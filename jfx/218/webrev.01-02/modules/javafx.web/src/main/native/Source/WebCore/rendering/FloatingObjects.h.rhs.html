<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/FloatingObjects.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2007 David Smith (catfish.man@gmail.com)
  5  * Copyright (C) 2003-2019 Apple Inc. All rights reserved.
  6  * Copyright (C) Research In Motion Limited 2010. All rights reserved.
  7  *
  8  * This library is free software; you can redistribute it and/or
  9  * modify it under the terms of the GNU Library General Public
 10  * License as published by the Free Software Foundation; either
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  */
 23 
 24 #pragma once
 25 
<a name="1" id="anc1"></a>
 26 #include &quot;RootInlineBox.h&quot;
 27 #include &lt;wtf/ListHashSet.h&gt;
 28 #include &lt;wtf/WeakPtr.h&gt;
 29 
 30 namespace WebCore {
 31 
 32 class RenderBlockFlow;
 33 class RenderBox;
 34 
<a name="2" id="anc2"></a><span class="line-added"> 35 template&lt;typename, typename&gt; class PODInterval;</span>
<span class="line-added"> 36 template&lt;typename, typename&gt; class PODIntervalTree;</span>
<span class="line-added"> 37 </span>
 38 class FloatingObject {
 39     WTF_MAKE_NONCOPYABLE(FloatingObject); WTF_MAKE_FAST_ALLOCATED;
 40 public:
 41     // Note that Type uses bits so you can use FloatLeftRight as a mask to query for both left and right.
 42     enum Type { FloatLeft = 1, FloatRight = 2, FloatLeftRight = 3 };
 43 
 44     static std::unique_ptr&lt;FloatingObject&gt; create(RenderBox&amp;);
 45     std::unique_ptr&lt;FloatingObject&gt; copyToNewContainer(LayoutSize, bool shouldPaint = false, bool isDescendant = false) const;
 46     std::unique_ptr&lt;FloatingObject&gt; cloneForNewParent() const;
 47 
 48     explicit FloatingObject(RenderBox&amp;);
 49     FloatingObject(RenderBox&amp;, Type, const LayoutRect&amp;, const LayoutSize&amp;, bool shouldPaint, bool isDescendant);
 50 
 51     Type type() const { return static_cast&lt;Type&gt;(m_type); }
 52     RenderBox&amp; renderer() const { return *m_renderer; }
 53 
 54     bool isPlaced() const { return m_isPlaced; }
 55     void setIsPlaced(bool placed = true) { m_isPlaced = placed; }
 56 
 57     LayoutUnit x() const { ASSERT(isPlaced()); return m_frameRect.x(); }
 58     LayoutUnit maxX() const { ASSERT(isPlaced()); return m_frameRect.maxX(); }
 59     LayoutUnit y() const { ASSERT(isPlaced()); return m_frameRect.y(); }
 60     LayoutUnit maxY() const { ASSERT(isPlaced()); return m_frameRect.maxY(); }
 61     LayoutUnit width() const { return m_frameRect.width(); }
 62     LayoutUnit height() const { return m_frameRect.height(); }
 63 
 64     void setX(LayoutUnit x) { ASSERT(!isInPlacedTree()); m_frameRect.setX(x); }
 65     void setY(LayoutUnit y) { ASSERT(!isInPlacedTree()); m_frameRect.setY(y); }
 66     void setWidth(LayoutUnit width) { ASSERT(!isInPlacedTree()); m_frameRect.setWidth(width); }
 67     void setHeight(LayoutUnit height) { ASSERT(!isInPlacedTree()); m_frameRect.setHeight(height); }
 68 
 69     void setMarginOffset(LayoutSize offset) { ASSERT(!isInPlacedTree()); m_marginOffset = offset; }
 70 
 71     const LayoutRect&amp; frameRect() const { ASSERT(isPlaced()); return m_frameRect; }
 72     void setFrameRect(const LayoutRect&amp; frameRect) { ASSERT(!isInPlacedTree()); m_frameRect = frameRect; }
 73 
 74     LayoutUnit paginationStrut() const { return m_paginationStrut; }
 75     void setPaginationStrut(LayoutUnit strut) { m_paginationStrut = strut; }
 76 
<a name="3" id="anc3"></a><span class="line-modified"> 77 #if ASSERT_ENABLED</span>
 78     bool isInPlacedTree() const { return m_isInPlacedTree; }
 79     void setIsInPlacedTree(bool value) { m_isInPlacedTree = value; }
 80 #endif
 81 
 82     bool shouldPaint() const { return m_shouldPaint; }
 83     void setShouldPaint(bool shouldPaint) { m_shouldPaint = shouldPaint; }
 84     bool isDescendant() const { return m_isDescendant; }
 85     void setIsDescendant(bool isDescendant) { m_isDescendant = isDescendant; }
 86 
 87     // FIXME: Callers of these methods are dangerous and should be whitelisted explicitly or removed.
 88     RootInlineBox* originatingLine() const { return m_originatingLine.get(); }
 89     void clearOriginatingLine() { m_originatingLine = nullptr; }
 90     void setOriginatingLine(RootInlineBox&amp; line) { m_originatingLine = makeWeakPtr(line); }
 91 
 92     LayoutSize locationOffsetOfBorderBox() const
 93     {
 94         ASSERT(isPlaced());
 95         return LayoutSize(m_frameRect.location().x() + m_marginOffset.width(), m_frameRect.location().y() + m_marginOffset.height());
 96     }
 97     LayoutSize marginOffset() const { ASSERT(isPlaced()); return m_marginOffset; }
 98     LayoutSize translationOffsetToAncestor() const;
 99 
<a name="4" id="anc4"></a>

100 private:
101     WeakPtr&lt;RenderBox&gt; m_renderer;
102     WeakPtr&lt;RootInlineBox&gt; m_originatingLine;
103     LayoutRect m_frameRect;
104     LayoutUnit m_paginationStrut;
105     LayoutSize m_marginOffset;
106 
107     unsigned m_type : 2; // Type (left or right aligned)
108     unsigned m_shouldPaint : 1;
109     unsigned m_isDescendant : 1;
110     unsigned m_isPlaced : 1;
<a name="5" id="anc5"></a><span class="line-modified">111 #if ASSERT_ENABLED</span>
112     unsigned m_isInPlacedTree : 1;
113 #endif
114 };
115 
116 // FIXME: This could be simplified if we made it inherit from PtrHash&lt;std::unique_ptr&lt;FloatingObject&gt;&gt; and
117 // changed PtrHashBase to have all of its hash and equal functions bottleneck through single functions (as
118 // is done here). That would allow us to only override those master hash and equal functions.
119 struct FloatingObjectHashFunctions {
120     typedef std::unique_ptr&lt;FloatingObject&gt; T;
121     typedef typename WTF::GetPtrHelper&lt;T&gt;::PtrType PtrType;
122 
123     static unsigned hash(PtrType key) { return PtrHash&lt;RenderBox*&gt;::hash(&amp;key-&gt;renderer()); }
124     static bool equal(PtrType a, PtrType b) { return &amp;a-&gt;renderer() == &amp;b-&gt;renderer(); }
125     static const bool safeToCompareToEmptyOrDeleted = true;
126 
127     static unsigned hash(const T&amp; key) { return hash(WTF::getPtr(key)); }
128     static bool equal(const T&amp; a, const T&amp; b) { return equal(WTF::getPtr(a), WTF::getPtr(b)); }
129     static bool equal(PtrType a, const T&amp; b) { return equal(a, WTF::getPtr(b)); }
130     static bool equal(const T&amp; a, PtrType b) { return equal(WTF::getPtr(a), b); }
131 };
132 struct FloatingObjectHashTranslator {
133     static unsigned hash(const RenderBox&amp; key) { return PtrHash&lt;const RenderBox*&gt;::hash(&amp;key); }
134     static bool equal(const std::unique_ptr&lt;FloatingObject&gt;&amp; a, const RenderBox&amp; b) { return &amp;a-&gt;renderer() == &amp;b; }
135 };
136 
137 typedef ListHashSet&lt;std::unique_ptr&lt;FloatingObject&gt;, FloatingObjectHashFunctions&gt; FloatingObjectSet;
138 
139 typedef PODInterval&lt;LayoutUnit, FloatingObject*&gt; FloatingObjectInterval;
140 typedef PODIntervalTree&lt;LayoutUnit, FloatingObject*&gt; FloatingObjectTree;
141 
142 // FIXME: This is really the same thing as FloatingObjectSet.
143 // Change clients to use that set directly, and replace the moveAllToFloatInfoMap function with a takeSet function.
144 typedef HashMap&lt;RenderBox*, std::unique_ptr&lt;FloatingObject&gt;&gt; RendererToFloatInfoMap;
145 
146 class FloatingObjects {
147     WTF_MAKE_NONCOPYABLE(FloatingObjects); WTF_MAKE_FAST_ALLOCATED;
148 public:
149     explicit FloatingObjects(const RenderBlockFlow&amp;);
150     ~FloatingObjects();
151 
152     void clear();
153     void moveAllToFloatInfoMap(RendererToFloatInfoMap&amp;);
154     FloatingObject* add(std::unique_ptr&lt;FloatingObject&gt;);
155     void remove(FloatingObject*);
156     void addPlacedObject(FloatingObject*);
157     void removePlacedObject(FloatingObject*);
158     void setHorizontalWritingMode(bool b = true) { m_horizontalWritingMode = b; }
159 
160     bool hasLeftObjects() const { return m_leftObjectsCount &gt; 0; }
161     bool hasRightObjects() const { return m_rightObjectsCount &gt; 0; }
162     const FloatingObjectSet&amp; set() const { return m_set; }
163     void clearLineBoxTreePointers();
164 
165     LayoutUnit logicalLeftOffset(LayoutUnit fixedOffset, LayoutUnit logicalTop, LayoutUnit logicalHeight);
166     LayoutUnit logicalRightOffset(LayoutUnit fixedOffset, LayoutUnit logicalTop, LayoutUnit logicalHeight);
167 
168     LayoutUnit logicalLeftOffsetForPositioningFloat(LayoutUnit fixedOffset, LayoutUnit logicalTop, LayoutUnit* heightRemaining);
169     LayoutUnit logicalRightOffsetForPositioningFloat(LayoutUnit fixedOffset, LayoutUnit logicalTop, LayoutUnit* heightRemaining);
170 
171     LayoutUnit findNextFloatLogicalBottomBelow(LayoutUnit logicalHeight);
172     LayoutUnit findNextFloatLogicalBottomBelowForBlock(LayoutUnit logicalHeight);
173 
174 private:
175     const RenderBlockFlow&amp; renderer() const { return *m_renderer; }
176     void computePlacedFloatsTree();
177     const FloatingObjectTree* placedFloatsTree();
178     void increaseObjectsCount(FloatingObject::Type);
179     void decreaseObjectsCount(FloatingObject::Type);
180     FloatingObjectInterval intervalForFloatingObject(FloatingObject*);
181 
182     FloatingObjectSet m_set;
183     std::unique_ptr&lt;FloatingObjectTree&gt; m_placedFloatsTree;
184     unsigned m_leftObjectsCount;
185     unsigned m_rightObjectsCount;
186     bool m_horizontalWritingMode;
187     WeakPtr&lt;const RenderBlockFlow&gt; m_renderer;
188 };
189 
<a name="6" id="anc6"></a>

190 #ifndef NDEBUG
<a name="7" id="anc7"></a><span class="line-modified">191 TextStream&amp; operator&lt;&lt;(TextStream&amp;, const FloatingObject&amp;);</span>









192 #endif
<a name="8" id="anc8"></a><span class="line-added">193 </span>
<span class="line-added">194 } // namespace WebCore</span>
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
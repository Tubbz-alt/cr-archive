<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/layout/layouttree/LayoutBox.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LayoutBox.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="LayoutChildIterator.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/layouttree/LayoutBox.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,34 ***</span>
  
  #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  
  #include &quot;LayoutReplaced.h&quot;
  #include &quot;RenderStyle.h&quot;
  #include &lt;wtf/IsoMalloc.h&gt;
  #include &lt;wtf/WeakPtr.h&gt;
  
  namespace WebCore {
  
  namespace Layout {
  
  class Container;
  class TreeBuilder;
  
  class Box : public CanMakeWeakPtr&lt;Box&gt; {
      WTF_MAKE_ISO_ALLOCATED(Box);
  public:
      enum class ElementType {
          Document,
          Body,
          TableWrapperBox, // The table generates a principal block container box called the table wrapper box that contains the table box and any caption boxes.
          TableBox, // The table box is a block-level box that contains the table&#39;s internal table boxes.
<span class="line-removed">-         TableColumn,</span>
<span class="line-removed">-         TableRow,</span>
<span class="line-removed">-         TableColumnGroup,</span>
<span class="line-removed">-         TableHeaderGroup,</span>
<span class="line-removed">-         TableBodyGroup,</span>
<span class="line-removed">-         TableFooterGroup,</span>
          Image,
          IFrame,
          HardLineBreak,
          GenericElement
      };
<span class="line-new-header">--- 27,34 ---</span>
  
  #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  
  #include &quot;LayoutReplaced.h&quot;
  #include &quot;RenderStyle.h&quot;
<span class="line-added">+ #include &quot;TextContext.h&quot;</span>
  #include &lt;wtf/IsoMalloc.h&gt;
  #include &lt;wtf/WeakPtr.h&gt;
  
  namespace WebCore {
  
<span class="line-added">+ namespace Display {</span>
<span class="line-added">+ class Box;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  namespace Layout {
  
  class Container;
<span class="line-added">+ class LayoutState;</span>
  class TreeBuilder;
  
  class Box : public CanMakeWeakPtr&lt;Box&gt; {
      WTF_MAKE_ISO_ALLOCATED(Box);
  public:
      enum class ElementType {
          Document,
          Body,
          TableWrapperBox, // The table generates a principal block container box called the table wrapper box that contains the table box and any caption boxes.
          TableBox, // The table box is a block-level box that contains the table&#39;s internal table boxes.
          Image,
          IFrame,
          HardLineBreak,
          GenericElement
      };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 68,19 ***</span>
          ContainerFlag         = 1 &lt;&lt; 1
      };
      typedef unsigned BaseTypeFlags;
  
      Box(Optional&lt;ElementAttributes&gt;, RenderStyle&amp;&amp;);
<span class="line-modified">!     Box(String textContent, RenderStyle&amp;&amp;);</span>
<span class="line-modified">!     virtual ~Box();</span>
  
      bool establishesFormattingContext() const;
      bool establishesBlockFormattingContext() const;
<span class="line-removed">-     bool establishesTableFormattingContext() const;</span>
<span class="line-removed">-     bool establishesBlockFormattingContextOnly() const;</span>
      bool establishesInlineFormattingContext() const;
<span class="line-modified">!     bool establishesInlineFormattingContextOnly() const;</span>
  
      bool isInFlow() const { return !isFloatingOrOutOfFlowPositioned(); }
      bool isPositioned() const { return isInFlowPositioned() || isOutOfFlowPositioned(); }
      bool isInFlowPositioned() const { return isRelativelyPositioned() || isStickyPositioned(); }
      bool isOutOfFlowPositioned() const { return isAbsolutelyPositioned(); }
<span class="line-new-header">--- 68,18 ---</span>
          ContainerFlag         = 1 &lt;&lt; 1
      };
      typedef unsigned BaseTypeFlags;
  
      Box(Optional&lt;ElementAttributes&gt;, RenderStyle&amp;&amp;);
<span class="line-modified">!     Box(TextContext&amp;&amp;, RenderStyle&amp;&amp;);</span>
<span class="line-modified">!     ~Box();</span>
  
      bool establishesFormattingContext() const;
      bool establishesBlockFormattingContext() const;
      bool establishesInlineFormattingContext() const;
<span class="line-modified">!     bool establishesTableFormattingContext() const;</span>
<span class="line-added">+     bool establishesIndependentFormattingContext() const;</span>
  
      bool isInFlow() const { return !isFloatingOrOutOfFlowPositioned(); }
      bool isPositioned() const { return isInFlowPositioned() || isOutOfFlowPositioned(); }
      bool isInFlowPositioned() const { return isRelativelyPositioned() || isStickyPositioned(); }
      bool isOutOfFlowPositioned() const { return isAbsolutelyPositioned(); }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 101,28 ***</span>
      const Container&amp; initialContainingBlock() const;
  
      bool isDescendantOf(const Container&amp;) const;
      bool isContainingBlockDescendantOf(const Container&amp;) const;
  
<span class="line-modified">!     bool isAnonymous() const { return !m_elementAttributes; }</span>
  
      bool isBlockLevelBox() const;
      bool isInlineLevelBox() const;
      bool isInlineBlockBox() const;
      bool isBlockContainerBox() const;
      bool isInitialContainingBlock() const;
  
      bool isDocumentBox() const { return m_elementAttributes &amp;&amp; m_elementAttributes.value().elementType == ElementType::Document; }
      bool isBodyBox() const { return m_elementAttributes &amp;&amp; m_elementAttributes.value().elementType == ElementType::Body; }
      bool isTableWrapperBox() const { return m_elementAttributes &amp;&amp; m_elementAttributes.value().elementType == ElementType::TableWrapperBox; }
      bool isTableBox() const { return m_elementAttributes &amp;&amp; m_elementAttributes.value().elementType == ElementType::TableBox; }
      bool isTableCaption() const { return style().display() == DisplayType::TableCaption; }
<span class="line-modified">!     bool isTableHeader() const { return m_elementAttributes &amp;&amp; m_elementAttributes.value().elementType == ElementType::TableHeaderGroup; }</span>
<span class="line-modified">!     bool isTableBody() const { return m_elementAttributes &amp;&amp; m_elementAttributes.value().elementType == ElementType::TableBodyGroup; }</span>
<span class="line-modified">!     bool isTableFooter() const { return m_elementAttributes &amp;&amp; m_elementAttributes.value().elementType == ElementType::TableFooterGroup; }</span>
<span class="line-modified">!     bool isTableRow() const { return m_elementAttributes &amp;&amp; m_elementAttributes.value().elementType == ElementType::TableRow; }</span>
<span class="line-modified">!     bool isTableCell() const { return style().display() == DisplayType::TableCell;; }</span>
      bool isReplaced() const { return isImage() || isIFrame(); }
      bool isIFrame() const { return m_elementAttributes &amp;&amp; m_elementAttributes.value().elementType == ElementType::IFrame; }
      bool isImage() const { return m_elementAttributes &amp;&amp; m_elementAttributes.value().elementType == ElementType::Image; }
      bool isLineBreakBox() const { return m_elementAttributes &amp;&amp; m_elementAttributes.value().elementType == ElementType::HardLineBreak; }
  
<span class="line-new-header">--- 100,33 ---</span>
      const Container&amp; initialContainingBlock() const;
  
      bool isDescendantOf(const Container&amp;) const;
      bool isContainingBlockDescendantOf(const Container&amp;) const;
  
<span class="line-modified">!     bool isAnonymous() const { return m_isAnonymous; }</span>
  
      bool isBlockLevelBox() const;
      bool isInlineLevelBox() const;
<span class="line-added">+     bool isInlineBox() const;</span>
<span class="line-added">+     bool isAtomicInlineLevelBox() const;</span>
      bool isInlineBlockBox() const;
<span class="line-added">+     bool isInlineTableBox() const;</span>
      bool isBlockContainerBox() const;
      bool isInitialContainingBlock() const;
  
      bool isDocumentBox() const { return m_elementAttributes &amp;&amp; m_elementAttributes.value().elementType == ElementType::Document; }
      bool isBodyBox() const { return m_elementAttributes &amp;&amp; m_elementAttributes.value().elementType == ElementType::Body; }
      bool isTableWrapperBox() const { return m_elementAttributes &amp;&amp; m_elementAttributes.value().elementType == ElementType::TableWrapperBox; }
      bool isTableBox() const { return m_elementAttributes &amp;&amp; m_elementAttributes.value().elementType == ElementType::TableBox; }
      bool isTableCaption() const { return style().display() == DisplayType::TableCaption; }
<span class="line-modified">!     bool isTableHeader() const { return style().display() == DisplayType::TableHeaderGroup; }</span>
<span class="line-modified">!     bool isTableBody() const { return style().display() == DisplayType::TableRowGroup; }</span>
<span class="line-modified">!     bool isTableFooter() const { return style().display() == DisplayType::TableFooterGroup; }</span>
<span class="line-modified">!     bool isTableRow() const { return style().display() == DisplayType::TableRow; }</span>
<span class="line-modified">!     bool isTableColumnGroup() const { return style().display() == DisplayType::TableColumnGroup; }</span>
<span class="line-added">+     bool isTableColumn() const { return style().display() == DisplayType::TableColumn; }</span>
<span class="line-added">+     bool isTableCell() const { return style().display() == DisplayType::TableCell; }</span>
      bool isReplaced() const { return isImage() || isIFrame(); }
      bool isIFrame() const { return m_elementAttributes &amp;&amp; m_elementAttributes.value().elementType == ElementType::IFrame; }
      bool isImage() const { return m_elementAttributes &amp;&amp; m_elementAttributes.value().elementType == ElementType::Image; }
      bool isLineBreakBox() const { return m_elementAttributes &amp;&amp; m_elementAttributes.value().elementType == ElementType::HardLineBreak; }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 132,52 ***</span>
      const Box* nextInFlowOrFloatingSibling() const;
      const Box* previousSibling() const { return m_previousSibling; }
      const Box* previousInFlowSibling() const;
      const Box* previousInFlowOrFloatingSibling() const;
  
      bool isContainer() const { return m_baseTypeFlags &amp; ContainerFlag; }
<span class="line-removed">-     bool isBlockContainer() const { return isBlockLevelBox() &amp;&amp; isContainer(); }</span>
<span class="line-removed">-     bool isInlineContainer() const { return isInlineLevelBox() &amp;&amp; isContainer(); }</span>
  
      bool isPaddingApplicable() const;
      bool isOverflowVisible() const;
  
      const RenderStyle&amp; style() const { return m_style; }
  
      const Replaced* replaced() const;
      // FIXME: Temporary until after intrinsic size change is tracked by Replaced.
      Replaced* replaced();
<span class="line-modified">!     bool hasTextContent() const;</span>
<span class="line-modified">!     String textContent() const;</span>
  
      // FIXME: Find a better place for random DOM things.
      void setRowSpan(unsigned);
<span class="line-removed">-     void setColumnSpan(unsigned);</span>
      unsigned rowSpan() const;
      unsigned columnSpan() const;
  
      void setParent(Container&amp; parent) { m_parent = &amp;parent; }
      void setNextSibling(Box&amp; nextSibling) { m_nextSibling = &amp;nextSibling; }
      void setPreviousSibling(Box&amp; previousSibling) { m_previousSibling = &amp;previousSibling; }
  
      void setIsAnonymous() { m_isAnonymous = true; }
  
  protected:
<span class="line-modified">!     Box(Optional&lt;ElementAttributes&gt;, RenderStyle&amp;&amp;, BaseTypeFlags);</span>
  
  private:
<span class="line-removed">-     void setTextContent(String);</span>
<span class="line-removed">- </span>
      class BoxRareData {
          WTF_MAKE_FAST_ALLOCATED;
      public:
          BoxRareData() = default;
  
<span class="line-removed">-         String textContent;</span>
          std::unique_ptr&lt;Replaced&gt; replaced;
          unsigned rowSpan { 1 };
          unsigned columnSpan { 1 };
      };
  
      bool hasRareData() const { return m_hasRareData; }
      void setHasRareData(bool hasRareData) { m_hasRareData = hasRareData; }
      const BoxRareData&amp; rareData() const;
<span class="line-new-header">--- 136,60 ---</span>
      const Box* nextInFlowOrFloatingSibling() const;
      const Box* previousSibling() const { return m_previousSibling; }
      const Box* previousInFlowSibling() const;
      const Box* previousInFlowOrFloatingSibling() const;
  
<span class="line-added">+     // FIXME: This is currently needed for style updates.</span>
<span class="line-added">+     Box* nextSibling() { return m_nextSibling; }</span>
<span class="line-added">+ </span>
      bool isContainer() const { return m_baseTypeFlags &amp; ContainerFlag; }
  
      bool isPaddingApplicable() const;
      bool isOverflowVisible() const;
  
<span class="line-added">+     void updateStyle(const RenderStyle&amp; newStyle);</span>
      const RenderStyle&amp; style() const { return m_style; }
  
      const Replaced* replaced() const;
      // FIXME: Temporary until after intrinsic size change is tracked by Replaced.
      Replaced* replaced();
<span class="line-modified">!     bool hasTextContent() const { return !!m_textContext; }</span>
<span class="line-modified">!     const Optional&lt;TextContext&gt;&amp; textContext() const { return m_textContext; }</span>
  
      // FIXME: Find a better place for random DOM things.
      void setRowSpan(unsigned);
      unsigned rowSpan() const;
<span class="line-added">+ </span>
<span class="line-added">+     void setColumnSpan(unsigned);</span>
      unsigned columnSpan() const;
  
<span class="line-added">+     void setColumnWidth(LayoutUnit);</span>
<span class="line-added">+     Optional&lt;LayoutUnit&gt; columnWidth() const;</span>
<span class="line-added">+ </span>
      void setParent(Container&amp; parent) { m_parent = &amp;parent; }
      void setNextSibling(Box&amp; nextSibling) { m_nextSibling = &amp;nextSibling; }
      void setPreviousSibling(Box&amp; previousSibling) { m_previousSibling = &amp;previousSibling; }
  
      void setIsAnonymous() { m_isAnonymous = true; }
  
<span class="line-added">+     bool canCacheForLayoutState(const LayoutState&amp;) const;</span>
<span class="line-added">+     Display::Box* cachedDisplayBoxForLayoutState(const LayoutState&amp;) const;</span>
<span class="line-added">+     void setCachedDisplayBoxForLayoutState(LayoutState&amp;, std::unique_ptr&lt;Display::Box&gt;) const;</span>
<span class="line-added">+ </span>
  protected:
<span class="line-modified">!     Box(Optional&lt;ElementAttributes&gt;, Optional&lt;TextContext&gt;, RenderStyle&amp;&amp;, BaseTypeFlags);</span>
  
  private:
      class BoxRareData {
          WTF_MAKE_FAST_ALLOCATED;
      public:
          BoxRareData() = default;
  
          std::unique_ptr&lt;Replaced&gt; replaced;
          unsigned rowSpan { 1 };
          unsigned columnSpan { 1 };
<span class="line-added">+         Optional&lt;LayoutUnit&gt; columnWidth;</span>
      };
  
      bool hasRareData() const { return m_hasRareData; }
      void setHasRareData(bool hasRareData) { m_hasRareData = hasRareData; }
      const BoxRareData&amp; rareData() const;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 193,10 ***</span>
<span class="line-new-header">--- 205,16 ---</span>
  
      Container* m_parent { nullptr };
      Box* m_previousSibling { nullptr };
      Box* m_nextSibling { nullptr };
  
<span class="line-added">+     const Optional&lt;TextContext&gt; m_textContext;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // First LayoutState gets a direct cache.</span>
<span class="line-added">+     mutable WeakPtr&lt;LayoutState&gt; m_cachedLayoutState;</span>
<span class="line-added">+     mutable std::unique_ptr&lt;Display::Box&gt; m_cachedDisplayBoxForLayoutState;</span>
<span class="line-added">+ </span>
      unsigned m_baseTypeFlags : 6;
      bool m_hasRareData : 1;
      bool m_isAnonymous : 1;
  };
  
</pre>
<center><a href="LayoutBox.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="LayoutChildIterator.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../makeprop.pl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSParser.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * version 2 of the License, or (at your option) any later version.
 16  *
 17  * This library is distributed in the hope that it will be useful,
 18  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 19  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 20  * Library General Public License for more details.
 21  *
 22  * You should have received a copy of the GNU Library General Public License
 23  * along with this library; see the file COPYING.LIB.  If not, write to
 24  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 25  * Boston, MA 02110-1301, USA.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;CSSParser.h&quot;
 30 
 31 #include &quot;CSSCustomPropertyValue.h&quot;
 32 #include &quot;CSSKeyframeRule.h&quot;
 33 #include &quot;CSSParserFastPaths.h&quot;
 34 #include &quot;CSSParserImpl.h&quot;

 35 #include &quot;CSSPendingSubstitutionValue.h&quot;
 36 #include &quot;CSSPropertyParser.h&quot;

 37 #include &quot;CSSSelectorParser.h&quot;
 38 #include &quot;CSSSupportsParser.h&quot;
 39 #include &quot;CSSTokenizer.h&quot;

 40 #include &quot;CSSVariableData.h&quot;
 41 #include &quot;CSSVariableReferenceValue.h&quot;
 42 #include &quot;Document.h&quot;
 43 #include &quot;Element.h&quot;
 44 #include &quot;Page.h&quot;
 45 #include &quot;RenderStyle.h&quot;
 46 #include &quot;RenderTheme.h&quot;
<span class="line-removed"> 47 #include &quot;RuntimeEnabledFeatures.h&quot;</span>
 48 #include &quot;Settings.h&quot;

 49 #include &quot;StyleColor.h&quot;
 50 #include &quot;StyleResolver.h&quot;
 51 #include &quot;StyleRule.h&quot;
 52 #include &quot;StyleSheetContents.h&quot;
 53 #include &lt;wtf/NeverDestroyed.h&gt;
 54 #include &lt;wtf/text/StringBuilder.h&gt;
 55 
 56 namespace WebCore {
 57 
 58 CSSParser::CSSParser(const CSSParserContext&amp; context)
 59     : m_context(context)
 60 {
 61 }
 62 
 63 CSSParser::~CSSParser() = default;
 64 
 65 void CSSParser::parseSheet(StyleSheetContents* sheet, const String&amp; string, RuleParsing ruleParsing)
 66 {
 67     return CSSParserImpl::parseStyleSheet(string, m_context, sheet, ruleParsing);
 68 }
</pre>
<hr />
<pre>
 83     return downcast&lt;StyleRuleKeyframe&gt;(keyframe.get());
 84 }
 85 
 86 bool CSSParser::parseSupportsCondition(const String&amp; condition)
 87 {
 88     CSSParserImpl parser(m_context, condition);
 89     return CSSSupportsParser::supportsCondition(parser.tokenizer()-&gt;tokenRange(), parser, CSSSupportsParser::ForWindowCSS) == CSSSupportsParser::Supported;
 90 }
 91 
 92 Color CSSParser::parseColor(const String&amp; string, bool strict)
 93 {
 94     if (string.isEmpty())
 95         return Color();
 96 
 97     // Try named colors first.
 98     Color namedColor { string };
 99     if (namedColor.isValid())
100         return namedColor;
101 
102     // Try the fast path to parse hex and rgb.
<span class="line-modified">103     RefPtr&lt;CSSValue&gt; value = CSSParserFastPaths::parseColor(string, strict ? HTMLStandardMode : HTMLQuirksMode);</span>
104 
105     // If that fails, try the full parser.
106     if (!value)
107         value = parseSingleValue(CSSPropertyColor, string, strictCSSParserContext());
108     if (!value || !value-&gt;isPrimitiveValue())
109         return Color();
110     const auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*value);
111     if (!primitiveValue.isRGBColor())
112         return Color();
113     return primitiveValue.color();
114 }
115 





















116 Color CSSParser::parseSystemColor(const String&amp; string, const CSSParserContext* context)
117 {
118     CSSValueID id = cssValueKeywordID(string);
119     if (!StyleColor::isSystemColor(id))
120         return Color();
121 
122     OptionSet&lt;StyleColor::Options&gt; options;
123     if (context &amp;&amp; context-&gt;useSystemAppearance)
124         options.add(StyleColor::Options::UseSystemAppearance);
125     return RenderTheme::singleton().systemColor(id, options);
126 }
127 
128 RefPtr&lt;CSSValue&gt; CSSParser::parseSingleValue(CSSPropertyID propertyID, const String&amp; string, const CSSParserContext&amp; context)
129 {
130     if (string.isEmpty())
131         return nullptr;
132     if (RefPtr&lt;CSSValue&gt; value = CSSParserFastPaths::maybeParseValue(propertyID, string, context.mode))
133         return value;
134     CSSTokenizer tokenizer(string);
135     return CSSPropertyParser::parseSingleValue(propertyID, tokenizer.tokenRange(), context);
</pre>
<hr />
<pre>
160 {
161     CSSTokenizer tokenizer(string);
162     selectorList = CSSSelectorParser::parseSelector(tokenizer.tokenRange(), m_context, nullptr);
163 }
164 
165 Ref&lt;ImmutableStyleProperties&gt; CSSParser::parseInlineStyleDeclaration(const String&amp; string, const Element* element)
166 {
167     return CSSParserImpl::parseInlineStyleDeclaration(string, element);
168 }
169 
170 bool CSSParser::parseDeclaration(MutableStyleProperties&amp; declaration, const String&amp; string)
171 {
172     return CSSParserImpl::parseDeclarationList(&amp;declaration, string, m_context);
173 }
174 
175 void CSSParser::parseDeclarationForInspector(const CSSParserContext&amp; context, const String&amp; string, CSSParserObserver&amp; observer)
176 {
177     CSSParserImpl::parseDeclarationListForInspector(string, context, observer);
178 }
179 
<span class="line-modified">180 RefPtr&lt;CSSValue&gt; CSSParser::parseValueWithVariableReferences(CSSPropertyID propID, const CSSValue&amp; value, ApplyCascadedPropertyState&amp; state)</span>
181 {
182     ASSERT((propID == CSSPropertyCustom &amp;&amp; value.isCustomPropertyValue()) || (propID != CSSPropertyCustom &amp;&amp; !value.isCustomPropertyValue()));
<span class="line-modified">183     auto&amp; style = *state.styleResolver-&gt;style();</span>
184     auto direction = style.direction();
185     auto writingMode = style.writingMode();
186 
187     if (value.isPendingSubstitutionValue()) {
188         // FIXME: Should have a resolvedShorthands cache to stop this from being done
189         // over and over for each longhand value.
190         const CSSPendingSubstitutionValue&amp; pendingSubstitution = downcast&lt;CSSPendingSubstitutionValue&gt;(value);
191         CSSPropertyID shorthandID = pendingSubstitution.shorthandPropertyId();
192         if (CSSProperty::isDirectionAwareProperty(shorthandID))
193             shorthandID = CSSProperty::resolveDirectionAwareProperty(shorthandID, direction, writingMode);
194         CSSVariableReferenceValue* shorthandValue = pendingSubstitution.shorthandValue();
195 
<span class="line-modified">196         auto resolvedData = shorthandValue-&gt;resolveVariableReferences(state);</span>
197         if (!resolvedData)
198             return nullptr;
199         Vector&lt;CSSParserToken&gt; resolvedTokens = resolvedData-&gt;tokens();
200 
201         ParsedPropertyVector parsedProperties;
<span class="line-modified">202         if (!CSSPropertyParser::parseValue(shorthandID, false, resolvedTokens, m_context, parsedProperties, StyleRule::Style))</span>
203             return nullptr;
204 
205         for (auto&amp; property : parsedProperties) {
206             if (property.id() == propID)
207                 return property.value();
208         }
209 
210         return nullptr;
211     }
212 
213     if (value.isVariableReferenceValue()) {
214         const CSSVariableReferenceValue&amp; valueWithReferences = downcast&lt;CSSVariableReferenceValue&gt;(value);
<span class="line-modified">215         auto resolvedData = valueWithReferences.resolveVariableReferences(state);</span>
216         if (!resolvedData)
217             return nullptr;
218         return CSSPropertyParser::parseSingleValue(propID, resolvedData-&gt;tokens(), m_context);
219     }
220 
221     const auto&amp; customPropValue = downcast&lt;CSSCustomPropertyValue&gt;(value);
222     const auto&amp; valueWithReferences = WTF::get&lt;Ref&lt;CSSVariableReferenceValue&gt;&gt;(customPropValue.value()).get();
223 
224     auto&amp; name = downcast&lt;CSSCustomPropertyValue&gt;(value).name();
<span class="line-modified">225     auto* registered = state.styleResolver-&gt;document().getCSSRegisteredCustomPropertySet().get(name);</span>
226     auto&amp; syntax = registered ? registered-&gt;syntax : &quot;*&quot;;
<span class="line-modified">227     auto resolvedData = valueWithReferences.resolveVariableReferences(state);</span>
228 
229     if (!resolvedData)
230         return nullptr;
231 
232     // FIXME handle REM cycles.
233     HashSet&lt;CSSPropertyID&gt; dependencies;
234     CSSPropertyParser::collectParsedCustomPropertyValueDependencies(syntax, false, dependencies, resolvedData-&gt;tokens(), m_context);
235 
236     for (auto id : dependencies)
<span class="line-modified">237         state.styleResolver-&gt;applyCascadedProperties(id, id, state);</span>
238 
<span class="line-modified">239     return CSSPropertyParser::parseTypedCustomPropertyValue(name, syntax, resolvedData-&gt;tokens(), *state.styleResolver, m_context);</span>
240 }
241 
242 std::unique_ptr&lt;Vector&lt;double&gt;&gt; CSSParser::parseKeyframeKeyList(const String&amp; selector)
243 {
244     return CSSParserImpl::parseKeyframeKeyList(selector);
245 }
246 
247 RefPtr&lt;CSSValue&gt; CSSParser::parseFontFaceDescriptor(CSSPropertyID propertyID, const String&amp; propertyValue, const CSSParserContext&amp; context)
248 {
249     String string = makeString(&quot;@font-face { &quot;, getPropertyNameString(propertyID), &quot; : &quot;, propertyValue, &quot;; }&quot;);
250     RefPtr&lt;StyleRuleBase&gt; rule = parseRule(context, nullptr, string);
251     if (!rule || !rule-&gt;isFontFaceRule())
252         return nullptr;
253     return downcast&lt;StyleRuleFontFace&gt;(*rule.get()).properties().getPropertyCSSValue(propertyID);
254 }
255 
256 }
</pre>
</td>
<td>
<hr />
<pre>
 15  * version 2 of the License, or (at your option) any later version.
 16  *
 17  * This library is distributed in the hope that it will be useful,
 18  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 19  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 20  * Library General Public License for more details.
 21  *
 22  * You should have received a copy of the GNU Library General Public License
 23  * along with this library; see the file COPYING.LIB.  If not, write to
 24  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 25  * Boston, MA 02110-1301, USA.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;CSSParser.h&quot;
 30 
 31 #include &quot;CSSCustomPropertyValue.h&quot;
 32 #include &quot;CSSKeyframeRule.h&quot;
 33 #include &quot;CSSParserFastPaths.h&quot;
 34 #include &quot;CSSParserImpl.h&quot;
<span class="line-added"> 35 #include &quot;CSSParserTokenRange.h&quot;</span>
 36 #include &quot;CSSPendingSubstitutionValue.h&quot;
 37 #include &quot;CSSPropertyParser.h&quot;
<span class="line-added"> 38 #include &quot;CSSPropertyParserHelpers.h&quot;</span>
 39 #include &quot;CSSSelectorParser.h&quot;
 40 #include &quot;CSSSupportsParser.h&quot;
 41 #include &quot;CSSTokenizer.h&quot;
<span class="line-added"> 42 #include &quot;CSSValuePool.h&quot;</span>
 43 #include &quot;CSSVariableData.h&quot;
 44 #include &quot;CSSVariableReferenceValue.h&quot;
 45 #include &quot;Document.h&quot;
 46 #include &quot;Element.h&quot;
 47 #include &quot;Page.h&quot;
 48 #include &quot;RenderStyle.h&quot;
 49 #include &quot;RenderTheme.h&quot;

 50 #include &quot;Settings.h&quot;
<span class="line-added"> 51 #include &quot;StyleBuilder.h&quot;</span>
 52 #include &quot;StyleColor.h&quot;
 53 #include &quot;StyleResolver.h&quot;
 54 #include &quot;StyleRule.h&quot;
 55 #include &quot;StyleSheetContents.h&quot;
 56 #include &lt;wtf/NeverDestroyed.h&gt;
 57 #include &lt;wtf/text/StringBuilder.h&gt;
 58 
 59 namespace WebCore {
 60 
 61 CSSParser::CSSParser(const CSSParserContext&amp; context)
 62     : m_context(context)
 63 {
 64 }
 65 
 66 CSSParser::~CSSParser() = default;
 67 
 68 void CSSParser::parseSheet(StyleSheetContents* sheet, const String&amp; string, RuleParsing ruleParsing)
 69 {
 70     return CSSParserImpl::parseStyleSheet(string, m_context, sheet, ruleParsing);
 71 }
</pre>
<hr />
<pre>
 86     return downcast&lt;StyleRuleKeyframe&gt;(keyframe.get());
 87 }
 88 
 89 bool CSSParser::parseSupportsCondition(const String&amp; condition)
 90 {
 91     CSSParserImpl parser(m_context, condition);
 92     return CSSSupportsParser::supportsCondition(parser.tokenizer()-&gt;tokenRange(), parser, CSSSupportsParser::ForWindowCSS) == CSSSupportsParser::Supported;
 93 }
 94 
 95 Color CSSParser::parseColor(const String&amp; string, bool strict)
 96 {
 97     if (string.isEmpty())
 98         return Color();
 99 
100     // Try named colors first.
101     Color namedColor { string };
102     if (namedColor.isValid())
103         return namedColor;
104 
105     // Try the fast path to parse hex and rgb.
<span class="line-modified">106     RefPtr&lt;CSSValue&gt; value = CSSParserFastPaths::parseColor(string, strict ? HTMLStandardMode : HTMLQuirksMode, CSSValuePool::singleton());</span>
107 
108     // If that fails, try the full parser.
109     if (!value)
110         value = parseSingleValue(CSSPropertyColor, string, strictCSSParserContext());
111     if (!value || !value-&gt;isPrimitiveValue())
112         return Color();
113     const auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*value);
114     if (!primitiveValue.isRGBColor())
115         return Color();
116     return primitiveValue.color();
117 }
118 
<span class="line-added">119 Color CSSParser::parseColorWorkerSafe(const String&amp; string, CSSValuePool&amp; valuePool, bool strict)</span>
<span class="line-added">120 {</span>
<span class="line-added">121     if (string.isEmpty())</span>
<span class="line-added">122         return Color();</span>
<span class="line-added">123 </span>
<span class="line-added">124     // Try named colors first.</span>
<span class="line-added">125     Color namedColor { string };</span>
<span class="line-added">126     if (namedColor.isValid())</span>
<span class="line-added">127         return namedColor;</span>
<span class="line-added">128 </span>
<span class="line-added">129     // Try the fast path to parse hex and rgb.</span>
<span class="line-added">130     RefPtr&lt;CSSValue&gt; value = CSSParserFastPaths::parseColor(string, strict ? HTMLStandardMode : HTMLQuirksMode, valuePool);</span>
<span class="line-added">131 </span>
<span class="line-added">132     if (!value || !value-&gt;isPrimitiveValue())</span>
<span class="line-added">133         return Color();</span>
<span class="line-added">134     const auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*value);</span>
<span class="line-added">135     if (!primitiveValue.isRGBColor())</span>
<span class="line-added">136         return Color();</span>
<span class="line-added">137     return primitiveValue.color();</span>
<span class="line-added">138 }</span>
<span class="line-added">139 </span>
140 Color CSSParser::parseSystemColor(const String&amp; string, const CSSParserContext* context)
141 {
142     CSSValueID id = cssValueKeywordID(string);
143     if (!StyleColor::isSystemColor(id))
144         return Color();
145 
146     OptionSet&lt;StyleColor::Options&gt; options;
147     if (context &amp;&amp; context-&gt;useSystemAppearance)
148         options.add(StyleColor::Options::UseSystemAppearance);
149     return RenderTheme::singleton().systemColor(id, options);
150 }
151 
152 RefPtr&lt;CSSValue&gt; CSSParser::parseSingleValue(CSSPropertyID propertyID, const String&amp; string, const CSSParserContext&amp; context)
153 {
154     if (string.isEmpty())
155         return nullptr;
156     if (RefPtr&lt;CSSValue&gt; value = CSSParserFastPaths::maybeParseValue(propertyID, string, context.mode))
157         return value;
158     CSSTokenizer tokenizer(string);
159     return CSSPropertyParser::parseSingleValue(propertyID, tokenizer.tokenRange(), context);
</pre>
<hr />
<pre>
184 {
185     CSSTokenizer tokenizer(string);
186     selectorList = CSSSelectorParser::parseSelector(tokenizer.tokenRange(), m_context, nullptr);
187 }
188 
189 Ref&lt;ImmutableStyleProperties&gt; CSSParser::parseInlineStyleDeclaration(const String&amp; string, const Element* element)
190 {
191     return CSSParserImpl::parseInlineStyleDeclaration(string, element);
192 }
193 
194 bool CSSParser::parseDeclaration(MutableStyleProperties&amp; declaration, const String&amp; string)
195 {
196     return CSSParserImpl::parseDeclarationList(&amp;declaration, string, m_context);
197 }
198 
199 void CSSParser::parseDeclarationForInspector(const CSSParserContext&amp; context, const String&amp; string, CSSParserObserver&amp; observer)
200 {
201     CSSParserImpl::parseDeclarationListForInspector(string, context, observer);
202 }
203 
<span class="line-modified">204 RefPtr&lt;CSSValue&gt; CSSParser::parseValueWithVariableReferences(CSSPropertyID propID, const CSSValue&amp; value, Style::BuilderState&amp; builderState)</span>
205 {
206     ASSERT((propID == CSSPropertyCustom &amp;&amp; value.isCustomPropertyValue()) || (propID != CSSPropertyCustom &amp;&amp; !value.isCustomPropertyValue()));
<span class="line-modified">207     auto&amp; style = builderState.style();</span>
208     auto direction = style.direction();
209     auto writingMode = style.writingMode();
210 
211     if (value.isPendingSubstitutionValue()) {
212         // FIXME: Should have a resolvedShorthands cache to stop this from being done
213         // over and over for each longhand value.
214         const CSSPendingSubstitutionValue&amp; pendingSubstitution = downcast&lt;CSSPendingSubstitutionValue&gt;(value);
215         CSSPropertyID shorthandID = pendingSubstitution.shorthandPropertyId();
216         if (CSSProperty::isDirectionAwareProperty(shorthandID))
217             shorthandID = CSSProperty::resolveDirectionAwareProperty(shorthandID, direction, writingMode);
218         CSSVariableReferenceValue* shorthandValue = pendingSubstitution.shorthandValue();
219 
<span class="line-modified">220         auto resolvedData = shorthandValue-&gt;resolveVariableReferences(builderState);</span>
221         if (!resolvedData)
222             return nullptr;
223         Vector&lt;CSSParserToken&gt; resolvedTokens = resolvedData-&gt;tokens();
224 
225         ParsedPropertyVector parsedProperties;
<span class="line-modified">226         if (!CSSPropertyParser::parseValue(shorthandID, false, resolvedTokens, m_context, parsedProperties, StyleRuleType::Style))</span>
227             return nullptr;
228 
229         for (auto&amp; property : parsedProperties) {
230             if (property.id() == propID)
231                 return property.value();
232         }
233 
234         return nullptr;
235     }
236 
237     if (value.isVariableReferenceValue()) {
238         const CSSVariableReferenceValue&amp; valueWithReferences = downcast&lt;CSSVariableReferenceValue&gt;(value);
<span class="line-modified">239         auto resolvedData = valueWithReferences.resolveVariableReferences(builderState);</span>
240         if (!resolvedData)
241             return nullptr;
242         return CSSPropertyParser::parseSingleValue(propID, resolvedData-&gt;tokens(), m_context);
243     }
244 
245     const auto&amp; customPropValue = downcast&lt;CSSCustomPropertyValue&gt;(value);
246     const auto&amp; valueWithReferences = WTF::get&lt;Ref&lt;CSSVariableReferenceValue&gt;&gt;(customPropValue.value()).get();
247 
248     auto&amp; name = downcast&lt;CSSCustomPropertyValue&gt;(value).name();
<span class="line-modified">249     auto* registered = builderState.document().getCSSRegisteredCustomPropertySet().get(name);</span>
250     auto&amp; syntax = registered ? registered-&gt;syntax : &quot;*&quot;;
<span class="line-modified">251     auto resolvedData = valueWithReferences.resolveVariableReferences(builderState);</span>
252 
253     if (!resolvedData)
254         return nullptr;
255 
256     // FIXME handle REM cycles.
257     HashSet&lt;CSSPropertyID&gt; dependencies;
258     CSSPropertyParser::collectParsedCustomPropertyValueDependencies(syntax, false, dependencies, resolvedData-&gt;tokens(), m_context);
259 
260     for (auto id : dependencies)
<span class="line-modified">261         builderState.builder().applyProperty(id);</span>
262 
<span class="line-modified">263     return CSSPropertyParser::parseTypedCustomPropertyValue(name, syntax, resolvedData-&gt;tokens(), builderState, m_context);</span>
264 }
265 
266 std::unique_ptr&lt;Vector&lt;double&gt;&gt; CSSParser::parseKeyframeKeyList(const String&amp; selector)
267 {
268     return CSSParserImpl::parseKeyframeKeyList(selector);
269 }
270 
271 RefPtr&lt;CSSValue&gt; CSSParser::parseFontFaceDescriptor(CSSPropertyID propertyID, const String&amp; propertyValue, const CSSParserContext&amp; context)
272 {
273     String string = makeString(&quot;@font-face { &quot;, getPropertyNameString(propertyID), &quot; : &quot;, propertyValue, &quot;; }&quot;);
274     RefPtr&lt;StyleRuleBase&gt; rule = parseRule(context, nullptr, string);
275     if (!rule || !rule-&gt;isFontFaceRule())
276         return nullptr;
277     return downcast&lt;StyleRuleFontFace&gt;(*rule.get()).properties().getPropertyCSSValue(propertyID);
278 }
279 
280 }
</pre>
</td>
</tr>
</table>
<center><a href="../makeprop.pl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSParser.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
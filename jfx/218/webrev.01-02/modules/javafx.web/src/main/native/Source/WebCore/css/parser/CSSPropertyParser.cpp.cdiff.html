<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSPropertyParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSParserToken.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSPropertyParser.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSPropertyParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 70,14 ***</span>
  #include &quot;Rect.h&quot;
  #include &quot;RenderTheme.h&quot;
  #include &quot;RuntimeEnabledFeatures.h&quot;
  #include &quot;SVGPathByteStream.h&quot;
  #include &quot;SVGPathUtilities.h&quot;
  #include &quot;StyleBuilderConverter.h&quot;
  #include &quot;StylePropertyShorthand.h&quot;
  #include &quot;StylePropertyShorthandFunctions.h&quot;
<span class="line-removed">- #include &quot;StyleResolver.h&quot;</span>
  #include &lt;bitset&gt;
  #include &lt;memory&gt;
  #include &lt;wtf/text/StringBuilder.h&gt;
  
  namespace WebCore {
<span class="line-new-header">--- 70,14 ---</span>
  #include &quot;Rect.h&quot;
  #include &quot;RenderTheme.h&quot;
  #include &quot;RuntimeEnabledFeatures.h&quot;
  #include &quot;SVGPathByteStream.h&quot;
  #include &quot;SVGPathUtilities.h&quot;
<span class="line-added">+ #include &quot;StyleBuilder.h&quot;</span>
  #include &quot;StyleBuilderConverter.h&quot;
  #include &quot;StylePropertyShorthand.h&quot;
  #include &quot;StylePropertyShorthandFunctions.h&quot;
  #include &lt;bitset&gt;
  #include &lt;memory&gt;
  #include &lt;wtf/text/StringBuilder.h&gt;
  
  namespace WebCore {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 153,18 ***</span>
  {
      static const char applePrefix[] = &quot;-apple-&quot;;
      static const char appleSystemPrefix[] = &quot;-apple-system&quot;;
      static const char applePayPrefix[] = &quot;-apple-pay&quot;;
  
<span class="line-modified">! #if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)</span>
      static const char* appleWirelessPlaybackTargetActive = getValueName(CSSValueAppleWirelessPlaybackTargetActive);
  #endif
  
      return hasPrefix(valueKeyword, length, applePrefix)
      &amp;&amp; !hasPrefix(valueKeyword, length, appleSystemPrefix)
      &amp;&amp; !hasPrefix(valueKeyword, length, applePayPrefix)
<span class="line-modified">! #if PLATFORM(MAC) || PLATFORM(IOS_FAMILY)</span>
      &amp;&amp; !WTF::equal(reinterpret_cast&lt;const LChar*&gt;(valueKeyword), reinterpret_cast&lt;const LChar*&gt;(appleWirelessPlaybackTargetActive), length)
  #endif
      ;
  }
  
<span class="line-new-header">--- 153,18 ---</span>
  {
      static const char applePrefix[] = &quot;-apple-&quot;;
      static const char appleSystemPrefix[] = &quot;-apple-system&quot;;
      static const char applePayPrefix[] = &quot;-apple-pay&quot;;
  
<span class="line-modified">! #if PLATFORM(COCOA)</span>
      static const char* appleWirelessPlaybackTargetActive = getValueName(CSSValueAppleWirelessPlaybackTargetActive);
  #endif
  
      return hasPrefix(valueKeyword, length, applePrefix)
      &amp;&amp; !hasPrefix(valueKeyword, length, appleSystemPrefix)
      &amp;&amp; !hasPrefix(valueKeyword, length, applePayPrefix)
<span class="line-modified">! #if PLATFORM(COCOA)</span>
      &amp;&amp; !WTF::equal(reinterpret_cast&lt;const LChar*&gt;(valueKeyword), reinterpret_cast&lt;const LChar*&gt;(appleWirelessPlaybackTargetActive), length)
  #endif
      ;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 257,23 ***</span>
      const CSSPropertyID* longhands = shorthand.properties();
      for (unsigned i = 0; i &lt; shorthandLength; ++i)
          addProperty(longhands[i], property, value.copyRef(), important);
  }
  
<span class="line-modified">! bool CSSPropertyParser::parseValue(CSSPropertyID propertyID, bool important, const CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, ParsedPropertyVector&amp; parsedProperties, StyleRule::Type ruleType)</span>
  {
      int parsedPropertiesSize = parsedProperties.size();
  
      CSSPropertyParser parser(range, context, &amp;parsedProperties);
      bool parseSuccess;
  
  #if ENABLE(CSS_DEVICE_ADAPTATION)
<span class="line-modified">!     if (ruleType == StyleRule::Viewport)</span>
          parseSuccess = parser.parseViewportDescriptor(propertyID, important);
      else
  #endif
<span class="line-modified">!     if (ruleType == StyleRule::FontFace)</span>
          parseSuccess = parser.parseFontFaceDescriptor(propertyID);
      else
          parseSuccess = parser.parseValueStart(propertyID, important);
  
      if (!parseSuccess)
<span class="line-new-header">--- 257,23 ---</span>
      const CSSPropertyID* longhands = shorthand.properties();
      for (unsigned i = 0; i &lt; shorthandLength; ++i)
          addProperty(longhands[i], property, value.copyRef(), important);
  }
  
<span class="line-modified">! bool CSSPropertyParser::parseValue(CSSPropertyID propertyID, bool important, const CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, ParsedPropertyVector&amp; parsedProperties, StyleRuleType ruleType)</span>
  {
      int parsedPropertiesSize = parsedProperties.size();
  
      CSSPropertyParser parser(range, context, &amp;parsedProperties);
      bool parseSuccess;
  
  #if ENABLE(CSS_DEVICE_ADAPTATION)
<span class="line-modified">!     if (ruleType == StyleRuleType::Viewport)</span>
          parseSuccess = parser.parseViewportDescriptor(propertyID, important);
      else
  #endif
<span class="line-modified">!     if (ruleType == StyleRuleType::FontFace)</span>
          parseSuccess = parser.parseFontFaceDescriptor(propertyID);
      else
          parseSuccess = parser.parseValueStart(propertyID, important);
  
      if (!parseSuccess)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 295,14 ***</span>
  {
      CSSPropertyParser parser(tokens, context, nullptr);
      return parser.canParseTypedCustomPropertyValue(syntax);
  }
  
<span class="line-modified">! RefPtr&lt;CSSCustomPropertyValue&gt; CSSPropertyParser::parseTypedCustomPropertyValue(const String&amp; name, const String&amp; syntax, const CSSParserTokenRange&amp; tokens, const StyleResolver&amp; styleResolver, const CSSParserContext&amp; context)</span>
  {
      CSSPropertyParser parser(tokens, context, nullptr, false);
<span class="line-modified">!     RefPtr&lt;CSSCustomPropertyValue&gt; value = parser.parseTypedCustomPropertyValue(name, syntax, styleResolver);</span>
      if (!value || !parser.m_range.atEnd())
          return nullptr;
      return value;
  }
  
<span class="line-new-header">--- 295,14 ---</span>
  {
      CSSPropertyParser parser(tokens, context, nullptr);
      return parser.canParseTypedCustomPropertyValue(syntax);
  }
  
<span class="line-modified">! RefPtr&lt;CSSCustomPropertyValue&gt; CSSPropertyParser::parseTypedCustomPropertyValue(const String&amp; name, const String&amp; syntax, const CSSParserTokenRange&amp; tokens, const Style::BuilderState&amp; builderState, const CSSParserContext&amp; context)</span>
  {
      CSSPropertyParser parser(tokens, context, nullptr, false);
<span class="line-modified">!     RefPtr&lt;CSSCustomPropertyValue&gt; value = parser.parseTypedCustomPropertyValue(name, syntax, builderState);</span>
      if (!value || !parser.m_range.atEnd())
          return nullptr;
      return value;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 387,22 ***</span>
          bool hasZ = resultZ;
          if (!hasZ &amp;&amp; !atEnd)
              return false;
          addProperty(CSSPropertyTransformOriginX, CSSPropertyTransformOrigin, resultX.releaseNonNull(), important);
          addProperty(CSSPropertyTransformOriginY, CSSPropertyTransformOrigin, resultY.releaseNonNull(), important);
<span class="line-modified">!         addProperty(CSSPropertyTransformOriginZ, CSSPropertyTransformOrigin, resultZ ? resultZ.releaseNonNull() : CSSValuePool::singleton().createValue(0, CSSPrimitiveValue::UnitType::CSS_PX), important, !hasZ);</span>
  
          return true;
      }
      return false;
  }
  
  bool CSSPropertyParser::consumePerspectiveOrigin(bool important)
  {
      RefPtr&lt;CSSPrimitiveValue&gt; resultX;
      RefPtr&lt;CSSPrimitiveValue&gt; resultY;
<span class="line-modified">!     if (consumePosition(m_range, m_context.mode, UnitlessQuirk::Forbid, resultX, resultY)) {</span>
          addProperty(CSSPropertyPerspectiveOriginX, CSSPropertyPerspectiveOrigin, resultX.releaseNonNull(), important);
          addProperty(CSSPropertyPerspectiveOriginY, CSSPropertyPerspectiveOrigin, resultY.releaseNonNull(), important);
          return true;
      }
      return false;
<span class="line-new-header">--- 387,22 ---</span>
          bool hasZ = resultZ;
          if (!hasZ &amp;&amp; !atEnd)
              return false;
          addProperty(CSSPropertyTransformOriginX, CSSPropertyTransformOrigin, resultX.releaseNonNull(), important);
          addProperty(CSSPropertyTransformOriginY, CSSPropertyTransformOrigin, resultY.releaseNonNull(), important);
<span class="line-modified">!         addProperty(CSSPropertyTransformOriginZ, CSSPropertyTransformOrigin, resultZ ? resultZ.releaseNonNull() : CSSValuePool::singleton().createValue(0, CSSUnitType::CSS_PX), important, !hasZ);</span>
  
          return true;
      }
      return false;
  }
  
  bool CSSPropertyParser::consumePerspectiveOrigin(bool important)
  {
      RefPtr&lt;CSSPrimitiveValue&gt; resultX;
      RefPtr&lt;CSSPrimitiveValue&gt; resultY;
<span class="line-modified">!     if (consumePosition(m_range, m_context.mode, UnitlessQuirk::Forbid, PositionSyntax::Position, resultX, resultY)) {</span>
          addProperty(CSSPropertyPerspectiveOriginX, CSSPropertyPerspectiveOrigin, resultX.releaseNonNull(), important);
          addProperty(CSSPropertyPerspectiveOriginY, CSSPropertyPerspectiveOrigin, resultY.releaseNonNull(), important);
          return true;
      }
      return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 968,11 ***</span>
          return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(valueID));
      ASSERT(result-&gt;valueID() == CSSValueOblique);
  #if ENABLE(VARIATION_FONTS)
      if (!range.atEnd()) {
          if (auto angle = consumeAngle(range, cssParserMode)) {
<span class="line-modified">!             if (fontStyleIsWithinRange(angle-&gt;value&lt;float&gt;(CSSPrimitiveValue::CSS_DEG)))</span>
                  return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueOblique), WTFMove(angle));
              return nullptr;
          }
      }
  #else
<span class="line-new-header">--- 968,11 ---</span>
          return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(valueID));
      ASSERT(result-&gt;valueID() == CSSValueOblique);
  #if ENABLE(VARIATION_FONTS)
      if (!range.atEnd()) {
          if (auto angle = consumeAngle(range, cssParserMode)) {
<span class="line-modified">!             if (fontStyleIsWithinRange(angle-&gt;value&lt;float&gt;(CSSUnitType::CSS_DEG)))</span>
                  return CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(CSSValueOblique), WTFMove(angle));
              return nullptr;
          }
      }
  #else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 990,19 ***</span>
  
      if (keyword-&gt;valueID() != CSSValueOblique || range.atEnd())
          return CSSFontStyleRangeValue::create(keyword.releaseNonNull());
  
      if (auto firstAngle = consumeAngle(range, cssParserMode)) {
<span class="line-modified">!         if (!fontStyleIsWithinRange(firstAngle-&gt;value&lt;float&gt;(CSSPrimitiveValue::CSS_DEG)))</span>
              return nullptr;
          if (range.atEnd()) {
              auto result = CSSValueList::createSpaceSeparated();
              result-&gt;append(firstAngle.releaseNonNull());
              return CSSFontStyleRangeValue::create(keyword.releaseNonNull(), WTFMove(result));
          }
          auto secondAngle = consumeAngle(range, cssParserMode);
<span class="line-modified">!         if (!secondAngle || !fontStyleIsWithinRange(secondAngle-&gt;value&lt;float&gt;(CSSPrimitiveValue::CSS_DEG)) || firstAngle-&gt;floatValue(CSSPrimitiveValue::CSS_DEG) &gt; secondAngle-&gt;floatValue(CSSPrimitiveValue::CSS_DEG))</span>
              return nullptr;
          auto result = CSSValueList::createSpaceSeparated();
          result-&gt;append(firstAngle.releaseNonNull());
          result-&gt;append(secondAngle.releaseNonNull());
          return CSSFontStyleRangeValue::create(keyword.releaseNonNull(), WTFMove(result));
<span class="line-new-header">--- 990,19 ---</span>
  
      if (keyword-&gt;valueID() != CSSValueOblique || range.atEnd())
          return CSSFontStyleRangeValue::create(keyword.releaseNonNull());
  
      if (auto firstAngle = consumeAngle(range, cssParserMode)) {
<span class="line-modified">!         if (!fontStyleIsWithinRange(firstAngle-&gt;value&lt;float&gt;(CSSUnitType::CSS_DEG)))</span>
              return nullptr;
          if (range.atEnd()) {
              auto result = CSSValueList::createSpaceSeparated();
              result-&gt;append(firstAngle.releaseNonNull());
              return CSSFontStyleRangeValue::create(keyword.releaseNonNull(), WTFMove(result));
          }
          auto secondAngle = consumeAngle(range, cssParserMode);
<span class="line-modified">!         if (!secondAngle || !fontStyleIsWithinRange(secondAngle-&gt;value&lt;float&gt;(CSSUnitType::CSS_DEG)) || firstAngle-&gt;floatValue(CSSUnitType::CSS_DEG) &gt; secondAngle-&gt;floatValue(CSSUnitType::CSS_DEG))</span>
              return nullptr;
          auto result = CSSValueList::createSpaceSeparated();
          result-&gt;append(firstAngle.releaseNonNull());
          result-&gt;append(secondAngle.releaseNonNull());
          return CSSFontStyleRangeValue::create(keyword.releaseNonNull(), WTFMove(result));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1173,11 ***</span>
          if (!counterName)
              return nullptr;
          int i = defaultValue;
          if (RefPtr&lt;CSSPrimitiveValue&gt; counterValue = consumeInteger(range))
              i = counterValue-&gt;intValue();
<span class="line-modified">!         list-&gt;append(createPrimitiveValuePair(counterName.releaseNonNull(), CSSPrimitiveValue::create(i, CSSPrimitiveValue::UnitType::CSS_NUMBER), Pair::IdenticalValueEncoding::Coalesce));</span>
      } while (!range.atEnd());
      return list;
  }
  
  static RefPtr&lt;CSSValue&gt; consumePageSize(CSSParserTokenRange&amp; range)
<span class="line-new-header">--- 1173,11 ---</span>
          if (!counterName)
              return nullptr;
          int i = defaultValue;
          if (RefPtr&lt;CSSPrimitiveValue&gt; counterValue = consumeInteger(range))
              i = counterValue-&gt;intValue();
<span class="line-modified">!         list-&gt;append(createPrimitiveValuePair(counterName.releaseNonNull(), CSSPrimitiveValue::create(i, CSSUnitType::CSS_NUMBER), Pair::IdenticalValueEncoding::Coalesce));</span>
      } while (!range.atEnd());
      return list;
  }
  
  static RefPtr&lt;CSSValue&gt; consumePageSize(CSSParserTokenRange&amp; range)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1378,12 ***</span>
      if (range.peek().id() == CSSValueAuto)
          return consumeIdent(range);
      // Always parse lengths in strict mode here, since it would be ambiguous otherwise when used in
      // the &#39;columns&#39; shorthand property.
      RefPtr&lt;CSSPrimitiveValue&gt; columnWidth = consumeLength(range, HTMLStandardMode, ValueRangeNonNegative);
<span class="line-modified">!     if (!columnWidth || (!columnWidth-&gt;isCalculated() &amp;&amp; !columnWidth-&gt;doubleValue()) || (columnWidth-&gt;cssCalcValue() &amp;&amp; !columnWidth-&gt;cssCalcValue()-&gt;doubleValue()))</span>
          return nullptr;
      return columnWidth;
  }
  
  static RefPtr&lt;CSSValue&gt; consumeColumnCount(CSSParserTokenRange&amp; range)
  {
<span class="line-new-header">--- 1378,13 ---</span>
      if (range.peek().id() == CSSValueAuto)
          return consumeIdent(range);
      // Always parse lengths in strict mode here, since it would be ambiguous otherwise when used in
      // the &#39;columns&#39; shorthand property.
      RefPtr&lt;CSSPrimitiveValue&gt; columnWidth = consumeLength(range, HTMLStandardMode, ValueRangeNonNegative);
<span class="line-modified">!     if (!columnWidth || columnWidth-&gt;isZero().valueOr(false))</span>
          return nullptr;
<span class="line-added">+ </span>
      return columnWidth;
  }
  
  static RefPtr&lt;CSSValue&gt; consumeColumnCount(CSSParserTokenRange&amp; range)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1433,11 ***</span>
      if (range.peek().type() == StringToken) {
          const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
          if (equalIgnoringASCIICase(token.value(), &quot;none&quot;))
              return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
          // FIXME-NEWPARSER: Want to use a CSSCustomIdentValue here eventually.
<span class="line-modified">!         return CSSValuePool::singleton().createValue(token.value().toString(), CSSPrimitiveValue::UnitType::CSS_STRING);</span>
      }
  
      return consumeCustomIdent(range);
  }
  
<span class="line-new-header">--- 1434,11 ---</span>
      if (range.peek().type() == StringToken) {
          const CSSParserToken&amp; token = range.consumeIncludingWhitespace();
          if (equalIgnoringASCIICase(token.value(), &quot;none&quot;))
              return CSSValuePool::singleton().createIdentifierValue(CSSValueNone);
          // FIXME-NEWPARSER: Want to use a CSSCustomIdentValue here eventually.
<span class="line-modified">!         return CSSValuePool::singleton().createValue(token.value().toString(), CSSUnitType::CSS_STRING);</span>
      }
  
      return consumeCustomIdent(range);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1861,11 ***</span>
      RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeLength(args, cssParserMode, ValueRangeNonNegative);
      if (!parsedValue) {
          double perspective;
          if (!consumeNumberRaw(args, perspective) || perspective &lt; 0)
              return false;
<span class="line-modified">!         parsedValue = CSSPrimitiveValue::create(perspective, CSSPrimitiveValue::UnitType::CSS_PX);</span>
      }
      if (!parsedValue)
          return false;
      transformValue-&gt;append(parsedValue.releaseNonNull());
      return true;
<span class="line-new-header">--- 1862,11 ---</span>
      RefPtr&lt;CSSPrimitiveValue&gt; parsedValue = consumeLength(args, cssParserMode, ValueRangeNonNegative);
      if (!parsedValue) {
          double perspective;
          if (!consumeNumberRaw(args, perspective) || perspective &lt; 0)
              return false;
<span class="line-modified">!         parsedValue = CSSPrimitiveValue::create(perspective, CSSUnitType::CSS_PX);</span>
      }
      if (!parsedValue)
          return false;
      transformValue-&gt;append(parsedValue.releaseNonNull());
      return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1993,11 ***</span>
          else if (id == end)
              percent = 100;
          else
              return nullptr;
          range.consumeIncludingWhitespace();
<span class="line-modified">!         return CSSPrimitiveValue::create(percent, CSSPrimitiveValue::UnitType::CSS_PERCENTAGE);</span>
      }
      return consumeLengthOrPercent(range, cssParserMode, ValueRangeAll);
  }
  
  static RefPtr&lt;CSSPrimitiveValue&gt; consumePositionX(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
<span class="line-new-header">--- 1994,11 ---</span>
          else if (id == end)
              percent = 100;
          else
              return nullptr;
          range.consumeIncludingWhitespace();
<span class="line-modified">!         return CSSPrimitiveValue::create(percent, CSSUnitType::CSS_PERCENTAGE);</span>
      }
      return consumeLengthOrPercent(range, cssParserMode, ValueRangeAll);
  }
  
  static RefPtr&lt;CSSPrimitiveValue&gt; consumePositionX(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2138,23 ***</span>
      if (id == CSSValueBaseline || id == CSSValueSub || id == CSSValueSuper)
          return consumeIdent(range);
      return consumeLengthOrPercent(range, SVGAttributeMode, ValueRangeAll);
  }
  
<span class="line-modified">! static RefPtr&lt;CSSPrimitiveValue&gt; consumeRxOrRy(CSSParserTokenRange&amp; range)</span>
  {
<span class="line-modified">!     // FIXME-NEWPARSER: We don&#39;t support auto values when mapping, so for now turn this</span>
<span class="line-modified">!     // off until we can figure out if we&#39;re even supposed to support it.</span>
<span class="line-modified">!     // if (range.peek().id() == CSSValueAuto)</span>
<span class="line-removed">-     //     return consumeIdent(range);</span>
<span class="line-removed">-     return consumeLengthOrPercent(range, SVGAttributeMode, ValueRangeAll, UnitlessQuirk::Forbid);</span>
  }
  
  static RefPtr&lt;CSSValue&gt; consumeCursor(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, bool inQuirksMode)
  {
      RefPtr&lt;CSSValueList&gt; list;
<span class="line-modified">!     while (RefPtr&lt;CSSValue&gt; image = consumeImage(range, context, ConsumeGeneratedImage::Forbid)) {</span>
          double num;
          IntPoint hotSpot(-1, -1);
          bool hotSpotSpecified = false;
          if (consumeNumberRaw(range, num)) {
              hotSpot.setX(int(num));
<span class="line-new-header">--- 2139,21 ---</span>
      if (id == CSSValueBaseline || id == CSSValueSub || id == CSSValueSuper)
          return consumeIdent(range);
      return consumeLengthOrPercent(range, SVGAttributeMode, ValueRangeAll);
  }
  
<span class="line-modified">! static RefPtr&lt;CSSPrimitiveValue&gt; consumeRxOrRy(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)</span>
  {
<span class="line-modified">!     if (range.peek().id() == CSSValueAuto)</span>
<span class="line-modified">!         return consumeIdent(range);</span>
<span class="line-modified">!     return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative, UnitlessQuirk::Forbid);</span>
  }
  
  static RefPtr&lt;CSSValue&gt; consumeCursor(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, bool inQuirksMode)
  {
      RefPtr&lt;CSSValueList&gt; list;
<span class="line-modified">!     while (RefPtr&lt;CSSValue&gt; image = consumeImage(range, context, { AllowedImageType::URLFunction, AllowedImageType::ImageSet })) {</span>
          double num;
          IntPoint hotSpot(-1, -1);
          bool hotSpotSpecified = false;
          if (consumeNumberRaw(range, num)) {
              hotSpot.setX(int(num));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2205,26 ***</span>
          return nullptr;
  
      // FIXME-NEWPARSER: We want to use a CSSCustomIdentValue here eventually for the attrName.
      // FIXME-NEWPARSER: We want to use a CSSFunctionValue rather than relying on a custom
      // attr() primitive value.
<span class="line-modified">!     return CSSValuePool::singleton().createValue(attrName, CSSPrimitiveValue::CSS_ATTR);</span>
  }
  
  static RefPtr&lt;CSSValue&gt; consumeCounterContent(CSSParserTokenRange args, bool counters)
  {
      RefPtr&lt;CSSPrimitiveValue&gt; identifier = consumeCustomIdent(args);
      if (!identifier)
          return nullptr;
  
      RefPtr&lt;CSSPrimitiveValue&gt; separator;
      if (!counters)
<span class="line-modified">!         separator = CSSPrimitiveValue::create(String(), CSSPrimitiveValue::UnitType::CSS_STRING);</span>
      else {
          if (!consumeCommaIncludingWhitespace(args) || args.peek().type() != StringToken)
              return nullptr;
<span class="line-modified">!         separator = CSSPrimitiveValue::create(args.consumeIncludingWhitespace().value().toString(), CSSPrimitiveValue::UnitType::CSS_STRING);</span>
      }
  
      RefPtr&lt;CSSPrimitiveValue&gt; listStyle;
      if (consumeCommaIncludingWhitespace(args)) {
          CSSValueID id = args.peek().id();
<span class="line-new-header">--- 2204,26 ---</span>
          return nullptr;
  
      // FIXME-NEWPARSER: We want to use a CSSCustomIdentValue here eventually for the attrName.
      // FIXME-NEWPARSER: We want to use a CSSFunctionValue rather than relying on a custom
      // attr() primitive value.
<span class="line-modified">!     return CSSValuePool::singleton().createValue(attrName, CSSUnitType::CSS_ATTR);</span>
  }
  
  static RefPtr&lt;CSSValue&gt; consumeCounterContent(CSSParserTokenRange args, bool counters)
  {
      RefPtr&lt;CSSPrimitiveValue&gt; identifier = consumeCustomIdent(args);
      if (!identifier)
          return nullptr;
  
      RefPtr&lt;CSSPrimitiveValue&gt; separator;
      if (!counters)
<span class="line-modified">!         separator = CSSPrimitiveValue::create(String(), CSSUnitType::CSS_STRING);</span>
      else {
          if (!consumeCommaIncludingWhitespace(args) || args.peek().type() != StringToken)
              return nullptr;
<span class="line-modified">!         separator = CSSPrimitiveValue::create(args.consumeIncludingWhitespace().value().toString(), CSSUnitType::CSS_STRING);</span>
      }
  
      RefPtr&lt;CSSPrimitiveValue&gt; listStyle;
      if (consumeCommaIncludingWhitespace(args)) {
          CSSValueID id = args.peek().id();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2278,14 ***</span>
      if (!parsedValue) {
          // FIXME: Make this quirk only apply to the webkit prefixed version of the property.
          double perspective;
          if (!consumeNumberRaw(range, perspective))
              return nullptr;
<span class="line-modified">!         parsedValue = CSSPrimitiveValue::create(perspective, CSSPrimitiveValue::UnitType::CSS_PX);</span>
      }
<span class="line-modified">!     if (parsedValue &amp;&amp; (parsedValue-&gt;isCalculated() || parsedValue-&gt;doubleValue() &gt; 0))</span>
          return parsedValue;
      return nullptr;
  }
  
  #if ENABLE(CSS_SCROLL_SNAP)
  
<span class="line-new-header">--- 2277,19 ---</span>
      if (!parsedValue) {
          // FIXME: Make this quirk only apply to the webkit prefixed version of the property.
          double perspective;
          if (!consumeNumberRaw(range, perspective))
              return nullptr;
<span class="line-modified">!         parsedValue = CSSPrimitiveValue::create(perspective, CSSUnitType::CSS_PX);</span>
      }
<span class="line-modified">! </span>
<span class="line-added">+     if (!parsedValue)</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (parsedValue-&gt;isPositive().valueOr(true))</span>
          return parsedValue;
<span class="line-added">+ </span>
      return nullptr;
  }
  
  #if ENABLE(CSS_SCROLL_SNAP)
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2321,10 ***</span>
<span class="line-new-header">--- 2325,18 ---</span>
      return typeValue;
  }
  
  #endif
  
<span class="line-added">+ static RefPtr&lt;CSSPrimitiveValue&gt; consumeScrollBehavior(CSSParserTokenRange&amp; range)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto valueID = range.peek().id();</span>
<span class="line-added">+     if (valueID != CSSValueAuto &amp;&amp; valueID != CSSValueSmooth)</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     return consumeIdent(range);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  static RefPtr&lt;CSSValue&gt; consumeBorderRadiusCorner(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
  {
      RefPtr&lt;CSSPrimitiveValue&gt; parsedValue1 = consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative);
      if (!parsedValue1)
          return nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2371,11 ***</span>
      if (RefPtr&lt;CSSPrimitiveValue&gt; radius = consumeShapeRadius(args, context.mode))
          shape-&gt;setRadius(radius.releaseNonNull());
      if (consumeIdent&lt;CSSValueAt&gt;(args)) {
          RefPtr&lt;CSSPrimitiveValue&gt; centerX;
          RefPtr&lt;CSSPrimitiveValue&gt; centerY;
<span class="line-modified">!         if (!consumePosition(args, context.mode, UnitlessQuirk::Forbid, centerX, centerY))</span>
              return nullptr;
          shape-&gt;setCenterX(centerX.releaseNonNull());
          shape-&gt;setCenterY(centerY.releaseNonNull());
      }
      return shape;
<span class="line-new-header">--- 2383,11 ---</span>
      if (RefPtr&lt;CSSPrimitiveValue&gt; radius = consumeShapeRadius(args, context.mode))
          shape-&gt;setRadius(radius.releaseNonNull());
      if (consumeIdent&lt;CSSValueAt&gt;(args)) {
          RefPtr&lt;CSSPrimitiveValue&gt; centerX;
          RefPtr&lt;CSSPrimitiveValue&gt; centerY;
<span class="line-modified">!         if (!consumePosition(args, context.mode, UnitlessQuirk::Forbid, PositionSyntax::Position, centerX, centerY))</span>
              return nullptr;
          shape-&gt;setCenterX(centerX.releaseNonNull());
          shape-&gt;setCenterY(centerY.releaseNonNull());
      }
      return shape;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2383,20 ***</span>
  
  static RefPtr&lt;CSSBasicShapeEllipse&gt; consumeBasicShapeEllipse(CSSParserTokenRange&amp; args, const CSSParserContext&amp; context)
  {
      // spec: https://drafts.csswg.org/css-shapes/#supported-basic-shapes
      // ellipse( [&lt;shape-radius&gt;{2}]? [at &lt;position&gt;]? )
<span class="line-modified">!     RefPtr&lt;CSSBasicShapeEllipse&gt; shape = CSSBasicShapeEllipse::create();</span>
<span class="line-modified">!     if (RefPtr&lt;CSSPrimitiveValue&gt; radiusX = consumeShapeRadius(args, context.mode)) {</span>
          shape-&gt;setRadiusX(radiusX.releaseNonNull());
<span class="line-modified">!         if (RefPtr&lt;CSSPrimitiveValue&gt; radiusY = consumeShapeRadius(args, context.mode))</span>
<span class="line-removed">-             shape-&gt;setRadiusY(radiusY.releaseNonNull());</span>
      }
      if (consumeIdent&lt;CSSValueAt&gt;(args)) {
          RefPtr&lt;CSSPrimitiveValue&gt; centerX;
          RefPtr&lt;CSSPrimitiveValue&gt; centerY;
<span class="line-modified">!         if (!consumePosition(args, context.mode, UnitlessQuirk::Forbid, centerX, centerY))</span>
              return nullptr;
          shape-&gt;setCenterX(centerX.releaseNonNull());
          shape-&gt;setCenterY(centerY.releaseNonNull());
      }
      return shape;
<span class="line-new-header">--- 2395,22 ---</span>
  
  static RefPtr&lt;CSSBasicShapeEllipse&gt; consumeBasicShapeEllipse(CSSParserTokenRange&amp; args, const CSSParserContext&amp; context)
  {
      // spec: https://drafts.csswg.org/css-shapes/#supported-basic-shapes
      // ellipse( [&lt;shape-radius&gt;{2}]? [at &lt;position&gt;]? )
<span class="line-modified">!     auto shape = CSSBasicShapeEllipse::create();</span>
<span class="line-modified">!     if (auto radiusX = consumeShapeRadius(args, context.mode)) {</span>
<span class="line-added">+         auto radiusY = consumeShapeRadius(args, context.mode);</span>
<span class="line-added">+         if (!radiusY)</span>
<span class="line-added">+             return nullptr;</span>
          shape-&gt;setRadiusX(radiusX.releaseNonNull());
<span class="line-modified">!         shape-&gt;setRadiusY(radiusY.releaseNonNull());</span>
      }
      if (consumeIdent&lt;CSSValueAt&gt;(args)) {
          RefPtr&lt;CSSPrimitiveValue&gt; centerX;
          RefPtr&lt;CSSPrimitiveValue&gt; centerY;
<span class="line-modified">!         if (!consumePosition(args, context.mode, UnitlessQuirk::Forbid, PositionSyntax::Position, centerX, centerY))</span>
              return nullptr;
          shape-&gt;setCenterX(centerX.releaseNonNull());
          shape-&gt;setCenterY(centerY.releaseNonNull());
      }
      return shape;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2528,13 ***</span>
          shape-&gt;setBottomLeftRadius(createPrimitiveValuePair(horizontalRadii[3].releaseNonNull(), verticalRadii[3].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce));
      }
      return shape;
  }
  
<span class="line-modified">! static RefPtr&lt;CSSValue&gt; consumeBasicShape(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)</span>
  {
<span class="line-removed">-     RefPtr&lt;CSSValue&gt; result;</span>
      if (range.peek().type() != FunctionToken)
          return nullptr;
      CSSValueID id = range.peek().functionId();
      CSSParserTokenRange rangeCopy = range;
      CSSParserTokenRange args = consumeFunction(rangeCopy);
<span class="line-new-header">--- 2542,12 ---</span>
          shape-&gt;setBottomLeftRadius(createPrimitiveValuePair(horizontalRadii[3].releaseNonNull(), verticalRadii[3].releaseNonNull(), Pair::IdenticalValueEncoding::Coalesce));
      }
      return shape;
  }
  
<span class="line-modified">! static RefPtr&lt;CSSPrimitiveValue&gt; consumeBasicShape(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)</span>
  {
      if (range.peek().type() != FunctionToken)
          return nullptr;
      CSSValueID id = range.peek().functionId();
      CSSParserTokenRange rangeCopy = range;
      CSSParserTokenRange args = consumeFunction(rangeCopy);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2584,11 ***</span>
          return nullptr;
  
      return list;
  }
  
<span class="line-modified">! static RefPtr&lt;CSSValue&gt; consumeWebkitClipPath(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)</span>
  {
      if (range.peek().id() == CSSValueNone)
          return consumeIdent(range);
      if (RefPtr&lt;CSSPrimitiveValue&gt; url = consumeUrl(range))
          return url;
<span class="line-new-header">--- 2597,11 ---</span>
          return nullptr;
  
      return list;
  }
  
<span class="line-modified">! static RefPtr&lt;CSSValue&gt; consumeClipPath(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)</span>
  {
      if (range.peek().id() == CSSValueNone)
          return consumeIdent(range);
      if (RefPtr&lt;CSSPrimitiveValue&gt; url = consumeUrl(range))
          return url;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2600,11 ***</span>
      if (RefPtr&lt;CSSValue&gt; imageValue = consumeImageOrNone(range, context))
          return imageValue;
      RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
      if (RefPtr&lt;CSSValue&gt; boxValue = consumeIdent&lt;CSSValueContentBox, CSSValuePaddingBox, CSSValueBorderBox, CSSValueMarginBox&gt;(range))
          list-&gt;append(boxValue.releaseNonNull());
<span class="line-modified">!     if (RefPtr&lt;CSSValue&gt; shapeValue = consumeBasicShape(range, context)) {</span>
          list-&gt;append(shapeValue.releaseNonNull());
          if (list-&gt;length() &lt; 2) {
              if (RefPtr&lt;CSSValue&gt; boxValue = consumeIdent&lt;CSSValueContentBox, CSSValuePaddingBox, CSSValueBorderBox, CSSValueMarginBox&gt;(range))
                  list-&gt;append(boxValue.releaseNonNull());
          }
<span class="line-new-header">--- 2613,13 ---</span>
      if (RefPtr&lt;CSSValue&gt; imageValue = consumeImageOrNone(range, context))
          return imageValue;
      RefPtr&lt;CSSValueList&gt; list = CSSValueList::createSpaceSeparated();
      if (RefPtr&lt;CSSValue&gt; boxValue = consumeIdent&lt;CSSValueContentBox, CSSValuePaddingBox, CSSValueBorderBox, CSSValueMarginBox&gt;(range))
          list-&gt;append(boxValue.releaseNonNull());
<span class="line-modified">!     if (RefPtr&lt;CSSPrimitiveValue&gt; shapeValue = consumeBasicShape(range, context)) {</span>
<span class="line-added">+         if (shapeValue-&gt;shapeValue()-&gt;type() == CSSBasicShapeCircle::CSSBasicShapePathType)</span>
<span class="line-added">+             return nullptr;</span>
          list-&gt;append(shapeValue.releaseNonNull());
          if (list-&gt;length() &lt; 2) {
              if (RefPtr&lt;CSSValue&gt; boxValue = consumeIdent&lt;CSSValueContentBox, CSSValuePaddingBox, CSSValueBorderBox, CSSValueMarginBox&gt;(range))
                  list-&gt;append(boxValue.releaseNonNull());
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2877,11 ***</span>
      if (!direction)
          return nullptr;
  
      RefPtr&lt;CSSPrimitiveValue&gt; offset;
      if (range.atEnd())
<span class="line-modified">!         offset = CSSValuePool::singleton().createValue(0, CSSPrimitiveValue::UnitType::CSS_PX);</span>
      else {
          offset = consumeLengthOrPercent(range, context.mode, ValueRangeAll, UnitlessQuirk::Forbid);
          if (!offset)
              return nullptr;
      }
<span class="line-new-header">--- 2892,11 ---</span>
      if (!direction)
          return nullptr;
  
      RefPtr&lt;CSSPrimitiveValue&gt; offset;
      if (range.atEnd())
<span class="line-modified">!         offset = CSSValuePool::singleton().createValue(0, CSSUnitType::CSS_PX);</span>
      else {
          offset = consumeLengthOrPercent(range, context.mode, ValueRangeAll, UnitlessQuirk::Forbid);
          if (!offset)
              return nullptr;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2893,22 ***</span>
              return nullptr;
      }
      return CSSReflectValue::create(direction.releaseNonNull(), offset.releaseNonNull(), WTFMove(mask));
  }
  
<span class="line-removed">- #if ENABLE(CSS_IMAGE_ORIENTATION)</span>
<span class="line-removed">- static RefPtr&lt;CSSValue&gt; consumeImageOrientation(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless = UnitlessQuirk::Forbid)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (range.peek().type() != NumberToken) {</span>
<span class="line-removed">-         RefPtr&lt;CSSPrimitiveValue&gt; angle = consumeAngle(range, cssParserMode, unitless);</span>
<span class="line-removed">-         if (angle &amp;&amp; angle-&gt;doubleValue() == 0)</span>
<span class="line-removed">-             return angle;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return nullptr;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  static RefPtr&lt;CSSPrimitiveValue&gt; consumeBackgroundBlendMode(CSSParserTokenRange&amp; range)
  {
      CSSValueID id = range.peek().id();
      if (id == CSSValueNormal || id == CSSValueOverlay || (id &gt;= CSSValueMultiply &amp;&amp; id &lt;= CSSValueLuminosity))
          return consumeIdent(range);
<span class="line-new-header">--- 2908,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3303,14 ***</span>
  static RefPtr&lt;CSSPrimitiveValue&gt; consumeGridBreadth(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
  {
      const CSSParserToken&amp; token = range.peek();
      if (identMatches&lt;CSSValueMinContent, CSSValueWebkitMinContent, CSSValueMaxContent, CSSValueWebkitMaxContent, CSSValueAuto&gt;(token.id()))
          return consumeIdent(range);
<span class="line-modified">!     if (token.type() == DimensionToken &amp;&amp; token.unitType() == CSSPrimitiveValue::UnitType::CSS_FR) {</span>
          if (range.peek().numericValue() &lt; 0)
              return nullptr;
<span class="line-modified">!         return CSSPrimitiveValue::create(range.consumeIncludingWhitespace().numericValue(), CSSPrimitiveValue::UnitType::CSS_FR);</span>
      }
      return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative, UnitlessQuirk::Allow);
  }
  
  static RefPtr&lt;CSSValue&gt; consumeGridTrackSize(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
<span class="line-new-header">--- 3306,14 ---</span>
  static RefPtr&lt;CSSPrimitiveValue&gt; consumeGridBreadth(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
  {
      const CSSParserToken&amp; token = range.peek();
      if (identMatches&lt;CSSValueMinContent, CSSValueWebkitMinContent, CSSValueMaxContent, CSSValueWebkitMaxContent, CSSValueAuto&gt;(token.id()))
          return consumeIdent(range);
<span class="line-modified">!     if (token.type() == DimensionToken &amp;&amp; token.unitType() == CSSUnitType::CSS_FR) {</span>
          if (range.peek().numericValue() &lt; 0)
              return nullptr;
<span class="line-modified">!         return CSSPrimitiveValue::create(range.consumeIncludingWhitespace().numericValue(), CSSUnitType::CSS_FR);</span>
      }
      return consumeLengthOrPercent(range, cssParserMode, ValueRangeNonNegative, UnitlessQuirk::Allow);
  }
  
  static RefPtr&lt;CSSValue&gt; consumeGridTrackSize(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3339,11 ***</span>
          return consumeFitContent(range, cssParserMode);
  
      return consumeGridBreadth(range, cssParserMode);
  }
  
<span class="line-modified">! // Appends to the passed in CSSGridLineNamesValue if any, otherwise creates a new one.</span>
  static RefPtr&lt;CSSGridLineNamesValue&gt; consumeGridLineNames(CSSParserTokenRange&amp; range, CSSGridLineNamesValue* lineNames = nullptr)
  {
      CSSParserTokenRange rangeCopy = range;
      if (rangeCopy.consumeIncludingWhitespace().type() != LeftBracketToken)
          return nullptr;
<span class="line-new-header">--- 3342,11 ---</span>
          return consumeFitContent(range, cssParserMode);
  
      return consumeGridBreadth(range, cssParserMode);
  }
  
<span class="line-modified">! // Appends to the passed in CSSGridLineNamesValue if any, otherwise creates a new one. Returns nullptr if an empty list is consumed.</span>
  static RefPtr&lt;CSSGridLineNamesValue&gt; consumeGridLineNames(CSSParserTokenRange&amp; range, CSSGridLineNamesValue* lineNames = nullptr)
  {
      CSSParserTokenRange rangeCopy = range;
      if (rangeCopy.consumeIncludingWhitespace().type() != LeftBracketToken)
          return nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3354,11 ***</span>
      while (RefPtr&lt;CSSPrimitiveValue&gt; lineName = consumeCustomIdentForGridLine(rangeCopy))
          result-&gt;append(lineName.releaseNonNull());
      if (rangeCopy.consumeIncludingWhitespace().type() != RightBracketToken)
          return nullptr;
      range = rangeCopy;
<span class="line-modified">!     return result;</span>
  }
  
  static bool consumeGridTrackRepeatFunction(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, CSSValueList&amp; list, bool&amp; isAutoRepeat, bool&amp; allTracksAreFixedSized)
  {
      CSSParserTokenRange args = consumeFunction(range);
<span class="line-new-header">--- 3357,11 ---</span>
      while (RefPtr&lt;CSSPrimitiveValue&gt; lineName = consumeCustomIdentForGridLine(rangeCopy))
          result-&gt;append(lineName.releaseNonNull());
      if (rangeCopy.consumeIncludingWhitespace().type() != RightBracketToken)
          return nullptr;
      range = rangeCopy;
<span class="line-modified">!     return result-&gt;length() ? result : nullptr;</span>
  }
  
  static bool consumeGridTrackRepeatFunction(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, CSSValueList&amp; list, bool&amp; isAutoRepeat, bool&amp; allTracksAreFixedSized)
  {
      CSSParserTokenRange args = consumeFunction(range);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3417,16 ***</span>
  
  static RefPtr&lt;CSSValue&gt; consumeGridTrackList(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, TrackListType trackListType)
  {
      bool allowGridLineNames = trackListType != GridAuto;
      RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
      RefPtr&lt;CSSGridLineNamesValue&gt; lineNames = consumeGridLineNames(range);
<span class="line-modified">!     if (lineNames) {</span>
<span class="line-removed">-         if (!allowGridLineNames)</span>
<span class="line-removed">-             return nullptr;</span>
          values-&gt;append(lineNames.releaseNonNull());
<span class="line-removed">-     }</span>
  
      bool allowRepeat = trackListType == GridTemplate;
      bool seenAutoRepeat = false;
      bool allTracksAreFixedSized = true;
      do {
<span class="line-new-header">--- 3420,15 ---</span>
  
  static RefPtr&lt;CSSValue&gt; consumeGridTrackList(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, TrackListType trackListType)
  {
      bool allowGridLineNames = trackListType != GridAuto;
      RefPtr&lt;CSSValueList&gt; values = CSSValueList::createSpaceSeparated();
<span class="line-added">+     if (!allowGridLineNames &amp;&amp; range.peek().type() == LeftBracketToken)</span>
<span class="line-added">+         return nullptr;</span>
      RefPtr&lt;CSSGridLineNamesValue&gt; lineNames = consumeGridLineNames(range);
<span class="line-modified">!     if (lineNames)</span>
          values-&gt;append(lineNames.releaseNonNull());
  
      bool allowRepeat = trackListType == GridTemplate;
      bool seenAutoRepeat = false;
      bool allTracksAreFixedSized = true;
      do {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3446,16 ***</span>
          } else {
              return nullptr;
          }
          if (seenAutoRepeat &amp;&amp; !allTracksAreFixedSized)
              return nullptr;
          lineNames = consumeGridLineNames(range);
<span class="line-modified">!         if (lineNames) {</span>
<span class="line-removed">-             if (!allowGridLineNames)</span>
<span class="line-removed">-                 return nullptr;</span>
              values-&gt;append(lineNames.releaseNonNull());
<span class="line-removed">-         }</span>
      } while (!range.atEnd() &amp;&amp; range.peek().type() != DelimiterToken);
      return values;
  }
  
  static RefPtr&lt;CSSValue&gt; consumeGridTemplatesRowsOrColumns(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
<span class="line-new-header">--- 3448,15 ---</span>
          } else {
              return nullptr;
          }
          if (seenAutoRepeat &amp;&amp; !allTracksAreFixedSized)
              return nullptr;
<span class="line-added">+         if (!allowGridLineNames &amp;&amp; range.peek().type() == LeftBracketToken)</span>
<span class="line-added">+             return nullptr;</span>
          lineNames = consumeGridLineNames(range);
<span class="line-modified">!         if (lineNames)</span>
              values-&gt;append(lineNames.releaseNonNull());
      } while (!range.atEnd() &amp;&amp; range.peek().type() != DelimiterToken);
      return values;
  }
  
  static RefPtr&lt;CSSValue&gt; consumeGridTemplatesRowsOrColumns(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3489,42 ***</span>
  static RefPtr&lt;CSSValue&gt; consumeLineBoxContain(CSSParserTokenRange&amp; range)
  {
      if (range.peek().id() == CSSValueNone)
          return consumeIdent(range);
  
<span class="line-modified">!     LineBoxContain lineBoxContain = LineBoxContainNone;</span>
  
      while (range.peek().type() == IdentToken) {
          auto id = range.peek().id();
          if (id == CSSValueBlock) {
<span class="line-modified">!             if (lineBoxContain &amp; LineBoxContainBlock)</span>
                  return nullptr;
<span class="line-modified">!             lineBoxContain |= LineBoxContainBlock;</span>
          } else if (id == CSSValueInline) {
<span class="line-modified">!             if (lineBoxContain &amp; LineBoxContainInline)</span>
                  return nullptr;
<span class="line-modified">!             lineBoxContain |= LineBoxContainInline;</span>
          } else if (id == CSSValueFont) {
<span class="line-modified">!             if (lineBoxContain &amp; LineBoxContainFont)</span>
                  return nullptr;
<span class="line-modified">!             lineBoxContain |= LineBoxContainFont;</span>
          } else if (id == CSSValueGlyphs) {
<span class="line-modified">!             if (lineBoxContain &amp; LineBoxContainGlyphs)</span>
                  return nullptr;
<span class="line-modified">!             lineBoxContain |= LineBoxContainGlyphs;</span>
          } else if (id == CSSValueReplaced) {
<span class="line-modified">!             if (lineBoxContain &amp; LineBoxContainReplaced)</span>
                  return nullptr;
<span class="line-modified">!             lineBoxContain |= LineBoxContainReplaced;</span>
          } else if (id == CSSValueInlineBox) {
<span class="line-modified">!             if (lineBoxContain &amp; LineBoxContainInlineBox)</span>
                  return nullptr;
<span class="line-modified">!             lineBoxContain |= LineBoxContainInlineBox;</span>
          } else if (id == CSSValueInitialLetter) {
<span class="line-modified">!             if (lineBoxContain &amp; LineBoxContainInitialLetter)</span>
                  return nullptr;
<span class="line-modified">!             lineBoxContain |= LineBoxContainInitialLetter;</span>
          } else
              return nullptr;
          range.consumeIncludingWhitespace();
      }
  
<span class="line-new-header">--- 3490,42 ---</span>
  static RefPtr&lt;CSSValue&gt; consumeLineBoxContain(CSSParserTokenRange&amp; range)
  {
      if (range.peek().id() == CSSValueNone)
          return consumeIdent(range);
  
<span class="line-modified">!     OptionSet&lt;LineBoxContain&gt; lineBoxContain;</span>
  
      while (range.peek().type() == IdentToken) {
          auto id = range.peek().id();
          if (id == CSSValueBlock) {
<span class="line-modified">!             if (lineBoxContain.contains(LineBoxContain::Block))</span>
                  return nullptr;
<span class="line-modified">!             lineBoxContain.add(LineBoxContain::Block);</span>
          } else if (id == CSSValueInline) {
<span class="line-modified">!             if (lineBoxContain.contains(LineBoxContain::Inline))</span>
                  return nullptr;
<span class="line-modified">!             lineBoxContain.add(LineBoxContain::Inline);</span>
          } else if (id == CSSValueFont) {
<span class="line-modified">!             if (lineBoxContain.contains(LineBoxContain::Font))</span>
                  return nullptr;
<span class="line-modified">!             lineBoxContain.add(LineBoxContain::Font);</span>
          } else if (id == CSSValueGlyphs) {
<span class="line-modified">!             if (lineBoxContain.contains(LineBoxContain::Glyphs))</span>
                  return nullptr;
<span class="line-modified">!             lineBoxContain.add(LineBoxContain::Glyphs);</span>
          } else if (id == CSSValueReplaced) {
<span class="line-modified">!             if (lineBoxContain.contains(LineBoxContain::Replaced))</span>
                  return nullptr;
<span class="line-modified">!             lineBoxContain.add(LineBoxContain::Replaced);</span>
          } else if (id == CSSValueInlineBox) {
<span class="line-modified">!             if (lineBoxContain.contains(LineBoxContain::InlineBox))</span>
                  return nullptr;
<span class="line-modified">!             lineBoxContain.add(LineBoxContain::InlineBox);</span>
          } else if (id == CSSValueInitialLetter) {
<span class="line-modified">!             if (lineBoxContain.contains(LineBoxContain::InitialLetter))</span>
                  return nullptr;
<span class="line-modified">!             lineBoxContain.add(LineBoxContain::InitialLetter);</span>
          } else
              return nullptr;
          range.consumeIncludingWhitespace();
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3651,26 ***</span>
      return list-&gt;length() ? list : nullptr;
  }
  
  static RefPtr&lt;CSSValue&gt; consumeWebkitMarqueeIncrement(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
  {
<span class="line-removed">-     if (range.peek().type() == IdentToken)</span>
<span class="line-removed">-         return consumeIdent&lt;CSSValueSmall, CSSValueMedium, CSSValueLarge&gt;(range);</span>
      return consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Allow);
  }
  
  static RefPtr&lt;CSSValue&gt; consumeWebkitMarqueeRepetition(CSSParserTokenRange&amp; range)
  {
<span class="line-removed">-     if (range.peek().type() == IdentToken)</span>
<span class="line-removed">-         return consumeIdent&lt;CSSValueInfinite&gt;(range);</span>
      return consumeNumber(range, ValueRangeNonNegative);
  }
  
  static RefPtr&lt;CSSValue&gt; consumeWebkitMarqueeSpeed(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
  {
<span class="line-removed">-     if (range.peek().type() == IdentToken)</span>
<span class="line-removed">-         return consumeIdent&lt;CSSValueSlow, CSSValueNormal, CSSValueFast&gt;(range);</span>
      return consumeTime(range, cssParserMode, ValueRangeNonNegative, UnitlessQuirk::Allow);
  }
  
  static RefPtr&lt;CSSValue&gt; consumeAlt(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context)
  {
<span class="line-new-header">--- 3652,20 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3687,14 ***</span>
  {
      if (range.peek().type() == IdentToken)
          return consumeIdent&lt;CSSValueAuto, CSSValueFromDimensions, CSSValueFromIntrinsic&gt;(range);
  
      RefPtr&lt;CSSPrimitiveValue&gt; leftValue = consumeNumber(range, ValueRangeNonNegative);
<span class="line-modified">!     if (!leftValue || !leftValue-&gt;floatValue() || range.atEnd() || !consumeSlashIncludingWhitespace(range))</span>
          return nullptr;
      RefPtr&lt;CSSPrimitiveValue&gt; rightValue = consumeNumber(range, ValueRangeNonNegative);
<span class="line-modified">!     if (!rightValue || !rightValue-&gt;floatValue())</span>
          return nullptr;
  
      return CSSAspectRatioValue::create(leftValue-&gt;floatValue(), rightValue-&gt;floatValue());
  }
  
<span class="line-new-header">--- 3682,15 ---</span>
  {
      if (range.peek().type() == IdentToken)
          return consumeIdent&lt;CSSValueAuto, CSSValueFromDimensions, CSSValueFromIntrinsic&gt;(range);
  
      RefPtr&lt;CSSPrimitiveValue&gt; leftValue = consumeNumber(range, ValueRangeNonNegative);
<span class="line-modified">!     if (!leftValue || leftValue-&gt;isZero().valueOr(false) || range.atEnd() || !consumeSlashIncludingWhitespace(range))</span>
          return nullptr;
<span class="line-added">+ </span>
      RefPtr&lt;CSSPrimitiveValue&gt; rightValue = consumeNumber(range, ValueRangeNonNegative);
<span class="line-modified">!     if (!rightValue || rightValue-&gt;isZero().valueOr(false))</span>
          return nullptr;
  
      return CSSAspectRatioValue::create(leftValue-&gt;floatValue(), rightValue-&gt;floatValue());
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3920,18 ***</span>
      case CSSPropertyScrollSnapAlign:
          return consumeScrollSnapAlign(m_range);
      case CSSPropertyScrollSnapType:
          return consumeScrollSnapType(m_range);
  #endif
      case CSSPropertyClip:
          return consumeClip(m_range, m_context.mode);
  #if ENABLE(POINTER_EVENTS)
      case CSSPropertyTouchAction:
          return consumeTouchAction(m_range);
  #endif
      case CSSPropertyObjectPosition:
<span class="line-modified">!         return consumePosition(m_range, m_context.mode, UnitlessQuirk::Forbid);</span>
      case CSSPropertyWebkitLineClamp:
          return consumeLineClamp(m_range);
      case CSSPropertyWebkitFontSizeDelta:
          return consumeLength(m_range, m_context.mode, ValueRangeAll, UnitlessQuirk::Allow);
      case CSSPropertyWebkitHyphenateCharacter:
<span class="line-new-header">--- 3916,22 ---</span>
      case CSSPropertyScrollSnapAlign:
          return consumeScrollSnapAlign(m_range);
      case CSSPropertyScrollSnapType:
          return consumeScrollSnapType(m_range);
  #endif
<span class="line-added">+     case CSSPropertyScrollBehavior:</span>
<span class="line-added">+         if (!m_context.scrollBehaviorEnabled)</span>
<span class="line-added">+             return nullptr;</span>
<span class="line-added">+         return consumeScrollBehavior(m_range);</span>
      case CSSPropertyClip:
          return consumeClip(m_range, m_context.mode);
  #if ENABLE(POINTER_EVENTS)
      case CSSPropertyTouchAction:
          return consumeTouchAction(m_range);
  #endif
      case CSSPropertyObjectPosition:
<span class="line-modified">!         return consumePosition(m_range, m_context.mode, UnitlessQuirk::Forbid, PositionSyntax::Position);</span>
      case CSSPropertyWebkitLineClamp:
          return consumeLineClamp(m_range);
      case CSSPropertyWebkitFontSizeDelta:
          return consumeLength(m_range, m_context.mode, ValueRangeAll, UnitlessQuirk::Allow);
      case CSSPropertyWebkitHyphenateCharacter:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4052,11 ***</span>
      case CSSPropertyOutlineWidth:
          return consumeLineWidth(m_range, m_context.mode, UnitlessQuirk::Forbid);
      case CSSPropertyTransform:
          return consumeTransform(m_range, m_context.mode);
      case CSSPropertyTransformBox:
<span class="line-modified">!         return consumeIdent&lt;CSSValueBorderBox, CSSValueViewBox, CSSValueFillBox&gt;(m_range);</span>
      case CSSPropertyTransformOriginX:
      case CSSPropertyPerspectiveOriginX:
          return consumePositionX(m_range, m_context.mode);
      case CSSPropertyTransformOriginY:
      case CSSPropertyPerspectiveOriginY:
<span class="line-new-header">--- 4052,11 ---</span>
      case CSSPropertyOutlineWidth:
          return consumeLineWidth(m_range, m_context.mode, UnitlessQuirk::Forbid);
      case CSSPropertyTransform:
          return consumeTransform(m_range, m_context.mode);
      case CSSPropertyTransformBox:
<span class="line-modified">!         return consumeIdent&lt;CSSValueBorderBox, CSSValueViewBox, CSSValueFillBox, CSSValueStrokeBox, CSSValueContentBox&gt;(m_range);</span>
      case CSSPropertyTransformOriginX:
      case CSSPropertyPerspectiveOriginX:
          return consumePositionX(m_range, m_context.mode);
      case CSSPropertyTransformOriginY:
      case CSSPropertyPerspectiveOriginY:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4072,11 ***</span>
      case CSSPropertyPaintOrder:
          return consumePaintOrder(m_range);
      case CSSPropertyMarkerStart:
      case CSSPropertyMarkerMid:
      case CSSPropertyMarkerEnd:
<span class="line-removed">-     case CSSPropertyClipPath:</span>
      case CSSPropertyMask:
          return consumeNoneOrURI(m_range);
      case CSSPropertyFlexBasis:
          return consumeFlexBasis(m_range, m_context.mode);
      case CSSPropertyFlexGrow:
<span class="line-new-header">--- 4072,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4089,10 ***</span>
<span class="line-new-header">--- 4088,16 ---</span>
      case CSSPropertyStrokeOpacity:
      case CSSPropertyFillOpacity:
      case CSSPropertyStopOpacity:
      case CSSPropertyFloodOpacity:
      case CSSPropertyOpacity:
<span class="line-added">+     {</span>
<span class="line-added">+         RefPtr&lt;CSSValue&gt; parsedValue = consumeNumber(m_range, ValueRangeAll);</span>
<span class="line-added">+         if (parsedValue)</span>
<span class="line-added">+             return parsedValue;</span>
<span class="line-added">+         return consumePercent(m_range, ValueRangeAll);</span>
<span class="line-added">+     }</span>
      case CSSPropertyWebkitBoxFlex:
          return consumeNumber(m_range, ValueRangeAll);
      case CSSPropertyBaselineShift:
          return consumeBaselineShift(m_range);
      case CSSPropertyKerning:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4103,15 ***</span>
      case CSSPropertyStrokeDashoffset:
      case CSSPropertyCx:
      case CSSPropertyCy:
      case CSSPropertyX:
      case CSSPropertyY:
<span class="line-removed">-     case CSSPropertyR:</span>
          return consumeLengthOrPercent(m_range, SVGAttributeMode, ValueRangeAll, UnitlessQuirk::Forbid);
      case CSSPropertyRx:
      case CSSPropertyRy:
<span class="line-modified">!         return consumeRxOrRy(m_range);</span>
      case CSSPropertyCursor:
          return consumeCursor(m_range, m_context, inQuirksMode());
      case CSSPropertyContent:
          return consumeContent(m_range, m_context);
      case CSSPropertyListStyleImage:
<span class="line-new-header">--- 4108,16 ---</span>
      case CSSPropertyStrokeDashoffset:
      case CSSPropertyCx:
      case CSSPropertyCy:
      case CSSPropertyX:
      case CSSPropertyY:
          return consumeLengthOrPercent(m_range, SVGAttributeMode, ValueRangeAll, UnitlessQuirk::Forbid);
<span class="line-added">+     case CSSPropertyR:</span>
<span class="line-added">+         return consumeLengthOrPercent(m_range, m_context.mode, ValueRangeNonNegative, UnitlessQuirk::Forbid);</span>
      case CSSPropertyRx:
      case CSSPropertyRy:
<span class="line-modified">!         return consumeRxOrRy(m_range, m_context.mode);</span>
      case CSSPropertyCursor:
          return consumeCursor(m_range, m_context, inQuirksMode());
      case CSSPropertyContent:
          return consumeContent(m_range, m_context);
      case CSSPropertyListStyleImage:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4138,12 ***</span>
          return consumeTextDecorationThickness(m_range, m_context.mode);
      case CSSPropertyVerticalAlign:
          return consumeVerticalAlign(m_range, m_context.mode);
      case CSSPropertyShapeOutside:
          return consumeShapeOutside(m_range, m_context);
<span class="line-modified">!     case CSSPropertyWebkitClipPath:</span>
<span class="line-modified">!         return consumeWebkitClipPath(m_range, m_context);</span>
      case CSSPropertyJustifyContent:
          // justify-content property does not allow the &lt;baseline-position&gt; values.
          if (isBaselineKeyword(m_range.peek().id()))
              return nullptr;
          return consumeContentDistributionOverflowPosition(m_range, isContentPositionOrLeftOrRightKeyword);
<span class="line-new-header">--- 4144,12 ---</span>
          return consumeTextDecorationThickness(m_range, m_context.mode);
      case CSSPropertyVerticalAlign:
          return consumeVerticalAlign(m_range, m_context.mode);
      case CSSPropertyShapeOutside:
          return consumeShapeOutside(m_range, m_context);
<span class="line-modified">!     case CSSPropertyClipPath:</span>
<span class="line-modified">!         return consumeClipPath(m_range, m_context);</span>
      case CSSPropertyJustifyContent:
          // justify-content property does not allow the &lt;baseline-position&gt; values.
          if (isBaselineKeyword(m_range.peek().id()))
              return nullptr;
          return consumeContentDistributionOverflowPosition(m_range, isContentPositionOrLeftOrRightKeyword);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4166,14 ***</span>
          return consumeWebkitBorderImage(property, m_range, m_context);
      case CSSPropertyWebkitBoxReflect:
          return consumeReflect(m_range, m_context);
      case CSSPropertyWebkitLineBoxContain:
          return consumeLineBoxContain(m_range);
<span class="line-removed">- #if ENABLE(CSS_IMAGE_ORIENTATION)</span>
<span class="line-removed">-     case CSSPropertyImageOrientation:</span>
<span class="line-removed">-         return consumeImageOrientation(m_range, m_context.mode);</span>
<span class="line-removed">- #endif</span>
      case CSSPropertyBackgroundAttachment:
      case CSSPropertyBackgroundBlendMode:
      case CSSPropertyBackgroundClip:
      case CSSPropertyBackgroundImage:
      case CSSPropertyBackgroundOrigin:
<span class="line-new-header">--- 4172,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4287,17 ***</span>
                  primitiveVal-&gt;collectDirectRootComputationalDependencies(dependencies);
          }
      }
  }
  
<span class="line-modified">! RefPtr&lt;CSSCustomPropertyValue&gt; CSSPropertyParser::parseTypedCustomPropertyValue(const String&amp; name, const String&amp; syntax, const StyleResolver&amp; styleResolver)</span>
  {
      if (syntax != &quot;*&quot;) {
          m_range.consumeWhitespace();
          auto primitiveVal = consumeWidthOrHeight(m_range, m_context);
          if (primitiveVal &amp;&amp; primitiveVal-&gt;isPrimitiveValue() &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(*primitiveVal).isLength()) {
<span class="line-modified">!             auto length = StyleBuilderConverter::convertLength(styleResolver, *primitiveVal);</span>
              if (!length.isCalculated() &amp;&amp; !length.isUndefined())
                  return CSSCustomPropertyValue::createSyntaxLength(name, WTFMove(length));
          }
      } else {
          auto propertyValue = CSSCustomPropertyValue::createSyntaxAll(name, CSSVariableData::create(m_range));
<span class="line-new-header">--- 4289,17 ---</span>
                  primitiveVal-&gt;collectDirectRootComputationalDependencies(dependencies);
          }
      }
  }
  
<span class="line-modified">! RefPtr&lt;CSSCustomPropertyValue&gt; CSSPropertyParser::parseTypedCustomPropertyValue(const String&amp; name, const String&amp; syntax, const Style::BuilderState&amp; builderState)</span>
  {
      if (syntax != &quot;*&quot;) {
          m_range.consumeWhitespace();
          auto primitiveVal = consumeWidthOrHeight(m_range, m_context);
          if (primitiveVal &amp;&amp; primitiveVal-&gt;isPrimitiveValue() &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(*primitiveVal).isLength()) {
<span class="line-modified">!             auto length = Style::BuilderConverter::convertLength(builderState, *primitiveVal);</span>
              if (!length.isCalculated() &amp;&amp; !length.isUndefined())
                  return CSSCustomPropertyValue::createSyntaxLength(name, WTFMove(length));
          }
      } else {
          auto propertyValue = CSSCustomPropertyValue::createSyntaxAll(name, CSSVariableData::create(m_range));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4476,11 ***</span>
      if (!fontDescription.isAbsoluteSize())
          return false;
  
      addProperty(CSSPropertyFontStyle, CSSPropertyFont, CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(isItalic(fontDescription.italic()) ? CSSValueItalic : CSSValueNormal)), important);
      addProperty(CSSPropertyFontWeight, CSSPropertyFont, CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(fontDescription.weight())), important);
<span class="line-modified">!     addProperty(CSSPropertyFontSize, CSSPropertyFont, CSSValuePool::singleton().createValue(fontDescription.specifiedSize(), CSSPrimitiveValue::CSS_PX), important);</span>
      Ref&lt;CSSValueList&gt; fontFamilyList = CSSValueList::createCommaSeparated();
      fontFamilyList-&gt;append(CSSValuePool::singleton().createFontFamilyValue(fontDescription.familyAt(0), FromSystemFontID::Yes));
      addProperty(CSSPropertyFontFamily, CSSPropertyFont, WTFMove(fontFamilyList), important);
      addProperty(CSSPropertyFontVariantCaps, CSSPropertyFont, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
      addProperty(CSSPropertyLineHeight, CSSPropertyFont, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
<span class="line-new-header">--- 4478,11 ---</span>
      if (!fontDescription.isAbsoluteSize())
          return false;
  
      addProperty(CSSPropertyFontStyle, CSSPropertyFont, CSSFontStyleValue::create(CSSValuePool::singleton().createIdentifierValue(isItalic(fontDescription.italic()) ? CSSValueItalic : CSSValueNormal)), important);
      addProperty(CSSPropertyFontWeight, CSSPropertyFont, CSSValuePool::singleton().createValue(static_cast&lt;float&gt;(fontDescription.weight())), important);
<span class="line-modified">!     addProperty(CSSPropertyFontSize, CSSPropertyFont, CSSValuePool::singleton().createValue(fontDescription.specifiedSize(), CSSUnitType::CSS_PX), important);</span>
      Ref&lt;CSSValueList&gt; fontFamilyList = CSSValueList::createCommaSeparated();
      fontFamilyList-&gt;append(CSSValuePool::singleton().createFontFamilyValue(fontDescription.familyAt(0), FromSystemFontID::Yes));
      addProperty(CSSPropertyFontFamily, CSSPropertyFont, WTFMove(fontFamilyList), important);
      addProperty(CSSPropertyFontVariantCaps, CSSPropertyFont, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
      addProperty(CSSPropertyLineHeight, CSSPropertyFont, CSSValuePool::singleton().createIdentifierValue(CSSValueNormal), important);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4845,11 ***</span>
                  if (flexGrow == unsetValue)
                      flexGrow = num;
                  else if (flexShrink == unsetValue)
                      flexShrink = num;
                  else if (!num) // flex only allows a basis of 0 (sans units) if flex-grow and flex-shrink values have already been set.
<span class="line-modified">!                     flexBasis = CSSPrimitiveValue::create(0, CSSPrimitiveValue::UnitType::CSS_PX);</span>
                  else
                      return false;
              } else if (!flexBasis) {
                  if (m_range.peek().id() == CSSValueAuto)
                      flexBasis = consumeIdent(m_range);
<span class="line-new-header">--- 4847,11 ---</span>
                  if (flexGrow == unsetValue)
                      flexGrow = num;
                  else if (flexShrink == unsetValue)
                      flexShrink = num;
                  else if (!num) // flex only allows a basis of 0 (sans units) if flex-grow and flex-shrink values have already been set.
<span class="line-modified">!                     flexBasis = CSSPrimitiveValue::create(0, CSSUnitType::CSS_PX);</span>
                  else
                      return false;
              } else if (!flexBasis) {
                  if (m_range.peek().id() == CSSValueAuto)
                      flexBasis = consumeIdent(m_range);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4869,17 ***</span>
          // FIXME: Using % here is a hack to work around intrinsic sizing implementation being
          // a mess (e.g., turned off for nested column flexboxes, failing to relayout properly even
          // if turned back on for nested columns, etc.). We have layout test coverage of both
          // scenarios.
          if (!flexBasis)
<span class="line-modified">!             flexBasis = CSSPrimitiveValue::create(0, CSSPrimitiveValue::UnitType::CSS_PERCENTAGE);</span>
      }
  
      if (!m_range.atEnd())
          return false;
<span class="line-modified">!     addProperty(CSSPropertyFlexGrow, CSSPropertyFlex, CSSPrimitiveValue::create(clampTo&lt;float&gt;(flexGrow), CSSPrimitiveValue::UnitType::CSS_NUMBER), important);</span>
<span class="line-modified">!     addProperty(CSSPropertyFlexShrink, CSSPropertyFlex, CSSPrimitiveValue::create(clampTo&lt;float&gt;(flexShrink), CSSPrimitiveValue::UnitType::CSS_NUMBER), important);</span>
      addProperty(CSSPropertyFlexBasis, CSSPropertyFlex, flexBasis.releaseNonNull(), important);
      return true;
  }
  
  bool CSSPropertyParser::consumeBorder(RefPtr&lt;CSSValue&gt;&amp; width, RefPtr&lt;CSSValue&gt;&amp; style, RefPtr&lt;CSSValue&gt;&amp; color)
<span class="line-new-header">--- 4871,17 ---</span>
          // FIXME: Using % here is a hack to work around intrinsic sizing implementation being
          // a mess (e.g., turned off for nested column flexboxes, failing to relayout properly even
          // if turned back on for nested columns, etc.). We have layout test coverage of both
          // scenarios.
          if (!flexBasis)
<span class="line-modified">!             flexBasis = CSSPrimitiveValue::create(0, CSSUnitType::CSS_PERCENTAGE);</span>
      }
  
      if (!m_range.atEnd())
          return false;
<span class="line-modified">!     addProperty(CSSPropertyFlexGrow, CSSPropertyFlex, CSSPrimitiveValue::create(clampTo&lt;float&gt;(flexGrow), CSSUnitType::CSS_NUMBER), important);</span>
<span class="line-modified">!     addProperty(CSSPropertyFlexShrink, CSSPropertyFlex, CSSPrimitiveValue::create(clampTo&lt;float&gt;(flexShrink), CSSUnitType::CSS_NUMBER), important);</span>
      addProperty(CSSPropertyFlexBasis, CSSPropertyFlex, flexBasis.releaseNonNull(), important);
      return true;
  }
  
  bool CSSPropertyParser::consumeBorder(RefPtr&lt;CSSValue&gt;&amp; width, RefPtr&lt;CSSValue&gt;&amp; style, RefPtr&lt;CSSValue&gt;&amp; color)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5087,11 ***</span>
  static bool consumeBackgroundPosition(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, UnitlessQuirk unitless, RefPtr&lt;CSSValue&gt;&amp; resultX, RefPtr&lt;CSSValue&gt;&amp; resultY)
  {
      do {
          RefPtr&lt;CSSPrimitiveValue&gt; positionX;
          RefPtr&lt;CSSPrimitiveValue&gt; positionY;
<span class="line-modified">!         if (!consumePosition(range, context.mode, unitless, positionX, positionY))</span>
              return false;
          addBackgroundValue(resultX, positionX.releaseNonNull());
          addBackgroundValue(resultY, positionY.releaseNonNull());
      } while (consumeCommaIncludingWhitespace(range));
      return true;
<span class="line-new-header">--- 5089,11 ---</span>
  static bool consumeBackgroundPosition(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, UnitlessQuirk unitless, RefPtr&lt;CSSValue&gt;&amp; resultX, RefPtr&lt;CSSValue&gt;&amp; resultY)
  {
      do {
          RefPtr&lt;CSSPrimitiveValue&gt; positionX;
          RefPtr&lt;CSSPrimitiveValue&gt; positionY;
<span class="line-modified">!         if (!consumePosition(range, context.mode, unitless, PositionSyntax::BackgroundPosition, positionX, positionY))</span>
              return false;
          addBackgroundValue(resultX, positionX.releaseNonNull());
          addBackgroundValue(resultY, positionY.releaseNonNull());
      } while (consumeCommaIncludingWhitespace(range));
      return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5165,11 ***</span>
                      valueY = primitiveValueY;
                  } else if (property == CSSPropertyBackgroundPositionX || property == CSSPropertyWebkitMaskPositionX) {
                      CSSParserTokenRange rangeCopy = m_range;
                      RefPtr&lt;CSSPrimitiveValue&gt; primitiveValue;
                      RefPtr&lt;CSSPrimitiveValue&gt; primitiveValueY;
<span class="line-modified">!                     if (!consumePosition(rangeCopy, m_context.mode, UnitlessQuirk::Forbid, primitiveValue, primitiveValueY))</span>
                          continue;
                      value = primitiveValue;
                      valueY = primitiveValueY;
                      m_range = rangeCopy;
                  } else if (property == CSSPropertyBackgroundSize || property == CSSPropertyWebkitMaskSize) {
<span class="line-new-header">--- 5167,11 ---</span>
                      valueY = primitiveValueY;
                  } else if (property == CSSPropertyBackgroundPositionX || property == CSSPropertyWebkitMaskPositionX) {
                      CSSParserTokenRange rangeCopy = m_range;
                      RefPtr&lt;CSSPrimitiveValue&gt; primitiveValue;
                      RefPtr&lt;CSSPrimitiveValue&gt; primitiveValueY;
<span class="line-modified">!                     if (!consumePosition(rangeCopy, m_context.mode, UnitlessQuirk::Forbid, PositionSyntax::BackgroundPosition, primitiveValue, primitiveValueY))</span>
                          continue;
                      value = primitiveValue;
                      valueY = primitiveValueY;
                      m_range = rangeCopy;
                  } else if (property == CSSPropertyBackgroundSize || property == CSSPropertyWebkitMaskSize) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5226,10 ***</span>
<span class="line-new-header">--- 5228,39 ---</span>
          addProperty(property, shorthand.id(), *longhands[i], important, implicit);
      }
      return true;
  }
  
<span class="line-added">+ bool CSSPropertyParser::consumeOverflowShorthand(bool important)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     CSSValueID xValueID = m_range.consumeIncludingWhitespace().id();</span>
<span class="line-added">+     if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyOverflowY, xValueID, m_context))</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     CSSValueID yValueID;</span>
<span class="line-added">+     if (m_range.atEnd()) {</span>
<span class="line-added">+         yValueID = xValueID;</span>
<span class="line-added">+ </span>
<span class="line-added">+         // FIXME: -webkit-paged-x or -webkit-paged-y only apply to overflow-y. If this value has been</span>
<span class="line-added">+         // set using the shorthand, then for now overflow-x will default to auto, but once we implement</span>
<span class="line-added">+         // pagination controls, it should default to hidden. If the overflow-y value is anything but</span>
<span class="line-added">+         // paged-x or paged-y, then overflow-x and overflow-y should have the same value.</span>
<span class="line-added">+         if (xValueID == CSSValueWebkitPagedX || xValueID == CSSValueWebkitPagedY)</span>
<span class="line-added">+             xValueID = CSSValueAuto;</span>
<span class="line-added">+     } else</span>
<span class="line-added">+         yValueID = m_range.consumeIncludingWhitespace().id();</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyOverflowY, yValueID, m_context))</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     if (!m_range.atEnd())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     addProperty(CSSPropertyOverflowX, CSSPropertyOverflow, CSSValuePool::singleton().createIdentifierValue(xValueID), important);</span>
<span class="line-added">+     addProperty(CSSPropertyOverflowY, CSSPropertyOverflow, CSSValuePool::singleton().createIdentifierValue(yValueID), important);</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // FIXME-NEWPARSER: Hack to work around the fact that we aren&#39;t using CSSCustomIdentValue
  // for stuff yet. This can be replaced by CSSValue::isCustomIdentValue() once we switch
  // to using CSSCustomIdentValue everywhere.
  static bool isCustomIdentValue(const CSSValue&amp; value)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5585,31 ***</span>
          if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyWebkitMarginAfterCollapse, id, m_context))
              return false;
          addProperty(CSSPropertyWebkitMarginAfterCollapse, CSSPropertyWebkitMarginCollapse, CSSValuePool::singleton().createIdentifierValue(id), important);
          return true;
      }
<span class="line-modified">!     case CSSPropertyOverflow: {</span>
<span class="line-modified">!         CSSValueID id = m_range.consumeIncludingWhitespace().id();</span>
<span class="line-removed">-         if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyOverflowY, id, m_context))</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         if (!m_range.atEnd())</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         RefPtr&lt;CSSValue&gt; overflowYValue = CSSValuePool::singleton().createIdentifierValue(id);</span>
<span class="line-removed">-         RefPtr&lt;CSSValue&gt; overflowXValue;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // FIXME: -webkit-paged-x or -webkit-paged-y only apply to overflow-y. If this value has been</span>
<span class="line-removed">-         // set using the shorthand, then for now overflow-x will default to auto, but once we implement</span>
<span class="line-removed">-         // pagination controls, it should default to hidden. If the overflow-y value is anything but</span>
<span class="line-removed">-         // paged-x or paged-y, then overflow-x and overflow-y should have the same value.</span>
<span class="line-removed">-         if (id == CSSValueWebkitPagedX || id == CSSValueWebkitPagedY)</span>
<span class="line-removed">-             overflowXValue = CSSValuePool::singleton().createIdentifierValue(CSSValueAuto);</span>
<span class="line-removed">-         else</span>
<span class="line-removed">-             overflowXValue = overflowYValue;</span>
<span class="line-removed">-         addProperty(CSSPropertyOverflowX, CSSPropertyOverflow, *overflowXValue, important);</span>
<span class="line-removed">-         addProperty(CSSPropertyOverflowY, CSSPropertyOverflow, *overflowYValue, important);</span>
<span class="line-removed">-         return true;</span>
<span class="line-removed">-     }</span>
      case CSSPropertyFont: {
          const CSSParserToken&amp; token = m_range.peek();
          if (token.id() &gt;= CSSValueCaption &amp;&amp; token.id() &lt;= CSSValueStatusBar)
              return consumeSystemFont(important);
          return consumeFont(important);
<span class="line-new-header">--- 5616,12 ---</span>
          if (!CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyWebkitMarginAfterCollapse, id, m_context))
              return false;
          addProperty(CSSPropertyWebkitMarginAfterCollapse, CSSPropertyWebkitMarginCollapse, CSSValuePool::singleton().createIdentifierValue(id), important);
          return true;
      }
<span class="line-modified">!     case CSSPropertyOverflow:</span>
<span class="line-modified">!         return consumeOverflowShorthand(important);</span>
      case CSSPropertyFont: {
          const CSSParserToken&amp; token = m_range.peek();
          if (token.id() &gt;= CSSValueCaption &amp;&amp; token.id() &lt;= CSSValueStatusBar)
              return consumeSystemFont(important);
          return consumeFont(important);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5822,12 ***</span>
          return consumePlaceContentShorthand(important);
      case CSSPropertyPlaceItems:
          return consumePlaceItemsShorthand(important);
      case CSSPropertyPlaceSelf:
          return consumePlaceSelfShorthand(important);
<span class="line-removed">-     case CSSPropertyWebkitMarquee:</span>
<span class="line-removed">-         return consumeShorthandGreedily(webkitMarqueeShorthand(), important);</span>
      default:
          return false;
      }
  }
  
<span class="line-new-header">--- 5834,10 ---</span>
</pre>
<center><a href="CSSParserToken.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSPropertyParser.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
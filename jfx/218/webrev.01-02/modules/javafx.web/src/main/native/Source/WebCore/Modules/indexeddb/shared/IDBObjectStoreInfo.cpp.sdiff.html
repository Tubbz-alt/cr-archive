<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/shared/IDBObjectStoreInfo.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IDBIterateCursorData.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="IDBObjectStoreInfo.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/shared/IDBObjectStoreInfo.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 26 #include &quot;config.h&quot;
 27 #include &quot;IDBObjectStoreInfo.h&quot;
 28 #include &lt;wtf/text/StringBuilder.h&gt;
 29 
 30 #if ENABLE(INDEXED_DATABASE)
 31 
 32 namespace WebCore {
 33 
 34 IDBObjectStoreInfo::IDBObjectStoreInfo()
 35 {
 36 }
 37 
 38 IDBObjectStoreInfo::IDBObjectStoreInfo(uint64_t identifier, const String&amp; name, Optional&lt;IDBKeyPath&gt;&amp;&amp; keyPath, bool autoIncrement)
 39     : m_identifier(identifier)
 40     , m_name(name)
 41     , m_keyPath(WTFMove(keyPath))
 42     , m_autoIncrement(autoIncrement)
 43 {
 44 }
 45 
<span class="line-modified"> 46 IDBIndexInfo IDBObjectStoreInfo::createNewIndex(const String&amp; name, IDBKeyPath&amp;&amp; keyPath, bool unique, bool multiEntry)</span>
 47 {
<span class="line-modified"> 48     IDBIndexInfo info(++m_maxIndexID, m_identifier, name, WTFMove(keyPath), unique, multiEntry);</span>
 49     m_indexMap.set(info.identifier(), info);
 50     return info;
 51 }
 52 
 53 void IDBObjectStoreInfo::addExistingIndex(const IDBIndexInfo&amp; info)
 54 {
 55     ASSERT(!m_indexMap.contains(info.identifier()));
 56 
<span class="line-removed"> 57     if (info.identifier() &gt; m_maxIndexID)</span>
<span class="line-removed"> 58         m_maxIndexID = info.identifier();</span>
<span class="line-removed"> 59 </span>
 60     m_indexMap.set(info.identifier(), info);
 61 }
 62 
 63 bool IDBObjectStoreInfo::hasIndex(const String&amp; name) const
 64 {
 65     for (auto&amp; index : m_indexMap.values()) {
 66         if (index.name() == name)
 67             return true;
 68     }
 69 
 70     return false;
 71 }
 72 
 73 bool IDBObjectStoreInfo::hasIndex(uint64_t indexIdentifier) const
 74 {
 75     return m_indexMap.contains(indexIdentifier);
 76 }
 77 
 78 IDBIndexInfo* IDBObjectStoreInfo::infoForExistingIndex(const String&amp; name)
 79 {
</pre>
<hr />
<pre>
 81         if (index.name() == name)
 82             return &amp;index;
 83     }
 84 
 85     return nullptr;
 86 }
 87 
 88 IDBIndexInfo* IDBObjectStoreInfo::infoForExistingIndex(uint64_t identifier)
 89 {
 90     auto iterator = m_indexMap.find(identifier);
 91     if (iterator == m_indexMap.end())
 92         return nullptr;
 93 
 94     return &amp;iterator-&gt;value;
 95 }
 96 
 97 IDBObjectStoreInfo IDBObjectStoreInfo::isolatedCopy() const
 98 {
 99     IDBObjectStoreInfo result = { m_identifier, m_name.isolatedCopy(), WebCore::isolatedCopy(m_keyPath), m_autoIncrement };
100 
<span class="line-modified">101     for (auto&amp; iterator : m_indexMap) {</span>
102         result.m_indexMap.set(iterator.key, iterator.value.isolatedCopy());
<span class="line-removed">103         if (iterator.key &gt; result.m_maxIndexID)</span>
<span class="line-removed">104             result.m_maxIndexID = iterator.key;</span>
<span class="line-removed">105     }</span>
<span class="line-removed">106 </span>
<span class="line-removed">107     ASSERT(result.m_maxIndexID == m_maxIndexID);</span>
108 
109     return result;
110 }
111 
112 Vector&lt;String&gt; IDBObjectStoreInfo::indexNames() const
113 {
114     Vector&lt;String&gt; names;
115     names.reserveCapacity(m_indexMap.size());
116     for (auto&amp; index : m_indexMap.values())
117         names.uncheckedAppend(index.name());
118 
119     return names;
120 }
121 
122 void IDBObjectStoreInfo::deleteIndex(const String&amp; indexName)
123 {
124     auto* info = infoForExistingIndex(indexName);
125     if (!info)
126         return;
127 
</pre>
</td>
<td>
<hr />
<pre>
 26 #include &quot;config.h&quot;
 27 #include &quot;IDBObjectStoreInfo.h&quot;
 28 #include &lt;wtf/text/StringBuilder.h&gt;
 29 
 30 #if ENABLE(INDEXED_DATABASE)
 31 
 32 namespace WebCore {
 33 
 34 IDBObjectStoreInfo::IDBObjectStoreInfo()
 35 {
 36 }
 37 
 38 IDBObjectStoreInfo::IDBObjectStoreInfo(uint64_t identifier, const String&amp; name, Optional&lt;IDBKeyPath&gt;&amp;&amp; keyPath, bool autoIncrement)
 39     : m_identifier(identifier)
 40     , m_name(name)
 41     , m_keyPath(WTFMove(keyPath))
 42     , m_autoIncrement(autoIncrement)
 43 {
 44 }
 45 
<span class="line-modified"> 46 IDBIndexInfo IDBObjectStoreInfo::createNewIndex(uint64_t indexID, const String&amp; name, IDBKeyPath&amp;&amp; keyPath, bool unique, bool multiEntry)</span>
 47 {
<span class="line-modified"> 48     IDBIndexInfo info(indexID, m_identifier, name, WTFMove(keyPath), unique, multiEntry);</span>
 49     m_indexMap.set(info.identifier(), info);
 50     return info;
 51 }
 52 
 53 void IDBObjectStoreInfo::addExistingIndex(const IDBIndexInfo&amp; info)
 54 {
 55     ASSERT(!m_indexMap.contains(info.identifier()));
 56 



 57     m_indexMap.set(info.identifier(), info);
 58 }
 59 
 60 bool IDBObjectStoreInfo::hasIndex(const String&amp; name) const
 61 {
 62     for (auto&amp; index : m_indexMap.values()) {
 63         if (index.name() == name)
 64             return true;
 65     }
 66 
 67     return false;
 68 }
 69 
 70 bool IDBObjectStoreInfo::hasIndex(uint64_t indexIdentifier) const
 71 {
 72     return m_indexMap.contains(indexIdentifier);
 73 }
 74 
 75 IDBIndexInfo* IDBObjectStoreInfo::infoForExistingIndex(const String&amp; name)
 76 {
</pre>
<hr />
<pre>
 78         if (index.name() == name)
 79             return &amp;index;
 80     }
 81 
 82     return nullptr;
 83 }
 84 
 85 IDBIndexInfo* IDBObjectStoreInfo::infoForExistingIndex(uint64_t identifier)
 86 {
 87     auto iterator = m_indexMap.find(identifier);
 88     if (iterator == m_indexMap.end())
 89         return nullptr;
 90 
 91     return &amp;iterator-&gt;value;
 92 }
 93 
 94 IDBObjectStoreInfo IDBObjectStoreInfo::isolatedCopy() const
 95 {
 96     IDBObjectStoreInfo result = { m_identifier, m_name.isolatedCopy(), WebCore::isolatedCopy(m_keyPath), m_autoIncrement };
 97 
<span class="line-modified"> 98     for (auto&amp; iterator : m_indexMap)</span>
 99         result.m_indexMap.set(iterator.key, iterator.value.isolatedCopy());





100 
101     return result;
102 }
103 
104 Vector&lt;String&gt; IDBObjectStoreInfo::indexNames() const
105 {
106     Vector&lt;String&gt; names;
107     names.reserveCapacity(m_indexMap.size());
108     for (auto&amp; index : m_indexMap.values())
109         names.uncheckedAppend(index.name());
110 
111     return names;
112 }
113 
114 void IDBObjectStoreInfo::deleteIndex(const String&amp; indexName)
115 {
116     auto* info = infoForExistingIndex(indexName);
117     if (!info)
118         return;
119 
</pre>
</td>
</tr>
</table>
<center><a href="IDBIterateCursorData.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="IDBObjectStoreInfo.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/modern-media-controls/controls/auto-hide-controller.js</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Apple Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 const AutoHideDelayMS = 4000;
 27 
 28 class AutoHideController
 29 {
 30 
 31     constructor(mediaControls)
 32     {
 33         this._mediaControls = mediaControls;
 34 
 35         this._pointerIdentifiersPreventingAutoHide = new Set;
 36         this._pointerIdentifiersPreventingAutoHideForHover = new Set;
 37 
 38         if (GestureRecognizer.SupportsTouches)
 39             this._tapGestureRecognizer = new TapGestureRecognizer(this._mediaControls.element, this);
 40 
 41         this.autoHideDelay = AutoHideDelayMS;
 42     }
 43 
 44     // Public
 45 
 46     get fadesWhileIdle()
 47     {
 48         return this._fadesWhileIdle;
 49     }
 50 
 51     set fadesWhileIdle(flag)
 52     {
 53         if (this._fadesWhileIdle == flag)
 54             return;
 55 
 56         this._fadesWhileIdle = flag;
 57 
 58         if (flag) {
 59             this._mediaControls.element.addEventListener(&quot;pointermove&quot;, this);
 60             this._mediaControls.element.addEventListener(&quot;pointerdown&quot;, this);
 61             this._mediaControls.element.addEventListener(&quot;pointerup&quot;, this);
 62             this._mediaControls.element.addEventListener(&quot;pointerleave&quot;, this);
 63             this._mediaControls.element.addEventListener(&quot;pointerout&quot;, this);
 64         } else {
 65             this._mediaControls.element.removeEventListener(&quot;pointermove&quot;, this);
 66             this._mediaControls.element.removeEventListener(&quot;pointerdown&quot;, this);
 67             this._mediaControls.element.removeEventListener(&quot;pointerup&quot;, this);
 68             this._mediaControls.element.removeEventListener(&quot;pointerleave&quot;, this);
 69             this._mediaControls.element.removeEventListener(&quot;pointerout&quot;, this);
 70         }
 71 
 72         if (flag &amp;&amp; !this._mediaControls.faded)
 73             this._resetAutoHideTimer(false);
 74         else if (!flag)
 75             this._mediaControls.faded = false;
 76     }
 77 
 78     // Protected
 79 
 80     handleEvent(event)
 81     {
 82         if (event.currentTarget !== this._mediaControls.element)
 83             return;
 84 
 85         if (event.type === &quot;pointermove&quot;) {
 86             this._mediaControls.faded = false;
 87             this._resetAutoHideTimer(true);
 88             if (this._mediaControls.isPointInControls(new DOMPoint(event.clientX, event.clientY))) {
 89                 this._pointerIdentifiersPreventingAutoHideForHover.add(event.pointerId);
 90                 this._cancelNonEnforcedAutoHideTimer();
 91             } else {
 92                 this._pointerIdentifiersPreventingAutoHideForHover.delete(event.pointerId);
 93                 this._resetAutoHideTimer(true);
 94             }
 95         } else if (event.type === &quot;pointerleave&quot; &amp;&amp; this._fadesWhileIdle &amp;&amp; !this.hasSecondaryUIAttached &amp;&amp; !this._enforceAutoHideTimer) {
 96             this._pointerIdentifiersPreventingAutoHide.delete(event.pointerId);
 97             this._pointerIdentifiersPreventingAutoHideForHover.delete(event.pointerId);
 98 
 99             // If the pointer is a mouse (supports hover), see if we can
100             // immediately hide without waiting for the auto-hide timer.
101             if (event.pointerType == &quot;mouse&quot;)
102                 this._autoHideTimerFired();
103 
104             this._resetAutoHideTimer(true);
105         }
106 
107         if (event.type === &quot;pointerdown&quot;) {
108             // Remember the current faded state so that we can determine,
109             // if we recognize a tap, if it should fade the controls out.
110             this._nextTapCanFadeControls = !this._mediaControls.faded;
111             this._pointerIdentifiersPreventingAutoHide.add(event.pointerId);
112             this._mediaControls.faded = false;
113             this._cancelNonEnforcedAutoHideTimer();
114         } else if (event.type === &quot;pointerup&quot;) {
115             this._pointerIdentifiersPreventingAutoHide.delete(event.pointerId);
116             this._resetAutoHideTimer(true);
117         }
118     }
119 
120     gestureRecognizerStateDidChange(recognizer)
121     {
122         if (this._tapGestureRecognizer !== recognizer || recognizer.state !== GestureRecognizer.States.Recognized)
123             return;
124 
125         this._mediaControls.faded = this._nextTapCanFadeControls &amp;&amp; !this._mediaControls.isPointInControls(recognizer.locationInClient());
126         delete this._nextTapCanFadeControls;
127     }
128 
129     mediaControlsFadedStateDidChange()
130     {
131         if (this._mediaControls.faded)
132             delete this._enforceAutoHideTimer;
133         else
134             this._resetAutoHideTimer(true);
135     }
136 
137     mediaControlsBecameInvisible()
138     {
139         this._cancelNonEnforcedAutoHideTimer();
140     }
141 
142     // Private
143 
144     _cancelNonEnforcedAutoHideTimer()
145     {
146         if (!this._enforceAutoHideTimer)
147             this._cancelAutoHideTimer();
148     }
149 
150     _cancelAutoHideTimer()
151     {
152         window.clearTimeout(this._autoHideTimer);
153         delete this._autoHideTimer;
154     }
155 
156     _resetAutoHideTimer(cancelable)
157     {
158         if (cancelable &amp;&amp; this._enforceAutoHideTimer)
159             return;
160 
161         this._cancelAutoHideTimer();
162 
163         if (cancelable)
164             delete this._enforceAutoHideTimer;
165         else
166             this._enforceAutoHideTimer = true;
167 
168         this._autoHideTimer = window.setTimeout(this._autoHideTimerFired.bind(this), this.autoHideDelay);
169     }
170 
171     _autoHideTimerFired()
172     {
173         const disableAutoHiding = this._pointerIdentifiersPreventingAutoHide.size || this._pointerIdentifiersPreventingAutoHideForHover.size;
174 
175         delete this._enforceAutoHideTimer;
176         if (disableAutoHiding)
177             return;
178 
179         this._cancelAutoHideTimer();
180         this._mediaControls.faded = this._fadesWhileIdle &amp;&amp; !this.hasSecondaryUIAttached;
181     }
182 
183 }
    </pre>
  </body>
</html>
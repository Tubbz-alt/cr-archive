<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirCustom.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;AirCustom.h&quot;
 28 
 29 #if ENABLE(B3_JIT)
 30 
 31 #include &quot;AirInstInlines.h&quot;
 32 #include &quot;B3CCallValue.h&quot;
 33 #include &quot;B3ValueInlines.h&quot;
 34 #include &quot;CCallHelpers.h&quot;
 35 
 36 namespace JSC { namespace B3 { namespace Air {
 37 
 38 bool PatchCustom::isValidForm(Inst&amp; inst)
 39 {
 40     if (inst.args.size() &lt; 1)
 41         return false;
 42     if (!inst.args[0].isSpecial())
 43         return false;
 44     if (!inst.args[0].special()-&gt;isValid(inst))
 45         return false;
 46     RegisterSet clobberedEarly = inst.extraEarlyClobberedRegs();
 47     RegisterSet clobberedLate = inst.extraClobberedRegs();
 48     bool ok = true;
 49     inst.forEachTmp(
 50         [&amp;] (Tmp&amp; tmp, Arg::Role role, Bank, Width) {
 51             if (!tmp.isReg())
 52                 return;
 53             if (Arg::isLateDef(role) || Arg::isLateUse(role))
 54                 ok &amp;= !clobberedLate.get(tmp.reg());
 55             else
 56                 ok &amp;= !clobberedEarly.get(tmp.reg());
 57         });
 58     return ok;
 59 }
 60 
 61 bool CCallCustom::isValidForm(Inst&amp; inst)
 62 {
 63     CCallValue* value = inst.origin-&gt;as&lt;CCallValue&gt;();
 64     if (!value)
 65         return false;
 66 
 67     if (inst.args.size() != (value-&gt;type() == Void ? 0 : 1) + value-&gt;numChildren())
 68         return false;
 69 
 70     // The arguments can only refer to the stack, tmps, or immediates.
 71     for (Arg&amp; arg : inst.args) {
 72         if (!arg.isTmp() &amp;&amp; !arg.isStackMemory() &amp;&amp; !arg.isSomeImm())
 73             return false;
 74     }
 75 
 76     unsigned offset = 0;
 77 
 78     if (!inst.args[0].isGP())
 79         return false;
 80 
 81     // If there is a result then it cannot be an immediate.
 82     if (value-&gt;type() != Void) {
 83         if (inst.args[1].isSomeImm())
 84             return false;
 85         if (!inst.args[1].canRepresent(value))
 86             return false;
 87         offset++;
 88     }
 89 
 90     for (unsigned i = value-&gt;numChildren(); i-- &gt; 1;) {
 91         Value* child = value-&gt;child(i);
 92         Arg arg = inst.args[offset + i];
 93         if (!arg.canRepresent(child))
 94             return false;
 95     }
 96 
 97     return true;
 98 }
 99 
100 MacroAssembler::Jump CCallCustom::generate(Inst&amp; inst, CCallHelpers&amp;, GenerationContext&amp;)
101 {
102     dataLog(&quot;FATAL: Unlowered C call: &quot;, inst, &quot;\n&quot;);
103     UNREACHABLE_FOR_PLATFORM();
104     return MacroAssembler::Jump();
105 }
106 
107 bool ShuffleCustom::isValidForm(Inst&amp; inst)
108 {
109     if (inst.args.size() % 3)
110         return false;
111 
112     // A destination may only appear once. This requirement allows us to avoid the undefined behavior
113     // of having a destination that is supposed to get multiple inputs simultaneously. It also
114     // imposes some interesting constraints on the &quot;shape&quot; of the shuffle. If we treat a shuffle pair
115     // as an edge and the Args as nodes, then the single-destination requirement means that the
116     // shuffle graph consists of two kinds of subgraphs:
117     //
118     // - Spanning trees. We call these shifts. They can be executed as a sequence of Move
119     //   instructions and don&#39;t usually require scratch registers.
120     //
121     // - Closed loops. These loops consist of nodes that have one successor and one predecessor, so
122     //   there is no way to &quot;get into&quot; the loop from outside of it. These can be executed using swaps
123     //   or by saving one of the Args to a scratch register and executing it as a shift.
124     HashSet&lt;Arg&gt; dsts;
125 
126     for (unsigned i = 0; i &lt; inst.args.size(); ++i) {
127         Arg arg = inst.args[i];
128         unsigned mode = i % 3;
129 
130         if (mode == 2) {
131             // It&#39;s the width.
132             if (!arg.isWidthArg())
133                 return false;
134             continue;
135         }
136 
137         // The source can be an immediate.
138         if (!mode) {
139             if (arg.isSomeImm())
140                 continue;
141 
142             if (!arg.isCompatibleBank(inst.args[i + 1]))
143                 return false;
144         } else {
145             ASSERT(mode == 1);
146             if (!dsts.add(arg).isNewEntry)
147                 return false;
148         }
149 
150         if (arg.isTmp() || arg.isMemory())
151             continue;
152 
153         return false;
154     }
155 
156     // No destination register may appear in any address expressions. The lowering can&#39;t handle it
157     // and it&#39;s not useful for the way we end up using Shuffles. Normally, Shuffles only used for
158     // stack addresses and non-stack registers.
159     for (Arg&amp; arg : inst.args) {
160         if (!arg.isMemory())
161             continue;
162         bool ok = true;
163         arg.forEachTmpFast(
164             [&amp;] (Tmp tmp) {
165                 if (dsts.contains(tmp))
166                     ok = false;
167             });
168         if (!ok)
169             return false;
170     }
171 
172     return true;
173 }
174 
175 MacroAssembler::Jump ShuffleCustom::generate(Inst&amp; inst, CCallHelpers&amp;, GenerationContext&amp;)
176 {
177     dataLog(&quot;FATAL: Unlowered shuffle: &quot;, inst, &quot;\n&quot;);
178     UNREACHABLE_FOR_PLATFORM();
179     return MacroAssembler::Jump();
180 }
181 
182 bool WasmBoundsCheckCustom::isValidForm(Inst&amp; inst)
183 {
184     if (inst.args.size() != 2)
185         return false;
186     if (!inst.args[0].isTmp() &amp;&amp; !inst.args[0].isSomeImm())
187         return false;
188 
189     return inst.args[1].isReg() || inst.args[1].isTmp() || inst.args[1].isSomeImm();
190 }
191 
192 MacroAssembler::Jump WasmBoundsCheckCustom::generate(Inst&amp; inst, CCallHelpers&amp; jit, GenerationContext&amp; context)
193 {
194     WasmBoundsCheckValue* value = inst.origin-&gt;as&lt;WasmBoundsCheckValue&gt;();
195     MacroAssembler::Jump outOfBounds = Inst(Air::Branch64, value, Arg::relCond(MacroAssembler::AboveOrEqual), inst.args[0], inst.args[1]).generate(jit, context);
196 
197     context.latePaths.append(createSharedTask&lt;GenerationContext::LatePathFunction&gt;(
198         [outOfBounds, value] (CCallHelpers&amp; jit, Air::GenerationContext&amp; context) {
199             outOfBounds.link(&amp;jit);
200             switch (value-&gt;boundsType()) {
201             case WasmBoundsCheckValue::Type::Pinned:
202                 context.code-&gt;wasmBoundsCheckGenerator()-&gt;run(jit, value-&gt;bounds().pinnedSize);
203                 break;
204 
205             case WasmBoundsCheckValue::Type::Maximum:
206                 context.code-&gt;wasmBoundsCheckGenerator()-&gt;run(jit, InvalidGPRReg);
207                 break;
208             }
209         }));
210 
211     // We said we were not a terminal.
212     return MacroAssembler::Jump();
213 }
214 
215 } } } // namespace JSC::B3::Air
216 
217 #endif // ENABLE(B3_JIT)
218 
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGTypeCheckHoistingPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGToFTLForOSREntryDeferredCompilationCallback.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGUseKind.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGTypeCheckHoistingPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
126                     // Insert a GetLocal and a CheckStructure immediately following this
127                     // SetArgumentDefinitely, if the variable was a candidate for structure hoisting.
128                     // If the basic block previously only had the SetArgumentDefinitely as its
129                     // variable-at-tail, then replace it with this GetLocal.
130                     VariableAccessData* variable = node-&gt;variableAccessData();
131                     HashMap&lt;VariableAccessData*, CheckData&gt;::iterator iter = m_map.find(variable);
132                     if (iter == m_map.end())
133                         break;
134                     if (!iter-&gt;value.m_structure &amp;&amp; !iter-&gt;value.m_arrayModeIsValid)
135                         break;
136 
137                     // Currently we should only be doing this hoisting for SetArguments at a CFG root.
138                     ASSERT(m_graph.isRoot(block));
139 
140                     NodeOrigin origin = node-&gt;origin;
141                     RELEASE_ASSERT(origin.exitOK);
142 
143                     Node* getLocal = insertionSet.insertNode(
144                         indexInBlock + 1, variable-&gt;prediction(), GetLocal, origin,
145                         OpInfo(variable), Edge(node));
<span class="line-modified">146                     if (iter-&gt;value.m_structure) {</span>
<span class="line-modified">147                         auto checkOp = CheckStructure;</span>
<span class="line-modified">148                         if (SpecCellCheck &amp; SpecEmpty) {</span>
<span class="line-modified">149                             VirtualRegister local = node-&gt;variableAccessData()-&gt;local();</span>
<span class="line-modified">150                             auto* inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();</span>
<span class="line-modified">151                             if ((local - (inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0)) == virtualRegisterForArgument(0)) {</span>
<span class="line-modified">152                                 // |this| can be the TDZ value. The call entrypoint won&#39;t have |this| as TDZ,</span>
<span class="line-modified">153                                 // but a catch or a loop OSR entry may have |this| be TDZ.</span>
<span class="line-modified">154                                 checkOp = CheckStructureOrEmpty;</span>
<span class="line-modified">155                             }</span>
156                         }


157 




158                         insertionSet.insertNode(
159                             indexInBlock + 1, SpecNone, checkOp, origin,
160                             OpInfo(m_graph.addStructureSet(iter-&gt;value.m_structure)),
161                             Edge(getLocal, CellUse));
162                     } else if (iter-&gt;value.m_arrayModeIsValid) {
163                         ASSERT(iter-&gt;value.m_arrayModeHoistingOkay);



164                         insertionSet.insertNode(
<span class="line-modified">165                             indexInBlock + 1, SpecNone, CheckArray, origin,</span>
166                             OpInfo(iter-&gt;value.m_arrayMode.asWord()),
167                             Edge(getLocal, CellUse));
168                     } else
169                         RELEASE_ASSERT_NOT_REACHED();
170 
<span class="line-modified">171                     if (block-&gt;variablesAtTail.operand(variable-&gt;local()) == node)</span>
<span class="line-modified">172                         block-&gt;variablesAtTail.operand(variable-&gt;local()) = getLocal;</span>
173 
174                     m_graph.substituteGetLocal(*block, indexInBlock, variable, getLocal);
175 
176                     changed = true;
177                     break;
178                 }
179 
180                 case SetLocal: {
181                     VariableAccessData* variable = node-&gt;variableAccessData();
182                     HashMap&lt;VariableAccessData*, CheckData&gt;::iterator iter = m_map.find(variable);
183                     if (iter == m_map.end())
184                         break;
185                     if (!iter-&gt;value.m_structure &amp;&amp; !iter-&gt;value.m_arrayModeIsValid)
186                         break;
187 
188                     NodeOrigin origin = node-&gt;origin;
189                     Edge child1 = node-&gt;child1();
190 





191                     if (iter-&gt;value.m_structure) {
<span class="line-removed">192                         // Note: On 64-bit platforms, cell checks allow the empty value to flow through.</span>
<span class="line-removed">193                         // This means that this structure check may see the empty value as input. We need</span>
<span class="line-removed">194                         // to emit a node that explicitly handles the empty value. Most of the time, CheckStructureOrEmpty</span>
<span class="line-removed">195                         // will be folded to CheckStructure because AI proves that the incoming value is</span>
<span class="line-removed">196                         // definitely not empty.</span>
197                         insertionSet.insertNode(
198                             indexForChecks, SpecNone, (SpecCellCheck &amp; SpecEmpty) ? CheckStructureOrEmpty : CheckStructure,
199                             originForChecks.withSemantic(origin.semantic),
200                             OpInfo(m_graph.addStructureSet(iter-&gt;value.m_structure)),
201                             Edge(child1.node(), CellUse));
202                     } else if (iter-&gt;value.m_arrayModeIsValid) {
203                         ASSERT(iter-&gt;value.m_arrayModeHoistingOkay);
204                         insertionSet.insertNode(
<span class="line-modified">205                             indexForChecks, SpecNone, CheckArray,</span>
206                             originForChecks.withSemantic(origin.semantic),
207                             OpInfo(iter-&gt;value.m_arrayMode.asWord()),
208                             Edge(child1.node(), CellUse));
209                     } else
210                         RELEASE_ASSERT_NOT_REACHED();
211                     changed = true;
212                     break;
213                 }
214 
215                 default:
216                     break;
217                 }
218             }
219             insertionSet.execute(block);
220         }
221 
222         return changed;
223     }
224 
225 private:
</pre>
<hr />
<pre>
254                         break;
255                     noticeStructureCheck(variable, node-&gt;structureSet());
256                     break;
257                 }
258 
259                 case ArrayifyToStructure:
260                 case Arrayify:
261                 case GetByOffset:
262                 case PutByOffset:
263                 case PutStructure:
264                 case AllocatePropertyStorage:
265                 case ReallocatePropertyStorage:
266                 case NukeStructureAndSetButterfly:
267                 case GetButterfly:
268                 case GetByVal:
269                 case PutByValDirect:
270                 case PutByVal:
271                 case PutByValAlias:
272                 case GetArrayLength:
273                 case CheckArray:

274                 case GetIndexedPropertyStorage:
275                 case GetTypedArrayByteOffset:
276                 case Phantom:
277                 case MovHint:
278                 case MultiGetByOffset:
279                 case MultiPutByOffset:
280                     // Don&#39;t count these uses.
281                     break;
282 
283                 case SetLocal: {
284                     // Find all uses of the source of the SetLocal. If any of them are a
285                     // kind of CheckStructure, then we should notice them to ensure that
286                     // we&#39;re not hoisting a check that would contravene checks that are
287                     // already being performed.
288                     VariableAccessData* variable = node-&gt;variableAccessData();
289                     if (!shouldConsiderForHoisting&lt;StructureTypeCheck&gt;(variable))
290                         break;
291                     Node* source = node-&gt;child1().node();
292                     for (auto* subNode : *block) {
293                         switch (subNode-&gt;op()) {
</pre>
<hr />
<pre>
319     {
320         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
321             BasicBlock* block = m_graph.block(blockIndex);
322             if (!block)
323                 continue;
324             for (auto* node : *block) {
325                 switch (node-&gt;op()) {
326                 case CheckArray: {
327                     Node* child = node-&gt;child1().node();
328                     if (child-&gt;op() != GetLocal)
329                         break;
330                     VariableAccessData* variable = child-&gt;variableAccessData();
331                     variable-&gt;vote(VoteCheckArray);
332                     if (!shouldConsiderForHoisting&lt;ArrayTypeCheck&gt;(variable))
333                         break;
334                     noticeCheckArray(variable, node-&gt;arrayMode());
335                     break;
336                 }
337 
338                 case CheckStructure:

339                 case GetByOffset:
340                 case PutByOffset:
341                 case PutStructure:
342                 case ReallocatePropertyStorage:
343                 case GetButterfly:
344                 case GetByVal:
345                 case PutByValDirect:
346                 case PutByVal:
347                 case PutByValAlias:
348                 case GetArrayLength:
349                 case GetIndexedPropertyStorage:
350                 case Phantom:
351                 case MovHint:
352                 case MultiGetByOffset:
353                 case MultiPutByOffset:
354                     // Don&#39;t count these uses.
355                     break;
356 
357                 case AllocatePropertyStorage:
358                 case ArrayifyToStructure:
</pre>
<hr />
<pre>
429         }
430     }
431 
432     // Disable check hoisting for variables that cross the OSR entry that
433     // we&#39;re currently taking, and where the value currently does not have the
434     // particular form we want (e.g. a contradictory ArrayMode or Struture).
435     template &lt;typename TypeCheck&gt;
436     void disableHoistingAcrossOSREntries()
437     {
438         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
439             BasicBlock* block = m_graph.block(blockIndex);
440             if (!block)
441                 continue;
442             ASSERT(block-&gt;isReachable);
443             if (!block-&gt;isOSRTarget)
444                 continue;
445             if (block-&gt;bytecodeBegin != m_graph.m_plan.osrEntryBytecodeIndex())
446                 continue;
447             const Operands&lt;Optional&lt;JSValue&gt;&gt;&amp; mustHandleValues = m_graph.m_plan.mustHandleValues();
448             for (size_t i = 0; i &lt; mustHandleValues.size(); ++i) {
<span class="line-modified">449                 int operand = mustHandleValues.operandForIndex(i);</span>
450                 Node* node = block-&gt;variablesAtHead.operand(operand);
451                 if (!node)
452                     continue;
453                 VariableAccessData* variable = node-&gt;variableAccessData();
454                 HashMap&lt;VariableAccessData*, CheckData&gt;::iterator iter = m_map.find(variable);
455                 if (iter == m_map.end())
456                     continue;
457                 if (!TypeCheck::isValidToHoist(iter-&gt;value))
458                     continue;
459                 Optional&lt;JSValue&gt; value = mustHandleValues[i];
460                 if (!value || !value.value() || !value.value().isCell() || TypeCheck::isContravenedByValue(iter-&gt;value, value.value())) {
461                     TypeCheck::disableHoisting(iter-&gt;value);
462                     continue;
463                 }
464             }
465         }
466     }
467 
468     void disableCheckArrayHoisting(VariableAccessData* variable)
469     {
</pre>
</td>
<td>
<hr />
<pre>
126                     // Insert a GetLocal and a CheckStructure immediately following this
127                     // SetArgumentDefinitely, if the variable was a candidate for structure hoisting.
128                     // If the basic block previously only had the SetArgumentDefinitely as its
129                     // variable-at-tail, then replace it with this GetLocal.
130                     VariableAccessData* variable = node-&gt;variableAccessData();
131                     HashMap&lt;VariableAccessData*, CheckData&gt;::iterator iter = m_map.find(variable);
132                     if (iter == m_map.end())
133                         break;
134                     if (!iter-&gt;value.m_structure &amp;&amp; !iter-&gt;value.m_arrayModeIsValid)
135                         break;
136 
137                     // Currently we should only be doing this hoisting for SetArguments at a CFG root.
138                     ASSERT(m_graph.isRoot(block));
139 
140                     NodeOrigin origin = node-&gt;origin;
141                     RELEASE_ASSERT(origin.exitOK);
142 
143                     Node* getLocal = insertionSet.insertNode(
144                         indexInBlock + 1, variable-&gt;prediction(), GetLocal, origin,
145                         OpInfo(variable), Edge(node));
<span class="line-modified">146 </span>
<span class="line-modified">147                     auto needsEmptyCheck = [](Node* node) -&gt; bool {</span>
<span class="line-modified">148                         if (!(SpecCellCheck &amp; SpecEmpty))</span>
<span class="line-modified">149                             return false;</span>
<span class="line-modified">150                         VirtualRegister local = node-&gt;variableAccessData()-&gt;operand().virtualRegister();</span>
<span class="line-modified">151                         auto* inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();</span>
<span class="line-modified">152                         if ((local - (inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0)) == virtualRegisterForArgumentIncludingThis(0)) {</span>
<span class="line-modified">153                             // |this| can be the TDZ value. The call entrypoint won&#39;t have |this| as TDZ,</span>
<span class="line-modified">154                             // but a catch or a loop OSR entry may have |this| be TDZ.</span>
<span class="line-modified">155                             return true;</span>
156                         }
<span class="line-added">157                         return false;</span>
<span class="line-added">158                     };</span>
159 
<span class="line-added">160                     if (iter-&gt;value.m_structure) {</span>
<span class="line-added">161                         auto checkOp = CheckStructure;</span>
<span class="line-added">162                         if (needsEmptyCheck(node))</span>
<span class="line-added">163                             checkOp = CheckStructureOrEmpty;</span>
164                         insertionSet.insertNode(
165                             indexInBlock + 1, SpecNone, checkOp, origin,
166                             OpInfo(m_graph.addStructureSet(iter-&gt;value.m_structure)),
167                             Edge(getLocal, CellUse));
168                     } else if (iter-&gt;value.m_arrayModeIsValid) {
169                         ASSERT(iter-&gt;value.m_arrayModeHoistingOkay);
<span class="line-added">170                         auto checkOp = CheckArray;</span>
<span class="line-added">171                         if (needsEmptyCheck(node))</span>
<span class="line-added">172                             checkOp = CheckArrayOrEmpty;</span>
173                         insertionSet.insertNode(
<span class="line-modified">174                             indexInBlock + 1, SpecNone, checkOp, origin,</span>
175                             OpInfo(iter-&gt;value.m_arrayMode.asWord()),
176                             Edge(getLocal, CellUse));
177                     } else
178                         RELEASE_ASSERT_NOT_REACHED();
179 
<span class="line-modified">180                     if (block-&gt;variablesAtTail.operand(variable-&gt;operand()) == node)</span>
<span class="line-modified">181                         block-&gt;variablesAtTail.operand(variable-&gt;operand()) = getLocal;</span>
182 
183                     m_graph.substituteGetLocal(*block, indexInBlock, variable, getLocal);
184 
185                     changed = true;
186                     break;
187                 }
188 
189                 case SetLocal: {
190                     VariableAccessData* variable = node-&gt;variableAccessData();
191                     HashMap&lt;VariableAccessData*, CheckData&gt;::iterator iter = m_map.find(variable);
192                     if (iter == m_map.end())
193                         break;
194                     if (!iter-&gt;value.m_structure &amp;&amp; !iter-&gt;value.m_arrayModeIsValid)
195                         break;
196 
197                     NodeOrigin origin = node-&gt;origin;
198                     Edge child1 = node-&gt;child1();
199 
<span class="line-added">200                     // Note: On 64-bit platforms, cell checks allow the empty value to flow through.</span>
<span class="line-added">201                     // This means that this structure/array check may see the empty value as input. We need</span>
<span class="line-added">202                     // to emit a node that explicitly handles the empty value. Most of the time, CheckStructureOrEmpty/CheckArrayOrEmpty</span>
<span class="line-added">203                     // will be folded to CheckStructure/CheckArray because AI proves that the incoming value is</span>
<span class="line-added">204                     // definitely not empty.</span>
205                     if (iter-&gt;value.m_structure) {





206                         insertionSet.insertNode(
207                             indexForChecks, SpecNone, (SpecCellCheck &amp; SpecEmpty) ? CheckStructureOrEmpty : CheckStructure,
208                             originForChecks.withSemantic(origin.semantic),
209                             OpInfo(m_graph.addStructureSet(iter-&gt;value.m_structure)),
210                             Edge(child1.node(), CellUse));
211                     } else if (iter-&gt;value.m_arrayModeIsValid) {
212                         ASSERT(iter-&gt;value.m_arrayModeHoistingOkay);
213                         insertionSet.insertNode(
<span class="line-modified">214                             indexForChecks, SpecNone, (SpecCellCheck &amp; SpecEmpty) ? CheckArrayOrEmpty : CheckArray,</span>
215                             originForChecks.withSemantic(origin.semantic),
216                             OpInfo(iter-&gt;value.m_arrayMode.asWord()),
217                             Edge(child1.node(), CellUse));
218                     } else
219                         RELEASE_ASSERT_NOT_REACHED();
220                     changed = true;
221                     break;
222                 }
223 
224                 default:
225                     break;
226                 }
227             }
228             insertionSet.execute(block);
229         }
230 
231         return changed;
232     }
233 
234 private:
</pre>
<hr />
<pre>
263                         break;
264                     noticeStructureCheck(variable, node-&gt;structureSet());
265                     break;
266                 }
267 
268                 case ArrayifyToStructure:
269                 case Arrayify:
270                 case GetByOffset:
271                 case PutByOffset:
272                 case PutStructure:
273                 case AllocatePropertyStorage:
274                 case ReallocatePropertyStorage:
275                 case NukeStructureAndSetButterfly:
276                 case GetButterfly:
277                 case GetByVal:
278                 case PutByValDirect:
279                 case PutByVal:
280                 case PutByValAlias:
281                 case GetArrayLength:
282                 case CheckArray:
<span class="line-added">283                 case CheckNeutered:</span>
284                 case GetIndexedPropertyStorage:
285                 case GetTypedArrayByteOffset:
286                 case Phantom:
287                 case MovHint:
288                 case MultiGetByOffset:
289                 case MultiPutByOffset:
290                     // Don&#39;t count these uses.
291                     break;
292 
293                 case SetLocal: {
294                     // Find all uses of the source of the SetLocal. If any of them are a
295                     // kind of CheckStructure, then we should notice them to ensure that
296                     // we&#39;re not hoisting a check that would contravene checks that are
297                     // already being performed.
298                     VariableAccessData* variable = node-&gt;variableAccessData();
299                     if (!shouldConsiderForHoisting&lt;StructureTypeCheck&gt;(variable))
300                         break;
301                     Node* source = node-&gt;child1().node();
302                     for (auto* subNode : *block) {
303                         switch (subNode-&gt;op()) {
</pre>
<hr />
<pre>
329     {
330         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
331             BasicBlock* block = m_graph.block(blockIndex);
332             if (!block)
333                 continue;
334             for (auto* node : *block) {
335                 switch (node-&gt;op()) {
336                 case CheckArray: {
337                     Node* child = node-&gt;child1().node();
338                     if (child-&gt;op() != GetLocal)
339                         break;
340                     VariableAccessData* variable = child-&gt;variableAccessData();
341                     variable-&gt;vote(VoteCheckArray);
342                     if (!shouldConsiderForHoisting&lt;ArrayTypeCheck&gt;(variable))
343                         break;
344                     noticeCheckArray(variable, node-&gt;arrayMode());
345                     break;
346                 }
347 
348                 case CheckStructure:
<span class="line-added">349                 case CheckNeutered:</span>
350                 case GetByOffset:
351                 case PutByOffset:
352                 case PutStructure:
353                 case ReallocatePropertyStorage:
354                 case GetButterfly:
355                 case GetByVal:
356                 case PutByValDirect:
357                 case PutByVal:
358                 case PutByValAlias:
359                 case GetArrayLength:
360                 case GetIndexedPropertyStorage:
361                 case Phantom:
362                 case MovHint:
363                 case MultiGetByOffset:
364                 case MultiPutByOffset:
365                     // Don&#39;t count these uses.
366                     break;
367 
368                 case AllocatePropertyStorage:
369                 case ArrayifyToStructure:
</pre>
<hr />
<pre>
440         }
441     }
442 
443     // Disable check hoisting for variables that cross the OSR entry that
444     // we&#39;re currently taking, and where the value currently does not have the
445     // particular form we want (e.g. a contradictory ArrayMode or Struture).
446     template &lt;typename TypeCheck&gt;
447     void disableHoistingAcrossOSREntries()
448     {
449         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
450             BasicBlock* block = m_graph.block(blockIndex);
451             if (!block)
452                 continue;
453             ASSERT(block-&gt;isReachable);
454             if (!block-&gt;isOSRTarget)
455                 continue;
456             if (block-&gt;bytecodeBegin != m_graph.m_plan.osrEntryBytecodeIndex())
457                 continue;
458             const Operands&lt;Optional&lt;JSValue&gt;&gt;&amp; mustHandleValues = m_graph.m_plan.mustHandleValues();
459             for (size_t i = 0; i &lt; mustHandleValues.size(); ++i) {
<span class="line-modified">460                 Operand operand = mustHandleValues.operandForIndex(i);</span>
461                 Node* node = block-&gt;variablesAtHead.operand(operand);
462                 if (!node)
463                     continue;
464                 VariableAccessData* variable = node-&gt;variableAccessData();
465                 HashMap&lt;VariableAccessData*, CheckData&gt;::iterator iter = m_map.find(variable);
466                 if (iter == m_map.end())
467                     continue;
468                 if (!TypeCheck::isValidToHoist(iter-&gt;value))
469                     continue;
470                 Optional&lt;JSValue&gt; value = mustHandleValues[i];
471                 if (!value || !value.value() || !value.value().isCell() || TypeCheck::isContravenedByValue(iter-&gt;value, value.value())) {
472                     TypeCheck::disableHoisting(iter-&gt;value);
473                     continue;
474                 }
475             }
476         }
477     }
478 
479     void disableCheckArrayHoisting(VariableAccessData* variable)
480     {
</pre>
</td>
</tr>
</table>
<center><a href="DFGToFTLForOSREntryDeferredCompilationCallback.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGUseKind.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
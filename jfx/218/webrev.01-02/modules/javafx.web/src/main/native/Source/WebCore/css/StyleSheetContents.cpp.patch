diff a/modules/javafx.web/src/main/native/Source/WebCore/css/StyleSheetContents.cpp b/modules/javafx.web/src/main/native/Source/WebCore/css/StyleSheetContents.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/css/StyleSheetContents.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/css/StyleSheetContents.cpp
@@ -50,11 +50,11 @@
 
 // Rough size estimate for the memory cache.
 unsigned StyleSheetContents::estimatedSizeInBytes() const
 {
     // Note that this does not take into account size of the strings hanging from various objects.
-    // The assumption is that nearly all of of them are atomic and would exist anyway.
+    // The assumption is that nearly all of of them are atoms that would exist anyway.
     unsigned size = sizeof(*this);
 
     // FIXME: This ignores the children of media and region rules.
     // Most rules are StyleRules.
     size += ruleCount() * StyleRule::averageSizeInBytes();
@@ -154,12 +154,12 @@
     if (is<StyleRuleMedia>(rule))
         reportMediaQueryWarningIfNeeded(singleOwnerDocument(), downcast<StyleRuleMedia>(rule.get()).mediaQueries());
 
     // NOTE: The selector list has to fit into RuleData. <http://webkit.org/b/118369>
     // If we're adding a rule with a huge number of selectors, split it up into multiple rules
-    if (is<StyleRule>(rule) && downcast<StyleRule>(rule.get()).selectorList().componentCount() > RuleData::maximumSelectorComponentCount) {
-        m_childRules.appendVector(downcast<StyleRule>(rule.get()).splitIntoMultipleRulesWithMaximumSelectorComponentCount(RuleData::maximumSelectorComponentCount));
+    if (is<StyleRule>(rule) && downcast<StyleRule>(rule.get()).selectorList().componentCount() > Style::RuleData::maximumSelectorComponentCount) {
+        m_childRules.appendVector(downcast<StyleRule>(rule.get()).splitIntoMultipleRulesWithMaximumSelectorComponentCount(Style::RuleData::maximumSelectorComponentCount));
         return;
     }
 
     m_childRules.append(WTFMove(rule));
 }
@@ -262,11 +262,11 @@
     if (is<StyleRuleNamespace>(rule))
         return false;
     childVectorIndex -= m_namespaceRules.size();
 
     // If the number of selectors would overflow RuleData, we drop the operation.
-    if (is<StyleRule>(rule) && downcast<StyleRule>(rule.get()).selectorList().componentCount() > RuleData::maximumSelectorComponentCount)
+    if (is<StyleRule>(rule) && downcast<StyleRule>(rule.get()).selectorList().componentCount() > Style::RuleData::maximumSelectorComponentCount)
         return false;
 
     m_childRules.insert(childVectorIndex, WTFMove(rule));
     return true;
 }
@@ -314,11 +314,11 @@
     if (it == m_namespaces.end())
         return nullAtom();
     return it->value;
 }
 
-void StyleSheetContents::parseAuthorStyleSheet(const CachedCSSStyleSheet* cachedStyleSheet, const SecurityOrigin* securityOrigin)
+bool StyleSheetContents::parseAuthorStyleSheet(const CachedCSSStyleSheet* cachedStyleSheet, const SecurityOrigin* securityOrigin)
 {
     bool isSameOriginRequest = securityOrigin && securityOrigin->canRequest(baseURL());
     CachedCSSStyleSheet::MIMETypeCheckHint mimeTypeCheckHint = isStrictParserMode(m_parserContext.mode) || !isSameOriginRequest ? CachedCSSStyleSheet::MIMETypeCheckHint::Strict : CachedCSSStyleSheet::MIMETypeCheckHint::Lax;
     bool hasValidMIMEType = true;
     String sheetText = cachedStyleSheet->sheetText(mimeTypeCheckHint, &hasValidMIMEType);
@@ -333,14 +333,15 @@
                     page->console().addMessage(MessageSource::Security, MessageLevel::Error, makeString("Did not parse stylesheet at '", cachedStyleSheet->url().stringCenterEllipsizedToLength(), "' because non CSS MIME types are not allowed when 'X-Content-Type: nosniff' is given."));
                 else
                     page->console().addMessage(MessageSource::Security, MessageLevel::Error, makeString("Did not parse stylesheet at '", cachedStyleSheet->url().stringCenterEllipsizedToLength(), "' because non CSS MIME types are not allowed for cross-origin stylesheets."));
             }
         }
-        return;
+        return false;
     }
 
     CSSParser(parserContext()).parseSheet(this, sheetText, CSSParser::RuleParsing::Deferred);
+    return true;
 }
 
 bool StyleSheetContents::parseString(const String& sheetText)
 {
     CSSParser p(parserContext());
@@ -424,30 +425,30 @@
 {
     for (auto& rule : rules) {
         if (handler(*rule))
             return true;
         switch (rule->type()) {
-        case StyleRuleBase::Media: {
+        case StyleRuleType::Media: {
             auto* childRules = downcast<StyleRuleMedia>(*rule).childRulesWithoutDeferredParsing();
             if (childRules && traverseRulesInVector(*childRules, handler))
                 return true;
             break;
         }
-        case StyleRuleBase::Import:
+        case StyleRuleType::Import:
             ASSERT_NOT_REACHED();
             break;
-        case StyleRuleBase::Style:
-        case StyleRuleBase::FontFace:
-        case StyleRuleBase::Page:
-        case StyleRuleBase::Keyframes:
-        case StyleRuleBase::Namespace:
-        case StyleRuleBase::Unknown:
-        case StyleRuleBase::Charset:
-        case StyleRuleBase::Keyframe:
-        case StyleRuleBase::Supports:
+        case StyleRuleType::Style:
+        case StyleRuleType::FontFace:
+        case StyleRuleType::Page:
+        case StyleRuleType::Keyframes:
+        case StyleRuleType::Namespace:
+        case StyleRuleType::Unknown:
+        case StyleRuleType::Charset:
+        case StyleRuleType::Keyframe:
+        case StyleRuleType::Supports:
 #if ENABLE(CSS_DEVICE_ADAPTATION)
-        case StyleRuleBase::Viewport:
+        case StyleRuleType::Viewport:
 #endif
             break;
         }
     }
     return false;
@@ -467,30 +468,30 @@
 
 bool StyleSheetContents::traverseSubresources(const WTF::Function<bool (const CachedResource&)>& handler) const
 {
     return traverseRules([&] (const StyleRuleBase& rule) {
         switch (rule.type()) {
-        case StyleRuleBase::Style: {
+        case StyleRuleType::Style: {
             auto* properties = downcast<StyleRule>(rule).propertiesWithoutDeferredParsing();
             return properties && properties->traverseSubresources(handler);
         }
-        case StyleRuleBase::FontFace:
+        case StyleRuleType::FontFace:
             return downcast<StyleRuleFontFace>(rule).properties().traverseSubresources(handler);
-        case StyleRuleBase::Import:
+        case StyleRuleType::Import:
             if (auto* cachedResource = downcast<StyleRuleImport>(rule).cachedCSSStyleSheet())
                 return handler(*cachedResource);
             return false;
-        case StyleRuleBase::Media:
-        case StyleRuleBase::Page:
-        case StyleRuleBase::Keyframes:
-        case StyleRuleBase::Namespace:
-        case StyleRuleBase::Unknown:
-        case StyleRuleBase::Charset:
-        case StyleRuleBase::Keyframe:
-        case StyleRuleBase::Supports:
+        case StyleRuleType::Media:
+        case StyleRuleType::Page:
+        case StyleRuleType::Keyframes:
+        case StyleRuleType::Namespace:
+        case StyleRuleType::Unknown:
+        case StyleRuleType::Charset:
+        case StyleRuleType::Keyframe:
+        case StyleRuleType::Supports:
 #if ENABLE(CSS_DEVICE_ADAPTATION)
-        case StyleRuleBase::Viewport:
+        case StyleRuleType::Viewport:
 #endif
             return false;
         };
         ASSERT_NOT_REACHED();
         return false;

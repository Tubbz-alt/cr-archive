<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/nicosia/ScrollingTreeFrameScrollingNodeNicosia.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScrollingTreeFixedNode.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ScrollingTreeFrameScrollingNodeNicosia.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/nicosia/ScrollingTreeFrameScrollingNodeNicosia.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2018 Igalia S.L.</span>

  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above
 11  *    copyright notice, this list of conditions and the following
 12  *    disclaimer in the documentation and/or other materials provided
 13  *    with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 16  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 17  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 18  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 19  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 20  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 21  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 22  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 23  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;ScrollingTreeFrameScrollingNodeNicosia.h&quot;
 30 
 31 #if ENABLE(ASYNC_SCROLLING) &amp;&amp; USE(NICOSIA)
 32 






 33 namespace WebCore {
 34 
 35 Ref&lt;ScrollingTreeFrameScrollingNode&gt; ScrollingTreeFrameScrollingNodeNicosia::create(ScrollingTree&amp; scrollingTree, ScrollingNodeType nodeType, ScrollingNodeID nodeID)
 36 {
 37     return adoptRef(*new ScrollingTreeFrameScrollingNodeNicosia(scrollingTree, nodeType, nodeID));
 38 }
 39 
 40 ScrollingTreeFrameScrollingNodeNicosia::ScrollingTreeFrameScrollingNodeNicosia(ScrollingTree&amp; scrollingTree, ScrollingNodeType nodeType, ScrollingNodeID nodeID)
 41     : ScrollingTreeFrameScrollingNode(scrollingTree, nodeType, nodeID)
 42 {
 43 }
 44 
 45 ScrollingTreeFrameScrollingNodeNicosia::~ScrollingTreeFrameScrollingNodeNicosia() = default;
 46 
<span class="line-modified"> 47 ScrollingEventResult ScrollingTreeFrameScrollingNodeNicosia::handleWheelEvent(const PlatformWheelEvent&amp;)</span>
 48 {
<span class="line-modified"> 49     return ScrollingEventResult::DidNotHandleEvent;</span>












































































 50 }
 51 
 52 void ScrollingTreeFrameScrollingNodeNicosia::repositionScrollingLayers()
 53 {




























































 54 }
 55 
 56 } // namespace WebCore
 57 
 58 #endif // ENABLE(ASYNC_SCROLLING) &amp;&amp; USE(NICOSIA)
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2012, 2014-2015 Apple Inc. All rights reserved.</span>
<span class="line-added">  3  * Copyright (C) 2019 Igalia S.L.</span>
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above
 12  *    copyright notice, this list of conditions and the following
 13  *    disclaimer in the documentation and/or other materials provided
 14  *    with the distribution.
 15  *
 16  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 17  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 18  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 19  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 20  * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 21  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 22  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 23  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 24  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 26  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;ScrollingTreeFrameScrollingNodeNicosia.h&quot;
 31 
 32 #if ENABLE(ASYNC_SCROLLING) &amp;&amp; USE(NICOSIA)
 33 
<span class="line-added"> 34 #include &quot;FrameView.h&quot;</span>
<span class="line-added"> 35 #include &quot;Logging.h&quot;</span>
<span class="line-added"> 36 #include &quot;NicosiaPlatformLayer.h&quot;</span>
<span class="line-added"> 37 #include &quot;ScrollingStateFrameScrollingNode.h&quot;</span>
<span class="line-added"> 38 #include &quot;ScrollingTree.h&quot;</span>
<span class="line-added"> 39 </span>
 40 namespace WebCore {
 41 
 42 Ref&lt;ScrollingTreeFrameScrollingNode&gt; ScrollingTreeFrameScrollingNodeNicosia::create(ScrollingTree&amp; scrollingTree, ScrollingNodeType nodeType, ScrollingNodeID nodeID)
 43 {
 44     return adoptRef(*new ScrollingTreeFrameScrollingNodeNicosia(scrollingTree, nodeType, nodeID));
 45 }
 46 
 47 ScrollingTreeFrameScrollingNodeNicosia::ScrollingTreeFrameScrollingNodeNicosia(ScrollingTree&amp; scrollingTree, ScrollingNodeType nodeType, ScrollingNodeID nodeID)
 48     : ScrollingTreeFrameScrollingNode(scrollingTree, nodeType, nodeID)
 49 {
 50 }
 51 
 52 ScrollingTreeFrameScrollingNodeNicosia::~ScrollingTreeFrameScrollingNodeNicosia() = default;
 53 
<span class="line-modified"> 54 void ScrollingTreeFrameScrollingNodeNicosia::commitStateBeforeChildren(const ScrollingStateNode&amp; stateNode)</span>
 55 {
<span class="line-modified"> 56     ScrollingTreeFrameScrollingNode::commitStateBeforeChildren(stateNode);</span>
<span class="line-added"> 57 </span>
<span class="line-added"> 58     const auto&amp; scrollingStateNode = downcast&lt;ScrollingStateFrameScrollingNode&gt;(stateNode);</span>
<span class="line-added"> 59 </span>
<span class="line-added"> 60     if (scrollingStateNode.hasChangedProperty(ScrollingStateFrameScrollingNode::RootContentsLayer)) {</span>
<span class="line-added"> 61         auto* layer = static_cast&lt;Nicosia::PlatformLayer*&gt;(scrollingStateNode.rootContentsLayer());</span>
<span class="line-added"> 62         m_rootContentsLayer = downcast&lt;Nicosia::CompositionLayer&gt;(layer);</span>
<span class="line-added"> 63     }</span>
<span class="line-added"> 64     if (scrollingStateNode.hasChangedProperty(ScrollingStateFrameScrollingNode::CounterScrollingLayer)) {</span>
<span class="line-added"> 65         auto* layer = static_cast&lt;Nicosia::PlatformLayer*&gt;(scrollingStateNode.counterScrollingLayer());</span>
<span class="line-added"> 66         m_counterScrollingLayer = downcast&lt;Nicosia::CompositionLayer&gt;(layer);</span>
<span class="line-added"> 67     }</span>
<span class="line-added"> 68     if (scrollingStateNode.hasChangedProperty(ScrollingStateFrameScrollingNode::InsetClipLayer)) {</span>
<span class="line-added"> 69         auto* layer = static_cast&lt;Nicosia::PlatformLayer*&gt;(scrollingStateNode.insetClipLayer());</span>
<span class="line-added"> 70         m_insetClipLayer = downcast&lt;Nicosia::CompositionLayer&gt;(layer);</span>
<span class="line-added"> 71     }</span>
<span class="line-added"> 72     if (scrollingStateNode.hasChangedProperty(ScrollingStateFrameScrollingNode::ContentShadowLayer)) {</span>
<span class="line-added"> 73         auto* layer = static_cast&lt;Nicosia::PlatformLayer*&gt;(scrollingStateNode.contentShadowLayer());</span>
<span class="line-added"> 74         m_contentShadowLayer = downcast&lt;Nicosia::CompositionLayer&gt;(layer);</span>
<span class="line-added"> 75     }</span>
<span class="line-added"> 76     if (scrollingStateNode.hasChangedProperty(ScrollingStateFrameScrollingNode::HeaderLayer)) {</span>
<span class="line-added"> 77         auto* layer = static_cast&lt;Nicosia::PlatformLayer*&gt;(scrollingStateNode.headerLayer());</span>
<span class="line-added"> 78         m_headerLayer = downcast&lt;Nicosia::CompositionLayer&gt;(layer);</span>
<span class="line-added"> 79     }</span>
<span class="line-added"> 80     if (scrollingStateNode.hasChangedProperty(ScrollingStateFrameScrollingNode::FooterLayer)) {</span>
<span class="line-added"> 81         auto* layer = static_cast&lt;Nicosia::PlatformLayer*&gt;(scrollingStateNode.footerLayer());</span>
<span class="line-added"> 82         m_footerLayer = downcast&lt;Nicosia::CompositionLayer&gt;(layer);</span>
<span class="line-added"> 83     }</span>
<span class="line-added"> 84 }</span>
<span class="line-added"> 85 </span>
<span class="line-added"> 86 void ScrollingTreeFrameScrollingNodeNicosia::commitStateAfterChildren(const ScrollingStateNode&amp; stateNode)</span>
<span class="line-added"> 87 {</span>
<span class="line-added"> 88     ScrollingTreeFrameScrollingNode::commitStateAfterChildren(stateNode);</span>
<span class="line-added"> 89 </span>
<span class="line-added"> 90     const auto&amp; scrollingStateNode = downcast&lt;ScrollingStateScrollingNode&gt;(stateNode);</span>
<span class="line-added"> 91 </span>
<span class="line-added"> 92     // Update the scroll position after child nodes have been updated, because they need to have updated their constraints before any scrolling happens.</span>
<span class="line-added"> 93     if (scrollingStateNode.hasChangedProperty(ScrollingStateScrollingNode::RequestedScrollPosition)) {</span>
<span class="line-added"> 94         const auto&amp; requestedScrollData = scrollingStateNode.requestedScrollData();</span>
<span class="line-added"> 95         scrollTo(requestedScrollData.scrollPosition, requestedScrollData.scrollType, requestedScrollData.clamping);</span>
<span class="line-added"> 96     }</span>
<span class="line-added"> 97 }</span>
<span class="line-added"> 98 </span>
<span class="line-added"> 99 ScrollingEventResult ScrollingTreeFrameScrollingNodeNicosia::handleWheelEvent(const PlatformWheelEvent&amp; wheelEvent)</span>
<span class="line-added">100 {</span>
<span class="line-added">101     if (!canHaveScrollbars())</span>
<span class="line-added">102         return ScrollingEventResult::DidNotHandleEvent;</span>
<span class="line-added">103 </span>
<span class="line-added">104     if (wheelEvent.deltaX() || wheelEvent.deltaY()) {</span>
<span class="line-added">105         auto* scrollLayer = static_cast&lt;Nicosia::PlatformLayer*&gt;(scrolledContentsLayer());</span>
<span class="line-added">106         ASSERT(scrollLayer);</span>
<span class="line-added">107         auto&amp; compositionLayer = downcast&lt;Nicosia::CompositionLayer&gt;(*scrollLayer);</span>
<span class="line-added">108 </span>
<span class="line-added">109         auto updateScope = compositionLayer.createUpdateScope();</span>
<span class="line-added">110         scrollBy({ -wheelEvent.deltaX(), -wheelEvent.deltaY() });</span>
<span class="line-added">111     }</span>
<span class="line-added">112 </span>
<span class="line-added">113     scrollingTree().setOrClearLatchedNode(wheelEvent, scrollingNodeID());</span>
<span class="line-added">114 </span>
<span class="line-added">115     // FIXME: This needs to return whether the event was handled.</span>
<span class="line-added">116     return ScrollingEventResult::DidHandleEvent;</span>
<span class="line-added">117 }</span>
<span class="line-added">118 </span>
<span class="line-added">119 FloatPoint ScrollingTreeFrameScrollingNodeNicosia::adjustedScrollPosition(const FloatPoint&amp; position, ScrollClamping clamping) const</span>
<span class="line-added">120 {</span>
<span class="line-added">121     FloatPoint scrollPosition(roundf(position.x()), roundf(position.y()));</span>
<span class="line-added">122     return ScrollingTreeFrameScrollingNode::adjustedScrollPosition(scrollPosition, clamping);</span>
<span class="line-added">123 }</span>
<span class="line-added">124 </span>
<span class="line-added">125 void ScrollingTreeFrameScrollingNodeNicosia::currentScrollPositionChanged()</span>
<span class="line-added">126 {</span>
<span class="line-added">127     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollingTreeFrameScrollingNodeNicosia::currentScrollPositionChanged to &quot; &lt;&lt; currentScrollPosition() &lt;&lt; &quot; min: &quot; &lt;&lt; minimumScrollPosition() &lt;&lt; &quot; max: &quot; &lt;&lt; maximumScrollPosition() &lt;&lt; &quot; sync: &quot; &lt;&lt; shouldUpdateScrollLayerPositionSynchronously());</span>
<span class="line-added">128 </span>
<span class="line-added">129     if (shouldUpdateScrollLayerPositionSynchronously())</span>
<span class="line-added">130         scrollingTree().scrollingTreeNodeDidScroll(*this, ScrollingLayerPositionAction::Set);</span>
<span class="line-added">131     else</span>
<span class="line-added">132         ScrollingTreeFrameScrollingNode::currentScrollPositionChanged();</span>
133 }
134 
135 void ScrollingTreeFrameScrollingNodeNicosia::repositionScrollingLayers()
136 {
<span class="line-added">137     auto* scrollLayer = static_cast&lt;Nicosia::PlatformLayer*&gt;(scrolledContentsLayer());</span>
<span class="line-added">138     ASSERT(scrollLayer);</span>
<span class="line-added">139     auto&amp; compositionLayer = downcast&lt;Nicosia::CompositionLayer&gt;(*scrollLayer);</span>
<span class="line-added">140 </span>
<span class="line-added">141     auto scrollPosition = currentScrollPosition();</span>
<span class="line-added">142 </span>
<span class="line-added">143     compositionLayer.updateState(</span>
<span class="line-added">144         [&amp;scrollPosition](Nicosia::CompositionLayer::LayerState&amp; state)</span>
<span class="line-added">145         {</span>
<span class="line-added">146             state.position = -scrollPosition;</span>
<span class="line-added">147             state.delta.positionChanged = true;</span>
<span class="line-added">148         });</span>
<span class="line-added">149 }</span>
<span class="line-added">150 </span>
<span class="line-added">151 void ScrollingTreeFrameScrollingNodeNicosia::repositionRelatedLayers()</span>
<span class="line-added">152 {</span>
<span class="line-added">153     auto scrollPosition = currentScrollPosition();</span>
<span class="line-added">154     auto layoutViewport = this-&gt;layoutViewport();</span>
<span class="line-added">155 </span>
<span class="line-added">156     FloatRect visibleContentRect(scrollPosition, scrollableAreaSize());</span>
<span class="line-added">157 </span>
<span class="line-added">158     auto applyLayerPosition =</span>
<span class="line-added">159         [](auto&amp; layer, auto&amp;&amp; position)</span>
<span class="line-added">160         {</span>
<span class="line-added">161             layer.updateState(</span>
<span class="line-added">162                 [&amp;position](Nicosia::CompositionLayer::LayerState&amp; state)</span>
<span class="line-added">163                 {</span>
<span class="line-added">164                     state.position = position;</span>
<span class="line-added">165                     state.delta.positionChanged = true;</span>
<span class="line-added">166                 });</span>
<span class="line-added">167         };</span>
<span class="line-added">168 </span>
<span class="line-added">169     if (m_counterScrollingLayer)</span>
<span class="line-added">170         applyLayerPosition(*m_counterScrollingLayer, layoutViewport.location());</span>
<span class="line-added">171 </span>
<span class="line-added">172     float topContentInset = this-&gt;topContentInset();</span>
<span class="line-added">173     if (m_insetClipLayer &amp;&amp; m_rootContentsLayer) {</span>
<span class="line-added">174         m_insetClipLayer-&gt;updateState(</span>
<span class="line-added">175             [&amp;scrollPosition, &amp;topContentInset](Nicosia::CompositionLayer::LayerState&amp; state)</span>
<span class="line-added">176             {</span>
<span class="line-added">177                 state.position = { state.position.x(), FrameView::yPositionForInsetClipLayer(scrollPosition, topContentInset) };</span>
<span class="line-added">178                 state.delta.positionChanged = true;</span>
<span class="line-added">179             });</span>
<span class="line-added">180 </span>
<span class="line-added">181         auto rootContentsPosition = FrameView::positionForRootContentLayer(scrollPosition, scrollOrigin(), topContentInset, headerHeight());</span>
<span class="line-added">182         applyLayerPosition(*m_rootContentsLayer, rootContentsPosition);</span>
<span class="line-added">183         if (m_contentShadowLayer)</span>
<span class="line-added">184             applyLayerPosition(*m_contentShadowLayer, rootContentsPosition);</span>
<span class="line-added">185     }</span>
<span class="line-added">186 </span>
<span class="line-added">187     if (m_headerLayer || m_footerLayer) {</span>
<span class="line-added">188         // Generally the banners should have the same horizontal-position computation as a fixed element. However,</span>
<span class="line-added">189         // the banners are not affected by the frameScaleFactor(), so if there is currently a non-1 frameScaleFactor()</span>
<span class="line-added">190         // then we should recompute layoutViewport.x() for the banner with a scale factor of 1.</span>
<span class="line-added">191         float horizontalScrollOffsetForBanner = layoutViewport.x();</span>
<span class="line-added">192         if (m_headerLayer)</span>
<span class="line-added">193             applyLayerPosition(*m_headerLayer, FloatPoint(horizontalScrollOffsetForBanner, FrameView::yPositionForHeaderLayer(scrollPosition, topContentInset)));</span>
<span class="line-added">194         if (m_footerLayer)</span>
<span class="line-added">195             applyLayerPosition(*m_footerLayer, FloatPoint(horizontalScrollOffsetForBanner, FrameView::yPositionForFooterLayer(scrollPosition, topContentInset, totalContentsSize().height(), footerHeight())));</span>
<span class="line-added">196     }</span>
197 }
198 
199 } // namespace WebCore
200 
201 #endif // ENABLE(ASYNC_SCROLLING) &amp;&amp; USE(NICOSIA)
</pre>
</td>
</tr>
</table>
<center><a href="ScrollingTreeFixedNode.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ScrollingTreeFrameScrollingNodeNicosia.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
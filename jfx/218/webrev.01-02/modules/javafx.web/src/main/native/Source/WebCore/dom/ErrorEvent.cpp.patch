diff a/modules/javafx.web/src/main/native/Source/WebCore/dom/ErrorEvent.cpp b/modules/javafx.web/src/main/native/Source/WebCore/dom/ErrorEvent.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/dom/ErrorEvent.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/dom/ErrorEvent.cpp
@@ -34,14 +34,17 @@
 
 #include "DOMWrapperWorld.h"
 #include "EventNames.h"
 #include <JavaScriptCore/HeapInlines.h>
 #include <JavaScriptCore/StrongInlines.h>
+#include <wtf/IsoMallocInlines.h>
 
 namespace WebCore {
 using namespace JSC;
 
+WTF_MAKE_ISO_ALLOCATED_IMPL(ErrorEvent);
+
 ErrorEvent::ErrorEvent(const AtomString& type, const Init& initializer, IsTrusted isTrusted)
     : Event(type, initializer, isTrusted)
     , m_message(initializer.message)
     , m_fileName(initializer.filename)
     , m_lineNumber(initializer.lineno)
@@ -65,29 +68,29 @@
 EventInterface ErrorEvent::eventInterface() const
 {
     return ErrorEventInterfaceType;
 }
 
-JSValue ErrorEvent::error(ExecState& state, JSGlobalObject& globalObject)
+JSValue ErrorEvent::error(JSGlobalObject& globalObject)
 {
     JSValue error = m_error;
     if (!error)
         return jsNull();
 
-    if (!isWorldCompatible(state, error)) {
+    if (!isWorldCompatible(globalObject, error)) {
         // We need to make sure ErrorEvents do not leak their error property across isolated DOM worlds.
         // Ideally, we would check that the worlds have different privileges but that's not possible yet.
-        auto serializedError = trySerializeError(state);
+        auto serializedError = trySerializeError(globalObject);
         if (!serializedError)
             return jsNull();
-        return serializedError->deserialize(state, &globalObject);
+        return serializedError->deserialize(globalObject, &globalObject);
     }
 
     return error;
 }
 
-RefPtr<SerializedScriptValue> ErrorEvent::trySerializeError(ExecState& exec)
+RefPtr<SerializedScriptValue> ErrorEvent::trySerializeError(JSGlobalObject& exec)
 {
     if (!m_serializedError && !m_triedToSerialize) {
         m_serializedError = SerializedScriptValue::create(exec, m_error, SerializationErrorMode::NonThrowing);
         m_triedToSerialize = true;
     }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmSignature.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmSignature.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmSignatureInlines.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmSignature.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2016-2017 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 35 #include &lt;wtf/HashMap.h&gt;
 36 #include &lt;wtf/HashSet.h&gt;
 37 #include &lt;wtf/HashTraits.h&gt;
 38 #include &lt;wtf/StdLibExtras.h&gt;
 39 #include &lt;wtf/ThreadSafeRefCounted.h&gt;
 40 #include &lt;wtf/Vector.h&gt;
 41 
 42 namespace WTF {
 43 class PrintStream;
 44 }
 45 
 46 namespace JSC {
 47 
 48 namespace Wasm {
 49 
 50 using SignatureArgCount = uint32_t;
 51 using SignatureIndex = uint64_t;
 52 
 53 class Signature : public ThreadSafeRefCounted&lt;Signature&gt; {
 54     WTF_MAKE_FAST_ALLOCATED;
<span class="line-removed"> 55     static const constexpr SignatureArgCount s_retCount = 1;</span>
 56 
 57     Signature() = delete;
 58     Signature(const Signature&amp;) = delete;
<span class="line-modified"> 59     Signature(SignatureArgCount argCount)</span>
<span class="line-modified"> 60         : m_argCount(argCount)</span>

 61     {
 62     }
 63 
 64     Type* storage(SignatureArgCount i)
 65     {
 66         return i + reinterpret_cast&lt;Type*&gt;(reinterpret_cast&lt;char*&gt;(this) + sizeof(Signature));
 67     }
 68     Type* storage(SignatureArgCount i) const { return const_cast&lt;Signature*&gt;(this)-&gt;storage(i); }
<span class="line-modified"> 69     static size_t allocatedSize(Checked&lt;SignatureArgCount&gt; argCount)</span>
 70     {
<span class="line-modified"> 71         return (sizeof(Signature) + (s_retCount + argCount) * sizeof(Type)).unsafeGet();</span>
 72     }
 73 
 74 public:
<span class="line-modified"> 75     Type&amp; returnType() { return *storage(0); }</span>
<span class="line-removed"> 76     Type returnType() const { return *storage(0); }</span>
<span class="line-removed"> 77     SignatureArgCount returnCount() const { return s_retCount; }</span>
 78     SignatureArgCount argumentCount() const { return m_argCount; }
<span class="line-modified"> 79     Type&amp; argument(SignatureArgCount i)</span>
<span class="line-modified"> 80     {</span>
<span class="line-modified"> 81         ASSERT(i &lt; argumentCount());</span>
<span class="line-modified"> 82         return *storage(returnCount() + i);</span>
<span class="line-removed"> 83     }</span>
<span class="line-removed"> 84     Type argument(SignatureArgCount i) const { return const_cast&lt;Signature*&gt;(this)-&gt;argument(i); }</span>
 85     SignatureIndex index() const { return bitwise_cast&lt;SignatureIndex&gt;(this); }
 86 
 87     WTF::String toString() const;
 88     void dump(WTF::PrintStream&amp; out) const;
<span class="line-modified"> 89     bool operator==(const Signature&amp; rhs) const</span>
<span class="line-removed"> 90     {</span>
<span class="line-removed"> 91         if (argumentCount() != rhs.argumentCount())</span>
<span class="line-removed"> 92             return false;</span>
<span class="line-removed"> 93         if (returnType() != rhs.returnType())</span>
<span class="line-removed"> 94             return false;</span>
<span class="line-removed"> 95         for (unsigned i = 0; i &lt; argumentCount(); ++i) {</span>
<span class="line-removed"> 96             if (argument(i) != rhs.argument(i))</span>
<span class="line-removed"> 97                 return false;</span>
<span class="line-removed"> 98         }</span>
<span class="line-removed"> 99         return true;</span>
<span class="line-removed">100     }</span>
101     unsigned hash() const;
102 
<span class="line-removed">103     static RefPtr&lt;Signature&gt; tryCreate(SignatureArgCount);</span>
<span class="line-removed">104 </span>
105     // Signatures are uniqued and, for call_indirect, validated at runtime. Tables can create invalid SignatureIndex values which cause call_indirect to fail. We use 0 as the invalidIndex so that the codegen can easily test for it and trap, and we add a token invalid entry in SignatureInformation.
106     static const constexpr SignatureIndex invalidIndex = 0;
107 
108 private:
109     friend class SignatureInformation;







110     SignatureArgCount m_argCount;
111     // Return Type and arguments are stored here.
112 };
113 
114 struct SignatureHash {
115     RefPtr&lt;Signature&gt; key { nullptr };
116     SignatureHash() = default;
117     explicit SignatureHash(Ref&lt;Signature&gt;&amp;&amp; key)
118         : key(WTFMove(key))
<span class="line-modified">119     {</span>
<span class="line-removed">120     }</span>
121     explicit SignatureHash(WTF::HashTableDeletedValueType)
122         : key(WTF::HashTableDeletedValue)
<span class="line-modified">123     {</span>
<span class="line-removed">124     }</span>
125     bool operator==(const SignatureHash&amp; rhs) const { return equal(*this, rhs); }
<span class="line-modified">126     static bool equal(const SignatureHash&amp; lhs, const SignatureHash&amp; rhs) { return lhs.key == rhs.key || (lhs.key &amp;&amp; rhs.key &amp;&amp; *lhs.key == *rhs.key); }</span>
127     static unsigned hash(const SignatureHash&amp; signature) { return signature.key ? signature.key-&gt;hash() : 0; }
<span class="line-modified">128     static const bool safeToCompareToEmptyOrDeleted = false;</span>
129     bool isHashTableDeletedValue() const { return key.isHashTableDeletedValue(); }
130 };
131 
132 } } // namespace JSC::Wasm
133 
134 
135 namespace WTF {
136 
137 template&lt;typename T&gt; struct DefaultHash;
138 template&lt;&gt; struct DefaultHash&lt;JSC::Wasm::SignatureHash&gt; {
139     typedef JSC::Wasm::SignatureHash Hash;
140 };
141 
142 template&lt;typename T&gt; struct HashTraits;
143 template&lt;&gt; struct HashTraits&lt;JSC::Wasm::SignatureHash&gt; : SimpleClassHashTraits&lt;JSC::Wasm::SignatureHash&gt; {
<span class="line-modified">144     static const bool emptyValueIsZero = true;</span>
145 };
146 
147 } // namespace WTF
148 
149 
150 namespace JSC { namespace Wasm {
151 
152 // Signature information is held globally and shared by the entire process to allow all signatures to be unique. This is required when wasm calls another wasm instance, and must work when modules are shared between multiple VMs.
<span class="line-removed">153 // Note: signatures are never removed because that would require accounting for all WebAssembly.Module and which signatures they use. The maximum number of signatures is bounded, and isn&#39;t worth the counting overhead. We could clear everything when we reach zero outstanding WebAssembly.Module. https://bugs.webkit.org/show_bug.cgi?id=166037</span>
154 class SignatureInformation {
155     WTF_MAKE_NONCOPYABLE(SignatureInformation);
156     WTF_MAKE_FAST_ALLOCATED;
157 
158     SignatureInformation();
159 
160 public:
161     static SignatureInformation&amp; singleton();
162 
<span class="line-modified">163     static Ref&lt;Signature&gt; WARN_UNUSED_RETURN adopt(Ref&lt;Signature&gt;&amp;&amp;);</span>
<span class="line-modified">164     static const Signature&amp; WARN_UNUSED_RETURN get(SignatureIndex);</span>
<span class="line-modified">165     static SignatureIndex WARN_UNUSED_RETURN get(const Signature&amp;);</span>


166     static void tryCleanup();
167 
168 private:
169     HashSet&lt;Wasm::SignatureHash&gt; m_signatureSet;

170     Lock m_lock;
171 
172     JS_EXPORT_PRIVATE static SignatureInformation* theOne;
173     JS_EXPORT_PRIVATE static std::once_flag signatureInformationFlag;
174 };
175 
176 } } // namespace JSC::Wasm
177 
178 #endif // ENABLE(WEBASSEMBLY)
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 35 #include &lt;wtf/HashMap.h&gt;
 36 #include &lt;wtf/HashSet.h&gt;
 37 #include &lt;wtf/HashTraits.h&gt;
 38 #include &lt;wtf/StdLibExtras.h&gt;
 39 #include &lt;wtf/ThreadSafeRefCounted.h&gt;
 40 #include &lt;wtf/Vector.h&gt;
 41 
 42 namespace WTF {
 43 class PrintStream;
 44 }
 45 
 46 namespace JSC {
 47 
 48 namespace Wasm {
 49 
 50 using SignatureArgCount = uint32_t;
 51 using SignatureIndex = uint64_t;
 52 
 53 class Signature : public ThreadSafeRefCounted&lt;Signature&gt; {
 54     WTF_MAKE_FAST_ALLOCATED;

 55 
 56     Signature() = delete;
 57     Signature(const Signature&amp;) = delete;
<span class="line-modified"> 58     Signature(SignatureArgCount retCount, SignatureArgCount argCount)</span>
<span class="line-modified"> 59         : m_retCount(retCount)</span>
<span class="line-added"> 60         , m_argCount(argCount)</span>
 61     {
 62     }
 63 
 64     Type* storage(SignatureArgCount i)
 65     {
 66         return i + reinterpret_cast&lt;Type*&gt;(reinterpret_cast&lt;char*&gt;(this) + sizeof(Signature));
 67     }
 68     Type* storage(SignatureArgCount i) const { return const_cast&lt;Signature*&gt;(this)-&gt;storage(i); }
<span class="line-modified"> 69     static size_t allocatedSize(Checked&lt;SignatureArgCount&gt; retCount, Checked&lt;SignatureArgCount&gt; argCount)</span>
 70     {
<span class="line-modified"> 71         return (sizeof(Signature) + (retCount + argCount) * sizeof(Type)).unsafeGet();</span>
 72     }
 73 
 74 public:
<span class="line-modified"> 75     SignatureArgCount returnCount() const { return m_retCount; }</span>


 76     SignatureArgCount argumentCount() const { return m_argCount; }
<span class="line-modified"> 77 </span>
<span class="line-modified"> 78     Type returnType(SignatureArgCount i) const { ASSERT(i &lt; returnCount()); return const_cast&lt;Signature*&gt;(this)-&gt;getReturnType(i); }</span>
<span class="line-modified"> 79     bool returnsVoid() const { return !returnCount(); }</span>
<span class="line-modified"> 80     Type argument(SignatureArgCount i) const { return const_cast&lt;Signature*&gt;(this)-&gt;getArgument(i); }</span>


 81     SignatureIndex index() const { return bitwise_cast&lt;SignatureIndex&gt;(this); }
 82 
 83     WTF::String toString() const;
 84     void dump(WTF::PrintStream&amp; out) const;
<span class="line-modified"> 85     bool operator==(const Signature&amp; rhs) const { return this == &amp;rhs; }</span>











 86     unsigned hash() const;
 87 


 88     // Signatures are uniqued and, for call_indirect, validated at runtime. Tables can create invalid SignatureIndex values which cause call_indirect to fail. We use 0 as the invalidIndex so that the codegen can easily test for it and trap, and we add a token invalid entry in SignatureInformation.
 89     static const constexpr SignatureIndex invalidIndex = 0;
 90 
 91 private:
 92     friend class SignatureInformation;
<span class="line-added"> 93     friend struct ParameterTypes;</span>
<span class="line-added"> 94 </span>
<span class="line-added"> 95     static RefPtr&lt;Signature&gt; tryCreate(SignatureArgCount returnCount, SignatureArgCount argumentCount);</span>
<span class="line-added"> 96     Type&amp; getReturnType(SignatureArgCount i) { ASSERT(i &lt; returnCount()); return *storage(i); }</span>
<span class="line-added"> 97     Type&amp; getArgument(SignatureArgCount i) { ASSERT(i &lt; argumentCount()); return *storage(returnCount() + i); }</span>
<span class="line-added"> 98 </span>
<span class="line-added"> 99     SignatureArgCount m_retCount;</span>
100     SignatureArgCount m_argCount;
101     // Return Type and arguments are stored here.
102 };
103 
104 struct SignatureHash {
105     RefPtr&lt;Signature&gt; key { nullptr };
106     SignatureHash() = default;
107     explicit SignatureHash(Ref&lt;Signature&gt;&amp;&amp; key)
108         : key(WTFMove(key))
<span class="line-modified">109     { }</span>

110     explicit SignatureHash(WTF::HashTableDeletedValueType)
111         : key(WTF::HashTableDeletedValue)
<span class="line-modified">112     { }</span>

113     bool operator==(const SignatureHash&amp; rhs) const { return equal(*this, rhs); }
<span class="line-modified">114     static bool equal(const SignatureHash&amp; lhs, const SignatureHash&amp; rhs) { return lhs.key == rhs.key; }</span>
115     static unsigned hash(const SignatureHash&amp; signature) { return signature.key ? signature.key-&gt;hash() : 0; }
<span class="line-modified">116     static constexpr bool safeToCompareToEmptyOrDeleted = false;</span>
117     bool isHashTableDeletedValue() const { return key.isHashTableDeletedValue(); }
118 };
119 
120 } } // namespace JSC::Wasm
121 
122 
123 namespace WTF {
124 
125 template&lt;typename T&gt; struct DefaultHash;
126 template&lt;&gt; struct DefaultHash&lt;JSC::Wasm::SignatureHash&gt; {
127     typedef JSC::Wasm::SignatureHash Hash;
128 };
129 
130 template&lt;typename T&gt; struct HashTraits;
131 template&lt;&gt; struct HashTraits&lt;JSC::Wasm::SignatureHash&gt; : SimpleClassHashTraits&lt;JSC::Wasm::SignatureHash&gt; {
<span class="line-modified">132     static constexpr bool emptyValueIsZero = true;</span>
133 };
134 
135 } // namespace WTF
136 
137 
138 namespace JSC { namespace Wasm {
139 
140 // Signature information is held globally and shared by the entire process to allow all signatures to be unique. This is required when wasm calls another wasm instance, and must work when modules are shared between multiple VMs.

141 class SignatureInformation {
142     WTF_MAKE_NONCOPYABLE(SignatureInformation);
143     WTF_MAKE_FAST_ALLOCATED;
144 
145     SignatureInformation();
146 
147 public:
148     static SignatureInformation&amp; singleton();
149 
<span class="line-modified">150     static RefPtr&lt;Signature&gt; signatureFor(const Vector&lt;Type, 1&gt;&amp; returnTypes, const Vector&lt;Type&gt;&amp; argumentTypes);</span>
<span class="line-modified">151     ALWAYS_INLINE const Signature* thunkFor(Type type) const { return thunkSignatures[linearizeType(type)]; }</span>
<span class="line-modified">152 </span>
<span class="line-added">153     static const Signature&amp; get(SignatureIndex);</span>
<span class="line-added">154     static SignatureIndex get(const Signature&amp;);</span>
155     static void tryCleanup();
156 
157 private:
158     HashSet&lt;Wasm::SignatureHash&gt; m_signatureSet;
<span class="line-added">159     const Signature* thunkSignatures[numTypes];</span>
160     Lock m_lock;
161 
162     JS_EXPORT_PRIVATE static SignatureInformation* theOne;
163     JS_EXPORT_PRIVATE static std::once_flag signatureInformationFlag;
164 };
165 
166 } } // namespace JSC::Wasm
167 
168 #endif // ENABLE(WEBASSEMBLY)
</pre>
</td>
</tr>
</table>
<center><a href="WasmSignature.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmSignatureInlines.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
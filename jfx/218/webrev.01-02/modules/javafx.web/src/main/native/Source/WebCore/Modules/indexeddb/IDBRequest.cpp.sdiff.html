<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBRequest.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IDBOpenDBRequest.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBRequest.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBRequest.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
135     : IDBActiveDOMObject(&amp;context)
136     , m_transaction(&amp;transaction)
137     , m_resourceIdentifier(transaction.connectionProxy())
138     , m_source(&amp;objectStore)
139     , m_requestedObjectStoreRecordType(type)
140     , m_connectionProxy(transaction.database().connectionProxy())
141 {
142     m_result = NullResultType::Undefined;
143     suspendIfNeeded();
144 }
145 
146 IDBRequest::IDBRequest(ScriptExecutionContext&amp; context, IDBIndex&amp; index, IndexedDB::IndexRecordType requestedRecordType, IDBTransaction&amp; transaction)
147     : IDBRequest(context, index, transaction)
148 {
149     m_result = NullResultType::Undefined;
150     m_requestedIndexRecordType = requestedRecordType;
151 }
152 
153 IDBRequest::~IDBRequest()
154 {
<span class="line-modified">155     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
156 
157     WTF::switchOn(m_result,
158         [] (RefPtr&lt;IDBCursor&gt;&amp; cursor) { cursor-&gt;clearRequest(); },
159         [] (const auto&amp;) { }
160     );
161 }
162 
163 ExceptionOr&lt;IDBRequest::Result&gt; IDBRequest::result() const
164 {
165     if (!isDone())
166         return Exception { InvalidStateError, &quot;Failed to read the &#39;result&#39; property from &#39;IDBRequest&#39;: The request has not finished.&quot;_s };
167 
168     return IDBRequest::Result { m_result };
169 }
170 
171 ExceptionOr&lt;DOMException*&gt; IDBRequest::error() const
172 {
<span class="line-modified">173     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
174 
175     if (!isDone())
176         return Exception { InvalidStateError, &quot;Failed to read the &#39;error&#39; property from &#39;IDBRequest&#39;: The request has not finished.&quot;_s };
177 
178     return m_domError.get();
179 }
180 
181 void IDBRequest::setSource(IDBCursor&amp; cursor)
182 {
<span class="line-modified">183     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
184 
185     m_source = Source { &amp;cursor };
186 }
187 
188 void IDBRequest::setVersionChangeTransaction(IDBTransaction&amp; transaction)
189 {
<span class="line-modified">190     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
191     ASSERT(!m_transaction);
192     ASSERT(transaction.isVersionChange());
193     ASSERT(!transaction.isFinishedOrFinishing());
194 
195     m_transaction = &amp;transaction;
196 }
197 
198 RefPtr&lt;WebCore::IDBTransaction&gt; IDBRequest::transaction() const
199 {
<span class="line-modified">200     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
201     return m_shouldExposeTransactionToDOM ? m_transaction : nullptr;
202 }
203 
204 uint64_t IDBRequest::sourceObjectStoreIdentifier() const
205 {
<span class="line-modified">206     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
207 
208     if (!m_source)
209         return 0;
210 
211     return WTF::switchOn(m_source.value(),
212         [] (const RefPtr&lt;IDBObjectStore&gt;&amp; objectStore) { return objectStore-&gt;info().identifier(); },
213         [] (const RefPtr&lt;IDBIndex&gt;&amp; index) { return index-&gt;info().objectStoreIdentifier(); },
214         [] (const RefPtr&lt;IDBCursor&gt;&amp;) { return 0; }
215     );
216 }
217 
218 uint64_t IDBRequest::sourceIndexIdentifier() const
219 {
<span class="line-modified">220     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
221 
222     if (!m_source)
223         return 0;
224 
225     return WTF::switchOn(m_source.value(),
226         [] (const RefPtr&lt;IDBObjectStore&gt;&amp;) -&gt; uint64_t { return 0; },
227         [] (const RefPtr&lt;IDBIndex&gt;&amp; index) -&gt; uint64_t { return index-&gt;info().identifier(); },
228         [] (const RefPtr&lt;IDBCursor&gt;&amp;) -&gt; uint64_t { return 0; }
229     );
230 }
231 
232 IndexedDB::ObjectStoreRecordType IDBRequest::requestedObjectStoreRecordType() const
233 {
<span class="line-modified">234     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
235 
236     return m_requestedObjectStoreRecordType;
237 }
238 
239 IndexedDB::IndexRecordType IDBRequest::requestedIndexRecordType() const
240 {
<span class="line-modified">241     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
242     ASSERT(m_source);
243     ASSERT(WTF::holds_alternative&lt;RefPtr&lt;IDBIndex&gt;&gt;(m_source.value()));
244 
245     return m_requestedIndexRecordType;
246 }
247 
248 EventTargetInterface IDBRequest::eventTargetInterface() const
249 {
<span class="line-modified">250     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
251 
252     return IDBRequestEventTargetInterfaceType;
253 }
254 
255 const char* IDBRequest::activeDOMObjectName() const
256 {
<span class="line-modified">257     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
258 
259     return &quot;IDBRequest&quot;;
260 }
261 
<span class="line-removed">262 bool IDBRequest::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">263 {</span>
<span class="line-removed">264     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
<span class="line-removed">265     return false;</span>
<span class="line-removed">266 }</span>
<span class="line-removed">267 </span>
268 bool IDBRequest::hasPendingActivity() const
269 {
<span class="line-modified">270     ASSERT(&amp;originThread() == &amp;Thread::current() || Thread::mayBeGCThread());</span>
271     return !m_contextStopped &amp;&amp; m_hasPendingActivity;
272 }
273 
274 void IDBRequest::stop()
275 {
<span class="line-modified">276     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
277     ASSERT(!m_contextStopped);
278 
279     cancelForStop();
280 
281     removeAllEventListeners();
282 
283     clearWrappers();
284 
285     m_contextStopped = true;
286 }
287 
288 void IDBRequest::cancelForStop()
289 {
290     // The base IDBRequest class has nothing additional to do here.
291 }
292 
293 void IDBRequest::enqueueEvent(Ref&lt;Event&gt;&amp;&amp; event)
294 {
<span class="line-modified">295     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
296     if (m_contextStopped)
297         return;
298 
<span class="line-modified">299     event-&gt;setTarget(this);</span>
<span class="line-removed">300     scriptExecutionContext()-&gt;eventQueue().enqueueEvent(WTFMove(event));</span>
301 }
302 
303 void IDBRequest::dispatchEvent(Event&amp; event)
304 {
305     LOG(IndexedDB, &quot;IDBRequest::dispatchEvent - %s (%p)&quot;, event.type().string().utf8().data(), this);
306 
<span class="line-modified">307     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
308     ASSERT(m_hasPendingActivity);
309     ASSERT(!m_contextStopped);
310 
311     auto protectedThis = makeRef(*this);
312     m_dispatchingEvent = true;
313 
314     if (event.type() != eventNames().blockedEvent)
315         m_readyState = ReadyState::Done;
316 
317     Vector&lt;EventTarget*&gt; targets { this };
318 
319     if (&amp;event == m_openDatabaseSuccessEvent)
320         m_openDatabaseSuccessEvent = nullptr;
321     else if (m_transaction &amp;&amp; !m_transaction-&gt;didDispatchAbortOrCommit())
322         targets = { this, m_transaction.get(), &amp;m_transaction-&gt;database() };
323 
324     m_hasPendingActivity = false;
325 
326     {
327         TransactionActivator activator(m_transaction.get());
328         EventDispatcher::dispatchEvent(targets, event);
329     }
330 
331     // Dispatching the event might have set the pending activity flag back to true, suggesting the request will be reused.
332     // We might also re-use the request if this event was the upgradeneeded event for an IDBOpenDBRequest.
333     if (!m_hasPendingActivity)
334         m_hasPendingActivity = isOpenDBRequest() &amp;&amp; (event.type() == eventNames().upgradeneededEvent || event.type() == eventNames().blockedEvent);
335 
336     m_dispatchingEvent = false;
337     if (!m_transaction)
338         return;
339 
<span class="line-removed">340     // The request should only remain in the transaction&#39;s request list if it represents a pending cursor operation, or this is an open request that was blocked.</span>
<span class="line-removed">341     if (!m_pendingCursor &amp;&amp; event.type() != eventNames().blockedEvent)</span>
<span class="line-removed">342         m_transaction-&gt;removeRequest(*this);</span>
<span class="line-removed">343 </span>
344     if (m_hasUncaughtException)
345         m_transaction-&gt;abortDueToFailedRequest(DOMException::create(AbortError, &quot;IDBTransaction will abort due to uncaught exception in an event handler&quot;_s));
346     else if (!event.defaultPrevented() &amp;&amp; event.type() == eventNames().errorEvent &amp;&amp; !m_transaction-&gt;isFinishedOrFinishing()) {
347         ASSERT(m_domError);
348         m_transaction-&gt;abortDueToFailedRequest(*m_domError);
349     }
350 
351     m_transaction-&gt;finishedDispatchEventForRequest(*this);




352 }
353 
354 void IDBRequest::uncaughtExceptionInEventHandler()
355 {
356     LOG(IndexedDB, &quot;IDBRequest::uncaughtExceptionInEventHandler&quot;);
357 
<span class="line-modified">358     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
359 
360     if (m_dispatchingEvent) {
361         ASSERT(!m_hasUncaughtException);
362         m_hasUncaughtException = true;
363         return;
364     }
365     if (m_transaction &amp;&amp; m_idbError.code() != AbortError)
366         m_transaction-&gt;abortDueToFailedRequest(DOMException::create(AbortError, &quot;IDBTransaction will abort due to uncaught exception in an event handler&quot;_s));
367 }
368 
369 void IDBRequest::setResult(const IDBKeyData&amp; keyData)
370 {
<span class="line-modified">371     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
372 
373     auto* context = scriptExecutionContext();
374     if (!context)
375         return;
376 
377     VM&amp; vm = context-&gt;vm();
378     JSLockHolder lock(vm);
379     m_result = keyData;
380     m_resultWrapper = { };
381 }
382 
383 void IDBRequest::setResult(const Vector&lt;IDBKeyData&gt;&amp; keyDatas)
384 {
<span class="line-modified">385     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
386 
387     auto* context = scriptExecutionContext();
388     if (!context)
389         return;
390 
391     VM&amp; vm = context-&gt;vm();
392     JSLockHolder lock(vm);
393     m_result = keyDatas;
394     m_resultWrapper = { };
395 }
396 
397 void IDBRequest::setResult(const IDBGetAllResult&amp; result)
398 {
<span class="line-modified">399     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
400 
401     auto* context = scriptExecutionContext();
402     if (!context)
403         return;
404 
405     VM&amp; vm = context-&gt;vm();
406     JSLockHolder lock(vm);
407     m_result = result;
408     m_resultWrapper = { };
409 }
410 
411 void IDBRequest::setResult(uint64_t number)
412 {
<span class="line-modified">413     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
414 
415     auto* context = scriptExecutionContext();
416     if (!context)
417         return;
418 
419     VM&amp; vm = context-&gt;vm();
420     JSLockHolder lock(vm);
421     m_result = number;
422     m_resultWrapper = { };
423 }
424 
425 void IDBRequest::setResultToStructuredClone(const IDBGetResult&amp; result)
426 {
<span class="line-modified">427     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
428 
429     LOG(IndexedDB, &quot;IDBRequest::setResultToStructuredClone&quot;);
430 
431     auto* context = scriptExecutionContext();
432     if (!context)
433         return;
434 
435     VM&amp; vm = context-&gt;vm();
436     JSLockHolder lock(vm);
437     m_result = result;
438     m_resultWrapper = { };
439 }
440 
441 void IDBRequest::setResultToUndefined()
442 {
<span class="line-modified">443     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
444 
445     auto* context = scriptExecutionContext();
446     if (!context)
447         return;
448 
449     VM&amp; vm = context-&gt;vm();
450     JSLockHolder lock(vm);
451     m_result = NullResultType::Undefined;
452     m_resultWrapper = { };
453 }
454 
455 IDBCursor* IDBRequest::resultCursor()
456 {
<span class="line-modified">457     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
458 
459     return WTF::switchOn(m_result,
460         [] (const RefPtr&lt;IDBCursor&gt;&amp; cursor) -&gt; IDBCursor* { return cursor.get(); },
461         [] (const auto&amp;) -&gt; IDBCursor* { return nullptr; }
462     );
463 }
464 
465 void IDBRequest::willIterateCursor(IDBCursor&amp; cursor)
466 {
<span class="line-modified">467     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
468     ASSERT(isDone());
469     ASSERT(scriptExecutionContext());
470     ASSERT(m_transaction);
471     ASSERT(!m_pendingCursor);
472     ASSERT(&amp;cursor == resultCursor());
473 
474     m_pendingCursor = &amp;cursor;
475     m_hasPendingActivity = true;
476     m_result = NullResultType::Empty;
477 
478     auto* context = scriptExecutionContext();
479     if (!context)
480         return;
481 
482     VM&amp; vm = context-&gt;vm();
483     JSLockHolder lock(vm);
484 
485     if (m_resultWrapper)
486         m_cursorWrapper = m_resultWrapper;
487     m_resultWrapper = { };
488     m_readyState = ReadyState::Pending;
489     m_domError = nullptr;
490     m_idbError = IDBError { };
491 }
492 
493 void IDBRequest::didOpenOrIterateCursor(const IDBResultData&amp; resultData)
494 {
<span class="line-modified">495     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
496     ASSERT(m_pendingCursor);
497 
498     auto* context = scriptExecutionContext();
499     if (!context)
500         return;
501 
502     VM&amp; vm = context-&gt;vm();
503     JSLockHolder lock(vm);
504 
505     m_result = NullResultType::Empty;
506     m_resultWrapper = { };
507 
508     if (resultData.type() == IDBResultType::IterateCursorSuccess || resultData.type() == IDBResultType::OpenCursorSuccess) {
<span class="line-modified">509         if (m_pendingCursor-&gt;setGetResult(*this, resultData.getResult()) &amp;&amp; m_cursorWrapper)</span>
510             m_resultWrapper = m_cursorWrapper;
511         if (resultData.getResult().isDefined())
512             m_result = m_pendingCursor;
513     }
514 
515     m_pendingCursor = nullptr;
516 
517     completeRequestAndDispatchEvent(resultData);
518 }
519 
520 void IDBRequest::completeRequestAndDispatchEvent(const IDBResultData&amp; resultData)
521 {
<span class="line-modified">522     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
523 
524     m_readyState = ReadyState::Done;
525 
526     m_idbError = resultData.error();
527     if (!m_idbError.isNull())
528         onError();
529     else
530         onSuccess();
531 }
532 
533 void IDBRequest::onError()
534 {
535     LOG(IndexedDB, &quot;IDBRequest::onError&quot;);
536 
<span class="line-modified">537     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
538     ASSERT(!m_idbError.isNull());
539 
540     m_domError = m_idbError.toDOMException();
541     enqueueEvent(Event::create(eventNames().errorEvent, Event::CanBubble::Yes, Event::IsCancelable::Yes));
542 }
543 
544 void IDBRequest::onSuccess()
545 {
546     LOG(IndexedDB, &quot;IDBRequest::onSuccess&quot;);
<span class="line-modified">547     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
548     enqueueEvent(Event::create(eventNames().successEvent, Event::CanBubble::No, Event::IsCancelable::No));
549 }
550 
551 void IDBRequest::setResult(Ref&lt;IDBDatabase&gt;&amp;&amp; database)
552 {
<span class="line-modified">553     ASSERT(&amp;originThread() == &amp;Thread::current());</span>
554 
555     auto* context = scriptExecutionContext();
556     if (!context)
557         return;
558 
559     VM&amp; vm = context-&gt;vm();
560     JSLockHolder lock(vm);
561 
562     m_result = RefPtr&lt;IDBDatabase&gt; { WTFMove(database) };
563     m_resultWrapper = { };
564 }
565 
566 void IDBRequest::clearWrappers()
567 {
568     auto* context = scriptExecutionContext();
569     if (!context)
570         return;
571     VM&amp; vm = context-&gt;vm();
572     JSLockHolder lock(vm);
573 
</pre>
</td>
<td>
<hr />
<pre>
135     : IDBActiveDOMObject(&amp;context)
136     , m_transaction(&amp;transaction)
137     , m_resourceIdentifier(transaction.connectionProxy())
138     , m_source(&amp;objectStore)
139     , m_requestedObjectStoreRecordType(type)
140     , m_connectionProxy(transaction.database().connectionProxy())
141 {
142     m_result = NullResultType::Undefined;
143     suspendIfNeeded();
144 }
145 
146 IDBRequest::IDBRequest(ScriptExecutionContext&amp; context, IDBIndex&amp; index, IndexedDB::IndexRecordType requestedRecordType, IDBTransaction&amp; transaction)
147     : IDBRequest(context, index, transaction)
148 {
149     m_result = NullResultType::Undefined;
150     m_requestedIndexRecordType = requestedRecordType;
151 }
152 
153 IDBRequest::~IDBRequest()
154 {
<span class="line-modified">155     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
156 
157     WTF::switchOn(m_result,
158         [] (RefPtr&lt;IDBCursor&gt;&amp; cursor) { cursor-&gt;clearRequest(); },
159         [] (const auto&amp;) { }
160     );
161 }
162 
163 ExceptionOr&lt;IDBRequest::Result&gt; IDBRequest::result() const
164 {
165     if (!isDone())
166         return Exception { InvalidStateError, &quot;Failed to read the &#39;result&#39; property from &#39;IDBRequest&#39;: The request has not finished.&quot;_s };
167 
168     return IDBRequest::Result { m_result };
169 }
170 
171 ExceptionOr&lt;DOMException*&gt; IDBRequest::error() const
172 {
<span class="line-modified">173     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
174 
175     if (!isDone())
176         return Exception { InvalidStateError, &quot;Failed to read the &#39;error&#39; property from &#39;IDBRequest&#39;: The request has not finished.&quot;_s };
177 
178     return m_domError.get();
179 }
180 
181 void IDBRequest::setSource(IDBCursor&amp; cursor)
182 {
<span class="line-modified">183     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
184 
185     m_source = Source { &amp;cursor };
186 }
187 
188 void IDBRequest::setVersionChangeTransaction(IDBTransaction&amp; transaction)
189 {
<span class="line-modified">190     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
191     ASSERT(!m_transaction);
192     ASSERT(transaction.isVersionChange());
193     ASSERT(!transaction.isFinishedOrFinishing());
194 
195     m_transaction = &amp;transaction;
196 }
197 
198 RefPtr&lt;WebCore::IDBTransaction&gt; IDBRequest::transaction() const
199 {
<span class="line-modified">200     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
201     return m_shouldExposeTransactionToDOM ? m_transaction : nullptr;
202 }
203 
204 uint64_t IDBRequest::sourceObjectStoreIdentifier() const
205 {
<span class="line-modified">206     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
207 
208     if (!m_source)
209         return 0;
210 
211     return WTF::switchOn(m_source.value(),
212         [] (const RefPtr&lt;IDBObjectStore&gt;&amp; objectStore) { return objectStore-&gt;info().identifier(); },
213         [] (const RefPtr&lt;IDBIndex&gt;&amp; index) { return index-&gt;info().objectStoreIdentifier(); },
214         [] (const RefPtr&lt;IDBCursor&gt;&amp;) { return 0; }
215     );
216 }
217 
218 uint64_t IDBRequest::sourceIndexIdentifier() const
219 {
<span class="line-modified">220     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
221 
222     if (!m_source)
223         return 0;
224 
225     return WTF::switchOn(m_source.value(),
226         [] (const RefPtr&lt;IDBObjectStore&gt;&amp;) -&gt; uint64_t { return 0; },
227         [] (const RefPtr&lt;IDBIndex&gt;&amp; index) -&gt; uint64_t { return index-&gt;info().identifier(); },
228         [] (const RefPtr&lt;IDBCursor&gt;&amp;) -&gt; uint64_t { return 0; }
229     );
230 }
231 
232 IndexedDB::ObjectStoreRecordType IDBRequest::requestedObjectStoreRecordType() const
233 {
<span class="line-modified">234     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
235 
236     return m_requestedObjectStoreRecordType;
237 }
238 
239 IndexedDB::IndexRecordType IDBRequest::requestedIndexRecordType() const
240 {
<span class="line-modified">241     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
242     ASSERT(m_source);
243     ASSERT(WTF::holds_alternative&lt;RefPtr&lt;IDBIndex&gt;&gt;(m_source.value()));
244 
245     return m_requestedIndexRecordType;
246 }
247 
248 EventTargetInterface IDBRequest::eventTargetInterface() const
249 {
<span class="line-modified">250     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
251 
252     return IDBRequestEventTargetInterfaceType;
253 }
254 
255 const char* IDBRequest::activeDOMObjectName() const
256 {
<span class="line-modified">257     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
258 
259     return &quot;IDBRequest&quot;;
260 }
261 






262 bool IDBRequest::hasPendingActivity() const
263 {
<span class="line-modified">264     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()) || Thread::mayBeGCThread());</span>
265     return !m_contextStopped &amp;&amp; m_hasPendingActivity;
266 }
267 
268 void IDBRequest::stop()
269 {
<span class="line-modified">270     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
271     ASSERT(!m_contextStopped);
272 
273     cancelForStop();
274 
275     removeAllEventListeners();
276 
277     clearWrappers();
278 
279     m_contextStopped = true;
280 }
281 
282 void IDBRequest::cancelForStop()
283 {
284     // The base IDBRequest class has nothing additional to do here.
285 }
286 
287 void IDBRequest::enqueueEvent(Ref&lt;Event&gt;&amp;&amp; event)
288 {
<span class="line-modified">289     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
290     if (m_contextStopped)
291         return;
292 
<span class="line-modified">293     queueTaskToDispatchEvent(*this, TaskSource::DatabaseAccess, WTFMove(event));</span>

294 }
295 
296 void IDBRequest::dispatchEvent(Event&amp; event)
297 {
298     LOG(IndexedDB, &quot;IDBRequest::dispatchEvent - %s (%p)&quot;, event.type().string().utf8().data(), this);
299 
<span class="line-modified">300     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
301     ASSERT(m_hasPendingActivity);
302     ASSERT(!m_contextStopped);
303 
304     auto protectedThis = makeRef(*this);
305     m_dispatchingEvent = true;
306 
307     if (event.type() != eventNames().blockedEvent)
308         m_readyState = ReadyState::Done;
309 
310     Vector&lt;EventTarget*&gt; targets { this };
311 
312     if (&amp;event == m_openDatabaseSuccessEvent)
313         m_openDatabaseSuccessEvent = nullptr;
314     else if (m_transaction &amp;&amp; !m_transaction-&gt;didDispatchAbortOrCommit())
315         targets = { this, m_transaction.get(), &amp;m_transaction-&gt;database() };
316 
317     m_hasPendingActivity = false;
318 
319     {
320         TransactionActivator activator(m_transaction.get());
321         EventDispatcher::dispatchEvent(targets, event);
322     }
323 
324     // Dispatching the event might have set the pending activity flag back to true, suggesting the request will be reused.
325     // We might also re-use the request if this event was the upgradeneeded event for an IDBOpenDBRequest.
326     if (!m_hasPendingActivity)
327         m_hasPendingActivity = isOpenDBRequest() &amp;&amp; (event.type() == eventNames().upgradeneededEvent || event.type() == eventNames().blockedEvent);
328 
329     m_dispatchingEvent = false;
330     if (!m_transaction)
331         return;
332 




333     if (m_hasUncaughtException)
334         m_transaction-&gt;abortDueToFailedRequest(DOMException::create(AbortError, &quot;IDBTransaction will abort due to uncaught exception in an event handler&quot;_s));
335     else if (!event.defaultPrevented() &amp;&amp; event.type() == eventNames().errorEvent &amp;&amp; !m_transaction-&gt;isFinishedOrFinishing()) {
336         ASSERT(m_domError);
337         m_transaction-&gt;abortDueToFailedRequest(*m_domError);
338     }
339 
340     m_transaction-&gt;finishedDispatchEventForRequest(*this);
<span class="line-added">341 </span>
<span class="line-added">342     // The request should only remain in the transaction&#39;s request list if it represents a pending cursor operation, or this is an open request that was blocked.</span>
<span class="line-added">343     if (!m_pendingCursor &amp;&amp; event.type() != eventNames().blockedEvent)</span>
<span class="line-added">344         m_transaction-&gt;removeRequest(*this);</span>
345 }
346 
347 void IDBRequest::uncaughtExceptionInEventHandler()
348 {
349     LOG(IndexedDB, &quot;IDBRequest::uncaughtExceptionInEventHandler&quot;);
350 
<span class="line-modified">351     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
352 
353     if (m_dispatchingEvent) {
354         ASSERT(!m_hasUncaughtException);
355         m_hasUncaughtException = true;
356         return;
357     }
358     if (m_transaction &amp;&amp; m_idbError.code() != AbortError)
359         m_transaction-&gt;abortDueToFailedRequest(DOMException::create(AbortError, &quot;IDBTransaction will abort due to uncaught exception in an event handler&quot;_s));
360 }
361 
362 void IDBRequest::setResult(const IDBKeyData&amp; keyData)
363 {
<span class="line-modified">364     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
365 
366     auto* context = scriptExecutionContext();
367     if (!context)
368         return;
369 
370     VM&amp; vm = context-&gt;vm();
371     JSLockHolder lock(vm);
372     m_result = keyData;
373     m_resultWrapper = { };
374 }
375 
376 void IDBRequest::setResult(const Vector&lt;IDBKeyData&gt;&amp; keyDatas)
377 {
<span class="line-modified">378     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
379 
380     auto* context = scriptExecutionContext();
381     if (!context)
382         return;
383 
384     VM&amp; vm = context-&gt;vm();
385     JSLockHolder lock(vm);
386     m_result = keyDatas;
387     m_resultWrapper = { };
388 }
389 
390 void IDBRequest::setResult(const IDBGetAllResult&amp; result)
391 {
<span class="line-modified">392     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
393 
394     auto* context = scriptExecutionContext();
395     if (!context)
396         return;
397 
398     VM&amp; vm = context-&gt;vm();
399     JSLockHolder lock(vm);
400     m_result = result;
401     m_resultWrapper = { };
402 }
403 
404 void IDBRequest::setResult(uint64_t number)
405 {
<span class="line-modified">406     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
407 
408     auto* context = scriptExecutionContext();
409     if (!context)
410         return;
411 
412     VM&amp; vm = context-&gt;vm();
413     JSLockHolder lock(vm);
414     m_result = number;
415     m_resultWrapper = { };
416 }
417 
418 void IDBRequest::setResultToStructuredClone(const IDBGetResult&amp; result)
419 {
<span class="line-modified">420     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
421 
422     LOG(IndexedDB, &quot;IDBRequest::setResultToStructuredClone&quot;);
423 
424     auto* context = scriptExecutionContext();
425     if (!context)
426         return;
427 
428     VM&amp; vm = context-&gt;vm();
429     JSLockHolder lock(vm);
430     m_result = result;
431     m_resultWrapper = { };
432 }
433 
434 void IDBRequest::setResultToUndefined()
435 {
<span class="line-modified">436     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
437 
438     auto* context = scriptExecutionContext();
439     if (!context)
440         return;
441 
442     VM&amp; vm = context-&gt;vm();
443     JSLockHolder lock(vm);
444     m_result = NullResultType::Undefined;
445     m_resultWrapper = { };
446 }
447 
448 IDBCursor* IDBRequest::resultCursor()
449 {
<span class="line-modified">450     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
451 
452     return WTF::switchOn(m_result,
453         [] (const RefPtr&lt;IDBCursor&gt;&amp; cursor) -&gt; IDBCursor* { return cursor.get(); },
454         [] (const auto&amp;) -&gt; IDBCursor* { return nullptr; }
455     );
456 }
457 
458 void IDBRequest::willIterateCursor(IDBCursor&amp; cursor)
459 {
<span class="line-modified">460     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
461     ASSERT(isDone());
462     ASSERT(scriptExecutionContext());
463     ASSERT(m_transaction);
464     ASSERT(!m_pendingCursor);
465     ASSERT(&amp;cursor == resultCursor());
466 
467     m_pendingCursor = &amp;cursor;
468     m_hasPendingActivity = true;
469     m_result = NullResultType::Empty;
470 
471     auto* context = scriptExecutionContext();
472     if (!context)
473         return;
474 
475     VM&amp; vm = context-&gt;vm();
476     JSLockHolder lock(vm);
477 
478     if (m_resultWrapper)
479         m_cursorWrapper = m_resultWrapper;
480     m_resultWrapper = { };
481     m_readyState = ReadyState::Pending;
482     m_domError = nullptr;
483     m_idbError = IDBError { };
484 }
485 
486 void IDBRequest::didOpenOrIterateCursor(const IDBResultData&amp; resultData)
487 {
<span class="line-modified">488     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
489     ASSERT(m_pendingCursor);
490 
491     auto* context = scriptExecutionContext();
492     if (!context)
493         return;
494 
495     VM&amp; vm = context-&gt;vm();
496     JSLockHolder lock(vm);
497 
498     m_result = NullResultType::Empty;
499     m_resultWrapper = { };
500 
501     if (resultData.type() == IDBResultType::IterateCursorSuccess || resultData.type() == IDBResultType::OpenCursorSuccess) {
<span class="line-modified">502         if (m_pendingCursor-&gt;setGetResult(*this, resultData.getResult(), m_currentTransactionOperationID) &amp;&amp; m_cursorWrapper)</span>
503             m_resultWrapper = m_cursorWrapper;
504         if (resultData.getResult().isDefined())
505             m_result = m_pendingCursor;
506     }
507 
508     m_pendingCursor = nullptr;
509 
510     completeRequestAndDispatchEvent(resultData);
511 }
512 
513 void IDBRequest::completeRequestAndDispatchEvent(const IDBResultData&amp; resultData)
514 {
<span class="line-modified">515     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
516 
517     m_readyState = ReadyState::Done;
518 
519     m_idbError = resultData.error();
520     if (!m_idbError.isNull())
521         onError();
522     else
523         onSuccess();
524 }
525 
526 void IDBRequest::onError()
527 {
528     LOG(IndexedDB, &quot;IDBRequest::onError&quot;);
529 
<span class="line-modified">530     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
531     ASSERT(!m_idbError.isNull());
532 
533     m_domError = m_idbError.toDOMException();
534     enqueueEvent(Event::create(eventNames().errorEvent, Event::CanBubble::Yes, Event::IsCancelable::Yes));
535 }
536 
537 void IDBRequest::onSuccess()
538 {
539     LOG(IndexedDB, &quot;IDBRequest::onSuccess&quot;);
<span class="line-modified">540     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
541     enqueueEvent(Event::create(eventNames().successEvent, Event::CanBubble::No, Event::IsCancelable::No));
542 }
543 
544 void IDBRequest::setResult(Ref&lt;IDBDatabase&gt;&amp;&amp; database)
545 {
<span class="line-modified">546     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));</span>
547 
548     auto* context = scriptExecutionContext();
549     if (!context)
550         return;
551 
552     VM&amp; vm = context-&gt;vm();
553     JSLockHolder lock(vm);
554 
555     m_result = RefPtr&lt;IDBDatabase&gt; { WTFMove(database) };
556     m_resultWrapper = { };
557 }
558 
559 void IDBRequest::clearWrappers()
560 {
561     auto* context = scriptExecutionContext();
562     if (!context)
563         return;
564     VM&amp; vm = context-&gt;vm();
565     JSLockHolder lock(vm);
566 
</pre>
</td>
</tr>
</table>
<center><a href="IDBOpenDBRequest.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBRequest.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
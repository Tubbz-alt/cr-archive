<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/AbstractMacroAssembler.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AbstractMacroAssembler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AssemblerBuffer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/AbstractMacroAssembler.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 179 
 180     // ImplicitAddress:
 181     //
 182     // This class is used for explicit &#39;load&#39; and &#39;store&#39; operations
 183     // (as opposed to situations in which a memory operand is provided
 184     // to a generic operation, such as an integer arithmetic instruction).
 185     //
 186     // In the case of a load (or store) operation we want to permit
 187     // addresses to be implicitly constructed, e.g. the two calls:
 188     //
 189     //     load32(Address(addrReg), destReg);
 190     //     load32(addrReg, destReg);
 191     //
 192     // Are equivalent, and the explicit wrapping of the Address in the former
 193     // is unnecessary.
 194     struct ImplicitAddress {
 195         ImplicitAddress(RegisterID base)
 196             : base(base)
 197             , offset(0)
 198         {

 199         }
 200 
 201         ImplicitAddress(Address address)
 202             : base(address.base)
 203             , offset(address.offset)
 204         {

 205         }
 206 
 207         RegisterID base;
 208         int32_t offset;
 209     };
 210 
 211     // BaseIndex:
 212     //
 213     // Describes a complex addressing mode.
 214     struct BaseIndex {
 215         BaseIndex(RegisterID base, RegisterID index, Scale scale, int32_t offset = 0)
 216             : base(base)
 217             , index(index)
 218             , scale(scale)
 219             , offset(offset)
 220         {
 221         }
 222 
 223         RegisterID base;
 224         RegisterID index;
</pre>
<hr />
<pre>
 942     }
 943 
 944     template&lt;PtrTag tag&gt;
 945     static void replaceWithLoad(CodeLocationConvertibleLoad&lt;tag&gt; label)
 946     {
 947         AssemblerType::replaceWithLoad(label.dataLocation());
 948     }
 949 
 950     template&lt;PtrTag tag&gt;
 951     static void replaceWithAddressComputation(CodeLocationConvertibleLoad&lt;tag&gt; label)
 952     {
 953         AssemblerType::replaceWithAddressComputation(label.dataLocation());
 954     }
 955 
 956     template&lt;typename Functor&gt;
 957     void addLinkTask(const Functor&amp; functor)
 958     {
 959         m_linkTasks.append(createSharedTask&lt;void(LinkBuffer&amp;)&gt;(functor));
 960     }
 961 








 962     void emitNops(size_t memoryToFillWithNopsInBytes)
 963     {
 964 #if CPU(ARM64)
 965         RELEASE_ASSERT(memoryToFillWithNopsInBytes % 4 == 0);
 966         for (unsigned i = 0; i &lt; memoryToFillWithNopsInBytes / 4; ++i)
 967             m_assembler.nop();
 968 #else
 969         AssemblerBuffer&amp; buffer = m_assembler.buffer();
 970         size_t startCodeSize = buffer.codeSize();
 971         size_t targetCodeSize = startCodeSize + memoryToFillWithNopsInBytes;
 972         buffer.ensureSpace(memoryToFillWithNopsInBytes);
<span class="line-modified"> 973         AssemblerType::fillNops(static_cast&lt;char*&gt;(buffer.data()) + startCodeSize, memoryToFillWithNopsInBytes, memcpy);</span>
 974         buffer.setCodeSize(targetCodeSize);
 975 #endif
 976     }
 977 
 978     ALWAYS_INLINE void tagReturnAddress() { }
 979     ALWAYS_INLINE void untagReturnAddress() { }
 980 
 981     ALWAYS_INLINE void tagPtr(PtrTag, RegisterID) { }
 982     ALWAYS_INLINE void tagPtr(RegisterID, RegisterID) { }
 983     ALWAYS_INLINE void untagPtr(PtrTag, RegisterID) { }
 984     ALWAYS_INLINE void untagPtr(RegisterID, RegisterID) { }
 985     ALWAYS_INLINE void removePtrTag(RegisterID) { }
 986 
 987 protected:
 988     AbstractMacroAssembler()
 989         : m_randomSource(0)
 990         , m_assembler()
 991     {
 992         invalidateAllTempRegisters();
 993     }
</pre>
</td>
<td>
<hr />
<pre>
 179 
 180     // ImplicitAddress:
 181     //
 182     // This class is used for explicit &#39;load&#39; and &#39;store&#39; operations
 183     // (as opposed to situations in which a memory operand is provided
 184     // to a generic operation, such as an integer arithmetic instruction).
 185     //
 186     // In the case of a load (or store) operation we want to permit
 187     // addresses to be implicitly constructed, e.g. the two calls:
 188     //
 189     //     load32(Address(addrReg), destReg);
 190     //     load32(addrReg, destReg);
 191     //
 192     // Are equivalent, and the explicit wrapping of the Address in the former
 193     // is unnecessary.
 194     struct ImplicitAddress {
 195         ImplicitAddress(RegisterID base)
 196             : base(base)
 197             , offset(0)
 198         {
<span class="line-added"> 199             ASSERT(base != RegisterID::InvalidGPRReg);</span>
 200         }
 201 
 202         ImplicitAddress(Address address)
 203             : base(address.base)
 204             , offset(address.offset)
 205         {
<span class="line-added"> 206             ASSERT(base != RegisterID::InvalidGPRReg);</span>
 207         }
 208 
 209         RegisterID base;
 210         int32_t offset;
 211     };
 212 
 213     // BaseIndex:
 214     //
 215     // Describes a complex addressing mode.
 216     struct BaseIndex {
 217         BaseIndex(RegisterID base, RegisterID index, Scale scale, int32_t offset = 0)
 218             : base(base)
 219             , index(index)
 220             , scale(scale)
 221             , offset(offset)
 222         {
 223         }
 224 
 225         RegisterID base;
 226         RegisterID index;
</pre>
<hr />
<pre>
 944     }
 945 
 946     template&lt;PtrTag tag&gt;
 947     static void replaceWithLoad(CodeLocationConvertibleLoad&lt;tag&gt; label)
 948     {
 949         AssemblerType::replaceWithLoad(label.dataLocation());
 950     }
 951 
 952     template&lt;PtrTag tag&gt;
 953     static void replaceWithAddressComputation(CodeLocationConvertibleLoad&lt;tag&gt; label)
 954     {
 955         AssemblerType::replaceWithAddressComputation(label.dataLocation());
 956     }
 957 
 958     template&lt;typename Functor&gt;
 959     void addLinkTask(const Functor&amp; functor)
 960     {
 961         m_linkTasks.append(createSharedTask&lt;void(LinkBuffer&amp;)&gt;(functor));
 962     }
 963 
<span class="line-added"> 964 #if COMPILER(GCC)</span>
<span class="line-added"> 965     // Workaround for GCC demanding that memcpy &quot;must be the name of a function with external linkage&quot;.</span>
<span class="line-added"> 966     static void* memcpy(void* dst, const void* src, size_t size)</span>
<span class="line-added"> 967     {</span>
<span class="line-added"> 968         return std::memcpy(dst, src, size);</span>
<span class="line-added"> 969     }</span>
<span class="line-added"> 970 #endif</span>
<span class="line-added"> 971 </span>
 972     void emitNops(size_t memoryToFillWithNopsInBytes)
 973     {
 974 #if CPU(ARM64)
 975         RELEASE_ASSERT(memoryToFillWithNopsInBytes % 4 == 0);
 976         for (unsigned i = 0; i &lt; memoryToFillWithNopsInBytes / 4; ++i)
 977             m_assembler.nop();
 978 #else
 979         AssemblerBuffer&amp; buffer = m_assembler.buffer();
 980         size_t startCodeSize = buffer.codeSize();
 981         size_t targetCodeSize = startCodeSize + memoryToFillWithNopsInBytes;
 982         buffer.ensureSpace(memoryToFillWithNopsInBytes);
<span class="line-modified"> 983         AssemblerType::template fillNops&lt;memcpy&gt;(static_cast&lt;char*&gt;(buffer.data()) + startCodeSize, memoryToFillWithNopsInBytes);</span>
 984         buffer.setCodeSize(targetCodeSize);
 985 #endif
 986     }
 987 
 988     ALWAYS_INLINE void tagReturnAddress() { }
 989     ALWAYS_INLINE void untagReturnAddress() { }
 990 
 991     ALWAYS_INLINE void tagPtr(PtrTag, RegisterID) { }
 992     ALWAYS_INLINE void tagPtr(RegisterID, RegisterID) { }
 993     ALWAYS_INLINE void untagPtr(PtrTag, RegisterID) { }
 994     ALWAYS_INLINE void untagPtr(RegisterID, RegisterID) { }
 995     ALWAYS_INLINE void removePtrTag(RegisterID) { }
 996 
 997 protected:
 998     AbstractMacroAssembler()
 999         : m_randomSource(0)
1000         , m_assembler()
1001     {
1002         invalidateAllTempRegisters();
1003     }
</pre>
</td>
</tr>
</table>
<center><a href="AbstractMacroAssembler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AssemblerBuffer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
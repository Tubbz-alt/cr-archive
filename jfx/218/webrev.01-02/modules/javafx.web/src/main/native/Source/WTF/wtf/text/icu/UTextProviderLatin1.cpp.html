<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/text/icu/UTextProviderLatin1.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2014 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &lt;wtf/text/icu/UTextProviderLatin1.h&gt;
 28 
 29 #include &lt;wtf/text/StringImpl.h&gt;
 30 #include &lt;wtf/text/icu/UTextProvider.h&gt;
 31 
 32 namespace WTF {
 33 
 34 // Latin1 provider
 35 
 36 static UText* uTextLatin1Clone(UText*, const UText*, UBool, UErrorCode*);
 37 static int64_t uTextLatin1NativeLength(UText*);
 38 static UBool uTextLatin1Access(UText*, int64_t, UBool);
 39 static int32_t uTextLatin1Extract(UText*, int64_t, int64_t, UChar*, int32_t, UErrorCode*);
 40 static int64_t uTextLatin1MapOffsetToNative(const UText*);
 41 static int32_t uTextLatin1MapNativeIndexToUTF16(const UText*, int64_t);
 42 static void uTextLatin1Close(UText*);
 43 
 44 static const struct UTextFuncs uTextLatin1Funcs = {
 45     sizeof(UTextFuncs),
 46     0,
 47     0,
 48     0,
 49     uTextLatin1Clone,
 50     uTextLatin1NativeLength,
 51     uTextLatin1Access,
 52     uTextLatin1Extract,
 53     nullptr,
 54     nullptr,
 55     uTextLatin1MapOffsetToNative,
 56     uTextLatin1MapNativeIndexToUTF16,
 57     uTextLatin1Close,
 58     nullptr,
 59     nullptr,
 60     nullptr
 61 };
 62 
 63 static UText* uTextLatin1Clone(UText* destination, const UText* source, UBool deep, UErrorCode* status)
 64 {
 65     ASSERT_UNUSED(deep, !deep);
 66 
 67     if (U_FAILURE(*status))
 68         return 0;
 69 
 70     UText* result = utext_setup(destination, sizeof(UChar) * UTextWithBufferInlineCapacity, status);
 71     if (U_FAILURE(*status))
 72         return destination;
 73 
 74     result-&gt;providerProperties = source-&gt;providerProperties;
 75 
 76     // Point at the same position, but with an empty buffer.
 77     result-&gt;chunkNativeStart = source-&gt;chunkNativeStart;
 78     result-&gt;chunkNativeLimit = source-&gt;chunkNativeStart;
 79     result-&gt;nativeIndexingLimit = static_cast&lt;int32_t&gt;(source-&gt;chunkNativeStart);
 80     result-&gt;chunkOffset = 0;
 81     result-&gt;context = source-&gt;context;
 82     result-&gt;a = source-&gt;a;
 83     result-&gt;pFuncs = &amp;uTextLatin1Funcs;
 84     result-&gt;chunkContents = (UChar*)result-&gt;pExtra;
 85     memset(const_cast&lt;UChar*&gt;(result-&gt;chunkContents), 0, sizeof(UChar) * UTextWithBufferInlineCapacity);
 86 
 87     return result;
 88 }
 89 
 90 static int64_t uTextLatin1NativeLength(UText* uText)
 91 {
 92     return uText-&gt;a;
 93 }
 94 
 95 static UBool uTextLatin1Access(UText* uText, int64_t index, UBool forward)
 96 {
 97     int64_t length = uText-&gt;a;
 98 
 99     if (forward) {
100         if (index &lt; uText-&gt;chunkNativeLimit &amp;&amp; index &gt;= uText-&gt;chunkNativeStart) {
101             // Already inside the buffer. Set the new offset.
102             uText-&gt;chunkOffset = static_cast&lt;int32_t&gt;(index - uText-&gt;chunkNativeStart);
103             return TRUE;
104         }
105         if (index &gt;= length &amp;&amp; uText-&gt;chunkNativeLimit == length) {
106             // Off the end of the buffer, but we can&#39;t get it.
107             uText-&gt;chunkOffset = static_cast&lt;int32_t&gt;(index - uText-&gt;chunkNativeStart);
108             return FALSE;
109         }
110     } else {
111         if (index &lt;= uText-&gt;chunkNativeLimit &amp;&amp; index &gt; uText-&gt;chunkNativeStart) {
112             // Already inside the buffer. Set the new offset.
113             uText-&gt;chunkOffset = static_cast&lt;int32_t&gt;(index - uText-&gt;chunkNativeStart);
114             return TRUE;
115         }
116         if (!index &amp;&amp; !uText-&gt;chunkNativeStart) {
117             // Already at the beginning; can&#39;t go any farther.
118             uText-&gt;chunkOffset = 0;
119             return FALSE;
120         }
121     }
122 
123     if (forward) {
124         uText-&gt;chunkNativeStart = index;
125         uText-&gt;chunkNativeLimit = uText-&gt;chunkNativeStart + UTextWithBufferInlineCapacity;
126         if (uText-&gt;chunkNativeLimit &gt; length)
127             uText-&gt;chunkNativeLimit = length;
128 
129         uText-&gt;chunkOffset = 0;
130     } else {
131         uText-&gt;chunkNativeLimit = index;
132         if (uText-&gt;chunkNativeLimit &gt; length)
133             uText-&gt;chunkNativeLimit = length;
134 
135         uText-&gt;chunkNativeStart = uText-&gt;chunkNativeLimit - UTextWithBufferInlineCapacity;
136         if (uText-&gt;chunkNativeStart &lt; 0)
137             uText-&gt;chunkNativeStart = 0;
138 
139         uText-&gt;chunkOffset = static_cast&lt;int32_t&gt;(index - uText-&gt;chunkNativeStart);
140     }
141     uText-&gt;chunkLength = static_cast&lt;int32_t&gt;(uText-&gt;chunkNativeLimit - uText-&gt;chunkNativeStart);
142 
143     StringImpl::copyCharacters(const_cast&lt;UChar*&gt;(uText-&gt;chunkContents), static_cast&lt;const LChar*&gt;(uText-&gt;context) + uText-&gt;chunkNativeStart, static_cast&lt;unsigned&gt;(uText-&gt;chunkLength));
144 
145     uText-&gt;nativeIndexingLimit = uText-&gt;chunkLength;
146 
147     return TRUE;
148 }
149 
150 static int32_t uTextLatin1Extract(UText* uText, int64_t start, int64_t limit, UChar* dest, int32_t destCapacity, UErrorCode* status)
151 {
152     int64_t length = uText-&gt;a;
153     if (U_FAILURE(*status))
154         return 0;
155 
156     if (destCapacity &lt; 0 || (!dest &amp;&amp; destCapacity &gt; 0)) {
157         *status = U_ILLEGAL_ARGUMENT_ERROR;
158         return 0;
159     }
160 
161     if (start &lt; 0 || start &gt; limit || (limit - start) &gt; INT32_MAX) {
162         *status = U_INDEX_OUTOFBOUNDS_ERROR;
163         return 0;
164     }
165 
166     if (start &gt; length)
167         start = length;
168     if (limit &gt; length)
169         limit = length;
170 
171     length = limit - start;
172 
173     if (!length)
174         return 0;
175 
176     if (dest) {
177         int32_t trimmedLength = static_cast&lt;int32_t&gt;(length);
178         if (trimmedLength &gt; destCapacity)
179             trimmedLength = destCapacity;
180 
181         StringImpl::copyCharacters(dest, static_cast&lt;const LChar*&gt;(uText-&gt;context) + start, static_cast&lt;unsigned&gt;(trimmedLength));
182     }
183 
184     if (length &lt; destCapacity) {
185         if (dest)
186             dest[length] = 0;
187         if (*status == U_STRING_NOT_TERMINATED_WARNING)
188             *status = U_ZERO_ERROR;
189     } else if (length == destCapacity)
190         *status = U_STRING_NOT_TERMINATED_WARNING;
191     else
192         *status = U_BUFFER_OVERFLOW_ERROR;
193 
194     return static_cast&lt;int32_t&gt;(length);
195 }
196 
197 static int64_t uTextLatin1MapOffsetToNative(const UText* uText)
198 {
199     return uText-&gt;chunkNativeStart + uText-&gt;chunkOffset;
200 }
201 
202 static int32_t uTextLatin1MapNativeIndexToUTF16(const UText* uText, int64_t nativeIndex)
203 {
204     ASSERT_UNUSED(uText, uText-&gt;chunkNativeStart &gt;= nativeIndex);
205     ASSERT_UNUSED(uText, nativeIndex &lt; uText-&gt;chunkNativeLimit);
206     return static_cast&lt;int32_t&gt;(nativeIndex);
207 }
208 
209 static void uTextLatin1Close(UText* uText)
210 {
211     uText-&gt;context = nullptr;
212 }
213 
214 UText* openLatin1UTextProvider(UTextWithBuffer* utWithBuffer, const LChar* string, unsigned length, UErrorCode* status)
215 {
216     if (U_FAILURE(*status))
217         return nullptr;
218     if (!string || length &gt; static_cast&lt;unsigned&gt;(std::numeric_limits&lt;int32_t&gt;::max())) {
219         *status = U_ILLEGAL_ARGUMENT_ERROR;
220         return nullptr;
221     }
222     UText* text = utext_setup(&amp;utWithBuffer-&gt;text, sizeof(utWithBuffer-&gt;buffer), status);
223     if (U_FAILURE(*status)) {
224         ASSERT(!text);
225         return nullptr;
226     }
227 
228     text-&gt;context = string;
229     text-&gt;a = length;
230     text-&gt;pFuncs = &amp;uTextLatin1Funcs;
231     text-&gt;chunkContents = (UChar*)text-&gt;pExtra;
232     memset(const_cast&lt;UChar*&gt;(text-&gt;chunkContents), 0, sizeof(UChar) * UTextWithBufferInlineCapacity);
233 
234     return text;
235 }
236 
237 
238 // Latin1ContextAware provider
239 
240 static UText* uTextLatin1ContextAwareClone(UText*, const UText*, UBool, UErrorCode*);
241 static int64_t uTextLatin1ContextAwareNativeLength(UText*);
242 static UBool uTextLatin1ContextAwareAccess(UText*, int64_t, UBool);
243 static int32_t uTextLatin1ContextAwareExtract(UText*, int64_t, int64_t, UChar*, int32_t, UErrorCode*);
244 static void uTextLatin1ContextAwareClose(UText*);
245 
246 static const struct UTextFuncs textLatin1ContextAwareFuncs = {
247     sizeof(UTextFuncs),
248     0,
249     0,
250     0,
251     uTextLatin1ContextAwareClone,
252     uTextLatin1ContextAwareNativeLength,
253     uTextLatin1ContextAwareAccess,
254     uTextLatin1ContextAwareExtract,
255     nullptr,
256     nullptr,
257     nullptr,
258     nullptr,
259     uTextLatin1ContextAwareClose,
260     nullptr,
261     nullptr,
262     nullptr
263 };
264 
265 static inline UTextProviderContext textLatin1ContextAwareGetCurrentContext(const UText* text)
266 {
267     if (!text-&gt;chunkContents)
268         return UTextProviderContext::NoContext;
269     return text-&gt;chunkContents == text-&gt;pExtra ? UTextProviderContext::PrimaryContext : UTextProviderContext::PriorContext;
270 }
271 
272 static void textLatin1ContextAwareMoveInPrimaryContext(UText* text, int64_t nativeIndex, int64_t nativeLength, UBool forward)
273 {
274     ASSERT(text-&gt;chunkContents == text-&gt;pExtra);
275     if (forward) {
276         ASSERT(nativeIndex &gt;= text-&gt;b &amp;&amp; nativeIndex &lt; nativeLength);
277         text-&gt;chunkNativeStart = nativeIndex;
278         text-&gt;chunkNativeLimit = nativeIndex + text-&gt;extraSize / sizeof(UChar);
279         if (text-&gt;chunkNativeLimit &gt; nativeLength)
280             text-&gt;chunkNativeLimit = nativeLength;
281     } else {
282         ASSERT(nativeIndex &gt; text-&gt;b &amp;&amp; nativeIndex &lt;= nativeLength);
283         text-&gt;chunkNativeLimit = nativeIndex;
284         text-&gt;chunkNativeStart = nativeIndex - text-&gt;extraSize / sizeof(UChar);
285         if (text-&gt;chunkNativeStart &lt; text-&gt;b)
286             text-&gt;chunkNativeStart = text-&gt;b;
287     }
288     int64_t length = text-&gt;chunkNativeLimit - text-&gt;chunkNativeStart;
289     // Ensure chunk length is well defined if computed length exceeds int32_t range.
290     ASSERT(length &lt; std::numeric_limits&lt;int32_t&gt;::max());
291     text-&gt;chunkLength = length &lt; std::numeric_limits&lt;int32_t&gt;::max() ? static_cast&lt;int32_t&gt;(length) : 0;
292     text-&gt;nativeIndexingLimit = text-&gt;chunkLength;
293     text-&gt;chunkOffset = forward ? 0 : text-&gt;chunkLength;
294     StringImpl::copyCharacters(const_cast&lt;UChar*&gt;(text-&gt;chunkContents), static_cast&lt;const LChar*&gt;(text-&gt;p) + (text-&gt;chunkNativeStart - text-&gt;b), static_cast&lt;unsigned&gt;(text-&gt;chunkLength));
295 }
296 
297 static void textLatin1ContextAwareSwitchToPrimaryContext(UText* text, int64_t nativeIndex, int64_t nativeLength, UBool forward)
298 {
299     ASSERT(!text-&gt;chunkContents || text-&gt;chunkContents == text-&gt;q);
300     text-&gt;chunkContents = static_cast&lt;const UChar*&gt;(text-&gt;pExtra);
301     textLatin1ContextAwareMoveInPrimaryContext(text, nativeIndex, nativeLength, forward);
302 }
303 
304 static void textLatin1ContextAwareMoveInPriorContext(UText* text, int64_t nativeIndex, int64_t nativeLength, UBool forward)
305 {
306     ASSERT(text-&gt;chunkContents == text-&gt;q);
307     ASSERT(forward ? nativeIndex &lt; text-&gt;b : nativeIndex &lt;= text-&gt;b);
308     ASSERT_UNUSED(nativeLength, forward ? nativeIndex &lt; nativeLength : nativeIndex &lt;= nativeLength);
309     ASSERT_UNUSED(forward, forward ? nativeIndex &lt; nativeLength : nativeIndex &lt;= nativeLength);
310     text-&gt;chunkNativeStart = 0;
311     text-&gt;chunkNativeLimit = text-&gt;b;
312     text-&gt;chunkLength = text-&gt;b;
313     text-&gt;nativeIndexingLimit = text-&gt;chunkLength;
314     int64_t offset = nativeIndex - text-&gt;chunkNativeStart;
315     // Ensure chunk offset is well defined if computed offset exceeds int32_t range or chunk length.
316     ASSERT(offset &lt; std::numeric_limits&lt;int32_t&gt;::max());
317     text-&gt;chunkOffset = std::min(offset &lt; std::numeric_limits&lt;int32_t&gt;::max() ? static_cast&lt;int32_t&gt;(offset) : 0, text-&gt;chunkLength);
318 }
319 
320 static void textLatin1ContextAwareSwitchToPriorContext(UText* text, int64_t nativeIndex, int64_t nativeLength, UBool forward)
321 {
322     ASSERT(!text-&gt;chunkContents || text-&gt;chunkContents == text-&gt;pExtra);
323     text-&gt;chunkContents = static_cast&lt;const UChar*&gt;(text-&gt;q);
324     textLatin1ContextAwareMoveInPriorContext(text, nativeIndex, nativeLength, forward);
325 }
326 
327 static UText* uTextLatin1ContextAwareClone(UText* destination, const UText* source, UBool deep, UErrorCode* status)
328 {
329     return uTextCloneImpl(destination, source, deep, status);
330 }
331 
332 static int64_t uTextLatin1ContextAwareNativeLength(UText* text)
333 {
334     return text-&gt;a + text-&gt;b;
335 }
336 
337 static UBool uTextLatin1ContextAwareAccess(UText* text, int64_t nativeIndex, UBool forward)
338 {
339     if (!text-&gt;context)
340         return FALSE;
341     int64_t nativeLength = uTextLatin1ContextAwareNativeLength(text);
342     UBool isAccessible;
343     if (uTextAccessInChunkOrOutOfRange(text, nativeIndex, nativeLength, forward, isAccessible))
344         return isAccessible;
345     nativeIndex = uTextAccessPinIndex(nativeIndex, nativeLength);
346     UTextProviderContext currentContext = textLatin1ContextAwareGetCurrentContext(text);
347     UTextProviderContext newContext = uTextProviderContext(text, nativeIndex, forward);
348     ASSERT(newContext != UTextProviderContext::NoContext);
349     if (newContext == currentContext) {
350         if (currentContext == UTextProviderContext::PrimaryContext)
351             textLatin1ContextAwareMoveInPrimaryContext(text, nativeIndex, nativeLength, forward);
352         else
353             textLatin1ContextAwareMoveInPriorContext(text, nativeIndex, nativeLength, forward);
354     } else if (newContext == UTextProviderContext::PrimaryContext)
355         textLatin1ContextAwareSwitchToPrimaryContext(text, nativeIndex, nativeLength, forward);
356     else {
357         ASSERT(newContext == UTextProviderContext::PriorContext);
358         textLatin1ContextAwareSwitchToPriorContext(text, nativeIndex, nativeLength, forward);
359     }
360     return TRUE;
361 }
362 
363 static int32_t uTextLatin1ContextAwareExtract(UText*, int64_t, int64_t, UChar*, int32_t, UErrorCode* errorCode)
364 {
365     // In the present context, this text provider is used only with ICU functions
366     // that do not perform an extract operation.
367     ASSERT_NOT_REACHED();
368     *errorCode = U_UNSUPPORTED_ERROR;
369     return 0;
370 }
371 
372 static void uTextLatin1ContextAwareClose(UText* text)
373 {
374     text-&gt;context = nullptr;
375 }
376 
377 UText* openLatin1ContextAwareUTextProvider(UTextWithBuffer* utWithBuffer, const LChar* string, unsigned length, const UChar* priorContext, int priorContextLength, UErrorCode* status)
378 {
379     if (U_FAILURE(*status))
380         return 0;
381     if (!string || length &gt; static_cast&lt;unsigned&gt;(std::numeric_limits&lt;int32_t&gt;::max())) {
382         *status = U_ILLEGAL_ARGUMENT_ERROR;
383         return 0;
384     }
385     UText* text = utext_setup(&amp;utWithBuffer-&gt;text, sizeof(utWithBuffer-&gt;buffer), status);
386     if (U_FAILURE(*status)) {
387         ASSERT(!text);
388         return 0;
389     }
390 
391     initializeContextAwareUTextProvider(text, &amp;textLatin1ContextAwareFuncs, string, length, priorContext, priorContextLength);
392     return text;
393 }
394 
395 } // namespace WTF
    </pre>
  </body>
</html>
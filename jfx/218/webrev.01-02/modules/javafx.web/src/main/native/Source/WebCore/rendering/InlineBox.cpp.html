<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2003, 2004, 2005, 2006, 2007 Apple Inc. All rights reserved.
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Library General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public License
 15  * along with this library; see the file COPYING.LIB.  If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  */
 19 
 20 #include &quot;config.h&quot;
 21 #include &quot;InlineBox.h&quot;
 22 
 23 #include &quot;FontMetrics.h&quot;
 24 #include &quot;Frame.h&quot;
 25 #include &quot;HitTestResult.h&quot;
 26 #include &quot;InlineFlowBox.h&quot;
 27 #include &quot;RenderBlockFlow.h&quot;
 28 #include &quot;RenderLineBreak.h&quot;
 29 #include &quot;RootInlineBox.h&quot;
 30 #include &lt;wtf/IsoMallocInlines.h&gt;
 31 #include &lt;wtf/text/TextStream.h&gt;
 32 
 33 #if ENABLE(TREE_DEBUGGING)
 34 #include &lt;stdio.h&gt;
 35 #endif
 36 
 37 namespace WebCore {
 38 
 39 WTF_MAKE_ISO_ALLOCATED_IMPL(InlineBox);
 40 
 41 struct SameSizeAsInlineBox {
 42     virtual ~SameSizeAsInlineBox() = default;
 43     void* a[4];
 44     FloatPoint b;
 45     float c[2];
 46     unsigned d : 23;
 47 #if !ASSERT_WITH_SECURITY_IMPLICATION_DISABLED
 48     unsigned s;
 49     bool f;
 50     bool i;
 51 #endif
 52 };
 53 
 54 COMPILE_ASSERT(sizeof(InlineBox) == sizeof(SameSizeAsInlineBox), InlineBox_size_guard);
 55 
 56 #if !ASSERT_WITH_SECURITY_IMPLICATION_DISABLED
 57 
 58 void InlineBox::assertNotDeleted() const
 59 {
 60     ASSERT(m_deletionSentinel == deletionSentinelNotDeletedValue);
 61 }
 62 
 63 InlineBox::~InlineBox()
 64 {
 65     invalidateParentChildList();
 66     m_deletionSentinel = deletionSentinelDeletedValue;
 67 }
 68 
 69 void InlineBox::setHasBadParent()
 70 {
 71     assertNotDeleted();
 72     m_hasBadParent = true;
 73 }
 74 
 75 void InlineBox::invalidateParentChildList()
 76 {
 77     assertNotDeleted();
 78     if (!m_hasBadParent &amp;&amp; m_parent &amp;&amp; m_isEverInChildList)
 79         m_parent-&gt;setHasBadChildList();
 80 }
 81 
 82 #endif
 83 
 84 void InlineBox::removeFromParent()
 85 {
 86     if (parent())
 87         parent()-&gt;removeChild(this);
 88 }
 89 
 90 #if ENABLE(TREE_DEBUGGING)
 91 
 92 const char* InlineBox::boxName() const
 93 {
 94     return &quot;InlineBox&quot;;
 95 }
 96 
 97 void InlineBox::showNodeTreeForThis() const
 98 {
 99     m_renderer.showNodeTreeForThis();
100 }
101 
102 void InlineBox::showLineTreeForThis() const
103 {
104     m_renderer.containingBlock()-&gt;showLineTreeForThis();
105 }
106 
107 void InlineBox::outputLineTreeAndMark(TextStream&amp; stream, const InlineBox* markedBox, int depth) const
108 {
109     outputLineBox(stream, markedBox == this, depth);
110 }
111 
112 void InlineBox::outputLineBox(TextStream&amp; stream, bool mark, int depth) const
113 {
114     stream &lt;&lt; &quot;-------- &quot; &lt;&lt; (isDirty() ? &quot;D&quot; : &quot;-&quot;) &lt;&lt; &quot;-&quot;;
115     int printedCharacters = 0;
116     if (mark) {
117         stream &lt;&lt; &quot;*&quot;;
118         ++printedCharacters;
119     }
120     while (++printedCharacters &lt;= depth * 2)
121         stream &lt;&lt; &quot; &quot;;
122     stream &lt;&lt; boxName() &lt;&lt; &quot; &quot; &lt;&lt; FloatRect(x(), y(), width(), height()) &lt;&lt; &quot; (&quot; &lt;&lt; this &lt;&lt; &quot;) renderer-&gt;(&quot; &lt;&lt; &amp;renderer() &lt;&lt; &quot;)&quot;;
123     stream.nextLine();
124 }
125 
126 #endif // ENABLE(TREE_DEBUGGING)
127 
128 float InlineBox::logicalHeight() const
129 {
130     if (hasVirtualLogicalHeight())
131         return virtualLogicalHeight();
132 
133     const RenderStyle&amp; lineStyle = this-&gt;lineStyle();
134     if (renderer().isTextOrLineBreak())
135         return lineStyle.fontMetrics().height();
136     if (is&lt;RenderBox&gt;(renderer()) &amp;&amp; parent())
137         return isHorizontal() ? downcast&lt;RenderBox&gt;(renderer()).height() : downcast&lt;RenderBox&gt;(renderer()).width();
138 
139     ASSERT(isInlineFlowBox());
140     RenderBoxModelObject* flowObject = boxModelObject();
141     const FontMetrics&amp; fontMetrics = lineStyle.fontMetrics();
142     float result = fontMetrics.height();
143     if (parent())
144         result += flowObject-&gt;borderAndPaddingLogicalHeight();
145     return result;
146 }
147 
148 int InlineBox::baselinePosition(FontBaseline baselineType) const
149 {
150     return boxModelObject()-&gt;baselinePosition(baselineType, m_bitfields.firstLine(), isHorizontal() ? HorizontalLine : VerticalLine, PositionOnContainingLine);
151 }
152 
153 LayoutUnit InlineBox::lineHeight() const
154 {
155     return boxModelObject()-&gt;lineHeight(m_bitfields.firstLine(), isHorizontal() ? HorizontalLine : VerticalLine, PositionOnContainingLine);
156 }
157 
158 int InlineBox::caretMinOffset() const
159 {
160     return m_renderer.caretMinOffset();
161 }
162 
163 int InlineBox::caretMaxOffset() const
164 {
165     return m_renderer.caretMaxOffset();
166 }
167 
168 void InlineBox::dirtyLineBoxes()
169 {
170     markDirty();
171     for (InlineFlowBox* curr = parent(); curr &amp;&amp; !curr-&gt;isDirty(); curr = curr-&gt;parent())
172         curr-&gt;markDirty();
173 }
174 
175 void InlineBox::adjustPosition(float dx, float dy)
176 {
177     m_topLeft.move(dx, dy);
178 
179     if (m_renderer.isOutOfFlowPositioned())
180         return;
181 
182     if (m_renderer.isReplaced())
183         downcast&lt;RenderBox&gt;(renderer()).move(LayoutUnit(dx), LayoutUnit(dy));
184 }
185 
186 const RootInlineBox&amp; InlineBox::root() const
187 {
188     if (parent())
189         return parent()-&gt;root();
190     return downcast&lt;RootInlineBox&gt;(*this);
191 }
192 
193 RootInlineBox&amp; InlineBox::root()
194 {
195     if (parent())
196         return parent()-&gt;root();
197     return downcast&lt;RootInlineBox&gt;(*this);
198 }
199 
200 bool InlineBox::nextOnLineExists() const
201 {
202     if (!m_bitfields.determinedIfNextOnLineExists()) {
203         m_bitfields.setDeterminedIfNextOnLineExists(true);
204 
205         if (!parent())
206             m_bitfields.setNextOnLineExists(false);
207         else if (nextOnLine())
208             m_bitfields.setNextOnLineExists(true);
209         else
210             m_bitfields.setNextOnLineExists(parent()-&gt;nextOnLineExists());
211     }
212     return m_bitfields.nextOnLineExists();
213 }
214 
215 bool InlineBox::previousOnLineExists() const
216 {
217     if (!parent())
218         return false;
219     if (previousOnLine())
220         return true;
221     return parent()-&gt;previousOnLineExists();
222 }
223 
224 InlineBox* InlineBox::nextLeafOnLine() const
225 {
226     InlineBox* leaf = nullptr;
227     for (InlineBox* box = nextOnLine(); box &amp;&amp; !leaf; box = box-&gt;nextOnLine())
228         leaf = box-&gt;isLeaf() ? box : downcast&lt;InlineFlowBox&gt;(*box).firstLeafDescendant();
229     if (!leaf &amp;&amp; parent())
230         leaf = parent()-&gt;nextLeafOnLine();
231     return leaf;
232 }
233 
234 InlineBox* InlineBox::previousLeafOnLine() const
235 {
236     InlineBox* leaf = nullptr;
237     for (InlineBox* box = previousOnLine(); box &amp;&amp; !leaf; box = box-&gt;previousOnLine())
238         leaf = box-&gt;isLeaf() ? box : downcast&lt;InlineFlowBox&gt;(*box).lastLeafDescendant();
239     if (!leaf &amp;&amp; parent())
240         leaf = parent()-&gt;previousLeafOnLine();
241     return leaf;
242 }
243 
244 InlineBox* InlineBox::nextLeafOnLineIgnoringLineBreak() const
245 {
246     InlineBox* leaf = nextLeafOnLine();
247     if (leaf &amp;&amp; leaf-&gt;isLineBreak())
248         return nullptr;
249     return leaf;
250 }
251 
252 InlineBox* InlineBox::previousLeafOnLineIgnoringLineBreak() const
253 {
254     InlineBox* leaf = previousLeafOnLine();
255     if (leaf &amp;&amp; leaf-&gt;isLineBreak())
256         return nullptr;
257     return leaf;
258 }
259 
260 RenderObject::SelectionState InlineBox::selectionState()
261 {
262     return m_renderer.selectionState();
263 }
264 
265 bool InlineBox::canAccommodateEllipsis(bool ltr, int blockEdge, int ellipsisWidth) const
266 {
267     // Non-replaced elements can always accommodate an ellipsis.
268     if (!m_renderer.isReplaced())
269         return true;
270 
271     IntRect boxRect(left(), 0, m_logicalWidth, 10);
272     IntRect ellipsisRect(ltr ? blockEdge - ellipsisWidth : blockEdge, 0, ellipsisWidth, 10);
273     return !(boxRect.intersects(ellipsisRect));
274 }
275 
276 float InlineBox::placeEllipsisBox(bool, float, float, float, float&amp; truncatedWidth, bool&amp;)
277 {
278     // Use -1 to mean &quot;we didn&#39;t set the position.&quot;
279     truncatedWidth += logicalWidth();
280     return -1;
281 }
282 
283 void InlineBox::clearKnownToHaveNoOverflow()
284 {
285     m_bitfields.setKnownToHaveNoOverflow(false);
286     if (parent() &amp;&amp; parent()-&gt;knownToHaveNoOverflow())
287         parent()-&gt;clearKnownToHaveNoOverflow();
288 }
289 
290 FloatPoint InlineBox::locationIncludingFlipping() const
291 {
292     if (!m_renderer.style().isFlippedBlocksWritingMode())
293         return topLeft();
294     RenderBlockFlow&amp; block = root().blockFlow();
295     if (block.style().isHorizontalWritingMode())
296         return { x(), block.height() - height() - y() };
297     return { block.width() - width() - x(), y() };
298 }
299 
300 void InlineBox::flipForWritingMode(FloatRect&amp; rect) const
301 {
302     if (!m_renderer.style().isFlippedBlocksWritingMode())
303         return;
304     root().blockFlow().flipForWritingMode(rect);
305 }
306 
307 FloatPoint InlineBox::flipForWritingMode(const FloatPoint&amp; point) const
308 {
309     if (!m_renderer.style().isFlippedBlocksWritingMode())
310         return point;
311     return root().blockFlow().flipForWritingMode(point);
312 }
313 
314 void InlineBox::flipForWritingMode(LayoutRect&amp; rect) const
315 {
316     if (!m_renderer.style().isFlippedBlocksWritingMode())
317         return;
318     root().blockFlow().flipForWritingMode(rect);
319 }
320 
321 LayoutPoint InlineBox::flipForWritingMode(const LayoutPoint&amp; point) const
322 {
323     if (!m_renderer.style().isFlippedBlocksWritingMode())
324         return point;
325     return root().blockFlow().flipForWritingMode(point);
326 }
327 
328 } // namespace WebCore
329 
330 #if ENABLE(TREE_DEBUGGING)
331 
332 void showNodeTree(const WebCore::InlineBox* inlineBox)
333 {
334     if (!inlineBox)
335         return;
336     inlineBox-&gt;showNodeTreeForThis();
337 }
338 
339 void showLineTree(const WebCore::InlineBox* inlineBox)
340 {
341     if (!inlineBox)
342         return;
343     inlineBox-&gt;showLineTreeForThis();
344 }
345 
346 #endif
    </pre>
  </body>
</html>
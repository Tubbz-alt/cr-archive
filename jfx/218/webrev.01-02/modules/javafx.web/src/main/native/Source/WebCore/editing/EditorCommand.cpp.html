<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/editing/EditorCommand.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2006-2008, 2014, 2016 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
   4  * Copyright (C) 2009 Igalia S.L.
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  * 1. Redistributions of source code must retain the above copyright
  10  *    notice, this list of conditions and the following disclaimer.
  11  * 2. Redistributions in binary form must reproduce the above copyright
  12  *    notice, this list of conditions and the following disclaimer in the
  13  *    documentation and/or other materials provided with the distribution.
  14  *
  15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  26  */
  27 
  28 #include &quot;config.h&quot;
  29 #include &quot;Editor.h&quot;
  30 
  31 #include &quot;CSSComputedStyleDeclaration.h&quot;
  32 #include &quot;CSSValueList.h&quot;
  33 #include &quot;Chrome.h&quot;
  34 #include &quot;CreateLinkCommand.h&quot;
  35 #include &quot;DocumentFragment.h&quot;
  36 #include &quot;Editing.h&quot;
  37 #include &quot;EditorClient.h&quot;
  38 #include &quot;Event.h&quot;
  39 #include &quot;EventHandler.h&quot;
  40 #include &quot;FormatBlockCommand.h&quot;
  41 #include &quot;Frame.h&quot;
  42 #include &quot;FrameLoader.h&quot;
  43 #include &quot;FrameView.h&quot;
  44 #include &quot;HTMLFontElement.h&quot;
  45 #include &quot;HTMLHRElement.h&quot;
  46 #include &quot;HTMLImageElement.h&quot;
  47 #include &quot;HTMLNames.h&quot;
  48 #include &quot;IndentOutdentCommand.h&quot;
  49 #include &quot;InsertEditableImageCommand.h&quot;
  50 #include &quot;InsertListCommand.h&quot;
  51 #include &quot;InsertNestedListCommand.h&quot;
  52 #include &quot;Page.h&quot;
  53 #include &quot;Pasteboard.h&quot;
  54 #include &quot;RenderBox.h&quot;
  55 #include &quot;ReplaceSelectionCommand.h&quot;
  56 #include &quot;Scrollbar.h&quot;
  57 #include &quot;Settings.h&quot;
  58 #include &quot;StyleProperties.h&quot;
  59 #include &quot;TypingCommand.h&quot;
  60 #include &quot;UnlinkCommand.h&quot;
  61 #include &quot;UserGestureIndicator.h&quot;
  62 #include &quot;UserTypingGestureIndicator.h&quot;
  63 #include &quot;markup.h&quot;
  64 #include &lt;pal/system/Sound.h&gt;
  65 #include &lt;pal/text/KillRing.h&gt;
  66 #include &lt;wtf/text/AtomString.h&gt;
  67 
  68 namespace WebCore {
  69 
  70 using namespace HTMLNames;
  71 
  72 class EditorInternalCommand {
  73 public:
  74     bool (*execute)(Frame&amp;, Event*, EditorCommandSource, const String&amp;);
  75     bool (*isSupportedFromDOM)(Frame*);
  76     bool (*isEnabled)(Frame&amp;, Event*, EditorCommandSource);
  77     TriState (*state)(Frame&amp;, Event*);
  78     String (*value)(Frame&amp;, Event*);
  79     bool isTextInsertion;
  80     bool (*allowExecutionWhenDisabled)(Frame&amp;, EditorCommandSource);
  81 };
  82 
  83 typedef HashMap&lt;String, const EditorInternalCommand*, ASCIICaseInsensitiveHash&gt; CommandMap;
  84 
  85 static const bool notTextInsertion = false;
  86 static const bool isTextInsertion = true;
  87 
  88 // Related to Editor::selectionForCommand.
  89 // Certain operations continue to use the target control&#39;s selection even if the event handler
  90 // already moved the selection outside of the text control.
  91 static Frame* targetFrame(Frame&amp; frame, Event* event)
  92 {
  93     if (!event)
  94         return &amp;frame;
  95     if (!is&lt;Node&gt;(event-&gt;target()))
  96         return &amp;frame;
  97     return downcast&lt;Node&gt;(*event-&gt;target()).document().frame();
  98 }
  99 
 100 static bool applyCommandToFrame(Frame&amp; frame, EditorCommandSource source, EditAction action, Ref&lt;EditingStyle&gt;&amp;&amp; style)
 101 {
 102     // FIXME: We don&#39;t call shouldApplyStyle when the source is DOM; is there a good reason for that?
 103     switch (source) {
 104     case CommandFromMenuOrKeyBinding:
 105         // Use InvertColor for testing purposes. foreColor and backColor are never triggered with CommandFromMenuOrKeyBinding outside DRT/WTR.
 106         frame.editor().applyStyleToSelection(WTFMove(style), action, Editor::ColorFilterMode::InvertColor);
 107         return true;
 108     case CommandFromDOM:
 109     case CommandFromDOMWithUserInterface:
 110         frame.editor().applyStyle(WTFMove(style), EditAction::Unspecified, Editor::ColorFilterMode::UseOriginalColor);
 111         return true;
 112     }
 113     ASSERT_NOT_REACHED();
 114     return false;
 115 }
 116 
 117 static bool isStylePresent(Editor&amp; editor, CSSPropertyID propertyID, const char* onValue)
 118 {
 119     // Style is considered present when
 120     // Mac: present at the beginning of selection
 121     // Windows: present throughout the selection
 122     if (editor.behavior().shouldToggleStyleBasedOnStartOfSelection())
 123         return editor.selectionStartHasStyle(propertyID, onValue);
 124     return editor.selectionHasStyle(propertyID, onValue) == TrueTriState;
 125 }
 126 
 127 static bool executeApplyStyle(Frame&amp; frame, EditorCommandSource source, EditAction action, CSSPropertyID propertyID, const String&amp; propertyValue)
 128 {
 129     return applyCommandToFrame(frame, source, action, EditingStyle::create(propertyID, propertyValue));
 130 }
 131 
 132 static bool executeApplyStyle(Frame&amp; frame, EditorCommandSource source, EditAction action, CSSPropertyID propertyID, CSSValueID propertyValue)
 133 {
 134     return applyCommandToFrame(frame, source, action, EditingStyle::create(propertyID, propertyValue));
 135 }
 136 
 137 static bool executeToggleStyle(Frame&amp; frame, EditorCommandSource source, EditAction action, CSSPropertyID propertyID, const char* offValue, const char* onValue)
 138 {
 139     bool styleIsPresent = isStylePresent(frame.editor(), propertyID, onValue);
 140     return applyCommandToFrame(frame, source, action, EditingStyle::create(propertyID, styleIsPresent ? offValue : onValue));
 141 }
 142 
 143 static bool executeApplyParagraphStyle(Frame&amp; frame, EditorCommandSource source, EditAction action, CSSPropertyID propertyID, const String&amp; propertyValue)
 144 {
 145     auto style = MutableStyleProperties::create();
 146     style-&gt;setProperty(propertyID, propertyValue);
 147     // FIXME: We don&#39;t call shouldApplyStyle when the source is DOM; is there a good reason for that?
 148     switch (source) {
 149     case CommandFromMenuOrKeyBinding:
 150         frame.editor().applyParagraphStyleToSelection(style.ptr(), action);
 151         return true;
 152     case CommandFromDOM:
 153     case CommandFromDOMWithUserInterface:
 154         frame.editor().applyParagraphStyle(style.ptr());
 155         return true;
 156     }
 157     ASSERT_NOT_REACHED();
 158     return false;
 159 }
 160 
 161 static bool executeInsertFragment(Frame&amp; frame, Ref&lt;DocumentFragment&gt;&amp;&amp; fragment)
 162 {
 163     ASSERT(frame.document());
 164     ReplaceSelectionCommand::create(*frame.document(), WTFMove(fragment), ReplaceSelectionCommand::PreventNesting, EditAction::Insert)-&gt;apply();
 165     return true;
 166 }
 167 
 168 static bool executeInsertNode(Frame&amp; frame, Ref&lt;Node&gt;&amp;&amp; content)
 169 {
 170     auto fragment = DocumentFragment::create(*frame.document());
 171     if (fragment-&gt;appendChild(content).hasException())
 172         return false;
 173     return executeInsertFragment(frame, WTFMove(fragment));
 174 }
 175 
 176 static bool expandSelectionToGranularity(Frame&amp; frame, TextGranularity granularity)
 177 {
 178     VisibleSelection selection = frame.selection().selection();
 179     selection.expandUsingGranularity(granularity);
 180     RefPtr&lt;Range&gt; newRange = selection.toNormalizedRange();
 181     if (!newRange)
 182         return false;
 183     if (newRange-&gt;collapsed())
 184         return false;
 185     RefPtr&lt;Range&gt; oldRange = selection.toNormalizedRange();
 186     EAffinity affinity = selection.affinity();
 187     if (!frame.editor().client()-&gt;shouldChangeSelectedRange(oldRange.get(), newRange.get(), affinity, false))
 188         return false;
 189     frame.selection().setSelectedRange(newRange.get(), affinity, FrameSelection::ShouldCloseTyping::Yes);
 190     return true;
 191 }
 192 
 193 static TriState stateStyle(Frame&amp; frame, CSSPropertyID propertyID, const char* desiredValue)
 194 {
 195     if (frame.editor().behavior().shouldToggleStyleBasedOnStartOfSelection())
 196         return frame.editor().selectionStartHasStyle(propertyID, desiredValue) ? TrueTriState : FalseTriState;
 197     return frame.editor().selectionHasStyle(propertyID, desiredValue);
 198 }
 199 
 200 static String valueStyle(Frame&amp; frame, CSSPropertyID propertyID)
 201 {
 202     // FIXME: Rather than retrieving the style at the start of the current selection,
 203     // we should retrieve the style present throughout the selection for non-Mac platforms.
 204     return frame.editor().selectionStartCSSPropertyValue(propertyID);
 205 }
 206 
 207 static TriState stateTextWritingDirection(Frame&amp; frame, WritingDirection direction)
 208 {
 209     bool hasNestedOrMultipleEmbeddings;
 210     WritingDirection selectionDirection = EditingStyle::textDirectionForSelection(frame.selection().selection(),
 211         frame.selection().typingStyle(), hasNestedOrMultipleEmbeddings);
 212     // FXIME: We should be returning MixedTriState when selectionDirection == direction &amp;&amp; hasNestedOrMultipleEmbeddings
 213     return (selectionDirection == direction &amp;&amp; !hasNestedOrMultipleEmbeddings) ? TrueTriState : FalseTriState;
 214 }
 215 
 216 static unsigned verticalScrollDistance(Frame&amp; frame)
 217 {
 218     Element* focusedElement = frame.document()-&gt;focusedElement();
 219     if (!focusedElement)
 220         return 0;
 221     auto* renderer = focusedElement-&gt;renderer();
 222     if (!is&lt;RenderBox&gt;(renderer))
 223         return 0;
 224     const RenderStyle&amp; style = renderer-&gt;style();
 225     if (!(style.overflowY() == Overflow::Scroll || style.overflowY() == Overflow::Auto || focusedElement-&gt;hasEditableStyle()))
 226         return 0;
 227     int height = std::min&lt;int&gt;(downcast&lt;RenderBox&gt;(*renderer).clientHeight(), frame.view()-&gt;visibleHeight());
 228     return static_cast&lt;unsigned&gt;(Scrollbar::pageStep(height));
 229 }
 230 
 231 static RefPtr&lt;Range&gt; unionDOMRanges(Range&amp; a, Range&amp; b)
 232 {
 233     Range&amp; start = a.compareBoundaryPoints(Range::START_TO_START, b).releaseReturnValue() &lt;= 0 ? a : b;
 234     Range&amp; end = a.compareBoundaryPoints(Range::END_TO_END, b).releaseReturnValue() &lt;= 0 ? b : a;
 235     return Range::create(a.ownerDocument(), &amp;start.startContainer(), start.startOffset(), &amp;end.endContainer(), end.endOffset());
 236 }
 237 
 238 // Execute command functions
 239 
 240 static bool executeBackColor(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp; value)
 241 {
 242     return executeApplyStyle(frame, source, EditAction::SetBackgroundColor, CSSPropertyBackgroundColor, value);
 243 }
 244 
 245 static bool executeCopy(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 246 {
 247     frame.editor().copy();
 248     return true;
 249 }
 250 
 251 static bool executeCreateLink(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
 252 {
 253     // FIXME: If userInterface is true, we should display a dialog box to let the user enter a URL.
 254     if (value.isEmpty())
 255         return false;
 256     ASSERT(frame.document());
 257     CreateLinkCommand::create(*frame.document(), value)-&gt;apply();
 258     return true;
 259 }
 260 
 261 static bool executeCut(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 262 {
 263     if (source == CommandFromMenuOrKeyBinding) {
 264         UserTypingGestureIndicator typingGestureIndicator(frame);
 265         frame.editor().cut();
 266     } else
 267         frame.editor().cut();
 268     return true;
 269 }
 270 
 271 static bool executeClearText(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 272 {
 273     frame.editor().clearText();
 274     return true;
 275 }
 276 
 277 static bool executeDefaultParagraphSeparator(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
 278 {
 279     if (equalLettersIgnoringASCIICase(value, &quot;div&quot;))
 280         frame.editor().setDefaultParagraphSeparator(EditorParagraphSeparatorIsDiv);
 281     else if (equalLettersIgnoringASCIICase(value, &quot;p&quot;))
 282         frame.editor().setDefaultParagraphSeparator(EditorParagraphSeparatorIsP);
 283 
 284     return true;
 285 }
 286 
 287 static bool executeDelete(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 288 {
 289     switch (source) {
 290     case CommandFromMenuOrKeyBinding: {
 291         // Doesn&#39;t modify the text if the current selection isn&#39;t a range.
 292         UserTypingGestureIndicator typingGestureIndicator(frame);
 293         frame.editor().performDelete();
 294         return true;
 295     }
 296     case CommandFromDOM:
 297     case CommandFromDOMWithUserInterface:
 298         // If the current selection is a caret, delete the preceding character. IE performs forwardDelete, but we currently side with Firefox.
 299         // Doesn&#39;t scroll to make the selection visible, or modify the kill ring (this time, siding with IE, not Firefox).
 300         TypingCommand::deleteKeyPressed(*frame.document(), frame.editor().shouldSmartDelete() ? TypingCommand::SmartDelete : 0);
 301         return true;
 302     }
 303     ASSERT_NOT_REACHED();
 304     return false;
 305 }
 306 
 307 static bool executeDeleteBackward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 308 {
 309     frame.editor().deleteWithDirection(DirectionBackward, CharacterGranularity, false, true);
 310     return true;
 311 }
 312 
 313 static bool executeDeleteBackwardByDecomposingPreviousCharacter(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 314 {
 315     LOG_ERROR(&quot;DeleteBackwardByDecomposingPreviousCharacter is not implemented, doing DeleteBackward instead&quot;);
 316     frame.editor().deleteWithDirection(DirectionBackward, CharacterGranularity, false, true);
 317     return true;
 318 }
 319 
 320 static bool executeDeleteForward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 321 {
 322     frame.editor().deleteWithDirection(DirectionForward, CharacterGranularity, false, true);
 323     return true;
 324 }
 325 
 326 static bool executeDeleteToBeginningOfLine(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 327 {
 328     frame.editor().deleteWithDirection(DirectionBackward, LineBoundary, true, false);
 329     return true;
 330 }
 331 
 332 static bool executeDeleteToBeginningOfParagraph(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 333 {
 334     frame.editor().deleteWithDirection(DirectionBackward, ParagraphBoundary, true, false);
 335     return true;
 336 }
 337 
 338 static bool executeDeleteToEndOfLine(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 339 {
 340     // Despite its name, this command should delete the newline at the end of
 341     // a paragraph if you are at the end of a paragraph (like DeleteToEndOfParagraph).
 342     frame.editor().deleteWithDirection(DirectionForward, LineBoundary, true, false);
 343     return true;
 344 }
 345 
 346 static bool executeDeleteToEndOfParagraph(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 347 {
 348     // Despite its name, this command should delete the newline at the end of
 349     // a paragraph if you are at the end of a paragraph.
 350     frame.editor().deleteWithDirection(DirectionForward, ParagraphBoundary, true, false);
 351     return true;
 352 }
 353 
 354 static bool executeDeleteToMark(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 355 {
 356     RefPtr&lt;Range&gt; mark = frame.editor().mark().toNormalizedRange();
 357     FrameSelection&amp; selection = frame.selection();
 358     if (mark &amp;&amp; frame.editor().selectedRange()) {
 359         bool selected = selection.setSelectedRange(unionDOMRanges(*mark, *frame.editor().selectedRange()).get(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::Yes);
 360         ASSERT(selected);
 361         if (!selected)
 362             return false;
 363     }
 364     frame.editor().performDelete();
 365     frame.editor().setMark(selection.selection());
 366     return true;
 367 }
 368 
 369 static bool executeDeleteWordBackward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 370 {
 371     frame.editor().deleteWithDirection(DirectionBackward, WordGranularity, true, false);
 372     return true;
 373 }
 374 
 375 static bool executeDeleteWordForward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 376 {
 377     frame.editor().deleteWithDirection(DirectionForward, WordGranularity, true, false);
 378     return true;
 379 }
 380 
 381 static bool executeFindString(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
 382 {
 383     return frame.editor().findString(value, { CaseInsensitive, WrapAround, DoNotTraverseFlatTree });
 384 }
 385 
 386 static bool executeFontName(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp; value)
 387 {
 388     return executeApplyStyle(frame, source, EditAction::SetFont, CSSPropertyFontFamily, value);
 389 }
 390 
 391 static bool executeFontSize(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp; value)
 392 {
 393     CSSValueID size;
 394     if (!HTMLFontElement::cssValueFromFontSizeNumber(value, size))
 395         return false;
 396     return executeApplyStyle(frame, source, EditAction::ChangeAttributes, CSSPropertyFontSize, size);
 397 }
 398 
 399 static bool executeFontSizeDelta(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp; value)
 400 {
 401     return executeApplyStyle(frame, source, EditAction::ChangeAttributes, CSSPropertyWebkitFontSizeDelta, value);
 402 }
 403 
 404 static bool executeForeColor(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp; value)
 405 {
 406     return executeApplyStyle(frame, source, EditAction::SetColor, CSSPropertyColor, value);
 407 }
 408 
 409 static bool executeFormatBlock(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
 410 {
 411     String tagName = value.convertToASCIILowercase();
 412     if (tagName[0] == &#39;&lt;&#39; &amp;&amp; tagName[tagName.length() - 1] == &#39;&gt;&#39;)
 413         tagName = tagName.substring(1, tagName.length() - 2);
 414 
 415     auto qualifiedTagName = Document::parseQualifiedName(xhtmlNamespaceURI, tagName);
 416     if (qualifiedTagName.hasException())
 417         return false;
 418 
 419     ASSERT(frame.document());
 420     auto command = FormatBlockCommand::create(*frame.document(), qualifiedTagName.releaseReturnValue());
 421     command-&gt;apply();
 422     return command-&gt;didApply();
 423 }
 424 
 425 static bool executeForwardDelete(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 426 {
 427     switch (source) {
 428     case CommandFromMenuOrKeyBinding:
 429         frame.editor().deleteWithDirection(DirectionForward, CharacterGranularity, false, true);
 430         return true;
 431     case CommandFromDOM:
 432     case CommandFromDOMWithUserInterface:
 433         // Doesn&#39;t scroll to make the selection visible, or modify the kill ring.
 434         // ForwardDelete is not implemented in IE or Firefox, so this behavior is only needed for
 435         // backward compatibility with ourselves, and for consistency with Delete.
 436         TypingCommand::forwardDeleteKeyPressed(*frame.document());
 437         return true;
 438     }
 439     ASSERT_NOT_REACHED();
 440     return false;
 441 }
 442 
 443 static bool executeIgnoreSpelling(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 444 {
 445     frame.editor().ignoreSpelling();
 446     return true;
 447 }
 448 
 449 static bool executeIndent(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 450 {
 451     ASSERT(frame.document());
 452     IndentOutdentCommand::create(*frame.document(), IndentOutdentCommand::Indent)-&gt;apply();
 453     return true;
 454 }
 455 
 456 static bool executeInsertBacktab(Frame&amp; frame, Event* event, EditorCommandSource, const String&amp;)
 457 {
 458     return targetFrame(frame, event)-&gt;eventHandler().handleTextInputEvent(&quot;\t&quot;_s, event, TextEventInputBackTab);
 459 }
 460 
 461 static bool executeInsertHorizontalRule(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
 462 {
 463     Ref&lt;HTMLHRElement&gt; rule = HTMLHRElement::create(*frame.document());
 464     if (!value.isEmpty())
 465         rule-&gt;setIdAttribute(value);
 466     return executeInsertNode(frame, WTFMove(rule));
 467 }
 468 
 469 static bool executeInsertHTML(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
 470 {
 471     return executeInsertFragment(frame, createFragmentFromMarkup(*frame.document(), value, emptyString()));
 472 }
 473 
 474 static bool executeInsertImage(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
 475 {
 476     // FIXME: If userInterface is true, we should display a dialog box and let the user choose a local image.
 477     Ref&lt;HTMLImageElement&gt; image = HTMLImageElement::create(*frame.document());
 478     image-&gt;setSrc(value);
 479     return executeInsertNode(frame, WTFMove(image));
 480 }
 481 
 482 static bool executeInsertEditableImage(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 483 {
 484     ASSERT(frame.document());
 485     InsertEditableImageCommand::create(*frame.document())-&gt;apply();
 486     return true;
 487 }
 488 
 489 static bool executeInsertLineBreak(Frame&amp; frame, Event* event, EditorCommandSource source, const String&amp;)
 490 {
 491     switch (source) {
 492     case CommandFromMenuOrKeyBinding:
 493         return targetFrame(frame, event)-&gt;eventHandler().handleTextInputEvent(&quot;\n&quot;_s, event, TextEventInputLineBreak);
 494     case CommandFromDOM:
 495     case CommandFromDOMWithUserInterface:
 496         // Doesn&#39;t scroll to make the selection visible, or modify the kill ring.
 497         // InsertLineBreak is not implemented in IE or Firefox, so this behavior is only needed for
 498         // backward compatibility with ourselves, and for consistency with other commands.
 499         TypingCommand::insertLineBreak(*frame.document(), 0);
 500         return true;
 501     }
 502     ASSERT_NOT_REACHED();
 503     return false;
 504 }
 505 
 506 static bool executeInsertNewline(Frame&amp; frame, Event* event, EditorCommandSource, const String&amp;)
 507 {
 508     Frame* targetFrame = WebCore::targetFrame(frame, event);
 509     return targetFrame-&gt;eventHandler().handleTextInputEvent(&quot;\n&quot;_s, event, targetFrame-&gt;editor().canEditRichly() ? TextEventInputKeyboard : TextEventInputLineBreak);
 510 }
 511 
 512 static bool executeInsertNewlineInQuotedContent(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 513 {
 514     TypingCommand::insertParagraphSeparatorInQuotedContent(*frame.document());
 515     return true;
 516 }
 517 
 518 static bool executeInsertOrderedList(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 519 {
 520     ASSERT(frame.document());
 521     InsertListCommand::create(*frame.document(), InsertListCommand::Type::OrderedList)-&gt;apply();
 522     return true;
 523 }
 524 
 525 static bool executeInsertParagraph(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 526 {
 527     TypingCommand::insertParagraphSeparator(*frame.document(), 0);
 528     return true;
 529 }
 530 
 531 static bool executeInsertTab(Frame&amp; frame, Event* event, EditorCommandSource, const String&amp;)
 532 {
 533     return targetFrame(frame, event)-&gt;eventHandler().handleTextInputEvent(&quot;\t&quot;_s, event);
 534 }
 535 
 536 static bool executeInsertText(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
 537 {
 538     TypingCommand::insertText(*frame.document(), value, 0);
 539     return true;
 540 }
 541 
 542 static bool executeInsertUnorderedList(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 543 {
 544     ASSERT(frame.document());
 545     InsertListCommand::create(*frame.document(), InsertListCommand::Type::UnorderedList)-&gt;apply();
 546     return true;
 547 }
 548 
 549 static bool executeInsertNestedUnorderedList(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 550 {
 551     ASSERT(frame.document());
 552     InsertNestedListCommand::insertUnorderedList(*frame.document());
 553     return true;
 554 }
 555 
 556 static bool executeInsertNestedOrderedList(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 557 {
 558     ASSERT(frame.document());
 559     InsertNestedListCommand::insertOrderedList(*frame.document());
 560     return true;
 561 }
 562 
 563 static bool executeJustifyCenter(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 564 {
 565     return executeApplyParagraphStyle(frame, source, EditAction::Center, CSSPropertyTextAlign, &quot;center&quot;_s);
 566 }
 567 
 568 static bool executeJustifyFull(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 569 {
 570     return executeApplyParagraphStyle(frame, source, EditAction::Justify, CSSPropertyTextAlign, &quot;justify&quot;_s);
 571 }
 572 
 573 static bool executeJustifyLeft(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 574 {
 575     return executeApplyParagraphStyle(frame, source, EditAction::AlignLeft, CSSPropertyTextAlign, &quot;left&quot;_s);
 576 }
 577 
 578 static bool executeJustifyRight(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 579 {
 580     return executeApplyParagraphStyle(frame, source, EditAction::AlignRight, CSSPropertyTextAlign, &quot;right&quot;_s);
 581 }
 582 
 583 static bool executeMakeTextWritingDirectionLeftToRight(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 584 {
 585     auto style = MutableStyleProperties::create();
 586     style-&gt;setProperty(CSSPropertyUnicodeBidi, CSSValueEmbed);
 587     style-&gt;setProperty(CSSPropertyDirection, CSSValueLtr);
 588     frame.editor().applyStyle(style.ptr(), EditAction::SetInlineWritingDirection);
 589     return true;
 590 }
 591 
 592 static bool executeMakeTextWritingDirectionNatural(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 593 {
 594     auto style = MutableStyleProperties::create();
 595     style-&gt;setProperty(CSSPropertyUnicodeBidi, CSSValueNormal);
 596     frame.editor().applyStyle(style.ptr(), EditAction::SetInlineWritingDirection);
 597     return true;
 598 }
 599 
 600 static bool executeMakeTextWritingDirectionRightToLeft(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 601 {
 602     auto style = MutableStyleProperties::create();
 603     style-&gt;setProperty(CSSPropertyUnicodeBidi, CSSValueEmbed);
 604     style-&gt;setProperty(CSSPropertyDirection, CSSValueRtl);
 605     frame.editor().applyStyle(style.ptr(), EditAction::SetInlineWritingDirection);
 606     return true;
 607 }
 608 
 609 static bool executeMoveBackward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 610 {
 611     frame.selection().modify(FrameSelection::AlterationMove, DirectionBackward, CharacterGranularity, UserTriggered);
 612     return true;
 613 }
 614 
 615 static bool executeMoveBackwardAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 616 {
 617     frame.selection().modify(FrameSelection::AlterationExtend, DirectionBackward, CharacterGranularity, UserTriggered);
 618     return true;
 619 }
 620 
 621 static bool executeMoveDown(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 622 {
 623     return frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, LineGranularity, UserTriggered);
 624 }
 625 
 626 static bool executeMoveDownAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 627 {
 628     frame.selection().modify(FrameSelection::AlterationExtend, DirectionForward, LineGranularity, UserTriggered);
 629     return true;
 630 }
 631 
 632 static bool executeMoveForward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 633 {
 634     frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, CharacterGranularity, UserTriggered);
 635     return true;
 636 }
 637 
 638 static bool executeMoveForwardAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 639 {
 640     frame.selection().modify(FrameSelection::AlterationExtend, DirectionForward, CharacterGranularity, UserTriggered);
 641     return true;
 642 }
 643 
 644 static bool executeMoveLeft(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 645 {
 646     return frame.selection().modify(FrameSelection::AlterationMove, DirectionLeft, CharacterGranularity, UserTriggered);
 647 }
 648 
 649 static bool executeMoveLeftAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 650 {
 651     frame.selection().modify(FrameSelection::AlterationExtend, DirectionLeft, CharacterGranularity, UserTriggered);
 652     return true;
 653 }
 654 
 655 static bool executeMovePageDown(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 656 {
 657     unsigned distance = verticalScrollDistance(frame);
 658     if (!distance)
 659         return false;
 660     return frame.selection().modify(FrameSelection::AlterationMove, distance, FrameSelection::DirectionDown,
 661         UserTriggered, FrameSelection::AlignCursorOnScrollAlways);
 662 }
 663 
 664 static bool executeMovePageDownAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 665 {
 666     unsigned distance = verticalScrollDistance(frame);
 667     if (!distance)
 668         return false;
 669     return frame.selection().modify(FrameSelection::AlterationExtend, distance, FrameSelection::DirectionDown,
 670         UserTriggered, FrameSelection::AlignCursorOnScrollAlways);
 671 }
 672 
 673 static bool executeMovePageUp(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 674 {
 675     unsigned distance = verticalScrollDistance(frame);
 676     if (!distance)
 677         return false;
 678     return frame.selection().modify(FrameSelection::AlterationMove, distance, FrameSelection::DirectionUp,
 679         UserTriggered, FrameSelection::AlignCursorOnScrollAlways);
 680 }
 681 
 682 static bool executeMovePageUpAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 683 {
 684     unsigned distance = verticalScrollDistance(frame);
 685     if (!distance)
 686         return false;
 687     return frame.selection().modify(FrameSelection::AlterationExtend, distance, FrameSelection::DirectionUp,
 688         UserTriggered, FrameSelection::AlignCursorOnScrollAlways);
 689 }
 690 
 691 static bool executeMoveRight(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 692 {
 693     return frame.selection().modify(FrameSelection::AlterationMove, DirectionRight, CharacterGranularity, UserTriggered);
 694 }
 695 
 696 static bool executeMoveRightAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 697 {
 698     frame.selection().modify(FrameSelection::AlterationExtend, DirectionRight, CharacterGranularity, UserTriggered);
 699     return true;
 700 }
 701 
 702 static bool executeMoveToBeginningOfDocument(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 703 {
 704     frame.selection().modify(FrameSelection::AlterationMove, DirectionBackward, DocumentBoundary, UserTriggered);
 705     return true;
 706 }
 707 
 708 static bool executeMoveToBeginningOfDocumentAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 709 {
 710     frame.selection().modify(FrameSelection::AlterationExtend, DirectionBackward, DocumentBoundary, UserTriggered);
 711     return true;
 712 }
 713 
 714 static bool executeMoveToBeginningOfLine(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 715 {
 716     frame.selection().modify(FrameSelection::AlterationMove, DirectionBackward, LineBoundary, UserTriggered);
 717     return true;
 718 }
 719 
 720 static bool executeMoveToBeginningOfLineAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 721 {
 722     frame.selection().modify(FrameSelection::AlterationExtend, DirectionBackward, LineBoundary, UserTriggered);
 723     return true;
 724 }
 725 
 726 static bool executeMoveToBeginningOfParagraph(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 727 {
 728     frame.selection().modify(FrameSelection::AlterationMove, DirectionBackward, ParagraphBoundary, UserTriggered);
 729     return true;
 730 }
 731 
 732 static bool executeMoveToBeginningOfParagraphAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 733 {
 734     frame.selection().modify(FrameSelection::AlterationExtend, DirectionBackward, ParagraphBoundary, UserTriggered);
 735     return true;
 736 }
 737 
 738 static bool executeMoveToBeginningOfSentence(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 739 {
 740     frame.selection().modify(FrameSelection::AlterationMove, DirectionBackward, SentenceBoundary, UserTriggered);
 741     return true;
 742 }
 743 
 744 static bool executeMoveToBeginningOfSentenceAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 745 {
 746     frame.selection().modify(FrameSelection::AlterationExtend, DirectionBackward, SentenceBoundary, UserTriggered);
 747     return true;
 748 }
 749 
 750 static bool executeMoveToEndOfDocument(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 751 {
 752     frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, DocumentBoundary, UserTriggered);
 753     return true;
 754 }
 755 
 756 static bool executeMoveToEndOfDocumentAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 757 {
 758     frame.selection().modify(FrameSelection::AlterationExtend, DirectionForward, DocumentBoundary, UserTriggered);
 759     return true;
 760 }
 761 
 762 static bool executeMoveToEndOfSentence(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 763 {
 764     frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, SentenceBoundary, UserTriggered);
 765     return true;
 766 }
 767 
 768 static bool executeMoveToEndOfSentenceAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 769 {
 770     frame.selection().modify(FrameSelection::AlterationExtend, DirectionForward, SentenceBoundary, UserTriggered);
 771     return true;
 772 }
 773 
 774 static bool executeMoveToEndOfLine(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 775 {
 776     frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, LineBoundary, UserTriggered);
 777     return true;
 778 }
 779 
 780 static bool executeMoveToEndOfLineAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 781 {
 782     frame.selection().modify(FrameSelection::AlterationExtend, DirectionForward, LineBoundary, UserTriggered);
 783     return true;
 784 }
 785 
 786 static bool executeMoveToEndOfParagraph(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 787 {
 788     frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, ParagraphBoundary, UserTriggered);
 789     return true;
 790 }
 791 
 792 static bool executeMoveToEndOfParagraphAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 793 {
 794     frame.selection().modify(FrameSelection::AlterationExtend, DirectionForward, ParagraphBoundary, UserTriggered);
 795     return true;
 796 }
 797 
 798 static bool executeMoveParagraphBackwardAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 799 {
 800     frame.selection().modify(FrameSelection::AlterationExtend, DirectionBackward, ParagraphGranularity, UserTriggered);
 801     return true;
 802 }
 803 
 804 static bool executeMoveParagraphForwardAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 805 {
 806     frame.selection().modify(FrameSelection::AlterationExtend, DirectionForward, ParagraphGranularity, UserTriggered);
 807     return true;
 808 }
 809 
 810 static bool executeMoveUp(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 811 {
 812     return frame.selection().modify(FrameSelection::AlterationMove, DirectionBackward, LineGranularity, UserTriggered);
 813 }
 814 
 815 static bool executeMoveUpAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 816 {
 817     frame.selection().modify(FrameSelection::AlterationExtend, DirectionBackward, LineGranularity, UserTriggered);
 818     return true;
 819 }
 820 
 821 static bool executeMoveWordBackward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 822 {
 823     frame.selection().modify(FrameSelection::AlterationMove, DirectionBackward, WordGranularity, UserTriggered);
 824     return true;
 825 }
 826 
 827 static bool executeMoveWordBackwardAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 828 {
 829     frame.selection().modify(FrameSelection::AlterationExtend, DirectionBackward, WordGranularity, UserTriggered);
 830     return true;
 831 }
 832 
 833 static bool executeMoveWordForward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 834 {
 835     frame.selection().modify(FrameSelection::AlterationMove, DirectionForward, WordGranularity, UserTriggered);
 836     return true;
 837 }
 838 
 839 static bool executeMoveWordForwardAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 840 {
 841     frame.selection().modify(FrameSelection::AlterationExtend, DirectionForward, WordGranularity, UserTriggered);
 842     return true;
 843 }
 844 
 845 static bool executeMoveWordLeft(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 846 {
 847     frame.selection().modify(FrameSelection::AlterationMove, DirectionLeft, WordGranularity, UserTriggered);
 848     return true;
 849 }
 850 
 851 static bool executeMoveWordLeftAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 852 {
 853     frame.selection().modify(FrameSelection::AlterationExtend, DirectionLeft, WordGranularity, UserTriggered);
 854     return true;
 855 }
 856 
 857 static bool executeMoveWordRight(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 858 {
 859     frame.selection().modify(FrameSelection::AlterationMove, DirectionRight, WordGranularity, UserTriggered);
 860     return true;
 861 }
 862 
 863 static bool executeMoveWordRightAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 864 {
 865     frame.selection().modify(FrameSelection::AlterationExtend, DirectionRight, WordGranularity, UserTriggered);
 866     return true;
 867 }
 868 
 869 static bool executeMoveToLeftEndOfLine(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 870 {
 871     frame.selection().modify(FrameSelection::AlterationMove, DirectionLeft, LineBoundary, UserTriggered);
 872     return true;
 873 }
 874 
 875 static bool executeMoveToLeftEndOfLineAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 876 {
 877     frame.selection().modify(FrameSelection::AlterationExtend, DirectionLeft, LineBoundary, UserTriggered);
 878     return true;
 879 }
 880 
 881 static bool executeMoveToRightEndOfLine(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 882 {
 883     frame.selection().modify(FrameSelection::AlterationMove, DirectionRight, LineBoundary, UserTriggered);
 884     return true;
 885 }
 886 
 887 static bool executeMoveToRightEndOfLineAndModifySelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 888 {
 889     frame.selection().modify(FrameSelection::AlterationExtend, DirectionRight, LineBoundary, UserTriggered);
 890     return true;
 891 }
 892 
 893 static bool executeOutdent(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 894 {
 895     ASSERT(frame.document());
 896     IndentOutdentCommand::create(*frame.document(), IndentOutdentCommand::Outdent)-&gt;apply();
 897     return true;
 898 }
 899 
 900 static bool executeToggleOverwrite(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 901 {
 902     frame.editor().toggleOverwriteModeEnabled();
 903     return true;
 904 }
 905 
 906 static bool executePaste(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 907 {
 908     if (source == CommandFromMenuOrKeyBinding) {
 909         UserTypingGestureIndicator typingGestureIndicator(frame);
 910         frame.editor().paste();
 911         return true;
 912     }
 913 
 914     if (!frame.requestDOMPasteAccess())
 915         return false;
 916 
 917     frame.editor().paste();
 918     return true;
 919 }
 920 
 921 #if PLATFORM(GTK)
 922 
 923 static bool executePasteGlobalSelection(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 924 {
 925     // FIXME: This check should be in an enable function, not here.
 926     if (!frame.editor().client()-&gt;supportsGlobalSelection())
 927         return false;
 928 
 929     ASSERT_UNUSED(source, source == CommandFromMenuOrKeyBinding);
 930     UserTypingGestureIndicator typingGestureIndicator(frame);
 931     frame.editor().paste(*Pasteboard::createForGlobalSelection());
 932     return true;
 933 }
 934 
 935 #endif
 936 
 937 static bool executePasteAndMatchStyle(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 938 {
 939     if (source == CommandFromMenuOrKeyBinding) {
 940         UserTypingGestureIndicator typingGestureIndicator(frame);
 941         frame.editor().pasteAsPlainText();
 942         return true;
 943     }
 944 
 945     if (!frame.requestDOMPasteAccess())
 946         return false;
 947 
 948     frame.editor().pasteAsPlainText();
 949     return true;
 950 }
 951 
 952 static bool executePasteAsPlainText(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 953 {
 954     if (source == CommandFromMenuOrKeyBinding) {
 955         UserTypingGestureIndicator typingGestureIndicator(frame);
 956         frame.editor().pasteAsPlainText();
 957         return true;
 958     }
 959 
 960     if (!frame.requestDOMPasteAccess())
 961         return false;
 962 
 963     frame.editor().pasteAsPlainText();
 964     return true;
 965 }
 966 
 967 static bool executePasteAsQuotation(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
 968 {
 969     if (source == CommandFromMenuOrKeyBinding) {
 970         UserTypingGestureIndicator typingGestureIndicator(frame);
 971         frame.editor().pasteAsQuotation();
 972         return true;
 973     }
 974 
 975     if (!frame.requestDOMPasteAccess())
 976         return false;
 977 
 978     frame.editor().pasteAsQuotation();
 979     return true;
 980 }
 981 
 982 static bool executePrint(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 983 {
 984     Page* page = frame.page();
 985     if (!page)
 986         return false;
 987     return page-&gt;chrome().print(frame);
 988 }
 989 
 990 static bool executeRedo(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 991 {
 992     frame.editor().redo();
 993     return true;
 994 }
 995 
 996 static bool executeRemoveFormat(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
 997 {
 998     frame.editor().removeFormattingAndStyle();
 999     return true;
1000 }
1001 
1002 static bool executeScrollPageBackward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1003 {
1004     return frame.eventHandler().logicalScrollRecursively(ScrollBlockDirectionBackward, ScrollByPage);
1005 }
1006 
1007 static bool executeScrollPageForward(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1008 {
1009     return frame.eventHandler().logicalScrollRecursively(ScrollBlockDirectionForward, ScrollByPage);
1010 }
1011 
1012 static bool executeScrollLineUp(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1013 {
1014     return frame.eventHandler().scrollRecursively(ScrollUp, ScrollByLine);
1015 }
1016 
1017 static bool executeScrollLineDown(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1018 {
1019     return frame.eventHandler().scrollRecursively(ScrollDown, ScrollByLine);
1020 }
1021 
1022 static bool executeScrollToBeginningOfDocument(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1023 {
1024     return frame.eventHandler().logicalScrollRecursively(ScrollBlockDirectionBackward, ScrollByDocument);
1025 }
1026 
1027 static bool executeScrollToEndOfDocument(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1028 {
1029     return frame.eventHandler().logicalScrollRecursively(ScrollBlockDirectionForward, ScrollByDocument);
1030 }
1031 
1032 static bool executeSelectAll(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1033 {
1034     frame.selection().selectAll();
1035     return true;
1036 }
1037 
1038 static bool executeSelectLine(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1039 {
1040     return expandSelectionToGranularity(frame, LineGranularity);
1041 }
1042 
1043 static bool executeSelectParagraph(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1044 {
1045     return expandSelectionToGranularity(frame, ParagraphGranularity);
1046 }
1047 
1048 static bool executeSelectSentence(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1049 {
1050     return expandSelectionToGranularity(frame, SentenceGranularity);
1051 }
1052 
1053 static bool executeSelectToMark(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1054 {
1055     RefPtr&lt;Range&gt; mark = frame.editor().mark().toNormalizedRange();
1056     RefPtr&lt;Range&gt; selection = frame.editor().selectedRange();
1057     if (!mark || !selection) {
1058         PAL::systemBeep();
1059         return false;
1060     }
1061     frame.selection().setSelectedRange(unionDOMRanges(*mark, *selection).get(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::Yes);
1062     return true;
1063 }
1064 
1065 static bool executeSelectWord(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1066 {
1067     return expandSelectionToGranularity(frame, WordGranularity);
1068 }
1069 
1070 static bool executeSetMark(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1071 {
1072     frame.editor().setMark(frame.selection().selection());
1073     return true;
1074 }
1075 
1076 static TextDecorationChange textDecorationChangeForToggling(Editor&amp; editor, CSSPropertyID propertyID, const char* onValue)
1077 {
1078     return isStylePresent(editor, propertyID, onValue) ? TextDecorationChange::Remove : TextDecorationChange::Add;
1079 }
1080 
1081 static bool executeStrikethrough(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
1082 {
1083     Ref&lt;EditingStyle&gt; style = EditingStyle::create();
1084     style-&gt;setStrikeThroughChange(textDecorationChangeForToggling(frame.editor(), CSSPropertyWebkitTextDecorationsInEffect, &quot;line-through&quot;_s));
1085     return applyCommandToFrame(frame, source, EditAction::StrikeThrough, WTFMove(style));
1086 }
1087 
1088 static bool executeStyleWithCSS(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
1089 {
1090     frame.editor().setShouldStyleWithCSS(!equalLettersIgnoringASCIICase(value, &quot;false&quot;));
1091     return true;
1092 }
1093 
1094 static bool executeUseCSS(Frame&amp; frame, Event*, EditorCommandSource, const String&amp; value)
1095 {
1096     frame.editor().setShouldStyleWithCSS(equalLettersIgnoringASCIICase(value, &quot;false&quot;));
1097     return true;
1098 }
1099 
1100 static bool executeSubscript(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
1101 {
1102     return executeToggleStyle(frame, source, EditAction::Subscript, CSSPropertyVerticalAlign, &quot;baseline&quot;_s, &quot;sub&quot;_s);
1103 }
1104 
1105 static bool executeSuperscript(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
1106 {
1107     return executeToggleStyle(frame, source, EditAction::Superscript, CSSPropertyVerticalAlign, &quot;baseline&quot;_s, &quot;super&quot;_s);
1108 }
1109 
1110 static bool executeSwapWithMark(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1111 {
1112     Ref&lt;Frame&gt; protector(frame);
1113     const VisibleSelection&amp; mark = frame.editor().mark();
1114     const VisibleSelection&amp; selection = frame.selection().selection();
1115     if (mark.isNone() || selection.isNone()) {
1116         PAL::systemBeep();
1117         return false;
1118     }
1119     frame.selection().setSelection(mark);
1120     frame.editor().setMark(selection);
1121     return true;
1122 }
1123 
1124 #if PLATFORM(COCOA)
1125 
1126 static bool executeTakeFindStringFromSelection(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1127 {
1128     frame.editor().takeFindStringFromSelection();
1129     return true;
1130 }
1131 
1132 #endif // PLATFORM(COCOA)
1133 
1134 static bool executeToggleBold(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
1135 {
1136     return executeToggleStyle(frame, source, EditAction::Bold, CSSPropertyFontWeight, &quot;normal&quot;_s, &quot;bold&quot;_s);
1137 }
1138 
1139 static bool executeToggleItalic(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
1140 {
1141     return executeToggleStyle(frame, source, EditAction::Italics, CSSPropertyFontStyle, &quot;normal&quot;_s, &quot;italic&quot;_s);
1142 }
1143 
1144 static bool executeTranspose(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1145 {
1146     frame.editor().transpose();
1147     return true;
1148 }
1149 
1150 static bool executeUnderline(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
1151 {
1152     Ref&lt;EditingStyle&gt; style = EditingStyle::create();
1153     TextDecorationChange change = textDecorationChangeForToggling(frame.editor(), CSSPropertyWebkitTextDecorationsInEffect, &quot;underline&quot;_s);
1154     style-&gt;setUnderlineChange(change);
1155     return applyCommandToFrame(frame, source, EditAction::Underline, WTFMove(style));
1156 }
1157 
1158 static bool executeUndo(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1159 {
1160     frame.editor().undo();
1161     return true;
1162 }
1163 
1164 static bool executeUnlink(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1165 {
1166     ASSERT(frame.document());
1167     UnlinkCommand::create(*frame.document())-&gt;apply();
1168     return true;
1169 }
1170 
1171 static bool executeUnscript(Frame&amp; frame, Event*, EditorCommandSource source, const String&amp;)
1172 {
1173     return executeApplyStyle(frame, source, EditAction::Unscript, CSSPropertyVerticalAlign, &quot;baseline&quot;_s);
1174 }
1175 
1176 static bool executeUnselect(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1177 {
1178     frame.selection().clear();
1179     return true;
1180 }
1181 
1182 static bool executeYank(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1183 {
1184     frame.editor().insertTextWithoutSendingTextEvent(frame.editor().killRing().yank(), false, 0);
1185     frame.editor().killRing().setToYankedState();
1186     return true;
1187 }
1188 
1189 static bool executeYankAndSelect(Frame&amp; frame, Event*, EditorCommandSource, const String&amp;)
1190 {
1191     frame.editor().insertTextWithoutSendingTextEvent(frame.editor().killRing().yank(), true, 0);
1192     frame.editor().killRing().setToYankedState();
1193     return true;
1194 }
1195 
1196 // Supported functions
1197 
1198 static bool supported(Frame*)
1199 {
1200     return true;
1201 }
1202 
1203 static bool supportedFromMenuOrKeyBinding(Frame*)
1204 {
1205     return false;
1206 }
1207 
1208 static bool defaultValueForSupportedCopyCut(Frame&amp; frame)
1209 {
1210     auto&amp; settings = frame.settings();
1211     if (settings.javaScriptCanAccessClipboard())
1212         return true;
1213 
1214     switch (settings.clipboardAccessPolicy()) {
1215     case ClipboardAccessPolicy::Allow:
1216     case ClipboardAccessPolicy::RequiresUserGesture:
1217         return true;
1218     case ClipboardAccessPolicy::Deny:
1219         return false;
1220     }
1221 
1222     ASSERT_NOT_REACHED();
1223     return false;
1224 }
1225 
1226 static bool supportedCopyCut(Frame* frame)
1227 {
1228     if (!frame)
1229         return false;
1230 
1231     bool defaultValue = defaultValueForSupportedCopyCut(*frame);
1232 
1233     EditorClient* client = frame-&gt;editor().client();
1234     return client ? client-&gt;canCopyCut(frame, defaultValue) : defaultValue;
1235 }
1236 
1237 static bool defaultValueForSupportedPaste(Frame&amp; frame)
1238 {
1239     auto&amp; settings = frame.settings();
1240     if (settings.javaScriptCanAccessClipboard() &amp;&amp; settings.DOMPasteAllowed())
1241         return true;
1242 
1243     return settings.domPasteAccessRequestsEnabled();
1244 }
1245 
1246 static bool supportedPaste(Frame* frame)
1247 {
1248     if (!frame)
1249         return false;
1250 
1251     bool defaultValue = defaultValueForSupportedPaste(*frame);
1252 
1253     EditorClient* client = frame-&gt;editor().client();
1254     return client ? client-&gt;canPaste(frame, defaultValue) : defaultValue;
1255 }
1256 
1257 // Enabled functions
1258 
1259 static bool enabled(Frame&amp;, Event*, EditorCommandSource)
1260 {
1261     return true;
1262 }
1263 
1264 static bool enabledVisibleSelection(Frame&amp; frame, Event* event, EditorCommandSource)
1265 {
1266     // The term &quot;visible&quot; here includes a caret in editable text or a range in any text.
1267     const VisibleSelection&amp; selection = frame.editor().selectionForCommand(event);
1268     return (selection.isCaret() &amp;&amp; selection.isContentEditable()) || selection.isRange();
1269 }
1270 
1271 static bool caretBrowsingEnabled(Frame&amp; frame)
1272 {
1273     return frame.settings().caretBrowsingEnabled();
1274 }
1275 
1276 static EditorCommandSource dummyEditorCommandSource = static_cast&lt;EditorCommandSource&gt;(0);
1277 
1278 static bool enabledVisibleSelectionOrCaretBrowsing(Frame&amp; frame, Event* event, EditorCommandSource)
1279 {
1280     // The EditorCommandSource parameter is unused in enabledVisibleSelection, so just pass a dummy variable
1281     return caretBrowsingEnabled(frame) || enabledVisibleSelection(frame, event, dummyEditorCommandSource);
1282 }
1283 
1284 static bool enabledVisibleSelectionAndMark(Frame&amp; frame, Event* event, EditorCommandSource)
1285 {
1286     const VisibleSelection&amp; selection = frame.editor().selectionForCommand(event);
1287     return ((selection.isCaret() &amp;&amp; selection.isContentEditable()) || selection.isRange())
1288         &amp;&amp; frame.editor().mark().isCaretOrRange();
1289 }
1290 
1291 static bool enableCaretInEditableText(Frame&amp; frame, Event* event, EditorCommandSource)
1292 {
1293     const VisibleSelection&amp; selection = frame.editor().selectionForCommand(event);
1294     return selection.isCaret() &amp;&amp; selection.isContentEditable();
1295 }
1296 
1297 static bool allowCopyCutFromDOM(Frame&amp; frame)
1298 {
1299     auto&amp; settings = frame.settings();
1300     if (settings.javaScriptCanAccessClipboard())
1301         return true;
1302 
1303     switch (settings.clipboardAccessPolicy()) {
1304     case ClipboardAccessPolicy::Allow:
1305         return true;
1306     case ClipboardAccessPolicy::Deny:
1307         return false;
1308     case ClipboardAccessPolicy::RequiresUserGesture:
1309         return UserGestureIndicator::processingUserGesture();
1310     }
1311 
1312     ASSERT_NOT_REACHED();
1313     return false;
1314 }
1315 
1316 static bool enabledCopy(Frame&amp; frame, Event*, EditorCommandSource source)
1317 {
1318     switch (source) {
1319     case CommandFromMenuOrKeyBinding:
1320         return frame.editor().canDHTMLCopy() || frame.editor().canCopy();
1321     case CommandFromDOM:
1322     case CommandFromDOMWithUserInterface:
1323         return allowCopyCutFromDOM(frame) &amp;&amp; (frame.editor().canDHTMLCopy() || frame.editor().canCopy());
1324     }
1325     ASSERT_NOT_REACHED();
1326     return false;
1327 }
1328 
1329 static bool enabledCut(Frame&amp; frame, Event*, EditorCommandSource source)
1330 {
1331     switch (source) {
1332     case CommandFromMenuOrKeyBinding:
1333         return frame.editor().canDHTMLCut() || frame.editor().canCut();
1334     case CommandFromDOM:
1335     case CommandFromDOMWithUserInterface:
1336         return allowCopyCutFromDOM(frame) &amp;&amp; (frame.editor().canDHTMLCut() || frame.editor().canCut());
1337     }
1338     ASSERT_NOT_REACHED();
1339     return false;
1340 }
1341 
1342 static bool enabledClearText(Frame&amp; frame, Event*, EditorCommandSource)
1343 {
1344     UNUSED_PARAM(frame);
1345     return false;
1346 }
1347 
1348 static bool enabledInEditableText(Frame&amp; frame, Event* event, EditorCommandSource)
1349 {
1350     return frame.editor().selectionForCommand(event).rootEditableElement();
1351 }
1352 
1353 static bool enabledDelete(Frame&amp; frame, Event* event, EditorCommandSource source)
1354 {
1355     switch (source) {
1356     case CommandFromMenuOrKeyBinding:
1357         return frame.editor().canDelete();
1358     case CommandFromDOM:
1359     case CommandFromDOMWithUserInterface:
1360         // &quot;Delete&quot; from DOM is like delete/backspace keypress, affects selected range if non-empty,
1361         // otherwise removes a character
1362         return enabledInEditableText(frame, event, source);
1363     }
1364     ASSERT_NOT_REACHED();
1365     return false;
1366 }
1367 
1368 static bool enabledInEditableTextOrCaretBrowsing(Frame&amp; frame, Event* event, EditorCommandSource)
1369 {
1370     // The EditorCommandSource parameter is unused in enabledInEditableText, so just pass a dummy variable
1371     return caretBrowsingEnabled(frame) || enabledInEditableText(frame, event, dummyEditorCommandSource);
1372 }
1373 
1374 static bool enabledInRichlyEditableText(Frame&amp; frame, Event*, EditorCommandSource)
1375 {
1376     const VisibleSelection&amp; selection = frame.selection().selection();
1377     return selection.isCaretOrRange() &amp;&amp; selection.isContentRichlyEditable() &amp;&amp; selection.rootEditableElement();
1378 }
1379 
1380 static bool allowPasteFromDOM(Frame&amp; frame)
1381 {
1382     auto&amp; settings = frame.settings();
1383     if (settings.javaScriptCanAccessClipboard() &amp;&amp; settings.DOMPasteAllowed())
1384         return true;
1385 
1386     return settings.domPasteAccessRequestsEnabled() &amp;&amp; UserGestureIndicator::processingUserGesture();
1387 }
1388 
1389 static bool enabledPaste(Frame&amp; frame, Event*, EditorCommandSource source)
1390 {
1391     switch (source) {
1392     case CommandFromMenuOrKeyBinding:
1393         return frame.editor().canDHTMLPaste() || frame.editor().canPaste();
1394     case CommandFromDOM:
1395     case CommandFromDOMWithUserInterface:
1396         return allowPasteFromDOM(frame) &amp;&amp; (frame.editor().canDHTMLPaste() || frame.editor().canPaste());
1397     }
1398     ASSERT_NOT_REACHED();
1399     return false;
1400 }
1401 
1402 static bool enabledRangeInEditableText(Frame&amp; frame, Event*, EditorCommandSource)
1403 {
1404     return frame.selection().isRange() &amp;&amp; frame.selection().selection().isContentEditable();
1405 }
1406 
1407 static bool enabledRangeInRichlyEditableText(Frame&amp; frame, Event*, EditorCommandSource)
1408 {
1409     return frame.selection().isRange() &amp;&amp; frame.selection().selection().isContentRichlyEditable();
1410 }
1411 
1412 static bool enabledRedo(Frame&amp; frame, Event*, EditorCommandSource)
1413 {
1414     return frame.editor().canRedo();
1415 }
1416 
1417 #if PLATFORM(COCOA)
1418 
1419 static bool enabledTakeFindStringFromSelection(Frame&amp; frame, Event*, EditorCommandSource)
1420 {
1421     return frame.editor().canCopyExcludingStandaloneImages();
1422 }
1423 
1424 #endif // PLATFORM(COCOA)
1425 
1426 static bool enabledUndo(Frame&amp; frame, Event*, EditorCommandSource)
1427 {
1428     return frame.editor().canUndo();
1429 }
1430 
1431 static bool enabledInRichlyEditableTextWithEditableImagesEnabled(Frame&amp; frame, Event* event, EditorCommandSource source)
1432 {
1433     if (!frame.settings().editableImagesEnabled())
1434         return false;
1435     return enabledInRichlyEditableText(frame, event, source);
1436 }
1437 
1438 // State functions
1439 
1440 static TriState stateNone(Frame&amp;, Event*)
1441 {
1442     return FalseTriState;
1443 }
1444 
1445 static TriState stateBold(Frame&amp; frame, Event*)
1446 {
1447     return stateStyle(frame, CSSPropertyFontWeight, &quot;bold&quot;_s);
1448 }
1449 
1450 static TriState stateItalic(Frame&amp; frame, Event*)
1451 {
1452     return stateStyle(frame, CSSPropertyFontStyle, &quot;italic&quot;_s);
1453 }
1454 
1455 static TriState stateOrderedList(Frame&amp; frame, Event*)
1456 {
1457     return frame.editor().selectionOrderedListState();
1458 }
1459 
1460 static TriState stateStrikethrough(Frame&amp; frame, Event*)
1461 {
1462     return stateStyle(frame, CSSPropertyWebkitTextDecorationsInEffect, &quot;line-through&quot;_s);
1463 }
1464 
1465 static TriState stateStyleWithCSS(Frame&amp; frame, Event*)
1466 {
1467     return frame.editor().shouldStyleWithCSS() ? TrueTriState : FalseTriState;
1468 }
1469 
1470 static TriState stateSubscript(Frame&amp; frame, Event*)
1471 {
1472     return stateStyle(frame, CSSPropertyVerticalAlign, &quot;sub&quot;_s);
1473 }
1474 
1475 static TriState stateSuperscript(Frame&amp; frame, Event*)
1476 {
1477     return stateStyle(frame, CSSPropertyVerticalAlign, &quot;super&quot;_s);
1478 }
1479 
1480 static TriState stateTextWritingDirectionLeftToRight(Frame&amp; frame, Event*)
1481 {
1482     return stateTextWritingDirection(frame, WritingDirection::LeftToRight);
1483 }
1484 
1485 static TriState stateTextWritingDirectionNatural(Frame&amp; frame, Event*)
1486 {
1487     return stateTextWritingDirection(frame, WritingDirection::Natural);
1488 }
1489 
1490 static TriState stateTextWritingDirectionRightToLeft(Frame&amp; frame, Event*)
1491 {
1492     return stateTextWritingDirection(frame, WritingDirection::RightToLeft);
1493 }
1494 
1495 static TriState stateUnderline(Frame&amp; frame, Event*)
1496 {
1497     return stateStyle(frame, CSSPropertyWebkitTextDecorationsInEffect, &quot;underline&quot;_s);
1498 }
1499 
1500 static TriState stateUnorderedList(Frame&amp; frame, Event*)
1501 {
1502     return frame.editor().selectionUnorderedListState();
1503 }
1504 
1505 static TriState stateJustifyCenter(Frame&amp; frame, Event*)
1506 {
1507     return stateStyle(frame, CSSPropertyTextAlign, &quot;center&quot;_s);
1508 }
1509 
1510 static TriState stateJustifyFull(Frame&amp; frame, Event*)
1511 {
1512     return stateStyle(frame, CSSPropertyTextAlign, &quot;justify&quot;_s);
1513 }
1514 
1515 static TriState stateJustifyLeft(Frame&amp; frame, Event*)
1516 {
1517     return stateStyle(frame, CSSPropertyTextAlign, &quot;left&quot;_s);
1518 }
1519 
1520 static TriState stateJustifyRight(Frame&amp; frame, Event*)
1521 {
1522     return stateStyle(frame, CSSPropertyTextAlign, &quot;right&quot;_s);
1523 }
1524 
1525 // Value functions
1526 
1527 static String valueNull(Frame&amp;, Event*)
1528 {
1529     return String();
1530 }
1531 
1532 static String valueBackColor(Frame&amp; frame, Event*)
1533 {
1534     return valueStyle(frame, CSSPropertyBackgroundColor);
1535 }
1536 
1537 static String valueDefaultParagraphSeparator(Frame&amp; frame, Event*)
1538 {
1539     switch (frame.editor().defaultParagraphSeparator()) {
1540     case EditorParagraphSeparatorIsDiv:
1541         return divTag-&gt;localName();
1542     case EditorParagraphSeparatorIsP:
1543         return pTag-&gt;localName();
1544     }
1545 
1546     ASSERT_NOT_REACHED();
1547     return String();
1548 }
1549 
1550 static String valueFontName(Frame&amp; frame, Event*)
1551 {
1552     return valueStyle(frame, CSSPropertyFontFamily);
1553 }
1554 
1555 static String valueFontSize(Frame&amp; frame, Event*)
1556 {
1557     return valueStyle(frame, CSSPropertyFontSize);
1558 }
1559 
1560 static String valueFontSizeDelta(Frame&amp; frame, Event*)
1561 {
1562     return valueStyle(frame, CSSPropertyWebkitFontSizeDelta);
1563 }
1564 
1565 static String valueForeColor(Frame&amp; frame, Event*)
1566 {
1567     return valueStyle(frame, CSSPropertyColor);
1568 }
1569 
1570 static String valueFormatBlock(Frame&amp; frame, Event*)
1571 {
1572     const VisibleSelection&amp; selection = frame.selection().selection();
1573     if (selection.isNoneOrOrphaned() || !selection.isContentEditable())
1574         return emptyString();
1575     Element* formatBlockElement = FormatBlockCommand::elementForFormatBlockCommand(selection.firstRange().get());
1576     if (!formatBlockElement)
1577         return emptyString();
1578     return formatBlockElement-&gt;localName();
1579 }
1580 
1581 // allowExecutionWhenDisabled functions
1582 
1583 static bool allowExecutionWhenDisabled(Frame&amp;, EditorCommandSource)
1584 {
1585     return true;
1586 }
1587 
1588 static bool doNotAllowExecutionWhenDisabled(Frame&amp;, EditorCommandSource)
1589 {
1590     return false;
1591 }
1592 
1593 static bool allowExecutionWhenDisabledCopyCut(Frame&amp;, EditorCommandSource source)
1594 {
1595     switch (source) {
1596     case CommandFromMenuOrKeyBinding:
1597         return true;
1598     case CommandFromDOM:
1599     case CommandFromDOMWithUserInterface:
1600         return false;
1601     }
1602 
1603     ASSERT_NOT_REACHED();
1604     return false;
1605 }
1606 
1607 static bool allowExecutionWhenDisabledPaste(Frame&amp; frame, EditorCommandSource)
1608 {
1609     if (frame.mainFrame().loader().shouldSuppressTextInputFromEditing())
1610         return false;
1611     return true;
1612 }
1613 
1614 // Map of functions
1615 
1616 struct CommandEntry {
1617     const char* name;
1618     EditorInternalCommand command;
1619 };
1620 
1621 static const CommandMap&amp; createCommandMap()
1622 {
1623     static const CommandEntry commands[] = {
1624         { &quot;AlignCenter&quot;, { executeJustifyCenter, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1625         { &quot;AlignJustified&quot;, { executeJustifyFull, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1626         { &quot;AlignLeft&quot;, { executeJustifyLeft, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1627         { &quot;AlignRight&quot;, { executeJustifyRight, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1628         { &quot;BackColor&quot;, { executeBackColor, supported, enabledInRichlyEditableText, stateNone, valueBackColor, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1629         { &quot;Bold&quot;, { executeToggleBold, supported, enabledInRichlyEditableText, stateBold, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1630         { &quot;ClearText&quot;, { executeClearText, supported, enabledClearText, stateNone, valueNull, notTextInsertion, allowExecutionWhenDisabled } },
1631         { &quot;Copy&quot;, { executeCopy, supportedCopyCut, enabledCopy, stateNone, valueNull, notTextInsertion, allowExecutionWhenDisabledCopyCut } },
1632         { &quot;CreateLink&quot;, { executeCreateLink, supported, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1633         { &quot;Cut&quot;, { executeCut, supportedCopyCut, enabledCut, stateNone, valueNull, notTextInsertion, allowExecutionWhenDisabledCopyCut } },
1634         { &quot;DefaultParagraphSeparator&quot;, { executeDefaultParagraphSeparator, supported, enabled, stateNone, valueDefaultParagraphSeparator, notTextInsertion, doNotAllowExecutionWhenDisabled} },
1635         { &quot;Delete&quot;, { executeDelete, supported, enabledDelete, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1636         { &quot;DeleteBackward&quot;, { executeDeleteBackward, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1637         { &quot;DeleteBackwardByDecomposingPreviousCharacter&quot;, { executeDeleteBackwardByDecomposingPreviousCharacter, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1638         { &quot;DeleteForward&quot;, { executeDeleteForward, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1639         { &quot;DeleteToBeginningOfLine&quot;, { executeDeleteToBeginningOfLine, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1640         { &quot;DeleteToBeginningOfParagraph&quot;, { executeDeleteToBeginningOfParagraph, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1641         { &quot;DeleteToEndOfLine&quot;, { executeDeleteToEndOfLine, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1642         { &quot;DeleteToEndOfParagraph&quot;, { executeDeleteToEndOfParagraph, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1643         { &quot;DeleteToMark&quot;, { executeDeleteToMark, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1644         { &quot;DeleteWordBackward&quot;, { executeDeleteWordBackward, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1645         { &quot;DeleteWordForward&quot;, { executeDeleteWordForward, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1646         { &quot;FindString&quot;, { executeFindString, supported, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1647         { &quot;FontName&quot;, { executeFontName, supported, enabledInEditableText, stateNone, valueFontName, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1648         { &quot;FontSize&quot;, { executeFontSize, supported, enabledInEditableText, stateNone, valueFontSize, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1649         { &quot;FontSizeDelta&quot;, { executeFontSizeDelta, supported, enabledInEditableText, stateNone, valueFontSizeDelta, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1650         { &quot;ForeColor&quot;, { executeForeColor, supported, enabledInRichlyEditableText, stateNone, valueForeColor, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1651         { &quot;FormatBlock&quot;, { executeFormatBlock, supported, enabledInRichlyEditableText, stateNone, valueFormatBlock, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1652         { &quot;ForwardDelete&quot;, { executeForwardDelete, supported, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1653         { &quot;HiliteColor&quot;, { executeBackColor, supported, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1654         { &quot;IgnoreSpelling&quot;, { executeIgnoreSpelling, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1655         { &quot;Indent&quot;, { executeIndent, supported, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1656         { &quot;InsertBacktab&quot;, { executeInsertBacktab, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, isTextInsertion, doNotAllowExecutionWhenDisabled } },
1657         { &quot;InsertEditableImage&quot;, { executeInsertEditableImage, supported, enabledInRichlyEditableTextWithEditableImagesEnabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1658         { &quot;InsertHTML&quot;, { executeInsertHTML, supported, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1659         { &quot;InsertHorizontalRule&quot;, { executeInsertHorizontalRule, supported, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1660         { &quot;InsertImage&quot;, { executeInsertImage, supported, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1661         { &quot;InsertLineBreak&quot;, { executeInsertLineBreak, supported, enabledInEditableText, stateNone, valueNull, isTextInsertion, doNotAllowExecutionWhenDisabled } },
1662         { &quot;InsertNewline&quot;, { executeInsertNewline, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, isTextInsertion, doNotAllowExecutionWhenDisabled } },
1663         { &quot;InsertNewlineInQuotedContent&quot;, { executeInsertNewlineInQuotedContent, supported, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1664         { &quot;InsertOrderedList&quot;, { executeInsertOrderedList, supported, enabledInRichlyEditableText, stateOrderedList, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1665         { &quot;InsertNestedOrderedList&quot;, { executeInsertNestedOrderedList, supported, enabledInRichlyEditableText, stateOrderedList, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1666         { &quot;InsertParagraph&quot;, { executeInsertParagraph, supported, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1667         { &quot;InsertTab&quot;, { executeInsertTab, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, isTextInsertion, doNotAllowExecutionWhenDisabled } },
1668         { &quot;InsertText&quot;, { executeInsertText, supported, enabledInEditableText, stateNone, valueNull, isTextInsertion, doNotAllowExecutionWhenDisabled } },
1669         { &quot;InsertUnorderedList&quot;, { executeInsertUnorderedList, supported, enabledInRichlyEditableText, stateUnorderedList, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1670         { &quot;InsertNestedUnorderedList&quot;, { executeInsertNestedUnorderedList, supported, enabledInRichlyEditableText, stateUnorderedList, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1671         { &quot;Italic&quot;, { executeToggleItalic, supported, enabledInRichlyEditableText, stateItalic, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1672         { &quot;JustifyCenter&quot;, { executeJustifyCenter, supported, enabledInRichlyEditableText, stateJustifyCenter, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1673         { &quot;JustifyFull&quot;, { executeJustifyFull, supported, enabledInRichlyEditableText, stateJustifyFull, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1674         { &quot;JustifyLeft&quot;, { executeJustifyLeft, supported, enabledInRichlyEditableText, stateJustifyLeft, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1675         { &quot;JustifyNone&quot;, { executeJustifyLeft, supported, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1676         { &quot;JustifyRight&quot;, { executeJustifyRight, supported, enabledInRichlyEditableText, stateJustifyRight, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1677         { &quot;MakeTextWritingDirectionLeftToRight&quot;, { executeMakeTextWritingDirectionLeftToRight, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateTextWritingDirectionLeftToRight, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1678         { &quot;MakeTextWritingDirectionNatural&quot;, { executeMakeTextWritingDirectionNatural, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateTextWritingDirectionNatural, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1679         { &quot;MakeTextWritingDirectionRightToLeft&quot;, { executeMakeTextWritingDirectionRightToLeft, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateTextWritingDirectionRightToLeft, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1680         { &quot;MoveBackward&quot;, { executeMoveBackward, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1681         { &quot;MoveBackwardAndModifySelection&quot;, { executeMoveBackwardAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1682         { &quot;MoveDown&quot;, { executeMoveDown, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1683         { &quot;MoveDownAndModifySelection&quot;, { executeMoveDownAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1684         { &quot;MoveForward&quot;, { executeMoveForward, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1685         { &quot;MoveForwardAndModifySelection&quot;, { executeMoveForwardAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1686         { &quot;MoveLeft&quot;, { executeMoveLeft, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1687         { &quot;MoveLeftAndModifySelection&quot;, { executeMoveLeftAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1688         { &quot;MovePageDown&quot;, { executeMovePageDown, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1689         { &quot;MovePageDownAndModifySelection&quot;, { executeMovePageDownAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1690         { &quot;MovePageUp&quot;, { executeMovePageUp, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1691         { &quot;MovePageUpAndModifySelection&quot;, { executeMovePageUpAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1692         { &quot;MoveParagraphBackwardAndModifySelection&quot;, { executeMoveParagraphBackwardAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1693         { &quot;MoveParagraphForwardAndModifySelection&quot;, { executeMoveParagraphForwardAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1694         { &quot;MoveRight&quot;, { executeMoveRight, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1695         { &quot;MoveRightAndModifySelection&quot;, { executeMoveRightAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1696         { &quot;MoveToBeginningOfDocument&quot;, { executeMoveToBeginningOfDocument, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1697         { &quot;MoveToBeginningOfDocumentAndModifySelection&quot;, { executeMoveToBeginningOfDocumentAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1698         { &quot;MoveToBeginningOfLine&quot;, { executeMoveToBeginningOfLine, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1699         { &quot;MoveToBeginningOfLineAndModifySelection&quot;, { executeMoveToBeginningOfLineAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1700         { &quot;MoveToBeginningOfParagraph&quot;, { executeMoveToBeginningOfParagraph, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1701         { &quot;MoveToBeginningOfParagraphAndModifySelection&quot;, { executeMoveToBeginningOfParagraphAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1702         { &quot;MoveToBeginningOfSentence&quot;, { executeMoveToBeginningOfSentence, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1703         { &quot;MoveToBeginningOfSentenceAndModifySelection&quot;, { executeMoveToBeginningOfSentenceAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1704         { &quot;MoveToEndOfDocument&quot;, { executeMoveToEndOfDocument, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1705         { &quot;MoveToEndOfDocumentAndModifySelection&quot;, { executeMoveToEndOfDocumentAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1706         { &quot;MoveToEndOfLine&quot;, { executeMoveToEndOfLine, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1707         { &quot;MoveToEndOfLineAndModifySelection&quot;, { executeMoveToEndOfLineAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1708         { &quot;MoveToEndOfParagraph&quot;, { executeMoveToEndOfParagraph, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1709         { &quot;MoveToEndOfParagraphAndModifySelection&quot;, { executeMoveToEndOfParagraphAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1710         { &quot;MoveToEndOfSentence&quot;, { executeMoveToEndOfSentence, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1711         { &quot;MoveToEndOfSentenceAndModifySelection&quot;, { executeMoveToEndOfSentenceAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1712         { &quot;MoveToLeftEndOfLine&quot;, { executeMoveToLeftEndOfLine, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1713         { &quot;MoveToLeftEndOfLineAndModifySelection&quot;, { executeMoveToLeftEndOfLineAndModifySelection, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1714         { &quot;MoveToRightEndOfLine&quot;, { executeMoveToRightEndOfLine, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1715         { &quot;MoveToRightEndOfLineAndModifySelection&quot;, { executeMoveToRightEndOfLineAndModifySelection, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1716         { &quot;MoveUp&quot;, { executeMoveUp, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1717         { &quot;MoveUpAndModifySelection&quot;, { executeMoveUpAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1718         { &quot;MoveWordBackward&quot;, { executeMoveWordBackward, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1719         { &quot;MoveWordBackwardAndModifySelection&quot;, { executeMoveWordBackwardAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1720         { &quot;MoveWordForward&quot;, { executeMoveWordForward, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1721         { &quot;MoveWordForwardAndModifySelection&quot;, { executeMoveWordForwardAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1722         { &quot;MoveWordLeft&quot;, { executeMoveWordLeft, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1723         { &quot;MoveWordLeftAndModifySelection&quot;, { executeMoveWordLeftAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1724         { &quot;MoveWordRight&quot;, { executeMoveWordRight, supportedFromMenuOrKeyBinding, enabledInEditableTextOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1725         { &quot;MoveWordRightAndModifySelection&quot;, { executeMoveWordRightAndModifySelection, supportedFromMenuOrKeyBinding, enabledVisibleSelectionOrCaretBrowsing, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1726         { &quot;Outdent&quot;, { executeOutdent, supported, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1727         { &quot;OverWrite&quot;, { executeToggleOverwrite, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1728         { &quot;Paste&quot;, { executePaste, supportedPaste, enabledPaste, stateNone, valueNull, notTextInsertion, allowExecutionWhenDisabledPaste } },
1729         { &quot;PasteAndMatchStyle&quot;, { executePasteAndMatchStyle, supportedPaste, enabledPaste, stateNone, valueNull, notTextInsertion, allowExecutionWhenDisabledPaste } },
1730         { &quot;PasteAsPlainText&quot;, { executePasteAsPlainText, supportedPaste, enabledPaste, stateNone, valueNull, notTextInsertion, allowExecutionWhenDisabledPaste } },
1731         { &quot;PasteAsQuotation&quot;, { executePasteAsQuotation, supportedPaste, enabledPaste, stateNone, valueNull, notTextInsertion, allowExecutionWhenDisabledPaste } },
1732         { &quot;Print&quot;, { executePrint, supported, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1733         { &quot;Redo&quot;, { executeRedo, supported, enabledRedo, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1734         { &quot;RemoveFormat&quot;, { executeRemoveFormat, supported, enabledRangeInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1735         { &quot;ScrollPageBackward&quot;, { executeScrollPageBackward, supportedFromMenuOrKeyBinding, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1736         { &quot;ScrollPageForward&quot;, { executeScrollPageForward, supportedFromMenuOrKeyBinding, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1737         { &quot;ScrollLineUp&quot;, { executeScrollLineUp, supportedFromMenuOrKeyBinding, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1738         { &quot;ScrollLineDown&quot;, { executeScrollLineDown, supportedFromMenuOrKeyBinding, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1739         { &quot;ScrollToBeginningOfDocument&quot;, { executeScrollToBeginningOfDocument, supportedFromMenuOrKeyBinding, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1740         { &quot;ScrollToEndOfDocument&quot;, { executeScrollToEndOfDocument, supportedFromMenuOrKeyBinding, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1741         { &quot;SelectAll&quot;, { executeSelectAll, supported, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1742         { &quot;SelectLine&quot;, { executeSelectLine, supportedFromMenuOrKeyBinding, enabledVisibleSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1743         { &quot;SelectParagraph&quot;, { executeSelectParagraph, supportedFromMenuOrKeyBinding, enabledVisibleSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1744         { &quot;SelectSentence&quot;, { executeSelectSentence, supportedFromMenuOrKeyBinding, enabledVisibleSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1745         { &quot;SelectToMark&quot;, { executeSelectToMark, supportedFromMenuOrKeyBinding, enabledVisibleSelectionAndMark, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1746         { &quot;SelectWord&quot;, { executeSelectWord, supportedFromMenuOrKeyBinding, enabledVisibleSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1747         { &quot;SetMark&quot;, { executeSetMark, supportedFromMenuOrKeyBinding, enabledVisibleSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1748         { &quot;Strikethrough&quot;, { executeStrikethrough, supported, enabledInRichlyEditableText, stateStrikethrough, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1749         { &quot;StyleWithCSS&quot;, { executeStyleWithCSS, supported, enabled, stateStyleWithCSS, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1750         { &quot;Subscript&quot;, { executeSubscript, supported, enabledInRichlyEditableText, stateSubscript, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1751         { &quot;Superscript&quot;, { executeSuperscript, supported, enabledInRichlyEditableText, stateSuperscript, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1752         { &quot;SwapWithMark&quot;, { executeSwapWithMark, supportedFromMenuOrKeyBinding, enabledVisibleSelectionAndMark, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1753         { &quot;ToggleBold&quot;, { executeToggleBold, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateBold, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1754         { &quot;ToggleItalic&quot;, { executeToggleItalic, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateItalic, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1755         { &quot;ToggleUnderline&quot;, { executeUnderline, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateUnderline, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1756         { &quot;Transpose&quot;, { executeTranspose, supported, enableCaretInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1757         { &quot;Underline&quot;, { executeUnderline, supported, enabledInRichlyEditableText, stateUnderline, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1758         { &quot;Undo&quot;, { executeUndo, supported, enabledUndo, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1759         { &quot;Unlink&quot;, { executeUnlink, supported, enabledRangeInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1760         { &quot;Unscript&quot;, { executeUnscript, supportedFromMenuOrKeyBinding, enabledInRichlyEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1761         { &quot;Unselect&quot;, { executeUnselect, supported, enabledVisibleSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1762         { &quot;UseCSS&quot;, { executeUseCSS, supported, enabled, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1763         { &quot;Yank&quot;, { executeYank, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1764         { &quot;YankAndSelect&quot;, { executeYankAndSelect, supportedFromMenuOrKeyBinding, enabledInEditableText, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1765 
1766 #if PLATFORM(GTK)
1767         { &quot;PasteGlobalSelection&quot;, { executePasteGlobalSelection, supportedFromMenuOrKeyBinding, enabledPaste, stateNone, valueNull, notTextInsertion, allowExecutionWhenDisabled } },
1768 #endif
1769 
1770 #if PLATFORM(COCOA)
1771         { &quot;TakeFindStringFromSelection&quot;, { executeTakeFindStringFromSelection, supportedFromMenuOrKeyBinding, enabledTakeFindStringFromSelection, stateNone, valueNull, notTextInsertion, doNotAllowExecutionWhenDisabled } },
1772 #endif
1773     };
1774 
1775     // These unsupported commands are listed here since they appear in the Microsoft
1776     // documentation used as the starting point for our DOM executeCommand support.
1777     //
1778     // 2D-Position (not supported)
1779     // AbsolutePosition (not supported)
1780     // BlockDirLTR (not supported)
1781     // BlockDirRTL (not supported)
1782     // BrowseMode (not supported)
1783     // ClearAuthenticationCache (not supported)
1784     // CreateBookmark (not supported)
1785     // DirLTR (not supported)
1786     // DirRTL (not supported)
1787     // EditMode (not supported)
1788     // InlineDirLTR (not supported)
1789     // InlineDirRTL (not supported)
1790     // InsertButton (not supported)
1791     // InsertFieldSet (not supported)
1792     // InsertIFrame (not supported)
1793     // InsertInputButton (not supported)
1794     // InsertInputCheckbox (not supported)
1795     // InsertInputFileUpload (not supported)
1796     // InsertInputHidden (not supported)
1797     // InsertInputImage (not supported)
1798     // InsertInputPassword (not supported)
1799     // InsertInputRadio (not supported)
1800     // InsertInputReset (not supported)
1801     // InsertInputSubmit (not supported)
1802     // InsertInputText (not supported)
1803     // InsertMarquee (not supported)
1804     // InsertSelectDropDown (not supported)
1805     // InsertSelectListBox (not supported)
1806     // InsertTextArea (not supported)
1807     // LiveResize (not supported)
1808     // MultipleSelection (not supported)
1809     // Open (not supported)
1810     // PlayImage (not supported)
1811     // Refresh (not supported)
1812     // RemoveParaFormat (not supported)
1813     // SaveAs (not supported)
1814     // SizeToControl (not supported)
1815     // SizeToControlHeight (not supported)
1816     // SizeToControlWidth (not supported)
1817     // Stop (not supported)
1818     // StopImage (not supported)
1819     // Unbookmark (not supported)
1820 
1821     CommandMap&amp; commandMap = *new CommandMap;
1822 
1823     for (auto&amp; command : commands) {
1824         ASSERT(!commandMap.get(command.name));
1825         commandMap.set(command.name, &amp;command.command);
1826     }
1827 
1828     return commandMap;
1829 }
1830 
1831 static const EditorInternalCommand* internalCommand(const String&amp; commandName)
1832 {
1833     static const CommandMap&amp; commandMap = createCommandMap();
1834     return commandName.isEmpty() ? 0 : commandMap.get(commandName);
1835 }
1836 
1837 Editor::Command Editor::command(const String&amp; commandName)
1838 {
1839     return Command(internalCommand(commandName), CommandFromMenuOrKeyBinding, m_frame);
1840 }
1841 
1842 Editor::Command Editor::command(const String&amp; commandName, EditorCommandSource source)
1843 {
1844     return Command(internalCommand(commandName), source, m_frame);
1845 }
1846 
1847 bool Editor::commandIsSupportedFromMenuOrKeyBinding(const String&amp; commandName)
1848 {
1849     return internalCommand(commandName);
1850 }
1851 
1852 Editor::Command::Command()
1853 {
1854 }
1855 
1856 Editor::Command::Command(const EditorInternalCommand* command, EditorCommandSource source, Frame&amp; frame)
1857     : m_command(command)
1858     , m_source(source)
1859     , m_frame(command ? &amp;frame : nullptr)
1860 {
1861     ASSERT(command || !m_frame);
1862 }
1863 
1864 bool Editor::Command::execute(const String&amp; parameter, Event* triggeringEvent) const
1865 {
1866     if (!isEnabled(triggeringEvent)) {
1867         // Let certain commands be executed when performed explicitly even if they are disabled.
1868         if (!allowExecutionWhenDisabled())
1869             return false;
1870     }
1871     auto document = m_frame-&gt;document();
1872     document-&gt;updateLayoutIgnorePendingStylesheets();
1873     if (m_frame-&gt;document() != document)
1874         return false;
1875 
1876     return m_command-&gt;execute(*m_frame, triggeringEvent, m_source, parameter);
1877 }
1878 
1879 bool Editor::Command::execute(Event* triggeringEvent) const
1880 {
1881     return execute(String(), triggeringEvent);
1882 }
1883 
1884 bool Editor::Command::isSupported() const
1885 {
1886     if (!m_command)
1887         return false;
1888     switch (m_source) {
1889     case CommandFromMenuOrKeyBinding:
1890         return true;
1891     case CommandFromDOM:
1892     case CommandFromDOMWithUserInterface:
1893         return m_command-&gt;isSupportedFromDOM(m_frame.get());
1894     }
1895     ASSERT_NOT_REACHED();
1896     return false;
1897 }
1898 
1899 bool Editor::Command::isEnabled(Event* triggeringEvent) const
1900 {
1901     if (!isSupported() || !m_frame)
1902         return false;
1903     return m_command-&gt;isEnabled(*m_frame, triggeringEvent, m_source);
1904 }
1905 
1906 TriState Editor::Command::state(Event* triggeringEvent) const
1907 {
1908     if (!isSupported() || !m_frame)
1909         return FalseTriState;
1910     return m_command-&gt;state(*m_frame, triggeringEvent);
1911 }
1912 
1913 String Editor::Command::value(Event* triggeringEvent) const
1914 {
1915     if (!isSupported() || !m_frame)
1916         return String();
1917     if (m_command-&gt;value == valueNull &amp;&amp; m_command-&gt;state != stateNone)
1918         return m_command-&gt;state(*m_frame, triggeringEvent) == TrueTriState ? &quot;true&quot;_s : &quot;false&quot;_s;
1919     return m_command-&gt;value(*m_frame, triggeringEvent);
1920 }
1921 
1922 bool Editor::Command::isTextInsertion() const
1923 {
1924     return m_command &amp;&amp; m_command-&gt;isTextInsertion;
1925 }
1926 
1927 bool Editor::Command::allowExecutionWhenDisabled() const
1928 {
1929     if (!isSupported() || !m_frame)
1930         return false;
1931     return m_command-&gt;allowExecutionWhenDisabled(*m_frame, m_source);
1932 }
1933 
1934 } // namespace WebCore
    </pre>
  </body>
</html>
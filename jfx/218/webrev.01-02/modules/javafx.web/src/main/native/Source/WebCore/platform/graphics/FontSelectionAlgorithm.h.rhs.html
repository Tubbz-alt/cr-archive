<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FontSelectionAlgorithm.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;TextFlags.h&quot;
 29 #include &lt;algorithm&gt;
 30 #include &lt;tuple&gt;
 31 #include &lt;wtf/Hasher.h&gt;
 32 #include &lt;wtf/Optional.h&gt;
 33 #include &lt;wtf/text/TextStream.h&gt;
 34 
 35 namespace WebCore {
 36 
 37 // Unclamped, unchecked, signed fixed-point number representing a value used for font variations.
 38 // Sixteen bits in total, one sign bit, two fractional bits, smallest positive value is 0.25,
 39 // maximum value is 8191.75, and minimum value is -8192.
 40 class FontSelectionValue {
 41 public:
 42     using BackingType = int16_t;
 43 
 44     FontSelectionValue() = default;
 45 
 46     // Explicit because it won&#39;t work correctly for values outside the representable range.
 47     explicit constexpr FontSelectionValue(int);
 48 
 49     // Explicit because it won&#39;t work correctly for values outside the representable range and because precision can be lost.
 50     explicit constexpr FontSelectionValue(float);
 51 
 52     // Precision can be lost, but value will be clamped to the representable range.
 53     static constexpr FontSelectionValue clampFloat(float);
 54 
 55     // Since floats have 23 mantissa bits, every value can be represented losslessly.
 56     constexpr operator float() const;
 57 
 58     static constexpr FontSelectionValue maximumValue();
 59     static constexpr FontSelectionValue minimumValue();
 60 
 61     friend constexpr FontSelectionValue operator+(FontSelectionValue, FontSelectionValue);
 62     friend constexpr FontSelectionValue operator-(FontSelectionValue, FontSelectionValue);
 63     friend constexpr FontSelectionValue operator*(FontSelectionValue, FontSelectionValue);
 64     friend constexpr FontSelectionValue operator/(FontSelectionValue, FontSelectionValue);
 65     friend constexpr FontSelectionValue operator-(FontSelectionValue);
 66 
 67     constexpr BackingType rawValue() const { return m_backing; }
 68 
<a name="1" id="anc1"></a><span class="line-added"> 69     template&lt;class Encoder&gt;</span>
<span class="line-added"> 70     void encode(Encoder&amp;) const;</span>
<span class="line-added"> 71 </span>
<span class="line-added"> 72     template&lt;class Decoder&gt;</span>
<span class="line-added"> 73     static Optional&lt;FontSelectionValue&gt; decode(Decoder&amp;);</span>
<span class="line-added"> 74 </span>
 75 private:
 76     enum class RawTag { RawTag };
 77     constexpr FontSelectionValue(int, RawTag);
 78 
 79     static constexpr int fractionalEntropy = 4;
 80     BackingType m_backing { 0 };
 81 };
 82 
<a name="2" id="anc2"></a><span class="line-added"> 83 template&lt;class Encoder&gt;</span>
<span class="line-added"> 84 void FontSelectionValue::encode(Encoder&amp; encoder) const</span>
<span class="line-added"> 85 {</span>
<span class="line-added"> 86     encoder &lt;&lt; m_backing;</span>
<span class="line-added"> 87 }</span>
<span class="line-added"> 88 </span>
<span class="line-added"> 89 template&lt;class Decoder&gt;</span>
<span class="line-added"> 90 Optional&lt;FontSelectionValue&gt; FontSelectionValue::decode(Decoder&amp; decoder)</span>
<span class="line-added"> 91 {</span>
<span class="line-added"> 92     Optional&lt;FontSelectionValue::BackingType&gt; backing;</span>
<span class="line-added"> 93     decoder &gt;&gt; backing;</span>
<span class="line-added"> 94     if (!backing)</span>
<span class="line-added"> 95         return WTF::nullopt;</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97     FontSelectionValue result;</span>
<span class="line-added"> 98     result.m_backing = *backing;</span>
<span class="line-added"> 99     return result;</span>
<span class="line-added">100 }</span>
<span class="line-added">101 </span>
102 constexpr FontSelectionValue::FontSelectionValue(int x)
103     : m_backing(x * fractionalEntropy)
104 {
105     // FIXME: Should we assert the passed in value was in range?
106 }
107 
108 constexpr FontSelectionValue::FontSelectionValue(float x)
109     : m_backing(x * fractionalEntropy)
110 {
111     // FIXME: Should we assert the passed in value was in range?
112 }
113 
114 constexpr FontSelectionValue::operator float() const
115 {
116     return m_backing / static_cast&lt;float&gt;(fractionalEntropy);
117 }
118 
119 constexpr FontSelectionValue FontSelectionValue::maximumValue()
120 {
121     return { std::numeric_limits&lt;BackingType&gt;::max(), RawTag::RawTag };
122 }
123 
124 constexpr FontSelectionValue FontSelectionValue::minimumValue()
125 {
126     return { std::numeric_limits&lt;BackingType&gt;::min(), RawTag::RawTag };
127 }
128 
129 constexpr FontSelectionValue FontSelectionValue::clampFloat(float value)
130 {
131     return FontSelectionValue { std::max&lt;float&gt;(minimumValue(), std::min&lt;float&gt;(value, maximumValue())) };
132 }
133 
134 constexpr FontSelectionValue::FontSelectionValue(int rawValue, RawTag)
135     : m_backing(rawValue)
136 {
137 }
138 
139 constexpr FontSelectionValue operator+(FontSelectionValue a, FontSelectionValue b)
140 {
141     return { a.m_backing + b.m_backing, FontSelectionValue::RawTag::RawTag };
142 }
143 
144 constexpr FontSelectionValue operator-(FontSelectionValue a, FontSelectionValue b)
145 {
146     return { a.m_backing - b.m_backing, FontSelectionValue::RawTag::RawTag };
147 }
148 
149 constexpr FontSelectionValue operator*(FontSelectionValue a, FontSelectionValue b)
150 {
151     return { a.m_backing * b.m_backing / FontSelectionValue::fractionalEntropy, FontSelectionValue::RawTag::RawTag };
152 }
153 
154 constexpr FontSelectionValue operator/(FontSelectionValue a, FontSelectionValue b)
155 {
156     return { a.m_backing * FontSelectionValue::fractionalEntropy / b.m_backing, FontSelectionValue::RawTag::RawTag };
157 }
158 
159 constexpr FontSelectionValue operator-(FontSelectionValue value)
160 {
161     return { -value.m_backing, FontSelectionValue::RawTag::RawTag };
162 }
163 
164 constexpr bool operator==(FontSelectionValue a, FontSelectionValue b)
165 {
166     return a.rawValue() == b.rawValue();
167 }
168 
169 constexpr bool operator!=(FontSelectionValue a, FontSelectionValue b)
170 {
171     return a.rawValue() != b.rawValue();
172 }
173 
174 constexpr bool operator&lt;(FontSelectionValue a, FontSelectionValue b)
175 {
176     return a.rawValue() &lt; b.rawValue();
177 }
178 
179 constexpr bool operator&lt;=(FontSelectionValue a, FontSelectionValue b)
180 {
181     return a.rawValue() &lt;= b.rawValue();
182 }
183 
184 constexpr bool operator&gt;(FontSelectionValue a, FontSelectionValue b)
185 {
186     return a.rawValue() &gt; b.rawValue();
187 }
188 
189 constexpr bool operator&gt;=(FontSelectionValue a, FontSelectionValue b)
190 {
191     return a.rawValue() &gt;= b.rawValue();
192 }
193 
194 constexpr FontSelectionValue italicThreshold()
195 {
196     return FontSelectionValue { 20 };
197 }
198 
199 constexpr bool isItalic(Optional&lt;FontSelectionValue&gt; fontWeight)
200 {
201     return fontWeight &amp;&amp; fontWeight.value() &gt;= italicThreshold();
202 }
203 
204 constexpr FontSelectionValue normalItalicValue()
205 {
206     return FontSelectionValue { 0 };
207 }
208 
209 constexpr FontSelectionValue italicValue()
210 {
211     return FontSelectionValue { 20 };
212 }
213 
214 constexpr FontSelectionValue boldThreshold()
215 {
216     return FontSelectionValue { 600 };
217 }
218 
219 constexpr FontSelectionValue boldWeightValue()
220 {
221     return FontSelectionValue { 700 };
222 }
223 
224 constexpr FontSelectionValue normalWeightValue()
225 {
226     return FontSelectionValue { 400 };
227 }
228 
229 constexpr FontSelectionValue lightWeightValue()
230 {
231     return FontSelectionValue { 200 };
232 }
233 
234 constexpr bool isFontWeightBold(FontSelectionValue fontWeight)
235 {
236     return fontWeight &gt;= boldThreshold();
237 }
238 
239 constexpr FontSelectionValue lowerWeightSearchThreshold()
240 {
241     return FontSelectionValue { 400 };
242 }
243 
244 constexpr FontSelectionValue upperWeightSearchThreshold()
245 {
246     return FontSelectionValue { 500 };
247 }
248 
249 constexpr FontSelectionValue ultraCondensedStretchValue()
250 {
251     return FontSelectionValue { 50 };
252 }
253 
254 constexpr FontSelectionValue extraCondensedStretchValue()
255 {
256     return FontSelectionValue { 62.5f };
257 }
258 
259 constexpr FontSelectionValue condensedStretchValue()
260 {
261     return FontSelectionValue { 75 };
262 }
263 
264 constexpr FontSelectionValue semiCondensedStretchValue()
265 {
266     return FontSelectionValue { 87.5f };
267 }
268 
269 constexpr FontSelectionValue normalStretchValue()
270 {
271     return FontSelectionValue { 100 };
272 }
273 
274 constexpr FontSelectionValue semiExpandedStretchValue()
275 {
276     return FontSelectionValue { 112.5f };
277 }
278 
279 constexpr FontSelectionValue expandedStretchValue()
280 {
281     return FontSelectionValue { 125 };
282 }
283 
284 constexpr FontSelectionValue extraExpandedStretchValue()
285 {
286     return FontSelectionValue { 150 };
287 }
288 
289 constexpr FontSelectionValue ultraExpandedStretchValue()
290 {
291     return FontSelectionValue { 200 };
292 }
293 
294 // [Inclusive, Inclusive]
295 struct FontSelectionRange {
296     using Value = FontSelectionValue;
297 
298     constexpr FontSelectionRange(Value minimum, Value maximum)
299         : minimum(minimum)
300         , maximum(maximum)
301     {
302     }
303 
304     explicit constexpr FontSelectionRange(Value value)
305         : minimum(value)
306         , maximum(value)
307     {
308     }
309 
310     constexpr bool operator==(const FontSelectionRange&amp; other) const
311     {
312         return WTF::tie(minimum, maximum) == WTF::tie(other.minimum, other.maximum);
313     }
314 
315     constexpr bool isValid() const
316     {
317         return minimum &lt;= maximum;
318     }
319 
320     void expand(const FontSelectionRange&amp; other)
321     {
322         ASSERT(other.isValid());
323         if (!isValid())
324             *this = other;
325         else {
326             minimum = std::min(minimum, other.minimum);
327             maximum = std::max(maximum, other.maximum);
328         }
329         ASSERT(isValid());
330     }
331 
332     constexpr bool includes(Value target) const
333     {
334         return target &gt;= minimum &amp;&amp; target &lt;= maximum;
335     }
336 
337     // FIXME: This name is not so great. Move this into the add function below
338     // once we move FontPlatformDataCacheKeyHash from IntegerHasher to Hasher,
339     // and then it doesn&#39;t need to have a name.
340     constexpr uint32_t uniqueValue() const
341     {
342         return minimum.rawValue() &lt;&lt; 16 | maximum.rawValue();
343     }
344 
<a name="3" id="anc3"></a><span class="line-added">345     template&lt;class Encoder&gt;</span>
<span class="line-added">346     void encode(Encoder&amp;) const;</span>
<span class="line-added">347 </span>
<span class="line-added">348     template&lt;class Decoder&gt;</span>
<span class="line-added">349     static Optional&lt;FontSelectionRange&gt; decode(Decoder&amp;);</span>
<span class="line-added">350 </span>
351     Value minimum { 1 };
352     Value maximum { 0 };
353 };
354 
<a name="4" id="anc4"></a><span class="line-added">355 template&lt;class Encoder&gt;</span>
<span class="line-added">356 void FontSelectionRange::encode(Encoder&amp; encoder) const</span>
<span class="line-added">357 {</span>
<span class="line-added">358     encoder &lt;&lt; minimum;</span>
<span class="line-added">359     encoder &lt;&lt; maximum;</span>
<span class="line-added">360 }</span>
<span class="line-added">361 </span>
<span class="line-added">362 template&lt;class Decoder&gt;</span>
<span class="line-added">363 Optional&lt;FontSelectionRange&gt; FontSelectionRange::decode(Decoder&amp; decoder)</span>
<span class="line-added">364 {</span>
<span class="line-added">365     Optional&lt;FontSelectionRange::Value&gt; minimum;</span>
<span class="line-added">366     decoder &gt;&gt; minimum;</span>
<span class="line-added">367     if (!minimum)</span>
<span class="line-added">368         return WTF::nullopt;</span>
<span class="line-added">369 </span>
<span class="line-added">370     Optional&lt;FontSelectionRange::Value&gt; maximum;</span>
<span class="line-added">371     decoder &gt;&gt; maximum;</span>
<span class="line-added">372     if (!maximum)</span>
<span class="line-added">373         return WTF::nullopt;</span>
<span class="line-added">374 </span>
<span class="line-added">375     return {{ *minimum, *maximum }};</span>
<span class="line-added">376 }</span>
<span class="line-added">377 </span>
378 inline void add(Hasher&amp; hasher, const FontSelectionRange&amp; range)
379 {
380     add(hasher, range.uniqueValue());
381 }
382 
383 struct FontSelectionRequest {
384     using Value = FontSelectionValue;
385 
386     Value weight;
387     Value width;
388     // FIXME: We are using an optional here to be able to distinguish between an explicit
389     // or implicit slope (for &quot;italic&quot; and &quot;oblique&quot;) and the &quot;normal&quot; value which has no
390     // slope. The &quot;italic&quot; and &quot;oblique&quot; values can be distinguished by looking at the
391     // &quot;fontStyleAxis&quot; on the FontDescription. We should come up with a tri-state member
392     // so that it&#39;s a lot clearer whether we&#39;re dealing with a &quot;normal&quot;, &quot;italic&quot; or explicit
393     // &quot;oblique&quot; font style. See webkit.org/b/187774.
394     Optional&lt;Value&gt; slope;
395 
396     std::tuple&lt;Value, Value, Optional&lt;Value&gt;&gt; tied() const
397     {
398         return WTF::tie(weight, width, slope);
399     }
400 };
401 
402 inline TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const FontSelectionValue&amp; fontSelectionValue)
403 {
404     ts &lt;&lt; TextStream::FormatNumberRespectingIntegers(fontSelectionValue.rawValue());
405     return ts;
406 }
407 
408 inline TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const Optional&lt;FontSelectionValue&gt;&amp; optionalFontSelectionValue)
409 {
410     ts &lt;&lt; optionalFontSelectionValue.valueOr(normalItalicValue());
411     return ts;
412 }
413 
414 inline bool operator==(const FontSelectionRequest&amp; a, const FontSelectionRequest&amp; b)
415 {
416     return a.tied() == b.tied();
417 }
418 
419 inline bool operator!=(const FontSelectionRequest&amp; a, const FontSelectionRequest&amp; b)
420 {
421     return !(a == b);
422 }
423 
424 inline void add(Hasher&amp; hasher, const FontSelectionRequest&amp; request)
425 {
426     add(hasher, request.tied());
427 }
428 
429 struct FontSelectionCapabilities {
430     using Range = FontSelectionRange;
431 
432     FontSelectionCapabilities&amp; operator=(const FontSelectionCapabilities&amp;) = default;
433 
434     constexpr std::tuple&lt;Range, Range, Range&gt; tied() const
435     {
436         return WTF::tie(weight, width, slope);
437     }
438 
439     void expand(const FontSelectionCapabilities&amp; capabilities)
440     {
441         weight.expand(capabilities.weight);
442         width.expand(capabilities.width);
443         slope.expand(capabilities.slope);
444     }
445 
446     Range weight { normalWeightValue() };
447     Range width { normalStretchValue() };
448     Range slope { normalItalicValue() };
449 };
450 
451 constexpr bool operator==(const FontSelectionCapabilities&amp; a, const FontSelectionCapabilities&amp; b)
452 {
453     return a.tied() == b.tied();
454 }
455 
456 constexpr bool operator!=(const FontSelectionCapabilities&amp; a, const FontSelectionCapabilities&amp; b)
457 {
458     return !(a == b);
459 }
460 
461 struct FontSelectionSpecifiedCapabilities {
462     using Capabilities = FontSelectionCapabilities;
463     using Range = FontSelectionRange;
464     using OptionalRange = Optional&lt;Range&gt;;
465 
466     constexpr Capabilities computeFontSelectionCapabilities() const
467     {
468         return { computeWeight(), computeWidth(), computeSlope() };
469     }
470 
471     constexpr std::tuple&lt;OptionalRange&amp;, OptionalRange&amp;, OptionalRange&amp;&gt; tied()
472     {
473         return WTF::tie(weight, width, slope);
474     }
475 
476     constexpr std::tuple&lt;const OptionalRange&amp;, const OptionalRange&amp;, const OptionalRange&amp;&gt; tied() const
477     {
478         return WTF::tie(weight, width, slope);
479     }
480 
481     FontSelectionSpecifiedCapabilities&amp; operator=(const Capabilities&amp; other)
482     {
483         tied() = other.tied();
484         return *this;
485     }
486 
487     constexpr Range computeWeight() const
488     {
489         return weight.valueOr(Range { normalWeightValue() });
490     }
491 
492     constexpr Range computeWidth() const
493     {
494         return width.valueOr(Range { normalStretchValue() });
495     }
496 
497     constexpr Range computeSlope() const
498     {
499         return slope.valueOr(Range { normalItalicValue() });
500     }
501 
<a name="5" id="anc5"></a><span class="line-added">502     template&lt;class Encoder&gt;</span>
<span class="line-added">503     void encode(Encoder&amp;) const;</span>
<span class="line-added">504 </span>
<span class="line-added">505     template&lt;class Decoder&gt;</span>
<span class="line-added">506     static Optional&lt;FontSelectionSpecifiedCapabilities&gt; decode(Decoder&amp;);</span>
<span class="line-added">507 </span>
508     OptionalRange weight;
509     OptionalRange width;
510     OptionalRange slope;
511 };
512 
<a name="6" id="anc6"></a><span class="line-added">513 template&lt;class Encoder&gt;</span>
<span class="line-added">514 void FontSelectionSpecifiedCapabilities::encode(Encoder&amp; encoder) const</span>
<span class="line-added">515 {</span>
<span class="line-added">516     encoder &lt;&lt; weight;</span>
<span class="line-added">517     encoder &lt;&lt; width;</span>
<span class="line-added">518     encoder &lt;&lt; slope;</span>
<span class="line-added">519 }</span>
<span class="line-added">520 </span>
<span class="line-added">521 template&lt;class Decoder&gt;</span>
<span class="line-added">522 Optional&lt;FontSelectionSpecifiedCapabilities&gt; FontSelectionSpecifiedCapabilities::decode(Decoder&amp; decoder)</span>
<span class="line-added">523 {</span>
<span class="line-added">524     Optional&lt;OptionalRange&gt; weight;</span>
<span class="line-added">525     decoder &gt;&gt; weight;</span>
<span class="line-added">526     if (!weight)</span>
<span class="line-added">527         return WTF::nullopt;</span>
<span class="line-added">528 </span>
<span class="line-added">529     Optional&lt;OptionalRange&gt; width;</span>
<span class="line-added">530     decoder &gt;&gt; width;</span>
<span class="line-added">531     if (!width)</span>
<span class="line-added">532         return WTF::nullopt;</span>
<span class="line-added">533 </span>
<span class="line-added">534     Optional&lt;OptionalRange&gt; slope;</span>
<span class="line-added">535     decoder &gt;&gt; slope;</span>
<span class="line-added">536     if (!slope)</span>
<span class="line-added">537         return WTF::nullopt;</span>
<span class="line-added">538 </span>
<span class="line-added">539     return {{ *weight, *width, *slope }};</span>
<span class="line-added">540 }</span>
<span class="line-added">541 </span>
542 constexpr bool operator==(const FontSelectionSpecifiedCapabilities&amp; a, const FontSelectionSpecifiedCapabilities&amp; b)
543 {
544     return a.tied() == b.tied();
545 }
546 
547 constexpr bool operator!=(const FontSelectionSpecifiedCapabilities&amp; a, const FontSelectionSpecifiedCapabilities&amp; b)
548 {
549     return !(a == b);
550 }
551 
552 class FontSelectionAlgorithm {
553 public:
554     using Capabilities = FontSelectionCapabilities;
555 
556     FontSelectionAlgorithm() = delete;
557     FontSelectionAlgorithm(FontSelectionRequest, const Vector&lt;Capabilities&gt;&amp;, Optional&lt;Capabilities&gt; capabilitiesBounds = WTF::nullopt);
558 
559     struct DistanceResult {
560         FontSelectionValue distance;
561         FontSelectionValue value;
562     };
563     DistanceResult stretchDistance(Capabilities) const;
564     DistanceResult styleDistance(Capabilities) const;
565     DistanceResult weightDistance(Capabilities) const;
566 
567     size_t indexOfBestCapabilities();
568 
569 private:
570     using DistanceFunction = DistanceResult (FontSelectionAlgorithm::*)(Capabilities) const;
571     using CapabilitiesRange = FontSelectionRange Capabilities::*;
572     FontSelectionValue bestValue(const bool eliminated[], DistanceFunction) const;
573     void filterCapability(bool eliminated[], DistanceFunction, CapabilitiesRange);
574 
575     FontSelectionRequest m_request;
576     Capabilities m_capabilitiesBounds;
577     const Vector&lt;Capabilities&gt;&amp; m_capabilities;
578 };
579 
580 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/IntlNumberFormat.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015 Andy VanWagoner (andy@vanwagoner.family)
  3  * Copyright (C) 2016 Sukolsak Sakshuwong (sukolsak@gmail.com)
  4  * Copyright (C) 2016-2020 Apple Inc. All rights reserved.
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above copyright
 12  *    notice, this list of conditions and the following disclaimer in the
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 16  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 17  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 19  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 20  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 21  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 22  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 23  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 24  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 25  * THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;IntlNumberFormat.h&quot;
 30 
 31 #if ENABLE(INTL)
 32 
 33 #include &quot;CatchScope.h&quot;
 34 #include &quot;Error.h&quot;
 35 #include &quot;IntlNumberFormatConstructor.h&quot;
 36 #include &quot;IntlObject.h&quot;
 37 #include &quot;JSBoundFunction.h&quot;
 38 #include &quot;JSCInlines.h&quot;
 39 #include &quot;ObjectConstructor.h&quot;
 40 
 41 #if HAVE(ICU_FORMAT_DOUBLE_FOR_FIELDS)
 42 #include &lt;unicode/ufieldpositer.h&gt;
 43 #endif
 44 
 45 namespace JSC {
 46 
 47 const ClassInfo IntlNumberFormat::s_info = { &quot;Object&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(IntlNumberFormat) };
 48 
 49 static const char* const relevantNumberExtensionKeys[1] = { &quot;nu&quot; };
 50 
 51 void IntlNumberFormat::UNumberFormatDeleter::operator()(UNumberFormat* numberFormat) const
 52 {
 53     if (numberFormat)
 54         unum_close(numberFormat);
 55 }
 56 
 57 IntlNumberFormat* IntlNumberFormat::create(VM&amp; vm, Structure* structure)
 58 {
 59     IntlNumberFormat* format = new (NotNull, allocateCell&lt;IntlNumberFormat&gt;(vm.heap)) IntlNumberFormat(vm, structure);
 60     format-&gt;finishCreation(vm);
 61     return format;
 62 }
 63 
 64 Structure* IntlNumberFormat::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 65 {
 66     return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 67 }
 68 
 69 IntlNumberFormat::IntlNumberFormat(VM&amp; vm, Structure* structure)
 70     : Base(vm, structure)
 71 {
 72 }
 73 
 74 void IntlNumberFormat::finishCreation(VM&amp; vm)
 75 {
 76     Base::finishCreation(vm);
 77     ASSERT(inherits(vm, info()));
 78 }
 79 
 80 void IntlNumberFormat::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 81 {
 82     IntlNumberFormat* thisObject = jsCast&lt;IntlNumberFormat*&gt;(cell);
 83     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 84 
 85     Base::visitChildren(thisObject, visitor);
 86 
 87     visitor.append(thisObject-&gt;m_boundFormat);
 88 }
 89 
 90 namespace IntlNFInternal {
 91 static Vector&lt;String&gt; localeData(const String&amp; locale, size_t keyIndex)
 92 {
 93     // 9.1 Internal slots of Service Constructors &amp; 11.2.3 Internal slots (ECMA-402 2.0)
 94     ASSERT_UNUSED(keyIndex, !keyIndex); // The index of the extension key &quot;nu&quot; in relevantExtensionKeys is 0.
 95     return numberingSystemsForLocale(locale);
 96 }
 97 }
 98 
 99 static inline unsigned computeCurrencySortKey(const String&amp; currency)
100 {
101     ASSERT(currency.length() == 3);
102     ASSERT(currency.isAllSpecialCharacters&lt;isASCIIUpper&gt;());
103     return (currency[0] &lt;&lt; 16) + (currency[1] &lt;&lt; 8) + currency[2];
104 }
105 
106 static inline unsigned computeCurrencySortKey(const char* currency)
107 {
108     ASSERT(strlen(currency) == 3);
109     ASSERT(isAllSpecialCharacters&lt;isASCIIUpper&gt;(currency, 3));
110     return (currency[0] &lt;&lt; 16) + (currency[1] &lt;&lt; 8) + currency[2];
111 }
112 
113 static unsigned extractCurrencySortKey(std::pair&lt;const char*, unsigned&gt;* currencyMinorUnit)
114 {
115     return computeCurrencySortKey(currencyMinorUnit-&gt;first);
116 }
117 
118 static unsigned computeCurrencyDigits(const String&amp; currency)
119 {
120     // 11.1.1 The abstract operation CurrencyDigits (currency)
121     // &quot;If the ISO 4217 currency and funds code list contains currency as an alphabetic code,
122     // then return the minor unit value corresponding to the currency from the list; else return 2.
123     std::pair&lt;const char*, unsigned&gt; currencyMinorUnits[] = {
124         { &quot;BHD&quot;, 3 },
125         { &quot;BIF&quot;, 0 },
126         { &quot;BYR&quot;, 0 },
127         { &quot;CLF&quot;, 4 },
128         { &quot;CLP&quot;, 0 },
129         { &quot;DJF&quot;, 0 },
130         { &quot;GNF&quot;, 0 },
131         { &quot;IQD&quot;, 3 },
132         { &quot;ISK&quot;, 0 },
133         { &quot;JOD&quot;, 3 },
134         { &quot;JPY&quot;, 0 },
135         { &quot;KMF&quot;, 0 },
136         { &quot;KRW&quot;, 0 },
137         { &quot;KWD&quot;, 3 },
138         { &quot;LYD&quot;, 3 },
139         { &quot;OMR&quot;, 3 },
140         { &quot;PYG&quot;, 0 },
141         { &quot;RWF&quot;, 0 },
142         { &quot;TND&quot;, 3 },
143         { &quot;UGX&quot;, 0 },
144         { &quot;UYI&quot;, 0 },
145         { &quot;VND&quot;, 0 },
146         { &quot;VUV&quot;, 0 },
147         { &quot;XAF&quot;, 0 },
148         { &quot;XOF&quot;, 0 },
149         { &quot;XPF&quot;, 0 }
150     };
151     auto* currencyMinorUnit = tryBinarySearch&lt;std::pair&lt;const char*, unsigned&gt;&gt;(currencyMinorUnits, WTF_ARRAY_LENGTH(currencyMinorUnits), computeCurrencySortKey(currency), extractCurrencySortKey);
152     if (currencyMinorUnit)
153         return currencyMinorUnit-&gt;second;
154     return 2;
155 }
156 
157 void IntlNumberFormat::initializeNumberFormat(JSGlobalObject* globalObject, JSValue locales, JSValue optionsValue)
158 {
159     VM&amp; vm = globalObject-&gt;vm();
160     auto scope = DECLARE_THROW_SCOPE(vm);
161 
162     // 11.1.2 InitializeNumberFormat (numberFormat, locales, options) (ECMA-402)
163     // https://tc39.github.io/ecma402/#sec-initializenumberformat
164 
165     auto requestedLocales = canonicalizeLocaleList(globalObject, locales);
166     RETURN_IF_EXCEPTION(scope, void());
167 
168     JSObject* options;
169     if (optionsValue.isUndefined())
170         options = constructEmptyObject(vm, globalObject-&gt;nullPrototypeObjectStructure());
171     else {
172         options = optionsValue.toObject(globalObject);
173         RETURN_IF_EXCEPTION(scope, void());
174     }
175 
176     HashMap&lt;String, String&gt; opt;
177 
178     String matcher = intlStringOption(globalObject, options, vm.propertyNames-&gt;localeMatcher, { &quot;lookup&quot;, &quot;best fit&quot; }, &quot;localeMatcher must be either \&quot;lookup\&quot; or \&quot;best fit\&quot;&quot;, &quot;best fit&quot;);
179     RETURN_IF_EXCEPTION(scope, void());
180     opt.add(&quot;localeMatcher&quot;_s, matcher);
181 
182     auto&amp; availableLocales = intlNumberFormatAvailableLocales();
183     auto result = resolveLocale(globalObject, availableLocales, requestedLocales, opt, relevantNumberExtensionKeys, WTF_ARRAY_LENGTH(relevantNumberExtensionKeys), IntlNFInternal::localeData);
184 
185     m_locale = result.get(&quot;locale&quot;_s);
186     if (m_locale.isEmpty()) {
187         throwTypeError(globalObject, scope, &quot;failed to initialize NumberFormat due to invalid locale&quot;_s);
188         return;
189     }
190 
191     m_numberingSystem = result.get(&quot;nu&quot;_s);
192 
193     String styleString = intlStringOption(globalObject, options, Identifier::fromString(vm, &quot;style&quot;), { &quot;decimal&quot;, &quot;percent&quot;, &quot;currency&quot; }, &quot;style must be either \&quot;decimal\&quot;, \&quot;percent\&quot;, or \&quot;currency\&quot;&quot;, &quot;decimal&quot;);
194     RETURN_IF_EXCEPTION(scope, void());
195     if (styleString == &quot;decimal&quot;)
196         m_style = Style::Decimal;
197     else if (styleString == &quot;percent&quot;)
198         m_style = Style::Percent;
199     else if (styleString == &quot;currency&quot;)
200         m_style = Style::Currency;
201     else
202         ASSERT_NOT_REACHED();
203 
204     String currency = intlStringOption(globalObject, options, Identifier::fromString(vm, &quot;currency&quot;), { }, nullptr, nullptr);
205     RETURN_IF_EXCEPTION(scope, void());
206     if (!currency.isNull()) {
207         if (currency.length() != 3 || !currency.isAllSpecialCharacters&lt;isASCIIAlpha&gt;()) {
208             throwException(globalObject, scope, createRangeError(globalObject, &quot;currency is not a well-formed currency code&quot;_s));
209             return;
210         }
211     }
212 
213     unsigned currencyDigits = 0;
214     if (m_style == Style::Currency) {
215         if (currency.isNull()) {
216             throwTypeError(globalObject, scope, &quot;currency must be a string&quot;_s);
217             return;
218         }
219 
220         currency = currency.convertToASCIIUppercase();
221         m_currency = currency;
222         currencyDigits = computeCurrencyDigits(currency);
223     }
224 
225     String currencyDisplayString = intlStringOption(globalObject, options, Identifier::fromString(vm, &quot;currencyDisplay&quot;), { &quot;code&quot;, &quot;symbol&quot;, &quot;name&quot; }, &quot;currencyDisplay must be either \&quot;code\&quot;, \&quot;symbol\&quot;, or \&quot;name\&quot;&quot;, &quot;symbol&quot;);
226     RETURN_IF_EXCEPTION(scope, void());
227     if (m_style == Style::Currency) {
228         if (currencyDisplayString == &quot;code&quot;)
229             m_currencyDisplay = CurrencyDisplay::Code;
230         else if (currencyDisplayString == &quot;symbol&quot;)
231             m_currencyDisplay = CurrencyDisplay::Symbol;
232         else if (currencyDisplayString == &quot;name&quot;)
233             m_currencyDisplay = CurrencyDisplay::Name;
234         else
235             ASSERT_NOT_REACHED();
236     }
237 
238     unsigned minimumIntegerDigits = intlNumberOption(globalObject, options, Identifier::fromString(vm, &quot;minimumIntegerDigits&quot;), 1, 21, 1);
239     RETURN_IF_EXCEPTION(scope, void());
240     m_minimumIntegerDigits = minimumIntegerDigits;
241 
242     unsigned minimumFractionDigitsDefault = (m_style == Style::Currency) ? currencyDigits : 0;
243 
244     unsigned minimumFractionDigits = intlNumberOption(globalObject, options, Identifier::fromString(vm, &quot;minimumFractionDigits&quot;), 0, 20, minimumFractionDigitsDefault);
245     RETURN_IF_EXCEPTION(scope, void());
246     m_minimumFractionDigits = minimumFractionDigits;
247 
248     unsigned maximumFractionDigitsDefault;
249     if (m_style == Style::Currency)
250         maximumFractionDigitsDefault = std::max(minimumFractionDigits, currencyDigits);
251     else if (m_style == Style::Percent)
252         maximumFractionDigitsDefault = minimumFractionDigits;
253     else
254         maximumFractionDigitsDefault = std::max(minimumFractionDigits, 3u);
255 
256     unsigned maximumFractionDigits = intlNumberOption(globalObject, options, Identifier::fromString(vm, &quot;maximumFractionDigits&quot;), minimumFractionDigits, 20, maximumFractionDigitsDefault);
257     RETURN_IF_EXCEPTION(scope, void());
258     m_maximumFractionDigits = maximumFractionDigits;
259 
260     JSValue minimumSignificantDigitsValue = options-&gt;get(globalObject, Identifier::fromString(vm, &quot;minimumSignificantDigits&quot;));
261     RETURN_IF_EXCEPTION(scope, void());
262 
263     JSValue maximumSignificantDigitsValue = options-&gt;get(globalObject, Identifier::fromString(vm, &quot;maximumSignificantDigits&quot;));
264     RETURN_IF_EXCEPTION(scope, void());
265 
266     if (!minimumSignificantDigitsValue.isUndefined() || !maximumSignificantDigitsValue.isUndefined()) {
267         unsigned minimumSignificantDigits = intlDefaultNumberOption(globalObject, minimumSignificantDigitsValue, Identifier::fromString(vm, &quot;minimumSignificantDigits&quot;), 1, 21, 1);
268         RETURN_IF_EXCEPTION(scope, void());
269         unsigned maximumSignificantDigits = intlDefaultNumberOption(globalObject, maximumSignificantDigitsValue, Identifier::fromString(vm, &quot;maximumSignificantDigits&quot;), minimumSignificantDigits, 21, 21);
270         RETURN_IF_EXCEPTION(scope, void());
271         m_minimumSignificantDigits = minimumSignificantDigits;
272         m_maximumSignificantDigits = maximumSignificantDigits;
273     }
274 
275     bool usesFallback;
276     bool useGrouping = intlBooleanOption(globalObject, options, Identifier::fromString(vm, &quot;useGrouping&quot;), usesFallback);
277     if (usesFallback)
278         useGrouping = true;
279     RETURN_IF_EXCEPTION(scope, void());
280     m_useGrouping = useGrouping;
281 
282     UNumberFormatStyle style = UNUM_DEFAULT;
283     switch (m_style) {
284     case Style::Decimal:
285         style = UNUM_DECIMAL;
286         break;
287     case Style::Percent:
288         style = UNUM_PERCENT;
289         break;
290     case Style::Currency:
291         switch (m_currencyDisplay) {
292         case CurrencyDisplay::Code:
293             style = UNUM_CURRENCY_ISO;
294             break;
295         case CurrencyDisplay::Symbol:
296             style = UNUM_CURRENCY;
297             break;
298         case CurrencyDisplay::Name:
299             style = UNUM_CURRENCY_PLURAL;
300             break;
301         default:
302             ASSERT_NOT_REACHED();
303         }
304         break;
305     default:
306         ASSERT_NOT_REACHED();
307     }
308 
309     UErrorCode status = U_ZERO_ERROR;
310     m_numberFormat = std::unique_ptr&lt;UNumberFormat, UNumberFormatDeleter&gt;(unum_open(style, nullptr, 0, m_locale.utf8().data(), nullptr, &amp;status));
311     if (U_FAILURE(status)) {
312         throwTypeError(globalObject, scope, &quot;failed to initialize NumberFormat&quot;_s);
313         return;
314     }
315 
316     if (m_style == Style::Currency) {
317         unum_setTextAttribute(m_numberFormat.get(), UNUM_CURRENCY_CODE, StringView(m_currency).upconvertedCharacters(), m_currency.length(), &amp;status);
318         if (U_FAILURE(status)) {
319             throwTypeError(globalObject, scope, &quot;failed to initialize NumberFormat&quot;_s);
320             return;
321         }
322     }
323     if (!m_minimumSignificantDigits) {
324         unum_setAttribute(m_numberFormat.get(), UNUM_MIN_INTEGER_DIGITS, m_minimumIntegerDigits);
325         unum_setAttribute(m_numberFormat.get(), UNUM_MIN_FRACTION_DIGITS, m_minimumFractionDigits);
326         unum_setAttribute(m_numberFormat.get(), UNUM_MAX_FRACTION_DIGITS, m_maximumFractionDigits);
327     } else {
328         unum_setAttribute(m_numberFormat.get(), UNUM_SIGNIFICANT_DIGITS_USED, true);
329         unum_setAttribute(m_numberFormat.get(), UNUM_MIN_SIGNIFICANT_DIGITS, m_minimumSignificantDigits);
330         unum_setAttribute(m_numberFormat.get(), UNUM_MAX_SIGNIFICANT_DIGITS, m_maximumSignificantDigits);
331     }
332     unum_setAttribute(m_numberFormat.get(), UNUM_GROUPING_USED, m_useGrouping);
333     unum_setAttribute(m_numberFormat.get(), UNUM_ROUNDING_MODE, UNUM_ROUND_HALFUP);
334 
335     m_initializedNumberFormat = true;
336 }
337 
338 JSValue IntlNumberFormat::formatNumber(JSGlobalObject* globalObject, double number)
339 {
340     VM&amp; vm = globalObject-&gt;vm();
341     auto scope = DECLARE_THROW_SCOPE(vm);
342 
343     // 11.3.4 FormatNumber abstract operation (ECMA-402 2.0)
344     if (!m_initializedNumberFormat)
345         return throwTypeError(globalObject, scope, &quot;Intl.NumberFormat.prototype.format called on value that&#39;s not an object initialized as a NumberFormat&quot;_s);
346 
347     // Map negative zero to positive zero.
348     if (!number)
349         number = 0.0;
350 
351     UErrorCode status = U_ZERO_ERROR;
352     Vector&lt;UChar, 32&gt; buffer(32);
353     auto length = unum_formatDouble(m_numberFormat.get(), number, buffer.data(), buffer.size(), nullptr, &amp;status);
354     if (status == U_BUFFER_OVERFLOW_ERROR) {
355         buffer.grow(length);
356         status = U_ZERO_ERROR;
357         unum_formatDouble(m_numberFormat.get(), number, buffer.data(), length, nullptr, &amp;status);
358     }
359     if (U_FAILURE(status))
360         return throwException(globalObject, scope, createError(globalObject, &quot;Failed to format a number.&quot;_s));
361 
362     return jsString(vm, String(buffer.data(), length));
363 }
364 
365 ASCIILiteral IntlNumberFormat::styleString(Style style)
366 {
367     switch (style) {
368     case Style::Decimal:
369         return &quot;decimal&quot;_s;
370     case Style::Percent:
371         return &quot;percent&quot;_s;
372     case Style::Currency:
373         return &quot;currency&quot;_s;
374     }
375     ASSERT_NOT_REACHED();
376     return ASCIILiteral::null();
377 }
378 
379 ASCIILiteral IntlNumberFormat::currencyDisplayString(CurrencyDisplay currencyDisplay)
380 {
381     switch (currencyDisplay) {
382     case CurrencyDisplay::Code:
383         return &quot;code&quot;_s;
384     case CurrencyDisplay::Symbol:
385         return &quot;symbol&quot;_s;
386     case CurrencyDisplay::Name:
387         return &quot;name&quot;_s;
388     }
389     ASSERT_NOT_REACHED();
390     return ASCIILiteral::null();
391 }
392 
393 JSObject* IntlNumberFormat::resolvedOptions(JSGlobalObject* globalObject)
394 {
395     VM&amp; vm = globalObject-&gt;vm();
396     auto scope = DECLARE_THROW_SCOPE(vm);
397 
398     // 11.3.5 Intl.NumberFormat.prototype.resolvedOptions() (ECMA-402 2.0)
399     // The function returns a new object whose properties and attributes are set as if
400     // constructed by an object literal assigning to each of the following properties the
401     // value of the corresponding internal slot of this NumberFormat object (see 11.4):
402     // locale, numberingSystem, style, currency, currencyDisplay, minimumIntegerDigits,
403     // minimumFractionDigits, maximumFractionDigits, minimumSignificantDigits,
404     // maximumSignificantDigits, and useGrouping. Properties whose corresponding internal
405     // slots are not present are not assigned.
406 
407     if (!m_initializedNumberFormat) {
408         initializeNumberFormat(globalObject, jsUndefined(), jsUndefined());
409         scope.assertNoException();
410     }
411 
412     JSObject* options = constructEmptyObject(globalObject);
413     options-&gt;putDirect(vm, vm.propertyNames-&gt;locale, jsString(vm, m_locale));
414     options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;numberingSystem&quot;), jsString(vm, m_numberingSystem));
415     options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;style&quot;), jsNontrivialString(vm, styleString(m_style)));
416     if (m_style == Style::Currency) {
417         options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;currency&quot;), jsNontrivialString(vm, m_currency));
418         options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;currencyDisplay&quot;), jsNontrivialString(vm, currencyDisplayString(m_currencyDisplay)));
419     }
420     options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;minimumIntegerDigits&quot;), jsNumber(m_minimumIntegerDigits));
421     options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;minimumFractionDigits&quot;), jsNumber(m_minimumFractionDigits));
422     options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;maximumFractionDigits&quot;), jsNumber(m_maximumFractionDigits));
423     if (m_minimumSignificantDigits) {
424         ASSERT(m_maximumSignificantDigits);
425         options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;minimumSignificantDigits&quot;), jsNumber(m_minimumSignificantDigits));
426         options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;maximumSignificantDigits&quot;), jsNumber(m_maximumSignificantDigits));
427     }
428     options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;useGrouping&quot;), jsBoolean(m_useGrouping));
429     return options;
430 }
431 
432 void IntlNumberFormat::setBoundFormat(VM&amp; vm, JSBoundFunction* format)
433 {
434     m_boundFormat.set(vm, this, format);
435 }
436 
437 #if HAVE(ICU_FORMAT_DOUBLE_FOR_FIELDS)
438 void IntlNumberFormat::UFieldPositionIteratorDeleter::operator()(UFieldPositionIterator* iterator) const
439 {
440     if (iterator)
441         ufieldpositer_close(iterator);
442 }
443 
444 ASCIILiteral IntlNumberFormat::partTypeString(UNumberFormatFields field, double value)
445 {
446     switch (field) {
447     case UNUM_INTEGER_FIELD:
448         if (std::isnan(value))
449             return &quot;nan&quot;_s;
450         if (!std::isfinite(value))
451             return &quot;infinity&quot;_s;
452         return &quot;integer&quot;_s;
453     case UNUM_FRACTION_FIELD:
454         return &quot;fraction&quot;_s;
455     case UNUM_DECIMAL_SEPARATOR_FIELD:
456         return &quot;decimal&quot;_s;
457     case UNUM_GROUPING_SEPARATOR_FIELD:
458         return &quot;group&quot;_s;
459     case UNUM_CURRENCY_FIELD:
460         return &quot;currency&quot;_s;
461     case UNUM_PERCENT_FIELD:
462         return &quot;percentSign&quot;_s;
463     case UNUM_SIGN_FIELD:
464         return value &lt; 0 ? &quot;minusSign&quot;_s : &quot;plusSign&quot;_s;
465     // These should not show up because there is no way to specify them in NumberFormat options.
466     // If they do, they don&#39;t fit well into any of known part types, so consider it an &quot;unknown&quot;.
467     case UNUM_PERMILL_FIELD:
468     case UNUM_EXPONENT_SYMBOL_FIELD:
469     case UNUM_EXPONENT_SIGN_FIELD:
470     case UNUM_EXPONENT_FIELD:
471 #if !defined(U_HIDE_DEPRECATED_API)
472     case UNUM_FIELD_COUNT:
473 #endif
474     // Any newer additions to the UNumberFormatFields enum should just be considered an &quot;unknown&quot; part.
475     default:
476         return &quot;unknown&quot;_s;
477     }
478     return &quot;unknown&quot;_s;
479 }
480 
481 JSValue IntlNumberFormat::formatToParts(JSGlobalObject* globalObject, double value)
482 {
483     VM&amp; vm = globalObject-&gt;vm();
484     auto scope = DECLARE_THROW_SCOPE(vm);
485 
486     // FormatNumberToParts (ECMA-402)
487     // https://tc39.github.io/ecma402/#sec-formatnumbertoparts
488     // https://tc39.github.io/ecma402/#sec-partitionnumberpattern
489 
490     if (!m_initializedNumberFormat)
491         return throwTypeError(globalObject, scope, &quot;Intl.NumberFormat.prototype.formatToParts called on value that&#39;s not an object initialized as a NumberFormat&quot;_s);
492 
493     UErrorCode status = U_ZERO_ERROR;
494     auto fieldItr = std::unique_ptr&lt;UFieldPositionIterator, UFieldPositionIteratorDeleter&gt;(ufieldpositer_open(&amp;status));
495     if (U_FAILURE(status))
496         return throwTypeError(globalObject, scope, &quot;failed to open field position iterator&quot;_s);
497 
498     status = U_ZERO_ERROR;
499     Vector&lt;UChar, 32&gt; result(32);
500     auto resultLength = unum_formatDoubleForFields(m_numberFormat.get(), value, result.data(), result.size(), fieldItr.get(), &amp;status);
501     if (status == U_BUFFER_OVERFLOW_ERROR) {
502         status = U_ZERO_ERROR;
503         result.grow(resultLength);
504         unum_formatDoubleForFields(m_numberFormat.get(), value, result.data(), resultLength, fieldItr.get(), &amp;status);
505     }
506     if (U_FAILURE(status))
507         return throwTypeError(globalObject, scope, &quot;failed to format a number.&quot;_s);
508 
509     int32_t literalFieldType = -1;
510     auto literalField = IntlNumberFormatField(literalFieldType, resultLength);
511     Vector&lt;IntlNumberFormatField&gt; fields(resultLength, literalField);
512     int32_t beginIndex = 0;
513     int32_t endIndex = 0;
514     auto fieldType = ufieldpositer_next(fieldItr.get(), &amp;beginIndex, &amp;endIndex);
515     while (fieldType &gt;= 0) {
516         auto size = endIndex - beginIndex;
517         for (auto i = beginIndex; i &lt; endIndex; ++i) {
518             // Only override previous value if new value is more specific.
519             if (fields[i].size &gt;= size)
520                 fields[i] = IntlNumberFormatField(fieldType, size);
521         }
522         fieldType = ufieldpositer_next(fieldItr.get(), &amp;beginIndex, &amp;endIndex);
523     }
524 
525     JSArray* parts = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous), 0);
526     if (!parts)
527         return throwOutOfMemoryError(globalObject, scope);
528     unsigned index = 0;
529 
530     auto resultString = String(result.data(), resultLength);
531     auto typePropertyName = Identifier::fromString(vm, &quot;type&quot;);
532     auto literalString = jsNontrivialString(vm, &quot;literal&quot;_s);
533 
534     int32_t currentIndex = 0;
535     while (currentIndex &lt; resultLength) {
536         auto startIndex = currentIndex;
537         auto fieldType = fields[currentIndex].type;
538         while (currentIndex &lt; resultLength &amp;&amp; fields[currentIndex].type == fieldType)
539             ++currentIndex;
540         auto partType = fieldType == literalFieldType ? literalString : jsString(vm, partTypeString(UNumberFormatFields(fieldType), value));
541         auto partValue = jsSubstring(vm, resultString, startIndex, currentIndex - startIndex);
542         JSObject* part = constructEmptyObject(globalObject);
543         part-&gt;putDirect(vm, typePropertyName, partType);
544         part-&gt;putDirect(vm, vm.propertyNames-&gt;value, partValue);
545         parts-&gt;putDirectIndex(globalObject, index++, part);
546         RETURN_IF_EXCEPTION(scope, { });
547     }
548 
549     return parts;
550 }
551 #endif
552 
553 } // namespace JSC
554 
555 #endif // ENABLE(INTL)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLCapabilities.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FTLCapabilities.h&quot;
 28 
 29 #if ENABLE(FTL_JIT)
 30 
 31 namespace JSC { namespace FTL {
 32 
 33 using namespace DFG;
 34 
 35 static bool verboseCapabilities()
 36 {
 37     return verboseCompilationEnabled() || Options::verboseFTLFailure();
 38 }
 39 
 40 inline CapabilityLevel canCompile(Node* node)
 41 {
 42     // NOTE: If we ever have phantom arguments, we can compile them but we cannot
 43     // OSR enter.
 44 
 45     switch (node-&gt;op()) {
 46     case JSConstant:
 47     case LazyJSConstant:
 48     case GetLocal:
 49     case SetLocal:
 50     case PutStack:
 51     case KillStack:
 52     case GetStack:
 53     case MovHint:
 54     case ZombieHint:
 55     case ExitOK:
 56     case Phantom:
 57     case Flush:
 58     case PhantomLocal:
 59     case SetArgumentDefinitely:
 60     case SetArgumentMaybe:
 61     case Return:
 62     case ArithBitNot:
 63     case ArithBitAnd:
 64     case ArithBitOr:
 65     case ArithBitXor:
 66     case ArithBitRShift:
 67     case ArithBitLShift:
 68     case BitURShift:
 69     case CheckStructure:
 70     case CheckStructureOrEmpty:
 71     case DoubleAsInt32:
 72     case Arrayify:
 73     case ArrayifyToStructure:
 74     case PutStructure:
 75     case GetButterfly:
 76     case NewObject:
 77     case NewPromise:
 78     case NewGenerator:
 79     case NewAsyncGenerator:
 80     case NewStringObject:
 81     case NewSymbol:
 82     case NewArray:
 83     case NewArrayWithSpread:
 84     case NewArrayIterator:
 85     case Spread:
 86     case NewArrayBuffer:
 87     case NewTypedArray:
 88     case GetByOffset:
 89     case GetGetterSetterByOffset:
 90     case GetGetter:
 91     case GetSetter:
 92     case PutByOffset:
 93     case GetGlobalVar:
 94     case GetGlobalLexicalVariable:
 95     case PutGlobalVariable:
 96     case ValueBitAnd:
 97     case ValueBitXor:
 98     case ValueBitOr:
 99     case ValueBitNot:
100     case ValueBitLShift:
101     case ValueBitRShift:
102     case ValueNegate:
103     case ValueAdd:
104     case ValueSub:
105     case ValueMul:
106     case ValueDiv:
107     case ValueMod:
108     case ValuePow:
109     case Inc:
110     case Dec:
111     case StrCat:
112     case ArithAdd:
113     case ArithClz32:
114     case ArithSub:
115     case ArithMul:
116     case ArithDiv:
117     case ArithMod:
118     case ArithMin:
119     case ArithMax:
120     case ArithAbs:
121     case ArithPow:
122     case ArithRandom:
123     case ArithRound:
124     case ArithFloor:
125     case ArithCeil:
126     case ArithTrunc:
127     case ArithSqrt:
128     case ArithFRound:
129     case ArithNegate:
130     case ArithUnary:
131     case UInt32ToNumber:
132     case Jump:
133     case ForceOSRExit:
134     case Phi:
135     case Upsilon:
136     case ExtractOSREntryLocal:
137     case ExtractCatchLocal:
138     case ClearCatchLocals:
139     case LoopHint:
140     case SkipScope:
141     case GetGlobalObject:
142     case GetGlobalThis:
143     case CreateActivation:
144     case PushWithScope:
145     case NewFunction:
146     case NewGeneratorFunction:
147     case NewAsyncFunction:
148     case NewAsyncGeneratorFunction:
149     case GetClosureVar:
150     case PutClosureVar:
151     case GetInternalField:
152     case PutInternalField:
153     case CreateDirectArguments:
154     case CreateScopedArguments:
155     case CreateClonedArguments:
156     case CreateArgumentsButterfly:
157     case GetFromArguments:
158     case PutToArguments:
159     case GetArgument:
160     case InvalidationPoint:
161     case StringCharAt:
162     case CheckCell:
163     case CheckBadCell:
164     case CheckNotEmpty:
165     case AssertNotEmpty:
166     case CheckIdent:
167     case CheckTraps:
168     case StringCharCodeAt:
169     case StringCodePointAt:
170     case StringFromCharCode:
171     case AllocatePropertyStorage:
172     case ReallocatePropertyStorage:
173     case NukeStructureAndSetButterfly:
174     case GetTypedArrayByteOffset:
175     case GetPrototypeOf:
176     case NotifyWrite:
177     case StoreBarrier:
178     case FencedStoreBarrier:
179     case Call:
180     case DirectCall:
181     case TailCall:
182     case DirectTailCall:
183     case TailCallInlinedCaller:
184     case DirectTailCallInlinedCaller:
185     case Construct:
186     case DirectConstruct:
187     case CallVarargs:
188     case CallEval:
189     case TailCallVarargs:
190     case TailCallVarargsInlinedCaller:
191     case ConstructVarargs:
192     case CallForwardVarargs:
193     case TailCallForwardVarargs:
194     case TailCallForwardVarargsInlinedCaller:
195     case ConstructForwardVarargs:
196     case VarargsLength:
197     case LoadVarargs:
198     case ValueToInt32:
199     case Branch:
200     case LogicalNot:
201     case CheckInBounds:
202     case ConstantStoragePointer:
203     case Check:
204     case CheckVarargs:
205     case CheckArray:
206     case CheckArrayOrEmpty:
207     case CheckNeutered:
208     case CountExecution:
209     case SuperSamplerBegin:
210     case SuperSamplerEnd:
211     case GetExecutable:
212     case GetScope:
213     case GetCallee:
214     case SetCallee:
215     case GetArgumentCountIncludingThis:
216     case SetArgumentCountIncludingThis:
217     case ToNumber:
218     case ToNumeric:
219     case ToString:
220     case ToObject:
221     case CallObjectConstructor:
222     case CallStringConstructor:
223     case ObjectCreate:
224     case ObjectKeys:
225     case MakeRope:
226     case NewArrayWithSize:
227     case TryGetById:
228     case GetById:
229     case GetByIdFlush:
230     case GetByIdWithThis:
231     case GetByIdDirect:
232     case GetByIdDirectFlush:
233     case ToThis:
234     case MultiGetByOffset:
235     case MultiPutByOffset:
236     case ToPrimitive:
237     case ToPropertyKey:
238     case Throw:
239     case ThrowStaticError:
240     case Unreachable:
241     case InByVal:
242     case InById:
243     case HasOwnProperty:
244     case IsCellWithType:
245     case MapHash:
246     case NormalizeMapKey:
247     case GetMapBucket:
248     case GetMapBucketHead:
249     case GetMapBucketNext:
250     case LoadKeyFromMapBucket:
251     case LoadValueFromMapBucket:
252     case ExtractValueFromWeakMapGet:
253     case SetAdd:
254     case MapSet:
255     case WeakMapGet:
256     case WeakSetAdd:
257     case WeakMapSet:
258     case IsEmpty:
259     case IsUndefined:
260     case IsUndefinedOrNull:
261     case IsBoolean:
262     case IsNumber:
263     case NumberIsInteger:
264     case IsObject:
265     case IsObjectOrNull:
266     case IsFunction:
267     case IsTypedArrayView:
268     case CheckTypeInfoFlags:
269     case OverridesHasInstance:
270     case InstanceOf:
271     case InstanceOfCustom:
272     case DoubleRep:
273     case ValueRep:
274     case Int52Rep:
275     case DoubleConstant:
276     case Int52Constant:
277     case BooleanToNumber:
278     case HasGenericProperty:
279     case HasStructureProperty:
280     case HasIndexedProperty:
281     case GetDirectPname:
282     case GetEnumerableLength:
283     case GetIndexedPropertyStorage:
284     case GetPropertyEnumerator:
285     case GetEnumeratorStructurePname:
286     case GetEnumeratorGenericPname:
287     case ToIndexString:
288     case BottomValue:
289     case PhantomNewObject:
290     case PhantomNewFunction:
291     case PhantomNewGeneratorFunction:
292     case PhantomNewAsyncGeneratorFunction:
293     case PhantomNewAsyncFunction:
294     case PhantomNewArrayIterator:
295     case PhantomCreateActivation:
296     case PhantomNewRegexp:
297     case PutHint:
298     case CheckStructureImmediate:
299     case MaterializeNewObject:
300     case MaterializeCreateActivation:
301     case MaterializeNewInternalFieldObject:
302     case PhantomDirectArguments:
303     case PhantomCreateRest:
304     case PhantomSpread:
305     case PhantomNewArrayWithSpread:
306     case PhantomNewArrayBuffer:
307     case PhantomClonedArguments:
308     case GetMyArgumentByVal:
309     case GetMyArgumentByValOutOfBounds:
310     case ForwardVarargs:
311     case EntrySwitch:
312     case Switch:
313     case TypeOf:
314     case PutById:
315     case PutByIdDirect:
316     case PutByIdFlush:
317     case PutByIdWithThis:
318     case PutGetterById:
319     case PutSetterById:
320     case PutGetterSetterById:
321     case PutGetterByVal:
322     case PutSetterByVal:
323     case DeleteById:
324     case DeleteByVal:
325     case CreateRest:
326     case GetRestLength:
327     case RegExpExec:
328     case RegExpExecNonGlobalOrSticky:
329     case RegExpTest:
330     case RegExpMatchFast:
331     case RegExpMatchFastGlobal:
332     case NewRegexp:
333     case StringReplace:
334     case StringReplaceRegExp:
335     case GetRegExpObjectLastIndex:
336     case SetRegExpObjectLastIndex:
337     case RecordRegExpCachedResult:
338     case SetFunctionName:
339     case LogShadowChickenPrologue:
340     case LogShadowChickenTail:
341     case ResolveScope:
342     case ResolveScopeForHoistingFuncDeclInEval:
343     case GetDynamicVar:
344     case PutDynamicVar:
345     case CompareEq:
346     case CompareEqPtr:
347     case CompareLess:
348     case CompareLessEq:
349     case CompareGreater:
350     case CompareGreaterEq:
351     case CompareBelow:
352     case CompareBelowEq:
353     case CompareStrictEq:
354     case SameValue:
355     case DefineDataProperty:
356     case DefineAccessorProperty:
357     case StringValueOf:
358     case StringSlice:
359     case ToLowerCase:
360     case NumberToStringWithRadix:
361     case NumberToStringWithValidRadixConstant:
362     case CheckSubClass:
363     case CallDOM:
364     case CallDOMGetter:
365     case ArraySlice:
366     case ArrayIndexOf:
367     case ArrayPop:
368     case ArrayPush:
369     case ParseInt:
370     case AtomicsAdd:
371     case AtomicsAnd:
372     case AtomicsCompareExchange:
373     case AtomicsExchange:
374     case AtomicsLoad:
375     case AtomicsOr:
376     case AtomicsStore:
377     case AtomicsSub:
378     case AtomicsXor:
379     case AtomicsIsLockFree:
380     case InitializeEntrypointArguments:
381     case CPUIntrinsic:
382     case GetArrayLength:
383     case GetVectorLength:
384     case GetByVal:
385     case GetByValWithThis:
386     case PutByVal:
387     case PutByValAlias:
388     case PutByValDirect:
389     case PutByValWithThis:
390     case MatchStructure:
391     case FilterCallLinkStatus:
392     case FilterGetByStatus:
393     case FilterPutByIdStatus:
394     case FilterInByIdStatus:
395     case CreateThis:
396     case CreatePromise:
397     case CreateGenerator:
398     case CreateAsyncGenerator:
399     case DataViewGetInt:
400     case DataViewGetFloat:
401     case DataViewSet:
402     case DateGetInt32OrNaN:
403     case DateGetTime:
404         // These are OK.
405         break;
406 
407     case Identity:
408         // No backend handles this because it will be optimized out. But we may check
409         // for capabilities before optimization. It would be a deep error to remove this
410         // case because it would prevent us from catching bugs where the FTL backend
411         // pipeline failed to optimize out an Identity.
412         break;
413 
414     case IdentityWithProfile:
415     case CheckTierUpInLoop:
416     case CheckTierUpAndOSREnter:
417     case CheckTierUpAtReturn:
418     case FiatInt52:
419     case ArithIMul:
420     case ProfileType:
421     case ProfileControlFlow:
422     case LastNodeType:
423         return CannotCompile;
424     }
425     return CanCompileAndOSREnter;
426 }
427 
428 CapabilityLevel canCompile(Graph&amp; graph)
429 {
430     if (graph.m_codeBlock-&gt;bytecodeCost() &gt; Options::maximumFTLCandidateBytecodeCost()) {
431         if (verboseCapabilities())
432             dataLog(&quot;FTL rejecting &quot;, *graph.m_codeBlock, &quot; because it&#39;s too big.\n&quot;);
433         return CannotCompile;
434     }
435 
436     if (UNLIKELY(graph.m_codeBlock-&gt;ownerExecutable()-&gt;neverFTLOptimize())) {
437         if (verboseCapabilities())
438             dataLog(&quot;FTL rejecting &quot;, *graph.m_codeBlock, &quot; because it is marked as never FTL compile.\n&quot;);
439         return CannotCompile;
440     }
441 
442     CapabilityLevel result = CanCompileAndOSREnter;
443 
444     for (BlockIndex blockIndex = graph.numBlocks(); blockIndex--;) {
445         BasicBlock* block = graph.block(blockIndex);
446         if (!block)
447             continue;
448 
449         // We don&#39;t care if we can compile blocks that the CFA hasn&#39;t visited.
450         if (!block-&gt;cfaHasVisited)
451             continue;
452 
453         for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
454             Node* node = block-&gt;at(nodeIndex);
455 
456             for (unsigned childIndex = graph.numChildren(node); childIndex--;) {
457                 Edge edge = graph.child(node, childIndex);
458                 if (!edge)
459                     continue;
460                 switch (edge.useKind()) {
461                 case UntypedUse:
462                 case Int32Use:
463                 case KnownInt32Use:
464                 case Int52RepUse:
465                 case NumberUse:
466                 case RealNumberUse:
467                 case DoubleRepUse:
468                 case DoubleRepRealUse:
469                 case BooleanUse:
470                 case KnownBooleanUse:
471                 case CellUse:
472                 case KnownCellUse:
473                 case CellOrOtherUse:
474                 case ObjectUse:
475                 case ArrayUse:
476                 case FunctionUse:
477                 case ObjectOrOtherUse:
478                 case StringUse:
479                 case StringOrOtherUse:
480                 case KnownStringUse:
481                 case KnownPrimitiveUse:
482                 case StringObjectUse:
483                 case StringOrStringObjectUse:
484                 case SymbolUse:
485                 case BigIntUse:
486                 case DateObjectUse:
487                 case MapObjectUse:
488                 case SetObjectUse:
489                 case WeakMapObjectUse:
490                 case WeakSetObjectUse:
491                 case DataViewObjectUse:
492                 case FinalObjectUse:
493                 case PromiseObjectUse:
494                 case RegExpObjectUse:
495                 case ProxyObjectUse:
496                 case DerivedArrayUse:
497                 case NotCellUse:
498                 case OtherUse:
499                 case KnownOtherUse:
500                 case MiscUse:
501                 case StringIdentUse:
502                 case NotStringVarUse:
503                 case NotSymbolUse:
504                 case AnyIntUse:
505                 case DoubleRepAnyIntUse:
506                     // These are OK.
507                     break;
508                 default:
509                     // Don&#39;t know how to handle anything else.
510                     if (verboseCapabilities()) {
511                         dataLog(&quot;FTL rejecting node in &quot;, *graph.m_codeBlock, &quot; because of bad use kind: &quot;, edge.useKind(), &quot; in node:\n&quot;);
512                         graph.dump(WTF::dataFile(), &quot;    &quot;, node);
513                     }
514                     return CannotCompile;
515                 }
516             }
517 
518             switch (canCompile(node)) {
519             case CannotCompile:
520                 if (verboseCapabilities()) {
521                     dataLog(&quot;FTL rejecting node in &quot;, *graph.m_codeBlock, &quot;:\n&quot;);
522                     graph.dump(WTF::dataFile(), &quot;    &quot;, node);
523                 }
524                 return CannotCompile;
525 
526             case CanCompile:
527                 if (result == CanCompileAndOSREnter &amp;&amp; verboseCompilationEnabled()) {
528                     dataLog(&quot;FTL disabling OSR entry because of node:\n&quot;);
529                     graph.dump(WTF::dataFile(), &quot;    &quot;, node);
530                 }
531                 result = CanCompile;
532                 break;
533 
534             case CanCompileAndOSREnter:
535                 break;
536             }
537 
538             if (node-&gt;op() == ForceOSRExit)
539                 break;
540         }
541     }
542 
543     return result;
544 }
545 
546 } } // namespace JSC::FTL
547 
548 #endif // ENABLE(FTL_JIT)
549 
    </pre>
  </body>
</html>
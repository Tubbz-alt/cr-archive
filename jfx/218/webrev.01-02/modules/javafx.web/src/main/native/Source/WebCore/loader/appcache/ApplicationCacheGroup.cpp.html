<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/loader/appcache/ApplicationCacheGroup.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2008-2017 Apple Inc. All Rights Reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;ApplicationCacheGroup.h&quot;
  28 
  29 #include &quot;ApplicationCache.h&quot;
  30 #include &quot;ApplicationCacheHost.h&quot;
  31 #include &quot;ApplicationCacheResource.h&quot;
  32 #include &quot;ApplicationCacheResourceLoader.h&quot;
  33 #include &quot;ApplicationCacheStorage.h&quot;
  34 #include &quot;Chrome.h&quot;
  35 #include &quot;ChromeClient.h&quot;
  36 #include &quot;DOMApplicationCache.h&quot;
  37 #include &quot;DocumentLoader.h&quot;
  38 #include &quot;EventNames.h&quot;
  39 #include &quot;Frame.h&quot;
  40 #include &quot;FrameLoader.h&quot;
  41 #include &quot;FrameLoaderClient.h&quot;
  42 #include &quot;HTTPHeaderNames.h&quot;
  43 #include &quot;HTTPHeaderValues.h&quot;
  44 #include &quot;InspectorInstrumentation.h&quot;
  45 #include &quot;ManifestParser.h&quot;
  46 #include &quot;NavigationScheduler.h&quot;
  47 #include &quot;NetworkLoadMetrics.h&quot;
  48 #include &quot;Page.h&quot;
  49 #include &quot;ProgressTracker.h&quot;
  50 #include &quot;SecurityOrigin.h&quot;
  51 #include &quot;Settings.h&quot;
  52 #include &lt;wtf/CompletionHandler.h&gt;
  53 #include &lt;wtf/HashMap.h&gt;
  54 #include &lt;wtf/MainThread.h&gt;
  55 
  56 namespace WebCore {
  57 
  58 ApplicationCacheGroup::ApplicationCacheGroup(Ref&lt;ApplicationCacheStorage&gt;&amp;&amp; storage, const URL&amp; manifestURL)
  59     : m_storage(WTFMove(storage))
  60     , m_manifestURL(manifestURL)
  61     , m_origin(SecurityOrigin::create(manifestURL))
  62     , m_availableSpaceInQuota(ApplicationCacheStorage::unknownQuota())
  63 {
  64 }
  65 
  66 ApplicationCacheGroup::~ApplicationCacheGroup()
  67 {
  68     ASSERT(!m_newestCache);
  69     ASSERT(m_caches.isEmpty());
  70 
  71     stopLoading();
  72 
  73     m_storage-&gt;cacheGroupDestroyed(*this);
  74 }
  75 
  76 ApplicationCache* ApplicationCacheGroup::cacheForMainRequest(const ResourceRequest&amp; request, DocumentLoader* documentLoader)
  77 {
  78     if (!ApplicationCache::requestIsHTTPOrHTTPSGet(request))
  79         return nullptr;
  80 
  81     URL url(request.url());
  82     url.removeFragmentIdentifier();
  83 
  84     auto* page = documentLoader-&gt;frame() ? documentLoader-&gt;frame()-&gt;page() : nullptr;
  85     if (!page || page-&gt;usesEphemeralSession())
  86         return nullptr;
  87 
  88     auto* group = page-&gt;applicationCacheStorage().cacheGroupForURL(url);
  89     if (!group)
  90         return nullptr;
  91 
  92     ASSERT(group-&gt;newestCache());
  93     ASSERT(!group-&gt;isObsolete());
  94 
  95     return group-&gt;newestCache();
  96 }
  97 
  98 ApplicationCache* ApplicationCacheGroup::fallbackCacheForMainRequest(const ResourceRequest&amp; request, DocumentLoader* documentLoader)
  99 {
 100     if (!ApplicationCache::requestIsHTTPOrHTTPSGet(request))
 101         return nullptr;
 102 
 103     auto* frame = documentLoader-&gt;frame();
 104     if (!frame)
 105         return nullptr;
 106 
 107     auto* page = frame-&gt;page();
 108     if (!page)
 109         return nullptr;
 110 
 111     URL url(request.url());
 112     url.removeFragmentIdentifier();
 113 
 114     auto* group = page-&gt;applicationCacheStorage().fallbackCacheGroupForURL(url);
 115     if (!group)
 116         return nullptr;
 117 
 118     ASSERT(group-&gt;newestCache());
 119     ASSERT(!group-&gt;isObsolete());
 120 
 121     return group-&gt;newestCache();
 122 }
 123 
 124 void ApplicationCacheGroup::selectCache(Frame&amp; frame, const URL&amp; passedManifestURL)
 125 {
 126     ASSERT(frame.document());
 127     ASSERT(frame.page());
 128     ASSERT(frame.loader().documentLoader());
 129 
 130     if (!frame.settings().offlineWebApplicationCacheEnabled())
 131         return;
 132 
 133     auto&amp; documentLoader = *frame.loader().documentLoader();
 134     ASSERT(!documentLoader.applicationCacheHost().applicationCache());
 135 
 136     if (passedManifestURL.isNull()) {
 137         selectCacheWithoutManifestURL(frame);
 138         return;
 139     }
 140 
 141     // Don&#39;t access anything on disk if private browsing is enabled.
 142     if (frame.page()-&gt;usesEphemeralSession() || !frame.document()-&gt;securityOrigin().canAccessApplicationCache(frame.tree().top().document()-&gt;securityOrigin())) {
 143         postListenerTask(eventNames().checkingEvent, documentLoader);
 144         postListenerTask(eventNames().errorEvent, documentLoader);
 145         return;
 146     }
 147 
 148     URL manifestURL(passedManifestURL);
 149     manifestURL.removeFragmentIdentifier();
 150 
 151     auto* mainResourceCache = documentLoader.applicationCacheHost().mainResourceApplicationCache();
 152 
 153     if (mainResourceCache) {
 154         ASSERT(mainResourceCache-&gt;group());
 155         if (manifestURL == mainResourceCache-&gt;group()-&gt;m_manifestURL) {
 156             // The cache may have gotten obsoleted after we&#39;ve loaded from it, but before we parsed the document and saw cache manifest.
 157             if (mainResourceCache-&gt;group()-&gt;isObsolete())
 158                 return;
 159             mainResourceCache-&gt;group()-&gt;associateDocumentLoaderWithCache(&amp;documentLoader, mainResourceCache);
 160             mainResourceCache-&gt;group()-&gt;update(frame, ApplicationCacheUpdateWithBrowsingContext);
 161         } else {
 162             // The main resource was loaded from cache, so the cache must have an entry for it. Mark it as foreign.
 163             URL resourceURL { documentLoader.responseURL() };
 164             resourceURL.removeFragmentIdentifier();
 165 
 166             ASSERT(mainResourceCache-&gt;resourceForURL(resourceURL));
 167             auto&amp; resource = *mainResourceCache-&gt;resourceForURL(resourceURL);
 168 
 169             bool inStorage = resource.storageID();
 170             resource.addType(ApplicationCacheResource::Foreign);
 171             if (inStorage)
 172                 frame.page()-&gt;applicationCacheStorage().storeUpdatedType(&amp;resource, mainResourceCache);
 173 
 174             // Restart the current navigation from the top of the navigation algorithm, undoing any changes that were made
 175             // as part of the initial load.
 176             // The navigation will not result in the same resource being loaded, because &quot;foreign&quot; entries are never picked during navigation.
 177             frame.navigationScheduler().scheduleLocationChange(*frame.document(), frame.document()-&gt;securityOrigin(), documentLoader.url(), frame.loader().referrer());
 178         }
 179         return;
 180     }
 181 
 182     // The resource was loaded from the network, check if it is a HTTP/HTTPS GET.
 183     auto&amp; request = frame.loader().activeDocumentLoader()-&gt;request();
 184 
 185     if (!ApplicationCache::requestIsHTTPOrHTTPSGet(request))
 186         return;
 187 
 188     // Check that the resource URL has the same scheme/host/port as the manifest URL.
 189     if (!protocolHostAndPortAreEqual(manifestURL, request.url()))
 190         return;
 191 
 192     auto&amp; group = *frame.page()-&gt;applicationCacheStorage().findOrCreateCacheGroup(manifestURL);
 193 
 194     documentLoader.applicationCacheHost().setCandidateApplicationCacheGroup(&amp;group);
 195     group.m_pendingMasterResourceLoaders.add(&amp;documentLoader);
 196     group.m_downloadingPendingMasterResourceLoadersCount++;
 197 
 198     ASSERT(!group.m_cacheBeingUpdated || group.m_updateStatus != Idle);
 199     group.update(frame, ApplicationCacheUpdateWithBrowsingContext);
 200 }
 201 
 202 void ApplicationCacheGroup::selectCacheWithoutManifestURL(Frame&amp; frame)
 203 {
 204     if (!frame.settings().offlineWebApplicationCacheEnabled())
 205         return;
 206 
 207     ASSERT(frame.document());
 208     ASSERT(frame.page());
 209     ASSERT(frame.loader().documentLoader());
 210     auto&amp; documentLoader = *frame.loader().documentLoader();
 211     ASSERT(!documentLoader.applicationCacheHost().applicationCache());
 212 
 213     // Don&#39;t access anything on disk if private browsing is enabled.
 214     if (frame.page()-&gt;usesEphemeralSession() || !frame.document()-&gt;securityOrigin().canAccessApplicationCache(frame.tree().top().document()-&gt;securityOrigin())) {
 215         postListenerTask(eventNames().checkingEvent, documentLoader);
 216         postListenerTask(eventNames().errorEvent, documentLoader);
 217         return;
 218     }
 219 
 220     if (auto* mainResourceCache = documentLoader.applicationCacheHost().mainResourceApplicationCache()) {
 221         ASSERT(mainResourceCache-&gt;group());
 222         auto&amp; group = *mainResourceCache-&gt;group();
 223         group.associateDocumentLoaderWithCache(&amp;documentLoader, mainResourceCache);
 224         group.update(frame, ApplicationCacheUpdateWithBrowsingContext);
 225     }
 226 }
 227 
 228 void ApplicationCacheGroup::finishedLoadingMainResource(DocumentLoader&amp; loader)
 229 {
 230     ASSERT(m_pendingMasterResourceLoaders.contains(&amp;loader));
 231     ASSERT(m_completionType == None || m_pendingEntries.isEmpty());
 232     URL url = loader.url();
 233     url.removeFragmentIdentifier();
 234 
 235     switch (m_completionType) {
 236     case None:
 237         // The main resource finished loading before the manifest was ready. It will be handled via dispatchMainResources() later.
 238         return;
 239     case NoUpdate:
 240         ASSERT(!m_cacheBeingUpdated);
 241         associateDocumentLoaderWithCache(&amp;loader, m_newestCache.get());
 242         if (auto* resource = m_newestCache-&gt;resourceForURL(url)) {
 243             if (!(resource-&gt;type() &amp; ApplicationCacheResource::Master)) {
 244                 resource-&gt;addType(ApplicationCacheResource::Master);
 245                 ASSERT(!resource-&gt;storageID());
 246             }
 247         } else
 248             m_newestCache-&gt;addResource(ApplicationCacheResource::create(url, loader.response(), ApplicationCacheResource::Master, loader.mainResourceData()));
 249         break;
 250     case Failure:
 251         // Cache update has been a failure, so there is no reason to keep the document associated with the incomplete cache
 252         // (its main resource was not cached yet, so it is likely that the application changed significantly server-side).
 253         ASSERT(!m_cacheBeingUpdated); // Already cleared out by stopLoading().
 254         loader.applicationCacheHost().setApplicationCache(nullptr); // Will unset candidate, too.
 255         m_associatedDocumentLoaders.remove(&amp;loader);
 256         postListenerTask(eventNames().errorEvent, loader);
 257         break;
 258     case Completed:
 259         ASSERT(m_associatedDocumentLoaders.contains(&amp;loader));
 260         if (auto* resource = m_cacheBeingUpdated-&gt;resourceForURL(url)) {
 261             if (!(resource-&gt;type() &amp; ApplicationCacheResource::Master)) {
 262                 resource-&gt;addType(ApplicationCacheResource::Master);
 263                 ASSERT(!resource-&gt;storageID());
 264             }
 265         } else
 266             m_cacheBeingUpdated-&gt;addResource(ApplicationCacheResource::create(url, loader.response(), ApplicationCacheResource::Master, loader.mainResourceData()));
 267         // The &quot;cached&quot; event will be posted to all associated documents once update is complete.
 268         break;
 269     }
 270 
 271     ASSERT(m_downloadingPendingMasterResourceLoadersCount &gt; 0);
 272     m_downloadingPendingMasterResourceLoadersCount--;
 273     checkIfLoadIsComplete();
 274 }
 275 
 276 void ApplicationCacheGroup::failedLoadingMainResource(DocumentLoader&amp; loader)
 277 {
 278     ASSERT(m_pendingMasterResourceLoaders.contains(&amp;loader));
 279     ASSERT(m_completionType == None || m_pendingEntries.isEmpty());
 280 
 281     switch (m_completionType) {
 282     case None:
 283         // The main resource finished loading before the manifest was ready. It will be handled via dispatchMainResources() later.
 284         return;
 285     case NoUpdate:
 286         ASSERT(!m_cacheBeingUpdated);
 287         // The manifest didn&#39;t change, and we have a relevant cache - but the main resource download failed mid-way, so it cannot be stored to the cache,
 288         // and the loader does not get associated to it. If there are other main resources being downloaded for this cache group, they may still succeed.
 289         postListenerTask(eventNames().errorEvent, loader);
 290         break;
 291     case Failure:
 292         // Cache update failed, too.
 293         ASSERT(!m_cacheBeingUpdated); // Already cleared out by stopLoading().
 294         ASSERT(!loader.applicationCacheHost().applicationCache() || loader.applicationCacheHost().applicationCache()-&gt;group() == this);
 295         loader.applicationCacheHost().setApplicationCache(nullptr); // Will unset candidate, too.
 296         m_associatedDocumentLoaders.remove(&amp;loader);
 297         postListenerTask(eventNames().errorEvent, loader);
 298         break;
 299     case Completed:
 300         // The cache manifest didn&#39;t list this main resource, and all cache entries were already updated successfully - but the main resource failed to load,
 301         // so it cannot be stored to the cache. If there are other main resources being downloaded for this cache group, they may still succeed.
 302         ASSERT(m_associatedDocumentLoaders.contains(&amp;loader));
 303         ASSERT(loader.applicationCacheHost().applicationCache() == m_cacheBeingUpdated);
 304         ASSERT(!loader.applicationCacheHost().candidateApplicationCacheGroup());
 305         m_associatedDocumentLoaders.remove(&amp;loader);
 306         loader.applicationCacheHost().setApplicationCache(nullptr);
 307         postListenerTask(eventNames().errorEvent, loader);
 308         break;
 309     }
 310 
 311     ASSERT(m_downloadingPendingMasterResourceLoadersCount &gt; 0);
 312     m_downloadingPendingMasterResourceLoadersCount--;
 313     checkIfLoadIsComplete();
 314 }
 315 
 316 void ApplicationCacheGroup::stopLoading()
 317 {
 318     if (m_manifestLoader) {
 319         m_manifestLoader-&gt;cancel();
 320         m_manifestLoader = nullptr;
 321     }
 322 
 323     if (m_entryLoader) {
 324         m_entryLoader-&gt;cancel();
 325         m_entryLoader = nullptr;
 326     }
 327 
 328     // FIXME: Resetting just a tiny part of the state in this function is confusing. Callers have to take care of a lot more.
 329     m_cacheBeingUpdated = nullptr;
 330     m_pendingEntries.clear();
 331 }
 332 
 333 void ApplicationCacheGroup::disassociateDocumentLoader(DocumentLoader&amp; loader)
 334 {
 335     m_associatedDocumentLoaders.remove(&amp;loader);
 336     m_pendingMasterResourceLoaders.remove(&amp;loader);
 337 
 338     if (auto* host = loader.applicationCacheHostUnlessBeingDestroyed())
 339         host-&gt;setApplicationCache(nullptr); // Will set candidate group to null, too.
 340 
 341     if (!m_associatedDocumentLoaders.isEmpty() || !m_pendingMasterResourceLoaders.isEmpty())
 342         return;
 343 
 344     if (m_caches.isEmpty()) {
 345         // There is an initial cache attempt in progress.
 346         ASSERT(!m_newestCache);
 347         // Delete ourselves, causing the cache attempt to be stopped.
 348         delete this;
 349         return;
 350     }
 351 
 352     ASSERT(m_caches.contains(m_newestCache.get()));
 353 
 354     // Release our reference to the newest cache. This could cause us to be deleted.
 355     // Any ongoing updates will be stopped from destructor.
 356     m_newestCache = nullptr;
 357 }
 358 
 359 void ApplicationCacheGroup::cacheDestroyed(ApplicationCache&amp; cache)
 360 {
 361     if (m_caches.remove(&amp;cache) &amp;&amp; m_caches.isEmpty()) {
 362         ASSERT(m_associatedDocumentLoaders.isEmpty());
 363         ASSERT(m_pendingMasterResourceLoaders.isEmpty());
 364         delete this;
 365     }
 366 }
 367 
 368 void ApplicationCacheGroup::stopLoadingInFrame(Frame&amp; frame)
 369 {
 370     if (&amp;frame != m_frame)
 371         return;
 372 
 373     cacheUpdateFailed();
 374 }
 375 
 376 void ApplicationCacheGroup::setNewestCache(Ref&lt;ApplicationCache&gt;&amp;&amp; newestCache)
 377 {
 378     m_newestCache = WTFMove(newestCache);
 379 
 380     m_caches.add(m_newestCache.get());
 381     m_newestCache-&gt;setGroup(this);
 382 }
 383 
 384 void ApplicationCacheGroup::makeObsolete()
 385 {
 386     if (isObsolete())
 387         return;
 388 
 389     m_isObsolete = true;
 390     m_storage-&gt;cacheGroupMadeObsolete(*this);
 391     ASSERT(!m_storageID);
 392 }
 393 
 394 void ApplicationCacheGroup::update(Frame&amp; frame, ApplicationCacheUpdateOption updateOption)
 395 {
 396     ASSERT(frame.loader().documentLoader());
 397     auto&amp; documentLoader = *frame.loader().documentLoader();
 398 
 399     if (m_updateStatus == Checking || m_updateStatus == Downloading) {
 400         if (updateOption == ApplicationCacheUpdateWithBrowsingContext) {
 401             postListenerTask(eventNames().checkingEvent, documentLoader);
 402             if (m_updateStatus == Downloading)
 403                 postListenerTask(eventNames().downloadingEvent, documentLoader);
 404         }
 405         return;
 406     }
 407 
 408     // Don&#39;t access anything on disk if private browsing is enabled.
 409     if (frame.page()-&gt;usesEphemeralSession() || !frame.document()-&gt;securityOrigin().canAccessApplicationCache(frame.tree().top().document()-&gt;securityOrigin())) {
 410         ASSERT(m_pendingMasterResourceLoaders.isEmpty());
 411         ASSERT(m_pendingEntries.isEmpty());
 412         ASSERT(!m_cacheBeingUpdated);
 413         postListenerTask(eventNames().checkingEvent, documentLoader);
 414         postListenerTask(eventNames().errorEvent, documentLoader);
 415         return;
 416     }
 417 
 418     ASSERT(!m_frame);
 419     m_frame = &amp;frame;
 420 
 421     setUpdateStatus(Checking);
 422 
 423     postListenerTask(eventNames().checkingEvent, m_associatedDocumentLoaders);
 424     if (!m_newestCache) {
 425         ASSERT(updateOption == ApplicationCacheUpdateWithBrowsingContext);
 426         postListenerTask(eventNames().checkingEvent, documentLoader);
 427     }
 428 
 429     ASSERT(!m_manifestLoader);
 430     ASSERT(!m_entryLoader);
 431     ASSERT(!m_manifestResource);
 432     ASSERT(!m_currentResource);
 433     ASSERT(m_completionType == None);
 434 
 435     // FIXME: Handle defer loading
 436 
 437     auto request = createRequest(URL { m_manifestURL }, m_newestCache ? m_newestCache-&gt;manifestResource() : nullptr);
 438 
 439     m_currentResourceIdentifier = m_frame-&gt;page()-&gt;progress().createUniqueIdentifier();
 440     InspectorInstrumentation::willSendRequest(m_frame, m_currentResourceIdentifier, m_frame-&gt;loader().documentLoader(), request, ResourceResponse { });
 441 
 442     m_manifestLoader = ApplicationCacheResourceLoader::create(ApplicationCacheResource::Type::Manifest, documentLoader.cachedResourceLoader(), WTFMove(request), [this] (auto&amp;&amp; resourceOrError) {
 443         // &#39;this&#39; is only valid if returned value is not Error::Abort.
 444         if (!resourceOrError.has_value()) {
 445             auto error = resourceOrError.error();
 446             if (error == ApplicationCacheResourceLoader::Error::Abort)
 447                 return;
 448             if (error == ApplicationCacheResourceLoader::Error::CannotCreateResource) {
 449                 // FIXME: We should get back the error from ApplicationCacheResourceLoader level.
 450                 InspectorInstrumentation::didFailLoading(m_frame, m_frame-&gt;loader().documentLoader(), m_currentResourceIdentifier, ResourceError { ResourceError::Type::AccessControl });
 451                 this-&gt;cacheUpdateFailed();
 452                 return;
 453             }
 454             this-&gt;didFailLoadingManifest(error);
 455             return;
 456         }
 457 
 458         m_manifestResource = WTFMove(resourceOrError.value());
 459         this-&gt;didFinishLoadingManifest();
 460     });
 461 }
 462 
 463 ResourceRequest ApplicationCacheGroup::createRequest(URL&amp;&amp; url, ApplicationCacheResource* resource)
 464 {
 465     ResourceRequest request { WTFMove(url) };
 466     m_frame-&gt;loader().applyUserAgentIfNeeded(request);
 467     request.setHTTPHeaderField(HTTPHeaderName::CacheControl, HTTPHeaderValues::maxAge0());
 468 
 469     if (resource) {
 470         const String&amp; lastModified = resource-&gt;response().httpHeaderField(HTTPHeaderName::LastModified);
 471         if (!lastModified.isEmpty())
 472             request.setHTTPHeaderField(HTTPHeaderName::IfModifiedSince, lastModified);
 473 
 474         const String&amp; eTag = resource-&gt;response().httpHeaderField(HTTPHeaderName::ETag);
 475         if (!eTag.isEmpty())
 476             request.setHTTPHeaderField(HTTPHeaderName::IfNoneMatch, eTag);
 477     }
 478     return request;
 479 }
 480 
 481 void ApplicationCacheGroup::abort(Frame&amp; frame)
 482 {
 483     if (m_updateStatus == Idle)
 484         return;
 485     ASSERT(m_updateStatus == Checking || (m_updateStatus == Downloading &amp;&amp; m_cacheBeingUpdated));
 486 
 487     if (m_completionType != None)
 488         return;
 489 
 490     frame.document()-&gt;addConsoleMessage(MessageSource::AppCache, MessageLevel::Debug, &quot;Application Cache download process was aborted.&quot;_s);
 491     cacheUpdateFailed();
 492 }
 493 
 494 void ApplicationCacheGroup::didFinishLoadingEntry(const URL&amp; entryURL)
 495 {
 496     // FIXME: We should have NetworkLoadMetrics for ApplicationCache loads.
 497     NetworkLoadMetrics emptyMetrics;
 498     InspectorInstrumentation::didFinishLoading(m_frame, m_frame-&gt;loader().documentLoader(), m_currentResourceIdentifier, emptyMetrics, nullptr);
 499 
 500     ASSERT(m_pendingEntries.contains(entryURL));
 501 
 502     auto type = m_pendingEntries.take(entryURL);
 503 
 504     ASSERT(m_cacheBeingUpdated);
 505 
 506     // Did we received a 304?
 507     if (!m_currentResource) {
 508         if (m_newestCache) {
 509             ApplicationCacheResource* newestCachedResource = m_newestCache-&gt;resourceForURL(entryURL);
 510             if (newestCachedResource) {
 511                 m_cacheBeingUpdated-&gt;addResource(ApplicationCacheResource::create(entryURL, newestCachedResource-&gt;response(), type, &amp;newestCachedResource-&gt;data(), newestCachedResource-&gt;path()));
 512                 m_entryLoader = nullptr;
 513                 startLoadingEntry();
 514                 return;
 515             }
 516         }
 517         // The server could return 304 for an unconditional request - in this case, we handle the response as a normal error.
 518         m_entryLoader = nullptr;
 519         startLoadingEntry();
 520         return;
 521     }
 522 
 523     m_cacheBeingUpdated-&gt;addResource(m_currentResource.releaseNonNull());
 524     m_entryLoader = nullptr;
 525 
 526     // While downloading check to see if we have exceeded the available quota.
 527     // We can stop immediately if we have already previously failed
 528     // due to an earlier quota restriction. The client was already notified
 529     // of the quota being reached and decided not to increase it then.
 530     // FIXME: Should we break earlier and prevent redownloading on later page loads?
 531     if (m_originQuotaExceededPreviously &amp;&amp; m_availableSpaceInQuota &lt; m_cacheBeingUpdated-&gt;estimatedSizeInStorage()) {
 532         m_currentResource = nullptr;
 533         m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::AppCache, MessageLevel::Error, &quot;Application Cache update failed, because size quota was exceeded.&quot;_s);
 534         cacheUpdateFailed();
 535         return;
 536     }
 537 
 538     // Load the next resource, if any.
 539     startLoadingEntry();
 540 }
 541 
 542 void ApplicationCacheGroup::didFailLoadingEntry(ApplicationCacheResourceLoader::Error error, const URL&amp; entryURL, unsigned type)
 543 {
 544     // FIXME: We should get back the error from ApplicationCacheResourceLoader level.
 545     ResourceError resourceError { error == ApplicationCacheResourceLoader::Error::CannotCreateResource ? ResourceError::Type::AccessControl : ResourceError::Type::General };
 546 
 547     InspectorInstrumentation::didFailLoading(m_frame, m_frame-&gt;loader().documentLoader(), m_currentResourceIdentifier, resourceError);
 548 
 549     URL url(entryURL);
 550     url.removeFragmentIdentifier();
 551 
 552     ASSERT(!m_currentResource || !m_pendingEntries.contains(url));
 553     m_currentResource = nullptr;
 554     m_pendingEntries.remove(url);
 555 
 556     if ((type &amp; ApplicationCacheResource::Explicit) || (type &amp; ApplicationCacheResource::Fallback)) {
 557         m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::AppCache, MessageLevel::Error, makeString(&quot;Application Cache update failed, because &quot;, url.stringCenterEllipsizedToLength(), (m_entryLoader &amp;&amp; m_entryLoader-&gt;hasRedirection() ? &quot; was redirected.&quot; : &quot; could not be fetched.&quot;)));
 558         // Note that cacheUpdateFailed() can cause the cache group to be deleted.
 559         cacheUpdateFailed();
 560         return;
 561     }
 562 
 563     if (error == ApplicationCacheResourceLoader::Error::NotFound) {
 564         // Skip this resource. It is dropped from the cache.
 565         m_pendingEntries.remove(url);
 566         startLoadingEntry();
 567         return;
 568     }
 569 
 570     // Copy the resource and its metadata from the newest application cache in cache group whose completeness flag is complete, and act
 571     // as if that was the fetched resource, ignoring the resource obtained from the network.
 572     ASSERT(m_newestCache);
 573     ApplicationCacheResource* newestCachedResource = m_newestCache-&gt;resourceForURL(url);
 574     ASSERT(newestCachedResource);
 575     m_cacheBeingUpdated-&gt;addResource(ApplicationCacheResource::create(url, newestCachedResource-&gt;response(), type, &amp;newestCachedResource-&gt;data(), newestCachedResource-&gt;path()));
 576     // Load the next resource, if any.
 577     startLoadingEntry();
 578 }
 579 
 580 void ApplicationCacheGroup::didFinishLoadingManifest()
 581 {
 582     bool isUpgradeAttempt = m_newestCache;
 583 
 584     if (!isUpgradeAttempt &amp;&amp; !m_manifestResource) {
 585         // The server returned 304 Not Modified even though we didn&#39;t send a conditional request.
 586         m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::AppCache, MessageLevel::Error, &quot;Application Cache manifest could not be fetched because of an unexpected 304 Not Modified server response.&quot;_s);
 587         cacheUpdateFailed();
 588         return;
 589     }
 590 
 591     m_manifestLoader = nullptr;
 592 
 593     // Check if the manifest was not modified.
 594     if (isUpgradeAttempt) {
 595         ApplicationCacheResource* newestManifest = m_newestCache-&gt;manifestResource();
 596         ASSERT(newestManifest);
 597 
 598         if (!m_manifestResource || // The resource will be null if HTTP response was 304 Not Modified.
 599             (newestManifest-&gt;data().size() == m_manifestResource-&gt;data().size() &amp;&amp; !memcmp(newestManifest-&gt;data().data(), m_manifestResource-&gt;data().data(), newestManifest-&gt;data().size()))) {
 600 
 601             m_completionType = NoUpdate;
 602             m_manifestResource = nullptr;
 603             deliverDelayedMainResources();
 604 
 605             return;
 606         }
 607     }
 608 
 609     Manifest manifest;
 610     if (!parseManifest(m_manifestURL, m_manifestResource-&gt;response().mimeType(), m_manifestResource-&gt;data().data(), m_manifestResource-&gt;data().size(), manifest)) {
 611         // At the time of this writing, lack of &quot;CACHE MANIFEST&quot; signature is the only reason for parseManifest to fail.
 612         m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::AppCache, MessageLevel::Error, &quot;Application Cache manifest could not be parsed. Does it start with CACHE MANIFEST?&quot;_s);
 613         cacheUpdateFailed();
 614         return;
 615     }
 616 
 617     ASSERT(!m_cacheBeingUpdated);
 618     m_cacheBeingUpdated = ApplicationCache::create();
 619     m_cacheBeingUpdated-&gt;setGroup(this);
 620 
 621     for (auto&amp; loader : m_pendingMasterResourceLoaders)
 622         associateDocumentLoaderWithCache(loader, m_cacheBeingUpdated.get());
 623 
 624     // We have the manifest, now download the resources.
 625     setUpdateStatus(Downloading);
 626 
 627     postListenerTask(eventNames().downloadingEvent, m_associatedDocumentLoaders);
 628 
 629     ASSERT(m_pendingEntries.isEmpty());
 630 
 631     if (isUpgradeAttempt) {
 632         for (const auto&amp; urlAndResource : m_newestCache-&gt;resources()) {
 633             unsigned type = urlAndResource.value-&gt;type();
 634             if (type &amp; ApplicationCacheResource::Master)
 635                 addEntry(urlAndResource.key, type);
 636         }
 637     }
 638 
 639     for (const auto&amp; explicitURL : manifest.explicitURLs)
 640         addEntry(explicitURL, ApplicationCacheResource::Explicit);
 641 
 642     for (auto&amp; fallbackURL : manifest.fallbackURLs)
 643         addEntry(fallbackURL.second, ApplicationCacheResource::Fallback);
 644 
 645     m_cacheBeingUpdated-&gt;setOnlineWhitelist(manifest.onlineWhitelistedURLs);
 646     m_cacheBeingUpdated-&gt;setFallbackURLs(manifest.fallbackURLs);
 647     m_cacheBeingUpdated-&gt;setAllowsAllNetworkRequests(manifest.allowAllNetworkRequests);
 648 
 649     m_progressTotal = m_pendingEntries.size();
 650     m_progressDone = 0;
 651 
 652     recalculateAvailableSpaceInQuota();
 653 
 654     startLoadingEntry();
 655 }
 656 
 657 void ApplicationCacheGroup::didFailLoadingManifest(ApplicationCacheResourceLoader::Error error)
 658 {
 659     ASSERT(error != ApplicationCacheResourceLoader::Error::Abort &amp;&amp; error != ApplicationCacheResourceLoader::Error::CannotCreateResource);
 660 
 661     InspectorInstrumentation::didReceiveResourceResponse(*m_frame, m_currentResourceIdentifier, m_frame-&gt;loader().documentLoader(), m_manifestLoader-&gt;resource()-&gt;response(), nullptr);
 662     switch (error) {
 663     case ApplicationCacheResourceLoader::Error::NetworkError:
 664         cacheUpdateFailed();
 665         break;
 666     case ApplicationCacheResourceLoader::Error::NotFound:
 667         InspectorInstrumentation::didFailLoading(m_frame, m_frame-&gt;loader().documentLoader(), m_currentResourceIdentifier, m_frame-&gt;loader().cancelledError(m_manifestLoader-&gt;resource()-&gt;resourceRequest()));
 668         m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::AppCache, MessageLevel::Error, makeString(&quot;Application Cache manifest could not be fetched, because the manifest had a &quot;, m_manifestLoader-&gt;resource()-&gt;response().httpStatusCode(), &quot; response.&quot;));
 669         manifestNotFound();
 670         break;
 671     case ApplicationCacheResourceLoader::Error::NotOK:
 672         InspectorInstrumentation::didFailLoading(m_frame, m_frame-&gt;loader().documentLoader(), m_currentResourceIdentifier, m_frame-&gt;loader().cancelledError(m_manifestLoader-&gt;resource()-&gt;resourceRequest()));
 673         m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::AppCache, MessageLevel::Error, makeString(&quot;Application Cache manifest could not be fetched, because the manifest had a &quot;, m_manifestLoader-&gt;resource()-&gt;response().httpStatusCode(), &quot; response.&quot;));
 674         cacheUpdateFailed();
 675         break;
 676     case ApplicationCacheResourceLoader::Error::RedirectForbidden:
 677         InspectorInstrumentation::didFailLoading(m_frame, m_frame-&gt;loader().documentLoader(), m_currentResourceIdentifier, m_frame-&gt;loader().cancelledError(m_manifestLoader-&gt;resource()-&gt;resourceRequest()));
 678         m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::AppCache, MessageLevel::Error, &quot;Application Cache manifest could not be fetched, because a redirection was attempted.&quot;_s);
 679         cacheUpdateFailed();
 680         break;
 681     case ApplicationCacheResourceLoader::Error::CannotCreateResource:
 682     case ApplicationCacheResourceLoader::Error::Abort:
 683         break;
 684     }
 685 }
 686 
 687 void ApplicationCacheGroup::didReachMaxAppCacheSize()
 688 {
 689     ASSERT(m_frame);
 690     ASSERT(m_cacheBeingUpdated);
 691     m_frame-&gt;page()-&gt;chrome().client().reachedMaxAppCacheSize(m_frame-&gt;page()-&gt;applicationCacheStorage().spaceNeeded(m_cacheBeingUpdated-&gt;estimatedSizeInStorage()));
 692     m_calledReachedMaxAppCacheSize = true;
 693     checkIfLoadIsComplete();
 694 }
 695 
 696 void ApplicationCacheGroup::didReachOriginQuota(int64_t totalSpaceNeeded)
 697 {
 698     // Inform the client the origin quota has been reached, they may decide to increase the quota.
 699     // We expect quota to be increased synchronously while waiting for the call to return.
 700     m_frame-&gt;page()-&gt;chrome().client().reachedApplicationCacheOriginQuota(m_origin.get(), totalSpaceNeeded);
 701 }
 702 
 703 void ApplicationCacheGroup::cacheUpdateFailed()
 704 {
 705     stopLoading();
 706     m_manifestResource = nullptr;
 707 
 708     // Wait for master resource loads to finish.
 709     m_completionType = Failure;
 710     deliverDelayedMainResources();
 711 }
 712 
 713 void ApplicationCacheGroup::recalculateAvailableSpaceInQuota()
 714 {
 715     if (!m_frame-&gt;page()-&gt;applicationCacheStorage().calculateRemainingSizeForOriginExcludingCache(m_origin, m_newestCache.get(), m_availableSpaceInQuota)) {
 716         // Failed to determine what is left in the quota. Fallback to allowing anything.
 717         m_availableSpaceInQuota = ApplicationCacheStorage::noQuota();
 718     }
 719 }
 720 
 721 void ApplicationCacheGroup::manifestNotFound()
 722 {
 723     makeObsolete();
 724 
 725     postListenerTask(eventNames().obsoleteEvent, m_associatedDocumentLoaders);
 726     postListenerTask(eventNames().errorEvent, m_pendingMasterResourceLoaders);
 727 
 728     stopLoading();
 729 
 730     ASSERT(m_pendingEntries.isEmpty());
 731     m_manifestResource = nullptr;
 732 
 733     while (!m_pendingMasterResourceLoaders.isEmpty()) {
 734         HashSet&lt;DocumentLoader*&gt;::iterator it = m_pendingMasterResourceLoaders.begin();
 735 
 736         ASSERT((*it)-&gt;applicationCacheHost().candidateApplicationCacheGroup() == this);
 737         ASSERT(!(*it)-&gt;applicationCacheHost().applicationCache());
 738         (*it)-&gt;applicationCacheHost().setCandidateApplicationCacheGroup(nullptr);
 739         m_pendingMasterResourceLoaders.remove(it);
 740     }
 741 
 742     m_downloadingPendingMasterResourceLoadersCount = 0;
 743     setUpdateStatus(Idle);
 744     m_frame = nullptr;
 745 
 746     if (m_caches.isEmpty()) {
 747         ASSERT(m_associatedDocumentLoaders.isEmpty());
 748         ASSERT(!m_cacheBeingUpdated);
 749         delete this;
 750     }
 751 }
 752 
 753 void ApplicationCacheGroup::checkIfLoadIsComplete()
 754 {
 755     if (m_manifestLoader || m_entryLoader || !m_pendingEntries.isEmpty() || m_downloadingPendingMasterResourceLoadersCount)
 756         return;
 757 
 758     // We&#39;re done, all resources have finished downloading (successfully or not).
 759 
 760     bool isUpgradeAttempt = m_newestCache;
 761 
 762     switch (m_completionType) {
 763     case None:
 764         ASSERT_NOT_REACHED();
 765         return;
 766     case NoUpdate:
 767         ASSERT(isUpgradeAttempt);
 768         ASSERT(!m_cacheBeingUpdated);
 769 
 770         // The storage could have been manually emptied by the user.
 771         if (!m_storageID)
 772             m_storage-&gt;storeNewestCache(*this);
 773 
 774         postListenerTask(eventNames().noupdateEvent, m_associatedDocumentLoaders);
 775         break;
 776     case Failure:
 777         ASSERT(!m_cacheBeingUpdated);
 778         postListenerTask(eventNames().errorEvent, m_associatedDocumentLoaders);
 779         if (m_caches.isEmpty()) {
 780             ASSERT(m_associatedDocumentLoaders.isEmpty());
 781             delete this;
 782             return;
 783         }
 784         break;
 785     case Completed: {
 786         // FIXME: Fetch the resource from manifest URL again, and check whether it is identical to the one used for update (in case the application was upgraded server-side in the meanwhile). (&lt;rdar://problem/6467625&gt;)
 787 
 788         ASSERT(m_cacheBeingUpdated);
 789         if (m_manifestResource)
 790             m_cacheBeingUpdated-&gt;setManifestResource(m_manifestResource.releaseNonNull());
 791         else {
 792             // We can get here as a result of retrying the Complete step, following
 793             // a failure of the cache storage to save the newest cache due to hitting
 794             // the maximum size. In such a case, m_manifestResource may be 0, as
 795             // the manifest was already set on the newest cache object.
 796             ASSERT(m_cacheBeingUpdated-&gt;manifestResource());
 797             ASSERT(m_storage-&gt;isMaximumSizeReached());
 798             ASSERT(m_calledReachedMaxAppCacheSize);
 799         }
 800 
 801         RefPtr&lt;ApplicationCache&gt; oldNewestCache = (m_newestCache == m_cacheBeingUpdated) ? RefPtr&lt;ApplicationCache&gt;() : m_newestCache;
 802 
 803         // If we exceeded the origin quota while downloading we can request a quota
 804         // increase now, before we attempt to store the cache.
 805         int64_t totalSpaceNeeded;
 806         if (!m_storage-&gt;checkOriginQuota(this, oldNewestCache.get(), m_cacheBeingUpdated.get(), totalSpaceNeeded))
 807             didReachOriginQuota(totalSpaceNeeded);
 808 
 809         ApplicationCacheStorage::FailureReason failureReason;
 810         setNewestCache(m_cacheBeingUpdated.releaseNonNull());
 811         if (m_storage-&gt;storeNewestCache(*this, oldNewestCache.get(), failureReason)) {
 812             // New cache stored, now remove the old cache.
 813             if (oldNewestCache)
 814                 m_storage-&gt;remove(oldNewestCache.get());
 815 
 816             // Fire the final progress event.
 817             ASSERT(m_progressDone == m_progressTotal);
 818             postListenerTask(eventNames().progressEvent, m_progressTotal, m_progressDone, m_associatedDocumentLoaders);
 819 
 820             // Fire the success event.
 821             postListenerTask(isUpgradeAttempt ? eventNames().updatereadyEvent : eventNames().cachedEvent, m_associatedDocumentLoaders);
 822             // It is clear that the origin quota was not reached, so clear the flag if it was set.
 823             m_originQuotaExceededPreviously = false;
 824         } else {
 825             if (failureReason == ApplicationCacheStorage::OriginQuotaReached) {
 826                 // We ran out of space for this origin. Fall down to the normal error handling
 827                 // after recording this state.
 828                 m_originQuotaExceededPreviously = true;
 829                 m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::AppCache, MessageLevel::Error, &quot;Application Cache update failed, because size quota was exceeded.&quot;_s);
 830             }
 831 
 832             if (failureReason == ApplicationCacheStorage::TotalQuotaReached &amp;&amp; !m_calledReachedMaxAppCacheSize) {
 833                 // FIXME: Should this be handled more like Origin Quotas? Does this fail properly?
 834 
 835                 // We ran out of space. All the changes in the cache storage have
 836                 // been rolled back. We roll back to the previous state in here,
 837                 // as well, call the chrome client asynchronously and retry to
 838                 // save the new cache.
 839 
 840                 // Save a reference to the new cache.
 841                 m_cacheBeingUpdated = WTFMove(m_newestCache);
 842                 if (oldNewestCache)
 843                     setNewestCache(oldNewestCache.releaseNonNull());
 844                 scheduleReachedMaxAppCacheSizeCallback();
 845                 return;
 846             }
 847 
 848             // Run the &quot;cache failure steps&quot;
 849             // Fire the error events to all pending master entries, as well any other cache hosts
 850             // currently associated with a cache in this group.
 851             postListenerTask(eventNames().errorEvent, m_associatedDocumentLoaders);
 852             // Disassociate the pending master entries from the failed new cache. Note that
 853             // all other loaders in the m_associatedDocumentLoaders are still associated with
 854             // some other cache in this group. They are not associated with the failed new cache.
 855 
 856             // Need to copy loaders, because the cache group may be destroyed at the end of iteration.
 857             for (auto&amp; loader : copyToVector(m_pendingMasterResourceLoaders))
 858                 disassociateDocumentLoader(*loader); // This can delete this group.
 859 
 860             // Reinstate the oldNewestCache, if there was one.
 861             if (oldNewestCache) {
 862                 // This will discard the failed new cache.
 863                 setNewestCache(oldNewestCache.releaseNonNull());
 864             } else {
 865                 // We must have been deleted by the last call to disassociateDocumentLoader().
 866                 return;
 867             }
 868         }
 869         break;
 870     }
 871     }
 872 
 873     // Empty cache group&#39;s list of pending master entries.
 874     m_pendingMasterResourceLoaders.clear();
 875     m_completionType = None;
 876     setUpdateStatus(Idle);
 877     m_frame = nullptr;
 878     m_availableSpaceInQuota = ApplicationCacheStorage::unknownQuota();
 879     m_calledReachedMaxAppCacheSize = false;
 880 }
 881 
 882 void ApplicationCacheGroup::startLoadingEntry()
 883 {
 884     ASSERT(m_cacheBeingUpdated);
 885 
 886     if (m_pendingEntries.isEmpty()) {
 887         m_completionType = Completed;
 888         deliverDelayedMainResources();
 889         return;
 890     }
 891 
 892     auto firstPendingEntryURL = m_pendingEntries.begin()-&gt;key;
 893 
 894     postListenerTask(eventNames().progressEvent, m_progressTotal, m_progressDone, m_associatedDocumentLoaders);
 895     m_progressDone++;
 896 
 897     ASSERT(!m_manifestLoader);
 898     ASSERT(!m_entryLoader);
 899 
 900     auto request = createRequest(URL { { }, firstPendingEntryURL }, m_newestCache ? m_newestCache-&gt;resourceForURL(firstPendingEntryURL) : nullptr);
 901 
 902     m_currentResourceIdentifier = m_frame-&gt;page()-&gt;progress().createUniqueIdentifier();
 903     InspectorInstrumentation::willSendRequest(m_frame, m_currentResourceIdentifier, m_frame-&gt;loader().documentLoader(), request, ResourceResponse { });
 904 
 905     auto&amp; documentLoader = *m_frame-&gt;loader().documentLoader();
 906     auto requestURL = request.url();
 907     unsigned type = m_pendingEntries.begin()-&gt;value;
 908     m_entryLoader = ApplicationCacheResourceLoader::create(type, documentLoader.cachedResourceLoader(), WTFMove(request), [this, requestURL = WTFMove(requestURL), type] (auto&amp;&amp; resourceOrError) {
 909         if (!resourceOrError.has_value()) {
 910             auto error = resourceOrError.error();
 911             if (error == ApplicationCacheResourceLoader::Error::Abort)
 912                 return;
 913             this-&gt;didFailLoadingEntry(error, requestURL, type);
 914             return;
 915         }
 916 
 917         m_currentResource = WTFMove(resourceOrError.value());
 918         this-&gt;didFinishLoadingEntry(requestURL);
 919     });
 920 }
 921 
 922 void ApplicationCacheGroup::deliverDelayedMainResources()
 923 {
 924     // Need to copy loaders, because the cache group may be destroyed at the end of iteration.
 925     auto loaders = copyToVector(m_pendingMasterResourceLoaders);
 926     for (auto* loader : loaders) {
 927         if (loader-&gt;isLoadingMainResource())
 928             continue;
 929         if (loader-&gt;mainDocumentError().isNull())
 930             finishedLoadingMainResource(*loader);
 931         else
 932             failedLoadingMainResource(*loader);
 933     }
 934     if (loaders.isEmpty())
 935         checkIfLoadIsComplete();
 936 }
 937 
 938 void ApplicationCacheGroup::addEntry(const String&amp; url, unsigned type)
 939 {
 940     ASSERT(m_cacheBeingUpdated);
 941     ASSERT(!URL({ }, url).hasFragmentIdentifier());
 942 
 943     // Don&#39;t add the URL if we already have an master resource in the cache
 944     // (i.e., the main resource finished loading before the manifest).
 945     if (auto* resource = m_cacheBeingUpdated-&gt;resourceForURL(url)) {
 946         ASSERT(resource-&gt;type() &amp; ApplicationCacheResource::Master);
 947         ASSERT(!m_frame-&gt;loader().documentLoader()-&gt;isLoadingMainResource());
 948         resource-&gt;addType(type);
 949         return;
 950     }
 951 
 952     // Don&#39;t add the URL if it&#39;s the same as the manifest URL.
 953     ASSERT(m_manifestResource);
 954     if (m_manifestResource-&gt;url() == url) {
 955         m_manifestResource-&gt;addType(type);
 956         return;
 957     }
 958 
 959     m_pendingEntries.add(url, type).iterator-&gt;value |= type;
 960 }
 961 
 962 void ApplicationCacheGroup::associateDocumentLoaderWithCache(DocumentLoader* loader, ApplicationCache* cache)
 963 {
 964     // If teardown started already, revive the group.
 965     if (!m_newestCache &amp;&amp; !m_cacheBeingUpdated)
 966         m_newestCache = cache;
 967 
 968     ASSERT(!m_isObsolete);
 969 
 970     loader-&gt;applicationCacheHost().setApplicationCache(cache);
 971 
 972     ASSERT(!m_associatedDocumentLoaders.contains(loader));
 973     m_associatedDocumentLoaders.add(loader);
 974 }
 975 
 976 class ChromeClientCallbackTimer final : public TimerBase {
 977 public:
 978     ChromeClientCallbackTimer(ApplicationCacheGroup&amp; group)
 979         : m_group(group)
 980     {
 981     }
 982 
 983 private:
 984     void fired() final
 985     {
 986         m_group.didReachMaxAppCacheSize();
 987         delete this;
 988     }
 989 
 990     // Note that there is no need to use a Ref here. The ApplicationCacheGroup instance is guaranteed
 991     // to be alive when the timer fires since invoking the callback is part of its normal
 992     // update machinery and nothing can yet cause it to get deleted.
 993     ApplicationCacheGroup&amp; m_group;
 994 };
 995 
 996 void ApplicationCacheGroup::scheduleReachedMaxAppCacheSizeCallback()
 997 {
 998     ASSERT(isMainThread());
 999     auto* timer = new ChromeClientCallbackTimer(*this);
1000     timer-&gt;startOneShot(0_s);
1001     // The timer will delete itself once it fires.
1002 }
1003 
1004 void ApplicationCacheGroup::postListenerTask(const AtomString&amp; eventType, int progressTotal, int progressDone, const HashSet&lt;DocumentLoader*&gt;&amp; loaderSet)
1005 {
1006     for (auto&amp; loader : loaderSet)
1007         postListenerTask(eventType, progressTotal, progressDone, *loader);
1008 }
1009 
1010 void ApplicationCacheGroup::postListenerTask(const AtomString&amp; eventType, int progressTotal, int progressDone, DocumentLoader&amp; loader)
1011 {
1012     auto* frame = loader.frame();
1013     if (!frame)
1014         return;
1015 
1016     ASSERT(frame-&gt;loader().documentLoader() == &amp;loader);
1017 
1018     RefPtr&lt;DocumentLoader&gt; protectedLoader(&amp;loader);
1019     frame-&gt;document()-&gt;postTask([protectedLoader, &amp;eventType, progressTotal, progressDone] (ScriptExecutionContext&amp; context) {
1020         ASSERT_UNUSED(context, context.isDocument());
1021         auto* frame = protectedLoader-&gt;frame();
1022         if (!frame)
1023             return;
1024 
1025         ASSERT(frame-&gt;loader().documentLoader() == protectedLoader);
1026         protectedLoader-&gt;applicationCacheHost().notifyDOMApplicationCache(eventType, progressTotal, progressDone);
1027     });
1028 }
1029 
1030 void ApplicationCacheGroup::setUpdateStatus(UpdateStatus status)
1031 {
1032     m_updateStatus = status;
1033 }
1034 
1035 void ApplicationCacheGroup::clearStorageID()
1036 {
1037     m_storageID = 0;
1038     for (auto&amp; cache : m_caches)
1039         cache-&gt;clearStorageID();
1040 }
1041 
1042 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/image-decoders/png/PNGImageDecoder.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../jpeg/JPEGImageDecoder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../java/LocalizedStringsJava.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/image-decoders/png/PNGImageDecoder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
443 #endif
444     }
445 
446     /* libpng comments (here to explain what follows).
447      *
448      * this function is called for every row in the image.  If the
449      * image is interlacing, and you turned on the interlace handler,
450      * this function will be called for every row in every pass.
451      * Some of these rows will not be changed from the previous pass.
452      * When the row is not changed, the new_row variable will be NULL.
453      * The rows and passes are called in order, so you don&#39;t really
454      * need the row_num and pass, but I&#39;m supplying them because it
455      * may make your life easier.
456      */
457 
458     // Nothing to do if the row is unchanged, or the row is outside
459     // the image bounds: libpng may send extra rows, ignore them to
460     // make our lives easier.
461     if (!rowBuffer)
462         return;
<span class="line-modified">463     if (rowIndex &gt;= size().height())</span>
464         return;
465 
466     /* libpng comments (continued).
467      *
468      * For the non-NULL rows of interlaced images, you must call
469      * png_progressive_combine_row() passing in the row and the
470      * old row.  You can call this function for NULL rows (it will
471      * just return) and for non-interlaced images (it just does the
472      * memcpy for you) if it will make the code easier.  Thus, you
473      * can just do this for all cases:
474      *
475      *    png_progressive_combine_row(png_ptr, old_row, new_row);
476      *
477      * where old_row is what was displayed for previous rows.  Note
478      * that the first pass (pass == 0 really) will completely cover
479      * the old row, so the rows do not have to be initialized.  After
480      * the first pass (and only for interlaced images), you will have
481      * to pass the current row, and the function will combine the
482      * old row and the new row.
483      */
</pre>
<hr />
<pre>
494             return; // Only do incremental image display for the first frame.
495         }
496 #endif
497         png_progressive_combine_row(m_reader-&gt;pngPtr(), row, rowBuffer);
498     }
499 
500     // Write the decoded row pixels to the frame buffer.
501     auto* address = buffer.backingStore()-&gt;pixelAt(0, rowIndex);
502     int width = size().width();
503     unsigned char nonTrivialAlphaMask = 0;
504 
505     png_bytep pixel = row;
506     if (hasAlpha) {
507         for (int x = 0; x &lt; width; ++x, pixel += 4, ++address) {
508             unsigned alpha = pixel[3];
509             buffer.backingStore()-&gt;setPixel(address, pixel[0], pixel[1], pixel[2], alpha);
510             nonTrivialAlphaMask |= (255 - alpha);
511         }
512     } else {
513         for (int x = 0; x &lt; width; ++x, pixel += 3, ++address)
<span class="line-modified">514             *address = makeRGB(pixel[0], pixel[1], pixel[2]);</span>
515     }
516 
517     if (nonTrivialAlphaMask &amp;&amp; !buffer.hasAlpha())
518         buffer.setHasAlpha(true);
519 }
520 
521 void PNGImageDecoder::pngComplete()
522 {
523 #if ENABLE(APNG)
524     if (m_isAnimated) {
525         if (!processingFinish() &amp;&amp; m_frameCount == m_currentFrame)
526             return;
527 
528         fallbackNotAnimated();
529     }
530 #endif
531     if (!m_frameBufferCache.isEmpty())
532         m_frameBufferCache.first().setDecodingStatus(DecodingStatus::Complete);
533 }
534 
</pre>
</td>
<td>
<hr />
<pre>
443 #endif
444     }
445 
446     /* libpng comments (here to explain what follows).
447      *
448      * this function is called for every row in the image.  If the
449      * image is interlacing, and you turned on the interlace handler,
450      * this function will be called for every row in every pass.
451      * Some of these rows will not be changed from the previous pass.
452      * When the row is not changed, the new_row variable will be NULL.
453      * The rows and passes are called in order, so you don&#39;t really
454      * need the row_num and pass, but I&#39;m supplying them because it
455      * may make your life easier.
456      */
457 
458     // Nothing to do if the row is unchanged, or the row is outside
459     // the image bounds: libpng may send extra rows, ignore them to
460     // make our lives easier.
461     if (!rowBuffer)
462         return;
<span class="line-modified">463     if (rowIndex &gt;= (unsigned)size().height())</span>
464         return;
465 
466     /* libpng comments (continued).
467      *
468      * For the non-NULL rows of interlaced images, you must call
469      * png_progressive_combine_row() passing in the row and the
470      * old row.  You can call this function for NULL rows (it will
471      * just return) and for non-interlaced images (it just does the
472      * memcpy for you) if it will make the code easier.  Thus, you
473      * can just do this for all cases:
474      *
475      *    png_progressive_combine_row(png_ptr, old_row, new_row);
476      *
477      * where old_row is what was displayed for previous rows.  Note
478      * that the first pass (pass == 0 really) will completely cover
479      * the old row, so the rows do not have to be initialized.  After
480      * the first pass (and only for interlaced images), you will have
481      * to pass the current row, and the function will combine the
482      * old row and the new row.
483      */
</pre>
<hr />
<pre>
494             return; // Only do incremental image display for the first frame.
495         }
496 #endif
497         png_progressive_combine_row(m_reader-&gt;pngPtr(), row, rowBuffer);
498     }
499 
500     // Write the decoded row pixels to the frame buffer.
501     auto* address = buffer.backingStore()-&gt;pixelAt(0, rowIndex);
502     int width = size().width();
503     unsigned char nonTrivialAlphaMask = 0;
504 
505     png_bytep pixel = row;
506     if (hasAlpha) {
507         for (int x = 0; x &lt; width; ++x, pixel += 4, ++address) {
508             unsigned alpha = pixel[3];
509             buffer.backingStore()-&gt;setPixel(address, pixel[0], pixel[1], pixel[2], alpha);
510             nonTrivialAlphaMask |= (255 - alpha);
511         }
512     } else {
513         for (int x = 0; x &lt; width; ++x, pixel += 3, ++address)
<span class="line-modified">514             *address = 0xFF000000 | pixel[0] &lt;&lt; 16 | pixel[1] &lt;&lt; 8 | pixel[2];</span>
515     }
516 
517     if (nonTrivialAlphaMask &amp;&amp; !buffer.hasAlpha())
518         buffer.setHasAlpha(true);
519 }
520 
521 void PNGImageDecoder::pngComplete()
522 {
523 #if ENABLE(APNG)
524     if (m_isAnimated) {
525         if (!processingFinish() &amp;&amp; m_frameCount == m_currentFrame)
526             return;
527 
528         fallbackNotAnimated();
529     }
530 #endif
531     if (!m_frameBufferCache.isEmpty())
532         m_frameBufferCache.first().setDecodingStatus(DecodingStatus::Complete);
533 }
534 
</pre>
</td>
</tr>
</table>
<center><a href="../jpeg/JPEGImageDecoder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../java/LocalizedStringsJava.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
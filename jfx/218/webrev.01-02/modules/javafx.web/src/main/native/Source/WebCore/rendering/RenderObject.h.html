<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderObject.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2000 Lars Knoll (knoll@kde.org)
   3  *           (C) 2000 Antti Koivisto (koivisto@kde.org)
   4  *           (C) 2000 Dirk Mueller (mueller@kde.org)
   5  *           (C) 2004 Allan Sandfeld Jensen (kde@carewolf.com)
   6  * Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2012 Apple Inc. All rights reserved.
   7  * Copyright (C) 2009 Google Inc. All rights reserved.
   8  *
   9  * This library is free software; you can redistribute it and/or
  10  * modify it under the terms of the GNU Library General Public
  11  * License as published by the Free Software Foundation; either
  12  * version 2 of the License, or (at your option) any later version.
  13  *
  14  * This library is distributed in the hope that it will be useful,
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Library General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Library General Public License
  20  * along with this library; see the file COPYING.LIB.  If not, write to
  21  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  22  * Boston, MA 02110-1301, USA.
  23  *
  24  */
  25 
  26 #pragma once
  27 
  28 #include &quot;CachedImageClient.h&quot;
  29 #include &quot;Element.h&quot;
  30 #include &quot;FloatQuad.h&quot;
  31 #include &quot;Frame.h&quot;
  32 #include &quot;LayoutRect.h&quot;
  33 #include &quot;Page.h&quot;
  34 #include &quot;RenderObjectEnums.h&quot;
  35 #include &quot;RenderStyle.h&quot;
  36 #include &quot;ScrollAlignment.h&quot;
  37 #include &quot;StyleImage.h&quot;
  38 #include &quot;TextAffinity.h&quot;
  39 #include &lt;wtf/IsoMalloc.h&gt;
  40 #include &lt;wtf/WeakPtr.h&gt;
  41 
  42 namespace WebCore {
  43 
  44 class AffineTransform;
  45 class CSSAnimationController;
  46 class Color;
  47 class Cursor;
  48 class Document;
  49 class DocumentTimeline;
  50 class HitTestLocation;
  51 class HitTestRequest;
  52 class HitTestResult;
  53 class InlineBox;
  54 class Path;
  55 class Position;
  56 class RenderBoxModelObject;
  57 class RenderInline;
  58 class RenderBlock;
  59 class RenderElement;
  60 class RenderFragmentedFlow;
  61 class RenderGeometryMap;
  62 class RenderLayer;
  63 class RenderLayerModelObject;
  64 class RenderFragmentContainer;
  65 class RenderTheme;
  66 class RenderTreeBuilder;
  67 class SelectionRangeData;
  68 class TransformState;
  69 class VisiblePosition;
  70 
  71 #if PLATFORM(IOS_FAMILY)
  72 class SelectionRect;
  73 #endif
  74 
  75 struct PaintInfo;
  76 
  77 #if PLATFORM(IOS_FAMILY)
  78 const int caretWidth = 2; // This value should be kept in sync with UIKit. See &lt;rdar://problem/15580601&gt;.
  79 #else
  80 const int caretWidth = 1;
  81 #endif
  82 
  83 enum class ShouldAllowCrossOriginScrolling { No, Yes };
  84 
  85 struct ScrollRectToVisibleOptions;
  86 
  87 namespace Style {
  88 class PseudoElementRequest;
  89 }
  90 
  91 // Base class for all rendering tree objects.
  92 class RenderObject : public CachedImageClient, public CanMakeWeakPtr&lt;RenderObject&gt; {
  93     WTF_MAKE_ISO_ALLOCATED(RenderObject);
  94     friend class RenderBlock;
  95     friend class RenderBlockFlow;
  96     friend class RenderElement;
  97     friend class RenderLayer;
  98 public:
  99     // Anonymous objects should pass the document as their node, and they will then automatically be
 100     // marked as anonymous in the constructor.
 101     explicit RenderObject(Node&amp;);
 102     virtual ~RenderObject();
 103 
 104     RenderTheme&amp; theme() const;
 105 
 106     virtual const char* renderName() const = 0;
 107 
 108     RenderElement* parent() const { return m_parent; }
 109     bool isDescendantOf(const RenderObject*) const;
 110 
 111     RenderObject* previousSibling() const { return m_previous; }
 112     RenderObject* nextSibling() const { return m_next; }
 113 
 114     // Use RenderElement versions instead.
 115     virtual RenderObject* firstChildSlow() const { return nullptr; }
 116     virtual RenderObject* lastChildSlow() const { return nullptr; }
 117 
 118     RenderObject* nextInPreOrder() const;
 119     RenderObject* nextInPreOrder(const RenderObject* stayWithin) const;
 120     RenderObject* nextInPreOrderAfterChildren() const;
 121     RenderObject* nextInPreOrderAfterChildren(const RenderObject* stayWithin) const;
 122     RenderObject* previousInPreOrder() const;
 123     RenderObject* previousInPreOrder(const RenderObject* stayWithin) const;
 124     WEBCORE_EXPORT RenderObject* childAt(unsigned) const;
 125 
 126     RenderObject* firstLeafChild() const;
 127     RenderObject* lastLeafChild() const;
 128 
 129 #if ENABLE(TEXT_AUTOSIZING)
 130     // Minimal distance between the block with fixed height and overflowing content and the text block to apply text autosizing.
 131     // The greater this constant is the more potential places we have where autosizing is turned off.
 132     // So it should be as low as possible. There are sites that break at 2.
 133     static const int TextAutoSizingFixedHeightDepth = 3;
 134 
 135     enum BlockContentHeightType {
 136         FixedHeight,
 137         FlexibleHeight,
 138         OverflowHeight
 139     };
 140 
 141     typedef BlockContentHeightType (*HeightTypeTraverseNextInclusionFunction)(const RenderObject&amp;);
 142     RenderObject* traverseNext(const RenderObject* stayWithin, HeightTypeTraverseNextInclusionFunction, int&amp; currentDepth, int&amp; newFixedDepth) const;
 143 #endif
 144 
 145     WEBCORE_EXPORT RenderLayer* enclosingLayer() const;
 146 
 147     // Scrolling is a RenderBox concept, however some code just cares about recursively scrolling our enclosing ScrollableArea(s).
 148     WEBCORE_EXPORT bool scrollRectToVisible(const LayoutRect&amp; absoluteRect, bool insideFixed, const ScrollRectToVisibleOptions&amp;);
 149 
 150     // Convenience function for getting to the nearest enclosing box of a RenderObject.
 151     WEBCORE_EXPORT RenderBox&amp; enclosingBox() const;
 152     RenderBoxModelObject&amp; enclosingBoxModelObject() const;
 153     const RenderBox* enclosingScrollableContainerForSnapping() const;
 154 
 155     // Function to return our enclosing flow thread if we are contained inside one. This
 156     // function follows the containing block chain.
 157     RenderFragmentedFlow* enclosingFragmentedFlow() const
 158     {
 159         if (fragmentedFlowState() == NotInsideFragmentedFlow)
 160             return nullptr;
 161 
 162         return locateEnclosingFragmentedFlow();
 163     }
 164 
 165     WEBCORE_EXPORT bool useDarkAppearance() const;
 166     OptionSet&lt;StyleColor::Options&gt; styleColorOptions() const;
 167 
 168 #if ASSERT_ENABLED
 169     void setHasAXObject(bool flag) { m_hasAXObject = flag; }
 170     bool hasAXObject() const { return m_hasAXObject; }
 171 
 172     // Helper class forbidding calls to setNeedsLayout() during its lifetime.
 173     class SetLayoutNeededForbiddenScope {
 174     public:
 175         explicit SetLayoutNeededForbiddenScope(RenderObject*, bool isForbidden = true);
 176         ~SetLayoutNeededForbiddenScope();
 177     private:
 178         RenderObject* m_renderObject;
 179         bool m_preexistingForbidden;
 180     };
 181 #endif // ASSERT_ENABLED
 182 
 183     // Obtains the nearest enclosing block (including this block) that contributes a first-line style to our inline
 184     // children.
 185     virtual RenderBlock* firstLineBlock() const;
 186 
 187     // RenderObject tree manipulation
 188     //////////////////////////////////////////
 189     virtual bool canHaveChildren() const = 0;
 190     virtual bool canHaveGeneratedChildren() const;
 191     virtual bool createsAnonymousWrapper() const { return false; }
 192     //////////////////////////////////////////
 193 
 194 #if ENABLE(TREE_DEBUGGING)
 195     void showNodeTreeForThis() const;
 196     void showRenderTreeForThis() const;
 197     void showLineTreeForThis() const;
 198 
 199     void outputRenderObject(WTF::TextStream&amp;, bool mark, int depth) const;
 200     void outputRenderSubTreeAndMark(WTF::TextStream&amp;, const RenderObject* markedObject, int depth) const;
 201     void outputRegionsInformation(WTF::TextStream&amp;) const;
 202 #endif
 203 
 204     bool isPseudoElement() const { return node() &amp;&amp; node()-&gt;isPseudoElement(); }
 205 
 206     bool isRenderElement() const { return !isText(); }
 207     bool isRenderReplaced() const;
 208     bool isBoxModelObject() const;
 209     bool isRenderBlock() const;
 210     bool isRenderBlockFlow() const;
 211     bool isRenderInline() const;
 212     bool isRenderLayerModelObject() const;
 213 
 214     virtual bool isCounter() const { return false; }
 215     virtual bool isQuote() const { return false; }
 216 
 217     virtual bool isDetailsMarker() const { return false; }
 218     virtual bool isEmbeddedObject() const { return false; }
 219     bool isFieldset() const;
 220     virtual bool isFileUploadControl() const { return false; }
 221     virtual bool isFrame() const { return false; }
 222     virtual bool isFrameSet() const { return false; }
 223     virtual bool isImage() const { return false; }
 224     virtual bool isInlineBlockOrInlineTable() const { return false; }
 225     virtual bool isListBox() const { return false; }
 226     virtual bool isListItem() const { return false; }
 227     virtual bool isListMarker() const { return false; }
 228     virtual bool isMedia() const { return false; }
 229     virtual bool isMenuList() const { return false; }
 230 #if ENABLE(METER_ELEMENT)
 231     virtual bool isMeter() const { return false; }
 232 #endif
 233     virtual bool isSnapshottedPlugIn() const { return false; }
 234     virtual bool isProgress() const { return false; }
 235     virtual bool isRenderButton() const { return false; }
 236     virtual bool isRenderIFrame() const { return false; }
 237     virtual bool isRenderImage() const { return false; }
 238     virtual bool isRenderFragmentContainer() const { return false; }
 239     virtual bool isReplica() const { return false; }
 240 
 241     virtual bool isRubyInline() const { return false; }
 242     virtual bool isRubyBlock() const { return false; }
 243     virtual bool isRubyBase() const { return false; }
 244     virtual bool isRubyRun() const { return false; }
 245     virtual bool isRubyText() const { return false; }
 246 
 247     virtual bool isSlider() const { return false; }
 248     virtual bool isSliderThumb() const { return false; }
 249     virtual bool isTable() const { return false; }
 250     virtual bool isTableCell() const { return false; }
 251     virtual bool isRenderTableCol() const { return false; }
 252     virtual bool isTableCaption() const { return false; }
 253     virtual bool isTableRow() const { return false; }
 254     virtual bool isTableSection() const { return false; }
 255     virtual bool isTextControl() const { return false; }
 256     virtual bool isTextArea() const { return false; }
 257     virtual bool isTextField() const { return false; }
 258     virtual bool isSearchField() const { return false; }
 259     virtual bool isTextControlInnerBlock() const { return false; }
 260     virtual bool isVideo() const { return false; }
 261     virtual bool isWidget() const { return false; }
 262     virtual bool isCanvas() const { return false; }
 263 #if ENABLE(ATTACHMENT_ELEMENT)
 264     virtual bool isAttachment() const { return false; }
 265 #endif
 266 #if ENABLE(FULLSCREEN_API)
 267     virtual bool isRenderFullScreen() const { return false; }
 268     virtual bool isRenderFullScreenPlaceholder() const { return false; }
 269 #endif
 270     virtual bool isRenderGrid() const { return false; }
 271     bool isInFlowRenderFragmentedFlow() const { return isRenderFragmentedFlow() &amp;&amp; !isOutOfFlowPositioned(); }
 272     bool isOutOfFlowRenderFragmentedFlow() const { return isRenderFragmentedFlow() &amp;&amp; isOutOfFlowPositioned(); }
 273 
 274     virtual bool isMultiColumnBlockFlow() const { return false; }
 275     virtual bool isRenderMultiColumnSet() const { return false; }
 276     virtual bool isRenderMultiColumnFlow() const { return false; }
 277     virtual bool isRenderMultiColumnSpannerPlaceholder() const { return false; }
 278 
 279     virtual bool isRenderScrollbarPart() const { return false; }
 280 
 281     bool isDocumentElementRenderer() const { return document().documentElement() == &amp;m_node; }
 282     bool isBody() const { return node() &amp;&amp; node()-&gt;hasTagName(HTMLNames::bodyTag); }
 283     bool isHR() const { return node() &amp;&amp; node()-&gt;hasTagName(HTMLNames::hrTag); }
 284     bool isLegend() const;
 285 
 286     bool isHTMLMarquee() const;
 287 
 288     bool isTablePart() const { return isTableCell() || isRenderTableCol() || isTableCaption() || isTableRow() || isTableSection(); }
 289 
 290     inline bool isBeforeContent() const;
 291     inline bool isAfterContent() const;
 292     inline bool isBeforeOrAfterContent() const;
 293     static inline bool isBeforeContent(const RenderObject* obj) { return obj &amp;&amp; obj-&gt;isBeforeContent(); }
 294     static inline bool isAfterContent(const RenderObject* obj) { return obj &amp;&amp; obj-&gt;isAfterContent(); }
 295     static inline bool isBeforeOrAfterContent(const RenderObject* obj) { return obj &amp;&amp; obj-&gt;isBeforeOrAfterContent(); }
 296 
 297     bool beingDestroyed() const { return m_bitfields.beingDestroyed(); }
 298 
 299     bool everHadLayout() const { return m_bitfields.everHadLayout(); }
 300 
 301     bool childrenInline() const { return m_bitfields.childrenInline(); }
 302     void setChildrenInline(bool b) { m_bitfields.setChildrenInline(b); }
 303 
 304     enum FragmentedFlowState {
 305         NotInsideFragmentedFlow = 0,
 306         InsideInFragmentedFlow = 1,
 307     };
 308 
 309     void setFragmentedFlowStateIncludingDescendants(FragmentedFlowState);
 310 
 311     FragmentedFlowState fragmentedFlowState() const { return m_bitfields.fragmentedFlowState(); }
 312     void setFragmentedFlowState(FragmentedFlowState state) { m_bitfields.setFragmentedFlowState(state); }
 313 
 314 #if ENABLE(MATHML)
 315     virtual bool isRenderMathMLBlock() const { return false; }
 316     virtual bool isRenderMathMLTable() const { return false; }
 317     virtual bool isRenderMathMLOperator() const { return false; }
 318     virtual bool isRenderMathMLRow() const { return false; }
 319     virtual bool isRenderMathMLMath() const { return false; }
 320     virtual bool isRenderMathMLMenclose() const { return false; }
 321     virtual bool isRenderMathMLFenced() const { return false; }
 322     virtual bool isRenderMathMLFencedOperator() const { return false; }
 323     virtual bool isRenderMathMLFraction() const { return false; }
 324     virtual bool isRenderMathMLPadded() const { return false; }
 325     virtual bool isRenderMathMLRoot() const { return false; }
 326     virtual bool isRenderMathMLSpace() const { return false; }
 327     virtual bool isRenderMathMLSquareRoot() const { return false; }
 328     virtual bool isRenderMathMLScripts() const { return false; }
 329     virtual bool isRenderMathMLToken() const { return false; }
 330     virtual bool isRenderMathMLUnderOver() const { return false; }
 331 #endif // ENABLE(MATHML)
 332 
 333     // FIXME: Until all SVG renders can be subclasses of RenderSVGModelObject we have
 334     // to add SVG renderer methods to RenderObject with an ASSERT_NOT_REACHED() default implementation.
 335     virtual bool isRenderSVGModelObject() const { return false; }
 336     virtual bool isRenderSVGBlock() const { return false; };
 337     virtual bool isSVGRoot() const { return false; }
 338     virtual bool isSVGContainer() const { return false; }
 339     virtual bool isSVGTransformableContainer() const { return false; }
 340     virtual bool isSVGViewportContainer() const { return false; }
 341     virtual bool isSVGGradientStop() const { return false; }
 342     virtual bool isSVGHiddenContainer() const { return false; }
 343     virtual bool isSVGPath() const { return false; }
 344     virtual bool isSVGShape() const { return false; }
 345     virtual bool isSVGText() const { return false; }
 346     virtual bool isSVGTextPath() const { return false; }
 347     virtual bool isSVGTSpan() const { return false; }
 348     virtual bool isSVGInline() const { return false; }
 349     virtual bool isSVGInlineText() const { return false; }
 350     virtual bool isSVGImage() const { return false; }
 351     virtual bool isSVGForeignObject() const { return false; }
 352     virtual bool isSVGResourceContainer() const { return false; }
 353     virtual bool isSVGResourceFilter() const { return false; }
 354     virtual bool isSVGResourceClipper() const { return false; }
 355     virtual bool isSVGResourceFilterPrimitive() const { return false; }
 356 
 357     // FIXME: Those belong into a SVG specific base-class for all renderers (see above)
 358     // Unfortunately we don&#39;t have such a class yet, because it&#39;s not possible for all renderers
 359     // to inherit from RenderSVGObject -&gt; RenderObject (some need RenderBlock inheritance for instance)
 360     virtual void setNeedsTransformUpdate() { }
 361     virtual void setNeedsBoundariesUpdate();
 362     virtual bool needsBoundariesUpdate() { return false; }
 363 
 364     // Per SVG 1.1 objectBoundingBox ignores clipping, masking, filter effects, opacity and stroke-width.
 365     // This is used for all computation of objectBoundingBox relative units and by SVGLocatable::getBBox().
 366     // NOTE: Markers are not specifically ignored here by SVG 1.1 spec, but we ignore them
 367     // since stroke-width is ignored (and marker size can depend on stroke-width).
 368     // objectBoundingBox is returned local coordinates.
 369     // The name objectBoundingBox is taken from the SVG 1.1 spec.
 370     virtual FloatRect objectBoundingBox() const;
 371     virtual FloatRect strokeBoundingBox() const;
 372 
 373     // Returns the smallest rectangle enclosing all of the painted content
 374     // respecting clipping, masking, filters, opacity, stroke-width and markers
 375     virtual FloatRect repaintRectInLocalCoordinates() const;
 376 
 377     // This only returns the transform=&quot;&quot; value from the element
 378     // most callsites want localToParentTransform() instead.
 379     virtual AffineTransform localTransform() const;
 380 
 381     // Returns the full transform mapping from local coordinates to local coords for the parent SVG renderer
 382     // This includes any viewport transforms and x/y offsets as well as the transform=&quot;&quot; value off the element.
 383     virtual const AffineTransform&amp; localToParentTransform() const;
 384 
 385     // SVG uses FloatPoint precise hit testing, and passes the point in parent
 386     // coordinates instead of in repaint container coordinates.  Eventually the
 387     // rest of the rendering tree will move to a similar model.
 388     virtual bool nodeAtFloatPoint(const HitTestRequest&amp;, HitTestResult&amp;, const FloatPoint&amp; pointInParent, HitTestAction);
 389 
 390     bool hasAspectRatio() const { return isReplaced() &amp;&amp; (isImage() || isVideo() || isCanvas()); }
 391     bool isAnonymous() const { return m_bitfields.isAnonymous(); }
 392     bool isAnonymousBlock() const
 393     {
 394         // This function is kept in sync with anonymous block creation conditions in
 395         // RenderBlock::createAnonymousBlock(). This includes creating an anonymous
 396         // RenderBlock having a DisplayType::Block or DisplayType::Box display. Other classes such as RenderTextFragment
 397         // are not RenderBlocks and will return false. See https://bugs.webkit.org/show_bug.cgi?id=56709.
 398         return isAnonymous() &amp;&amp; (style().display() == DisplayType::Block || style().display() == DisplayType::Box) &amp;&amp; style().styleType() == PseudoId::None &amp;&amp; isRenderBlock() &amp;&amp; !isListMarker() &amp;&amp; !isRenderFragmentedFlow() &amp;&amp; !isRenderMultiColumnSet() &amp;&amp; !isRenderView()
 399 #if ENABLE(FULLSCREEN_API)
 400             &amp;&amp; !isRenderFullScreen()
 401             &amp;&amp; !isRenderFullScreenPlaceholder()
 402 #endif
 403 #if ENABLE(MATHML)
 404             &amp;&amp; !isRenderMathMLBlock()
 405 #endif
 406             ;
 407     }
 408 
 409     bool isFloating() const { return m_bitfields.floating(); }
 410 
 411     bool isPositioned() const { return m_bitfields.isPositioned(); }
 412     bool isInFlowPositioned() const { return m_bitfields.isRelativelyPositioned() || m_bitfields.isStickilyPositioned(); }
 413     bool isOutOfFlowPositioned() const { return m_bitfields.isOutOfFlowPositioned(); } // absolute or fixed positioning
 414     bool isFixedPositioned() const { return isOutOfFlowPositioned() &amp;&amp; style().position() == PositionType::Fixed; }
 415     bool isAbsolutelyPositioned() const { return isOutOfFlowPositioned() &amp;&amp; style().position() == PositionType::Absolute; }
 416     bool isRelativelyPositioned() const { return m_bitfields.isRelativelyPositioned(); }
 417     bool isStickilyPositioned() const { return m_bitfields.isStickilyPositioned(); }
 418 
 419     bool isText() const  { return !m_bitfields.isBox() &amp;&amp; m_bitfields.isTextOrRenderView(); }
 420     bool isLineBreak() const { return m_bitfields.isLineBreak(); }
 421     bool isBR() const { return isLineBreak() &amp;&amp; !isWBR(); }
 422     bool isLineBreakOpportunity() const { return isLineBreak() &amp;&amp; isWBR(); }
 423     bool isTextOrLineBreak() const { return isText() || isLineBreak(); }
 424     bool isBox() const { return m_bitfields.isBox(); }
 425     bool isRenderView() const  { return m_bitfields.isBox() &amp;&amp; m_bitfields.isTextOrRenderView(); }
 426     bool isInline() const { return m_bitfields.isInline(); } // inline object
 427     bool isReplaced() const { return m_bitfields.isReplaced(); } // a &quot;replaced&quot; element (see CSS)
 428     bool isHorizontalWritingMode() const { return m_bitfields.horizontalWritingMode(); }
 429 
 430     bool isDragging() const { return m_bitfields.hasRareData() &amp;&amp; rareData().isDragging(); }
 431     bool hasReflection() const { return m_bitfields.hasRareData() &amp;&amp; rareData().hasReflection(); }
 432     bool isRenderFragmentedFlow() const { return m_bitfields.hasRareData() &amp;&amp; rareData().isRenderFragmentedFlow(); }
 433     bool hasOutlineAutoAncestor() const { return m_bitfields.hasRareData() &amp;&amp; rareData().hasOutlineAutoAncestor(); }
 434 
 435     bool isExcludedFromNormalLayout() const { return m_bitfields.isExcludedFromNormalLayout(); }
 436     void setIsExcludedFromNormalLayout(bool excluded) { m_bitfields.setIsExcludedFromNormalLayout(excluded); }
 437     bool isExcludedAndPlacedInBorder() const { return isExcludedFromNormalLayout() &amp;&amp; isLegend(); }
 438 
 439     bool hasLayer() const { return m_bitfields.hasLayer(); }
 440 
 441     enum BoxDecorationState {
 442         NoBoxDecorations,
 443         HasBoxDecorationsAndBackgroundObscurationStatusInvalid,
 444         HasBoxDecorationsAndBackgroundIsKnownToBeObscured,
 445         HasBoxDecorationsAndBackgroundMayBeVisible,
 446     };
 447     bool hasVisibleBoxDecorations() const { return m_bitfields.boxDecorationState() != NoBoxDecorations; }
 448     bool backgroundIsKnownToBeObscured(const LayoutPoint&amp; paintOffset);
 449 
 450     bool needsLayout() const
 451     {
 452         return m_bitfields.needsLayout() || m_bitfields.normalChildNeedsLayout() || m_bitfields.posChildNeedsLayout()
 453             || m_bitfields.needsSimplifiedNormalFlowLayout() || m_bitfields.needsPositionedMovementLayout();
 454     }
 455 
 456     bool selfNeedsLayout() const { return m_bitfields.needsLayout(); }
 457     bool needsPositionedMovementLayout() const { return m_bitfields.needsPositionedMovementLayout(); }
 458     bool needsPositionedMovementLayoutOnly() const
 459     {
 460         return m_bitfields.needsPositionedMovementLayout() &amp;&amp; !m_bitfields.needsLayout() &amp;&amp; !m_bitfields.normalChildNeedsLayout()
 461             &amp;&amp; !m_bitfields.posChildNeedsLayout() &amp;&amp; !m_bitfields.needsSimplifiedNormalFlowLayout();
 462     }
 463 
 464     bool posChildNeedsLayout() const { return m_bitfields.posChildNeedsLayout(); }
 465     bool needsSimplifiedNormalFlowLayout() const { return m_bitfields.needsSimplifiedNormalFlowLayout(); }
 466     bool needsSimplifiedNormalFlowLayoutOnly() const;
 467     bool normalChildNeedsLayout() const { return m_bitfields.normalChildNeedsLayout(); }
 468 
 469     bool preferredLogicalWidthsDirty() const { return m_bitfields.preferredLogicalWidthsDirty(); }
 470 
 471     bool isSelectionBorder() const;
 472 
 473     bool hasOverflowClip() const { return m_bitfields.hasOverflowClip(); }
 474 
 475     bool hasTransformRelatedProperty() const { return m_bitfields.hasTransformRelatedProperty(); } // Transform, perspective or transform-style: preserve-3d.
 476     bool hasTransform() const { return hasTransformRelatedProperty() &amp;&amp; style().hasTransform(); }
 477 
 478     inline bool preservesNewline() const;
 479 
 480     virtual void updateDragState(bool dragOn);
 481 
 482     RenderView&amp; view() const { return *document().renderView(); };
 483 
 484     // Returns true if this renderer is rooted.
 485     bool isRooted() const;
 486 
 487     Node* node() const { return isAnonymous() ? nullptr : &amp;m_node; }
 488     Node* nonPseudoNode() const { return isPseudoElement() ? nullptr : node(); }
 489 
 490     // Returns the styled node that caused the generation of this renderer.
 491     // This is the same as node() except for renderers of :before and :after
 492     // pseudo elements for which their parent node is returned.
 493     Node* generatingNode() const { return isPseudoElement() ? generatingPseudoHostElement() : node(); }
 494 
 495     Document&amp; document() const { return m_node.document(); }
 496     Frame&amp; frame() const;
 497     Page&amp; page() const;
 498     Settings&amp; settings() const { return page().settings(); }
 499 
 500     // Returns the object containing this one. Can be different from parent for positioned elements.
 501     // If repaintContainer and repaintContainerSkipped are not null, on return *repaintContainerSkipped
 502     // is true if the renderer returned is an ancestor of repaintContainer.
 503     RenderElement* container() const;
 504     RenderElement* container(const RenderLayerModelObject* repaintContainer, bool&amp; repaintContainerSkipped) const;
 505 
 506     RenderBoxModelObject* offsetParent() const;
 507 
 508     void markContainingBlocksForLayout(ScheduleRelayout = ScheduleRelayout::Yes, RenderElement* newRoot = nullptr);
 509     void setNeedsLayout(MarkingBehavior = MarkContainingBlockChain);
 510     void clearNeedsLayout();
 511     void setPreferredLogicalWidthsDirty(bool, MarkingBehavior = MarkContainingBlockChain);
 512     void invalidateContainerPreferredLogicalWidths();
 513 
 514     void setNeedsLayoutAndPrefWidthsRecalc()
 515     {
 516         setNeedsLayout();
 517         setPreferredLogicalWidthsDirty(true);
 518     }
 519 
 520     void setPositionState(PositionType position)
 521     {
 522         ASSERT((position != PositionType::Absolute &amp;&amp; position != PositionType::Fixed) || isBox());
 523         m_bitfields.setPositionedState(static_cast&lt;int&gt;(position));
 524     }
 525     void clearPositionedState() { m_bitfields.clearPositionedState(); }
 526 
 527     void setFloating(bool b = true) { m_bitfields.setFloating(b); }
 528     void setInline(bool b = true) { m_bitfields.setIsInline(b); }
 529 
 530     void setHasVisibleBoxDecorations(bool = true);
 531     void invalidateBackgroundObscurationStatus();
 532     virtual bool computeBackgroundIsKnownToBeObscured(const LayoutPoint&amp;) { return false; }
 533 
 534     void setIsText() { ASSERT(!isBox()); m_bitfields.setIsTextOrRenderView(true); }
 535     void setIsLineBreak() { m_bitfields.setIsLineBreak(true); }
 536     void setIsBox() { m_bitfields.setIsBox(true); }
 537     void setIsRenderView() { ASSERT(isBox()); m_bitfields.setIsTextOrRenderView(true); }
 538     void setReplaced(bool b = true) { m_bitfields.setIsReplaced(b); }
 539     void setHorizontalWritingMode(bool b = true) { m_bitfields.setHorizontalWritingMode(b); }
 540     void setHasOverflowClip(bool b = true) { m_bitfields.setHasOverflowClip(b); }
 541     void setHasLayer(bool b = true) { m_bitfields.setHasLayer(b); }
 542     void setHasTransformRelatedProperty(bool b = true) { m_bitfields.setHasTransformRelatedProperty(b); }
 543 
 544     void setIsDragging(bool);
 545     void setHasReflection(bool = true);
 546     void setIsRenderFragmentedFlow(bool = true);
 547     void setHasOutlineAutoAncestor(bool = true);
 548 
 549     // Hook so that RenderTextControl can return the line height of its inner renderer.
 550     // For other renderers, the value is the same as lineHeight(false).
 551     virtual int innerLineHeight() const;
 552 
 553     // used for element state updates that cannot be fixed with a
 554     // repaint and do not need a relayout
 555     virtual void updateFromElement() { }
 556 
 557     bool isComposited() const;
 558 
 559     bool hitTest(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestFilter = HitTestAll);
 560     virtual void updateHitTestResult(HitTestResult&amp;, const LayoutPoint&amp;);
 561     virtual bool nodeAtPoint(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction);
 562 
 563     virtual Position positionForPoint(const LayoutPoint&amp;);
 564     virtual VisiblePosition positionForPoint(const LayoutPoint&amp;, const RenderFragmentContainer*);
 565     VisiblePosition createVisiblePosition(int offset, EAffinity) const;
 566     VisiblePosition createVisiblePosition(const Position&amp;) const;
 567 
 568     // returns the containing block level element for this element.
 569     WEBCORE_EXPORT RenderBlock* containingBlock() const;
 570     RenderBlock* containingBlockForObjectInFlow() const;
 571 
 572     // Convert the given local point to absolute coordinates. If MapCoordinatesFlags includes UseTransforms, take transforms into account.
 573     WEBCORE_EXPORT FloatPoint localToAbsolute(const FloatPoint&amp; localPoint = FloatPoint(), MapCoordinatesFlags = 0, bool* wasFixed = nullptr) const;
 574     FloatPoint absoluteToLocal(const FloatPoint&amp;, MapCoordinatesFlags = 0) const;
 575 
 576     // Convert a local quad to absolute coordinates, taking transforms into account.
 577     FloatQuad localToAbsoluteQuad(const FloatQuad&amp; quad, MapCoordinatesFlags mode = UseTransforms, bool* wasFixed = nullptr) const
 578     {
 579         return localToContainerQuad(quad, nullptr, mode, wasFixed);
 580     }
 581     // Convert an absolute quad to local coordinates.
 582     FloatQuad absoluteToLocalQuad(const FloatQuad&amp;, MapCoordinatesFlags mode = UseTransforms) const;
 583 
 584     // Convert a local quad into the coordinate system of container, taking transforms into account.
 585     WEBCORE_EXPORT FloatQuad localToContainerQuad(const FloatQuad&amp;, const RenderLayerModelObject* repaintContainer, MapCoordinatesFlags = UseTransforms, bool* wasFixed = nullptr) const;
 586     WEBCORE_EXPORT FloatPoint localToContainerPoint(const FloatPoint&amp;, const RenderLayerModelObject* repaintContainer, MapCoordinatesFlags = UseTransforms, bool* wasFixed = nullptr) const;
 587 
 588     // Return the offset from the container() renderer (excluding transforms). In multi-column layout,
 589     // different offsets apply at different points, so return the offset that applies to the given point.
 590     virtual LayoutSize offsetFromContainer(RenderElement&amp;, const LayoutPoint&amp;, bool* offsetDependsOnPoint = nullptr) const;
 591     // Return the offset from an object up the container() chain. Asserts that none of the intermediate objects have transforms.
 592     LayoutSize offsetFromAncestorContainer(RenderElement&amp;) const;
 593 
 594 #if PLATFORM(IOS_FAMILY)
 595     virtual void collectSelectionRects(Vector&lt;SelectionRect&gt;&amp;, unsigned startOffset = 0, unsigned endOffset = std::numeric_limits&lt;unsigned&gt;::max());
 596     virtual void absoluteQuadsForSelection(Vector&lt;FloatQuad&gt;&amp; quads) const { absoluteQuads(quads); }
 597 #endif
 598 
 599     virtual void absoluteRects(Vector&lt;IntRect&gt;&amp;, const LayoutPoint&amp;) const { }
 600 
 601     // FIXME: useTransforms should go away eventually
 602     WEBCORE_EXPORT IntRect absoluteBoundingBoxRect(bool useTransform = true, bool* wasFixed = nullptr) const;
 603     IntRect absoluteBoundingBoxRectIgnoringTransforms() const { return absoluteBoundingBoxRect(false); }
 604 
 605     // Build an array of quads in absolute coords for line boxes
 606     virtual void absoluteQuads(Vector&lt;FloatQuad&gt;&amp;, bool* /*wasFixed*/ = nullptr) const { }
 607 
 608     virtual void absoluteFocusRingQuads(Vector&lt;FloatQuad&gt;&amp;);
 609 
 610     static FloatRect absoluteBoundingBoxRectForRange(const Range*);
 611 
 612     // the rect that will be painted if this object is passed as the paintingRoot
 613     WEBCORE_EXPORT LayoutRect paintingRootRect(LayoutRect&amp; topLevelRect);
 614 
 615     virtual LayoutUnit minPreferredLogicalWidth() const { return 0; }
 616     virtual LayoutUnit maxPreferredLogicalWidth() const { return 0; }
 617 
 618     const RenderStyle&amp; style() const;
 619     const RenderStyle&amp; firstLineStyle() const;
 620 
 621     // Anonymous blocks that are part of of a continuation chain will return their inline continuation&#39;s outline style instead.
 622     // This is typically only relevant when repainting.
 623     virtual const RenderStyle&amp; outlineStyleForRepaint() const { return style(); }
 624 
 625     virtual CursorDirective getCursor(const LayoutPoint&amp;, Cursor&amp;) const;
 626 
 627     // Return the RenderLayerModelObject in the container chain which is responsible for painting this object, or nullptr
 628     // if painting is root-relative. This is the container that should be passed to the &#39;forRepaint&#39;
 629     // methods.
 630     RenderLayerModelObject* containerForRepaint() const;
 631     // Actually do the repaint of rect r for this object which has been computed in the coordinate space
 632     // of repaintContainer. If repaintContainer is nullptr, repaint via the view.
 633     void repaintUsingContainer(const RenderLayerModelObject* repaintContainer, const LayoutRect&amp;, bool shouldClipToLayer = true) const;
 634 
 635     // Repaint the entire object.  Called when, e.g., the color of a border changes, or when a border
 636     // style changes.
 637     void repaint() const;
 638 
 639     // Repaint a specific subrectangle within a given object.  The rect |r| is in the object&#39;s coordinate space.
 640     WEBCORE_EXPORT void repaintRectangle(const LayoutRect&amp;, bool shouldClipToLayer = true) const;
 641 
 642     // Repaint a slow repaint object, which, at this time, means we are repainting an object with background-attachment:fixed.
 643     void repaintSlowRepaintObject() const;
 644 
 645     // Returns the rect that should be repainted whenever this object changes.  The rect is in the view&#39;s
 646     // coordinate space.  This method deals with outlines and overflow.
 647     LayoutRect absoluteClippedOverflowRect() const
 648     {
 649         return clippedOverflowRectForRepaint(nullptr);
 650     }
 651     WEBCORE_EXPORT IntRect pixelSnappedAbsoluteClippedOverflowRect() const;
 652     virtual LayoutRect clippedOverflowRectForRepaint(const RenderLayerModelObject* repaintContainer) const;
 653     virtual LayoutRect rectWithOutlineForRepaint(const RenderLayerModelObject* repaintContainer, LayoutUnit outlineWidth) const;
 654     virtual LayoutRect outlineBoundsForRepaint(const RenderLayerModelObject* /*repaintContainer*/, const RenderGeometryMap* = nullptr) const { return LayoutRect(); }
 655 
 656     // Given a rect in the object&#39;s coordinate space, compute a rect suitable for repainting
 657     // that rect in view coordinates.
 658     LayoutRect computeAbsoluteRepaintRect(const LayoutRect&amp; r) const
 659     {
 660         return computeRectForRepaint(r, nullptr);
 661     }
 662     // Given a rect in the object&#39;s coordinate space, compute a rect suitable for repainting
 663     // that rect in the coordinate space of repaintContainer.
 664     LayoutRect computeRectForRepaint(const LayoutRect&amp;, const RenderLayerModelObject* repaintContainer) const;
 665     FloatRect computeFloatRectForRepaint(const FloatRect&amp;, const RenderLayerModelObject* repaintContainer) const;
 666 
 667     // Given a rect in the object&#39;s coordinate space, compute the location in container space where this rect is visible,
 668     // when clipping and scrolling as specified by the context. When using edge-inclusive intersection, return WTF::nullopt
 669     // rather than an empty rect if the rect is completely clipped out in container space.
 670     enum class VisibleRectContextOption {
 671         UseEdgeInclusiveIntersection = 1 &lt;&lt; 0,
 672         ApplyCompositedClips = 1 &lt;&lt; 1,
 673         ApplyCompositedContainerScrolls  = 1 &lt;&lt; 2,
 674         ApplyContainerClip = 1 &lt;&lt; 3,
 675     };
 676     struct VisibleRectContext {
 677         VisibleRectContext(bool hasPositionFixedDescendant = false, bool dirtyRectIsFlipped = false, OptionSet&lt;VisibleRectContextOption&gt; options = { })
 678             : m_hasPositionFixedDescendant(hasPositionFixedDescendant)
 679             , m_dirtyRectIsFlipped(dirtyRectIsFlipped)
 680             , m_options(options)
 681             {
 682             }
 683         bool m_hasPositionFixedDescendant;
 684         bool m_dirtyRectIsFlipped;
 685         OptionSet&lt;VisibleRectContextOption&gt; m_options;
 686     };
 687     virtual Optional&lt;LayoutRect&gt; computeVisibleRectInContainer(const LayoutRect&amp;, const RenderLayerModelObject* repaintContainer, VisibleRectContext) const;
 688     virtual Optional&lt;FloatRect&gt; computeFloatVisibleRectInContainer(const FloatRect&amp;, const RenderLayerModelObject* repaintContainer, VisibleRectContext) const;
 689 
 690     WEBCORE_EXPORT bool hasNonEmptyVisibleRectRespectingParentFrames() const;
 691 
 692     virtual unsigned int length() const { return 1; }
 693 
 694     bool isFloatingOrOutOfFlowPositioned() const { return (isFloating() || isOutOfFlowPositioned()); }
 695 
 696     enum SelectionState {
 697         SelectionNone, // The object is not selected.
 698         SelectionStart, // The object either contains the start of a selection run or is the start of a run
 699         SelectionInside, // The object is fully encompassed by a selection run
 700         SelectionEnd, // The object either contains the end of a selection run or is the end of a run
 701         SelectionBoth // The object contains an entire run or is the sole selected object in that run
 702     };
 703 
 704     // The current selection state for an object.  For blocks, the state refers to the state of the leaf
 705     // descendants (as described above in the SelectionState enum declaration).
 706     SelectionState selectionState() const { return m_bitfields.selectionState(); }
 707     virtual void setSelectionState(SelectionState state) { m_bitfields.setSelectionState(state); }
 708     inline void setSelectionStateIfNeeded(SelectionState);
 709     bool canUpdateSelectionOnRootLineBoxes();
 710 
 711     // A single rectangle that encompasses all of the selected objects within this object.  Used to determine the tightest
 712     // possible bounding box for the selection.
 713     LayoutRect selectionRect(bool clipToVisibleContent = true) { return selectionRectForRepaint(nullptr, clipToVisibleContent); }
 714     virtual LayoutRect selectionRectForRepaint(const RenderLayerModelObject* /*repaintContainer*/, bool /*clipToVisibleContent*/ = true) { return LayoutRect(); }
 715 
 716     virtual bool canBeSelectionLeaf() const { return false; }
 717 
 718     // Whether or not a given block needs to paint selection gaps.
 719     virtual bool shouldPaintSelectionGaps() const { return false; }
 720 
 721     /**
 722      * Returns the local coordinates of the caret within this render object.
 723      * @param caretOffset zero-based offset determining position within the render object.
 724      * @param extraWidthToEndOfLine optional out arg to give extra width to end of line -
 725      * useful for character range rect computations
 726      */
 727     virtual LayoutRect localCaretRect(InlineBox*, unsigned caretOffset, LayoutUnit* extraWidthToEndOfLine = nullptr);
 728 
 729     // When performing a global document tear-down, or when going into the back/forward cache, the renderer of the document is cleared.
 730     bool renderTreeBeingDestroyed() const;
 731 
 732     void destroy();
 733 
 734     // Virtual function helpers for the deprecated Flexible Box Layout (display: -webkit-box).
 735     virtual bool isDeprecatedFlexibleBox() const { return false; }
 736 
 737     // Virtual function helper for the new FlexibleBox Layout (display: -webkit-flex).
 738     virtual bool isFlexibleBox() const { return false; }
 739 
 740     bool isFlexibleBoxIncludingDeprecated() const
 741     {
 742         return isFlexibleBox() || isDeprecatedFlexibleBox();
 743     }
 744 
 745     virtual bool isCombineText() const { return false; }
 746 
 747     virtual int caretMinOffset() const;
 748     virtual int caretMaxOffset() const;
 749 
 750     virtual int previousOffset(int current) const;
 751     virtual int previousOffsetForBackwardDeletion(int current) const;
 752     virtual int nextOffset(int current) const;
 753 
 754     void imageChanged(CachedImage*, const IntRect* = nullptr) override;
 755     virtual void imageChanged(WrappedImagePtr, const IntRect* = nullptr) { }
 756 
 757     CSSAnimationController&amp; animation() const;
 758     DocumentTimeline* documentTimeline() const;
 759 
 760     // Map points and quads through elements, potentially via 3d transforms. You should never need to call these directly; use
 761     // localToAbsolute/absoluteToLocal methods instead.
 762     virtual void mapLocalToContainer(const RenderLayerModelObject* repaintContainer, TransformState&amp;, MapCoordinatesFlags, bool* wasFixed = nullptr) const;
 763     virtual void mapAbsoluteToLocalPoint(MapCoordinatesFlags, TransformState&amp;) const;
 764 
 765     // Pushes state onto RenderGeometryMap about how to map coordinates from this renderer to its container, or ancestorToStopAt (whichever is encountered first).
 766     // Returns the renderer which was mapped to (container or ancestorToStopAt).
 767     virtual const RenderObject* pushMappingToContainer(const RenderLayerModelObject* ancestorToStopAt, RenderGeometryMap&amp;) const;
 768 
 769     bool shouldUseTransformFromContainer(const RenderObject* container) const;
 770     void getTransformFromContainer(const RenderObject* container, const LayoutSize&amp; offsetInContainer, TransformationMatrix&amp;) const;
 771 
 772     virtual void addFocusRingRects(Vector&lt;LayoutRect&gt;&amp;, const LayoutPoint&amp; /* additionalOffset */, const RenderLayerModelObject* /* paintContainer */ = nullptr) { };
 773 
 774     LayoutRect absoluteOutlineBounds() const
 775     {
 776         return outlineBoundsForRepaint(nullptr);
 777     }
 778 
 779     virtual void willBeRemovedFromTree();
 780     void resetFragmentedFlowStateOnRemoval();
 781     void initializeFragmentedFlowStateOnInsertion();
 782     virtual void insertedIntoTree();
 783 
 784 protected:
 785     //////////////////////////////////////////
 786     // Helper functions. Dangerous to use!
 787     void setPreviousSibling(RenderObject* previous) { m_previous = previous; }
 788     void setNextSibling(RenderObject* next) { m_next = next; }
 789     void setParent(RenderElement*);
 790     //////////////////////////////////////////
 791     void addPDFURLRect(PaintInfo&amp;, const LayoutPoint&amp;);
 792     Node&amp; nodeForNonAnonymous() const { ASSERT(!isAnonymous()); return m_node; }
 793 
 794     void adjustRectForOutlineAndShadow(LayoutRect&amp;) const;
 795 
 796     virtual void willBeDestroyed();
 797 
 798     void setNeedsPositionedMovementLayoutBit(bool b) { m_bitfields.setNeedsPositionedMovementLayout(b); }
 799     void setNormalChildNeedsLayoutBit(bool b) { m_bitfields.setNormalChildNeedsLayout(b); }
 800     void setPosChildNeedsLayoutBit(bool b) { m_bitfields.setPosChildNeedsLayout(b); }
 801     void setNeedsSimplifiedNormalFlowLayoutBit(bool b) { m_bitfields.setNeedsSimplifiedNormalFlowLayout(b); }
 802 
 803     virtual RenderFragmentedFlow* locateEnclosingFragmentedFlow() const;
 804     static void calculateBorderStyleColor(const BorderStyle&amp;, const BoxSide&amp;, Color&amp;);
 805 
 806     static FragmentedFlowState computedFragmentedFlowState(const RenderObject&amp;);
 807 
 808     static bool shouldApplyCompositedContainerScrollsForRepaint();
 809 
 810     static VisibleRectContext visibleRectContextForRepaint()
 811     {
 812         return VisibleRectContext(false, false, { VisibleRectContextOption::ApplyContainerClip, VisibleRectContextOption::ApplyCompositedContainerScrolls });
 813     }
 814 
 815 private:
 816 #if ASSERT_ENABLED
 817     bool isSetNeedsLayoutForbidden() const { return m_setNeedsLayoutForbidden; }
 818     void setNeedsLayoutIsForbidden(bool flag) { m_setNeedsLayoutForbidden = flag; }
 819 #endif
 820 
 821     void addAbsoluteRectForLayer(LayoutRect&amp; result);
 822     void setLayerNeedsFullRepaint();
 823     void setLayerNeedsFullRepaintForPositionedMovementLayout();
 824 
 825     Node* generatingPseudoHostElement() const;
 826 
 827     void propagateRepaintToParentWithOutlineAutoIfNeeded(const RenderLayerModelObject&amp; repaintContainer, const LayoutRect&amp; repaintRect) const;
 828 
 829     virtual bool isWBR() const { ASSERT_NOT_REACHED(); return false; }
 830 
 831     void setEverHadLayout(bool b) { m_bitfields.setEverHadLayout(b); }
 832 
 833     bool hasRareData() const { return m_bitfields.hasRareData(); }
 834     void setHasRareData(bool b) { m_bitfields.setHasRareData(b); }
 835 
 836 #if ASSERT_ENABLED
 837     void checkBlockPositionedObjectsNeedLayout();
 838 #endif
 839 
 840     Node&amp; m_node;
 841 
 842     RenderElement* m_parent;
 843     RenderObject* m_previous;
 844     RenderObject* m_next;
 845 
 846 #if ASSERT_ENABLED
 847     bool m_hasAXObject             : 1;
 848     bool m_setNeedsLayoutForbidden : 1;
 849 #endif
 850 
 851 #define ADD_BOOLEAN_BITFIELD(name, Name) \
 852     private:\
 853         unsigned m_##name : 1;\
 854     public:\
 855         bool name() const { return m_##name; }\
 856         void set##Name(bool name) { m_##name = name; }\
 857 
 858 #define ADD_ENUM_BITFIELD(name, Name, Type, width) \
 859     private:\
 860         unsigned m_##name : width;\
 861     public:\
 862         Type name() const { return static_cast&lt;Type&gt;(m_##name); }\
 863         void set##Name(Type name) { m_##name = static_cast&lt;unsigned&gt;(name); }\
 864 
 865     class RenderObjectBitfields {
 866         enum PositionedState {
 867             IsStaticallyPositioned = 0,
 868             IsRelativelyPositioned = 1,
 869             IsOutOfFlowPositioned = 2,
 870             IsStickilyPositioned = 3
 871         };
 872 
 873     public:
 874         RenderObjectBitfields(const Node&amp; node)
 875             : m_hasRareData(false)
 876             , m_beingDestroyed(false)
 877             , m_needsLayout(false)
 878             , m_needsPositionedMovementLayout(false)
 879             , m_normalChildNeedsLayout(false)
 880             , m_posChildNeedsLayout(false)
 881             , m_needsSimplifiedNormalFlowLayout(false)
 882             , m_preferredLogicalWidthsDirty(false)
 883             , m_floating(false)
 884             , m_isAnonymous(node.isDocumentNode())
 885             , m_isTextOrRenderView(false)
 886             , m_isBox(false)
 887             , m_isInline(true)
 888             , m_isReplaced(false)
 889             , m_isLineBreak(false)
 890             , m_horizontalWritingMode(true)
 891             , m_hasLayer(false)
 892             , m_hasOverflowClip(false)
 893             , m_hasTransformRelatedProperty(false)
 894             , m_everHadLayout(false)
 895             , m_childrenInline(false)
 896             , m_isExcludedFromNormalLayout(false)
 897             , m_positionedState(IsStaticallyPositioned)
 898             , m_selectionState(SelectionNone)
 899             , m_fragmentedFlowState(NotInsideFragmentedFlow)
 900             , m_boxDecorationState(NoBoxDecorations)
 901         {
 902         }
 903 
 904         ADD_BOOLEAN_BITFIELD(hasRareData, HasRareData);
 905 
 906         ADD_BOOLEAN_BITFIELD(beingDestroyed, BeingDestroyed);
 907         ADD_BOOLEAN_BITFIELD(needsLayout, NeedsLayout);
 908         ADD_BOOLEAN_BITFIELD(needsPositionedMovementLayout, NeedsPositionedMovementLayout);
 909         ADD_BOOLEAN_BITFIELD(normalChildNeedsLayout, NormalChildNeedsLayout);
 910         ADD_BOOLEAN_BITFIELD(posChildNeedsLayout, PosChildNeedsLayout);
 911         ADD_BOOLEAN_BITFIELD(needsSimplifiedNormalFlowLayout, NeedsSimplifiedNormalFlowLayout);
 912         ADD_BOOLEAN_BITFIELD(preferredLogicalWidthsDirty, PreferredLogicalWidthsDirty);
 913         ADD_BOOLEAN_BITFIELD(floating, Floating);
 914 
 915         ADD_BOOLEAN_BITFIELD(isAnonymous, IsAnonymous);
 916         ADD_BOOLEAN_BITFIELD(isTextOrRenderView, IsTextOrRenderView);
 917         ADD_BOOLEAN_BITFIELD(isBox, IsBox);
 918         ADD_BOOLEAN_BITFIELD(isInline, IsInline);
 919         ADD_BOOLEAN_BITFIELD(isReplaced, IsReplaced);
 920         ADD_BOOLEAN_BITFIELD(isLineBreak, IsLineBreak);
 921         ADD_BOOLEAN_BITFIELD(horizontalWritingMode, HorizontalWritingMode);
 922 
 923         ADD_BOOLEAN_BITFIELD(hasLayer, HasLayer);
 924         ADD_BOOLEAN_BITFIELD(hasOverflowClip, HasOverflowClip); // Set in the case of overflow:auto/scroll/hidden
 925         ADD_BOOLEAN_BITFIELD(hasTransformRelatedProperty, HasTransformRelatedProperty);
 926         ADD_BOOLEAN_BITFIELD(unused, Unused);
 927 
 928         ADD_BOOLEAN_BITFIELD(everHadLayout, EverHadLayout);
 929 
 930         // from RenderBlock
 931         ADD_BOOLEAN_BITFIELD(childrenInline, ChildrenInline);
 932 
 933         ADD_BOOLEAN_BITFIELD(isExcludedFromNormalLayout, IsExcludedFromNormalLayout);
 934 
 935     private:
 936         unsigned m_positionedState : 2; // PositionedState
 937         unsigned m_selectionState : 3; // SelectionState
 938         unsigned m_fragmentedFlowState : 2; // FragmentedFlowState
 939         unsigned m_boxDecorationState : 2; // BoxDecorationState
 940 
 941     public:
 942         bool isOutOfFlowPositioned() const { return m_positionedState == IsOutOfFlowPositioned; }
 943         bool isRelativelyPositioned() const { return m_positionedState == IsRelativelyPositioned; }
 944         bool isStickilyPositioned() const { return m_positionedState == IsStickilyPositioned; }
 945         bool isPositioned() const { return m_positionedState != IsStaticallyPositioned; }
 946 
 947         void setPositionedState(int positionState)
 948         {
 949             // This mask maps PositionType::Fixed and PositionType::Absolute to IsOutOfFlowPositioned, saving one bit.
 950             m_positionedState = static_cast&lt;PositionedState&gt;(positionState &amp; 0x3);
 951         }
 952         void clearPositionedState() { m_positionedState = static_cast&lt;unsigned&gt;(PositionType::Static); }
 953 
 954         ALWAYS_INLINE SelectionState selectionState() const { return static_cast&lt;SelectionState&gt;(m_selectionState); }
 955         ALWAYS_INLINE void setSelectionState(SelectionState selectionState) { m_selectionState = selectionState; }
 956 
 957         ALWAYS_INLINE FragmentedFlowState fragmentedFlowState() const { return static_cast&lt;FragmentedFlowState&gt;(m_fragmentedFlowState); }
 958         ALWAYS_INLINE void setFragmentedFlowState(FragmentedFlowState fragmentedFlowState) { m_fragmentedFlowState = fragmentedFlowState; }
 959 
 960         ALWAYS_INLINE BoxDecorationState boxDecorationState() const { return static_cast&lt;BoxDecorationState&gt;(m_boxDecorationState); }
 961         ALWAYS_INLINE void setBoxDecorationState(BoxDecorationState boxDecorationState) { m_boxDecorationState = boxDecorationState; }
 962     };
 963 
 964     RenderObjectBitfields m_bitfields;
 965 
 966     // FIXME: This should be RenderElementRareData.
 967     class RenderObjectRareData {
 968         WTF_MAKE_FAST_ALLOCATED;
 969     public:
 970         RenderObjectRareData()
 971             : m_isDragging(false)
 972             , m_hasReflection(false)
 973             , m_isRenderFragmentedFlow(false)
 974             , m_hasOutlineAutoAncestor(false)
 975         {
 976         }
 977         ADD_BOOLEAN_BITFIELD(isDragging, IsDragging);
 978         ADD_BOOLEAN_BITFIELD(hasReflection, HasReflection);
 979         ADD_BOOLEAN_BITFIELD(isRenderFragmentedFlow, IsRenderFragmentedFlow);
 980         ADD_BOOLEAN_BITFIELD(hasOutlineAutoAncestor, HasOutlineAutoAncestor);
 981 
 982         // From RenderElement
 983         std::unique_ptr&lt;RenderStyle&gt; cachedFirstLineStyle;
 984     };
 985 
 986     const RenderObject::RenderObjectRareData&amp; rareData() const;
 987     RenderObjectRareData&amp; ensureRareData();
 988     void removeRareData();
 989 
 990     typedef HashMap&lt;const RenderObject*, std::unique_ptr&lt;RenderObjectRareData&gt;&gt; RareDataMap;
 991 
 992     static RareDataMap&amp; rareDataMap();
 993 
 994 #undef ADD_BOOLEAN_BITFIELD
 995 };
 996 
 997 inline Frame&amp; RenderObject::frame() const
 998 {
 999     return *document().frame();
1000 }
1001 
1002 inline Page&amp; RenderObject::page() const
1003 {
1004     // The render tree will always be torn down before Frame is disconnected from Page,
1005     // so it&#39;s safe to assume Frame::page() is non-null as long as there are live RenderObjects.
1006     ASSERT(frame().page());
1007     return *frame().page();
1008 }
1009 
1010 inline CSSAnimationController&amp; RenderObject::animation() const
1011 {
1012     return frame().animation();
1013 }
1014 
1015 inline DocumentTimeline* RenderObject::documentTimeline() const
1016 {
1017     return document().existingTimeline();
1018 }
1019 
1020 inline bool RenderObject::renderTreeBeingDestroyed() const
1021 {
1022     return document().renderTreeBeingDestroyed();
1023 }
1024 
1025 inline bool RenderObject::isBeforeContent() const
1026 {
1027     // Text nodes don&#39;t have their own styles, so ignore the style on a text node.
1028     if (isText())
1029         return false;
1030     if (style().styleType() != PseudoId::Before)
1031         return false;
1032     return true;
1033 }
1034 
1035 inline bool RenderObject::isAfterContent() const
1036 {
1037     // Text nodes don&#39;t have their own styles, so ignore the style on a text node.
1038     if (isText())
1039         return false;
1040     if (style().styleType() != PseudoId::After)
1041         return false;
1042     return true;
1043 }
1044 
1045 inline bool RenderObject::isBeforeOrAfterContent() const
1046 {
1047     return isBeforeContent() || isAfterContent();
1048 }
1049 
1050 inline void RenderObject::setNeedsLayout(MarkingBehavior markParents)
1051 {
1052     ASSERT(!isSetNeedsLayoutForbidden());
1053     if (m_bitfields.needsLayout())
1054         return;
1055     m_bitfields.setNeedsLayout(true);
1056     if (markParents == MarkContainingBlockChain)
1057         markContainingBlocksForLayout();
1058     if (hasLayer())
1059         setLayerNeedsFullRepaint();
1060 }
1061 
1062 inline bool RenderObject::preservesNewline() const
1063 {
1064     if (isSVGInlineText())
1065         return false;
1066 
1067     return style().preserveNewline();
1068 }
1069 
1070 inline void RenderObject::setSelectionStateIfNeeded(SelectionState state)
1071 {
1072     if (selectionState() == state)
1073         return;
1074 
1075     setSelectionState(state);
1076 }
1077 
1078 inline void RenderObject::setHasVisibleBoxDecorations(bool b)
1079 {
1080     if (!b) {
1081         m_bitfields.setBoxDecorationState(NoBoxDecorations);
1082         return;
1083     }
1084     if (hasVisibleBoxDecorations())
1085         return;
1086     m_bitfields.setBoxDecorationState(HasBoxDecorationsAndBackgroundObscurationStatusInvalid);
1087 }
1088 
1089 inline void RenderObject::invalidateBackgroundObscurationStatus()
1090 {
1091     if (!hasVisibleBoxDecorations())
1092         return;
1093     m_bitfields.setBoxDecorationState(HasBoxDecorationsAndBackgroundObscurationStatusInvalid);
1094 }
1095 
1096 inline bool RenderObject::backgroundIsKnownToBeObscured(const LayoutPoint&amp; paintOffset)
1097 {
1098     if (m_bitfields.boxDecorationState() == HasBoxDecorationsAndBackgroundObscurationStatusInvalid) {
1099         BoxDecorationState boxDecorationState = computeBackgroundIsKnownToBeObscured(paintOffset) ? HasBoxDecorationsAndBackgroundIsKnownToBeObscured : HasBoxDecorationsAndBackgroundMayBeVisible;
1100         m_bitfields.setBoxDecorationState(boxDecorationState);
1101     }
1102     return m_bitfields.boxDecorationState() == HasBoxDecorationsAndBackgroundIsKnownToBeObscured;
1103 }
1104 
1105 inline bool RenderObject::needsSimplifiedNormalFlowLayoutOnly() const
1106 {
1107     return m_bitfields.needsSimplifiedNormalFlowLayout() &amp;&amp; !m_bitfields.needsLayout() &amp;&amp; !m_bitfields.normalChildNeedsLayout()
1108         &amp;&amp; !m_bitfields.posChildNeedsLayout() &amp;&amp; !m_bitfields.needsPositionedMovementLayout();
1109 }
1110 
1111 inline void Node::setRenderer(RenderObject* renderer) { m_rendererWithStyleFlags.setPointer(renderer); }
1112 
1113 #if ENABLE(TREE_DEBUGGING)
1114 void printRenderTreeForLiveDocuments();
1115 void printLayerTreeForLiveDocuments();
1116 void printGraphicsLayerTreeForLiveDocuments();
1117 #endif
1118 
1119 } // namespace WebCore
1120 
1121 #define SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(ToValueTypeName, predicate) \
1122 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::ToValueTypeName) \
1123     static bool isType(const WebCore::RenderObject&amp; renderer) { return renderer.predicate; } \
1124 SPECIALIZE_TYPE_TRAITS_END()
1125 
1126 #if ENABLE(TREE_DEBUGGING)
1127 // Outside the WebCore namespace for ease of invocation from the debugger.
1128 void showNodeTree(const WebCore::RenderObject*);
1129 void showLineTree(const WebCore::RenderObject*);
1130 void showRenderTree(const WebCore::RenderObject*);
1131 #endif
    </pre>
  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PropertyCondition.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PropertyCondition.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PropertyCondition.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PropertyCondition.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2015-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2015-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -38,10 +38,11 @@
     enum Kind : uint8_t {
         Presence,
         Absence,
         AbsenceOfSetEffect,
         Equivalence, // An adaptive watchpoint on this will be a pair of watchpoints, and when the structure transitions, we will set the replacement watchpoint on the new structure.
+        CustomFunctionEquivalence, // Custom value or accessor.
         HasPrototype
     };
 
     using Header = CompactPointerTuple<UniquedStringImpl*, Kind>;
 
@@ -121,10 +122,17 @@
         if (value.isCell() && owner)
             vm.heap.writeBarrier(owner);
         return equivalenceWithoutBarrier(uid, value);
     }
 
+    static PropertyCondition customFunctionEquivalence(UniquedStringImpl* uid)
+    {
+        PropertyCondition result;
+        result.m_header = Header(uid, CustomFunctionEquivalence);
+        return result;
+    }
+
     static PropertyCondition hasPrototypeWithoutBarrier(JSObject* prototype)
     {
         PropertyCondition result;
         result.m_header = Header(nullptr, HasPrototype);
         result.u.prototype.prototype = prototype;
@@ -191,10 +199,12 @@
             result ^= WTF::PtrHash<JSObject*>::hash(u.prototype.prototype);
             break;
         case Equivalence:
             result ^= EncodedJSValueHash::hash(u.equivalence.value);
             break;
+        case CustomFunctionEquivalence:
+            break;
         }
         return result;
     }
 
     bool operator==(const PropertyCondition& other) const
@@ -211,10 +221,12 @@
         case AbsenceOfSetEffect:
         case HasPrototype:
             return u.prototype.prototype == other.u.prototype.prototype;
         case Equivalence:
             return u.equivalence.value == other.u.equivalence.value;
+        case CustomFunctionEquivalence:
+            return true;
         }
         RELEASE_ASSERT_NOT_REACHED();
         return false;
     }
 
@@ -277,16 +289,16 @@
     };
 
     // This means that it's still valid and we could enforce validity by setting a transition
     // watchpoint on the structure and possibly an impure property watchpoint.
     bool isWatchableAssumingImpurePropertyWatchpoint(
-        Structure*, JSObject* base = nullptr, WatchabilityEffort = MakeNoChanges) const;
+        Structure*, JSObject* base, WatchabilityEffort = MakeNoChanges) const;
 
     // This means that it's still valid and we could enforce validity by setting a transition
     // watchpoint on the structure.
     bool isWatchable(
-        Structure*, JSObject* base = nullptr, WatchabilityEffort = MakeNoChanges) const;
+        Structure*, JSObject*, WatchabilityEffort = MakeNoChanges) const;
 
     bool watchingRequiresStructureTransitionWatchpoint() const
     {
         // Currently, this is required for all of our conditions.
         return !!*this;
@@ -294,12 +306,19 @@
     bool watchingRequiresReplacementWatchpoint() const
     {
         return !!*this && m_header.type() == Equivalence;
     }
 
-    // This means that the objects involved in this are still live.
-    bool isStillLive(VM&) const;
+    template<typename Functor>
+    void forEachDependentCell(const Functor& functor) const
+    {
+        if (hasPrototype() && prototype())
+            functor(prototype());
+
+        if (hasRequiredValue() && requiredValue() && requiredValue().isCell())
+            functor(requiredValue().asCell());
+    }
 
     void validateReferences(const TrackedReferences&) const;
 
     static bool isValidValueForAttributes(VM&, JSValue, unsigned attributes);
 
@@ -330,11 +349,11 @@
     static bool equal(
         const PropertyCondition& a, const PropertyCondition& b)
     {
         return a == b;
     }
-    static const bool safeToCompareToEmptyOrDeleted = true;
+    static constexpr bool safeToCompareToEmptyOrDeleted = true;
 };
 
 } // namespace JSC
 
 namespace WTF {

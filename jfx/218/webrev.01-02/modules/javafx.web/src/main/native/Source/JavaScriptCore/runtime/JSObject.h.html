<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSObject.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
   4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.
   5  *
   6  *  This library is free software; you can redistribute it and/or
   7  *  modify it under the terms of the GNU Library General Public
   8  *  License as published by the Free Software Foundation; either
   9  *  version 2 of the License, or (at your option) any later version.
  10  *
  11  *  This library is distributed in the hope that it will be useful,
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #pragma once
  24 
  25 #include &quot;ArrayConventions.h&quot;
  26 #include &quot;ArrayStorage.h&quot;
  27 #include &quot;Butterfly.h&quot;
  28 #include &quot;CPU.h&quot;
  29 #include &quot;CagedBarrierPtr.h&quot;
  30 #include &quot;CallFrame.h&quot;
  31 #include &quot;ClassInfo.h&quot;
  32 #include &quot;CustomGetterSetter.h&quot;
  33 #include &quot;DOMAttributeGetterSetter.h&quot;
  34 #include &quot;Heap.h&quot;
  35 #include &quot;IndexingHeaderInlines.h&quot;
  36 #include &quot;JSCast.h&quot;
  37 #include &quot;ObjectInitializationScope.h&quot;
  38 #include &quot;PropertySlot.h&quot;
  39 #include &quot;PropertyStorage.h&quot;
  40 #include &quot;PutDirectIndexMode.h&quot;
  41 #include &quot;PutPropertySlot.h&quot;
  42 #include &quot;Structure.h&quot;
  43 #include &quot;StructureTransitionTable.h&quot;
  44 #include &quot;VM.h&quot;
  45 #include &quot;JSString.h&quot;
  46 #include &quot;SparseArrayValueMap.h&quot;
  47 #include &lt;wtf/StdLibExtras.h&gt;
  48 
  49 namespace JSC {
  50 namespace DOMJIT {
  51 class Signature;
  52 }
  53 
  54 inline JSCell* getJSFunction(JSValue value)
  55 {
  56     if (value.isCell() &amp;&amp; (value.asCell()-&gt;type() == JSFunctionType))
  57         return value.asCell();
  58     return nullptr;
  59 }
  60 
  61 class Exception;
  62 class GetterSetter;
  63 class InternalFunction;
  64 class JSFunction;
  65 class LLIntOffsetsExtractor;
  66 class MarkedBlock;
  67 class PropertyDescriptor;
  68 class PropertyNameArray;
  69 class Structure;
  70 class ThrowScope;
  71 struct HashTable;
  72 struct HashTableValue;
  73 
  74 JS_EXPORT_PRIVATE Exception* throwTypeError(JSGlobalObject*, ThrowScope&amp;, const String&amp;);
  75 extern JS_EXPORT_PRIVATE const ASCIILiteral NonExtensibleObjectPropertyDefineError;
  76 extern JS_EXPORT_PRIVATE const ASCIILiteral ReadonlyPropertyWriteError;
  77 extern JS_EXPORT_PRIVATE const ASCIILiteral ReadonlyPropertyChangeError;
  78 extern JS_EXPORT_PRIVATE const ASCIILiteral UnableToDeletePropertyError;
  79 extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeAccessMechanismError;
  80 extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeConfigurabilityError;
  81 extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeEnumerabilityError;
  82 extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeWritabilityError;
  83 
  84 COMPILE_ASSERT(PropertyAttribute::None &lt; FirstInternalAttribute, None_is_below_FirstInternalAttribute);
  85 COMPILE_ASSERT(PropertyAttribute::ReadOnly &lt; FirstInternalAttribute, ReadOnly_is_below_FirstInternalAttribute);
  86 COMPILE_ASSERT(PropertyAttribute::DontEnum &lt; FirstInternalAttribute, DontEnum_is_below_FirstInternalAttribute);
  87 COMPILE_ASSERT(PropertyAttribute::DontDelete &lt; FirstInternalAttribute, DontDelete_is_below_FirstInternalAttribute);
  88 COMPILE_ASSERT(PropertyAttribute::Accessor &lt; FirstInternalAttribute, Accessor_is_below_FirstInternalAttribute);
  89 
  90 class JSFinalObject;
  91 
  92 class JSObject : public JSCell {
  93     friend class BatchedTransitionOptimizer;
  94     friend class JIT;
  95     friend class JSCell;
  96     friend class JSFinalObject;
  97     friend class MarkedBlock;
  98     JS_EXPORT_PRIVATE friend bool setUpStaticFunctionSlot(VM&amp;, const HashTableValue*, JSObject*, PropertyName, PropertySlot&amp;);
  99 
 100     enum PutMode {
 101         PutModePut,
 102         PutModeDefineOwnProperty,
 103     };
 104 
 105 public:
 106     using Base = JSCell;
 107 
 108     // Don&#39;t call this directly. Call JSC::subspaceFor&lt;Type&gt;(vm) instead.
 109     // FIXME: Refer to Subspace by reference.
 110     // https://bugs.webkit.org/show_bug.cgi?id=166988
 111     template&lt;typename CellType, SubspaceAccess&gt;
 112     static CompleteSubspace* subspaceFor(VM&amp;);
 113 
 114     // This is a super dangerous method for JITs. Sometimes the JITs will want to create either a
 115     // JSFinalObject or a JSArray. This is the method that will do that.
 116     static JSObject* createRawObject(VM&amp; vm, Structure* structure, Butterfly* = nullptr);
 117 
 118     JS_EXPORT_PRIVATE static size_t estimatedSize(JSCell*, VM&amp;);
 119     JS_EXPORT_PRIVATE static void visitChildren(JSCell*, SlotVisitor&amp;);
 120     JS_EXPORT_PRIVATE static void analyzeHeap(JSCell*, HeapAnalyzer&amp;);
 121 
 122     JS_EXPORT_PRIVATE static String className(const JSObject*, VM&amp;);
 123     JS_EXPORT_PRIVATE static String calculatedClassName(JSObject*);
 124 
 125     // This function is what Object.prototype.toString() will use to get the name of
 126     // an object when using Symbol.toStringTag fails. For the most part there is no
 127     // difference between this and className(). The main use case is for new JS language
 128     // objects to set the default tag to &quot;Object&quot;.
 129     JS_EXPORT_PRIVATE static String toStringName(const JSObject*, JSGlobalObject*);
 130 
 131     // This is the fully virtual [[GetPrototypeOf]] internal function defined
 132     // in the ECMAScript 6 specification. Use this when doing a [[GetPrototypeOf]]
 133     // operation as dictated in the specification.
 134     JSValue getPrototype(VM&amp;, JSGlobalObject*);
 135     JS_EXPORT_PRIVATE static JSValue getPrototype(JSObject*, JSGlobalObject*);
 136     // This gets the prototype directly off of the structure. This does not do
 137     // dynamic dispatch on the getPrototype method table method. It is not valid
 138     // to use this when performing a [[GetPrototypeOf]] operation in the specification.
 139     // It is valid to use though when you know that you want to directly get it
 140     // without consulting the method table. This is akin to getting the [[Prototype]]
 141     // internal field directly as described in the specification.
 142     JSValue getPrototypeDirect(VM&amp;) const;
 143 
 144     // This sets the prototype without checking for cycles and without
 145     // doing dynamic dispatch on [[SetPrototypeOf]] operation in the specification.
 146     // It is not valid to use this when performing a [[SetPrototypeOf]] operation in
 147     // the specification. It is valid to use though when you know that you want to directly
 148     // set it without consulting the method table and when you definitely won&#39;t
 149     // introduce a cycle in the prototype chain. This is akin to setting the
 150     // [[Prototype]] internal field directly as described in the specification.
 151     JS_EXPORT_PRIVATE void setPrototypeDirect(VM&amp;, JSValue prototype);
 152 private:
 153     // This is OrdinarySetPrototypeOf in the specification. Section 9.1.2.1
 154     // https://tc39.github.io/ecma262/#sec-ordinarysetprototypeof
 155     JS_EXPORT_PRIVATE bool setPrototypeWithCycleCheck(VM&amp;, JSGlobalObject*, JSValue prototype, bool shouldThrowIfCantSet);
 156 public:
 157     // This is the fully virtual [[SetPrototypeOf]] internal function defined
 158     // in the ECMAScript 6 specification. Use this when doing a [[SetPrototypeOf]]
 159     // operation as dictated in the specification.
 160     bool setPrototype(VM&amp;, JSGlobalObject*, JSValue prototype, bool shouldThrowIfCantSet = false);
 161     JS_EXPORT_PRIVATE static bool setPrototype(JSObject*, JSGlobalObject*, JSValue prototype, bool shouldThrowIfCantSet);
 162 
 163     inline bool mayInterceptIndexedAccesses(VM&amp;);
 164 
 165     JSValue get(JSGlobalObject*, PropertyName) const;
 166     JSValue get(JSGlobalObject*, unsigned propertyName) const;
 167 
 168     template&lt;bool checkNullStructure = false&gt;
 169     bool getPropertySlot(JSGlobalObject*, PropertyName, PropertySlot&amp;);
 170     bool getPropertySlot(JSGlobalObject*, unsigned propertyName, PropertySlot&amp;);
 171     template&lt;typename CallbackWhenNoException&gt; typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type getPropertySlot(JSGlobalObject*, PropertyName, CallbackWhenNoException) const;
 172     template&lt;typename CallbackWhenNoException&gt; typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type getPropertySlot(JSGlobalObject*, PropertyName, PropertySlot&amp;, CallbackWhenNoException) const;
 173 
 174     static bool getOwnPropertySlot(JSObject*, JSGlobalObject*, PropertyName, PropertySlot&amp;);
 175     JS_EXPORT_PRIVATE static bool getOwnPropertySlotByIndex(JSObject*, JSGlobalObject*, unsigned propertyName, PropertySlot&amp;);
 176     bool getOwnPropertySlotInline(JSGlobalObject*, PropertyName, PropertySlot&amp;);
 177     static void doPutPropertySecurityCheck(JSObject*, JSGlobalObject*, PropertyName, PutPropertySlot&amp;);
 178 
 179     // The key difference between this and getOwnPropertySlot is that getOwnPropertySlot
 180     // currently returns incorrect results for the DOM window (with non-own properties)
 181     // being returned. Once this is fixed we should migrate code &amp; remove this method.
 182     JS_EXPORT_PRIVATE bool getOwnPropertyDescriptor(JSGlobalObject*, PropertyName, PropertyDescriptor&amp;);
 183 
 184     unsigned getArrayLength() const
 185     {
 186         if (!hasIndexedProperties(indexingType()))
 187             return 0;
 188         return m_butterfly-&gt;publicLength();
 189     }
 190 
 191     unsigned getVectorLength()
 192     {
 193         if (!hasIndexedProperties(indexingType()))
 194             return 0;
 195         return m_butterfly-&gt;vectorLength();
 196     }
 197 
 198     static bool putInlineForJSObject(JSCell*, JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);
 199 
 200     JS_EXPORT_PRIVATE static bool put(JSCell*, JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);
 201     // putByIndex assumes that the receiver is this JSCell object.
 202     JS_EXPORT_PRIVATE static bool putByIndex(JSCell*, JSGlobalObject*, unsigned propertyName, JSValue, bool shouldThrow);
 203 
 204     // This performs the ECMAScript Set() operation.
 205     ALWAYS_INLINE bool putByIndexInline(JSGlobalObject* globalObject, unsigned propertyName, JSValue value, bool shouldThrow)
 206     {
 207         VM&amp; vm = getVM(globalObject);
 208         if (canSetIndexQuickly(propertyName, value)) {
 209             setIndexQuickly(vm, propertyName, value);
 210             return true;
 211         }
 212         return methodTable(vm)-&gt;putByIndex(this, globalObject, propertyName, value, shouldThrow);
 213     }
 214 
 215     // This is similar to the putDirect* methods:
 216     //  - the prototype chain is not consulted
 217     //  - accessors are not called.
 218     //  - it will ignore extensibility and read-only properties if PutDirectIndexLikePutDirect is passed as the mode (the default).
 219     // This method creates a property with attributes writable, enumerable and configurable all set to true if attributes is zero,
 220     // otherwise, it creates a property with the provided attributes. Semantically, this is performing defineOwnProperty.
 221     bool putDirectIndex(JSGlobalObject* globalObject, unsigned propertyName, JSValue value, unsigned attributes, PutDirectIndexMode mode)
 222     {
 223         ASSERT(!value.isCustomGetterSetter());
 224         auto canSetIndexQuicklyForPutDirect = [&amp;] () -&gt; bool {
 225             switch (indexingMode()) {
 226             case ALL_BLANK_INDEXING_TYPES:
 227             case ALL_UNDECIDED_INDEXING_TYPES:
 228                 return false;
 229             case ALL_WRITABLE_INT32_INDEXING_TYPES:
 230             case ALL_WRITABLE_DOUBLE_INDEXING_TYPES:
 231             case ALL_WRITABLE_CONTIGUOUS_INDEXING_TYPES:
 232             case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 233                 return propertyName &lt; m_butterfly-&gt;vectorLength();
 234             default:
 235                 if (isCopyOnWrite(indexingMode()))
 236                     return false;
 237                 RELEASE_ASSERT_NOT_REACHED();
 238                 return false;
 239             }
 240         };
 241 
 242         if (!attributes &amp;&amp; canSetIndexQuicklyForPutDirect()) {
 243             setIndexQuickly(getVM(globalObject), propertyName, value);
 244             return true;
 245         }
 246         return putDirectIndexSlowOrBeyondVectorLength(globalObject, propertyName, value, attributes, mode);
 247     }
 248     // This is semantically equivalent to performing defineOwnProperty(propertyName, {configurable:true, writable:true, enumerable:true, value:value}).
 249     bool putDirectIndex(JSGlobalObject* globalObject, unsigned propertyName, JSValue value)
 250     {
 251         return putDirectIndex(globalObject, propertyName, value, 0, PutDirectIndexLikePutDirect);
 252     }
 253 
 254     // A generally non-throwing version of putDirect and putDirectIndex.
 255     // However, it&#39;s only guaranteed to not throw based on what the receiver is.
 256     // For example, if the receiver is a ProxyObject, this is not guaranteed, since
 257     // it may call into arbitrary JS code. It&#39;s the responsibility of the user of
 258     // this API to ensure that the receiver object is a well known type if they
 259     // want to ensure that this won&#39;t throw an exception.
 260     JS_EXPORT_PRIVATE bool putDirectMayBeIndex(JSGlobalObject*, PropertyName, JSValue);
 261 
 262     bool hasIndexingHeader(VM&amp; vm) const
 263     {
 264         return structure(vm)-&gt;hasIndexingHeader(this);
 265     }
 266 
 267     bool canGetIndexQuicklyForTypedArray(unsigned) const;
 268     JSValue getIndexQuicklyForTypedArray(unsigned) const;
 269 
 270     bool canGetIndexQuickly(unsigned i) const
 271     {
 272         const Butterfly* butterfly = this-&gt;butterfly();
 273         switch (indexingType()) {
 274         case ALL_BLANK_INDEXING_TYPES:
 275             return canGetIndexQuicklyForTypedArray(i);
 276         case ALL_UNDECIDED_INDEXING_TYPES:
 277             return false;
 278         case ALL_INT32_INDEXING_TYPES:
 279         case ALL_CONTIGUOUS_INDEXING_TYPES:
 280             return i &lt; butterfly-&gt;vectorLength() &amp;&amp; butterfly-&gt;contiguous().at(this, i);
 281         case ALL_DOUBLE_INDEXING_TYPES: {
 282             if (i &gt;= butterfly-&gt;vectorLength())
 283                 return false;
 284             double value = butterfly-&gt;contiguousDouble().at(this, i);
 285             if (value != value)
 286                 return false;
 287             return true;
 288         }
 289         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 290             return i &lt; butterfly-&gt;arrayStorage()-&gt;vectorLength() &amp;&amp; butterfly-&gt;arrayStorage()-&gt;m_vector[i];
 291         default:
 292             RELEASE_ASSERT_NOT_REACHED();
 293             return false;
 294         }
 295     }
 296 
 297     JSValue getIndexQuickly(unsigned i) const
 298     {
 299         const Butterfly* butterfly = this-&gt;butterfly();
 300         switch (indexingType()) {
 301         case ALL_INT32_INDEXING_TYPES:
 302             return jsNumber(butterfly-&gt;contiguous().at(this, i).get().asInt32());
 303         case ALL_CONTIGUOUS_INDEXING_TYPES:
 304             return butterfly-&gt;contiguous().at(this, i).get();
 305         case ALL_DOUBLE_INDEXING_TYPES:
 306             return JSValue(JSValue::EncodeAsDouble, butterfly-&gt;contiguousDouble().at(this, i));
 307         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 308             return butterfly-&gt;arrayStorage()-&gt;m_vector[i].get();
 309         case ALL_BLANK_INDEXING_TYPES:
 310             return getIndexQuicklyForTypedArray(i);
 311         default:
 312             RELEASE_ASSERT_NOT_REACHED();
 313             return JSValue();
 314         }
 315     }
 316 
 317     JSValue tryGetIndexQuickly(unsigned i) const
 318     {
 319         const Butterfly* butterfly = this-&gt;butterfly();
 320         switch (indexingType()) {
 321         case ALL_BLANK_INDEXING_TYPES:
 322             if (canGetIndexQuicklyForTypedArray(i))
 323                 return getIndexQuicklyForTypedArray(i);
 324             break;
 325         case ALL_UNDECIDED_INDEXING_TYPES:
 326             break;
 327         case ALL_INT32_INDEXING_TYPES:
 328             if (i &lt; butterfly-&gt;publicLength()) {
 329                 JSValue result = butterfly-&gt;contiguous().at(this, i).get();
 330                 ASSERT(result.isInt32() || !result);
 331                 return result;
 332             }
 333             break;
 334         case ALL_CONTIGUOUS_INDEXING_TYPES:
 335             if (i &lt; butterfly-&gt;publicLength())
 336                 return butterfly-&gt;contiguous().at(this, i).get();
 337             break;
 338         case ALL_DOUBLE_INDEXING_TYPES: {
 339             if (i &gt;= butterfly-&gt;publicLength())
 340                 break;
 341             double result = butterfly-&gt;contiguousDouble().at(this, i);
 342             if (result != result)
 343                 break;
 344             return JSValue(JSValue::EncodeAsDouble, result);
 345         }
 346         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 347             if (i &lt; butterfly-&gt;arrayStorage()-&gt;vectorLength())
 348                 return butterfly-&gt;arrayStorage()-&gt;m_vector[i].get();
 349             break;
 350         default:
 351             RELEASE_ASSERT_NOT_REACHED();
 352             break;
 353         }
 354         return JSValue();
 355     }
 356 
 357     JSValue getDirectIndex(JSGlobalObject* globalObject, unsigned i)
 358     {
 359         if (JSValue result = tryGetIndexQuickly(i))
 360             return result;
 361         PropertySlot slot(this, PropertySlot::InternalMethodType::Get);
 362         if (methodTable(getVM(globalObject))-&gt;getOwnPropertySlotByIndex(this, globalObject, i, slot))
 363             return slot.getValue(globalObject, i);
 364         return JSValue();
 365     }
 366 
 367     JSValue getIndex(JSGlobalObject* globalObject, unsigned i) const
 368     {
 369         if (JSValue result = tryGetIndexQuickly(i))
 370             return result;
 371         return get(globalObject, i);
 372     }
 373 
 374     bool canSetIndexQuicklyForTypedArray(unsigned, JSValue) const;
 375     void setIndexQuicklyForTypedArray(unsigned, JSValue);
 376 
 377     bool canSetIndexQuickly(unsigned i, JSValue value)
 378     {
 379         Butterfly* butterfly = this-&gt;butterfly();
 380         switch (indexingMode()) {
 381         case ALL_BLANK_INDEXING_TYPES:
 382             return canSetIndexQuicklyForTypedArray(i, value);
 383         case ALL_UNDECIDED_INDEXING_TYPES:
 384             return false;
 385         case ALL_WRITABLE_INT32_INDEXING_TYPES:
 386         case ALL_WRITABLE_DOUBLE_INDEXING_TYPES:
 387         case ALL_WRITABLE_CONTIGUOUS_INDEXING_TYPES:
 388         case NonArrayWithArrayStorage:
 389         case ArrayWithArrayStorage:
 390             return i &lt; butterfly-&gt;vectorLength();
 391         case NonArrayWithSlowPutArrayStorage:
 392         case ArrayWithSlowPutArrayStorage:
 393             return i &lt; butterfly-&gt;arrayStorage()-&gt;vectorLength()
 394                 &amp;&amp; !!butterfly-&gt;arrayStorage()-&gt;m_vector[i];
 395         default:
 396             if (isCopyOnWrite(indexingMode()))
 397                 return false;
 398             RELEASE_ASSERT_NOT_REACHED();
 399             return false;
 400         }
 401     }
 402 
 403     void setIndexQuickly(VM&amp; vm, unsigned i, JSValue v)
 404     {
 405         Butterfly* butterfly = m_butterfly.get();
 406         ASSERT(!isCopyOnWrite(indexingMode()));
 407         switch (indexingType()) {
 408         case ALL_INT32_INDEXING_TYPES: {
 409             ASSERT(i &lt; butterfly-&gt;vectorLength());
 410             if (!v.isInt32()) {
 411                 convertInt32ToDoubleOrContiguousWhilePerformingSetIndex(vm, i, v);
 412                 return;
 413             }
 414             FALLTHROUGH;
 415         }
 416         case ALL_CONTIGUOUS_INDEXING_TYPES: {
 417             ASSERT(i &lt; butterfly-&gt;vectorLength());
 418             butterfly-&gt;contiguous().at(this, i).setWithoutWriteBarrier(v);
 419             if (i &gt;= butterfly-&gt;publicLength())
 420                 butterfly-&gt;setPublicLength(i + 1);
 421             vm.heap.writeBarrier(this, v);
 422             break;
 423         }
 424         case ALL_DOUBLE_INDEXING_TYPES: {
 425             ASSERT(i &lt; butterfly-&gt;vectorLength());
 426             if (!v.isNumber()) {
 427                 convertDoubleToContiguousWhilePerformingSetIndex(vm, i, v);
 428                 return;
 429             }
 430             double value = v.asNumber();
 431             if (value != value) {
 432                 convertDoubleToContiguousWhilePerformingSetIndex(vm, i, v);
 433                 return;
 434             }
 435             butterfly-&gt;contiguousDouble().at(this, i) = value;
 436             if (i &gt;= butterfly-&gt;publicLength())
 437                 butterfly-&gt;setPublicLength(i + 1);
 438             break;
 439         }
 440         case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
 441             ArrayStorage* storage = butterfly-&gt;arrayStorage();
 442             WriteBarrier&lt;Unknown&gt;&amp; x = storage-&gt;m_vector[i];
 443             JSValue old = x.get();
 444             x.set(vm, this, v);
 445             if (!old) {
 446                 ++storage-&gt;m_numValuesInVector;
 447                 if (i &gt;= storage-&gt;length())
 448                     storage-&gt;setLength(i + 1);
 449             }
 450             break;
 451         }
 452         case ALL_BLANK_INDEXING_TYPES:
 453             setIndexQuicklyForTypedArray(i, v);
 454             break;
 455         default:
 456             RELEASE_ASSERT_NOT_REACHED();
 457         }
 458     }
 459 
 460     void initializeIndex(ObjectInitializationScope&amp; scope, unsigned i, JSValue v)
 461     {
 462         initializeIndex(scope, i, v, indexingType());
 463     }
 464 
 465     // NOTE: Clients of this method may call it more than once for any index, and this is supposed
 466     // to work.
 467     ALWAYS_INLINE void initializeIndex(ObjectInitializationScope&amp; scope, unsigned i, JSValue v, IndexingType indexingType)
 468     {
 469         VM&amp; vm = scope.vm();
 470         Butterfly* butterfly = m_butterfly.get();
 471         switch (indexingType) {
 472         case ALL_UNDECIDED_INDEXING_TYPES: {
 473             setIndexQuicklyToUndecided(vm, i, v);
 474             break;
 475         }
 476         case ALL_INT32_INDEXING_TYPES: {
 477             ASSERT(i &lt; butterfly-&gt;publicLength());
 478             ASSERT(i &lt; butterfly-&gt;vectorLength());
 479             if (!v.isInt32()) {
 480                 convertInt32ToDoubleOrContiguousWhilePerformingSetIndex(vm, i, v);
 481                 break;
 482             }
 483             FALLTHROUGH;
 484         }
 485         case ALL_CONTIGUOUS_INDEXING_TYPES: {
 486             ASSERT(i &lt; butterfly-&gt;publicLength());
 487             ASSERT(i &lt; butterfly-&gt;vectorLength());
 488             butterfly-&gt;contiguous().at(this, i).set(vm, this, v);
 489             break;
 490         }
 491         case ALL_DOUBLE_INDEXING_TYPES: {
 492             ASSERT(i &lt; butterfly-&gt;publicLength());
 493             ASSERT(i &lt; butterfly-&gt;vectorLength());
 494             if (!v.isNumber()) {
 495                 convertDoubleToContiguousWhilePerformingSetIndex(vm, i, v);
 496                 return;
 497             }
 498             double value = v.asNumber();
 499             if (value != value) {
 500                 convertDoubleToContiguousWhilePerformingSetIndex(vm, i, v);
 501                 return;
 502             }
 503             butterfly-&gt;contiguousDouble().at(this, i) = value;
 504             break;
 505         }
 506         case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
 507             ArrayStorage* storage = butterfly-&gt;arrayStorage();
 508             ASSERT(i &lt; storage-&gt;length());
 509             ASSERT(i &lt; storage-&gt;m_numValuesInVector);
 510             storage-&gt;m_vector[i].set(vm, this, v);
 511             break;
 512         }
 513         default:
 514             RELEASE_ASSERT_NOT_REACHED();
 515         }
 516     }
 517 
 518     void initializeIndexWithoutBarrier(ObjectInitializationScope&amp; scope, unsigned i, JSValue v)
 519     {
 520         initializeIndexWithoutBarrier(scope, i, v, indexingType());
 521     }
 522 
 523     // This version of initializeIndex is for cases where you know that you will not need any
 524     // barriers. This implies not having any data format conversions.
 525     ALWAYS_INLINE void initializeIndexWithoutBarrier(ObjectInitializationScope&amp;, unsigned i, JSValue v, IndexingType indexingType)
 526     {
 527         Butterfly* butterfly = m_butterfly.get();
 528         switch (indexingType) {
 529         case ALL_UNDECIDED_INDEXING_TYPES: {
 530             RELEASE_ASSERT_NOT_REACHED();
 531             break;
 532         }
 533         case ALL_INT32_INDEXING_TYPES: {
 534             ASSERT(i &lt; butterfly-&gt;publicLength());
 535             ASSERT(i &lt; butterfly-&gt;vectorLength());
 536             RELEASE_ASSERT(v.isInt32());
 537             FALLTHROUGH;
 538         }
 539         case ALL_CONTIGUOUS_INDEXING_TYPES: {
 540             ASSERT(i &lt; butterfly-&gt;publicLength());
 541             ASSERT(i &lt; butterfly-&gt;vectorLength());
 542             butterfly-&gt;contiguous().at(this, i).setWithoutWriteBarrier(v);
 543             break;
 544         }
 545         case ALL_DOUBLE_INDEXING_TYPES: {
 546             ASSERT(i &lt; butterfly-&gt;publicLength());
 547             ASSERT(i &lt; butterfly-&gt;vectorLength());
 548             RELEASE_ASSERT(v.isNumber());
 549             double value = v.asNumber();
 550             RELEASE_ASSERT(value == value);
 551             butterfly-&gt;contiguousDouble().at(this, i) = value;
 552             break;
 553         }
 554         case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
 555             ArrayStorage* storage = butterfly-&gt;arrayStorage();
 556             ASSERT(i &lt; storage-&gt;length());
 557             ASSERT(i &lt; storage-&gt;m_numValuesInVector);
 558             storage-&gt;m_vector[i].setWithoutWriteBarrier(v);
 559             break;
 560         }
 561         default:
 562             RELEASE_ASSERT_NOT_REACHED();
 563         }
 564     }
 565 
 566     bool hasSparseMap()
 567     {
 568         switch (indexingType()) {
 569         case ALL_BLANK_INDEXING_TYPES:
 570         case ALL_UNDECIDED_INDEXING_TYPES:
 571         case ALL_INT32_INDEXING_TYPES:
 572         case ALL_DOUBLE_INDEXING_TYPES:
 573         case ALL_CONTIGUOUS_INDEXING_TYPES:
 574             return false;
 575         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 576             return !!m_butterfly-&gt;arrayStorage()-&gt;m_sparseMap;
 577         default:
 578             RELEASE_ASSERT_NOT_REACHED();
 579             return false;
 580         }
 581     }
 582 
 583     bool inSparseIndexingMode()
 584     {
 585         switch (indexingType()) {
 586         case ALL_BLANK_INDEXING_TYPES:
 587         case ALL_UNDECIDED_INDEXING_TYPES:
 588         case ALL_INT32_INDEXING_TYPES:
 589         case ALL_DOUBLE_INDEXING_TYPES:
 590         case ALL_CONTIGUOUS_INDEXING_TYPES:
 591             return false;
 592         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 593             return m_butterfly-&gt;arrayStorage()-&gt;inSparseMode();
 594         default:
 595             RELEASE_ASSERT_NOT_REACHED();
 596             return false;
 597         }
 598     }
 599 
 600     void enterDictionaryIndexingMode(VM&amp;);
 601 
 602     // putDirect is effectively an unchecked vesion of &#39;defineOwnProperty&#39;:
 603     //  - the prototype chain is not consulted
 604     //  - accessors are not called.
 605     //  - attributes will be respected (after the call the property will exist with the given attributes)
 606     //  - the property name is assumed to not be an index.
 607     bool putDirect(VM&amp;, PropertyName, JSValue, unsigned attributes = 0);
 608     bool putDirect(VM&amp;, PropertyName, JSValue, PutPropertySlot&amp;);
 609     void putDirectWithoutTransition(VM&amp;, PropertyName, JSValue, unsigned attributes = 0);
 610     bool putDirectNonIndexAccessor(VM&amp;, PropertyName, GetterSetter*, unsigned attributes);
 611     void putDirectNonIndexAccessorWithoutTransition(VM&amp;, PropertyName, GetterSetter*, unsigned attributes);
 612     bool putDirectAccessor(JSGlobalObject*, PropertyName, GetterSetter*, unsigned attributes);
 613     JS_EXPORT_PRIVATE bool putDirectCustomAccessor(VM&amp;, PropertyName, JSValue, unsigned attributes);
 614 
 615     bool putGetter(JSGlobalObject*, PropertyName, JSValue, unsigned attributes);
 616     bool putSetter(JSGlobalObject*, PropertyName, JSValue, unsigned attributes);
 617 
 618     JS_EXPORT_PRIVATE bool hasProperty(JSGlobalObject*, PropertyName) const;
 619     JS_EXPORT_PRIVATE bool hasProperty(JSGlobalObject*, unsigned propertyName) const;
 620     bool hasPropertyGeneric(JSGlobalObject*, PropertyName, PropertySlot::InternalMethodType) const;
 621     bool hasPropertyGeneric(JSGlobalObject*, unsigned propertyName, PropertySlot::InternalMethodType) const;
 622     bool hasOwnProperty(JSGlobalObject*, PropertyName, PropertySlot&amp;) const;
 623     bool hasOwnProperty(JSGlobalObject*, PropertyName) const;
 624     bool hasOwnProperty(JSGlobalObject*, unsigned) const;
 625 
 626     JS_EXPORT_PRIVATE static bool deleteProperty(JSCell*, JSGlobalObject*, PropertyName);
 627     JS_EXPORT_PRIVATE static bool deletePropertyByIndex(JSCell*, JSGlobalObject*, unsigned propertyName);
 628 
 629     JS_EXPORT_PRIVATE static JSValue defaultValue(const JSObject*, JSGlobalObject*, PreferredPrimitiveType);
 630     JSValue ordinaryToPrimitive(JSGlobalObject*, PreferredPrimitiveType) const;
 631 
 632     JS_EXPORT_PRIVATE bool hasInstance(JSGlobalObject*, JSValue value, JSValue hasInstanceValue);
 633     JS_EXPORT_PRIVATE bool hasInstance(JSGlobalObject*, JSValue);
 634     static bool defaultHasInstance(JSGlobalObject*, JSValue, JSValue prototypeProperty);
 635 
 636     JS_EXPORT_PRIVATE static void getOwnPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);
 637     JS_EXPORT_PRIVATE static void getOwnNonIndexPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);
 638     JS_EXPORT_PRIVATE static void getPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);
 639 
 640     JS_EXPORT_PRIVATE static uint32_t getEnumerableLength(JSGlobalObject*, JSObject*);
 641     JS_EXPORT_PRIVATE static void getStructurePropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);
 642     JS_EXPORT_PRIVATE static void getGenericPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);
 643 
 644     JS_EXPORT_PRIVATE JSValue toPrimitive(JSGlobalObject*, PreferredPrimitiveType = NoPreference) const;
 645     bool getPrimitiveNumber(JSGlobalObject*, double&amp; number, JSValue&amp;) const;
 646     JS_EXPORT_PRIVATE double toNumber(JSGlobalObject*) const;
 647     JS_EXPORT_PRIVATE JSString* toString(JSGlobalObject*) const;
 648 
 649     JS_EXPORT_PRIVATE static JSValue toThis(JSCell*, JSGlobalObject*, ECMAMode);
 650 
 651     // This get function only looks at the property map.
 652     JSValue getDirect(VM&amp; vm, PropertyName propertyName) const
 653     {
 654         Structure* structure = this-&gt;structure(vm);
 655         PropertyOffset offset = structure-&gt;get(vm, propertyName);
 656         checkOffset(offset, structure-&gt;inlineCapacity());
 657         return offset != invalidOffset ? getDirect(offset) : JSValue();
 658     }
 659 
 660     JSValue getDirect(VM&amp; vm, PropertyName propertyName, unsigned&amp; attributes) const
 661     {
 662         Structure* structure = this-&gt;structure(vm);
 663         PropertyOffset offset = structure-&gt;get(vm, propertyName, attributes);
 664         checkOffset(offset, structure-&gt;inlineCapacity());
 665         return offset != invalidOffset ? getDirect(offset) : JSValue();
 666     }
 667 
 668     PropertyOffset getDirectOffset(VM&amp; vm, PropertyName propertyName)
 669     {
 670         Structure* structure = this-&gt;structure(vm);
 671         PropertyOffset offset = structure-&gt;get(vm, propertyName);
 672         checkOffset(offset, structure-&gt;inlineCapacity());
 673         return offset;
 674     }
 675 
 676     PropertyOffset getDirectOffset(VM&amp; vm, PropertyName propertyName, unsigned&amp; attributes)
 677     {
 678         Structure* structure = this-&gt;structure(vm);
 679         PropertyOffset offset = structure-&gt;get(vm, propertyName, attributes);
 680         checkOffset(offset, structure-&gt;inlineCapacity());
 681         return offset;
 682     }
 683 
 684     bool hasInlineStorage() const { return structure()-&gt;hasInlineStorage(); }
 685     ConstPropertyStorage inlineStorageUnsafe() const
 686     {
 687         return bitwise_cast&lt;ConstPropertyStorage&gt;(this + 1);
 688     }
 689     PropertyStorage inlineStorageUnsafe()
 690     {
 691         return bitwise_cast&lt;PropertyStorage&gt;(this + 1);
 692     }
 693     ConstPropertyStorage inlineStorage() const
 694     {
 695         ASSERT(hasInlineStorage());
 696         return inlineStorageUnsafe();
 697     }
 698     PropertyStorage inlineStorage()
 699     {
 700         ASSERT(hasInlineStorage());
 701         return inlineStorageUnsafe();
 702     }
 703 
 704     const Butterfly* butterfly() const { return m_butterfly.get(); }
 705     Butterfly* butterfly() { return m_butterfly.get(); }
 706 
 707     ConstPropertyStorage outOfLineStorage() const { return m_butterfly-&gt;propertyStorage(); }
 708     PropertyStorage outOfLineStorage() { return m_butterfly-&gt;propertyStorage(); }
 709 
 710     ALWAYS_INLINE const WriteBarrierBase&lt;Unknown&gt;* locationForOffset(PropertyOffset offset) const
 711     {
 712         if (isInlineOffset(offset))
 713             return &amp;inlineStorage()[offsetInInlineStorage(offset)];
 714         return &amp;outOfLineStorage()[offsetInOutOfLineStorage(offset)];
 715     }
 716 
 717     ALWAYS_INLINE WriteBarrierBase&lt;Unknown&gt;* locationForOffset(PropertyOffset offset)
 718     {
 719         if (isInlineOffset(offset))
 720             return &amp;inlineStorage()[offsetInInlineStorage(offset)];
 721         return &amp;outOfLineStorage()[offsetInOutOfLineStorage(offset)];
 722     }
 723 
 724     void transitionTo(VM&amp;, Structure*);
 725 
 726     bool hasCustomProperties(VM&amp; vm) { return structure(vm)-&gt;didTransition(); }
 727     bool hasGetterSetterProperties(VM&amp; vm) { return structure(vm)-&gt;hasGetterSetterProperties(); }
 728     bool hasCustomGetterSetterProperties(VM&amp; vm) { return structure(vm)-&gt;hasCustomGetterSetterProperties(); }
 729 
 730     // putOwnDataProperty has &#39;put&#39; like semantics, however this method:
 731     //  - assumes the object contains no own getter/setter properties.
 732     //  - provides no special handling for __proto__
 733     //  - does not walk the prototype chain (to check for accessors or non-writable properties).
 734     // This is used by JSLexicalEnvironment.
 735     bool putOwnDataProperty(VM&amp;, PropertyName, JSValue, PutPropertySlot&amp;);
 736     bool putOwnDataPropertyMayBeIndex(JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);
 737 private:
 738     void validatePutOwnDataProperty(VM&amp;, PropertyName, JSValue);
 739 public:
 740 
 741     // Fast access to known property offsets.
 742     ALWAYS_INLINE JSValue getDirect(PropertyOffset offset) const { return locationForOffset(offset)-&gt;get(); }
 743     JSValue getDirectConcurrently(Structure* expectedStructure, PropertyOffset) const;
 744     void putDirect(VM&amp; vm, PropertyOffset offset, JSValue value) { locationForOffset(offset)-&gt;set(vm, this, value); }
 745     void putDirectWithoutBarrier(PropertyOffset offset, JSValue value) { locationForOffset(offset)-&gt;setWithoutWriteBarrier(value); }
 746     void putDirectUndefined(PropertyOffset offset) { locationForOffset(offset)-&gt;setUndefined(); }
 747 
 748     JS_EXPORT_PRIVATE bool putDirectNativeIntrinsicGetter(VM&amp;, JSGlobalObject*, Identifier, NativeFunction, Intrinsic, unsigned attributes);
 749     JS_EXPORT_PRIVATE void putDirectNativeIntrinsicGetterWithoutTransition(VM&amp;, JSGlobalObject*, Identifier, NativeFunction, Intrinsic, unsigned attributes);
 750     JS_EXPORT_PRIVATE bool putDirectNativeFunction(VM&amp;, JSGlobalObject*, const PropertyName&amp;, unsigned functionLength, NativeFunction, Intrinsic, unsigned attributes);
 751     JS_EXPORT_PRIVATE bool putDirectNativeFunction(VM&amp;, JSGlobalObject*, const PropertyName&amp;, unsigned functionLength, NativeFunction, Intrinsic, const DOMJIT::Signature*, unsigned attributes);
 752     JS_EXPORT_PRIVATE void putDirectNativeFunctionWithoutTransition(VM&amp;, JSGlobalObject*, const PropertyName&amp;, unsigned functionLength, NativeFunction, Intrinsic, unsigned attributes);
 753 
 754     JS_EXPORT_PRIVATE JSFunction* putDirectBuiltinFunction(VM&amp;, JSGlobalObject*, const PropertyName&amp;, FunctionExecutable*, unsigned attributes);
 755     JSFunction* putDirectBuiltinFunctionWithoutTransition(VM&amp;, JSGlobalObject*, const PropertyName&amp;, FunctionExecutable*, unsigned attributes);
 756 
 757     JS_EXPORT_PRIVATE static bool defineOwnProperty(JSObject*, JSGlobalObject*, PropertyName, const PropertyDescriptor&amp;, bool shouldThrow);
 758 
 759     bool isEnvironment() const;
 760     bool isGlobalObject() const;
 761     bool isJSLexicalEnvironment() const;
 762     bool isGlobalLexicalEnvironment() const;
 763     bool isStrictEvalActivation() const;
 764     bool isWithScope() const;
 765 
 766     bool isErrorInstance() const;
 767 
 768     JS_EXPORT_PRIVATE void seal(VM&amp;);
 769     JS_EXPORT_PRIVATE void freeze(VM&amp;);
 770     JS_EXPORT_PRIVATE static bool preventExtensions(JSObject*, JSGlobalObject*);
 771     JS_EXPORT_PRIVATE static bool isExtensible(JSObject*, JSGlobalObject*);
 772     bool isSealed(VM&amp; vm) { return structure(vm)-&gt;isSealed(vm); }
 773     bool isFrozen(VM&amp; vm) { return structure(vm)-&gt;isFrozen(vm); }
 774 
 775     JS_EXPORT_PRIVATE bool anyObjectInChainMayInterceptIndexedAccesses(VM&amp;) const;
 776     JS_EXPORT_PRIVATE bool prototypeChainMayInterceptStoreTo(VM&amp;, PropertyName);
 777     bool needsSlowPutIndexing(VM&amp;) const;
 778 
 779 private:
 780     NonPropertyTransition suggestedArrayStorageTransition(VM&amp;) const;
 781 public:
 782     // You should only call isStructureExtensible() when:
 783     // - Performing this check in a way that isn&#39;t described in the specification
 784     //   as calling the virtual [[IsExtensible]] trap.
 785     // - When you&#39;re guaranteed that object-&gt;methodTable(vm)-&gt;isExtensible isn&#39;t
 786     //   overridden.
 787     ALWAYS_INLINE bool isStructureExtensible(VM&amp; vm) { return structure(vm)-&gt;isStructureExtensible(); }
 788     // You should call this when performing [[IsExtensible]] trap in a place
 789     // that is described in the specification. This performs the fully virtual
 790     // [[IsExtensible]] trap.
 791     bool isExtensible(JSGlobalObject*);
 792     bool indexingShouldBeSparse(VM&amp; vm)
 793     {
 794         return !isStructureExtensible(vm)
 795             || structure(vm)-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero();
 796     }
 797 
 798     bool staticPropertiesReified(VM&amp; vm) { return structure(vm)-&gt;staticPropertiesReified(); }
 799     void reifyAllStaticProperties(JSGlobalObject*);
 800 
 801     JS_EXPORT_PRIVATE Butterfly* allocateMoreOutOfLineStorage(VM&amp;, size_t oldSize, size_t newSize);
 802 
 803     // Call this when you do not need to change the structure.
 804     void setButterfly(VM&amp;, Butterfly*);
 805 
 806     // Call this if you do need to change the structure, or if you changed something about a structure
 807     // in-place.
 808     void nukeStructureAndSetButterfly(VM&amp;, StructureID oldStructureID, Butterfly*);
 809 
 810     void setStructure(VM&amp;, Structure*);
 811 
 812     JS_EXPORT_PRIVATE void convertToDictionary(VM&amp;);
 813 
 814     void flattenDictionaryObject(VM&amp; vm)
 815     {
 816         structure(vm)-&gt;flattenDictionaryStructure(vm, this);
 817     }
 818     void shiftButterflyAfterFlattening(const GCSafeConcurrentJSLocker&amp;, VM&amp;, Structure* structure, size_t outOfLineCapacityAfter);
 819 
 820     JSGlobalObject* globalObject() const
 821     {
 822         ASSERT(structure()-&gt;globalObject());
 823         ASSERT(!isGlobalObject() || ((JSObject*)structure()-&gt;globalObject()) == this);
 824         return structure()-&gt;globalObject();
 825     }
 826 
 827     JSGlobalObject* globalObject(VM&amp; vm) const
 828     {
 829         ASSERT(structure(vm)-&gt;globalObject());
 830         ASSERT(!isGlobalObject() || ((JSObject*)structure(vm)-&gt;globalObject()) == this);
 831         return structure(vm)-&gt;globalObject();
 832     }
 833 
 834     void switchToSlowPutArrayStorage(VM&amp;);
 835 
 836     // The receiver is the prototype in this case. The following:
 837     //
 838     // asObject(foo-&gt;structure()-&gt;storedPrototype())-&gt;attemptToInterceptPutByIndexOnHoleForPrototype(...)
 839     //
 840     // is equivalent to:
 841     //
 842     // foo-&gt;attemptToInterceptPutByIndexOnHole(...);
 843     bool attemptToInterceptPutByIndexOnHoleForPrototype(JSGlobalObject*, JSValue thisValue, unsigned propertyName, JSValue, bool shouldThrow, bool&amp; putResult);
 844 
 845     // Returns 0 if int32 storage cannot be created - either because
 846     // indexing should be sparse, we&#39;re having a bad time, or because
 847     // we already have a more general form of storage (double,
 848     // contiguous, array storage).
 849     ContiguousJSValues tryMakeWritableInt32(VM&amp; vm)
 850     {
 851         if (LIKELY(hasInt32(indexingType()) &amp;&amp; !isCopyOnWrite(indexingMode())))
 852             return m_butterfly-&gt;contiguousInt32();
 853 
 854         return tryMakeWritableInt32Slow(vm);
 855     }
 856 
 857     // Returns 0 if double storage cannot be created - either because
 858     // indexing should be sparse, we&#39;re having a bad time, or because
 859     // we already have a more general form of storage (contiguous,
 860     // or array storage).
 861     ContiguousDoubles tryMakeWritableDouble(VM&amp; vm)
 862     {
 863         if (LIKELY(hasDouble(indexingType()) &amp;&amp; !isCopyOnWrite(indexingMode())))
 864             return m_butterfly-&gt;contiguousDouble();
 865 
 866         return tryMakeWritableDoubleSlow(vm);
 867     }
 868 
 869     // Returns 0 if contiguous storage cannot be created - either because
 870     // indexing should be sparse or because we&#39;re having a bad time.
 871     ContiguousJSValues tryMakeWritableContiguous(VM&amp; vm)
 872     {
 873         if (LIKELY(hasContiguous(indexingType()) &amp;&amp; !isCopyOnWrite(indexingMode())))
 874             return m_butterfly-&gt;contiguous();
 875 
 876         return tryMakeWritableContiguousSlow(vm);
 877     }
 878 
 879     // Ensure that the object is in a mode where it has array storage. Use
 880     // this if you&#39;re about to perform actions that would have required the
 881     // object to be converted to have array storage, if it didn&#39;t have it
 882     // already.
 883     ArrayStorage* ensureArrayStorage(VM&amp; vm)
 884     {
 885         if (LIKELY(hasAnyArrayStorage(indexingType())))
 886             return m_butterfly-&gt;arrayStorage();
 887 
 888         return ensureArrayStorageSlow(vm);
 889     }
 890 
 891     void ensureWritable(VM&amp; vm)
 892     {
 893         if (isCopyOnWrite(indexingMode()))
 894             convertFromCopyOnWrite(vm);
 895     }
 896 
 897     static size_t offsetOfInlineStorage();
 898 
 899     static ptrdiff_t butterflyOffset()
 900     {
 901         return OBJECT_OFFSETOF(JSObject, m_butterfly);
 902     }
 903     void* butterflyAddress()
 904     {
 905         return &amp;m_butterfly;
 906     }
 907 
 908     JS_EXPORT_PRIVATE JSValue getMethod(JSGlobalObject*, CallData&amp;, CallType&amp;, const Identifier&amp;, const String&amp; errorMessage);
 909 
 910     bool canPerformFastPutInline(VM&amp;, PropertyName);
 911     bool canPerformFastPutInlineExcludingProto(VM&amp;);
 912 
 913     bool mayBePrototype() const;
 914     void didBecomePrototype();
 915 
 916     Optional&lt;Structure::PropertyHashEntry&gt; findPropertyHashEntry(VM&amp;, PropertyName) const;
 917 
 918     DECLARE_EXPORT_INFO;
 919 
 920 protected:
 921     void finishCreation(VM&amp; vm)
 922     {
 923         Base::finishCreation(vm);
 924         ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, this));
 925         ASSERT(structure(vm)-&gt;hasPolyProto() || getPrototypeDirect(vm).isNull() || Heap::heap(this) == Heap::heap(getPrototypeDirect(vm)));
 926         ASSERT(structure(vm)-&gt;isObject());
 927         ASSERT(classInfo(vm));
 928     }
 929 
 930     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 931     {
 932         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 933     }
 934 
 935     // To instantiate objects you likely want JSFinalObject, below.
 936     // To create derived types you likely want JSNonFinalObject, below.
 937     JSObject(VM&amp;, Structure*, Butterfly* = nullptr);
 938 
 939     // Visits the butterfly unless there is a race. Returns the structure if there was no race.
 940     Structure* visitButterfly(SlotVisitor&amp;);
 941 
 942     Structure* visitButterflyImpl(SlotVisitor&amp;);
 943 
 944     void markAuxiliaryAndVisitOutOfLineProperties(SlotVisitor&amp;, Butterfly*, Structure*, PropertyOffset maxOffset);
 945 
 946     // Call this if you know that the object is in a mode where it has array
 947     // storage. This will assert otherwise.
 948     ArrayStorage* arrayStorage()
 949     {
 950         ASSERT(hasAnyArrayStorage(indexingType()));
 951         return m_butterfly-&gt;arrayStorage();
 952     }
 953 
 954     // Call this if you want to predicate some actions on whether or not the
 955     // object is in a mode where it has array storage.
 956     ArrayStorage* arrayStorageOrNull()
 957     {
 958         switch (indexingType()) {
 959         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 960             return m_butterfly-&gt;arrayStorage();
 961 
 962         default:
 963             return 0;
 964         }
 965     }
 966 
 967     size_t butterflyTotalSize();
 968     size_t butterflyPreCapacity();
 969 
 970     Butterfly* createInitialUndecided(VM&amp;, unsigned length);
 971     ContiguousJSValues createInitialInt32(VM&amp;, unsigned length);
 972     ContiguousDoubles createInitialDouble(VM&amp;, unsigned length);
 973     ContiguousJSValues createInitialContiguous(VM&amp;, unsigned length);
 974 
 975     void convertUndecidedForValue(VM&amp;, JSValue);
 976     void createInitialForValueAndSet(VM&amp;, unsigned index, JSValue);
 977     void convertInt32ForValue(VM&amp;, JSValue);
 978     void convertDoubleForValue(VM&amp;, JSValue);
 979     void convertFromCopyOnWrite(VM&amp;);
 980 
 981     static Butterfly* createArrayStorageButterfly(VM&amp;, JSObject* intendedOwner, Structure*, unsigned length, unsigned vectorLength, Butterfly* oldButterfly = nullptr);
 982     ArrayStorage* createArrayStorage(VM&amp;, unsigned length, unsigned vectorLength);
 983     ArrayStorage* createInitialArrayStorage(VM&amp;);
 984 
 985     ContiguousJSValues convertUndecidedToInt32(VM&amp;);
 986     ContiguousDoubles convertUndecidedToDouble(VM&amp;);
 987     ContiguousJSValues convertUndecidedToContiguous(VM&amp;);
 988     ArrayStorage* convertUndecidedToArrayStorage(VM&amp;, NonPropertyTransition);
 989     ArrayStorage* convertUndecidedToArrayStorage(VM&amp;);
 990 
 991     ContiguousDoubles convertInt32ToDouble(VM&amp;);
 992     ContiguousJSValues convertInt32ToContiguous(VM&amp;);
 993     ArrayStorage* convertInt32ToArrayStorage(VM&amp;, NonPropertyTransition);
 994     ArrayStorage* convertInt32ToArrayStorage(VM&amp;);
 995 
 996     ContiguousJSValues convertDoubleToContiguous(VM&amp;);
 997     ArrayStorage* convertDoubleToArrayStorage(VM&amp;, NonPropertyTransition);
 998     ArrayStorage* convertDoubleToArrayStorage(VM&amp;);
 999 
1000     ArrayStorage* convertContiguousToArrayStorage(VM&amp;, NonPropertyTransition);
1001     ArrayStorage* convertContiguousToArrayStorage(VM&amp;);
1002 
1003 
1004     ArrayStorage* ensureArrayStorageExistsAndEnterDictionaryIndexingMode(VM&amp;);
1005 
1006     bool defineOwnNonIndexProperty(JSGlobalObject*, PropertyName, const PropertyDescriptor&amp;, bool throwException);
1007 
1008     template&lt;IndexingType indexingShape&gt;
1009     bool putByIndexBeyondVectorLengthWithoutAttributes(JSGlobalObject*, unsigned propertyName, JSValue);
1010     bool putByIndexBeyondVectorLengthWithArrayStorage(JSGlobalObject*, unsigned propertyName, JSValue, bool shouldThrow, ArrayStorage*);
1011 
1012     bool increaseVectorLength(VM&amp;, unsigned newLength);
1013     void deallocateSparseIndexMap();
1014     bool defineOwnIndexedProperty(JSGlobalObject*, unsigned, const PropertyDescriptor&amp;, bool throwException);
1015     SparseArrayValueMap* allocateSparseIndexMap(VM&amp;);
1016 
1017     void notifyPresenceOfIndexedAccessors(VM&amp;);
1018 
1019     bool attemptToInterceptPutByIndexOnHole(JSGlobalObject*, unsigned index, JSValue, bool shouldThrow, bool&amp; putResult);
1020 
1021     // Call this if you want setIndexQuickly to succeed and you&#39;re sure that
1022     // the array is contiguous.
1023     bool WARN_UNUSED_RETURN ensureLength(VM&amp; vm, unsigned length)
1024     {
1025         RELEASE_ASSERT(length &lt;= MAX_STORAGE_VECTOR_LENGTH);
1026         ASSERT(hasContiguous(indexingType()) || hasInt32(indexingType()) || hasDouble(indexingType()) || hasUndecided(indexingType()));
1027 
1028         if (m_butterfly-&gt;vectorLength() &lt; length || isCopyOnWrite(indexingMode())) {
1029             if (!ensureLengthSlow(vm, length))
1030                 return false;
1031         }
1032 
1033         if (m_butterfly-&gt;publicLength() &lt; length)
1034             m_butterfly-&gt;setPublicLength(length);
1035         return true;
1036     }
1037 
1038     // Call this if you want to shrink the butterfly backing store, and you&#39;re
1039     // sure that the array is contiguous.
1040     void reallocateAndShrinkButterfly(VM&amp;, unsigned length);
1041 
1042     template&lt;IndexingType indexingShape&gt;
1043     unsigned countElements(Butterfly*);
1044 
1045     // This is relevant to undecided, int32, double, and contiguous.
1046     unsigned countElements();
1047 
1048 private:
1049     friend class LLIntOffsetsExtractor;
1050     friend class VMInspector;
1051 
1052     // Nobody should ever ask any of these questions on something already known to be a JSObject.
1053     using JSCell::isAPIValueWrapper;
1054     using JSCell::isGetterSetter;
1055     void getObject();
1056     void getString(JSGlobalObject* globalObject);
1057     void isObject();
1058     void isString();
1059 
1060     Butterfly* createInitialIndexedStorage(VM&amp;, unsigned length);
1061 
1062     ArrayStorage* enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(VM&amp;, ArrayStorage*);
1063 
1064     template&lt;PutMode&gt;
1065     bool putDirectInternal(VM&amp;, PropertyName, JSValue, unsigned attr, PutPropertySlot&amp;);
1066 
1067     JS_EXPORT_PRIVATE NEVER_INLINE bool putInlineSlow(JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);
1068 
1069     bool getNonIndexPropertySlot(JSGlobalObject*, PropertyName, PropertySlot&amp;);
1070     bool getOwnNonIndexPropertySlot(VM&amp;, Structure*, PropertyName, PropertySlot&amp;);
1071     JS_EXPORT_PRIVATE void fillGetterPropertySlot(VM&amp;, PropertySlot&amp;, JSCell*, unsigned, PropertyOffset);
1072     void fillCustomGetterPropertySlot(VM&amp;, PropertySlot&amp;, CustomGetterSetter*, unsigned, Structure*);
1073 
1074     JS_EXPORT_PRIVATE bool getOwnStaticPropertySlot(VM&amp;, PropertyName, PropertySlot&amp;);
1075 
1076     bool putByIndexBeyondVectorLength(JSGlobalObject*, unsigned propertyName, JSValue, bool shouldThrow);
1077     bool putDirectIndexBeyondVectorLengthWithArrayStorage(JSGlobalObject*, unsigned propertyName, JSValue, unsigned attributes, PutDirectIndexMode, ArrayStorage*);
1078     JS_EXPORT_PRIVATE bool putDirectIndexSlowOrBeyondVectorLength(JSGlobalObject*, unsigned propertyName, JSValue, unsigned attributes, PutDirectIndexMode);
1079 
1080     unsigned getNewVectorLength(VM&amp;, unsigned indexBias, unsigned currentVectorLength, unsigned currentLength, unsigned desiredLength);
1081     unsigned getNewVectorLength(VM&amp;, unsigned desiredLength);
1082 
1083     ArrayStorage* constructConvertedArrayStorageWithoutCopyingElements(VM&amp;, unsigned neededLength);
1084 
1085     JS_EXPORT_PRIVATE void setIndexQuicklyToUndecided(VM&amp;, unsigned index, JSValue);
1086     JS_EXPORT_PRIVATE void convertInt32ToDoubleOrContiguousWhilePerformingSetIndex(VM&amp;, unsigned index, JSValue);
1087     JS_EXPORT_PRIVATE void convertDoubleToContiguousWhilePerformingSetIndex(VM&amp;, unsigned index, JSValue);
1088 
1089     bool ensureLengthSlow(VM&amp;, unsigned length);
1090 
1091     ContiguousJSValues tryMakeWritableInt32Slow(VM&amp;);
1092     ContiguousDoubles tryMakeWritableDoubleSlow(VM&amp;);
1093     ContiguousJSValues tryMakeWritableContiguousSlow(VM&amp;);
1094     JS_EXPORT_PRIVATE ArrayStorage* ensureArrayStorageSlow(VM&amp;);
1095 
1096     PropertyOffset prepareToPutDirectWithoutTransition(VM&amp;, PropertyName, unsigned attributes, StructureID, Structure*);
1097 
1098     AuxiliaryBarrier&lt;Butterfly*&gt; m_butterfly;
1099 #if CPU(ADDRESS32)
1100     unsigned m_32BitPadding;
1101 #endif
1102 };
1103 
1104 // JSNonFinalObject is a type of JSObject that has some internal storage,
1105 // but also preserves some space in the collector cell for additional
1106 // data members in derived types.
1107 class JSNonFinalObject : public JSObject {
1108     friend class JSObject;
1109 
1110 public:
1111     typedef JSObject Base;
1112 
1113     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
1114     {
1115         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
1116     }
1117 
1118 protected:
1119     explicit JSNonFinalObject(VM&amp; vm, Structure* structure, Butterfly* butterfly = 0)
1120         : JSObject(vm, structure, butterfly)
1121     {
1122     }
1123 
1124     void finishCreation(VM&amp; vm)
1125     {
1126         Base::finishCreation(vm);
1127         ASSERT(!this-&gt;structure(vm)-&gt;hasInlineStorage());
1128         ASSERT(classInfo(vm));
1129     }
1130 };
1131 
1132 class JSFinalObject;
1133 
1134 // JSFinalObject is a type of JSObject that contains sufficient internal
1135 // storage to fully make use of the collector cell containing it.
1136 class JSFinalObject final : public JSObject {
1137     friend class JSObject;
1138 
1139 public:
1140     typedef JSObject Base;
1141     static constexpr unsigned StructureFlags = Base::StructureFlags;
1142 
1143     static size_t allocationSize(Checked&lt;size_t&gt; inlineCapacity)
1144     {
1145         return (sizeof(JSObject) + inlineCapacity * sizeof(WriteBarrierBase&lt;Unknown&gt;)).unsafeGet();
1146     }
1147 
1148     static inline const TypeInfo typeInfo() { return TypeInfo(FinalObjectType, StructureFlags); }
1149     static constexpr IndexingType defaultIndexingType = NonArray;
1150 
1151     static constexpr unsigned defaultSize = 64;
1152     static inline unsigned defaultInlineCapacity()
1153     {
1154         return (defaultSize - allocationSize(0)) / sizeof(WriteBarrier&lt;Unknown&gt;);
1155     }
1156 
1157     static constexpr unsigned maxSize = 512;
1158     static inline unsigned maxInlineCapacity()
1159     {
1160         return (maxSize - allocationSize(0)) / sizeof(WriteBarrier&lt;Unknown&gt;);
1161     }
1162 
1163     static JSFinalObject* create(VM&amp;, Structure*, Butterfly* = nullptr);
1164     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype, unsigned inlineCapacity)
1165     {
1166         return Structure::create(vm, globalObject, prototype, typeInfo(), info(), defaultIndexingType, inlineCapacity);
1167     }
1168 
1169     JS_EXPORT_PRIVATE static void visitChildren(JSCell*, SlotVisitor&amp;);
1170 
1171     DECLARE_EXPORT_INFO;
1172 
1173 protected:
1174     void visitChildrenCommon(SlotVisitor&amp;);
1175 
1176     void finishCreation(VM&amp; vm)
1177     {
1178         Base::finishCreation(vm);
1179         ASSERT(structure(vm)-&gt;totalStorageCapacity() == structure(vm)-&gt;inlineCapacity());
1180         ASSERT(classInfo(vm));
1181     }
1182 
1183 private:
1184     friend class LLIntOffsetsExtractor;
1185 
1186     explicit JSFinalObject(VM&amp; vm, Structure* structure, Butterfly* butterfly = nullptr)
1187         : JSObject(vm, structure, butterfly)
1188     {
1189         gcSafeZeroMemory(inlineStorageUnsafe(), structure-&gt;inlineCapacity() * sizeof(EncodedJSValue));
1190     }
1191 };
1192 
1193 JS_EXPORT_PRIVATE EncodedJSValue JSC_HOST_CALL objectPrivateFuncInstanceOf(JSGlobalObject*, CallFrame*);
1194 
1195 inline JSObject* JSObject::createRawObject(VM&amp; vm, Structure* structure, Butterfly* butterfly)
1196 {
1197     JSObject* finalObject = new (
1198         NotNull,
1199         allocateCell&lt;JSFinalObject&gt;(
1200             vm.heap,
1201             JSFinalObject::allocationSize(structure-&gt;inlineCapacity())
1202         )
1203     ) JSObject(vm, structure, butterfly);
1204     finalObject-&gt;finishCreation(vm);
1205     return finalObject;
1206 }
1207 
1208 inline JSFinalObject* JSFinalObject::create(VM&amp; vm, Structure* structure, Butterfly* butterfly)
1209 {
1210     JSFinalObject* finalObject = new (
1211         NotNull,
1212         allocateCell&lt;JSFinalObject&gt;(
1213             vm.heap,
1214             allocationSize(structure-&gt;inlineCapacity())
1215         )
1216     ) JSFinalObject(vm, structure, butterfly);
1217     finalObject-&gt;finishCreation(vm);
1218     return finalObject;
1219 }
1220 
1221 inline size_t JSObject::offsetOfInlineStorage()
1222 {
1223     return sizeof(JSObject);
1224 }
1225 
1226 inline bool JSObject::isGlobalObject() const
1227 {
1228     return type() == GlobalObjectType;
1229 }
1230 
1231 inline bool JSObject::isJSLexicalEnvironment() const
1232 {
1233     return type() == LexicalEnvironmentType || type() == ModuleEnvironmentType;
1234 }
1235 
1236 inline bool JSObject::isGlobalLexicalEnvironment() const
1237 {
1238     return type() == GlobalLexicalEnvironmentType;
1239 }
1240 
1241 inline bool JSObject::isStrictEvalActivation() const
1242 {
1243     return type() == StrictEvalActivationType;
1244 }
1245 
1246 inline bool JSObject::isEnvironment() const
1247 {
1248     bool result = GlobalObjectType &lt;= type() &amp;&amp; type() &lt;= StrictEvalActivationType;
1249     ASSERT((isGlobalObject() || isJSLexicalEnvironment() || isGlobalLexicalEnvironment() || isStrictEvalActivation()) == result);
1250     return result;
1251 }
1252 
1253 inline bool JSObject::isErrorInstance() const
1254 {
1255     return type() == ErrorInstanceType;
1256 }
1257 
1258 inline bool JSObject::isWithScope() const
1259 {
1260     return type() == WithScopeType;
1261 }
1262 
1263 inline void JSObject::setStructure(VM&amp; vm, Structure* structure)
1264 {
1265     ASSERT(structure);
1266     ASSERT(!m_butterfly == !(structure-&gt;outOfLineCapacity() || structure-&gt;hasIndexingHeader(this)));
1267     JSCell::setStructure(vm, structure);
1268 }
1269 
1270 inline void JSObject::setButterfly(VM&amp; vm, Butterfly* butterfly)
1271 {
1272     if (isX86() || vm.heap.mutatorShouldBeFenced()) {
1273         WTF::storeStoreFence();
1274         m_butterfly.set(vm, this, butterfly);
1275         WTF::storeStoreFence();
1276         return;
1277     }
1278 
1279     m_butterfly.set(vm, this, butterfly);
1280 }
1281 
1282 inline void JSObject::nukeStructureAndSetButterfly(VM&amp; vm, StructureID oldStructureID, Butterfly* butterfly)
1283 {
1284     if (isX86() || vm.heap.mutatorShouldBeFenced()) {
1285         setStructureIDDirectly(nuke(oldStructureID));
1286         WTF::storeStoreFence();
1287         m_butterfly.set(vm, this, butterfly);
1288         WTF::storeStoreFence();
1289         return;
1290     }
1291 
1292     m_butterfly.set(vm, this, butterfly);
1293 }
1294 
1295 inline JSObject* asObject(JSCell* cell)
1296 {
1297     ASSERT(cell-&gt;isObject());
1298     return jsCast&lt;JSObject*&gt;(cell);
1299 }
1300 
1301 inline JSObject* asObject(JSValue value)
1302 {
1303     return asObject(value.asCell());
1304 }
1305 
1306 inline JSObject::JSObject(VM&amp; vm, Structure* structure, Butterfly* butterfly)
1307     : JSCell(vm, structure)
1308     , m_butterfly(vm, this, butterfly)
1309 {
1310 }
1311 
1312 inline JSValue JSObject::getPrototypeDirect(VM&amp; vm) const
1313 {
1314     return structure(vm)-&gt;storedPrototype(this);
1315 }
1316 
1317 inline JSValue JSObject::getPrototype(VM&amp; vm, JSGlobalObject* globalObject)
1318 {
1319     auto getPrototypeMethod = methodTable(vm)-&gt;getPrototype;
1320     MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
1321     if (LIKELY(getPrototypeMethod == defaultGetPrototype))
1322         return getPrototypeDirect(vm);
1323     return getPrototypeMethod(this, globalObject);
1324 }
1325 
1326 // Normally, we never shrink the butterfly so if we know an offset is valid for some
1327 // past structure then it should be valid for any new structure. However, we may sometimes
1328 // shrink the butterfly when we are holding the Structure&#39;s ConcurrentJSLock, such as when we
1329 // flatten an object.
1330 inline JSValue JSObject::getDirectConcurrently(Structure* structure, PropertyOffset offset) const
1331 {
1332     ConcurrentJSLocker locker(structure-&gt;lock());
1333     if (!structure-&gt;isValidOffset(offset))
1334         return { };
1335     return getDirect(offset);
1336 }
1337 
1338 // It is safe to call this method with a PropertyName that is actually an index,
1339 // but if so will always return false (doesn&#39;t search index storage).
1340 ALWAYS_INLINE bool JSObject::getOwnNonIndexPropertySlot(VM&amp; vm, Structure* structure, PropertyName propertyName, PropertySlot&amp; slot)
1341 {
1342     unsigned attributes;
1343     PropertyOffset offset = structure-&gt;get(vm, propertyName, attributes);
1344     if (!isValidOffset(offset)) {
1345         if (!TypeInfo::hasStaticPropertyTable(inlineTypeFlags()))
1346             return false;
1347         return getOwnStaticPropertySlot(vm, propertyName, slot);
1348     }
1349 
1350     // getPropertySlot relies on this method never returning index properties!
1351     ASSERT(!parseIndex(propertyName));
1352 
1353     JSValue value = getDirect(offset);
1354     if (value.isCell()) {
1355         ASSERT(value);
1356         JSCell* cell = value.asCell();
1357         JSType type = cell-&gt;type();
1358         switch (type) {
1359         case GetterSetterType:
1360             fillGetterPropertySlot(vm, slot, cell, attributes, offset);
1361             return true;
1362         case CustomGetterSetterType:
1363             fillCustomGetterPropertySlot(vm, slot, jsCast&lt;CustomGetterSetter*&gt;(cell), attributes, structure);
1364             return true;
1365         default:
1366             break;
1367         }
1368     }
1369 
1370     slot.setValue(this, attributes, value, offset);
1371     return true;
1372 }
1373 
1374 ALWAYS_INLINE void JSObject::fillCustomGetterPropertySlot(VM&amp; vm, PropertySlot&amp; slot, CustomGetterSetter* customGetterSetter, unsigned attributes, Structure* structure)
1375 {
1376     ASSERT(attributes &amp; PropertyAttribute::CustomAccessorOrValue);
1377     if (customGetterSetter-&gt;inherits&lt;DOMAttributeGetterSetter&gt;(vm)) {
1378         auto* domAttribute = jsCast&lt;DOMAttributeGetterSetter*&gt;(customGetterSetter);
1379         if (structure-&gt;isUncacheableDictionary())
1380             slot.setCustom(this, attributes, domAttribute-&gt;getter(), domAttribute-&gt;domAttribute());
1381         else
1382             slot.setCacheableCustom(this, attributes, domAttribute-&gt;getter(), domAttribute-&gt;domAttribute());
1383         return;
1384     }
1385 
1386     if (structure-&gt;isUncacheableDictionary())
1387         slot.setCustom(this, attributes, customGetterSetter-&gt;getter());
1388     else
1389         slot.setCacheableCustom(this, attributes, customGetterSetter-&gt;getter());
1390 }
1391 
1392 // It may seem crazy to inline a function this large, especially a virtual function,
1393 // but it makes a big difference to property lookup that derived classes can inline their
1394 // base class call to this.
1395 ALWAYS_INLINE bool JSObject::getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)
1396 {
1397     VM&amp; vm = getVM(globalObject);
1398     Structure* structure = object-&gt;structure(vm);
1399     if (object-&gt;getOwnNonIndexPropertySlot(vm, structure, propertyName, slot))
1400         return true;
1401     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
1402         return getOwnPropertySlotByIndex(object, globalObject, index.value(), slot);
1403     return false;
1404 }
1405 
1406 ALWAYS_INLINE void JSObject::doPutPropertySecurityCheck(JSObject*, JSGlobalObject*, PropertyName, PutPropertySlot&amp;)
1407 {
1408 }
1409 
1410 // It may seem crazy to inline a function this large but it makes a big difference
1411 // since this is function very hot in variable lookup
1412 template&lt;bool checkNullStructure&gt;
1413 ALWAYS_INLINE bool JSObject::getPropertySlot(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)
1414 {
1415     VM&amp; vm = getVM(globalObject);
1416     auto&amp; structureIDTable = vm.heap.structureIDTable();
1417     JSObject* object = this;
1418     while (true) {
1419         if (UNLIKELY(TypeInfo::overridesGetOwnPropertySlot(object-&gt;inlineTypeFlags()))) {
1420             // If propertyName is an index then we may have missed it (as this loop is using
1421             // getOwnNonIndexPropertySlot), so we cannot safely call the overridden getOwnPropertySlot
1422             // (lest we return a property from a prototype that is shadowed). Check now for an index,
1423             // if so we need to start afresh from this object.
1424             if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
1425                 return getPropertySlot(globalObject, index.value(), slot);
1426             // Safe to continue searching from current position; call getNonIndexPropertySlot to avoid
1427             // parsing the int again.
1428             return object-&gt;getNonIndexPropertySlot(globalObject, propertyName, slot);
1429         }
1430         ASSERT(object-&gt;type() != ProxyObjectType);
1431         Structure* structure = structureIDTable.get(object-&gt;structureID());
1432 #if USE(JSVALUE64)
1433         if (checkNullStructure &amp;&amp; UNLIKELY(!structure))
1434             CRASH_WITH_INFO(object-&gt;type(), object-&gt;structureID(), structureIDTable.size());
1435 #endif
1436         if (object-&gt;getOwnNonIndexPropertySlot(vm, structure, propertyName, slot))
1437             return true;
1438         // FIXME: This doesn&#39;t look like it&#39;s following the specification:
1439         // https://bugs.webkit.org/show_bug.cgi?id=172572
1440         JSValue prototype = structure-&gt;storedPrototype(object);
1441         if (!prototype.isObject())
1442             break;
1443         object = asObject(prototype);
1444     }
1445 
1446     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
1447         return getPropertySlot(globalObject, index.value(), slot);
1448     return false;
1449 }
1450 
1451 inline JSValue JSObject::get(JSGlobalObject* globalObject, PropertyName propertyName) const
1452 {
1453     VM&amp; vm = getVM(globalObject);
1454     auto scope = DECLARE_THROW_SCOPE(vm);
1455     PropertySlot slot(this, PropertySlot::InternalMethodType::Get);
1456     bool hasProperty = const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(globalObject, propertyName, slot);
1457     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
1458     if (hasProperty)
1459         RELEASE_AND_RETURN(scope, slot.getValue(globalObject, propertyName));
1460 
1461     return jsUndefined();
1462 }
1463 
1464 inline JSValue JSObject::get(JSGlobalObject* globalObject, unsigned propertyName) const
1465 {
1466     VM&amp; vm = getVM(globalObject);
1467     auto scope = DECLARE_THROW_SCOPE(vm);
1468     PropertySlot slot(this, PropertySlot::InternalMethodType::Get);
1469     bool hasProperty = const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(globalObject, propertyName, slot);
1470     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
1471     if (hasProperty)
1472         RELEASE_AND_RETURN(scope, slot.getValue(globalObject, propertyName));
1473 
1474     return jsUndefined();
1475 }
1476 
1477 inline bool JSObject::putDirect(VM&amp; vm, PropertyName propertyName, JSValue value, unsigned attributes)
1478 {
1479     ASSERT(!value.isGetterSetter() &amp;&amp; !(attributes &amp; PropertyAttribute::Accessor));
1480     ASSERT(!value.isCustomGetterSetter() &amp;&amp; !(attributes &amp; PropertyAttribute::CustomAccessorOrValue));
1481     PutPropertySlot slot(this);
1482     return putDirectInternal&lt;PutModeDefineOwnProperty&gt;(vm, propertyName, value, attributes, slot);
1483 }
1484 
1485 inline bool JSObject::putDirect(VM&amp; vm, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
1486 {
1487     ASSERT(!value.isGetterSetter());
1488     ASSERT(!value.isCustomGetterSetter());
1489     return putDirectInternal&lt;PutModeDefineOwnProperty&gt;(vm, propertyName, value, 0, slot);
1490 }
1491 
1492 inline size_t offsetInButterfly(PropertyOffset offset)
1493 {
1494     return offsetInOutOfLineStorage(offset) + Butterfly::indexOfPropertyStorage();
1495 }
1496 
1497 inline size_t JSObject::butterflyPreCapacity()
1498 {
1499     VM&amp; vm = this-&gt;vm();
1500     if (UNLIKELY(hasIndexingHeader(vm)))
1501         return butterfly()-&gt;indexingHeader()-&gt;preCapacity(structure(vm));
1502     return 0;
1503 }
1504 
1505 inline size_t JSObject::butterflyTotalSize()
1506 {
1507     VM&amp; vm = this-&gt;vm();
1508     Structure* structure = this-&gt;structure(vm);
1509     Butterfly* butterfly = this-&gt;butterfly();
1510     size_t preCapacity;
1511     size_t indexingPayloadSizeInBytes;
1512     bool hasIndexingHeader = this-&gt;hasIndexingHeader(vm);
1513 
1514     if (UNLIKELY(hasIndexingHeader)) {
1515         preCapacity = butterfly-&gt;indexingHeader()-&gt;preCapacity(structure);
1516         indexingPayloadSizeInBytes = butterfly-&gt;indexingHeader()-&gt;indexingPayloadSizeInBytes(structure);
1517     } else {
1518         preCapacity = 0;
1519         indexingPayloadSizeInBytes = 0;
1520     }
1521 
1522     return Butterfly::totalSize(preCapacity, structure-&gt;outOfLineCapacity(), hasIndexingHeader, indexingPayloadSizeInBytes);
1523 }
1524 
1525 inline int indexRelativeToBase(PropertyOffset offset)
1526 {
1527     if (isOutOfLineOffset(offset))
1528         return offsetInOutOfLineStorage(offset) + Butterfly::indexOfPropertyStorage();
1529     ASSERT(!(JSObject::offsetOfInlineStorage() % sizeof(EncodedJSValue)));
1530     return JSObject::offsetOfInlineStorage() / sizeof(EncodedJSValue) + offsetInInlineStorage(offset);
1531 }
1532 
1533 inline int offsetRelativeToBase(PropertyOffset offset)
1534 {
1535     if (isOutOfLineOffset(offset))
1536         return offsetInOutOfLineStorage(offset) * sizeof(EncodedJSValue) + Butterfly::offsetOfPropertyStorage();
1537     return JSObject::offsetOfInlineStorage() + offsetInInlineStorage(offset) * sizeof(EncodedJSValue);
1538 }
1539 
1540 // Returns the maximum offset (away from zero) a load instruction will encode.
1541 inline size_t maxOffsetRelativeToBase(PropertyOffset offset)
1542 {
1543     ptrdiff_t addressOffset = offsetRelativeToBase(offset);
1544 #if USE(JSVALUE32_64)
1545     if (addressOffset &gt;= 0)
1546         return static_cast&lt;size_t&gt;(addressOffset) + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.tag);
1547 #endif
1548     return static_cast&lt;size_t&gt;(addressOffset);
1549 }
1550 
1551 COMPILE_ASSERT(!(sizeof(JSObject) % sizeof(WriteBarrierBase&lt;Unknown&gt;)), JSObject_inline_storage_has_correct_alignment);
1552 
1553 template&lt;unsigned charactersCount&gt;
1554 ALWAYS_INLINE Identifier makeIdentifier(VM&amp; vm, const char (&amp;characters)[charactersCount])
1555 {
1556     return Identifier::fromString(vm, characters);
1557 }
1558 
1559 ALWAYS_INLINE Identifier makeIdentifier(VM&amp; vm, const char* name)
1560 {
1561     return Identifier::fromString(vm, name);
1562 }
1563 
1564 ALWAYS_INLINE Identifier makeIdentifier(VM&amp;, const Identifier&amp; name)
1565 {
1566     return name;
1567 }
1568 
1569 bool validateAndApplyPropertyDescriptor(JSGlobalObject*, JSObject*, PropertyName, bool isExtensible,
1570     const PropertyDescriptor&amp; descriptor, bool isCurrentDefined, const PropertyDescriptor&amp; current, bool throwException);
1571 
1572 JS_EXPORT_PRIVATE NEVER_INLINE bool ordinarySetSlow(JSGlobalObject*, JSObject*, PropertyName, JSValue, JSValue receiver, bool shouldThrow);
1573 
1574 // Helper for defining native functions, if you&#39;re not using a static hash table.
1575 // Use this macro from within finishCreation() methods in prototypes. This assumes
1576 // you&#39;ve defined variables called globalObject, globalObject, and vm, and they
1577 // have the expected meanings.
1578 #define JSC_NATIVE_INTRINSIC_FUNCTION(jsName, cppName, attributes, length, intrinsic) \
1579     putDirectNativeFunction(\
1580         vm, globalObject, makeIdentifier(vm, (jsName)), (length), cppName, \
1581         (intrinsic), (attributes))
1582 
1583 #define JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(jsName, cppName, attributes, length, intrinsic) \
1584     putDirectNativeFunctionWithoutTransition(\
1585         vm, globalObject, makeIdentifier(vm, (jsName)), (length), cppName, \
1586         (intrinsic), (attributes))
1587 
1588 // As above, but this assumes that the function you&#39;re defining doesn&#39;t have an
1589 // intrinsic.
1590 #define JSC_NATIVE_FUNCTION(jsName, cppName, attributes, length) \
1591     JSC_NATIVE_INTRINSIC_FUNCTION(jsName, cppName, (attributes), (length), NoIntrinsic)
1592 
1593 #define JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(jsName, cppName, attributes, length) \
1594     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(jsName, cppName, (attributes), (length), NoIntrinsic)
1595 
1596 // Identical helpers but for builtins. Note that currently, we don&#39;t support builtins that are
1597 // also intrinsics, but we probably will do that eventually.
1598 #define JSC_BUILTIN_FUNCTION(jsName, generatorName, attributes) \
1599     putDirectBuiltinFunction(\
1600         vm, globalObject, makeIdentifier(vm, (jsName)), (generatorName)(vm), (attributes))
1601 
1602 #define JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(jsName, generatorName, attributes) \
1603     putDirectBuiltinFunctionWithoutTransition(\
1604         vm, globalObject, makeIdentifier(vm, (jsName)), (generatorName)(vm), (attributes))
1605 
1606 // Helper for defining native getters on properties.
1607 #define JSC_NATIVE_INTRINSIC_GETTER(jsName, cppName, attributes, intrinsic)  \
1608     putDirectNativeIntrinsicGetter(\
1609         vm, globalObject, makeIdentifier(vm, (jsName)), (cppName), \
1610         (intrinsic), ((attributes) | PropertyAttribute::Accessor))
1611 
1612 #define JSC_NATIVE_INTRINSIC_GETTER_WITHOUT_TRANSITION(jsName, cppName, attributes, intrinsic)  \
1613     putDirectNativeIntrinsicGetterWithoutTransition(\
1614         vm, globalObject, makeIdentifier(vm, (jsName)), (cppName), \
1615         (intrinsic), ((attributes) | PropertyAttribute::Accessor))
1616 
1617 #define JSC_NATIVE_GETTER(jsName, cppName, attributes) \
1618     JSC_NATIVE_INTRINSIC_GETTER((jsName), (cppName), (attributes), NoIntrinsic)
1619 
1620 #define JSC_NATIVE_GETTER_WITHOUT_TRANSITION(jsName, cppName, attributes) \
1621     JSC_NATIVE_INTRINSIC_GETTER_WITHOUT_TRANSITION((jsName), (cppName), (attributes), NoIntrinsic)
1622 
1623 
1624 #define STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(DerivedClass, BaseClass) \
1625     static_assert(sizeof(DerivedClass) == sizeof(BaseClass)); \
1626     static_assert(DerivedClass::destroy == BaseClass::destroy);
1627 
1628 } // namespace JSC
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/page/DOMWindow.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DOMTimer.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DOMWindow.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/DOMWindow.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 66,11 ***</span>
<span class="line-new-header">--- 66,13 ---</span>
  #include &quot;FrameLoaderClient.h&quot;
  #include &quot;FrameTree.h&quot;
  #include &quot;FrameView.h&quot;
  #include &quot;HTTPParsers.h&quot;
  #include &quot;History.h&quot;
<span class="line-added">+ #include &quot;IdleRequestOptions.h&quot;</span>
  #include &quot;InspectorInstrumentation.h&quot;
<span class="line-added">+ #include &quot;JSDOMPromiseDeferred.h&quot;</span>
  #include &quot;JSDOMWindowBase.h&quot;
  #include &quot;JSExecState.h&quot;
  #include &quot;Location.h&quot;
  #include &quot;MediaQueryList.h&quot;
  #include &quot;MediaQueryMatcher.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 84,11 ***</span>
  #include &quot;Performance.h&quot;
  #include &quot;RequestAnimationFrameCallback.h&quot;
  #include &quot;ResourceLoadInfo.h&quot;
  #include &quot;ResourceLoadObserver.h&quot;
  #include &quot;RuntimeApplicationChecks.h&quot;
<span class="line-removed">- #include &quot;RuntimeEnabledFeatures.h&quot;</span>
  #include &quot;ScheduledAction.h&quot;
  #include &quot;Screen.h&quot;
  #include &quot;SecurityOrigin.h&quot;
  #include &quot;SecurityOriginData.h&quot;
  #include &quot;SecurityPolicy.h&quot;
<span class="line-new-header">--- 86,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 144,10 ***</span>
<span class="line-new-header">--- 145,25 ---</span>
  #endif
  
  namespace WebCore {
  using namespace Inspector;
  
<span class="line-added">+ static const Seconds defaultTransientActivationDuration { 2_s };</span>
<span class="line-added">+ </span>
<span class="line-added">+ static Optional&lt;Seconds&gt;&amp; transientActivationDurationOverrideForTesting()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     static NeverDestroyed&lt;Optional&lt;Seconds&gt;&gt; overrideForTesting;</span>
<span class="line-added">+     return overrideForTesting;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static Seconds transientActivationDuration()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (auto override = transientActivationDurationOverrideForTesting())</span>
<span class="line-added">+         return *override;</span>
<span class="line-added">+     return defaultTransientActivationDuration;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  WTF_MAKE_ISO_ALLOCATED_IMPL(DOMWindow);
  
  class PostMessageTimer : public TimerBase {
  public:
      PostMessageTimer(DOMWindow&amp; window, MessageWithMessagePorts&amp;&amp; message, const String&amp; sourceOrigin, RefPtr&lt;WindowProxy&gt;&amp;&amp; source, RefPtr&lt;SecurityOrigin&gt;&amp;&amp; targetOrigin, RefPtr&lt;ScriptCallStack&gt;&amp;&amp; stackTrace)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 432,10 ***</span>
<span class="line-new-header">--- 448,11 ---</span>
          return;
  
      if (!page-&gt;mainFrame().mayPrewarmLocalStorage())
          return;
  
<span class="line-added">+     // This eagerly constructs the StorageArea, which will load items from disk.</span>
      auto localStorageResult = this-&gt;localStorage();
      if (localStorageResult.hasException())
          return;
  
      auto* localStorage = localStorageResult.returnValue();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 555,29 ***</span>
      if (m_suspendedForDocumentSuspension)
          return;
      willDestroyDocumentInFrame();
  }
  
<span class="line-modified">! void DOMWindow::suspendForPageCache()</span>
  {
      SetForScope&lt;bool&gt; isSuspendingObservers(m_isSuspendingObservers, true);
      RELEASE_ASSERT(frame());
  
      for (auto* observer : copyToVector(m_observers)) {
          if (m_observers.contains(observer))
<span class="line-modified">!             observer-&gt;suspendForPageCache();</span>
      }
      RELEASE_ASSERT(frame());
  
      m_suspendedForDocumentSuspension = true;
  }
  
<span class="line-modified">! void DOMWindow::resumeFromPageCache()</span>
  {
      for (auto* observer : copyToVector(m_observers)) {
          if (m_observers.contains(observer))
<span class="line-modified">!             observer-&gt;resumeFromPageCache();</span>
      }
  
      m_suspendedForDocumentSuspension = false;
  }
  
<span class="line-new-header">--- 572,29 ---</span>
      if (m_suspendedForDocumentSuspension)
          return;
      willDestroyDocumentInFrame();
  }
  
<span class="line-modified">! void DOMWindow::suspendForBackForwardCache()</span>
  {
      SetForScope&lt;bool&gt; isSuspendingObservers(m_isSuspendingObservers, true);
      RELEASE_ASSERT(frame());
  
      for (auto* observer : copyToVector(m_observers)) {
          if (m_observers.contains(observer))
<span class="line-modified">!             observer-&gt;suspendForBackForwardCache();</span>
      }
      RELEASE_ASSERT(frame());
  
      m_suspendedForDocumentSuspension = true;
  }
  
<span class="line-modified">! void DOMWindow::resumeFromBackForwardCache()</span>
  {
      for (auto* observer : copyToVector(m_observers)) {
          if (m_observers.contains(observer))
<span class="line-modified">!             observer-&gt;resumeFromBackForwardCache();</span>
      }
  
      m_suspendedForDocumentSuspension = false;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 869,34 ***</span>
      auto storageArea = page-&gt;storageNamespaceProvider().localStorageArea(*document);
      m_localStorage = Storage::create(*this, WTFMove(storageArea));
      return m_localStorage.get();
  }
  
<span class="line-modified">! ExceptionOr&lt;void&gt; DOMWindow::postMessage(JSC::ExecState&amp; state, DOMWindow&amp; incumbentWindow, JSC::JSValue messageValue, const String&amp; targetOrigin, Vector&lt;JSC::Strong&lt;JSC::JSObject&gt;&gt;&amp;&amp; transfer)</span>
  {
      if (!isCurrentlyDisplayedInFrame())
          return { };
  
      Document* sourceDocument = incumbentWindow.document();
  
      // Compute the target origin.  We need to do this synchronously in order
      // to generate the SyntaxError exception correctly.
      RefPtr&lt;SecurityOrigin&gt; target;
<span class="line-modified">!     if (targetOrigin == &quot;/&quot;) {</span>
          if (!sourceDocument)
              return { };
          target = &amp;sourceDocument-&gt;securityOrigin();
<span class="line-modified">!     } else if (targetOrigin != &quot;*&quot;) {</span>
<span class="line-modified">!         target = SecurityOrigin::createFromString(targetOrigin);</span>
          // It doesn&#39;t make sense target a postMessage at a unique origin
          // because there&#39;s no way to represent a unique origin in a string.
          if (target-&gt;isUnique())
              return Exception { SyntaxError };
      }
  
      Vector&lt;RefPtr&lt;MessagePort&gt;&gt; ports;
<span class="line-modified">!     auto messageData = SerializedScriptValue::create(state, messageValue, WTFMove(transfer), ports, SerializationContext::WindowPostMessage);</span>
      if (messageData.hasException())
          return messageData.releaseException();
  
      auto disentangledPorts = MessagePort::disentanglePorts(WTFMove(ports));
      if (disentangledPorts.hasException())
<span class="line-new-header">--- 886,34 ---</span>
      auto storageArea = page-&gt;storageNamespaceProvider().localStorageArea(*document);
      m_localStorage = Storage::create(*this, WTFMove(storageArea));
      return m_localStorage.get();
  }
  
<span class="line-modified">! ExceptionOr&lt;void&gt; DOMWindow::postMessage(JSC::JSGlobalObject&amp; lexicalGlobalObject, DOMWindow&amp; incumbentWindow, JSC::JSValue messageValue, WindowPostMessageOptions&amp;&amp; options)</span>
  {
      if (!isCurrentlyDisplayedInFrame())
          return { };
  
      Document* sourceDocument = incumbentWindow.document();
  
      // Compute the target origin.  We need to do this synchronously in order
      // to generate the SyntaxError exception correctly.
      RefPtr&lt;SecurityOrigin&gt; target;
<span class="line-modified">!     if (options.targetOrigin == &quot;/&quot;) {</span>
          if (!sourceDocument)
              return { };
          target = &amp;sourceDocument-&gt;securityOrigin();
<span class="line-modified">!     } else if (options.targetOrigin != &quot;*&quot;) {</span>
<span class="line-modified">!         target = SecurityOrigin::createFromString(options.targetOrigin);</span>
          // It doesn&#39;t make sense target a postMessage at a unique origin
          // because there&#39;s no way to represent a unique origin in a string.
          if (target-&gt;isUnique())
              return Exception { SyntaxError };
      }
  
      Vector&lt;RefPtr&lt;MessagePort&gt;&gt; ports;
<span class="line-modified">!     auto messageData = SerializedScriptValue::create(lexicalGlobalObject, messageValue, WTFMove(options.transfer), ports, SerializationContext::WindowPostMessage);</span>
      if (messageData.hasException())
          return messageData.releaseException();
  
      auto disentangledPorts = MessagePort::disentanglePorts(WTFMove(ports));
      if (disentangledPorts.hasException())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 918,11 ***</span>
      // Schedule the message.
      RefPtr&lt;WindowProxy&gt; incumbentWindowProxy = incumbentWindow.frame() ? &amp;incumbentWindow.frame()-&gt;windowProxy() : nullptr;
      auto* timer = new PostMessageTimer(*this, WTFMove(message), sourceOrigin, WTFMove(incumbentWindowProxy), WTFMove(target), WTFMove(stackTrace));
      timer-&gt;startOneShot(0_s);
  
<span class="line-modified">!     InspectorInstrumentation::didPostMessage(*frame(), *timer, state);</span>
  
      return { };
  }
  
  void DOMWindow::postMessageTimerFired(PostMessageTimer&amp; timer)
<span class="line-new-header">--- 935,11 ---</span>
      // Schedule the message.
      RefPtr&lt;WindowProxy&gt; incumbentWindowProxy = incumbentWindow.frame() ? &amp;incumbentWindow.frame()-&gt;windowProxy() : nullptr;
      auto* timer = new PostMessageTimer(*this, WTFMove(message), sourceOrigin, WTFMove(incumbentWindowProxy), WTFMove(target), WTFMove(stackTrace));
      timer-&gt;startOneShot(0_s);
  
<span class="line-modified">!     InspectorInstrumentation::didPostMessage(*frame(), *timer, lexicalGlobalObject);</span>
  
      return { };
  }
  
  void DOMWindow::postMessageTimerFired(PostMessageTimer&amp; timer)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 982,34 ***</span>
  void DOMWindow::focus(bool allowFocus)
  {
      if (!frame())
          return;
  
<span class="line-modified">!     Page* page = frame()-&gt;page();</span>
      if (!page)
          return;
  
<span class="line-modified">!     allowFocus = allowFocus || WindowFocusAllowedIndicator::windowFocusAllowed() || !frame()-&gt;settings().windowFocusRestricted();</span>
  
      // If we&#39;re a top level window, bring the window to the front.
<span class="line-modified">!     if (frame()-&gt;isMainFrame() &amp;&amp; allowFocus)</span>
          page-&gt;chrome().focus();
  
<span class="line-modified">!     if (!frame())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!frame()-&gt;hasHadUserInteraction() &amp;&amp; !isSameSecurityOriginAsMainFrame())</span>
          return;
  
      // Clear the current frame&#39;s focused node if a new frame is about to be focused.
<span class="line-modified">!     Frame* focusedFrame = page-&gt;focusController().focusedFrame();</span>
<span class="line-modified">!     if (focusedFrame &amp;&amp; focusedFrame != frame())</span>
          focusedFrame-&gt;document()-&gt;setFocusedElement(nullptr);
  
<span class="line-modified">!     // setFocusedElement may clear frame(), so recheck before using it.</span>
<span class="line-removed">-     if (auto* frame = this-&gt;frame())</span>
<span class="line-removed">-         frame-&gt;eventHandler().focusDocumentView();</span>
  }
  
  void DOMWindow::blur()
  {
      auto* frame = this-&gt;frame();
<span class="line-new-header">--- 999,31 ---</span>
  void DOMWindow::focus(bool allowFocus)
  {
      if (!frame())
          return;
  
<span class="line-modified">!     auto protectedFrame = makeRefPtr(frame());</span>
<span class="line-added">+ </span>
<span class="line-added">+     Page* page = protectedFrame-&gt;page();</span>
      if (!page)
          return;
  
<span class="line-modified">!     allowFocus = allowFocus || WindowFocusAllowedIndicator::windowFocusAllowed() || !protectedFrame-&gt;settings().windowFocusRestricted();</span>
  
      // If we&#39;re a top level window, bring the window to the front.
<span class="line-modified">!     if (protectedFrame-&gt;isMainFrame() &amp;&amp; allowFocus)</span>
          page-&gt;chrome().focus();
  
<span class="line-modified">!     if (!protectedFrame-&gt;hasHadUserInteraction() &amp;&amp; !isSameSecurityOriginAsMainFrame())</span>
          return;
  
      // Clear the current frame&#39;s focused node if a new frame is about to be focused.
<span class="line-modified">!     auto focusedFrame = makeRefPtr(page-&gt;focusController().focusedFrame());</span>
<span class="line-modified">!     if (focusedFrame &amp;&amp; focusedFrame != protectedFrame)</span>
          focusedFrame-&gt;document()-&gt;setFocusedElement(nullptr);
  
<span class="line-modified">!     protectedFrame-&gt;eventHandler().focusDocumentView();</span>
  }
  
  void DOMWindow::blur()
  {
      auto* frame = this-&gt;frame();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1055,10 ***</span>
<span class="line-new-header">--- 1069,12 ---</span>
      }
  
      if (!frame-&gt;loader().shouldClose())
          return;
  
<span class="line-added">+     ResourceLoadObserver::shared().updateCentralStatisticsStore();</span>
<span class="line-added">+ </span>
      page-&gt;setIsClosing();
      page-&gt;chrome().closeWindowSoon();
  }
  
  void DOMWindow::print()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1121,11 ***</span>
  #endif
  
      page-&gt;chrome().runJavaScriptAlert(*frame, message);
  }
  
<span class="line-modified">! bool DOMWindow::confirm(const String&amp; message)</span>
  {
      auto* frame = this-&gt;frame();
      if (!frame)
          return false;
  
<span class="line-new-header">--- 1137,11 ---</span>
  #endif
  
      page-&gt;chrome().runJavaScriptAlert(*frame, message);
  }
  
<span class="line-modified">! bool DOMWindow::confirmForBindings(const String&amp; message)</span>
  {
      auto* frame = this-&gt;frame();
      if (!frame)
          return false;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1486,19 ***</span>
      return &amp;frame-&gt;tree().top().windowProxy();
  }
  
  String DOMWindow::origin() const
  {
<span class="line-modified">!     auto document = this-&gt;document();</span>
      return document ? document-&gt;securityOrigin().toString() : emptyString();
  }
  
  Document* DOMWindow::document() const
  {
      return downcast&lt;Document&gt;(ContextDestructionObserver::scriptExecutionContext());
  }
  
  StyleMedia&amp; DOMWindow::styleMedia()
  {
      if (!m_media)
          m_media = StyleMedia::create(*this);
      return *m_media;
<span class="line-new-header">--- 1502,84 ---</span>
      return &amp;frame-&gt;tree().top().windowProxy();
  }
  
  String DOMWindow::origin() const
  {
<span class="line-modified">!     auto* document = this-&gt;document();</span>
      return document ? document-&gt;securityOrigin().toString() : emptyString();
  }
  
<span class="line-added">+ SecurityOrigin* DOMWindow::securityOrigin() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto* document = this-&gt;document();</span>
<span class="line-added">+     return document ? &amp;document-&gt;securityOrigin() : nullptr;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  Document* DOMWindow::document() const
  {
      return downcast&lt;Document&gt;(ContextDestructionObserver::scriptExecutionContext());
  }
  
<span class="line-added">+ void DOMWindow::overrideTransientActivationDurationForTesting(Optional&lt;Seconds&gt;&amp;&amp; override)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     transientActivationDurationOverrideForTesting() = WTFMove(override);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // When the current high resolution time is greater than or equal to the last activation timestamp in W, and</span>
<span class="line-added">+ // less than the last activation timestamp in W plus the transient activation duration, then W is said to</span>
<span class="line-added">+ // have transient activation. (https://html.spec.whatwg.org/multipage/interaction.html#transient-activation)</span>
<span class="line-added">+ bool DOMWindow::hasTransientActivation() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto now = MonotonicTime::now();</span>
<span class="line-added">+     return now &gt;= m_lastActivationTimestamp &amp;&amp; now &lt; (m_lastActivationTimestamp + transientActivationDuration());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // https://html.spec.whatwg.org/multipage/interaction.html#consume-user-activation</span>
<span class="line-added">+ bool DOMWindow::consumeTransientActivation()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (!hasTransientActivation())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (Frame* frame = this-&gt;frame() ? &amp;this-&gt;frame()-&gt;tree().top() : nullptr; frame; frame = frame-&gt;tree().traverseNext()) {</span>
<span class="line-added">+         auto* window = frame-&gt;window();</span>
<span class="line-added">+         if (!window || window-&gt;lastActivationTimestamp() != MonotonicTime::infinity())</span>
<span class="line-added">+             window-&gt;setLastActivationTimestamp(-MonotonicTime::infinity());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // https://html.spec.whatwg.org/multipage/interaction.html#activation-notification</span>
<span class="line-added">+ void DOMWindow::notifyActivated(MonotonicTime activationTime)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     setLastActivationTimestamp(activationTime);</span>
<span class="line-added">+     if (!frame())</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (Frame* ancestor = frame() ? frame()-&gt;tree().parent() : nullptr; ancestor; ancestor = ancestor-&gt;tree().parent()) {</span>
<span class="line-added">+         if (auto* window = ancestor-&gt;window())</span>
<span class="line-added">+             window-&gt;setLastActivationTimestamp(activationTime);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto* securityOrigin = this-&gt;securityOrigin();</span>
<span class="line-added">+     if (!securityOrigin)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto* descendant = frame();</span>
<span class="line-added">+     while ((descendant = descendant-&gt;tree().traverseNext(frame()))) {</span>
<span class="line-added">+         auto* descendantWindow = descendant-&gt;window();</span>
<span class="line-added">+         if (!descendantWindow)</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto* descendantSecurityOrigin = descendantWindow-&gt;securityOrigin();</span>
<span class="line-added">+         if (!descendantSecurityOrigin || !descendantSecurityOrigin-&gt;isSameOriginAs(*securityOrigin))</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+ </span>
<span class="line-added">+         descendantWindow-&gt;setLastActivationTimestamp(activationTime);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  StyleMedia&amp; DOMWindow::styleMedia()
  {
      if (!m_media)
          m_media = StyleMedia::create(*this);
      return *m_media;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1520,13 ***</span>
          return nullptr;
  
      auto* frame = this-&gt;frame();
      frame-&gt;document()-&gt;styleScope().flushPendingUpdate();
  
<span class="line-modified">!     unsigned rulesToInclude = StyleResolver::AuthorCSSRules;</span>
      if (!authorOnly)
<span class="line-modified">!         rulesToInclude |= StyleResolver::UAAndUserCSSRules;</span>
  
      PseudoId pseudoId = CSSSelector::pseudoId(pseudoType);
  
      auto matchedRules = frame-&gt;document()-&gt;styleScope().resolver().pseudoStyleRulesForElement(element, pseudoId, rulesToInclude);
      if (matchedRules.isEmpty())
<span class="line-new-header">--- 1601,13 ---</span>
          return nullptr;
  
      auto* frame = this-&gt;frame();
      frame-&gt;document()-&gt;styleScope().flushPendingUpdate();
  
<span class="line-modified">!     unsigned rulesToInclude = Style::Resolver::AuthorCSSRules;</span>
      if (!authorOnly)
<span class="line-modified">!         rulesToInclude |= Style::Resolver::UAAndUserCSSRules;</span>
  
      PseudoId pseudoId = CSSSelector::pseudoId(pseudoType);
  
      auto matchedRules = frame-&gt;document()-&gt;styleScope().resolver().pseudoStyleRulesForElement(element, pseudoId, rulesToInclude);
      if (matchedRules.isEmpty())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1600,11 ***</span>
      if (!isCurrentlyDisplayedInFrame())
          return;
  
      document()-&gt;updateLayoutIgnorePendingStylesheets();
  
<span class="line-modified">!     FrameView* view = frame()-&gt;view();</span>
      if (!view)
          return;
  
      ScrollToOptions scrollToOptions = normalizeNonFiniteCoordinatesOrFallBackTo(options, 0, 0);
      scrollToOptions.left.value() += view-&gt;mapFromLayoutToCSSUnits(view-&gt;contentsScrollPosition().x());
<span class="line-new-header">--- 1681,15 ---</span>
      if (!isCurrentlyDisplayedInFrame())
          return;
  
      document()-&gt;updateLayoutIgnorePendingStylesheets();
  
<span class="line-modified">!     auto* frame = this-&gt;frame();</span>
<span class="line-added">+     if (!frame)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto view = makeRefPtr(frame-&gt;view());</span>
      if (!view)
          return;
  
      ScrollToOptions scrollToOptions = normalizeNonFiniteCoordinatesOrFallBackTo(options, 0, 0);
      scrollToOptions.left.value() += view-&gt;mapFromLayoutToCSSUnits(view-&gt;contentsScrollPosition().x());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1615,11 ***</span>
  void DOMWindow::scrollTo(double x, double y, ScrollClamping clamping) const
  {
      scrollTo({ x, y }, clamping);
  }
  
<span class="line-modified">! void DOMWindow::scrollTo(const ScrollToOptions&amp; options, ScrollClamping) const</span>
  {
      if (!isCurrentlyDisplayedInFrame())
          return;
  
      RefPtr&lt;FrameView&gt; view = frame()-&gt;view();
<span class="line-new-header">--- 1700,11 ---</span>
  void DOMWindow::scrollTo(double x, double y, ScrollClamping clamping) const
  {
      scrollTo({ x, y }, clamping);
  }
  
<span class="line-modified">! void DOMWindow::scrollTo(const ScrollToOptions&amp; options, ScrollClamping clamping) const</span>
  {
      if (!isCurrentlyDisplayedInFrame())
          return;
  
      RefPtr&lt;FrameView&gt; view = frame()-&gt;view();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1634,11 ***</span>
          return;
  
      document()-&gt;updateLayoutIgnorePendingStylesheets();
  
      IntPoint layoutPos(view-&gt;mapFromCSSToLayoutUnits(scrollToOptions.left.value()), view-&gt;mapFromCSSToLayoutUnits(scrollToOptions.top.value()));
<span class="line-modified">!     view-&gt;setContentsScrollPosition(layoutPos);</span>
  }
  
  bool DOMWindow::allowedToChangeWindowGeometry() const
  {
      auto* frame = this-&gt;frame();
<span class="line-new-header">--- 1719,11 ---</span>
          return;
  
      document()-&gt;updateLayoutIgnorePendingStylesheets();
  
      IntPoint layoutPos(view-&gt;mapFromCSSToLayoutUnits(scrollToOptions.left.value()), view-&gt;mapFromCSSToLayoutUnits(scrollToOptions.top.value()));
<span class="line-modified">!     view-&gt;setContentsScrollPosition(layoutPos, clamping);</span>
  }
  
  bool DOMWindow::allowedToChangeWindowGeometry() const
  {
      auto* frame = this-&gt;frame();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1702,11 ***</span>
      FloatSize dest = FloatSize(width, height);
      FloatRect update(fr.location(), dest);
      page-&gt;chrome().setWindowRect(adjustWindowRect(*page, update));
  }
  
<span class="line-modified">! ExceptionOr&lt;int&gt; DOMWindow::setTimeout(JSC::ExecState&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>
  {
      auto* context = scriptExecutionContext();
      if (!context)
          return Exception { InvalidAccessError };
  
<span class="line-new-header">--- 1787,11 ---</span>
      FloatSize dest = FloatSize(width, height);
      FloatRect update(fr.location(), dest);
      page-&gt;chrome().setWindowRect(adjustWindowRect(*page, update));
  }
  
<span class="line-modified">! ExceptionOr&lt;int&gt; DOMWindow::setTimeout(JSC::JSGlobalObject&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>
  {
      auto* context = scriptExecutionContext();
      if (!context)
          return Exception { InvalidAccessError };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1727,11 ***</span>
      if (!context)
          return;
      DOMTimer::removeById(*context, timeoutId);
  }
  
<span class="line-modified">! ExceptionOr&lt;int&gt; DOMWindow::setInterval(JSC::ExecState&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>
  {
      auto* context = scriptExecutionContext();
      if (!context)
          return Exception { InvalidAccessError };
  
<span class="line-new-header">--- 1812,11 ---</span>
      if (!context)
          return;
      DOMTimer::removeById(*context, timeoutId);
  }
  
<span class="line-modified">! ExceptionOr&lt;int&gt; DOMWindow::setInterval(JSC::JSGlobalObject&amp; state, std::unique_ptr&lt;ScheduledAction&gt; action, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>
  {
      auto* context = scriptExecutionContext();
      if (!context)
          return Exception { InvalidAccessError };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1778,10 ***</span>
<span class="line-new-header">--- 1863,26 ---</span>
      if (!document)
          return;
      document-&gt;cancelAnimationFrame(id);
  }
  
<span class="line-added">+ int DOMWindow::requestIdleCallback(Ref&lt;IdleRequestCallback&gt;&amp;&amp; callback, const IdleRequestOptions&amp; options)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto document = makeRefPtr(this-&gt;document());</span>
<span class="line-added">+     if (!document)</span>
<span class="line-added">+         return 0;</span>
<span class="line-added">+     return document-&gt;requestIdleCallback(WTFMove(callback), Seconds::fromMilliseconds(options.timeout));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void DOMWindow::cancelIdleCallback(int id)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto document = makeRefPtr(this-&gt;document());</span>
<span class="line-added">+     if (!document)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     return document-&gt;cancelIdleCallback(id);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void DOMWindow::createImageBitmap(ImageBitmap::Source&amp;&amp; source, ImageBitmapOptions&amp;&amp; options, ImageBitmap::Promise&amp;&amp; promise)
  {
      auto* document = this-&gt;document();
      if (!document) {
          promise.reject(InvalidStateError);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2038,11 ***</span>
  void DOMWindow::decrementScrollEventListenersCount()
  {
      Document* document = this-&gt;document();
      if (!--m_scrollEventListenerCount &amp;&amp; document == &amp;document-&gt;topDocument()) {
          Frame* frame = this-&gt;frame();
<span class="line-modified">!         if (frame &amp;&amp; frame-&gt;page() &amp;&amp; document-&gt;pageCacheState() == Document::NotInPageCache)</span>
              frame-&gt;page()-&gt;chrome().client().setNeedsScrollNotifications(*frame, false);
      }
  }
  
  #endif
<span class="line-new-header">--- 2139,11 ---</span>
  void DOMWindow::decrementScrollEventListenersCount()
  {
      Document* document = this-&gt;document();
      if (!--m_scrollEventListenerCount &amp;&amp; document == &amp;document-&gt;topDocument()) {
          Frame* frame = this-&gt;frame();
<span class="line-modified">!         if (frame &amp;&amp; frame-&gt;page() &amp;&amp; document-&gt;backForwardCacheState() == Document::NotInBackForwardCache)</span>
              frame-&gt;page()-&gt;chrome().client().setNeedsScrollNotifications(*frame, false);
      }
  }
  
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2103,12 ***</span>
      return true;
  }
  
  void DOMWindow::languagesChanged()
  {
<span class="line-modified">!     if (auto* document = this-&gt;document())</span>
<span class="line-modified">!         document-&gt;enqueueWindowEvent(Event::create(eventNames().languagechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
  }
  
  void DOMWindow::dispatchLoadEvent()
  {
      // If we did not protect it, the document loader and its timing subobject might get destroyed
<span class="line-new-header">--- 2204,13 ---</span>
      return true;
  }
  
  void DOMWindow::languagesChanged()
  {
<span class="line-modified">!     // https://html.spec.whatwg.org/multipage/system-state.html#dom-navigator-languages</span>
<span class="line-modified">!     if (auto document = makeRefPtr(this-&gt;document()))</span>
<span class="line-added">+         document-&gt;queueTaskToDispatchEventOnWindow(TaskSource::DOMManipulation, Event::create(eventNames().languagechangeEvent, Event::CanBubble::No, Event::IsCancelable::No));</span>
  }
  
  void DOMWindow::dispatchLoadEvent()
  {
      // If we did not protect it, the document loader and its timing subobject might get destroyed
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2166,15 ***</span>
      // But the instrumentation prevents us from calling EventDispatcher::dispatchEvent here.
      event.setTarget(target ? target : this);
      event.setCurrentTarget(this);
      event.setEventPhase(Event::AT_TARGET);
      event.resetBeforeDispatch();
<span class="line-modified">!     auto cookie = InspectorInstrumentation::willDispatchEventOnWindow(frame(), event, *this);</span>
      // FIXME: We should use EventDispatcher everywhere.
      fireEventListeners(event, EventInvokePhase::Capturing);
      fireEventListeners(event, EventInvokePhase::Bubbling);
<span class="line-modified">!     InspectorInstrumentation::didDispatchEventOnWindow(cookie, event.defaultPrevented());</span>
      event.resetAfterDispatch();
  }
  
  void DOMWindow::removeAllEventListeners()
  {
<span class="line-new-header">--- 2268,27 ---</span>
      // But the instrumentation prevents us from calling EventDispatcher::dispatchEvent here.
      event.setTarget(target ? target : this);
      event.setCurrentTarget(this);
      event.setEventPhase(Event::AT_TARGET);
      event.resetBeforeDispatch();
<span class="line-modified">! </span>
<span class="line-added">+     Frame* protectedFrame = nullptr;</span>
<span class="line-added">+     bool hasListenersForEvent = false;</span>
<span class="line-added">+     if (UNLIKELY(InspectorInstrumentation::hasFrontends())) {</span>
<span class="line-added">+         protectedFrame = frame();</span>
<span class="line-added">+         hasListenersForEvent = hasEventListeners(event.type());</span>
<span class="line-added">+         if (hasListenersForEvent)</span>
<span class="line-added">+             InspectorInstrumentation::willDispatchEventOnWindow(protectedFrame, event, *this);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      // FIXME: We should use EventDispatcher everywhere.
      fireEventListeners(event, EventInvokePhase::Capturing);
      fireEventListeners(event, EventInvokePhase::Bubbling);
<span class="line-modified">! </span>
<span class="line-added">+     if (hasListenersForEvent)</span>
<span class="line-added">+         InspectorInstrumentation::didDispatchEventOnWindow(protectedFrame, event);</span>
<span class="line-added">+ </span>
      event.resetAfterDispatch();
  }
  
  void DOMWindow::removeAllEventListeners()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2252,11 ***</span>
          // FIXME: What if activeDocument()-&gt;frame() is 0?
          completedURL, activeDocument-&gt;frame()-&gt;loader().outgoingReferrer(),
          lockHistory, lockBackForwardList);
  }
  
<span class="line-modified">! void DOMWindow::printErrorMessage(const String&amp; message)</span>
  {
      if (message.isEmpty())
          return;
  
      if (PageConsoleClient* pageConsole = console())
<span class="line-new-header">--- 2366,11 ---</span>
          // FIXME: What if activeDocument()-&gt;frame() is 0?
          completedURL, activeDocument-&gt;frame()-&gt;loader().outgoingReferrer(),
          lockHistory, lockBackForwardList);
  }
  
<span class="line-modified">! void DOMWindow::printErrorMessage(const String&amp; message) const</span>
  {
      if (message.isEmpty())
          return;
  
      if (PageConsoleClient* pageConsole = console())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2355,11 ***</span>
      // For whatever reason, Firefox uses the first frame to determine the outgoingReferrer. We replicate that behavior here.
      String referrer = windowFeatures.noreferrer ? String() : SecurityPolicy::generateReferrerHeader(firstFrame.document()-&gt;referrerPolicy(), completedURL, firstFrame.loader().outgoingReferrer());
      auto initiatedByMainFrame = activeFrame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
  
      ResourceRequest resourceRequest { completedURL, referrer };
<span class="line-removed">-     FrameLoader::addHTTPOriginIfNeeded(resourceRequest, firstFrame.loader().outgoingOrigin());</span>
      FrameLoadRequest frameLoadRequest { *activeDocument, activeDocument-&gt;securityOrigin(), resourceRequest, frameName, LockHistory::No, LockBackForwardList::No, MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Allow, activeDocument-&gt;shouldOpenExternalURLsPolicyToPropagate(), initiatedByMainFrame };
  
      // We pass the opener frame for the lookupFrame in case the active frame is different from
      // the opener frame, and the name references a frame relative to the opener frame.
      bool created;
<span class="line-new-header">--- 2469,10 ---</span>
</pre>
<center><a href="DOMTimer.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DOMWindow.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
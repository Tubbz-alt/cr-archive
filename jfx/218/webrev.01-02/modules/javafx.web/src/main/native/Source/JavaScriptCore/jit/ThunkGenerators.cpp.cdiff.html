<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/ThunkGenerators.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TempRegisterSet.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ThunkGenerators.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/ThunkGenerators.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 33,10 ***</span>
<span class="line-new-header">--- 33,11 ---</span>
  #include &quot;JSArray.h&quot;
  #include &quot;JSBoundFunction.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;MathCommon.h&quot;
  #include &quot;MaxFrameExtentForSlowPathCall.h&quot;
<span class="line-added">+ #include &quot;ProbeContext.h&quot;</span>
  #include &quot;SpecializedThunkJIT.h&quot;
  #include &lt;wtf/InlineASM.h&gt;
  #include &lt;wtf/StringPrintStream.h&gt;
  #include &lt;wtf/text/StringImpl.h&gt;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 45,11 ***</span>
  namespace JSC {
  
  template&lt;typename TagType&gt;
  inline void emitPointerValidation(CCallHelpers&amp; jit, GPRReg pointerGPR, TagType tag)
  {
<span class="line-modified">!     if (ASSERT_DISABLED)</span>
          return;
      CCallHelpers::Jump isNonZero = jit.branchTestPtr(CCallHelpers::NonZero, pointerGPR);
      jit.abortWithReason(TGInvalidPointer);
      isNonZero.link(&amp;jit);
      jit.pushToSave(pointerGPR);
<span class="line-new-header">--- 46,11 ---</span>
  namespace JSC {
  
  template&lt;typename TagType&gt;
  inline void emitPointerValidation(CCallHelpers&amp; jit, GPRReg pointerGPR, TagType tag)
  {
<span class="line-modified">!     if (!ASSERT_ENABLED)</span>
          return;
      CCallHelpers::Jump isNonZero = jit.branchTestPtr(CCallHelpers::NonZero, pointerGPR);
      jit.abortWithReason(TGInvalidPointer);
      isNonZero.link(&amp;jit);
      jit.pushToSave(pointerGPR);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 68,32 ***</span>
      // even though we won&#39;t use it.
      jit.preserveReturnAddressAfterCall(GPRInfo::nonPreservedNonReturnGPR);
  
      jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm.topEntryFrame);
  
<span class="line-modified">!     jit.setupArguments&lt;decltype(lookupExceptionHandler)&gt;(CCallHelpers::TrustedImmPtr(&amp;vm), GPRInfo::callFrameRegister);</span>
<span class="line-modified">!     jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(lookupExceptionHandler)), GPRInfo::nonArgGPR0);</span>
      emitPointerValidation(jit, GPRInfo::nonArgGPR0, OperationPtrTag);
      jit.call(GPRInfo::nonArgGPR0, OperationPtrTag);
      jit.jumpToExceptionHandler(vm);
  
      LinkBuffer patchBuffer(jit, GLOBAL_THUNK_ID);
      return FINALIZE_CODE(patchBuffer, JITThunkPtrTag, &quot;Throw exception from call slow path thunk&quot;);
  }
  
<span class="line-modified">! static void slowPathFor(CCallHelpers&amp; jit, VM&amp; vm, Sprt_JITOperation_ECli slowPathFunction)</span>
  {
      jit.sanitizeStackInline(vm, GPRInfo::nonArgGPR0);
      jit.emitFunctionPrologue();
      jit.storePtr(GPRInfo::callFrameRegister, &amp;vm.topCallFrame);
  #if OS(WINDOWS) &amp;&amp; CPU(X86_64)
      // Windows X86_64 needs some space pointed to by arg0 for return types larger than 64 bits.
      // Other argument values are shift by 1. Use space on the stack for our two return values.
      // Moving the stack down maxFrameExtentForSlowPathCall bytes gives us room for our 3 arguments
      // and space for the 16 byte return area.
      jit.addPtr(CCallHelpers::TrustedImm32(-static_cast&lt;int32_t&gt;(maxFrameExtentForSlowPathCall)), CCallHelpers::stackPointerRegister);
<span class="line-modified">!     jit.move(GPRInfo::regT2, GPRInfo::argumentGPR2);</span>
      jit.addPtr(CCallHelpers::TrustedImm32(32), CCallHelpers::stackPointerRegister, GPRInfo::argumentGPR0);
      jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR1);
      jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(slowPathFunction)), GPRInfo::nonArgGPR0);
      emitPointerValidation(jit, GPRInfo::nonArgGPR0, OperationPtrTag);
      jit.call(GPRInfo::nonArgGPR0, OperationPtrTag);
<span class="line-new-header">--- 69,37 ---</span>
      // even though we won&#39;t use it.
      jit.preserveReturnAddressAfterCall(GPRInfo::nonPreservedNonReturnGPR);
  
      jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm.topEntryFrame);
  
<span class="line-modified">!     jit.setupArguments&lt;decltype(operationLookupExceptionHandler)&gt;(CCallHelpers::TrustedImmPtr(&amp;vm));</span>
<span class="line-modified">!     jit.prepareCallOperation(vm);</span>
<span class="line-added">+     jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(operationLookupExceptionHandler)), GPRInfo::nonArgGPR0);</span>
      emitPointerValidation(jit, GPRInfo::nonArgGPR0, OperationPtrTag);
      jit.call(GPRInfo::nonArgGPR0, OperationPtrTag);
      jit.jumpToExceptionHandler(vm);
  
      LinkBuffer patchBuffer(jit, GLOBAL_THUNK_ID);
      return FINALIZE_CODE(patchBuffer, JITThunkPtrTag, &quot;Throw exception from call slow path thunk&quot;);
  }
  
<span class="line-modified">! static void slowPathFor(CCallHelpers&amp; jit, VM&amp; vm, Sprt_JITOperation_EGCli slowPathFunction)</span>
  {
      jit.sanitizeStackInline(vm, GPRInfo::nonArgGPR0);
      jit.emitFunctionPrologue();
      jit.storePtr(GPRInfo::callFrameRegister, &amp;vm.topCallFrame);
  #if OS(WINDOWS) &amp;&amp; CPU(X86_64)
      // Windows X86_64 needs some space pointed to by arg0 for return types larger than 64 bits.
      // Other argument values are shift by 1. Use space on the stack for our two return values.
      // Moving the stack down maxFrameExtentForSlowPathCall bytes gives us room for our 3 arguments
      // and space for the 16 byte return area.
      jit.addPtr(CCallHelpers::TrustedImm32(-static_cast&lt;int32_t&gt;(maxFrameExtentForSlowPathCall)), CCallHelpers::stackPointerRegister);
<span class="line-modified">!     static_assert(GPRInfo::regT2 != GPRInfo::argumentGPR0);</span>
<span class="line-added">+     static_assert(GPRInfo::regT3 != GPRInfo::argumentGPR0);</span>
<span class="line-added">+     jit.move(GPRInfo::regT2, GPRInfo::argumentGPR0);</span>
<span class="line-added">+     jit.move(GPRInfo::regT3, GPRInfo::argumentGPR2);</span>
<span class="line-added">+     jit.move(GPRInfo::argumentGPR0, GPRInfo::argumentGPR3);</span>
      jit.addPtr(CCallHelpers::TrustedImm32(32), CCallHelpers::stackPointerRegister, GPRInfo::argumentGPR0);
      jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR1);
      jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(slowPathFunction)), GPRInfo::nonArgGPR0);
      emitPointerValidation(jit, GPRInfo::nonArgGPR0, OperationPtrTag);
      jit.call(GPRInfo::nonArgGPR0, OperationPtrTag);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 101,11 ***</span>
      jit.loadPtr(CCallHelpers::Address(GPRInfo::returnValueGPR), GPRInfo::returnValueGPR);
      jit.addPtr(CCallHelpers::TrustedImm32(maxFrameExtentForSlowPathCall), CCallHelpers::stackPointerRegister);
  #else
      if (maxFrameExtentForSlowPathCall)
          jit.addPtr(CCallHelpers::TrustedImm32(-maxFrameExtentForSlowPathCall), CCallHelpers::stackPointerRegister);
<span class="line-modified">!     jit.setupArguments&lt;decltype(slowPathFunction)&gt;(GPRInfo::regT2);</span>
      jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(slowPathFunction)), GPRInfo::nonArgGPR0);
      emitPointerValidation(jit, GPRInfo::nonArgGPR0, OperationPtrTag);
      jit.call(GPRInfo::nonArgGPR0, OperationPtrTag);
      if (maxFrameExtentForSlowPathCall)
          jit.addPtr(CCallHelpers::TrustedImm32(maxFrameExtentForSlowPathCall), CCallHelpers::stackPointerRegister);
<span class="line-new-header">--- 107,11 ---</span>
      jit.loadPtr(CCallHelpers::Address(GPRInfo::returnValueGPR), GPRInfo::returnValueGPR);
      jit.addPtr(CCallHelpers::TrustedImm32(maxFrameExtentForSlowPathCall), CCallHelpers::stackPointerRegister);
  #else
      if (maxFrameExtentForSlowPathCall)
          jit.addPtr(CCallHelpers::TrustedImm32(-maxFrameExtentForSlowPathCall), CCallHelpers::stackPointerRegister);
<span class="line-modified">!     jit.setupArguments&lt;decltype(slowPathFunction)&gt;(GPRInfo::regT3, GPRInfo::regT2);</span>
      jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(slowPathFunction)), GPRInfo::nonArgGPR0);
      emitPointerValidation(jit, GPRInfo::nonArgGPR0, OperationPtrTag);
      jit.call(GPRInfo::nonArgGPR0, OperationPtrTag);
      if (maxFrameExtentForSlowPathCall)
          jit.addPtr(CCallHelpers::TrustedImm32(maxFrameExtentForSlowPathCall), CCallHelpers::stackPointerRegister);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 182,26 ***</span>
      // FIXME: we should have a story for eliminating these checks. In many cases,
      // the DFG knows that the value is definitely a cell, or definitely a function.
  
  #if USE(JSVALUE64)
      if (callLinkInfo.isTailCall()) {
<span class="line-modified">!         // Tail calls could have clobbered the GPRInfo::tagMaskRegister because they</span>
          // restore callee saved registers before getthing here. So, let&#39;s materialize
<span class="line-modified">!         // the TagMask in a temp register and use the temp instead.</span>
          slowCase.append(jit.branchIfNotCell(GPRInfo::regT0, DoNotHaveTagRegisters));
      } else
          slowCase.append(jit.branchIfNotCell(GPRInfo::regT0));
  #else
      slowCase.append(jit.branchIfNotCell(GPRInfo::regT1));
  #endif
      auto notJSFunction = jit.branchIfNotFunction(GPRInfo::regT0);
  
      // Now we know we have a JSFunction.
  
<span class="line-modified">!     jit.loadPtr(</span>
<span class="line-modified">!         CCallHelpers::Address(GPRInfo::regT0, JSFunction::offsetOfExecutable()),</span>
<span class="line-modified">!         GPRInfo::regT4);</span>
      jit.loadPtr(
          CCallHelpers::Address(
              GPRInfo::regT4, ExecutableBase::offsetOfJITCodeWithArityCheckFor(
                  callLinkInfo.specializationKind())),
          GPRInfo::regT4);
<span class="line-new-header">--- 188,27 ---</span>
      // FIXME: we should have a story for eliminating these checks. In many cases,
      // the DFG knows that the value is definitely a cell, or definitely a function.
  
  #if USE(JSVALUE64)
      if (callLinkInfo.isTailCall()) {
<span class="line-modified">!         // Tail calls could have clobbered the GPRInfo::notCellMaskRegister because they</span>
          // restore callee saved registers before getthing here. So, let&#39;s materialize
<span class="line-modified">!         // the NotCellMask in a temp register and use the temp instead.</span>
          slowCase.append(jit.branchIfNotCell(GPRInfo::regT0, DoNotHaveTagRegisters));
      } else
          slowCase.append(jit.branchIfNotCell(GPRInfo::regT0));
  #else
      slowCase.append(jit.branchIfNotCell(GPRInfo::regT1));
  #endif
      auto notJSFunction = jit.branchIfNotFunction(GPRInfo::regT0);
  
      // Now we know we have a JSFunction.
  
<span class="line-modified">!     jit.loadPtr(CCallHelpers::Address(GPRInfo::regT0, JSFunction::offsetOfExecutableOrRareData()), GPRInfo::regT4);</span>
<span class="line-modified">!     auto hasExecutable = jit.branchTestPtr(CCallHelpers::Zero, GPRInfo::regT4, CCallHelpers::TrustedImm32(JSFunction::rareDataTag));</span>
<span class="line-modified">!     jit.loadPtr(CCallHelpers::Address(GPRInfo::regT4, FunctionRareData::offsetOfExecutable() - JSFunction::rareDataTag), GPRInfo::regT4);</span>
<span class="line-added">+     hasExecutable.link(&amp;jit);</span>
      jit.loadPtr(
          CCallHelpers::Address(
              GPRInfo::regT4, ExecutableBase::offsetOfJITCodeWithArityCheckFor(
                  callLinkInfo.specializationKind())),
          GPRInfo::regT4);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 255,112 ***</span>
          break;
      case EnterViaJumpWithSavedTags:
  #if USE(JSVALUE64)
          // We&#39;re coming from a specialized thunk that has saved the prior tag registers&#39; contents.
          // Restore them now.
<span class="line-modified">!         jit.popPair(JSInterfaceJIT::tagTypeNumberRegister, JSInterfaceJIT::tagMaskRegister);</span>
  #endif
          break;
      case EnterViaJumpWithoutSavedTags:
          jit.move(JSInterfaceJIT::framePointerRegister, JSInterfaceJIT::stackPointerRegister);
          break;
      }
  
      jit.emitPutToCallFrameHeader(0, CallFrameSlot::codeBlock);
<span class="line-modified">!     jit.storePtr(JSInterfaceJIT::callFrameRegister, &amp;vm.topCallFrame);</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if CPU(X86)</span>
<span class="line-removed">-     // Calling convention:      f(ecx, edx, ...);</span>
<span class="line-removed">-     // Host function signature: f(ExecState*);</span>
<span class="line-removed">-     jit.move(JSInterfaceJIT::callFrameRegister, X86Registers::ecx);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     jit.subPtr(JSInterfaceJIT::TrustedImm32(8), JSInterfaceJIT::stackPointerRegister); // Align stack after prologue.</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // call the function</span>
<span class="line-removed">-     jit.emitGetFromCallFrameHeaderPtr(CallFrameSlot::callee, JSInterfaceJIT::regT1);</span>
<span class="line-removed">-     if (thunkFunctionType == ThunkFunctionType::JSFunction) {</span>
<span class="line-removed">-         jit.loadPtr(JSInterfaceJIT::Address(JSInterfaceJIT::regT1, JSFunction::offsetOfExecutable()), JSInterfaceJIT::regT1);</span>
<span class="line-removed">-         jit.call(JSInterfaceJIT::Address(JSInterfaceJIT::regT1, executableOffsetToFunction), JSEntryPtrTag);</span>
<span class="line-removed">-     } else</span>
<span class="line-removed">-         jit.call(JSInterfaceJIT::Address(JSInterfaceJIT::regT1, InternalFunction::offsetOfNativeFunctionFor(kind)), JSEntryPtrTag);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     jit.addPtr(JSInterfaceJIT::TrustedImm32(8), JSInterfaceJIT::stackPointerRegister);</span>
<span class="line-removed">- </span>
<span class="line-removed">- #elif CPU(X86_64)</span>
<span class="line-removed">- #if !OS(WINDOWS)</span>
<span class="line-removed">-     // Calling convention:      f(edi, esi, edx, ecx, ...);</span>
<span class="line-removed">-     // Host function signature: f(ExecState*);</span>
<span class="line-removed">-     jit.move(JSInterfaceJIT::callFrameRegister, X86Registers::edi);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     jit.emitGetFromCallFrameHeaderPtr(CallFrameSlot::callee, X86Registers::esi);</span>
<span class="line-removed">-     if (thunkFunctionType == ThunkFunctionType::JSFunction) {</span>
<span class="line-removed">-         jit.loadPtr(JSInterfaceJIT::Address(X86Registers::esi, JSFunction::offsetOfExecutable()), X86Registers::r9);</span>
<span class="line-removed">-         jit.loadPtr(JSInterfaceJIT::Address(X86Registers::r9, executableOffsetToFunction), X86Registers::r9);</span>
<span class="line-removed">-     } else</span>
<span class="line-removed">-         jit.loadPtr(JSInterfaceJIT::Address(X86Registers::esi, InternalFunction::offsetOfNativeFunctionFor(kind)), X86Registers::r9);</span>
<span class="line-removed">-     jit.call(X86Registers::r9, JSEntryPtrTag);</span>
<span class="line-removed">- </span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     // Calling convention:      f(ecx, edx, r8, r9, ...);</span>
<span class="line-removed">-     // Host function signature: f(ExecState*);</span>
<span class="line-removed">-     jit.move(JSInterfaceJIT::callFrameRegister, X86Registers::ecx);</span>
  
      // Leave space for the callee parameter home addresses.
      // At this point the stack is aligned to 16 bytes, but if this changes at some point, we need to emit code to align it.
<span class="line-modified">!     jit.subPtr(JSInterfaceJIT::TrustedImm32(4 * sizeof(int64_t)), JSInterfaceJIT::stackPointerRegister);</span>
<span class="line-modified">! </span>
<span class="line-removed">-     jit.emitGetFromCallFrameHeaderPtr(CallFrameSlot::callee, X86Registers::edx);</span>
<span class="line-removed">-     if (thunkFunctionType == ThunkFunctionType::JSFunction) {</span>
<span class="line-removed">-         jit.loadPtr(JSInterfaceJIT::Address(X86Registers::edx, JSFunction::offsetOfExecutable()), X86Registers::r9);</span>
<span class="line-removed">-         jit.call(JSInterfaceJIT::Address(X86Registers::r9, executableOffsetToFunction), JSEntryPtrTag);</span>
<span class="line-removed">-     } else</span>
<span class="line-removed">-         jit.call(JSInterfaceJIT::Address(X86Registers::edx, InternalFunction::offsetOfNativeFunctionFor(kind)), JSEntryPtrTag);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     jit.addPtr(JSInterfaceJIT::TrustedImm32(4 * sizeof(int64_t)), JSInterfaceJIT::stackPointerRegister);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">- #elif CPU(ARM64)</span>
<span class="line-removed">-     COMPILE_ASSERT(ARM64Registers::x0 != JSInterfaceJIT::regT3, T3_not_trampled_by_arg_0);</span>
<span class="line-removed">-     COMPILE_ASSERT(ARM64Registers::x1 != JSInterfaceJIT::regT3, T3_not_trampled_by_arg_1);</span>
<span class="line-removed">-     COMPILE_ASSERT(ARM64Registers::x2 != JSInterfaceJIT::regT3, T3_not_trampled_by_arg_2);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Host function signature: f(ExecState*);</span>
<span class="line-removed">-     jit.move(JSInterfaceJIT::callFrameRegister, ARM64Registers::x0);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     jit.emitGetFromCallFrameHeaderPtr(CallFrameSlot::callee, ARM64Registers::x1);</span>
<span class="line-removed">-     if (thunkFunctionType == ThunkFunctionType::JSFunction) {</span>
<span class="line-removed">-         jit.loadPtr(JSInterfaceJIT::Address(ARM64Registers::x1, JSFunction::offsetOfExecutable()), ARM64Registers::x2);</span>
<span class="line-removed">-         jit.loadPtr(JSInterfaceJIT::Address(ARM64Registers::x2, executableOffsetToFunction), ARM64Registers::x2);</span>
<span class="line-removed">-     } else</span>
<span class="line-removed">-         jit.loadPtr(JSInterfaceJIT::Address(ARM64Registers::x1, InternalFunction::offsetOfNativeFunctionFor(kind)), ARM64Registers::x2);</span>
<span class="line-removed">-     jit.call(ARM64Registers::x2, JSEntryPtrTag);</span>
<span class="line-removed">- </span>
<span class="line-removed">- #elif CPU(ARM_THUMB2) || CPU(MIPS)</span>
<span class="line-removed">- #if CPU(MIPS)</span>
      // Allocate stack space for (unused) 16 bytes (8-byte aligned) for 4 arguments.
<span class="line-modified">!     jit.subPtr(JSInterfaceJIT::TrustedImm32(16), JSInterfaceJIT::stackPointerRegister);</span>
  #endif
  
<span class="line-modified">!     // Calling convention is f(argumentGPR0, argumentGPR1, ...).</span>
<span class="line-modified">!     // Host function signature is f(ExecState*).</span>
<span class="line-removed">-     jit.move(JSInterfaceJIT::callFrameRegister, JSInterfaceJIT::argumentGPR0);</span>
  
<span class="line-removed">-     jit.emitGetFromCallFrameHeaderPtr(CallFrameSlot::callee, JSInterfaceJIT::argumentGPR1);</span>
      if (thunkFunctionType == ThunkFunctionType::JSFunction) {
<span class="line-modified">!         jit.loadPtr(JSInterfaceJIT::Address(JSInterfaceJIT::argumentGPR1, JSFunction::offsetOfExecutable()), JSInterfaceJIT::regT2);</span>
<span class="line-modified">!         jit.call(JSInterfaceJIT::Address(JSInterfaceJIT::regT2, executableOffsetToFunction), JSEntryPtrTag);</span>
<span class="line-modified">!     } else</span>
<span class="line-modified">!         jit.call(JSInterfaceJIT::Address(JSInterfaceJIT::argumentGPR1, InternalFunction::offsetOfNativeFunctionFor(kind)), JSEntryPtrTag);</span>
  
<span class="line-modified">! #if CPU(MIPS)</span>
<span class="line-modified">!     // Restore stack space</span>
<span class="line-modified">!     jit.addPtr(JSInterfaceJIT::TrustedImm32(16), JSInterfaceJIT::stackPointerRegister);</span>
<span class="line-modified">! #endif</span>
<span class="line-removed">- #else</span>
<span class="line-removed">- #error &quot;JIT not supported on this platform.&quot;</span>
<span class="line-removed">-     UNUSED_PARAM(executableOffsetToFunction);</span>
<span class="line-removed">-     abortWithReason(TGNotSupported);</span>
  #endif
  
      // Check for an exception
  #if USE(JSVALUE64)
      jit.load64(vm.addressOfException(), JSInterfaceJIT::regT2);
<span class="line-new-header">--- 262,51 ---</span>
          break;
      case EnterViaJumpWithSavedTags:
  #if USE(JSVALUE64)
          // We&#39;re coming from a specialized thunk that has saved the prior tag registers&#39; contents.
          // Restore them now.
<span class="line-modified">!         jit.popPair(JSInterfaceJIT::numberTagRegister, JSInterfaceJIT::notCellMaskRegister);</span>
  #endif
          break;
      case EnterViaJumpWithoutSavedTags:
          jit.move(JSInterfaceJIT::framePointerRegister, JSInterfaceJIT::stackPointerRegister);
          break;
      }
  
      jit.emitPutToCallFrameHeader(0, CallFrameSlot::codeBlock);
<span class="line-modified">!     jit.storePtr(GPRInfo::callFrameRegister, &amp;vm.topCallFrame);</span>
  
<span class="line-added">+     // Host function signature: f(JSGlobalObject*, CallFrame*);</span>
<span class="line-added">+ #if CPU(X86_64) &amp;&amp; OS(WINDOWS)</span>
      // Leave space for the callee parameter home addresses.
      // At this point the stack is aligned to 16 bytes, but if this changes at some point, we need to emit code to align it.
<span class="line-modified">!     jit.subPtr(CCallHelpers::TrustedImm32(4 * sizeof(int64_t)), CCallHelpers::stackPointerRegister);</span>
<span class="line-modified">! #elif CPU(MIPS)</span>
      // Allocate stack space for (unused) 16 bytes (8-byte aligned) for 4 arguments.
<span class="line-modified">!     jit.subPtr(CCallHelpers::TrustedImm32(16), CCallHelpers::stackPointerRegister);</span>
  #endif
  
<span class="line-modified">!     jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR1);</span>
<span class="line-modified">!     jit.emitGetFromCallFrameHeaderPtr(CallFrameSlot::callee, GPRInfo::argumentGPR2);</span>
  
      if (thunkFunctionType == ThunkFunctionType::JSFunction) {
<span class="line-modified">!         jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR2, JSFunction::offsetOfScopeChain()), GPRInfo::argumentGPR0);</span>
<span class="line-modified">!         jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR2, JSFunction::offsetOfExecutableOrRareData()), GPRInfo::argumentGPR2);</span>
<span class="line-modified">!         auto hasExecutable = jit.branchTestPtr(CCallHelpers::Zero, GPRInfo::argumentGPR2, CCallHelpers::TrustedImm32(JSFunction::rareDataTag));</span>
<span class="line-modified">!         jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR2, FunctionRareData::offsetOfExecutable() - JSFunction::rareDataTag), GPRInfo::argumentGPR2);</span>
<span class="line-added">+         hasExecutable.link(&amp;jit);</span>
<span class="line-added">+         jit.call(CCallHelpers::Address(GPRInfo::argumentGPR2, executableOffsetToFunction), JSEntryPtrTag);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         ASSERT(thunkFunctionType == ThunkFunctionType::InternalFunction);</span>
<span class="line-added">+         jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR2, InternalFunction::offsetOfGlobalObject()), GPRInfo::argumentGPR0);</span>
<span class="line-added">+         jit.call(CCallHelpers::Address(GPRInfo::argumentGPR2, InternalFunction::offsetOfNativeFunctionFor(kind)), JSEntryPtrTag);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">! #if CPU(X86_64) &amp;&amp; OS(WINDOWS)</span>
<span class="line-modified">!     jit.addPtr(CCallHelpers::TrustedImm32(4 * sizeof(int64_t)), CCallHelpers::stackPointerRegister);</span>
<span class="line-modified">! #elif CPU(MIPS)</span>
<span class="line-modified">!     jit.addPtr(CCallHelpers::TrustedImm32(16), CCallHelpers::stackPointerRegister);</span>
  #endif
  
      // Check for an exception
  #if USE(JSVALUE64)
      jit.load64(vm.addressOfException(), JSInterfaceJIT::regT2);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 379,28 ***</span>
      // Handle an exception
      exceptionHandler.link(&amp;jit);
  
      jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm.topEntryFrame);
      jit.storePtr(JSInterfaceJIT::callFrameRegister, &amp;vm.topCallFrame);
<span class="line-removed">- </span>
<span class="line-removed">- #if CPU(X86) &amp;&amp; USE(JSVALUE32_64)</span>
<span class="line-removed">-     jit.subPtr(JSInterfaceJIT::TrustedImm32(4), JSInterfaceJIT::stackPointerRegister);</span>
<span class="line-removed">-     jit.move(JSInterfaceJIT::callFrameRegister, JSInterfaceJIT::regT0);</span>
<span class="line-removed">-     jit.push(JSInterfaceJIT::regT0);</span>
<span class="line-removed">- #else</span>
  #if OS(WINDOWS)
      // Allocate space on stack for the 4 parameter registers.
      jit.subPtr(JSInterfaceJIT::TrustedImm32(4 * sizeof(int64_t)), JSInterfaceJIT::stackPointerRegister);
  #endif
<span class="line-modified">!     jit.move(JSInterfaceJIT::callFrameRegister, JSInterfaceJIT::argumentGPR0);</span>
<span class="line-removed">- #endif</span>
      jit.move(JSInterfaceJIT::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(operationVMHandleException)), JSInterfaceJIT::regT3);
      jit.call(JSInterfaceJIT::regT3, OperationPtrTag);
<span class="line-modified">! #if CPU(X86) &amp;&amp; USE(JSVALUE32_64)</span>
<span class="line-removed">-     jit.addPtr(JSInterfaceJIT::TrustedImm32(8), JSInterfaceJIT::stackPointerRegister);</span>
<span class="line-removed">- #elif OS(WINDOWS)</span>
      jit.addPtr(JSInterfaceJIT::TrustedImm32(4 * sizeof(int64_t)), JSInterfaceJIT::stackPointerRegister);
  #endif
  
      jit.jumpToExceptionHandler(vm);
  
      LinkBuffer patchBuffer(jit, GLOBAL_THUNK_ID);
<span class="line-new-header">--- 325,24 ---</span>
      // Handle an exception
      exceptionHandler.link(&amp;jit);
  
      jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm.topEntryFrame);
      jit.storePtr(JSInterfaceJIT::callFrameRegister, &amp;vm.topCallFrame);
  #if OS(WINDOWS)
      // Allocate space on stack for the 4 parameter registers.
      jit.subPtr(JSInterfaceJIT::TrustedImm32(4 * sizeof(int64_t)), JSInterfaceJIT::stackPointerRegister);
<span class="line-added">+ #elif CPU(MIPS)</span>
<span class="line-added">+     // Allocate stack space for (unused) 16 bytes (8-byte aligned) for 4 arguments.</span>
<span class="line-added">+     jit.subPtr(CCallHelpers::TrustedImm32(16), CCallHelpers::stackPointerRegister);</span>
  #endif
<span class="line-modified">!     jit.move(CCallHelpers::TrustedImmPtr(&amp;vm), JSInterfaceJIT::argumentGPR0);</span>
      jit.move(JSInterfaceJIT::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(operationVMHandleException)), JSInterfaceJIT::regT3);
      jit.call(JSInterfaceJIT::regT3, OperationPtrTag);
<span class="line-modified">! #if OS(WINDOWS)</span>
      jit.addPtr(JSInterfaceJIT::TrustedImm32(4 * sizeof(int64_t)), JSInterfaceJIT::stackPointerRegister);
<span class="line-added">+ #elif CPU(MIPS)</span>
<span class="line-added">+     jit.addPtr(CCallHelpers::TrustedImm32(16), CCallHelpers::stackPointerRegister);</span>
  #endif
  
      jit.jumpToExceptionHandler(vm);
  
      LinkBuffer patchBuffer(jit, GLOBAL_THUNK_ID);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 461,18 ***</span>
      jit.move(JSInterfaceJIT::TrustedImmPtr(tempReturnPCTag), extraTemp);
      jit.tagPtr(extraTemp, GPRInfo::regT3);
      jit.storePtr(GPRInfo::regT3, JSInterfaceJIT::Address(GPRInfo::callFrameRegister, CallFrame::returnPCOffset()));
  #endif
      jit.move(JSInterfaceJIT::callFrameRegister, JSInterfaceJIT::regT3);
<span class="line-modified">!     jit.load32(JSInterfaceJIT::addressFor(CallFrameSlot::argumentCount), JSInterfaceJIT::argumentGPR2);</span>
      jit.add32(JSInterfaceJIT::TrustedImm32(CallFrame::headerSizeInRegisters), JSInterfaceJIT::argumentGPR2);
  
      // Check to see if we have extra slots we can use
      jit.move(JSInterfaceJIT::argumentGPR0, JSInterfaceJIT::argumentGPR1);
      jit.and32(JSInterfaceJIT::TrustedImm32(stackAlignmentRegisters() - 1), JSInterfaceJIT::argumentGPR1);
      JSInterfaceJIT::Jump noExtraSlot = jit.branchTest32(MacroAssembler::Zero, JSInterfaceJIT::argumentGPR1);
<span class="line-modified">!     jit.move(JSInterfaceJIT::TrustedImm64(ValueUndefined), extraTemp);</span>
      JSInterfaceJIT::Label fillExtraSlots(jit.label());
      jit.store64(extraTemp, MacroAssembler::BaseIndex(JSInterfaceJIT::callFrameRegister, JSInterfaceJIT::argumentGPR2, JSInterfaceJIT::TimesEight));
      jit.add32(JSInterfaceJIT::TrustedImm32(1), JSInterfaceJIT::argumentGPR2);
      jit.branchSub32(JSInterfaceJIT::NonZero, JSInterfaceJIT::TrustedImm32(1), JSInterfaceJIT::argumentGPR1).linkTo(fillExtraSlots, &amp;jit);
      jit.and32(JSInterfaceJIT::TrustedImm32(-stackAlignmentRegisters()), JSInterfaceJIT::argumentGPR0);
<span class="line-new-header">--- 403,18 ---</span>
      jit.move(JSInterfaceJIT::TrustedImmPtr(tempReturnPCTag), extraTemp);
      jit.tagPtr(extraTemp, GPRInfo::regT3);
      jit.storePtr(GPRInfo::regT3, JSInterfaceJIT::Address(GPRInfo::callFrameRegister, CallFrame::returnPCOffset()));
  #endif
      jit.move(JSInterfaceJIT::callFrameRegister, JSInterfaceJIT::regT3);
<span class="line-modified">!     jit.load32(JSInterfaceJIT::addressFor(CallFrameSlot::argumentCountIncludingThis), JSInterfaceJIT::argumentGPR2);</span>
      jit.add32(JSInterfaceJIT::TrustedImm32(CallFrame::headerSizeInRegisters), JSInterfaceJIT::argumentGPR2);
  
      // Check to see if we have extra slots we can use
      jit.move(JSInterfaceJIT::argumentGPR0, JSInterfaceJIT::argumentGPR1);
      jit.and32(JSInterfaceJIT::TrustedImm32(stackAlignmentRegisters() - 1), JSInterfaceJIT::argumentGPR1);
      JSInterfaceJIT::Jump noExtraSlot = jit.branchTest32(MacroAssembler::Zero, JSInterfaceJIT::argumentGPR1);
<span class="line-modified">!     jit.move(JSInterfaceJIT::TrustedImm64(JSValue::ValueUndefined), extraTemp);</span>
      JSInterfaceJIT::Label fillExtraSlots(jit.label());
      jit.store64(extraTemp, MacroAssembler::BaseIndex(JSInterfaceJIT::callFrameRegister, JSInterfaceJIT::argumentGPR2, JSInterfaceJIT::TimesEight));
      jit.add32(JSInterfaceJIT::TrustedImm32(1), JSInterfaceJIT::argumentGPR2);
      jit.branchSub32(JSInterfaceJIT::NonZero, JSInterfaceJIT::TrustedImm32(1), JSInterfaceJIT::argumentGPR1).linkTo(fillExtraSlots, &amp;jit);
      jit.and32(JSInterfaceJIT::TrustedImm32(-stackAlignmentRegisters()), JSInterfaceJIT::argumentGPR0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 499,11 ***</span>
      jit.addPtr(JSInterfaceJIT::TrustedImm32(8), JSInterfaceJIT::regT3);
      jit.branchSub32(MacroAssembler::NonZero, JSInterfaceJIT::TrustedImm32(1), JSInterfaceJIT::argumentGPR2).linkTo(copyLoop, &amp;jit);
  
      // Fill in argumentGPR0 missing arg slots with undefined
      jit.move(JSInterfaceJIT::argumentGPR0, JSInterfaceJIT::argumentGPR2);
<span class="line-modified">!     jit.move(JSInterfaceJIT::TrustedImm64(ValueUndefined), extraTemp);</span>
      JSInterfaceJIT::Label fillUndefinedLoop(jit.label());
      jit.store64(extraTemp, MacroAssembler::BaseIndex(JSInterfaceJIT::regT3, JSInterfaceJIT::argumentGPR0, JSInterfaceJIT::TimesEight));
      jit.addPtr(JSInterfaceJIT::TrustedImm32(8), JSInterfaceJIT::regT3);
      jit.branchAdd32(MacroAssembler::NonZero, JSInterfaceJIT::TrustedImm32(1), JSInterfaceJIT::argumentGPR2).linkTo(fillUndefinedLoop, &amp;jit);
  
<span class="line-new-header">--- 441,11 ---</span>
      jit.addPtr(JSInterfaceJIT::TrustedImm32(8), JSInterfaceJIT::regT3);
      jit.branchSub32(MacroAssembler::NonZero, JSInterfaceJIT::TrustedImm32(1), JSInterfaceJIT::argumentGPR2).linkTo(copyLoop, &amp;jit);
  
      // Fill in argumentGPR0 missing arg slots with undefined
      jit.move(JSInterfaceJIT::argumentGPR0, JSInterfaceJIT::argumentGPR2);
<span class="line-modified">!     jit.move(JSInterfaceJIT::TrustedImm64(JSValue::ValueUndefined), extraTemp);</span>
      JSInterfaceJIT::Label fillUndefinedLoop(jit.label());
      jit.store64(extraTemp, MacroAssembler::BaseIndex(JSInterfaceJIT::regT3, JSInterfaceJIT::argumentGPR0, JSInterfaceJIT::TimesEight));
      jit.addPtr(JSInterfaceJIT::TrustedImm32(8), JSInterfaceJIT::regT3);
      jit.branchAdd32(MacroAssembler::NonZero, JSInterfaceJIT::TrustedImm32(1), JSInterfaceJIT::argumentGPR2).linkTo(fillUndefinedLoop, &amp;jit);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 521,15 ***</span>
  #  if CPU(X86_64)
      jit.push(JSInterfaceJIT::regT4);
  #  endif
      jit.ret();
  #else // USE(JSVALUE64) section above, USE(JSVALUE32_64) section below.
<span class="line-removed">- #  if CPU(X86)</span>
<span class="line-removed">-     jit.pop(JSInterfaceJIT::regT4);</span>
<span class="line-removed">- #  endif</span>
      jit.move(JSInterfaceJIT::callFrameRegister, JSInterfaceJIT::regT3);
<span class="line-modified">!     jit.load32(JSInterfaceJIT::addressFor(CallFrameSlot::argumentCount), JSInterfaceJIT::argumentGPR2);</span>
      jit.add32(JSInterfaceJIT::TrustedImm32(CallFrame::headerSizeInRegisters), JSInterfaceJIT::argumentGPR2);
  
      // Check to see if we have extra slots we can use
      jit.move(JSInterfaceJIT::argumentGPR0, JSInterfaceJIT::argumentGPR1);
      jit.and32(JSInterfaceJIT::TrustedImm32(stackAlignmentRegisters() - 1), JSInterfaceJIT::argumentGPR1);
<span class="line-new-header">--- 463,12 ---</span>
  #  if CPU(X86_64)
      jit.push(JSInterfaceJIT::regT4);
  #  endif
      jit.ret();
  #else // USE(JSVALUE64) section above, USE(JSVALUE32_64) section below.
      jit.move(JSInterfaceJIT::callFrameRegister, JSInterfaceJIT::regT3);
<span class="line-modified">!     jit.load32(JSInterfaceJIT::addressFor(CallFrameSlot::argumentCountIncludingThis), JSInterfaceJIT::argumentGPR2);</span>
      jit.add32(JSInterfaceJIT::TrustedImm32(CallFrame::headerSizeInRegisters), JSInterfaceJIT::argumentGPR2);
  
      // Check to see if we have extra slots we can use
      jit.move(JSInterfaceJIT::argumentGPR0, JSInterfaceJIT::argumentGPR1);
      jit.and32(JSInterfaceJIT::TrustedImm32(stackAlignmentRegisters() - 1), JSInterfaceJIT::argumentGPR1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 578,13 ***</span>
      jit.addPtr(JSInterfaceJIT::TrustedImm32(8), JSInterfaceJIT::regT3);
      jit.branchAdd32(MacroAssembler::NonZero, JSInterfaceJIT::TrustedImm32(1), JSInterfaceJIT::argumentGPR2).linkTo(fillUndefinedLoop, &amp;jit);
  
      done.link(&amp;jit);
  
<span class="line-removed">- #  if CPU(X86)</span>
<span class="line-removed">-     jit.push(JSInterfaceJIT::regT4);</span>
<span class="line-removed">- #  endif</span>
      jit.ret();
  #endif // End of USE(JSVALUE32_64) section.
  
      LinkBuffer patchBuffer(jit, GLOBAL_THUNK_ID);
      return FINALIZE_CODE(patchBuffer, JITThunkPtrTag, &quot;fixup arity&quot;);
<span class="line-new-header">--- 517,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 625,16 ***</span>
  
      // Do an unsigned compare to simultaneously filter negative indices as well as indices that are too large
      failures.append(jit.branch32(JSInterfaceJIT::AboveOrEqual, indexGPR, scratchGPR));
  
      // Load the character
<span class="line-removed">-     JSInterfaceJIT::JumpList is16Bit;</span>
      JSInterfaceJIT::JumpList cont8Bit;
      // Load the string flags
      jit.load32(JSInterfaceJIT::Address(stringGPR, StringImpl::flagsOffset()), scratchGPR);
      jit.loadPtr(JSInterfaceJIT::Address(stringGPR, StringImpl::dataOffset()), stringGPR);
<span class="line-modified">!     is16Bit.append(jit.branchTest32(JSInterfaceJIT::Zero, scratchGPR, JSInterfaceJIT::TrustedImm32(StringImpl::flagIs8Bit())));</span>
      jit.load8(JSInterfaceJIT::BaseIndex(stringGPR, indexGPR, JSInterfaceJIT::TimesOne, 0), stringGPR);
      cont8Bit.append(jit.jump());
      is16Bit.link(&amp;jit);
      jit.load16(JSInterfaceJIT::BaseIndex(stringGPR, indexGPR, JSInterfaceJIT::TimesTwo, 0), stringGPR);
      cont8Bit.link(&amp;jit);
<span class="line-new-header">--- 561,15 ---</span>
  
      // Do an unsigned compare to simultaneously filter negative indices as well as indices that are too large
      failures.append(jit.branch32(JSInterfaceJIT::AboveOrEqual, indexGPR, scratchGPR));
  
      // Load the character
      JSInterfaceJIT::JumpList cont8Bit;
      // Load the string flags
      jit.load32(JSInterfaceJIT::Address(stringGPR, StringImpl::flagsOffset()), scratchGPR);
      jit.loadPtr(JSInterfaceJIT::Address(stringGPR, StringImpl::dataOffset()), stringGPR);
<span class="line-modified">!     auto is16Bit = jit.branchTest32(JSInterfaceJIT::Zero, scratchGPR, JSInterfaceJIT::TrustedImm32(StringImpl::flagIs8Bit()));</span>
      jit.load8(JSInterfaceJIT::BaseIndex(stringGPR, indexGPR, JSInterfaceJIT::TimesOne, 0), stringGPR);
      cont8Bit.append(jit.jump());
      is16Bit.link(&amp;jit);
      jit.load16(JSInterfaceJIT::BaseIndex(stringGPR, indexGPR, JSInterfaceJIT::TimesTwo, 0), stringGPR);
      cont8Bit.link(&amp;jit);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 670,11 ***</span>
  
      // Load the character
      SpecializedThunkJIT::JumpList is16Bit;
      SpecializedThunkJIT::JumpList cont8Bit;
      // Load the string flags
<span class="line-modified">!     jit.loadPtr(MacroAssembler::Address(SpecializedThunkJIT::regT0, StringImpl::flagsOffset()), SpecializedThunkJIT::regT2);</span>
      jit.loadPtr(MacroAssembler::Address(SpecializedThunkJIT::regT0, StringImpl::dataOffset()), SpecializedThunkJIT::regT0);
      is16Bit.append(jit.branchTest32(MacroAssembler::Zero, SpecializedThunkJIT::regT2, MacroAssembler::TrustedImm32(StringImpl::flagIs8Bit())));
      jit.load8(MacroAssembler::BaseIndex(SpecializedThunkJIT::regT0, SpecializedThunkJIT::regT1, MacroAssembler::TimesOne, 0), SpecializedThunkJIT::regT0);
      cont8Bit.append(jit.jump());
      is16Bit.link(&amp;jit);
<span class="line-new-header">--- 605,11 ---</span>
  
      // Load the character
      SpecializedThunkJIT::JumpList is16Bit;
      SpecializedThunkJIT::JumpList cont8Bit;
      // Load the string flags
<span class="line-modified">!     jit.load32(MacroAssembler::Address(SpecializedThunkJIT::regT0, StringImpl::flagsOffset()), SpecializedThunkJIT::regT2);</span>
      jit.loadPtr(MacroAssembler::Address(SpecializedThunkJIT::regT0, StringImpl::dataOffset()), SpecializedThunkJIT::regT0);
      is16Bit.append(jit.branchTest32(MacroAssembler::Zero, SpecializedThunkJIT::regT2, MacroAssembler::TrustedImm32(StringImpl::flagIs8Bit())));
      jit.load8(MacroAssembler::BaseIndex(SpecializedThunkJIT::regT0, SpecializedThunkJIT::regT1, MacroAssembler::TimesOne, 0), SpecializedThunkJIT::regT0);
      cont8Bit.append(jit.jump());
      is16Bit.link(&amp;jit);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 715,10 ***</span>
<span class="line-new-header">--- 650,54 ---</span>
      charToString(jit, vm, SpecializedThunkJIT::regT0, SpecializedThunkJIT::regT0, SpecializedThunkJIT::regT1);
      jit.returnJSCell(SpecializedThunkJIT::regT0);
      return jit.finalize(vm.jitStubs-&gt;ctiNativeTailCall(vm), &quot;fromCharCode&quot;);
  }
  
<span class="line-added">+ MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; stringPrototypeCodePointAtThunkGenerator(VM&amp; vm)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     SpecializedThunkJIT jit(vm, 1);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // load string</span>
<span class="line-added">+     jit.loadJSStringArgument(SpecializedThunkJIT::ThisArgument, GPRInfo::regT0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Load string length to regT3, and start the process of loading the data pointer into regT2</span>
<span class="line-added">+     jit.loadPtr(CCallHelpers::Address(GPRInfo::regT0, JSString::offsetOfValue()), GPRInfo::regT0);</span>
<span class="line-added">+     jit.appendFailure(jit.branchIfRopeStringImpl(GPRInfo::regT0));</span>
<span class="line-added">+     jit.load32(CCallHelpers::Address(GPRInfo::regT0, StringImpl::lengthMemoryOffset()), GPRInfo::regT3);</span>
<span class="line-added">+ </span>
<span class="line-added">+     // load index</span>
<span class="line-added">+     jit.loadInt32Argument(0, GPRInfo::regT1); // regT1 contains the index</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Do an unsigned compare to simultaneously filter negative indices as well as indices that are too large</span>
<span class="line-added">+     jit.appendFailure(jit.branch32(CCallHelpers::AboveOrEqual, GPRInfo::regT1, GPRInfo::regT3));</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Load the character</span>
<span class="line-added">+     CCallHelpers::JumpList done;</span>
<span class="line-added">+     // Load the string flags</span>
<span class="line-added">+     jit.loadPtr(CCallHelpers::Address(GPRInfo::regT0, StringImpl::dataOffset()), GPRInfo::regT2);</span>
<span class="line-added">+     auto is16Bit = jit.branchTest32(CCallHelpers::Zero, CCallHelpers::Address(GPRInfo::regT0, StringImpl::flagsOffset()), CCallHelpers::TrustedImm32(StringImpl::flagIs8Bit()));</span>
<span class="line-added">+     jit.load8(CCallHelpers::BaseIndex(GPRInfo::regT2, GPRInfo::regT1, CCallHelpers::TimesOne, 0), GPRInfo::regT0);</span>
<span class="line-added">+     done.append(jit.jump());</span>
<span class="line-added">+ </span>
<span class="line-added">+     is16Bit.link(&amp;jit);</span>
<span class="line-added">+     jit.load16(CCallHelpers::BaseIndex(GPRInfo::regT2, GPRInfo::regT1, CCallHelpers::TimesTwo, 0), GPRInfo::regT0);</span>
<span class="line-added">+     // Original index is int32_t, and here, we ensure that it is positive. If we interpret it as uint32_t, adding 1 never overflows.</span>
<span class="line-added">+     jit.add32(CCallHelpers::TrustedImm32(1), GPRInfo::regT1);</span>
<span class="line-added">+     done.append(jit.branch32(CCallHelpers::AboveOrEqual, GPRInfo::regT1, GPRInfo::regT3));</span>
<span class="line-added">+     jit.and32(CCallHelpers::TrustedImm32(0xfffffc00), GPRInfo::regT0, GPRInfo::regT3);</span>
<span class="line-added">+     done.append(jit.branch32(CCallHelpers::NotEqual, GPRInfo::regT3, CCallHelpers::TrustedImm32(0xd800)));</span>
<span class="line-added">+     jit.load16(CCallHelpers::BaseIndex(GPRInfo::regT2, GPRInfo::regT1, CCallHelpers::TimesTwo, 0), GPRInfo::regT2);</span>
<span class="line-added">+     jit.and32(CCallHelpers::TrustedImm32(0xfffffc00), GPRInfo::regT2, GPRInfo::regT3);</span>
<span class="line-added">+     done.append(jit.branch32(CCallHelpers::NotEqual, GPRInfo::regT3, CCallHelpers::TrustedImm32(0xdc00)));</span>
<span class="line-added">+     jit.lshift32(CCallHelpers::TrustedImm32(10), GPRInfo::regT0);</span>
<span class="line-added">+     jit.getEffectiveAddress(CCallHelpers::BaseIndex(GPRInfo::regT0, GPRInfo::regT2, CCallHelpers::TimesOne, -U16_SURROGATE_OFFSET), GPRInfo::regT0);</span>
<span class="line-added">+     done.link(&amp;jit);</span>
<span class="line-added">+ </span>
<span class="line-added">+     jit.returnInt32(GPRInfo::regT0);</span>
<span class="line-added">+     return jit.finalize(vm.jitStubs-&gt;ctiNativeTailCall(vm), &quot;codePointAt&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; clz32ThunkGenerator(VM&amp; vm)
  {
      SpecializedThunkJIT jit(vm, 1);
      MacroAssembler::Jump nonIntArgJump;
      jit.loadInt32Argument(0, SpecializedThunkJIT::regT0, nonIntArgJump);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 815,11 ***</span>
      extern &quot;C&quot; { \
          MathThunkCallingConvention function##Thunk(MathThunkCallingConvention); \
      } \
      static MathThunk UnaryDoubleOpWrapper(function) = &amp;function##Thunk;
  
<span class="line-modified">! #elif CPU(ARM_THUMB2) &amp;&amp; COMPILER(GCC_COMPATIBLE) &amp;&amp; PLATFORM(IOS_FAMILY)</span>
  
  #define defineUnaryDoubleOpWrapper(function) \
      asm( \
          &quot;.text\n&quot; \
          &quot;.align 2\n&quot; \
<span class="line-new-header">--- 794,11 ---</span>
      extern &quot;C&quot; { \
          MathThunkCallingConvention function##Thunk(MathThunkCallingConvention); \
      } \
      static MathThunk UnaryDoubleOpWrapper(function) = &amp;function##Thunk;
  
<span class="line-modified">! #elif CPU(ARM_THUMB2) &amp;&amp; COMPILER(GCC_COMPATIBLE) &amp;&amp; OS(DARWIN)</span>
  
  #define defineUnaryDoubleOpWrapper(function) \
      asm( \
          &quot;.text\n&quot; \
          &quot;.align 2\n&quot; \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 894,12 ***</span>
  defineUnaryDoubleOpWrapper(log);
  defineUnaryDoubleOpWrapper(floor);
  defineUnaryDoubleOpWrapper(ceil);
  defineUnaryDoubleOpWrapper(trunc);
  
<span class="line-removed">- static const double halfConstant = 0.5;</span>
<span class="line-removed">- </span>
  MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; floorThunkGenerator(VM&amp; vm)
  {
      SpecializedThunkJIT jit(vm, 1);
      MacroAssembler::Jump nonIntJump;
      if (!UnaryDoubleOpWrapper(floor) || !jit.supportsFloatingPoint())
<span class="line-new-header">--- 873,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 995,28 ***</span>
      MacroAssembler::Jump nonIntJump;
      jit.loadInt32Argument(0, SpecializedThunkJIT::regT0, nonIntJump);
      jit.returnInt32(SpecializedThunkJIT::regT0);
      nonIntJump.link(&amp;jit);
      jit.loadDoubleArgument(0, SpecializedThunkJIT::fpRegT0, SpecializedThunkJIT::regT0);
<span class="line-removed">-     SpecializedThunkJIT::Jump intResult;</span>
      SpecializedThunkJIT::JumpList doubleResult;
<span class="line-modified">!     if (jit.supportsFloatingPointTruncate()) {</span>
          jit.moveZeroToDouble(SpecializedThunkJIT::fpRegT1);
          doubleResult.append(jit.branchDouble(MacroAssembler::DoubleEqual, SpecializedThunkJIT::fpRegT0, SpecializedThunkJIT::fpRegT1));
<span class="line-modified">!         SpecializedThunkJIT::JumpList slowPath;</span>
<span class="line-modified">!         // Handle the negative doubles in the slow path for now.</span>
<span class="line-modified">!         slowPath.append(jit.branchDouble(MacroAssembler::DoubleLessThanOrUnordered, SpecializedThunkJIT::fpRegT0, SpecializedThunkJIT::fpRegT1));</span>
<span class="line-modified">!         jit.loadDouble(MacroAssembler::TrustedImmPtr(&amp;halfConstant), SpecializedThunkJIT::fpRegT1);</span>
<span class="line-modified">!         jit.addDouble(SpecializedThunkJIT::fpRegT0, SpecializedThunkJIT::fpRegT1);</span>
<span class="line-modified">!         slowPath.append(jit.branchTruncateDoubleToInt32(SpecializedThunkJIT::fpRegT1, SpecializedThunkJIT::regT0));</span>
<span class="line-modified">!         intResult = jit.jump();</span>
<span class="line-modified">!         slowPath.link(&amp;jit);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     jit.callDoubleToDoublePreservingReturn(UnaryDoubleOpWrapper(jsRound));</span>
      jit.branchConvertDoubleToInt32(SpecializedThunkJIT::fpRegT0, SpecializedThunkJIT::regT0, doubleResult, SpecializedThunkJIT::fpRegT1);
<span class="line-removed">-     if (jit.supportsFloatingPointTruncate())</span>
<span class="line-removed">-         intResult.link(&amp;jit);</span>
      jit.returnInt32(SpecializedThunkJIT::regT0);
      doubleResult.link(&amp;jit);
      jit.returnDouble(SpecializedThunkJIT::fpRegT0);
      return jit.finalize(vm.jitStubs-&gt;ctiNativeTailCall(vm), &quot;round&quot;);
  }
<span class="line-new-header">--- 972,33 ---</span>
      MacroAssembler::Jump nonIntJump;
      jit.loadInt32Argument(0, SpecializedThunkJIT::regT0, nonIntJump);
      jit.returnInt32(SpecializedThunkJIT::regT0);
      nonIntJump.link(&amp;jit);
      jit.loadDoubleArgument(0, SpecializedThunkJIT::fpRegT0, SpecializedThunkJIT::regT0);
      SpecializedThunkJIT::JumpList doubleResult;
<span class="line-modified">!     if (jit.supportsFloatingPointRounding()) {</span>
          jit.moveZeroToDouble(SpecializedThunkJIT::fpRegT1);
          doubleResult.append(jit.branchDouble(MacroAssembler::DoubleEqual, SpecializedThunkJIT::fpRegT0, SpecializedThunkJIT::fpRegT1));
<span class="line-modified">! </span>
<span class="line-modified">!         jit.ceilDouble(SpecializedThunkJIT::fpRegT0, SpecializedThunkJIT::fpRegT1);</span>
<span class="line-modified">!         static constexpr double halfConstant = -0.5;</span>
<span class="line-modified">!         jit.loadDouble(MacroAssembler::TrustedImmPtr(&amp;halfConstant), SpecializedThunkJIT::fpRegT2);</span>
<span class="line-modified">!         jit.addDouble(SpecializedThunkJIT::fpRegT1, SpecializedThunkJIT::fpRegT2);</span>
<span class="line-modified">!         MacroAssembler::Jump shouldRoundDown = jit.branchDouble(MacroAssembler::DoubleGreaterThan, SpecializedThunkJIT::fpRegT2, SpecializedThunkJIT::fpRegT0);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         jit.moveDouble(SpecializedThunkJIT::fpRegT1, SpecializedThunkJIT::fpRegT0);</span>
<span class="line-modified">!         MacroAssembler::Jump continuation = jit.jump();</span>
<span class="line-modified">! </span>
<span class="line-added">+         shouldRoundDown.link(&amp;jit);</span>
<span class="line-added">+         static constexpr double oneConstant = 1.0;</span>
<span class="line-added">+         jit.loadDouble(MacroAssembler::TrustedImmPtr(&amp;oneConstant), SpecializedThunkJIT::fpRegT2);</span>
<span class="line-added">+         jit.subDouble(SpecializedThunkJIT::fpRegT1, SpecializedThunkJIT::fpRegT2, SpecializedThunkJIT::fpRegT0);</span>
<span class="line-added">+ </span>
<span class="line-added">+         continuation.link(&amp;jit);</span>
<span class="line-added">+     } else</span>
<span class="line-added">+         jit.callDoubleToDoublePreservingReturn(UnaryDoubleOpWrapper(jsRound));</span>
      jit.branchConvertDoubleToInt32(SpecializedThunkJIT::fpRegT0, SpecializedThunkJIT::regT0, doubleResult, SpecializedThunkJIT::fpRegT1);
      jit.returnInt32(SpecializedThunkJIT::regT0);
      doubleResult.link(&amp;jit);
      jit.returnDouble(SpecializedThunkJIT::fpRegT0);
      return jit.finalize(vm.jitStubs-&gt;ctiNativeTailCall(vm), &quot;round&quot;);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1052,12 ***</span>
      SpecializedThunkJIT jit(vm, 1);
      if (!jit.supportsFloatingPointAbs())
          return MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt;::createSelfManagedCodeRef(vm.jitStubs-&gt;ctiNativeCall(vm));
  
  #if USE(JSVALUE64)
<span class="line-modified">!     unsigned virtualRegisterIndex = CallFrame::argumentOffset(0);</span>
<span class="line-modified">!     jit.load64(AssemblyHelpers::addressFor(virtualRegisterIndex), GPRInfo::regT0);</span>
      auto notInteger = jit.branchIfNotInt32(GPRInfo::regT0);
  
      // Abs Int32.
      jit.rshift32(GPRInfo::regT0, MacroAssembler::TrustedImm32(31), GPRInfo::regT1);
      jit.add32(GPRInfo::regT1, GPRInfo::regT0);
<span class="line-new-header">--- 1034,12 ---</span>
      SpecializedThunkJIT jit(vm, 1);
      if (!jit.supportsFloatingPointAbs())
          return MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt;::createSelfManagedCodeRef(vm.jitStubs-&gt;ctiNativeCall(vm));
  
  #if USE(JSVALUE64)
<span class="line-modified">!     VirtualRegister virtualRegister = CallFrameSlot::firstArgument;</span>
<span class="line-modified">!     jit.load64(AssemblyHelpers::addressFor(virtualRegister), GPRInfo::regT0);</span>
      auto notInteger = jit.branchIfNotInt32(GPRInfo::regT0);
  
      // Abs Int32.
      jit.rshift32(GPRInfo::regT0, MacroAssembler::TrustedImm32(31), GPRInfo::regT1);
      jit.add32(GPRInfo::regT1, GPRInfo::regT0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1065,11 ***</span>
  
      // IntMin cannot be inverted.
      MacroAssembler::Jump integerIsIntMin = jit.branchTest32(MacroAssembler::Signed, GPRInfo::regT0);
  
      // Box and finish.
<span class="line-modified">!     jit.or64(GPRInfo::tagTypeNumberRegister, GPRInfo::regT0);</span>
      MacroAssembler::Jump doneWithIntegers = jit.jump();
  
      // Handle Doubles.
      notInteger.link(&amp;jit);
      jit.appendFailure(jit.branchIfNotNumber(GPRInfo::regT0));
<span class="line-new-header">--- 1047,11 ---</span>
  
      // IntMin cannot be inverted.
      MacroAssembler::Jump integerIsIntMin = jit.branchTest32(MacroAssembler::Signed, GPRInfo::regT0);
  
      // Box and finish.
<span class="line-modified">!     jit.or64(GPRInfo::numberTagRegister, GPRInfo::regT0);</span>
      MacroAssembler::Jump doneWithIntegers = jit.jump();
  
      // Handle Doubles.
      notInteger.link(&amp;jit);
      jit.appendFailure(jit.branchIfNotNumber(GPRInfo::regT0));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1149,19 ***</span>
  #else
      return MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt;::createSelfManagedCodeRef(vm.jitStubs-&gt;ctiNativeCall(vm));
  #endif
  }
  
<span class="line-modified">! MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; boundThisNoArgsFunctionCallGenerator(VM&amp; vm)</span>
  {
      CCallHelpers jit;
  
      jit.emitFunctionPrologue();
  
      // Set up our call frame.
      jit.storePtr(CCallHelpers::TrustedImmPtr(nullptr), CCallHelpers::addressFor(CallFrameSlot::codeBlock));
<span class="line-modified">!     jit.store32(CCallHelpers::TrustedImm32(0), CCallHelpers::tagFor(CallFrameSlot::argumentCount));</span>
  
      unsigned extraStackNeeded = 0;
      if (unsigned stackMisalignment = sizeof(CallerFrameAndPC) % stackAlignmentBytes())
          extraStackNeeded = stackAlignmentBytes() - stackMisalignment;
  
<span class="line-new-header">--- 1131,19 ---</span>
  #else
      return MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt;::createSelfManagedCodeRef(vm.jitStubs-&gt;ctiNativeCall(vm));
  #endif
  }
  
<span class="line-modified">! MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; boundFunctionCallGenerator(VM&amp; vm)</span>
  {
      CCallHelpers jit;
  
      jit.emitFunctionPrologue();
  
      // Set up our call frame.
      jit.storePtr(CCallHelpers::TrustedImmPtr(nullptr), CCallHelpers::addressFor(CallFrameSlot::codeBlock));
<span class="line-modified">!     jit.store32(CCallHelpers::TrustedImm32(0), CCallHelpers::tagFor(CallFrameSlot::argumentCountIncludingThis));</span>
  
      unsigned extraStackNeeded = 0;
      if (unsigned stackMisalignment = sizeof(CallerFrameAndPC) % stackAlignmentBytes())
          extraStackNeeded = stackAlignmentBytes() - stackMisalignment;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1178,67 ***</span>
      //
      //     stackAlign((numParams + (CallFrameHeaderSize - CallerFrameAndPCSize)) * sizeof(Register))
      //
      // That&#39;s really all there is to this. We have all the registers we need to do it.
  
<span class="line-modified">!     jit.load32(CCallHelpers::payloadFor(CallFrameSlot::argumentCount), GPRInfo::regT1);</span>
      jit.add32(CCallHelpers::TrustedImm32(CallFrame::headerSizeInRegisters - CallerFrameAndPC::sizeInRegisters), GPRInfo::regT1, GPRInfo::regT2);
      jit.lshift32(CCallHelpers::TrustedImm32(3), GPRInfo::regT2);
      jit.add32(CCallHelpers::TrustedImm32(stackAlignmentBytes() - 1), GPRInfo::regT2);
      jit.and32(CCallHelpers::TrustedImm32(-stackAlignmentBytes()), GPRInfo::regT2);
  
      if (extraStackNeeded)
          jit.add32(CCallHelpers::TrustedImm32(extraStackNeeded), GPRInfo::regT2);
  
<span class="line-modified">!     // At this point regT1 has the actual argument count and regT2 has the amount of stack we will need.</span>
      // Check to see if we have enough stack space.
  
      jit.negPtr(GPRInfo::regT2);
      jit.addPtr(CCallHelpers::stackPointerRegister, GPRInfo::regT2);
      CCallHelpers::Jump haveStackSpace = jit.branchPtr(CCallHelpers::BelowOrEqual, CCallHelpers::AbsoluteAddress(vm.addressOfSoftStackLimit()), GPRInfo::regT2);
  
      // Throw Stack Overflow exception
      jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm.topEntryFrame);
<span class="line-modified">!     jit.setupArguments&lt;decltype(throwStackOverflowErrorFromThunk)&gt;(CCallHelpers::TrustedImmPtr(&amp;vm), GPRInfo::callFrameRegister);</span>
<span class="line-modified">!     jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(throwStackOverflowErrorFromThunk)), GPRInfo::nonArgGPR0);</span>
      emitPointerValidation(jit, GPRInfo::nonArgGPR0, OperationPtrTag);
      jit.call(GPRInfo::nonArgGPR0, OperationPtrTag);
      jit.jumpToExceptionHandler(vm);
  
      haveStackSpace.link(&amp;jit);
      jit.move(GPRInfo::regT2, CCallHelpers::stackPointerRegister);
  
      // Do basic callee frame setup, including &#39;this&#39;.
  
<span class="line-modified">!     jit.loadCell(CCallHelpers::addressFor(CallFrameSlot::callee), GPRInfo::regT3);</span>
  
<span class="line-modified">!     jit.store32(GPRInfo::regT1, CCallHelpers::calleeFramePayloadSlot(CallFrameSlot::argumentCount));</span>
<span class="line-modified">! </span>
<span class="line-removed">-     JSValueRegs valueRegs = JSValueRegs::withTwoAvailableRegs(GPRInfo::regT0, GPRInfo::regT2);</span>
<span class="line-removed">-     jit.loadValue(CCallHelpers::Address(GPRInfo::regT3, JSBoundFunction::offsetOfBoundThis()), valueRegs);</span>
      jit.storeValue(valueRegs, CCallHelpers::calleeArgumentSlot(0));
  
<span class="line-removed">-     jit.loadPtr(CCallHelpers::Address(GPRInfo::regT3, JSBoundFunction::offsetOfTargetFunction()), GPRInfo::regT3);</span>
<span class="line-removed">-     jit.storeCell(GPRInfo::regT3, CCallHelpers::calleeFrameSlot(CallFrameSlot::callee));</span>
<span class="line-removed">- </span>
      // OK, now we can start copying. This is a simple matter of copying parameters from the caller&#39;s
<span class="line-modified">!     // frame to the callee&#39;s frame. Note that we know that regT1 (the argument count) must be at</span>
      // least 1.
      jit.sub32(CCallHelpers::TrustedImm32(1), GPRInfo::regT1);
<span class="line-modified">!     CCallHelpers::Jump done = jit.branchTest32(CCallHelpers::Zero, GPRInfo::regT1);</span>
  
      CCallHelpers::Label loop = jit.label();
      jit.sub32(CCallHelpers::TrustedImm32(1), GPRInfo::regT1);
<span class="line-modified">!     jit.loadValue(CCallHelpers::addressFor(virtualRegisterForArgument(1)).indexedBy(GPRInfo::regT1, CCallHelpers::TimesEight), valueRegs);</span>
      jit.storeValue(valueRegs, CCallHelpers::calleeArgumentSlot(1).indexedBy(GPRInfo::regT1, CCallHelpers::TimesEight));
<span class="line-modified">!     jit.branchTest32(CCallHelpers::NonZero, GPRInfo::regT1).linkTo(loop, &amp;jit);</span>
  
      done.link(&amp;jit);
  
<span class="line-removed">-     jit.loadPtr(</span>
<span class="line-removed">-         CCallHelpers::Address(GPRInfo::regT3, JSFunction::offsetOfExecutable()),</span>
<span class="line-removed">-         GPRInfo::regT0);</span>
      jit.loadPtr(
          CCallHelpers::Address(
              GPRInfo::regT0, ExecutableBase::offsetOfJITCodeWithArityCheckFor(CodeForCall)),
          GPRInfo::regT0);
      CCallHelpers::Jump noCode = jit.branchTestPtr(CCallHelpers::Zero, GPRInfo::regT0);
<span class="line-new-header">--- 1160,90 ---</span>
      //
      //     stackAlign((numParams + (CallFrameHeaderSize - CallerFrameAndPCSize)) * sizeof(Register))
      //
      // That&#39;s really all there is to this. We have all the registers we need to do it.
  
<span class="line-modified">!     jit.loadCell(CCallHelpers::addressFor(CallFrameSlot::callee), GPRInfo::regT0);</span>
<span class="line-added">+     jit.loadPtr(CCallHelpers::Address(GPRInfo::regT0, JSBoundFunction::offsetOfBoundArgs()), GPRInfo::regT2);</span>
<span class="line-added">+     jit.load32(CCallHelpers::payloadFor(CallFrameSlot::argumentCountIncludingThis), GPRInfo::regT1);</span>
<span class="line-added">+     jit.move(GPRInfo::regT1, GPRInfo::regT3);</span>
<span class="line-added">+     auto noArgs = jit.branchTestPtr(CCallHelpers::Zero, GPRInfo::regT2);</span>
<span class="line-added">+     jit.load32(CCallHelpers::Address(GPRInfo::regT2, JSImmutableButterfly::offsetOfPublicLength()), GPRInfo::regT2);</span>
<span class="line-added">+     jit.add32(GPRInfo::regT2, GPRInfo::regT1);</span>
<span class="line-added">+     jit.sub32(CCallHelpers::TrustedImm32(1), GPRInfo::regT1);</span>
<span class="line-added">+     noArgs.link(&amp;jit);</span>
      jit.add32(CCallHelpers::TrustedImm32(CallFrame::headerSizeInRegisters - CallerFrameAndPC::sizeInRegisters), GPRInfo::regT1, GPRInfo::regT2);
      jit.lshift32(CCallHelpers::TrustedImm32(3), GPRInfo::regT2);
      jit.add32(CCallHelpers::TrustedImm32(stackAlignmentBytes() - 1), GPRInfo::regT2);
      jit.and32(CCallHelpers::TrustedImm32(-stackAlignmentBytes()), GPRInfo::regT2);
  
      if (extraStackNeeded)
          jit.add32(CCallHelpers::TrustedImm32(extraStackNeeded), GPRInfo::regT2);
  
<span class="line-modified">!     // At this point regT1 has the actual argument count, regT2 has the amount of stack we will need, and regT3 has the passed argument count.</span>
      // Check to see if we have enough stack space.
  
      jit.negPtr(GPRInfo::regT2);
      jit.addPtr(CCallHelpers::stackPointerRegister, GPRInfo::regT2);
      CCallHelpers::Jump haveStackSpace = jit.branchPtr(CCallHelpers::BelowOrEqual, CCallHelpers::AbsoluteAddress(vm.addressOfSoftStackLimit()), GPRInfo::regT2);
  
      // Throw Stack Overflow exception
      jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm.topEntryFrame);
<span class="line-modified">!     jit.loadPtr(CCallHelpers::Address(GPRInfo::regT0, JSBoundFunction::offsetOfScopeChain()), GPRInfo::regT3);</span>
<span class="line-modified">!     jit.setupArguments&lt;decltype(operationThrowStackOverflowErrorFromThunk)&gt;(GPRInfo::regT3);</span>
<span class="line-added">+     jit.prepareCallOperation(vm);</span>
<span class="line-added">+     jit.move(CCallHelpers::TrustedImmPtr(tagCFunctionPtr&lt;OperationPtrTag&gt;(operationThrowStackOverflowErrorFromThunk)), GPRInfo::nonArgGPR0);</span>
      emitPointerValidation(jit, GPRInfo::nonArgGPR0, OperationPtrTag);
      jit.call(GPRInfo::nonArgGPR0, OperationPtrTag);
      jit.jumpToExceptionHandler(vm);
  
      haveStackSpace.link(&amp;jit);
      jit.move(GPRInfo::regT2, CCallHelpers::stackPointerRegister);
  
      // Do basic callee frame setup, including &#39;this&#39;.
  
<span class="line-modified">!     jit.store32(GPRInfo::regT1, CCallHelpers::calleeFramePayloadSlot(CallFrameSlot::argumentCountIncludingThis));</span>
  
<span class="line-modified">!     JSValueRegs valueRegs = JSValueRegs::withTwoAvailableRegs(GPRInfo::regT4, GPRInfo::regT2);</span>
<span class="line-modified">!     jit.loadValue(CCallHelpers::Address(GPRInfo::regT0, JSBoundFunction::offsetOfBoundThis()), valueRegs);</span>
      jit.storeValue(valueRegs, CCallHelpers::calleeArgumentSlot(0));
  
      // OK, now we can start copying. This is a simple matter of copying parameters from the caller&#39;s
<span class="line-modified">!     // frame to the callee&#39;s frame. Note that we know that regT3 (the argument count) must be at</span>
      // least 1.
<span class="line-added">+     jit.sub32(CCallHelpers::TrustedImm32(1), GPRInfo::regT3);</span>
      jit.sub32(CCallHelpers::TrustedImm32(1), GPRInfo::regT1);
<span class="line-modified">!     CCallHelpers::Jump done = jit.branchTest32(CCallHelpers::Zero, GPRInfo::regT3);</span>
  
      CCallHelpers::Label loop = jit.label();
<span class="line-added">+     jit.sub32(CCallHelpers::TrustedImm32(1), GPRInfo::regT3);</span>
      jit.sub32(CCallHelpers::TrustedImm32(1), GPRInfo::regT1);
<span class="line-modified">!     jit.loadValue(CCallHelpers::addressFor(virtualRegisterForArgumentIncludingThis(1)).indexedBy(GPRInfo::regT3, CCallHelpers::TimesEight), valueRegs);</span>
      jit.storeValue(valueRegs, CCallHelpers::calleeArgumentSlot(1).indexedBy(GPRInfo::regT1, CCallHelpers::TimesEight));
<span class="line-modified">!     jit.branchTest32(CCallHelpers::NonZero, GPRInfo::regT3).linkTo(loop, &amp;jit);</span>
  
      done.link(&amp;jit);
<span class="line-added">+     auto noArgs2 = jit.branchTest32(CCallHelpers::Zero, GPRInfo::regT1);</span>
<span class="line-added">+ </span>
<span class="line-added">+     jit.loadPtr(CCallHelpers::Address(GPRInfo::regT0, JSBoundFunction::offsetOfBoundArgs()), GPRInfo::regT3);</span>
<span class="line-added">+ </span>
<span class="line-added">+     CCallHelpers::Label loopBound = jit.label();</span>
<span class="line-added">+     jit.sub32(CCallHelpers::TrustedImm32(1), GPRInfo::regT1);</span>
<span class="line-added">+     jit.loadValue(CCallHelpers::BaseIndex(GPRInfo::regT3, GPRInfo::regT1, CCallHelpers::TimesEight, JSImmutableButterfly::offsetOfData() + sizeof(WriteBarrier&lt;Unknown&gt;)), valueRegs);</span>
<span class="line-added">+     jit.storeValue(valueRegs, CCallHelpers::calleeArgumentSlot(1).indexedBy(GPRInfo::regT1, CCallHelpers::TimesEight));</span>
<span class="line-added">+     jit.branchTest32(CCallHelpers::NonZero, GPRInfo::regT1).linkTo(loopBound, &amp;jit);</span>
<span class="line-added">+ </span>
<span class="line-added">+     noArgs2.link(&amp;jit);</span>
<span class="line-added">+ </span>
<span class="line-added">+     jit.loadPtr(CCallHelpers::Address(GPRInfo::regT0, JSBoundFunction::offsetOfTargetFunction()), GPRInfo::regT2);</span>
<span class="line-added">+     jit.storeCell(GPRInfo::regT2, CCallHelpers::calleeFrameSlot(CallFrameSlot::callee));</span>
<span class="line-added">+ </span>
<span class="line-added">+     jit.loadPtr(CCallHelpers::Address(GPRInfo::regT2, JSFunction::offsetOfExecutableOrRareData()), GPRInfo::regT0);</span>
<span class="line-added">+     auto hasExecutable = jit.branchTestPtr(CCallHelpers::Zero, GPRInfo::regT0, CCallHelpers::TrustedImm32(JSFunction::rareDataTag));</span>
<span class="line-added">+     jit.loadPtr(CCallHelpers::Address(GPRInfo::regT0, FunctionRareData::offsetOfExecutable() - JSFunction::rareDataTag), GPRInfo::regT0);</span>
<span class="line-added">+     hasExecutable.link(&amp;jit);</span>
  
      jit.loadPtr(
          CCallHelpers::Address(
              GPRInfo::regT0, ExecutableBase::offsetOfJITCodeWithArityCheckFor(CodeForCall)),
          GPRInfo::regT0);
      CCallHelpers::Jump noCode = jit.branchTestPtr(CCallHelpers::Zero, GPRInfo::regT0);
</pre>
<center><a href="TempRegisterSet.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ThunkGenerators.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
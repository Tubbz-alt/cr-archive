<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/loader/ProgressTracker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2007, 2018 Apple Inc.  All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ProgressTracker.h&quot;
 28 
 29 #include &quot;DocumentLoader.h&quot;
 30 #include &quot;Frame.h&quot;
 31 #include &quot;FrameLoader.h&quot;
 32 #include &quot;FrameLoaderStateMachine.h&quot;
 33 #include &quot;FrameLoaderClient.h&quot;
 34 #include &quot;InspectorInstrumentation.h&quot;
 35 #include &quot;Logging.h&quot;
 36 #include &quot;ProgressTrackerClient.h&quot;
 37 #include &quot;ResourceResponse.h&quot;
 38 #include &lt;wtf/text/CString.h&gt;
 39 
 40 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), Network, &quot;%p - ProgressTracker::&quot; fmt, this, ##__VA_ARGS__)
 41 
 42 namespace WebCore {
 43 
 44 // Always start progress at initialProgressValue. This helps provide feedback as
 45 // soon as a load starts.
 46 static const double initialProgressValue = 0.1;
 47 
 48 // Similarly, always leave space at the end. This helps show the user that we&#39;re not done
 49 // until we&#39;re done.
 50 static const double finalProgressValue = 0.9; // 1.0 - initialProgressValue
 51 
 52 static const int progressItemDefaultEstimatedLength = 1024 * 16;
 53 
 54 // Check if the load is progressing this often.
 55 static const Seconds progressHeartbeatInterval { 100_ms };
 56 
 57 // How many heartbeats must pass without progress before deciding the load is currently stalled.
 58 static const unsigned loadStalledHeartbeatCount = 4;
 59 
 60 // How many bytes are required between heartbeats to consider it progress.
 61 static const unsigned minumumBytesPerHeartbeatForProgress = 1024;
 62 
 63 static const Seconds progressNotificationTimeInterval { 200_ms };
 64 
 65 struct ProgressItem {
 66     WTF_MAKE_NONCOPYABLE(ProgressItem); WTF_MAKE_FAST_ALLOCATED;
 67 public:
 68     explicit ProgressItem(long long length)
 69         : bytesReceived(0)
 70         , estimatedLength(length)
 71     {
 72     }
 73 
 74     long long bytesReceived;
 75     long long estimatedLength;
 76 };
 77 
 78 unsigned long ProgressTracker::s_uniqueIdentifier = 0;
 79 
<a name="1" id="anc1"></a><span class="line-modified"> 80 ProgressTracker::ProgressTracker(UniqueRef&lt;ProgressTrackerClient&gt;&amp;&amp; client)</span>
<span class="line-modified"> 81     : m_client(WTFMove(client))</span>
 82     , m_progressHeartbeatTimer(*this, &amp;ProgressTracker::progressHeartbeatTimerFired)
 83 {
 84 }
 85 
<a name="2" id="anc2"></a><span class="line-modified"> 86 ProgressTracker::~ProgressTracker() = default;</span>



 87 
 88 double ProgressTracker::estimatedProgress() const
 89 {
 90     return m_progressValue;
 91 }
 92 
 93 void ProgressTracker::reset()
 94 {
 95     m_progressItems.clear();
 96 
 97     m_totalPageAndResourceBytesToLoad = 0;
 98     m_totalBytesReceived = 0;
 99     m_totalBytesReceivedBeforePreviousHeartbeat = 0;
100 
101     m_lastNotifiedProgressValue = 0;
102     m_progressValue = 0;
103 
104     m_lastNotifiedProgressTime = MonotonicTime();
105     m_finalProgressChangedSent = false;
106     m_numProgressTrackedFrames = 0;
107     m_originatingProgressFrame = nullptr;
108 
109     m_heartbeatsWithNoProgress = 0;
110     m_progressHeartbeatTimer.stop();
111 }
112 
113 void ProgressTracker::progressStarted(Frame&amp; frame)
114 {
115     LOG(Progress, &quot;Progress started (%p) - frame %p(\&quot;%s\&quot;), value %f, tracked frames %d, originating frame %p&quot;, this, &amp;frame, frame.tree().uniqueName().string().utf8().data(), m_progressValue, m_numProgressTrackedFrames, m_originatingProgressFrame.get());
116 
<a name="3" id="anc3"></a><span class="line-modified">117     m_client-&gt;willChangeEstimatedProgress();</span>
118 
119     if (!m_numProgressTrackedFrames || m_originatingProgressFrame == &amp;frame) {
120         reset();
121         m_progressValue = initialProgressValue;
122         m_originatingProgressFrame = &amp;frame;
123 
124         m_progressHeartbeatTimer.startRepeating(progressHeartbeatInterval);
125         m_originatingProgressFrame-&gt;loader().loadProgressingStatusChanged();
126 
127         bool isMainFrame = !m_originatingProgressFrame-&gt;tree().parent();
128         auto elapsedTimeSinceMainLoadComplete = MonotonicTime::now() - m_mainLoadCompletionTime;
129 
130         static const auto subframePartOfMainLoadThreshold = 1_s;
131         m_isMainLoad = isMainFrame || elapsedTimeSinceMainLoadComplete &lt; subframePartOfMainLoadThreshold;
132 
<a name="4" id="anc4"></a><span class="line-modified">133         m_client-&gt;progressStarted(*m_originatingProgressFrame);</span>
134     }
135     m_numProgressTrackedFrames++;
136 
137     RELEASE_LOG_IF_ALLOWED(&quot;progressStarted: frame %p, value %f, tracked frames %d, originating frame %p, isMainLoad %d&quot;, &amp;frame, m_progressValue, m_numProgressTrackedFrames, m_originatingProgressFrame.get(), m_isMainLoad);
138 
<a name="5" id="anc5"></a><span class="line-modified">139     m_client-&gt;didChangeEstimatedProgress();</span>
140     InspectorInstrumentation::frameStartedLoading(frame);
141 }
142 
143 void ProgressTracker::progressCompleted(Frame&amp; frame)
144 {
145     LOG(Progress, &quot;Progress completed (%p) - frame %p(\&quot;%s\&quot;), value %f, tracked frames %d, originating frame %p&quot;, this, &amp;frame, frame.tree().uniqueName().string().utf8().data(), m_progressValue, m_numProgressTrackedFrames, m_originatingProgressFrame.get());
146     RELEASE_LOG_IF_ALLOWED(&quot;progressCompleted: frame %p, value %f, tracked frames %d, originating frame %p, isMainLoad %d&quot;, &amp;frame, m_progressValue, m_numProgressTrackedFrames, m_originatingProgressFrame.get(), m_isMainLoad);
147 
148     if (m_numProgressTrackedFrames &lt;= 0)
149         return;
150 
<a name="6" id="anc6"></a><span class="line-modified">151     m_client-&gt;willChangeEstimatedProgress();</span>
152 
153     m_numProgressTrackedFrames--;
154     if (!m_numProgressTrackedFrames || m_originatingProgressFrame == &amp;frame)
155         finalProgressComplete();
156 
<a name="7" id="anc7"></a><span class="line-modified">157     m_client-&gt;didChangeEstimatedProgress();</span>
158 }
159 
160 void ProgressTracker::finalProgressComplete()
161 {
162     LOG(Progress, &quot;Final progress complete (%p)&quot;, this);
163     RELEASE_LOG_IF_ALLOWED(&quot;finalProgressComplete: value %f, tracked frames %d, originating frame %p, isMainLoad %d, isMainLoadProgressing %d&quot;, m_progressValue, m_numProgressTrackedFrames, m_originatingProgressFrame.get(), m_isMainLoad, isMainLoadProgressing());
164 
165     auto frame = WTFMove(m_originatingProgressFrame);
166 
167     // Before resetting progress value be sure to send client a least one notification
168     // with final progress value.
169     if (!m_finalProgressChangedSent) {
170         m_progressValue = 1;
<a name="8" id="anc8"></a><span class="line-modified">171         m_client-&gt;progressEstimateChanged(*frame);</span>
172     }
173 
174     reset();
175 
176     if (m_isMainLoad)
177         m_mainLoadCompletionTime = MonotonicTime::now();
178 
179     frame-&gt;loader().client().setMainFrameDocumentReady(true);
<a name="9" id="anc9"></a><span class="line-modified">180     m_client-&gt;progressFinished(*frame);</span>
181     frame-&gt;loader().loadProgressingStatusChanged();
182 
183     InspectorInstrumentation::frameStoppedLoading(*frame);
184 }
185 
186 void ProgressTracker::incrementProgress(unsigned long identifier, const ResourceResponse&amp; response)
187 {
188     LOG(Progress, &quot;Progress incremented (%p) - value %f, tracked frames %d, originating frame %p&quot;, this, m_progressValue, m_numProgressTrackedFrames, m_originatingProgressFrame.get());
189 
190     if (m_numProgressTrackedFrames &lt;= 0)
191         return;
192 
193     long long estimatedLength = response.expectedContentLength();
194     if (estimatedLength &lt; 0)
195         estimatedLength = progressItemDefaultEstimatedLength;
196 
197     m_totalPageAndResourceBytesToLoad += estimatedLength;
198 
199     auto&amp; item = m_progressItems.add(identifier, nullptr).iterator-&gt;value;
200     if (!item) {
201         item = makeUnique&lt;ProgressItem&gt;(estimatedLength);
202         return;
203     }
204 
205     item-&gt;bytesReceived = 0;
206     item-&gt;estimatedLength = estimatedLength;
207 }
208 
209 void ProgressTracker::incrementProgress(unsigned long identifier, unsigned bytesReceived)
210 {
211     ProgressItem* item = m_progressItems.get(identifier);
212 
213     // FIXME: Can this ever happen?
214     if (!item)
215         return;
216 
217     RefPtr&lt;Frame&gt; frame = m_originatingProgressFrame;
218 
<a name="10" id="anc10"></a><span class="line-modified">219     m_client-&gt;willChangeEstimatedProgress();</span>
220 
221     double increment, percentOfRemainingBytes;
222     long long remainingBytes, estimatedBytesForPendingRequests;
223 
224     item-&gt;bytesReceived += bytesReceived;
225     if (item-&gt;bytesReceived &gt; item-&gt;estimatedLength) {
226         m_totalPageAndResourceBytesToLoad += ((item-&gt;bytesReceived * 2) - item-&gt;estimatedLength);
227         item-&gt;estimatedLength = item-&gt;bytesReceived * 2;
228     }
229 
230     int numPendingOrLoadingRequests = frame-&gt;loader().numPendingOrLoadingRequests(true);
231     estimatedBytesForPendingRequests = static_cast&lt;long long&gt;(progressItemDefaultEstimatedLength) * numPendingOrLoadingRequests;
232     remainingBytes = ((m_totalPageAndResourceBytesToLoad + estimatedBytesForPendingRequests) - m_totalBytesReceived);
233     if (remainingBytes &gt; 0)  // Prevent divide by 0.
234         percentOfRemainingBytes = (double)bytesReceived / (double)remainingBytes;
235     else
236         percentOfRemainingBytes = 1.0;
237 
238     // For documents that use WebCore&#39;s layout system, treat first layout as the half-way point.
239     // FIXME: The hasHTMLView function is a sort of roundabout way of asking &quot;do you use WebCore&#39;s layout system&quot;.
240     bool useClampedMaxProgress = frame-&gt;loader().client().hasHTMLView()
241         &amp;&amp; !frame-&gt;loader().stateMachine().firstLayoutDone();
242     double maxProgressValue = useClampedMaxProgress ? 0.5 : finalProgressValue;
243     increment = (maxProgressValue - m_progressValue) * percentOfRemainingBytes;
244     m_progressValue += increment;
245     m_progressValue = std::min(m_progressValue, maxProgressValue);
246     ASSERT(m_progressValue &gt;= initialProgressValue);
247 
248     m_totalBytesReceived += bytesReceived;
249 
250     auto now = MonotonicTime::now();
251     auto notifiedProgressTimeDelta = now - m_lastNotifiedProgressTime;
252 
253     LOG(Progress, &quot;Progress incremented (%p) - value %f, tracked frames %d&quot;, this, m_progressValue, m_numProgressTrackedFrames);
254     if ((notifiedProgressTimeDelta &gt;= progressNotificationTimeInterval || m_progressValue == 1) &amp;&amp; m_numProgressTrackedFrames &gt; 0) {
255         if (!m_finalProgressChangedSent) {
256             if (m_progressValue == 1)
257                 m_finalProgressChangedSent = true;
258 
<a name="11" id="anc11"></a><span class="line-modified">259             m_client-&gt;progressEstimateChanged(*frame);</span>
260 
261             m_lastNotifiedProgressValue = m_progressValue;
262             m_lastNotifiedProgressTime = now;
263         }
264     }
265 
<a name="12" id="anc12"></a><span class="line-modified">266     m_client-&gt;didChangeEstimatedProgress();</span>
267 }
268 
269 void ProgressTracker::completeProgress(unsigned long identifier)
270 {
271     auto it = m_progressItems.find(identifier);
272 
273     // This can happen if a load fails without receiving any response data.
274     if (it == m_progressItems.end())
275         return;
276 
277     ProgressItem&amp; item = *it-&gt;value;
278 
279     // Adjust the total expected bytes to account for any overage/underage.
280     long long delta = item.bytesReceived - item.estimatedLength;
281     m_totalPageAndResourceBytesToLoad += delta;
282 
283     m_progressItems.remove(it);
284 }
285 
286 unsigned long ProgressTracker::createUniqueIdentifier()
287 {
288     return ++s_uniqueIdentifier;
289 }
290 
291 bool ProgressTracker::isMainLoadProgressing() const
292 {
293     if (!m_originatingProgressFrame)
294         return false;
295 
296     if (!m_isMainLoad)
297         return false;
298 
299     return m_progressValue &amp;&amp; m_progressValue &lt; finalProgressValue &amp;&amp; m_heartbeatsWithNoProgress &lt; loadStalledHeartbeatCount;
300 }
301 
302 void ProgressTracker::progressHeartbeatTimerFired()
303 {
304     if (m_totalBytesReceived &lt; m_totalBytesReceivedBeforePreviousHeartbeat + minumumBytesPerHeartbeatForProgress)
305         ++m_heartbeatsWithNoProgress;
306     else
307         m_heartbeatsWithNoProgress = 0;
308 
309     m_totalBytesReceivedBeforePreviousHeartbeat = m_totalBytesReceived;
310 
311     if (m_originatingProgressFrame)
312         m_originatingProgressFrame-&gt;loader().loadProgressingStatusChanged();
313 
314     if (m_progressValue &gt;= finalProgressValue)
315         m_progressHeartbeatTimer.stop();
316 }
317 
318 bool ProgressTracker::isAlwaysOnLoggingAllowed() const
319 {
320     if (!m_originatingProgressFrame)
321         return false;
322 
323     return m_originatingProgressFrame-&gt;isAlwaysOnLoggingAllowed();
324 }
325 
326 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
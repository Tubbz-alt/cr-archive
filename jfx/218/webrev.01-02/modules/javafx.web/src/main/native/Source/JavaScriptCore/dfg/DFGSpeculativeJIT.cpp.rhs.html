<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 /*
    2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
    3  *
    4  * Redistribution and use in source and binary forms, with or without
    5  * modification, are permitted provided that the following conditions
    6  * are met:
    7  * 1. Redistributions of source code must retain the above copyright
    8  *    notice, this list of conditions and the following disclaimer.
    9  * 2. Redistributions in binary form must reproduce the above copyright
   10  *    notice, this list of conditions and the following disclaimer in the
   11  *    documentation and/or other materials provided with the distribution.
   12  *
   13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
   14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
   15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
   16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
   17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
   21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   24  */
   25 
   26 #include &quot;config.h&quot;
   27 #include &quot;DFGSpeculativeJIT.h&quot;
   28 
   29 #if ENABLE(DFG_JIT)
   30 
   31 #include &quot;BinarySwitch.h&quot;
   32 #include &quot;DFGAbstractInterpreterInlines.h&quot;
   33 #include &quot;DFGArrayifySlowPathGenerator.h&quot;
   34 #include &quot;DFGCallArrayAllocatorSlowPathGenerator.h&quot;
   35 #include &quot;DFGCallCreateDirectArgumentsSlowPathGenerator.h&quot;
   36 #include &quot;DFGCapabilities.h&quot;
   37 #include &quot;DFGMayExit.h&quot;
   38 #include &quot;DFGOSRExitFuzz.h&quot;
   39 #include &quot;DFGSaneStringGetByValSlowPathGenerator.h&quot;
   40 #include &quot;DFGSlowPathGenerator.h&quot;
   41 #include &quot;DFGSnippetParams.h&quot;
<a name="1" id="anc1"></a><span class="line-added">   42 #include &quot;DateInstance.h&quot;</span>
   43 #include &quot;DirectArguments.h&quot;
   44 #include &quot;DisallowMacroScratchRegisterUsage.h&quot;
   45 #include &quot;JITAddGenerator.h&quot;
   46 #include &quot;JITBitAndGenerator.h&quot;
   47 #include &quot;JITBitOrGenerator.h&quot;
   48 #include &quot;JITBitXorGenerator.h&quot;
   49 #include &quot;JITDivGenerator.h&quot;
   50 #include &quot;JITLeftShiftGenerator.h&quot;
   51 #include &quot;JITMulGenerator.h&quot;
   52 #include &quot;JITRightShiftGenerator.h&quot;
   53 #include &quot;JITSubGenerator.h&quot;
<a name="2" id="anc2"></a><span class="line-added">   54 #include &quot;JSArrayIterator.h&quot;</span>
   55 #include &quot;JSAsyncFunction.h&quot;
   56 #include &quot;JSAsyncGeneratorFunction.h&quot;
   57 #include &quot;JSCInlines.h&quot;
<a name="3" id="anc3"></a>
   58 #include &quot;JSGeneratorFunction.h&quot;
   59 #include &quot;JSImmutableButterfly.h&quot;
   60 #include &quot;JSLexicalEnvironment.h&quot;
   61 #include &quot;JSPropertyNameEnumerator.h&quot;
   62 #include &quot;LinkBuffer.h&quot;
   63 #include &quot;RegExpObject.h&quot;
   64 #include &quot;ScopedArguments.h&quot;
   65 #include &quot;ScratchRegisterAllocator.h&quot;
   66 #include &quot;SuperSampler.h&quot;
   67 #include &quot;TypeProfilerLog.h&quot;
   68 #include &quot;WeakMapImpl.h&quot;
   69 #include &lt;wtf/BitVector.h&gt;
   70 #include &lt;wtf/Box.h&gt;
   71 #include &lt;wtf/MathExtras.h&gt;
   72 
   73 namespace JSC { namespace DFG {
   74 
<a name="4" id="anc4"></a><span class="line-added">   75 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(SpeculativeJIT);</span>
<span class="line-added">   76 </span>
   77 SpeculativeJIT::SpeculativeJIT(JITCompiler&amp; jit)
   78     : m_jit(jit)
   79     , m_graph(m_jit.graph())
   80     , m_currentNode(0)
   81     , m_lastGeneratedNode(LastNodeType)
   82     , m_indexInBlock(0)
   83     , m_generationInfo(m_jit.graph().frameRegisterCount())
   84     , m_compileOkay(true)
   85     , m_state(m_jit.graph())
   86     , m_interpreter(m_jit.graph(), m_state)
   87     , m_stream(&amp;jit.jitCode()-&gt;variableEventStream)
   88     , m_minifiedGraph(&amp;jit.jitCode()-&gt;minifiedDFG)
   89 {
   90 }
   91 
   92 SpeculativeJIT::~SpeculativeJIT()
   93 {
   94 }
   95 
   96 void SpeculativeJIT::emitAllocateRawObject(GPRReg resultGPR, RegisteredStructure structure, GPRReg storageGPR, unsigned numElements, unsigned vectorLength)
   97 {
   98     ASSERT(!isCopyOnWrite(structure-&gt;indexingMode()));
   99     IndexingType indexingType = structure-&gt;indexingType();
  100     bool hasIndexingHeader = hasIndexedProperties(indexingType);
  101 
  102     unsigned inlineCapacity = structure-&gt;inlineCapacity();
  103     unsigned outOfLineCapacity = structure-&gt;outOfLineCapacity();
  104 
  105     GPRTemporary scratch(this);
  106     GPRTemporary scratch2(this);
  107     GPRReg scratchGPR = scratch.gpr();
  108     GPRReg scratch2GPR = scratch2.gpr();
  109 
  110     ASSERT(vectorLength &gt;= numElements);
  111     vectorLength = Butterfly::optimalContiguousVectorLength(structure.get(), vectorLength);
  112 
  113     JITCompiler::JumpList slowCases;
  114 
  115     size_t size = 0;
  116     if (hasIndexingHeader)
  117         size += vectorLength * sizeof(JSValue) + sizeof(IndexingHeader);
  118     size += outOfLineCapacity * sizeof(JSValue);
  119 
  120     m_jit.move(TrustedImmPtr(nullptr), storageGPR);
  121 
  122     VM&amp; vm = this-&gt;vm();
  123     if (size) {
  124         if (Allocator allocator = vm.jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(size, AllocatorForMode::AllocatorIfExists)) {
  125             m_jit.emitAllocate(storageGPR, JITAllocator::constant(allocator), scratchGPR, scratch2GPR, slowCases);
  126 
  127             m_jit.addPtr(
  128                 TrustedImm32(outOfLineCapacity * sizeof(JSValue) + sizeof(IndexingHeader)),
  129                 storageGPR);
  130 
  131             if (hasIndexingHeader)
  132                 m_jit.store32(TrustedImm32(vectorLength), MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
  133         } else
  134             slowCases.append(m_jit.jump());
  135     }
  136 
  137     size_t allocationSize = JSFinalObject::allocationSize(inlineCapacity);
  138     Allocator allocator = allocatorForNonVirtualConcurrently&lt;JSFinalObject&gt;(vm, allocationSize, AllocatorForMode::AllocatorIfExists);
  139     if (allocator) {
  140         emitAllocateJSObject(resultGPR, JITAllocator::constant(allocator), scratchGPR, TrustedImmPtr(structure), storageGPR, scratch2GPR, slowCases);
  141         m_jit.emitInitializeInlineStorage(resultGPR, structure-&gt;inlineCapacity());
  142     } else
  143         slowCases.append(m_jit.jump());
  144 
  145     // I want a slow path that also loads out the storage pointer, and that&#39;s
  146     // what this custom CallArrayAllocatorSlowPathGenerator gives me. It&#39;s a lot
  147     // of work for a very small piece of functionality. :-/
  148     addSlowPathGenerator(makeUnique&lt;CallArrayAllocatorSlowPathGenerator&gt;(
  149         slowCases, this, operationNewRawObject, resultGPR, storageGPR,
  150         structure, vectorLength));
  151 
  152     if (numElements &lt; vectorLength) {
  153 #if USE(JSVALUE64)
  154         if (hasDouble(structure-&gt;indexingType()))
  155             m_jit.move(TrustedImm64(bitwise_cast&lt;int64_t&gt;(PNaN)), scratchGPR);
  156         else
  157             m_jit.move(TrustedImm64(JSValue::encode(JSValue())), scratchGPR);
  158         for (unsigned i = numElements; i &lt; vectorLength; ++i)
  159             m_jit.store64(scratchGPR, MacroAssembler::Address(storageGPR, sizeof(double) * i));
  160 #else
  161         EncodedValueDescriptor value;
  162         if (hasDouble(structure-&gt;indexingType()))
  163             value.asInt64 = JSValue::encode(JSValue(JSValue::EncodeAsDouble, PNaN));
  164         else
  165             value.asInt64 = JSValue::encode(JSValue());
  166         for (unsigned i = numElements; i &lt; vectorLength; ++i) {
  167             m_jit.store32(TrustedImm32(value.asBits.tag), MacroAssembler::Address(storageGPR, sizeof(double) * i + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
  168             m_jit.store32(TrustedImm32(value.asBits.payload), MacroAssembler::Address(storageGPR, sizeof(double) * i + OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
  169         }
  170 #endif
  171     }
  172 
  173     if (hasIndexingHeader)
  174         m_jit.store32(TrustedImm32(numElements), MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
  175 
  176     m_jit.emitInitializeOutOfLineStorage(storageGPR, structure-&gt;outOfLineCapacity());
  177 
  178     m_jit.mutatorFence(vm);
  179 }
  180 
  181 void SpeculativeJIT::emitGetLength(InlineCallFrame* inlineCallFrame, GPRReg lengthGPR, bool includeThis)
  182 {
  183     if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs())
  184         m_jit.move(TrustedImm32(inlineCallFrame-&gt;argumentCountIncludingThis - !includeThis), lengthGPR);
  185     else {
  186         VirtualRegister argumentCountRegister = m_jit.argumentCount(inlineCallFrame);
  187         m_jit.load32(JITCompiler::payloadFor(argumentCountRegister), lengthGPR);
  188         if (!includeThis)
  189             m_jit.sub32(TrustedImm32(1), lengthGPR);
  190     }
  191 }
  192 
  193 void SpeculativeJIT::emitGetLength(CodeOrigin origin, GPRReg lengthGPR, bool includeThis)
  194 {
  195     emitGetLength(origin.inlineCallFrame(), lengthGPR, includeThis);
  196 }
  197 
  198 void SpeculativeJIT::emitGetCallee(CodeOrigin origin, GPRReg calleeGPR)
  199 {
  200     auto* inlineCallFrame = origin.inlineCallFrame();
  201     if (inlineCallFrame) {
  202         if (inlineCallFrame-&gt;isClosureCall) {
  203             m_jit.loadPtr(
  204                 JITCompiler::addressFor(inlineCallFrame-&gt;calleeRecovery.virtualRegister()),
  205                 calleeGPR);
  206         } else {
  207             m_jit.move(
  208                 TrustedImmPtr::weakPointer(m_jit.graph(), inlineCallFrame-&gt;calleeRecovery.constant().asCell()),
  209                 calleeGPR);
  210         }
  211     } else
  212         m_jit.loadPtr(JITCompiler::addressFor(CallFrameSlot::callee), calleeGPR);
  213 }
  214 
  215 void SpeculativeJIT::emitGetArgumentStart(CodeOrigin origin, GPRReg startGPR)
  216 {
  217     m_jit.addPtr(
  218         TrustedImm32(
  219             JITCompiler::argumentsStart(origin).offset() * static_cast&lt;int&gt;(sizeof(Register))),
  220         GPRInfo::callFrameRegister, startGPR);
  221 }
  222 
  223 MacroAssembler::Jump SpeculativeJIT::emitOSRExitFuzzCheck()
  224 {
  225     if (!Options::useOSRExitFuzz()
  226         || !canUseOSRExitFuzzing(m_jit.graph().baselineCodeBlockFor(m_origin.semantic))
  227         || !doOSRExitFuzzing())
  228         return MacroAssembler::Jump();
  229 
  230     MacroAssembler::Jump result;
  231 
  232     m_jit.pushToSave(GPRInfo::regT0);
  233     m_jit.load32(&amp;g_numberOfOSRExitFuzzChecks, GPRInfo::regT0);
  234     m_jit.add32(TrustedImm32(1), GPRInfo::regT0);
  235     m_jit.store32(GPRInfo::regT0, &amp;g_numberOfOSRExitFuzzChecks);
  236     unsigned atOrAfter = Options::fireOSRExitFuzzAtOrAfter();
  237     unsigned at = Options::fireOSRExitFuzzAt();
  238     if (at || atOrAfter) {
  239         unsigned threshold;
  240         MacroAssembler::RelationalCondition condition;
  241         if (atOrAfter) {
  242             threshold = atOrAfter;
  243             condition = MacroAssembler::Below;
  244         } else {
  245             threshold = at;
  246             condition = MacroAssembler::NotEqual;
  247         }
  248         MacroAssembler::Jump ok = m_jit.branch32(
  249             condition, GPRInfo::regT0, MacroAssembler::TrustedImm32(threshold));
  250         m_jit.popToRestore(GPRInfo::regT0);
  251         result = m_jit.jump();
  252         ok.link(&amp;m_jit);
  253     }
  254     m_jit.popToRestore(GPRInfo::regT0);
  255 
  256     return result;
  257 }
  258 
  259 void SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Node* node, MacroAssembler::Jump jumpToFail)
  260 {
  261     if (!m_compileOkay)
  262         return;
  263     JITCompiler::Jump fuzzJump = emitOSRExitFuzzCheck();
  264     if (fuzzJump.isSet()) {
  265         JITCompiler::JumpList jumpsToFail;
  266         jumpsToFail.append(fuzzJump);
  267         jumpsToFail.append(jumpToFail);
  268         m_jit.appendExitInfo(jumpsToFail);
  269     } else
  270         m_jit.appendExitInfo(jumpToFail);
  271     m_jit.jitCode()-&gt;appendOSRExit(OSRExit(kind, jsValueSource, m_jit.graph().methodOfGettingAValueProfileFor(m_currentNode, node), this, m_stream-&gt;size()));
  272 }
  273 
  274 void SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Node* node, const MacroAssembler::JumpList&amp; jumpsToFail)
  275 {
  276     if (!m_compileOkay)
  277         return;
  278     JITCompiler::Jump fuzzJump = emitOSRExitFuzzCheck();
  279     if (fuzzJump.isSet()) {
  280         JITCompiler::JumpList myJumpsToFail;
  281         myJumpsToFail.append(jumpsToFail);
  282         myJumpsToFail.append(fuzzJump);
  283         m_jit.appendExitInfo(myJumpsToFail);
  284     } else
  285         m_jit.appendExitInfo(jumpsToFail);
  286     m_jit.jitCode()-&gt;appendOSRExit(OSRExit(kind, jsValueSource, m_jit.graph().methodOfGettingAValueProfileFor(m_currentNode, node), this, m_stream-&gt;size()));
  287 }
  288 
  289 OSRExitJumpPlaceholder SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Node* node)
  290 {
  291     if (!m_compileOkay)
  292         return OSRExitJumpPlaceholder();
  293     unsigned index = m_jit.jitCode()-&gt;osrExit.size();
  294     m_jit.appendExitInfo();
  295     m_jit.jitCode()-&gt;appendOSRExit(OSRExit(kind, jsValueSource, m_jit.graph().methodOfGettingAValueProfileFor(m_currentNode, node), this, m_stream-&gt;size()));
  296     return OSRExitJumpPlaceholder(index);
  297 }
  298 
  299 OSRExitJumpPlaceholder SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Edge nodeUse)
  300 {
  301     return speculationCheck(kind, jsValueSource, nodeUse.node());
  302 }
  303 
  304 void SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Edge nodeUse, MacroAssembler::Jump jumpToFail)
  305 {
  306     speculationCheck(kind, jsValueSource, nodeUse.node(), jumpToFail);
  307 }
  308 
  309 void SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Edge nodeUse, const MacroAssembler::JumpList&amp; jumpsToFail)
  310 {
  311     speculationCheck(kind, jsValueSource, nodeUse.node(), jumpsToFail);
  312 }
  313 
  314 void SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Node* node, MacroAssembler::Jump jumpToFail, const SpeculationRecovery&amp; recovery)
  315 {
  316     if (!m_compileOkay)
  317         return;
  318     unsigned recoveryIndex = m_jit.jitCode()-&gt;appendSpeculationRecovery(recovery);
  319     m_jit.appendExitInfo(jumpToFail);
  320     m_jit.jitCode()-&gt;appendOSRExit(OSRExit(kind, jsValueSource, m_jit.graph().methodOfGettingAValueProfileFor(m_currentNode, node), this, m_stream-&gt;size(), recoveryIndex));
  321 }
  322 
  323 void SpeculativeJIT::speculationCheck(ExitKind kind, JSValueSource jsValueSource, Edge nodeUse, MacroAssembler::Jump jumpToFail, const SpeculationRecovery&amp; recovery)
  324 {
  325     speculationCheck(kind, jsValueSource, nodeUse.node(), jumpToFail, recovery);
  326 }
  327 
  328 void SpeculativeJIT::emitInvalidationPoint(Node* node)
  329 {
  330     if (!m_compileOkay)
  331         return;
  332     OSRExitCompilationInfo&amp; info = m_jit.appendExitInfo(JITCompiler::JumpList());
  333     m_jit.jitCode()-&gt;appendOSRExit(OSRExit(
  334         UncountableInvalidation, JSValueSource(), MethodOfGettingAValueProfile(),
  335         this, m_stream-&gt;size()));
  336     info.m_replacementSource = m_jit.watchpointLabel();
  337     ASSERT(info.m_replacementSource.isSet());
  338     noResult(node);
  339 }
  340 
  341 void SpeculativeJIT::unreachable(Node* node)
  342 {
  343     m_compileOkay = false;
  344     m_jit.abortWithReason(DFGUnreachableNode, node-&gt;op());
  345 }
  346 
  347 void SpeculativeJIT::terminateSpeculativeExecution(ExitKind kind, JSValueRegs jsValueRegs, Node* node)
  348 {
  349     if (!m_compileOkay)
  350         return;
  351     speculationCheck(kind, jsValueRegs, node, m_jit.jump());
  352     m_compileOkay = false;
  353     if (verboseCompilationEnabled())
  354         dataLog(&quot;Bailing compilation.\n&quot;);
  355 }
  356 
  357 void SpeculativeJIT::terminateSpeculativeExecution(ExitKind kind, JSValueRegs jsValueRegs, Edge nodeUse)
  358 {
  359     terminateSpeculativeExecution(kind, jsValueRegs, nodeUse.node());
  360 }
  361 
  362 void SpeculativeJIT::typeCheck(JSValueSource source, Edge edge, SpeculatedType typesPassedThrough, MacroAssembler::Jump jumpToFail, ExitKind exitKind)
  363 {
  364     ASSERT(needsTypeCheck(edge, typesPassedThrough));
  365     m_interpreter.filter(edge, typesPassedThrough);
  366     speculationCheck(exitKind, source, edge.node(), jumpToFail);
  367 }
  368 
  369 RegisterSet SpeculativeJIT::usedRegisters()
  370 {
  371     RegisterSet result;
  372 
  373     for (unsigned i = GPRInfo::numberOfRegisters; i--;) {
  374         GPRReg gpr = GPRInfo::toRegister(i);
  375         if (m_gprs.isInUse(gpr))
  376             result.set(gpr);
  377     }
  378     for (unsigned i = FPRInfo::numberOfRegisters; i--;) {
  379         FPRReg fpr = FPRInfo::toRegister(i);
  380         if (m_fprs.isInUse(fpr))
  381             result.set(fpr);
  382     }
  383 
  384     // FIXME: This is overly conservative. We could subtract out those callee-saves that we
  385     // actually saved.
  386     // https://bugs.webkit.org/show_bug.cgi?id=185686
  387     result.merge(RegisterSet::stubUnavailableRegisters());
  388 
  389     return result;
  390 }
  391 
  392 void SpeculativeJIT::addSlowPathGenerator(std::unique_ptr&lt;SlowPathGenerator&gt; slowPathGenerator)
  393 {
  394     m_slowPathGenerators.append(WTFMove(slowPathGenerator));
  395 }
  396 
  397 void SpeculativeJIT::addSlowPathGeneratorLambda(Function&lt;void()&gt;&amp;&amp; lambda)
  398 {
  399     m_slowPathLambdas.append(SlowPathLambda{ WTFMove(lambda), m_currentNode, static_cast&lt;unsigned&gt;(m_stream-&gt;size()) });
  400 }
  401 
  402 void SpeculativeJIT::runSlowPathGenerators(PCToCodeOriginMapBuilder&amp; pcToCodeOriginMapBuilder)
  403 {
  404     for (auto&amp; slowPathGenerator : m_slowPathGenerators) {
  405         pcToCodeOriginMapBuilder.appendItem(m_jit.labelIgnoringWatchpoints(), slowPathGenerator-&gt;origin().semantic);
  406         slowPathGenerator-&gt;generate(this);
  407     }
  408     for (auto&amp; slowPathLambda : m_slowPathLambdas) {
  409         Node* currentNode = slowPathLambda.currentNode;
  410         m_currentNode = currentNode;
  411         m_outOfLineStreamIndex = slowPathLambda.streamIndex;
  412         pcToCodeOriginMapBuilder.appendItem(m_jit.labelIgnoringWatchpoints(), currentNode-&gt;origin.semantic);
  413         slowPathLambda.generator();
  414         m_outOfLineStreamIndex = WTF::nullopt;
  415     }
  416 }
  417 
  418 void SpeculativeJIT::clearGenerationInfo()
  419 {
  420     for (unsigned i = 0; i &lt; m_generationInfo.size(); ++i)
  421         m_generationInfo[i] = GenerationInfo();
  422     m_gprs = RegisterBank&lt;GPRInfo&gt;();
  423     m_fprs = RegisterBank&lt;FPRInfo&gt;();
  424 }
  425 
  426 SilentRegisterSavePlan SpeculativeJIT::silentSavePlanForGPR(VirtualRegister spillMe, GPRReg source)
  427 {
  428     GenerationInfo&amp; info = generationInfoFromVirtualRegister(spillMe);
  429     Node* node = info.node();
  430     DataFormat registerFormat = info.registerFormat();
  431     ASSERT(registerFormat != DataFormatNone);
  432     ASSERT(registerFormat != DataFormatDouble);
  433 
  434     SilentSpillAction spillAction;
  435     SilentFillAction fillAction;
  436 
  437     if (!info.needsSpill())
  438         spillAction = DoNothingForSpill;
  439     else {
  440 #if USE(JSVALUE64)
  441         ASSERT(info.gpr() == source);
  442         if (registerFormat == DataFormatInt32)
  443             spillAction = Store32Payload;
  444         else if (registerFormat == DataFormatCell || registerFormat == DataFormatStorage)
  445             spillAction = StorePtr;
  446         else if (registerFormat == DataFormatInt52 || registerFormat == DataFormatStrictInt52)
  447             spillAction = Store64;
  448         else {
  449             ASSERT(registerFormat &amp; DataFormatJS);
  450             spillAction = Store64;
  451         }
  452 #elif USE(JSVALUE32_64)
  453         if (registerFormat &amp; DataFormatJS) {
  454             ASSERT(info.tagGPR() == source || info.payloadGPR() == source);
  455             spillAction = source == info.tagGPR() ? Store32Tag : Store32Payload;
  456         } else {
  457             ASSERT(info.gpr() == source);
  458             spillAction = Store32Payload;
  459         }
  460 #endif
  461     }
  462 
  463     if (registerFormat == DataFormatInt32) {
  464         ASSERT(info.gpr() == source);
  465         ASSERT(isJSInt32(info.registerFormat()));
  466         if (node-&gt;hasConstant()) {
  467             ASSERT(node-&gt;isInt32Constant());
  468             fillAction = SetInt32Constant;
  469         } else
  470             fillAction = Load32Payload;
  471     } else if (registerFormat == DataFormatBoolean) {
  472 #if USE(JSVALUE64)
  473         RELEASE_ASSERT_NOT_REACHED();
  474 #if COMPILER_QUIRK(CONSIDERS_UNREACHABLE_CODE)
  475         fillAction = DoNothingForFill;
  476 #endif
  477 #elif USE(JSVALUE32_64)
  478         ASSERT(info.gpr() == source);
  479         if (node-&gt;hasConstant()) {
  480             ASSERT(node-&gt;isBooleanConstant());
  481             fillAction = SetBooleanConstant;
  482         } else
  483             fillAction = Load32Payload;
  484 #endif
  485     } else if (registerFormat == DataFormatCell) {
  486         ASSERT(info.gpr() == source);
  487         if (node-&gt;hasConstant()) {
  488             DFG_ASSERT(m_jit.graph(), m_currentNode, node-&gt;isCellConstant());
  489             node-&gt;asCell(); // To get the assertion.
  490             fillAction = SetCellConstant;
  491         } else {
  492 #if USE(JSVALUE64)
  493             fillAction = LoadPtr;
  494 #else
  495             fillAction = Load32Payload;
  496 #endif
  497         }
  498     } else if (registerFormat == DataFormatStorage) {
  499         ASSERT(info.gpr() == source);
  500         fillAction = LoadPtr;
  501     } else if (registerFormat == DataFormatInt52) {
  502         if (node-&gt;hasConstant())
  503             fillAction = SetInt52Constant;
  504         else if (info.spillFormat() == DataFormatInt52)
  505             fillAction = Load64;
  506         else if (info.spillFormat() == DataFormatStrictInt52)
  507             fillAction = Load64ShiftInt52Left;
  508         else if (info.spillFormat() == DataFormatNone)
  509             fillAction = Load64;
  510         else {
  511             RELEASE_ASSERT_NOT_REACHED();
  512 #if COMPILER_QUIRK(CONSIDERS_UNREACHABLE_CODE)
  513             fillAction = Load64; // Make GCC happy.
  514 #endif
  515         }
  516     } else if (registerFormat == DataFormatStrictInt52) {
  517         if (node-&gt;hasConstant())
  518             fillAction = SetStrictInt52Constant;
  519         else if (info.spillFormat() == DataFormatInt52)
  520             fillAction = Load64ShiftInt52Right;
  521         else if (info.spillFormat() == DataFormatStrictInt52)
  522             fillAction = Load64;
  523         else if (info.spillFormat() == DataFormatNone)
  524             fillAction = Load64;
  525         else {
  526             RELEASE_ASSERT_NOT_REACHED();
  527 #if COMPILER_QUIRK(CONSIDERS_UNREACHABLE_CODE)
  528             fillAction = Load64; // Make GCC happy.
  529 #endif
  530         }
  531     } else {
  532         ASSERT(registerFormat &amp; DataFormatJS);
  533 #if USE(JSVALUE64)
  534         ASSERT(info.gpr() == source);
  535         if (node-&gt;hasConstant()) {
  536             if (node-&gt;isCellConstant())
  537                 fillAction = SetTrustedJSConstant;
  538             else
  539                 fillAction = SetJSConstant;
  540         } else if (info.spillFormat() == DataFormatInt32) {
  541             ASSERT(registerFormat == DataFormatJSInt32);
  542             fillAction = Load32PayloadBoxInt;
  543         } else
  544             fillAction = Load64;
  545 #else
  546         ASSERT(info.tagGPR() == source || info.payloadGPR() == source);
  547         if (node-&gt;hasConstant())
  548             fillAction = info.tagGPR() == source ? SetJSConstantTag : SetJSConstantPayload;
  549         else if (info.payloadGPR() == source)
  550             fillAction = Load32Payload;
  551         else { // Fill the Tag
  552             switch (info.spillFormat()) {
  553             case DataFormatInt32:
  554                 ASSERT(registerFormat == DataFormatJSInt32);
  555                 fillAction = SetInt32Tag;
  556                 break;
  557             case DataFormatCell:
  558                 ASSERT(registerFormat == DataFormatJSCell);
  559                 fillAction = SetCellTag;
  560                 break;
  561             case DataFormatBoolean:
  562                 ASSERT(registerFormat == DataFormatJSBoolean);
  563                 fillAction = SetBooleanTag;
  564                 break;
  565             default:
  566                 fillAction = Load32Tag;
  567                 break;
  568             }
  569         }
  570 #endif
  571     }
  572 
  573     return SilentRegisterSavePlan(spillAction, fillAction, node, source);
  574 }
  575 
  576 SilentRegisterSavePlan SpeculativeJIT::silentSavePlanForFPR(VirtualRegister spillMe, FPRReg source)
  577 {
  578     GenerationInfo&amp; info = generationInfoFromVirtualRegister(spillMe);
  579     Node* node = info.node();
  580     ASSERT(info.registerFormat() == DataFormatDouble);
  581 
  582     SilentSpillAction spillAction;
  583     SilentFillAction fillAction;
  584 
  585     if (!info.needsSpill())
  586         spillAction = DoNothingForSpill;
  587     else {
  588         ASSERT(!node-&gt;hasConstant());
  589         ASSERT(info.spillFormat() == DataFormatNone);
  590         ASSERT(info.fpr() == source);
  591         spillAction = StoreDouble;
  592     }
  593 
  594 #if USE(JSVALUE64)
  595     if (node-&gt;hasConstant()) {
  596         node-&gt;asNumber(); // To get the assertion.
  597         fillAction = SetDoubleConstant;
  598     } else {
  599         ASSERT(info.spillFormat() == DataFormatNone || info.spillFormat() == DataFormatDouble);
  600         fillAction = LoadDouble;
  601     }
  602 #elif USE(JSVALUE32_64)
  603     ASSERT(info.registerFormat() == DataFormatDouble);
  604     if (node-&gt;hasConstant()) {
  605         node-&gt;asNumber(); // To get the assertion.
  606         fillAction = SetDoubleConstant;
  607     } else
  608         fillAction = LoadDouble;
  609 #endif
  610 
  611     return SilentRegisterSavePlan(spillAction, fillAction, node, source);
  612 }
  613 
  614 void SpeculativeJIT::silentSpill(const SilentRegisterSavePlan&amp; plan)
  615 {
  616     switch (plan.spillAction()) {
  617     case DoNothingForSpill:
  618         break;
  619     case Store32Tag:
  620         m_jit.store32(plan.gpr(), JITCompiler::tagFor(plan.node()-&gt;virtualRegister()));
  621         break;
  622     case Store32Payload:
  623         m_jit.store32(plan.gpr(), JITCompiler::payloadFor(plan.node()-&gt;virtualRegister()));
  624         break;
  625     case StorePtr:
  626         m_jit.storePtr(plan.gpr(), JITCompiler::addressFor(plan.node()-&gt;virtualRegister()));
  627         break;
  628 #if USE(JSVALUE64)
  629     case Store64:
  630         m_jit.store64(plan.gpr(), JITCompiler::addressFor(plan.node()-&gt;virtualRegister()));
  631         break;
  632 #endif
  633     case StoreDouble:
  634         m_jit.storeDouble(plan.fpr(), JITCompiler::addressFor(plan.node()-&gt;virtualRegister()));
  635         break;
  636     default:
  637         RELEASE_ASSERT_NOT_REACHED();
  638     }
  639 }
  640 
  641 void SpeculativeJIT::silentFill(const SilentRegisterSavePlan&amp; plan)
  642 {
  643     switch (plan.fillAction()) {
  644     case DoNothingForFill:
  645         break;
  646     case SetInt32Constant:
  647         m_jit.move(Imm32(plan.node()-&gt;asInt32()), plan.gpr());
  648         break;
  649 #if USE(JSVALUE64)
  650     case SetInt52Constant:
  651         m_jit.move(Imm64(plan.node()-&gt;asAnyInt() &lt;&lt; JSValue::int52ShiftAmount), plan.gpr());
  652         break;
  653     case SetStrictInt52Constant:
  654         m_jit.move(Imm64(plan.node()-&gt;asAnyInt()), plan.gpr());
  655         break;
  656 #endif // USE(JSVALUE64)
  657     case SetBooleanConstant:
  658         m_jit.move(TrustedImm32(plan.node()-&gt;asBoolean()), plan.gpr());
  659         break;
  660     case SetCellConstant:
  661         ASSERT(plan.node()-&gt;constant()-&gt;value().isCell());
  662         m_jit.move(TrustedImmPtr(plan.node()-&gt;constant()), plan.gpr());
  663         break;
  664 #if USE(JSVALUE64)
  665     case SetTrustedJSConstant:
  666         m_jit.move(valueOfJSConstantAsImm64(plan.node()).asTrustedImm64(), plan.gpr());
  667         break;
  668     case SetJSConstant:
  669         m_jit.move(valueOfJSConstantAsImm64(plan.node()), plan.gpr());
  670         break;
  671     case SetDoubleConstant:
  672         m_jit.moveDouble(Imm64(reinterpretDoubleToInt64(plan.node()-&gt;asNumber())), plan.fpr());
  673         break;
  674     case Load32PayloadBoxInt:
  675         m_jit.load32(JITCompiler::payloadFor(plan.node()-&gt;virtualRegister()), plan.gpr());
<a name="5" id="anc5"></a><span class="line-modified">  676         m_jit.or64(GPRInfo::numberTagRegister, plan.gpr());</span>
  677         break;
  678     case Load32PayloadConvertToInt52:
  679         m_jit.load32(JITCompiler::payloadFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  680         m_jit.signExtend32ToPtr(plan.gpr(), plan.gpr());
  681         m_jit.lshift64(TrustedImm32(JSValue::int52ShiftAmount), plan.gpr());
  682         break;
  683     case Load32PayloadSignExtend:
  684         m_jit.load32(JITCompiler::payloadFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  685         m_jit.signExtend32ToPtr(plan.gpr(), plan.gpr());
  686         break;
  687 #else
  688     case SetJSConstantTag:
  689         m_jit.move(Imm32(plan.node()-&gt;asJSValue().tag()), plan.gpr());
  690         break;
  691     case SetJSConstantPayload:
  692         m_jit.move(Imm32(plan.node()-&gt;asJSValue().payload()), plan.gpr());
  693         break;
  694     case SetInt32Tag:
  695         m_jit.move(TrustedImm32(JSValue::Int32Tag), plan.gpr());
  696         break;
  697     case SetCellTag:
  698         m_jit.move(TrustedImm32(JSValue::CellTag), plan.gpr());
  699         break;
  700     case SetBooleanTag:
  701         m_jit.move(TrustedImm32(JSValue::BooleanTag), plan.gpr());
  702         break;
  703     case SetDoubleConstant:
  704         m_jit.loadDouble(TrustedImmPtr(m_jit.addressOfDoubleConstant(plan.node())), plan.fpr());
  705         break;
  706 #endif
  707     case Load32Tag:
  708         m_jit.load32(JITCompiler::tagFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  709         break;
  710     case Load32Payload:
  711         m_jit.load32(JITCompiler::payloadFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  712         break;
  713     case LoadPtr:
  714         m_jit.loadPtr(JITCompiler::addressFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  715         break;
  716 #if USE(JSVALUE64)
  717     case Load64:
  718         m_jit.load64(JITCompiler::addressFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  719         break;
  720     case Load64ShiftInt52Right:
  721         m_jit.load64(JITCompiler::addressFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  722         m_jit.rshift64(TrustedImm32(JSValue::int52ShiftAmount), plan.gpr());
  723         break;
  724     case Load64ShiftInt52Left:
  725         m_jit.load64(JITCompiler::addressFor(plan.node()-&gt;virtualRegister()), plan.gpr());
  726         m_jit.lshift64(TrustedImm32(JSValue::int52ShiftAmount), plan.gpr());
  727         break;
  728 #endif
  729     case LoadDouble:
  730         m_jit.loadDouble(JITCompiler::addressFor(plan.node()-&gt;virtualRegister()), plan.fpr());
  731         break;
  732     default:
  733         RELEASE_ASSERT_NOT_REACHED();
  734     }
  735 }
  736 
  737 JITCompiler::JumpList SpeculativeJIT::jumpSlowForUnwantedArrayMode(GPRReg tempGPR, ArrayMode arrayMode)
  738 {
  739     JITCompiler::JumpList result;
  740 
  741     IndexingType indexingModeMask = IsArray | IndexingShapeMask;
  742     if (arrayMode.action() == Array::Write)
  743         indexingModeMask |= CopyOnWrite;
  744 
  745     switch (arrayMode.type()) {
  746     case Array::Int32:
  747     case Array::Double:
  748     case Array::Contiguous:
  749     case Array::Undecided:
  750     case Array::ArrayStorage: {
  751         IndexingType shape = arrayMode.shapeMask();
  752         switch (arrayMode.arrayClass()) {
  753         case Array::OriginalArray:
  754         case Array::OriginalCopyOnWriteArray:
  755             RELEASE_ASSERT_NOT_REACHED();
  756             return result;
  757 
  758         case Array::Array:
  759             m_jit.and32(TrustedImm32(indexingModeMask), tempGPR);
  760             result.append(m_jit.branch32(
  761                 MacroAssembler::NotEqual, tempGPR, TrustedImm32(IsArray | shape)));
  762             return result;
  763 
  764         case Array::NonArray:
  765         case Array::OriginalNonArray:
  766             m_jit.and32(TrustedImm32(indexingModeMask), tempGPR);
  767             result.append(m_jit.branch32(
  768                 MacroAssembler::NotEqual, tempGPR, TrustedImm32(shape)));
  769             return result;
  770 
  771         case Array::PossiblyArray:
  772             m_jit.and32(TrustedImm32(indexingModeMask &amp; ~IsArray), tempGPR);
  773             result.append(m_jit.branch32(MacroAssembler::NotEqual, tempGPR, TrustedImm32(shape)));
  774             return result;
  775         }
  776 
  777         RELEASE_ASSERT_NOT_REACHED();
  778         return result;
  779     }
  780 
  781     case Array::SlowPutArrayStorage: {
  782         ASSERT(!arrayMode.isJSArrayWithOriginalStructure());
  783 
  784         switch (arrayMode.arrayClass()) {
  785         case Array::OriginalArray:
  786         case Array::OriginalCopyOnWriteArray:
  787             RELEASE_ASSERT_NOT_REACHED();
  788             return result;
  789 
  790         case Array::Array:
  791             result.append(
  792                 m_jit.branchTest32(
  793                     MacroAssembler::Zero, tempGPR, MacroAssembler::TrustedImm32(IsArray)));
  794             break;
  795 
  796         case Array::NonArray:
  797         case Array::OriginalNonArray:
  798             result.append(
  799                 m_jit.branchTest32(
  800                     MacroAssembler::NonZero, tempGPR, MacroAssembler::TrustedImm32(IsArray)));
  801             break;
  802 
  803         case Array::PossiblyArray:
  804             break;
  805         }
  806 
  807         m_jit.and32(TrustedImm32(IndexingShapeMask), tempGPR);
  808         m_jit.sub32(TrustedImm32(ArrayStorageShape), tempGPR);
  809         result.append(
  810             m_jit.branch32(
  811                 MacroAssembler::Above, tempGPR,
  812                 TrustedImm32(SlowPutArrayStorageShape - ArrayStorageShape)));
  813         return result;
  814     }
  815     default:
  816         CRASH();
  817         break;
  818     }
  819 
  820     return result;
  821 }
  822 
  823 void SpeculativeJIT::checkArray(Node* node)
  824 {
  825     ASSERT(node-&gt;arrayMode().isSpecific());
  826     ASSERT(!node-&gt;arrayMode().doesConversion());
  827 
  828     SpeculateCellOperand base(this, node-&gt;child1());
  829     GPRReg baseReg = base.gpr();
  830 
  831     if (node-&gt;arrayMode().alreadyChecked(m_jit.graph(), node, m_state.forNode(node-&gt;child1()))) {
<a name="6" id="anc6"></a><span class="line-added">  832         // We can purge Empty check completely in this case of CheckArrayOrEmpty since CellUse only accepts SpecCell | SpecEmpty.</span>
<span class="line-added">  833         ASSERT(typeFilterFor(node-&gt;child1().useKind()) &amp; SpecEmpty);</span>
  834         noResult(m_currentNode);
  835         return;
  836     }
  837 
<a name="7" id="anc7"></a><span class="line-added">  838     Optional&lt;GPRTemporary&gt; temp;</span>
<span class="line-added">  839     Optional&lt;GPRReg&gt; tempGPR;</span>
<span class="line-added">  840     switch (node-&gt;arrayMode().type()) {</span>
<span class="line-added">  841     case Array::Int32:</span>
<span class="line-added">  842     case Array::Double:</span>
<span class="line-added">  843     case Array::Contiguous:</span>
<span class="line-added">  844     case Array::Undecided:</span>
<span class="line-added">  845     case Array::ArrayStorage:</span>
<span class="line-added">  846     case Array::SlowPutArrayStorage: {</span>
<span class="line-added">  847         temp.emplace(this);</span>
<span class="line-added">  848         tempGPR = temp-&gt;gpr();</span>
<span class="line-added">  849         break;</span>
<span class="line-added">  850     }</span>
<span class="line-added">  851     default:</span>
<span class="line-added">  852         break;</span>
<span class="line-added">  853     }</span>
<span class="line-added">  854 </span>
<span class="line-added">  855     CCallHelpers::Jump isEmpty;</span>
<span class="line-added">  856 </span>
<span class="line-added">  857 #if USE(JSVALUE64)</span>
<span class="line-added">  858     if (node-&gt;op() == CheckArrayOrEmpty) {</span>
<span class="line-added">  859         if (m_interpreter.forNode(node-&gt;child1()).m_type &amp; SpecEmpty)</span>
<span class="line-added">  860             isEmpty = m_jit.branchIfEmpty(baseReg);</span>
<span class="line-added">  861     }</span>
<span class="line-added">  862 #endif</span>
<span class="line-added">  863 </span>
  864     switch (node-&gt;arrayMode().type()) {
  865     case Array::AnyTypedArray:
  866     case Array::String:
  867         RELEASE_ASSERT_NOT_REACHED(); // Should have been a Phantom(String:)
  868         return;
  869     case Array::Int32:
  870     case Array::Double:
  871     case Array::Contiguous:
  872     case Array::Undecided:
  873     case Array::ArrayStorage:
  874     case Array::SlowPutArrayStorage: {
<a name="8" id="anc8"></a><span class="line-modified">  875         m_jit.load8(MacroAssembler::Address(baseReg, JSCell::indexingTypeAndMiscOffset()), tempGPR.value());</span>


  876         speculationCheck(
  877             BadIndexingType, JSValueSource::unboxedCell(baseReg), 0,
<a name="9" id="anc9"></a><span class="line-modified">  878             jumpSlowForUnwantedArrayMode(tempGPR.value(), node-&gt;arrayMode()));</span>
<span class="line-modified">  879         break;</span>


  880     }
  881     case Array::DirectArguments:
  882         speculateCellTypeWithoutTypeFiltering(node-&gt;child1(), baseReg, DirectArgumentsType);
<a name="10" id="anc10"></a><span class="line-modified">  883         break;</span>

  884     case Array::ScopedArguments:
  885         speculateCellTypeWithoutTypeFiltering(node-&gt;child1(), baseReg, ScopedArgumentsType);
<a name="11" id="anc11"></a><span class="line-modified">  886         break;</span>

  887     default:
  888         speculateCellTypeWithoutTypeFiltering(
  889             node-&gt;child1(), baseReg,
  890             typeForTypedArrayType(node-&gt;arrayMode().typedArrayType()));
<a name="12" id="anc12"></a><span class="line-modified">  891         break;</span>

  892     }
<a name="13" id="anc13"></a><span class="line-added">  893 </span>
<span class="line-added">  894     if (isEmpty.isSet())</span>
<span class="line-added">  895         isEmpty.link(&amp;m_jit);</span>
<span class="line-added">  896     noResult(m_currentNode);</span>
  897 }
  898 
  899 void SpeculativeJIT::arrayify(Node* node, GPRReg baseReg, GPRReg propertyReg)
  900 {
  901     ASSERT(node-&gt;arrayMode().doesConversion());
  902 
  903     GPRTemporary temp(this);
  904     GPRTemporary structure;
  905     GPRReg tempGPR = temp.gpr();
  906     GPRReg structureGPR = InvalidGPRReg;
  907 
  908     if (node-&gt;op() != ArrayifyToStructure) {
  909         GPRTemporary realStructure(this);
  910         structure.adopt(realStructure);
  911         structureGPR = structure.gpr();
  912     }
  913 
  914     // We can skip all that comes next if we already have array storage.
  915     MacroAssembler::JumpList slowPath;
  916 
  917     if (node-&gt;op() == ArrayifyToStructure) {
  918         ASSERT(!isCopyOnWrite(node-&gt;structure()-&gt;indexingMode()));
  919         ASSERT((node-&gt;structure()-&gt;indexingType() &amp; IndexingShapeMask) == node-&gt;arrayMode().shapeMask());
  920         slowPath.append(m_jit.branchWeakStructure(
  921             JITCompiler::NotEqual,
  922             JITCompiler::Address(baseReg, JSCell::structureIDOffset()),
  923             node-&gt;structure()));
  924     } else {
  925         m_jit.load8(
  926             MacroAssembler::Address(baseReg, JSCell::indexingTypeAndMiscOffset()), tempGPR);
  927 
  928         slowPath.append(jumpSlowForUnwantedArrayMode(tempGPR, node-&gt;arrayMode()));
  929     }
  930 
  931     addSlowPathGenerator(makeUnique&lt;ArrayifySlowPathGenerator&gt;(
  932         slowPath, this, node, baseReg, propertyReg, tempGPR, structureGPR));
  933 
  934     noResult(m_currentNode);
  935 }
  936 
  937 void SpeculativeJIT::arrayify(Node* node)
  938 {
  939     ASSERT(node-&gt;arrayMode().isSpecific());
  940 
  941     SpeculateCellOperand base(this, node-&gt;child1());
  942 
  943     if (!node-&gt;child2()) {
  944         arrayify(node, base.gpr(), InvalidGPRReg);
  945         return;
  946     }
  947 
  948     SpeculateInt32Operand property(this, node-&gt;child2());
  949 
  950     arrayify(node, base.gpr(), property.gpr());
  951 }
  952 
  953 GPRReg SpeculativeJIT::fillStorage(Edge edge)
  954 {
  955     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
  956     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
  957 
  958     switch (info.registerFormat()) {
  959     case DataFormatNone: {
  960         if (info.spillFormat() == DataFormatStorage) {
  961             GPRReg gpr = allocate();
  962             m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
  963             m_jit.loadPtr(JITCompiler::addressFor(virtualRegister), gpr);
  964             info.fillStorage(*m_stream, gpr);
  965             return gpr;
  966         }
  967 
  968         // Must be a cell; fill it as a cell and then return the pointer.
  969         return fillSpeculateCell(edge);
  970     }
  971 
  972     case DataFormatStorage: {
  973         GPRReg gpr = info.gpr();
  974         m_gprs.lock(gpr);
  975         return gpr;
  976     }
  977 
  978     default:
  979         return fillSpeculateCell(edge);
  980     }
  981 }
  982 
  983 void SpeculativeJIT::useChildren(Node* node)
  984 {
  985     if (node-&gt;flags() &amp; NodeHasVarArgs) {
  986         for (unsigned childIdx = node-&gt;firstChild(); childIdx &lt; node-&gt;firstChild() + node-&gt;numChildren(); childIdx++) {
  987             if (!!m_jit.graph().m_varArgChildren[childIdx])
  988                 use(m_jit.graph().m_varArgChildren[childIdx]);
  989         }
  990     } else {
  991         Edge child1 = node-&gt;child1();
  992         if (!child1) {
  993             ASSERT(!node-&gt;child2() &amp;&amp; !node-&gt;child3());
  994             return;
  995         }
  996         use(child1);
  997 
  998         Edge child2 = node-&gt;child2();
  999         if (!child2) {
 1000             ASSERT(!node-&gt;child3());
 1001             return;
 1002         }
 1003         use(child2);
 1004 
 1005         Edge child3 = node-&gt;child3();
 1006         if (!child3)
 1007             return;
 1008         use(child3);
 1009     }
 1010 }
 1011 
 1012 void SpeculativeJIT::compileGetById(Node* node, AccessType accessType)
 1013 {
<a name="14" id="anc14"></a><span class="line-modified"> 1014     ASSERT(accessType == AccessType::GetById || accessType == AccessType::GetByIdDirect || accessType == AccessType::TryGetById);</span>
 1015 
 1016     switch (node-&gt;child1().useKind()) {
 1017     case CellUse: {
 1018         SpeculateCellOperand base(this, node-&gt;child1());
 1019         JSValueRegsTemporary result(this, Reuse, base);
 1020 
 1021         JSValueRegs baseRegs = JSValueRegs::payloadOnly(base.gpr());
 1022         JSValueRegs resultRegs = result.regs();
 1023 
 1024         base.use();
 1025 
 1026         cachedGetById(node-&gt;origin.semantic, baseRegs, resultRegs, node-&gt;identifierNumber(), JITCompiler::Jump(), NeedToSpill, accessType);
 1027 
 1028         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 1029         break;
 1030     }
 1031 
 1032     case UntypedUse: {
 1033         JSValueOperand base(this, node-&gt;child1());
 1034         JSValueRegsTemporary result(this, Reuse, base);
 1035 
 1036         JSValueRegs baseRegs = base.jsValueRegs();
 1037         JSValueRegs resultRegs = result.regs();
 1038 
 1039         base.use();
 1040 
 1041         JITCompiler::Jump notCell = m_jit.branchIfNotCell(baseRegs);
 1042 
 1043         cachedGetById(node-&gt;origin.semantic, baseRegs, resultRegs, node-&gt;identifierNumber(), notCell, NeedToSpill, accessType);
 1044 
 1045         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 1046         break;
 1047     }
 1048 
 1049     default:
 1050         DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
 1051         break;
 1052     }
 1053 }
 1054 
 1055 void SpeculativeJIT::compileGetByIdFlush(Node* node, AccessType accessType)
 1056 {
 1057     switch (node-&gt;child1().useKind()) {
 1058     case CellUse: {
 1059         SpeculateCellOperand base(this, node-&gt;child1());
 1060         JSValueRegs baseRegs = JSValueRegs::payloadOnly(base.gpr());
 1061 
 1062         JSValueRegsFlushedCallResult result(this);
 1063         JSValueRegs resultRegs = result.regs();
 1064 
 1065         base.use();
 1066 
 1067         flushRegisters();
 1068 
 1069         cachedGetById(node-&gt;origin.semantic, baseRegs, resultRegs, node-&gt;identifierNumber(), JITCompiler::Jump(), DontSpill, accessType);
 1070 
 1071         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 1072         break;
 1073     }
 1074 
 1075     case UntypedUse: {
 1076         JSValueOperand base(this, node-&gt;child1());
 1077         JSValueRegs baseRegs = base.jsValueRegs();
 1078 
 1079         JSValueRegsFlushedCallResult result(this);
 1080         JSValueRegs resultRegs = result.regs();
 1081 
 1082         base.use();
 1083 
 1084         flushRegisters();
 1085 
 1086         JITCompiler::Jump notCell = m_jit.branchIfNotCell(baseRegs);
 1087 
 1088         cachedGetById(node-&gt;origin.semantic, baseRegs, resultRegs, node-&gt;identifierNumber(), notCell, DontSpill, accessType);
 1089 
 1090         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 1091         break;
 1092     }
 1093 
 1094     default:
 1095         DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
 1096         break;
 1097     }
 1098 }
 1099 
 1100 void SpeculativeJIT::compileInById(Node* node)
 1101 {
 1102     SpeculateCellOperand base(this, node-&gt;child1());
 1103     JSValueRegsTemporary result(this, Reuse, base, PayloadWord);
 1104 
 1105     GPRReg baseGPR = base.gpr();
 1106     JSValueRegs resultRegs = result.regs();
 1107 
 1108     base.use();
 1109 
 1110     CodeOrigin codeOrigin = node-&gt;origin.semantic;
 1111     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
 1112     RegisterSet usedRegisters = this-&gt;usedRegisters();
 1113     JITInByIdGenerator gen(
 1114         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(node-&gt;identifierNumber()),
 1115         JSValueRegs::payloadOnly(baseGPR), resultRegs);
 1116     gen.generateFastPath(m_jit);
 1117 
 1118     auto slowPath = slowPathCall(
 1119         gen.slowPathJump(), this, operationInByIdOptimize,
 1120         NeedToSpill, ExceptionCheckRequirement::CheckNeeded,
<a name="15" id="anc15"></a><span class="line-modified"> 1121         resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), gen.stubInfo(), CCallHelpers::CellValue(baseGPR), identifierUID(node-&gt;identifierNumber()));</span>
 1122 
 1123     m_jit.addInById(gen, slowPath.get());
 1124     addSlowPathGenerator(WTFMove(slowPath));
 1125 
 1126     blessedBooleanResult(resultRegs.payloadGPR(), node, UseChildrenCalledExplicitly);
 1127 }
 1128 
 1129 void SpeculativeJIT::compileInByVal(Node* node)
 1130 {
 1131     SpeculateCellOperand base(this, node-&gt;child1());
 1132     JSValueOperand key(this, node-&gt;child2());
 1133 
 1134     GPRReg baseGPR = base.gpr();
 1135     JSValueRegs regs = key.jsValueRegs();
 1136 
 1137     base.use();
 1138     key.use();
 1139 
 1140     flushRegisters();
 1141     JSValueRegsFlushedCallResult result(this);
 1142     JSValueRegs resultRegs = result.regs();
<a name="16" id="anc16"></a><span class="line-modified"> 1143     callOperation(operationInByVal, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, regs);</span>
 1144     m_jit.exceptionCheck();
 1145     blessedBooleanResult(resultRegs.payloadGPR(), node, UseChildrenCalledExplicitly);
 1146 }
 1147 
 1148 void SpeculativeJIT::compileDeleteById(Node* node)
 1149 {
 1150     JSValueOperand value(this, node-&gt;child1());
 1151     GPRFlushedCallResult result(this);
 1152 
 1153     JSValueRegs valueRegs = value.jsValueRegs();
 1154     GPRReg resultGPR = result.gpr();
 1155 
 1156     value.use();
 1157 
 1158     flushRegisters();
<a name="17" id="anc17"></a><span class="line-modified"> 1159     callOperation(operationDeleteById, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs, identifierUID(node-&gt;identifierNumber()));</span>
 1160     m_jit.exceptionCheck();
 1161 
 1162     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
 1163 }
 1164 
 1165 void SpeculativeJIT::compileDeleteByVal(Node* node)
 1166 {
 1167     JSValueOperand base(this, node-&gt;child1());
 1168     JSValueOperand key(this, node-&gt;child2());
 1169     GPRFlushedCallResult result(this);
 1170 
 1171     JSValueRegs baseRegs = base.jsValueRegs();
 1172     JSValueRegs keyRegs = key.jsValueRegs();
 1173     GPRReg resultGPR = result.gpr();
 1174 
 1175     base.use();
 1176     key.use();
 1177 
 1178     flushRegisters();
<a name="18" id="anc18"></a><span class="line-modified"> 1179     callOperation(operationDeleteByVal, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseRegs, keyRegs);</span>
 1180     m_jit.exceptionCheck();
 1181 
 1182     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
 1183 }
 1184 
 1185 void SpeculativeJIT::compilePushWithScope(Node* node)
 1186 {
 1187     SpeculateCellOperand currentScope(this, node-&gt;child1());
 1188     GPRReg currentScopeGPR = currentScope.gpr();
 1189 
 1190     GPRFlushedCallResult result(this);
 1191     GPRReg resultGPR = result.gpr();
 1192 
 1193     auto objectEdge = node-&gt;child2();
 1194     if (objectEdge.useKind() == ObjectUse) {
 1195         SpeculateCellOperand object(this, objectEdge);
 1196         GPRReg objectGPR = object.gpr();
 1197         speculateObject(objectEdge, objectGPR);
 1198 
 1199         flushRegisters();
<a name="19" id="anc19"></a><span class="line-modified"> 1200         callOperation(operationPushWithScopeObject, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), currentScopeGPR, objectGPR);</span>
 1201         // No exception check here as we did not have to call toObject().
 1202     } else {
 1203         ASSERT(objectEdge.useKind() == UntypedUse);
 1204         JSValueOperand object(this, objectEdge);
 1205         JSValueRegs objectRegs = object.jsValueRegs();
 1206 
 1207         flushRegisters();
<a name="20" id="anc20"></a><span class="line-modified"> 1208         callOperation(operationPushWithScope, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), currentScopeGPR, objectRegs);</span>
 1209         m_jit.exceptionCheck();
 1210     }
 1211 
 1212     cellResult(resultGPR, node);
 1213 }
 1214 
 1215 bool SpeculativeJIT::nonSpeculativeStrictEq(Node* node, bool invert)
 1216 {
 1217     unsigned branchIndexInBlock = detectPeepHoleBranch();
 1218     if (branchIndexInBlock != UINT_MAX) {
 1219         Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 1220 
 1221         ASSERT(node-&gt;adjustedRefCount() == 1);
 1222 
 1223         nonSpeculativePeepholeStrictEq(node, branchNode, invert);
 1224 
 1225         m_indexInBlock = branchIndexInBlock;
 1226         m_currentNode = branchNode;
 1227 
 1228         return true;
 1229     }
 1230 
 1231     nonSpeculativeNonPeepholeStrictEq(node, invert);
 1232 
 1233     return false;
 1234 }
 1235 
 1236 static const char* dataFormatString(DataFormat format)
 1237 {
 1238     // These values correspond to the DataFormat enum.
 1239     const char* strings[] = {
 1240         &quot;[  ]&quot;,
 1241         &quot;[ i]&quot;,
 1242         &quot;[ d]&quot;,
 1243         &quot;[ c]&quot;,
 1244         &quot;Err!&quot;,
 1245         &quot;Err!&quot;,
 1246         &quot;Err!&quot;,
 1247         &quot;Err!&quot;,
 1248         &quot;[J ]&quot;,
 1249         &quot;[Ji]&quot;,
 1250         &quot;[Jd]&quot;,
 1251         &quot;[Jc]&quot;,
 1252         &quot;Err!&quot;,
 1253         &quot;Err!&quot;,
 1254         &quot;Err!&quot;,
 1255         &quot;Err!&quot;,
 1256     };
 1257     return strings[format];
 1258 }
 1259 
 1260 void SpeculativeJIT::dump(const char* label)
 1261 {
 1262     if (label)
 1263         dataLogF(&quot;&lt;%s&gt;\n&quot;, label);
 1264 
 1265     dataLogF(&quot;  gprs:\n&quot;);
 1266     m_gprs.dump();
 1267     dataLogF(&quot;  fprs:\n&quot;);
 1268     m_fprs.dump();
 1269     dataLogF(&quot;  VirtualRegisters:\n&quot;);
 1270     for (unsigned i = 0; i &lt; m_generationInfo.size(); ++i) {
 1271         GenerationInfo&amp; info = m_generationInfo[i];
 1272         if (info.alive())
 1273             dataLogF(&quot;    % 3d:%s%s&quot;, i, dataFormatString(info.registerFormat()), dataFormatString(info.spillFormat()));
 1274         else
 1275             dataLogF(&quot;    % 3d:[__][__]&quot;, i);
 1276         if (info.registerFormat() == DataFormatDouble)
 1277             dataLogF(&quot;:fpr%d\n&quot;, info.fpr());
 1278         else if (info.registerFormat() != DataFormatNone
 1279 #if USE(JSVALUE32_64)
 1280             &amp;&amp; !(info.registerFormat() &amp; DataFormatJS)
 1281 #endif
 1282             ) {
 1283             ASSERT(info.gpr() != InvalidGPRReg);
 1284             dataLogF(&quot;:%s\n&quot;, GPRInfo::debugName(info.gpr()));
 1285         } else
 1286             dataLogF(&quot;\n&quot;);
 1287     }
 1288     if (label)
 1289         dataLogF(&quot;&lt;/%s&gt;\n&quot;, label);
 1290 }
 1291 
 1292 GPRTemporary::GPRTemporary()
 1293     : m_jit(0)
 1294     , m_gpr(InvalidGPRReg)
 1295 {
 1296 }
 1297 
 1298 GPRTemporary::GPRTemporary(SpeculativeJIT* jit)
 1299     : m_jit(jit)
 1300     , m_gpr(InvalidGPRReg)
 1301 {
 1302     m_gpr = m_jit-&gt;allocate();
 1303 }
 1304 
 1305 GPRTemporary::GPRTemporary(SpeculativeJIT* jit, GPRReg specific)
 1306     : m_jit(jit)
 1307     , m_gpr(InvalidGPRReg)
 1308 {
 1309     m_gpr = m_jit-&gt;allocate(specific);
 1310 }
 1311 
 1312 #if USE(JSVALUE32_64)
 1313 GPRTemporary::GPRTemporary(
 1314     SpeculativeJIT* jit, ReuseTag, JSValueOperand&amp; op1, WhichValueWord which)
 1315     : m_jit(jit)
 1316     , m_gpr(InvalidGPRReg)
 1317 {
 1318     if (!op1.isDouble() &amp;&amp; m_jit-&gt;canReuse(op1.node()))
 1319         m_gpr = m_jit-&gt;reuse(op1.gpr(which));
 1320     else
 1321         m_gpr = m_jit-&gt;allocate();
 1322 }
 1323 #else // USE(JSVALUE32_64)
 1324 GPRTemporary::GPRTemporary(SpeculativeJIT* jit, ReuseTag, JSValueOperand&amp; op1, WhichValueWord)
 1325     : GPRTemporary(jit, Reuse, op1)
 1326 {
 1327 }
 1328 #endif
 1329 
 1330 JSValueRegsTemporary::JSValueRegsTemporary() { }
 1331 
 1332 JSValueRegsTemporary::JSValueRegsTemporary(SpeculativeJIT* jit)
 1333 #if USE(JSVALUE64)
 1334     : m_gpr(jit)
 1335 #else
 1336     : m_payloadGPR(jit)
 1337     , m_tagGPR(jit)
 1338 #endif
 1339 {
 1340 }
 1341 
 1342 #if USE(JSVALUE64)
 1343 template&lt;typename T&gt;
 1344 JSValueRegsTemporary::JSValueRegsTemporary(SpeculativeJIT* jit, ReuseTag, T&amp; operand, WhichValueWord)
 1345     : m_gpr(jit, Reuse, operand)
 1346 {
 1347 }
 1348 #else
 1349 template&lt;typename T&gt;
 1350 JSValueRegsTemporary::JSValueRegsTemporary(SpeculativeJIT* jit, ReuseTag, T&amp; operand, WhichValueWord resultWord)
 1351 {
 1352     if (resultWord == PayloadWord) {
 1353         m_payloadGPR = GPRTemporary(jit, Reuse, operand);
 1354         m_tagGPR = GPRTemporary(jit);
 1355     } else {
 1356         m_payloadGPR = GPRTemporary(jit);
 1357         m_tagGPR = GPRTemporary(jit, Reuse, operand);
 1358     }
 1359 }
 1360 #endif
 1361 
 1362 #if USE(JSVALUE64)
 1363 JSValueRegsTemporary::JSValueRegsTemporary(SpeculativeJIT* jit, ReuseTag, JSValueOperand&amp; operand)
 1364 {
 1365     m_gpr = GPRTemporary(jit, Reuse, operand);
 1366 }
 1367 #else
 1368 JSValueRegsTemporary::JSValueRegsTemporary(SpeculativeJIT* jit, ReuseTag, JSValueOperand&amp; operand)
 1369 {
 1370     if (jit-&gt;canReuse(operand.node())) {
 1371         m_payloadGPR = GPRTemporary(jit, Reuse, operand, PayloadWord);
 1372         m_tagGPR = GPRTemporary(jit, Reuse, operand, TagWord);
 1373     } else {
 1374         m_payloadGPR = GPRTemporary(jit);
 1375         m_tagGPR = GPRTemporary(jit);
 1376     }
 1377 }
 1378 #endif
 1379 
 1380 JSValueRegsTemporary::~JSValueRegsTemporary() { }
 1381 
 1382 JSValueRegs JSValueRegsTemporary::regs()
 1383 {
 1384 #if USE(JSVALUE64)
 1385     return JSValueRegs(m_gpr.gpr());
 1386 #else
 1387     return JSValueRegs(m_tagGPR.gpr(), m_payloadGPR.gpr());
 1388 #endif
 1389 }
 1390 
 1391 void GPRTemporary::adopt(GPRTemporary&amp; other)
 1392 {
 1393     ASSERT(!m_jit);
 1394     ASSERT(m_gpr == InvalidGPRReg);
 1395     ASSERT(other.m_jit);
 1396     ASSERT(other.m_gpr != InvalidGPRReg);
 1397     m_jit = other.m_jit;
 1398     m_gpr = other.m_gpr;
 1399     other.m_jit = 0;
 1400     other.m_gpr = InvalidGPRReg;
 1401 }
 1402 
 1403 FPRTemporary::FPRTemporary(FPRTemporary&amp;&amp; other)
 1404 {
 1405     ASSERT(other.m_jit);
 1406     ASSERT(other.m_fpr != InvalidFPRReg);
 1407     m_jit = other.m_jit;
 1408     m_fpr = other.m_fpr;
 1409 
 1410     other.m_jit = nullptr;
 1411 }
 1412 
 1413 FPRTemporary::FPRTemporary(SpeculativeJIT* jit)
 1414     : m_jit(jit)
 1415     , m_fpr(InvalidFPRReg)
 1416 {
 1417     m_fpr = m_jit-&gt;fprAllocate();
 1418 }
 1419 
 1420 FPRTemporary::FPRTemporary(SpeculativeJIT* jit, SpeculateDoubleOperand&amp; op1)
 1421     : m_jit(jit)
 1422     , m_fpr(InvalidFPRReg)
 1423 {
 1424     if (m_jit-&gt;canReuse(op1.node()))
 1425         m_fpr = m_jit-&gt;reuse(op1.fpr());
 1426     else
 1427         m_fpr = m_jit-&gt;fprAllocate();
 1428 }
 1429 
 1430 FPRTemporary::FPRTemporary(SpeculativeJIT* jit, SpeculateDoubleOperand&amp; op1, SpeculateDoubleOperand&amp; op2)
 1431     : m_jit(jit)
 1432     , m_fpr(InvalidFPRReg)
 1433 {
 1434     if (m_jit-&gt;canReuse(op1.node()))
 1435         m_fpr = m_jit-&gt;reuse(op1.fpr());
 1436     else if (m_jit-&gt;canReuse(op2.node()))
 1437         m_fpr = m_jit-&gt;reuse(op2.fpr());
 1438     else if (m_jit-&gt;canReuse(op1.node(), op2.node()) &amp;&amp; op1.fpr() == op2.fpr())
 1439         m_fpr = m_jit-&gt;reuse(op1.fpr());
 1440     else
 1441         m_fpr = m_jit-&gt;fprAllocate();
 1442 }
 1443 
 1444 #if USE(JSVALUE32_64)
 1445 FPRTemporary::FPRTemporary(SpeculativeJIT* jit, JSValueOperand&amp; op1)
 1446     : m_jit(jit)
 1447     , m_fpr(InvalidFPRReg)
 1448 {
 1449     if (op1.isDouble() &amp;&amp; m_jit-&gt;canReuse(op1.node()))
 1450         m_fpr = m_jit-&gt;reuse(op1.fpr());
 1451     else
 1452         m_fpr = m_jit-&gt;fprAllocate();
 1453 }
 1454 #endif
 1455 
 1456 void SpeculativeJIT::compilePeepHoleDoubleBranch(Node* node, Node* branchNode, JITCompiler::DoubleCondition condition)
 1457 {
 1458     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 1459     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 1460 
 1461     if (taken == nextBlock()) {
 1462         condition = MacroAssembler::invert(condition);
 1463         std::swap(taken, notTaken);
 1464     }
 1465 
 1466     SpeculateDoubleOperand op1(this, node-&gt;child1());
 1467     SpeculateDoubleOperand op2(this, node-&gt;child2());
 1468 
 1469     branchDouble(condition, op1.fpr(), op2.fpr(), taken);
 1470     jump(notTaken);
 1471 }
 1472 
 1473 void SpeculativeJIT::compilePeepHoleObjectEquality(Node* node, Node* branchNode)
 1474 {
 1475     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 1476     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 1477 
 1478     MacroAssembler::RelationalCondition condition = MacroAssembler::Equal;
 1479 
 1480     if (taken == nextBlock()) {
 1481         condition = MacroAssembler::NotEqual;
 1482         BasicBlock* tmp = taken;
 1483         taken = notTaken;
 1484         notTaken = tmp;
 1485     }
 1486 
 1487     SpeculateCellOperand op1(this, node-&gt;child1());
 1488     SpeculateCellOperand op2(this, node-&gt;child2());
 1489 
 1490     GPRReg op1GPR = op1.gpr();
 1491     GPRReg op2GPR = op2.gpr();
 1492 
 1493     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
 1494         if (m_state.forNode(node-&gt;child1()).m_type &amp; ~SpecObject) {
 1495             speculationCheck(
 1496                 BadType, JSValueSource::unboxedCell(op1GPR), node-&gt;child1(), m_jit.branchIfNotObject(op1GPR));
 1497         }
 1498         if (m_state.forNode(node-&gt;child2()).m_type &amp; ~SpecObject) {
 1499             speculationCheck(
 1500                 BadType, JSValueSource::unboxedCell(op2GPR), node-&gt;child2(), m_jit.branchIfNotObject(op2GPR));
 1501         }
 1502     } else {
 1503         if (m_state.forNode(node-&gt;child1()).m_type &amp; ~SpecObject) {
 1504             speculationCheck(
 1505                 BadType, JSValueSource::unboxedCell(op1GPR), node-&gt;child1(),
 1506                 m_jit.branchIfNotObject(op1GPR));
 1507         }
 1508         speculationCheck(BadType, JSValueSource::unboxedCell(op1GPR), node-&gt;child1(),
 1509             m_jit.branchTest8(
 1510                 MacroAssembler::NonZero,
 1511                 MacroAssembler::Address(op1GPR, JSCell::typeInfoFlagsOffset()),
 1512                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
 1513 
 1514         if (m_state.forNode(node-&gt;child2()).m_type &amp; ~SpecObject) {
 1515             speculationCheck(
 1516                 BadType, JSValueSource::unboxedCell(op2GPR), node-&gt;child2(),
 1517                 m_jit.branchIfNotObject(op2GPR));
 1518         }
 1519         speculationCheck(BadType, JSValueSource::unboxedCell(op2GPR), node-&gt;child2(),
 1520             m_jit.branchTest8(
 1521                 MacroAssembler::NonZero,
 1522                 MacroAssembler::Address(op2GPR, JSCell::typeInfoFlagsOffset()),
 1523                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
 1524     }
 1525 
 1526     branchPtr(condition, op1GPR, op2GPR, taken);
 1527     jump(notTaken);
 1528 }
 1529 
 1530 void SpeculativeJIT::compilePeepHoleBooleanBranch(Node* node, Node* branchNode, JITCompiler::RelationalCondition condition)
 1531 {
 1532     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 1533     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 1534 
 1535     // The branch instruction will branch to the taken block.
 1536     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
 1537     if (taken == nextBlock()) {
 1538         condition = JITCompiler::invert(condition);
 1539         BasicBlock* tmp = taken;
 1540         taken = notTaken;
 1541         notTaken = tmp;
 1542     }
 1543 
 1544     if (node-&gt;child1()-&gt;isInt32Constant()) {
 1545         int32_t imm = node-&gt;child1()-&gt;asInt32();
 1546         SpeculateBooleanOperand op2(this, node-&gt;child2());
 1547         branch32(condition, JITCompiler::Imm32(imm), op2.gpr(), taken);
 1548     } else if (node-&gt;child2()-&gt;isInt32Constant()) {
 1549         SpeculateBooleanOperand op1(this, node-&gt;child1());
 1550         int32_t imm = node-&gt;child2()-&gt;asInt32();
 1551         branch32(condition, op1.gpr(), JITCompiler::Imm32(imm), taken);
 1552     } else {
 1553         SpeculateBooleanOperand op1(this, node-&gt;child1());
 1554         SpeculateBooleanOperand op2(this, node-&gt;child2());
 1555         branch32(condition, op1.gpr(), op2.gpr(), taken);
 1556     }
 1557 
 1558     jump(notTaken);
 1559 }
 1560 
 1561 void SpeculativeJIT::compileStringSlice(Node* node)
 1562 {
 1563     SpeculateCellOperand string(this, node-&gt;child1());
 1564 
 1565     GPRReg stringGPR = string.gpr();
 1566 
 1567     speculateString(node-&gt;child1(), stringGPR);
 1568 
 1569     SpeculateInt32Operand start(this, node-&gt;child2());
 1570     GPRReg startGPR = start.gpr();
 1571 
 1572     Optional&lt;SpeculateInt32Operand&gt; end;
 1573     Optional&lt;GPRReg&gt; endGPR;
 1574     if (node-&gt;child3()) {
 1575         end.emplace(this, node-&gt;child3());
 1576         endGPR.emplace(end-&gt;gpr());
 1577     }
 1578 
 1579     GPRTemporary temp(this);
 1580     GPRTemporary temp2(this);
 1581     GPRTemporary startIndex(this);
 1582 
 1583     GPRReg tempGPR = temp.gpr();
 1584     GPRReg temp2GPR = temp2.gpr();
 1585     GPRReg startIndexGPR = startIndex.gpr();
 1586 
 1587     m_jit.loadPtr(CCallHelpers::Address(stringGPR, JSString::offsetOfValue()), tempGPR);
 1588     auto isRope = m_jit.branchIfRopeStringImpl(tempGPR);
 1589     {
 1590         m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), temp2GPR);
 1591 
 1592         emitPopulateSliceIndex(node-&gt;child2(), startGPR, temp2GPR, startIndexGPR);
 1593 
 1594         if (node-&gt;child3())
 1595             emitPopulateSliceIndex(node-&gt;child3(), endGPR.value(), temp2GPR, tempGPR);
 1596         else
 1597             m_jit.move(temp2GPR, tempGPR);
 1598     }
 1599 
 1600     CCallHelpers::JumpList doneCases;
 1601     CCallHelpers::JumpList slowCases;
 1602 
 1603     VM&amp; vm = this-&gt;vm();
 1604     auto nonEmptyCase = m_jit.branch32(MacroAssembler::Below, startIndexGPR, tempGPR);
 1605     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(vm)), tempGPR);
 1606     doneCases.append(m_jit.jump());
 1607 
 1608     nonEmptyCase.link(&amp;m_jit);
 1609     m_jit.sub32(startIndexGPR, tempGPR); // the size of the sliced string.
 1610     slowCases.append(m_jit.branch32(MacroAssembler::NotEqual, tempGPR, TrustedImm32(1)));
 1611 
 1612     // Refill StringImpl* here.
 1613     m_jit.loadPtr(MacroAssembler::Address(stringGPR, JSString::offsetOfValue()), temp2GPR);
 1614     m_jit.loadPtr(MacroAssembler::Address(temp2GPR, StringImpl::dataOffset()), tempGPR);
 1615 
 1616     // Load the character into scratchReg
 1617     m_jit.zeroExtend32ToPtr(startIndexGPR, startIndexGPR);
 1618     auto is16Bit = m_jit.branchTest32(MacroAssembler::Zero, MacroAssembler::Address(temp2GPR, StringImpl::flagsOffset()), TrustedImm32(StringImpl::flagIs8Bit()));
 1619 
 1620     m_jit.load8(MacroAssembler::BaseIndex(tempGPR, startIndexGPR, MacroAssembler::TimesOne, 0), tempGPR);
 1621     auto cont8Bit = m_jit.jump();
 1622 
 1623     is16Bit.link(&amp;m_jit);
 1624     m_jit.load16(MacroAssembler::BaseIndex(tempGPR, startIndexGPR, MacroAssembler::TimesTwo, 0), tempGPR);
 1625 
 1626     auto bigCharacter = m_jit.branch32(MacroAssembler::Above, tempGPR, TrustedImm32(maxSingleCharacterString));
 1627 
 1628     // 8 bit string values don&#39;t need the isASCII check.
 1629     cont8Bit.link(&amp;m_jit);
 1630 
 1631     m_jit.lshift32(MacroAssembler::TrustedImm32(sizeof(void*) == 4 ? 2 : 3), tempGPR);
 1632     m_jit.addPtr(TrustedImmPtr(vm.smallStrings.singleCharacterStrings()), tempGPR);
 1633     m_jit.loadPtr(tempGPR, tempGPR);
 1634 
<a name="21" id="anc21"></a><span class="line-modified"> 1635     addSlowPathGenerator(slowPathCall(bigCharacter, this, operationSingleCharacterString, tempGPR, &amp;vm, tempGPR));</span>
 1636 
<a name="22" id="anc22"></a><span class="line-modified"> 1637     addSlowPathGenerator(slowPathCall(slowCases, this, operationStringSubstr, tempGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), stringGPR, startIndexGPR, tempGPR));</span>
 1638 
 1639     if (endGPR)
<a name="23" id="anc23"></a><span class="line-modified"> 1640         addSlowPathGenerator(slowPathCall(isRope, this, operationStringSlice, tempGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), stringGPR, startGPR, *endGPR));</span>
 1641     else
<a name="24" id="anc24"></a><span class="line-modified"> 1642         addSlowPathGenerator(slowPathCall(isRope, this, operationStringSlice, tempGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), stringGPR, startGPR, TrustedImm32(std::numeric_limits&lt;int32_t&gt;::max())));</span>
 1643 
 1644     doneCases.link(&amp;m_jit);
 1645     cellResult(tempGPR, node);
 1646 }
 1647 
 1648 void SpeculativeJIT::compileToLowerCase(Node* node)
 1649 {
 1650     ASSERT(node-&gt;op() == ToLowerCase);
 1651     SpeculateCellOperand string(this, node-&gt;child1());
 1652     GPRTemporary temp(this);
 1653     GPRTemporary index(this);
 1654     GPRTemporary charReg(this);
 1655     GPRTemporary length(this);
 1656 
 1657     GPRReg stringGPR = string.gpr();
 1658     GPRReg tempGPR = temp.gpr();
 1659     GPRReg indexGPR = index.gpr();
 1660     GPRReg charGPR = charReg.gpr();
 1661     GPRReg lengthGPR = length.gpr();
 1662 
 1663     speculateString(node-&gt;child1(), stringGPR);
 1664 
 1665     CCallHelpers::JumpList slowPath;
 1666 
 1667     m_jit.move(TrustedImmPtr(nullptr), indexGPR);
 1668 
 1669     m_jit.loadPtr(MacroAssembler::Address(stringGPR, JSString::offsetOfValue()), tempGPR);
 1670     slowPath.append(m_jit.branchIfRopeStringImpl(tempGPR));
 1671     slowPath.append(m_jit.branchTest32(
 1672         MacroAssembler::Zero, MacroAssembler::Address(tempGPR, StringImpl::flagsOffset()),
 1673         MacroAssembler::TrustedImm32(StringImpl::flagIs8Bit())));
 1674     m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), lengthGPR);
 1675     m_jit.loadPtr(MacroAssembler::Address(tempGPR, StringImpl::dataOffset()), tempGPR);
 1676 
 1677     auto loopStart = m_jit.label();
 1678     auto loopDone = m_jit.branch32(CCallHelpers::AboveOrEqual, indexGPR, lengthGPR);
 1679     m_jit.load8(MacroAssembler::BaseIndex(tempGPR, indexGPR, MacroAssembler::TimesOne), charGPR);
 1680     slowPath.append(m_jit.branchTest32(CCallHelpers::NonZero, charGPR, TrustedImm32(~0x7F)));
 1681     m_jit.sub32(TrustedImm32(&#39;A&#39;), charGPR);
 1682     slowPath.append(m_jit.branch32(CCallHelpers::BelowOrEqual, charGPR, TrustedImm32(&#39;Z&#39; - &#39;A&#39;)));
 1683 
 1684     m_jit.add32(TrustedImm32(1), indexGPR);
 1685     m_jit.jump().linkTo(loopStart, &amp;m_jit);
 1686 
 1687     slowPath.link(&amp;m_jit);
 1688     silentSpillAllRegisters(lengthGPR);
<a name="25" id="anc25"></a><span class="line-modified"> 1689     callOperation(operationToLowerCase, lengthGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), stringGPR, indexGPR);</span>
 1690     silentFillAllRegisters();
 1691     m_jit.exceptionCheck();
 1692     auto done = m_jit.jump();
 1693 
 1694     loopDone.link(&amp;m_jit);
 1695     m_jit.move(stringGPR, lengthGPR);
 1696 
 1697     done.link(&amp;m_jit);
 1698     cellResult(lengthGPR, node);
 1699 }
 1700 
 1701 void SpeculativeJIT::compilePeepHoleInt32Branch(Node* node, Node* branchNode, JITCompiler::RelationalCondition condition)
 1702 {
 1703     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 1704     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 1705 
 1706     // The branch instruction will branch to the taken block.
 1707     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
 1708     if (taken == nextBlock()) {
 1709         condition = JITCompiler::invert(condition);
 1710         BasicBlock* tmp = taken;
 1711         taken = notTaken;
 1712         notTaken = tmp;
 1713     }
 1714 
 1715     if (node-&gt;child1()-&gt;isInt32Constant()) {
 1716         int32_t imm = node-&gt;child1()-&gt;asInt32();
 1717         SpeculateInt32Operand op2(this, node-&gt;child2());
 1718         branch32(condition, JITCompiler::Imm32(imm), op2.gpr(), taken);
 1719     } else if (node-&gt;child2()-&gt;isInt32Constant()) {
 1720         SpeculateInt32Operand op1(this, node-&gt;child1());
 1721         int32_t imm = node-&gt;child2()-&gt;asInt32();
 1722         branch32(condition, op1.gpr(), JITCompiler::Imm32(imm), taken);
 1723     } else {
 1724         SpeculateInt32Operand op1(this, node-&gt;child1());
 1725         SpeculateInt32Operand op2(this, node-&gt;child2());
 1726         branch32(condition, op1.gpr(), op2.gpr(), taken);
 1727     }
 1728 
 1729     jump(notTaken);
 1730 }
 1731 
 1732 // Returns true if the compare is fused with a subsequent branch.
<a name="26" id="anc26"></a><span class="line-modified"> 1733 bool SpeculativeJIT::compilePeepHoleBranch(Node* node, MacroAssembler::RelationalCondition condition, MacroAssembler::DoubleCondition doubleCondition, S_JITOperation_GJJ operation)</span>
 1734 {
 1735     // Fused compare &amp; branch.
 1736     unsigned branchIndexInBlock = detectPeepHoleBranch();
 1737     if (branchIndexInBlock != UINT_MAX) {
 1738         Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 1739 
 1740         // detectPeepHoleBranch currently only permits the branch to be the very next node,
 1741         // so can be no intervening nodes to also reference the compare.
 1742         ASSERT(node-&gt;adjustedRefCount() == 1);
 1743 
 1744         if (node-&gt;isBinaryUseKind(Int32Use))
 1745             compilePeepHoleInt32Branch(node, branchNode, condition);
 1746 #if USE(JSVALUE64)
 1747         else if (node-&gt;isBinaryUseKind(Int52RepUse))
 1748             compilePeepHoleInt52Branch(node, branchNode, condition);
 1749 #endif // USE(JSVALUE64)
 1750         else if (node-&gt;isBinaryUseKind(StringUse) || node-&gt;isBinaryUseKind(StringIdentUse)) {
 1751             // Use non-peephole comparison, for now.
 1752             return false;
 1753         } else if (node-&gt;isBinaryUseKind(DoubleRepUse))
 1754             compilePeepHoleDoubleBranch(node, branchNode, doubleCondition);
 1755         else if (node-&gt;op() == CompareEq) {
 1756             if (node-&gt;isBinaryUseKind(BooleanUse))
 1757                 compilePeepHoleBooleanBranch(node, branchNode, condition);
 1758             else if (node-&gt;isBinaryUseKind(SymbolUse))
 1759                 compilePeepHoleSymbolEquality(node, branchNode);
 1760             else if (node-&gt;isBinaryUseKind(ObjectUse))
 1761                 compilePeepHoleObjectEquality(node, branchNode);
 1762             else if (node-&gt;isBinaryUseKind(ObjectUse, ObjectOrOtherUse))
 1763                 compilePeepHoleObjectToObjectOrOtherEquality(node-&gt;child1(), node-&gt;child2(), branchNode);
 1764             else if (node-&gt;isBinaryUseKind(ObjectOrOtherUse, ObjectUse))
 1765                 compilePeepHoleObjectToObjectOrOtherEquality(node-&gt;child2(), node-&gt;child1(), branchNode);
 1766             else if (!needsTypeCheck(node-&gt;child1(), SpecOther))
 1767                 nonSpeculativePeepholeBranchNullOrUndefined(node-&gt;child2(), branchNode);
 1768             else if (!needsTypeCheck(node-&gt;child2(), SpecOther))
 1769                 nonSpeculativePeepholeBranchNullOrUndefined(node-&gt;child1(), branchNode);
 1770             else {
 1771                 nonSpeculativePeepholeBranch(node, branchNode, condition, operation);
 1772                 return true;
 1773             }
 1774         } else {
 1775             nonSpeculativePeepholeBranch(node, branchNode, condition, operation);
 1776             return true;
 1777         }
 1778 
 1779         use(node-&gt;child1());
 1780         use(node-&gt;child2());
 1781         m_indexInBlock = branchIndexInBlock;
 1782         m_currentNode = branchNode;
 1783         return true;
 1784     }
 1785     return false;
 1786 }
 1787 
 1788 void SpeculativeJIT::noticeOSRBirth(Node* node)
 1789 {
 1790     if (!node-&gt;hasVirtualRegister())
 1791         return;
 1792 
 1793     VirtualRegister virtualRegister = node-&gt;virtualRegister();
 1794     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
 1795 
 1796     info.noticeOSRBirth(*m_stream, node, virtualRegister);
 1797 }
 1798 
 1799 void SpeculativeJIT::compileMovHint(Node* node)
 1800 {
 1801     ASSERT(node-&gt;containsMovHint() &amp;&amp; node-&gt;op() != ZombieHint);
 1802 
 1803     Node* child = node-&gt;child1().node();
 1804     noticeOSRBirth(child);
 1805 
<a name="27" id="anc27"></a><span class="line-modified"> 1806     m_stream-&gt;appendAndLog(VariableEvent::movHint(MinifiedID(child), node-&gt;unlinkedOperand()));</span>
<span class="line-added"> 1807 }</span>
<span class="line-added"> 1808 </span>
<span class="line-added"> 1809 void SpeculativeJIT::compileCheckNeutered(Node* node)</span>
<span class="line-added"> 1810 {</span>
<span class="line-added"> 1811     SpeculateCellOperand base(this, node-&gt;child1());</span>
<span class="line-added"> 1812     GPRReg baseReg = base.gpr();</span>
<span class="line-added"> 1813 </span>
<span class="line-added"> 1814     speculationCheck(</span>
<span class="line-added"> 1815         BadIndexingType, JSValueSource::unboxedCell(baseReg), node-&gt;child1(),</span>
<span class="line-added"> 1816         m_jit.branchTestPtr(MacroAssembler::Zero, MacroAssembler::Address(baseReg, JSArrayBufferView::offsetOfVector())));</span>
<span class="line-added"> 1817 </span>
<span class="line-added"> 1818     noResult(node);</span>
 1819 }
 1820 
 1821 void SpeculativeJIT::bail(AbortReason reason)
 1822 {
 1823     if (verboseCompilationEnabled())
 1824         dataLog(&quot;Bailing compilation.\n&quot;);
 1825     m_compileOkay = true;
 1826     m_jit.abortWithReason(reason, m_lastGeneratedNode);
 1827     clearGenerationInfo();
 1828 }
 1829 
 1830 void SpeculativeJIT::compileCurrentBlock()
 1831 {
 1832     ASSERT(m_compileOkay);
 1833 
 1834     if (!m_block)
 1835         return;
 1836 
 1837     ASSERT(m_block-&gt;isReachable);
 1838 
 1839     m_jit.blockHeads()[m_block-&gt;index] = m_jit.label();
 1840 
 1841     if (!m_block-&gt;intersectionOfCFAHasVisited) {
 1842         // Don&#39;t generate code for basic blocks that are unreachable according to CFA.
 1843         // But to be sure that nobody has generated a jump to this block, drop in a
 1844         // breakpoint here.
 1845         m_jit.abortWithReason(DFGUnreachableBasicBlock);
 1846         return;
 1847     }
 1848 
 1849     if (m_block-&gt;isCatchEntrypoint) {
 1850         m_jit.addPtr(CCallHelpers::TrustedImm32(-(m_jit.graph().frameRegisterCount() * sizeof(Register))), GPRInfo::callFrameRegister,  CCallHelpers::stackPointerRegister);
<a name="28" id="anc28"></a>

 1851         m_jit.emitSaveCalleeSaves();
 1852         m_jit.emitMaterializeTagCheckRegisters();
 1853         m_jit.emitPutToCallFrameHeader(m_jit.codeBlock(), CallFrameSlot::codeBlock);
 1854     }
 1855 
 1856     m_stream-&gt;appendAndLog(VariableEvent::reset());
 1857 
 1858     m_jit.jitAssertHasValidCallFrame();
 1859     m_jit.jitAssertTagsInPlace();
 1860     m_jit.jitAssertArgumentCountSane();
 1861 
 1862     m_state.reset();
 1863     m_state.beginBasicBlock(m_block);
 1864 
 1865     for (size_t i = m_block-&gt;variablesAtHead.size(); i--;) {
<a name="29" id="anc29"></a><span class="line-modified"> 1866         Operand operand = m_block-&gt;variablesAtHead.operandForIndex(i);</span>
 1867         Node* node = m_block-&gt;variablesAtHead[i];
 1868         if (!node)
 1869             continue; // No need to record dead SetLocal&#39;s.
 1870 
 1871         VariableAccessData* variable = node-&gt;variableAccessData();
 1872         DataFormat format;
 1873         if (!node-&gt;refCount())
 1874             continue; // No need to record dead SetLocal&#39;s.
 1875         format = dataFormatFor(variable-&gt;flushFormat());
<a name="30" id="anc30"></a><span class="line-modified"> 1876         DFG_ASSERT(m_jit.graph(), node, !operand.isArgument() || operand.virtualRegister().toArgument() &gt;= 0);</span>
<span class="line-modified"> 1877         m_stream-&gt;appendAndLog(VariableEvent::setLocal(operand, variable-&gt;machineLocal(), format));</span>



 1878     }
 1879 
 1880     m_origin = NodeOrigin();
 1881 
 1882     for (m_indexInBlock = 0; m_indexInBlock &lt; m_block-&gt;size(); ++m_indexInBlock) {
 1883         m_currentNode = m_block-&gt;at(m_indexInBlock);
 1884 
 1885         // We may have hit a contradiction that the CFA was aware of but that the JIT
 1886         // didn&#39;t cause directly.
 1887         if (!m_state.isValid()) {
 1888             bail(DFGBailedAtTopOfBlock);
 1889             return;
 1890         }
 1891 
 1892         m_interpreter.startExecuting();
 1893         m_interpreter.executeKnownEdgeTypes(m_currentNode);
 1894         m_jit.setForNode(m_currentNode);
 1895         m_origin = m_currentNode-&gt;origin;
 1896         m_lastGeneratedNode = m_currentNode-&gt;op();
 1897 
 1898         ASSERT(m_currentNode-&gt;shouldGenerate());
 1899 
<a name="31" id="anc31"></a><span class="line-modified"> 1900         if (verboseCompilationEnabled())</span>
<span class="line-modified"> 1901             dataLogLn(&quot;SpeculativeJIT generating Node @&quot;, (int)m_currentNode-&gt;index(), &quot; (&quot;, m_currentNode-&gt;origin.semantic.bytecodeIndex().offset(), &quot;) at JIT offset 0x&quot;, m_jit.debugOffset());</span>





 1902 
 1903         if (Options::validateDFGExceptionHandling() &amp;&amp; (mayExit(m_jit.graph(), m_currentNode) != DoesNotExit || m_currentNode-&gt;isTerminal()))
 1904             m_jit.jitReleaseAssertNoException(m_jit.vm());
 1905 
 1906         m_jit.pcToCodeOriginMapBuilder().appendItem(m_jit.labelIgnoringWatchpoints(), m_origin.semantic);
 1907 
 1908         compile(m_currentNode);
 1909 
 1910         if (belongsInMinifiedGraph(m_currentNode-&gt;op()))
 1911             m_minifiedGraph-&gt;append(MinifiedNode::fromNode(m_currentNode));
 1912 
 1913 #if ENABLE(DFG_REGISTER_ALLOCATION_VALIDATION)
 1914         m_jit.clearRegisterAllocationOffsets();
 1915 #endif
 1916 
 1917         if (!m_compileOkay) {
 1918             bail(DFGBailedAtEndOfNode);
 1919             return;
 1920         }
 1921 
 1922         // Make sure that the abstract state is rematerialized for the next node.
 1923         m_interpreter.executeEffects(m_indexInBlock);
 1924     }
 1925 
 1926     // Perform the most basic verification that children have been used correctly.
<a name="32" id="anc32"></a><span class="line-modified"> 1927     if (ASSERT_ENABLED) {</span>
 1928         for (auto&amp; info : m_generationInfo)
 1929             RELEASE_ASSERT(!info.alive());
 1930     }
 1931 }
 1932 
 1933 // If we are making type predictions about our arguments then
 1934 // we need to check that they are correct on function entry.
 1935 void SpeculativeJIT::checkArgumentTypes()
 1936 {
 1937     ASSERT(!m_currentNode);
<a name="33" id="anc33"></a><span class="line-modified"> 1938     m_origin = NodeOrigin(CodeOrigin(BytecodeIndex(0)), CodeOrigin(BytecodeIndex(0)), true);</span>
 1939 
 1940     auto&amp; arguments = m_jit.graph().m_rootToArguments.find(m_jit.graph().block(0))-&gt;value;
 1941     for (int i = 0; i &lt; m_jit.codeBlock()-&gt;numParameters(); ++i) {
 1942         Node* node = arguments[i];
 1943         if (!node) {
 1944             // The argument is dead. We don&#39;t do any checks for such arguments.
 1945             continue;
 1946         }
 1947 
 1948         ASSERT(node-&gt;op() == SetArgumentDefinitely);
 1949         ASSERT(node-&gt;shouldGenerate());
 1950 
 1951         VariableAccessData* variableAccessData = node-&gt;variableAccessData();
 1952         FlushFormat format = variableAccessData-&gt;flushFormat();
 1953 
 1954         if (format == FlushedJSValue)
 1955             continue;
 1956 
<a name="34" id="anc34"></a><span class="line-modified"> 1957         VirtualRegister virtualRegister = variableAccessData-&gt;operand().virtualRegister();</span>
<span class="line-added"> 1958         ASSERT(virtualRegister.isArgument());</span>
 1959 
 1960         JSValueSource valueSource = JSValueSource(JITCompiler::addressFor(virtualRegister));
 1961 
 1962 #if USE(JSVALUE64)
 1963         switch (format) {
 1964         case FlushedInt32: {
<a name="35" id="anc35"></a><span class="line-modified"> 1965             speculationCheck(BadType, valueSource, node, m_jit.branch64(MacroAssembler::Below, JITCompiler::addressFor(virtualRegister), GPRInfo::numberTagRegister));</span>
 1966             break;
 1967         }
 1968         case FlushedBoolean: {
 1969             GPRTemporary temp(this);
 1970             m_jit.load64(JITCompiler::addressFor(virtualRegister), temp.gpr());
<a name="36" id="anc36"></a><span class="line-modified"> 1971             m_jit.xor64(TrustedImm32(JSValue::ValueFalse), temp.gpr());</span>
 1972             speculationCheck(BadType, valueSource, node, m_jit.branchTest64(MacroAssembler::NonZero, temp.gpr(), TrustedImm32(static_cast&lt;int32_t&gt;(~1))));
 1973             break;
 1974         }
 1975         case FlushedCell: {
<a name="37" id="anc37"></a><span class="line-modified"> 1976             speculationCheck(BadType, valueSource, node, m_jit.branchTest64(MacroAssembler::NonZero, JITCompiler::addressFor(virtualRegister), GPRInfo::notCellMaskRegister));</span>
 1977             break;
 1978         }
 1979         default:
 1980             RELEASE_ASSERT_NOT_REACHED();
 1981             break;
 1982         }
 1983 #else
 1984         switch (format) {
 1985         case FlushedInt32: {
 1986             speculationCheck(BadType, valueSource, node, m_jit.branch32(MacroAssembler::NotEqual, JITCompiler::tagFor(virtualRegister), TrustedImm32(JSValue::Int32Tag)));
 1987             break;
 1988         }
 1989         case FlushedBoolean: {
 1990             speculationCheck(BadType, valueSource, node, m_jit.branch32(MacroAssembler::NotEqual, JITCompiler::tagFor(virtualRegister), TrustedImm32(JSValue::BooleanTag)));
 1991             break;
 1992         }
 1993         case FlushedCell: {
 1994             speculationCheck(BadType, valueSource, node, m_jit.branch32(MacroAssembler::NotEqual, JITCompiler::tagFor(virtualRegister), TrustedImm32(JSValue::CellTag)));
 1995             break;
 1996         }
 1997         default:
 1998             RELEASE_ASSERT_NOT_REACHED();
 1999             break;
 2000         }
 2001 #endif
 2002     }
 2003 
 2004     m_origin = NodeOrigin();
 2005 }
 2006 
 2007 bool SpeculativeJIT::compile()
 2008 {
 2009     checkArgumentTypes();
 2010 
 2011     ASSERT(!m_currentNode);
 2012     for (BlockIndex blockIndex = 0; blockIndex &lt; m_jit.graph().numBlocks(); ++blockIndex) {
 2013         m_jit.setForBlockIndex(blockIndex);
 2014         m_block = m_jit.graph().block(blockIndex);
 2015         compileCurrentBlock();
 2016     }
 2017     linkBranches();
 2018     return true;
 2019 }
 2020 
 2021 void SpeculativeJIT::createOSREntries()
 2022 {
 2023     for (BlockIndex blockIndex = 0; blockIndex &lt; m_jit.graph().numBlocks(); ++blockIndex) {
 2024         BasicBlock* block = m_jit.graph().block(blockIndex);
 2025         if (!block)
 2026             continue;
 2027         if (block-&gt;isOSRTarget || block-&gt;isCatchEntrypoint) {
 2028             // Currently we don&#39;t have OSR entry trampolines. We could add them
 2029             // here if need be.
 2030             m_osrEntryHeads.append(m_jit.blockHeads()[blockIndex]);
 2031         }
 2032     }
 2033 }
 2034 
 2035 void SpeculativeJIT::linkOSREntries(LinkBuffer&amp; linkBuffer)
 2036 {
 2037     unsigned osrEntryIndex = 0;
 2038     for (BlockIndex blockIndex = 0; blockIndex &lt; m_jit.graph().numBlocks(); ++blockIndex) {
 2039         BasicBlock* block = m_jit.graph().block(blockIndex);
 2040         if (!block)
 2041             continue;
 2042         if (!block-&gt;isOSRTarget &amp;&amp; !block-&gt;isCatchEntrypoint)
 2043             continue;
 2044         if (block-&gt;isCatchEntrypoint) {
 2045             auto&amp; argumentsVector = m_jit.graph().m_rootToArguments.find(block)-&gt;value;
 2046             Vector&lt;FlushFormat&gt; argumentFormats;
 2047             argumentFormats.reserveInitialCapacity(argumentsVector.size());
 2048             for (Node* setArgument : argumentsVector) {
 2049                 if (setArgument) {
 2050                     FlushFormat flushFormat = setArgument-&gt;variableAccessData()-&gt;flushFormat();
 2051                     ASSERT(flushFormat == FlushedInt32 || flushFormat == FlushedCell || flushFormat == FlushedBoolean || flushFormat == FlushedJSValue);
 2052                     argumentFormats.uncheckedAppend(flushFormat);
 2053                 } else
 2054                     argumentFormats.uncheckedAppend(DeadFlush);
 2055             }
 2056             m_jit.noticeCatchEntrypoint(*block, m_osrEntryHeads[osrEntryIndex++], linkBuffer, WTFMove(argumentFormats));
 2057         } else {
 2058             ASSERT(block-&gt;isOSRTarget);
 2059             m_jit.noticeOSREntry(*block, m_osrEntryHeads[osrEntryIndex++], linkBuffer);
 2060         }
 2061     }
 2062 
 2063     m_jit.jitCode()-&gt;finalizeOSREntrypoints();
 2064     m_jit.jitCode()-&gt;common.finalizeCatchEntrypoints();
 2065 
 2066     ASSERT(osrEntryIndex == m_osrEntryHeads.size());
 2067 
 2068     if (verboseCompilationEnabled()) {
 2069         DumpContext dumpContext;
 2070         dataLog(&quot;OSR Entries:\n&quot;);
 2071         for (OSREntryData&amp; entryData : m_jit.jitCode()-&gt;osrEntry)
 2072             dataLog(&quot;    &quot;, inContext(entryData, &amp;dumpContext), &quot;\n&quot;);
 2073         if (!dumpContext.isEmpty())
 2074             dumpContext.dump(WTF::dataFile());
 2075     }
 2076 }
 2077 
 2078 void SpeculativeJIT::compileCheckTraps(Node* node)
 2079 {
 2080     ASSERT(Options::usePollingTraps());
 2081     GPRTemporary unused(this);
 2082     GPRReg unusedGPR = unused.gpr();
 2083 
 2084     JITCompiler::Jump needTrapHandling = m_jit.branchTest8(JITCompiler::NonZero,
 2085         JITCompiler::AbsoluteAddress(m_jit.vm().needTrapHandlingAddress()));
 2086 
<a name="38" id="anc38"></a><span class="line-modified"> 2087     addSlowPathGenerator(slowPathCall(needTrapHandling, this, operationHandleTraps, unusedGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic))));</span>
 2088     noResult(node);
 2089 }
 2090 
 2091 void SpeculativeJIT::compileDoublePutByVal(Node* node, SpeculateCellOperand&amp; base, SpeculateStrictInt32Operand&amp; property)
 2092 {
 2093     Edge child3 = m_jit.graph().varArgChild(node, 2);
 2094     Edge child4 = m_jit.graph().varArgChild(node, 3);
 2095 
 2096     ArrayMode arrayMode = node-&gt;arrayMode();
 2097 
 2098     GPRReg baseReg = base.gpr();
 2099     GPRReg propertyReg = property.gpr();
 2100 
 2101     SpeculateDoubleOperand value(this, child3);
 2102 
 2103     FPRReg valueReg = value.fpr();
 2104 
 2105     DFG_TYPE_CHECK(
 2106         JSValueRegs(), child3, SpecFullRealNumber,
 2107         m_jit.branchIfNaN(valueReg));
 2108 
 2109     if (!m_compileOkay)
 2110         return;
 2111 
 2112     StorageOperand storage(this, child4);
 2113     GPRReg storageReg = storage.gpr();
 2114 
 2115     if (node-&gt;op() == PutByValAlias) {
 2116         // Store the value to the array.
 2117         GPRReg propertyReg = property.gpr();
 2118         FPRReg valueReg = value.fpr();
 2119         m_jit.storeDouble(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight));
 2120 
 2121         noResult(m_currentNode);
 2122         return;
 2123     }
 2124 
 2125     GPRTemporary temporary;
 2126     GPRReg temporaryReg = temporaryRegisterForPutByVal(temporary, node);
 2127 
 2128     MacroAssembler::Jump slowCase;
 2129 
 2130     if (arrayMode.isInBounds()) {
 2131         speculationCheck(
 2132             OutOfBounds, JSValueRegs(), 0,
 2133             m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
 2134     } else {
 2135         MacroAssembler::Jump inBounds = m_jit.branch32(MacroAssembler::Below, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
 2136 
 2137         slowCase = m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfVectorLength()));
 2138 
 2139         if (!arrayMode.isOutOfBounds())
 2140             speculationCheck(OutOfBounds, JSValueRegs(), 0, slowCase);
 2141 
 2142         m_jit.add32(TrustedImm32(1), propertyReg, temporaryReg);
 2143         m_jit.store32(temporaryReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
 2144 
 2145         inBounds.link(&amp;m_jit);
 2146     }
 2147 
 2148     m_jit.storeDouble(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight));
 2149 
 2150     base.use();
 2151     property.use();
 2152     value.use();
 2153     storage.use();
 2154 
 2155     if (arrayMode.isOutOfBounds()) {
 2156         addSlowPathGenerator(
 2157             slowPathCall(
 2158                 slowCase, this,
 2159                 m_jit.isStrictModeFor(node-&gt;origin.semantic)
 2160                     ? (node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsStrict : operationPutDoubleByValBeyondArrayBoundsStrict)
 2161                     : (node-&gt;op() == PutByValDirect ? operationPutDoubleByValDirectBeyondArrayBoundsNonStrict : operationPutDoubleByValBeyondArrayBoundsNonStrict),
<a name="39" id="anc39"></a><span class="line-modified"> 2162                 NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg, valueReg));</span>
 2163     }
 2164 
 2165     noResult(m_currentNode, UseChildrenCalledExplicitly);
 2166 }
 2167 
 2168 void SpeculativeJIT::compileGetCharCodeAt(Node* node)
 2169 {
 2170     SpeculateCellOperand string(this, node-&gt;child1());
 2171     SpeculateStrictInt32Operand index(this, node-&gt;child2());
 2172     StorageOperand storage(this, node-&gt;child3());
 2173 
 2174     GPRReg stringReg = string.gpr();
 2175     GPRReg indexReg = index.gpr();
 2176     GPRReg storageReg = storage.gpr();
 2177 
 2178     ASSERT(speculationChecked(m_state.forNode(node-&gt;child1()).m_type, SpecString));
 2179 
 2180     GPRTemporary scratch(this);
 2181     GPRReg scratchReg = scratch.gpr();
 2182 
 2183     m_jit.loadPtr(MacroAssembler::Address(stringReg, JSString::offsetOfValue()), scratchReg);
 2184 
 2185     // unsigned comparison so we can filter out negative indices and indices that are too large
 2186     speculationCheck(Uncountable, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, indexReg, CCallHelpers::Address(scratchReg, StringImpl::lengthMemoryOffset())));
 2187 
 2188     // Load the character into scratchReg
 2189     JITCompiler::Jump is16Bit = m_jit.branchTest32(MacroAssembler::Zero, MacroAssembler::Address(scratchReg, StringImpl::flagsOffset()), TrustedImm32(StringImpl::flagIs8Bit()));
 2190 
 2191     m_jit.load8(MacroAssembler::BaseIndex(storageReg, indexReg, MacroAssembler::TimesOne, 0), scratchReg);
 2192     JITCompiler::Jump cont8Bit = m_jit.jump();
 2193 
 2194     is16Bit.link(&amp;m_jit);
 2195 
 2196     m_jit.load16(MacroAssembler::BaseIndex(storageReg, indexReg, MacroAssembler::TimesTwo, 0), scratchReg);
 2197 
 2198     cont8Bit.link(&amp;m_jit);
 2199 
 2200     int32Result(scratchReg, m_currentNode);
 2201 }
 2202 
 2203 void SpeculativeJIT::compileGetByValOnString(Node* node)
 2204 {
 2205     SpeculateCellOperand base(this, m_graph.child(node, 0));
 2206     SpeculateStrictInt32Operand property(this, m_graph.child(node, 1));
 2207     StorageOperand storage(this, m_graph.child(node, 2));
 2208     GPRReg baseReg = base.gpr();
 2209     GPRReg propertyReg = property.gpr();
 2210     GPRReg storageReg = storage.gpr();
 2211 
 2212     GPRTemporary scratch(this);
 2213     GPRReg scratchReg = scratch.gpr();
 2214 #if USE(JSVALUE32_64)
 2215     GPRTemporary resultTag;
 2216     GPRReg resultTagReg = InvalidGPRReg;
 2217     if (node-&gt;arrayMode().isOutOfBounds()) {
 2218         GPRTemporary realResultTag(this);
 2219         resultTag.adopt(realResultTag);
 2220         resultTagReg = resultTag.gpr();
 2221     }
 2222 #endif
 2223 
 2224     ASSERT(ArrayMode(Array::String, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(m_graph.child(node, 0))));
 2225 
 2226     // unsigned comparison so we can filter out negative indices and indices that are too large
 2227     m_jit.loadPtr(MacroAssembler::Address(baseReg, JSString::offsetOfValue()), scratchReg);
 2228     JITCompiler::Jump outOfBounds = m_jit.branch32(
 2229         MacroAssembler::AboveOrEqual, propertyReg,
 2230         MacroAssembler::Address(scratchReg, StringImpl::lengthMemoryOffset()));
 2231     if (node-&gt;arrayMode().isInBounds())
 2232         speculationCheck(OutOfBounds, JSValueRegs(), 0, outOfBounds);
 2233 
 2234     // Load the character into scratchReg
 2235     JITCompiler::Jump is16Bit = m_jit.branchTest32(MacroAssembler::Zero, MacroAssembler::Address(scratchReg, StringImpl::flagsOffset()), TrustedImm32(StringImpl::flagIs8Bit()));
 2236 
 2237     m_jit.load8(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesOne, 0), scratchReg);
 2238     JITCompiler::Jump cont8Bit = m_jit.jump();
 2239 
 2240     is16Bit.link(&amp;m_jit);
 2241 
 2242     m_jit.load16(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesTwo, 0), scratchReg);
 2243 
 2244     JITCompiler::Jump bigCharacter =
 2245         m_jit.branch32(MacroAssembler::Above, scratchReg, TrustedImm32(maxSingleCharacterString));
 2246 
 2247     // 8 bit string values don&#39;t need the isASCII check.
 2248     cont8Bit.link(&amp;m_jit);
 2249 
 2250     VM&amp; vm = this-&gt;vm();
 2251     m_jit.lshift32(MacroAssembler::TrustedImm32(sizeof(void*) == 4 ? 2 : 3), scratchReg);
 2252     m_jit.addPtr(TrustedImmPtr(vm.smallStrings.singleCharacterStrings()), scratchReg);
 2253     m_jit.loadPtr(scratchReg, scratchReg);
 2254 
 2255     addSlowPathGenerator(
 2256         slowPathCall(
<a name="40" id="anc40"></a><span class="line-modified"> 2257             bigCharacter, this, operationSingleCharacterString, scratchReg, &amp;vm, scratchReg));</span>
 2258 
 2259     if (node-&gt;arrayMode().isOutOfBounds()) {
 2260 #if USE(JSVALUE32_64)
 2261         m_jit.move(TrustedImm32(JSValue::CellTag), resultTagReg);
 2262 #endif
 2263 
 2264         JSGlobalObject* globalObject = m_jit.globalObjectFor(node-&gt;origin.semantic);
 2265         Structure* stringPrototypeStructure = globalObject-&gt;stringPrototype()-&gt;structure(vm);
 2266         Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(vm);
 2267         WTF::loadLoadFence();
 2268 
 2269         if (globalObject-&gt;stringPrototypeChainIsSane()) {
 2270             // FIXME: This could be captured using a Speculation mode that means &quot;out-of-bounds
 2271             // loads return a trivial value&quot;. Something like SaneChainOutOfBounds. This should
 2272             // speculate that we don&#39;t take negative out-of-bounds, or better yet, it should rely
 2273             // on a stringPrototypeChainIsSane() guaranteeing that the prototypes have no negative
 2274             // indexed properties either.
 2275             // https://bugs.webkit.org/show_bug.cgi?id=144668
 2276             m_jit.graph().registerAndWatchStructureTransition(stringPrototypeStructure);
 2277             m_jit.graph().registerAndWatchStructureTransition(objectPrototypeStructure);
 2278 
 2279 #if USE(JSVALUE64)
 2280             addSlowPathGenerator(makeUnique&lt;SaneStringGetByValSlowPathGenerator&gt;(
<a name="41" id="anc41"></a><span class="line-modified"> 2281                 outOfBounds, this, JSValueRegs(scratchReg), TrustedImmPtr::weakPointer(m_graph, globalObject), baseReg, propertyReg));</span>
 2282 #else
 2283             addSlowPathGenerator(makeUnique&lt;SaneStringGetByValSlowPathGenerator&gt;(
<a name="42" id="anc42"></a><span class="line-modified"> 2284                 outOfBounds, this, JSValueRegs(resultTagReg, scratchReg), TrustedImmPtr::weakPointer(m_graph, globalObject), baseReg, propertyReg));</span>

 2285 #endif
 2286         } else {
 2287 #if USE(JSVALUE64)
 2288             addSlowPathGenerator(
 2289                 slowPathCall(
 2290                     outOfBounds, this, operationGetByValStringInt,
<a name="43" id="anc43"></a><span class="line-modified"> 2291                     scratchReg, TrustedImmPtr::weakPointer(m_graph, globalObject), baseReg, propertyReg));</span>
 2292 #else
 2293             addSlowPathGenerator(
 2294                 slowPathCall(
 2295                     outOfBounds, this, operationGetByValStringInt,
<a name="44" id="anc44"></a><span class="line-modified"> 2296                     JSValueRegs(resultTagReg, scratchReg), TrustedImmPtr::weakPointer(m_graph, globalObject), baseReg, propertyReg));</span>
 2297 #endif
 2298         }
 2299 
 2300 #if USE(JSVALUE64)
 2301         jsValueResult(scratchReg, m_currentNode);
 2302 #else
 2303         jsValueResult(resultTagReg, scratchReg, m_currentNode);
 2304 #endif
 2305     } else
 2306         cellResult(scratchReg, m_currentNode);
 2307 }
 2308 
 2309 void SpeculativeJIT::compileFromCharCode(Node* node)
 2310 {
 2311     Edge&amp; child = node-&gt;child1();
 2312     if (child.useKind() == UntypedUse) {
 2313         JSValueOperand opr(this, child);
 2314         JSValueRegs oprRegs = opr.jsValueRegs();
 2315 
 2316         flushRegisters();
 2317         JSValueRegsFlushedCallResult result(this);
 2318         JSValueRegs resultRegs = result.regs();
<a name="45" id="anc45"></a><span class="line-modified"> 2319         callOperation(operationStringFromCharCodeUntyped, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), oprRegs);</span>
 2320         m_jit.exceptionCheck();
 2321 
 2322         jsValueResult(resultRegs, node);
 2323         return;
 2324     }
 2325 
 2326     SpeculateStrictInt32Operand property(this, child);
 2327     GPRReg propertyReg = property.gpr();
 2328     GPRTemporary smallStrings(this);
 2329     GPRTemporary scratch(this);
 2330     GPRReg scratchReg = scratch.gpr();
 2331     GPRReg smallStringsReg = smallStrings.gpr();
 2332 
 2333     JITCompiler::JumpList slowCases;
 2334     slowCases.append(m_jit.branch32(MacroAssembler::Above, propertyReg, TrustedImm32(maxSingleCharacterString)));
 2335     m_jit.move(TrustedImmPtr(vm().smallStrings.singleCharacterStrings()), smallStringsReg);
 2336     m_jit.loadPtr(MacroAssembler::BaseIndex(smallStringsReg, propertyReg, MacroAssembler::ScalePtr, 0), scratchReg);
 2337 
 2338     slowCases.append(m_jit.branchTest32(MacroAssembler::Zero, scratchReg));
<a name="46" id="anc46"></a><span class="line-modified"> 2339     addSlowPathGenerator(slowPathCall(slowCases, this, operationStringFromCharCode, scratchReg, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), propertyReg));</span>
 2340     cellResult(scratchReg, m_currentNode);
 2341 }
 2342 
 2343 GeneratedOperandType SpeculativeJIT::checkGeneratedTypeForToInt32(Node* node)
 2344 {
 2345     VirtualRegister virtualRegister = node-&gt;virtualRegister();
 2346     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
 2347 
 2348     switch (info.registerFormat()) {
 2349     case DataFormatStorage:
 2350         RELEASE_ASSERT_NOT_REACHED();
 2351 
 2352     case DataFormatBoolean:
 2353     case DataFormatCell:
 2354         terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
 2355         return GeneratedOperandTypeUnknown;
 2356 
 2357     case DataFormatNone:
 2358     case DataFormatJSCell:
 2359     case DataFormatJS:
 2360     case DataFormatJSBoolean:
 2361     case DataFormatJSDouble:
 2362         return GeneratedOperandJSValue;
 2363 
 2364     case DataFormatJSInt32:
 2365     case DataFormatInt32:
 2366         return GeneratedOperandInteger;
 2367 
 2368     default:
 2369         RELEASE_ASSERT_NOT_REACHED();
 2370         return GeneratedOperandTypeUnknown;
 2371     }
 2372 }
 2373 
 2374 void SpeculativeJIT::compileValueToInt32(Node* node)
 2375 {
 2376     switch (node-&gt;child1().useKind()) {
 2377 #if USE(JSVALUE64)
 2378     case Int52RepUse: {
 2379         SpeculateStrictInt52Operand op1(this, node-&gt;child1());
 2380         GPRTemporary result(this, Reuse, op1);
 2381         GPRReg op1GPR = op1.gpr();
 2382         GPRReg resultGPR = result.gpr();
 2383         m_jit.zeroExtend32ToPtr(op1GPR, resultGPR);
 2384         int32Result(resultGPR, node, DataFormatInt32);
 2385         return;
 2386     }
 2387 #endif // USE(JSVALUE64)
 2388 
 2389     case DoubleRepUse: {
 2390         GPRTemporary result(this);
 2391         SpeculateDoubleOperand op1(this, node-&gt;child1());
 2392         FPRReg fpr = op1.fpr();
 2393         GPRReg gpr = result.gpr();
 2394 #if CPU(ARM64)
 2395         if (MacroAssemblerARM64::supportsDoubleToInt32ConversionUsingJavaScriptSemantics())
 2396             m_jit.convertDoubleToInt32UsingJavaScriptSemantics(fpr, gpr);
 2397         else
 2398 #endif
 2399         {
 2400             JITCompiler::Jump notTruncatedToInteger = m_jit.branchTruncateDoubleToInt32(fpr, gpr, JITCompiler::BranchIfTruncateFailed);
 2401             addSlowPathGenerator(slowPathCall(notTruncatedToInteger, this,
 2402                 hasSensibleDoubleToInt() ? operationToInt32SensibleSlow : operationToInt32, NeedToSpill, ExceptionCheckRequirement::CheckNotNeeded, gpr, fpr));
 2403         }
 2404         int32Result(gpr, node);
 2405         return;
 2406     }
 2407 
 2408     case NumberUse:
 2409     case NotCellUse: {
 2410         switch (checkGeneratedTypeForToInt32(node-&gt;child1().node())) {
 2411         case GeneratedOperandInteger: {
 2412             SpeculateInt32Operand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 2413             GPRTemporary result(this, Reuse, op1);
 2414             m_jit.move(op1.gpr(), result.gpr());
 2415             int32Result(result.gpr(), node, op1.format());
 2416             return;
 2417         }
 2418         case GeneratedOperandJSValue: {
 2419             GPRTemporary result(this);
 2420 #if USE(JSVALUE64)
 2421             JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 2422 
 2423             GPRReg gpr = op1.gpr();
 2424             GPRReg resultGpr = result.gpr();
 2425             FPRTemporary tempFpr(this);
 2426             FPRReg fpr = tempFpr.fpr();
 2427 
 2428             JITCompiler::Jump isInteger = m_jit.branchIfInt32(gpr);
 2429             JITCompiler::JumpList converted;
 2430 
 2431             if (node-&gt;child1().useKind() == NumberUse) {
 2432                 DFG_TYPE_CHECK(
 2433                     JSValueRegs(gpr), node-&gt;child1(), SpecBytecodeNumber,
 2434                     m_jit.branchIfNotNumber(gpr));
 2435             } else {
 2436                 JITCompiler::Jump isNumber = m_jit.branchIfNumber(gpr);
 2437 
 2438                 DFG_TYPE_CHECK(
 2439                     JSValueRegs(gpr), node-&gt;child1(), ~SpecCellCheck, m_jit.branchIfCell(JSValueRegs(gpr)));
 2440 
 2441                 // It&#39;s not a cell: so true turns into 1 and all else turns into 0.
<a name="47" id="anc47"></a><span class="line-modified"> 2442                 m_jit.compare64(JITCompiler::Equal, gpr, TrustedImm32(JSValue::ValueTrue), resultGpr);</span>
 2443                 converted.append(m_jit.jump());
 2444 
 2445                 isNumber.link(&amp;m_jit);
 2446             }
 2447 
 2448             // First, if we get here we have a double encoded as a JSValue
 2449             unboxDouble(gpr, resultGpr, fpr);
 2450 #if CPU(ARM64)
 2451             if (MacroAssemblerARM64::supportsDoubleToInt32ConversionUsingJavaScriptSemantics())
 2452                 m_jit.convertDoubleToInt32UsingJavaScriptSemantics(fpr, resultGpr);
 2453             else
 2454 #endif
 2455             {
 2456                 silentSpillAllRegisters(resultGpr);
 2457                 callOperation(operationToInt32, resultGpr, fpr);
 2458                 silentFillAllRegisters();
 2459             }
 2460 
 2461             converted.append(m_jit.jump());
 2462 
 2463             isInteger.link(&amp;m_jit);
 2464             m_jit.zeroExtend32ToPtr(gpr, resultGpr);
 2465 
 2466             converted.link(&amp;m_jit);
 2467 #else
 2468             Node* childNode = node-&gt;child1().node();
 2469             VirtualRegister virtualRegister = childNode-&gt;virtualRegister();
 2470             GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
 2471 
 2472             JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 2473 
 2474             GPRReg payloadGPR = op1.payloadGPR();
 2475             GPRReg resultGpr = result.gpr();
 2476 
 2477             JITCompiler::JumpList converted;
 2478 
 2479             if (info.registerFormat() == DataFormatJSInt32)
 2480                 m_jit.move(payloadGPR, resultGpr);
 2481             else {
 2482                 GPRReg tagGPR = op1.tagGPR();
 2483                 FPRTemporary tempFpr(this);
 2484                 FPRReg fpr = tempFpr.fpr();
 2485                 FPRTemporary scratch(this);
 2486 
 2487                 JITCompiler::Jump isInteger = m_jit.branchIfInt32(tagGPR);
 2488 
 2489                 if (node-&gt;child1().useKind() == NumberUse) {
 2490                     DFG_TYPE_CHECK(
 2491                         op1.jsValueRegs(), node-&gt;child1(), SpecBytecodeNumber,
 2492                         m_jit.branch32(
 2493                             MacroAssembler::AboveOrEqual, tagGPR,
 2494                             TrustedImm32(JSValue::LowestTag)));
 2495                 } else {
 2496                     JITCompiler::Jump isNumber = m_jit.branch32(MacroAssembler::Below, tagGPR, TrustedImm32(JSValue::LowestTag));
 2497 
 2498                     DFG_TYPE_CHECK(
 2499                         op1.jsValueRegs(), node-&gt;child1(), ~SpecCell,
 2500                         m_jit.branchIfCell(op1.jsValueRegs()));
 2501 
 2502                     // It&#39;s not a cell: so true turns into 1 and all else turns into 0.
 2503                     JITCompiler::Jump isBoolean = m_jit.branchIfBoolean(tagGPR, InvalidGPRReg);
 2504                     m_jit.move(TrustedImm32(0), resultGpr);
 2505                     converted.append(m_jit.jump());
 2506 
 2507                     isBoolean.link(&amp;m_jit);
 2508                     m_jit.move(payloadGPR, resultGpr);
 2509                     converted.append(m_jit.jump());
 2510 
 2511                     isNumber.link(&amp;m_jit);
 2512                 }
 2513 
 2514                 unboxDouble(tagGPR, payloadGPR, fpr, scratch.fpr());
 2515 
 2516                 silentSpillAllRegisters(resultGpr);
 2517                 callOperation(operationToInt32, resultGpr, fpr);
 2518                 silentFillAllRegisters();
 2519 
 2520                 converted.append(m_jit.jump());
 2521 
 2522                 isInteger.link(&amp;m_jit);
 2523                 m_jit.move(payloadGPR, resultGpr);
 2524 
 2525                 converted.link(&amp;m_jit);
 2526             }
 2527 #endif
 2528             int32Result(resultGpr, node);
 2529             return;
 2530         }
 2531         case GeneratedOperandTypeUnknown:
 2532             RELEASE_ASSERT(!m_compileOkay);
 2533             return;
 2534         }
 2535         RELEASE_ASSERT_NOT_REACHED();
 2536         return;
 2537     }
 2538 
 2539     default:
 2540         ASSERT(!m_compileOkay);
 2541         return;
 2542     }
 2543 }
 2544 
 2545 void SpeculativeJIT::compileUInt32ToNumber(Node* node)
 2546 {
 2547     if (doesOverflow(node-&gt;arithMode())) {
 2548         if (enableInt52()) {
 2549             SpeculateInt32Operand op1(this, node-&gt;child1());
 2550             GPRTemporary result(this, Reuse, op1);
 2551             m_jit.zeroExtend32ToPtr(op1.gpr(), result.gpr());
 2552             strictInt52Result(result.gpr(), node);
 2553             return;
 2554         }
 2555         SpeculateInt32Operand op1(this, node-&gt;child1());
 2556         FPRTemporary result(this);
 2557 
 2558         GPRReg inputGPR = op1.gpr();
 2559         FPRReg outputFPR = result.fpr();
 2560 
 2561         m_jit.convertInt32ToDouble(inputGPR, outputFPR);
 2562 
 2563         JITCompiler::Jump positive = m_jit.branch32(MacroAssembler::GreaterThanOrEqual, inputGPR, TrustedImm32(0));
 2564         m_jit.addDouble(JITCompiler::AbsoluteAddress(&amp;AssemblyHelpers::twoToThe32), outputFPR);
 2565         positive.link(&amp;m_jit);
 2566 
 2567         doubleResult(outputFPR, node);
 2568         return;
 2569     }
 2570 
 2571     RELEASE_ASSERT(node-&gt;arithMode() == Arith::CheckOverflow);
 2572 
 2573     SpeculateInt32Operand op1(this, node-&gt;child1());
 2574     GPRTemporary result(this);
 2575 
 2576     m_jit.move(op1.gpr(), result.gpr());
 2577 
 2578     speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::LessThan, result.gpr(), TrustedImm32(0)));
 2579 
 2580     int32Result(result.gpr(), node, op1.format());
 2581 }
 2582 
 2583 void SpeculativeJIT::compileDoubleAsInt32(Node* node)
 2584 {
 2585     SpeculateDoubleOperand op1(this, node-&gt;child1());
 2586     FPRTemporary scratch(this);
 2587     GPRTemporary result(this);
 2588 
 2589     FPRReg valueFPR = op1.fpr();
 2590     FPRReg scratchFPR = scratch.fpr();
 2591     GPRReg resultGPR = result.gpr();
 2592 
 2593     JITCompiler::JumpList failureCases;
 2594     RELEASE_ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
 2595     m_jit.branchConvertDoubleToInt32(
 2596         valueFPR, resultGPR, failureCases, scratchFPR,
 2597         shouldCheckNegativeZero(node-&gt;arithMode()));
 2598     speculationCheck(Overflow, JSValueRegs(), 0, failureCases);
 2599 
 2600     int32Result(resultGPR, node);
 2601 }
 2602 
 2603 void SpeculativeJIT::compileDoubleRep(Node* node)
 2604 {
 2605     switch (node-&gt;child1().useKind()) {
 2606     case RealNumberUse: {
 2607         JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 2608         FPRTemporary result(this);
 2609 
 2610         JSValueRegs op1Regs = op1.jsValueRegs();
 2611         FPRReg resultFPR = result.fpr();
 2612 
 2613 #if USE(JSVALUE64)
 2614         GPRTemporary temp(this);
 2615         GPRReg tempGPR = temp.gpr();
 2616         m_jit.unboxDoubleWithoutAssertions(op1Regs.gpr(), tempGPR, resultFPR);
 2617 #else
 2618         FPRTemporary temp(this);
 2619         FPRReg tempFPR = temp.fpr();
 2620         unboxDouble(op1Regs.tagGPR(), op1Regs.payloadGPR(), resultFPR, tempFPR);
 2621 #endif
 2622 
 2623         JITCompiler::Jump done = m_jit.branchIfNotNaN(resultFPR);
 2624 
 2625         DFG_TYPE_CHECK(
 2626             op1Regs, node-&gt;child1(), SpecBytecodeRealNumber, m_jit.branchIfNotInt32(op1Regs));
 2627         m_jit.convertInt32ToDouble(op1Regs.payloadGPR(), resultFPR);
 2628 
 2629         done.link(&amp;m_jit);
 2630 
 2631         doubleResult(resultFPR, node);
 2632         return;
 2633     }
 2634 
 2635     case NotCellUse:
 2636     case NumberUse: {
 2637         SpeculatedType possibleTypes = m_state.forNode(node-&gt;child1()).m_type;
 2638         if (isInt32Speculation(possibleTypes)) {
 2639             SpeculateInt32Operand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 2640             FPRTemporary result(this);
 2641             m_jit.convertInt32ToDouble(op1.gpr(), result.fpr());
 2642             doubleResult(result.fpr(), node);
 2643             return;
 2644         }
 2645 
 2646         JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 2647         FPRTemporary result(this);
 2648 
 2649 #if USE(JSVALUE64)
 2650         GPRTemporary temp(this);
 2651 
 2652         GPRReg op1GPR = op1.gpr();
 2653         GPRReg tempGPR = temp.gpr();
 2654         FPRReg resultFPR = result.fpr();
 2655         JITCompiler::JumpList done;
 2656 
 2657         JITCompiler::Jump isInteger = m_jit.branchIfInt32(op1GPR);
 2658 
 2659         if (node-&gt;child1().useKind() == NotCellUse) {
 2660             JITCompiler::Jump isNumber = m_jit.branchIfNumber(op1GPR);
 2661             JITCompiler::Jump isUndefined = m_jit.branchIfUndefined(op1GPR);
 2662 
<a name="48" id="anc48"></a><span class="line-modified"> 2663             static constexpr double zero = 0;</span>
 2664             m_jit.loadDouble(TrustedImmPtr(&amp;zero), resultFPR);
 2665 
 2666             JITCompiler::Jump isNull = m_jit.branchIfNull(op1GPR);
 2667             done.append(isNull);
 2668 
 2669             DFG_TYPE_CHECK(JSValueRegs(op1GPR), node-&gt;child1(), ~SpecCellCheck,
<a name="49" id="anc49"></a><span class="line-modified"> 2670                 m_jit.branchTest64(JITCompiler::Zero, op1GPR, TrustedImm32(JSValue::BoolTag)));</span>
 2671 
<a name="50" id="anc50"></a><span class="line-modified"> 2672             JITCompiler::Jump isFalse = m_jit.branch64(JITCompiler::Equal, op1GPR, TrustedImm64(JSValue::ValueFalse));</span>
<span class="line-modified"> 2673             static constexpr double one = 1;</span>
 2674             m_jit.loadDouble(TrustedImmPtr(&amp;one), resultFPR);
 2675             done.append(m_jit.jump());
 2676             done.append(isFalse);
 2677 
 2678             isUndefined.link(&amp;m_jit);
 2679             static const double NaN = PNaN;
 2680             m_jit.loadDouble(TrustedImmPtr(&amp;NaN), resultFPR);
 2681             done.append(m_jit.jump());
 2682 
 2683             isNumber.link(&amp;m_jit);
 2684         } else if (needsTypeCheck(node-&gt;child1(), SpecBytecodeNumber)) {
 2685             typeCheck(
 2686                 JSValueRegs(op1GPR), node-&gt;child1(), SpecBytecodeNumber,
 2687                 m_jit.branchIfNotNumber(op1GPR));
 2688         }
 2689 
 2690         unboxDouble(op1GPR, tempGPR, resultFPR);
 2691         done.append(m_jit.jump());
 2692 
 2693         isInteger.link(&amp;m_jit);
 2694         m_jit.convertInt32ToDouble(op1GPR, resultFPR);
 2695         done.link(&amp;m_jit);
 2696 #else // USE(JSVALUE64) -&gt; this is the 32_64 case
 2697         FPRTemporary temp(this);
 2698 
 2699         GPRReg op1TagGPR = op1.tagGPR();
 2700         GPRReg op1PayloadGPR = op1.payloadGPR();
 2701         FPRReg tempFPR = temp.fpr();
 2702         FPRReg resultFPR = result.fpr();
 2703         JITCompiler::JumpList done;
 2704 
 2705         JITCompiler::Jump isInteger = m_jit.branchIfInt32(op1TagGPR);
 2706 
 2707         if (node-&gt;child1().useKind() == NotCellUse) {
 2708             JITCompiler::Jump isNumber = m_jit.branch32(JITCompiler::Below, op1TagGPR, JITCompiler::TrustedImm32(JSValue::LowestTag + 1));
 2709             JITCompiler::Jump isUndefined = m_jit.branchIfUndefined(op1TagGPR);
 2710 
<a name="51" id="anc51"></a><span class="line-modified"> 2711             static constexpr double zero = 0;</span>
 2712             m_jit.loadDouble(TrustedImmPtr(&amp;zero), resultFPR);
 2713 
 2714             JITCompiler::Jump isNull = m_jit.branchIfNull(op1TagGPR);
 2715             done.append(isNull);
 2716 
 2717             DFG_TYPE_CHECK(JSValueRegs(op1TagGPR, op1PayloadGPR), node-&gt;child1(), ~SpecCell, m_jit.branchIfNotBoolean(op1TagGPR, InvalidGPRReg));
 2718 
 2719             JITCompiler::Jump isFalse = m_jit.branchTest32(JITCompiler::Zero, op1PayloadGPR, TrustedImm32(1));
<a name="52" id="anc52"></a><span class="line-modified"> 2720             static constexpr double one = 1;</span>
 2721             m_jit.loadDouble(TrustedImmPtr(&amp;one), resultFPR);
 2722             done.append(m_jit.jump());
 2723             done.append(isFalse);
 2724 
 2725             isUndefined.link(&amp;m_jit);
 2726             static const double NaN = PNaN;
 2727             m_jit.loadDouble(TrustedImmPtr(&amp;NaN), resultFPR);
 2728             done.append(m_jit.jump());
 2729 
 2730             isNumber.link(&amp;m_jit);
 2731         } else if (needsTypeCheck(node-&gt;child1(), SpecBytecodeNumber)) {
 2732             // This check fails with Int32Tag, but it is OK since Int32 case is already excluded.
 2733             typeCheck(
 2734                 JSValueRegs(op1TagGPR, op1PayloadGPR), node-&gt;child1(), SpecBytecodeNumber,
 2735                 m_jit.branch32(MacroAssembler::AboveOrEqual, op1TagGPR, TrustedImm32(JSValue::LowestTag)));
 2736         }
 2737 
 2738         unboxDouble(op1TagGPR, op1PayloadGPR, resultFPR, tempFPR);
 2739         done.append(m_jit.jump());
 2740 
 2741         isInteger.link(&amp;m_jit);
 2742         m_jit.convertInt32ToDouble(op1PayloadGPR, resultFPR);
 2743         done.link(&amp;m_jit);
 2744 #endif // USE(JSVALUE64)
 2745 
 2746         doubleResult(resultFPR, node);
 2747         return;
 2748     }
 2749 
 2750 #if USE(JSVALUE64)
 2751     case Int52RepUse: {
 2752         SpeculateStrictInt52Operand value(this, node-&gt;child1());
 2753         FPRTemporary result(this);
 2754 
 2755         GPRReg valueGPR = value.gpr();
 2756         FPRReg resultFPR = result.fpr();
 2757 
 2758         m_jit.convertInt64ToDouble(valueGPR, resultFPR);
 2759 
 2760         doubleResult(resultFPR, node);
 2761         return;
 2762     }
 2763 #endif // USE(JSVALUE64)
 2764 
 2765     default:
 2766         RELEASE_ASSERT_NOT_REACHED();
 2767         return;
 2768     }
 2769 }
 2770 
 2771 void SpeculativeJIT::compileValueRep(Node* node)
 2772 {
 2773     switch (node-&gt;child1().useKind()) {
 2774     case DoubleRepUse: {
 2775         SpeculateDoubleOperand value(this, node-&gt;child1());
 2776         JSValueRegsTemporary result(this);
 2777 
 2778         FPRReg valueFPR = value.fpr();
 2779         JSValueRegs resultRegs = result.regs();
 2780 
 2781         // It&#39;s very tempting to in-place filter the value to indicate that it&#39;s not impure NaN
 2782         // anymore. Unfortunately, this would be unsound. If it&#39;s a GetLocal or if the value was
 2783         // subject to a prior SetLocal, filtering the value would imply that the corresponding
 2784         // local was purified.
 2785         if (needsTypeCheck(node-&gt;child1(), ~SpecDoubleImpureNaN))
 2786             m_jit.purifyNaN(valueFPR);
 2787 
 2788         boxDouble(valueFPR, resultRegs);
 2789 
 2790         jsValueResult(resultRegs, node);
 2791         return;
 2792     }
 2793 
 2794 #if USE(JSVALUE64)
 2795     case Int52RepUse: {
 2796         SpeculateStrictInt52Operand value(this, node-&gt;child1());
 2797         GPRTemporary result(this);
 2798 
 2799         GPRReg valueGPR = value.gpr();
 2800         GPRReg resultGPR = result.gpr();
 2801 
 2802         boxInt52(valueGPR, resultGPR, DataFormatStrictInt52);
 2803 
 2804         jsValueResult(resultGPR, node);
 2805         return;
 2806     }
 2807 #endif // USE(JSVALUE64)
 2808 
 2809     default:
 2810         RELEASE_ASSERT_NOT_REACHED();
 2811         return;
 2812     }
 2813 }
 2814 
 2815 static double clampDoubleToByte(double d)
 2816 {
 2817     d += 0.5;
 2818     if (!(d &gt; 0))
 2819         d = 0;
 2820     else if (d &gt; 255)
 2821         d = 255;
 2822     return d;
 2823 }
 2824 
 2825 static void compileClampIntegerToByte(JITCompiler&amp; jit, GPRReg result)
 2826 {
 2827     MacroAssembler::Jump inBounds = jit.branch32(MacroAssembler::BelowOrEqual, result, JITCompiler::TrustedImm32(0xff));
 2828     MacroAssembler::Jump tooBig = jit.branch32(MacroAssembler::GreaterThan, result, JITCompiler::TrustedImm32(0xff));
 2829     jit.xorPtr(result, result);
 2830     MacroAssembler::Jump clamped = jit.jump();
 2831     tooBig.link(&amp;jit);
 2832     jit.move(JITCompiler::TrustedImm32(255), result);
 2833     clamped.link(&amp;jit);
 2834     inBounds.link(&amp;jit);
 2835 }
 2836 
 2837 static void compileClampDoubleToByte(JITCompiler&amp; jit, GPRReg result, FPRReg source, FPRReg scratch)
 2838 {
 2839     // Unordered compare so we pick up NaN
<a name="53" id="anc53"></a><span class="line-modified"> 2840     static constexpr double zero = 0;</span>
<span class="line-modified"> 2841     static constexpr double byteMax = 255;</span>
<span class="line-modified"> 2842     static constexpr double half = 0.5;</span>
 2843     jit.loadDouble(JITCompiler::TrustedImmPtr(&amp;zero), scratch);
 2844     MacroAssembler::Jump tooSmall = jit.branchDouble(MacroAssembler::DoubleLessThanOrEqualOrUnordered, source, scratch);
 2845     jit.loadDouble(JITCompiler::TrustedImmPtr(&amp;byteMax), scratch);
 2846     MacroAssembler::Jump tooBig = jit.branchDouble(MacroAssembler::DoubleGreaterThan, source, scratch);
 2847 
 2848     jit.loadDouble(JITCompiler::TrustedImmPtr(&amp;half), scratch);
 2849     // FIXME: This should probably just use a floating point round!
 2850     // https://bugs.webkit.org/show_bug.cgi?id=72054
 2851     jit.addDouble(source, scratch);
 2852     jit.truncateDoubleToInt32(scratch, result);
 2853     MacroAssembler::Jump truncatedInt = jit.jump();
 2854 
 2855     tooSmall.link(&amp;jit);
 2856     jit.xorPtr(result, result);
 2857     MacroAssembler::Jump zeroed = jit.jump();
 2858 
 2859     tooBig.link(&amp;jit);
 2860     jit.move(JITCompiler::TrustedImm32(255), result);
 2861 
 2862     truncatedInt.link(&amp;jit);
 2863     zeroed.link(&amp;jit);
 2864 
 2865 }
 2866 
 2867 JITCompiler::Jump SpeculativeJIT::jumpForTypedArrayOutOfBounds(Node* node, GPRReg baseGPR, GPRReg indexGPR)
 2868 {
 2869     if (node-&gt;op() == PutByValAlias)
 2870         return JITCompiler::Jump();
 2871     JSArrayBufferView* view = m_jit.graph().tryGetFoldableView(
 2872         m_state.forNode(m_jit.graph().child(node, 0)).m_value, node-&gt;arrayMode());
 2873     if (view) {
 2874         uint32_t length = view-&gt;length();
 2875         Node* indexNode = m_jit.graph().child(node, 1).node();
 2876         if (indexNode-&gt;isInt32Constant() &amp;&amp; indexNode-&gt;asUInt32() &lt; length)
 2877             return JITCompiler::Jump();
 2878         return m_jit.branch32(
 2879             MacroAssembler::AboveOrEqual, indexGPR, MacroAssembler::Imm32(length));
 2880     }
 2881     return m_jit.branch32(
 2882         MacroAssembler::AboveOrEqual, indexGPR,
 2883         MacroAssembler::Address(baseGPR, JSArrayBufferView::offsetOfLength()));
 2884 }
 2885 
 2886 void SpeculativeJIT::emitTypedArrayBoundsCheck(Node* node, GPRReg baseGPR, GPRReg indexGPR)
 2887 {
 2888     JITCompiler::Jump jump = jumpForTypedArrayOutOfBounds(node, baseGPR, indexGPR);
 2889     if (!jump.isSet())
 2890         return;
 2891     speculationCheck(OutOfBounds, JSValueRegs(), 0, jump);
 2892 }
 2893 
 2894 JITCompiler::Jump SpeculativeJIT::jumpForTypedArrayIsNeuteredIfOutOfBounds(Node* node, GPRReg base, JITCompiler::Jump outOfBounds)
 2895 {
 2896     JITCompiler::Jump done;
 2897     if (outOfBounds.isSet()) {
 2898         done = m_jit.jump();
 2899         if (node-&gt;arrayMode().isInBounds())
 2900             speculationCheck(OutOfBounds, JSValueSource(), 0, outOfBounds);
 2901         else {
 2902             outOfBounds.link(&amp;m_jit);
 2903 
 2904             JITCompiler::Jump notWasteful = m_jit.branch32(
 2905                 MacroAssembler::NotEqual,
 2906                 MacroAssembler::Address(base, JSArrayBufferView::offsetOfMode()),
 2907                 TrustedImm32(WastefulTypedArray));
 2908 
 2909             JITCompiler::Jump hasNullVector;
 2910 #if CPU(ARM64E)
 2911             {
 2912                 GPRReg scratch = m_jit.scratchRegister();
 2913                 DisallowMacroScratchRegisterUsage disallowScratch(m_jit);
 2914 
 2915                 m_jit.loadPtr(MacroAssembler::Address(base, JSArrayBufferView::offsetOfVector()), scratch);
 2916                 m_jit.removeArrayPtrTag(scratch);
 2917                 hasNullVector = m_jit.branchTestPtr(MacroAssembler::Zero, scratch);
 2918             }
 2919 #else // CPU(ARM64E)
 2920             hasNullVector = m_jit.branchTestPtr(
 2921                 MacroAssembler::Zero,
 2922                 MacroAssembler::Address(base, JSArrayBufferView::offsetOfVector()));
 2923 #endif
 2924             speculationCheck(Uncountable, JSValueSource(), node, hasNullVector);
 2925             notWasteful.link(&amp;m_jit);
 2926         }
 2927     }
 2928     return done;
 2929 }
 2930 
 2931 void SpeculativeJIT::loadFromIntTypedArray(GPRReg storageReg, GPRReg propertyReg, GPRReg resultReg, TypedArrayType type)
 2932 {
 2933     switch (elementSize(type)) {
 2934     case 1:
 2935         if (isSigned(type))
 2936             m_jit.load8SignedExtendTo32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesOne), resultReg);
 2937         else
 2938             m_jit.load8(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesOne), resultReg);
 2939         break;
 2940     case 2:
 2941         if (isSigned(type))
 2942             m_jit.load16SignedExtendTo32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesTwo), resultReg);
 2943         else
 2944             m_jit.load16(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesTwo), resultReg);
 2945         break;
 2946     case 4:
 2947         m_jit.load32(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesFour), resultReg);
 2948         break;
 2949     default:
 2950         CRASH();
 2951     }
 2952 }
 2953 
 2954 void SpeculativeJIT::setIntTypedArrayLoadResult(Node* node, GPRReg resultReg, TypedArrayType type, bool canSpeculate)
 2955 {
 2956     if (elementSize(type) &lt; 4 || isSigned(type)) {
 2957         int32Result(resultReg, node);
 2958         return;
 2959     }
 2960 
 2961     ASSERT(elementSize(type) == 4 &amp;&amp; !isSigned(type));
 2962     if (node-&gt;shouldSpeculateInt32() &amp;&amp; canSpeculate) {
 2963         speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::LessThan, resultReg, TrustedImm32(0)));
 2964         int32Result(resultReg, node);
 2965         return;
 2966     }
 2967 
 2968 #if USE(JSVALUE64)
 2969     if (node-&gt;shouldSpeculateInt52()) {
 2970         ASSERT(enableInt52());
 2971         m_jit.zeroExtend32ToPtr(resultReg, resultReg);
 2972         strictInt52Result(resultReg, node);
 2973         return;
 2974     }
 2975 #endif
 2976 
 2977     FPRTemporary fresult(this);
 2978     m_jit.convertInt32ToDouble(resultReg, fresult.fpr());
 2979     JITCompiler::Jump positive = m_jit.branch32(MacroAssembler::GreaterThanOrEqual, resultReg, TrustedImm32(0));
 2980     m_jit.addDouble(JITCompiler::AbsoluteAddress(&amp;AssemblyHelpers::twoToThe32), fresult.fpr());
 2981     positive.link(&amp;m_jit);
 2982     doubleResult(fresult.fpr(), node);
 2983 }
 2984 
 2985 void SpeculativeJIT::compileGetByValOnIntTypedArray(Node* node, TypedArrayType type)
 2986 {
 2987     ASSERT(isInt(type));
 2988 
 2989     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
 2990     SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
 2991     StorageOperand storage(this, m_graph.varArgChild(node, 2));
 2992 
 2993     GPRReg baseReg = base.gpr();
 2994     GPRReg propertyReg = property.gpr();
 2995     GPRReg storageReg = storage.gpr();
 2996 
 2997     GPRTemporary result(this);
 2998     GPRReg resultReg = result.gpr();
 2999 
 3000     emitTypedArrayBoundsCheck(node, baseReg, propertyReg);
 3001     loadFromIntTypedArray(storageReg, propertyReg, resultReg, type);
 3002     bool canSpeculate = true;
 3003     setIntTypedArrayLoadResult(node, resultReg, type, canSpeculate);
 3004 }
 3005 
 3006 bool SpeculativeJIT::getIntTypedArrayStoreOperand(
 3007     GPRTemporary&amp; value,
 3008     GPRReg property,
 3009 #if USE(JSVALUE32_64)
 3010     GPRTemporary&amp; propertyTag,
 3011     GPRTemporary&amp; valueTag,
 3012 #endif
 3013     Edge valueUse, JITCompiler::JumpList&amp; slowPathCases, bool isClamped)
 3014 {
 3015     bool isAppropriateConstant = false;
 3016     if (valueUse-&gt;isConstant()) {
 3017         JSValue jsValue = valueUse-&gt;asJSValue();
 3018         SpeculatedType expectedType = typeFilterFor(valueUse.useKind());
 3019         SpeculatedType actualType = speculationFromValue(jsValue);
 3020         isAppropriateConstant = (expectedType | actualType) == expectedType;
 3021     }
 3022 
 3023     if (isAppropriateConstant) {
 3024         JSValue jsValue = valueUse-&gt;asJSValue();
 3025         if (!jsValue.isNumber()) {
 3026             terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
 3027             return false;
 3028         }
 3029         double d = jsValue.asNumber();
 3030         if (isClamped)
 3031             d = clampDoubleToByte(d);
 3032         GPRTemporary scratch(this);
 3033         GPRReg scratchReg = scratch.gpr();
 3034         m_jit.move(Imm32(toInt32(d)), scratchReg);
 3035         value.adopt(scratch);
 3036     } else {
 3037         switch (valueUse.useKind()) {
 3038         case Int32Use: {
 3039             SpeculateInt32Operand valueOp(this, valueUse);
 3040             GPRTemporary scratch(this);
 3041             GPRReg scratchReg = scratch.gpr();
 3042             m_jit.move(valueOp.gpr(), scratchReg);
 3043             if (isClamped)
 3044                 compileClampIntegerToByte(m_jit, scratchReg);
 3045             value.adopt(scratch);
 3046             break;
 3047         }
 3048 
 3049 #if USE(JSVALUE64)
 3050         case Int52RepUse: {
 3051             SpeculateStrictInt52Operand valueOp(this, valueUse);
 3052             GPRTemporary scratch(this);
 3053             GPRReg scratchReg = scratch.gpr();
 3054             m_jit.move(valueOp.gpr(), scratchReg);
 3055             if (isClamped) {
 3056                 MacroAssembler::Jump inBounds = m_jit.branch64(
 3057                     MacroAssembler::BelowOrEqual, scratchReg, JITCompiler::TrustedImm64(0xff));
 3058                 MacroAssembler::Jump tooBig = m_jit.branch64(
 3059                     MacroAssembler::GreaterThan, scratchReg, JITCompiler::TrustedImm64(0xff));
 3060                 m_jit.move(TrustedImm32(0), scratchReg);
 3061                 MacroAssembler::Jump clamped = m_jit.jump();
 3062                 tooBig.link(&amp;m_jit);
 3063                 m_jit.move(JITCompiler::TrustedImm32(255), scratchReg);
 3064                 clamped.link(&amp;m_jit);
 3065                 inBounds.link(&amp;m_jit);
 3066             }
 3067             value.adopt(scratch);
 3068             break;
 3069         }
 3070 #endif // USE(JSVALUE64)
 3071 
 3072         case DoubleRepUse: {
 3073             RELEASE_ASSERT(!isAtomicsIntrinsic(m_currentNode-&gt;op()));
 3074             if (isClamped) {
 3075                 SpeculateDoubleOperand valueOp(this, valueUse);
 3076                 GPRTemporary result(this);
 3077                 FPRTemporary floatScratch(this);
 3078                 FPRReg fpr = valueOp.fpr();
 3079                 GPRReg gpr = result.gpr();
 3080                 compileClampDoubleToByte(m_jit, gpr, fpr, floatScratch.fpr());
 3081                 value.adopt(result);
 3082             } else {
 3083 #if USE(JSVALUE32_64)
 3084                 GPRTemporary realPropertyTag(this);
 3085                 propertyTag.adopt(realPropertyTag);
 3086                 GPRReg propertyTagGPR = propertyTag.gpr();
 3087 
 3088                 GPRTemporary realValueTag(this);
 3089                 valueTag.adopt(realValueTag);
 3090                 GPRReg valueTagGPR = valueTag.gpr();
 3091 #endif
 3092                 SpeculateDoubleOperand valueOp(this, valueUse);
 3093                 GPRTemporary result(this);
 3094                 FPRReg fpr = valueOp.fpr();
 3095                 GPRReg gpr = result.gpr();
 3096                 MacroAssembler::Jump notNaN = m_jit.branchIfNotNaN(fpr);
 3097                 m_jit.xorPtr(gpr, gpr);
 3098                 MacroAssembler::JumpList fixed(m_jit.jump());
 3099                 notNaN.link(&amp;m_jit);
 3100 
 3101                 fixed.append(m_jit.branchTruncateDoubleToInt32(
 3102                     fpr, gpr, MacroAssembler::BranchIfTruncateSuccessful));
 3103 
 3104 #if USE(JSVALUE64)
<a name="54" id="anc54"></a><span class="line-modified"> 3105                 m_jit.or64(GPRInfo::numberTagRegister, property);</span>
 3106                 boxDouble(fpr, gpr);
 3107 #else
 3108                 UNUSED_PARAM(property);
 3109                 m_jit.move(TrustedImm32(JSValue::Int32Tag), propertyTagGPR);
 3110                 boxDouble(fpr, valueTagGPR, gpr);
 3111 #endif
 3112                 slowPathCases.append(m_jit.jump());
 3113 
 3114                 fixed.link(&amp;m_jit);
 3115                 value.adopt(result);
 3116             }
 3117             break;
 3118         }
 3119 
 3120         default:
 3121             RELEASE_ASSERT_NOT_REACHED();
 3122             break;
 3123         }
 3124     }
 3125     return true;
 3126 }
 3127 
 3128 void SpeculativeJIT::compilePutByValForIntTypedArray(GPRReg base, GPRReg property, Node* node, TypedArrayType type)
 3129 {
 3130     ASSERT(isInt(type));
 3131 
 3132     StorageOperand storage(this, m_jit.graph().varArgChild(node, 3));
 3133     GPRReg storageReg = storage.gpr();
 3134 
 3135     Edge valueUse = m_jit.graph().varArgChild(node, 2);
 3136 
 3137     GPRTemporary value;
 3138 #if USE(JSVALUE32_64)
 3139     GPRTemporary propertyTag;
 3140     GPRTemporary valueTag;
 3141 #endif
 3142 
 3143     JITCompiler::JumpList slowPathCases;
 3144 
 3145     bool result = getIntTypedArrayStoreOperand(
 3146         value, property,
 3147 #if USE(JSVALUE32_64)
 3148         propertyTag, valueTag,
 3149 #endif
 3150         valueUse, slowPathCases, isClamped(type));
 3151     if (!result) {
 3152         noResult(node);
 3153         return;
 3154     }
 3155 
 3156     GPRReg valueGPR = value.gpr();
 3157 #if USE(JSVALUE32_64)
 3158     GPRReg propertyTagGPR = propertyTag.gpr();
 3159     GPRReg valueTagGPR = valueTag.gpr();
 3160 #endif
 3161 
 3162     ASSERT_UNUSED(valueGPR, valueGPR != property);
 3163     ASSERT(valueGPR != base);
 3164     ASSERT(valueGPR != storageReg);
 3165     JITCompiler::Jump outOfBounds = jumpForTypedArrayOutOfBounds(node, base, property);
 3166 
 3167     switch (elementSize(type)) {
 3168     case 1:
 3169         m_jit.store8(value.gpr(), MacroAssembler::BaseIndex(storageReg, property, MacroAssembler::TimesOne));
 3170         break;
 3171     case 2:
 3172         m_jit.store16(value.gpr(), MacroAssembler::BaseIndex(storageReg, property, MacroAssembler::TimesTwo));
 3173         break;
 3174     case 4:
 3175         m_jit.store32(value.gpr(), MacroAssembler::BaseIndex(storageReg, property, MacroAssembler::TimesFour));
 3176         break;
 3177     default:
 3178         CRASH();
 3179     }
 3180 
 3181     JITCompiler::Jump done = jumpForTypedArrayIsNeuteredIfOutOfBounds(node, base, outOfBounds);
 3182     if (done.isSet())
 3183         done.link(&amp;m_jit);
 3184 
 3185     if (!slowPathCases.empty()) {
 3186 #if USE(JSVALUE64)
 3187         if (node-&gt;op() == PutByValDirect) {
 3188             addSlowPathGenerator(slowPathCall(
 3189                 slowPathCases, this,
 3190                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectStrict : operationPutByValDirectNonStrict,
<a name="55" id="anc55"></a><span class="line-modified"> 3191                 NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), base, property, valueGPR));</span>
 3192         } else {
 3193             addSlowPathGenerator(slowPathCall(
 3194                 slowPathCases, this,
 3195                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValStrict : operationPutByValNonStrict,
<a name="56" id="anc56"></a><span class="line-modified"> 3196                 NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), base, property, valueGPR));</span>
 3197         }
 3198 #else // not USE(JSVALUE64)
 3199         if (node-&gt;op() == PutByValDirect) {
 3200             addSlowPathGenerator(slowPathCall(
 3201                 slowPathCases, this,
 3202                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectCellStrict : operationPutByValDirectCellNonStrict,
<a name="57" id="anc57"></a><span class="line-modified"> 3203                 NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), base, JSValueRegs(propertyTagGPR, property), JSValueRegs(valueTagGPR, valueGPR)));</span>
 3204         } else {
 3205             addSlowPathGenerator(slowPathCall(
 3206                 slowPathCases, this,
 3207                 m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellStrict : operationPutByValCellNonStrict,
<a name="58" id="anc58"></a><span class="line-modified"> 3208                 NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), base, JSValueRegs(propertyTagGPR, property), JSValueRegs(valueTagGPR, valueGPR)));</span>
 3209         }
 3210 #endif
 3211     }
 3212 
 3213     noResult(node);
 3214 }
 3215 
 3216 void SpeculativeJIT::compileGetByValOnFloatTypedArray(Node* node, TypedArrayType type)
 3217 {
 3218     ASSERT(isFloat(type));
 3219 
 3220     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
 3221     SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
 3222     StorageOperand storage(this, m_graph.varArgChild(node, 2));
 3223 
 3224     GPRReg baseReg = base.gpr();
 3225     GPRReg propertyReg = property.gpr();
 3226     GPRReg storageReg = storage.gpr();
 3227 
 3228     FPRTemporary result(this);
 3229     FPRReg resultReg = result.fpr();
 3230     emitTypedArrayBoundsCheck(node, baseReg, propertyReg);
 3231     switch (elementSize(type)) {
 3232     case 4:
 3233         m_jit.loadFloat(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesFour), resultReg);
 3234         m_jit.convertFloatToDouble(resultReg, resultReg);
 3235         break;
 3236     case 8: {
 3237         m_jit.loadDouble(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), resultReg);
 3238         break;
 3239     }
 3240     default:
 3241         RELEASE_ASSERT_NOT_REACHED();
 3242     }
 3243 
 3244     doubleResult(resultReg, node);
 3245 }
 3246 
 3247 void SpeculativeJIT::compilePutByValForFloatTypedArray(GPRReg base, GPRReg property, Node* node, TypedArrayType type)
 3248 {
 3249     ASSERT(isFloat(type));
 3250 
 3251     StorageOperand storage(this, m_jit.graph().varArgChild(node, 3));
 3252     GPRReg storageReg = storage.gpr();
 3253 
 3254     Edge baseUse = m_jit.graph().varArgChild(node, 0);
 3255     Edge valueUse = m_jit.graph().varArgChild(node, 2);
 3256 
 3257     SpeculateDoubleOperand valueOp(this, valueUse);
 3258     FPRTemporary scratch(this);
 3259     FPRReg valueFPR = valueOp.fpr();
 3260     FPRReg scratchFPR = scratch.fpr();
 3261 
 3262     ASSERT_UNUSED(baseUse, node-&gt;arrayMode().alreadyChecked(m_jit.graph(), node, m_state.forNode(baseUse)));
 3263 
 3264     MacroAssembler::Jump outOfBounds = jumpForTypedArrayOutOfBounds(node, base, property);
 3265 
 3266     switch (elementSize(type)) {
 3267     case 4: {
 3268         m_jit.moveDouble(valueFPR, scratchFPR);
 3269         m_jit.convertDoubleToFloat(valueFPR, scratchFPR);
 3270         m_jit.storeFloat(scratchFPR, MacroAssembler::BaseIndex(storageReg, property, MacroAssembler::TimesFour));
 3271         break;
 3272     }
 3273     case 8:
 3274         m_jit.storeDouble(valueFPR, MacroAssembler::BaseIndex(storageReg, property, MacroAssembler::TimesEight));
 3275         break;
 3276     default:
 3277         RELEASE_ASSERT_NOT_REACHED();
 3278     }
 3279 
 3280     JITCompiler::Jump done = jumpForTypedArrayIsNeuteredIfOutOfBounds(node, base, outOfBounds);
 3281     if (done.isSet())
 3282         done.link(&amp;m_jit);
 3283     noResult(node);
 3284 }
 3285 
 3286 void SpeculativeJIT::compileGetByValForObjectWithString(Node* node)
 3287 {
 3288     SpeculateCellOperand arg1(this, m_graph.varArgChild(node, 0));
 3289     SpeculateCellOperand arg2(this, m_graph.varArgChild(node, 1));
 3290 
 3291     GPRReg arg1GPR = arg1.gpr();
 3292     GPRReg arg2GPR = arg2.gpr();
 3293 
 3294     speculateObject(m_graph.varArgChild(node, 0), arg1GPR);
 3295     speculateString(m_graph.varArgChild(node, 1), arg2GPR);
 3296 
 3297     flushRegisters();
 3298     JSValueRegsFlushedCallResult result(this);
 3299     JSValueRegs resultRegs = result.regs();
<a name="59" id="anc59"></a><span class="line-modified"> 3300     callOperation(operationGetByValObjectString, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1GPR, arg2GPR);</span>
 3301     m_jit.exceptionCheck();
 3302 
 3303     jsValueResult(resultRegs, node);
 3304 }
 3305 
 3306 void SpeculativeJIT::compileGetByValForObjectWithSymbol(Node* node)
 3307 {
 3308     SpeculateCellOperand arg1(this, m_graph.varArgChild(node, 0));
 3309     SpeculateCellOperand arg2(this, m_graph.varArgChild(node, 1));
 3310 
 3311     GPRReg arg1GPR = arg1.gpr();
 3312     GPRReg arg2GPR = arg2.gpr();
 3313 
 3314     speculateObject(m_graph.varArgChild(node, 0), arg1GPR);
 3315     speculateSymbol(m_graph.varArgChild(node, 1), arg2GPR);
 3316 
 3317     flushRegisters();
 3318     JSValueRegsFlushedCallResult result(this);
 3319     JSValueRegs resultRegs = result.regs();
<a name="60" id="anc60"></a><span class="line-modified"> 3320     callOperation(operationGetByValObjectSymbol, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1GPR, arg2GPR);</span>
 3321     m_jit.exceptionCheck();
 3322 
 3323     jsValueResult(resultRegs, node);
 3324 }
 3325 
 3326 void SpeculativeJIT::compilePutByValForCellWithString(Node* node, Edge&amp; child1, Edge&amp; child2, Edge&amp; child3)
 3327 {
 3328     SpeculateCellOperand arg1(this, child1);
 3329     SpeculateCellOperand arg2(this, child2);
 3330     JSValueOperand arg3(this, child3);
 3331 
 3332     GPRReg arg1GPR = arg1.gpr();
 3333     GPRReg arg2GPR = arg2.gpr();
 3334     JSValueRegs arg3Regs = arg3.jsValueRegs();
 3335 
 3336     speculateString(child2, arg2GPR);
 3337 
 3338     flushRegisters();
<a name="61" id="anc61"></a><span class="line-modified"> 3339     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellStringStrict : operationPutByValCellStringNonStrict, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1GPR, arg2GPR, arg3Regs);</span>
 3340     m_jit.exceptionCheck();
 3341 
 3342     noResult(node);
 3343 }
 3344 
 3345 void SpeculativeJIT::compilePutByValForCellWithSymbol(Node* node, Edge&amp; child1, Edge&amp; child2, Edge&amp; child3)
 3346 {
 3347     SpeculateCellOperand arg1(this, child1);
 3348     SpeculateCellOperand arg2(this, child2);
 3349     JSValueOperand arg3(this, child3);
 3350 
 3351     GPRReg arg1GPR = arg1.gpr();
 3352     GPRReg arg2GPR = arg2.gpr();
 3353     JSValueRegs arg3Regs = arg3.jsValueRegs();
 3354 
 3355     speculateSymbol(child2, arg2GPR);
 3356 
 3357     flushRegisters();
<a name="62" id="anc62"></a><span class="line-modified"> 3358     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValCellSymbolStrict : operationPutByValCellSymbolNonStrict, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1GPR, arg2GPR, arg3Regs);</span>
 3359     m_jit.exceptionCheck();
 3360 
 3361     noResult(node);
 3362 }
 3363 
 3364 void SpeculativeJIT::compileGetByValWithThis(Node* node)
 3365 {
 3366     JSValueOperand base(this, node-&gt;child1());
 3367     JSValueRegs baseRegs = base.jsValueRegs();
 3368     JSValueOperand thisValue(this, node-&gt;child2());
 3369     JSValueRegs thisValueRegs = thisValue.jsValueRegs();
 3370     JSValueOperand subscript(this, node-&gt;child3());
 3371     JSValueRegs subscriptRegs = subscript.jsValueRegs();
 3372 
 3373     flushRegisters();
 3374     JSValueRegsFlushedCallResult result(this);
 3375     JSValueRegs resultRegs = result.regs();
<a name="63" id="anc63"></a><span class="line-modified"> 3376     callOperation(operationGetByValWithThis, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseRegs, thisValueRegs, subscriptRegs);</span>
 3377     m_jit.exceptionCheck();
 3378 
 3379     jsValueResult(resultRegs, node);
 3380 }
 3381 
 3382 void SpeculativeJIT::compileCheckTypeInfoFlags(Node* node)
 3383 {
 3384     SpeculateCellOperand base(this, node-&gt;child1());
 3385 
 3386     GPRReg baseGPR = base.gpr();
 3387 
 3388     // FIXME: This only works for checking if a single bit is set. If we want to check more
 3389     // than one bit at once, we&#39;ll need to fix this:
 3390     // https://bugs.webkit.org/show_bug.cgi?id=185705
 3391     speculationCheck(BadTypeInfoFlags, JSValueRegs(), 0, m_jit.branchTest8(MacroAssembler::Zero, MacroAssembler::Address(baseGPR, JSCell::typeInfoFlagsOffset()), MacroAssembler::TrustedImm32(node-&gt;typeInfoOperand())));
 3392 
 3393     noResult(node);
 3394 }
 3395 
 3396 void SpeculativeJIT::compileParseInt(Node* node)
 3397 {
 3398     RELEASE_ASSERT(node-&gt;child1().useKind() == UntypedUse || node-&gt;child1().useKind() == StringUse);
 3399     if (node-&gt;child2()) {
 3400         SpeculateInt32Operand radix(this, node-&gt;child2());
 3401         GPRReg radixGPR = radix.gpr();
 3402         if (node-&gt;child1().useKind() == UntypedUse) {
 3403             JSValueOperand value(this, node-&gt;child1());
 3404             JSValueRegs valueRegs = value.jsValueRegs();
 3405 
 3406             flushRegisters();
 3407             JSValueRegsFlushedCallResult result(this);
 3408             JSValueRegs resultRegs = result.regs();
<a name="64" id="anc64"></a><span class="line-modified"> 3409             callOperation(operationParseIntGeneric, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs, radixGPR);</span>
 3410             m_jit.exceptionCheck();
 3411             jsValueResult(resultRegs, node);
 3412             return;
 3413         }
 3414 
 3415         SpeculateCellOperand value(this, node-&gt;child1());
 3416         GPRReg valueGPR = value.gpr();
 3417         speculateString(node-&gt;child1(), valueGPR);
 3418 
 3419         flushRegisters();
 3420         JSValueRegsFlushedCallResult result(this);
 3421         JSValueRegs resultRegs = result.regs();
<a name="65" id="anc65"></a><span class="line-modified"> 3422         callOperation(operationParseIntString, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueGPR, radixGPR);</span>
 3423         m_jit.exceptionCheck();
 3424         jsValueResult(resultRegs, node);
 3425         return;
 3426     }
 3427 
 3428     if (node-&gt;child1().useKind() == UntypedUse) {
 3429         JSValueOperand value(this, node-&gt;child1());
 3430         JSValueRegs valueRegs = value.jsValueRegs();
 3431 
 3432         flushRegisters();
 3433         JSValueRegsFlushedCallResult result(this);
 3434         JSValueRegs resultRegs = result.regs();
<a name="66" id="anc66"></a><span class="line-modified"> 3435         callOperation(operationParseIntNoRadixGeneric, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs);</span>
 3436         m_jit.exceptionCheck();
 3437         jsValueResult(resultRegs, node);
 3438         return;
 3439     }
 3440 
 3441     SpeculateCellOperand value(this, node-&gt;child1());
 3442     GPRReg valueGPR = value.gpr();
 3443     speculateString(node-&gt;child1(), valueGPR);
 3444 
 3445     flushRegisters();
 3446     JSValueRegsFlushedCallResult result(this);
 3447     JSValueRegs resultRegs = result.regs();
<a name="67" id="anc67"></a><span class="line-modified"> 3448     callOperation(operationParseIntStringNoRadix, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueGPR);</span>
 3449     m_jit.exceptionCheck();
 3450     jsValueResult(resultRegs, node);
 3451 }
 3452 
 3453 void SpeculativeJIT::compileOverridesHasInstance(Node* node)
 3454 {
 3455     Node* hasInstanceValueNode = node-&gt;child2().node();
 3456     JSFunction* defaultHasInstanceFunction = jsCast&lt;JSFunction*&gt;(node-&gt;cellOperand()-&gt;value());
 3457 
 3458     MacroAssembler::JumpList notDefault;
 3459     SpeculateCellOperand base(this, node-&gt;child1());
 3460     JSValueOperand hasInstanceValue(this, node-&gt;child2());
 3461     GPRTemporary result(this);
 3462 
 3463     GPRReg baseGPR = base.gpr();
 3464     GPRReg resultGPR = result.gpr();
 3465 
 3466     // It would be great if constant folding handled automatically the case where we knew the hasInstance function
 3467     // was a constant. Unfortunately, the folding rule for OverridesHasInstance is in the strength reduction phase
 3468     // since it relies on OSR information. https://bugs.webkit.org/show_bug.cgi?id=154832
 3469     if (!hasInstanceValueNode-&gt;isCellConstant() || defaultHasInstanceFunction != hasInstanceValueNode-&gt;asCell()) {
 3470         JSValueRegs hasInstanceValueRegs = hasInstanceValue.jsValueRegs();
 3471 #if USE(JSVALUE64)
 3472         notDefault.append(m_jit.branchPtr(MacroAssembler::NotEqual, hasInstanceValueRegs.gpr(), TrustedImmPtr(node-&gt;cellOperand())));
 3473 #else
 3474         notDefault.append(m_jit.branchIfNotCell(hasInstanceValueRegs));
 3475         notDefault.append(m_jit.branchPtr(MacroAssembler::NotEqual, hasInstanceValueRegs.payloadGPR(), TrustedImmPtr(node-&gt;cellOperand())));
 3476 #endif
 3477     }
 3478 
 3479     // Check that base &#39;ImplementsDefaultHasInstance&#39;.
 3480     m_jit.test8(MacroAssembler::Zero, MacroAssembler::Address(baseGPR, JSCell::typeInfoFlagsOffset()), MacroAssembler::TrustedImm32(ImplementsDefaultHasInstance), resultGPR);
 3481     MacroAssembler::Jump done = m_jit.jump();
 3482 
 3483     if (!notDefault.empty()) {
 3484         notDefault.link(&amp;m_jit);
 3485         m_jit.move(TrustedImm32(1), resultGPR);
 3486     }
 3487 
 3488     done.link(&amp;m_jit);
 3489     unblessedBooleanResult(resultGPR, node);
 3490 }
 3491 
 3492 void SpeculativeJIT::compileInstanceOfForCells(Node* node, JSValueRegs valueRegs, JSValueRegs prototypeRegs, GPRReg resultGPR, GPRReg scratchGPR, GPRReg scratch2GPR, JITCompiler::Jump slowCase)
 3493 {
 3494     CallSiteIndex callSiteIndex = m_jit.addCallSite(node-&gt;origin.semantic);
 3495 
 3496     JITInstanceOfGenerator gen(
 3497         m_jit.codeBlock(), node-&gt;origin.semantic, callSiteIndex, usedRegisters(), resultGPR,
 3498         valueRegs.payloadGPR(), prototypeRegs.payloadGPR(), scratchGPR, scratch2GPR,
 3499         m_state.forNode(node-&gt;child2()).isType(SpecObject | ~SpecCell));
 3500     gen.generateFastPath(m_jit);
 3501 
 3502     JITCompiler::JumpList slowCases;
 3503     slowCases.append(slowCase);
 3504 
 3505     std::unique_ptr&lt;SlowPathGenerator&gt; slowPath = slowPathCall(
<a name="68" id="anc68"></a><span class="line-modified"> 3506         slowCases, this, operationInstanceOfOptimize, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), gen.stubInfo(), valueRegs,</span>
 3507         prototypeRegs);
 3508 
 3509     m_jit.addInstanceOf(gen, slowPath.get());
 3510     addSlowPathGenerator(WTFMove(slowPath));
 3511 }
 3512 
 3513 void SpeculativeJIT::compileInstanceOf(Node* node)
 3514 {
 3515 #if USE(JSVALUE64)
 3516     if (node-&gt;child1().useKind() == CellUse
 3517         &amp;&amp; node-&gt;child2().useKind() == CellUse) {
 3518         SpeculateCellOperand value(this, node-&gt;child1());
 3519         SpeculateCellOperand prototype(this, node-&gt;child2());
 3520 
 3521         GPRTemporary result(this);
 3522         GPRTemporary scratch(this);
 3523         GPRTemporary scratch2(this);
 3524 
 3525         GPRReg valueGPR = value.gpr();
 3526         GPRReg prototypeGPR = prototype.gpr();
 3527         GPRReg resultGPR = result.gpr();
 3528         GPRReg scratchGPR = scratch.gpr();
 3529         GPRReg scratch2GPR = scratch2.gpr();
 3530 
 3531         compileInstanceOfForCells(node, JSValueRegs(valueGPR), JSValueRegs(prototypeGPR), resultGPR, scratchGPR, scratch2GPR);
 3532 
 3533         blessedBooleanResult(resultGPR, node);
 3534         return;
 3535     }
 3536 #endif
 3537 
 3538     DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse);
 3539     DFG_ASSERT(m_jit.graph(), node, node-&gt;child2().useKind() == UntypedUse);
 3540 
 3541     JSValueOperand value(this, node-&gt;child1());
 3542     JSValueOperand prototype(this, node-&gt;child2());
 3543 
 3544     GPRTemporary result(this);
 3545     GPRTemporary scratch(this);
 3546 
 3547     JSValueRegs valueRegs = value.jsValueRegs();
 3548     JSValueRegs prototypeRegs = prototype.jsValueRegs();
 3549 
 3550     GPRReg resultGPR = result.gpr();
 3551     GPRReg scratchGPR = scratch.gpr();
 3552 
 3553     JITCompiler::Jump isCell = m_jit.branchIfCell(valueRegs);
 3554     moveFalseTo(resultGPR);
 3555 
 3556     JITCompiler::Jump done = m_jit.jump();
 3557 
 3558     isCell.link(&amp;m_jit);
 3559 
 3560     JITCompiler::Jump slowCase = m_jit.branchIfNotCell(prototypeRegs);
 3561 
 3562     compileInstanceOfForCells(node, valueRegs, prototypeRegs, resultGPR, scratchGPR, InvalidGPRReg, slowCase);
 3563 
 3564     done.link(&amp;m_jit);
 3565     blessedBooleanResult(resultGPR, node);
 3566     return;
 3567 }
 3568 
 3569 void SpeculativeJIT::compileValueBitNot(Node* node)
 3570 {
 3571     Edge&amp; child1 = node-&gt;child1();
 3572 
 3573     if (child1.useKind() == BigIntUse) {
 3574         SpeculateCellOperand operand(this, child1);
 3575         GPRReg operandGPR = operand.gpr();
 3576 
 3577         speculateBigInt(child1, operandGPR);
 3578 
 3579         flushRegisters();
 3580         GPRFlushedCallResult result(this);
 3581         GPRReg resultGPR = result.gpr();
 3582 
<a name="69" id="anc69"></a><span class="line-modified"> 3583         callOperation(operationBitNotBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), operandGPR);</span>
 3584         m_jit.exceptionCheck();
 3585         cellResult(resultGPR, node);
 3586 
 3587         return;
 3588     }
 3589 
 3590     JSValueOperand operand(this, child1);
 3591     JSValueRegs operandRegs = operand.jsValueRegs();
 3592 
 3593     flushRegisters();
 3594     JSValueRegsFlushedCallResult result(this);
 3595     JSValueRegs resultRegs = result.regs();
<a name="70" id="anc70"></a><span class="line-modified"> 3596     callOperation(operationValueBitNot, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), operandRegs);</span>
 3597     m_jit.exceptionCheck();
 3598 
 3599     jsValueResult(resultRegs, node);
 3600 }
 3601 
 3602 void SpeculativeJIT::compileBitwiseNot(Node* node)
 3603 {
 3604     Edge&amp; child1 = node-&gt;child1();
 3605 
 3606     SpeculateInt32Operand operand(this, child1);
 3607     GPRTemporary result(this);
 3608     GPRReg resultGPR = result.gpr();
 3609 
 3610     m_jit.move(operand.gpr(), resultGPR);
 3611 
 3612     m_jit.not32(resultGPR);
 3613 
 3614     int32Result(resultGPR, node);
 3615 }
 3616 
<a name="71" id="anc71"></a><span class="line-modified"> 3617 template&lt;typename SnippetGenerator, J_JITOperation_GJJ snippetSlowPathFunction&gt;</span>
 3618 void SpeculativeJIT::emitUntypedBitOp(Node* node)
 3619 {
 3620     Edge&amp; leftChild = node-&gt;child1();
 3621     Edge&amp; rightChild = node-&gt;child2();
 3622 
 3623     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 3624         JSValueOperand left(this, leftChild);
 3625         JSValueOperand right(this, rightChild);
 3626         JSValueRegs leftRegs = left.jsValueRegs();
 3627         JSValueRegs rightRegs = right.jsValueRegs();
 3628 
 3629         flushRegisters();
 3630         JSValueRegsFlushedCallResult result(this);
 3631         JSValueRegs resultRegs = result.regs();
<a name="72" id="anc72"></a><span class="line-modified"> 3632         callOperation(snippetSlowPathFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
 3633         m_jit.exceptionCheck();
 3634 
 3635         jsValueResult(resultRegs, node);
 3636         return;
 3637     }
 3638 
 3639     Optional&lt;JSValueOperand&gt; left;
 3640     Optional&lt;JSValueOperand&gt; right;
 3641 
 3642     JSValueRegs leftRegs;
 3643     JSValueRegs rightRegs;
 3644 
 3645 #if USE(JSVALUE64)
 3646     GPRTemporary result(this);
 3647     JSValueRegs resultRegs = JSValueRegs(result.gpr());
 3648     GPRTemporary scratch(this);
 3649     GPRReg scratchGPR = scratch.gpr();
 3650 #else
 3651     GPRTemporary resultTag(this);
 3652     GPRTemporary resultPayload(this);
 3653     JSValueRegs resultRegs = JSValueRegs(resultPayload.gpr(), resultTag.gpr());
 3654     GPRReg scratchGPR = resultTag.gpr();
 3655 #endif
 3656 
 3657     SnippetOperand leftOperand;
 3658     SnippetOperand rightOperand;
 3659 
 3660     // The snippet generator does not support both operands being constant. If the left
 3661     // operand is already const, we&#39;ll ignore the right operand&#39;s constness.
 3662     if (leftChild-&gt;isInt32Constant())
 3663         leftOperand.setConstInt32(leftChild-&gt;asInt32());
 3664     else if (rightChild-&gt;isInt32Constant())
 3665         rightOperand.setConstInt32(rightChild-&gt;asInt32());
 3666 
 3667     RELEASE_ASSERT(!leftOperand.isConst() || !rightOperand.isConst());
 3668 
 3669     if (!leftOperand.isConst()) {
 3670         left.emplace(this, leftChild);
 3671         leftRegs = left-&gt;jsValueRegs();
 3672     }
 3673     if (!rightOperand.isConst()) {
 3674         right.emplace(this, rightChild);
 3675         rightRegs = right-&gt;jsValueRegs();
 3676     }
 3677 
 3678     SnippetGenerator gen(leftOperand, rightOperand, resultRegs, leftRegs, rightRegs, scratchGPR);
 3679     gen.generateFastPath(m_jit);
 3680 
 3681     ASSERT(gen.didEmitFastPath());
 3682     gen.endJumpList().append(m_jit.jump());
 3683 
 3684     gen.slowPathJumpList().link(&amp;m_jit);
 3685     silentSpillAllRegisters(resultRegs);
 3686 
 3687     if (leftOperand.isConst()) {
 3688         leftRegs = resultRegs;
 3689         m_jit.moveValue(leftChild-&gt;asJSValue(), leftRegs);
 3690     } else if (rightOperand.isConst()) {
 3691         rightRegs = resultRegs;
 3692         m_jit.moveValue(rightChild-&gt;asJSValue(), rightRegs);
 3693     }
 3694 
<a name="73" id="anc73"></a><span class="line-modified"> 3695     callOperation(snippetSlowPathFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
 3696 
 3697     silentFillAllRegisters();
 3698     m_jit.exceptionCheck();
 3699 
 3700     gen.endJumpList().link(&amp;m_jit);
 3701     jsValueResult(resultRegs, node);
 3702 }
 3703 
 3704 void SpeculativeJIT::compileValueBitwiseOp(Node* node)
 3705 {
 3706     NodeType op = node-&gt;op();
 3707     Edge&amp; leftChild = node-&gt;child1();
 3708     Edge&amp; rightChild = node-&gt;child2();
 3709 
 3710     if (leftChild.useKind() == UntypedUse || rightChild.useKind() == UntypedUse) {
 3711         switch (op) {
 3712         case ValueBitAnd:
 3713             emitUntypedBitOp&lt;JITBitAndGenerator, operationValueBitAnd&gt;(node);
 3714             return;
 3715         case ValueBitXor:
 3716             emitUntypedBitOp&lt;JITBitXorGenerator, operationValueBitXor&gt;(node);
 3717             return;
 3718         case ValueBitOr:
 3719             emitUntypedBitOp&lt;JITBitOrGenerator, operationValueBitOr&gt;(node);
 3720             return;
 3721         default:
 3722             RELEASE_ASSERT_NOT_REACHED();
 3723         }
 3724     }
 3725 
 3726     ASSERT(leftChild.useKind() == BigIntUse &amp;&amp; rightChild.useKind() == BigIntUse);
 3727 
 3728     SpeculateCellOperand left(this, node-&gt;child1());
 3729     SpeculateCellOperand right(this, node-&gt;child2());
 3730     GPRReg leftGPR = left.gpr();
 3731     GPRReg rightGPR = right.gpr();
 3732 
 3733     speculateBigInt(leftChild, leftGPR);
 3734     speculateBigInt(rightChild, rightGPR);
 3735 
 3736     flushRegisters();
 3737     GPRFlushedCallResult result(this);
 3738     GPRReg resultGPR = result.gpr();
 3739 
 3740     switch (op) {
 3741     case ValueBitAnd:
<a name="74" id="anc74"></a><span class="line-modified"> 3742         callOperation(operationBitAndBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
 3743         break;
 3744     case ValueBitXor:
<a name="75" id="anc75"></a><span class="line-modified"> 3745         callOperation(operationBitXorBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
 3746         break;
 3747     case ValueBitOr:
<a name="76" id="anc76"></a><span class="line-modified"> 3748         callOperation(operationBitOrBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
 3749         break;
 3750     default:
 3751         RELEASE_ASSERT_NOT_REACHED();
 3752     }
 3753 
 3754     m_jit.exceptionCheck();
 3755     cellResult(resultGPR, node);
 3756 }
 3757 
 3758 void SpeculativeJIT::compileBitwiseOp(Node* node)
 3759 {
 3760     NodeType op = node-&gt;op();
 3761     Edge&amp; leftChild = node-&gt;child1();
 3762     Edge&amp; rightChild = node-&gt;child2();
 3763 
 3764     if (leftChild-&gt;isInt32Constant()) {
 3765         SpeculateInt32Operand op2(this, rightChild);
 3766         GPRTemporary result(this, Reuse, op2);
 3767 
 3768         bitOp(op, leftChild-&gt;asInt32(), op2.gpr(), result.gpr());
 3769 
 3770         int32Result(result.gpr(), node);
 3771         return;
 3772     }
 3773 
 3774     if (rightChild-&gt;isInt32Constant()) {
 3775         SpeculateInt32Operand op1(this, leftChild);
 3776         GPRTemporary result(this, Reuse, op1);
 3777 
 3778         bitOp(op, rightChild-&gt;asInt32(), op1.gpr(), result.gpr());
 3779 
 3780         int32Result(result.gpr(), node);
 3781         return;
 3782     }
 3783 
 3784     SpeculateInt32Operand op1(this, leftChild);
 3785     SpeculateInt32Operand op2(this, rightChild);
 3786     GPRTemporary result(this, Reuse, op1, op2);
 3787 
 3788     GPRReg reg1 = op1.gpr();
 3789     GPRReg reg2 = op2.gpr();
 3790     bitOp(op, reg1, reg2, result.gpr());
 3791 
 3792     int32Result(result.gpr(), node);
 3793 }
 3794 
 3795 void SpeculativeJIT::emitUntypedRightShiftBitOp(Node* node)
 3796 {
<a name="77" id="anc77"></a><span class="line-modified"> 3797     J_JITOperation_GJJ snippetSlowPathFunction = node-&gt;op() == ValueBitRShift</span>
 3798         ? operationValueBitRShift : operationValueBitURShift;
<a name="78" id="anc78"></a><span class="line-modified"> 3799     JITRightShiftGenerator::ShiftType shiftType = node-&gt;op() == ValueBitRShift</span>
 3800         ? JITRightShiftGenerator::SignedShift : JITRightShiftGenerator::UnsignedShift;
 3801 
 3802     Edge&amp; leftChild = node-&gt;child1();
 3803     Edge&amp; rightChild = node-&gt;child2();
 3804 
 3805     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 3806         JSValueOperand left(this, leftChild);
 3807         JSValueOperand right(this, rightChild);
 3808         JSValueRegs leftRegs = left.jsValueRegs();
 3809         JSValueRegs rightRegs = right.jsValueRegs();
 3810 
 3811         flushRegisters();
 3812         JSValueRegsFlushedCallResult result(this);
 3813         JSValueRegs resultRegs = result.regs();
<a name="79" id="anc79"></a><span class="line-modified"> 3814         callOperation(snippetSlowPathFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
 3815         m_jit.exceptionCheck();
 3816 
 3817         jsValueResult(resultRegs, node);
 3818         return;
 3819     }
 3820 
 3821     Optional&lt;JSValueOperand&gt; left;
 3822     Optional&lt;JSValueOperand&gt; right;
 3823 
 3824     JSValueRegs leftRegs;
 3825     JSValueRegs rightRegs;
 3826 
 3827     FPRTemporary leftNumber(this);
 3828     FPRReg leftFPR = leftNumber.fpr();
 3829 
 3830 #if USE(JSVALUE64)
 3831     GPRTemporary result(this);
 3832     JSValueRegs resultRegs = JSValueRegs(result.gpr());
 3833     GPRTemporary scratch(this);
 3834     GPRReg scratchGPR = scratch.gpr();
 3835     FPRReg scratchFPR = InvalidFPRReg;
 3836 #else
 3837     GPRTemporary resultTag(this);
 3838     GPRTemporary resultPayload(this);
 3839     JSValueRegs resultRegs = JSValueRegs(resultPayload.gpr(), resultTag.gpr());
 3840     GPRReg scratchGPR = resultTag.gpr();
 3841     FPRTemporary fprScratch(this);
 3842     FPRReg scratchFPR = fprScratch.fpr();
 3843 #endif
 3844 
 3845     SnippetOperand leftOperand;
 3846     SnippetOperand rightOperand;
 3847 
 3848     // The snippet generator does not support both operands being constant. If the left
 3849     // operand is already const, we&#39;ll ignore the right operand&#39;s constness.
 3850     if (leftChild-&gt;isInt32Constant())
 3851         leftOperand.setConstInt32(leftChild-&gt;asInt32());
 3852     else if (rightChild-&gt;isInt32Constant())
 3853         rightOperand.setConstInt32(rightChild-&gt;asInt32());
 3854 
 3855     RELEASE_ASSERT(!leftOperand.isConst() || !rightOperand.isConst());
 3856 
 3857     if (!leftOperand.isConst()) {
 3858         left.emplace(this, leftChild);
 3859         leftRegs = left-&gt;jsValueRegs();
 3860     }
 3861     if (!rightOperand.isConst()) {
 3862         right.emplace(this, rightChild);
 3863         rightRegs = right-&gt;jsValueRegs();
 3864     }
 3865 
 3866     JITRightShiftGenerator gen(leftOperand, rightOperand, resultRegs, leftRegs, rightRegs,
 3867         leftFPR, scratchGPR, scratchFPR, shiftType);
 3868     gen.generateFastPath(m_jit);
 3869 
 3870     ASSERT(gen.didEmitFastPath());
 3871     gen.endJumpList().append(m_jit.jump());
 3872 
 3873     gen.slowPathJumpList().link(&amp;m_jit);
 3874     silentSpillAllRegisters(resultRegs);
 3875 
 3876     if (leftOperand.isConst()) {
 3877         leftRegs = resultRegs;
 3878         m_jit.moveValue(leftChild-&gt;asJSValue(), leftRegs);
 3879     } else if (rightOperand.isConst()) {
 3880         rightRegs = resultRegs;
 3881         m_jit.moveValue(rightChild-&gt;asJSValue(), rightRegs);
 3882     }
 3883 
<a name="80" id="anc80"></a><span class="line-modified"> 3884     callOperation(snippetSlowPathFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
 3885 
 3886     silentFillAllRegisters();
 3887     m_jit.exceptionCheck();
 3888 
 3889     gen.endJumpList().link(&amp;m_jit);
 3890     jsValueResult(resultRegs, node);
 3891     return;
 3892 }
 3893 
 3894 void SpeculativeJIT::compileValueLShiftOp(Node* node)
 3895 {
 3896     Edge&amp; leftChild = node-&gt;child1();
 3897     Edge&amp; rightChild = node-&gt;child2();
 3898 
 3899     if (node-&gt;binaryUseKind() == BigIntUse) {
 3900         SpeculateCellOperand left(this, leftChild);
 3901         SpeculateCellOperand right(this, rightChild);
 3902         GPRReg leftGPR = left.gpr();
 3903         GPRReg rightGPR = right.gpr();
 3904 
 3905         speculateBigInt(leftChild, leftGPR);
 3906         speculateBigInt(rightChild, rightGPR);
 3907 
 3908         flushRegisters();
 3909         GPRFlushedCallResult result(this);
 3910         GPRReg resultGPR = result.gpr();
 3911 
<a name="81" id="anc81"></a><span class="line-modified"> 3912         callOperation(operationBitLShiftBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
 3913         m_jit.exceptionCheck();
 3914         cellResult(resultGPR, node);
 3915         return;
 3916     }
 3917 
 3918     ASSERT(leftChild.useKind() == UntypedUse &amp;&amp; rightChild.useKind() == UntypedUse);
 3919     emitUntypedBitOp&lt;JITLeftShiftGenerator, operationValueBitLShift&gt;(node);
 3920 }
 3921 
<a name="82" id="anc82"></a><span class="line-added"> 3922 void SpeculativeJIT::compileValueBitRShift(Node* node)</span>
<span class="line-added"> 3923 {</span>
<span class="line-added"> 3924     Edge&amp; leftChild = node-&gt;child1();</span>
<span class="line-added"> 3925     Edge&amp; rightChild = node-&gt;child2();</span>
<span class="line-added"> 3926 </span>
<span class="line-added"> 3927     if (node-&gt;isBinaryUseKind(BigIntUse)) {</span>
<span class="line-added"> 3928         SpeculateCellOperand left(this, leftChild);</span>
<span class="line-added"> 3929         SpeculateCellOperand right(this, rightChild);</span>
<span class="line-added"> 3930         GPRReg leftGPR = left.gpr();</span>
<span class="line-added"> 3931         GPRReg rightGPR = right.gpr();</span>
<span class="line-added"> 3932 </span>
<span class="line-added"> 3933         speculateBigInt(leftChild, leftGPR);</span>
<span class="line-added"> 3934         speculateBigInt(rightChild, rightGPR);</span>
<span class="line-added"> 3935 </span>
<span class="line-added"> 3936         flushRegisters();</span>
<span class="line-added"> 3937         GPRFlushedCallResult result(this);</span>
<span class="line-added"> 3938         GPRReg resultGPR = result.gpr();</span>
<span class="line-added"> 3939         callOperation(operationBitRShiftBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
<span class="line-added"> 3940         m_jit.exceptionCheck();</span>
<span class="line-added"> 3941 </span>
<span class="line-added"> 3942         cellResult(resultGPR, node);</span>
<span class="line-added"> 3943         return;</span>
<span class="line-added"> 3944     }</span>
<span class="line-added"> 3945 </span>
<span class="line-added"> 3946     ASSERT(leftChild.useKind() == UntypedUse &amp;&amp; rightChild.useKind() == UntypedUse);</span>
<span class="line-added"> 3947     emitUntypedRightShiftBitOp(node);</span>
<span class="line-added"> 3948 }</span>
<span class="line-added"> 3949 </span>
 3950 void SpeculativeJIT::compileShiftOp(Node* node)
 3951 {
 3952     NodeType op = node-&gt;op();
 3953     Edge&amp; leftChild = node-&gt;child1();
 3954     Edge&amp; rightChild = node-&gt;child2();
 3955 
 3956     if (leftChild.useKind() == UntypedUse || rightChild.useKind() == UntypedUse) {
<a name="83" id="anc83"></a><span class="line-modified"> 3957         RELEASE_ASSERT(op == BitURShift);</span>
<span class="line-modified"> 3958         emitUntypedRightShiftBitOp(node);</span>
<span class="line-modified"> 3959         return;</span>





 3960     }
 3961 
 3962     if (rightChild-&gt;isInt32Constant()) {
 3963         SpeculateInt32Operand op1(this, leftChild);
 3964         GPRTemporary result(this, Reuse, op1);
 3965 
 3966         shiftOp(op, op1.gpr(), rightChild-&gt;asInt32() &amp; 0x1f, result.gpr());
 3967 
 3968         int32Result(result.gpr(), node);
 3969     } else {
 3970         // Do not allow shift amount to be used as the result, MacroAssembler does not permit this.
 3971         SpeculateInt32Operand op1(this, leftChild);
 3972         SpeculateInt32Operand op2(this, rightChild);
 3973         GPRTemporary result(this, Reuse, op1);
 3974 
 3975         GPRReg reg1 = op1.gpr();
 3976         GPRReg reg2 = op2.gpr();
 3977         shiftOp(op, reg1, reg2, result.gpr());
 3978 
 3979         int32Result(result.gpr(), node);
 3980     }
 3981 }
 3982 
 3983 void SpeculativeJIT::compileValueAdd(Node* node)
 3984 {
 3985     Edge&amp; leftChild = node-&gt;child1();
 3986     Edge&amp; rightChild = node-&gt;child2();
 3987 
 3988     if (node-&gt;isBinaryUseKind(BigIntUse)) {
 3989         SpeculateCellOperand left(this, node-&gt;child1());
 3990         SpeculateCellOperand right(this, node-&gt;child2());
 3991         GPRReg leftGPR = left.gpr();
 3992         GPRReg rightGPR = right.gpr();
 3993 
 3994         speculateBigInt(leftChild, leftGPR);
 3995         speculateBigInt(rightChild, rightGPR);
 3996 
 3997         flushRegisters();
 3998         GPRFlushedCallResult result(this);
 3999         GPRReg resultGPR = result.gpr();
<a name="84" id="anc84"></a><span class="line-modified"> 4000         callOperation(operationAddBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
 4001         m_jit.exceptionCheck();
 4002 
 4003         cellResult(resultGPR, node);
 4004         return;
 4005     }
 4006 
 4007     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 4008         JSValueOperand left(this, leftChild);
 4009         JSValueOperand right(this, rightChild);
 4010         JSValueRegs leftRegs = left.jsValueRegs();
 4011         JSValueRegs rightRegs = right.jsValueRegs();
 4012 
 4013         flushRegisters();
 4014         JSValueRegsFlushedCallResult result(this);
 4015         JSValueRegs resultRegs = result.regs();
<a name="85" id="anc85"></a><span class="line-modified"> 4016         callOperation(operationValueAddNotNumber, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
 4017         m_jit.exceptionCheck();
 4018 
 4019         jsValueResult(resultRegs, node);
 4020         return;
 4021     }
 4022 
 4023 #if USE(JSVALUE64)
 4024     bool needsScratchGPRReg = true;
 4025     bool needsScratchFPRReg = false;
 4026 #else
 4027     bool needsScratchGPRReg = true;
 4028     bool needsScratchFPRReg = true;
 4029 #endif
 4030 
 4031     CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<a name="86" id="anc86"></a><span class="line-modified"> 4032     BytecodeIndex bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 4033     BinaryArithProfile* arithProfile = baselineCodeBlock-&gt;binaryArithProfileForBytecodeIndex(bytecodeIndex);</span>
 4034     JITAddIC* addIC = m_jit.codeBlock()-&gt;addJITAddIC(arithProfile);
 4035     auto repatchingFunction = operationValueAddOptimize;
 4036     auto nonRepatchingFunction = operationValueAdd;
 4037 
 4038     compileMathIC(node, addIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
 4039 }
 4040 
 4041 void SpeculativeJIT::compileValueSub(Node* node)
 4042 {
 4043     Edge&amp; leftChild = node-&gt;child1();
 4044     Edge&amp; rightChild = node-&gt;child2();
 4045 
 4046     if (node-&gt;binaryUseKind() == UntypedUse) {
 4047 #if USE(JSVALUE64)
 4048         bool needsScratchGPRReg = true;
 4049         bool needsScratchFPRReg = false;
 4050 #else
 4051         bool needsScratchGPRReg = true;
 4052         bool needsScratchFPRReg = true;
 4053 #endif
 4054 
 4055         CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<a name="87" id="anc87"></a><span class="line-modified"> 4056         BytecodeIndex bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 4057         BinaryArithProfile* arithProfile = baselineCodeBlock-&gt;binaryArithProfileForBytecodeIndex(bytecodeIndex);</span>
 4058         JITSubIC* subIC = m_jit.codeBlock()-&gt;addJITSubIC(arithProfile);
 4059         auto repatchingFunction = operationValueSubOptimize;
 4060         auto nonRepatchingFunction = operationValueSub;
 4061 
 4062         compileMathIC(node, subIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
 4063         return;
 4064     }
 4065 
 4066     ASSERT(leftChild.useKind() == BigIntUse &amp;&amp; rightChild.useKind() == BigIntUse);
 4067 
 4068     SpeculateCellOperand left(this, node-&gt;child1());
 4069     SpeculateCellOperand right(this, node-&gt;child2());
 4070     GPRReg leftGPR = left.gpr();
 4071     GPRReg rightGPR = right.gpr();
 4072 
 4073     speculateBigInt(leftChild, leftGPR);
 4074     speculateBigInt(rightChild, rightGPR);
 4075 
 4076     flushRegisters();
 4077     GPRFlushedCallResult result(this);
 4078     GPRReg resultGPR = result.gpr();
 4079 
<a name="88" id="anc88"></a><span class="line-modified"> 4080     callOperation(operationSubBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
 4081 
 4082     m_jit.exceptionCheck();
 4083     cellResult(resultGPR, node);
 4084 }
 4085 
 4086 template &lt;typename Generator, typename RepatchingFunction, typename NonRepatchingFunction&gt;
 4087 void SpeculativeJIT::compileMathIC(Node* node, JITBinaryMathIC&lt;Generator&gt;* mathIC, bool needsScratchGPRReg, bool needsScratchFPRReg, RepatchingFunction repatchingFunction, NonRepatchingFunction nonRepatchingFunction)
 4088 {
 4089     Edge&amp; leftChild = node-&gt;child1();
 4090     Edge&amp; rightChild = node-&gt;child2();
 4091 
 4092     Optional&lt;JSValueOperand&gt; left;
 4093     Optional&lt;JSValueOperand&gt; right;
 4094 
 4095     JSValueRegs leftRegs;
 4096     JSValueRegs rightRegs;
 4097 
 4098     FPRTemporary leftNumber(this);
 4099     FPRTemporary rightNumber(this);
 4100     FPRReg leftFPR = leftNumber.fpr();
 4101     FPRReg rightFPR = rightNumber.fpr();
 4102 
 4103     GPRReg scratchGPR = InvalidGPRReg;
 4104     FPRReg scratchFPR = InvalidFPRReg;
 4105 
 4106     Optional&lt;FPRTemporary&gt; fprScratch;
 4107     if (needsScratchFPRReg) {
 4108         fprScratch.emplace(this);
 4109         scratchFPR = fprScratch-&gt;fpr();
 4110     }
 4111 
 4112 #if USE(JSVALUE64)
 4113     Optional&lt;GPRTemporary&gt; gprScratch;
 4114     if (needsScratchGPRReg) {
 4115         gprScratch.emplace(this);
 4116         scratchGPR = gprScratch-&gt;gpr();
 4117     }
 4118     GPRTemporary result(this);
 4119     JSValueRegs resultRegs = JSValueRegs(result.gpr());
 4120 #else
 4121     GPRTemporary resultTag(this);
 4122     GPRTemporary resultPayload(this);
 4123     JSValueRegs resultRegs = JSValueRegs(resultPayload.gpr(), resultTag.gpr());
 4124     if (needsScratchGPRReg)
 4125         scratchGPR = resultRegs.tagGPR();
 4126 #endif
 4127 
 4128     SnippetOperand leftOperand(m_state.forNode(leftChild).resultType());
 4129     SnippetOperand rightOperand(m_state.forNode(rightChild).resultType());
 4130 
 4131     // The snippet generator does not support both operands being constant. If the left
 4132     // operand is already const, we&#39;ll ignore the right operand&#39;s constness.
 4133     if (leftChild-&gt;isInt32Constant())
 4134         leftOperand.setConstInt32(leftChild-&gt;asInt32());
 4135     else if (rightChild-&gt;isInt32Constant())
 4136         rightOperand.setConstInt32(rightChild-&gt;asInt32());
 4137 
 4138     ASSERT(!leftOperand.isConst() || !rightOperand.isConst());
 4139     ASSERT(!(Generator::isLeftOperandValidConstant(leftOperand) &amp;&amp; Generator::isRightOperandValidConstant(rightOperand)));
 4140 
 4141     if (!Generator::isLeftOperandValidConstant(leftOperand)) {
 4142         left.emplace(this, leftChild);
 4143         leftRegs = left-&gt;jsValueRegs();
 4144     }
 4145     if (!Generator::isRightOperandValidConstant(rightOperand)) {
 4146         right.emplace(this, rightChild);
 4147         rightRegs = right-&gt;jsValueRegs();
 4148     }
 4149 
 4150 #if ENABLE(MATH_IC_STATS)
 4151     auto inlineStart = m_jit.label();
 4152 #endif
 4153 
 4154     Box&lt;MathICGenerationState&gt; addICGenerationState = Box&lt;MathICGenerationState&gt;::create();
 4155     mathIC-&gt;m_generator = Generator(leftOperand, rightOperand, resultRegs, leftRegs, rightRegs, leftFPR, rightFPR, scratchGPR, scratchFPR);
 4156 
 4157     bool shouldEmitProfiling = false;
 4158     bool generatedInline = mathIC-&gt;generateInline(m_jit, *addICGenerationState, shouldEmitProfiling);
 4159     if (generatedInline) {
 4160         ASSERT(!addICGenerationState-&gt;slowPathJumps.empty());
 4161 
 4162         Vector&lt;SilentRegisterSavePlan&gt; savePlans;
 4163         silentSpillAllRegistersImpl(false, savePlans, resultRegs);
 4164 
 4165         auto done = m_jit.label();
 4166 
 4167         addSlowPathGeneratorLambda([=, savePlans = WTFMove(savePlans)] () {
 4168             addICGenerationState-&gt;slowPathJumps.link(&amp;m_jit);
 4169             addICGenerationState-&gt;slowPathStart = m_jit.label();
 4170 #if ENABLE(MATH_IC_STATS)
 4171             auto slowPathStart = m_jit.label();
 4172 #endif
 4173 
 4174             silentSpill(savePlans);
 4175 
 4176             auto innerLeftRegs = leftRegs;
 4177             auto innerRightRegs = rightRegs;
 4178             if (Generator::isLeftOperandValidConstant(leftOperand)) {
 4179                 innerLeftRegs = resultRegs;
 4180                 m_jit.moveValue(leftChild-&gt;asJSValue(), innerLeftRegs);
 4181             } else if (Generator::isRightOperandValidConstant(rightOperand)) {
 4182                 innerRightRegs = resultRegs;
 4183                 m_jit.moveValue(rightChild-&gt;asJSValue(), innerRightRegs);
 4184             }
 4185 
 4186             if (addICGenerationState-&gt;shouldSlowPathRepatch)
<a name="89" id="anc89"></a><span class="line-modified"> 4187                 addICGenerationState-&gt;slowPathCall = callOperation(bitwise_cast&lt;J_JITOperation_GJJMic&gt;(repatchingFunction), resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), innerLeftRegs, innerRightRegs, TrustedImmPtr(mathIC));</span>
 4188             else
<a name="90" id="anc90"></a><span class="line-modified"> 4189                 addICGenerationState-&gt;slowPathCall = callOperation(nonRepatchingFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), innerLeftRegs, innerRightRegs);</span>
 4190 
 4191             silentFill(savePlans);
 4192             m_jit.exceptionCheck();
 4193             m_jit.jump().linkTo(done, &amp;m_jit);
 4194 
 4195             m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4196                 mathIC-&gt;finalizeInlineCode(*addICGenerationState, linkBuffer);
 4197             });
 4198 
 4199 #if ENABLE(MATH_IC_STATS)
 4200             auto slowPathEnd = m_jit.label();
 4201             m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4202                 size_t size = static_cast&lt;char*&gt;(linkBuffer.locationOf(slowPathEnd).executableAddress()) - static_cast&lt;char*&gt;(linkBuffer.locationOf(slowPathStart).executableAddress());
 4203                 mathIC-&gt;m_generatedCodeSize += size;
 4204             });
 4205 #endif
 4206 
 4207         });
 4208     } else {
 4209         if (Generator::isLeftOperandValidConstant(leftOperand)) {
 4210             left.emplace(this, leftChild);
 4211             leftRegs = left-&gt;jsValueRegs();
 4212         } else if (Generator::isRightOperandValidConstant(rightOperand)) {
 4213             right.emplace(this, rightChild);
 4214             rightRegs = right-&gt;jsValueRegs();
 4215         }
 4216 
 4217         flushRegisters();
<a name="91" id="anc91"></a><span class="line-modified"> 4218         callOperation(nonRepatchingFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
 4219         m_jit.exceptionCheck();
 4220     }
 4221 
 4222 #if ENABLE(MATH_IC_STATS)
 4223     auto inlineEnd = m_jit.label();
 4224     m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4225         size_t size = static_cast&lt;char*&gt;(linkBuffer.locationOf(inlineEnd).executableAddress()) - static_cast&lt;char*&gt;(linkBuffer.locationOf(inlineStart).executableAddress());
 4226         mathIC-&gt;m_generatedCodeSize += size;
 4227     });
 4228 #endif
 4229 
 4230     jsValueResult(resultRegs, node);
 4231     return;
 4232 }
 4233 
 4234 void SpeculativeJIT::compileInstanceOfCustom(Node* node)
 4235 {
 4236     // We could do something smarter here but this case is currently super rare and unless
 4237     // Symbol.hasInstance becomes popular will likely remain that way.
 4238 
 4239     JSValueOperand value(this, node-&gt;child1());
 4240     SpeculateCellOperand constructor(this, node-&gt;child2());
 4241     JSValueOperand hasInstanceValue(this, node-&gt;child3());
 4242     GPRTemporary result(this);
 4243 
 4244     JSValueRegs valueRegs = value.jsValueRegs();
 4245     GPRReg constructorGPR = constructor.gpr();
 4246     JSValueRegs hasInstanceRegs = hasInstanceValue.jsValueRegs();
 4247     GPRReg resultGPR = result.gpr();
 4248 
 4249     MacroAssembler::Jump slowCase = m_jit.jump();
 4250 
<a name="92" id="anc92"></a><span class="line-modified"> 4251     addSlowPathGenerator(slowPathCall(slowCase, this, operationInstanceOfCustom, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs, constructorGPR, hasInstanceRegs));</span>
 4252 
 4253     unblessedBooleanResult(resultGPR, node);
 4254 }
 4255 
 4256 void SpeculativeJIT::compileIsCellWithType(Node* node)
 4257 {
 4258     switch (node-&gt;child1().useKind()) {
 4259     case UntypedUse: {
 4260         JSValueOperand value(this, node-&gt;child1());
 4261         GPRTemporary result(this, Reuse, value, PayloadWord);
 4262 
 4263         JSValueRegs valueRegs = value.jsValueRegs();
 4264         GPRReg resultGPR = result.gpr();
 4265 
 4266         JITCompiler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
 4267 
 4268         m_jit.compare8(JITCompiler::Equal,
 4269             JITCompiler::Address(valueRegs.payloadGPR(), JSCell::typeInfoTypeOffset()),
 4270             TrustedImm32(node-&gt;queriedType()),
 4271             resultGPR);
 4272         blessBoolean(resultGPR);
 4273         JITCompiler::Jump done = m_jit.jump();
 4274 
 4275         isNotCell.link(&amp;m_jit);
 4276         moveFalseTo(resultGPR);
 4277 
 4278         done.link(&amp;m_jit);
 4279         blessedBooleanResult(resultGPR, node);
 4280         return;
 4281     }
 4282 
 4283     case CellUse: {
 4284         SpeculateCellOperand cell(this, node-&gt;child1());
 4285         GPRTemporary result(this, Reuse, cell);
 4286 
 4287         GPRReg cellGPR = cell.gpr();
 4288         GPRReg resultGPR = result.gpr();
 4289 
 4290         m_jit.compare8(JITCompiler::Equal,
 4291             JITCompiler::Address(cellGPR, JSCell::typeInfoTypeOffset()),
 4292             TrustedImm32(node-&gt;queriedType()),
 4293             resultGPR);
 4294         blessBoolean(resultGPR);
 4295         blessedBooleanResult(resultGPR, node);
 4296         return;
 4297     }
 4298 
 4299     default:
 4300         RELEASE_ASSERT_NOT_REACHED();
 4301         break;
 4302     }
 4303 }
 4304 
 4305 void SpeculativeJIT::compileIsTypedArrayView(Node* node)
 4306 {
 4307     JSValueOperand value(this, node-&gt;child1());
 4308     GPRTemporary result(this, Reuse, value, PayloadWord);
 4309 
 4310     JSValueRegs valueRegs = value.jsValueRegs();
 4311     GPRReg resultGPR = result.gpr();
 4312 
 4313     JITCompiler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
 4314 
 4315     m_jit.load8(JITCompiler::Address(valueRegs.payloadGPR(), JSCell::typeInfoTypeOffset()), resultGPR);
 4316     m_jit.sub32(TrustedImm32(FirstTypedArrayType), resultGPR);
 4317     m_jit.compare32(JITCompiler::Below,
 4318         resultGPR,
 4319         TrustedImm32(NumberOfTypedArrayTypesExcludingDataView),
 4320         resultGPR);
 4321     blessBoolean(resultGPR);
 4322     JITCompiler::Jump done = m_jit.jump();
 4323 
 4324     isNotCell.link(&amp;m_jit);
 4325     moveFalseTo(resultGPR);
 4326 
 4327     done.link(&amp;m_jit);
 4328     blessedBooleanResult(resultGPR, node);
 4329 }
 4330 
 4331 void SpeculativeJIT::compileToObjectOrCallObjectConstructor(Node* node)
 4332 {
 4333     RELEASE_ASSERT(node-&gt;child1().useKind() == UntypedUse);
 4334 
 4335     JSValueOperand value(this, node-&gt;child1());
 4336     GPRTemporary result(this, Reuse, value, PayloadWord);
 4337 
 4338     JSValueRegs valueRegs = value.jsValueRegs();
 4339     GPRReg resultGPR = result.gpr();
 4340 
 4341     MacroAssembler::JumpList slowCases;
 4342     slowCases.append(m_jit.branchIfNotCell(valueRegs));
 4343     slowCases.append(m_jit.branchIfNotObject(valueRegs.payloadGPR()));
 4344     m_jit.move(valueRegs.payloadGPR(), resultGPR);
 4345 
<a name="93" id="anc93"></a><span class="line-modified"> 4346     if (node-&gt;op() == ToObject) {</span>
<span class="line-modified"> 4347         UniquedStringImpl* errorMessage = nullptr;</span>
<span class="line-modified"> 4348         if (node-&gt;identifierNumber() != UINT32_MAX)</span>
<span class="line-added"> 4349             errorMessage = identifierUID(node-&gt;identifierNumber());</span>
<span class="line-added"> 4350         addSlowPathGenerator(slowPathCall(slowCases, this, operationToObject, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs, errorMessage));</span>
<span class="line-added"> 4351     } else</span>
 4352         addSlowPathGenerator(slowPathCall(slowCases, this, operationCallObjectConstructor, resultGPR, TrustedImmPtr(node-&gt;cellOperand()), valueRegs));
 4353 
 4354     cellResult(resultGPR, node);
 4355 }
 4356 
 4357 void SpeculativeJIT::compileArithAdd(Node* node)
 4358 {
 4359     switch (node-&gt;binaryUseKind()) {
 4360     case Int32Use: {
 4361         ASSERT(!shouldCheckNegativeZero(node-&gt;arithMode()));
 4362 
 4363         if (node-&gt;child2()-&gt;isInt32Constant()) {
 4364             SpeculateInt32Operand op1(this, node-&gt;child1());
 4365             GPRTemporary result(this, Reuse, op1);
 4366 
 4367             GPRReg gpr1 = op1.gpr();
 4368             int32_t imm2 = node-&gt;child2()-&gt;asInt32();
 4369             GPRReg gprResult = result.gpr();
 4370 
 4371             if (!shouldCheckOverflow(node-&gt;arithMode())) {
 4372                 m_jit.add32(Imm32(imm2), gpr1, gprResult);
 4373                 int32Result(gprResult, node);
 4374                 return;
 4375             }
 4376 
 4377             MacroAssembler::Jump check = m_jit.branchAdd32(MacroAssembler::Overflow, gpr1, Imm32(imm2), gprResult);
 4378             if (gpr1 == gprResult) {
 4379                 speculationCheck(Overflow, JSValueRegs(), 0, check,
 4380                     SpeculationRecovery(SpeculativeAddImmediate, gpr1, imm2));
 4381             } else
 4382                 speculationCheck(Overflow, JSValueRegs(), 0, check);
 4383 
 4384             int32Result(gprResult, node);
 4385             return;
 4386         }
 4387 
 4388         SpeculateInt32Operand op1(this, node-&gt;child1());
 4389         SpeculateInt32Operand op2(this, node-&gt;child2());
 4390         GPRTemporary result(this, Reuse, op1, op2);
 4391 
 4392         GPRReg gpr1 = op1.gpr();
 4393         GPRReg gpr2 = op2.gpr();
 4394         GPRReg gprResult = result.gpr();
 4395 
 4396         if (!shouldCheckOverflow(node-&gt;arithMode()))
 4397             m_jit.add32(gpr1, gpr2, gprResult);
 4398         else {
 4399             MacroAssembler::Jump check = m_jit.branchAdd32(MacroAssembler::Overflow, gpr1, gpr2, gprResult);
 4400 
 4401             if (gpr1 == gprResult &amp;&amp; gpr2 == gprResult)
 4402                 speculationCheck(Overflow, JSValueRegs(), 0, check, SpeculationRecovery(SpeculativeAddSelf, gprResult, gpr2));
 4403             else if (gpr1 == gprResult)
 4404                 speculationCheck(Overflow, JSValueRegs(), 0, check, SpeculationRecovery(SpeculativeAdd, gprResult, gpr2));
 4405             else if (gpr2 == gprResult)
 4406                 speculationCheck(Overflow, JSValueRegs(), 0, check, SpeculationRecovery(SpeculativeAdd, gprResult, gpr1));
 4407             else
 4408                 speculationCheck(Overflow, JSValueRegs(), 0, check);
 4409         }
 4410 
 4411         int32Result(gprResult, node);
 4412         return;
 4413     }
 4414 
 4415 #if USE(JSVALUE64)
 4416     case Int52RepUse: {
 4417         ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
 4418         ASSERT(!shouldCheckNegativeZero(node-&gt;arithMode()));
 4419 
 4420         // Will we need an overflow check? If we can prove that neither input can be
 4421         // Int52 then the overflow check will not be necessary.
 4422         if (!m_state.forNode(node-&gt;child1()).couldBeType(SpecNonInt32AsInt52)
 4423             &amp;&amp; !m_state.forNode(node-&gt;child2()).couldBeType(SpecNonInt32AsInt52)) {
 4424             SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
 4425             SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), op1);
 4426             GPRTemporary result(this, Reuse, op1);
 4427             m_jit.add64(op1.gpr(), op2.gpr(), result.gpr());
 4428             int52Result(result.gpr(), node, op1.format());
 4429             return;
 4430         }
 4431 
 4432         SpeculateInt52Operand op1(this, node-&gt;child1());
 4433         SpeculateInt52Operand op2(this, node-&gt;child2());
 4434         GPRTemporary result(this);
 4435         m_jit.move(op1.gpr(), result.gpr());
 4436         speculationCheck(
 4437             Int52Overflow, JSValueRegs(), 0,
 4438             m_jit.branchAdd64(MacroAssembler::Overflow, op2.gpr(), result.gpr()));
 4439         int52Result(result.gpr(), node);
 4440         return;
 4441     }
 4442 #endif // USE(JSVALUE64)
 4443 
 4444     case DoubleRepUse: {
 4445         SpeculateDoubleOperand op1(this, node-&gt;child1());
 4446         SpeculateDoubleOperand op2(this, node-&gt;child2());
 4447         FPRTemporary result(this, op1, op2);
 4448 
 4449         FPRReg reg1 = op1.fpr();
 4450         FPRReg reg2 = op2.fpr();
 4451         m_jit.addDouble(reg1, reg2, result.fpr());
 4452 
 4453         doubleResult(result.fpr(), node);
 4454         return;
 4455     }
 4456 
 4457     default:
 4458         RELEASE_ASSERT_NOT_REACHED();
 4459         break;
 4460     }
 4461 }
 4462 
 4463 void SpeculativeJIT::compileArithAbs(Node* node)
 4464 {
 4465     switch (node-&gt;child1().useKind()) {
 4466     case Int32Use: {
 4467         SpeculateStrictInt32Operand op1(this, node-&gt;child1());
 4468         GPRTemporary result(this, Reuse, op1);
 4469         GPRTemporary scratch(this);
 4470 
 4471         m_jit.move(op1.gpr(), result.gpr());
 4472         m_jit.rshift32(result.gpr(), MacroAssembler::TrustedImm32(31), scratch.gpr());
 4473         m_jit.add32(scratch.gpr(), result.gpr());
 4474         m_jit.xor32(scratch.gpr(), result.gpr());
 4475         if (shouldCheckOverflow(node-&gt;arithMode()))
 4476             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Signed, result.gpr()));
 4477         int32Result(result.gpr(), node);
 4478         break;
 4479     }
 4480 
 4481     case DoubleRepUse: {
 4482         SpeculateDoubleOperand op1(this, node-&gt;child1());
 4483         FPRTemporary result(this);
 4484 
 4485         m_jit.absDouble(op1.fpr(), result.fpr());
 4486         doubleResult(result.fpr(), node);
 4487         break;
 4488     }
 4489 
 4490     default: {
 4491         DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
 4492         JSValueOperand op1(this, node-&gt;child1());
 4493         JSValueRegs op1Regs = op1.jsValueRegs();
 4494         flushRegisters();
 4495         FPRResult result(this);
<a name="94" id="anc94"></a><span class="line-modified"> 4496         callOperation(operationArithAbs, result.fpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
 4497         m_jit.exceptionCheck();
 4498         doubleResult(result.fpr(), node);
 4499         break;
 4500     }
 4501     }
 4502 }
 4503 
 4504 void SpeculativeJIT::compileArithClz32(Node* node)
 4505 {
 4506     if (node-&gt;child1().useKind() == Int32Use || node-&gt;child1().useKind() == KnownInt32Use) {
 4507         SpeculateInt32Operand value(this, node-&gt;child1());
 4508         GPRTemporary result(this, Reuse, value);
 4509         GPRReg valueReg = value.gpr();
 4510         GPRReg resultReg = result.gpr();
 4511         m_jit.countLeadingZeros32(valueReg, resultReg);
 4512         int32Result(resultReg, node);
 4513         return;
 4514     }
 4515     JSValueOperand op1(this, node-&gt;child1());
 4516     JSValueRegs op1Regs = op1.jsValueRegs();
 4517     GPRTemporary result(this);
 4518     GPRReg resultReg = result.gpr();
 4519     flushRegisters();
<a name="95" id="anc95"></a><span class="line-modified"> 4520     callOperation(operationArithClz32, resultReg, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
 4521     m_jit.exceptionCheck();
 4522     int32Result(resultReg, node);
 4523 }
 4524 
<a name="96" id="anc96"></a><span class="line-modified"> 4525 void SpeculativeJIT::compileArithDoubleUnaryOp(Node* node, double (*doubleFunction)(double), double (*operation)(JSGlobalObject*, EncodedJSValue))</span>
 4526 {
 4527     if (node-&gt;child1().useKind() == DoubleRepUse) {
 4528         SpeculateDoubleOperand op1(this, node-&gt;child1());
 4529         FPRReg op1FPR = op1.fpr();
 4530 
 4531         flushRegisters();
 4532 
 4533         FPRResult result(this);
 4534         callOperation(doubleFunction, result.fpr(), op1FPR);
 4535 
 4536         doubleResult(result.fpr(), node);
 4537         return;
 4538     }
 4539 
 4540     JSValueOperand op1(this, node-&gt;child1());
 4541     JSValueRegs op1Regs = op1.jsValueRegs();
 4542     flushRegisters();
 4543     FPRResult result(this);
<a name="97" id="anc97"></a><span class="line-modified"> 4544     callOperation(operation, result.fpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
 4545     m_jit.exceptionCheck();
 4546     doubleResult(result.fpr(), node);
 4547 }
 4548 
 4549 void SpeculativeJIT::compileArithSub(Node* node)
 4550 {
 4551     switch (node-&gt;binaryUseKind()) {
 4552     case Int32Use: {
 4553         ASSERT(!shouldCheckNegativeZero(node-&gt;arithMode()));
 4554 
 4555         if (node-&gt;child2()-&gt;isInt32Constant()) {
 4556             SpeculateInt32Operand op1(this, node-&gt;child1());
 4557             int32_t imm2 = node-&gt;child2()-&gt;asInt32();
 4558             GPRTemporary result(this);
 4559 
 4560             if (!shouldCheckOverflow(node-&gt;arithMode())) {
 4561                 m_jit.move(op1.gpr(), result.gpr());
 4562                 m_jit.sub32(Imm32(imm2), result.gpr());
 4563             } else {
 4564                 GPRTemporary scratch(this);
 4565                 speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchSub32(MacroAssembler::Overflow, op1.gpr(), Imm32(imm2), result.gpr(), scratch.gpr()));
 4566             }
 4567 
 4568             int32Result(result.gpr(), node);
 4569             return;
 4570         }
 4571 
 4572         if (node-&gt;child1()-&gt;isInt32Constant()) {
 4573             int32_t imm1 = node-&gt;child1()-&gt;asInt32();
 4574             SpeculateInt32Operand op2(this, node-&gt;child2());
 4575             GPRTemporary result(this);
 4576 
 4577             m_jit.move(Imm32(imm1), result.gpr());
 4578             if (!shouldCheckOverflow(node-&gt;arithMode()))
 4579                 m_jit.sub32(op2.gpr(), result.gpr());
 4580             else
 4581                 speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchSub32(MacroAssembler::Overflow, op2.gpr(), result.gpr()));
 4582 
 4583             int32Result(result.gpr(), node);
 4584             return;
 4585         }
 4586 
 4587         SpeculateInt32Operand op1(this, node-&gt;child1());
 4588         SpeculateInt32Operand op2(this, node-&gt;child2());
 4589         GPRTemporary result(this);
 4590 
 4591         if (!shouldCheckOverflow(node-&gt;arithMode())) {
 4592             m_jit.move(op1.gpr(), result.gpr());
 4593             m_jit.sub32(op2.gpr(), result.gpr());
 4594         } else
 4595             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchSub32(MacroAssembler::Overflow, op1.gpr(), op2.gpr(), result.gpr()));
 4596 
 4597         int32Result(result.gpr(), node);
 4598         return;
 4599     }
 4600 
 4601 #if USE(JSVALUE64)
 4602     case Int52RepUse: {
 4603         ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
 4604         ASSERT(!shouldCheckNegativeZero(node-&gt;arithMode()));
 4605 
 4606         // Will we need an overflow check? If we can prove that neither input can be
 4607         // Int52 then the overflow check will not be necessary.
 4608         if (!m_state.forNode(node-&gt;child1()).couldBeType(SpecNonInt32AsInt52)
 4609             &amp;&amp; !m_state.forNode(node-&gt;child2()).couldBeType(SpecNonInt32AsInt52)) {
 4610             SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
 4611             SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), op1);
 4612             GPRTemporary result(this, Reuse, op1);
 4613             m_jit.move(op1.gpr(), result.gpr());
 4614             m_jit.sub64(op2.gpr(), result.gpr());
 4615             int52Result(result.gpr(), node, op1.format());
 4616             return;
 4617         }
 4618 
 4619         SpeculateInt52Operand op1(this, node-&gt;child1());
 4620         SpeculateInt52Operand op2(this, node-&gt;child2());
 4621         GPRTemporary result(this);
 4622         m_jit.move(op1.gpr(), result.gpr());
 4623         speculationCheck(
 4624             Int52Overflow, JSValueRegs(), 0,
 4625             m_jit.branchSub64(MacroAssembler::Overflow, op2.gpr(), result.gpr()));
 4626         int52Result(result.gpr(), node);
 4627         return;
 4628     }
 4629 #endif // USE(JSVALUE64)
 4630 
 4631     case DoubleRepUse: {
 4632         SpeculateDoubleOperand op1(this, node-&gt;child1());
 4633         SpeculateDoubleOperand op2(this, node-&gt;child2());
 4634         FPRTemporary result(this, op1);
 4635 
 4636         FPRReg reg1 = op1.fpr();
 4637         FPRReg reg2 = op2.fpr();
 4638         m_jit.subDouble(reg1, reg2, result.fpr());
 4639 
 4640         doubleResult(result.fpr(), node);
 4641         return;
 4642     }
 4643 
 4644     default:
 4645         RELEASE_ASSERT_NOT_REACHED();
 4646         return;
 4647     }
 4648 }
 4649 
<a name="98" id="anc98"></a><span class="line-added"> 4650 void SpeculativeJIT::compileIncOrDec(Node* node)</span>
<span class="line-added"> 4651 {</span>
<span class="line-added"> 4652     // In all other cases the node should have been transformed into an add or a sub by FixupPhase</span>
<span class="line-added"> 4653     ASSERT(node-&gt;child1().useKind() == UntypedUse);</span>
<span class="line-added"> 4654 </span>
<span class="line-added"> 4655     JSValueOperand op1(this, node-&gt;child1());</span>
<span class="line-added"> 4656     JSValueRegs op1Regs = op1.jsValueRegs();</span>
<span class="line-added"> 4657     flushRegisters();</span>
<span class="line-added"> 4658     JSValueRegsFlushedCallResult result(this);</span>
<span class="line-added"> 4659     JSValueRegs resultRegs = result.regs();</span>
<span class="line-added"> 4660     auto operation = node-&gt;op() == Inc ? operationInc : operationDec;</span>
<span class="line-added"> 4661     callOperation(operation, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
<span class="line-added"> 4662     m_jit.exceptionCheck();</span>
<span class="line-added"> 4663     jsValueResult(resultRegs, node);</span>
<span class="line-added"> 4664 }</span>
<span class="line-added"> 4665 </span>
 4666 void SpeculativeJIT::compileValueNegate(Node* node)
 4667 {
 4668     CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<a name="99" id="anc99"></a><span class="line-modified"> 4669     BytecodeIndex bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 4670     UnaryArithProfile* arithProfile = baselineCodeBlock-&gt;unaryArithProfileForBytecodeIndex(bytecodeIndex);</span>
 4671     JITNegIC* negIC = m_jit.codeBlock()-&gt;addJITNegIC(arithProfile);
 4672     auto repatchingFunction = operationArithNegateOptimize;
 4673     auto nonRepatchingFunction = operationArithNegate;
 4674     bool needsScratchGPRReg = true;
 4675     compileMathIC(node, negIC, needsScratchGPRReg, repatchingFunction, nonRepatchingFunction);
 4676 }
 4677 
 4678 void SpeculativeJIT::compileArithNegate(Node* node)
 4679 {
 4680     switch (node-&gt;child1().useKind()) {
 4681     case Int32Use: {
 4682         SpeculateInt32Operand op1(this, node-&gt;child1());
 4683         GPRTemporary result(this);
 4684 
 4685         m_jit.move(op1.gpr(), result.gpr());
 4686 
 4687         // Note: there is no notion of being not used as a number, but someone
 4688         // caring about negative zero.
 4689 
 4690         if (!shouldCheckOverflow(node-&gt;arithMode()))
 4691             m_jit.neg32(result.gpr());
 4692         else if (!shouldCheckNegativeZero(node-&gt;arithMode()))
 4693             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchNeg32(MacroAssembler::Overflow, result.gpr()));
 4694         else {
 4695             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Zero, result.gpr(), TrustedImm32(0x7fffffff)));
 4696             m_jit.neg32(result.gpr());
 4697         }
 4698 
 4699         int32Result(result.gpr(), node);
 4700         return;
 4701     }
 4702 
 4703 #if USE(JSVALUE64)
 4704     case Int52RepUse: {
 4705         ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
 4706 
 4707         if (!m_state.forNode(node-&gt;child1()).couldBeType(SpecNonInt32AsInt52)) {
 4708             SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
 4709             GPRTemporary result(this);
 4710             GPRReg op1GPR = op1.gpr();
 4711             GPRReg resultGPR = result.gpr();
 4712             m_jit.move(op1GPR, resultGPR);
 4713             m_jit.neg64(resultGPR);
 4714             if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 4715                 speculationCheck(
 4716                     NegativeZero, JSValueRegs(), 0,
 4717                     m_jit.branchTest64(MacroAssembler::Zero, resultGPR));
 4718             }
 4719             int52Result(resultGPR, node, op1.format());
 4720             return;
 4721         }
 4722 
 4723         SpeculateInt52Operand op1(this, node-&gt;child1());
 4724         GPRTemporary result(this);
 4725         GPRReg op1GPR = op1.gpr();
 4726         GPRReg resultGPR = result.gpr();
 4727         m_jit.move(op1GPR, resultGPR);
 4728         speculationCheck(
 4729             Int52Overflow, JSValueRegs(), 0,
 4730             m_jit.branchNeg64(MacroAssembler::Overflow, resultGPR));
 4731         if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 4732             speculationCheck(
 4733                 NegativeZero, JSValueRegs(), 0,
 4734                 m_jit.branchTest64(MacroAssembler::Zero, resultGPR));
 4735         }
 4736         int52Result(resultGPR, node);
 4737         return;
 4738     }
 4739 #endif // USE(JSVALUE64)
 4740 
 4741     case DoubleRepUse: {
 4742         SpeculateDoubleOperand op1(this, node-&gt;child1());
 4743         FPRTemporary result(this);
 4744 
 4745         m_jit.negateDouble(op1.fpr(), result.fpr());
 4746 
 4747         doubleResult(result.fpr(), node);
 4748         return;
 4749     }
 4750 
 4751     default: {
 4752         RELEASE_ASSERT_NOT_REACHED();
 4753     }
 4754     }
 4755 }
 4756 
 4757 template &lt;typename Generator, typename RepatchingFunction, typename NonRepatchingFunction&gt;
 4758 void SpeculativeJIT::compileMathIC(Node* node, JITUnaryMathIC&lt;Generator&gt;* mathIC, bool needsScratchGPRReg, RepatchingFunction repatchingFunction, NonRepatchingFunction nonRepatchingFunction)
 4759 {
 4760     GPRReg scratchGPR = InvalidGPRReg;
 4761     Optional&lt;GPRTemporary&gt; gprScratch;
 4762     if (needsScratchGPRReg) {
 4763         gprScratch.emplace(this);
 4764         scratchGPR = gprScratch-&gt;gpr();
 4765     }
 4766     JSValueOperand childOperand(this, node-&gt;child1());
 4767     JSValueRegs childRegs = childOperand.jsValueRegs();
 4768 #if USE(JSVALUE64)
 4769     GPRTemporary result(this, Reuse, childOperand);
 4770     JSValueRegs resultRegs(result.gpr());
 4771 #else
 4772     GPRTemporary resultTag(this);
 4773     GPRTemporary resultPayload(this);
 4774     JSValueRegs resultRegs(resultPayload.gpr(), resultTag.gpr());
 4775 #endif
 4776 
 4777 #if ENABLE(MATH_IC_STATS)
 4778     auto inlineStart = m_jit.label();
 4779 #endif
 4780 
 4781     Box&lt;MathICGenerationState&gt; icGenerationState = Box&lt;MathICGenerationState&gt;::create();
 4782     mathIC-&gt;m_generator = Generator(resultRegs, childRegs, scratchGPR);
 4783 
 4784     bool shouldEmitProfiling = false;
 4785     bool generatedInline = mathIC-&gt;generateInline(m_jit, *icGenerationState, shouldEmitProfiling);
 4786     if (generatedInline) {
 4787         ASSERT(!icGenerationState-&gt;slowPathJumps.empty());
 4788 
 4789         Vector&lt;SilentRegisterSavePlan&gt; savePlans;
 4790         silentSpillAllRegistersImpl(false, savePlans, resultRegs);
 4791 
 4792         auto done = m_jit.label();
 4793 
 4794         addSlowPathGeneratorLambda([=, savePlans = WTFMove(savePlans)] () {
 4795             icGenerationState-&gt;slowPathJumps.link(&amp;m_jit);
 4796             icGenerationState-&gt;slowPathStart = m_jit.label();
 4797 #if ENABLE(MATH_IC_STATS)
 4798             auto slowPathStart = m_jit.label();
 4799 #endif
 4800 
 4801             silentSpill(savePlans);
 4802 
 4803             if (icGenerationState-&gt;shouldSlowPathRepatch)
<a name="100" id="anc100"></a><span class="line-modified"> 4804                 icGenerationState-&gt;slowPathCall = callOperation(bitwise_cast&lt;J_JITOperation_GJMic&gt;(repatchingFunction), resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), childRegs, TrustedImmPtr(mathIC));</span>
 4805             else
<a name="101" id="anc101"></a><span class="line-modified"> 4806                 icGenerationState-&gt;slowPathCall = callOperation(nonRepatchingFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), childRegs);</span>
 4807 
 4808             silentFill(savePlans);
 4809             m_jit.exceptionCheck();
 4810             m_jit.jump().linkTo(done, &amp;m_jit);
 4811 
 4812             m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4813                 mathIC-&gt;finalizeInlineCode(*icGenerationState, linkBuffer);
 4814             });
 4815 
 4816 #if ENABLE(MATH_IC_STATS)
 4817             auto slowPathEnd = m_jit.label();
 4818             m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4819                 size_t size = static_cast&lt;char*&gt;(linkBuffer.locationOf(slowPathEnd).executableAddress()) - static_cast&lt;char*&gt;(linkBuffer.locationOf(slowPathStart).executableAddress());
 4820                 mathIC-&gt;m_generatedCodeSize += size;
 4821             });
 4822 #endif
 4823 
 4824         });
 4825     } else {
 4826         flushRegisters();
<a name="102" id="anc102"></a><span class="line-modified"> 4827         callOperation(nonRepatchingFunction, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), childRegs);</span>
 4828         m_jit.exceptionCheck();
 4829     }
 4830 
 4831 #if ENABLE(MATH_IC_STATS)
 4832     auto inlineEnd = m_jit.label();
 4833     m_jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 4834         size_t size = static_cast&lt;char*&gt;(linkBuffer.locationOf(inlineEnd).executableAddress()) - static_cast&lt;char*&gt;(linkBuffer.locationOf(inlineStart).executableAddress());
 4835         mathIC-&gt;m_generatedCodeSize += size;
 4836     });
 4837 #endif
 4838 
 4839     jsValueResult(resultRegs, node);
 4840     return;
 4841 }
 4842 
 4843 void SpeculativeJIT::compileValueMul(Node* node)
 4844 {
 4845     Edge&amp; leftChild = node-&gt;child1();
 4846     Edge&amp; rightChild = node-&gt;child2();
 4847 
 4848     if (leftChild.useKind() == BigIntUse &amp;&amp; rightChild.useKind() == BigIntUse) {
 4849         SpeculateCellOperand left(this, leftChild);
 4850         SpeculateCellOperand right(this, rightChild);
 4851         GPRReg leftGPR = left.gpr();
 4852         GPRReg rightGPR = right.gpr();
 4853 
 4854         speculateBigInt(leftChild, leftGPR);
 4855         speculateBigInt(rightChild, rightGPR);
 4856 
 4857         flushRegisters();
 4858         GPRFlushedCallResult result(this);
 4859         GPRReg resultGPR = result.gpr();
 4860 
<a name="103" id="anc103"></a><span class="line-modified"> 4861         callOperation(operationMulBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
 4862 
 4863         m_jit.exceptionCheck();
 4864         cellResult(resultGPR, node);
 4865         return;
 4866     }
 4867 
 4868     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 4869         JSValueOperand left(this, leftChild);
 4870         JSValueOperand right(this, rightChild);
 4871         JSValueRegs leftRegs = left.jsValueRegs();
 4872         JSValueRegs rightRegs = right.jsValueRegs();
 4873 
 4874         flushRegisters();
 4875         JSValueRegsFlushedCallResult result(this);
 4876         JSValueRegs resultRegs = result.regs();
<a name="104" id="anc104"></a><span class="line-modified"> 4877         callOperation(operationValueMul, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
 4878         m_jit.exceptionCheck();
 4879 
 4880         jsValueResult(resultRegs, node);
 4881         return;
 4882     }
 4883 
 4884     bool needsScratchGPRReg = true;
 4885 #if USE(JSVALUE64)
 4886     bool needsScratchFPRReg = false;
 4887 #else
 4888     bool needsScratchFPRReg = true;
 4889 #endif
 4890 
 4891     CodeBlock* baselineCodeBlock = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic);
<a name="105" id="anc105"></a><span class="line-modified"> 4892     BytecodeIndex bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
<span class="line-modified"> 4893     BinaryArithProfile* arithProfile = baselineCodeBlock-&gt;binaryArithProfileForBytecodeIndex(bytecodeIndex);</span>
 4894     JITMulIC* mulIC = m_jit.codeBlock()-&gt;addJITMulIC(arithProfile);
 4895     auto repatchingFunction = operationValueMulOptimize;
 4896     auto nonRepatchingFunction = operationValueMul;
 4897 
 4898     compileMathIC(node, mulIC, needsScratchGPRReg, needsScratchFPRReg, repatchingFunction, nonRepatchingFunction);
 4899 }
 4900 
 4901 void SpeculativeJIT::compileArithMul(Node* node)
 4902 {
 4903     switch (node-&gt;binaryUseKind()) {
 4904     case Int32Use: {
 4905         if (node-&gt;child2()-&gt;isInt32Constant()) {
 4906             SpeculateInt32Operand op1(this, node-&gt;child1());
 4907             GPRTemporary result(this);
 4908 
 4909             int32_t imm = node-&gt;child2()-&gt;asInt32();
 4910             GPRReg op1GPR = op1.gpr();
 4911             GPRReg resultGPR = result.gpr();
 4912 
 4913             if (!shouldCheckOverflow(node-&gt;arithMode()))
 4914                 m_jit.mul32(Imm32(imm), op1GPR, resultGPR);
 4915             else {
 4916                 speculationCheck(Overflow, JSValueRegs(), 0,
 4917                     m_jit.branchMul32(MacroAssembler::Overflow, op1GPR, Imm32(imm), resultGPR));
 4918             }
 4919 
 4920             // The only way to create negative zero with a constant is:
 4921             // -negative-op1 * 0.
 4922             // -zero-op1 * negative constant.
 4923             if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 4924                 if (!imm)
 4925                     speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Signed, op1GPR));
 4926                 else if (imm &lt; 0) {
 4927                     if (shouldCheckOverflow(node-&gt;arithMode()))
 4928                         speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Zero, resultGPR));
 4929                     else
 4930                         speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Zero, op1GPR));
 4931                 }
 4932             }
 4933 
 4934             int32Result(resultGPR, node);
 4935             return;
 4936         }
 4937         SpeculateInt32Operand op1(this, node-&gt;child1());
 4938         SpeculateInt32Operand op2(this, node-&gt;child2());
 4939         GPRTemporary result(this);
 4940 
 4941         GPRReg reg1 = op1.gpr();
 4942         GPRReg reg2 = op2.gpr();
 4943 
 4944         // We can perform truncated multiplications if we get to this point, because if the
 4945         // fixup phase could not prove that it would be safe, it would have turned us into
 4946         // a double multiplication.
 4947         if (!shouldCheckOverflow(node-&gt;arithMode()))
 4948             m_jit.mul32(reg1, reg2, result.gpr());
 4949         else {
 4950             speculationCheck(
 4951                 Overflow, JSValueRegs(), 0,
 4952                 m_jit.branchMul32(MacroAssembler::Overflow, reg1, reg2, result.gpr()));
 4953         }
 4954 
 4955         // Check for negative zero, if the users of this node care about such things.
 4956         if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 4957             MacroAssembler::Jump resultNonZero = m_jit.branchTest32(MacroAssembler::NonZero, result.gpr());
 4958             speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Signed, reg1));
 4959             speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branchTest32(MacroAssembler::Signed, reg2));
 4960             resultNonZero.link(&amp;m_jit);
 4961         }
 4962 
 4963         int32Result(result.gpr(), node);
 4964         return;
 4965     }
 4966 
 4967 #if USE(JSVALUE64)
 4968     case Int52RepUse: {
 4969         ASSERT(shouldCheckOverflow(node-&gt;arithMode()));
 4970 
 4971         // This is super clever. We want to do an int52 multiplication and check the
 4972         // int52 overflow bit. There is no direct hardware support for this, but we do
 4973         // have the ability to do an int64 multiplication and check the int64 overflow
 4974         // bit. We leverage that. Consider that a, b are int52 numbers inside int64
 4975         // registers, with the high 12 bits being sign-extended. We can do:
 4976         //
 4977         //     (a * (b &lt;&lt; 12))
 4978         //
 4979         // This will give us a left-shifted int52 (value is in high 52 bits, low 16
 4980         // bits are zero) plus the int52 overflow bit. I.e. whether this 64-bit
 4981         // multiplication overflows is identical to whether the &#39;a * b&#39; 52-bit
 4982         // multiplication overflows.
 4983         //
 4984         // In our nomenclature, this is:
 4985         //
 4986         //     strictInt52(a) * int52(b) =&gt; int52
 4987         //
 4988         // That is &quot;strictInt52&quot; means unshifted and &quot;int52&quot; means left-shifted by 16
 4989         // bits.
 4990         //
 4991         // We don&#39;t care which of op1 or op2 serves as the left-shifted operand, so
 4992         // we just do whatever is more convenient for op1 and have op2 do the
 4993         // opposite. This ensures that we do at most one shift.
 4994 
 4995         SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
 4996         SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), OppositeShift, op1);
 4997         GPRTemporary result(this);
 4998 
 4999         GPRReg op1GPR = op1.gpr();
 5000         GPRReg op2GPR = op2.gpr();
 5001         GPRReg resultGPR = result.gpr();
 5002 
 5003         m_jit.move(op1GPR, resultGPR);
 5004         speculationCheck(
 5005             Int52Overflow, JSValueRegs(), 0,
 5006             m_jit.branchMul64(MacroAssembler::Overflow, op2GPR, resultGPR));
 5007 
 5008         if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 5009             MacroAssembler::Jump resultNonZero = m_jit.branchTest64(
 5010                 MacroAssembler::NonZero, resultGPR);
 5011             speculationCheck(
 5012                 NegativeZero, JSValueRegs(), 0,
 5013                 m_jit.branch64(MacroAssembler::LessThan, op1GPR, TrustedImm32(0)));
 5014             speculationCheck(
 5015                 NegativeZero, JSValueRegs(), 0,
 5016                 m_jit.branch64(MacroAssembler::LessThan, op2GPR, TrustedImm32(0)));
 5017             resultNonZero.link(&amp;m_jit);
 5018         }
 5019 
 5020         int52Result(resultGPR, node);
 5021         return;
 5022     }
 5023 #endif // USE(JSVALUE64)
 5024 
 5025     case DoubleRepUse: {
 5026         SpeculateDoubleOperand op1(this, node-&gt;child1());
 5027         SpeculateDoubleOperand op2(this, node-&gt;child2());
 5028         FPRTemporary result(this, op1, op2);
 5029 
 5030         FPRReg reg1 = op1.fpr();
 5031         FPRReg reg2 = op2.fpr();
 5032 
 5033         m_jit.mulDouble(reg1, reg2, result.fpr());
 5034 
 5035         doubleResult(result.fpr(), node);
 5036         return;
 5037     }
 5038 
 5039     default:
 5040         RELEASE_ASSERT_NOT_REACHED();
 5041         return;
 5042     }
 5043 }
 5044 
 5045 void SpeculativeJIT::compileValueDiv(Node* node)
 5046 {
 5047     Edge&amp; leftChild = node-&gt;child1();
 5048     Edge&amp; rightChild = node-&gt;child2();
 5049 
 5050     if (leftChild.useKind() == BigIntUse &amp;&amp; rightChild.useKind() == BigIntUse) {
 5051         SpeculateCellOperand left(this, leftChild);
 5052         SpeculateCellOperand right(this, rightChild);
 5053         GPRReg leftGPR = left.gpr();
 5054         GPRReg rightGPR = right.gpr();
 5055 
 5056         speculateBigInt(leftChild, leftGPR);
 5057         speculateBigInt(rightChild, rightGPR);
 5058 
 5059         flushRegisters();
 5060         GPRFlushedCallResult result(this);
 5061         GPRReg resultGPR = result.gpr();
 5062 
<a name="106" id="anc106"></a><span class="line-modified"> 5063         callOperation(operationDivBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
 5064 
 5065         m_jit.exceptionCheck();
 5066         cellResult(resultGPR, node);
 5067         return;
 5068     }
 5069 
 5070     if (isKnownNotNumber(leftChild.node()) || isKnownNotNumber(rightChild.node())) {
 5071         JSValueOperand left(this, leftChild);
 5072         JSValueOperand right(this, rightChild);
 5073         JSValueRegs leftRegs = left.jsValueRegs();
 5074         JSValueRegs rightRegs = right.jsValueRegs();
 5075 
 5076         flushRegisters();
 5077         JSValueRegsFlushedCallResult result(this);
 5078         JSValueRegs resultRegs = result.regs();
<a name="107" id="anc107"></a><span class="line-modified"> 5079         callOperation(operationValueDiv, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
 5080         m_jit.exceptionCheck();
 5081 
 5082         jsValueResult(resultRegs, node);
 5083         return;
 5084     }
 5085 
 5086     Optional&lt;JSValueOperand&gt; left;
 5087     Optional&lt;JSValueOperand&gt; right;
 5088 
 5089     JSValueRegs leftRegs;
 5090     JSValueRegs rightRegs;
 5091 
 5092     FPRTemporary leftNumber(this);
 5093     FPRTemporary rightNumber(this);
 5094     FPRReg leftFPR = leftNumber.fpr();
 5095     FPRReg rightFPR = rightNumber.fpr();
 5096     FPRTemporary fprScratch(this);
 5097     FPRReg scratchFPR = fprScratch.fpr();
 5098 
 5099 #if USE(JSVALUE64)
 5100     GPRTemporary result(this);
 5101     JSValueRegs resultRegs = JSValueRegs(result.gpr());
 5102     GPRTemporary scratch(this);
 5103     GPRReg scratchGPR = scratch.gpr();
 5104 #else
 5105     GPRTemporary resultTag(this);
 5106     GPRTemporary resultPayload(this);
 5107     JSValueRegs resultRegs = JSValueRegs(resultPayload.gpr(), resultTag.gpr());
 5108     GPRReg scratchGPR = resultTag.gpr();
 5109 #endif
 5110 
 5111     SnippetOperand leftOperand(m_state.forNode(leftChild).resultType());
 5112     SnippetOperand rightOperand(m_state.forNode(rightChild).resultType());
 5113 
 5114     if (leftChild-&gt;isInt32Constant())
 5115         leftOperand.setConstInt32(leftChild-&gt;asInt32());
 5116 #if USE(JSVALUE64)
 5117     else if (leftChild-&gt;isDoubleConstant())
 5118         leftOperand.setConstDouble(leftChild-&gt;asNumber());
 5119 #endif
 5120 
 5121     if (leftOperand.isConst()) {
 5122         // The snippet generator only supports 1 argument as a constant.
 5123         // Ignore the rightChild&#39;s const-ness.
 5124     } else if (rightChild-&gt;isInt32Constant())
 5125         rightOperand.setConstInt32(rightChild-&gt;asInt32());
 5126 #if USE(JSVALUE64)
 5127     else if (rightChild-&gt;isDoubleConstant())
 5128         rightOperand.setConstDouble(rightChild-&gt;asNumber());
 5129 #endif
 5130 
 5131     RELEASE_ASSERT(!leftOperand.isConst() || !rightOperand.isConst());
 5132 
 5133     if (!leftOperand.isConst()) {
 5134         left.emplace(this, leftChild);
 5135         leftRegs = left-&gt;jsValueRegs();
 5136     }
 5137     if (!rightOperand.isConst()) {
 5138         right.emplace(this, rightChild);
 5139         rightRegs = right-&gt;jsValueRegs();
 5140     }
 5141 
 5142     JITDivGenerator gen(leftOperand, rightOperand, resultRegs, leftRegs, rightRegs,
 5143         leftFPR, rightFPR, scratchGPR, scratchFPR);
 5144     gen.generateFastPath(m_jit);
 5145 
 5146     ASSERT(gen.didEmitFastPath());
 5147     gen.endJumpList().append(m_jit.jump());
 5148 
 5149     gen.slowPathJumpList().link(&amp;m_jit);
 5150     silentSpillAllRegisters(resultRegs);
 5151 
 5152     if (leftOperand.isConst()) {
 5153         leftRegs = resultRegs;
 5154         m_jit.moveValue(leftChild-&gt;asJSValue(), leftRegs);
 5155     }
 5156     if (rightOperand.isConst()) {
 5157         rightRegs = resultRegs;
 5158         m_jit.moveValue(rightChild-&gt;asJSValue(), rightRegs);
 5159     }
 5160 
<a name="108" id="anc108"></a><span class="line-modified"> 5161     callOperation(operationValueDiv, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
 5162 
 5163     silentFillAllRegisters();
 5164     m_jit.exceptionCheck();
 5165 
 5166     gen.endJumpList().link(&amp;m_jit);
 5167     jsValueResult(resultRegs, node);
 5168 }
 5169 
 5170 void SpeculativeJIT::compileArithDiv(Node* node)
 5171 {
 5172     switch (node-&gt;binaryUseKind()) {
 5173     case Int32Use: {
<a name="109" id="anc109"></a><span class="line-modified"> 5174 #if CPU(X86_64)</span>
 5175         SpeculateInt32Operand op1(this, node-&gt;child1());
 5176         SpeculateInt32Operand op2(this, node-&gt;child2());
 5177         GPRTemporary eax(this, X86Registers::eax);
 5178         GPRTemporary edx(this, X86Registers::edx);
 5179         GPRReg op1GPR = op1.gpr();
 5180         GPRReg op2GPR = op2.gpr();
 5181 
 5182         GPRReg op2TempGPR;
 5183         GPRReg temp;
 5184         if (op2GPR == X86Registers::eax || op2GPR == X86Registers::edx) {
 5185             op2TempGPR = allocate();
 5186             temp = op2TempGPR;
 5187         } else {
 5188             op2TempGPR = InvalidGPRReg;
 5189             if (op1GPR == X86Registers::eax)
 5190                 temp = X86Registers::edx;
 5191             else
 5192                 temp = X86Registers::eax;
 5193         }
 5194 
 5195         ASSERT(temp != op1GPR);
 5196         ASSERT(temp != op2GPR);
 5197 
 5198         m_jit.add32(JITCompiler::TrustedImm32(1), op2GPR, temp);
 5199 
 5200         JITCompiler::Jump safeDenominator = m_jit.branch32(JITCompiler::Above, temp, JITCompiler::TrustedImm32(1));
 5201 
 5202         JITCompiler::JumpList done;
 5203         if (shouldCheckOverflow(node-&gt;arithMode())) {
 5204             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, op2GPR));
 5205             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branch32(JITCompiler::Equal, op1GPR, TrustedImm32(-2147483647-1)));
 5206         } else {
 5207             // This is the case where we convert the result to an int after we&#39;re done, and we
 5208             // already know that the denominator is either -1 or 0. So, if the denominator is
 5209             // zero, then the result should be zero. If the denominator is not zero (i.e. it&#39;s
 5210             // -1) and the numerator is -2^31 then the result should be -2^31. Otherwise we
 5211             // are happy to fall through to a normal division, since we&#39;re just dividing
 5212             // something by negative 1.
 5213 
 5214             JITCompiler::Jump notZero = m_jit.branchTest32(JITCompiler::NonZero, op2GPR);
 5215             m_jit.move(TrustedImm32(0), eax.gpr());
 5216             done.append(m_jit.jump());
 5217 
 5218             notZero.link(&amp;m_jit);
 5219             JITCompiler::Jump notNeg2ToThe31 =
 5220                 m_jit.branch32(JITCompiler::NotEqual, op1GPR, TrustedImm32(-2147483647-1));
 5221             m_jit.zeroExtend32ToPtr(op1GPR, eax.gpr());
 5222             done.append(m_jit.jump());
 5223 
 5224             notNeg2ToThe31.link(&amp;m_jit);
 5225         }
 5226 
 5227         safeDenominator.link(&amp;m_jit);
 5228 
 5229         // If the user cares about negative zero, then speculate that we&#39;re not about
 5230         // to produce negative zero.
 5231         if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 5232             MacroAssembler::Jump numeratorNonZero = m_jit.branchTest32(MacroAssembler::NonZero, op1GPR);
 5233             speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::LessThan, op2GPR, TrustedImm32(0)));
 5234             numeratorNonZero.link(&amp;m_jit);
 5235         }
 5236 
 5237         if (op2TempGPR != InvalidGPRReg) {
 5238             m_jit.move(op2GPR, op2TempGPR);
 5239             op2GPR = op2TempGPR;
 5240         }
 5241 
 5242         m_jit.move(op1GPR, eax.gpr());
 5243         m_jit.x86ConvertToDoubleWord32();
 5244         m_jit.x86Div32(op2GPR);
 5245 
 5246         if (op2TempGPR != InvalidGPRReg)
 5247             unlock(op2TempGPR);
 5248 
 5249         // Check that there was no remainder. If there had been, then we&#39;d be obligated to
 5250         // produce a double result instead.
 5251         if (shouldCheckOverflow(node-&gt;arithMode()))
 5252             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::NonZero, edx.gpr()));
 5253 
 5254         done.link(&amp;m_jit);
 5255         int32Result(eax.gpr(), node);
 5256 #elif HAVE(ARM_IDIV_INSTRUCTIONS) || CPU(ARM64)
 5257         SpeculateInt32Operand op1(this, node-&gt;child1());
 5258         SpeculateInt32Operand op2(this, node-&gt;child2());
 5259         GPRReg op1GPR = op1.gpr();
 5260         GPRReg op2GPR = op2.gpr();
 5261         GPRTemporary quotient(this);
 5262         GPRTemporary multiplyAnswer(this);
 5263 
 5264         // If the user cares about negative zero, then speculate that we&#39;re not about
 5265         // to produce negative zero.
 5266         if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 5267             MacroAssembler::Jump numeratorNonZero = m_jit.branchTest32(MacroAssembler::NonZero, op1GPR);
 5268             speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::LessThan, op2GPR, TrustedImm32(0)));
 5269             numeratorNonZero.link(&amp;m_jit);
 5270         }
 5271 
 5272         if (shouldCheckOverflow(node-&gt;arithMode()))
 5273             speculationCheck(Overflow, JSValueRegs(), nullptr, m_jit.branchTest32(MacroAssembler::Zero, op2GPR));
 5274 
 5275         m_jit.assembler().sdiv&lt;32&gt;(quotient.gpr(), op1GPR, op2GPR);
 5276 
 5277         // Check that there was no remainder. If there had been, then we&#39;d be obligated to
 5278         // produce a double result instead.
 5279         if (shouldCheckOverflow(node-&gt;arithMode())) {
 5280             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchMul32(JITCompiler::Overflow, quotient.gpr(), op2GPR, multiplyAnswer.gpr()));
 5281             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branch32(JITCompiler::NotEqual, multiplyAnswer.gpr(), op1GPR));
 5282         }
 5283 
 5284         int32Result(quotient.gpr(), node);
 5285 #else
 5286         RELEASE_ASSERT_NOT_REACHED();
 5287 #endif
 5288         break;
 5289     }
 5290 
 5291     case DoubleRepUse: {
 5292         SpeculateDoubleOperand op1(this, node-&gt;child1());
 5293         SpeculateDoubleOperand op2(this, node-&gt;child2());
 5294         FPRTemporary result(this, op1);
 5295 
 5296         FPRReg reg1 = op1.fpr();
 5297         FPRReg reg2 = op2.fpr();
 5298         m_jit.divDouble(reg1, reg2, result.fpr());
 5299 
 5300         doubleResult(result.fpr(), node);
 5301         break;
 5302     }
 5303 
 5304     default:
 5305         RELEASE_ASSERT_NOT_REACHED();
 5306         break;
 5307     }
 5308 }
 5309 
 5310 void SpeculativeJIT::compileArithFRound(Node* node)
 5311 {
 5312     if (node-&gt;child1().useKind() == DoubleRepUse) {
 5313         SpeculateDoubleOperand op1(this, node-&gt;child1());
 5314         FPRTemporary result(this, op1);
 5315         m_jit.convertDoubleToFloat(op1.fpr(), result.fpr());
 5316         m_jit.convertFloatToDouble(result.fpr(), result.fpr());
 5317         doubleResult(result.fpr(), node);
 5318         return;
 5319     }
 5320 
 5321     JSValueOperand op1(this, node-&gt;child1());
 5322     JSValueRegs op1Regs = op1.jsValueRegs();
 5323     flushRegisters();
 5324     FPRResult result(this);
<a name="110" id="anc110"></a><span class="line-modified"> 5325     callOperation(operationArithFRound, result.fpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
 5326     m_jit.exceptionCheck();
 5327     doubleResult(result.fpr(), node);
 5328 }
 5329 
 5330 void SpeculativeJIT::compileValueMod(Node* node)
 5331 {
 5332     Edge&amp; leftChild = node-&gt;child1();
 5333     Edge&amp; rightChild = node-&gt;child2();
 5334 
 5335     if (node-&gt;binaryUseKind() == BigIntUse) {
 5336         SpeculateCellOperand left(this, leftChild);
 5337         SpeculateCellOperand right(this, rightChild);
 5338         GPRReg leftGPR = left.gpr();
 5339         GPRReg rightGPR = right.gpr();
 5340 
 5341         speculateBigInt(leftChild, leftGPR);
 5342         speculateBigInt(rightChild, rightGPR);
 5343 
 5344         flushRegisters();
 5345         GPRFlushedCallResult result(this);
 5346         GPRReg resultGPR = result.gpr();
 5347 
<a name="111" id="anc111"></a><span class="line-modified"> 5348         callOperation(operationModBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
 5349 
 5350         m_jit.exceptionCheck();
 5351         cellResult(resultGPR, node);
 5352         return;
 5353     }
 5354 
 5355     DFG_ASSERT(m_jit.graph(), node, node-&gt;binaryUseKind() == UntypedUse, node-&gt;binaryUseKind());
 5356     JSValueOperand op1(this, leftChild);
 5357     JSValueOperand op2(this, rightChild);
 5358     JSValueRegs op1Regs = op1.jsValueRegs();
 5359     JSValueRegs op2Regs = op2.jsValueRegs();
 5360     flushRegisters();
 5361     JSValueRegsFlushedCallResult result(this);
 5362     JSValueRegs resultRegs = result.regs();
<a name="112" id="anc112"></a><span class="line-modified"> 5363     callOperation(operationValueMod, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs, op2Regs);</span>
 5364     m_jit.exceptionCheck();
 5365     jsValueResult(resultRegs, node);
 5366 }
 5367 
 5368 void SpeculativeJIT::compileArithMod(Node* node)
 5369 {
 5370     switch (node-&gt;binaryUseKind()) {
 5371     case Int32Use: {
 5372         // In the fast path, the dividend value could be the final result
 5373         // (in case of |dividend| &lt; |divisor|), so we speculate it as strict int32.
 5374         SpeculateStrictInt32Operand op1(this, node-&gt;child1());
 5375 
 5376         if (node-&gt;child2()-&gt;isInt32Constant()) {
 5377             int32_t divisor = node-&gt;child2()-&gt;asInt32();
 5378             if (divisor &gt; 1 &amp;&amp; hasOneBitSet(divisor)) {
 5379                 unsigned logarithm = WTF::fastLog2(static_cast&lt;uint32_t&gt;(divisor));
 5380                 GPRReg dividendGPR = op1.gpr();
 5381                 GPRTemporary result(this);
 5382                 GPRReg resultGPR = result.gpr();
 5383 
 5384                 // This is what LLVM generates. It&#39;s pretty crazy. Here&#39;s my
 5385                 // attempt at understanding it.
 5386 
 5387                 // First, compute either divisor - 1, or 0, depending on whether
 5388                 // the dividend is negative:
 5389                 //
 5390                 // If dividend &lt; 0:  resultGPR = divisor - 1
 5391                 // If dividend &gt;= 0: resultGPR = 0
 5392                 m_jit.move(dividendGPR, resultGPR);
 5393                 m_jit.rshift32(TrustedImm32(31), resultGPR);
 5394                 m_jit.urshift32(TrustedImm32(32 - logarithm), resultGPR);
 5395 
 5396                 // Add in the dividend, so that:
 5397                 //
 5398                 // If dividend &lt; 0:  resultGPR = dividend + divisor - 1
 5399                 // If dividend &gt;= 0: resultGPR = dividend
 5400                 m_jit.add32(dividendGPR, resultGPR);
 5401 
 5402                 // Mask so as to only get the *high* bits. This rounds down
 5403                 // (towards negative infinity) resultGPR to the nearest multiple
 5404                 // of divisor, so that:
 5405                 //
 5406                 // If dividend &lt; 0:  resultGPR = floor((dividend + divisor - 1) / divisor)
 5407                 // If dividend &gt;= 0: resultGPR = floor(dividend / divisor)
 5408                 //
 5409                 // Note that this can be simplified to:
 5410                 //
 5411                 // If dividend &lt; 0:  resultGPR = ceil(dividend / divisor)
 5412                 // If dividend &gt;= 0: resultGPR = floor(dividend / divisor)
 5413                 //
 5414                 // Note that if the dividend is negative, resultGPR will also be negative.
 5415                 // Regardless of the sign of dividend, resultGPR will be rounded towards
 5416                 // zero, because of how things are conditionalized.
 5417                 m_jit.and32(TrustedImm32(-divisor), resultGPR);
 5418 
 5419                 // Subtract resultGPR from dividendGPR, which yields the remainder:
 5420                 //
 5421                 // resultGPR = dividendGPR - resultGPR
 5422                 m_jit.neg32(resultGPR);
 5423                 m_jit.add32(dividendGPR, resultGPR);
 5424 
 5425                 if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 5426                     // Check that we&#39;re not about to create negative zero.
 5427                     JITCompiler::Jump numeratorPositive = m_jit.branch32(JITCompiler::GreaterThanOrEqual, dividendGPR, TrustedImm32(0));
 5428                     speculationCheck(NegativeZero, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, resultGPR));
 5429                     numeratorPositive.link(&amp;m_jit);
 5430                 }
 5431 
 5432                 int32Result(resultGPR, node);
 5433                 return;
 5434             }
 5435         }
 5436 
<a name="113" id="anc113"></a><span class="line-modified"> 5437 #if CPU(X86_64)</span>
 5438         if (node-&gt;child2()-&gt;isInt32Constant()) {
 5439             int32_t divisor = node-&gt;child2()-&gt;asInt32();
 5440             if (divisor &amp;&amp; divisor != -1) {
 5441                 GPRReg op1Gpr = op1.gpr();
 5442 
 5443                 GPRTemporary eax(this, X86Registers::eax);
 5444                 GPRTemporary edx(this, X86Registers::edx);
 5445                 GPRTemporary scratch(this);
 5446                 GPRReg scratchGPR = scratch.gpr();
 5447 
 5448                 GPRReg op1SaveGPR;
 5449                 if (op1Gpr == X86Registers::eax || op1Gpr == X86Registers::edx) {
 5450                     op1SaveGPR = allocate();
 5451                     ASSERT(op1Gpr != op1SaveGPR);
 5452                     m_jit.move(op1Gpr, op1SaveGPR);
 5453                 } else
 5454                     op1SaveGPR = op1Gpr;
 5455                 ASSERT(op1SaveGPR != X86Registers::eax);
 5456                 ASSERT(op1SaveGPR != X86Registers::edx);
 5457 
 5458                 m_jit.move(op1Gpr, eax.gpr());
 5459                 m_jit.move(TrustedImm32(divisor), scratchGPR);
 5460                 m_jit.x86ConvertToDoubleWord32();
 5461                 m_jit.x86Div32(scratchGPR);
 5462                 if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 5463                     JITCompiler::Jump numeratorPositive = m_jit.branch32(JITCompiler::GreaterThanOrEqual, op1SaveGPR, TrustedImm32(0));
 5464                     speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, edx.gpr()));
 5465                     numeratorPositive.link(&amp;m_jit);
 5466                 }
 5467 
 5468                 if (op1SaveGPR != op1Gpr)
 5469                     unlock(op1SaveGPR);
 5470 
 5471                 int32Result(edx.gpr(), node);
 5472                 return;
 5473             }
 5474         }
 5475 #endif
 5476 
 5477         SpeculateInt32Operand op2(this, node-&gt;child2());
<a name="114" id="anc114"></a><span class="line-modified"> 5478 #if CPU(X86_64)</span>
 5479         GPRTemporary eax(this, X86Registers::eax);
 5480         GPRTemporary edx(this, X86Registers::edx);
 5481         GPRReg op1GPR = op1.gpr();
 5482         GPRReg op2GPR = op2.gpr();
 5483 
 5484         GPRReg op2TempGPR;
 5485         GPRReg temp;
 5486         GPRReg op1SaveGPR;
 5487 
 5488         if (op2GPR == X86Registers::eax || op2GPR == X86Registers::edx) {
 5489             op2TempGPR = allocate();
 5490             temp = op2TempGPR;
 5491         } else {
 5492             op2TempGPR = InvalidGPRReg;
 5493             if (op1GPR == X86Registers::eax)
 5494                 temp = X86Registers::edx;
 5495             else
 5496                 temp = X86Registers::eax;
 5497         }
 5498 
 5499         if (op1GPR == X86Registers::eax || op1GPR == X86Registers::edx) {
 5500             op1SaveGPR = allocate();
 5501             ASSERT(op1GPR != op1SaveGPR);
 5502             m_jit.move(op1GPR, op1SaveGPR);
 5503         } else
 5504             op1SaveGPR = op1GPR;
 5505 
 5506         ASSERT(temp != op1GPR);
 5507         ASSERT(temp != op2GPR);
 5508         ASSERT(op1SaveGPR != X86Registers::eax);
 5509         ASSERT(op1SaveGPR != X86Registers::edx);
 5510 
 5511         m_jit.add32(JITCompiler::TrustedImm32(1), op2GPR, temp);
 5512 
 5513         JITCompiler::Jump safeDenominator = m_jit.branch32(JITCompiler::Above, temp, JITCompiler::TrustedImm32(1));
 5514 
 5515         JITCompiler::JumpList done;
 5516 
 5517         // FIXME: -2^31 / -1 will actually yield negative zero, so we could have a
 5518         // separate case for that. But it probably doesn&#39;t matter so much.
 5519         if (shouldCheckOverflow(node-&gt;arithMode())) {
 5520             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, op2GPR));
 5521             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branch32(JITCompiler::Equal, op1GPR, TrustedImm32(-2147483647-1)));
 5522         } else {
 5523             // This is the case where we convert the result to an int after we&#39;re done, and we
 5524             // already know that the denominator is either -1 or 0. So, if the denominator is
 5525             // zero, then the result should be zero. If the denominator is not zero (i.e. it&#39;s
 5526             // -1) and the numerator is -2^31 then the result should be 0. Otherwise we are
 5527             // happy to fall through to a normal division, since we&#39;re just dividing something
 5528             // by negative 1.
 5529 
 5530             JITCompiler::Jump notZero = m_jit.branchTest32(JITCompiler::NonZero, op2GPR);
 5531             m_jit.move(TrustedImm32(0), edx.gpr());
 5532             done.append(m_jit.jump());
 5533 
 5534             notZero.link(&amp;m_jit);
 5535             JITCompiler::Jump notNeg2ToThe31 =
 5536                 m_jit.branch32(JITCompiler::NotEqual, op1GPR, TrustedImm32(-2147483647-1));
 5537             m_jit.move(TrustedImm32(0), edx.gpr());
 5538             done.append(m_jit.jump());
 5539 
 5540             notNeg2ToThe31.link(&amp;m_jit);
 5541         }
 5542 
 5543         safeDenominator.link(&amp;m_jit);
 5544 
 5545         if (op2TempGPR != InvalidGPRReg) {
 5546             m_jit.move(op2GPR, op2TempGPR);
 5547             op2GPR = op2TempGPR;
 5548         }
 5549 
 5550         m_jit.move(op1GPR, eax.gpr());
 5551         m_jit.x86ConvertToDoubleWord32();
 5552         m_jit.x86Div32(op2GPR);
 5553 
 5554         if (op2TempGPR != InvalidGPRReg)
 5555             unlock(op2TempGPR);
 5556 
 5557         // Check that we&#39;re not about to create negative zero.
 5558         if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 5559             JITCompiler::Jump numeratorPositive = m_jit.branch32(JITCompiler::GreaterThanOrEqual, op1SaveGPR, TrustedImm32(0));
 5560             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, edx.gpr()));
 5561             numeratorPositive.link(&amp;m_jit);
 5562         }
 5563 
 5564         if (op1SaveGPR != op1GPR)
 5565             unlock(op1SaveGPR);
 5566 
 5567         done.link(&amp;m_jit);
 5568         int32Result(edx.gpr(), node);
 5569 
 5570 #elif HAVE(ARM_IDIV_INSTRUCTIONS) || CPU(ARM64)
 5571         GPRTemporary temp(this);
 5572         GPRTemporary quotientThenRemainder(this);
 5573         GPRTemporary multiplyAnswer(this);
 5574         GPRReg dividendGPR = op1.gpr();
 5575         GPRReg divisorGPR = op2.gpr();
 5576         GPRReg quotientThenRemainderGPR = quotientThenRemainder.gpr();
 5577         GPRReg multiplyAnswerGPR = multiplyAnswer.gpr();
 5578 
 5579         JITCompiler::JumpList done;
 5580 
 5581         if (shouldCheckOverflow(node-&gt;arithMode()))
 5582             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, divisorGPR));
 5583         else {
 5584             JITCompiler::Jump denominatorNotZero = m_jit.branchTest32(JITCompiler::NonZero, divisorGPR);
 5585             // We know that the low 32-bit of divisorGPR is 0, but we don&#39;t know if the high bits are.
 5586             // So, use TrustedImm32(0) on ARM instead because done expects the result to be in DataFormatInt32.
 5587             // Using an immediate 0 doesn&#39;t cost anything extra on ARM.
 5588             m_jit.move(TrustedImm32(0), quotientThenRemainderGPR);
 5589             done.append(m_jit.jump());
 5590             denominatorNotZero.link(&amp;m_jit);
 5591         }
 5592 
 5593         m_jit.assembler().sdiv&lt;32&gt;(quotientThenRemainderGPR, dividendGPR, divisorGPR);
 5594         // FIXME: It seems like there are cases where we don&#39;t need this? What if we have
 5595         // arithMode() == Arith::Unchecked?
 5596         // https://bugs.webkit.org/show_bug.cgi?id=126444
 5597         speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchMul32(JITCompiler::Overflow, quotientThenRemainderGPR, divisorGPR, multiplyAnswerGPR));
 5598 #if HAVE(ARM_IDIV_INSTRUCTIONS)
 5599         m_jit.assembler().sub(quotientThenRemainderGPR, dividendGPR, multiplyAnswerGPR);
 5600 #else
 5601         m_jit.assembler().sub&lt;32&gt;(quotientThenRemainderGPR, dividendGPR, multiplyAnswerGPR);
 5602 #endif
 5603 
 5604         // If the user cares about negative zero, then speculate that we&#39;re not about
 5605         // to produce negative zero.
 5606         if (shouldCheckNegativeZero(node-&gt;arithMode())) {
 5607             // Check that we&#39;re not about to create negative zero.
 5608             JITCompiler::Jump numeratorPositive = m_jit.branch32(JITCompiler::GreaterThanOrEqual, dividendGPR, TrustedImm32(0));
 5609             speculationCheck(Overflow, JSValueRegs(), 0, m_jit.branchTest32(JITCompiler::Zero, quotientThenRemainderGPR));
 5610             numeratorPositive.link(&amp;m_jit);
 5611         }
 5612 
 5613         done.link(&amp;m_jit);
 5614 
 5615         int32Result(quotientThenRemainderGPR, node);
 5616 #else // not architecture that can do integer division
 5617         RELEASE_ASSERT_NOT_REACHED();
 5618 #endif
 5619         return;
 5620     }
 5621 
 5622     case DoubleRepUse: {
 5623         SpeculateDoubleOperand op1(this, node-&gt;child1());
 5624         SpeculateDoubleOperand op2(this, node-&gt;child2());
 5625 
 5626         FPRReg op1FPR = op1.fpr();
 5627         FPRReg op2FPR = op2.fpr();
 5628 
 5629         flushRegisters();
 5630 
 5631         FPRResult result(this);
 5632 
 5633         using OperationType = D_JITOperation_DD;
 5634         callOperation&lt;OperationType&gt;(jsMod, result.fpr(), op1FPR, op2FPR);
 5635 
 5636         doubleResult(result.fpr(), node);
 5637         return;
 5638     }
 5639 
 5640     default:
 5641         RELEASE_ASSERT_NOT_REACHED();
 5642         return;
 5643     }
 5644 }
 5645 
 5646 void SpeculativeJIT::compileArithRounding(Node* node)
 5647 {
 5648     if (node-&gt;child1().useKind() == DoubleRepUse) {
 5649         SpeculateDoubleOperand value(this, node-&gt;child1());
 5650         FPRReg valueFPR = value.fpr();
 5651 
 5652         auto setResult = [&amp;] (FPRReg resultFPR) {
 5653             if (producesInteger(node-&gt;arithRoundingMode())) {
 5654                 GPRTemporary roundedResultAsInt32(this);
 5655                 FPRTemporary scratch(this);
 5656                 FPRReg scratchFPR = scratch.fpr();
 5657                 GPRReg resultGPR = roundedResultAsInt32.gpr();
 5658                 JITCompiler::JumpList failureCases;
 5659                 m_jit.branchConvertDoubleToInt32(resultFPR, resultGPR, failureCases, scratchFPR, shouldCheckNegativeZero(node-&gt;arithRoundingMode()));
 5660                 speculationCheck(Overflow, JSValueRegs(), node, failureCases);
 5661 
 5662                 int32Result(resultGPR, node);
 5663             } else
 5664                 doubleResult(resultFPR, node);
 5665         };
 5666 
 5667         if (m_jit.supportsFloatingPointRounding()) {
 5668             switch (node-&gt;op()) {
 5669             case ArithRound: {
 5670                 FPRTemporary result(this);
 5671                 FPRReg resultFPR = result.fpr();
 5672                 if (producesInteger(node-&gt;arithRoundingMode()) &amp;&amp; !shouldCheckNegativeZero(node-&gt;arithRoundingMode())) {
<a name="115" id="anc115"></a><span class="line-modified"> 5673                     static constexpr double halfConstant = 0.5;</span>
 5674                     m_jit.loadDouble(TrustedImmPtr(&amp;halfConstant), resultFPR);
 5675                     m_jit.addDouble(valueFPR, resultFPR);
 5676                     m_jit.floorDouble(resultFPR, resultFPR);
 5677                 } else {
 5678                     m_jit.ceilDouble(valueFPR, resultFPR);
<a name="116" id="anc116"></a>


 5679 
 5680                     FPRTemporary scratch(this);
 5681                     FPRReg scratchFPR = scratch.fpr();
<a name="117" id="anc117"></a><span class="line-modified"> 5682                     static constexpr double halfConstant = -0.5;</span>
 5683                     m_jit.loadDouble(TrustedImmPtr(&amp;halfConstant), scratchFPR);
<a name="118" id="anc118"></a><span class="line-added"> 5684                     m_jit.addDouble(resultFPR, scratchFPR);</span>
 5685 
<a name="119" id="anc119"></a><span class="line-modified"> 5686                     JITCompiler::Jump shouldUseCeiled = m_jit.branchDouble(JITCompiler::DoubleLessThanOrEqual, scratchFPR, valueFPR);</span>
<span class="line-modified"> 5687                     static constexpr double oneConstant = -1.0;</span>
 5688                     m_jit.loadDouble(TrustedImmPtr(&amp;oneConstant), scratchFPR);
 5689                     m_jit.addDouble(scratchFPR, resultFPR);
 5690                     shouldUseCeiled.link(&amp;m_jit);
 5691                 }
 5692                 setResult(resultFPR);
 5693                 return;
 5694             }
 5695 
 5696             case ArithFloor: {
 5697                 FPRTemporary rounded(this);
 5698                 FPRReg resultFPR = rounded.fpr();
 5699                 m_jit.floorDouble(valueFPR, resultFPR);
 5700                 setResult(resultFPR);
 5701                 return;
 5702             }
 5703 
 5704             case ArithCeil: {
 5705                 FPRTemporary rounded(this);
 5706                 FPRReg resultFPR = rounded.fpr();
 5707                 m_jit.ceilDouble(valueFPR, resultFPR);
 5708                 setResult(resultFPR);
 5709                 return;
 5710             }
 5711 
 5712             case ArithTrunc: {
 5713                 FPRTemporary rounded(this);
 5714                 FPRReg resultFPR = rounded.fpr();
 5715                 m_jit.roundTowardZeroDouble(valueFPR, resultFPR);
 5716                 setResult(resultFPR);
 5717                 return;
 5718             }
 5719 
 5720             default:
 5721                 RELEASE_ASSERT_NOT_REACHED();
 5722             }
 5723         } else {
 5724             flushRegisters();
 5725             FPRResult roundedResultAsDouble(this);
 5726             FPRReg resultFPR = roundedResultAsDouble.fpr();
 5727             using OperationType = D_JITOperation_D;
 5728             if (node-&gt;op() == ArithRound)
 5729                 callOperation&lt;OperationType&gt;(jsRound, resultFPR, valueFPR);
 5730             else if (node-&gt;op() == ArithFloor)
 5731                 callOperation&lt;OperationType&gt;(floor, resultFPR, valueFPR);
 5732             else if (node-&gt;op() == ArithCeil)
 5733                 callOperation&lt;OperationType&gt;(ceil, resultFPR, valueFPR);
 5734             else {
 5735                 ASSERT(node-&gt;op() == ArithTrunc);
 5736                 callOperation&lt;OperationType&gt;(trunc, resultFPR, valueFPR);
 5737             }
 5738             setResult(resultFPR);
 5739         }
 5740         return;
 5741     }
 5742 
 5743     DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
 5744 
 5745     JSValueOperand argument(this, node-&gt;child1());
 5746     JSValueRegs argumentRegs = argument.jsValueRegs();
 5747 
 5748     flushRegisters();
 5749     JSValueRegsFlushedCallResult result(this);
 5750     JSValueRegs resultRegs = result.regs();
<a name="120" id="anc120"></a><span class="line-modified"> 5751     J_JITOperation_GJ operation = nullptr;</span>
 5752     if (node-&gt;op() == ArithRound)
 5753         operation = operationArithRound;
 5754     else if (node-&gt;op() == ArithFloor)
 5755         operation = operationArithFloor;
 5756     else if (node-&gt;op() == ArithCeil)
 5757         operation = operationArithCeil;
 5758     else {
 5759         ASSERT(node-&gt;op() == ArithTrunc);
 5760         operation = operationArithTrunc;
 5761     }
<a name="121" id="anc121"></a><span class="line-modified"> 5762     callOperation(operation, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentRegs);</span>
 5763     m_jit.exceptionCheck();
 5764     jsValueResult(resultRegs, node);
 5765 }
 5766 
 5767 void SpeculativeJIT::compileArithUnary(Node* node)
 5768 {
 5769     compileArithDoubleUnaryOp(node, arithUnaryFunction(node-&gt;arithUnaryType()), arithUnaryOperation(node-&gt;arithUnaryType()));
 5770 }
 5771 
 5772 void SpeculativeJIT::compileArithSqrt(Node* node)
 5773 {
 5774     if (node-&gt;child1().useKind() == DoubleRepUse) {
 5775         SpeculateDoubleOperand op1(this, node-&gt;child1());
 5776         FPRReg op1FPR = op1.fpr();
 5777 
 5778         if (!MacroAssembler::supportsFloatingPointSqrt() || !Options::useArchitectureSpecificOptimizations()) {
 5779             flushRegisters();
 5780             FPRResult result(this);
 5781             callOperation&lt;D_JITOperation_D&gt;(sqrt, result.fpr(), op1FPR);
 5782             doubleResult(result.fpr(), node);
 5783         } else {
 5784             FPRTemporary result(this, op1);
 5785             m_jit.sqrtDouble(op1.fpr(), result.fpr());
 5786             doubleResult(result.fpr(), node);
 5787         }
 5788         return;
 5789     }
 5790 
 5791     JSValueOperand op1(this, node-&gt;child1());
 5792     JSValueRegs op1Regs = op1.jsValueRegs();
 5793     flushRegisters();
 5794     FPRResult result(this);
<a name="122" id="anc122"></a><span class="line-modified"> 5795     callOperation(operationArithSqrt, result.fpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
 5796     m_jit.exceptionCheck();
 5797     doubleResult(result.fpr(), node);
 5798 }
 5799 
 5800 void SpeculativeJIT::compileArithMinMax(Node* node)
 5801 {
 5802     switch (node-&gt;binaryUseKind()) {
 5803     case Int32Use: {
 5804         SpeculateStrictInt32Operand op1(this, node-&gt;child1());
 5805         SpeculateStrictInt32Operand op2(this, node-&gt;child2());
 5806         GPRTemporary result(this, Reuse, op1);
 5807 
 5808         GPRReg op1GPR = op1.gpr();
 5809         GPRReg op2GPR = op2.gpr();
 5810         GPRReg resultGPR = result.gpr();
 5811 
 5812         MacroAssembler::Jump op1Less = m_jit.branch32(node-&gt;op() == ArithMin ? MacroAssembler::LessThan : MacroAssembler::GreaterThan, op1GPR, op2GPR);
 5813         m_jit.move(op2GPR, resultGPR);
 5814         if (op1GPR != resultGPR) {
 5815             MacroAssembler::Jump done = m_jit.jump();
 5816             op1Less.link(&amp;m_jit);
 5817             m_jit.move(op1GPR, resultGPR);
 5818             done.link(&amp;m_jit);
 5819         } else
 5820             op1Less.link(&amp;m_jit);
 5821 
 5822         int32Result(resultGPR, node);
 5823         break;
 5824     }
 5825 
 5826     case DoubleRepUse: {
 5827         SpeculateDoubleOperand op1(this, node-&gt;child1());
 5828         SpeculateDoubleOperand op2(this, node-&gt;child2());
 5829         FPRTemporary result(this, op1);
 5830 
 5831         FPRReg op1FPR = op1.fpr();
 5832         FPRReg op2FPR = op2.fpr();
 5833         FPRReg resultFPR = result.fpr();
 5834 
 5835         MacroAssembler::JumpList done;
 5836 
 5837         MacroAssembler::Jump op1Less = m_jit.branchDouble(node-&gt;op() == ArithMin ? MacroAssembler::DoubleLessThan : MacroAssembler::DoubleGreaterThan, op1FPR, op2FPR);
 5838 
 5839         // op2 is eather the lesser one or one of then is NaN
 5840         MacroAssembler::Jump op2Less = m_jit.branchDouble(node-&gt;op() == ArithMin ? MacroAssembler::DoubleGreaterThanOrEqual : MacroAssembler::DoubleLessThanOrEqual, op1FPR, op2FPR);
 5841 
 5842         // Unordered case. We don&#39;t know which of op1, op2 is NaN. Manufacture NaN by adding
 5843         // op1 + op2 and putting it into result.
 5844         m_jit.addDouble(op1FPR, op2FPR, resultFPR);
 5845         done.append(m_jit.jump());
 5846 
 5847         op2Less.link(&amp;m_jit);
 5848         m_jit.moveDouble(op2FPR, resultFPR);
 5849 
 5850         if (op1FPR != resultFPR) {
 5851             done.append(m_jit.jump());
 5852 
 5853             op1Less.link(&amp;m_jit);
 5854             m_jit.moveDouble(op1FPR, resultFPR);
 5855         } else
 5856             op1Less.link(&amp;m_jit);
 5857 
 5858         done.link(&amp;m_jit);
 5859 
 5860         doubleResult(resultFPR, node);
 5861         break;
 5862     }
 5863 
 5864     default:
 5865         DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
 5866         break;
 5867     }
 5868 }
 5869 
 5870 // For small positive integers , it is worth doing a tiny inline loop to exponentiate the base.
 5871 // Every register is clobbered by this helper.
 5872 static MacroAssembler::Jump compileArithPowIntegerFastPath(JITCompiler&amp; assembler, FPRReg xOperand, GPRReg yOperand, FPRReg result)
 5873 {
 5874     MacroAssembler::JumpList skipFastPath;
 5875     skipFastPath.append(assembler.branch32(MacroAssembler::Above, yOperand, MacroAssembler::TrustedImm32(maxExponentForIntegerMathPow)));
 5876 
<a name="123" id="anc123"></a><span class="line-modified"> 5877     static constexpr double oneConstant = 1.0;</span>
 5878     assembler.loadDouble(MacroAssembler::TrustedImmPtr(&amp;oneConstant), result);
 5879 
 5880     MacroAssembler::Label startLoop(assembler.label());
 5881     MacroAssembler::Jump exponentIsEven = assembler.branchTest32(MacroAssembler::Zero, yOperand, MacroAssembler::TrustedImm32(1));
 5882     assembler.mulDouble(xOperand, result);
 5883     exponentIsEven.link(&amp;assembler);
 5884     assembler.mulDouble(xOperand, xOperand);
 5885     assembler.rshift32(MacroAssembler::TrustedImm32(1), yOperand);
 5886     assembler.branchTest32(MacroAssembler::NonZero, yOperand).linkTo(startLoop, &amp;assembler);
 5887 
 5888     MacroAssembler::Jump skipSlowPath = assembler.jump();
 5889     skipFastPath.link(&amp;assembler);
 5890 
 5891     return skipSlowPath;
 5892 }
 5893 
 5894 void SpeculativeJIT::compileValuePow(Node* node)
 5895 {
 5896     Edge&amp; leftChild = node-&gt;child1();
 5897     Edge&amp; rightChild = node-&gt;child2();
 5898 
 5899     if (node-&gt;binaryUseKind() == BigIntUse) {
 5900         SpeculateCellOperand left(this, leftChild);
 5901         SpeculateCellOperand right(this, rightChild);
 5902         GPRReg leftGPR = left.gpr();
 5903         GPRReg rightGPR = right.gpr();
 5904 
 5905         speculateBigInt(leftChild, leftGPR);
 5906         speculateBigInt(rightChild, rightGPR);
 5907 
 5908         flushRegisters();
 5909         GPRFlushedCallResult result(this);
 5910         GPRReg resultGPR = result.gpr();
 5911 
<a name="124" id="anc124"></a><span class="line-modified"> 5912         callOperation(operationPowBigInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
 5913 
 5914         m_jit.exceptionCheck();
 5915         cellResult(resultGPR, node);
 5916         return;
 5917     }
 5918 
 5919     DFG_ASSERT(m_jit.graph(), node, node-&gt;binaryUseKind() == UntypedUse, node-&gt;binaryUseKind());
 5920 
 5921     JSValueOperand left(this, leftChild);
 5922     JSValueOperand right(this, rightChild);
 5923     JSValueRegs leftRegs = left.jsValueRegs();
 5924     JSValueRegs rightRegs = right.jsValueRegs();
 5925 
 5926     flushRegisters();
 5927     JSValueRegsFlushedCallResult result(this);
 5928     JSValueRegs resultRegs = result.regs();
<a name="125" id="anc125"></a><span class="line-modified"> 5929     callOperation(operationValuePow, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftRegs, rightRegs);</span>
 5930     m_jit.exceptionCheck();
 5931 
 5932     jsValueResult(resultRegs, node);
 5933 }
 5934 
 5935 void SpeculativeJIT::compileArithPow(Node* node)
 5936 {
 5937     if (node-&gt;child2().useKind() == Int32Use) {
 5938         SpeculateDoubleOperand xOperand(this, node-&gt;child1());
 5939         SpeculateInt32Operand yOperand(this, node-&gt;child2());
 5940         FPRReg xOperandfpr = xOperand.fpr();
 5941         GPRReg yOperandGpr = yOperand.gpr();
 5942         FPRTemporary yOperandfpr(this);
 5943 
 5944         flushRegisters();
 5945 
 5946         FPRResult result(this);
 5947         FPRReg resultFpr = result.fpr();
 5948 
 5949         FPRTemporary xOperandCopy(this);
 5950         FPRReg xOperandCopyFpr = xOperandCopy.fpr();
 5951         m_jit.moveDouble(xOperandfpr, xOperandCopyFpr);
 5952 
 5953         GPRTemporary counter(this);
 5954         GPRReg counterGpr = counter.gpr();
 5955         m_jit.move(yOperandGpr, counterGpr);
 5956 
 5957         MacroAssembler::Jump skipFallback = compileArithPowIntegerFastPath(m_jit, xOperandCopyFpr, counterGpr, resultFpr);
 5958         m_jit.convertInt32ToDouble(yOperandGpr, yOperandfpr.fpr());
 5959         callOperation(operationMathPow, resultFpr, xOperandfpr, yOperandfpr.fpr());
 5960 
 5961         skipFallback.link(&amp;m_jit);
 5962         doubleResult(resultFpr, node);
 5963         return;
 5964     }
 5965 
 5966     if (node-&gt;child2()-&gt;isDoubleConstant()) {
 5967         double exponent = node-&gt;child2()-&gt;asNumber();
<a name="126" id="anc126"></a><span class="line-modified"> 5968         static constexpr double infinityConstant = std::numeric_limits&lt;double&gt;::infinity();</span>
<span class="line-modified"> 5969         static constexpr double minusInfinityConstant = -std::numeric_limits&lt;double&gt;::infinity();</span>
 5970         if (exponent == 0.5) {
 5971             SpeculateDoubleOperand xOperand(this, node-&gt;child1());
 5972             FPRTemporary result(this);
 5973             FPRReg xOperandFpr = xOperand.fpr();
 5974             FPRReg resultFpr = result.fpr();
 5975 
 5976             m_jit.moveZeroToDouble(resultFpr);
 5977             MacroAssembler::Jump xIsZeroOrNegativeZero = m_jit.branchDouble(MacroAssembler::DoubleEqual, xOperandFpr, resultFpr);
 5978 
 5979             m_jit.loadDouble(TrustedImmPtr(&amp;minusInfinityConstant), resultFpr);
 5980             MacroAssembler::Jump xIsMinusInfinity = m_jit.branchDouble(MacroAssembler::DoubleEqual, xOperandFpr, resultFpr);
 5981             m_jit.sqrtDouble(xOperandFpr, resultFpr);
 5982             MacroAssembler::Jump doneWithSqrt = m_jit.jump();
 5983 
 5984             xIsMinusInfinity.link(&amp;m_jit);
 5985             if (isX86())
 5986                 m_jit.loadDouble(TrustedImmPtr(&amp;infinityConstant), resultFpr);
 5987             else
 5988                 m_jit.absDouble(resultFpr, resultFpr);
 5989 
 5990             xIsZeroOrNegativeZero.link(&amp;m_jit);
 5991             doneWithSqrt.link(&amp;m_jit);
 5992             doubleResult(resultFpr, node);
 5993             return;
 5994         }
 5995         if (exponent == -0.5) {
 5996             SpeculateDoubleOperand xOperand(this, node-&gt;child1());
 5997             FPRTemporary scratch(this);
 5998             FPRTemporary result(this);
 5999             FPRReg xOperandFpr = xOperand.fpr();
 6000             FPRReg scratchFPR = scratch.fpr();
 6001             FPRReg resultFpr = result.fpr();
 6002 
 6003             m_jit.moveZeroToDouble(resultFpr);
 6004             MacroAssembler::Jump xIsZeroOrNegativeZero = m_jit.branchDouble(MacroAssembler::DoubleEqual, xOperandFpr, resultFpr);
 6005 
 6006             m_jit.loadDouble(TrustedImmPtr(&amp;minusInfinityConstant), resultFpr);
 6007             MacroAssembler::Jump xIsMinusInfinity = m_jit.branchDouble(MacroAssembler::DoubleEqual, xOperandFpr, resultFpr);
 6008 
<a name="127" id="anc127"></a><span class="line-modified"> 6009             static constexpr double oneConstant = 1.;</span>
 6010             m_jit.loadDouble(TrustedImmPtr(&amp;oneConstant), resultFpr);
 6011             m_jit.sqrtDouble(xOperandFpr, scratchFPR);
 6012             m_jit.divDouble(resultFpr, scratchFPR, resultFpr);
 6013             MacroAssembler::Jump doneWithSqrt = m_jit.jump();
 6014 
 6015             xIsZeroOrNegativeZero.link(&amp;m_jit);
 6016             m_jit.loadDouble(TrustedImmPtr(&amp;infinityConstant), resultFpr);
 6017             MacroAssembler::Jump doneWithBaseZero = m_jit.jump();
 6018 
 6019             xIsMinusInfinity.link(&amp;m_jit);
 6020             m_jit.moveZeroToDouble(resultFpr);
 6021 
 6022             doneWithBaseZero.link(&amp;m_jit);
 6023             doneWithSqrt.link(&amp;m_jit);
 6024             doubleResult(resultFpr, node);
 6025             return;
 6026         }
 6027     }
 6028 
 6029     SpeculateDoubleOperand xOperand(this, node-&gt;child1());
 6030     SpeculateDoubleOperand yOperand(this, node-&gt;child2());
 6031     FPRReg xOperandfpr = xOperand.fpr();
 6032     FPRReg yOperandfpr = yOperand.fpr();
 6033 
 6034     flushRegisters();
 6035 
 6036     FPRResult result(this);
 6037     FPRReg resultFpr = result.fpr();
 6038 
 6039     FPRTemporary xOperandCopy(this);
 6040     FPRReg xOperandCopyFpr = xOperandCopy.fpr();
 6041 
 6042     FPRTemporary scratch(this);
 6043     FPRReg scratchFpr = scratch.fpr();
 6044 
 6045     GPRTemporary yOperandInteger(this);
 6046     GPRReg yOperandIntegerGpr = yOperandInteger.gpr();
 6047     MacroAssembler::JumpList failedExponentConversionToInteger;
 6048     m_jit.branchConvertDoubleToInt32(yOperandfpr, yOperandIntegerGpr, failedExponentConversionToInteger, scratchFpr, false);
 6049 
 6050     m_jit.moveDouble(xOperandfpr, xOperandCopyFpr);
 6051     MacroAssembler::Jump skipFallback = compileArithPowIntegerFastPath(m_jit, xOperandCopyFpr, yOperandInteger.gpr(), resultFpr);
 6052     failedExponentConversionToInteger.link(&amp;m_jit);
 6053 
 6054     callOperation(operationMathPow, resultFpr, xOperandfpr, yOperandfpr);
 6055     skipFallback.link(&amp;m_jit);
 6056     doubleResult(resultFpr, node);
 6057 }
 6058 
 6059 // Returns true if the compare is fused with a subsequent branch.
<a name="128" id="anc128"></a><span class="line-modified"> 6060 bool SpeculativeJIT::compare(Node* node, MacroAssembler::RelationalCondition condition, MacroAssembler::DoubleCondition doubleCondition, S_JITOperation_GJJ operation)</span>
 6061 {
 6062     if (compilePeepHoleBranch(node, condition, doubleCondition, operation))
 6063         return true;
 6064 
 6065     if (node-&gt;isBinaryUseKind(Int32Use)) {
 6066         compileInt32Compare(node, condition);
 6067         return false;
 6068     }
 6069 
 6070 #if USE(JSVALUE64)
 6071     if (node-&gt;isBinaryUseKind(Int52RepUse)) {
 6072         compileInt52Compare(node, condition);
 6073         return false;
 6074     }
 6075 #endif // USE(JSVALUE64)
 6076 
 6077     if (node-&gt;isBinaryUseKind(DoubleRepUse)) {
 6078         compileDoubleCompare(node, doubleCondition);
 6079         return false;
 6080     }
 6081 
 6082     if (node-&gt;isBinaryUseKind(StringUse)) {
 6083         if (node-&gt;op() == CompareEq)
 6084             compileStringEquality(node);
 6085         else
 6086             compileStringCompare(node, condition);
 6087         return false;
 6088     }
 6089 
 6090     if (node-&gt;isBinaryUseKind(StringIdentUse)) {
 6091         if (node-&gt;op() == CompareEq)
 6092             compileStringIdentEquality(node);
 6093         else
 6094             compileStringIdentCompare(node, condition);
 6095         return false;
 6096     }
 6097 
 6098     if (node-&gt;op() == CompareEq) {
 6099         if (node-&gt;isBinaryUseKind(BooleanUse)) {
 6100             compileBooleanCompare(node, condition);
 6101             return false;
 6102         }
 6103 
 6104         if (node-&gt;isBinaryUseKind(SymbolUse)) {
 6105             compileSymbolEquality(node);
 6106             return false;
 6107         }
 6108 
 6109         if (node-&gt;isBinaryUseKind(ObjectUse)) {
 6110             compileObjectEquality(node);
 6111             return false;
 6112         }
 6113 
 6114         if (node-&gt;isBinaryUseKind(ObjectUse, ObjectOrOtherUse)) {
 6115             compileObjectToObjectOrOtherEquality(node-&gt;child1(), node-&gt;child2());
 6116             return false;
 6117         }
 6118 
 6119         if (node-&gt;isBinaryUseKind(ObjectOrOtherUse, ObjectUse)) {
 6120             compileObjectToObjectOrOtherEquality(node-&gt;child2(), node-&gt;child1());
 6121             return false;
 6122         }
 6123 
 6124         if (!needsTypeCheck(node-&gt;child1(), SpecOther)) {
 6125             nonSpeculativeNonPeepholeCompareNullOrUndefined(node-&gt;child2());
 6126             return false;
 6127         }
 6128 
 6129         if (!needsTypeCheck(node-&gt;child2(), SpecOther)) {
 6130             nonSpeculativeNonPeepholeCompareNullOrUndefined(node-&gt;child1());
 6131             return false;
 6132         }
 6133     }
 6134 
 6135     nonSpeculativeNonPeepholeCompare(node, condition, operation);
 6136     return false;
 6137 }
 6138 
 6139 void SpeculativeJIT::compileCompareUnsigned(Node* node, MacroAssembler::RelationalCondition condition)
 6140 {
 6141     compileInt32Compare(node, condition);
 6142 }
 6143 
 6144 bool SpeculativeJIT::compileStrictEq(Node* node)
 6145 {
 6146     if (node-&gt;isBinaryUseKind(BooleanUse)) {
 6147         unsigned branchIndexInBlock = detectPeepHoleBranch();
 6148         if (branchIndexInBlock != UINT_MAX) {
 6149             Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 6150             compilePeepHoleBooleanBranch(node, branchNode, MacroAssembler::Equal);
 6151             use(node-&gt;child1());
 6152             use(node-&gt;child2());
 6153             m_indexInBlock = branchIndexInBlock;
 6154             m_currentNode = branchNode;
 6155             return true;
 6156         }
 6157         compileBooleanCompare(node, MacroAssembler::Equal);
 6158         return false;
 6159     }
 6160 
 6161     if (node-&gt;isBinaryUseKind(Int32Use)) {
 6162         unsigned branchIndexInBlock = detectPeepHoleBranch();
 6163         if (branchIndexInBlock != UINT_MAX) {
 6164             Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 6165             compilePeepHoleInt32Branch(node, branchNode, MacroAssembler::Equal);
 6166             use(node-&gt;child1());
 6167             use(node-&gt;child2());
 6168             m_indexInBlock = branchIndexInBlock;
 6169             m_currentNode = branchNode;
 6170             return true;
 6171         }
 6172         compileInt32Compare(node, MacroAssembler::Equal);
 6173         return false;
 6174     }
 6175 
 6176 #if USE(JSVALUE64)
 6177     if (node-&gt;isBinaryUseKind(Int52RepUse)) {
 6178         unsigned branchIndexInBlock = detectPeepHoleBranch();
 6179         if (branchIndexInBlock != UINT_MAX) {
 6180             Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 6181             compilePeepHoleInt52Branch(node, branchNode, MacroAssembler::Equal);
 6182             use(node-&gt;child1());
 6183             use(node-&gt;child2());
 6184             m_indexInBlock = branchIndexInBlock;
 6185             m_currentNode = branchNode;
 6186             return true;
 6187         }
 6188         compileInt52Compare(node, MacroAssembler::Equal);
 6189         return false;
 6190     }
 6191 #endif // USE(JSVALUE64)
 6192 
 6193     if (node-&gt;isBinaryUseKind(DoubleRepUse)) {
 6194         unsigned branchIndexInBlock = detectPeepHoleBranch();
 6195         if (branchIndexInBlock != UINT_MAX) {
 6196             Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 6197             compilePeepHoleDoubleBranch(node, branchNode, MacroAssembler::DoubleEqual);
 6198             use(node-&gt;child1());
 6199             use(node-&gt;child2());
 6200             m_indexInBlock = branchIndexInBlock;
 6201             m_currentNode = branchNode;
 6202             return true;
 6203         }
 6204         compileDoubleCompare(node, MacroAssembler::DoubleEqual);
 6205         return false;
 6206     }
 6207 
 6208     if (node-&gt;isBinaryUseKind(SymbolUse)) {
 6209         unsigned branchIndexInBlock = detectPeepHoleBranch();
 6210         if (branchIndexInBlock != UINT_MAX) {
 6211             Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 6212             compilePeepHoleSymbolEquality(node, branchNode);
 6213             use(node-&gt;child1());
 6214             use(node-&gt;child2());
 6215             m_indexInBlock = branchIndexInBlock;
 6216             m_currentNode = branchNode;
 6217             return true;
 6218         }
 6219         compileSymbolEquality(node);
 6220         return false;
 6221     }
 6222 
 6223     if (node-&gt;isBinaryUseKind(BigIntUse)) {
 6224         compileBigIntEquality(node);
 6225         return false;
 6226     }
 6227 
 6228     if (node-&gt;isBinaryUseKind(SymbolUse, UntypedUse)) {
 6229         compileSymbolUntypedEquality(node, node-&gt;child1(), node-&gt;child2());
 6230         return false;
 6231     }
 6232 
 6233     if (node-&gt;isBinaryUseKind(UntypedUse, SymbolUse)) {
 6234         compileSymbolUntypedEquality(node, node-&gt;child2(), node-&gt;child1());
 6235         return false;
 6236     }
 6237 
 6238     if (node-&gt;isBinaryUseKind(StringUse)) {
 6239         compileStringEquality(node);
 6240         return false;
 6241     }
 6242 
 6243     if (node-&gt;isBinaryUseKind(StringIdentUse)) {
 6244         compileStringIdentEquality(node);
 6245         return false;
 6246     }
 6247 
 6248     if (node-&gt;isBinaryUseKind(ObjectUse, UntypedUse)) {
 6249         unsigned branchIndexInBlock = detectPeepHoleBranch();
 6250         if (branchIndexInBlock != UINT_MAX) {
 6251             Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 6252             compilePeepHoleObjectStrictEquality(node-&gt;child1(), node-&gt;child2(), branchNode);
 6253             use(node-&gt;child1());
 6254             use(node-&gt;child2());
 6255             m_indexInBlock = branchIndexInBlock;
 6256             m_currentNode = branchNode;
 6257             return true;
 6258         }
 6259         compileObjectStrictEquality(node-&gt;child1(), node-&gt;child2());
 6260         return false;
 6261     }
 6262 
 6263     if (node-&gt;isBinaryUseKind(UntypedUse, ObjectUse)) {
 6264         unsigned branchIndexInBlock = detectPeepHoleBranch();
 6265         if (branchIndexInBlock != UINT_MAX) {
 6266             Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 6267             compilePeepHoleObjectStrictEquality(node-&gt;child2(), node-&gt;child1(), branchNode);
 6268             use(node-&gt;child1());
 6269             use(node-&gt;child2());
 6270             m_indexInBlock = branchIndexInBlock;
 6271             m_currentNode = branchNode;
 6272             return true;
 6273         }
 6274         compileObjectStrictEquality(node-&gt;child2(), node-&gt;child1());
 6275         return false;
 6276     }
 6277 
 6278     if (node-&gt;isBinaryUseKind(ObjectUse)) {
 6279         unsigned branchIndexInBlock = detectPeepHoleBranch();
 6280         if (branchIndexInBlock != UINT_MAX) {
 6281             Node* branchNode = m_block-&gt;at(branchIndexInBlock);
 6282             compilePeepHoleObjectEquality(node, branchNode);
 6283             use(node-&gt;child1());
 6284             use(node-&gt;child2());
 6285             m_indexInBlock = branchIndexInBlock;
 6286             m_currentNode = branchNode;
 6287             return true;
 6288         }
 6289         compileObjectEquality(node);
 6290         return false;
 6291     }
 6292 
 6293     if (node-&gt;isBinaryUseKind(MiscUse, UntypedUse)
 6294         || node-&gt;isBinaryUseKind(UntypedUse, MiscUse)) {
 6295         compileMiscStrictEq(node);
 6296         return false;
 6297     }
 6298 
 6299     if (node-&gt;isBinaryUseKind(StringIdentUse, NotStringVarUse)) {
 6300         compileStringIdentToNotStringVarEquality(node, node-&gt;child1(), node-&gt;child2());
 6301         return false;
 6302     }
 6303 
 6304     if (node-&gt;isBinaryUseKind(NotStringVarUse, StringIdentUse)) {
 6305         compileStringIdentToNotStringVarEquality(node, node-&gt;child2(), node-&gt;child1());
 6306         return false;
 6307     }
 6308 
 6309     if (node-&gt;isBinaryUseKind(StringUse, UntypedUse)) {
 6310         compileStringToUntypedEquality(node, node-&gt;child1(), node-&gt;child2());
 6311         return false;
 6312     }
 6313 
 6314     if (node-&gt;isBinaryUseKind(UntypedUse, StringUse)) {
 6315         compileStringToUntypedEquality(node, node-&gt;child2(), node-&gt;child1());
 6316         return false;
 6317     }
 6318 
 6319     RELEASE_ASSERT(node-&gt;isBinaryUseKind(UntypedUse));
 6320     return nonSpeculativeStrictEq(node);
 6321 }
 6322 
 6323 void SpeculativeJIT::compileBooleanCompare(Node* node, MacroAssembler::RelationalCondition condition)
 6324 {
 6325     SpeculateBooleanOperand op1(this, node-&gt;child1());
 6326     SpeculateBooleanOperand op2(this, node-&gt;child2());
 6327     GPRTemporary result(this);
 6328 
 6329     m_jit.compare32(condition, op1.gpr(), op2.gpr(), result.gpr());
 6330 
 6331     unblessedBooleanResult(result.gpr(), node);
 6332 }
 6333 
 6334 void SpeculativeJIT::compileInt32Compare(Node* node, MacroAssembler::RelationalCondition condition)
 6335 {
 6336     if (node-&gt;child1()-&gt;isInt32Constant()) {
 6337         SpeculateInt32Operand op2(this, node-&gt;child2());
 6338         GPRTemporary result(this, Reuse, op2);
 6339         int32_t imm = node-&gt;child1()-&gt;asInt32();
 6340         m_jit.compare32(condition, JITCompiler::Imm32(imm), op2.gpr(), result.gpr());
 6341 
 6342         unblessedBooleanResult(result.gpr(), node);
 6343     } else if (node-&gt;child2()-&gt;isInt32Constant()) {
 6344         SpeculateInt32Operand op1(this, node-&gt;child1());
 6345         GPRTemporary result(this, Reuse, op1);
 6346         int32_t imm = node-&gt;child2()-&gt;asInt32();
 6347         m_jit.compare32(condition, op1.gpr(), JITCompiler::Imm32(imm), result.gpr());
 6348 
 6349         unblessedBooleanResult(result.gpr(), node);
 6350     } else {
 6351         SpeculateInt32Operand op1(this, node-&gt;child1());
 6352         SpeculateInt32Operand op2(this, node-&gt;child2());
 6353         GPRTemporary result(this, Reuse, op1, op2);
 6354         m_jit.compare32(condition, op1.gpr(), op2.gpr(), result.gpr());
 6355 
 6356         unblessedBooleanResult(result.gpr(), node);
 6357     }
 6358 }
 6359 
 6360 void SpeculativeJIT::compileDoubleCompare(Node* node, MacroAssembler::DoubleCondition condition)
 6361 {
 6362     SpeculateDoubleOperand op1(this, node-&gt;child1());
 6363     SpeculateDoubleOperand op2(this, node-&gt;child2());
 6364     GPRTemporary result(this);
 6365 
 6366     FPRReg op1FPR = op1.fpr();
 6367     FPRReg op2FPR = op2.fpr();
 6368     GPRReg resultGPR = result.gpr();
 6369 
 6370     m_jit.compareDouble(condition, op1FPR, op2FPR, resultGPR);
 6371 
 6372     unblessedBooleanResult(resultGPR, node);
 6373 }
 6374 
 6375 void SpeculativeJIT::compileObjectEquality(Node* node)
 6376 {
 6377     SpeculateCellOperand op1(this, node-&gt;child1());
 6378     SpeculateCellOperand op2(this, node-&gt;child2());
 6379     GPRTemporary result(this, Reuse, op1);
 6380 
 6381     GPRReg op1GPR = op1.gpr();
 6382     GPRReg op2GPR = op2.gpr();
 6383     GPRReg resultGPR = result.gpr();
 6384 
 6385     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
 6386         DFG_TYPE_CHECK(
 6387             JSValueSource::unboxedCell(op1GPR), node-&gt;child1(), SpecObject, m_jit.branchIfNotObject(op1GPR));
 6388         DFG_TYPE_CHECK(
 6389             JSValueSource::unboxedCell(op2GPR), node-&gt;child2(), SpecObject, m_jit.branchIfNotObject(op2GPR));
 6390     } else {
 6391         DFG_TYPE_CHECK(
 6392             JSValueSource::unboxedCell(op1GPR), node-&gt;child1(), SpecObject, m_jit.branchIfNotObject(op1GPR));
 6393         speculationCheck(BadType, JSValueSource::unboxedCell(op1GPR), node-&gt;child1(),
 6394             m_jit.branchTest8(
 6395                 MacroAssembler::NonZero,
 6396                 MacroAssembler::Address(op1GPR, JSCell::typeInfoFlagsOffset()),
 6397                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
 6398 
 6399         DFG_TYPE_CHECK(
 6400             JSValueSource::unboxedCell(op2GPR), node-&gt;child2(), SpecObject, m_jit.branchIfNotObject(op2GPR));
 6401         speculationCheck(BadType, JSValueSource::unboxedCell(op2GPR), node-&gt;child2(),
 6402             m_jit.branchTest8(
 6403                 MacroAssembler::NonZero,
 6404                 MacroAssembler::Address(op2GPR, JSCell::typeInfoFlagsOffset()),
 6405                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
 6406     }
 6407 
 6408     m_jit.comparePtr(MacroAssembler::Equal, op1GPR, op2GPR, resultGPR);
 6409     unblessedBooleanResult(resultGPR, node);
 6410 }
 6411 
 6412 void SpeculativeJIT::compileSymbolEquality(Node* node)
 6413 {
 6414     SpeculateCellOperand left(this, node-&gt;child1());
 6415     SpeculateCellOperand right(this, node-&gt;child2());
 6416     GPRTemporary result(this, Reuse, left, right);
 6417 
 6418     GPRReg leftGPR = left.gpr();
 6419     GPRReg rightGPR = right.gpr();
 6420     GPRReg resultGPR = result.gpr();
 6421 
 6422     speculateSymbol(node-&gt;child1(), leftGPR);
 6423     speculateSymbol(node-&gt;child2(), rightGPR);
 6424 
 6425     m_jit.comparePtr(JITCompiler::Equal, leftGPR, rightGPR, resultGPR);
 6426     unblessedBooleanResult(resultGPR, node);
 6427 }
 6428 
 6429 void SpeculativeJIT::compilePeepHoleSymbolEquality(Node* node, Node* branchNode)
 6430 {
 6431     SpeculateCellOperand left(this, node-&gt;child1());
 6432     SpeculateCellOperand right(this, node-&gt;child2());
 6433 
 6434     GPRReg leftGPR = left.gpr();
 6435     GPRReg rightGPR = right.gpr();
 6436 
 6437     speculateSymbol(node-&gt;child1(), leftGPR);
 6438     speculateSymbol(node-&gt;child2(), rightGPR);
 6439 
 6440     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 6441     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 6442 
 6443     if (taken == nextBlock()) {
 6444         branchPtr(JITCompiler::NotEqual, leftGPR, rightGPR, notTaken);
 6445         jump(taken);
 6446     } else {
 6447         branchPtr(JITCompiler::Equal, leftGPR, rightGPR, taken);
 6448         jump(notTaken);
 6449     }
 6450 }
 6451 
 6452 void SpeculativeJIT::compileStringEquality(
 6453     Node* node, GPRReg leftGPR, GPRReg rightGPR, GPRReg lengthGPR, GPRReg leftTempGPR,
 6454     GPRReg rightTempGPR, GPRReg leftTemp2GPR, GPRReg rightTemp2GPR,
 6455     const JITCompiler::JumpList&amp; fastTrue, const JITCompiler::JumpList&amp; fastFalse)
 6456 {
 6457     JITCompiler::JumpList trueCase;
 6458     JITCompiler::JumpList falseCase;
 6459     JITCompiler::JumpList slowCase;
 6460 
 6461     trueCase.append(fastTrue);
 6462     falseCase.append(fastFalse);
 6463 
 6464     m_jit.loadPtr(MacroAssembler::Address(leftGPR, JSString::offsetOfValue()), leftTempGPR);
 6465     m_jit.loadPtr(MacroAssembler::Address(rightGPR, JSString::offsetOfValue()), rightTempGPR);
 6466 
 6467     slowCase.append(m_jit.branchIfRopeStringImpl(leftTempGPR));
 6468     slowCase.append(m_jit.branchIfRopeStringImpl(rightTempGPR));
 6469 
 6470     m_jit.load32(MacroAssembler::Address(leftTempGPR, StringImpl::lengthMemoryOffset()), lengthGPR);
 6471 
 6472     falseCase.append(m_jit.branch32(
 6473         MacroAssembler::NotEqual,
 6474         MacroAssembler::Address(rightTempGPR, StringImpl::lengthMemoryOffset()),
 6475         lengthGPR));
 6476 
 6477     trueCase.append(m_jit.branchTest32(MacroAssembler::Zero, lengthGPR));
 6478 
 6479     slowCase.append(m_jit.branchTest32(
 6480         MacroAssembler::Zero,
 6481         MacroAssembler::Address(leftTempGPR, StringImpl::flagsOffset()),
 6482         TrustedImm32(StringImpl::flagIs8Bit())));
 6483     slowCase.append(m_jit.branchTest32(
 6484         MacroAssembler::Zero,
 6485         MacroAssembler::Address(rightTempGPR, StringImpl::flagsOffset()),
 6486         TrustedImm32(StringImpl::flagIs8Bit())));
 6487 
 6488     m_jit.loadPtr(MacroAssembler::Address(leftTempGPR, StringImpl::dataOffset()), leftTempGPR);
 6489     m_jit.loadPtr(MacroAssembler::Address(rightTempGPR, StringImpl::dataOffset()), rightTempGPR);
 6490 
 6491     MacroAssembler::Label loop = m_jit.label();
 6492 
 6493     m_jit.sub32(TrustedImm32(1), lengthGPR);
 6494 
 6495     // This isn&#39;t going to generate the best code on x86. But that&#39;s OK, it&#39;s still better
 6496     // than not inlining.
 6497     m_jit.load8(MacroAssembler::BaseIndex(leftTempGPR, lengthGPR, MacroAssembler::TimesOne), leftTemp2GPR);
 6498     m_jit.load8(MacroAssembler::BaseIndex(rightTempGPR, lengthGPR, MacroAssembler::TimesOne), rightTemp2GPR);
 6499     falseCase.append(m_jit.branch32(MacroAssembler::NotEqual, leftTemp2GPR, rightTemp2GPR));
 6500 
 6501     m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loop, &amp;m_jit);
 6502 
 6503     trueCase.link(&amp;m_jit);
 6504     moveTrueTo(leftTempGPR);
 6505 
 6506     JITCompiler::Jump done = m_jit.jump();
 6507 
 6508     falseCase.link(&amp;m_jit);
 6509     moveFalseTo(leftTempGPR);
 6510 
 6511     done.link(&amp;m_jit);
 6512     addSlowPathGenerator(
 6513         slowPathCall(
<a name="129" id="anc129"></a><span class="line-modified"> 6514             slowCase, this, operationCompareStringEq, leftTempGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR));</span>
 6515 
 6516     blessedBooleanResult(leftTempGPR, node);
 6517 }
 6518 
 6519 void SpeculativeJIT::compileStringEquality(Node* node)
 6520 {
 6521     SpeculateCellOperand left(this, node-&gt;child1());
 6522     SpeculateCellOperand right(this, node-&gt;child2());
 6523     GPRTemporary length(this);
 6524     GPRTemporary leftTemp(this);
 6525     GPRTemporary rightTemp(this);
 6526     GPRTemporary leftTemp2(this, Reuse, left);
 6527     GPRTemporary rightTemp2(this, Reuse, right);
 6528 
 6529     GPRReg leftGPR = left.gpr();
 6530     GPRReg rightGPR = right.gpr();
 6531     GPRReg lengthGPR = length.gpr();
 6532     GPRReg leftTempGPR = leftTemp.gpr();
 6533     GPRReg rightTempGPR = rightTemp.gpr();
 6534     GPRReg leftTemp2GPR = leftTemp2.gpr();
 6535     GPRReg rightTemp2GPR = rightTemp2.gpr();
 6536 
 6537     speculateString(node-&gt;child1(), leftGPR);
 6538 
 6539     // It&#39;s safe to branch around the type check below, since proving that the values are
 6540     // equal does indeed prove that the right value is a string.
 6541     JITCompiler::Jump fastTrue = m_jit.branchPtr(MacroAssembler::Equal, leftGPR, rightGPR);
 6542 
 6543     speculateString(node-&gt;child2(), rightGPR);
 6544 
 6545     compileStringEquality(
 6546         node, leftGPR, rightGPR, lengthGPR, leftTempGPR, rightTempGPR, leftTemp2GPR,
 6547         rightTemp2GPR, fastTrue, JITCompiler::Jump());
 6548 }
 6549 
 6550 void SpeculativeJIT::compileStringToUntypedEquality(Node* node, Edge stringEdge, Edge untypedEdge)
 6551 {
 6552     SpeculateCellOperand left(this, stringEdge);
 6553     JSValueOperand right(this, untypedEdge, ManualOperandSpeculation);
 6554     GPRTemporary length(this);
 6555     GPRTemporary leftTemp(this);
 6556     GPRTemporary rightTemp(this);
 6557     GPRTemporary leftTemp2(this, Reuse, left);
 6558     GPRTemporary rightTemp2(this);
 6559 
 6560     GPRReg leftGPR = left.gpr();
 6561     JSValueRegs rightRegs = right.jsValueRegs();
 6562     GPRReg lengthGPR = length.gpr();
 6563     GPRReg leftTempGPR = leftTemp.gpr();
 6564     GPRReg rightTempGPR = rightTemp.gpr();
 6565     GPRReg leftTemp2GPR = leftTemp2.gpr();
 6566     GPRReg rightTemp2GPR = rightTemp2.gpr();
 6567 
 6568     speculateString(stringEdge, leftGPR);
 6569 
 6570     JITCompiler::JumpList fastTrue;
 6571     JITCompiler::JumpList fastFalse;
 6572 
 6573     fastFalse.append(m_jit.branchIfNotCell(rightRegs));
 6574 
 6575     // It&#39;s safe to branch around the type check below, since proving that the values are
 6576     // equal does indeed prove that the right value is a string.
 6577     fastTrue.append(m_jit.branchPtr(
 6578         MacroAssembler::Equal, leftGPR, rightRegs.payloadGPR()));
 6579 
 6580     fastFalse.append(m_jit.branchIfNotString(rightRegs.payloadGPR()));
 6581 
 6582     compileStringEquality(
 6583         node, leftGPR, rightRegs.payloadGPR(), lengthGPR, leftTempGPR, rightTempGPR, leftTemp2GPR,
 6584         rightTemp2GPR, fastTrue, fastFalse);
 6585 }
 6586 
 6587 void SpeculativeJIT::compileStringIdentEquality(Node* node)
 6588 {
 6589     SpeculateCellOperand left(this, node-&gt;child1());
 6590     SpeculateCellOperand right(this, node-&gt;child2());
 6591     GPRTemporary leftTemp(this);
 6592     GPRTemporary rightTemp(this);
 6593 
 6594     GPRReg leftGPR = left.gpr();
 6595     GPRReg rightGPR = right.gpr();
 6596     GPRReg leftTempGPR = leftTemp.gpr();
 6597     GPRReg rightTempGPR = rightTemp.gpr();
 6598 
 6599     speculateString(node-&gt;child1(), leftGPR);
 6600     speculateString(node-&gt;child2(), rightGPR);
 6601 
 6602     speculateStringIdentAndLoadStorage(node-&gt;child1(), leftGPR, leftTempGPR);
 6603     speculateStringIdentAndLoadStorage(node-&gt;child2(), rightGPR, rightTempGPR);
 6604 
 6605     m_jit.comparePtr(MacroAssembler::Equal, leftTempGPR, rightTempGPR, leftTempGPR);
 6606 
 6607     unblessedBooleanResult(leftTempGPR, node);
 6608 }
 6609 
 6610 void SpeculativeJIT::compileStringIdentToNotStringVarEquality(
 6611     Node* node, Edge stringEdge, Edge notStringVarEdge)
 6612 {
 6613     SpeculateCellOperand left(this, stringEdge);
 6614     JSValueOperand right(this, notStringVarEdge, ManualOperandSpeculation);
 6615     GPRTemporary leftTemp(this);
 6616     GPRTemporary rightTemp(this);
 6617     GPRReg leftTempGPR = leftTemp.gpr();
 6618     GPRReg rightTempGPR = rightTemp.gpr();
 6619     GPRReg leftGPR = left.gpr();
 6620     JSValueRegs rightRegs = right.jsValueRegs();
 6621 
 6622     speculateString(stringEdge, leftGPR);
 6623     speculateStringIdentAndLoadStorage(stringEdge, leftGPR, leftTempGPR);
 6624 
 6625     moveFalseTo(rightTempGPR);
 6626     JITCompiler::JumpList notString;
 6627     notString.append(m_jit.branchIfNotCell(rightRegs));
 6628     notString.append(m_jit.branchIfNotString(rightRegs.payloadGPR()));
 6629 
 6630     speculateStringIdentAndLoadStorage(notStringVarEdge, rightRegs.payloadGPR(), rightTempGPR);
 6631 
 6632     m_jit.comparePtr(MacroAssembler::Equal, leftTempGPR, rightTempGPR, rightTempGPR);
 6633     notString.link(&amp;m_jit);
 6634 
 6635     unblessedBooleanResult(rightTempGPR, node);
 6636 }
 6637 
 6638 void SpeculativeJIT::compileStringCompare(Node* node, MacroAssembler::RelationalCondition condition)
 6639 {
 6640     SpeculateCellOperand left(this, node-&gt;child1());
 6641     SpeculateCellOperand right(this, node-&gt;child2());
 6642     GPRReg leftGPR = left.gpr();
 6643     GPRReg rightGPR = right.gpr();
 6644 
 6645     speculateString(node-&gt;child1(), leftGPR);
 6646     speculateString(node-&gt;child2(), rightGPR);
 6647 
<a name="130" id="anc130"></a><span class="line-modified"> 6648     C_JITOperation_B_GJssJss compareFunction = nullptr;</span>
 6649     if (condition == MacroAssembler::LessThan)
 6650         compareFunction = operationCompareStringLess;
 6651     else if (condition == MacroAssembler::LessThanOrEqual)
 6652         compareFunction = operationCompareStringLessEq;
 6653     else if (condition == MacroAssembler::GreaterThan)
 6654         compareFunction = operationCompareStringGreater;
 6655     else if (condition == MacroAssembler::GreaterThanOrEqual)
 6656         compareFunction = operationCompareStringGreaterEq;
 6657     else
 6658         RELEASE_ASSERT_NOT_REACHED();
 6659 
 6660     GPRFlushedCallResult result(this);
 6661     GPRReg resultGPR = result.gpr();
 6662 
 6663     flushRegisters();
<a name="131" id="anc131"></a><span class="line-modified"> 6664     callOperation(compareFunction, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
 6665     m_jit.exceptionCheck();
 6666 
 6667     unblessedBooleanResult(resultGPR, node);
 6668 }
 6669 
 6670 void SpeculativeJIT::compileStringIdentCompare(Node* node, MacroAssembler::RelationalCondition condition)
 6671 {
 6672     SpeculateCellOperand left(this, node-&gt;child1());
 6673     SpeculateCellOperand right(this, node-&gt;child2());
 6674     GPRFlushedCallResult result(this);
 6675     GPRTemporary leftTemp(this);
 6676     GPRTemporary rightTemp(this);
 6677 
 6678     GPRReg leftGPR = left.gpr();
 6679     GPRReg rightGPR = right.gpr();
 6680     GPRReg resultGPR = result.gpr();
 6681     GPRReg leftTempGPR = leftTemp.gpr();
 6682     GPRReg rightTempGPR = rightTemp.gpr();
 6683 
 6684     speculateString(node-&gt;child1(), leftGPR);
 6685     speculateString(node-&gt;child2(), rightGPR);
 6686 
 6687     C_JITOperation_TT compareFunction = nullptr;
 6688     if (condition == MacroAssembler::LessThan)
 6689         compareFunction = operationCompareStringImplLess;
 6690     else if (condition == MacroAssembler::LessThanOrEqual)
 6691         compareFunction = operationCompareStringImplLessEq;
 6692     else if (condition == MacroAssembler::GreaterThan)
 6693         compareFunction = operationCompareStringImplGreater;
 6694     else if (condition == MacroAssembler::GreaterThanOrEqual)
 6695         compareFunction = operationCompareStringImplGreaterEq;
 6696     else
 6697         RELEASE_ASSERT_NOT_REACHED();
 6698 
 6699     speculateStringIdentAndLoadStorage(node-&gt;child1(), leftGPR, leftTempGPR);
 6700     speculateStringIdentAndLoadStorage(node-&gt;child2(), rightGPR, rightTempGPR);
 6701 
 6702     flushRegisters();
 6703     callOperation(compareFunction, resultGPR, leftTempGPR, rightTempGPR);
 6704 
 6705     unblessedBooleanResult(resultGPR, node);
 6706 }
 6707 
 6708 void SpeculativeJIT::compileSameValue(Node* node)
 6709 {
 6710     if (node-&gt;isBinaryUseKind(DoubleRepUse)) {
 6711         SpeculateDoubleOperand arg1(this, node-&gt;child1());
 6712         SpeculateDoubleOperand arg2(this, node-&gt;child2());
 6713         GPRTemporary result(this);
 6714         GPRTemporary temp(this);
 6715         GPRTemporary temp2(this);
 6716 
 6717         FPRReg arg1FPR = arg1.fpr();
 6718         FPRReg arg2FPR = arg2.fpr();
 6719         GPRReg resultGPR = result.gpr();
 6720         GPRReg tempGPR = temp.gpr();
 6721         GPRReg temp2GPR = temp2.gpr();
 6722 
 6723 #if USE(JSVALUE64)
 6724         m_jit.moveDoubleTo64(arg1FPR, tempGPR);
 6725         m_jit.moveDoubleTo64(arg2FPR, temp2GPR);
 6726         auto trueCase = m_jit.branch64(CCallHelpers::Equal, tempGPR, temp2GPR);
 6727 #else
 6728         GPRTemporary temp3(this);
 6729         GPRReg temp3GPR = temp3.gpr();
 6730 
 6731         m_jit.moveDoubleToInts(arg1FPR, tempGPR, temp2GPR);
 6732         m_jit.moveDoubleToInts(arg2FPR, temp3GPR, resultGPR);
 6733         auto notEqual = m_jit.branch32(CCallHelpers::NotEqual, tempGPR, temp3GPR);
 6734         auto trueCase = m_jit.branch32(CCallHelpers::Equal, temp2GPR, resultGPR);
 6735         notEqual.link(&amp;m_jit);
 6736 #endif
 6737 
 6738         m_jit.compareDouble(CCallHelpers::DoubleNotEqualOrUnordered, arg1FPR, arg1FPR, tempGPR);
 6739         m_jit.compareDouble(CCallHelpers::DoubleNotEqualOrUnordered, arg2FPR, arg2FPR, temp2GPR);
 6740         m_jit.and32(tempGPR, temp2GPR, resultGPR);
 6741         auto done = m_jit.jump();
 6742 
 6743         trueCase.link(&amp;m_jit);
 6744         m_jit.move(CCallHelpers::TrustedImm32(1), resultGPR);
 6745         done.link(&amp;m_jit);
 6746 
 6747         unblessedBooleanResult(resultGPR, node);
 6748         return;
 6749     }
 6750 
 6751     ASSERT(node-&gt;isBinaryUseKind(UntypedUse));
 6752 
 6753     JSValueOperand arg1(this, node-&gt;child1());
 6754     JSValueOperand arg2(this, node-&gt;child2());
 6755     JSValueRegs arg1Regs = arg1.jsValueRegs();
 6756     JSValueRegs arg2Regs = arg2.jsValueRegs();
 6757 
 6758     arg1.use();
 6759     arg2.use();
 6760 
 6761     flushRegisters();
 6762 
 6763     GPRFlushedCallResult result(this);
 6764     GPRReg resultGPR = result.gpr();
<a name="132" id="anc132"></a><span class="line-modified"> 6765     callOperation(operationSameValue, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs);</span>
 6766     m_jit.exceptionCheck();
 6767 
 6768     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
 6769 }
 6770 
 6771 void SpeculativeJIT::compileStringZeroLength(Node* node)
 6772 {
 6773     SpeculateCellOperand str(this, node-&gt;child1());
 6774     GPRReg strGPR = str.gpr();
 6775 
 6776     // Make sure that this is a string.
 6777     speculateString(node-&gt;child1(), strGPR);
 6778 
 6779     GPRTemporary eq(this);
 6780     GPRReg eqGPR = eq.gpr();
 6781 
 6782     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(vm())), eqGPR);
 6783     m_jit.comparePtr(CCallHelpers::Equal, strGPR, eqGPR, eqGPR);
 6784     unblessedBooleanResult(eqGPR, node);
 6785 }
 6786 
 6787 void SpeculativeJIT::compileLogicalNotStringOrOther(Node* node)
 6788 {
 6789     JSValueOperand value(this, node-&gt;child1(), ManualOperandSpeculation);
 6790     GPRTemporary temp(this);
 6791     JSValueRegs valueRegs = value.jsValueRegs();
 6792     GPRReg tempGPR = temp.gpr();
 6793 
 6794     JITCompiler::Jump notCell = m_jit.branchIfNotCell(valueRegs);
 6795     GPRReg cellGPR = valueRegs.payloadGPR();
 6796     DFG_TYPE_CHECK(
 6797         valueRegs, node-&gt;child1(), (~SpecCellCheck) | SpecString, m_jit.branchIfNotString(cellGPR));
 6798 
 6799     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(vm())), tempGPR);
 6800     m_jit.comparePtr(CCallHelpers::Equal, cellGPR, tempGPR, tempGPR);
 6801     auto done = m_jit.jump();
 6802 
 6803     notCell.link(&amp;m_jit);
 6804     DFG_TYPE_CHECK(
 6805         valueRegs, node-&gt;child1(), SpecCellCheck | SpecOther, m_jit.branchIfNotOther(valueRegs, tempGPR));
 6806     m_jit.move(TrustedImm32(1), tempGPR);
 6807 
 6808     done.link(&amp;m_jit);
 6809     unblessedBooleanResult(tempGPR, node);
 6810 
 6811 }
 6812 
 6813 void SpeculativeJIT::emitStringBranch(Edge nodeUse, BasicBlock* taken, BasicBlock* notTaken)
 6814 {
 6815     SpeculateCellOperand str(this, nodeUse);
 6816 
 6817     GPRReg strGPR = str.gpr();
 6818 
 6819     speculateString(nodeUse, strGPR);
 6820 
 6821     branchPtr(CCallHelpers::Equal, strGPR, TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(vm())), notTaken);
 6822     jump(taken);
 6823 
 6824     noResult(m_currentNode);
 6825 }
 6826 
 6827 void SpeculativeJIT::emitStringOrOtherBranch(Edge nodeUse, BasicBlock* taken, BasicBlock* notTaken)
 6828 {
 6829     JSValueOperand value(this, nodeUse, ManualOperandSpeculation);
 6830     GPRTemporary temp(this);
 6831     JSValueRegs valueRegs = value.jsValueRegs();
 6832     GPRReg tempGPR = temp.gpr();
 6833 
 6834     JITCompiler::Jump notCell = m_jit.branchIfNotCell(valueRegs);
 6835     GPRReg cellGPR = valueRegs.payloadGPR();
 6836     DFG_TYPE_CHECK(valueRegs, nodeUse, (~SpecCellCheck) | SpecString, m_jit.branchIfNotString(cellGPR));
 6837 
 6838     branchPtr(CCallHelpers::Equal, cellGPR, TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(vm())), notTaken);
 6839     jump(taken, ForceJump);
 6840 
 6841     notCell.link(&amp;m_jit);
 6842     DFG_TYPE_CHECK(
 6843         valueRegs, nodeUse, SpecCellCheck | SpecOther, m_jit.branchIfNotOther(valueRegs, tempGPR));
 6844     jump(notTaken);
 6845     noResult(m_currentNode);
 6846 }
 6847 
 6848 void SpeculativeJIT::compileConstantStoragePointer(Node* node)
 6849 {
 6850     GPRTemporary storage(this);
 6851     GPRReg storageGPR = storage.gpr();
 6852     m_jit.move(TrustedImmPtr(node-&gt;storagePointer()), storageGPR);
 6853     storageResult(storageGPR, node);
 6854 }
 6855 
 6856 void SpeculativeJIT::cageTypedArrayStorage(GPRReg baseReg, GPRReg storageReg)
 6857 {
 6858     auto untagArrayPtr = [&amp;]() {
 6859 #if CPU(ARM64E)
 6860         m_jit.untagArrayPtr(MacroAssembler::Address(baseReg, JSArrayBufferView::offsetOfLength()), storageReg);
 6861 #else
 6862         UNUSED_PARAM(baseReg);
 6863         UNUSED_PARAM(storageReg);
 6864 #endif
 6865     };
 6866 
 6867 #if GIGACAGE_ENABLED
 6868     UNUSED_PARAM(baseReg);
 6869     if (!Gigacage::shouldBeEnabled()) {
 6870         untagArrayPtr();
 6871         return;
 6872     }
 6873 
 6874     if (Gigacage::canPrimitiveGigacageBeDisabled()) {
 6875         VM&amp; vm = this-&gt;vm();
 6876         if (vm.primitiveGigacageEnabled().isStillValid())
 6877             m_jit.graph().watchpoints().addLazily(vm.primitiveGigacageEnabled());
 6878         else {
 6879             untagArrayPtr();
 6880             return;
 6881         }
 6882     }
 6883 
 6884     m_jit.cageWithoutUntagging(Gigacage::Primitive, storageReg);
 6885 #endif
 6886     untagArrayPtr();
 6887 }
 6888 
 6889 void SpeculativeJIT::compileGetIndexedPropertyStorage(Node* node)
 6890 {
 6891     SpeculateCellOperand base(this, node-&gt;child1());
 6892     GPRReg baseReg = base.gpr();
 6893 
 6894     GPRTemporary storage(this);
 6895     GPRReg storageReg = storage.gpr();
 6896 
 6897     switch (node-&gt;arrayMode().type()) {
 6898     case Array::String:
 6899         m_jit.loadPtr(MacroAssembler::Address(baseReg, JSString::offsetOfValue()), storageReg);
 6900 
 6901         addSlowPathGenerator(
 6902             slowPathCall(
 6903                 m_jit.branchIfRopeStringImpl(storageReg),
<a name="133" id="anc133"></a><span class="line-modified"> 6904                 this, operationResolveRope, storageReg, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg));</span>
 6905 
 6906         m_jit.loadPtr(MacroAssembler::Address(storageReg, StringImpl::dataOffset()), storageReg);
 6907         break;
 6908 
 6909     default: {
 6910         auto typedArrayType = node-&gt;arrayMode().typedArrayType();
 6911         ASSERT_UNUSED(typedArrayType, isTypedView(typedArrayType));
 6912 
 6913         m_jit.loadPtr(JITCompiler::Address(baseReg, JSArrayBufferView::offsetOfVector()), storageReg);
 6914         cageTypedArrayStorage(baseReg, storageReg);
 6915         break;
 6916     }
 6917     }
 6918 
 6919     storageResult(storageReg, node);
 6920 }
 6921 
 6922 void SpeculativeJIT::compileGetTypedArrayByteOffset(Node* node)
 6923 {
 6924     SpeculateCellOperand base(this, node-&gt;child1());
 6925     GPRTemporary vector(this);
 6926     GPRTemporary data(this);
 6927 
 6928     GPRReg baseGPR = base.gpr();
 6929     GPRReg vectorGPR = vector.gpr();
 6930     GPRReg dataGPR = data.gpr();
 6931     ASSERT(baseGPR != vectorGPR);
 6932     ASSERT(baseGPR != dataGPR);
 6933     ASSERT(vectorGPR != dataGPR);
 6934 
 6935     GPRReg arrayBufferGPR = dataGPR;
 6936 
 6937     JITCompiler::Jump emptyByteOffset = m_jit.branch32(
 6938         MacroAssembler::NotEqual,
 6939         MacroAssembler::Address(baseGPR, JSArrayBufferView::offsetOfMode()),
 6940         TrustedImm32(WastefulTypedArray));
 6941 
 6942     m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSArrayBufferView::offsetOfVector()), vectorGPR);
 6943 
 6944     // FIXME: This should mask the PAC bits
 6945     // https://bugs.webkit.org/show_bug.cgi?id=197701
 6946     JITCompiler::Jump nullVector = m_jit.branchTestPtr(JITCompiler::Zero, vectorGPR);
 6947 
 6948     m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSObject::butterflyOffset()), dataGPR);
 6949     m_jit.cageWithoutUntagging(Gigacage::JSValue, dataGPR);
 6950 
 6951     cageTypedArrayStorage(baseGPR, vectorGPR);
 6952 
 6953     m_jit.loadPtr(MacroAssembler::Address(dataGPR, Butterfly::offsetOfArrayBuffer()), arrayBufferGPR);
 6954     // FIXME: This needs caging.
 6955     // https://bugs.webkit.org/show_bug.cgi?id=175515
 6956     m_jit.loadPtr(MacroAssembler::Address(arrayBufferGPR, ArrayBuffer::offsetOfData()), dataGPR);
 6957 #if CPU(ARM64E)
 6958     m_jit.removeArrayPtrTag(dataGPR);
 6959 #endif
 6960 
 6961     m_jit.subPtr(dataGPR, vectorGPR);
 6962 
 6963     JITCompiler::Jump done = m_jit.jump();
 6964 
 6965     emptyByteOffset.link(&amp;m_jit);
 6966     m_jit.move(TrustedImmPtr(nullptr), vectorGPR);
 6967 
 6968     done.link(&amp;m_jit);
 6969     nullVector.link(&amp;m_jit);
 6970 
 6971     int32Result(vectorGPR, node);
 6972 }
 6973 
 6974 void SpeculativeJIT::compileGetByValOnDirectArguments(Node* node)
 6975 {
 6976     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
 6977     SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
 6978     JSValueRegsTemporary result(this);
 6979     GPRTemporary scratch(this);
 6980 
 6981     GPRReg baseReg = base.gpr();
 6982     GPRReg propertyReg = property.gpr();
 6983     JSValueRegs resultRegs = result.regs();
 6984     GPRReg scratchReg = scratch.gpr();
 6985 
 6986     if (!m_compileOkay)
 6987         return;
 6988 
 6989     ASSERT(ArrayMode(Array::DirectArguments, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(m_graph.varArgChild(node, 0))));
 6990 
 6991     speculationCheck(
 6992         ExoticObjectMode, JSValueSource(), 0,
 6993         m_jit.branchTestPtr(
 6994             MacroAssembler::NonZero,
 6995             MacroAssembler::Address(baseReg, DirectArguments::offsetOfMappedArguments())));
 6996 
 6997     m_jit.load32(CCallHelpers::Address(baseReg, DirectArguments::offsetOfLength()), scratchReg);
 6998     auto isOutOfBounds = m_jit.branch32(CCallHelpers::AboveOrEqual, propertyReg, scratchReg);
 6999     if (node-&gt;arrayMode().isInBounds())
 7000         speculationCheck(OutOfBounds, JSValueSource(), 0, isOutOfBounds);
 7001 
 7002     m_jit.loadValue(
 7003         MacroAssembler::BaseIndex(
 7004             baseReg, propertyReg, MacroAssembler::TimesEight, DirectArguments::storageOffset()),
 7005         resultRegs);
 7006 
 7007     if (!node-&gt;arrayMode().isInBounds()) {
 7008         addSlowPathGenerator(
 7009             slowPathCall(
 7010                 isOutOfBounds, this, operationGetByValObjectInt,
<a name="134" id="anc134"></a><span class="line-modified"> 7011                 extractResult(resultRegs), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg));</span>
 7012     }
 7013 
 7014     jsValueResult(resultRegs, node);
 7015 }
 7016 
 7017 void SpeculativeJIT::compileGetByValOnScopedArguments(Node* node)
 7018 {
 7019     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
 7020     SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
 7021     JSValueRegsTemporary result(this);
 7022     GPRTemporary scratch(this);
 7023     GPRTemporary scratch2(this);
<a name="135" id="anc135"></a>
 7024 
 7025     GPRReg baseReg = base.gpr();
 7026     GPRReg propertyReg = property.gpr();
 7027     JSValueRegs resultRegs = result.regs();
 7028     GPRReg scratchReg = scratch.gpr();
 7029     GPRReg scratch2Reg = scratch2.gpr();
<a name="136" id="anc136"></a>
 7030 
 7031     if (!m_compileOkay)
 7032         return;
 7033 
 7034     ASSERT(ArrayMode(Array::ScopedArguments, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(m_graph.varArgChild(node, 0))));
 7035 
 7036     m_jit.loadPtr(
 7037         MacroAssembler::Address(baseReg, ScopedArguments::offsetOfStorage()), resultRegs.payloadGPR());
<a name="137" id="anc137"></a>


 7038 
 7039     speculationCheck(
 7040         ExoticObjectMode, JSValueSource(), nullptr,
<a name="138" id="anc138"></a><span class="line-modified"> 7041         m_jit.branch32(</span>
<span class="line-modified"> 7042             MacroAssembler::AboveOrEqual, propertyReg,</span>
<span class="line-modified"> 7043             MacroAssembler::Address(baseReg, ScopedArguments::offsetOfTotalLength())));</span>
 7044 
 7045     m_jit.loadPtr(MacroAssembler::Address(baseReg, ScopedArguments::offsetOfTable()), scratchReg);
 7046     m_jit.load32(
 7047         MacroAssembler::Address(scratchReg, ScopedArgumentsTable::offsetOfLength()), scratch2Reg);
 7048 
 7049     MacroAssembler::Jump overflowArgument = m_jit.branch32(
 7050         MacroAssembler::AboveOrEqual, propertyReg, scratch2Reg);
 7051 
 7052     m_jit.loadPtr(MacroAssembler::Address(baseReg, ScopedArguments::offsetOfScope()), scratch2Reg);
 7053 
 7054     m_jit.loadPtr(
 7055         MacroAssembler::Address(scratchReg, ScopedArgumentsTable::offsetOfArguments()),
 7056         scratchReg);
 7057     m_jit.load32(
 7058         MacroAssembler::BaseIndex(scratchReg, propertyReg, MacroAssembler::TimesFour),
 7059         scratchReg);
 7060 
 7061     speculationCheck(
 7062         ExoticObjectMode, JSValueSource(), nullptr,
 7063         m_jit.branch32(
 7064             MacroAssembler::Equal, scratchReg, TrustedImm32(ScopeOffset::invalidOffset)));
 7065 
 7066     m_jit.loadValue(
 7067         MacroAssembler::BaseIndex(
 7068             scratch2Reg, propertyReg, MacroAssembler::TimesEight,
 7069             JSLexicalEnvironment::offsetOfVariables()),
 7070         resultRegs);
 7071 
 7072     MacroAssembler::Jump done = m_jit.jump();
 7073     overflowArgument.link(&amp;m_jit);
 7074 
 7075     m_jit.sub32(propertyReg, scratch2Reg);
 7076     m_jit.neg32(scratch2Reg);
 7077 
 7078     m_jit.loadValue(
 7079         MacroAssembler::BaseIndex(
 7080             resultRegs.payloadGPR(), scratch2Reg, MacroAssembler::TimesEight),
 7081         resultRegs);
 7082     speculationCheck(ExoticObjectMode, JSValueSource(), nullptr, m_jit.branchIfEmpty(resultRegs));
 7083 
 7084     done.link(&amp;m_jit);
 7085 
<a name="139" id="anc139"></a>

 7086     jsValueResult(resultRegs, node);
 7087 }
 7088 
 7089 void SpeculativeJIT::compileGetScope(Node* node)
 7090 {
 7091     SpeculateCellOperand function(this, node-&gt;child1());
 7092     GPRTemporary result(this, Reuse, function);
 7093     m_jit.loadPtr(JITCompiler::Address(function.gpr(), JSFunction::offsetOfScopeChain()), result.gpr());
 7094     cellResult(result.gpr(), node);
 7095 }
 7096 
 7097 void SpeculativeJIT::compileSkipScope(Node* node)
 7098 {
 7099     SpeculateCellOperand scope(this, node-&gt;child1());
 7100     GPRTemporary result(this, Reuse, scope);
 7101     m_jit.loadPtr(JITCompiler::Address(scope.gpr(), JSScope::offsetOfNext()), result.gpr());
 7102     cellResult(result.gpr(), node);
 7103 }
 7104 
 7105 void SpeculativeJIT::compileGetGlobalObject(Node* node)
 7106 {
 7107     SpeculateCellOperand object(this, node-&gt;child1());
 7108     GPRTemporary result(this);
 7109     GPRTemporary scratch(this);
 7110     m_jit.emitLoadStructure(vm(), object.gpr(), result.gpr(), scratch.gpr());
 7111     m_jit.loadPtr(JITCompiler::Address(result.gpr(), Structure::globalObjectOffset()), result.gpr());
 7112     cellResult(result.gpr(), node);
 7113 }
 7114 
 7115 void SpeculativeJIT::compileGetGlobalThis(Node* node)
 7116 {
 7117     GPRTemporary result(this);
 7118     GPRReg resultGPR = result.gpr();
 7119     auto* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 7120     m_jit.loadPtr(globalObject-&gt;addressOfGlobalThis(), resultGPR);
 7121     cellResult(resultGPR, node);
 7122 }
 7123 
 7124 bool SpeculativeJIT::canBeRope(Edge&amp; edge)
 7125 {
 7126     if (m_state.forNode(edge).isType(SpecStringIdent))
 7127         return false;
 7128     // If this value is LazyValue, it will be converted to JSString, and the result must be non-rope string.
 7129     String string = edge-&gt;tryGetString(m_graph);
 7130     if (!string.isNull())
 7131         return false;
 7132     return true;
 7133 }
 7134 
 7135 void SpeculativeJIT::compileGetArrayLength(Node* node)
 7136 {
 7137     switch (node-&gt;arrayMode().type()) {
 7138     case Array::Undecided:
 7139     case Array::Int32:
 7140     case Array::Double:
 7141     case Array::Contiguous: {
 7142         StorageOperand storage(this, node-&gt;child2());
 7143         GPRTemporary result(this, Reuse, storage);
 7144         GPRReg storageReg = storage.gpr();
 7145         GPRReg resultReg = result.gpr();
 7146         m_jit.load32(MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()), resultReg);
 7147 
 7148         int32Result(resultReg, node);
 7149         break;
 7150     }
 7151     case Array::ArrayStorage:
 7152     case Array::SlowPutArrayStorage: {
 7153         StorageOperand storage(this, node-&gt;child2());
 7154         GPRTemporary result(this, Reuse, storage);
 7155         GPRReg storageReg = storage.gpr();
 7156         GPRReg resultReg = result.gpr();
 7157         m_jit.load32(MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()), resultReg);
 7158 
 7159         speculationCheck(Uncountable, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::LessThan, resultReg, MacroAssembler::TrustedImm32(0)));
 7160 
 7161         int32Result(resultReg, node);
 7162         break;
 7163     }
 7164     case Array::String: {
 7165         SpeculateCellOperand base(this, node-&gt;child1());
 7166         GPRTemporary result(this, Reuse, base);
 7167         GPRTemporary temp(this);
 7168         GPRReg baseGPR = base.gpr();
 7169         GPRReg resultGPR = result.gpr();
 7170         GPRReg tempGPR = temp.gpr();
 7171 
 7172         bool needsRopeCase = canBeRope(node-&gt;child1());
 7173 
 7174         m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSString::offsetOfValue()), tempGPR);
 7175         CCallHelpers::Jump isRope;
 7176         if (needsRopeCase)
 7177             isRope = m_jit.branchIfRopeStringImpl(tempGPR);
 7178         m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), resultGPR);
 7179         if (needsRopeCase) {
 7180             auto done = m_jit.jump();
 7181 
 7182             isRope.link(&amp;m_jit);
 7183             m_jit.load32(CCallHelpers::Address(baseGPR, JSRopeString::offsetOfLength()), resultGPR);
 7184 
 7185             done.link(&amp;m_jit);
 7186         }
 7187         int32Result(resultGPR, node);
 7188         break;
 7189     }
 7190     case Array::DirectArguments: {
 7191         SpeculateCellOperand base(this, node-&gt;child1());
 7192         GPRTemporary result(this, Reuse, base);
 7193 
 7194         GPRReg baseReg = base.gpr();
 7195         GPRReg resultReg = result.gpr();
 7196 
 7197         if (!m_compileOkay)
 7198             return;
 7199 
 7200         ASSERT(ArrayMode(Array::DirectArguments, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(node-&gt;child1())));
 7201 
 7202         speculationCheck(
 7203             ExoticObjectMode, JSValueSource(), 0,
 7204             m_jit.branchTestPtr(
 7205                 MacroAssembler::NonZero,
 7206                 MacroAssembler::Address(baseReg, DirectArguments::offsetOfMappedArguments())));
 7207 
 7208         m_jit.load32(
 7209             MacroAssembler::Address(baseReg, DirectArguments::offsetOfLength()), resultReg);
 7210 
 7211         int32Result(resultReg, node);
 7212         break;
 7213     }
 7214     case Array::ScopedArguments: {
 7215         SpeculateCellOperand base(this, node-&gt;child1());
<a name="140" id="anc140"></a><span class="line-modified"> 7216         GPRTemporary result(this, Reuse, base);</span>
 7217 
 7218         GPRReg baseReg = base.gpr();
 7219         GPRReg resultReg = result.gpr();
 7220 
 7221         if (!m_compileOkay)
 7222             return;
 7223 
 7224         ASSERT(ArrayMode(Array::ScopedArguments, Array::Read).alreadyChecked(m_jit.graph(), node, m_state.forNode(node-&gt;child1())));
 7225 
<a name="141" id="anc141"></a>


 7226         speculationCheck(
 7227             ExoticObjectMode, JSValueSource(), 0,
 7228             m_jit.branchTest8(
 7229                 MacroAssembler::NonZero,
<a name="142" id="anc142"></a><span class="line-modified"> 7230                 MacroAssembler::Address(baseReg, ScopedArguments::offsetOfOverrodeThings())));</span>
 7231 
 7232         m_jit.load32(
<a name="143" id="anc143"></a><span class="line-modified"> 7233             MacroAssembler::Address(baseReg, ScopedArguments::offsetOfTotalLength()), resultReg);</span>
 7234 
 7235         int32Result(resultReg, node);
 7236         break;
 7237     }
 7238     default: {
 7239         ASSERT(node-&gt;arrayMode().isSomeTypedArrayView());
 7240         SpeculateCellOperand base(this, node-&gt;child1());
 7241         GPRTemporary result(this, Reuse, base);
 7242         GPRReg baseGPR = base.gpr();
 7243         GPRReg resultGPR = result.gpr();
 7244         m_jit.load32(MacroAssembler::Address(baseGPR, JSArrayBufferView::offsetOfLength()), resultGPR);
 7245         int32Result(resultGPR, node);
 7246         break;
 7247     } }
 7248 }
 7249 
<a name="144" id="anc144"></a><span class="line-modified"> 7250 void SpeculativeJIT::compileCheckIdent(Node* node)</span>
 7251 {
<a name="145" id="anc145"></a><span class="line-modified"> 7252     SpeculateCellOperand stringOrSymbol(this, node-&gt;child1());</span>
<span class="line-modified"> 7253     GPRTemporary impl(this);</span>
<span class="line-added"> 7254     GPRReg stringOrSymbolGPR = stringOrSymbol.gpr();</span>
<span class="line-added"> 7255     GPRReg implGPR = impl.gpr();</span>
 7256 
<a name="146" id="anc146"></a><span class="line-modified"> 7257     if (node-&gt;child1().useKind() == StringIdentUse) {</span>
<span class="line-modified"> 7258         speculateString(node-&gt;child1(), stringOrSymbolGPR);</span>
<span class="line-modified"> 7259         speculateStringIdentAndLoadStorage(node-&gt;child1(), stringOrSymbolGPR, implGPR);</span>
<span class="line-modified"> 7260     } else {</span>
<span class="line-modified"> 7261         ASSERT(node-&gt;child1().useKind() == SymbolUse);</span>
<span class="line-added"> 7262         speculateSymbol(node-&gt;child1(), stringOrSymbolGPR);</span>
<span class="line-added"> 7263         m_jit.loadPtr(MacroAssembler::Address(stringOrSymbolGPR, Symbol::offsetOfSymbolImpl()), implGPR);</span>
<span class="line-added"> 7264     }</span>
 7265 
 7266     UniquedStringImpl* uid = node-&gt;uidOperand();
 7267     speculationCheck(
 7268         BadIdent, JSValueSource(), nullptr,
<a name="147" id="anc147"></a><span class="line-modified"> 7269         m_jit.branchPtr(JITCompiler::NotEqual, implGPR, TrustedImmPtr(uid)));</span>
 7270     noResult(node);
 7271 }
 7272 
 7273 template &lt;typename ClassType&gt;
 7274 void SpeculativeJIT::compileNewFunctionCommon(GPRReg resultGPR, RegisteredStructure structure, GPRReg scratch1GPR, GPRReg scratch2GPR, GPRReg scopeGPR, MacroAssembler::JumpList&amp; slowPath, size_t size, FunctionExecutable* executable)
 7275 {
 7276     auto butterfly = TrustedImmPtr(nullptr);
 7277     emitAllocateJSObjectWithKnownSize&lt;ClassType&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowPath, size);
 7278 
 7279     m_jit.storePtr(scopeGPR, JITCompiler::Address(resultGPR, JSFunction::offsetOfScopeChain()));
<a name="148" id="anc148"></a><span class="line-modified"> 7280     m_jit.storePtr(TrustedImmPtr::weakPointer(m_jit.graph(), executable), JITCompiler::Address(resultGPR, JSFunction::offsetOfExecutableOrRareData()));</span>
<span class="line-modified"> 7281     m_jit.mutatorFence(vm());</span>























 7282 }
 7283 
 7284 void SpeculativeJIT::compileNewFunction(Node* node)
 7285 {
 7286     NodeType nodeType = node-&gt;op();
 7287     ASSERT(nodeType == NewFunction || nodeType == NewGeneratorFunction || nodeType == NewAsyncFunction || nodeType == NewAsyncGeneratorFunction);
 7288 
 7289     SpeculateCellOperand scope(this, node-&gt;child1());
 7290     GPRReg scopeGPR = scope.gpr();
 7291 
 7292     FunctionExecutable* executable = node-&gt;castOperand&lt;FunctionExecutable*&gt;();
 7293 
 7294     if (executable-&gt;singleton().isStillValid()) {
 7295         GPRFlushedCallResult result(this);
 7296         GPRReg resultGPR = result.gpr();
 7297 
 7298         flushRegisters();
 7299 
 7300         if (nodeType == NewGeneratorFunction)
<a name="149" id="anc149"></a><span class="line-modified"> 7301             callOperation(operationNewGeneratorFunction, resultGPR, &amp;vm(), scopeGPR, executable);</span>
 7302         else if (nodeType == NewAsyncFunction)
<a name="150" id="anc150"></a><span class="line-modified"> 7303             callOperation(operationNewAsyncFunction, resultGPR, &amp;vm(), scopeGPR, executable);</span>
 7304         else if (nodeType == NewAsyncGeneratorFunction)
<a name="151" id="anc151"></a><span class="line-modified"> 7305             callOperation(operationNewAsyncGeneratorFunction, resultGPR, &amp;vm(), scopeGPR, executable);</span>
 7306         else
<a name="152" id="anc152"></a><span class="line-modified"> 7307             callOperation(operationNewFunction, resultGPR, &amp;vm(), scopeGPR, executable);</span>
 7308         m_jit.exceptionCheck();
 7309         cellResult(resultGPR, node);
 7310         return;
 7311     }
 7312 
 7313     RegisteredStructure structure = m_jit.graph().registerStructure(
 7314         [&amp;] () {
 7315             JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 7316             switch (nodeType) {
 7317             case NewGeneratorFunction:
 7318                 return globalObject-&gt;generatorFunctionStructure();
 7319             case NewAsyncFunction:
 7320                 return globalObject-&gt;asyncFunctionStructure();
 7321             case NewAsyncGeneratorFunction:
 7322                 return globalObject-&gt;asyncGeneratorFunctionStructure();
 7323             case NewFunction:
 7324                 return JSFunction::selectStructureForNewFuncExp(globalObject, node-&gt;castOperand&lt;FunctionExecutable*&gt;());
 7325             default:
 7326                 RELEASE_ASSERT_NOT_REACHED();
 7327             }
 7328         }());
 7329 
 7330     GPRTemporary result(this);
 7331     GPRTemporary scratch1(this);
 7332     GPRTemporary scratch2(this);
 7333 
 7334     GPRReg resultGPR = result.gpr();
 7335     GPRReg scratch1GPR = scratch1.gpr();
 7336     GPRReg scratch2GPR = scratch2.gpr();
 7337 
 7338     JITCompiler::JumpList slowPath;
 7339 
 7340     if (nodeType == NewFunction) {
 7341         compileNewFunctionCommon&lt;JSFunction&gt;(resultGPR, structure, scratch1GPR, scratch2GPR, scopeGPR, slowPath, JSFunction::allocationSize(0), executable);
 7342 
<a name="153" id="anc153"></a><span class="line-modified"> 7343         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewFunctionWithInvalidatedReallocationWatchpoint, resultGPR, &amp;vm(), scopeGPR, executable));</span>
 7344     }
 7345 
 7346     if (nodeType == NewGeneratorFunction) {
 7347         compileNewFunctionCommon&lt;JSGeneratorFunction&gt;(resultGPR, structure, scratch1GPR, scratch2GPR, scopeGPR, slowPath, JSGeneratorFunction::allocationSize(0), executable);
 7348 
<a name="154" id="anc154"></a><span class="line-modified"> 7349         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewGeneratorFunctionWithInvalidatedReallocationWatchpoint, resultGPR, &amp;vm(), scopeGPR, executable));</span>
 7350     }
 7351 
 7352     if (nodeType == NewAsyncFunction) {
 7353         compileNewFunctionCommon&lt;JSAsyncFunction&gt;(resultGPR, structure, scratch1GPR, scratch2GPR, scopeGPR, slowPath, JSAsyncFunction::allocationSize(0), executable);
 7354 
<a name="155" id="anc155"></a><span class="line-modified"> 7355         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewAsyncFunctionWithInvalidatedReallocationWatchpoint, resultGPR, &amp;vm(), scopeGPR, executable));</span>
 7356     }
 7357 
 7358     if (nodeType == NewAsyncGeneratorFunction) {
 7359         compileNewFunctionCommon&lt;JSAsyncGeneratorFunction&gt;(resultGPR, structure, scratch1GPR, scratch2GPR, scopeGPR, slowPath, JSAsyncGeneratorFunction::allocationSize(0), executable);
 7360 
<a name="156" id="anc156"></a><span class="line-modified"> 7361         addSlowPathGenerator(slowPathCall(slowPath, this, operationNewAsyncGeneratorFunctionWithInvalidatedReallocationWatchpoint, resultGPR, &amp;vm(), scopeGPR, executable));</span>
 7362     }
 7363 
 7364     cellResult(resultGPR, node);
 7365 }
 7366 
 7367 void SpeculativeJIT::compileSetFunctionName(Node* node)
 7368 {
 7369     SpeculateCellOperand func(this, node-&gt;child1());
 7370     GPRReg funcGPR = func.gpr();
 7371     JSValueOperand nameValue(this, node-&gt;child2());
 7372     JSValueRegs nameValueRegs = nameValue.jsValueRegs();
 7373 
 7374     flushRegisters();
<a name="157" id="anc157"></a><span class="line-modified"> 7375     callOperation(operationSetFunctionName, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), funcGPR, nameValueRegs);</span>
 7376     m_jit.exceptionCheck();
 7377 
 7378     noResult(node);
 7379 }
 7380 
<a name="158" id="anc158"></a><span class="line-modified"> 7381 void SpeculativeJIT::compileVarargsLength(Node* node)</span>
 7382 {
 7383     LoadVarargsData* data = node-&gt;loadVarargsData();
 7384 
 7385     JSValueRegs argumentsRegs;
<a name="159" id="anc159"></a><span class="line-modified"> 7386     lock(GPRInfo::returnValueGPR);</span>
<span class="line-modified"> 7387     JSValueOperand arguments(this, node-&gt;argumentsChild());</span>
<span class="line-modified"> 7388     argumentsRegs = arguments.jsValueRegs();</span>
<span class="line-modified"> 7389     flushRegisters();</span>
<span class="line-modified"> 7390     unlock(GPRInfo::returnValueGPR);</span>
 7391 
<a name="160" id="anc160"></a><span class="line-modified"> 7392     callOperation(operationSizeOfVarargs, GPRInfo::returnValueGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentsRegs, data-&gt;offset);</span>
 7393     m_jit.exceptionCheck();
 7394 
 7395     lock(GPRInfo::returnValueGPR);
<a name="161" id="anc161"></a><span class="line-modified"> 7396     GPRTemporary argCountIncludingThis(this);</span>
<span class="line-modified"> 7397     GPRReg argCountIncludingThisGPR = argCountIncludingThis.gpr();</span>



 7398     unlock(GPRInfo::returnValueGPR);
 7399 
<a name="162" id="anc162"></a><span class="line-modified"> 7400     m_jit.add32(TrustedImm32(1), GPRInfo::returnValueGPR, argCountIncludingThisGPR);</span>
<span class="line-modified"> 7401 </span>
<span class="line-modified"> 7402     int32Result(argCountIncludingThisGPR, node);</span>
<span class="line-modified"> 7403 }</span>

 7404 
<a name="163" id="anc163"></a><span class="line-modified"> 7405 void SpeculativeJIT::compileLoadVarargs(Node* node)</span>
<span class="line-modified"> 7406 {</span>
<span class="line-added"> 7407     LoadVarargsData* data = node-&gt;loadVarargsData();</span>
 7408 
<a name="164" id="anc164"></a><span class="line-modified"> 7409     SpeculateStrictInt32Operand argumentCount(this, node-&gt;child1());</span>
<span class="line-added"> 7410     JSValueOperand arguments(this, node-&gt;argumentsChild());</span>
<span class="line-added"> 7411     GPRReg argumentCountIncludingThis = argumentCount.gpr();</span>
<span class="line-added"> 7412     JSValueRegs argumentsRegs = arguments.jsValueRegs();</span>
 7413 
 7414     speculationCheck(
<a name="165" id="anc165"></a><span class="line-modified"> 7415         VarargsOverflow, JSValueSource(), Edge(), m_jit.branchTest32(</span>
<span class="line-modified"> 7416             MacroAssembler::Zero,</span>
<span class="line-modified"> 7417             argumentCountIncludingThis));</span>

 7418 
 7419     speculationCheck(
 7420         VarargsOverflow, JSValueSource(), Edge(), m_jit.branch32(
 7421             MacroAssembler::Above,
<a name="166" id="anc166"></a><span class="line-modified"> 7422             argumentCountIncludingThis,</span>
 7423             TrustedImm32(data-&gt;limit)));
 7424 
<a name="167" id="anc167"></a><span class="line-modified"> 7425     flushRegisters();</span>
<span class="line-added"> 7426 </span>
<span class="line-added"> 7427     m_jit.store32(argumentCountIncludingThis, JITCompiler::payloadFor(data-&gt;machineCount));</span>
 7428 
<a name="168" id="anc168"></a><span class="line-modified"> 7429     callOperation(operationLoadVarargs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), data-&gt;machineStart.offset(), argumentsRegs, data-&gt;offset, argumentCountIncludingThis, data-&gt;mandatoryMinimum);</span>
 7430     m_jit.exceptionCheck();
 7431 
 7432     noResult(node);
 7433 }
 7434 
 7435 void SpeculativeJIT::compileForwardVarargs(Node* node)
 7436 {
 7437     LoadVarargsData* data = node-&gt;loadVarargsData();
 7438     InlineCallFrame* inlineCallFrame;
<a name="169" id="anc169"></a><span class="line-modified"> 7439     if (node-&gt;argumentsChild())</span>
<span class="line-modified"> 7440         inlineCallFrame = node-&gt;argumentsChild()-&gt;origin.semantic.inlineCallFrame();</span>
 7441     else
 7442         inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();
 7443 
<a name="170" id="anc170"></a><span class="line-added"> 7444     SpeculateStrictInt32Operand argumentCount(this, node-&gt;child1());</span>
 7445     GPRTemporary length(this);
 7446     JSValueRegsTemporary temp(this);
<a name="171" id="anc171"></a><span class="line-modified"> 7447     GPRReg argumentCountIncludingThis = argumentCount.gpr();</span>
<span class="line-added"> 7448     GPRReg lengthGPR = argumentCount.gpr();</span>
 7449     JSValueRegs tempRegs = temp.regs();
 7450 
<a name="172" id="anc172"></a><span class="line-modified"> 7451     m_jit.move(argumentCountIncludingThis, lengthGPR);</span>
 7452     if (data-&gt;offset)
 7453         m_jit.sub32(TrustedImm32(data-&gt;offset), lengthGPR);
 7454 
 7455     speculationCheck(
 7456         VarargsOverflow, JSValueSource(), Edge(), m_jit.branch32(
 7457             MacroAssembler::Above,
 7458             lengthGPR, TrustedImm32(data-&gt;limit)));
 7459 
 7460     m_jit.store32(lengthGPR, JITCompiler::payloadFor(data-&gt;machineCount));
 7461 
 7462     VirtualRegister sourceStart = JITCompiler::argumentsStart(inlineCallFrame) + data-&gt;offset;
 7463     VirtualRegister targetStart = data-&gt;machineStart;
 7464 
 7465     m_jit.sub32(TrustedImm32(1), lengthGPR);
 7466 
 7467     // First have a loop that fills in the undefined slots in case of an arity check failure.
 7468     m_jit.move(TrustedImm32(data-&gt;mandatoryMinimum), tempRegs.payloadGPR());
 7469     JITCompiler::Jump done = m_jit.branch32(JITCompiler::BelowOrEqual, tempRegs.payloadGPR(), lengthGPR);
 7470 
 7471     JITCompiler::Label loop = m_jit.label();
 7472     m_jit.sub32(TrustedImm32(1), tempRegs.payloadGPR());
 7473     m_jit.storeTrustedValue(
 7474         jsUndefined(),
 7475         JITCompiler::BaseIndex(
 7476             GPRInfo::callFrameRegister, tempRegs.payloadGPR(), JITCompiler::TimesEight,
 7477             targetStart.offset() * sizeof(EncodedJSValue)));
 7478     m_jit.branch32(JITCompiler::Above, tempRegs.payloadGPR(), lengthGPR).linkTo(loop, &amp;m_jit);
 7479     done.link(&amp;m_jit);
 7480 
 7481     // And then fill in the actual argument values.
 7482     done = m_jit.branchTest32(JITCompiler::Zero, lengthGPR);
 7483 
 7484     loop = m_jit.label();
 7485     m_jit.sub32(TrustedImm32(1), lengthGPR);
 7486     m_jit.loadValue(
 7487         JITCompiler::BaseIndex(
 7488             GPRInfo::callFrameRegister, lengthGPR, JITCompiler::TimesEight,
 7489             sourceStart.offset() * sizeof(EncodedJSValue)),
 7490         tempRegs);
 7491     m_jit.storeValue(
 7492         tempRegs,
 7493         JITCompiler::BaseIndex(
 7494             GPRInfo::callFrameRegister, lengthGPR, JITCompiler::TimesEight,
 7495             targetStart.offset() * sizeof(EncodedJSValue)));
 7496     m_jit.branchTest32(JITCompiler::NonZero, lengthGPR).linkTo(loop, &amp;m_jit);
 7497 
 7498     done.link(&amp;m_jit);
 7499 
 7500     noResult(node);
 7501 }
 7502 
 7503 void SpeculativeJIT::compileCreateActivation(Node* node)
 7504 {
 7505     SymbolTable* table = node-&gt;castOperand&lt;SymbolTable*&gt;();
 7506     RegisteredStructure structure = m_jit.graph().registerStructure(m_jit.graph().globalObjectFor(
 7507         node-&gt;origin.semantic)-&gt;activationStructure());
 7508 
 7509     SpeculateCellOperand scope(this, node-&gt;child1());
 7510     GPRReg scopeGPR = scope.gpr();
 7511     JSValue initializationValue = node-&gt;initializationValueForActivation();
 7512     ASSERT(initializationValue == jsUndefined() || initializationValue == jsTDZValue());
 7513 
 7514     if (table-&gt;singleton().isStillValid()) {
 7515         GPRFlushedCallResult result(this);
 7516         GPRReg resultGPR = result.gpr();
 7517 
 7518 #if USE(JSVALUE32_64)
 7519         JSValueRegsTemporary initialization(this);
 7520         JSValueRegs initializationRegs = initialization.regs();
 7521         m_jit.moveTrustedValue(initializationValue, initializationRegs);
 7522 #endif
 7523 
 7524         flushRegisters();
 7525 
 7526 #if USE(JSVALUE64)
 7527         callOperation(operationCreateActivationDirect,
<a name="173" id="anc173"></a><span class="line-modified"> 7528             resultGPR, &amp;vm(), structure, scopeGPR, table, TrustedImm64(JSValue::encode(initializationValue)));</span>
 7529 #else
 7530         callOperation(operationCreateActivationDirect,
<a name="174" id="anc174"></a><span class="line-modified"> 7531             resultGPR, &amp;vm(), structure, scopeGPR, table, initializationRegs);</span>
 7532 #endif
 7533         m_jit.exceptionCheck();
 7534         cellResult(resultGPR, node);
 7535         return;
 7536     }
 7537 
 7538     GPRTemporary result(this);
 7539     GPRTemporary scratch1(this);
 7540     GPRTemporary scratch2(this);
 7541     GPRReg resultGPR = result.gpr();
 7542     GPRReg scratch1GPR = scratch1.gpr();
 7543     GPRReg scratch2GPR = scratch2.gpr();
 7544 
 7545 #if USE(JSVALUE32_64)
 7546     JSValueRegsTemporary initialization(this);
 7547     JSValueRegs initializationRegs = initialization.regs();
 7548     m_jit.moveTrustedValue(initializationValue, initializationRegs);
 7549 #endif
 7550 
 7551     JITCompiler::JumpList slowPath;
 7552     auto butterfly = TrustedImmPtr(nullptr);
 7553     emitAllocateJSObjectWithKnownSize&lt;JSLexicalEnvironment&gt;(
 7554         resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR,
 7555         slowPath, JSLexicalEnvironment::allocationSize(table));
 7556 
 7557     // Don&#39;t need a memory barriers since we just fast-created the activation, so the
 7558     // activation must be young.
 7559     m_jit.storePtr(scopeGPR, JITCompiler::Address(resultGPR, JSScope::offsetOfNext()));
 7560     m_jit.storePtr(
 7561         TrustedImmPtr(node-&gt;cellOperand()),
 7562         JITCompiler::Address(resultGPR, JSLexicalEnvironment::offsetOfSymbolTable()));
 7563 
 7564     // Must initialize all members to undefined or the TDZ empty value.
 7565     for (unsigned i = 0; i &lt; table-&gt;scopeSize(); ++i) {
 7566         m_jit.storeTrustedValue(
 7567             initializationValue,
 7568             JITCompiler::Address(
 7569                 resultGPR, JSLexicalEnvironment::offsetOfVariable(ScopeOffset(i))));
 7570     }
 7571 
 7572     m_jit.mutatorFence(vm());
 7573 
 7574 #if USE(JSVALUE64)
 7575     addSlowPathGenerator(
 7576         slowPathCall(
<a name="175" id="anc175"></a><span class="line-modified"> 7577             slowPath, this, operationCreateActivationDirect, resultGPR, &amp;vm(), structure, scopeGPR, table, TrustedImm64(JSValue::encode(initializationValue))));</span>
 7578 #else
 7579     addSlowPathGenerator(
 7580         slowPathCall(
<a name="176" id="anc176"></a><span class="line-modified"> 7581             slowPath, this, operationCreateActivationDirect, resultGPR, &amp;vm(), structure, scopeGPR, table, initializationRegs));</span>
 7582 #endif
 7583 
 7584     cellResult(resultGPR, node);
 7585 }
 7586 
 7587 void SpeculativeJIT::compileCreateDirectArguments(Node* node)
 7588 {
 7589     // FIXME: A more effective way of dealing with the argument count and callee is to have
 7590     // them be explicit arguments to this node.
 7591     // https://bugs.webkit.org/show_bug.cgi?id=142207
 7592 
 7593     GPRTemporary result(this);
 7594     GPRTemporary scratch1(this);
 7595     GPRTemporary scratch2(this);
 7596     GPRTemporary length;
 7597     GPRReg resultGPR = result.gpr();
 7598     GPRReg scratch1GPR = scratch1.gpr();
 7599     GPRReg scratch2GPR = scratch2.gpr();
 7600     GPRReg lengthGPR = InvalidGPRReg;
 7601     JSValueRegs valueRegs = JSValueRegs::withTwoAvailableRegs(scratch1GPR, scratch2GPR);
 7602 
 7603     unsigned minCapacity = m_jit.graph().baselineCodeBlockFor(node-&gt;origin.semantic)-&gt;numParameters() - 1;
 7604 
 7605     unsigned knownLength;
 7606     bool lengthIsKnown; // if false, lengthGPR will have the length.
 7607     auto* inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();
 7608     if (inlineCallFrame
 7609         &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {
<a name="177" id="anc177"></a><span class="line-modified"> 7610         knownLength = static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1);</span>
 7611         lengthIsKnown = true;
 7612     } else {
 7613         knownLength = UINT_MAX;
 7614         lengthIsKnown = false;
 7615 
 7616         GPRTemporary realLength(this);
 7617         length.adopt(realLength);
 7618         lengthGPR = length.gpr();
 7619 
 7620         VirtualRegister argumentCountRegister = m_jit.argumentCount(node-&gt;origin.semantic);
 7621         m_jit.load32(JITCompiler::payloadFor(argumentCountRegister), lengthGPR);
 7622         m_jit.sub32(TrustedImm32(1), lengthGPR);
 7623     }
 7624 
 7625     RegisteredStructure structure =
 7626         m_jit.graph().registerStructure(m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;directArgumentsStructure());
 7627 
 7628     // Use a different strategy for allocating the object depending on whether we know its
 7629     // size statically.
 7630     JITCompiler::JumpList slowPath;
 7631     if (lengthIsKnown) {
 7632         auto butterfly = TrustedImmPtr(nullptr);
 7633         emitAllocateJSObjectWithKnownSize&lt;DirectArguments&gt;(
 7634             resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR,
 7635             slowPath, DirectArguments::allocationSize(std::max(knownLength, minCapacity)));
 7636 
 7637         m_jit.store32(
 7638             TrustedImm32(knownLength),
 7639             JITCompiler::Address(resultGPR, DirectArguments::offsetOfLength()));
 7640     } else {
 7641         JITCompiler::Jump tooFewArguments;
 7642         if (minCapacity) {
 7643             tooFewArguments =
 7644                 m_jit.branch32(JITCompiler::Below, lengthGPR, TrustedImm32(minCapacity));
 7645         }
 7646         m_jit.lshift32(lengthGPR, TrustedImm32(3), scratch1GPR);
 7647         m_jit.add32(TrustedImm32(DirectArguments::storageOffset()), scratch1GPR);
 7648         if (minCapacity) {
 7649             JITCompiler::Jump done = m_jit.jump();
 7650             tooFewArguments.link(&amp;m_jit);
 7651             m_jit.move(TrustedImm32(DirectArguments::allocationSize(minCapacity)), scratch1GPR);
 7652             done.link(&amp;m_jit);
 7653         }
 7654 
 7655         emitAllocateVariableSizedJSObject&lt;DirectArguments&gt;(
 7656             resultGPR, TrustedImmPtr(structure), scratch1GPR, scratch1GPR, scratch2GPR,
 7657             slowPath);
 7658 
 7659         m_jit.store32(
 7660             lengthGPR, JITCompiler::Address(resultGPR, DirectArguments::offsetOfLength()));
 7661     }
 7662 
 7663     m_jit.store32(
 7664         TrustedImm32(minCapacity),
 7665         JITCompiler::Address(resultGPR, DirectArguments::offsetOfMinCapacity()));
 7666 
 7667     m_jit.storePtr(
 7668         TrustedImmPtr(nullptr), JITCompiler::Address(resultGPR, DirectArguments::offsetOfMappedArguments()));
 7669 
 7670     m_jit.storePtr(
 7671         TrustedImmPtr(nullptr), JITCompiler::Address(resultGPR, DirectArguments::offsetOfModifiedArgumentsDescriptor()));
 7672 
 7673     if (lengthIsKnown) {
 7674         addSlowPathGenerator(
 7675             slowPathCall(
<a name="178" id="anc178"></a><span class="line-modified"> 7676                 slowPath, this, operationCreateDirectArguments, resultGPR, &amp;vm(), structure,</span>
 7677                 knownLength, minCapacity));
 7678     } else {
 7679         auto generator = makeUnique&lt;CallCreateDirectArgumentsSlowPathGenerator&gt;(
 7680             slowPath, this, resultGPR, structure, lengthGPR, minCapacity);
 7681         addSlowPathGenerator(WTFMove(generator));
 7682     }
 7683 
 7684     if (inlineCallFrame) {
 7685         if (inlineCallFrame-&gt;isClosureCall) {
 7686             m_jit.loadPtr(
 7687                 JITCompiler::addressFor(
 7688                     inlineCallFrame-&gt;calleeRecovery.virtualRegister()),
 7689                 scratch1GPR);
 7690         } else {
 7691             m_jit.move(
 7692                 TrustedImmPtr::weakPointer(
 7693                     m_jit.graph(), inlineCallFrame-&gt;calleeRecovery.constant().asCell()),
 7694                 scratch1GPR);
 7695         }
 7696     } else
 7697         m_jit.loadPtr(JITCompiler::addressFor(CallFrameSlot::callee), scratch1GPR);
 7698 
 7699     // Don&#39;t need a memory barriers since we just fast-created the activation, so the
 7700     // activation must be young.
 7701     m_jit.storePtr(
 7702         scratch1GPR, JITCompiler::Address(resultGPR, DirectArguments::offsetOfCallee()));
 7703 
 7704     VirtualRegister start = m_jit.argumentsStart(node-&gt;origin.semantic);
 7705     if (lengthIsKnown) {
 7706         for (unsigned i = 0; i &lt; std::max(knownLength, minCapacity); ++i) {
 7707             m_jit.loadValue(JITCompiler::addressFor(start + i), valueRegs);
 7708             m_jit.storeValue(
 7709                 valueRegs, JITCompiler::Address(resultGPR, DirectArguments::offsetOfSlot(i)));
 7710         }
 7711     } else {
 7712         JITCompiler::Jump done;
 7713         if (minCapacity) {
 7714             JITCompiler::Jump startLoop = m_jit.branch32(
 7715                 JITCompiler::AboveOrEqual, lengthGPR, TrustedImm32(minCapacity));
 7716             m_jit.move(TrustedImm32(minCapacity), lengthGPR);
 7717             startLoop.link(&amp;m_jit);
 7718         } else
 7719             done = m_jit.branchTest32(MacroAssembler::Zero, lengthGPR);
 7720         JITCompiler::Label loop = m_jit.label();
 7721         m_jit.sub32(TrustedImm32(1), lengthGPR);
 7722         m_jit.loadValue(
 7723             JITCompiler::BaseIndex(
 7724                 GPRInfo::callFrameRegister, lengthGPR, JITCompiler::TimesEight,
 7725                 start.offset() * static_cast&lt;int&gt;(sizeof(Register))),
 7726             valueRegs);
 7727         m_jit.storeValue(
 7728             valueRegs,
 7729             JITCompiler::BaseIndex(
 7730                 resultGPR, lengthGPR, JITCompiler::TimesEight,
 7731                 DirectArguments::storageOffset()));
 7732         m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loop, &amp;m_jit);
 7733         if (done.isSet())
 7734             done.link(&amp;m_jit);
 7735     }
 7736 
 7737     m_jit.mutatorFence(vm());
 7738 
 7739     cellResult(resultGPR, node);
 7740 }
 7741 
 7742 void SpeculativeJIT::compileGetFromArguments(Node* node)
 7743 {
 7744     SpeculateCellOperand arguments(this, node-&gt;child1());
 7745     JSValueRegsTemporary result(this);
 7746 
 7747     GPRReg argumentsGPR = arguments.gpr();
 7748     JSValueRegs resultRegs = result.regs();
 7749 
 7750     m_jit.loadValue(JITCompiler::Address(argumentsGPR, DirectArguments::offsetOfSlot(node-&gt;capturedArgumentsOffset().offset())), resultRegs);
 7751     jsValueResult(resultRegs, node);
 7752 }
 7753 
 7754 void SpeculativeJIT::compilePutToArguments(Node* node)
 7755 {
 7756     SpeculateCellOperand arguments(this, node-&gt;child1());
 7757     JSValueOperand value(this, node-&gt;child2());
 7758 
 7759     GPRReg argumentsGPR = arguments.gpr();
 7760     JSValueRegs valueRegs = value.jsValueRegs();
 7761 
 7762     m_jit.storeValue(valueRegs, JITCompiler::Address(argumentsGPR, DirectArguments::offsetOfSlot(node-&gt;capturedArgumentsOffset().offset())));
 7763     noResult(node);
 7764 }
 7765 
 7766 void SpeculativeJIT::compileGetArgument(Node* node)
 7767 {
 7768     GPRTemporary argumentCount(this);
 7769     JSValueRegsTemporary result(this);
 7770     GPRReg argumentCountGPR = argumentCount.gpr();
 7771     JSValueRegs resultRegs = result.regs();
 7772     m_jit.load32(CCallHelpers::payloadFor(m_jit.argumentCount(node-&gt;origin.semantic)), argumentCountGPR);
 7773     auto argumentOutOfBounds = m_jit.branch32(CCallHelpers::LessThanOrEqual, argumentCountGPR, CCallHelpers::TrustedImm32(node-&gt;argumentIndex()));
 7774     m_jit.loadValue(CCallHelpers::addressFor(CCallHelpers::argumentsStart(node-&gt;origin.semantic) + node-&gt;argumentIndex() - 1), resultRegs);
 7775     auto done = m_jit.jump();
 7776 
 7777     argumentOutOfBounds.link(&amp;m_jit);
 7778     m_jit.moveValue(jsUndefined(), resultRegs);
 7779 
 7780     done.link(&amp;m_jit);
 7781     jsValueResult(resultRegs, node);
 7782 }
 7783 
 7784 void SpeculativeJIT::compileCreateScopedArguments(Node* node)
 7785 {
 7786     SpeculateCellOperand scope(this, node-&gt;child1());
 7787     GPRReg scopeGPR = scope.gpr();
 7788 
 7789     GPRFlushedCallResult result(this);
 7790     GPRReg resultGPR = result.gpr();
 7791     flushRegisters();
 7792 
<a name="179" id="anc179"></a><span class="line-added"> 7793     JSGlobalObject* globalObject = m_jit.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="line-added"> 7794 </span>
 7795     // We set up the arguments ourselves, because we have the whole register file and we can
 7796     // set them up directly into the argument registers. This also means that we don&#39;t have to
 7797     // invent a four-argument-register shuffle.
 7798 
<a name="180" id="anc180"></a><span class="line-modified"> 7799     // Arguments: 0:JSGlobalObject*, 1:structure, 2:start, 3:length, 4:callee, 5:scope</span>
 7800 
 7801     // Do the scopeGPR first, since it might alias an argument register.
 7802     m_jit.setupArgument(5, [&amp;] (GPRReg destGPR) { m_jit.move(scopeGPR, destGPR); });
 7803 
 7804     // These other things could be done in any order.
 7805     m_jit.setupArgument(4, [&amp;] (GPRReg destGPR) { emitGetCallee(node-&gt;origin.semantic, destGPR); });
 7806     m_jit.setupArgument(3, [&amp;] (GPRReg destGPR) { emitGetLength(node-&gt;origin.semantic, destGPR); });
 7807     m_jit.setupArgument(2, [&amp;] (GPRReg destGPR) { emitGetArgumentStart(node-&gt;origin.semantic, destGPR); });
 7808     m_jit.setupArgument(
 7809         1, [&amp;] (GPRReg destGPR) {
 7810             m_jit.move(
<a name="181" id="anc181"></a><span class="line-modified"> 7811                 TrustedImmPtr::weakPointer(m_jit.graph(), globalObject-&gt;scopedArgumentsStructure()),</span>
 7812                 destGPR);
 7813         });
<a name="182" id="anc182"></a><span class="line-modified"> 7814     m_jit.setupArgument(0, [&amp;] (GPRReg destGPR) { m_jit.move(TrustedImmPtr::weakPointer(m_graph, globalObject), destGPR); });</span>
 7815 
 7816     appendCallSetResult(operationCreateScopedArguments, resultGPR);
 7817     m_jit.exceptionCheck();
 7818 
 7819     cellResult(resultGPR, node);
 7820 }
 7821 
 7822 void SpeculativeJIT::compileCreateClonedArguments(Node* node)
 7823 {
 7824     GPRFlushedCallResult result(this);
 7825     GPRReg resultGPR = result.gpr();
 7826     flushRegisters();
 7827 
<a name="183" id="anc183"></a><span class="line-added"> 7828     JSGlobalObject* globalObject = m_jit.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="line-added"> 7829 </span>
 7830     // We set up the arguments ourselves, because we have the whole register file and we can
 7831     // set them up directly into the argument registers.
 7832 
<a name="184" id="anc184"></a><span class="line-modified"> 7833     // Arguments: 0:JSGlobalObject*, 1:structure, 2:start, 3:length, 4:callee</span>
 7834     m_jit.setupArgument(4, [&amp;] (GPRReg destGPR) { emitGetCallee(node-&gt;origin.semantic, destGPR); });
 7835     m_jit.setupArgument(3, [&amp;] (GPRReg destGPR) { emitGetLength(node-&gt;origin.semantic, destGPR); });
 7836     m_jit.setupArgument(2, [&amp;] (GPRReg destGPR) { emitGetArgumentStart(node-&gt;origin.semantic, destGPR); });
 7837     m_jit.setupArgument(
 7838         1, [&amp;] (GPRReg destGPR) {
 7839             m_jit.move(
 7840                 TrustedImmPtr::weakPointer(
<a name="185" id="anc185"></a><span class="line-modified"> 7841                     m_jit.graph(), globalObject-&gt;clonedArgumentsStructure()),</span>
 7842                 destGPR);
 7843         });
<a name="186" id="anc186"></a><span class="line-modified"> 7844     m_jit.setupArgument(0, [&amp;] (GPRReg destGPR) { m_jit.move(TrustedImmPtr::weakPointer(m_graph, globalObject), destGPR); });</span>
 7845 
 7846     appendCallSetResult(operationCreateClonedArguments, resultGPR);
 7847     m_jit.exceptionCheck();
 7848 
 7849     cellResult(resultGPR, node);
 7850 }
 7851 
<a name="187" id="anc187"></a><span class="line-added"> 7852 void SpeculativeJIT::compileCreateArgumentsButterfly(Node* node)</span>
<span class="line-added"> 7853 {</span>
<span class="line-added"> 7854     GPRFlushedCallResult result(this);</span>
<span class="line-added"> 7855     GPRReg resultGPR = result.gpr();</span>
<span class="line-added"> 7856     flushRegisters();</span>
<span class="line-added"> 7857 </span>
<span class="line-added"> 7858     JSGlobalObject* globalObject = m_jit.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="line-added"> 7859 </span>
<span class="line-added"> 7860     // We set up the arguments ourselves, because we have the whole register file and we can</span>
<span class="line-added"> 7861     // set them up directly into the argument registers.</span>
<span class="line-added"> 7862 </span>
<span class="line-added"> 7863     // Arguments: 0:JSGlobalObject*, 1:start, 3:length</span>
<span class="line-added"> 7864     m_jit.setupArgument(2, [&amp;] (GPRReg destGPR) { emitGetLength(node-&gt;origin.semantic, destGPR); });</span>
<span class="line-added"> 7865     m_jit.setupArgument(1, [&amp;] (GPRReg destGPR) { emitGetArgumentStart(node-&gt;origin.semantic, destGPR); });</span>
<span class="line-added"> 7866     m_jit.setupArgument(0, [&amp;] (GPRReg destGPR) { m_jit.move(TrustedImmPtr::weakPointer(m_graph, globalObject), destGPR); });</span>
<span class="line-added"> 7867 </span>
<span class="line-added"> 7868     appendCallSetResult(operationCreateArgumentsButterfly, resultGPR);</span>
<span class="line-added"> 7869     m_jit.exceptionCheck();</span>
<span class="line-added"> 7870 </span>
<span class="line-added"> 7871     cellResult(resultGPR, node);</span>
<span class="line-added"> 7872 }</span>
<span class="line-added"> 7873 </span>
 7874 void SpeculativeJIT::compileCreateRest(Node* node)
 7875 {
 7876     ASSERT(node-&gt;op() == CreateRest);
 7877 
<a name="188" id="anc188"></a>
 7878     if (m_jit.graph().isWatchingHavingABadTimeWatchpoint(node)) {
 7879         SpeculateStrictInt32Operand arrayLength(this, node-&gt;child1());
 7880         GPRTemporary arrayResult(this);
 7881 
 7882         GPRReg arrayLengthGPR = arrayLength.gpr();
 7883         GPRReg arrayResultGPR = arrayResult.gpr();
 7884 
 7885         // We can tell compileAllocateNewArrayWithSize() that it does not need to check
 7886         // for large arrays and use ArrayStorage structure because arrayLength here will
 7887         // always be bounded by stack size. Realistically, we won&#39;t be able to push enough
 7888         // arguments to have arrayLength exceed MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH.
 7889         bool shouldAllowForArrayStorageStructureForLargeArrays = false;
<a name="189" id="anc189"></a>
 7890         compileAllocateNewArrayWithSize(m_jit.graph().globalObjectFor(node-&gt;origin.semantic), arrayResultGPR, arrayLengthGPR, ArrayWithContiguous, shouldAllowForArrayStorageStructureForLargeArrays);
 7891 
 7892         GPRTemporary argumentsStart(this);
 7893         GPRReg argumentsStartGPR = argumentsStart.gpr();
 7894 
 7895         emitGetArgumentStart(node-&gt;origin.semantic, argumentsStartGPR);
 7896 
 7897         GPRTemporary butterfly(this);
 7898         GPRTemporary currentLength(this);
 7899         JSValueRegsTemporary value(this);
 7900 
 7901         JSValueRegs valueRegs = value.regs();
 7902         GPRReg currentLengthGPR = currentLength.gpr();
 7903         GPRReg butterflyGPR = butterfly.gpr();
 7904 
 7905         m_jit.loadPtr(MacroAssembler::Address(arrayResultGPR, JSObject::butterflyOffset()), butterflyGPR);
 7906 
 7907         CCallHelpers::Jump skipLoop = m_jit.branch32(MacroAssembler::Equal, arrayLengthGPR, TrustedImm32(0));
 7908         m_jit.zeroExtend32ToPtr(arrayLengthGPR, currentLengthGPR);
 7909         m_jit.addPtr(Imm32(sizeof(Register) * node-&gt;numberOfArgumentsToSkip()), argumentsStartGPR);
 7910 
 7911         auto loop = m_jit.label();
 7912         m_jit.sub32(TrustedImm32(1), currentLengthGPR);
 7913         m_jit.loadValue(JITCompiler::BaseIndex(argumentsStartGPR, currentLengthGPR, MacroAssembler::TimesEight), valueRegs);
 7914         m_jit.storeValue(valueRegs, MacroAssembler::BaseIndex(butterflyGPR, currentLengthGPR, MacroAssembler::TimesEight));
 7915         m_jit.branch32(MacroAssembler::NotEqual, currentLengthGPR, TrustedImm32(0)).linkTo(loop, &amp;m_jit);
 7916 
 7917         skipLoop.link(&amp;m_jit);
 7918         cellResult(arrayResultGPR, node);
 7919         return;
 7920     }
<a name="190" id="anc190"></a>
 7921 
 7922     SpeculateStrictInt32Operand arrayLength(this, node-&gt;child1());
 7923     GPRTemporary argumentsStart(this);
 7924     GPRTemporary numberOfArgumentsToSkip(this);
 7925 
 7926     GPRReg arrayLengthGPR = arrayLength.gpr();
 7927     GPRReg argumentsStartGPR = argumentsStart.gpr();
 7928 
 7929     emitGetArgumentStart(node-&gt;origin.semantic, argumentsStartGPR);
 7930 
 7931     flushRegisters();
 7932 
 7933     GPRFlushedCallResult result(this);
 7934     GPRReg resultGPR = result.gpr();
<a name="191" id="anc191"></a><span class="line-modified"> 7935     callOperation(operationCreateRest, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentsStartGPR, Imm32(node-&gt;numberOfArgumentsToSkip()), arrayLengthGPR);</span>
 7936     m_jit.exceptionCheck();
 7937 
 7938     cellResult(resultGPR, node);
 7939 }
 7940 
 7941 void SpeculativeJIT::compileSpread(Node* node)
 7942 {
 7943     ASSERT(node-&gt;op() == Spread);
 7944 
 7945     SpeculateCellOperand operand(this, node-&gt;child1());
 7946     GPRReg argument = operand.gpr();
 7947 
 7948     if (node-&gt;child1().useKind() == ArrayUse)
 7949         speculateArray(node-&gt;child1(), argument);
 7950 
 7951     if (m_jit.graph().canDoFastSpread(node, m_state.forNode(node-&gt;child1()))) {
 7952 #if USE(JSVALUE64)
 7953         GPRTemporary result(this);
 7954         GPRTemporary scratch1(this);
 7955         GPRTemporary scratch2(this);
 7956         GPRTemporary length(this);
 7957         FPRTemporary doubleRegister(this);
 7958 
 7959         GPRReg resultGPR = result.gpr();
 7960         GPRReg scratch1GPR = scratch1.gpr();
 7961         GPRReg scratch2GPR = scratch2.gpr();
 7962         GPRReg lengthGPR = length.gpr();
 7963         FPRReg doubleFPR = doubleRegister.fpr();
 7964 
 7965         MacroAssembler::JumpList slowPath;
<a name="192" id="anc192"></a><span class="line-added"> 7966         MacroAssembler::JumpList done;</span>
 7967 
 7968         m_jit.load8(MacroAssembler::Address(argument, JSCell::indexingTypeAndMiscOffset()), scratch1GPR);
<a name="193" id="anc193"></a><span class="line-added"> 7969         m_jit.and32(TrustedImm32(IndexingModeMask), scratch1GPR);</span>
<span class="line-added"> 7970         auto notShareCase = m_jit.branch32(CCallHelpers::NotEqual, scratch1GPR, TrustedImm32(CopyOnWriteArrayWithContiguous));</span>
<span class="line-added"> 7971         m_jit.loadPtr(MacroAssembler::Address(argument, JSObject::butterflyOffset()), resultGPR);</span>
<span class="line-added"> 7972         m_jit.addPtr(TrustedImm32(-static_cast&lt;ptrdiff_t&gt;(JSImmutableButterfly::offsetOfData())), resultGPR);</span>
<span class="line-added"> 7973         done.append(m_jit.jump());</span>
<span class="line-added"> 7974 </span>
<span class="line-added"> 7975         notShareCase.link(&amp;m_jit);</span>
 7976         m_jit.and32(TrustedImm32(IndexingShapeMask), scratch1GPR);
 7977         m_jit.sub32(TrustedImm32(Int32Shape), scratch1GPR);
 7978 
 7979         slowPath.append(m_jit.branch32(MacroAssembler::Above, scratch1GPR, TrustedImm32(ContiguousShape - Int32Shape)));
 7980 
 7981         m_jit.loadPtr(MacroAssembler::Address(argument, JSObject::butterflyOffset()), lengthGPR);
 7982         m_jit.load32(MacroAssembler::Address(lengthGPR, Butterfly::offsetOfPublicLength()), lengthGPR);
<a name="194" id="anc194"></a><span class="line-added"> 7983         slowPath.append(m_jit.branch32(MacroAssembler::Above, lengthGPR, TrustedImm32(MAX_STORAGE_VECTOR_LENGTH)));</span>
 7984         static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;This is strongly assumed in the code below.&quot;);
 7985         m_jit.move(lengthGPR, scratch1GPR);
 7986         m_jit.lshift32(TrustedImm32(3), scratch1GPR);
<a name="195" id="anc195"></a><span class="line-modified"> 7987         m_jit.add32(TrustedImm32(JSImmutableButterfly::offsetOfData()), scratch1GPR);</span>
 7988 
<a name="196" id="anc196"></a><span class="line-modified"> 7989         m_jit.emitAllocateVariableSizedCell&lt;JSImmutableButterfly&gt;(vm(), resultGPR, TrustedImmPtr(m_jit.graph().registerStructure(m_jit.graph().m_vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get())), scratch1GPR, scratch1GPR, scratch2GPR, slowPath);</span>
<span class="line-modified"> 7990         m_jit.store32(lengthGPR, MacroAssembler::Address(resultGPR, JSImmutableButterfly::offsetOfPublicLength()));</span>
<span class="line-added"> 7991         m_jit.store32(lengthGPR, MacroAssembler::Address(resultGPR, JSImmutableButterfly::offsetOfVectorLength()));</span>
 7992 
 7993         m_jit.loadPtr(MacroAssembler::Address(argument, JSObject::butterflyOffset()), scratch1GPR);
 7994 
<a name="197" id="anc197"></a>

 7995         m_jit.load8(MacroAssembler::Address(argument, JSCell::indexingTypeAndMiscOffset()), scratch2GPR);
 7996         m_jit.and32(TrustedImm32(IndexingShapeMask), scratch2GPR);
 7997         auto isDoubleArray = m_jit.branch32(MacroAssembler::Equal, scratch2GPR, TrustedImm32(DoubleShape));
 7998 
 7999         {
 8000             done.append(m_jit.branchTest32(MacroAssembler::Zero, lengthGPR));
 8001             auto loopStart = m_jit.label();
 8002             m_jit.sub32(TrustedImm32(1), lengthGPR);
 8003             m_jit.load64(MacroAssembler::BaseIndex(scratch1GPR, lengthGPR, MacroAssembler::TimesEight), scratch2GPR);
 8004             auto notEmpty = m_jit.branchIfNotEmpty(scratch2GPR);
 8005             m_jit.move(TrustedImm64(JSValue::encode(jsUndefined())), scratch2GPR);
 8006             notEmpty.link(&amp;m_jit);
<a name="198" id="anc198"></a><span class="line-modified"> 8007             m_jit.store64(scratch2GPR, MacroAssembler::BaseIndex(resultGPR, lengthGPR, MacroAssembler::TimesEight, JSImmutableButterfly::offsetOfData()));</span>
 8008             m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loopStart, &amp;m_jit);
 8009             done.append(m_jit.jump());
 8010         }
 8011 
 8012         isDoubleArray.link(&amp;m_jit);
 8013         {
 8014             done.append(m_jit.branchTest32(MacroAssembler::Zero, lengthGPR));
 8015             auto loopStart = m_jit.label();
 8016             m_jit.sub32(TrustedImm32(1), lengthGPR);
 8017             m_jit.loadDouble(MacroAssembler::BaseIndex(scratch1GPR, lengthGPR, MacroAssembler::TimesEight), doubleFPR);
 8018             auto notEmpty = m_jit.branchIfNotNaN(doubleFPR);
 8019             m_jit.move(TrustedImm64(JSValue::encode(jsUndefined())), scratch2GPR);
 8020             auto doStore = m_jit.jump();
 8021             notEmpty.link(&amp;m_jit);
 8022             m_jit.boxDouble(doubleFPR, scratch2GPR);
 8023             doStore.link(&amp;m_jit);
<a name="199" id="anc199"></a><span class="line-modified"> 8024             m_jit.store64(scratch2GPR, MacroAssembler::BaseIndex(resultGPR, lengthGPR, MacroAssembler::TimesEight, JSImmutableButterfly::offsetOfData()));</span>
 8025             m_jit.branchTest32(MacroAssembler::NonZero, lengthGPR).linkTo(loopStart, &amp;m_jit);
 8026             done.append(m_jit.jump());
 8027         }
 8028 
<a name="200" id="anc200"></a><span class="line-modified"> 8029         addSlowPathGenerator(slowPathCall(slowPath, this, operationSpreadFastArray, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argument));</span>



 8030 
 8031         done.link(&amp;m_jit);
<a name="201" id="anc201"></a><span class="line-added"> 8032         m_jit.mutatorFence(vm());</span>
 8033         cellResult(resultGPR, node);
 8034 #else
 8035         flushRegisters();
 8036 
 8037         GPRFlushedCallResult result(this);
 8038         GPRReg resultGPR = result.gpr();
<a name="202" id="anc202"></a><span class="line-modified"> 8039         callOperation(operationSpreadFastArray, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argument);</span>
 8040         m_jit.exceptionCheck();
 8041         cellResult(resultGPR, node);
 8042 #endif // USE(JSVALUE64)
 8043     } else {
 8044         flushRegisters();
 8045 
 8046         GPRFlushedCallResult result(this);
 8047         GPRReg resultGPR = result.gpr();
<a name="203" id="anc203"></a><span class="line-modified"> 8048         callOperation(operationSpreadGeneric, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argument);</span>
 8049         m_jit.exceptionCheck();
 8050         cellResult(resultGPR, node);
 8051     }
 8052 }
 8053 
 8054 void SpeculativeJIT::compileNewArray(Node* node)
 8055 {
 8056     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
<a name="204" id="anc204"></a><span class="line-added"> 8057     RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType()));</span>
 8058     if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(node-&gt;indexingType())) {
<a name="205" id="anc205"></a>







 8059         unsigned numElements = node-&gt;numChildren();
 8060         unsigned vectorLengthHint = node-&gt;vectorLengthHint();
 8061         ASSERT(vectorLengthHint &gt;= numElements);
 8062 
 8063         GPRTemporary result(this);
 8064         GPRTemporary storage(this);
 8065 
 8066         GPRReg resultGPR = result.gpr();
 8067         GPRReg storageGPR = storage.gpr();
 8068 
 8069         emitAllocateRawObject(resultGPR, structure, storageGPR, numElements, vectorLengthHint);
 8070 
 8071         // At this point, one way or another, resultGPR and storageGPR have pointers to
 8072         // the JSArray and the Butterfly, respectively.
 8073 
 8074         ASSERT(!hasUndecided(structure-&gt;indexingType()) || !node-&gt;numChildren());
 8075 
 8076         for (unsigned operandIdx = 0; operandIdx &lt; node-&gt;numChildren(); ++operandIdx) {
 8077             Edge use = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + operandIdx];
 8078             switch (node-&gt;indexingType()) {
 8079             case ALL_BLANK_INDEXING_TYPES:
 8080             case ALL_UNDECIDED_INDEXING_TYPES:
 8081                 CRASH();
 8082                 break;
 8083             case ALL_DOUBLE_INDEXING_TYPES: {
 8084                 SpeculateDoubleOperand operand(this, use);
 8085                 FPRReg opFPR = operand.fpr();
 8086                 DFG_TYPE_CHECK(
 8087                     JSValueRegs(), use, SpecDoubleReal,
 8088                     m_jit.branchIfNaN(opFPR));
 8089                 m_jit.storeDouble(opFPR, MacroAssembler::Address(storageGPR, sizeof(double) * operandIdx));
 8090                 break;
 8091             }
 8092             case ALL_INT32_INDEXING_TYPES:
 8093             case ALL_CONTIGUOUS_INDEXING_TYPES: {
 8094                 JSValueOperand operand(this, use, ManualOperandSpeculation);
 8095                 JSValueRegs operandRegs = operand.jsValueRegs();
 8096                 if (hasInt32(node-&gt;indexingType())) {
 8097                     DFG_TYPE_CHECK(
 8098                         operandRegs, use, SpecInt32Only,
 8099                         m_jit.branchIfNotInt32(operandRegs));
 8100                 }
 8101                 m_jit.storeValue(operandRegs, MacroAssembler::Address(storageGPR, sizeof(JSValue) * operandIdx));
 8102                 break;
 8103             }
 8104             default:
 8105                 CRASH();
 8106                 break;
 8107             }
 8108         }
 8109 
 8110         // Yuck, we should *really* have a way of also returning the storageGPR. But
 8111         // that&#39;s the least of what&#39;s wrong with this code. We really shouldn&#39;t be
 8112         // allocating the array after having computed - and probably spilled to the
 8113         // stack - all of the things that will go into the array. The solution to that
 8114         // bigger problem will also likely fix the redundancy in reloading the storage
 8115         // pointer that we currently have.
 8116 
 8117         cellResult(resultGPR, node);
 8118         return;
 8119     }
 8120 
 8121     if (!node-&gt;numChildren()) {
 8122         flushRegisters();
 8123         GPRFlushedCallResult result(this);
<a name="206" id="anc206"></a><span class="line-modified"> 8124         callOperation(operationNewEmptyArray, result.gpr(), &amp;vm(), structure);</span>
 8125         m_jit.exceptionCheck();
 8126         cellResult(result.gpr(), node);
 8127         return;
 8128     }
 8129 
 8130     size_t scratchSize = sizeof(EncodedJSValue) * node-&gt;numChildren();
 8131     ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 8132     EncodedJSValue* buffer = scratchBuffer ? static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer()) : nullptr;
 8133 
 8134     for (unsigned operandIdx = 0; operandIdx &lt; node-&gt;numChildren(); ++operandIdx) {
 8135         // Need to perform the speculations that this node promises to perform. If we&#39;re
 8136         // emitting code here and the indexing type is not array storage then there is
 8137         // probably something hilarious going on and we&#39;re already failing at all the
 8138         // things, but at least we&#39;re going to be sound.
 8139         Edge use = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + operandIdx];
 8140         switch (node-&gt;indexingType()) {
 8141         case ALL_BLANK_INDEXING_TYPES:
 8142         case ALL_UNDECIDED_INDEXING_TYPES:
 8143             CRASH();
 8144             break;
 8145         case ALL_DOUBLE_INDEXING_TYPES: {
 8146             SpeculateDoubleOperand operand(this, use);
 8147             FPRReg opFPR = operand.fpr();
 8148             DFG_TYPE_CHECK(
 8149                 JSValueRegs(), use, SpecDoubleReal,
 8150                 m_jit.branchIfNaN(opFPR));
 8151 #if USE(JSVALUE64)
 8152             JSValueRegsTemporary scratch(this);
 8153             JSValueRegs scratchRegs = scratch.regs();
 8154             m_jit.boxDouble(opFPR, scratchRegs);
 8155             m_jit.storeValue(scratchRegs, buffer + operandIdx);
 8156 #else
 8157             m_jit.storeDouble(opFPR, TrustedImmPtr(buffer + operandIdx));
 8158 #endif
 8159             operand.use();
 8160             break;
 8161         }
 8162         case ALL_INT32_INDEXING_TYPES:
 8163         case ALL_CONTIGUOUS_INDEXING_TYPES:
 8164         case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
 8165             JSValueOperand operand(this, use, ManualOperandSpeculation);
 8166             JSValueRegs operandRegs = operand.jsValueRegs();
 8167             if (hasInt32(node-&gt;indexingType())) {
 8168                 DFG_TYPE_CHECK(
 8169                     operandRegs, use, SpecInt32Only,
 8170                     m_jit.branchIfNotInt32(operandRegs));
 8171             }
 8172             m_jit.storeValue(operandRegs, buffer + operandIdx);
 8173             operand.use();
 8174             break;
 8175         }
 8176         default:
 8177             CRASH();
 8178             break;
 8179         }
 8180     }
 8181 
 8182     flushRegisters();
 8183 
 8184     if (scratchSize) {
 8185         GPRTemporary scratch(this);
 8186 
 8187         // Tell GC mark phase how much of the scratch buffer is active during call.
 8188         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratch.gpr());
 8189         m_jit.storePtr(TrustedImmPtr(scratchSize), scratch.gpr());
 8190     }
 8191 
 8192     GPRFlushedCallResult result(this);
 8193 
 8194     callOperation(
<a name="207" id="anc207"></a><span class="line-modified"> 8195         operationNewArray, result.gpr(), TrustedImmPtr::weakPointer(m_graph, globalObject), m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType())),</span>
 8196         static_cast&lt;void*&gt;(buffer), size_t(node-&gt;numChildren()));
 8197     m_jit.exceptionCheck();
 8198 
 8199     if (scratchSize) {
 8200         GPRTemporary scratch(this);
 8201 
 8202         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratch.gpr());
 8203         m_jit.storePtr(TrustedImmPtr(nullptr), scratch.gpr());
 8204     }
 8205 
 8206     cellResult(result.gpr(), node, UseChildrenCalledExplicitly);
 8207 }
 8208 
 8209 void SpeculativeJIT::compileNewArrayWithSpread(Node* node)
 8210 {
 8211     ASSERT(node-&gt;op() == NewArrayWithSpread);
<a name="208" id="anc208"></a><span class="line-added"> 8212     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);</span>
 8213 
 8214 #if USE(JSVALUE64)
 8215     if (m_jit.graph().isWatchingHavingABadTimeWatchpoint(node)) {
 8216         GPRTemporary result(this);
 8217         GPRReg resultGPR = result.gpr();
 8218 
 8219         BitVector* bitVector = node-&gt;bitVector();
<a name="209" id="anc209"></a><span class="line-added"> 8220 </span>
<span class="line-added"> 8221         if (node-&gt;numChildren() == 1 &amp;&amp; bitVector-&gt;get(0)) {</span>
<span class="line-added"> 8222             Edge use = m_jit.graph().varArgChild(node, 0);</span>
<span class="line-added"> 8223             SpeculateCellOperand immutableButterfly(this, use);</span>
<span class="line-added"> 8224             GPRTemporary result(this);</span>
<span class="line-added"> 8225             GPRTemporary butterfly(this);</span>
<span class="line-added"> 8226             GPRTemporary scratch1(this);</span>
<span class="line-added"> 8227             GPRTemporary scratch2(this);</span>
<span class="line-added"> 8228 </span>
<span class="line-added"> 8229             GPRReg immutableButterflyGPR = immutableButterfly.gpr();</span>
<span class="line-added"> 8230             GPRReg resultGPR = result.gpr();</span>
<span class="line-added"> 8231             GPRReg butterflyGPR = butterfly.gpr();</span>
<span class="line-added"> 8232             GPRReg scratch1GPR = scratch1.gpr();</span>
<span class="line-added"> 8233             GPRReg scratch2GPR = scratch2.gpr();</span>
<span class="line-added"> 8234 </span>
<span class="line-added"> 8235             RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;originalArrayStructureForIndexingType(CopyOnWriteArrayWithContiguous));</span>
<span class="line-added"> 8236 </span>
<span class="line-added"> 8237             MacroAssembler::JumpList slowCases;</span>
<span class="line-added"> 8238 </span>
<span class="line-added"> 8239             m_jit.move(immutableButterflyGPR, butterflyGPR);</span>
<span class="line-added"> 8240             m_jit.addPtr(TrustedImm32(JSImmutableButterfly::offsetOfData()), butterflyGPR);</span>
<span class="line-added"> 8241 </span>
<span class="line-added"> 8242             emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(structure), butterflyGPR, scratch1GPR, scratch2GPR, slowCases);</span>
<span class="line-added"> 8243 </span>
<span class="line-added"> 8244             addSlowPathGenerator(slowPathCall(slowCases, this, operationNewArrayBuffer, resultGPR, &amp;vm(), structure, immutableButterflyGPR));</span>
<span class="line-added"> 8245 </span>
<span class="line-added"> 8246             cellResult(resultGPR, node);</span>
<span class="line-added"> 8247             return;</span>
<span class="line-added"> 8248         }</span>
<span class="line-added"> 8249 </span>
 8250         {
 8251             unsigned startLength = 0;
 8252             for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
 8253                 if (!bitVector-&gt;get(i))
 8254                     ++startLength;
 8255             }
 8256 
 8257             GPRTemporary length(this);
 8258             GPRReg lengthGPR = length.gpr();
 8259             m_jit.move(TrustedImm32(startLength), lengthGPR);
 8260 
 8261             for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
 8262                 if (bitVector-&gt;get(i)) {
 8263                     Edge use = m_jit.graph().varArgChild(node, i);
<a name="210" id="anc210"></a><span class="line-modified"> 8264                     SpeculateCellOperand immutableButterfly(this, use);</span>
<span class="line-modified"> 8265                     GPRReg immutableButterflyGPR = immutableButterfly.gpr();</span>
<span class="line-modified"> 8266                     speculationCheck(Overflow, JSValueRegs(), nullptr, m_jit.branchAdd32(MacroAssembler::Overflow, MacroAssembler::Address(immutableButterflyGPR, JSImmutableButterfly::offsetOfPublicLength()), lengthGPR));</span>
 8267                 }
 8268             }
 8269 
 8270             speculationCheck(Overflow, JSValueRegs(), nullptr, m_jit.branch32(MacroAssembler::AboveOrEqual, lengthGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)));
 8271 
 8272             // We can tell compileAllocateNewArrayWithSize() that it does not need to
 8273             // check for large arrays and use ArrayStorage structure because we already
 8274             // ensured above that the spread array length will definitely fit in a
 8275             // non-ArrayStorage shaped array.
 8276             bool shouldAllowForArrayStorageStructureForLargeArrays = false;
<a name="211" id="anc211"></a><span class="line-modified"> 8277             compileAllocateNewArrayWithSize(globalObject, resultGPR, lengthGPR, ArrayWithContiguous, shouldAllowForArrayStorageStructureForLargeArrays);</span>

 8278         }
 8279 
 8280         GPRTemporary index(this);
 8281         GPRReg indexGPR = index.gpr();
 8282 
 8283         GPRTemporary storage(this);
 8284         GPRReg storageGPR = storage.gpr();
 8285 
 8286         m_jit.move(TrustedImm32(0), indexGPR);
 8287         m_jit.loadPtr(MacroAssembler::Address(resultGPR, JSObject::butterflyOffset()), storageGPR);
 8288 
 8289         for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
 8290             Edge use = m_jit.graph().varArgChild(node, i);
 8291             if (bitVector-&gt;get(i)) {
<a name="212" id="anc212"></a><span class="line-modified"> 8292                 SpeculateCellOperand immutableButterfly(this, use);</span>
<span class="line-modified"> 8293                 GPRReg immutableButterflyGPR = immutableButterfly.gpr();</span>
 8294 
<a name="213" id="anc213"></a><span class="line-modified"> 8295                 GPRTemporary immutableButterflyIndex(this);</span>
<span class="line-modified"> 8296                 GPRReg immutableButterflyIndexGPR = immutableButterflyIndex.gpr();</span>
 8297 
 8298                 GPRTemporary item(this);
 8299                 GPRReg itemGPR = item.gpr();
 8300 
<a name="214" id="anc214"></a><span class="line-modified"> 8301                 GPRTemporary immutableButterflyLength(this);</span>
<span class="line-modified"> 8302                 GPRReg immutableButterflyLengthGPR = immutableButterflyLength.gpr();</span>
 8303 
<a name="215" id="anc215"></a><span class="line-modified"> 8304                 m_jit.load32(MacroAssembler::Address(immutableButterflyGPR, JSImmutableButterfly::offsetOfPublicLength()), immutableButterflyLengthGPR);</span>
<span class="line-modified"> 8305                 m_jit.move(TrustedImm32(0), immutableButterflyIndexGPR);</span>
<span class="line-modified"> 8306                 auto done = m_jit.branchPtr(MacroAssembler::AboveOrEqual, immutableButterflyIndexGPR, immutableButterflyLengthGPR);</span>
 8307                 auto loopStart = m_jit.label();
 8308                 m_jit.load64(
<a name="216" id="anc216"></a><span class="line-modified"> 8309                     MacroAssembler::BaseIndex(immutableButterflyGPR, immutableButterflyIndexGPR, MacroAssembler::TimesEight, JSImmutableButterfly::offsetOfData()),</span>
 8310                     itemGPR);
 8311 
 8312                 m_jit.store64(itemGPR, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight));
<a name="217" id="anc217"></a><span class="line-modified"> 8313                 m_jit.addPtr(TrustedImm32(1), immutableButterflyIndexGPR);</span>
 8314                 m_jit.addPtr(TrustedImm32(1), indexGPR);
<a name="218" id="anc218"></a><span class="line-modified"> 8315                 m_jit.branchPtr(MacroAssembler::Below, immutableButterflyIndexGPR, immutableButterflyLengthGPR).linkTo(loopStart, &amp;m_jit);</span>
 8316 
 8317                 done.link(&amp;m_jit);
 8318             } else {
 8319                 JSValueOperand item(this, use);
 8320                 GPRReg itemGPR = item.gpr();
 8321                 m_jit.store64(itemGPR, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight));
 8322                 m_jit.addPtr(TrustedImm32(1), indexGPR);
 8323             }
 8324         }
 8325 
 8326         cellResult(resultGPR, node);
 8327         return;
 8328     }
 8329 #endif // USE(JSVALUE64)
 8330 
 8331     ASSERT(node-&gt;numChildren());
 8332     size_t scratchSize = sizeof(EncodedJSValue) * node-&gt;numChildren();
 8333     ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 8334     EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer());
 8335 
 8336     BitVector* bitVector = node-&gt;bitVector();
 8337     for (unsigned i = 0; i &lt; node-&gt;numChildren(); ++i) {
 8338         Edge use = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + i];
 8339         if (bitVector-&gt;get(i)) {
<a name="219" id="anc219"></a><span class="line-modified"> 8340             SpeculateCellOperand immutableButterfly(this, use);</span>
<span class="line-modified"> 8341             GPRReg immutableButterflyGPR = immutableButterfly.gpr();</span>
 8342 #if USE(JSVALUE64)
<a name="220" id="anc220"></a><span class="line-modified"> 8343             m_jit.store64(immutableButterflyGPR, &amp;buffer[i]);</span>
 8344 #else
 8345             char* pointer = static_cast&lt;char*&gt;(static_cast&lt;void*&gt;(&amp;buffer[i]));
<a name="221" id="anc221"></a><span class="line-modified"> 8346             m_jit.store32(immutableButterflyGPR, pointer + PayloadOffset);</span>
 8347             m_jit.store32(TrustedImm32(JSValue::CellTag), pointer + TagOffset);
 8348 #endif
 8349         } else {
 8350             JSValueOperand input(this, use);
 8351             JSValueRegs inputRegs = input.jsValueRegs();
 8352             m_jit.storeValue(inputRegs, &amp;buffer[i]);
 8353         }
 8354     }
 8355 
 8356     {
 8357         GPRTemporary scratch(this);
 8358         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratch.gpr());
 8359         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(scratch.gpr()));
 8360     }
 8361 
 8362     flushRegisters();
 8363 
 8364     GPRFlushedCallResult result(this);
 8365     GPRReg resultGPR = result.gpr();
 8366 
<a name="222" id="anc222"></a><span class="line-modified"> 8367     callOperation(operationNewArrayWithSpreadSlow, resultGPR, TrustedImmPtr::weakPointer(m_graph, globalObject), buffer, node-&gt;numChildren());</span>
 8368     m_jit.exceptionCheck();
 8369     {
 8370         GPRTemporary scratch(this);
 8371         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratch.gpr());
 8372         m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(scratch.gpr()));
 8373     }
 8374 
 8375     cellResult(resultGPR, node);
 8376 }
 8377 
 8378 void SpeculativeJIT::compileGetRestLength(Node* node)
 8379 {
 8380     ASSERT(node-&gt;op() == GetRestLength);
 8381 
 8382     GPRTemporary result(this);
 8383     GPRReg resultGPR = result.gpr();
 8384 
 8385     emitGetLength(node-&gt;origin.semantic, resultGPR);
 8386     CCallHelpers::Jump hasNonZeroLength = m_jit.branch32(MacroAssembler::Above, resultGPR, Imm32(node-&gt;numberOfArgumentsToSkip()));
 8387     m_jit.move(TrustedImm32(0), resultGPR);
 8388     CCallHelpers::Jump done = m_jit.jump();
 8389     hasNonZeroLength.link(&amp;m_jit);
 8390     if (node-&gt;numberOfArgumentsToSkip())
 8391         m_jit.sub32(TrustedImm32(node-&gt;numberOfArgumentsToSkip()), resultGPR);
 8392     done.link(&amp;m_jit);
 8393     int32Result(resultGPR, node);
 8394 }
 8395 
 8396 void SpeculativeJIT::emitPopulateSliceIndex(Edge&amp; target, Optional&lt;GPRReg&gt; indexGPR, GPRReg lengthGPR, GPRReg resultGPR)
 8397 {
 8398     if (target-&gt;isInt32Constant()) {
 8399         int32_t value = target-&gt;asInt32();
 8400         if (value == 0) {
 8401             m_jit.move(TrustedImm32(0), resultGPR);
 8402             return;
 8403         }
 8404 
 8405         MacroAssembler::JumpList done;
 8406         if (value &gt; 0) {
 8407             m_jit.move(TrustedImm32(value), resultGPR);
 8408             done.append(m_jit.branch32(MacroAssembler::BelowOrEqual, resultGPR, lengthGPR));
 8409             m_jit.move(lengthGPR, resultGPR);
 8410         } else {
 8411             ASSERT(value != 0);
 8412             m_jit.move(lengthGPR, resultGPR);
 8413             done.append(m_jit.branchAdd32(MacroAssembler::PositiveOrZero, TrustedImm32(value), resultGPR));
 8414             m_jit.move(TrustedImm32(0), resultGPR);
 8415         }
 8416         done.link(&amp;m_jit);
 8417         return;
 8418     }
 8419 
 8420     Optional&lt;SpeculateInt32Operand&gt; index;
 8421     if (!indexGPR) {
 8422         index.emplace(this, target);
 8423         indexGPR = index-&gt;gpr();
 8424     }
 8425     MacroAssembler::JumpList done;
 8426 
 8427     auto isPositive = m_jit.branch32(MacroAssembler::GreaterThanOrEqual, indexGPR.value(), TrustedImm32(0));
 8428     m_jit.move(lengthGPR, resultGPR);
 8429     done.append(m_jit.branchAdd32(MacroAssembler::PositiveOrZero, indexGPR.value(), resultGPR));
 8430     m_jit.move(TrustedImm32(0), resultGPR);
 8431     done.append(m_jit.jump());
 8432 
 8433     isPositive.link(&amp;m_jit);
 8434     m_jit.move(indexGPR.value(), resultGPR);
 8435     done.append(m_jit.branch32(MacroAssembler::BelowOrEqual, resultGPR, lengthGPR));
 8436     m_jit.move(lengthGPR, resultGPR);
 8437 
 8438     done.link(&amp;m_jit);
 8439 }
 8440 
 8441 void SpeculativeJIT::compileArraySlice(Node* node)
 8442 {
 8443     ASSERT(node-&gt;op() == ArraySlice);
 8444 
 8445     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 8446 
 8447     GPRTemporary temp(this);
 8448     StorageOperand storage(this, m_jit.graph().varArgChild(node, node-&gt;numChildren() - 1));
 8449     GPRTemporary result(this);
 8450 
 8451     GPRReg storageGPR = storage.gpr();
 8452     GPRReg resultGPR = result.gpr();
 8453     GPRReg tempGPR = temp.gpr();
 8454 
 8455     if (node-&gt;numChildren() == 2)
 8456         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), tempGPR);
 8457     else {
 8458         ASSERT(node-&gt;numChildren() == 3 || node-&gt;numChildren() == 4);
 8459         GPRTemporary tempLength(this);
 8460         GPRReg lengthGPR = tempLength.gpr();
 8461         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), lengthGPR);
 8462 
 8463         if (node-&gt;numChildren() == 4)
 8464             emitPopulateSliceIndex(m_jit.graph().varArgChild(node, 2), WTF::nullopt, lengthGPR, tempGPR);
 8465         else
 8466             m_jit.move(lengthGPR, tempGPR);
 8467 
 8468         if (m_jit.graph().varArgChild(node, 1)-&gt;isInt32Constant() &amp;&amp; m_jit.graph().varArgChild(node, 1)-&gt;asInt32() == 0) {
 8469             // Do nothing for array.slice(0, end) or array.slice(0) cases.
 8470             // `tempGPR` already points to the size of a newly created array.
 8471         } else {
 8472             GPRTemporary tempStartIndex(this);
 8473             GPRReg startGPR = tempStartIndex.gpr();
 8474             emitPopulateSliceIndex(m_jit.graph().varArgChild(node, 1), WTF::nullopt, lengthGPR, startGPR);
 8475 
 8476             auto tooBig = m_jit.branch32(MacroAssembler::Above, startGPR, tempGPR);
 8477             m_jit.sub32(startGPR, tempGPR); // the size of the array we&#39;ll make.
 8478             auto done = m_jit.jump();
 8479 
 8480             tooBig.link(&amp;m_jit);
 8481             m_jit.move(TrustedImm32(0), tempGPR);
 8482             done.link(&amp;m_jit);
 8483         }
 8484     }
 8485 
 8486     GPRTemporary temp3(this);
 8487     GPRReg tempValue = temp3.gpr();
 8488 
 8489     {
 8490         // We need to keep the source array alive at least until after we&#39;re done
 8491         // with anything that can GC (e.g. allocating the result array below).
 8492         SpeculateCellOperand cell(this, m_jit.graph().varArgChild(node, 0));
 8493 
 8494         m_jit.load8(MacroAssembler::Address(cell.gpr(), JSCell::indexingTypeAndMiscOffset()), tempValue);
 8495         // We can ignore the writability of the cell since we won&#39;t write to the source.
 8496         m_jit.and32(TrustedImm32(AllWritableArrayTypesAndHistory), tempValue);
 8497 
 8498         JSValueRegsTemporary emptyValue(this);
 8499         JSValueRegs emptyValueRegs = emptyValue.regs();
 8500 
 8501         GPRTemporary storage(this);
 8502         GPRReg storageResultGPR = storage.gpr();
 8503 
 8504         GPRReg sizeGPR = tempGPR;
 8505 
 8506         CCallHelpers::JumpList done;
 8507 
 8508         auto emitMoveEmptyValue = [&amp;] (JSValue v) {
 8509             m_jit.moveValue(v, emptyValueRegs);
 8510         };
 8511 
 8512         auto isContiguous = m_jit.branch32(MacroAssembler::Equal, tempValue, TrustedImm32(ArrayWithContiguous));
 8513         auto isInt32 = m_jit.branch32(MacroAssembler::Equal, tempValue, TrustedImm32(ArrayWithInt32));
 8514         // When we emit an ArraySlice, we dominate the use of the array by a CheckStructure
 8515         // to ensure the incoming array is one to be one of the original array structures
 8516         // with one of the following indexing shapes: Int32, Contiguous, Double. Therefore,
 8517         // we&#39;re a double array here.
 8518         m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithDouble))), tempValue);
 8519         emitMoveEmptyValue(jsNaN());
 8520         done.append(m_jit.jump());
 8521 
 8522         isContiguous.link(&amp;m_jit);
 8523         m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous))), tempValue);
 8524         emitMoveEmptyValue(JSValue());
 8525         done.append(m_jit.jump());
 8526 
 8527         isInt32.link(&amp;m_jit);
 8528         m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithInt32))), tempValue);
 8529         emitMoveEmptyValue(JSValue());
 8530 
 8531         done.link(&amp;m_jit);
 8532 
 8533         MacroAssembler::JumpList slowCases;
 8534         m_jit.move(TrustedImmPtr(nullptr), storageResultGPR);
 8535         // Enable the fast case on 64-bit platforms, where a sufficient amount of GP registers should be available.
 8536         // Other platforms could support the same approach with custom code, but that is not currently worth the extra code maintenance.
 8537         if (is64Bit()) {
 8538             GPRTemporary scratch(this);
 8539             GPRTemporary scratch2(this);
 8540             GPRReg scratchGPR = scratch.gpr();
 8541             GPRReg scratch2GPR = scratch2.gpr();
 8542 
 8543             emitAllocateButterfly(storageResultGPR, sizeGPR, scratchGPR, scratch2GPR, resultGPR, slowCases);
 8544             emitInitializeButterfly(storageResultGPR, sizeGPR, emptyValueRegs, scratchGPR);
 8545             emitAllocateJSObject&lt;JSArray&gt;(resultGPR, tempValue, storageResultGPR, scratchGPR, scratch2GPR, slowCases);
 8546             m_jit.mutatorFence(vm());
 8547         } else {
 8548             slowCases.append(m_jit.jump());
 8549         }
 8550 
 8551         addSlowPathGenerator(makeUnique&lt;CallArrayAllocatorWithVariableStructureVariableSizeSlowPathGenerator&gt;(
<a name="223" id="anc223"></a><span class="line-modified"> 8552             slowCases, this, operationNewArrayWithSize, resultGPR, TrustedImmPtr::weakPointer(m_graph, globalObject), tempValue, sizeGPR, storageResultGPR));</span>
 8553     }
 8554 
 8555     GPRTemporary temp4(this);
 8556     GPRReg loadIndex = temp4.gpr();
 8557 
 8558     if (node-&gt;numChildren() == 2) {
 8559         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), tempGPR);
 8560         m_jit.move(TrustedImm32(0), loadIndex);
 8561     } else {
 8562         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), tempValue);
 8563         if (node-&gt;numChildren() == 4)
 8564             emitPopulateSliceIndex(m_jit.graph().varArgChild(node, 2), WTF::nullopt, tempValue, tempGPR);
 8565         else
 8566             m_jit.move(tempValue, tempGPR);
 8567         emitPopulateSliceIndex(m_jit.graph().varArgChild(node, 1), WTF::nullopt, tempValue, loadIndex);
 8568     }
 8569 
 8570     GPRTemporary temp5(this);
 8571     GPRReg storeIndex = temp5.gpr();
 8572     m_jit.move(TrustedImmPtr(nullptr), storeIndex);
 8573 
 8574     GPRTemporary temp2(this);
 8575     GPRReg resultButterfly = temp2.gpr();
 8576 
 8577     m_jit.loadPtr(MacroAssembler::Address(resultGPR, JSObject::butterflyOffset()), resultButterfly);
 8578     m_jit.zeroExtend32ToPtr(tempGPR, tempGPR);
 8579     m_jit.zeroExtend32ToPtr(loadIndex, loadIndex);
 8580     auto done = m_jit.branchPtr(MacroAssembler::AboveOrEqual, loadIndex, tempGPR);
 8581 
 8582     auto loop = m_jit.label();
 8583 #if USE(JSVALUE64)
 8584     m_jit.load64(
 8585         MacroAssembler::BaseIndex(storageGPR, loadIndex, MacroAssembler::TimesEight), tempValue);
 8586     m_jit.store64(
 8587         tempValue, MacroAssembler::BaseIndex(resultButterfly, storeIndex, MacroAssembler::TimesEight));
 8588 #else
 8589     m_jit.load32(
 8590         MacroAssembler::BaseIndex(storageGPR, loadIndex, MacroAssembler::TimesEight, PayloadOffset), tempValue);
 8591     m_jit.store32(
 8592         tempValue, MacroAssembler::BaseIndex(resultButterfly, storeIndex, MacroAssembler::TimesEight, PayloadOffset));
 8593     m_jit.load32(
 8594         MacroAssembler::BaseIndex(storageGPR, loadIndex, MacroAssembler::TimesEight, TagOffset), tempValue);
 8595     m_jit.store32(
 8596         tempValue, MacroAssembler::BaseIndex(resultButterfly, storeIndex, MacroAssembler::TimesEight, TagOffset));
 8597 #endif // USE(JSVALUE64)
 8598     m_jit.addPtr(TrustedImm32(1), loadIndex);
 8599     m_jit.addPtr(TrustedImm32(1), storeIndex);
 8600     m_jit.branchPtr(MacroAssembler::Below, loadIndex, tempGPR).linkTo(loop, &amp;m_jit);
 8601 
 8602     done.link(&amp;m_jit);
 8603     cellResult(resultGPR, node);
 8604 }
 8605 
 8606 void SpeculativeJIT::compileArrayIndexOf(Node* node)
 8607 {
 8608     ASSERT(node-&gt;op() == ArrayIndexOf);
 8609 
 8610     StorageOperand storage(this, m_jit.graph().varArgChild(node, node-&gt;numChildren() == 3 ? 2 : 3));
 8611     GPRTemporary index(this);
 8612     GPRTemporary tempLength(this);
 8613 
 8614     GPRReg storageGPR = storage.gpr();
 8615     GPRReg indexGPR = index.gpr();
 8616     GPRReg lengthGPR = tempLength.gpr();
 8617 
 8618     m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), lengthGPR);
 8619 
 8620     if (node-&gt;numChildren() == 4)
 8621         emitPopulateSliceIndex(m_jit.graph().varArgChild(node, 2), WTF::nullopt, lengthGPR, indexGPR);
 8622     else
 8623         m_jit.move(TrustedImm32(0), indexGPR);
 8624 
 8625     Edge&amp; searchElementEdge = m_jit.graph().varArgChild(node, 1);
 8626     switch (searchElementEdge.useKind()) {
 8627     case Int32Use:
 8628     case ObjectUse:
 8629     case SymbolUse:
 8630     case OtherUse: {
 8631         auto emitLoop = [&amp;] (auto emitCompare) {
 8632 #if ENABLE(DFG_REGISTER_ALLOCATION_VALIDATION)
 8633             m_jit.clearRegisterAllocationOffsets();
 8634 #endif
 8635 
 8636             m_jit.zeroExtend32ToPtr(lengthGPR, lengthGPR);
 8637             m_jit.zeroExtend32ToPtr(indexGPR, indexGPR);
 8638 
 8639             auto loop = m_jit.label();
 8640             auto notFound = m_jit.branch32(CCallHelpers::Equal, indexGPR, lengthGPR);
 8641 
 8642             auto found = emitCompare();
 8643 
 8644             m_jit.add32(TrustedImm32(1), indexGPR);
 8645             m_jit.jump().linkTo(loop, &amp;m_jit);
 8646 
 8647             notFound.link(&amp;m_jit);
 8648             m_jit.move(TrustedImm32(-1), indexGPR);
 8649             found.link(&amp;m_jit);
 8650             int32Result(indexGPR, node);
 8651         };
 8652 
 8653         if (searchElementEdge.useKind() == Int32Use) {
 8654             ASSERT(node-&gt;arrayMode().type() == Array::Int32);
 8655 #if USE(JSVALUE64)
 8656             JSValueOperand searchElement(this, searchElementEdge, ManualOperandSpeculation);
 8657             JSValueRegs searchElementRegs = searchElement.jsValueRegs();
 8658             speculateInt32(searchElementEdge, searchElementRegs);
 8659             GPRReg searchElementGPR = searchElementRegs.payloadGPR();
 8660 #else
 8661             SpeculateInt32Operand searchElement(this, searchElementEdge);
 8662             GPRReg searchElementGPR = searchElement.gpr();
 8663 
 8664             GPRTemporary temp(this);
 8665             GPRReg tempGPR = temp.gpr();
 8666 #endif
 8667             emitLoop([&amp;] () {
 8668 #if USE(JSVALUE64)
 8669                 auto found = m_jit.branch64(CCallHelpers::Equal, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight), searchElementGPR);
 8670 #else
 8671                 auto skip = m_jit.branch32(CCallHelpers::NotEqual, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, TagOffset), TrustedImm32(JSValue::Int32Tag));
 8672                 m_jit.load32(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, PayloadOffset), tempGPR);
 8673                 auto found = m_jit.branch32(CCallHelpers::Equal, tempGPR, searchElementGPR);
 8674                 skip.link(&amp;m_jit);
 8675 #endif
 8676                 return found;
 8677             });
 8678             return;
 8679         }
 8680 
 8681         if (searchElementEdge.useKind() == OtherUse) {
 8682             ASSERT(node-&gt;arrayMode().type() == Array::Contiguous);
 8683             JSValueOperand searchElement(this, searchElementEdge, ManualOperandSpeculation);
 8684             GPRTemporary temp(this);
 8685 
 8686             JSValueRegs searchElementRegs = searchElement.jsValueRegs();
 8687             GPRReg tempGPR = temp.gpr();
 8688             speculateOther(searchElementEdge, searchElementRegs, tempGPR);
 8689 
 8690             emitLoop([&amp;] () {
 8691 #if USE(JSVALUE64)
 8692                 auto found = m_jit.branch64(CCallHelpers::Equal, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight), searchElementRegs.payloadGPR());
 8693 #else
 8694                 m_jit.load32(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, TagOffset), tempGPR);
 8695                 auto found = m_jit.branch32(CCallHelpers::Equal, tempGPR, searchElementRegs.tagGPR());
 8696 #endif
 8697                 return found;
 8698             });
 8699             return;
 8700         }
 8701 
 8702         ASSERT(node-&gt;arrayMode().type() == Array::Contiguous);
 8703         SpeculateCellOperand searchElement(this, searchElementEdge);
 8704         GPRReg searchElementGPR = searchElement.gpr();
 8705 
 8706         if (searchElementEdge.useKind() == ObjectUse)
 8707             speculateObject(searchElementEdge, searchElementGPR);
 8708         else {
 8709             ASSERT(searchElementEdge.useKind() == SymbolUse);
 8710             speculateSymbol(searchElementEdge, searchElementGPR);
 8711         }
 8712 
 8713 #if USE(JSVALUE32_64)
 8714         GPRTemporary temp(this);
 8715         GPRReg tempGPR = temp.gpr();
 8716 #endif
 8717 
 8718         emitLoop([&amp;] () {
 8719 #if USE(JSVALUE64)
 8720             auto found = m_jit.branch64(CCallHelpers::Equal, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight), searchElementGPR);
 8721 #else
 8722             auto skip = m_jit.branch32(CCallHelpers::NotEqual, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, TagOffset), TrustedImm32(JSValue::CellTag));
 8723             m_jit.load32(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, PayloadOffset), tempGPR);
 8724             auto found = m_jit.branch32(CCallHelpers::Equal, tempGPR, searchElementGPR);
 8725             skip.link(&amp;m_jit);
 8726 #endif
 8727             return found;
 8728         });
 8729         return;
 8730     }
 8731 
 8732     case DoubleRepUse: {
 8733         ASSERT(node-&gt;arrayMode().type() == Array::Double);
 8734         SpeculateDoubleOperand searchElement(this, searchElementEdge);
 8735         FPRTemporary tempDouble(this);
 8736 
 8737         FPRReg searchElementFPR = searchElement.fpr();
 8738         FPRReg tempFPR = tempDouble.fpr();
 8739 
 8740 #if ENABLE(DFG_REGISTER_ALLOCATION_VALIDATION)
 8741         m_jit.clearRegisterAllocationOffsets();
 8742 #endif
 8743 
 8744         m_jit.zeroExtend32ToPtr(lengthGPR, lengthGPR);
 8745         m_jit.zeroExtend32ToPtr(indexGPR, indexGPR);
 8746 
 8747         auto loop = m_jit.label();
 8748         auto notFound = m_jit.branch32(CCallHelpers::Equal, indexGPR, lengthGPR);
 8749         m_jit.loadDouble(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight), tempFPR);
 8750         auto found = m_jit.branchDouble(CCallHelpers::DoubleEqual, tempFPR, searchElementFPR);
 8751         m_jit.add32(TrustedImm32(1), indexGPR);
 8752         m_jit.jump().linkTo(loop, &amp;m_jit);
 8753 
 8754         notFound.link(&amp;m_jit);
 8755         m_jit.move(TrustedImm32(-1), indexGPR);
 8756         found.link(&amp;m_jit);
 8757         int32Result(indexGPR, node);
 8758         return;
 8759     }
 8760 
 8761     case StringUse: {
 8762         ASSERT(node-&gt;arrayMode().type() == Array::Contiguous);
 8763         SpeculateCellOperand searchElement(this, searchElementEdge);
 8764 
 8765         GPRReg searchElementGPR = searchElement.gpr();
 8766 
 8767         speculateString(searchElementEdge, searchElementGPR);
 8768 
 8769         flushRegisters();
 8770 
<a name="224" id="anc224"></a><span class="line-modified"> 8771         callOperation(operationArrayIndexOfString, lengthGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), storageGPR, searchElementGPR, indexGPR);</span>
 8772         m_jit.exceptionCheck();
 8773 
 8774         int32Result(lengthGPR, node);
 8775         return;
 8776     }
 8777 
 8778     case UntypedUse: {
 8779         JSValueOperand searchElement(this, searchElementEdge);
 8780 
 8781         JSValueRegs searchElementRegs = searchElement.jsValueRegs();
 8782 
 8783         flushRegisters();
 8784         switch (node-&gt;arrayMode().type()) {
 8785         case Array::Double:
<a name="225" id="anc225"></a><span class="line-modified"> 8786             callOperation(operationArrayIndexOfValueDouble, lengthGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), storageGPR, searchElementRegs, indexGPR);</span>
 8787             break;
 8788         case Array::Int32:
 8789         case Array::Contiguous:
<a name="226" id="anc226"></a><span class="line-modified"> 8790             callOperation(operationArrayIndexOfValueInt32OrContiguous, lengthGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), storageGPR, searchElementRegs, indexGPR);</span>
 8791             break;
 8792         default:
 8793             RELEASE_ASSERT_NOT_REACHED();
 8794             break;
 8795         }
 8796         m_jit.exceptionCheck();
 8797 
 8798         int32Result(lengthGPR, node);
 8799         return;
 8800     }
 8801 
 8802     default:
 8803         RELEASE_ASSERT_NOT_REACHED();
 8804         return;
 8805     }
 8806 }
 8807 
 8808 void SpeculativeJIT::compileArrayPush(Node* node)
 8809 {
 8810     ASSERT(node-&gt;arrayMode().isJSArray());
 8811 
 8812     Edge&amp; storageEdge = m_jit.graph().varArgChild(node, 0);
 8813     Edge&amp; arrayEdge = m_jit.graph().varArgChild(node, 1);
 8814 
 8815     SpeculateCellOperand base(this, arrayEdge);
 8816     GPRTemporary storageLength(this);
 8817 
 8818     GPRReg baseGPR = base.gpr();
 8819     GPRReg storageLengthGPR = storageLength.gpr();
 8820 
 8821     StorageOperand storage(this, storageEdge);
 8822     GPRReg storageGPR = storage.gpr();
 8823     unsigned elementOffset = 2;
 8824     unsigned elementCount = node-&gt;numChildren() - elementOffset;
 8825 
 8826 #if USE(JSVALUE32_64)
 8827     GPRTemporary tag(this);
 8828     GPRReg tagGPR = tag.gpr();
 8829     JSValueRegs resultRegs { tagGPR, storageLengthGPR };
 8830 #else
 8831     JSValueRegs resultRegs { storageLengthGPR };
 8832 #endif
 8833 
 8834     auto getStorageBufferAddress = [&amp;] (GPRReg storageGPR, GPRReg indexGPR, int32_t offset, GPRReg bufferGPR) {
 8835         static_assert(sizeof(JSValue) == 8 &amp;&amp; 1 &lt;&lt; 3 == 8, &quot;This is strongly assumed in the code below.&quot;);
 8836         m_jit.getEffectiveAddress(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, offset), bufferGPR);
 8837     };
 8838 
 8839     switch (node-&gt;arrayMode().type()) {
 8840     case Array::Int32:
 8841     case Array::Contiguous: {
 8842         if (elementCount == 1) {
 8843             Edge&amp; element = m_jit.graph().varArgChild(node, elementOffset);
 8844             if (node-&gt;arrayMode().type() == Array::Int32) {
 8845                 ASSERT(element.useKind() == Int32Use);
 8846                 speculateInt32(element);
 8847             }
 8848             JSValueOperand value(this, element, ManualOperandSpeculation);
 8849             JSValueRegs valueRegs = value.jsValueRegs();
 8850 
 8851             m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8852             MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8853             m_jit.storeValue(valueRegs, MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
 8854             m_jit.add32(TrustedImm32(1), storageLengthGPR);
 8855             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
 8856             m_jit.boxInt32(storageLengthGPR, resultRegs);
 8857 
 8858             addSlowPathGenerator(
<a name="227" id="anc227"></a><span class="line-modified"> 8859                 slowPathCall(slowPath, this, operationArrayPush, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs, baseGPR));</span>
 8860 
 8861             jsValueResult(resultRegs, node);
 8862             return;
 8863         }
 8864 
 8865         if (node-&gt;arrayMode().type() == Array::Int32) {
 8866             for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8867                 Edge element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
 8868                 ASSERT(element.useKind() == Int32Use);
 8869                 speculateInt32(element);
 8870             }
 8871         }
 8872 
 8873         GPRTemporary buffer(this);
 8874         GPRReg bufferGPR = buffer.gpr();
 8875 
 8876         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8877         m_jit.move(storageLengthGPR, bufferGPR);
 8878         m_jit.add32(TrustedImm32(elementCount), bufferGPR);
 8879         MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::Above, bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8880 
 8881         m_jit.store32(bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
 8882         getStorageBufferAddress(storageGPR, storageLengthGPR, 0, bufferGPR);
 8883         m_jit.add32(TrustedImm32(elementCount), storageLengthGPR);
 8884         m_jit.boxInt32(storageLengthGPR, resultRegs);
 8885         auto storageDone = m_jit.jump();
 8886 
 8887         slowPath.link(&amp;m_jit);
 8888 
 8889         size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
 8890         ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 8891         m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
 8892         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
 8893         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
 8894 
 8895         storageDone.link(&amp;m_jit);
 8896         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8897             Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
 8898             JSValueOperand value(this, element, ManualOperandSpeculation); // We did type checks above.
 8899             JSValueRegs valueRegs = value.jsValueRegs();
 8900 
 8901             m_jit.storeValue(valueRegs, MacroAssembler::Address(bufferGPR, sizeof(EncodedJSValue) * elementIndex));
 8902             value.use();
 8903         }
 8904 
 8905         MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 8906 
<a name="228" id="anc228"></a><span class="line-modified"> 8907         addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationArrayPushMultiple, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, bufferGPR, TrustedImm32(elementCount)));</span>
 8908 
 8909         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), bufferGPR);
 8910         m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(bufferGPR));
 8911 
 8912         base.use();
 8913         storage.use();
 8914 
 8915         fastPath.link(&amp;m_jit);
 8916         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 8917         return;
 8918     }
 8919 
 8920     case Array::Double: {
 8921         if (elementCount == 1) {
 8922             Edge&amp; element = m_jit.graph().varArgChild(node, elementOffset);
 8923             speculate(node, element);
 8924             SpeculateDoubleOperand value(this, element);
 8925             FPRReg valueFPR = value.fpr();
 8926 
 8927             m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8928             MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8929             m_jit.storeDouble(valueFPR, MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
 8930             m_jit.add32(TrustedImm32(1), storageLengthGPR);
 8931             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
 8932             m_jit.boxInt32(storageLengthGPR, resultRegs);
 8933 
 8934             addSlowPathGenerator(
<a name="229" id="anc229"></a><span class="line-modified"> 8935                 slowPathCall(slowPath, this, operationArrayPushDouble, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueFPR, baseGPR));</span>
 8936 
 8937             jsValueResult(resultRegs, node);
 8938             return;
 8939         }
 8940 
 8941         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8942             Edge element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
 8943             ASSERT(element.useKind() == DoubleRepRealUse);
 8944             speculate(node, element);
 8945         }
 8946 
 8947         GPRTemporary buffer(this);
 8948         GPRReg bufferGPR = buffer.gpr();
 8949 
 8950         m_jit.load32(MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
 8951         m_jit.move(storageLengthGPR, bufferGPR);
 8952         m_jit.add32(TrustedImm32(elementCount), bufferGPR);
 8953         MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::Above, bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfVectorLength()));
 8954 
 8955         m_jit.store32(bufferGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
 8956         getStorageBufferAddress(storageGPR, storageLengthGPR, 0, bufferGPR);
 8957         m_jit.add32(TrustedImm32(elementCount), storageLengthGPR);
 8958         m_jit.boxInt32(storageLengthGPR, resultRegs);
 8959         auto storageDone = m_jit.jump();
 8960 
 8961         slowPath.link(&amp;m_jit);
 8962 
 8963         size_t scratchSize = sizeof(double) * elementCount;
 8964         ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 8965         m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
 8966         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
 8967         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
 8968 
 8969         storageDone.link(&amp;m_jit);
 8970         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 8971             Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
 8972             SpeculateDoubleOperand value(this, element);
 8973             FPRReg valueFPR = value.fpr();
 8974 
 8975             m_jit.storeDouble(valueFPR, MacroAssembler::Address(bufferGPR, sizeof(double) * elementIndex));
 8976             value.use();
 8977         }
 8978 
 8979         MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 8980 
<a name="230" id="anc230"></a><span class="line-modified"> 8981         addSlowPathGenerator(slowPathCall(m_jit.jump(), this, operationArrayPushDoubleMultiple, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, bufferGPR, TrustedImm32(elementCount)));</span>
 8982 
 8983         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), bufferGPR);
 8984         m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(bufferGPR));
 8985 
 8986         base.use();
 8987         storage.use();
 8988 
 8989         fastPath.link(&amp;m_jit);
 8990         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 8991         return;
 8992     }
 8993 
 8994     case Array::ArrayStorage: {
 8995         // This ensures that the result of ArrayPush is Int32 in AI.
 8996         int32_t largestPositiveInt32Length = 0x7fffffff - elementCount;
 8997         if (elementCount == 1) {
 8998             Edge&amp; element = m_jit.graph().varArgChild(node, elementOffset);
 8999             JSValueOperand value(this, element);
 9000             JSValueRegs valueRegs = value.jsValueRegs();
 9001 
 9002             m_jit.load32(MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()), storageLengthGPR);
 9003 
 9004             // Refuse to handle bizarre lengths.
 9005             speculationCheck(Uncountable, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::Above, storageLengthGPR, TrustedImm32(largestPositiveInt32Length)));
 9006 
 9007             MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::vectorLengthOffset()));
 9008 
 9009             m_jit.storeValue(valueRegs, MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()));
 9010 
 9011             m_jit.add32(TrustedImm32(1), storageLengthGPR);
 9012             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()));
 9013             m_jit.add32(TrustedImm32(1), MacroAssembler::Address(storageGPR, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
 9014             m_jit.boxInt32(storageLengthGPR, resultRegs);
 9015 
 9016             addSlowPathGenerator(
<a name="231" id="anc231"></a><span class="line-modified"> 9017                 slowPathCall(slowPath, this, operationArrayPush, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs, baseGPR));</span>
 9018 
 9019             jsValueResult(resultRegs, node);
 9020             return;
 9021         }
 9022 
 9023         GPRTemporary buffer(this);
 9024         GPRReg bufferGPR = buffer.gpr();
 9025 
 9026         m_jit.load32(MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()), storageLengthGPR);
 9027 
 9028         // Refuse to handle bizarre lengths.
 9029         speculationCheck(Uncountable, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::Above, storageLengthGPR, TrustedImm32(largestPositiveInt32Length)));
 9030 
 9031         m_jit.move(storageLengthGPR, bufferGPR);
 9032         m_jit.add32(TrustedImm32(elementCount), bufferGPR);
 9033         MacroAssembler::Jump slowPath = m_jit.branch32(MacroAssembler::Above, bufferGPR, MacroAssembler::Address(storageGPR, ArrayStorage::vectorLengthOffset()));
 9034 
 9035         m_jit.store32(bufferGPR, MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()));
 9036         getStorageBufferAddress(storageGPR, storageLengthGPR, ArrayStorage::vectorOffset(), bufferGPR);
 9037         m_jit.add32(TrustedImm32(elementCount), MacroAssembler::Address(storageGPR, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
 9038         m_jit.add32(TrustedImm32(elementCount), storageLengthGPR);
 9039         m_jit.boxInt32(storageLengthGPR, resultRegs);
 9040         auto storageDone = m_jit.jump();
 9041 
 9042         slowPath.link(&amp;m_jit);
 9043 
 9044         size_t scratchSize = sizeof(EncodedJSValue) * elementCount;
 9045         ScratchBuffer* scratchBuffer = vm().scratchBufferForSize(scratchSize);
 9046         m_jit.move(TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())), bufferGPR);
 9047         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), storageLengthGPR);
 9048         m_jit.storePtr(TrustedImmPtr(scratchSize), MacroAssembler::Address(storageLengthGPR));
 9049 
 9050         storageDone.link(&amp;m_jit);
 9051         for (unsigned elementIndex = 0; elementIndex &lt; elementCount; ++elementIndex) {
 9052             Edge&amp; element = m_jit.graph().varArgChild(node, elementIndex + elementOffset);
 9053             JSValueOperand value(this, element);
 9054             JSValueRegs valueRegs = value.jsValueRegs();
 9055 
 9056             m_jit.storeValue(valueRegs, MacroAssembler::Address(bufferGPR, sizeof(EncodedJSValue) * elementIndex));
 9057             value.use();
 9058         }
 9059 
 9060         MacroAssembler::Jump fastPath = m_jit.branchPtr(MacroAssembler::NotEqual, bufferGPR, TrustedImmPtr(static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer())));
 9061 
 9062         addSlowPathGenerator(
<a name="232" id="anc232"></a><span class="line-modified"> 9063             slowPathCall(m_jit.jump(), this, operationArrayPushMultiple, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, bufferGPR, TrustedImm32(elementCount)));</span>
 9064 
 9065         m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), bufferGPR);
 9066         m_jit.storePtr(TrustedImmPtr(nullptr), MacroAssembler::Address(bufferGPR));
 9067 
 9068         base.use();
 9069         storage.use();
 9070 
 9071         fastPath.link(&amp;m_jit);
 9072         jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
 9073         return;
 9074     }
 9075 
 9076     default:
 9077         RELEASE_ASSERT_NOT_REACHED();
 9078     }
 9079 }
 9080 
 9081 void SpeculativeJIT::compileNotifyWrite(Node* node)
 9082 {
 9083     WatchpointSet* set = node-&gt;watchpointSet();
 9084 
 9085     JITCompiler::Jump slowCase = m_jit.branch8(
 9086         JITCompiler::NotEqual,
 9087         JITCompiler::AbsoluteAddress(set-&gt;addressOfState()),
 9088         TrustedImm32(IsInvalidated));
 9089 
 9090     addSlowPathGenerator(
<a name="233" id="anc233"></a><span class="line-modified"> 9091         slowPathCall(slowCase, this, operationNotifyWrite, NeedToSpill, ExceptionCheckRequirement::CheckNotNeeded, NoResult, &amp;vm(), set));</span>
 9092 
 9093     noResult(node);
 9094 }
 9095 
 9096 void SpeculativeJIT::compileIsObject(Node* node)
 9097 {
 9098     JSValueOperand value(this, node-&gt;child1());
 9099     GPRTemporary result(this, Reuse, value, TagWord);
 9100 
 9101     JSValueRegs valueRegs = value.jsValueRegs();
 9102     GPRReg resultGPR = result.gpr();
 9103 
 9104     JITCompiler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
 9105 
 9106     m_jit.compare8(JITCompiler::AboveOrEqual,
 9107         JITCompiler::Address(valueRegs.payloadGPR(), JSCell::typeInfoTypeOffset()),
 9108         TrustedImm32(ObjectType),
 9109         resultGPR);
 9110     JITCompiler::Jump done = m_jit.jump();
 9111 
 9112     isNotCell.link(&amp;m_jit);
 9113     m_jit.move(TrustedImm32(0), resultGPR);
 9114 
 9115     done.link(&amp;m_jit);
 9116     unblessedBooleanResult(resultGPR, node);
 9117 }
 9118 
 9119 void SpeculativeJIT::compileIsObjectOrNull(Node* node)
 9120 {
 9121     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 9122 
 9123     JSValueOperand value(this, node-&gt;child1());
 9124     JSValueRegs valueRegs = value.jsValueRegs();
 9125 
 9126     GPRTemporary result(this);
 9127     GPRReg resultGPR = result.gpr();
 9128 
 9129     JITCompiler::Jump isCell = m_jit.branchIfCell(valueRegs);
 9130 
 9131     JITCompiler::Jump isNull = m_jit.branchIfEqual(valueRegs, jsNull());
 9132     JITCompiler::Jump isNonNullNonCell = m_jit.jump();
 9133 
 9134     isCell.link(&amp;m_jit);
 9135     JITCompiler::Jump isFunction = m_jit.branchIfFunction(valueRegs.payloadGPR());
 9136     JITCompiler::Jump notObject = m_jit.branchIfNotObject(valueRegs.payloadGPR());
 9137 
 9138     JITCompiler::Jump slowPath = m_jit.branchTest8(
 9139         JITCompiler::NonZero,
 9140         JITCompiler::Address(valueRegs.payloadGPR(), JSCell::typeInfoFlagsOffset()),
 9141         TrustedImm32(MasqueradesAsUndefined | OverridesGetCallData));
 9142 
 9143     isNull.link(&amp;m_jit);
 9144     m_jit.move(TrustedImm32(1), resultGPR);
 9145     JITCompiler::Jump done = m_jit.jump();
 9146 
 9147     isNonNullNonCell.link(&amp;m_jit);
 9148     isFunction.link(&amp;m_jit);
 9149     notObject.link(&amp;m_jit);
 9150     m_jit.move(TrustedImm32(0), resultGPR);
 9151 
 9152     addSlowPathGenerator(
 9153         slowPathCall(
 9154             slowPath, this, operationObjectIsObject, resultGPR, globalObject,
 9155             valueRegs.payloadGPR()));
 9156 
 9157     done.link(&amp;m_jit);
 9158 
 9159     unblessedBooleanResult(resultGPR, node);
 9160 }
 9161 
 9162 void SpeculativeJIT::compileIsFunction(Node* node)
 9163 {
 9164     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 9165 
 9166     JSValueOperand value(this, node-&gt;child1());
 9167     JSValueRegs valueRegs = value.jsValueRegs();
 9168 
 9169     GPRTemporary result(this);
 9170     GPRReg resultGPR = result.gpr();
 9171 
 9172     JITCompiler::Jump notCell = m_jit.branchIfNotCell(valueRegs);
 9173     JITCompiler::Jump isFunction = m_jit.branchIfFunction(valueRegs.payloadGPR());
 9174     JITCompiler::Jump notObject = m_jit.branchIfNotObject(valueRegs.payloadGPR());
 9175 
 9176     JITCompiler::Jump slowPath = m_jit.branchTest8(
 9177         JITCompiler::NonZero,
 9178         JITCompiler::Address(valueRegs.payloadGPR(), JSCell::typeInfoFlagsOffset()),
 9179         TrustedImm32(MasqueradesAsUndefined | OverridesGetCallData));
 9180 
 9181     notCell.link(&amp;m_jit);
 9182     notObject.link(&amp;m_jit);
 9183     m_jit.move(TrustedImm32(0), resultGPR);
 9184     JITCompiler::Jump done = m_jit.jump();
 9185 
 9186     isFunction.link(&amp;m_jit);
 9187     m_jit.move(TrustedImm32(1), resultGPR);
 9188 
 9189     addSlowPathGenerator(
 9190         slowPathCall(
 9191             slowPath, this, operationObjectIsFunction, resultGPR, globalObject,
 9192             valueRegs.payloadGPR()));
 9193 
 9194     done.link(&amp;m_jit);
 9195 
 9196     unblessedBooleanResult(resultGPR, node);
 9197 }
 9198 
 9199 void SpeculativeJIT::compileTypeOf(Node* node)
 9200 {
 9201     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 9202 
 9203     JSValueOperand value(this, node-&gt;child1());
 9204     JSValueRegs valueRegs = value.jsValueRegs();
 9205 
 9206     GPRTemporary result(this);
 9207     GPRReg resultGPR = result.gpr();
 9208 
 9209     JITCompiler::JumpList done;
 9210     JITCompiler::Jump slowPath;
 9211     m_jit.emitTypeOf(
 9212         valueRegs, resultGPR,
 9213         [&amp;] (TypeofType type, bool fallsThrough) {
 9214             m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), vm().smallStrings.typeString(type)), resultGPR);
 9215             if (!fallsThrough)
 9216                 done.append(m_jit.jump());
 9217         },
 9218         [&amp;] (JITCompiler::Jump theSlowPath) {
 9219             slowPath = theSlowPath;
 9220         });
 9221     done.link(&amp;m_jit);
 9222 
 9223     addSlowPathGenerator(
 9224         slowPathCall(
 9225             slowPath, this, operationTypeOfObject, resultGPR, globalObject,
 9226             valueRegs.payloadGPR()));
 9227 
 9228     cellResult(resultGPR, node);
 9229 }
 9230 
 9231 void SpeculativeJIT::emitStructureCheck(Node* node, GPRReg cellGPR, GPRReg tempGPR)
 9232 {
 9233     ASSERT(node-&gt;structureSet().size());
 9234 
 9235     if (node-&gt;structureSet().size() == 1) {
 9236         speculationCheck(
 9237             BadCache, JSValueSource::unboxedCell(cellGPR), 0,
 9238             m_jit.branchWeakStructure(
 9239                 JITCompiler::NotEqual,
 9240                 JITCompiler::Address(cellGPR, JSCell::structureIDOffset()),
 9241                 node-&gt;structureSet()[0]));
 9242     } else {
 9243         std::unique_ptr&lt;GPRTemporary&gt; structure;
 9244         GPRReg structureGPR;
 9245 
 9246         if (tempGPR == InvalidGPRReg) {
 9247             structure = makeUnique&lt;GPRTemporary&gt;(this);
 9248             structureGPR = structure-&gt;gpr();
 9249         } else
 9250             structureGPR = tempGPR;
 9251 
 9252         m_jit.load32(JITCompiler::Address(cellGPR, JSCell::structureIDOffset()), structureGPR);
 9253 
 9254         JITCompiler::JumpList done;
 9255 
 9256         for (size_t i = 0; i &lt; node-&gt;structureSet().size() - 1; ++i) {
 9257             done.append(
 9258                 m_jit.branchWeakStructure(JITCompiler::Equal, structureGPR, node-&gt;structureSet()[i]));
 9259         }
 9260 
 9261         speculationCheck(
 9262             BadCache, JSValueSource::unboxedCell(cellGPR), 0,
 9263             m_jit.branchWeakStructure(
 9264                 JITCompiler::NotEqual, structureGPR, node-&gt;structureSet().last()));
 9265 
 9266         done.link(&amp;m_jit);
 9267     }
 9268 }
 9269 
 9270 void SpeculativeJIT::compileCheckCell(Node* node)
 9271 {
 9272     SpeculateCellOperand cell(this, node-&gt;child1());
 9273     speculationCheck(BadCell, JSValueSource::unboxedCell(cell.gpr()), node-&gt;child1(), m_jit.branchWeakPtr(JITCompiler::NotEqual, cell.gpr(), node-&gt;cellOperand()-&gt;cell()));
 9274     noResult(node);
 9275 }
 9276 
 9277 void SpeculativeJIT::compileCheckNotEmpty(Node* node)
 9278 {
 9279     JSValueOperand operand(this, node-&gt;child1());
 9280     JSValueRegs regs = operand.jsValueRegs();
 9281     speculationCheck(TDZFailure, JSValueSource(), nullptr, m_jit.branchIfEmpty(regs));
 9282     noResult(node);
 9283 }
 9284 
 9285 void SpeculativeJIT::compileCheckStructure(Node* node)
 9286 {
 9287     switch (node-&gt;child1().useKind()) {
 9288     case CellUse:
 9289     case KnownCellUse: {
 9290         SpeculateCellOperand cell(this, node-&gt;child1());
 9291         emitStructureCheck(node, cell.gpr(), InvalidGPRReg);
 9292         noResult(node);
 9293         return;
 9294     }
 9295 
 9296     case CellOrOtherUse: {
 9297         JSValueOperand value(this, node-&gt;child1(), ManualOperandSpeculation);
 9298         GPRTemporary temp(this);
 9299 
 9300         JSValueRegs valueRegs = value.jsValueRegs();
 9301         GPRReg tempGPR = temp.gpr();
 9302 
 9303         JITCompiler::Jump cell = m_jit.branchIfCell(valueRegs);
 9304         DFG_TYPE_CHECK(
 9305             valueRegs, node-&gt;child1(), SpecCell | SpecOther,
 9306             m_jit.branchIfNotOther(valueRegs, tempGPR));
 9307         JITCompiler::Jump done = m_jit.jump();
 9308         cell.link(&amp;m_jit);
 9309         emitStructureCheck(node, valueRegs.payloadGPR(), tempGPR);
 9310         done.link(&amp;m_jit);
 9311         noResult(node);
 9312         return;
 9313     }
 9314 
 9315     default:
 9316         DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
 9317         return;
 9318     }
 9319 }
 9320 
 9321 void SpeculativeJIT::compileAllocatePropertyStorage(Node* node)
 9322 {
 9323     ASSERT(!node-&gt;transition()-&gt;previous-&gt;outOfLineCapacity());
 9324     ASSERT(initialOutOfLineCapacity == node-&gt;transition()-&gt;next-&gt;outOfLineCapacity());
 9325 
 9326     size_t size = initialOutOfLineCapacity * sizeof(JSValue);
 9327 
 9328     Allocator allocator = vm().jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(size, AllocatorForMode::AllocatorIfExists);
 9329 
 9330     if (!allocator || node-&gt;transition()-&gt;previous-&gt;couldHaveIndexingHeader()) {
 9331         SpeculateCellOperand base(this, node-&gt;child1());
 9332 
 9333         GPRReg baseGPR = base.gpr();
 9334 
 9335         flushRegisters();
 9336 
 9337         GPRFlushedCallResult result(this);
<a name="234" id="anc234"></a><span class="line-modified"> 9338         callOperation(operationAllocateComplexPropertyStorageWithInitialCapacity, result.gpr(), &amp;vm(), baseGPR);</span>
 9339         m_jit.exceptionCheck();
 9340 
 9341         storageResult(result.gpr(), node);
 9342         return;
 9343     }
 9344 
 9345     GPRTemporary scratch1(this);
 9346     GPRTemporary scratch2(this);
 9347     GPRTemporary scratch3(this);
 9348 
 9349     GPRReg scratchGPR1 = scratch1.gpr();
 9350     GPRReg scratchGPR2 = scratch2.gpr();
 9351     GPRReg scratchGPR3 = scratch3.gpr();
 9352 
 9353     JITCompiler::JumpList slowPath;
 9354     m_jit.emitAllocate(scratchGPR1, JITAllocator::constant(allocator), scratchGPR2, scratchGPR3, slowPath);
 9355     m_jit.addPtr(JITCompiler::TrustedImm32(size + sizeof(IndexingHeader)), scratchGPR1);
 9356 
 9357     addSlowPathGenerator(
<a name="235" id="anc235"></a><span class="line-modified"> 9358         slowPathCall(slowPath, this, operationAllocateSimplePropertyStorageWithInitialCapacity, scratchGPR1, &amp;vm()));</span>
 9359 
 9360     for (ptrdiff_t offset = 0; offset &lt; static_cast&lt;ptrdiff_t&gt;(size); offset += sizeof(void*))
 9361         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratchGPR1, -(offset + sizeof(JSValue) + sizeof(void*))));
 9362 
 9363     storageResult(scratchGPR1, node);
 9364 }
 9365 
 9366 void SpeculativeJIT::compileReallocatePropertyStorage(Node* node)
 9367 {
 9368     size_t oldSize = node-&gt;transition()-&gt;previous-&gt;outOfLineCapacity() * sizeof(JSValue);
 9369     size_t newSize = oldSize * outOfLineGrowthFactor;
 9370     ASSERT(newSize == node-&gt;transition()-&gt;next-&gt;outOfLineCapacity() * sizeof(JSValue));
 9371 
 9372     Allocator allocator = vm().jsValueGigacageAuxiliarySpace.allocatorForNonVirtual(newSize, AllocatorForMode::AllocatorIfExists);
 9373 
 9374     if (!allocator || node-&gt;transition()-&gt;previous-&gt;couldHaveIndexingHeader()) {
 9375         SpeculateCellOperand base(this, node-&gt;child1());
 9376 
 9377         GPRReg baseGPR = base.gpr();
 9378 
 9379         flushRegisters();
 9380 
 9381         GPRFlushedCallResult result(this);
<a name="236" id="anc236"></a><span class="line-modified"> 9382         callOperation(operationAllocateComplexPropertyStorage, result.gpr(), &amp;vm(), baseGPR, newSize / sizeof(JSValue));</span>
 9383         m_jit.exceptionCheck();
 9384 
 9385         storageResult(result.gpr(), node);
 9386         return;
 9387     }
 9388 
 9389     StorageOperand oldStorage(this, node-&gt;child2());
 9390     GPRTemporary scratch1(this);
 9391     GPRTemporary scratch2(this);
 9392     GPRTemporary scratch3(this);
 9393 
 9394     GPRReg oldStorageGPR = oldStorage.gpr();
 9395     GPRReg scratchGPR1 = scratch1.gpr();
 9396     GPRReg scratchGPR2 = scratch2.gpr();
 9397     GPRReg scratchGPR3 = scratch3.gpr();
 9398 
 9399     JITCompiler::JumpList slowPath;
 9400     m_jit.emitAllocate(scratchGPR1, JITAllocator::constant(allocator), scratchGPR2, scratchGPR3, slowPath);
 9401 
 9402     m_jit.addPtr(JITCompiler::TrustedImm32(newSize + sizeof(IndexingHeader)), scratchGPR1);
 9403 
 9404     addSlowPathGenerator(
<a name="237" id="anc237"></a><span class="line-modified"> 9405         slowPathCall(slowPath, this, operationAllocateSimplePropertyStorage, scratchGPR1, &amp;vm(), newSize / sizeof(JSValue)));</span>
 9406 
 9407     for (ptrdiff_t offset = oldSize; offset &lt; static_cast&lt;ptrdiff_t&gt;(newSize); offset += sizeof(void*))
 9408         m_jit.storePtr(TrustedImmPtr(nullptr), JITCompiler::Address(scratchGPR1, -(offset + sizeof(JSValue) + sizeof(void*))));
 9409 
 9410     // We have scratchGPR1 = new storage, scratchGPR2 = scratch
 9411     for (ptrdiff_t offset = 0; offset &lt; static_cast&lt;ptrdiff_t&gt;(oldSize); offset += sizeof(void*)) {
 9412         m_jit.loadPtr(JITCompiler::Address(oldStorageGPR, -(offset + sizeof(JSValue) + sizeof(void*))), scratchGPR2);
 9413         m_jit.storePtr(scratchGPR2, JITCompiler::Address(scratchGPR1, -(offset + sizeof(JSValue) + sizeof(void*))));
 9414     }
 9415 
 9416     storageResult(scratchGPR1, node);
 9417 }
 9418 
 9419 void SpeculativeJIT::compileNukeStructureAndSetButterfly(Node* node)
 9420 {
 9421     SpeculateCellOperand base(this, node-&gt;child1());
 9422     StorageOperand storage(this, node-&gt;child2());
 9423 
 9424     GPRReg baseGPR = base.gpr();
 9425     GPRReg storageGPR = storage.gpr();
 9426 
 9427     m_jit.nukeStructureAndStoreButterfly(vm(), storageGPR, baseGPR);
 9428 
 9429     noResult(node);
 9430 }
 9431 
 9432 void SpeculativeJIT::compileGetButterfly(Node* node)
 9433 {
 9434     SpeculateCellOperand base(this, node-&gt;child1());
 9435     GPRTemporary result(this, Reuse, base);
 9436 
 9437     GPRReg baseGPR = base.gpr();
 9438     GPRReg resultGPR = result.gpr();
 9439 
 9440     m_jit.loadPtr(JITCompiler::Address(baseGPR, JSObject::butterflyOffset()), resultGPR);
 9441 
 9442     storageResult(resultGPR, node);
 9443 }
 9444 
 9445 static void allocateTemporaryRegistersForSnippet(SpeculativeJIT* jit, Vector&lt;GPRTemporary&gt;&amp; gpHolders, Vector&lt;FPRTemporary&gt;&amp; fpHolders, Vector&lt;GPRReg&gt;&amp; gpScratch, Vector&lt;FPRReg&gt;&amp; fpScratch, Snippet&amp; snippet)
 9446 {
 9447     for (unsigned i = 0; i &lt; snippet.numGPScratchRegisters; ++i) {
 9448         GPRTemporary temporary(jit);
 9449         gpScratch.append(temporary.gpr());
 9450         gpHolders.append(WTFMove(temporary));
 9451     }
 9452 
 9453     for (unsigned i = 0; i &lt; snippet.numFPScratchRegisters; ++i) {
 9454         FPRTemporary temporary(jit);
 9455         fpScratch.append(temporary.fpr());
 9456         fpHolders.append(WTFMove(temporary));
 9457     }
 9458 }
 9459 
 9460 void SpeculativeJIT::compileCallDOM(Node* node)
 9461 {
 9462     const DOMJIT::Signature* signature = node-&gt;signature();
 9463 
 9464     // FIXME: We should have a way to call functions with the vector of registers.
 9465     // https://bugs.webkit.org/show_bug.cgi?id=163099
 9466     Vector&lt;Variant&lt;SpeculateCellOperand, SpeculateInt32Operand, SpeculateBooleanOperand&gt;, JSC_DOMJIT_SIGNATURE_MAX_ARGUMENTS_INCLUDING_THIS&gt; operands;
 9467     Vector&lt;GPRReg, JSC_DOMJIT_SIGNATURE_MAX_ARGUMENTS_INCLUDING_THIS&gt; regs;
 9468 
 9469     auto appendCell = [&amp;](Edge&amp; edge) {
 9470         SpeculateCellOperand operand(this, edge);
 9471         regs.append(operand.gpr());
 9472         operands.append(WTFMove(operand));
 9473     };
 9474 
 9475     auto appendString = [&amp;](Edge&amp; edge) {
 9476         SpeculateCellOperand operand(this, edge);
 9477         GPRReg gpr = operand.gpr();
 9478         regs.append(gpr);
 9479         speculateString(edge, gpr);
 9480         operands.append(WTFMove(operand));
 9481     };
 9482 
 9483     auto appendInt32 = [&amp;](Edge&amp; edge) {
 9484         SpeculateInt32Operand operand(this, edge);
 9485         regs.append(operand.gpr());
 9486         operands.append(WTFMove(operand));
 9487     };
 9488 
 9489     auto appendBoolean = [&amp;](Edge&amp; edge) {
 9490         SpeculateBooleanOperand operand(this, edge);
 9491         regs.append(operand.gpr());
 9492         operands.append(WTFMove(operand));
 9493     };
 9494 
 9495     unsigned index = 0;
 9496     m_jit.graph().doToChildren(node, [&amp;](Edge edge) {
 9497         if (!index)
 9498             appendCell(edge);
 9499         else {
 9500             switch (signature-&gt;arguments[index - 1]) {
 9501             case SpecString:
 9502                 appendString(edge);
 9503                 break;
 9504             case SpecInt32Only:
 9505                 appendInt32(edge);
 9506                 break;
 9507             case SpecBoolean:
 9508                 appendBoolean(edge);
 9509                 break;
 9510             default:
 9511                 RELEASE_ASSERT_NOT_REACHED();
 9512                 break;
 9513             }
 9514         }
 9515         ++index;
 9516     });
 9517 
 9518     JSValueRegsTemporary result(this);
 9519     JSValueRegs resultRegs = result.regs();
 9520 
 9521     flushRegisters();
 9522 
<a name="238" id="anc238"></a><span class="line-added"> 9523     // FIXME: Revisit JSGlobalObject.</span>
<span class="line-added"> 9524     // https://bugs.webkit.org/show_bug.cgi?id=203204</span>
 9525     auto function = CFunctionPtr(signature-&gt;functionWithoutTypeCheck);
 9526     unsigned argumentCountIncludingThis = signature-&gt;argumentCount + 1;
 9527     switch (argumentCountIncludingThis) {
 9528     case 1:
<a name="239" id="anc239"></a><span class="line-modified"> 9529         callOperation(reinterpret_cast&lt;J_JITOperation_GP&gt;(function.get()), extractResult(resultRegs), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), regs[0]);</span>
 9530         break;
 9531     case 2:
<a name="240" id="anc240"></a><span class="line-modified"> 9532         callOperation(reinterpret_cast&lt;J_JITOperation_GPP&gt;(function.get()), extractResult(resultRegs), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), regs[0], regs[1]);</span>
 9533         break;
 9534     case 3:
<a name="241" id="anc241"></a><span class="line-modified"> 9535         callOperation(reinterpret_cast&lt;J_JITOperation_GPPP&gt;(function.get()), extractResult(resultRegs), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), regs[0], regs[1], regs[2]);</span>
 9536         break;
 9537     default:
 9538         RELEASE_ASSERT_NOT_REACHED();
 9539         break;
 9540     }
 9541 
 9542     m_jit.exceptionCheck();
 9543     jsValueResult(resultRegs, node);
 9544 }
 9545 
 9546 void SpeculativeJIT::compileCallDOMGetter(Node* node)
 9547 {
 9548     DOMJIT::CallDOMGetterSnippet* snippet = node-&gt;callDOMGetterData()-&gt;snippet;
 9549     if (!snippet) {
 9550         FunctionPtr&lt;OperationPtrTag&gt; getter = node-&gt;callDOMGetterData()-&gt;customAccessorGetter;
 9551         SpeculateCellOperand base(this, node-&gt;child1());
 9552         JSValueRegsTemporary result(this);
 9553 
 9554         JSValueRegs resultRegs = result.regs();
 9555         GPRReg baseGPR = base.gpr();
 9556 
 9557         flushRegisters();
<a name="242" id="anc242"></a><span class="line-modified"> 9558         m_jit.setupArguments&lt;J_JITOperation_GJI&gt;(TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), CCallHelpers::CellValue(baseGPR), identifierUID(node-&gt;callDOMGetterData()-&gt;identifierNumber));</span>
 9559         m_jit.storePtr(GPRInfo::callFrameRegister, &amp;vm().topCallFrame);
 9560         m_jit.emitStoreCodeOrigin(m_currentNode-&gt;origin.semantic);
 9561         m_jit.appendCall(getter.retagged&lt;CFunctionPtrTag&gt;());
 9562         m_jit.setupResults(resultRegs);
 9563 
 9564         m_jit.exceptionCheck();
 9565         jsValueResult(resultRegs, node);
 9566         return;
 9567     }
 9568 
 9569     Vector&lt;GPRReg&gt; gpScratch;
 9570     Vector&lt;FPRReg&gt; fpScratch;
 9571     Vector&lt;SnippetParams::Value&gt; regs;
 9572 
 9573     JSValueRegsTemporary result(this);
 9574     regs.append(result.regs());
 9575 
 9576     Edge&amp; baseEdge = node-&gt;child1();
 9577     SpeculateCellOperand base(this, baseEdge);
 9578     regs.append(SnippetParams::Value(base.gpr(), m_state.forNode(baseEdge).value()));
 9579 
 9580     Optional&lt;SpeculateCellOperand&gt; globalObject;
 9581     if (snippet-&gt;requireGlobalObject) {
 9582         Edge&amp; globalObjectEdge = node-&gt;child2();
 9583         globalObject.emplace(this, globalObjectEdge);
 9584         regs.append(SnippetParams::Value(globalObject-&gt;gpr(), m_state.forNode(globalObjectEdge).value()));
 9585     }
 9586 
 9587     Vector&lt;GPRTemporary&gt; gpTempraries;
 9588     Vector&lt;FPRTemporary&gt; fpTempraries;
 9589     allocateTemporaryRegistersForSnippet(this, gpTempraries, fpTempraries, gpScratch, fpScratch, *snippet);
 9590     SnippetParams params(this, WTFMove(regs), WTFMove(gpScratch), WTFMove(fpScratch));
 9591     snippet-&gt;generator()-&gt;run(m_jit, params);
 9592     jsValueResult(result.regs(), node);
 9593 }
 9594 
 9595 void SpeculativeJIT::compileCheckSubClass(Node* node)
 9596 {
 9597     const ClassInfo* classInfo = node-&gt;classInfo();
 9598     if (!classInfo-&gt;checkSubClassSnippet) {
 9599         SpeculateCellOperand base(this, node-&gt;child1());
 9600         GPRTemporary other(this);
 9601         GPRTemporary specified(this);
 9602 
 9603         GPRReg baseGPR = base.gpr();
 9604         GPRReg otherGPR = other.gpr();
 9605         GPRReg specifiedGPR = specified.gpr();
 9606 
 9607         m_jit.emitLoadStructure(vm(), baseGPR, otherGPR, specifiedGPR);
 9608         m_jit.loadPtr(CCallHelpers::Address(otherGPR, Structure::classInfoOffset()), otherGPR);
 9609         m_jit.move(CCallHelpers::TrustedImmPtr(node-&gt;classInfo()), specifiedGPR);
 9610 
 9611         CCallHelpers::Label loop = m_jit.label();
 9612         auto done = m_jit.branchPtr(CCallHelpers::Equal, otherGPR, specifiedGPR);
 9613         m_jit.loadPtr(CCallHelpers::Address(otherGPR, ClassInfo::offsetOfParentClass()), otherGPR);
 9614         m_jit.branchTestPtr(CCallHelpers::NonZero, otherGPR).linkTo(loop, &amp;m_jit);
 9615         speculationCheck(BadType, JSValueSource::unboxedCell(baseGPR), node-&gt;child1(), m_jit.jump());
 9616         done.link(&amp;m_jit);
 9617         noResult(node);
 9618         return;
 9619     }
 9620 
 9621     Ref&lt;Snippet&gt; snippet = classInfo-&gt;checkSubClassSnippet();
 9622 
 9623     Vector&lt;GPRReg&gt; gpScratch;
 9624     Vector&lt;FPRReg&gt; fpScratch;
 9625     Vector&lt;SnippetParams::Value&gt; regs;
 9626 
 9627     SpeculateCellOperand base(this, node-&gt;child1());
 9628     GPRReg baseGPR = base.gpr();
 9629     regs.append(SnippetParams::Value(baseGPR, m_state.forNode(node-&gt;child1()).value()));
 9630 
 9631     Vector&lt;GPRTemporary&gt; gpTempraries;
 9632     Vector&lt;FPRTemporary&gt; fpTempraries;
 9633     allocateTemporaryRegistersForSnippet(this, gpTempraries, fpTempraries, gpScratch, fpScratch, snippet.get());
 9634 
 9635     SnippetParams params(this, WTFMove(regs), WTFMove(gpScratch), WTFMove(fpScratch));
 9636     CCallHelpers::JumpList failureCases = snippet-&gt;generator()-&gt;run(m_jit, params);
 9637     speculationCheck(BadType, JSValueSource::unboxedCell(baseGPR), node-&gt;child1(), failureCases);
 9638     noResult(node);
 9639 }
 9640 
 9641 GPRReg SpeculativeJIT::temporaryRegisterForPutByVal(GPRTemporary&amp; temporary, ArrayMode arrayMode)
 9642 {
 9643     if (!putByValWillNeedExtraRegister(arrayMode))
 9644         return InvalidGPRReg;
 9645 
 9646     GPRTemporary realTemporary(this);
 9647     temporary.adopt(realTemporary);
 9648     return temporary.gpr();
 9649 }
 9650 
 9651 void SpeculativeJIT::compileToStringOrCallStringConstructorOrStringValueOf(Node* node)
 9652 {
 9653     ASSERT(node-&gt;op() != StringValueOf || node-&gt;child1().useKind() == UntypedUse);
 9654     switch (node-&gt;child1().useKind()) {
 9655     case NotCellUse: {
 9656         JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
 9657         JSValueRegs op1Regs = op1.jsValueRegs();
 9658 
 9659         GPRFlushedCallResult result(this);
 9660         GPRReg resultGPR = result.gpr();
 9661 
 9662         speculateNotCell(node-&gt;child1(), op1Regs);
 9663 
 9664         flushRegisters();
 9665 
 9666         if (node-&gt;op() == ToString)
<a name="243" id="anc243"></a><span class="line-modified"> 9667             callOperation(operationToString, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
 9668         else {
 9669             ASSERT(node-&gt;op() == CallStringConstructor);
<a name="244" id="anc244"></a><span class="line-modified"> 9670             callOperation(operationCallStringConstructor, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
 9671         }
 9672         m_jit.exceptionCheck();
 9673         cellResult(resultGPR, node);
 9674         return;
 9675     }
 9676 
 9677     case UntypedUse: {
 9678         JSValueOperand op1(this, node-&gt;child1());
 9679         JSValueRegs op1Regs = op1.jsValueRegs();
 9680         GPRReg op1PayloadGPR = op1Regs.payloadGPR();
 9681 
 9682         GPRFlushedCallResult result(this);
 9683         GPRReg resultGPR = result.gpr();
 9684 
 9685         flushRegisters();
 9686 
 9687         JITCompiler::Jump done;
 9688         if (node-&gt;child1()-&gt;prediction() &amp; SpecString) {
 9689             JITCompiler::Jump slowPath1 = m_jit.branchIfNotCell(op1.jsValueRegs());
 9690             JITCompiler::Jump slowPath2 = m_jit.branchIfNotString(op1PayloadGPR);
 9691             m_jit.move(op1PayloadGPR, resultGPR);
 9692             done = m_jit.jump();
 9693             slowPath1.link(&amp;m_jit);
 9694             slowPath2.link(&amp;m_jit);
 9695         }
 9696         if (node-&gt;op() == ToString)
<a name="245" id="anc245"></a><span class="line-modified"> 9697             callOperation(operationToString, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
 9698         else if (node-&gt;op() == StringValueOf)
<a name="246" id="anc246"></a><span class="line-modified"> 9699             callOperation(operationStringValueOf, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
 9700         else {
 9701             ASSERT(node-&gt;op() == CallStringConstructor);
<a name="247" id="anc247"></a><span class="line-modified"> 9702             callOperation(operationCallStringConstructor, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs);</span>
 9703         }
 9704         m_jit.exceptionCheck();
 9705         if (done.isSet())
 9706             done.link(&amp;m_jit);
 9707         cellResult(resultGPR, node);
 9708         return;
 9709     }
 9710 
 9711     case Int32Use:
 9712     case Int52RepUse:
 9713     case DoubleRepUse:
 9714         compileNumberToStringWithValidRadixConstant(node, 10);
 9715         return;
 9716 
 9717     default:
 9718         break;
 9719     }
 9720 
 9721     SpeculateCellOperand op1(this, node-&gt;child1());
 9722     GPRReg op1GPR = op1.gpr();
 9723 
 9724     switch (node-&gt;child1().useKind()) {
 9725     case StringObjectUse: {
 9726         GPRTemporary result(this);
 9727         GPRReg resultGPR = result.gpr();
 9728 
 9729         speculateStringObject(node-&gt;child1(), op1GPR);
 9730 
 9731         m_jit.loadPtr(JITCompiler::Address(op1GPR, JSWrapperObject::internalValueCellOffset()), resultGPR);
 9732         cellResult(resultGPR, node);
 9733         break;
 9734     }
 9735 
 9736     case StringOrStringObjectUse: {
 9737         GPRTemporary result(this);
 9738         GPRReg resultGPR = result.gpr();
 9739 
 9740         m_jit.load8(JITCompiler::Address(op1GPR, JSCell::typeInfoTypeOffset()), resultGPR);
 9741         JITCompiler::Jump isString = m_jit.branch32(JITCompiler::Equal, resultGPR, TrustedImm32(StringType));
 9742 
 9743         speculationCheck(BadType, JSValueSource::unboxedCell(op1GPR), node-&gt;child1().node(), m_jit.branch32(JITCompiler::NotEqual, resultGPR, TrustedImm32(StringObjectType)));
 9744         m_jit.loadPtr(JITCompiler::Address(op1GPR, JSWrapperObject::internalValueCellOffset()), resultGPR);
 9745         JITCompiler::Jump done = m_jit.jump();
 9746 
 9747         isString.link(&amp;m_jit);
 9748         m_jit.move(op1GPR, resultGPR);
 9749         done.link(&amp;m_jit);
 9750 
 9751         m_interpreter.filter(node-&gt;child1(), SpecString | SpecStringObject);
 9752 
 9753         cellResult(resultGPR, node);
 9754         break;
 9755     }
 9756 
 9757     case CellUse: {
 9758         GPRFlushedCallResult result(this);
 9759         GPRReg resultGPR = result.gpr();
 9760 
 9761         // We flush registers instead of silent spill/fill because in this mode we
 9762         // believe that most likely the input is not a string, and we need to take
 9763         // slow path.
 9764         flushRegisters();
 9765         JITCompiler::Jump done;
 9766         if (node-&gt;child1()-&gt;prediction() &amp; SpecString) {
 9767             JITCompiler::Jump needCall = m_jit.branchIfNotString(op1GPR);
 9768             m_jit.move(op1GPR, resultGPR);
 9769             done = m_jit.jump();
 9770             needCall.link(&amp;m_jit);
 9771         }
 9772         if (node-&gt;op() == ToString)
<a name="248" id="anc248"></a><span class="line-modified"> 9773             callOperation(operationToStringOnCell, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1GPR);</span>
 9774         else {
 9775             ASSERT(node-&gt;op() == CallStringConstructor);
<a name="249" id="anc249"></a><span class="line-modified"> 9776             callOperation(operationCallStringConstructorOnCell, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1GPR);</span>
 9777         }
 9778         m_jit.exceptionCheck();
 9779         if (done.isSet())
 9780             done.link(&amp;m_jit);
 9781         cellResult(resultGPR, node);
 9782         break;
 9783     }
 9784 
 9785     default:
 9786         RELEASE_ASSERT_NOT_REACHED();
 9787     }
 9788 }
 9789 
 9790 void SpeculativeJIT::compileNumberToStringWithValidRadixConstant(Node* node)
 9791 {
 9792     compileNumberToStringWithValidRadixConstant(node, node-&gt;validRadixConstant());
 9793 }
 9794 
 9795 void SpeculativeJIT::compileNumberToStringWithValidRadixConstant(Node* node, int32_t radix)
 9796 {
 9797     auto callToString = [&amp;] (auto operation, GPRReg resultGPR, auto valueReg) {
 9798         flushRegisters();
<a name="250" id="anc250"></a><span class="line-modified"> 9799         callOperation(operation, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueReg, TrustedImm32(radix));</span>
 9800         m_jit.exceptionCheck();
 9801         cellResult(resultGPR, node);
 9802     };
 9803 
 9804     switch (node-&gt;child1().useKind()) {
 9805     case Int32Use: {
 9806         SpeculateStrictInt32Operand value(this, node-&gt;child1());
 9807         GPRFlushedCallResult result(this);
 9808         callToString(operationInt32ToStringWithValidRadix, result.gpr(), value.gpr());
 9809         break;
 9810     }
 9811 
 9812 #if USE(JSVALUE64)
 9813     case Int52RepUse: {
 9814         SpeculateStrictInt52Operand value(this, node-&gt;child1());
 9815         GPRFlushedCallResult result(this);
 9816         callToString(operationInt52ToStringWithValidRadix, result.gpr(), value.gpr());
 9817         break;
 9818     }
 9819 #endif
 9820 
 9821     case DoubleRepUse: {
 9822         SpeculateDoubleOperand value(this, node-&gt;child1());
 9823         GPRFlushedCallResult result(this);
 9824         callToString(operationDoubleToStringWithValidRadix, result.gpr(), value.fpr());
 9825         break;
 9826     }
 9827 
 9828     default:
 9829         RELEASE_ASSERT_NOT_REACHED();
 9830     }
 9831 }
 9832 
 9833 void SpeculativeJIT::compileNumberToStringWithRadix(Node* node)
 9834 {
 9835     bool validRadixIsGuaranteed = false;
 9836     if (node-&gt;child2()-&gt;isInt32Constant()) {
 9837         int32_t radix = node-&gt;child2()-&gt;asInt32();
 9838         if (radix &gt;= 2 &amp;&amp; radix &lt;= 36)
 9839             validRadixIsGuaranteed = true;
 9840     }
 9841 
 9842     auto callToString = [&amp;] (auto operation, GPRReg resultGPR, auto valueReg, GPRReg radixGPR) {
 9843         flushRegisters();
<a name="251" id="anc251"></a><span class="line-modified"> 9844         callOperation(operation, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueReg, radixGPR);</span>
 9845         m_jit.exceptionCheck();
 9846         cellResult(resultGPR, node);
 9847     };
 9848 
 9849     switch (node-&gt;child1().useKind()) {
 9850     case Int32Use: {
 9851         SpeculateStrictInt32Operand value(this, node-&gt;child1());
 9852         SpeculateStrictInt32Operand radix(this, node-&gt;child2());
 9853         GPRFlushedCallResult result(this);
 9854         callToString(validRadixIsGuaranteed ? operationInt32ToStringWithValidRadix : operationInt32ToString, result.gpr(), value.gpr(), radix.gpr());
 9855         break;
 9856     }
 9857 
 9858 #if USE(JSVALUE64)
 9859     case Int52RepUse: {
 9860         SpeculateStrictInt52Operand value(this, node-&gt;child1());
 9861         SpeculateStrictInt32Operand radix(this, node-&gt;child2());
 9862         GPRFlushedCallResult result(this);
 9863         callToString(validRadixIsGuaranteed ? operationInt52ToStringWithValidRadix : operationInt52ToString, result.gpr(), value.gpr(), radix.gpr());
 9864         break;
 9865     }
 9866 #endif
 9867 
 9868     case DoubleRepUse: {
 9869         SpeculateDoubleOperand value(this, node-&gt;child1());
 9870         SpeculateStrictInt32Operand radix(this, node-&gt;child2());
 9871         GPRFlushedCallResult result(this);
 9872         callToString(validRadixIsGuaranteed ? operationDoubleToStringWithValidRadix : operationDoubleToString, result.gpr(), value.fpr(), radix.gpr());
 9873         break;
 9874     }
 9875 
 9876     default:
 9877         RELEASE_ASSERT_NOT_REACHED();
 9878     }
 9879 }
 9880 
 9881 void SpeculativeJIT::compileNewStringObject(Node* node)
 9882 {
 9883     SpeculateCellOperand operand(this, node-&gt;child1());
 9884 
 9885     GPRTemporary result(this);
 9886     GPRTemporary scratch1(this);
 9887     GPRTemporary scratch2(this);
 9888 
 9889     GPRReg operandGPR = operand.gpr();
 9890     GPRReg resultGPR = result.gpr();
 9891     GPRReg scratch1GPR = scratch1.gpr();
 9892     GPRReg scratch2GPR = scratch2.gpr();
 9893 
 9894     JITCompiler::JumpList slowPath;
 9895 
 9896     auto butterfly = TrustedImmPtr(nullptr);
 9897     emitAllocateJSObject&lt;StringObject&gt;(
 9898         resultGPR, TrustedImmPtr(node-&gt;structure()), butterfly, scratch1GPR, scratch2GPR,
 9899         slowPath);
 9900 
 9901     m_jit.storePtr(
 9902         TrustedImmPtr(StringObject::info()),
 9903         JITCompiler::Address(resultGPR, JSDestructibleObject::classInfoOffset()));
 9904 #if USE(JSVALUE64)
 9905     m_jit.store64(
 9906         operandGPR, JITCompiler::Address(resultGPR, JSWrapperObject::internalValueOffset()));
 9907 #else
 9908     m_jit.store32(
 9909         TrustedImm32(JSValue::CellTag),
 9910         JITCompiler::Address(resultGPR, JSWrapperObject::internalValueOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
 9911     m_jit.store32(
 9912         operandGPR,
 9913         JITCompiler::Address(resultGPR, JSWrapperObject::internalValueOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
 9914 #endif
 9915 
 9916     m_jit.mutatorFence(vm());
 9917 
 9918     addSlowPathGenerator(slowPathCall(
<a name="252" id="anc252"></a><span class="line-modified"> 9919         slowPath, this, operationNewStringObject, resultGPR, &amp;vm(), operandGPR, node-&gt;structure()));</span>
 9920 
 9921     cellResult(resultGPR, node);
 9922 }
 9923 
 9924 void SpeculativeJIT::compileNewSymbol(Node* node)
 9925 {
 9926     if (!node-&gt;child1()) {
 9927         flushRegisters();
 9928         GPRFlushedCallResult result(this);
 9929         GPRReg resultGPR = result.gpr();
<a name="253" id="anc253"></a><span class="line-modified"> 9930         callOperation(operationNewSymbol, resultGPR, &amp;vm());</span>
 9931         m_jit.exceptionCheck();
 9932         cellResult(resultGPR, node);
 9933         return;
 9934     }
 9935 
 9936 
 9937     ASSERT(node-&gt;child1().useKind() == KnownStringUse);
 9938     SpeculateCellOperand operand(this, node-&gt;child1());
 9939 
 9940     GPRReg stringGPR = operand.gpr();
 9941 
 9942     flushRegisters();
 9943     GPRFlushedCallResult result(this);
 9944     GPRReg resultGPR = result.gpr();
<a name="254" id="anc254"></a><span class="line-modified"> 9945     callOperation(operationNewSymbolWithDescription, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), stringGPR);</span>
 9946     m_jit.exceptionCheck();
 9947     cellResult(resultGPR, node);
 9948 }
 9949 
 9950 void SpeculativeJIT::compileNewTypedArrayWithSize(Node* node)
 9951 {
 9952     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
 9953     auto typedArrayType = node-&gt;typedArrayType();
 9954     RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;typedArrayStructureConcurrently(typedArrayType));
 9955     RELEASE_ASSERT(structure.get());
 9956 
 9957     SpeculateInt32Operand size(this, node-&gt;child1());
 9958     GPRReg sizeGPR = size.gpr();
 9959 
 9960     GPRTemporary result(this);
 9961     GPRTemporary storage(this);
 9962     GPRTemporary scratch(this);
 9963     GPRTemporary scratch2(this);
 9964     GPRReg resultGPR = result.gpr();
 9965     GPRReg storageGPR = storage.gpr();
 9966     GPRReg scratchGPR = scratch.gpr();
 9967     GPRReg scratchGPR2 = scratch2.gpr();
 9968 
 9969     JITCompiler::JumpList slowCases;
 9970 
 9971     m_jit.move(TrustedImmPtr(nullptr), storageGPR);
 9972 
 9973     slowCases.append(m_jit.branch32(
 9974         MacroAssembler::Above, sizeGPR, TrustedImm32(JSArrayBufferView::fastSizeLimit)));
 9975 
 9976     m_jit.move(sizeGPR, scratchGPR);
 9977     m_jit.lshift32(TrustedImm32(logElementSize(typedArrayType)), scratchGPR);
 9978     if (elementSize(typedArrayType) &lt; 8) {
 9979         m_jit.add32(TrustedImm32(7), scratchGPR);
 9980         m_jit.and32(TrustedImm32(~7), scratchGPR);
 9981     }
 9982     m_jit.emitAllocateVariableSized(
 9983         storageGPR, vm().primitiveGigacageAuxiliarySpace, scratchGPR, scratchGPR,
 9984         scratchGPR2, slowCases);
 9985 
 9986     MacroAssembler::Jump done = m_jit.branchTest32(MacroAssembler::Zero, sizeGPR);
 9987     m_jit.move(sizeGPR, scratchGPR);
 9988     if (elementSize(typedArrayType) != 4) {
 9989         if (elementSize(typedArrayType) &gt; 4)
 9990             m_jit.lshift32(TrustedImm32(logElementSize(typedArrayType) - 2), scratchGPR);
 9991         else {
 9992             if (elementSize(typedArrayType) &gt; 1)
 9993                 m_jit.lshift32(TrustedImm32(logElementSize(typedArrayType)), scratchGPR);
 9994             m_jit.add32(TrustedImm32(3), scratchGPR);
 9995             m_jit.urshift32(TrustedImm32(2), scratchGPR);
 9996         }
 9997     }
 9998     MacroAssembler::Label loop = m_jit.label();
 9999     m_jit.sub32(TrustedImm32(1), scratchGPR);
10000     m_jit.store32(
10001         TrustedImm32(0),
10002         MacroAssembler::BaseIndex(storageGPR, scratchGPR, MacroAssembler::TimesFour));
10003     m_jit.branchTest32(MacroAssembler::NonZero, scratchGPR).linkTo(loop, &amp;m_jit);
10004     done.link(&amp;m_jit);
10005 #if CPU(ARM64E)
10006     // sizeGPR is still boxed as a number and there is no 32-bit variant of the PAC instructions.
10007     m_jit.zeroExtend32ToPtr(sizeGPR, scratchGPR);
10008     m_jit.tagArrayPtr(scratchGPR, storageGPR);
10009 #endif
10010 
10011     auto butterfly = TrustedImmPtr(nullptr);
<a name="255" id="anc255"></a><span class="line-modified">10012     switch (typedArrayType) {</span>
<span class="line-modified">10013 #define TYPED_ARRAY_TYPE_CASE(name) \</span>
<span class="line-modified">10014     case Type ## name: \</span>
<span class="line-added">10015         emitAllocateJSObject&lt;JS##name##Array&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratchGPR, scratchGPR2, slowCases); \</span>
<span class="line-added">10016         break;</span>
<span class="line-added">10017     FOR_EACH_TYPED_ARRAY_TYPE_EXCLUDING_DATA_VIEW(TYPED_ARRAY_TYPE_CASE)</span>
<span class="line-added">10018 #undef TYPED_ARRAY_TYPE_CASE</span>
<span class="line-added">10019     case TypeDataView:</span>
<span class="line-added">10020         emitAllocateJSObject&lt;JSDataView&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratchGPR, scratchGPR2, slowCases);</span>
<span class="line-added">10021         break;</span>
<span class="line-added">10022     default:</span>
<span class="line-added">10023         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">10024         break;</span>
<span class="line-added">10025     }</span>
10026 
10027     m_jit.storePtr(
10028         storageGPR,
10029         MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfVector()));
10030     m_jit.store32(
10031         sizeGPR,
10032         MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfLength()));
10033     m_jit.store32(
10034         TrustedImm32(FastTypedArray),
10035         MacroAssembler::Address(resultGPR, JSArrayBufferView::offsetOfMode()));
10036 
10037     m_jit.mutatorFence(vm());
10038 
10039     addSlowPathGenerator(slowPathCall(
10040         slowCases, this, operationNewTypedArrayWithSizeForType(typedArrayType),
<a name="256" id="anc256"></a><span class="line-modified">10041         resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), structure, sizeGPR, storageGPR));</span>
10042 
10043     cellResult(resultGPR, node);
10044 }
10045 
10046 void SpeculativeJIT::compileNewRegexp(Node* node)
10047 {
10048     RegExp* regexp = node-&gt;castOperand&lt;RegExp*&gt;();
10049 
10050     GPRTemporary result(this);
10051     GPRTemporary scratch1(this);
10052     GPRTemporary scratch2(this);
10053     JSValueOperand lastIndex(this, node-&gt;child1());
10054 
10055     GPRReg resultGPR = result.gpr();
10056     GPRReg scratch1GPR = scratch1.gpr();
10057     GPRReg scratch2GPR = scratch2.gpr();
10058     JSValueRegs lastIndexRegs = lastIndex.jsValueRegs();
10059 
10060     JITCompiler::JumpList slowPath;
10061 
10062     auto structure = m_jit.graph().registerStructure(m_jit.graph().globalObjectFor(node-&gt;origin.semantic)-&gt;regExpStructure());
10063     auto butterfly = TrustedImmPtr(nullptr);
10064     emitAllocateJSObject&lt;RegExpObject&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowPath);
10065 
10066     m_jit.storePtr(
10067         TrustedImmPtr(node-&gt;cellOperand()),
10068         CCallHelpers::Address(resultGPR, RegExpObject::offsetOfRegExpAndLastIndexIsNotWritableFlag()));
10069     m_jit.storeValue(lastIndexRegs, CCallHelpers::Address(resultGPR, RegExpObject::offsetOfLastIndex()));
10070     m_jit.mutatorFence(vm());
10071 
<a name="257" id="anc257"></a><span class="line-modified">10072     addSlowPathGenerator(slowPathCall(slowPath, this, operationNewRegexpWithLastIndex, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), regexp, lastIndexRegs));</span>
10073 
10074     cellResult(resultGPR, node);
10075 }
10076 
10077 void SpeculativeJIT::speculateCellTypeWithoutTypeFiltering(
10078     Edge edge, GPRReg cellGPR, JSType jsType)
10079 {
10080     speculationCheck(
10081         BadType, JSValueSource::unboxedCell(cellGPR), edge,
10082         m_jit.branchIfNotType(cellGPR, jsType));
10083 }
10084 
10085 void SpeculativeJIT::speculateCellType(
10086     Edge edge, GPRReg cellGPR, SpeculatedType specType, JSType jsType)
10087 {
10088     DFG_TYPE_CHECK(
10089         JSValueSource::unboxedCell(cellGPR), edge, specType,
10090         m_jit.branchIfNotType(cellGPR, jsType));
10091 }
10092 
10093 void SpeculativeJIT::speculateInt32(Edge edge)
10094 {
10095     if (!needsTypeCheck(edge, SpecInt32Only))
10096         return;
10097 
10098     (SpeculateInt32Operand(this, edge)).gpr();
10099 }
10100 
10101 void SpeculativeJIT::speculateNumber(Edge edge)
10102 {
10103     if (!needsTypeCheck(edge, SpecBytecodeNumber))
10104         return;
10105 
10106     JSValueOperand value(this, edge, ManualOperandSpeculation);
10107 #if USE(JSVALUE64)
10108     GPRReg gpr = value.gpr();
10109     typeCheck(
10110         JSValueRegs(gpr), edge, SpecBytecodeNumber,
10111         m_jit.branchIfNotNumber(gpr));
10112 #else
10113     IGNORE_WARNINGS_BEGIN(&quot;enum-compare&quot;)
10114     static_assert(JSValue::Int32Tag &gt;= JSValue::LowestTag, &quot;Int32Tag is included in &gt;= JSValue::LowestTag range.&quot;);
10115     IGNORE_WARNINGS_END
10116     GPRReg tagGPR = value.tagGPR();
10117     DFG_TYPE_CHECK(
10118         value.jsValueRegs(), edge, ~SpecInt32Only,
10119         m_jit.branchIfInt32(tagGPR));
10120     DFG_TYPE_CHECK(
10121         value.jsValueRegs(), edge, SpecBytecodeNumber,
10122         m_jit.branch32(MacroAssembler::AboveOrEqual, tagGPR, TrustedImm32(JSValue::LowestTag)));
10123 #endif
10124 }
10125 
10126 void SpeculativeJIT::speculateRealNumber(Edge edge)
10127 {
10128     if (!needsTypeCheck(edge, SpecBytecodeRealNumber))
10129         return;
10130 
10131     JSValueOperand op1(this, edge, ManualOperandSpeculation);
10132     FPRTemporary result(this);
10133 
10134     JSValueRegs op1Regs = op1.jsValueRegs();
10135     FPRReg resultFPR = result.fpr();
10136 
10137 #if USE(JSVALUE64)
10138     GPRTemporary temp(this);
10139     GPRReg tempGPR = temp.gpr();
10140     m_jit.unboxDoubleWithoutAssertions(op1Regs.gpr(), tempGPR, resultFPR);
10141 #else
10142     FPRTemporary temp(this);
10143     FPRReg tempFPR = temp.fpr();
10144     unboxDouble(op1Regs.tagGPR(), op1Regs.payloadGPR(), resultFPR, tempFPR);
10145 #endif
10146 
10147     JITCompiler::Jump done = m_jit.branchIfNotNaN(resultFPR);
10148 
10149     typeCheck(op1Regs, edge, SpecBytecodeRealNumber, m_jit.branchIfNotInt32(op1Regs));
10150 
10151     done.link(&amp;m_jit);
10152 }
10153 
10154 void SpeculativeJIT::speculateDoubleRepReal(Edge edge)
10155 {
10156     if (!needsTypeCheck(edge, SpecDoubleReal))
10157         return;
10158 
10159     SpeculateDoubleOperand operand(this, edge);
10160     FPRReg fpr = operand.fpr();
10161     typeCheck(
10162         JSValueRegs(), edge, SpecDoubleReal,
10163         m_jit.branchIfNaN(fpr));
10164 }
10165 
10166 void SpeculativeJIT::speculateBoolean(Edge edge)
10167 {
10168     if (!needsTypeCheck(edge, SpecBoolean))
10169         return;
10170 
10171     (SpeculateBooleanOperand(this, edge)).gpr();
10172 }
10173 
10174 void SpeculativeJIT::speculateCell(Edge edge)
10175 {
10176     if (!needsTypeCheck(edge, SpecCellCheck))
10177         return;
10178 
10179     (SpeculateCellOperand(this, edge)).gpr();
10180 }
10181 
10182 void SpeculativeJIT::speculateCellOrOther(Edge edge)
10183 {
10184     if (!needsTypeCheck(edge, SpecCellCheck | SpecOther))
10185         return;
10186 
10187     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10188     GPRTemporary temp(this);
10189     GPRReg tempGPR = temp.gpr();
10190 
10191     MacroAssembler::Jump ok = m_jit.branchIfCell(operand.jsValueRegs());
10192     DFG_TYPE_CHECK(
10193         operand.jsValueRegs(), edge, SpecCellCheck | SpecOther,
10194         m_jit.branchIfNotOther(operand.jsValueRegs(), tempGPR));
10195     ok.link(&amp;m_jit);
10196 }
10197 
10198 void SpeculativeJIT::speculateObject(Edge edge, GPRReg cell)
10199 {
10200     DFG_TYPE_CHECK(JSValueSource::unboxedCell(cell), edge, SpecObject, m_jit.branchIfNotObject(cell));
10201 }
10202 
10203 void SpeculativeJIT::speculateObject(Edge edge)
10204 {
10205     if (!needsTypeCheck(edge, SpecObject))
10206         return;
10207 
10208     SpeculateCellOperand operand(this, edge);
10209     speculateObject(edge, operand.gpr());
10210 }
10211 
10212 void SpeculativeJIT::speculateFunction(Edge edge, GPRReg cell)
10213 {
10214     speculateCellType(edge, cell, SpecFunction, JSFunctionType);
10215 }
10216 
10217 void SpeculativeJIT::speculateFunction(Edge edge)
10218 {
10219     if (!needsTypeCheck(edge, SpecFunction))
10220         return;
10221 
10222     SpeculateCellOperand operand(this, edge);
10223     speculateFunction(edge, operand.gpr());
10224 }
10225 
10226 void SpeculativeJIT::speculateFinalObject(Edge edge, GPRReg cell)
10227 {
10228     speculateCellType(edge, cell, SpecFinalObject, FinalObjectType);
10229 }
10230 
10231 void SpeculativeJIT::speculateFinalObject(Edge edge)
10232 {
10233     if (!needsTypeCheck(edge, SpecFinalObject))
10234         return;
10235 
10236     SpeculateCellOperand operand(this, edge);
10237     speculateFinalObject(edge, operand.gpr());
10238 }
10239 
10240 void SpeculativeJIT::speculateRegExpObject(Edge edge, GPRReg cell)
10241 {
10242     speculateCellType(edge, cell, SpecRegExpObject, RegExpObjectType);
10243 }
10244 
10245 void SpeculativeJIT::speculateRegExpObject(Edge edge)
10246 {
10247     if (!needsTypeCheck(edge, SpecRegExpObject))
10248         return;
10249 
10250     SpeculateCellOperand operand(this, edge);
10251     speculateRegExpObject(edge, operand.gpr());
10252 }
10253 
10254 void SpeculativeJIT::speculateArray(Edge edge, GPRReg cell)
10255 {
10256     speculateCellType(edge, cell, SpecArray, ArrayType);
10257 }
10258 
10259 void SpeculativeJIT::speculateArray(Edge edge)
10260 {
10261     if (!needsTypeCheck(edge, SpecArray))
10262         return;
10263 
10264     SpeculateCellOperand operand(this, edge);
10265     speculateArray(edge, operand.gpr());
10266 }
10267 
10268 void SpeculativeJIT::speculateProxyObject(Edge edge, GPRReg cell)
10269 {
10270     speculateCellType(edge, cell, SpecProxyObject, ProxyObjectType);
10271 }
10272 
10273 void SpeculativeJIT::speculateProxyObject(Edge edge)
10274 {
10275     if (!needsTypeCheck(edge, SpecProxyObject))
10276         return;
10277 
10278     SpeculateCellOperand operand(this, edge);
10279     speculateProxyObject(edge, operand.gpr());
10280 }
10281 
10282 void SpeculativeJIT::speculateDerivedArray(Edge edge, GPRReg cell)
10283 {
10284     speculateCellType(edge, cell, SpecDerivedArray, DerivedArrayType);
10285 }
10286 
10287 void SpeculativeJIT::speculateDerivedArray(Edge edge)
10288 {
10289     if (!needsTypeCheck(edge, SpecDerivedArray))
10290         return;
10291 
10292     SpeculateCellOperand operand(this, edge);
10293     speculateDerivedArray(edge, operand.gpr());
10294 }
10295 
<a name="258" id="anc258"></a><span class="line-added">10296 void SpeculativeJIT::speculatePromiseObject(Edge edge, GPRReg cell)</span>
<span class="line-added">10297 {</span>
<span class="line-added">10298     speculateCellType(edge, cell, SpecPromiseObject, JSPromiseType);</span>
<span class="line-added">10299 }</span>
<span class="line-added">10300 </span>
<span class="line-added">10301 void SpeculativeJIT::speculatePromiseObject(Edge edge)</span>
<span class="line-added">10302 {</span>
<span class="line-added">10303     if (!needsTypeCheck(edge, SpecPromiseObject))</span>
<span class="line-added">10304         return;</span>
<span class="line-added">10305 </span>
<span class="line-added">10306     SpeculateCellOperand operand(this, edge);</span>
<span class="line-added">10307     speculatePromiseObject(edge, operand.gpr());</span>
<span class="line-added">10308 }</span>
<span class="line-added">10309 </span>
<span class="line-added">10310 void SpeculativeJIT::speculateDateObject(Edge edge, GPRReg cell)</span>
<span class="line-added">10311 {</span>
<span class="line-added">10312     speculateCellType(edge, cell, SpecDateObject, JSDateType);</span>
<span class="line-added">10313 }</span>
<span class="line-added">10314 </span>
<span class="line-added">10315 void SpeculativeJIT::speculateDateObject(Edge edge)</span>
<span class="line-added">10316 {</span>
<span class="line-added">10317     if (!needsTypeCheck(edge, SpecDateObject))</span>
<span class="line-added">10318         return;</span>
<span class="line-added">10319 </span>
<span class="line-added">10320     SpeculateCellOperand operand(this, edge);</span>
<span class="line-added">10321     speculateDateObject(edge, operand.gpr());</span>
<span class="line-added">10322 }</span>
<span class="line-added">10323 </span>
10324 void SpeculativeJIT::speculateMapObject(Edge edge, GPRReg cell)
10325 {
10326     speculateCellType(edge, cell, SpecMapObject, JSMapType);
10327 }
10328 
10329 void SpeculativeJIT::speculateMapObject(Edge edge)
10330 {
10331     if (!needsTypeCheck(edge, SpecMapObject))
10332         return;
10333 
10334     SpeculateCellOperand operand(this, edge);
10335     speculateMapObject(edge, operand.gpr());
10336 }
10337 
10338 void SpeculativeJIT::speculateSetObject(Edge edge, GPRReg cell)
10339 {
10340     speculateCellType(edge, cell, SpecSetObject, JSSetType);
10341 }
10342 
10343 void SpeculativeJIT::speculateSetObject(Edge edge)
10344 {
10345     if (!needsTypeCheck(edge, SpecSetObject))
10346         return;
10347 
10348     SpeculateCellOperand operand(this, edge);
10349     speculateSetObject(edge, operand.gpr());
10350 }
10351 
10352 void SpeculativeJIT::speculateWeakMapObject(Edge edge, GPRReg cell)
10353 {
10354     speculateCellType(edge, cell, SpecWeakMapObject, JSWeakMapType);
10355 }
10356 
10357 void SpeculativeJIT::speculateWeakMapObject(Edge edge)
10358 {
10359     if (!needsTypeCheck(edge, SpecWeakMapObject))
10360         return;
10361 
10362     SpeculateCellOperand operand(this, edge);
10363     speculateWeakMapObject(edge, operand.gpr());
10364 }
10365 
10366 void SpeculativeJIT::speculateWeakSetObject(Edge edge, GPRReg cell)
10367 {
10368     speculateCellType(edge, cell, SpecWeakSetObject, JSWeakSetType);
10369 }
10370 
10371 void SpeculativeJIT::speculateWeakSetObject(Edge edge)
10372 {
10373     if (!needsTypeCheck(edge, SpecWeakSetObject))
10374         return;
10375 
10376     SpeculateCellOperand operand(this, edge);
10377     speculateWeakSetObject(edge, operand.gpr());
10378 }
10379 
10380 void SpeculativeJIT::speculateDataViewObject(Edge edge, GPRReg cell)
10381 {
10382     speculateCellType(edge, cell, SpecDataViewObject, DataViewType);
10383 }
10384 
10385 void SpeculativeJIT::speculateDataViewObject(Edge edge)
10386 {
10387     if (!needsTypeCheck(edge, SpecDataViewObject))
10388         return;
10389 
10390     SpeculateCellOperand operand(this, edge);
10391     speculateDataViewObject(edge, operand.gpr());
10392 }
10393 
10394 void SpeculativeJIT::speculateObjectOrOther(Edge edge)
10395 {
10396     if (!needsTypeCheck(edge, SpecObject | SpecOther))
10397         return;
10398 
10399     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10400     GPRTemporary temp(this);
10401     GPRReg tempGPR = temp.gpr();
10402     MacroAssembler::Jump notCell = m_jit.branchIfNotCell(operand.jsValueRegs());
10403     GPRReg gpr = operand.jsValueRegs().payloadGPR();
10404     DFG_TYPE_CHECK(
10405         operand.jsValueRegs(), edge, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(gpr));
10406     MacroAssembler::Jump done = m_jit.jump();
10407     notCell.link(&amp;m_jit);
10408     DFG_TYPE_CHECK(
10409         operand.jsValueRegs(), edge, SpecCellCheck | SpecOther,
10410         m_jit.branchIfNotOther(operand.jsValueRegs(), tempGPR));
10411     done.link(&amp;m_jit);
10412 }
10413 
10414 void SpeculativeJIT::speculateString(Edge edge, GPRReg cell)
10415 {
10416     DFG_TYPE_CHECK(
10417         JSValueSource::unboxedCell(cell), edge, SpecString | ~SpecCellCheck, m_jit.branchIfNotString(cell));
10418 }
10419 
10420 void SpeculativeJIT::speculateStringOrOther(Edge edge, JSValueRegs regs, GPRReg scratch)
10421 {
10422     JITCompiler::Jump notCell = m_jit.branchIfNotCell(regs);
10423     GPRReg cell = regs.payloadGPR();
10424     DFG_TYPE_CHECK(regs, edge, (~SpecCellCheck) | SpecString, m_jit.branchIfNotString(cell));
10425     JITCompiler::Jump done = m_jit.jump();
10426     notCell.link(&amp;m_jit);
10427     DFG_TYPE_CHECK(regs, edge, SpecCellCheck | SpecOther, m_jit.branchIfNotOther(regs, scratch));
10428     done.link(&amp;m_jit);
10429 }
10430 
10431 void SpeculativeJIT::speculateStringOrOther(Edge edge)
10432 {
10433     if (!needsTypeCheck(edge, SpecString | SpecOther))
10434         return;
10435 
10436     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10437     GPRTemporary temp(this);
10438     JSValueRegs regs = operand.jsValueRegs();
10439     GPRReg tempGPR = temp.gpr();
10440     speculateStringOrOther(edge, regs, tempGPR);
10441 }
10442 
10443 void SpeculativeJIT::speculateStringIdentAndLoadStorage(Edge edge, GPRReg string, GPRReg storage)
10444 {
10445     m_jit.loadPtr(MacroAssembler::Address(string, JSString::offsetOfValue()), storage);
10446 
10447     if (!needsTypeCheck(edge, SpecStringIdent | ~SpecString))
10448         return;
10449 
10450     speculationCheck(
10451         BadType, JSValueSource::unboxedCell(string), edge,
10452         m_jit.branchIfRopeStringImpl(storage));
10453     speculationCheck(
10454         BadType, JSValueSource::unboxedCell(string), edge, m_jit.branchTest32(
10455             MacroAssembler::Zero,
10456             MacroAssembler::Address(storage, StringImpl::flagsOffset()),
10457             MacroAssembler::TrustedImm32(StringImpl::flagIsAtom())));
10458 
10459     m_interpreter.filter(edge, SpecStringIdent | ~SpecString);
10460 }
10461 
10462 void SpeculativeJIT::speculateStringIdent(Edge edge, GPRReg string)
10463 {
10464     if (!needsTypeCheck(edge, SpecStringIdent))
10465         return;
10466 
10467     GPRTemporary temp(this);
10468     speculateStringIdentAndLoadStorage(edge, string, temp.gpr());
10469 }
10470 
10471 void SpeculativeJIT::speculateStringIdent(Edge edge)
10472 {
10473     if (!needsTypeCheck(edge, SpecStringIdent))
10474         return;
10475 
10476     SpeculateCellOperand operand(this, edge);
10477     GPRReg gpr = operand.gpr();
10478     speculateString(edge, gpr);
10479     speculateStringIdent(edge, gpr);
10480 }
10481 
10482 void SpeculativeJIT::speculateString(Edge edge)
10483 {
10484     if (!needsTypeCheck(edge, SpecString))
10485         return;
10486 
10487     SpeculateCellOperand operand(this, edge);
10488     speculateString(edge, operand.gpr());
10489 }
10490 
10491 void SpeculativeJIT::speculateStringObject(Edge edge, GPRReg cellGPR)
10492 {
10493     DFG_TYPE_CHECK(JSValueSource::unboxedCell(cellGPR), edge, ~SpecCellCheck | SpecStringObject, m_jit.branchIfNotType(cellGPR, StringObjectType));
10494 }
10495 
10496 void SpeculativeJIT::speculateStringObject(Edge edge)
10497 {
10498     if (!needsTypeCheck(edge, SpecStringObject))
10499         return;
10500 
10501     SpeculateCellOperand operand(this, edge);
10502     GPRReg gpr = operand.gpr();
10503     speculateStringObject(edge, gpr);
10504 }
10505 
10506 void SpeculativeJIT::speculateStringOrStringObject(Edge edge)
10507 {
10508     if (!needsTypeCheck(edge, SpecString | SpecStringObject))
10509         return;
10510 
10511     SpeculateCellOperand operand(this, edge);
10512     GPRReg gpr = operand.gpr();
10513     if (!needsTypeCheck(edge, SpecString | SpecStringObject))
10514         return;
10515 
10516     GPRTemporary typeTemp(this);
10517     GPRReg typeGPR = typeTemp.gpr();
10518 
10519     m_jit.load8(JITCompiler::Address(gpr, JSCell::typeInfoTypeOffset()), typeGPR);
10520 
10521     JITCompiler::Jump isString = m_jit.branch32(JITCompiler::Equal, typeGPR, TrustedImm32(StringType));
10522     speculationCheck(BadType, JSValueSource::unboxedCell(gpr), edge.node(), m_jit.branch32(JITCompiler::NotEqual, typeGPR, TrustedImm32(StringObjectType)));
10523     isString.link(&amp;m_jit);
10524 
10525     m_interpreter.filter(edge, SpecString | SpecStringObject);
10526 }
10527 
10528 void SpeculativeJIT::speculateNotStringVar(Edge edge)
10529 {
10530     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10531     GPRTemporary temp(this);
10532     GPRReg tempGPR = temp.gpr();
10533 
10534     JITCompiler::Jump notCell = m_jit.branchIfNotCell(operand.jsValueRegs());
10535     GPRReg cell = operand.jsValueRegs().payloadGPR();
10536 
10537     JITCompiler::Jump notString = m_jit.branchIfNotString(cell);
10538 
10539     speculateStringIdentAndLoadStorage(edge, cell, tempGPR);
10540 
10541     notString.link(&amp;m_jit);
10542     notCell.link(&amp;m_jit);
10543 }
10544 
10545 void SpeculativeJIT::speculateNotSymbol(Edge edge)
10546 {
10547     if (!needsTypeCheck(edge, ~SpecSymbol))
10548         return;
10549 
10550     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10551     auto valueRegs = operand.jsValueRegs();
10552     GPRReg value = valueRegs.payloadGPR();
10553     JITCompiler::Jump notCell;
10554 
10555     bool needsCellCheck = needsTypeCheck(edge, SpecCell);
10556     if (needsCellCheck)
10557         notCell = m_jit.branchIfNotCell(valueRegs);
10558 
10559     speculationCheck(BadType, JSValueSource::unboxedCell(value), edge.node(), m_jit.branchIfSymbol(value));
10560 
10561     if (needsCellCheck)
10562         notCell.link(&amp;m_jit);
10563 
10564     m_interpreter.filter(edge, ~SpecSymbol);
10565 }
10566 
10567 void SpeculativeJIT::speculateSymbol(Edge edge, GPRReg cell)
10568 {
10569     DFG_TYPE_CHECK(JSValueSource::unboxedCell(cell), edge, ~SpecCellCheck | SpecSymbol, m_jit.branchIfNotSymbol(cell));
10570 }
10571 
10572 void SpeculativeJIT::speculateSymbol(Edge edge)
10573 {
10574     if (!needsTypeCheck(edge, SpecSymbol))
10575         return;
10576 
10577     SpeculateCellOperand operand(this, edge);
10578     speculateSymbol(edge, operand.gpr());
10579 }
10580 
10581 void SpeculativeJIT::speculateBigInt(Edge edge, GPRReg cell)
10582 {
10583     DFG_TYPE_CHECK(JSValueSource::unboxedCell(cell), edge, ~SpecCellCheck | SpecBigInt, m_jit.branchIfNotBigInt(cell));
10584 }
10585 
10586 void SpeculativeJIT::speculateBigInt(Edge edge)
10587 {
10588     if (!needsTypeCheck(edge, SpecBigInt))
10589         return;
10590 
10591     SpeculateCellOperand operand(this, edge);
10592     speculateBigInt(edge, operand.gpr());
10593 }
10594 
10595 void SpeculativeJIT::speculateNotCell(Edge edge, JSValueRegs regs)
10596 {
10597     DFG_TYPE_CHECK(regs, edge, ~SpecCellCheck, m_jit.branchIfCell(regs));
10598 }
10599 
10600 void SpeculativeJIT::speculateNotCell(Edge edge)
10601 {
10602     if (!needsTypeCheck(edge, ~SpecCellCheck))
10603         return;
10604 
10605     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10606     speculateNotCell(edge, operand.jsValueRegs());
10607 }
10608 
10609 void SpeculativeJIT::speculateOther(Edge edge, JSValueRegs regs, GPRReg tempGPR)
10610 {
10611     DFG_TYPE_CHECK(regs, edge, SpecOther, m_jit.branchIfNotOther(regs, tempGPR));
10612 }
10613 
10614 void SpeculativeJIT::speculateOther(Edge edge, JSValueRegs regs)
10615 {
10616     if (!needsTypeCheck(edge, SpecOther))
10617         return;
10618 
10619     GPRTemporary temp(this);
10620     GPRReg tempGPR = temp.gpr();
10621     speculateOther(edge, regs, tempGPR);
10622 }
10623 
10624 void SpeculativeJIT::speculateOther(Edge edge)
10625 {
10626     if (!needsTypeCheck(edge, SpecOther))
10627         return;
10628 
10629     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10630     speculateOther(edge, operand.jsValueRegs());
10631 }
10632 
10633 void SpeculativeJIT::speculateMisc(Edge edge, JSValueRegs regs)
10634 {
10635 #if USE(JSVALUE64)
10636     DFG_TYPE_CHECK(
10637         regs, edge, SpecMisc,
<a name="259" id="anc259"></a><span class="line-modified">10638         m_jit.branch64(MacroAssembler::Above, regs.gpr(), MacroAssembler::TrustedImm64(JSValue::MiscTag)));</span>
10639 #else
10640     IGNORE_WARNINGS_BEGIN(&quot;enum-compare&quot;)
10641     static_assert(JSValue::Int32Tag &gt;= JSValue::UndefinedTag, &quot;Int32Tag is included in &gt;= JSValue::UndefinedTag range.&quot;);
10642     IGNORE_WARNINGS_END
10643     DFG_TYPE_CHECK(
10644         regs, edge, ~SpecInt32Only,
10645         m_jit.branchIfInt32(regs.tagGPR()));
10646     DFG_TYPE_CHECK(
10647         regs, edge, SpecMisc,
10648         m_jit.branch32(MacroAssembler::Below, regs.tagGPR(), MacroAssembler::TrustedImm32(JSValue::UndefinedTag)));
10649 #endif
10650 }
10651 
10652 void SpeculativeJIT::speculateMisc(Edge edge)
10653 {
10654     if (!needsTypeCheck(edge, SpecMisc))
10655         return;
10656 
10657     JSValueOperand operand(this, edge, ManualOperandSpeculation);
10658     speculateMisc(edge, operand.jsValueRegs());
10659 }
10660 
10661 void SpeculativeJIT::speculate(Node*, Edge edge)
10662 {
10663     switch (edge.useKind()) {
10664     case UntypedUse:
10665         break;
10666     case DoubleRepUse:
10667     case Int52RepUse:
10668     case KnownInt32Use:
10669     case KnownCellUse:
10670     case KnownStringUse:
10671     case KnownPrimitiveUse:
10672     case KnownOtherUse:
10673     case KnownBooleanUse:
10674         ASSERT(!m_interpreter.needsTypeCheck(edge));
10675         break;
10676     case Int32Use:
10677         speculateInt32(edge);
10678         break;
10679     case NumberUse:
10680         speculateNumber(edge);
10681         break;
10682     case RealNumberUse:
10683         speculateRealNumber(edge);
10684         break;
10685     case DoubleRepRealUse:
10686         speculateDoubleRepReal(edge);
10687         break;
10688 #if USE(JSVALUE64)
10689     case AnyIntUse:
10690         speculateAnyInt(edge);
10691         break;
10692     case DoubleRepAnyIntUse:
10693         speculateDoubleRepAnyInt(edge);
10694         break;
10695 #endif
10696     case BooleanUse:
10697         speculateBoolean(edge);
10698         break;
10699     case CellUse:
10700         speculateCell(edge);
10701         break;
10702     case CellOrOtherUse:
10703         speculateCellOrOther(edge);
10704         break;
10705     case ObjectUse:
10706         speculateObject(edge);
10707         break;
10708     case FunctionUse:
10709         speculateFunction(edge);
10710         break;
10711     case ArrayUse:
10712         speculateArray(edge);
10713         break;
10714     case FinalObjectUse:
10715         speculateFinalObject(edge);
10716         break;
10717     case RegExpObjectUse:
10718         speculateRegExpObject(edge);
10719         break;
<a name="260" id="anc260"></a><span class="line-added">10720     case PromiseObjectUse:</span>
<span class="line-added">10721         speculatePromiseObject(edge);</span>
<span class="line-added">10722         break;</span>
10723     case ProxyObjectUse:
10724         speculateProxyObject(edge);
10725         break;
10726     case DerivedArrayUse:
10727         speculateDerivedArray(edge);
10728         break;
<a name="261" id="anc261"></a><span class="line-added">10729     case DateObjectUse:</span>
<span class="line-added">10730         speculateDateObject(edge);</span>
<span class="line-added">10731         break;</span>
10732     case MapObjectUse:
10733         speculateMapObject(edge);
10734         break;
10735     case SetObjectUse:
10736         speculateSetObject(edge);
10737         break;
10738     case WeakMapObjectUse:
10739         speculateWeakMapObject(edge);
10740         break;
10741     case WeakSetObjectUse:
10742         speculateWeakSetObject(edge);
10743         break;
10744     case DataViewObjectUse:
10745         speculateDataViewObject(edge);
10746         break;
10747     case ObjectOrOtherUse:
10748         speculateObjectOrOther(edge);
10749         break;
10750     case StringIdentUse:
10751         speculateStringIdent(edge);
10752         break;
10753     case StringUse:
10754         speculateString(edge);
10755         break;
10756     case StringOrOtherUse:
10757         speculateStringOrOther(edge);
10758         break;
10759     case SymbolUse:
10760         speculateSymbol(edge);
10761         break;
10762     case BigIntUse:
10763         speculateBigInt(edge);
10764         break;
10765     case StringObjectUse:
10766         speculateStringObject(edge);
10767         break;
10768     case StringOrStringObjectUse:
10769         speculateStringOrStringObject(edge);
10770         break;
10771     case NotStringVarUse:
10772         speculateNotStringVar(edge);
10773         break;
10774     case NotSymbolUse:
10775         speculateNotSymbol(edge);
10776         break;
10777     case NotCellUse:
10778         speculateNotCell(edge);
10779         break;
10780     case OtherUse:
10781         speculateOther(edge);
10782         break;
10783     case MiscUse:
10784         speculateMisc(edge);
10785         break;
10786     default:
10787         RELEASE_ASSERT_NOT_REACHED();
10788         break;
10789     }
10790 }
10791 
10792 void SpeculativeJIT::emitSwitchIntJump(
10793     SwitchData* data, GPRReg value, GPRReg scratch)
10794 {
10795     SimpleJumpTable&amp; table = m_jit.codeBlock()-&gt;switchJumpTable(data-&gt;switchTableIndex);
10796     table.ensureCTITable();
10797     m_jit.sub32(Imm32(table.min), value);
10798     addBranch(
10799         m_jit.branch32(JITCompiler::AboveOrEqual, value, Imm32(table.ctiOffsets.size())),
10800         data-&gt;fallThrough.block);
10801     m_jit.move(TrustedImmPtr(table.ctiOffsets.begin()), scratch);
10802     m_jit.loadPtr(JITCompiler::BaseIndex(scratch, value, JITCompiler::timesPtr()), scratch);
10803 
10804     m_jit.farJump(scratch, JSSwitchPtrTag);
10805     data-&gt;didUseJumpTable = true;
10806 }
10807 
10808 void SpeculativeJIT::emitSwitchImm(Node* node, SwitchData* data)
10809 {
10810     switch (node-&gt;child1().useKind()) {
10811     case Int32Use: {
10812         SpeculateInt32Operand value(this, node-&gt;child1());
10813         GPRTemporary temp(this);
10814         emitSwitchIntJump(data, value.gpr(), temp.gpr());
10815         noResult(node);
10816         break;
10817     }
10818 
10819     case UntypedUse: {
10820         JSValueOperand value(this, node-&gt;child1());
10821         GPRTemporary temp(this);
10822         JSValueRegs valueRegs = value.jsValueRegs();
10823         GPRReg scratch = temp.gpr();
10824 
10825         value.use();
10826 
10827         auto notInt32 = m_jit.branchIfNotInt32(valueRegs);
10828         emitSwitchIntJump(data, valueRegs.payloadGPR(), scratch);
10829         notInt32.link(&amp;m_jit);
10830         addBranch(m_jit.branchIfNotNumber(valueRegs, scratch), data-&gt;fallThrough.block);
10831         silentSpillAllRegisters(scratch);
<a name="262" id="anc262"></a><span class="line-modified">10832         callOperation(operationFindSwitchImmTargetForDouble, scratch, &amp;vm(), valueRegs, data-&gt;switchTableIndex);</span>
10833         silentFillAllRegisters();
10834 
10835         m_jit.farJump(scratch, JSSwitchPtrTag);
10836         noResult(node, UseChildrenCalledExplicitly);
10837         break;
10838     }
10839 
10840     default:
10841         RELEASE_ASSERT_NOT_REACHED();
10842         break;
10843     }
10844 }
10845 
<a name="263" id="anc263"></a><span class="line-modified">10846 void SpeculativeJIT::emitSwitchCharStringJump(Node* node, SwitchData* data, GPRReg value, GPRReg scratch)</span>

10847 {
10848     m_jit.loadPtr(MacroAssembler::Address(value, JSString::offsetOfValue()), scratch);
10849     auto isRope = m_jit.branchIfRopeStringImpl(scratch);
<a name="264" id="anc264"></a><span class="line-added">10850     addSlowPathGenerator(slowPathCall(isRope, this, operationResolveRope, scratch, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), value));</span>
10851 
10852     addBranch(
10853         m_jit.branch32(
10854             MacroAssembler::NotEqual,
10855             MacroAssembler::Address(scratch, StringImpl::lengthMemoryOffset()),
10856             TrustedImm32(1)),
10857         data-&gt;fallThrough.block);
10858 
<a name="265" id="anc265"></a>

10859     m_jit.loadPtr(MacroAssembler::Address(scratch, StringImpl::dataOffset()), value);
10860 
10861     JITCompiler::Jump is8Bit = m_jit.branchTest32(
10862         MacroAssembler::NonZero,
10863         MacroAssembler::Address(scratch, StringImpl::flagsOffset()),
10864         TrustedImm32(StringImpl::flagIs8Bit()));
10865 
10866     m_jit.load16(MacroAssembler::Address(value), scratch);
10867 
10868     JITCompiler::Jump ready = m_jit.jump();
10869 
10870     is8Bit.link(&amp;m_jit);
10871     m_jit.load8(MacroAssembler::Address(value), scratch);
10872 
10873     ready.link(&amp;m_jit);
10874     emitSwitchIntJump(data, scratch, value);
10875 }
10876 
10877 void SpeculativeJIT::emitSwitchChar(Node* node, SwitchData* data)
10878 {
10879     switch (node-&gt;child1().useKind()) {
10880     case StringUse: {
10881         SpeculateCellOperand op1(this, node-&gt;child1());
10882         GPRTemporary temp(this);
10883 
10884         GPRReg op1GPR = op1.gpr();
10885         GPRReg tempGPR = temp.gpr();
10886 
10887         op1.use();
10888 
10889         speculateString(node-&gt;child1(), op1GPR);
<a name="266" id="anc266"></a><span class="line-modified">10890         emitSwitchCharStringJump(node, data, op1GPR, tempGPR);</span>
10891         noResult(node, UseChildrenCalledExplicitly);
10892         break;
10893     }
10894 
10895     case UntypedUse: {
10896         JSValueOperand op1(this, node-&gt;child1());
10897         GPRTemporary temp(this);
10898 
10899         JSValueRegs op1Regs = op1.jsValueRegs();
10900         GPRReg tempGPR = temp.gpr();
10901 
10902         op1.use();
10903 
10904         addBranch(m_jit.branchIfNotCell(op1Regs), data-&gt;fallThrough.block);
10905 
10906         addBranch(m_jit.branchIfNotString(op1Regs.payloadGPR()), data-&gt;fallThrough.block);
10907 
<a name="267" id="anc267"></a><span class="line-modified">10908         emitSwitchCharStringJump(node, data, op1Regs.payloadGPR(), tempGPR);</span>
10909         noResult(node, UseChildrenCalledExplicitly);
10910         break;
10911     }
10912 
10913     default:
10914         RELEASE_ASSERT_NOT_REACHED();
10915         break;
10916     }
10917 }
10918 
10919 namespace {
10920 
10921 struct CharacterCase {
10922     bool operator&lt;(const CharacterCase&amp; other) const
10923     {
10924         return character &lt; other.character;
10925     }
10926 
10927     LChar character;
10928     unsigned begin;
10929     unsigned end;
10930 };
10931 
10932 } // anonymous namespace
10933 
10934 void SpeculativeJIT::emitBinarySwitchStringRecurse(
10935     SwitchData* data, const Vector&lt;SpeculativeJIT::StringSwitchCase&gt;&amp; cases,
10936     unsigned numChecked, unsigned begin, unsigned end, GPRReg buffer, GPRReg length,
10937     GPRReg temp, unsigned alreadyCheckedLength, bool checkedExactLength)
10938 {
<a name="268" id="anc268"></a><span class="line-modified">10939     static constexpr bool verbose = false;</span>
10940 
10941     if (verbose) {
10942         dataLog(&quot;We&#39;re down to the following cases, alreadyCheckedLength = &quot;, alreadyCheckedLength, &quot;:\n&quot;);
10943         for (unsigned i = begin; i &lt; end; ++i) {
10944             dataLog(&quot;    &quot;, cases[i].string, &quot;\n&quot;);
10945         }
10946     }
10947 
10948     if (begin == end) {
10949         jump(data-&gt;fallThrough.block, ForceJump);
10950         return;
10951     }
10952 
10953     unsigned minLength = cases[begin].string-&gt;length();
10954     unsigned commonChars = minLength;
10955     bool allLengthsEqual = true;
10956     for (unsigned i = begin + 1; i &lt; end; ++i) {
10957         unsigned myCommonChars = numChecked;
10958         for (unsigned j = numChecked;
10959             j &lt; std::min(cases[begin].string-&gt;length(), cases[i].string-&gt;length());
10960             ++j) {
10961             if (cases[begin].string-&gt;at(j) != cases[i].string-&gt;at(j)) {
10962                 if (verbose)
10963                     dataLog(&quot;string(&quot;, cases[i].string, &quot;)[&quot;, j, &quot;] != string(&quot;, cases[begin].string, &quot;)[&quot;, j, &quot;]\n&quot;);
10964                 break;
10965             }
10966             myCommonChars++;
10967         }
10968         commonChars = std::min(commonChars, myCommonChars);
10969         if (minLength != cases[i].string-&gt;length())
10970             allLengthsEqual = false;
10971         minLength = std::min(minLength, cases[i].string-&gt;length());
10972     }
10973 
10974     if (checkedExactLength) {
10975         RELEASE_ASSERT(alreadyCheckedLength == minLength);
10976         RELEASE_ASSERT(allLengthsEqual);
10977     }
10978 
10979     RELEASE_ASSERT(minLength &gt;= commonChars);
10980 
10981     if (verbose)
10982         dataLog(&quot;length = &quot;, minLength, &quot;, commonChars = &quot;, commonChars, &quot;, allLengthsEqual = &quot;, allLengthsEqual, &quot;\n&quot;);
10983 
10984     if (!allLengthsEqual &amp;&amp; alreadyCheckedLength &lt; minLength)
10985         branch32(MacroAssembler::Below, length, Imm32(minLength), data-&gt;fallThrough.block);
10986     if (allLengthsEqual &amp;&amp; (alreadyCheckedLength &lt; minLength || !checkedExactLength))
10987         branch32(MacroAssembler::NotEqual, length, Imm32(minLength), data-&gt;fallThrough.block);
10988 
10989     for (unsigned i = numChecked; i &lt; commonChars; ++i) {
10990         branch8(
10991             MacroAssembler::NotEqual, MacroAssembler::Address(buffer, i),
10992             TrustedImm32(cases[begin].string-&gt;at(i)), data-&gt;fallThrough.block);
10993     }
10994 
10995     if (minLength == commonChars) {
10996         // This is the case where one of the cases is a prefix of all of the other cases.
10997         // We&#39;ve already checked that the input string is a prefix of all of the cases,
10998         // so we just check length to jump to that case.
10999 
<a name="269" id="anc269"></a><span class="line-modified">11000         if (ASSERT_ENABLED) {</span>
11001             ASSERT(cases[begin].string-&gt;length() == commonChars);
11002             for (unsigned i = begin + 1; i &lt; end; ++i)
11003                 ASSERT(cases[i].string-&gt;length() &gt; commonChars);
11004         }
11005 
11006         if (allLengthsEqual) {
11007             RELEASE_ASSERT(end == begin + 1);
11008             jump(cases[begin].target, ForceJump);
11009             return;
11010         }
11011 
11012         branch32(MacroAssembler::Equal, length, Imm32(commonChars), cases[begin].target);
11013 
11014         // We&#39;ve checked if the length is &gt;= minLength, and then we checked if the
11015         // length is == commonChars. We get to this point if it is &gt;= minLength but not
11016         // == commonChars. Hence we know that it now must be &gt; minLength, i.e., that
11017         // it&#39;s &gt;= minLength + 1.
11018         emitBinarySwitchStringRecurse(
11019             data, cases, commonChars, begin + 1, end, buffer, length, temp, minLength + 1, false);
11020         return;
11021     }
11022 
11023     // At this point we know that the string is longer than commonChars, and we&#39;ve only
11024     // verified commonChars. Use a binary switch on the next unchecked character, i.e.
11025     // string[commonChars].
11026 
11027     RELEASE_ASSERT(end &gt;= begin + 2);
11028 
11029     m_jit.load8(MacroAssembler::Address(buffer, commonChars), temp);
11030 
11031     Vector&lt;CharacterCase&gt; characterCases;
11032     CharacterCase currentCase;
11033     currentCase.character = cases[begin].string-&gt;at(commonChars);
11034     currentCase.begin = begin;
11035     currentCase.end = begin + 1;
11036     for (unsigned i = begin + 1; i &lt; end; ++i) {
11037         if (cases[i].string-&gt;at(commonChars) != currentCase.character) {
11038             if (verbose)
11039                 dataLog(&quot;string(&quot;, cases[i].string, &quot;)[&quot;, commonChars, &quot;] != string(&quot;, cases[begin].string, &quot;)[&quot;, commonChars, &quot;]\n&quot;);
11040             currentCase.end = i;
11041             characterCases.append(currentCase);
11042             currentCase.character = cases[i].string-&gt;at(commonChars);
11043             currentCase.begin = i;
11044             currentCase.end = i + 1;
11045         } else
11046             currentCase.end = i + 1;
11047     }
11048     characterCases.append(currentCase);
11049 
11050     Vector&lt;int64_t&gt; characterCaseValues;
11051     for (unsigned i = 0; i &lt; characterCases.size(); ++i)
11052         characterCaseValues.append(characterCases[i].character);
11053 
11054     BinarySwitch binarySwitch(temp, characterCaseValues, BinarySwitch::Int32);
11055     while (binarySwitch.advance(m_jit)) {
11056         const CharacterCase&amp; myCase = characterCases[binarySwitch.caseIndex()];
11057         emitBinarySwitchStringRecurse(
11058             data, cases, commonChars + 1, myCase.begin, myCase.end, buffer, length,
11059             temp, minLength, allLengthsEqual);
11060     }
11061 
11062     addBranch(binarySwitch.fallThrough(), data-&gt;fallThrough.block);
11063 }
11064 
<a name="270" id="anc270"></a><span class="line-modified">11065 void SpeculativeJIT::emitSwitchStringOnString(Node* node, SwitchData* data, GPRReg string)</span>
11066 {
11067     data-&gt;didUseJumpTable = true;
11068 
11069     bool canDoBinarySwitch = true;
11070     unsigned totalLength = 0;
11071 
11072     for (unsigned i = data-&gt;cases.size(); i--;) {
11073         StringImpl* string = data-&gt;cases[i].value.stringImpl();
11074         if (!string-&gt;is8Bit()) {
11075             canDoBinarySwitch = false;
11076             break;
11077         }
11078         if (string-&gt;length() &gt; Options::maximumBinaryStringSwitchCaseLength()) {
11079             canDoBinarySwitch = false;
11080             break;
11081         }
11082         totalLength += string-&gt;length();
11083     }
11084 
11085     if (!canDoBinarySwitch || totalLength &gt; Options::maximumBinaryStringSwitchTotalLength()) {
11086         flushRegisters();
11087         callOperation(
<a name="271" id="anc271"></a><span class="line-modified">11088             operationSwitchString, string, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), static_cast&lt;size_t&gt;(data-&gt;switchTableIndex), string);</span>
11089         m_jit.exceptionCheck();
11090         m_jit.farJump(string, JSSwitchPtrTag);
11091         return;
11092     }
11093 
11094     GPRTemporary length(this);
11095     GPRTemporary temp(this);
11096 
11097     GPRReg lengthGPR = length.gpr();
11098     GPRReg tempGPR = temp.gpr();
11099 
11100     MacroAssembler::JumpList slowCases;
11101     m_jit.loadPtr(MacroAssembler::Address(string, JSString::offsetOfValue()), tempGPR);
11102     slowCases.append(m_jit.branchIfRopeStringImpl(tempGPR));
11103     m_jit.load32(MacroAssembler::Address(tempGPR, StringImpl::lengthMemoryOffset()), lengthGPR);
11104 
11105     slowCases.append(m_jit.branchTest32(
11106         MacroAssembler::Zero,
11107         MacroAssembler::Address(tempGPR, StringImpl::flagsOffset()),
11108         TrustedImm32(StringImpl::flagIs8Bit())));
11109 
11110     m_jit.loadPtr(MacroAssembler::Address(tempGPR, StringImpl::dataOffset()), string);
11111 
11112     Vector&lt;StringSwitchCase&gt; cases;
11113     for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
11114         cases.append(
11115             StringSwitchCase(data-&gt;cases[i].value.stringImpl(), data-&gt;cases[i].target.block));
11116     }
11117 
11118     std::sort(cases.begin(), cases.end());
11119 
11120     emitBinarySwitchStringRecurse(
11121         data, cases, 0, 0, cases.size(), string, lengthGPR, tempGPR, 0, false);
11122 
11123     slowCases.link(&amp;m_jit);
11124     silentSpillAllRegisters(string);
<a name="272" id="anc272"></a><span class="line-modified">11125     callOperation(operationSwitchString, string, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), static_cast&lt;size_t&gt;(data-&gt;switchTableIndex), string);</span>
11126     silentFillAllRegisters();
11127     m_jit.exceptionCheck();
11128     m_jit.farJump(string, JSSwitchPtrTag);
11129 }
11130 
11131 void SpeculativeJIT::emitSwitchString(Node* node, SwitchData* data)
11132 {
11133     switch (node-&gt;child1().useKind()) {
11134     case StringIdentUse: {
11135         SpeculateCellOperand op1(this, node-&gt;child1());
11136         GPRTemporary temp(this);
11137 
11138         GPRReg op1GPR = op1.gpr();
11139         GPRReg tempGPR = temp.gpr();
11140 
11141         speculateString(node-&gt;child1(), op1GPR);
11142         speculateStringIdentAndLoadStorage(node-&gt;child1(), op1GPR, tempGPR);
11143 
11144         Vector&lt;int64_t&gt; identifierCaseValues;
11145         for (unsigned i = 0; i &lt; data-&gt;cases.size(); ++i) {
11146             identifierCaseValues.append(
11147                 static_cast&lt;int64_t&gt;(bitwise_cast&lt;intptr_t&gt;(data-&gt;cases[i].value.stringImpl())));
11148         }
11149 
11150         BinarySwitch binarySwitch(tempGPR, identifierCaseValues, BinarySwitch::IntPtr);
11151         while (binarySwitch.advance(m_jit))
11152             jump(data-&gt;cases[binarySwitch.caseIndex()].target.block, ForceJump);
11153         addBranch(binarySwitch.fallThrough(), data-&gt;fallThrough.block);
11154 
11155         noResult(node);
11156         break;
11157     }
11158 
11159     case StringUse: {
11160         SpeculateCellOperand op1(this, node-&gt;child1());
11161 
11162         GPRReg op1GPR = op1.gpr();
11163 
11164         op1.use();
11165 
11166         speculateString(node-&gt;child1(), op1GPR);
<a name="273" id="anc273"></a><span class="line-modified">11167         emitSwitchStringOnString(node, data, op1GPR);</span>
11168         noResult(node, UseChildrenCalledExplicitly);
11169         break;
11170     }
11171 
11172     case UntypedUse: {
11173         JSValueOperand op1(this, node-&gt;child1());
11174 
11175         JSValueRegs op1Regs = op1.jsValueRegs();
11176 
11177         op1.use();
11178 
11179         addBranch(m_jit.branchIfNotCell(op1Regs), data-&gt;fallThrough.block);
11180 
11181         addBranch(m_jit.branchIfNotString(op1Regs.payloadGPR()), data-&gt;fallThrough.block);
11182 
<a name="274" id="anc274"></a><span class="line-modified">11183         emitSwitchStringOnString(node, data, op1Regs.payloadGPR());</span>
11184         noResult(node, UseChildrenCalledExplicitly);
11185         break;
11186     }
11187 
11188     default:
11189         RELEASE_ASSERT_NOT_REACHED();
11190         break;
11191     }
11192 }
11193 
11194 void SpeculativeJIT::emitSwitch(Node* node)
11195 {
11196     SwitchData* data = node-&gt;switchData();
11197     switch (data-&gt;kind) {
11198     case SwitchImm: {
11199         emitSwitchImm(node, data);
11200         return;
11201     }
11202     case SwitchChar: {
11203         emitSwitchChar(node, data);
11204         return;
11205     }
11206     case SwitchString: {
11207         emitSwitchString(node, data);
11208         return;
11209     }
11210     case SwitchCell: {
11211         DFG_CRASH(m_jit.graph(), node, &quot;Bad switch kind&quot;);
11212         return;
11213     } }
11214     RELEASE_ASSERT_NOT_REACHED();
11215 }
11216 
11217 void SpeculativeJIT::addBranch(const MacroAssembler::JumpList&amp; jump, BasicBlock* destination)
11218 {
11219     for (unsigned i = jump.jumps().size(); i--;)
11220         addBranch(jump.jumps()[i], destination);
11221 }
11222 
11223 void SpeculativeJIT::linkBranches()
11224 {
11225     for (auto&amp; branch : m_branches)
11226         branch.jump.linkTo(m_jit.blockHeads()[branch.destination-&gt;index], &amp;m_jit);
11227 }
11228 
11229 void SpeculativeJIT::compileStoreBarrier(Node* node)
11230 {
11231     ASSERT(node-&gt;op() == StoreBarrier || node-&gt;op() == FencedStoreBarrier);
11232 
11233     bool isFenced = node-&gt;op() == FencedStoreBarrier;
11234 
11235     SpeculateCellOperand base(this, node-&gt;child1());
11236     GPRTemporary scratch1(this);
11237 
11238     GPRReg baseGPR = base.gpr();
11239     GPRReg scratch1GPR = scratch1.gpr();
11240 
11241     JITCompiler::JumpList ok;
11242 
11243     if (isFenced) {
11244         ok.append(m_jit.barrierBranch(vm(), baseGPR, scratch1GPR));
11245 
11246         JITCompiler::Jump noFence = m_jit.jumpIfMutatorFenceNotNeeded(vm());
11247         m_jit.memoryFence();
11248         ok.append(m_jit.barrierBranchWithoutFence(baseGPR));
11249         noFence.link(&amp;m_jit);
11250     } else
11251         ok.append(m_jit.barrierBranchWithoutFence(baseGPR));
11252 
11253     silentSpillAllRegisters(InvalidGPRReg);
<a name="275" id="anc275"></a><span class="line-modified">11254     callOperation(operationWriteBarrierSlowPath, &amp;vm(), baseGPR);</span>
11255     silentFillAllRegisters();
11256 
11257     ok.link(&amp;m_jit);
11258 
11259     noResult(node);
11260 }
11261 
11262 void SpeculativeJIT::compilePutAccessorById(Node* node)
11263 {
11264     SpeculateCellOperand base(this, node-&gt;child1());
11265     SpeculateCellOperand accessor(this, node-&gt;child2());
11266 
11267     GPRReg baseGPR = base.gpr();
11268     GPRReg accessorGPR = accessor.gpr();
11269 
11270     flushRegisters();
<a name="276" id="anc276"></a><span class="line-modified">11271     callOperation(node-&gt;op() == PutGetterById ? operationPutGetterById : operationPutSetterById, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;accessorAttributes(), accessorGPR);</span>
11272     m_jit.exceptionCheck();
11273 
11274     noResult(node);
11275 }
11276 
11277 void SpeculativeJIT::compilePutGetterSetterById(Node* node)
11278 {
11279     SpeculateCellOperand base(this, node-&gt;child1());
11280     JSValueOperand getter(this, node-&gt;child2());
11281     JSValueOperand setter(this, node-&gt;child3());
11282 
11283 #if USE(JSVALUE64)
11284     GPRReg baseGPR = base.gpr();
11285     GPRReg getterGPR = getter.gpr();
11286     GPRReg setterGPR = setter.gpr();
11287 
11288     flushRegisters();
<a name="277" id="anc277"></a><span class="line-modified">11289     callOperation(operationPutGetterSetter, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;accessorAttributes(), getterGPR, setterGPR);</span>
11290 #else
11291     // These JSValues may be JSUndefined OR JSFunction*.
11292     // At that time,
11293     // 1. If the JSValue is JSUndefined, its payload becomes nullptr.
11294     // 2. If the JSValue is JSFunction*, its payload becomes JSFunction*.
11295     // So extract payload and pass it to operationPutGetterSetter. This hack is used as the same way in baseline JIT.
11296     GPRReg baseGPR = base.gpr();
11297     JSValueRegs getterRegs = getter.jsValueRegs();
11298     JSValueRegs setterRegs = setter.jsValueRegs();
11299 
11300     flushRegisters();
<a name="278" id="anc278"></a><span class="line-modified">11301     callOperation(operationPutGetterSetter, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;accessorAttributes(), getterRegs.payloadGPR(), setterRegs.payloadGPR());</span>
11302 #endif
11303     m_jit.exceptionCheck();
11304 
11305     noResult(node);
11306 }
11307 
11308 void SpeculativeJIT::compileResolveScope(Node* node)
11309 {
11310     SpeculateCellOperand scope(this, node-&gt;child1());
11311     GPRReg scopeGPR = scope.gpr();
11312     GPRFlushedCallResult result(this);
11313     GPRReg resultGPR = result.gpr();
11314     flushRegisters();
<a name="279" id="anc279"></a><span class="line-modified">11315     callOperation(operationResolveScope, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), scopeGPR, identifierUID(node-&gt;identifierNumber()));</span>
11316     m_jit.exceptionCheck();
11317     cellResult(resultGPR, node);
11318 }
11319 
11320 void SpeculativeJIT::compileResolveScopeForHoistingFuncDeclInEval(Node* node)
11321 {
11322     SpeculateCellOperand scope(this, node-&gt;child1());
11323     GPRReg scopeGPR = scope.gpr();
11324     flushRegisters();
11325     JSValueRegsFlushedCallResult result(this);
11326     JSValueRegs resultRegs = result.regs();
<a name="280" id="anc280"></a><span class="line-modified">11327     callOperation(operationResolveScopeForHoistingFuncDeclInEval, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), scopeGPR, identifierUID(node-&gt;identifierNumber()));</span>
11328     m_jit.exceptionCheck();
11329     jsValueResult(resultRegs, node);
11330 }
11331 
11332 void SpeculativeJIT::compileGetGlobalVariable(Node* node)
11333 {
11334     JSValueRegsTemporary result(this);
11335     JSValueRegs resultRegs = result.regs();
11336     m_jit.loadValue(node-&gt;variablePointer(), resultRegs);
11337     jsValueResult(resultRegs, node);
11338 }
11339 
11340 void SpeculativeJIT::compilePutGlobalVariable(Node* node)
11341 {
11342     JSValueOperand value(this, node-&gt;child2());
11343     JSValueRegs valueRegs = value.jsValueRegs();
11344     m_jit.storeValue(valueRegs, node-&gt;variablePointer());
11345     noResult(node);
11346 }
11347 
11348 void SpeculativeJIT::compileGetDynamicVar(Node* node)
11349 {
11350     SpeculateCellOperand scope(this, node-&gt;child1());
11351     GPRReg scopeGPR = scope.gpr();
11352     flushRegisters();
11353     JSValueRegsFlushedCallResult result(this);
11354     JSValueRegs resultRegs = result.regs();
<a name="281" id="anc281"></a><span class="line-modified">11355     callOperation(operationGetDynamicVar, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), scopeGPR, identifierUID(node-&gt;identifierNumber()), node-&gt;getPutInfo());</span>
11356     m_jit.exceptionCheck();
11357     jsValueResult(resultRegs, node);
11358 }
11359 
11360 void SpeculativeJIT::compilePutDynamicVar(Node* node)
11361 {
11362     SpeculateCellOperand scope(this, node-&gt;child1());
11363     JSValueOperand value(this, node-&gt;child2());
11364 
11365     GPRReg scopeGPR = scope.gpr();
11366     JSValueRegs valueRegs = value.jsValueRegs();
11367 
11368     flushRegisters();
<a name="282" id="anc282"></a><span class="line-modified">11369     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutDynamicVarStrict : operationPutDynamicVarNonStrict, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), scopeGPR, valueRegs, identifierUID(node-&gt;identifierNumber()), node-&gt;getPutInfo());</span>
11370     m_jit.exceptionCheck();
11371     noResult(node);
11372 }
11373 
11374 void SpeculativeJIT::compileGetClosureVar(Node* node)
11375 {
11376     SpeculateCellOperand base(this, node-&gt;child1());
11377     JSValueRegsTemporary result(this);
11378 
11379     GPRReg baseGPR = base.gpr();
11380     JSValueRegs resultRegs = result.regs();
11381 
11382     m_jit.loadValue(JITCompiler::Address(baseGPR, JSLexicalEnvironment::offsetOfVariable(node-&gt;scopeOffset())), resultRegs);
11383     jsValueResult(resultRegs, node);
11384 }
11385 
11386 void SpeculativeJIT::compilePutClosureVar(Node* node)
11387 {
11388     SpeculateCellOperand base(this, node-&gt;child1());
11389     JSValueOperand value(this, node-&gt;child2());
11390 
11391     GPRReg baseGPR = base.gpr();
11392     JSValueRegs valueRegs = value.jsValueRegs();
11393 
11394     m_jit.storeValue(valueRegs, JITCompiler::Address(baseGPR, JSLexicalEnvironment::offsetOfVariable(node-&gt;scopeOffset())));
11395     noResult(node);
11396 }
11397 
<a name="283" id="anc283"></a><span class="line-added">11398 void SpeculativeJIT::compileGetInternalField(Node* node)</span>
<span class="line-added">11399 {</span>
<span class="line-added">11400     SpeculateCellOperand base(this, node-&gt;child1());</span>
<span class="line-added">11401     JSValueRegsTemporary result(this);</span>
<span class="line-added">11402 </span>
<span class="line-added">11403     GPRReg baseGPR = base.gpr();</span>
<span class="line-added">11404     JSValueRegs resultRegs = result.regs();</span>
<span class="line-added">11405 </span>
<span class="line-added">11406     m_jit.loadValue(JITCompiler::Address(baseGPR, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(node-&gt;internalFieldIndex())), resultRegs);</span>
<span class="line-added">11407     jsValueResult(resultRegs, node);</span>
<span class="line-added">11408 }</span>
<span class="line-added">11409 </span>
<span class="line-added">11410 void SpeculativeJIT::compilePutInternalField(Node* node)</span>
<span class="line-added">11411 {</span>
<span class="line-added">11412     SpeculateCellOperand base(this, node-&gt;child1());</span>
<span class="line-added">11413     JSValueOperand value(this, node-&gt;child2());</span>
<span class="line-added">11414 </span>
<span class="line-added">11415     GPRReg baseGPR = base.gpr();</span>
<span class="line-added">11416     JSValueRegs valueRegs = value.jsValueRegs();</span>
<span class="line-added">11417 </span>
<span class="line-added">11418     m_jit.storeValue(valueRegs, JITCompiler::Address(baseGPR, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(node-&gt;internalFieldIndex())));</span>
<span class="line-added">11419     noResult(node);</span>
<span class="line-added">11420 }</span>
<span class="line-added">11421 </span>
11422 void SpeculativeJIT::compilePutAccessorByVal(Node* node)
11423 {
11424     SpeculateCellOperand base(this, node-&gt;child1());
11425     JSValueOperand subscript(this, node-&gt;child2());
11426     SpeculateCellOperand accessor(this, node-&gt;child3());
11427 
11428     auto operation = node-&gt;op() == PutGetterByVal ? operationPutGetterByVal : operationPutSetterByVal;
11429 
11430     GPRReg baseGPR = base.gpr();
11431     JSValueRegs subscriptRegs = subscript.jsValueRegs();
11432     GPRReg accessorGPR = accessor.gpr();
11433 
11434     flushRegisters();
<a name="284" id="anc284"></a><span class="line-modified">11435     callOperation(operation, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, subscriptRegs, node-&gt;accessorAttributes(), accessorGPR);</span>
11436     m_jit.exceptionCheck();
11437 
11438     noResult(node);
11439 }
11440 
11441 void SpeculativeJIT::compileGetRegExpObjectLastIndex(Node* node)
11442 {
11443     SpeculateCellOperand regExp(this, node-&gt;child1());
11444     JSValueRegsTemporary result(this);
11445     GPRReg regExpGPR = regExp.gpr();
11446     JSValueRegs resultRegs = result.regs();
11447     speculateRegExpObject(node-&gt;child1(), regExpGPR);
11448     m_jit.loadValue(JITCompiler::Address(regExpGPR, RegExpObject::offsetOfLastIndex()), resultRegs);
11449     jsValueResult(resultRegs, node);
11450 }
11451 
11452 void SpeculativeJIT::compileSetRegExpObjectLastIndex(Node* node)
11453 {
11454     SpeculateCellOperand regExp(this, node-&gt;child1());
11455     JSValueOperand value(this, node-&gt;child2());
11456     GPRReg regExpGPR = regExp.gpr();
11457     JSValueRegs valueRegs = value.jsValueRegs();
11458 
11459     if (!node-&gt;ignoreLastIndexIsWritable()) {
11460         speculateRegExpObject(node-&gt;child1(), regExpGPR);
11461         speculationCheck(
11462             ExoticObjectMode, JSValueRegs(), nullptr,
11463             m_jit.branchTestPtr(
11464                 JITCompiler::NonZero,
11465                 JITCompiler::Address(regExpGPR, RegExpObject::offsetOfRegExpAndLastIndexIsNotWritableFlag()),
11466                 JITCompiler::TrustedImm32(RegExpObject::lastIndexIsNotWritableFlag)));
11467     }
11468 
11469     m_jit.storeValue(valueRegs, JITCompiler::Address(regExpGPR, RegExpObject::offsetOfLastIndex()));
11470     noResult(node);
11471 }
11472 
11473 void SpeculativeJIT::compileRegExpExec(Node* node)
11474 {
11475     bool sample = false;
11476     if (sample)
11477         m_jit.incrementSuperSamplerCount();
11478 
11479     SpeculateCellOperand globalObject(this, node-&gt;child1());
11480     GPRReg globalObjectGPR = globalObject.gpr();
11481 
11482     if (node-&gt;child2().useKind() == RegExpObjectUse) {
11483         if (node-&gt;child3().useKind() == StringUse) {
11484             SpeculateCellOperand base(this, node-&gt;child2());
11485             SpeculateCellOperand argument(this, node-&gt;child3());
11486             GPRReg baseGPR = base.gpr();
11487             GPRReg argumentGPR = argument.gpr();
11488             speculateRegExpObject(node-&gt;child2(), baseGPR);
11489             speculateString(node-&gt;child3(), argumentGPR);
11490 
11491             flushRegisters();
11492             JSValueRegsFlushedCallResult result(this);
11493             JSValueRegs resultRegs = result.regs();
11494             callOperation(operationRegExpExecString, resultRegs, globalObjectGPR, baseGPR, argumentGPR);
11495             m_jit.exceptionCheck();
11496 
11497             jsValueResult(resultRegs, node);
11498 
11499             if (sample)
11500                 m_jit.decrementSuperSamplerCount();
11501             return;
11502         }
11503 
11504         SpeculateCellOperand base(this, node-&gt;child2());
11505         JSValueOperand argument(this, node-&gt;child3());
11506         GPRReg baseGPR = base.gpr();
11507         JSValueRegs argumentRegs = argument.jsValueRegs();
11508         speculateRegExpObject(node-&gt;child2(), baseGPR);
11509 
11510         flushRegisters();
11511         JSValueRegsFlushedCallResult result(this);
11512         JSValueRegs resultRegs = result.regs();
11513         callOperation(operationRegExpExec, resultRegs, globalObjectGPR, baseGPR, argumentRegs);
11514         m_jit.exceptionCheck();
11515 
11516         jsValueResult(resultRegs, node);
11517 
11518         if (sample)
11519             m_jit.decrementSuperSamplerCount();
11520         return;
11521     }
11522 
11523     JSValueOperand base(this, node-&gt;child2());
11524     JSValueOperand argument(this, node-&gt;child3());
11525     JSValueRegs baseRegs = base.jsValueRegs();
11526     JSValueRegs argumentRegs = argument.jsValueRegs();
11527 
11528     flushRegisters();
11529     JSValueRegsFlushedCallResult result(this);
11530     JSValueRegs resultRegs = result.regs();
11531     callOperation(operationRegExpExecGeneric, resultRegs, globalObjectGPR, baseRegs, argumentRegs);
11532     m_jit.exceptionCheck();
11533 
11534     jsValueResult(resultRegs, node);
11535 
11536     if (sample)
11537         m_jit.decrementSuperSamplerCount();
11538 }
11539 
11540 void SpeculativeJIT::compileRegExpTest(Node* node)
11541 {
11542     SpeculateCellOperand globalObject(this, node-&gt;child1());
11543     GPRReg globalObjectGPR = globalObject.gpr();
11544 
11545     if (node-&gt;child2().useKind() == RegExpObjectUse) {
11546         if (node-&gt;child3().useKind() == StringUse) {
11547             SpeculateCellOperand base(this, node-&gt;child2());
11548             SpeculateCellOperand argument(this, node-&gt;child3());
11549             GPRReg baseGPR = base.gpr();
11550             GPRReg argumentGPR = argument.gpr();
11551             speculateRegExpObject(node-&gt;child2(), baseGPR);
11552             speculateString(node-&gt;child3(), argumentGPR);
11553 
11554             flushRegisters();
11555             GPRFlushedCallResult result(this);
11556             callOperation(operationRegExpTestString, result.gpr(), globalObjectGPR, baseGPR, argumentGPR);
11557             m_jit.exceptionCheck();
11558 
11559             unblessedBooleanResult(result.gpr(), node);
11560             return;
11561         }
11562 
11563         SpeculateCellOperand base(this, node-&gt;child2());
11564         JSValueOperand argument(this, node-&gt;child3());
11565         GPRReg baseGPR = base.gpr();
11566         JSValueRegs argumentRegs = argument.jsValueRegs();
11567         speculateRegExpObject(node-&gt;child2(), baseGPR);
11568 
11569         flushRegisters();
11570         GPRFlushedCallResult result(this);
11571         callOperation(operationRegExpTest, result.gpr(), globalObjectGPR, baseGPR, argumentRegs);
11572         m_jit.exceptionCheck();
11573 
11574         unblessedBooleanResult(result.gpr(), node);
11575         return;
11576     }
11577 
11578     JSValueOperand base(this, node-&gt;child2());
11579     JSValueOperand argument(this, node-&gt;child3());
11580     JSValueRegs baseRegs = base.jsValueRegs();
11581     JSValueRegs argumentRegs = argument.jsValueRegs();
11582 
11583     flushRegisters();
11584     GPRFlushedCallResult result(this);
11585     callOperation(operationRegExpTestGeneric, result.gpr(), globalObjectGPR, baseRegs, argumentRegs);
11586     m_jit.exceptionCheck();
11587 
11588     unblessedBooleanResult(result.gpr(), node);
11589 }
11590 
11591 void SpeculativeJIT::compileStringReplace(Node* node)
11592 {
11593     ASSERT(node-&gt;op() == StringReplace || node-&gt;op() == StringReplaceRegExp);
11594     bool sample = false;
11595     if (sample)
11596         m_jit.incrementSuperSamplerCount();
11597 
11598     if (node-&gt;child1().useKind() == StringUse
11599         &amp;&amp; node-&gt;child2().useKind() == RegExpObjectUse
11600         &amp;&amp; node-&gt;child3().useKind() == StringUse) {
11601         if (JSString* replace = node-&gt;child3()-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {
11602             if (!replace-&gt;length()) {
11603                 SpeculateCellOperand string(this, node-&gt;child1());
11604                 SpeculateCellOperand regExp(this, node-&gt;child2());
11605                 GPRReg stringGPR = string.gpr();
11606                 GPRReg regExpGPR = regExp.gpr();
11607                 speculateString(node-&gt;child1(), stringGPR);
11608                 speculateRegExpObject(node-&gt;child2(), regExpGPR);
11609 
11610                 flushRegisters();
11611                 GPRFlushedCallResult result(this);
<a name="285" id="anc285"></a><span class="line-modified">11612                 callOperation(operationStringProtoFuncReplaceRegExpEmptyStr, result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), stringGPR, regExpGPR);</span>
11613                 m_jit.exceptionCheck();
11614                 cellResult(result.gpr(), node);
11615                 if (sample)
11616                     m_jit.decrementSuperSamplerCount();
11617                 return;
11618             }
11619         }
11620 
11621         SpeculateCellOperand string(this, node-&gt;child1());
11622         SpeculateCellOperand regExp(this, node-&gt;child2());
11623         SpeculateCellOperand replace(this, node-&gt;child3());
11624         GPRReg stringGPR = string.gpr();
11625         GPRReg regExpGPR = regExp.gpr();
11626         GPRReg replaceGPR = replace.gpr();
11627         speculateString(node-&gt;child1(), stringGPR);
11628         speculateRegExpObject(node-&gt;child2(), regExpGPR);
11629         speculateString(node-&gt;child3(), replaceGPR);
11630 
11631         flushRegisters();
11632         GPRFlushedCallResult result(this);
<a name="286" id="anc286"></a><span class="line-modified">11633         callOperation(operationStringProtoFuncReplaceRegExpString, result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), stringGPR, regExpGPR, replaceGPR);</span>
11634         m_jit.exceptionCheck();
11635         cellResult(result.gpr(), node);
11636         if (sample)
11637             m_jit.decrementSuperSamplerCount();
11638         return;
11639     }
11640 
11641     // If we fixed up the edge of child2, we inserted a Check(@child2, String).
11642     OperandSpeculationMode child2SpeculationMode = AutomaticOperandSpeculation;
11643     if (node-&gt;child2().useKind() == StringUse)
11644         child2SpeculationMode = ManualOperandSpeculation;
11645 
11646     JSValueOperand string(this, node-&gt;child1());
11647     JSValueOperand search(this, node-&gt;child2(), child2SpeculationMode);
11648     JSValueOperand replace(this, node-&gt;child3());
11649     JSValueRegs stringRegs = string.jsValueRegs();
11650     JSValueRegs searchRegs = search.jsValueRegs();
11651     JSValueRegs replaceRegs = replace.jsValueRegs();
11652 
11653     flushRegisters();
11654     GPRFlushedCallResult result(this);
<a name="287" id="anc287"></a><span class="line-modified">11655     callOperation(operationStringProtoFuncReplaceGeneric, result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), stringRegs, searchRegs, replaceRegs);</span>
11656     m_jit.exceptionCheck();
11657     cellResult(result.gpr(), node);
11658     if (sample)
11659         m_jit.decrementSuperSamplerCount();
11660 }
11661 
11662 void SpeculativeJIT::compileRegExpExecNonGlobalOrSticky(Node* node)
11663 {
11664     SpeculateCellOperand globalObject(this, node-&gt;child1());
11665     SpeculateCellOperand argument(this, node-&gt;child2());
11666     GPRReg globalObjectGPR = globalObject.gpr();
11667     GPRReg argumentGPR = argument.gpr();
11668 
11669     speculateString(node-&gt;child2(), argumentGPR);
11670 
11671     flushRegisters();
11672     JSValueRegsFlushedCallResult result(this);
11673     JSValueRegs resultRegs = result.regs();
11674     callOperation(
11675         operationRegExpExecNonGlobalOrSticky, resultRegs,
11676         globalObjectGPR, TrustedImmPtr(node-&gt;cellOperand()), argumentGPR);
11677     m_jit.exceptionCheck();
11678 
11679     jsValueResult(resultRegs, node);
11680 }
11681 
11682 void SpeculativeJIT::compileRegExpMatchFastGlobal(Node* node)
11683 {
11684     SpeculateCellOperand globalObject(this, node-&gt;child1());
11685     SpeculateCellOperand argument(this, node-&gt;child2());
11686     GPRReg globalObjectGPR = globalObject.gpr();
11687     GPRReg argumentGPR = argument.gpr();
11688 
11689     speculateString(node-&gt;child2(), argumentGPR);
11690 
11691     flushRegisters();
11692     JSValueRegsFlushedCallResult result(this);
11693     JSValueRegs resultRegs = result.regs();
11694     callOperation(
11695         operationRegExpMatchFastGlobalString, resultRegs,
11696         globalObjectGPR, TrustedImmPtr(node-&gt;cellOperand()), argumentGPR);
11697     m_jit.exceptionCheck();
11698 
11699     jsValueResult(resultRegs, node);
11700 }
11701 
11702 void SpeculativeJIT::compileRegExpMatchFast(Node* node)
11703 {
11704     SpeculateCellOperand globalObject(this, node-&gt;child1());
11705     SpeculateCellOperand base(this, node-&gt;child2());
11706     SpeculateCellOperand argument(this, node-&gt;child3());
11707     GPRReg globalObjectGPR = globalObject.gpr();
11708     GPRReg baseGPR = base.gpr();
11709     GPRReg argumentGPR = argument.gpr();
11710     speculateRegExpObject(node-&gt;child2(), baseGPR);
11711     speculateString(node-&gt;child3(), argumentGPR);
11712 
11713     flushRegisters();
11714     JSValueRegsFlushedCallResult result(this);
11715     JSValueRegs resultRegs = result.regs();
11716     callOperation(
11717         operationRegExpMatchFastString, resultRegs,
11718         globalObjectGPR, baseGPR, argumentGPR);
11719     m_jit.exceptionCheck();
11720 
11721     jsValueResult(resultRegs, node);
11722 }
11723 
11724 void SpeculativeJIT::compileLazyJSConstant(Node* node)
11725 {
11726     JSValueRegsTemporary result(this);
11727     JSValueRegs resultRegs = result.regs();
11728     node-&gt;lazyJSValue().emit(m_jit, resultRegs);
11729     jsValueResult(resultRegs, node);
11730 }
11731 
11732 void SpeculativeJIT::compileMaterializeNewObject(Node* node)
11733 {
11734     RegisteredStructure structure = node-&gt;structureSet().at(0);
11735     ASSERT(m_jit.graph().varArgChild(node, 0)-&gt;dynamicCastConstant&lt;Structure*&gt;(vm()) == structure.get());
11736 
11737     ObjectMaterializationData&amp; data = node-&gt;objectMaterializationData();
11738 
11739     IndexingType indexingType = structure-&gt;indexingType();
11740     bool hasIndexingHeader = hasIndexedProperties(indexingType);
11741     int32_t publicLength = 0;
11742     int32_t vectorLength = 0;
11743 
11744     if (hasIndexingHeader) {
11745         for (unsigned i = data.m_properties.size(); i--;) {
11746             Edge edge = m_jit.graph().varArgChild(node, 1 + i);
11747             switch (data.m_properties[i].kind()) {
11748             case PublicLengthPLoc:
11749                 publicLength = edge-&gt;asInt32();
11750                 break;
11751             case VectorLengthPLoc:
11752                 vectorLength = edge-&gt;asInt32();
11753                 break;
11754             default:
11755                 break;
11756             }
11757         }
11758     }
11759 
11760     GPRTemporary result(this);
11761     GPRTemporary storage(this);
11762     GPRReg resultGPR = result.gpr();
11763     GPRReg storageGPR = storage.gpr();
11764 
11765     emitAllocateRawObject(resultGPR, structure, storageGPR, 0, vectorLength);
11766 
11767     m_jit.store32(
11768         JITCompiler::TrustedImm32(publicLength),
11769         JITCompiler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
11770 
11771     for (unsigned i = data.m_properties.size(); i--;) {
11772         Edge edge = m_jit.graph().varArgChild(node, 1 + i);
11773         PromotedLocationDescriptor descriptor = data.m_properties[i];
11774         switch (descriptor.kind()) {
11775         case IndexedPropertyPLoc: {
11776             JSValueOperand value(this, edge);
11777             m_jit.storeValue(
11778                 value.jsValueRegs(),
11779                 JITCompiler::Address(storageGPR, sizeof(EncodedJSValue) * descriptor.info()));
11780             break;
11781         }
11782 
11783         case NamedPropertyPLoc: {
11784             StringImpl* uid = m_jit.graph().identifiers()[descriptor.info()];
11785             for (PropertyMapEntry entry : structure-&gt;getPropertiesConcurrently()) {
11786                 if (uid != entry.key)
11787                     continue;
11788 
11789                 JSValueOperand value(this, edge);
11790                 GPRReg baseGPR = isInlineOffset(entry.offset) ? resultGPR : storageGPR;
11791                 m_jit.storeValue(
11792                     value.jsValueRegs(),
11793                     JITCompiler::Address(baseGPR, offsetRelativeToBase(entry.offset)));
11794             }
11795             break;
11796         }
11797 
11798         default:
11799             break;
11800         }
11801     }
11802 
11803     cellResult(resultGPR, node);
11804 }
11805 
11806 void SpeculativeJIT::compileRecordRegExpCachedResult(Node* node)
11807 {
11808     Edge globalObjectEdge = m_jit.graph().varArgChild(node, 0);
11809     Edge regExpEdge = m_jit.graph().varArgChild(node, 1);
11810     Edge stringEdge = m_jit.graph().varArgChild(node, 2);
11811     Edge startEdge = m_jit.graph().varArgChild(node, 3);
11812     Edge endEdge = m_jit.graph().varArgChild(node, 4);
11813 
11814     SpeculateCellOperand globalObject(this, globalObjectEdge);
11815     SpeculateCellOperand regExp(this, regExpEdge);
11816     SpeculateCellOperand string(this, stringEdge);
11817     SpeculateInt32Operand start(this, startEdge);
11818     SpeculateInt32Operand end(this, endEdge);
11819 
11820     GPRReg globalObjectGPR = globalObject.gpr();
11821     GPRReg regExpGPR = regExp.gpr();
11822     GPRReg stringGPR = string.gpr();
11823     GPRReg startGPR = start.gpr();
11824     GPRReg endGPR = end.gpr();
11825 
11826     ptrdiff_t offset = JSGlobalObject::regExpGlobalDataOffset() + RegExpGlobalData::offsetOfCachedResult();
11827 
11828     m_jit.storePtr(
11829         regExpGPR,
11830         JITCompiler::Address(globalObjectGPR, offset + RegExpCachedResult::offsetOfLastRegExp()));
11831     m_jit.storePtr(
11832         stringGPR,
11833         JITCompiler::Address(globalObjectGPR, offset + RegExpCachedResult::offsetOfLastInput()));
11834     m_jit.store32(
11835         startGPR,
11836         JITCompiler::Address(
11837             globalObjectGPR,
11838             offset + RegExpCachedResult::offsetOfResult() + OBJECT_OFFSETOF(MatchResult, start)));
11839     m_jit.store32(
11840         endGPR,
11841         JITCompiler::Address(
11842             globalObjectGPR,
11843             offset + RegExpCachedResult::offsetOfResult() + OBJECT_OFFSETOF(MatchResult, end)));
11844     m_jit.store8(
11845         TrustedImm32(0),
11846         JITCompiler::Address(globalObjectGPR, offset + RegExpCachedResult::offsetOfReified()));
11847 
11848     noResult(node);
11849 }
11850 
11851 void SpeculativeJIT::compileDefineDataProperty(Node* node)
11852 {
11853 #if USE(JSVALUE64)
11854     static_assert(GPRInfo::numberOfRegisters &gt;= 5, &quot;We are assuming we have enough registers to make this call without incrementally setting up the arguments.&quot;);
11855 #else
11856     static_assert(GPRInfo::numberOfRegisters &gt;= 6, &quot;We are assuming we have enough registers to make this call without incrementally setting up the arguments.&quot;);
11857 #endif
11858 
11859     SpeculateCellOperand base(this, m_jit.graph().varArgChild(node, 0));
11860     GPRReg baseGPR = base.gpr();
11861 
11862     JSValueOperand value(this, m_jit.graph().varArgChild(node, 2));
11863     JSValueRegs valueRegs = value.jsValueRegs();
11864 
11865     SpeculateInt32Operand attributes(this, m_jit.graph().varArgChild(node, 3));
11866     GPRReg attributesGPR = attributes.gpr();
11867 
11868     Edge&amp; propertyEdge = m_jit.graph().varArgChild(node, 1);
11869     switch (propertyEdge.useKind()) {
11870     case StringUse: {
11871         SpeculateCellOperand property(this, propertyEdge);
11872         GPRReg propertyGPR = property.gpr();
11873         speculateString(propertyEdge, propertyGPR);
11874 
11875         useChildren(node);
11876 
11877         flushRegisters();
<a name="288" id="anc288"></a><span class="line-modified">11878         callOperation(operationDefineDataPropertyString, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyGPR, valueRegs, attributesGPR);</span>
11879         m_jit.exceptionCheck();
11880         break;
11881     }
11882     case StringIdentUse: {
11883         SpeculateCellOperand property(this, propertyEdge);
11884         GPRTemporary ident(this);
11885 
11886         GPRReg propertyGPR = property.gpr();
11887         GPRReg identGPR = ident.gpr();
11888 
11889         speculateString(propertyEdge, propertyGPR);
11890         speculateStringIdentAndLoadStorage(propertyEdge, propertyGPR, identGPR);
11891 
11892         useChildren(node);
11893 
11894         flushRegisters();
<a name="289" id="anc289"></a><span class="line-modified">11895         callOperation(operationDefineDataPropertyStringIdent, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, identGPR, valueRegs, attributesGPR);</span>
11896         m_jit.exceptionCheck();
11897         break;
11898     }
11899     case SymbolUse: {
11900         SpeculateCellOperand property(this, propertyEdge);
11901         GPRReg propertyGPR = property.gpr();
11902         speculateSymbol(propertyEdge, propertyGPR);
11903 
11904         useChildren(node);
11905 
11906         flushRegisters();
<a name="290" id="anc290"></a><span class="line-modified">11907         callOperation(operationDefineDataPropertySymbol, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyGPR, valueRegs, attributesGPR);</span>
11908         m_jit.exceptionCheck();
11909         break;
11910     }
11911     case UntypedUse: {
11912         JSValueOperand property(this, propertyEdge);
11913         JSValueRegs propertyRegs = property.jsValueRegs();
11914 
11915         useChildren(node);
11916 
11917         flushRegisters();
<a name="291" id="anc291"></a><span class="line-modified">11918         callOperation(operationDefineDataProperty, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyRegs, valueRegs, attributesGPR);</span>
11919         m_jit.exceptionCheck();
11920         break;
11921     }
11922     default:
11923         RELEASE_ASSERT_NOT_REACHED();
11924     }
11925 
11926     noResult(node, UseChildrenCalledExplicitly);
11927 }
11928 
11929 void SpeculativeJIT::compileDefineAccessorProperty(Node* node)
11930 {
11931 #if USE(JSVALUE64)
11932     static_assert(GPRInfo::numberOfRegisters &gt;= 5, &quot;We are assuming we have enough registers to make this call without incrementally setting up the arguments.&quot;);
11933 #else
11934     static_assert(GPRInfo::numberOfRegisters &gt;= 6, &quot;We are assuming we have enough registers to make this call without incrementally setting up the arguments.&quot;);
11935 #endif
11936 
11937     SpeculateCellOperand base(this, m_jit.graph().varArgChild(node, 0));
11938     GPRReg baseGPR = base.gpr();
11939 
11940     SpeculateCellOperand getter(this, m_jit.graph().varArgChild(node, 2));
11941     GPRReg getterGPR = getter.gpr();
11942 
11943     SpeculateCellOperand setter(this, m_jit.graph().varArgChild(node, 3));
11944     GPRReg setterGPR = setter.gpr();
11945 
11946     SpeculateInt32Operand attributes(this, m_jit.graph().varArgChild(node, 4));
11947     GPRReg attributesGPR = attributes.gpr();
11948 
11949     Edge&amp; propertyEdge = m_jit.graph().varArgChild(node, 1);
11950     switch (propertyEdge.useKind()) {
11951     case StringUse: {
11952         SpeculateCellOperand property(this, propertyEdge);
11953         GPRReg propertyGPR = property.gpr();
11954         speculateString(propertyEdge, propertyGPR);
11955 
11956         useChildren(node);
11957 
11958         flushRegisters();
<a name="292" id="anc292"></a><span class="line-modified">11959         callOperation(operationDefineAccessorPropertyString, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyGPR, getterGPR, setterGPR, attributesGPR);</span>
11960         m_jit.exceptionCheck();
11961         break;
11962     }
11963     case StringIdentUse: {
11964         SpeculateCellOperand property(this, propertyEdge);
11965         GPRTemporary ident(this);
11966 
11967         GPRReg propertyGPR = property.gpr();
11968         GPRReg identGPR = ident.gpr();
11969 
11970         speculateString(propertyEdge, propertyGPR);
11971         speculateStringIdentAndLoadStorage(propertyEdge, propertyGPR, identGPR);
11972 
11973         useChildren(node);
11974 
11975         flushRegisters();
<a name="293" id="anc293"></a><span class="line-modified">11976         callOperation(operationDefineAccessorPropertyStringIdent, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, identGPR, getterGPR, setterGPR, attributesGPR);</span>
11977         m_jit.exceptionCheck();
11978         break;
11979     }
11980     case SymbolUse: {
11981         SpeculateCellOperand property(this, propertyEdge);
11982         GPRReg propertyGPR = property.gpr();
11983         speculateSymbol(propertyEdge, propertyGPR);
11984 
11985         useChildren(node);
11986 
11987         flushRegisters();
<a name="294" id="anc294"></a><span class="line-modified">11988         callOperation(operationDefineAccessorPropertySymbol, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyGPR, getterGPR, setterGPR, attributesGPR);</span>
11989         m_jit.exceptionCheck();
11990         break;
11991     }
11992     case UntypedUse: {
11993         JSValueOperand property(this, propertyEdge);
11994         JSValueRegs propertyRegs = property.jsValueRegs();
11995 
11996         useChildren(node);
11997 
11998         flushRegisters();
<a name="295" id="anc295"></a><span class="line-modified">11999         callOperation(operationDefineAccessorProperty, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyRegs, getterGPR, setterGPR, attributesGPR);</span>
12000         m_jit.exceptionCheck();
12001         break;
12002     }
12003     default:
12004         RELEASE_ASSERT_NOT_REACHED();
12005     }
12006 
12007     noResult(node, UseChildrenCalledExplicitly);
12008 }
12009 
12010 void SpeculativeJIT::emitAllocateButterfly(GPRReg storageResultGPR, GPRReg sizeGPR, GPRReg scratch1, GPRReg scratch2, GPRReg scratch3, MacroAssembler::JumpList&amp; slowCases)
12011 {
12012     RELEASE_ASSERT(RegisterSet(storageResultGPR, sizeGPR, scratch1, scratch2, scratch3).numberOfSetGPRs() == 5);
12013     ASSERT((1 &lt;&lt; 3) == sizeof(JSValue));
12014     m_jit.zeroExtend32ToPtr(sizeGPR, scratch1);
12015     m_jit.lshift32(TrustedImm32(3), scratch1);
12016     m_jit.add32(TrustedImm32(sizeof(IndexingHeader)), scratch1, scratch2);
<a name="296" id="anc296"></a><span class="line-modified">12017 #if ASSERT_ENABLED</span>
12018     MacroAssembler::Jump didNotOverflow = m_jit.branch32(MacroAssembler::AboveOrEqual, scratch2, sizeGPR);
12019     m_jit.abortWithReason(UncheckedOverflow);
12020     didNotOverflow.link(&amp;m_jit);
12021 #endif
12022     m_jit.emitAllocateVariableSized(
12023         storageResultGPR, vm().jsValueGigacageAuxiliarySpace, scratch2, scratch1, scratch3, slowCases);
12024     m_jit.addPtr(TrustedImm32(sizeof(IndexingHeader)), storageResultGPR);
12025 
12026     m_jit.store32(sizeGPR, MacroAssembler::Address(storageResultGPR, Butterfly::offsetOfPublicLength()));
12027     m_jit.store32(sizeGPR, MacroAssembler::Address(storageResultGPR, Butterfly::offsetOfVectorLength()));
12028 }
12029 
12030 void SpeculativeJIT::compileNormalizeMapKey(Node* node)
12031 {
12032     ASSERT(node-&gt;child1().useKind() == UntypedUse);
12033     JSValueOperand key(this, node-&gt;child1());
12034     JSValueRegsTemporary result(this, Reuse, key);
12035     GPRTemporary scratch(this);
12036     FPRTemporary doubleValue(this);
12037     FPRTemporary temp(this);
12038 
12039     JSValueRegs keyRegs = key.jsValueRegs();
12040     JSValueRegs resultRegs = result.regs();
12041     GPRReg scratchGPR = scratch.gpr();
12042     FPRReg doubleValueFPR = doubleValue.fpr();
12043     FPRReg tempFPR = temp.fpr();
12044 
12045     CCallHelpers::JumpList passThroughCases;
12046     CCallHelpers::JumpList doneCases;
12047 
12048     passThroughCases.append(m_jit.branchIfNotNumber(keyRegs, scratchGPR));
12049     passThroughCases.append(m_jit.branchIfInt32(keyRegs));
12050 
12051 #if USE(JSVALUE64)
12052     m_jit.unboxDoubleWithoutAssertions(keyRegs.gpr(), scratchGPR, doubleValueFPR);
12053 #else
12054     unboxDouble(keyRegs.tagGPR(), keyRegs.payloadGPR(), doubleValueFPR, tempFPR);
12055 #endif
12056     auto notNaN = m_jit.branchIfNotNaN(doubleValueFPR);
12057     m_jit.moveTrustedValue(jsNaN(), resultRegs);
12058     doneCases.append(m_jit.jump());
12059 
12060     notNaN.link(&amp;m_jit);
12061     m_jit.truncateDoubleToInt32(doubleValueFPR, scratchGPR);
12062     m_jit.convertInt32ToDouble(scratchGPR, tempFPR);
12063     passThroughCases.append(m_jit.branchDouble(JITCompiler::DoubleNotEqual, doubleValueFPR, tempFPR));
12064 
12065     m_jit.boxInt32(scratchGPR, resultRegs);
12066     doneCases.append(m_jit.jump());
12067 
12068     passThroughCases.link(&amp;m_jit);
12069     m_jit.moveValueRegs(keyRegs, resultRegs);
12070 
12071     doneCases.link(&amp;m_jit);
12072     jsValueResult(resultRegs, node);
12073 }
12074 
12075 void SpeculativeJIT::compileGetMapBucketHead(Node* node)
12076 {
12077     SpeculateCellOperand map(this, node-&gt;child1());
12078     GPRTemporary bucket(this);
12079 
12080     GPRReg mapGPR = map.gpr();
12081     GPRReg bucketGPR = bucket.gpr();
12082 
12083     if (node-&gt;child1().useKind() == MapObjectUse)
12084         speculateMapObject(node-&gt;child1(), mapGPR);
12085     else if (node-&gt;child1().useKind() == SetObjectUse)
12086         speculateSetObject(node-&gt;child1(), mapGPR);
12087     else
12088         RELEASE_ASSERT_NOT_REACHED();
12089 
12090     ASSERT(HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::offsetOfHead() == HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKeyValue&gt;&gt;::offsetOfHead());
12091     m_jit.loadPtr(MacroAssembler::Address(mapGPR, HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::offsetOfHead()), bucketGPR);
12092     cellResult(bucketGPR, node);
12093 }
12094 
12095 void SpeculativeJIT::compileGetMapBucketNext(Node* node)
12096 {
12097     SpeculateCellOperand bucket(this, node-&gt;child1());
12098     GPRTemporary result(this);
12099 
12100     GPRReg bucketGPR = bucket.gpr();
12101     GPRReg resultGPR = result.gpr();
12102 
12103     ASSERT(HashMapBucket&lt;HashMapBucketDataKey&gt;::offsetOfNext() == HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfNext());
12104     ASSERT(HashMapBucket&lt;HashMapBucketDataKey&gt;::offsetOfKey() == HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey());
12105     m_jit.loadPtr(MacroAssembler::Address(bucketGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfNext()), resultGPR);
12106 
12107     MacroAssembler::Label loop = m_jit.label();
12108     auto notBucket = m_jit.branchTestPtr(MacroAssembler::Zero, resultGPR);
12109 #if USE(JSVALUE32_64)
12110     auto done = m_jit.branch32(MacroAssembler::NotEqual, MacroAssembler::Address(resultGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey() + TagOffset), TrustedImm32(JSValue::EmptyValueTag));
12111 #else
12112     auto done = m_jit.branchTest64(MacroAssembler::NonZero, MacroAssembler::Address(resultGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey()));
12113 #endif
12114     m_jit.loadPtr(MacroAssembler::Address(resultGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfNext()), resultGPR);
12115     m_jit.jump().linkTo(loop, &amp;m_jit);
12116 
12117     notBucket.link(&amp;m_jit);
12118     JSCell* sentinel = nullptr;
12119     if (node-&gt;bucketOwnerType() == BucketOwnerType::Map)
12120         sentinel = vm().sentinelMapBucket();
12121     else {
12122         ASSERT(node-&gt;bucketOwnerType() == BucketOwnerType::Set);
12123         sentinel = vm().sentinelSetBucket();
12124     }
12125     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), sentinel), resultGPR);
12126     done.link(&amp;m_jit);
12127 
12128     cellResult(resultGPR, node);
12129 }
12130 
12131 void SpeculativeJIT::compileLoadKeyFromMapBucket(Node* node)
12132 {
12133     SpeculateCellOperand bucket(this, node-&gt;child1());
12134     JSValueRegsTemporary result(this);
12135 
12136     GPRReg bucketGPR = bucket.gpr();
12137     JSValueRegs resultRegs = result.regs();
12138 
12139     m_jit.loadValue(MacroAssembler::Address(bucketGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey()), resultRegs);
12140     jsValueResult(resultRegs, node);
12141 }
12142 
12143 void SpeculativeJIT::compileLoadValueFromMapBucket(Node* node)
12144 {
12145     SpeculateCellOperand bucket(this, node-&gt;child1());
12146     JSValueRegsTemporary result(this);
12147 
12148     GPRReg bucketGPR = bucket.gpr();
12149     JSValueRegs resultRegs = result.regs();
12150 
12151     m_jit.loadValue(MacroAssembler::Address(bucketGPR, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfValue()), resultRegs);
12152     jsValueResult(resultRegs, node);
12153 }
12154 
12155 void SpeculativeJIT::compileExtractValueFromWeakMapGet(Node* node)
12156 {
12157     JSValueOperand value(this, node-&gt;child1());
12158     JSValueRegsTemporary result(this, Reuse, value);
12159 
12160     JSValueRegs valueRegs = value.jsValueRegs();
12161     JSValueRegs resultRegs = result.regs();
12162 
12163 #if USE(JSVALUE64)
12164     m_jit.moveValueRegs(valueRegs, resultRegs);
12165     auto done = m_jit.branchTestPtr(CCallHelpers::NonZero, resultRegs.payloadGPR());
12166     m_jit.moveValue(jsUndefined(), resultRegs);
12167     done.link(&amp;m_jit);
12168 #else
12169     auto isEmpty = m_jit.branchIfEmpty(valueRegs.tagGPR());
12170     m_jit.moveValueRegs(valueRegs, resultRegs);
12171     auto done = m_jit.jump();
12172 
12173     isEmpty.link(&amp;m_jit);
12174     m_jit.moveValue(jsUndefined(), resultRegs);
12175 
12176     done.link(&amp;m_jit);
12177 #endif
12178 
12179     jsValueResult(resultRegs, node, DataFormatJS);
12180 }
12181 
12182 void SpeculativeJIT::compileThrow(Node* node)
12183 {
12184     JSValueOperand value(this, node-&gt;child1());
12185     JSValueRegs valueRegs = value.jsValueRegs();
12186     flushRegisters();
<a name="297" id="anc297"></a><span class="line-modified">12187     callOperation(operationThrowDFG, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs);</span>
12188     m_jit.exceptionCheck();
12189     m_jit.breakpoint();
12190     noResult(node);
12191 }
12192 
12193 void SpeculativeJIT::compileThrowStaticError(Node* node)
12194 {
12195     SpeculateCellOperand message(this, node-&gt;child1());
12196     GPRReg messageGPR = message.gpr();
12197     speculateString(node-&gt;child1(), messageGPR);
12198     flushRegisters();
<a name="298" id="anc298"></a><span class="line-modified">12199     callOperation(operationThrowStaticError, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), messageGPR, node-&gt;errorType());</span>
12200     m_jit.exceptionCheck();
12201     m_jit.breakpoint();
12202     noResult(node);
12203 }
12204 
12205 void SpeculativeJIT::compileGetEnumerableLength(Node* node)
12206 {
12207     SpeculateCellOperand enumerator(this, node-&gt;child1());
12208     GPRFlushedCallResult result(this);
12209     GPRReg resultGPR = result.gpr();
12210 
12211     m_jit.load32(MacroAssembler::Address(enumerator.gpr(), JSPropertyNameEnumerator::indexedLengthOffset()), resultGPR);
12212     int32Result(resultGPR, node);
12213 }
12214 
12215 void SpeculativeJIT::compileHasGenericProperty(Node* node)
12216 {
12217     JSValueOperand base(this, node-&gt;child1());
12218     SpeculateCellOperand property(this, node-&gt;child2());
12219 
12220     JSValueRegs baseRegs = base.jsValueRegs();
12221     GPRReg propertyGPR = property.gpr();
12222 
12223     flushRegisters();
12224     JSValueRegsFlushedCallResult result(this);
12225     JSValueRegs resultRegs = result.regs();
<a name="299" id="anc299"></a><span class="line-modified">12226     callOperation(operationHasGenericProperty, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseRegs, propertyGPR);</span>
12227     m_jit.exceptionCheck();
12228     blessedBooleanResult(resultRegs.payloadGPR(), node);
12229 }
12230 
12231 void SpeculativeJIT::compileToIndexString(Node* node)
12232 {
12233     SpeculateInt32Operand index(this, node-&gt;child1());
12234     GPRReg indexGPR = index.gpr();
12235 
12236     flushRegisters();
12237     GPRFlushedCallResult result(this);
12238     GPRReg resultGPR = result.gpr();
<a name="300" id="anc300"></a><span class="line-modified">12239     callOperation(operationToIndexString, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), indexGPR);</span>
12240     m_jit.exceptionCheck();
12241     cellResult(resultGPR, node);
12242 }
12243 
12244 void SpeculativeJIT::compilePutByIdFlush(Node* node)
12245 {
12246     SpeculateCellOperand base(this, node-&gt;child1());
12247     JSValueOperand value(this, node-&gt;child2());
12248     GPRTemporary scratch(this);
12249 
12250     GPRReg baseGPR = base.gpr();
12251     JSValueRegs valueRegs = value.jsValueRegs();
12252     GPRReg scratchGPR = scratch.gpr();
12253     flushRegisters();
12254 
12255     cachedPutById(node-&gt;origin.semantic, baseGPR, valueRegs, scratchGPR, node-&gt;identifierNumber(), NotDirect, MacroAssembler::Jump(), DontSpill);
12256 
12257     noResult(node);
12258 }
12259 
12260 void SpeculativeJIT::compilePutById(Node* node)
12261 {
12262     SpeculateCellOperand base(this, node-&gt;child1());
12263     JSValueOperand value(this, node-&gt;child2());
12264     GPRTemporary scratch(this);
12265 
12266     GPRReg baseGPR = base.gpr();
12267     JSValueRegs valueRegs = value.jsValueRegs();
12268     GPRReg scratchGPR = scratch.gpr();
12269 
12270     cachedPutById(node-&gt;origin.semantic, baseGPR, valueRegs, scratchGPR, node-&gt;identifierNumber(), NotDirect);
12271 
12272     noResult(node);
12273 }
12274 
12275 void SpeculativeJIT::compilePutByIdDirect(Node* node)
12276 {
12277     SpeculateCellOperand base(this, node-&gt;child1());
12278     JSValueOperand value(this, node-&gt;child2());
12279     GPRTemporary scratch(this);
12280 
12281     GPRReg baseGPR = base.gpr();
12282     JSValueRegs valueRegs = value.jsValueRegs();
12283     GPRReg scratchGPR = scratch.gpr();
12284 
12285     cachedPutById(node-&gt;origin.semantic, baseGPR, valueRegs, scratchGPR, node-&gt;identifierNumber(), Direct);
12286 
12287     noResult(node);
12288 }
12289 
12290 void SpeculativeJIT::compilePutByIdWithThis(Node* node)
12291 {
12292     JSValueOperand base(this, node-&gt;child1());
12293     JSValueRegs baseRegs = base.jsValueRegs();
12294     JSValueOperand thisValue(this, node-&gt;child2());
12295     JSValueRegs thisRegs = thisValue.jsValueRegs();
12296     JSValueOperand value(this, node-&gt;child3());
12297     JSValueRegs valueRegs = value.jsValueRegs();
12298 
12299     flushRegisters();
12300     callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByIdWithThisStrict : operationPutByIdWithThis,
<a name="301" id="anc301"></a><span class="line-modified">12301         TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseRegs, thisRegs, valueRegs, identifierUID(node-&gt;identifierNumber()));</span>
12302     m_jit.exceptionCheck();
12303 
12304     noResult(node);
12305 }
12306 
12307 void SpeculativeJIT::compileGetByOffset(Node* node)
12308 {
12309     StorageOperand storage(this, node-&gt;child1());
12310     JSValueRegsTemporary result(this, Reuse, storage);
12311 
12312     GPRReg storageGPR = storage.gpr();
12313     JSValueRegs resultRegs = result.regs();
12314 
12315     StorageAccessData&amp; storageAccessData = node-&gt;storageAccessData();
12316 
12317     m_jit.loadValue(JITCompiler::Address(storageGPR, offsetRelativeToBase(storageAccessData.offset)), resultRegs);
12318 
12319     jsValueResult(resultRegs, node);
12320 }
12321 
12322 void SpeculativeJIT::compilePutByOffset(Node* node)
12323 {
12324     StorageOperand storage(this, node-&gt;child1());
12325     JSValueOperand value(this, node-&gt;child3());
12326 
12327     GPRReg storageGPR = storage.gpr();
12328     JSValueRegs valueRegs = value.jsValueRegs();
12329 
12330     speculate(node, node-&gt;child2());
12331 
12332     StorageAccessData&amp; storageAccessData = node-&gt;storageAccessData();
12333 
12334     m_jit.storeValue(valueRegs, JITCompiler::Address(storageGPR, offsetRelativeToBase(storageAccessData.offset)));
12335 
12336     noResult(node);
12337 }
12338 
12339 void SpeculativeJIT::compileMatchStructure(Node* node)
12340 {
12341     SpeculateCellOperand base(this, node-&gt;child1());
12342     GPRTemporary temp(this);
12343     GPRReg baseGPR = base.gpr();
12344     GPRReg tempGPR = temp.gpr();
12345 
12346     m_jit.load32(JITCompiler::Address(baseGPR, JSCell::structureIDOffset()), tempGPR);
12347 
12348     auto&amp; variants = node-&gt;matchStructureData().variants;
12349     Vector&lt;int64_t&gt; cases;
12350     for (MatchStructureVariant&amp; variant : variants)
12351         cases.append(bitwise_cast&lt;int32_t&gt;(variant.structure-&gt;id()));
12352 
12353     BinarySwitch binarySwitch(tempGPR, cases, BinarySwitch::Int32);
12354     JITCompiler::JumpList done;
12355     while (binarySwitch.advance(m_jit)) {
12356         m_jit.boxBooleanPayload(variants[binarySwitch.caseIndex()].result, tempGPR);
12357         done.append(m_jit.jump());
12358     }
12359     speculationCheck(BadCache, JSValueRegs(), node, binarySwitch.fallThrough());
12360 
12361     done.link(&amp;m_jit);
12362 
12363     blessedBooleanResult(tempGPR, node);
12364 }
12365 
12366 void SpeculativeJIT::compileHasStructureProperty(Node* node)
12367 {
12368     JSValueOperand base(this, node-&gt;child1());
12369     SpeculateCellOperand property(this, node-&gt;child2());
12370     SpeculateCellOperand enumerator(this, node-&gt;child3());
12371     JSValueRegsTemporary result(this);
12372 
12373     JSValueRegs baseRegs = base.jsValueRegs();
12374     GPRReg propertyGPR = property.gpr();
12375     JSValueRegs resultRegs = result.regs();
12376 
12377     CCallHelpers::JumpList wrongStructure;
12378 
12379     wrongStructure.append(m_jit.branchIfNotCell(baseRegs));
12380 
12381     m_jit.load32(MacroAssembler::Address(baseRegs.payloadGPR(), JSCell::structureIDOffset()), resultRegs.payloadGPR());
12382     wrongStructure.append(m_jit.branch32(MacroAssembler::NotEqual,
12383         resultRegs.payloadGPR(),
12384         MacroAssembler::Address(enumerator.gpr(), JSPropertyNameEnumerator::cachedStructureIDOffset())));
12385 
12386     moveTrueTo(resultRegs.payloadGPR());
12387     MacroAssembler::Jump done = m_jit.jump();
12388 
12389     done.link(&amp;m_jit);
12390 
<a name="302" id="anc302"></a><span class="line-modified">12391     addSlowPathGenerator(slowPathCall(wrongStructure, this, operationHasGenericProperty, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseRegs, propertyGPR));</span>
12392     blessedBooleanResult(resultRegs.payloadGPR(), node);
12393 }
12394 
12395 void SpeculativeJIT::compileGetPropertyEnumerator(Node* node)
12396 {
12397     if (node-&gt;child1().useKind() == CellUse) {
12398         SpeculateCellOperand base(this, node-&gt;child1());
12399         GPRReg baseGPR = base.gpr();
12400 
12401         flushRegisters();
12402         GPRFlushedCallResult result(this);
12403         GPRReg resultGPR = result.gpr();
<a name="303" id="anc303"></a><span class="line-modified">12404         callOperation(operationGetPropertyEnumeratorCell, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR);</span>
12405         m_jit.exceptionCheck();
12406         cellResult(resultGPR, node);
12407         return;
12408     }
12409 
12410     JSValueOperand base(this, node-&gt;child1());
12411     JSValueRegs baseRegs = base.jsValueRegs();
12412 
12413     flushRegisters();
12414     GPRFlushedCallResult result(this);
12415     GPRReg resultGPR = result.gpr();
<a name="304" id="anc304"></a><span class="line-modified">12416     callOperation(operationGetPropertyEnumerator, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseRegs);</span>
12417     m_jit.exceptionCheck();
12418     cellResult(resultGPR, node);
12419 }
12420 
12421 void SpeculativeJIT::compileGetEnumeratorPname(Node* node)
12422 {
12423     ASSERT(node-&gt;op() == GetEnumeratorStructurePname || node-&gt;op() == GetEnumeratorGenericPname);
12424     SpeculateCellOperand enumerator(this, node-&gt;child1());
12425     SpeculateStrictInt32Operand index(this, node-&gt;child2());
12426     GPRTemporary scratch(this);
12427     JSValueRegsTemporary result(this);
12428 
12429     GPRReg enumeratorGPR = enumerator.gpr();
12430     GPRReg indexGPR = index.gpr();
12431     GPRReg scratchGPR = scratch.gpr();
12432     JSValueRegs resultRegs = result.regs();
12433 
12434     MacroAssembler::Jump inBounds = m_jit.branch32(MacroAssembler::Below, indexGPR,
12435         MacroAssembler::Address(enumeratorGPR, (node-&gt;op() == GetEnumeratorStructurePname)
12436             ? JSPropertyNameEnumerator::endStructurePropertyIndexOffset()
12437             : JSPropertyNameEnumerator::endGenericPropertyIndexOffset()));
12438 
12439     m_jit.moveValue(jsNull(), resultRegs);
12440 
12441     MacroAssembler::Jump done = m_jit.jump();
12442     inBounds.link(&amp;m_jit);
12443 
12444     m_jit.loadPtr(MacroAssembler::Address(enumeratorGPR, JSPropertyNameEnumerator::cachedPropertyNamesVectorOffset()), scratchGPR);
12445     m_jit.loadPtr(MacroAssembler::BaseIndex(scratchGPR, indexGPR, MacroAssembler::ScalePtr), resultRegs.payloadGPR());
12446 #if USE(JSVALUE32_64)
12447     m_jit.move(MacroAssembler::TrustedImm32(JSValue::CellTag), resultRegs.tagGPR());
12448 #endif
12449 
12450     done.link(&amp;m_jit);
12451     jsValueResult(resultRegs, node);
12452 }
12453 
12454 void SpeculativeJIT::compileGetExecutable(Node* node)
12455 {
12456     SpeculateCellOperand function(this, node-&gt;child1());
12457     GPRTemporary result(this, Reuse, function);
12458     GPRReg functionGPR = function.gpr();
12459     GPRReg resultGPR = result.gpr();
12460     speculateCellType(node-&gt;child1(), functionGPR, SpecFunction, JSFunctionType);
<a name="305" id="anc305"></a><span class="line-modified">12461     m_jit.loadPtr(JITCompiler::Address(functionGPR, JSFunction::offsetOfExecutableOrRareData()), resultGPR);</span>
<span class="line-added">12462     auto hasExecutable = m_jit.branchTestPtr(CCallHelpers::Zero, resultGPR, CCallHelpers::TrustedImm32(JSFunction::rareDataTag));</span>
<span class="line-added">12463     m_jit.loadPtr(CCallHelpers::Address(resultGPR, FunctionRareData::offsetOfExecutable() - JSFunction::rareDataTag), resultGPR);</span>
<span class="line-added">12464     hasExecutable.link(&amp;m_jit);</span>
12465     cellResult(resultGPR, node);
12466 }
12467 
12468 void SpeculativeJIT::compileGetGetter(Node* node)
12469 {
12470     SpeculateCellOperand op1(this, node-&gt;child1());
12471     GPRTemporary result(this, Reuse, op1);
12472 
12473     GPRReg op1GPR = op1.gpr();
12474     GPRReg resultGPR = result.gpr();
12475 
12476     m_jit.loadPtr(JITCompiler::Address(op1GPR, GetterSetter::offsetOfGetter()), resultGPR);
12477 
12478     cellResult(resultGPR, node);
12479 }
12480 
12481 void SpeculativeJIT::compileGetSetter(Node* node)
12482 {
12483     SpeculateCellOperand op1(this, node-&gt;child1());
12484     GPRTemporary result(this, Reuse, op1);
12485 
12486     GPRReg op1GPR = op1.gpr();
12487     GPRReg resultGPR = result.gpr();
12488 
12489     m_jit.loadPtr(JITCompiler::Address(op1GPR, GetterSetter::offsetOfSetter()), resultGPR);
12490 
12491     cellResult(resultGPR, node);
12492 }
12493 
12494 void SpeculativeJIT::compileGetCallee(Node* node)
12495 {
12496     GPRTemporary result(this);
12497     m_jit.loadPtr(JITCompiler::payloadFor(CallFrameSlot::callee), result.gpr());
12498     cellResult(result.gpr(), node);
12499 }
12500 
12501 void SpeculativeJIT::compileSetCallee(Node* node)
12502 {
12503     SpeculateCellOperand callee(this, node-&gt;child1());
12504     m_jit.storeCell(callee.gpr(), JITCompiler::payloadFor(CallFrameSlot::callee));
12505     noResult(node);
12506 }
12507 
12508 void SpeculativeJIT::compileGetArgumentCountIncludingThis(Node* node)
12509 {
12510     GPRTemporary result(this);
12511     VirtualRegister argumentCountRegister;
12512     if (InlineCallFrame* inlineCallFrame = node-&gt;argumentsInlineCallFrame())
12513         argumentCountRegister = inlineCallFrame-&gt;argumentCountRegister;
12514     else
<a name="306" id="anc306"></a><span class="line-modified">12515         argumentCountRegister = CallFrameSlot::argumentCountIncludingThis;</span>
12516     m_jit.load32(JITCompiler::payloadFor(argumentCountRegister), result.gpr());
12517     int32Result(result.gpr(), node);
12518 }
12519 
12520 void SpeculativeJIT::compileSetArgumentCountIncludingThis(Node* node)
12521 {
<a name="307" id="anc307"></a><span class="line-modified">12522     m_jit.store32(TrustedImm32(node-&gt;argumentCountIncludingThis()), JITCompiler::payloadFor(CallFrameSlot::argumentCountIncludingThis));</span>
12523     noResult(node);
12524 }
12525 
12526 void SpeculativeJIT::compileStrCat(Node* node)
12527 {
12528     JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
12529     JSValueOperand op2(this, node-&gt;child2(), ManualOperandSpeculation);
12530     JSValueOperand op3(this, node-&gt;child3(), ManualOperandSpeculation);
12531 
12532     JSValueRegs op1Regs = op1.jsValueRegs();
12533     JSValueRegs op2Regs = op2.jsValueRegs();
12534     JSValueRegs op3Regs;
12535 
12536     if (node-&gt;child3())
12537         op3Regs = op3.jsValueRegs();
12538 
12539     flushRegisters();
12540 
12541     GPRFlushedCallResult result(this);
12542     if (node-&gt;child3())
<a name="308" id="anc308"></a><span class="line-modified">12543         callOperation(operationStrCat3, result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs, op2Regs, op3Regs);</span>
12544     else
<a name="309" id="anc309"></a><span class="line-modified">12545         callOperation(operationStrCat2, result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), op1Regs, op2Regs);</span>
12546     m_jit.exceptionCheck();
12547 
12548     cellResult(result.gpr(), node);
12549 }
12550 
12551 void SpeculativeJIT::compileNewArrayBuffer(Node* node)
12552 {
12553     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
12554     auto* array = node-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
12555 
12556     IndexingType indexingMode = node-&gt;indexingMode();
12557     RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingMode));
12558 
12559     if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(indexingMode)) {
12560         GPRTemporary result(this);
12561         GPRTemporary scratch1(this);
12562         GPRTemporary scratch2(this);
12563 
12564         GPRReg resultGPR = result.gpr();
12565         GPRReg scratch1GPR = scratch1.gpr();
12566         GPRReg scratch2GPR = scratch2.gpr();
12567 
12568         MacroAssembler::JumpList slowCases;
12569 
12570         emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(structure), TrustedImmPtr(array-&gt;toButterfly()), scratch1GPR, scratch2GPR, slowCases);
12571 
<a name="310" id="anc310"></a><span class="line-modified">12572         addSlowPathGenerator(slowPathCall(slowCases, this, operationNewArrayBuffer, result.gpr(), &amp;vm(), structure, array));</span>
12573 
12574         DFG_ASSERT(m_jit.graph(), node, indexingMode &amp; IsArray, indexingMode);
12575         cellResult(resultGPR, node);
12576         return;
12577     }
12578 
12579     flushRegisters();
12580     GPRFlushedCallResult result(this);
12581 
<a name="311" id="anc311"></a><span class="line-modified">12582     callOperation(operationNewArrayBuffer, result.gpr(), &amp;vm(), structure, TrustedImmPtr(node-&gt;cellOperand()));</span>
12583     m_jit.exceptionCheck();
12584 
12585     cellResult(result.gpr(), node);
12586 }
12587 
12588 void SpeculativeJIT::compileNewArrayWithSize(Node* node)
12589 {
12590     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
12591     if (!globalObject-&gt;isHavingABadTime() &amp;&amp; !hasAnyArrayStorage(node-&gt;indexingType())) {
12592         SpeculateStrictInt32Operand size(this, node-&gt;child1());
12593         GPRTemporary result(this);
12594 
12595         GPRReg sizeGPR = size.gpr();
12596         GPRReg resultGPR = result.gpr();
12597 
12598         compileAllocateNewArrayWithSize(globalObject, resultGPR, sizeGPR, node-&gt;indexingType());
12599         cellResult(resultGPR, node);
12600         return;
12601     }
12602 
12603     SpeculateStrictInt32Operand size(this, node-&gt;child1());
12604     GPRReg sizeGPR = size.gpr();
12605     flushRegisters();
12606     GPRFlushedCallResult result(this);
12607     GPRReg resultGPR = result.gpr();
12608     GPRReg structureGPR = AssemblyHelpers::selectScratchGPR(sizeGPR);
12609     MacroAssembler::Jump bigLength = m_jit.branch32(MacroAssembler::AboveOrEqual, sizeGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH));
12610     m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType()))), structureGPR);
12611     MacroAssembler::Jump done = m_jit.jump();
12612     bigLength.link(&amp;m_jit);
12613     m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage))), structureGPR);
12614     done.link(&amp;m_jit);
<a name="312" id="anc312"></a><span class="line-modified">12615     callOperation(operationNewArrayWithSize, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), structureGPR, sizeGPR, nullptr);</span>
12616     m_jit.exceptionCheck();
12617     cellResult(resultGPR, node);
12618 }
12619 
12620 void SpeculativeJIT::compileNewTypedArray(Node* node)
12621 {
12622     switch (node-&gt;child1().useKind()) {
12623     case Int32Use:
12624         compileNewTypedArrayWithSize(node);
12625         break;
12626     case UntypedUse: {
12627         JSValueOperand argument(this, node-&gt;child1());
12628         JSValueRegs argumentRegs = argument.jsValueRegs();
12629 
12630         flushRegisters();
12631 
12632         GPRFlushedCallResult result(this);
12633         GPRReg resultGPR = result.gpr();
12634 
12635         JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
12636         callOperation(
12637             operationNewTypedArrayWithOneArgumentForType(node-&gt;typedArrayType()),
<a name="313" id="anc313"></a><span class="line-modified">12638             resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), m_jit.graph().registerStructure(globalObject-&gt;typedArrayStructureConcurrently(node-&gt;typedArrayType())), argumentRegs);</span>
12639         m_jit.exceptionCheck();
12640 
12641         cellResult(resultGPR, node);
12642         break;
12643     }
12644     default:
12645         RELEASE_ASSERT_NOT_REACHED();
12646         break;
12647     }
12648 }
12649 
12650 void SpeculativeJIT::compileToThis(Node* node)
12651 {
12652     ASSERT(node-&gt;child1().useKind() == UntypedUse);
12653     JSValueOperand thisValue(this, node-&gt;child1());
12654     JSValueRegsTemporary temp(this);
12655 
12656     JSValueRegs thisValueRegs = thisValue.jsValueRegs();
12657     JSValueRegs tempRegs = temp.regs();
12658 
12659     MacroAssembler::JumpList slowCases;
12660     slowCases.append(m_jit.branchIfNotCell(thisValueRegs));
12661     slowCases.append(
12662         m_jit.branchTest8(
12663             MacroAssembler::NonZero,
12664             MacroAssembler::Address(thisValueRegs.payloadGPR(), JSCell::typeInfoFlagsOffset()),
12665             MacroAssembler::TrustedImm32(OverridesToThis)));
12666     m_jit.moveValueRegs(thisValueRegs, tempRegs);
12667 
<a name="314" id="anc314"></a><span class="line-modified">12668     J_JITOperation_GJ function;</span>
12669     if (m_jit.isStrictModeFor(node-&gt;origin.semantic))
12670         function = operationToThisStrict;
12671     else
12672         function = operationToThis;
<a name="315" id="anc315"></a><span class="line-modified">12673     addSlowPathGenerator(slowPathCall(slowCases, this, function, tempRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), thisValueRegs));</span>
12674 
12675     jsValueResult(tempRegs, node);
12676 }
12677 
12678 void SpeculativeJIT::compileObjectKeys(Node* node)
12679 {
12680     switch (node-&gt;child1().useKind()) {
12681     case ObjectUse: {
12682         if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
12683             SpeculateCellOperand object(this, node-&gt;child1());
12684             GPRTemporary structure(this);
12685             GPRTemporary scratch(this);
12686             GPRTemporary scratch2(this);
12687             GPRTemporary scratch3(this);
12688             GPRTemporary result(this);
12689 
12690             GPRReg objectGPR = object.gpr();
12691             GPRReg structureGPR = structure.gpr();
12692             GPRReg scratchGPR = scratch.gpr();
12693             GPRReg scratch2GPR = scratch2.gpr();
12694             GPRReg scratch3GPR = scratch3.gpr();
12695             GPRReg resultGPR = result.gpr();
12696 
12697             speculateObject(node-&gt;child1(), objectGPR);
12698 
12699             CCallHelpers::JumpList slowCases;
12700             m_jit.emitLoadStructure(vm(), objectGPR, structureGPR, scratchGPR);
12701             m_jit.loadPtr(CCallHelpers::Address(structureGPR, Structure::previousOrRareDataOffset()), scratchGPR);
12702 
12703             slowCases.append(m_jit.branchTestPtr(CCallHelpers::Zero, scratchGPR));
12704             slowCases.append(m_jit.branch32(CCallHelpers::Equal, CCallHelpers::Address(scratchGPR, JSCell::structureIDOffset()), TrustedImm32(bitwise_cast&lt;int32_t&gt;(vm().structureStructure-&gt;structureID()))));
12705 
12706             m_jit.loadPtr(CCallHelpers::Address(scratchGPR, StructureRareData::offsetOfCachedOwnKeys()), scratchGPR);
12707 
12708             ASSERT(bitwise_cast&lt;uintptr_t&gt;(StructureRareData::cachedOwnKeysSentinel()) == 1);
12709             slowCases.append(m_jit.branchPtr(CCallHelpers::BelowOrEqual, scratchGPR, TrustedImmPtr(bitwise_cast&lt;void*&gt;(StructureRareData::cachedOwnKeysSentinel()))));
12710 
12711             MacroAssembler::JumpList slowButArrayBufferCases;
12712 
12713             JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
12714             RegisteredStructure arrayStructure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(CopyOnWriteArrayWithContiguous));
12715 
12716             m_jit.move(scratchGPR, scratch3GPR);
<a name="316" id="anc316"></a><span class="line-modified">12717             m_jit.addPtr(TrustedImm32(JSImmutableButterfly::offsetOfData()), scratchGPR);</span>
12718 
12719             emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(arrayStructure), scratchGPR, structureGPR, scratch2GPR, slowButArrayBufferCases);
12720 
<a name="317" id="anc317"></a><span class="line-modified">12721             addSlowPathGenerator(slowPathCall(slowButArrayBufferCases, this, operationNewArrayBuffer, resultGPR, &amp;vm(), arrayStructure, scratch3GPR));</span>
12722 
<a name="318" id="anc318"></a><span class="line-modified">12723             addSlowPathGenerator(slowPathCall(slowCases, this, operationObjectKeysObject, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), objectGPR));</span>
12724 
12725             cellResult(resultGPR, node);
12726             break;
12727         }
12728 
12729         SpeculateCellOperand object(this, node-&gt;child1());
12730 
12731         GPRReg objectGPR = object.gpr();
12732 
12733         speculateObject(node-&gt;child1(), objectGPR);
12734 
12735         flushRegisters();
12736         GPRFlushedCallResult result(this);
12737         GPRReg resultGPR = result.gpr();
<a name="319" id="anc319"></a><span class="line-modified">12738         callOperation(operationObjectKeysObject, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), objectGPR);</span>
12739         m_jit.exceptionCheck();
12740 
12741         cellResult(resultGPR, node);
12742         break;
12743     }
12744 
12745     case UntypedUse: {
12746         JSValueOperand object(this, node-&gt;child1());
12747 
12748         JSValueRegs objectRegs = object.jsValueRegs();
12749 
12750         flushRegisters();
12751         GPRFlushedCallResult result(this);
12752         GPRReg resultGPR = result.gpr();
<a name="320" id="anc320"></a><span class="line-modified">12753         callOperation(operationObjectKeys, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), objectRegs);</span>
12754         m_jit.exceptionCheck();
12755 
12756         cellResult(resultGPR, node);
12757         break;
12758     }
12759 
12760     default:
12761         RELEASE_ASSERT_NOT_REACHED();
12762         break;
12763     }
12764 }
12765 
12766 void SpeculativeJIT::compileObjectCreate(Node* node)
12767 {
12768     switch (node-&gt;child1().useKind()) {
12769     case ObjectUse: {
12770         SpeculateCellOperand prototype(this, node-&gt;child1());
12771 
12772         GPRReg prototypeGPR = prototype.gpr();
12773 
12774         speculateObject(node-&gt;child1(), prototypeGPR);
12775 
12776         flushRegisters();
12777         GPRFlushedCallResult result(this);
12778         GPRReg resultGPR = result.gpr();
<a name="321" id="anc321"></a><span class="line-modified">12779         callOperation(operationObjectCreateObject, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), prototypeGPR);</span>
12780         m_jit.exceptionCheck();
12781 
12782         cellResult(resultGPR, node);
12783         break;
12784     }
12785 
12786     case UntypedUse: {
12787         JSValueOperand prototype(this, node-&gt;child1());
12788 
12789         JSValueRegs prototypeRegs = prototype.jsValueRegs();
12790 
12791         flushRegisters();
12792         GPRFlushedCallResult result(this);
12793         GPRReg resultGPR = result.gpr();
<a name="322" id="anc322"></a><span class="line-modified">12794         callOperation(operationObjectCreate, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), prototypeRegs);</span>
12795         m_jit.exceptionCheck();
12796 
12797         cellResult(resultGPR, node);
12798         break;
12799     }
12800 
12801     default:
12802         RELEASE_ASSERT_NOT_REACHED();
12803         break;
12804     }
12805 }
12806 
12807 void SpeculativeJIT::compileCreateThis(Node* node)
12808 {
12809     // Note that there is not so much profit to speculate here. The only things we
12810     // speculate on are (1) that it&#39;s a cell, since that eliminates cell checks
12811     // later if the proto is reused, and (2) if we have a FinalObject prediction
12812     // then we speculate because we want to get recompiled if it isn&#39;t (since
12813     // otherwise we&#39;d start taking slow path a lot).
12814 
12815     SpeculateCellOperand callee(this, node-&gt;child1());
12816     GPRTemporary result(this);
12817     GPRTemporary allocator(this);
12818     GPRTemporary structure(this);
12819     GPRTemporary scratch(this);
12820 
12821     GPRReg calleeGPR = callee.gpr();
12822     GPRReg resultGPR = result.gpr();
12823     GPRReg allocatorGPR = allocator.gpr();
12824     GPRReg structureGPR = structure.gpr();
12825     GPRReg scratchGPR = scratch.gpr();
12826     // Rare data is only used to access the allocator &amp; structure
12827     // We can avoid using an additional GPR this way
12828     GPRReg rareDataGPR = structureGPR;
12829     GPRReg inlineCapacityGPR = rareDataGPR;
12830 
12831     MacroAssembler::JumpList slowPath;
12832 
12833     slowPath.append(m_jit.branchIfNotFunction(calleeGPR));
<a name="323" id="anc323"></a><span class="line-modified">12834     m_jit.loadPtr(JITCompiler::Address(calleeGPR, JSFunction::offsetOfExecutableOrRareData()), rareDataGPR);</span>
<span class="line-modified">12835     slowPath.append(m_jit.branchTestPtr(MacroAssembler::Zero, rareDataGPR, CCallHelpers::TrustedImm32(JSFunction::rareDataTag)));</span>
<span class="line-modified">12836     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfAllocator() - JSFunction::rareDataTag), allocatorGPR);</span>
<span class="line-modified">12837     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfStructure() - JSFunction::rareDataTag), structureGPR);</span>
12838 
12839     auto butterfly = TrustedImmPtr(nullptr);
12840     emitAllocateJSObject(resultGPR, JITAllocator::variable(), allocatorGPR, structureGPR, butterfly, scratchGPR, slowPath);
12841 
12842     m_jit.load8(JITCompiler::Address(structureGPR, Structure::inlineCapacityOffset()), inlineCapacityGPR);
12843     m_jit.emitInitializeInlineStorage(resultGPR, inlineCapacityGPR);
12844     m_jit.mutatorFence(vm());
12845 
<a name="324" id="anc324"></a><span class="line-modified">12846     addSlowPathGenerator(slowPathCall(slowPath, this, operationCreateThis, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), calleeGPR, node-&gt;inlineCapacity()));</span>
<span class="line-added">12847 </span>
<span class="line-added">12848     cellResult(resultGPR, node);</span>
<span class="line-added">12849 }</span>
<span class="line-added">12850 </span>
<span class="line-added">12851 void SpeculativeJIT::compileCreatePromise(Node* node)</span>
<span class="line-added">12852 {</span>
<span class="line-added">12853     JSGlobalObject* globalObject = m_jit.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="line-added">12854 </span>
<span class="line-added">12855     SpeculateCellOperand callee(this, node-&gt;child1());</span>
<span class="line-added">12856     GPRTemporary result(this);</span>
<span class="line-added">12857     GPRTemporary structure(this);</span>
<span class="line-added">12858     GPRTemporary scratch1(this);</span>
<span class="line-added">12859     GPRTemporary scratch2(this);</span>
<span class="line-added">12860 </span>
<span class="line-added">12861     GPRReg calleeGPR = callee.gpr();</span>
<span class="line-added">12862     GPRReg resultGPR = result.gpr();</span>
<span class="line-added">12863     GPRReg structureGPR = structure.gpr();</span>
<span class="line-added">12864     GPRReg scratch1GPR = scratch1.gpr();</span>
<span class="line-added">12865     GPRReg scratch2GPR = scratch2.gpr();</span>
<span class="line-added">12866     // Rare data is only used to access the allocator &amp; structure</span>
<span class="line-added">12867     // We can avoid using an additional GPR this way</span>
<span class="line-added">12868     GPRReg rareDataGPR = structureGPR;</span>
<span class="line-added">12869 </span>
<span class="line-added">12870     m_jit.move(TrustedImmPtr(m_jit.graph().registerStructure(node-&gt;isInternalPromise() ? globalObject-&gt;internalPromiseStructure() : globalObject-&gt;promiseStructure())), structureGPR);</span>
<span class="line-added">12871     auto fastPromisePath = m_jit.branchPtr(CCallHelpers::Equal, calleeGPR, TrustedImmPtr::weakPointer(m_jit.graph(), node-&gt;isInternalPromise() ? globalObject-&gt;internalPromiseConstructor() : globalObject-&gt;promiseConstructor()));</span>
<span class="line-added">12872 </span>
<span class="line-added">12873     MacroAssembler::JumpList slowCases;</span>
<span class="line-added">12874 </span>
<span class="line-added">12875     slowCases.append(m_jit.branchIfNotFunction(calleeGPR));</span>
<span class="line-added">12876     m_jit.loadPtr(JITCompiler::Address(calleeGPR, JSFunction::offsetOfExecutableOrRareData()), rareDataGPR);</span>
<span class="line-added">12877     slowCases.append(m_jit.branchTestPtr(MacroAssembler::Zero, rareDataGPR, CCallHelpers::TrustedImm32(JSFunction::rareDataTag)));</span>
<span class="line-added">12878     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfInternalFunctionAllocationProfile() + InternalFunctionAllocationProfile::offsetOfStructure() - JSFunction::rareDataTag), structureGPR);</span>
<span class="line-added">12879     slowCases.append(m_jit.branchTestPtr(CCallHelpers::Zero, structureGPR));</span>
<span class="line-added">12880     m_jit.move(TrustedImmPtr(node-&gt;isInternalPromise() ? JSInternalPromise::info() : JSPromise::info()), scratch1GPR);</span>
<span class="line-added">12881     slowCases.append(m_jit.branchPtr(CCallHelpers::NotEqual, scratch1GPR, CCallHelpers::Address(structureGPR, Structure::classInfoOffset())));</span>
<span class="line-added">12882     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), globalObject), scratch1GPR);</span>
<span class="line-added">12883     slowCases.append(m_jit.branchPtr(CCallHelpers::NotEqual, scratch1GPR, CCallHelpers::Address(structureGPR, Structure::globalObjectOffset())));</span>
<span class="line-added">12884 </span>
<span class="line-added">12885     fastPromisePath.link(&amp;m_jit);</span>
<span class="line-added">12886     auto butterfly = TrustedImmPtr(nullptr);</span>
<span class="line-added">12887     if (node-&gt;isInternalPromise())</span>
<span class="line-added">12888         emitAllocateJSObjectWithKnownSize&lt;JSInternalPromise&gt;(resultGPR, structureGPR, butterfly, scratch1GPR, scratch2GPR, slowCases, sizeof(JSInternalPromise));</span>
<span class="line-added">12889     else</span>
<span class="line-added">12890         emitAllocateJSObjectWithKnownSize&lt;JSPromise&gt;(resultGPR, structureGPR, butterfly, scratch1GPR, scratch2GPR, slowCases, sizeof(JSPromise));</span>
<span class="line-added">12891     m_jit.storeTrustedValue(jsNumber(static_cast&lt;unsigned&gt;(JSPromise::Status::Pending)), CCallHelpers::Address(resultGPR, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(static_cast&lt;unsigned&gt;(JSPromise::Field::Flags))));</span>
<span class="line-added">12892     m_jit.storeTrustedValue(jsUndefined(), CCallHelpers::Address(resultGPR, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(static_cast&lt;unsigned&gt;(JSPromise::Field::ReactionsOrResult))));</span>
<span class="line-added">12893     m_jit.mutatorFence(m_jit.vm());</span>
<span class="line-added">12894 </span>
<span class="line-added">12895     addSlowPathGenerator(slowPathCall(slowCases, this, node-&gt;isInternalPromise() ? operationCreateInternalPromise : operationCreatePromise, resultGPR, TrustedImmPtr::weakPointer(m_jit.graph(), globalObject), calleeGPR));</span>
12896 
12897     cellResult(resultGPR, node);
12898 }
12899 
<a name="325" id="anc325"></a><span class="line-added">12900 </span>
<span class="line-added">12901 template&lt;typename JSClass, typename Operation&gt;</span>
<span class="line-added">12902 void SpeculativeJIT::compileCreateInternalFieldObject(Node* node, Operation operation)</span>
<span class="line-added">12903 {</span>
<span class="line-added">12904     JSGlobalObject* globalObject = m_jit.globalObjectFor(node-&gt;origin.semantic);</span>
<span class="line-added">12905 </span>
<span class="line-added">12906     SpeculateCellOperand callee(this, node-&gt;child1());</span>
<span class="line-added">12907     GPRTemporary result(this);</span>
<span class="line-added">12908     GPRTemporary structure(this);</span>
<span class="line-added">12909     GPRTemporary scratch1(this);</span>
<span class="line-added">12910     GPRTemporary scratch2(this);</span>
<span class="line-added">12911 </span>
<span class="line-added">12912     GPRReg calleeGPR = callee.gpr();</span>
<span class="line-added">12913     GPRReg resultGPR = result.gpr();</span>
<span class="line-added">12914     GPRReg structureGPR = structure.gpr();</span>
<span class="line-added">12915     GPRReg scratch1GPR = scratch1.gpr();</span>
<span class="line-added">12916     GPRReg scratch2GPR = scratch2.gpr();</span>
<span class="line-added">12917     // Rare data is only used to access the allocator &amp; structure</span>
<span class="line-added">12918     // We can avoid using an additional GPR this way</span>
<span class="line-added">12919     GPRReg rareDataGPR = structureGPR;</span>
<span class="line-added">12920 </span>
<span class="line-added">12921     MacroAssembler::JumpList slowCases;</span>
<span class="line-added">12922 </span>
<span class="line-added">12923     slowCases.append(m_jit.branchIfNotFunction(calleeGPR));</span>
<span class="line-added">12924     m_jit.loadPtr(JITCompiler::Address(calleeGPR, JSFunction::offsetOfExecutableOrRareData()), rareDataGPR);</span>
<span class="line-added">12925     slowCases.append(m_jit.branchTestPtr(MacroAssembler::Zero, rareDataGPR, CCallHelpers::TrustedImm32(JSFunction::rareDataTag)));</span>
<span class="line-added">12926     m_jit.loadPtr(JITCompiler::Address(rareDataGPR, FunctionRareData::offsetOfInternalFunctionAllocationProfile() + InternalFunctionAllocationProfile::offsetOfStructure() - JSFunction::rareDataTag), structureGPR);</span>
<span class="line-added">12927     slowCases.append(m_jit.branchTestPtr(CCallHelpers::Zero, structureGPR));</span>
<span class="line-added">12928     m_jit.move(TrustedImmPtr(JSClass::info()), scratch1GPR);</span>
<span class="line-added">12929     slowCases.append(m_jit.branchPtr(CCallHelpers::NotEqual, scratch1GPR, CCallHelpers::Address(structureGPR, Structure::classInfoOffset())));</span>
<span class="line-added">12930     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), globalObject), scratch1GPR);</span>
<span class="line-added">12931     slowCases.append(m_jit.branchPtr(CCallHelpers::NotEqual, scratch1GPR, CCallHelpers::Address(structureGPR, Structure::globalObjectOffset())));</span>
<span class="line-added">12932 </span>
<span class="line-added">12933     auto butterfly = TrustedImmPtr(nullptr);</span>
<span class="line-added">12934     emitAllocateJSObjectWithKnownSize&lt;JSClass&gt;(resultGPR, structureGPR, butterfly, scratch1GPR, scratch2GPR, slowCases, sizeof(JSClass));</span>
<span class="line-added">12935     auto initialValues = JSClass::initialValues();</span>
<span class="line-added">12936     ASSERT(initialValues.size() == JSClass::numberOfInternalFields);</span>
<span class="line-added">12937     for (unsigned index = 0; index &lt; initialValues.size(); ++index)</span>
<span class="line-added">12938         m_jit.storeTrustedValue(initialValues[index], CCallHelpers::Address(resultGPR, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(index)));</span>
<span class="line-added">12939     m_jit.mutatorFence(m_jit.vm());</span>
<span class="line-added">12940 </span>
<span class="line-added">12941     addSlowPathGenerator(slowPathCall(slowCases, this, operation, resultGPR, TrustedImmPtr::weakPointer(m_jit.graph(), globalObject), calleeGPR));</span>
<span class="line-added">12942 </span>
<span class="line-added">12943     cellResult(resultGPR, node);</span>
<span class="line-added">12944 }</span>
<span class="line-added">12945 </span>
<span class="line-added">12946 void SpeculativeJIT::compileCreateGenerator(Node* node)</span>
<span class="line-added">12947 {</span>
<span class="line-added">12948     compileCreateInternalFieldObject&lt;JSGenerator&gt;(node, operationCreateGenerator);</span>
<span class="line-added">12949 }</span>
<span class="line-added">12950 </span>
<span class="line-added">12951 void SpeculativeJIT::compileCreateAsyncGenerator(Node* node)</span>
<span class="line-added">12952 {</span>
<span class="line-added">12953     compileCreateInternalFieldObject&lt;JSAsyncGenerator&gt;(node, operationCreateAsyncGenerator);</span>
<span class="line-added">12954 }</span>
<span class="line-added">12955 </span>
12956 void SpeculativeJIT::compileNewObject(Node* node)
12957 {
12958     GPRTemporary result(this);
12959     GPRTemporary allocator(this);
12960     GPRTemporary scratch(this);
12961 
12962     GPRReg resultGPR = result.gpr();
12963     GPRReg allocatorGPR = allocator.gpr();
12964     GPRReg scratchGPR = scratch.gpr();
12965 
12966     MacroAssembler::JumpList slowPath;
12967 
12968     RegisteredStructure structure = node-&gt;structure();
12969     size_t allocationSize = JSFinalObject::allocationSize(structure-&gt;inlineCapacity());
12970     Allocator allocatorValue = allocatorForNonVirtualConcurrently&lt;JSFinalObject&gt;(vm(), allocationSize, AllocatorForMode::AllocatorIfExists);
12971     if (!allocatorValue)
12972         slowPath.append(m_jit.jump());
12973     else {
12974         auto butterfly = TrustedImmPtr(nullptr);
12975         emitAllocateJSObject(resultGPR, JITAllocator::constant(allocatorValue), allocatorGPR, TrustedImmPtr(structure), butterfly, scratchGPR, slowPath);
12976         m_jit.emitInitializeInlineStorage(resultGPR, structure-&gt;inlineCapacity());
12977         m_jit.mutatorFence(vm());
12978     }
12979 
<a name="326" id="anc326"></a><span class="line-modified">12980     addSlowPathGenerator(slowPathCall(slowPath, this, operationNewObject, resultGPR, &amp;vm(), structure));</span>
<span class="line-added">12981 </span>
<span class="line-added">12982     cellResult(resultGPR, node);</span>
<span class="line-added">12983 }</span>
<span class="line-added">12984 </span>
<span class="line-added">12985 void SpeculativeJIT::compileNewPromise(Node* node)</span>
<span class="line-added">12986 {</span>
<span class="line-added">12987     GPRTemporary result(this);</span>
<span class="line-added">12988     GPRTemporary scratch1(this);</span>
<span class="line-added">12989     GPRTemporary scratch2(this);</span>
<span class="line-added">12990 </span>
<span class="line-added">12991     GPRReg resultGPR = result.gpr();</span>
<span class="line-added">12992     GPRReg scratch1GPR = scratch1.gpr();</span>
<span class="line-added">12993     GPRReg scratch2GPR = scratch2.gpr();</span>
<span class="line-added">12994 </span>
<span class="line-added">12995     MacroAssembler::JumpList slowCases;</span>
<span class="line-added">12996 </span>
<span class="line-added">12997     FrozenValue* structure = m_graph.freezeStrong(node-&gt;structure().get());</span>
<span class="line-added">12998     auto butterfly = TrustedImmPtr(nullptr);</span>
<span class="line-added">12999     if (node-&gt;isInternalPromise())</span>
<span class="line-added">13000         emitAllocateJSObjectWithKnownSize&lt;JSInternalPromise&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowCases, sizeof(JSInternalPromise));</span>
<span class="line-added">13001     else</span>
<span class="line-added">13002         emitAllocateJSObjectWithKnownSize&lt;JSPromise&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowCases, sizeof(JSPromise));</span>
<span class="line-added">13003     m_jit.storeTrustedValue(jsNumber(static_cast&lt;unsigned&gt;(JSPromise::Status::Pending)), CCallHelpers::Address(resultGPR, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(static_cast&lt;unsigned&gt;(JSPromise::Field::Flags))));</span>
<span class="line-added">13004     m_jit.storeTrustedValue(jsUndefined(), CCallHelpers::Address(resultGPR, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(static_cast&lt;unsigned&gt;(JSPromise::Field::ReactionsOrResult))));</span>
<span class="line-added">13005     m_jit.mutatorFence(m_jit.vm());</span>
<span class="line-added">13006 </span>
<span class="line-added">13007     addSlowPathGenerator(slowPathCall(slowCases, this, node-&gt;isInternalPromise() ? operationNewInternalPromise : operationNewPromise, resultGPR, TrustedImmPtr(&amp;vm()), TrustedImmPtr(structure)));</span>
13008 
13009     cellResult(resultGPR, node);
13010 }
13011 
<a name="327" id="anc327"></a><span class="line-added">13012 template&lt;typename JSClass, typename Operation&gt;</span>
<span class="line-added">13013 void SpeculativeJIT::compileNewInternalFieldObject(Node* node, Operation operation)</span>
<span class="line-added">13014 {</span>
<span class="line-added">13015     GPRTemporary result(this);</span>
<span class="line-added">13016     GPRTemporary scratch1(this);</span>
<span class="line-added">13017     GPRTemporary scratch2(this);</span>
<span class="line-added">13018 </span>
<span class="line-added">13019     GPRReg resultGPR = result.gpr();</span>
<span class="line-added">13020     GPRReg scratch1GPR = scratch1.gpr();</span>
<span class="line-added">13021     GPRReg scratch2GPR = scratch2.gpr();</span>
<span class="line-added">13022 </span>
<span class="line-added">13023     MacroAssembler::JumpList slowCases;</span>
<span class="line-added">13024 </span>
<span class="line-added">13025     FrozenValue* structure = m_graph.freezeStrong(node-&gt;structure().get());</span>
<span class="line-added">13026     auto butterfly = TrustedImmPtr(nullptr);</span>
<span class="line-added">13027     emitAllocateJSObjectWithKnownSize&lt;JSClass&gt;(resultGPR, TrustedImmPtr(structure), butterfly, scratch1GPR, scratch2GPR, slowCases, sizeof(JSClass));</span>
<span class="line-added">13028     auto initialValues = JSClass::initialValues();</span>
<span class="line-added">13029     static_assert(initialValues.size() == JSClass::numberOfInternalFields);</span>
<span class="line-added">13030     for (unsigned index = 0; index &lt; initialValues.size(); ++index)</span>
<span class="line-added">13031         m_jit.storeTrustedValue(initialValues[index], CCallHelpers::Address(resultGPR, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(index)));</span>
<span class="line-added">13032     m_jit.mutatorFence(m_jit.vm());</span>
<span class="line-added">13033 </span>
<span class="line-added">13034     addSlowPathGenerator(slowPathCall(slowCases, this, operation, resultGPR, &amp;vm(), TrustedImmPtr(structure)));</span>
<span class="line-added">13035 </span>
<span class="line-added">13036     cellResult(resultGPR, node);</span>
<span class="line-added">13037 }</span>
<span class="line-added">13038 </span>
<span class="line-added">13039 void SpeculativeJIT::compileNewGenerator(Node* node)</span>
<span class="line-added">13040 {</span>
<span class="line-added">13041     compileNewInternalFieldObject&lt;JSGenerator&gt;(node, operationNewGenerator);</span>
<span class="line-added">13042 }</span>
<span class="line-added">13043 </span>
<span class="line-added">13044 void SpeculativeJIT::compileNewAsyncGenerator(Node* node)</span>
<span class="line-added">13045 {</span>
<span class="line-added">13046     compileNewInternalFieldObject&lt;JSAsyncGenerator&gt;(node, operationNewAsyncGenerator);</span>
<span class="line-added">13047 }</span>
<span class="line-added">13048 </span>
<span class="line-added">13049 void SpeculativeJIT::compileNewArrayIterator(Node* node)</span>
<span class="line-added">13050 {</span>
<span class="line-added">13051     compileNewInternalFieldObject&lt;JSArrayIterator&gt;(node, operationNewArrayIterator);</span>
<span class="line-added">13052 }</span>
<span class="line-added">13053 </span>
13054 void SpeculativeJIT::compileToPrimitive(Node* node)
13055 {
13056     DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
13057     JSValueOperand argument(this, node-&gt;child1());
13058     JSValueRegsTemporary result(this, Reuse, argument);
13059 
13060     JSValueRegs argumentRegs = argument.jsValueRegs();
13061     JSValueRegs resultRegs = result.regs();
13062 
13063     argument.use();
13064 
13065     MacroAssembler::Jump alreadyPrimitive = m_jit.branchIfNotCell(argumentRegs);
13066     MacroAssembler::Jump notPrimitive = m_jit.branchIfObject(argumentRegs.payloadGPR());
13067 
13068     alreadyPrimitive.link(&amp;m_jit);
13069     m_jit.moveValueRegs(argumentRegs, resultRegs);
13070 
<a name="328" id="anc328"></a><span class="line-modified">13071     addSlowPathGenerator(slowPathCall(notPrimitive, this, operationToPrimitive, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentRegs));</span>
13072 
13073     jsValueResult(resultRegs, node, DataFormatJS, UseChildrenCalledExplicitly);
13074 }
13075 
<a name="329" id="anc329"></a><span class="line-added">13076 void SpeculativeJIT::compileToPropertyKey(Node* node)</span>
<span class="line-added">13077 {</span>
<span class="line-added">13078     DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());</span>
<span class="line-added">13079     JSValueOperand argument(this, node-&gt;child1());</span>
<span class="line-added">13080     JSValueRegsTemporary result(this, Reuse, argument);</span>
<span class="line-added">13081 </span>
<span class="line-added">13082     JSValueRegs argumentRegs = argument.jsValueRegs();</span>
<span class="line-added">13083     JSValueRegs resultRegs = result.regs();</span>
<span class="line-added">13084 </span>
<span class="line-added">13085     argument.use();</span>
<span class="line-added">13086 </span>
<span class="line-added">13087     MacroAssembler::JumpList slowCases;</span>
<span class="line-added">13088     slowCases.append(m_jit.branchIfNotCell(argumentRegs));</span>
<span class="line-added">13089     MacroAssembler::Jump alreadyPropertyKey = m_jit.branchIfSymbol(argumentRegs.payloadGPR());</span>
<span class="line-added">13090     slowCases.append(m_jit.branchIfNotString(argumentRegs.payloadGPR()));</span>
<span class="line-added">13091 </span>
<span class="line-added">13092     alreadyPropertyKey.link(&amp;m_jit);</span>
<span class="line-added">13093     m_jit.moveValueRegs(argumentRegs, resultRegs);</span>
<span class="line-added">13094 </span>
<span class="line-added">13095     addSlowPathGenerator(slowPathCall(slowCases, this, operationToPropertyKey, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentRegs));</span>
<span class="line-added">13096 </span>
<span class="line-added">13097     jsValueResult(resultRegs, node, DataFormatJSCell, UseChildrenCalledExplicitly);</span>
<span class="line-added">13098 }</span>
<span class="line-added">13099 </span>
<span class="line-added">13100 void SpeculativeJIT::compileToNumeric(Node* node)</span>
<span class="line-added">13101 {</span>
<span class="line-added">13102     DFG_ASSERT(m_jit.graph(), node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());</span>
<span class="line-added">13103     JSValueOperand argument(this, node-&gt;child1());</span>
<span class="line-added">13104     JSValueRegsTemporary result(this);</span>
<span class="line-added">13105     GPRTemporary temp(this);</span>
<span class="line-added">13106 </span>
<span class="line-added">13107     JSValueRegs argumentRegs = argument.jsValueRegs();</span>
<span class="line-added">13108     JSValueRegs resultRegs = result.regs();</span>
<span class="line-added">13109     GPRReg scratch = temp.gpr();</span>
<span class="line-added">13110 </span>
<span class="line-added">13111     MacroAssembler::JumpList slowCases;</span>
<span class="line-added">13112 </span>
<span class="line-added">13113     MacroAssembler::Jump notCell = m_jit.branchIfNotCell(argumentRegs);</span>
<span class="line-added">13114     slowCases.append(m_jit.branchIfNotBigInt(argumentRegs.payloadGPR()));</span>
<span class="line-added">13115     MacroAssembler::Jump isBigInt = m_jit.jump();</span>
<span class="line-added">13116 </span>
<span class="line-added">13117     notCell.link(&amp;m_jit);</span>
<span class="line-added">13118     slowCases.append(m_jit.branchIfNotNumber(argumentRegs, scratch));</span>
<span class="line-added">13119 </span>
<span class="line-added">13120     isBigInt.link(&amp;m_jit);</span>
<span class="line-added">13121     m_jit.moveValueRegs(argumentRegs, resultRegs);</span>
<span class="line-added">13122 </span>
<span class="line-added">13123     addSlowPathGenerator(slowPathCall(slowCases, this, operationToNumeric, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentRegs));</span>
<span class="line-added">13124 </span>
<span class="line-added">13125     jsValueResult(resultRegs, node, DataFormatJS);</span>
<span class="line-added">13126 }</span>
<span class="line-added">13127 </span>
13128 void SpeculativeJIT::compileLogShadowChickenPrologue(Node* node)
13129 {
13130     flushRegisters();
13131     prepareForExternalCall();
13132     m_jit.emitStoreCodeOrigin(node-&gt;origin.semantic);
13133 
13134     GPRTemporary scratch1(this, GPRInfo::nonArgGPR0); // This must be a non-argument GPR.
13135     GPRReg scratch1Reg = scratch1.gpr();
13136     GPRTemporary scratch2(this);
13137     GPRReg scratch2Reg = scratch2.gpr();
13138     GPRTemporary shadowPacket(this);
13139     GPRReg shadowPacketReg = shadowPacket.gpr();
13140 
13141     m_jit.ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);
13142 
13143     SpeculateCellOperand scope(this, node-&gt;child1());
13144     GPRReg scopeReg = scope.gpr();
13145 
13146     m_jit.logShadowChickenProloguePacket(shadowPacketReg, scratch1Reg, scopeReg);
13147     noResult(node);
13148 }
13149 
13150 void SpeculativeJIT::compileLogShadowChickenTail(Node* node)
13151 {
13152     flushRegisters();
13153     prepareForExternalCall();
13154     CallSiteIndex callSiteIndex = m_jit.emitStoreCodeOrigin(node-&gt;origin.semantic);
13155 
13156     GPRTemporary scratch1(this, GPRInfo::nonArgGPR0); // This must be a non-argument GPR.
13157     GPRReg scratch1Reg = scratch1.gpr();
13158     GPRTemporary scratch2(this);
13159     GPRReg scratch2Reg = scratch2.gpr();
13160     GPRTemporary shadowPacket(this);
13161     GPRReg shadowPacketReg = shadowPacket.gpr();
13162 
13163     m_jit.ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);
13164 
13165     JSValueOperand thisValue(this, node-&gt;child1());
13166     JSValueRegs thisRegs = thisValue.jsValueRegs();
13167     SpeculateCellOperand scope(this, node-&gt;child2());
13168     GPRReg scopeReg = scope.gpr();
13169 
13170     m_jit.logShadowChickenTailPacket(shadowPacketReg, thisRegs, scopeReg, m_jit.codeBlock(), callSiteIndex);
13171     noResult(node);
13172 }
13173 
13174 void SpeculativeJIT::compileSetAdd(Node* node)
13175 {
13176     SpeculateCellOperand set(this, node-&gt;child1());
13177     JSValueOperand key(this, node-&gt;child2());
13178     SpeculateInt32Operand hash(this, node-&gt;child3());
13179 
13180     GPRReg setGPR = set.gpr();
13181     JSValueRegs keyRegs = key.jsValueRegs();
13182     GPRReg hashGPR = hash.gpr();
13183 
13184     speculateSetObject(node-&gt;child1(), setGPR);
13185 
13186     flushRegisters();
13187     GPRFlushedCallResult result(this);
13188     GPRReg resultGPR = result.gpr();
<a name="330" id="anc330"></a><span class="line-modified">13189     callOperation(operationSetAdd, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), setGPR, keyRegs, hashGPR);</span>
13190     m_jit.exceptionCheck();
13191     cellResult(resultGPR, node);
13192 }
13193 
13194 void SpeculativeJIT::compileMapSet(Node* node)
13195 {
13196     SpeculateCellOperand map(this, m_jit.graph().varArgChild(node, 0));
13197     JSValueOperand key(this, m_jit.graph().varArgChild(node, 1));
13198     JSValueOperand value(this, m_jit.graph().varArgChild(node, 2));
13199     SpeculateInt32Operand hash(this, m_jit.graph().varArgChild(node, 3));
13200 
13201     GPRReg mapGPR = map.gpr();
13202     JSValueRegs keyRegs = key.jsValueRegs();
13203     JSValueRegs valueRegs = value.jsValueRegs();
13204     GPRReg hashGPR = hash.gpr();
13205 
13206     speculateMapObject(m_jit.graph().varArgChild(node, 0), mapGPR);
13207 
13208     flushRegisters();
13209     GPRFlushedCallResult result(this);
13210     GPRReg resultGPR = result.gpr();
<a name="331" id="anc331"></a><span class="line-modified">13211     callOperation(operationMapSet, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), mapGPR, keyRegs, valueRegs, hashGPR);</span>
13212     m_jit.exceptionCheck();
13213     cellResult(resultGPR, node);
13214 }
13215 
13216 void SpeculativeJIT::compileWeakMapGet(Node* node)
13217 {
13218     GPRTemporary mask(this);
13219     GPRTemporary buffer(this);
13220     JSValueRegsTemporary result(this);
13221 
13222     GPRReg maskGPR = mask.gpr();
13223     GPRReg bufferGPR = buffer.gpr();
13224     JSValueRegs resultRegs = result.regs();
13225 
13226     GPRTemporary index;
13227     GPRReg indexGPR { InvalidGPRReg };
13228     {
13229         SpeculateInt32Operand hash(this, node-&gt;child3());
13230         GPRReg hashGPR = hash.gpr();
13231         index = GPRTemporary(this, Reuse, hash);
13232         indexGPR = index.gpr();
13233         m_jit.move(hashGPR, indexGPR);
13234     }
13235 
13236     {
13237         SpeculateCellOperand weakMap(this, node-&gt;child1());
13238         GPRReg weakMapGPR = weakMap.gpr();
13239         if (node-&gt;child1().useKind() == WeakMapObjectUse)
13240             speculateWeakMapObject(node-&gt;child1(), weakMapGPR);
13241         else
13242             speculateWeakSetObject(node-&gt;child1(), weakMapGPR);
13243 
13244         ASSERT(WeakMapImpl&lt;WeakMapBucket&lt;WeakMapBucketDataKey&gt;&gt;::offsetOfCapacity() == WeakMapImpl&lt;WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;&gt;::offsetOfCapacity());
13245         ASSERT(WeakMapImpl&lt;WeakMapBucket&lt;WeakMapBucketDataKey&gt;&gt;::offsetOfBuffer() == WeakMapImpl&lt;WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;&gt;::offsetOfBuffer());
13246         m_jit.load32(MacroAssembler::Address(weakMapGPR, WeakMapImpl&lt;WeakMapBucket&lt;WeakMapBucketDataKey&gt;&gt;::offsetOfCapacity()), maskGPR);
13247         m_jit.loadPtr(MacroAssembler::Address(weakMapGPR, WeakMapImpl&lt;WeakMapBucket&lt;WeakMapBucketDataKey&gt;&gt;::offsetOfBuffer()), bufferGPR);
13248     }
13249 
13250     SpeculateCellOperand key(this, node-&gt;child2());
13251     GPRReg keyGPR = key.gpr();
13252     speculateObject(node-&gt;child2(), keyGPR);
13253 
13254 #if USE(JSVALUE32_64)
13255     GPRReg bucketGPR = resultRegs.tagGPR();
13256 #else
13257     GPRTemporary bucket(this);
13258     GPRReg bucketGPR = bucket.gpr();
13259 #endif
13260 
13261     m_jit.sub32(TrustedImm32(1), maskGPR);
13262 
13263     MacroAssembler::Label loop = m_jit.label();
13264     m_jit.and32(maskGPR, indexGPR);
13265     if (node-&gt;child1().useKind() == WeakSetObjectUse) {
13266         static_assert(sizeof(WeakMapBucket&lt;WeakMapBucketDataKey&gt;) == sizeof(void*), &quot;&quot;);
13267         m_jit.zeroExtend32ToPtr(indexGPR, bucketGPR);
13268         m_jit.lshiftPtr(MacroAssembler::Imm32(sizeof(void*) == 4 ? 2 : 3), bucketGPR);
13269         m_jit.addPtr(bufferGPR, bucketGPR);
13270     } else {
13271         ASSERT(node-&gt;child1().useKind() == WeakMapObjectUse);
13272         static_assert(sizeof(WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;) == 16, &quot;&quot;);
13273         m_jit.zeroExtend32ToPtr(indexGPR, bucketGPR);
13274         m_jit.lshiftPtr(MacroAssembler::Imm32(4), bucketGPR);
13275         m_jit.addPtr(bufferGPR, bucketGPR);
13276     }
13277 
13278     m_jit.loadPtr(MacroAssembler::Address(bucketGPR, WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;::offsetOfKey()), resultRegs.payloadGPR());
13279 
13280     // They&#39;re definitely the same value, we found the bucket we were looking for!
13281     // The deleted key comparison is also done with this.
13282     auto found = m_jit.branchPtr(MacroAssembler::Equal, resultRegs.payloadGPR(), keyGPR);
13283 
13284     auto notPresentInTable = m_jit.branchTestPtr(MacroAssembler::Zero, resultRegs.payloadGPR());
13285 
13286     m_jit.add32(TrustedImm32(1), indexGPR);
13287     m_jit.jump().linkTo(loop, &amp;m_jit);
13288 
13289 #if USE(JSVALUE32_64)
13290     notPresentInTable.link(&amp;m_jit);
13291     m_jit.moveValue(JSValue(), resultRegs);
13292     auto notPresentInTableDone = m_jit.jump();
13293 
13294     found.link(&amp;m_jit);
13295     if (node-&gt;child1().useKind() == WeakSetObjectUse)
13296         m_jit.move(TrustedImm32(JSValue::CellTag), resultRegs.tagGPR());
13297     else
13298         m_jit.loadValue(MacroAssembler::Address(bucketGPR, WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;::offsetOfValue()), resultRegs);
13299 
13300     notPresentInTableDone.link(&amp;m_jit);
13301 #else
13302     notPresentInTable.link(&amp;m_jit);
13303     found.link(&amp;m_jit);
13304 
13305     // In 64bit environment, Empty bucket has JSEmpty value. Empty key is JSEmpty.
13306     // If empty bucket is found, we can use the same path used for the case of finding a bucket.
13307     if (node-&gt;child1().useKind() == WeakMapObjectUse)
13308         m_jit.loadValue(MacroAssembler::Address(bucketGPR, WeakMapBucket&lt;WeakMapBucketDataKeyValue&gt;::offsetOfValue()), resultRegs);
13309 #endif
13310 
13311     jsValueResult(resultRegs, node);
13312 }
13313 
13314 void SpeculativeJIT::compileWeakSetAdd(Node* node)
13315 {
13316     SpeculateCellOperand set(this, node-&gt;child1());
13317     SpeculateCellOperand key(this, node-&gt;child2());
13318     SpeculateInt32Operand hash(this, node-&gt;child3());
13319 
13320     GPRReg setGPR = set.gpr();
13321     GPRReg keyGPR = key.gpr();
13322     GPRReg hashGPR = hash.gpr();
13323 
13324     speculateWeakSetObject(node-&gt;child1(), setGPR);
13325     speculateObject(node-&gt;child2(), keyGPR);
13326 
13327     flushRegisters();
<a name="332" id="anc332"></a><span class="line-modified">13328     callOperation(operationWeakSetAdd, &amp;vm(), setGPR, keyGPR, hashGPR);</span>
13329     m_jit.exceptionCheck();
13330     noResult(node);
13331 }
13332 
13333 void SpeculativeJIT::compileWeakMapSet(Node* node)
13334 {
13335     SpeculateCellOperand map(this, m_jit.graph().varArgChild(node, 0));
13336     SpeculateCellOperand key(this, m_jit.graph().varArgChild(node, 1));
13337     JSValueOperand value(this, m_jit.graph().varArgChild(node, 2));
13338     SpeculateInt32Operand hash(this, m_jit.graph().varArgChild(node, 3));
13339 
13340     GPRReg mapGPR = map.gpr();
13341     GPRReg keyGPR = key.gpr();
13342     JSValueRegs valueRegs = value.jsValueRegs();
13343     GPRReg hashGPR = hash.gpr();
13344 
13345     speculateWeakMapObject(m_jit.graph().varArgChild(node, 0), mapGPR);
13346     speculateObject(m_jit.graph().varArgChild(node, 1), keyGPR);
13347 
13348     flushRegisters();
<a name="333" id="anc333"></a><span class="line-modified">13349     callOperation(operationWeakMapSet, &amp;vm(), mapGPR, keyGPR, valueRegs, hashGPR);</span>
13350     m_jit.exceptionCheck();
13351     noResult(node);
13352 }
13353 
13354 void SpeculativeJIT::compileGetPrototypeOf(Node* node)
13355 {
13356     switch (node-&gt;child1().useKind()) {
13357     case ArrayUse:
13358     case FunctionUse:
13359     case FinalObjectUse: {
13360         SpeculateCellOperand object(this, node-&gt;child1());
13361         GPRTemporary temp(this);
13362         GPRTemporary temp2(this);
13363 
13364         GPRReg objectGPR = object.gpr();
13365         GPRReg tempGPR = temp.gpr();
13366         GPRReg temp2GPR = temp2.gpr();
13367 
13368         switch (node-&gt;child1().useKind()) {
13369         case ArrayUse:
13370             speculateArray(node-&gt;child1(), objectGPR);
13371             break;
13372         case FunctionUse:
13373             speculateFunction(node-&gt;child1(), objectGPR);
13374             break;
13375         case FinalObjectUse:
13376             speculateFinalObject(node-&gt;child1(), objectGPR);
13377             break;
13378         default:
13379             RELEASE_ASSERT_NOT_REACHED();
13380             break;
13381         }
13382 
13383         m_jit.emitLoadStructure(vm(), objectGPR, tempGPR, temp2GPR);
13384 
13385         AbstractValue&amp; value = m_state.forNode(node-&gt;child1());
13386         if ((value.m_type &amp;&amp; !(value.m_type &amp; ~SpecObject)) &amp;&amp; value.m_structure.isFinite()) {
13387             bool hasPolyProto = false;
13388             bool hasMonoProto = false;
13389             value.m_structure.forEach([&amp;] (RegisteredStructure structure) {
13390                 if (structure-&gt;hasPolyProto())
13391                     hasPolyProto = true;
13392                 else
13393                     hasMonoProto = true;
13394             });
13395 
13396             if (hasMonoProto &amp;&amp; !hasPolyProto) {
13397 #if USE(JSVALUE64)
13398                 m_jit.load64(MacroAssembler::Address(tempGPR, Structure::prototypeOffset()), tempGPR);
13399                 jsValueResult(tempGPR, node);
13400 #else
13401                 m_jit.load32(MacroAssembler::Address(tempGPR, Structure::prototypeOffset() + TagOffset), temp2GPR);
13402                 m_jit.load32(MacroAssembler::Address(tempGPR, Structure::prototypeOffset() + PayloadOffset), tempGPR);
13403                 jsValueResult(temp2GPR, tempGPR, node);
13404 #endif
13405                 return;
13406             }
13407 
13408             if (hasPolyProto &amp;&amp; !hasMonoProto) {
13409 #if USE(JSVALUE64)
13410                 m_jit.load64(JITCompiler::Address(objectGPR, offsetRelativeToBase(knownPolyProtoOffset)), tempGPR);
13411                 jsValueResult(tempGPR, node);
13412 #else
13413                 m_jit.load32(JITCompiler::Address(objectGPR, offsetRelativeToBase(knownPolyProtoOffset) + TagOffset), temp2GPR);
13414                 m_jit.load32(JITCompiler::Address(objectGPR, offsetRelativeToBase(knownPolyProtoOffset) + PayloadOffset), tempGPR);
13415                 jsValueResult(temp2GPR, tempGPR, node);
13416 #endif
13417                 return;
13418             }
13419         }
13420 
13421 #if USE(JSVALUE64)
13422         m_jit.load64(MacroAssembler::Address(tempGPR, Structure::prototypeOffset()), tempGPR);
13423         auto hasMonoProto = m_jit.branchIfNotEmpty(tempGPR);
13424         m_jit.load64(JITCompiler::Address(objectGPR, offsetRelativeToBase(knownPolyProtoOffset)), tempGPR);
13425         hasMonoProto.link(&amp;m_jit);
13426         jsValueResult(tempGPR, node);
13427 #else
13428         m_jit.load32(MacroAssembler::Address(tempGPR, Structure::prototypeOffset() + TagOffset), temp2GPR);
13429         m_jit.load32(MacroAssembler::Address(tempGPR, Structure::prototypeOffset() + PayloadOffset), tempGPR);
13430         auto hasMonoProto = m_jit.branchIfNotEmpty(temp2GPR);
13431         m_jit.load32(JITCompiler::Address(objectGPR, offsetRelativeToBase(knownPolyProtoOffset) + TagOffset), temp2GPR);
13432         m_jit.load32(JITCompiler::Address(objectGPR, offsetRelativeToBase(knownPolyProtoOffset) + PayloadOffset), tempGPR);
13433         hasMonoProto.link(&amp;m_jit);
13434         jsValueResult(temp2GPR, tempGPR, node);
13435 #endif
13436         return;
13437     }
13438     case ObjectUse: {
13439         SpeculateCellOperand value(this, node-&gt;child1());
13440         JSValueRegsTemporary result(this);
13441 
13442         GPRReg valueGPR = value.gpr();
13443         JSValueRegs resultRegs = result.regs();
13444 
13445         speculateObject(node-&gt;child1(), valueGPR);
13446 
13447         flushRegisters();
<a name="334" id="anc334"></a><span class="line-modified">13448         callOperation(operationGetPrototypeOfObject, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueGPR);</span>
13449         m_jit.exceptionCheck();
13450         jsValueResult(resultRegs, node);
13451         return;
13452     }
13453     default: {
13454         JSValueOperand value(this, node-&gt;child1());
13455         JSValueRegsTemporary result(this);
13456 
13457         JSValueRegs valueRegs = value.jsValueRegs();
13458         JSValueRegs resultRegs = result.regs();
13459 
13460         flushRegisters();
<a name="335" id="anc335"></a><span class="line-modified">13461         callOperation(operationGetPrototypeOf, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), valueRegs);</span>
13462         m_jit.exceptionCheck();
13463         jsValueResult(resultRegs, node);
13464         return;
13465     }
13466     }
13467 }
13468 
13469 void SpeculativeJIT::compileIdentity(Node* node)
13470 {
13471     speculate(node, node-&gt;child1());
13472     switch (node-&gt;child1().useKind()) {
13473 #if USE(JSVALUE64)
13474     case DoubleRepAnyIntUse:
13475 #endif
13476     case DoubleRepUse:
13477     case DoubleRepRealUse: {
13478         SpeculateDoubleOperand op(this, node-&gt;child1());
13479         FPRTemporary scratch(this, op);
13480         m_jit.moveDouble(op.fpr(), scratch.fpr());
13481         doubleResult(scratch.fpr(), node);
13482         break;
13483     }
13484 #if USE(JSVALUE64)
13485     case Int52RepUse: {
13486         SpeculateInt52Operand op(this, node-&gt;child1());
13487         GPRTemporary result(this, Reuse, op);
13488         m_jit.move(op.gpr(), result.gpr());
13489         int52Result(result.gpr(), node);
13490         break;
13491     }
13492 #endif
13493     default: {
13494         JSValueOperand op(this, node-&gt;child1(), ManualOperandSpeculation);
13495         JSValueRegsTemporary result(this, Reuse, op);
13496         JSValueRegs opRegs = op.jsValueRegs();
13497         JSValueRegs resultRegs = result.regs();
13498         m_jit.moveValueRegs(opRegs, resultRegs);
13499         jsValueResult(resultRegs, node);
13500         break;
13501     }
13502     }
13503 }
13504 
13505 void SpeculativeJIT::compileMiscStrictEq(Node* node)
13506 {
13507     JSValueOperand op1(this, node-&gt;child1(), ManualOperandSpeculation);
13508     JSValueOperand op2(this, node-&gt;child2(), ManualOperandSpeculation);
13509     GPRTemporary result(this);
13510 
13511     if (node-&gt;child1().useKind() == MiscUse)
13512         speculateMisc(node-&gt;child1(), op1.jsValueRegs());
13513     if (node-&gt;child2().useKind() == MiscUse)
13514         speculateMisc(node-&gt;child2(), op2.jsValueRegs());
13515 
13516 #if USE(JSVALUE64)
13517     m_jit.compare64(JITCompiler::Equal, op1.gpr(), op2.gpr(), result.gpr());
13518 #else
13519     m_jit.move(TrustedImm32(0), result.gpr());
13520     JITCompiler::Jump notEqual = m_jit.branch32(JITCompiler::NotEqual, op1.tagGPR(), op2.tagGPR());
13521     m_jit.compare32(JITCompiler::Equal, op1.payloadGPR(), op2.payloadGPR(), result.gpr());
13522     notEqual.link(&amp;m_jit);
13523 #endif
13524     unblessedBooleanResult(result.gpr(), node);
13525 }
13526 
13527 void SpeculativeJIT::emitInitializeButterfly(GPRReg storageGPR, GPRReg sizeGPR, JSValueRegs emptyValueRegs, GPRReg scratchGPR)
13528 {
13529     m_jit.zeroExtend32ToPtr(sizeGPR, scratchGPR);
13530     MacroAssembler::Jump done = m_jit.branchTest32(MacroAssembler::Zero, scratchGPR);
13531     MacroAssembler::Label loop = m_jit.label();
13532     m_jit.sub32(TrustedImm32(1), scratchGPR);
13533     m_jit.storeValue(emptyValueRegs, MacroAssembler::BaseIndex(storageGPR, scratchGPR, MacroAssembler::TimesEight));
13534     m_jit.branchTest32(MacroAssembler::NonZero, scratchGPR).linkTo(loop, &amp;m_jit);
13535     done.link(&amp;m_jit);
13536 }
13537 
13538 void SpeculativeJIT::compileAllocateNewArrayWithSize(JSGlobalObject* globalObject, GPRReg resultGPR, GPRReg sizeGPR, IndexingType indexingType, bool shouldConvertLargeSizeToArrayStorage)
13539 {
13540     GPRTemporary storage(this);
13541     GPRTemporary scratch(this);
13542     GPRTemporary scratch2(this);
13543 
13544     GPRReg storageGPR = storage.gpr();
13545     GPRReg scratchGPR = scratch.gpr();
13546     GPRReg scratch2GPR = scratch2.gpr();
13547 
13548     m_jit.move(TrustedImmPtr(nullptr), storageGPR);
13549 
13550     MacroAssembler::JumpList slowCases;
13551     if (shouldConvertLargeSizeToArrayStorage)
13552         slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, sizeGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)));
<a name="336" id="anc336"></a><span class="line-modified">13553 #if ASSERT_ENABLED</span>
13554     else {
13555         MacroAssembler::Jump lengthIsWithinLimits;
13556         lengthIsWithinLimits = m_jit.branch32(MacroAssembler::Below, sizeGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH));
13557         m_jit.abortWithReason(UncheckedOverflow);
13558         lengthIsWithinLimits.link(&amp;m_jit);
13559     }
<a name="337" id="anc337"></a><span class="line-modified">13560 #endif // ASSERT_ENABLED</span>
13561 
13562     // We can use resultGPR as a scratch right now.
13563     emitAllocateButterfly(storageGPR, sizeGPR, scratchGPR, scratch2GPR, resultGPR, slowCases);
13564 
13565 #if USE(JSVALUE64)
13566     JSValueRegs emptyValueRegs(scratchGPR);
13567     if (hasDouble(indexingType))
13568         m_jit.move(TrustedImm64(bitwise_cast&lt;int64_t&gt;(PNaN)), emptyValueRegs.gpr());
13569     else
13570         m_jit.move(TrustedImm64(JSValue::encode(JSValue())), emptyValueRegs.gpr());
13571 #else
13572     JSValueRegs emptyValueRegs(scratchGPR, scratch2GPR);
13573     if (hasDouble(indexingType))
13574         m_jit.moveValue(JSValue(JSValue::EncodeAsDouble, PNaN), emptyValueRegs);
13575     else
13576         m_jit.moveValue(JSValue(), emptyValueRegs);
13577 #endif
13578     emitInitializeButterfly(storageGPR, sizeGPR, emptyValueRegs, resultGPR);
13579 
13580     RegisteredStructure structure = m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingType));
13581 
13582     emitAllocateJSObject&lt;JSArray&gt;(resultGPR, TrustedImmPtr(structure), storageGPR, scratchGPR, scratch2GPR, slowCases);
13583 
13584     m_jit.mutatorFence(vm());
13585 
13586     addSlowPathGenerator(makeUnique&lt;CallArrayAllocatorWithVariableSizeSlowPathGenerator&gt;(
13587         slowCases, this, operationNewArrayWithSize, resultGPR,
<a name="338" id="anc338"></a><span class="line-added">13588         TrustedImmPtr::weakPointer(m_graph, globalObject),</span>
13589         structure,
13590         shouldConvertLargeSizeToArrayStorage ? m_jit.graph().registerStructure(globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage)) : structure,
13591         sizeGPR, storageGPR));
13592 }
13593 
13594 void SpeculativeJIT::compileHasIndexedProperty(Node* node)
13595 {
13596     SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
13597     SpeculateStrictInt32Operand index(this, m_graph.varArgChild(node, 1));
13598     GPRTemporary result(this);
13599 
13600     GPRReg baseGPR = base.gpr();
13601     GPRReg indexGPR = index.gpr();
13602     GPRReg resultGPR = result.gpr();
13603 
13604     MacroAssembler::JumpList slowCases;
13605     ArrayMode mode = node-&gt;arrayMode();
13606     switch (mode.type()) {
13607     case Array::Int32:
13608     case Array::Contiguous: {
13609         ASSERT(!!m_graph.varArgChild(node, 2));
13610         StorageOperand storage(this, m_graph.varArgChild(node, 2));
13611         GPRTemporary scratch(this);
13612 
13613         GPRReg storageGPR = storage.gpr();
13614         GPRReg scratchGPR = scratch.gpr();
13615 
13616         MacroAssembler::Jump outOfBounds = m_jit.branch32(MacroAssembler::AboveOrEqual, indexGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
13617         if (mode.isInBounds())
13618             speculationCheck(OutOfBounds, JSValueRegs(), nullptr, outOfBounds);
13619         else
13620             slowCases.append(outOfBounds);
13621 
13622 #if USE(JSVALUE64)
13623         m_jit.load64(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight), scratchGPR);
13624         slowCases.append(m_jit.branchIfEmpty(scratchGPR));
13625 #else
13626         m_jit.load32(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)), scratchGPR);
13627         slowCases.append(m_jit.branchIfEmpty(scratchGPR));
13628 #endif
13629         m_jit.move(TrustedImm32(1), resultGPR);
13630         break;
13631     }
13632     case Array::Double: {
13633         ASSERT(!!m_graph.varArgChild(node, 2));
13634         StorageOperand storage(this, m_graph.varArgChild(node, 2));
13635         FPRTemporary scratch(this);
13636         FPRReg scratchFPR = scratch.fpr();
13637         GPRReg storageGPR = storage.gpr();
13638 
13639         MacroAssembler::Jump outOfBounds = m_jit.branch32(MacroAssembler::AboveOrEqual, indexGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
13640         if (mode.isInBounds())
13641             speculationCheck(OutOfBounds, JSValueRegs(), nullptr, outOfBounds);
13642         else
13643             slowCases.append(outOfBounds);
13644 
13645         m_jit.loadDouble(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight), scratchFPR);
13646         slowCases.append(m_jit.branchIfNaN(scratchFPR));
13647         m_jit.move(TrustedImm32(1), resultGPR);
13648         break;
13649     }
13650     case Array::ArrayStorage: {
13651         ASSERT(!!m_graph.varArgChild(node, 2));
13652         StorageOperand storage(this, m_graph.varArgChild(node, 2));
13653         GPRTemporary scratch(this);
13654 
13655         GPRReg storageGPR = storage.gpr();
13656         GPRReg scratchGPR = scratch.gpr();
13657 
13658         MacroAssembler::Jump outOfBounds = m_jit.branch32(MacroAssembler::AboveOrEqual, indexGPR, MacroAssembler::Address(storageGPR, ArrayStorage::vectorLengthOffset()));
13659         if (mode.isInBounds())
13660             speculationCheck(OutOfBounds, JSValueRegs(), nullptr, outOfBounds);
13661         else
13662             slowCases.append(outOfBounds);
13663 
13664 #if USE(JSVALUE64)
13665         m_jit.load64(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()), scratchGPR);
13666         slowCases.append(m_jit.branchIfEmpty(scratchGPR));
13667 #else
13668         m_jit.load32(MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), scratchGPR);
13669         slowCases.append(m_jit.branchIfEmpty(scratchGPR));
13670 #endif
13671         m_jit.move(TrustedImm32(1), resultGPR);
13672         break;
13673     }
13674     default: {
13675         slowCases.append(m_jit.jump());
13676         break;
13677     }
13678     }
13679 
<a name="339" id="anc339"></a><span class="line-modified">13680     addSlowPathGenerator(slowPathCall(slowCases, this, operationHasIndexedPropertyByInt, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, indexGPR, static_cast&lt;int32_t&gt;(node-&gt;internalMethodType())));</span>
13681 
13682     unblessedBooleanResult(resultGPR, node);
13683 }
13684 
13685 void SpeculativeJIT::compileGetDirectPname(Node* node)
13686 {
13687     Edge&amp; baseEdge = m_jit.graph().varArgChild(node, 0);
13688     Edge&amp; propertyEdge = m_jit.graph().varArgChild(node, 1);
13689     Edge&amp; indexEdge = m_jit.graph().varArgChild(node, 2);
13690 
13691     SpeculateCellOperand base(this, baseEdge);
13692     SpeculateCellOperand property(this, propertyEdge);
13693     GPRReg baseGPR = base.gpr();
13694     GPRReg propertyGPR = property.gpr();
13695 
<a name="340" id="anc340"></a>









13696     Edge&amp; enumeratorEdge = m_jit.graph().varArgChild(node, 3);
13697     SpeculateStrictInt32Operand index(this, indexEdge);
13698     SpeculateCellOperand enumerator(this, enumeratorEdge);
13699     GPRTemporary scratch(this);
13700     JSValueRegsTemporary result(this);
13701 
13702     GPRReg indexGPR = index.gpr();
13703     GPRReg enumeratorGPR = enumerator.gpr();
13704     GPRReg scratchGPR = scratch.gpr();
13705     JSValueRegs resultRegs = result.regs();
13706 
13707     MacroAssembler::JumpList slowPath;
13708 
13709     // Check the structure
13710     m_jit.load32(MacroAssembler::Address(baseGPR, JSCell::structureIDOffset()), scratchGPR);
13711     slowPath.append(
13712         m_jit.branch32(
13713             MacroAssembler::NotEqual,
13714             scratchGPR,
13715             MacroAssembler::Address(
13716                 enumeratorGPR, JSPropertyNameEnumerator::cachedStructureIDOffset())));
13717 
13718     // Compute the offset
13719     // If index is less than the enumerator&#39;s cached inline storage, then it&#39;s an inline access
13720     MacroAssembler::Jump outOfLineAccess = m_jit.branch32(MacroAssembler::AboveOrEqual,
13721         indexGPR, MacroAssembler::Address(enumeratorGPR, JSPropertyNameEnumerator::cachedInlineCapacityOffset()));
13722 
13723     m_jit.loadValue(MacroAssembler::BaseIndex(baseGPR, indexGPR, MacroAssembler::TimesEight, JSObject::offsetOfInlineStorage()), resultRegs);
13724 
13725     MacroAssembler::Jump done = m_jit.jump();
13726 
13727     // Otherwise it&#39;s out of line
13728     outOfLineAccess.link(&amp;m_jit);
13729     m_jit.loadPtr(MacroAssembler::Address(baseGPR, JSObject::butterflyOffset()), resultRegs.payloadGPR());
13730     m_jit.move(indexGPR, scratchGPR);
13731     m_jit.sub32(MacroAssembler::Address(enumeratorGPR, JSPropertyNameEnumerator::cachedInlineCapacityOffset()), scratchGPR);
13732     m_jit.neg32(scratchGPR);
13733     m_jit.signExtend32ToPtr(scratchGPR, scratchGPR);
13734     int32_t offsetOfFirstProperty = static_cast&lt;int32_t&gt;(offsetInButterfly(firstOutOfLineOffset)) * sizeof(EncodedJSValue);
13735     m_jit.loadValue(MacroAssembler::BaseIndex(resultRegs.payloadGPR(), scratchGPR, MacroAssembler::TimesEight, offsetOfFirstProperty), resultRegs);
13736 
13737     done.link(&amp;m_jit);
13738 
<a name="341" id="anc341"></a><span class="line-modified">13739     addSlowPathGenerator(slowPathCall(slowPath, this, operationGetByValCell, resultRegs, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, CCallHelpers::CellValue(propertyGPR)));</span>
13740 
13741     jsValueResult(resultRegs, node);
<a name="342" id="anc342"></a>
13742 }
13743 
13744 void SpeculativeJIT::compileExtractCatchLocal(Node* node)
13745 {
13746     JSValueRegsTemporary result(this);
13747     JSValueRegs resultRegs = result.regs();
13748 
13749     JSValue* ptr = &amp;reinterpret_cast&lt;JSValue*&gt;(m_jit.jitCode()-&gt;common.catchOSREntryBuffer-&gt;dataBuffer())[node-&gt;catchOSREntryIndex()];
13750     m_jit.loadValue(ptr, resultRegs);
13751     jsValueResult(resultRegs, node);
13752 }
13753 
13754 void SpeculativeJIT::compileClearCatchLocals(Node* node)
13755 {
13756     ScratchBuffer* scratchBuffer = m_jit.jitCode()-&gt;common.catchOSREntryBuffer;
13757     ASSERT(scratchBuffer);
13758     GPRTemporary scratch(this);
13759     GPRReg scratchGPR = scratch.gpr();
13760     m_jit.move(TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), scratchGPR);
13761     m_jit.storePtr(TrustedImmPtr(nullptr), scratchGPR);
13762     noResult(node);
13763 }
13764 
13765 void SpeculativeJIT::compileProfileType(Node* node)
13766 {
13767     JSValueOperand value(this, node-&gt;child1());
13768     GPRTemporary scratch1(this);
13769     GPRTemporary scratch2(this);
13770     GPRTemporary scratch3(this);
13771 
13772     JSValueRegs valueRegs = value.jsValueRegs();
13773     GPRReg scratch1GPR = scratch1.gpr();
13774     GPRReg scratch2GPR = scratch2.gpr();
13775     GPRReg scratch3GPR = scratch3.gpr();
13776 
13777     MacroAssembler::JumpList jumpToEnd;
13778 
13779     jumpToEnd.append(m_jit.branchIfEmpty(valueRegs));
13780 
13781     TypeLocation* cachedTypeLocation = node-&gt;typeLocation();
13782     // Compile in a predictive type check, if possible, to see if we can skip writing to the log.
13783     // These typechecks are inlined to match those of the 64-bit JSValue type checks.
13784     if (cachedTypeLocation-&gt;m_lastSeenType == TypeUndefined)
13785         jumpToEnd.append(m_jit.branchIfUndefined(valueRegs));
13786     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeNull)
13787         jumpToEnd.append(m_jit.branchIfNull(valueRegs));
13788     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeBoolean)
13789         jumpToEnd.append(m_jit.branchIfBoolean(valueRegs, scratch1GPR));
13790     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeAnyInt)
13791         jumpToEnd.append(m_jit.branchIfInt32(valueRegs));
13792     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeNumber)
13793         jumpToEnd.append(m_jit.branchIfNumber(valueRegs, scratch1GPR));
13794     else if (cachedTypeLocation-&gt;m_lastSeenType == TypeString) {
13795         MacroAssembler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
13796         jumpToEnd.append(m_jit.branchIfString(valueRegs.payloadGPR()));
13797         isNotCell.link(&amp;m_jit);
13798     }
13799 
13800     // Load the TypeProfilerLog into Scratch2.
13801     TypeProfilerLog* cachedTypeProfilerLog = vm().typeProfilerLog();
13802     m_jit.move(TrustedImmPtr(cachedTypeProfilerLog), scratch2GPR);
13803 
13804     // Load the next LogEntry into Scratch1.
13805     m_jit.loadPtr(MacroAssembler::Address(scratch2GPR, TypeProfilerLog::currentLogEntryOffset()), scratch1GPR);
13806 
13807     // Store the JSValue onto the log entry.
13808     m_jit.storeValue(valueRegs, MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::valueOffset()));
13809 
13810     // Store the structureID of the cell if valueRegs is a cell, otherwise, store 0 on the log entry.
13811     MacroAssembler::Jump isNotCell = m_jit.branchIfNotCell(valueRegs);
13812     m_jit.load32(MacroAssembler::Address(valueRegs.payloadGPR(), JSCell::structureIDOffset()), scratch3GPR);
13813     m_jit.store32(scratch3GPR, MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::structureIDOffset()));
13814     MacroAssembler::Jump skipIsCell = m_jit.jump();
13815     isNotCell.link(&amp;m_jit);
13816     m_jit.store32(TrustedImm32(0), MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::structureIDOffset()));
13817     skipIsCell.link(&amp;m_jit);
13818 
13819     // Store the typeLocation on the log entry.
13820     m_jit.move(TrustedImmPtr(cachedTypeLocation), scratch3GPR);
13821     m_jit.storePtr(scratch3GPR, MacroAssembler::Address(scratch1GPR, TypeProfilerLog::LogEntry::locationOffset()));
13822 
13823     // Increment the current log entry.
13824     m_jit.addPtr(TrustedImm32(sizeof(TypeProfilerLog::LogEntry)), scratch1GPR);
13825     m_jit.storePtr(scratch1GPR, MacroAssembler::Address(scratch2GPR, TypeProfilerLog::currentLogEntryOffset()));
13826     MacroAssembler::Jump clearLog = m_jit.branchPtr(MacroAssembler::Equal, scratch1GPR, TrustedImmPtr(cachedTypeProfilerLog-&gt;logEndPtr()));
13827     addSlowPathGenerator(
<a name="343" id="anc343"></a><span class="line-modified">13828         slowPathCall(clearLog, this, operationProcessTypeProfilerLogDFG, NoResult, TrustedImmPtr(&amp;vm())));</span>
13829 
13830     jumpToEnd.link(&amp;m_jit);
13831 
13832     noResult(node);
13833 }
13834 
13835 void SpeculativeJIT::cachedPutById(CodeOrigin codeOrigin, GPRReg baseGPR, JSValueRegs valueRegs, GPRReg scratchGPR, unsigned identifierNumber, PutKind putKind, JITCompiler::Jump slowPathTarget, SpillRegistersMode spillMode)
13836 {
13837     RegisterSet usedRegisters = this-&gt;usedRegisters();
13838     if (spillMode == DontSpill) {
13839         // We&#39;ve already flushed registers to the stack, we don&#39;t need to spill these.
13840         usedRegisters.set(baseGPR, false);
13841         usedRegisters.set(valueRegs, false);
13842     }
13843     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
13844     JITPutByIdGenerator gen(
13845         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters,
13846         JSValueRegs::payloadOnly(baseGPR), valueRegs,
13847         scratchGPR, m_jit.ecmaModeFor(codeOrigin), putKind);
13848 
13849     gen.generateFastPath(m_jit);
13850 
13851     JITCompiler::JumpList slowCases;
13852     if (slowPathTarget.isSet())
13853         slowCases.append(slowPathTarget);
13854     slowCases.append(gen.slowPathJump());
13855 
13856     auto slowPath = slowPathCall(
<a name="344" id="anc344"></a><span class="line-modified">13857         slowCases, this, gen.slowPathFunction(), NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(), valueRegs,</span>
13858         CCallHelpers::CellValue(baseGPR), identifierUID(identifierNumber));
13859 
13860     m_jit.addPutById(gen, slowPath.get());
13861     addSlowPathGenerator(WTFMove(slowPath));
13862 }
13863 
<a name="345" id="anc345"></a><span class="line-modified">13864 void SpeculativeJIT::nonSpeculativeNonPeepholeCompare(Node* node, MacroAssembler::RelationalCondition cond, S_JITOperation_GJJ helperFunction)</span>
13865 {
13866     ASSERT(node-&gt;isBinaryUseKind(UntypedUse));
13867     JSValueOperand arg1(this, node-&gt;child1());
13868     JSValueOperand arg2(this, node-&gt;child2());
13869 
13870     JSValueRegs arg1Regs = arg1.jsValueRegs();
13871     JSValueRegs arg2Regs = arg2.jsValueRegs();
13872 
13873     JITCompiler::JumpList slowPath;
13874 
13875     if (isKnownNotInteger(node-&gt;child1().node()) || isKnownNotInteger(node-&gt;child2().node())) {
13876         GPRFlushedCallResult result(this);
13877         GPRReg resultGPR = result.gpr();
13878 
13879         arg1.use();
13880         arg2.use();
13881 
13882         flushRegisters();
<a name="346" id="anc346"></a><span class="line-modified">13883         callOperation(helperFunction, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs);</span>
13884         m_jit.exceptionCheck();
13885 
13886         unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
13887         return;
13888     }
13889 
13890     GPRTemporary result(this, Reuse, arg1, TagWord);
13891     GPRReg resultGPR = result.gpr();
13892 
13893     arg1.use();
13894     arg2.use();
13895 
13896     if (!isKnownInteger(node-&gt;child1().node()))
13897         slowPath.append(m_jit.branchIfNotInt32(arg1Regs));
13898     if (!isKnownInteger(node-&gt;child2().node()))
13899         slowPath.append(m_jit.branchIfNotInt32(arg2Regs));
13900 
13901     m_jit.compare32(cond, arg1Regs.payloadGPR(), arg2Regs.payloadGPR(), resultGPR);
13902 
13903     if (!isKnownInteger(node-&gt;child1().node()) || !isKnownInteger(node-&gt;child2().node()))
<a name="347" id="anc347"></a><span class="line-modified">13904         addSlowPathGenerator(slowPathCall(slowPath, this, helperFunction, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs));</span>
13905 
13906     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
13907 }
13908 
<a name="348" id="anc348"></a><span class="line-modified">13909 void SpeculativeJIT::nonSpeculativePeepholeBranch(Node* node, Node* branchNode, MacroAssembler::RelationalCondition cond, S_JITOperation_GJJ helperFunction)</span>
13910 {
13911     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
13912     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
13913 
13914     JITCompiler::ResultCondition callResultCondition = JITCompiler::NonZero;
13915 
13916     // The branch instruction will branch to the taken block.
13917     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
13918     if (taken == nextBlock()) {
13919         cond = JITCompiler::invert(cond);
13920         callResultCondition = JITCompiler::Zero;
13921         BasicBlock* tmp = taken;
13922         taken = notTaken;
13923         notTaken = tmp;
13924     }
13925 
13926     JSValueOperand arg1(this, node-&gt;child1());
13927     JSValueOperand arg2(this, node-&gt;child2());
13928     JSValueRegs arg1Regs = arg1.jsValueRegs();
13929     JSValueRegs arg2Regs = arg2.jsValueRegs();
13930 
13931     JITCompiler::JumpList slowPath;
13932 
13933     if (isKnownNotInteger(node-&gt;child1().node()) || isKnownNotInteger(node-&gt;child2().node())) {
13934         GPRFlushedCallResult result(this);
13935         GPRReg resultGPR = result.gpr();
13936 
13937         arg1.use();
13938         arg2.use();
13939 
13940         flushRegisters();
<a name="349" id="anc349"></a><span class="line-modified">13941         callOperation(helperFunction, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs);</span>
13942         m_jit.exceptionCheck();
13943 
13944         branchTest32(callResultCondition, resultGPR, taken);
13945     } else {
13946         GPRTemporary result(this, Reuse, arg2, TagWord);
13947         GPRReg resultGPR = result.gpr();
13948 
13949         arg1.use();
13950         arg2.use();
13951 
13952         if (!isKnownInteger(node-&gt;child1().node()))
13953             slowPath.append(m_jit.branchIfNotInt32(arg1Regs));
13954         if (!isKnownInteger(node-&gt;child2().node()))
13955             slowPath.append(m_jit.branchIfNotInt32(arg2Regs));
13956 
13957         branch32(cond, arg1Regs.payloadGPR(), arg2Regs.payloadGPR(), taken);
13958 
13959         if (!isKnownInteger(node-&gt;child1().node()) || !isKnownInteger(node-&gt;child2().node())) {
13960             jump(notTaken, ForceJump);
13961 
13962             slowPath.link(&amp;m_jit);
13963 
13964             silentSpillAllRegisters(resultGPR);
<a name="350" id="anc350"></a><span class="line-modified">13965             callOperation(helperFunction, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs);</span>
13966             silentFillAllRegisters();
13967             m_jit.exceptionCheck();
13968 
13969             branchTest32(callResultCondition, resultGPR, taken);
13970         }
13971     }
13972 
13973     jump(notTaken);
13974 
13975     m_indexInBlock = m_block-&gt;size() - 1;
13976     m_currentNode = branchNode;
13977 }
13978 
13979 void SpeculativeJIT::compileBigIntEquality(Node* node)
13980 {
13981     // FIXME: [ESNext][BigInt] Create specialized version of strict equals for BigIntUse
13982     // https://bugs.webkit.org/show_bug.cgi?id=182895
13983     SpeculateCellOperand left(this, node-&gt;child1());
13984     SpeculateCellOperand right(this, node-&gt;child2());
13985     GPRTemporary result(this, Reuse, left);
13986     GPRReg leftGPR = left.gpr();
13987     GPRReg rightGPR = right.gpr();
13988     GPRReg resultGPR = result.gpr();
13989 
13990     left.use();
13991     right.use();
13992 
13993     speculateBigInt(node-&gt;child1(), leftGPR);
13994     speculateBigInt(node-&gt;child2(), rightGPR);
13995 
13996     JITCompiler::Jump notEqualCase = m_jit.branchPtr(JITCompiler::NotEqual, leftGPR, rightGPR);
13997 
13998     m_jit.move(JITCompiler::TrustedImm32(1), resultGPR);
13999 
14000     JITCompiler::Jump done = m_jit.jump();
14001 
14002     notEqualCase.link(&amp;m_jit);
14003 
14004     silentSpillAllRegisters(resultGPR);
<a name="351" id="anc351"></a><span class="line-modified">14005     callOperation(operationCompareStrictEqCell, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), leftGPR, rightGPR);</span>
14006     silentFillAllRegisters();
14007 
14008     done.link(&amp;m_jit);
14009 
14010     unblessedBooleanResult(resultGPR, node, UseChildrenCalledExplicitly);
14011 }
14012 
14013 void SpeculativeJIT::compileMakeRope(Node* node)
14014 {
14015     ASSERT(node-&gt;child1().useKind() == KnownStringUse);
14016     ASSERT(node-&gt;child2().useKind() == KnownStringUse);
14017     ASSERT(!node-&gt;child3() || node-&gt;child3().useKind() == KnownStringUse);
14018 
14019     SpeculateCellOperand op1(this, node-&gt;child1());
14020     SpeculateCellOperand op2(this, node-&gt;child2());
14021     SpeculateCellOperand op3(this, node-&gt;child3());
14022     GPRReg opGPRs[3];
14023     unsigned numOpGPRs;
14024     opGPRs[0] = op1.gpr();
14025     opGPRs[1] = op2.gpr();
14026     if (node-&gt;child3()) {
14027         opGPRs[2] = op3.gpr();
14028         numOpGPRs = 3;
14029     } else {
14030         opGPRs[2] = InvalidGPRReg;
14031         numOpGPRs = 2;
14032     }
14033 
14034 #if CPU(ADDRESS64)
14035     Edge edges[3] = {
14036         node-&gt;child1(),
14037         node-&gt;child2(),
14038         node-&gt;child3()
14039     };
14040 
14041     GPRTemporary result(this);
14042     GPRTemporary allocator(this);
14043     GPRTemporary scratch(this);
14044     GPRTemporary scratch2(this);
14045     GPRReg resultGPR = result.gpr();
14046     GPRReg allocatorGPR = allocator.gpr();
14047     GPRReg scratchGPR = scratch.gpr();
14048     GPRReg scratch2GPR = scratch2.gpr();
14049 
14050     CCallHelpers::JumpList slowPath;
14051     Allocator allocatorValue = allocatorForNonVirtualConcurrently&lt;JSRopeString&gt;(vm(), sizeof(JSRopeString), AllocatorForMode::AllocatorIfExists);
14052     emitAllocateJSCell(resultGPR, JITAllocator::constant(allocatorValue), allocatorGPR, TrustedImmPtr(m_jit.graph().registerStructure(vm().stringStructure.get())), scratchGPR, slowPath);
14053 
14054     // This puts nullptr for the first fiber. It makes visitChildren safe even if this JSRopeString is discarded due to the speculation failure in the following path.
14055     m_jit.storePtr(TrustedImmPtr(JSString::isRopeInPointer), CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber0()));
14056 
14057     {
14058         if (JSString* string = edges[0]-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {
14059             m_jit.move(TrustedImm32(string-&gt;is8Bit() ? StringImpl::flagIs8Bit() : 0), scratchGPR);
14060             m_jit.move(TrustedImm32(string-&gt;length()), allocatorGPR);
14061         } else {
14062             bool needsRopeCase = canBeRope(edges[0]);
14063             m_jit.loadPtr(CCallHelpers::Address(opGPRs[0], JSString::offsetOfValue()), scratch2GPR);
14064             CCallHelpers::Jump isRope;
14065             if (needsRopeCase)
14066                 isRope = m_jit.branchIfRopeStringImpl(scratch2GPR);
14067 
14068             m_jit.load32(CCallHelpers::Address(scratch2GPR, StringImpl::flagsOffset()), scratchGPR);
14069             m_jit.load32(CCallHelpers::Address(scratch2GPR, StringImpl::lengthMemoryOffset()), allocatorGPR);
14070 
14071             if (needsRopeCase) {
14072                 auto done = m_jit.jump();
14073 
14074                 isRope.link(&amp;m_jit);
14075                 m_jit.load32(CCallHelpers::Address(opGPRs[0], JSRopeString::offsetOfFlags()), scratchGPR);
14076                 m_jit.load32(CCallHelpers::Address(opGPRs[0], JSRopeString::offsetOfLength()), allocatorGPR);
14077                 done.link(&amp;m_jit);
14078             }
14079         }
14080 
<a name="352" id="anc352"></a><span class="line-modified">14081         if (ASSERT_ENABLED) {</span>
14082             CCallHelpers::Jump ok = m_jit.branch32(
14083                 CCallHelpers::GreaterThanOrEqual, allocatorGPR, TrustedImm32(0));
14084             m_jit.abortWithReason(DFGNegativeStringLength);
14085             ok.link(&amp;m_jit);
14086         }
14087     }
14088 
14089     for (unsigned i = 1; i &lt; numOpGPRs; ++i) {
14090         if (JSString* string = edges[i]-&gt;dynamicCastConstant&lt;JSString*&gt;(vm())) {
14091             m_jit.and32(TrustedImm32(string-&gt;is8Bit() ? StringImpl::flagIs8Bit() : 0), scratchGPR);
14092             speculationCheck(
14093                 Uncountable, JSValueSource(), nullptr,
14094                 m_jit.branchAdd32(
14095                     CCallHelpers::Overflow,
14096                     TrustedImm32(string-&gt;length()), allocatorGPR));
14097         } else {
14098             bool needsRopeCase = canBeRope(edges[i]);
14099             m_jit.loadPtr(CCallHelpers::Address(opGPRs[i], JSString::offsetOfValue()), scratch2GPR);
14100             CCallHelpers::Jump isRope;
14101             if (needsRopeCase)
14102                 isRope = m_jit.branchIfRopeStringImpl(scratch2GPR);
14103 
14104             m_jit.and32(CCallHelpers::Address(scratch2GPR, StringImpl::flagsOffset()), scratchGPR);
14105             speculationCheck(
14106                 Uncountable, JSValueSource(), nullptr,
14107                 m_jit.branchAdd32(
14108                     CCallHelpers::Overflow,
14109                     CCallHelpers::Address(scratch2GPR, StringImpl::lengthMemoryOffset()), allocatorGPR));
14110             if (needsRopeCase) {
14111                 auto done = m_jit.jump();
14112 
14113                 isRope.link(&amp;m_jit);
14114                 m_jit.and32(CCallHelpers::Address(opGPRs[i], JSRopeString::offsetOfFlags()), scratchGPR);
14115                 m_jit.load32(CCallHelpers::Address(opGPRs[i], JSRopeString::offsetOfLength()), scratch2GPR);
14116                 speculationCheck(
14117                     Uncountable, JSValueSource(), nullptr,
14118                     m_jit.branchAdd32(
14119                         CCallHelpers::Overflow, scratch2GPR, allocatorGPR));
14120                 done.link(&amp;m_jit);
14121             }
14122         }
14123     }
14124 
<a name="353" id="anc353"></a><span class="line-modified">14125     if (ASSERT_ENABLED) {</span>
14126         CCallHelpers::Jump ok = m_jit.branch32(
14127             CCallHelpers::GreaterThanOrEqual, allocatorGPR, TrustedImm32(0));
14128         m_jit.abortWithReason(DFGNegativeStringLength);
14129         ok.link(&amp;m_jit);
14130     }
14131 
14132     static_assert(StringImpl::flagIs8Bit() == JSRopeString::is8BitInPointer, &quot;&quot;);
14133     m_jit.and32(TrustedImm32(StringImpl::flagIs8Bit()), scratchGPR);
14134     m_jit.orPtr(opGPRs[0], scratchGPR);
14135     m_jit.orPtr(TrustedImmPtr(JSString::isRopeInPointer), scratchGPR);
14136     m_jit.storePtr(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber0()));
14137 
14138     m_jit.move(opGPRs[1], scratchGPR);
14139     m_jit.lshiftPtr(TrustedImm32(32), scratchGPR);
14140     m_jit.orPtr(allocatorGPR, scratchGPR);
14141     m_jit.storePtr(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber1()));
14142 
14143     if (numOpGPRs == 2) {
14144         m_jit.move(opGPRs[1], scratchGPR);
14145         m_jit.rshiftPtr(TrustedImm32(32), scratchGPR);
14146         m_jit.storePtr(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber2()));
14147     } else {
14148         m_jit.move(opGPRs[1], scratchGPR);
14149         m_jit.rshiftPtr(TrustedImm32(32), scratchGPR);
14150         m_jit.move(opGPRs[2], scratch2GPR);
14151         m_jit.lshiftPtr(TrustedImm32(16), scratch2GPR);
14152         m_jit.orPtr(scratch2GPR, scratchGPR);
14153         m_jit.storePtr(scratchGPR, CCallHelpers::Address(resultGPR, JSRopeString::offsetOfFiber2()));
14154     }
14155 
14156     auto isNonEmptyString = m_jit.branchTest32(CCallHelpers::NonZero, allocatorGPR);
14157 
14158     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), jsEmptyString(m_jit.graph().m_vm)), resultGPR);
14159 
14160     isNonEmptyString.link(&amp;m_jit);
14161     m_jit.mutatorFence(vm());
14162 
14163     switch (numOpGPRs) {
14164     case 2:
14165         addSlowPathGenerator(slowPathCall(
<a name="354" id="anc354"></a><span class="line-modified">14166             slowPath, this, operationMakeRope2, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), opGPRs[0], opGPRs[1]));</span>
14167         break;
14168     case 3:
14169         addSlowPathGenerator(slowPathCall(
<a name="355" id="anc355"></a><span class="line-modified">14170             slowPath, this, operationMakeRope3, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), opGPRs[0], opGPRs[1], opGPRs[2]));</span>
14171         break;
14172     default:
14173         RELEASE_ASSERT_NOT_REACHED();
14174         break;
14175     }
14176 
14177     cellResult(resultGPR, node);
14178 #else
14179     flushRegisters();
14180     GPRFlushedCallResult result(this);
14181     GPRReg resultGPR = result.gpr();
14182     switch (numOpGPRs) {
14183     case 2:
<a name="356" id="anc356"></a><span class="line-modified">14184         callOperation(operationMakeRope2, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), opGPRs[0], opGPRs[1]);</span>
14185         m_jit.exceptionCheck();
14186         break;
14187     case 3:
<a name="357" id="anc357"></a><span class="line-modified">14188         callOperation(operationMakeRope3, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), opGPRs[0], opGPRs[1], opGPRs[2]);</span>
14189         m_jit.exceptionCheck();
14190         break;
14191     default:
14192         RELEASE_ASSERT_NOT_REACHED();
14193         break;
14194     }
14195 
14196     cellResult(resultGPR, node);
14197 #endif
14198 }
14199 
14200 } } // namespace JSC::DFG
14201 
14202 #endif
<a name="358" id="anc358"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="358" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/MemoryIDBBackingStore.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;MemoryIDBBackingStore.h&quot;
 28 
 29 #if ENABLE(INDEXED_DATABASE)
 30 
 31 #include &quot;IDBCursorInfo.h&quot;
 32 #include &quot;IDBGetAllRecordsData.h&quot;
 33 #include &quot;IDBGetRecordData.h&quot;
 34 #include &quot;IDBGetResult.h&quot;
 35 #include &quot;IDBIndexInfo.h&quot;
 36 #include &quot;IDBIterateCursorData.h&quot;
 37 #include &quot;IDBKeyRangeData.h&quot;
 38 #include &quot;Logging.h&quot;
 39 #include &quot;MemoryIndexCursor.h&quot;
 40 #include &quot;MemoryObjectStore.h&quot;
 41 #include &quot;MemoryObjectStoreCursor.h&quot;
 42 
 43 namespace WebCore {
 44 namespace IDBServer {
 45 
<a name="1" id="anc1"></a><span class="line-modified"> 46 // The IndexedDB spec states the maximum value you can get from the key generator is 2^53.</span>
<span class="line-modified"> 47 constexpr uint64_t maxGeneratedKeyValue = 0x20000000000000;</span>





 48 
 49 MemoryIDBBackingStore::MemoryIDBBackingStore(PAL::SessionID sessionID, const IDBDatabaseIdentifier&amp; identifier)
 50     : m_identifier(identifier)
 51     , m_sessionID(sessionID)
 52 {
 53 }
 54 
 55 MemoryIDBBackingStore::~MemoryIDBBackingStore() = default;
 56 
 57 IDBError MemoryIDBBackingStore::getOrEstablishDatabaseInfo(IDBDatabaseInfo&amp; info)
 58 {
 59     if (!m_databaseInfo)
<a name="2" id="anc2"></a><span class="line-modified"> 60         m_databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(m_identifier.databaseName(), 0, 0);</span>
 61 
 62     info = *m_databaseInfo;
 63     return IDBError { };
 64 }
 65 
 66 void MemoryIDBBackingStore::setDatabaseInfo(const IDBDatabaseInfo&amp; info)
 67 {
 68     // It is not valid to directly set database info on a backing store that hasn&#39;t already set its own database info.
 69     ASSERT(m_databaseInfo);
 70 
 71     m_databaseInfo = makeUnique&lt;IDBDatabaseInfo&gt;(info);
 72 }
 73 
 74 IDBError MemoryIDBBackingStore::beginTransaction(const IDBTransactionInfo&amp; info)
 75 {
 76     LOG(IndexedDB, &quot;MemoryIDBBackingStore::beginTransaction&quot;);
 77 
 78     if (m_transactions.contains(info.identifier()))
 79         return IDBError { InvalidStateError, &quot;Backing store asked to create transaction it already has a record of&quot; };
 80 
 81     auto transaction = MemoryBackingStoreTransaction::create(*this, info);
 82 
 83     // VersionChange transactions are scoped to &quot;every object store&quot;.
 84     if (transaction-&gt;isVersionChange()) {
 85         for (auto&amp; objectStore : m_objectStoresByIdentifier.values())
 86             transaction-&gt;addExistingObjectStore(*objectStore);
 87     } else if (transaction-&gt;isWriting()) {
 88         for (auto&amp; iterator : m_objectStoresByName) {
 89             if (info.objectStores().contains(iterator.key))
 90                 transaction-&gt;addExistingObjectStore(*iterator.value);
 91         }
 92     }
 93 
 94     m_transactions.set(info.identifier(), WTFMove(transaction));
 95 
 96     return IDBError { };
 97 }
 98 
 99 IDBError MemoryIDBBackingStore::abortTransaction(const IDBResourceIdentifier&amp; transactionIdentifier)
100 {
101     LOG(IndexedDB, &quot;MemoryIDBBackingStore::abortTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
102 
103     auto transaction = m_transactions.take(transactionIdentifier);
104     if (!transaction)
105         return IDBError { InvalidStateError, &quot;Backing store asked to abort transaction it didn&#39;t have record of&quot; };
106 
107     transaction-&gt;abort();
108 
109     return IDBError { };
110 }
111 
112 IDBError MemoryIDBBackingStore::commitTransaction(const IDBResourceIdentifier&amp; transactionIdentifier)
113 {
114     LOG(IndexedDB, &quot;MemoryIDBBackingStore::commitTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
115 
116     auto transaction = m_transactions.take(transactionIdentifier);
117     if (!transaction)
118         return IDBError { InvalidStateError, &quot;Backing store asked to commit transaction it didn&#39;t have record of&quot; };
119 
120     transaction-&gt;commit();
121 
122     return IDBError { };
123 }
124 
125 IDBError MemoryIDBBackingStore::createObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBObjectStoreInfo&amp; info)
126 {
127     LOG(IndexedDB, &quot;MemoryIDBBackingStore::createObjectStore - adding OS %s with ID %&quot; PRIu64, info.name().utf8().data(), info.identifier());
128 
129     ASSERT(m_databaseInfo);
130     if (m_databaseInfo-&gt;hasObjectStore(info.name()))
131         return IDBError { ConstraintError };
132 
133     ASSERT(!m_objectStoresByIdentifier.contains(info.identifier()));
134     auto objectStore = MemoryObjectStore::create(m_sessionID, info);
135 
136     m_databaseInfo-&gt;addExistingObjectStore(info);
137 
138     auto rawTransaction = m_transactions.get(transactionIdentifier);
139     ASSERT(rawTransaction);
140     ASSERT(rawTransaction-&gt;isVersionChange());
141 
142     rawTransaction-&gt;addNewObjectStore(objectStore.get());
143     registerObjectStore(WTFMove(objectStore));
144 
145     return IDBError { };
146 }
147 
148 IDBError MemoryIDBBackingStore::deleteObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier)
149 {
150     LOG(IndexedDB, &quot;MemoryIDBBackingStore::deleteObjectStore&quot;);
151 
152     ASSERT(m_databaseInfo);
153     if (!m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier))
154         return IDBError { ConstraintError };
155 
156     auto transaction = m_transactions.get(transactionIdentifier);
157     ASSERT(transaction);
158     ASSERT(transaction-&gt;isVersionChange());
159 
160     auto objectStore = takeObjectStoreByIdentifier(objectStoreIdentifier);
161     ASSERT(objectStore);
162     if (!objectStore)
163         return IDBError { ConstraintError };
164 
165     m_databaseInfo-&gt;deleteObjectStore(objectStore-&gt;info().name());
166     transaction-&gt;objectStoreDeleted(*objectStore);
167 
168     return IDBError { };
169 }
170 
171 IDBError MemoryIDBBackingStore::renameObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const String&amp; newName)
172 {
173     LOG(IndexedDB, &quot;MemoryIDBBackingStore::renameObjectStore&quot;);
174 
175     ASSERT(m_databaseInfo);
176     if (!m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier))
177         return IDBError { ConstraintError };
178 
179     auto transaction = m_transactions.get(transactionIdentifier);
180     ASSERT(transaction);
181     ASSERT(transaction-&gt;isVersionChange());
182 
183     auto objectStore = m_objectStoresByIdentifier.get(objectStoreIdentifier);
184     ASSERT(objectStore);
185     if (!objectStore)
186         return IDBError { ConstraintError };
187 
188     String oldName = objectStore-&gt;info().name();
189     objectStore-&gt;rename(newName);
190     transaction-&gt;objectStoreRenamed(*objectStore, oldName);
191 
<a name="3" id="anc3"></a><span class="line-added">192     m_objectStoresByName.remove(oldName);</span>
<span class="line-added">193     m_objectStoresByName.set(newName, objectStore);</span>
<span class="line-added">194 </span>
195     m_databaseInfo-&gt;renameObjectStore(objectStoreIdentifier, newName);
196 
197     return IDBError { };
198 }
199 
200 IDBError MemoryIDBBackingStore::clearObjectStore(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier)
201 {
202     LOG(IndexedDB, &quot;MemoryIDBBackingStore::clearObjectStore&quot;);
203     ASSERT(objectStoreIdentifier);
204 
205     ASSERT_UNUSED(transactionIdentifier, m_transactions.contains(transactionIdentifier));
206 
207 #ifndef NDEBUG
208     auto transaction = m_transactions.get(transactionIdentifier);
209     ASSERT(transaction-&gt;isWriting());
210 #endif
211 
212     auto objectStore = m_objectStoresByIdentifier.get(objectStoreIdentifier);
213     if (!objectStore)
214         return IDBError { ConstraintError };
215 
216     objectStore-&gt;clear();
217 
218     return IDBError { };
219 }
220 
221 IDBError MemoryIDBBackingStore::createIndex(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBIndexInfo&amp; info)
222 {
223     LOG(IndexedDB, &quot;MemoryIDBBackingStore::createIndex&quot;);
224 
<a name="4" id="anc4"></a><span class="line-added">225     ASSERT(m_databaseInfo);</span>
<span class="line-added">226     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(info.objectStoreIdentifier());</span>
<span class="line-added">227     if (!objectStoreInfo)</span>
<span class="line-added">228         return IDBError { ConstraintError };</span>
<span class="line-added">229 </span>
230     auto rawTransaction = m_transactions.get(transactionIdentifier);
231     ASSERT(rawTransaction);
232     ASSERT(rawTransaction-&gt;isVersionChange());
233 
234     auto* objectStore = m_objectStoresByIdentifier.get(info.objectStoreIdentifier());
235     if (!objectStore)
236         return IDBError { ConstraintError };
237 
<a name="5" id="anc5"></a><span class="line-modified">238     auto error = objectStore-&gt;createIndex(*rawTransaction, info);</span>
<span class="line-added">239     if (error.isNull()) {</span>
<span class="line-added">240         objectStoreInfo-&gt;addExistingIndex(info);</span>
<span class="line-added">241         m_databaseInfo-&gt;setMaxIndexID(info.identifier());</span>
<span class="line-added">242     }</span>
<span class="line-added">243 </span>
<span class="line-added">244     return error;</span>
245 }
246 
247 IDBError MemoryIDBBackingStore::deleteIndex(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier)
248 {
249     LOG(IndexedDB, &quot;MemoryIDBBackingStore::deleteIndex&quot;);
250 
<a name="6" id="anc6"></a><span class="line-added">251     ASSERT(m_databaseInfo);</span>
<span class="line-added">252     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);</span>
<span class="line-added">253     if (!objectStoreInfo)</span>
<span class="line-added">254         return IDBError { ConstraintError };</span>
<span class="line-added">255 </span>
<span class="line-added">256     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);</span>
<span class="line-added">257     if (!indexInfo)</span>
<span class="line-added">258         return IDBError { ConstraintError };</span>
<span class="line-added">259 </span>
260     auto rawTransaction = m_transactions.get(transactionIdentifier);
261     ASSERT(rawTransaction);
262     ASSERT(rawTransaction-&gt;isVersionChange());
263 
264     auto* objectStore = m_objectStoresByIdentifier.get(objectStoreIdentifier);
265     if (!objectStore)
266         return IDBError { ConstraintError };
267 
<a name="7" id="anc7"></a><span class="line-modified">268     auto error = objectStore-&gt;deleteIndex(*rawTransaction, indexIdentifier);</span>
<span class="line-added">269     if (error.isNull())</span>
<span class="line-added">270         objectStoreInfo-&gt;deleteIndex(indexIdentifier);</span>
<span class="line-added">271 </span>
<span class="line-added">272     return error;</span>
273 }
274 
275 IDBError MemoryIDBBackingStore::renameIndex(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
276 {
277     LOG(IndexedDB, &quot;MemoryIDBBackingStore::renameIndex&quot;);
278 
279     ASSERT(m_databaseInfo);
280     auto* objectStoreInfo = m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
281     if (!objectStoreInfo)
282         return IDBError { ConstraintError };
283 
284     auto* indexInfo = objectStoreInfo-&gt;infoForExistingIndex(indexIdentifier);
285     if (!indexInfo)
286         return IDBError { ConstraintError };
287 
288     auto transaction = m_transactions.get(transactionIdentifier);
289     ASSERT(transaction);
290     ASSERT(transaction-&gt;isVersionChange());
291 
292     auto objectStore = m_objectStoresByIdentifier.get(objectStoreIdentifier);
293     ASSERT(objectStore);
294     if (!objectStore)
295         return IDBError { ConstraintError };
296 
297     auto* index = objectStore-&gt;indexForIdentifier(indexIdentifier);
298     ASSERT(index);
299     if (!index)
300         return IDBError { ConstraintError };
301 
302     String oldName = index-&gt;info().name();
303     objectStore-&gt;renameIndex(*index, newName);
304     transaction-&gt;indexRenamed(*index, oldName);
305 
306     indexInfo-&gt;rename(newName);
307 
308     return IDBError { };
309 }
310 
311 void MemoryIDBBackingStore::removeObjectStoreForVersionChangeAbort(MemoryObjectStore&amp; objectStore)
312 {
313     LOG(IndexedDB, &quot;MemoryIDBBackingStore::removeObjectStoreForVersionChangeAbort&quot;);
314 
315     if (!m_objectStoresByIdentifier.contains(objectStore.info().identifier()))
316         return;
317 
318     ASSERT(m_objectStoresByIdentifier.get(objectStore.info().identifier()) == &amp;objectStore);
319 
320     unregisterObjectStore(objectStore);
321 }
322 
323 void MemoryIDBBackingStore::restoreObjectStoreForVersionChangeAbort(Ref&lt;MemoryObjectStore&gt;&amp;&amp; objectStore)
324 {
325     registerObjectStore(WTFMove(objectStore));
326 }
327 
328 IDBError MemoryIDBBackingStore::keyExistsInObjectStore(const IDBResourceIdentifier&amp;, uint64_t objectStoreIdentifier, const IDBKeyData&amp; keyData, bool&amp; keyExists)
329 {
330     LOG(IndexedDB, &quot;MemoryIDBBackingStore::keyExistsInObjectStore&quot;);
331 
332     ASSERT(objectStoreIdentifier);
333 
334     MemoryObjectStore* objectStore = m_objectStoresByIdentifier.get(objectStoreIdentifier);
335     RELEASE_ASSERT(objectStore);
336 
337     keyExists = objectStore-&gt;containsRecord(keyData);
338     return IDBError { };
339 }
340 
341 IDBError MemoryIDBBackingStore::deleteRange(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyRangeData&amp; range)
342 {
343     LOG(IndexedDB, &quot;MemoryIDBBackingStore::deleteRange&quot;);
344 
345     ASSERT(objectStoreIdentifier);
346 
347     if (!m_transactions.contains(transactionIdentifier))
348         return IDBError { UnknownError, &quot;No backing store transaction found to delete from&quot;_s };
349 
350     MemoryObjectStore* objectStore = m_objectStoresByIdentifier.get(objectStoreIdentifier);
351     if (!objectStore)
352         return IDBError { UnknownError, &quot;No backing store object store found&quot;_s };
353 
354     objectStore-&gt;deleteRange(range);
355     return IDBError { };
356 }
357 
358 IDBError MemoryIDBBackingStore::addRecord(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBObjectStoreInfo&amp; objectStoreInfo, const IDBKeyData&amp; keyData, const IDBValue&amp; value)
359 {
360     LOG(IndexedDB, &quot;MemoryIDBBackingStore::addRecord&quot;);
361 
362     ASSERT(objectStoreInfo.identifier());
363 
364     auto transaction = m_transactions.get(transactionIdentifier);
365     if (!transaction)
366         return IDBError { UnknownError, &quot;No backing store transaction found to put record&quot;_s };
367 
368     MemoryObjectStore* objectStore = m_objectStoresByIdentifier.get(objectStoreInfo.identifier());
369     if (!objectStore)
370         return IDBError { UnknownError, &quot;No backing store object store found to put record&quot;_s };
371 
372     return objectStore-&gt;addRecord(*transaction, keyData, value);
373 }
374 
375 IDBError MemoryIDBBackingStore::getRecord(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, const IDBKeyRangeData&amp; range, IDBGetRecordDataType type, IDBGetResult&amp; outValue)
376 {
377     LOG(IndexedDB, &quot;MemoryIDBBackingStore::getRecord&quot;);
378 
379     ASSERT(objectStoreIdentifier);
380 
381     if (!m_transactions.contains(transactionIdentifier))
382         return IDBError { UnknownError, &quot;No backing store transaction found to get record&quot;_s };
383 
384     MemoryObjectStore* objectStore = m_objectStoresByIdentifier.get(objectStoreIdentifier);
385     if (!objectStore)
386         return IDBError { UnknownError, &quot;No backing store object store found&quot;_s };
387 
388     switch (type) {
389     case IDBGetRecordDataType::KeyAndValue: {
390         auto key = objectStore-&gt;lowestKeyWithRecordInRange(range);
391         outValue = { key, key.isNull() ? ThreadSafeDataBuffer() : objectStore-&gt;valueForKey(key), objectStore-&gt;info().keyPath() };
392         break;
393     }
394     case IDBGetRecordDataType::KeyOnly:
395         outValue = objectStore-&gt;lowestKeyWithRecordInRange(range);
396         break;
397     }
398 
399     return IDBError { };
400 }
401 
402 IDBError MemoryIDBBackingStore::getAllRecords(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBGetAllRecordsData&amp; getAllRecordsData, IDBGetAllResult&amp; result)
403 {
404     LOG(IndexedDB, &quot;MemoryIDBBackingStore::getAllRecords&quot;);
405 
406     ASSERT(getAllRecordsData.objectStoreIdentifier);
407 
408     if (!m_transactions.contains(transactionIdentifier))
409         return IDBError { UnknownError, &quot;No backing store transaction found to get all records&quot;_s };
410 
411     auto* objectStore = m_objectStoresByIdentifier.get(getAllRecordsData.objectStoreIdentifier);
412     if (!objectStore)
413         return IDBError { UnknownError, &quot;No backing store object store found&quot;_s };
414 
415     if (getAllRecordsData.indexIdentifier) {
416         auto* index = objectStore-&gt;indexForIdentifier(getAllRecordsData.indexIdentifier);
417         if (!index)
418             return IDBError { UnknownError, &quot;No backing store index found&quot;_s };
419 
420         index-&gt;getAllRecords(getAllRecordsData.keyRangeData, getAllRecordsData.count, getAllRecordsData.getAllType, result);
421     } else
422         objectStore-&gt;getAllRecords(getAllRecordsData.keyRangeData, getAllRecordsData.count, getAllRecordsData.getAllType, result);
423 
424     return IDBError { };
425 }
426 
427 IDBError MemoryIDBBackingStore::getIndexRecord(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, IndexedDB::IndexRecordType recordType, const IDBKeyRangeData&amp; range, IDBGetResult&amp; outValue)
428 {
429     LOG(IndexedDB, &quot;MemoryIDBBackingStore::getIndexRecord&quot;);
430 
431     ASSERT(objectStoreIdentifier);
432 
433     if (!m_transactions.contains(transactionIdentifier))
434         return IDBError { UnknownError, &quot;No backing store transaction found to get record&quot;_s };
435 
436     MemoryObjectStore* objectStore = m_objectStoresByIdentifier.get(objectStoreIdentifier);
437     if (!objectStore)
438         return IDBError { UnknownError, &quot;No backing store object store found&quot;_s };
439 
440     outValue = objectStore-&gt;indexValueForKeyRange(indexIdentifier, recordType, range);
441     return IDBError { };
442 }
443 
444 IDBError MemoryIDBBackingStore::getCount(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const IDBKeyRangeData&amp; range, uint64_t&amp; outCount)
445 {
446     LOG(IndexedDB, &quot;MemoryIDBBackingStore::getCount&quot;);
447 
448     ASSERT(objectStoreIdentifier);
449 
450     if (!m_transactions.contains(transactionIdentifier))
451         return IDBError { UnknownError, &quot;No backing store transaction found to get count&quot;_s };
452 
453     MemoryObjectStore* objectStore = m_objectStoresByIdentifier.get(objectStoreIdentifier);
454     if (!objectStore)
455         return IDBError { UnknownError, &quot;No backing store object store found&quot;_s };
456 
457     outCount = objectStore-&gt;countForKeyRange(indexIdentifier, range);
458 
459     return IDBError { };
460 }
461 
462 IDBError MemoryIDBBackingStore::generateKeyNumber(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t&amp; keyNumber)
463 {
464     LOG(IndexedDB, &quot;MemoryIDBBackingStore::generateKeyNumber&quot;);
465     ASSERT(objectStoreIdentifier);
466     ASSERT_UNUSED(transactionIdentifier, m_transactions.contains(transactionIdentifier));
467     ASSERT_UNUSED(transactionIdentifier, m_transactions.get(transactionIdentifier)-&gt;isWriting());
468 
469     MemoryObjectStore* objectStore = m_objectStoresByIdentifier.get(objectStoreIdentifier);
470     RELEASE_ASSERT(objectStore);
471 
472     keyNumber = objectStore-&gt;currentKeyGeneratorValue();
473     if (keyNumber &gt; maxGeneratedKeyValue)
474         return IDBError { ConstraintError, &quot;Cannot generate new key value over 2^53 for object store operation&quot; };
475 
476     objectStore-&gt;setKeyGeneratorValue(keyNumber + 1);
477 
478     return IDBError { };
479 }
480 
481 IDBError MemoryIDBBackingStore::revertGeneratedKeyNumber(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, uint64_t keyNumber)
482 {
483     LOG(IndexedDB, &quot;MemoryIDBBackingStore::revertGeneratedKeyNumber&quot;);
484     ASSERT(objectStoreIdentifier);
485     ASSERT_UNUSED(transactionIdentifier, m_transactions.contains(transactionIdentifier));
486     ASSERT_UNUSED(transactionIdentifier, m_transactions.get(transactionIdentifier)-&gt;isWriting());
487 
488     MemoryObjectStore* objectStore = m_objectStoresByIdentifier.get(objectStoreIdentifier);
489     RELEASE_ASSERT(objectStore);
490 
491     objectStore-&gt;setKeyGeneratorValue(keyNumber);
492 
493     return IDBError { };
494 }
495 
496 IDBError MemoryIDBBackingStore::maybeUpdateKeyGeneratorNumber(const IDBResourceIdentifier&amp; transactionIdentifier, uint64_t objectStoreIdentifier, double newKeyNumber)
497 {
498     LOG(IndexedDB, &quot;MemoryIDBBackingStore::maybeUpdateKeyGeneratorNumber&quot;);
499     ASSERT(objectStoreIdentifier);
500     ASSERT_UNUSED(transactionIdentifier, m_transactions.contains(transactionIdentifier));
501     ASSERT_UNUSED(transactionIdentifier, m_transactions.get(transactionIdentifier)-&gt;isWriting());
502 
503     MemoryObjectStore* objectStore = m_objectStoresByIdentifier.get(objectStoreIdentifier);
504     RELEASE_ASSERT(objectStore);
505 
506     if (newKeyNumber &lt; objectStore-&gt;currentKeyGeneratorValue())
507         return IDBError { };
508 
<a name="8" id="anc8"></a><span class="line-added">509     if (newKeyNumber &gt;= (double)maxGeneratedKeyValue) {</span>
<span class="line-added">510         objectStore-&gt;setKeyGeneratorValue(maxGeneratedKeyValue + 1);</span>
<span class="line-added">511         return IDBError { };</span>
<span class="line-added">512     }</span>
<span class="line-added">513 </span>
514     uint64_t newKeyInteger(newKeyNumber);
515     if (newKeyInteger &lt;= uint64_t(newKeyNumber))
516         ++newKeyInteger;
517 
518     ASSERT(newKeyInteger &gt; uint64_t(newKeyNumber));
519 
520     objectStore-&gt;setKeyGeneratorValue(newKeyInteger);
521 
522     return IDBError { };
523 }
524 
525 IDBError MemoryIDBBackingStore::openCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBCursorInfo&amp; info, IDBGetResult&amp; outData)
526 {
527     LOG(IndexedDB, &quot;MemoryIDBBackingStore::openCursor&quot;);
528 
529     ASSERT(!MemoryCursor::cursorForIdentifier(info.identifier()));
530 
531     if (!m_transactions.contains(transactionIdentifier))
532         return IDBError { UnknownError, &quot;No backing store transaction found in which to open a cursor&quot;_s };
533 
534     switch (info.cursorSource()) {
535     case IndexedDB::CursorSource::ObjectStore: {
536         auto* objectStore = m_objectStoresByIdentifier.get(info.sourceIdentifier());
537         if (!objectStore)
538             return IDBError { UnknownError, &quot;No backing store object store found&quot;_s };
539 
540         MemoryCursor* cursor = objectStore-&gt;maybeOpenCursor(info);
541         if (!cursor)
542             return IDBError { UnknownError, &quot;Could not create object store cursor in backing store&quot;_s };
543 
544         cursor-&gt;currentData(outData);
545         break;
546     }
547     case IndexedDB::CursorSource::Index:
548         auto* objectStore = m_objectStoresByIdentifier.get(info.objectStoreIdentifier());
549         if (!objectStore)
550             return IDBError { UnknownError, &quot;No backing store object store found&quot;_s };
551 
552         auto* index = objectStore-&gt;indexForIdentifier(info.sourceIdentifier());
553         if (!index)
554             return IDBError { UnknownError, &quot;No backing store index found&quot;_s };
555 
556         MemoryCursor* cursor = index-&gt;maybeOpenCursor(info);
557         if (!cursor)
558             return IDBError { UnknownError, &quot;Could not create index cursor in backing store&quot;_s };
559 
560         cursor-&gt;currentData(outData);
561         break;
562     }
563 
564     return IDBError { };
565 }
566 
567 IDBError MemoryIDBBackingStore::iterateCursor(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBResourceIdentifier&amp; cursorIdentifier, const IDBIterateCursorData&amp; data, IDBGetResult&amp; outData)
568 {
569     LOG(IndexedDB, &quot;MemoryIDBBackingStore::iterateCursor&quot;);
570 
571     if (!m_transactions.contains(transactionIdentifier))
572         return IDBError { UnknownError, &quot;No backing store transaction found in which to iterate cursor&quot;_s };
573 
574     auto* cursor = MemoryCursor::cursorForIdentifier(cursorIdentifier);
575     if (!cursor)
576         return IDBError { UnknownError, &quot;No backing store cursor found in which to iterate cursor&quot;_s };
577 
578     cursor-&gt;iterate(data.keyData, data.primaryKeyData, data.count, outData);
579 
580     return IDBError { };
581 }
582 
583 void MemoryIDBBackingStore::registerObjectStore(Ref&lt;MemoryObjectStore&gt;&amp;&amp; objectStore)
584 {
585     ASSERT(!m_objectStoresByIdentifier.contains(objectStore-&gt;info().identifier()));
586     ASSERT(!m_objectStoresByName.contains(objectStore-&gt;info().name()));
587 
588     auto identifier = objectStore-&gt;info().identifier();
589     m_objectStoresByName.set(objectStore-&gt;info().name(), &amp;objectStore.get());
590     m_objectStoresByIdentifier.set(identifier, WTFMove(objectStore));
591 }
592 
593 void MemoryIDBBackingStore::unregisterObjectStore(MemoryObjectStore&amp; objectStore)
594 {
595     ASSERT(m_objectStoresByIdentifier.contains(objectStore.info().identifier()));
596     ASSERT(m_objectStoresByName.contains(objectStore.info().name()));
597 
598     m_objectStoresByName.remove(objectStore.info().name());
599     m_objectStoresByIdentifier.remove(objectStore.info().identifier());
600 }
601 
602 RefPtr&lt;MemoryObjectStore&gt; MemoryIDBBackingStore::takeObjectStoreByIdentifier(uint64_t identifier)
603 {
604     auto objectStoreByIdentifier = m_objectStoresByIdentifier.take(identifier);
605     if (!objectStoreByIdentifier)
606         return nullptr;
607 
608     auto objectStore = m_objectStoresByName.take(objectStoreByIdentifier-&gt;info().name());
609     ASSERT_UNUSED(objectStore, objectStore);
610 
611     return objectStoreByIdentifier;
612 }
613 
614 IDBObjectStoreInfo* MemoryIDBBackingStore::infoForObjectStore(uint64_t objectStoreIdentifier)
615 {
616     ASSERT(m_databaseInfo);
617     return m_databaseInfo-&gt;infoForExistingObjectStore(objectStoreIdentifier);
618 }
619 
620 void MemoryIDBBackingStore::deleteBackingStore()
621 {
622     // The in-memory IDB backing store doesn&#39;t need to do any cleanup when it is deleted.
623 }
624 
<a name="9" id="anc9"></a>





625 void MemoryIDBBackingStore::close()
626 {
627 }
628 
629 } // namespace IDBServer
630 } // namespace WebCore
631 
632 #endif // ENABLE(INDEXED_DATABASE)
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
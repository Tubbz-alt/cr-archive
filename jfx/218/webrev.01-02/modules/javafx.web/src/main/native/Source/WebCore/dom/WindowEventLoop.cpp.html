<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/dom/WindowEventLoop.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WindowEventLoop.h&quot;
 28 
 29 #include &quot;CommonVM.h&quot;
 30 #include &quot;CustomElementReactionQueue.h&quot;
 31 #include &quot;Document.h&quot;
 32 #include &quot;HTMLSlotElement.h&quot;
 33 #include &quot;Microtasks.h&quot;
 34 #include &quot;MutationObserver.h&quot;
 35 #include &quot;SecurityOrigin.h&quot;
 36 
 37 namespace WebCore {
 38 
 39 static HashMap&lt;String, WindowEventLoop*&gt;&amp; windowEventLoopMap()
 40 {
 41     RELEASE_ASSERT(isMainThread());
 42     static NeverDestroyed&lt;HashMap&lt;String, WindowEventLoop*&gt;&gt; map;
 43     return map.get();
 44 }
 45 
 46 static String agentClusterKeyOrNullIfUnique(const SecurityOrigin&amp; origin)
 47 {
 48     auto computeKey = [&amp;] {
 49         // https://html.spec.whatwg.org/multipage/webappapis.html#obtain-agent-cluster-key
 50         if (origin.isUnique())
 51             return origin.toString();
 52         RegistrableDomain registrableDomain { origin.data() };
 53         if (registrableDomain.isEmpty())
 54             return origin.toString();
 55         return makeString(origin.protocol(), &quot;://&quot;, registrableDomain.string());
 56     };
 57     auto key = computeKey();
 58     if (key.isEmpty() || key == &quot;null&quot;_s)
 59         return { };
 60     return key;
 61 }
 62 
 63 Ref&lt;WindowEventLoop&gt; WindowEventLoop::eventLoopForSecurityOrigin(const SecurityOrigin&amp; origin)
 64 {
 65     auto key = agentClusterKeyOrNullIfUnique(origin);
 66     if (key.isNull())
 67         return create({ });
 68 
 69     auto addResult = windowEventLoopMap().add(key, nullptr);
 70     if (UNLIKELY(addResult.isNewEntry)) {
 71         auto newEventLoop = create(key);
 72         addResult.iterator-&gt;value = newEventLoop.ptr();
 73         return newEventLoop;
 74     }
 75     return *addResult.iterator-&gt;value;
 76 }
 77 
 78 inline Ref&lt;WindowEventLoop&gt; WindowEventLoop::create(const String&amp; agentClusterKey)
 79 {
 80     return adoptRef(*new WindowEventLoop(agentClusterKey));
 81 }
 82 
 83 inline WindowEventLoop::WindowEventLoop(const String&amp; agentClusterKey)
 84     : m_agentClusterKey(agentClusterKey)
 85     , m_timer(*this, &amp;WindowEventLoop::didReachTimeToRun)
 86     , m_perpetualTaskGroupForSimilarOriginWindowAgents(*this)
 87 {
 88 }
 89 
 90 WindowEventLoop::~WindowEventLoop()
 91 {
 92     if (m_agentClusterKey.isNull())
 93         return;
 94     auto didRemove = windowEventLoopMap().remove(m_agentClusterKey);
 95     RELEASE_ASSERT(didRemove);
 96 }
 97 
 98 void WindowEventLoop::scheduleToRun()
 99 {
100     m_timer.startOneShot(0_s);
101 }
102 
103 bool WindowEventLoop::isContextThread() const
104 {
105     return isMainThread();
106 }
107 
108 MicrotaskQueue&amp; WindowEventLoop::microtaskQueue()
109 {
110     if (!m_microtaskQueue)
111         m_microtaskQueue = makeUnique&lt;MicrotaskQueue&gt;(commonVM());
112     return *m_microtaskQueue;
113 }
114 
115 void WindowEventLoop::didReachTimeToRun()
116 {
117     auto protectedThis = makeRef(*this); // Executing tasks may remove the last reference to this WindowEventLoop.
118     run();
119 }
120 
121 void WindowEventLoop::queueMutationObserverCompoundMicrotask()
122 {
123     if (m_mutationObserverCompoundMicrotaskQueuedFlag)
124         return;
125     m_mutationObserverCompoundMicrotaskQueuedFlag = true;
126     m_perpetualTaskGroupForSimilarOriginWindowAgents.queueMicrotask([this] {
127         // We can&#39;t make a Ref to WindowEventLoop in the lambda capture as that would result in a reference cycle &amp; leak.
128         auto protectedThis = makeRef(*this);
129         m_mutationObserverCompoundMicrotaskQueuedFlag = false;
130 
131         // FIXME: This check doesn&#39;t exist in the spec.
132         if (m_deliveringMutationRecords)
133             return;
134         m_deliveringMutationRecords = true;
135         MutationObserver::notifyMutationObservers(*this);
136         m_deliveringMutationRecords = false;
137     });
138 }
139 
140 CustomElementQueue&amp; WindowEventLoop::backupElementQueue()
141 {
142     if (!m_processingBackupElementQueue) {
143         m_processingBackupElementQueue = true;
144         m_perpetualTaskGroupForSimilarOriginWindowAgents.queueMicrotask([this] {
145             // We can&#39;t make a Ref to WindowEventLoop in the lambda capture as that would result in a reference cycle &amp; leak.
146             auto protectedThis = makeRef(*this);
147             m_processingBackupElementQueue = false;
148             ASSERT(m_customElementQueue);
149             CustomElementReactionQueue::processBackupQueue(*m_customElementQueue);
150         });
151     }
152     if (!m_customElementQueue)
153         m_customElementQueue = makeUnique&lt;CustomElementQueue&gt;();
154     return *m_customElementQueue;
155 }
156 
157 } // namespace WebCore
    </pre>
  </body>
</html>
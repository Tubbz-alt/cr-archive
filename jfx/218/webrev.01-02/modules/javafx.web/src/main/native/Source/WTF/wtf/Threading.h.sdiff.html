<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/Threading.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Threading.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ThreadingPrimitives.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/Threading.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 35 #include &lt;wtf/Atomics.h&gt;
 36 #include &lt;wtf/Expected.h&gt;
 37 #include &lt;wtf/FastTLS.h&gt;
 38 #include &lt;wtf/Function.h&gt;
 39 #include &lt;wtf/HashMap.h&gt;
 40 #include &lt;wtf/HashSet.h&gt;
 41 #include &lt;wtf/PlatformRegisters.h&gt;
 42 #include &lt;wtf/Ref.h&gt;
 43 #include &lt;wtf/RefPtr.h&gt;
 44 #include &lt;wtf/StackBounds.h&gt;
 45 #include &lt;wtf/StackStats.h&gt;
 46 #include &lt;wtf/ThreadSafeRefCounted.h&gt;
 47 #include &lt;wtf/Vector.h&gt;
 48 #include &lt;wtf/WordLock.h&gt;
 49 #include &lt;wtf/text/AtomStringTable.h&gt;
 50 
 51 #if USE(PTHREADS) &amp;&amp; !OS(DARWIN)
 52 #include &lt;signal.h&gt;
 53 #endif
 54 




 55 namespace WTF {
 56 
 57 class AbstractLocker;
 58 class ThreadMessageData;
 59 
 60 enum class ThreadGroupAddResult;
 61 
 62 class ThreadGroup;
 63 class PrintStream;
 64 
 65 // This function can be called from any threads.
 66 WTF_EXPORT_PRIVATE void initializeThreading();
 67 
 68 #if USE(PTHREADS)
 69 
 70 // We use SIGUSR1 to suspend and resume machine threads in JavaScriptCore.
 71 constexpr const int SigThreadSuspendResume = SIGUSR1;
 72 
 73 #endif
 74 
</pre>
<hr />
<pre>
 89     // The thread name must be a literal since on some platforms it&#39;s passed in to the thread.
 90     WTF_EXPORT_PRIVATE static Ref&lt;Thread&gt; create(const char* threadName, Function&lt;void()&gt;&amp;&amp;);
 91 
 92     // Returns Thread object.
 93     static Thread&amp; current();
 94 
 95     // Set of all WTF::Thread created threads.
 96     WTF_EXPORT_PRIVATE static HashSet&lt;Thread*&gt;&amp; allThreads(const LockHolder&amp;);
 97     WTF_EXPORT_PRIVATE static Lock&amp; allThreadsMutex();
 98 
 99     WTF_EXPORT_PRIVATE unsigned numberOfThreadGroups();
100 
101 #if OS(WINDOWS)
102     // Returns ThreadIdentifier directly. It is useful if the user only cares about identity
103     // of threads. At that time, users should know that holding this ThreadIdentifier does not ensure
104     // that the thread information is alive. While Thread::current() is not safe if it is called
105     // from the destructor of the other TLS data, currentID() always returns meaningful thread ID.
106     WTF_EXPORT_PRIVATE static ThreadIdentifier currentID();
107 
108     ThreadIdentifier id() const { return m_id; }



















109 #endif
110 
111     WTF_EXPORT_PRIVATE void changePriority(int);
112     WTF_EXPORT_PRIVATE int waitForCompletion();
113     WTF_EXPORT_PRIVATE void detach();
114 
115 #if OS(DARWIN)
116     using PlatformSuspendError = kern_return_t;
117 #elif USE(PTHREADS)
118     using PlatformSuspendError = int;
119 #elif OS(WINDOWS)
120     using PlatformSuspendError = DWORD;
121 #endif
122 
123     WTF_EXPORT_PRIVATE Expected&lt;void, PlatformSuspendError&gt; suspend();
124     WTF_EXPORT_PRIVATE void resume();
125     WTF_EXPORT_PRIVATE size_t getRegisters(PlatformRegisters&amp;);
126 
127 #if USE(PTHREADS)
128     WTF_EXPORT_PRIVATE bool signal(int signalNumber);
129 #endif
130 
131     // Mark the current thread as requiring UI responsiveness.
132     // relativePriority is a value in the range [-15, 0] where a lower value indicates a lower priority.
133     WTF_EXPORT_PRIVATE static void setCurrentThreadIsUserInteractive(int relativePriority = 0);
134     WTF_EXPORT_PRIVATE static void setCurrentThreadIsUserInitiated(int relativePriority = 0);
135 
136 #if HAVE(QOS_CLASSES)
137     WTF_EXPORT_PRIVATE static void setGlobalMaxQOSClass(qos_class_t);
138     WTF_EXPORT_PRIVATE static qos_class_t adjustedQOSClass(qos_class_t);
139 #endif
140 
141     // Called in the thread during initialization.
142     // Helpful for platforms where the thread name must be set from within the thread.
143     static void initializeCurrentThreadInternal(const char* threadName);
144     static void initializeCurrentThreadEvenIfNonWTFCreated();
145 
<span class="line-removed">146     WTF_EXPORT_PRIVATE static const unsigned lockSpinLimit;</span>
147     WTF_EXPORT_PRIVATE static void yield();
148 
149     WTF_EXPORT_PRIVATE static bool exchangeIsCompilationThread(bool newValue);
150     WTF_EXPORT_PRIVATE static void registerGCThread(GCThreadType);
151     WTF_EXPORT_PRIVATE static bool mayBeGCThread();
152 
153     WTF_EXPORT_PRIVATE void dump(PrintStream&amp; out) const;
154 
155     static void initializePlatformThreading();
156 
157     const StackBounds&amp; stack() const
158     {
159         return m_stack;
160     }
161 
162     AtomStringTable* atomStringTable()
163     {
164         return m_currentAtomStringTable;
165     }
166 
</pre>
<hr />
<pre>
234         // Somebody waited on this thread to exit and this thread finally exited. This state is here because there can be a
235         // period of time between when the thread exits (which causes pthread_join to return and the remainder of waitOnThreadCompletion to run)
236         // and when threadDidExit is called. We need threadDidExit to take charge and delete the thread data since there&#39;s
237         // nobody else to pick up the slack in this case (since waitOnThreadCompletion has already returned).
238         Joined,
239 
240         // The thread has been detached and can no longer be joined on. At this point, the thread must take care of cleaning up after itself.
241         Detached,
242     };
243 
244     JoinableState joinableState() const { return m_joinableState; }
245     void didBecomeDetached() { m_joinableState = Detached; }
246     void didExit();
247     void didJoin() { m_joinableState = Joined; }
248     bool hasExited() const { return m_didExit; }
249 
250     // These functions are only called from ThreadGroup.
251     ThreadGroupAddResult addToThreadGroup(const AbstractLocker&amp; threadGroupLocker, ThreadGroup&amp;);
252     void removeFromThreadGroup(const AbstractLocker&amp; threadGroupLocker, ThreadGroup&amp;);
253 
<span class="line-modified">254     // The Thread instance is ref&#39;ed and held in thread-specific storage. It will be deref&#39;ed by destructTLS at thread destruction time.</span>
<span class="line-modified">255     // For pthread, it employs pthreads-specific 2-pass destruction to reliably remove Thread.</span>
<span class="line-removed">256     // For Windows, we use thread_local to defer thread TLS destruction. It assumes regular ThreadSpecific</span>
<span class="line-removed">257     // types don&#39;t use multiple-pass destruction.</span>
258 
<span class="line-modified">259 #if !HAVE(FAST_TLS)</span>
260     static WTF_EXPORT_PRIVATE ThreadSpecificKey s_key;
261     // One time initialization for this class as a whole.
262     // This method must be called before initializeTLS() and it is not thread-safe.
263     static void initializeTLSKey();
264 #endif






265 
266     // Creates and puts an instance of Thread into thread-specific storage.
267     static Thread&amp; initializeTLS(Ref&lt;Thread&gt;&amp;&amp;);
268     WTF_EXPORT_PRIVATE static Thread&amp; initializeCurrentTLS();
269 
270     // Returns nullptr if thread-specific storage was not initialized.
<span class="line-removed">271     static Thread* currentMayBeNull();</span>
<span class="line-removed">272 </span>
273 #if OS(WINDOWS)
<span class="line-modified">274     WTF_EXPORT_PRIVATE static Thread* currentDying();</span>
<span class="line-modified">275     static RefPtr&lt;Thread&gt; get(ThreadIdentifier);</span>

276 #endif
277 
<span class="line-removed">278     // This thread-specific destructor is called 2 times when thread terminates:</span>
<span class="line-removed">279     // - first, when all the other thread-specific destructors are called, it simply remembers it was &#39;destroyed once&#39;</span>
<span class="line-removed">280     // and (1) re-sets itself into the thread-specific slot or (2) constructs thread local value to call it again later.</span>
<span class="line-removed">281     // - second, after all thread-specific destructors were invoked, it gets called again - this time, we remove the</span>
<span class="line-removed">282     // Thread from the threadMap, completing the cleanup.</span>
<span class="line-removed">283     static void THREAD_SPECIFIC_CALL destructTLS(void* data);</span>
<span class="line-removed">284 </span>
285     JoinableState m_joinableState { Joinable };
286     bool m_isShuttingDown : 1;
287     bool m_didExit : 1;
288     bool m_isDestroyedOnce : 1;
289     bool m_isCompilationThread: 1;
290     unsigned m_gcThreadType : 2;
291 
292     // Lock &amp; ParkingLot rely on ThreadSpecific. But Thread object can be destroyed even after ThreadSpecific things are destroyed.
293     // Use WordLock since WordLock does not depend on ThreadSpecific and this &quot;Thread&quot;.
294     WordLock m_mutex;
295     StackBounds m_stack { StackBounds::emptyBounds() };
296     HashMap&lt;ThreadGroup*, std::weak_ptr&lt;ThreadGroup&gt;&gt; m_threadGroupMap;
297     PlatformThreadHandle m_handle;
298 #if OS(WINDOWS)
299     ThreadIdentifier m_id { 0 };
300 #elif OS(DARWIN)
301     mach_port_t m_platformThread { MACH_PORT_NULL };
302 #elif USE(PTHREADS)
303     PlatformRegisters* m_platformRegisters { nullptr };
304     unsigned m_suspendCount { 0 };
305 #endif
306 




307     AtomStringTable* m_currentAtomStringTable { nullptr };
308     AtomStringTable m_defaultAtomStringTable;
309 
310 #if ENABLE(STACK_STATS)
311     StackStats::PerThreadStats m_stackStats;
312 #endif
313     void* m_savedStackPointerAtVMEntry { nullptr };
314     void* m_savedLastStackTop;
315 public:
316     void* m_apiData { nullptr };
317 };
318 
319 inline Thread::Thread()
320     : m_isShuttingDown(false)
321     , m_didExit(false)
322     , m_isDestroyedOnce(false)
323     , m_isCompilationThread(false)
324     , m_gcThreadType(static_cast&lt;unsigned&gt;(GCThreadType::None))
325 {
326 }
327 

328 inline Thread* Thread::currentMayBeNull()
329 {
330 #if !HAVE(FAST_TLS)
331     ASSERT(s_key != InvalidThreadSpecificKey);
332     return static_cast&lt;Thread*&gt;(threadSpecificGet(s_key));
333 #else
334     return static_cast&lt;Thread*&gt;(_pthread_getspecific_direct(WTF_THREAD_DATA_KEY));
335 #endif
336 }

337 
338 inline Thread&amp; Thread::current()
339 {
340     // WRT WebCore:
341     //    Thread::current() is used on main thread before it could possibly be used
342     //    on secondary ones, so there is no need for synchronization here.
343     // WRT JavaScriptCore:
344     //    Thread::initializeTLSKey() is initially called from initializeThreading(), ensuring
345     //    this is initially called in a std::call_once locked context.
<span class="line-modified">346 #if !HAVE(FAST_TLS)</span>
347     if (UNLIKELY(Thread::s_key == InvalidThreadSpecificKey))
348         WTF::initializeThreading();
349 #endif
350     if (auto* thread = currentMayBeNull())
351         return *thread;
<span class="line-removed">352 #if OS(WINDOWS)</span>
<span class="line-removed">353     if (auto* thread = currentDying())</span>
<span class="line-removed">354         return *thread;</span>
<span class="line-removed">355 #endif</span>
356     return initializeCurrentTLS();
357 }
358 
359 } // namespace WTF
360 
361 using WTF::Thread;
362 using WTF::GCThreadType;
</pre>
</td>
<td>
<hr />
<pre>
 35 #include &lt;wtf/Atomics.h&gt;
 36 #include &lt;wtf/Expected.h&gt;
 37 #include &lt;wtf/FastTLS.h&gt;
 38 #include &lt;wtf/Function.h&gt;
 39 #include &lt;wtf/HashMap.h&gt;
 40 #include &lt;wtf/HashSet.h&gt;
 41 #include &lt;wtf/PlatformRegisters.h&gt;
 42 #include &lt;wtf/Ref.h&gt;
 43 #include &lt;wtf/RefPtr.h&gt;
 44 #include &lt;wtf/StackBounds.h&gt;
 45 #include &lt;wtf/StackStats.h&gt;
 46 #include &lt;wtf/ThreadSafeRefCounted.h&gt;
 47 #include &lt;wtf/Vector.h&gt;
 48 #include &lt;wtf/WordLock.h&gt;
 49 #include &lt;wtf/text/AtomStringTable.h&gt;
 50 
 51 #if USE(PTHREADS) &amp;&amp; !OS(DARWIN)
 52 #include &lt;signal.h&gt;
 53 #endif
 54 
<span class="line-added"> 55 #if OS(WINDOWS)</span>
<span class="line-added"> 56 #include &lt;array&gt;</span>
<span class="line-added"> 57 #endif</span>
<span class="line-added"> 58 </span>
 59 namespace WTF {
 60 
 61 class AbstractLocker;
 62 class ThreadMessageData;
 63 
 64 enum class ThreadGroupAddResult;
 65 
 66 class ThreadGroup;
 67 class PrintStream;
 68 
 69 // This function can be called from any threads.
 70 WTF_EXPORT_PRIVATE void initializeThreading();
 71 
 72 #if USE(PTHREADS)
 73 
 74 // We use SIGUSR1 to suspend and resume machine threads in JavaScriptCore.
 75 constexpr const int SigThreadSuspendResume = SIGUSR1;
 76 
 77 #endif
 78 
</pre>
<hr />
<pre>
 93     // The thread name must be a literal since on some platforms it&#39;s passed in to the thread.
 94     WTF_EXPORT_PRIVATE static Ref&lt;Thread&gt; create(const char* threadName, Function&lt;void()&gt;&amp;&amp;);
 95 
 96     // Returns Thread object.
 97     static Thread&amp; current();
 98 
 99     // Set of all WTF::Thread created threads.
100     WTF_EXPORT_PRIVATE static HashSet&lt;Thread*&gt;&amp; allThreads(const LockHolder&amp;);
101     WTF_EXPORT_PRIVATE static Lock&amp; allThreadsMutex();
102 
103     WTF_EXPORT_PRIVATE unsigned numberOfThreadGroups();
104 
105 #if OS(WINDOWS)
106     // Returns ThreadIdentifier directly. It is useful if the user only cares about identity
107     // of threads. At that time, users should know that holding this ThreadIdentifier does not ensure
108     // that the thread information is alive. While Thread::current() is not safe if it is called
109     // from the destructor of the other TLS data, currentID() always returns meaningful thread ID.
110     WTF_EXPORT_PRIVATE static ThreadIdentifier currentID();
111 
112     ThreadIdentifier id() const { return m_id; }
<span class="line-added">113 </span>
<span class="line-added">114     class SpecificStorage {</span>
<span class="line-added">115     public:</span>
<span class="line-added">116         using DestroyFunction = void (*)(void*);</span>
<span class="line-added">117         WTF_EXPORT_PRIVATE static bool allocateKey(int&amp; key, DestroyFunction);</span>
<span class="line-added">118         WTF_EXPORT_PRIVATE void* get(int key);</span>
<span class="line-added">119         WTF_EXPORT_PRIVATE void set(int key, void* value);</span>
<span class="line-added">120         void destroySlots();</span>
<span class="line-added">121 </span>
<span class="line-added">122     private:</span>
<span class="line-added">123         static constexpr size_t s_maxKeys = 32;</span>
<span class="line-added">124         static Atomic&lt;int&gt; s_numberOfKeys;</span>
<span class="line-added">125         static std::array&lt;Atomic&lt;DestroyFunction&gt;, s_maxKeys&gt; s_destroyFunctions;</span>
<span class="line-added">126         std::array&lt;void*, s_maxKeys&gt; m_slots { };</span>
<span class="line-added">127     };</span>
<span class="line-added">128 </span>
<span class="line-added">129     SpecificStorage&amp; specificStorage() { return m_specificStorage; };</span>
<span class="line-added">130 </span>
<span class="line-added">131     class ThreadHolder;</span>
132 #endif
133 
134     WTF_EXPORT_PRIVATE void changePriority(int);
135     WTF_EXPORT_PRIVATE int waitForCompletion();
136     WTF_EXPORT_PRIVATE void detach();
137 
138 #if OS(DARWIN)
139     using PlatformSuspendError = kern_return_t;
140 #elif USE(PTHREADS)
141     using PlatformSuspendError = int;
142 #elif OS(WINDOWS)
143     using PlatformSuspendError = DWORD;
144 #endif
145 
146     WTF_EXPORT_PRIVATE Expected&lt;void, PlatformSuspendError&gt; suspend();
147     WTF_EXPORT_PRIVATE void resume();
148     WTF_EXPORT_PRIVATE size_t getRegisters(PlatformRegisters&amp;);
149 
150 #if USE(PTHREADS)
151     WTF_EXPORT_PRIVATE bool signal(int signalNumber);
152 #endif
153 
154     // Mark the current thread as requiring UI responsiveness.
155     // relativePriority is a value in the range [-15, 0] where a lower value indicates a lower priority.
156     WTF_EXPORT_PRIVATE static void setCurrentThreadIsUserInteractive(int relativePriority = 0);
157     WTF_EXPORT_PRIVATE static void setCurrentThreadIsUserInitiated(int relativePriority = 0);
158 
159 #if HAVE(QOS_CLASSES)
160     WTF_EXPORT_PRIVATE static void setGlobalMaxQOSClass(qos_class_t);
161     WTF_EXPORT_PRIVATE static qos_class_t adjustedQOSClass(qos_class_t);
162 #endif
163 
164     // Called in the thread during initialization.
165     // Helpful for platforms where the thread name must be set from within the thread.
166     static void initializeCurrentThreadInternal(const char* threadName);
167     static void initializeCurrentThreadEvenIfNonWTFCreated();
168 

169     WTF_EXPORT_PRIVATE static void yield();
170 
171     WTF_EXPORT_PRIVATE static bool exchangeIsCompilationThread(bool newValue);
172     WTF_EXPORT_PRIVATE static void registerGCThread(GCThreadType);
173     WTF_EXPORT_PRIVATE static bool mayBeGCThread();
174 
175     WTF_EXPORT_PRIVATE void dump(PrintStream&amp; out) const;
176 
177     static void initializePlatformThreading();
178 
179     const StackBounds&amp; stack() const
180     {
181         return m_stack;
182     }
183 
184     AtomStringTable* atomStringTable()
185     {
186         return m_currentAtomStringTable;
187     }
188 
</pre>
<hr />
<pre>
256         // Somebody waited on this thread to exit and this thread finally exited. This state is here because there can be a
257         // period of time between when the thread exits (which causes pthread_join to return and the remainder of waitOnThreadCompletion to run)
258         // and when threadDidExit is called. We need threadDidExit to take charge and delete the thread data since there&#39;s
259         // nobody else to pick up the slack in this case (since waitOnThreadCompletion has already returned).
260         Joined,
261 
262         // The thread has been detached and can no longer be joined on. At this point, the thread must take care of cleaning up after itself.
263         Detached,
264     };
265 
266     JoinableState joinableState() const { return m_joinableState; }
267     void didBecomeDetached() { m_joinableState = Detached; }
268     void didExit();
269     void didJoin() { m_joinableState = Joined; }
270     bool hasExited() const { return m_didExit; }
271 
272     // These functions are only called from ThreadGroup.
273     ThreadGroupAddResult addToThreadGroup(const AbstractLocker&amp; threadGroupLocker, ThreadGroup&amp;);
274     void removeFromThreadGroup(const AbstractLocker&amp; threadGroupLocker, ThreadGroup&amp;);
275 
<span class="line-modified">276     // For pthread, the Thread instance is ref&#39;ed and held in thread-specific storage. It will be deref&#39;ed by destructTLS at thread destruction time.</span>
<span class="line-modified">277     // It employs pthreads-specific 2-pass destruction to reliably remove Thread.</span>


278 
<span class="line-modified">279 #if !HAVE(FAST_TLS) &amp;&amp; !OS(WINDOWS)</span>
280     static WTF_EXPORT_PRIVATE ThreadSpecificKey s_key;
281     // One time initialization for this class as a whole.
282     // This method must be called before initializeTLS() and it is not thread-safe.
283     static void initializeTLSKey();
284 #endif
<span class="line-added">285     // This thread-specific destructor is called 2 times when thread terminates:</span>
<span class="line-added">286     // - first, when all the other thread-specific destructors are called, it simply remembers it was &#39;destroyed once&#39;</span>
<span class="line-added">287     // and (1) re-sets itself into the thread-specific slot or (2) constructs thread local value to call it again later.</span>
<span class="line-added">288     // - second, after all thread-specific destructors were invoked, it gets called again - this time, we deref the</span>
<span class="line-added">289     // Thread in the TLS, completing the cleanup.</span>
<span class="line-added">290     static void destructTLS(void* data);</span>
291 
292     // Creates and puts an instance of Thread into thread-specific storage.
293     static Thread&amp; initializeTLS(Ref&lt;Thread&gt;&amp;&amp;);
294     WTF_EXPORT_PRIVATE static Thread&amp; initializeCurrentTLS();
295 
296     // Returns nullptr if thread-specific storage was not initialized.


297 #if OS(WINDOWS)
<span class="line-modified">298     WTF_EXPORT_PRIVATE static Thread* currentMayBeNull();</span>
<span class="line-modified">299 #else</span>
<span class="line-added">300     static Thread* currentMayBeNull();</span>
301 #endif
302 







303     JoinableState m_joinableState { Joinable };
304     bool m_isShuttingDown : 1;
305     bool m_didExit : 1;
306     bool m_isDestroyedOnce : 1;
307     bool m_isCompilationThread: 1;
308     unsigned m_gcThreadType : 2;
309 
310     // Lock &amp; ParkingLot rely on ThreadSpecific. But Thread object can be destroyed even after ThreadSpecific things are destroyed.
311     // Use WordLock since WordLock does not depend on ThreadSpecific and this &quot;Thread&quot;.
312     WordLock m_mutex;
313     StackBounds m_stack { StackBounds::emptyBounds() };
314     HashMap&lt;ThreadGroup*, std::weak_ptr&lt;ThreadGroup&gt;&gt; m_threadGroupMap;
315     PlatformThreadHandle m_handle;
316 #if OS(WINDOWS)
317     ThreadIdentifier m_id { 0 };
318 #elif OS(DARWIN)
319     mach_port_t m_platformThread { MACH_PORT_NULL };
320 #elif USE(PTHREADS)
321     PlatformRegisters* m_platformRegisters { nullptr };
322     unsigned m_suspendCount { 0 };
323 #endif
324 
<span class="line-added">325 #if OS(WINDOWS)</span>
<span class="line-added">326     SpecificStorage m_specificStorage;</span>
<span class="line-added">327 #endif</span>
<span class="line-added">328 </span>
329     AtomStringTable* m_currentAtomStringTable { nullptr };
330     AtomStringTable m_defaultAtomStringTable;
331 
332 #if ENABLE(STACK_STATS)
333     StackStats::PerThreadStats m_stackStats;
334 #endif
335     void* m_savedStackPointerAtVMEntry { nullptr };
336     void* m_savedLastStackTop;
337 public:
338     void* m_apiData { nullptr };
339 };
340 
341 inline Thread::Thread()
342     : m_isShuttingDown(false)
343     , m_didExit(false)
344     , m_isDestroyedOnce(false)
345     , m_isCompilationThread(false)
346     , m_gcThreadType(static_cast&lt;unsigned&gt;(GCThreadType::None))
347 {
348 }
349 
<span class="line-added">350 #if !OS(WINDOWS)</span>
351 inline Thread* Thread::currentMayBeNull()
352 {
353 #if !HAVE(FAST_TLS)
354     ASSERT(s_key != InvalidThreadSpecificKey);
355     return static_cast&lt;Thread*&gt;(threadSpecificGet(s_key));
356 #else
357     return static_cast&lt;Thread*&gt;(_pthread_getspecific_direct(WTF_THREAD_DATA_KEY));
358 #endif
359 }
<span class="line-added">360 #endif</span>
361 
362 inline Thread&amp; Thread::current()
363 {
364     // WRT WebCore:
365     //    Thread::current() is used on main thread before it could possibly be used
366     //    on secondary ones, so there is no need for synchronization here.
367     // WRT JavaScriptCore:
368     //    Thread::initializeTLSKey() is initially called from initializeThreading(), ensuring
369     //    this is initially called in a std::call_once locked context.
<span class="line-modified">370 #if !HAVE(FAST_TLS) &amp;&amp; !OS(WINDOWS)</span>
371     if (UNLIKELY(Thread::s_key == InvalidThreadSpecificKey))
372         WTF::initializeThreading();
373 #endif
374     if (auto* thread = currentMayBeNull())
375         return *thread;




376     return initializeCurrentTLS();
377 }
378 
379 } // namespace WTF
380 
381 using WTF::Thread;
382 using WTF::GCThreadType;
</pre>
</td>
</tr>
</table>
<center><a href="Threading.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ThreadingPrimitives.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCPeerConnectionBackend.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCPeerConnectionBackend.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCPeerConnectionBackend.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCPeerConnectionBackend.cpp
@@ -43,11 +43,10 @@
 #include "RTCSessionDescription.h"
 #include "RealtimeIncomingAudioSource.h"
 #include "RealtimeIncomingVideoSource.h"
 #include "RealtimeOutgoingAudioSource.h"
 #include "RealtimeOutgoingVideoSource.h"
-#include "RuntimeEnabledFeatures.h"
 #include "Settings.h"
 
 namespace WebCore {
 
 static std::unique_ptr<PeerConnectionBackend> createLibWebRTCPeerConnectionBackend(RTCPeerConnection& peerConnection)
@@ -88,10 +87,20 @@
 {
 }
 
 LibWebRTCPeerConnectionBackend::~LibWebRTCPeerConnectionBackend() = default;
 
+void LibWebRTCPeerConnectionBackend::suspend()
+{
+    m_endpoint->suspend();
+}
+
+void LibWebRTCPeerConnectionBackend::resume()
+{
+    m_endpoint->resume();
+}
+
 static inline webrtc::PeerConnectionInterface::BundlePolicy bundlePolicyfromConfiguration(const MediaEndpointConfiguration& configuration)
 {
     switch (configuration.bundlePolicy) {
     case RTCBundlePolicy::MaxCompat:
         return webrtc::PeerConnectionInterface::kBundlePolicyMaxCompat;
@@ -240,10 +249,15 @@
         return;
     }
     m_endpoint->doCreateAnswer();
 }
 
+void LibWebRTCPeerConnectionBackend::close()
+{
+    m_endpoint->close();
+}
+
 void LibWebRTCPeerConnectionBackend::doStop()
 {
     m_endpoint->stop();
     m_pendingReceivers.clear();
 }
@@ -397,66 +411,32 @@
     return nullptr;
 }
 
 ExceptionOr<Ref<RTCRtpSender>> LibWebRTCPeerConnectionBackend::addTrack(MediaStreamTrack& track, Vector<String>&& mediaStreamIds)
 {
-    if (RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled()) {
-        auto senderBackend = makeUnique<LibWebRTCRtpSenderBackend>(*this, nullptr);
-        if (!m_endpoint->addTrack(*senderBackend, track, mediaStreamIds))
-            return Exception { TypeError, "Unable to add track"_s };
-
-        if (auto sender = findExistingSender(m_peerConnection.currentTransceivers(), *senderBackend)) {
-            backendFromRTPSender(*sender).takeSource(*senderBackend);
-            sender->setTrack(makeRef(track));
-            sender->setMediaStreamIds(WTFMove(mediaStreamIds));
-            return sender.releaseNonNull();
-        }
-
-        auto transceiverBackend = m_endpoint->transceiverBackendFromSender(*senderBackend);
-
-        auto sender = RTCRtpSender::create(*this, makeRef(track), WTFMove(mediaStreamIds), WTFMove(senderBackend));
-        auto receiver = createReceiverForSource(createEmptySource(track.kind(), createCanonicalUUIDString()), transceiverBackend->createReceiverBackend());
-        auto transceiver = RTCRtpTransceiver::create(sender.copyRef(), WTFMove(receiver), WTFMove(transceiverBackend));
-        m_peerConnection.addInternalTransceiver(WTFMove(transceiver));
-        return sender;
-    }
-
-    RTCRtpSender* sender = nullptr;
-    // Reuse an existing sender with the same track kind if it has never been used to send before.
-    for (auto& transceiver : m_peerConnection.currentTransceivers()) {
-        auto& existingSender = transceiver->sender();
-        if (!existingSender.isStopped() && existingSender.trackKind() == track.kind() && existingSender.trackId().isNull() && !transceiver->hasSendingDirection()) {
-            existingSender.setTrack(makeRef(track));
-            existingSender.setMediaStreamIds(WTFMove(mediaStreamIds));
-            transceiver->enableSendingDirection();
-            sender = &existingSender;
-
-            break;
-        }
-    }
-
-    if (!sender) {
-        const String& trackKind = track.kind();
-        String trackId = createCanonicalUUIDString();
-
-        auto senderBackend = makeUnique<LibWebRTCRtpSenderBackend>(*this, nullptr);
-        auto newSender = RTCRtpSender::create(*this, makeRef(track), Vector<String> { mediaStreamIds }, WTFMove(senderBackend));
-        auto receiver = createReceiver(trackKind, trackId);
-        auto transceiver = RTCRtpTransceiver::create(WTFMove(newSender), WTFMove(receiver), nullptr);
+    auto senderBackend = makeUnique<LibWebRTCRtpSenderBackend>(*this, nullptr);
+    if (!m_endpoint->addTrack(*senderBackend, track, mediaStreamIds))
+        return Exception { TypeError, "Unable to add track"_s };
 
-        sender = &transceiver->sender();
-        m_peerConnection.addInternalTransceiver(WTFMove(transceiver));
+    if (auto sender = findExistingSender(m_peerConnection.currentTransceivers(), *senderBackend)) {
+        backendFromRTPSender(*sender).takeSource(*senderBackend);
+        sender->setTrack(makeRef(track));
+        sender->setMediaStreamIds(WTFMove(mediaStreamIds));
+        return sender.releaseNonNull();
     }
 
-    if (!m_endpoint->addTrack(backendFromRTPSender(*sender), track, mediaStreamIds))
-        return Exception { TypeError, "Unable to add track"_s };
+    auto transceiverBackend = m_endpoint->transceiverBackendFromSender(*senderBackend);
 
-    return makeRef(*sender);
+    auto sender = RTCRtpSender::create(*this, makeRef(track), WTFMove(mediaStreamIds), WTFMove(senderBackend));
+    auto receiver = createReceiverForSource(createEmptySource(track.kind(), createCanonicalUUIDString()), transceiverBackend->createReceiverBackend());
+    auto transceiver = RTCRtpTransceiver::create(sender.copyRef(), WTFMove(receiver), WTFMove(transceiverBackend));
+    m_peerConnection.addInternalTransceiver(WTFMove(transceiver));
+    return sender;
 }
 
 template<typename T>
-ExceptionOr<Ref<RTCRtpTransceiver>> LibWebRTCPeerConnectionBackend::addUnifiedPlanTransceiver(T&& trackOrKind, const RTCRtpTransceiverInit& init)
+ExceptionOr<Ref<RTCRtpTransceiver>> LibWebRTCPeerConnectionBackend::addTransceiverFromTrackOrKind(T&& trackOrKind, const RTCRtpTransceiverInit& init)
 {
     auto backends = m_endpoint->addTransceiver(trackOrKind, init);
     if (!backends)
         return Exception { InvalidAccessError, "Unable to add transceiver"_s };
 
@@ -467,30 +447,16 @@
     return transceiver;
 }
 
 ExceptionOr<Ref<RTCRtpTransceiver>> LibWebRTCPeerConnectionBackend::addTransceiver(const String& trackKind, const RTCRtpTransceiverInit& init)
 {
-    if (RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())
-        return addUnifiedPlanTransceiver(String { trackKind }, init);
-
-    auto senderBackend = makeUnique<LibWebRTCRtpSenderBackend>(*this, nullptr);
-    auto newSender = RTCRtpSender::create(*this, String(trackKind), Vector<String>(), WTFMove(senderBackend));
-    return completeAddTransceiver(WTFMove(newSender), init, createCanonicalUUIDString(), trackKind);
+    return addTransceiverFromTrackOrKind(String { trackKind }, init);
 }
 
 ExceptionOr<Ref<RTCRtpTransceiver>> LibWebRTCPeerConnectionBackend::addTransceiver(Ref<MediaStreamTrack>&& track, const RTCRtpTransceiverInit& init)
 {
-    if (RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled())
-        return addUnifiedPlanTransceiver(WTFMove(track), init);
-
-    auto senderBackend = makeUnique<LibWebRTCRtpSenderBackend>(*this, nullptr);
-    auto& backend = *senderBackend;
-    auto sender = RTCRtpSender::create(*this, track.copyRef(), Vector<String>(), WTFMove(senderBackend));
-    if (!m_endpoint->addTrack(backend, track, Vector<String> { }))
-        return Exception { InvalidAccessError, "Unable to add track"_s };
-
-    return completeAddTransceiver(WTFMove(sender), init, track->id(), track->kind());
+    return addTransceiverFromTrackOrKind(WTFMove(track), init);
 }
 
 void LibWebRTCPeerConnectionBackend::setSenderSourceFromTrack(LibWebRTCRtpSenderBackend& sender, MediaStreamTrack& track)
 {
     m_endpoint->setSenderSourceFromTrack(sender, track);
@@ -547,28 +513,8 @@
                 videoSource->setApplyRotation(true);
         }
     }
 }
 
-bool LibWebRTCPeerConnectionBackend::shouldOfferAllowToReceive(const char* kind) const
-{
-    ASSERT(!RuntimeEnabledFeatures::sharedFeatures().webRTCUnifiedPlanEnabled());
-    for (const auto& transceiver : m_peerConnection.currentTransceivers()) {
-        if (transceiver->sender().trackKind() != kind)
-            continue;
-
-        if (transceiver->direction() == RTCRtpTransceiverDirection::Recvonly)
-            return true;
-
-        if (transceiver->direction() != RTCRtpTransceiverDirection::Sendrecv)
-            continue;
-
-        auto* backend = static_cast<LibWebRTCRtpSenderBackend*>(transceiver->sender().backend());
-        if (backend && !backend->rtcSender())
-            return true;
-    }
-    return false;
-}
-
 } // namespace WebCore
 
 #endif // USE(LIBWEBRTC)

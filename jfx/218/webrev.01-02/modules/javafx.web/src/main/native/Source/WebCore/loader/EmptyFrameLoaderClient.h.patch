diff a/modules/javafx.web/src/main/native/Source/WebCore/loader/EmptyFrameLoaderClient.h b/modules/javafx.web/src/main/native/Source/WebCore/loader/EmptyFrameLoaderClient.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/loader/EmptyFrameLoaderClient.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/loader/EmptyFrameLoaderClient.h
@@ -21,37 +21,43 @@
  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#pragma once
+
 #include "FrameLoaderClient.h"
+#include "ResourceError.h"
+
+#if USE(QUICK_LOOK)
+#include "LegacyPreviewLoaderClient.h"
+#endif
 
 namespace WebCore {
 
 class WEBCORE_EXPORT EmptyFrameLoaderClient : public FrameLoaderClient {
     Ref<DocumentLoader> createDocumentLoader(const ResourceRequest&, const SubstituteData&) override;
 
     void frameLoaderDestroyed() override { }
 
     Optional<FrameIdentifier> frameID() const override { return WTF::nullopt; }
     Optional<PageIdentifier> pageID() const override { return WTF::nullopt; }
-    PAL::SessionID sessionID() const override;
 
     bool hasWebView() const final { return true; } // mainly for assertions
 
     void makeRepresentation(DocumentLoader*) final { }
 #if PLATFORM(IOS_FAMILY)
-    bool forceLayoutOnRestoreFromPageCache() final { return false; }
+    bool forceLayoutOnRestoreFromBackForwardCache() final { return false; }
 #endif
     void forceLayoutForNonHTML() final { }
 
     void setCopiesOnScroll() final { }
 
     void detachedFromParent2() final { }
     void detachedFromParent3() final { }
 
-    void convertMainResourceLoadToDownload(DocumentLoader*, PAL::SessionID, const ResourceRequest&, const ResourceResponse&) final { }
+    void convertMainResourceLoadToDownload(DocumentLoader*, const ResourceRequest&, const ResourceResponse&) final { }
 
     void assignIdentifierToInitialRequest(unsigned long, DocumentLoader*, const ResourceRequest&) final { }
     bool shouldUseCredentialStorage(DocumentLoader*, unsigned long) override { return false; }
     void dispatchWillSendRequest(DocumentLoader*, unsigned long, ResourceRequest&, const ResourceResponse&) final { }
     void dispatchDidReceiveAuthenticationChallenge(DocumentLoader*, unsigned long, const AuthenticationChallenge&) final { }
@@ -156,12 +162,11 @@
 #if PLATFORM(IOS_FAMILY)
     void didRestoreFrameHierarchyForCachedFrame() final { }
 #endif
     void transitionToCommittedForNewPage() final { }
 
-    void didSaveToPageCache() final { }
-    void didRestoreFromPageCache() final { }
+    void didRestoreFromBackForwardCache() final { }
 
     void dispatchDidBecomeFrameset(bool) final { }
 
     void updateGlobalHistory() final { }
     void updateGlobalHistoryRedirectLinks() final { }
@@ -190,18 +195,21 @@
     bool shouldCacheResponse(DocumentLoader*, unsigned long, const ResourceResponse&, const unsigned char*, unsigned long long) final { return true; }
 #endif
 
     Ref<FrameNetworkingContext> createNetworkingContext() final;
 
-    bool isEmptyFrameLoaderClient() final { return true; }
+    bool isEmptyFrameLoaderClient() const final { return true; }
     void prefetchDNS(const String&) final { }
 
 #if USE(QUICK_LOOK)
-    RefPtr<PreviewLoaderClient> createPreviewLoaderClient(const String&, const String&) final { return nullptr; }
+    RefPtr<LegacyPreviewLoaderClient> createPreviewLoaderClient(const String&, const String&) final { return nullptr; }
 #endif
 #if ENABLE(RESOURCE_LOAD_STATISTICS)
     bool hasFrameSpecificStorageAccess() final { return false; }
-    void setHasFrameSpecificStorageAccess(bool) final { }
 #endif
 };
 
-}
+} // namespace WebCore
+
+SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::EmptyFrameLoaderClient)
+    static bool isType(const WebCore::FrameLoaderClient& frameLoaderClient) { return frameLoaderClient.isEmptyFrameLoaderClient(); }
+SPECIALIZE_TYPE_TRAITS_END()

diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/RTCPeerConnection.h b/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/RTCPeerConnection.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/RTCPeerConnection.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/RTCPeerConnection.h
@@ -94,11 +94,11 @@
         RefPtr<Uint8Array> publicExponent;
         Optional<double> expires;
     };
 
     using AlgorithmIdentifier = Variant<JSC::Strong<JSC::JSObject>, String>;
-    static void generateCertificate(JSC::ExecState&, AlgorithmIdentifier&&, DOMPromiseDeferred<IDLInterface<RTCCertificate>>&&);
+    static void generateCertificate(JSC::JSGlobalObject&, AlgorithmIdentifier&&, DOMPromiseDeferred<IDLInterface<RTCCertificate>>&&);
 
     // 4.3.2 RTCPeerConnection Interface
     void queuedCreateOffer(RTCOfferOptions&&, PeerConnection::SessionDescriptionPromise&&);
     void queuedCreateAnswer(RTCAnswerOptions&&, PeerConnection::SessionDescriptionPromise&&);
 
@@ -140,11 +140,11 @@
 
     using AddTransceiverTrackOrKind = Variant<RefPtr<MediaStreamTrack>, String>;
     ExceptionOr<Ref<RTCRtpTransceiver>> addTransceiver(AddTransceiverTrackOrKind&&, const RTCRtpTransceiverInit&);
 
     // 6.1 Peer-to-peer data API
-    ExceptionOr<Ref<RTCDataChannel>> createDataChannel(ScriptExecutionContext&, String&&, RTCDataChannelInit&&);
+    ExceptionOr<Ref<RTCDataChannel>> createDataChannel(String&&, RTCDataChannelInit&&);
 
     // 8.2 Statistics API
     void getStats(MediaStreamTrack*, Ref<DeferredPromise>&&);
 
     // EventTarget
@@ -163,29 +163,38 @@
     void updateIceGatheringState(RTCIceGatheringState);
     void updateIceConnectionState(RTCIceConnectionState);
 
     void scheduleNegotiationNeededEvent();
 
-    void fireEvent(Event&);
+    void dispatchEventWhenFeasible(Ref<Event>&&);
 
     void disableICECandidateFiltering() { m_backend->disableICECandidateFiltering(); }
     void enableICECandidateFiltering() { m_backend->enableICECandidateFiltering(); }
 
     void clearController() { m_controller = nullptr; }
 
     // ActiveDOMObject.
     bool hasPendingActivity() const final;
 
+    Document* document();
+
+    void doTask(Function<void()>&&);
+
 #if !RELEASE_LOG_DISABLED
     const Logger& logger() const final { return m_logger.get(); }
     const void* logIdentifier() const final { return m_logIdentifier; }
     const char* logClassName() const final { return "RTCPeerConnection"; }
     WTFLogChannel& logChannel() const final;
 #endif
 
 private:
-    RTCPeerConnection(ScriptExecutionContext&);
+    template<typename PromiseType> void addPendingPromise(PromiseType& promise)
+    {
+        promise.whenSettled([pendingActivity = makePendingActivity(*this)] { });
+    }
+
+    RTCPeerConnection(Document&);
 
     ExceptionOr<void> initializeConfiguration(RTCConfiguration&&);
     Ref<RTCRtpTransceiver> completeAddTransceiver(Ref<RTCRtpSender>&&, const RTCRtpTransceiverInit&, const String& trackId, const String& trackKind);
 
     void registerToController(RTCController&);
@@ -200,11 +209,12 @@
     void dispatchEvent(Event&) final;
 
     // ActiveDOMObject
     WEBCORE_EXPORT void stop() final;
     const char* activeDOMObjectName() const final;
-    bool canSuspendForDocumentSuspension() const final;
+    void suspend(ReasonForSuspension) final;
+    void resume() final;
 
     void updateConnectionState();
     bool doClose();
     void doStop();
 
@@ -226,11 +236,12 @@
     std::unique_ptr<PeerConnectionBackend> m_backend;
 
     RTCConfiguration m_configuration;
     RTCController* m_controller { nullptr };
     Vector<RefPtr<RTCCertificate>> m_certificates;
-    RefPtr<PendingActivity<RTCPeerConnection>> m_pendingActivity;
+    bool m_shouldDelayTasks { false };
+    Vector<Function<void()>> m_pendingTasks;
 };
 
 } // namespace WebCore
 
 #endif // ENABLE(WEB_RTC)

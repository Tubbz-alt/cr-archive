diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/testmasm.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/testmasm.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/testmasm.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/testmasm.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2017-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2017-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -175,28 +175,48 @@
 T compileAndRun(Generator&& generator, Arguments... arguments)
 {
     return invoke<T>(compile(WTFMove(generator)), arguments...);
 }
 
+void emitFunctionPrologue(CCallHelpers& jit)
+{
+    jit.emitFunctionPrologue();
+#if CPU(ARM_THUMB2)
+    // MacroAssemblerARMv7 uses r6 as a temporary register, which is a
+    // callee-saved register, see 5.1.1 of the Procedure Call Standard for
+    // the ARM Architecture.
+    // http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042f/IHI0042F_aapcs.pdf
+    jit.push(ARMRegisters::r6);
+#endif
+}
+
+void emitFunctionEpilogue(CCallHelpers& jit)
+{
+#if CPU(ARM_THUMB2)
+    jit.pop(ARMRegisters::r6);
+#endif
+    jit.emitFunctionEpilogue();
+}
+
 void testSimple()
 {
     CHECK_EQ(compileAndRun<int>([] (CCallHelpers& jit) {
-        jit.emitFunctionPrologue();
+        emitFunctionPrologue(jit);
         jit.move(CCallHelpers::TrustedImm32(42), GPRInfo::returnValueGPR);
-        jit.emitFunctionEpilogue();
+        emitFunctionEpilogue(jit);
         jit.ret();
     }), 42);
 }
 
 void testGetEffectiveAddress(size_t pointer, ptrdiff_t length, int32_t offset, CCallHelpers::Scale scale)
 {
     CHECK_EQ(compileAndRun<size_t>([=] (CCallHelpers& jit) {
-        jit.emitFunctionPrologue();
+        emitFunctionPrologue(jit);
         jit.move(CCallHelpers::TrustedImmPtr(bitwise_cast<void*>(pointer)), GPRInfo::regT0);
         jit.move(CCallHelpers::TrustedImmPtr(bitwise_cast<void*>(length)), GPRInfo::regT1);
         jit.getEffectiveAddress(CCallHelpers::BaseIndex(GPRInfo::regT0, GPRInfo::regT1, scale, offset), GPRInfo::returnValueGPR);
-        jit.emitFunctionEpilogue();
+        emitFunctionEpilogue(jit);
         jit.ret();
     }), pointer + offset + (static_cast<size_t>(1) << static_cast<int>(scale)) * length);
 }
 
 // branchTruncateDoubleToInt32(), when encountering Infinity, -Infinity or a
@@ -208,11 +228,11 @@
     const bool isBigEndian = true;
 #else
     const bool isBigEndian = false;
 #endif
     CHECK_EQ(compileAndRun<int>([&] (CCallHelpers& jit) {
-        jit.emitFunctionPrologue();
+        emitFunctionPrologue(jit);
         jit.subPtr(CCallHelpers::TrustedImm32(stackAlignmentBytes()), MacroAssembler::stackPointerRegister);
         if (isBigEndian) {
             jit.store32(CCallHelpers::TrustedImm32(valAsUInt >> 32),
                 MacroAssembler::stackPointerRegister);
             jit.store32(CCallHelpers::TrustedImm32(valAsUInt & 0xffffffff),
@@ -230,11 +250,11 @@
 
         jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
 
         done.link(&jit);
         jit.addPtr(CCallHelpers::TrustedImm32(stackAlignmentBytes()), MacroAssembler::stackPointerRegister);
-        jit.emitFunctionEpilogue();
+        emitFunctionEpilogue(jit);
         jit.ret();
     }), expected);
 }
 
 
@@ -314,136 +334,136 @@
 #endif
 
 #if CPU(X86_64)
 void testBranchTestBit32RegReg()
 {
-    for (uint32_t value : int32Operands()) {
+    for (auto value : int32Operands()) {
         auto test = compile([=] (CCallHelpers& jit) {
-            jit.emitFunctionPrologue();
+            emitFunctionPrologue(jit);
 
             auto branch = jit.branchTestBit32(MacroAssembler::NonZero, GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
             jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
             auto done = jit.jump();
             branch.link(&jit);
             jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
             done.link(&jit);
 
-            jit.emitFunctionEpilogue();
+            emitFunctionEpilogue(jit);
             jit.ret();
         });
 
-        for (uint32_t value2 : int32Operands())
+        for (auto value2 : int32Operands())
             CHECK_EQ(invoke<int>(test, value, value2), (value>>(value2%32))&1);
     }
 }
 
 void testBranchTestBit32RegImm()
 {
-    for (uint32_t value : int32Operands()) {
+    for (auto value : int32Operands()) {
         auto test = compile([=] (CCallHelpers& jit) {
-            jit.emitFunctionPrologue();
+            emitFunctionPrologue(jit);
 
             auto branch = jit.branchTestBit32(MacroAssembler::NonZero, GPRInfo::argumentGPR0, CCallHelpers::TrustedImm32(value));
             jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
             auto done = jit.jump();
             branch.link(&jit);
             jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
             done.link(&jit);
 
-            jit.emitFunctionEpilogue();
+            emitFunctionEpilogue(jit);
             jit.ret();
         });
 
-        for (uint32_t value2 : int32Operands())
+        for (auto value2 : int32Operands())
             CHECK_EQ(invoke<int>(test, value2), (value2>>(value%32))&1);
     }
 }
 
 void testBranchTestBit32AddrImm()
 {
-    for (uint32_t value : int32Operands()) {
+    for (auto value : int32Operands()) {
         auto test = compile([=] (CCallHelpers& jit) {
-            jit.emitFunctionPrologue();
+            emitFunctionPrologue(jit);
 
             auto branch = jit.branchTestBit32(MacroAssembler::NonZero, MacroAssembler::Address(GPRInfo::argumentGPR0, 0), CCallHelpers::TrustedImm32(value));
             jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
             auto done = jit.jump();
             branch.link(&jit);
             jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
             done.link(&jit);
 
-            jit.emitFunctionEpilogue();
+            emitFunctionEpilogue(jit);
             jit.ret();
         });
 
-        for (uint32_t value2 : int32Operands())
+        for (auto value2 : int32Operands())
             CHECK_EQ(invoke<int>(test, &value2), (value2>>(value%32))&1);
     }
 }
 
 void testBranchTestBit64RegReg()
 {
-    for (uint64_t value : int64Operands()) {
+    for (auto value : int64Operands()) {
         auto test = compile([=] (CCallHelpers& jit) {
-            jit.emitFunctionPrologue();
+            emitFunctionPrologue(jit);
 
             auto branch = jit.branchTestBit64(MacroAssembler::NonZero, GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
             jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::returnValueGPR);
             auto done = jit.jump();
             branch.link(&jit);
             jit.move(CCallHelpers::TrustedImm64(1), GPRInfo::returnValueGPR);
             done.link(&jit);
 
-            jit.emitFunctionEpilogue();
+            emitFunctionEpilogue(jit);
             jit.ret();
         });
 
-        for (uint64_t value2 : int64Operands())
+        for (auto value2 : int64Operands())
             CHECK_EQ(invoke<long int>(test, value, value2), (value>>(value2%64))&1);
     }
 }
 
 void testBranchTestBit64RegImm()
 {
-    for (uint64_t value : int64Operands()) {
+    for (auto value : int64Operands()) {
         auto test = compile([=] (CCallHelpers& jit) {
-            jit.emitFunctionPrologue();
+            emitFunctionPrologue(jit);
 
             auto branch = jit.branchTestBit64(MacroAssembler::NonZero, GPRInfo::argumentGPR0, CCallHelpers::TrustedImm32(value));
             jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::returnValueGPR);
             auto done = jit.jump();
             branch.link(&jit);
             jit.move(CCallHelpers::TrustedImm64(1), GPRInfo::returnValueGPR);
             done.link(&jit);
 
-            jit.emitFunctionEpilogue();
+            emitFunctionEpilogue(jit);
             jit.ret();
         });
 
-        for (uint64_t value2 : int64Operands())
+        for (auto value2 : int64Operands())
             CHECK_EQ(invoke<long int>(test, value2), (value2>>(value%64))&1);
     }
 }
 
 void testBranchTestBit64AddrImm()
 {
-    for (uint64_t value : int64Operands()) {
+    for (auto value : int64Operands()) {
         auto test = compile([=] (CCallHelpers& jit) {
-            jit.emitFunctionPrologue();
+            emitFunctionPrologue(jit);
 
             auto branch = jit.branchTestBit64(MacroAssembler::NonZero, MacroAssembler::Address(GPRInfo::argumentGPR0, 0), CCallHelpers::TrustedImm32(value));
             jit.move(CCallHelpers::TrustedImm64(0), GPRInfo::returnValueGPR);
             auto done = jit.jump();
             branch.link(&jit);
             jit.move(CCallHelpers::TrustedImm64(1), GPRInfo::returnValueGPR);
             done.link(&jit);
 
-            jit.emitFunctionEpilogue();
+            emitFunctionEpilogue(jit);
             jit.ret();
         });
 
-        for (uint64_t value2 : int64Operands())
+        for (auto value2 : int64Operands())
             CHECK_EQ(invoke<long int>(test, &value2), (value2>>(value%64))&1);
     }
 }
 
 #endif
@@ -452,32 +472,32 @@
 {
     double arg1 = 0;
     double arg2 = 0;
 
     auto compareDouble = compile([&, condition] (CCallHelpers& jit) {
-        jit.emitFunctionPrologue();
+        emitFunctionPrologue(jit);
 
         jit.loadDouble(CCallHelpers::TrustedImmPtr(&arg1), FPRInfo::fpRegT0);
         jit.loadDouble(CCallHelpers::TrustedImmPtr(&arg2), FPRInfo::fpRegT1);
         jit.move(CCallHelpers::TrustedImm32(-1), GPRInfo::returnValueGPR);
         jit.compareDouble(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1, GPRInfo::returnValueGPR);
 
-        jit.emitFunctionEpilogue();
+        emitFunctionEpilogue(jit);
         jit.ret();
     });
 
     auto compareDoubleGeneric = compile([&, condition] (CCallHelpers& jit) {
-        jit.emitFunctionPrologue();
+        emitFunctionPrologue(jit);
 
         jit.loadDouble(CCallHelpers::TrustedImmPtr(&arg1), FPRInfo::fpRegT0);
         jit.loadDouble(CCallHelpers::TrustedImmPtr(&arg2), FPRInfo::fpRegT1);
         jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
         auto jump = jit.branchDouble(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1);
         jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
         jump.link(&jit);
 
-        jit.emitFunctionEpilogue();
+        emitFunctionEpilogue(jit);
         jit.ret();
     });
 
     auto operands = doubleOperands();
     for (auto a : operands) {
@@ -491,15 +511,15 @@
 
 void testMul32WithImmediates()
 {
     for (auto immediate : int32Operands()) {
         auto mul = compile([=] (CCallHelpers& jit) {
-            jit.emitFunctionPrologue();
+            emitFunctionPrologue(jit);
 
             jit.mul32(CCallHelpers::TrustedImm32(immediate), GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
 
-            jit.emitFunctionEpilogue();
+            emitFunctionEpilogue(jit);
             jit.ret();
         });
 
         for (auto value : int32Operands())
             CHECK_EQ(invoke<int>(mul, value), immediate * value);
@@ -509,15 +529,15 @@
 #if CPU(ARM64)
 void testMul32SignExtend()
 {
     for (auto value : int32Operands()) {
         auto mul = compile([=] (CCallHelpers& jit) {
-            jit.emitFunctionPrologue();
+            emitFunctionPrologue(jit);
 
             jit.multiplySignExtend32(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1, GPRInfo::returnValueGPR);
 
-            jit.emitFunctionEpilogue();
+            emitFunctionEpilogue(jit);
             jit.ret();
         });
 
         for (auto value2 : int32Operands())
             CHECK_EQ(invoke<long int>(mul, value, value2), ((long int) value) * ((long int) value2));
@@ -530,32 +550,32 @@
 {
     float arg1 = 0;
     float arg2 = 0;
 
     auto compareFloat = compile([&, condition] (CCallHelpers& jit) {
-        jit.emitFunctionPrologue();
+        emitFunctionPrologue(jit);
 
         jit.loadFloat(CCallHelpers::TrustedImmPtr(&arg1), FPRInfo::fpRegT0);
         jit.loadFloat(CCallHelpers::TrustedImmPtr(&arg2), FPRInfo::fpRegT1);
         jit.move(CCallHelpers::TrustedImm32(-1), GPRInfo::returnValueGPR);
         jit.compareFloat(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1, GPRInfo::returnValueGPR);
 
-        jit.emitFunctionEpilogue();
+        emitFunctionEpilogue(jit);
         jit.ret();
     });
 
     auto compareFloatGeneric = compile([&, condition] (CCallHelpers& jit) {
-        jit.emitFunctionPrologue();
+        emitFunctionPrologue(jit);
 
         jit.loadFloat(CCallHelpers::TrustedImmPtr(&arg1), FPRInfo::fpRegT0);
         jit.loadFloat(CCallHelpers::TrustedImmPtr(&arg2), FPRInfo::fpRegT1);
         jit.move(CCallHelpers::TrustedImm32(1), GPRInfo::returnValueGPR);
         auto jump = jit.branchFloat(condition, FPRInfo::fpRegT0, FPRInfo::fpRegT1);
         jit.move(CCallHelpers::TrustedImm32(0), GPRInfo::returnValueGPR);
         jump.link(&jit);
 
-        jit.emitFunctionEpilogue();
+        emitFunctionEpilogue(jit);
         jit.ret();
     });
 
     auto operands = floatOperands();
     for (auto a : operands) {
@@ -571,11 +591,11 @@
 #if ENABLE(MASM_PROBE)
 void testProbeReadsArgumentRegisters()
 {
     bool probeWasCalled = false;
     compileAndRun<void>([&] (CCallHelpers& jit) {
-        jit.emitFunctionPrologue();
+        emitFunctionPrologue(jit);
 
         jit.pushPair(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
         jit.pushPair(GPRInfo::argumentGPR2, GPRInfo::argumentGPR3);
 
         jit.move(CCallHelpers::TrustedImm32(testWord32(0)), GPRInfo::argumentGPR0);
@@ -607,11 +627,11 @@
         });
 
         jit.popPair(GPRInfo::argumentGPR2, GPRInfo::argumentGPR3);
         jit.popPair(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
 
-        jit.emitFunctionEpilogue();
+        emitFunctionEpilogue(jit);
         jit.ret();
     });
     CHECK_EQ(probeWasCalled, true);
 }
 
@@ -620,11 +640,11 @@
     // This test relies on testProbeReadsArgumentRegisters() having already validated
     // that we can read from argument registers. We'll use that ability to validate
     // that our writes did take effect.
     unsigned probeCallCount = 0;
     compileAndRun<void>([&] (CCallHelpers& jit) {
-        jit.emitFunctionPrologue();
+        emitFunctionPrologue(jit);
 
         jit.pushPair(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
         jit.pushPair(GPRInfo::argumentGPR2, GPRInfo::argumentGPR3);
 
         // Pre-initialize with non-expected values.
@@ -669,11 +689,11 @@
         });
 
         jit.popPair(GPRInfo::argumentGPR2, GPRInfo::argumentGPR3);
         jit.popPair(GPRInfo::argumentGPR0, GPRInfo::argumentGPR1);
 
-        jit.emitFunctionEpilogue();
+        emitFunctionEpilogue(jit);
         jit.ret();
     });
     CHECK_EQ(probeCallCount, 2);
 }
 
@@ -697,11 +717,11 @@
     // to validate that the probe preserves register values.
     unsigned probeCallCount = 0;
     CPUState originalState;
 
     compileAndRun<void>([&] (CCallHelpers& jit) {
-        jit.emitFunctionPrologue();
+        emitFunctionPrologue(jit);
 
         // Write expected values into the registers (except for sp, fp, and pc).
         jit.probe([&] (Probe::Context& context) {
             auto& cpu = context.cpu;
             probeCallCount++;
@@ -771,11 +791,11 @@
                 if (!(id & 1))
 #endif
                 CHECK_EQ(cpu.fpr<uint64_t>(id), originalState.fpr<uint64_t>(id));
         });
 
-        jit.emitFunctionEpilogue();
+        emitFunctionEpilogue(jit);
         jit.ret();
     });
     CHECK_EQ(probeCallCount, 5);
 }
 
@@ -799,11 +819,11 @@
     auto flagsSPR = ARM64Registers::nzcv;
     uintptr_t flagsMask = 0xf0000000;
 #endif
 
     compileAndRun<void>([&] (CCallHelpers& jit) {
-        jit.emitFunctionPrologue();
+        emitFunctionPrologue(jit);
 
         // Preserve original stack pointer and modify the sp, and
         // write expected values into other registers (except for fp, and pc).
         jit.probe([&] (Probe::Context& context) {
             auto& cpu = context.cpu;
@@ -889,11 +909,11 @@
             CHECK_EQ(cpu.spr(flagsSPR) & flagsMask, originalState.spr(flagsSPR) & flagsMask);
 #endif
             CHECK_EQ(cpu.sp(), originalSP);
         });
 
-        jit.emitFunctionEpilogue();
+        emitFunctionEpilogue(jit);
         jit.ret();
     });
     CHECK_EQ(probeCallCount, 4);
 }
 
@@ -939,16 +959,16 @@
         jit.probe([&] (Probe::Context&) {
             probeCallCount++;
             continuationWasReached = true;
         });
 
-        jit.emitFunctionEpilogue();
+        emitFunctionEpilogue(jit);
         jit.ret();
     });
 
     compileAndRun<void>([&] (CCallHelpers& jit) {
-        jit.emitFunctionPrologue();
+        emitFunctionPrologue(jit);
 
         // Write expected values into the registers.
         jit.probe([&] (Probe::Context& context) {
             probeCallCount++;
             context.cpu.pc() = untagCodePtr(continuation.code().executableAddress(), JSEntryPtrTag);
@@ -981,11 +1001,11 @@
     MacroAssembler::SPRegisterID flagsSPR = ARM64Registers::nzcv;
     uintptr_t flagsMask = 0xf0000000;
 #endif
 
     compileAndRun<void>([&] (CCallHelpers& jit) {
-        jit.emitFunctionPrologue();
+        emitFunctionPrologue(jit);
 
         // Write expected values into the registers.
         jit.probe([&] (Probe::Context& context) {
             auto& cpu = context.cpu;
             auto& stack = context.stack();
@@ -1074,46 +1094,81 @@
             cpu.spr(flagsSPR) = originalState.spr(flagsSPR);
 #endif
             cpu.sp() = originalSP;
         });
 
-        jit.emitFunctionEpilogue();
+        emitFunctionEpilogue(jit);
         jit.ret();
     });
 
     CHECK_EQ(probeCallCount, 3);
 }
 #endif // ENABLE(MASM_PROBE)
 
+void testOrImmMem()
+{
+    // FIXME: this does not test that the or does not touch beyond its width.
+    // I am not sure how to do such a test without a lot of complexity (running multiple threads, with a race on the high bits of the memory location).
+    uint64_t memoryLocation = 0x12341234;
+    auto or32 = compile([&] (CCallHelpers& jit) {
+        emitFunctionPrologue(jit);
+        jit.or32(CCallHelpers::TrustedImm32(42), CCallHelpers::AbsoluteAddress(&memoryLocation));
+        emitFunctionEpilogue(jit);
+        jit.ret();
+    });
+    invoke<void>(or32);
+    CHECK_EQ(memoryLocation, 0x12341234 | 42);
+
+    memoryLocation = 0x12341234;
+    auto or16 = compile([&] (CCallHelpers& jit) {
+        emitFunctionPrologue(jit);
+        jit.or16(CCallHelpers::TrustedImm32(42), CCallHelpers::AbsoluteAddress(&memoryLocation));
+        emitFunctionEpilogue(jit);
+        jit.ret();
+    });
+    invoke<void>(or16);
+    CHECK_EQ(memoryLocation, 0x12341234 | 42);
+
+    memoryLocation = 0x12341234;
+    auto or16InvalidLogicalImmInARM64 = compile([&] (CCallHelpers& jit) {
+        emitFunctionPrologue(jit);
+        jit.or16(CCallHelpers::TrustedImm32(0), CCallHelpers::AbsoluteAddress(&memoryLocation));
+        emitFunctionEpilogue(jit);
+        jit.ret();
+    });
+    invoke<void>(or16InvalidLogicalImmInARM64);
+    CHECK_EQ(memoryLocation, 0x12341234);
+}
+
 void testByteSwap()
 {
 #if CPU(X86_64) || CPU(ARM64)
     auto byteSwap16 = compile([] (CCallHelpers& jit) {
-        jit.emitFunctionPrologue();
+        emitFunctionPrologue(jit);
         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
         jit.byteSwap16(GPRInfo::returnValueGPR);
-        jit.emitFunctionEpilogue();
+        emitFunctionEpilogue(jit);
         jit.ret();
     });
     CHECK_EQ(invoke<uint64_t>(byteSwap16, 0xaabbccddee001122), static_cast<uint64_t>(0x2211));
     CHECK_EQ(invoke<uint64_t>(byteSwap16, 0xaabbccddee00ffaa), static_cast<uint64_t>(0xaaff));
 
     auto byteSwap32 = compile([] (CCallHelpers& jit) {
-        jit.emitFunctionPrologue();
+        emitFunctionPrologue(jit);
         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
         jit.byteSwap32(GPRInfo::returnValueGPR);
-        jit.emitFunctionEpilogue();
+        emitFunctionEpilogue(jit);
         jit.ret();
     });
     CHECK_EQ(invoke<uint64_t>(byteSwap32, 0xaabbccddee001122), static_cast<uint64_t>(0x221100ee));
     CHECK_EQ(invoke<uint64_t>(byteSwap32, 0xaabbccddee00ffaa), static_cast<uint64_t>(0xaaff00ee));
 
     auto byteSwap64 = compile([] (CCallHelpers& jit) {
-        jit.emitFunctionPrologue();
+        emitFunctionPrologue(jit);
         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
         jit.byteSwap64(GPRInfo::returnValueGPR);
-        jit.emitFunctionEpilogue();
+        emitFunctionEpilogue(jit);
         jit.ret();
     });
     CHECK_EQ(invoke<uint64_t>(byteSwap64, 0xaabbccddee001122), static_cast<uint64_t>(0x221100eeddccbbaa));
     CHECK_EQ(invoke<uint64_t>(byteSwap64, 0xaabbccddee00ffaa), static_cast<uint64_t>(0xaaff00eeddccbbaa));
 #endif
@@ -1128,19 +1183,19 @@
 
     const double chosenDouble = 6.00000059604644775390625;
     CHECK_EQ(static_cast<double>(static_cast<float>(chosenDouble)) == chosenDouble, false);
 
     auto sel = compile([&] (CCallHelpers& jit) {
-        jit.emitFunctionPrologue();
+        emitFunctionPrologue(jit);
         jit.loadDouble(CCallHelpers::TrustedImmPtr(&zero), FPRInfo::returnValueFPR);
         jit.loadDouble(CCallHelpers::TrustedImmPtr(&arg1), FPRInfo::fpRegT1);
         jit.loadDouble(CCallHelpers::TrustedImmPtr(&arg2), FPRInfo::fpRegT2);
 
         jit.move(MacroAssembler::TrustedImm32(-1), GPRInfo::regT0);
         jit.moveDoubleConditionally32(MacroAssembler::Equal, GPRInfo::regT0, GPRInfo::regT0, FPRInfo::fpRegT1, FPRInfo::fpRegT2, FPRInfo::returnValueFPR);
 
-        jit.emitFunctionEpilogue();
+        emitFunctionEpilogue(jit);
         jit.ret();
     });
 
     arg1 = chosenDouble;
     arg2 = 43;
@@ -1162,19 +1217,19 @@
 
     const double chosenDouble = 6.00000059604644775390625;
     CHECK_EQ(static_cast<double>(static_cast<float>(chosenDouble)) == chosenDouble, false);
 
     auto sel = compile([&] (CCallHelpers& jit) {
-        jit.emitFunctionPrologue();
+        emitFunctionPrologue(jit);
         jit.loadDouble(CCallHelpers::TrustedImmPtr(&zero), FPRInfo::returnValueFPR);
         jit.loadDouble(CCallHelpers::TrustedImmPtr(&arg1), FPRInfo::fpRegT1);
         jit.loadDouble(CCallHelpers::TrustedImmPtr(&arg2), FPRInfo::fpRegT2);
 
         jit.move(MacroAssembler::TrustedImm64(-1), GPRInfo::regT0);
         jit.moveDoubleConditionally64(MacroAssembler::Equal, GPRInfo::regT0, GPRInfo::regT0, FPRInfo::fpRegT1, FPRInfo::fpRegT2, FPRInfo::returnValueFPR);
 
-        jit.emitFunctionEpilogue();
+        emitFunctionEpilogue(jit);
         jit.ret();
     });
 
     arg1 = chosenDouble;
     arg2 = 43;
@@ -1188,22 +1243,26 @@
 }
 
 static void testCagePreservesPACFailureBit()
 {
 #if GIGACAGE_ENABLED
-    ASSERT(!Gigacage::isDisablingPrimitiveGigacageDisabled());
+    // Placate ASan builds and any environments that disables the Gigacage.
+    if (!Gigacage::shouldBeEnabled())
+        return;
+
+    RELEASE_ASSERT(!Gigacage::isDisablingPrimitiveGigacageForbidden());
     auto cage = compile([] (CCallHelpers& jit) {
-        jit.emitFunctionPrologue();
+        emitFunctionPrologue(jit);
         jit.cageConditionally(Gigacage::Primitive, GPRInfo::argumentGPR0, GPRInfo::argumentGPR1, GPRInfo::argumentGPR2);
         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
-        jit.emitFunctionEpilogue();
+        emitFunctionEpilogue(jit);
         jit.ret();
     });
 
     void* ptr = Gigacage::tryMalloc(Gigacage::Primitive, 1);
     void* taggedPtr = tagArrayPtr(ptr, 1);
-    ASSERT(hasOneBitSet(Gigacage::size(Gigacage::Primitive) << 2));
+    RELEASE_ASSERT(hasOneBitSet(Gigacage::size(Gigacage::Primitive) << 2));
     void* notCagedPtr = reinterpret_cast<void*>(reinterpret_cast<uintptr_t>(ptr) + (Gigacage::size(Gigacage::Primitive) << 2));
     CHECK_NOT_EQ(Gigacage::caged(Gigacage::Primitive, notCagedPtr), notCagedPtr);
     void* taggedNotCagedPtr = tagArrayPtr(notCagedPtr, 1);
 
     if (isARM64E()) {
@@ -1214,14 +1273,14 @@
         CHECK_EQ(invoke<void*>(cage, taggedPtr, 2), ptr);
 
     CHECK_EQ(invoke<void*>(cage, taggedPtr, 1), ptr);
 
     auto cageWithoutAuthentication = compile([] (CCallHelpers& jit) {
-        jit.emitFunctionPrologue();
+        emitFunctionPrologue(jit);
         jit.cageWithoutUntagging(Gigacage::Primitive, GPRInfo::argumentGPR0);
         jit.move(GPRInfo::argumentGPR0, GPRInfo::returnValueGPR);
-        jit.emitFunctionEpilogue();
+        emitFunctionEpilogue(jit);
         jit.ret();
     });
 
     CHECK_EQ(invoke<void*>(cageWithoutAuthentication, taggedPtr), taggedPtr);
     if (isARM64E()) {
@@ -1334,10 +1393,12 @@
     RUN(testMoveDoubleConditionally32());
     RUN(testMoveDoubleConditionally64());
 
     RUN(testCagePreservesPACFailureBit());
 
+    RUN(testOrImmMem());
+
     if (tasks.isEmpty())
         usage();
 
     Lock lock;
 

diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/InjectedScriptSource.js b/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/InjectedScriptSource.js
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/InjectedScriptSource.js
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/InjectedScriptSource.js
@@ -228,22 +228,20 @@
         let parsedObjectId = this._parseObjectId(objectId);
         let object = this._objectForId(parsedObjectId);
         return RemoteObject.createObjectPreviewForValue(object, true);
     }
 
-    getProperties(objectId, ownProperties, generatePreview)
+    getProperties(objectId, ownProperties, fetchStart, fetchCount, generatePreview)
     {
-        let nativeGettersAsValues = false;
         let collectionMode = ownProperties ? InjectedScript.CollectionMode.OwnProperties : InjectedScript.CollectionMode.AllProperties;
-        return this._getProperties(objectId, collectionMode, generatePreview, nativeGettersAsValues);
+        return this._getProperties(objectId, collectionMode, {fetchStart, fetchCount, generatePreview});
     }
 
-    getDisplayableProperties(objectId, generatePreview)
+    getDisplayableProperties(objectId, fetchStart, fetchCount, generatePreview)
     {
-        let nativeGettersAsValues = true;
         let collectionMode = InjectedScript.CollectionMode.OwnProperties | InjectedScript.CollectionMode.NativeGetterProperties;
-        return this._getProperties(objectId, collectionMode, generatePreview, nativeGettersAsValues);
+        return this._getProperties(objectId, collectionMode, {fetchStart, fetchCount, generatePreview, nativeGettersAsValues: true});
     }
 
     getInternalProperties(objectId, generatePreview)
     {
         let parsedObjectId = this._parseObjectId(objectId);
@@ -267,11 +265,11 @@
         }
 
         return descriptors;
     }
 
-    getCollectionEntries(objectId, objectGroupName, startIndex, numberToFetch)
+    getCollectionEntries(objectId, objectGroupName, fetchStart, fetchCount)
     {
         let parsedObjectId = this._parseObjectId(objectId);
         let object = this._objectForId(parsedObjectId);
         objectGroupName = objectGroupName || this._idToObjectGroupName[parsedObjectId.id];
 
@@ -279,11 +277,11 @@
             return;
 
         if (typeof object !== "object")
             return;
 
-        let entries = this._entries(object, InjectedScriptHost.subtype(object), startIndex, numberToFetch);
+        let entries = this._entries(object, InjectedScriptHost.subtype(object), fetchStart, fetchCount);
         return entries.map(function(entry) {
             entry.value = RemoteObject.create(entry.value, objectGroupName, false, true);
             if ("key" in entry)
                 entry.key = RemoteObject.create(entry.key, objectGroupName, false, true);
             return entry;
@@ -579,11 +577,11 @@
         while (--ordinal >= 0 && callFrame)
             callFrame = callFrame.caller;
         return callFrame;
     }
 
-    _getProperties(objectId, collectionMode, generatePreview, nativeGettersAsValues)
+    _getProperties(objectId, collectionMode, {fetchStart, fetchCount, generatePreview, nativeGettersAsValues})
     {
         let parsedObjectId = this._parseObjectId(objectId);
         let object = this._objectForId(parsedObjectId);
         let objectGroupName = this._idToObjectGroupName[parsedObjectId.id];
 
@@ -591,28 +589,43 @@
             return false;
 
         if (isSymbol(object))
             return false;
 
-        let descriptors = this._propertyDescriptors(object, collectionMode, nativeGettersAsValues);
+        let start = fetchStart || 0;
+        if (start < 0)
+            start = 0;
+
+        let count = fetchCount || 0;
+        if (count < 0)
+            count = 0;
+
+        // Always include __proto__ at the end, but only for the first fetch.
+        let includeProto = !start;
+
+        let descriptors = [];
+        this._forEachPropertyDescriptor(object, collectionMode, (descriptor) => {
+            if (start > 0) {
+                --start;
+                return InjectedScript.PropertyFetchAction.Continue;
+            }
 
-        for (let i = 0; i < descriptors.length; ++i) {
-            let descriptor = descriptors[i];
             if ("get" in descriptor)
                 descriptor.get = RemoteObject.create(descriptor.get, objectGroupName);
             if ("set" in descriptor)
                 descriptor.set = RemoteObject.create(descriptor.set, objectGroupName);
             if ("value" in descriptor)
                 descriptor.value = RemoteObject.create(descriptor.value, objectGroupName, false, generatePreview);
-            if (!("configurable" in descriptor))
-                descriptor.configurable = false;
-            if (!("enumerable" in descriptor))
-                descriptor.enumerable = false;
             if ("symbol" in descriptor)
                 descriptor.symbol = RemoteObject.create(descriptor.symbol, objectGroupName);
-        }
+            descriptors.push(descriptor);
+
+            if (includeProto && count && descriptors.length >= count && descriptor.name !== "__proto__")
+                return InjectedScript.PropertyFetchAction.Stop;
 
+            return (count && descriptors.length >= count) ? InjectedScript.PropertyFetchAction.Stop : InjectedScript.PropertyFetchAction.Continue;
+        }, {nativeGettersAsValues, includeProto});
         return descriptors;
     }
 
     _internalPropertyDescriptors(object, completeDescriptor)
     {
@@ -622,33 +635,39 @@
 
         let descriptors = [];
         for (let i = 0; i < internalProperties.length; i++) {
             let property = internalProperties[i];
             let descriptor = {name: property.name, value: property.value};
-            if (completeDescriptor) {
-                descriptor.writable = false;
-                descriptor.configurable = false;
-                descriptor.enumerable = false;
+            if (completeDescriptor)
                 descriptor.isOwn = true;
-            }
             descriptors.push(descriptor);
         }
         return descriptors;
     }
 
-    _propertyDescriptors(object, collectionMode, nativeGettersAsValues)
+    _forEachPropertyDescriptor(object, collectionMode, callback, {nativeGettersAsValues, includeProto})
     {
         if (InjectedScriptHost.subtype(object) === "proxy")
-            return [];
+            return;
 
-        let descriptors = [];
         let nameProcessed = new Set;
 
+        // Handled below when `includeProto`.
+        nameProcessed.add("__proto__");
+
         function createFakeValueDescriptor(name, symbol, descriptor, isOwnProperty, possibleNativeBindingGetter)
         {
             try {
-                let fakeDescriptor = {name, value: object[name], writable: descriptor.writable || false, configurable: descriptor.configurable || false, enumerable: descriptor.enumerable || false};
+                let fakeDescriptor = {name, value: object[name]};
+                if (descriptor) {
+                    if (descriptor.writable)
+                        fakeDescriptor.writable = true;
+                    if (descriptor.configurable)
+                        fakeDescriptor.configurable = true;
+                    if (descriptor.enumerable)
+                        fakeDescriptor.enumerable = true;
+                }
                 if (possibleNativeBindingGetter)
                     fakeDescriptor.nativeGetter = true;
                 if (isOwnProperty)
                     fakeDescriptor.isOwn = true;
                 if (symbol)
@@ -668,178 +687,184 @@
         }
 
         function processDescriptor(descriptor, isOwnProperty, possibleNativeBindingGetter)
         {
             // All properties.
-            if (collectionMode & InjectedScript.CollectionMode.AllProperties) {
-                descriptors.push(descriptor);
-                return;
-            }
+            if (collectionMode & InjectedScript.CollectionMode.AllProperties)
+                return callback(descriptor);
 
             // Own properties.
-            if (collectionMode & InjectedScript.CollectionMode.OwnProperties && isOwnProperty) {
-                descriptors.push(descriptor);
-                return;
-            }
+            if (collectionMode & InjectedScript.CollectionMode.OwnProperties && isOwnProperty)
+                return callback(descriptor);
 
             // Native Getter properties.
             if (collectionMode & InjectedScript.CollectionMode.NativeGetterProperties) {
-                if (possibleNativeBindingGetter) {
-                    descriptors.push(descriptor);
-                    return;
-                }
+                if (possibleNativeBindingGetter)
+                    return callback(descriptor);
             }
         }
 
-        function processProperties(o, properties, isOwnProperty)
+        function processProperty(o, propertyName, isOwnProperty)
         {
-            for (let i = 0; i < properties.length; ++i) {
-                let property = properties[i];
-                if (nameProcessed.has(property) || property === "__proto__")
-                    continue;
-
-                nameProcessed.add(property);
-
-                let name = toString(property);
-                let symbol = isSymbol(property) ? property : null;
-
-                let descriptor = Object.getOwnPropertyDescriptor(o, property);
-                if (!descriptor) {
-                    // FIXME: Bad descriptor. Can we get here?
-                    // Fall back to very restrictive settings.
-                    let fakeDescriptor = createFakeValueDescriptor(name, symbol, {writable: false, configurable: false, enumerable: false}, isOwnProperty);
-                    processDescriptor(fakeDescriptor, isOwnProperty);
-                    continue;
-                }
+            if (nameProcessed.has(propertyName))
+                return InjectedScript.PropertyFetchAction.Continue;
 
-                if (nativeGettersAsValues) {
-                    if (String(descriptor.get).endsWith("[native code]\n}") || (!descriptor.get && descriptor.hasOwnProperty("get") && !descriptor.set && descriptor.hasOwnProperty("set"))) {
-                        // Developers may create such a descriptor, so we should be resilient:
-                        // let x = {}; Object.defineProperty(x, "p", {get:undefined}); Object.getOwnPropertyDescriptor(x, "p")
-                        let fakeDescriptor = createFakeValueDescriptor(name, symbol, descriptor, isOwnProperty, true);
-                        processDescriptor(fakeDescriptor, isOwnProperty, true);
-                        continue;
-                    }
-                }
+            nameProcessed.add(propertyName);
 
-                descriptor.name = name;
-                if (isOwnProperty)
-                    descriptor.isOwn = true;
-                if (symbol)
-                    descriptor.symbol = symbol;
-                processDescriptor(descriptor, isOwnProperty);
+            let name = toString(propertyName);
+            let symbol = isSymbol(propertyName) ? propertyName : null;
+
+            let descriptor = Object.getOwnPropertyDescriptor(o, propertyName);
+            if (!descriptor) {
+                // FIXME: Bad descriptor. Can we get here?
+                // Fall back to very restrictive settings.
+                let fakeDescriptor = createFakeValueDescriptor(name, symbol, descriptor, isOwnProperty);
+                return processDescriptor(fakeDescriptor, isOwnProperty);
             }
-        }
 
-        function arrayIndexPropertyNames(o, length)
-        {
-            let array = [];
-            for (let i = 0; i < length; ++i) {
-                if (i in o)
-                    array.push("" + i);
+            if (nativeGettersAsValues) {
+                if (String(descriptor.get).endsWith("[native code]\n}") || (!descriptor.get && descriptor.hasOwnProperty("get") && !descriptor.set && descriptor.hasOwnProperty("set"))) {
+                    // Developers may create such a descriptor, so we should be resilient:
+                    // let x = {}; Object.defineProperty(x, "p", {get:undefined}); Object.getOwnPropertyDescriptor(x, "p")
+                    let fakeDescriptor = createFakeValueDescriptor(name, symbol, descriptor, isOwnProperty, true);
+                    return processDescriptor(fakeDescriptor, isOwnProperty, true);
+                }
             }
-            return array;
+
+            descriptor.name = name;
+            if (isOwnProperty)
+                descriptor.isOwn = true;
+            if (symbol)
+                descriptor.symbol = symbol;
+            return processDescriptor(descriptor, isOwnProperty);
         }
 
-        // FIXME: <https://webkit.org/b/143589> Web Inspector: Better handling for large collections in Object Trees
-        // For array types with a large length we attempt to skip getOwnPropertyNames and instead just sublist of indexes.
         let isArrayLike = false;
         try {
             isArrayLike = RemoteObject.subtype(object) === "array" && isFinite(object.length) && object.length > 0;
         } catch { }
 
         for (let o = object; isDefined(o); o = Object.getPrototypeOf(o)) {
             let isOwnProperty = o === object;
+            let shouldBreak = false;
+
+            // FIXME: <https://webkit.org/b/201861> Web Inspector: show autocomplete entries for non-index properties on arrays
+            if (isArrayLike && isOwnProperty) {
+                for (let i = 0; i < o.length; ++i) {
+                    if (!(i in o))
+                        continue;
+
+                    let result = processProperty(o, toString(i), isOwnProperty);
+                    shouldBreak = result === InjectedScript.PropertyFetchAction.Stop;
+                    if (shouldBreak)
+                        break;
+                }
+            } else {
+                let propertyNames = Object.getOwnPropertyNames(o);
+                for (let i = 0; i < propertyNames.length; ++i) {
+                    let result = processProperty(o, propertyNames[i], isOwnProperty);
+                    shouldBreak = result === InjectedScript.PropertyFetchAction.Stop;
+                    if (shouldBreak)
+                        break;
+                }
+            }
 
-            if (isArrayLike && isOwnProperty)
-                processProperties(o, arrayIndexPropertyNames(o, Math.min(object.length, 100)), isOwnProperty);
-            else {
-                processProperties(o, Object.getOwnPropertyNames(o), isOwnProperty);
-                if (Object.getOwnPropertySymbols)
-                    processProperties(o, Object.getOwnPropertySymbols(o), isOwnProperty);
+            if (shouldBreak)
+                break;
+
+            if (Object.getOwnPropertySymbols) {
+                let propertySymbols = Object.getOwnPropertySymbols(o);
+                for (let i = 0; i < propertySymbols.length; ++i) {
+                    let result = processProperty(o, propertySymbols[i], isOwnProperty);
+                    shouldBreak = result === InjectedScript.PropertyFetchAction.Stop;
+                    if (shouldBreak)
+                        break;
+                }
             }
 
+            if (shouldBreak)
+                break;
+
             if (collectionMode === InjectedScript.CollectionMode.OwnProperties)
                 break;
         }
 
-        // Always include __proto__ at the end.
-        try {
-            if (object.__proto__)
-                descriptors.push({name: "__proto__", value: object.__proto__, writable: true, configurable: true, enumerable: false, isOwn: true});
-        } catch { }
-
-        return descriptors;
+        if (includeProto) {
+            try {
+                if (object.__proto__)
+                    callback({name: "__proto__", value: object.__proto__, writable: true, configurable: true, isOwn: true});
+            } catch { }
+        }
     }
 
-    _getSetEntries(object, skip, numberToFetch)
+    _getSetEntries(object, fetchStart, fetchCount)
     {
         let entries = [];
 
         // FIXME: This is observable if the page overrides Set.prototype[Symbol.iterator].
         for (let value of object) {
-            if (skip > 0) {
-                skip--;
+            if (fetchStart > 0) {
+                fetchStart--;
                 continue;
             }
 
             entries.push({value});
 
-            if (numberToFetch && entries.length === numberToFetch)
+            if (fetchCount && entries.length === fetchCount)
                 break;
         }
 
         return entries;
     }
 
-    _getMapEntries(object, skip, numberToFetch)
+    _getMapEntries(object, fetchStart, fetchCount)
     {
         let entries = [];
 
         // FIXME: This is observable if the page overrides Map.prototype[Symbol.iterator].
         for (let [key, value] of object) {
-            if (skip > 0) {
-                skip--;
+            if (fetchStart > 0) {
+                fetchStart--;
                 continue;
             }
 
             entries.push({key, value});
 
-            if (numberToFetch && entries.length === numberToFetch)
+            if (fetchCount && entries.length === fetchCount)
                 break;
         }
 
         return entries;
     }
 
-    _getWeakMapEntries(object, numberToFetch)
+    _getWeakMapEntries(object, fetchCount)
     {
-        return InjectedScriptHost.weakMapEntries(object, numberToFetch);
+        return InjectedScriptHost.weakMapEntries(object, fetchCount);
     }
 
-    _getWeakSetEntries(object, numberToFetch)
+    _getWeakSetEntries(object, fetchCount)
     {
-        return InjectedScriptHost.weakSetEntries(object, numberToFetch);
+        return InjectedScriptHost.weakSetEntries(object, fetchCount);
     }
 
-    _getIteratorEntries(object, numberToFetch)
+    _getIteratorEntries(object, fetchCount)
     {
-        return InjectedScriptHost.iteratorEntries(object, numberToFetch);
+        return InjectedScriptHost.iteratorEntries(object, fetchCount);
     }
 
-    _entries(object, subtype, startIndex, numberToFetch)
+    _entries(object, subtype, fetchStart, fetchCount)
     {
         if (subtype === "set")
-            return this._getSetEntries(object, startIndex, numberToFetch);
+            return this._getSetEntries(object, fetchStart, fetchCount);
         if (subtype === "map")
-            return this._getMapEntries(object, startIndex, numberToFetch);
+            return this._getMapEntries(object, fetchStart, fetchCount);
         if (subtype === "weakmap")
-            return this._getWeakMapEntries(object, numberToFetch);
+            return this._getWeakMapEntries(object, fetchCount);
         if (subtype === "weakset")
-            return this._getWeakSetEntries(object, numberToFetch);
+            return this._getWeakSetEntries(object, fetchCount);
         if (subtype === "iterator")
-            return this._getIteratorEntries(object, numberToFetch);
+            return this._getIteratorEntries(object, fetchCount);
 
         throw "unexpected type";
     }
 
     _saveResult(result)
@@ -868,10 +893,15 @@
     OwnProperties: 1 << 0,          // own properties.
     NativeGetterProperties: 1 << 1, // native getter properties in the prototype chain.
     AllProperties: 1 << 2,          // all properties in the prototype chain.
 };
 
+InjectedScript.PropertyFetchAction = {
+    Continue: Symbol("continue"),
+    Stop: Symbol("stop"),
+}
+
 var injectedScript = new InjectedScript;
 
 // -------
 
 let RemoteObject = class RemoteObject
@@ -1119,170 +1149,157 @@
             preview.properties = [];
 
             // Internal Properties.
             let internalPropertyDescriptors = injectedScript._internalPropertyDescriptors(object, true);
             if (internalPropertyDescriptors) {
-                this._appendPropertyPreviews(object, preview, internalPropertyDescriptors, true, propertiesThreshold, firstLevelKeys, secondLevelKeys);
-                if (propertiesThreshold.indexes < 0 || propertiesThreshold.properties < 0)
-                    return preview;
+                for (let i = 0; i < internalPropertyDescriptors.length; ++i) {
+                    let result = this._appendPropertyPreview(object, preview, internalPropertyDescriptors[i], propertiesThreshold, firstLevelKeys, secondLevelKeys, {internal: true});
+                    if (result === InjectedScript.PropertyFetchAction.Stop)
+                        return preview;
+                }
             }
 
             if (preview.entries)
                 return preview;
 
             // Properties.
-            let nativeGettersAsValues = true;
-            let descriptors = injectedScript._propertyDescriptors(object, InjectedScript.CollectionMode.AllProperties, nativeGettersAsValues);
-            this._appendPropertyPreviews(object, preview, descriptors, false, propertiesThreshold, firstLevelKeys, secondLevelKeys);
-            if (propertiesThreshold.indexes < 0 || propertiesThreshold.properties < 0)
-                return preview;
+            injectedScript._forEachPropertyDescriptor(object, InjectedScript.CollectionMode.AllProperties, (descriptor) => {
+                return this._appendPropertyPreview(object, preview, descriptor, propertiesThreshold, firstLevelKeys, secondLevelKeys);
+            }, {nativeGettersAsValues: true, includeProto: true})
         } catch {
             preview.lossless = false;
         }
 
         return preview;
     }
 
-    _appendPropertyPreviews(object, preview, descriptors, internal, propertiesThreshold, firstLevelKeys, secondLevelKeys)
+    _appendPropertyPreview(object, preview, descriptor, propertiesThreshold, firstLevelKeys, secondLevelKeys, {internal} = {})
     {
-        for (let i = 0; i < descriptors.length; ++i) {
-            let descriptor = descriptors[i];
-
-            // Seen enough.
-            if (propertiesThreshold.indexes < 0 || propertiesThreshold.properties < 0)
-                break;
+        // Error in descriptor.
+        if (descriptor.wasThrown) {
+            preview.lossless = false;
+            return InjectedScript.PropertyFetchAction.Continue;
+        }
 
-            // Error in descriptor.
-            if (descriptor.wasThrown) {
+        // Do not show "__proto__" in preview.
+        let name = descriptor.name;
+        if (name === "__proto__") {
+            // Non basic __proto__ objects may have interesting, non-enumerable, methods to show.
+            if (descriptor.value && descriptor.value.constructor
+                && descriptor.value.constructor !== Object
+                && descriptor.value.constructor !== Array
+                && descriptor.value.constructor !== RegExp)
                 preview.lossless = false;
-                continue;
-            }
+            return InjectedScript.PropertyFetchAction.Continue;
+        }
 
-            // Do not show "__proto__" in preview.
-            let name = descriptor.name;
-            if (name === "__proto__") {
-                // Non basic __proto__ objects may have interesting, non-enumerable, methods to show.
-                if (descriptor.value && descriptor.value.constructor
-                    && descriptor.value.constructor !== Object
-                    && descriptor.value.constructor !== Array
-                    && descriptor.value.constructor !== RegExp)
-                    preview.lossless = false;
-                continue;
-            }
+        // For arrays, only allow indexes.
+        if (this.subtype === "array" && !isUInt32(name))
+            return InjectedScript.PropertyFetchAction.Continue;
 
-            // For arrays, only allow indexes.
-            if (this.subtype === "array" && !isUInt32(name))
-                continue;
+        // Do not show non-enumerable non-own properties.
+        // Special case to allow array indexes that may be on the prototype.
+        // Special case to allow native getters on non-RegExp objects.
+        if (!descriptor.enumerable && !descriptor.isOwn && !(this.subtype === "array" || (this.subtype !== "regexp" && descriptor.nativeGetter)))
+            return InjectedScript.PropertyFetchAction.Continue;
 
-            // Do not show non-enumerable non-own properties.
-            // Special case to allow array indexes that may be on the prototype.
-            // Special case to allow native getters on non-RegExp objects.
-            if (!descriptor.enumerable && !descriptor.isOwn && !(this.subtype === "array" || (this.subtype !== "regexp" && descriptor.nativeGetter)))
-                continue;
+        // If we have a filter, only show properties in the filter.
+        // FIXME: Currently these filters do nothing on the backend.
+        if (firstLevelKeys && !firstLevelKeys.includes(name))
+            return InjectedScript.PropertyFetchAction.Continue;
 
-            // If we have a filter, only show properties in the filter.
-            // FIXME: Currently these filters do nothing on the backend.
-            if (firstLevelKeys && !firstLevelKeys.includes(name))
-                continue;
+        function appendPreview(property) {
+            if (toString(property.name >>> 0) === property.name)
+                propertiesThreshold.indexes--;
+            else
+                propertiesThreshold.properties--;
 
-            // Getter/setter.
-            if (!("value" in descriptor)) {
+            if (propertiesThreshold.indexes < 0 || propertiesThreshold.properties < 0) {
+                preview.overflow = true;
                 preview.lossless = false;
-                this._appendPropertyPreview(preview, internal, {name, type: "accessor"}, propertiesThreshold);
-                continue;
+                return InjectedScript.PropertyFetchAction.Stop;
             }
 
-            // Null value.
-            let value = descriptor.value;
-            if (value === null) {
-                this._appendPropertyPreview(preview, internal, {name, type: "object", subtype: "null", value: "null"}, propertiesThreshold);
-                continue;
-            }
+            if (internal)
+                property.internal = true;
 
-            // Ignore non-enumerable functions.
-            let type = typeof value;
-            if (!descriptor.enumerable && type === "function")
-                continue;
+            preview.properties.push(property);
+            return InjectedScript.PropertyFetchAction.Continue;
+        }
 
-            // Fix type of document.all.
-            if (InjectedScriptHost.isHTMLAllCollection(value))
-                type = "object";
+        // Getter/setter.
+        if (!("value" in descriptor)) {
+            preview.lossless = false;
+            return appendPreview({name, type: "accessor"});
+        }
 
-            // Primitive.
-            const maxLength = 100;
-            if (isPrimitiveValue(value) || isBigInt(value)) {
-                if (type === "string" && value.length > maxLength) {
-                    value = this._abbreviateString(value, maxLength, true);
-                    preview.lossless = false;
-                }
-                this._appendPropertyPreview(preview, internal, {name, type, value: toStringDescription(value)}, propertiesThreshold);
-                continue;
-            }
+        // Null value.
+        let value = descriptor.value;
+        if (value === null)
+            return appendPreview({name, type: "object", subtype: "null", value: "null"});
 
-            // Symbol.
-            if (isSymbol(value)) {
-                let symbolString = toString(value);
-                if (symbolString.length > maxLength) {
-                    symbolString = this._abbreviateString(symbolString, maxLength, true);
-                    preview.lossless = false;
-                }
-                this._appendPropertyPreview(preview, internal, {name, type, value: symbolString}, propertiesThreshold);
-                continue;
-            }
+        // Ignore non-enumerable functions.
+        let type = typeof value;
+        if (!descriptor.enumerable && type === "function")
+            return InjectedScript.PropertyFetchAction.Continue;
 
-            // Object.
-            let property = {name, type};
-            let subtype = RemoteObject.subtype(value);
-            if (subtype)
-                property.subtype = subtype;
-
-            // Second level.
-            if ((secondLevelKeys === null || secondLevelKeys) || this._isPreviewableObject(value, object)) {
-                // FIXME: If we want secondLevelKeys filter to continue we would need some refactoring.
-                let subPreview = RemoteObject.createObjectPreviewForValue(value, value !== object, secondLevelKeys);
-                property.valuePreview = subPreview;
-                if (!subPreview.lossless)
-                    preview.lossless = false;
-                if (subPreview.overflow)
-                    preview.overflow = true;
-            } else {
-                let description = "";
-                if (type !== "function" || subtype === "class") {
-                    let fullDescription;
-                    if (subtype === "class")
-                        fullDescription = "class " + value.name;
-                    else if (subtype === "node")
-                        fullDescription = RemoteObject.nodePreview(value);
-                    else
-                        fullDescription = RemoteObject.describe(value);
-                    description = this._abbreviateString(fullDescription, maxLength, subtype === "regexp");
-                }
-                property.value = description;
+        // Fix type of document.all.
+        if (InjectedScriptHost.isHTMLAllCollection(value))
+            type = "object";
+
+        // Primitive.
+        const maxLength = 100;
+        if (isPrimitiveValue(value) || isBigInt(value)) {
+            if (type === "string" && value.length > maxLength) {
+                value = this._abbreviateString(value, maxLength, true);
                 preview.lossless = false;
             }
+            return appendPreview({name, type, value: toStringDescription(value)});
+        }
 
-            this._appendPropertyPreview(preview, internal, property, propertiesThreshold);
+        // Symbol.
+        if (isSymbol(value)) {
+            let symbolString = toString(value);
+            if (symbolString.length > maxLength) {
+                symbolString = this._abbreviateString(symbolString, maxLength, true);
+                preview.lossless = false;
+            }
+            return appendPreview({name, type, value: symbolString});
         }
-    }
 
-    _appendPropertyPreview(preview, internal, property, propertiesThreshold)
-    {
-        if (toString(property.name >>> 0) === property.name)
-            propertiesThreshold.indexes--;
-        else
-            propertiesThreshold.properties--;
+        // Object.
+        let property = {name, type};
+        let subtype = RemoteObject.subtype(value);
+        if (subtype)
+            property.subtype = subtype;
 
-        if (propertiesThreshold.indexes < 0 || propertiesThreshold.properties < 0) {
-            preview.overflow = true;
+        // Second level.
+        if ((secondLevelKeys === null || secondLevelKeys) || this._isPreviewableObject(value, object)) {
+            // FIXME: If we want secondLevelKeys filter to continue we would need some refactoring.
+            let subPreview = RemoteObject.createObjectPreviewForValue(value, value !== object, secondLevelKeys);
+            property.valuePreview = subPreview;
+            if (!subPreview.lossless)
+                preview.lossless = false;
+            if (subPreview.overflow)
+                preview.overflow = true;
+        } else {
+            let description = "";
+            if (type !== "function" || subtype === "class") {
+                let fullDescription;
+                if (subtype === "class")
+                    fullDescription = "class " + value.name;
+                else if (subtype === "node")
+                    fullDescription = RemoteObject.nodePreview(value);
+                else
+                    fullDescription = RemoteObject.describe(value);
+                description = this._abbreviateString(fullDescription, maxLength, subtype === "regexp");
+            }
+            property.value = description;
             preview.lossless = false;
-            return;
         }
 
-        if (internal)
-            property.internal = true;
-
-        preview.properties.push(property);
+        return appendPreview(property);
     }
 
     _appendEntryPreviews(object, preview)
     {
         // Fetch 6, but only return 5, so we can tell if we overflowed.
@@ -1447,33 +1464,33 @@
 
 function CommandLineAPI(callFrame)
 {
     let savedResultAlias = InjectedScriptHost.savedResultAlias;
 
-    let defineGetter = (key, value) => {
-        if (typeof value !== "function") {
+    let defineGetter = (key, value, wrap) => {
+        if (wrap) {
             let originalValue = value;
             value = function() { return originalValue; };
         }
 
         this.__defineGetter__("$" + key, value);
         if (savedResultAlias && savedResultAlias !== "$")
             this.__defineGetter__(savedResultAlias + key, value);
     };
 
     if ("_lastResult" in injectedScript)
-        defineGetter("_", injectedScript._lastResult);
+        defineGetter("_", injectedScript._lastResult, true);
 
     if ("_exceptionValue" in injectedScript)
-        defineGetter("exception", injectedScript._exceptionValue);
+        defineGetter("exception", injectedScript._exceptionValue, true);
 
     if ("_eventValue" in injectedScript)
-        defineGetter("event", injectedScript._eventValue);
+        defineGetter("event", injectedScript._eventValue, true);
 
     // $1-$99
     for (let i = 1; i < injectedScript._savedResults.length; ++i)
-        defineGetter(i, injectedScript._savedResults[i]);
+        defineGetter(i, injectedScript._savedResults[i], true);
 
     for (let name in CommandLineAPI.getters)
         defineGetter(name, CommandLineAPI.getters[name]);
 
     for (let name in CommandLineAPI.methods)

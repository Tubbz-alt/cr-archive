<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGShape.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderSVGResourcePattern.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderSVGShape.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGShape.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 77,11 ***</span>
  
  RenderSVGShape::~RenderSVGShape() = default;
  
  void RenderSVGShape::updateShapeFromElement()
  {
<span class="line-modified">!     m_path = makeUnique&lt;Path&gt;(pathFromGraphicsElement(&amp;graphicsElement()));</span>
      processMarkerPositions();
  
      m_fillBoundingBox = calculateObjectBoundingBox();
      m_strokeBoundingBox = calculateStrokeBoundingBox();
  }
<span class="line-new-header">--- 77,11 ---</span>
  
  RenderSVGShape::~RenderSVGShape() = default;
  
  void RenderSVGShape::updateShapeFromElement()
  {
<span class="line-modified">!     m_path = createPath();</span>
      processMarkerPositions();
  
      m_fillBoundingBox = calculateObjectBoundingBox();
      m_strokeBoundingBox = calculateStrokeBoundingBox();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 118,24 ***</span>
  
      if (hasNonScalingStroke() &amp;&amp; pointCoordinateSpace != LocalCoordinateSpace) {
          AffineTransform nonScalingTransform = nonScalingStrokeTransform();
          Path* usePath = nonScalingStrokePath(m_path.get(), nonScalingTransform);
  
<span class="line-modified">!         return usePath-&gt;strokeContains(&amp;applier, nonScalingTransform.mapPoint(point));</span>
      }
  
<span class="line-modified">!     return m_path-&gt;strokeContains(&amp;applier, point);</span>
  }
  
  bool RenderSVGShape::shapeDependentFillContains(const FloatPoint&amp; point, const WindRule fillRule) const
  {
      return path().contains(point, fillRule);
  }
  
  bool RenderSVGShape::fillContains(const FloatPoint&amp; point, bool requiresFill, const WindRule fillRule)
  {
<span class="line-modified">!     if (!m_fillBoundingBox.contains(point))</span>
          return false;
  
      Color fallbackColor;
      if (requiresFill &amp;&amp; !RenderSVGResource::fillPaintingResource(*this, style(), fallbackColor))
          return false;
<span class="line-new-header">--- 118,24 ---</span>
  
      if (hasNonScalingStroke() &amp;&amp; pointCoordinateSpace != LocalCoordinateSpace) {
          AffineTransform nonScalingTransform = nonScalingStrokeTransform();
          Path* usePath = nonScalingStrokePath(m_path.get(), nonScalingTransform);
  
<span class="line-modified">!         return usePath-&gt;strokeContains(applier, nonScalingTransform.mapPoint(point));</span>
      }
  
<span class="line-modified">!     return m_path-&gt;strokeContains(applier, point);</span>
  }
  
  bool RenderSVGShape::shapeDependentFillContains(const FloatPoint&amp; point, const WindRule fillRule) const
  {
      return path().contains(point, fillRule);
  }
  
  bool RenderSVGShape::fillContains(const FloatPoint&amp; point, bool requiresFill, const WindRule fillRule)
  {
<span class="line-modified">!     if (m_fillBoundingBox.isEmpty() || !m_fillBoundingBox.contains(point))</span>
          return false;
  
      Color fallbackColor;
      if (requiresFill &amp;&amp; !RenderSVGResource::fillPaintingResource(*this, style(), fallbackColor))
          return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 143,11 ***</span>
      return shapeDependentFillContains(point, fillRule);
  }
  
  bool RenderSVGShape::strokeContains(const FloatPoint&amp; point, bool requiresStroke)
  {
<span class="line-modified">!     if (!strokeBoundingBox().contains(point))</span>
          return false;
  
      Color fallbackColor;
      if (requiresStroke &amp;&amp; !RenderSVGResource::strokePaintingResource(*this, style(), fallbackColor))
          return false;
<span class="line-new-header">--- 143,11 ---</span>
      return shapeDependentFillContains(point, fillRule);
  }
  
  bool RenderSVGShape::strokeContains(const FloatPoint&amp; point, bool requiresStroke)
  {
<span class="line-modified">!     if (strokeBoundingBox().isEmpty() || !strokeBoundingBox().contains(point))</span>
          return false;
  
      Color fallbackColor;
      if (requiresStroke &amp;&amp; !RenderSVGResource::strokePaintingResource(*this, style(), fallbackColor))
          return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 345,23 ***</span>
      return shapeDependentStrokeContains(point, LocalCoordinateSpace);
  }
  
  float RenderSVGShape::getTotalLength() const
  {
<span class="line-modified">!     if (m_path)</span>
<span class="line-removed">-         return m_path-&gt;length();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return 0;</span>
  }
  
<span class="line-modified">! void RenderSVGShape::getPointAtLength(FloatPoint&amp; point, float distance) const</span>
  {
<span class="line-modified">!     if (!m_path)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     bool isValid;</span>
<span class="line-removed">-     point = m_path-&gt;pointAtLength(distance, isValid);</span>
  }
  
  bool RenderSVGShape::nodeAtFloatPoint(const HitTestRequest&amp; request, HitTestResult&amp; result, const FloatPoint&amp; pointInParent, HitTestAction hitTestAction)
  {
      // We only draw in the forground phase, so we only hit-test then.
<span class="line-new-header">--- 345,16 ---</span>
      return shapeDependentStrokeContains(point, LocalCoordinateSpace);
  }
  
  float RenderSVGShape::getTotalLength() const
  {
<span class="line-modified">!     return hasPath() ? path().length() : createPath()-&gt;length();</span>
  }
  
<span class="line-modified">! FloatPoint RenderSVGShape::getPointAtLength(float distance) const</span>
  {
<span class="line-modified">!     return hasPath() ? path().pointAtLength(distance) : createPath()-&gt;pointAtLength(distance);</span>
  }
  
  bool RenderSVGShape::nodeAtFloatPoint(const HitTestRequest&amp; request, HitTestResult&amp; result, const FloatPoint&amp; pointInParent, HitTestAction hitTestAction)
  {
      // We only draw in the forground phase, so we only hit-test then.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 379,11 ***</span>
          const SVGRenderStyle&amp; svgStyle = style().svgStyle();
          WindRule fillRule = svgStyle.fillRule();
          if (request.svgClipContent())
              fillRule = svgStyle.clipRule();
          if ((hitRules.canHitStroke &amp;&amp; (svgStyle.hasStroke() || !hitRules.requireStroke) &amp;&amp; strokeContains(localPoint, hitRules.requireStroke))
<span class="line-modified">!             || (hitRules.canHitFill &amp;&amp; (svgStyle.hasFill() || !hitRules.requireFill) &amp;&amp; fillContains(localPoint, hitRules.requireFill, fillRule))) {</span>
              updateHitTestResult(result, LayoutPoint(localPoint));
              if (result.addNodeToListBasedTestResult(&amp;graphicsElement(), request, localPoint) == HitTestProgress::Stop)
                  return true;
          }
      }
<span class="line-new-header">--- 372,12 ---</span>
          const SVGRenderStyle&amp; svgStyle = style().svgStyle();
          WindRule fillRule = svgStyle.fillRule();
          if (request.svgClipContent())
              fillRule = svgStyle.clipRule();
          if ((hitRules.canHitStroke &amp;&amp; (svgStyle.hasStroke() || !hitRules.requireStroke) &amp;&amp; strokeContains(localPoint, hitRules.requireStroke))
<span class="line-modified">!             || (hitRules.canHitFill &amp;&amp; (svgStyle.hasFill() || !hitRules.requireFill) &amp;&amp; fillContains(localPoint, hitRules.requireFill, fillRule))</span>
<span class="line-added">+             || (hitRules.canHitBoundingBox &amp;&amp; objectBoundingBox().contains(localPoint))) {</span>
              updateHitTestResult(result, LayoutPoint(localPoint));
              if (result.addNodeToListBasedTestResult(&amp;graphicsElement(), request, localPoint) == HitTestProgress::Stop)
                  return true;
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 500,10 ***</span>
<span class="line-new-header">--- 494,15 ---</span>
          if (RenderSVGResourceMarker* marker = markerForType(m_markerPositions[i].type, markerStart, markerMid, markerEnd))
              marker-&gt;draw(paintInfo, marker-&gt;markerTransformation(m_markerPositions[i].origin, m_markerPositions[i].angle, strokeWidth));
      }
  }
  
<span class="line-added">+ std::unique_ptr&lt;Path&gt; RenderSVGShape::createPath() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return makeUnique&lt;Path&gt;(pathFromGraphicsElement(&amp;graphicsElement()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void RenderSVGShape::processMarkerPositions()
  {
      m_markerPositions.clear();
  
      if (!shouldGenerateMarkerPositions())
</pre>
<center><a href="RenderSVGResourcePattern.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderSVGShape.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/transform.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 # Copyright (C) 2011 Apple Inc. All rights reserved.
  2 #
  3 # Redistribution and use in source and binary forms, with or without
  4 # modification, are permitted provided that the following conditions
  5 # are met:
  6 # 1. Redistributions of source code must retain the above copyright
  7 #    notice, this list of conditions and the following disclaimer.
  8 # 2. Redistributions in binary form must reproduce the above copyright
  9 #    notice, this list of conditions and the following disclaimer in the
 10 #    documentation and/or other materials provided with the distribution.
 11 #
 12 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 13 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 14 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 15 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 16 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 17 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 18 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 19 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 20 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 21 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 22 # THE POSSIBILITY OF SUCH DAMAGE.
 23 
 24 require &quot;config&quot;
 25 require &quot;ast&quot;
 26 
 27 #
 28 # node.resolveSettings(settings)
 29 #
 30 # Construct a new AST that does not have any IfThenElse nodes by
 31 # substituting concrete boolean values for each Setting.
 32 #
 33 
 34 class Node
 35     def resolveSettings(settings)
 36         mapChildren {
 37             | child |
 38             child.resolveSettings(settings)
 39         }
 40     end
 41 end
 42 
 43 class True
 44     def resolveSettings(settings)
 45         self
 46     end
 47 end
 48 
 49 class False
 50     def resolveSettings(settings)
 51         self
 52     end
 53 end
 54 
 55 class Setting
 56     def resolveSettings(settings)
 57         settings[@name].asNode
 58     end
 59 end
 60 
 61 class And
 62     def resolveSettings(settings)
 63         (@left.resolveSettings(settings).value and @right.resolveSettings(settings).value).asNode
 64     end
 65 end
 66 
 67 class Or
 68     def resolveSettings(settings)
 69         (@left.resolveSettings(settings).value or @right.resolveSettings(settings).value).asNode
 70     end
 71 end
 72 
 73 class Not
 74     def resolveSettings(settings)
 75         (not @child.resolveSettings(settings).value).asNode
 76     end
 77 end
 78 
 79 class IfThenElse
 80     def resolveSettings(settings)
 81         if @predicate.resolveSettings(settings).value
 82             @thenCase.resolveSettings(settings)
 83         else
 84             @elseCase.resolveSettings(settings)
 85         end
 86     end
 87 end
 88 
 89 class Sequence
 90     def resolveSettings(settings)
 91         newList = []
 92         @list.each {
 93             | item |
 94             item = item.resolveSettings(settings)
 95             if item.is_a? Sequence
 96                 newList += item.list
 97             else
 98                 newList &lt;&lt; item
 99             end
100         }
101         Sequence.new(codeOrigin, newList)
102     end
103 end
104 
105 #
106 # node.demacroify(macros)
107 # node.substitute(mapping)
108 #
109 # demacroify() constructs a new AST that does not have any Macro
110 # nodes, while substitute() replaces Variable nodes with the given
111 # nodes in the mapping.
112 #
113 
114 class Node
115     def demacroify(macros)
116         mapChildren {
117             | child |
118             child.demacroify(macros)
119         }
120     end
121 
122     def freshVariables(mapping)
123         mapChildren {
124             | child |
125             child.freshVariables(mapping)
126         }
127     end
128 
129     def substitute(mapping)
130         mapChildren {
131             | child |
132             child.substitute(mapping)
133         }
134     end
135     
136     def substituteLabels(mapping)
137         mapChildren {
138             | child |
139             child.substituteLabels(mapping)
140         }
141     end
142 end
143 
144 $uniqueMacroVarID = 0
145 class Macro
146     def freshVariables(mapping = {})
147         myMapping = mapping.dup
148         newVars = []
149         variables.each do |var|
150             $uniqueMacroVarID += 1
151             newVar = Variable.forName(var.codeOrigin, &quot;_var#{$uniqueMacroVarID}&quot;, var.originalName)
152             newVars &lt;&lt; newVar
153             myMapping[var] = newVar
154         end
155         Macro.new(codeOrigin, name, newVars, body.freshVariables(myMapping))
156     end
157 
158     def substitute(mapping)
159         myMapping = {}
160         mapping.each_pair {
161             | key, value |
162             unless @variables.include? key
163                 myMapping[key] = value
164             end
165         }
166         mapChildren {
167             | child |
168             child.substitute(myMapping)
169         }
170     end
171 end
172 
173 class MacroCall
174     def freshVariables(mapping)
175         newName = Variable.forName(codeOrigin, name, originalName)
176         if mapping[newName]
177             newName = mapping[newName]
178         end
179         newOperands = operands.map { |operand| operand.freshVariables(mapping) }
180         MacroCall.new(codeOrigin, newName.name, newOperands, annotation, originalName)
181     end
182 end
183 
184 $concatenation = /%([a-zA-Z0-9_]+)%/
185 class Variable
186     def freshVariables(mapping)
187         if @name =~ $concatenation
188             name = @name.gsub($concatenation) { |match|
189                 var = Variable.forName(codeOrigin, match[1...-1])
190                 if mapping[var]
191                     &quot;%#{mapping[var].name}%&quot;
192                 else
193                     match
194                 end
195             }
196             Variable.forName(codeOrigin, name)
197         elsif mapping[self]
198             mapping[self]
199         else
200             self
201         end
202     end
203 
204     def substitute(mapping)
205         if @name =~ $concatenation
206             name = @name.gsub($concatenation) { |match|
207                 var = Variable.forName(codeOrigin, match[1...-1])
208                 if mapping[var]
209                     mapping[var].name
210                 else
211                     match
212                 end
213             }
214             Variable.forName(codeOrigin, name)
215         elsif mapping[self]
216             mapping[self]
217         else
218             self
219         end
220     end
221 end
222 
223 class StructOffset
224     def freshVariables(mapping)
225         if dump =~ $concatenation
226             names = dump.gsub($concatenation) { |match|
227                 var = Variable.forName(codeOrigin, match[1...-1])
228                 if mapping[var]
229                     &quot;%#{mapping[var].name}%&quot;
230                 else
231                     match
232                 end
233             }.split(&#39;::&#39;)
234             StructOffset.forField(codeOrigin, names[0..-2].join(&#39;::&#39;), names[-1])
235         else
236             self
237         end
238     end
239 
240     def substitute(mapping)
241         if dump =~ $concatenation
242             names = dump.gsub($concatenation) { |match|
243                 var = Variable.forName(codeOrigin, match[1...-1])
244                 if mapping[var]
245                     mapping[var].name
246                 else
247                     match
248                 end
249             }.split(&#39;::&#39;)
250             StructOffset.forField(codeOrigin, names[0..-2].join(&#39;::&#39;), names[-1])
251         else
252             self
253         end
254     end
255 end
256 
257 class Label
258     def freshVariables(mapping)
259         if @name =~ $concatenation
260             name = @name.gsub($concatenation) { |match|
261                 var = Variable.forName(codeOrigin, match[1...-1])
262                 if mapping[var]
263                     &quot;%#{mapping[var].name}%&quot;
264                 else
265                     match
266                 end
267             }
268             result = Label.forName(codeOrigin, name, @definedInFile)
269             result.setGlobal() if global?
270             result.clearExtern unless extern?
271             result
272         else
273             self
274         end
275     end
276 
277     def substitute(mapping)
278         if @name =~ $concatenation
279             name = @name.gsub($concatenation) { |match|
280                 var = Variable.forName(codeOrigin, match[1...-1])
281                 if mapping[var]
282                     mapping[var].name
283                 else
284                     match
285                 end
286             }
287             result = Label.forName(codeOrigin, name, @definedInFile)
288             result.setGlobal() if global?
289             result.clearExtern unless extern?
290             result
291         else
292             self
293         end
294     end
295 end
296 
297 class ConstExpr
298     def freshVariables(mapping)
299         if @value =~ $concatenation
300             value = @value.gsub($concatenation) { |match|
301                 var = Variable.forName(codeOrigin, match[1...-1])
302                 if mapping[var]
303                     &quot;%#{mapping[var].name}%&quot;
304                 else
305                     match
306                 end
307             }
308             ConstExpr.forName(codeOrigin, value)
309         else
310             self
311         end
312     end
313 
314     def substitute(mapping)
315         if @value =~ $concatenation
316             value = @value.gsub($concatenation) { |match|
317                 var = Variable.forName(codeOrigin, match[1...-1])
318                 if mapping[var]
319                     mapping[var].name
320                 else
321                     match
322                 end
323             }
324             ConstExpr.forName(codeOrigin, value)
325         else
326             self
327         end
328     end
329 end
330 
331 class Sizeof
332     def freshVariables(mapping)
333         if struct =~ $concatenation
334             value = struct.gsub($concatenation) { |match|
335                 var = Variable.forName(codeOrigin, match[1...-1])
336                 if mapping[var]
337                     &quot;%#{mapping[var].name}%&quot;
338                 else
339                     match
340                 end
341             }
342             Sizeof.forName(codeOrigin, value)
343         else
344             self
345         end
346     end
347 
348     def substitute(mapping)
349         if struct =~ $concatenation
350             value = struct.gsub($concatenation) { |match|
351                 var = Variable.forName(codeOrigin, match[1...-1])
352                 if mapping[var]
353                     mapping[var].name
354                 else
355                     match
356                 end
357             }
358             Sizeof.forName(codeOrigin, value)
359         else
360             self
361         end
362     end
363 end
364 
365 class LocalLabel
366     def substituteLabels(mapping)
367         if mapping[self]
368             mapping[self]
369         else
370             self
371         end
372     end
373 end
374 
375 class MacroError &lt; StandardError
376 end
377 
378 class Sequence
379     def substitute(constants)
380         newList = []
381         myConstants = constants.dup
382         @list.each {
383             | item |
384             if item.is_a? ConstDecl
385                 myConstants[item.variable] = item.value.substitute(myConstants)
386             else
387                 newList &lt;&lt; item.substitute(myConstants)
388             end
389         }
390         Sequence.new(codeOrigin, newList)
391     end
392     
393     def renameLabels(comment)
394         mapping = {}
395         
396         @list.each {
397             | item |
398             if item.is_a? LocalLabel
399                 mapping[item] = LocalLabel.unique(if comment then comment + &quot;_&quot; else &quot;&quot; end + item.cleanName)
400             end
401         }
402         
403         substituteLabels(mapping)
404     end
405     
406     @@demacroifyStack = []
407     def macroError(msg)
408         backtrace = @@demacroifyStack.reverse.map { |macroCall|
409             &quot;#{macroCall.codeOrigin} in call to #{macroCall.originalName}&quot;
410         }
411         raise MacroError, msg, backtrace
412     end
413 
414     def demacroify(macros)
415         myMacros = macros.dup
416         # We do an initial pass looking for all macros in order to allow forward references
417         @list.each {
418             | item |
419             if item.is_a? Macro
420                 myMacros[item.name] = item.freshVariables
421             end
422         }
423         newList = []
424         @list.each {
425             | item |
426             if item.is_a? Macro
427                 # Ignore. We already looked for macros above and they should not be part of the final output
428             elsif item.is_a? MacroCall
429                 @@demacroifyStack &lt;&lt; item
430                 mapping = {}
431                 myMyMacros = myMacros.dup
432                 macro = myMacros[item.name]
433                 macroError &quot;Could not find macro #{item.originalName}&quot; unless macro
434                 macroError &quot;Argument count mismatch for call to #{item.originalName} (expected #{macro.variables.size} but got #{item.operands.size} arguments for macro #{item.originalName} defined at #{macro.codeOrigin})&quot; unless item.operands.size == macro.variables.size
435                 item.operands.size.times {
436                     | idx |
437                     if item.operands[idx].is_a? Variable and myMacros[item.operands[idx].name]
438                         myMyMacros[macro.variables[idx].name] = myMacros[item.operands[idx].name]
439                         mapping[macro.variables[idx]] = nil
440                     elsif item.operands[idx].is_a? Macro
441                         myMyMacros[macro.variables[idx].name] = item.operands[idx].freshVariables
442                         mapping[macro.variables[idx]] = nil
443                     else
444                         myMyMacros[macro.variables[idx]] = nil
445                         mapping[macro.variables[idx]] = item.operands[idx]
446                     end
447                 }
448                 if item.annotation
449                     newList &lt;&lt; Instruction.new(item.codeOrigin, &quot;localAnnotation&quot;, [], item.annotation)
450                 end
451                 newList += macro.body.substitute(mapping).demacroify(myMyMacros).renameLabels(item.originalName).list
452 
453                 @@demacroifyStack.pop
454             else
455                 newList &lt;&lt; item.demacroify(myMacros)
456             end
457         }
458         Sequence.new(codeOrigin, newList).substitute({})
459     end
460 end
461 
462 #
463 # node.resolveOffsets(offsets, sizes)
464 #
465 # Construct a new AST that has offset values instead of symbolic
466 # offsets.
467 #
468 
469 class Node
470     def resolveOffsets(constantsMap)
471         mapChildren {
472             | child |
473             child.resolveOffsets(constantsMap)
474         }
475     end
476 end
477 
478 class StructOffset
479     def resolveOffsets(constantsMap)
480         if constantsMap[self]
481             Immediate.new(codeOrigin, constantsMap[self])
482         else
483             puts &quot;Could not find #{self.inspect} in #{constantsMap.keys.inspect}&quot;
484             puts &quot;sizes = #{constantsMap.inspect}&quot;
485             raise
486         end
487     end
488 end
489 
490 class Sizeof
491     def resolveOffsets(constantsMap)
492         if constantsMap[self]
493             Immediate.new(codeOrigin, constantsMap[self])
494         else
495             puts &quot;Could not find #{self.inspect} in #{constantsMap.keys.inspect}&quot;
496             puts &quot;sizes = #{constantsMap.inspect}&quot;
497             raise
498         end
499     end
500 end
501 
502 class ConstExpr
503     def resolveOffsets(constantsMap)
504         if constantsMap[self]
505             Immediate.new(codeOrigin, constantsMap[self])
506         else
507             puts &quot;Could not find #{self.inspect} in #{constantsMap.keys.inspect}&quot;
508             puts &quot;sizes = #{constantsMap.inspect}&quot;
509             raise
510         end
511     end
512 end
513 
514 #
515 # node.fold
516 #
517 # Resolve constant references and compute arithmetic expressions.
518 #
519 
520 class Node
521     def fold
522         mapChildren {
523             | child |
524             child.fold
525         }
526     end
527 end
528 
529 class AddImmediates
530     def fold
531         @left = @left.fold
532         @right = @right.fold
533         
534         return right.plusOffset(@left.value) if @left.is_a? Immediate and @right.is_a? LabelReference
535         return left.plusOffset(@right.value) if @left.is_a? LabelReference and @right.is_a? Immediate
536         
537         return self unless @left.is_a? Immediate
538         return self unless @right.is_a? Immediate
539         Immediate.new(codeOrigin, @left.value + @right.value)
540     end
541 end
542 
543 class SubImmediates
544     def fold
545         @left = @left.fold
546         @right = @right.fold
547         
548         return left.plusOffset(-@right.value) if @left.is_a? LabelReference and @right.is_a? Immediate
549         
550         return self unless @left.is_a? Immediate
551         return self unless @right.is_a? Immediate
552         Immediate.new(codeOrigin, @left.value - @right.value)
553     end
554 end
555 
556 class MulImmediates
557     def fold
558         @left = @left.fold
559         @right = @right.fold
560         return self unless @left.is_a? Immediate
561         return self unless @right.is_a? Immediate
562         Immediate.new(codeOrigin, @left.value * @right.value)
563     end
564 end
565 
566 class NegImmediate
567     def fold
568         @child = @child.fold
569         return self unless @child.is_a? Immediate
570         Immediate.new(codeOrigin, -@child.value)
571     end
572 end
573 
574 class OrImmediates
575     def fold
576         @left = @left.fold
577         @right = @right.fold
578         return self unless @left.is_a? Immediate
579         return self unless @right.is_a? Immediate
580         Immediate.new(codeOrigin, @left.value | @right.value)
581     end
582 end
583 
584 class AndImmediates
585     def fold
586         @left = @left.fold
587         @right = @right.fold
588         return self unless @left.is_a? Immediate
589         return self unless @right.is_a? Immediate
590         Immediate.new(codeOrigin, @left.value &amp; @right.value)
591     end
592 end
593 
594 class XorImmediates
595     def fold
596         @left = @left.fold
597         @right = @right.fold
598         return self unless @left.is_a? Immediate
599         return self unless @right.is_a? Immediate
600         Immediate.new(codeOrigin, @left.value ^ @right.value)
601     end
602 end
603 
604 class BitnotImmediate
605     def fold
606         @child = @child.fold
607         return self unless @child.is_a? Immediate
608         Immediate.new(codeOrigin, ~@child.value)
609     end
610 end
611 
612 #
613 # node.resolveAfterSettings(offsets, sizes)
614 #
615 # Compile assembly against a set of offsets.
616 #
617 
618 class Node
619     def resolve(constantsMap)
620         demacroify({}).resolveOffsets(constantsMap).fold
621     end
622 end
623 
624 #
625 # node.validate
626 #
627 # Checks that the node is ready for backend compilation.
628 #
629 
630 class Node
631     def validate
632         raise &quot;Unresolved #{dump} at #{codeOriginString}&quot;
633     end
634     
635     def validateChildren
636         children.each {
637             | node |
638             node.validate
639         }
640     end
641 end
642 
643 class Sequence
644     def validate
645         validateChildren
646         
647         # Further verify that this list contains only instructions, labels, and skips.
648         @list.each {
649             | node |
650             unless node.is_a? Instruction or
651                     node.is_a? Label or
652                     node.is_a? LocalLabel or
653                     node.is_a? Skip
654                 raise &quot;Unexpected #{node.inspect} at #{node.codeOrigin}&quot; 
655             end
656         }
657     end
658 end
659 
660 class Immediate
661     def validate
662     end
663 end
664 
665 class StringLiteral
666     def validate
667     end
668 end
669 
670 class RegisterID
671     def validate
672     end
673 end
674 
675 class FPRegisterID
676     def validate
677     end
678 end
679 
680 class Address
681     def validate
682         validateChildren
683     end
684 end
685 
686 class BaseIndex
687     def validate
688         validateChildren
689     end
690 end
691 
692 class AbsoluteAddress
693     def validate
694         validateChildren
695     end
696 end
697 
698 class Instruction
699     def validate
700         validateChildren
701     end
702 end
703 
704 class SubImmediates
705     def validate
706       raise &quot;Invalid operand #{left.dump} to immediate subtraction&quot; unless left.immediateOperand?
707       raise &quot;Invalid operand #{right.dump} to immediate subtraction&quot; unless right.immediateOperand?
708     end
709 end
710 
711 class Error
712     def validate
713     end
714 end
715 
716 class Label
717     def validate
718         raise &quot;Unresolved substitution in Label #{name} at #{codeOrigin}&quot; if name =~ /%/
719     end
720 end
721 
722 class LocalLabel
723     def validate
724     end
725 end
726 
727 class LabelReference
728     def validate
729     end
730 end
731 
732 class LocalLabelReference
733     def validate
734     end
735 end
736 
737 class Skip
738     def validate
739     end
740 end
    </pre>
  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PolymorphicAccess.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PolymorphicAccess.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PolymorphicAccess.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PolymorphicAccess.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2014-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2014-2020 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -43,10 +43,12 @@
 class PolymorphicAccess;
 class StructureStubInfo;
 class WatchpointsOnStructureStubInfo;
 class ScratchRegisterAllocator;
 
+DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(PolymorphicAccess);
+
 class AccessGenerationResult {
 public:
     enum Kind {
         MadeNoChanges,
         GaveUp,
@@ -127,30 +129,32 @@
     Vector<std::pair<InlineWatchpointSet&, StringFireDetail>> m_watchpointsToFire;
 };
 
 class PolymorphicAccess {
     WTF_MAKE_NONCOPYABLE(PolymorphicAccess);
-    WTF_MAKE_FAST_ALLOCATED;
+    WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(PolymorphicAccess);
 public:
     PolymorphicAccess();
     ~PolymorphicAccess();
 
     // When this fails (returns GaveUp), this will leave the old stub intact but you should not try
     // to call this method again for that PolymorphicAccess instance.
     AccessGenerationResult addCases(
-        const GCSafeConcurrentJSLocker&, VM&, CodeBlock*, StructureStubInfo&, const Identifier&, Vector<std::unique_ptr<AccessCase>, 2>);
+        const GCSafeConcurrentJSLocker&, VM&, CodeBlock*, StructureStubInfo&, Vector<std::unique_ptr<AccessCase>, 2>);
 
     AccessGenerationResult addCase(
-        const GCSafeConcurrentJSLocker&, VM&, CodeBlock*, StructureStubInfo&, const Identifier&, std::unique_ptr<AccessCase>);
+        const GCSafeConcurrentJSLocker&, VM&, CodeBlock*, StructureStubInfo&, std::unique_ptr<AccessCase>);
 
-    AccessGenerationResult regenerate(const GCSafeConcurrentJSLocker&, VM&, CodeBlock*, StructureStubInfo&, const Identifier&);
+    AccessGenerationResult regenerate(const GCSafeConcurrentJSLocker&, VM&, CodeBlock*, StructureStubInfo&);
 
     bool isEmpty() const { return m_list.isEmpty(); }
     unsigned size() const { return m_list.size(); }
     const AccessCase& at(unsigned i) const { return *m_list[i]; }
     const AccessCase& operator[](unsigned i) const { return *m_list[i]; }
 
+    void visitAggregate(SlotVisitor&);
+
     // If this returns false then we are requesting a reset of the owning StructureStubInfo.
     bool visitWeak(VM&) const;
 
     // This returns true if it has marked everything it will ever marked. This can be used as an
     // optimization to then avoid calling this method again during the fixpoint.
@@ -175,11 +179,11 @@
 
     typedef Vector<std::unique_ptr<AccessCase>, 2> ListType;
 
     void commit(
         const GCSafeConcurrentJSLocker&, VM&, std::unique_ptr<WatchpointsOnStructureStubInfo>&, CodeBlock*, StructureStubInfo&,
-        const Identifier&, AccessCase&);
+        AccessCase&);
 
     ListType m_list;
     RefPtr<JITStubRoutine> m_stubRoutine;
     std::unique_ptr<WatchpointsOnStructureStubInfo> m_watchpoints;
     std::unique_ptr<Vector<WriteBarrier<JSCell>>> m_weakReferences;
@@ -191,10 +195,11 @@
         , m_globalObject(globalObject)
         , m_calculatedRegistersForCallAndExceptionHandling(false)
         , m_needsToRestoreRegistersIfException(false)
         , m_calculatedCallSiteIndex(false)
     {
+        u.thisGPR = InvalidGPRReg;
     }
     VM& m_vm;
     JSGlobalObject* m_globalObject;
     CCallHelpers* jit { nullptr };
     ScratchRegisterAllocator* allocator;
@@ -203,18 +208,23 @@
     StructureStubInfo* stubInfo { nullptr };
     MacroAssembler::JumpList success;
     MacroAssembler::JumpList failAndRepatch;
     MacroAssembler::JumpList failAndIgnore;
     GPRReg baseGPR { InvalidGPRReg };
-    GPRReg thisGPR { InvalidGPRReg };
+    union {
+        GPRReg thisGPR;
+        GPRReg prototypeGPR;
+        GPRReg propertyGPR;
+    } u;
     JSValueRegs valueRegs;
     GPRReg scratchGPR { InvalidGPRReg };
-    const Identifier* ident;
+    FPRReg scratchFPR { InvalidFPRReg };
     std::unique_ptr<WatchpointsOnStructureStubInfo> watchpoints;
     Vector<WriteBarrier<JSCell>> weakReferences;
+    Bag<CallLinkInfo> m_callLinkInfos;
 
-    Watchpoint* addWatchpoint(const ObjectPropertyCondition& = ObjectPropertyCondition());
+    void installWatchpoint(const ObjectPropertyCondition&);
 
     void restoreScratch();
     void succeed();
 
     struct SpillState {

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/ScrollView.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScrollView.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScrollableArea.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/ScrollView.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
103     // Functions for setting and retrieving the scrolling mode in each axis (horizontal/vertical). The mode has values of
104     // AlwaysOff, AlwaysOn, and Auto. AlwaysOff means never show a scrollbar, AlwaysOn means always show a scrollbar.
105     // Auto means show a scrollbar only when one is needed.
106     // Note that for platforms with native widgets, these modes are considered advisory. In other words the underlying native
107     // widget may choose not to honor the requested modes.
108     WEBCORE_EXPORT void setScrollbarModes(ScrollbarMode horizontalMode, ScrollbarMode verticalMode, bool horizontalLock = false, bool verticalLock = false);
109     void setHorizontalScrollbarMode(ScrollbarMode mode, bool lock = false) { setScrollbarModes(mode, verticalScrollbarMode(), lock, verticalScrollbarLock()); }
110     void setVerticalScrollbarMode(ScrollbarMode mode, bool lock = false) { setScrollbarModes(horizontalScrollbarMode(), mode, horizontalScrollbarLock(), lock); };
111     WEBCORE_EXPORT void scrollbarModes(ScrollbarMode&amp; horizontalMode, ScrollbarMode&amp; verticalMode) const;
112     ScrollbarMode horizontalScrollbarMode() const final { ScrollbarMode horizontal, vertical; scrollbarModes(horizontal, vertical); return horizontal; }
113     ScrollbarMode verticalScrollbarMode() const final { ScrollbarMode horizontal, vertical; scrollbarModes(horizontal, vertical); return vertical; }
114 
115     void setHorizontalScrollbarLock(bool lock = true) { m_horizontalScrollbarLock = lock; }
116     bool horizontalScrollbarLock() const { return m_horizontalScrollbarLock; }
117     void setVerticalScrollbarLock(bool lock = true) { m_verticalScrollbarLock = lock; }
118     bool verticalScrollbarLock() const { return m_verticalScrollbarLock; }
119 
120     void setScrollingModesLock(bool lock = true) { m_horizontalScrollbarLock = m_verticalScrollbarLock = lock; }
121 
122     WEBCORE_EXPORT virtual void setCanHaveScrollbars(bool);
<span class="line-removed">123     bool canHaveScrollbars() const { return horizontalScrollbarMode() != ScrollbarAlwaysOff || verticalScrollbarMode() != ScrollbarAlwaysOff; }</span>
124 
125     virtual bool avoidScrollbarCreation() const { return false; }
126 
127     void setScrollbarOverlayStyle(ScrollbarOverlayStyle) final;
128 
129     // By default you only receive paint events for the area that is visible. In the case of using a
130     // tiled backing store, this function can be set, so that the view paints the entire contents.
131     bool paintsEntireContents() const { return m_paintsEntireContents; }
132     WEBCORE_EXPORT void setPaintsEntireContents(bool);
133 
134     // By default programmatic scrolling is handled by WebCore and not by the UI application.
135     // In the case of using a tiled backing store, this mode can be set, so that the scroll requests
136     // are delegated to the UI application.
137     bool delegatesScrolling() const { return m_delegatesScrolling; }
138     WEBCORE_EXPORT void setDelegatesScrolling(bool);
139 
140     // Overridden by FrameView to create custom CSS scrollbars if applicable.
141     virtual Ref&lt;Scrollbar&gt; createScrollbar(ScrollbarOrientation);
142 
<span class="line-modified">143     void styleDidChange();</span>
144 
145     // If the prohibits scrolling flag is set, then all scrolling in the view (even programmatic scrolling) is turned off.
146     void setProhibitsScrolling(bool b) { m_prohibitsScrolling = b; }
147     bool prohibitsScrolling() const { return m_prohibitsScrolling; }
148 
149     // Whether or not a scroll view will blit visible contents when it is scrolled. Blitting is disabled in situations
150     // where it would cause rendering glitches (such as with fixed backgrounds or when the view is partially transparent).
151     void setCanBlitOnScroll(bool);
152     bool canBlitOnScroll() const;
153 
154     // There are at least three types of contentInset. Usually we just care about WebCoreContentInset, which is the inset
155     // that is set on a Page that requires WebCore to move its layers to accomodate the inset. However, there are platform
156     // concepts that are similar on both iOS and Mac when there is a platformWidget(). Sometimes we need the Mac platform value
157     // for topContentInset, so when the TopContentInsetType is WebCoreOrPlatformContentInset, platformTopContentInset()
158     // will be returned instead of the value set on Page.
159     enum class TopContentInsetType { WebCoreContentInset, WebCoreOrPlatformContentInset };
160     virtual float topContentInset(TopContentInsetType = TopContentInsetType::WebCoreContentInset) const { return 0; }
161 
162     // The visible content rect has a location that is the scrolled offset of the document. The width and height are the unobscured viewport
163     // width and height. By default the scrollbars themselves are excluded from this rectangle, but an optional boolean argument allows them
164     // to be included.
165     // In the situation the client is responsible for the scrolling (ie. with a tiled backing store) it is possible to use
166     // the setFixedVisibleContentRect instead for the mainframe, though this must be updated manually, e.g just before resuming the page
167     // which usually will happen when panning, pinching and rotation ends, or when scale or position are changed manually.
168     IntSize visibleSize() const final { return visibleContentRect(LegacyIOSDocumentVisibleRect).size(); }
169 
170 #if USE(COORDINATED_GRAPHICS)
171     virtual void setFixedVisibleContentRect(const IntRect&amp; visibleContentRect) { m_fixedVisibleContentRect = visibleContentRect; }
172     IntRect fixedVisibleContentRect() const { return m_fixedVisibleContentRect; }
173 #endif
174 
175     // Parts of the document can be visible through transparent or blured UI widgets of the chrome. Those parts
176     // contribute to painting but not to the scrollable area.
177     // The unobscuredContentRect is the area that is not covered by UI elements.
178     WEBCORE_EXPORT IntRect unobscuredContentRect(VisibleContentRectIncludesScrollbars = ExcludeScrollbars) const;

179 #if PLATFORM(IOS_FAMILY)
180     IntRect unobscuredContentRectIncludingScrollbars() const { return unobscuredContentRect(IncludeScrollbars); }
181 #else
182     IntRect unobscuredContentRectIncludingScrollbars() const { return visibleContentRectIncludingScrollbars(); }
183 #endif
184 
<span class="line-removed">185 #if PLATFORM(IOS_FAMILY)</span>
186     // This is the area that is partially or fully exposed, and may extend under overlapping UI elements.
187     WEBCORE_EXPORT FloatRect exposedContentRect() const;
188 
189     // The given rects are only used if there is no platform widget.
190     WEBCORE_EXPORT void setExposedContentRect(const FloatRect&amp;);
<span class="line-modified">191     const FloatSize&amp; unobscuredContentSize() const { return m_unobscuredContentSize; }</span>

192     WEBCORE_EXPORT void setUnobscuredContentSize(const FloatSize&amp;);
193 

194     void setActualScrollPosition(const IntPoint&amp;);
195     LegacyTileCache* legacyTileCache();
196 #endif
197 
198     // Size available for view contents, including content inset areas. Not affected by zooming.
199     IntSize sizeForVisibleContent(VisibleContentRectIncludesScrollbars = ExcludeScrollbars) const;
200     // FIXME: remove this. It&#39;s only used for the incorrectly behaving ScrollView::unobscuredContentRectInternal().
201     virtual float visibleContentScaleFactor() const { return 1; }
202 
203     // Functions for getting/setting the size webkit should use to layout the contents. By default this is the same as the visible
204     // content size. Explicitly setting a layout size value will cause webkit to layout the contents using this size instead.
205     WEBCORE_EXPORT IntSize layoutSize() const;
206     int layoutWidth() const { return layoutSize().width(); }
207     int layoutHeight() const { return layoutSize().height(); }
208 
209     WEBCORE_EXPORT IntSize fixedLayoutSize() const;
210     WEBCORE_EXPORT void setFixedLayoutSize(const IntSize&amp;);
211     WEBCORE_EXPORT bool useFixedLayout() const;
212     WEBCORE_EXPORT void setUseFixedLayout(bool enable);
213 
214     // Functions for getting/setting the size of the document contained inside the ScrollView (as an IntSize or as individual width and height
215     // values).
216     WEBCORE_EXPORT IntSize contentsSize() const final; // Always at least as big as the visibleWidth()/visibleHeight().
217     int contentsWidth() const { return contentsSize().width(); }
218     int contentsHeight() const { return contentsSize().height(); }
219     virtual void setContentsSize(const IntSize&amp;);
220 
221     // Functions for querying the current scrolled position (both as a point, a size, or as individual X and Y values).
222     ScrollPosition scrollPosition() const final { return visibleContentRect(LegacyIOSDocumentVisibleRect).location(); }
223 
224     ScrollPosition maximumScrollPosition() const override; // The maximum position we can be scrolled to.
225 
226     // Adjust the passed in scroll position to keep it between the minimum and maximum positions.
227     ScrollPosition adjustScrollPositionWithinRange(const ScrollPosition&amp;) const;
228     int scrollX() const { return scrollPosition().x(); }
229     int scrollY() const { return scrollPosition().y(); }
230 
231     // Scroll position used by web-exposed features (has legacy iOS behavior).
232     WEBCORE_EXPORT IntPoint contentsScrollPosition() const;
<span class="line-modified">233     void setContentsScrollPosition(const IntPoint&amp;);</span>
234 
235 #if PLATFORM(IOS_FAMILY)
236     int actualScrollX() const { return unobscuredContentRect().x(); }
237     int actualScrollY() const { return unobscuredContentRect().y(); }
238     // FIXME: maybe fix scrollPosition() on iOS to return the actual scroll position.
239     IntPoint actualScrollPosition() const { return unobscuredContentRect().location(); }
240 #endif
241 
242     // scrollOffset() anchors its (0,0) point at the ScrollableArea&#39;s origin. When the Page has a
243     // header, the header is positioned at (0,0), ABOVE the start of the Document. So when a page with
244     // a header is pinned to the top, the scrollOffset() is (0,0), but the Document is actually at
245     // (0, -headerHeight()). documentScrollPositionRelativeToScrollableAreaOrigin() will return this
246     // version of the offset, which tracks the top of Document relative to where scrolling was achored.
247     ScrollPosition documentScrollPositionRelativeToScrollableAreaOrigin() const;
248 
249     // scrollPostion() anchors its (0,0) point at the ScrollableArea&#39;s origin. The top of the scrolling
250     // layer does not represent the top of the view when there is a topContentInset. Additionally, as
251     // detailed above, the origin of the scrolling layer also does not necessarily correspond with the
252     // top of the document anyway, since there could also be header. documentScrollPositionRelativeToViewOrigin()
253     // will return a version of the current scroll offset which tracks the top of the Document
254     // relative to the very top of the view.
255     WEBCORE_EXPORT ScrollPosition documentScrollPositionRelativeToViewOrigin() const;
256 
257     IntSize overhangAmount() const final;
258 
259     void cacheCurrentScrollPosition() { m_cachedScrollPosition = scrollPosition(); }
260     ScrollPosition cachedScrollPosition() const { return m_cachedScrollPosition; }
261 
262     // Functions for scrolling the view.
<span class="line-modified">263     virtual void setScrollPosition(const ScrollPosition&amp;);</span>
264     void scrollBy(const IntSize&amp; s) { return setScrollPosition(scrollPosition() + s); }
265 
266     // This function scrolls by lines, pages or pixels.
267     bool scroll(ScrollDirection, ScrollGranularity);
268 
269     // A logical scroll that just ends up calling the corresponding physical scroll() based off the document&#39;s writing mode.
270     bool logicalScroll(ScrollLogicalDirection, ScrollGranularity);
271 
272     // Scroll the actual contents of the view (either blitting or invalidating as needed).
273     void scrollContents(const IntSize&amp; scrollDelta);
274 
275     // This gives us a means of blocking painting on our scrollbars until the first layout has occurred.
276     WEBCORE_EXPORT void setScrollbarsSuppressed(bool suppressed, bool repaintOnUnsuppress = false);
277     bool scrollbarsSuppressed() const { return m_scrollbarsSuppressed; }
278 
279     WEBCORE_EXPORT IntPoint rootViewToContents(const IntPoint&amp;) const;
280     WEBCORE_EXPORT IntPoint contentsToRootView(const IntPoint&amp;) const;
281     WEBCORE_EXPORT FloatPoint contentsToRootView(const FloatPoint&amp;) const;
282     WEBCORE_EXPORT IntRect rootViewToContents(const IntRect&amp;) const;
283     WEBCORE_EXPORT IntRect contentsToRootView(const IntRect&amp;) const;
</pre>
<hr />
<pre>
408     virtual void scrollContentsSlowPath(const IntRect&amp; updateRect);
409 
410     void setScrollOrigin(const IntPoint&amp;, bool updatePositionAtAll, bool updatePositionSynchronously);
411 
412     // Subclassed by FrameView to check the writing-mode of the document.
413     virtual bool isVerticalDocument() const = 0;
414     virtual bool isFlippedDocument() const = 0;
415 
416     // Called to update the scrollbars to accurately reflect the state of the view.
417     void updateScrollbars(const ScrollPosition&amp; desiredPosition);
418 
419     float platformTopContentInset() const;
420     void platformSetTopContentInset(float);
421 
422     void handleDeferredScrollUpdateAfterContentSizeChange();
423 
424     virtual bool shouldDeferScrollUpdateAfterContentSizeChange() = 0;
425 
426     virtual void scrollOffsetChangedViaPlatformWidgetImpl(const ScrollOffset&amp;, const ScrollOffset&amp;) = 0;
427 
<span class="line-removed">428 #if PLATFORM(IOS_FAMILY)</span>
429     virtual void unobscuredContentSizeChanged() = 0;
<span class="line-removed">430 #endif</span>
431 
432 #if PLATFORM(COCOA) &amp;&amp; defined __OBJC__
433 public:
434     WEBCORE_EXPORT NSView* documentView() const;
435 
436 private:
437     NSScrollView&lt;WebCoreFrameScrollView&gt;* scrollView() const;
438 #endif
439 
440 private:
441     // Size available for view contents, excluding content insets. Not affected by zooming.
442     IntSize sizeForUnobscuredContent(VisibleContentRectIncludesScrollbars = ExcludeScrollbars) const;
443 
444     IntRect visibleContentRectInternal(VisibleContentRectIncludesScrollbars, VisibleContentRectBehavior) const final;
445     WEBCORE_EXPORT IntRect unobscuredContentRectInternal(VisibleContentRectIncludesScrollbars = ExcludeScrollbars) const;
446 
447     void completeUpdatesAfterScrollTo(const IntSize&amp; scrollDelta);
448 
449     bool setHasScrollbarInternal(RefPtr&lt;Scrollbar&gt;&amp;, ScrollbarOrientation, bool hasBar, bool* contentSizeAffected);
450 
451     bool isScrollView() const final { return true; }
452 
453     void init();
454     void destroy();
455 
456     IntRect rectToCopyOnScroll() const;
457 
458     // Called when the scroll position within this view changes. FrameView overrides this to generate repaint invalidations.
459     virtual void updateLayerPositionsAfterScrolling() = 0;
460     virtual void updateCompositingLayersAfterScrolling() = 0;
461 
462     void platformAddChild(Widget*);
463     void platformRemoveChild(Widget*);
464     void platformSetScrollbarModes();
465     void platformScrollbarModes(ScrollbarMode&amp; horizontal, ScrollbarMode&amp; vertical) const;
466     void platformSetCanBlitOnScroll(bool);
467     bool platformCanBlitOnScroll() const;

468     IntRect platformVisibleContentRect(bool includeScrollbars) const;
469     IntSize platformVisibleContentSize(bool includeScrollbars) const;
470     IntRect platformVisibleContentRectIncludingObscuredArea(bool includeScrollbars) const;
471     IntSize platformVisibleContentSizeIncludingObscuredArea(bool includeScrollbars) const;




472     void platformSetContentsSize();

473     IntRect platformContentsToScreen(const IntRect&amp;) const;
474     IntPoint platformScreenToContents(const IntPoint&amp;) const;

475     void platformSetScrollPosition(const IntPoint&amp;);
476     bool platformScroll(ScrollDirection, ScrollGranularity);
477     void platformSetScrollbarsSuppressed(bool repaintOnUnsuppress);
478     void platformRepaintContentRectangle(const IntRect&amp;);
479     bool platformIsOffscreen() const;
480     void platformSetScrollbarOverlayStyle(ScrollbarOverlayStyle);
481     void platformSetScrollOrigin(const IntPoint&amp;, bool updatePositionAtAll, bool updatePositionSynchronously);
482 
483     void calculateOverhangAreasForPainting(IntRect&amp; horizontalOverhangRect, IntRect&amp; verticalOverhangRect);
484     void updateOverhangAreas();
485 
486     HashSet&lt;Ref&lt;Widget&gt;&gt; m_children;
487 
488     RefPtr&lt;Scrollbar&gt; m_horizontalScrollbar;
489     RefPtr&lt;Scrollbar&gt; m_verticalScrollbar;
490     ScrollbarMode m_horizontalScrollbarMode { ScrollbarAuto };
491     ScrollbarMode m_verticalScrollbarMode { ScrollbarAuto };
492 
<span class="line-modified">493 #if PLATFORM(IOS_FAMILY)</span>








494     // FIXME: exposedContentRect is a very similar concept to fixedVisibleContentRect except it does not differentiate
495     // between exposed and unobscured areas. The two attributes should eventually be merged.
<span class="line-removed">496     FloatRect m_exposedContentRect;</span>
<span class="line-removed">497     FloatSize m_unobscuredContentSize;</span>
<span class="line-removed">498     // This is only used for history scroll position restoration.</span>
<span class="line-removed">499 #else</span>
500     IntRect m_fixedVisibleContentRect;
501 #endif
502     ScrollPosition m_scrollPosition;
503     IntPoint m_cachedScrollPosition;
504     IntSize m_fixedLayoutSize;
505     IntSize m_contentsSize;
506 
507     Optional&lt;IntSize&gt; m_deferredScrollDelta; // Needed for WebKit scrolling
508     Optional&lt;std::pair&lt;ScrollOffset, ScrollOffset&gt;&gt; m_deferredScrollOffsets; // Needed for platform widget scrolling
509 
510     IntPoint m_panScrollIconPoint;
511 
512     unsigned m_updateScrollbarsPass { 0 };
513 
514     bool m_horizontalScrollbarLock { false };
515     bool m_verticalScrollbarLock { false };
516 
517     bool m_prohibitsScrolling { false };
518     bool m_allowsUnclampedScrollPosition { false };
519 
520     // This bool is unused on Mac OS because we directly ask the platform widget
521     // whether it is safe to blit on scroll.
522     bool m_canBlitOnScroll { true };
523 
524     bool m_scrollbarsSuppressed { false };
525     bool m_inUpdateScrollbars { false };
526 
527     bool m_drawPanScrollIcon { false };
528     bool m_useFixedLayout { false };
529 
530     bool m_paintsEntireContents { false };
531     bool m_delegatesScrolling { false };

532 }; // class ScrollView
533 
534 } // namespace WebCore
535 
536 SPECIALIZE_TYPE_TRAITS_WIDGET(ScrollView, isScrollView())
</pre>
</td>
<td>
<hr />
<pre>
103     // Functions for setting and retrieving the scrolling mode in each axis (horizontal/vertical). The mode has values of
104     // AlwaysOff, AlwaysOn, and Auto. AlwaysOff means never show a scrollbar, AlwaysOn means always show a scrollbar.
105     // Auto means show a scrollbar only when one is needed.
106     // Note that for platforms with native widgets, these modes are considered advisory. In other words the underlying native
107     // widget may choose not to honor the requested modes.
108     WEBCORE_EXPORT void setScrollbarModes(ScrollbarMode horizontalMode, ScrollbarMode verticalMode, bool horizontalLock = false, bool verticalLock = false);
109     void setHorizontalScrollbarMode(ScrollbarMode mode, bool lock = false) { setScrollbarModes(mode, verticalScrollbarMode(), lock, verticalScrollbarLock()); }
110     void setVerticalScrollbarMode(ScrollbarMode mode, bool lock = false) { setScrollbarModes(horizontalScrollbarMode(), mode, horizontalScrollbarLock(), lock); };
111     WEBCORE_EXPORT void scrollbarModes(ScrollbarMode&amp; horizontalMode, ScrollbarMode&amp; verticalMode) const;
112     ScrollbarMode horizontalScrollbarMode() const final { ScrollbarMode horizontal, vertical; scrollbarModes(horizontal, vertical); return horizontal; }
113     ScrollbarMode verticalScrollbarMode() const final { ScrollbarMode horizontal, vertical; scrollbarModes(horizontal, vertical); return vertical; }
114 
115     void setHorizontalScrollbarLock(bool lock = true) { m_horizontalScrollbarLock = lock; }
116     bool horizontalScrollbarLock() const { return m_horizontalScrollbarLock; }
117     void setVerticalScrollbarLock(bool lock = true) { m_verticalScrollbarLock = lock; }
118     bool verticalScrollbarLock() const { return m_verticalScrollbarLock; }
119 
120     void setScrollingModesLock(bool lock = true) { m_horizontalScrollbarLock = m_verticalScrollbarLock = lock; }
121 
122     WEBCORE_EXPORT virtual void setCanHaveScrollbars(bool);

123 
124     virtual bool avoidScrollbarCreation() const { return false; }
125 
126     void setScrollbarOverlayStyle(ScrollbarOverlayStyle) final;
127 
128     // By default you only receive paint events for the area that is visible. In the case of using a
129     // tiled backing store, this function can be set, so that the view paints the entire contents.
130     bool paintsEntireContents() const { return m_paintsEntireContents; }
131     WEBCORE_EXPORT void setPaintsEntireContents(bool);
132 
133     // By default programmatic scrolling is handled by WebCore and not by the UI application.
134     // In the case of using a tiled backing store, this mode can be set, so that the scroll requests
135     // are delegated to the UI application.
136     bool delegatesScrolling() const { return m_delegatesScrolling; }
137     WEBCORE_EXPORT void setDelegatesScrolling(bool);
138 
139     // Overridden by FrameView to create custom CSS scrollbars if applicable.
140     virtual Ref&lt;Scrollbar&gt; createScrollbar(ScrollbarOrientation);
141 
<span class="line-modified">142     virtual void styleDidChange();</span>
143 
144     // If the prohibits scrolling flag is set, then all scrolling in the view (even programmatic scrolling) is turned off.
145     void setProhibitsScrolling(bool b) { m_prohibitsScrolling = b; }
146     bool prohibitsScrolling() const { return m_prohibitsScrolling; }
147 
148     // Whether or not a scroll view will blit visible contents when it is scrolled. Blitting is disabled in situations
149     // where it would cause rendering glitches (such as with fixed backgrounds or when the view is partially transparent).
150     void setCanBlitOnScroll(bool);
151     bool canBlitOnScroll() const;
152 
153     // There are at least three types of contentInset. Usually we just care about WebCoreContentInset, which is the inset
154     // that is set on a Page that requires WebCore to move its layers to accomodate the inset. However, there are platform
155     // concepts that are similar on both iOS and Mac when there is a platformWidget(). Sometimes we need the Mac platform value
156     // for topContentInset, so when the TopContentInsetType is WebCoreOrPlatformContentInset, platformTopContentInset()
157     // will be returned instead of the value set on Page.
158     enum class TopContentInsetType { WebCoreContentInset, WebCoreOrPlatformContentInset };
159     virtual float topContentInset(TopContentInsetType = TopContentInsetType::WebCoreContentInset) const { return 0; }
160 
161     // The visible content rect has a location that is the scrolled offset of the document. The width and height are the unobscured viewport
162     // width and height. By default the scrollbars themselves are excluded from this rectangle, but an optional boolean argument allows them
163     // to be included.
164     // In the situation the client is responsible for the scrolling (ie. with a tiled backing store) it is possible to use
165     // the setFixedVisibleContentRect instead for the mainframe, though this must be updated manually, e.g just before resuming the page
166     // which usually will happen when panning, pinching and rotation ends, or when scale or position are changed manually.
167     IntSize visibleSize() const final { return visibleContentRect(LegacyIOSDocumentVisibleRect).size(); }
168 
169 #if USE(COORDINATED_GRAPHICS)
170     virtual void setFixedVisibleContentRect(const IntRect&amp; visibleContentRect) { m_fixedVisibleContentRect = visibleContentRect; }
171     IntRect fixedVisibleContentRect() const { return m_fixedVisibleContentRect; }
172 #endif
173 
174     // Parts of the document can be visible through transparent or blured UI widgets of the chrome. Those parts
175     // contribute to painting but not to the scrollable area.
176     // The unobscuredContentRect is the area that is not covered by UI elements.
177     WEBCORE_EXPORT IntRect unobscuredContentRect(VisibleContentRectIncludesScrollbars = ExcludeScrollbars) const;
<span class="line-added">178 </span>
179 #if PLATFORM(IOS_FAMILY)
180     IntRect unobscuredContentRectIncludingScrollbars() const { return unobscuredContentRect(IncludeScrollbars); }
181 #else
182     IntRect unobscuredContentRectIncludingScrollbars() const { return visibleContentRectIncludingScrollbars(); }
183 #endif
184 

185     // This is the area that is partially or fully exposed, and may extend under overlapping UI elements.
186     WEBCORE_EXPORT FloatRect exposedContentRect() const;
187 
188     // The given rects are only used if there is no platform widget.
189     WEBCORE_EXPORT void setExposedContentRect(const FloatRect&amp;);
<span class="line-modified">190 </span>
<span class="line-added">191     WEBCORE_EXPORT FloatSize unobscuredContentSize() const;</span>
192     WEBCORE_EXPORT void setUnobscuredContentSize(const FloatSize&amp;);
193 
<span class="line-added">194 #if PLATFORM(IOS_FAMILY)</span>
195     void setActualScrollPosition(const IntPoint&amp;);
196     LegacyTileCache* legacyTileCache();
197 #endif
198 
199     // Size available for view contents, including content inset areas. Not affected by zooming.
200     IntSize sizeForVisibleContent(VisibleContentRectIncludesScrollbars = ExcludeScrollbars) const;
201     // FIXME: remove this. It&#39;s only used for the incorrectly behaving ScrollView::unobscuredContentRectInternal().
202     virtual float visibleContentScaleFactor() const { return 1; }
203 
204     // Functions for getting/setting the size webkit should use to layout the contents. By default this is the same as the visible
205     // content size. Explicitly setting a layout size value will cause webkit to layout the contents using this size instead.
206     WEBCORE_EXPORT IntSize layoutSize() const;
207     int layoutWidth() const { return layoutSize().width(); }
208     int layoutHeight() const { return layoutSize().height(); }
209 
210     WEBCORE_EXPORT IntSize fixedLayoutSize() const;
211     WEBCORE_EXPORT void setFixedLayoutSize(const IntSize&amp;);
212     WEBCORE_EXPORT bool useFixedLayout() const;
213     WEBCORE_EXPORT void setUseFixedLayout(bool enable);
214 
215     // Functions for getting/setting the size of the document contained inside the ScrollView (as an IntSize or as individual width and height
216     // values).
217     WEBCORE_EXPORT IntSize contentsSize() const final; // Always at least as big as the visibleWidth()/visibleHeight().
218     int contentsWidth() const { return contentsSize().width(); }
219     int contentsHeight() const { return contentsSize().height(); }
220     virtual void setContentsSize(const IntSize&amp;);
221 
222     // Functions for querying the current scrolled position (both as a point, a size, or as individual X and Y values).
223     ScrollPosition scrollPosition() const final { return visibleContentRect(LegacyIOSDocumentVisibleRect).location(); }
224 
225     ScrollPosition maximumScrollPosition() const override; // The maximum position we can be scrolled to.
226 
227     // Adjust the passed in scroll position to keep it between the minimum and maximum positions.
228     ScrollPosition adjustScrollPositionWithinRange(const ScrollPosition&amp;) const;
229     int scrollX() const { return scrollPosition().x(); }
230     int scrollY() const { return scrollPosition().y(); }
231 
232     // Scroll position used by web-exposed features (has legacy iOS behavior).
233     WEBCORE_EXPORT IntPoint contentsScrollPosition() const;
<span class="line-modified">234     void setContentsScrollPosition(const IntPoint&amp;, ScrollClamping = ScrollClamping::Clamped);</span>
235 
236 #if PLATFORM(IOS_FAMILY)
237     int actualScrollX() const { return unobscuredContentRect().x(); }
238     int actualScrollY() const { return unobscuredContentRect().y(); }
239     // FIXME: maybe fix scrollPosition() on iOS to return the actual scroll position.
240     IntPoint actualScrollPosition() const { return unobscuredContentRect().location(); }
241 #endif
242 
243     // scrollOffset() anchors its (0,0) point at the ScrollableArea&#39;s origin. When the Page has a
244     // header, the header is positioned at (0,0), ABOVE the start of the Document. So when a page with
245     // a header is pinned to the top, the scrollOffset() is (0,0), but the Document is actually at
246     // (0, -headerHeight()). documentScrollPositionRelativeToScrollableAreaOrigin() will return this
247     // version of the offset, which tracks the top of Document relative to where scrolling was achored.
248     ScrollPosition documentScrollPositionRelativeToScrollableAreaOrigin() const;
249 
250     // scrollPostion() anchors its (0,0) point at the ScrollableArea&#39;s origin. The top of the scrolling
251     // layer does not represent the top of the view when there is a topContentInset. Additionally, as
252     // detailed above, the origin of the scrolling layer also does not necessarily correspond with the
253     // top of the document anyway, since there could also be header. documentScrollPositionRelativeToViewOrigin()
254     // will return a version of the current scroll offset which tracks the top of the Document
255     // relative to the very top of the view.
256     WEBCORE_EXPORT ScrollPosition documentScrollPositionRelativeToViewOrigin() const;
257 
258     IntSize overhangAmount() const final;
259 
260     void cacheCurrentScrollPosition() { m_cachedScrollPosition = scrollPosition(); }
261     ScrollPosition cachedScrollPosition() const { return m_cachedScrollPosition; }
262 
263     // Functions for scrolling the view.
<span class="line-modified">264     virtual void setScrollPosition(const ScrollPosition&amp;, ScrollClamping = ScrollClamping::Clamped);</span>
265     void scrollBy(const IntSize&amp; s) { return setScrollPosition(scrollPosition() + s); }
266 
267     // This function scrolls by lines, pages or pixels.
268     bool scroll(ScrollDirection, ScrollGranularity);
269 
270     // A logical scroll that just ends up calling the corresponding physical scroll() based off the document&#39;s writing mode.
271     bool logicalScroll(ScrollLogicalDirection, ScrollGranularity);
272 
273     // Scroll the actual contents of the view (either blitting or invalidating as needed).
274     void scrollContents(const IntSize&amp; scrollDelta);
275 
276     // This gives us a means of blocking painting on our scrollbars until the first layout has occurred.
277     WEBCORE_EXPORT void setScrollbarsSuppressed(bool suppressed, bool repaintOnUnsuppress = false);
278     bool scrollbarsSuppressed() const { return m_scrollbarsSuppressed; }
279 
280     WEBCORE_EXPORT IntPoint rootViewToContents(const IntPoint&amp;) const;
281     WEBCORE_EXPORT IntPoint contentsToRootView(const IntPoint&amp;) const;
282     WEBCORE_EXPORT FloatPoint contentsToRootView(const FloatPoint&amp;) const;
283     WEBCORE_EXPORT IntRect rootViewToContents(const IntRect&amp;) const;
284     WEBCORE_EXPORT IntRect contentsToRootView(const IntRect&amp;) const;
</pre>
<hr />
<pre>
409     virtual void scrollContentsSlowPath(const IntRect&amp; updateRect);
410 
411     void setScrollOrigin(const IntPoint&amp;, bool updatePositionAtAll, bool updatePositionSynchronously);
412 
413     // Subclassed by FrameView to check the writing-mode of the document.
414     virtual bool isVerticalDocument() const = 0;
415     virtual bool isFlippedDocument() const = 0;
416 
417     // Called to update the scrollbars to accurately reflect the state of the view.
418     void updateScrollbars(const ScrollPosition&amp; desiredPosition);
419 
420     float platformTopContentInset() const;
421     void platformSetTopContentInset(float);
422 
423     void handleDeferredScrollUpdateAfterContentSizeChange();
424 
425     virtual bool shouldDeferScrollUpdateAfterContentSizeChange() = 0;
426 
427     virtual void scrollOffsetChangedViaPlatformWidgetImpl(const ScrollOffset&amp;, const ScrollOffset&amp;) = 0;
428 

429     virtual void unobscuredContentSizeChanged() = 0;

430 
431 #if PLATFORM(COCOA) &amp;&amp; defined __OBJC__
432 public:
433     WEBCORE_EXPORT NSView* documentView() const;
434 
435 private:
436     NSScrollView&lt;WebCoreFrameScrollView&gt;* scrollView() const;
437 #endif
438 
439 private:
440     // Size available for view contents, excluding content insets. Not affected by zooming.
441     IntSize sizeForUnobscuredContent(VisibleContentRectIncludesScrollbars = ExcludeScrollbars) const;
442 
443     IntRect visibleContentRectInternal(VisibleContentRectIncludesScrollbars, VisibleContentRectBehavior) const final;
444     WEBCORE_EXPORT IntRect unobscuredContentRectInternal(VisibleContentRectIncludesScrollbars = ExcludeScrollbars) const;
445 
446     void completeUpdatesAfterScrollTo(const IntSize&amp; scrollDelta);
447 
448     bool setHasScrollbarInternal(RefPtr&lt;Scrollbar&gt;&amp;, ScrollbarOrientation, bool hasBar, bool* contentSizeAffected);
449 
450     bool isScrollView() const final { return true; }
451 
452     void init();
453     void destroy();
454 
455     IntRect rectToCopyOnScroll() const;
456 
457     // Called when the scroll position within this view changes. FrameView overrides this to generate repaint invalidations.
458     virtual void updateLayerPositionsAfterScrolling() = 0;
459     virtual void updateCompositingLayersAfterScrolling() = 0;
460 
461     void platformAddChild(Widget*);
462     void platformRemoveChild(Widget*);
463     void platformSetScrollbarModes();
464     void platformScrollbarModes(ScrollbarMode&amp; horizontal, ScrollbarMode&amp; vertical) const;
465     void platformSetCanBlitOnScroll(bool);
466     bool platformCanBlitOnScroll() const;
<span class="line-added">467 </span>
468     IntRect platformVisibleContentRect(bool includeScrollbars) const;
469     IntSize platformVisibleContentSize(bool includeScrollbars) const;
470     IntRect platformVisibleContentRectIncludingObscuredArea(bool includeScrollbars) const;
471     IntSize platformVisibleContentSizeIncludingObscuredArea(bool includeScrollbars) const;
<span class="line-added">472 </span>
<span class="line-added">473     IntRect platformUnobscuredContentRect(VisibleContentRectIncludesScrollbars) const;</span>
<span class="line-added">474     FloatRect platformExposedContentRect() const;</span>
<span class="line-added">475 </span>
476     void platformSetContentsSize();
<span class="line-added">477 </span>
478     IntRect platformContentsToScreen(const IntRect&amp;) const;
479     IntPoint platformScreenToContents(const IntPoint&amp;) const;
<span class="line-added">480 </span>
481     void platformSetScrollPosition(const IntPoint&amp;);
482     bool platformScroll(ScrollDirection, ScrollGranularity);
483     void platformSetScrollbarsSuppressed(bool repaintOnUnsuppress);
484     void platformRepaintContentRectangle(const IntRect&amp;);
485     bool platformIsOffscreen() const;
486     void platformSetScrollbarOverlayStyle(ScrollbarOverlayStyle);
487     void platformSetScrollOrigin(const IntPoint&amp;, bool updatePositionAtAll, bool updatePositionSynchronously);
488 
489     void calculateOverhangAreasForPainting(IntRect&amp; horizontalOverhangRect, IntRect&amp; verticalOverhangRect);
490     void updateOverhangAreas();
491 
492     HashSet&lt;Ref&lt;Widget&gt;&gt; m_children;
493 
494     RefPtr&lt;Scrollbar&gt; m_horizontalScrollbar;
495     RefPtr&lt;Scrollbar&gt; m_verticalScrollbar;
496     ScrollbarMode m_horizontalScrollbarMode { ScrollbarAuto };
497     ScrollbarMode m_verticalScrollbarMode { ScrollbarAuto };
498 
<span class="line-modified">499 </span>
<span class="line-added">500     // FIXME: More things will move into here.</span>
<span class="line-added">501     struct DelegatedScrollingGeometry {</span>
<span class="line-added">502         FloatSize unobscuredContentSize;</span>
<span class="line-added">503         FloatRect exposedContentRect;</span>
<span class="line-added">504     };</span>
<span class="line-added">505     Optional&lt;DelegatedScrollingGeometry&gt; m_delegatedScrollingGeometry;</span>
<span class="line-added">506 </span>
<span class="line-added">507 #if USE(COORDINATED_GRAPHICS)</span>
508     // FIXME: exposedContentRect is a very similar concept to fixedVisibleContentRect except it does not differentiate
509     // between exposed and unobscured areas. The two attributes should eventually be merged.




510     IntRect m_fixedVisibleContentRect;
511 #endif
512     ScrollPosition m_scrollPosition;
513     IntPoint m_cachedScrollPosition;
514     IntSize m_fixedLayoutSize;
515     IntSize m_contentsSize;
516 
517     Optional&lt;IntSize&gt; m_deferredScrollDelta; // Needed for WebKit scrolling
518     Optional&lt;std::pair&lt;ScrollOffset, ScrollOffset&gt;&gt; m_deferredScrollOffsets; // Needed for platform widget scrolling
519 
520     IntPoint m_panScrollIconPoint;
521 
522     unsigned m_updateScrollbarsPass { 0 };
523 
524     bool m_horizontalScrollbarLock { false };
525     bool m_verticalScrollbarLock { false };
526 
527     bool m_prohibitsScrolling { false };
528     bool m_allowsUnclampedScrollPosition { false };
529 
530     // This bool is unused on Mac OS because we directly ask the platform widget
531     // whether it is safe to blit on scroll.
532     bool m_canBlitOnScroll { true };
533 
534     bool m_scrollbarsSuppressed { false };
535     bool m_inUpdateScrollbars { false };
536 
537     bool m_drawPanScrollIcon { false };
538     bool m_useFixedLayout { false };
539 
540     bool m_paintsEntireContents { false };
541     bool m_delegatesScrolling { false };
<span class="line-added">542 </span>
543 }; // class ScrollView
544 
545 } // namespace WebCore
546 
547 SPECIALIZE_TYPE_TRAITS_WIDGET(ScrollView, isScrollView())
</pre>
</td>
</tr>
</table>
<center><a href="ScrollView.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScrollableArea.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
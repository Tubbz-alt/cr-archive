<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/Assertions.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2003-2019 Apple Inc.  All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;wtf/Platform.h&gt;
 29 
 30 /*
 31    no namespaces because this file has to be includable from C and Objective-C
 32 
 33    Note, this file uses many GCC extensions, but it should be compatible with
 34    C, Objective C, C++, and Objective C++.
 35 
 36    For non-debug builds, everything is disabled by default except for &quot;always
 37    on&quot; logging. Defining any of the symbols explicitly prevents this from
 38    having any effect.
 39 */
 40 
 41 #undef __STDC_FORMAT_MACROS
 42 #define __STDC_FORMAT_MACROS
 43 #include &lt;inttypes.h&gt;
 44 #include &lt;stdarg.h&gt;
 45 #include &lt;stdbool.h&gt;
 46 #include &lt;stddef.h&gt;
 47 #include &lt;stdlib.h&gt;
 48 #include &lt;wtf/ExportMacros.h&gt;
 49 
 50 #if USE(OS_LOG)
 51 #include &lt;os/log.h&gt;
 52 #endif
 53 
 54 #ifdef __cplusplus
 55 #include &lt;cstdlib&gt;
 56 #include &lt;type_traits&gt;
 57 
 58 #if OS(WINDOWS)
 59 #if !COMPILER(GCC_COMPATIBLE)
 60 extern &quot;C&quot; void _ReadWriteBarrier(void);
 61 #pragma intrinsic(_ReadWriteBarrier)
 62 #endif
 63 #include &lt;intrin.h&gt;
 64 #endif
 65 #endif
 66 
 67 /* ASSERT_ENABLED is defined in Platform.h. */
 68 
 69 #ifndef BACKTRACE_DISABLED
 70 #define BACKTRACE_DISABLED !ASSERT_ENABLED
 71 #endif
 72 
 73 #ifndef ASSERT_MSG_DISABLED
 74 #define ASSERT_MSG_DISABLED !ASSERT_ENABLED
 75 #endif
 76 
 77 #ifndef ASSERT_ARG_DISABLED
 78 #define ASSERT_ARG_DISABLED !ASSERT_ENABLED
 79 #endif
 80 
 81 #ifndef FATAL_DISABLED
 82 #define FATAL_DISABLED !ASSERT_ENABLED
 83 #endif
 84 
 85 #ifndef ERROR_DISABLED
 86 #define ERROR_DISABLED !ASSERT_ENABLED
 87 #endif
 88 
 89 #ifndef LOG_DISABLED
 90 #define LOG_DISABLED !ASSERT_ENABLED
 91 #endif
 92 
 93 #ifndef RELEASE_LOG_DISABLED
 94 #define RELEASE_LOG_DISABLED !(USE(OS_LOG))
 95 #endif
 96 
 97 #if COMPILER(GCC_COMPATIBLE)
 98 #define WTF_PRETTY_FUNCTION __PRETTY_FUNCTION__
 99 #else
100 #define WTF_PRETTY_FUNCTION __FUNCTION__
101 #endif
102 
103 #if COMPILER(MINGW)
104 /* By default MinGW emits warnings when C99 format attributes are used, even if __USE_MINGW_ANSI_STDIO is defined */
105 #define WTF_ATTRIBUTE_PRINTF(formatStringArgument, extraArguments) __attribute__((__format__(gnu_printf, formatStringArgument, extraArguments)))
106 #elif COMPILER(GCC_COMPATIBLE) &amp;&amp; !defined(__OBJC__)
107 /* WTF logging functions can process %@ in the format string to log a NSObject* but the printf format attribute
108    emits a warning when %@ is used in the format string.  Until &lt;rdar://problem/5195437&gt; is resolved we can&#39;t include
109    the attribute when being used from Objective-C code in case it decides to use %@. */
110 #define WTF_ATTRIBUTE_PRINTF(formatStringArgument, extraArguments) __attribute__((__format__(printf, formatStringArgument, extraArguments)))
111 #else
112 #define WTF_ATTRIBUTE_PRINTF(formatStringArgument, extraArguments)
113 #endif
114 
115 #if PLATFORM(IOS_FAMILY)
116 /* For a project that uses WTF but has no config.h, we need to explicitly set the export defines here. */
117 #ifndef WTF_EXPORT_PRIVATE
118 #define WTF_EXPORT_PRIVATE
119 #endif
120 #endif // PLATFORM(IOS_FAMILY)
121 
122 /* These helper functions are always declared, but not necessarily always defined if the corresponding function is disabled. */
123 
124 #ifdef __cplusplus
125 extern &quot;C&quot; {
126 #endif
127 
128 /* CRASH() - Raises a fatal error resulting in program termination and triggering either the debugger or the crash reporter.
129 
130    Use CRASH() in response to known, unrecoverable errors like out-of-memory.
131    Macro is enabled in both debug and release mode.
132    To test for unknown errors and verify assumptions, use ASSERT instead, to avoid impacting performance in release builds.
133 
134    Signals are ignored by the crash reporter on OS X so we must do better.
135 */
136 #if COMPILER(GCC_COMPATIBLE) || COMPILER(MSVC)
137 #define NO_RETURN_DUE_TO_CRASH NO_RETURN
138 #else
139 #define NO_RETURN_DUE_TO_CRASH
140 #endif
141 
142 #ifdef __cplusplus
143 enum class WTFLogChannelState : uint8_t { Off, On, OnWithAccumulation };
144 #undef Always
145 enum class WTFLogLevel : uint8_t { Always, Error, Warning, Info, Debug };
146 #else
147 typedef uint8_t WTFLogChannelState;
148 typedef uint8_t WTFLogLevel;
149 #endif
150 
151 typedef struct {
152     WTFLogChannelState state;
153     const char* name;
154     WTFLogLevel level;
155 #if !RELEASE_LOG_DISABLED
156     const char* subsystem;
157     __unsafe_unretained os_log_t osLogChannel;
158 #endif
159 } WTFLogChannel;
160 
161 #define LOG_CHANNEL(name) JOIN_LOG_CHANNEL_WITH_PREFIX(LOG_CHANNEL_PREFIX, name)
162 #define LOG_CHANNEL_ADDRESS(name) &amp;LOG_CHANNEL(name),
163 #define JOIN_LOG_CHANNEL_WITH_PREFIX(prefix, channel) JOIN_LOG_CHANNEL_WITH_PREFIX_LEVEL_2(prefix, channel)
164 #define JOIN_LOG_CHANNEL_WITH_PREFIX_LEVEL_2(prefix, channel) prefix ## channel
165 
166 #define LOG_CHANNEL_WEBKIT_SUBSYSTEM &quot;com.apple.WebKit&quot;
167 
168 #define DECLARE_LOG_CHANNEL(name) \
169     extern WTFLogChannel LOG_CHANNEL(name);
170 
171 #if !defined(DEFINE_LOG_CHANNEL)
172 #if RELEASE_LOG_DISABLED
173 #define DEFINE_LOG_CHANNEL(name, subsystem) \
174     WTFLogChannel LOG_CHANNEL(name) = { (WTFLogChannelState)0, #name, (WTFLogLevel)1 };
175 #else
176 #define DEFINE_LOG_CHANNEL(name, subsystem) \
177     WTFLogChannel LOG_CHANNEL(name) = { (WTFLogChannelState)0, #name, (WTFLogLevel)1, subsystem, OS_LOG_DEFAULT };
178 #endif
179 #endif
180 
181 WTF_EXPORT_PRIVATE void WTFReportNotImplementedYet(const char* file, int line, const char* function);
182 WTF_EXPORT_PRIVATE void WTFReportAssertionFailure(const char* file, int line, const char* function, const char* assertion);
183 WTF_EXPORT_PRIVATE void WTFReportAssertionFailureWithMessage(const char* file, int line, const char* function, const char* assertion, const char* format, ...) WTF_ATTRIBUTE_PRINTF(5, 6);
184 WTF_EXPORT_PRIVATE void WTFReportArgumentAssertionFailure(const char* file, int line, const char* function, const char* argName, const char* assertion);
185 WTF_EXPORT_PRIVATE void WTFReportFatalError(const char* file, int line, const char* function, const char* format, ...) WTF_ATTRIBUTE_PRINTF(4, 5);
186 WTF_EXPORT_PRIVATE void WTFReportError(const char* file, int line, const char* function, const char* format, ...) WTF_ATTRIBUTE_PRINTF(4, 5);
187 WTF_EXPORT_PRIVATE void WTFLog(WTFLogChannel*, const char* format, ...) WTF_ATTRIBUTE_PRINTF(2, 3);
188 WTF_EXPORT_PRIVATE void WTFLogVerbose(const char* file, int line, const char* function, WTFLogChannel*, const char* format, ...) WTF_ATTRIBUTE_PRINTF(5, 6);
189 WTF_EXPORT_PRIVATE void WTFLogAlwaysV(const char* format, va_list);
190 WTF_EXPORT_PRIVATE void WTFLogAlways(const char* format, ...) WTF_ATTRIBUTE_PRINTF(1, 2);
191 WTF_EXPORT_PRIVATE NO_RETURN_DUE_TO_CRASH void WTFLogAlwaysAndCrash(const char* format, ...) WTF_ATTRIBUTE_PRINTF(1, 2);
192 WTF_EXPORT_PRIVATE WTFLogChannel* WTFLogChannelByName(WTFLogChannel*[], size_t count, const char*);
193 WTF_EXPORT_PRIVATE void WTFInitializeLogChannelStatesFromString(WTFLogChannel*[], size_t count, const char*);
194 WTF_EXPORT_PRIVATE void WTFLogWithLevel(WTFLogChannel*, WTFLogLevel, const char* format, ...) WTF_ATTRIBUTE_PRINTF(3, 4);
195 WTF_EXPORT_PRIVATE void WTFSetLogChannelLevel(WTFLogChannel*, WTFLogLevel);
196 WTF_EXPORT_PRIVATE bool WTFWillLogWithLevel(WTFLogChannel*, WTFLogLevel);
197 
198 WTF_EXPORT_PRIVATE void WTFGetBacktrace(void** stack, int* size);
199 WTF_EXPORT_PRIVATE void WTFReportBacktrace(void);
200 WTF_EXPORT_PRIVATE void WTFPrintBacktrace(void** stack, int size);
201 #if !RELEASE_LOG_DISABLED
202 WTF_EXPORT_PRIVATE void WTFReleaseLogStackTrace(WTFLogChannel*);
203 #endif
204 
205 WTF_EXPORT_PRIVATE bool WTFIsDebuggerAttached(void);
206 
207 #if COMPILER(MSVC)
208 #define WTFBreakpointTrap()  __debugbreak()
209 #elif ASAN_ENABLED
210 #define WTFBreakpointTrap()  __builtin_trap()
211 #elif CPU(X86_64) || CPU(X86)
212 #define WTFBreakpointTrap()  asm volatile (&quot;int3&quot;)
213 #elif CPU(ARM_THUMB2)
214 #define WTFBreakpointTrap()  asm volatile (&quot;bkpt #0&quot;)
215 #elif CPU(ARM64)
216 #define WTFBreakpointTrap()  asm volatile (&quot;brk #0&quot;)
217 #else
218 #define WTFBreakpointTrap() WTFCrash() // Not implemented.
219 #endif
220 
221 #if COMPILER(MSVC)
222 #define WTFBreakpointTrapUnderConstexprContext() __debugbreak()
223 #else
224 #define WTFBreakpointTrapUnderConstexprContext() __builtin_trap()
225 #endif
226 
227 #ifndef CRASH
228 
229 #if defined(NDEBUG) &amp;&amp; (OS(DARWIN) || PLATFORM(PLAYSTATION))
230 // Crash with a SIGTRAP i.e EXC_BREAKPOINT.
231 // We are not using __builtin_trap because it is only guaranteed to abort, but not necessarily
232 // trigger a SIGTRAP. Instead, we use inline asm to ensure that we trigger the SIGTRAP.
233 #define CRASH() do { \
234     WTFBreakpointTrap(); \
235     __builtin_unreachable(); \
236 } while (0)
237 #define CRASH_UNDER_CONSTEXPR_CONTEXT() do { \
238     WTFBreakpointTrapUnderConstexprContext(); \
239     __builtin_unreachable(); \
240 } while (0)
241 #elif !ENABLE(DEVELOPER_MODE) &amp;&amp; !OS(DARWIN)
242 #ifdef __cplusplus
243 #define CRASH() std::abort()
244 #define CRASH_UNDER_CONSTEXPR_CONTEXT() std::abort()
245 #else
246 #define CRASH() abort()
247 #define CRASH_UNDER_CONSTEXPR_CONTEXT() abort()
248 #endif // __cplusplus
249 #else
250 #define CRASH() WTFCrash()
251 #define CRASH_UNDER_CONSTEXPR_CONTEXT() WTFCrash()
252 #endif
253 
254 #endif // !defined(CRASH)
255 
256 WTF_EXPORT_PRIVATE NO_RETURN_DUE_TO_CRASH void WTFCrash(void);
257 
258 #ifndef CRASH_WITH_SECURITY_IMPLICATION
259 #define CRASH_WITH_SECURITY_IMPLICATION() WTFCrashWithSecurityImplication()
260 #endif
261 
262 WTF_EXPORT_PRIVATE NO_RETURN_DUE_TO_CRASH void WTFCrashWithSecurityImplication(void);
263 
264 #ifdef __cplusplus
265 }
266 #endif
267 
268 /* BACKTRACE
269 
270   Print a backtrace to the same location as ASSERT messages.
271 */
272 
273 #if BACKTRACE_DISABLED
274 
275 #define BACKTRACE() ((void)0)
276 
277 #else
278 
279 #define BACKTRACE() do { \
280     WTFReportBacktrace(); \
281 } while(false)
282 
283 #endif
284 
285 /* ASSERT, ASSERT_NOT_REACHED, ASSERT_UNUSED
286 
287   These macros are compiled out of release builds.
288   Expressions inside them are evaluated in debug builds only.
289 */
290 
291 #if OS(WINDOWS)
292 /* FIXME: Change to use something other than ASSERT to avoid this conflict with the underlying platform */
293 #undef ASSERT
294 #endif
295 
296 #if !ASSERT_ENABLED
297 
298 #define ASSERT(assertion, ...) ((void)0)
299 #define ASSERT_UNDER_CONSTEXPR_CONTEXT(assertion) ((void)0)
300 #define ASSERT_AT(assertion, file, line, function) ((void)0)
301 #define ASSERT_NOT_REACHED(...) ((void)0)
302 #define ASSERT_NOT_IMPLEMENTED_YET() ((void)0)
303 #define ASSERT_IMPLIES(condition, assertion) ((void)0)
304 #define NO_RETURN_DUE_TO_ASSERT
305 
306 #define ASSERT_UNUSED(variable, assertion, ...) ((void)variable)
307 
308 #if ENABLE(SECURITY_ASSERTIONS)
309 #define ASSERT_WITH_SECURITY_IMPLICATION(assertion) \
310     (!(assertion) ? \
311         (WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion), \
312          CRASH_WITH_SECURITY_IMPLICATION()) : \
313         (void)0)
314 
315 #define ASSERT_WITH_SECURITY_IMPLICATION_DISABLED 0
316 #else /* not ENABLE(SECURITY_ASSERTIONS) */
317 #define ASSERT_WITH_SECURITY_IMPLICATION(assertion) ((void)0)
318 #define ASSERT_WITH_SECURITY_IMPLICATION_DISABLED 1
319 #endif /* ENABLE(SECURITY_ASSERTIONS) */
320 
321 #else /* ASSERT_ENABLED */
322 
323 #define ASSERT(assertion, ...) do { \
324     if (!(assertion)) { \
325         WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion); \
326         CRASH_WITH_INFO(__VA_ARGS__); \
327     } \
328 } while (0)
329 
330 #define ASSERT_UNDER_CONSTEXPR_CONTEXT(assertion) do { \
331     if (!(assertion)) { \
332         WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion); \
333         CRASH_UNDER_CONSTEXPR_CONTEXT(); \
334     } \
335 } while (0)
336 
337 #define ASSERT_AT(assertion, file, line, function) do { \
338     if (!(assertion)) { \
339         WTFReportAssertionFailure(file, line, function, #assertion); \
340         CRASH(); \
341     } \
342 } while (0)
343 
344 #define ASSERT_NOT_REACHED(...) do { \
345     WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, 0); \
346     CRASH_WITH_INFO(__VA_ARGS__); \
347 } while (0)
348 
349 #define ASSERT_NOT_IMPLEMENTED_YET() do { \
350     WTFReportNotImplementedYet(__FILE__, __LINE__, WTF_PRETTY_FUNCTION); \
351     CRASH(); \
352 } while (0)
353 
354 #define ASSERT_IMPLIES(condition, assertion) do { \
355     if ((condition) &amp;&amp; !(assertion)) { \
356         WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #condition &quot; =&gt; &quot; #assertion); \
357         CRASH(); \
358     } \
359 } while (0)
360 
361 #define ASSERT_UNUSED(variable, assertion, ...) ASSERT(assertion, __VA_ARGS__)
362 
363 #define NO_RETURN_DUE_TO_ASSERT NO_RETURN_DUE_TO_CRASH
364 
365 /* ASSERT_WITH_SECURITY_IMPLICATION
366 
367    Failure of this assertion indicates a possible security vulnerability.
368    Class of vulnerabilities that it tests include bad casts, out of bounds
369    accesses, use-after-frees, etc. Please file a bug using the security
370    template - https://bugs.webkit.org/enter_bug.cgi?product=Security.
371 
372 */
373 #define ASSERT_WITH_SECURITY_IMPLICATION(assertion) \
374     (!(assertion) ? \
375         (WTFReportAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion), \
376          CRASH_WITH_SECURITY_IMPLICATION()) : \
377         (void)0)
378 #define ASSERT_WITH_SECURITY_IMPLICATION_DISABLED 0
379 
380 #endif /* ASSERT_ENABLED */
381 
382 /* ASSERT_WITH_MESSAGE */
383 
384 #if ASSERT_MSG_DISABLED
385 #define ASSERT_WITH_MESSAGE(assertion, ...) ((void)0)
386 #else
387 #define ASSERT_WITH_MESSAGE(assertion, ...) do { \
388     if (!(assertion)) { \
389         WTFReportAssertionFailureWithMessage(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion, __VA_ARGS__); \
390         CRASH(); \
391     } \
392 } while (0)
393 #endif
394 
395 #ifdef __cplusplus
396 constexpr bool assertionFailureDueToUnreachableCode = false;
397 #define ASSERT_NOT_REACHED_WITH_MESSAGE(...) ASSERT_WITH_MESSAGE(assertionFailureDueToUnreachableCode, __VA_ARGS__)
398 #endif
399 
400 /* ASSERT_WITH_MESSAGE_UNUSED */
401 
402 #if ASSERT_MSG_DISABLED
403 #define ASSERT_WITH_MESSAGE_UNUSED(variable, assertion, ...) ((void)variable)
404 #else
405 #define ASSERT_WITH_MESSAGE_UNUSED(variable, assertion, ...) do { \
406     if (!(assertion)) { \
407         WTFReportAssertionFailureWithMessage(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #assertion, __VA_ARGS__); \
408         CRASH(); \
409     } \
410 } while (0)
411 #endif
412 
413 
414 /* ASSERT_ARG */
415 
416 #if ASSERT_ARG_DISABLED
417 
418 #define ASSERT_ARG(argName, assertion) ((void)0)
419 
420 #else
421 
422 #define ASSERT_ARG(argName, assertion) do { \
423     if (!(assertion)) { \
424         WTFReportArgumentAssertionFailure(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, #argName, #assertion); \
425         CRASH(); \
426     } \
427 } while (0)
428 
429 #endif
430 
431 /* COMPILE_ASSERT */
432 #ifndef COMPILE_ASSERT
433 #if COMPILER_SUPPORTS(C_STATIC_ASSERT)
434 /* Unlike static_assert below, this also works in plain C code. */
435 #define COMPILE_ASSERT(exp, name) _Static_assert((exp), #name)
436 #else
437 #define COMPILE_ASSERT(exp, name) static_assert((exp), #name)
438 #endif
439 #endif
440 
441 /* FATAL */
442 
443 #if FATAL_DISABLED
444 #define FATAL(...) ((void)0)
445 #else
446 #define FATAL(...) do { \
447     WTFReportFatalError(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, __VA_ARGS__); \
448     CRASH(); \
449 } while (0)
450 #endif
451 
452 /* LOG_ERROR */
453 
454 #if ERROR_DISABLED
455 #define LOG_ERROR(...) ((void)0)
456 #else
457 #define LOG_ERROR(...) WTFReportError(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, __VA_ARGS__)
458 #endif
459 
460 /* LOG */
461 
462 #if LOG_DISABLED
463 #define LOG(channel, ...) ((void)0)
464 #else
465 #define LOG(channel, ...) WTFLog(&amp;LOG_CHANNEL(channel), __VA_ARGS__)
466 #endif
467 
468 /* LOG_VERBOSE */
469 
470 #if LOG_DISABLED
471 #define LOG_VERBOSE(channel, ...) ((void)0)
472 #else
473 #define LOG_VERBOSE(channel, ...) WTFLogVerbose(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, &amp;LOG_CHANNEL(channel), __VA_ARGS__)
474 #endif
475 
476 /* LOG_WITH_LEVEL */
477 
478 #if LOG_DISABLED
479 #define LOG_WITH_LEVEL(channel, level, ...) ((void)0)
480 #else
481 #define LOG_WITH_LEVEL(channel, level, ...) WTFLogWithLevel(&amp;LOG_CHANNEL(channel), level, __VA_ARGS__)
482 #endif
483 
484 /* RELEASE_LOG */
485 
486 #if RELEASE_LOG_DISABLED
487 #define RELEASE_LOG(channel, ...) ((void)0)
488 #define RELEASE_LOG_ERROR(channel, ...) LOG_ERROR(__VA_ARGS__)
489 #define RELEASE_LOG_FAULT(channel, ...) LOG_ERROR(__VA_ARGS__)
490 #define RELEASE_LOG_INFO(channel, ...) ((void)0)
491 
492 #define RELEASE_LOG_IF(isAllowed, channel, ...) ((void)0)
493 #define RELEASE_LOG_ERROR_IF(isAllowed, channel, ...) do { if (isAllowed) RELEASE_LOG_ERROR(channel, __VA_ARGS__); } while (0)
494 #define RELEASE_LOG_INFO_IF(isAllowed, channel, ...) ((void)0)
495 
496 #define RELEASE_LOG_WITH_LEVEL(channel, level, ...) ((void)0)
497 #define RELEASE_LOG_WITH_LEVEL_IF(isAllowed, channel, level, ...) do { if (isAllowed) RELEASE_LOG_WITH_LEVEL(channel, level, __VA_ARGS__); } while (0)
498 
499 #define RELEASE_LOG_STACKTRACE(channel) ((void)0)
500 #else
501 #define RELEASE_LOG(channel, ...) os_log(LOG_CHANNEL(channel).osLogChannel, __VA_ARGS__)
502 #define RELEASE_LOG_ERROR(channel, ...) os_log_error(LOG_CHANNEL(channel).osLogChannel, __VA_ARGS__)
503 #define RELEASE_LOG_FAULT(channel, ...) os_log_fault(LOG_CHANNEL(channel).osLogChannel, __VA_ARGS__)
504 #define RELEASE_LOG_INFO(channel, ...) os_log_info(LOG_CHANNEL(channel).osLogChannel, __VA_ARGS__)
505 
506 #define RELEASE_LOG_IF(isAllowed, channel, ...) do { if (isAllowed) RELEASE_LOG(      channel, __VA_ARGS__); } while (0)
507 #define RELEASE_LOG_ERROR_IF(isAllowed, channel, ...) do { if (isAllowed) RELEASE_LOG_ERROR(channel, __VA_ARGS__); } while (0)
508 #define RELEASE_LOG_INFO_IF(isAllowed, channel, ...) do { if (isAllowed) RELEASE_LOG_INFO(channel, __VA_ARGS__); } while (0)
509 
510 #define RELEASE_LOG_WITH_LEVEL(channel, logLevel, ...) do { \
511     if (LOG_CHANNEL(channel).level &gt;= (logLevel)) \
512         os_log(LOG_CHANNEL(channel).osLogChannel, __VA_ARGS__); \
513 } while (0)
514 
515 #define RELEASE_LOG_WITH_LEVEL_IF(isAllowed, channel, logLevel, ...) do { \
516     if ((isAllowed) &amp;&amp; LOG_CHANNEL(channel).level &gt;= (logLevel)) \
517         os_log(LOG_CHANNEL(channel).osLogChannel, __VA_ARGS__); \
518 } while (0)
519 
520 #define RELEASE_LOG_STACKTRACE(channel) WTFReleaseLogStackTrace(&amp;LOG_CHANNEL(channel))
521 #endif
522 
523 
524 /* RELEASE_ASSERT */
525 
526 #if !ASSERT_ENABLED
527 
528 #define RELEASE_ASSERT(assertion, ...) do { \
529     if (UNLIKELY(!(assertion))) \
530         CRASH_WITH_INFO(__VA_ARGS__); \
531 } while (0)
532 #define RELEASE_ASSERT_WITH_MESSAGE(assertion, ...) RELEASE_ASSERT(assertion)
533 #define RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(assertion) RELEASE_ASSERT(assertion)
534 #define RELEASE_ASSERT_NOT_REACHED(...) CRASH_WITH_INFO(__VA_ARGS__)
535 #define RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(assertion) do { \
536     if (UNLIKELY(!(assertion))) { \
537         CRASH_UNDER_CONSTEXPR_CONTEXT(); \
538     } \
539 } while (0)
540 
541 #else /* ASSERT_ENABLED */
542 
543 #define RELEASE_ASSERT(assertion, ...) ASSERT(assertion, __VA_ARGS__)
544 #define RELEASE_ASSERT_WITH_MESSAGE(assertion, ...) ASSERT_WITH_MESSAGE(assertion, __VA_ARGS__)
545 #define RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(assertion) ASSERT_WITH_SECURITY_IMPLICATION(assertion)
546 #define RELEASE_ASSERT_NOT_REACHED() ASSERT_NOT_REACHED()
547 #define RELEASE_ASSERT_UNDER_CONSTEXPR_CONTEXT(assertion) ASSERT_UNDER_CONSTEXPR_CONTEXT(assertion)
548 
549 #endif /* ASSERT_ENABLED */
550 
551 #ifdef __cplusplus
552 #define RELEASE_ASSERT_NOT_REACHED_WITH_MESSAGE(...) RELEASE_ASSERT_WITH_MESSAGE(assertionFailureDueToUnreachableCode, __VA_ARGS__)
553 
554 // The combination of line, file, function, and counter should be a unique number per call to this crash. This tricks the compiler into not coalescing calls to WTFCrashWithInfo.
555 // The easiest way to fill these values per translation unit is to pass __LINE__, __FILE__, WTF_PRETTY_FUNCTION, and __COUNTER__.
556 WTF_EXPORT_PRIVATE NO_RETURN_DUE_TO_CRASH NOT_TAIL_CALLED void WTFCrashWithInfoImpl(int line, const char* file, const char* function, int counter, uint64_t reason, uint64_t misc1, uint64_t misc2, uint64_t misc3, uint64_t misc4, uint64_t misc5, uint64_t misc6);
557 WTF_EXPORT_PRIVATE NO_RETURN_DUE_TO_CRASH NOT_TAIL_CALLED void WTFCrashWithInfoImpl(int line, const char* file, const char* function, int counter, uint64_t reason, uint64_t misc1, uint64_t misc2, uint64_t misc3, uint64_t misc4, uint64_t misc5);
558 WTF_EXPORT_PRIVATE NO_RETURN_DUE_TO_CRASH NOT_TAIL_CALLED void WTFCrashWithInfoImpl(int line, const char* file, const char* function, int counter, uint64_t reason, uint64_t misc1, uint64_t misc2, uint64_t misc3, uint64_t misc4);
559 WTF_EXPORT_PRIVATE NO_RETURN_DUE_TO_CRASH NOT_TAIL_CALLED void WTFCrashWithInfoImpl(int line, const char* file, const char* function, int counter, uint64_t reason, uint64_t misc1, uint64_t misc2, uint64_t misc3);
560 WTF_EXPORT_PRIVATE NO_RETURN_DUE_TO_CRASH NOT_TAIL_CALLED void WTFCrashWithInfoImpl(int line, const char* file, const char* function, int counter, uint64_t reason, uint64_t misc1, uint64_t misc2);
561 WTF_EXPORT_PRIVATE NO_RETURN_DUE_TO_CRASH NOT_TAIL_CALLED void WTFCrashWithInfoImpl(int line, const char* file, const char* function, int counter, uint64_t reason, uint64_t misc1);
562 WTF_EXPORT_PRIVATE NO_RETURN_DUE_TO_CRASH NOT_TAIL_CALLED void WTFCrashWithInfoImpl(int line, const char* file, const char* function, int counter, uint64_t reason);
563 NO_RETURN_DUE_TO_CRASH NOT_TAIL_CALLED void WTFCrashWithInfo(int line, const char* file, const char* function, int counter);
564 
565 template&lt;typename T&gt;
566 ALWAYS_INLINE uint64_t wtfCrashArg(T* arg) { return reinterpret_cast&lt;uintptr_t&gt;(arg); }
567 
568 template&lt;typename T&gt;
569 ALWAYS_INLINE uint64_t wtfCrashArg(T arg) { return arg; }
570 
571 template&lt;typename T&gt;
572 NO_RETURN_DUE_TO_CRASH ALWAYS_INLINE void WTFCrashWithInfo(int line, const char* file, const char* function, int counter, T reason)
573 {
574     WTFCrashWithInfoImpl(line, file, function, counter, wtfCrashArg(reason));
575 }
576 
577 template&lt;typename T, typename U&gt;
578 NO_RETURN_DUE_TO_CRASH ALWAYS_INLINE void WTFCrashWithInfo(int line, const char* file, const char* function, int counter, T reason, U misc1)
579 {
580     WTFCrashWithInfoImpl(line, file, function, counter, wtfCrashArg(reason), wtfCrashArg(misc1));
581 }
582 
583 template&lt;typename T, typename U, typename V&gt;
584 NO_RETURN_DUE_TO_CRASH ALWAYS_INLINE void WTFCrashWithInfo(int line, const char* file, const char* function, int counter, T reason, U misc1, V misc2)
585 {
586     WTFCrashWithInfoImpl(line, file, function, counter, wtfCrashArg(reason), wtfCrashArg(misc1), wtfCrashArg(misc2));
587 }
588 
589 template&lt;typename T, typename U, typename V, typename W&gt;
590 NO_RETURN_DUE_TO_CRASH ALWAYS_INLINE void WTFCrashWithInfo(int line, const char* file, const char* function, int counter, T reason, U misc1, V misc2, W misc3)
591 {
592     WTFCrashWithInfoImpl(line, file, function, counter, wtfCrashArg(reason), wtfCrashArg(misc1), wtfCrashArg(misc2), wtfCrashArg(misc3));
593 }
594 
595 template&lt;typename T, typename U, typename V, typename W, typename X&gt;
596 NO_RETURN_DUE_TO_CRASH ALWAYS_INLINE void WTFCrashWithInfo(int line, const char* file, const char* function, int counter, T reason, U misc1, V misc2, W misc3, X misc4)
597 {
598     WTFCrashWithInfoImpl(line, file, function, counter, wtfCrashArg(reason), wtfCrashArg(misc1), wtfCrashArg(misc2), wtfCrashArg(misc3), wtfCrashArg(misc4));
599 }
600 
601 template&lt;typename T, typename U, typename V, typename W, typename X, typename Y&gt;
602 NO_RETURN_DUE_TO_CRASH ALWAYS_INLINE void WTFCrashWithInfo(int line, const char* file, const char* function, int counter, T reason, U misc1, V misc2, W misc3, X misc4, Y misc5)
603 {
604     WTFCrashWithInfoImpl(line, file, function, counter, wtfCrashArg(reason), wtfCrashArg(misc1), wtfCrashArg(misc2), wtfCrashArg(misc3), wtfCrashArg(misc4), wtfCrashArg(misc5));
605 }
606 
607 template&lt;typename T, typename U, typename V, typename W, typename X, typename Y, typename Z&gt;
608 NO_RETURN_DUE_TO_CRASH ALWAYS_INLINE void WTFCrashWithInfo(int line, const char* file, const char* function, int counter, T reason, U misc1, V misc2, W misc3, X misc4, Y misc5, Z misc6)
609 {
610     WTFCrashWithInfoImpl(line, file, function, counter, wtfCrashArg(reason), wtfCrashArg(misc1), wtfCrashArg(misc2), wtfCrashArg(misc3), wtfCrashArg(misc4), wtfCrashArg(misc5), wtfCrashArg(misc6));
611 }
612 
613 inline void WTFCrashWithInfo(int, const char*, const char*, int)
614 #if COMPILER(CLANG)
615     __attribute__((optnone))
616 #endif
617 {
618     CRASH();
619 }
620 
621 namespace WTF {
622 inline void isIntegralOrPointerType() { }
623 
624 template&lt;typename T, typename... Types&gt;
625 void isIntegralOrPointerType(T, Types... types)
626 {
627     static_assert(std::is_integral&lt;T&gt;::value || std::is_enum&lt;T&gt;::value || std::is_pointer&lt;T&gt;::value, &quot;All types need to be bitwise_cast-able to integral type for logging&quot;);
628     isIntegralOrPointerType(types...);
629 }
630 }
631 
632 inline void compilerFenceForCrash()
633 {
634 #if OS(WINDOWS) &amp;&amp; !COMPILER(GCC_COMPATIBLE)
635     _ReadWriteBarrier();
636 #else
637     asm volatile(&quot;&quot; ::: &quot;memory&quot;);
638 #endif
639 }
640 
641 #ifndef CRASH_WITH_INFO
642 // This is useful if you are going to stuff data into registers before crashing, like the
643 // crashWithInfo functions below.
644 #if COMPILER(CLANG) || COMPILER(MSVC)
645 #define CRASH_WITH_INFO(...) do { \
646         WTF::isIntegralOrPointerType(__VA_ARGS__); \
647         compilerFenceForCrash(); \
648         WTFCrashWithInfo(__LINE__, __FILE__, WTF_PRETTY_FUNCTION, __COUNTER__, ##__VA_ARGS__); \
649     } while (false)
650 #else
651 // GCC does not allow ##__VA_ARGS__ unless GNU extensions are enabled (--std=gnu++NN instead of
652 // --std=c++NN) and I think we don&#39;t want that, so we&#39;ll have a fallback path for GCC. Obviously
653 // this will not actually succeed at getting the desired info into registers before crashing, but
654 // it&#39;s just a fallback anyway.
655 //
656 // FIXME: When we enable C++20, we should replace ##__VA_ARGS__ with format __VA_OPT__(,) __VA_ARGS__
657 // so that we can remove this fallback.
658 inline NO_RETURN_DUE_TO_CRASH void CRASH_WITH_INFO(...)
659 {
660     CRASH();
661 }
662 
663 // We must define this here because CRASH_WITH_INFO() is not defined as a macro.
664 // FIXME: Remove this when upgrading to C++20.
665 inline NO_RETURN_DUE_TO_CRASH void CRASH_WITH_SECURITY_IMPLICATION_AND_INFO(...)
666 {
667     CRASH();
668 }
669 #endif
670 #endif // CRASH_WITH_INFO
671 
672 #ifndef CRASH_WITH_SECURITY_IMPLICATION_AND_INFO
673 #define CRASH_WITH_SECURITY_IMPLICATION_AND_INFO CRASH_WITH_INFO
674 #endif // CRASH_WITH_SECURITY_IMPLICATION_AND_INFO
675 
676 #else /* not __cplusplus */
677 
678 #ifndef CRASH_WITH_INFO
679 #define CRASH_WITH_INFO() CRASH()
680 #endif
681 
682 #endif /* __cplusplus */
683 
684 /* UNREACHABLE_FOR_PLATFORM */
685 
686 #if COMPILER(CLANG)
687 // This would be a macro except that its use of #pragma works best around
688 // a function. Hence it uses macro naming convention.
689 IGNORE_WARNINGS_BEGIN(&quot;missing-noreturn&quot;)
690 static inline void UNREACHABLE_FOR_PLATFORM()
691 {
692     // This *MUST* be a release assert. We use it in places where it&#39;s better to crash than to keep
693     // going.
694     RELEASE_ASSERT_NOT_REACHED();
695 }
696 IGNORE_WARNINGS_END
697 #else
698 #define UNREACHABLE_FOR_PLATFORM() RELEASE_ASSERT_NOT_REACHED()
699 #endif
    </pre>
  </body>
</html>
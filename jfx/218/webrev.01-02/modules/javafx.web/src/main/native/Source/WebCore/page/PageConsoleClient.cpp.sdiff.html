<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/PageConsoleClient.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PageConfiguration.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PageConsoleClient.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/PageConsoleClient.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 39 #include &quot;FrameSnapshotting.h&quot;
 40 #include &quot;HTMLCanvasElement.h&quot;
 41 #include &quot;HTMLImageElement.h&quot;
 42 #include &quot;HTMLPictureElement.h&quot;
 43 #include &quot;HTMLVideoElement.h&quot;
 44 #include &quot;Image.h&quot;
 45 #include &quot;ImageBitmap.h&quot;
 46 #include &quot;ImageBitmapRenderingContext.h&quot;
 47 #include &quot;ImageBuffer.h&quot;
 48 #include &quot;ImageData.h&quot;
 49 #include &quot;InspectorController.h&quot;
 50 #include &quot;InspectorInstrumentation.h&quot;
 51 #include &quot;IntRect.h&quot;
 52 #include &quot;JSCanvasRenderingContext2D.h&quot;
 53 #include &quot;JSExecState.h&quot;
 54 #include &quot;JSHTMLCanvasElement.h&quot;
 55 #include &quot;JSImageBitmap.h&quot;
 56 #include &quot;JSImageBitmapRenderingContext.h&quot;
 57 #include &quot;JSImageData.h&quot;
 58 #include &quot;JSNode.h&quot;
<span class="line-removed"> 59 #include &quot;JSOffscreenCanvas.h&quot;</span>
 60 #include &quot;Node.h&quot;
<span class="line-removed"> 61 #include &quot;OffscreenCanvas.h&quot;</span>
 62 #include &quot;Page.h&quot;
 63 #include &quot;ScriptableDocumentParser.h&quot;
 64 #include &quot;Settings.h&quot;
 65 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
 66 #include &lt;JavaScriptCore/JSCInlines.h&gt;
 67 #include &lt;JavaScriptCore/ScriptArguments.h&gt;
 68 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 69 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;

 70 #include &lt;wtf/text/WTFString.h&gt;
 71 





 72 #if ENABLE(WEBGL)
 73 #include &quot;JSWebGLRenderingContext.h&quot;
 74 #include &quot;WebGLRenderingContext.h&quot;
 75 #endif
 76 
 77 #if ENABLE(WEBGL2)
 78 #include &quot;JSWebGL2RenderingContext.h&quot;
 79 #include &quot;WebGL2RenderingContext.h&quot;
 80 #endif
 81 
 82 namespace WebCore {
 83 using namespace Inspector;
 84 
 85 PageConsoleClient::PageConsoleClient(Page&amp; page)
 86     : m_page(page)
 87 {
 88 }
 89 
 90 PageConsoleClient::~PageConsoleClient() = default;
 91 
</pre>
<hr />
<pre>
110 void PageConsoleClient::unmute()
111 {
112     ASSERT(muteCount &gt; 0);
113     muteCount--;
114 }
115 
116 void PageConsoleClient::addMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp; consoleMessage)
117 {
118     if (!m_page.usesEphemeralSession()) {
119         String message;
120         if (consoleMessage-&gt;type() == MessageType::Image) {
121             ASSERT(consoleMessage-&gt;arguments());
122             consoleMessage-&gt;arguments()-&gt;getFirstArgumentAsString(message);
123         } else
124             message = consoleMessage-&gt;message();
125         m_page.chrome().client().addMessageToConsole(consoleMessage-&gt;source(), consoleMessage-&gt;level(), message, consoleMessage-&gt;line(), consoleMessage-&gt;column(), consoleMessage-&gt;url());
126 
127         if (UNLIKELY(m_page.settings().logsPageMessagesToSystemConsoleEnabled() || shouldPrintExceptions())) {
128             if (consoleMessage-&gt;type() == MessageType::Image) {
129                 ASSERT(consoleMessage-&gt;arguments());
<span class="line-modified">130                 ConsoleClient::printConsoleMessageWithArguments(MessageSource::ConsoleAPI, MessageType::Log, consoleMessage-&gt;level(), consoleMessage-&gt;arguments()-&gt;globalState(), *consoleMessage-&gt;arguments());</span>
131             } else
132                 ConsoleClient::printConsoleMessage(MessageSource::ConsoleAPI, MessageType::Log, consoleMessage-&gt;level(), consoleMessage-&gt;message(), consoleMessage-&gt;url(), consoleMessage-&gt;line(), consoleMessage-&gt;column());
133         }
134     }
135 
136     InspectorInstrumentation::addMessageToConsole(m_page, WTFMove(consoleMessage));
137 }
138 
139 void PageConsoleClient::addMessage(MessageSource source, MessageLevel level, const String&amp; message, unsigned long requestIdentifier, Document* document)
140 {
141     String url;
142     unsigned line = 0;
143     unsigned column = 0;
144     if (document)
145         document-&gt;getParserLocation(url, line, column);
146 
147     addMessage(source, level, message, url, line, column, 0, JSExecState::currentState(), requestIdentifier);
148 }
149 
150 void PageConsoleClient::addMessage(MessageSource source, MessageLevel level, const String&amp; message, Ref&lt;ScriptCallStack&gt;&amp;&amp; callStack)
151 {
152     addMessage(source, level, message, String(), 0, 0, WTFMove(callStack), 0);
153 }
154 
<span class="line-modified">155 void PageConsoleClient::addMessage(MessageSource source, MessageLevel level, const String&amp; messageText, const String&amp; suggestedURL, unsigned suggestedLineNumber, unsigned suggestedColumnNumber, RefPtr&lt;ScriptCallStack&gt;&amp;&amp; callStack, JSC::ExecState* state, unsigned long requestIdentifier)</span>
156 {
157     if (muteCount &amp;&amp; source != MessageSource::ConsoleAPI)
158         return;
159 
160     std::unique_ptr&lt;Inspector::ConsoleMessage&gt; message;
161 
162     if (callStack)
163         message = makeUnique&lt;Inspector::ConsoleMessage&gt;(source, MessageType::Log, level, messageText, callStack.releaseNonNull(), requestIdentifier);
164     else
<span class="line-modified">165         message = makeUnique&lt;Inspector::ConsoleMessage&gt;(source, MessageType::Log, level, messageText, suggestedURL, suggestedLineNumber, suggestedColumnNumber, state, requestIdentifier);</span>
166 
167     addMessage(WTFMove(message));
168 }
169 
170 
<span class="line-modified">171 void PageConsoleClient::messageWithTypeAndLevel(MessageType type, MessageLevel level, JSC::ExecState* exec, Ref&lt;Inspector::ScriptArguments&gt;&amp;&amp; arguments)</span>
172 {
173     String messageText;
174     bool gotMessage = arguments-&gt;getFirstArgumentAsString(messageText);
175 
<span class="line-modified">176     auto message = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::ConsoleAPI, type, level, messageText, arguments.copyRef(), exec);</span>
177 
178     String url = message-&gt;url();
179     unsigned lineNumber = message-&gt;line();
180     unsigned columnNumber = message-&gt;column();
181 
182     InspectorInstrumentation::addMessageToConsole(m_page, WTFMove(message));
183 
184     if (m_page.usesEphemeralSession())
185         return;
186 
187     if (gotMessage)
188         m_page.chrome().client().addMessageToConsole(MessageSource::ConsoleAPI, level, messageText, lineNumber, columnNumber, url);
189 
190     if (m_page.settings().logsPageMessagesToSystemConsoleEnabled() || PageConsoleClient::shouldPrintExceptions())
<span class="line-modified">191         ConsoleClient::printConsoleMessageWithArguments(MessageSource::ConsoleAPI, type, level, exec, WTFMove(arguments));</span>
192 }
193 
<span class="line-modified">194 void PageConsoleClient::count(JSC::ExecState* exec, const String&amp; label)</span>
195 {
<span class="line-modified">196     InspectorInstrumentation::consoleCount(m_page, exec, label);</span>
197 }
198 
<span class="line-modified">199 void PageConsoleClient::countReset(JSC::ExecState* exec, const String&amp; label)</span>
200 {
<span class="line-modified">201     InspectorInstrumentation::consoleCountReset(m_page, exec, label);</span>
202 }
203 
<span class="line-modified">204 void PageConsoleClient::profile(JSC::ExecState* exec, const String&amp; title)</span>
205 {
206     // FIXME: &lt;https://webkit.org/b/153499&gt; Web Inspector: console.profile should use the new Sampling Profiler
<span class="line-modified">207     InspectorInstrumentation::startProfiling(m_page, exec, title);</span>
208 }
209 
<span class="line-modified">210 void PageConsoleClient::profileEnd(JSC::ExecState* exec, const String&amp; title)</span>
211 {
212     // FIXME: &lt;https://webkit.org/b/153499&gt; Web Inspector: console.profile should use the new Sampling Profiler
<span class="line-modified">213     InspectorInstrumentation::stopProfiling(m_page, exec, title);</span>
214 }
215 
<span class="line-modified">216 void PageConsoleClient::takeHeapSnapshot(JSC::ExecState*, const String&amp; title)</span>
217 {
218     InspectorInstrumentation::takeHeapSnapshot(m_page.mainFrame(), title);
219 }
220 
<span class="line-modified">221 void PageConsoleClient::time(JSC::ExecState* exec, const String&amp; label)</span>
222 {
<span class="line-modified">223     InspectorInstrumentation::startConsoleTiming(m_page.mainFrame(), exec, label);</span>
224 }
225 
<span class="line-modified">226 void PageConsoleClient::timeLog(JSC::ExecState* exec, const String&amp; label, Ref&lt;ScriptArguments&gt;&amp;&amp; arguments)</span>
227 {
<span class="line-modified">228     InspectorInstrumentation::logConsoleTiming(m_page.mainFrame(), exec, label, WTFMove(arguments));</span>
229 }
230 
<span class="line-modified">231 void PageConsoleClient::timeEnd(JSC::ExecState* exec, const String&amp; label)</span>
232 {
<span class="line-modified">233     InspectorInstrumentation::stopConsoleTiming(m_page.mainFrame(), exec, label);</span>
234 }
235 
<span class="line-modified">236 void PageConsoleClient::timeStamp(JSC::ExecState*, Ref&lt;ScriptArguments&gt;&amp;&amp; arguments)</span>
237 {
238     InspectorInstrumentation::consoleTimeStamp(m_page.mainFrame(), WTFMove(arguments));
239 }
240 
241 static JSC::JSObject* objectArgumentAt(ScriptArguments&amp; arguments, unsigned index)
242 {
243     return arguments.argumentCount() &gt; index ? arguments.argumentAt(index).getObject() : nullptr;
244 }
245 
246 static CanvasRenderingContext* canvasRenderingContext(JSC::VM&amp; vm, JSC::JSValue target)
247 {
248     if (auto* canvas = JSHTMLCanvasElement::toWrapped(vm, target))
249         return canvas-&gt;renderingContext();

250     if (auto* canvas = JSOffscreenCanvas::toWrapped(vm, target))
251         return canvas-&gt;renderingContext();

252     if (auto* context = JSCanvasRenderingContext2D::toWrapped(vm, target))
253         return context;
254     if (auto* context = JSImageBitmapRenderingContext::toWrapped(vm, target))
255         return context;
256 #if ENABLE(WEBGL)
257     if (auto* context = JSWebGLRenderingContext::toWrapped(vm, target))
258         return context;
259 #endif
260 #if ENABLE(WEBGL2)
261     if (auto* context = JSWebGL2RenderingContext::toWrapped(vm, target))
262         return context;
263 #endif
264     return nullptr;
265 }
266 
<span class="line-modified">267 void PageConsoleClient::record(JSC::ExecState* state, Ref&lt;ScriptArguments&gt;&amp;&amp; arguments)</span>
268 {



269     if (auto* target = objectArgumentAt(arguments, 0)) {
<span class="line-modified">270         if (auto* context = canvasRenderingContext(state-&gt;vm(), target))</span>
<span class="line-modified">271             InspectorInstrumentation::consoleStartRecordingCanvas(*context, *state, objectArgumentAt(arguments, 1));</span>
272     }
273 }
274 
<span class="line-modified">275 void PageConsoleClient::recordEnd(JSC::ExecState* state, Ref&lt;ScriptArguments&gt;&amp;&amp; arguments)</span>
276 {



277     if (auto* target = objectArgumentAt(arguments, 0)) {
<span class="line-modified">278         if (auto* context = canvasRenderingContext(state-&gt;vm(), target))</span>
<span class="line-modified">279             InspectorInstrumentation::didFinishRecordingCanvasFrame(*context, true);</span>
280     }
281 }
282 
283 static Optional&lt;String&gt; snapshotCanvas(HTMLCanvasElement&amp; canvasElement, CanvasRenderingContext&amp; canvasRenderingContext)
284 {
285 #if ENABLE(WEBGL)
286     if (is&lt;WebGLRenderingContextBase&gt;(canvasRenderingContext))
287         downcast&lt;WebGLRenderingContextBase&gt;(canvasRenderingContext).setPreventBufferClearForInspector(true);
288 #endif
289 
290     auto result = canvasElement.toDataURL(&quot;image/png&quot;_s);
291 
292 #if ENABLE(WEBGL)
293     if (is&lt;WebGLRenderingContextBase&gt;(canvasRenderingContext))
294         downcast&lt;WebGLRenderingContextBase&gt;(canvasRenderingContext).setPreventBufferClearForInspector(false);
295 #endif
296 
297     if (!result.hasException())
298         return result.releaseReturnValue().string;
299 
300     return WTF::nullopt;
301 }
302 
<span class="line-modified">303 void PageConsoleClient::screenshot(JSC::ExecState* state, Ref&lt;ScriptArguments&gt;&amp;&amp; arguments)</span>
304 {
<span class="line-modified">305     JSC::VM&amp; vm = state-&gt;vm();</span>
306     String dataURL;
307     JSC::JSValue target;
308 
309     if (arguments-&gt;argumentCount()) {
310         auto possibleTarget = arguments-&gt;argumentAt(0);
311 
312         if (auto* node = JSNode::toWrapped(vm, possibleTarget)) {
313             target = possibleTarget;
314             if (UNLIKELY(InspectorInstrumentation::hasFrontends())) {
315                 std::unique_ptr&lt;ImageBuffer&gt; snapshot;
316 
317                 // Only try to do something special for subclasses of Node if they&#39;re detached from the DOM tree.
318                 if (!node-&gt;document().contains(node)) {
319                     auto snapshotImageElement = [&amp;snapshot] (HTMLImageElement&amp; imageElement) {
320                         if (auto* cachedImage = imageElement.cachedImage()) {
321                             auto* image = cachedImage-&gt;image();
322                             if (image &amp;&amp; image != &amp;Image::nullImage()) {
323                                 snapshot = ImageBuffer::create(image-&gt;size(), RenderingMode::Unaccelerated);
324                                 snapshot-&gt;context().drawImage(*image, FloatPoint(0, 0));
325                             }
</pre>
<hr />
<pre>
370             }
371         } else if (auto* imageBitmap = JSImageBitmap::toWrapped(vm, possibleTarget)) {
372             target = possibleTarget;
373             if (UNLIKELY(InspectorInstrumentation::hasFrontends())) {
374                 if (auto* imageBuffer = imageBitmap-&gt;buffer())
375                     dataURL = imageBuffer-&gt;toDataURL(&quot;image/png&quot;_s, WTF::nullopt, PreserveResolution::Yes);
376             }
377         } else if (auto* context = canvasRenderingContext(vm, possibleTarget)) {
378             auto&amp; canvas = context-&gt;canvasBase();
379             if (is&lt;HTMLCanvasElement&gt;(canvas)) {
380                 target = possibleTarget;
381                 if (UNLIKELY(InspectorInstrumentation::hasFrontends())) {
382                     if (auto result = snapshotCanvas(downcast&lt;HTMLCanvasElement&gt;(canvas), *context))
383                         dataURL = result.value();
384                 }
385             }
386 
387             // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations
388         } else {
389             String base64;
<span class="line-modified">390             if (possibleTarget.getString(state, base64) &amp;&amp; base64.startsWithIgnoringASCIICase(&quot;data:&quot;_s) &amp;&amp; base64.length() &gt; 5) {</span>
391                 target = possibleTarget;
392                 dataURL = base64;
393             }
394         }
395     }
396 
397     if (UNLIKELY(InspectorInstrumentation::hasFrontends())) {
398         if (!target) {
399             // If no target is provided, capture an image of the viewport.
400             IntRect imageRect(IntPoint::zero(), m_page.mainFrame().view()-&gt;sizeForVisibleContent());
401             if (auto snapshot = WebCore::snapshotFrameRect(m_page.mainFrame(), imageRect, SnapshotOptionsInViewCoordinates))
402                 dataURL = snapshot-&gt;toDataURL(&quot;image/png&quot;_s, WTF::nullopt, PreserveResolution::Yes);
403         }
404 
405         if (dataURL.isEmpty()) {
406             addMessage(makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Image, MessageLevel::Error, &quot;Could not capture screenshot&quot;_s, WTFMove(arguments)));
407             return;
408         }
409     }
410 
411     Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt; adjustedArguments;
412     adjustedArguments.append({ vm, target ? target : JSC::jsNontrivialString(vm, &quot;Viewport&quot;_s) });
413     for (size_t i = (!target ? 0 : 1); i &lt; arguments-&gt;argumentCount(); ++i)
414         adjustedArguments.append({ vm, arguments-&gt;argumentAt(i) });
<span class="line-modified">415     arguments = ScriptArguments::create(*state, WTFMove(adjustedArguments));</span>
416     addMessage(makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Image, MessageLevel::Log, dataURL, WTFMove(arguments)));
417 }
418 
419 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 39 #include &quot;FrameSnapshotting.h&quot;
 40 #include &quot;HTMLCanvasElement.h&quot;
 41 #include &quot;HTMLImageElement.h&quot;
 42 #include &quot;HTMLPictureElement.h&quot;
 43 #include &quot;HTMLVideoElement.h&quot;
 44 #include &quot;Image.h&quot;
 45 #include &quot;ImageBitmap.h&quot;
 46 #include &quot;ImageBitmapRenderingContext.h&quot;
 47 #include &quot;ImageBuffer.h&quot;
 48 #include &quot;ImageData.h&quot;
 49 #include &quot;InspectorController.h&quot;
 50 #include &quot;InspectorInstrumentation.h&quot;
 51 #include &quot;IntRect.h&quot;
 52 #include &quot;JSCanvasRenderingContext2D.h&quot;
 53 #include &quot;JSExecState.h&quot;
 54 #include &quot;JSHTMLCanvasElement.h&quot;
 55 #include &quot;JSImageBitmap.h&quot;
 56 #include &quot;JSImageBitmapRenderingContext.h&quot;
 57 #include &quot;JSImageData.h&quot;
 58 #include &quot;JSNode.h&quot;

 59 #include &quot;Node.h&quot;

 60 #include &quot;Page.h&quot;
 61 #include &quot;ScriptableDocumentParser.h&quot;
 62 #include &quot;Settings.h&quot;
 63 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
 64 #include &lt;JavaScriptCore/JSCInlines.h&gt;
 65 #include &lt;JavaScriptCore/ScriptArguments.h&gt;
 66 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 67 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
<span class="line-added"> 68 #include &lt;JavaScriptCore/StrongInlines.h&gt;</span>
 69 #include &lt;wtf/text/WTFString.h&gt;
 70 
<span class="line-added"> 71 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added"> 72 #include &quot;JSOffscreenCanvas.h&quot;</span>
<span class="line-added"> 73 #include &quot;OffscreenCanvas.h&quot;</span>
<span class="line-added"> 74 #endif</span>
<span class="line-added"> 75 </span>
 76 #if ENABLE(WEBGL)
 77 #include &quot;JSWebGLRenderingContext.h&quot;
 78 #include &quot;WebGLRenderingContext.h&quot;
 79 #endif
 80 
 81 #if ENABLE(WEBGL2)
 82 #include &quot;JSWebGL2RenderingContext.h&quot;
 83 #include &quot;WebGL2RenderingContext.h&quot;
 84 #endif
 85 
 86 namespace WebCore {
 87 using namespace Inspector;
 88 
 89 PageConsoleClient::PageConsoleClient(Page&amp; page)
 90     : m_page(page)
 91 {
 92 }
 93 
 94 PageConsoleClient::~PageConsoleClient() = default;
 95 
</pre>
<hr />
<pre>
114 void PageConsoleClient::unmute()
115 {
116     ASSERT(muteCount &gt; 0);
117     muteCount--;
118 }
119 
120 void PageConsoleClient::addMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp; consoleMessage)
121 {
122     if (!m_page.usesEphemeralSession()) {
123         String message;
124         if (consoleMessage-&gt;type() == MessageType::Image) {
125             ASSERT(consoleMessage-&gt;arguments());
126             consoleMessage-&gt;arguments()-&gt;getFirstArgumentAsString(message);
127         } else
128             message = consoleMessage-&gt;message();
129         m_page.chrome().client().addMessageToConsole(consoleMessage-&gt;source(), consoleMessage-&gt;level(), message, consoleMessage-&gt;line(), consoleMessage-&gt;column(), consoleMessage-&gt;url());
130 
131         if (UNLIKELY(m_page.settings().logsPageMessagesToSystemConsoleEnabled() || shouldPrintExceptions())) {
132             if (consoleMessage-&gt;type() == MessageType::Image) {
133                 ASSERT(consoleMessage-&gt;arguments());
<span class="line-modified">134                 ConsoleClient::printConsoleMessageWithArguments(MessageSource::ConsoleAPI, MessageType::Log, consoleMessage-&gt;level(), consoleMessage-&gt;arguments()-&gt;globalObject(), *consoleMessage-&gt;arguments());</span>
135             } else
136                 ConsoleClient::printConsoleMessage(MessageSource::ConsoleAPI, MessageType::Log, consoleMessage-&gt;level(), consoleMessage-&gt;message(), consoleMessage-&gt;url(), consoleMessage-&gt;line(), consoleMessage-&gt;column());
137         }
138     }
139 
140     InspectorInstrumentation::addMessageToConsole(m_page, WTFMove(consoleMessage));
141 }
142 
143 void PageConsoleClient::addMessage(MessageSource source, MessageLevel level, const String&amp; message, unsigned long requestIdentifier, Document* document)
144 {
145     String url;
146     unsigned line = 0;
147     unsigned column = 0;
148     if (document)
149         document-&gt;getParserLocation(url, line, column);
150 
151     addMessage(source, level, message, url, line, column, 0, JSExecState::currentState(), requestIdentifier);
152 }
153 
154 void PageConsoleClient::addMessage(MessageSource source, MessageLevel level, const String&amp; message, Ref&lt;ScriptCallStack&gt;&amp;&amp; callStack)
155 {
156     addMessage(source, level, message, String(), 0, 0, WTFMove(callStack), 0);
157 }
158 
<span class="line-modified">159 void PageConsoleClient::addMessage(MessageSource source, MessageLevel level, const String&amp; messageText, const String&amp; suggestedURL, unsigned suggestedLineNumber, unsigned suggestedColumnNumber, RefPtr&lt;ScriptCallStack&gt;&amp;&amp; callStack, JSC::JSGlobalObject* lexicalGlobalObject, unsigned long requestIdentifier)</span>
160 {
161     if (muteCount &amp;&amp; source != MessageSource::ConsoleAPI)
162         return;
163 
164     std::unique_ptr&lt;Inspector::ConsoleMessage&gt; message;
165 
166     if (callStack)
167         message = makeUnique&lt;Inspector::ConsoleMessage&gt;(source, MessageType::Log, level, messageText, callStack.releaseNonNull(), requestIdentifier);
168     else
<span class="line-modified">169         message = makeUnique&lt;Inspector::ConsoleMessage&gt;(source, MessageType::Log, level, messageText, suggestedURL, suggestedLineNumber, suggestedColumnNumber, lexicalGlobalObject, requestIdentifier);</span>
170 
171     addMessage(WTFMove(message));
172 }
173 
174 
<span class="line-modified">175 void PageConsoleClient::messageWithTypeAndLevel(MessageType type, MessageLevel level, JSC::JSGlobalObject* lexicalGlobalObject, Ref&lt;Inspector::ScriptArguments&gt;&amp;&amp; arguments)</span>
176 {
177     String messageText;
178     bool gotMessage = arguments-&gt;getFirstArgumentAsString(messageText);
179 
<span class="line-modified">180     auto message = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::ConsoleAPI, type, level, messageText, arguments.copyRef(), lexicalGlobalObject);</span>
181 
182     String url = message-&gt;url();
183     unsigned lineNumber = message-&gt;line();
184     unsigned columnNumber = message-&gt;column();
185 
186     InspectorInstrumentation::addMessageToConsole(m_page, WTFMove(message));
187 
188     if (m_page.usesEphemeralSession())
189         return;
190 
191     if (gotMessage)
192         m_page.chrome().client().addMessageToConsole(MessageSource::ConsoleAPI, level, messageText, lineNumber, columnNumber, url);
193 
194     if (m_page.settings().logsPageMessagesToSystemConsoleEnabled() || PageConsoleClient::shouldPrintExceptions())
<span class="line-modified">195         ConsoleClient::printConsoleMessageWithArguments(MessageSource::ConsoleAPI, type, level, lexicalGlobalObject, WTFMove(arguments));</span>
196 }
197 
<span class="line-modified">198 void PageConsoleClient::count(JSC::JSGlobalObject* lexicalGlobalObject, const String&amp; label)</span>
199 {
<span class="line-modified">200     InspectorInstrumentation::consoleCount(m_page, lexicalGlobalObject, label);</span>
201 }
202 
<span class="line-modified">203 void PageConsoleClient::countReset(JSC::JSGlobalObject* lexicalGlobalObject, const String&amp; label)</span>
204 {
<span class="line-modified">205     InspectorInstrumentation::consoleCountReset(m_page, lexicalGlobalObject, label);</span>
206 }
207 
<span class="line-modified">208 void PageConsoleClient::profile(JSC::JSGlobalObject* lexicalGlobalObject, const String&amp; title)</span>
209 {
210     // FIXME: &lt;https://webkit.org/b/153499&gt; Web Inspector: console.profile should use the new Sampling Profiler
<span class="line-modified">211     InspectorInstrumentation::startProfiling(m_page, lexicalGlobalObject, title);</span>
212 }
213 
<span class="line-modified">214 void PageConsoleClient::profileEnd(JSC::JSGlobalObject* lexicalGlobalObject, const String&amp; title)</span>
215 {
216     // FIXME: &lt;https://webkit.org/b/153499&gt; Web Inspector: console.profile should use the new Sampling Profiler
<span class="line-modified">217     InspectorInstrumentation::stopProfiling(m_page, lexicalGlobalObject, title);</span>
218 }
219 
<span class="line-modified">220 void PageConsoleClient::takeHeapSnapshot(JSC::JSGlobalObject*, const String&amp; title)</span>
221 {
222     InspectorInstrumentation::takeHeapSnapshot(m_page.mainFrame(), title);
223 }
224 
<span class="line-modified">225 void PageConsoleClient::time(JSC::JSGlobalObject* lexicalGlobalObject, const String&amp; label)</span>
226 {
<span class="line-modified">227     InspectorInstrumentation::startConsoleTiming(m_page.mainFrame(), lexicalGlobalObject, label);</span>
228 }
229 
<span class="line-modified">230 void PageConsoleClient::timeLog(JSC::JSGlobalObject* lexicalGlobalObject, const String&amp; label, Ref&lt;ScriptArguments&gt;&amp;&amp; arguments)</span>
231 {
<span class="line-modified">232     InspectorInstrumentation::logConsoleTiming(m_page.mainFrame(), lexicalGlobalObject, label, WTFMove(arguments));</span>
233 }
234 
<span class="line-modified">235 void PageConsoleClient::timeEnd(JSC::JSGlobalObject* lexicalGlobalObject, const String&amp; label)</span>
236 {
<span class="line-modified">237     InspectorInstrumentation::stopConsoleTiming(m_page.mainFrame(), lexicalGlobalObject, label);</span>
238 }
239 
<span class="line-modified">240 void PageConsoleClient::timeStamp(JSC::JSGlobalObject*, Ref&lt;ScriptArguments&gt;&amp;&amp; arguments)</span>
241 {
242     InspectorInstrumentation::consoleTimeStamp(m_page.mainFrame(), WTFMove(arguments));
243 }
244 
245 static JSC::JSObject* objectArgumentAt(ScriptArguments&amp; arguments, unsigned index)
246 {
247     return arguments.argumentCount() &gt; index ? arguments.argumentAt(index).getObject() : nullptr;
248 }
249 
250 static CanvasRenderingContext* canvasRenderingContext(JSC::VM&amp; vm, JSC::JSValue target)
251 {
252     if (auto* canvas = JSHTMLCanvasElement::toWrapped(vm, target))
253         return canvas-&gt;renderingContext();
<span class="line-added">254 #if ENABLE(OFFSCREEN_CANVAS)</span>
255     if (auto* canvas = JSOffscreenCanvas::toWrapped(vm, target))
256         return canvas-&gt;renderingContext();
<span class="line-added">257 #endif</span>
258     if (auto* context = JSCanvasRenderingContext2D::toWrapped(vm, target))
259         return context;
260     if (auto* context = JSImageBitmapRenderingContext::toWrapped(vm, target))
261         return context;
262 #if ENABLE(WEBGL)
263     if (auto* context = JSWebGLRenderingContext::toWrapped(vm, target))
264         return context;
265 #endif
266 #if ENABLE(WEBGL2)
267     if (auto* context = JSWebGL2RenderingContext::toWrapped(vm, target))
268         return context;
269 #endif
270     return nullptr;
271 }
272 
<span class="line-modified">273 void PageConsoleClient::record(JSC::JSGlobalObject* lexicalGlobalObject, Ref&lt;ScriptArguments&gt;&amp;&amp; arguments)</span>
274 {
<span class="line-added">275     if (LIKELY(!InspectorInstrumentation::hasFrontends()))</span>
<span class="line-added">276         return;</span>
<span class="line-added">277 </span>
278     if (auto* target = objectArgumentAt(arguments, 0)) {
<span class="line-modified">279         if (auto* context = canvasRenderingContext(lexicalGlobalObject-&gt;vm(), target))</span>
<span class="line-modified">280             InspectorInstrumentation::consoleStartRecordingCanvas(*context, *lexicalGlobalObject, objectArgumentAt(arguments, 1));</span>
281     }
282 }
283 
<span class="line-modified">284 void PageConsoleClient::recordEnd(JSC::JSGlobalObject* lexicalGlobalObject, Ref&lt;ScriptArguments&gt;&amp;&amp; arguments)</span>
285 {
<span class="line-added">286     if (LIKELY(!InspectorInstrumentation::hasFrontends()))</span>
<span class="line-added">287         return;</span>
<span class="line-added">288 </span>
289     if (auto* target = objectArgumentAt(arguments, 0)) {
<span class="line-modified">290         if (auto* context = canvasRenderingContext(lexicalGlobalObject-&gt;vm(), target))</span>
<span class="line-modified">291             InspectorInstrumentation::consoleStopRecordingCanvas(*context);</span>
292     }
293 }
294 
295 static Optional&lt;String&gt; snapshotCanvas(HTMLCanvasElement&amp; canvasElement, CanvasRenderingContext&amp; canvasRenderingContext)
296 {
297 #if ENABLE(WEBGL)
298     if (is&lt;WebGLRenderingContextBase&gt;(canvasRenderingContext))
299         downcast&lt;WebGLRenderingContextBase&gt;(canvasRenderingContext).setPreventBufferClearForInspector(true);
300 #endif
301 
302     auto result = canvasElement.toDataURL(&quot;image/png&quot;_s);
303 
304 #if ENABLE(WEBGL)
305     if (is&lt;WebGLRenderingContextBase&gt;(canvasRenderingContext))
306         downcast&lt;WebGLRenderingContextBase&gt;(canvasRenderingContext).setPreventBufferClearForInspector(false);
307 #endif
308 
309     if (!result.hasException())
310         return result.releaseReturnValue().string;
311 
312     return WTF::nullopt;
313 }
314 
<span class="line-modified">315 void PageConsoleClient::screenshot(JSC::JSGlobalObject* lexicalGlobalObject, Ref&lt;ScriptArguments&gt;&amp;&amp; arguments)</span>
316 {
<span class="line-modified">317     JSC::VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
318     String dataURL;
319     JSC::JSValue target;
320 
321     if (arguments-&gt;argumentCount()) {
322         auto possibleTarget = arguments-&gt;argumentAt(0);
323 
324         if (auto* node = JSNode::toWrapped(vm, possibleTarget)) {
325             target = possibleTarget;
326             if (UNLIKELY(InspectorInstrumentation::hasFrontends())) {
327                 std::unique_ptr&lt;ImageBuffer&gt; snapshot;
328 
329                 // Only try to do something special for subclasses of Node if they&#39;re detached from the DOM tree.
330                 if (!node-&gt;document().contains(node)) {
331                     auto snapshotImageElement = [&amp;snapshot] (HTMLImageElement&amp; imageElement) {
332                         if (auto* cachedImage = imageElement.cachedImage()) {
333                             auto* image = cachedImage-&gt;image();
334                             if (image &amp;&amp; image != &amp;Image::nullImage()) {
335                                 snapshot = ImageBuffer::create(image-&gt;size(), RenderingMode::Unaccelerated);
336                                 snapshot-&gt;context().drawImage(*image, FloatPoint(0, 0));
337                             }
</pre>
<hr />
<pre>
382             }
383         } else if (auto* imageBitmap = JSImageBitmap::toWrapped(vm, possibleTarget)) {
384             target = possibleTarget;
385             if (UNLIKELY(InspectorInstrumentation::hasFrontends())) {
386                 if (auto* imageBuffer = imageBitmap-&gt;buffer())
387                     dataURL = imageBuffer-&gt;toDataURL(&quot;image/png&quot;_s, WTF::nullopt, PreserveResolution::Yes);
388             }
389         } else if (auto* context = canvasRenderingContext(vm, possibleTarget)) {
390             auto&amp; canvas = context-&gt;canvasBase();
391             if (is&lt;HTMLCanvasElement&gt;(canvas)) {
392                 target = possibleTarget;
393                 if (UNLIKELY(InspectorInstrumentation::hasFrontends())) {
394                     if (auto result = snapshotCanvas(downcast&lt;HTMLCanvasElement&gt;(canvas), *context))
395                         dataURL = result.value();
396                 }
397             }
398 
399             // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations
400         } else {
401             String base64;
<span class="line-modified">402             if (possibleTarget.getString(lexicalGlobalObject, base64) &amp;&amp; base64.startsWithIgnoringASCIICase(&quot;data:&quot;_s) &amp;&amp; base64.length() &gt; 5) {</span>
403                 target = possibleTarget;
404                 dataURL = base64;
405             }
406         }
407     }
408 
409     if (UNLIKELY(InspectorInstrumentation::hasFrontends())) {
410         if (!target) {
411             // If no target is provided, capture an image of the viewport.
412             IntRect imageRect(IntPoint::zero(), m_page.mainFrame().view()-&gt;sizeForVisibleContent());
413             if (auto snapshot = WebCore::snapshotFrameRect(m_page.mainFrame(), imageRect, SnapshotOptionsInViewCoordinates))
414                 dataURL = snapshot-&gt;toDataURL(&quot;image/png&quot;_s, WTF::nullopt, PreserveResolution::Yes);
415         }
416 
417         if (dataURL.isEmpty()) {
418             addMessage(makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Image, MessageLevel::Error, &quot;Could not capture screenshot&quot;_s, WTFMove(arguments)));
419             return;
420         }
421     }
422 
423     Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt; adjustedArguments;
424     adjustedArguments.append({ vm, target ? target : JSC::jsNontrivialString(vm, &quot;Viewport&quot;_s) });
425     for (size_t i = (!target ? 0 : 1); i &lt; arguments-&gt;argumentCount(); ++i)
426         adjustedArguments.append({ vm, arguments-&gt;argumentAt(i) });
<span class="line-modified">427     arguments = ScriptArguments::create(lexicalGlobalObject, WTFMove(adjustedArguments));</span>
428     addMessage(makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Image, MessageLevel::Log, dataURL, WTFMove(arguments)));
429 }
430 
431 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="PageConfiguration.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PageConsoleClient.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/platform/PODIntervalTree.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2010 Google Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 16  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 17  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 18  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 19  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 20  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 21  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 23  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #ifndef PODIntervalTree_h
 27 #define PODIntervalTree_h
 28 
 29 #include &quot;PODInterval.h&quot;
 30 #include &quot;PODRedBlackTree.h&quot;
 31 #include &lt;wtf/Assertions.h&gt;
 32 #include &lt;wtf/Noncopyable.h&gt;
 33 #include &lt;wtf/Optional.h&gt;
 34 #include &lt;wtf/Vector.h&gt;
 35 #include &lt;wtf/text/ValueToString.h&gt;
 36 
 37 namespace WebCore {
 38 
 39 template &lt;class T, class UserData = void*&gt;
 40 class PODIntervalSearchAdapter {
 41 public:
 42     typedef PODInterval&lt;T, UserData&gt; IntervalType;
 43 
 44     PODIntervalSearchAdapter(Vector&lt;IntervalType&gt;&amp; result, const T&amp; lowValue, const T&amp; highValue)
 45         : m_result(result)
 46         , m_lowValue(lowValue)
 47         , m_highValue(highValue)
 48     {
 49     }
 50 
 51     const T&amp; lowValue() const { return m_lowValue; }
 52     const T&amp; highValue() const { return m_highValue; }
 53     void collectIfNeeded(const IntervalType&amp; data) const
 54     {
 55         if (data.overlaps(m_lowValue, m_highValue))
 56             m_result.append(data);
 57     }
 58 
 59 private:
 60     Vector&lt;IntervalType&gt;&amp; m_result;
 61     T m_lowValue;
 62     T m_highValue;
 63 };
 64 
 65 // An interval tree, which is a form of augmented red-black tree. It
 66 // supports efficient (O(lg n)) insertion, removal and querying of
 67 // intervals in the tree.
 68 template&lt;class T, class UserData = void*&gt;
 69 class PODIntervalTree : public PODRedBlackTree&lt;PODInterval&lt;T, UserData&gt;&gt; {
 70     WTF_MAKE_FAST_ALLOCATED;
 71     WTF_MAKE_NONCOPYABLE(PODIntervalTree);
 72 public:
 73     // Typedef to reduce typing when declaring intervals to be stored in
 74     // this tree.
 75     typedef PODInterval&lt;T, UserData&gt; IntervalType;
 76     typedef PODIntervalSearchAdapter&lt;T, UserData&gt; IntervalSearchAdapterType;
 77 
 78     PODIntervalTree()
 79         : PODRedBlackTree&lt;IntervalType&gt;()
 80     {
 81         init();
 82     }
 83 
 84     // Returns all intervals in the tree which overlap the given query
 85     // interval. The returned intervals are sorted by increasing low
 86     // endpoint.
 87     Vector&lt;IntervalType&gt; allOverlaps(const IntervalType&amp; interval) const
 88     {
 89         Vector&lt;IntervalType&gt; result;
 90         allOverlaps(interval, result);
 91         return result;
 92     }
 93 
 94     // Returns all intervals in the tree which overlap the given query
 95     // interval. The returned intervals are sorted by increasing low
 96     // endpoint.
 97     void allOverlaps(const IntervalType&amp; interval, Vector&lt;IntervalType&gt;&amp; result) const
 98     {
 99         // Explicit dereference of &quot;this&quot; required because of
100         // inheritance rules in template classes.
101         IntervalSearchAdapterType adapter(result, interval.low(), interval.high());
102         searchForOverlapsFrom&lt;IntervalSearchAdapterType&gt;(this-&gt;root(), adapter);
103     }
104 
105     template &lt;class AdapterType&gt;
106     void allOverlapsWithAdapter(AdapterType&amp; adapter) const
107     {
108         // Explicit dereference of &quot;this&quot; required because of
109         // inheritance rules in template classes.
110         searchForOverlapsFrom&lt;AdapterType&gt;(this-&gt;root(), adapter);
111     }
112 
113     // Helper to create interval objects.
114     static IntervalType createInterval(const T&amp; low, const T&amp; high, const UserData data = 0)
115     {
116         return IntervalType(low, high, data);
117     }
118 
119     Optional&lt;IntervalType&gt; nextIntervalAfter(const IntervalType&amp; interval)
120     {
121         auto next = smallestNodeGreaterThanFrom(interval, this-&gt;root());
122         if (!next)
123             return WTF::nullopt;
124 
125         return next-&gt;data();
126     }
127 
128     bool checkInvariants() const override
129     {
130         if (!PODRedBlackTree&lt;IntervalType&gt;::checkInvariants())
131             return false;
132         if (!this-&gt;root())
133             return true;
134         return checkInvariantsFromNode(this-&gt;root(), 0);
135     }
136 
137 private:
138     typedef typename PODRedBlackTree&lt;IntervalType&gt;::Node IntervalNode;
139 
140     // Initializes the tree.
141     void init()
142     {
143         // Explicit dereference of &quot;this&quot; required because of
144         // inheritance rules in template classes.
145         this-&gt;setNeedsFullOrderingComparisons(true);
146     }
147 
148     // Starting from the given node, adds all overlaps with the given
149     // interval to the result vector. The intervals are sorted by
150     // increasing low endpoint.
151     template &lt;class AdapterType&gt;
152     void searchForOverlapsFrom(IntervalNode* node, AdapterType&amp; adapter) const
153     {
154         if (!node)
155             return;
156 
157         // Because the intervals are sorted by left endpoint, inorder
158         // traversal produces results sorted as desired.
159 
160         // See whether we need to traverse the left subtree.
161         IntervalNode* left = node-&gt;left();
162         if (left
163             // This is phrased this way to avoid the need for operator
164             // &lt;= on type T.
165             &amp;&amp; !(left-&gt;data().maxHigh() &lt; adapter.lowValue()))
166             searchForOverlapsFrom&lt;AdapterType&gt;(left, adapter);
167 
168         // Check for overlap with current node.
169         adapter.collectIfNeeded(node-&gt;data());
170 
171         // See whether we need to traverse the right subtree.
172         // This is phrased this way to avoid the need for operator &lt;=
173         // on type T.
174         if (!(adapter.highValue() &lt; node-&gt;data().low()))
175             searchForOverlapsFrom&lt;AdapterType&gt;(node-&gt;right(), adapter);
176     }
177 
178     IntervalNode* smallestNodeGreaterThanFrom(const IntervalType&amp; interval, IntervalNode* node) const
179     {
180         if (!node)
181             return nullptr;
182 
183         if (!(interval.high() &lt; node-&gt;data().low()))
184             return smallestNodeGreaterThanFrom(interval, node-&gt;right());
185 
186         if (auto left = smallestNodeGreaterThanFrom(interval, node-&gt;right()))
187             return left;
188 
189         return node;
190 }
191 
192     bool updateNode(IntervalNode* node) override
193     {
194         // Would use const T&amp;, but need to reassign this reference in this
195         // function.
196         const T* curMax = &amp;node-&gt;data().high();
197         IntervalNode* left = node-&gt;left();
198         if (left) {
199             if (*curMax &lt; left-&gt;data().maxHigh())
200                 curMax = &amp;left-&gt;data().maxHigh();
201         }
202         IntervalNode* right = node-&gt;right();
203         if (right) {
204             if (*curMax &lt; right-&gt;data().maxHigh())
205                 curMax = &amp;right-&gt;data().maxHigh();
206         }
207         // This is phrased like this to avoid needing operator!= on type T.
208         if (!(*curMax == node-&gt;data().maxHigh())) {
209             node-&gt;data().setMaxHigh(*curMax);
210             return true;
211         }
212         return false;
213     }
214 
215     bool checkInvariantsFromNode(IntervalNode* node, T* currentMaxValue) const
216     {
217         // These assignments are only done in order to avoid requiring
218         // a default constructor on type T.
219         T leftMaxValue(node-&gt;data().maxHigh());
220         T rightMaxValue(node-&gt;data().maxHigh());
221         IntervalNode* left = node-&gt;left();
222         IntervalNode* right = node-&gt;right();
223         if (left) {
224             if (!checkInvariantsFromNode(left, &amp;leftMaxValue))
225                 return false;
226         }
227         if (right) {
228             if (!checkInvariantsFromNode(right, &amp;rightMaxValue))
229                 return false;
230         }
231         if (!left &amp;&amp; !right) {
232             // Base case.
233             if (currentMaxValue)
234                 *currentMaxValue = node-&gt;data().high();
235             return (node-&gt;data().high() == node-&gt;data().maxHigh());
236         }
237         T localMaxValue(node-&gt;data().maxHigh());
238         if (!left || !right) {
239             if (left)
240                 localMaxValue = leftMaxValue;
241             else
242                 localMaxValue = rightMaxValue;
243         } else
244             localMaxValue = (leftMaxValue &lt; rightMaxValue) ? rightMaxValue : leftMaxValue;
245         if (localMaxValue &lt; node-&gt;data().high())
246             localMaxValue = node-&gt;data().high();
247         if (!(localMaxValue == node-&gt;data().maxHigh())) {
248 #ifndef NDEBUG
249             String localMaxValueString = ValueToString&lt;T&gt;::string(localMaxValue);
250             LOG_ERROR(&quot;PODIntervalTree verification failed at node 0x%p: localMaxValue=%s and data=%s&quot;,
251                       node, localMaxValueString.utf8().data(), node-&gt;data().toString().utf8().data());
252 #endif
253             return false;
254         }
255         if (currentMaxValue)
256             *currentMaxValue = localMaxValue;
257         return true;
258     }
259 };
260 
261 } // namespace WebCore
262 
263 #ifndef NDEBUG
264 namespace WTF {
265 
266 // Support for printing PODIntervals at the PODRedBlackTree level.
267 template&lt;class T, class UserData&gt;
268 struct ValueToString&lt;WebCore::PODInterval&lt;T, UserData&gt;&gt; {
269     static String string(const WebCore::PODInterval&lt;T, UserData&gt;&amp; interval)
270     {
271         return interval.toString();
272     }
273 };
274 
275 } // namespace WTF
276 #endif
277 
278 #endif // PODIntervalTree_h
    </pre>
  </body>
</html>
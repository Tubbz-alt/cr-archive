<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorController.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011 Google Inc. All rights reserved.
  3  * Copyright (C) 2014, 2015 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;InspectorController.h&quot;
 34 
 35 #include &quot;CommandLineAPIHost.h&quot;
 36 #include &quot;CommonVM.h&quot;
 37 #include &quot;DOMWindow.h&quot;
 38 #include &quot;DOMWrapperWorld.h&quot;
 39 #include &quot;Frame.h&quot;
 40 #include &quot;GraphicsContext.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 41 #include &quot;InspectorAnimationAgent.h&quot;</span>
 42 #include &quot;InspectorApplicationCacheAgent.h&quot;
 43 #include &quot;InspectorCPUProfilerAgent.h&quot;
 44 #include &quot;InspectorCSSAgent.h&quot;
 45 #include &quot;InspectorCanvasAgent.h&quot;
 46 #include &quot;InspectorClient.h&quot;
 47 #include &quot;InspectorDOMAgent.h&quot;
<a name="2" id="anc2"></a>
 48 #include &quot;InspectorDOMStorageAgent.h&quot;
 49 #include &quot;InspectorDatabaseAgent.h&quot;
 50 #include &quot;InspectorDatabaseResource.h&quot;
 51 #include &quot;InspectorFrontendClient.h&quot;
 52 #include &quot;InspectorIndexedDBAgent.h&quot;
 53 #include &quot;InspectorInstrumentation.h&quot;
 54 #include &quot;InspectorLayerTreeAgent.h&quot;
 55 #include &quot;InspectorMemoryAgent.h&quot;
 56 #include &quot;InspectorPageAgent.h&quot;
 57 #include &quot;InspectorTimelineAgent.h&quot;
 58 #include &quot;InspectorWorkerAgent.h&quot;
 59 #include &quot;InstrumentingAgents.h&quot;
 60 #include &quot;JSDOMBindingSecurity.h&quot;
 61 #include &quot;JSDOMWindow.h&quot;
 62 #include &quot;JSDOMWindowCustom.h&quot;
 63 #include &quot;JSExecState.h&quot;
 64 #include &quot;Page.h&quot;
 65 #include &quot;PageAuditAgent.h&quot;
 66 #include &quot;PageConsoleAgent.h&quot;
<a name="3" id="anc3"></a><span class="line-added"> 67 #include &quot;PageDOMDebuggerAgent.h&quot;</span>
 68 #include &quot;PageDebuggerAgent.h&quot;
 69 #include &quot;PageHeapAgent.h&quot;
 70 #include &quot;PageNetworkAgent.h&quot;
 71 #include &quot;PageRuntimeAgent.h&quot;
 72 #include &quot;PageScriptDebugServer.h&quot;
 73 #include &quot;Settings.h&quot;
<a name="4" id="anc4"></a><span class="line-added"> 74 #include &quot;SharedBuffer.h&quot;</span>
 75 #include &quot;WebInjectedScriptHost.h&quot;
 76 #include &quot;WebInjectedScriptManager.h&quot;
 77 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
 78 #include &lt;JavaScriptCore/InspectorAgent.h&gt;
 79 #include &lt;JavaScriptCore/InspectorBackendDispatcher.h&gt;
 80 #include &lt;JavaScriptCore/InspectorBackendDispatchers.h&gt;
 81 #include &lt;JavaScriptCore/InspectorFrontendDispatchers.h&gt;
 82 #include &lt;JavaScriptCore/InspectorFrontendRouter.h&gt;
 83 #include &lt;JavaScriptCore/InspectorScriptProfilerAgent.h&gt;
 84 #include &lt;JavaScriptCore/JSLock.h&gt;
 85 #include &lt;wtf/Stopwatch.h&gt;
 86 
 87 #if ENABLE(REMOTE_INSPECTOR)
 88 #include &quot;PageDebuggable.h&quot;
 89 #endif
 90 
 91 namespace WebCore {
 92 
 93 using namespace JSC;
 94 using namespace Inspector;
 95 
 96 InspectorController::InspectorController(Page&amp; page, InspectorClient* inspectorClient)
 97     : m_instrumentingAgents(InstrumentingAgents::create(*this))
 98     , m_injectedScriptManager(makeUnique&lt;WebInjectedScriptManager&gt;(*this, WebInjectedScriptHost::create()))
 99     , m_frontendRouter(FrontendRouter::create())
100     , m_backendDispatcher(BackendDispatcher::create(m_frontendRouter.copyRef()))
101     , m_overlay(makeUnique&lt;InspectorOverlay&gt;(page, inspectorClient))
102     , m_executionStopwatch(Stopwatch::create())
103     , m_scriptDebugServer(page)
104     , m_page(page)
105     , m_inspectorClient(inspectorClient)
106 {
107     ASSERT_ARG(inspectorClient, inspectorClient);
108 
109     auto pageContext = pageAgentContext();
110 
111     auto consoleAgent = makeUnique&lt;PageConsoleAgent&gt;(pageContext);
112     m_instrumentingAgents-&gt;setWebConsoleAgent(consoleAgent.get());
113     m_agents.append(WTFMove(consoleAgent));
114 }
115 
116 InspectorController::~InspectorController()
117 {
118     m_instrumentingAgents-&gt;reset();
119     ASSERT(!m_inspectorClient);
120 }
121 
122 PageAgentContext InspectorController::pageAgentContext()
123 {
124     AgentContext baseContext = {
125         *this,
126         *m_injectedScriptManager,
127         m_frontendRouter.get(),
128         m_backendDispatcher.get()
129     };
130 
131     WebAgentContext webContext = {
132         baseContext,
133         m_instrumentingAgents.get()
134     };
135 
136     PageAgentContext pageContext = {
137         webContext,
138         m_page
139     };
140 
141     return pageContext;
142 }
143 
144 void InspectorController::createLazyAgents()
145 {
146     if (m_didCreateLazyAgents)
147         return;
148 
149     m_didCreateLazyAgents = true;
150 
151     m_injectedScriptManager-&gt;connect();
152 
153     auto pageContext = pageAgentContext();
154 
155     ensureInspectorAgent();
156     ensurePageAgent();
157 
158     m_agents.append(makeUnique&lt;PageRuntimeAgent&gt;(pageContext));
159 
160     auto debuggerAgent = makeUnique&lt;PageDebuggerAgent&gt;(pageContext);
161     auto debuggerAgentPtr = debuggerAgent.get();
162     m_agents.append(WTFMove(debuggerAgent));
163 
164     m_agents.append(makeUnique&lt;PageNetworkAgent&gt;(pageContext));
165     m_agents.append(makeUnique&lt;InspectorCSSAgent&gt;(pageContext));
166     ensureDOMAgent();
<a name="5" id="anc5"></a><span class="line-modified">167     m_agents.append(makeUnique&lt;PageDOMDebuggerAgent&gt;(pageContext, debuggerAgentPtr));</span>
168     m_agents.append(makeUnique&lt;InspectorApplicationCacheAgent&gt;(pageContext));
169     m_agents.append(makeUnique&lt;InspectorLayerTreeAgent&gt;(pageContext));
170     m_agents.append(makeUnique&lt;InspectorWorkerAgent&gt;(pageContext));
171     m_agents.append(makeUnique&lt;InspectorDOMStorageAgent&gt;(pageContext));
172     m_agents.append(makeUnique&lt;InspectorDatabaseAgent&gt;(pageContext));
173 #if ENABLE(INDEXED_DATABASE)
174     m_agents.append(makeUnique&lt;InspectorIndexedDBAgent&gt;(pageContext));
175 #endif
176 
177     auto scriptProfilerAgentPtr = makeUnique&lt;InspectorScriptProfilerAgent&gt;(pageContext);
178     m_instrumentingAgents-&gt;setInspectorScriptProfilerAgent(scriptProfilerAgentPtr.get());
179     m_agents.append(WTFMove(scriptProfilerAgentPtr));
180 
181 #if ENABLE(RESOURCE_USAGE)
182     m_agents.append(makeUnique&lt;InspectorCPUProfilerAgent&gt;(pageContext));
183     m_agents.append(makeUnique&lt;InspectorMemoryAgent&gt;(pageContext));
184 #endif
185     m_agents.append(makeUnique&lt;PageHeapAgent&gt;(pageContext));
186     m_agents.append(makeUnique&lt;PageAuditAgent&gt;(pageContext));
187     m_agents.append(makeUnique&lt;InspectorCanvasAgent&gt;(pageContext));
188     m_agents.append(makeUnique&lt;InspectorTimelineAgent&gt;(pageContext));
<a name="6" id="anc6"></a><span class="line-added">189     m_agents.append(makeUnique&lt;InspectorAnimationAgent&gt;(pageContext));</span>
190 
191     if (auto&amp; commandLineAPIHost = m_injectedScriptManager-&gt;commandLineAPIHost())
192         commandLineAPIHost-&gt;init(m_instrumentingAgents.copyRef());
193 }
194 
195 void InspectorController::inspectedPageDestroyed()
196 {
197     // Clean up resources and disconnect local and remote frontends.
198     disconnectAllFrontends();
199 
200     // Disconnect the client.
201     m_inspectorClient-&gt;inspectedPageDestroyed();
202     m_inspectorClient = nullptr;
203 
204     m_agents.discardValues();
205 }
206 
207 void InspectorController::setInspectorFrontendClient(InspectorFrontendClient* inspectorFrontendClient)
208 {
209     m_inspectorFrontendClient = inspectorFrontendClient;
210 }
211 
212 bool InspectorController::hasLocalFrontend() const
213 {
214     return m_frontendRouter-&gt;hasLocalFrontend();
215 }
216 
217 bool InspectorController::hasRemoteFrontend() const
218 {
219     return m_frontendRouter-&gt;hasRemoteFrontend();
220 }
221 
222 unsigned InspectorController::inspectionLevel() const
223 {
224     return m_inspectorFrontendClient ? m_inspectorFrontendClient-&gt;inspectionLevel() : 0;
225 }
226 
227 void InspectorController::didClearWindowObjectInWorld(Frame&amp; frame, DOMWrapperWorld&amp; world)
228 {
229     if (&amp;world != &amp;mainThreadNormalWorld())
230         return;
231 
232     if (frame.isMainFrame())
233         m_injectedScriptManager-&gt;discardInjectedScripts();
234 
235     // If the page is supposed to serve as InspectorFrontend notify inspector frontend
236     // client that it&#39;s cleared so that the client can expose inspector bindings.
237     if (m_inspectorFrontendClient &amp;&amp; frame.isMainFrame())
238         m_inspectorFrontendClient-&gt;windowObjectCleared();
239 }
240 
241 void InspectorController::connectFrontend(Inspector::FrontendChannel&amp; frontendChannel, bool isAutomaticInspection, bool immediatelyPause)
242 {
243     ASSERT(m_inspectorClient);
244 
245     // If a frontend has connected enable the developer extras and keep them enabled.
246     m_page.settings().setDeveloperExtrasEnabled(true);
247 
248     createLazyAgents();
249 
250     bool connectedFirstFrontend = !m_frontendRouter-&gt;hasFrontends();
251     m_isAutomaticInspection = isAutomaticInspection;
252     m_pauseAfterInitialization = immediatelyPause;
253 
254     m_frontendRouter-&gt;connectFrontend(frontendChannel);
255 
256     InspectorInstrumentation::frontendCreated();
257 
258     if (connectedFirstFrontend) {
259         InspectorInstrumentation::registerInstrumentingAgents(m_instrumentingAgents.get());
260         m_agents.didCreateFrontendAndBackend(&amp;m_frontendRouter.get(), &amp;m_backendDispatcher.get());
261     }
262 
263     m_inspectorClient-&gt;frontendCountChanged(m_frontendRouter-&gt;frontendCount());
264 
265 #if ENABLE(REMOTE_INSPECTOR)
266     if (hasLocalFrontend())
267         m_page.remoteInspectorInformationDidChange();
268 #endif
269 }
270 
271 void InspectorController::disconnectFrontend(FrontendChannel&amp; frontendChannel)
272 {
273     m_frontendRouter-&gt;disconnectFrontend(frontendChannel);
274 
275     m_isAutomaticInspection = false;
276     m_pauseAfterInitialization = false;
277 
278     InspectorInstrumentation::frontendDeleted();
279 
280     bool disconnectedLastFrontend = !m_frontendRouter-&gt;hasFrontends();
281     if (disconnectedLastFrontend) {
282         // Notify agents first.
283         m_agents.willDestroyFrontendAndBackend(DisconnectReason::InspectorDestroyed);
284 
285         // Clean up inspector resources.
286         m_injectedScriptManager-&gt;discardInjectedScripts();
287 
288         // Unplug all instrumentations since they aren&#39;t needed now.
289         InspectorInstrumentation::unregisterInstrumentingAgents(m_instrumentingAgents.get());
290     }
291 
292     m_inspectorClient-&gt;frontendCountChanged(m_frontendRouter-&gt;frontendCount());
293 
294 #if ENABLE(REMOTE_INSPECTOR)
295     if (disconnectedLastFrontend)
296         m_page.remoteInspectorInformationDidChange();
297 #endif
298 }
299 
300 void InspectorController::disconnectAllFrontends()
301 {
302     // If the local frontend page was destroyed, close the window.
303     if (m_inspectorFrontendClient)
304         m_inspectorFrontendClient-&gt;closeWindow();
305 
306     // The frontend should call setInspectorFrontendClient(nullptr) under closeWindow().
307     ASSERT(!m_inspectorFrontendClient);
308 
309     if (!m_frontendRouter-&gt;hasFrontends())
310         return;
311 
312     for (unsigned i = 0; i &lt; m_frontendRouter-&gt;frontendCount(); ++i)
313         InspectorInstrumentation::frontendDeleted();
314 
315     // Unplug all instrumentations to prevent further agent callbacks.
316     InspectorInstrumentation::unregisterInstrumentingAgents(m_instrumentingAgents.get());
317 
318     // Notify agents first, since they may need to use InspectorClient.
319     m_agents.willDestroyFrontendAndBackend(DisconnectReason::InspectedTargetDestroyed);
320 
321     // Clean up inspector resources.
322     m_injectedScriptManager-&gt;disconnect();
323 
324     // Disconnect any remaining remote frontends.
325     m_frontendRouter-&gt;disconnectAllFrontends();
326     m_isAutomaticInspection = false;
327     m_pauseAfterInitialization = false;
328 
329     m_inspectorClient-&gt;frontendCountChanged(m_frontendRouter-&gt;frontendCount());
330 
331 #if ENABLE(REMOTE_INSPECTOR)
332     m_page.remoteInspectorInformationDidChange();
333 #endif
334 }
335 
336 void InspectorController::show()
337 {
338     ASSERT(!hasRemoteFrontend());
339 
340     if (!enabled())
341         return;
342 
343     if (m_frontendRouter-&gt;hasLocalFrontend())
344         m_inspectorClient-&gt;bringFrontendToFront();
345     else if (Inspector::FrontendChannel* frontendChannel = m_inspectorClient-&gt;openLocalFrontend(this))
346         connectFrontend(*frontendChannel);
347 }
348 
<a name="7" id="anc7"></a>










349 void InspectorController::evaluateForTestInFrontend(const String&amp; script)
350 {
351     ensureInspectorAgent().evaluateForTestInFrontend(script);
352 }
353 
354 void InspectorController::drawHighlight(GraphicsContext&amp; context) const
355 {
356     m_overlay-&gt;paint(context);
357 }
358 
359 void InspectorController::getHighlight(Highlight&amp; highlight, InspectorOverlay::CoordinateSystem coordinateSystem) const
360 {
361     m_overlay-&gt;getHighlight(highlight, coordinateSystem);
362 }
363 
364 void InspectorController::inspect(Node* node)
365 {
366     if (!enabled())
367         return;
368 
369     if (!hasRemoteFrontend())
370         show();
371 
372     ensureDOMAgent().inspect(node);
373 }
374 
375 bool InspectorController::enabled() const
376 {
377     return developerExtrasEnabled();
378 }
379 
380 Page&amp; InspectorController::inspectedPage() const
381 {
382     return m_page;
383 }
384 
385 void InspectorController::dispatchMessageFromFrontend(const String&amp; message)
386 {
387     m_backendDispatcher-&gt;dispatch(message);
388 }
389 
390 void InspectorController::hideHighlight()
391 {
392     m_overlay-&gt;hideHighlight();
393 }
394 
395 Node* InspectorController::highlightedNode() const
396 {
397     return m_overlay-&gt;highlightedNode();
398 }
399 
400 void InspectorController::setIndicating(bool indicating)
401 {
402 #if !PLATFORM(IOS_FAMILY)
403     m_overlay-&gt;setIndicating(indicating);
404 #else
405     if (indicating)
406         m_inspectorClient-&gt;showInspectorIndication();
407     else
408         m_inspectorClient-&gt;hideInspectorIndication();
409 #endif
410 }
411 
412 InspectorAgent&amp; InspectorController::ensureInspectorAgent()
413 {
414     if (!m_inspectorAgent) {
415         auto pageContext = pageAgentContext();
416         auto inspectorAgent = makeUnique&lt;InspectorAgent&gt;(pageContext);
417         m_inspectorAgent = inspectorAgent.get();
418         m_instrumentingAgents-&gt;setInspectorAgent(m_inspectorAgent);
419         m_agents.append(WTFMove(inspectorAgent));
420     }
421     return *m_inspectorAgent;
422 }
423 
424 InspectorDOMAgent&amp; InspectorController::ensureDOMAgent()
425 {
426     if (!m_inspectorDOMAgent) {
427         auto pageContext = pageAgentContext();
428         auto domAgent = makeUnique&lt;InspectorDOMAgent&gt;(pageContext, m_overlay.get());
429         m_inspectorDOMAgent = domAgent.get();
430         m_agents.append(WTFMove(domAgent));
431     }
432     return *m_inspectorDOMAgent;
433 }
434 
435 InspectorPageAgent&amp; InspectorController::ensurePageAgent()
436 {
437     if (!m_inspectorPageAgent) {
438         auto pageContext = pageAgentContext();
439         auto pageAgent = makeUnique&lt;InspectorPageAgent&gt;(pageContext, m_inspectorClient, m_overlay.get());
440         m_inspectorPageAgent = pageAgent.get();
441         m_agents.append(WTFMove(pageAgent));
442     }
443     return *m_inspectorPageAgent;
444 }
445 
446 bool InspectorController::developerExtrasEnabled() const
447 {
448     return m_page.settings().developerExtrasEnabled();
449 }
450 
<a name="8" id="anc8"></a><span class="line-modified">451 bool InspectorController::canAccessInspectedScriptState(JSC::JSGlobalObject* lexicalGlobalObject) const</span>
452 {
<a name="9" id="anc9"></a><span class="line-modified">453     JSLockHolder lock(lexicalGlobalObject);</span>
454 
<a name="10" id="anc10"></a><span class="line-modified">455     JSDOMWindow* inspectedWindow = toJSDOMWindow(lexicalGlobalObject-&gt;vm(), lexicalGlobalObject);</span>
456     if (!inspectedWindow)
457         return false;
458 
<a name="11" id="anc11"></a><span class="line-modified">459     return BindingSecurity::shouldAllowAccessToDOMWindow(lexicalGlobalObject, inspectedWindow-&gt;wrapped(), DoNotReportSecurityError);</span>
460 }
461 
462 InspectorFunctionCallHandler InspectorController::functionCallHandler() const
463 {
464     return WebCore::functionCallHandlerFromAnyThread;
465 }
466 
467 InspectorEvaluateHandler InspectorController::evaluateHandler() const
468 {
469     return WebCore::evaluateHandlerFromAnyThread;
470 }
471 
472 void InspectorController::frontendInitialized()
473 {
474     if (m_pauseAfterInitialization) {
475         m_pauseAfterInitialization = false;
476         if (PageDebuggerAgent* debuggerAgent = m_instrumentingAgents-&gt;pageDebuggerAgent()) {
477             ErrorString ignored;
478             debuggerAgent-&gt;pause(ignored);
479         }
480     }
481 
482 #if ENABLE(REMOTE_INSPECTOR)
483     if (m_isAutomaticInspection)
484         m_page.inspectorDebuggable().unpauseForInitializedInspector();
485 #endif
486 }
487 
488 Ref&lt;Stopwatch&gt; InspectorController::executionStopwatch()
489 {
490     return m_executionStopwatch.copyRef();
491 }
492 
493 PageScriptDebugServer&amp; InspectorController::scriptDebugServer()
494 {
495     return m_scriptDebugServer;
496 }
497 
498 JSC::VM&amp; InspectorController::vm()
499 {
500     return commonVM();
501 }
502 
503 void InspectorController::willComposite(Frame&amp; frame)
504 {
505     InspectorInstrumentation::willComposite(frame);
506 }
507 
508 void InspectorController::didComposite(Frame&amp; frame)
509 {
510     InspectorInstrumentation::didComposite(frame);
511 }
512 
513 } // namespace WebCore
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
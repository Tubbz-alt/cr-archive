<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/Modules/modern-media-controls/controls/slider.js</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016 Apple Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 class Slider extends LayoutNode
 27 {
 28 
 29     constructor(cssClassName = &quot;&quot;)
 30     {
 31         super(`&lt;div class=&quot;slider ${cssClassName}&quot;&gt;&lt;/div&gt;`);
 32 
 33         this._container = new LayoutNode(`&lt;div class=&quot;custom-slider&quot;&gt;&lt;/div&gt;`);
 34         this._track = new LayoutNode(`&lt;div class=&quot;track fill&quot;&gt;&lt;/div&gt;`);
 35         this._primaryFill = new LayoutNode(`&lt;div class=&quot;primary fill&quot;&gt;&lt;/div&gt;`);
 36         this._secondaryFill = new LayoutNode(`&lt;div class=&quot;secondary fill&quot;&gt;&lt;/div&gt;`);
 37         this._knob = new LayoutNode(`&lt;div class=&quot;knob&quot;&gt;&lt;/div&gt;`);
 38         this._container.children = [this._track, this._primaryFill, this._secondaryFill, this._knob];
 39 
 40         this._input = new LayoutNode(`&lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;1&quot; step=&quot;0.001&quot; /&gt;`);
 41         this._input.element.addEventListener(GestureRecognizer.SupportsTouches ? &quot;touchstart&quot; : &quot;mousedown&quot;, this);
 42         this._input.element.addEventListener(&quot;input&quot;, this);
 43         this._input.element.addEventListener(&quot;change&quot;, this);
 44 
 45         this.value = 0;
 46         this.height = 16;
 47         this.enabled = true;
 48         this.isActive = false;
 49         this._secondaryValue = 0;
 50         this._disabled = false;
 51 
 52         this.children = [this._container, this._input];
 53     }
 54 
 55     // Public
 56 
 57     set inputAccessibleLabel(timeValue)
 58     {
 59         this._input.element.setAttribute(&quot;aria-valuetext&quot;, formattedStringForDuration(timeValue));
 60     }
 61 
 62     get disabled()
 63     {
 64         return this._disabled;
 65     }
 66 
 67     set disabled(flag)
 68     {
 69         if (this._disabled === flag)
 70             return;
 71 
 72         this._disabled = flag;
 73         this.markDirtyProperty(&quot;disabled&quot;);
 74     }
 75 
 76     get value()
 77     {
 78         if (this._value !== undefined)
 79             return this._value;
 80         return parseFloat(this._input.element.value);
 81     }
 82 
 83     set value(value)
 84     {
 85         if (this.isActive)
 86             return;
 87 
 88         this._value = value;
 89         this.markDirtyProperty(&quot;value&quot;);
 90         this.needsLayout = true;
 91     }
 92 
 93     get secondaryValue()
 94     {
 95         return this._secondaryValue;
 96     }
 97 
 98     set secondaryValue(secondaryValue)
 99     {
100         if (this._secondaryValue === secondaryValue)
101             return;
102 
103         this._secondaryValue = secondaryValue;
104         this.needsLayout = true;
105     }
106 
107     // Protected
108 
109     handleEvent(event)
110     {
111         switch (event.type) {
112         case &quot;mousedown&quot;:
113             this._handleMousedownEvent();
114             break;
115         case &quot;touchstart&quot;:
116             this._handleTouchstartEvent(event);
117             break;
118         case &quot;mouseup&quot;:
119             this._handleMouseupEvent();
120             break;
121         case &quot;touchend&quot;:
122             this._handleTouchendEvent(event);
123             break;
124         case &quot;change&quot;:
125         case &quot;input&quot;:
126             this._valueDidChange();
127             break;
128         }
129     }
130 
131     commitProperty(propertyName)
132     {
133         switch (propertyName) {
134         case &quot;value&quot;:
135             this._input.element.value = this._value;
136             delete this._value;
137             break;
138         case &quot;disabled&quot;:
139             this.element.classList.toggle(&quot;disabled&quot;, this._disabled);
140             break;
141         default :
142             super.commitProperty(propertyName);
143             break;
144         }
145     }
146 
147     commit()
148     {
149         super.commit();
150 
151         const scrubberRadius = 4.5;
152         const scrubberCenterX = scrubberRadius + Math.round((this.width - (scrubberRadius * 2)) * this.value);
153         this._primaryFill.element.style.width = `${scrubberCenterX}px`;
154         this._secondaryFill.element.style.left = `${scrubberCenterX}px`;
155         this._secondaryFill.element.style.right = `${(1 - this._secondaryValue) * 100}%`;
156         this._knob.element.style.left = `${scrubberCenterX}px`;
157     }
158 
159     // Private
160 
161     _handleMousedownEvent()
162     {
163         this._mouseupTarget = this._interactionEndTarget();
164         this._mouseupTarget.addEventListener(&quot;mouseup&quot;, this, true);
165 
166         this._valueWillStartChanging();
167     }
168 
169     _interactionEndTarget()
170     {
171         const mediaControls = this.parentOfType(MediaControls);
172         return (!mediaControls || mediaControls instanceof MacOSInlineMediaControls) ? window : mediaControls.element;
173     }
174 
175     _handleTouchstartEvent(event)
176     {
177         // We&#39;re only interested in the very first touch on the &lt;input&gt;.
178         if (event.touches.length !== 1)
179             return;
180 
181         this._initialTouchIdentifier = event.touches[0].identifier;
182 
183         this._touchendTarget = this._interactionEndTarget();
184         this._touchendTarget.addEventListener(&quot;touchend&quot;, this, true);
185 
186         this._valueWillStartChanging();
187     }
188 
189     _valueWillStartChanging()
190     {
191         // We should no longer cache the value since we&#39;ll be interacting with the &lt;input&gt;
192         // so the value should be read back from it dynamically.
193         delete this._value;
194 
195         if (this.uiDelegate &amp;&amp; typeof this.uiDelegate.controlValueWillStartChanging === &quot;function&quot;)
196             this.uiDelegate.controlValueWillStartChanging(this);
197         this.isActive = true;
198         this.needsLayout = true;
199     }
200 
201     _valueDidChange()
202     {
203         if (this.uiDelegate &amp;&amp; typeof this.uiDelegate.controlValueDidChange === &quot;function&quot;)
204             this.uiDelegate.controlValueDidChange(this);
205 
206         this.needsLayout = true;
207     }
208 
209     _valueDidStopChanging()
210     {
211         this.isActive = false;
212         if (this.uiDelegate &amp;&amp; typeof this.uiDelegate.controlValueDidStopChanging === &quot;function&quot;)
213             this.uiDelegate.controlValueDidStopChanging(this);
214 
215         this.needsLayout = true;
216     }
217 
218     _handleMouseupEvent()
219     {
220         this._mouseupTarget.removeEventListener(&quot;mouseup&quot;, this, true);
221         delete this._mouseupTarget;
222 
223         this._valueDidStopChanging();
224     }
225 
226     _handleTouchendEvent(event)
227     {
228         if (!Array.from(event.changedTouches).find(touch =&gt; touch.identifier === this._initialTouchIdentifier))
229             return;
230 
231         this._touchendTarget.removeEventListener(&quot;touchend&quot;, this, true);
232         delete this._touchendTarget;
233         delete this._initialTouchIdentifier;
234 
235         this._valueDidStopChanging();
236     }
237 
238 }
    </pre>
  </body>
</html>
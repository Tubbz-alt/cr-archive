diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h
@@ -31,15 +31,20 @@
 #include "ArrayPrototype.h"
 #include "DFGAbstractInterpreter.h"
 #include "DFGAbstractInterpreterClobberState.h"
 #include "DOMJITGetterSetter.h"
 #include "DOMJITSignature.h"
-#include "GetByIdStatus.h"
+#include "GetByStatus.h"
 #include "GetterSetter.h"
 #include "HashMapImpl.h"
 #include "JITOperations.h"
+#include "JSAsyncGenerator.h"
+#include "JSGenerator.h"
 #include "JSImmutableButterfly.h"
+#include "JSInternalPromise.h"
+#include "JSInternalPromiseConstructor.h"
+#include "JSPromiseConstructor.h"
 #include "MathCommon.h"
 #include "NumberConstructor.h"
 #include "Operations.h"
 #include "PutByIdStatus.h"
 #include "StringObject.h"
@@ -71,11 +76,11 @@
 AbstractInterpreter<AbstractStateType>::booleanResult(
     Node* node, AbstractValue& value)
 {
     JSValue childConst = value.value();
     if (childConst) {
-        if (childConst.toBoolean(m_codeBlock->globalObjectFor(node->origin.semantic)->globalExec()))
+        if (childConst.toBoolean(m_codeBlock->globalObjectFor(node->origin.semantic)))
             return DefinitelyTrue;
         return DefinitelyFalse;
     }
 
     // Next check if we can fold because we know that the source is an object or string and does not equal undefined.
@@ -255,11 +260,12 @@
             break;
         case ValueBitXor:
         case ArithBitXor:
             setConstant(node, JSValue(a ^ b));
             break;
-        case BitRShift:
+        case ArithBitRShift:
+        case ValueBitRShift:
             setConstant(node, JSValue(a >> (static_cast<uint32_t>(b) & 0x1f)));
             break;
         case ValueBitLShift:
         case ArithBitLShift:
             setConstant(node, JSValue(a << (static_cast<uint32_t>(b) & 0x1f)));
@@ -315,14 +321,21 @@
             }
         } else if (left.isNumber() && right.isNumber()) {
             if (isClobbering)
                 didFoldClobberWorld();
 
-            if (isDivOperation)
-                setConstant(node, jsDoubleNumber(left.asNumber() / right.asNumber()));
-            else
-                setConstant(node, jsDoubleNumber(fmod(left.asNumber(), right.asNumber())));
+            if (isDivOperation) {
+                if (op == ValueDiv)
+                    setConstant(node, jsNumber(left.asNumber() / right.asNumber()));
+                else
+                    setConstant(node, jsDoubleNumber(left.asNumber() / right.asNumber()));
+            } else {
+                if (op == ValueMod)
+                    setConstant(node, jsNumber(fmod(left.asNumber(), right.asNumber())));
+                else
+                    setConstant(node, jsDoubleNumber(fmod(left.asNumber(), right.asNumber())));
+            }
 
             return true;
         }
     }
 
@@ -361,11 +374,11 @@
 
     case IdentityWithProfile:
     case Identity: {
         setForNode(node, forNode(node->child1()));
         if (forNode(node).value())
-            m_state.setFoundConstants(true);
+            m_state.setShouldTryConstantFolding(true);
         break;
     }
 
     case ExtractCatchLocal:
     case ExtractOSREntryLocal: {
@@ -373,37 +386,37 @@
         break;
     }
 
     case GetLocal: {
         VariableAccessData* variableAccessData = node->variableAccessData();
-        AbstractValue value = m_state.operand(variableAccessData->local().offset());
+        AbstractValue value = m_state.operand(variableAccessData->operand());
         // The value in the local should already be checked.
         DFG_ASSERT(m_graph, node, value.isType(typeFilterFor(variableAccessData->flushFormat())));
         if (value.value())
-            m_state.setFoundConstants(true);
+            m_state.setShouldTryConstantFolding(true);
         setForNode(node, value);
         break;
     }
 
     case GetStack: {
         StackAccessData* data = node->stackAccessData();
-        AbstractValue value = m_state.operand(data->local);
+        AbstractValue value = m_state.operand(data->operand);
         // The value in the local should already be checked.
         DFG_ASSERT(m_graph, node, value.isType(typeFilterFor(data->format)));
         if (value.value())
-            m_state.setFoundConstants(true);
+            m_state.setShouldTryConstantFolding(true);
         setForNode(node, value);
         break;
     }
 
     case SetLocal: {
-        m_state.operand(node->local()) = forNode(node->child1());
+        m_state.operand(node->operand()) = forNode(node->child1());
         break;
     }
 
     case PutStack: {
-        m_state.operand(node->stackAccessData()->local) = forNode(node->child1());
+        m_state.operand(node->stackAccessData()->operand) = forNode(node->child1());
         break;
     }
 
     case MovHint: {
         // Don't need to do anything. A MovHint only informs us about what would have happened
@@ -421,11 +434,11 @@
     case SetArgumentDefinitely:
     case SetArgumentMaybe:
         // Assert that the state of arguments has been set. SetArgumentDefinitely/SetArgumentMaybe means
         // that someone set the argument values out-of-band, and currently this always means setting to a
         // non-clear value.
-        ASSERT(!m_state.operand(node->local()).isClear());
+        ASSERT(!m_state.operand(node->operand()).isClear());
         break;
 
     case InitializeEntrypointArguments: {
         unsigned entrypointIndex = node->entrypointIndex();
         const Vector<FlushFormat>& argumentFormats = m_graph.m_argumentFormats[entrypointIndex];
@@ -450,10 +463,16 @@
             }
         }
         break;
     }
 
+    case VarargsLength: {
+        clobberWorld();
+        setTypeForNode(node, SpecInt32Only);
+        break;
+    }
+
     case LoadVarargs:
     case ForwardVarargs: {
         // FIXME: ForwardVarargs should check if the count becomes known, and if it does, it should turn
         // itself into a straight-line sequence of GetStack/PutStack.
         // https://bugs.webkit.org/show_bug.cgi?id=143071
@@ -468,11 +487,11 @@
             break;
         }
         LoadVarargsData* data = node->loadVarargsData();
         m_state.operand(data->count).setNonCellType(SpecInt32Only);
         for (unsigned i = data->limit - 1; i--;)
-            m_state.operand(data->start.offset() + i).makeHeapTop();
+            m_state.operand(data->start + i).makeHeapTop();
         break;
     }
 
     case ValueBitNot: {
         JSValue operand = forNode(node->child1()).value();
@@ -506,10 +525,11 @@
     }
 
     case ValueBitXor:
     case ValueBitAnd:
     case ValueBitOr:
+    case ValueBitRShift:
     case ValueBitLShift: {
         if (handleConstantBinaryBitwiseOp(node))
             break;
 
         if (node->binaryUseKind() == BigIntUse)
@@ -522,11 +542,11 @@
     }
 
     case ArithBitAnd:
     case ArithBitOr:
     case ArithBitXor:
-    case BitRShift:
+    case ArithBitRShift:
     case ArithBitLShift:
     case BitURShift: {
         if (node->child1().useKind() == UntypedUse || node->child2().useKind() == UntypedUse) {
             clobberWorld();
             setNonCellTypeForNode(node, SpecInt32Only);
@@ -588,11 +608,11 @@
             break;
         }
         AbstractValue& value = forNode(node);
         value = forNode(node->child1());
         if (node->child1().useKind() == UntypedUse && !(value.m_type & ~SpecBoolean))
-            m_state.setFoundConstants(true);
+            m_state.setShouldTryConstantFolding(true);
         if (value.m_type & SpecBoolean) {
             value.merge(SpecBoolInt32);
             value.filter(~SpecBoolean);
         }
         break;
@@ -810,11 +830,11 @@
                 continue;
             ++numberOfRemovedChildren;
         }
 
         if (numberOfRemovedChildren)
-            m_state.setFoundConstants(true);
+            m_state.setShouldTryConstantFolding(true);
         setForNode(node, m_vm.stringStructure.get());
         break;
     }
 
     case ArithSub: {
@@ -922,19 +942,45 @@
             break;
         }
         break;
     }
 
+    case Inc:
+    case Dec: {
+        // FIXME: support some form of constant folding here.
+        // https://bugs.webkit.org/show_bug.cgi?id=204258
+        switch (node->child1().useKind()) {
+        case Int32Use:
+            setNonCellTypeForNode(node, SpecInt32Only);
+            break;
+        case Int52RepUse:
+            setNonCellTypeForNode(node, SpecInt52Any);
+            break;
+        case DoubleRepUse:
+            setNonCellTypeForNode(node, typeOfDoubleIncOrDec(forNode(node->child1()).m_type));
+            break;
+        case BigIntUse:
+            setTypeForNode(node, SpecBigInt);
+            break;
+        default:
+            setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);
+            clobberWorld(); // Because of the call to ToNumeric()
+            break;
+        }
+        break;
+    }
+
     case ValuePow: {
         JSValue childX = forNode(node->child1()).value();
         JSValue childY = forNode(node->child2()).value();
         if (childX && childY && childX.isNumber() && childY.isNumber()) {
             // We need to call `didFoldClobberWorld` here because this path is only possible
             // when node->useKind is UntypedUse. In the case of BigIntUse, children will be
             // cleared by `AbstractInterpreter::executeEffects`.
             didFoldClobberWorld();
-            setConstant(node, jsDoubleNumber(operationMathPow(childX.asNumber(), childY.asNumber())));
+            // Our boxing scheme here matches what we do in operationValuePow.
+            setConstant(node, jsNumber(operationMathPow(childX.asNumber(), childY.asNumber())));
             break;
         }
 
         if (node->binaryUseKind() == BigIntUse)
             setTypeForNode(node, SpecBigInt);
@@ -1261,11 +1307,11 @@
             break;
         }
 
         SpeculatedType typeMaybeNormalized = (SpecFullNumber & ~SpecInt32Only);
         if (!(forNode(node->child1()).m_type & typeMaybeNormalized)) {
-            m_state.setFoundConstants(true);
+            m_state.setShouldTryConstantFolding(true);
             forNode(node) = forNode(node->child1());
             break;
         }
 
         makeHeapTopForNode(node);
@@ -1410,10 +1456,41 @@
             }
             if (constantWasSet)
                 break;
         }
 
+        if (!(child.m_type & ~SpecCell)) {
+            if (child.m_structure.isFinite()) {
+                bool constantWasSet = false;
+                switch (node->op()) {
+                case IsCellWithType: {
+                    bool ok = true;
+                    Optional<bool> result;
+                    child.m_structure.forEach(
+                        [&] (RegisteredStructure structure) {
+                            bool matched = structure->typeInfo().type() == node->queriedType();
+                            if (!result)
+                                result = matched;
+                            else {
+                                if (result.value() != matched)
+                                    ok = false;
+                            }
+                        });
+                    if (ok && result) {
+                        setConstant(node, jsBoolean(result.value()));
+                        constantWasSet = true;
+                    }
+                    break;
+                }
+                default:
+                    break;
+                }
+                if (constantWasSet)
+                    break;
+            }
+        }
+
         // FIXME: This code should really use AbstractValue::isType() and
         // AbstractValue::couldBeType().
         // https://bugs.webkit.org/show_bug.cgi?id=146870
 
         bool constantWasSet = false;
@@ -1559,22 +1636,31 @@
                 constantWasSet = true;
                 break;
             }
             break;
 
-        case IsCellWithType:
-            if (!(child.m_type & ~node->speculatedTypeForQuery())) {
+        case IsCellWithType: {
+            Optional<SpeculatedType> filter = node->speculatedTypeForQuery();
+            if (!filter) {
+                if (!(child.m_type & SpecCell)) {
+                    setConstant(node, jsBoolean(false));
+                    constantWasSet = true;
+                }
+                break;
+            }
+            if (!(child.m_type & ~filter.value())) {
                 setConstant(node, jsBoolean(true));
                 constantWasSet = true;
                 break;
             }
-            if (!(child.m_type & node->speculatedTypeForQuery())) {
+            if (!(child.m_type & filter.value())) {
                 setConstant(node, jsBoolean(false));
                 constantWasSet = true;
                 break;
             }
             break;
+        }
 
         case IsTypedArrayView:
             if (!(child.m_type & ~SpecTypedArrayView)) {
                 setConstant(node, jsBoolean(true));
                 constantWasSet = true;
@@ -1855,11 +1941,11 @@
             auto isNonStringCellConstant = [] (JSValue value) {
                 return value && value.isCell() && !value.isString();
             };
 
             if (isNonStringCellConstant(left) || isNonStringCellConstant(right)) {
-                m_state.setFoundConstants(true);
+                m_state.setShouldTryConstantFolding(true);
                 setNonCellTypeForNode(node, SpecBoolean);
                 break;
             }
         }
 
@@ -1904,10 +1990,11 @@
         setNonCellTypeForNode(node, SpecBoolean);
         break;
     }
 
     case StringCharCodeAt:
+    case StringCodePointAt:
         setNonCellTypeForNode(node, SpecInt32Only);
         break;
 
     case StringFromCharCode:
         switch (node->child1().useKind()) {
@@ -2282,20 +2369,20 @@
             Checked<unsigned, RecordOverflow> argumentIndexChecked = index.asUInt32();
             argumentIndexChecked += node->numberOfArgumentsToSkip();
             unsigned argumentIndex;
             if (argumentIndexChecked.safeGet(argumentIndex) != CheckedState::DidOverflow) {
                 if (inlineCallFrame) {
-                    if (argumentIndex < inlineCallFrame->argumentCountIncludingThis - 1) {
+                    if (argumentIndex < static_cast<unsigned>(inlineCallFrame->argumentCountIncludingThis - 1)) {
                         setForNode(node, m_state.operand(
-                            virtualRegisterForArgument(argumentIndex + 1) + inlineCallFrame->stackOffset));
-                        m_state.setFoundConstants(true);
+                            virtualRegisterForArgumentIncludingThis(argumentIndex + 1) + inlineCallFrame->stackOffset));
+                        m_state.setShouldTryConstantFolding(true);
                         break;
                     }
                 } else {
                     if (argumentIndex < m_state.numberOfArguments() - 1) {
                         setForNode(node, m_state.argument(argumentIndex + 1));
-                        m_state.setFoundConstants(true);
+                        m_state.setShouldTryConstantFolding(true);
                         break;
                     }
                 }
             }
         }
@@ -2305,18 +2392,18 @@
 
             AbstractValue result;
             for (unsigned i = 1 + node->numberOfArgumentsToSkip(); i < inlineCallFrame->argumentCountIncludingThis; ++i) {
                 result.merge(
                     m_state.operand(
-                        virtualRegisterForArgument(i) + inlineCallFrame->stackOffset));
+                        virtualRegisterForArgumentIncludingThis(i) + inlineCallFrame->stackOffset));
             }
 
             if (node->op() == GetMyArgumentByValOutOfBounds)
                 result.merge(SpecOther);
 
             if (result.value())
-                m_state.setFoundConstants(true);
+                m_state.setShouldTryConstantFolding(true);
 
             setForNode(node, result);
             break;
         }
 
@@ -2336,11 +2423,10 @@
             if (JSGlobalObject* globalObject = jsDynamicCast<JSGlobalObject*>(m_vm, globalObjectValue)) {
                 if (!globalObject->isHavingABadTime()) {
                     m_graph.watchpoints().addLazily(globalObject->havingABadTimeWatchpoint());
                     RegisteredStructureSet structureSet;
                     structureSet.add(m_graph.registerStructure(globalObject->regExpMatchesArrayStructure()));
-                    structureSet.add(m_graph.registerStructure(globalObject->regExpMatchesArrayWithGroupsStructure()));
                     setForNode(node, structureSet);
                     forNode(node).merge(SpecOther);
                     break;
                 }
             }
@@ -2431,11 +2517,11 @@
         }
 
         ASSERT(node->child1().useKind() == UntypedUse);
 
         if (!(forNode(node->child1()).m_type & ~(SpecFullNumber | SpecBoolean | SpecString | SpecSymbol | SpecBigInt))) {
-            m_state.setFoundConstants(true);
+            m_state.setShouldTryConstantFolding(true);
             didFoldClobberWorld();
             setForNode(node, forNode(node->child1()));
             break;
         }
 
@@ -2443,10 +2529,24 @@
 
         setTypeForNode(node, SpecHeapTop & ~SpecObject);
         break;
     }
 
+    case ToPropertyKey: {
+        if (!(forNode(node->child1()).m_type & ~(SpecString | SpecSymbol))) {
+            m_state.setShouldTryConstantFolding(true);
+            didFoldClobberWorld();
+            setForNode(node, forNode(node->child1()));
+            break;
+        }
+
+        clobberWorld();
+
+        setTypeForNode(node, SpecString | SpecSymbol);
+        break;
+    }
+
     case ToNumber: {
         JSValue childConst = forNode(node->child1()).value();
         if (childConst && childConst.isNumber()) {
             didFoldClobberWorld();
             setConstant(node, childConst);
@@ -2454,21 +2554,43 @@
         }
 
         ASSERT(node->child1().useKind() == UntypedUse);
 
         if (!(forNode(node->child1()).m_type & ~SpecBytecodeNumber)) {
-            m_state.setFoundConstants(true);
+            m_state.setShouldTryConstantFolding(true);
             didFoldClobberWorld();
             setForNode(node, forNode(node->child1()));
             break;
         }
 
         clobberWorld();
         setNonCellTypeForNode(node, SpecBytecodeNumber);
         break;
     }
 
+    case ToNumeric: {
+        JSValue childConst = forNode(node->child1()).value();
+        if (childConst && (childConst.isNumber() || childConst.isBigInt())) {
+            didFoldClobberWorld();
+            setConstant(node, childConst);
+            break;
+        }
+
+        ASSERT(node->child1().useKind() == UntypedUse);
+
+        if (!(forNode(node->child1()).m_type & ~(SpecBytecodeNumber | SpecBigInt))) {
+            m_state.setShouldTryConstantFolding(true);
+            didFoldClobberWorld();
+            setForNode(node, forNode(node->child1()));
+            break;
+        }
+
+        clobberWorld();
+        setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);
+        break;
+    }
+
     case ToString:
     case CallStringConstructor: {
         switch (node->child1().useKind()) {
         case StringObjectUse:
         case StringOrStringObjectUse:
@@ -2492,11 +2614,11 @@
     case NumberToStringWithRadix: {
         JSValue radixValue = forNode(node->child2()).m_value;
         if (radixValue && radixValue.isInt32()) {
             int32_t radix = radixValue.asInt32();
             if (2 <= radix && radix <= 36) {
-                m_state.setFoundConstants(true);
+                m_state.setShouldTryConstantFolding(true);
                 didFoldClobberWorld();
                 setForNode(node, m_graph.m_vm.stringStructure.get());
                 break;
             }
         }
@@ -2530,12 +2652,30 @@
     case NewArrayWithSpread:
         if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
             // We've compiled assuming we're not having a bad time, so to be consistent
             // with StructureRegisterationPhase we must say we produce an original array
             // allocation structure.
-            setForNode(node,
-                m_graph.globalObjectFor(node->origin.semantic)->originalArrayStructureForIndexingType(ArrayWithContiguous));
+#if USE(JSVALUE64)
+            BitVector* bitVector = node->bitVector();
+            if (node->numChildren() == 1 && bitVector->get(0)) {
+                Edge use = m_graph.varArgChild(node, 0);
+                if (use->op() == PhantomSpread) {
+                    if (use->child1()->op() == PhantomNewArrayBuffer) {
+                        auto* immutableButterfly = use->child1()->castOperand<JSImmutableButterfly*>();
+                        if (hasContiguous(immutableButterfly->indexingType())) {
+                            m_state.setShouldTryConstantFolding(true);
+                            setForNode(node, m_graph.globalObjectFor(node->origin.semantic)->originalArrayStructureForIndexingType(CopyOnWriteArrayWithContiguous));
+                            break;
+                        }
+                    }
+                } else {
+                    setForNode(node, m_graph.globalObjectFor(node->origin.semantic)->originalArrayStructureForIndexingType(CopyOnWriteArrayWithContiguous));
+                    break;
+                }
+            }
+#endif
+            setForNode(node, m_graph.globalObjectFor(node->origin.semantic)->originalArrayStructureForIndexingType(ArrayWithContiguous));
         } else {
             setForNode(node,
                 m_graph.globalObjectFor(node->origin.semantic)->arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous));
         }
 
@@ -2552,12 +2692,11 @@
             else
                 didFoldClobberWorld();
             break;
         }
 
-        setForNode(node,
-            m_vm.fixedArrayStructure.get());
+        setForNode(node, m_vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get());
         break;
 
     case NewArrayBuffer:
         setForNode(node,
             m_graph.globalObjectFor(node->origin.semantic)->arrayStructureForIndexingTypeDuringAllocation(node->indexingMode()));
@@ -2593,18 +2732,18 @@
         bool strictMode = m_graph.isStrictModeFor(node->origin.semantic);
 
         ToThisResult result = isToThisAnIdentity(m_vm, strictMode, source);
         switch (result) {
         case ToThisResult::Identity:
-            m_state.setFoundConstants(true);
+            m_state.setShouldTryConstantFolding(true);
             destination = source;
             break;
         case ToThisResult::Undefined:
             setConstant(node, jsUndefined());
             break;
         case ToThisResult::GlobalThis:
-            m_state.setFoundConstants(true);
+            m_state.setShouldTryConstantFolding(true);
             destination.setType(m_graph, SpecObject);
             break;
         case ToThisResult::Dynamic:
             if (strictMode)
                 destination.makeHeapTop();
@@ -2619,27 +2758,113 @@
 
     case CreateThis: {
         if (JSValue base = forNode(node->child1()).m_value) {
             if (auto* function = jsDynamicCast<JSFunction*>(m_vm, base)) {
                 if (FunctionRareData* rareData = function->rareData()) {
-                    if (Structure* structure = rareData->objectAllocationStructure()) {
-                        m_graph.freeze(rareData);
-                        m_graph.watchpoints().addLazily(rareData->allocationProfileWatchpointSet());
-                        m_state.setFoundConstants(true);
-                        didFoldClobberWorld();
-                        setForNode(node, structure);
-                        break;
+                    if (rareData->allocationProfileWatchpointSet().isStillValid()) {
+                        if (Structure* structure = rareData->objectAllocationStructure()) {
+                            m_graph.freeze(rareData);
+                            m_graph.watchpoints().addLazily(rareData->allocationProfileWatchpointSet());
+                            m_state.setShouldTryConstantFolding(true);
+                            didFoldClobberWorld();
+                            setForNode(node, structure);
+                            break;
+                        }
                     }
                 }
             }
         }
         clobberWorld();
         setTypeForNode(node, SpecFinalObject);
         break;
     }
 
+    case CreatePromise: {
+        JSGlobalObject* globalObject = m_graph.globalObjectFor(node->origin.semantic);
+        if (JSValue base = forNode(node->child1()).m_value) {
+            if (base == (node->isInternalPromise() ? globalObject->internalPromiseConstructor() : globalObject->promiseConstructor())) {
+                m_state.setShouldTryConstantFolding(true);
+                didFoldClobberWorld();
+                setForNode(node, node->isInternalPromise() ? globalObject->internalPromiseStructure() : globalObject->promiseStructure());
+                break;
+            }
+            if (auto* function = jsDynamicCast<JSFunction*>(m_graph.m_vm, base)) {
+                if (FunctionRareData* rareData = function->rareData()) {
+                    if (rareData->allocationProfileWatchpointSet().isStillValid()) {
+                        Structure* structure = rareData->internalFunctionAllocationStructure();
+                        if (structure
+                            && structure->classInfo() == (node->isInternalPromise() ? JSInternalPromise::info() : JSPromise::info())
+                            && structure->globalObject() == globalObject
+                            && rareData->allocationProfileWatchpointSet().isStillValid()) {
+                            m_graph.freeze(rareData);
+                            m_graph.watchpoints().addLazily(rareData->allocationProfileWatchpointSet());
+                            m_state.setShouldTryConstantFolding(true);
+                            didFoldClobberWorld();
+                            setForNode(node, structure);
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+        clobberWorld();
+        setTypeForNode(node, SpecPromiseObject);
+        break;
+    }
+
+    case CreateGenerator:
+    case CreateAsyncGenerator: {
+        auto tryToFold = [&] (const ClassInfo* classInfo) -> bool {
+            JSGlobalObject* globalObject = m_graph.globalObjectFor(node->origin.semantic);
+            if (JSValue base = forNode(node->child1()).m_value) {
+                if (auto* function = jsDynamicCast<JSFunction*>(m_graph.m_vm, base)) {
+                    if (FunctionRareData* rareData = function->rareData()) {
+                        if (rareData->allocationProfileWatchpointSet().isStillValid()) {
+                            Structure* structure = rareData->internalFunctionAllocationStructure();
+                            if (structure
+                                && structure->classInfo() == classInfo
+                                && structure->globalObject() == globalObject
+                                && rareData->allocationProfileWatchpointSet().isStillValid()) {
+                                m_graph.freeze(rareData);
+                                m_graph.watchpoints().addLazily(rareData->allocationProfileWatchpointSet());
+                                m_state.setShouldTryConstantFolding(true);
+                                didFoldClobberWorld();
+                                setForNode(node, structure);
+                                return true;
+                            }
+                        }
+                    }
+                }
+            }
+            return false;
+        };
+
+        bool found = false;
+        switch (node->op()) {
+        case CreateGenerator:
+            found = tryToFold(JSGenerator::info());
+            break;
+        case CreateAsyncGenerator:
+            found = tryToFold(JSAsyncGenerator::info());
+            break;
+        default:
+            RELEASE_ASSERT_NOT_REACHED();
+            break;
+        }
+        if (found)
+            break;
+        clobberWorld();
+        setTypeForNode(node, SpecObjectOther);
+        break;
+    }
+
+    case NewPromise:
+    case NewGenerator:
+    case NewAsyncGenerator:
+    case NewArrayIterator:
     case NewObject:
+    case MaterializeNewInternalFieldObject:
         ASSERT(!!node->structure().get());
         setForNode(node, node->structure());
         break;
 
     case ObjectCreate: {
@@ -2647,14 +2872,14 @@
             JSGlobalObject* globalObject = m_graph.globalObjectFor(node->origin.semantic);
             Structure* structure = nullptr;
             if (base.isNull())
                 structure = globalObject->nullPrototypeObjectStructure();
             else if (base.isObject())
-                structure = globalObject->vm().structureCache.emptyObjectStructureConcurrently(globalObject, base.getObject(), JSFinalObject::defaultInlineCapacity());
+                structure = m_vm.structureCache.emptyObjectStructureConcurrently(globalObject, base.getObject(), JSFinalObject::defaultInlineCapacity());
 
             if (structure) {
-                m_state.setFoundConstants(true);
+                m_state.setShouldTryConstantFolding(true);
                 if (node->child1().useKind() == UntypedUse)
                     didFoldClobberWorld();
                 setForNode(node, structure);
                 break;
             }
@@ -2671,11 +2896,11 @@
             if (structureSet.isFinite() && structureSet.size() == 1) {
                 RegisteredStructure structure = structureSet.onlyStructure();
                 if (auto* rareData = structure->rareDataConcurrently()) {
                     if (!!rareData->cachedOwnKeysConcurrently()) {
                         if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
-                            m_state.setFoundConstants(true);
+                            m_state.setShouldTryConstantFolding(true);
                             didFoldClobberWorld();
                             setTypeForNode(node, SpecArray);
                             break;
                         }
                     }
@@ -2692,11 +2917,11 @@
     case CallObjectConstructor: {
         AbstractValue& source = forNode(node->child1());
         AbstractValue& destination = forNode(node);
 
         if (!(source.m_type & ~SpecObject)) {
-            m_state.setFoundConstants(true);
+            m_state.setShouldTryConstantFolding(true);
             if (node->op() == ToObject)
                 didFoldClobberWorld();
             destination = source;
             break;
         }
@@ -2717,10 +2942,11 @@
     case PhantomClonedArguments:
     case PhantomCreateRest:
     case PhantomSpread:
     case PhantomNewArrayWithSpread:
     case PhantomNewArrayBuffer:
+    case PhantomNewArrayIterator:
     case PhantomNewRegexp:
     case BottomValue: {
         clearForNode(node);
         break;
     }
@@ -2758,10 +2984,14 @@
             break;
         }
         setForNode(node, m_codeBlock->globalObjectFor(node->origin.semantic)->clonedArgumentsStructure());
         break;
 
+    case CreateArgumentsButterfly:
+        setForNode(node, m_vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get());
+        break;
+
     case NewGeneratorFunction:
         setForNode(node,
             m_codeBlock->globalObjectFor(node->origin.semantic)->generatorFunctionStructure());
         break;
 
@@ -2895,10 +3125,18 @@
         break;
 
     case PutClosureVar:
         break;
 
+    case GetInternalField:
+        makeBytecodeTopForNode(node);
+        break;
+
+    case PutInternalField:
+        break;
+
+
     case GetRegExpObjectLastIndex:
         makeHeapTopForNode(node);
         break;
 
     case SetRegExpObjectLastIndex:
@@ -2928,11 +3166,11 @@
     case GetByIdFlush: {
         AbstractValue& value = forNode(node->child1());
         if (value.m_structure.isFinite()
             && (node->child1().useKind() == CellUse || !(value.m_type & ~SpecCell))) {
             UniquedStringImpl* uid = m_graph.identifiers()[node->identifierNumber()];
-            GetByIdStatus status = GetByIdStatus::computeFor(value.m_structure.toStructureSet(), uid);
+            GetByStatus status = GetByStatus::computeFor(value.m_structure.toStructureSet(), uid);
             if (status.isSimple()) {
                 // Figure out what the result is going to be - is it TOP, a constant, or maybe
                 // something more subtle?
                 AbstractValue result;
                 for (unsigned i = status.numVariants(); i--;) {
@@ -2943,11 +3181,11 @@
                     result.merge(
                         m_graph.inferredValueForProperty(
                             value, status[i].offset(), m_state.structureClobberState()));
                 }
 
-                m_state.setFoundConstants(true);
+                m_state.setShouldTryConstantFolding(true);
                 didFoldClobberWorld();
                 forNode(node) = result;
                 break;
             }
         }
@@ -2996,11 +3234,11 @@
         // It's interesting that we could have proven that the object has a larger structure set
         // that includes the set we're testing. In that case we could make the structure check
         // more efficient. We currently don't.
 
         if (value.m_structure.isSubsetOf(set))
-            m_state.setFoundConstants(true);
+            m_state.setShouldTryConstantFolding(true);
 
         SpeculatedType admittedTypes = SpecNone;
         switch (node->child1().useKind()) {
         case CellUse:
         case KnownCellUse:
@@ -3021,11 +3259,11 @@
     case CheckStructureOrEmpty: {
         AbstractValue& value = forNode(node->child1());
 
         bool mayBeEmpty = value.m_type & SpecEmpty;
         if (!mayBeEmpty)
-            m_state.setFoundConstants(true);
+            m_state.setShouldTryConstantFolding(true);
 
         SpeculatedType admittedTypes = mayBeEmpty ? SpecEmpty : SpecNone;
         filter(value, node->structureSet(), admittedTypes);
         break;
     }
@@ -3038,11 +3276,11 @@
         const RegisteredStructureSet& set = node->structureSet();
 
         if (value.value()) {
             if (Structure* structure = jsDynamicCast<Structure*>(m_vm, value.value())) {
                 if (set.contains(m_graph.registerStructure(structure))) {
-                    m_state.setFoundConstants(true);
+                    m_state.setShouldTryConstantFolding(true);
                     break;
                 }
             }
             m_state.setIsValid(false);
             break;
@@ -3058,11 +3296,11 @@
                             return;
                     }
                     allGood = false;
                 });
             if (allGood) {
-                m_state.setFoundConstants(true);
+                m_state.setShouldTryConstantFolding(true);
                 break;
             }
         }
 
         if (RegisteredStructure structure = set.onlyStructure()) {
@@ -3076,11 +3314,11 @@
 
     case PutStructure:
         if (!forNode(node->child1()).m_structure.isClear()) {
             if (forNode(node->child1()).m_structure.onlyStructure() == node->transition()->next) {
                 didFoldClobberStructures();
-                m_state.setFoundConstants(true);
+                m_state.setShouldTryConstantFolding(true);
             } else {
                 observeTransition(
                     clobberLimit, node->transition()->previous, node->transition()->next);
                 forNode(node->child1()).changeStructure(m_graph, node->transition()->next);
             }
@@ -3101,20 +3339,20 @@
         break;
     case CheckSubClass: {
         JSValue constant = forNode(node->child1()).value();
         if (constant) {
             if (constant.isCell() && constant.asCell()->inherits(m_vm, node->classInfo())) {
-                m_state.setFoundConstants(true);
+                m_state.setShouldTryConstantFolding(true);
                 ASSERT(constant);
                 break;
             }
         }
 
         AbstractValue& value = forNode(node->child1());
 
         if (value.m_structure.isSubClassOf(node->classInfo()))
-            m_state.setFoundConstants(true);
+            m_state.setShouldTryConstantFolding(true);
 
         filterClassInfo(value, node->classInfo());
         break;
     }
     case CallDOMGetter: {
@@ -3133,84 +3371,99 @@
         if (signature->effect.writes)
             clobberWorld();
         setTypeForNode(node, signature->result);
         break;
     }
+
+    case CheckArrayOrEmpty:
     case CheckArray: {
-        if (node->arrayMode().alreadyChecked(m_graph, node, forNode(node->child1()))) {
-            m_state.setFoundConstants(true);
+        AbstractValue& value = forNode(node->child1());
+
+        SpeculatedType admittedTypes = SpecNone;
+        if (node->op() == CheckArrayOrEmpty) {
+            bool mayBeEmpty = value.m_type & SpecEmpty;
+            if (!mayBeEmpty)
+                m_state.setShouldTryConstantFolding(true);
+            else
+                admittedTypes = SpecEmpty;
+        }
+
+        if (node->arrayMode().alreadyChecked(m_graph, node, value)) {
+            m_state.setShouldTryConstantFolding(true);
             break;
         }
+
         switch (node->arrayMode().type()) {
         case Array::String:
-            filter(node->child1(), SpecString);
+            filter(node->child1(), SpecString | admittedTypes);
             break;
         case Array::Int32:
         case Array::Double:
         case Array::Contiguous:
         case Array::Undecided:
         case Array::ArrayStorage:
         case Array::SlowPutArrayStorage:
             break;
         case Array::DirectArguments:
-            filter(node->child1(), SpecDirectArguments);
+            filter(node->child1(), SpecDirectArguments | admittedTypes);
             break;
         case Array::ScopedArguments:
-            filter(node->child1(), SpecScopedArguments);
+            filter(node->child1(), SpecScopedArguments | admittedTypes);
             break;
         case Array::Int8Array:
-            filter(node->child1(), SpecInt8Array);
+            filter(node->child1(), SpecInt8Array | admittedTypes);
             break;
         case Array::Int16Array:
-            filter(node->child1(), SpecInt16Array);
+            filter(node->child1(), SpecInt16Array | admittedTypes);
             break;
         case Array::Int32Array:
-            filter(node->child1(), SpecInt32Array);
+            filter(node->child1(), SpecInt32Array | admittedTypes);
             break;
         case Array::Uint8Array:
-            filter(node->child1(), SpecUint8Array);
+            filter(node->child1(), SpecUint8Array | admittedTypes);
             break;
         case Array::Uint8ClampedArray:
-            filter(node->child1(), SpecUint8ClampedArray);
+            filter(node->child1(), SpecUint8ClampedArray | admittedTypes);
             break;
         case Array::Uint16Array:
-            filter(node->child1(), SpecUint16Array);
+            filter(node->child1(), SpecUint16Array | admittedTypes);
             break;
         case Array::Uint32Array:
-            filter(node->child1(), SpecUint32Array);
+            filter(node->child1(), SpecUint32Array | admittedTypes);
             break;
         case Array::Float32Array:
-            filter(node->child1(), SpecFloat32Array);
+            filter(node->child1(), SpecFloat32Array | admittedTypes);
             break;
         case Array::Float64Array:
-            filter(node->child1(), SpecFloat64Array);
+            filter(node->child1(), SpecFloat64Array | admittedTypes);
             break;
         case Array::AnyTypedArray:
-            filter(node->child1(), SpecTypedArrayView);
+            filter(node->child1(), SpecTypedArrayView | admittedTypes);
             break;
         default:
             RELEASE_ASSERT_NOT_REACHED();
             break;
         }
-        filterArrayModes(node->child1(), node->arrayMode().arrayModesThatPassFiltering());
+        filterArrayModes(node->child1(), node->arrayMode().arrayModesThatPassFiltering(), admittedTypes);
         break;
     }
+
     case Arrayify: {
         if (node->arrayMode().alreadyChecked(m_graph, node, forNode(node->child1()))) {
             didFoldClobberStructures();
-            m_state.setFoundConstants(true);
+            m_state.setShouldTryConstantFolding(true);
             break;
         }
         ASSERT(node->arrayMode().conversion() == Array::Convert);
         clobberStructures();
         filterArrayModes(node->child1(), node->arrayMode().arrayModesThatPassFiltering());
         break;
     }
     case ArrayifyToStructure: {
         AbstractValue& value = forNode(node->child1());
         if (value.m_structure.isSubsetOf(RegisteredStructureSet(node->structure())))
-            m_state.setFoundConstants(true);
+            m_state.setShouldTryConstantFolding(true);
         clobberStructures();
 
         // We have a bunch of options of how to express the abstract set at this point. Let set S
         // be the set of structures that the value had before clobbering and assume that all of
         // them are watchable. The new value should be the least expressible upper bound of the
@@ -3243,11 +3496,11 @@
     }
     case GetIndexedPropertyStorage: {
         JSArrayBufferView* view = m_graph.tryGetFoldableView(
             forNode(node->child1()).m_value, node->arrayMode());
         if (view)
-            m_state.setFoundConstants(true);
+            m_state.setShouldTryConstantFolding(true);
         clearForNode(node);
         break;
     }
     case ConstantStoragePointer: {
         clearForNode(node);
@@ -3255,12 +3508,15 @@
     }
 
     case GetTypedArrayByteOffset: {
         JSArrayBufferView* view = m_graph.tryGetFoldableView(forNode(node->child1()).m_value);
         if (view) {
-            setConstant(node, jsNumber(view->byteOffset()));
-            break;
+            Optional<unsigned> byteOffset = view->byteOffsetConcurrently();
+            if (byteOffset) {
+                setConstant(node, jsNumber(*byteOffset));
+                break;
+            }
         }
         setNonCellTypeForNode(node, SpecInt32Only);
         break;
     }
 
@@ -3331,11 +3587,11 @@
         if (value.isClear())
             m_state.setIsValid(false);
 
         setForNode(node, value);
         if (value.m_value)
-            m_state.setFoundConstants(true);
+            m_state.setShouldTryConstantFolding(true);
         break;
     }
 
     case GetGetterSetterByOffset: {
         StorageAccessData& data = node->storageAccessData();
@@ -3344,16 +3600,11 @@
         if (result && jsDynamicCast<GetterSetter*>(m_vm, result)) {
             setConstant(node, *m_graph.freeze(result));
             break;
         }
 
-        if (base.value() && base.value().isObject()) {
-            setForNode(node, asObject(base.value())->globalObject()->getterSetterStructure());
-            break;
-        }
-
-        setTypeForNode(node, SpecObjectOther);
+        setForNode(node, m_vm.getterSetterStructure.get());
         break;
     }
 
     case MultiGetByOffset: {
         // This code will filter the base value in a manner that is possibly different (either more
@@ -3363,13 +3614,13 @@
         // one guy proving that code should never execute (due to a contradiction) and another guy
         // not finding that contradiction. If someone ever proved that there would be a
         // contradiction then there must always be a contradiction even if subsequent passes don't
         // realize it. This is the case here.
 
-        // Ordinarily you have to be careful with calling setFoundConstants()
+        // Ordinarily you have to be careful with calling setShouldTryConstantFolding()
         // because of the effect on compile times, but this node is FTL-only.
-        m_state.setFoundConstants(true);
+        m_state.setShouldTryConstantFolding(true);
 
         AbstractValue base = forNode(node->child1());
         RegisteredStructureSet baseSet;
         AbstractValue result;
         for (const MultiGetByOffsetCase& getCase : node->multiGetByOffsetData().cases) {
@@ -3409,13 +3660,13 @@
 
     case MultiPutByOffset: {
         RegisteredStructureSet newSet;
         TransitionVector transitions;
 
-        // Ordinarily you have to be careful with calling setFoundConstants()
+        // Ordinarily you have to be careful with calling setShouldTryConstantFolding()
         // because of the effect on compile times, but this node is FTL-only.
-        m_state.setFoundConstants(true);
+        m_state.setShouldTryConstantFolding(true);
 
         AbstractValue base = forNode(node->child1());
         AbstractValue originalValue = forNode(node->child2());
         AbstractValue resultingValue;
 
@@ -3473,11 +3724,11 @@
     }
 
     case CheckCell: {
         JSValue value = forNode(node->child1()).value();
         if (value == node->cellOperand()->value()) {
-            m_state.setFoundConstants(true);
+            m_state.setShouldTryConstantFolding(true);
             ASSERT(value);
             break;
         }
         filterByValue(node->child1(), *node->cellOperand());
         break;
@@ -3485,41 +3736,49 @@
 
     case AssertNotEmpty:
     case CheckNotEmpty: {
         AbstractValue& value = forNode(node->child1());
         if (!(value.m_type & SpecEmpty)) {
-            m_state.setFoundConstants(true);
+            m_state.setShouldTryConstantFolding(true);
             break;
         }
 
         filter(value, ~SpecEmpty);
         break;
     }
 
-    case CheckStringIdent: {
+    case CheckIdent: {
         AbstractValue& value = forNode(node->child1());
         UniquedStringImpl* uid = node->uidOperand();
-        ASSERT(!(value.m_type & ~SpecStringIdent)); // Edge filtering should have already ensured this.
 
         JSValue childConstant = value.value();
         if (childConstant) {
-            ASSERT(childConstant.isString());
-            if (asString(childConstant)->tryGetValueImpl() == uid) {
-                m_state.setFoundConstants(true);
-                break;
+            if (childConstant.isString()) {
+                if (asString(childConstant)->tryGetValueImpl() == uid) {
+                    m_state.setShouldTryConstantFolding(true);
+                    break;
+                }
+            } else if (childConstant.isSymbol()) {
+                if (&jsCast<Symbol*>(childConstant)->uid() == uid) {
+                    m_state.setShouldTryConstantFolding(true);
+                    break;
+                }
             }
         }
 
-        filter(value, SpecStringIdent);
+        if (node->child1().useKind() == StringIdentUse)
+            filter(value, SpecStringIdent);
+        else
+            filter(value, SpecSymbol);
         break;
     }
 
     case CheckInBounds: {
         JSValue left = forNode(node->child1()).value();
         JSValue right = forNode(node->child2()).value();
         if (left && right && left.isInt32() && right.isInt32() && static_cast<uint32_t>(left.asInt32()) < static_cast<uint32_t>(right.asInt32()))
-            m_state.setFoundConstants(true);
+            m_state.setShouldTryConstantFolding(true);
 
         // We claim we result in Int32. It's not really important what our result is (though we
         // don't want to claim we may result in the empty value), other nodes with data flow edges
         // to us just do that to maintain the invariant that they can't be hoisted higher than us.
         // So we just arbitrarily pick Int32. In some ways, StorageResult may be the more correct
@@ -3538,16 +3797,26 @@
                 m_graph.globalObjectFor(node->origin.semantic),
                 value.m_structure.toStructureSet(),
                 m_graph.identifiers()[node->identifierNumber()],
                 node->op() == PutByIdDirect);
 
+            bool allGood = true;
             if (status.isSimple()) {
                 RegisteredStructureSet newSet;
                 TransitionVector transitions;
 
-                for (unsigned i = status.numVariants(); i--;) {
-                    const PutByIdVariant& variant = status[i];
+                for (const PutByIdVariant& variant : status.variants()) {
+                    for (const ObjectPropertyCondition& condition : variant.conditionSet()) {
+                        if (!m_graph.watchCondition(condition)) {
+                            allGood = false;
+                            break;
+                        }
+                    }
+
+                    if (!allGood)
+                        break;
+
                     if (variant.kind() == PutByIdVariant::Transition) {
                         RegisteredStructure newStructure = m_graph.registerStructure(variant.newStructure());
                         transitions.append(
                             Transition(
                                 m_graph.registerStructure(variant.oldStructureForTransition()), newStructure));
@@ -3557,17 +3826,19 @@
                         newSet.merge(*m_graph.addStructureSet(variant.oldStructure()));
                     }
                 }
 
                 if (status.numVariants() == 1 || m_graph.m_plan.isFTL())
-                    m_state.setFoundConstants(true);
+                    m_state.setShouldTryConstantFolding(true);
 
-                didFoldClobberWorld();
-                observeTransitions(clobberLimit, transitions);
-                if (forNode(node->child1()).changeStructure(m_graph, newSet) == Contradiction)
-                    m_state.setIsValid(false);
-                break;
+                if (allGood) {
+                    didFoldClobberWorld();
+                    observeTransitions(clobberLimit, transitions);
+                    if (forNode(node->child1()).changeStructure(m_graph, newSet) == Contradiction)
+                        m_state.setIsValid(false);
+                    break;
+                }
             }
         }
 
         clobberWorld();
         break;
@@ -3606,11 +3877,11 @@
         if (JSValue constant = property.value()) {
             if (constant.isString()) {
                 JSString* string = asString(constant);
                 const StringImpl* impl = string->tryGetValueImpl();
                 if (impl && impl->isAtom())
-                    m_state.setFoundConstants(true);
+                    m_state.setShouldTryConstantFolding(true);
             }
         }
 
         // FIXME: We can determine when the property definitely exists based on abstract
         // value information.
@@ -3731,11 +4002,11 @@
 
         BooleanLattice result = BooleanLattice::Bottom;
         for (MatchStructureVariant& variant : node->matchStructureData().variants) {
             RegisteredStructure structure = variant.structure;
             if (!base.contains(structure)) {
-                m_state.setFoundConstants(true);
+                m_state.setShouldTryConstantFolding(true);
                 continue;
             }
 
             baseSet.add(structure);
             result = leastUpperBoundOfBooleanLattices(
@@ -3763,11 +4034,11 @@
         RELEASE_ASSERT(m_graph.m_form == SSA);
         setForNode(node, forNode(NodeFlowProjection(node, NodeFlowProjection::Shadow)));
         // The state of this node would have already been decided, but it may have become a
         // constant, in which case we'd like to know.
         if (forNode(node).m_value)
-            m_state.setFoundConstants(true);
+            m_state.setShouldTryConstantFolding(true);
         break;
 
     case Upsilon: {
         NodeFlowProjection shadow(node->phi(), NodeFlowProjection::Shadow);
         if (shadow.isStillValid()) {
@@ -3822,18 +4093,19 @@
     case ProfileControlFlow:
     case Phantom:
     case CountExecution:
     case CheckTierUpInLoop:
     case CheckTierUpAtReturn:
+    case CheckNeutered:
     case SuperSamplerBegin:
     case SuperSamplerEnd:
     case CheckTierUpAndOSREnter:
     case LoopHint:
     case ZombieHint:
     case ExitOK:
     case FilterCallLinkStatus:
-    case FilterGetByIdStatus:
+    case FilterGetByStatus:
     case FilterPutByIdStatus:
     case FilterInByIdStatus:
     case ClearCatchLocals:
         break;
 
@@ -3841,22 +4113,22 @@
         const AbstractValue& abstractValue = forNode(node->child1());
         unsigned bits = node->typeInfoOperand();
         ASSERT(bits);
         if (bits == ImplementsDefaultHasInstance) {
             if (abstractValue.m_type == SpecFunctionWithDefaultHasInstance) {
-                m_state.setFoundConstants(true);
+                m_state.setShouldTryConstantFolding(true);
                 break;
             }
         }
 
         if (JSValue value = abstractValue.value()) {
             if (value.isCell()) {
                 // This works because if we see a cell here, we know it's fully constructed
                 // and we can read its inline type info flags. These flags don't change over the
                 // object's lifetime.
                 if ((value.asCell()->inlineTypeFlags() & bits) == bits) {
-                    m_state.setFoundConstants(true);
+                    m_state.setShouldTryConstantFolding(true);
                     break;
                 }
             }
         }
 
@@ -3864,11 +4136,11 @@
             bool ok = true;
             abstractValue.m_structure.forEach([&] (RegisteredStructure structure) {
                 ok &= (structure->typeInfo().inlineTypeFlags() & bits) == bits;
             });
             if (ok) {
-                m_state.setFoundConstants(true);
+                m_state.setShouldTryConstantFolding(true);
                 break;
             }
         }
 
         break;
@@ -3883,11 +4155,11 @@
             else
                 radix = forNode(node->child2()).m_value;
 
             if (radix.isNumber()
                 && (radix.asNumber() == 0 || radix.asNumber() == 10)) {
-                m_state.setFoundConstants(true);
+                m_state.setShouldTryConstantFolding(true);
                 if (node->child1().useKind() == UntypedUse)
                     didFoldClobberWorld();
                 setNonCellTypeForNode(node, SpecInt32Only);
                 break;
             }
@@ -3915,11 +4187,11 @@
         // Simplify out checks that don't actually do checking.
         m_graph.doToChildren(node, [&] (Edge edge) {
             if (!edge)
                 return;
             if (edge.isProved() || edge.willNotHaveCheck())
-                m_state.setFoundConstants(true);
+                m_state.setShouldTryConstantFolding(true);
         });
         break;
     }
 
     case SetFunctionName: {
@@ -3950,10 +4222,20 @@
     case DataViewGetFloat: {
         setNonCellTypeForNode(node, SpecFullDouble);
         break;
     }
 
+    case DateGetInt32OrNaN: {
+        setNonCellTypeForNode(node, SpecInt32Only | SpecDoublePureNaN);
+        break;
+    }
+
+    case DateGetTime: {
+        setNonCellTypeForNode(node, SpecFullDouble);
+        break;
+    }
+
     case DataViewSet: {
         break;
     }
 
     case Unreachable:
@@ -3982,14 +4264,14 @@
     case FilterCallLinkStatus:
         if (JSValue value = forNode(node->child1()).m_value)
             node->callLinkStatus()->filter(m_vm, value);
         break;
 
-    case FilterGetByIdStatus: {
+    case FilterGetByStatus: {
         AbstractValue& value = forNode(node->child1());
         if (value.m_structure.isFinite())
-            node->getByIdStatus()->filter(value.m_structure.toStructureSet());
+            node->getByStatus()->filter(value.m_structure.toStructureSet());
         break;
     }
 
     case FilterInByIdStatus: {
         AbstractValue& value = forNode(node->child1());
@@ -4126,11 +4408,11 @@
     }
 
     AbstractValue::TransitionsObserver transitionsObserver(vector);
     forAllValues(clobberLimit, transitionsObserver);
 
-    if (!ASSERT_DISABLED) {
+    if (ASSERT_ENABLED) {
         // We don't need to claim to be in a clobbered state because none of the Transition::previous structures are watchable.
         for (unsigned i = vector.size(); i--;)
             ASSERT(!vector[i].previous->dfgShouldWatch());
     }
 
@@ -4189,13 +4471,13 @@
     return Contradiction;
 }
 
 template<typename AbstractStateType>
 FiltrationResult AbstractInterpreter<AbstractStateType>::filterArrayModes(
-    AbstractValue& value, ArrayModes arrayModes)
+    AbstractValue& value, ArrayModes arrayModes, SpeculatedType admittedTypes)
 {
-    if (value.filterArrayModes(arrayModes) == FiltrationOK)
+    if (value.filterArrayModes(arrayModes, admittedTypes) == FiltrationOK)
         return FiltrationOK;
     m_state.setIsValid(false);
     return Contradiction;
 }
 

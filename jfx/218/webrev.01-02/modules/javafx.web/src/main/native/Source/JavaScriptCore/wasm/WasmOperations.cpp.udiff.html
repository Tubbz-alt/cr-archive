<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmOpcodeOrigin.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmOperations.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmOperations.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -26,12 +26,22 @@</span>
  #include &quot;config.h&quot;
  #include &quot;WasmOperations.h&quot;
  
  #if ENABLE(WEBASSEMBLY)
  
<span class="udiff-line-added">+ #include &quot;ButterflyInlines.h&quot;</span>
<span class="udiff-line-added">+ #include &quot;FrameTracers.h&quot;</span>
<span class="udiff-line-added">+ #include &quot;IteratorOperations.h&quot;</span>
<span class="udiff-line-added">+ #include &quot;JITExceptions.h&quot;</span>
<span class="udiff-line-added">+ #include &quot;JSCJSValueInlines.h&quot;</span>
<span class="udiff-line-added">+ #include &quot;JSGlobalObjectInlines.h&quot;</span>
<span class="udiff-line-added">+ #include &quot;JSWebAssemblyHelpers.h&quot;</span>
<span class="udiff-line-added">+ #include &quot;JSWebAssemblyInstance.h&quot;</span>
<span class="udiff-line-added">+ #include &quot;JSWebAssemblyRuntimeError.h&quot;</span>
  #include &quot;ProbeContext.h&quot;
  #include &quot;WasmCallee.h&quot;
<span class="udiff-line-added">+ #include &quot;WasmCallingConvention.h&quot;</span>
  #include &quot;WasmContextInlines.h&quot;
  #include &quot;WasmInstance.h&quot;
  #include &quot;WasmMemory.h&quot;
  #include &quot;WasmNameSection.h&quot;
  #include &quot;WasmOMGForOSREntryPlan.h&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -42,12 +52,31 @@</span>
  #include &lt;wtf/DataLog.h&gt;
  #include &lt;wtf/Locker.h&gt;
  #include &lt;wtf/MonotonicTime.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
  
<span class="udiff-line-added">+ IGNORE_WARNINGS_BEGIN(&quot;frame-address&quot;)</span>
<span class="udiff-line-added">+ </span>
  namespace JSC { namespace Wasm {
  
<span class="udiff-line-added">+ void JIT_OPERATION operationWasmThrowBadI64(JSWebAssemblyInstance* instance)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     VM&amp; vm = instance-&gt;vm();</span>
<span class="udiff-line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="udiff-line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="udiff-line-added">+         JSGlobalObject* globalObject = instance-&gt;globalObject();</span>
<span class="udiff-line-added">+         auto* error = ErrorInstance::create(globalObject, vm, globalObject-&gt;errorStructure(ErrorType::TypeError), &quot;i64 not allowed as return type or argument to an imported function&quot;_s);</span>
<span class="udiff-line-added">+         throwException(globalObject, throwScope, error);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     genericUnwind(vm, callFrame);</span>
<span class="udiff-line-added">+     ASSERT(!!vm.callFrameForCatch);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  static bool shouldTriggerOMGCompile(TierUpCount&amp; tierUp, OMGCallee* replacement, uint32_t functionIndex)
  {
      if (!replacement &amp;&amp; !tierUp.checkIfOptimizationThresholdReached()) {
          dataLogLnIf(Options::verboseOSR(), &quot;delayOMGCompile counter = &quot;, tierUp, &quot; for &quot;, functionIndex);
          dataLogLnIf(Options::verboseOSR(), &quot;Choosing not to OMG-optimize &quot;, functionIndex, &quot; yet.&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -96,10 +125,12 @@</span>
  {
      auto returnWithoutOSREntry = [&amp;] {
          context.gpr(GPRInfo::argumentGPR0) = 0;
      };
  
<span class="udiff-line-added">+     RELEASE_ASSERT(osrEntryCallee.osrEntryScratchBufferSize() == osrEntryData.values().size());</span>
<span class="udiff-line-added">+ </span>
      uint64_t* buffer = instance-&gt;context()-&gt;scratchBufferForSize(osrEntryCallee.osrEntryScratchBufferSize());
      if (!buffer)
          return returnWithoutOSREntry();
  
      dataLogLnIf(Options::verboseOSR(), osrEntryData.functionIndex(), &quot;:OMG OSR entry: got entry callee &quot;, RawPointer(&amp;osrEntryCallee));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -200,11 +231,11 @@</span>
      // 4. Configure argument registers to jump to OSR entry from the caller of this runtime function.
      context.gpr(GPRInfo::argumentGPR0) = bitwise_cast&lt;UCPURegister&gt;(buffer);
      context.gpr(GPRInfo::argumentGPR1) = bitwise_cast&lt;UCPURegister&gt;(osrEntryCallee.entrypoint().executableAddress&lt;&gt;());
  }
  
<span class="udiff-line-modified-removed">- void JIT_OPERATION triggerOSREntryNow(Probe::Context&amp; context)</span>
<span class="udiff-line-modified-added">+ void JIT_OPERATION operationWasmTriggerOSREntryNow(Probe::Context&amp; context)</span>
  {
      OSREntryData&amp; osrEntryData = *context.arg&lt;OSREntryData*&gt;();
      uint32_t functionIndex = osrEntryData.functionIndex();
      uint32_t loopIndex = osrEntryData.loopIndex();
      Instance* instance = Wasm::Context::tryLoadInstanceFromTLS();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -384,11 +415,11 @@</span>
  
      tierUp.dontOptimizeAnytimeSoon(functionIndex);
      return returnWithoutOSREntry();
  }
  
<span class="udiff-line-modified-removed">- void JIT_OPERATION triggerTierUpNow(Instance* instance, uint32_t functionIndex)</span>
<span class="udiff-line-modified-added">+ void JIT_OPERATION operationWasmTriggerTierUpNow(Instance* instance, uint32_t functionIndex)</span>
  {
      Wasm::CodeBlock&amp; codeBlock = *instance-&gt;codeBlock();
      ASSERT(instance-&gt;memory()-&gt;mode() == codeBlock.mode());
  
      uint32_t functionIndexInSpace = functionIndex + codeBlock.functionImportCount();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -417,8 +448,308 @@</span>
              return;
          }
      }
  }
  
<span class="udiff-line-added">+ void JIT_OPERATION operationWasmUnwind(CallFrame* callFrame)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     // FIXME: Consider passing JSWebAssemblyInstance* instead.</span>
<span class="udiff-line-added">+     // https://bugs.webkit.org/show_bug.cgi?id=203206</span>
<span class="udiff-line-added">+     VM&amp; vm = callFrame-&gt;deprecatedVM();</span>
<span class="udiff-line-added">+     NativeCallFrameTracer tracer(vm, callFrame);</span>
<span class="udiff-line-added">+     genericUnwind(vm, callFrame);</span>
<span class="udiff-line-added">+     ASSERT(!!vm.callFrameForCatch);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ double JIT_OPERATION operationConvertToF64(CallFrame* callFrame, JSValue v)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     // FIXME: Consider passing JSWebAssemblyInstance* instead.</span>
<span class="udiff-line-added">+     // https://bugs.webkit.org/show_bug.cgi?id=203206</span>
<span class="udiff-line-added">+     VM&amp; vm = callFrame-&gt;deprecatedVM();</span>
<span class="udiff-line-added">+     NativeCallFrameTracer tracer(vm, callFrame);</span>
<span class="udiff-line-added">+     return v.toNumber(callFrame-&gt;lexicalGlobalObject(vm));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ int32_t JIT_OPERATION operationConvertToI32(CallFrame* callFrame, JSValue v)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     // FIXME: Consider passing JSWebAssemblyInstance* instead.</span>
<span class="udiff-line-added">+     // https://bugs.webkit.org/show_bug.cgi?id=203206</span>
<span class="udiff-line-added">+     VM&amp; vm = callFrame-&gt;deprecatedVM();</span>
<span class="udiff-line-added">+     NativeCallFrameTracer tracer(vm, callFrame);</span>
<span class="udiff-line-added">+     return v.toInt32(callFrame-&gt;lexicalGlobalObject(vm));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ float JIT_OPERATION operationConvertToF32(CallFrame* callFrame, JSValue v)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     // FIXME: Consider passing JSWebAssemblyInstance* instead.</span>
<span class="udiff-line-added">+     // https://bugs.webkit.org/show_bug.cgi?id=203206</span>
<span class="udiff-line-added">+     VM&amp; vm = callFrame-&gt;deprecatedVM();</span>
<span class="udiff-line-added">+     NativeCallFrameTracer tracer(vm, callFrame);</span>
<span class="udiff-line-added">+     return static_cast&lt;float&gt;(v.toNumber(callFrame-&gt;lexicalGlobalObject(vm)));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void JIT_OPERATION operationIterateResults(CallFrame* callFrame, Instance* instance, const Signature* signature, JSValue result, uint64_t* registerResults, uint64_t* calleeFramePointer)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     // FIXME: Consider passing JSWebAssemblyInstance* instead.</span>
<span class="udiff-line-added">+     // https://bugs.webkit.org/show_bug.cgi?id=203206</span>
<span class="udiff-line-added">+     JSWebAssemblyInstance* jsInstance = instance-&gt;owner&lt;JSWebAssemblyInstance&gt;();</span>
<span class="udiff-line-added">+     JSGlobalObject* globalObject = jsInstance-&gt;globalObject();</span>
<span class="udiff-line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="udiff-line-added">+     NativeCallFrameTracer(vm, callFrame);</span>
<span class="udiff-line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto wasmCallInfo = wasmCallingConvention().callInformationFor(*signature, CallRole::Callee);</span>
<span class="udiff-line-added">+     RegisterAtOffsetList registerResultOffsets = wasmCallInfo.computeResultsOffsetList();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     unsigned itemsInserted = 0;</span>
<span class="udiff-line-added">+     forEachInIterable(globalObject, result, [&amp;] (VM&amp; vm, JSGlobalObject* globalObject, JSValue value) -&gt; void {</span>
<span class="udiff-line-added">+         auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="udiff-line-added">+         if (itemsInserted &lt; signature-&gt;returnCount()) {</span>
<span class="udiff-line-added">+             uint64_t unboxedValue;</span>
<span class="udiff-line-added">+             switch (signature-&gt;returnType(itemsInserted)) {</span>
<span class="udiff-line-added">+             case I32:</span>
<span class="udiff-line-added">+                 unboxedValue = value.toInt32(globalObject);</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             case F32:</span>
<span class="udiff-line-added">+                 unboxedValue = bitwise_cast&lt;uint32_t&gt;(value.toFloat(globalObject));</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             case F64:</span>
<span class="udiff-line-added">+                 unboxedValue = bitwise_cast&lt;uint64_t&gt;(value.toNumber(globalObject));</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             case Funcref:</span>
<span class="udiff-line-added">+                 if (!value.isFunction(vm)) {</span>
<span class="udiff-line-added">+                     throwTypeError(globalObject, scope, &quot;Funcref value is not a function&quot;_s);</span>
<span class="udiff-line-added">+                     return;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 FALLTHROUGH;</span>
<span class="udiff-line-added">+             case Anyref:</span>
<span class="udiff-line-added">+                 unboxedValue = bitwise_cast&lt;uint64_t&gt;(value);</span>
<span class="udiff-line-added">+                 RELEASE_ASSERT(Options::useWebAssemblyReferences());</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             default:</span>
<span class="udiff-line-added">+                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             RETURN_IF_EXCEPTION(scope, void());</span>
<span class="udiff-line-added">+             auto rep = wasmCallInfo.results[itemsInserted];</span>
<span class="udiff-line-added">+             if (rep.isReg())</span>
<span class="udiff-line-added">+                 registerResults[registerResultOffsets.find(rep.reg())-&gt;offset() / sizeof(uint64_t)] = unboxedValue;</span>
<span class="udiff-line-added">+             else</span>
<span class="udiff-line-added">+                 calleeFramePointer[rep.offsetFromFP() / sizeof(uint64_t)] = unboxedValue;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         itemsInserted++;</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+     RETURN_IF_EXCEPTION(scope, void());</span>
<span class="udiff-line-added">+     if (itemsInserted != signature-&gt;returnCount())</span>
<span class="udiff-line-added">+         throwVMTypeError(globalObject, scope, &quot;Incorrect number of values returned to Wasm from JS&quot;);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // FIXME: It would be much easier to inline this when we have a global GC, which could probably mean we could avoid</span>
<span class="udiff-line-added">+ // spilling the results onto the stack.</span>
<span class="udiff-line-added">+ // Saved result registers should be placed on the stack just above the last stack result.</span>
<span class="udiff-line-added">+ JSArray* JIT_OPERATION operationAllocateResultsArray(CallFrame* callFrame, Wasm::Instance* instance, const Signature* signature, IndexingType indexingType, JSValue* stackPointerFromCallee)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     JSWebAssemblyInstance* jsInstance = instance-&gt;owner&lt;JSWebAssemblyInstance&gt;();</span>
<span class="udiff-line-added">+     VM&amp; vm = jsInstance-&gt;vm();</span>
<span class="udiff-line-added">+     NativeCallFrameTracer tracer(vm, callFrame);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     JSGlobalObject* globalObject = jsInstance-&gt;globalObject();</span>
<span class="udiff-line-added">+     ObjectInitializationScope initializationScope(globalObject-&gt;vm());</span>
<span class="udiff-line-added">+     JSArray* result = JSArray::tryCreateUninitializedRestricted(initializationScope, nullptr, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingType), signature-&gt;returnCount());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // FIXME: Handle allocation failure...</span>
<span class="udiff-line-added">+     RELEASE_ASSERT(result);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto wasmCallInfo = wasmCallingConvention().callInformationFor(*signature);</span>
<span class="udiff-line-added">+     RegisterAtOffsetList registerResults = wasmCallInfo.computeResultsOffsetList();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     static_assert(sizeof(JSValue) == sizeof(CPURegister), &quot;The code below relies on this.&quot;);</span>
<span class="udiff-line-added">+     for (unsigned i = 0; i &lt; signature-&gt;returnCount(); ++i) {</span>
<span class="udiff-line-added">+         B3::ValueRep rep = wasmCallInfo.results[i];</span>
<span class="udiff-line-added">+         JSValue value;</span>
<span class="udiff-line-added">+         if (rep.isReg())</span>
<span class="udiff-line-added">+             value = stackPointerFromCallee[(registerResults.find(rep.reg())-&gt;offset() + wasmCallInfo.headerAndArgumentStackSizeInBytes) / sizeof(JSValue)];</span>
<span class="udiff-line-added">+         else</span>
<span class="udiff-line-added">+             value = stackPointerFromCallee[rep.offsetFromSP() / sizeof(JSValue)];</span>
<span class="udiff-line-added">+         result-&gt;initializeIndex(initializationScope, i, value);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     ASSERT(result-&gt;indexingType() == indexingType);</span>
<span class="udiff-line-added">+     return result;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void JIT_OPERATION operationWasmWriteBarrierSlowPath(JSCell* cell, VM* vmPointer)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     ASSERT(cell);</span>
<span class="udiff-line-added">+     ASSERT(vmPointer);</span>
<span class="udiff-line-added">+     VM&amp; vm = *vmPointer;</span>
<span class="udiff-line-added">+     vm.heap.writeBarrierSlowPath(cell);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ uint32_t JIT_OPERATION operationPopcount32(int32_t value)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return __builtin_popcount(value);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ uint64_t JIT_OPERATION operationPopcount64(int64_t value)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return __builtin_popcountll(value);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ int32_t JIT_OPERATION operationGrowMemory(void* callFrame, Instance* instance, int32_t delta)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     instance-&gt;storeTopCallFrame(callFrame);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (delta &lt; 0)</span>
<span class="udiff-line-added">+         return -1;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto grown = instance-&gt;memory()-&gt;grow(PageCount(delta));</span>
<span class="udiff-line-added">+     if (!grown) {</span>
<span class="udiff-line-added">+         switch (grown.error()) {</span>
<span class="udiff-line-added">+         case Memory::GrowFailReason::InvalidDelta:</span>
<span class="udiff-line-added">+         case Memory::GrowFailReason::InvalidGrowSize:</span>
<span class="udiff-line-added">+         case Memory::GrowFailReason::WouldExceedMaximum:</span>
<span class="udiff-line-added">+         case Memory::GrowFailReason::OutOfMemory:</span>
<span class="udiff-line-added">+             return -1;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return grown.value().pageCount();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ EncodedJSValue JIT_OPERATION operationGetWasmTableElement(Instance* instance, unsigned tableIndex, int32_t signedIndex)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     ASSERT(tableIndex &lt; instance-&gt;module().moduleInformation().tableCount());</span>
<span class="udiff-line-added">+     if (signedIndex &lt; 0)</span>
<span class="udiff-line-added">+         return 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     uint32_t index = signedIndex;</span>
<span class="udiff-line-added">+     if (index &gt;= instance-&gt;table(tableIndex)-&gt;length())</span>
<span class="udiff-line-added">+         return 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return JSValue::encode(instance-&gt;table(tableIndex)-&gt;get(index));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static bool setWasmTableElement(Instance* instance, unsigned tableIndex, int32_t signedIndex, EncodedJSValue encValue)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     ASSERT(tableIndex &lt; instance-&gt;module().moduleInformation().tableCount());</span>
<span class="udiff-line-added">+     if (signedIndex &lt; 0)</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     uint32_t index = signedIndex;</span>
<span class="udiff-line-added">+     if (index &gt;= instance-&gt;table(tableIndex)-&gt;length())</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     JSValue value = JSValue::decode(encValue);</span>
<span class="udiff-line-added">+     if (instance-&gt;table(tableIndex)-&gt;type() == Wasm::TableElementType::Anyref)</span>
<span class="udiff-line-added">+         instance-&gt;table(tableIndex)-&gt;set(index, value);</span>
<span class="udiff-line-added">+     else if (instance-&gt;table(tableIndex)-&gt;type() == Wasm::TableElementType::Funcref) {</span>
<span class="udiff-line-added">+         WebAssemblyFunction* wasmFunction;</span>
<span class="udiff-line-added">+         WebAssemblyWrapperFunction* wasmWrapperFunction;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (isWebAssemblyHostFunction(instance-&gt;owner&lt;JSObject&gt;()-&gt;vm(), value, wasmFunction, wasmWrapperFunction)) {</span>
<span class="udiff-line-added">+             ASSERT(!!wasmFunction || !!wasmWrapperFunction);</span>
<span class="udiff-line-added">+             if (wasmFunction)</span>
<span class="udiff-line-added">+                 instance-&gt;table(tableIndex)-&gt;asFuncrefTable()-&gt;setFunction(index, jsCast&lt;JSObject*&gt;(value), wasmFunction-&gt;importableFunction(), &amp;wasmFunction-&gt;instance()-&gt;instance());</span>
<span class="udiff-line-added">+             else</span>
<span class="udiff-line-added">+                 instance-&gt;table(tableIndex)-&gt;asFuncrefTable()-&gt;setFunction(index, jsCast&lt;JSObject*&gt;(value), wasmWrapperFunction-&gt;importableFunction(), &amp;wasmWrapperFunction-&gt;instance()-&gt;instance());</span>
<span class="udiff-line-added">+         } else if (value.isNull())</span>
<span class="udiff-line-added">+             instance-&gt;table(tableIndex)-&gt;clear(index);</span>
<span class="udiff-line-added">+         else</span>
<span class="udiff-line-added">+             ASSERT_NOT_REACHED();</span>
<span class="udiff-line-added">+     } else</span>
<span class="udiff-line-added">+         ASSERT_NOT_REACHED();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool JIT_OPERATION operationSetWasmTableElement(Instance* instance, unsigned tableIndex, int32_t signedIndex, EncodedJSValue encValue)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return setWasmTableElement(instance, tableIndex, signedIndex, encValue);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ int32_t JIT_OPERATION operationWasmTableGrow(Instance* instance, unsigned tableIndex, EncodedJSValue fill, int32_t delta)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     ASSERT(tableIndex &lt; instance-&gt;module().moduleInformation().tableCount());</span>
<span class="udiff-line-added">+     auto oldSize = instance-&gt;table(tableIndex)-&gt;length();</span>
<span class="udiff-line-added">+     if (delta &lt; 0)</span>
<span class="udiff-line-added">+         return oldSize;</span>
<span class="udiff-line-added">+     auto newSize = instance-&gt;table(tableIndex)-&gt;grow(delta);</span>
<span class="udiff-line-added">+     if (!newSize || *newSize == oldSize)</span>
<span class="udiff-line-added">+         return -1;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     for (unsigned i = oldSize; i &lt; instance-&gt;table(tableIndex)-&gt;length(); ++i)</span>
<span class="udiff-line-added">+         setWasmTableElement(instance, tableIndex, i, fill);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return oldSize;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool JIT_OPERATION operationWasmTableFill(Instance* instance, unsigned tableIndex, int32_t unsafeOffset, EncodedJSValue fill, int32_t unsafeCount)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     ASSERT(tableIndex &lt; instance-&gt;module().moduleInformation().tableCount());</span>
<span class="udiff-line-added">+     if (unsafeOffset &lt; 0 || unsafeCount &lt; 0)</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     unsigned offset = unsafeOffset;</span>
<span class="udiff-line-added">+     unsigned count = unsafeCount;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (offset &gt;= instance-&gt;table(tableIndex)-&gt;length() || offset + count &gt; instance-&gt;table(tableIndex)-&gt;length())</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     for (unsigned j = 0; j &lt; count; ++j)</span>
<span class="udiff-line-added">+         setWasmTableElement(instance, tableIndex, offset + j, fill);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ EncodedJSValue JIT_OPERATION operationWasmRefFunc(Instance* instance, uint32_t index)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     JSValue value = instance-&gt;getFunctionWrapper(index);</span>
<span class="udiff-line-added">+     ASSERT(value.isFunction(instance-&gt;owner&lt;JSObject&gt;()-&gt;vm()));</span>
<span class="udiff-line-added">+     return JSValue::encode(value);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ int32_t JIT_OPERATION operationGetWasmTableSize(Instance* instance, unsigned tableIndex)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return instance-&gt;table(tableIndex)-&gt;length();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void* JIT_OPERATION operationWasmToJSException(CallFrame* callFrame, Wasm::ExceptionType type, Instance* wasmInstance)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     wasmInstance-&gt;storeTopCallFrame(callFrame);</span>
<span class="udiff-line-added">+     JSWebAssemblyInstance* instance = wasmInstance-&gt;owner&lt;JSWebAssemblyInstance&gt;();</span>
<span class="udiff-line-added">+     JSGlobalObject* globalObject = instance-&gt;globalObject();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     // Do not retrieve VM&amp; from CallFrame since CallFrame&#39;s callee is not a JSCell.</span>
<span class="udiff-line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         JSObject* error;</span>
<span class="udiff-line-added">+         if (type == ExceptionType::StackOverflow)</span>
<span class="udiff-line-added">+             error = createStackOverflowError(globalObject);</span>
<span class="udiff-line-added">+         else</span>
<span class="udiff-line-added">+             error = JSWebAssemblyRuntimeError::create(globalObject, vm, globalObject-&gt;webAssemblyRuntimeErrorStructure(), Wasm::errorMessageForExceptionType(type));</span>
<span class="udiff-line-added">+         throwException(globalObject, throwScope, error);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     genericUnwind(vm, callFrame);</span>
<span class="udiff-line-added">+     ASSERT(!!vm.callFrameForCatch);</span>
<span class="udiff-line-added">+     ASSERT(!!vm.targetMachinePCForThrow);</span>
<span class="udiff-line-added">+     // FIXME: We could make this better:</span>
<span class="udiff-line-added">+     // This is a total hack, but the llint (both op_catch and handleUncaughtException)</span>
<span class="udiff-line-added">+     // require a cell in the callee field to load the VM. (The baseline JIT does not require</span>
<span class="udiff-line-added">+     // this since it is compiled with a constant VM pointer.) We could make the calling convention</span>
<span class="udiff-line-added">+     // for exceptions first load callFrameForCatch info call frame register before jumping</span>
<span class="udiff-line-added">+     // to the exception handler. If we did this, we could remove this terrible hack.</span>
<span class="udiff-line-added">+     // https://bugs.webkit.org/show_bug.cgi?id=170440</span>
<span class="udiff-line-added">+     bitwise_cast&lt;uint64_t*&gt;(callFrame)[static_cast&lt;int&gt;(CallFrameSlot::callee)] = bitwise_cast&lt;uint64_t&gt;(instance-&gt;module());</span>
<span class="udiff-line-added">+     return vm.targetMachinePCForThrow;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  } } // namespace JSC::Wasm
  
<span class="udiff-line-added">+ IGNORE_WARNINGS_END</span>
<span class="udiff-line-added">+ </span>
  #endif // ENABLE(WEBASSEMBLY)
</pre>
<center><a href="WasmOpcodeOrigin.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmOperations.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/page/Page.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2006-2019 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Library General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Library General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Library General Public License
  16  * along with this library; see the file COPYING.LIB.  If not, write to
  17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  18  * Boston, MA 02110-1301, USA.
  19  */
  20 
  21 #pragma once
  22 
  23 #include &quot;ActivityState.h&quot;
  24 #include &quot;DisabledAdaptations.h&quot;
  25 #include &quot;Document.h&quot;
  26 #include &quot;FindOptions.h&quot;
  27 #include &quot;FrameLoaderTypes.h&quot;
  28 #include &quot;LayoutMilestone.h&quot;
  29 #include &quot;LayoutRect.h&quot;
  30 #include &quot;LengthBox.h&quot;
  31 #include &quot;MediaProducer.h&quot;
  32 #include &quot;Pagination.h&quot;
  33 #include &quot;RTCController.h&quot;
  34 #include &quot;Region.h&quot;
  35 #include &quot;RegistrableDomain.h&quot;
  36 #include &quot;RenderingUpdateScheduler.h&quot;
  37 #include &quot;ScrollTypes.h&quot;
  38 #include &quot;Supplementable.h&quot;
  39 #include &quot;Timer.h&quot;
  40 #include &quot;UserInterfaceLayoutDirection.h&quot;
  41 #include &quot;ViewportArguments.h&quot;
  42 #include &quot;VisibilityState.h&quot;
  43 #include &quot;WheelEventTestMonitor.h&quot;
  44 #include &lt;memory&gt;
  45 #include &lt;pal/SessionID.h&gt;
  46 #include &lt;wtf/Assertions.h&gt;
  47 #include &lt;wtf/Forward.h&gt;
  48 #include &lt;wtf/Function.h&gt;
  49 #include &lt;wtf/HashSet.h&gt;
  50 #include &lt;wtf/Noncopyable.h&gt;
  51 #include &lt;wtf/Ref.h&gt;
  52 #include &lt;wtf/UniqueRef.h&gt;
  53 #include &lt;wtf/WeakPtr.h&gt;
  54 #include &lt;wtf/text/WTFString.h&gt;
  55 
  56 #if PLATFORM(COCOA)
  57 #include &lt;wtf/SchedulePair.h&gt;
  58 #endif
  59 
  60 #if ENABLE(APPLICATION_MANIFEST)
  61 #include &quot;ApplicationManifest.h&quot;
  62 #endif
  63 
  64 #if ENABLE(MEDIA_SESSION)
  65 #include &quot;MediaSessionEvents.h&quot;
  66 #endif
  67 
  68 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
  69 #include &quot;MediaPlaybackTargetContext.h&quot;
  70 #endif
  71 
  72 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
  73 #include &quot;DeviceOrientationUpdateProvider.h&quot;
  74 #endif
  75 
  76 namespace JSC {
  77 class Debugger;
  78 }
  79 
  80 namespace WebCore {
  81 
  82 namespace IDBClient {
  83 class IDBConnectionToServer;
  84 }
  85 
  86 class ActivityStateChangeObserver;
  87 class AlternativeTextClient;
  88 class ApplicationCacheStorage;
  89 class AuthenticatorCoordinator;
  90 class BackForwardController;
  91 class CacheStorageProvider;
  92 class Chrome;
  93 class Color;
  94 class ContextMenuController;
  95 class CookieJar;
  96 class DOMRectList;
  97 class DatabaseProvider;
  98 class DiagnosticLoggingClient;
  99 class DragCaretController;
 100 class DragController;
 101 class EditorClient;
 102 class Element;
 103 class FocusController;
 104 class Frame;
 105 class HTMLMediaElement;
 106 class HistoryItem;
 107 class InspectorClient;
 108 class InspectorController;
 109 class LibWebRTCProvider;
 110 class LowPowerModeNotifier;
 111 class MediaCanStartListener;
 112 class MediaPlaybackTarget;
 113 class MediaRecorderProvider;
 114 class PageConfiguration;
 115 class PageConsoleClient;
 116 class PageDebuggable;
 117 class PageGroup;
 118 class PageOverlayController;
 119 class PaymentCoordinator;
 120 class PerformanceLogging;
 121 class PerformanceLoggingClient;
 122 class PerformanceMonitor;
 123 class PlugInClient;
 124 class PluginData;
 125 class PluginInfoProvider;
 126 class PluginViewBase;
 127 class PointerCaptureController;
 128 class PointerLockController;
 129 class ProgressTracker;
 130 class Range;
 131 class RenderObject;
 132 class ResourceUsageOverlay;
 133 class ScrollLatchingState;
 134 class ScrollingCoordinator;
 135 class ServicesOverlayController;
 136 class Settings;
 137 class SocketProvider;
 138 class SpeechSynthesisClient;
 139 class StorageNamespace;
 140 class StorageNamespaceProvider;
 141 class UserContentProvider;
 142 class UserContentURLPattern;
 143 class UserInputBridge;
 144 class ValidationMessageClient;
 145 class VisibleSelection;
 146 class VisitedLinkStore;
 147 class WebGLStateTracker;
 148 class WheelEventDeltaFilter;
 149 
 150 using SharedStringHash = uint32_t;
 151 
 152 enum class CanWrap : bool;
 153 enum class DidWrap : bool;
 154 enum class RouteSharingPolicy : uint8_t;
 155 enum class ShouldTreatAsContinuingLoad : bool;
 156 
 157 enum class EventThrottlingBehavior : bool { Responsive, Unresponsive };
 158 
 159 enum class CompositingPolicy : bool {
 160     Normal,
 161     Conservative, // Used in low memory situations.
 162 };
 163 
 164 class Page : public Supplementable&lt;Page&gt;, public CanMakeWeakPtr&lt;Page&gt; {
 165     WTF_MAKE_NONCOPYABLE(Page);
 166     WTF_MAKE_FAST_ALLOCATED;
 167     friend class SettingsBase;
 168 
 169 public:
 170     WEBCORE_EXPORT static void updateStyleForAllPagesAfterGlobalChangeInEnvironment();
 171     WEBCORE_EXPORT static void clearPreviousItemFromAllPages(HistoryItem*);
 172 
 173     void updateStyleAfterChangeInEnvironment();
 174 
 175     WEBCORE_EXPORT explicit Page(PageConfiguration&amp;&amp;);
 176     WEBCORE_EXPORT ~Page();
 177 
 178     WEBCORE_EXPORT uint64_t renderTreeSize() const;
 179 
 180     WEBCORE_EXPORT void setNeedsRecalcStyleInAllFrames();
 181 
 182     WEBCORE_EXPORT OptionSet&lt;DisabledAdaptations&gt; disabledAdaptations() const;
 183     WEBCORE_EXPORT ViewportArguments viewportArguments() const;
 184 
 185     const Optional&lt;ViewportArguments&gt;&amp; overrideViewportArguments() const { return m_overrideViewportArguments; }
 186     WEBCORE_EXPORT void setOverrideViewportArguments(const Optional&lt;ViewportArguments&gt;&amp;);
 187 
 188     static void refreshPlugins(bool reload);
 189     WEBCORE_EXPORT PluginData&amp; pluginData();
 190     void clearPluginData();
 191 
 192     WEBCORE_EXPORT void setCanStartMedia(bool);
 193     bool canStartMedia() const { return m_canStartMedia; }
 194 
 195     EditorClient&amp; editorClient() { return m_editorClient.get(); }
 196     PlugInClient* plugInClient() const { return m_plugInClient.get(); }
 197 
 198     Frame&amp; mainFrame() { return m_mainFrame.get(); }
 199     const Frame&amp; mainFrame() const { return m_mainFrame.get(); }
 200 
 201     bool openedByDOM() const;
 202     void setOpenedByDOM();
 203 
 204     bool openedByDOMWithOpener() const { return m_openedByDOMWithOpener; }
 205     void setOpenedByDOMWithOpener() { m_openedByDOMWithOpener = true; }
 206 
 207     WEBCORE_EXPORT void goToItem(HistoryItem&amp;, FrameLoadType, ShouldTreatAsContinuingLoad);
 208 
 209     WEBCORE_EXPORT void setGroupName(const String&amp;);
 210     WEBCORE_EXPORT const String&amp; groupName() const;
 211 
 212     PageGroup&amp; group();
 213 
 214     WEBCORE_EXPORT static void forEachPage(const WTF::Function&lt;void(Page&amp;)&gt;&amp;);
 215 
 216     void incrementSubframeCount() { ++m_subframeCount; }
 217     void decrementSubframeCount() { ASSERT(m_subframeCount); --m_subframeCount; }
 218     int subframeCount() const { checkSubframeCountConsistency(); return m_subframeCount; }
 219 
 220     void incrementNestedRunLoopCount();
 221     void decrementNestedRunLoopCount();
 222     bool insideNestedRunLoop() const { return m_nestedRunLoopCount &gt; 0; }
 223     WEBCORE_EXPORT void whenUnnested(WTF::Function&lt;void()&gt;&amp;&amp;);
 224 
 225 #if ENABLE(REMOTE_INSPECTOR)
 226     WEBCORE_EXPORT bool remoteInspectionAllowed() const;
 227     WEBCORE_EXPORT void setRemoteInspectionAllowed(bool);
 228     WEBCORE_EXPORT String remoteInspectionNameOverride() const;
 229     WEBCORE_EXPORT void setRemoteInspectionNameOverride(const String&amp;);
 230     void remoteInspectorInformationDidChange() const;
 231 #endif
 232 
 233     Chrome&amp; chrome() const { return *m_chrome; }
 234     DragCaretController&amp; dragCaretController() const { return *m_dragCaretController; }
 235 #if ENABLE(DRAG_SUPPORT)
 236     DragController&amp; dragController() const { return *m_dragController; }
 237 #endif
 238     FocusController&amp; focusController() const { return *m_focusController; }
 239 #if ENABLE(CONTEXT_MENUS)
 240     ContextMenuController&amp; contextMenuController() const { return *m_contextMenuController; }
 241 #endif
 242     UserInputBridge&amp; userInputBridge() const { return *m_userInputBridge; }
 243     InspectorController&amp; inspectorController() const { return *m_inspectorController; }
 244 #if ENABLE(POINTER_EVENTS)
 245     PointerCaptureController&amp; pointerCaptureController() const { return *m_pointerCaptureController; }
 246 #endif
 247 #if ENABLE(POINTER_LOCK)
 248     PointerLockController&amp; pointerLockController() const { return *m_pointerLockController; }
 249 #endif
 250     LibWebRTCProvider&amp; libWebRTCProvider() { return m_libWebRTCProvider.get(); }
 251     RTCController&amp; rtcController() { return m_rtcController; }
 252     WEBCORE_EXPORT void disableICECandidateFiltering();
 253     WEBCORE_EXPORT void enableICECandidateFiltering();
 254     bool shouldEnableICECandidateFilteringByDefault() const { return m_shouldEnableICECandidateFilteringByDefault; }
 255 
 256     void didChangeMainDocument();
 257 
 258     PerformanceMonitor* performanceMonitor() { return m_performanceMonitor.get(); }
 259 
 260     RenderingUpdateScheduler&amp; renderingUpdateScheduler();
 261 
 262     ValidationMessageClient* validationMessageClient() const { return m_validationMessageClient.get(); }
 263     void updateValidationBubbleStateIfNeeded();
 264 
 265     WEBCORE_EXPORT ScrollingCoordinator* scrollingCoordinator();
 266 
 267     WEBCORE_EXPORT String scrollingStateTreeAsText();
 268     WEBCORE_EXPORT String synchronousScrollingReasonsAsText();
 269     WEBCORE_EXPORT Ref&lt;DOMRectList&gt; nonFastScrollableRects();
 270 
 271     WEBCORE_EXPORT Ref&lt;DOMRectList&gt; touchEventRectsForEvent(const String&amp; eventName);
 272     WEBCORE_EXPORT Ref&lt;DOMRectList&gt; passiveTouchEventListenerRects();
 273 
 274     Settings&amp; settings() const { return *m_settings; }
 275     ProgressTracker&amp; progress() const { return *m_progress; }
 276     BackForwardController&amp; backForward() const { return *m_backForwardController; }
 277 
 278     Seconds domTimerAlignmentInterval() const { return m_domTimerAlignmentInterval; }
 279 
 280     void setTabKeyCyclesThroughElements(bool b) { m_tabKeyCyclesThroughElements = b; }
 281     bool tabKeyCyclesThroughElements() const { return m_tabKeyCyclesThroughElements; }
 282 
 283     WEBCORE_EXPORT bool findString(const String&amp;, FindOptions, DidWrap* = nullptr);
 284     WEBCORE_EXPORT uint32_t replaceRangesWithText(const Vector&lt;Ref&lt;Range&gt;&gt;&amp; rangesToReplace, const String&amp; replacementText, bool selectionOnly);
 285     WEBCORE_EXPORT uint32_t replaceSelectionWithText(const String&amp; replacementText);
 286 
 287     WEBCORE_EXPORT RefPtr&lt;Range&gt; rangeOfString(const String&amp;, Range*, FindOptions);
 288 
 289     WEBCORE_EXPORT unsigned countFindMatches(const String&amp;, FindOptions, unsigned maxMatchCount);
 290     WEBCORE_EXPORT unsigned markAllMatchesForText(const String&amp;, FindOptions, bool shouldHighlight, unsigned maxMatchCount);
 291 
 292     WEBCORE_EXPORT void unmarkAllTextMatches();
 293 
 294     WEBCORE_EXPORT void dispatchBeforePrintEvent();
 295     WEBCORE_EXPORT void dispatchAfterPrintEvent();
 296 
 297     // Find all the Ranges for the matching text.
 298     // Upon return, indexForSelection will be one of the following:
 299     // 0 if there is no user selection
 300     // the index of the first range after the user selection
 301     // NoMatchAfterUserSelection if there is no matching text after the user selection.
 302     enum { NoMatchAfterUserSelection = -1 };
 303     WEBCORE_EXPORT void findStringMatchingRanges(const String&amp;, FindOptions, int maxCount, Vector&lt;RefPtr&lt;Range&gt;&gt;&amp;, int&amp; indexForSelection);
 304 
 305 #if PLATFORM(COCOA)
 306     void platformInitialize();
 307     WEBCORE_EXPORT void addSchedulePair(Ref&lt;SchedulePair&gt;&amp;&amp;);
 308     WEBCORE_EXPORT void removeSchedulePair(Ref&lt;SchedulePair&gt;&amp;&amp;);
 309     SchedulePairHashSet* scheduledRunLoopPairs() { return m_scheduledRunLoopPairs.get(); }
 310 
 311     std::unique_ptr&lt;SchedulePairHashSet&gt; m_scheduledRunLoopPairs;
 312 #endif
 313 
 314     WEBCORE_EXPORT const VisibleSelection&amp; selection() const;
 315 
 316     WEBCORE_EXPORT void setDefersLoading(bool);
 317     bool defersLoading() const { return m_defersLoading; }
 318 
 319     WEBCORE_EXPORT void clearUndoRedoOperations();
 320 
 321     WEBCORE_EXPORT bool inLowQualityImageInterpolationMode() const;
 322     WEBCORE_EXPORT void setInLowQualityImageInterpolationMode(bool = true);
 323 
 324     float mediaVolume() const { return m_mediaVolume; }
 325     WEBCORE_EXPORT void setMediaVolume(float);
 326 
 327     WEBCORE_EXPORT void setPageScaleFactor(float scale, const IntPoint&amp; origin, bool inStableState = true);
 328     float pageScaleFactor() const { return m_pageScaleFactor; }
 329 
 330     UserInterfaceLayoutDirection userInterfaceLayoutDirection() const { return m_userInterfaceLayoutDirection; }
 331     WEBCORE_EXPORT void setUserInterfaceLayoutDirection(UserInterfaceLayoutDirection);
 332 
 333     WEBCORE_EXPORT void updateMediaElementRateChangeRestrictions();
 334 
 335     void didStartProvisionalLoad();
 336     void didFinishLoad(); // Called when the load has been committed in the main frame.
 337 
 338     bool delegatesScaling() const { return m_delegatesScaling; }
 339     WEBCORE_EXPORT void setDelegatesScaling(bool);
 340 
 341     // The view scale factor is multiplied into the page scale factor by all
 342     // callers of setPageScaleFactor.
 343     WEBCORE_EXPORT void setViewScaleFactor(float);
 344     float viewScaleFactor() const { return m_viewScaleFactor; }
 345 
 346     WEBCORE_EXPORT void setZoomedOutPageScaleFactor(float);
 347     float zoomedOutPageScaleFactor() const { return m_zoomedOutPageScaleFactor; }
 348 
 349     float deviceScaleFactor() const { return m_deviceScaleFactor; }
 350     WEBCORE_EXPORT void setDeviceScaleFactor(float);
 351 
 352     float initialScale() const { return m_initialScale; }
 353     WEBCORE_EXPORT void setInitialScale(float);
 354 
 355     float topContentInset() const { return m_topContentInset; }
 356     WEBCORE_EXPORT void setTopContentInset(float);
 357 
 358     const FloatBoxExtent&amp; obscuredInsets() const { return m_obscuredInsets; }
 359     void setObscuredInsets(const FloatBoxExtent&amp; obscuredInsets) { m_obscuredInsets = obscuredInsets; }
 360 
 361     const FloatBoxExtent&amp; contentInsets() const { return m_contentInsets; }
 362     void setContentInsets(const FloatBoxExtent&amp; insets) { m_contentInsets = insets; }
 363 
 364     const FloatBoxExtent&amp; unobscuredSafeAreaInsets() const { return m_unobscuredSafeAreaInsets; }
 365     WEBCORE_EXPORT void setUnobscuredSafeAreaInsets(const FloatBoxExtent&amp;);
 366 
 367 #if PLATFORM(IOS_FAMILY)
 368     bool enclosedInScrollableAncestorView() const { return m_enclosedInScrollableAncestorView; }
 369     void setEnclosedInScrollableAncestorView(bool f) { m_enclosedInScrollableAncestorView = f; }
 370 #endif
 371 
 372     bool useSystemAppearance() const { return m_useSystemAppearance; }
 373     WEBCORE_EXPORT void setUseSystemAppearance(bool);
 374 
 375     WEBCORE_EXPORT bool useDarkAppearance() const;
 376     bool useElevatedUserInterfaceLevel() const { return m_useElevatedUserInterfaceLevel; }
 377     WEBCORE_EXPORT void effectiveAppearanceDidChange(bool useDarkAppearance, bool useElevatedUserInterfaceLevel);
 378     bool defaultUseDarkAppearance() const { return m_useDarkAppearance; }
 379     void setUseDarkAppearanceOverride(Optional&lt;bool&gt;);
 380 
 381 #if ENABLE(TEXT_AUTOSIZING)
 382     float textAutosizingWidth() const { return m_textAutosizingWidth; }
 383     void setTextAutosizingWidth(float textAutosizingWidth) { m_textAutosizingWidth = textAutosizingWidth; }
 384     WEBCORE_EXPORT void recomputeTextAutoSizingInAllFrames();
 385 #endif
 386 
 387     const FloatBoxExtent&amp; fullscreenInsets() const { return m_fullscreenInsets; }
 388     WEBCORE_EXPORT void setFullscreenInsets(const FloatBoxExtent&amp;);
 389 
 390     const Seconds fullscreenAutoHideDuration() const { return m_fullscreenAutoHideDuration; }
 391     WEBCORE_EXPORT void setFullscreenAutoHideDuration(Seconds);
 392     WEBCORE_EXPORT void setFullscreenControlsHidden(bool);
 393 
 394     bool shouldSuppressScrollbarAnimations() const { return m_suppressScrollbarAnimations; }
 395     WEBCORE_EXPORT void setShouldSuppressScrollbarAnimations(bool suppressAnimations);
 396     void lockAllOverlayScrollbarsToHidden(bool lockOverlayScrollbars);
 397 
 398     WEBCORE_EXPORT void setVerticalScrollElasticity(ScrollElasticity);
 399     ScrollElasticity verticalScrollElasticity() const { return static_cast&lt;ScrollElasticity&gt;(m_verticalScrollElasticity); }
 400 
 401     WEBCORE_EXPORT void setHorizontalScrollElasticity(ScrollElasticity);
 402     ScrollElasticity horizontalScrollElasticity() const { return static_cast&lt;ScrollElasticity&gt;(m_horizontalScrollElasticity); }
 403 
 404     WEBCORE_EXPORT void accessibilitySettingsDidChange();
 405     WEBCORE_EXPORT void appearanceDidChange();
 406 
 407     // Page and FrameView both store a Pagination value. Page::pagination() is set only by API,
 408     // and FrameView::pagination() is set only by CSS. Page::pagination() will affect all
 409     // FrameViews in the back/forward cache, but FrameView::pagination() only affects the current
 410     // FrameView.
 411     const Pagination&amp; pagination() const { return m_pagination; }
 412     WEBCORE_EXPORT void setPagination(const Pagination&amp;);
 413     bool paginationLineGridEnabled() const { return m_paginationLineGridEnabled; }
 414     WEBCORE_EXPORT void setPaginationLineGridEnabled(bool flag);
 415 
 416     WEBCORE_EXPORT unsigned pageCount() const;
 417 
 418     WEBCORE_EXPORT DiagnosticLoggingClient&amp; diagnosticLoggingClient() const;
 419 
 420     PerformanceLoggingClient* performanceLoggingClient() const { return m_performanceLoggingClient.get(); }
 421 
 422     WheelEventDeltaFilter* wheelEventDeltaFilter() { return m_recentWheelEventDeltaFilter.get(); }
 423     PageOverlayController&amp; pageOverlayController() { return *m_pageOverlayController; }
 424 
 425 #if PLATFORM(MAC) &amp;&amp; (ENABLE(SERVICE_CONTROLS) || ENABLE(TELEPHONE_NUMBER_DETECTION))
 426     ServicesOverlayController&amp; servicesOverlayController() { return *m_servicesOverlayController; }
 427 #endif
 428 
 429 #if PLATFORM(MAC)
 430     ScrollLatchingState* latchingState();
 431     void pushNewLatchingState();
 432     void popLatchingState();
 433     void resetLatchingState();
 434     void removeLatchingStateForTarget(Element&amp;);
 435 #endif // PLATFORM(MAC)
 436 
 437 #if ENABLE(APPLE_PAY)
 438     PaymentCoordinator&amp; paymentCoordinator() const { return *m_paymentCoordinator; }
 439     WEBCORE_EXPORT void setPaymentCoordinator(std::unique_ptr&lt;PaymentCoordinator&gt;&amp;&amp;);
 440 #endif
 441 
 442 #if ENABLE(WEB_AUTHN)
 443     AuthenticatorCoordinator&amp; authenticatorCoordinator() { return m_authenticatorCoordinator.get(); }
 444 #endif
 445 
 446 #if ENABLE(APPLICATION_MANIFEST)
 447     const Optional&lt;ApplicationManifest&gt;&amp; applicationManifest() const { return m_applicationManifest; }
 448 #endif
 449 
 450     // Notifications when the Page starts and stops being presented via a native window.
 451     WEBCORE_EXPORT void setActivityState(OptionSet&lt;ActivityState::Flag&gt;);
 452     OptionSet&lt;ActivityState::Flag&gt; activityState() const { return m_activityState; }
 453 
 454     bool isWindowActive() const;
 455     bool isVisibleAndActive() const;
 456     WEBCORE_EXPORT void setIsVisible(bool);
 457     WEBCORE_EXPORT void setIsPrerender();
 458     bool isVisible() const { return m_activityState.contains(ActivityState::IsVisible); }
 459 
 460     // Notification that this Page was moved into or out of a native window.
 461     WEBCORE_EXPORT void setIsInWindow(bool);
 462     bool isInWindow() const { return m_activityState.contains(ActivityState::IsInWindow); }
 463 
 464     void setIsClosing() { m_isClosing = true; }
 465     bool isClosing() const { return m_isClosing; }
 466 
 467     void setIsRestoringCachedPage(bool value) { m_isRestoringCachedPage = value; }
 468     bool isRestoringCachedPage() const { return m_isRestoringCachedPage; }
 469 
 470     WEBCORE_EXPORT void addActivityStateChangeObserver(ActivityStateChangeObserver&amp;);
 471     WEBCORE_EXPORT void removeActivityStateChangeObserver(ActivityStateChangeObserver&amp;);
 472 
 473     WEBCORE_EXPORT void layoutIfNeeded();
 474     WEBCORE_EXPORT void updateRendering();
 475 
 476     WEBCORE_EXPORT void suspendScriptedAnimations();
 477     WEBCORE_EXPORT void resumeScriptedAnimations();
 478     bool scriptedAnimationsSuspended() const { return m_scriptedAnimationsSuspended; }
 479 
 480     void userStyleSheetLocationChanged();
 481     const String&amp; userStyleSheet() const;
 482 
 483     WEBCORE_EXPORT void userAgentChanged();
 484 
 485     void dnsPrefetchingStateChanged();
 486     void storageBlockingStateChanged();
 487 
 488 #if ENABLE(RESOURCE_USAGE)
 489     void setResourceUsageOverlayVisible(bool);
 490 #endif
 491 
 492     void setDebugger(JSC::Debugger*);
 493     JSC::Debugger* debugger() const { return m_debugger; }
 494 
 495     WEBCORE_EXPORT void invalidateStylesForAllLinks();
 496     WEBCORE_EXPORT void invalidateStylesForLink(SharedStringHash);
 497 
 498     void invalidateInjectedStyleSheetCacheInAllFrames();
 499 
 500     StorageNamespace* sessionStorage(bool optionalCreate = true);
 501     void setSessionStorage(RefPtr&lt;StorageNamespace&gt;&amp;&amp;);
 502 
 503     bool hasCustomHTMLTokenizerTimeDelay() const;
 504     double customHTMLTokenizerTimeDelay() const;
 505 
 506     WEBCORE_EXPORT void setMemoryCacheClientCallsEnabled(bool);
 507     bool areMemoryCacheClientCallsEnabled() const { return m_areMemoryCacheClientCallsEnabled; }
 508 
 509     // Don&#39;t allow more than a certain number of frames in a page.
 510     // This seems like a reasonable upper bound, and otherwise mutually
 511     // recursive frameset pages can quickly bring the program to its knees
 512     // with exponential growth in the number of frames.
 513     static const int maxNumberOfFrames = 1000;
 514 
 515     void setEditable(bool isEditable) { m_isEditable = isEditable; }
 516     bool isEditable() { return m_isEditable; }
 517 
 518     WEBCORE_EXPORT VisibilityState visibilityState() const;
 519     WEBCORE_EXPORT void resumeAnimatingImages();
 520 
 521     void didFinishLoadingImageForElement(HTMLImageElement&amp;);
 522 
 523     WEBCORE_EXPORT void addLayoutMilestones(OptionSet&lt;LayoutMilestone&gt;);
 524     WEBCORE_EXPORT void removeLayoutMilestones(OptionSet&lt;LayoutMilestone&gt;);
 525     OptionSet&lt;LayoutMilestone&gt; requestedLayoutMilestones() const { return m_requestedLayoutMilestones; }
 526 
 527     WEBCORE_EXPORT void setHeaderHeight(int);
 528     WEBCORE_EXPORT void setFooterHeight(int);
 529 
 530     int headerHeight() const { return m_headerHeight; }
 531     int footerHeight() const { return m_footerHeight; }
 532 
 533     WEBCORE_EXPORT Color pageExtendedBackgroundColor() const;
 534 
 535     bool isCountingRelevantRepaintedObjects() const;
 536     void setIsCountingRelevantRepaintedObjects(bool isCounting) { m_isCountingRelevantRepaintedObjects = isCounting; }
 537     void startCountingRelevantRepaintedObjects();
 538     void resetRelevantPaintedObjectCounter();
 539     void addRelevantRepaintedObject(RenderObject*, const LayoutRect&amp; objectPaintRect);
 540     void addRelevantUnpaintedObject(RenderObject*, const LayoutRect&amp; objectPaintRect);
 541 
 542     WEBCORE_EXPORT void suspendActiveDOMObjectsAndAnimations();
 543     WEBCORE_EXPORT void resumeActiveDOMObjectsAndAnimations();
 544 
 545 #ifndef NDEBUG
 546     void setIsPainting(bool painting) { m_isPainting = painting; }
 547     bool isPainting() const { return m_isPainting; }
 548 #endif
 549 
 550     AlternativeTextClient* alternativeTextClient() const { return m_alternativeTextClient.get(); }
 551 
 552     bool hasSeenPlugin(const String&amp; serviceType) const;
 553     WEBCORE_EXPORT bool hasSeenAnyPlugin() const;
 554     void sawPlugin(const String&amp; serviceType);
 555     void resetSeenPlugins();
 556 
 557     bool hasSeenMediaEngine(const String&amp; engineName) const;
 558     bool hasSeenAnyMediaEngine() const;
 559     void sawMediaEngine(const String&amp; engineName);
 560     void resetSeenMediaEngines();
 561 
 562     PageConsoleClient&amp; console() { return *m_consoleClient; }
 563 
 564 #if ENABLE(REMOTE_INSPECTOR)
 565     PageDebuggable&amp; inspectorDebuggable() const { return *m_inspectorDebuggable.get(); }
 566 #endif
 567 
 568     void hiddenPageCSSAnimationSuspensionStateChanged();
 569 
 570 #if ENABLE(VIDEO_TRACK)
 571     void captionPreferencesChanged();
 572 #endif
 573 
 574     void forbidPrompts();
 575     void allowPrompts();
 576     bool arePromptsAllowed();
 577 
 578     void forbidSynchronousLoads();
 579     void allowSynchronousLoads();
 580     bool areSynchronousLoadsAllowed();
 581 
 582     void mainFrameLoadStarted(const URL&amp;, FrameLoadType);
 583 
 584     void setLastSpatialNavigationCandidateCount(unsigned count) { m_lastSpatialNavigationCandidatesCount = count; }
 585     unsigned lastSpatialNavigationCandidateCount() const { return m_lastSpatialNavigationCandidatesCount; }
 586 
 587     ApplicationCacheStorage&amp; applicationCacheStorage() { return m_applicationCacheStorage; }
 588     DatabaseProvider&amp; databaseProvider() { return m_databaseProvider; }
 589     CacheStorageProvider&amp; cacheStorageProvider() { return m_cacheStorageProvider; }
 590     SocketProvider&amp; socketProvider() { return m_socketProvider; }
 591     MediaRecorderProvider&amp; mediaRecorderProvider() { return m_mediaRecorderProvider; }
 592     CookieJar&amp; cookieJar() { return m_cookieJar.get(); }
 593 
 594     StorageNamespaceProvider&amp; storageNamespaceProvider() { return m_storageNamespaceProvider.get(); }
 595 
 596     PluginInfoProvider&amp; pluginInfoProvider();
 597 
 598     WEBCORE_EXPORT UserContentProvider&amp; userContentProvider();
 599     WEBCORE_EXPORT void setUserContentProvider(Ref&lt;UserContentProvider&gt;&amp;&amp;);
 600 
 601     VisitedLinkStore&amp; visitedLinkStore();
 602     WEBCORE_EXPORT void setVisitedLinkStore(Ref&lt;VisitedLinkStore&gt;&amp;&amp;);
 603 
 604     WEBCORE_EXPORT PAL::SessionID sessionID() const;
 605     WEBCORE_EXPORT void setSessionID(PAL::SessionID);
 606     bool usesEphemeralSession() const { return m_sessionID.isEphemeral(); }
 607 
 608     MediaProducer::MediaStateFlags mediaState() const { return m_mediaState; }
 609     void updateIsPlayingMedia(uint64_t);
 610     MediaProducer::MutedStateFlags mutedState() const { return m_mutedState; }
 611     bool isAudioMuted() const { return m_mutedState &amp; MediaProducer::AudioIsMuted; }
 612     bool isMediaCaptureMuted() const { return m_mutedState &amp; MediaProducer::MediaStreamCaptureIsMuted; };
 613     void schedulePlaybackControlsManagerUpdate();
 614     WEBCORE_EXPORT void setMuted(MediaProducer::MutedStateFlags);
 615     WEBCORE_EXPORT void stopMediaCapture();
 616 
 617     WEBCORE_EXPORT void stopAllMediaPlayback();
 618     WEBCORE_EXPORT void suspendAllMediaPlayback();
 619     WEBCORE_EXPORT void resumeAllMediaPlayback();
 620     bool mediaPlaybackIsSuspended() const { return m_mediaPlaybackIsSuspended; }
 621     WEBCORE_EXPORT void suspendAllMediaBuffering();
 622     WEBCORE_EXPORT void resumeAllMediaBuffering();
 623     bool mediaBufferingIsSuspended() const { return m_mediaBufferingIsSuspended; }
 624 
 625     void setHasResourceLoadClient(bool has) { m_hasResourceLoadClient = has; }
 626     bool hasResourceLoadClient() const { return m_hasResourceLoadClient; }
 627 
 628 #if ENABLE(MEDIA_SESSION)
 629     WEBCORE_EXPORT void handleMediaEvent(MediaEventType);
 630     WEBCORE_EXPORT void setVolumeOfMediaElement(double, uint64_t);
 631 #endif
 632 
 633 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 634     void addPlaybackTargetPickerClient(uint64_t);
 635     void removePlaybackTargetPickerClient(uint64_t);
 636     void showPlaybackTargetPicker(uint64_t, const IntPoint&amp;, bool, RouteSharingPolicy, const String&amp;);
 637     void playbackTargetPickerClientStateDidChange(uint64_t, MediaProducer::MediaStateFlags);
 638     WEBCORE_EXPORT void setMockMediaPlaybackTargetPickerEnabled(bool);
 639     WEBCORE_EXPORT void setMockMediaPlaybackTargetPickerState(const String&amp;, MediaPlaybackTargetContext::State);
 640     WEBCORE_EXPORT void mockMediaPlaybackTargetPickerDismissPopup();
 641 
 642     WEBCORE_EXPORT void setPlaybackTarget(uint64_t, Ref&lt;MediaPlaybackTarget&gt;&amp;&amp;);
 643     WEBCORE_EXPORT void playbackTargetAvailabilityDidChange(uint64_t, bool);
 644     WEBCORE_EXPORT void setShouldPlayToPlaybackTarget(uint64_t, bool);
 645     WEBCORE_EXPORT void playbackTargetPickerWasDismissed(uint64_t);
 646 #endif
 647 
 648     RefPtr&lt;WheelEventTestMonitor&gt; wheelEventTestMonitor() const { return m_wheelEventTestMonitor; }
 649     WEBCORE_EXPORT WheelEventTestMonitor&amp; ensureWheelEventTestMonitor();
 650     void clearWheelEventTestMonitor() { m_wheelEventTestMonitor = nullptr; }
 651     bool isMonitoringWheelEvents() const { return !!m_wheelEventTestMonitor; }
 652 
 653 #if ENABLE(VIDEO)
 654     bool allowsMediaDocumentInlinePlayback() const { return m_allowsMediaDocumentInlinePlayback; }
 655     WEBCORE_EXPORT void setAllowsMediaDocumentInlinePlayback(bool);
 656 #endif
 657 
 658     bool allowsPlaybackControlsForAutoplayingAudio() const { return m_allowsPlaybackControlsForAutoplayingAudio; }
 659     void setAllowsPlaybackControlsForAutoplayingAudio(bool allowsPlaybackControlsForAutoplayingAudio) { m_allowsPlaybackControlsForAutoplayingAudio = allowsPlaybackControlsForAutoplayingAudio; }
 660 
 661 #if ENABLE(INDEXED_DATABASE)
 662     IDBClient::IDBConnectionToServer&amp; idbConnection();
 663     WEBCORE_EXPORT IDBClient::IDBConnectionToServer* optionalIDBConnection();
 664     WEBCORE_EXPORT void clearIDBConnection();
 665 #endif
 666 
 667     void setShowAllPlugins(bool showAll) { m_showAllPlugins = showAll; }
 668     bool showAllPlugins() const;
 669 
 670     WEBCORE_EXPORT void setDOMTimerAlignmentIntervalIncreaseLimit(Seconds);
 671 
 672     bool isControlledByAutomation() const { return m_controlledByAutomation; }
 673     void setControlledByAutomation(bool controlled) { m_controlledByAutomation = controlled; }
 674 
 675     WEBCORE_EXPORT bool isAlwaysOnLoggingAllowed() const;
 676 
 677     String captionUserPreferencesStyleSheet();
 678     void setCaptionUserPreferencesStyleSheet(const String&amp;);
 679 
 680     bool isResourceCachingDisabledByWebInspector() const { return m_resourceCachingDisabledByWebInspector; }
 681     void setResourceCachingDisabledByWebInspector(bool disabled) { m_resourceCachingDisabledByWebInspector = disabled; }
 682 
 683     Optional&lt;EventThrottlingBehavior&gt; eventThrottlingBehaviorOverride() const { return m_eventThrottlingBehaviorOverride; }
 684     void setEventThrottlingBehaviorOverride(Optional&lt;EventThrottlingBehavior&gt; throttling) { m_eventThrottlingBehaviorOverride = throttling; }
 685 
 686     Optional&lt;CompositingPolicy&gt; compositingPolicyOverride() const { return m_compositingPolicyOverride; }
 687     void setCompositingPolicyOverride(Optional&lt;CompositingPolicy&gt; policy) { m_compositingPolicyOverride = policy; }
 688 
 689 #if ENABLE(WEBGL)
 690     WebGLStateTracker* webGLStateTracker() const { return m_webGLStateTracker.get(); }
 691 #endif
 692 
 693 #if ENABLE(SPEECH_SYNTHESIS)
 694     SpeechSynthesisClient* speechSynthesisClient() const { return m_speechSynthesisClient.get(); }
 695 #endif
 696 
 697     bool isOnlyNonUtilityPage() const;
 698     bool isUtilityPage() const { return m_isUtilityPage; }
 699 
 700     bool isLowPowerModeEnabled() const;
 701     WEBCORE_EXPORT void setLowPowerModeEnabledOverrideForTesting(Optional&lt;bool&gt;);
 702 
 703     WEBCORE_EXPORT void applicationWillResignActive();
 704     WEBCORE_EXPORT void applicationDidEnterBackground();
 705     WEBCORE_EXPORT void applicationWillEnterForeground();
 706     WEBCORE_EXPORT void applicationDidBecomeActive();
 707 
 708     PerformanceLogging&amp; performanceLogging() const { return *m_performanceLogging; }
 709 
 710     void configureLoggingChannel(const String&amp;, WTFLogChannelState, WTFLogLevel);
 711 
 712     WEBCORE_EXPORT Vector&lt;Ref&lt;Element&gt;&gt; editableElementsInRect(const FloatRect&amp;) const;
 713 
 714 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
 715     DeviceOrientationUpdateProvider* deviceOrientationUpdateProvider() const { return m_deviceOrientationUpdateProvider.get(); }
 716 #endif
 717 
 718     WEBCORE_EXPORT void forEachDocument(const WTF::Function&lt;void(Document&amp;)&gt;&amp;) const;
 719     void forEachMediaElement(const WTF::Function&lt;void(HTMLMediaElement&amp;)&gt;&amp;);
 720 
 721     bool shouldDisableCorsForRequestTo(const URL&amp;) const;
 722 
 723 private:
 724     struct Navigation {
 725         RegistrableDomain domain;
 726         FrameLoadType type;
 727     };
 728     void logNavigation(const Navigation&amp;);
 729 
 730     WEBCORE_EXPORT void initGroup();
 731 
 732     void setIsInWindowInternal(bool);
 733     void setIsVisibleInternal(bool);
 734     void setIsVisuallyIdleInternal(bool);
 735 
 736     void checkSubframeCountConsistency() const;
 737 
 738     enum ShouldHighlightMatches { DoNotHighlightMatches, HighlightMatches };
 739     enum ShouldMarkMatches { DoNotMarkMatches, MarkMatches };
 740 
 741     unsigned findMatchesForText(const String&amp;, FindOptions, unsigned maxMatchCount, ShouldHighlightMatches, ShouldMarkMatches);
 742 
 743     Optional&lt;std::pair&lt;MediaCanStartListener&amp;, Document&amp;&gt;&gt; takeAnyMediaCanStartListener();
 744 
 745 #if ENABLE(VIDEO)
 746     void playbackControlsManagerUpdateTimerFired();
 747 #endif
 748 
 749     Vector&lt;Ref&lt;PluginViewBase&gt;&gt; pluginViews();
 750 
 751     void handleLowModePowerChange(bool);
 752 
 753     enum class TimerThrottlingState { Disabled, Enabled, EnabledIncreasing };
 754     void hiddenPageDOMTimerThrottlingStateChanged();
 755     void setTimerThrottlingState(TimerThrottlingState);
 756     void updateTimerThrottlingState();
 757     void updateDOMTimerAlignmentInterval();
 758     void domTimerAlignmentIntervalIncreaseTimerFired();
 759 
 760     const std::unique_ptr&lt;Chrome&gt; m_chrome;
 761     const std::unique_ptr&lt;DragCaretController&gt; m_dragCaretController;
 762 
 763 #if ENABLE(DRAG_SUPPORT)
 764     const std::unique_ptr&lt;DragController&gt; m_dragController;
 765 #endif
 766     const std::unique_ptr&lt;FocusController&gt; m_focusController;
 767 #if ENABLE(CONTEXT_MENUS)
 768     const std::unique_ptr&lt;ContextMenuController&gt; m_contextMenuController;
 769 #endif
 770     const std::unique_ptr&lt;UserInputBridge&gt; m_userInputBridge;
 771     const std::unique_ptr&lt;InspectorController&gt; m_inspectorController;
 772 #if ENABLE(POINTER_EVENTS)
 773     const std::unique_ptr&lt;PointerCaptureController&gt; m_pointerCaptureController;
 774 #endif
 775 #if ENABLE(POINTER_LOCK)
 776     const std::unique_ptr&lt;PointerLockController&gt; m_pointerLockController;
 777 #endif
 778     RefPtr&lt;ScrollingCoordinator&gt; m_scrollingCoordinator;
 779 
 780     const RefPtr&lt;Settings&gt; m_settings;
 781     const std::unique_ptr&lt;ProgressTracker&gt; m_progress;
 782 
 783     const std::unique_ptr&lt;BackForwardController&gt; m_backForwardController;
 784     Ref&lt;Frame&gt; m_mainFrame;
 785 
 786     RefPtr&lt;PluginData&gt; m_pluginData;
 787 
 788     UniqueRef&lt;EditorClient&gt; m_editorClient;
 789     std::unique_ptr&lt;PlugInClient&gt; m_plugInClient;
 790     std::unique_ptr&lt;ValidationMessageClient&gt; m_validationMessageClient;
 791     std::unique_ptr&lt;DiagnosticLoggingClient&gt; m_diagnosticLoggingClient;
 792     std::unique_ptr&lt;PerformanceLoggingClient&gt; m_performanceLoggingClient;
 793 
 794 #if ENABLE(WEBGL)
 795     std::unique_ptr&lt;WebGLStateTracker&gt; m_webGLStateTracker;
 796 #endif
 797 
 798 #if ENABLE(SPEECH_SYNTHESIS)
 799     std::unique_ptr&lt;SpeechSynthesisClient&gt; m_speechSynthesisClient;
 800 #endif
 801 
 802     UniqueRef&lt;MediaRecorderProvider&gt; m_mediaRecorderProvider;
 803     UniqueRef&lt;LibWebRTCProvider&gt; m_libWebRTCProvider;
 804     RTCController m_rtcController;
 805 
 806     int m_nestedRunLoopCount { 0 };
 807     WTF::Function&lt;void()&gt; m_unnestCallback;
 808 
 809     int m_subframeCount { 0 };
 810     String m_groupName;
 811     bool m_openedByDOM { false };
 812     bool m_openedByDOMWithOpener { false };
 813 
 814     bool m_tabKeyCyclesThroughElements { true };
 815     bool m_defersLoading { false };
 816     unsigned m_defersLoadingCallCount { 0 };
 817 
 818     bool m_inLowQualityInterpolationMode { false };
 819     bool m_areMemoryCacheClientCallsEnabled { true };
 820     float m_mediaVolume { 1 };
 821     MediaProducer::MutedStateFlags m_mutedState { MediaProducer::NoneMuted };
 822 
 823     float m_pageScaleFactor { 1 };
 824     float m_zoomedOutPageScaleFactor { 0 };
 825     float m_deviceScaleFactor { 1 };
 826     float m_viewScaleFactor { 1 };
 827 
 828     float m_topContentInset { 0 };
 829     FloatBoxExtent m_obscuredInsets;
 830     FloatBoxExtent m_contentInsets;
 831     FloatBoxExtent m_unobscuredSafeAreaInsets;
 832     FloatBoxExtent m_fullscreenInsets;
 833     Seconds m_fullscreenAutoHideDuration { 0_s };
 834 
 835 #if PLATFORM(IOS_FAMILY)
 836     bool m_enclosedInScrollableAncestorView { false };
 837 #endif
 838 
 839     bool m_useSystemAppearance { false };
 840     bool m_useElevatedUserInterfaceLevel { false };
 841     bool m_useDarkAppearance { false };
 842     Optional&lt;bool&gt; m_useDarkAppearanceOverride;
 843 
 844 #if ENABLE(TEXT_AUTOSIZING)
 845     float m_textAutosizingWidth { 0 };
 846 #endif
 847     float m_initialScale { 1.0f };
 848 
 849     bool m_suppressScrollbarAnimations { false };
 850 
 851     unsigned m_verticalScrollElasticity : 2; // ScrollElasticity
 852     unsigned m_horizontalScrollElasticity : 2; // ScrollElasticity
 853 
 854     Pagination m_pagination;
 855     bool m_paginationLineGridEnabled { false };
 856 
 857     String m_userStyleSheetPath;
 858     mutable String m_userStyleSheet;
 859     mutable bool m_didLoadUserStyleSheet { false };
 860     mutable Optional&lt;WallTime&gt; m_userStyleSheetModificationTime;
 861 
 862     String m_captionUserPreferencesStyleSheet;
 863 
 864     std::unique_ptr&lt;PageGroup&gt; m_singlePageGroup;
 865     PageGroup* m_group { nullptr };
 866 
 867     JSC::Debugger* m_debugger { nullptr };
 868 
 869     bool m_canStartMedia { true };
 870 
 871     RefPtr&lt;StorageNamespace&gt; m_sessionStorage;
 872 
 873     TimerThrottlingState m_timerThrottlingState { TimerThrottlingState::Disabled };
 874     MonotonicTime m_timerThrottlingStateLastChangedTime;
 875     Seconds m_domTimerAlignmentInterval;
 876     Timer m_domTimerAlignmentIntervalIncreaseTimer;
 877     Seconds m_domTimerAlignmentIntervalIncreaseLimit;
 878 
 879     bool m_isEditable { false };
 880     bool m_isPrerender { false };
 881     OptionSet&lt;ActivityState::Flag&gt; m_activityState;
 882 
 883     OptionSet&lt;LayoutMilestone&gt; m_requestedLayoutMilestones;
 884 
 885     int m_headerHeight { 0 };
 886     int m_footerHeight { 0 };
 887 
 888     std::unique_ptr&lt;RenderingUpdateScheduler&gt; m_renderingUpdateScheduler;
 889 
 890     HashSet&lt;RenderObject*&gt; m_relevantUnpaintedRenderObjects;
 891     Region m_topRelevantPaintedRegion;
 892     Region m_bottomRelevantPaintedRegion;
 893     Region m_relevantUnpaintedRegion;
 894     bool m_isCountingRelevantRepaintedObjects { false };
 895 #ifndef NDEBUG
 896     bool m_isPainting { false };
 897 #endif
 898     std::unique_ptr&lt;AlternativeTextClient&gt; m_alternativeTextClient;
 899 
 900     bool m_scriptedAnimationsSuspended { false };
 901     const std::unique_ptr&lt;PageConsoleClient&gt; m_consoleClient;
 902 
 903 #if ENABLE(REMOTE_INSPECTOR)
 904     const std::unique_ptr&lt;PageDebuggable&gt; m_inspectorDebuggable;
 905 #endif
 906 
 907 #if ENABLE(INDEXED_DATABASE)
 908     RefPtr&lt;IDBClient::IDBConnectionToServer&gt; m_idbConnectionToServer;
 909 #endif
 910 
 911     HashSet&lt;String&gt; m_seenPlugins;
 912     HashSet&lt;String&gt; m_seenMediaEngines;
 913 
 914     unsigned m_lastSpatialNavigationCandidatesCount { 0 };
 915     unsigned m_forbidPromptsDepth { 0 };
 916     unsigned m_forbidSynchronousLoadsDepth { 0 };
 917 
 918     Ref&lt;SocketProvider&gt; m_socketProvider;
 919     Ref&lt;CookieJar&gt; m_cookieJar;
 920     Ref&lt;ApplicationCacheStorage&gt; m_applicationCacheStorage;
 921     Ref&lt;CacheStorageProvider&gt; m_cacheStorageProvider;
 922     Ref&lt;DatabaseProvider&gt; m_databaseProvider;
 923     Ref&lt;PluginInfoProvider&gt; m_pluginInfoProvider;
 924     Ref&lt;StorageNamespaceProvider&gt; m_storageNamespaceProvider;
 925     Ref&lt;UserContentProvider&gt; m_userContentProvider;
 926     Ref&lt;VisitedLinkStore&gt; m_visitedLinkStore;
 927     RefPtr&lt;WheelEventTestMonitor&gt; m_wheelEventTestMonitor;
 928     HashSet&lt;ActivityStateChangeObserver*&gt; m_activityStateChangeObservers;
 929 
 930 #if ENABLE(RESOURCE_USAGE)
 931     std::unique_ptr&lt;ResourceUsageOverlay&gt; m_resourceUsageOverlay;
 932 #endif
 933 
 934     PAL::SessionID m_sessionID;
 935 
 936     bool m_isClosing { false };
 937     bool m_isRestoringCachedPage { false };
 938 
 939     MediaProducer::MediaStateFlags m_mediaState { MediaProducer::IsNotPlaying };
 940 
 941 #if ENABLE(VIDEO)
 942     Timer m_playbackControlsManagerUpdateTimer;
 943 #endif
 944 
 945     bool m_allowsMediaDocumentInlinePlayback { false };
 946     bool m_allowsPlaybackControlsForAutoplayingAudio { false };
 947     bool m_showAllPlugins { false };
 948     bool m_controlledByAutomation { false };
 949     bool m_resourceCachingDisabledByWebInspector { false };
 950     bool m_isUtilityPage;
 951     bool m_shouldEnableICECandidateFilteringByDefault { true };
 952     bool m_mediaPlaybackIsSuspended { false };
 953     bool m_mediaBufferingIsSuspended { false };
 954     bool m_inUpdateRendering { false };
 955     bool m_hasResourceLoadClient { false };
 956     bool m_delegatesScaling { false };
 957 
 958     UserInterfaceLayoutDirection m_userInterfaceLayoutDirection { UserInterfaceLayoutDirection::LTR };
 959 
 960     // For testing.
 961     Optional&lt;EventThrottlingBehavior&gt; m_eventThrottlingBehaviorOverride;
 962     Optional&lt;CompositingPolicy&gt; m_compositingPolicyOverride;
 963 
 964     std::unique_ptr&lt;PerformanceMonitor&gt; m_performanceMonitor;
 965     std::unique_ptr&lt;LowPowerModeNotifier&gt; m_lowPowerModeNotifier;
 966     Optional&lt;bool&gt; m_lowPowerModeEnabledOverrideForTesting;
 967 
 968     Optional&lt;Navigation&gt; m_navigationToLogWhenVisible;
 969 
 970     std::unique_ptr&lt;PerformanceLogging&gt; m_performanceLogging;
 971 #if PLATFORM(MAC)
 972     Vector&lt;ScrollLatchingState&gt; m_latchingState;
 973 #endif
 974 #if PLATFORM(MAC) &amp;&amp; (ENABLE(SERVICE_CONTROLS) || ENABLE(TELEPHONE_NUMBER_DETECTION))
 975     std::unique_ptr&lt;ServicesOverlayController&gt; m_servicesOverlayController;
 976 #endif
 977 
 978     std::unique_ptr&lt;WheelEventDeltaFilter&gt; m_recentWheelEventDeltaFilter;
 979     std::unique_ptr&lt;PageOverlayController&gt; m_pageOverlayController;
 980 
 981 #if ENABLE(APPLE_PAY)
 982     std::unique_ptr&lt;PaymentCoordinator&gt; m_paymentCoordinator;
 983 #endif
 984 
 985 #if ENABLE(WEB_AUTHN)
 986     UniqueRef&lt;AuthenticatorCoordinator&gt; m_authenticatorCoordinator;
 987 #endif
 988 
 989 #if ENABLE(APPLICATION_MANIFEST)
 990     Optional&lt;ApplicationManifest&gt; m_applicationManifest;
 991 #endif
 992 
 993     Optional&lt;ViewportArguments&gt; m_overrideViewportArguments;
 994 
 995 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
 996     RefPtr&lt;DeviceOrientationUpdateProvider&gt; m_deviceOrientationUpdateProvider;
 997 #endif
 998 
 999     Vector&lt;UserContentURLPattern&gt; m_corsDisablingPatterns;
1000 };
1001 
1002 inline PageGroup&amp; Page::group()
1003 {
1004     if (!m_group)
1005         initGroup();
1006     return *m_group;
1007 }
1008 
1009 #if !ASSERT_ENABLED
1010 
1011 inline void Page::checkSubframeCountConsistency() const
1012 {
1013 }
1014 
1015 #endif // !ASSERT_ENABLED
1016 
1017 } // namespace WebCore
    </pre>
  </body>
</html>
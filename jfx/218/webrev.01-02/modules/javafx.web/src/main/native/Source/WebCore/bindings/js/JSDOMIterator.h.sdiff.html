<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMIterator.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDOMIterator.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMMapLike.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMIterator.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY CANON INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CANON INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;JSDOMConvert.h&quot;
 30 #include &lt;JavaScriptCore/IteratorPrototype.h&gt;

 31 #include &lt;type_traits&gt;
 32 
 33 namespace WebCore {
 34 
 35 void addValueIterableMethods(JSC::JSGlobalObject&amp;, JSC::JSObject&amp;);
 36 
 37 enum class JSDOMIteratorType { Set, Map };
 38 
 39 // struct IteratorTraits {
 40 //     static constexpr JSDOMIteratorType type = [Map|Set];
 41 //     using KeyType = [IDLType|void];
 42 //     using ValueType = [IDLType];
 43 // };
 44 
 45 template&lt;typename T, typename U = void&gt; using EnableIfMap = typename std::enable_if&lt;T::type == JSDOMIteratorType::Map, U&gt;::type;
 46 template&lt;typename T, typename U = void&gt; using EnableIfSet = typename std::enable_if&lt;T::type == JSDOMIteratorType::Set, U&gt;::type;
 47 
<span class="line-modified"> 48 template&lt;typename JSWrapper, typename IteratorTraits&gt; class JSDOMIteratorPrototype : public JSC::JSNonFinalObject {</span>
 49 public:
 50     using Base = JSC::JSNonFinalObject;
 51     using DOMWrapped = typename JSWrapper::DOMWrapped;
 52 
 53     static JSDOMIteratorPrototype* create(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
 54     {

 55         JSDOMIteratorPrototype* prototype = new (NotNull, JSC::allocateCell&lt;JSDOMIteratorPrototype&gt;(vm.heap)) JSDOMIteratorPrototype(vm, structure);
 56         prototype-&gt;finishCreation(vm, globalObject);
 57         return prototype;
 58     }
 59 
 60     DECLARE_INFO;
 61 
 62     static JSC::Structure* createStructure(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
 63     {
 64         return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
 65     }
 66 
<span class="line-modified"> 67     static JSC::EncodedJSValue JSC_HOST_CALL next(JSC::ExecState*);</span>
 68 
 69 private:
 70     JSDOMIteratorPrototype(JSC::VM&amp; vm, JSC::Structure* structure) : Base(vm, structure) { }
 71 
 72     void finishCreation(JSC::VM&amp;, JSC::JSGlobalObject*);
 73 };
 74 
<span class="line-modified"> 75 enum class IterationKind { Key, Value, KeyValue };</span>
 76 
 77 template&lt;typename JSWrapper, typename IteratorTraits&gt; class JSDOMIterator : public JSDOMObject {
 78 public:
 79     using Base = JSDOMObject;
 80 
 81     using Wrapper = JSWrapper;
 82     using Traits = IteratorTraits;
 83 
 84     using DOMWrapped = typename Wrapper::DOMWrapped;
 85     using Prototype = JSDOMIteratorPrototype&lt;Wrapper, Traits&gt;;
 86 
 87     DECLARE_INFO;
 88 
 89     static JSC::Structure* createStructure(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
 90     {
 91         return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
 92     }
 93 
 94     static JSDOMIterator* create(JSC::VM&amp; vm, JSC::Structure* structure, JSWrapper&amp; iteratedObject, IterationKind kind)
 95     {
 96         JSDOMIterator* instance = new (NotNull, JSC::allocateCell&lt;JSDOMIterator&gt;(vm.heap)) JSDOMIterator(structure, iteratedObject, kind);
 97         instance-&gt;finishCreation(vm);
 98         return instance;
 99     }
100 
101     static Prototype* createPrototype(JSC::VM&amp; vm, JSC::JSGlobalObject&amp; globalObject)
102     {
103         return Prototype::create(vm, &amp;globalObject, Prototype::createStructure(vm, &amp;globalObject, globalObject.iteratorPrototype()));
104     }
105 
<span class="line-modified">106     JSC::JSValue next(JSC::ExecState&amp;);</span>
107 
108 private:
109     JSDOMIterator(JSC::Structure* structure, JSWrapper&amp; iteratedObject, IterationKind kind)
110         : Base(structure, *iteratedObject.globalObject())
111         , m_iterator(iteratedObject.wrapped().createIterator())
112         , m_kind(kind)
113     {
114     }
115 
<span class="line-modified">116     template&lt;typename IteratorValue, typename T = Traits&gt; EnableIfMap&lt;T, JSC::JSValue&gt; asJS(JSC::ExecState&amp;, IteratorValue&amp;);</span>
<span class="line-modified">117     template&lt;typename IteratorValue, typename T = Traits&gt; EnableIfSet&lt;T, JSC::JSValue&gt; asJS(JSC::ExecState&amp;, IteratorValue&amp;);</span>
118 
119     static void destroy(JSC::JSCell*);
120 
121     Optional&lt;typename DOMWrapped::Iterator&gt; m_iterator;
122     IterationKind m_kind;
123 };
124 
<span class="line-modified">125 inline JSC::JSValue jsPair(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, JSC::JSValue value1, JSC::JSValue value2)</span>
126 {
127     JSC::MarkedArgumentBuffer arguments;
128     arguments.append(value1);
129     arguments.append(value2);
130     ASSERT(!arguments.hasOverflowed());
<span class="line-modified">131     return constructArray(&amp;state, nullptr, &amp;globalObject, arguments);</span>
132 }
133 
134 template&lt;typename FirstType, typename SecondType, typename T, typename U&gt;
<span class="line-modified">135 inline JSC::JSValue jsPair(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, const T&amp; value1, const U&amp; value2)</span>
136 {
<span class="line-modified">137     return jsPair(state, globalObject, toJS&lt;FirstType&gt;(state, globalObject, value1), toJS&lt;SecondType&gt;(state, globalObject, value2));</span>
138 }
139 
140 template&lt;typename JSIterator&gt; JSC::JSValue iteratorCreate(typename JSIterator::Wrapper&amp;, IterationKind);
<span class="line-modified">141 template&lt;typename JSIterator&gt; JSC::JSValue iteratorForEach(JSC::ExecState&amp;, typename JSIterator::Wrapper&amp;, JSC::ThrowScope&amp;);</span>
142 
143 template&lt;typename JSIterator&gt; JSC::JSValue iteratorCreate(typename JSIterator::Wrapper&amp; thisObject, IterationKind kind)
144 {
145     ASSERT(thisObject.globalObject());
146     JSDOMGlobalObject&amp; globalObject = *thisObject.globalObject();
147     return JSIterator::create(globalObject.vm(), getDOMStructure&lt;JSIterator&gt;(globalObject.vm(), globalObject), thisObject, kind);
148 }
149 
150 template&lt;typename JSWrapper, typename IteratorTraits&gt;
<span class="line-modified">151 template&lt;typename IteratorValue, typename T&gt; inline EnableIfMap&lt;T, JSC::JSValue&gt; JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;::asJS(JSC::ExecState&amp; state, IteratorValue&amp; value)</span>
152 {
153     ASSERT(value);
154 
155     switch (m_kind) {
<span class="line-modified">156     case IterationKind::Key:</span>
<span class="line-modified">157         return toJS&lt;typename Traits::KeyType&gt;(state, *globalObject(), value-&gt;key);</span>
<span class="line-modified">158     case IterationKind::Value:</span>
<span class="line-modified">159         return toJS&lt;typename Traits::ValueType&gt;(state, *globalObject(), value-&gt;value);</span>
<span class="line-modified">160     case IterationKind::KeyValue:</span>
<span class="line-modified">161         return jsPair&lt;typename Traits::KeyType, typename Traits::ValueType&gt;(state, *globalObject(), value-&gt;key, value-&gt;value);</span>
162     };
163 
164     ASSERT_NOT_REACHED();
165     return { };
166 }
167 
168 template&lt;typename JSWrapper, typename IteratorTraits&gt;
<span class="line-modified">169 template&lt;typename IteratorValue, typename T&gt; inline EnableIfSet&lt;T, JSC::JSValue&gt; JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;::asJS(JSC::ExecState&amp; state, IteratorValue&amp; value)</span>
170 {
171     ASSERT(value);
172 
173     auto globalObject = this-&gt;globalObject();
<span class="line-modified">174     auto result = toJS&lt;typename Traits::ValueType&gt;(state, *globalObject, value);</span>
175 
176     switch (m_kind) {
<span class="line-modified">177     case IterationKind::Key:</span>
<span class="line-modified">178     case IterationKind::Value:</span>
179         return result;
<span class="line-modified">180     case IterationKind::KeyValue:</span>
<span class="line-modified">181         return jsPair(state, *globalObject, result, result);</span>
182     };
183 
184     ASSERT_NOT_REACHED();
185     return { };
186 }
187 
<span class="line-modified">188 template&lt;typename JSIterator, typename IteratorValue&gt; EnableIfMap&lt;typename JSIterator::Traits&gt; appendForEachArguments(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, JSC::MarkedArgumentBuffer&amp; arguments, IteratorValue&amp; value)</span>
189 {
190     ASSERT(value);
<span class="line-modified">191     arguments.append(toJS&lt;typename JSIterator::Traits::ValueType&gt;(state, globalObject, value-&gt;value));</span>
<span class="line-modified">192     arguments.append(toJS&lt;typename JSIterator::Traits::KeyType&gt;(state, globalObject, value-&gt;key));</span>
193 }
194 
<span class="line-modified">195 template&lt;typename JSIterator, typename IteratorValue&gt; EnableIfSet&lt;typename JSIterator::Traits&gt; appendForEachArguments(JSC::ExecState&amp; state, JSDOMGlobalObject&amp; globalObject, JSC::MarkedArgumentBuffer&amp; arguments, IteratorValue&amp; value)</span>
196 {
197     ASSERT(value);
<span class="line-modified">198     auto argument = toJS&lt;typename JSIterator::Traits::ValueType&gt;(state, globalObject, value);</span>
199     arguments.append(argument);
200     arguments.append(argument);
201 }
202 
<span class="line-modified">203 template&lt;typename JSIterator&gt; JSC::JSValue iteratorForEach(JSC::ExecState&amp; state, typename JSIterator::Wrapper&amp; thisObject, JSC::ThrowScope&amp; scope)</span>
204 {
<span class="line-modified">205     JSC::JSValue callback = state.argument(0);</span>
<span class="line-modified">206     JSC::JSValue thisValue = state.argument(1);</span>
207 
208     JSC::CallData callData;
<span class="line-modified">209     JSC::CallType callType = JSC::getCallData(state.vm(), callback, callData);</span>
210     if (callType == JSC::CallType::None)
<span class="line-modified">211         return throwTypeError(&amp;state, scope, &quot;Cannot call callback&quot;_s);</span>
212 
213     auto iterator = thisObject.wrapped().createIterator();
214     while (auto value = iterator.next()) {
215         JSC::MarkedArgumentBuffer arguments;
<span class="line-modified">216         appendForEachArguments&lt;JSIterator&gt;(state, *thisObject.globalObject(), arguments, value);</span>
217         arguments.append(&amp;thisObject);
218         if (UNLIKELY(arguments.hasOverflowed())) {
<span class="line-modified">219             throwOutOfMemoryError(&amp;state, scope);</span>
220             return { };
221         }
<span class="line-modified">222         JSC::call(&amp;state, callback, callType, callData, thisValue, arguments);</span>
223         if (UNLIKELY(scope.exception()))
224             break;
225     }
226     return JSC::jsUndefined();
227 }
228 
229 template&lt;typename JSWrapper, typename IteratorTraits&gt;
230 void JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;::destroy(JSCell* cell)
231 {
232     JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;* thisObject = static_cast&lt;JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;*&gt;(cell);
233     thisObject-&gt;JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;::~JSDOMIterator();
234 }
235 
236 template&lt;typename JSWrapper, typename IteratorTraits&gt;
<span class="line-modified">237 JSC::JSValue JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;::next(JSC::ExecState&amp; state)</span>
238 {
239     if (m_iterator) {
240         auto iteratorValue = m_iterator-&gt;next();
241         if (iteratorValue)
<span class="line-modified">242             return createIteratorResultObject(&amp;state, asJS(state, iteratorValue), false);</span>
243         m_iterator = WTF::nullopt;
244     }
<span class="line-modified">245     return createIteratorResultObject(&amp;state, JSC::jsUndefined(), true);</span>
246 }
247 
248 template&lt;typename JSWrapper, typename IteratorTraits&gt;
<span class="line-modified">249 JSC::EncodedJSValue JSC_HOST_CALL JSDOMIteratorPrototype&lt;JSWrapper, IteratorTraits&gt;::next(JSC::ExecState* state)</span>
250 {
<span class="line-modified">251     JSC::VM&amp; vm = state-&gt;vm();</span>
252     auto scope = DECLARE_THROW_SCOPE(vm);
253 
<span class="line-modified">254     auto iterator = JSC::jsDynamicCast&lt;JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;*&gt;(vm, state-&gt;thisValue());</span>
255     if (!iterator)
<span class="line-modified">256         return JSC::JSValue::encode(throwTypeError(state, scope, &quot;Cannot call next() on a non-Iterator object&quot;_s));</span>
257 
<span class="line-modified">258     return JSC::JSValue::encode(iterator-&gt;next(*state));</span>
259 }
260 
261 template&lt;typename JSWrapper, typename IteratorTraits&gt;
262 void JSDOMIteratorPrototype&lt;JSWrapper, IteratorTraits&gt;::finishCreation(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject)
263 {
264     Base::finishCreation(vm);
265     ASSERT(inherits(vm, info()));
266 

267     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;next, next, 0, 0, JSC::NoIntrinsic);
268 }
269 
270 }
</pre>
</td>
<td>
<hr />
<pre>
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY CANON INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CANON INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;JSDOMConvert.h&quot;
 30 #include &lt;JavaScriptCore/IteratorPrototype.h&gt;
<span class="line-added"> 31 #include &lt;JavaScriptCore/PropertySlot.h&gt;</span>
 32 #include &lt;type_traits&gt;
 33 
 34 namespace WebCore {
 35 
 36 void addValueIterableMethods(JSC::JSGlobalObject&amp;, JSC::JSObject&amp;);
 37 
 38 enum class JSDOMIteratorType { Set, Map };
 39 
 40 // struct IteratorTraits {
 41 //     static constexpr JSDOMIteratorType type = [Map|Set];
 42 //     using KeyType = [IDLType|void];
 43 //     using ValueType = [IDLType];
 44 // };
 45 
 46 template&lt;typename T, typename U = void&gt; using EnableIfMap = typename std::enable_if&lt;T::type == JSDOMIteratorType::Map, U&gt;::type;
 47 template&lt;typename T, typename U = void&gt; using EnableIfSet = typename std::enable_if&lt;T::type == JSDOMIteratorType::Set, U&gt;::type;
 48 
<span class="line-modified"> 49 template&lt;typename JSWrapper, typename IteratorTraits&gt; class JSDOMIteratorPrototype final : public JSC::JSNonFinalObject {</span>
 50 public:
 51     using Base = JSC::JSNonFinalObject;
 52     using DOMWrapped = typename JSWrapper::DOMWrapped;
 53 
 54     static JSDOMIteratorPrototype* create(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
 55     {
<span class="line-added"> 56         STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSDOMIteratorPrototype, JSDOMIteratorPrototype::Base);</span>
 57         JSDOMIteratorPrototype* prototype = new (NotNull, JSC::allocateCell&lt;JSDOMIteratorPrototype&gt;(vm.heap)) JSDOMIteratorPrototype(vm, structure);
 58         prototype-&gt;finishCreation(vm, globalObject);
 59         return prototype;
 60     }
 61 
 62     DECLARE_INFO;
 63 
 64     static JSC::Structure* createStructure(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
 65     {
 66         return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
 67     }
 68 
<span class="line-modified"> 69     static JSC::EncodedJSValue JSC_HOST_CALL next(JSC::JSGlobalObject*, JSC::CallFrame*);</span>
 70 
 71 private:
 72     JSDOMIteratorPrototype(JSC::VM&amp; vm, JSC::Structure* structure) : Base(vm, structure) { }
 73 
 74     void finishCreation(JSC::VM&amp;, JSC::JSGlobalObject*);
 75 };
 76 
<span class="line-modified"> 77 using IterationKind = JSC::IterationKind;</span>
 78 
 79 template&lt;typename JSWrapper, typename IteratorTraits&gt; class JSDOMIterator : public JSDOMObject {
 80 public:
 81     using Base = JSDOMObject;
 82 
 83     using Wrapper = JSWrapper;
 84     using Traits = IteratorTraits;
 85 
 86     using DOMWrapped = typename Wrapper::DOMWrapped;
 87     using Prototype = JSDOMIteratorPrototype&lt;Wrapper, Traits&gt;;
 88 
 89     DECLARE_INFO;
 90 
 91     static JSC::Structure* createStructure(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
 92     {
 93         return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
 94     }
 95 
 96     static JSDOMIterator* create(JSC::VM&amp; vm, JSC::Structure* structure, JSWrapper&amp; iteratedObject, IterationKind kind)
 97     {
 98         JSDOMIterator* instance = new (NotNull, JSC::allocateCell&lt;JSDOMIterator&gt;(vm.heap)) JSDOMIterator(structure, iteratedObject, kind);
 99         instance-&gt;finishCreation(vm);
100         return instance;
101     }
102 
103     static Prototype* createPrototype(JSC::VM&amp; vm, JSC::JSGlobalObject&amp; globalObject)
104     {
105         return Prototype::create(vm, &amp;globalObject, Prototype::createStructure(vm, &amp;globalObject, globalObject.iteratorPrototype()));
106     }
107 
<span class="line-modified">108     JSC::JSValue next(JSC::JSGlobalObject&amp;);</span>
109 
110 private:
111     JSDOMIterator(JSC::Structure* structure, JSWrapper&amp; iteratedObject, IterationKind kind)
112         : Base(structure, *iteratedObject.globalObject())
113         , m_iterator(iteratedObject.wrapped().createIterator())
114         , m_kind(kind)
115     {
116     }
117 
<span class="line-modified">118     template&lt;typename IteratorValue, typename T = Traits&gt; EnableIfMap&lt;T, JSC::JSValue&gt; asJS(JSC::JSGlobalObject&amp;, IteratorValue&amp;);</span>
<span class="line-modified">119     template&lt;typename IteratorValue, typename T = Traits&gt; EnableIfSet&lt;T, JSC::JSValue&gt; asJS(JSC::JSGlobalObject&amp;, IteratorValue&amp;);</span>
120 
121     static void destroy(JSC::JSCell*);
122 
123     Optional&lt;typename DOMWrapped::Iterator&gt; m_iterator;
124     IterationKind m_kind;
125 };
126 
<span class="line-modified">127 inline JSC::JSValue jsPair(JSC::JSGlobalObject&amp;, JSDOMGlobalObject&amp; globalObject, JSC::JSValue value1, JSC::JSValue value2)</span>
128 {
129     JSC::MarkedArgumentBuffer arguments;
130     arguments.append(value1);
131     arguments.append(value2);
132     ASSERT(!arguments.hasOverflowed());
<span class="line-modified">133     return constructArray(&amp;globalObject, static_cast&lt;JSC::ArrayAllocationProfile*&gt;(nullptr), arguments);</span>
134 }
135 
136 template&lt;typename FirstType, typename SecondType, typename T, typename U&gt;
<span class="line-modified">137 inline JSC::JSValue jsPair(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const T&amp; value1, const U&amp; value2)</span>
138 {
<span class="line-modified">139     return jsPair(lexicalGlobalObject, globalObject, toJS&lt;FirstType&gt;(lexicalGlobalObject, globalObject, value1), toJS&lt;SecondType&gt;(lexicalGlobalObject, globalObject, value2));</span>
140 }
141 
142 template&lt;typename JSIterator&gt; JSC::JSValue iteratorCreate(typename JSIterator::Wrapper&amp;, IterationKind);
<span class="line-modified">143 template&lt;typename JSIterator&gt; JSC::JSValue iteratorForEach(JSC::JSGlobalObject&amp;, JSC::CallFrame&amp;, typename JSIterator::Wrapper&amp;, JSC::ThrowScope&amp;);</span>
144 
145 template&lt;typename JSIterator&gt; JSC::JSValue iteratorCreate(typename JSIterator::Wrapper&amp; thisObject, IterationKind kind)
146 {
147     ASSERT(thisObject.globalObject());
148     JSDOMGlobalObject&amp; globalObject = *thisObject.globalObject();
149     return JSIterator::create(globalObject.vm(), getDOMStructure&lt;JSIterator&gt;(globalObject.vm(), globalObject), thisObject, kind);
150 }
151 
152 template&lt;typename JSWrapper, typename IteratorTraits&gt;
<span class="line-modified">153 template&lt;typename IteratorValue, typename T&gt; inline EnableIfMap&lt;T, JSC::JSValue&gt; JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;::asJS(JSC::JSGlobalObject&amp; lexicalGlobalObject, IteratorValue&amp; value)</span>
154 {
155     ASSERT(value);
156 
157     switch (m_kind) {
<span class="line-modified">158     case IterationKind::Keys:</span>
<span class="line-modified">159         return toJS&lt;typename Traits::KeyType&gt;(lexicalGlobalObject, *globalObject(), value-&gt;key);</span>
<span class="line-modified">160     case IterationKind::Values:</span>
<span class="line-modified">161         return toJS&lt;typename Traits::ValueType&gt;(lexicalGlobalObject, *globalObject(), value-&gt;value);</span>
<span class="line-modified">162     case IterationKind::Entries:</span>
<span class="line-modified">163         return jsPair&lt;typename Traits::KeyType, typename Traits::ValueType&gt;(lexicalGlobalObject, *globalObject(), value-&gt;key, value-&gt;value);</span>
164     };
165 
166     ASSERT_NOT_REACHED();
167     return { };
168 }
169 
170 template&lt;typename JSWrapper, typename IteratorTraits&gt;
<span class="line-modified">171 template&lt;typename IteratorValue, typename T&gt; inline EnableIfSet&lt;T, JSC::JSValue&gt; JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;::asJS(JSC::JSGlobalObject&amp; lexicalGlobalObject, IteratorValue&amp; value)</span>
172 {
173     ASSERT(value);
174 
175     auto globalObject = this-&gt;globalObject();
<span class="line-modified">176     auto result = toJS&lt;typename Traits::ValueType&gt;(lexicalGlobalObject, *globalObject, value);</span>
177 
178     switch (m_kind) {
<span class="line-modified">179     case IterationKind::Keys:</span>
<span class="line-modified">180     case IterationKind::Values:</span>
181         return result;
<span class="line-modified">182     case IterationKind::Entries:</span>
<span class="line-modified">183         return jsPair(lexicalGlobalObject, *globalObject, result, result);</span>
184     };
185 
186     ASSERT_NOT_REACHED();
187     return { };
188 }
189 
<span class="line-modified">190 template&lt;typename JSIterator, typename IteratorValue&gt; EnableIfMap&lt;typename JSIterator::Traits&gt; appendForEachArguments(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, JSC::MarkedArgumentBuffer&amp; arguments, IteratorValue&amp; value)</span>
191 {
192     ASSERT(value);
<span class="line-modified">193     arguments.append(toJS&lt;typename JSIterator::Traits::ValueType&gt;(lexicalGlobalObject, globalObject, value-&gt;value));</span>
<span class="line-modified">194     arguments.append(toJS&lt;typename JSIterator::Traits::KeyType&gt;(lexicalGlobalObject, globalObject, value-&gt;key));</span>
195 }
196 
<span class="line-modified">197 template&lt;typename JSIterator, typename IteratorValue&gt; EnableIfSet&lt;typename JSIterator::Traits&gt; appendForEachArguments(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, JSC::MarkedArgumentBuffer&amp; arguments, IteratorValue&amp; value)</span>
198 {
199     ASSERT(value);
<span class="line-modified">200     auto argument = toJS&lt;typename JSIterator::Traits::ValueType&gt;(lexicalGlobalObject, globalObject, value);</span>
201     arguments.append(argument);
202     arguments.append(argument);
203 }
204 
<span class="line-modified">205 template&lt;typename JSIterator&gt; JSC::JSValue iteratorForEach(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame, typename JSIterator::Wrapper&amp; thisObject, JSC::ThrowScope&amp; scope)</span>
206 {
<span class="line-modified">207     JSC::JSValue callback = callFrame.argument(0);</span>
<span class="line-modified">208     JSC::JSValue thisValue = callFrame.argument(1);</span>
209 
210     JSC::CallData callData;
<span class="line-modified">211     JSC::CallType callType = JSC::getCallData(JSC::getVM(&amp;lexicalGlobalObject), callback, callData);</span>
212     if (callType == JSC::CallType::None)
<span class="line-modified">213         return throwTypeError(&amp;lexicalGlobalObject, scope, &quot;Cannot call callback&quot;_s);</span>
214 
215     auto iterator = thisObject.wrapped().createIterator();
216     while (auto value = iterator.next()) {
217         JSC::MarkedArgumentBuffer arguments;
<span class="line-modified">218         appendForEachArguments&lt;JSIterator&gt;(lexicalGlobalObject, *thisObject.globalObject(), arguments, value);</span>
219         arguments.append(&amp;thisObject);
220         if (UNLIKELY(arguments.hasOverflowed())) {
<span class="line-modified">221             throwOutOfMemoryError(&amp;lexicalGlobalObject, scope);</span>
222             return { };
223         }
<span class="line-modified">224         JSC::call(&amp;lexicalGlobalObject, callback, callType, callData, thisValue, arguments);</span>
225         if (UNLIKELY(scope.exception()))
226             break;
227     }
228     return JSC::jsUndefined();
229 }
230 
231 template&lt;typename JSWrapper, typename IteratorTraits&gt;
232 void JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;::destroy(JSCell* cell)
233 {
234     JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;* thisObject = static_cast&lt;JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;*&gt;(cell);
235     thisObject-&gt;JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;::~JSDOMIterator();
236 }
237 
238 template&lt;typename JSWrapper, typename IteratorTraits&gt;
<span class="line-modified">239 JSC::JSValue JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;::next(JSC::JSGlobalObject&amp; lexicalGlobalObject)</span>
240 {
241     if (m_iterator) {
242         auto iteratorValue = m_iterator-&gt;next();
243         if (iteratorValue)
<span class="line-modified">244             return createIteratorResultObject(&amp;lexicalGlobalObject, asJS(lexicalGlobalObject, iteratorValue), false);</span>
245         m_iterator = WTF::nullopt;
246     }
<span class="line-modified">247     return createIteratorResultObject(&amp;lexicalGlobalObject, JSC::jsUndefined(), true);</span>
248 }
249 
250 template&lt;typename JSWrapper, typename IteratorTraits&gt;
<span class="line-modified">251 JSC::EncodedJSValue JSC_HOST_CALL JSDOMIteratorPrototype&lt;JSWrapper, IteratorTraits&gt;::next(JSC::JSGlobalObject* globalObject, JSC::CallFrame* callFrame)</span>
252 {
<span class="line-modified">253     JSC::VM&amp; vm = globalObject-&gt;vm();</span>
254     auto scope = DECLARE_THROW_SCOPE(vm);
255 
<span class="line-modified">256     auto iterator = JSC::jsDynamicCast&lt;JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;*&gt;(vm, callFrame-&gt;thisValue());</span>
257     if (!iterator)
<span class="line-modified">258         return JSC::JSValue::encode(throwTypeError(globalObject, scope, &quot;Cannot call next() on a non-Iterator object&quot;_s));</span>
259 
<span class="line-modified">260     return JSC::JSValue::encode(iterator-&gt;next(*globalObject));</span>
261 }
262 
263 template&lt;typename JSWrapper, typename IteratorTraits&gt;
264 void JSDOMIteratorPrototype&lt;JSWrapper, IteratorTraits&gt;::finishCreation(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject)
265 {
266     Base::finishCreation(vm);
267     ASSERT(inherits(vm, info()));
268 
<span class="line-added">269     putDirectWithoutTransition(vm, vm.propertyNames-&gt;toStringTagSymbol, jsString(vm, info()-&gt;className), JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);</span>
270     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;next, next, 0, 0, JSC::NoIntrinsic);
271 }
272 
273 }
</pre>
</td>
</tr>
</table>
<center><a href="JSDOMIterator.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSDOMMapLike.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
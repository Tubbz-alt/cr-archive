<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SparseArrayValueMap.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SmallStrings.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SparseArrayValueMap.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SparseArrayValueMap.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 79             m_reportedCapacity = capacity;
 80         }
 81     }
 82     if (increasedCapacity)
 83         Heap::heap(array)-&gt;reportExtraMemoryAllocated(increasedCapacity * sizeof(Map::KeyValuePairType));
 84     return result;
 85 }
 86 
 87 void SparseArrayValueMap::remove(iterator it)
 88 {
 89     auto locker = holdLock(cellLock());
 90     m_map.remove(it);
 91 }
 92 
 93 void SparseArrayValueMap::remove(unsigned i)
 94 {
 95     auto locker = holdLock(cellLock());
 96     m_map.remove(i);
 97 }
 98 
<span class="line-modified"> 99 bool SparseArrayValueMap::putEntry(ExecState* exec, JSObject* array, unsigned i, JSValue value, bool shouldThrow)</span>
100 {
<span class="line-modified">101     VM&amp; vm = exec-&gt;vm();</span>
102     auto scope = DECLARE_THROW_SCOPE(vm);
103     ASSERT(value);
104 
105     AddResult result = add(array, i);
106     SparseArrayEntry&amp; entry = result.iterator-&gt;value;
107 
108     // To save a separate find &amp; add, we first always add to the sparse map.
109     // In the uncommon case that this is a new property, and the array is not
110     // extensible, this is not the right thing to have done - so remove again.
111     if (result.isNewEntry &amp;&amp; !array-&gt;isStructureExtensible(vm)) {
112         remove(result.iterator);
<span class="line-modified">113         return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
114     }
115 
<span class="line-modified">116     RELEASE_AND_RETURN(scope, entry.put(exec, array, this, value, shouldThrow));</span>
117 }
118 
<span class="line-modified">119 bool SparseArrayValueMap::putDirect(ExecState* exec, JSObject* array, unsigned i, JSValue value, unsigned attributes, PutDirectIndexMode mode)</span>
120 {
<span class="line-modified">121     VM&amp; vm = exec-&gt;vm();</span>
122     auto scope = DECLARE_THROW_SCOPE(vm);
123     ASSERT(value);
124 
125     bool shouldThrow = (mode == PutDirectIndexShouldThrow);
126 
127     AddResult result = add(array, i);
128     SparseArrayEntry&amp; entry = result.iterator-&gt;value;
129 
130     // To save a separate find &amp; add, we first always add to the sparse map.
131     // In the uncommon case that this is a new property, and the array is not
132     // extensible, this is not the right thing to have done - so remove again.
133     if (mode != PutDirectIndexLikePutDirect &amp;&amp; result.isNewEntry &amp;&amp; !array-&gt;isStructureExtensible(vm)) {
134         remove(result.iterator);
<span class="line-modified">135         return typeError(exec, scope, shouldThrow, NonExtensibleObjectPropertyDefineError);</span>
136     }
137 
138     if (entry.attributes() &amp; PropertyAttribute::ReadOnly)
<span class="line-modified">139         return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
140 
141     entry.forceSet(vm, this, value, attributes);
142     return true;
143 }
144 
145 JSValue SparseArrayValueMap::getConcurrently(unsigned i)
146 {
147     auto locker = holdLock(cellLock());
148     auto iterator = m_map.find(i);
149     if (iterator == m_map.end())
150         return JSValue();
151     return iterator-&gt;value.getConcurrently();
152 }
153 
154 void SparseArrayEntry::get(JSObject* thisObject, PropertySlot&amp; slot) const
155 {
156     JSValue value = Base::get();
157     ASSERT(value);
158 
159     if (LIKELY(!value.isGetterSetter())) {
</pre>
<hr />
<pre>
173 {
174     // These attributes and value can be updated while executing getConcurrently.
175     // But this is OK since attributes should be never weaken once it gets DontDelete and ReadOnly.
176     // By emitting store-store-fence and load-load-fence between value setting and attributes setting,
177     // we can ensure that the value is what we want once the attributes get ReadOnly &amp; DontDelete:
178     // once attributes get this state, the value should not be changed.
179     unsigned attributes = m_attributes;
180     Dependency attributesDependency = Dependency::fence(attributes);
181     if (attributes &amp; PropertyAttribute::Accessor)
182         return JSValue();
183 
184     if (!(attributes &amp; PropertyAttribute::ReadOnly))
185         return JSValue();
186 
187     if (!(attributes &amp; PropertyAttribute::DontDelete))
188         return JSValue();
189 
190     return attributesDependency.consume(this)-&gt;Base::get();
191 }
192 
<span class="line-modified">193 bool SparseArrayEntry::put(ExecState* exec, JSValue thisValue, SparseArrayValueMap* map, JSValue value, bool shouldThrow)</span>
194 {
<span class="line-modified">195     VM&amp; vm = exec-&gt;vm();</span>
196     auto scope = DECLARE_THROW_SCOPE(vm);
197 
198     if (!(m_attributes &amp; PropertyAttribute::Accessor)) {
199         if (m_attributes &amp; PropertyAttribute::ReadOnly)
<span class="line-modified">200             return typeError(exec, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
201 
202         set(vm, map, value);
203         return true;
204     }
205 
<span class="line-modified">206     RELEASE_AND_RETURN(scope, callSetter(exec, thisValue, Base::get(), value, shouldThrow ? StrictMode : NotStrictMode));</span>
207 }
208 
209 JSValue SparseArrayEntry::getNonSparseMode() const
210 {
211     ASSERT(!m_attributes);
212     return Base::get();
213 }
214 
215 void SparseArrayValueMap::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
216 {
217     SparseArrayValueMap* thisObject = jsCast&lt;SparseArrayValueMap*&gt;(cell);
218     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
219     Base::visitChildren(cell, visitor);
220     {
221         auto locker = holdLock(thisObject-&gt;cellLock());
222         for (auto&amp; entry : thisObject-&gt;m_map)
223             visitor.append(entry.value.asValue());
224     }
225     visitor.reportExtraMemoryVisited(thisObject-&gt;m_reportedCapacity * sizeof(Map::KeyValuePairType));
226 }
</pre>
</td>
<td>
<hr />
<pre>
 79             m_reportedCapacity = capacity;
 80         }
 81     }
 82     if (increasedCapacity)
 83         Heap::heap(array)-&gt;reportExtraMemoryAllocated(increasedCapacity * sizeof(Map::KeyValuePairType));
 84     return result;
 85 }
 86 
 87 void SparseArrayValueMap::remove(iterator it)
 88 {
 89     auto locker = holdLock(cellLock());
 90     m_map.remove(it);
 91 }
 92 
 93 void SparseArrayValueMap::remove(unsigned i)
 94 {
 95     auto locker = holdLock(cellLock());
 96     m_map.remove(i);
 97 }
 98 
<span class="line-modified"> 99 bool SparseArrayValueMap::putEntry(JSGlobalObject* globalObject, JSObject* array, unsigned i, JSValue value, bool shouldThrow)</span>
100 {
<span class="line-modified">101     VM&amp; vm = globalObject-&gt;vm();</span>
102     auto scope = DECLARE_THROW_SCOPE(vm);
103     ASSERT(value);
104 
105     AddResult result = add(array, i);
106     SparseArrayEntry&amp; entry = result.iterator-&gt;value;
107 
108     // To save a separate find &amp; add, we first always add to the sparse map.
109     // In the uncommon case that this is a new property, and the array is not
110     // extensible, this is not the right thing to have done - so remove again.
111     if (result.isNewEntry &amp;&amp; !array-&gt;isStructureExtensible(vm)) {
112         remove(result.iterator);
<span class="line-modified">113         return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
114     }
115 
<span class="line-modified">116     RELEASE_AND_RETURN(scope, entry.put(globalObject, array, this, value, shouldThrow));</span>
117 }
118 
<span class="line-modified">119 bool SparseArrayValueMap::putDirect(JSGlobalObject* globalObject, JSObject* array, unsigned i, JSValue value, unsigned attributes, PutDirectIndexMode mode)</span>
120 {
<span class="line-modified">121     VM&amp; vm = globalObject-&gt;vm();</span>
122     auto scope = DECLARE_THROW_SCOPE(vm);
123     ASSERT(value);
124 
125     bool shouldThrow = (mode == PutDirectIndexShouldThrow);
126 
127     AddResult result = add(array, i);
128     SparseArrayEntry&amp; entry = result.iterator-&gt;value;
129 
130     // To save a separate find &amp; add, we first always add to the sparse map.
131     // In the uncommon case that this is a new property, and the array is not
132     // extensible, this is not the right thing to have done - so remove again.
133     if (mode != PutDirectIndexLikePutDirect &amp;&amp; result.isNewEntry &amp;&amp; !array-&gt;isStructureExtensible(vm)) {
134         remove(result.iterator);
<span class="line-modified">135         return typeError(globalObject, scope, shouldThrow, NonExtensibleObjectPropertyDefineError);</span>
136     }
137 
138     if (entry.attributes() &amp; PropertyAttribute::ReadOnly)
<span class="line-modified">139         return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
140 
141     entry.forceSet(vm, this, value, attributes);
142     return true;
143 }
144 
145 JSValue SparseArrayValueMap::getConcurrently(unsigned i)
146 {
147     auto locker = holdLock(cellLock());
148     auto iterator = m_map.find(i);
149     if (iterator == m_map.end())
150         return JSValue();
151     return iterator-&gt;value.getConcurrently();
152 }
153 
154 void SparseArrayEntry::get(JSObject* thisObject, PropertySlot&amp; slot) const
155 {
156     JSValue value = Base::get();
157     ASSERT(value);
158 
159     if (LIKELY(!value.isGetterSetter())) {
</pre>
<hr />
<pre>
173 {
174     // These attributes and value can be updated while executing getConcurrently.
175     // But this is OK since attributes should be never weaken once it gets DontDelete and ReadOnly.
176     // By emitting store-store-fence and load-load-fence between value setting and attributes setting,
177     // we can ensure that the value is what we want once the attributes get ReadOnly &amp; DontDelete:
178     // once attributes get this state, the value should not be changed.
179     unsigned attributes = m_attributes;
180     Dependency attributesDependency = Dependency::fence(attributes);
181     if (attributes &amp; PropertyAttribute::Accessor)
182         return JSValue();
183 
184     if (!(attributes &amp; PropertyAttribute::ReadOnly))
185         return JSValue();
186 
187     if (!(attributes &amp; PropertyAttribute::DontDelete))
188         return JSValue();
189 
190     return attributesDependency.consume(this)-&gt;Base::get();
191 }
192 
<span class="line-modified">193 bool SparseArrayEntry::put(JSGlobalObject* globalObject, JSValue thisValue, SparseArrayValueMap* map, JSValue value, bool shouldThrow)</span>
194 {
<span class="line-modified">195     VM&amp; vm = globalObject-&gt;vm();</span>
196     auto scope = DECLARE_THROW_SCOPE(vm);
197 
198     if (!(m_attributes &amp; PropertyAttribute::Accessor)) {
199         if (m_attributes &amp; PropertyAttribute::ReadOnly)
<span class="line-modified">200             return typeError(globalObject, scope, shouldThrow, ReadonlyPropertyWriteError);</span>
201 
202         set(vm, map, value);
203         return true;
204     }
205 
<span class="line-modified">206     RELEASE_AND_RETURN(scope, callSetter(globalObject, thisValue, Base::get(), value, shouldThrow ? StrictMode : NotStrictMode));</span>
207 }
208 
209 JSValue SparseArrayEntry::getNonSparseMode() const
210 {
211     ASSERT(!m_attributes);
212     return Base::get();
213 }
214 
215 void SparseArrayValueMap::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
216 {
217     SparseArrayValueMap* thisObject = jsCast&lt;SparseArrayValueMap*&gt;(cell);
218     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
219     Base::visitChildren(cell, visitor);
220     {
221         auto locker = holdLock(thisObject-&gt;cellLock());
222         for (auto&amp; entry : thisObject-&gt;m_map)
223             visitor.append(entry.value.asValue());
224     }
225     visitor.reportExtraMemoryVisited(thisObject-&gt;m_reportedCapacity * sizeof(Map::KeyValuePairType));
226 }
</pre>
</td>
</tr>
</table>
<center><a href="SmallStrings.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SparseArrayValueMap.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
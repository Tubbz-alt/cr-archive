<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorTimelineAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2 * Copyright (C) 2013 Google Inc. All rights reserved.
  3 * Copyright (C) 2014 University of Washington.
  4 * Copyright (C) 2015 Apple Inc. All rights reserved.
  5 *
  6 * Redistribution and use in source and binary forms, with or without
  7 * modification, are permitted provided that the following conditions are
  8 * met:
  9 *
 10 *     * Redistributions of source code must retain the above copyright
 11 * notice, this list of conditions and the following disclaimer.
 12 *     * Redistributions in binary form must reproduce the above
 13 * copyright notice, this list of conditions and the following disclaimer
 14 * in the documentation and/or other materials provided with the
 15 * distribution.
 16 *     * Neither the name of Google Inc. nor the names of its
 17 * contributors may be used to endorse or promote products derived from
 18 * this software without specific prior written permission.
 19 *
 20 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 21 * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 22 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 23 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 24 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 25 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 26 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 27 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 28 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 29 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 30 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 31 */
 32 
 33 #include &quot;config.h&quot;
 34 #include &quot;InspectorTimelineAgent.h&quot;
 35 
 36 #include &quot;DOMWindow.h&quot;
 37 #include &quot;Event.h&quot;
 38 #include &quot;Frame.h&quot;
 39 #include &quot;InspectorAnimationAgent.h&quot;
 40 #include &quot;InspectorCPUProfilerAgent.h&quot;
 41 #include &quot;InspectorClient.h&quot;
 42 #include &quot;InspectorController.h&quot;
 43 #include &quot;InspectorMemoryAgent.h&quot;
 44 #include &quot;InspectorPageAgent.h&quot;
 45 #include &quot;InstrumentingAgents.h&quot;
 46 #include &quot;JSDOMWindow.h&quot;
 47 #include &quot;PageHeapAgent.h&quot;
 48 #include &quot;PageScriptDebugServer.h&quot;
 49 #include &quot;RenderView.h&quot;
 50 #include &quot;ScriptState.h&quot;
 51 #include &quot;TimelineRecordFactory.h&quot;
 52 #include &quot;WebConsoleAgent.h&quot;
 53 #include &quot;WebDebuggerAgent.h&quot;
 54 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
 55 #include &lt;JavaScriptCore/InspectorScriptProfilerAgent.h&gt;
 56 #include &lt;JavaScriptCore/ScriptBreakpoint.h&gt;
 57 #include &lt;wtf/Stopwatch.h&gt;
 58 
 59 #if PLATFORM(IOS_FAMILY)
 60 #include &quot;RuntimeApplicationChecks.h&quot;
 61 #include &quot;WebCoreThreadInternal.h&quot;
 62 #endif
 63 
 64 #if PLATFORM(COCOA)
 65 #include &quot;RunLoopObserver.h&quot;
 66 #endif
 67 
 68 
 69 namespace WebCore {
 70 
 71 using namespace Inspector;
 72 
 73 #if PLATFORM(COCOA)
 74 static CFRunLoopRef currentRunLoop()
 75 {
 76 #if PLATFORM(IOS_FAMILY)
 77     // A race condition during WebView deallocation can lead to a crash if the layer sync run loop
 78     // observer is added to the main run loop &lt;rdar://problem/9798550&gt;. However, for responsiveness,
 79     // we still allow this, see &lt;rdar://problem/7403328&gt;. Since the race condition and subsequent
 80     // crash are especially troublesome for iBooks, we never allow the observer to be added to the
 81     // main run loop in iBooks.
 82     if (IOSApplication::isIBooks())
 83         return WebThreadRunLoop();
 84 #endif
 85     return CFRunLoopGetCurrent();
 86 }
 87 #endif
 88 
 89 InspectorTimelineAgent::InspectorTimelineAgent(PageAgentContext&amp; context)
 90     : InspectorAgentBase(&quot;Timeline&quot;_s, context)
 91     , m_frontendDispatcher(makeUnique&lt;Inspector::TimelineFrontendDispatcher&gt;(context.frontendRouter))
 92     , m_backendDispatcher(Inspector::TimelineBackendDispatcher::create(context.backendDispatcher, this))
 93     , m_inspectedPage(context.inspectedPage)
 94 {
 95 }
 96 
 97 InspectorTimelineAgent::~InspectorTimelineAgent() = default;
 98 
 99 void InspectorTimelineAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
100 {
101 }
102 
103 void InspectorTimelineAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
104 {
105     ErrorString ignored;
106     disable(ignored);
107 }
108 
109 void InspectorTimelineAgent::enable(ErrorString&amp; errorString)
110 {
111     if (m_instrumentingAgents.inspectorTimelineAgent() == this) {
112         errorString = &quot;Timeline domain already enabled&quot;_s;
113         return;
114     }
115 
116     m_instrumentingAgents.setInspectorTimelineAgent(this);
117 }
118 
119 void InspectorTimelineAgent::disable(ErrorString&amp; errorString)
120 {
121     if (m_instrumentingAgents.inspectorTimelineAgent() != this) {
122         errorString = &quot;Timeline domain already disabled&quot;_s;
123         return;
124     }
125 
126     m_instrumentingAgents.setInspectorTimelineAgent(nullptr);
127 
128     ErrorString ignored;
129     stop(ignored);
130 
131     m_autoCaptureEnabled = false;
132     m_instruments.clear();
133 }
134 
135 void InspectorTimelineAgent::start(ErrorString&amp;, const int* maxCallStackDepth)
136 {
137     m_trackingFromFrontend = true;
138 
139     internalStart(maxCallStackDepth);
140 }
141 
142 void InspectorTimelineAgent::stop(ErrorString&amp;)
143 {
144     internalStop();
145 
146     m_trackingFromFrontend = false;
147 }
148 
149 void InspectorTimelineAgent::setAutoCaptureEnabled(ErrorString&amp;, bool enabled)
150 {
151     m_autoCaptureEnabled = enabled;
152 }
153 
154 void InspectorTimelineAgent::setInstruments(ErrorString&amp; errorString, const JSON::Array&amp; instruments)
155 {
156     Vector&lt;Protocol::Timeline::Instrument&gt; newInstruments;
157     newInstruments.reserveCapacity(instruments.length());
158 
159     for (const auto&amp; instrumentValue : instruments) {
160         String enumValueString;
161         if (!instrumentValue-&gt;asString(enumValueString)) {
162             errorString = &quot;Unexpected non-string value in given instruments&quot;_s;
163             return;
164         }
165 
166         Optional&lt;Protocol::Timeline::Instrument&gt; instrumentType = Protocol::InspectorHelpers::parseEnumValueFromString&lt;Protocol::Timeline::Instrument&gt;(enumValueString);
167         if (!instrumentType) {
168             errorString = makeString(&quot;Unknown item in given instruments: &quot;, enumValueString);
169             return;
170         }
171 
172         newInstruments.uncheckedAppend(*instrumentType);
173     }
174 
175     m_instruments.swap(newInstruments);
176 }
177 
178 void InspectorTimelineAgent::internalStart(const int* maxCallStackDepth)
179 {
180     if (m_tracking)
181         return;
182 
183     if (maxCallStackDepth &amp;&amp; *maxCallStackDepth &gt; 0)
184         m_maxCallStackDepth = *maxCallStackDepth;
185     else
186         m_maxCallStackDepth = 5;
187 
188     m_instrumentingAgents.setTrackingInspectorTimelineAgent(this);
189 
190     m_environment.scriptDebugServer().addListener(this);
191 
192     m_tracking = true;
193 
194     // FIXME: Abstract away platform-specific code once https://bugs.webkit.org/show_bug.cgi?id=142748 is fixed.
195 
196 #if PLATFORM(COCOA)
197     m_frameStartObserver = makeUnique&lt;RunLoopObserver&gt;(static_cast&lt;CFIndex&gt;(RunLoopObserver::WellKnownRunLoopOrders::InspectorFrameBegin), [this]() {
198         if (!m_tracking || m_environment.scriptDebugServer().isPaused())
199             return;
200 
201         if (!m_runLoopNestingLevel)
202             pushCurrentRecord(JSON::Object::create(), TimelineRecordType::RenderingFrame, false, nullptr);
203         m_runLoopNestingLevel++;
204     });
205 
206     m_frameStopObserver = makeUnique&lt;RunLoopObserver&gt;(static_cast&lt;CFIndex&gt;(RunLoopObserver::WellKnownRunLoopOrders::InspectorFrameEnd), [this]() {
207         if (!m_tracking || m_environment.scriptDebugServer().isPaused())
208             return;
209 
210         ASSERT(m_runLoopNestingLevel &gt; 0);
211         m_runLoopNestingLevel--;
212         if (m_runLoopNestingLevel)
213             return;
214 
215         if (m_startedComposite)
216             didComposite();
217 
218         didCompleteCurrentRecord(TimelineRecordType::RenderingFrame);
219     });
220 
221     m_frameStartObserver-&gt;schedule(currentRunLoop(), kCFRunLoopEntry | kCFRunLoopAfterWaiting);
222     m_frameStopObserver-&gt;schedule(currentRunLoop(), kCFRunLoopExit | kCFRunLoopBeforeWaiting);
223 
224     // Create a runloop record and increment the runloop nesting level, to capture the current turn of the main runloop
225     // (which is the outer runloop if recording started while paused in the debugger).
226     pushCurrentRecord(JSON::Object::create(), TimelineRecordType::RenderingFrame, false, nullptr);
227 
228     m_runLoopNestingLevel = 1;
229 #endif
230 
231     m_frontendDispatcher-&gt;recordingStarted(timestamp());
232 
233     if (auto* client = m_inspectedPage.inspectorController().inspectorClient())
234         client-&gt;timelineRecordingChanged(true);
235 }
236 
237 void InspectorTimelineAgent::internalStop()
238 {
239     if (!m_tracking)
240         return;
241 
242     m_instrumentingAgents.setTrackingInspectorTimelineAgent(nullptr);
243 
244     m_environment.scriptDebugServer().removeListener(this, true);
245 
246 #if PLATFORM(COCOA)
247     m_frameStartObserver = nullptr;
248     m_frameStopObserver = nullptr;
249     m_runLoopNestingLevel = 0;
250 
251     // Complete all pending records to prevent discarding events that are currently in progress.
252     while (!m_recordStack.isEmpty())
253         didCompleteCurrentRecord(m_recordStack.last().type);
254 #endif
255 
256     m_recordStack.clear();
257 
258     m_tracking = false;
259     m_startedComposite = false;
260     m_autoCapturePhase = AutoCapturePhase::None;
261 
262     m_frontendDispatcher-&gt;recordingStopped(timestamp());
263 
264     if (auto* client = m_inspectedPage.inspectorController().inspectorClient())
265         client-&gt;timelineRecordingChanged(false);
266 }
267 
268 double InspectorTimelineAgent::timestamp()
269 {
270     return m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
271 }
272 
273 void InspectorTimelineAgent::startFromConsole(JSC::JSGlobalObject* exec, const String&amp; title)
274 {
275     // Allow duplicate unnamed profiles. Disallow duplicate named profiles.
276     if (!title.isEmpty()) {
277         for (const TimelineRecordEntry&amp; record : m_pendingConsoleProfileRecords) {
278             String recordTitle;
279             record.data-&gt;getString(&quot;title&quot;_s, recordTitle);
280             if (recordTitle == title) {
281                 if (WebConsoleAgent* consoleAgent = m_instrumentingAgents.webConsoleAgent()) {
282                     // FIXME: Send an enum to the frontend for localization?
283                     String warning = title.isEmpty() ? &quot;Unnamed Profile already exists&quot;_s : makeString(&quot;Profile \&quot;&quot;, title, &quot;\&quot; already exists&quot;);
284                     consoleAgent-&gt;addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Profile, MessageLevel::Warning, warning));
285                 }
286                 return;
287             }
288         }
289     }
290 
291     if (!m_tracking &amp;&amp; m_pendingConsoleProfileRecords.isEmpty())
292         startProgrammaticCapture();
293 
294     m_pendingConsoleProfileRecords.append(createRecordEntry(TimelineRecordFactory::createConsoleProfileData(title), TimelineRecordType::ConsoleProfile, true, frameFromExecState(exec)));
295 }
296 
297 void InspectorTimelineAgent::stopFromConsole(JSC::JSGlobalObject*, const String&amp; title)
298 {
299     // Stop profiles in reverse order. If the title is empty, then stop the last profile.
300     // Otherwise, match the title of the profile to stop.
301     for (int i = m_pendingConsoleProfileRecords.size() - 1; i &gt;= 0; --i) {
302         const TimelineRecordEntry&amp; record = m_pendingConsoleProfileRecords[i];
303 
304         String recordTitle;
305         record.data-&gt;getString(&quot;title&quot;_s, recordTitle);
306         if (title.isEmpty() || recordTitle == title) {
307             didCompleteRecordEntry(record);
308             m_pendingConsoleProfileRecords.remove(i);
309 
310             if (!m_trackingFromFrontend &amp;&amp; m_pendingConsoleProfileRecords.isEmpty())
311                 stopProgrammaticCapture();
312 
313             return;
314         }
315     }
316 
317     if (WebConsoleAgent* consoleAgent = m_instrumentingAgents.webConsoleAgent()) {
318         // FIXME: Send an enum to the frontend for localization?
319         String warning = title.isEmpty() ? &quot;No profiles exist&quot;_s : makeString(&quot;Profile \&quot;&quot;, title, &quot;\&quot; does not exist&quot;);
320         consoleAgent-&gt;addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::ProfileEnd, MessageLevel::Warning, warning));
321     }
322 }
323 
324 void InspectorTimelineAgent::willCallFunction(const String&amp; scriptName, int scriptLine, int scriptColumn, Frame* frame)
325 {
326     pushCurrentRecord(TimelineRecordFactory::createFunctionCallData(scriptName, scriptLine, scriptColumn), TimelineRecordType::FunctionCall, true, frame);
327 }
328 
329 void InspectorTimelineAgent::didCallFunction(Frame*)
330 {
331     didCompleteCurrentRecord(TimelineRecordType::FunctionCall);
332 }
333 
334 void InspectorTimelineAgent::willDispatchEvent(const Event&amp; event, Frame* frame)
335 {
336     pushCurrentRecord(TimelineRecordFactory::createEventDispatchData(event), TimelineRecordType::EventDispatch, false, frame);
337 }
338 
339 void InspectorTimelineAgent::didDispatchEvent(bool defaultPrevented)
340 {
341     if (m_recordStack.isEmpty())
342         return;
343 
344     auto&amp; entry = m_recordStack.last();
345     ASSERT(entry.type == TimelineRecordType::EventDispatch);
346     entry.data-&gt;setBoolean(&quot;defaultPrevented&quot;_s, defaultPrevented);
347 
348     didCompleteCurrentRecord(TimelineRecordType::EventDispatch);
349 }
350 
351 void InspectorTimelineAgent::didInvalidateLayout(Frame&amp; frame)
352 {
353     appendRecord(JSON::Object::create(), TimelineRecordType::InvalidateLayout, true, &amp;frame);
354 }
355 
356 void InspectorTimelineAgent::willLayout(Frame&amp; frame)
357 {
358     pushCurrentRecord(JSON::Object::create(), TimelineRecordType::Layout, true, &amp;frame);
359 }
360 
361 void InspectorTimelineAgent::didLayout(RenderObject&amp; root)
362 {
363     if (m_recordStack.isEmpty())
364         return;
365     TimelineRecordEntry&amp; entry = m_recordStack.last();
366     ASSERT(entry.type == TimelineRecordType::Layout);
367     Vector&lt;FloatQuad&gt; quads;
368     root.absoluteQuads(quads);
369     if (quads.size() &gt;= 1)
370         TimelineRecordFactory::appendLayoutRoot(entry.data.get(), quads[0]);
371     else
372         ASSERT_NOT_REACHED();
373     didCompleteCurrentRecord(TimelineRecordType::Layout);
374 }
375 
376 void InspectorTimelineAgent::didScheduleStyleRecalculation(Frame* frame)
377 {
378     appendRecord(JSON::Object::create(), TimelineRecordType::ScheduleStyleRecalculation, true, frame);
379 }
380 
381 void InspectorTimelineAgent::willRecalculateStyle(Frame* frame)
382 {
383     pushCurrentRecord(JSON::Object::create(), TimelineRecordType::RecalculateStyles, true, frame);
384 }
385 
386 void InspectorTimelineAgent::didRecalculateStyle()
387 {
388     didCompleteCurrentRecord(TimelineRecordType::RecalculateStyles);
389 }
390 
391 void InspectorTimelineAgent::willComposite(Frame&amp; frame)
392 {
393     ASSERT(!m_startedComposite);
394     pushCurrentRecord(JSON::Object::create(), TimelineRecordType::Composite, true, &amp;frame);
395     m_startedComposite = true;
396 }
397 
398 void InspectorTimelineAgent::didComposite()
399 {
400     if (m_startedComposite)
401         didCompleteCurrentRecord(TimelineRecordType::Composite);
402     m_startedComposite = false;
403 }
404 
405 void InspectorTimelineAgent::willPaint(Frame&amp; frame)
406 {
407     pushCurrentRecord(JSON::Object::create(), TimelineRecordType::Paint, true, &amp;frame);
408 }
409 
410 void InspectorTimelineAgent::didPaint(RenderObject&amp; renderer, const LayoutRect&amp; clipRect)
411 {
412     if (m_recordStack.isEmpty())
413         return;
414 
415     TimelineRecordEntry&amp; entry = m_recordStack.last();
416     ASSERT(entry.type == TimelineRecordType::Paint);
417     FloatQuad quad;
418     localToPageQuad(renderer, clipRect, &amp;quad);
419     entry.data = TimelineRecordFactory::createPaintData(quad);
420     didCompleteCurrentRecord(TimelineRecordType::Paint);
421 }
422 
423 void InspectorTimelineAgent::didInstallTimer(int timerId, Seconds timeout, bool singleShot, Frame* frame)
424 {
425     appendRecord(TimelineRecordFactory::createTimerInstallData(timerId, timeout, singleShot), TimelineRecordType::TimerInstall, true, frame);
426 }
427 
428 void InspectorTimelineAgent::didRemoveTimer(int timerId, Frame* frame)
429 {
430     appendRecord(TimelineRecordFactory::createGenericTimerData(timerId), TimelineRecordType::TimerRemove, true, frame);
431 }
432 
433 void InspectorTimelineAgent::willFireTimer(int timerId, Frame* frame)
434 {
435     pushCurrentRecord(TimelineRecordFactory::createGenericTimerData(timerId), TimelineRecordType::TimerFire, false, frame);
436 }
437 
438 void InspectorTimelineAgent::didFireTimer()
439 {
440     didCompleteCurrentRecord(TimelineRecordType::TimerFire);
441 }
442 
443 void InspectorTimelineAgent::willEvaluateScript(const String&amp; url, int lineNumber, int columnNumber, Frame&amp; frame)
444 {
445     pushCurrentRecord(TimelineRecordFactory::createEvaluateScriptData(url, lineNumber, columnNumber), TimelineRecordType::EvaluateScript, true, &amp;frame);
446 }
447 
448 void InspectorTimelineAgent::didEvaluateScript(Frame&amp;)
449 {
450     didCompleteCurrentRecord(TimelineRecordType::EvaluateScript);
451 }
452 
453 void InspectorTimelineAgent::didTimeStamp(Frame&amp; frame, const String&amp; message)
454 {
455     appendRecord(TimelineRecordFactory::createTimeStampData(message), TimelineRecordType::TimeStamp, true, &amp;frame);
456 }
457 
458 void InspectorTimelineAgent::time(Frame&amp; frame, const String&amp; message)
459 {
460     appendRecord(TimelineRecordFactory::createTimeStampData(message), TimelineRecordType::Time, true, &amp;frame);
461 }
462 
463 void InspectorTimelineAgent::timeEnd(Frame&amp; frame, const String&amp; message)
464 {
465     appendRecord(TimelineRecordFactory::createTimeStampData(message), TimelineRecordType::TimeEnd, true, &amp;frame);
466 }
467 
468 void InspectorTimelineAgent::mainFrameStartedLoading()
469 {
470     if (m_tracking)
471         return;
472 
473     if (!m_autoCaptureEnabled)
474         return;
475 
476     if (m_instruments.isEmpty())
477         return;
478 
479     m_autoCapturePhase = AutoCapturePhase::BeforeLoad;
480 
481     // Pre-emptively disable breakpoints. The frontend must re-enable them.
482     if (auto* webDebuggerAgent = m_instrumentingAgents.webDebuggerAgent()) {
483         ErrorString ignored;
484         webDebuggerAgent-&gt;setBreakpointsActive(ignored, false);
485     }
486 
487     // Inform the frontend we started an auto capture. The frontend must stop capture.
488     m_frontendDispatcher-&gt;autoCaptureStarted();
489 
490     toggleInstruments(InstrumentState::Start);
491 }
492 
493 void InspectorTimelineAgent::mainFrameNavigated()
494 {
495     if (m_autoCapturePhase == AutoCapturePhase::BeforeLoad) {
496         m_autoCapturePhase = AutoCapturePhase::FirstNavigation;
497         toggleInstruments(InstrumentState::Start);
498         m_autoCapturePhase = AutoCapturePhase::AfterFirstNavigation;
499     }
500 }
501 
502 void InspectorTimelineAgent::startProgrammaticCapture()
503 {
504     ASSERT(!m_tracking);
505 
506     // Disable breakpoints during programmatic capture.
507     if (auto* webDebuggerAgent = m_instrumentingAgents.webDebuggerAgent()) {
508         m_programmaticCaptureRestoreBreakpointActiveValue = webDebuggerAgent-&gt;breakpointsActive();
509         if (m_programmaticCaptureRestoreBreakpointActiveValue) {
510             ErrorString ignored;
511             webDebuggerAgent-&gt;setBreakpointsActive(ignored, false);
512         }
513     } else
514         m_programmaticCaptureRestoreBreakpointActiveValue = false;
515 
516     toggleScriptProfilerInstrument(InstrumentState::Start); // Ensure JavaScript samping data.
517     toggleTimelineInstrument(InstrumentState::Start); // Ensure Console Profile event records.
518     toggleInstruments(InstrumentState::Start); // Any other instruments the frontend wants us to record.
519 }
520 
521 void InspectorTimelineAgent::stopProgrammaticCapture()
522 {
523     ASSERT(m_tracking);
524     ASSERT(!m_trackingFromFrontend);
525 
526     toggleInstruments(InstrumentState::Stop);
527     toggleTimelineInstrument(InstrumentState::Stop);
528     toggleScriptProfilerInstrument(InstrumentState::Stop);
529 
530     // Re-enable breakpoints if they were enabled.
531     if (m_programmaticCaptureRestoreBreakpointActiveValue) {
532         if (auto* webDebuggerAgent = m_instrumentingAgents.webDebuggerAgent()) {
533             ErrorString ignored;
534             webDebuggerAgent-&gt;setBreakpointsActive(ignored, true);
535         }
536     }
537 }
538 
539 void InspectorTimelineAgent::toggleInstruments(InstrumentState state)
540 {
541     for (auto instrumentType : m_instruments) {
542         switch (instrumentType) {
543         case Inspector::Protocol::Timeline::Instrument::ScriptProfiler: {
544             toggleScriptProfilerInstrument(state);
545             break;
546         }
547         case Inspector::Protocol::Timeline::Instrument::Heap: {
548             toggleHeapInstrument(state);
549             break;
550         }
551         case Inspector::Protocol::Timeline::Instrument::CPU: {
552             toggleCPUInstrument(state);
553             break;
554         }
555         case Inspector::Protocol::Timeline::Instrument::Memory: {
556             toggleMemoryInstrument(state);
557             break;
558         }
559         case Inspector::Protocol::Timeline::Instrument::Timeline:
560             toggleTimelineInstrument(state);
561             break;
562         case Inspector::Protocol::Timeline::Instrument::Animation:
563             toggleAnimationInstrument(state);
564             break;
565         }
566     }
567 }
568 
569 void InspectorTimelineAgent::toggleScriptProfilerInstrument(InstrumentState state)
570 {
571     if (auto* scriptProfilerAgent = m_instrumentingAgents.inspectorScriptProfilerAgent()) {
572         ErrorString ignored;
573         if (state == InstrumentState::Start) {
574             const bool includeSamples = true;
575             scriptProfilerAgent-&gt;startTracking(ignored, &amp;includeSamples);
576         } else
577             scriptProfilerAgent-&gt;stopTracking(ignored);
578     }
579 }
580 
581 void InspectorTimelineAgent::toggleHeapInstrument(InstrumentState state)
582 {
583     if (auto* heapAgent = m_instrumentingAgents.pageHeapAgent()) {
584         ErrorString ignored;
585         if (state == InstrumentState::Start) {
586             if (m_autoCapturePhase == AutoCapturePhase::None || m_autoCapturePhase == AutoCapturePhase::FirstNavigation)
587                 heapAgent-&gt;startTracking(ignored);
588         } else
589             heapAgent-&gt;stopTracking(ignored);
590     }
591 }
592 
593 void InspectorTimelineAgent::toggleCPUInstrument(InstrumentState state)
594 {
595 #if ENABLE(RESOURCE_USAGE)
596     if (InspectorCPUProfilerAgent* cpuProfilerAgent = m_instrumentingAgents.inspectorCPUProfilerAgent()) {
597         ErrorString ignored;
598         if (state == InstrumentState::Start)
599             cpuProfilerAgent-&gt;startTracking(ignored);
600         else
601             cpuProfilerAgent-&gt;stopTracking(ignored);
602     }
603 #else
604     UNUSED_PARAM(state);
605 #endif
606 }
607 
608 void InspectorTimelineAgent::toggleMemoryInstrument(InstrumentState state)
609 {
610 #if ENABLE(RESOURCE_USAGE)
611     if (InspectorMemoryAgent* memoryAgent = m_instrumentingAgents.inspectorMemoryAgent()) {
612         ErrorString ignored;
613         if (state == InstrumentState::Start)
614             memoryAgent-&gt;startTracking(ignored);
615         else
616             memoryAgent-&gt;stopTracking(ignored);
617     }
618 #else
619     UNUSED_PARAM(state);
620 #endif
621 }
622 
623 void InspectorTimelineAgent::toggleTimelineInstrument(InstrumentState state)
624 {
625     if (state == InstrumentState::Start)
626         internalStart();
627     else
628         internalStop();
629 }
630 
631 void InspectorTimelineAgent::toggleAnimationInstrument(InstrumentState state)
632 {
633     if (auto* animationAgent = m_instrumentingAgents.persistentInspectorAnimationAgent()) {
634         ErrorString ignored;
635         if (state == InstrumentState::Start)
636             animationAgent-&gt;startTracking(ignored);
637         else
638             animationAgent-&gt;stopTracking(ignored);
639     }
640 }
641 
642 void InspectorTimelineAgent::didRequestAnimationFrame(int callbackId, Frame* frame)
643 {
644     appendRecord(TimelineRecordFactory::createAnimationFrameData(callbackId), TimelineRecordType::RequestAnimationFrame, true, frame);
645 }
646 
647 void InspectorTimelineAgent::didCancelAnimationFrame(int callbackId, Frame* frame)
648 {
649     appendRecord(TimelineRecordFactory::createAnimationFrameData(callbackId), TimelineRecordType::CancelAnimationFrame, true, frame);
650 }
651 
652 void InspectorTimelineAgent::willFireAnimationFrame(int callbackId, Frame* frame)
653 {
654     pushCurrentRecord(TimelineRecordFactory::createAnimationFrameData(callbackId), TimelineRecordType::FireAnimationFrame, false, frame);
655 }
656 
657 void InspectorTimelineAgent::didFireAnimationFrame()
658 {
659     didCompleteCurrentRecord(TimelineRecordType::FireAnimationFrame);
660 }
661 
662 void InspectorTimelineAgent::willFireObserverCallback(const String&amp; callbackType, Frame* frame)
663 {
664     pushCurrentRecord(TimelineRecordFactory::createObserverCallbackData(callbackType), TimelineRecordType::ObserverCallback, false, frame);
665 }
666 
667 void InspectorTimelineAgent::didFireObserverCallback()
668 {
669     didCompleteCurrentRecord(TimelineRecordType::ObserverCallback);
670 }
671 
672 // ScriptDebugListener
673 
674 void InspectorTimelineAgent::breakpointActionProbe(JSC::JSGlobalObject* lexicalGlobalObject, const Inspector::ScriptBreakpointAction&amp; action, unsigned /*batchId*/, unsigned sampleId, JSC::JSValue)
675 {
676     appendRecord(TimelineRecordFactory::createProbeSampleData(action, sampleId), TimelineRecordType::ProbeSample, false, frameFromExecState(lexicalGlobalObject));
677 }
678 
679 static Inspector::Protocol::Timeline::EventType toProtocol(TimelineRecordType type)
680 {
681     switch (type) {
682     case TimelineRecordType::EventDispatch:
683         return Inspector::Protocol::Timeline::EventType::EventDispatch;
684     case TimelineRecordType::ScheduleStyleRecalculation:
685         return Inspector::Protocol::Timeline::EventType::ScheduleStyleRecalculation;
686     case TimelineRecordType::RecalculateStyles:
687         return Inspector::Protocol::Timeline::EventType::RecalculateStyles;
688     case TimelineRecordType::InvalidateLayout:
689         return Inspector::Protocol::Timeline::EventType::InvalidateLayout;
690     case TimelineRecordType::Layout:
691         return Inspector::Protocol::Timeline::EventType::Layout;
692     case TimelineRecordType::Paint:
693         return Inspector::Protocol::Timeline::EventType::Paint;
694     case TimelineRecordType::Composite:
695         return Inspector::Protocol::Timeline::EventType::Composite;
696     case TimelineRecordType::RenderingFrame:
697         return Inspector::Protocol::Timeline::EventType::RenderingFrame;
698 
699     case TimelineRecordType::TimerInstall:
700         return Inspector::Protocol::Timeline::EventType::TimerInstall;
701     case TimelineRecordType::TimerRemove:
702         return Inspector::Protocol::Timeline::EventType::TimerRemove;
703     case TimelineRecordType::TimerFire:
704         return Inspector::Protocol::Timeline::EventType::TimerFire;
705 
706     case TimelineRecordType::EvaluateScript:
707         return Inspector::Protocol::Timeline::EventType::EvaluateScript;
708 
709     case TimelineRecordType::TimeStamp:
710         return Inspector::Protocol::Timeline::EventType::TimeStamp;
711     case TimelineRecordType::Time:
712         return Inspector::Protocol::Timeline::EventType::Time;
713     case TimelineRecordType::TimeEnd:
714         return Inspector::Protocol::Timeline::EventType::TimeEnd;
715 
716     case TimelineRecordType::FunctionCall:
717         return Inspector::Protocol::Timeline::EventType::FunctionCall;
718     case TimelineRecordType::ProbeSample:
719         return Inspector::Protocol::Timeline::EventType::ProbeSample;
720     case TimelineRecordType::ConsoleProfile:
721         return Inspector::Protocol::Timeline::EventType::ConsoleProfile;
722 
723     case TimelineRecordType::RequestAnimationFrame:
724         return Inspector::Protocol::Timeline::EventType::RequestAnimationFrame;
725     case TimelineRecordType::CancelAnimationFrame:
726         return Inspector::Protocol::Timeline::EventType::CancelAnimationFrame;
727     case TimelineRecordType::FireAnimationFrame:
728         return Inspector::Protocol::Timeline::EventType::FireAnimationFrame;
729 
730     case TimelineRecordType::ObserverCallback:
731         return Inspector::Protocol::Timeline::EventType::ObserverCallback;
732     }
733 
734     return Inspector::Protocol::Timeline::EventType::TimeStamp;
735 }
736 
737 void InspectorTimelineAgent::addRecordToTimeline(RefPtr&lt;JSON::Object&gt;&amp;&amp; record, TimelineRecordType type)
738 {
739     ASSERT_ARG(record, record);
740     record-&gt;setString(&quot;type&quot;, Inspector::Protocol::InspectorHelpers::getEnumConstantValue(toProtocol(type)));
741 
742     if (m_recordStack.isEmpty()) {
743         auto recordObject = BindingTraits&lt;Inspector::Protocol::Timeline::TimelineEvent&gt;::runtimeCast(WTFMove(record));
744         sendEvent(WTFMove(recordObject));
745     } else {
746         const TimelineRecordEntry&amp; parent = m_recordStack.last();
747         // Nested paint records are an implementation detail and add no information not already contained in the parent.
748         if (type == TimelineRecordType::Paint &amp;&amp; parent.type == type)
749             return;
750 
751         parent.children-&gt;pushObject(WTFMove(record));
752     }
753 }
754 
755 void InspectorTimelineAgent::setFrameIdentifier(JSON::Object* record, Frame* frame)
756 {
757     if (!frame)
758         return;
759 
760     auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();
761     if (!pageAgent)
762         return;
763 
764     record-&gt;setString(&quot;frameId&quot;_s, pageAgent-&gt;frameId(frame));
765 }
766 
767 void InspectorTimelineAgent::didCompleteRecordEntry(const TimelineRecordEntry&amp; entry)
768 {
769     entry.record-&gt;setObject(&quot;data&quot;_s, entry.data);
770     entry.record-&gt;setArray(&quot;children&quot;_s, entry.children);
771     entry.record-&gt;setDouble(&quot;endTime&quot;_s, timestamp());
772     addRecordToTimeline(entry.record.copyRef(), entry.type);
773 }
774 
775 void InspectorTimelineAgent::didCompleteCurrentRecord(TimelineRecordType type)
776 {
777     // An empty stack could merely mean that the timeline agent was turned on in the middle of
778     // an event.  Don&#39;t treat as an error.
779     if (!m_recordStack.isEmpty()) {
780         TimelineRecordEntry entry = m_recordStack.last();
781         m_recordStack.removeLast();
782         ASSERT_UNUSED(type, entry.type == type);
783 
784         // Don&#39;t send RenderingFrame records that have no children to reduce noise.
785         if (entry.type == TimelineRecordType::RenderingFrame &amp;&amp; !entry.children-&gt;length())
786             return;
787 
788         didCompleteRecordEntry(entry);
789     }
790 }
791 
792 void InspectorTimelineAgent::appendRecord(RefPtr&lt;JSON::Object&gt;&amp;&amp; data, TimelineRecordType type, bool captureCallStack, Frame* frame)
793 {
794     Ref&lt;JSON::Object&gt; record = TimelineRecordFactory::createGenericRecord(timestamp(), captureCallStack ? m_maxCallStackDepth : 0);
795     record-&gt;setObject(&quot;data&quot;, WTFMove(data));
796     setFrameIdentifier(&amp;record.get(), frame);
797     addRecordToTimeline(WTFMove(record), type);
798 }
799 
800 void InspectorTimelineAgent::sendEvent(RefPtr&lt;JSON::Object&gt;&amp;&amp; event)
801 {
802     // FIXME: runtimeCast is a hack. We do it because we can&#39;t build TimelineEvent directly now.
803     auto recordChecked = BindingTraits&lt;Inspector::Protocol::Timeline::TimelineEvent&gt;::runtimeCast(WTFMove(event));
804     m_frontendDispatcher-&gt;eventRecorded(WTFMove(recordChecked));
805 }
806 
807 InspectorTimelineAgent::TimelineRecordEntry InspectorTimelineAgent::createRecordEntry(RefPtr&lt;JSON::Object&gt;&amp;&amp; data, TimelineRecordType type, bool captureCallStack, Frame* frame)
808 {
809     Ref&lt;JSON::Object&gt; record = TimelineRecordFactory::createGenericRecord(timestamp(), captureCallStack ? m_maxCallStackDepth : 0);
810     setFrameIdentifier(&amp;record.get(), frame);
811     return TimelineRecordEntry(WTFMove(record), WTFMove(data), JSON::Array::create(), type);
812 }
813 
814 void InspectorTimelineAgent::pushCurrentRecord(RefPtr&lt;JSON::Object&gt;&amp;&amp; data, TimelineRecordType type, bool captureCallStack, Frame* frame)
815 {
816     pushCurrentRecord(createRecordEntry(WTFMove(data), type, captureCallStack, frame));
817 }
818 
819 void InspectorTimelineAgent::localToPageQuad(const RenderObject&amp; renderer, const LayoutRect&amp; rect, FloatQuad* quad)
820 {
821     const FrameView&amp; frameView = renderer.view().frameView();
822     FloatQuad absolute = renderer.localToAbsoluteQuad(FloatQuad(rect));
823     quad-&gt;setP1(frameView.contentsToRootView(roundedIntPoint(absolute.p1())));
824     quad-&gt;setP2(frameView.contentsToRootView(roundedIntPoint(absolute.p2())));
825     quad-&gt;setP3(frameView.contentsToRootView(roundedIntPoint(absolute.p3())));
826     quad-&gt;setP4(frameView.contentsToRootView(roundedIntPoint(absolute.p4())));
827 }
828 
829 } // namespace WebCore
    </pre>
  </body>
</html>
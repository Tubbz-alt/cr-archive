<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/scripts/codegen/models.py</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 #!/usr/bin/env python
  2 #
  3 # Copyright (c) 2014 Apple Inc. All rights reserved.
  4 # Copyright (c) 2014 University of Washington. All rights reserved.
  5 #
  6 # Redistribution and use in source and binary forms, with or without
  7 # modification, are permitted provided that the following conditions
  8 # are met:
  9 # 1. Redistributions of source code must retain the above copyright
 10 #    notice, this list of conditions and the following disclaimer.
 11 # 2. Redistributions in binary form must reproduce the above copyright
 12 #    notice, this list of conditions and the following disclaimer in the
 13 #    documentation and/or other materials provided with the distribution.
 14 #
 15 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 16 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 17 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 19 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 20 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 21 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 22 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 23 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 24 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 25 # THE POSSIBILITY OF SUCH DAMAGE.
 26 
 27 import logging
 28 import collections
 29 
 30 log = logging.getLogger(&#39;global&#39;)
 31 
 32 
 33 def ucfirst(str):
 34     return str[:1].upper() + str[1:]
 35 
 36 
 37 def find_duplicates(l):
 38     return [key for key, count in list(collections.Counter(l).items()) if count &gt; 1]
 39 
 40 
 41 def validate_target_types(debuggable_types, target_types):
 42     for target_type in target_types:
 43         required_debuggable_types = set()
 44         if target_type == &#39;javascript&#39;:
 45             if not &#39;javascript&#39; in debuggable_types:
 46                 return False
 47         elif target_type == &#39;page&#39; or target_type == &#39;worker&#39;:
 48             if not &#39;page&#39; in debuggable_types:
 49                 return False
 50         elif target_type == &#39;service-worker&#39;:
 51             if not &#39;service-worker&#39; in debuggable_types:
 52                 return False
 53         elif target_type == &#39;web-page&#39;:
 54             if not &#39;web-page&#39; in debuggable_types:
 55                 return False
 56     return True
 57 
 58 
 59 _FRAMEWORK_CONFIG_MAP = {
 60     &quot;Global&quot;: {
 61     },
 62     &quot;JavaScriptCore&quot;: {
 63         &quot;cpp_protocol_group&quot;: &quot;Inspector&quot;,
 64         &quot;export_macro&quot;: &quot;JS_EXPORT_PRIVATE&quot;,
 65         &quot;alternate_dispatchers&quot;: True,
 66     },
 67     &quot;WebKit&quot;: {
 68         &quot;cpp_protocol_group&quot;: &quot;Automation&quot;,
 69         &quot;objc_protocol_group&quot;: &quot;WD&quot;,
 70         &quot;objc_prefix&quot;: &quot;WD&quot;,
 71     },
 72     &quot;WebInspector&quot;: {
 73         &quot;objc_protocol_group&quot;: &quot;RWI&quot;,
 74         &quot;objc_prefix&quot;: &quot;RWI&quot;,
 75     },
 76     &quot;WebInspectorUI&quot;: {
 77     },
 78     # Used for code generator tests.
 79     &quot;Test&quot;: {
 80         &quot;alternate_dispatchers&quot;: True,
 81         &quot;cpp_protocol_group&quot;: &quot;Test&quot;,
 82         &quot;objc_protocol_group&quot;: &quot;Test&quot;,
 83         &quot;objc_prefix&quot;: &quot;Test&quot;,
 84     }
 85 }
 86 
 87 _ALLOWED_DEBUGGABLE_TYPE_STRINGS = frozenset([&#39;javascript&#39;, &#39;page&#39;, &#39;service-worker&#39;, &#39;web-page&#39;])
 88 _ALLOWED_TARGET_TYPE_STRINGS = frozenset([&#39;javascript&#39;, &#39;page&#39;, &#39;service-worker&#39;, &#39;web-page&#39;, &#39;worker&#39;])
 89 
 90 
 91 class ParseException(Exception):
 92     pass
 93 
 94 
 95 class TypecheckException(Exception):
 96     pass
 97 
 98 
 99 class Framework:
100     def __init__(self, name):
101         self._settings = _FRAMEWORK_CONFIG_MAP[name]
102         self.name = name
103 
104     def setting(self, key, default=&#39;&#39;):
105         return self._settings.get(key, default)
106 
107     @staticmethod
108     def fromString(frameworkString):
109         if frameworkString == &quot;Global&quot;:
110             return Frameworks.Global
111 
112         if frameworkString == &quot;JavaScriptCore&quot;:
113             return Frameworks.JavaScriptCore
114 
115         if frameworkString == &quot;WebKit&quot;:
116             return Frameworks.WebKit
117 
118         if frameworkString == &quot;WebInspector&quot;:
119             return Frameworks.WebInspector
120 
121         if frameworkString == &quot;WebInspectorUI&quot;:
122             return Frameworks.WebInspectorUI
123 
124         if frameworkString == &quot;Test&quot;:
125             return Frameworks.Test
126 
127         raise ParseException(&quot;Unknown framework: %s&quot; % frameworkString)
128 
129 
130 class Frameworks:
131     Global = Framework(&quot;Global&quot;)
132     JavaScriptCore = Framework(&quot;JavaScriptCore&quot;)
133     WebKit = Framework(&quot;WebKit&quot;)
134     WebInspector = Framework(&quot;WebInspector&quot;)
135     WebInspectorUI = Framework(&quot;WebInspectorUI&quot;)
136     Test = Framework(&quot;Test&quot;)
137 
138 
139 class Platform:
140     def __init__(self, name):
141         self.name = name
142 
143     @staticmethod
144     def fromString(platformString):
145         platformString = platformString.lower()
146         if platformString == &quot;ios&quot;:
147             return Platforms.iOS
148 
149         if platformString == &quot;macos&quot;:
150             return Platforms.macOS
151 
152         if platformString == &quot;all&quot;:
153             return Platforms.All
154 
155         if platformString == &quot;generic&quot; or not platformString:
156             return Platforms.Generic
157 
158         raise ParseException(&quot;Unknown platform: %s&quot; % platformString)
159 
160 
161 class Platforms:
162     All = Platform(&quot;all&quot;)
163     Generic = Platform(&quot;generic&quot;)
164     iOS = Platform(&quot;ios&quot;)
165     macOS = Platform(&quot;macos&quot;)
166 
167     # Allow iteration over all platforms. See &lt;http://stackoverflow.com/questions/5434400/&gt;.
168     class __metaclass__(type):
169         def __iter__(self):
170             for attr in dir(Platforms):
171                 if not attr.startswith(&quot;__&quot;):
172                     yield getattr(Platforms, attr)
173 
174 class TypeReference:
175     def __init__(self, type_kind, referenced_type_name, enum_values, array_items):
176         self.type_kind = type_kind
177         self.referenced_type_name = referenced_type_name
178         self.enum_values = enum_values
179         if array_items is None:
180             self.array_type_ref = None
181         else:
182             self.array_type_ref = TypeReference(array_items.get(&#39;type&#39;), array_items.get(&#39;$ref&#39;), array_items.get(&#39;enum&#39;), array_items.get(&#39;items&#39;))
183 
184         if type_kind is not None and referenced_type_name is not None:
185             raise ParseException(&quot;Type reference cannot have both &#39;type&#39; and &#39;$ref&#39; keys.&quot;)
186 
187         all_primitive_types = [&quot;integer&quot;, &quot;number&quot;, &quot;string&quot;, &quot;boolean&quot;, &quot;enum&quot;, &quot;object&quot;, &quot;array&quot;, &quot;any&quot;]
188         if type_kind is not None and type_kind not in all_primitive_types:
189             raise ParseException(&quot;Type reference &#39;%s&#39; is not a primitive type. Allowed values: %s&quot; % (type_kind, &#39;, &#39;.join(all_primitive_types)))
190 
191         if type_kind == &quot;array&quot; and array_items is None:
192             raise ParseException(&quot;Type reference with type &#39;array&#39; must have key &#39;items&#39; to define array element type.&quot;)
193 
194         if enum_values is not None and len(enum_values) == 0:
195             raise ParseException(&quot;Type reference with enum values must have at least one enum value.&quot;)
196 
197     def referenced_name(self):
198         if self.referenced_type_name is not None:
199             return self.referenced_type_name
200         else:
201             return self.type_kind  # one of all_primitive_types
202 
203 
204 class Type:
205     def __init__(self):
206         pass
207 
208     def __eq__(self, other):
209         return self.qualified_name() == other.qualified_name()
210 
211     def __hash__(self):
212         return self.qualified_name().__hash__()
213 
214     def raw_name(self):
215         return self._name
216 
217     # These methods should be overridden by subclasses.
218     def is_enum(self):
219         return False
220 
221     def type_domain(self):
222         pass
223 
224     def qualified_name(self):
225         pass
226 
227     # This is used to resolve nested types after instances are created.
228     def resolve_type_references(self, protocol):
229         pass
230 
231 
232 class PrimitiveType(Type):
233     def __init__(self, name):
234         self._name = name
235 
236     def __repr__(self):
237         return &#39;PrimitiveType[%s]&#39; % self.qualified_name()
238 
239     def type_domain(self):
240         return None
241 
242     def qualified_name(self):
243         return self.raw_name()
244 
245 
246 class AliasedType(Type):
247     def __init__(self, declaration, domain, aliased_type_ref):
248         self._name = declaration.type_name
249         self._declaration = declaration
250         self._domain = domain
251         self._aliased_type_ref = aliased_type_ref
252         self.aliased_type = None
253 
254     def __repr__(self):
255         if self.aliased_type is not None:
256             return &#39;AliasedType[%s -&gt; %r]&#39; % (self.qualified_name(), self.aliased_type)
257         else:
258             return &#39;AliasedType[%s -&gt; (unresolved)]&#39; % self.qualified_name()
259 
260     def is_enum(self):
261         return self.aliased_type.is_enum()
262 
263     def type_domain(self):
264         return self._domain
265 
266     def qualified_name(self):
267         return  &quot;.&quot;.join([self.type_domain().domain_name, self.raw_name()])
268 
269     def resolve_type_references(self, protocol):
270         if self.aliased_type is not None:
271             return
272 
273         self.aliased_type = protocol.lookup_type_reference(self._aliased_type_ref, self.type_domain())
274         log.debug(&quot;&lt; Resolved type reference for aliased type in %s: %s&quot; % (self.qualified_name(), self.aliased_type.qualified_name()))
275 
276 
277 class EnumType(Type):
278     def __init__(self, declaration, domain, values, primitive_type_ref, is_anonymous=False):
279         self._name = &quot;(anonymous)&quot; if declaration is None else declaration.type_name
280         self._declaration = declaration
281         self._domain = domain
282         self._values = values
283         self._primitive_type_ref = primitive_type_ref
284         self.primitive_type = None
285         self.is_anonymous = is_anonymous
286 
287     def __repr__(self):
288         return &#39;EnumType[primitive_type=%s; enum_values=%s]&#39; % (self.qualified_name(), &#39;, &#39;.join(map(str, self.enum_values())))
289 
290     def is_enum(self):
291         return True
292 
293     def enum_values(self):
294         return self._values
295 
296     def type_domain(self):
297         return self._domain
298 
299     def declaration(self):
300         return self._declaration
301 
302     def qualified_name(self):
303         return  &quot;.&quot;.join([self.type_domain().domain_name, self.raw_name()])
304 
305     def resolve_type_references(self, protocol):
306         if self.primitive_type is not None:
307             return
308 
309         self.primitive_type = protocol.lookup_type_reference(self._primitive_type_ref, Domains.GLOBAL)
310         log.debug(&quot;&lt; Resolved type reference for enum type in %s: %s&quot; % (self.qualified_name(), self.primitive_type.qualified_name()))
311         log.debug(&quot;&lt;&lt; enum values: %s&quot; % self.enum_values())
312 
313 
314 class ArrayType(Type):
315     def __init__(self, declaration, element_type_ref, domain):
316         self._name = None if declaration is None else declaration.type_name
317         self._declaration = declaration
318         self._domain = domain
319         self._element_type_ref = element_type_ref
320         self.element_type = None
321 
322     def __repr__(self):
323         if self.element_type is not None:
324             return &#39;ArrayType[element_type=%r]&#39; % self.element_type
325         else:
326             return &#39;ArrayType[element_type=(unresolved)]&#39;
327 
328     def declaration(self):
329         return self._declaration
330 
331     def type_domain(self):
332         return self._domain
333 
334     def qualified_name(self):
335         return  &quot;.&quot;.join([&quot;array&quot;, self.element_type.qualified_name()])
336 
337     def resolve_type_references(self, protocol):
338         if self.element_type is not None:
339             return
340 
341         self.element_type = protocol.lookup_type_reference(self._element_type_ref, self.type_domain())
342         log.debug(&quot;&lt; Resolved type reference for element type in %s: %s&quot; % (self.qualified_name(), self.element_type.qualified_name()))
343 
344 
345 class ObjectType(Type):
346     def __init__(self, declaration, domain):
347         self._name = declaration.type_name
348         self._declaration = declaration
349         self._domain = domain
350         self.members = declaration.type_members
351 
352     def __repr__(self):
353         return &#39;ObjectType[%s]&#39; % self.qualified_name()
354 
355     def declaration(self):
356         return self._declaration
357 
358     def type_domain(self):
359         return self._domain
360 
361     def qualified_name(self):
362         return  &quot;.&quot;.join([self.type_domain().domain_name, self.raw_name()])
363 
364 
365 def check_for_required_properties(props, obj, what):
366     for prop in props:
367         if prop not in obj:
368             raise ParseException(&quot;When parsing %s, required property missing: %s&quot; % (what, prop))
369 
370 
371 class Protocol:
372     def __init__(self, framework_name):
373         self.domains = []
374         self.types_by_name = {}
375         self.framework = Framework.fromString(framework_name)
376 
377     def parse_specification(self, json, isSupplemental):
378         log.debug(&quot;parse toplevel&quot;)
379 
380         if isinstance(json, dict) and &#39;domains&#39; in json:
381             json = json[&#39;domains&#39;]
382         if not isinstance(json, list):
383             json = [json]
384 
385         for domain in json:
386             self.parse_domain(domain, isSupplemental)
387 
388     def parse_domain(self, json, isSupplemental):
389         check_for_required_properties([&#39;domain&#39;], json, &quot;domain&quot;)
390         log.debug(&quot;parse domain &quot; + json[&#39;domain&#39;])
391 
392         debuggable_types = None
393         target_types = None
394         version = None
395         types = []
396         commands = []
397         events = []
398 
399         if &#39;debuggableTypes&#39; in json:
400             if not isinstance(json[&#39;debuggableTypes&#39;], list):
401                 raise ParseException(&quot;Malformed domain specification: debuggableTypes for domain %s is not an array&quot; % json[&#39;domain&#39;])
402 
403             for debuggable_types in json[&#39;debuggableTypes&#39;]:
404                 if debuggable_types not in _ALLOWED_DEBUGGABLE_TYPE_STRINGS:
405                     raise ParseException(&#39;Malformed domain specification: debuggableTypes for domain %s is an unsupported string. Was: &quot;%s&quot;, Allowed values: %s&#39; % (json[&#39;domain&#39;], json[&#39;debuggableTypes&#39;], &#39;, &#39;.join(_ALLOWED_DEBUGGABLE_TYPE_STRINGS)))
406 
407             debuggable_types = json.get(&#39;debuggableTypes&#39;)
408 
409         if &#39;targetTypes&#39; in json:
410             if not isinstance(json[&#39;targetTypes&#39;], list):
411                 raise ParseException(&quot;Malformed domain specification: targetTypes for domain %s is not an array&quot; % json[&#39;domain&#39;])
412 
413             for target_types in json[&#39;targetTypes&#39;]:
414                 if target_types not in _ALLOWED_TARGET_TYPE_STRINGS:
415                     raise ParseException(&#39;Malformed domain specification: targetTypes for domain %s is an unsupported string. Was: &quot;%s&quot;, Allowed values: %s&#39; % (json[&#39;domain&#39;], json[&#39;targetTypes&#39;], &#39;, &#39;.join(_ALLOWED_TARGET_TYPE_STRINGS)))
416 
417             target_types = json.get(&#39;targetTypes&#39;)
418 
419             if debuggable_types and not validate_target_types(debuggable_types, target_types):
420                 raise ParseException(&#39;Malformed domain specification: domain %s has an item in targetTypes &quot;%s&quot; that is not supported by any value in debuggableTypes &quot;%s&quot;.&#39; % (json[&#39;domain&#39;], target_types, debuggable_types))
421 
422         if &#39;version&#39; in json:
423             if not isinstance(json[&#39;version&#39;], int):
424                 raise ParseException(&quot;Malformed domain specification: version is not a number or string&quot;)
425             version = json[&#39;version&#39;]
426 
427         if &#39;types&#39; in json:
428             if not isinstance(json[&#39;types&#39;], list):
429                 raise ParseException(&quot;Malformed domain specification: types is not an array&quot;)
430             types.extend([self.parse_type_declaration(declaration) for declaration in json[&#39;types&#39;]])
431 
432         if &#39;commands&#39; in json:
433             if not isinstance(json[&#39;commands&#39;], list):
434                 raise ParseException(&quot;Malformed domain specification: commands is not an array&quot;)
435             commands.extend([self.parse_command(command, debuggable_types) for command in json[&#39;commands&#39;]])
436 
437         if &#39;events&#39; in json:
438             if not isinstance(json[&#39;events&#39;], list):
439                 raise ParseException(&quot;Malformed domain specification: events is not an array&quot;)
440             events.extend([self.parse_event(event, debuggable_types) for event in json[&#39;events&#39;]])
441 
442         self.domains.append(Domain(json[&#39;domain&#39;], json.get(&#39;description&#39;, &#39;&#39;), json.get(&#39;featureGuard&#39;), debuggable_types, target_types, isSupplemental, version, types, commands, events))
443 
444     def parse_type_declaration(self, json):
445         check_for_required_properties([&#39;id&#39;, &#39;type&#39;], json, &quot;type&quot;)
446         log.debug(&quot;parse type %s&quot; % json[&#39;id&#39;])
447 
448         type_members = []
449 
450         if &#39;properties&#39; in json:
451             if not isinstance(json[&#39;properties&#39;], list):
452                 raise ParseException(&quot;Malformed type specification: properties is not an array&quot;)
453             type_members.extend([self.parse_type_member(member) for member in json[&#39;properties&#39;]])
454 
455         duplicate_names = find_duplicates([member.member_name for member in type_members])
456         if len(duplicate_names) &gt; 0:
457             raise ParseException(&quot;Malformed domain specification: type declaration for %s has duplicate member names&quot; % json[&#39;id&#39;])
458 
459         type_ref = TypeReference(json[&#39;type&#39;], json.get(&#39;$ref&#39;), json.get(&#39;enum&#39;), json.get(&#39;items&#39;))
460         platform = Platform.fromString(json.get(&#39;platform&#39;, &#39;generic&#39;))
461         return TypeDeclaration(json[&#39;id&#39;], type_ref, json.get(&quot;description&quot;, &quot;&quot;), platform, type_members)
462 
463     def parse_type_member(self, json):
464         check_for_required_properties([&#39;name&#39;], json, &quot;type member&quot;)
465         log.debug(&quot;parse type member %s&quot; % json[&#39;name&#39;])
466 
467         type_ref = TypeReference(json.get(&#39;type&#39;), json.get(&#39;$ref&#39;), json.get(&#39;enum&#39;), json.get(&#39;items&#39;))
468         return TypeMember(json[&#39;name&#39;], type_ref, json.get(&#39;optional&#39;, False), json.get(&#39;description&#39;, &quot;&quot;))
469 
470     def parse_command(self, json, debuggable_types):
471         check_for_required_properties([&#39;name&#39;], json, &quot;command&quot;)
472         log.debug(&quot;parse command %s&quot; % json[&#39;name&#39;])
473 
474         target_types = None
475         call_parameters = []
476         return_parameters = []
477 
478         if &#39;targetTypes&#39; in json:
479             if not isinstance(json[&#39;targetTypes&#39;], list):
480                 raise ParseException(&quot;Malformed domain specification: targetTypes list for command %s is not an array&quot; % json[&#39;name&#39;])
481             target_types = json[&#39;targetTypes&#39;]
482 
483             for target_type in target_types:
484                 if target_type not in _ALLOWED_TARGET_TYPE_STRINGS:
485                     raise ParseException(&#39;Malformed domain specification: targetTypes list for command %s is an unsupported string. Was: &quot;%s&quot;, Allowed values: %s&#39; % (json[&#39;name&#39;], json[&#39;targetTypes&#39;], &#39;, &#39;.join(_ALLOWED_TARGET_TYPE_STRINGS)))
486 
487             duplicate_types = find_duplicates(target_types)
488             if len(duplicate_types) &gt; 0:
489                 raise ParseException(&quot;Malformed domain specification: targetTypes list for command %s has duplicate items&quot; % json[&#39;name&#39;])
490 
491             if debuggable_types and not validate_target_types(debuggable_types, target_types):
492                 raise ParseException(&#39;Malformed domain specification: command %s has an item in targetTypes &quot;%s&quot; that is not supported by any value in debuggableTypes &quot;%s&quot;.&#39; % (json[&#39;name&#39;], target_types, debuggable_types))
493 
494         if &#39;parameters&#39; in json:
495             if not isinstance(json[&#39;parameters&#39;], list):
496                 raise ParseException(&quot;Malformed command specification: parameters is not an array&quot;)
497             call_parameters.extend([self.parse_call_or_return_parameter(parameter) for parameter in json[&#39;parameters&#39;]])
498 
499             duplicate_names = find_duplicates([param.parameter_name for param in call_parameters])
500             if len(duplicate_names) &gt; 0:
501                 raise ParseException(&quot;Malformed domain specification: call parameter list for command %s has duplicate parameter names&quot; % json[&#39;name&#39;])
502 
503         if &#39;returns&#39; in json:
504             if not isinstance(json[&#39;returns&#39;], list):
505                 raise ParseException(&quot;Malformed command specification: returns is not an array&quot;)
506             return_parameters.extend([self.parse_call_or_return_parameter(parameter) for parameter in json[&#39;returns&#39;]])
507 
508             duplicate_names = find_duplicates([param.parameter_name for param in return_parameters])
509             if len(duplicate_names) &gt; 0:
510                 raise ParseException(&quot;Malformed domain specification: return parameter list for command %s has duplicate parameter names&quot; % json[&#39;name&#39;])
511 
512         platform = Platform.fromString(json.get(&#39;platform&#39;, &#39;generic&#39;))
513         return Command(json[&#39;name&#39;], target_types, call_parameters, return_parameters, json.get(&#39;description&#39;, &quot;&quot;), platform, json.get(&#39;async&#39;, False))
514 
515     def parse_event(self, json, debuggable_types):
516         check_for_required_properties([&#39;name&#39;], json, &quot;event&quot;)
517         log.debug(&quot;parse event %s&quot; % json[&#39;name&#39;])
518 
519         target_types = None
520         event_parameters = []
521 
522         if &#39;targetTypes&#39; in json:
523             if not isinstance(json[&#39;targetTypes&#39;], list):
524                 raise ParseException(&quot;Malformed domain specification: targetTypes for event %s is not an array&quot; % json[&#39;name&#39;])
525             target_types = json[&#39;targetTypes&#39;]
526 
527             for target_type in target_types:
528                 if target_type not in _ALLOWED_TARGET_TYPE_STRINGS:
529                     raise ParseException(&#39;Malformed domain specification: targetTypes for event %s is an unsupported string. Was: &quot;%s&quot;, Allowed values: %s&#39; % (json[&#39;name&#39;], json[&#39;targetTypes&#39;], &#39;, &#39;.join(_ALLOWED_TARGET_TYPE_STRINGS)))
530 
531             duplicate_types = find_duplicates(target_types)
532             if len(duplicate_types) &gt; 0:
533                 raise ParseException(&quot;Malformed domain specification: targetTypes list for event %s has duplicate items&quot; % json[&#39;name&#39;])
534 
535             if debuggable_types and not validate_target_types(debuggable_types, target_types):
536                 raise ParseException(&#39;Malformed domain specification: event %s has an item in targetTypes &quot;%s&quot; that is not supported by any value in debuggableTypes &quot;%s&quot;.&#39; % (json[&#39;name&#39;], target_types, debuggable_types))
537 
538         if &#39;parameters&#39; in json:
539             if not isinstance(json[&#39;parameters&#39;], list):
540                 raise ParseException(&quot;Malformed event specification: parameters is not an array&quot;)
541             event_parameters.extend([self.parse_call_or_return_parameter(parameter) for parameter in json[&#39;parameters&#39;]])
542 
543             duplicate_names = find_duplicates([param.parameter_name for param in event_parameters])
544             if len(duplicate_names) &gt; 0:
545                 raise ParseException(&quot;Malformed domain specification: parameter list for event %s has duplicate parameter names&quot; % json[&#39;name&#39;])
546 
547         platform = Platform.fromString(json.get(&#39;platform&#39;, &#39;generic&#39;))
548         return Event(json[&#39;name&#39;], target_types, event_parameters, json.get(&#39;description&#39;, &quot;&quot;), platform)
549 
550     def parse_call_or_return_parameter(self, json):
551         check_for_required_properties([&#39;name&#39;], json, &quot;parameter&quot;)
552         log.debug(&quot;parse parameter %s&quot; % json[&#39;name&#39;])
553 
554         type_ref = TypeReference(json.get(&#39;type&#39;), json.get(&#39;$ref&#39;), json.get(&#39;enum&#39;), json.get(&#39;items&#39;))
555         return Parameter(json[&#39;name&#39;], type_ref, json.get(&#39;optional&#39;, False), json.get(&#39;description&#39;, &quot;&quot;))
556 
557     def resolve_types(self):
558         qualified_declared_type_names = set([&#39;boolean&#39;, &#39;string&#39;, &#39;integer&#39;, &#39;number&#39;, &#39;enum&#39;, &#39;array&#39;, &#39;object&#39;, &#39;any&#39;])
559 
560         self.types_by_name[&#39;string&#39;] = PrimitiveType(&#39;string&#39;)
561         for _primitive_type in [&#39;boolean&#39;, &#39;integer&#39;, &#39;number&#39;]:
562             self.types_by_name[_primitive_type] = PrimitiveType(_primitive_type)
563         for _object_type in [&#39;any&#39;, &#39;object&#39;]:
564             self.types_by_name[_object_type] = PrimitiveType(_object_type)
565 
566         # Gather qualified type names from type declarations in each domain.
567         for domain in self.domains:
568             for declaration in domain.all_type_declarations():
569                 # Basic sanity checking.
570                 if declaration.type_ref.referenced_type_name is not None:
571                     raise TypecheckException(&quot;Type declarations must name a base type, not a type reference.&quot;)
572 
573                 # Find duplicate qualified type names.
574                 qualified_type_name = &quot;.&quot;.join([domain.domain_name, declaration.type_name])
575                 if qualified_type_name in qualified_declared_type_names:
576                     raise TypecheckException(&quot;Duplicate type declaration: %s&quot; % qualified_type_name)
577 
578                 qualified_declared_type_names.add(qualified_type_name)
579 
580                 type_instance = None
581 
582                 kind = declaration.type_ref.type_kind
583                 if declaration.type_ref.enum_values is not None:
584                     primitive_type_ref = TypeReference(declaration.type_ref.type_kind, None, None, None)
585                     type_instance = EnumType(declaration, domain, declaration.type_ref.enum_values, primitive_type_ref)
586                 elif kind == &quot;array&quot;:
587                     type_instance = ArrayType(declaration, declaration.type_ref.array_type_ref, domain)
588                 elif kind == &quot;object&quot;:
589                     type_instance = ObjectType(declaration, domain)
590                 else:
591                     type_instance = AliasedType(declaration, domain, declaration.type_ref)
592 
593                 log.debug(&quot;&lt; Created fresh type %r for declaration %s&quot; % (type_instance, qualified_type_name))
594                 self.types_by_name[qualified_type_name] = type_instance
595 
596         # Resolve all type references recursively.
597         for domain in self.domains:
598             domain.resolve_type_references(self)
599 
600     def lookup_type_for_declaration(self, declaration, domain):
601         # This will only match a type defined in the same domain, where prefixes aren&#39;t required.
602         qualified_name = &quot;.&quot;.join([domain.domain_name, declaration.type_name])
603         if qualified_name in self.types_by_name:
604             found_type = self.types_by_name[qualified_name]
605             found_type.resolve_type_references(self)
606             return found_type
607 
608         raise TypecheckException(&quot;Lookup failed for type declaration: %s (referenced from domain: %s)&quot; % (declaration.type_name, domain.domain_name))
609 
610     def lookup_type_reference(self, type_ref, domain):
611         # If reference is to an anonymous array type, create a fresh instance.
612         if type_ref.type_kind == &quot;array&quot;:
613             type_instance = ArrayType(None, type_ref.array_type_ref, domain)
614             type_instance.resolve_type_references(self)
615             log.debug(&quot;&lt; Created fresh type instance for anonymous array type: %s&quot; % type_instance.qualified_name())
616             return type_instance
617 
618         # If reference is to an anonymous enum type, create a fresh instance.
619         if type_ref.enum_values is not None:
620             # We need to create a type reference without enum values as the enum&#39;s nested type.
621             primitive_type_ref = TypeReference(type_ref.type_kind, None, None, None)
622             type_instance = EnumType(None, domain, type_ref.enum_values, primitive_type_ref, True)
623             type_instance.resolve_type_references(self)
624             log.debug(&quot;&lt; Created fresh type instance for anonymous enum type: %s&quot; % type_instance.qualified_name())
625             return type_instance
626 
627         # This will match when referencing a type defined in the same domain, where prefixes aren&#39;t required.
628         qualified_name = &quot;.&quot;.join([domain.domain_name, type_ref.referenced_name()])
629         if qualified_name in self.types_by_name:
630             found_type = self.types_by_name[qualified_name]
631             found_type.resolve_type_references(self)
632             log.debug(&quot;&lt; Lookup succeeded for unqualified type: %s&quot; % found_type.qualified_name())
633             return found_type
634 
635         # This will match primitive types and fully-qualified types from a different domain.
636         if type_ref.referenced_name() in self.types_by_name:
637             found_type = self.types_by_name[type_ref.referenced_name()]
638             found_type.resolve_type_references(self)
639             log.debug(&quot;&lt; Lookup succeeded for primitive or qualified type: %s&quot; % found_type.qualified_name())
640             return found_type
641 
642         raise TypecheckException(&quot;Lookup failed for type reference: %s (referenced from domain: %s)&quot; % (type_ref.referenced_name(), domain.domain_name))
643 
644 
645 class Domain:
646     def __init__(self, domain_name, description, feature_guard, debuggable_types, target_types, isSupplemental, version, type_declarations, commands, events):
647         self.domain_name = domain_name
648         self.description = description
649         self.feature_guard = feature_guard
650         self.debuggable_types = debuggable_types
651         self.target_types = target_types
652         self.is_supplemental = isSupplemental
653         self._version = version
654         self._type_declarations = type_declarations
655         self._commands = commands
656         self._events = events
657 
658     def version(self):
659         return self._version
660 
661     def all_type_declarations(self):
662         return self._type_declarations
663 
664     def all_commands(self):
665         return self._commands
666 
667     def all_events(self):
668         return self._events
669 
670     def resolve_type_references(self, protocol):
671         log.debug(&quot;&gt; Resolving type declarations for domain: %s&quot; % self.domain_name)
672         for declaration in self._type_declarations:
673             declaration.resolve_type_references(protocol, self)
674 
675         log.debug(&quot;&gt; Resolving types in commands for domain: %s&quot; % self.domain_name)
676         for command in self._commands:
677             command.resolve_type_references(protocol, self)
678 
679         log.debug(&quot;&gt; Resolving types in events for domain: %s&quot; % self.domain_name)
680         for event in self._events:
681             event.resolve_type_references(protocol, self)
682 
683 
684 class Domains:
685     GLOBAL = Domain(&quot;&quot;, &quot;The global domain, in which primitive types are implicitly declared.&quot;, None, None, None, False, None, [], [], [])
686 
687 
688 class TypeDeclaration:
689     def __init__(self, type_name, type_ref, description, platform, type_members):
690         self.type_name = type_name
691         self.type_ref = type_ref
692         self.description = description
693         self.platform = platform
694         self.type_members = type_members
695 
696         if self.type_name != ucfirst(self.type_name):
697             raise ParseException(&quot;Types must begin with an uppercase character.&quot;)
698 
699     def resolve_type_references(self, protocol, domain):
700         log.debug(&quot;&gt;&gt; Resolving type references for type declaration: %s&quot; % self.type_name)
701         self.type = protocol.lookup_type_for_declaration(self, domain)
702         for member in self.type_members:
703             member.resolve_type_references(protocol, domain)
704 
705 
706 class TypeMember:
707     def __init__(self, member_name, type_ref, is_optional, description):
708         self.member_name = member_name
709         self.type_ref = type_ref
710         self.is_optional = is_optional
711         self.description = description
712 
713         if not isinstance(self.is_optional, bool):
714             raise ParseException(&quot;The &#39;optional&#39; flag for a type member must be a boolean literal.&quot;)
715 
716     def resolve_type_references(self, protocol, domain):
717         log.debug(&quot;&gt;&gt;&gt; Resolving type references for type member: %s&quot; % self.member_name)
718         self.type = protocol.lookup_type_reference(self.type_ref, domain)
719 
720 
721 class Parameter:
722     def __init__(self, parameter_name, type_ref, is_optional, description):
723         self.parameter_name = parameter_name
724         self.type_ref = type_ref
725         self.is_optional = is_optional
726         self.description = description
727 
728         if not isinstance(self.is_optional, bool):
729             raise ParseException(&quot;The &#39;optional&#39; flag for a parameter must be a boolean literal.&quot;)
730 
731     def resolve_type_references(self, protocol, domain):
732         log.debug(&quot;&gt;&gt;&gt; Resolving type references for parameter: %s&quot; % self.parameter_name)
733         self.type = protocol.lookup_type_reference(self.type_ref, domain)
734 
735 
736 class Command:
737     def __init__(self, command_name, target_types, call_parameters, return_parameters, description, platform, is_async):
738         self.command_name = command_name
739         self.target_types = target_types
740         self.call_parameters = call_parameters
741         self.return_parameters = return_parameters
742         self.description = description
743         self.platform = platform
744         self.is_async = is_async
745 
746     def resolve_type_references(self, protocol, domain):
747         log.debug(&quot;&gt;&gt; Resolving type references for call parameters in command: %s&quot; % self.command_name)
748         for parameter in self.call_parameters:
749             parameter.resolve_type_references(protocol, domain)
750 
751         log.debug(&quot;&gt;&gt; Resolving type references for return parameters in command: %s&quot; % self.command_name)
752         for parameter in self.return_parameters:
753             parameter.resolve_type_references(protocol, domain)
754 
755 
756 class Event:
757     def __init__(self, event_name, target_types, event_parameters, description, platform):
758         self.event_name = event_name
759         self.target_types = target_types
760         self.event_parameters = event_parameters
761         self.description = description
762         self.platform = platform
763 
764     def resolve_type_references(self, protocol, domain):
765         log.debug(&quot;&gt;&gt; Resolving type references for parameters in event: %s&quot; % self.event_name)
766         for parameter in self.event_parameters:
767             parameter.resolve_type_references(protocol, domain)
    </pre>
  </body>
</html>
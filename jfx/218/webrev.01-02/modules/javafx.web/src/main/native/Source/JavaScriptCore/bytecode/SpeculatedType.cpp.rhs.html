<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/SpeculatedType.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;SpeculatedType.h&quot;
 31 
<a name="1" id="anc1"></a><span class="line-added"> 32 #include &quot;DateInstance.h&quot;</span>
 33 #include &quot;DirectArguments.h&quot;
 34 #include &quot;JSArray.h&quot;
 35 #include &quot;JSBigInt.h&quot;
 36 #include &quot;JSBoundFunction.h&quot;
 37 #include &quot;JSCInlines.h&quot;
 38 #include &quot;JSFunction.h&quot;
 39 #include &quot;JSMap.h&quot;
 40 #include &quot;JSSet.h&quot;
 41 #include &quot;JSWeakMap.h&quot;
 42 #include &quot;JSWeakSet.h&quot;
 43 #include &quot;ProxyObject.h&quot;
 44 #include &quot;RegExpObject.h&quot;
 45 #include &quot;ScopedArguments.h&quot;
 46 #include &quot;StringObject.h&quot;
 47 #include &quot;ValueProfile.h&quot;
 48 #include &lt;wtf/CommaPrinter.h&gt;
 49 #include &lt;wtf/StringPrintStream.h&gt;
 50 
 51 namespace JSC {
 52 
 53 struct PrettyPrinter {
 54     PrettyPrinter(PrintStream&amp; out)
 55         : out(out)
 56         , separator(&quot;|&quot;)
 57     { }
 58 
 59     template&lt;typename T&gt;
 60     void print(const T&amp; value)
 61     {
 62         out.print(separator, value);
 63     }
 64 
 65     PrintStream&amp; out;
 66     CommaPrinter separator;
 67 };
 68 
 69 void dumpSpeculation(PrintStream&amp; outStream, SpeculatedType value)
 70 {
 71     StringPrintStream strStream;
 72     PrettyPrinter out(outStream);
 73     PrettyPrinter strOut(strStream);
 74 
 75     if (value == SpecNone) {
 76         out.print(&quot;None&quot;);
 77         return;
 78     }
 79 
 80     bool isTop = true;
 81 
 82     if ((value &amp; SpecCell) == SpecCell)
 83         strOut.print(&quot;Cell&quot;);
 84     else {
 85         if ((value &amp; SpecObject) == SpecObject)
 86             strOut.print(&quot;Object&quot;);
 87         else {
 88             if (value &amp; SpecCellOther)
 89                 strOut.print(&quot;OtherCell&quot;);
 90             else
 91                 isTop = false;
 92 
 93             if (value &amp; SpecObjectOther)
 94                 strOut.print(&quot;OtherObj&quot;);
 95             else
 96                 isTop = false;
 97 
 98             if (value &amp; SpecFinalObject)
 99                 strOut.print(&quot;Final&quot;);
100             else
101                 isTop = false;
102 
103             if (value &amp; SpecArray)
104                 strOut.print(&quot;Array&quot;);
105             else
106                 isTop = false;
107 
108             if (value &amp; SpecInt8Array)
109                 strOut.print(&quot;Int8Array&quot;);
110             else
111                 isTop = false;
112 
113             if (value &amp; SpecInt16Array)
114                 strOut.print(&quot;Int16Array&quot;);
115             else
116                 isTop = false;
117 
118             if (value &amp; SpecInt32Array)
119                 strOut.print(&quot;Int32Array&quot;);
120             else
121                 isTop = false;
122 
123             if (value &amp; SpecUint8Array)
124                 strOut.print(&quot;Uint8Array&quot;);
125             else
126                 isTop = false;
127 
128             if (value &amp; SpecUint8ClampedArray)
129                 strOut.print(&quot;Uint8ClampedArray&quot;);
130             else
131                 isTop = false;
132 
133             if (value &amp; SpecUint16Array)
134                 strOut.print(&quot;Uint16Array&quot;);
135             else
136                 isTop = false;
137 
138             if (value &amp; SpecUint32Array)
139                 strOut.print(&quot;Uint32Array&quot;);
140             else
141                 isTop = false;
142 
143             if (value &amp; SpecFloat32Array)
144                 strOut.print(&quot;Float32array&quot;);
145             else
146                 isTop = false;
147 
148             if (value &amp; SpecFloat64Array)
149                 strOut.print(&quot;Float64Array&quot;);
150             else
151                 isTop = false;
152 
153             if (value &amp; SpecFunction)
154                 strOut.print(&quot;Function&quot;);
155             else
156                 isTop = false;
157 
158             if (value &amp; SpecDirectArguments)
159                 strOut.print(&quot;DirectArguments&quot;);
160             else
161                 isTop = false;
162 
163             if (value &amp; SpecScopedArguments)
164                 strOut.print(&quot;ScopedArguments&quot;);
165             else
166                 isTop = false;
167 
168             if (value &amp; SpecStringObject)
169                 strOut.print(&quot;StringObject&quot;);
170             else
171                 isTop = false;
172 
173             if (value &amp; SpecRegExpObject)
174                 strOut.print(&quot;RegExpObject&quot;);
175             else
176                 isTop = false;
177 
<a name="2" id="anc2"></a><span class="line-added">178             if (value &amp; SpecDateObject)</span>
<span class="line-added">179                 strOut.print(&quot;DateObject&quot;);</span>
<span class="line-added">180             else</span>
<span class="line-added">181                 isTop = false;</span>
<span class="line-added">182 </span>
<span class="line-added">183             if (value &amp; SpecPromiseObject)</span>
<span class="line-added">184                 strOut.print(&quot;PromiseObject&quot;);</span>
<span class="line-added">185             else</span>
<span class="line-added">186                 isTop = false;</span>
<span class="line-added">187 </span>
188             if (value &amp; SpecMapObject)
189                 strOut.print(&quot;MapObject&quot;);
190             else
191                 isTop = false;
192 
193             if (value &amp; SpecSetObject)
194                 strOut.print(&quot;SetObject&quot;);
195             else
196                 isTop = false;
197 
198             if (value &amp; SpecWeakMapObject)
199                 strOut.print(&quot;WeakMapObject&quot;);
200             else
201                 isTop = false;
202 
203             if (value &amp; SpecWeakSetObject)
204                 strOut.print(&quot;WeakSetObject&quot;);
205             else
206                 isTop = false;
207 
208             if (value &amp; SpecProxyObject)
209                 strOut.print(&quot;ProxyObject&quot;);
210             else
211                 isTop = false;
212 
213             if (value &amp; SpecDerivedArray)
214                 strOut.print(&quot;DerivedArray&quot;);
215             else
216                 isTop = false;
217 
218             if (value &amp; SpecDataViewObject)
219                 strOut.print(&quot;DataView&quot;);
220             else
221                 isTop = false;
222         }
223 
224         if ((value &amp; SpecString) == SpecString)
225             strOut.print(&quot;String&quot;);
226         else {
227             if (value &amp; SpecStringIdent)
228                 strOut.print(&quot;StringIdent&quot;);
229             else
230                 isTop = false;
231 
232             if (value &amp; SpecStringVar)
233                 strOut.print(&quot;StringVar&quot;);
234             else
235                 isTop = false;
236         }
237 
238         if (value &amp; SpecSymbol)
239             strOut.print(&quot;Symbol&quot;);
240         else
241             isTop = false;
242 
243         if (value &amp; SpecBigInt)
244             strOut.print(&quot;BigInt&quot;);
245         else
246             isTop = false;
247     }
248 
249     if (value == SpecInt32Only)
250         strOut.print(&quot;Int32&quot;);
251     else {
252         if (value &amp; SpecBoolInt32)
253             strOut.print(&quot;BoolInt32&quot;);
254         else
255             isTop = false;
256 
257         if (value &amp; SpecNonBoolInt32)
258             strOut.print(&quot;NonBoolInt32&quot;);
259         else
260             isTop = false;
261     }
262 
263     if ((value &amp; SpecBytecodeDouble) == SpecBytecodeDouble)
264         strOut.print(&quot;BytecodeDouble&quot;);
265     else {
266         if (value &amp; SpecAnyIntAsDouble)
267             strOut.print(&quot;AnyIntAsDouble&quot;);
268         else
269             isTop = false;
270 
271         if (value &amp; SpecNonIntAsDouble)
272             strOut.print(&quot;NonIntAsDouble&quot;);
273         else
274             isTop = false;
275 
276         if (value &amp; SpecDoublePureNaN)
<a name="3" id="anc3"></a><span class="line-modified">277             strOut.print(&quot;DoublePureNaN&quot;);</span>
278         else
279             isTop = false;
280     }
281 
282     if (value &amp; SpecDoubleImpureNaN)
<a name="4" id="anc4"></a><span class="line-modified">283         strOut.print(&quot;DoubleImpureNaN&quot;);</span>
284 
285     if (value &amp; SpecBoolean)
286         strOut.print(&quot;Bool&quot;);
287     else
288         isTop = false;
289 
290     if (value &amp; SpecOther)
291         strOut.print(&quot;Other&quot;);
292     else
293         isTop = false;
294 
295     if (value &amp; SpecEmpty)
296         strOut.print(&quot;Empty&quot;);
297     else
298         isTop = false;
299 
300     if (value &amp; SpecInt52Any) {
301         if ((value &amp; SpecInt52Any) == SpecInt52Any)
302             strOut.print(&quot;Int52Any&quot;);
303         else if (value &amp; SpecInt32AsInt52)
304             strOut.print(&quot;Int32AsInt52&quot;);
305         else if (value &amp; SpecNonInt32AsInt52)
306             strOut.print(&quot;NonInt32AsInt52&quot;);
307     } else
308         isTop = false;
309 
310     if (value == SpecBytecodeTop)
311         out.print(&quot;BytecodeTop&quot;);
312     else if (value == SpecHeapTop)
313         out.print(&quot;HeapTop&quot;);
314     else if (value == SpecFullTop)
315         out.print(&quot;FullTop&quot;);
316     else if (isTop)
317         out.print(&quot;Top&quot;);
318     else
319         out.print(strStream.toCString());
320 }
321 
322 // We don&#39;t expose this because we don&#39;t want anyone relying on the fact that this method currently
323 // just returns string constants.
324 static const char* speculationToAbbreviatedString(SpeculatedType prediction)
325 {
326     if (isFinalObjectSpeculation(prediction))
327         return &quot;&lt;Final&gt;&quot;;
328     if (isArraySpeculation(prediction))
329         return &quot;&lt;Array&gt;&quot;;
330     if (isStringIdentSpeculation(prediction))
331         return &quot;&lt;StringIdent&gt;&quot;;
332     if (isStringSpeculation(prediction))
333         return &quot;&lt;String&gt;&quot;;
334     if (isFunctionSpeculation(prediction))
335         return &quot;&lt;Function&gt;&quot;;
336     if (isInt8ArraySpeculation(prediction))
337         return &quot;&lt;Int8array&gt;&quot;;
338     if (isInt16ArraySpeculation(prediction))
339         return &quot;&lt;Int16array&gt;&quot;;
340     if (isInt32ArraySpeculation(prediction))
341         return &quot;&lt;Int32array&gt;&quot;;
342     if (isUint8ArraySpeculation(prediction))
343         return &quot;&lt;Uint8array&gt;&quot;;
344     if (isUint16ArraySpeculation(prediction))
345         return &quot;&lt;Uint16array&gt;&quot;;
346     if (isUint32ArraySpeculation(prediction))
347         return &quot;&lt;Uint32array&gt;&quot;;
348     if (isFloat32ArraySpeculation(prediction))
349         return &quot;&lt;Float32array&gt;&quot;;
350     if (isFloat64ArraySpeculation(prediction))
351         return &quot;&lt;Float64array&gt;&quot;;
352     if (isDirectArgumentsSpeculation(prediction))
353         return &quot;&lt;DirectArguments&gt;&quot;;
354     if (isScopedArgumentsSpeculation(prediction))
355         return &quot;&lt;ScopedArguments&gt;&quot;;
356     if (isStringObjectSpeculation(prediction))
357         return &quot;&lt;StringObject&gt;&quot;;
358     if (isRegExpObjectSpeculation(prediction))
359         return &quot;&lt;RegExpObject&gt;&quot;;
360     if (isStringOrStringObjectSpeculation(prediction))
361         return &quot;&lt;StringOrStringObject&gt;&quot;;
362     if (isObjectSpeculation(prediction))
363         return &quot;&lt;Object&gt;&quot;;
364     if (isCellSpeculation(prediction))
365         return &quot;&lt;Cell&gt;&quot;;
366     if (isBoolInt32Speculation(prediction))
367         return &quot;&lt;BoolInt32&gt;&quot;;
368     if (isInt32Speculation(prediction))
369         return &quot;&lt;Int32&gt;&quot;;
370     if (isAnyIntAsDoubleSpeculation(prediction))
371         return &quot;&lt;AnyIntAsDouble&gt;&quot;;
372     if (prediction == SpecNonInt32AsInt52)
373         return &quot;&lt;NonInt32AsInt52&gt;&quot;;
374     if (prediction == SpecInt32AsInt52)
375         return &quot;&lt;Int32AsInt52&gt;&quot;;
376     if (isAnyInt52Speculation(prediction))
377         return &quot;&lt;Int52Any&gt;&quot;;
378     if (isDoubleSpeculation(prediction))
379         return &quot;&lt;Double&gt;&quot;;
380     if (isFullNumberSpeculation(prediction))
381         return &quot;&lt;Number&gt;&quot;;
382     if (isBooleanSpeculation(prediction))
383         return &quot;&lt;Boolean&gt;&quot;;
384     if (isOtherSpeculation(prediction))
385         return &quot;&lt;Other&gt;&quot;;
386     if (isMiscSpeculation(prediction))
387         return &quot;&lt;Misc&gt;&quot;;
388     return &quot;&quot;;
389 }
390 
391 void dumpSpeculationAbbreviated(PrintStream&amp; out, SpeculatedType value)
392 {
393     out.print(speculationToAbbreviatedString(value));
394 }
395 
396 SpeculatedType speculationFromTypedArrayType(TypedArrayType type)
397 {
398     switch (type) {
399     case TypeInt8:
400         return SpecInt8Array;
401     case TypeInt16:
402         return SpecInt16Array;
403     case TypeInt32:
404         return SpecInt32Array;
405     case TypeUint8:
406         return SpecUint8Array;
407     case TypeUint8Clamped:
408         return SpecUint8ClampedArray;
409     case TypeUint16:
410         return SpecUint16Array;
411     case TypeUint32:
412         return SpecUint32Array;
413     case TypeFloat32:
414         return SpecFloat32Array;
415     case TypeFloat64:
416         return SpecFloat64Array;
417     case NotTypedArray:
418     case TypeDataView:
419         break;
420     }
421     RELEASE_ASSERT_NOT_REACHED();
422     return SpecNone;
423 }
424 
425 SpeculatedType speculationFromClassInfo(const ClassInfo* classInfo)
426 {
427     if (classInfo == JSString::info())
428         return SpecString;
429 
430     if (classInfo == Symbol::info())
431         return SpecSymbol;
432 
433     if (classInfo == JSBigInt::info())
434         return SpecBigInt;
435 
436     if (classInfo == JSFinalObject::info())
437         return SpecFinalObject;
438 
439     if (classInfo == JSArray::info())
440         return SpecArray;
441 
442     if (classInfo == DirectArguments::info())
443         return SpecDirectArguments;
444 
445     if (classInfo == ScopedArguments::info())
446         return SpecScopedArguments;
447 
448     if (classInfo == StringObject::info())
449         return SpecStringObject;
450 
451     if (classInfo == RegExpObject::info())
452         return SpecRegExpObject;
453 
<a name="5" id="anc5"></a><span class="line-added">454     if (classInfo == DateInstance::info())</span>
<span class="line-added">455         return SpecDateObject;</span>
<span class="line-added">456 </span>
457     if (classInfo == JSMap::info())
458         return SpecMapObject;
459 
460     if (classInfo == JSSet::info())
461         return SpecSetObject;
462 
463     if (classInfo == JSWeakMap::info())
464         return SpecWeakMapObject;
465 
466     if (classInfo == JSWeakSet::info())
467         return SpecWeakSetObject;
468 
469     if (classInfo == ProxyObject::info())
470         return SpecProxyObject;
471 
472     if (classInfo == JSDataView::info())
473         return SpecDataViewObject;
474 
475     if (classInfo-&gt;isSubClassOf(JSFunction::info())) {
476         if (classInfo == JSBoundFunction::info())
477             return SpecFunctionWithNonDefaultHasInstance;
478         return SpecFunctionWithDefaultHasInstance;
479     }
480 
<a name="6" id="anc6"></a><span class="line-added">481     if (classInfo-&gt;isSubClassOf(JSPromise::info()))</span>
<span class="line-added">482         return SpecPromiseObject;</span>
<span class="line-added">483 </span>
484     if (isTypedView(classInfo-&gt;typedArrayStorageType))
485         return speculationFromTypedArrayType(classInfo-&gt;typedArrayStorageType);
486 
487     if (classInfo-&gt;isSubClassOf(JSArray::info()))
488         return SpecDerivedArray;
489 
490     if (classInfo-&gt;isSubClassOf(JSObject::info()))
491         return SpecObjectOther;
492 
493     return SpecCellOther;
494 }
495 
496 SpeculatedType speculationFromStructure(Structure* structure)
497 {
498     if (structure-&gt;typeInfo().type() == StringType)
499         return SpecString;
500     if (structure-&gt;typeInfo().type() == SymbolType)
501         return SpecSymbol;
502     if (structure-&gt;typeInfo().type() == BigIntType)
503         return SpecBigInt;
504     if (structure-&gt;typeInfo().type() == DerivedArrayType)
505         return SpecDerivedArray;
506     return speculationFromClassInfo(structure-&gt;classInfo());
507 }
508 
509 SpeculatedType speculationFromCell(JSCell* cell)
510 {
511     if (cell-&gt;isString()) {
512         JSString* string = jsCast&lt;JSString*&gt;(cell);
513         if (const StringImpl* impl = string-&gt;tryGetValueImpl()) {
514             if (impl-&gt;isAtom())
515                 return SpecStringIdent;
516         }
517         return SpecString;
518     }
519     return speculationFromStructure(cell-&gt;structure());
520 }
521 
522 SpeculatedType speculationFromValue(JSValue value)
523 {
524     if (value.isEmpty())
525         return SpecEmpty;
526     if (value.isInt32()) {
527         if (value.asInt32() &amp; ~1)
528             return SpecNonBoolInt32;
529         return SpecBoolInt32;
530     }
531     if (value.isDouble()) {
532         double number = value.asNumber();
533         if (number != number)
534             return SpecDoublePureNaN;
535         if (value.isAnyInt())
536             return SpecAnyIntAsDouble;
537         return SpecNonIntAsDouble;
538     }
539     if (value.isCell())
540         return speculationFromCell(value.asCell());
541     if (value.isBoolean())
542         return SpecBoolean;
543     ASSERT(value.isUndefinedOrNull());
544     return SpecOther;
545 }
546 
547 SpeculatedType int52AwareSpeculationFromValue(JSValue value)
548 {
549     if (!value.isAnyInt())
550         return speculationFromValue(value);
551 
552     int64_t intValue = value.asAnyInt();
553     bool isI32 = static_cast&lt;int64_t&gt;(static_cast&lt;int32_t&gt;(intValue)) == intValue;
554     if (isI32)
555         return SpecInt32AsInt52;
556     return SpecNonInt32AsInt52;
557 }
558 
559 TypedArrayType typedArrayTypeFromSpeculation(SpeculatedType type)
560 {
561     if (isInt8ArraySpeculation(type))
562         return TypeInt8;
563 
564     if (isInt16ArraySpeculation(type))
565         return TypeInt16;
566 
567     if (isInt32ArraySpeculation(type))
568         return TypeInt32;
569 
570     if (isUint8ArraySpeculation(type))
571         return TypeUint8;
572 
573     if (isUint8ClampedArraySpeculation(type))
574         return TypeUint8Clamped;
575 
576     if (isUint16ArraySpeculation(type))
577         return TypeUint16;
578 
579     if (isUint32ArraySpeculation(type))
580         return TypeUint32;
581 
582     if (isFloat32ArraySpeculation(type))
583         return TypeFloat32;
584 
585     if (isFloat64ArraySpeculation(type))
586         return TypeFloat64;
587 
588     return NotTypedArray;
589 }
590 
<a name="7" id="anc7"></a><span class="line-modified">591 Optional&lt;SpeculatedType&gt; speculationFromJSType(JSType type)</span>
592 {
593     switch (type) {
594     case StringType:
595         return SpecString;
596     case SymbolType:
597         return SpecSymbol;
598     case BigIntType:
599         return SpecBigInt;
600     case ArrayType:
601         return SpecArray;
602     case DerivedArrayType:
603         return SpecDerivedArray;
604     case RegExpObjectType:
605         return SpecRegExpObject;
<a name="8" id="anc8"></a><span class="line-added">606     case JSDateType:</span>
<span class="line-added">607         return SpecDateObject;</span>
608     case ProxyObjectType:
609         return SpecProxyObject;
<a name="9" id="anc9"></a><span class="line-added">610     case JSPromiseType:</span>
<span class="line-added">611         return SpecPromiseObject;</span>
612     case JSMapType:
613         return SpecMapObject;
614     case JSSetType:
615         return SpecSetObject;
616     case JSWeakMapType:
617         return SpecWeakMapObject;
618     case JSWeakSetType:
619         return SpecWeakSetObject;
620     case DataViewType:
621         return SpecDataViewObject;
622     default:
<a name="10" id="anc10"></a><span class="line-modified">623         return WTF::nullopt;</span>
624     }
<a name="11" id="anc11"></a>
625 }
626 
627 SpeculatedType leastUpperBoundOfStrictlyEquivalentSpeculations(SpeculatedType type)
628 {
629     // SpecNonIntAsDouble includes negative zero (-0.0), which can be equal to 0 and 0.0 in the context of == and ===.
630     if (type &amp; (SpecIntAnyFormat | SpecNonIntAsDouble))
631         type |= (SpecIntAnyFormat | SpecNonIntAsDouble);
632 
633     if (type &amp; SpecString)
634         type |= SpecString;
635     return type;
636 }
637 
<a name="12" id="anc12"></a><span class="line-added">638 static inline SpeculatedType leastUpperBoundOfEquivalentSpeculations(SpeculatedType type)</span>
<span class="line-added">639 {</span>
<span class="line-added">640     type = leastUpperBoundOfStrictlyEquivalentSpeculations(type);</span>
<span class="line-added">641 </span>
<span class="line-added">642     // Boolean or BigInt can be converted to Number when performing non-strict equal.</span>
<span class="line-added">643     if (type &amp; (SpecIntAnyFormat | SpecNonIntAsDouble | SpecBoolean | SpecBigInt))</span>
<span class="line-added">644         type |= (SpecIntAnyFormat | SpecNonIntAsDouble | SpecBoolean | SpecBigInt);</span>
<span class="line-added">645 </span>
<span class="line-added">646     return type;</span>
<span class="line-added">647 }</span>
<span class="line-added">648 </span>
649 bool valuesCouldBeEqual(SpeculatedType a, SpeculatedType b)
650 {
<a name="13" id="anc13"></a><span class="line-modified">651     a = leastUpperBoundOfEquivalentSpeculations(a);</span>
<span class="line-modified">652     b = leastUpperBoundOfEquivalentSpeculations(b);</span>
653 
654     // Anything could be equal to a string.
655     if (a &amp; SpecString)
656         return true;
657     if (b &amp; SpecString)
658         return true;
659 
660     // If both sides are definitely only objects, then equality is fairly sane.
661     if (isObjectSpeculation(a) &amp;&amp; isObjectSpeculation(b))
662         return !!(a &amp; b);
663 
664     // If either side could be an object or not, then we could call toString or
665     // valueOf, which could return anything.
666     if (a &amp; SpecObject)
667         return true;
668     if (b &amp; SpecObject)
669         return true;
670 
671     // Neither side is an object or string, so the world is relatively sane.
672     return !!(a &amp; b);
673 }
674 
675 static SpeculatedType typeOfDoubleSumOrDifferenceOrProduct(SpeculatedType a, SpeculatedType b)
676 {
677     SpeculatedType result = a | b;
678 
679     if (result &amp; SpecNonIntAsDouble) {
680         // NaN can be produced by:
681         // Infinity - Infinity
682         // Infinity + (-Infinity)
683         // Infinity * 0
684         result |= SpecDoublePureNaN;
685     }
686 
687     // Impure NaN could become pure NaN during addition because addition may clear bits.
688     if (result &amp; SpecDoubleImpureNaN)
689         result |= SpecDoublePureNaN;
690     // Values could overflow, or fractions could become integers.
691     if (result &amp; SpecDoubleReal)
692         result |= SpecDoubleReal;
693     return result;
694 }
695 
696 SpeculatedType typeOfDoubleSum(SpeculatedType a, SpeculatedType b)
697 {
698     return typeOfDoubleSumOrDifferenceOrProduct(a, b);
699 }
700 
701 SpeculatedType typeOfDoubleDifference(SpeculatedType a, SpeculatedType b)
702 {
703     return typeOfDoubleSumOrDifferenceOrProduct(a, b);
704 }
705 
<a name="14" id="anc14"></a><span class="line-added">706 SpeculatedType typeOfDoubleIncOrDec(SpeculatedType t)</span>
<span class="line-added">707 {</span>
<span class="line-added">708     // Impure NaN could become pure NaN during addition because addition may clear bits.</span>
<span class="line-added">709     if (t &amp; SpecDoubleImpureNaN)</span>
<span class="line-added">710         t |= SpecDoublePureNaN;</span>
<span class="line-added">711     // Values could overflow, or fractions could become integers.</span>
<span class="line-added">712     if (t &amp; SpecDoubleReal)</span>
<span class="line-added">713         t |= SpecDoubleReal;</span>
<span class="line-added">714     return t;</span>
<span class="line-added">715 }</span>
<span class="line-added">716 </span>
717 SpeculatedType typeOfDoubleProduct(SpeculatedType a, SpeculatedType b)
718 {
719     return typeOfDoubleSumOrDifferenceOrProduct(a, b);
720 }
721 
722 static SpeculatedType polluteDouble(SpeculatedType value)
723 {
724     // Impure NaN could become pure NaN because the operation could clear some bits.
725     if (value &amp; SpecDoubleImpureNaN)
726         value |= SpecDoubleNaN;
727     // Values could overflow, fractions could become integers, or an error could produce
728     // PureNaN.
729     if (value &amp; SpecDoubleReal)
730         value |= SpecDoubleReal | SpecDoublePureNaN;
731     return value;
732 }
733 
734 SpeculatedType typeOfDoubleQuotient(SpeculatedType a, SpeculatedType b)
735 {
736     return polluteDouble(a | b);
737 }
738 
739 SpeculatedType typeOfDoubleMinMax(SpeculatedType a, SpeculatedType b)
740 {
741     SpeculatedType result = a | b;
742     // Impure NaN could become pure NaN during addition because addition may clear bits.
743     if (result &amp; SpecDoubleImpureNaN)
744         result |= SpecDoublePureNaN;
745     return result;
746 }
747 
748 SpeculatedType typeOfDoubleNegation(SpeculatedType value)
749 {
750     // Changing bits can make pure NaN impure and vice versa:
751     // 0xefff000000000000 (pure) - 0xffff000000000000 (impure)
752     if (value &amp; SpecDoubleNaN)
753         value |= SpecDoubleNaN;
754     // We could get negative zero, which mixes SpecAnyIntAsDouble and SpecNotIntAsDouble.
755     // We could also overflow a large negative int into something that is no longer
756     // representable as an int.
757     if (value &amp; SpecDoubleReal)
758         value |= SpecDoubleReal;
759     return value;
760 }
761 
762 SpeculatedType typeOfDoubleAbs(SpeculatedType value)
763 {
764     return typeOfDoubleNegation(value);
765 }
766 
767 SpeculatedType typeOfDoubleRounding(SpeculatedType value)
768 {
769     // Double Pure NaN can becomes impure when converted back from Float.
770     // and vice versa.
771     if (value &amp; SpecDoubleNaN)
772         value |= SpecDoubleNaN;
773     // We might lose bits, which leads to a value becoming integer-representable.
774     if (value &amp; SpecNonIntAsDouble)
775         value |= SpecAnyIntAsDouble;
776     return value;
777 }
778 
779 SpeculatedType typeOfDoublePow(SpeculatedType xValue, SpeculatedType yValue)
780 {
781     // Math.pow() always return NaN if the exponent is NaN, unlike std::pow().
782     // We always set a pure NaN in that case.
783     if (yValue &amp; SpecDoubleNaN)
784         xValue |= SpecDoublePureNaN;
785     // Handle the wierd case of NaN ^ 0, which returns 1. See https://tc39.github.io/ecma262/#sec-applying-the-exp-operator
786     if (xValue &amp; SpecDoubleNaN)
787         xValue |= SpecFullDouble;
788     return polluteDouble(xValue);
789 }
790 
791 SpeculatedType typeOfDoubleBinaryOp(SpeculatedType a, SpeculatedType b)
792 {
793     return polluteDouble(a | b);
794 }
795 
796 SpeculatedType typeOfDoubleUnaryOp(SpeculatedType value)
797 {
798     return polluteDouble(value);
799 }
800 
801 SpeculatedType speculationFromString(const char* speculation)
802 {
803     if (!strncmp(speculation, &quot;SpecNone&quot;, strlen(&quot;SpecNone&quot;)))
804         return SpecNone;
805     if (!strncmp(speculation, &quot;SpecFinalObject&quot;, strlen(&quot;SpecFinalObject&quot;)))
806         return SpecFinalObject;
807     if (!strncmp(speculation, &quot;SpecArray&quot;, strlen(&quot;SpecArray&quot;)))
808         return SpecArray;
809     if (!strncmp(speculation, &quot;SpecFunction&quot;, strlen(&quot;SpecFunction&quot;)))
810         return SpecFunction;
811     if (!strncmp(speculation, &quot;SpecInt8Array&quot;, strlen(&quot;SpecInt8Array&quot;)))
812         return SpecInt8Array;
813     if (!strncmp(speculation, &quot;SpecInt16Array&quot;, strlen(&quot;SpecInt16Array&quot;)))
814         return SpecInt16Array;
815     if (!strncmp(speculation, &quot;SpecInt32Array&quot;, strlen(&quot;SpecInt32Array&quot;)))
816         return SpecInt32Array;
817     if (!strncmp(speculation, &quot;SpecUint8Array&quot;, strlen(&quot;SpecUint8Array&quot;)))
818         return SpecUint8Array;
819     if (!strncmp(speculation, &quot;SpecUint8ClampedArray&quot;, strlen(&quot;SpecUint8ClampedArray&quot;)))
820         return SpecUint8ClampedArray;
821     if (!strncmp(speculation, &quot;SpecUint16Array&quot;, strlen(&quot;SpecUint16Array&quot;)))
822         return SpecUint16Array;
823     if (!strncmp(speculation, &quot;SpecUint32Array&quot;, strlen(&quot;SpecUint32Array&quot;)))
824         return SpecUint32Array;
825     if (!strncmp(speculation, &quot;SpecFloat32Array&quot;, strlen(&quot;SpecFloat32Array&quot;)))
826         return SpecFloat32Array;
827     if (!strncmp(speculation, &quot;SpecFloat64Array&quot;, strlen(&quot;SpecFloat64Array&quot;)))
828         return SpecFloat64Array;
829     if (!strncmp(speculation, &quot;SpecTypedArrayView&quot;, strlen(&quot;SpecTypedArrayView&quot;)))
830         return SpecTypedArrayView;
831     if (!strncmp(speculation, &quot;SpecDirectArguments&quot;, strlen(&quot;SpecDirectArguments&quot;)))
832         return SpecDirectArguments;
833     if (!strncmp(speculation, &quot;SpecScopedArguments&quot;, strlen(&quot;SpecScopedArguments&quot;)))
834         return SpecScopedArguments;
835     if (!strncmp(speculation, &quot;SpecStringObject&quot;, strlen(&quot;SpecStringObject&quot;)))
836         return SpecStringObject;
837     if (!strncmp(speculation, &quot;SpecRegExpObject&quot;, strlen(&quot;SpecRegExpObject&quot;)))
838         return SpecRegExpObject;
<a name="15" id="anc15"></a><span class="line-added">839     if (!strncmp(speculation, &quot;SpecDateObject&quot;, strlen(&quot;SpecDateObject&quot;)))</span>
<span class="line-added">840         return SpecDateObject;</span>
<span class="line-added">841     if (!strncmp(speculation, &quot;SpecPromiseObject&quot;, strlen(&quot;SpecPromiseObject&quot;)))</span>
<span class="line-added">842         return SpecPromiseObject;</span>
843     if (!strncmp(speculation, &quot;SpecMapObject&quot;, strlen(&quot;SpecMapObject&quot;)))
844         return SpecMapObject;
845     if (!strncmp(speculation, &quot;SpecSetObject&quot;, strlen(&quot;SpecSetObject&quot;)))
846         return SpecSetObject;
847     if (!strncmp(speculation, &quot;SpecWeakMapObject&quot;, strlen(&quot;SpecWeakMapObject&quot;)))
848         return SpecWeakMapObject;
849     if (!strncmp(speculation, &quot;SpecWeakSetObject&quot;, strlen(&quot;SpecWeakSetObject&quot;)))
850         return SpecWeakSetObject;
851     if (!strncmp(speculation, &quot;SpecProxyObject&quot;, strlen(&quot;SpecProxyObject&quot;)))
852         return SpecProxyObject;
853     if (!strncmp(speculation, &quot;SpecDerivedArray&quot;, strlen(&quot;SpecDerivedArray&quot;)))
854         return SpecDerivedArray;
855     if (!strncmp(speculation, &quot;SpecDataViewObject&quot;, strlen(&quot;SpecDataViewObject&quot;)))
856         return SpecDataViewObject;
857     if (!strncmp(speculation, &quot;SpecObjectOther&quot;, strlen(&quot;SpecObjectOther&quot;)))
858         return SpecObjectOther;
859     if (!strncmp(speculation, &quot;SpecObject&quot;, strlen(&quot;SpecObject&quot;)))
860         return SpecObject;
861     if (!strncmp(speculation, &quot;SpecStringIdent&quot;, strlen(&quot;SpecStringIdent&quot;)))
862         return SpecStringIdent;
863     if (!strncmp(speculation, &quot;SpecStringVar&quot;, strlen(&quot;SpecStringVar&quot;)))
864         return SpecStringVar;
865     if (!strncmp(speculation, &quot;SpecString&quot;, strlen(&quot;SpecString&quot;)))
866         return SpecString;
867     if (!strncmp(speculation, &quot;SpecSymbol&quot;, strlen(&quot;SpecSymbol&quot;)))
868         return SpecSymbol;
869     if (!strncmp(speculation, &quot;SpecBigInt&quot;, strlen(&quot;SpecBigInt&quot;)))
870         return SpecBigInt;
871     if (!strncmp(speculation, &quot;SpecCellOther&quot;, strlen(&quot;SpecCellOther&quot;)))
872         return SpecCellOther;
873     if (!strncmp(speculation, &quot;SpecCell&quot;, strlen(&quot;SpecCell&quot;)))
874         return SpecCell;
875     if (!strncmp(speculation, &quot;SpecBoolInt32&quot;, strlen(&quot;SpecBoolInt32&quot;)))
876         return SpecBoolInt32;
877     if (!strncmp(speculation, &quot;SpecNonBoolInt32&quot;, strlen(&quot;SpecNonBoolInt32&quot;)))
878         return SpecNonBoolInt32;
879     if (!strncmp(speculation, &quot;SpecInt32Only&quot;, strlen(&quot;SpecInt32Only&quot;)))
880         return SpecInt32Only;
881     if (!strncmp(speculation, &quot;SpecInt32AsInt52&quot;, strlen(&quot;SpecInt32AsInt52&quot;)))
882         return SpecInt32AsInt52;
883     if (!strncmp(speculation, &quot;SpecNonInt32AsInt52&quot;, strlen(&quot;SpecNonInt32AsInt52&quot;)))
884         return SpecNonInt32AsInt52;
885     if (!strncmp(speculation, &quot;SpecInt52Any&quot;, strlen(&quot;SpecInt52Any&quot;)))
886         return SpecInt52Any;
887     if (!strncmp(speculation, &quot;SpecIntAnyFormat&quot;, strlen(&quot;SpecIntAnyFormat&quot;)))
888         return SpecIntAnyFormat;
889     if (!strncmp(speculation, &quot;SpecAnyIntAsDouble&quot;, strlen(&quot;SpecAnyIntAsDouble&quot;)))
890         return SpecAnyIntAsDouble;
891     if (!strncmp(speculation, &quot;SpecNonIntAsDouble&quot;, strlen(&quot;SpecNonIntAsDouble&quot;)))
892         return SpecNonIntAsDouble;
893     if (!strncmp(speculation, &quot;SpecDoubleReal&quot;, strlen(&quot;SpecDoubleReal&quot;)))
894         return SpecDoubleReal;
895     if (!strncmp(speculation, &quot;SpecDoublePureNaN&quot;, strlen(&quot;SpecDoublePureNaN&quot;)))
896         return SpecDoublePureNaN;
897     if (!strncmp(speculation, &quot;SpecDoubleImpureNaN&quot;, strlen(&quot;SpecDoubleImpureNaN&quot;)))
898         return SpecDoubleImpureNaN;
899     if (!strncmp(speculation, &quot;SpecDoubleNaN&quot;, strlen(&quot;SpecDoubleNaN&quot;)))
900         return SpecDoubleNaN;
901     if (!strncmp(speculation, &quot;SpecBytecodeDouble&quot;, strlen(&quot;SpecBytecodeDouble&quot;)))
902         return SpecBytecodeDouble;
903     if (!strncmp(speculation, &quot;SpecFullDouble&quot;, strlen(&quot;SpecFullDouble&quot;)))
904         return SpecFullDouble;
905     if (!strncmp(speculation, &quot;SpecBytecodeRealNumber&quot;, strlen(&quot;SpecBytecodeRealNumber&quot;)))
906         return SpecBytecodeRealNumber;
907     if (!strncmp(speculation, &quot;SpecFullRealNumber&quot;, strlen(&quot;SpecFullRealNumber&quot;)))
908         return SpecFullRealNumber;
909     if (!strncmp(speculation, &quot;SpecBytecodeNumber&quot;, strlen(&quot;SpecBytecodeNumber&quot;)))
910         return SpecBytecodeNumber;
911     if (!strncmp(speculation, &quot;SpecFullNumber&quot;, strlen(&quot;SpecFullNumber&quot;)))
912         return SpecFullNumber;
913     if (!strncmp(speculation, &quot;SpecBoolean&quot;, strlen(&quot;SpecBoolean&quot;)))
914         return SpecBoolean;
915     if (!strncmp(speculation, &quot;SpecOther&quot;, strlen(&quot;SpecOther&quot;)))
916         return SpecOther;
917     if (!strncmp(speculation, &quot;SpecMisc&quot;, strlen(&quot;SpecMisc&quot;)))
918         return SpecMisc;
919     if (!strncmp(speculation, &quot;SpecHeapTop&quot;, strlen(&quot;SpecHeapTop&quot;)))
920         return SpecHeapTop;
921     if (!strncmp(speculation, &quot;SpecPrimitive&quot;, strlen(&quot;SpecPrimitive&quot;)))
922         return SpecPrimitive;
923     if (!strncmp(speculation, &quot;SpecEmpty&quot;, strlen(&quot;SpecEmpty&quot;)))
924         return SpecEmpty;
925     if (!strncmp(speculation, &quot;SpecBytecodeTop&quot;, strlen(&quot;SpecBytecodeTop&quot;)))
926         return SpecBytecodeTop;
927     if (!strncmp(speculation, &quot;SpecFullTop&quot;, strlen(&quot;SpecFullTop&quot;)))
928         return SpecFullTop;
929     if (!strncmp(speculation, &quot;SpecCellCheck&quot;, strlen(&quot;SpecCellCheck&quot;)))
930         return SpecCellCheck;
931     RELEASE_ASSERT_NOT_REACHED();
932 }
933 
934 } // namespace JSC
935 
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
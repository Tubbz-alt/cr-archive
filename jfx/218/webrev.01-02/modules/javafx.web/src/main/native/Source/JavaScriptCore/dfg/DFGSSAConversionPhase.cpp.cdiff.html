<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSSAConversionPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGRegisterBank.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSSALoweringPhase.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSSAConversionPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2013-2017 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 46,11 ***</span>
  } while (0)
  
  namespace JSC { namespace DFG {
  
  class SSAConversionPhase : public Phase {
<span class="line-modified">!     static const bool verbose = false;</span>
  
  public:
      SSAConversionPhase(Graph&amp; graph)
          : Phase(graph, &quot;SSA conversion&quot;)
          , m_insertionSet(graph)
<span class="line-new-header">--- 46,11 ---</span>
  } while (0)
  
  namespace JSC { namespace DFG {
  
  class SSAConversionPhase : public Phase {
<span class="line-modified">!     static constexpr bool verbose = false;</span>
  
  public:
      SSAConversionPhase(Graph&amp; graph)
          : Phase(graph, &quot;SSA conversion&quot;)
          , m_insertionSet(graph)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 95,18 ***</span>
                  ASSERT(oldRoot-&gt;predecessors.isEmpty());
                  oldRoot-&gt;predecessors.append(newRoot);
  
                  if (oldRoot-&gt;isCatchEntrypoint) {
                      ASSERT(!!entrypointIndex);
<span class="line-modified">!                     m_graph.m_entrypointIndexToCatchBytecodeOffset.add(entrypointIndex, oldRoot-&gt;bytecodeBegin);</span>
                  }
              }
  
              RELEASE_ASSERT(entrySwitchData-&gt;cases[0] == m_graph.block(0)); // We strongly assume the normal call entrypoint is the first item in the list.
  
              const bool exitOK = false;
<span class="line-modified">!             NodeOrigin origin { CodeOrigin(0), CodeOrigin(0), exitOK };</span>
              newRoot-&gt;appendNode(
                  m_graph, SpecNone, EntrySwitch, origin, OpInfo(entrySwitchData));
  
              m_graph.m_roots.clear();
              m_graph.m_roots.append(newRoot);
<span class="line-new-header">--- 95,18 ---</span>
                  ASSERT(oldRoot-&gt;predecessors.isEmpty());
                  oldRoot-&gt;predecessors.append(newRoot);
  
                  if (oldRoot-&gt;isCatchEntrypoint) {
                      ASSERT(!!entrypointIndex);
<span class="line-modified">!                     m_graph.m_entrypointIndexToCatchBytecodeIndex.add(entrypointIndex, oldRoot-&gt;bytecodeBegin);</span>
                  }
              }
  
              RELEASE_ASSERT(entrySwitchData-&gt;cases[0] == m_graph.block(0)); // We strongly assume the normal call entrypoint is the first item in the list.
  
              const bool exitOK = false;
<span class="line-modified">!             NodeOrigin origin { CodeOrigin(BytecodeIndex(0)), CodeOrigin(BytecodeIndex(0)), exitOK };</span>
              newRoot-&gt;appendNode(
                  m_graph, SpecNone, EntrySwitch, origin, OpInfo(entrySwitchData));
  
              m_graph.m_roots.clear();
              m_graph.m_roots.append(newRoot);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 156,12 ***</span>
                  else {
                      ASSERT(node-&gt;op() == SetArgumentDefinitely);
                      childNode = m_insertionSet.insertNode(
                          nodeIndex, node-&gt;variableAccessData()-&gt;prediction(),
                          GetStack, node-&gt;origin,
<span class="line-modified">!                         OpInfo(m_graph.m_stackAccessData.add(variable-&gt;local(), variable-&gt;flushFormat())));</span>
<span class="line-modified">!                     if (!ASSERT_DISABLED)</span>
                          m_argumentGetters.add(childNode);
                      m_argumentMapping.add(node, childNode);
                  }
  
                  calculator.newDef(
<span class="line-new-header">--- 156,12 ---</span>
                  else {
                      ASSERT(node-&gt;op() == SetArgumentDefinitely);
                      childNode = m_insertionSet.insertNode(
                          nodeIndex, node-&gt;variableAccessData()-&gt;prediction(),
                          GetStack, node-&gt;origin,
<span class="line-modified">!                         OpInfo(m_graph.m_stackAccessData.add(variable-&gt;operand(), variable-&gt;flushFormat())));</span>
<span class="line-modified">!                     if (ASSERT_ENABLED)</span>
                          m_argumentGetters.add(childNode);
                      m_argumentMapping.add(node, childNode);
                  }
  
                  calculator.newDef(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 176,11 ***</span>
          calculator.computePhis(
              [&amp;] (SSACalculator::Variable* ssaVariable, BasicBlock* block) -&gt; Node* {
                  VariableAccessData* variable = m_variableForSSAIndex[ssaVariable-&gt;index()];
  
                  // Prune by liveness. This doesn&#39;t buy us much other than compile times.
<span class="line-modified">!                 Node* headNode = block-&gt;variablesAtHead.operand(variable-&gt;local());</span>
                  if (!headNode)
                      return nullptr;
  
                  // There is the possibiltiy of &quot;rebirths&quot;. The SSA calculator will already prune
                  // rebirths for the same VariableAccessData. But it will not be able to prune
<span class="line-new-header">--- 176,11 ---</span>
          calculator.computePhis(
              [&amp;] (SSACalculator::Variable* ssaVariable, BasicBlock* block) -&gt; Node* {
                  VariableAccessData* variable = m_variableForSSAIndex[ssaVariable-&gt;index()];
  
                  // Prune by liveness. This doesn&#39;t buy us much other than compile times.
<span class="line-modified">!                 Node* headNode = block-&gt;variablesAtHead.operand(variable-&gt;operand());</span>
                  if (!headNode)
                      return nullptr;
  
                  // There is the possibiltiy of &quot;rebirths&quot;. The SSA calculator will already prune
                  // rebirths for the same VariableAccessData. But it will not be able to prune
</pre>
<hr />
<pre>
<span class="line-old-header">*** 298,11 ***</span>
                          // would not in turn have a replacement.
                          node = node-&gt;replacement();
                          ASSERT(!node-&gt;replacement());
                      }
                      if (verbose)
<span class="line-modified">!                         dataLog(&quot;Mapping: &quot;, VirtualRegister(valueForOperand.operandForIndex(i)), &quot; -&gt; &quot;, node, &quot;\n&quot;);</span>
                      valueForOperand[i] = node;
                  }
              }
  
              // Insert Phis by asking the calculator what phis there are in this block. Also update
<span class="line-new-header">--- 298,11 ---</span>
                          // would not in turn have a replacement.
                          node = node-&gt;replacement();
                          ASSERT(!node-&gt;replacement());
                      }
                      if (verbose)
<span class="line-modified">!                         dataLog(&quot;Mapping: &quot;, valueForOperand.operandForIndex(i), &quot; -&gt; &quot;, node, &quot;\n&quot;);</span>
                      valueForOperand[i] = node;
                  }
              }
  
              // Insert Phis by asking the calculator what phis there are in this block. Also update
</pre>
<hr />
<pre>
<span class="line-old-header">*** 311,15 ***</span>
              size_t phiInsertionPoint = 0;
              for (SSACalculator::Def* phiDef : calculator.phisForBlock(block)) {
                  VariableAccessData* variable = m_variableForSSAIndex[phiDef-&gt;variable()-&gt;index()];
  
                  m_insertionSet.insert(phiInsertionPoint, phiDef-&gt;value());
<span class="line-modified">!                 valueForOperand.operand(variable-&gt;local()) = phiDef-&gt;value();</span>
  
                  m_insertionSet.insertNode(
                      phiInsertionPoint, SpecNone, MovHint, block-&gt;at(0)-&gt;origin.withInvalidExit(),
<span class="line-modified">!                     OpInfo(variable-&gt;local().offset()), phiDef-&gt;value()-&gt;defaultEdge());</span>
              }
  
              if (block-&gt;at(0)-&gt;origin.exitOK)
                  m_insertionSet.insertNode(phiInsertionPoint, SpecNone, ExitOK, block-&gt;at(0)-&gt;origin);
  
<span class="line-new-header">--- 311,15 ---</span>
              size_t phiInsertionPoint = 0;
              for (SSACalculator::Def* phiDef : calculator.phisForBlock(block)) {
                  VariableAccessData* variable = m_variableForSSAIndex[phiDef-&gt;variable()-&gt;index()];
  
                  m_insertionSet.insert(phiInsertionPoint, phiDef-&gt;value());
<span class="line-modified">!                 valueForOperand.operand(variable-&gt;operand()) = phiDef-&gt;value();</span>
  
                  m_insertionSet.insertNode(
                      phiInsertionPoint, SpecNone, MovHint, block-&gt;at(0)-&gt;origin.withInvalidExit(),
<span class="line-modified">!                     OpInfo(variable-&gt;operand()), phiDef-&gt;value()-&gt;defaultEdge());</span>
              }
  
              if (block-&gt;at(0)-&gt;origin.exitOK)
                  m_insertionSet.insertNode(phiInsertionPoint, SpecNone, ExitOK, block-&gt;at(0)-&gt;origin);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 335,11 ***</span>
  
                  switch (node-&gt;op()) {
                  case MovHint: {
                      m_insertionSet.insertNode(
                          nodeIndex, SpecNone, KillStack, node-&gt;origin,
<span class="line-modified">!                         OpInfo(node-&gt;unlinkedLocal().offset()));</span>
                      node-&gt;origin.exitOK = false; // KillStack clobbers exit.
                      break;
                  }
  
                  case SetLocal: {
<span class="line-new-header">--- 335,11 ---</span>
  
                  switch (node-&gt;op()) {
                  case MovHint: {
                      m_insertionSet.insertNode(
                          nodeIndex, SpecNone, KillStack, node-&gt;origin,
<span class="line-modified">!                         OpInfo(node-&gt;unlinkedOperand()));</span>
                      node-&gt;origin.exitOK = false; // KillStack clobbers exit.
                      break;
                  }
  
                  case SetLocal: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 347,34 ***</span>
                      Node* child = node-&gt;child1().node();
  
                      if (!!(node-&gt;flags() &amp; NodeIsFlushed)) {
                          node-&gt;convertToPutStack(
                              m_graph.m_stackAccessData.add(
<span class="line-modified">!                                 variable-&gt;local(), variable-&gt;flushFormat()));</span>
                      } else
                          node-&gt;remove(m_graph);
  
                      if (verbose)
<span class="line-modified">!                         dataLog(&quot;Mapping: &quot;, variable-&gt;local(), &quot; -&gt; &quot;, child, &quot;\n&quot;);</span>
<span class="line-modified">!                     valueForOperand.operand(variable-&gt;local()) = child;</span>
                      break;
                  }
  
                  case GetStack: {
                      ASSERT(m_argumentGetters.contains(node));
<span class="line-modified">!                     valueForOperand.operand(node-&gt;stackAccessData()-&gt;local) = node;</span>
                      break;
                  }
  
                  case GetLocal: {
                      VariableAccessData* variable = node-&gt;variableAccessData();
                      node-&gt;children.reset();
  
                      node-&gt;remove(m_graph);
                      if (verbose)
<span class="line-modified">!                         dataLog(&quot;Replacing node &quot;, node, &quot; with &quot;, valueForOperand.operand(variable-&gt;local()), &quot;\n&quot;);</span>
<span class="line-modified">!                     node-&gt;setReplacement(valueForOperand.operand(variable-&gt;local()));</span>
                      break;
                  }
  
                  case Flush: {
                      node-&gt;children.reset();
<span class="line-new-header">--- 347,34 ---</span>
                      Node* child = node-&gt;child1().node();
  
                      if (!!(node-&gt;flags() &amp; NodeIsFlushed)) {
                          node-&gt;convertToPutStack(
                              m_graph.m_stackAccessData.add(
<span class="line-modified">!                                 variable-&gt;operand(), variable-&gt;flushFormat()));</span>
                      } else
                          node-&gt;remove(m_graph);
  
                      if (verbose)
<span class="line-modified">!                         dataLog(&quot;Mapping: &quot;, variable-&gt;operand(), &quot; -&gt; &quot;, child, &quot;\n&quot;);</span>
<span class="line-modified">!                     valueForOperand.operand(variable-&gt;operand()) = child;</span>
                      break;
                  }
  
                  case GetStack: {
                      ASSERT(m_argumentGetters.contains(node));
<span class="line-modified">!                     valueForOperand.operand(node-&gt;stackAccessData()-&gt;operand) = node;</span>
                      break;
                  }
  
                  case GetLocal: {
                      VariableAccessData* variable = node-&gt;variableAccessData();
                      node-&gt;children.reset();
  
                      node-&gt;remove(m_graph);
                      if (verbose)
<span class="line-modified">!                         dataLog(&quot;Replacing node &quot;, node, &quot; with &quot;, valueForOperand.operand(variable-&gt;operand()), &quot;\n&quot;);</span>
<span class="line-modified">!                     node-&gt;setReplacement(valueForOperand.operand(variable-&gt;operand()));</span>
                      break;
                  }
  
                  case Flush: {
                      node-&gt;children.reset();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 383,11 ***</span>
                  }
  
                  case PhantomLocal: {
                      ASSERT(node-&gt;child1().useKind() == UntypedUse);
                      VariableAccessData* variable = node-&gt;variableAccessData();
<span class="line-modified">!                     node-&gt;child1() = valueForOperand.operand(variable-&gt;local())-&gt;defaultEdge();</span>
                      node-&gt;remove(m_graph);
                      break;
                  }
  
                  case SetArgumentDefinitely: {
<span class="line-new-header">--- 383,11 ---</span>
                  }
  
                  case PhantomLocal: {
                      ASSERT(node-&gt;child1().useKind() == UntypedUse);
                      VariableAccessData* variable = node-&gt;variableAccessData();
<span class="line-modified">!                     node-&gt;child1() = valueForOperand.operand(variable-&gt;operand())-&gt;defaultEdge();</span>
                      node-&gt;remove(m_graph);
                      break;
                  }
  
                  case SetArgumentDefinitely: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 423,14 ***</span>
                      // We can use an unchecked use kind because the SetLocal was turned into a Check.
                      // We have to use an unchecked use because at least sometimes, the end of the block
                      // is not exitOK.
                      UseKind useKind = uncheckedUseKindFor(format);
  
                      m_insertionSet.insertNode(
                          upsilonInsertionPoint, SpecNone, Upsilon, upsilonOrigin,
                          OpInfo(phiNode), Edge(
<span class="line-modified">!                             valueForOperand.operand(variable-&gt;local()),</span>
                              useKind));
                  }
              }
  
              m_insertionSet.execute(block);
<span class="line-new-header">--- 423,16 ---</span>
                      // We can use an unchecked use kind because the SetLocal was turned into a Check.
                      // We have to use an unchecked use because at least sometimes, the end of the block
                      // is not exitOK.
                      UseKind useKind = uncheckedUseKindFor(format);
  
<span class="line-added">+                     dataLogLnIf(verbose, &quot;Inserting Upsilon for &quot;, variable-&gt;operand(), &quot; propagating &quot;, valueForOperand.operand(variable-&gt;operand()), &quot; to &quot;, phiNode);</span>
<span class="line-added">+ </span>
                      m_insertionSet.insertNode(
                          upsilonInsertionPoint, SpecNone, Upsilon, upsilonOrigin,
                          OpInfo(phiNode), Edge(
<span class="line-modified">!                             valueForOperand.operand(variable-&gt;operand()),</span>
                              useKind));
                  }
              }
  
              m_insertionSet.execute(block);
</pre>
<center><a href="DFGRegisterBank.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSSALoweringPhase.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
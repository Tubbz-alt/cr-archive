<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSModuleLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2015-2019 Apple Inc. All Rights Reserved.
  3  * Copyright (C) 2016 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;JSModuleLoader.h&quot;
 29 
 30 #include &quot;BuiltinNames.h&quot;
 31 #include &quot;CatchScope.h&quot;
 32 #include &quot;CodeProfiling.h&quot;
 33 #include &quot;Error.h&quot;
 34 #include &quot;Exception.h&quot;
 35 #include &quot;JSCInlines.h&quot;
 36 #include &quot;JSGlobalObjectFunctions.h&quot;
 37 #include &quot;JSInternalPromise.h&quot;
<a name="1" id="anc1"></a><span class="line-removed"> 38 #include &quot;JSInternalPromiseDeferred.h&quot;</span>
 39 #include &quot;JSMap.h&quot;
 40 #include &quot;JSModuleEnvironment.h&quot;
 41 #include &quot;JSModuleNamespaceObject.h&quot;
 42 #include &quot;JSModuleRecord.h&quot;
 43 #include &quot;JSSourceCode.h&quot;
 44 #include &quot;JSWebAssembly.h&quot;
 45 #include &quot;ModuleAnalyzer.h&quot;
 46 #include &quot;Nodes.h&quot;
 47 #include &quot;ObjectConstructor.h&quot;
 48 #include &quot;Parser.h&quot;
 49 #include &quot;ParserError.h&quot;
 50 
 51 namespace JSC {
 52 
<a name="2" id="anc2"></a><span class="line-modified"> 53 static EncodedJSValue JSC_HOST_CALL moduleLoaderParseModule(ExecState*);</span>
<span class="line-modified"> 54 static EncodedJSValue JSC_HOST_CALL moduleLoaderRequestedModules(ExecState*);</span>
<span class="line-modified"> 55 static EncodedJSValue JSC_HOST_CALL moduleLoaderEvaluate(ExecState*);</span>
<span class="line-modified"> 56 static EncodedJSValue JSC_HOST_CALL moduleLoaderModuleDeclarationInstantiation(ExecState*);</span>
<span class="line-modified"> 57 static EncodedJSValue JSC_HOST_CALL moduleLoaderResolve(ExecState*);</span>
<span class="line-modified"> 58 static EncodedJSValue JSC_HOST_CALL moduleLoaderResolveSync(ExecState*);</span>
<span class="line-modified"> 59 static EncodedJSValue JSC_HOST_CALL moduleLoaderFetch(ExecState*);</span>
<span class="line-modified"> 60 static EncodedJSValue JSC_HOST_CALL moduleLoaderGetModuleNamespaceObject(ExecState*);</span>
 61 
 62 }
 63 
 64 #include &quot;JSModuleLoader.lut.h&quot;
 65 
 66 namespace JSC {
 67 
 68 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(JSModuleLoader);
 69 
 70 const ClassInfo JSModuleLoader::s_info = { &quot;ModuleLoader&quot;, &amp;Base::s_info, &amp;moduleLoaderTable, nullptr, CREATE_METHOD_TABLE(JSModuleLoader) };
 71 
 72 /* Source for JSModuleLoader.lut.h
 73 @begin moduleLoaderTable
 74     ensureRegistered               JSBuiltin                                  DontEnum|Function 1
 75     forceFulfillPromise            JSBuiltin                                  DontEnum|Function 2
 76     fulfillFetch                   JSBuiltin                                  DontEnum|Function 2
 77     requestFetch                   JSBuiltin                                  DontEnum|Function 3
 78     requestInstantiate             JSBuiltin                                  DontEnum|Function 3
 79     requestSatisfy                 JSBuiltin                                  DontEnum|Function 3
 80     link                           JSBuiltin                                  DontEnum|Function 2
 81     moduleDeclarationInstantiation moduleLoaderModuleDeclarationInstantiation DontEnum|Function 2
 82     moduleEvaluation               JSBuiltin                                  DontEnum|Function 2
 83     evaluate                       moduleLoaderEvaluate                       DontEnum|Function 3
 84     provideFetch                   JSBuiltin                                  DontEnum|Function 2
 85     loadAndEvaluateModule          JSBuiltin                                  DontEnum|Function 3
 86     loadModule                     JSBuiltin                                  DontEnum|Function 3
 87     linkAndEvaluateModule          JSBuiltin                                  DontEnum|Function 2
 88     requestImportModule            JSBuiltin                                  DontEnum|Function 3
 89     dependencyKeysIfEvaluated      JSBuiltin                                  DontEnum|Function 1
 90     getModuleNamespaceObject       moduleLoaderGetModuleNamespaceObject       DontEnum|Function 1
 91     parseModule                    moduleLoaderParseModule                    DontEnum|Function 2
 92     requestedModules               moduleLoaderRequestedModules               DontEnum|Function 1
 93     resolve                        moduleLoaderResolve                        DontEnum|Function 2
 94     resolveSync                    moduleLoaderResolveSync                    DontEnum|Function 2
 95     fetch                          moduleLoaderFetch                          DontEnum|Function 3
 96 @end
 97 */
 98 
 99 JSModuleLoader::JSModuleLoader(VM&amp; vm, Structure* structure)
100     : JSNonFinalObject(vm, structure)
101 {
102 }
103 
<a name="3" id="anc3"></a><span class="line-modified">104 void JSModuleLoader::finishCreation(ExecState* exec, VM&amp; vm, JSGlobalObject* globalObject)</span>
105 {
106     auto scope = DECLARE_CATCH_SCOPE(vm);
107 
108     Base::finishCreation(vm);
109     ASSERT(inherits(vm, info()));
<a name="4" id="anc4"></a><span class="line-modified">110     JSMap* map = JSMap::create(exec, vm, globalObject-&gt;mapStructure());</span>
111     scope.releaseAssertNoException();
112     putDirect(vm, Identifier::fromString(vm, &quot;registry&quot;), map);
113 }
114 
115 // ------------------------------ Functions --------------------------------
116 
<a name="5" id="anc5"></a><span class="line-modified">117 static String printableModuleKey(ExecState* exec, JSValue key)</span>
118 {
<a name="6" id="anc6"></a><span class="line-modified">119     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">120     auto scope = DECLARE_THROW_SCOPE(vm);</span>
121     if (key.isString() || key.isSymbol()) {
<a name="7" id="anc7"></a><span class="line-modified">122         auto propertyName = key.toPropertyKey(exec);</span>
123         scope.assertNoException(); // This is OK since this function is just for debugging purpose.
124         return propertyName.impl();
125     }
126     return vm.propertyNames-&gt;emptyIdentifier.impl();
127 }
128 
<a name="8" id="anc8"></a><span class="line-modified">129 JSArray* JSModuleLoader::dependencyKeysIfEvaluated(ExecState* exec, JSValue key)</span>
130 {
<a name="9" id="anc9"></a><span class="line-modified">131     VM&amp; vm = exec-&gt;vm();</span>
132     auto scope = DECLARE_THROW_SCOPE(vm);
133 
<a name="10" id="anc10"></a><span class="line-modified">134     JSObject* function = jsCast&lt;JSObject*&gt;(get(exec, vm.propertyNames-&gt;builtinNames().dependencyKeysIfEvaluatedPublicName()));</span>
135     RETURN_IF_EXCEPTION(scope, nullptr);
136     CallData callData;
137     CallType callType = JSC::getCallData(vm, function, callData);
138     ASSERT(callType != CallType::None);
139 
140     MarkedArgumentBuffer arguments;
141     arguments.append(key);
142 
<a name="11" id="anc11"></a><span class="line-modified">143     JSValue result = call(exec, function, callType, callData, this, arguments);</span>
144     RETURN_IF_EXCEPTION(scope, nullptr);
145 
146     return jsDynamicCast&lt;JSArray*&gt;(vm, result);
147 }
148 
<a name="12" id="anc12"></a><span class="line-modified">149 JSValue JSModuleLoader::provideFetch(ExecState* exec, JSValue key, const SourceCode&amp; sourceCode)</span>
150 {
<a name="13" id="anc13"></a><span class="line-modified">151     VM&amp; vm = exec-&gt;vm();</span>
152     auto scope = DECLARE_THROW_SCOPE(vm);
153 
<a name="14" id="anc14"></a><span class="line-modified">154     JSObject* function = jsCast&lt;JSObject*&gt;(get(exec, vm.propertyNames-&gt;builtinNames().provideFetchPublicName()));</span>
155     RETURN_IF_EXCEPTION(scope, { });
156     CallData callData;
157     CallType callType = JSC::getCallData(vm, function, callData);
158     ASSERT(callType != CallType::None);
159 
160     SourceCode source { sourceCode };
161     MarkedArgumentBuffer arguments;
162     arguments.append(key);
163     arguments.append(JSSourceCode::create(vm, WTFMove(source)));
164     ASSERT(!arguments.hasOverflowed());
165 
<a name="15" id="anc15"></a><span class="line-modified">166     RELEASE_AND_RETURN(scope, call(exec, function, callType, callData, this, arguments));</span>
167 }
168 
<a name="16" id="anc16"></a><span class="line-modified">169 JSInternalPromise* JSModuleLoader::loadAndEvaluateModule(ExecState* exec, JSValue moduleName, JSValue parameters, JSValue scriptFetcher)</span>
170 {
<a name="17" id="anc17"></a><span class="line-modified">171     VM&amp; vm = exec-&gt;vm();</span>
172     auto scope = DECLARE_THROW_SCOPE(vm);
173 
<a name="18" id="anc18"></a><span class="line-modified">174     JSObject* function = jsCast&lt;JSObject*&gt;(get(exec, vm.propertyNames-&gt;builtinNames().loadAndEvaluateModulePublicName()));</span>
175     RETURN_IF_EXCEPTION(scope, nullptr);
176     CallData callData;
177     CallType callType = JSC::getCallData(vm, function, callData);
178     ASSERT(callType != CallType::None);
179 
180     MarkedArgumentBuffer arguments;
181     arguments.append(moduleName);
182     arguments.append(parameters);
183     arguments.append(scriptFetcher);
184     ASSERT(!arguments.hasOverflowed());
185 
<a name="19" id="anc19"></a><span class="line-modified">186     JSValue promise = call(exec, function, callType, callData, this, arguments);</span>
187     RETURN_IF_EXCEPTION(scope, nullptr);
188     return jsCast&lt;JSInternalPromise*&gt;(promise);
189 }
190 
<a name="20" id="anc20"></a><span class="line-modified">191 JSInternalPromise* JSModuleLoader::loadModule(ExecState* exec, JSValue moduleName, JSValue parameters, JSValue scriptFetcher)</span>
192 {
<a name="21" id="anc21"></a><span class="line-modified">193     VM&amp; vm = exec-&gt;vm();</span>
194     auto scope = DECLARE_THROW_SCOPE(vm);
195 
<a name="22" id="anc22"></a><span class="line-modified">196     JSObject* function = jsCast&lt;JSObject*&gt;(get(exec, vm.propertyNames-&gt;builtinNames().loadModulePublicName()));</span>
197     RETURN_IF_EXCEPTION(scope, nullptr);
198     CallData callData;
199     CallType callType = JSC::getCallData(vm, function, callData);
200     ASSERT(callType != CallType::None);
201 
202     MarkedArgumentBuffer arguments;
203     arguments.append(moduleName);
204     arguments.append(parameters);
205     arguments.append(scriptFetcher);
206     ASSERT(!arguments.hasOverflowed());
207 
<a name="23" id="anc23"></a><span class="line-modified">208     JSValue promise = call(exec, function, callType, callData, this, arguments);</span>
209     RETURN_IF_EXCEPTION(scope, nullptr);
210     return jsCast&lt;JSInternalPromise*&gt;(promise);
211 }
212 
<a name="24" id="anc24"></a><span class="line-modified">213 JSValue JSModuleLoader::linkAndEvaluateModule(ExecState* exec, JSValue moduleKey, JSValue scriptFetcher)</span>
214 {
<a name="25" id="anc25"></a><span class="line-modified">215     VM&amp; vm = exec-&gt;vm();</span>
216     auto scope = DECLARE_THROW_SCOPE(vm);
217 
<a name="26" id="anc26"></a><span class="line-modified">218     JSObject* function = jsCast&lt;JSObject*&gt;(get(exec, vm.propertyNames-&gt;builtinNames().linkAndEvaluateModulePublicName()));</span>
219     RETURN_IF_EXCEPTION(scope, { });
220     CallData callData;
221     CallType callType = JSC::getCallData(vm, function, callData);
222     ASSERT(callType != CallType::None);
223 
224     MarkedArgumentBuffer arguments;
225     arguments.append(moduleKey);
226     arguments.append(scriptFetcher);
227     ASSERT(!arguments.hasOverflowed());
228 
<a name="27" id="anc27"></a><span class="line-modified">229     RELEASE_AND_RETURN(scope, call(exec, function, callType, callData, this, arguments));</span>
230 }
231 
<a name="28" id="anc28"></a><span class="line-modified">232 JSInternalPromise* JSModuleLoader::requestImportModule(ExecState* exec, const Identifier&amp; moduleKey, JSValue parameters, JSValue scriptFetcher)</span>
233 {
<a name="29" id="anc29"></a><span class="line-modified">234     VM&amp; vm = exec-&gt;vm();</span>
235     auto scope = DECLARE_THROW_SCOPE(vm);
236 
<a name="30" id="anc30"></a><span class="line-modified">237     auto* function = jsCast&lt;JSObject*&gt;(get(exec, vm.propertyNames-&gt;builtinNames().requestImportModulePublicName()));</span>
238     RETURN_IF_EXCEPTION(scope, nullptr);
239     CallData callData;
240     auto callType = JSC::getCallData(vm, function, callData);
241     ASSERT(callType != CallType::None);
242 
243     MarkedArgumentBuffer arguments;
244     arguments.append(jsString(vm, moduleKey.impl()));
245     arguments.append(parameters);
246     arguments.append(scriptFetcher);
247     ASSERT(!arguments.hasOverflowed());
248 
<a name="31" id="anc31"></a><span class="line-modified">249     JSValue promise = call(exec, function, callType, callData, this, arguments);</span>
250     RETURN_IF_EXCEPTION(scope, nullptr);
251     return jsCast&lt;JSInternalPromise*&gt;(promise);
252 }
253 
<a name="32" id="anc32"></a><span class="line-modified">254 JSInternalPromise* JSModuleLoader::importModule(ExecState* exec, JSString* moduleName, JSValue parameters, const SourceOrigin&amp; referrer)</span>
255 {
<a name="33" id="anc33"></a><span class="line-modified">256     if (Options::dumpModuleLoadingState())</span>
<span class="line-removed">257         dataLog(&quot;Loader [import] &quot;, printableModuleKey(exec, moduleName), &quot;\n&quot;);</span>
258 
<a name="34" id="anc34"></a><span class="line-removed">259     auto* globalObject = exec-&gt;lexicalGlobalObject();</span>
260     VM&amp; vm = globalObject-&gt;vm();
261     auto throwScope = DECLARE_THROW_SCOPE(vm);
262 
263     if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderImportModule)
<a name="35" id="anc35"></a><span class="line-modified">264         RELEASE_AND_RETURN(throwScope, globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderImportModule(globalObject, exec, this, moduleName, parameters, referrer));</span>
265 
<a name="36" id="anc36"></a><span class="line-modified">266     auto* deferred = JSInternalPromiseDeferred::tryCreate(exec, globalObject);</span>
<span class="line-removed">267     RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
268 
269     auto catchScope = DECLARE_CATCH_SCOPE(vm);
<a name="37" id="anc37"></a><span class="line-modified">270     auto moduleNameString = moduleName-&gt;value(exec);</span>
271     if (UNLIKELY(catchScope.exception())) {
272         JSValue exception = catchScope.exception()-&gt;value();
273         catchScope.clearException();
<a name="38" id="anc38"></a><span class="line-modified">274         deferred-&gt;reject(exec, exception);</span>
275         catchScope.clearException();
<a name="39" id="anc39"></a><span class="line-modified">276         return deferred-&gt;promise();</span>
277     }
<a name="40" id="anc40"></a><span class="line-modified">278     deferred-&gt;reject(exec, createError(exec, makeString(&quot;Could not import the module &#39;&quot;, moduleNameString, &quot;&#39;.&quot;)));</span>
279     catchScope.clearException();
<a name="41" id="anc41"></a><span class="line-modified">280     return deferred-&gt;promise();</span>
281 }
282 
<a name="42" id="anc42"></a><span class="line-modified">283 Identifier JSModuleLoader::resolveSync(ExecState* exec, JSValue name, JSValue referrer, JSValue scriptFetcher)</span>
284 {
<a name="43" id="anc43"></a><span class="line-modified">285     if (Options::dumpModuleLoadingState())</span>
<span class="line-removed">286         dataLog(&quot;Loader [resolve] &quot;, printableModuleKey(exec, name), &quot;\n&quot;);</span>
287 
<a name="44" id="anc44"></a><span class="line-removed">288     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
289     if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderResolve)
<a name="45" id="anc45"></a><span class="line-modified">290         return globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderResolve(globalObject, exec, this, name, referrer, scriptFetcher);</span>
<span class="line-modified">291     return name.toPropertyKey(exec);</span>
292 }
293 
<a name="46" id="anc46"></a><span class="line-modified">294 JSInternalPromise* JSModuleLoader::resolve(ExecState* exec, JSValue name, JSValue referrer, JSValue scriptFetcher)</span>
295 {
<a name="47" id="anc47"></a><span class="line-modified">296     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">297     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
298 
<a name="48" id="anc48"></a><span class="line-modified">299     JSInternalPromiseDeferred* deferred = JSInternalPromiseDeferred::tryCreate(exec, exec-&gt;lexicalGlobalObject());</span>
<span class="line-removed">300     RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
301 
302     auto catchScope = DECLARE_CATCH_SCOPE(vm);
303 
<a name="49" id="anc49"></a><span class="line-modified">304     const Identifier moduleKey = resolveSync(exec, name, referrer, scriptFetcher);</span>
305     if (UNLIKELY(catchScope.exception())) {
306         JSValue exception = catchScope.exception();
307         catchScope.clearException();
<a name="50" id="anc50"></a><span class="line-modified">308         auto result = deferred-&gt;reject(exec, exception);</span>
309         catchScope.clearException();
<a name="51" id="anc51"></a><span class="line-modified">310         return result;</span>
311     }
<a name="52" id="anc52"></a><span class="line-modified">312     auto result = deferred-&gt;resolve(exec, identifierToJSValue(vm, moduleKey));</span>
313     catchScope.clearException();
<a name="53" id="anc53"></a><span class="line-modified">314     return result;</span>
315 }
316 
<a name="54" id="anc54"></a><span class="line-modified">317 JSInternalPromise* JSModuleLoader::fetch(ExecState* exec, JSValue key, JSValue parameters, JSValue scriptFetcher)</span>
318 {
<a name="55" id="anc55"></a><span class="line-modified">319     if (Options::dumpModuleLoadingState())</span>
<span class="line-removed">320         dataLog(&quot;Loader [fetch] &quot;, printableModuleKey(exec, key), &quot;\n&quot;);</span>
321 
<a name="56" id="anc56"></a><span class="line-removed">322     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
323     VM&amp; vm = globalObject-&gt;vm();
324     auto throwScope = DECLARE_THROW_SCOPE(vm);
325 
326     if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderFetch)
<a name="57" id="anc57"></a><span class="line-modified">327         RELEASE_AND_RETURN(throwScope, globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderFetch(globalObject, exec, this, key, parameters, scriptFetcher));</span>
328 
<a name="58" id="anc58"></a><span class="line-modified">329     JSInternalPromiseDeferred* deferred = JSInternalPromiseDeferred::tryCreate(exec, globalObject);</span>
<span class="line-removed">330     RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
331 
332     auto catchScope = DECLARE_CATCH_SCOPE(vm);
333 
<a name="59" id="anc59"></a><span class="line-modified">334     String moduleKey = key.toWTFString(exec);</span>
335     if (UNLIKELY(catchScope.exception())) {
336         JSValue exception = catchScope.exception()-&gt;value();
337         catchScope.clearException();
<a name="60" id="anc60"></a><span class="line-modified">338         deferred-&gt;reject(exec, exception);</span>
339         catchScope.clearException();
<a name="61" id="anc61"></a><span class="line-modified">340         return deferred-&gt;promise();</span>
341     }
<a name="62" id="anc62"></a><span class="line-modified">342     deferred-&gt;reject(exec, createError(exec, makeString(&quot;Could not open the module &#39;&quot;, moduleKey, &quot;&#39;.&quot;)));</span>
343     catchScope.clearException();
<a name="63" id="anc63"></a><span class="line-modified">344     return deferred-&gt;promise();</span>
345 }
346 
<a name="64" id="anc64"></a><span class="line-modified">347 JSObject* JSModuleLoader::createImportMetaProperties(ExecState* exec, JSValue key, JSModuleRecord* moduleRecord, JSValue scriptFetcher)</span>
348 {
<a name="65" id="anc65"></a><span class="line-removed">349     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
350     if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderCreateImportMetaProperties)
<a name="66" id="anc66"></a><span class="line-modified">351         return globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderCreateImportMetaProperties(globalObject, exec, this, key, moduleRecord, scriptFetcher);</span>
<span class="line-modified">352     return constructEmptyObject(exec, exec-&gt;lexicalGlobalObject()-&gt;nullPrototypeObjectStructure());</span>
353 }
354 
<a name="67" id="anc67"></a><span class="line-modified">355 JSValue JSModuleLoader::evaluate(ExecState* exec, JSValue key, JSValue moduleRecordValue, JSValue scriptFetcher)</span>
356 {
<a name="68" id="anc68"></a><span class="line-modified">357     if (Options::dumpModuleLoadingState())</span>
<span class="line-removed">358         dataLog(&quot;Loader [evaluate] &quot;, printableModuleKey(exec, key), &quot;\n&quot;);</span>
359 
<a name="69" id="anc69"></a><span class="line-removed">360     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
361     if (globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderEvaluate)
<a name="70" id="anc70"></a><span class="line-modified">362         return globalObject-&gt;globalObjectMethodTable()-&gt;moduleLoaderEvaluate(globalObject, exec, this, key, moduleRecordValue, scriptFetcher);</span>
363 
<a name="71" id="anc71"></a><span class="line-modified">364     return evaluateNonVirtual(exec, key, moduleRecordValue, scriptFetcher);</span>
365 }
366 
<a name="72" id="anc72"></a><span class="line-modified">367 JSValue JSModuleLoader::evaluateNonVirtual(ExecState* exec, JSValue, JSValue moduleRecordValue, JSValue)</span>
368 {
<a name="73" id="anc73"></a><span class="line-modified">369     if (auto* moduleRecord = jsDynamicCast&lt;AbstractModuleRecord*&gt;(exec-&gt;vm(), moduleRecordValue))</span>
<span class="line-modified">370         return moduleRecord-&gt;evaluate(exec);</span>
371     return jsUndefined();
372 }
373 
<a name="74" id="anc74"></a><span class="line-modified">374 JSModuleNamespaceObject* JSModuleLoader::getModuleNamespaceObject(ExecState* exec, JSValue moduleRecordValue)</span>
375 {
<a name="75" id="anc75"></a><span class="line-modified">376     VM&amp; vm = exec-&gt;vm();</span>
377     auto scope = DECLARE_THROW_SCOPE(vm);
378 
379     auto* moduleRecord = jsDynamicCast&lt;AbstractModuleRecord*&gt;(vm, moduleRecordValue);
380     if (!moduleRecord) {
<a name="76" id="anc76"></a><span class="line-modified">381         throwTypeError(exec, scope);</span>
382         return nullptr;
383     }
384 
<a name="77" id="anc77"></a><span class="line-modified">385     RELEASE_AND_RETURN(scope, moduleRecord-&gt;getModuleNamespace(exec));</span>
386 }
387 
388 // ------------------------------ Functions --------------------------------
389 
<a name="78" id="anc78"></a><span class="line-modified">390 EncodedJSValue JSC_HOST_CALL moduleLoaderParseModule(ExecState* exec)</span>
391 {
<a name="79" id="anc79"></a><span class="line-modified">392     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">393     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
394 
<a name="80" id="anc80"></a><span class="line-modified">395     JSInternalPromiseDeferred* deferred = JSInternalPromiseDeferred::tryCreate(exec, exec-&gt;lexicalGlobalObject());</span>
<span class="line-removed">396     RETURN_IF_EXCEPTION(throwScope, encodedJSValue());</span>
397 
398     auto catchScope = DECLARE_CATCH_SCOPE(vm);
399     auto reject = [&amp;] (JSValue rejectionReason) {
400         catchScope.clearException();
<a name="81" id="anc81"></a><span class="line-modified">401         auto result = deferred-&gt;reject(exec, rejectionReason);</span>
402         catchScope.clearException();
<a name="82" id="anc82"></a><span class="line-modified">403         return JSValue::encode(result);</span>
404     };
405 
<a name="83" id="anc83"></a><span class="line-modified">406     const Identifier moduleKey = exec-&gt;argument(0).toPropertyKey(exec);</span>
407     if (UNLIKELY(catchScope.exception()))
408         return reject(catchScope.exception());
409 
<a name="84" id="anc84"></a><span class="line-modified">410     JSValue source = exec-&gt;argument(1);</span>
411     auto* jsSourceCode = jsCast&lt;JSSourceCode*&gt;(source);
412     SourceCode sourceCode = jsSourceCode-&gt;sourceCode();
413 
414 #if ENABLE(WEBASSEMBLY)
415     if (sourceCode.provider()-&gt;sourceType() == SourceProviderSourceType::WebAssembly)
<a name="85" id="anc85"></a><span class="line-modified">416         return JSValue::encode(JSWebAssembly::instantiate(exec, deferred, moduleKey, jsSourceCode));</span>
417 #endif
418 
419     CodeProfiling profile(sourceCode);
420 
421     ParserError error;
422     std::unique_ptr&lt;ModuleProgramNode&gt; moduleProgramNode = parse&lt;ModuleProgramNode&gt;(
423         vm, sourceCode, Identifier(), JSParserBuiltinMode::NotBuiltin,
424         JSParserStrictMode::Strict, JSParserScriptMode::Module, SourceParseMode::ModuleAnalyzeMode, SuperBinding::NotNeeded, error);
425     if (error.isValid())
<a name="86" id="anc86"></a><span class="line-modified">426         return reject(error.toErrorObject(exec-&gt;lexicalGlobalObject(), sourceCode));</span>
427     ASSERT(moduleProgramNode);
428 
<a name="87" id="anc87"></a><span class="line-modified">429     ModuleAnalyzer moduleAnalyzer(exec, moduleKey, sourceCode, moduleProgramNode-&gt;varDeclarations(), moduleProgramNode-&gt;lexicalVariables());</span>
430     if (UNLIKELY(catchScope.exception()))
431         return reject(catchScope.exception());
432 
<a name="88" id="anc88"></a><span class="line-modified">433     auto result = deferred-&gt;resolve(exec, moduleAnalyzer.analyze(*moduleProgramNode));</span>
434     catchScope.clearException();
<a name="89" id="anc89"></a><span class="line-modified">435     return JSValue::encode(result);</span>
436 }
437 
<a name="90" id="anc90"></a><span class="line-modified">438 EncodedJSValue JSC_HOST_CALL moduleLoaderRequestedModules(ExecState* exec)</span>
439 {
<a name="91" id="anc91"></a><span class="line-modified">440     VM&amp; vm = exec-&gt;vm();</span>
441     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="92" id="anc92"></a><span class="line-modified">442     auto* moduleRecord = jsDynamicCast&lt;AbstractModuleRecord*&gt;(vm, exec-&gt;argument(0));</span>
443     if (!moduleRecord)
<a name="93" id="anc93"></a><span class="line-modified">444         RELEASE_AND_RETURN(scope, JSValue::encode(constructEmptyArray(exec, nullptr)));</span>
445 
<a name="94" id="anc94"></a><span class="line-modified">446     JSArray* result = constructEmptyArray(exec, nullptr, moduleRecord-&gt;requestedModules().size());</span>
447     RETURN_IF_EXCEPTION(scope, encodedJSValue());
448     size_t i = 0;
449     for (auto&amp; key : moduleRecord-&gt;requestedModules()) {
<a name="95" id="anc95"></a><span class="line-modified">450         result-&gt;putDirectIndex(exec, i++, jsString(vm, key.get()));</span>
451         RETURN_IF_EXCEPTION(scope, encodedJSValue());
452     }
453     return JSValue::encode(result);
454 }
455 
<a name="96" id="anc96"></a><span class="line-modified">456 EncodedJSValue JSC_HOST_CALL moduleLoaderModuleDeclarationInstantiation(ExecState* exec)</span>
457 {
<a name="97" id="anc97"></a><span class="line-modified">458     VM&amp; vm = exec-&gt;vm();</span>
459     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="98" id="anc98"></a><span class="line-modified">460     auto* moduleRecord = jsDynamicCast&lt;AbstractModuleRecord*&gt;(vm, exec-&gt;argument(0));</span>
461     if (!moduleRecord)
462         return JSValue::encode(jsUndefined());
463 
<a name="99" id="anc99"></a><span class="line-modified">464     if (Options::dumpModuleLoadingState())</span>
<span class="line-removed">465         dataLog(&quot;Loader [link] &quot;, moduleRecord-&gt;moduleKey(), &quot;\n&quot;);</span>
466 
<a name="100" id="anc100"></a><span class="line-modified">467     moduleRecord-&gt;link(exec, exec-&gt;argument(1));</span>
468     RETURN_IF_EXCEPTION(scope, encodedJSValue());
469 
470     return JSValue::encode(jsUndefined());
471 }
472 
473 // ------------------------------ Hook Functions ---------------------------
474 
<a name="101" id="anc101"></a><span class="line-modified">475 EncodedJSValue JSC_HOST_CALL moduleLoaderResolve(ExecState* exec)</span>
476 {
<a name="102" id="anc102"></a><span class="line-modified">477     VM&amp; vm = exec-&gt;vm();</span>
478     // Hook point, Loader.resolve.
479     // https://whatwg.github.io/loader/#browser-resolve
480     // Take the name and resolve it to the unique identifier for the resource location.
481     // For example, take the &quot;jquery&quot; and return the URL for the resource.
<a name="103" id="anc103"></a><span class="line-modified">482     JSModuleLoader* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, exec-&gt;thisValue());</span>
483     if (!loader)
484         return JSValue::encode(jsUndefined());
<a name="104" id="anc104"></a><span class="line-modified">485     return JSValue::encode(loader-&gt;resolve(exec, exec-&gt;argument(0), exec-&gt;argument(1), exec-&gt;argument(2)));</span>
486 }
487 
<a name="105" id="anc105"></a><span class="line-modified">488 EncodedJSValue JSC_HOST_CALL moduleLoaderResolveSync(ExecState* exec)</span>
489 {
<a name="106" id="anc106"></a><span class="line-modified">490     VM&amp; vm = exec-&gt;vm();</span>
491     auto scope = DECLARE_THROW_SCOPE(vm);
492 
<a name="107" id="anc107"></a><span class="line-modified">493     JSModuleLoader* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, exec-&gt;thisValue());</span>
494     if (!loader)
495         return JSValue::encode(jsUndefined());
<a name="108" id="anc108"></a><span class="line-modified">496     auto result = loader-&gt;resolveSync(exec, exec-&gt;argument(0), exec-&gt;argument(1), exec-&gt;argument(2));</span>
497     RETURN_IF_EXCEPTION(scope, encodedJSValue());
498     return JSValue::encode(identifierToJSValue(vm, result));
499 }
500 
<a name="109" id="anc109"></a><span class="line-modified">501 EncodedJSValue JSC_HOST_CALL moduleLoaderFetch(ExecState* exec)</span>
502 {
<a name="110" id="anc110"></a><span class="line-modified">503     VM&amp; vm = exec-&gt;vm();</span>
504     // Hook point, Loader.fetch
505     // https://whatwg.github.io/loader/#browser-fetch
506     // Take the key and fetch the resource actually.
507     // For example, JavaScriptCore shell can provide the hook fetching the resource
508     // from the local file system.
<a name="111" id="anc111"></a><span class="line-modified">509     JSModuleLoader* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, exec-&gt;thisValue());</span>
510     if (!loader)
511         return JSValue::encode(jsUndefined());
<a name="112" id="anc112"></a><span class="line-modified">512     return JSValue::encode(loader-&gt;fetch(exec, exec-&gt;argument(0), exec-&gt;argument(1), exec-&gt;argument(2)));</span>
513 }
514 
<a name="113" id="anc113"></a><span class="line-modified">515 EncodedJSValue JSC_HOST_CALL moduleLoaderGetModuleNamespaceObject(ExecState* exec)</span>
516 {
<a name="114" id="anc114"></a><span class="line-modified">517     VM&amp; vm = exec-&gt;vm();</span>
518     auto scope = DECLARE_THROW_SCOPE(vm);
519 
<a name="115" id="anc115"></a><span class="line-modified">520     auto* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, exec-&gt;thisValue());</span>
521     if (!loader)
522         return JSValue::encode(jsUndefined());
<a name="116" id="anc116"></a><span class="line-modified">523     auto* moduleNamespaceObject = loader-&gt;getModuleNamespaceObject(exec, exec-&gt;argument(0));</span>
524     RETURN_IF_EXCEPTION(scope, encodedJSValue());
525     return JSValue::encode(moduleNamespaceObject);
526 }
527 
528 // ------------------- Additional Hook Functions ---------------------------
529 
<a name="117" id="anc117"></a><span class="line-modified">530 EncodedJSValue JSC_HOST_CALL moduleLoaderEvaluate(ExecState* exec)</span>
531 {
532     // To instrument and retrieve the errors raised from the module execution,
533     // we inserted the hook point here.
534 
<a name="118" id="anc118"></a><span class="line-modified">535     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">536     JSModuleLoader* loader = jsDynamicCast&lt;JSModuleLoader*&gt;(vm, exec-&gt;thisValue());</span>
537     if (!loader)
538         return JSValue::encode(jsUndefined());
<a name="119" id="anc119"></a><span class="line-modified">539     return JSValue::encode(loader-&gt;evaluate(exec, exec-&gt;argument(0), exec-&gt;argument(1), exec-&gt;argument(2)));</span>
540 }
541 
542 } // namespace JSC
<a name="120" id="anc120"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="120" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/layout/blockformatting/BlockFormattingContextQuirks.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BlockFormattingContextGeometry.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="BlockFormattingState.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/layout/blockformatting/BlockFormattingContextQuirks.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,10 ***</span>
<span class="line-new-header">--- 26,12 ---</span>
  #include &quot;config.h&quot;
  #include &quot;BlockFormattingContext.h&quot;
  
  #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
  
<span class="line-added">+ #include &quot;BlockFormattingState.h&quot;</span>
<span class="line-added">+ #include &quot;DisplayBox.h&quot;</span>
  #include &quot;LayoutBox.h&quot;
  #include &quot;LayoutContainer.h&quot;
  #include &quot;LayoutState.h&quot;
  
  namespace WebCore {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 46,65 ***</span>
  static bool isQuirkContainer(const Box&amp; layoutBox)
  {
      return layoutBox.isBodyBox() || layoutBox.isDocumentBox() || layoutBox.isTableCell();
  }
  
<span class="line-modified">! bool BlockFormattingContext::Quirks::needsStretching(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
  {
      // In quirks mode, body stretches to html and html to the initial containing block (height: auto only).
<span class="line-modified">!     if (!layoutState.inQuirksMode())</span>
          return false;
  
      if (!layoutBox.isDocumentBox() &amp;&amp; !layoutBox.isBodyBox())
          return false;
  
      return layoutBox.style().logicalHeight().isAuto();
  }
  
<span class="line-modified">! HeightAndMargin BlockFormattingContext::Quirks::stretchedInFlowHeight(const LayoutState&amp; layoutState, const Box&amp; layoutBox, HeightAndMargin heightAndMargin)</span>
  {
      ASSERT(layoutBox.isInFlow());
      ASSERT(layoutBox.isDocumentBox() || layoutBox.isBodyBox());
  
      auto&amp; documentBox = layoutBox.isDocumentBox() ? layoutBox : *layoutBox.parent();
<span class="line-modified">!     auto&amp; documentBoxDisplayBox = layoutState.displayBoxForLayoutBox(documentBox);</span>
  
<span class="line-modified">!     auto&amp; initialContainingBlockDisplayBox = layoutState.displayBoxForLayoutBox(initialContainingBlock(layoutBox));</span>
<span class="line-modified">!     auto strechedHeight = initialContainingBlockDisplayBox.contentBoxHeight();</span>
<span class="line-modified">!     strechedHeight -= documentBoxDisplayBox.verticalBorder() + documentBoxDisplayBox.verticalPadding().valueOr(0);</span>
  
      LayoutUnit totalVerticalMargin;
      if (layoutBox.isDocumentBox()) {
          // Document box&#39;s margins do not collapse.
<span class="line-modified">!         auto verticalMargin = heightAndMargin.nonCollapsedMargin;</span>
          totalVerticalMargin = verticalMargin.before + verticalMargin.after;
      } else if (layoutBox.isBodyBox()) {
          // Here is the quirky part for body box:
          // Stretch the body using the initial containing block&#39;s height and shrink it with document box&#39;s margin/border/padding.
          // This looks extremely odd when html has non-auto height.
<span class="line-modified">!         auto documentBoxVerticalMargin = Geometry::computedVerticalMargin(documentBox, UsedHorizontalValues { initialContainingBlockDisplayBox.contentBoxWidth() });</span>
          strechedHeight -= (documentBoxVerticalMargin.before.valueOr(0) + documentBoxVerticalMargin.after.valueOr(0));
  
<span class="line-modified">!         auto&amp; bodyBoxDisplayBox = layoutState.displayBoxForLayoutBox(layoutBox);</span>
<span class="line-modified">!         strechedHeight -= bodyBoxDisplayBox.verticalBorder() + bodyBoxDisplayBox.verticalPadding().valueOr(0);</span>
  
<span class="line-modified">!         auto nonCollapsedMargin = heightAndMargin.nonCollapsedMargin;</span>
<span class="line-modified">!         auto collapsedMargin = MarginCollapse::collapsedVerticalValues(layoutState, layoutBox, nonCollapsedMargin);</span>
          totalVerticalMargin = collapsedMargin.before.valueOr(nonCollapsedMargin.before);
          totalVerticalMargin += collapsedMargin.isCollapsedThrough ? nonCollapsedMargin.after : collapsedMargin.after.valueOr(nonCollapsedMargin.after);
      }
  
      // Stretch but never overstretch with the margins.
<span class="line-modified">!     if (heightAndMargin.height + totalVerticalMargin &lt; strechedHeight)</span>
<span class="line-modified">!         heightAndMargin.height = strechedHeight - totalVerticalMargin;</span>
  
<span class="line-modified">!     return heightAndMargin;</span>
  }
  
<span class="line-modified">! bool BlockFormattingContext::Quirks::shouldIgnoreCollapsedQuirkMargin(const LayoutState&amp; layoutState, const Box&amp; layoutBox)</span>
  {
<span class="line-modified">!     return layoutState.inQuirksMode() &amp;&amp; isQuirkContainer(layoutBox);</span>
  }
  
  }
  }
  
<span class="line-new-header">--- 48,66 ---</span>
  static bool isQuirkContainer(const Box&amp; layoutBox)
  {
      return layoutBox.isBodyBox() || layoutBox.isDocumentBox() || layoutBox.isTableCell();
  }
  
<span class="line-modified">! bool BlockFormattingContext::Quirks::needsStretching(const Box&amp; layoutBox) const</span>
  {
      // In quirks mode, body stretches to html and html to the initial containing block (height: auto only).
<span class="line-modified">!     if (!layoutState().inQuirksMode())</span>
          return false;
  
      if (!layoutBox.isDocumentBox() &amp;&amp; !layoutBox.isBodyBox())
          return false;
  
      return layoutBox.style().logicalHeight().isAuto();
  }
  
<span class="line-modified">! ContentHeightAndMargin BlockFormattingContext::Quirks::stretchedInFlowHeight(const Box&amp; layoutBox, ContentHeightAndMargin contentHeightAndMargin)</span>
  {
      ASSERT(layoutBox.isInFlow());
      ASSERT(layoutBox.isDocumentBox() || layoutBox.isBodyBox());
  
<span class="line-added">+     auto&amp; formattingContext = this-&gt;formattingContext();</span>
      auto&amp; documentBox = layoutBox.isDocumentBox() ? layoutBox : *layoutBox.parent();
<span class="line-modified">!     auto&amp; documentBoxGeometry = formattingContext.geometryForBox(documentBox, EscapeReason::BodyStrechesToViewportQuirk);</span>
  
<span class="line-modified">!     auto&amp; initialContainingBlockGeometry = formattingContext.geometryForBox(initialContainingBlock(layoutBox), EscapeReason::BodyStrechesToViewportQuirk);</span>
<span class="line-modified">!     auto strechedHeight = initialContainingBlockGeometry.contentBoxHeight();</span>
<span class="line-modified">!     strechedHeight -= documentBoxGeometry.verticalBorder() + documentBoxGeometry.verticalPadding().valueOr(0);</span>
  
      LayoutUnit totalVerticalMargin;
      if (layoutBox.isDocumentBox()) {
          // Document box&#39;s margins do not collapse.
<span class="line-modified">!         auto verticalMargin = contentHeightAndMargin.nonCollapsedMargin;</span>
          totalVerticalMargin = verticalMargin.before + verticalMargin.after;
      } else if (layoutBox.isBodyBox()) {
          // Here is the quirky part for body box:
          // Stretch the body using the initial containing block&#39;s height and shrink it with document box&#39;s margin/border/padding.
          // This looks extremely odd when html has non-auto height.
<span class="line-modified">!         auto documentBoxVerticalMargin = formattingContext.geometry().computedVerticalMargin(documentBox, Geometry::horizontalConstraintsForInFlow(initialContainingBlockGeometry));</span>
          strechedHeight -= (documentBoxVerticalMargin.before.valueOr(0) + documentBoxVerticalMargin.after.valueOr(0));
  
<span class="line-modified">!         auto&amp; bodyBoxGeometry = formattingContext.geometryForBox(layoutBox);</span>
<span class="line-modified">!         strechedHeight -= bodyBoxGeometry.verticalBorder() + bodyBoxGeometry.verticalPadding().valueOr(0);</span>
  
<span class="line-modified">!         auto nonCollapsedMargin = contentHeightAndMargin.nonCollapsedMargin;</span>
<span class="line-modified">!         auto collapsedMargin = formattingContext.marginCollapse().collapsedVerticalValues(layoutBox, nonCollapsedMargin);</span>
          totalVerticalMargin = collapsedMargin.before.valueOr(nonCollapsedMargin.before);
          totalVerticalMargin += collapsedMargin.isCollapsedThrough ? nonCollapsedMargin.after : collapsedMargin.after.valueOr(nonCollapsedMargin.after);
      }
  
      // Stretch but never overstretch with the margins.
<span class="line-modified">!     if (contentHeightAndMargin.contentHeight + totalVerticalMargin &lt; strechedHeight)</span>
<span class="line-modified">!         contentHeightAndMargin.contentHeight = strechedHeight - totalVerticalMargin;</span>
  
<span class="line-modified">!     return contentHeightAndMargin;</span>
  }
  
<span class="line-modified">! bool BlockFormattingContext::Quirks::shouldIgnoreCollapsedQuirkMargin(const Box&amp; layoutBox) const</span>
  {
<span class="line-modified">!     return layoutState().inQuirksMode() &amp;&amp; isQuirkContainer(layoutBox);</span>
  }
  
  }
  }
  
</pre>
<center><a href="BlockFormattingContextGeometry.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="BlockFormattingState.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
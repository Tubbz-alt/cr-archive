<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/editing/markup.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="atk/FrameSelectionAtk.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../features.json.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/markup.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 159 {
 160     Vector&lt;ElementAttribute&gt; attributesToRemove;
 161     for (auto&amp; element : descendantsOfType&lt;Element&gt;(fragment)) {
 162         if (!element.hasAttributes())
 163             continue;
 164         for (const Attribute&amp; attribute : element.attributesIterator()) {
 165             // FIXME: This won&#39;t work for srcset.
 166             if (element.attributeContainsURL(attribute) &amp;&amp; !attribute.value().isEmpty()) {
 167                 URL url({ }, attribute.value());
 168                 if (shouldRemoveURL(url))
 169                     attributesToRemove.append({ element, attribute.name() });
 170             }
 171         }
 172     }
 173     for (auto&amp; item : attributesToRemove)
 174         item.element-&gt;removeAttribute(item.attributeName);
 175 }
 176 
 177 std::unique_ptr&lt;Page&gt; createPageForSanitizingWebContent()
 178 {
<span class="line-modified"> 179     auto pageConfiguration = pageConfigurationWithEmptyClients();</span>
 180 
 181     auto page = makeUnique&lt;Page&gt;(WTFMove(pageConfiguration));
<span class="line-removed"> 182     page-&gt;setIsForSanitizingWebContent();</span>
 183     page-&gt;settings().setMediaEnabled(false);
 184     page-&gt;settings().setScriptEnabled(false);

 185     page-&gt;settings().setPluginsEnabled(false);
 186     page-&gt;settings().setAcceleratedCompositingEnabled(false);
 187 
 188     Frame&amp; frame = page-&gt;mainFrame();
 189     frame.setView(FrameView::create(frame, IntSize { 800, 600 }));
 190     frame.init();
 191 
 192     FrameLoader&amp; loader = frame.loader();
 193     static char markup[] = &quot;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;;
 194     ASSERT(loader.activeDocumentLoader());
 195     auto&amp; writer = loader.activeDocumentLoader()-&gt;writer();
 196     writer.setMIMEType(&quot;text/html&quot;);
 197     writer.begin();
 198     writer.insertDataSynchronously(String(markup));
 199     writer.end();
 200     RELEASE_ASSERT(page-&gt;mainFrame().document()-&gt;body());
 201 
 202     return page;
 203 }
 204 
 205 String sanitizeMarkup(const String&amp; rawHTML, MSOListQuirks msoListQuirks, Optional&lt;WTF::Function&lt;void(DocumentFragment&amp;)&gt;&gt; fragmentSanitizer)
 206 {
 207     auto page = createPageForSanitizingWebContent();
 208     Document* stagingDocument = page-&gt;mainFrame().document();
 209     ASSERT(stagingDocument);
 210 
 211     auto fragment = createFragmentFromMarkup(*stagingDocument, rawHTML, emptyString(), DisallowScriptingAndPluginContent);
 212 
 213     if (fragmentSanitizer)
 214         (*fragmentSanitizer)(fragment);
 215 
 216     return sanitizedMarkupForFragmentInDocument(WTFMove(fragment), *stagingDocument, msoListQuirks, rawHTML);
 217 }
 218 
 219 enum class MSOListMode { Preserve, DoNotPreserve };
 220 class StyledMarkupAccumulator final : public MarkupAccumulator {
 221 public:
 222     enum RangeFullySelectsNode { DoesFullySelectNode, DoesNotFullySelectNode };
 223 
 224     StyledMarkupAccumulator(const Position&amp; start, const Position&amp; end, Vector&lt;Node*&gt;* nodes, ResolveURLs, SerializeComposedTree,
<span class="line-modified"> 225         AnnotateForInterchange, MSOListMode, bool needsPositionStyleConversion, Node* highestNodeToBeSerialized = nullptr);</span>
 226 
 227     Node* serializeNodes(const Position&amp; start, const Position&amp; end);
 228     void wrapWithNode(Node&amp;, bool convertBlocksToInlines = false, RangeFullySelectsNode = DoesFullySelectNode);
 229     void wrapWithStyleNode(StyleProperties*, Document&amp;, bool isBlock = false);
 230     String takeResults();
 231 
 232     bool needRelativeStyleWrapper() const { return m_needRelativeStyleWrapper; }
 233     bool needClearingDiv() const { return m_needClearingDiv; }
 234 
 235     using MarkupAccumulator::appendString;
 236 
 237     ContainerNode* parentNode(Node&amp; node)
 238     {
 239         if (UNLIKELY(m_useComposedTree))
 240             return node.parentInComposedTree();
 241         return node.parentOrShadowHostNode();
 242     }
 243 
 244 private:
 245     void appendStyleNodeOpenTag(StringBuilder&amp;, StyleProperties*, Document&amp;, bool isBlock = false);
</pre>
<hr />
<pre>
 301     bool appendNodeToPreserveMSOList(Node&amp;);
 302 
 303     bool shouldAnnotate()
 304     {
 305         return m_annotate == AnnotateForInterchange::Yes;
 306     }
 307 
 308     bool shouldApplyWrappingStyle(const Node&amp; node) const
 309     {
 310         return m_highestNodeToBeSerialized &amp;&amp; m_highestNodeToBeSerialized-&gt;parentNode() == node.parentNode() &amp;&amp; m_wrappingStyle &amp;&amp; m_wrappingStyle-&gt;style();
 311     }
 312 
 313     Position m_start;
 314     Position m_end;
 315     Vector&lt;String&gt; m_reversedPrecedingMarkup;
 316     const AnnotateForInterchange m_annotate;
 317     RefPtr&lt;Node&gt; m_highestNodeToBeSerialized;
 318     RefPtr&lt;EditingStyle&gt; m_wrappingStyle;
 319     bool m_useComposedTree;
 320     bool m_needsPositionStyleConversion;


 321     bool m_needRelativeStyleWrapper { false };
 322     bool m_needClearingDiv { false };
<span class="line-removed"> 323     bool m_shouldPreserveMSOList;</span>
 324     bool m_inMSOList { false };
 325 };
 326 
 327 inline StyledMarkupAccumulator::StyledMarkupAccumulator(const Position&amp; start, const Position&amp; end, Vector&lt;Node*&gt;* nodes, ResolveURLs urlsToResolve, SerializeComposedTree serializeComposedTree,
<span class="line-modified"> 328     AnnotateForInterchange annotate, MSOListMode msoListMode, bool needsPositionStyleConversion, Node* highestNodeToBeSerialized)</span>
 329     : MarkupAccumulator(nodes, urlsToResolve)
 330     , m_start(start)
 331     , m_end(end)
 332     , m_annotate(annotate)
 333     , m_highestNodeToBeSerialized(highestNodeToBeSerialized)
 334     , m_useComposedTree(serializeComposedTree == SerializeComposedTree::Yes)
 335     , m_needsPositionStyleConversion(needsPositionStyleConversion)

 336     , m_shouldPreserveMSOList(msoListMode == MSOListMode::Preserve)
 337 {
 338 }
 339 
 340 void StyledMarkupAccumulator::wrapWithNode(Node&amp; node, bool convertBlocksToInlines, RangeFullySelectsNode rangeFullySelectsNode)
 341 {
 342     StringBuilder markup;
 343     if (is&lt;Element&gt;(node))
 344         appendStartTag(markup, downcast&lt;Element&gt;(node), convertBlocksToInlines &amp;&amp; isBlock(&amp;node), rangeFullySelectsNode);
 345     else
 346         appendNonElementNode(markup, node, nullptr);
 347     m_reversedPrecedingMarkup.append(markup.toString());
 348     endAppendingNode(node);
 349     if (m_nodes)
 350         m_nodes-&gt;append(&amp;node);
 351 }
 352 
 353 void StyledMarkupAccumulator::wrapWithStyleNode(StyleProperties* style, Document&amp; document, bool isBlock)
 354 {
 355     StringBuilder openTag;
</pre>
<hr />
<pre>
 514     }
 515 
 516     if (shouldOverrideStyleAttr) {
 517         RefPtr&lt;EditingStyle&gt; newInlineStyle;
 518 
 519         if (shouldApplyWrappingStyle(element)) {
 520             newInlineStyle = m_wrappingStyle-&gt;copy();
 521             newInlineStyle-&gt;removePropertiesInElementDefaultStyle(*const_cast&lt;Element*&gt;(&amp;element));
 522             newInlineStyle-&gt;removeStyleConflictingWithStyleOfNode(*const_cast&lt;Element*&gt;(&amp;element));
 523         } else
 524             newInlineStyle = EditingStyle::create();
 525 
 526         if (isSlotElement)
 527             newInlineStyle-&gt;addDisplayContents();
 528 
 529         if (is&lt;StyledElement&gt;(element) &amp;&amp; downcast&lt;StyledElement&gt;(element).inlineStyle())
 530             newInlineStyle-&gt;overrideWithStyle(*downcast&lt;StyledElement&gt;(element).inlineStyle());
 531 
 532         if (shouldAnnotateOrForceInline) {
 533             if (shouldAnnotate())
<span class="line-modified"> 534                 newInlineStyle-&gt;mergeStyleFromRulesForSerialization(downcast&lt;HTMLElement&gt;(*const_cast&lt;Element*&gt;(&amp;element)));</span>
 535 
 536             if (addDisplayInline)
 537                 newInlineStyle-&gt;forceInline();
 538 
 539             if (m_needsPositionStyleConversion) {
 540                 m_needRelativeStyleWrapper |= newInlineStyle-&gt;convertPositionStyle();
 541                 m_needClearingDiv |= newInlineStyle-&gt;isFloating();
 542             }
 543 
 544             // If the node is not fully selected by the range, then we don&#39;t want to keep styles that affect its relationship to the nodes around it
 545             // only the ones that affect it and the nodes within it.
 546             if (rangeFullySelectsNode == DoesNotFullySelectNode &amp;&amp; newInlineStyle-&gt;style())
 547                 newInlineStyle-&gt;style()-&gt;removeProperty(CSSPropertyFloat);
 548         }
 549 
 550         if (!newInlineStyle-&gt;isEmpty()) {
 551             out.appendLiteral(&quot; style=\&quot;&quot;);
 552             appendAttributeValue(out, newInlineStyle-&gt;style()-&gt;asText(), documentIsHTML);
 553             out.append(&#39;\&quot;&#39;);
 554         }
</pre>
<hr />
<pre>
 562     if (UNLIKELY(is&lt;HTMLSlotElement&gt;(element)))
 563         out.append(&quot;&lt;/span&gt;&quot;);
 564     else
 565         MarkupAccumulator::appendEndTag(out, element);
 566 }
 567 
 568 Node* StyledMarkupAccumulator::serializeNodes(const Position&amp; start, const Position&amp; end)
 569 {
 570     ASSERT(comparePositions(start, end) &lt;= 0);
 571     auto startNode = start.firstNode();
 572     Node* pastEnd = end.computeNodeAfterPosition();
 573     if (!pastEnd &amp;&amp; end.containerNode())
 574         pastEnd = nextSkippingChildren(*end.containerNode());
 575 
 576     if (!m_highestNodeToBeSerialized) {
 577         Node* lastClosed = traverseNodesForSerialization(startNode.get(), pastEnd, NodeTraversalMode::DoNotEmitString);
 578         m_highestNodeToBeSerialized = lastClosed;
 579     }
 580 
 581     if (m_highestNodeToBeSerialized &amp;&amp; m_highestNodeToBeSerialized-&gt;parentNode())
<span class="line-modified"> 582         m_wrappingStyle = EditingStyle::wrappingStyleForSerialization(*m_highestNodeToBeSerialized-&gt;parentNode(), shouldAnnotate());</span>
 583 
 584     return traverseNodesForSerialization(startNode.get(), pastEnd, NodeTraversalMode::EmitString);
 585 }
 586 
 587 Node* StyledMarkupAccumulator::traverseNodesForSerialization(Node* startNode, Node* pastEnd, NodeTraversalMode traversalMode)
 588 {
 589     const bool shouldEmit = traversalMode == NodeTraversalMode::EmitString;
 590 
 591     m_inMSOList = false;
 592 
 593     unsigned depth = 0;
 594     auto enterNode = [&amp;] (Node&amp; node) {
 595         if (UNLIKELY(m_shouldPreserveMSOList) &amp;&amp; shouldEmit) {
 596             if (appendNodeToPreserveMSOList(node))
 597                 return false;
 598         }
 599 
 600         bool isDisplayContents = is&lt;Element&gt;(node) &amp;&amp; downcast&lt;Element&gt;(node).hasDisplayContents();
 601         if (!node.renderer() &amp;&amp; !isDisplayContents &amp;&amp; !enclosingElementWithTag(firstPositionInOrBeforeNode(&amp;node), selectTag))
 602             return false;
</pre>
<hr />
<pre>
 805         if (newSpecialCommonAncestor)
 806             specialCommonAncestor = newSpecialCommonAncestor;
 807     }
 808 
 809     // If a single tab is selected, commonAncestor will be a text node inside a tab span.
 810     // If two or more tabs are selected, commonAncestor will be the tab span.
 811     // In either case, if there is a specialCommonAncestor already, it will necessarily be above
 812     // any tab span that needs to be included.
 813     if (!specialCommonAncestor &amp;&amp; isTabSpanTextNode(&amp;commonAncestor))
 814         specialCommonAncestor = commonAncestor.parentNode();
 815     if (!specialCommonAncestor &amp;&amp; isTabSpanNode(&amp;commonAncestor))
 816         specialCommonAncestor = &amp;commonAncestor;
 817 
 818     if (auto* enclosingAnchor = enclosingElementWithTag(firstPositionInNode(specialCommonAncestor ? specialCommonAncestor : &amp;commonAncestor), aTag))
 819         specialCommonAncestor = enclosingAnchor;
 820 
 821     return specialCommonAncestor;
 822 }
 823 
 824 static String serializePreservingVisualAppearanceInternal(const Position&amp; start, const Position&amp; end, Vector&lt;Node*&gt;* nodes, ResolveURLs urlsToResolve, SerializeComposedTree serializeComposedTree,
<span class="line-modified"> 825     AnnotateForInterchange annotate, ConvertBlocksToInlines convertBlocksToInlines, MSOListMode msoListMode)</span>
 826 {
 827     static NeverDestroyed&lt;const String&gt; interchangeNewlineString(MAKE_STATIC_STRING_IMPL(&quot;&lt;br class=\&quot;&quot; AppleInterchangeNewline &quot;\&quot;&gt;&quot;));
 828 
 829     if (!comparePositions(start, end))
 830         return emptyString();
 831 
 832     RefPtr&lt;Node&gt; commonAncestor = commonShadowIncludingAncestor(start, end);
 833     if (!commonAncestor)
 834         return emptyString();
 835 
 836     auto&amp; document = *start.document();
 837     document.updateLayoutIgnorePendingStylesheets();
 838 
 839     VisiblePosition visibleStart { start };
 840     VisiblePosition visibleEnd { end };
 841 
 842     auto body = makeRefPtr(enclosingElementWithTag(firstPositionInNode(commonAncestor.get()), bodyTag));
 843     RefPtr&lt;Element&gt; fullySelectedRoot;
 844     // FIXME: Do this for all fully selected blocks, not just the body.
 845     if (body &amp;&amp; VisiblePosition(firstPositionInNode(body.get())) == visibleStart &amp;&amp; VisiblePosition(lastPositionInNode(body.get())) == visibleEnd)
 846         fullySelectedRoot = body;
 847     bool needsPositionStyleConversion = body &amp;&amp; fullySelectedRoot == body &amp;&amp; document.settings().shouldConvertPositionStyleOnCopy();
 848 
 849     Node* specialCommonAncestor = highestAncestorToWrapMarkup(start, end, *commonAncestor, annotate);
 850 
<span class="line-modified"> 851     StyledMarkupAccumulator accumulator(start, end, nodes, urlsToResolve, serializeComposedTree, annotate, msoListMode, needsPositionStyleConversion, specialCommonAncestor);</span>
 852 
 853     Position startAdjustedForInterchangeNewline = start;
 854     if (annotate == AnnotateForInterchange::Yes &amp;&amp; needInterchangeNewlineAfter(visibleStart)) {
 855         if (visibleStart == visibleEnd.previous())
 856             return interchangeNewlineString;
 857 
 858         accumulator.appendString(interchangeNewlineString);
 859         startAdjustedForInterchangeNewline = visibleStart.next().deepEquivalent();
 860 
 861         if (comparePositions(startAdjustedForInterchangeNewline, end) &gt;= 0)
 862             return interchangeNewlineString;
 863     }
 864 
 865     Node* lastClosed = accumulator.serializeNodes(startAdjustedForInterchangeNewline, end);
 866 
 867     if (specialCommonAncestor &amp;&amp; lastClosed) {
 868         // Also include all of the ancestors of lastClosed up to this special ancestor.
 869         for (ContainerNode* ancestor = accumulator.parentNode(*lastClosed); ancestor; ancestor = accumulator.parentNode(*ancestor)) {
 870             if (ancestor == fullySelectedRoot &amp;&amp; convertBlocksToInlines == ConvertBlocksToInlines::No) {
 871                 RefPtr&lt;EditingStyle&gt; fullySelectedRootStyle = styleFromMatchedRulesAndInlineDecl(*fullySelectedRoot);
</pre>
<hr />
<pre>
 900     }
 901 
 902     if (accumulator.needRelativeStyleWrapper() &amp;&amp; needsPositionStyleConversion) {
 903         if (accumulator.needClearingDiv())
 904             accumulator.appendString(&quot;&lt;div style=\&quot;clear: both;\&quot;&gt;&lt;/div&gt;&quot;);
 905         RefPtr&lt;EditingStyle&gt; positionRelativeStyle = styleFromMatchedRulesAndInlineDecl(*body);
 906         positionRelativeStyle-&gt;style()-&gt;setProperty(CSSPropertyPosition, CSSValueRelative);
 907         accumulator.wrapWithStyleNode(positionRelativeStyle-&gt;style(), document, true);
 908     }
 909 
 910     // FIXME: The interchange newline should be placed in the block that it&#39;s in, not after all of the content, unconditionally.
 911     if (annotate == AnnotateForInterchange::Yes &amp;&amp; needInterchangeNewlineAfter(visibleEnd.previous()))
 912         accumulator.appendString(interchangeNewlineString);
 913 
 914     return accumulator.takeResults();
 915 }
 916 
 917 String serializePreservingVisualAppearance(const Range&amp; range, Vector&lt;Node*&gt;* nodes, AnnotateForInterchange annotate, ConvertBlocksToInlines convertBlocksToInlines, ResolveURLs urlsToReslve)
 918 {
 919     return serializePreservingVisualAppearanceInternal(range.startPosition(), range.endPosition(), nodes, urlsToReslve, SerializeComposedTree::No,
<span class="line-modified"> 920         annotate, convertBlocksToInlines, MSOListMode::DoNotPreserve);</span>
 921 }
 922 
 923 String serializePreservingVisualAppearance(const VisibleSelection&amp; selection, ResolveURLs resolveURLs, SerializeComposedTree serializeComposedTree, Vector&lt;Node*&gt;* nodes)
 924 {
 925     return serializePreservingVisualAppearanceInternal(selection.start(), selection.end(), nodes, resolveURLs, serializeComposedTree,
<span class="line-modified"> 926         AnnotateForInterchange::Yes, ConvertBlocksToInlines::No, MSOListMode::DoNotPreserve);</span>
 927 }
 928 
 929 
 930 static bool shouldPreserveMSOLists(const String&amp; markup)
 931 {
 932     if (!markup.startsWith(&quot;&lt;html xmlns:&quot;))
 933         return false;
 934     auto tagClose = markup.find(&#39;&gt;&#39;);
 935     if (tagClose == notFound)
 936         return false;
 937     auto htmlTag = markup.substring(0, tagClose);
 938     return htmlTag.contains(&quot;xmlns:o=\&quot;urn:schemas-microsoft-com:office:office\&quot;&quot;)
 939         &amp;&amp; htmlTag.contains(&quot;xmlns:w=\&quot;urn:schemas-microsoft-com:office:word\&quot;&quot;);
 940 }
 941 
 942 String sanitizedMarkupForFragmentInDocument(Ref&lt;DocumentFragment&gt;&amp;&amp; fragment, Document&amp; document, MSOListQuirks msoListQuirks, const String&amp; originalMarkup)
 943 {
 944     MSOListMode msoListMode = msoListQuirks == MSOListQuirks::CheckIfNeeded &amp;&amp; shouldPreserveMSOLists(originalMarkup)
 945         ? MSOListMode::Preserve : MSOListMode::DoNotPreserve;
 946 
 947     auto bodyElement = makeRefPtr(document.body());
 948     ASSERT(bodyElement);
 949     bodyElement-&gt;appendChild(fragment.get());
 950 
 951     // SerializeComposedTree::No because there can&#39;t be a shadow tree in the pasted fragment.
 952     auto result = serializePreservingVisualAppearanceInternal(firstPositionInNode(bodyElement.get()), lastPositionInNode(bodyElement.get()), nullptr,
<span class="line-modified"> 953         ResolveURLs::YesExcludingLocalFileURLsForPrivacy, SerializeComposedTree::No, AnnotateForInterchange::Yes, ConvertBlocksToInlines::No,  msoListMode);</span>
 954 
 955     if (msoListMode == MSOListMode::Preserve) {
 956         StringBuilder builder;
 957         builder.appendLiteral(&quot;&lt;html xmlns:o=\&quot;urn:schemas-microsoft-com:office:office\&quot;\n&quot;
 958             &quot;xmlns:w=\&quot;urn:schemas-microsoft-com:office:word\&quot;\n&quot;
 959             &quot;xmlns:m=\&quot;http://schemas.microsoft.com/office/2004/12/omml\&quot;\n&quot;
 960             &quot;xmlns=\&quot;http://www.w3.org/TR/REC-html40\&quot;&gt;&quot;);
 961         builder.append(result);
 962         builder.appendLiteral(&quot;&lt;/html&gt;&quot;);
 963         return builder.toString();
 964     }
 965 
 966     return result;
 967 }
 968 
 969 static void restoreAttachmentElementsInFragment(DocumentFragment&amp; fragment)
 970 {
 971 #if ENABLE(ATTACHMENT_ELEMENT)
 972     if (!RuntimeEnabledFeatures::sharedFeatures().attachmentElementEnabled())
 973         return;
 974 
 975     // When creating a fragment we must strip the webkit-attachment-path attribute after restoring the File object.
 976     Vector&lt;Ref&lt;HTMLAttachmentElement&gt;&gt; attachments;
 977     for (auto&amp; attachment : descendantsOfType&lt;HTMLAttachmentElement&gt;(fragment))
 978         attachments.append(attachment);
 979 
 980     for (auto&amp; attachment : attachments) {
 981         attachment-&gt;setUniqueIdentifier(attachment-&gt;attributeWithoutSynchronization(webkitattachmentidAttr));
 982 
 983         auto attachmentPath = attachment-&gt;attachmentPath();
 984         auto blobURL = attachment-&gt;blobURL();
 985         if (!attachmentPath.isEmpty())
<span class="line-modified"> 986             attachment-&gt;setFile(File::create(fragment.document().sessionID(), attachmentPath));</span>
 987         else if (!blobURL.isEmpty())
<span class="line-modified"> 988             attachment-&gt;setFile(File::deserialize(fragment.document().sessionID(), { }, blobURL, attachment-&gt;attachmentType(), attachment-&gt;attachmentTitle()));</span>
 989 
 990         // Remove temporary attributes that were previously added in StyledMarkupAccumulator::appendCustomAttributes.
 991         attachment-&gt;removeAttribute(webkitattachmentidAttr);
 992         attachment-&gt;removeAttribute(webkitattachmentpathAttr);
 993         attachment-&gt;removeAttribute(webkitattachmentbloburlAttr);
 994     }
 995 
 996     Vector&lt;Ref&lt;HTMLImageElement&gt;&gt; images;
 997     for (auto&amp; image : descendantsOfType&lt;HTMLImageElement&gt;(fragment))
 998         images.append(image);
 999 
1000     for (auto&amp; image : images) {
1001         auto attachmentIdentifier = image-&gt;attributeWithoutSynchronization(webkitattachmentidAttr);
1002         if (attachmentIdentifier.isEmpty())
1003             continue;
1004 
1005         auto attachment = HTMLAttachmentElement::create(HTMLNames::attachmentTag, *fragment.ownerDocument());
1006         attachment-&gt;setUniqueIdentifier(attachmentIdentifier);
1007         image-&gt;setAttachmentElement(WTFMove(attachment));
1008         image-&gt;removeAttribute(webkitattachmentidAttr);
</pre>
</td>
<td>
<hr />
<pre>
 159 {
 160     Vector&lt;ElementAttribute&gt; attributesToRemove;
 161     for (auto&amp; element : descendantsOfType&lt;Element&gt;(fragment)) {
 162         if (!element.hasAttributes())
 163             continue;
 164         for (const Attribute&amp; attribute : element.attributesIterator()) {
 165             // FIXME: This won&#39;t work for srcset.
 166             if (element.attributeContainsURL(attribute) &amp;&amp; !attribute.value().isEmpty()) {
 167                 URL url({ }, attribute.value());
 168                 if (shouldRemoveURL(url))
 169                     attributesToRemove.append({ element, attribute.name() });
 170             }
 171         }
 172     }
 173     for (auto&amp; item : attributesToRemove)
 174         item.element-&gt;removeAttribute(item.attributeName);
 175 }
 176 
 177 std::unique_ptr&lt;Page&gt; createPageForSanitizingWebContent()
 178 {
<span class="line-modified"> 179     auto pageConfiguration = pageConfigurationWithEmptyClients(PAL::SessionID::defaultSessionID());</span>
 180 
 181     auto page = makeUnique&lt;Page&gt;(WTFMove(pageConfiguration));

 182     page-&gt;settings().setMediaEnabled(false);
 183     page-&gt;settings().setScriptEnabled(false);
<span class="line-added"> 184     page-&gt;settings().setParserScriptingFlagPolicy(SettingsBase::ParserScriptingFlagPolicy::Enabled);</span>
 185     page-&gt;settings().setPluginsEnabled(false);
 186     page-&gt;settings().setAcceleratedCompositingEnabled(false);
 187 
 188     Frame&amp; frame = page-&gt;mainFrame();
 189     frame.setView(FrameView::create(frame, IntSize { 800, 600 }));
 190     frame.init();
 191 
 192     FrameLoader&amp; loader = frame.loader();
 193     static char markup[] = &quot;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;;
 194     ASSERT(loader.activeDocumentLoader());
 195     auto&amp; writer = loader.activeDocumentLoader()-&gt;writer();
 196     writer.setMIMEType(&quot;text/html&quot;);
 197     writer.begin();
 198     writer.insertDataSynchronously(String(markup));
 199     writer.end();
 200     RELEASE_ASSERT(page-&gt;mainFrame().document()-&gt;body());
 201 
 202     return page;
 203 }
 204 
 205 String sanitizeMarkup(const String&amp; rawHTML, MSOListQuirks msoListQuirks, Optional&lt;WTF::Function&lt;void(DocumentFragment&amp;)&gt;&gt; fragmentSanitizer)
 206 {
 207     auto page = createPageForSanitizingWebContent();
 208     Document* stagingDocument = page-&gt;mainFrame().document();
 209     ASSERT(stagingDocument);
 210 
 211     auto fragment = createFragmentFromMarkup(*stagingDocument, rawHTML, emptyString(), DisallowScriptingAndPluginContent);
 212 
 213     if (fragmentSanitizer)
 214         (*fragmentSanitizer)(fragment);
 215 
 216     return sanitizedMarkupForFragmentInDocument(WTFMove(fragment), *stagingDocument, msoListQuirks, rawHTML);
 217 }
 218 
 219 enum class MSOListMode { Preserve, DoNotPreserve };
 220 class StyledMarkupAccumulator final : public MarkupAccumulator {
 221 public:
 222     enum RangeFullySelectsNode { DoesFullySelectNode, DoesNotFullySelectNode };
 223 
 224     StyledMarkupAccumulator(const Position&amp; start, const Position&amp; end, Vector&lt;Node*&gt;* nodes, ResolveURLs, SerializeComposedTree,
<span class="line-modified"> 225         AnnotateForInterchange, StandardFontFamilySerializationMode, MSOListMode, bool needsPositionStyleConversion, Node* highestNodeToBeSerialized = nullptr);</span>
 226 
 227     Node* serializeNodes(const Position&amp; start, const Position&amp; end);
 228     void wrapWithNode(Node&amp;, bool convertBlocksToInlines = false, RangeFullySelectsNode = DoesFullySelectNode);
 229     void wrapWithStyleNode(StyleProperties*, Document&amp;, bool isBlock = false);
 230     String takeResults();
 231 
 232     bool needRelativeStyleWrapper() const { return m_needRelativeStyleWrapper; }
 233     bool needClearingDiv() const { return m_needClearingDiv; }
 234 
 235     using MarkupAccumulator::appendString;
 236 
 237     ContainerNode* parentNode(Node&amp; node)
 238     {
 239         if (UNLIKELY(m_useComposedTree))
 240             return node.parentInComposedTree();
 241         return node.parentOrShadowHostNode();
 242     }
 243 
 244 private:
 245     void appendStyleNodeOpenTag(StringBuilder&amp;, StyleProperties*, Document&amp;, bool isBlock = false);
</pre>
<hr />
<pre>
 301     bool appendNodeToPreserveMSOList(Node&amp;);
 302 
 303     bool shouldAnnotate()
 304     {
 305         return m_annotate == AnnotateForInterchange::Yes;
 306     }
 307 
 308     bool shouldApplyWrappingStyle(const Node&amp; node) const
 309     {
 310         return m_highestNodeToBeSerialized &amp;&amp; m_highestNodeToBeSerialized-&gt;parentNode() == node.parentNode() &amp;&amp; m_wrappingStyle &amp;&amp; m_wrappingStyle-&gt;style();
 311     }
 312 
 313     Position m_start;
 314     Position m_end;
 315     Vector&lt;String&gt; m_reversedPrecedingMarkup;
 316     const AnnotateForInterchange m_annotate;
 317     RefPtr&lt;Node&gt; m_highestNodeToBeSerialized;
 318     RefPtr&lt;EditingStyle&gt; m_wrappingStyle;
 319     bool m_useComposedTree;
 320     bool m_needsPositionStyleConversion;
<span class="line-added"> 321     StandardFontFamilySerializationMode m_standardFontFamilySerializationMode;</span>
<span class="line-added"> 322     bool m_shouldPreserveMSOList;</span>
 323     bool m_needRelativeStyleWrapper { false };
 324     bool m_needClearingDiv { false };

 325     bool m_inMSOList { false };
 326 };
 327 
 328 inline StyledMarkupAccumulator::StyledMarkupAccumulator(const Position&amp; start, const Position&amp; end, Vector&lt;Node*&gt;* nodes, ResolveURLs urlsToResolve, SerializeComposedTree serializeComposedTree,
<span class="line-modified"> 329     AnnotateForInterchange annotate, StandardFontFamilySerializationMode standardFontFamilySerializationMode, MSOListMode msoListMode, bool needsPositionStyleConversion, Node* highestNodeToBeSerialized)</span>
 330     : MarkupAccumulator(nodes, urlsToResolve)
 331     , m_start(start)
 332     , m_end(end)
 333     , m_annotate(annotate)
 334     , m_highestNodeToBeSerialized(highestNodeToBeSerialized)
 335     , m_useComposedTree(serializeComposedTree == SerializeComposedTree::Yes)
 336     , m_needsPositionStyleConversion(needsPositionStyleConversion)
<span class="line-added"> 337     , m_standardFontFamilySerializationMode(standardFontFamilySerializationMode)</span>
 338     , m_shouldPreserveMSOList(msoListMode == MSOListMode::Preserve)
 339 {
 340 }
 341 
 342 void StyledMarkupAccumulator::wrapWithNode(Node&amp; node, bool convertBlocksToInlines, RangeFullySelectsNode rangeFullySelectsNode)
 343 {
 344     StringBuilder markup;
 345     if (is&lt;Element&gt;(node))
 346         appendStartTag(markup, downcast&lt;Element&gt;(node), convertBlocksToInlines &amp;&amp; isBlock(&amp;node), rangeFullySelectsNode);
 347     else
 348         appendNonElementNode(markup, node, nullptr);
 349     m_reversedPrecedingMarkup.append(markup.toString());
 350     endAppendingNode(node);
 351     if (m_nodes)
 352         m_nodes-&gt;append(&amp;node);
 353 }
 354 
 355 void StyledMarkupAccumulator::wrapWithStyleNode(StyleProperties* style, Document&amp; document, bool isBlock)
 356 {
 357     StringBuilder openTag;
</pre>
<hr />
<pre>
 516     }
 517 
 518     if (shouldOverrideStyleAttr) {
 519         RefPtr&lt;EditingStyle&gt; newInlineStyle;
 520 
 521         if (shouldApplyWrappingStyle(element)) {
 522             newInlineStyle = m_wrappingStyle-&gt;copy();
 523             newInlineStyle-&gt;removePropertiesInElementDefaultStyle(*const_cast&lt;Element*&gt;(&amp;element));
 524             newInlineStyle-&gt;removeStyleConflictingWithStyleOfNode(*const_cast&lt;Element*&gt;(&amp;element));
 525         } else
 526             newInlineStyle = EditingStyle::create();
 527 
 528         if (isSlotElement)
 529             newInlineStyle-&gt;addDisplayContents();
 530 
 531         if (is&lt;StyledElement&gt;(element) &amp;&amp; downcast&lt;StyledElement&gt;(element).inlineStyle())
 532             newInlineStyle-&gt;overrideWithStyle(*downcast&lt;StyledElement&gt;(element).inlineStyle());
 533 
 534         if (shouldAnnotateOrForceInline) {
 535             if (shouldAnnotate())
<span class="line-modified"> 536                 newInlineStyle-&gt;mergeStyleFromRulesForSerialization(downcast&lt;HTMLElement&gt;(*const_cast&lt;Element*&gt;(&amp;element)), m_standardFontFamilySerializationMode);</span>
 537 
 538             if (addDisplayInline)
 539                 newInlineStyle-&gt;forceInline();
 540 
 541             if (m_needsPositionStyleConversion) {
 542                 m_needRelativeStyleWrapper |= newInlineStyle-&gt;convertPositionStyle();
 543                 m_needClearingDiv |= newInlineStyle-&gt;isFloating();
 544             }
 545 
 546             // If the node is not fully selected by the range, then we don&#39;t want to keep styles that affect its relationship to the nodes around it
 547             // only the ones that affect it and the nodes within it.
 548             if (rangeFullySelectsNode == DoesNotFullySelectNode &amp;&amp; newInlineStyle-&gt;style())
 549                 newInlineStyle-&gt;style()-&gt;removeProperty(CSSPropertyFloat);
 550         }
 551 
 552         if (!newInlineStyle-&gt;isEmpty()) {
 553             out.appendLiteral(&quot; style=\&quot;&quot;);
 554             appendAttributeValue(out, newInlineStyle-&gt;style()-&gt;asText(), documentIsHTML);
 555             out.append(&#39;\&quot;&#39;);
 556         }
</pre>
<hr />
<pre>
 564     if (UNLIKELY(is&lt;HTMLSlotElement&gt;(element)))
 565         out.append(&quot;&lt;/span&gt;&quot;);
 566     else
 567         MarkupAccumulator::appendEndTag(out, element);
 568 }
 569 
 570 Node* StyledMarkupAccumulator::serializeNodes(const Position&amp; start, const Position&amp; end)
 571 {
 572     ASSERT(comparePositions(start, end) &lt;= 0);
 573     auto startNode = start.firstNode();
 574     Node* pastEnd = end.computeNodeAfterPosition();
 575     if (!pastEnd &amp;&amp; end.containerNode())
 576         pastEnd = nextSkippingChildren(*end.containerNode());
 577 
 578     if (!m_highestNodeToBeSerialized) {
 579         Node* lastClosed = traverseNodesForSerialization(startNode.get(), pastEnd, NodeTraversalMode::DoNotEmitString);
 580         m_highestNodeToBeSerialized = lastClosed;
 581     }
 582 
 583     if (m_highestNodeToBeSerialized &amp;&amp; m_highestNodeToBeSerialized-&gt;parentNode())
<span class="line-modified"> 584         m_wrappingStyle = EditingStyle::wrappingStyleForSerialization(*m_highestNodeToBeSerialized-&gt;parentNode(), shouldAnnotate(), m_standardFontFamilySerializationMode);</span>
 585 
 586     return traverseNodesForSerialization(startNode.get(), pastEnd, NodeTraversalMode::EmitString);
 587 }
 588 
 589 Node* StyledMarkupAccumulator::traverseNodesForSerialization(Node* startNode, Node* pastEnd, NodeTraversalMode traversalMode)
 590 {
 591     const bool shouldEmit = traversalMode == NodeTraversalMode::EmitString;
 592 
 593     m_inMSOList = false;
 594 
 595     unsigned depth = 0;
 596     auto enterNode = [&amp;] (Node&amp; node) {
 597         if (UNLIKELY(m_shouldPreserveMSOList) &amp;&amp; shouldEmit) {
 598             if (appendNodeToPreserveMSOList(node))
 599                 return false;
 600         }
 601 
 602         bool isDisplayContents = is&lt;Element&gt;(node) &amp;&amp; downcast&lt;Element&gt;(node).hasDisplayContents();
 603         if (!node.renderer() &amp;&amp; !isDisplayContents &amp;&amp; !enclosingElementWithTag(firstPositionInOrBeforeNode(&amp;node), selectTag))
 604             return false;
</pre>
<hr />
<pre>
 807         if (newSpecialCommonAncestor)
 808             specialCommonAncestor = newSpecialCommonAncestor;
 809     }
 810 
 811     // If a single tab is selected, commonAncestor will be a text node inside a tab span.
 812     // If two or more tabs are selected, commonAncestor will be the tab span.
 813     // In either case, if there is a specialCommonAncestor already, it will necessarily be above
 814     // any tab span that needs to be included.
 815     if (!specialCommonAncestor &amp;&amp; isTabSpanTextNode(&amp;commonAncestor))
 816         specialCommonAncestor = commonAncestor.parentNode();
 817     if (!specialCommonAncestor &amp;&amp; isTabSpanNode(&amp;commonAncestor))
 818         specialCommonAncestor = &amp;commonAncestor;
 819 
 820     if (auto* enclosingAnchor = enclosingElementWithTag(firstPositionInNode(specialCommonAncestor ? specialCommonAncestor : &amp;commonAncestor), aTag))
 821         specialCommonAncestor = enclosingAnchor;
 822 
 823     return specialCommonAncestor;
 824 }
 825 
 826 static String serializePreservingVisualAppearanceInternal(const Position&amp; start, const Position&amp; end, Vector&lt;Node*&gt;* nodes, ResolveURLs urlsToResolve, SerializeComposedTree serializeComposedTree,
<span class="line-modified"> 827     AnnotateForInterchange annotate, ConvertBlocksToInlines convertBlocksToInlines, StandardFontFamilySerializationMode standardFontFamilySerializationMode, MSOListMode msoListMode)</span>
 828 {
 829     static NeverDestroyed&lt;const String&gt; interchangeNewlineString(MAKE_STATIC_STRING_IMPL(&quot;&lt;br class=\&quot;&quot; AppleInterchangeNewline &quot;\&quot;&gt;&quot;));
 830 
 831     if (!comparePositions(start, end))
 832         return emptyString();
 833 
 834     RefPtr&lt;Node&gt; commonAncestor = commonShadowIncludingAncestor(start, end);
 835     if (!commonAncestor)
 836         return emptyString();
 837 
 838     auto&amp; document = *start.document();
 839     document.updateLayoutIgnorePendingStylesheets();
 840 
 841     VisiblePosition visibleStart { start };
 842     VisiblePosition visibleEnd { end };
 843 
 844     auto body = makeRefPtr(enclosingElementWithTag(firstPositionInNode(commonAncestor.get()), bodyTag));
 845     RefPtr&lt;Element&gt; fullySelectedRoot;
 846     // FIXME: Do this for all fully selected blocks, not just the body.
 847     if (body &amp;&amp; VisiblePosition(firstPositionInNode(body.get())) == visibleStart &amp;&amp; VisiblePosition(lastPositionInNode(body.get())) == visibleEnd)
 848         fullySelectedRoot = body;
 849     bool needsPositionStyleConversion = body &amp;&amp; fullySelectedRoot == body &amp;&amp; document.settings().shouldConvertPositionStyleOnCopy();
 850 
 851     Node* specialCommonAncestor = highestAncestorToWrapMarkup(start, end, *commonAncestor, annotate);
 852 
<span class="line-modified"> 853     StyledMarkupAccumulator accumulator(start, end, nodes, urlsToResolve, serializeComposedTree, annotate, standardFontFamilySerializationMode, msoListMode, needsPositionStyleConversion, specialCommonAncestor);</span>
 854 
 855     Position startAdjustedForInterchangeNewline = start;
 856     if (annotate == AnnotateForInterchange::Yes &amp;&amp; needInterchangeNewlineAfter(visibleStart)) {
 857         if (visibleStart == visibleEnd.previous())
 858             return interchangeNewlineString;
 859 
 860         accumulator.appendString(interchangeNewlineString);
 861         startAdjustedForInterchangeNewline = visibleStart.next().deepEquivalent();
 862 
 863         if (comparePositions(startAdjustedForInterchangeNewline, end) &gt;= 0)
 864             return interchangeNewlineString;
 865     }
 866 
 867     Node* lastClosed = accumulator.serializeNodes(startAdjustedForInterchangeNewline, end);
 868 
 869     if (specialCommonAncestor &amp;&amp; lastClosed) {
 870         // Also include all of the ancestors of lastClosed up to this special ancestor.
 871         for (ContainerNode* ancestor = accumulator.parentNode(*lastClosed); ancestor; ancestor = accumulator.parentNode(*ancestor)) {
 872             if (ancestor == fullySelectedRoot &amp;&amp; convertBlocksToInlines == ConvertBlocksToInlines::No) {
 873                 RefPtr&lt;EditingStyle&gt; fullySelectedRootStyle = styleFromMatchedRulesAndInlineDecl(*fullySelectedRoot);
</pre>
<hr />
<pre>
 902     }
 903 
 904     if (accumulator.needRelativeStyleWrapper() &amp;&amp; needsPositionStyleConversion) {
 905         if (accumulator.needClearingDiv())
 906             accumulator.appendString(&quot;&lt;div style=\&quot;clear: both;\&quot;&gt;&lt;/div&gt;&quot;);
 907         RefPtr&lt;EditingStyle&gt; positionRelativeStyle = styleFromMatchedRulesAndInlineDecl(*body);
 908         positionRelativeStyle-&gt;style()-&gt;setProperty(CSSPropertyPosition, CSSValueRelative);
 909         accumulator.wrapWithStyleNode(positionRelativeStyle-&gt;style(), document, true);
 910     }
 911 
 912     // FIXME: The interchange newline should be placed in the block that it&#39;s in, not after all of the content, unconditionally.
 913     if (annotate == AnnotateForInterchange::Yes &amp;&amp; needInterchangeNewlineAfter(visibleEnd.previous()))
 914         accumulator.appendString(interchangeNewlineString);
 915 
 916     return accumulator.takeResults();
 917 }
 918 
 919 String serializePreservingVisualAppearance(const Range&amp; range, Vector&lt;Node*&gt;* nodes, AnnotateForInterchange annotate, ConvertBlocksToInlines convertBlocksToInlines, ResolveURLs urlsToReslve)
 920 {
 921     return serializePreservingVisualAppearanceInternal(range.startPosition(), range.endPosition(), nodes, urlsToReslve, SerializeComposedTree::No,
<span class="line-modified"> 922         annotate, convertBlocksToInlines, StandardFontFamilySerializationMode::Keep, MSOListMode::DoNotPreserve);</span>
 923 }
 924 
 925 String serializePreservingVisualAppearance(const VisibleSelection&amp; selection, ResolveURLs resolveURLs, SerializeComposedTree serializeComposedTree, Vector&lt;Node*&gt;* nodes)
 926 {
 927     return serializePreservingVisualAppearanceInternal(selection.start(), selection.end(), nodes, resolveURLs, serializeComposedTree,
<span class="line-modified"> 928         AnnotateForInterchange::Yes, ConvertBlocksToInlines::No, StandardFontFamilySerializationMode::Keep, MSOListMode::DoNotPreserve);</span>
 929 }
 930 
 931 
 932 static bool shouldPreserveMSOLists(const String&amp; markup)
 933 {
 934     if (!markup.startsWith(&quot;&lt;html xmlns:&quot;))
 935         return false;
 936     auto tagClose = markup.find(&#39;&gt;&#39;);
 937     if (tagClose == notFound)
 938         return false;
 939     auto htmlTag = markup.substring(0, tagClose);
 940     return htmlTag.contains(&quot;xmlns:o=\&quot;urn:schemas-microsoft-com:office:office\&quot;&quot;)
 941         &amp;&amp; htmlTag.contains(&quot;xmlns:w=\&quot;urn:schemas-microsoft-com:office:word\&quot;&quot;);
 942 }
 943 
 944 String sanitizedMarkupForFragmentInDocument(Ref&lt;DocumentFragment&gt;&amp;&amp; fragment, Document&amp; document, MSOListQuirks msoListQuirks, const String&amp; originalMarkup)
 945 {
 946     MSOListMode msoListMode = msoListQuirks == MSOListQuirks::CheckIfNeeded &amp;&amp; shouldPreserveMSOLists(originalMarkup)
 947         ? MSOListMode::Preserve : MSOListMode::DoNotPreserve;
 948 
 949     auto bodyElement = makeRefPtr(document.body());
 950     ASSERT(bodyElement);
 951     bodyElement-&gt;appendChild(fragment.get());
 952 
 953     // SerializeComposedTree::No because there can&#39;t be a shadow tree in the pasted fragment.
 954     auto result = serializePreservingVisualAppearanceInternal(firstPositionInNode(bodyElement.get()), lastPositionInNode(bodyElement.get()), nullptr,
<span class="line-modified"> 955         ResolveURLs::YesExcludingLocalFileURLsForPrivacy, SerializeComposedTree::No, AnnotateForInterchange::Yes, ConvertBlocksToInlines::No,  StandardFontFamilySerializationMode::Strip, msoListMode);</span>
 956 
 957     if (msoListMode == MSOListMode::Preserve) {
 958         StringBuilder builder;
 959         builder.appendLiteral(&quot;&lt;html xmlns:o=\&quot;urn:schemas-microsoft-com:office:office\&quot;\n&quot;
 960             &quot;xmlns:w=\&quot;urn:schemas-microsoft-com:office:word\&quot;\n&quot;
 961             &quot;xmlns:m=\&quot;http://schemas.microsoft.com/office/2004/12/omml\&quot;\n&quot;
 962             &quot;xmlns=\&quot;http://www.w3.org/TR/REC-html40\&quot;&gt;&quot;);
 963         builder.append(result);
 964         builder.appendLiteral(&quot;&lt;/html&gt;&quot;);
 965         return builder.toString();
 966     }
 967 
 968     return result;
 969 }
 970 
 971 static void restoreAttachmentElementsInFragment(DocumentFragment&amp; fragment)
 972 {
 973 #if ENABLE(ATTACHMENT_ELEMENT)
 974     if (!RuntimeEnabledFeatures::sharedFeatures().attachmentElementEnabled())
 975         return;
 976 
 977     // When creating a fragment we must strip the webkit-attachment-path attribute after restoring the File object.
 978     Vector&lt;Ref&lt;HTMLAttachmentElement&gt;&gt; attachments;
 979     for (auto&amp; attachment : descendantsOfType&lt;HTMLAttachmentElement&gt;(fragment))
 980         attachments.append(attachment);
 981 
 982     for (auto&amp; attachment : attachments) {
 983         attachment-&gt;setUniqueIdentifier(attachment-&gt;attributeWithoutSynchronization(webkitattachmentidAttr));
 984 
 985         auto attachmentPath = attachment-&gt;attachmentPath();
 986         auto blobURL = attachment-&gt;blobURL();
 987         if (!attachmentPath.isEmpty())
<span class="line-modified"> 988             attachment-&gt;setFile(File::create(attachmentPath));</span>
 989         else if (!blobURL.isEmpty())
<span class="line-modified"> 990             attachment-&gt;setFile(File::deserialize({ }, blobURL, attachment-&gt;attachmentType(), attachment-&gt;attachmentTitle()));</span>
 991 
 992         // Remove temporary attributes that were previously added in StyledMarkupAccumulator::appendCustomAttributes.
 993         attachment-&gt;removeAttribute(webkitattachmentidAttr);
 994         attachment-&gt;removeAttribute(webkitattachmentpathAttr);
 995         attachment-&gt;removeAttribute(webkitattachmentbloburlAttr);
 996     }
 997 
 998     Vector&lt;Ref&lt;HTMLImageElement&gt;&gt; images;
 999     for (auto&amp; image : descendantsOfType&lt;HTMLImageElement&gt;(fragment))
1000         images.append(image);
1001 
1002     for (auto&amp; image : images) {
1003         auto attachmentIdentifier = image-&gt;attributeWithoutSynchronization(webkitattachmentidAttr);
1004         if (attachmentIdentifier.isEmpty())
1005             continue;
1006 
1007         auto attachment = HTMLAttachmentElement::create(HTMLNames::attachmentTag, *fragment.ownerDocument());
1008         attachment-&gt;setUniqueIdentifier(attachmentIdentifier);
1009         image-&gt;setAttachmentElement(WTFMove(attachment));
1010         image-&gt;removeAttribute(webkitattachmentidAttr);
</pre>
</td>
</tr>
</table>
<center><a href="atk/FrameSelectionAtk.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../features.json.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
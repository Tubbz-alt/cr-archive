diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/InjectedScriptBase.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/InjectedScriptBase.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/InjectedScriptBase.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/InjectedScriptBase.cpp
@@ -35,11 +35,10 @@
 #include "DebuggerEvalEnabler.h"
 #include "JSCInlines.h"
 #include "JSGlobalObject.h"
 #include "JSLock.h"
 #include "JSNativeStdFunction.h"
-#include "NativeStdFunctionCell.h"
 #include "ScriptFunctionCall.h"
 #include <wtf/JSONValues.h>
 #include <wtf/text/StringConcatenateNumbers.h>
 
 namespace Inspector {
@@ -60,38 +59,35 @@
 {
 }
 
 bool InjectedScriptBase::hasAccessToInspectedScriptState() const
 {
-    return m_environment && m_environment->canAccessInspectedScriptState(m_injectedScriptObject.scriptState());
+    return m_environment && m_environment->canAccessInspectedScriptState(m_injectedScriptObject.globalObject());
 }
 
 const Deprecated::ScriptObject& InjectedScriptBase::injectedScriptObject() const
 {
     return m_injectedScriptObject;
 }
 
-JSC::JSValue InjectedScriptBase::callFunctionWithEvalEnabled(Deprecated::ScriptFunctionCall& function, bool& hadException) const
+Expected<JSC::JSValue, NakedPtr<JSC::Exception>> InjectedScriptBase::callFunctionWithEvalEnabled(Deprecated::ScriptFunctionCall& function) const
 {
-    JSC::ExecState* scriptState = m_injectedScriptObject.scriptState();
-    JSC::DebuggerEvalEnabler evalEnabler(scriptState);
-    return function.call(hadException);
+    JSC::JSGlobalObject* globalObject = m_injectedScriptObject.globalObject();
+    JSC::DebuggerEvalEnabler evalEnabler(globalObject);
+    return function.call();
 }
 
 Ref<JSON::Value> InjectedScriptBase::makeCall(Deprecated::ScriptFunctionCall& function)
 {
     if (hasNoValue() || !hasAccessToInspectedScriptState())
         return JSON::Value::null();
 
-    bool hadException = false;
-    auto resultJSValue = callFunctionWithEvalEnabled(function, hadException);
-
-    ASSERT(!hadException);
-    if (hadException)
+    auto result = callFunctionWithEvalEnabled(function);
+    if (!result)
         return JSON::Value::create("Exception while making a call.");
 
-    RefPtr<JSON::Value> resultJSONValue = toInspectorValue(*m_injectedScriptObject.scriptState(), resultJSValue);
+    RefPtr<JSON::Value> resultJSONValue = toInspectorValue(m_injectedScriptObject.globalObject(), result.value());
     if (!resultJSONValue)
         return JSON::Value::create(makeString("Object has too long reference chain (must not be longer than ", JSON::Value::maxDepth, ')'));
 
     return resultJSONValue.releaseNonNull();
 }
@@ -106,40 +102,38 @@
     if (hasNoValue() || !hasAccessToInspectedScriptState()) {
         checkAsyncCallResult(JSON::Value::null(), callback);
         return;
     }
 
-    auto* scriptState = m_injectedScriptObject.scriptState();
-    JSC::VM& vm = scriptState->vm();
-
-    JSC::JSNativeStdFunction* jsFunction;
+    auto* globalObject = m_injectedScriptObject.globalObject();
+    JSC::VM& vm = globalObject->vm();
 
+    JSC::JSNativeStdFunction* jsFunction = nullptr;
     {
         JSC::JSLockHolder locker(vm);
 
-        jsFunction = JSC::JSNativeStdFunction::create(vm, scriptState->lexicalGlobalObject(), 1, String(), [&, callback = WTFMove(callback)] (JSC::ExecState* exec) {
-            if (!exec)
+        jsFunction = JSC::JSNativeStdFunction::create(vm, globalObject, 1, String(), [&, callback = WTFMove(callback)] (JSC::JSGlobalObject* globalObject, JSC::CallFrame* callFrame) {
+            if (!callFrame)
                 checkAsyncCallResult(JSON::Value::create("Exception while making a call."), callback);
-            else if (auto resultJSONValue = toInspectorValue(*exec, exec->argument(0)))
+            else if (auto resultJSONValue = toInspectorValue(globalObject, callFrame->argument(0)))
                 checkAsyncCallResult(resultJSONValue, callback);
             else
                 checkAsyncCallResult(JSON::Value::create(makeString("Object has too long reference chain (must not be longer than ", JSON::Value::maxDepth, ')')), callback);
             return JSC::JSValue::encode(JSC::jsUndefined());
         });
     }
 
     function.appendArgument(JSC::JSValue(jsFunction));
 
-    bool hadException = false;
-    auto resultJSValue = callFunctionWithEvalEnabled(function, hadException);
-    ASSERT_UNUSED(resultJSValue, resultJSValue.isUndefined());
+    auto result = callFunctionWithEvalEnabled(function);
+    ASSERT_UNUSED(result, result.value().isUndefined());
 
-    ASSERT(!hadException);
-    if (hadException) {
+    ASSERT(result);
+    if (!result) {
         // Since `callback` is moved above, we can't call it if there's an exception while trying to
         // execute the `JSNativeStdFunction` inside InjectedScriptSource.js.
-        jsFunction->nativeStdFunctionCell()->function()(nullptr);
+        jsFunction->function()(globalObject, nullptr);
     }
 }
 
 void InjectedScriptBase::checkCallResult(ErrorString& errorString, RefPtr<JSON::Value> result, RefPtr<Protocol::Runtime::RemoteObject>& out_resultObject, Optional<bool>& out_wasThrown, Optional<int>& out_savedResultIndex)
 {

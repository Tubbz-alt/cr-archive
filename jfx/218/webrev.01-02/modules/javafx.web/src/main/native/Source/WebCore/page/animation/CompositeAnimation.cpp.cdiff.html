<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/page/animation/CompositeAnimation.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSPropertyAnimation.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ImplicitAnimation.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/animation/CompositeAnimation.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 35,10 ***</span>
<span class="line-new-header">--- 35,11 ---</span>
  #include &quot;ImplicitAnimation.h&quot;
  #include &quot;KeyframeAnimation.h&quot;
  #include &quot;Logging.h&quot;
  #include &quot;RenderElement.h&quot;
  #include &quot;RenderStyle.h&quot;
<span class="line-added">+ #include &quot;StyleAdjuster.h&quot;</span>
  #include &lt;wtf/NeverDestroyed.h&gt;
  #include &lt;wtf/text/CString.h&gt;
  
  namespace WebCore {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 284,12 ***</span>
      // We don&#39;t do any transitions if we don&#39;t have a currentStyle (on startup).
      updateTransitions(element, currentStyle, targetStyle);
      updateKeyframeAnimations(element, currentStyle, targetStyle);
      m_keyframeAnimations.checkConsistency();
  
<span class="line-modified">!     bool animationChangeRequiresRecomposite = false;</span>
<span class="line-removed">-     bool forceStackingContext = false;</span>
  
      std::unique_ptr&lt;RenderStyle&gt; animatedStyle;
  
      if (currentStyle) {
          // Now that we have transition objects ready, let them know about the new goal state.  We want them
<span class="line-new-header">--- 285,11 ---</span>
      // We don&#39;t do any transitions if we don&#39;t have a currentStyle (on startup).
      updateTransitions(element, currentStyle, targetStyle);
      updateKeyframeAnimations(element, currentStyle, targetStyle);
      m_keyframeAnimations.checkConsistency();
  
<span class="line-modified">!     OptionSet&lt;AnimationImpact&gt; imapct;</span>
  
      std::unique_ptr&lt;RenderStyle&gt; animatedStyle;
  
      if (currentStyle) {
          // Now that we have transition objects ready, let them know about the new goal state.  We want them
</pre>
<hr />
<pre>
<span class="line-old-header">*** 298,15 ***</span>
          for (auto&amp; transition : m_transitions.values()) {
              auto changes = transition-&gt;animate(*this, targetStyle, animatedStyle);
              if (changes.contains(AnimateChange::StyleBlended))
                  checkForStackingContext |= WillChangeData::propertyCreatesStackingContext(transition-&gt;animatingProperty());
  
<span class="line-modified">!             animationChangeRequiresRecomposite = changes.contains(AnimateChange::RunningStateChange) &amp;&amp; transition-&gt;affectsAcceleratedProperty();</span>
          }
  
          if (animatedStyle &amp;&amp; checkForStackingContext) {
<span class="line-modified">!             // Note that this is similar to code in StyleResolver::adjustRenderStyle() but only needs to consult</span>
              // animatable properties that can trigger stacking context.
              if (animatedStyle-&gt;opacity() &lt; 1.0f
                  || animatedStyle-&gt;hasTransformRelatedProperty()
                  || animatedStyle-&gt;hasMask()
                  || animatedStyle-&gt;clipPath()
<span class="line-new-header">--- 298,16 ---</span>
          for (auto&amp; transition : m_transitions.values()) {
              auto changes = transition-&gt;animate(*this, targetStyle, animatedStyle);
              if (changes.contains(AnimateChange::StyleBlended))
                  checkForStackingContext |= WillChangeData::propertyCreatesStackingContext(transition-&gt;animatingProperty());
  
<span class="line-modified">!             if (changes.contains(AnimateChange::RunningStateChange) &amp;&amp; transition-&gt;affectsAcceleratedProperty())</span>
<span class="line-added">+                 imapct.add(AnimationImpact::RequiresRecomposite);</span>
          }
  
          if (animatedStyle &amp;&amp; checkForStackingContext) {
<span class="line-modified">!             // Note that this is similar to code in Style::Adjuster::adjust() but only needs to consult</span>
              // animatable properties that can trigger stacking context.
              if (animatedStyle-&gt;opacity() &lt; 1.0f
                  || animatedStyle-&gt;hasTransformRelatedProperty()
                  || animatedStyle-&gt;hasMask()
                  || animatedStyle-&gt;clipPath()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 314,36 ***</span>
                  || animatedStyle-&gt;hasFilter()
  #if ENABLE(FILTERS_LEVEL_2)
                  || animatedStyle-&gt;hasBackdropFilter()
  #endif
                  )
<span class="line-modified">!             forceStackingContext = true;</span>
          }
      }
  
      // Now that we have animation objects ready, let them know about the new goal state.  We want them
      // to fill in a RenderStyle*&amp; only if needed.
      for (auto&amp; name : m_keyframeAnimationOrderMap) {
          RefPtr&lt;KeyframeAnimation&gt; keyframeAnim = m_keyframeAnimations.get(name);
          if (keyframeAnim) {
              auto changes = keyframeAnim-&gt;animate(*this, targetStyle, animatedStyle);
<span class="line-modified">!             animationChangeRequiresRecomposite = changes.contains(AnimateChange::RunningStateChange) &amp;&amp; keyframeAnim-&gt;affectsAcceleratedProperty();</span>
<span class="line-modified">!             forceStackingContext |= changes.contains(AnimateChange::StyleBlended) &amp;&amp; keyframeAnim-&gt;triggersStackingContext();</span>
              m_hasAnimationThatDependsOnLayout |= keyframeAnim-&gt;dependsOnLayout();
          }
      }
  
<span class="line-modified">!     // https://drafts.csswg.org/css-animations-1/</span>
<span class="line-removed">-     // While an animation is applied but has not finished, or has finished but has an animation-fill-mode of forwards or both,</span>
<span class="line-removed">-     // the user agent must act as if the will-change property ([css-will-change-1]) on the element additionally</span>
<span class="line-removed">-     // includes all the properties animated by the animation.</span>
<span class="line-removed">-     if (forceStackingContext &amp;&amp; animatedStyle) {</span>
<span class="line-removed">-         if (animatedStyle-&gt;hasAutoZIndex())</span>
<span class="line-removed">-             animatedStyle-&gt;setZIndex(0);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return { WTFMove(animatedStyle), animationChangeRequiresRecomposite };</span>
  }
  
  std::unique_ptr&lt;RenderStyle&gt; CompositeAnimation::getAnimatedStyle() const
  {
      std::unique_ptr&lt;RenderStyle&gt; resultStyle;
<span class="line-new-header">--- 315,31 ---</span>
                  || animatedStyle-&gt;hasFilter()
  #if ENABLE(FILTERS_LEVEL_2)
                  || animatedStyle-&gt;hasBackdropFilter()
  #endif
                  )
<span class="line-modified">!             imapct.add(AnimationImpact::ForcesStackingContext);</span>
          }
      }
  
      // Now that we have animation objects ready, let them know about the new goal state.  We want them
      // to fill in a RenderStyle*&amp; only if needed.
      for (auto&amp; name : m_keyframeAnimationOrderMap) {
          RefPtr&lt;KeyframeAnimation&gt; keyframeAnim = m_keyframeAnimations.get(name);
          if (keyframeAnim) {
              auto changes = keyframeAnim-&gt;animate(*this, targetStyle, animatedStyle);
<span class="line-modified">!             if (changes.contains(AnimateChange::RunningStateChange) &amp;&amp; keyframeAnim-&gt;affectsAcceleratedProperty())</span>
<span class="line-modified">!                 imapct.add(AnimationImpact::RequiresRecomposite);</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (changes.contains(AnimateChange::StyleBlended) &amp;&amp; keyframeAnim-&gt;triggersStackingContext())</span>
<span class="line-added">+                 imapct.add(AnimationImpact::ForcesStackingContext);</span>
<span class="line-added">+ </span>
              m_hasAnimationThatDependsOnLayout |= keyframeAnim-&gt;dependsOnLayout();
          }
      }
  
<span class="line-modified">!     return { WTFMove(animatedStyle), imapct };</span>
  }
  
  std::unique_ptr&lt;RenderStyle&gt; CompositeAnimation::getAnimatedStyle() const
  {
      std::unique_ptr&lt;RenderStyle&gt; resultStyle;
</pre>
<center><a href="CSSPropertyAnimation.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ImplicitAnimation.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/AssemblerBufferWithConstantPool.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2009 University of Szeged
  3  * All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY UNIVERSITY OF SZEGED ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL UNIVERSITY OF SZEGED OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #if ENABLE(ASSEMBLER)
 30 
 31 #include &quot;AssemblerBuffer.h&quot;
 32 #include &lt;wtf/SegmentedVector.h&gt;
 33 
 34 #define ASSEMBLER_HAS_CONSTANT_POOL 1
 35 
 36 namespace JSC {
 37 
 38 /*
 39     On a constant pool 4 or 8 bytes data can be stored. The values can be
 40     constants or addresses. The addresses should be 32 or 64 bits. The constants
 41     should be double-precisions float or integer numbers which are hard to be
 42     encoded as few machine instructions.
 43 
 44     TODO: The pool is desinged to handle both 32 and 64 bits values, but
 45     currently only the 4 bytes constants are implemented and tested.
 46 
 47     The AssemblerBuffer can contain multiple constant pools. Each pool is inserted
 48     into the instruction stream - protected by a jump instruction from the
 49     execution flow.
 50 
 51     The flush mechanism is called when no space remain to insert the next instruction
 52     into the pool. Three values are used to determine when the constant pool itself
 53     have to be inserted into the instruction stream (Assembler Buffer):
 54 
 55     - maxPoolSize: size of the constant pool in bytes, this value cannot be
 56         larger than the maximum offset of a PC relative memory load
 57 
 58     - barrierSize: size of jump instruction in bytes which protects the
 59         constant pool from execution
 60 
 61     - maxInstructionSize: maximum length of a machine instruction in bytes
 62 
 63     There are some callbacks which solve the target architecture specific
 64     address handling:
 65 
 66     - TYPE patchConstantPoolLoad(TYPE load, int value):
 67         patch the &#39;load&#39; instruction with the index of the constant in the
 68         constant pool and return the patched instruction.
 69 
 70     - void patchConstantPoolLoad(void* loadAddr, void* constPoolAddr):
 71         patch the a PC relative load instruction at &#39;loadAddr&#39; address with the
 72         final relative offset. The offset can be computed with help of
 73         &#39;constPoolAddr&#39; (the address of the constant pool) and index of the
 74         constant (which is stored previously in the load instruction itself).
 75 
 76     - TYPE placeConstantPoolBarrier(int size):
 77         return with a constant pool barrier instruction which jumps over the
 78         constant pool.
 79 
 80     The &#39;put*WithConstant*&#39; functions should be used to place a data into the
 81     constant pool.
 82 */
 83 
 84 template &lt;int maxPoolSize, int barrierSize, int maxInstructionSize, class AssemblerType&gt;
 85 class AssemblerBufferWithConstantPool : public AssemblerBuffer {
 86     typedef SegmentedVector&lt;uint32_t, 512&gt; LoadOffsets;
 87     using AssemblerBuffer::putIntegral;
 88     using AssemblerBuffer::putIntegralUnchecked;
 89 public:
 90     typedef struct {
 91         short high;
 92         short low;
 93     } TwoShorts;
 94 
 95     enum {
 96         UniqueConst,
 97         ReusableConst,
 98         UnusedEntry,
 99     };
100 
101     AssemblerBufferWithConstantPool()
102         : AssemblerBuffer()
103         , m_numConsts(0)
104         , m_maxDistance(maxPoolSize)
105         , m_lastConstDelta(0)
106     {
<a name="1" id="anc1"></a><span class="line-modified">107         m_pool = static_cast&lt;uint32_t*&gt;(AssemblerDataMalloc::malloc(maxPoolSize));</span>
<span class="line-modified">108         m_mask = static_cast&lt;char*&gt;(AssemblerDataMalloc::malloc(maxPoolSize / sizeof(uint32_t)));</span>
109     }
110 
111     ~AssemblerBufferWithConstantPool()
112     {
<a name="2" id="anc2"></a><span class="line-modified">113         AssemblerDataMalloc::free(m_mask);</span>
<span class="line-modified">114         AssemblerDataMalloc::free(m_pool);</span>
115     }
116 
117     void ensureSpace(int space)
118     {
119         flushIfNoSpaceFor(space);
120         AssemblerBuffer::ensureSpace(space);
121     }
122 
123     void ensureSpace(int insnSpace, int constSpace)
124     {
125         flushIfNoSpaceFor(insnSpace, constSpace);
126         AssemblerBuffer::ensureSpace(insnSpace);
127     }
128 
129     void ensureSpaceForAnyInstruction(int amount = 1)
130     {
131         flushIfNoSpaceFor(amount * maxInstructionSize, amount * sizeof(uint64_t));
132     }
133 
134     bool isAligned(int alignment)
135     {
136         flushIfNoSpaceFor(alignment);
137         return AssemblerBuffer::isAligned(alignment);
138     }
139 
140     void putByteUnchecked(int value)
141     {
142         AssemblerBuffer::putByteUnchecked(value);
143         correctDeltas(1);
144     }
145 
146     void putByte(int value)
147     {
148         flushIfNoSpaceFor(1);
149         AssemblerBuffer::putByte(value);
150         correctDeltas(1);
151     }
152 
153     void putShortUnchecked(int value)
154     {
155         AssemblerBuffer::putShortUnchecked(value);
156         correctDeltas(2);
157     }
158 
159     void putShort(int value)
160     {
161         flushIfNoSpaceFor(2);
162         AssemblerBuffer::putShort(value);
163         correctDeltas(2);
164     }
165 
166     void putIntUnchecked(int value)
167     {
168         AssemblerBuffer::putIntUnchecked(value);
169         correctDeltas(4);
170     }
171 
172     void putInt(int value)
173     {
174         flushIfNoSpaceFor(4);
175         AssemblerBuffer::putInt(value);
176         correctDeltas(4);
177     }
178 
179     void putInt64Unchecked(int64_t value)
180     {
181         AssemblerBuffer::putInt64Unchecked(value);
182         correctDeltas(8);
183     }
184 
185     void putIntegral(TwoShorts value)
186     {
187         putIntegral(value.high);
188         putIntegral(value.low);
189     }
190 
191     void putIntegralUnchecked(TwoShorts value)
192     {
193         putIntegralUnchecked(value.high);
194         putIntegralUnchecked(value.low);
195     }
196 
197     void putShortWithConstantInt(uint16_t insn, uint32_t constant, bool isReusable = false)
198     {
199         putIntegralWithConstantInt(insn, constant, isReusable);
200     }
201 
202     void putIntWithConstantInt(uint32_t insn, uint32_t constant, bool isReusable = false)
203     {
204         putIntegralWithConstantInt(insn, constant, isReusable);
205     }
206 
207     // This flushing mechanism can be called after any unconditional jumps.
208     void flushWithoutBarrier(bool isForced = false)
209     {
210         // Flush if constant pool is more than 60% full to avoid overuse of this function.
211         if (isForced || 5 * static_cast&lt;uint32_t&gt;(m_numConsts) &gt; 3 * maxPoolSize / sizeof(uint32_t))
212             flushConstantPool(false);
213     }
214 
215     uint32_t* poolAddress()
216     {
217         return m_pool;
218     }
219 
220     int sizeOfConstantPool()
221     {
222         return m_numConsts;
223     }
224 
225     void flushConstantPool(bool useBarrier = true)
226     {
227         if (!m_numConsts)
228             return;
229         int alignPool = (codeSize() + (useBarrier ? barrierSize : 0)) &amp; (sizeof(uint64_t) - 1);
230 
231         if (alignPool)
232             alignPool = sizeof(uint64_t) - alignPool;
233 
234         // Callback to protect the constant pool from execution
235         if (useBarrier)
236             putIntegral(AssemblerType::placeConstantPoolBarrier(m_numConsts * sizeof(uint32_t) + alignPool));
237 
238         if (alignPool) {
239             if (alignPool &amp; 1)
240                 AssemblerBuffer::putByte(AssemblerType::padForAlign8);
241             if (alignPool &amp; 2)
242                 AssemblerBuffer::putShort(AssemblerType::padForAlign16);
243             if (alignPool &amp; 4)
244                 AssemblerBuffer::putInt(AssemblerType::padForAlign32);
245         }
246 
247         int constPoolOffset = codeSize();
248         append(reinterpret_cast&lt;char*&gt;(m_pool), m_numConsts * sizeof(uint32_t));
249 
250         // Patch each PC relative load
251         for (LoadOffsets::Iterator iter = m_loadOffsets.begin(); iter != m_loadOffsets.end(); ++iter) {
252             void* loadAddr = reinterpret_cast&lt;char*&gt;(data()) + *iter;
253             AssemblerType::patchConstantPoolLoad(loadAddr, reinterpret_cast&lt;char*&gt;(data()) + constPoolOffset);
254         }
255 
256         m_loadOffsets.clear();
257         m_numConsts = 0;
258     }
259 
260 private:
261     void correctDeltas(int insnSize)
262     {
263         m_maxDistance -= insnSize;
264         m_lastConstDelta -= insnSize;
265         if (m_lastConstDelta &lt; 0)
266             m_lastConstDelta = 0;
267     }
268 
269     void correctDeltas(int insnSize, int constSize)
270     {
271         correctDeltas(insnSize);
272 
273         m_maxDistance -= m_lastConstDelta;
274         m_lastConstDelta = constSize;
275     }
276 
277     template&lt;typename IntegralType&gt;
278     void putIntegralWithConstantInt(IntegralType insn, uint32_t constant, bool isReusable)
279     {
280         if (!m_numConsts)
281             m_maxDistance = maxPoolSize;
282         flushIfNoSpaceFor(sizeof(IntegralType), 4);
283 
284         m_loadOffsets.append(codeSize());
285         if (isReusable) {
286             for (int i = 0; i &lt; m_numConsts; ++i) {
287                 if (m_mask[i] == ReusableConst &amp;&amp; m_pool[i] == constant) {
288                     putIntegral(static_cast&lt;IntegralType&gt;(AssemblerType::patchConstantPoolLoad(insn, i)));
289                     correctDeltas(sizeof(IntegralType));
290                     return;
291                 }
292             }
293         }
294 
295         m_pool[m_numConsts] = constant;
296         m_mask[m_numConsts] = static_cast&lt;char&gt;(isReusable ? ReusableConst : UniqueConst);
297 
298         putIntegral(static_cast&lt;IntegralType&gt;(AssemblerType::patchConstantPoolLoad(insn, m_numConsts)));
299         ++m_numConsts;
300 
301         correctDeltas(sizeof(IntegralType), 4);
302     }
303 
304     void flushIfNoSpaceFor(int nextInsnSize)
305     {
306         if (m_numConsts == 0)
307             return;
308         int lastConstDelta = m_lastConstDelta &gt; nextInsnSize ? m_lastConstDelta - nextInsnSize : 0;
309         if ((m_maxDistance &lt; nextInsnSize + lastConstDelta + barrierSize + (int)sizeof(uint32_t)))
310             flushConstantPool();
311     }
312 
313     void flushIfNoSpaceFor(int nextInsnSize, int nextConstSize)
314     {
315         if (m_numConsts == 0)
316             return;
317         if ((m_maxDistance &lt; nextInsnSize + m_lastConstDelta + nextConstSize + barrierSize + (int)sizeof(uint32_t)) ||
318             (m_numConsts * sizeof(uint32_t) + nextConstSize &gt;= maxPoolSize))
319             flushConstantPool();
320     }
321 
322     uint32_t* m_pool;
323     char* m_mask;
324     LoadOffsets m_loadOffsets;
325 
326     int m_numConsts;
327     int m_maxDistance;
328     int m_lastConstDelta;
329 };
330 
331 } // namespace JSC
332 
333 #endif // ENABLE(ASSEMBLER)
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
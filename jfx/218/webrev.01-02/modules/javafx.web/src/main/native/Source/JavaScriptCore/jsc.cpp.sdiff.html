<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jsc.cpp</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="jit/UnusedPointer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="llint/LLIntData.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jsc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  10  *
  11  *  This library is distributed in the hope that it will be useful,
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 
  25 #include &quot;ArrayBuffer.h&quot;
  26 #include &quot;ArrayPrototype.h&quot;
  27 #include &quot;BuiltinNames.h&quot;
  28 #include &quot;ButterflyInlines.h&quot;
  29 #include &quot;BytecodeCacheError.h&quot;

  30 #include &quot;CatchScope.h&quot;
  31 #include &quot;CodeBlock.h&quot;
  32 #include &quot;CodeCache.h&quot;

  33 #include &quot;Completion.h&quot;
  34 #include &quot;ConfigFile.h&quot;
  35 #include &quot;Disassembler.h&quot;
  36 #include &quot;Exception.h&quot;
  37 #include &quot;ExceptionHelpers.h&quot;
  38 #include &quot;HeapProfiler.h&quot;
  39 #include &quot;HeapSnapshotBuilder.h&quot;
  40 #include &quot;InitializeThreading.h&quot;
  41 #include &quot;Interpreter.h&quot;
  42 #include &quot;JIT.h&quot;
  43 #include &quot;JSArray.h&quot;
  44 #include &quot;JSArrayBuffer.h&quot;
  45 #include &quot;JSBigInt.h&quot;
  46 #include &quot;JSCInlines.h&quot;
  47 #include &quot;JSFunction.h&quot;
  48 #include &quot;JSInternalPromise.h&quot;
<span class="line-removed">  49 #include &quot;JSInternalPromiseDeferred.h&quot;</span>
  50 #include &quot;JSLock.h&quot;
  51 #include &quot;JSModuleLoader.h&quot;
  52 #include &quot;JSNativeStdFunction.h&quot;
  53 #include &quot;JSONObject.h&quot;

  54 #include &quot;JSSourceCode.h&quot;
  55 #include &quot;JSString.h&quot;
  56 #include &quot;JSTypedArrays.h&quot;
  57 #include &quot;JSWebAssemblyInstance.h&quot;
  58 #include &quot;JSWebAssemblyMemory.h&quot;
  59 #include &quot;LLIntThunks.h&quot;
  60 #include &quot;ObjectConstructor.h&quot;
  61 #include &quot;ParserError.h&quot;
  62 #include &quot;ProfilerDatabase.h&quot;
<span class="line-modified">  63 #include &quot;PromiseDeferredTimer.h&quot;</span>
  64 #include &quot;ProtoCallFrame.h&quot;
  65 #include &quot;ReleaseHeapAccessScope.h&quot;
  66 #include &quot;SamplingProfiler.h&quot;
  67 #include &quot;StackVisitor.h&quot;
  68 #include &quot;StructureInlines.h&quot;
  69 #include &quot;StructureRareDataInlines.h&quot;
  70 #include &quot;SuperSampler.h&quot;
  71 #include &quot;TestRunnerUtils.h&quot;
  72 #include &quot;TypedArrayInlines.h&quot;

  73 #include &quot;WasmCapabilities.h&quot;
  74 #include &quot;WasmContext.h&quot;
  75 #include &quot;WasmFaultSignalHandler.h&quot;
  76 #include &quot;WasmMemory.h&quot;
  77 #include &lt;locale.h&gt;
  78 #include &lt;math.h&gt;
  79 #include &lt;stdio.h&gt;
  80 #include &lt;stdlib.h&gt;
  81 #include &lt;string.h&gt;
  82 #include &lt;sys/stat.h&gt;
  83 #include &lt;sys/types.h&gt;
  84 #include &lt;thread&gt;
  85 #include &lt;type_traits&gt;
  86 #include &lt;wtf/Box.h&gt;

  87 #include &lt;wtf/CommaPrinter.h&gt;
  88 #include &lt;wtf/FileSystem.h&gt;
  89 #include &lt;wtf/MainThread.h&gt;
  90 #include &lt;wtf/MemoryPressureHandler.h&gt;
  91 #include &lt;wtf/MonotonicTime.h&gt;
  92 #include &lt;wtf/NeverDestroyed.h&gt;
  93 #include &lt;wtf/Scope.h&gt;
  94 #include &lt;wtf/StringPrintStream.h&gt;
  95 #include &lt;wtf/URL.h&gt;
  96 #include &lt;wtf/WallTime.h&gt;
  97 #include &lt;wtf/text/StringBuilder.h&gt;
  98 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  99 
 100 #if OS(WINDOWS)
 101 #include &lt;direct.h&gt;
 102 #include &lt;fcntl.h&gt;
 103 #include &lt;io.h&gt;
 104 #else
 105 #include &lt;unistd.h&gt;
 106 #endif
</pre>
<hr />
<pre>
 115 #define Function ReadlineFunction
 116 #include &lt;readline/history.h&gt;
 117 #include &lt;readline/readline.h&gt;
 118 #undef Function
 119 #endif
 120 
 121 #if HAVE(SYS_TIME_H)
 122 #include &lt;sys/time.h&gt;
 123 #endif
 124 
 125 #if HAVE(SIGNAL_H)
 126 #include &lt;signal.h&gt;
 127 #endif
 128 
 129 #if COMPILER(MSVC)
 130 #include &lt;crtdbg.h&gt;
 131 #include &lt;mmsystem.h&gt;
 132 #include &lt;windows.h&gt;
 133 #endif
 134 
<span class="line-modified"> 135 #if PLATFORM(IOS_FAMILY) &amp;&amp; CPU(ARM_THUMB2)</span>
 136 #include &lt;fenv.h&gt;
 137 #include &lt;arm/arch.h&gt;
 138 #endif
 139 
 140 #if OS(DARWIN)
 141 #include &lt;wtf/spi/darwin/ProcessMemoryFootprint.h&gt;





 142 struct MemoryFootprint : ProcessMemoryFootprint {
 143     MemoryFootprint(const ProcessMemoryFootprint&amp; src)
 144         : ProcessMemoryFootprint(src)
 145     {
 146     }
 147 };
 148 #else
 149 struct MemoryFootprint {
 150     uint64_t current;
 151     uint64_t peak;
 152 
 153     static MemoryFootprint now()
 154     {
 155         return { 0L, 0L };
 156     }
 157 
 158     static void resetPeak()
 159     {
 160     }
 161 };
</pre>
<hr />
<pre>
 178         for (;;) {
 179 #if OS(WINDOWS)
 180             Sleep(1000);
 181 #else
 182             pause();
 183 #endif
 184         }
 185     }
 186 #endif // ENABLE(DFG_JIT)
 187     exit(status);
 188 }
 189 
 190 class Masquerader : public JSNonFinalObject {
 191 public:
 192     Masquerader(VM&amp; vm, Structure* structure)
 193         : Base(vm, structure)
 194     {
 195     }
 196 
 197     typedef JSNonFinalObject Base;
<span class="line-modified"> 198     static const unsigned StructureFlags = Base::StructureFlags | JSC::MasqueradesAsUndefined;</span>
 199 
 200     static Masquerader* create(VM&amp; vm, JSGlobalObject* globalObject)
 201     {
 202         globalObject-&gt;masqueradesAsUndefinedWatchpoint()-&gt;fireAll(vm, &quot;Masquerading object allocated&quot;);
 203         Structure* structure = createStructure(vm, globalObject, jsNull());
 204         Masquerader* result = new (NotNull, allocateCell&lt;Masquerader&gt;(vm.heap)) Masquerader(vm, structure);
 205         result-&gt;finishCreation(vm);
 206         return result;
 207     }
 208 
 209     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 210     {
 211         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 212     }
 213 
 214     DECLARE_INFO;
 215 };
 216 
 217 const ClassInfo Masquerader::s_info = { &quot;Masquerader&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(Masquerader) };
 218 static unsigned asyncTestPasses { 0 };
 219 static unsigned asyncTestExpectedPasses { 0 };
 220 
 221 }
 222 
 223 template&lt;typename Vector&gt;
 224 static bool fillBufferWithContentsOfFile(const String&amp; fileName, Vector&amp; buffer);
 225 static RefPtr&lt;Uint8Array&gt; fillBufferWithContentsOfFile(const String&amp; fileName);
 226 
 227 class CommandLine;
 228 class GlobalObject;
 229 class Workers;
 230 
 231 template&lt;typename Func&gt;
 232 int runJSC(const CommandLine&amp;, bool isWorker, const Func&amp;);
<span class="line-modified"> 233 static void checkException(ExecState*, GlobalObject*, bool isLastFile, bool hasException, JSValue, CommandLine&amp;, bool&amp; success);</span>
 234 
 235 class Message : public ThreadSafeRefCounted&lt;Message&gt; {
 236 public:
 237     Message(ArrayBufferContents&amp;&amp;, int32_t);
 238     ~Message();
 239 
 240     ArrayBufferContents&amp;&amp; releaseContents() { return WTFMove(m_contents); }
 241     int32_t index() const { return m_index; }
 242 
 243 private:
 244     ArrayBufferContents m_contents;
 245     int32_t m_index { 0 };
 246 };
 247 
 248 class Worker : public BasicRawSentinelNode&lt;Worker&gt; {
 249 public:
 250     Worker(Workers&amp;);
 251     ~Worker();
 252 
 253     void enqueue(const AbstractLocker&amp;, RefPtr&lt;Message&gt;);
</pre>
<hr />
<pre>
 271 
 272     template&lt;typename Func&gt;
 273     void broadcast(const Func&amp;);
 274 
 275     void report(const String&amp;);
 276     String tryGetReport();
 277     String getReport();
 278 
 279     static Workers&amp; singleton();
 280 
 281 private:
 282     friend class Worker;
 283 
 284     Lock m_lock;
 285     Condition m_condition;
 286     SentinelLinkedList&lt;Worker, BasicRawSentinelNode&lt;Worker&gt;&gt; m_workers;
 287     Deque&lt;String&gt; m_reports;
 288 };
 289 
 290 
<span class="line-modified"> 291 static EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(ExecState*);</span>
<span class="line-modified"> 292 </span>
<span class="line-modified"> 293 static EncodedJSValue JSC_HOST_CALL functionPrintStdOut(ExecState*);</span>
<span class="line-modified"> 294 static EncodedJSValue JSC_HOST_CALL functionPrintStdErr(ExecState*);</span>
<span class="line-modified"> 295 static EncodedJSValue JSC_HOST_CALL functionDebug(ExecState*);</span>
<span class="line-modified"> 296 static EncodedJSValue JSC_HOST_CALL functionDescribe(ExecState*);</span>
<span class="line-modified"> 297 static EncodedJSValue JSC_HOST_CALL functionDescribeArray(ExecState*);</span>
<span class="line-modified"> 298 static EncodedJSValue JSC_HOST_CALL functionSleepSeconds(ExecState*);</span>
<span class="line-modified"> 299 static EncodedJSValue JSC_HOST_CALL functionJSCStack(ExecState*);</span>
<span class="line-modified"> 300 static EncodedJSValue JSC_HOST_CALL functionGCAndSweep(ExecState*);</span>
<span class="line-modified"> 301 static EncodedJSValue JSC_HOST_CALL functionFullGC(ExecState*);</span>
<span class="line-modified"> 302 static EncodedJSValue JSC_HOST_CALL functionEdenGC(ExecState*);</span>
<span class="line-modified"> 303 static EncodedJSValue JSC_HOST_CALL functionForceGCSlowPaths(ExecState*);</span>
<span class="line-modified"> 304 static EncodedJSValue JSC_HOST_CALL functionHeapSize(ExecState*);</span>
<span class="line-modified"> 305 static EncodedJSValue JSC_HOST_CALL functionCreateMemoryFootprint(ExecState*);</span>
<span class="line-modified"> 306 static EncodedJSValue JSC_HOST_CALL functionResetMemoryPeak(ExecState*);</span>
<span class="line-modified"> 307 static EncodedJSValue JSC_HOST_CALL functionAddressOf(ExecState*);</span>
<span class="line-modified"> 308 static EncodedJSValue JSC_HOST_CALL functionVersion(ExecState*);</span>
<span class="line-modified"> 309 static EncodedJSValue JSC_HOST_CALL functionRun(ExecState*);</span>
<span class="line-modified"> 310 static EncodedJSValue JSC_HOST_CALL functionRunString(ExecState*);</span>
<span class="line-modified"> 311 static EncodedJSValue JSC_HOST_CALL functionLoad(ExecState*);</span>
<span class="line-modified"> 312 static EncodedJSValue JSC_HOST_CALL functionLoadString(ExecState*);</span>
<span class="line-modified"> 313 static EncodedJSValue JSC_HOST_CALL functionReadFile(ExecState*);</span>
<span class="line-modified"> 314 static EncodedJSValue JSC_HOST_CALL functionCheckSyntax(ExecState*);</span>
<span class="line-modified"> 315 static EncodedJSValue JSC_HOST_CALL functionReadline(ExecState*);</span>
<span class="line-modified"> 316 static EncodedJSValue JSC_HOST_CALL functionPreciseTime(ExecState*);</span>
<span class="line-modified"> 317 static EncodedJSValue JSC_HOST_CALL functionNeverInlineFunction(ExecState*);</span>
<span class="line-modified"> 318 static EncodedJSValue JSC_HOST_CALL functionNoDFG(ExecState*);</span>
<span class="line-modified"> 319 static EncodedJSValue JSC_HOST_CALL functionNoFTL(ExecState*);</span>
<span class="line-modified"> 320 static EncodedJSValue JSC_HOST_CALL functionNoOSRExitFuzzing(ExecState*);</span>
<span class="line-modified"> 321 static EncodedJSValue JSC_HOST_CALL functionOptimizeNextInvocation(ExecState*);</span>
<span class="line-modified"> 322 static EncodedJSValue JSC_HOST_CALL functionNumberOfDFGCompiles(ExecState*);</span>
<span class="line-modified"> 323 static EncodedJSValue JSC_HOST_CALL functionJSCOptions(ExecState*);</span>
<span class="line-modified"> 324 static EncodedJSValue JSC_HOST_CALL functionReoptimizationRetryCount(ExecState*);</span>
<span class="line-modified"> 325 static EncodedJSValue JSC_HOST_CALL functionTransferArrayBuffer(ExecState*);</span>
<span class="line-modified"> 326 static EncodedJSValue JSC_HOST_CALL functionFailNextNewCodeBlock(ExecState*);</span>
<span class="line-modified"> 327 static NO_RETURN_WITH_VALUE EncodedJSValue JSC_HOST_CALL functionQuit(ExecState*);</span>
<span class="line-modified"> 328 static EncodedJSValue JSC_HOST_CALL functionFalse(ExecState*);</span>
<span class="line-modified"> 329 static EncodedJSValue JSC_HOST_CALL functionUndefined1(ExecState*);</span>
<span class="line-modified"> 330 static EncodedJSValue JSC_HOST_CALL functionUndefined2(ExecState*);</span>
<span class="line-modified"> 331 static EncodedJSValue JSC_HOST_CALL functionIsInt32(ExecState*);</span>
<span class="line-modified"> 332 static EncodedJSValue JSC_HOST_CALL functionIsPureNaN(ExecState*);</span>
<span class="line-modified"> 333 static EncodedJSValue JSC_HOST_CALL functionEffectful42(ExecState*);</span>
<span class="line-modified"> 334 static EncodedJSValue JSC_HOST_CALL functionIdentity(ExecState*);</span>
<span class="line-modified"> 335 static EncodedJSValue JSC_HOST_CALL functionMakeMasquerader(ExecState*);</span>
<span class="line-modified"> 336 static EncodedJSValue JSC_HOST_CALL functionHasCustomProperties(ExecState*);</span>
<span class="line-modified"> 337 static EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(ExecState*);</span>
<span class="line-modified"> 338 static EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(ExecState*);</span>
<span class="line-modified"> 339 static EncodedJSValue JSC_HOST_CALL functionReleaseWeakRefs(ExecState*);</span>
<span class="line-modified"> 340 static EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(ExecState*);</span>
<span class="line-modified"> 341 static EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(ExecState*);</span>
<span class="line-modified"> 342 static EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(ExecState*);</span>
<span class="line-modified"> 343 static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(ExecState*);</span>
<span class="line-modified"> 344 static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(ExecState*);</span>
<span class="line-modified"> 345 static EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(ExecState*);</span>
<span class="line-modified"> 346 static EncodedJSValue JSC_HOST_CALL functionEnsureArrayStorage(ExecState*);</span>
 347 #if ENABLE(SAMPLING_PROFILER)
<span class="line-modified"> 348 static EncodedJSValue JSC_HOST_CALL functionStartSamplingProfiler(ExecState*);</span>
<span class="line-modified"> 349 static EncodedJSValue JSC_HOST_CALL functionSamplingProfilerStackTraces(ExecState*);</span>
 350 #endif
 351 
<span class="line-modified"> 352 static EncodedJSValue JSC_HOST_CALL functionMaxArguments(ExecState*);</span>
<span class="line-modified"> 353 static EncodedJSValue JSC_HOST_CALL functionAsyncTestStart(ExecState*);</span>
<span class="line-modified"> 354 static EncodedJSValue JSC_HOST_CALL functionAsyncTestPassed(ExecState*);</span>
 355 
 356 #if ENABLE(WEBASSEMBLY)
<span class="line-modified"> 357 static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(ExecState*);</span>
 358 #endif
 359 
 360 #if ENABLE(SAMPLING_FLAGS)
<span class="line-modified"> 361 static EncodedJSValue JSC_HOST_CALL functionSetSamplingFlags(ExecState*);</span>
<span class="line-modified"> 362 static EncodedJSValue JSC_HOST_CALL functionClearSamplingFlags(ExecState*);</span>
 363 #endif
 364 
<span class="line-modified"> 365 static EncodedJSValue JSC_HOST_CALL functionGetRandomSeed(ExecState*);</span>
<span class="line-modified"> 366 static EncodedJSValue JSC_HOST_CALL functionSetRandomSeed(ExecState*);</span>
<span class="line-modified"> 367 static EncodedJSValue JSC_HOST_CALL functionIsRope(ExecState*);</span>
<span class="line-modified"> 368 static EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(ExecState*);</span>
<span class="line-modified"> 369 static EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(ExecState*);</span>
<span class="line-modified"> 370 static EncodedJSValue JSC_HOST_CALL functionDollarDetachArrayBuffer(ExecState*);</span>
<span class="line-modified"> 371 static EncodedJSValue JSC_HOST_CALL functionDollarEvalScript(ExecState*);</span>
<span class="line-modified"> 372 static EncodedJSValue JSC_HOST_CALL functionDollarAgentStart(ExecState*);</span>
<span class="line-modified"> 373 static EncodedJSValue JSC_HOST_CALL functionDollarAgentReceiveBroadcast(ExecState*);</span>
<span class="line-modified"> 374 static EncodedJSValue JSC_HOST_CALL functionDollarAgentReport(ExecState*);</span>
<span class="line-modified"> 375 static EncodedJSValue JSC_HOST_CALL functionDollarAgentSleep(ExecState*);</span>
<span class="line-modified"> 376 static EncodedJSValue JSC_HOST_CALL functionDollarAgentBroadcast(ExecState*);</span>
<span class="line-modified"> 377 static EncodedJSValue JSC_HOST_CALL functionDollarAgentGetReport(ExecState*);</span>
<span class="line-modified"> 378 static EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(ExecState*);</span>
<span class="line-modified"> 379 static EncodedJSValue JSC_HOST_CALL functionDollarAgentMonotonicNow(ExecState*);</span>
<span class="line-modified"> 380 static EncodedJSValue JSC_HOST_CALL functionWaitForReport(ExecState*);</span>
<span class="line-modified"> 381 static EncodedJSValue JSC_HOST_CALL functionHeapCapacity(ExecState*);</span>
<span class="line-modified"> 382 static EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(ExecState*);</span>
<span class="line-modified"> 383 static EncodedJSValue JSC_HOST_CALL functionDisableRichSourceInfo(ExecState*);</span>
<span class="line-modified"> 384 static EncodedJSValue JSC_HOST_CALL functionMallocInALoop(ExecState*);</span>
<span class="line-modified"> 385 static EncodedJSValue JSC_HOST_CALL functionTotalCompileTime(ExecState*);</span>
<span class="line-modified"> 386 </span>
<span class="line-removed"> 387 static EncodedJSValue JSC_HOST_CALL functionSetUnhandledRejectionCallback(ExecState*);</span>
 388 
 389 struct Script {
 390     enum class StrictMode {
 391         Strict,
 392         Sloppy
 393     };
 394 
 395     enum class ScriptType {
 396         Script,
 397         Module
 398     };
 399 
 400     enum class CodeSource {
 401         File,
 402         CommandLine
 403     };
 404 
 405     StrictMode strictMode;
 406     CodeSource codeSource;
 407     ScriptType scriptType;
</pre>
<hr />
<pre>
 461 {
 462     m_startTime = MonotonicTime::now();
 463 }
 464 
 465 void StopWatch::stop()
 466 {
 467     m_stopTime = MonotonicTime::now();
 468 }
 469 
 470 long StopWatch::getElapsedMS()
 471 {
 472     return (m_stopTime - m_startTime).millisecondsAs&lt;long&gt;();
 473 }
 474 
 475 template&lt;typename Vector&gt;
 476 static inline String stringFromUTF(const Vector&amp; utf8)
 477 {
 478     return String::fromUTF8WithLatin1Fallback(utf8.data(), utf8.size());
 479 }
 480 
<span class="line-modified"> 481 class GlobalObject : public JSGlobalObject {</span>
 482 private:
 483     GlobalObject(VM&amp;, Structure*);
 484 
 485 public:
 486     typedef JSGlobalObject Base;
 487 
 488     static GlobalObject* create(VM&amp; vm, Structure* structure, const Vector&lt;String&gt;&amp; arguments)
 489     {
 490         GlobalObject* object = new (NotNull, allocateCell&lt;GlobalObject&gt;(vm.heap)) GlobalObject(vm, structure);
 491         object-&gt;finishCreation(vm, arguments);
 492         return object;
 493     }
 494 
<span class="line-removed"> 495     static const bool needsDestruction = false;</span>
<span class="line-removed"> 496 </span>
 497     DECLARE_INFO;
 498     static const GlobalObjectMethodTable s_globalObjectMethodTable;
 499 
 500     static Structure* createStructure(VM&amp; vm, JSValue prototype)
 501     {
 502         return Structure::create(vm, 0, prototype, TypeInfo(GlobalObjectType, StructureFlags), info());
 503     }
 504 
 505     static RuntimeFlags javaScriptRuntimeFlags(const JSGlobalObject*) { return RuntimeFlags::createAllEnabled(); }
 506 
 507 protected:
 508     void finishCreation(VM&amp; vm, const Vector&lt;String&gt;&amp; arguments)
 509     {
 510         Base::finishCreation(vm);
 511 
 512         addFunction(vm, &quot;debug&quot;, functionDebug, 1);
 513         addFunction(vm, &quot;describe&quot;, functionDescribe, 1);
 514         addFunction(vm, &quot;describeArray&quot;, functionDescribeArray, 1);
 515         addFunction(vm, &quot;print&quot;, functionPrintStdOut, 1);
 516         addFunction(vm, &quot;printErr&quot;, functionPrintStdErr, 1);
 517         addFunction(vm, &quot;quit&quot;, functionQuit, 0);
 518         addFunction(vm, &quot;gc&quot;, functionGCAndSweep, 0);
 519         addFunction(vm, &quot;fullGC&quot;, functionFullGC, 0);
 520         addFunction(vm, &quot;edenGC&quot;, functionEdenGC, 0);
<span class="line-removed"> 521         addFunction(vm, &quot;forceGCSlowPaths&quot;, functionForceGCSlowPaths, 0);</span>
 522         addFunction(vm, &quot;gcHeapSize&quot;, functionHeapSize, 0);
 523         addFunction(vm, &quot;MemoryFootprint&quot;, functionCreateMemoryFootprint, 0);
 524         addFunction(vm, &quot;resetMemoryPeak&quot;, functionResetMemoryPeak, 0);
 525         addFunction(vm, &quot;addressOf&quot;, functionAddressOf, 1);
 526         addFunction(vm, &quot;version&quot;, functionVersion, 1);
 527         addFunction(vm, &quot;run&quot;, functionRun, 1);
 528         addFunction(vm, &quot;runString&quot;, functionRunString, 1);
 529         addFunction(vm, &quot;load&quot;, functionLoad, 1);
 530         addFunction(vm, &quot;loadString&quot;, functionLoadString, 1);
 531         addFunction(vm, &quot;readFile&quot;, functionReadFile, 2);
 532         addFunction(vm, &quot;read&quot;, functionReadFile, 2);
 533         addFunction(vm, &quot;checkSyntax&quot;, functionCheckSyntax, 1);
 534         addFunction(vm, &quot;sleepSeconds&quot;, functionSleepSeconds, 1);
 535         addFunction(vm, &quot;jscStack&quot;, functionJSCStack, 1);
 536         addFunction(vm, &quot;readline&quot;, functionReadline, 0);
 537         addFunction(vm, &quot;preciseTime&quot;, functionPreciseTime, 0);
 538         addFunction(vm, &quot;neverInlineFunction&quot;, functionNeverInlineFunction, 1);
 539         addFunction(vm, &quot;noInline&quot;, functionNeverInlineFunction, 1);
 540         addFunction(vm, &quot;noDFG&quot;, functionNoDFG, 1);
 541         addFunction(vm, &quot;noFTL&quot;, functionNoFTL, 1);
 542         addFunction(vm, &quot;noOSRExitFuzzing&quot;, functionNoOSRExitFuzzing, 1);
 543         addFunction(vm, &quot;numberOfDFGCompiles&quot;, functionNumberOfDFGCompiles, 1);

 544         addFunction(vm, &quot;jscOptions&quot;, functionJSCOptions, 0);
 545         addFunction(vm, &quot;optimizeNextInvocation&quot;, functionOptimizeNextInvocation, 1);
 546         addFunction(vm, &quot;reoptimizationRetryCount&quot;, functionReoptimizationRetryCount, 1);
 547         addFunction(vm, &quot;transferArrayBuffer&quot;, functionTransferArrayBuffer, 1);
 548         addFunction(vm, &quot;failNextNewCodeBlock&quot;, functionFailNextNewCodeBlock, 1);
 549 #if ENABLE(SAMPLING_FLAGS)
 550         addFunction(vm, &quot;setSamplingFlags&quot;, functionSetSamplingFlags, 1);
 551         addFunction(vm, &quot;clearSamplingFlags&quot;, functionClearSamplingFlags, 1);
 552 #endif
 553 
 554         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;OSRExit&quot;), 0, functionUndefined1, OSRExitIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 555         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;isFinalTier&quot;), 0, functionFalse, IsFinalTierIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 556         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;predictInt32&quot;), 0, functionUndefined2, SetInt32HeapPredictionIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 557         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;isInt32&quot;), 0, functionIsInt32, CheckInt32Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 558         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;isPureNaN&quot;), 0, functionIsPureNaN, CheckInt32Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 559         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;fiatInt52&quot;), 0, functionIdentity, FiatInt52Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 560 
 561         addFunction(vm, &quot;effectful42&quot;, functionEffectful42, 0);
 562         addFunction(vm, &quot;makeMasquerader&quot;, functionMakeMasquerader, 0);
 563         addFunction(vm, &quot;hasCustomProperties&quot;, functionHasCustomProperties, 0);
</pre>
<hr />
<pre>
 581         addFunction(vm, &quot;platformSupportsSamplingProfiler&quot;, functionPlatformSupportsSamplingProfiler, 0);
 582         addFunction(vm, &quot;generateHeapSnapshot&quot;, functionGenerateHeapSnapshot, 0);
 583         addFunction(vm, &quot;generateHeapSnapshotForGCDebugging&quot;, functionGenerateHeapSnapshotForGCDebugging, 0);
 584         addFunction(vm, &quot;resetSuperSamplerState&quot;, functionResetSuperSamplerState, 0);
 585         addFunction(vm, &quot;ensureArrayStorage&quot;, functionEnsureArrayStorage, 0);
 586 #if ENABLE(SAMPLING_PROFILER)
 587         addFunction(vm, &quot;startSamplingProfiler&quot;, functionStartSamplingProfiler, 0);
 588         addFunction(vm, &quot;samplingProfilerStackTraces&quot;, functionSamplingProfilerStackTraces, 0);
 589 #endif
 590 
 591         addFunction(vm, &quot;maxArguments&quot;, functionMaxArguments, 0);
 592 
 593         addFunction(vm, &quot;asyncTestStart&quot;, functionAsyncTestStart, 1);
 594         addFunction(vm, &quot;asyncTestPassed&quot;, functionAsyncTestPassed, 1);
 595 
 596 #if ENABLE(WEBASSEMBLY)
 597         addFunction(vm, &quot;WebAssemblyMemoryMode&quot;, functionWebAssemblyMemoryMode, 1);
 598 #endif
 599 
 600         if (!arguments.isEmpty()) {
<span class="line-modified"> 601             JSArray* array = constructEmptyArray(globalExec(), 0);</span>
 602             for (size_t i = 0; i &lt; arguments.size(); ++i)
<span class="line-modified"> 603                 array-&gt;putDirectIndex(globalExec(), i, jsString(vm, arguments[i]));</span>
 604             putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);
 605         }
 606 
 607         putDirect(vm, Identifier::fromString(vm, &quot;console&quot;), jsUndefined());
 608 
 609         Structure* plainObjectStructure = JSFinalObject::createStructure(vm, this, objectPrototype(), 0);
 610 
 611         JSObject* dollar = JSFinalObject::create(vm, plainObjectStructure);
 612         putDirect(vm, Identifier::fromString(vm, &quot;$&quot;), dollar);
 613         putDirect(vm, Identifier::fromString(vm, &quot;$262&quot;), dollar);
 614 
 615         addFunction(vm, dollar, &quot;createRealm&quot;, functionDollarCreateRealm, 0);
<span class="line-modified"> 616         addFunction(vm, dollar, &quot;detachArrayBuffer&quot;, functionDollarDetachArrayBuffer, 1);</span>
 617         addFunction(vm, dollar, &quot;evalScript&quot;, functionDollarEvalScript, 1);
 618 
 619         dollar-&gt;putDirect(vm, Identifier::fromString(vm, &quot;global&quot;), this);
 620 
 621         JSObject* agent = JSFinalObject::create(vm, plainObjectStructure);
 622         dollar-&gt;putDirect(vm, Identifier::fromString(vm, &quot;agent&quot;), agent);
 623 
 624         // The test262 INTERPRETING.md document says that some of these functions are just in the main
 625         // thread and some are in the other threads. We just put them in all threads.
 626         addFunction(vm, agent, &quot;start&quot;, functionDollarAgentStart, 1);
 627         addFunction(vm, agent, &quot;receiveBroadcast&quot;, functionDollarAgentReceiveBroadcast, 1);
 628         addFunction(vm, agent, &quot;report&quot;, functionDollarAgentReport, 1);
 629         addFunction(vm, agent, &quot;sleep&quot;, functionDollarAgentSleep, 1);
 630         addFunction(vm, agent, &quot;broadcast&quot;, functionDollarAgentBroadcast, 1);
 631         addFunction(vm, agent, &quot;getReport&quot;, functionDollarAgentGetReport, 0);
 632         addFunction(vm, agent, &quot;leaving&quot;, functionDollarAgentLeaving, 0);
 633         addFunction(vm, agent, &quot;monotonicNow&quot;, functionDollarAgentMonotonicNow, 0);
 634 
 635         addFunction(vm, &quot;waitForReport&quot;, functionWaitForReport, 0);
 636 
</pre>
<hr />
<pre>
 638         addFunction(vm, &quot;flashHeapAccess&quot;, functionFlashHeapAccess, 0);
 639 
 640         addFunction(vm, &quot;disableRichSourceInfo&quot;, functionDisableRichSourceInfo, 0);
 641         addFunction(vm, &quot;mallocInALoop&quot;, functionMallocInALoop, 0);
 642         addFunction(vm, &quot;totalCompileTime&quot;, functionTotalCompileTime, 0);
 643 
 644         addFunction(vm, &quot;setUnhandledRejectionCallback&quot;, functionSetUnhandledRejectionCallback, 1);
 645     }
 646 
 647     void addFunction(VM&amp; vm, JSObject* object, const char* name, NativeFunction function, unsigned arguments)
 648     {
 649         Identifier identifier = Identifier::fromString(vm, name);
 650         object-&gt;putDirect(vm, identifier, JSFunction::create(vm, this, arguments, identifier.string(), function));
 651     }
 652 
 653     void addFunction(VM&amp; vm, const char* name, NativeFunction function, unsigned arguments)
 654     {
 655         addFunction(vm, this, name, function, arguments);
 656     }
 657 
<span class="line-modified"> 658     static JSInternalPromise* moduleLoaderImportModule(JSGlobalObject*, ExecState*, JSModuleLoader*, JSString*, JSValue, const SourceOrigin&amp;);</span>
<span class="line-modified"> 659     static Identifier moduleLoaderResolve(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSValue, JSValue);</span>
<span class="line-modified"> 660     static JSInternalPromise* moduleLoaderFetch(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSValue, JSValue);</span>
<span class="line-modified"> 661     static JSObject* moduleLoaderCreateImportMetaProperties(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSModuleRecord*, JSValue);</span>
 662 };

 663 
 664 static bool supportsRichSourceInfo = true;
 665 static bool shellSupportsRichSourceInfo(const JSGlobalObject*)
 666 {
 667     return supportsRichSourceInfo;
 668 }
 669 
 670 const ClassInfo GlobalObject::s_info = { &quot;global&quot;, &amp;JSGlobalObject::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(GlobalObject) };
 671 const GlobalObjectMethodTable GlobalObject::s_globalObjectMethodTable = {
 672     &amp;shellSupportsRichSourceInfo,
 673     &amp;shouldInterruptScript,
 674     &amp;javaScriptRuntimeFlags,
 675     nullptr, // queueTaskToEventLoop
 676     &amp;shouldInterruptScriptBeforeTimeout,
 677     &amp;moduleLoaderImportModule,
 678     &amp;moduleLoaderResolve,
 679     &amp;moduleLoaderFetch,
 680     &amp;moduleLoaderCreateImportMetaProperties,
 681     nullptr, // moduleLoaderEvaluate
 682     nullptr, // promiseRejectionTracker
</pre>
<hr />
<pre>
 799     }
 800 
 801     StringBuilder builder;
 802     builder.append(directoryName.rootName);
 803     for (size_t i = 0; i &lt; directoryPieces.size(); ++i) {
 804         builder.append(directoryPieces[i]);
 805         if (i + 1 != directoryPieces.size())
 806             builder.append(pathSeparator());
 807     }
 808     return builder.toString();
 809 }
 810 
 811 static String absolutePath(const String&amp; fileName)
 812 {
 813     auto directoryName = currentWorkingDirectory();
 814     if (!directoryName)
 815         return fileName;
 816     return resolvePath(directoryName.value(), ModuleName(fileName.impl()));
 817 }
 818 
<span class="line-modified"> 819 JSInternalPromise* GlobalObject::moduleLoaderImportModule(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSString* moduleNameValue, JSValue parameters, const SourceOrigin&amp; sourceOrigin)</span>
 820 {
 821     VM&amp; vm = globalObject-&gt;vm();
 822     auto throwScope = DECLARE_THROW_SCOPE(vm);
 823 
<span class="line-modified"> 824     auto* deferred = JSInternalPromiseDeferred::tryCreate(exec, globalObject);</span>
<span class="line-removed"> 825     RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
 826 
 827     auto catchScope = DECLARE_CATCH_SCOPE(vm);
 828     auto reject = [&amp;] (JSValue rejectionReason) {
 829         catchScope.clearException();
<span class="line-modified"> 830         auto result = deferred-&gt;reject(exec, rejectionReason);</span>
 831         catchScope.clearException();
<span class="line-modified"> 832         return result;</span>
 833     };
 834 
 835     if (sourceOrigin.isNull())
<span class="line-modified"> 836         return reject(createError(exec, &quot;Could not resolve the module specifier.&quot;_s));</span>
 837 
<span class="line-modified"> 838     const auto&amp; referrer = sourceOrigin.string();</span>
<span class="line-modified"> 839     const auto&amp; moduleName = moduleNameValue-&gt;value(exec);</span>

 840     if (UNLIKELY(catchScope.exception()))
 841         return reject(catchScope.exception());
 842 
 843     auto directoryName = extractDirectoryName(referrer.impl());
 844     if (!directoryName)
<span class="line-modified"> 845         return reject(createError(exec, makeString(&quot;Could not resolve the referrer name &#39;&quot;, String(referrer.impl()), &quot;&#39;.&quot;)));</span>
 846 
<span class="line-modified"> 847     auto result = JSC::importModule(exec, Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(moduleName))), parameters, jsUndefined());</span>
 848     if (UNLIKELY(catchScope.exception()))
 849         return reject(catchScope.exception());
 850     return result;
 851 }
 852 
<span class="line-modified"> 853 Identifier GlobalObject::moduleLoaderResolve(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSValue keyValue, JSValue referrerValue, JSValue)</span>
 854 {
 855     VM&amp; vm = globalObject-&gt;vm();
 856     auto scope = DECLARE_THROW_SCOPE(vm);
 857 
 858     scope.releaseAssertNoException();
<span class="line-modified"> 859     const Identifier key = keyValue.toPropertyKey(exec);</span>
 860     RETURN_IF_EXCEPTION(scope, { });
 861 
 862     if (key.isSymbol())
 863         return key;
 864 
 865     if (referrerValue.isUndefined()) {
 866         auto directoryName = currentWorkingDirectory();
 867         if (!directoryName) {
<span class="line-modified"> 868             throwException(exec, scope, createError(exec, &quot;Could not resolve the current working directory.&quot;_s));</span>
 869             return { };
 870         }
 871         return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));
 872     }
 873 
<span class="line-modified"> 874     const Identifier referrer = referrerValue.toPropertyKey(exec);</span>
 875     RETURN_IF_EXCEPTION(scope, { });
 876 
 877     if (referrer.isSymbol()) {
 878         auto directoryName = currentWorkingDirectory();
 879         if (!directoryName) {
<span class="line-modified"> 880             throwException(exec, scope, createError(exec, &quot;Could not resolve the current working directory.&quot;_s));</span>
 881             return { };
 882         }
 883         return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));
 884     }
 885 
 886     // If the referrer exists, we assume that the referrer is the correct absolute path.
 887     auto directoryName = extractDirectoryName(referrer.impl());
 888     if (!directoryName) {
<span class="line-modified"> 889         throwException(exec, scope, createError(exec, makeString(&quot;Could not resolve the referrer name &#39;&quot;, String(referrer.impl()), &quot;&#39;.&quot;)));</span>
 890         return { };
 891     }
 892     return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));
 893 }
 894 
 895 template&lt;typename Vector&gt;
 896 static void convertShebangToJSComment(Vector&amp; buffer)
 897 {
 898     if (buffer.size() &gt;= 2) {
 899         if (buffer[0] == &#39;#&#39; &amp;&amp; buffer[1] == &#39;!&#39;)
 900             buffer[0] = buffer[1] = &#39;/&#39;;
 901     }
 902 }
 903 
 904 static RefPtr&lt;Uint8Array&gt; fillBufferWithContentsOfFile(FILE* file)
 905 {
 906     if (fseek(file, 0, SEEK_END) == -1)
 907         return nullptr;
 908     long bufferCapacity = ftell(file);
 909     if (bufferCapacity == -1)
</pre>
<hr />
<pre>
1135     if (stat(pathName.data(), &amp;status))
1136         return false;
1137     if ((status.st_mode &amp; S_IFMT) != S_IFREG)
1138         return false;
1139 
1140     FILE* f = fopen(pathName.data(), &quot;r&quot;);
1141 #endif
1142     if (!f) {
1143         fprintf(stderr, &quot;Could not open file: %s\n&quot;, fileName.utf8().data());
1144         return false;
1145     }
1146 
1147     bool result = fillBufferWithContentsOfFile(f, buffer);
1148     if (result)
1149         convertShebangToJSComment(buffer);
1150     fclose(f);
1151 
1152     return result;
1153 }
1154 
<span class="line-modified">1155 JSInternalPromise* GlobalObject::moduleLoaderFetch(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSValue key, JSValue, JSValue)</span>
1156 {
1157     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1158     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-removed">1159     JSInternalPromiseDeferred* deferred = JSInternalPromiseDeferred::tryCreate(exec, globalObject);</span>
<span class="line-removed">1160     RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
1161 
1162     auto catchScope = DECLARE_CATCH_SCOPE(vm);
1163     auto reject = [&amp;] (JSValue rejectionReason) {
1164         catchScope.clearException();
<span class="line-modified">1165         auto result = deferred-&gt;reject(exec, rejectionReason);</span>
1166         catchScope.clearException();
<span class="line-modified">1167         return result;</span>
1168     };
1169 
<span class="line-modified">1170     String moduleKey = key.toWTFString(exec);</span>
1171     if (UNLIKELY(catchScope.exception()))
1172         return reject(catchScope.exception());
1173 
1174     // Here, now we consider moduleKey as the fileName.
1175     Vector&lt;uint8_t&gt; buffer;
1176     if (!fetchModuleFromLocalFileSystem(moduleKey, buffer))
<span class="line-modified">1177         return reject(createError(exec, makeString(&quot;Could not open file &#39;&quot;, moduleKey, &quot;&#39;.&quot;)));</span>
1178 
1179 
1180     URL moduleURL = URL({ }, moduleKey);
1181 #if ENABLE(WEBASSEMBLY)
1182     // FileSystem does not have mime-type header. The JSC shell recognizes WebAssembly&#39;s magic header.
1183     if (buffer.size() &gt;= 4) {
1184         if (buffer[0] == &#39;\0&#39; &amp;&amp; buffer[1] == &#39;a&#39; &amp;&amp; buffer[2] == &#39;s&#39; &amp;&amp; buffer[3] == &#39;m&#39;) {
1185             auto source = SourceCode(WebAssemblySourceProvider::create(WTFMove(buffer), SourceOrigin { moduleKey }, WTFMove(moduleURL)));
1186             catchScope.releaseAssertNoException();
1187             auto sourceCode = JSSourceCode::create(vm, WTFMove(source));
1188             catchScope.releaseAssertNoException();
<span class="line-modified">1189             auto result = deferred-&gt;resolve(exec, sourceCode);</span>
1190             catchScope.clearException();
<span class="line-modified">1191             return result;</span>
1192         }
1193     }
1194 #endif
1195 
1196     auto sourceCode = JSSourceCode::create(vm, jscSource(stringFromUTF(buffer), SourceOrigin { moduleKey }, WTFMove(moduleURL), TextPosition(), SourceProviderSourceType::Module));
1197     catchScope.releaseAssertNoException();
<span class="line-modified">1198     auto result = deferred-&gt;resolve(exec, sourceCode);</span>
1199     catchScope.clearException();
<span class="line-modified">1200     return result;</span>
1201 }
1202 
<span class="line-modified">1203 JSObject* GlobalObject::moduleLoaderCreateImportMetaProperties(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSValue key, JSModuleRecord*, JSValue)</span>
1204 {
<span class="line-modified">1205     VM&amp; vm = exec-&gt;vm();</span>
1206     auto scope = DECLARE_THROW_SCOPE(vm);
1207 
<span class="line-modified">1208     JSObject* metaProperties = constructEmptyObject(exec, globalObject-&gt;nullPrototypeObjectStructure());</span>
1209     RETURN_IF_EXCEPTION(scope, nullptr);
1210 
1211     metaProperties-&gt;putDirect(vm, Identifier::fromString(vm, &quot;filename&quot;), key);
1212     RETURN_IF_EXCEPTION(scope, nullptr);
1213 
1214     return metaProperties;
1215 }
1216 
<span class="line-modified">1217 static CString cStringFromViewWithString(ExecState* exec, ThrowScope&amp; scope, StringViewWithUnderlyingString&amp; viewWithString)</span>
1218 {
1219     Expected&lt;CString, UTF8ConversionError&gt; expectedString = viewWithString.view.tryGetUtf8();
1220     if (expectedString)
1221         return expectedString.value();
1222     switch (expectedString.error()) {
1223     case UTF8ConversionError::OutOfMemory:
<span class="line-modified">1224         throwOutOfMemoryError(exec, scope);</span>
1225         break;
1226     case UTF8ConversionError::IllegalSource:
<span class="line-modified">1227         scope.throwException(exec, createError(exec, &quot;Illegal source encountered during UTF8 conversion&quot;));</span>
1228         break;
1229     case UTF8ConversionError::SourceExhausted:
<span class="line-modified">1230         scope.throwException(exec, createError(exec, &quot;Source exhausted during UTF8 conversion&quot;));</span>
1231         break;
1232     default:
1233         RELEASE_ASSERT_NOT_REACHED();
1234     }
1235     return { };
1236 }
1237 
<span class="line-modified">1238 static EncodedJSValue printInternal(ExecState* exec, FILE* out)</span>
1239 {
<span class="line-modified">1240     VM&amp; vm = exec-&gt;vm();</span>
1241     auto scope = DECLARE_THROW_SCOPE(vm);
1242 
1243     if (asyncTestExpectedPasses) {
<span class="line-modified">1244         JSValue value = exec-&gt;argument(0);</span>
<span class="line-modified">1245         if (value.isString() &amp;&amp; WTF::equal(asString(value)-&gt;value(exec).impl(), &quot;Test262:AsyncTestComplete&quot;)) {</span>
1246             asyncTestPasses++;
1247             return JSValue::encode(jsUndefined());
1248         }
1249     }
1250 
<span class="line-modified">1251     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
1252         if (i)
1253             if (EOF == fputc(&#39; &#39;, out))
1254                 goto fail;
1255 
<span class="line-modified">1256         auto viewWithString = exec-&gt;uncheckedArgument(i).toString(exec)-&gt;viewWithUnderlyingString(exec);</span>
1257         RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1258         auto string = cStringFromViewWithString(exec, scope, viewWithString);</span>
1259         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1260         if (fprintf(out, &quot;%s&quot;, string.data()) &lt; 0)
1261             goto fail;
1262     }
1263 
1264     fputc(&#39;\n&#39;, out);
1265 fail:
1266     fflush(out);
1267     return JSValue::encode(jsUndefined());
1268 }
1269 
<span class="line-modified">1270 EncodedJSValue JSC_HOST_CALL functionPrintStdOut(ExecState* exec) { return printInternal(exec, stdout); }</span>
<span class="line-modified">1271 EncodedJSValue JSC_HOST_CALL functionPrintStdErr(ExecState* exec) { return printInternal(exec, stderr); }</span>
1272 
<span class="line-modified">1273 EncodedJSValue JSC_HOST_CALL functionDebug(ExecState* exec)</span>
1274 {
<span class="line-modified">1275     VM&amp; vm = exec-&gt;vm();</span>
1276     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">1277     auto viewWithString = exec-&gt;argument(0).toString(exec)-&gt;viewWithUnderlyingString(exec);</span>
1278     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1279     auto string = cStringFromViewWithString(exec, scope, viewWithString);</span>
1280     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1281     fprintf(stderr, &quot;--&gt; %s\n&quot;, string.data());
1282     return JSValue::encode(jsUndefined());
1283 }
1284 
<span class="line-modified">1285 EncodedJSValue JSC_HOST_CALL functionDescribe(ExecState* exec)</span>
1286 {
<span class="line-modified">1287     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1288     if (exec-&gt;argumentCount() &lt; 1)</span>
1289         return JSValue::encode(jsUndefined());
<span class="line-modified">1290     return JSValue::encode(jsString(vm, toString(exec-&gt;argument(0))));</span>
1291 }
1292 
<span class="line-modified">1293 EncodedJSValue JSC_HOST_CALL functionDescribeArray(ExecState* exec)</span>
1294 {
<span class="line-modified">1295     if (exec-&gt;argumentCount() &lt; 1)</span>
1296         return JSValue::encode(jsUndefined());
<span class="line-modified">1297     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">1298     JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0));</span>
1299     if (!object)
1300         return JSValue::encode(jsNontrivialString(vm, &quot;&lt;not object&gt;&quot;_s));
1301     return JSValue::encode(jsNontrivialString(vm, toString(&quot;&lt;Butterfly: &quot;, RawPointer(object-&gt;butterfly()), &quot;; public length: &quot;, object-&gt;getArrayLength(), &quot;; vector length: &quot;, object-&gt;getVectorLength(), &quot;&gt;&quot;)));
1302 }
1303 
<span class="line-modified">1304 EncodedJSValue JSC_HOST_CALL functionSleepSeconds(ExecState* exec)</span>
1305 {
<span class="line-modified">1306     VM&amp; vm = exec-&gt;vm();</span>
1307     auto scope = DECLARE_THROW_SCOPE(vm);
1308 
<span class="line-modified">1309     if (exec-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">1310         Seconds seconds = Seconds(exec-&gt;argument(0).toNumber(exec));</span>
1311         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1312         sleep(seconds);
1313     }
1314 
1315     return JSValue::encode(jsUndefined());
1316 }
1317 
1318 class FunctionJSCStackFunctor {
1319 public:
1320     FunctionJSCStackFunctor(StringBuilder&amp; trace)
1321         : m_trace(trace)
1322     {
1323     }
1324 
1325     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
1326     {
1327         m_trace.append(makeString(&quot;    &quot;, visitor-&gt;index(), &quot;   &quot;, visitor-&gt;toString(), &#39;\n&#39;));
1328         return StackVisitor::Continue;
1329     }
1330 
1331 private:
1332     StringBuilder&amp; m_trace;
1333 };
1334 
<span class="line-modified">1335 EncodedJSValue JSC_HOST_CALL functionJSCStack(ExecState* exec)</span>
1336 {

1337     StringBuilder trace;
1338     trace.appendLiteral(&quot;--&gt; Stack trace:\n&quot;);
1339 
1340     FunctionJSCStackFunctor functor(trace);
<span class="line-modified">1341     exec-&gt;iterate(functor);</span>
1342     fprintf(stderr, &quot;%s&quot;, trace.toString().utf8().data());
1343     return JSValue::encode(jsUndefined());
1344 }
1345 
<span class="line-modified">1346 EncodedJSValue JSC_HOST_CALL functionGCAndSweep(ExecState* exec)</span>
1347 {
<span class="line-modified">1348     VM&amp; vm = exec-&gt;vm();</span>
1349     JSLockHolder lock(vm);
1350     vm.heap.collectNow(Sync, CollectionScope::Full);
1351     return JSValue::encode(jsNumber(vm.heap.sizeAfterLastFullCollection()));
1352 }
1353 
<span class="line-modified">1354 EncodedJSValue JSC_HOST_CALL functionFullGC(ExecState* exec)</span>
1355 {
<span class="line-modified">1356     VM&amp; vm = exec-&gt;vm();</span>
1357     JSLockHolder lock(vm);
1358     vm.heap.collectSync(CollectionScope::Full);
1359     return JSValue::encode(jsNumber(vm.heap.sizeAfterLastFullCollection()));
1360 }
1361 
<span class="line-modified">1362 EncodedJSValue JSC_HOST_CALL functionEdenGC(ExecState* exec)</span>
1363 {
<span class="line-modified">1364     VM&amp; vm = exec-&gt;vm();</span>
1365     JSLockHolder lock(vm);
1366     vm.heap.collectSync(CollectionScope::Eden);
1367     return JSValue::encode(jsNumber(vm.heap.sizeAfterLastEdenCollection()));
1368 }
1369 
<span class="line-modified">1370 EncodedJSValue JSC_HOST_CALL functionForceGCSlowPaths(ExecState*)</span>
1371 {
<span class="line-modified">1372     // It&#39;s best for this to be the first thing called in the</span>
<span class="line-removed">1373     // JS program so the option is set to true before we JIT.</span>
<span class="line-removed">1374     Options::forceGCSlowPaths() = true;</span>
<span class="line-removed">1375     return JSValue::encode(jsUndefined());</span>
<span class="line-removed">1376 }</span>
<span class="line-removed">1377 </span>
<span class="line-removed">1378 EncodedJSValue JSC_HOST_CALL functionHeapSize(ExecState* exec)</span>
<span class="line-removed">1379 {</span>
<span class="line-removed">1380     VM&amp; vm = exec-&gt;vm();</span>
1381     JSLockHolder lock(vm);
1382     return JSValue::encode(jsNumber(vm.heap.size()));
1383 }
1384 
1385 class JSCMemoryFootprint : public JSDestructibleObject {
1386     using Base = JSDestructibleObject;
1387 public:
1388     JSCMemoryFootprint(VM&amp; vm, Structure* structure)
1389         : Base(vm, structure)
1390     { }
1391 
1392     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
1393     {
1394         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
1395     }
1396 
1397     static JSCMemoryFootprint* create(VM&amp; vm, JSGlobalObject* globalObject)
1398     {
1399         Structure* structure = createStructure(vm, globalObject, jsNull());
1400         JSCMemoryFootprint* footprint = new (NotNull, allocateCell&lt;JSCMemoryFootprint&gt;(vm.heap)) JSCMemoryFootprint(vm, structure);
</pre>
<hr />
<pre>
1411         };
1412 
1413         MemoryFootprint footprint = MemoryFootprint::now();
1414 
1415         addProperty(vm, &quot;current&quot;, jsNumber(footprint.current));
1416         addProperty(vm, &quot;peak&quot;, jsNumber(footprint.peak));
1417     }
1418 
1419     DECLARE_INFO;
1420 
1421 private:
1422     void addProperty(VM&amp; vm, const char* name, JSValue value)
1423     {
1424         Identifier identifier = Identifier::fromString(vm, name);
1425         putDirect(vm, identifier, value);
1426     }
1427 };
1428 
1429 const ClassInfo JSCMemoryFootprint::s_info = { &quot;MemoryFootprint&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSCMemoryFootprint) };
1430 
<span class="line-modified">1431 EncodedJSValue JSC_HOST_CALL functionCreateMemoryFootprint(ExecState* exec)</span>
1432 {
<span class="line-modified">1433     VM&amp; vm = exec-&gt;vm();</span>
1434     JSLockHolder lock(vm);
<span class="line-modified">1435     return JSValue::encode(JSCMemoryFootprint::create(vm, exec-&gt;lexicalGlobalObject()));</span>
1436 }
1437 
<span class="line-modified">1438 EncodedJSValue JSC_HOST_CALL functionResetMemoryPeak(ExecState*)</span>
1439 {
1440     MemoryFootprint::resetPeak();
1441     return JSValue::encode(jsUndefined());
1442 }
1443 
1444 // This function is not generally very helpful in 64-bit code as the tag and payload
1445 // share a register. But in 32-bit JITed code the tag may not be checked if an
1446 // optimization removes type checking requirements, such as in ===.
<span class="line-modified">1447 EncodedJSValue JSC_HOST_CALL functionAddressOf(ExecState* exec)</span>
1448 {
<span class="line-modified">1449     JSValue value = exec-&gt;argument(0);</span>
1450     if (!value.isCell())
1451         return JSValue::encode(jsUndefined());
1452     // Need to cast to uint64_t so bitwise_cast will play along.
1453     uint64_t asNumber = reinterpret_cast&lt;uint64_t&gt;(value.asCell());
1454     EncodedJSValue returnValue = JSValue::encode(jsNumber(bitwise_cast&lt;double&gt;(asNumber)));
1455     return returnValue;
1456 }
1457 
<span class="line-modified">1458 EncodedJSValue JSC_HOST_CALL functionVersion(ExecState*)</span>
1459 {
1460     // We need this function for compatibility with the Mozilla JS tests but for now
1461     // we don&#39;t actually do any version-specific handling
1462     return JSValue::encode(jsUndefined());
1463 }
1464 
<span class="line-modified">1465 EncodedJSValue JSC_HOST_CALL functionRun(ExecState* exec)</span>
1466 {
<span class="line-modified">1467     VM&amp; vm = exec-&gt;vm();</span>
1468     auto scope = DECLARE_THROW_SCOPE(vm);
1469 
<span class="line-modified">1470     String fileName = exec-&gt;argument(0).toWTFString(exec);</span>
1471     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1472     Vector&lt;char&gt; script;
1473     if (!fetchScriptFromLocalFileSystem(fileName, script))
<span class="line-modified">1474         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Could not open file.&quot;_s)));</span>
1475 
<span class="line-modified">1476     GlobalObject* globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());</span>
1477 
<span class="line-modified">1478     JSArray* array = constructEmptyArray(globalObject-&gt;globalExec(), 0);</span>
1479     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1480     for (unsigned i = 1; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">1481         array-&gt;putDirectIndex(globalObject-&gt;globalExec(), i - 1, exec-&gt;uncheckedArgument(i));</span>
1482         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1483     }
<span class="line-modified">1484     globalObject-&gt;putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);</span>
1485 
1486     NakedPtr&lt;Exception&gt; exception;
1487     StopWatch stopWatch;
1488     stopWatch.start();
<span class="line-modified">1489     evaluate(globalObject-&gt;globalExec(), jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), exception);</span>
1490     stopWatch.stop();
1491 
1492     if (exception) {
<span class="line-modified">1493         throwException(globalObject-&gt;globalExec(), scope, exception);</span>
1494         return JSValue::encode(jsUndefined());
1495     }
1496 
1497     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
1498 }
1499 
<span class="line-modified">1500 EncodedJSValue JSC_HOST_CALL functionRunString(ExecState* exec)</span>
1501 {
<span class="line-modified">1502     VM&amp; vm = exec-&gt;vm();</span>
1503     auto scope = DECLARE_THROW_SCOPE(vm);
1504 
<span class="line-modified">1505     String source = exec-&gt;argument(0).toWTFString(exec);</span>
1506     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1507 
<span class="line-modified">1508     GlobalObject* globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());</span>
1509 
<span class="line-modified">1510     JSArray* array = constructEmptyArray(globalObject-&gt;globalExec(), 0);</span>
1511     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1512     for (unsigned i = 1; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">1513         array-&gt;putDirectIndex(globalObject-&gt;globalExec(), i - 1, exec-&gt;uncheckedArgument(i));</span>
1514         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1515     }
<span class="line-modified">1516     globalObject-&gt;putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);</span>
1517 
1518     NakedPtr&lt;Exception&gt; exception;
<span class="line-modified">1519     evaluate(globalObject-&gt;globalExec(), jscSource(source, exec-&gt;callerSourceOrigin()), JSValue(), exception);</span>
1520 
1521     if (exception) {
<span class="line-modified">1522         scope.throwException(globalObject-&gt;globalExec(), exception);</span>
1523         return JSValue::encode(jsUndefined());
1524     }
1525 
<span class="line-modified">1526     return JSValue::encode(globalObject);</span>
1527 }
1528 
<span class="line-modified">1529 EncodedJSValue JSC_HOST_CALL functionLoad(ExecState* exec)</span>
1530 {
<span class="line-modified">1531     VM&amp; vm = exec-&gt;vm();</span>
1532     auto scope = DECLARE_THROW_SCOPE(vm);
1533 
<span class="line-modified">1534     String fileName = exec-&gt;argument(0).toWTFString(exec);</span>
1535     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1536     Vector&lt;char&gt; script;
1537     if (!fetchScriptFromLocalFileSystem(fileName, script))
<span class="line-modified">1538         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Could not open file.&quot;_s)));</span>
<span class="line-removed">1539 </span>
<span class="line-removed">1540     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
1541 
1542     NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">1543     JSValue result = evaluate(globalObject-&gt;globalExec(), jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), evaluationException);</span>
1544     if (evaluationException)
<span class="line-modified">1545         throwException(exec, scope, evaluationException);</span>
1546     return JSValue::encode(result);
1547 }
1548 
<span class="line-modified">1549 EncodedJSValue JSC_HOST_CALL functionLoadString(ExecState* exec)</span>
1550 {
<span class="line-modified">1551     VM&amp; vm = exec-&gt;vm();</span>
1552     auto scope = DECLARE_THROW_SCOPE(vm);
1553 
<span class="line-modified">1554     String sourceCode = exec-&gt;argument(0).toWTFString(exec);</span>
1555     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-removed">1556     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
1557 
1558     NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">1559     JSValue result = evaluate(globalObject-&gt;globalExec(), jscSource(sourceCode, exec-&gt;callerSourceOrigin()), JSValue(), evaluationException);</span>
1560     if (evaluationException)
<span class="line-modified">1561         throwException(exec, scope, evaluationException);</span>
1562     return JSValue::encode(result);
1563 }
1564 
<span class="line-modified">1565 EncodedJSValue JSC_HOST_CALL functionReadFile(ExecState* exec)</span>
1566 {
<span class="line-modified">1567     VM&amp; vm = exec-&gt;vm();</span>
1568     auto scope = DECLARE_THROW_SCOPE(vm);
1569 
<span class="line-modified">1570     String fileName = exec-&gt;argument(0).toWTFString(exec);</span>
1571     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1572 
1573     bool isBinary = false;
<span class="line-modified">1574     if (exec-&gt;argumentCount() &gt; 1) {</span>
<span class="line-modified">1575         String type = exec-&gt;argument(1).toWTFString(exec);</span>
1576         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1577         if (type != &quot;binary&quot;)
<span class="line-modified">1578             return throwVMError(exec, scope, &quot;Expected &#39;binary&#39; as second argument.&quot;);</span>
1579         isBinary = true;
1580     }
1581 
1582     RefPtr&lt;Uint8Array&gt; content = fillBufferWithContentsOfFile(fileName);
1583     if (!content)
<span class="line-modified">1584         return throwVMError(exec, scope, &quot;Could not open file.&quot;);</span>
1585 
1586     if (!isBinary)
1587         return JSValue::encode(jsString(vm, String::fromUTF8WithLatin1Fallback(content-&gt;data(), content-&gt;length())));
1588 
<span class="line-modified">1589     Structure* structure = exec-&gt;lexicalGlobalObject()-&gt;typedArrayStructure(TypeUint8);</span>
1590     JSObject* result = JSUint8Array::create(vm, structure, WTFMove(content));
1591     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1592 
1593     return JSValue::encode(result);
1594 }
1595 
<span class="line-modified">1596 EncodedJSValue JSC_HOST_CALL functionCheckSyntax(ExecState* exec)</span>
1597 {
<span class="line-modified">1598     VM&amp; vm = exec-&gt;vm();</span>
1599     auto scope = DECLARE_THROW_SCOPE(vm);
1600 
<span class="line-modified">1601     String fileName = exec-&gt;argument(0).toWTFString(exec);</span>
1602     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1603     Vector&lt;char&gt; script;
1604     if (!fetchScriptFromLocalFileSystem(fileName, script))
<span class="line-modified">1605         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Could not open file.&quot;_s)));</span>
<span class="line-removed">1606 </span>
<span class="line-removed">1607     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
1608 
1609     StopWatch stopWatch;
1610     stopWatch.start();
1611 
1612     JSValue syntaxException;
<span class="line-modified">1613     bool validSyntax = checkSyntax(globalObject-&gt;globalExec(), jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), &amp;syntaxException);</span>
1614     stopWatch.stop();
1615 
1616     if (!validSyntax)
<span class="line-modified">1617         throwException(exec, scope, syntaxException);</span>
1618     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
1619 }
1620 
1621 #if ENABLE(SAMPLING_FLAGS)
<span class="line-modified">1622 EncodedJSValue JSC_HOST_CALL functionSetSamplingFlags(ExecState* exec)</span>
1623 {
<span class="line-modified">1624     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">1625         unsigned flag = static_cast&lt;unsigned&gt;(exec-&gt;uncheckedArgument(i).toNumber(exec));</span>
1626         if ((flag &gt;= 1) &amp;&amp; (flag &lt;= 32))
1627             SamplingFlags::setFlag(flag);
1628     }
1629     return JSValue::encode(jsNull());
1630 }
1631 
<span class="line-modified">1632 EncodedJSValue JSC_HOST_CALL functionClearSamplingFlags(ExecState* exec)</span>
1633 {
<span class="line-modified">1634     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">1635         unsigned flag = static_cast&lt;unsigned&gt;(exec-&gt;uncheckedArgument(i).toNumber(exec));</span>
1636         if ((flag &gt;= 1) &amp;&amp; (flag &lt;= 32))
1637             SamplingFlags::clearFlag(flag);
1638     }
1639     return JSValue::encode(jsNull());
1640 }
1641 #endif
1642 
<span class="line-modified">1643 EncodedJSValue JSC_HOST_CALL functionGetRandomSeed(ExecState* exec)</span>
1644 {
<span class="line-modified">1645     return JSValue::encode(jsNumber(exec-&gt;lexicalGlobalObject()-&gt;weakRandom().seed()));</span>
1646 }
1647 
<span class="line-modified">1648 EncodedJSValue JSC_HOST_CALL functionSetRandomSeed(ExecState* exec)</span>
1649 {
<span class="line-modified">1650     VM&amp; vm = exec-&gt;vm();</span>
1651     auto scope = DECLARE_THROW_SCOPE(vm);
1652 
<span class="line-modified">1653     unsigned seed = exec-&gt;argument(0).toUInt32(exec);</span>
1654     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1655     exec-&gt;lexicalGlobalObject()-&gt;weakRandom().setSeed(seed);</span>
1656     return JSValue::encode(jsUndefined());
1657 }
1658 
<span class="line-modified">1659 EncodedJSValue JSC_HOST_CALL functionIsRope(ExecState* exec)</span>
1660 {
<span class="line-modified">1661     JSValue argument = exec-&gt;argument(0);</span>
1662     if (!argument.isString())
1663         return JSValue::encode(jsBoolean(false));
1664     const StringImpl* impl = asString(argument)-&gt;tryGetValueImpl();
1665     return JSValue::encode(jsBoolean(!impl));
1666 }
1667 
<span class="line-modified">1668 EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(ExecState* state)</span>
1669 {
<span class="line-modified">1670     SourceOrigin sourceOrigin = state-&gt;callerSourceOrigin();</span>

1671     if (sourceOrigin.isNull())
1672         return JSValue::encode(jsNull());
<span class="line-modified">1673     return JSValue::encode(jsString(state-&gt;vm(), sourceOrigin.string()));</span>
1674 }
1675 
<span class="line-modified">1676 EncodedJSValue JSC_HOST_CALL functionReadline(ExecState* exec)</span>
1677 {
1678     Vector&lt;char, 256&gt; line;
1679     int c;
1680     while ((c = getchar()) != EOF) {
1681         // FIXME: Should we also break on \r?
1682         if (c == &#39;\n&#39;)
1683             break;
1684         line.append(c);
1685     }
1686     line.append(&#39;\0&#39;);
<span class="line-modified">1687     return JSValue::encode(jsString(exec-&gt;vm(), line.data()));</span>
1688 }
1689 
<span class="line-modified">1690 EncodedJSValue JSC_HOST_CALL functionPreciseTime(ExecState*)</span>
1691 {
1692     return JSValue::encode(jsNumber(WallTime::now().secondsSinceEpoch().value()));
1693 }
1694 
<span class="line-modified">1695 EncodedJSValue JSC_HOST_CALL functionNeverInlineFunction(ExecState* exec)</span>
1696 {
<span class="line-modified">1697     return JSValue::encode(setNeverInline(exec));</span>
1698 }
1699 
<span class="line-modified">1700 EncodedJSValue JSC_HOST_CALL functionNoDFG(ExecState* exec)</span>
1701 {
<span class="line-modified">1702     return JSValue::encode(setNeverOptimize(exec));</span>
1703 }
1704 
<span class="line-modified">1705 EncodedJSValue JSC_HOST_CALL functionNoFTL(ExecState* exec)</span>
1706 {
<span class="line-modified">1707     if (exec-&gt;argumentCount()) {</span>
<span class="line-modified">1708         FunctionExecutable* executable = getExecutableForFunction(exec-&gt;argument(0));</span>
1709         if (executable)
1710             executable-&gt;setNeverFTLOptimize(true);
1711     }
1712     return JSValue::encode(jsUndefined());
1713 }
1714 
<span class="line-modified">1715 EncodedJSValue JSC_HOST_CALL functionNoOSRExitFuzzing(ExecState* exec)</span>
1716 {
<span class="line-modified">1717     return JSValue::encode(setCannotUseOSRExitFuzzing(exec));</span>
1718 }
1719 
<span class="line-modified">1720 EncodedJSValue JSC_HOST_CALL functionOptimizeNextInvocation(ExecState* exec)</span>
1721 {
<span class="line-modified">1722     return JSValue::encode(optimizeNextInvocation(exec));</span>
1723 }
1724 
<span class="line-modified">1725 EncodedJSValue JSC_HOST_CALL functionNumberOfDFGCompiles(ExecState* exec)</span>
1726 {
<span class="line-modified">1727     return JSValue::encode(numberOfDFGCompiles(exec));</span>

























1728 }
1729 
1730 Message::Message(ArrayBufferContents&amp;&amp; contents, int32_t index)
1731     : m_contents(WTFMove(contents))
1732     , m_index(index)
1733 {
1734 }
1735 
1736 Message::~Message()
1737 {
1738 }
1739 
1740 Worker::Worker(Workers&amp; workers)
1741     : m_workers(workers)
1742 {
1743     auto locker = holdLock(m_workers.m_lock);
1744     m_workers.m_workers.append(this);
1745 
1746     *currentWorker() = this;
1747 }
</pre>
<hr />
<pre>
1821 String Workers::getReport()
1822 {
1823     auto locker = holdLock(m_lock);
1824     while (m_reports.isEmpty())
1825         m_condition.wait(m_lock);
1826     return m_reports.takeFirst();
1827 }
1828 
1829 Workers&amp; Workers::singleton()
1830 {
1831     static Workers* result;
1832     static std::once_flag flag;
1833     std::call_once(
1834         flag,
1835         [] {
1836             result = new Workers();
1837         });
1838     return *result;
1839 }
1840 
<span class="line-modified">1841 EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(ExecState* exec)</span>
1842 {
<span class="line-modified">1843     VM&amp; vm = exec-&gt;vm();</span>
1844     GlobalObject* result = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());
1845     return JSValue::encode(result-&gt;getDirect(vm, Identifier::fromString(vm, &quot;$&quot;)));
1846 }
1847 
<span class="line-modified">1848 EncodedJSValue JSC_HOST_CALL functionDollarDetachArrayBuffer(ExecState* exec)</span>
1849 {
<span class="line-modified">1850     return functionTransferArrayBuffer(exec);</span>
<span class="line-removed">1851 }</span>
<span class="line-removed">1852 </span>
<span class="line-removed">1853 EncodedJSValue JSC_HOST_CALL functionDollarEvalScript(ExecState* exec)</span>
<span class="line-removed">1854 {</span>
<span class="line-removed">1855     VM&amp; vm = exec-&gt;vm();</span>
1856     auto scope = DECLARE_THROW_SCOPE(vm);
1857 
<span class="line-modified">1858     String sourceCode = exec-&gt;argument(0).toWTFString(exec);</span>
1859     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1860 
<span class="line-modified">1861     GlobalObject* globalObject = jsDynamicCast&lt;GlobalObject*&gt;(vm,</span>
<span class="line-modified">1862         exec-&gt;thisValue().get(exec, Identifier::fromString(vm, &quot;global&quot;)));</span>
1863     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1864     if (!globalObject)</span>
<span class="line-modified">1865         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Expected global to point to a global object&quot;_s)));</span>
1866 
1867     NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">1868     JSValue result = evaluate(globalObject-&gt;globalExec(), jscSource(sourceCode, exec-&gt;callerSourceOrigin()), JSValue(), evaluationException);</span>
1869     if (evaluationException)
<span class="line-modified">1870         throwException(exec, scope, evaluationException);</span>
1871     return JSValue::encode(result);
1872 }
1873 
<span class="line-modified">1874 EncodedJSValue JSC_HOST_CALL functionDollarAgentStart(ExecState* exec)</span>
1875 {
<span class="line-modified">1876     VM&amp; vm = exec-&gt;vm();</span>
1877     auto scope = DECLARE_THROW_SCOPE(vm);
1878 
<span class="line-modified">1879     String sourceCode = exec-&gt;argument(0).toWTFString(exec).isolatedCopy();</span>
1880     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1881 
1882     Lock didStartLock;
1883     Condition didStartCondition;
1884     bool didStart = false;
1885 
1886     Thread::create(
1887         &quot;JSC Agent&quot;,
1888         [sourceCode, &amp;didStartLock, &amp;didStartCondition, &amp;didStart] () {
1889             CommandLine commandLine(0, nullptr);
1890             commandLine.m_interactive = false;
1891             runJSC(
1892                 commandLine, true,
1893                 [&amp;] (VM&amp;, GlobalObject* globalObject, bool&amp; success) {
1894                     // Notify the thread that started us that we have registered a worker.
1895                     {
1896                         auto locker = holdLock(didStartLock);
1897                         didStart = true;
1898                         didStartCondition.notifyOne();
1899                     }
1900 
1901                     NakedPtr&lt;Exception&gt; evaluationException;
1902                     JSValue result;
<span class="line-modified">1903                     result = evaluate(globalObject-&gt;globalExec(), jscSource(sourceCode, SourceOrigin(&quot;worker&quot;_s)), JSValue(), evaluationException);</span>
1904                     if (evaluationException)
1905                         result = evaluationException-&gt;value();
<span class="line-modified">1906                     checkException(globalObject-&gt;globalExec(), globalObject, true, evaluationException, result, commandLine, success);</span>
1907                     if (!success)
1908                         exit(1);
1909                 });
1910         })-&gt;detach();
1911 
1912     {
1913         auto locker = holdLock(didStartLock);
1914         while (!didStart)
1915             didStartCondition.wait(didStartLock);
1916     }
1917 
1918     return JSValue::encode(jsUndefined());
1919 }
1920 
<span class="line-modified">1921 EncodedJSValue JSC_HOST_CALL functionDollarAgentReceiveBroadcast(ExecState* exec)</span>
1922 {
<span class="line-modified">1923     VM&amp; vm = exec-&gt;vm();</span>
1924     auto scope = DECLARE_THROW_SCOPE(vm);
1925 
<span class="line-modified">1926     JSValue callback = exec-&gt;argument(0);</span>
1927     CallData callData;
1928     CallType callType = getCallData(vm, callback, callData);
1929     if (callType == CallType::None)
<span class="line-modified">1930         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Expected callback&quot;_s)));</span>
1931 
1932     RefPtr&lt;Message&gt; message;
1933     {
1934         ReleaseHeapAccessScope releaseAccess(vm.heap);
1935         message = Worker::current().dequeue();
1936     }
1937 
1938     auto nativeBuffer = ArrayBuffer::create(message-&gt;releaseContents());
1939     ArrayBufferSharingMode sharingMode = nativeBuffer-&gt;sharingMode();
<span class="line-modified">1940     JSArrayBuffer* jsBuffer = JSArrayBuffer::create(vm, exec-&gt;lexicalGlobalObject()-&gt;arrayBufferStructure(sharingMode), WTFMove(nativeBuffer));</span>
1941 
1942     MarkedArgumentBuffer args;
1943     args.append(jsBuffer);
1944     args.append(jsNumber(message-&gt;index()));
1945     if (UNLIKELY(args.hasOverflowed()))
<span class="line-modified">1946         return JSValue::encode(throwOutOfMemoryError(exec, scope));</span>
<span class="line-modified">1947     RELEASE_AND_RETURN(scope, JSValue::encode(call(exec, callback, callType, callData, jsNull(), args)));</span>
1948 }
1949 
<span class="line-modified">1950 EncodedJSValue JSC_HOST_CALL functionDollarAgentReport(ExecState* exec)</span>
1951 {
<span class="line-modified">1952     VM&amp; vm = exec-&gt;vm();</span>
1953     auto scope = DECLARE_THROW_SCOPE(vm);
1954 
<span class="line-modified">1955     String report = exec-&gt;argument(0).toWTFString(exec);</span>
1956     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1957 
1958     Workers::singleton().report(report);
1959 
1960     return JSValue::encode(jsUndefined());
1961 }
1962 
<span class="line-modified">1963 EncodedJSValue JSC_HOST_CALL functionDollarAgentSleep(ExecState* exec)</span>
1964 {
<span class="line-modified">1965     VM&amp; vm = exec-&gt;vm();</span>
1966     auto scope = DECLARE_THROW_SCOPE(vm);
1967 
<span class="line-modified">1968     if (exec-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">1969         Seconds seconds = Seconds::fromMilliseconds(exec-&gt;argument(0).toNumber(exec));</span>
1970         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1971         sleep(seconds);
1972     }
1973     return JSValue::encode(jsUndefined());
1974 }
1975 
<span class="line-modified">1976 EncodedJSValue JSC_HOST_CALL functionDollarAgentBroadcast(ExecState* exec)</span>
1977 {
<span class="line-modified">1978     VM&amp; vm = exec-&gt;vm();</span>
1979     auto scope = DECLARE_THROW_SCOPE(vm);
1980 
<span class="line-modified">1981     JSArrayBuffer* jsBuffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, exec-&gt;argument(0));</span>
1982     if (!jsBuffer || !jsBuffer-&gt;isShared())
<span class="line-modified">1983         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Expected SharedArrayBuffer&quot;_s)));</span>
1984 
<span class="line-modified">1985     int32_t index = exec-&gt;argument(1).toInt32(exec);</span>
1986     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1987 
1988     Workers::singleton().broadcast(
1989         [&amp;] (const AbstractLocker&amp; locker, Worker&amp; worker) {
1990             ArrayBuffer* nativeBuffer = jsBuffer-&gt;impl();
1991             ArrayBufferContents contents;
1992             nativeBuffer-&gt;transferTo(vm, contents); // &quot;transferTo&quot; means &quot;share&quot; if the buffer is shared.
1993             RefPtr&lt;Message&gt; message = adoptRef(new Message(WTFMove(contents), index));
1994             worker.enqueue(locker, message);
1995         });
1996 
1997     return JSValue::encode(jsUndefined());
1998 }
1999 
<span class="line-modified">2000 EncodedJSValue JSC_HOST_CALL functionDollarAgentGetReport(ExecState* exec)</span>
2001 {
<span class="line-modified">2002     VM&amp; vm = exec-&gt;vm();</span>
2003 
2004     String string = Workers::singleton().tryGetReport();
2005     if (!string)
2006         return JSValue::encode(jsNull());
2007 
2008     return JSValue::encode(jsString(vm, string));
2009 }
2010 
<span class="line-modified">2011 EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(ExecState*)</span>
2012 {
2013     return JSValue::encode(jsUndefined());
2014 }
2015 
<span class="line-modified">2016 EncodedJSValue JSC_HOST_CALL functionDollarAgentMonotonicNow(ExecState*)</span>
2017 {
2018     return JSValue::encode(jsNumber(MonotonicTime::now().secondsSinceEpoch().milliseconds()));
2019 }
2020 
<span class="line-modified">2021 EncodedJSValue JSC_HOST_CALL functionWaitForReport(ExecState* exec)</span>
2022 {
<span class="line-modified">2023     VM&amp; vm = exec-&gt;vm();</span>
2024 
2025     String string;
2026     {
2027         ReleaseHeapAccessScope releaseAccess(vm.heap);
2028         string = Workers::singleton().getReport();
2029     }
2030     if (!string)
2031         return JSValue::encode(jsNull());
2032 
2033     return JSValue::encode(jsString(vm, string));
2034 }
2035 
<span class="line-modified">2036 EncodedJSValue JSC_HOST_CALL functionHeapCapacity(ExecState* exec)</span>
2037 {
<span class="line-modified">2038     VM&amp; vm = exec-&gt;vm();</span>
2039     return JSValue::encode(jsNumber(vm.heap.capacity()));
2040 }
2041 
<span class="line-modified">2042 EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(ExecState* exec)</span>
2043 {
<span class="line-modified">2044     VM&amp; vm = exec-&gt;vm();</span>
2045     auto scope = DECLARE_THROW_SCOPE(vm);
2046 
2047     double sleepTimeMs = 0;
<span class="line-modified">2048     if (exec-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">2049         sleepTimeMs = exec-&gt;argument(0).toNumber(exec);</span>
2050         RETURN_IF_EXCEPTION(scope, encodedJSValue());
2051     }
2052 
2053     vm.heap.releaseAccess();
2054     if (sleepTimeMs)
2055         sleep(Seconds::fromMilliseconds(sleepTimeMs));
2056     vm.heap.acquireAccess();
2057     return JSValue::encode(jsUndefined());
2058 }
2059 
<span class="line-modified">2060 EncodedJSValue JSC_HOST_CALL functionDisableRichSourceInfo(ExecState*)</span>
2061 {
2062     supportsRichSourceInfo = false;
2063     return JSValue::encode(jsUndefined());
2064 }
2065 
<span class="line-modified">2066 EncodedJSValue JSC_HOST_CALL functionMallocInALoop(ExecState*)</span>
2067 {
2068     Vector&lt;void*&gt; ptrs;
2069     for (unsigned i = 0; i &lt; 5000; ++i)
2070         ptrs.append(fastMalloc(1024 * 2));
2071     for (void* ptr : ptrs)
2072         fastFree(ptr);
2073     return JSValue::encode(jsUndefined());
2074 }
2075 
<span class="line-modified">2076 EncodedJSValue JSC_HOST_CALL functionTotalCompileTime(ExecState*)</span>
2077 {
2078 #if ENABLE(JIT)
2079     return JSValue::encode(jsNumber(JIT::totalCompileTime().milliseconds()));
2080 #else
2081     return JSValue::encode(jsNumber(0));
2082 #endif
2083 }
2084 
2085 template&lt;typename ValueType&gt;
2086 typename std::enable_if&lt;!std::is_fundamental&lt;ValueType&gt;::value&gt;::type addOption(VM&amp;, JSObject*, const Identifier&amp;, ValueType) { }
2087 
2088 template&lt;typename ValueType&gt;
2089 typename std::enable_if&lt;std::is_fundamental&lt;ValueType&gt;::value&gt;::type addOption(VM&amp; vm, JSObject* optionsObject, const Identifier&amp; identifier, ValueType value)
2090 {
2091     optionsObject-&gt;putDirect(vm, identifier, JSValue(value));
2092 }
2093 
<span class="line-modified">2094 EncodedJSValue JSC_HOST_CALL functionJSCOptions(ExecState* exec)</span>
2095 {
<span class="line-modified">2096     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2097     JSObject* optionsObject = constructEmptyObject(exec);</span>
<span class="line-modified">2098 #define FOR_EACH_OPTION(type_, name_, defaultValue_, availability_, description_) \</span>
2099     addOption(vm, optionsObject, Identifier::fromString(vm, #name_), Options::name_());
<span class="line-modified">2100     JSC_OPTIONS(FOR_EACH_OPTION)</span>
<span class="line-modified">2101 #undef FOR_EACH_OPTION</span>
2102     return JSValue::encode(optionsObject);
2103 }
2104 
<span class="line-modified">2105 EncodedJSValue JSC_HOST_CALL functionReoptimizationRetryCount(ExecState* exec)</span>
2106 {
<span class="line-modified">2107     if (exec-&gt;argumentCount() &lt; 1)</span>
2108         return JSValue::encode(jsUndefined());
2109 
<span class="line-modified">2110     CodeBlock* block = getSomeBaselineCodeBlockForFunction(exec-&gt;argument(0));</span>
2111     if (!block)
2112         return JSValue::encode(jsNumber(0));
2113 
2114     return JSValue::encode(jsNumber(block-&gt;reoptimizationRetryCounter()));
2115 }
2116 
<span class="line-modified">2117 EncodedJSValue JSC_HOST_CALL functionTransferArrayBuffer(ExecState* exec)</span>
2118 {
<span class="line-modified">2119     VM&amp; vm = exec-&gt;vm();</span>
2120     auto scope = DECLARE_THROW_SCOPE(vm);
2121 
<span class="line-modified">2122     if (exec-&gt;argumentCount() &lt; 1)</span>
<span class="line-modified">2123         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Not enough arguments&quot;_s)));</span>
2124 
<span class="line-modified">2125     JSArrayBuffer* buffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, exec-&gt;argument(0));</span>
2126     if (!buffer)
<span class="line-modified">2127         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Expected an array buffer&quot;_s)));</span>
2128 
2129     ArrayBufferContents dummyContents;
2130     buffer-&gt;impl()-&gt;transferTo(vm, dummyContents);
2131 
2132     return JSValue::encode(jsUndefined());
2133 }
2134 
<span class="line-modified">2135 EncodedJSValue JSC_HOST_CALL functionFailNextNewCodeBlock(ExecState* exec)</span>
2136 {
<span class="line-modified">2137     VM&amp; vm = exec-&gt;vm();</span>
2138     vm.setFailNextNewCodeBlock();
2139     return JSValue::encode(jsUndefined());
2140 }
2141 
<span class="line-modified">2142 EncodedJSValue JSC_HOST_CALL functionQuit(ExecState* exec)</span>
2143 {
<span class="line-modified">2144     VM&amp; vm = exec-&gt;vm();</span>
2145     vm.codeCache()-&gt;write(vm);
2146 
2147     jscExit(EXIT_SUCCESS);
2148 
2149 #if COMPILER(MSVC)
2150     // Without this, Visual Studio will complain that this method does not return a value.
2151     return JSValue::encode(jsUndefined());
2152 #endif
2153 }
2154 
<span class="line-modified">2155 EncodedJSValue JSC_HOST_CALL functionFalse(ExecState*) { return JSValue::encode(jsBoolean(false)); }</span>
2156 
<span class="line-modified">2157 EncodedJSValue JSC_HOST_CALL functionUndefined1(ExecState*) { return JSValue::encode(jsUndefined()); }</span>
<span class="line-modified">2158 EncodedJSValue JSC_HOST_CALL functionUndefined2(ExecState*) { return JSValue::encode(jsUndefined()); }</span>
<span class="line-modified">2159 EncodedJSValue JSC_HOST_CALL functionIsInt32(ExecState* exec)</span>
2160 {
<span class="line-modified">2161     for (size_t i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">2162         if (!exec-&gt;argument(i).isInt32())</span>
2163             return JSValue::encode(jsBoolean(false));
2164     }
2165     return JSValue::encode(jsBoolean(true));
2166 }
2167 
<span class="line-modified">2168 EncodedJSValue JSC_HOST_CALL functionIsPureNaN(ExecState* exec)</span>
2169 {
<span class="line-modified">2170     for (size_t i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">2171         JSValue value = exec-&gt;argument(i);</span>
2172         if (!value.isNumber())
2173             return JSValue::encode(jsBoolean(false));
2174         double number = value.asNumber();
2175         if (!std::isnan(number))
2176             return JSValue::encode(jsBoolean(false));
2177         if (isImpureNaN(number))
2178             return JSValue::encode(jsBoolean(false));
2179     }
2180     return JSValue::encode(jsBoolean(true));
2181 }
2182 
<span class="line-modified">2183 EncodedJSValue JSC_HOST_CALL functionIdentity(ExecState* exec) { return JSValue::encode(exec-&gt;argument(0)); }</span>
2184 
<span class="line-modified">2185 EncodedJSValue JSC_HOST_CALL functionEffectful42(ExecState*)</span>
2186 {
2187     return JSValue::encode(jsNumber(42));
2188 }
2189 
<span class="line-modified">2190 EncodedJSValue JSC_HOST_CALL functionMakeMasquerader(ExecState* exec)</span>
2191 {
<span class="line-modified">2192     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2193     return JSValue::encode(Masquerader::create(vm, exec-&gt;lexicalGlobalObject()));</span>
2194 }
2195 
<span class="line-modified">2196 EncodedJSValue JSC_HOST_CALL functionHasCustomProperties(ExecState* exec)</span>
2197 {
<span class="line-modified">2198     JSValue value = exec-&gt;argument(0);</span>
2199     if (value.isObject())
<span class="line-modified">2200         return JSValue::encode(jsBoolean(asObject(value)-&gt;hasCustomProperties(exec-&gt;vm())));</span>
2201     return JSValue::encode(jsBoolean(false));
2202 }
2203 
<span class="line-modified">2204 EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(ExecState* exec)</span>
2205 {
<span class="line-modified">2206     VM&amp; vm = exec-&gt;vm();</span>
2207     vm.dumpTypeProfilerData();
2208     return JSValue::encode(jsUndefined());
2209 }
2210 
<span class="line-modified">2211 EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(ExecState* exec)</span>
2212 {
<span class="line-modified">2213     VM&amp; vm = exec-&gt;vm();</span>
2214     vm.drainMicrotasks();
2215     return JSValue::encode(jsUndefined());
2216 }
2217 
<span class="line-modified">2218 EncodedJSValue JSC_HOST_CALL functionReleaseWeakRefs(ExecState* exec)</span>
2219 {
<span class="line-modified">2220     VM&amp; vm = exec-&gt;vm();</span>
2221     vm.finalizeSynchronousJSExecution();
2222     return JSValue::encode(jsUndefined());
2223 }
2224 
<span class="line-modified">2225 EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(ExecState*)</span>
2226 {
2227 #if USE(JSVALUE64)
2228     return JSValue::encode(JSValue(JSC::JSValue::JSFalse));
2229 #else
2230     return JSValue::encode(JSValue(JSC::JSValue::JSTrue));
2231 #endif
2232 }
2233 
<span class="line-modified">2234 EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(ExecState* exec)</span>
2235 {
<span class="line-modified">2236     VM&amp; vm = exec-&gt;vm();</span>
2237     return JSValue::encode(GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;()));
2238 }
2239 
<span class="line-modified">2240 EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(ExecState* exec)</span>
2241 {
<span class="line-modified">2242     VM&amp; vm = exec-&gt;vm();</span>
2243     auto scope = DECLARE_THROW_SCOPE(vm);
2244 
<span class="line-modified">2245     String source = exec-&gt;argument(0).toWTFString(exec);</span>
2246     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2247 
2248     StopWatch stopWatch;
2249     stopWatch.start();
2250 
2251     ParserError error;
<span class="line-modified">2252     bool validSyntax = checkModuleSyntax(exec, jscSource(source, { }, URL(), TextPosition(), SourceProviderSourceType::Module), error);</span>
2253     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2254     stopWatch.stop();
2255 
2256     if (!validSyntax)
<span class="line-modified">2257         throwException(exec, scope, jsNontrivialString(vm, toString(&quot;SyntaxError: &quot;, error.message(), &quot;:&quot;, error.line())));</span>
2258     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
2259 }
2260 
<span class="line-modified">2261 EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(ExecState*)</span>
2262 {
2263 #if ENABLE(SAMPLING_PROFILER)
2264     return JSValue::encode(JSValue(JSC::JSValue::JSTrue));
2265 #else
2266     return JSValue::encode(JSValue(JSC::JSValue::JSFalse));
2267 #endif
2268 }
2269 
<span class="line-modified">2270 EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(ExecState* exec)</span>
2271 {
<span class="line-modified">2272     VM&amp; vm = exec-&gt;vm();</span>
2273     JSLockHolder lock(vm);
2274     auto scope = DECLARE_THROW_SCOPE(vm);
2275 
2276     HeapSnapshotBuilder snapshotBuilder(vm.ensureHeapProfiler());
2277     snapshotBuilder.buildSnapshot();
2278 
2279     String jsonString = snapshotBuilder.json();
<span class="line-modified">2280     EncodedJSValue result = JSValue::encode(JSONParse(exec, jsonString));</span>
2281     scope.releaseAssertNoException();
2282     return result;
2283 }
2284 
<span class="line-modified">2285 EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(ExecState* exec)</span>
2286 {
<span class="line-modified">2287     VM&amp; vm = exec-&gt;vm();</span>
2288     JSLockHolder lock(vm);
2289     auto scope = DECLARE_THROW_SCOPE(vm);
2290     String jsonString;
2291     {
2292         DeferGCForAWhile deferGC(vm.heap); // Prevent concurrent GC from interfering with the full GC that the snapshot does.
2293 
2294         HeapSnapshotBuilder snapshotBuilder(vm.ensureHeapProfiler(), HeapSnapshotBuilder::SnapshotType::GCDebuggingSnapshot);
2295         snapshotBuilder.buildSnapshot();
2296 
2297         jsonString = snapshotBuilder.json();
2298     }
2299     scope.releaseAssertNoException();
2300     return JSValue::encode(jsString(vm, jsonString));
2301 }
2302 
<span class="line-modified">2303 EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(ExecState*)</span>
2304 {
2305     resetSuperSamplerState();
2306     return JSValue::encode(jsUndefined());
2307 }
2308 
<span class="line-modified">2309 EncodedJSValue JSC_HOST_CALL functionEnsureArrayStorage(ExecState* exec)</span>
2310 {
<span class="line-modified">2311     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2312     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">2313         if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(i)))</span>
2314             object-&gt;ensureArrayStorage(vm);
2315     }
2316     return JSValue::encode(jsUndefined());
2317 }
2318 
2319 #if ENABLE(SAMPLING_PROFILER)
<span class="line-modified">2320 EncodedJSValue JSC_HOST_CALL functionStartSamplingProfiler(ExecState* exec)</span>
2321 {
<span class="line-modified">2322     VM&amp; vm = exec-&gt;vm();</span>
2323     SamplingProfiler&amp; samplingProfiler = vm.ensureSamplingProfiler(WTF::Stopwatch::create());
2324     samplingProfiler.noticeCurrentThreadAsJSCExecutionThread();
2325     samplingProfiler.start();
2326     return JSValue::encode(jsUndefined());
2327 }
2328 
<span class="line-modified">2329 EncodedJSValue JSC_HOST_CALL functionSamplingProfilerStackTraces(ExecState* exec)</span>
2330 {
<span class="line-modified">2331     VM&amp; vm = exec-&gt;vm();</span>
2332     auto scope = DECLARE_THROW_SCOPE(vm);
2333 
2334     if (!vm.samplingProfiler())
<span class="line-modified">2335         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Sampling profiler was never started&quot;_s)));</span>
2336 
2337     String jsonString = vm.samplingProfiler()-&gt;stackTracesAsJSON();
<span class="line-modified">2338     EncodedJSValue result = JSValue::encode(JSONParse(exec, jsonString));</span>
2339     scope.releaseAssertNoException();
2340     return result;
2341 }
2342 #endif // ENABLE(SAMPLING_PROFILER)
2343 
<span class="line-modified">2344 EncodedJSValue JSC_HOST_CALL functionMaxArguments(ExecState*)</span>
2345 {
2346     return JSValue::encode(jsNumber(JSC::maxArguments));
2347 }
2348 
<span class="line-modified">2349 EncodedJSValue JSC_HOST_CALL functionAsyncTestStart(ExecState* exec)</span>
2350 {
<span class="line-modified">2351     VM&amp; vm = exec-&gt;vm();</span>
2352     auto scope = DECLARE_THROW_SCOPE(vm);
2353 
<span class="line-modified">2354     JSValue numberOfAsyncPasses = exec-&gt;argument(0);</span>
2355     if (!numberOfAsyncPasses.isUInt32())
<span class="line-modified">2356         return throwVMError(exec, scope, &quot;Expected first argument to be a uint32&quot;_s);</span>
2357 
2358     asyncTestExpectedPasses += numberOfAsyncPasses.asUInt32();
2359     return encodedJSUndefined();
2360 }
2361 
<span class="line-modified">2362 EncodedJSValue JSC_HOST_CALL functionAsyncTestPassed(ExecState*)</span>
2363 {
2364     asyncTestPasses++;
2365     return encodedJSUndefined();
2366 }
2367 
2368 #if ENABLE(WEBASSEMBLY)
2369 
<span class="line-modified">2370 static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(ExecState* exec)</span>
2371 {
<span class="line-modified">2372     VM&amp; vm = exec-&gt;vm();</span>
2373     auto scope = DECLARE_THROW_SCOPE(vm);
2374 
2375     if (!Wasm::isSupported())
<span class="line-modified">2376         return throwVMTypeError(exec, scope, &quot;WebAssemblyMemoryMode should only be called if the useWebAssembly option is set&quot;_s);</span>
2377 
<span class="line-modified">2378     if (JSObject* object = exec-&gt;argument(0).getObject()) {</span>
2379         if (auto* memory = jsDynamicCast&lt;JSWebAssemblyMemory*&gt;(vm, object))
2380             return JSValue::encode(jsString(vm, makeString(memory-&gt;memory().mode())));
2381         if (auto* instance = jsDynamicCast&lt;JSWebAssemblyInstance*&gt;(vm, object))
2382             return JSValue::encode(jsString(vm, makeString(instance-&gt;memoryMode())));
2383     }
2384 
<span class="line-modified">2385     return throwVMTypeError(exec, scope, &quot;WebAssemblyMemoryMode expects either a WebAssembly.Memory or WebAssembly.Instance&quot;_s);</span>
2386 }
2387 
2388 #endif // ENABLE(WEBASSEMBLY)
2389 
<span class="line-modified">2390 EncodedJSValue JSC_HOST_CALL functionSetUnhandledRejectionCallback(ExecState* exec)</span>
2391 {
<span class="line-modified">2392     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">2393     JSObject* object = exec-&gt;argument(0).getObject();</span>
2394     auto scope = DECLARE_THROW_SCOPE(vm);
2395 
2396     if (!object || !object-&gt;isFunction(vm))
<span class="line-modified">2397         return throwVMTypeError(exec, scope);</span>
2398 
<span class="line-modified">2399     exec-&gt;lexicalGlobalObject()-&gt;setUnhandledRejectionCallback(vm, object);</span>
2400     return JSValue::encode(jsUndefined());
2401 }
2402 
2403 // Use SEH for Release builds only to get rid of the crash report dialog
2404 // (luckily the same tests fail in Release and Debug builds so far). Need to
2405 // be in a separate main function because the jscmain function requires object
2406 // unwinding.
2407 
2408 #if COMPILER(MSVC) &amp;&amp; !defined(_DEBUG)
2409 #define TRY       __try {
2410 #define EXCEPT(x) } __except (EXCEPTION_EXECUTE_HANDLER) { x; }
2411 #else
2412 #define TRY
2413 #define EXCEPT(x)
2414 #endif
2415 
2416 int jscmain(int argc, char** argv);
2417 
2418 static double s_desiredTimeout;
2419 static double s_timeoutMultiplier = 1.0;
















2420 
<span class="line-modified">2421 static void startTimeoutThreadIfNeeded()</span>












2422 {
2423     if (char* timeoutString = getenv(&quot;JSCTEST_timeout&quot;)) {
2424         if (sscanf(timeoutString, &quot;%lf&quot;, &amp;s_desiredTimeout) != 1) {
2425             dataLog(&quot;WARNING: timeout string is malformed, got &quot;, timeoutString,
2426                 &quot; but expected a number. Not using a timeout.\n&quot;);
<span class="line-modified">2427         } else {</span>
<span class="line-modified">2428             Thread::create(&quot;jsc Timeout Thread&quot;, [] () {</span>
<span class="line-removed">2429                 Seconds timeoutDuration(s_desiredTimeout * s_timeoutMultiplier);</span>
<span class="line-removed">2430                 sleep(timeoutDuration);</span>
<span class="line-removed">2431                 dataLog(&quot;Timed out after &quot;, timeoutDuration, &quot; seconds!\n&quot;);</span>
<span class="line-removed">2432                 CRASH();</span>
<span class="line-removed">2433             });</span>
<span class="line-removed">2434         }</span>
2435     }
2436 }
2437 












2438 int main(int argc, char** argv)
2439 {
<span class="line-modified">2440 #if PLATFORM(IOS_FAMILY) &amp;&amp; CPU(ARM_THUMB2)</span>
2441     // Enabled IEEE754 denormal support.
2442     fenv_t env;
2443     fegetenv( &amp;env );
2444     env.__fpscr &amp;= ~0x01000000u;
2445     fesetenv( &amp;env );
2446 #endif
2447 
2448 #if OS(WINDOWS)
2449     // Cygwin calls ::SetErrorMode(SEM_FAILCRITICALERRORS), which we will inherit. This is bad for
2450     // testing/debugging, as it causes the post-mortem debugger not to be invoked. We reset the
2451     // error mode here to work around Cygwin&#39;s behavior. See &lt;http://webkit.org/b/55222&gt;.
2452     ::SetErrorMode(0);
2453 
2454     _setmode(_fileno(stdout), _O_BINARY);
2455     _setmode(_fileno(stderr), _O_BINARY);
2456 
2457 #if defined(_DEBUG)
2458     _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);
2459     _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);
2460     _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);
</pre>
<hr />
<pre>
2486     TRY
2487         res = jscmain(argc, argv);
2488     EXCEPT(res = 3)
2489     finalizeStatsAtEndOfTesting();
2490 
2491     jscExit(res);
2492 }
2493 
2494 static void dumpException(GlobalObject* globalObject, JSValue exception)
2495 {
2496     VM&amp; vm = globalObject-&gt;vm();
2497     auto scope = DECLARE_CATCH_SCOPE(vm);
2498 
2499 #define CHECK_EXCEPTION() do { \
2500         if (scope.exception()) { \
2501             scope.clearException(); \
2502             return; \
2503         } \
2504     } while (false)
2505 
<span class="line-modified">2506     auto exceptionString = exception.toWTFString(globalObject-&gt;globalExec());</span>

2507     Expected&lt;CString, UTF8ConversionError&gt; expectedCString = exceptionString.tryGetUtf8();
2508     if (expectedCString)
2509         printf(&quot;Exception: %s\n&quot;, expectedCString.value().data());
2510     else
2511         printf(&quot;Exception: &lt;out of memory while extracting exception string&gt;\n&quot;);
2512 
2513     Identifier nameID = Identifier::fromString(vm, &quot;name&quot;);
2514     CHECK_EXCEPTION();
2515     Identifier fileNameID = Identifier::fromString(vm, &quot;sourceURL&quot;);
2516     CHECK_EXCEPTION();
2517     Identifier lineNumberID = Identifier::fromString(vm, &quot;line&quot;);
2518     CHECK_EXCEPTION();
2519     Identifier stackID = Identifier::fromString(vm, &quot;stack&quot;);
2520     CHECK_EXCEPTION();
2521 
<span class="line-modified">2522     JSValue nameValue = exception.get(globalObject-&gt;globalExec(), nameID);</span>
2523     CHECK_EXCEPTION();
<span class="line-modified">2524     JSValue fileNameValue = exception.get(globalObject-&gt;globalExec(), fileNameID);</span>
2525     CHECK_EXCEPTION();
<span class="line-modified">2526     JSValue lineNumberValue = exception.get(globalObject-&gt;globalExec(), lineNumberID);</span>
2527     CHECK_EXCEPTION();
<span class="line-modified">2528     JSValue stackValue = exception.get(globalObject-&gt;globalExec(), stackID);</span>
2529     CHECK_EXCEPTION();
2530 
<span class="line-modified">2531     if (nameValue.toWTFString(globalObject-&gt;globalExec()) == &quot;SyntaxError&quot;</span>
<span class="line-modified">2532         &amp;&amp; (!fileNameValue.isUndefinedOrNull() || !lineNumberValue.isUndefinedOrNull())) {</span>
<span class="line-modified">2533         printf(</span>
<span class="line-modified">2534             &quot;at %s:%s\n&quot;,</span>
<span class="line-modified">2535             fileNameValue.toWTFString(globalObject-&gt;globalExec()).utf8().data(),</span>
<span class="line-modified">2536             lineNumberValue.toWTFString(globalObject-&gt;globalExec()).utf8().data());</span>



2537     }
2538 
2539     if (!stackValue.isUndefinedOrNull()) {
<span class="line-modified">2540         auto stackString = stackValue.toWTFString(globalObject-&gt;globalExec());</span>

2541         if (stackString.length())
2542             printf(&quot;%s\n&quot;, stackString.utf8().data());
2543     }
2544 
2545 #undef CHECK_EXCEPTION
2546 }
2547 
2548 static bool checkUncaughtException(VM&amp; vm, GlobalObject* globalObject, JSValue exception, CommandLine&amp; options)
2549 {
2550     const String&amp; expectedExceptionName = options.m_uncaughtExceptionName;
2551     auto scope = DECLARE_CATCH_SCOPE(vm);
2552     scope.clearException();
2553     if (!exception) {
2554         printf(&quot;Expected uncaught exception with name &#39;%s&#39; but none was thrown\n&quot;, expectedExceptionName.utf8().data());
2555         return false;
2556     }
2557 
<span class="line-modified">2558     ExecState* exec = globalObject-&gt;globalExec();</span>
<span class="line-removed">2559     JSValue exceptionClass = globalObject-&gt;get(exec, Identifier::fromString(vm, expectedExceptionName));</span>
2560     if (!exceptionClass.isObject() || scope.exception()) {
2561         printf(&quot;Expected uncaught exception with name &#39;%s&#39; but given exception class is not defined\n&quot;, expectedExceptionName.utf8().data());
2562         return false;
2563     }
2564 
<span class="line-modified">2565     bool isInstanceOfExpectedException = jsCast&lt;JSObject*&gt;(exceptionClass)-&gt;hasInstance(exec, exception);</span>
2566     if (scope.exception()) {
2567         printf(&quot;Expected uncaught exception with name &#39;%s&#39; but given exception class fails performing hasInstance\n&quot;, expectedExceptionName.utf8().data());
2568         return false;
2569     }
2570     if (isInstanceOfExpectedException) {
2571         if (options.m_alwaysDumpUncaughtException)
2572             dumpException(globalObject, exception);
2573         return true;
2574     }
2575 
2576     printf(&quot;Expected uncaught exception with name &#39;%s&#39; but exception value is not instance of this exception class\n&quot;, expectedExceptionName.utf8().data());
2577     dumpException(globalObject, exception);
2578     return false;
2579 }
2580 
<span class="line-modified">2581 static void checkException(ExecState* exec, GlobalObject* globalObject, bool isLastFile, bool hasException, JSValue value, CommandLine&amp; options, bool&amp; success)</span>
2582 {
2583     VM&amp; vm = globalObject-&gt;vm();
2584 
2585     if (options.m_treatWatchdogExceptionAsSuccess &amp;&amp; value.inherits&lt;TerminatedExecutionError&gt;(vm)) {
2586         ASSERT(hasException);
2587         return;
2588     }
2589 
2590     if (!options.m_uncaughtExceptionName || !isLastFile) {
2591         success = success &amp;&amp; !hasException;
2592         if (options.m_dump &amp;&amp; !hasException)
<span class="line-modified">2593             printf(&quot;End: %s\n&quot;, value.toWTFString(exec).utf8().data());</span>
2594         if (hasException)
2595             dumpException(globalObject, value);
2596     } else
2597         success = success &amp;&amp; checkUncaughtException(vm, globalObject, (hasException) ? value : JSValue(), options);
2598 }
2599 
2600 static void runWithOptions(GlobalObject* globalObject, CommandLine&amp; options, bool&amp; success)
2601 {
2602     Vector&lt;Script&gt;&amp; scripts = options.m_scripts;
2603     String fileName;
2604     Vector&lt;char&gt; scriptBuffer;
2605 
<span class="line-removed">2606     if (options.m_dump)</span>
<span class="line-removed">2607         JSC::Options::dumpGeneratedBytecodes() = true;</span>
<span class="line-removed">2608 </span>
2609     VM&amp; vm = globalObject-&gt;vm();
2610     auto scope = DECLARE_CATCH_SCOPE(vm);
2611 
2612 #if ENABLE(SAMPLING_FLAGS)
2613     SamplingFlags::start();
2614 #endif
2615 
2616     for (size_t i = 0; i &lt; scripts.size(); i++) {
2617         JSInternalPromise* promise = nullptr;
2618         bool isModule = options.m_module || scripts[i].scriptType == Script::ScriptType::Module;
2619         if (scripts[i].codeSource == Script::CodeSource::File) {
2620             fileName = scripts[i].argument;
2621             if (scripts[i].strictMode == Script::StrictMode::Strict)
2622                 scriptBuffer.append(&quot;\&quot;use strict\&quot;;\n&quot;, strlen(&quot;\&quot;use strict\&quot;;\n&quot;));
2623 
2624             if (isModule) {
<span class="line-modified">2625                 promise = loadAndEvaluateModule(globalObject-&gt;globalExec(), fileName, jsUndefined(), jsUndefined());</span>
2626                 scope.releaseAssertNoException();
2627             } else {
2628                 if (!fetchScriptFromLocalFileSystem(fileName, scriptBuffer)) {
2629                     success = false; // fail early so we can catch missing files
2630                     return;
2631                 }
2632             }
2633         } else {
2634             size_t commandLineLength = strlen(scripts[i].argument);
2635             scriptBuffer.resize(commandLineLength);
2636             std::copy(scripts[i].argument, scripts[i].argument + commandLineLength, scriptBuffer.begin());
2637             fileName = &quot;[Command Line]&quot;_s;
2638         }
2639 
2640         bool isLastFile = i == scripts.size() - 1;
2641         if (isModule) {
2642             if (!promise) {
2643                 // FIXME: This should use an absolute file URL https://bugs.webkit.org/show_bug.cgi?id=193077
<span class="line-modified">2644                 promise = loadAndEvaluateModule(globalObject-&gt;globalExec(), jscSource(stringFromUTF(scriptBuffer), SourceOrigin { absolutePath(fileName) }, URL({ }, fileName), TextPosition(), SourceProviderSourceType::Module), jsUndefined());</span>
2645             }
2646             scope.clearException();
2647 
<span class="line-modified">2648             JSFunction* fulfillHandler = JSNativeStdFunction::create(vm, globalObject, 1, String(), [&amp;success, &amp;options, isLastFile](ExecState* exec) {</span>
<span class="line-modified">2649                 checkException(exec, jsCast&lt;GlobalObject*&gt;(exec-&gt;lexicalGlobalObject()), isLastFile, false, exec-&gt;argument(0), options, success);</span>
2650                 return JSValue::encode(jsUndefined());
2651             });
2652 
<span class="line-modified">2653             JSFunction* rejectHandler = JSNativeStdFunction::create(vm, globalObject, 1, String(), [&amp;success, &amp;options, isLastFile](ExecState* exec) {</span>
<span class="line-modified">2654                 checkException(exec, jsCast&lt;GlobalObject*&gt;(exec-&gt;lexicalGlobalObject()), isLastFile, true, exec-&gt;argument(0), options, success);</span>
2655                 return JSValue::encode(jsUndefined());
2656             });
2657 
<span class="line-modified">2658             promise-&gt;then(globalObject-&gt;globalExec(), fulfillHandler, rejectHandler);</span>
2659             scope.releaseAssertNoException();
2660             vm.drainMicrotasks();
2661         } else {
2662             NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">2663             JSValue returnValue = evaluate(globalObject-&gt;globalExec(), jscSource(scriptBuffer, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), evaluationException);</span>
2664             scope.assertNoException();
2665             if (evaluationException)
2666                 returnValue = evaluationException-&gt;value();
<span class="line-modified">2667             checkException(globalObject-&gt;globalExec(), globalObject, isLastFile, evaluationException, returnValue, options, success);</span>
2668         }
2669 
2670         scriptBuffer.clear();
2671         scope.clearException();
2672     }
2673 
2674 #if ENABLE(REGEXP_TRACING)
2675     vm.dumpRegExpTrace();
2676 #endif
2677 }
2678 
2679 #define RUNNING_FROM_XCODE 0
2680 
2681 static void runInteractive(GlobalObject* globalObject)
2682 {
2683     VM&amp; vm = globalObject-&gt;vm();
2684     auto scope = DECLARE_CATCH_SCOPE(vm);
2685 
2686     Optional&lt;DirectoryName&gt; directoryName = currentWorkingDirectory();
2687     if (!directoryName)
</pre>
<hr />
<pre>
2700             if (!line)
2701                 break;
2702             source = source + String::fromUTF8(line);
2703             source = source + &#39;\n&#39;;
2704             checkSyntax(vm, jscSource(source, sourceOrigin), error);
2705             if (!line[0]) {
2706                 free(line);
2707                 break;
2708             }
2709             add_history(line);
2710             free(line);
2711         } while (error.syntaxErrorType() == ParserError::SyntaxErrorRecoverable);
2712 
2713         if (error.isValid()) {
2714             printf(&quot;%s:%d\n&quot;, error.message().utf8().data(), error.line());
2715             continue;
2716         }
2717 
2718 
2719         NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">2720         JSValue returnValue = evaluate(globalObject-&gt;globalExec(), jscSource(source, sourceOrigin), JSValue(), evaluationException);</span>
2721 #else
2722         printf(&quot;%s&quot;, interactivePrompt);
2723         Vector&lt;char, 256&gt; line;
2724         int c;
2725         while ((c = getchar()) != EOF) {
2726             // FIXME: Should we also break on \r?
2727             if (c == &#39;\n&#39;)
2728                 break;
2729             line.append(c);
2730         }
2731         if (line.isEmpty())
2732             break;
2733 
2734         NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">2735         JSValue returnValue = evaluate(globalObject-&gt;globalExec(), jscSource(line, sourceOrigin, sourceOrigin.string()), JSValue(), evaluationException);</span>
2736 #endif
2737         if (evaluationException)
<span class="line-modified">2738             printf(&quot;Exception: %s\n&quot;, evaluationException-&gt;value().toWTFString(globalObject-&gt;globalExec()).utf8().data());</span>
2739         else
<span class="line-modified">2740             printf(&quot;%s\n&quot;, returnValue.toWTFString(globalObject-&gt;globalExec()).utf8().data());</span>
2741 
2742         scope.clearException();
2743         vm.drainMicrotasks();
2744     }
2745     printf(&quot;\n&quot;);
2746 }
2747 
2748 static NO_RETURN void printUsageStatement(bool help = false)
2749 {
2750     fprintf(stderr, &quot;Usage: jsc [options] [files] [-- arguments]\n&quot;);
2751     fprintf(stderr, &quot;  -d         Dumps bytecode (debug builds only)\n&quot;);
2752     fprintf(stderr, &quot;  -e         Evaluate argument as script code\n&quot;);
2753     fprintf(stderr, &quot;  -f         Specifies a source file (deprecated)\n&quot;);
2754     fprintf(stderr, &quot;  -h|--help  Prints this help message\n&quot;);
2755     fprintf(stderr, &quot;  -i         Enables interactive mode (default if no files are specified)\n&quot;);
2756     fprintf(stderr, &quot;  -m         Execute as a module\n&quot;);
2757 #if HAVE(SIGNAL_H)
2758     fprintf(stderr, &quot;  -s         Installs signal handlers that exit on a crash (Unix platforms only)\n&quot;);
2759 #endif
2760     fprintf(stderr, &quot;  -p &lt;file&gt;  Outputs profiling data to a file\n&quot;);
</pre>
<hr />
<pre>
2867 
2868         if (!strcmp(arg, &quot;--options&quot;)) {
2869             dumpOptionsLevel = JSC::Options::DumpLevel::Verbose;
2870             needToExit = true;
2871             continue;
2872         }
2873         if (!strcmp(arg, &quot;--dumpOptions&quot;)) {
2874             dumpOptionsLevel = JSC::Options::DumpLevel::Overridden;
2875             continue;
2876         }
2877         if (!strcmp(arg, &quot;--sample&quot;)) {
2878             JSC::Options::useSamplingProfiler() = true;
2879             JSC::Options::collectSamplingProfilerDataForJSCShell() = true;
2880             m_dumpSamplingProfilerData = true;
2881             continue;
2882         }
2883         if (!strcmp(arg, &quot;--destroy-vm&quot;)) {
2884             m_destroyVM = true;
2885             continue;
2886         }




2887 
2888         static const char* timeoutMultiplierOptStr = &quot;--timeoutMultiplier=&quot;;
2889         static const unsigned timeoutMultiplierOptStrLength = strlen(timeoutMultiplierOptStr);
2890         if (!strncmp(arg, timeoutMultiplierOptStr, timeoutMultiplierOptStrLength)) {
2891             const char* valueStr = &amp;arg[timeoutMultiplierOptStrLength];
2892             if (sscanf(valueStr, &quot;%lf&quot;, &amp;s_timeoutMultiplier) != 1)
2893                 dataLog(&quot;WARNING: --timeoutMultiplier=&quot;, valueStr, &quot; is invalid. Expects a numeric ratio.\n&quot;);
2894             continue;
2895         }
2896 
2897         if (!strcmp(arg, &quot;--test262-async&quot;)) {
2898             asyncTestExpectedPasses++;
2899             continue;
2900         }
2901 
2902         if (!strcmp(arg, &quot;--remote-debug&quot;)) {
2903             m_enableRemoteDebugging = true;
2904             continue;
2905         }
2906 
</pre>
<hr />
<pre>
2967             : &quot;All JSC runtime options:&quot;;
2968         JSC::Options::dumpAllOptions(stderr, dumpOptionsLevel, optionsTitle);
2969     }
2970     JSC::Options::ensureOptionsAreCoherent();
2971     if (needToExit)
2972         jscExit(EXIT_SUCCESS);
2973 }
2974 
2975 template&lt;typename Func&gt;
2976 int runJSC(const CommandLine&amp; options, bool isWorker, const Func&amp; func)
2977 {
2978     Worker worker(Workers::singleton());
2979 
2980     VM&amp; vm = VM::create(LargeHeap).leakRef();
2981     int result;
2982     bool success = true;
2983     GlobalObject* globalObject = nullptr;
2984     {
2985         JSLockHolder locker(vm);
2986 

2987         if (options.m_profile &amp;&amp; !vm.m_perBytecodeProfiler)
2988             vm.m_perBytecodeProfiler = makeUnique&lt;Profiler::Database&gt;(vm);
2989 
2990         globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), options.m_arguments);
2991         globalObject-&gt;setRemoteDebuggingEnabled(options.m_enableRemoteDebugging);
2992         func(vm, globalObject, success);
2993         vm.drainMicrotasks();
2994     }
<span class="line-modified">2995     vm.promiseDeferredTimer-&gt;runRunLoop();</span>
2996     {
2997         JSLockHolder locker(vm);
2998         if (options.m_interactive &amp;&amp; success)
2999             runInteractive(globalObject);
3000     }
3001 
3002     result = success &amp;&amp; (asyncTestExpectedPasses == asyncTestPasses) ? 0 : 3;
3003 
3004     if (options.m_exitCode) {
3005         printf(&quot;jsc exiting %d&quot;, result);
3006         if (asyncTestExpectedPasses != asyncTestPasses)
3007             printf(&quot; because expected: %d async test passes but got: %d async test passes&quot;, asyncTestExpectedPasses, asyncTestPasses);
3008         printf(&quot;\n&quot;);
3009     }
3010 
3011     if (options.m_profile) {
3012         JSLockHolder locker(vm);
3013         if (!vm.m_perBytecodeProfiler-&gt;save(options.m_profilerOutput.utf8().data()))
3014             fprintf(stderr, &quot;could not save profiler output.\n&quot;);
3015     }
</pre>
<hr />
<pre>
3019         JSLockHolder locker(vm);
3020         if (Options::useExceptionFuzz())
3021             printf(&quot;JSC EXCEPTION FUZZ: encountered %u checks.\n&quot;, numberOfExceptionFuzzChecks());
3022         bool fireAtEnabled =
3023         Options::fireExecutableAllocationFuzzAt() || Options::fireExecutableAllocationFuzzAtOrAfter();
3024         if (Options::useExecutableAllocationFuzz() &amp;&amp; (!fireAtEnabled || Options::verboseExecutableAllocationFuzz()))
3025             printf(&quot;JSC EXECUTABLE ALLOCATION FUZZ: encountered %u checks.\n&quot;, numberOfExecutableAllocationFuzzChecks());
3026         if (Options::useOSRExitFuzz()) {
3027             printf(&quot;JSC OSR EXIT FUZZ: encountered %u static checks.\n&quot;, numberOfStaticOSRExitFuzzChecks());
3028             printf(&quot;JSC OSR EXIT FUZZ: encountered %u dynamic checks.\n&quot;, numberOfOSRExitFuzzChecks());
3029         }
3030 
3031 
3032         auto compileTimeStats = JIT::compileTimeStats();
3033         Vector&lt;CString&gt; compileTimeKeys;
3034         for (auto&amp; entry : compileTimeStats)
3035             compileTimeKeys.append(entry.key);
3036         std::sort(compileTimeKeys.begin(), compileTimeKeys.end());
3037         for (const CString&amp; key : compileTimeKeys)
3038             printf(&quot;%40s: %.3lf ms\n&quot;, key.data(), compileTimeStats.get(key).milliseconds());



3039     }
3040 #endif
3041 
3042     if (Options::gcAtEnd()) {
3043         // We need to hold the API lock to do a GC.
3044         JSLockHolder locker(&amp;vm);
3045         vm.heap.collectNow(Sync, CollectionScope::Full);
3046     }
3047 
3048     if (options.m_dumpSamplingProfilerData) {
3049 #if ENABLE(SAMPLING_PROFILER)
3050         JSLockHolder locker(&amp;vm);
3051         vm.samplingProfiler()-&gt;reportTopFunctions();
3052         vm.samplingProfiler()-&gt;reportTopBytecodes();
3053 #else
3054         dataLog(&quot;Sampling profiler is not enabled on this platform\n&quot;);
3055 #endif
3056     }
3057 
3058     vm.codeCache()-&gt;write(vm);
3059 
3060     if (options.m_destroyVM || isWorker) {
3061         JSLockHolder locker(vm);
3062         // This is needed because we don&#39;t want the worker&#39;s main
3063         // thread to die before its compilation threads finish.
3064         vm.deref();
3065     }
3066 
3067     return result;
3068 }
3069 
3070 int jscmain(int argc, char** argv)
3071 {
3072     // Need to override and enable restricted options before we start parsing options below.
<span class="line-modified">3073     Options::enableRestrictedOptions(true);</span>
3074 
3075     WTF::initializeMainThread();
3076 
3077     // Note that the options parsing can affect VM creation, and thus
3078     // comes first.
3079     CommandLine options(argc, argv);
3080 
3081     processConfigFile(Options::configFile(), &quot;jsc&quot;);


3082 
3083     // Initialize JSC before getting VM.
3084     JSC::initializeThreading();
<span class="line-modified">3085     startTimeoutThreadIfNeeded();</span>
3086 #if ENABLE(WEBASSEMBLY)
3087     JSC::Wasm::enableFastMemory();
3088 #endif
<span class="line-modified">3089     Gigacage::disableDisablingPrimitiveGigacageIfShouldBeEnabled();</span>









3090 
3091 #if PLATFORM(COCOA)
3092     auto&amp; memoryPressureHandler = MemoryPressureHandler::singleton();
3093     {
3094         dispatch_queue_t queue = dispatch_queue_create(&quot;jsc shell memory pressure handler&quot;, DISPATCH_QUEUE_SERIAL);
3095         memoryPressureHandler.setDispatchQueue(queue);
3096         dispatch_release(queue);
3097     }
3098     Box&lt;Critical&gt; memoryPressureCriticalState = Box&lt;Critical&gt;::create(Critical::No);
3099     Box&lt;Synchronous&gt; memoryPressureSynchronousState = Box&lt;Synchronous&gt;::create(Synchronous::No);
3100     memoryPressureHandler.setLowMemoryHandler([=] (Critical critical, Synchronous synchronous) {
3101         // We set these racily with respect to reading them from the JS execution thread.
3102         *memoryPressureCriticalState = critical;
3103         *memoryPressureSynchronousState = synchronous;
3104     });
3105     memoryPressureHandler.setShouldLogMemoryMemoryPressureEvents(false);
3106     memoryPressureHandler.install();
3107 
3108     auto onEachMicrotaskTick = [&amp;] (VM&amp; vm) {
3109         if (*memoryPressureCriticalState == Critical::No)
</pre>
</td>
<td>
<hr />
<pre>
  10  *
  11  *  This library is distributed in the hope that it will be useful,
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 
  25 #include &quot;ArrayBuffer.h&quot;
  26 #include &quot;ArrayPrototype.h&quot;
  27 #include &quot;BuiltinNames.h&quot;
  28 #include &quot;ButterflyInlines.h&quot;
  29 #include &quot;BytecodeCacheError.h&quot;
<span class="line-added">  30 #include &quot;CallFrameInlines.h&quot;</span>
  31 #include &quot;CatchScope.h&quot;
  32 #include &quot;CodeBlock.h&quot;
  33 #include &quot;CodeCache.h&quot;
<span class="line-added">  34 #include &quot;CompilerTimingScope.h&quot;</span>
  35 #include &quot;Completion.h&quot;
  36 #include &quot;ConfigFile.h&quot;
  37 #include &quot;Disassembler.h&quot;
  38 #include &quot;Exception.h&quot;
  39 #include &quot;ExceptionHelpers.h&quot;
  40 #include &quot;HeapProfiler.h&quot;
  41 #include &quot;HeapSnapshotBuilder.h&quot;
  42 #include &quot;InitializeThreading.h&quot;
  43 #include &quot;Interpreter.h&quot;
  44 #include &quot;JIT.h&quot;
  45 #include &quot;JSArray.h&quot;
  46 #include &quot;JSArrayBuffer.h&quot;
  47 #include &quot;JSBigInt.h&quot;
  48 #include &quot;JSCInlines.h&quot;
  49 #include &quot;JSFunction.h&quot;
  50 #include &quot;JSInternalPromise.h&quot;

  51 #include &quot;JSLock.h&quot;
  52 #include &quot;JSModuleLoader.h&quot;
  53 #include &quot;JSNativeStdFunction.h&quot;
  54 #include &quot;JSONObject.h&quot;
<span class="line-added">  55 #include &quot;JSObjectInlines.h&quot;</span>
  56 #include &quot;JSSourceCode.h&quot;
  57 #include &quot;JSString.h&quot;
  58 #include &quot;JSTypedArrays.h&quot;
  59 #include &quot;JSWebAssemblyInstance.h&quot;
  60 #include &quot;JSWebAssemblyMemory.h&quot;
  61 #include &quot;LLIntThunks.h&quot;
  62 #include &quot;ObjectConstructor.h&quot;
  63 #include &quot;ParserError.h&quot;
  64 #include &quot;ProfilerDatabase.h&quot;
<span class="line-modified">  65 #include &quot;PromiseTimer.h&quot;</span>
  66 #include &quot;ProtoCallFrame.h&quot;
  67 #include &quot;ReleaseHeapAccessScope.h&quot;
  68 #include &quot;SamplingProfiler.h&quot;
  69 #include &quot;StackVisitor.h&quot;
  70 #include &quot;StructureInlines.h&quot;
  71 #include &quot;StructureRareDataInlines.h&quot;
  72 #include &quot;SuperSampler.h&quot;
  73 #include &quot;TestRunnerUtils.h&quot;
  74 #include &quot;TypedArrayInlines.h&quot;
<span class="line-added">  75 #include &quot;VMInspector.h&quot;</span>
  76 #include &quot;WasmCapabilities.h&quot;
  77 #include &quot;WasmContext.h&quot;
  78 #include &quot;WasmFaultSignalHandler.h&quot;
  79 #include &quot;WasmMemory.h&quot;
  80 #include &lt;locale.h&gt;
  81 #include &lt;math.h&gt;
  82 #include &lt;stdio.h&gt;
  83 #include &lt;stdlib.h&gt;
  84 #include &lt;string.h&gt;
  85 #include &lt;sys/stat.h&gt;
  86 #include &lt;sys/types.h&gt;
  87 #include &lt;thread&gt;
  88 #include &lt;type_traits&gt;
  89 #include &lt;wtf/Box.h&gt;
<span class="line-added">  90 #include &lt;wtf/CPUTime.h&gt;</span>
  91 #include &lt;wtf/CommaPrinter.h&gt;
  92 #include &lt;wtf/FileSystem.h&gt;
  93 #include &lt;wtf/MainThread.h&gt;
  94 #include &lt;wtf/MemoryPressureHandler.h&gt;
  95 #include &lt;wtf/MonotonicTime.h&gt;
  96 #include &lt;wtf/NeverDestroyed.h&gt;
  97 #include &lt;wtf/Scope.h&gt;
  98 #include &lt;wtf/StringPrintStream.h&gt;
  99 #include &lt;wtf/URL.h&gt;
 100 #include &lt;wtf/WallTime.h&gt;
 101 #include &lt;wtf/text/StringBuilder.h&gt;
 102 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 103 
 104 #if OS(WINDOWS)
 105 #include &lt;direct.h&gt;
 106 #include &lt;fcntl.h&gt;
 107 #include &lt;io.h&gt;
 108 #else
 109 #include &lt;unistd.h&gt;
 110 #endif
</pre>
<hr />
<pre>
 119 #define Function ReadlineFunction
 120 #include &lt;readline/history.h&gt;
 121 #include &lt;readline/readline.h&gt;
 122 #undef Function
 123 #endif
 124 
 125 #if HAVE(SYS_TIME_H)
 126 #include &lt;sys/time.h&gt;
 127 #endif
 128 
 129 #if HAVE(SIGNAL_H)
 130 #include &lt;signal.h&gt;
 131 #endif
 132 
 133 #if COMPILER(MSVC)
 134 #include &lt;crtdbg.h&gt;
 135 #include &lt;mmsystem.h&gt;
 136 #include &lt;windows.h&gt;
 137 #endif
 138 
<span class="line-modified"> 139 #if OS(DARWIN) &amp;&amp; CPU(ARM_THUMB2)</span>
 140 #include &lt;fenv.h&gt;
 141 #include &lt;arm/arch.h&gt;
 142 #endif
 143 
 144 #if OS(DARWIN)
 145 #include &lt;wtf/spi/darwin/ProcessMemoryFootprint.h&gt;
<span class="line-added"> 146 #elif OS(LINUX)</span>
<span class="line-added"> 147 #include &lt;wtf/linux/ProcessMemoryFootprint.h&gt;</span>
<span class="line-added"> 148 #endif</span>
<span class="line-added"> 149 </span>
<span class="line-added"> 150 #if OS(DARWIN) || OS(LINUX)</span>
 151 struct MemoryFootprint : ProcessMemoryFootprint {
 152     MemoryFootprint(const ProcessMemoryFootprint&amp; src)
 153         : ProcessMemoryFootprint(src)
 154     {
 155     }
 156 };
 157 #else
 158 struct MemoryFootprint {
 159     uint64_t current;
 160     uint64_t peak;
 161 
 162     static MemoryFootprint now()
 163     {
 164         return { 0L, 0L };
 165     }
 166 
 167     static void resetPeak()
 168     {
 169     }
 170 };
</pre>
<hr />
<pre>
 187         for (;;) {
 188 #if OS(WINDOWS)
 189             Sleep(1000);
 190 #else
 191             pause();
 192 #endif
 193         }
 194     }
 195 #endif // ENABLE(DFG_JIT)
 196     exit(status);
 197 }
 198 
 199 class Masquerader : public JSNonFinalObject {
 200 public:
 201     Masquerader(VM&amp; vm, Structure* structure)
 202         : Base(vm, structure)
 203     {
 204     }
 205 
 206     typedef JSNonFinalObject Base;
<span class="line-modified"> 207     static constexpr unsigned StructureFlags = Base::StructureFlags | JSC::MasqueradesAsUndefined;</span>
 208 
 209     static Masquerader* create(VM&amp; vm, JSGlobalObject* globalObject)
 210     {
 211         globalObject-&gt;masqueradesAsUndefinedWatchpoint()-&gt;fireAll(vm, &quot;Masquerading object allocated&quot;);
 212         Structure* structure = createStructure(vm, globalObject, jsNull());
 213         Masquerader* result = new (NotNull, allocateCell&lt;Masquerader&gt;(vm.heap)) Masquerader(vm, structure);
 214         result-&gt;finishCreation(vm);
 215         return result;
 216     }
 217 
 218     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 219     {
 220         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 221     }
 222 
 223     DECLARE_INFO;
 224 };
 225 
 226 const ClassInfo Masquerader::s_info = { &quot;Masquerader&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(Masquerader) };
 227 static unsigned asyncTestPasses { 0 };
 228 static unsigned asyncTestExpectedPasses { 0 };
 229 
 230 }
 231 
 232 template&lt;typename Vector&gt;
 233 static bool fillBufferWithContentsOfFile(const String&amp; fileName, Vector&amp; buffer);
 234 static RefPtr&lt;Uint8Array&gt; fillBufferWithContentsOfFile(const String&amp; fileName);
 235 
 236 class CommandLine;
 237 class GlobalObject;
 238 class Workers;
 239 
 240 template&lt;typename Func&gt;
 241 int runJSC(const CommandLine&amp;, bool isWorker, const Func&amp;);
<span class="line-modified"> 242 static void checkException(GlobalObject*, bool isLastFile, bool hasException, JSValue, CommandLine&amp;, bool&amp; success);</span>
 243 
 244 class Message : public ThreadSafeRefCounted&lt;Message&gt; {
 245 public:
 246     Message(ArrayBufferContents&amp;&amp;, int32_t);
 247     ~Message();
 248 
 249     ArrayBufferContents&amp;&amp; releaseContents() { return WTFMove(m_contents); }
 250     int32_t index() const { return m_index; }
 251 
 252 private:
 253     ArrayBufferContents m_contents;
 254     int32_t m_index { 0 };
 255 };
 256 
 257 class Worker : public BasicRawSentinelNode&lt;Worker&gt; {
 258 public:
 259     Worker(Workers&amp;);
 260     ~Worker();
 261 
 262     void enqueue(const AbstractLocker&amp;, RefPtr&lt;Message&gt;);
</pre>
<hr />
<pre>
 280 
 281     template&lt;typename Func&gt;
 282     void broadcast(const Func&amp;);
 283 
 284     void report(const String&amp;);
 285     String tryGetReport();
 286     String getReport();
 287 
 288     static Workers&amp; singleton();
 289 
 290 private:
 291     friend class Worker;
 292 
 293     Lock m_lock;
 294     Condition m_condition;
 295     SentinelLinkedList&lt;Worker, BasicRawSentinelNode&lt;Worker&gt;&gt; m_workers;
 296     Deque&lt;String&gt; m_reports;
 297 };
 298 
 299 
<span class="line-modified"> 300 static EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 301 </span>
<span class="line-modified"> 302 static EncodedJSValue JSC_HOST_CALL functionPrintStdOut(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 303 static EncodedJSValue JSC_HOST_CALL functionPrintStdErr(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 304 static EncodedJSValue JSC_HOST_CALL functionDebug(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 305 static EncodedJSValue JSC_HOST_CALL functionDescribe(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 306 static EncodedJSValue JSC_HOST_CALL functionDescribeArray(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 307 static EncodedJSValue JSC_HOST_CALL functionSleepSeconds(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 308 static EncodedJSValue JSC_HOST_CALL functionJSCStack(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 309 static EncodedJSValue JSC_HOST_CALL functionGCAndSweep(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 310 static EncodedJSValue JSC_HOST_CALL functionFullGC(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 311 static EncodedJSValue JSC_HOST_CALL functionEdenGC(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 312 static EncodedJSValue JSC_HOST_CALL functionHeapSize(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 313 static EncodedJSValue JSC_HOST_CALL functionCreateMemoryFootprint(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 314 static EncodedJSValue JSC_HOST_CALL functionResetMemoryPeak(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 315 static EncodedJSValue JSC_HOST_CALL functionAddressOf(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 316 static EncodedJSValue JSC_HOST_CALL functionVersion(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 317 static EncodedJSValue JSC_HOST_CALL functionRun(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 318 static EncodedJSValue JSC_HOST_CALL functionRunString(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 319 static EncodedJSValue JSC_HOST_CALL functionLoad(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 320 static EncodedJSValue JSC_HOST_CALL functionLoadString(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 321 static EncodedJSValue JSC_HOST_CALL functionReadFile(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 322 static EncodedJSValue JSC_HOST_CALL functionCheckSyntax(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 323 static EncodedJSValue JSC_HOST_CALL functionReadline(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 324 static EncodedJSValue JSC_HOST_CALL functionPreciseTime(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 325 static EncodedJSValue JSC_HOST_CALL functionNeverInlineFunction(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 326 static EncodedJSValue JSC_HOST_CALL functionNoDFG(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 327 static EncodedJSValue JSC_HOST_CALL functionNoFTL(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 328 static EncodedJSValue JSC_HOST_CALL functionNoOSRExitFuzzing(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 329 static EncodedJSValue JSC_HOST_CALL functionOptimizeNextInvocation(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 330 static EncodedJSValue JSC_HOST_CALL functionNumberOfDFGCompiles(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 331 static EncodedJSValue JSC_HOST_CALL functionCallerIsOMGCompiled(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 332 static EncodedJSValue JSC_HOST_CALL functionJSCOptions(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 333 static EncodedJSValue JSC_HOST_CALL functionReoptimizationRetryCount(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 334 static EncodedJSValue JSC_HOST_CALL functionTransferArrayBuffer(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 335 static EncodedJSValue JSC_HOST_CALL functionFailNextNewCodeBlock(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 336 static NO_RETURN_WITH_VALUE EncodedJSValue JSC_HOST_CALL functionQuit(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 337 static EncodedJSValue JSC_HOST_CALL functionFalse(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 338 static EncodedJSValue JSC_HOST_CALL functionUndefined1(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 339 static EncodedJSValue JSC_HOST_CALL functionUndefined2(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 340 static EncodedJSValue JSC_HOST_CALL functionIsInt32(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 341 static EncodedJSValue JSC_HOST_CALL functionIsPureNaN(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 342 static EncodedJSValue JSC_HOST_CALL functionEffectful42(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 343 static EncodedJSValue JSC_HOST_CALL functionIdentity(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 344 static EncodedJSValue JSC_HOST_CALL functionMakeMasquerader(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 345 static EncodedJSValue JSC_HOST_CALL functionHasCustomProperties(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 346 static EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 347 static EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 348 static EncodedJSValue JSC_HOST_CALL functionReleaseWeakRefs(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 349 static EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 350 static EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 351 static EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 352 static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 353 static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 354 static EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 355 static EncodedJSValue JSC_HOST_CALL functionEnsureArrayStorage(JSGlobalObject*, CallFrame*);</span>
 356 #if ENABLE(SAMPLING_PROFILER)
<span class="line-modified"> 357 static EncodedJSValue JSC_HOST_CALL functionStartSamplingProfiler(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 358 static EncodedJSValue JSC_HOST_CALL functionSamplingProfilerStackTraces(JSGlobalObject*, CallFrame*);</span>
 359 #endif
 360 
<span class="line-modified"> 361 static EncodedJSValue JSC_HOST_CALL functionMaxArguments(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 362 static EncodedJSValue JSC_HOST_CALL functionAsyncTestStart(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 363 static EncodedJSValue JSC_HOST_CALL functionAsyncTestPassed(JSGlobalObject*, CallFrame*);</span>
 364 
 365 #if ENABLE(WEBASSEMBLY)
<span class="line-modified"> 366 static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(JSGlobalObject*, CallFrame*);</span>
 367 #endif
 368 
 369 #if ENABLE(SAMPLING_FLAGS)
<span class="line-modified"> 370 static EncodedJSValue JSC_HOST_CALL functionSetSamplingFlags(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 371 static EncodedJSValue JSC_HOST_CALL functionClearSamplingFlags(JSGlobalObject*, CallFrame*);</span>
 372 #endif
 373 
<span class="line-modified"> 374 static EncodedJSValue JSC_HOST_CALL functionGetRandomSeed(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 375 static EncodedJSValue JSC_HOST_CALL functionSetRandomSeed(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 376 static EncodedJSValue JSC_HOST_CALL functionIsRope(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 377 static EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 378 static EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 379 static EncodedJSValue JSC_HOST_CALL functionDollarEvalScript(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 380 static EncodedJSValue JSC_HOST_CALL functionDollarAgentStart(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 381 static EncodedJSValue JSC_HOST_CALL functionDollarAgentReceiveBroadcast(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 382 static EncodedJSValue JSC_HOST_CALL functionDollarAgentReport(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 383 static EncodedJSValue JSC_HOST_CALL functionDollarAgentSleep(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 384 static EncodedJSValue JSC_HOST_CALL functionDollarAgentBroadcast(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 385 static EncodedJSValue JSC_HOST_CALL functionDollarAgentGetReport(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 386 static EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 387 static EncodedJSValue JSC_HOST_CALL functionDollarAgentMonotonicNow(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 388 static EncodedJSValue JSC_HOST_CALL functionWaitForReport(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 389 static EncodedJSValue JSC_HOST_CALL functionHeapCapacity(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 390 static EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 391 static EncodedJSValue JSC_HOST_CALL functionDisableRichSourceInfo(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 392 static EncodedJSValue JSC_HOST_CALL functionMallocInALoop(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 393 static EncodedJSValue JSC_HOST_CALL functionTotalCompileTime(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 394 </span>
<span class="line-modified"> 395 static EncodedJSValue JSC_HOST_CALL functionSetUnhandledRejectionCallback(JSGlobalObject*, CallFrame*);</span>

 396 
 397 struct Script {
 398     enum class StrictMode {
 399         Strict,
 400         Sloppy
 401     };
 402 
 403     enum class ScriptType {
 404         Script,
 405         Module
 406     };
 407 
 408     enum class CodeSource {
 409         File,
 410         CommandLine
 411     };
 412 
 413     StrictMode strictMode;
 414     CodeSource codeSource;
 415     ScriptType scriptType;
</pre>
<hr />
<pre>
 469 {
 470     m_startTime = MonotonicTime::now();
 471 }
 472 
 473 void StopWatch::stop()
 474 {
 475     m_stopTime = MonotonicTime::now();
 476 }
 477 
 478 long StopWatch::getElapsedMS()
 479 {
 480     return (m_stopTime - m_startTime).millisecondsAs&lt;long&gt;();
 481 }
 482 
 483 template&lt;typename Vector&gt;
 484 static inline String stringFromUTF(const Vector&amp; utf8)
 485 {
 486     return String::fromUTF8WithLatin1Fallback(utf8.data(), utf8.size());
 487 }
 488 
<span class="line-modified"> 489 class GlobalObject final : public JSGlobalObject {</span>
 490 private:
 491     GlobalObject(VM&amp;, Structure*);
 492 
 493 public:
 494     typedef JSGlobalObject Base;
 495 
 496     static GlobalObject* create(VM&amp; vm, Structure* structure, const Vector&lt;String&gt;&amp; arguments)
 497     {
 498         GlobalObject* object = new (NotNull, allocateCell&lt;GlobalObject&gt;(vm.heap)) GlobalObject(vm, structure);
 499         object-&gt;finishCreation(vm, arguments);
 500         return object;
 501     }
 502 


 503     DECLARE_INFO;
 504     static const GlobalObjectMethodTable s_globalObjectMethodTable;
 505 
 506     static Structure* createStructure(VM&amp; vm, JSValue prototype)
 507     {
 508         return Structure::create(vm, 0, prototype, TypeInfo(GlobalObjectType, StructureFlags), info());
 509     }
 510 
 511     static RuntimeFlags javaScriptRuntimeFlags(const JSGlobalObject*) { return RuntimeFlags::createAllEnabled(); }
 512 
 513 protected:
 514     void finishCreation(VM&amp; vm, const Vector&lt;String&gt;&amp; arguments)
 515     {
 516         Base::finishCreation(vm);
 517 
 518         addFunction(vm, &quot;debug&quot;, functionDebug, 1);
 519         addFunction(vm, &quot;describe&quot;, functionDescribe, 1);
 520         addFunction(vm, &quot;describeArray&quot;, functionDescribeArray, 1);
 521         addFunction(vm, &quot;print&quot;, functionPrintStdOut, 1);
 522         addFunction(vm, &quot;printErr&quot;, functionPrintStdErr, 1);
 523         addFunction(vm, &quot;quit&quot;, functionQuit, 0);
 524         addFunction(vm, &quot;gc&quot;, functionGCAndSweep, 0);
 525         addFunction(vm, &quot;fullGC&quot;, functionFullGC, 0);
 526         addFunction(vm, &quot;edenGC&quot;, functionEdenGC, 0);

 527         addFunction(vm, &quot;gcHeapSize&quot;, functionHeapSize, 0);
 528         addFunction(vm, &quot;MemoryFootprint&quot;, functionCreateMemoryFootprint, 0);
 529         addFunction(vm, &quot;resetMemoryPeak&quot;, functionResetMemoryPeak, 0);
 530         addFunction(vm, &quot;addressOf&quot;, functionAddressOf, 1);
 531         addFunction(vm, &quot;version&quot;, functionVersion, 1);
 532         addFunction(vm, &quot;run&quot;, functionRun, 1);
 533         addFunction(vm, &quot;runString&quot;, functionRunString, 1);
 534         addFunction(vm, &quot;load&quot;, functionLoad, 1);
 535         addFunction(vm, &quot;loadString&quot;, functionLoadString, 1);
 536         addFunction(vm, &quot;readFile&quot;, functionReadFile, 2);
 537         addFunction(vm, &quot;read&quot;, functionReadFile, 2);
 538         addFunction(vm, &quot;checkSyntax&quot;, functionCheckSyntax, 1);
 539         addFunction(vm, &quot;sleepSeconds&quot;, functionSleepSeconds, 1);
 540         addFunction(vm, &quot;jscStack&quot;, functionJSCStack, 1);
 541         addFunction(vm, &quot;readline&quot;, functionReadline, 0);
 542         addFunction(vm, &quot;preciseTime&quot;, functionPreciseTime, 0);
 543         addFunction(vm, &quot;neverInlineFunction&quot;, functionNeverInlineFunction, 1);
 544         addFunction(vm, &quot;noInline&quot;, functionNeverInlineFunction, 1);
 545         addFunction(vm, &quot;noDFG&quot;, functionNoDFG, 1);
 546         addFunction(vm, &quot;noFTL&quot;, functionNoFTL, 1);
 547         addFunction(vm, &quot;noOSRExitFuzzing&quot;, functionNoOSRExitFuzzing, 1);
 548         addFunction(vm, &quot;numberOfDFGCompiles&quot;, functionNumberOfDFGCompiles, 1);
<span class="line-added"> 549         addFunction(vm, &quot;callerIsOMGCompiled&quot;, functionCallerIsOMGCompiled, 0);</span>
 550         addFunction(vm, &quot;jscOptions&quot;, functionJSCOptions, 0);
 551         addFunction(vm, &quot;optimizeNextInvocation&quot;, functionOptimizeNextInvocation, 1);
 552         addFunction(vm, &quot;reoptimizationRetryCount&quot;, functionReoptimizationRetryCount, 1);
 553         addFunction(vm, &quot;transferArrayBuffer&quot;, functionTransferArrayBuffer, 1);
 554         addFunction(vm, &quot;failNextNewCodeBlock&quot;, functionFailNextNewCodeBlock, 1);
 555 #if ENABLE(SAMPLING_FLAGS)
 556         addFunction(vm, &quot;setSamplingFlags&quot;, functionSetSamplingFlags, 1);
 557         addFunction(vm, &quot;clearSamplingFlags&quot;, functionClearSamplingFlags, 1);
 558 #endif
 559 
 560         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;OSRExit&quot;), 0, functionUndefined1, OSRExitIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 561         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;isFinalTier&quot;), 0, functionFalse, IsFinalTierIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 562         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;predictInt32&quot;), 0, functionUndefined2, SetInt32HeapPredictionIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 563         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;isInt32&quot;), 0, functionIsInt32, CheckInt32Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 564         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;isPureNaN&quot;), 0, functionIsPureNaN, CheckInt32Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 565         putDirectNativeFunction(vm, this, Identifier::fromString(vm, &quot;fiatInt52&quot;), 0, functionIdentity, FiatInt52Intrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 566 
 567         addFunction(vm, &quot;effectful42&quot;, functionEffectful42, 0);
 568         addFunction(vm, &quot;makeMasquerader&quot;, functionMakeMasquerader, 0);
 569         addFunction(vm, &quot;hasCustomProperties&quot;, functionHasCustomProperties, 0);
</pre>
<hr />
<pre>
 587         addFunction(vm, &quot;platformSupportsSamplingProfiler&quot;, functionPlatformSupportsSamplingProfiler, 0);
 588         addFunction(vm, &quot;generateHeapSnapshot&quot;, functionGenerateHeapSnapshot, 0);
 589         addFunction(vm, &quot;generateHeapSnapshotForGCDebugging&quot;, functionGenerateHeapSnapshotForGCDebugging, 0);
 590         addFunction(vm, &quot;resetSuperSamplerState&quot;, functionResetSuperSamplerState, 0);
 591         addFunction(vm, &quot;ensureArrayStorage&quot;, functionEnsureArrayStorage, 0);
 592 #if ENABLE(SAMPLING_PROFILER)
 593         addFunction(vm, &quot;startSamplingProfiler&quot;, functionStartSamplingProfiler, 0);
 594         addFunction(vm, &quot;samplingProfilerStackTraces&quot;, functionSamplingProfilerStackTraces, 0);
 595 #endif
 596 
 597         addFunction(vm, &quot;maxArguments&quot;, functionMaxArguments, 0);
 598 
 599         addFunction(vm, &quot;asyncTestStart&quot;, functionAsyncTestStart, 1);
 600         addFunction(vm, &quot;asyncTestPassed&quot;, functionAsyncTestPassed, 1);
 601 
 602 #if ENABLE(WEBASSEMBLY)
 603         addFunction(vm, &quot;WebAssemblyMemoryMode&quot;, functionWebAssemblyMemoryMode, 1);
 604 #endif
 605 
 606         if (!arguments.isEmpty()) {
<span class="line-modified"> 607             JSArray* array = constructEmptyArray(this, 0);</span>
 608             for (size_t i = 0; i &lt; arguments.size(); ++i)
<span class="line-modified"> 609                 array-&gt;putDirectIndex(this, i, jsString(vm, arguments[i]));</span>
 610             putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);
 611         }
 612 
 613         putDirect(vm, Identifier::fromString(vm, &quot;console&quot;), jsUndefined());
 614 
 615         Structure* plainObjectStructure = JSFinalObject::createStructure(vm, this, objectPrototype(), 0);
 616 
 617         JSObject* dollar = JSFinalObject::create(vm, plainObjectStructure);
 618         putDirect(vm, Identifier::fromString(vm, &quot;$&quot;), dollar);
 619         putDirect(vm, Identifier::fromString(vm, &quot;$262&quot;), dollar);
 620 
 621         addFunction(vm, dollar, &quot;createRealm&quot;, functionDollarCreateRealm, 0);
<span class="line-modified"> 622         addFunction(vm, dollar, &quot;detachArrayBuffer&quot;, functionTransferArrayBuffer, 1);</span>
 623         addFunction(vm, dollar, &quot;evalScript&quot;, functionDollarEvalScript, 1);
 624 
 625         dollar-&gt;putDirect(vm, Identifier::fromString(vm, &quot;global&quot;), this);
 626 
 627         JSObject* agent = JSFinalObject::create(vm, plainObjectStructure);
 628         dollar-&gt;putDirect(vm, Identifier::fromString(vm, &quot;agent&quot;), agent);
 629 
 630         // The test262 INTERPRETING.md document says that some of these functions are just in the main
 631         // thread and some are in the other threads. We just put them in all threads.
 632         addFunction(vm, agent, &quot;start&quot;, functionDollarAgentStart, 1);
 633         addFunction(vm, agent, &quot;receiveBroadcast&quot;, functionDollarAgentReceiveBroadcast, 1);
 634         addFunction(vm, agent, &quot;report&quot;, functionDollarAgentReport, 1);
 635         addFunction(vm, agent, &quot;sleep&quot;, functionDollarAgentSleep, 1);
 636         addFunction(vm, agent, &quot;broadcast&quot;, functionDollarAgentBroadcast, 1);
 637         addFunction(vm, agent, &quot;getReport&quot;, functionDollarAgentGetReport, 0);
 638         addFunction(vm, agent, &quot;leaving&quot;, functionDollarAgentLeaving, 0);
 639         addFunction(vm, agent, &quot;monotonicNow&quot;, functionDollarAgentMonotonicNow, 0);
 640 
 641         addFunction(vm, &quot;waitForReport&quot;, functionWaitForReport, 0);
 642 
</pre>
<hr />
<pre>
 644         addFunction(vm, &quot;flashHeapAccess&quot;, functionFlashHeapAccess, 0);
 645 
 646         addFunction(vm, &quot;disableRichSourceInfo&quot;, functionDisableRichSourceInfo, 0);
 647         addFunction(vm, &quot;mallocInALoop&quot;, functionMallocInALoop, 0);
 648         addFunction(vm, &quot;totalCompileTime&quot;, functionTotalCompileTime, 0);
 649 
 650         addFunction(vm, &quot;setUnhandledRejectionCallback&quot;, functionSetUnhandledRejectionCallback, 1);
 651     }
 652 
 653     void addFunction(VM&amp; vm, JSObject* object, const char* name, NativeFunction function, unsigned arguments)
 654     {
 655         Identifier identifier = Identifier::fromString(vm, name);
 656         object-&gt;putDirect(vm, identifier, JSFunction::create(vm, this, arguments, identifier.string(), function));
 657     }
 658 
 659     void addFunction(VM&amp; vm, const char* name, NativeFunction function, unsigned arguments)
 660     {
 661         addFunction(vm, this, name, function, arguments);
 662     }
 663 
<span class="line-modified"> 664     static JSInternalPromise* moduleLoaderImportModule(JSGlobalObject*, JSModuleLoader*, JSString*, JSValue, const SourceOrigin&amp;);</span>
<span class="line-modified"> 665     static Identifier moduleLoaderResolve(JSGlobalObject*, JSModuleLoader*, JSValue, JSValue, JSValue);</span>
<span class="line-modified"> 666     static JSInternalPromise* moduleLoaderFetch(JSGlobalObject*, JSModuleLoader*, JSValue, JSValue, JSValue);</span>
<span class="line-modified"> 667     static JSObject* moduleLoaderCreateImportMetaProperties(JSGlobalObject*, JSModuleLoader*, JSValue, JSModuleRecord*, JSValue);</span>
 668 };
<span class="line-added"> 669 STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(GlobalObject, JSGlobalObject);</span>
 670 
 671 static bool supportsRichSourceInfo = true;
 672 static bool shellSupportsRichSourceInfo(const JSGlobalObject*)
 673 {
 674     return supportsRichSourceInfo;
 675 }
 676 
 677 const ClassInfo GlobalObject::s_info = { &quot;global&quot;, &amp;JSGlobalObject::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(GlobalObject) };
 678 const GlobalObjectMethodTable GlobalObject::s_globalObjectMethodTable = {
 679     &amp;shellSupportsRichSourceInfo,
 680     &amp;shouldInterruptScript,
 681     &amp;javaScriptRuntimeFlags,
 682     nullptr, // queueTaskToEventLoop
 683     &amp;shouldInterruptScriptBeforeTimeout,
 684     &amp;moduleLoaderImportModule,
 685     &amp;moduleLoaderResolve,
 686     &amp;moduleLoaderFetch,
 687     &amp;moduleLoaderCreateImportMetaProperties,
 688     nullptr, // moduleLoaderEvaluate
 689     nullptr, // promiseRejectionTracker
</pre>
<hr />
<pre>
 806     }
 807 
 808     StringBuilder builder;
 809     builder.append(directoryName.rootName);
 810     for (size_t i = 0; i &lt; directoryPieces.size(); ++i) {
 811         builder.append(directoryPieces[i]);
 812         if (i + 1 != directoryPieces.size())
 813             builder.append(pathSeparator());
 814     }
 815     return builder.toString();
 816 }
 817 
 818 static String absolutePath(const String&amp; fileName)
 819 {
 820     auto directoryName = currentWorkingDirectory();
 821     if (!directoryName)
 822         return fileName;
 823     return resolvePath(directoryName.value(), ModuleName(fileName.impl()));
 824 }
 825 
<span class="line-modified"> 826 JSInternalPromise* GlobalObject::moduleLoaderImportModule(JSGlobalObject* globalObject, JSModuleLoader*, JSString* moduleNameValue, JSValue parameters, const SourceOrigin&amp; sourceOrigin)</span>
 827 {
 828     VM&amp; vm = globalObject-&gt;vm();
 829     auto throwScope = DECLARE_THROW_SCOPE(vm);
 830 
<span class="line-modified"> 831     auto* promise = JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());</span>

 832 
 833     auto catchScope = DECLARE_CATCH_SCOPE(vm);
 834     auto reject = [&amp;] (JSValue rejectionReason) {
 835         catchScope.clearException();
<span class="line-modified"> 836         promise-&gt;reject(globalObject, rejectionReason);</span>
 837         catchScope.clearException();
<span class="line-modified"> 838         return promise;</span>
 839     };
 840 
 841     if (sourceOrigin.isNull())
<span class="line-modified"> 842         return reject(createError(globalObject, &quot;Could not resolve the module specifier.&quot;_s));</span>
 843 
<span class="line-modified"> 844     auto referrer = sourceOrigin.string();</span>
<span class="line-modified"> 845     auto moduleName = moduleNameValue-&gt;value(globalObject);</span>
<span class="line-added"> 846     RETURN_IF_EXCEPTION(throwScope, nullptr);</span>
 847     if (UNLIKELY(catchScope.exception()))
 848         return reject(catchScope.exception());
 849 
 850     auto directoryName = extractDirectoryName(referrer.impl());
 851     if (!directoryName)
<span class="line-modified"> 852         return reject(createError(globalObject, makeString(&quot;Could not resolve the referrer name &#39;&quot;, String(referrer.impl()), &quot;&#39;.&quot;)));</span>
 853 
<span class="line-modified"> 854     auto result = JSC::importModule(globalObject, Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(moduleName))), parameters, jsUndefined());</span>
 855     if (UNLIKELY(catchScope.exception()))
 856         return reject(catchScope.exception());
 857     return result;
 858 }
 859 
<span class="line-modified"> 860 Identifier GlobalObject::moduleLoaderResolve(JSGlobalObject* globalObject, JSModuleLoader*, JSValue keyValue, JSValue referrerValue, JSValue)</span>
 861 {
 862     VM&amp; vm = globalObject-&gt;vm();
 863     auto scope = DECLARE_THROW_SCOPE(vm);
 864 
 865     scope.releaseAssertNoException();
<span class="line-modified"> 866     const Identifier key = keyValue.toPropertyKey(globalObject);</span>
 867     RETURN_IF_EXCEPTION(scope, { });
 868 
 869     if (key.isSymbol())
 870         return key;
 871 
 872     if (referrerValue.isUndefined()) {
 873         auto directoryName = currentWorkingDirectory();
 874         if (!directoryName) {
<span class="line-modified"> 875             throwException(globalObject, scope, createError(globalObject, &quot;Could not resolve the current working directory.&quot;_s));</span>
 876             return { };
 877         }
 878         return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));
 879     }
 880 
<span class="line-modified"> 881     const Identifier referrer = referrerValue.toPropertyKey(globalObject);</span>
 882     RETURN_IF_EXCEPTION(scope, { });
 883 
 884     if (referrer.isSymbol()) {
 885         auto directoryName = currentWorkingDirectory();
 886         if (!directoryName) {
<span class="line-modified"> 887             throwException(globalObject, scope, createError(globalObject, &quot;Could not resolve the current working directory.&quot;_s));</span>
 888             return { };
 889         }
 890         return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));
 891     }
 892 
 893     // If the referrer exists, we assume that the referrer is the correct absolute path.
 894     auto directoryName = extractDirectoryName(referrer.impl());
 895     if (!directoryName) {
<span class="line-modified"> 896         throwException(globalObject, scope, createError(globalObject, makeString(&quot;Could not resolve the referrer name &#39;&quot;, String(referrer.impl()), &quot;&#39;.&quot;)));</span>
 897         return { };
 898     }
 899     return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));
 900 }
 901 
 902 template&lt;typename Vector&gt;
 903 static void convertShebangToJSComment(Vector&amp; buffer)
 904 {
 905     if (buffer.size() &gt;= 2) {
 906         if (buffer[0] == &#39;#&#39; &amp;&amp; buffer[1] == &#39;!&#39;)
 907             buffer[0] = buffer[1] = &#39;/&#39;;
 908     }
 909 }
 910 
 911 static RefPtr&lt;Uint8Array&gt; fillBufferWithContentsOfFile(FILE* file)
 912 {
 913     if (fseek(file, 0, SEEK_END) == -1)
 914         return nullptr;
 915     long bufferCapacity = ftell(file);
 916     if (bufferCapacity == -1)
</pre>
<hr />
<pre>
1142     if (stat(pathName.data(), &amp;status))
1143         return false;
1144     if ((status.st_mode &amp; S_IFMT) != S_IFREG)
1145         return false;
1146 
1147     FILE* f = fopen(pathName.data(), &quot;r&quot;);
1148 #endif
1149     if (!f) {
1150         fprintf(stderr, &quot;Could not open file: %s\n&quot;, fileName.utf8().data());
1151         return false;
1152     }
1153 
1154     bool result = fillBufferWithContentsOfFile(f, buffer);
1155     if (result)
1156         convertShebangToJSComment(buffer);
1157     fclose(f);
1158 
1159     return result;
1160 }
1161 
<span class="line-modified">1162 JSInternalPromise* GlobalObject::moduleLoaderFetch(JSGlobalObject* globalObject, JSModuleLoader*, JSValue key, JSValue, JSValue)</span>
1163 {
1164     VM&amp; vm = globalObject-&gt;vm();
<span class="line-modified">1165     JSInternalPromise* promise = JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());</span>


1166 
1167     auto catchScope = DECLARE_CATCH_SCOPE(vm);
1168     auto reject = [&amp;] (JSValue rejectionReason) {
1169         catchScope.clearException();
<span class="line-modified">1170         promise-&gt;reject(globalObject, rejectionReason);</span>
1171         catchScope.clearException();
<span class="line-modified">1172         return promise;</span>
1173     };
1174 
<span class="line-modified">1175     String moduleKey = key.toWTFString(globalObject);</span>
1176     if (UNLIKELY(catchScope.exception()))
1177         return reject(catchScope.exception());
1178 
1179     // Here, now we consider moduleKey as the fileName.
1180     Vector&lt;uint8_t&gt; buffer;
1181     if (!fetchModuleFromLocalFileSystem(moduleKey, buffer))
<span class="line-modified">1182         return reject(createError(globalObject, makeString(&quot;Could not open file &#39;&quot;, moduleKey, &quot;&#39;.&quot;)));</span>
1183 
1184 
1185     URL moduleURL = URL({ }, moduleKey);
1186 #if ENABLE(WEBASSEMBLY)
1187     // FileSystem does not have mime-type header. The JSC shell recognizes WebAssembly&#39;s magic header.
1188     if (buffer.size() &gt;= 4) {
1189         if (buffer[0] == &#39;\0&#39; &amp;&amp; buffer[1] == &#39;a&#39; &amp;&amp; buffer[2] == &#39;s&#39; &amp;&amp; buffer[3] == &#39;m&#39;) {
1190             auto source = SourceCode(WebAssemblySourceProvider::create(WTFMove(buffer), SourceOrigin { moduleKey }, WTFMove(moduleURL)));
1191             catchScope.releaseAssertNoException();
1192             auto sourceCode = JSSourceCode::create(vm, WTFMove(source));
1193             catchScope.releaseAssertNoException();
<span class="line-modified">1194             promise-&gt;resolve(globalObject, sourceCode);</span>
1195             catchScope.clearException();
<span class="line-modified">1196             return promise;</span>
1197         }
1198     }
1199 #endif
1200 
1201     auto sourceCode = JSSourceCode::create(vm, jscSource(stringFromUTF(buffer), SourceOrigin { moduleKey }, WTFMove(moduleURL), TextPosition(), SourceProviderSourceType::Module));
1202     catchScope.releaseAssertNoException();
<span class="line-modified">1203     promise-&gt;resolve(globalObject, sourceCode);</span>
1204     catchScope.clearException();
<span class="line-modified">1205     return promise;</span>
1206 }
1207 
<span class="line-modified">1208 JSObject* GlobalObject::moduleLoaderCreateImportMetaProperties(JSGlobalObject* globalObject, JSModuleLoader*, JSValue key, JSModuleRecord*, JSValue)</span>
1209 {
<span class="line-modified">1210     VM&amp; vm = globalObject-&gt;vm();</span>
1211     auto scope = DECLARE_THROW_SCOPE(vm);
1212 
<span class="line-modified">1213     JSObject* metaProperties = constructEmptyObject(vm, globalObject-&gt;nullPrototypeObjectStructure());</span>
1214     RETURN_IF_EXCEPTION(scope, nullptr);
1215 
1216     metaProperties-&gt;putDirect(vm, Identifier::fromString(vm, &quot;filename&quot;), key);
1217     RETURN_IF_EXCEPTION(scope, nullptr);
1218 
1219     return metaProperties;
1220 }
1221 
<span class="line-modified">1222 static CString cStringFromViewWithString(JSGlobalObject* globalObject, ThrowScope&amp; scope, StringViewWithUnderlyingString&amp; viewWithString)</span>
1223 {
1224     Expected&lt;CString, UTF8ConversionError&gt; expectedString = viewWithString.view.tryGetUtf8();
1225     if (expectedString)
1226         return expectedString.value();
1227     switch (expectedString.error()) {
1228     case UTF8ConversionError::OutOfMemory:
<span class="line-modified">1229         throwOutOfMemoryError(globalObject, scope);</span>
1230         break;
1231     case UTF8ConversionError::IllegalSource:
<span class="line-modified">1232         scope.throwException(globalObject, createError(globalObject, &quot;Illegal source encountered during UTF8 conversion&quot;));</span>
1233         break;
1234     case UTF8ConversionError::SourceExhausted:
<span class="line-modified">1235         scope.throwException(globalObject, createError(globalObject, &quot;Source exhausted during UTF8 conversion&quot;));</span>
1236         break;
1237     default:
1238         RELEASE_ASSERT_NOT_REACHED();
1239     }
1240     return { };
1241 }
1242 
<span class="line-modified">1243 static EncodedJSValue printInternal(JSGlobalObject* globalObject, CallFrame* callFrame, FILE* out)</span>
1244 {
<span class="line-modified">1245     VM&amp; vm = globalObject-&gt;vm();</span>
1246     auto scope = DECLARE_THROW_SCOPE(vm);
1247 
1248     if (asyncTestExpectedPasses) {
<span class="line-modified">1249         JSValue value = callFrame-&gt;argument(0);</span>
<span class="line-modified">1250         if (value.isString() &amp;&amp; WTF::equal(asString(value)-&gt;value(globalObject).impl(), &quot;Test262:AsyncTestComplete&quot;)) {</span>
1251             asyncTestPasses++;
1252             return JSValue::encode(jsUndefined());
1253         }
1254     }
1255 
<span class="line-modified">1256     for (unsigned i = 0; i &lt; callFrame-&gt;argumentCount(); ++i) {</span>
1257         if (i)
1258             if (EOF == fputc(&#39; &#39;, out))
1259                 goto fail;
1260 
<span class="line-modified">1261         auto viewWithString = callFrame-&gt;uncheckedArgument(i).toString(globalObject)-&gt;viewWithUnderlyingString(globalObject);</span>
1262         RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1263         auto string = cStringFromViewWithString(globalObject, scope, viewWithString);</span>
1264         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1265         if (fprintf(out, &quot;%s&quot;, string.data()) &lt; 0)
1266             goto fail;
1267     }
1268 
1269     fputc(&#39;\n&#39;, out);
1270 fail:
1271     fflush(out);
1272     return JSValue::encode(jsUndefined());
1273 }
1274 
<span class="line-modified">1275 EncodedJSValue JSC_HOST_CALL functionPrintStdOut(JSGlobalObject* globalObject, CallFrame* callFrame) { return printInternal(globalObject, callFrame, stdout); }</span>
<span class="line-modified">1276 EncodedJSValue JSC_HOST_CALL functionPrintStdErr(JSGlobalObject* globalObject, CallFrame* callFrame) { return printInternal(globalObject, callFrame, stderr); }</span>
1277 
<span class="line-modified">1278 EncodedJSValue JSC_HOST_CALL functionDebug(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1279 {
<span class="line-modified">1280     VM&amp; vm = globalObject-&gt;vm();</span>
1281     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">1282     auto viewWithString = callFrame-&gt;argument(0).toString(globalObject)-&gt;viewWithUnderlyingString(globalObject);</span>
1283     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1284     auto string = cStringFromViewWithString(globalObject, scope, viewWithString);</span>
1285     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1286     fprintf(stderr, &quot;--&gt; %s\n&quot;, string.data());
1287     return JSValue::encode(jsUndefined());
1288 }
1289 
<span class="line-modified">1290 EncodedJSValue JSC_HOST_CALL functionDescribe(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1291 {
<span class="line-modified">1292     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1293     if (callFrame-&gt;argumentCount() &lt; 1)</span>
1294         return JSValue::encode(jsUndefined());
<span class="line-modified">1295     return JSValue::encode(jsString(vm, toString(callFrame-&gt;argument(0))));</span>
1296 }
1297 
<span class="line-modified">1298 EncodedJSValue JSC_HOST_CALL functionDescribeArray(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1299 {
<span class="line-modified">1300     if (callFrame-&gt;argumentCount() &lt; 1)</span>
1301         return JSValue::encode(jsUndefined());
<span class="line-modified">1302     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">1303     JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, callFrame-&gt;argument(0));</span>
1304     if (!object)
1305         return JSValue::encode(jsNontrivialString(vm, &quot;&lt;not object&gt;&quot;_s));
1306     return JSValue::encode(jsNontrivialString(vm, toString(&quot;&lt;Butterfly: &quot;, RawPointer(object-&gt;butterfly()), &quot;; public length: &quot;, object-&gt;getArrayLength(), &quot;; vector length: &quot;, object-&gt;getVectorLength(), &quot;&gt;&quot;)));
1307 }
1308 
<span class="line-modified">1309 EncodedJSValue JSC_HOST_CALL functionSleepSeconds(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1310 {
<span class="line-modified">1311     VM&amp; vm = globalObject-&gt;vm();</span>
1312     auto scope = DECLARE_THROW_SCOPE(vm);
1313 
<span class="line-modified">1314     if (callFrame-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">1315         Seconds seconds = Seconds(callFrame-&gt;argument(0).toNumber(globalObject));</span>
1316         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1317         sleep(seconds);
1318     }
1319 
1320     return JSValue::encode(jsUndefined());
1321 }
1322 
1323 class FunctionJSCStackFunctor {
1324 public:
1325     FunctionJSCStackFunctor(StringBuilder&amp; trace)
1326         : m_trace(trace)
1327     {
1328     }
1329 
1330     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
1331     {
1332         m_trace.append(makeString(&quot;    &quot;, visitor-&gt;index(), &quot;   &quot;, visitor-&gt;toString(), &#39;\n&#39;));
1333         return StackVisitor::Continue;
1334     }
1335 
1336 private:
1337     StringBuilder&amp; m_trace;
1338 };
1339 
<span class="line-modified">1340 EncodedJSValue JSC_HOST_CALL functionJSCStack(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1341 {
<span class="line-added">1342     VM&amp; vm = globalObject-&gt;vm();</span>
1343     StringBuilder trace;
1344     trace.appendLiteral(&quot;--&gt; Stack trace:\n&quot;);
1345 
1346     FunctionJSCStackFunctor functor(trace);
<span class="line-modified">1347     callFrame-&gt;iterate(vm, functor);</span>
1348     fprintf(stderr, &quot;%s&quot;, trace.toString().utf8().data());
1349     return JSValue::encode(jsUndefined());
1350 }
1351 
<span class="line-modified">1352 EncodedJSValue JSC_HOST_CALL functionGCAndSweep(JSGlobalObject* globalObject, CallFrame*)</span>
1353 {
<span class="line-modified">1354     VM&amp; vm = globalObject-&gt;vm();</span>
1355     JSLockHolder lock(vm);
1356     vm.heap.collectNow(Sync, CollectionScope::Full);
1357     return JSValue::encode(jsNumber(vm.heap.sizeAfterLastFullCollection()));
1358 }
1359 
<span class="line-modified">1360 EncodedJSValue JSC_HOST_CALL functionFullGC(JSGlobalObject* globalObject, CallFrame*)</span>
1361 {
<span class="line-modified">1362     VM&amp; vm = globalObject-&gt;vm();</span>
1363     JSLockHolder lock(vm);
1364     vm.heap.collectSync(CollectionScope::Full);
1365     return JSValue::encode(jsNumber(vm.heap.sizeAfterLastFullCollection()));
1366 }
1367 
<span class="line-modified">1368 EncodedJSValue JSC_HOST_CALL functionEdenGC(JSGlobalObject* globalObject, CallFrame*)</span>
1369 {
<span class="line-modified">1370     VM&amp; vm = globalObject-&gt;vm();</span>
1371     JSLockHolder lock(vm);
1372     vm.heap.collectSync(CollectionScope::Eden);
1373     return JSValue::encode(jsNumber(vm.heap.sizeAfterLastEdenCollection()));
1374 }
1375 
<span class="line-modified">1376 EncodedJSValue JSC_HOST_CALL functionHeapSize(JSGlobalObject* globalObject, CallFrame*)</span>
1377 {
<span class="line-modified">1378     VM&amp; vm = globalObject-&gt;vm();</span>








1379     JSLockHolder lock(vm);
1380     return JSValue::encode(jsNumber(vm.heap.size()));
1381 }
1382 
1383 class JSCMemoryFootprint : public JSDestructibleObject {
1384     using Base = JSDestructibleObject;
1385 public:
1386     JSCMemoryFootprint(VM&amp; vm, Structure* structure)
1387         : Base(vm, structure)
1388     { }
1389 
1390     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
1391     {
1392         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
1393     }
1394 
1395     static JSCMemoryFootprint* create(VM&amp; vm, JSGlobalObject* globalObject)
1396     {
1397         Structure* structure = createStructure(vm, globalObject, jsNull());
1398         JSCMemoryFootprint* footprint = new (NotNull, allocateCell&lt;JSCMemoryFootprint&gt;(vm.heap)) JSCMemoryFootprint(vm, structure);
</pre>
<hr />
<pre>
1409         };
1410 
1411         MemoryFootprint footprint = MemoryFootprint::now();
1412 
1413         addProperty(vm, &quot;current&quot;, jsNumber(footprint.current));
1414         addProperty(vm, &quot;peak&quot;, jsNumber(footprint.peak));
1415     }
1416 
1417     DECLARE_INFO;
1418 
1419 private:
1420     void addProperty(VM&amp; vm, const char* name, JSValue value)
1421     {
1422         Identifier identifier = Identifier::fromString(vm, name);
1423         putDirect(vm, identifier, value);
1424     }
1425 };
1426 
1427 const ClassInfo JSCMemoryFootprint::s_info = { &quot;MemoryFootprint&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSCMemoryFootprint) };
1428 
<span class="line-modified">1429 EncodedJSValue JSC_HOST_CALL functionCreateMemoryFootprint(JSGlobalObject* globalObject, CallFrame*)</span>
1430 {
<span class="line-modified">1431     VM&amp; vm = globalObject-&gt;vm();</span>
1432     JSLockHolder lock(vm);
<span class="line-modified">1433     return JSValue::encode(JSCMemoryFootprint::create(vm, globalObject));</span>
1434 }
1435 
<span class="line-modified">1436 EncodedJSValue JSC_HOST_CALL functionResetMemoryPeak(JSGlobalObject*, CallFrame*)</span>
1437 {
1438     MemoryFootprint::resetPeak();
1439     return JSValue::encode(jsUndefined());
1440 }
1441 
1442 // This function is not generally very helpful in 64-bit code as the tag and payload
1443 // share a register. But in 32-bit JITed code the tag may not be checked if an
1444 // optimization removes type checking requirements, such as in ===.
<span class="line-modified">1445 EncodedJSValue JSC_HOST_CALL functionAddressOf(JSGlobalObject*, CallFrame* callFrame)</span>
1446 {
<span class="line-modified">1447     JSValue value = callFrame-&gt;argument(0);</span>
1448     if (!value.isCell())
1449         return JSValue::encode(jsUndefined());
1450     // Need to cast to uint64_t so bitwise_cast will play along.
1451     uint64_t asNumber = reinterpret_cast&lt;uint64_t&gt;(value.asCell());
1452     EncodedJSValue returnValue = JSValue::encode(jsNumber(bitwise_cast&lt;double&gt;(asNumber)));
1453     return returnValue;
1454 }
1455 
<span class="line-modified">1456 EncodedJSValue JSC_HOST_CALL functionVersion(JSGlobalObject*, CallFrame*)</span>
1457 {
1458     // We need this function for compatibility with the Mozilla JS tests but for now
1459     // we don&#39;t actually do any version-specific handling
1460     return JSValue::encode(jsUndefined());
1461 }
1462 
<span class="line-modified">1463 EncodedJSValue JSC_HOST_CALL functionRun(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1464 {
<span class="line-modified">1465     VM&amp; vm = globalObject-&gt;vm();</span>
1466     auto scope = DECLARE_THROW_SCOPE(vm);
1467 
<span class="line-modified">1468     String fileName = callFrame-&gt;argument(0).toWTFString(globalObject);</span>
1469     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1470     Vector&lt;char&gt; script;
1471     if (!fetchScriptFromLocalFileSystem(fileName, script))
<span class="line-modified">1472         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Could not open file.&quot;_s)));</span>
1473 
<span class="line-modified">1474     GlobalObject* realm = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());</span>
1475 
<span class="line-modified">1476     JSArray* array = constructEmptyArray(realm, 0);</span>
1477     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1478     for (unsigned i = 1; i &lt; callFrame-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">1479         array-&gt;putDirectIndex(realm, i - 1, callFrame-&gt;uncheckedArgument(i));</span>
1480         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1481     }
<span class="line-modified">1482     realm-&gt;putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);</span>
1483 
1484     NakedPtr&lt;Exception&gt; exception;
1485     StopWatch stopWatch;
1486     stopWatch.start();
<span class="line-modified">1487     evaluate(realm, jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), exception);</span>
1488     stopWatch.stop();
1489 
1490     if (exception) {
<span class="line-modified">1491         throwException(realm, scope, exception);</span>
1492         return JSValue::encode(jsUndefined());
1493     }
1494 
1495     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
1496 }
1497 
<span class="line-modified">1498 EncodedJSValue JSC_HOST_CALL functionRunString(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1499 {
<span class="line-modified">1500     VM&amp; vm = globalObject-&gt;vm();</span>
1501     auto scope = DECLARE_THROW_SCOPE(vm);
1502 
<span class="line-modified">1503     String source = callFrame-&gt;argument(0).toWTFString(globalObject);</span>
1504     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1505 
<span class="line-modified">1506     GlobalObject* realm = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());</span>
1507 
<span class="line-modified">1508     JSArray* array = constructEmptyArray(realm, 0);</span>
1509     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1510     for (unsigned i = 1; i &lt; callFrame-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">1511         array-&gt;putDirectIndex(realm, i - 1, callFrame-&gt;uncheckedArgument(i));</span>
1512         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1513     }
<span class="line-modified">1514     realm-&gt;putDirect(vm, Identifier::fromString(vm, &quot;arguments&quot;), array);</span>
1515 
1516     NakedPtr&lt;Exception&gt; exception;
<span class="line-modified">1517     evaluate(realm, jscSource(source, callFrame-&gt;callerSourceOrigin(vm)), JSValue(), exception);</span>
1518 
1519     if (exception) {
<span class="line-modified">1520         scope.throwException(realm, exception);</span>
1521         return JSValue::encode(jsUndefined());
1522     }
1523 
<span class="line-modified">1524     return JSValue::encode(realm);</span>
1525 }
1526 
<span class="line-modified">1527 EncodedJSValue JSC_HOST_CALL functionLoad(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1528 {
<span class="line-modified">1529     VM&amp; vm = globalObject-&gt;vm();</span>
1530     auto scope = DECLARE_THROW_SCOPE(vm);
1531 
<span class="line-modified">1532     String fileName = callFrame-&gt;argument(0).toWTFString(globalObject);</span>
1533     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1534     Vector&lt;char&gt; script;
1535     if (!fetchScriptFromLocalFileSystem(fileName, script))
<span class="line-modified">1536         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Could not open file.&quot;_s)));</span>


1537 
1538     NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">1539     JSValue result = evaluate(globalObject, jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), evaluationException);</span>
1540     if (evaluationException)
<span class="line-modified">1541         throwException(globalObject, scope, evaluationException);</span>
1542     return JSValue::encode(result);
1543 }
1544 
<span class="line-modified">1545 EncodedJSValue JSC_HOST_CALL functionLoadString(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1546 {
<span class="line-modified">1547     VM&amp; vm = globalObject-&gt;vm();</span>
1548     auto scope = DECLARE_THROW_SCOPE(vm);
1549 
<span class="line-modified">1550     String sourceCode = callFrame-&gt;argument(0).toWTFString(globalObject);</span>
1551     RETURN_IF_EXCEPTION(scope, encodedJSValue());

1552 
1553     NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">1554     JSValue result = evaluate(globalObject, jscSource(sourceCode, callFrame-&gt;callerSourceOrigin(vm)), JSValue(), evaluationException);</span>
1555     if (evaluationException)
<span class="line-modified">1556         throwException(globalObject, scope, evaluationException);</span>
1557     return JSValue::encode(result);
1558 }
1559 
<span class="line-modified">1560 EncodedJSValue JSC_HOST_CALL functionReadFile(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1561 {
<span class="line-modified">1562     VM&amp; vm = globalObject-&gt;vm();</span>
1563     auto scope = DECLARE_THROW_SCOPE(vm);
1564 
<span class="line-modified">1565     String fileName = callFrame-&gt;argument(0).toWTFString(globalObject);</span>
1566     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1567 
1568     bool isBinary = false;
<span class="line-modified">1569     if (callFrame-&gt;argumentCount() &gt; 1) {</span>
<span class="line-modified">1570         String type = callFrame-&gt;argument(1).toWTFString(globalObject);</span>
1571         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1572         if (type != &quot;binary&quot;)
<span class="line-modified">1573             return throwVMError(globalObject, scope, &quot;Expected &#39;binary&#39; as second argument.&quot;);</span>
1574         isBinary = true;
1575     }
1576 
1577     RefPtr&lt;Uint8Array&gt; content = fillBufferWithContentsOfFile(fileName);
1578     if (!content)
<span class="line-modified">1579         return throwVMError(globalObject, scope, &quot;Could not open file.&quot;);</span>
1580 
1581     if (!isBinary)
1582         return JSValue::encode(jsString(vm, String::fromUTF8WithLatin1Fallback(content-&gt;data(), content-&gt;length())));
1583 
<span class="line-modified">1584     Structure* structure = globalObject-&gt;typedArrayStructure(TypeUint8);</span>
1585     JSObject* result = JSUint8Array::create(vm, structure, WTFMove(content));
1586     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1587 
1588     return JSValue::encode(result);
1589 }
1590 
<span class="line-modified">1591 EncodedJSValue JSC_HOST_CALL functionCheckSyntax(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1592 {
<span class="line-modified">1593     VM&amp; vm = globalObject-&gt;vm();</span>
1594     auto scope = DECLARE_THROW_SCOPE(vm);
1595 
<span class="line-modified">1596     String fileName = callFrame-&gt;argument(0).toWTFString(globalObject);</span>
1597     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1598     Vector&lt;char&gt; script;
1599     if (!fetchScriptFromLocalFileSystem(fileName, script))
<span class="line-modified">1600         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Could not open file.&quot;_s)));</span>


1601 
1602     StopWatch stopWatch;
1603     stopWatch.start();
1604 
1605     JSValue syntaxException;
<span class="line-modified">1606     bool validSyntax = checkSyntax(globalObject, jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), &amp;syntaxException);</span>
1607     stopWatch.stop();
1608 
1609     if (!validSyntax)
<span class="line-modified">1610         throwException(globalObject, scope, syntaxException);</span>
1611     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
1612 }
1613 
1614 #if ENABLE(SAMPLING_FLAGS)
<span class="line-modified">1615 EncodedJSValue JSC_HOST_CALL functionSetSamplingFlags(JSGlobalObject*, CallFrame* callFrame)</span>
1616 {
<span class="line-modified">1617     for (unsigned i = 0; i &lt; callFrame-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">1618         unsigned flag = static_cast&lt;unsigned&gt;(callFrame-&gt;uncheckedArgument(i).toNumber(globalObject));</span>
1619         if ((flag &gt;= 1) &amp;&amp; (flag &lt;= 32))
1620             SamplingFlags::setFlag(flag);
1621     }
1622     return JSValue::encode(jsNull());
1623 }
1624 
<span class="line-modified">1625 EncodedJSValue JSC_HOST_CALL functionClearSamplingFlags(JSGlobalObject*, CallFrame* callFrame)</span>
1626 {
<span class="line-modified">1627     for (unsigned i = 0; i &lt; callFrame-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">1628         unsigned flag = static_cast&lt;unsigned&gt;(callFrame-&gt;uncheckedArgument(i).toNumber(globalObject));</span>
1629         if ((flag &gt;= 1) &amp;&amp; (flag &lt;= 32))
1630             SamplingFlags::clearFlag(flag);
1631     }
1632     return JSValue::encode(jsNull());
1633 }
1634 #endif
1635 
<span class="line-modified">1636 EncodedJSValue JSC_HOST_CALL functionGetRandomSeed(JSGlobalObject* globalObject, CallFrame*)</span>
1637 {
<span class="line-modified">1638     return JSValue::encode(jsNumber(globalObject-&gt;weakRandom().seed()));</span>
1639 }
1640 
<span class="line-modified">1641 EncodedJSValue JSC_HOST_CALL functionSetRandomSeed(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1642 {
<span class="line-modified">1643     VM&amp; vm = globalObject-&gt;vm();</span>
1644     auto scope = DECLARE_THROW_SCOPE(vm);
1645 
<span class="line-modified">1646     unsigned seed = callFrame-&gt;argument(0).toUInt32(globalObject);</span>
1647     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1648     globalObject-&gt;weakRandom().setSeed(seed);</span>
1649     return JSValue::encode(jsUndefined());
1650 }
1651 
<span class="line-modified">1652 EncodedJSValue JSC_HOST_CALL functionIsRope(JSGlobalObject*, CallFrame* callFrame)</span>
1653 {
<span class="line-modified">1654     JSValue argument = callFrame-&gt;argument(0);</span>
1655     if (!argument.isString())
1656         return JSValue::encode(jsBoolean(false));
1657     const StringImpl* impl = asString(argument)-&gt;tryGetValueImpl();
1658     return JSValue::encode(jsBoolean(!impl));
1659 }
1660 
<span class="line-modified">1661 EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1662 {
<span class="line-modified">1663     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">1664     SourceOrigin sourceOrigin = callFrame-&gt;callerSourceOrigin(vm);</span>
1665     if (sourceOrigin.isNull())
1666         return JSValue::encode(jsNull());
<span class="line-modified">1667     return JSValue::encode(jsString(vm, sourceOrigin.string()));</span>
1668 }
1669 
<span class="line-modified">1670 EncodedJSValue JSC_HOST_CALL functionReadline(JSGlobalObject* globalObject, CallFrame*)</span>
1671 {
1672     Vector&lt;char, 256&gt; line;
1673     int c;
1674     while ((c = getchar()) != EOF) {
1675         // FIXME: Should we also break on \r?
1676         if (c == &#39;\n&#39;)
1677             break;
1678         line.append(c);
1679     }
1680     line.append(&#39;\0&#39;);
<span class="line-modified">1681     return JSValue::encode(jsString(globalObject-&gt;vm(), line.data()));</span>
1682 }
1683 
<span class="line-modified">1684 EncodedJSValue JSC_HOST_CALL functionPreciseTime(JSGlobalObject*, CallFrame*)</span>
1685 {
1686     return JSValue::encode(jsNumber(WallTime::now().secondsSinceEpoch().value()));
1687 }
1688 
<span class="line-modified">1689 EncodedJSValue JSC_HOST_CALL functionNeverInlineFunction(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1690 {
<span class="line-modified">1691     return JSValue::encode(setNeverInline(globalObject, callFrame));</span>
1692 }
1693 
<span class="line-modified">1694 EncodedJSValue JSC_HOST_CALL functionNoDFG(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1695 {
<span class="line-modified">1696     return JSValue::encode(setNeverOptimize(globalObject, callFrame));</span>
1697 }
1698 
<span class="line-modified">1699 EncodedJSValue JSC_HOST_CALL functionNoFTL(JSGlobalObject*, CallFrame* callFrame)</span>
1700 {
<span class="line-modified">1701     if (callFrame-&gt;argumentCount()) {</span>
<span class="line-modified">1702         FunctionExecutable* executable = getExecutableForFunction(callFrame-&gt;argument(0));</span>
1703         if (executable)
1704             executable-&gt;setNeverFTLOptimize(true);
1705     }
1706     return JSValue::encode(jsUndefined());
1707 }
1708 
<span class="line-modified">1709 EncodedJSValue JSC_HOST_CALL functionNoOSRExitFuzzing(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1710 {
<span class="line-modified">1711     return JSValue::encode(setCannotUseOSRExitFuzzing(globalObject, callFrame));</span>
1712 }
1713 
<span class="line-modified">1714 EncodedJSValue JSC_HOST_CALL functionOptimizeNextInvocation(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1715 {
<span class="line-modified">1716     return JSValue::encode(optimizeNextInvocation(globalObject, callFrame));</span>
1717 }
1718 
<span class="line-modified">1719 EncodedJSValue JSC_HOST_CALL functionNumberOfDFGCompiles(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1720 {
<span class="line-modified">1721     return JSValue::encode(numberOfDFGCompiles(globalObject, callFrame));</span>
<span class="line-added">1722 }</span>
<span class="line-added">1723 </span>
<span class="line-added">1724 EncodedJSValue JSC_HOST_CALL functionCallerIsOMGCompiled(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
<span class="line-added">1725 {</span>
<span class="line-added">1726     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">1727     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">1728 </span>
<span class="line-added">1729     if (!Options::useBBQTierUpChecks())</span>
<span class="line-added">1730         return JSValue::encode(jsBoolean(true));</span>
<span class="line-added">1731 </span>
<span class="line-added">1732     CallerFunctor wasmToJSFrame;</span>
<span class="line-added">1733     StackVisitor::visit(callFrame, vm, wasmToJSFrame);</span>
<span class="line-added">1734     if (!wasmToJSFrame.callerFrame()-&gt;isAnyWasmCallee())</span>
<span class="line-added">1735         return throwVMError(globalObject, scope, &quot;caller is not a wasm-&gt;js import function&quot;);</span>
<span class="line-added">1736 </span>
<span class="line-added">1737     // We have a wrapper frame that we generate for imports. If we ever can direct call from wasm we would need to change this.</span>
<span class="line-added">1738     ASSERT(!wasmToJSFrame.callerFrame()-&gt;callee().isWasm());</span>
<span class="line-added">1739     CallerFunctor wasmFrame;</span>
<span class="line-added">1740     StackVisitor::visit(wasmToJSFrame.callerFrame(), vm, wasmFrame);</span>
<span class="line-added">1741     ASSERT(wasmFrame.callerFrame()-&gt;callee().isWasm());</span>
<span class="line-added">1742 #if ENABLE(WEBASSEMBLY)</span>
<span class="line-added">1743     auto mode = wasmFrame.callerFrame()-&gt;callee().asWasmCallee()-&gt;compilationMode();</span>
<span class="line-added">1744     return JSValue::encode(jsBoolean(mode == Wasm::CompilationMode::OMGMode || mode == Wasm::CompilationMode::OMGForOSREntryMode));</span>
<span class="line-added">1745 #endif</span>
<span class="line-added">1746     RELEASE_ASSERT_NOT_REACHED();</span>
1747 }
1748 
1749 Message::Message(ArrayBufferContents&amp;&amp; contents, int32_t index)
1750     : m_contents(WTFMove(contents))
1751     , m_index(index)
1752 {
1753 }
1754 
1755 Message::~Message()
1756 {
1757 }
1758 
1759 Worker::Worker(Workers&amp; workers)
1760     : m_workers(workers)
1761 {
1762     auto locker = holdLock(m_workers.m_lock);
1763     m_workers.m_workers.append(this);
1764 
1765     *currentWorker() = this;
1766 }
</pre>
<hr />
<pre>
1840 String Workers::getReport()
1841 {
1842     auto locker = holdLock(m_lock);
1843     while (m_reports.isEmpty())
1844         m_condition.wait(m_lock);
1845     return m_reports.takeFirst();
1846 }
1847 
1848 Workers&amp; Workers::singleton()
1849 {
1850     static Workers* result;
1851     static std::once_flag flag;
1852     std::call_once(
1853         flag,
1854         [] {
1855             result = new Workers();
1856         });
1857     return *result;
1858 }
1859 
<span class="line-modified">1860 EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(JSGlobalObject* globalObject, CallFrame*)</span>
1861 {
<span class="line-modified">1862     VM&amp; vm = globalObject-&gt;vm();</span>
1863     GlobalObject* result = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;());
1864     return JSValue::encode(result-&gt;getDirect(vm, Identifier::fromString(vm, &quot;$&quot;)));
1865 }
1866 
<span class="line-modified">1867 EncodedJSValue JSC_HOST_CALL functionDollarEvalScript(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1868 {
<span class="line-modified">1869     VM&amp; vm = globalObject-&gt;vm();</span>





1870     auto scope = DECLARE_THROW_SCOPE(vm);
1871 
<span class="line-modified">1872     String sourceCode = callFrame-&gt;argument(0).toWTFString(globalObject);</span>
1873     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1874 
<span class="line-modified">1875     GlobalObject* realm = jsDynamicCast&lt;GlobalObject*&gt;(vm,</span>
<span class="line-modified">1876         callFrame-&gt;thisValue().get(globalObject, Identifier::fromString(vm, &quot;global&quot;)));</span>
1877     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1878     if (!realm)</span>
<span class="line-modified">1879         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Expected global to point to a global object&quot;_s)));</span>
1880 
1881     NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">1882     JSValue result = evaluate(realm, jscSource(sourceCode, callFrame-&gt;callerSourceOrigin(vm)), JSValue(), evaluationException);</span>
1883     if (evaluationException)
<span class="line-modified">1884         throwException(globalObject, scope, evaluationException);</span>
1885     return JSValue::encode(result);
1886 }
1887 
<span class="line-modified">1888 EncodedJSValue JSC_HOST_CALL functionDollarAgentStart(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1889 {
<span class="line-modified">1890     VM&amp; vm = globalObject-&gt;vm();</span>
1891     auto scope = DECLARE_THROW_SCOPE(vm);
1892 
<span class="line-modified">1893     String sourceCode = callFrame-&gt;argument(0).toWTFString(globalObject).isolatedCopy();</span>
1894     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1895 
1896     Lock didStartLock;
1897     Condition didStartCondition;
1898     bool didStart = false;
1899 
1900     Thread::create(
1901         &quot;JSC Agent&quot;,
1902         [sourceCode, &amp;didStartLock, &amp;didStartCondition, &amp;didStart] () {
1903             CommandLine commandLine(0, nullptr);
1904             commandLine.m_interactive = false;
1905             runJSC(
1906                 commandLine, true,
1907                 [&amp;] (VM&amp;, GlobalObject* globalObject, bool&amp; success) {
1908                     // Notify the thread that started us that we have registered a worker.
1909                     {
1910                         auto locker = holdLock(didStartLock);
1911                         didStart = true;
1912                         didStartCondition.notifyOne();
1913                     }
1914 
1915                     NakedPtr&lt;Exception&gt; evaluationException;
1916                     JSValue result;
<span class="line-modified">1917                     result = evaluate(globalObject, jscSource(sourceCode, SourceOrigin(&quot;worker&quot;_s)), JSValue(), evaluationException);</span>
1918                     if (evaluationException)
1919                         result = evaluationException-&gt;value();
<span class="line-modified">1920                     checkException(globalObject, true, evaluationException, result, commandLine, success);</span>
1921                     if (!success)
1922                         exit(1);
1923                 });
1924         })-&gt;detach();
1925 
1926     {
1927         auto locker = holdLock(didStartLock);
1928         while (!didStart)
1929             didStartCondition.wait(didStartLock);
1930     }
1931 
1932     return JSValue::encode(jsUndefined());
1933 }
1934 
<span class="line-modified">1935 EncodedJSValue JSC_HOST_CALL functionDollarAgentReceiveBroadcast(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1936 {
<span class="line-modified">1937     VM&amp; vm = globalObject-&gt;vm();</span>
1938     auto scope = DECLARE_THROW_SCOPE(vm);
1939 
<span class="line-modified">1940     JSValue callback = callFrame-&gt;argument(0);</span>
1941     CallData callData;
1942     CallType callType = getCallData(vm, callback, callData);
1943     if (callType == CallType::None)
<span class="line-modified">1944         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Expected callback&quot;_s)));</span>
1945 
1946     RefPtr&lt;Message&gt; message;
1947     {
1948         ReleaseHeapAccessScope releaseAccess(vm.heap);
1949         message = Worker::current().dequeue();
1950     }
1951 
1952     auto nativeBuffer = ArrayBuffer::create(message-&gt;releaseContents());
1953     ArrayBufferSharingMode sharingMode = nativeBuffer-&gt;sharingMode();
<span class="line-modified">1954     JSArrayBuffer* jsBuffer = JSArrayBuffer::create(vm, globalObject-&gt;arrayBufferStructure(sharingMode), WTFMove(nativeBuffer));</span>
1955 
1956     MarkedArgumentBuffer args;
1957     args.append(jsBuffer);
1958     args.append(jsNumber(message-&gt;index()));
1959     if (UNLIKELY(args.hasOverflowed()))
<span class="line-modified">1960         return JSValue::encode(throwOutOfMemoryError(globalObject, scope));</span>
<span class="line-modified">1961     RELEASE_AND_RETURN(scope, JSValue::encode(call(globalObject, callback, callType, callData, jsNull(), args)));</span>
1962 }
1963 
<span class="line-modified">1964 EncodedJSValue JSC_HOST_CALL functionDollarAgentReport(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1965 {
<span class="line-modified">1966     VM&amp; vm = globalObject-&gt;vm();</span>
1967     auto scope = DECLARE_THROW_SCOPE(vm);
1968 
<span class="line-modified">1969     String report = callFrame-&gt;argument(0).toWTFString(globalObject);</span>
1970     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1971 
1972     Workers::singleton().report(report);
1973 
1974     return JSValue::encode(jsUndefined());
1975 }
1976 
<span class="line-modified">1977 EncodedJSValue JSC_HOST_CALL functionDollarAgentSleep(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1978 {
<span class="line-modified">1979     VM&amp; vm = globalObject-&gt;vm();</span>
1980     auto scope = DECLARE_THROW_SCOPE(vm);
1981 
<span class="line-modified">1982     if (callFrame-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">1983         Seconds seconds = Seconds::fromMilliseconds(callFrame-&gt;argument(0).toNumber(globalObject));</span>
1984         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1985         sleep(seconds);
1986     }
1987     return JSValue::encode(jsUndefined());
1988 }
1989 
<span class="line-modified">1990 EncodedJSValue JSC_HOST_CALL functionDollarAgentBroadcast(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1991 {
<span class="line-modified">1992     VM&amp; vm = globalObject-&gt;vm();</span>
1993     auto scope = DECLARE_THROW_SCOPE(vm);
1994 
<span class="line-modified">1995     JSArrayBuffer* jsBuffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, callFrame-&gt;argument(0));</span>
1996     if (!jsBuffer || !jsBuffer-&gt;isShared())
<span class="line-modified">1997         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Expected SharedArrayBuffer&quot;_s)));</span>
1998 
<span class="line-modified">1999     int32_t index = callFrame-&gt;argument(1).toInt32(globalObject);</span>
2000     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2001 
2002     Workers::singleton().broadcast(
2003         [&amp;] (const AbstractLocker&amp; locker, Worker&amp; worker) {
2004             ArrayBuffer* nativeBuffer = jsBuffer-&gt;impl();
2005             ArrayBufferContents contents;
2006             nativeBuffer-&gt;transferTo(vm, contents); // &quot;transferTo&quot; means &quot;share&quot; if the buffer is shared.
2007             RefPtr&lt;Message&gt; message = adoptRef(new Message(WTFMove(contents), index));
2008             worker.enqueue(locker, message);
2009         });
2010 
2011     return JSValue::encode(jsUndefined());
2012 }
2013 
<span class="line-modified">2014 EncodedJSValue JSC_HOST_CALL functionDollarAgentGetReport(JSGlobalObject* globalObject, CallFrame*)</span>
2015 {
<span class="line-modified">2016     VM&amp; vm = globalObject-&gt;vm();</span>
2017 
2018     String string = Workers::singleton().tryGetReport();
2019     if (!string)
2020         return JSValue::encode(jsNull());
2021 
2022     return JSValue::encode(jsString(vm, string));
2023 }
2024 
<span class="line-modified">2025 EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(JSGlobalObject*, CallFrame*)</span>
2026 {
2027     return JSValue::encode(jsUndefined());
2028 }
2029 
<span class="line-modified">2030 EncodedJSValue JSC_HOST_CALL functionDollarAgentMonotonicNow(JSGlobalObject*, CallFrame*)</span>
2031 {
2032     return JSValue::encode(jsNumber(MonotonicTime::now().secondsSinceEpoch().milliseconds()));
2033 }
2034 
<span class="line-modified">2035 EncodedJSValue JSC_HOST_CALL functionWaitForReport(JSGlobalObject* globalObject, CallFrame*)</span>
2036 {
<span class="line-modified">2037     VM&amp; vm = globalObject-&gt;vm();</span>
2038 
2039     String string;
2040     {
2041         ReleaseHeapAccessScope releaseAccess(vm.heap);
2042         string = Workers::singleton().getReport();
2043     }
2044     if (!string)
2045         return JSValue::encode(jsNull());
2046 
2047     return JSValue::encode(jsString(vm, string));
2048 }
2049 
<span class="line-modified">2050 EncodedJSValue JSC_HOST_CALL functionHeapCapacity(JSGlobalObject* globalObject, CallFrame*)</span>
2051 {
<span class="line-modified">2052     VM&amp; vm = globalObject-&gt;vm();</span>
2053     return JSValue::encode(jsNumber(vm.heap.capacity()));
2054 }
2055 
<span class="line-modified">2056 EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2057 {
<span class="line-modified">2058     VM&amp; vm = globalObject-&gt;vm();</span>
2059     auto scope = DECLARE_THROW_SCOPE(vm);
2060 
2061     double sleepTimeMs = 0;
<span class="line-modified">2062     if (callFrame-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">2063         sleepTimeMs = callFrame-&gt;argument(0).toNumber(globalObject);</span>
2064         RETURN_IF_EXCEPTION(scope, encodedJSValue());
2065     }
2066 
2067     vm.heap.releaseAccess();
2068     if (sleepTimeMs)
2069         sleep(Seconds::fromMilliseconds(sleepTimeMs));
2070     vm.heap.acquireAccess();
2071     return JSValue::encode(jsUndefined());
2072 }
2073 
<span class="line-modified">2074 EncodedJSValue JSC_HOST_CALL functionDisableRichSourceInfo(JSGlobalObject*, CallFrame*)</span>
2075 {
2076     supportsRichSourceInfo = false;
2077     return JSValue::encode(jsUndefined());
2078 }
2079 
<span class="line-modified">2080 EncodedJSValue JSC_HOST_CALL functionMallocInALoop(JSGlobalObject*, CallFrame*)</span>
2081 {
2082     Vector&lt;void*&gt; ptrs;
2083     for (unsigned i = 0; i &lt; 5000; ++i)
2084         ptrs.append(fastMalloc(1024 * 2));
2085     for (void* ptr : ptrs)
2086         fastFree(ptr);
2087     return JSValue::encode(jsUndefined());
2088 }
2089 
<span class="line-modified">2090 EncodedJSValue JSC_HOST_CALL functionTotalCompileTime(JSGlobalObject*, CallFrame*)</span>
2091 {
2092 #if ENABLE(JIT)
2093     return JSValue::encode(jsNumber(JIT::totalCompileTime().milliseconds()));
2094 #else
2095     return JSValue::encode(jsNumber(0));
2096 #endif
2097 }
2098 
2099 template&lt;typename ValueType&gt;
2100 typename std::enable_if&lt;!std::is_fundamental&lt;ValueType&gt;::value&gt;::type addOption(VM&amp;, JSObject*, const Identifier&amp;, ValueType) { }
2101 
2102 template&lt;typename ValueType&gt;
2103 typename std::enable_if&lt;std::is_fundamental&lt;ValueType&gt;::value&gt;::type addOption(VM&amp; vm, JSObject* optionsObject, const Identifier&amp; identifier, ValueType value)
2104 {
2105     optionsObject-&gt;putDirect(vm, identifier, JSValue(value));
2106 }
2107 
<span class="line-modified">2108 EncodedJSValue JSC_HOST_CALL functionJSCOptions(JSGlobalObject* globalObject, CallFrame*)</span>
2109 {
<span class="line-modified">2110     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2111     JSObject* optionsObject = constructEmptyObject(globalObject);</span>
<span class="line-modified">2112 #define READ_OPTION(type_, name_, defaultValue_, availability_, description_) \</span>
2113     addOption(vm, optionsObject, Identifier::fromString(vm, #name_), Options::name_());
<span class="line-modified">2114     FOR_EACH_JSC_OPTION(READ_OPTION)</span>
<span class="line-modified">2115 #undef READ_OPTION</span>
2116     return JSValue::encode(optionsObject);
2117 }
2118 
<span class="line-modified">2119 EncodedJSValue JSC_HOST_CALL functionReoptimizationRetryCount(JSGlobalObject*, CallFrame* callFrame)</span>
2120 {
<span class="line-modified">2121     if (callFrame-&gt;argumentCount() &lt; 1)</span>
2122         return JSValue::encode(jsUndefined());
2123 
<span class="line-modified">2124     CodeBlock* block = getSomeBaselineCodeBlockForFunction(callFrame-&gt;argument(0));</span>
2125     if (!block)
2126         return JSValue::encode(jsNumber(0));
2127 
2128     return JSValue::encode(jsNumber(block-&gt;reoptimizationRetryCounter()));
2129 }
2130 
<span class="line-modified">2131 EncodedJSValue JSC_HOST_CALL functionTransferArrayBuffer(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2132 {
<span class="line-modified">2133     VM&amp; vm = globalObject-&gt;vm();</span>
2134     auto scope = DECLARE_THROW_SCOPE(vm);
2135 
<span class="line-modified">2136     if (callFrame-&gt;argumentCount() &lt; 1)</span>
<span class="line-modified">2137         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Not enough arguments&quot;_s)));</span>
2138 
<span class="line-modified">2139     JSArrayBuffer* buffer = jsDynamicCast&lt;JSArrayBuffer*&gt;(vm, callFrame-&gt;argument(0));</span>
2140     if (!buffer)
<span class="line-modified">2141         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Expected an array buffer&quot;_s)));</span>
2142 
2143     ArrayBufferContents dummyContents;
2144     buffer-&gt;impl()-&gt;transferTo(vm, dummyContents);
2145 
2146     return JSValue::encode(jsUndefined());
2147 }
2148 
<span class="line-modified">2149 EncodedJSValue JSC_HOST_CALL functionFailNextNewCodeBlock(JSGlobalObject* globalObject, CallFrame*)</span>
2150 {
<span class="line-modified">2151     VM&amp; vm = globalObject-&gt;vm();</span>
2152     vm.setFailNextNewCodeBlock();
2153     return JSValue::encode(jsUndefined());
2154 }
2155 
<span class="line-modified">2156 EncodedJSValue JSC_HOST_CALL functionQuit(JSGlobalObject* globalObject, CallFrame*)</span>
2157 {
<span class="line-modified">2158     VM&amp; vm = globalObject-&gt;vm();</span>
2159     vm.codeCache()-&gt;write(vm);
2160 
2161     jscExit(EXIT_SUCCESS);
2162 
2163 #if COMPILER(MSVC)
2164     // Without this, Visual Studio will complain that this method does not return a value.
2165     return JSValue::encode(jsUndefined());
2166 #endif
2167 }
2168 
<span class="line-modified">2169 EncodedJSValue JSC_HOST_CALL functionFalse(JSGlobalObject*, CallFrame*) { return JSValue::encode(jsBoolean(false)); }</span>
2170 
<span class="line-modified">2171 EncodedJSValue JSC_HOST_CALL functionUndefined1(JSGlobalObject*, CallFrame*) { return JSValue::encode(jsUndefined()); }</span>
<span class="line-modified">2172 EncodedJSValue JSC_HOST_CALL functionUndefined2(JSGlobalObject*, CallFrame*) { return JSValue::encode(jsUndefined()); }</span>
<span class="line-modified">2173 EncodedJSValue JSC_HOST_CALL functionIsInt32(JSGlobalObject*, CallFrame* callFrame)</span>
2174 {
<span class="line-modified">2175     for (size_t i = 0; i &lt; callFrame-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">2176         if (!callFrame-&gt;argument(i).isInt32())</span>
2177             return JSValue::encode(jsBoolean(false));
2178     }
2179     return JSValue::encode(jsBoolean(true));
2180 }
2181 
<span class="line-modified">2182 EncodedJSValue JSC_HOST_CALL functionIsPureNaN(JSGlobalObject*, CallFrame* callFrame)</span>
2183 {
<span class="line-modified">2184     for (size_t i = 0; i &lt; callFrame-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">2185         JSValue value = callFrame-&gt;argument(i);</span>
2186         if (!value.isNumber())
2187             return JSValue::encode(jsBoolean(false));
2188         double number = value.asNumber();
2189         if (!std::isnan(number))
2190             return JSValue::encode(jsBoolean(false));
2191         if (isImpureNaN(number))
2192             return JSValue::encode(jsBoolean(false));
2193     }
2194     return JSValue::encode(jsBoolean(true));
2195 }
2196 
<span class="line-modified">2197 EncodedJSValue JSC_HOST_CALL functionIdentity(JSGlobalObject*, CallFrame* callFrame) { return JSValue::encode(callFrame-&gt;argument(0)); }</span>
2198 
<span class="line-modified">2199 EncodedJSValue JSC_HOST_CALL functionEffectful42(JSGlobalObject*, CallFrame*)</span>
2200 {
2201     return JSValue::encode(jsNumber(42));
2202 }
2203 
<span class="line-modified">2204 EncodedJSValue JSC_HOST_CALL functionMakeMasquerader(JSGlobalObject* globalObject, CallFrame*)</span>
2205 {
<span class="line-modified">2206     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2207     return JSValue::encode(Masquerader::create(vm, globalObject));</span>
2208 }
2209 
<span class="line-modified">2210 EncodedJSValue JSC_HOST_CALL functionHasCustomProperties(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2211 {
<span class="line-modified">2212     JSValue value = callFrame-&gt;argument(0);</span>
2213     if (value.isObject())
<span class="line-modified">2214         return JSValue::encode(jsBoolean(asObject(value)-&gt;hasCustomProperties(globalObject-&gt;vm())));</span>
2215     return JSValue::encode(jsBoolean(false));
2216 }
2217 
<span class="line-modified">2218 EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(JSGlobalObject* globalObject, CallFrame*)</span>
2219 {
<span class="line-modified">2220     VM&amp; vm = globalObject-&gt;vm();</span>
2221     vm.dumpTypeProfilerData();
2222     return JSValue::encode(jsUndefined());
2223 }
2224 
<span class="line-modified">2225 EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(JSGlobalObject* globalObject, CallFrame*)</span>
2226 {
<span class="line-modified">2227     VM&amp; vm = globalObject-&gt;vm();</span>
2228     vm.drainMicrotasks();
2229     return JSValue::encode(jsUndefined());
2230 }
2231 
<span class="line-modified">2232 EncodedJSValue JSC_HOST_CALL functionReleaseWeakRefs(JSGlobalObject* globalObject, CallFrame*)</span>
2233 {
<span class="line-modified">2234     VM&amp; vm = globalObject-&gt;vm();</span>
2235     vm.finalizeSynchronousJSExecution();
2236     return JSValue::encode(jsUndefined());
2237 }
2238 
<span class="line-modified">2239 EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(JSGlobalObject*, CallFrame*)</span>
2240 {
2241 #if USE(JSVALUE64)
2242     return JSValue::encode(JSValue(JSC::JSValue::JSFalse));
2243 #else
2244     return JSValue::encode(JSValue(JSC::JSValue::JSTrue));
2245 #endif
2246 }
2247 
<span class="line-modified">2248 EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(JSGlobalObject* globalObject, CallFrame*)</span>
2249 {
<span class="line-modified">2250     VM&amp; vm = globalObject-&gt;vm();</span>
2251     return JSValue::encode(GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector&lt;String&gt;()));
2252 }
2253 
<span class="line-modified">2254 EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2255 {
<span class="line-modified">2256     VM&amp; vm = globalObject-&gt;vm();</span>
2257     auto scope = DECLARE_THROW_SCOPE(vm);
2258 
<span class="line-modified">2259     String source = callFrame-&gt;argument(0).toWTFString(globalObject);</span>
2260     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2261 
2262     StopWatch stopWatch;
2263     stopWatch.start();
2264 
2265     ParserError error;
<span class="line-modified">2266     bool validSyntax = checkModuleSyntax(globalObject, jscSource(source, { }, URL(), TextPosition(), SourceProviderSourceType::Module), error);</span>
2267     RETURN_IF_EXCEPTION(scope, encodedJSValue());
2268     stopWatch.stop();
2269 
2270     if (!validSyntax)
<span class="line-modified">2271         throwException(globalObject, scope, jsNontrivialString(vm, toString(&quot;SyntaxError: &quot;, error.message(), &quot;:&quot;, error.line())));</span>
2272     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
2273 }
2274 
<span class="line-modified">2275 EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(JSGlobalObject*, CallFrame*)</span>
2276 {
2277 #if ENABLE(SAMPLING_PROFILER)
2278     return JSValue::encode(JSValue(JSC::JSValue::JSTrue));
2279 #else
2280     return JSValue::encode(JSValue(JSC::JSValue::JSFalse));
2281 #endif
2282 }
2283 
<span class="line-modified">2284 EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(JSGlobalObject* globalObject, CallFrame*)</span>
2285 {
<span class="line-modified">2286     VM&amp; vm = globalObject-&gt;vm();</span>
2287     JSLockHolder lock(vm);
2288     auto scope = DECLARE_THROW_SCOPE(vm);
2289 
2290     HeapSnapshotBuilder snapshotBuilder(vm.ensureHeapProfiler());
2291     snapshotBuilder.buildSnapshot();
2292 
2293     String jsonString = snapshotBuilder.json();
<span class="line-modified">2294     EncodedJSValue result = JSValue::encode(JSONParse(globalObject, jsonString));</span>
2295     scope.releaseAssertNoException();
2296     return result;
2297 }
2298 
<span class="line-modified">2299 EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(JSGlobalObject* globalObject, CallFrame*)</span>
2300 {
<span class="line-modified">2301     VM&amp; vm = globalObject-&gt;vm();</span>
2302     JSLockHolder lock(vm);
2303     auto scope = DECLARE_THROW_SCOPE(vm);
2304     String jsonString;
2305     {
2306         DeferGCForAWhile deferGC(vm.heap); // Prevent concurrent GC from interfering with the full GC that the snapshot does.
2307 
2308         HeapSnapshotBuilder snapshotBuilder(vm.ensureHeapProfiler(), HeapSnapshotBuilder::SnapshotType::GCDebuggingSnapshot);
2309         snapshotBuilder.buildSnapshot();
2310 
2311         jsonString = snapshotBuilder.json();
2312     }
2313     scope.releaseAssertNoException();
2314     return JSValue::encode(jsString(vm, jsonString));
2315 }
2316 
<span class="line-modified">2317 EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(JSGlobalObject*, CallFrame*)</span>
2318 {
2319     resetSuperSamplerState();
2320     return JSValue::encode(jsUndefined());
2321 }
2322 
<span class="line-modified">2323 EncodedJSValue JSC_HOST_CALL functionEnsureArrayStorage(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2324 {
<span class="line-modified">2325     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2326     for (unsigned i = 0; i &lt; callFrame-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">2327         if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, callFrame-&gt;argument(i)))</span>
2328             object-&gt;ensureArrayStorage(vm);
2329     }
2330     return JSValue::encode(jsUndefined());
2331 }
2332 
2333 #if ENABLE(SAMPLING_PROFILER)
<span class="line-modified">2334 EncodedJSValue JSC_HOST_CALL functionStartSamplingProfiler(JSGlobalObject* globalObject, CallFrame*)</span>
2335 {
<span class="line-modified">2336     VM&amp; vm = globalObject-&gt;vm();</span>
2337     SamplingProfiler&amp; samplingProfiler = vm.ensureSamplingProfiler(WTF::Stopwatch::create());
2338     samplingProfiler.noticeCurrentThreadAsJSCExecutionThread();
2339     samplingProfiler.start();
2340     return JSValue::encode(jsUndefined());
2341 }
2342 
<span class="line-modified">2343 EncodedJSValue JSC_HOST_CALL functionSamplingProfilerStackTraces(JSGlobalObject* globalObject, CallFrame*)</span>
2344 {
<span class="line-modified">2345     VM&amp; vm = globalObject-&gt;vm();</span>
2346     auto scope = DECLARE_THROW_SCOPE(vm);
2347 
2348     if (!vm.samplingProfiler())
<span class="line-modified">2349         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Sampling profiler was never started&quot;_s)));</span>
2350 
2351     String jsonString = vm.samplingProfiler()-&gt;stackTracesAsJSON();
<span class="line-modified">2352     EncodedJSValue result = JSValue::encode(JSONParse(globalObject, jsonString));</span>
2353     scope.releaseAssertNoException();
2354     return result;
2355 }
2356 #endif // ENABLE(SAMPLING_PROFILER)
2357 
<span class="line-modified">2358 EncodedJSValue JSC_HOST_CALL functionMaxArguments(JSGlobalObject*, CallFrame*)</span>
2359 {
2360     return JSValue::encode(jsNumber(JSC::maxArguments));
2361 }
2362 
<span class="line-modified">2363 EncodedJSValue JSC_HOST_CALL functionAsyncTestStart(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2364 {
<span class="line-modified">2365     VM&amp; vm = globalObject-&gt;vm();</span>
2366     auto scope = DECLARE_THROW_SCOPE(vm);
2367 
<span class="line-modified">2368     JSValue numberOfAsyncPasses = callFrame-&gt;argument(0);</span>
2369     if (!numberOfAsyncPasses.isUInt32())
<span class="line-modified">2370         return throwVMError(globalObject, scope, &quot;Expected first argument to be a uint32&quot;_s);</span>
2371 
2372     asyncTestExpectedPasses += numberOfAsyncPasses.asUInt32();
2373     return encodedJSUndefined();
2374 }
2375 
<span class="line-modified">2376 EncodedJSValue JSC_HOST_CALL functionAsyncTestPassed(JSGlobalObject*, CallFrame*)</span>
2377 {
2378     asyncTestPasses++;
2379     return encodedJSUndefined();
2380 }
2381 
2382 #if ENABLE(WEBASSEMBLY)
2383 
<span class="line-modified">2384 static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2385 {
<span class="line-modified">2386     VM&amp; vm = globalObject-&gt;vm();</span>
2387     auto scope = DECLARE_THROW_SCOPE(vm);
2388 
2389     if (!Wasm::isSupported())
<span class="line-modified">2390         return throwVMTypeError(globalObject, scope, &quot;WebAssemblyMemoryMode should only be called if the useWebAssembly option is set&quot;_s);</span>
2391 
<span class="line-modified">2392     if (JSObject* object = callFrame-&gt;argument(0).getObject()) {</span>
2393         if (auto* memory = jsDynamicCast&lt;JSWebAssemblyMemory*&gt;(vm, object))
2394             return JSValue::encode(jsString(vm, makeString(memory-&gt;memory().mode())));
2395         if (auto* instance = jsDynamicCast&lt;JSWebAssemblyInstance*&gt;(vm, object))
2396             return JSValue::encode(jsString(vm, makeString(instance-&gt;memoryMode())));
2397     }
2398 
<span class="line-modified">2399     return throwVMTypeError(globalObject, scope, &quot;WebAssemblyMemoryMode expects either a WebAssembly.Memory or WebAssembly.Instance&quot;_s);</span>
2400 }
2401 
2402 #endif // ENABLE(WEBASSEMBLY)
2403 
<span class="line-modified">2404 EncodedJSValue JSC_HOST_CALL functionSetUnhandledRejectionCallback(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
2405 {
<span class="line-modified">2406     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">2407     JSObject* object = callFrame-&gt;argument(0).getObject();</span>
2408     auto scope = DECLARE_THROW_SCOPE(vm);
2409 
2410     if (!object || !object-&gt;isFunction(vm))
<span class="line-modified">2411         return throwVMTypeError(globalObject, scope);</span>
2412 
<span class="line-modified">2413     globalObject-&gt;setUnhandledRejectionCallback(vm, object);</span>
2414     return JSValue::encode(jsUndefined());
2415 }
2416 
2417 // Use SEH for Release builds only to get rid of the crash report dialog
2418 // (luckily the same tests fail in Release and Debug builds so far). Need to
2419 // be in a separate main function because the jscmain function requires object
2420 // unwinding.
2421 
2422 #if COMPILER(MSVC) &amp;&amp; !defined(_DEBUG)
2423 #define TRY       __try {
2424 #define EXCEPT(x) } __except (EXCEPTION_EXECUTE_HANDLER) { x; }
2425 #else
2426 #define TRY
2427 #define EXCEPT(x)
2428 #endif
2429 
2430 int jscmain(int argc, char** argv);
2431 
2432 static double s_desiredTimeout;
2433 static double s_timeoutMultiplier = 1.0;
<span class="line-added">2434 static Seconds s_timeoutDuration;</span>
<span class="line-added">2435 static Seconds s_maxAllowedCPUTime;</span>
<span class="line-added">2436 static VM* s_vm;</span>
<span class="line-added">2437 </span>
<span class="line-added">2438 static void startTimeoutTimer(Seconds duration)</span>
<span class="line-added">2439 {</span>
<span class="line-added">2440     Thread::create(&quot;jsc Timeout Thread&quot;, [=] () {</span>
<span class="line-added">2441         sleep(duration);</span>
<span class="line-added">2442         VMInspector::forEachVM([&amp;] (VM&amp; vm) -&gt; VMInspector::FunctorStatus {</span>
<span class="line-added">2443             if (&amp;vm != s_vm)</span>
<span class="line-added">2444                 return VMInspector::FunctorStatus::Continue;</span>
<span class="line-added">2445             vm.notifyNeedShellTimeoutCheck();</span>
<span class="line-added">2446             return VMInspector::FunctorStatus::Done;</span>
<span class="line-added">2447         });</span>
<span class="line-added">2448     });</span>
<span class="line-added">2449 }</span>
2450 
<span class="line-modified">2451 static void timeoutCheckCallback(VM&amp; vm)</span>
<span class="line-added">2452 {</span>
<span class="line-added">2453     RELEASE_ASSERT(&amp;vm == s_vm);</span>
<span class="line-added">2454     auto cpuTime = CPUTime::forCurrentThread();</span>
<span class="line-added">2455     if (cpuTime &gt;= s_maxAllowedCPUTime) {</span>
<span class="line-added">2456         dataLog(&quot;Timed out after &quot;, s_timeoutDuration, &quot; seconds!\n&quot;);</span>
<span class="line-added">2457         CRASH();</span>
<span class="line-added">2458     }</span>
<span class="line-added">2459     auto remainingTime = s_maxAllowedCPUTime - cpuTime;</span>
<span class="line-added">2460     startTimeoutTimer(remainingTime);</span>
<span class="line-added">2461 }</span>
<span class="line-added">2462 </span>
<span class="line-added">2463 static void initializeTimeoutIfNeeded()</span>
2464 {
2465     if (char* timeoutString = getenv(&quot;JSCTEST_timeout&quot;)) {
2466         if (sscanf(timeoutString, &quot;%lf&quot;, &amp;s_desiredTimeout) != 1) {
2467             dataLog(&quot;WARNING: timeout string is malformed, got &quot;, timeoutString,
2468                 &quot; but expected a number. Not using a timeout.\n&quot;);
<span class="line-modified">2469         } else</span>
<span class="line-modified">2470             g_jscConfig.shellTimeoutCheckCallback = timeoutCheckCallback;</span>






2471     }
2472 }
2473 
<span class="line-added">2474 static void startTimeoutThreadIfNeeded(VM&amp; vm)</span>
<span class="line-added">2475 {</span>
<span class="line-added">2476     if (!g_jscConfig.shellTimeoutCheckCallback)</span>
<span class="line-added">2477         return;</span>
<span class="line-added">2478 </span>
<span class="line-added">2479     s_vm = &amp;vm;</span>
<span class="line-added">2480     s_timeoutDuration = Seconds(s_desiredTimeout * s_timeoutMultiplier);</span>
<span class="line-added">2481     s_maxAllowedCPUTime = CPUTime::forCurrentThread() + s_timeoutDuration;</span>
<span class="line-added">2482     Seconds timeoutDuration(s_desiredTimeout * s_timeoutMultiplier);</span>
<span class="line-added">2483     startTimeoutTimer(timeoutDuration);</span>
<span class="line-added">2484 }</span>
<span class="line-added">2485 </span>
2486 int main(int argc, char** argv)
2487 {
<span class="line-modified">2488 #if OS(DARWIN) &amp;&amp; CPU(ARM_THUMB2)</span>
2489     // Enabled IEEE754 denormal support.
2490     fenv_t env;
2491     fegetenv( &amp;env );
2492     env.__fpscr &amp;= ~0x01000000u;
2493     fesetenv( &amp;env );
2494 #endif
2495 
2496 #if OS(WINDOWS)
2497     // Cygwin calls ::SetErrorMode(SEM_FAILCRITICALERRORS), which we will inherit. This is bad for
2498     // testing/debugging, as it causes the post-mortem debugger not to be invoked. We reset the
2499     // error mode here to work around Cygwin&#39;s behavior. See &lt;http://webkit.org/b/55222&gt;.
2500     ::SetErrorMode(0);
2501 
2502     _setmode(_fileno(stdout), _O_BINARY);
2503     _setmode(_fileno(stderr), _O_BINARY);
2504 
2505 #if defined(_DEBUG)
2506     _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);
2507     _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);
2508     _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);
</pre>
<hr />
<pre>
2534     TRY
2535         res = jscmain(argc, argv);
2536     EXCEPT(res = 3)
2537     finalizeStatsAtEndOfTesting();
2538 
2539     jscExit(res);
2540 }
2541 
2542 static void dumpException(GlobalObject* globalObject, JSValue exception)
2543 {
2544     VM&amp; vm = globalObject-&gt;vm();
2545     auto scope = DECLARE_CATCH_SCOPE(vm);
2546 
2547 #define CHECK_EXCEPTION() do { \
2548         if (scope.exception()) { \
2549             scope.clearException(); \
2550             return; \
2551         } \
2552     } while (false)
2553 
<span class="line-modified">2554     auto exceptionString = exception.toWTFString(globalObject);</span>
<span class="line-added">2555     CHECK_EXCEPTION();</span>
2556     Expected&lt;CString, UTF8ConversionError&gt; expectedCString = exceptionString.tryGetUtf8();
2557     if (expectedCString)
2558         printf(&quot;Exception: %s\n&quot;, expectedCString.value().data());
2559     else
2560         printf(&quot;Exception: &lt;out of memory while extracting exception string&gt;\n&quot;);
2561 
2562     Identifier nameID = Identifier::fromString(vm, &quot;name&quot;);
2563     CHECK_EXCEPTION();
2564     Identifier fileNameID = Identifier::fromString(vm, &quot;sourceURL&quot;);
2565     CHECK_EXCEPTION();
2566     Identifier lineNumberID = Identifier::fromString(vm, &quot;line&quot;);
2567     CHECK_EXCEPTION();
2568     Identifier stackID = Identifier::fromString(vm, &quot;stack&quot;);
2569     CHECK_EXCEPTION();
2570 
<span class="line-modified">2571     JSValue nameValue = exception.get(globalObject, nameID);</span>
2572     CHECK_EXCEPTION();
<span class="line-modified">2573     JSValue fileNameValue = exception.get(globalObject, fileNameID);</span>
2574     CHECK_EXCEPTION();
<span class="line-modified">2575     JSValue lineNumberValue = exception.get(globalObject, lineNumberID);</span>
2576     CHECK_EXCEPTION();
<span class="line-modified">2577     JSValue stackValue = exception.get(globalObject, stackID);</span>
2578     CHECK_EXCEPTION();
2579 
<span class="line-modified">2580     auto nameString = nameValue.toWTFString(globalObject);</span>
<span class="line-modified">2581     CHECK_EXCEPTION();</span>
<span class="line-modified">2582 </span>
<span class="line-modified">2583     if (nameString == &quot;SyntaxError&quot; &amp;&amp; (!fileNameValue.isUndefinedOrNull() || !lineNumberValue.isUndefinedOrNull())) {</span>
<span class="line-modified">2584         auto fileNameString = fileNameValue.toWTFString(globalObject);</span>
<span class="line-modified">2585         CHECK_EXCEPTION();</span>
<span class="line-added">2586         auto lineNumberString = lineNumberValue.toWTFString(globalObject);</span>
<span class="line-added">2587         CHECK_EXCEPTION();</span>
<span class="line-added">2588         printf(&quot;at %s:%s\n&quot;, fileNameString.utf8().data(), lineNumberString.utf8().data());</span>
2589     }
2590 
2591     if (!stackValue.isUndefinedOrNull()) {
<span class="line-modified">2592         auto stackString = stackValue.toWTFString(globalObject);</span>
<span class="line-added">2593         CHECK_EXCEPTION();</span>
2594         if (stackString.length())
2595             printf(&quot;%s\n&quot;, stackString.utf8().data());
2596     }
2597 
2598 #undef CHECK_EXCEPTION
2599 }
2600 
2601 static bool checkUncaughtException(VM&amp; vm, GlobalObject* globalObject, JSValue exception, CommandLine&amp; options)
2602 {
2603     const String&amp; expectedExceptionName = options.m_uncaughtExceptionName;
2604     auto scope = DECLARE_CATCH_SCOPE(vm);
2605     scope.clearException();
2606     if (!exception) {
2607         printf(&quot;Expected uncaught exception with name &#39;%s&#39; but none was thrown\n&quot;, expectedExceptionName.utf8().data());
2608         return false;
2609     }
2610 
<span class="line-modified">2611     JSValue exceptionClass = globalObject-&gt;get(globalObject, Identifier::fromString(vm, expectedExceptionName));</span>

2612     if (!exceptionClass.isObject() || scope.exception()) {
2613         printf(&quot;Expected uncaught exception with name &#39;%s&#39; but given exception class is not defined\n&quot;, expectedExceptionName.utf8().data());
2614         return false;
2615     }
2616 
<span class="line-modified">2617     bool isInstanceOfExpectedException = jsCast&lt;JSObject*&gt;(exceptionClass)-&gt;hasInstance(globalObject, exception);</span>
2618     if (scope.exception()) {
2619         printf(&quot;Expected uncaught exception with name &#39;%s&#39; but given exception class fails performing hasInstance\n&quot;, expectedExceptionName.utf8().data());
2620         return false;
2621     }
2622     if (isInstanceOfExpectedException) {
2623         if (options.m_alwaysDumpUncaughtException)
2624             dumpException(globalObject, exception);
2625         return true;
2626     }
2627 
2628     printf(&quot;Expected uncaught exception with name &#39;%s&#39; but exception value is not instance of this exception class\n&quot;, expectedExceptionName.utf8().data());
2629     dumpException(globalObject, exception);
2630     return false;
2631 }
2632 
<span class="line-modified">2633 static void checkException(GlobalObject* globalObject, bool isLastFile, bool hasException, JSValue value, CommandLine&amp; options, bool&amp; success)</span>
2634 {
2635     VM&amp; vm = globalObject-&gt;vm();
2636 
2637     if (options.m_treatWatchdogExceptionAsSuccess &amp;&amp; value.inherits&lt;TerminatedExecutionError&gt;(vm)) {
2638         ASSERT(hasException);
2639         return;
2640     }
2641 
2642     if (!options.m_uncaughtExceptionName || !isLastFile) {
2643         success = success &amp;&amp; !hasException;
2644         if (options.m_dump &amp;&amp; !hasException)
<span class="line-modified">2645             printf(&quot;End: %s\n&quot;, value.toWTFString(globalObject).utf8().data());</span>
2646         if (hasException)
2647             dumpException(globalObject, value);
2648     } else
2649         success = success &amp;&amp; checkUncaughtException(vm, globalObject, (hasException) ? value : JSValue(), options);
2650 }
2651 
2652 static void runWithOptions(GlobalObject* globalObject, CommandLine&amp; options, bool&amp; success)
2653 {
2654     Vector&lt;Script&gt;&amp; scripts = options.m_scripts;
2655     String fileName;
2656     Vector&lt;char&gt; scriptBuffer;
2657 



2658     VM&amp; vm = globalObject-&gt;vm();
2659     auto scope = DECLARE_CATCH_SCOPE(vm);
2660 
2661 #if ENABLE(SAMPLING_FLAGS)
2662     SamplingFlags::start();
2663 #endif
2664 
2665     for (size_t i = 0; i &lt; scripts.size(); i++) {
2666         JSInternalPromise* promise = nullptr;
2667         bool isModule = options.m_module || scripts[i].scriptType == Script::ScriptType::Module;
2668         if (scripts[i].codeSource == Script::CodeSource::File) {
2669             fileName = scripts[i].argument;
2670             if (scripts[i].strictMode == Script::StrictMode::Strict)
2671                 scriptBuffer.append(&quot;\&quot;use strict\&quot;;\n&quot;, strlen(&quot;\&quot;use strict\&quot;;\n&quot;));
2672 
2673             if (isModule) {
<span class="line-modified">2674                 promise = loadAndEvaluateModule(globalObject, fileName, jsUndefined(), jsUndefined());</span>
2675                 scope.releaseAssertNoException();
2676             } else {
2677                 if (!fetchScriptFromLocalFileSystem(fileName, scriptBuffer)) {
2678                     success = false; // fail early so we can catch missing files
2679                     return;
2680                 }
2681             }
2682         } else {
2683             size_t commandLineLength = strlen(scripts[i].argument);
2684             scriptBuffer.resize(commandLineLength);
2685             std::copy(scripts[i].argument, scripts[i].argument + commandLineLength, scriptBuffer.begin());
2686             fileName = &quot;[Command Line]&quot;_s;
2687         }
2688 
2689         bool isLastFile = i == scripts.size() - 1;
2690         if (isModule) {
2691             if (!promise) {
2692                 // FIXME: This should use an absolute file URL https://bugs.webkit.org/show_bug.cgi?id=193077
<span class="line-modified">2693                 promise = loadAndEvaluateModule(globalObject, jscSource(stringFromUTF(scriptBuffer), SourceOrigin { absolutePath(fileName) }, URL({ }, fileName), TextPosition(), SourceProviderSourceType::Module), jsUndefined());</span>
2694             }
2695             scope.clearException();
2696 
<span class="line-modified">2697             JSFunction* fulfillHandler = JSNativeStdFunction::create(vm, globalObject, 1, String(), [&amp;success, &amp;options, isLastFile](JSGlobalObject* globalObject, CallFrame* callFrame) {</span>
<span class="line-modified">2698                 checkException(jsCast&lt;GlobalObject*&gt;(globalObject), isLastFile, false, callFrame-&gt;argument(0), options, success);</span>
2699                 return JSValue::encode(jsUndefined());
2700             });
2701 
<span class="line-modified">2702             JSFunction* rejectHandler = JSNativeStdFunction::create(vm, globalObject, 1, String(), [&amp;success, &amp;options, isLastFile](JSGlobalObject* globalObject, CallFrame* callFrame) {</span>
<span class="line-modified">2703                 checkException(jsCast&lt;GlobalObject*&gt;(globalObject), isLastFile, true, callFrame-&gt;argument(0), options, success);</span>
2704                 return JSValue::encode(jsUndefined());
2705             });
2706 
<span class="line-modified">2707             promise-&gt;then(globalObject, fulfillHandler, rejectHandler);</span>
2708             scope.releaseAssertNoException();
2709             vm.drainMicrotasks();
2710         } else {
2711             NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">2712             JSValue returnValue = evaluate(globalObject, jscSource(scriptBuffer, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), evaluationException);</span>
2713             scope.assertNoException();
2714             if (evaluationException)
2715                 returnValue = evaluationException-&gt;value();
<span class="line-modified">2716             checkException(globalObject, isLastFile, evaluationException, returnValue, options, success);</span>
2717         }
2718 
2719         scriptBuffer.clear();
2720         scope.clearException();
2721     }
2722 
2723 #if ENABLE(REGEXP_TRACING)
2724     vm.dumpRegExpTrace();
2725 #endif
2726 }
2727 
2728 #define RUNNING_FROM_XCODE 0
2729 
2730 static void runInteractive(GlobalObject* globalObject)
2731 {
2732     VM&amp; vm = globalObject-&gt;vm();
2733     auto scope = DECLARE_CATCH_SCOPE(vm);
2734 
2735     Optional&lt;DirectoryName&gt; directoryName = currentWorkingDirectory();
2736     if (!directoryName)
</pre>
<hr />
<pre>
2749             if (!line)
2750                 break;
2751             source = source + String::fromUTF8(line);
2752             source = source + &#39;\n&#39;;
2753             checkSyntax(vm, jscSource(source, sourceOrigin), error);
2754             if (!line[0]) {
2755                 free(line);
2756                 break;
2757             }
2758             add_history(line);
2759             free(line);
2760         } while (error.syntaxErrorType() == ParserError::SyntaxErrorRecoverable);
2761 
2762         if (error.isValid()) {
2763             printf(&quot;%s:%d\n&quot;, error.message().utf8().data(), error.line());
2764             continue;
2765         }
2766 
2767 
2768         NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">2769         JSValue returnValue = evaluate(globalObject, jscSource(source, sourceOrigin), JSValue(), evaluationException);</span>
2770 #else
2771         printf(&quot;%s&quot;, interactivePrompt);
2772         Vector&lt;char, 256&gt; line;
2773         int c;
2774         while ((c = getchar()) != EOF) {
2775             // FIXME: Should we also break on \r?
2776             if (c == &#39;\n&#39;)
2777                 break;
2778             line.append(c);
2779         }
2780         if (line.isEmpty())
2781             break;
2782 
2783         NakedPtr&lt;Exception&gt; evaluationException;
<span class="line-modified">2784         JSValue returnValue = evaluate(globalObject, jscSource(line, sourceOrigin, sourceOrigin.string()), JSValue(), evaluationException);</span>
2785 #endif
2786         if (evaluationException)
<span class="line-modified">2787             printf(&quot;Exception: %s\n&quot;, evaluationException-&gt;value().toWTFString(globalObject).utf8().data());</span>
2788         else
<span class="line-modified">2789             printf(&quot;%s\n&quot;, returnValue.toWTFString(globalObject).utf8().data());</span>
2790 
2791         scope.clearException();
2792         vm.drainMicrotasks();
2793     }
2794     printf(&quot;\n&quot;);
2795 }
2796 
2797 static NO_RETURN void printUsageStatement(bool help = false)
2798 {
2799     fprintf(stderr, &quot;Usage: jsc [options] [files] [-- arguments]\n&quot;);
2800     fprintf(stderr, &quot;  -d         Dumps bytecode (debug builds only)\n&quot;);
2801     fprintf(stderr, &quot;  -e         Evaluate argument as script code\n&quot;);
2802     fprintf(stderr, &quot;  -f         Specifies a source file (deprecated)\n&quot;);
2803     fprintf(stderr, &quot;  -h|--help  Prints this help message\n&quot;);
2804     fprintf(stderr, &quot;  -i         Enables interactive mode (default if no files are specified)\n&quot;);
2805     fprintf(stderr, &quot;  -m         Execute as a module\n&quot;);
2806 #if HAVE(SIGNAL_H)
2807     fprintf(stderr, &quot;  -s         Installs signal handlers that exit on a crash (Unix platforms only)\n&quot;);
2808 #endif
2809     fprintf(stderr, &quot;  -p &lt;file&gt;  Outputs profiling data to a file\n&quot;);
</pre>
<hr />
<pre>
2916 
2917         if (!strcmp(arg, &quot;--options&quot;)) {
2918             dumpOptionsLevel = JSC::Options::DumpLevel::Verbose;
2919             needToExit = true;
2920             continue;
2921         }
2922         if (!strcmp(arg, &quot;--dumpOptions&quot;)) {
2923             dumpOptionsLevel = JSC::Options::DumpLevel::Overridden;
2924             continue;
2925         }
2926         if (!strcmp(arg, &quot;--sample&quot;)) {
2927             JSC::Options::useSamplingProfiler() = true;
2928             JSC::Options::collectSamplingProfilerDataForJSCShell() = true;
2929             m_dumpSamplingProfilerData = true;
2930             continue;
2931         }
2932         if (!strcmp(arg, &quot;--destroy-vm&quot;)) {
2933             m_destroyVM = true;
2934             continue;
2935         }
<span class="line-added">2936         if (!strcmp(arg, &quot;--disableOptionsFreezingForTesting&quot;)) {</span>
<span class="line-added">2937             Config::disableFreezingForTesting();</span>
<span class="line-added">2938             continue;</span>
<span class="line-added">2939         }</span>
2940 
2941         static const char* timeoutMultiplierOptStr = &quot;--timeoutMultiplier=&quot;;
2942         static const unsigned timeoutMultiplierOptStrLength = strlen(timeoutMultiplierOptStr);
2943         if (!strncmp(arg, timeoutMultiplierOptStr, timeoutMultiplierOptStrLength)) {
2944             const char* valueStr = &amp;arg[timeoutMultiplierOptStrLength];
2945             if (sscanf(valueStr, &quot;%lf&quot;, &amp;s_timeoutMultiplier) != 1)
2946                 dataLog(&quot;WARNING: --timeoutMultiplier=&quot;, valueStr, &quot; is invalid. Expects a numeric ratio.\n&quot;);
2947             continue;
2948         }
2949 
2950         if (!strcmp(arg, &quot;--test262-async&quot;)) {
2951             asyncTestExpectedPasses++;
2952             continue;
2953         }
2954 
2955         if (!strcmp(arg, &quot;--remote-debug&quot;)) {
2956             m_enableRemoteDebugging = true;
2957             continue;
2958         }
2959 
</pre>
<hr />
<pre>
3020             : &quot;All JSC runtime options:&quot;;
3021         JSC::Options::dumpAllOptions(stderr, dumpOptionsLevel, optionsTitle);
3022     }
3023     JSC::Options::ensureOptionsAreCoherent();
3024     if (needToExit)
3025         jscExit(EXIT_SUCCESS);
3026 }
3027 
3028 template&lt;typename Func&gt;
3029 int runJSC(const CommandLine&amp; options, bool isWorker, const Func&amp; func)
3030 {
3031     Worker worker(Workers::singleton());
3032 
3033     VM&amp; vm = VM::create(LargeHeap).leakRef();
3034     int result;
3035     bool success = true;
3036     GlobalObject* globalObject = nullptr;
3037     {
3038         JSLockHolder locker(vm);
3039 
<span class="line-added">3040         startTimeoutThreadIfNeeded(vm);</span>
3041         if (options.m_profile &amp;&amp; !vm.m_perBytecodeProfiler)
3042             vm.m_perBytecodeProfiler = makeUnique&lt;Profiler::Database&gt;(vm);
3043 
3044         globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), options.m_arguments);
3045         globalObject-&gt;setRemoteDebuggingEnabled(options.m_enableRemoteDebugging);
3046         func(vm, globalObject, success);
3047         vm.drainMicrotasks();
3048     }
<span class="line-modified">3049     vm.promiseTimer-&gt;runRunLoop();</span>
3050     {
3051         JSLockHolder locker(vm);
3052         if (options.m_interactive &amp;&amp; success)
3053             runInteractive(globalObject);
3054     }
3055 
3056     result = success &amp;&amp; (asyncTestExpectedPasses == asyncTestPasses) ? 0 : 3;
3057 
3058     if (options.m_exitCode) {
3059         printf(&quot;jsc exiting %d&quot;, result);
3060         if (asyncTestExpectedPasses != asyncTestPasses)
3061             printf(&quot; because expected: %d async test passes but got: %d async test passes&quot;, asyncTestExpectedPasses, asyncTestPasses);
3062         printf(&quot;\n&quot;);
3063     }
3064 
3065     if (options.m_profile) {
3066         JSLockHolder locker(vm);
3067         if (!vm.m_perBytecodeProfiler-&gt;save(options.m_profilerOutput.utf8().data()))
3068             fprintf(stderr, &quot;could not save profiler output.\n&quot;);
3069     }
</pre>
<hr />
<pre>
3073         JSLockHolder locker(vm);
3074         if (Options::useExceptionFuzz())
3075             printf(&quot;JSC EXCEPTION FUZZ: encountered %u checks.\n&quot;, numberOfExceptionFuzzChecks());
3076         bool fireAtEnabled =
3077         Options::fireExecutableAllocationFuzzAt() || Options::fireExecutableAllocationFuzzAtOrAfter();
3078         if (Options::useExecutableAllocationFuzz() &amp;&amp; (!fireAtEnabled || Options::verboseExecutableAllocationFuzz()))
3079             printf(&quot;JSC EXECUTABLE ALLOCATION FUZZ: encountered %u checks.\n&quot;, numberOfExecutableAllocationFuzzChecks());
3080         if (Options::useOSRExitFuzz()) {
3081             printf(&quot;JSC OSR EXIT FUZZ: encountered %u static checks.\n&quot;, numberOfStaticOSRExitFuzzChecks());
3082             printf(&quot;JSC OSR EXIT FUZZ: encountered %u dynamic checks.\n&quot;, numberOfOSRExitFuzzChecks());
3083         }
3084 
3085 
3086         auto compileTimeStats = JIT::compileTimeStats();
3087         Vector&lt;CString&gt; compileTimeKeys;
3088         for (auto&amp; entry : compileTimeStats)
3089             compileTimeKeys.append(entry.key);
3090         std::sort(compileTimeKeys.begin(), compileTimeKeys.end());
3091         for (const CString&amp; key : compileTimeKeys)
3092             printf(&quot;%40s: %.3lf ms\n&quot;, key.data(), compileTimeStats.get(key).milliseconds());
<span class="line-added">3093 </span>
<span class="line-added">3094         if (Options::reportTotalPhaseTimes())</span>
<span class="line-added">3095             logTotalPhaseTimes();</span>
3096     }
3097 #endif
3098 
3099     if (Options::gcAtEnd()) {
3100         // We need to hold the API lock to do a GC.
3101         JSLockHolder locker(&amp;vm);
3102         vm.heap.collectNow(Sync, CollectionScope::Full);
3103     }
3104 
3105     if (options.m_dumpSamplingProfilerData) {
3106 #if ENABLE(SAMPLING_PROFILER)
3107         JSLockHolder locker(&amp;vm);
3108         vm.samplingProfiler()-&gt;reportTopFunctions();
3109         vm.samplingProfiler()-&gt;reportTopBytecodes();
3110 #else
3111         dataLog(&quot;Sampling profiler is not enabled on this platform\n&quot;);
3112 #endif
3113     }
3114 
3115     vm.codeCache()-&gt;write(vm);
3116 
3117     if (options.m_destroyVM || isWorker) {
3118         JSLockHolder locker(vm);
3119         // This is needed because we don&#39;t want the worker&#39;s main
3120         // thread to die before its compilation threads finish.
3121         vm.deref();
3122     }
3123 
3124     return result;
3125 }
3126 
3127 int jscmain(int argc, char** argv)
3128 {
3129     // Need to override and enable restricted options before we start parsing options below.
<span class="line-modified">3130     Config::enableRestrictedOptions();</span>
3131 
3132     WTF::initializeMainThread();
3133 
3134     // Note that the options parsing can affect VM creation, and thus
3135     // comes first.
3136     CommandLine options(argc, argv);
3137 
3138     processConfigFile(Options::configFile(), &quot;jsc&quot;);
<span class="line-added">3139     if (options.m_dump)</span>
<span class="line-added">3140         JSC::Options::dumpGeneratedBytecodes() = true;</span>
3141 
3142     // Initialize JSC before getting VM.
3143     JSC::initializeThreading();
<span class="line-modified">3144     initializeTimeoutIfNeeded();</span>
3145 #if ENABLE(WEBASSEMBLY)
3146     JSC::Wasm::enableFastMemory();
3147 #endif
<span class="line-modified">3148 </span>
<span class="line-added">3149     bool gigacageDisableRequested = false;</span>
<span class="line-added">3150 #if GIGACAGE_ENABLED &amp;&amp; !COMPILER(MSVC)</span>
<span class="line-added">3151     if (char* gigacageEnabled = getenv(&quot;GIGACAGE_ENABLED&quot;)) {</span>
<span class="line-added">3152         if (!strcasecmp(gigacageEnabled, &quot;no&quot;) || !strcasecmp(gigacageEnabled, &quot;false&quot;) || !strcasecmp(gigacageEnabled, &quot;0&quot;))</span>
<span class="line-added">3153             gigacageDisableRequested = true;</span>
<span class="line-added">3154     }</span>
<span class="line-added">3155 #endif</span>
<span class="line-added">3156     if (!gigacageDisableRequested)</span>
<span class="line-added">3157         Gigacage::forbidDisablingPrimitiveGigacage();</span>
3158 
3159 #if PLATFORM(COCOA)
3160     auto&amp; memoryPressureHandler = MemoryPressureHandler::singleton();
3161     {
3162         dispatch_queue_t queue = dispatch_queue_create(&quot;jsc shell memory pressure handler&quot;, DISPATCH_QUEUE_SERIAL);
3163         memoryPressureHandler.setDispatchQueue(queue);
3164         dispatch_release(queue);
3165     }
3166     Box&lt;Critical&gt; memoryPressureCriticalState = Box&lt;Critical&gt;::create(Critical::No);
3167     Box&lt;Synchronous&gt; memoryPressureSynchronousState = Box&lt;Synchronous&gt;::create(Synchronous::No);
3168     memoryPressureHandler.setLowMemoryHandler([=] (Critical critical, Synchronous synchronous) {
3169         // We set these racily with respect to reading them from the JS execution thread.
3170         *memoryPressureCriticalState = critical;
3171         *memoryPressureSynchronousState = synchronous;
3172     });
3173     memoryPressureHandler.setShouldLogMemoryMemoryPressureEvents(false);
3174     memoryPressureHandler.install();
3175 
3176     auto onEachMicrotaskTick = [&amp;] (VM&amp; vm) {
3177         if (*memoryPressureCriticalState == Critical::No)
</pre>
</td>
</tr>
</table>
<center><a href="jit/UnusedPointer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="llint/LLIntData.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
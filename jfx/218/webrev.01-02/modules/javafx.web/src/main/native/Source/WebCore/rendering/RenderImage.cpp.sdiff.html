<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderImage.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderGrid.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderImage.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderImage.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
228         return true;
229 
230     return false;
231 }
232 
233 void RenderImage::styleWillChange(StyleDifference diff, const RenderStyle&amp; newStyle)
234 {
235     if (!hasInitializedStyle())
236         imageResource().initialize(*this);
237     RenderReplaced::styleWillChange(diff, newStyle);
238 }
239 
240 void RenderImage::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
241 {
242     RenderReplaced::styleDidChange(diff, oldStyle);
243     if (m_needsToSetSizeForAltText) {
244         if (!m_altText.isEmpty() &amp;&amp; setImageSizeForAltText(cachedImage()))
245             repaintOrMarkForLayout(ImageSizeChangeForAltText);
246         m_needsToSetSizeForAltText = false;
247     }
<span class="line-removed">248 #if ENABLE(CSS_IMAGE_ORIENTATION)</span>
249     if (diff == StyleDifference::Layout &amp;&amp; oldStyle-&gt;imageOrientation() != style().imageOrientation())
250         return repaintOrMarkForLayout(ImageSizeChangeNone);
<span class="line-removed">251 #endif</span>
252 
253 #if ENABLE(CSS_IMAGE_RESOLUTION)
254     if (diff == StyleDifference::Layout
255         &amp;&amp; (oldStyle-&gt;imageResolution() != style().imageResolution()
256             || oldStyle-&gt;imageResolutionSnap() != style().imageResolutionSnap()
257             || oldStyle-&gt;imageResolutionSource() != style().imageResolutionSource()))
258         repaintOrMarkForLayout(ImageSizeChangeNone);
259 #endif
260 }
261 
262 void RenderImage::imageChanged(WrappedImagePtr newImage, const IntRect* rect)
263 {
264     if (renderTreeBeingDestroyed())
265         return;
266 
267     if (hasVisibleBoxDecorations() || hasMask() || hasShapeOutside())
268         RenderReplaced::imageChanged(newImage, rect);
269 
270     if (newImage != imageResource().imagePtr() || !newImage)
271         return;
</pre>
<hr />
<pre>
363     contentChanged(ImageChanged);
364 }
365 
366 void RenderImage::notifyFinished(CachedResource&amp; newImage)
367 {
368     if (renderTreeBeingDestroyed())
369         return;
370 
371     invalidateBackgroundObscurationStatus();
372 
373     if (&amp;newImage == cachedImage()) {
374         // tell any potential compositing layers
375         // that the image is done and they can reference it directly.
376         contentChanged(ImageChanged);
377     }
378 
379     if (is&lt;HTMLImageElement&gt;(element()))
380         page().didFinishLoadingImageForElement(downcast&lt;HTMLImageElement&gt;(*element()));
381 }
382 









383 bool RenderImage::isShowingMissingOrImageError() const
384 {
385     return !imageResource().cachedImage() || imageResource().errorOccurred();
386 }
387 
388 bool RenderImage::isShowingAltText() const
389 {
390     return isShowingMissingOrImageError() &amp;&amp; !m_altText.isEmpty();
391 }
392 





393 bool RenderImage::hasNonBitmapImage() const
394 {
395     if (!imageResource().cachedImage())
396         return false;
397 
398     Image* image = cachedImage()-&gt;imageForRenderer(this);
399     return image &amp;&amp; !is&lt;BitmapImage&gt;(image);
400 }
401 
402 void RenderImage::paintIncompleteImageOutline(PaintInfo&amp; paintInfo, LayoutPoint paintOffset, LayoutUnit borderWidth) const
403 {
404     auto contentSize = this-&gt;contentSize();
405     if (contentSize.width() &lt;= 2 || contentSize.height() &lt;= 2)
406         return;
407 
408     auto leftBorder = borderLeft();
409     auto topBorder = borderTop();
410     auto leftPadding = paddingLeft();
411     auto topPadding = paddingTop();
412 
</pre>
<hr />
<pre>
414     GraphicsContext&amp; context = paintInfo.context();
415     context.setStrokeStyle(SolidStroke);
416     context.setStrokeColor(Color::lightGray);
417     context.setFillColor(Color::transparent);
418     context.drawRect(snapRectToDevicePixels(LayoutRect({ paintOffset.x() + leftBorder + leftPadding, paintOffset.y() + topBorder + topPadding }, contentSize), document().deviceScaleFactor()), borderWidth);
419 }
420 
421 void RenderImage::paintReplaced(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
422 {
423     GraphicsContext&amp; context = paintInfo.context();
424     if (context.invalidatingImagesWithAsyncDecodes()) {
425         if (cachedImage() &amp;&amp; cachedImage()-&gt;isClientWaitingForAsyncDecoding(*this))
426             cachedImage()-&gt;removeAllClientsWaitingForAsyncDecoding();
427         return;
428     }
429 
430     auto contentSize = this-&gt;contentSize();
431     float deviceScaleFactor = document().deviceScaleFactor();
432     LayoutUnit missingImageBorderWidth(1 / deviceScaleFactor);
433 
<span class="line-modified">434     if (!imageResource().cachedImage() || imageResource().errorOccurred()) {</span>
435         if (paintInfo.phase == PaintPhase::Selection)
436             return;
437 
438         if (paintInfo.phase == PaintPhase::Foreground)
439             page().addRelevantUnpaintedObject(this, visualOverflowRect());
440 
441         paintIncompleteImageOutline(paintInfo, paintOffset, missingImageBorderWidth);
442 
443         if (contentSize.width() &gt; 2 &amp;&amp; contentSize.height() &gt; 2) {
444             LayoutUnit leftBorder = borderLeft();
445             LayoutUnit topBorder = borderTop();
446             LayoutUnit leftPad = paddingLeft();
447             LayoutUnit topPad = paddingTop();
448 
449             bool errorPictureDrawn = false;
450             LayoutSize imageOffset;
451             // When calculating the usable dimensions, exclude the pixels of
<span class="line-modified">452             // the ouline rect so the error image/alt text doesn&#39;t draw on it.</span>
453             LayoutSize usableSize = contentSize - LayoutSize(2 * missingImageBorderWidth, 2 * missingImageBorderWidth);
454 
455             RefPtr&lt;Image&gt; image = imageResource().image();
456 
<span class="line-modified">457             if (imageResource().errorOccurred() &amp;&amp; !image-&gt;isNull() &amp;&amp; usableSize.width() &gt;= image-&gt;width() &amp;&amp; usableSize.height() &gt;= image-&gt;height()) {</span>
458                 // Call brokenImage() explicitly to ensure we get the broken image icon at the appropriate resolution.
459                 std::pair&lt;Image*, float&gt; brokenImageAndImageScaleFactor = cachedImage()-&gt;brokenImage(deviceScaleFactor);
460                 image = brokenImageAndImageScaleFactor.first;
461                 FloatSize imageSize = image-&gt;size();
462                 imageSize.scale(1 / brokenImageAndImageScaleFactor.second);

463                 // Center the error image, accounting for border and padding.
464                 LayoutUnit centerX { (usableSize.width() - imageSize.width()) / 2 };
465                 if (centerX &lt; 0)
466                     centerX = 0;
467                 LayoutUnit centerY { (usableSize.height() - imageSize.height()) / 2 };
468                 if (centerY &lt; 0)
469                     centerY = 0;
470                 imageOffset = LayoutSize(leftBorder + leftPad + centerX + missingImageBorderWidth, topBorder + topPad + centerY + missingImageBorderWidth);
471 
472                 context.drawImage(*image, snapRectToDevicePixels(LayoutRect(paintOffset + imageOffset, imageSize), deviceScaleFactor), { imageOrientation() });
473                 errorPictureDrawn = true;
474             }
475 
476             if (!m_altText.isEmpty()) {
477                 String text = document().displayStringModifiedByEncoding(m_altText);
478                 context.setFillColor(style().visitedDependentColorWithColorFilter(CSSPropertyColor));
479                 const FontCascade&amp; font = style().fontCascade();
480                 const FontMetrics&amp; fontMetrics = font.fontMetrics();
481                 LayoutUnit ascent = fontMetrics.ascent();
482                 LayoutPoint altTextOffset = paintOffset;
</pre>
<hr />
<pre>
600 void RenderImage::areaElementFocusChanged(HTMLAreaElement* element)
601 {
602     ASSERT_UNUSED(element, element-&gt;imageElement() == this-&gt;element());
603 
604     // It would be more efficient to only repaint the focus ring rectangle
605     // for the passed-in area element. That would require adding functions
606     // to the area element class.
607     repaint();
608 }
609 
610 ImageDrawResult RenderImage::paintIntoRect(PaintInfo&amp; paintInfo, const FloatRect&amp; rect)
611 {
612     if (!imageResource().cachedImage() || imageResource().errorOccurred() || rect.width() &lt;= 0 || rect.height() &lt;= 0)
613         return ImageDrawResult::DidNothing;
614 
615     RefPtr&lt;Image&gt; img = imageResource().image(flooredIntSize(rect.size()));
616     if (!img || img-&gt;isNull())
617         return ImageDrawResult::DidNothing;
618 
619     HTMLImageElement* imageElement = is&lt;HTMLImageElement&gt;(element()) ? downcast&lt;HTMLImageElement&gt;(element()) : nullptr;
<span class="line-removed">620     CompositeOperator compositeOperator = imageElement ? imageElement-&gt;compositeOperator() : CompositeSourceOver;</span>
621 
622     // FIXME: Document when image != img.get().
623     Image* image = imageResource().image().get();
<span class="line-removed">624     InterpolationQuality interpolation = image ? chooseInterpolationQuality(paintInfo.context(), *image, image, LayoutSize(rect.size())) : InterpolationDefault;</span>
625 
626 #if USE(CG)
627     if (is&lt;PDFDocumentImage&gt;(image))
628         downcast&lt;PDFDocumentImage&gt;(*image).setPdfImageCachingPolicy(settings().pdfImageCachingPolicy());
629 #endif
630 
631     if (is&lt;BitmapImage&gt;(image))
632         downcast&lt;BitmapImage&gt;(*image).updateFromSettings(settings());
633 
<span class="line-modified">634     auto decodingMode = decodingModeForImageDraw(*image, paintInfo);</span>
<span class="line-modified">635     auto drawResult = paintInfo.context().drawImage(*img, rect, { compositeOperator, BlendMode::Normal, decodingMode, imageOrientation(), interpolation });</span>






636     if (drawResult == ImageDrawResult::DidRequestDecoding)
637         imageResource().cachedImage()-&gt;addClientWaitingForAsyncDecoding(*this);
638 
639 #if USE(SYSTEM_PREVIEW)
640     if (imageElement &amp;&amp; imageElement-&gt;isSystemPreviewImage() &amp;&amp; drawResult == ImageDrawResult::DidDraw &amp;&amp; RuntimeEnabledFeatures::sharedFeatures().systemPreviewEnabled())
641         theme().paintSystemPreviewBadge(*img, paintInfo, rect);
642 #endif
643 
644     return drawResult;
645 }
646 
647 bool RenderImage::boxShadowShouldBeAppliedToBackground(const LayoutPoint&amp; paintOffset, BackgroundBleedAvoidance bleedAvoidance, InlineFlowBox*) const
648 {
649     if (!RenderBoxModelObject::boxShadowShouldBeAppliedToBackground(paintOffset, bleedAvoidance))
650         return false;
651 
652     return !const_cast&lt;RenderImage*&gt;(this)-&gt;backgroundIsKnownToBeObscured(paintOffset);
653 }
654 
655 bool RenderImage::foregroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect, unsigned maxDepthToTest) const
</pre>
<hr />
<pre>
802     }
803 
804     controlsRenderer-&gt;setNeedsLayout(MarkOnlyThis);
805     controlsRenderer-&gt;layout();
806     clearChildNeedsLayout();
807 }
808 
809 void RenderImage::computeIntrinsicRatioInformation(FloatSize&amp; intrinsicSize, double&amp; intrinsicRatio) const
810 {
811     RenderReplaced::computeIntrinsicRatioInformation(intrinsicSize, intrinsicRatio);
812 
813     // Our intrinsicSize is empty if we&#39;re rendering generated images with relative width/height. Figure out the right intrinsic size to use.
814     if (intrinsicSize.isEmpty() &amp;&amp; (imageResource().imageHasRelativeWidth() || imageResource().imageHasRelativeHeight())) {
815         RenderObject* containingBlock = isOutOfFlowPositioned() ? container() : this-&gt;containingBlock();
816         if (is&lt;RenderBox&gt;(*containingBlock)) {
817             auto&amp; box = downcast&lt;RenderBox&gt;(*containingBlock);
818             intrinsicSize.setWidth(box.availableLogicalWidth());
819             intrinsicSize.setHeight(box.availableLogicalHeight(IncludeMarginBorderPadding));
820         }
821     }

822     // Don&#39;t compute an intrinsic ratio to preserve historical WebKit behavior if we&#39;re painting alt text and/or a broken image.
<span class="line-modified">823     if (imageResource().errorOccurred()) {</span>
824         intrinsicRatio = 1;
825         return;
826     }
827 }
828 
829 bool RenderImage::needsPreferredWidthsRecalculation() const
830 {
831     if (RenderReplaced::needsPreferredWidthsRecalculation())
832         return true;
833     return embeddedContentBox();
834 }
835 
836 RenderBox* RenderImage::embeddedContentBox() const
837 {
838     CachedImage* cachedImage = this-&gt;cachedImage();
839     if (cachedImage &amp;&amp; is&lt;SVGImage&gt;(cachedImage-&gt;image()))
840         return downcast&lt;SVGImage&gt;(*cachedImage-&gt;image()).embeddedContentBox();
841 
842     return nullptr;
843 }
</pre>
</td>
<td>
<hr />
<pre>
228         return true;
229 
230     return false;
231 }
232 
233 void RenderImage::styleWillChange(StyleDifference diff, const RenderStyle&amp; newStyle)
234 {
235     if (!hasInitializedStyle())
236         imageResource().initialize(*this);
237     RenderReplaced::styleWillChange(diff, newStyle);
238 }
239 
240 void RenderImage::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
241 {
242     RenderReplaced::styleDidChange(diff, oldStyle);
243     if (m_needsToSetSizeForAltText) {
244         if (!m_altText.isEmpty() &amp;&amp; setImageSizeForAltText(cachedImage()))
245             repaintOrMarkForLayout(ImageSizeChangeForAltText);
246         m_needsToSetSizeForAltText = false;
247     }

248     if (diff == StyleDifference::Layout &amp;&amp; oldStyle-&gt;imageOrientation() != style().imageOrientation())
249         return repaintOrMarkForLayout(ImageSizeChangeNone);

250 
251 #if ENABLE(CSS_IMAGE_RESOLUTION)
252     if (diff == StyleDifference::Layout
253         &amp;&amp; (oldStyle-&gt;imageResolution() != style().imageResolution()
254             || oldStyle-&gt;imageResolutionSnap() != style().imageResolutionSnap()
255             || oldStyle-&gt;imageResolutionSource() != style().imageResolutionSource()))
256         repaintOrMarkForLayout(ImageSizeChangeNone);
257 #endif
258 }
259 
260 void RenderImage::imageChanged(WrappedImagePtr newImage, const IntRect* rect)
261 {
262     if (renderTreeBeingDestroyed())
263         return;
264 
265     if (hasVisibleBoxDecorations() || hasMask() || hasShapeOutside())
266         RenderReplaced::imageChanged(newImage, rect);
267 
268     if (newImage != imageResource().imagePtr() || !newImage)
269         return;
</pre>
<hr />
<pre>
361     contentChanged(ImageChanged);
362 }
363 
364 void RenderImage::notifyFinished(CachedResource&amp; newImage)
365 {
366     if (renderTreeBeingDestroyed())
367         return;
368 
369     invalidateBackgroundObscurationStatus();
370 
371     if (&amp;newImage == cachedImage()) {
372         // tell any potential compositing layers
373         // that the image is done and they can reference it directly.
374         contentChanged(ImageChanged);
375     }
376 
377     if (is&lt;HTMLImageElement&gt;(element()))
378         page().didFinishLoadingImageForElement(downcast&lt;HTMLImageElement&gt;(*element()));
379 }
380 
<span class="line-added">381 void RenderImage::setImageDevicePixelRatio(float factor)</span>
<span class="line-added">382 {</span>
<span class="line-added">383     if (m_imageDevicePixelRatio == factor)</span>
<span class="line-added">384         return;</span>
<span class="line-added">385 </span>
<span class="line-added">386     m_imageDevicePixelRatio = factor;</span>
<span class="line-added">387     intrinsicSizeChanged();</span>
<span class="line-added">388 }</span>
<span class="line-added">389 </span>
390 bool RenderImage::isShowingMissingOrImageError() const
391 {
392     return !imageResource().cachedImage() || imageResource().errorOccurred();
393 }
394 
395 bool RenderImage::isShowingAltText() const
396 {
397     return isShowingMissingOrImageError() &amp;&amp; !m_altText.isEmpty();
398 }
399 
<span class="line-added">400 bool RenderImage::shouldDisplayBrokenImageIcon() const</span>
<span class="line-added">401 {</span>
<span class="line-added">402     return imageResource().errorOccurred();</span>
<span class="line-added">403 }</span>
<span class="line-added">404 </span>
405 bool RenderImage::hasNonBitmapImage() const
406 {
407     if (!imageResource().cachedImage())
408         return false;
409 
410     Image* image = cachedImage()-&gt;imageForRenderer(this);
411     return image &amp;&amp; !is&lt;BitmapImage&gt;(image);
412 }
413 
414 void RenderImage::paintIncompleteImageOutline(PaintInfo&amp; paintInfo, LayoutPoint paintOffset, LayoutUnit borderWidth) const
415 {
416     auto contentSize = this-&gt;contentSize();
417     if (contentSize.width() &lt;= 2 || contentSize.height() &lt;= 2)
418         return;
419 
420     auto leftBorder = borderLeft();
421     auto topBorder = borderTop();
422     auto leftPadding = paddingLeft();
423     auto topPadding = paddingTop();
424 
</pre>
<hr />
<pre>
426     GraphicsContext&amp; context = paintInfo.context();
427     context.setStrokeStyle(SolidStroke);
428     context.setStrokeColor(Color::lightGray);
429     context.setFillColor(Color::transparent);
430     context.drawRect(snapRectToDevicePixels(LayoutRect({ paintOffset.x() + leftBorder + leftPadding, paintOffset.y() + topBorder + topPadding }, contentSize), document().deviceScaleFactor()), borderWidth);
431 }
432 
433 void RenderImage::paintReplaced(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
434 {
435     GraphicsContext&amp; context = paintInfo.context();
436     if (context.invalidatingImagesWithAsyncDecodes()) {
437         if (cachedImage() &amp;&amp; cachedImage()-&gt;isClientWaitingForAsyncDecoding(*this))
438             cachedImage()-&gt;removeAllClientsWaitingForAsyncDecoding();
439         return;
440     }
441 
442     auto contentSize = this-&gt;contentSize();
443     float deviceScaleFactor = document().deviceScaleFactor();
444     LayoutUnit missingImageBorderWidth(1 / deviceScaleFactor);
445 
<span class="line-modified">446     if (!imageResource().cachedImage() || shouldDisplayBrokenImageIcon()) {</span>
447         if (paintInfo.phase == PaintPhase::Selection)
448             return;
449 
450         if (paintInfo.phase == PaintPhase::Foreground)
451             page().addRelevantUnpaintedObject(this, visualOverflowRect());
452 
453         paintIncompleteImageOutline(paintInfo, paintOffset, missingImageBorderWidth);
454 
455         if (contentSize.width() &gt; 2 &amp;&amp; contentSize.height() &gt; 2) {
456             LayoutUnit leftBorder = borderLeft();
457             LayoutUnit topBorder = borderTop();
458             LayoutUnit leftPad = paddingLeft();
459             LayoutUnit topPad = paddingTop();
460 
461             bool errorPictureDrawn = false;
462             LayoutSize imageOffset;
463             // When calculating the usable dimensions, exclude the pixels of
<span class="line-modified">464             // the outline rect so the error image/alt text doesn&#39;t draw on it.</span>
465             LayoutSize usableSize = contentSize - LayoutSize(2 * missingImageBorderWidth, 2 * missingImageBorderWidth);
466 
467             RefPtr&lt;Image&gt; image = imageResource().image();
468 
<span class="line-modified">469             if (shouldDisplayBrokenImageIcon() &amp;&amp; !image-&gt;isNull() &amp;&amp; usableSize.width() &gt;= image-&gt;width() &amp;&amp; usableSize.height() &gt;= image-&gt;height()) {</span>
470                 // Call brokenImage() explicitly to ensure we get the broken image icon at the appropriate resolution.
471                 std::pair&lt;Image*, float&gt; brokenImageAndImageScaleFactor = cachedImage()-&gt;brokenImage(deviceScaleFactor);
472                 image = brokenImageAndImageScaleFactor.first;
473                 FloatSize imageSize = image-&gt;size();
474                 imageSize.scale(1 / brokenImageAndImageScaleFactor.second);
<span class="line-added">475 </span>
476                 // Center the error image, accounting for border and padding.
477                 LayoutUnit centerX { (usableSize.width() - imageSize.width()) / 2 };
478                 if (centerX &lt; 0)
479                     centerX = 0;
480                 LayoutUnit centerY { (usableSize.height() - imageSize.height()) / 2 };
481                 if (centerY &lt; 0)
482                     centerY = 0;
483                 imageOffset = LayoutSize(leftBorder + leftPad + centerX + missingImageBorderWidth, topBorder + topPad + centerY + missingImageBorderWidth);
484 
485                 context.drawImage(*image, snapRectToDevicePixels(LayoutRect(paintOffset + imageOffset, imageSize), deviceScaleFactor), { imageOrientation() });
486                 errorPictureDrawn = true;
487             }
488 
489             if (!m_altText.isEmpty()) {
490                 String text = document().displayStringModifiedByEncoding(m_altText);
491                 context.setFillColor(style().visitedDependentColorWithColorFilter(CSSPropertyColor));
492                 const FontCascade&amp; font = style().fontCascade();
493                 const FontMetrics&amp; fontMetrics = font.fontMetrics();
494                 LayoutUnit ascent = fontMetrics.ascent();
495                 LayoutPoint altTextOffset = paintOffset;
</pre>
<hr />
<pre>
613 void RenderImage::areaElementFocusChanged(HTMLAreaElement* element)
614 {
615     ASSERT_UNUSED(element, element-&gt;imageElement() == this-&gt;element());
616 
617     // It would be more efficient to only repaint the focus ring rectangle
618     // for the passed-in area element. That would require adding functions
619     // to the area element class.
620     repaint();
621 }
622 
623 ImageDrawResult RenderImage::paintIntoRect(PaintInfo&amp; paintInfo, const FloatRect&amp; rect)
624 {
625     if (!imageResource().cachedImage() || imageResource().errorOccurred() || rect.width() &lt;= 0 || rect.height() &lt;= 0)
626         return ImageDrawResult::DidNothing;
627 
628     RefPtr&lt;Image&gt; img = imageResource().image(flooredIntSize(rect.size()));
629     if (!img || img-&gt;isNull())
630         return ImageDrawResult::DidNothing;
631 
632     HTMLImageElement* imageElement = is&lt;HTMLImageElement&gt;(element()) ? downcast&lt;HTMLImageElement&gt;(element()) : nullptr;

633 
634     // FIXME: Document when image != img.get().
635     Image* image = imageResource().image().get();

636 
637 #if USE(CG)
638     if (is&lt;PDFDocumentImage&gt;(image))
639         downcast&lt;PDFDocumentImage&gt;(*image).setPdfImageCachingPolicy(settings().pdfImageCachingPolicy());
640 #endif
641 
642     if (is&lt;BitmapImage&gt;(image))
643         downcast&lt;BitmapImage&gt;(*image).updateFromSettings(settings());
644 
<span class="line-modified">645     ImagePaintingOptions options = {</span>
<span class="line-modified">646         imageElement ? imageElement-&gt;compositeOperator() : CompositeOperator::SourceOver,</span>
<span class="line-added">647         decodingModeForImageDraw(*image, paintInfo),</span>
<span class="line-added">648         imageOrientation(),</span>
<span class="line-added">649         image ? chooseInterpolationQuality(paintInfo.context(), *image, image, LayoutSize(rect.size())) : InterpolationQuality::Default</span>
<span class="line-added">650     };</span>
<span class="line-added">651 </span>
<span class="line-added">652     auto drawResult = paintInfo.context().drawImage(*img, rect, options);</span>
653     if (drawResult == ImageDrawResult::DidRequestDecoding)
654         imageResource().cachedImage()-&gt;addClientWaitingForAsyncDecoding(*this);
655 
656 #if USE(SYSTEM_PREVIEW)
657     if (imageElement &amp;&amp; imageElement-&gt;isSystemPreviewImage() &amp;&amp; drawResult == ImageDrawResult::DidDraw &amp;&amp; RuntimeEnabledFeatures::sharedFeatures().systemPreviewEnabled())
658         theme().paintSystemPreviewBadge(*img, paintInfo, rect);
659 #endif
660 
661     return drawResult;
662 }
663 
664 bool RenderImage::boxShadowShouldBeAppliedToBackground(const LayoutPoint&amp; paintOffset, BackgroundBleedAvoidance bleedAvoidance, InlineFlowBox*) const
665 {
666     if (!RenderBoxModelObject::boxShadowShouldBeAppliedToBackground(paintOffset, bleedAvoidance))
667         return false;
668 
669     return !const_cast&lt;RenderImage*&gt;(this)-&gt;backgroundIsKnownToBeObscured(paintOffset);
670 }
671 
672 bool RenderImage::foregroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect, unsigned maxDepthToTest) const
</pre>
<hr />
<pre>
819     }
820 
821     controlsRenderer-&gt;setNeedsLayout(MarkOnlyThis);
822     controlsRenderer-&gt;layout();
823     clearChildNeedsLayout();
824 }
825 
826 void RenderImage::computeIntrinsicRatioInformation(FloatSize&amp; intrinsicSize, double&amp; intrinsicRatio) const
827 {
828     RenderReplaced::computeIntrinsicRatioInformation(intrinsicSize, intrinsicRatio);
829 
830     // Our intrinsicSize is empty if we&#39;re rendering generated images with relative width/height. Figure out the right intrinsic size to use.
831     if (intrinsicSize.isEmpty() &amp;&amp; (imageResource().imageHasRelativeWidth() || imageResource().imageHasRelativeHeight())) {
832         RenderObject* containingBlock = isOutOfFlowPositioned() ? container() : this-&gt;containingBlock();
833         if (is&lt;RenderBox&gt;(*containingBlock)) {
834             auto&amp; box = downcast&lt;RenderBox&gt;(*containingBlock);
835             intrinsicSize.setWidth(box.availableLogicalWidth());
836             intrinsicSize.setHeight(box.availableLogicalHeight(IncludeMarginBorderPadding));
837         }
838     }
<span class="line-added">839 </span>
840     // Don&#39;t compute an intrinsic ratio to preserve historical WebKit behavior if we&#39;re painting alt text and/or a broken image.
<span class="line-modified">841     if (shouldDisplayBrokenImageIcon()) {</span>
842         intrinsicRatio = 1;
843         return;
844     }
845 }
846 
847 bool RenderImage::needsPreferredWidthsRecalculation() const
848 {
849     if (RenderReplaced::needsPreferredWidthsRecalculation())
850         return true;
851     return embeddedContentBox();
852 }
853 
854 RenderBox* RenderImage::embeddedContentBox() const
855 {
856     CachedImage* cachedImage = this-&gt;cachedImage();
857     if (cachedImage &amp;&amp; is&lt;SVGImage&gt;(cachedImage-&gt;image()))
858         return downcast&lt;SVGImage&gt;(*cachedImage-&gt;image()).embeddedContentBox();
859 
860     return nullptr;
861 }
</pre>
</td>
</tr>
</table>
<center><a href="RenderGrid.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderImage.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
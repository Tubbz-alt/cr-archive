<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/messageports/MessagePortChannel.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../make_names.pl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MessagePortChannel.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/messageports/MessagePortChannel.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
130 
131 bool MessagePortChannel::postMessageToRemote(MessageWithMessagePorts&amp;&amp; message, const MessagePortIdentifier&amp; remoteTarget)
132 {
133     ASSERT(isMainThread());
134 
135     ASSERT(remoteTarget == m_ports[0] || remoteTarget == m_ports[1]);
136     size_t i = remoteTarget == m_ports[0] ? 0 : 1;
137 
138     m_pendingMessages[i].append(WTFMove(message));
139     LOG(MessagePorts, &quot;MessagePortChannel %s (%p) now has %zu messages pending on port %s&quot;, logString().utf8().data(), this, m_pendingMessages[i].size(), remoteTarget.logString().utf8().data());
140 
141     if (m_pendingMessages[i].size() == 1) {
142         m_pendingMessageProtectors[i] = this;
143         return true;
144     }
145 
146     ASSERT(m_pendingMessageProtectors[i] == this);
147     return false;
148 }
149 
<span class="line-modified">150 void MessagePortChannel::takeAllMessagesForPort(const MessagePortIdentifier&amp; port, Function&lt;void(Vector&lt;MessageWithMessagePorts&gt;&amp;&amp;, Function&lt;void()&gt;&amp;&amp;)&gt;&amp;&amp; callback)</span>
151 {
152     ASSERT(isMainThread());
153 
154     LOG(MessagePorts, &quot;MessagePortChannel %p taking all messages for port %s&quot;, this, port.logString().utf8().data());
155 
156     ASSERT(port == m_ports[0] || port == m_ports[1]);
157     size_t i = port == m_ports[0] ? 0 : 1;
158 
159     if (m_pendingMessages[i].isEmpty()) {
160         callback({ }, [] { });
161         return;
162     }
163 
164     ASSERT(m_pendingMessageProtectors[i]);
165 
166     Vector&lt;MessageWithMessagePorts&gt; result;
167     result.swap(m_pendingMessages[i]);
168 
169     ++m_messageBatchesInFlight;
170 
171     LOG(MessagePorts, &quot;There are %zu messages to take for port %s. Taking them now, messages in flight is now %&quot; PRIu64, result.size(), port.logString().utf8().data(), m_messageBatchesInFlight);
172 
173     auto size = result.size();
174     callback(WTFMove(result), [size, this, port, protectedThis = WTFMove(m_pendingMessageProtectors[i])] {
175         UNUSED_PARAM(port);
176 #if LOG_DISABLED
177         UNUSED_PARAM(size);
178 #endif
179         --m_messageBatchesInFlight;
180         LOG(MessagePorts, &quot;Message port channel %s was notified that a batch of %zu message port messages targeted for port %s just completed dispatch, in flight is now %&quot; PRIu64, logString().utf8().data(), size, port.logString().utf8().data(), m_messageBatchesInFlight);
181 
182     });
183 }
184 
<span class="line-modified">185 void MessagePortChannel::checkRemotePortForActivity(const MessagePortIdentifier&amp; remotePort, Function&lt;void(MessagePortChannelProvider::HasActivity)&gt;&amp;&amp; callback)</span>
186 {
187     ASSERT(isMainThread());
188     ASSERT(remotePort == m_ports[0] || remotePort == m_ports[1]);
189 
190     // If the remote port is closed there is no pending activity.
191     size_t i = remotePort == m_ports[0] ? 0 : 1;
192     if (m_isClosed[i]) {
193         callback(MessagePortChannelProvider::HasActivity::No);
194         return;
195     }
196 
197     // If there are any messages in flight between the ports, there is pending activity.
198     if (hasAnyMessagesPendingOrInFlight()) {
199         callback(MessagePortChannelProvider::HasActivity::Yes);
200         return;
201     }
202 
203     // If the port is not currently in a process then it&#39;s being transferred as part of a postMessage.
204     // We treat these ports as if they do have activity since they will be revived when the message is delivered.
205     if (!m_processes[i]) {
206         callback(MessagePortChannelProvider::HasActivity::Yes);
207         return;
208     }
209 
<span class="line-modified">210     auto outerCallback = Function&lt;void(MessagePortChannelProvider::HasActivity)&gt; { [this, protectedThis = makeRef(*this), callback = WTFMove(callback)] (MessagePortChannelProvider::HasActivity hasActivity) mutable {</span>
211         if (hasActivity == MessagePortChannelProvider::HasActivity::Yes) {
212             callback(hasActivity);
213             return;
214         }
215 
216         // If the remote port said it had no activity, check again for any messages that might be in flight.
217         // This is because it might have asynchronously sent a message just before it was asked about local activity.
218         if (hasAnyMessagesPendingOrInFlight())
219             hasActivity = MessagePortChannelProvider::HasActivity::Yes;
220 
221         callback(hasActivity);
<span class="line-modified">222     } };</span>
223 
<span class="line-modified">224     m_registry.provider().checkProcessLocalPortForActivity(remotePort, *m_processes[i], WTFMove(outerCallback));</span>
225 }
226 
227 bool MessagePortChannel::hasAnyMessagesPendingOrInFlight() const
228 {
229     ASSERT(isMainThread());
230     return m_messageBatchesInFlight || !m_pendingMessages[0].isEmpty() || !m_pendingMessages[1].isEmpty();
231 }
232 
233 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
130 
131 bool MessagePortChannel::postMessageToRemote(MessageWithMessagePorts&amp;&amp; message, const MessagePortIdentifier&amp; remoteTarget)
132 {
133     ASSERT(isMainThread());
134 
135     ASSERT(remoteTarget == m_ports[0] || remoteTarget == m_ports[1]);
136     size_t i = remoteTarget == m_ports[0] ? 0 : 1;
137 
138     m_pendingMessages[i].append(WTFMove(message));
139     LOG(MessagePorts, &quot;MessagePortChannel %s (%p) now has %zu messages pending on port %s&quot;, logString().utf8().data(), this, m_pendingMessages[i].size(), remoteTarget.logString().utf8().data());
140 
141     if (m_pendingMessages[i].size() == 1) {
142         m_pendingMessageProtectors[i] = this;
143         return true;
144     }
145 
146     ASSERT(m_pendingMessageProtectors[i] == this);
147     return false;
148 }
149 
<span class="line-modified">150 void MessagePortChannel::takeAllMessagesForPort(const MessagePortIdentifier&amp; port, CompletionHandler&lt;void(Vector&lt;MessageWithMessagePorts&gt;&amp;&amp;, Function&lt;void()&gt;&amp;&amp;)&gt;&amp;&amp; callback)</span>
151 {
152     ASSERT(isMainThread());
153 
154     LOG(MessagePorts, &quot;MessagePortChannel %p taking all messages for port %s&quot;, this, port.logString().utf8().data());
155 
156     ASSERT(port == m_ports[0] || port == m_ports[1]);
157     size_t i = port == m_ports[0] ? 0 : 1;
158 
159     if (m_pendingMessages[i].isEmpty()) {
160         callback({ }, [] { });
161         return;
162     }
163 
164     ASSERT(m_pendingMessageProtectors[i]);
165 
166     Vector&lt;MessageWithMessagePorts&gt; result;
167     result.swap(m_pendingMessages[i]);
168 
169     ++m_messageBatchesInFlight;
170 
171     LOG(MessagePorts, &quot;There are %zu messages to take for port %s. Taking them now, messages in flight is now %&quot; PRIu64, result.size(), port.logString().utf8().data(), m_messageBatchesInFlight);
172 
173     auto size = result.size();
174     callback(WTFMove(result), [size, this, port, protectedThis = WTFMove(m_pendingMessageProtectors[i])] {
175         UNUSED_PARAM(port);
176 #if LOG_DISABLED
177         UNUSED_PARAM(size);
178 #endif
179         --m_messageBatchesInFlight;
180         LOG(MessagePorts, &quot;Message port channel %s was notified that a batch of %zu message port messages targeted for port %s just completed dispatch, in flight is now %&quot; PRIu64, logString().utf8().data(), size, port.logString().utf8().data(), m_messageBatchesInFlight);
181 
182     });
183 }
184 
<span class="line-modified">185 void MessagePortChannel::checkRemotePortForActivity(const MessagePortIdentifier&amp; remotePort, CompletionHandler&lt;void(MessagePortChannelProvider::HasActivity)&gt;&amp;&amp; callback)</span>
186 {
187     ASSERT(isMainThread());
188     ASSERT(remotePort == m_ports[0] || remotePort == m_ports[1]);
189 
190     // If the remote port is closed there is no pending activity.
191     size_t i = remotePort == m_ports[0] ? 0 : 1;
192     if (m_isClosed[i]) {
193         callback(MessagePortChannelProvider::HasActivity::No);
194         return;
195     }
196 
197     // If there are any messages in flight between the ports, there is pending activity.
198     if (hasAnyMessagesPendingOrInFlight()) {
199         callback(MessagePortChannelProvider::HasActivity::Yes);
200         return;
201     }
202 
203     // If the port is not currently in a process then it&#39;s being transferred as part of a postMessage.
204     // We treat these ports as if they do have activity since they will be revived when the message is delivered.
205     if (!m_processes[i]) {
206         callback(MessagePortChannelProvider::HasActivity::Yes);
207         return;
208     }
209 
<span class="line-modified">210     CompletionHandler&lt;void(MessagePortChannelProvider::HasActivity)&gt; outerCallback = [this, protectedThis = makeRef(*this), callback = WTFMove(callback)](auto hasActivity) mutable {</span>
211         if (hasActivity == MessagePortChannelProvider::HasActivity::Yes) {
212             callback(hasActivity);
213             return;
214         }
215 
216         // If the remote port said it had no activity, check again for any messages that might be in flight.
217         // This is because it might have asynchronously sent a message just before it was asked about local activity.
218         if (hasAnyMessagesPendingOrInFlight())
219             hasActivity = MessagePortChannelProvider::HasActivity::Yes;
220 
221         callback(hasActivity);
<span class="line-modified">222     };</span>
223 
<span class="line-modified">224     m_registry.checkProcessLocalPortForActivity(remotePort, *m_processes[i], WTFMove(outerCallback));</span>
225 }
226 
227 bool MessagePortChannel::hasAnyMessagesPendingOrInFlight() const
228 {
229     ASSERT(isMainThread());
230     return m_messageBatchesInFlight || !m_pendingMessages[0].isEmpty() || !m_pendingMessages[1].isEmpty();
231 }
232 
233 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="../make_names.pl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MessagePortChannel.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGFixupPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2012-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DFGFixupPhase.h&quot;
  28 
  29 #if ENABLE(DFG_JIT)
  30 
  31 #include &quot;ArrayPrototype.h&quot;
  32 #include &quot;DFGGraph.h&quot;
  33 #include &quot;DFGInsertionSet.h&quot;
  34 #include &quot;DFGPhase.h&quot;
  35 #include &quot;DFGPredictionPropagationPhase.h&quot;
  36 #include &quot;DFGVariableAccessDataDump.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  37 #include &quot;GetterSetter.h&quot;</span>
  38 #include &quot;JSCInlines.h&quot;
  39 #include &quot;TypeLocation.h&quot;
  40 
  41 namespace JSC { namespace DFG {
  42 
  43 class FixupPhase : public Phase {
  44 public:
  45     FixupPhase(Graph&amp; graph)
  46         : Phase(graph, &quot;fixup&quot;)
  47         , m_insertionSet(graph)
  48     {
  49     }
  50 
  51     bool run()
  52     {
  53         ASSERT(m_graph.m_fixpointState == BeforeFixpoint);
  54         ASSERT(m_graph.m_form == ThreadedCPS);
  55 
  56         m_profitabilityChanged = false;
  57         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex)
  58             fixupBlock(m_graph.block(blockIndex));
  59 
  60         while (m_profitabilityChanged) {
  61             m_profitabilityChanged = false;
  62 
  63             for (unsigned i = m_graph.m_argumentPositions.size(); i--;)
  64                 m_graph.m_argumentPositions[i].mergeArgumentUnboxingAwareness();
  65 
  66             for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex)
  67                 fixupGetAndSetLocalsInBlock(m_graph.block(blockIndex));
  68         }
  69 
  70         for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex)
  71             fixupChecksInBlock(m_graph.block(blockIndex));
  72 
  73         m_graph.m_planStage = PlanStage::AfterFixup;
  74 
  75         return true;
  76     }
  77 
  78 private:
  79 
  80     void fixupArithDivInt32(Node* node, Edge&amp; leftChild, Edge&amp; rightChild)
  81     {
  82         if (optimizeForX86() || optimizeForARM64() || optimizeForARMv7IDIVSupported()) {
  83             fixIntOrBooleanEdge(leftChild);
  84             fixIntOrBooleanEdge(rightChild);
  85             if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
  86                 node-&gt;setArithMode(Arith::Unchecked);
  87             else if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
  88                 node-&gt;setArithMode(Arith::CheckOverflow);
  89             else
  90                 node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
  91             return;
  92         }
  93 
  94         // This will cause conversion nodes to be inserted later.
  95         fixDoubleOrBooleanEdge(leftChild);
  96         fixDoubleOrBooleanEdge(rightChild);
  97 
  98         // We don&#39;t need to do ref&#39;ing on the children because we&#39;re stealing them from
  99         // the original division.
 100         Node* newDivision = m_insertionSet.insertNode(m_indexInBlock, SpecBytecodeDouble, *node);
 101         newDivision-&gt;setResult(NodeResultDouble);
 102 
 103         node-&gt;setOp(DoubleAsInt32);
 104         node-&gt;children.initialize(Edge(newDivision, DoubleRepUse), Edge(), Edge());
 105         if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 106             node-&gt;setArithMode(Arith::CheckOverflow);
 107         else
 108             node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 109 
 110     }
 111 
 112     void fixupArithPow(Node* node)
 113     {
 114         if (node-&gt;child2()-&gt;shouldSpeculateInt32OrBooleanForArithmetic()) {
 115             fixDoubleOrBooleanEdge(node-&gt;child1());
 116             fixIntOrBooleanEdge(node-&gt;child2());
 117             return;
 118         }
 119 
 120         fixDoubleOrBooleanEdge(node-&gt;child1());
 121         fixDoubleOrBooleanEdge(node-&gt;child2());
 122     }
 123 
 124     void fixupArithDiv(Node* node, Edge&amp; leftChild, Edge&amp; rightChild)
 125     {
 126         if (m_graph.binaryArithShouldSpeculateInt32(node, FixupPass)) {
 127             fixupArithDivInt32(node, leftChild, rightChild);
 128             return;
 129         }
 130 
 131         fixDoubleOrBooleanEdge(leftChild);
 132         fixDoubleOrBooleanEdge(rightChild);
 133         node-&gt;setResult(NodeResultDouble);
 134     }
 135 
 136     void fixupArithMul(Node* node, Edge&amp; leftChild, Edge&amp; rightChild)
 137     {
 138         if (m_graph.binaryArithShouldSpeculateInt32(node, FixupPass)) {
 139             fixIntOrBooleanEdge(leftChild);
 140             fixIntOrBooleanEdge(rightChild);
 141             if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
 142                 node-&gt;setArithMode(Arith::Unchecked);
 143             else if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()) || leftChild.node() == rightChild.node())
 144                 node-&gt;setArithMode(Arith::CheckOverflow);
 145             else
 146                 node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 147             return;
 148         }
 149         if (m_graph.binaryArithShouldSpeculateInt52(node, FixupPass)) {
 150             fixEdge&lt;Int52RepUse&gt;(leftChild);
 151             fixEdge&lt;Int52RepUse&gt;(rightChild);
 152             if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()) || leftChild.node() == rightChild.node())
 153                 node-&gt;setArithMode(Arith::CheckOverflow);
 154             else
 155                 node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 156             node-&gt;setResult(NodeResultInt52);
 157             return;
 158         }
 159 
 160         fixDoubleOrBooleanEdge(leftChild);
 161         fixDoubleOrBooleanEdge(rightChild);
 162         node-&gt;setResult(NodeResultDouble);
 163     }
 164 
 165     void fixupBlock(BasicBlock* block)
 166     {
 167         if (!block)
 168             return;
 169         ASSERT(block-&gt;isReachable);
 170         m_block = block;
 171         for (m_indexInBlock = 0; m_indexInBlock &lt; block-&gt;size(); ++m_indexInBlock) {
 172             m_currentNode = block-&gt;at(m_indexInBlock);
 173             fixupNode(m_currentNode);
 174         }
 175         m_insertionSet.execute(block);
 176     }
 177 
 178     void fixupNode(Node* node)
 179     {
 180         NodeType op = node-&gt;op();
 181 
 182         switch (op) {
 183         case SetLocal: {
 184             // This gets handled by fixupGetAndSetLocalsInBlock().
 185             return;
 186         }
 187 
<a name="2" id="anc2"></a><span class="line-added"> 188         case Inc:</span>
<span class="line-added"> 189         case Dec: {</span>
<span class="line-added"> 190             if (node-&gt;child1()-&gt;shouldSpeculateUntypedForArithmetic()) {</span>
<span class="line-added"> 191                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());</span>
<span class="line-added"> 192                 break;</span>
<span class="line-added"> 193             }</span>
<span class="line-added"> 194 </span>
<span class="line-added"> 195             Node* nodeConstantOne;</span>
<span class="line-added"> 196             if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean() &amp;&amp; node-&gt;canSpeculateInt32(FixupPass)) {</span>
<span class="line-added"> 197                 node-&gt;setOp(op == Inc ? ArithAdd : ArithSub);</span>
<span class="line-added"> 198                 node-&gt;setArithMode(Arith::CheckOverflow);</span>
<span class="line-added"> 199                 nodeConstantOne = m_insertionSet.insertNode(m_indexInBlock, SpecInt32Only, JSConstant, node-&gt;origin, OpInfo(m_graph.freeze(jsNumber(1))));</span>
<span class="line-added"> 200                 node-&gt;children.setChild2(Edge(nodeConstantOne));</span>
<span class="line-added"> 201                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());</span>
<span class="line-added"> 202                 fixEdge&lt;Int32Use&gt;(node-&gt;child2());</span>
<span class="line-added"> 203                 node-&gt;setResult(NodeResultInt32);</span>
<span class="line-added"> 204             } else if (node-&gt;child1()-&gt;shouldSpeculateBigInt()) {</span>
<span class="line-added"> 205                 // FIXME: the freezing does not appear useful (since the JSCell is kept alive by vm), but it refuses to compile otherwise.</span>
<span class="line-added"> 206                 node-&gt;setOp(op == Inc ? ValueAdd : ValueSub);</span>
<span class="line-added"> 207                 nodeConstantOne = m_insertionSet.insertNode(m_indexInBlock, SpecBigInt, JSConstant, node-&gt;origin, OpInfo(m_graph.freeze(vm().bigIntConstantOne.get())));</span>
<span class="line-added"> 208                 node-&gt;children.setChild2(Edge(nodeConstantOne));</span>
<span class="line-added"> 209                 fixEdge&lt;BigIntUse&gt;(node-&gt;child1());</span>
<span class="line-added"> 210                 fixEdge&lt;BigIntUse&gt;(node-&gt;child2());</span>
<span class="line-added"> 211                 // BigInts are currently cells, so the default of NodeResultJS is good here</span>
<span class="line-added"> 212             } else if (node-&gt;child1()-&gt;shouldSpeculateInt52()) {</span>
<span class="line-added"> 213                 node-&gt;setOp(op == Inc ? ArithAdd : ArithSub);</span>
<span class="line-added"> 214                 node-&gt;setArithMode(Arith::CheckOverflow);</span>
<span class="line-added"> 215                 nodeConstantOne = m_insertionSet.insertNode(m_indexInBlock, SpecInt32AsInt52, JSConstant, node-&gt;origin, OpInfo(m_graph.freeze(jsNumber(1))));</span>
<span class="line-added"> 216                 node-&gt;children.setChild2(Edge(nodeConstantOne));</span>
<span class="line-added"> 217                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());</span>
<span class="line-added"> 218                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child2());</span>
<span class="line-added"> 219                 node-&gt;setResult(NodeResultInt52);</span>
<span class="line-added"> 220             } else {</span>
<span class="line-added"> 221                 node-&gt;setOp(op == Inc ? ArithAdd : ArithSub);</span>
<span class="line-added"> 222                 node-&gt;setArithMode(Arith::Unchecked);</span>
<span class="line-added"> 223                 nodeConstantOne = m_insertionSet.insertNode(m_indexInBlock, SpecBytecodeDouble, JSConstant, node-&gt;origin, OpInfo(m_graph.freeze(jsNumber(1))));</span>
<span class="line-added"> 224                 node-&gt;children.setChild2(Edge(nodeConstantOne));</span>
<span class="line-added"> 225                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());</span>
<span class="line-added"> 226                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child2());</span>
<span class="line-added"> 227                 node-&gt;setResult(NodeResultDouble);</span>
<span class="line-added"> 228             }</span>
<span class="line-added"> 229             node-&gt;clearFlags(NodeMustGenerate);</span>
<span class="line-added"> 230             break;</span>
<span class="line-added"> 231         }</span>
<span class="line-added"> 232 </span>
 233         case ValueSub: {
 234             Edge&amp; child1 = node-&gt;child1();
 235             Edge&amp; child2 = node-&gt;child2();
 236 
 237             if (Node::shouldSpeculateBigInt(child1.node(), child2.node())) {
 238                 fixEdge&lt;BigIntUse&gt;(child1);
 239                 fixEdge&lt;BigIntUse&gt;(child2);
 240                 break;
 241             }
 242 
 243             if (Node::shouldSpeculateUntypedForArithmetic(node-&gt;child1().node(), node-&gt;child2().node())) {
 244                 fixEdge&lt;UntypedUse&gt;(child1);
 245                 fixEdge&lt;UntypedUse&gt;(child2);
 246                 break;
 247             }
 248 
 249             if (attemptToMakeIntegerAdd(node)) {
 250                 // FIXME: Clear ArithSub&#39;s NodeMustGenerate when ArithMode is unchecked
 251                 // https://bugs.webkit.org/show_bug.cgi?id=190607
 252                 node-&gt;setOp(ArithSub);
 253                 break;
 254             }
 255 
 256             fixDoubleOrBooleanEdge(node-&gt;child1());
 257             fixDoubleOrBooleanEdge(node-&gt;child2());
 258             node-&gt;setOp(ArithSub);
 259             node-&gt;setResult(NodeResultDouble);
 260 
 261             break;
 262         }
 263 
 264         case ValueBitLShift:
<a name="3" id="anc3"></a><span class="line-added"> 265         case ValueBitRShift:</span>
 266         case ValueBitXor:
 267         case ValueBitOr:
 268         case ValueBitAnd: {
 269             if (Node::shouldSpeculateBigInt(node-&gt;child1().node(), node-&gt;child2().node())) {
 270                 fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
 271                 fixEdge&lt;BigIntUse&gt;(node-&gt;child2());
 272                 node-&gt;clearFlags(NodeMustGenerate);
 273                 break;
 274             }
 275 
 276             if (Node::shouldSpeculateUntypedForBitOps(node-&gt;child1().node(), node-&gt;child2().node())) {
 277                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 278                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
 279                 break;
 280             }
 281 
 282             switch (op) {
 283             case ValueBitXor:
 284                 node-&gt;setOp(ArithBitXor);
 285                 break;
 286             case ValueBitOr:
 287                 node-&gt;setOp(ArithBitOr);
 288                 break;
 289             case ValueBitAnd:
 290                 node-&gt;setOp(ArithBitAnd);
 291                 break;
 292             case ValueBitLShift:
 293                 node-&gt;setOp(ArithBitLShift);
 294                 break;
<a name="4" id="anc4"></a><span class="line-added"> 295             case ValueBitRShift:</span>
<span class="line-added"> 296                 node-&gt;setOp(ArithBitRShift);</span>
<span class="line-added"> 297                 break;</span>
 298             default:
 299                 DFG_CRASH(m_graph, node, &quot;Unexpected node during ValueBit operation fixup&quot;);
 300                 break;
 301             }
 302 
 303             node-&gt;clearFlags(NodeMustGenerate);
 304             node-&gt;setResult(NodeResultInt32);
 305             fixIntConvertingEdge(node-&gt;child1());
 306             fixIntConvertingEdge(node-&gt;child2());
 307             break;
 308         }
 309 
 310         case ValueBitNot: {
 311             Edge&amp; operandEdge = node-&gt;child1();
 312 
 313             if (operandEdge.node()-&gt;shouldSpeculateBigInt()) {
 314                 node-&gt;clearFlags(NodeMustGenerate);
 315                 fixEdge&lt;BigIntUse&gt;(operandEdge);
 316             } else if (operandEdge.node()-&gt;shouldSpeculateUntypedForBitOps())
 317                 fixEdge&lt;UntypedUse&gt;(operandEdge);
 318             else {
 319                 node-&gt;setOp(ArithBitNot);
 320                 node-&gt;setResult(NodeResultInt32);
 321                 node-&gt;clearFlags(NodeMustGenerate);
 322                 fixIntConvertingEdge(operandEdge);
 323             }
 324             break;
 325         }
 326 
 327         case ArithBitNot: {
 328             Edge&amp; operandEdge = node-&gt;child1();
 329 
 330             fixIntConvertingEdge(operandEdge);
 331             break;
 332         }
 333 
<a name="5" id="anc5"></a><span class="line-added"> 334         case ArithBitRShift:</span>
 335         case ArithBitLShift:
 336         case ArithBitXor:
 337         case ArithBitOr:
 338         case ArithBitAnd: {
 339             fixIntConvertingEdge(node-&gt;child1());
 340             fixIntConvertingEdge(node-&gt;child2());
 341             break;
 342         }
 343 
<a name="6" id="anc6"></a>
 344         case BitURShift: {
 345             if (Node::shouldSpeculateUntypedForBitOps(node-&gt;child1().node(), node-&gt;child2().node())) {
 346                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 347                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
 348                 break;
 349             }
 350             fixIntConvertingEdge(node-&gt;child1());
 351             fixIntConvertingEdge(node-&gt;child2());
 352             break;
 353         }
 354 
 355         case ArithIMul: {
 356             fixIntConvertingEdge(node-&gt;child1());
 357             fixIntConvertingEdge(node-&gt;child2());
 358             node-&gt;setOp(ArithMul);
 359             node-&gt;setArithMode(Arith::Unchecked);
 360             node-&gt;child1().setUseKind(Int32Use);
 361             node-&gt;child2().setUseKind(Int32Use);
 362             break;
 363         }
 364 
 365         case ArithClz32: {
 366             if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
 367                 fixIntConvertingEdge(node-&gt;child1());
 368                 node-&gt;clearFlags(NodeMustGenerate);
 369             } else
 370                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 371             break;
 372         }
 373 
 374         case UInt32ToNumber: {
 375             fixIntConvertingEdge(node-&gt;child1());
 376             if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
 377                 node-&gt;convertToIdentity();
 378             else if (node-&gt;canSpeculateInt32(FixupPass))
 379                 node-&gt;setArithMode(Arith::CheckOverflow);
 380             else {
 381                 node-&gt;setArithMode(Arith::DoOverflow);
 382                 node-&gt;setResult(enableInt52() ? NodeResultInt52 : NodeResultDouble);
 383             }
 384             break;
 385         }
 386 
 387         case ValueNegate: {
 388             if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean() &amp;&amp; node-&gt;canSpeculateInt32(FixupPass)) {
 389                 node-&gt;setOp(ArithNegate);
 390                 fixIntOrBooleanEdge(node-&gt;child1());
 391                 if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
 392                     node-&gt;setArithMode(Arith::Unchecked);
 393                 else if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 394                     node-&gt;setArithMode(Arith::CheckOverflow);
 395                 else
 396                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 397                 node-&gt;setResult(NodeResultInt32);
 398                 node-&gt;clearFlags(NodeMustGenerate);
 399                 break;
 400             }
 401 
 402             if (m_graph.unaryArithShouldSpeculateInt52(node, FixupPass)) {
 403                 node-&gt;setOp(ArithNegate);
 404                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
 405                 if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 406                     node-&gt;setArithMode(Arith::CheckOverflow);
 407                 else
 408                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 409                 node-&gt;setResult(NodeResultInt52);
 410                 node-&gt;clearFlags(NodeMustGenerate);
 411                 break;
 412             }
 413             if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
 414                 node-&gt;setOp(ArithNegate);
 415                 fixDoubleOrBooleanEdge(node-&gt;child1());
 416                 node-&gt;setResult(NodeResultDouble);
 417                 node-&gt;clearFlags(NodeMustGenerate);
 418             } else {
 419                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 420                 node-&gt;setResult(NodeResultJS);
 421             }
 422             break;
 423         }
 424 
 425         case ValueAdd: {
 426             if (attemptToMakeIntegerAdd(node)) {
 427                 node-&gt;setOp(ArithAdd);
 428                 break;
 429             }
 430             if (Node::shouldSpeculateNumberOrBooleanExpectingDefined(node-&gt;child1().node(), node-&gt;child2().node())) {
 431                 fixDoubleOrBooleanEdge(node-&gt;child1());
 432                 fixDoubleOrBooleanEdge(node-&gt;child2());
 433                 node-&gt;setOp(ArithAdd);
 434                 node-&gt;setResult(NodeResultDouble);
 435                 break;
 436             }
 437 
 438             if (attemptToMakeFastStringAdd(node))
 439                 break;
 440 
 441             Edge&amp; child1 = node-&gt;child1();
 442             Edge&amp; child2 = node-&gt;child2();
 443             if (child1-&gt;shouldSpeculateString() || child2-&gt;shouldSpeculateString()) {
 444                 if (child1-&gt;shouldSpeculateInt32() || child2-&gt;shouldSpeculateInt32()) {
 445                     auto convertString = [&amp;](Node* node, Edge&amp; edge) {
 446                         if (edge-&gt;shouldSpeculateInt32())
 447                             convertStringAddUse&lt;Int32Use&gt;(node, edge);
 448                         else {
 449                             ASSERT(edge-&gt;shouldSpeculateString());
 450                             convertStringAddUse&lt;StringUse&gt;(node, edge);
 451                         }
 452                     };
 453                     convertString(node, child1);
 454                     convertString(node, child2);
 455                     convertToMakeRope(node);
 456                     break;
 457                 }
 458             }
 459 
 460             if (Node::shouldSpeculateBigInt(child1.node(), child2.node())) {
 461                 fixEdge&lt;BigIntUse&gt;(child1);
 462                 fixEdge&lt;BigIntUse&gt;(child2);
 463             } else {
 464                 fixEdge&lt;UntypedUse&gt;(child1);
 465                 fixEdge&lt;UntypedUse&gt;(child2);
 466             }
 467 
 468             node-&gt;setResult(NodeResultJS);
 469             break;
 470         }
 471 
 472         case StrCat: {
 473             if (attemptToMakeFastStringAdd(node))
 474                 break;
 475 
 476             // FIXME: Remove empty string arguments and possibly turn this into a ToString operation. That
 477             // would require a form of ToString that takes a KnownPrimitiveUse. This is necessary because
 478             // the implementation of StrCat doesn&#39;t dynamically optimize for empty strings.
 479             // https://bugs.webkit.org/show_bug.cgi?id=148540
 480             m_graph.doToChildren(
 481                 node,
 482                 [&amp;] (Edge&amp; edge) {
 483                     fixEdge&lt;KnownPrimitiveUse&gt;(edge);
 484                     // StrCat automatically coerces the values into strings before concatenating them.
 485                     // The ECMA spec says that we&#39;re not allowed to automatically coerce a Symbol into
 486                     // a string. If a Symbol is encountered, a TypeError will be thrown. As a result,
 487                     // our runtime functions for this slow path expect that they will never be passed
 488                     // Symbols.
 489                     m_insertionSet.insertNode(
 490                         m_indexInBlock, SpecNone, Check, node-&gt;origin,
 491                         Edge(edge.node(), NotSymbolUse));
 492                 });
 493             break;
 494         }
 495 
 496         case MakeRope: {
 497             fixupMakeRope(node);
 498             break;
 499         }
 500 
 501         case ArithAdd:
 502         case ArithSub: {
 503             // FIXME: Clear ArithSub&#39;s NodeMustGenerate when ArithMode is unchecked
 504             // https://bugs.webkit.org/show_bug.cgi?id=190607
 505             if (attemptToMakeIntegerAdd(node))
 506                 break;
 507             fixDoubleOrBooleanEdge(node-&gt;child1());
 508             fixDoubleOrBooleanEdge(node-&gt;child2());
 509             node-&gt;setResult(NodeResultDouble);
 510             break;
 511         }
 512 
 513         case ArithNegate: {
 514             if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean() &amp;&amp; node-&gt;canSpeculateInt32(FixupPass)) {
 515                 fixIntOrBooleanEdge(node-&gt;child1());
 516                 if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
 517                     node-&gt;setArithMode(Arith::Unchecked);
 518                 else if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 519                     node-&gt;setArithMode(Arith::CheckOverflow);
 520                 else
 521                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 522                 node-&gt;setResult(NodeResultInt32);
 523                 node-&gt;clearFlags(NodeMustGenerate);
 524                 break;
 525             }
 526             if (m_graph.unaryArithShouldSpeculateInt52(node, FixupPass)) {
 527                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
 528                 if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 529                     node-&gt;setArithMode(Arith::CheckOverflow);
 530                 else
 531                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
 532                 node-&gt;setResult(NodeResultInt52);
 533                 node-&gt;clearFlags(NodeMustGenerate);
 534                 break;
 535             }
 536 
 537             fixDoubleOrBooleanEdge(node-&gt;child1());
 538             node-&gt;setResult(NodeResultDouble);
 539             node-&gt;clearFlags(NodeMustGenerate);
 540             break;
 541         }
 542 
 543         case ValueMul: {
 544             Edge&amp; leftChild = node-&gt;child1();
 545             Edge&amp; rightChild = node-&gt;child2();
 546 
 547             if (Node::shouldSpeculateBigInt(leftChild.node(), rightChild.node())) {
 548                 fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
 549                 fixEdge&lt;BigIntUse&gt;(node-&gt;child2());
 550                 node-&gt;clearFlags(NodeMustGenerate);
 551                 break;
 552             }
 553 
 554             // There are cases where we can have BigInt + Int32 operands reaching ValueMul.
 555             // Imagine the scenario where ValueMul was never executed, but we can predict types
 556             // reaching the node:
 557             //
 558             // 63: GetLocal(Check:Untyped:@72, JS|MustGen, NonBoolInt32, ...)  predicting NonBoolInt32
 559             // 64: GetLocal(Check:Untyped:@71, JS|MustGen, BigInt, ...)  predicting BigInt
 560             // 65: ValueMul(Check:Untyped:@63, Check:Untyped:@64, BigInt|BoolInt32|NonBoolInt32, ...)
 561             //
 562             // In such scenario, we need to emit ValueMul(Untyped, Untyped), so the runtime can throw
 563             // an exception whenever it gets excuted.
 564             if (Node::shouldSpeculateUntypedForArithmetic(leftChild.node(), rightChild.node())) {
 565                 fixEdge&lt;UntypedUse&gt;(leftChild);
 566                 fixEdge&lt;UntypedUse&gt;(rightChild);
 567                 break;
 568             }
 569 
 570             // At this point, all other possible specializations are only handled by ArithMul.
 571             node-&gt;setOp(ArithMul);
 572             node-&gt;setResult(NodeResultNumber);
 573             fixupArithMul(node, leftChild, rightChild);
 574             break;
 575         }
 576 
 577         case ArithMul: {
 578             Edge&amp; leftChild = node-&gt;child1();
 579             Edge&amp; rightChild = node-&gt;child2();
 580 
 581             fixupArithMul(node, leftChild, rightChild);
 582             break;
 583         }
 584 
 585         case ValueMod:
 586         case ValueDiv: {
 587             Edge&amp; leftChild = node-&gt;child1();
 588             Edge&amp; rightChild = node-&gt;child2();
 589 
 590             if (Node::shouldSpeculateBigInt(leftChild.node(), rightChild.node())) {
 591                 fixEdge&lt;BigIntUse&gt;(leftChild);
 592                 fixEdge&lt;BigIntUse&gt;(rightChild);
 593                 node-&gt;clearFlags(NodeMustGenerate);
 594                 break;
 595             }
 596 
 597             if (Node::shouldSpeculateUntypedForArithmetic(leftChild.node(), rightChild.node())) {
 598                 fixEdge&lt;UntypedUse&gt;(leftChild);
 599                 fixEdge&lt;UntypedUse&gt;(rightChild);
 600                 break;
 601             }
 602 
 603             if (op == ValueDiv)
 604                 node-&gt;setOp(ArithDiv);
 605             else
 606                 node-&gt;setOp(ArithMod);
 607 
 608             node-&gt;setResult(NodeResultNumber);
 609             fixupArithDiv(node, leftChild, rightChild);
 610             break;
 611 
 612         }
 613 
 614         case ArithDiv:
 615         case ArithMod: {
 616             Edge&amp; leftChild = node-&gt;child1();
 617             Edge&amp; rightChild = node-&gt;child2();
 618 
 619             fixupArithDiv(node, leftChild, rightChild);
 620             break;
 621         }
 622 
 623         case ArithMin:
 624         case ArithMax: {
 625             if (m_graph.binaryArithShouldSpeculateInt32(node, FixupPass)) {
 626                 fixIntOrBooleanEdge(node-&gt;child1());
 627                 fixIntOrBooleanEdge(node-&gt;child2());
 628                 break;
 629             }
 630             fixDoubleOrBooleanEdge(node-&gt;child1());
 631             fixDoubleOrBooleanEdge(node-&gt;child2());
 632             node-&gt;setResult(NodeResultDouble);
 633             break;
 634         }
 635 
 636         case ArithAbs: {
 637             if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean()
 638                 &amp;&amp; node-&gt;canSpeculateInt32(FixupPass)) {
 639                 fixIntOrBooleanEdge(node-&gt;child1());
 640                 if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
 641                     node-&gt;setArithMode(Arith::Unchecked);
 642                 else
 643                     node-&gt;setArithMode(Arith::CheckOverflow);
 644                 node-&gt;clearFlags(NodeMustGenerate);
 645                 node-&gt;setResult(NodeResultInt32);
 646                 break;
 647             }
 648 
 649             if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
 650                 fixDoubleOrBooleanEdge(node-&gt;child1());
 651                 node-&gt;clearFlags(NodeMustGenerate);
 652             } else
 653                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 654             node-&gt;setResult(NodeResultDouble);
 655             break;
 656         }
 657 
 658         case ValuePow: {
 659             if (Node::shouldSpeculateBigInt(node-&gt;child1().node(), node-&gt;child2().node())) {
 660                 fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
 661                 fixEdge&lt;BigIntUse&gt;(node-&gt;child2());
 662                 node-&gt;clearFlags(NodeMustGenerate);
 663                 break;
 664             }
 665 
 666             if (Node::shouldSpeculateUntypedForArithmetic(node-&gt;child1().node(), node-&gt;child2().node())) {
 667                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 668                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
 669                 break;
 670             }
 671 
 672             node-&gt;setOp(ArithPow);
 673             node-&gt;clearFlags(NodeMustGenerate);
 674             node-&gt;setResult(NodeResultDouble);
 675 
 676             fixupArithPow(node);
 677             break;
 678         }
 679 
 680         case ArithPow: {
 681             fixupArithPow(node);
 682             break;
 683         }
 684 
 685         case ArithRandom: {
 686             node-&gt;setResult(NodeResultDouble);
 687             break;
 688         }
 689 
 690         case ArithRound:
 691         case ArithFloor:
 692         case ArithCeil:
 693         case ArithTrunc: {
 694             if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean() &amp;&amp; m_graph.roundShouldSpeculateInt32(node, FixupPass)) {
 695                 fixIntOrBooleanEdge(node-&gt;child1());
 696                 insertCheck&lt;Int32Use&gt;(node-&gt;child1().node());
 697                 node-&gt;convertToIdentity();
 698                 break;
 699             }
 700             if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
 701                 fixDoubleOrBooleanEdge(node-&gt;child1());
 702 
 703                 if (isInt32OrBooleanSpeculation(node-&gt;getHeapPrediction()) &amp;&amp; m_graph.roundShouldSpeculateInt32(node, FixupPass)) {
 704                     node-&gt;setResult(NodeResultInt32);
 705                     if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
 706                         node-&gt;setArithRoundingMode(Arith::RoundingMode::Int32);
 707                     else
 708                         node-&gt;setArithRoundingMode(Arith::RoundingMode::Int32WithNegativeZeroCheck);
 709                 } else {
 710                     node-&gt;setResult(NodeResultDouble);
 711                     node-&gt;setArithRoundingMode(Arith::RoundingMode::Double);
 712                 }
 713                 node-&gt;clearFlags(NodeMustGenerate);
 714             } else
 715                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 716             break;
 717         }
 718 
 719         case ArithFRound:
 720         case ArithSqrt:
 721         case ArithUnary: {
 722             Edge&amp; child1 = node-&gt;child1();
 723             if (child1-&gt;shouldSpeculateNotCell()) {
 724                 fixDoubleOrBooleanEdge(child1);
 725                 node-&gt;clearFlags(NodeMustGenerate);
 726             } else
 727                 fixEdge&lt;UntypedUse&gt;(child1);
 728             break;
 729         }
 730 
 731         case LogicalNot: {
 732             if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
 733                 if (node-&gt;child1()-&gt;result() == NodeResultBoolean) {
 734                     // This is necessary in case we have a bytecode instruction implemented by:
 735                     //
 736                     // a: CompareEq(...)
 737                     // b: LogicalNot(@a)
 738                     //
 739                     // In that case, CompareEq might have a side-effect. Then, we need to make
 740                     // sure that we know that Branch does not exit.
 741                     fixEdge&lt;KnownBooleanUse&gt;(node-&gt;child1());
 742                 } else
 743                     fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
 744             } else if (node-&gt;child1()-&gt;shouldSpeculateObjectOrOther())
 745                 fixEdge&lt;ObjectOrOtherUse&gt;(node-&gt;child1());
 746             else if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean())
 747                 fixIntOrBooleanEdge(node-&gt;child1());
 748             else if (node-&gt;child1()-&gt;shouldSpeculateNumber())
 749                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
 750             else if (node-&gt;child1()-&gt;shouldSpeculateString())
 751                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
 752             else if (node-&gt;child1()-&gt;shouldSpeculateStringOrOther())
 753                 fixEdge&lt;StringOrOtherUse&gt;(node-&gt;child1());
 754             else {
 755                 WatchpointSet* masqueradesAsUndefinedWatchpoint = m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;masqueradesAsUndefinedWatchpoint();
 756                 if (masqueradesAsUndefinedWatchpoint-&gt;isStillValid())
 757                     m_graph.watchpoints().addLazily(masqueradesAsUndefinedWatchpoint);
 758             }
 759             break;
 760         }
 761 
 762         case CompareEq:
 763         case CompareLess:
 764         case CompareLessEq:
 765         case CompareGreater:
 766         case CompareGreaterEq: {
 767             if (node-&gt;op() == CompareEq
 768                 &amp;&amp; Node::shouldSpeculateBoolean(node-&gt;child1().node(), node-&gt;child2().node())) {
 769                 fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
 770                 fixEdge&lt;BooleanUse&gt;(node-&gt;child2());
 771                 node-&gt;clearFlags(NodeMustGenerate);
 772                 break;
 773             }
 774             if (Node::shouldSpeculateInt32OrBoolean(node-&gt;child1().node(), node-&gt;child2().node())) {
 775                 fixIntOrBooleanEdge(node-&gt;child1());
 776                 fixIntOrBooleanEdge(node-&gt;child2());
 777                 node-&gt;clearFlags(NodeMustGenerate);
 778                 break;
 779             }
 780             if (Node::shouldSpeculateInt52(node-&gt;child1().node(), node-&gt;child2().node())) {
 781                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
 782                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child2());
 783                 node-&gt;clearFlags(NodeMustGenerate);
 784                 break;
 785             }
 786             if (Node::shouldSpeculateNumberOrBoolean(node-&gt;child1().node(), node-&gt;child2().node())) {
 787                 fixDoubleOrBooleanEdge(node-&gt;child1());
 788                 fixDoubleOrBooleanEdge(node-&gt;child2());
 789             }
 790             if (node-&gt;op() != CompareEq
 791                 &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateNotCell()
 792                 &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateNotCell()) {
 793                 if (node-&gt;child1()-&gt;shouldSpeculateNumberOrBoolean())
 794                     fixDoubleOrBooleanEdge(node-&gt;child1());
 795                 else
 796                     fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
 797                 if (node-&gt;child2()-&gt;shouldSpeculateNumberOrBoolean())
 798                     fixDoubleOrBooleanEdge(node-&gt;child2());
 799                 else
 800                     fixEdge&lt;DoubleRepUse&gt;(node-&gt;child2());
 801                 node-&gt;clearFlags(NodeMustGenerate);
 802                 break;
 803             }
 804             if (node-&gt;child1()-&gt;shouldSpeculateStringIdent() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateStringIdent()) {
 805                 fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());
 806                 fixEdge&lt;StringIdentUse&gt;(node-&gt;child2());
 807                 node-&gt;clearFlags(NodeMustGenerate);
 808                 break;
 809             }
 810             if (node-&gt;child1()-&gt;shouldSpeculateString() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateString() &amp;&amp; GPRInfo::numberOfRegisters &gt;= 7) {
 811                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
 812                 fixEdge&lt;StringUse&gt;(node-&gt;child2());
 813                 node-&gt;clearFlags(NodeMustGenerate);
 814                 break;
 815             }
 816 
 817             if (node-&gt;op() != CompareEq)
 818                 break;
 819             if (Node::shouldSpeculateSymbol(node-&gt;child1().node(), node-&gt;child2().node())) {
 820                 fixEdge&lt;SymbolUse&gt;(node-&gt;child1());
 821                 fixEdge&lt;SymbolUse&gt;(node-&gt;child2());
 822                 node-&gt;clearFlags(NodeMustGenerate);
 823                 break;
 824             }
 825             if (node-&gt;child1()-&gt;shouldSpeculateObject() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateObject()) {
 826                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
 827                 fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
 828                 node-&gt;clearFlags(NodeMustGenerate);
 829                 break;
 830             }
 831 
 832             // If either child can be proved to be Null or Undefined, comparing them is greatly simplified.
 833             bool oneArgumentIsUsedAsSpecOther = false;
 834             if (node-&gt;child1()-&gt;isUndefinedOrNullConstant()) {
 835                 fixEdge&lt;KnownOtherUse&gt;(node-&gt;child1());
 836                 oneArgumentIsUsedAsSpecOther = true;
 837             } else if (node-&gt;child1()-&gt;shouldSpeculateOther()) {
 838                 m_insertionSet.insertNode(m_indexInBlock, SpecNone, Check, node-&gt;origin,
 839                     Edge(node-&gt;child1().node(), OtherUse));
 840                 fixEdge&lt;KnownOtherUse&gt;(node-&gt;child1());
 841                 oneArgumentIsUsedAsSpecOther = true;
 842             }
 843             if (node-&gt;child2()-&gt;isUndefinedOrNullConstant()) {
 844                 fixEdge&lt;KnownOtherUse&gt;(node-&gt;child2());
 845                 oneArgumentIsUsedAsSpecOther = true;
 846             } else if (node-&gt;child2()-&gt;shouldSpeculateOther()) {
 847                 m_insertionSet.insertNode(m_indexInBlock, SpecNone, Check, node-&gt;origin,
 848                     Edge(node-&gt;child2().node(), OtherUse));
 849                 fixEdge&lt;KnownOtherUse&gt;(node-&gt;child2());
 850                 oneArgumentIsUsedAsSpecOther = true;
 851             }
 852             if (oneArgumentIsUsedAsSpecOther) {
 853                 node-&gt;clearFlags(NodeMustGenerate);
 854                 break;
 855             }
 856 
 857             if (node-&gt;child1()-&gt;shouldSpeculateObject() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateObjectOrOther()) {
 858                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
 859                 fixEdge&lt;ObjectOrOtherUse&gt;(node-&gt;child2());
 860                 node-&gt;clearFlags(NodeMustGenerate);
 861                 break;
 862             }
 863             if (node-&gt;child1()-&gt;shouldSpeculateObjectOrOther() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateObject()) {
 864                 fixEdge&lt;ObjectOrOtherUse&gt;(node-&gt;child1());
 865                 fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
 866                 node-&gt;clearFlags(NodeMustGenerate);
 867                 break;
 868             }
 869 
 870             break;
 871         }
 872 
 873         case CompareStrictEq:
 874         case SameValue: {
 875             fixupCompareStrictEqAndSameValue(node);
 876             break;
 877         }
 878 
 879         case StringFromCharCode:
 880             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
 881                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());
 882                 node-&gt;clearFlags(NodeMustGenerate);
 883             } else
 884                 fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
 885             break;
 886 
 887         case StringCharAt:
<a name="7" id="anc7"></a><span class="line-modified"> 888         case StringCharCodeAt:</span>
<span class="line-added"> 889         case StringCodePointAt: {</span>
 890             // Currently we have no good way of refining these.
 891             ASSERT(node-&gt;arrayMode() == ArrayMode(Array::String, Array::Read));
 892             blessArrayOperation(node-&gt;child1(), node-&gt;child2(), node-&gt;child3());
 893             fixEdge&lt;KnownStringUse&gt;(node-&gt;child1());
 894             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
 895             break;
 896         }
 897 
 898         case GetByVal: {
 899             if (!node-&gt;prediction()) {
 900                 m_insertionSet.insertNode(
 901                     m_indexInBlock, SpecNone, ForceOSRExit, node-&gt;origin);
 902             }
 903 
 904             node-&gt;setArrayMode(
 905                 node-&gt;arrayMode().refine(
 906                     m_graph, node,
 907                     m_graph.varArgChild(node, 0)-&gt;prediction(),
 908                     m_graph.varArgChild(node, 1)-&gt;prediction(),
 909                     SpecNone));
 910 
 911             blessArrayOperation(m_graph.varArgChild(node, 0), m_graph.varArgChild(node, 1), m_graph.varArgChild(node, 2));
 912 
 913             ArrayMode arrayMode = node-&gt;arrayMode();
 914             switch (arrayMode.type()) {
 915             case Array::Contiguous:
 916             case Array::Double:
 917                 if (arrayMode.isJSArrayWithOriginalStructure() &amp;&amp; arrayMode.speculation() == Array::InBounds) {
 918                     // Check if SaneChain will work on a per-type basis. Note that:
 919                     //
 920                     // 1) We don&#39;t want double arrays to sometimes return undefined, since
 921                     // that would require a change to the return type and it would pessimise
 922                     // things a lot. So, we&#39;d only want to do that if we actually had
 923                     // evidence that we could read from a hole. That&#39;s pretty annoying.
 924                     // Likely the best way to handle that case is with an equivalent of
 925                     // SaneChain for OutOfBounds. For now we just detect when Undefined and
 926                     // NaN are indistinguishable according to backwards propagation, and just
 927                     // use SaneChain in that case. This happens to catch a lot of cases.
 928                     //
 929                     // 2) We don&#39;t want int32 array loads to have to do a hole check just to
 930                     // coerce to Undefined, since that would mean twice the checks.
 931                     //
 932                     // This has two implications. First, we have to do more checks than we&#39;d
 933                     // like. It&#39;s unfortunate that we have to do the hole check. Second,
 934                     // some accesses that hit a hole will now need to take the full-blown
 935                     // out-of-bounds slow path. We can fix that with:
 936                     // https://bugs.webkit.org/show_bug.cgi?id=144668
 937 
 938                     bool canDoSaneChain = false;
 939                     switch (arrayMode.type()) {
 940                     case Array::Contiguous:
 941                         // This is happens to be entirely natural. We already would have
 942                         // returned any JSValue, and now we&#39;ll return Undefined. We still do
 943                         // the check but it doesn&#39;t require taking any kind of slow path.
 944                         canDoSaneChain = true;
 945                         break;
 946 
 947                     case Array::Double:
 948                         if (!(node-&gt;flags() &amp; NodeBytecodeUsesAsOther)) {
 949                             // Holes look like NaN already, so if the user doesn&#39;t care
 950                             // about the difference between Undefined and NaN then we can
 951                             // do this.
 952                             canDoSaneChain = true;
 953                         }
 954                         break;
 955 
 956                     default:
 957                         break;
 958                     }
 959 
 960                     if (canDoSaneChain) {
 961                         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
 962                         Structure* arrayPrototypeStructure = globalObject-&gt;arrayPrototype()-&gt;structure(vm());
 963                         Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(vm());
 964                         if (arrayPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
 965                             &amp;&amp; objectPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
 966                             &amp;&amp; globalObject-&gt;arrayPrototypeChainIsSane()) {
 967                             m_graph.registerAndWatchStructureTransition(arrayPrototypeStructure);
 968                             m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);
 969                             node-&gt;setArrayMode(arrayMode.withSpeculation(Array::SaneChain));
 970                         }
 971                     }
 972                 }
 973                 break;
 974 
 975             case Array::String:
 976                 if ((node-&gt;prediction() &amp; ~SpecString)
 977                     || m_graph.hasExitSite(node-&gt;origin.semantic, OutOfBounds))
 978                     node-&gt;setArrayMode(arrayMode.withSpeculation(Array::OutOfBounds));
 979                 break;
 980 
 981             default:
 982                 break;
 983             }
 984 
 985             arrayMode = node-&gt;arrayMode();
 986             switch (arrayMode.type()) {
 987             case Array::SelectUsingPredictions:
 988             case Array::Unprofiled:
 989                 RELEASE_ASSERT_NOT_REACHED();
 990                 break;
 991             case Array::Generic:
 992                 if (m_graph.varArgChild(node, 0)-&gt;shouldSpeculateObject()) {
 993                     if (m_graph.varArgChild(node, 1)-&gt;shouldSpeculateString()) {
 994                         fixEdge&lt;ObjectUse&gt;(m_graph.varArgChild(node, 0));
 995                         fixEdge&lt;StringUse&gt;(m_graph.varArgChild(node, 1));
 996                         break;
 997                     }
 998 
 999                     if (m_graph.varArgChild(node, 1)-&gt;shouldSpeculateSymbol()) {
1000                         fixEdge&lt;ObjectUse&gt;(m_graph.varArgChild(node, 0));
1001                         fixEdge&lt;SymbolUse&gt;(m_graph.varArgChild(node, 1));
1002                         break;
1003                     }
1004                 }
1005 #if USE(JSVALUE32_64)
1006                 fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 0)); // Speculating cell due to register pressure on 32-bit.
1007 #endif
1008                 break;
1009             case Array::ForceExit:
1010                 break;
1011             case Array::String:
1012                 fixEdge&lt;KnownStringUse&gt;(m_graph.varArgChild(node, 0));
1013                 fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 1));
1014                 break;
1015             default:
1016                 fixEdge&lt;KnownCellUse&gt;(m_graph.varArgChild(node, 0));
1017                 fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 1));
1018                 break;
1019             }
1020 
1021             switch (arrayMode.type()) {
1022             case Array::Double:
1023                 if (!arrayMode.isOutOfBounds())
1024                     node-&gt;setResult(NodeResultDouble);
1025                 break;
1026 
1027             case Array::Float32Array:
1028             case Array::Float64Array:
1029                 node-&gt;setResult(NodeResultDouble);
1030                 break;
1031 
1032             case Array::Uint32Array:
1033                 if (node-&gt;shouldSpeculateInt32())
1034                     break;
1035                 if (node-&gt;shouldSpeculateInt52())
1036                     node-&gt;setResult(NodeResultInt52);
1037                 else
1038                     node-&gt;setResult(NodeResultDouble);
1039                 break;
1040 
1041             default:
1042                 break;
1043             }
1044 
1045             break;
1046         }
1047 
1048         case PutByValDirect:
1049         case PutByVal:
1050         case PutByValAlias: {
1051             Edge&amp; child1 = m_graph.varArgChild(node, 0);
1052             Edge&amp; child2 = m_graph.varArgChild(node, 1);
1053             Edge&amp; child3 = m_graph.varArgChild(node, 2);
1054 
1055             node-&gt;setArrayMode(
1056                 node-&gt;arrayMode().refine(
1057                     m_graph, node,
1058                     child1-&gt;prediction(),
1059                     child2-&gt;prediction(),
1060                     child3-&gt;prediction()));
1061 
1062             blessArrayOperation(child1, child2, m_graph.varArgChild(node, 3));
1063 
1064             switch (node-&gt;arrayMode().modeForPut().type()) {
1065             case Array::SelectUsingPredictions:
1066             case Array::SelectUsingArguments:
1067             case Array::Unprofiled:
1068             case Array::Undecided:
1069                 RELEASE_ASSERT_NOT_REACHED();
1070                 break;
1071             case Array::ForceExit:
1072             case Array::Generic:
1073                 if (child1-&gt;shouldSpeculateCell()) {
1074                     if (child2-&gt;shouldSpeculateString()) {
1075                         fixEdge&lt;CellUse&gt;(child1);
1076                         fixEdge&lt;StringUse&gt;(child2);
1077                         break;
1078                     }
1079 
1080                     if (child2-&gt;shouldSpeculateSymbol()) {
1081                         fixEdge&lt;CellUse&gt;(child1);
1082                         fixEdge&lt;SymbolUse&gt;(child2);
1083                         break;
1084                     }
1085                 }
1086 #if USE(JSVALUE32_64)
1087                 // Due to register pressure on 32-bit, we speculate cell and
1088                 // ignore the base-is-not-cell case entirely by letting the
1089                 // baseline JIT handle it.
1090                 fixEdge&lt;CellUse&gt;(child1);
1091 #endif
1092                 break;
1093             case Array::Int32:
1094                 fixEdge&lt;KnownCellUse&gt;(child1);
1095                 fixEdge&lt;Int32Use&gt;(child2);
1096                 fixEdge&lt;Int32Use&gt;(child3);
1097                 break;
1098             case Array::Double:
1099                 fixEdge&lt;KnownCellUse&gt;(child1);
1100                 fixEdge&lt;Int32Use&gt;(child2);
1101                 fixEdge&lt;DoubleRepRealUse&gt;(child3);
1102                 break;
1103             case Array::Int8Array:
1104             case Array::Int16Array:
1105             case Array::Int32Array:
1106             case Array::Uint8Array:
1107             case Array::Uint8ClampedArray:
1108             case Array::Uint16Array:
1109             case Array::Uint32Array:
1110                 fixEdge&lt;KnownCellUse&gt;(child1);
1111                 fixEdge&lt;Int32Use&gt;(child2);
1112                 if (child3-&gt;shouldSpeculateInt32())
1113                     fixIntOrBooleanEdge(child3);
1114                 else if (child3-&gt;shouldSpeculateInt52())
1115                     fixEdge&lt;Int52RepUse&gt;(child3);
1116                 else
1117                     fixDoubleOrBooleanEdge(child3);
1118                 break;
1119             case Array::Float32Array:
1120             case Array::Float64Array:
1121                 fixEdge&lt;KnownCellUse&gt;(child1);
1122                 fixEdge&lt;Int32Use&gt;(child2);
1123                 fixDoubleOrBooleanEdge(child3);
1124                 break;
1125             case Array::Contiguous:
1126             case Array::ArrayStorage:
1127             case Array::SlowPutArrayStorage:
1128                 fixEdge&lt;KnownCellUse&gt;(child1);
1129                 fixEdge&lt;Int32Use&gt;(child2);
1130                 speculateForBarrier(child3);
1131                 break;
1132             default:
1133                 fixEdge&lt;KnownCellUse&gt;(child1);
1134                 fixEdge&lt;Int32Use&gt;(child2);
1135                 break;
1136             }
1137             break;
1138         }
1139 
1140         case AtomicsAdd:
1141         case AtomicsAnd:
1142         case AtomicsCompareExchange:
1143         case AtomicsExchange:
1144         case AtomicsLoad:
1145         case AtomicsOr:
1146         case AtomicsStore:
1147         case AtomicsSub:
1148         case AtomicsXor: {
1149             Edge&amp; base = m_graph.child(node, 0);
1150             Edge&amp; index = m_graph.child(node, 1);
1151 
1152             bool badNews = false;
1153             for (unsigned i = numExtraAtomicsArgs(node-&gt;op()); i--;) {
1154                 Edge&amp; child = m_graph.child(node, 2 + i);
1155                 // NOTE: DFG is not smart enough to handle double-&gt;int conversions in atomics. So, we
1156                 // just call the function when that happens. But the FTL is totally cool with those
1157                 // conversions.
1158                 if (!child-&gt;shouldSpeculateInt32()
1159                     &amp;&amp; !child-&gt;shouldSpeculateInt52()
1160                     &amp;&amp; !(child-&gt;shouldSpeculateNumberOrBoolean() &amp;&amp; m_graph.m_plan.isFTL()))
1161                     badNews = true;
1162             }
1163 
1164             if (badNews) {
1165                 node-&gt;setArrayMode(ArrayMode(Array::Generic, node-&gt;arrayMode().action()));
1166                 break;
1167             }
1168 
1169             node-&gt;setArrayMode(
1170                 node-&gt;arrayMode().refine(
1171                     m_graph, node, base-&gt;prediction(), index-&gt;prediction()));
1172 
1173             if (node-&gt;arrayMode().type() == Array::Generic)
1174                 break;
1175 
1176             for (unsigned i = numExtraAtomicsArgs(node-&gt;op()); i--;) {
1177                 Edge&amp; child = m_graph.child(node, 2 + i);
1178                 if (child-&gt;shouldSpeculateInt32())
1179                     fixIntOrBooleanEdge(child);
1180                 else if (child-&gt;shouldSpeculateInt52())
1181                     fixEdge&lt;Int52RepUse&gt;(child);
1182                 else {
1183                     RELEASE_ASSERT(child-&gt;shouldSpeculateNumberOrBoolean() &amp;&amp; m_graph.m_plan.isFTL());
1184                     fixDoubleOrBooleanEdge(child);
1185                 }
1186             }
1187 
1188             blessArrayOperation(base, index, m_graph.child(node, 2 + numExtraAtomicsArgs(node-&gt;op())));
1189             fixEdge&lt;CellUse&gt;(base);
1190             fixEdge&lt;Int32Use&gt;(index);
1191 
1192             if (node-&gt;arrayMode().type() == Array::Uint32Array) {
1193                 // NOTE: This means basically always doing Int52.
1194                 if (node-&gt;shouldSpeculateInt52())
1195                     node-&gt;setResult(NodeResultInt52);
1196                 else
1197                     node-&gt;setResult(NodeResultDouble);
1198             }
1199             break;
1200         }
1201 
1202         case AtomicsIsLockFree:
1203             if (node-&gt;child1()-&gt;shouldSpeculateInt32())
1204                 fixIntOrBooleanEdge(node-&gt;child1());
1205             break;
1206 
1207         case ArrayPush: {
1208             // May need to refine the array mode in case the value prediction contravenes
1209             // the array prediction. For example, we may have evidence showing that the
1210             // array is in Int32 mode, but the value we&#39;re storing is likely to be a double.
1211             // Then we should turn this into a conversion to Double array followed by the
1212             // push. On the other hand, we absolutely don&#39;t want to refine based on the
1213             // base prediction. If it has non-cell garbage in it, then we want that to be
1214             // ignored. That&#39;s because ArrayPush can&#39;t handle any array modes that aren&#39;t
1215             // array-related - so if refine() turned this into a &quot;Generic&quot; ArrayPush then
1216             // that would break things.
1217             Edge&amp; storageEdge = m_graph.varArgChild(node, 0);
1218             Edge&amp; arrayEdge = m_graph.varArgChild(node, 1);
1219             unsigned elementOffset = 2;
1220             unsigned elementCount = node-&gt;numChildren() - elementOffset;
1221             for (unsigned i = 0; i &lt; elementCount; ++i) {
1222                 Edge&amp; element = m_graph.varArgChild(node, i + elementOffset);
1223                 node-&gt;setArrayMode(
1224                     node-&gt;arrayMode().refine(
1225                         m_graph, node,
1226                         arrayEdge-&gt;prediction() &amp; SpecCell,
1227                         SpecInt32Only,
1228                         element-&gt;prediction()));
1229             }
1230             blessArrayOperation(arrayEdge, Edge(), storageEdge);
1231             fixEdge&lt;KnownCellUse&gt;(arrayEdge);
1232 
1233             // Convert `array.push()` to GetArrayLength.
1234             if (!elementCount &amp;&amp; node-&gt;arrayMode().supportsSelfLength()) {
1235                 node-&gt;setOpAndDefaultFlags(GetArrayLength);
1236                 node-&gt;child1() = arrayEdge;
1237                 node-&gt;child2() = storageEdge;
1238                 fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1239                 break;
1240             }
1241 
1242             // We do not want to perform osr exit and retry for ArrayPush. We insert Check with appropriate type,
1243             // and ArrayPush uses the edge as known typed edge. Therefore, ArrayPush do not need to perform type checks.
1244             for (unsigned i = 0; i &lt; elementCount; ++i) {
1245                 Edge&amp; element = m_graph.varArgChild(node, i + elementOffset);
1246                 switch (node-&gt;arrayMode().type()) {
1247                 case Array::Int32:
1248                     fixEdge&lt;Int32Use&gt;(element);
1249                     break;
1250                 case Array::Double:
1251                     fixEdge&lt;DoubleRepRealUse&gt;(element);
1252                     break;
1253                 case Array::Contiguous:
1254                 case Array::ArrayStorage:
1255                     speculateForBarrier(element);
1256                     break;
1257                 default:
1258                     break;
1259                 }
1260             }
1261             break;
1262         }
1263 
1264         case ArrayPop: {
1265             blessArrayOperation(node-&gt;child1(), Edge(), node-&gt;child2());
1266             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1267             break;
1268         }
1269 
1270         case ArraySlice: {
1271             fixEdge&lt;KnownCellUse&gt;(m_graph.varArgChild(node, 0));
1272             if (node-&gt;numChildren() &gt;= 3) {
1273                 fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 1));
1274                 if (node-&gt;numChildren() == 4)
1275                     fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 2));
1276             }
1277             break;
1278         }
1279 
1280         case ArrayIndexOf:
1281             fixupArrayIndexOf(node);
1282             break;
1283 
1284         case RegExpExec:
1285         case RegExpTest: {
1286             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1287 
1288             if (node-&gt;child2()-&gt;shouldSpeculateRegExpObject()) {
1289                 fixEdge&lt;RegExpObjectUse&gt;(node-&gt;child2());
1290 
1291                 if (node-&gt;child3()-&gt;shouldSpeculateString())
1292                     fixEdge&lt;StringUse&gt;(node-&gt;child3());
1293             }
1294             break;
1295         }
1296 
1297         case RegExpMatchFast: {
1298             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1299             fixEdge&lt;RegExpObjectUse&gt;(node-&gt;child2());
1300             fixEdge&lt;StringUse&gt;(node-&gt;child3());
1301             break;
1302         }
1303 
1304         case StringReplace:
1305         case StringReplaceRegExp: {
1306             if (node-&gt;child2()-&gt;shouldSpeculateString()) {
1307                 m_insertionSet.insertNode(
1308                     m_indexInBlock, SpecNone, Check, node-&gt;origin,
1309                     Edge(node-&gt;child2().node(), StringUse));
1310                 fixEdge&lt;StringUse&gt;(node-&gt;child2());
1311             } else if (op == StringReplace) {
1312                 if (node-&gt;child2()-&gt;shouldSpeculateRegExpObject())
1313                     addStringReplacePrimordialChecks(node-&gt;child2().node());
1314                 else
1315                     m_insertionSet.insertNode(
1316                         m_indexInBlock, SpecNone, ForceOSRExit, node-&gt;origin);
1317             }
1318 
1319             if (node-&gt;child1()-&gt;shouldSpeculateString()
1320                 &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateRegExpObject()
1321                 &amp;&amp; node-&gt;child3()-&gt;shouldSpeculateString()) {
1322 
1323                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
1324                 fixEdge&lt;RegExpObjectUse&gt;(node-&gt;child2());
1325                 fixEdge&lt;StringUse&gt;(node-&gt;child3());
1326                 break;
1327             }
1328             break;
1329         }
1330 
1331         case Branch: {
1332             if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
1333                 if (node-&gt;child1()-&gt;result() == NodeResultBoolean) {
1334                     // This is necessary in case we have a bytecode instruction implemented by:
1335                     //
1336                     // a: CompareEq(...)
1337                     // b: Branch(@a)
1338                     //
1339                     // In that case, CompareEq might have a side-effect. Then, we need to make
1340                     // sure that we know that Branch does not exit.
1341                     fixEdge&lt;KnownBooleanUse&gt;(node-&gt;child1());
1342                 } else
1343                     fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
1344             } else if (node-&gt;child1()-&gt;shouldSpeculateObjectOrOther())
1345                 fixEdge&lt;ObjectOrOtherUse&gt;(node-&gt;child1());
1346             else if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean())
1347                 fixIntOrBooleanEdge(node-&gt;child1());
1348             else if (node-&gt;child1()-&gt;shouldSpeculateNumber())
1349                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
1350             else if (node-&gt;child1()-&gt;shouldSpeculateString())
1351                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
1352             else if (node-&gt;child1()-&gt;shouldSpeculateStringOrOther())
1353                 fixEdge&lt;StringOrOtherUse&gt;(node-&gt;child1());
1354             else {
1355                 WatchpointSet* masqueradesAsUndefinedWatchpoint = m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;masqueradesAsUndefinedWatchpoint();
1356                 if (masqueradesAsUndefinedWatchpoint-&gt;isStillValid())
1357                     m_graph.watchpoints().addLazily(masqueradesAsUndefinedWatchpoint);
1358             }
1359             break;
1360         }
1361 
1362         case Switch: {
1363             SwitchData* data = node-&gt;switchData();
1364             switch (data-&gt;kind) {
1365             case SwitchImm:
1366                 if (node-&gt;child1()-&gt;shouldSpeculateInt32())
1367                     fixEdge&lt;Int32Use&gt;(node-&gt;child1());
1368                 break;
1369             case SwitchChar:
1370                 if (node-&gt;child1()-&gt;shouldSpeculateString())
1371                     fixEdge&lt;StringUse&gt;(node-&gt;child1());
1372                 break;
1373             case SwitchString:
1374                 if (node-&gt;child1()-&gt;shouldSpeculateStringIdent())
1375                     fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());
1376                 else if (node-&gt;child1()-&gt;shouldSpeculateString())
1377                     fixEdge&lt;StringUse&gt;(node-&gt;child1());
1378                 break;
1379             case SwitchCell:
1380                 if (node-&gt;child1()-&gt;shouldSpeculateCell())
1381                     fixEdge&lt;CellUse&gt;(node-&gt;child1());
1382                 // else it&#39;s fine for this to have UntypedUse; we will handle this by just making
1383                 // non-cells take the default case.
1384                 break;
1385             }
1386             break;
1387         }
1388 
1389         case ToPrimitive: {
1390             fixupToPrimitive(node);
1391             break;
1392         }
1393 
<a name="8" id="anc8"></a><span class="line-added">1394         case ToPropertyKey: {</span>
<span class="line-added">1395             if (node-&gt;child1()-&gt;shouldSpeculateString()) {</span>
<span class="line-added">1396                 fixEdge&lt;StringUse&gt;(node-&gt;child1());</span>
<span class="line-added">1397                 node-&gt;convertToIdentity();</span>
<span class="line-added">1398 </span>
<span class="line-added">1399                 return;</span>
<span class="line-added">1400             }</span>
<span class="line-added">1401 </span>
<span class="line-added">1402             if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {</span>
<span class="line-added">1403                 fixEdge&lt;SymbolUse&gt;(node-&gt;child1());</span>
<span class="line-added">1404                 node-&gt;convertToIdentity();</span>
<span class="line-added">1405                 return;</span>
<span class="line-added">1406             }</span>
<span class="line-added">1407 </span>
<span class="line-added">1408             if (node-&gt;child1()-&gt;shouldSpeculateStringObject()</span>
<span class="line-added">1409                 &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {</span>
<span class="line-added">1410                 addCheckStructureForOriginalStringObjectUse(StringObjectUse, node-&gt;origin, node-&gt;child1().node());</span>
<span class="line-added">1411                 fixEdge&lt;StringObjectUse&gt;(node-&gt;child1());</span>
<span class="line-added">1412                 node-&gt;convertToToString();</span>
<span class="line-added">1413                 return;</span>
<span class="line-added">1414             }</span>
<span class="line-added">1415 </span>
<span class="line-added">1416             if (node-&gt;child1()-&gt;shouldSpeculateStringOrStringObject()</span>
<span class="line-added">1417                 &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {</span>
<span class="line-added">1418                 addCheckStructureForOriginalStringObjectUse(StringOrStringObjectUse, node-&gt;origin, node-&gt;child1().node());</span>
<span class="line-added">1419                 fixEdge&lt;StringOrStringObjectUse&gt;(node-&gt;child1());</span>
<span class="line-added">1420                 node-&gt;convertToToString();</span>
<span class="line-added">1421                 return;</span>
<span class="line-added">1422             }</span>
<span class="line-added">1423             break;</span>
<span class="line-added">1424         }</span>
<span class="line-added">1425 </span>
1426         case ToNumber: {
1427             fixupToNumber(node);
1428             break;
1429         }
1430 
<a name="9" id="anc9"></a><span class="line-added">1431         case ToNumeric: {</span>
<span class="line-added">1432             fixupToNumeric(node);</span>
<span class="line-added">1433             break;</span>
<span class="line-added">1434         }</span>
<span class="line-added">1435 </span>
1436         case ToString:
1437         case CallStringConstructor: {
1438             fixupToStringOrCallStringConstructor(node);
1439             break;
1440         }
1441 
1442         case NewStringObject: {
1443             fixEdge&lt;KnownStringUse&gt;(node-&gt;child1());
1444             break;
1445         }
1446 
1447         case NewSymbol: {
1448             if (node-&gt;child1())
1449                 fixEdge&lt;KnownStringUse&gt;(node-&gt;child1());
1450             break;
1451         }
1452 
1453         case NewArrayWithSpread: {
1454             watchHavingABadTime(node);
1455 
1456             BitVector* bitVector = node-&gt;bitVector();
1457             for (unsigned i = node-&gt;numChildren(); i--;) {
1458                 if (bitVector-&gt;get(i))
1459                     fixEdge&lt;KnownCellUse&gt;(m_graph.m_varArgChildren[node-&gt;firstChild() + i]);
1460                 else
1461                     fixEdge&lt;UntypedUse&gt;(m_graph.m_varArgChildren[node-&gt;firstChild() + i]);
1462             }
1463 
1464             break;
1465         }
1466 
1467         case Spread: {
1468             // Note: We care about performing the protocol on our child&#39;s global object, not necessarily ours.
1469 
1470             watchHavingABadTime(node-&gt;child1().node());
1471 
1472             JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;child1()-&gt;origin.semantic);
1473             // When we go down the fast path, we don&#39;t consult the prototype chain, so we must prove
1474             // that it doesn&#39;t contain any indexed properties, and that any holes will result in
1475             // jsUndefined().
1476             Structure* arrayPrototypeStructure = globalObject-&gt;arrayPrototype()-&gt;structure(vm());
1477             Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(vm());
1478             if (node-&gt;child1()-&gt;shouldSpeculateArray()
1479                 &amp;&amp; arrayPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
1480                 &amp;&amp; objectPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
1481                 &amp;&amp; globalObject-&gt;arrayPrototypeChainIsSane()
1482                 &amp;&amp; m_graph.isWatchingArrayIteratorProtocolWatchpoint(node-&gt;child1().node())
1483                 &amp;&amp; m_graph.isWatchingHavingABadTimeWatchpoint(node-&gt;child1().node())) {
1484                 m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);
1485                 m_graph.registerAndWatchStructureTransition(arrayPrototypeStructure);
1486                 fixEdge&lt;ArrayUse&gt;(node-&gt;child1());
1487             } else
1488                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
1489             break;
1490         }
1491 
1492         case NewArray: {
1493             watchHavingABadTime(node);
1494 
1495             for (unsigned i = m_graph.varArgNumChildren(node); i--;) {
1496                 node-&gt;setIndexingType(
1497                     leastUpperBoundOfIndexingTypeAndType(
1498                         node-&gt;indexingType(), m_graph.varArgChild(node, i)-&gt;prediction()));
1499             }
1500             switch (node-&gt;indexingType()) {
1501             case ALL_BLANK_INDEXING_TYPES:
1502                 CRASH();
1503                 break;
1504             case ALL_UNDECIDED_INDEXING_TYPES:
1505                 if (node-&gt;numChildren()) {
1506                     // This will only happen if the children have no type predictions. We
1507                     // would have already exited by now, but insert a forced exit just to
1508                     // be safe.
1509                     m_insertionSet.insertNode(
1510                         m_indexInBlock, SpecNone, ForceOSRExit, node-&gt;origin);
1511                 }
1512                 break;
1513             case ALL_INT32_INDEXING_TYPES:
1514                 for (unsigned operandIndex = 0; operandIndex &lt; node-&gt;numChildren(); ++operandIndex)
1515                     fixEdge&lt;Int32Use&gt;(m_graph.m_varArgChildren[node-&gt;firstChild() + operandIndex]);
1516                 break;
1517             case ALL_DOUBLE_INDEXING_TYPES:
1518                 for (unsigned operandIndex = 0; operandIndex &lt; node-&gt;numChildren(); ++operandIndex)
1519                     fixEdge&lt;DoubleRepRealUse&gt;(m_graph.m_varArgChildren[node-&gt;firstChild() + operandIndex]);
1520                 break;
1521             case ALL_CONTIGUOUS_INDEXING_TYPES:
1522             case ALL_ARRAY_STORAGE_INDEXING_TYPES:
1523                 break;
1524             default:
1525                 CRASH();
1526                 break;
1527             }
1528             break;
1529         }
1530 
1531         case NewTypedArray: {
1532             watchHavingABadTime(node);
1533 
1534             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
1535                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());
1536                 node-&gt;clearFlags(NodeMustGenerate);
1537                 break;
1538             }
1539             break;
1540         }
1541 
1542         case NewArrayWithSize: {
1543             watchHavingABadTime(node);
1544             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
1545             break;
1546         }
1547 
1548         case NewArrayBuffer: {
1549             watchHavingABadTime(node);
1550             break;
1551         }
1552 
1553         case ToObject: {
1554             fixupToObject(node);
1555             break;
1556         }
1557 
1558         case CallObjectConstructor: {
1559             fixupCallObjectConstructor(node);
1560             break;
1561         }
1562 
1563         case ToThis: {
1564             fixupToThis(node);
1565             break;
1566         }
1567 
1568         case PutStructure: {
1569             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1570             break;
1571         }
1572 
1573         case GetClosureVar:
<a name="10" id="anc10"></a><span class="line-modified">1574         case GetFromArguments:</span>
<span class="line-added">1575         case GetInternalField: {</span>
1576             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1577             break;
1578         }
1579 
1580         case PutClosureVar:
<a name="11" id="anc11"></a><span class="line-modified">1581         case PutToArguments:</span>
<span class="line-added">1582         case PutInternalField: {</span>
1583             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1584             speculateForBarrier(node-&gt;child2());
1585             break;
1586         }
1587 
1588         case SkipScope:
1589         case GetScope:
1590         case GetGetter:
1591         case GetSetter:
1592         case GetGlobalObject: {
1593             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1594             break;
1595         }
1596 
1597         case AllocatePropertyStorage:
1598         case ReallocatePropertyStorage: {
1599             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1600             break;
1601         }
1602 
1603         case NukeStructureAndSetButterfly: {
1604             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1605             break;
1606         }
1607 
1608         case TryGetById: {
1609             if (node-&gt;child1()-&gt;shouldSpeculateCell())
1610                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
1611             break;
1612         }
1613 
1614         case GetByIdDirect:
1615         case GetByIdDirectFlush: {
1616             if (node-&gt;child1()-&gt;shouldSpeculateCell())
1617                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
1618             break;
1619         }
1620 
1621         case GetById:
1622         case GetByIdFlush: {
1623             // FIXME: This should be done in the ByteCodeParser based on reading the
1624             // PolymorphicAccess, which will surely tell us that this is a AccessCase::ArrayLength.
1625             // https://bugs.webkit.org/show_bug.cgi?id=154990
1626             auto uid = m_graph.identifiers()[node-&gt;identifierNumber()];
1627             if (node-&gt;child1()-&gt;shouldSpeculateCellOrOther()
1628                 &amp;&amp; !m_graph.hasExitSite(node-&gt;origin.semantic, BadType)
1629                 &amp;&amp; !m_graph.hasExitSite(node-&gt;origin.semantic, BadCache)
1630                 &amp;&amp; !m_graph.hasExitSite(node-&gt;origin.semantic, BadIndexingType)
1631                 &amp;&amp; !m_graph.hasExitSite(node-&gt;origin.semantic, ExoticObjectMode)) {
1632 
1633                 if (uid == vm().propertyNames-&gt;length.impl()) {
1634                     attemptToMakeGetArrayLength(node);
1635                     break;
1636                 }
1637 
1638                 if (uid == vm().propertyNames-&gt;lastIndex.impl()
1639                     &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateRegExpObject()) {
1640                     node-&gt;setOp(GetRegExpObjectLastIndex);
1641                     node-&gt;clearFlags(NodeMustGenerate);
1642                     fixEdge&lt;RegExpObjectUse&gt;(node-&gt;child1());
1643                     break;
1644                 }
1645             }
1646 
1647             if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
1648                 if (uid == vm().propertyNames-&gt;toString.impl()) {
1649                     if (m_graph.isWatchingNumberToStringWatchpoint(node)) {
1650                         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
1651                         if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
1652                             insertCheck&lt;Int32Use&gt;(node-&gt;child1().node());
1653                             m_graph.convertToConstant(node, m_graph.freeze(globalObject-&gt;numberProtoToStringFunction()));
1654                             break;
1655                         }
1656 
1657                         if (node-&gt;child1()-&gt;shouldSpeculateInt52()) {
1658                             insertCheck&lt;Int52RepUse&gt;(node-&gt;child1().node());
1659                             m_graph.convertToConstant(node, m_graph.freeze(globalObject-&gt;numberProtoToStringFunction()));
1660                             break;
1661                         }
1662 
1663                         ASSERT(node-&gt;child1()-&gt;shouldSpeculateNumber());
1664                         insertCheck&lt;DoubleRepUse&gt;(node-&gt;child1().node());
1665                         m_graph.convertToConstant(node, m_graph.freeze(globalObject-&gt;numberProtoToStringFunction()));
1666                         break;
1667                     }
1668                 }
1669             }
1670 
1671             if (node-&gt;child1()-&gt;shouldSpeculateCell())
1672                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
1673             break;
1674         }
1675 
1676         case GetByIdWithThis: {
1677             if (node-&gt;child1()-&gt;shouldSpeculateCell() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateCell()) {
1678                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
1679                 fixEdge&lt;CellUse&gt;(node-&gt;child2());
1680             }
1681             break;
1682         }
1683 
1684         case PutById:
1685         case PutByIdFlush:
1686         case PutByIdDirect: {
1687             if (node-&gt;child1()-&gt;shouldSpeculateCellOrOther()
1688                 &amp;&amp; !m_graph.hasExitSite(node-&gt;origin.semantic, BadType)
1689                 &amp;&amp; !m_graph.hasExitSite(node-&gt;origin.semantic, BadCache)
1690                 &amp;&amp; !m_graph.hasExitSite(node-&gt;origin.semantic, BadIndexingType)
1691                 &amp;&amp; !m_graph.hasExitSite(node-&gt;origin.semantic, ExoticObjectMode)) {
1692 
1693                 auto uid = m_graph.identifiers()[node-&gt;identifierNumber()];
1694 
1695                 if (uid == vm().propertyNames-&gt;lastIndex.impl()
1696                     &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateRegExpObject()) {
1697                     node-&gt;convertToSetRegExpObjectLastIndex();
1698                     fixEdge&lt;RegExpObjectUse&gt;(node-&gt;child1());
1699                     speculateForBarrier(node-&gt;child2());
1700                     break;
1701                 }
1702             }
1703 
1704             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1705             break;
1706         }
1707 
1708         case PutGetterById:
1709         case PutSetterById: {
1710             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1711             fixEdge&lt;KnownCellUse&gt;(node-&gt;child2());
1712             break;
1713         }
1714 
1715         case PutGetterSetterById: {
1716             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1717             break;
1718         }
1719 
1720         case PutGetterByVal:
1721         case PutSetterByVal: {
1722             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1723             fixEdge&lt;KnownCellUse&gt;(node-&gt;child3());
1724             break;
1725         }
1726 
1727         case GetExecutable: {
1728             fixEdge&lt;FunctionUse&gt;(node-&gt;child1());
1729             break;
1730         }
1731 
1732         case OverridesHasInstance:
1733         case CheckStructure:
1734         case CheckCell:
1735         case CreateThis:
<a name="12" id="anc12"></a><span class="line-added">1736         case CreatePromise:</span>
<span class="line-added">1737         case CreateGenerator:</span>
<span class="line-added">1738         case CreateAsyncGenerator:</span>
1739         case GetButterfly: {
1740             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1741             break;
1742         }
1743 
1744         case ObjectCreate: {
1745             if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
1746                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
1747                 node-&gt;clearFlags(NodeMustGenerate);
1748                 break;
1749             }
1750             break;
1751         }
1752 
1753         case ObjectKeys: {
1754             if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
1755                 watchHavingABadTime(node);
1756                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
1757             }
1758             break;
1759         }
1760 
<a name="13" id="anc13"></a><span class="line-modified">1761         case CheckIdent: {</span>
<span class="line-modified">1762             if (node-&gt;uidOperand()-&gt;isSymbol())</span>
<span class="line-added">1763                 fixEdge&lt;SymbolUse&gt;(node-&gt;child1());</span>
<span class="line-added">1764             else</span>
<span class="line-added">1765                 fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());</span>
1766             break;
1767         }
1768 
1769         case Arrayify:
1770         case ArrayifyToStructure: {
1771             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1772             if (node-&gt;child2())
1773                 fixEdge&lt;Int32Use&gt;(node-&gt;child2());
1774             break;
1775         }
1776 
1777         case GetByOffset:
1778         case GetGetterSetterByOffset: {
1779             if (!node-&gt;child1()-&gt;hasStorageResult())
1780                 fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1781             fixEdge&lt;KnownCellUse&gt;(node-&gt;child2());
1782             break;
1783         }
1784 
1785         case MultiGetByOffset: {
1786             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1787             break;
1788         }
1789 
1790         case PutByOffset: {
1791             if (!node-&gt;child1()-&gt;hasStorageResult())
1792                 fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1793             fixEdge&lt;KnownCellUse&gt;(node-&gt;child2());
1794             speculateForBarrier(node-&gt;child3());
1795             break;
1796         }
1797 
1798         case MultiPutByOffset: {
1799             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1800             break;
1801         }
1802 
1803         case MatchStructure: {
1804             // FIXME: Introduce a variant of MatchStructure that doesn&#39;t do a cell check.
1805             // https://bugs.webkit.org/show_bug.cgi?id=185784
1806             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1807             break;
1808         }
1809 
1810         case InstanceOf: {
1811             if (node-&gt;child1()-&gt;shouldSpeculateCell()
1812                 &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateCell()
1813                 &amp;&amp; is64Bit()) {
1814                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
1815                 fixEdge&lt;CellUse&gt;(node-&gt;child2());
1816                 break;
1817             }
1818             break;
1819         }
1820 
1821         case InstanceOfCustom:
1822             fixEdge&lt;CellUse&gt;(node-&gt;child2());
1823             break;
1824 
1825         case InById: {
1826             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1827             break;
1828         }
1829 
1830         case InByVal: {
1831             if (node-&gt;child2()-&gt;shouldSpeculateInt32()) {
1832                 convertToHasIndexedProperty(node);
1833                 break;
1834             }
1835 
1836             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1837             break;
1838         }
1839 
1840         case HasOwnProperty: {
1841             fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
<a name="14" id="anc14"></a>



1842             if (node-&gt;child2()-&gt;shouldSpeculateString())
1843                 fixEdge&lt;StringUse&gt;(node-&gt;child2());
1844             else if (node-&gt;child2()-&gt;shouldSpeculateSymbol())
1845                 fixEdge&lt;SymbolUse&gt;(node-&gt;child2());
1846             else
1847                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
<a name="15" id="anc15"></a>
1848             break;
1849         }
1850 
1851         case CheckVarargs:
1852         case Check: {
1853             m_graph.doToChildren(
1854                 node,
1855                 [&amp;] (Edge&amp; edge) {
1856                     switch (edge.useKind()) {
1857                     case NumberUse:
1858                         if (edge-&gt;shouldSpeculateInt32ForArithmetic())
1859                             edge.setUseKind(Int32Use);
1860                         break;
1861                     default:
1862                         break;
1863                     }
1864                     observeUseKindOnEdge(edge);
1865                 });
1866             break;
1867         }
1868 
1869         case Phantom:
1870             // Phantoms are meaningless past Fixup. We recreate them on-demand in the backend.
1871             node-&gt;remove(m_graph);
1872             break;
1873 
1874         case FiatInt52: {
1875             RELEASE_ASSERT(enableInt52());
1876             node-&gt;convertToIdentity();
1877             fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
1878             node-&gt;setResult(NodeResultInt52);
1879             break;
1880         }
1881 
1882         case GetArrayLength: {
1883             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1884             break;
1885         }
1886 
1887         case GetTypedArrayByteOffset: {
1888             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
1889             break;
1890         }
1891 
1892         case CompareBelow:
1893         case CompareBelowEq: {
1894             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
1895             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
1896             break;
1897         }
1898 
1899         case GetPrototypeOf: {
1900             fixupGetPrototypeOf(node);
1901             break;
1902         }
1903 
<a name="16" id="anc16"></a><span class="line-added">1904         case CheckNeutered:</span>
<span class="line-added">1905         case CheckArray: {</span>
<span class="line-added">1906             fixEdge&lt;CellUse&gt;(node-&gt;child1());</span>
<span class="line-added">1907             break;</span>
<span class="line-added">1908         }</span>
<span class="line-added">1909 </span>
1910         case Phi:
1911         case Upsilon:
1912         case EntrySwitch:
1913         case GetIndexedPropertyStorage:
1914         case LastNodeType:
1915         case CheckTierUpInLoop:
1916         case CheckTierUpAtReturn:
1917         case CheckTierUpAndOSREnter:
<a name="17" id="anc17"></a>
1918         case CheckInBounds:
1919         case ConstantStoragePointer:
1920         case DoubleAsInt32:
1921         case ValueToInt32:
1922         case DoubleRep:
1923         case ValueRep:
1924         case Int52Rep:
1925         case Int52Constant:
1926         case Identity: // This should have been cleaned up.
1927         case BooleanToNumber:
1928         case PhantomNewObject:
1929         case PhantomNewFunction:
1930         case PhantomNewGeneratorFunction:
1931         case PhantomNewAsyncGeneratorFunction:
1932         case PhantomNewAsyncFunction:
<a name="18" id="anc18"></a><span class="line-added">1933         case PhantomNewArrayIterator:</span>
1934         case PhantomCreateActivation:
1935         case PhantomDirectArguments:
1936         case PhantomCreateRest:
1937         case PhantomSpread:
1938         case PhantomNewArrayWithSpread:
1939         case PhantomNewArrayBuffer:
1940         case PhantomClonedArguments:
1941         case PhantomNewRegexp:
1942         case GetMyArgumentByVal:
1943         case GetMyArgumentByValOutOfBounds:
1944         case GetVectorLength:
1945         case PutHint:
1946         case CheckStructureImmediate:
1947         case CheckStructureOrEmpty:
<a name="19" id="anc19"></a><span class="line-added">1948         case CheckArrayOrEmpty:</span>
1949         case MaterializeNewObject:
1950         case MaterializeCreateActivation:
<a name="20" id="anc20"></a><span class="line-added">1951         case MaterializeNewInternalFieldObject:</span>
1952         case PutStack:
1953         case KillStack:
1954         case GetStack:
1955         case StoreBarrier:
1956         case FencedStoreBarrier:
1957         case GetRegExpObjectLastIndex:
1958         case SetRegExpObjectLastIndex:
1959         case RecordRegExpCachedResult:
1960         case RegExpExecNonGlobalOrSticky:
1961         case RegExpMatchFastGlobal:
1962             // These are just nodes that we don&#39;t currently expect to see during fixup.
1963             // If we ever wanted to insert them prior to fixup, then we just have to create
1964             // fixup rules for them.
1965             DFG_CRASH(m_graph, node, &quot;Unexpected node during fixup&quot;);
1966             break;
1967 
1968         case PutGlobalVariable: {
1969             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1970             speculateForBarrier(node-&gt;child2());
1971             break;
1972         }
1973 
1974         case IsObject:
1975             if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
1976                 m_insertionSet.insertNode(
1977                     m_indexInBlock, SpecNone, Check, node-&gt;origin,
1978                     Edge(node-&gt;child1().node(), ObjectUse));
1979                 m_graph.convertToConstant(node, jsBoolean(true));
1980                 observeUseKindOnNode&lt;ObjectUse&gt;(node);
1981             }
1982             break;
1983 
1984         case IsCellWithType: {
1985             fixupIsCellWithType(node);
1986             break;
1987         }
1988 
1989         case GetEnumerableLength: {
1990             fixEdge&lt;CellUse&gt;(node-&gt;child1());
1991             break;
1992         }
1993         case HasGenericProperty: {
1994             fixEdge&lt;CellUse&gt;(node-&gt;child2());
1995             break;
1996         }
1997         case HasStructureProperty: {
1998             fixEdge&lt;StringUse&gt;(node-&gt;child2());
1999             fixEdge&lt;KnownCellUse&gt;(node-&gt;child3());
2000             break;
2001         }
2002         case HasIndexedProperty: {
2003             node-&gt;setArrayMode(
2004                 node-&gt;arrayMode().refine(
2005                     m_graph, node,
2006                     m_graph.varArgChild(node, 0)-&gt;prediction(),
2007                     m_graph.varArgChild(node, 1)-&gt;prediction(),
2008                     SpecNone));
2009 
2010             blessArrayOperation(m_graph.varArgChild(node, 0), m_graph.varArgChild(node, 1), m_graph.varArgChild(node, 2));
2011             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 0));
2012             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 1));
2013             break;
2014         }
2015         case GetDirectPname: {
2016             Edge&amp; base = m_graph.varArgChild(node, 0);
2017             Edge&amp; property = m_graph.varArgChild(node, 1);
2018             Edge&amp; index = m_graph.varArgChild(node, 2);
2019             Edge&amp; enumerator = m_graph.varArgChild(node, 3);
2020             fixEdge&lt;CellUse&gt;(base);
2021             fixEdge&lt;KnownCellUse&gt;(property);
2022             fixEdge&lt;Int32Use&gt;(index);
2023             fixEdge&lt;KnownCellUse&gt;(enumerator);
2024             break;
2025         }
2026         case GetPropertyEnumerator: {
2027             if (node-&gt;child1()-&gt;shouldSpeculateCell())
2028                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
2029             break;
2030         }
2031         case GetEnumeratorStructurePname: {
2032             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
2033             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
2034             break;
2035         }
2036         case GetEnumeratorGenericPname: {
2037             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
2038             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
2039             break;
2040         }
2041         case ToIndexString: {
2042             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2043             break;
2044         }
2045         case ProfileType: {
2046             // We want to insert type checks based on the instructionTypeSet of the TypeLocation, not the globalTypeSet.
2047             // Because the instructionTypeSet is contained in globalTypeSet, if we produce a type check for
2048             // type T for the instructionTypeSet, the global type set must also have information for type T.
2049             // So if it the type check succeeds for type T in the instructionTypeSet, a type check for type T
2050             // in the globalTypeSet would&#39;ve also succeeded.
2051             // (The other direction does not hold in general).
2052 
2053             RefPtr&lt;TypeSet&gt; typeSet = node-&gt;typeLocation()-&gt;m_instructionTypeSet;
2054             RuntimeTypeMask seenTypes = typeSet-&gt;seenTypes();
2055             if (typeSet-&gt;doesTypeConformTo(TypeAnyInt)) {
2056                 if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2057                     fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2058                     node-&gt;remove(m_graph);
2059                     break;
2060                 }
2061 
2062                 if (enableInt52()) {
2063                     fixEdge&lt;AnyIntUse&gt;(node-&gt;child1());
2064                     node-&gt;remove(m_graph);
2065                     break;
2066                 }
2067 
2068                 // Must not perform fixEdge&lt;NumberUse&gt; here since the type set only includes TypeAnyInt. Double values should be logged.
2069             }
2070 
2071             if (typeSet-&gt;doesTypeConformTo(TypeNumber | TypeAnyInt)) {
2072                 fixEdge&lt;NumberUse&gt;(node-&gt;child1());
2073                 node-&gt;remove(m_graph);
2074             } else if (typeSet-&gt;doesTypeConformTo(TypeString)) {
2075                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
2076                 node-&gt;remove(m_graph);
2077             } else if (typeSet-&gt;doesTypeConformTo(TypeBoolean)) {
2078                 fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
2079                 node-&gt;remove(m_graph);
2080             } else if (typeSet-&gt;doesTypeConformTo(TypeUndefined | TypeNull) &amp;&amp; (seenTypes &amp; TypeUndefined) &amp;&amp; (seenTypes &amp; TypeNull)) {
2081                 fixEdge&lt;OtherUse&gt;(node-&gt;child1());
2082                 node-&gt;remove(m_graph);
2083             } else if (typeSet-&gt;doesTypeConformTo(TypeObject)) {
2084                 StructureSet set;
2085                 {
2086                     ConcurrentJSLocker locker(typeSet-&gt;m_lock);
2087                     set = typeSet-&gt;structureSet(locker);
2088                 }
2089                 if (!set.isEmpty()) {
2090                     fixEdge&lt;CellUse&gt;(node-&gt;child1());
2091                     node-&gt;convertToCheckStructureOrEmpty(m_graph.addStructureSet(set));
2092                 }
2093             }
2094 
2095             break;
2096         }
2097 
2098         case CreateClonedArguments: {
2099             watchHavingABadTime(node);
2100             break;
2101         }
2102 
2103         case CreateScopedArguments:
2104         case CreateActivation:
2105         case NewFunction:
2106         case NewGeneratorFunction:
2107         case NewAsyncGeneratorFunction:
2108         case NewAsyncFunction: {
2109             // Child 1 is always the current scope, which is guaranteed to be an object
2110             // FIXME: should be KnownObjectUse once that exists (https://bugs.webkit.org/show_bug.cgi?id=175689)
2111             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
2112             break;
2113         }
2114 
2115         case PushWithScope: {
2116             // Child 1 is always the current scope, which is guaranteed to be an object
2117             // FIXME: should be KnownObjectUse once that exists (https://bugs.webkit.org/show_bug.cgi?id=175689)
2118             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
2119             if (node-&gt;child2()-&gt;shouldSpeculateObject())
2120                 fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
2121             break;
2122         }
2123 
2124         case SetFunctionName: {
2125             // The first child is guaranteed to be a cell because op_set_function_name is only used
2126             // on a newly instantiated function object (the first child).
2127             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
2128             fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
2129             break;
2130         }
2131 
2132         case CreateRest: {
2133             watchHavingABadTime(node);
2134             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2135             break;
2136         }
2137 
2138         case ResolveScopeForHoistingFuncDeclInEval: {
2139             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
2140             break;
2141         }
2142         case ResolveScope:
2143         case GetDynamicVar:
2144         case PutDynamicVar: {
2145             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
2146             break;
2147         }
2148 
2149         case LogShadowChickenPrologue: {
2150             fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
2151             break;
2152         }
2153         case LogShadowChickenTail: {
2154             fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
2155             fixEdge&lt;KnownCellUse&gt;(node-&gt;child2());
2156             break;
2157         }
2158 
2159         case GetMapBucket:
2160             if (node-&gt;child1().useKind() == MapObjectUse)
2161                 fixEdge&lt;MapObjectUse&gt;(node-&gt;child1());
2162             else if (node-&gt;child1().useKind() == SetObjectUse)
2163                 fixEdge&lt;SetObjectUse&gt;(node-&gt;child1());
2164             else
2165                 RELEASE_ASSERT_NOT_REACHED();
2166 
2167 #if USE(JSVALUE64)
2168             if (node-&gt;child2()-&gt;shouldSpeculateBoolean())
2169                 fixEdge&lt;BooleanUse&gt;(node-&gt;child2());
2170             else if (node-&gt;child2()-&gt;shouldSpeculateInt32())
2171                 fixEdge&lt;Int32Use&gt;(node-&gt;child2());
2172             else if (node-&gt;child2()-&gt;shouldSpeculateSymbol())
2173                 fixEdge&lt;SymbolUse&gt;(node-&gt;child2());
2174             else if (node-&gt;child2()-&gt;shouldSpeculateObject())
2175                 fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
2176             else if (node-&gt;child2()-&gt;shouldSpeculateString())
2177                 fixEdge&lt;StringUse&gt;(node-&gt;child2());
2178             else if (node-&gt;child2()-&gt;shouldSpeculateCell())
2179                 fixEdge&lt;CellUse&gt;(node-&gt;child2());
2180             else
2181                 fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
2182 #else
2183             fixEdge&lt;UntypedUse&gt;(node-&gt;child2());
2184 #endif // USE(JSVALUE64)
2185 
2186             fixEdge&lt;Int32Use&gt;(node-&gt;child3());
2187             break;
2188 
2189         case GetMapBucketHead:
2190             if (node-&gt;child1().useKind() == MapObjectUse)
2191                 fixEdge&lt;MapObjectUse&gt;(node-&gt;child1());
2192             else if (node-&gt;child1().useKind() == SetObjectUse)
2193                 fixEdge&lt;SetObjectUse&gt;(node-&gt;child1());
2194             else
2195                 RELEASE_ASSERT_NOT_REACHED();
2196             break;
2197 
2198         case GetMapBucketNext:
2199         case LoadKeyFromMapBucket:
2200         case LoadValueFromMapBucket:
2201             fixEdge&lt;CellUse&gt;(node-&gt;child1());
2202             break;
2203 
2204         case MapHash: {
2205 #if USE(JSVALUE64)
2206             if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
2207                 fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
2208                 break;
2209             }
2210 
2211             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2212                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2213                 break;
2214             }
2215 
2216             if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
2217                 fixEdge&lt;SymbolUse&gt;(node-&gt;child1());
2218                 break;
2219             }
2220 
2221             if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
2222                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
2223                 break;
2224             }
2225 
2226             if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2227                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
2228                 break;
2229             }
2230 
2231             if (node-&gt;child1()-&gt;shouldSpeculateCell()) {
2232                 fixEdge&lt;CellUse&gt;(node-&gt;child1());
2233                 break;
2234             }
2235 
2236             fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
2237 #else
2238             fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
2239 #endif // USE(JSVALUE64)
2240             break;
2241         }
2242 
2243         case NormalizeMapKey: {
2244             fixupNormalizeMapKey(node);
2245             break;
2246         }
2247 
2248         case WeakMapGet: {
2249             if (node-&gt;child1().useKind() == WeakMapObjectUse)
2250                 fixEdge&lt;WeakMapObjectUse&gt;(node-&gt;child1());
2251             else if (node-&gt;child1().useKind() == WeakSetObjectUse)
2252                 fixEdge&lt;WeakSetObjectUse&gt;(node-&gt;child1());
2253             else
2254                 RELEASE_ASSERT_NOT_REACHED();
2255             fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
2256             fixEdge&lt;Int32Use&gt;(node-&gt;child3());
2257             break;
2258         }
2259 
2260         case SetAdd: {
2261             fixEdge&lt;SetObjectUse&gt;(node-&gt;child1());
2262             fixEdge&lt;Int32Use&gt;(node-&gt;child3());
2263             break;
2264         }
2265 
2266         case MapSet: {
2267             fixEdge&lt;MapObjectUse&gt;(m_graph.varArgChild(node, 0));
2268             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 3));
2269             break;
2270         }
2271 
2272         case WeakSetAdd: {
2273             fixEdge&lt;WeakSetObjectUse&gt;(node-&gt;child1());
2274             fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
2275             fixEdge&lt;Int32Use&gt;(node-&gt;child3());
2276             break;
2277         }
2278 
2279         case WeakMapSet: {
2280             fixEdge&lt;WeakMapObjectUse&gt;(m_graph.varArgChild(node, 0));
2281             fixEdge&lt;ObjectUse&gt;(m_graph.varArgChild(node, 1));
2282             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 3));
2283             break;
2284         }
2285 
2286         case DefineDataProperty: {
2287             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 0));
2288             Edge&amp; propertyEdge = m_graph.varArgChild(node, 1);
2289             if (propertyEdge-&gt;shouldSpeculateSymbol())
2290                 fixEdge&lt;SymbolUse&gt;(propertyEdge);
2291             else if (propertyEdge-&gt;shouldSpeculateStringIdent())
2292                 fixEdge&lt;StringIdentUse&gt;(propertyEdge);
2293             else if (propertyEdge-&gt;shouldSpeculateString())
2294                 fixEdge&lt;StringUse&gt;(propertyEdge);
2295             else
2296                 fixEdge&lt;UntypedUse&gt;(propertyEdge);
2297             fixEdge&lt;UntypedUse&gt;(m_graph.varArgChild(node, 2));
2298             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 3));
2299             break;
2300         }
2301 
2302         case StringValueOf: {
2303             fixupStringValueOf(node);
2304             break;
2305         }
2306 
2307         case StringSlice: {
2308             fixEdge&lt;StringUse&gt;(node-&gt;child1());
2309             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
2310             if (node-&gt;child3())
2311                 fixEdge&lt;Int32Use&gt;(node-&gt;child3());
2312             break;
2313         }
2314 
2315         case ToLowerCase: {
2316             // We currently only support StringUse since that will ensure that
2317             // ToLowerCase is a pure operation. If we decide to update this with
2318             // more types in the future, we need to ensure that the clobberize rules
2319             // are correct.
2320             fixEdge&lt;StringUse&gt;(node-&gt;child1());
2321             break;
2322         }
2323 
2324         case NumberToStringWithRadix: {
2325             if (node-&gt;child1()-&gt;shouldSpeculateInt32())
2326                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2327             else if (node-&gt;child1()-&gt;shouldSpeculateInt52())
2328                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
2329             else
2330                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
2331             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
2332             break;
2333         }
2334 
2335         case DefineAccessorProperty: {
2336             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 0));
2337             Edge&amp; propertyEdge = m_graph.varArgChild(node, 1);
2338             if (propertyEdge-&gt;shouldSpeculateSymbol())
2339                 fixEdge&lt;SymbolUse&gt;(propertyEdge);
2340             else if (propertyEdge-&gt;shouldSpeculateStringIdent())
2341                 fixEdge&lt;StringIdentUse&gt;(propertyEdge);
2342             else if (propertyEdge-&gt;shouldSpeculateString())
2343                 fixEdge&lt;StringUse&gt;(propertyEdge);
2344             else
2345                 fixEdge&lt;UntypedUse&gt;(propertyEdge);
2346             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 2));
2347             fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 3));
2348             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 4));
2349             break;
2350         }
2351 
2352         case CheckSubClass: {
2353             fixupCheckSubClass(node);
2354             break;
2355         }
2356 
2357         case CallDOMGetter: {
2358             DOMJIT::CallDOMGetterSnippet* snippet = node-&gt;callDOMGetterData()-&gt;snippet;
2359             fixEdge&lt;CellUse&gt;(node-&gt;child1()); // DOM.
2360             if (snippet &amp;&amp; snippet-&gt;requireGlobalObject)
2361                 fixEdge&lt;KnownCellUse&gt;(node-&gt;child2()); // GlobalObject.
2362             break;
2363         }
2364 
2365         case CallDOM: {
2366             fixupCallDOM(node);
2367             break;
2368         }
2369 
2370         case Call: {
2371             attemptToMakeCallDOM(node);
2372             break;
2373         }
2374 
2375         case ParseInt: {
2376             if (node-&gt;child1()-&gt;shouldSpeculateInt32() &amp;&amp; !node-&gt;child2()) {
2377                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2378                 node-&gt;convertToIdentity();
2379                 break;
2380             }
2381 
2382             if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2383                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
2384                 node-&gt;clearFlags(NodeMustGenerate);
2385             }
2386 
2387             if (node-&gt;child2())
2388                 fixEdge&lt;Int32Use&gt;(node-&gt;child2());
2389 
2390             break;
2391         }
2392 
2393         case IdentityWithProfile: {
2394             node-&gt;clearFlags(NodeMustGenerate);
2395             break;
2396         }
2397 
2398         case ThrowStaticError:
2399             fixEdge&lt;StringUse&gt;(node-&gt;child1());
2400             break;
2401 
2402         case NumberIsInteger:
2403             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2404                 m_insertionSet.insertNode(
2405                     m_indexInBlock, SpecNone, Check, node-&gt;origin,
2406                     Edge(node-&gt;child1().node(), Int32Use));
2407                 m_graph.convertToConstant(node, jsBoolean(true));
2408                 break;
2409             }
2410             break;
2411 
2412         case SetCallee:
2413             fixEdge&lt;CellUse&gt;(node-&gt;child1());
2414             break;
2415 
<a name="21" id="anc21"></a><span class="line-added">2416         case DateGetInt32OrNaN:</span>
<span class="line-added">2417         case DateGetTime:</span>
<span class="line-added">2418             fixEdge&lt;DateObjectUse&gt;(node-&gt;child1());</span>
<span class="line-added">2419             break;</span>
<span class="line-added">2420 </span>
2421         case DataViewGetInt:
2422         case DataViewGetFloat: {
2423             fixEdge&lt;DataViewObjectUse&gt;(node-&gt;child1());
2424             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
2425             if (node-&gt;child3())
2426                 fixEdge&lt;BooleanUse&gt;(node-&gt;child3());
2427 
2428             if (node-&gt;op() == DataViewGetInt) {
2429                 DataViewData data = node-&gt;dataViewData();
2430                 switch (data.byteSize) {
2431                 case 1:
2432                 case 2:
2433                     node-&gt;setResult(NodeResultInt32);
2434                     break;
2435                 case 4:
2436                     if (data.isSigned)
2437                         node-&gt;setResult(NodeResultInt32);
2438                     else
2439                         node-&gt;setResult(NodeResultInt52);
2440                     break;
2441                 default:
2442                     RELEASE_ASSERT_NOT_REACHED();
2443                 }
2444             }
2445             break;
2446         }
2447 
2448         case DataViewSet: {
2449             fixEdge&lt;DataViewObjectUse&gt;(m_graph.varArgChild(node, 0));
2450             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 1));
2451             if (m_graph.varArgChild(node, 3))
2452                 fixEdge&lt;BooleanUse&gt;(m_graph.varArgChild(node, 3));
2453 
2454             DataViewData data = node-&gt;dataViewData();
2455             Edge&amp; valueToStore = m_graph.varArgChild(node, 2);
2456             if (data.isFloatingPoint)
2457                 fixEdge&lt;DoubleRepUse&gt;(valueToStore);
2458             else {
2459                 switch (data.byteSize) {
2460                 case 1:
2461                 case 2:
2462                     fixEdge&lt;Int32Use&gt;(valueToStore);
2463                     break;
2464                 case 4:
2465                     if (data.isSigned)
2466                         fixEdge&lt;Int32Use&gt;(valueToStore);
2467                     else
2468                         fixEdge&lt;Int52RepUse&gt;(valueToStore);
2469                     break;
2470                 }
2471             }
2472             break;
2473         }
2474 
<a name="22" id="anc22"></a><span class="line-modified">2475         case ForwardVarargs:</span>
<span class="line-added">2476         case LoadVarargs: {</span>
<span class="line-added">2477             fixEdge&lt;KnownInt32Use&gt;(node-&gt;child1());</span>
<span class="line-added">2478             break;</span>
<span class="line-added">2479         }</span>
<span class="line-added">2480 </span>
<span class="line-added">2481 #if ASSERT_ENABLED</span>
2482         // Have these no-op cases here to ensure that nobody forgets to add handlers for new opcodes.
2483         case SetArgumentDefinitely:
2484         case SetArgumentMaybe:
2485         case JSConstant:
2486         case LazyJSConstant:
2487         case DoubleConstant:
2488         case GetLocal:
2489         case GetCallee:
2490         case GetArgumentCountIncludingThis:
2491         case SetArgumentCountIncludingThis:
2492         case GetRestLength:
2493         case GetArgument:
2494         case Flush:
2495         case PhantomLocal:
2496         case GetGlobalVar:
2497         case GetGlobalLexicalVariable:
2498         case NotifyWrite:
2499         case DirectCall:
2500         case CheckTypeInfoFlags:
2501         case TailCallInlinedCaller:
2502         case DirectTailCallInlinedCaller:
2503         case Construct:
2504         case DirectConstruct:
2505         case CallVarargs:
2506         case CallEval:
2507         case TailCallVarargsInlinedCaller:
2508         case ConstructVarargs:
2509         case CallForwardVarargs:
2510         case ConstructForwardVarargs:
2511         case TailCallForwardVarargs:
2512         case TailCallForwardVarargsInlinedCaller:
<a name="23" id="anc23"></a><span class="line-modified">2513         case VarargsLength:</span>

2514         case ProfileControlFlow:
2515         case NewObject:
<a name="24" id="anc24"></a><span class="line-added">2516         case NewPromise:</span>
<span class="line-added">2517         case NewGenerator:</span>
<span class="line-added">2518         case NewAsyncGenerator:</span>
<span class="line-added">2519         case NewArrayIterator:</span>
2520         case NewRegexp:
2521         case DeleteById:
2522         case DeleteByVal:
2523         case IsTypedArrayView:
2524         case IsEmpty:
2525         case IsUndefined:
2526         case IsUndefinedOrNull:
2527         case IsBoolean:
2528         case IsNumber:
2529         case IsObjectOrNull:
2530         case IsFunction:
2531         case CreateDirectArguments:
2532         case Jump:
2533         case Return:
2534         case TailCall:
2535         case DirectTailCall:
2536         case TailCallVarargs:
2537         case Throw:
2538         case CountExecution:
2539         case SuperSamplerBegin:
2540         case SuperSamplerEnd:
2541         case ForceOSRExit:
2542         case CheckBadCell:
2543         case CheckNotEmpty:
2544         case AssertNotEmpty:
2545         case CheckTraps:
2546         case Unreachable:
2547         case ExtractOSREntryLocal:
2548         case ExtractCatchLocal:
2549         case ClearCatchLocals:
2550         case LoopHint:
2551         case MovHint:
2552         case InitializeEntrypointArguments:
2553         case ZombieHint:
2554         case ExitOK:
2555         case BottomValue:
2556         case TypeOf:
2557         case PutByIdWithThis:
2558         case PutByValWithThis:
2559         case GetByValWithThis:
2560         case CompareEqPtr:
2561         case NumberToStringWithValidRadixConstant:
2562         case GetGlobalThis:
2563         case ExtractValueFromWeakMapGet:
2564         case CPUIntrinsic:
2565         case FilterCallLinkStatus:
<a name="25" id="anc25"></a><span class="line-modified">2566         case FilterGetByStatus:</span>
2567         case FilterPutByIdStatus:
2568         case FilterInByIdStatus:
2569         case InvalidationPoint:
<a name="26" id="anc26"></a><span class="line-added">2570         case CreateArgumentsButterfly:</span>
2571             break;
<a name="27" id="anc27"></a><span class="line-modified">2572 #else // not ASSERT_ENABLED</span>
2573         default:
2574             break;
<a name="28" id="anc28"></a><span class="line-modified">2575 #endif // not ASSERT_ENABLED</span>
2576         }
2577     }
2578 
2579     void watchHavingABadTime(Node* node)
2580     {
2581         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
2582 
2583         // If this global object is not having a bad time, watch it. We go down this path anytime the code
2584         // does an array allocation. The types of array allocations may change if we start to have a bad
2585         // time. It&#39;s easier to reason about this if we know that whenever the types change after we start
2586         // optimizing, the code just gets thrown out. Doing this at FixupPhase is just early enough, since
2587         // prior to this point nobody should have been doing optimizations based on the indexing type of
2588         // the allocation.
2589         if (!globalObject-&gt;isHavingABadTime()) {
2590             m_graph.watchpoints().addLazily(globalObject-&gt;havingABadTimeWatchpoint());
2591             m_graph.freeze(globalObject);
2592         }
2593     }
2594 
2595     template&lt;UseKind useKind&gt;
2596     void createToString(Node* node, Edge&amp; edge)
2597     {
2598         Node* toString = m_insertionSet.insertNode(
2599             m_indexInBlock, SpecString, ToString, node-&gt;origin,
2600             Edge(edge.node(), useKind));
2601         switch (useKind) {
2602         case Int32Use:
2603         case Int52RepUse:
2604         case DoubleRepUse:
2605         case NotCellUse:
2606             toString-&gt;clearFlags(NodeMustGenerate);
2607             break;
2608         default:
2609             break;
2610         }
2611         edge.setNode(toString);
2612     }
2613 
2614     template&lt;UseKind useKind&gt;
2615     void attemptToForceStringArrayModeByToStringConversion(ArrayMode&amp; arrayMode, Node* node)
2616     {
2617         ASSERT(arrayMode == ArrayMode(Array::Generic, Array::Read) || arrayMode == ArrayMode(Array::Generic, Array::OriginalNonArray, Array::Read));
2618 
2619         if (!m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic))
2620             return;
2621 
2622         addCheckStructureForOriginalStringObjectUse(useKind, node-&gt;origin, node-&gt;child1().node());
2623         createToString&lt;useKind&gt;(node, node-&gt;child1());
2624         arrayMode = ArrayMode(Array::String, Array::Read);
2625     }
2626 
2627     void addCheckStructureForOriginalStringObjectUse(UseKind useKind, const NodeOrigin&amp; origin, Node* node)
2628     {
2629         RELEASE_ASSERT(useKind == StringObjectUse || useKind == StringOrStringObjectUse);
2630 
2631         StructureSet set;
2632         set.add(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;stringObjectStructure());
2633         if (useKind == StringOrStringObjectUse)
2634             set.add(vm().stringStructure.get());
2635 
2636         m_insertionSet.insertNode(
2637             m_indexInBlock, SpecNone, CheckStructure, origin,
2638             OpInfo(m_graph.addStructureSet(set)), Edge(node, CellUse));
2639     }
2640 
2641     template&lt;UseKind useKind&gt;
2642     void convertStringAddUse(Node* node, Edge&amp; edge)
2643     {
2644         if (useKind == StringUse) {
2645             observeUseKindOnNode&lt;StringUse&gt;(edge.node());
2646             m_insertionSet.insertNode(
2647                 m_indexInBlock, SpecNone, Check, node-&gt;origin,
2648                 Edge(edge.node(), StringUse));
2649             edge.setUseKind(KnownStringUse);
2650             return;
2651         }
2652 
2653         observeUseKindOnNode&lt;useKind&gt;(edge.node());
2654         createToString&lt;useKind&gt;(node, edge);
2655     }
2656 
2657     void convertToMakeRope(Node* node)
2658     {
2659         node-&gt;setOpAndDefaultFlags(MakeRope);
2660         fixupMakeRope(node);
2661     }
2662 
2663     void fixupMakeRope(Node* node)
2664     {
2665         for (unsigned i = 0; i &lt; AdjacencyList::Size; ++i) {
2666             Edge&amp; edge = node-&gt;children.child(i);
2667             if (!edge)
2668                 break;
2669             edge.setUseKind(KnownStringUse);
2670             JSString* string = edge-&gt;dynamicCastConstant&lt;JSString*&gt;(vm());
2671             if (!string)
2672                 continue;
2673             if (string-&gt;length())
2674                 continue;
2675 
2676             // Don&#39;t allow the MakeRope to have zero children.
2677             if (!i &amp;&amp; !node-&gt;child2())
2678                 break;
2679 
2680             node-&gt;children.removeEdge(i--);
2681         }
2682 
2683         if (!node-&gt;child2()) {
2684             ASSERT(!node-&gt;child3());
2685             node-&gt;convertToIdentity();
2686         }
2687     }
2688 
2689     void fixupIsCellWithType(Node* node)
2690     {
<a name="29" id="anc29"></a><span class="line-modified">2691         Optional&lt;SpeculatedType&gt; filter = node-&gt;speculatedTypeForQuery();</span>
<span class="line-modified">2692         if (filter) {</span>
<span class="line-modified">2693             switch (filter.value()) {</span>
<span class="line-modified">2694             case SpecString:</span>
<span class="line-modified">2695                 if (node-&gt;child1()-&gt;shouldSpeculateString()) {</span>
<span class="line-modified">2696                     m_insertionSet.insertNode(</span>
<span class="line-modified">2697                         m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="line-modified">2698                         Edge(node-&gt;child1().node(), StringUse));</span>
<span class="line-modified">2699                     m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="line-modified">2700                     observeUseKindOnNode&lt;StringUse&gt;(node);</span>
<span class="line-modified">2701                     return;</span>
<span class="line-added">2702                 }</span>
<span class="line-added">2703                 break;</span>
2704 
<a name="30" id="anc30"></a><span class="line-modified">2705             case SpecProxyObject:</span>
<span class="line-modified">2706                 if (node-&gt;child1()-&gt;shouldSpeculateProxyObject()) {</span>
<span class="line-modified">2707                     m_insertionSet.insertNode(</span>
<span class="line-modified">2708                         m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="line-modified">2709                         Edge(node-&gt;child1().node(), ProxyObjectUse));</span>
<span class="line-modified">2710                     m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="line-modified">2711                     observeUseKindOnNode&lt;ProxyObjectUse&gt;(node);</span>
<span class="line-modified">2712                     return;</span>
<span class="line-modified">2713                 }</span>
<span class="line-modified">2714                 break;</span>
2715 
<a name="31" id="anc31"></a><span class="line-modified">2716             case SpecRegExpObject:</span>
<span class="line-modified">2717                 if (node-&gt;child1()-&gt;shouldSpeculateRegExpObject()) {</span>
<span class="line-modified">2718                     m_insertionSet.insertNode(</span>
<span class="line-modified">2719                         m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="line-modified">2720                         Edge(node-&gt;child1().node(), RegExpObjectUse));</span>
<span class="line-modified">2721                     m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="line-modified">2722                     observeUseKindOnNode&lt;RegExpObjectUse&gt;(node);</span>
<span class="line-modified">2723                     return;</span>
<span class="line-modified">2724                 }</span>
<span class="line-modified">2725                 break;</span>
2726 
<a name="32" id="anc32"></a><span class="line-modified">2727             case SpecArray:</span>
<span class="line-modified">2728                 if (node-&gt;child1()-&gt;shouldSpeculateArray()) {</span>
<span class="line-modified">2729                     m_insertionSet.insertNode(</span>
<span class="line-modified">2730                         m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="line-modified">2731                         Edge(node-&gt;child1().node(), ArrayUse));</span>
<span class="line-modified">2732                     m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="line-modified">2733                     observeUseKindOnNode&lt;ArrayUse&gt;(node);</span>
<span class="line-modified">2734                     return;</span>
<span class="line-modified">2735                 }</span>
<span class="line-modified">2736                 break;</span>
2737 
<a name="33" id="anc33"></a><span class="line-modified">2738             case SpecDerivedArray:</span>
<span class="line-modified">2739                 if (node-&gt;child1()-&gt;shouldSpeculateDerivedArray()) {</span>
<span class="line-modified">2740                     m_insertionSet.insertNode(</span>
<span class="line-modified">2741                         m_indexInBlock, SpecNone, Check, node-&gt;origin,</span>
<span class="line-modified">2742                         Edge(node-&gt;child1().node(), DerivedArrayUse));</span>
<span class="line-modified">2743                     m_graph.convertToConstant(node, jsBoolean(true));</span>
<span class="line-modified">2744                     observeUseKindOnNode&lt;DerivedArrayUse&gt;(node);</span>
<span class="line-modified">2745                     return;</span>
<span class="line-added">2746                 }</span>
<span class="line-added">2747                 break;</span>
2748             }
<a name="34" id="anc34"></a>
2749         }
2750 
2751         if (node-&gt;child1()-&gt;shouldSpeculateCell()) {
2752             fixEdge&lt;CellUse&gt;(node-&gt;child1());
2753             return;
2754         }
2755 
2756         if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
2757             m_insertionSet.insertNode(
2758                 m_indexInBlock, SpecNone, Check, node-&gt;origin,
2759                 Edge(node-&gt;child1().node(), NotCellUse));
2760             m_graph.convertToConstant(node, jsBoolean(false));
2761             observeUseKindOnNode&lt;NotCellUse&gt;(node);
2762             return;
2763         }
2764     }
2765 
2766     void fixupGetPrototypeOf(Node* node)
2767     {
2768         // Reflect.getPrototypeOf only accepts Objects. For Reflect.getPrototypeOf, ByteCodeParser attaches ObjectUse edge filter before fixup phase.
2769         if (node-&gt;child1().useKind() != ObjectUse) {
2770             if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2771                 insertCheck&lt;StringUse&gt;(node-&gt;child1().node());
2772                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;stringPrototype()));
2773                 return;
2774             }
2775             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2776                 insertCheck&lt;Int32Use&gt;(node-&gt;child1().node());
2777                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;numberPrototype()));
2778                 return;
2779             }
2780             if (node-&gt;child1()-&gt;shouldSpeculateInt52()) {
2781                 insertCheck&lt;Int52RepUse&gt;(node-&gt;child1().node());
2782                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;numberPrototype()));
2783                 return;
2784             }
2785             if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
2786                 insertCheck&lt;NumberUse&gt;(node-&gt;child1().node());
2787                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;numberPrototype()));
2788                 return;
2789             }
2790             if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
2791                 insertCheck&lt;SymbolUse&gt;(node-&gt;child1().node());
2792                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;symbolPrototype()));
2793                 return;
2794             }
2795             if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
2796                 insertCheck&lt;BooleanUse&gt;(node-&gt;child1().node());
2797                 m_graph.convertToConstant(node, m_graph.freeze(m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;booleanPrototype()));
2798                 return;
2799             }
2800         }
2801 
2802         if (node-&gt;child1()-&gt;shouldSpeculateFinalObject()) {
2803             fixEdge&lt;FinalObjectUse&gt;(node-&gt;child1());
2804             node-&gt;clearFlags(NodeMustGenerate);
2805             return;
2806         }
2807         if (node-&gt;child1()-&gt;shouldSpeculateArray()) {
2808             fixEdge&lt;ArrayUse&gt;(node-&gt;child1());
2809             node-&gt;clearFlags(NodeMustGenerate);
2810             return;
2811         }
2812         if (node-&gt;child1()-&gt;shouldSpeculateFunction()) {
2813             fixEdge&lt;FunctionUse&gt;(node-&gt;child1());
2814             node-&gt;clearFlags(NodeMustGenerate);
2815             return;
2816         }
2817     }
2818 
2819     void fixupToThis(Node* node)
2820     {
2821         bool isStrictMode = m_graph.isStrictModeFor(node-&gt;origin.semantic);
2822 
2823         if (isStrictMode) {
2824             if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
2825                 fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
2826                 node-&gt;convertToIdentity();
2827                 return;
2828             }
2829 
2830             if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2831                 fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2832                 node-&gt;convertToIdentity();
2833                 return;
2834             }
2835 
2836             if (node-&gt;child1()-&gt;shouldSpeculateInt52()) {
2837                 fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
2838                 node-&gt;convertToIdentity();
2839                 node-&gt;setResult(NodeResultInt52);
2840                 return;
2841             }
2842 
2843             if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
2844                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
2845                 node-&gt;convertToIdentity();
2846                 node-&gt;setResult(NodeResultDouble);
2847                 return;
2848             }
2849 
2850             if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
2851                 fixEdge&lt;SymbolUse&gt;(node-&gt;child1());
2852                 node-&gt;convertToIdentity();
2853                 return;
2854             }
2855 
2856             if (node-&gt;child1()-&gt;shouldSpeculateStringIdent()) {
2857                 fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());
2858                 node-&gt;convertToIdentity();
2859                 return;
2860             }
2861 
2862             if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2863                 fixEdge&lt;StringUse&gt;(node-&gt;child1());
2864                 node-&gt;convertToIdentity();
2865                 return;
2866             }
2867 
2868             if (node-&gt;child1()-&gt;shouldSpeculateBigInt()) {
2869                 fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
2870                 node-&gt;convertToIdentity();
2871                 return;
2872             }
2873         }
2874 
2875         if (node-&gt;child1()-&gt;shouldSpeculateOther()) {
2876             if (isStrictMode) {
2877                 fixEdge&lt;OtherUse&gt;(node-&gt;child1());
2878                 node-&gt;convertToIdentity();
2879                 return;
2880             }
2881 
2882             m_insertionSet.insertNode(
2883                 m_indexInBlock, SpecNone, Check, node-&gt;origin,
2884                 Edge(node-&gt;child1().node(), OtherUse));
2885             observeUseKindOnNode&lt;OtherUse&gt;(node-&gt;child1().node());
2886             m_graph.convertToConstant(
2887                 node, m_graph.globalThisObjectFor(node-&gt;origin.semantic));
2888             return;
2889         }
2890 
2891         // FIXME: This should cover other use cases but we don&#39;t have use kinds for them. It&#39;s not critical,
2892         // however, since we cover all the missing cases in constant folding.
2893         // https://bugs.webkit.org/show_bug.cgi?id=157213
2894         if (node-&gt;child1()-&gt;shouldSpeculateStringObject()) {
2895             fixEdge&lt;StringObjectUse&gt;(node-&gt;child1());
2896             node-&gt;convertToIdentity();
2897             return;
2898         }
2899 
2900         if (isFinalObjectSpeculation(node-&gt;child1()-&gt;prediction())) {
2901             fixEdge&lt;FinalObjectUse&gt;(node-&gt;child1());
2902             node-&gt;convertToIdentity();
2903             return;
2904         }
2905     }
2906 
2907     void fixupToPrimitive(Node* node)
2908     {
2909         if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2910             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2911             node-&gt;convertToIdentity();
2912             return;
2913         }
2914 
2915         if (node-&gt;child1()-&gt;shouldSpeculateString()) {
2916             fixEdge&lt;StringUse&gt;(node-&gt;child1());
2917             node-&gt;convertToIdentity();
2918             return;
2919         }
2920 
2921         if (node-&gt;child1()-&gt;shouldSpeculateStringObject()
2922             &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
2923             addCheckStructureForOriginalStringObjectUse(StringObjectUse, node-&gt;origin, node-&gt;child1().node());
2924             fixEdge&lt;StringObjectUse&gt;(node-&gt;child1());
2925             node-&gt;convertToToString();
2926             return;
2927         }
2928 
2929         if (node-&gt;child1()-&gt;shouldSpeculateStringOrStringObject()
2930             &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
2931             addCheckStructureForOriginalStringObjectUse(StringOrStringObjectUse, node-&gt;origin, node-&gt;child1().node());
2932             fixEdge&lt;StringOrStringObjectUse&gt;(node-&gt;child1());
2933             node-&gt;convertToToString();
2934             return;
2935         }
2936     }
2937 
<a name="35" id="anc35"></a><span class="line-added">2938     void fixupToNumeric(Node* node)</span>
<span class="line-added">2939     {</span>
<span class="line-added">2940         // If the prediction of the child is BigInt, we attempt to convert ToNumeric to Identity, since it can only return a BigInt when fed a BigInt.</span>
<span class="line-added">2941         if (node-&gt;child1()-&gt;shouldSpeculateBigInt()) {</span>
<span class="line-added">2942             fixEdge&lt;BigIntUse&gt;(node-&gt;child1());</span>
<span class="line-added">2943             node-&gt;convertToIdentity();</span>
<span class="line-added">2944             return;</span>
<span class="line-added">2945         }</span>
<span class="line-added">2946 </span>
<span class="line-added">2947         fixupToNumber(node);</span>
<span class="line-added">2948     }</span>
<span class="line-added">2949 </span>
2950     void fixupToNumber(Node* node)
2951     {
2952         // At first, attempt to fold Boolean or Int32 to Int32.
2953         if (node-&gt;child1()-&gt;shouldSpeculateInt32OrBoolean()) {
2954             if (isInt32Speculation(node-&gt;getHeapPrediction())) {
2955                 fixIntOrBooleanEdge(node-&gt;child1());
2956                 node-&gt;convertToIdentity();
2957                 return;
2958             }
2959         }
2960 
2961         // If the prediction of the child is Number, we attempt to convert ToNumber to Identity.
2962         if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
2963             if (isInt32Speculation(node-&gt;getHeapPrediction())) {
2964                 // If the both predictions of this node and the child is Int32, we just convert ToNumber to Identity, that&#39;s simple.
2965                 if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
2966                     fixEdge&lt;Int32Use&gt;(node-&gt;child1());
2967                     node-&gt;convertToIdentity();
2968                     return;
2969                 }
2970 
2971                 // The another case is that the predicted type of the child is Int32, but the heap prediction tell the users that this will produce non Int32 values.
2972                 // In that case, let&#39;s receive the child value as a Double value and convert it to Int32. This case happens in misc-bugs-847389-jpeg2000.
2973                 fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
2974                 node-&gt;setOp(DoubleAsInt32);
2975                 if (bytecodeCanIgnoreNegativeZero(node-&gt;arithNodeFlags()))
2976                     node-&gt;setArithMode(Arith::CheckOverflow);
2977                 else
2978                     node-&gt;setArithMode(Arith::CheckOverflowAndNegativeZero);
2979                 return;
2980             }
2981 
2982             fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
2983             node-&gt;convertToIdentity();
2984             node-&gt;setResult(NodeResultDouble);
2985             return;
2986         }
2987 
2988         fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
2989         node-&gt;setResult(NodeResultJS);
2990     }
2991 
2992     void fixupToObject(Node* node)
2993     {
2994         if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
2995             fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
2996             node-&gt;convertToIdentity();
2997             return;
2998         }
2999 
3000         // ToObject(Null/Undefined) can throw an error. We can emit filters to convert ToObject to CallObjectConstructor.
3001 
3002         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
3003 
3004         if (node-&gt;child1()-&gt;shouldSpeculateString()) {
3005             insertCheck&lt;StringUse&gt;(node-&gt;child1().node());
3006             fixEdge&lt;KnownStringUse&gt;(node-&gt;child1());
3007             node-&gt;convertToNewStringObject(m_graph.registerStructure(globalObject-&gt;stringObjectStructure()));
3008             return;
3009         }
3010 
3011         if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
3012             insertCheck&lt;SymbolUse&gt;(node-&gt;child1().node());
3013             node-&gt;convertToCallObjectConstructor(m_graph.freeze(globalObject));
3014             return;
3015         }
3016 
3017         if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
3018             insertCheck&lt;NumberUse&gt;(node-&gt;child1().node());
3019             node-&gt;convertToCallObjectConstructor(m_graph.freeze(globalObject));
3020             return;
3021         }
3022 
3023         if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
3024             insertCheck&lt;BooleanUse&gt;(node-&gt;child1().node());
3025             node-&gt;convertToCallObjectConstructor(m_graph.freeze(globalObject));
3026             return;
3027         }
3028 
3029         fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
3030     }
3031 
3032     void fixupCallObjectConstructor(Node* node)
3033     {
3034         if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
3035             fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
3036             node-&gt;convertToIdentity();
3037             return;
3038         }
3039 
3040         if (node-&gt;child1()-&gt;shouldSpeculateString()) {
3041             auto* globalObject = jsCast&lt;JSGlobalObject*&gt;(node-&gt;cellOperand()-&gt;cell());
3042             insertCheck&lt;StringUse&gt;(node-&gt;child1().node());
3043             fixEdge&lt;KnownStringUse&gt;(node-&gt;child1());
3044             node-&gt;convertToNewStringObject(m_graph.registerStructure(globalObject-&gt;stringObjectStructure()));
3045             return;
3046         }
3047 
3048         // While ToObject(Null/Undefined) throws an error, CallObjectConstructor(Null/Undefined) generates a new empty object.
3049         if (node-&gt;child1()-&gt;shouldSpeculateOther()) {
3050             insertCheck&lt;OtherUse&gt;(node-&gt;child1().node());
3051             node-&gt;convertToNewObject(m_graph.registerStructure(jsCast&lt;JSGlobalObject*&gt;(node-&gt;cellOperand()-&gt;cell())-&gt;objectStructureForObjectConstructor()));
3052             return;
3053         }
3054 
3055         fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
3056     }
3057 
3058     void fixupToStringOrCallStringConstructor(Node* node)
3059     {
3060         if (node-&gt;child1()-&gt;shouldSpeculateString()) {
3061             fixEdge&lt;StringUse&gt;(node-&gt;child1());
3062             node-&gt;convertToIdentity();
3063             return;
3064         }
3065 
3066         if (node-&gt;child1()-&gt;shouldSpeculateStringObject()
3067             &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
3068             addCheckStructureForOriginalStringObjectUse(StringObjectUse, node-&gt;origin, node-&gt;child1().node());
3069             fixEdge&lt;StringObjectUse&gt;(node-&gt;child1());
3070             return;
3071         }
3072 
3073         if (node-&gt;child1()-&gt;shouldSpeculateStringOrStringObject()
3074             &amp;&amp; m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
3075             addCheckStructureForOriginalStringObjectUse(StringOrStringObjectUse, node-&gt;origin, node-&gt;child1().node());
3076             fixEdge&lt;StringOrStringObjectUse&gt;(node-&gt;child1());
3077             return;
3078         }
3079 
3080         if (node-&gt;child1()-&gt;shouldSpeculateCell()) {
3081             fixEdge&lt;CellUse&gt;(node-&gt;child1());
3082             return;
3083         }
3084 
3085         if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
3086             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
3087             node-&gt;clearFlags(NodeMustGenerate);
3088             return;
3089         }
3090 
3091         if (node-&gt;child1()-&gt;shouldSpeculateInt52()) {
3092             fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
3093             node-&gt;clearFlags(NodeMustGenerate);
3094             return;
3095         }
3096 
3097         if (node-&gt;child1()-&gt;shouldSpeculateNumber()) {
3098             fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
3099             node-&gt;clearFlags(NodeMustGenerate);
3100             return;
3101         }
3102 
3103         // ToString(Symbol) throws an error. So if the child1 can include Symbols,
3104         // we need to care about it in the clobberize. In the following case,
3105         // since NotCellUse edge filter is used and this edge filters Symbols,
3106         // we can say that ToString never throws an error!
3107         if (node-&gt;child1()-&gt;shouldSpeculateNotCell()) {
3108             fixEdge&lt;NotCellUse&gt;(node-&gt;child1());
3109             node-&gt;clearFlags(NodeMustGenerate);
3110             return;
3111         }
3112     }
3113 
3114     void fixupStringValueOf(Node* node)
3115     {
3116         if (node-&gt;child1()-&gt;shouldSpeculateString()) {
3117             fixEdge&lt;StringUse&gt;(node-&gt;child1());
3118             node-&gt;convertToIdentity();
3119             return;
3120         }
3121 
3122         if (node-&gt;child1()-&gt;shouldSpeculateStringObject()) {
3123             fixEdge&lt;StringObjectUse&gt;(node-&gt;child1());
3124             node-&gt;convertToToString();
3125             // It does not need to look up a toString property for the StringObject case. So we can clear NodeMustGenerate.
3126             node-&gt;clearFlags(NodeMustGenerate);
3127             return;
3128         }
3129 
3130         if (node-&gt;child1()-&gt;shouldSpeculateStringOrStringObject()) {
3131             fixEdge&lt;StringOrStringObjectUse&gt;(node-&gt;child1());
3132             node-&gt;convertToToString();
3133             // It does not need to look up a toString property for the StringObject case. So we can clear NodeMustGenerate.
3134             node-&gt;clearFlags(NodeMustGenerate);
3135             return;
3136         }
3137     }
3138 
3139     bool attemptToMakeFastStringAdd(Node* node)
3140     {
3141         bool goodToGo = true;
3142         m_graph.doToChildren(
3143             node,
3144             [&amp;] (Edge&amp; edge) {
3145                 if (edge-&gt;shouldSpeculateString())
3146                     return;
3147                 if (m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic)) {
3148                     if (edge-&gt;shouldSpeculateStringObject())
3149                         return;
3150                     if (edge-&gt;shouldSpeculateStringOrStringObject())
3151                         return;
3152                 }
3153                 goodToGo = false;
3154             });
3155         if (!goodToGo)
3156             return false;
3157 
3158         m_graph.doToChildren(
3159             node,
3160             [&amp;] (Edge&amp; edge) {
3161                 if (edge-&gt;shouldSpeculateString()) {
3162                     convertStringAddUse&lt;StringUse&gt;(node, edge);
3163                     return;
3164                 }
3165                 if (!Options::useConcurrentJIT())
3166                     ASSERT(m_graph.canOptimizeStringObjectAccess(node-&gt;origin.semantic));
3167                 if (edge-&gt;shouldSpeculateStringObject()) {
3168                     addCheckStructureForOriginalStringObjectUse(StringObjectUse, node-&gt;origin, edge.node());
3169                     convertStringAddUse&lt;StringObjectUse&gt;(node, edge);
3170                     return;
3171                 }
3172                 if (edge-&gt;shouldSpeculateStringOrStringObject()) {
3173                     addCheckStructureForOriginalStringObjectUse(StringOrStringObjectUse, node-&gt;origin, edge.node());
3174                     convertStringAddUse&lt;StringOrStringObjectUse&gt;(node, edge);
3175                     return;
3176                 }
3177                 RELEASE_ASSERT_NOT_REACHED();
3178             });
3179 
3180         convertToMakeRope(node);
3181         return true;
3182     }
3183 
3184     void fixupGetAndSetLocalsInBlock(BasicBlock* block)
3185     {
3186         if (!block)
3187             return;
3188         ASSERT(block-&gt;isReachable);
3189         m_block = block;
3190         for (m_indexInBlock = 0; m_indexInBlock &lt; block-&gt;size(); ++m_indexInBlock) {
3191             Node* node = m_currentNode = block-&gt;at(m_indexInBlock);
3192             if (node-&gt;op() != SetLocal &amp;&amp; node-&gt;op() != GetLocal)
3193                 continue;
3194 
3195             VariableAccessData* variable = node-&gt;variableAccessData();
3196             switch (node-&gt;op()) {
3197             case GetLocal:
3198                 switch (variable-&gt;flushFormat()) {
3199                 case FlushedDouble:
3200                     node-&gt;setResult(NodeResultDouble);
3201                     break;
3202                 case FlushedInt52:
3203                     node-&gt;setResult(NodeResultInt52);
3204                     break;
3205                 default:
3206                     break;
3207                 }
3208                 break;
3209 
3210             case SetLocal:
3211                 // NOTE: Any type checks we put here may get hoisted by fixupChecksInBlock(). So, if we
3212                 // add new type checking use kind for SetLocals, we need to modify that code as well.
3213 
3214                 switch (variable-&gt;flushFormat()) {
3215                 case FlushedJSValue:
3216                     break;
3217                 case FlushedDouble:
3218                     fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
3219                     break;
3220                 case FlushedInt32:
3221                     fixEdge&lt;Int32Use&gt;(node-&gt;child1());
3222                     break;
3223                 case FlushedInt52:
3224                     fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
3225                     break;
3226                 case FlushedCell:
3227                     fixEdge&lt;CellUse&gt;(node-&gt;child1());
3228                     break;
3229                 case FlushedBoolean:
3230                     fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
3231                     break;
3232                 default:
3233                     RELEASE_ASSERT_NOT_REACHED();
3234                     break;
3235                 }
3236                 break;
3237 
3238             default:
3239                 RELEASE_ASSERT_NOT_REACHED();
3240                 break;
3241             }
3242         }
3243         m_insertionSet.execute(block);
3244     }
3245 
3246     void addStringReplacePrimordialChecks(Node* searchRegExp)
3247     {
3248         Node* node = m_currentNode;
3249 
3250         // Check that structure of searchRegExp is RegExp object
3251         m_insertionSet.insertNode(
3252             m_indexInBlock, SpecNone, Check, node-&gt;origin,
3253             Edge(searchRegExp, RegExpObjectUse));
3254 
3255         auto emitPrimordialCheckFor = [&amp;] (JSValue primordialProperty, UniquedStringImpl* propertyUID) {
3256             unsigned index = m_graph.identifiers().ensure(propertyUID);
3257 
3258             Node* actualProperty = m_insertionSet.insertNode(
3259                 m_indexInBlock, SpecNone, TryGetById, node-&gt;origin,
3260                 OpInfo(index), OpInfo(SpecFunction), Edge(searchRegExp, CellUse));
3261 
3262             m_insertionSet.insertNode(
3263                 m_indexInBlock, SpecNone, CheckCell, node-&gt;origin,
3264                 OpInfo(m_graph.freeze(primordialProperty)), Edge(actualProperty, CellUse));
3265         };
3266 
3267         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
3268 
3269         // Check that searchRegExp.exec is the primordial RegExp.prototype.exec
3270         emitPrimordialCheckFor(globalObject-&gt;regExpProtoExecFunction(), vm().propertyNames-&gt;exec.impl());
3271         // Check that searchRegExp.global is the primordial RegExp.prototype.global
3272         emitPrimordialCheckFor(globalObject-&gt;regExpProtoGlobalGetter(), vm().propertyNames-&gt;global.impl());
3273         // Check that searchRegExp.unicode is the primordial RegExp.prototype.unicode
3274         emitPrimordialCheckFor(globalObject-&gt;regExpProtoUnicodeGetter(), vm().propertyNames-&gt;unicode.impl());
3275         // Check that searchRegExp[Symbol.match] is the primordial RegExp.prototype[Symbol.replace]
3276         emitPrimordialCheckFor(globalObject-&gt;regExpProtoSymbolReplaceFunction(), vm().propertyNames-&gt;replaceSymbol.impl());
3277     }
3278 
3279     Node* checkArray(ArrayMode arrayMode, const NodeOrigin&amp; origin, Node* array, Node* index, bool (*storageCheck)(const ArrayMode&amp;) = canCSEStorage)
3280     {
3281         ASSERT(arrayMode.isSpecific());
3282 
3283         if (arrayMode.type() == Array::String) {
3284             m_insertionSet.insertNode(
3285                 m_indexInBlock, SpecNone, Check, origin, Edge(array, StringUse));
3286         } else {
3287             // Note that we only need to be using a structure check if we opt for SaneChain, since
3288             // that needs to protect against JSArray&#39;s __proto__ being changed.
3289             Structure* structure = arrayMode.originalArrayStructure(m_graph, origin.semantic);
3290 
3291             Edge indexEdge = index ? Edge(index, Int32Use) : Edge();
3292 
3293             if (arrayMode.doesConversion()) {
3294                 if (structure) {
3295                     m_insertionSet.insertNode(
3296                         m_indexInBlock, SpecNone, ArrayifyToStructure, origin,
3297                         OpInfo(m_graph.registerStructure(structure)), OpInfo(arrayMode.asWord()), Edge(array, CellUse), indexEdge);
3298                 } else {
3299                     m_insertionSet.insertNode(
3300                         m_indexInBlock, SpecNone, Arrayify, origin,
3301                         OpInfo(arrayMode.asWord()), Edge(array, CellUse), indexEdge);
3302                 }
3303             } else {
3304                 if (structure) {
3305                     m_insertionSet.insertNode(
3306                         m_indexInBlock, SpecNone, CheckStructure, origin,
3307                         OpInfo(m_graph.addStructureSet(structure)), Edge(array, CellUse));
3308                 } else {
3309                     m_insertionSet.insertNode(
3310                         m_indexInBlock, SpecNone, CheckArray, origin,
3311                         OpInfo(arrayMode.asWord()), Edge(array, CellUse));
3312                 }
3313             }
3314         }
3315 
3316         if (!storageCheck(arrayMode))
3317             return nullptr;
3318 
3319         if (arrayMode.usesButterfly()) {
3320             return m_insertionSet.insertNode(
3321                 m_indexInBlock, SpecNone, GetButterfly, origin, Edge(array, CellUse));
3322         }
3323 
3324         return m_insertionSet.insertNode(
3325             m_indexInBlock, SpecNone, GetIndexedPropertyStorage, origin,
3326             OpInfo(arrayMode.asWord()), Edge(array, KnownCellUse));
3327     }
3328 
3329     void blessArrayOperation(Edge base, Edge index, Edge&amp; storageChild)
3330     {
3331         Node* node = m_currentNode;
3332 
3333         switch (node-&gt;arrayMode().type()) {
3334         case Array::ForceExit: {
3335             m_insertionSet.insertNode(
3336                 m_indexInBlock, SpecNone, ForceOSRExit, node-&gt;origin);
3337             return;
3338         }
3339 
3340         case Array::SelectUsingPredictions:
3341         case Array::Unprofiled:
3342             RELEASE_ASSERT_NOT_REACHED();
3343             return;
3344 
3345         case Array::Generic:
3346             return;
3347 
3348         default: {
3349             Node* storage = checkArray(node-&gt;arrayMode(), node-&gt;origin, base.node(), index.node());
3350             if (!storage)
3351                 return;
3352 
3353             storageChild = Edge(storage);
3354             return;
3355         } }
3356     }
3357 
3358     bool alwaysUnboxSimplePrimitives()
3359     {
3360 #if USE(JSVALUE64)
3361         return false;
3362 #else
3363         // Any boolean, int, or cell value is profitable to unbox on 32-bit because it
3364         // reduces traffic.
3365         return true;
3366 #endif
3367     }
3368 
3369     template&lt;UseKind useKind&gt;
3370     void observeUseKindOnNode(Node* node)
3371     {
3372         if (useKind == UntypedUse)
3373             return;
3374         observeUseKindOnNode(node, useKind);
3375     }
3376 
3377     void observeUseKindOnEdge(Edge edge)
3378     {
3379         observeUseKindOnNode(edge.node(), edge.useKind());
3380     }
3381 
3382     void observeUseKindOnNode(Node* node, UseKind useKind)
3383     {
3384         if (node-&gt;op() != GetLocal)
3385             return;
3386 
3387         // FIXME: The way this uses alwaysUnboxSimplePrimitives() is suspicious.
3388         // https://bugs.webkit.org/show_bug.cgi?id=121518
3389 
3390         VariableAccessData* variable = node-&gt;variableAccessData();
3391         switch (useKind) {
3392         case Int32Use:
3393         case KnownInt32Use:
3394             if (alwaysUnboxSimplePrimitives()
3395                 || isInt32Speculation(variable-&gt;prediction()))
3396                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3397             break;
3398         case NumberUse:
3399         case RealNumberUse:
3400         case DoubleRepUse:
3401         case DoubleRepRealUse:
3402             if (variable-&gt;doubleFormatState() == UsingDoubleFormat)
3403                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3404             break;
3405         case BooleanUse:
3406         case KnownBooleanUse:
3407             if (alwaysUnboxSimplePrimitives()
3408                 || isBooleanSpeculation(variable-&gt;prediction()))
3409                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3410             break;
3411         case Int52RepUse:
3412             if (!isInt32Speculation(variable-&gt;prediction()) &amp;&amp; isInt32OrInt52Speculation(variable-&gt;prediction()))
3413                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3414             break;
3415         case CellUse:
3416         case KnownCellUse:
3417         case ObjectUse:
3418         case FunctionUse:
3419         case StringUse:
3420         case KnownStringUse:
3421         case SymbolUse:
3422         case BigIntUse:
3423         case StringObjectUse:
3424         case StringOrStringObjectUse:
3425             if (alwaysUnboxSimplePrimitives()
3426                 || isCellSpeculation(variable-&gt;prediction()))
3427                 m_profitabilityChanged |= variable-&gt;mergeIsProfitableToUnbox(true);
3428             break;
3429         default:
3430             break;
3431         }
3432     }
3433 
3434     template&lt;UseKind useKind&gt;
3435     void fixEdge(Edge&amp; edge)
3436     {
3437         observeUseKindOnNode&lt;useKind&gt;(edge.node());
3438         edge.setUseKind(useKind);
3439     }
3440 
3441     unsigned indexForChecks()
3442     {
3443         unsigned index = m_indexInBlock;
3444         while (!m_block-&gt;at(index)-&gt;origin.exitOK)
3445             index--;
3446         return index;
3447     }
3448 
3449     NodeOrigin originForCheck(unsigned index)
3450     {
3451         return m_block-&gt;at(index)-&gt;origin.withSemantic(m_currentNode-&gt;origin.semantic);
3452     }
3453 
3454     void speculateForBarrier(Edge value)
3455     {
3456         // Currently, the DFG won&#39;t take advantage of this speculation. But, we want to do it in
3457         // the DFG anyway because if such a speculation would be wrong, we want to know before
3458         // we do an expensive compile.
3459 
3460         if (value-&gt;shouldSpeculateInt32()) {
3461             insertCheck&lt;Int32Use&gt;(value.node());
3462             return;
3463         }
3464 
3465         if (value-&gt;shouldSpeculateBoolean()) {
3466             insertCheck&lt;BooleanUse&gt;(value.node());
3467             return;
3468         }
3469 
3470         if (value-&gt;shouldSpeculateOther()) {
3471             insertCheck&lt;OtherUse&gt;(value.node());
3472             return;
3473         }
3474 
3475         if (value-&gt;shouldSpeculateNumber()) {
3476             insertCheck&lt;NumberUse&gt;(value.node());
3477             return;
3478         }
3479 
3480         if (value-&gt;shouldSpeculateNotCell()) {
3481             insertCheck&lt;NotCellUse&gt;(value.node());
3482             return;
3483         }
3484     }
3485 
3486     template&lt;UseKind useKind&gt;
3487     void insertCheck(Node* node)
3488     {
3489         observeUseKindOnNode&lt;useKind&gt;(node);
3490         unsigned index = indexForChecks();
3491         m_insertionSet.insertNode(index, SpecNone, Check, originForCheck(index), Edge(node, useKind));
3492     }
3493 
3494     void fixIntConvertingEdge(Edge&amp; edge)
3495     {
3496         Node* node = edge.node();
3497         if (node-&gt;shouldSpeculateInt32OrBoolean()) {
3498             fixIntOrBooleanEdge(edge);
3499             return;
3500         }
3501 
3502         UseKind useKind;
3503         if (node-&gt;shouldSpeculateInt52())
3504             useKind = Int52RepUse;
3505         else if (node-&gt;shouldSpeculateNumber())
3506             useKind = DoubleRepUse;
3507         else
3508             useKind = NotCellUse;
3509         Node* newNode = m_insertionSet.insertNode(
3510             m_indexInBlock, SpecInt32Only, ValueToInt32, m_currentNode-&gt;origin,
3511             Edge(node, useKind));
3512         observeUseKindOnNode(node, useKind);
3513 
3514         edge = Edge(newNode, KnownInt32Use);
3515     }
3516 
3517     void fixIntOrBooleanEdge(Edge&amp; edge)
3518     {
3519         Node* node = edge.node();
3520         if (!node-&gt;sawBooleans()) {
3521             fixEdge&lt;Int32Use&gt;(edge);
3522             return;
3523         }
3524 
3525         UseKind useKind;
3526         if (node-&gt;shouldSpeculateBoolean())
3527             useKind = BooleanUse;
3528         else
3529             useKind = UntypedUse;
3530         Node* newNode = m_insertionSet.insertNode(
3531             m_indexInBlock, SpecInt32Only, BooleanToNumber, m_currentNode-&gt;origin,
3532             Edge(node, useKind));
3533         observeUseKindOnNode(node, useKind);
3534 
3535         edge = Edge(newNode, Int32Use);
3536     }
3537 
3538     void fixDoubleOrBooleanEdge(Edge&amp; edge)
3539     {
3540         Node* node = edge.node();
3541         if (!node-&gt;sawBooleans()) {
3542             fixEdge&lt;DoubleRepUse&gt;(edge);
3543             return;
3544         }
3545 
3546         UseKind useKind;
3547         if (node-&gt;shouldSpeculateBoolean())
3548             useKind = BooleanUse;
3549         else
3550             useKind = UntypedUse;
3551         Node* newNode = m_insertionSet.insertNode(
3552             m_indexInBlock, SpecInt32Only, BooleanToNumber, m_currentNode-&gt;origin,
3553             Edge(node, useKind));
3554         observeUseKindOnNode(node, useKind);
3555 
3556         edge = Edge(newNode, DoubleRepUse);
3557     }
3558 
3559     void truncateConstantToInt32(Edge&amp; edge)
3560     {
3561         Node* oldNode = edge.node();
3562 
3563         JSValue value = oldNode-&gt;asJSValue();
3564         if (value.isInt32())
3565             return;
3566 
3567         value = jsNumber(JSC::toInt32(value.asNumber()));
3568         ASSERT(value.isInt32());
3569         edge.setNode(m_insertionSet.insertNode(
3570             m_indexInBlock, SpecInt32Only, JSConstant, m_currentNode-&gt;origin,
3571             OpInfo(m_graph.freeze(value))));
3572     }
3573 
3574     void truncateConstantsIfNecessary(Node* node, AddSpeculationMode mode)
3575     {
3576         if (mode != SpeculateInt32AndTruncateConstants)
3577             return;
3578 
3579         ASSERT(node-&gt;child1()-&gt;hasConstant() || node-&gt;child2()-&gt;hasConstant());
3580         if (node-&gt;child1()-&gt;hasConstant())
3581             truncateConstantToInt32(node-&gt;child1());
3582         else
3583             truncateConstantToInt32(node-&gt;child2());
3584     }
3585 
3586     bool attemptToMakeIntegerAdd(Node* node)
3587     {
3588         AddSpeculationMode mode = m_graph.addSpeculationMode(node, FixupPass);
3589         if (mode != DontSpeculateInt32) {
3590             truncateConstantsIfNecessary(node, mode);
3591             fixIntOrBooleanEdge(node-&gt;child1());
3592             fixIntOrBooleanEdge(node-&gt;child2());
3593             if (bytecodeCanTruncateInteger(node-&gt;arithNodeFlags()))
3594                 node-&gt;setArithMode(Arith::Unchecked);
3595             else
3596                 node-&gt;setArithMode(Arith::CheckOverflow);
3597             return true;
3598         }
3599 
3600         if (m_graph.addShouldSpeculateInt52(node)) {
3601             fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
3602             fixEdge&lt;Int52RepUse&gt;(node-&gt;child2());
3603             node-&gt;setArithMode(Arith::CheckOverflow);
3604             node-&gt;setResult(NodeResultInt52);
3605             return true;
3606         }
3607 
3608         return false;
3609     }
3610 
3611     bool attemptToMakeGetArrayLength(Node* node)
3612     {
3613         if (!isInt32Speculation(node-&gt;prediction()))
3614             return false;
3615         CodeBlock* profiledBlock = m_graph.baselineCodeBlockFor(node-&gt;origin.semantic);
3616         ArrayProfile* arrayProfile =
3617             profiledBlock-&gt;getArrayProfile(node-&gt;origin.semantic.bytecodeIndex());
3618         ArrayMode arrayMode = ArrayMode(Array::SelectUsingPredictions, Array::Read);
3619         if (arrayProfile) {
3620             ConcurrentJSLocker locker(profiledBlock-&gt;m_lock);
3621             arrayProfile-&gt;computeUpdatedPrediction(locker, profiledBlock);
3622             arrayMode = ArrayMode::fromObserved(locker, arrayProfile, Array::Read, false);
3623             if (arrayMode.type() == Array::Unprofiled) {
3624                 // For normal array operations, it makes sense to treat Unprofiled
3625                 // accesses as ForceExit and get more data rather than using
3626                 // predictions and then possibly ending up with a Generic. But here,
3627                 // we treat anything that is Unprofiled as Generic and keep the
3628                 // GetById. I.e. ForceExit = Generic. So, there is no harm - and only
3629                 // profit - from treating the Unprofiled case as
3630                 // SelectUsingPredictions.
3631                 arrayMode = ArrayMode(Array::SelectUsingPredictions, Array::Read);
3632             }
3633         }
3634 
3635         arrayMode = arrayMode.refine(
3636             m_graph, node, node-&gt;child1()-&gt;prediction(), node-&gt;prediction());
3637 
3638         if (arrayMode.type() == Array::Generic) {
3639             // Check if the input is something that we can&#39;t get array length for, but for which we
3640             // could insert some conversions in order to transform it into something that we can do it
3641             // for.
3642             if (node-&gt;child1()-&gt;shouldSpeculateStringObject())
3643                 attemptToForceStringArrayModeByToStringConversion&lt;StringObjectUse&gt;(arrayMode, node);
3644             else if (node-&gt;child1()-&gt;shouldSpeculateStringOrStringObject())
3645                 attemptToForceStringArrayModeByToStringConversion&lt;StringOrStringObjectUse&gt;(arrayMode, node);
3646         }
3647 
3648         if (!arrayMode.supportsSelfLength())
3649             return false;
3650 
3651         convertToGetArrayLength(node, arrayMode);
3652         return true;
3653     }
3654 
3655     void convertToGetArrayLength(Node* node, ArrayMode arrayMode)
3656     {
3657         node-&gt;setOp(GetArrayLength);
3658         node-&gt;clearFlags(NodeMustGenerate);
3659         fixEdge&lt;KnownCellUse&gt;(node-&gt;child1());
3660         node-&gt;setArrayMode(arrayMode);
3661 
3662         Node* storage = checkArray(arrayMode, node-&gt;origin, node-&gt;child1().node(), 0, lengthNeedsStorage);
3663         if (!storage)
3664             return;
3665 
3666         node-&gt;child2() = Edge(storage);
3667     }
3668 
3669     Node* prependGetArrayLength(NodeOrigin origin, Node* child, ArrayMode arrayMode)
3670     {
3671         Node* storage = checkArray(arrayMode, origin, child, 0, lengthNeedsStorage);
3672         return m_insertionSet.insertNode(
3673             m_indexInBlock, SpecInt32Only, GetArrayLength, origin,
3674             OpInfo(arrayMode.asWord()), Edge(child, KnownCellUse), Edge(storage));
3675     }
3676 
3677     void convertToHasIndexedProperty(Node* node)
3678     {
3679         node-&gt;setOp(HasIndexedProperty);
3680         node-&gt;clearFlags(NodeMustGenerate);
3681 
3682         {
3683             unsigned firstChild = m_graph.m_varArgChildren.size();
3684             unsigned numChildren = 3;
3685             m_graph.m_varArgChildren.append(node-&gt;child1());
3686             m_graph.m_varArgChildren.append(node-&gt;child2());
3687             m_graph.m_varArgChildren.append(Edge());
3688             node-&gt;mergeFlags(NodeHasVarArgs);
3689             node-&gt;children = AdjacencyList(AdjacencyList::Variable, firstChild, numChildren);
3690         }
3691 
3692         node-&gt;setArrayMode(
3693             node-&gt;arrayMode().refine(
3694                 m_graph, node,
3695                 m_graph.varArgChild(node, 0)-&gt;prediction(),
3696                 m_graph.varArgChild(node, 1)-&gt;prediction(),
3697                 SpecNone));
3698         node-&gt;setInternalMethodType(PropertySlot::InternalMethodType::HasProperty);
3699 
3700         blessArrayOperation(m_graph.varArgChild(node, 0), m_graph.varArgChild(node, 1), m_graph.varArgChild(node, 2));
3701 
3702         fixEdge&lt;CellUse&gt;(m_graph.varArgChild(node, 0));
3703         fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 1));
3704     }
3705 
3706     void fixupNormalizeMapKey(Node* node)
3707     {
3708         if (node-&gt;child1()-&gt;shouldSpeculateBoolean()) {
3709             fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
3710             node-&gt;convertToIdentity();
3711             return;
3712         }
3713 
3714         if (node-&gt;child1()-&gt;shouldSpeculateInt32()) {
3715             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
3716             node-&gt;convertToIdentity();
3717             return;
3718         }
3719 
3720         if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
3721             fixEdge&lt;SymbolUse&gt;(node-&gt;child1());
3722             node-&gt;convertToIdentity();
3723             return;
3724         }
3725 
3726         if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
3727             fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
3728             node-&gt;convertToIdentity();
3729             return;
3730         }
3731 
3732         if (node-&gt;child1()-&gt;shouldSpeculateString()) {
3733             fixEdge&lt;StringUse&gt;(node-&gt;child1());
3734             node-&gt;convertToIdentity();
3735             return;
3736         }
3737 
3738         if (node-&gt;child1()-&gt;shouldSpeculateCell()) {
3739             fixEdge&lt;CellUse&gt;(node-&gt;child1());
3740             node-&gt;convertToIdentity();
3741             return;
3742         }
3743 
3744         fixEdge&lt;UntypedUse&gt;(node-&gt;child1());
3745     }
3746 
3747     bool attemptToMakeCallDOM(Node* node)
3748     {
3749         if (m_graph.hasExitSite(node-&gt;origin.semantic, BadType))
3750             return false;
3751 
3752         const DOMJIT::Signature* signature = node-&gt;signature();
3753         if (!signature)
3754             return false;
3755 
3756         {
3757             unsigned index = 0;
3758             bool shouldConvertToCallDOM = true;
3759             m_graph.doToChildren(node, [&amp;](Edge&amp; edge) {
3760                 // Callee. Ignore this. DFGByteCodeParser already emit appropriate checks.
3761                 if (!index)
3762                     return;
3763 
3764                 if (index == 1) {
3765                     // DOM node case.
3766                     if (edge-&gt;shouldSpeculateNotCell())
3767                         shouldConvertToCallDOM = false;
3768                 } else {
3769                     switch (signature-&gt;arguments[index - 2]) {
3770                     case SpecString:
3771                         if (edge-&gt;shouldSpeculateNotString())
3772                             shouldConvertToCallDOM = false;
3773                         break;
3774                     case SpecInt32Only:
3775                         if (edge-&gt;shouldSpeculateNotInt32())
3776                             shouldConvertToCallDOM = false;
3777                         break;
3778                     case SpecBoolean:
3779                         if (edge-&gt;shouldSpeculateNotBoolean())
3780                             shouldConvertToCallDOM = false;
3781                         break;
3782                     default:
3783                         RELEASE_ASSERT_NOT_REACHED();
3784                         break;
3785                     }
3786                 }
3787                 ++index;
3788             });
3789             if (!shouldConvertToCallDOM)
3790                 return false;
3791         }
3792 
3793         Node* thisNode = m_graph.varArgChild(node, 1).node();
3794         Node* checkSubClass = m_insertionSet.insertNode(m_indexInBlock, SpecNone, CheckSubClass, node-&gt;origin, OpInfo(signature-&gt;classInfo), Edge(thisNode));
3795         node-&gt;convertToCallDOM(m_graph);
3796         fixupCheckSubClass(checkSubClass);
3797         fixupCallDOM(node);
3798         return true;
3799     }
3800 
3801     void fixupCheckSubClass(Node* node)
3802     {
3803         fixEdge&lt;CellUse&gt;(node-&gt;child1());
3804     }
3805 
3806     void fixupCallDOM(Node* node)
3807     {
3808         const DOMJIT::Signature* signature = node-&gt;signature();
3809         auto fixup = [&amp;](Edge&amp; edge, unsigned argumentIndex) {
3810             if (!edge)
3811                 return;
3812             switch (signature-&gt;arguments[argumentIndex]) {
3813             case SpecString:
3814                 fixEdge&lt;StringUse&gt;(edge);
3815                 break;
3816             case SpecInt32Only:
3817                 fixEdge&lt;Int32Use&gt;(edge);
3818                 break;
3819             case SpecBoolean:
3820                 fixEdge&lt;BooleanUse&gt;(edge);
3821                 break;
3822             default:
3823                 RELEASE_ASSERT_NOT_REACHED();
3824                 break;
3825             }
3826         };
3827         fixEdge&lt;CellUse&gt;(node-&gt;child1()); // DOM.
3828         fixup(node-&gt;child2(), 0);
3829         fixup(node-&gt;child3(), 1);
3830     }
3831 
3832     void fixupArrayIndexOf(Node* node)
3833     {
3834         Edge&amp; array = m_graph.varArgChild(node, 0);
3835         Edge&amp; storage = m_graph.varArgChild(node, node-&gt;numChildren() == 3 ? 2 : 3);
3836         blessArrayOperation(array, Edge(), storage);
3837         ASSERT_WITH_MESSAGE(storage.node(), &quot;blessArrayOperation for ArrayIndexOf must set Butterfly for storage edge.&quot;);
3838 
3839         Edge&amp; searchElement = m_graph.varArgChild(node, 1);
3840 
3841         // Constant folding.
3842         switch (node-&gt;arrayMode().type()) {
3843         case Array::Double:
3844         case Array::Int32: {
3845             if (searchElement-&gt;shouldSpeculateCell()) {
3846                 m_insertionSet.insertNode(m_indexInBlock, SpecNone, Check, node-&gt;origin, Edge(searchElement.node(), CellUse));
3847                 m_graph.convertToConstant(node, jsNumber(-1));
3848                 observeUseKindOnNode&lt;CellUse&gt;(searchElement.node());
3849                 return;
3850             }
3851 
3852             if (searchElement-&gt;shouldSpeculateOther()) {
3853                 m_insertionSet.insertNode(m_indexInBlock, SpecNone, Check, node-&gt;origin, Edge(searchElement.node(), OtherUse));
3854                 m_graph.convertToConstant(node, jsNumber(-1));
3855                 observeUseKindOnNode&lt;OtherUse&gt;(searchElement.node());
3856                 return;
3857             }
3858 
3859             if (searchElement-&gt;shouldSpeculateBoolean()) {
3860                 m_insertionSet.insertNode(m_indexInBlock, SpecNone, Check, node-&gt;origin, Edge(searchElement.node(), BooleanUse));
3861                 m_graph.convertToConstant(node, jsNumber(-1));
3862                 observeUseKindOnNode&lt;BooleanUse&gt;(searchElement.node());
3863                 return;
3864             }
3865             break;
3866         }
3867         default:
3868             break;
3869         }
3870 
3871         fixEdge&lt;KnownCellUse&gt;(array);
3872         if (node-&gt;numChildren() == 4)
3873             fixEdge&lt;Int32Use&gt;(m_graph.varArgChild(node, 2));
3874 
3875         switch (node-&gt;arrayMode().type()) {
3876         case Array::Double: {
3877             if (searchElement-&gt;shouldSpeculateNumber())
3878                 fixEdge&lt;DoubleRepUse&gt;(searchElement);
3879             return;
3880         }
3881         case Array::Int32: {
3882             if (searchElement-&gt;shouldSpeculateInt32())
3883                 fixEdge&lt;Int32Use&gt;(searchElement);
3884             return;
3885         }
3886         case Array::Contiguous: {
3887             if (searchElement-&gt;shouldSpeculateString())
3888                 fixEdge&lt;StringUse&gt;(searchElement);
3889             else if (searchElement-&gt;shouldSpeculateSymbol())
3890                 fixEdge&lt;SymbolUse&gt;(searchElement);
3891             else if (searchElement-&gt;shouldSpeculateOther())
3892                 fixEdge&lt;OtherUse&gt;(searchElement);
3893             else if (searchElement-&gt;shouldSpeculateObject())
3894                 fixEdge&lt;ObjectUse&gt;(searchElement);
3895             return;
3896         }
3897         default:
3898             RELEASE_ASSERT_NOT_REACHED();
3899             return;
3900         }
3901     }
3902 
3903     void fixupCompareStrictEqAndSameValue(Node* node)
3904     {
3905         ASSERT(node-&gt;op() == SameValue || node-&gt;op() == CompareStrictEq);
3906 
3907         if (Node::shouldSpeculateBoolean(node-&gt;child1().node(), node-&gt;child2().node())) {
3908             fixEdge&lt;BooleanUse&gt;(node-&gt;child1());
3909             fixEdge&lt;BooleanUse&gt;(node-&gt;child2());
3910             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3911             return;
3912         }
3913         if (Node::shouldSpeculateInt32(node-&gt;child1().node(), node-&gt;child2().node())) {
3914             fixEdge&lt;Int32Use&gt;(node-&gt;child1());
3915             fixEdge&lt;Int32Use&gt;(node-&gt;child2());
3916             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3917             return;
3918         }
3919         if (Node::shouldSpeculateInt52(node-&gt;child1().node(), node-&gt;child2().node())) {
3920             fixEdge&lt;Int52RepUse&gt;(node-&gt;child1());
3921             fixEdge&lt;Int52RepUse&gt;(node-&gt;child2());
3922             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3923             return;
3924         }
3925         if (Node::shouldSpeculateNumber(node-&gt;child1().node(), node-&gt;child2().node())) {
3926             fixEdge&lt;DoubleRepUse&gt;(node-&gt;child1());
3927             fixEdge&lt;DoubleRepUse&gt;(node-&gt;child2());
3928             // Do not convert SameValue to CompareStrictEq in this case since SameValue(NaN, NaN) and SameValue(-0, +0)
3929             // are not the same to CompareStrictEq(NaN, NaN) and CompareStrictEq(-0, +0).
3930             return;
3931         }
3932         if (Node::shouldSpeculateSymbol(node-&gt;child1().node(), node-&gt;child2().node())) {
3933             fixEdge&lt;SymbolUse&gt;(node-&gt;child1());
3934             fixEdge&lt;SymbolUse&gt;(node-&gt;child2());
3935             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3936             return;
3937         }
3938         if (Node::shouldSpeculateBigInt(node-&gt;child1().node(), node-&gt;child2().node())) {
3939             fixEdge&lt;BigIntUse&gt;(node-&gt;child1());
3940             fixEdge&lt;BigIntUse&gt;(node-&gt;child2());
3941             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3942             return;
3943         }
3944         if (node-&gt;child1()-&gt;shouldSpeculateStringIdent() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateStringIdent()) {
3945             fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());
3946             fixEdge&lt;StringIdentUse&gt;(node-&gt;child2());
3947             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3948             return;
3949         }
3950         if (node-&gt;child1()-&gt;shouldSpeculateString() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateString() &amp;&amp; ((GPRInfo::numberOfRegisters &gt;= 7) || m_graph.m_plan.isFTL())) {
3951             fixEdge&lt;StringUse&gt;(node-&gt;child1());
3952             fixEdge&lt;StringUse&gt;(node-&gt;child2());
3953             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3954             return;
3955         }
3956 
3957         if (node-&gt;op() == SameValue) {
3958             if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
3959                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
3960                 node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3961                 return;
3962             }
3963             if (node-&gt;child2()-&gt;shouldSpeculateObject()) {
3964                 fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
3965                 node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3966                 return;
3967             }
3968         } else {
3969             WatchpointSet* masqueradesAsUndefinedWatchpoint = m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;masqueradesAsUndefinedWatchpoint();
3970             if (masqueradesAsUndefinedWatchpoint-&gt;isStillValid()) {
3971                 if (node-&gt;child1()-&gt;shouldSpeculateObject()) {
3972                     m_graph.watchpoints().addLazily(masqueradesAsUndefinedWatchpoint);
3973                     fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
3974                     return;
3975                 }
3976                 if (node-&gt;child2()-&gt;shouldSpeculateObject()) {
3977                     m_graph.watchpoints().addLazily(masqueradesAsUndefinedWatchpoint);
3978                     fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
3979                     return;
3980                 }
3981             } else if (node-&gt;child1()-&gt;shouldSpeculateObject() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateObject()) {
3982                 fixEdge&lt;ObjectUse&gt;(node-&gt;child1());
3983                 fixEdge&lt;ObjectUse&gt;(node-&gt;child2());
3984                 return;
3985             }
3986         }
3987 
3988         if (node-&gt;child1()-&gt;shouldSpeculateSymbol()) {
3989             fixEdge&lt;SymbolUse&gt;(node-&gt;child1());
3990             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3991             return;
3992         }
3993         if (node-&gt;child2()-&gt;shouldSpeculateSymbol()) {
3994             fixEdge&lt;SymbolUse&gt;(node-&gt;child2());
3995             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
3996             return;
3997         }
3998         if (node-&gt;child1()-&gt;shouldSpeculateMisc()) {
3999             fixEdge&lt;MiscUse&gt;(node-&gt;child1());
4000             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
4001             return;
4002         }
4003         if (node-&gt;child2()-&gt;shouldSpeculateMisc()) {
4004             fixEdge&lt;MiscUse&gt;(node-&gt;child2());
4005             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
4006             return;
4007         }
4008         if (node-&gt;child1()-&gt;shouldSpeculateStringIdent()
4009             &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateNotStringVar()) {
4010             fixEdge&lt;StringIdentUse&gt;(node-&gt;child1());
4011             fixEdge&lt;NotStringVarUse&gt;(node-&gt;child2());
4012             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
4013             return;
4014         }
4015         if (node-&gt;child2()-&gt;shouldSpeculateStringIdent()
4016             &amp;&amp; node-&gt;child1()-&gt;shouldSpeculateNotStringVar()) {
4017             fixEdge&lt;StringIdentUse&gt;(node-&gt;child2());
4018             fixEdge&lt;NotStringVarUse&gt;(node-&gt;child1());
4019             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
4020             return;
4021         }
4022         if (node-&gt;child1()-&gt;shouldSpeculateString() &amp;&amp; ((GPRInfo::numberOfRegisters &gt;= 8) || m_graph.m_plan.isFTL())) {
4023             fixEdge&lt;StringUse&gt;(node-&gt;child1());
4024             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
4025             return;
4026         }
4027         if (node-&gt;child2()-&gt;shouldSpeculateString() &amp;&amp; ((GPRInfo::numberOfRegisters &gt;= 8) || m_graph.m_plan.isFTL())) {
4028             fixEdge&lt;StringUse&gt;(node-&gt;child2());
4029             node-&gt;setOpAndDefaultFlags(CompareStrictEq);
4030             return;
4031         }
4032     }
4033 
4034     void fixupChecksInBlock(BasicBlock* block)
4035     {
4036         if (!block)
4037             return;
4038         ASSERT(block-&gt;isReachable);
4039         m_block = block;
4040         unsigned indexForChecks = UINT_MAX;
4041         NodeOrigin originForChecks;
4042         for (unsigned indexInBlock = 0; indexInBlock &lt; block-&gt;size(); ++indexInBlock) {
4043             Node* node = block-&gt;at(indexInBlock);
4044 
4045             // If this is a node at which we could exit, then save its index. If nodes after this one
4046             // cannot exit, then we will hoist checks to here.
4047             if (node-&gt;origin.exitOK) {
4048                 indexForChecks = indexInBlock;
4049                 originForChecks = node-&gt;origin;
4050             }
4051 
4052             originForChecks = originForChecks.withSemantic(node-&gt;origin.semantic);
4053 
4054             // First, try to relax the representational demands of each node, in order to have
4055             // fewer conversions.
4056             switch (node-&gt;op()) {
4057             case MovHint:
4058             case Check:
4059             case CheckVarargs:
4060                 m_graph.doToChildren(
4061                     node,
4062                     [&amp;] (Edge&amp; edge) {
4063                         switch (edge.useKind()) {
4064                         case DoubleRepUse:
4065                         case DoubleRepRealUse:
4066                             if (edge-&gt;hasDoubleResult())
4067                                 break;
4068 
4069                             if (edge-&gt;hasInt52Result())
4070                                 edge.setUseKind(Int52RepUse);
4071                             else if (edge.useKind() == DoubleRepUse)
4072                                 edge.setUseKind(NumberUse);
4073                             break;
4074 
4075                         case Int52RepUse:
4076                             // Nothing we can really do.
4077                             break;
4078 
4079                         case UntypedUse:
4080                         case NumberUse:
4081                             if (edge-&gt;hasDoubleResult())
4082                                 edge.setUseKind(DoubleRepUse);
4083                             else if (edge-&gt;hasInt52Result())
4084                                 edge.setUseKind(Int52RepUse);
4085                             break;
4086 
4087                         case RealNumberUse:
4088                             if (edge-&gt;hasDoubleResult())
4089                                 edge.setUseKind(DoubleRepRealUse);
4090                             else if (edge-&gt;hasInt52Result())
4091                                 edge.setUseKind(Int52RepUse);
4092                             break;
4093 
4094                         default:
4095                             break;
4096                         }
4097                     });
4098                 break;
4099 
4100             case ValueToInt32:
4101                 if (node-&gt;child1().useKind() == DoubleRepUse
4102                     &amp;&amp; !node-&gt;child1()-&gt;hasDoubleResult()) {
4103                     node-&gt;child1().setUseKind(NumberUse);
4104                     break;
4105                 }
4106                 break;
4107 
4108             default:
4109                 break;
4110             }
4111 
4112             // Now, insert type conversions if necessary.
4113             m_graph.doToChildren(
4114                 node,
4115                 [&amp;] (Edge&amp; edge) {
4116                     Node* result = nullptr;
4117 
4118                     switch (edge.useKind()) {
4119                     case DoubleRepUse:
4120                     case DoubleRepRealUse:
4121                     case DoubleRepAnyIntUse: {
4122                         if (edge-&gt;hasDoubleResult())
4123                             break;
4124 
4125                         ASSERT(indexForChecks != UINT_MAX);
4126                         if (edge-&gt;isNumberConstant()) {
4127                             result = m_insertionSet.insertNode(
4128                                 indexForChecks, SpecBytecodeDouble, DoubleConstant, originForChecks,
4129                                 OpInfo(m_graph.freeze(jsDoubleNumber(edge-&gt;asNumber()))));
4130                         } else if (edge-&gt;hasInt52Result()) {
4131                             result = m_insertionSet.insertNode(
4132                                 indexForChecks, SpecAnyIntAsDouble, DoubleRep, originForChecks,
4133                                 Edge(edge.node(), Int52RepUse));
4134                         } else {
4135                             UseKind useKind;
4136                             if (edge-&gt;shouldSpeculateDoubleReal())
4137                                 useKind = RealNumberUse;
4138                             else if (edge-&gt;shouldSpeculateNumber())
4139                                 useKind = NumberUse;
4140                             else
4141                                 useKind = NotCellUse;
4142 
4143                             result = m_insertionSet.insertNode(
4144                                 indexForChecks, SpecBytecodeDouble, DoubleRep, originForChecks,
4145                                 Edge(edge.node(), useKind));
4146                         }
4147 
4148                         edge.setNode(result);
4149                         break;
4150                     }
4151 
4152                     case Int52RepUse: {
4153                         if (edge-&gt;hasInt52Result())
4154                             break;
4155 
4156                         ASSERT(indexForChecks != UINT_MAX);
4157                         if (edge-&gt;isAnyIntConstant()) {
4158                             result = m_insertionSet.insertNode(
4159                                 indexForChecks, SpecInt52Any, Int52Constant, originForChecks,
4160                                 OpInfo(edge-&gt;constant()));
4161                         } else if (edge-&gt;hasDoubleResult()) {
4162                             result = m_insertionSet.insertNode(
4163                                 indexForChecks, SpecInt52Any, Int52Rep, originForChecks,
4164                                 Edge(edge.node(), DoubleRepAnyIntUse));
4165                         } else if (edge-&gt;shouldSpeculateInt32ForArithmetic()) {
4166                             result = m_insertionSet.insertNode(
4167                                 indexForChecks, SpecInt32Only, Int52Rep, originForChecks,
4168                                 Edge(edge.node(), Int32Use));
4169                         } else {
4170                             result = m_insertionSet.insertNode(
4171                                 indexForChecks, SpecInt52Any, Int52Rep, originForChecks,
4172                                 Edge(edge.node(), AnyIntUse));
4173                         }
4174 
4175                         edge.setNode(result);
4176                         break;
4177                     }
4178 
4179                     default: {
4180                         if (!edge-&gt;hasDoubleResult() &amp;&amp; !edge-&gt;hasInt52Result())
4181                             break;
4182 
4183                         ASSERT(indexForChecks != UINT_MAX);
4184                         if (edge-&gt;hasDoubleResult()) {
4185                             result = m_insertionSet.insertNode(
4186                                 indexForChecks, SpecBytecodeDouble, ValueRep, originForChecks,
4187                                 Edge(edge.node(), DoubleRepUse));
4188                         } else {
4189                             result = m_insertionSet.insertNode(
4190                                 indexForChecks, SpecInt32Only | SpecAnyIntAsDouble, ValueRep,
4191                                 originForChecks, Edge(edge.node(), Int52RepUse));
4192                         }
4193 
4194                         edge.setNode(result);
4195                         break;
4196                     } }
4197 
4198                     // It&#39;s remotely possible that this node cannot do type checks, but we now have a
4199                     // type check on this node. We don&#39;t have to handle the general form of this
4200                     // problem. It only arises when ByteCodeParser emits an immediate SetLocal, rather
4201                     // than a delayed one. So, we only worry about those checks that we may have put on
4202                     // a SetLocal. Note that &quot;indexForChecks != indexInBlock&quot; is just another way of
4203                     // saying &quot;!node-&gt;origin.exitOK&quot;.
4204                     if (indexForChecks != indexInBlock &amp;&amp; mayHaveTypeCheck(edge.useKind())) {
4205                         UseKind knownUseKind;
4206 
4207                         switch (edge.useKind()) {
4208                         case Int32Use:
4209                             knownUseKind = KnownInt32Use;
4210                             break;
4211                         case CellUse:
4212                             knownUseKind = KnownCellUse;
4213                             break;
4214                         case BooleanUse:
4215                             knownUseKind = KnownBooleanUse;
4216                             break;
4217                         default:
4218                             // This can only arise if we have a Check node, and in that case, we can
4219                             // just remove the original check.
4220                             DFG_ASSERT(m_graph, node, node-&gt;op() == Check, node-&gt;op(), edge.useKind());
4221                             knownUseKind = UntypedUse;
4222                             break;
4223                         }
4224 
4225                         ASSERT(indexForChecks != UINT_MAX);
4226                         m_insertionSet.insertNode(
4227                             indexForChecks, SpecNone, Check, originForChecks, edge);
4228 
4229                         edge.setUseKind(knownUseKind);
4230                     }
4231                 });
4232         }
4233 
4234         m_insertionSet.execute(block);
4235     }
4236 
4237     BasicBlock* m_block;
4238     unsigned m_indexInBlock;
4239     Node* m_currentNode;
4240     InsertionSet m_insertionSet;
4241     bool m_profitabilityChanged;
4242 };
4243 
4244 bool performFixup(Graph&amp; graph)
4245 {
4246     return runPhase&lt;FixupPhase&gt;(graph);
4247 }
4248 
4249 } } // namespace JSC::DFG
4250 
4251 #endif // ENABLE(DFG_JIT)
4252 
<a name="36" id="anc36"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="36" type="hidden" />
</body>
</html>
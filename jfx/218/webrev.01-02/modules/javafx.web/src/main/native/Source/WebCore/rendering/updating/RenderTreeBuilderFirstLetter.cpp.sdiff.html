<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilderFirstLetter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderTreeBuilderBlockFlow.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderTreeBuilderFirstLetter.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilderFirstLetter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 39 
 40 static RenderStyle styleForFirstLetter(const RenderBlock&amp; firstLetterBlock, const RenderObject&amp; firstLetterContainer)
 41 {
 42     auto* containerFirstLetterStyle = firstLetterBlock.getCachedPseudoStyle(PseudoId::FirstLetter, &amp;firstLetterContainer.firstLineStyle());
 43     // FIXME: There appears to be some path where we have a first letter renderer without first letter style.
 44     ASSERT(containerFirstLetterStyle);
 45     auto firstLetterStyle = RenderStyle::clone(containerFirstLetterStyle ? *containerFirstLetterStyle : firstLetterContainer.firstLineStyle());
 46 
 47     // If we have an initial letter drop that is &gt;= 1, then we need to force floating to be on.
 48     if (firstLetterStyle.initialLetterDrop() &gt;= 1 &amp;&amp; !firstLetterStyle.isFloating())
 49         firstLetterStyle.setFloating(firstLetterStyle.isLeftToRightDirection() ? Float::Left : Float::Right);
 50 
 51     // We have to compute the correct font-size for the first-letter if it has an initial letter height set.
 52     auto* paragraph = firstLetterContainer.isRenderBlockFlow() ? &amp;firstLetterContainer : firstLetterContainer.containingBlock();
 53     if (firstLetterStyle.initialLetterHeight() &gt;= 1 &amp;&amp; firstLetterStyle.fontMetrics().hasCapHeight() &amp;&amp; paragraph-&gt;style().fontMetrics().hasCapHeight()) {
 54         // FIXME: For ideographic baselines, we want to go from line edge to line edge. This is equivalent to (N-1)*line-height + the font height.
 55         // We don&#39;t yet support ideographic baselines.
 56         // For an N-line first-letter and for alphabetic baselines, the cap-height of the first letter needs to equal (N-1)*line-height of paragraph lines + cap-height of the paragraph
 57         // Mathematically we can&#39;t rely on font-size, since font().height() doesn&#39;t necessarily match. For reliability, the best approach is simply to
 58         // compare the final measured cap-heights of the two fonts in order to get to the closest possible value.
<span class="line-modified"> 59         firstLetterStyle.setLineBoxContain(LineBoxContainInitialLetter);</span>
 60         int lineHeight = paragraph-&gt;style().computedLineHeight();
 61 
 62         // Set the font to be one line too big and then ratchet back to get to a precise fit. We can&#39;t just set the desired font size based off font height metrics
 63         // because many fonts bake ascent into the font metrics. Therefore we have to look at actual measured cap height values in order to know when we have a good fit.
 64         auto newFontDescription = firstLetterStyle.fontDescription();
 65         float capRatio = firstLetterStyle.fontMetrics().floatCapHeight() / firstLetterStyle.computedFontPixelSize();
 66         float startingFontSize = ((firstLetterStyle.initialLetterHeight() - 1) * lineHeight + paragraph-&gt;style().fontMetrics().capHeight()) / capRatio;
 67         newFontDescription.setSpecifiedSize(startingFontSize);
 68         newFontDescription.setComputedSize(startingFontSize);
 69         firstLetterStyle.setFontDescription(WTFMove(newFontDescription));
 70         firstLetterStyle.fontCascade().update(firstLetterStyle.fontCascade().fontSelector());
 71 
 72         int desiredCapHeight = (firstLetterStyle.initialLetterHeight() - 1) * lineHeight + paragraph-&gt;style().fontMetrics().capHeight();
 73         int actualCapHeight = firstLetterStyle.fontMetrics().capHeight();
 74         while (actualCapHeight &gt; desiredCapHeight) {
 75             auto newFontDescription = firstLetterStyle.fontDescription();
 76             newFontDescription.setSpecifiedSize(newFontDescription.specifiedSize() - 1);
 77             newFontDescription.setComputedSize(newFontDescription.computedSize() -1);
 78             firstLetterStyle.setFontDescription(WTFMove(newFontDescription));
 79             firstLetterStyle.fontCascade().update(firstLetterStyle.fontCascade().fontSelector());
 80             actualCapHeight = firstLetterStyle.fontMetrics().capHeight();
 81         }
 82     }
 83 

 84     // Force inline display (except for floating first-letters).
 85     firstLetterStyle.setDisplay(firstLetterStyle.isFloating() ? DisplayType::Block : DisplayType::Inline);
 86     // CSS2 says first-letter can&#39;t be positioned.
 87     firstLetterStyle.setPosition(PositionType::Static);

 88     return firstLetterStyle;
 89 }
 90 
 91 // CSS 2.1 http://www.w3.org/TR/CSS21/selector.html#first-letter
 92 // &quot;Punctuation (i.e, characters defined in Unicode [UNICODE] in the &quot;open&quot; (Ps), &quot;close&quot; (Pe),
 93 // &quot;initial&quot; (Pi). &quot;final&quot; (Pf) and &quot;other&quot; (Po) punctuation classes), that precedes or follows the first letter should be included&quot;
 94 static inline bool isPunctuationForFirstLetter(UChar32 c)
 95 {
 96     return U_GET_GC_MASK(c) &amp; (U_GC_PS_MASK | U_GC_PE_MASK | U_GC_PI_MASK | U_GC_PF_MASK | U_GC_PO_MASK);
 97 }
 98 
 99 static inline bool shouldSkipForFirstLetter(UChar32 c)
100 {
101     return isSpaceOrNewline(c) || c == noBreakSpace || isPunctuationForFirstLetter(c);
102 }
103 
104 static bool supportsFirstLetter(RenderBlock&amp; block)
105 {
106     if (is&lt;RenderButton&gt;(block))
107         return true;
</pre>
</td>
<td>
<hr />
<pre>
 39 
 40 static RenderStyle styleForFirstLetter(const RenderBlock&amp; firstLetterBlock, const RenderObject&amp; firstLetterContainer)
 41 {
 42     auto* containerFirstLetterStyle = firstLetterBlock.getCachedPseudoStyle(PseudoId::FirstLetter, &amp;firstLetterContainer.firstLineStyle());
 43     // FIXME: There appears to be some path where we have a first letter renderer without first letter style.
 44     ASSERT(containerFirstLetterStyle);
 45     auto firstLetterStyle = RenderStyle::clone(containerFirstLetterStyle ? *containerFirstLetterStyle : firstLetterContainer.firstLineStyle());
 46 
 47     // If we have an initial letter drop that is &gt;= 1, then we need to force floating to be on.
 48     if (firstLetterStyle.initialLetterDrop() &gt;= 1 &amp;&amp; !firstLetterStyle.isFloating())
 49         firstLetterStyle.setFloating(firstLetterStyle.isLeftToRightDirection() ? Float::Left : Float::Right);
 50 
 51     // We have to compute the correct font-size for the first-letter if it has an initial letter height set.
 52     auto* paragraph = firstLetterContainer.isRenderBlockFlow() ? &amp;firstLetterContainer : firstLetterContainer.containingBlock();
 53     if (firstLetterStyle.initialLetterHeight() &gt;= 1 &amp;&amp; firstLetterStyle.fontMetrics().hasCapHeight() &amp;&amp; paragraph-&gt;style().fontMetrics().hasCapHeight()) {
 54         // FIXME: For ideographic baselines, we want to go from line edge to line edge. This is equivalent to (N-1)*line-height + the font height.
 55         // We don&#39;t yet support ideographic baselines.
 56         // For an N-line first-letter and for alphabetic baselines, the cap-height of the first letter needs to equal (N-1)*line-height of paragraph lines + cap-height of the paragraph
 57         // Mathematically we can&#39;t rely on font-size, since font().height() doesn&#39;t necessarily match. For reliability, the best approach is simply to
 58         // compare the final measured cap-heights of the two fonts in order to get to the closest possible value.
<span class="line-modified"> 59         firstLetterStyle.setLineBoxContain({ LineBoxContain::InitialLetter });</span>
 60         int lineHeight = paragraph-&gt;style().computedLineHeight();
 61 
 62         // Set the font to be one line too big and then ratchet back to get to a precise fit. We can&#39;t just set the desired font size based off font height metrics
 63         // because many fonts bake ascent into the font metrics. Therefore we have to look at actual measured cap height values in order to know when we have a good fit.
 64         auto newFontDescription = firstLetterStyle.fontDescription();
 65         float capRatio = firstLetterStyle.fontMetrics().floatCapHeight() / firstLetterStyle.computedFontPixelSize();
 66         float startingFontSize = ((firstLetterStyle.initialLetterHeight() - 1) * lineHeight + paragraph-&gt;style().fontMetrics().capHeight()) / capRatio;
 67         newFontDescription.setSpecifiedSize(startingFontSize);
 68         newFontDescription.setComputedSize(startingFontSize);
 69         firstLetterStyle.setFontDescription(WTFMove(newFontDescription));
 70         firstLetterStyle.fontCascade().update(firstLetterStyle.fontCascade().fontSelector());
 71 
 72         int desiredCapHeight = (firstLetterStyle.initialLetterHeight() - 1) * lineHeight + paragraph-&gt;style().fontMetrics().capHeight();
 73         int actualCapHeight = firstLetterStyle.fontMetrics().capHeight();
 74         while (actualCapHeight &gt; desiredCapHeight) {
 75             auto newFontDescription = firstLetterStyle.fontDescription();
 76             newFontDescription.setSpecifiedSize(newFontDescription.specifiedSize() - 1);
 77             newFontDescription.setComputedSize(newFontDescription.computedSize() -1);
 78             firstLetterStyle.setFontDescription(WTFMove(newFontDescription));
 79             firstLetterStyle.fontCascade().update(firstLetterStyle.fontCascade().fontSelector());
 80             actualCapHeight = firstLetterStyle.fontMetrics().capHeight();
 81         }
 82     }
 83 
<span class="line-added"> 84     firstLetterStyle.setStyleType(PseudoId::FirstLetter);</span>
 85     // Force inline display (except for floating first-letters).
 86     firstLetterStyle.setDisplay(firstLetterStyle.isFloating() ? DisplayType::Block : DisplayType::Inline);
 87     // CSS2 says first-letter can&#39;t be positioned.
 88     firstLetterStyle.setPosition(PositionType::Static);
<span class="line-added"> 89 </span>
 90     return firstLetterStyle;
 91 }
 92 
 93 // CSS 2.1 http://www.w3.org/TR/CSS21/selector.html#first-letter
 94 // &quot;Punctuation (i.e, characters defined in Unicode [UNICODE] in the &quot;open&quot; (Ps), &quot;close&quot; (Pe),
 95 // &quot;initial&quot; (Pi). &quot;final&quot; (Pf) and &quot;other&quot; (Po) punctuation classes), that precedes or follows the first letter should be included&quot;
 96 static inline bool isPunctuationForFirstLetter(UChar32 c)
 97 {
 98     return U_GET_GC_MASK(c) &amp; (U_GC_PS_MASK | U_GC_PE_MASK | U_GC_PI_MASK | U_GC_PF_MASK | U_GC_PO_MASK);
 99 }
100 
101 static inline bool shouldSkipForFirstLetter(UChar32 c)
102 {
103     return isSpaceOrNewline(c) || c == noBreakSpace || isPunctuationForFirstLetter(c);
104 }
105 
106 static bool supportsFirstLetter(RenderBlock&amp; block)
107 {
108     if (is&lt;RenderButton&gt;(block))
109         return true;
</pre>
</td>
</tr>
</table>
<center><a href="RenderTreeBuilderBlockFlow.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderTreeBuilderFirstLetter.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
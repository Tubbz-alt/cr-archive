<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLVideoElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLTrackElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLVideoElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLVideoElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;HTMLVideoElement.h&quot;
 28 
 29 #if ENABLE(VIDEO)
 30 
 31 #include &quot;CSSPropertyNames.h&quot;
 32 #include &quot;Chrome.h&quot;
 33 #include &quot;ChromeClient.h&quot;
 34 #include &quot;Document.h&quot;
 35 #include &quot;EventNames.h&quot;
 36 #include &quot;Frame.h&quot;
 37 #include &quot;HTMLImageLoader.h&quot;
 38 #include &quot;HTMLNames.h&quot;
 39 #include &quot;HTMLParserIdioms.h&quot;
 40 #include &quot;Logging.h&quot;
 41 #include &quot;Page.h&quot;

 42 #include &quot;RenderImage.h&quot;
 43 #include &quot;RenderVideo.h&quot;
 44 #include &quot;ScriptController.h&quot;
 45 #include &quot;Settings.h&quot;
 46 #include &lt;wtf/IsoMallocInlines.h&gt;
 47 #include &lt;wtf/text/TextStream.h&gt;
 48 
 49 #if ENABLE(VIDEO_PRESENTATION_MODE)
 50 #include &quot;VideoFullscreenModel.h&quot;
 51 #endif
 52 





 53 namespace WebCore {
 54 
 55 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLVideoElement);
 56 
 57 using namespace HTMLNames;
 58 
 59 inline HTMLVideoElement::HTMLVideoElement(const QualifiedName&amp; tagName, Document&amp; document, bool createdByParser)
 60     : HTMLMediaElement(tagName, document, createdByParser)
 61 {
 62     ASSERT(hasTagName(videoTag));
 63     setHasCustomStyleResolveCallbacks();
 64     m_defaultPosterURL = document.settings().defaultVideoPosterURL();
 65 }
 66 
 67 Ref&lt;HTMLVideoElement&gt; HTMLVideoElement::create(const QualifiedName&amp; tagName, Document&amp; document, bool createdByParser)
 68 {
 69     auto videoElement = adoptRef(*new HTMLVideoElement(tagName, document, createdByParser));





 70     videoElement-&gt;finishInitialization();
 71     videoElement-&gt;suspendIfNeeded();
 72     return videoElement;
 73 }
 74 
 75 Ref&lt;HTMLVideoElement&gt; HTMLVideoElement::create(Document&amp; document)
 76 {
 77     return create(videoTag, document, false);
 78 }
 79 
 80 bool HTMLVideoElement::rendererIsNeeded(const RenderStyle&amp; style)
 81 {
 82     return HTMLElement::rendererIsNeeded(style);
 83 }
 84 
 85 RenderPtr&lt;RenderElement&gt; HTMLVideoElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 86 {
 87     return createRenderer&lt;RenderVideo&gt;(*this, WTFMove(style));
 88 }
 89 
</pre>
<hr />
<pre>
242 
243 void HTMLVideoElement::setDisplayMode(DisplayMode mode)
244 {
245     DisplayMode oldMode = displayMode();
246     URL poster = posterImageURL();
247 
248     if (!poster.isEmpty()) {
249         // We have a poster path, but only show it until the user triggers display by playing or seeking and the
250         // media engine has something to display.
251         if (mode == Video) {
252             if (oldMode != Video &amp;&amp; player())
253                 player()-&gt;prepareForRendering();
254             if (!hasAvailableVideoFrame())
255                 mode = PosterWaitingForVideo;
256         }
257     } else if (oldMode != Video &amp;&amp; player())
258         player()-&gt;prepareForRendering();
259 
260     HTMLMediaElement::setDisplayMode(mode);
261 
<span class="line-removed">262     if (player() &amp;&amp; player()-&gt;canLoadPoster()) {</span>
<span class="line-removed">263         bool canLoad = true;</span>
<span class="line-removed">264         if (!poster.isEmpty()) {</span>
<span class="line-removed">265             if (RefPtr&lt;Frame&gt; frame = document().frame())</span>
<span class="line-removed">266                 canLoad = frame-&gt;loader().willLoadMediaElementURL(poster, *this);</span>
<span class="line-removed">267         }</span>
<span class="line-removed">268         if (canLoad)</span>
<span class="line-removed">269             player()-&gt;setPoster(poster);</span>
<span class="line-removed">270     }</span>
<span class="line-removed">271 </span>
272     if (auto* renderer = this-&gt;renderer()) {
273         if (displayMode() != oldMode)
274             renderer-&gt;updateFromElement();
275     }
276 }
277 
278 void HTMLVideoElement::updateDisplayState()
279 {
280     if (posterImageURL().isEmpty())
281         setDisplayMode(Video);
282     else if (displayMode() &lt; Poster)
283         setDisplayMode(Poster);
284 }
285 
286 void HTMLVideoElement::paintCurrentFrameInContext(GraphicsContext&amp; context, const FloatRect&amp; destRect)
287 {
288     RefPtr&lt;MediaPlayer&gt; player = HTMLMediaElement::player();
289     if (!player)
290         return;
291 
292     player-&gt;setVisible(true); // Make player visible or it won&#39;t draw.
293     player-&gt;paintCurrentFrameInContext(context, destRect);
294 }
295 
<span class="line-modified">296 bool HTMLVideoElement::copyVideoTextureToPlatformTexture(GraphicsContext3D* context, Platform3DObject texture, GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Denum format, GC3Denum type, bool premultiplyAlpha, bool flipY)</span>
297 {
298     if (!player())
299         return false;
300     return player()-&gt;copyVideoTextureToPlatformTexture(context, texture, target, level, internalFormat, format, type, premultiplyAlpha, flipY);
301 }
302 
303 bool HTMLVideoElement::hasAvailableVideoFrame() const
304 {
305     if (!player())
306         return false;
307 
308     return player()-&gt;hasVideo() &amp;&amp; player()-&gt;hasAvailableVideoFrame();
309 }
310 
311 NativeImagePtr HTMLVideoElement::nativeImageForCurrentTime()
312 {
313     if (!player())
314         return nullptr;
315 
316     return player()-&gt;nativeImageForCurrentTime();
</pre>
<hr />
<pre>
396     return player()-&gt;droppedFrameCount();
397 }
398 #endif
399 
400 URL HTMLVideoElement::posterImageURL() const
401 {
402     String url = stripLeadingAndTrailingHTMLSpaces(imageSourceURL());
403     if (url.isEmpty())
404         return URL();
405     return document().completeURL(url);
406 }
407 
408 #if ENABLE(VIDEO_PRESENTATION_MODE)
409 
410 bool HTMLVideoElement::webkitSupportsPresentationMode(VideoPresentationMode mode) const
411 {
412     if (mode == VideoPresentationMode::Fullscreen)
413         return supportsFullscreen(HTMLMediaElementEnums::VideoFullscreenModeStandard);
414 
415     if (mode == VideoPresentationMode::PictureInPicture) {
<span class="line-removed">416 #if PLATFORM(COCOA)</span>
417         if (!supportsPictureInPicture())
418             return false;
<span class="line-removed">419 #endif</span>
420 
421         return supportsFullscreen(HTMLMediaElementEnums::VideoFullscreenModePictureInPicture);
422     }
423 
424     if (mode == VideoPresentationMode::Inline)
425         return !mediaSession().requiresFullscreenForVideoPlayback();
426 
427     return false;
428 }
429 
430 static inline HTMLMediaElementEnums::VideoFullscreenMode toFullscreenMode(HTMLVideoElement::VideoPresentationMode mode)
431 {
432     switch (mode) {
433     case HTMLVideoElement::VideoPresentationMode::Fullscreen:
434         return HTMLMediaElementEnums::VideoFullscreenModeStandard;
435     case HTMLVideoElement::VideoPresentationMode::PictureInPicture:
436         return HTMLMediaElementEnums::VideoFullscreenModePictureInPicture;
437     case HTMLVideoElement::VideoPresentationMode::Inline:
438         return HTMLMediaElementEnums::VideoFullscreenModeNone;
439     }
440     ASSERT_NOT_REACHED();
441     return HTMLMediaElementEnums::VideoFullscreenModeNone;
442 }
443 
444 void HTMLVideoElement::webkitSetPresentationMode(VideoPresentationMode mode)
445 {
<span class="line-modified">446     ALWAYS_LOG(LOGIDENTIFIER, mode);</span>
447     setFullscreenMode(toFullscreenMode(mode));
448 }
449 
450 void HTMLVideoElement::setFullscreenMode(HTMLMediaElementEnums::VideoFullscreenMode mode)
451 {
<span class="line-modified">452     if (mode == VideoFullscreenModeNone &amp;&amp; isFullscreen()) {</span>
<span class="line-modified">453         exitFullscreen();</span>



















454         return;
455     }
456 
457     if (!mediaSession().fullscreenPermitted() || !supportsFullscreen(mode))
458         return;
459 
460     enterFullscreen(mode);
461 }
462 
463 static HTMLVideoElement::VideoPresentationMode toPresentationMode(HTMLMediaElementEnums::VideoFullscreenMode mode)
464 {
465     if (mode == HTMLMediaElementEnums::VideoFullscreenModeStandard)
466         return HTMLVideoElement::VideoPresentationMode::Fullscreen;
467 
468     if (mode &amp; HTMLMediaElementEnums::VideoFullscreenModePictureInPicture)
469         return HTMLVideoElement::VideoPresentationMode::PictureInPicture;
470 
471     if (mode == HTMLMediaElementEnums::VideoFullscreenModeNone)
472         return HTMLVideoElement::VideoPresentationMode::Inline;
473 
474     ASSERT_NOT_REACHED();
475     return HTMLVideoElement::VideoPresentationMode::Inline;
476 }
477 
478 auto HTMLVideoElement::webkitPresentationMode() const -&gt; VideoPresentationMode
479 {
480     return toPresentationMode(fullscreenMode());
481 }
482 
483 void HTMLVideoElement::fullscreenModeChanged(VideoFullscreenMode mode)
484 {
485     if (mode != fullscreenMode()) {
<span class="line-modified">486         ALWAYS_LOG(LOGIDENTIFIER, &quot;changed from &quot;, fullscreenMode(), &quot;, to &quot;, mode);</span>
487         scheduleEvent(eventNames().webkitpresentationmodechangedEvent);












488     }
489 
490     if (player())
491         player()-&gt;setVideoFullscreenMode(mode);
492 
493     HTMLMediaElement::fullscreenModeChanged(mode);
494 }
495 















































496 #endif
497 
498 #if PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE)
499 void HTMLVideoElement::exitToFullscreenModeWithoutAnimationIfPossible(HTMLMediaElementEnums::VideoFullscreenMode fromMode, HTMLMediaElementEnums::VideoFullscreenMode toMode)
500 {
501     if (document().page()-&gt;chrome().client().supportsVideoFullscreen(fromMode))
502         document().page()-&gt;chrome().client().exitVideoFullscreenToModeWithoutAnimation(*this, toMode);
503 }
504 #endif
505 
506 }
507 
508 #endif
</pre>
</td>
<td>
<hr />
<pre>
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;HTMLVideoElement.h&quot;
 28 
 29 #if ENABLE(VIDEO)
 30 
 31 #include &quot;CSSPropertyNames.h&quot;
 32 #include &quot;Chrome.h&quot;
 33 #include &quot;ChromeClient.h&quot;
 34 #include &quot;Document.h&quot;
 35 #include &quot;EventNames.h&quot;
 36 #include &quot;Frame.h&quot;
 37 #include &quot;HTMLImageLoader.h&quot;
 38 #include &quot;HTMLNames.h&quot;
 39 #include &quot;HTMLParserIdioms.h&quot;
 40 #include &quot;Logging.h&quot;
 41 #include &quot;Page.h&quot;
<span class="line-added"> 42 #include &quot;PictureInPictureSupport.h&quot;</span>
 43 #include &quot;RenderImage.h&quot;
 44 #include &quot;RenderVideo.h&quot;
 45 #include &quot;ScriptController.h&quot;
 46 #include &quot;Settings.h&quot;
 47 #include &lt;wtf/IsoMallocInlines.h&gt;
 48 #include &lt;wtf/text/TextStream.h&gt;
 49 
 50 #if ENABLE(VIDEO_PRESENTATION_MODE)
 51 #include &quot;VideoFullscreenModel.h&quot;
 52 #endif
 53 
<span class="line-added"> 54 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added"> 55 #include &quot;HTMLVideoElementPictureInPicture.h&quot;</span>
<span class="line-added"> 56 #include &quot;PictureInPictureObserver.h&quot;</span>
<span class="line-added"> 57 #endif</span>
<span class="line-added"> 58 </span>
 59 namespace WebCore {
 60 
 61 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLVideoElement);
 62 
 63 using namespace HTMLNames;
 64 
 65 inline HTMLVideoElement::HTMLVideoElement(const QualifiedName&amp; tagName, Document&amp; document, bool createdByParser)
 66     : HTMLMediaElement(tagName, document, createdByParser)
 67 {
 68     ASSERT(hasTagName(videoTag));
 69     setHasCustomStyleResolveCallbacks();
 70     m_defaultPosterURL = document.settings().defaultVideoPosterURL();
 71 }
 72 
 73 Ref&lt;HTMLVideoElement&gt; HTMLVideoElement::create(const QualifiedName&amp; tagName, Document&amp; document, bool createdByParser)
 74 {
 75     auto videoElement = adoptRef(*new HTMLVideoElement(tagName, document, createdByParser));
<span class="line-added"> 76 </span>
<span class="line-added"> 77 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added"> 78     HTMLVideoElementPictureInPicture::providePictureInPictureTo(videoElement);</span>
<span class="line-added"> 79 #endif</span>
<span class="line-added"> 80 </span>
 81     videoElement-&gt;finishInitialization();
 82     videoElement-&gt;suspendIfNeeded();
 83     return videoElement;
 84 }
 85 
 86 Ref&lt;HTMLVideoElement&gt; HTMLVideoElement::create(Document&amp; document)
 87 {
 88     return create(videoTag, document, false);
 89 }
 90 
 91 bool HTMLVideoElement::rendererIsNeeded(const RenderStyle&amp; style)
 92 {
 93     return HTMLElement::rendererIsNeeded(style);
 94 }
 95 
 96 RenderPtr&lt;RenderElement&gt; HTMLVideoElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 97 {
 98     return createRenderer&lt;RenderVideo&gt;(*this, WTFMove(style));
 99 }
100 
</pre>
<hr />
<pre>
253 
254 void HTMLVideoElement::setDisplayMode(DisplayMode mode)
255 {
256     DisplayMode oldMode = displayMode();
257     URL poster = posterImageURL();
258 
259     if (!poster.isEmpty()) {
260         // We have a poster path, but only show it until the user triggers display by playing or seeking and the
261         // media engine has something to display.
262         if (mode == Video) {
263             if (oldMode != Video &amp;&amp; player())
264                 player()-&gt;prepareForRendering();
265             if (!hasAvailableVideoFrame())
266                 mode = PosterWaitingForVideo;
267         }
268     } else if (oldMode != Video &amp;&amp; player())
269         player()-&gt;prepareForRendering();
270 
271     HTMLMediaElement::setDisplayMode(mode);
272 










273     if (auto* renderer = this-&gt;renderer()) {
274         if (displayMode() != oldMode)
275             renderer-&gt;updateFromElement();
276     }
277 }
278 
279 void HTMLVideoElement::updateDisplayState()
280 {
281     if (posterImageURL().isEmpty())
282         setDisplayMode(Video);
283     else if (displayMode() &lt; Poster)
284         setDisplayMode(Poster);
285 }
286 
287 void HTMLVideoElement::paintCurrentFrameInContext(GraphicsContext&amp; context, const FloatRect&amp; destRect)
288 {
289     RefPtr&lt;MediaPlayer&gt; player = HTMLMediaElement::player();
290     if (!player)
291         return;
292 
293     player-&gt;setVisible(true); // Make player visible or it won&#39;t draw.
294     player-&gt;paintCurrentFrameInContext(context, destRect);
295 }
296 
<span class="line-modified">297 bool HTMLVideoElement::copyVideoTextureToPlatformTexture(GraphicsContextGLOpenGL* context, PlatformGLObject texture, GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLenum format, GCGLenum type, bool premultiplyAlpha, bool flipY)</span>
298 {
299     if (!player())
300         return false;
301     return player()-&gt;copyVideoTextureToPlatformTexture(context, texture, target, level, internalFormat, format, type, premultiplyAlpha, flipY);
302 }
303 
304 bool HTMLVideoElement::hasAvailableVideoFrame() const
305 {
306     if (!player())
307         return false;
308 
309     return player()-&gt;hasVideo() &amp;&amp; player()-&gt;hasAvailableVideoFrame();
310 }
311 
312 NativeImagePtr HTMLVideoElement::nativeImageForCurrentTime()
313 {
314     if (!player())
315         return nullptr;
316 
317     return player()-&gt;nativeImageForCurrentTime();
</pre>
<hr />
<pre>
397     return player()-&gt;droppedFrameCount();
398 }
399 #endif
400 
401 URL HTMLVideoElement::posterImageURL() const
402 {
403     String url = stripLeadingAndTrailingHTMLSpaces(imageSourceURL());
404     if (url.isEmpty())
405         return URL();
406     return document().completeURL(url);
407 }
408 
409 #if ENABLE(VIDEO_PRESENTATION_MODE)
410 
411 bool HTMLVideoElement::webkitSupportsPresentationMode(VideoPresentationMode mode) const
412 {
413     if (mode == VideoPresentationMode::Fullscreen)
414         return supportsFullscreen(HTMLMediaElementEnums::VideoFullscreenModeStandard);
415 
416     if (mode == VideoPresentationMode::PictureInPicture) {

417         if (!supportsPictureInPicture())
418             return false;

419 
420         return supportsFullscreen(HTMLMediaElementEnums::VideoFullscreenModePictureInPicture);
421     }
422 
423     if (mode == VideoPresentationMode::Inline)
424         return !mediaSession().requiresFullscreenForVideoPlayback();
425 
426     return false;
427 }
428 
429 static inline HTMLMediaElementEnums::VideoFullscreenMode toFullscreenMode(HTMLVideoElement::VideoPresentationMode mode)
430 {
431     switch (mode) {
432     case HTMLVideoElement::VideoPresentationMode::Fullscreen:
433         return HTMLMediaElementEnums::VideoFullscreenModeStandard;
434     case HTMLVideoElement::VideoPresentationMode::PictureInPicture:
435         return HTMLMediaElementEnums::VideoFullscreenModePictureInPicture;
436     case HTMLVideoElement::VideoPresentationMode::Inline:
437         return HTMLMediaElementEnums::VideoFullscreenModeNone;
438     }
439     ASSERT_NOT_REACHED();
440     return HTMLMediaElementEnums::VideoFullscreenModeNone;
441 }
442 
443 void HTMLVideoElement::webkitSetPresentationMode(VideoPresentationMode mode)
444 {
<span class="line-modified">445     INFO_LOG(LOGIDENTIFIER, &quot;, mode = &quot;,  mode);</span>
446     setFullscreenMode(toFullscreenMode(mode));
447 }
448 
449 void HTMLVideoElement::setFullscreenMode(HTMLMediaElementEnums::VideoFullscreenMode mode)
450 {
<span class="line-modified">451     INFO_LOG(LOGIDENTIFIER, &quot;, mode = &quot;, mode);</span>
<span class="line-modified">452 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added">453     if (m_pictureInPictureAPITestEnabled) {</span>
<span class="line-added">454         if (mode == VideoFullscreenModePictureInPicture) {</span>
<span class="line-added">455             fullscreenModeChanged(mode);</span>
<span class="line-added">456             didBecomeFullscreenElement();</span>
<span class="line-added">457             setVideoFullscreenFrame({0, 0, 100, 100});</span>
<span class="line-added">458             return;</span>
<span class="line-added">459         }</span>
<span class="line-added">460 </span>
<span class="line-added">461         if (mode == VideoFullscreenModeNone) {</span>
<span class="line-added">462             fullscreenModeChanged(mode);</span>
<span class="line-added">463             return;</span>
<span class="line-added">464         }</span>
<span class="line-added">465     }</span>
<span class="line-added">466 #endif</span>
<span class="line-added">467 </span>
<span class="line-added">468     if (mode == VideoFullscreenModeNone) {</span>
<span class="line-added">469         if (isFullscreen())</span>
<span class="line-added">470             exitFullscreen();</span>
<span class="line-added">471 </span>
472         return;
473     }
474 
475     if (!mediaSession().fullscreenPermitted() || !supportsFullscreen(mode))
476         return;
477 
478     enterFullscreen(mode);
479 }
480 
481 static HTMLVideoElement::VideoPresentationMode toPresentationMode(HTMLMediaElementEnums::VideoFullscreenMode mode)
482 {
483     if (mode == HTMLMediaElementEnums::VideoFullscreenModeStandard)
484         return HTMLVideoElement::VideoPresentationMode::Fullscreen;
485 
486     if (mode &amp; HTMLMediaElementEnums::VideoFullscreenModePictureInPicture)
487         return HTMLVideoElement::VideoPresentationMode::PictureInPicture;
488 
489     if (mode == HTMLMediaElementEnums::VideoFullscreenModeNone)
490         return HTMLVideoElement::VideoPresentationMode::Inline;
491 
492     ASSERT_NOT_REACHED();
493     return HTMLVideoElement::VideoPresentationMode::Inline;
494 }
495 
496 auto HTMLVideoElement::webkitPresentationMode() const -&gt; VideoPresentationMode
497 {
498     return toPresentationMode(fullscreenMode());
499 }
500 
501 void HTMLVideoElement::fullscreenModeChanged(VideoFullscreenMode mode)
502 {
503     if (mode != fullscreenMode()) {
<span class="line-modified">504         INFO_LOG(LOGIDENTIFIER, &quot;changed from &quot;, fullscreenMode(), &quot;, to &quot;, mode);</span>
505         scheduleEvent(eventNames().webkitpresentationmodechangedEvent);
<span class="line-added">506 </span>
<span class="line-added">507 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added">508         if (m_pictureInPictureObserver) {</span>
<span class="line-added">509             HTMLVideoElement::VideoPresentationMode targetVideoPresentationMode = toPresentationMode(mode);</span>
<span class="line-added">510             HTMLVideoElement::VideoPresentationMode sourceVideoPresentationMode = toPresentationMode(fullscreenMode());</span>
<span class="line-added">511 </span>
<span class="line-added">512             if (targetVideoPresentationMode != HTMLVideoElement::VideoPresentationMode::PictureInPicture &amp;&amp; sourceVideoPresentationMode == HTMLVideoElement::VideoPresentationMode::PictureInPicture) {</span>
<span class="line-added">513                 m_pictureInPictureObserver-&gt;didExitPictureInPicture();</span>
<span class="line-added">514                 m_isFullscreen = false;</span>
<span class="line-added">515             }</span>
<span class="line-added">516         }</span>
<span class="line-added">517 #endif</span>
518     }
519 
520     if (player())
521         player()-&gt;setVideoFullscreenMode(mode);
522 
523     HTMLMediaElement::fullscreenModeChanged(mode);
524 }
525 
<span class="line-added">526 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added">527 void HTMLVideoElement::didBecomeFullscreenElement()</span>
<span class="line-added">528 {</span>
<span class="line-added">529     m_isFullscreen = true;</span>
<span class="line-added">530     m_waitingForPictureInPictureWindowFrame = true;</span>
<span class="line-added">531     HTMLMediaElement::didBecomeFullscreenElement();</span>
<span class="line-added">532 }</span>
<span class="line-added">533 </span>
<span class="line-added">534 void HTMLVideoElement::setPictureInPictureObserver(PictureInPictureObserver* observer)</span>
<span class="line-added">535 {</span>
<span class="line-added">536     m_pictureInPictureObserver = observer;</span>
<span class="line-added">537 }</span>
<span class="line-added">538 </span>
<span class="line-added">539 void HTMLVideoElement::setPictureInPictureAPITestEnabled(bool enabled)</span>
<span class="line-added">540 {</span>
<span class="line-added">541     m_pictureInPictureAPITestEnabled = enabled;</span>
<span class="line-added">542 }</span>
<span class="line-added">543 #endif</span>
<span class="line-added">544 </span>
<span class="line-added">545 #endif</span>
<span class="line-added">546 </span>
<span class="line-added">547 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))</span>
<span class="line-added">548 void HTMLVideoElement::setVideoFullscreenFrame(FloatRect frame)</span>
<span class="line-added">549 {</span>
<span class="line-added">550     HTMLMediaElement::setVideoFullscreenFrame(frame);</span>
<span class="line-added">551 </span>
<span class="line-added">552 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added">553     // fullscreenMode() does not always provide the correct fullscreen mode</span>
<span class="line-added">554     // when mode changing is happening (webkit.org/b/203443)</span>
<span class="line-added">555     if (!m_isFullscreen)</span>
<span class="line-added">556         return;</span>
<span class="line-added">557 </span>
<span class="line-added">558     if (toPresentationMode(fullscreenMode()) != VideoPresentationMode::PictureInPicture)</span>
<span class="line-added">559         return;</span>
<span class="line-added">560 </span>
<span class="line-added">561     if (m_waitingForPictureInPictureWindowFrame) {</span>
<span class="line-added">562         m_waitingForPictureInPictureWindowFrame = false;</span>
<span class="line-added">563         if (m_pictureInPictureObserver)</span>
<span class="line-added">564             m_pictureInPictureObserver-&gt;didEnterPictureInPicture(IntSize(frame.size()));</span>
<span class="line-added">565 </span>
<span class="line-added">566         return;</span>
<span class="line-added">567     }</span>
<span class="line-added">568 </span>
<span class="line-added">569     if (m_pictureInPictureObserver)</span>
<span class="line-added">570         m_pictureInPictureObserver-&gt;pictureInPictureWindowResized(IntSize(frame.size()));</span>
<span class="line-added">571 #endif</span>
<span class="line-added">572 }</span>
573 #endif
574 
575 #if PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE)
576 void HTMLVideoElement::exitToFullscreenModeWithoutAnimationIfPossible(HTMLMediaElementEnums::VideoFullscreenMode fromMode, HTMLMediaElementEnums::VideoFullscreenMode toMode)
577 {
578     if (document().page()-&gt;chrome().client().supportsVideoFullscreen(fromMode))
579         document().page()-&gt;chrome().client().exitVideoFullscreenToModeWithoutAnimation(*this, toMode);
580 }
581 #endif
582 
583 }
584 
585 #endif
</pre>
</td>
</tr>
</table>
<center><a href="HTMLTrackElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLVideoElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
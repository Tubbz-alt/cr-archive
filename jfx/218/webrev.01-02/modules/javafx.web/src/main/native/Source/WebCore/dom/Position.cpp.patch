diff a/modules/javafx.web/src/main/native/Source/WebCore/dom/Position.cpp b/modules/javafx.web/src/main/native/Source/WebCore/dom/Position.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/dom/Position.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/dom/Position.cpp
@@ -35,21 +35,21 @@
 #include "HTMLParserIdioms.h"
 #include "HTMLTableElement.h"
 #include "InlineElementBox.h"
 #include "InlineIterator.h"
 #include "InlineTextBox.h"
+#include "LineLayoutTraversal.h"
 #include "Logging.h"
 #include "NodeTraversal.h"
 #include "PositionIterator.h"
 #include "RenderBlock.h"
 #include "RenderFlexibleBox.h"
 #include "RenderGrid.h"
 #include "RenderInline.h"
 #include "RenderIterator.h"
 #include "RenderLineBreak.h"
 #include "RenderText.h"
-#include "RuntimeEnabledFeatures.h"
 #include "Text.h"
 #include "TextIterator.h"
 #include "VisiblePosition.h"
 #include "VisibleUnits.h"
 #include <stdio.h>
@@ -654,17 +654,10 @@
         return true;
 
     return pos.atStartOfNode();
 }
 
-static void ensureLineBoxesIfNeeded(RenderObject& renderer)
-{
-    if (!is<RenderText>(renderer) && !is<RenderLineBreak>(renderer))
-        return;
-    is<RenderText>(renderer) ? downcast<RenderText>(renderer).ensureLineBoxes() : downcast<RenderLineBreak>(renderer).ensureLineBoxes();
-}
-
 // This function and downstream() are used for moving back and forth between visually equivalent candidates.
 // For example, for the text node "foo     bar" where whitespace is collapsible, there are two candidates
 // that map to the VisiblePosition between 'b' and the space.  This function will return the left candidate
 // and downstream() will return the right one.
 // Also, upstream() will return [boundary, 0] for any of the positions from [boundary, 0] to the first candidate
@@ -706,11 +699,11 @@
 
         // skip position in unrendered or invisible node
         RenderObject* renderer = currentNode.renderer();
         if (!renderer || renderer->style().visibility() != Visibility::Visible)
             continue;
-        ensureLineBoxesIfNeeded(*renderer);
+
         if (rule == CanCrossEditingBoundary && boundaryCrossed) {
             lastVisible = currentPosition;
             break;
         }
 
@@ -731,56 +724,33 @@
         }
 
         // return current position if it is in rendered text
         if (is<RenderText>(*renderer)) {
             auto& textRenderer = downcast<RenderText>(*renderer);
-            if (!textRenderer.firstTextBox())
+
+            auto firstTextBox = LineLayoutTraversal::firstTextBoxInTextOrderFor(textRenderer);
+            if (!firstTextBox)
                 continue;
+
             if (&currentNode != startNode) {
                 // This assertion fires in layout tests in the case-transform.html test because
                 // of a mix-up between offsets in the text in the DOM tree with text in the
                 // render tree which can have a different length due to case transformation.
                 // Until we resolve that, disable this so we can run the layout tests!
                 //ASSERT(currentOffset >= renderer->caretMaxOffset());
                 return createLegacyEditingPosition(&currentNode, renderer->caretMaxOffset());
             }
 
             unsigned textOffset = currentPosition.offsetInLeafNode();
-            auto lastTextBox = textRenderer.lastTextBox();
-            for (auto* box = textRenderer.firstTextBox(); box; box = box->nextTextBox()) {
-                if (textOffset <= box->start() + box->len()) {
-                    if (textOffset > box->start())
+            for (auto box = firstTextBox; box; box.traverseNextInTextOrder()) {
+                if (textOffset <= box->localEndOffset()) {
+                    if (textOffset > box->localStartOffset())
                         return currentPosition;
                     continue;
                 }
 
-                if (box == lastTextBox || textOffset != box->start() + box->len() + 1)
-                    continue;
-
-                // The text continues on the next line only if the last text box is not on this line and
-                // none of the boxes on this line have a larger start offset.
-
-                bool continuesOnNextLine = true;
-                InlineBox* otherBox = box;
-                while (continuesOnNextLine) {
-                    otherBox = otherBox->nextLeafChild();
-                    if (!otherBox)
-                        break;
-                    if (otherBox == lastTextBox || (&otherBox->renderer() == &textRenderer && downcast<InlineTextBox>(*otherBox).start() > textOffset))
-                        continuesOnNextLine = false;
-                }
-
-                otherBox = box;
-                while (continuesOnNextLine) {
-                    otherBox = otherBox->prevLeafChild();
-                    if (!otherBox)
-                        break;
-                    if (otherBox == lastTextBox || (&otherBox->renderer() == &textRenderer && downcast<InlineTextBox>(*otherBox).start() > textOffset))
-                        continuesOnNextLine = false;
-                }
-
-                if (continuesOnNextLine)
+                if (textOffset == box->localEndOffset() + 1 && box->isLastOnLine() && !box->isLast())
                     return currentPosition;
             }
         }
     }
 
@@ -841,11 +811,11 @@
 
         // skip position in unrendered or invisible node
         auto* renderer = currentNode.renderer();
         if (!renderer || renderer->style().visibility() != Visibility::Visible)
             continue;
-        ensureLineBoxesIfNeeded(*renderer);
+
         if (rule == CanCrossEditingBoundary && boundaryCrossed) {
             lastVisible = currentPosition;
             break;
         }
 
@@ -861,52 +831,32 @@
         }
 
         // return current position if it is in rendered text
         if (is<RenderText>(*renderer)) {
             auto& textRenderer = downcast<RenderText>(*renderer);
-            if (!textRenderer.firstTextBox())
+
+            auto firstTextBox = LineLayoutTraversal::firstTextBoxInTextOrderFor(textRenderer);
+            if (!firstTextBox)
                 continue;
+
             if (&currentNode != startNode) {
                 ASSERT(currentPosition.atStartOfNode());
-                return createLegacyEditingPosition(&currentNode, renderer->caretMinOffset());
+                return createLegacyEditingPosition(&currentNode, textRenderer.caretMinOffset());
             }
 
             unsigned textOffset = currentPosition.offsetInLeafNode();
-            auto lastTextBox = textRenderer.lastTextBox();
-            for (auto* box = textRenderer.firstTextBox(); box; box = box->nextTextBox()) {
-                if (textOffset <= box->end()) {
-                    if (textOffset >= box->start())
-                        return currentPosition;
-                    continue;
-                }
+            for (auto box = firstTextBox; box; box.traverseNextInTextOrder()) {
+                if (!box->length() && textOffset == box->localStartOffset())
+                    return currentPosition;
 
-                if (box == lastTextBox || textOffset != box->start() + box->len())
+                if (textOffset < box->localEndOffset()) {
+                    if (textOffset >= box->localStartOffset())
+                        return currentPosition;
                     continue;
-
-                // The text continues on the next line only if the last text box is not on this line and
-                // none of the boxes on this line have a larger start offset.
-
-                bool continuesOnNextLine = true;
-                InlineBox* otherBox = box;
-                while (continuesOnNextLine) {
-                    otherBox = otherBox->nextLeafChild();
-                    if (!otherBox)
-                        break;
-                    if (otherBox == lastTextBox || (&otherBox->renderer() == &textRenderer && downcast<InlineTextBox>(*otherBox).start() >= textOffset))
-                        continuesOnNextLine = false;
-                }
-
-                otherBox = box;
-                while (continuesOnNextLine) {
-                    otherBox = otherBox->prevLeafChild();
-                    if (!otherBox)
-                        break;
-                    if (otherBox == lastTextBox || (&otherBox->renderer() == &textRenderer && downcast<InlineTextBox>(*otherBox).start() >= textOffset))
-                        continuesOnNextLine = false;
                 }
 
-                if (continuesOnNextLine)
+                if (textOffset == box->localEndOffset() && box->isLastOnLine() && !box->isLast())
                     return currentPosition;
             }
         }
     }
 
@@ -1278,11 +1228,11 @@
                 return;
             }
 
             if (((caretOffset == caretMaxOffset) ^ (affinity == DOWNSTREAM))
                 || ((caretOffset == caretMinOffset) ^ (affinity == UPSTREAM))
-                || (caretOffset == caretMaxOffset && box->nextLeafChild() && box->nextLeafChild()->isLineBreak()))
+                || (caretOffset == caretMaxOffset && box->nextLeafOnLine() && box->nextLeafOnLine()->isLineBreak()))
                 break;
 
             candidate = box;
         }
         if (candidate && candidate == textRenderer.lastTextBox() && affinity == DOWNSTREAM) {
@@ -1319,86 +1269,86 @@
 
     unsigned char level = inlineBox->bidiLevel();
 
     if (inlineBox->direction() == primaryDirection) {
         if (caretOffset == inlineBox->caretRightmostOffset()) {
-            InlineBox* nextBox = inlineBox->nextLeafChild();
+            InlineBox* nextBox = inlineBox->nextLeafOnLine();
             if (!nextBox || nextBox->bidiLevel() >= level)
                 return;
 
             level = nextBox->bidiLevel();
             InlineBox* prevBox = inlineBox;
             do {
-                prevBox = prevBox->prevLeafChild();
+                prevBox = prevBox->previousLeafOnLine();
             } while (prevBox && prevBox->bidiLevel() > level);
 
             if (prevBox && prevBox->bidiLevel() == level)   // For example, abc FED 123 ^ CBA
                 return;
 
             // For example, abc 123 ^ CBA
-            while (InlineBox* nextBox = inlineBox->nextLeafChild()) {
+            while (InlineBox* nextBox = inlineBox->nextLeafOnLine()) {
                 if (nextBox->bidiLevel() < level)
                     break;
                 inlineBox = nextBox;
             }
             caretOffset = inlineBox->caretRightmostOffset();
         } else {
-            InlineBox* prevBox = inlineBox->prevLeafChild();
+            InlineBox* prevBox = inlineBox->previousLeafOnLine();
             if (!prevBox || prevBox->bidiLevel() >= level)
                 return;
 
             level = prevBox->bidiLevel();
             InlineBox* nextBox = inlineBox;
             do {
-                nextBox = nextBox->nextLeafChild();
+                nextBox = nextBox->nextLeafOnLine();
             } while (nextBox && nextBox->bidiLevel() > level);
 
             if (nextBox && nextBox->bidiLevel() == level)
                 return;
 
-            while (InlineBox* prevBox = inlineBox->prevLeafChild()) {
+            while (InlineBox* prevBox = inlineBox->previousLeafOnLine()) {
                 if (prevBox->bidiLevel() < level)
                     break;
                 inlineBox = prevBox;
             }
             caretOffset = inlineBox->caretLeftmostOffset();
         }
         return;
     }
 
     if (caretOffset == inlineBox->caretLeftmostOffset()) {
-        InlineBox* prevBox = inlineBox->prevLeafChildIgnoringLineBreak();
+        InlineBox* prevBox = inlineBox->previousLeafOnLineIgnoringLineBreak();
         if (!prevBox || prevBox->bidiLevel() < level) {
             // Left edge of a secondary run. Set to the right edge of the entire run.
-            while (InlineBox* nextBox = inlineBox->nextLeafChildIgnoringLineBreak()) {
+            while (InlineBox* nextBox = inlineBox->nextLeafOnLineIgnoringLineBreak()) {
                 if (nextBox->bidiLevel() < level)
                     break;
                 inlineBox = nextBox;
             }
             caretOffset = inlineBox->caretRightmostOffset();
         } else if (prevBox->bidiLevel() > level) {
             // Right edge of a "tertiary" run. Set to the left edge of that run.
-            while (InlineBox* tertiaryBox = inlineBox->prevLeafChildIgnoringLineBreak()) {
+            while (InlineBox* tertiaryBox = inlineBox->previousLeafOnLineIgnoringLineBreak()) {
                 if (tertiaryBox->bidiLevel() <= level)
                     break;
                 inlineBox = tertiaryBox;
             }
             caretOffset = inlineBox->caretLeftmostOffset();
         }
     } else {
-        InlineBox* nextBox = inlineBox->nextLeafChildIgnoringLineBreak();
+        InlineBox* nextBox = inlineBox->nextLeafOnLineIgnoringLineBreak();
         if (!nextBox || nextBox->bidiLevel() < level) {
             // Right edge of a secondary run. Set to the left edge of the entire run.
-            while (InlineBox* prevBox = inlineBox->prevLeafChildIgnoringLineBreak()) {
+            while (InlineBox* prevBox = inlineBox->previousLeafOnLineIgnoringLineBreak()) {
                 if (prevBox->bidiLevel() < level)
                     break;
                 inlineBox = prevBox;
             }
             caretOffset = inlineBox->caretLeftmostOffset();
         } else if (nextBox->bidiLevel() > level) {
             // Left edge of a "tertiary" run. Set to the right edge of that run.
-            while (InlineBox* tertiaryBox = inlineBox->nextLeafChildIgnoringLineBreak()) {
+            while (InlineBox* tertiaryBox = inlineBox->nextLeafOnLineIgnoringLineBreak()) {
                 if (tertiaryBox->bidiLevel() <= level)
                     break;
                 inlineBox = tertiaryBox;
             }
             caretOffset = inlineBox->caretRightmostOffset();
@@ -1617,10 +1567,32 @@
     auto* nodeB = commonScope->ancestorNodeInThisScope(b.containerNode());
     ASSERT(nodeB);
     return Range::commonAncestorContainer(nodeA, nodeB);
 }
 
+Position positionInParentBeforeNode(Node* node)
+{
+    auto* ancestor = node->parentNode();
+    while (ancestor && editingIgnoresContent(*ancestor)) {
+        node = ancestor;
+        ancestor = ancestor->parentNode();
+    }
+    ASSERT(ancestor);
+    return Position(ancestor, node->computeNodeIndex(), Position::PositionIsOffsetInAnchor);
+}
+
+Position positionInParentAfterNode(Node* node)
+{
+    auto* ancestor = node->parentNode();
+    while (ancestor && editingIgnoresContent(*ancestor)) {
+        node = ancestor;
+        ancestor = ancestor->parentNode();
+    }
+    ASSERT(ancestor);
+    return Position(ancestor, node->computeNodeIndex() + 1, Position::PositionIsOffsetInAnchor);
+}
+
 } // namespace WebCore
 
 #if ENABLE(TREE_DEBUGGING)
 
 void showTree(const WebCore::Position& pos)

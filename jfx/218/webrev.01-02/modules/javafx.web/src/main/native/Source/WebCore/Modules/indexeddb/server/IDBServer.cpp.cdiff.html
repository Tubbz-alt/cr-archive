<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/IDBServer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IDBSerializationContext.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="IDBServer.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/IDBServer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 44,63 ***</span>
  #include &lt;wtf/MainThread.h&gt;
  
  namespace WebCore {
  namespace IDBServer {
  
<span class="line-modified">! Ref&lt;IDBServer&gt; IDBServer::create(PAL::SessionID sessionID, IDBBackingStoreTemporaryFileHandler&amp; fileHandler, QuotaManagerGetter&amp;&amp; quotaManagerGetter)</span>
  {
<span class="line-modified">!     return adoptRef(*new IDBServer(sessionID, fileHandler, WTFMove(quotaManagerGetter)));</span>
<span class="line-modified">! }</span>
<span class="line-removed">- </span>
<span class="line-removed">- Ref&lt;IDBServer&gt; IDBServer::create(PAL::SessionID sessionID, const String&amp; databaseDirectoryPath, IDBBackingStoreTemporaryFileHandler&amp; fileHandler, QuotaManagerGetter&amp;&amp; quotaManagerGetter)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return adoptRef(*new IDBServer(sessionID, databaseDirectoryPath, fileHandler, WTFMove(quotaManagerGetter)));</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! IDBServer::IDBServer(PAL::SessionID sessionID, IDBBackingStoreTemporaryFileHandler&amp; fileHandler, QuotaManagerGetter&amp;&amp; quotaManagerGetter)</span>
<span class="line-modified">!     : CrossThreadTaskHandler(&quot;IndexedDatabase Server&quot;, AutodrainedPoolForRunLoop::Use)</span>
<span class="line-removed">-     , m_sessionID(sessionID)</span>
<span class="line-removed">-     , m_backingStoreTemporaryFileHandler(fileHandler)</span>
<span class="line-removed">-     , m_quotaManagerGetter(WTFMove(quotaManagerGetter))</span>
<span class="line-removed">- {</span>
  }
  
<span class="line-modified">! IDBServer::IDBServer(PAL::SessionID sessionID, const String&amp; databaseDirectoryPath, IDBBackingStoreTemporaryFileHandler&amp; fileHandler, QuotaManagerGetter&amp;&amp; quotaManagerGetter)</span>
<span class="line-removed">-     : CrossThreadTaskHandler(&quot;IndexedDatabase Server&quot;, AutodrainedPoolForRunLoop::Use)</span>
<span class="line-removed">-     , m_sessionID(sessionID)</span>
<span class="line-removed">-     , m_databaseDirectoryPath(databaseDirectoryPath)</span>
<span class="line-removed">-     , m_backingStoreTemporaryFileHandler(fileHandler)</span>
<span class="line-removed">-     , m_quotaManagerGetter(WTFMove(quotaManagerGetter))</span>
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;IDBServer created at path %s&quot;, databaseDirectoryPath.utf8().data());</span>
<span class="line-removed">-     postDatabaseTask(createCrossThreadTask(*this, &amp;IDBServer::upgradeFilesIfNecessary));</span>
  }
  
  void IDBServer::registerConnection(IDBConnectionToClient&amp; connection)
  {
      ASSERT(!m_connectionMap.contains(connection.identifier()));
      m_connectionMap.set(connection.identifier(), &amp;connection);
  }
  
  void IDBServer::unregisterConnection(IDBConnectionToClient&amp; connection)
  {
      ASSERT(m_connectionMap.contains(connection.identifier()));
      ASSERT(m_connectionMap.get(connection.identifier()) == &amp;connection);
  
      connection.connectionToClientClosed();
  
      m_connectionMap.remove(connection.identifier());
  }
  
  void IDBServer::registerTransaction(UniqueIDBDatabaseTransaction&amp; transaction)
  {
      ASSERT(!m_transactions.contains(transaction.info().identifier()));
      m_transactions.set(transaction.info().identifier(), &amp;transaction);
  }
  
  void IDBServer::unregisterTransaction(UniqueIDBDatabaseTransaction&amp; transaction)
  {
      ASSERT(m_transactions.contains(transaction.info().identifier()));
      ASSERT(m_transactions.get(transaction.info().identifier()) == &amp;transaction);
  
      m_transactions.remove(transaction.info().identifier());
  }
<span class="line-new-header">--- 44,57 ---</span>
  #include &lt;wtf/MainThread.h&gt;
  
  namespace WebCore {
  namespace IDBServer {
  
<span class="line-modified">! IDBServer::IDBServer(PAL::SessionID sessionID, const String&amp; databaseDirectoryPath, StorageQuotaManagerSpaceRequester&amp;&amp; spaceRequester)</span>
<span class="line-added">+     : m_sessionID(sessionID)</span>
<span class="line-added">+     , m_spaceRequester(WTFMove(spaceRequester))</span>
  {
<span class="line-modified">!     ASSERT(!isMainThread());</span>
<span class="line-modified">!     ASSERT(databaseDirectoryPath.isSafeToSendToAnotherThread());</span>
  
<span class="line-modified">!     m_databaseDirectoryPath = databaseDirectoryPath;</span>
<span class="line-modified">!     upgradeFilesIfNecessary();</span>
  }
  
<span class="line-modified">! IDBServer::~IDBServer()</span>
  {
<span class="line-modified">!     ASSERT(!isMainThread());</span>
  }
  
  void IDBServer::registerConnection(IDBConnectionToClient&amp; connection)
  {
<span class="line-added">+     ASSERT(!isMainThread());</span>
      ASSERT(!m_connectionMap.contains(connection.identifier()));
      m_connectionMap.set(connection.identifier(), &amp;connection);
  }
  
  void IDBServer::unregisterConnection(IDBConnectionToClient&amp; connection)
  {
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
      ASSERT(m_connectionMap.contains(connection.identifier()));
      ASSERT(m_connectionMap.get(connection.identifier()) == &amp;connection);
  
      connection.connectionToClientClosed();
  
      m_connectionMap.remove(connection.identifier());
  }
  
  void IDBServer::registerTransaction(UniqueIDBDatabaseTransaction&amp; transaction)
  {
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
      ASSERT(!m_transactions.contains(transaction.info().identifier()));
      m_transactions.set(transaction.info().identifier(), &amp;transaction);
  }
  
  void IDBServer::unregisterTransaction(UniqueIDBDatabaseTransaction&amp; transaction)
  {
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
      ASSERT(m_transactions.contains(transaction.info().identifier()));
      ASSERT(m_transactions.get(transaction.info().identifier()) == &amp;transaction);
  
      m_transactions.remove(transaction.info().identifier());
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 117,11 ***</span>
      m_databaseConnections.remove(connection.identifier());
  }
  
  UniqueIDBDatabase&amp; IDBServer::getOrCreateUniqueIDBDatabase(const IDBDatabaseIdentifier&amp; identifier)
  {
<span class="line-modified">!     ASSERT(isMainThread());</span>
  
      auto uniqueIDBDatabase = m_uniqueIDBDatabaseMap.add(identifier, nullptr);
      if (uniqueIDBDatabase.isNewEntry)
          uniqueIDBDatabase.iterator-&gt;value = makeUnique&lt;UniqueIDBDatabase&gt;(*this, identifier);
  
<span class="line-new-header">--- 111,11 ---</span>
      m_databaseConnections.remove(connection.identifier());
  }
  
  UniqueIDBDatabase&amp; IDBServer::getOrCreateUniqueIDBDatabase(const IDBDatabaseIdentifier&amp; identifier)
  {
<span class="line-modified">!     ASSERT(!isMainThread());</span>
  
      auto uniqueIDBDatabase = m_uniqueIDBDatabaseMap.add(identifier, nullptr);
      if (uniqueIDBDatabase.isNewEntry)
          uniqueIDBDatabase.iterator-&gt;value = makeUnique&lt;UniqueIDBDatabase&gt;(*this, identifier);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 132,18 ***</span>
  {
      ASSERT(!isMainThread());
  
      auto databaseDirectoryPath = this-&gt;databaseDirectoryPathIsolatedCopy();
      if (databaseDirectoryPath.isEmpty())
<span class="line-modified">!         return MemoryIDBBackingStore::create(m_sessionID, identifier);</span>
  
<span class="line-modified">!     return makeUnique&lt;SQLiteIDBBackingStore&gt;(m_sessionID, identifier, databaseDirectoryPath, m_backingStoreTemporaryFileHandler);</span>
  }
  
  void IDBServer::openDatabase(const IDBRequestData&amp; requestData)
  {
      LOG(IndexedDB, &quot;IDBServer::openDatabase&quot;);
  
      auto&amp; uniqueIDBDatabase = getOrCreateUniqueIDBDatabase(requestData.databaseIdentifier());
  
      auto connection = m_connectionMap.get(requestData.requestIdentifier().connectionIdentifier());
      if (!connection) {
<span class="line-new-header">--- 126,20 ---</span>
  {
      ASSERT(!isMainThread());
  
      auto databaseDirectoryPath = this-&gt;databaseDirectoryPathIsolatedCopy();
      if (databaseDirectoryPath.isEmpty())
<span class="line-modified">!         return makeUnique&lt;MemoryIDBBackingStore&gt;(m_sessionID, identifier);</span>
  
<span class="line-modified">!     return makeUnique&lt;SQLiteIDBBackingStore&gt;(m_sessionID, identifier, databaseDirectoryPath);</span>
  }
  
  void IDBServer::openDatabase(const IDBRequestData&amp; requestData)
  {
      LOG(IndexedDB, &quot;IDBServer::openDatabase&quot;);
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      auto&amp; uniqueIDBDatabase = getOrCreateUniqueIDBDatabase(requestData.databaseIdentifier());
  
      auto connection = m_connectionMap.get(requestData.requestIdentifier().connectionIdentifier());
      if (!connection) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 155,12 ***</span>
      uniqueIDBDatabase.openDatabaseConnection(*connection, requestData);
  }
  
  void IDBServer::deleteDatabase(const IDBRequestData&amp; requestData)
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;IDBServer::deleteDatabase - %s&quot;, requestData.databaseIdentifier().debugString().utf8().data());</span>
<span class="line-modified">!     ASSERT(isMainThread());</span>
  
      auto connection = m_connectionMap.get(requestData.requestIdentifier().connectionIdentifier());
      if (!connection) {
          // If the connection back to the client is gone, there&#39;s no way to delete the database as
          // well as no way to message back failure.
<span class="line-new-header">--- 151,13 ---</span>
      uniqueIDBDatabase.openDatabaseConnection(*connection, requestData);
  }
  
  void IDBServer::deleteDatabase(const IDBRequestData&amp; requestData)
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;IDBServer::deleteDatabase - %s&quot;, requestData.databaseIdentifier().loggingString().utf8().data());</span>
<span class="line-modified">!     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      auto connection = m_connectionMap.get(requestData.requestIdentifier().connectionIdentifier());
      if (!connection) {
          // If the connection back to the client is gone, there&#39;s no way to delete the database as
          // well as no way to message back failure.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 186,10 ***</span>
<span class="line-new-header">--- 183,12 ---</span>
  }
  
  void IDBServer::abortTransaction(const IDBResourceIdentifier&amp; transactionIdentifier)
  {
      LOG(IndexedDB, &quot;IDBServer::abortTransaction&quot;);
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      auto transaction = m_transactions.get(transactionIdentifier);
      if (!transaction) {
          // If there is no transaction there is nothing to abort.
          // We also have no access to a connection over which to message failure-to-abort.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 200,10 ***</span>
<span class="line-new-header">--- 199,12 ---</span>
  }
  
  void IDBServer::createObjectStore(const IDBRequestData&amp; requestData, const IDBObjectStoreInfo&amp; info)
  {
      LOG(IndexedDB, &quot;IDBServer::createObjectStore&quot;);
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      auto transaction = m_transactions.get(requestData.transactionIdentifier());
      if (!transaction)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 212,10 ***</span>
<span class="line-new-header">--- 213,12 ---</span>
  }
  
  void IDBServer::deleteObjectStore(const IDBRequestData&amp; requestData, const String&amp; objectStoreName)
  {
      LOG(IndexedDB, &quot;IDBServer::deleteObjectStore&quot;);
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      auto transaction = m_transactions.get(requestData.transactionIdentifier());
      if (!transaction)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 224,10 ***</span>
<span class="line-new-header">--- 227,12 ---</span>
  }
  
  void IDBServer::renameObjectStore(const IDBRequestData&amp; requestData, uint64_t objectStoreIdentifier, const String&amp; newName)
  {
      LOG(IndexedDB, &quot;IDBServer::renameObjectStore&quot;);
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      auto transaction = m_transactions.get(requestData.transactionIdentifier());
      if (!transaction)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 236,10 ***</span>
<span class="line-new-header">--- 241,12 ---</span>
  }
  
  void IDBServer::clearObjectStore(const IDBRequestData&amp; requestData, uint64_t objectStoreIdentifier)
  {
      LOG(IndexedDB, &quot;IDBServer::clearObjectStore&quot;);
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      auto transaction = m_transactions.get(requestData.transactionIdentifier());
      if (!transaction)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 247,10 ***</span>
<span class="line-new-header">--- 254,12 ---</span>
  }
  
  void IDBServer::createIndex(const IDBRequestData&amp; requestData, const IDBIndexInfo&amp; info)
  {
      LOG(IndexedDB, &quot;IDBServer::createIndex&quot;);
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      auto transaction = m_transactions.get(requestData.transactionIdentifier());
      if (!transaction)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 259,10 ***</span>
<span class="line-new-header">--- 268,12 ---</span>
  }
  
  void IDBServer::deleteIndex(const IDBRequestData&amp; requestData, uint64_t objectStoreIdentifier, const String&amp; indexName)
  {
      LOG(IndexedDB, &quot;IDBServer::deleteIndex&quot;);
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      auto transaction = m_transactions.get(requestData.transactionIdentifier());
      if (!transaction)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 271,10 ***</span>
<span class="line-new-header">--- 282,12 ---</span>
  }
  
  void IDBServer::renameIndex(const IDBRequestData&amp; requestData, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
  {
      LOG(IndexedDB, &quot;IDBServer::renameIndex&quot;);
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      auto transaction = m_transactions.get(requestData.transactionIdentifier());
      if (!transaction)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 283,10 ***</span>
<span class="line-new-header">--- 296,12 ---</span>
  }
  
  void IDBServer::putOrAdd(const IDBRequestData&amp; requestData, const IDBKeyData&amp; keyData, const IDBValue&amp; value, IndexedDB::ObjectStoreOverwriteMode overwriteMode)
  {
      LOG(IndexedDB, &quot;IDBServer::putOrAdd&quot;);
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      auto transaction = m_transactions.get(requestData.transactionIdentifier());
      if (!transaction)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 294,10 ***</span>
<span class="line-new-header">--- 309,12 ---</span>
  }
  
  void IDBServer::getRecord(const IDBRequestData&amp; requestData, const IDBGetRecordData&amp; getRecordData)
  {
      LOG(IndexedDB, &quot;IDBServer::getRecord&quot;);
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      auto transaction = m_transactions.get(requestData.transactionIdentifier());
      if (!transaction)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 305,10 ***</span>
<span class="line-new-header">--- 322,12 ---</span>
  }
  
  void IDBServer::getAllRecords(const IDBRequestData&amp; requestData, const IDBGetAllRecordsData&amp; getAllRecordsData)
  {
      LOG(IndexedDB, &quot;IDBServer::getAllRecords&quot;);
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      auto transaction = m_transactions.get(requestData.transactionIdentifier());
      if (!transaction)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 316,10 ***</span>
<span class="line-new-header">--- 335,12 ---</span>
  }
  
  void IDBServer::getCount(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData)
  {
      LOG(IndexedDB, &quot;IDBServer::getCount&quot;);
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      auto transaction = m_transactions.get(requestData.transactionIdentifier());
      if (!transaction)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 327,10 ***</span>
<span class="line-new-header">--- 348,12 ---</span>
  }
  
  void IDBServer::deleteRecord(const IDBRequestData&amp; requestData, const IDBKeyRangeData&amp; keyRangeData)
  {
      LOG(IndexedDB, &quot;IDBServer::deleteRecord&quot;);
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      auto transaction = m_transactions.get(requestData.transactionIdentifier());
      if (!transaction)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 338,10 ***</span>
<span class="line-new-header">--- 361,12 ---</span>
  }
  
  void IDBServer::openCursor(const IDBRequestData&amp; requestData, const IDBCursorInfo&amp; info)
  {
      LOG(IndexedDB, &quot;IDBServer::openCursor&quot;);
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      auto transaction = m_transactions.get(requestData.transactionIdentifier());
      if (!transaction)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 349,10 ***</span>
<span class="line-new-header">--- 374,12 ---</span>
  }
  
  void IDBServer::iterateCursor(const IDBRequestData&amp; requestData, const IDBIterateCursorData&amp; data)
  {
      LOG(IndexedDB, &quot;IDBServer::iterateCursor&quot;);
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      auto transaction = m_transactions.get(requestData.transactionIdentifier());
      if (!transaction)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 360,10 ***</span>
<span class="line-new-header">--- 387,12 ---</span>
  }
  
  void IDBServer::establishTransaction(uint64_t databaseConnectionIdentifier, const IDBTransactionInfo&amp; info)
  {
      LOG(IndexedDB, &quot;IDBServer::establishTransaction&quot;);
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier);
      if (!databaseConnection)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 371,10 ***</span>
<span class="line-new-header">--- 400,12 ---</span>
  }
  
  void IDBServer::commitTransaction(const IDBResourceIdentifier&amp; transactionIdentifier)
  {
      LOG(IndexedDB, &quot;IDBServer::commitTransaction&quot;);
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      auto transaction = m_transactions.get(transactionIdentifier);
      if (!transaction) {
          // If there is no transaction there is nothing to commit.
          // We also have no access to a connection over which to message failure-to-commit.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 385,10 ***</span>
<span class="line-new-header">--- 416,12 ---</span>
  }
  
  void IDBServer::didFinishHandlingVersionChangeTransaction(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier)
  {
      LOG(IndexedDB, &quot;IDBServer::didFinishHandlingVersionChangeTransaction - %s&quot;, transactionIdentifier.loggingString().utf8().data());
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      auto* connection = m_databaseConnections.get(databaseConnectionIdentifier);
      if (!connection)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 396,10 ***</span>
<span class="line-new-header">--- 429,12 ---</span>
  }
  
  void IDBServer::databaseConnectionPendingClose(uint64_t databaseConnectionIdentifier)
  {
      LOG(IndexedDB, &quot;IDBServer::databaseConnectionPendingClose - %&quot; PRIu64, databaseConnectionIdentifier);
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier);
      if (!databaseConnection)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 407,10 ***</span>
<span class="line-new-header">--- 442,12 ---</span>
  }
  
  void IDBServer::databaseConnectionClosed(uint64_t databaseConnectionIdentifier)
  {
      LOG(IndexedDB, &quot;IDBServer::databaseConnectionClosed - %&quot; PRIu64, databaseConnectionIdentifier);
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier);
      if (!databaseConnection)
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 418,10 ***</span>
<span class="line-new-header">--- 455,12 ---</span>
  }
  
  void IDBServer::abortOpenAndUpgradeNeeded(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier)
  {
      LOG(IndexedDB, &quot;IDBServer::abortOpenAndUpgradeNeeded&quot;);
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      auto transaction = m_transactions.get(transactionIdentifier);
      if (transaction)
          transaction-&gt;abortWithoutCallback();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 430,45 ***</span>
          return;
  
      databaseConnection-&gt;connectionClosedFromClient();
  }
  
<span class="line-modified">! void IDBServer::didFireVersionChangeEvent(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier&amp; requestIdentifier)</span>
  {
      LOG(IndexedDB, &quot;IDBServer::didFireVersionChangeEvent&quot;);
  
      if (auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier))
<span class="line-modified">!         databaseConnection-&gt;didFireVersionChangeEvent(requestIdentifier);</span>
  }
  
  void IDBServer::openDBRequestCancelled(const IDBRequestData&amp; requestData)
  {
      LOG(IndexedDB, &quot;IDBServer::openDBRequestCancelled&quot;);
<span class="line-modified">!     ASSERT(isMainThread());</span>
  
      auto* uniqueIDBDatabase = m_uniqueIDBDatabaseMap.get(requestData.databaseIdentifier());
      if (!uniqueIDBDatabase)
          return;
  
      uniqueIDBDatabase-&gt;openDBRequestCancelled(requestData.requestIdentifier());
  }
  
<span class="line-modified">! void IDBServer::confirmDidCloseFromServer(uint64_t databaseConnectionIdentifier)</span>
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;IDBServer::confirmDidCloseFromServer&quot;);</span>
<span class="line-modified">! </span>
<span class="line-removed">-     if (auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier))</span>
<span class="line-removed">-         databaseConnection-&gt;confirmDidCloseFromServer();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void IDBServer::getAllDatabaseNames(uint64_t serverConnectionIdentifier, const SecurityOriginData&amp; mainFrameOrigin, const SecurityOriginData&amp; openingOrigin, uint64_t callbackID)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     postDatabaseTask(createCrossThreadTask(*this, &amp;IDBServer::performGetAllDatabaseNames, serverConnectionIdentifier, mainFrameOrigin, openingOrigin, callbackID));</span>
<span class="line-removed">- }</span>
  
<span class="line-removed">- void IDBServer::performGetAllDatabaseNames(uint64_t serverConnectionIdentifier, const SecurityOriginData&amp; mainFrameOrigin, const SecurityOriginData&amp; openingOrigin, uint64_t callbackID)</span>
<span class="line-removed">- {</span>
      auto databaseDirectoryPath = this-&gt;databaseDirectoryPathIsolatedCopy();
      String oldDirectory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(mainFrameOrigin, openingOrigin, databaseDirectoryPath, &quot;v0&quot;);
      Vector&lt;String&gt; files = FileSystem::listDirectory(oldDirectory, &quot;*&quot;_s);
      Vector&lt;String&gt; databases;
      for (auto&amp; file : files) {
<span class="line-new-header">--- 469,38 ---</span>
          return;
  
      databaseConnection-&gt;connectionClosedFromClient();
  }
  
<span class="line-modified">! void IDBServer::didFireVersionChangeEvent(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier&amp; requestIdentifier, IndexedDB::ConnectionClosedOnBehalfOfServer connectionClosed)</span>
  {
      LOG(IndexedDB, &quot;IDBServer::didFireVersionChangeEvent&quot;);
<span class="line-added">+     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      if (auto databaseConnection = m_databaseConnections.get(databaseConnectionIdentifier))
<span class="line-modified">!         databaseConnection-&gt;didFireVersionChangeEvent(requestIdentifier, connectionClosed);</span>
  }
  
  void IDBServer::openDBRequestCancelled(const IDBRequestData&amp; requestData)
  {
      LOG(IndexedDB, &quot;IDBServer::openDBRequestCancelled&quot;);
<span class="line-modified">!     ASSERT(!isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
      auto* uniqueIDBDatabase = m_uniqueIDBDatabaseMap.get(requestData.databaseIdentifier());
      if (!uniqueIDBDatabase)
          return;
  
      uniqueIDBDatabase-&gt;openDBRequestCancelled(requestData.requestIdentifier());
  }
  
<span class="line-modified">! void IDBServer::getAllDatabaseNames(IDBConnectionIdentifier serverConnectionIdentifier, const SecurityOriginData&amp; mainFrameOrigin, const SecurityOriginData&amp; openingOrigin, uint64_t callbackID)</span>
  {
<span class="line-modified">!     ASSERT(!isMainThread());</span>
<span class="line-modified">!     ASSERT(m_lock.isHeld());</span>
  
      auto databaseDirectoryPath = this-&gt;databaseDirectoryPathIsolatedCopy();
      String oldDirectory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(mainFrameOrigin, openingOrigin, databaseDirectoryPath, &quot;v0&quot;);
      Vector&lt;String&gt; files = FileSystem::listDirectory(oldDirectory, &quot;*&quot;_s);
      Vector&lt;String&gt; databases;
      for (auto&amp; file : files) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 482,66 ***</span>
          auto databaseName = SQLiteIDBBackingStore::databaseNameFromFile(SQLiteIDBBackingStore::fullDatabasePathForDirectory(file));
          if (!databaseName.isEmpty())
              databases.append(databaseName);
      }
  
<span class="line-removed">-     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;IDBServer::didGetAllDatabaseNames, serverConnectionIdentifier, callbackID, databases));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void IDBServer::didGetAllDatabaseNames(uint64_t serverConnectionIdentifier, uint64_t callbackID, const Vector&lt;String&gt;&amp; databaseNames)</span>
<span class="line-removed">- {</span>
      auto connection = m_connectionMap.get(serverConnectionIdentifier);
      if (!connection)
          return;
  
<span class="line-modified">!     connection-&gt;didGetAllDatabaseNames(callbackID, databaseNames);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void IDBServer::postDatabaseTask(CrossThreadTask&amp;&amp; task)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     postTask(WTFMove(task));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void IDBServer::postDatabaseTaskReply(CrossThreadTask&amp;&amp; task)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     postTaskReply(WTFMove(task));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static uint64_t generateDeleteCallbackID()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isMainThread());</span>
<span class="line-removed">-     static uint64_t currentID = 0;</span>
<span class="line-removed">-     return ++currentID;</span>
  }
  
<span class="line-modified">! void IDBServer::closeAndDeleteDatabasesModifiedSince(WallTime modificationTime, Function&lt;void ()&gt;&amp;&amp; completionHandler)</span>
  {
<span class="line-modified">!     uint64_t callbackID = generateDeleteCallbackID();</span>
<span class="line-modified">!     auto addResult = m_deleteDatabaseCompletionHandlers.add(callbackID, WTFMove(completionHandler));</span>
<span class="line-removed">-     ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
  
      // If the modification time is in the future, don&#39;t both doing anything.
<span class="line-modified">!     if (modificationTime &gt; WallTime::now()) {</span>
<span class="line-removed">-         postDatabaseTaskReply(createCrossThreadTask(*this, &amp;IDBServer::didPerformCloseAndDeleteDatabases, callbackID));</span>
          return;
<span class="line-removed">-     }</span>
  
      HashSet&lt;UniqueIDBDatabase*&gt; openDatabases;
      for (auto&amp; database : m_uniqueIDBDatabaseMap.values())
<span class="line-removed">-         openDatabases.add(database.get());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     for (auto&amp; database : openDatabases)</span>
          database-&gt;immediateCloseForUserDelete();
  
<span class="line-modified">!     postDatabaseTask(createCrossThreadTask(*this, &amp;IDBServer::performCloseAndDeleteDatabasesModifiedSince, modificationTime, callbackID));</span>
  }
  
<span class="line-modified">! void IDBServer::closeAndDeleteDatabasesForOrigins(const Vector&lt;SecurityOriginData&gt;&amp; origins, Function&lt;void ()&gt;&amp;&amp; completionHandler)</span>
  {
<span class="line-modified">!     uint64_t callbackID = generateDeleteCallbackID();</span>
<span class="line-modified">!     auto addResult = m_deleteDatabaseCompletionHandlers.add(callbackID, WTFMove(completionHandler));</span>
<span class="line-removed">-     ASSERT_UNUSED(addResult, addResult.isNewEntry);</span>
  
      HashSet&lt;UniqueIDBDatabase*&gt; openDatabases;
      for (auto&amp; database : m_uniqueIDBDatabaseMap.values()) {
          const auto&amp; identifier = database-&gt;identifier();
          for (auto&amp; origin : origins) {
<span class="line-new-header">--- 514,42 ---</span>
          auto databaseName = SQLiteIDBBackingStore::databaseNameFromFile(SQLiteIDBBackingStore::fullDatabasePathForDirectory(file));
          if (!databaseName.isEmpty())
              databases.append(databaseName);
      }
  
      auto connection = m_connectionMap.get(serverConnectionIdentifier);
      if (!connection)
          return;
  
<span class="line-modified">!     connection-&gt;didGetAllDatabaseNames(callbackID, databases);</span>
  }
  
<span class="line-modified">! void IDBServer::closeAndDeleteDatabasesModifiedSince(WallTime modificationTime)</span>
  {
<span class="line-modified">!     ASSERT(!isMainThread());</span>
<span class="line-modified">!     ASSERT(m_lock.isHeld());</span>
  
      // If the modification time is in the future, don&#39;t both doing anything.
<span class="line-modified">!     if (modificationTime &gt; WallTime::now())</span>
          return;
  
      HashSet&lt;UniqueIDBDatabase*&gt; openDatabases;
      for (auto&amp; database : m_uniqueIDBDatabaseMap.values())
          database-&gt;immediateCloseForUserDelete();
  
<span class="line-modified">!     m_uniqueIDBDatabaseMap.clear();</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!m_databaseDirectoryPath.isEmpty()) {</span>
<span class="line-added">+         removeDatabasesModifiedSinceForVersion(modificationTime, &quot;v0&quot;);</span>
<span class="line-added">+         removeDatabasesModifiedSinceForVersion(modificationTime, &quot;v1&quot;);</span>
<span class="line-added">+     }</span>
  }
  
<span class="line-modified">! void IDBServer::closeAndDeleteDatabasesForOrigins(const Vector&lt;SecurityOriginData&gt;&amp; origins)</span>
  {
<span class="line-modified">!     ASSERT(!isMainThread());</span>
<span class="line-modified">!     ASSERT(m_lock.isHeld());</span>
  
      HashSet&lt;UniqueIDBDatabase*&gt; openDatabases;
      for (auto&amp; database : m_uniqueIDBDatabaseMap.values()) {
          const auto&amp; identifier = database-&gt;identifier();
          for (auto&amp; origin : origins) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 550,14 ***</span>
                  break;
              }
          }
      }
  
<span class="line-modified">!     for (auto&amp; database : openDatabases)</span>
          database-&gt;immediateCloseForUserDelete();
  
<span class="line-modified">!     postDatabaseTask(createCrossThreadTask(*this, &amp;IDBServer::performCloseAndDeleteDatabasesForOrigins, origins, callbackID));</span>
  }
  
  static void removeAllDatabasesForFullOriginPath(const String&amp; originPath, WallTime modifiedSince)
  {
      LOG(IndexedDB, &quot;removeAllDatabasesForOriginPath with originPath %s&quot;, originPath.utf8().data());
<span class="line-new-header">--- 558,19 ---</span>
                  break;
              }
          }
      }
  
<span class="line-modified">!     for (auto&amp; database : openDatabases) {</span>
          database-&gt;immediateCloseForUserDelete();
<span class="line-added">+         m_uniqueIDBDatabaseMap.remove(database-&gt;identifier());</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     if (!m_databaseDirectoryPath.isEmpty()) {</span>
<span class="line-added">+         removeDatabasesWithOriginsForVersion(origins, &quot;v0&quot;);</span>
<span class="line-added">+         removeDatabasesWithOriginsForVersion(origins, &quot;v1&quot;);</span>
<span class="line-added">+     }</span>
  }
  
  static void removeAllDatabasesForFullOriginPath(const String&amp; originPath, WallTime modifiedSince)
  {
      LOG(IndexedDB, &quot;removeAllDatabasesForOriginPath with originPath %s&quot;, originPath.utf8().data());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 647,20 ***</span>
          if (auto securityOrigin = SecurityOriginData::fromDatabaseIdentifier(databaseIdentifier))
              removeAllDatabasesForOriginPath(originPath, modifiedSince);
      }
  }
  
<span class="line-removed">- void IDBServer::performCloseAndDeleteDatabasesModifiedSince(WallTime modifiedSince, uint64_t callbackID)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!databaseDirectoryPathIsolatedCopy().isEmpty()) {</span>
<span class="line-removed">-         removeDatabasesModifiedSinceForVersion(modifiedSince, &quot;v0&quot;);</span>
<span class="line-removed">-         removeDatabasesModifiedSinceForVersion(modifiedSince, &quot;v1&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;IDBServer::didPerformCloseAndDeleteDatabases, callbackID));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void IDBServer::removeDatabasesWithOriginsForVersion(const Vector&lt;SecurityOriginData&gt; &amp;origins, const String&amp; version)
  {
      String versionPath = FileSystem::pathByAppendingComponent(databaseDirectoryPathIsolatedCopy(), version);
      for (const auto&amp; origin : origins) {
          String originPath = FileSystem::pathByAppendingComponent(versionPath, origin.databaseIdentifier());
<span class="line-new-header">--- 660,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 671,169 ***</span>
              removeAllDatabasesForOriginPath(originPath, -WallTime::infinity());
          }
      }
  }
  
<span class="line-modified">! void IDBServer::performCloseAndDeleteDatabasesForOrigins(const Vector&lt;SecurityOriginData&gt;&amp; origins, uint64_t callbackID)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!databaseDirectoryPathIsolatedCopy().isEmpty()) {</span>
<span class="line-removed">-         removeDatabasesWithOriginsForVersion(origins, &quot;v0&quot;);</span>
<span class="line-removed">-         removeDatabasesWithOriginsForVersion(origins, &quot;v1&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;IDBServer::didPerformCloseAndDeleteDatabases, callbackID));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void IDBServer::didPerformCloseAndDeleteDatabases(uint64_t callbackID)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     for (auto&amp; user : m_quotaUsers.values())</span>
<span class="line-removed">-         user-&gt;resetSpaceUsed();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     auto callback = m_deleteDatabaseCompletionHandlers.take(callbackID);</span>
<span class="line-removed">-     ASSERT(callback);</span>
<span class="line-removed">-     callback();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- IDBServer::QuotaUser::QuotaUser(IDBServer&amp; server, StorageQuotaManager* manager, ClientOrigin&amp;&amp; origin)</span>
<span class="line-removed">-     : m_server(server)</span>
<span class="line-removed">-     , m_manager(makeWeakPtr(manager))</span>
<span class="line-removed">-     , m_origin(WTFMove(origin))</span>
<span class="line-removed">-     , m_isInitialized(m_server.m_sessionID.isEphemeral())</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (manager)</span>
<span class="line-removed">-         manager-&gt;addUser(*this);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- IDBServer::QuotaUser::~QuotaUser()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (m_manager)</span>
<span class="line-removed">-         m_manager-&gt;removeUser(*this);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void IDBServer::QuotaUser::resetSpaceUsed()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_spaceUsed = 0;</span>
<span class="line-removed">-     m_estimatedSpaceIncrease = 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!m_manager)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (m_server.m_sessionID.isEphemeral())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!m_isInitialized)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ASSERT(!m_initializationCallback);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_isInitialized = false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Do add/remove to trigger call to whenInitialized.</span>
<span class="line-removed">-     m_manager-&gt;removeUser(*this);</span>
<span class="line-removed">-     m_manager-&gt;addUser(*this);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void IDBServer::QuotaUser::increaseSpaceUsed(uint64_t size)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!m_isInitialized)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     ASSERT(m_spaceUsed + size &gt; m_spaceUsed);</span>
<span class="line-removed">-     m_spaceUsed += size;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- void IDBServer::QuotaUser::decreaseSpaceUsed(uint64_t size)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (!m_isInitialized)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     ASSERT(m_spaceUsed &gt;= size);</span>
<span class="line-removed">-     m_spaceUsed -= size;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void IDBServer::QuotaUser::whenInitialized(CompletionHandler&lt;void()&gt;&amp;&amp; callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (m_isInitialized) {</span>
<span class="line-removed">-         callback();</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     m_initializationCallback = WTFMove(callback);</span>
<span class="line-removed">-     m_server.startComputingSpaceUsedForOrigin(m_origin);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void IDBServer::QuotaUser::initializeSpaceUsed(uint64_t spaceUsed)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(m_isInitialized || !m_estimatedSpaceIncrease);</span>
<span class="line-removed">-     m_spaceUsed = spaceUsed;</span>
<span class="line-removed">-     m_isInitialized = true;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (auto callback = WTFMove(m_initializationCallback))</span>
<span class="line-removed">-         callback();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- IDBServer::QuotaUser&amp; IDBServer::ensureQuotaUser(const ClientOrigin&amp; origin)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return *m_quotaUsers.ensure(origin, [this, &amp;origin] {</span>
<span class="line-removed">-         return makeUnique&lt;QuotaUser&gt;(*this, m_quotaManagerGetter(m_sessionID, origin), ClientOrigin { origin });</span>
<span class="line-removed">-     }).iterator-&gt;value;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void IDBServer::startComputingSpaceUsedForOrigin(const ClientOrigin&amp; origin)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(!m_sessionID.isEphemeral());</span>
<span class="line-removed">-     postDatabaseTask(createCrossThreadTask(*this, &amp;IDBServer::computeSpaceUsedForOrigin, origin));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void IDBServer::computeSpaceUsedForOrigin(const ClientOrigin&amp; origin)</span>
  {
      ASSERT(!isMainThread());
  
<span class="line-modified">!     auto databaseDirectoryPath = this-&gt;databaseDirectoryPathIsolatedCopy();</span>
<span class="line-removed">-     auto oldVersionOriginDirectory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(origin.topOrigin, origin.clientOrigin, databaseDirectoryPath, &quot;v0&quot;);</span>
<span class="line-removed">-     auto newVersionOriginDirectory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(origin.topOrigin, origin.clientOrigin, databaseDirectoryPath, &quot;v1&quot;);</span>
<span class="line-removed">-     auto size = SQLiteIDBBackingStore::databasesSizeForDirectory(oldVersionOriginDirectory) + SQLiteIDBBackingStore::databasesSizeForDirectory(newVersionOriginDirectory);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     postDatabaseTaskReply(createCrossThreadTask(*this, &amp;IDBServer::finishComputingSpaceUsedForOrigin, origin, size));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void IDBServer::finishComputingSpaceUsedForOrigin(const ClientOrigin&amp; origin, uint64_t spaceUsed)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ensureQuotaUser(origin).initializeSpaceUsed(spaceUsed);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void IDBServer::requestSpace(const ClientOrigin&amp; origin, uint64_t taskSize, CompletionHandler&lt;void(StorageQuotaManager::Decision)&gt;&amp;&amp; callback)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     auto* quotaManager = ensureQuotaUser(origin).manager();</span>
<span class="line-removed">-     if (!quotaManager) {</span>
<span class="line-removed">-         callback(StorageQuotaManager::Decision::Deny);</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     quotaManager-&gt;requestSpace(taskSize, WTFMove(callback));</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! void IDBServer::resetSpaceUsed(const ClientOrigin&amp; origin)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (auto* user = m_quotaUsers.get(origin))</span>
<span class="line-removed">-         user-&gt;resetSpaceUsed();</span>
  }
  
<span class="line-modified">! void IDBServer::increaseSpaceUsed(const ClientOrigin&amp; origin, uint64_t size)</span>
  {
<span class="line-modified">!     ensureQuotaUser(origin).increaseSpaceUsed(size);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void IDBServer::decreaseSpaceUsed(const ClientOrigin&amp; origin, uint64_t size)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ensureQuotaUser(origin).decreaseSpaceUsed(size);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void IDBServer::increasePotentialSpaceUsed(const ClientOrigin&amp; origin, uint64_t taskSize)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ensureQuotaUser(origin).increasePotentialSpaceUsed(taskSize);</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! void IDBServer::decreasePotentialSpaceUsed(const ClientOrigin&amp; origin, uint64_t spaceUsed)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     ensureQuotaUser(origin).decreasePotentialSpaceUsed(spaceUsed);</span>
  }
  
  void IDBServer::upgradeFilesIfNecessary()
  {
      auto databaseDirectoryPath = this-&gt;databaseDirectoryPathIsolatedCopy();
<span class="line-new-header">--- 674,32 ---</span>
              removeAllDatabasesForOriginPath(originPath, -WallTime::infinity());
          }
      }
  }
  
<span class="line-modified">! StorageQuotaManager::Decision IDBServer::requestSpace(const ClientOrigin&amp; origin, uint64_t taskSize)</span>
  {
      ASSERT(!isMainThread());
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
  
<span class="line-modified">!     StorageQuotaManager::Decision result = StorageQuotaManager::Decision::Deny;</span>
  
<span class="line-modified">!     // Release lock because space requesting could be blocked.</span>
<span class="line-modified">!     m_lock.unlock();</span>
<span class="line-added">+     result = m_spaceRequester(origin, taskSize);</span>
<span class="line-added">+     m_lock.lock();</span>
  
<span class="line-modified">!     return result;</span>
  }
  
<span class="line-modified">! uint64_t IDBServer::diskUsage(const String&amp; rootDirectory, const ClientOrigin&amp; origin)</span>
  {
<span class="line-modified">!     ASSERT(!isMainThread());</span>
  
<span class="line-modified">!     auto oldVersionOriginDirectory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(origin.topOrigin, origin.clientOrigin, rootDirectory, &quot;v0&quot;_str);</span>
<span class="line-modified">!     auto newVersionOriginDirectory = IDBDatabaseIdentifier::databaseDirectoryRelativeToRoot(origin.topOrigin, origin.clientOrigin, rootDirectory, &quot;v1&quot;_str);</span>
<span class="line-modified">!     return SQLiteIDBBackingStore::databasesSizeForDirectory(oldVersionOriginDirectory) + SQLiteIDBBackingStore::databasesSizeForDirectory(newVersionOriginDirectory);</span>
  }
  
  void IDBServer::upgradeFilesIfNecessary()
  {
      auto databaseDirectoryPath = this-&gt;databaseDirectoryPathIsolatedCopy();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 843,32 ***</span>
      String newVersionDirectory = FileSystem::pathByAppendingComponent(databaseDirectoryPath, &quot;v1&quot;);
      if (!FileSystem::fileExists(newVersionDirectory))
          FileSystem::makeAllDirectories(newVersionDirectory);
  }
  
<span class="line-modified">! void IDBServer::tryStop(ShouldForceStop shouldForceStop)</span>
  {
      // Only stop non-ephemeral IDBServers that can hold locked database files.
      if (m_sessionID.isEphemeral())
          return;
  
<span class="line-removed">-     suspendAndWait();</span>
<span class="line-removed">-     if (shouldForceStop == ShouldForceStop::No &amp;&amp; SQLiteDatabaseTracker::hasTransactionInProgress()) {</span>
<span class="line-removed">-         CrossThreadTaskHandler::resume();</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      for (auto&amp; database : m_uniqueIDBDatabaseMap.values())
<span class="line-modified">!         database-&gt;finishActiveTransactions();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void IDBServer::resume()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     if (m_sessionID.isEphemeral())</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     CrossThreadTaskHandler::resume();</span>
  }
  
  } // namespace IDBServer
  } // namespace WebCore
  
<span class="line-new-header">--- 709,21 ---</span>
      String newVersionDirectory = FileSystem::pathByAppendingComponent(databaseDirectoryPath, &quot;v1&quot;);
      if (!FileSystem::fileExists(newVersionDirectory))
          FileSystem::makeAllDirectories(newVersionDirectory);
  }
  
<span class="line-modified">! void IDBServer::stopDatabaseActivitiesOnMainThread()</span>
  {
<span class="line-added">+     ASSERT(isMainThread());</span>
<span class="line-added">+     ASSERT(m_lock.isHeld());</span>
<span class="line-added">+ </span>
      // Only stop non-ephemeral IDBServers that can hold locked database files.
      if (m_sessionID.isEphemeral())
          return;
  
      for (auto&amp; database : m_uniqueIDBDatabaseMap.values())
<span class="line-modified">!         database-&gt;abortActiveTransactions();</span>
  }
  
  } // namespace IDBServer
  } // namespace WebCore
  
</pre>
<center><a href="IDBSerializationContext.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="IDBServer.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
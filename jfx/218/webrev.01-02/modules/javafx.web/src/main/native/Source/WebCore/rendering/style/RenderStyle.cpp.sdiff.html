<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/style/RenderStyle.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NinePieceImage.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderStyle.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/style/RenderStyle.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;RenderStyle.h&quot;
  25 
  26 #include &quot;CSSComputedStyleDeclaration.h&quot;
  27 #include &quot;CSSCustomPropertyValue.h&quot;
  28 #include &quot;CSSParser.h&quot;
  29 #include &quot;CSSPropertyNames.h&quot;
  30 #include &quot;CSSPropertyParser.h&quot;
  31 #include &quot;ContentData.h&quot;
  32 #include &quot;CursorList.h&quot;
  33 #include &quot;FloatRoundedRect.h&quot;
  34 #include &quot;FontCascade.h&quot;
  35 #include &quot;FontSelector.h&quot;
  36 #include &quot;InlineTextBoxStyle.h&quot;
  37 #include &quot;Pagination.h&quot;
  38 #include &quot;QuotesData.h&quot;
  39 #include &quot;RenderObject.h&quot;
  40 #include &quot;RenderTheme.h&quot;
<span class="line-removed">  41 #include &quot;RuntimeEnabledFeatures.h&quot;</span>
  42 #include &quot;ScaleTransformOperation.h&quot;
  43 #include &quot;ShadowData.h&quot;
  44 #include &quot;StyleBuilderConverter.h&quot;
  45 #include &quot;StyleImage.h&quot;
  46 #include &quot;StyleInheritedData.h&quot;
  47 #include &quot;StyleResolver.h&quot;
  48 #include &quot;StyleScrollSnapPoints.h&quot;
  49 #include &quot;StyleSelfAlignmentData.h&quot;
  50 #include &quot;StyleTreeResolver.h&quot;
  51 #include &quot;WillChangeData.h&quot;
  52 #include &lt;wtf/MathExtras.h&gt;
  53 #include &lt;wtf/PointerComparison.h&gt;
  54 #include &lt;wtf/StdLibExtras.h&gt;
  55 #include &lt;algorithm&gt;
  56 
  57 #if ENABLE(TEXT_AUTOSIZING)
  58 #include &lt;wtf/text/StringHash.h&gt;
  59 #endif
  60 
  61 namespace WebCore {
  62 
  63 struct SameSizeAsBorderValue {
  64     Color m_color;
  65     float m_width;
  66     int m_restBits;
  67 };
  68 
  69 COMPILE_ASSERT(sizeof(BorderValue) == sizeof(SameSizeAsBorderValue), BorderValue_should_not_grow);
  70 
  71 struct SameSizeAsRenderStyle {
  72     void* dataRefs[7];
  73     void* ownPtrs[1];
  74     void* dataRefSvgStyle;
  75     struct InheritedFlags {
  76         unsigned m_bitfields[2];
  77     } m_inheritedFlags;
  78 
  79     struct NonInheritedFlags {
  80         unsigned m_bitfields[2];
  81     } m_nonInheritedFlags;
<span class="line-modified">  82 #if !ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS)</span>
  83     bool deletionCheck;
  84 #endif
  85 };
  86 
  87 static_assert(sizeof(RenderStyle) == sizeof(SameSizeAsRenderStyle), &quot;RenderStyle should stay small&quot;);
  88 


  89 RenderStyle&amp; RenderStyle::defaultStyle()
  90 {
  91     static NeverDestroyed&lt;RenderStyle&gt; style { CreateDefaultStyle };
  92     return style;
  93 }
  94 
  95 RenderStyle RenderStyle::create()
  96 {
  97     return clone(defaultStyle());
  98 }
  99 
 100 std::unique_ptr&lt;RenderStyle&gt; RenderStyle::createPtr()
 101 {
 102     return clonePtr(defaultStyle());
 103 }
 104 
 105 RenderStyle RenderStyle::clone(const RenderStyle&amp; style)
 106 {
 107     return RenderStyle(style, Clone);
 108 }
</pre>
<hr />
<pre>
 213 {
 214 }
 215 
 216 inline RenderStyle::RenderStyle(RenderStyle&amp; a, RenderStyle&amp;&amp; b)
 217     : m_boxData(a.m_boxData.replace(WTFMove(b.m_boxData)))
 218     , m_visualData(a.m_visualData.replace(WTFMove(b.m_visualData)))
 219     , m_backgroundData(a.m_backgroundData.replace(WTFMove(b.m_backgroundData)))
 220     , m_surroundData(a.m_surroundData.replace(WTFMove(b.m_surroundData)))
 221     , m_rareNonInheritedData(a.m_rareNonInheritedData.replace(WTFMove(b.m_rareNonInheritedData)))
 222     , m_nonInheritedFlags(std::exchange(a.m_nonInheritedFlags, b.m_nonInheritedFlags))
 223     , m_rareInheritedData(a.m_rareInheritedData.replace(WTFMove(b.m_rareInheritedData)))
 224     , m_inheritedData(a.m_inheritedData.replace(WTFMove(b.m_inheritedData)))
 225     , m_inheritedFlags(std::exchange(a.m_inheritedFlags, b.m_inheritedFlags))
 226     , m_cachedPseudoStyles(std::exchange(a.m_cachedPseudoStyles, WTFMove(b.m_cachedPseudoStyles)))
 227     , m_svgStyle(a.m_svgStyle.replace(WTFMove(b.m_svgStyle)))
 228 {
 229 }
 230 
 231 RenderStyle::~RenderStyle()
 232 {
<span class="line-modified"> 233 #if !ASSERT_DISABLED || ENABLE(SECURITY_ASSERTIONS)</span>
 234     ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);
 235     m_deletionHasBegun = true;
 236 #endif
 237 }
 238 
 239 RenderStyle RenderStyle::replace(RenderStyle&amp;&amp; newStyle)
 240 {
 241     return RenderStyle { *this, WTFMove(newStyle) };
 242 }
 243 
 244 static StyleSelfAlignmentData resolvedSelfAlignment(const StyleSelfAlignmentData&amp; value, ItemPosition normalValueBehavior)
 245 {
 246     if (value.position() == ItemPosition::Legacy || value.position() == ItemPosition::Normal || value.position() == ItemPosition::Auto)
 247         return { normalValueBehavior, OverflowAlignment::Default };
 248     return value;
 249 }
 250 
 251 StyleSelfAlignmentData RenderStyle::resolvedAlignItems(ItemPosition normalValueBehaviour) const
 252 {
 253     return resolvedSelfAlignment(alignItems(), normalValueBehaviour);
</pre>
<hr />
<pre>
 412         m_cachedPseudoStyles = makeUnique&lt;PseudoStyleCache&gt;();
 413 
 414     m_cachedPseudoStyles-&gt;append(WTFMove(pseudo));
 415 
 416     return result;
 417 }
 418 
 419 void RenderStyle::removeCachedPseudoStyle(PseudoId pid)
 420 {
 421     if (!m_cachedPseudoStyles)
 422         return;
 423     for (size_t i = 0; i &lt; m_cachedPseudoStyles-&gt;size(); ++i) {
 424         RenderStyle* pseudoStyle = m_cachedPseudoStyles-&gt;at(i).get();
 425         if (pseudoStyle-&gt;styleType() == pid) {
 426             m_cachedPseudoStyles-&gt;remove(i);
 427             return;
 428         }
 429     }
 430 }
 431 
<span class="line-modified"> 432 bool RenderStyle::inheritedNotEqual(const RenderStyle* other) const</span>








 433 {
<span class="line-modified"> 434     return m_inheritedFlags != other-&gt;m_inheritedFlags</span>
<span class="line-modified"> 435         || m_inheritedData != other-&gt;m_inheritedData</span>
<span class="line-modified"> 436         || m_svgStyle-&gt;inheritedNotEqual(other-&gt;m_svgStyle)</span>
<span class="line-modified"> 437         || m_rareInheritedData != other-&gt;m_rareInheritedData;</span>

 438 }
 439 
 440 #if ENABLE(TEXT_AUTOSIZING)
 441 
 442 static inline unsigned computeFontHash(const FontCascade&amp; font)
 443 {
 444     IntegerHasher hasher;
 445     hasher.add(ASCIICaseInsensitiveHash::hash(font.fontDescription().firstFamily()));
 446     hasher.add(font.fontDescription().specifiedSize());
 447     return hasher.hash();
 448 }
 449 
 450 unsigned RenderStyle::hashForTextAutosizing() const
 451 {
 452     // FIXME: Not a very smart hash. Could be improved upon. See &lt;https://bugs.webkit.org/show_bug.cgi?id=121131&gt;.
 453     unsigned hash = m_rareNonInheritedData-&gt;appearance;
 454     hash ^= m_rareNonInheritedData-&gt;marginBeforeCollapse;
 455     hash ^= m_rareNonInheritedData-&gt;marginAfterCollapse;
 456     hash ^= m_rareNonInheritedData-&gt;lineClamp.value();
 457     hash ^= m_rareInheritedData-&gt;overflowWrap;
</pre>
<hr />
<pre>
 565     }
 566 
 567     if (hasBackgroundImage() &amp;&amp; backgroundRepeatX() == FillRepeat::NoRepeat &amp;&amp; backgroundRepeatY() == FillRepeat::NoRepeat)
 568         return false;
 569 
 570     return true;
 571 }
 572 
 573 AutosizeStatus RenderStyle::autosizeStatus() const
 574 {
 575     return OptionSet&lt;AutosizeStatus::Fields&gt;::fromRaw(m_inheritedFlags.autosizeStatus);
 576 }
 577 
 578 void RenderStyle::setAutosizeStatus(AutosizeStatus autosizeStatus)
 579 {
 580     m_inheritedFlags.autosizeStatus = autosizeStatus.fields().toRaw();
 581 }
 582 
 583 #endif // ENABLE(TEXT_AUTOSIZING)
 584 
<span class="line-removed"> 585 bool RenderStyle::inheritedDataShared(const RenderStyle* other) const</span>
<span class="line-removed"> 586 {</span>
<span class="line-removed"> 587     // This is a fast check that only looks if the data structures are shared.</span>
<span class="line-removed"> 588     return m_inheritedFlags == other-&gt;m_inheritedFlags</span>
<span class="line-removed"> 589         &amp;&amp; m_inheritedData.ptr() == other-&gt;m_inheritedData.ptr()</span>
<span class="line-removed"> 590         &amp;&amp; m_svgStyle.ptr() == other-&gt;m_svgStyle.ptr()</span>
<span class="line-removed"> 591         &amp;&amp; m_rareInheritedData.ptr() == other-&gt;m_rareInheritedData.ptr();</span>
<span class="line-removed"> 592 }</span>
<span class="line-removed"> 593 </span>
 594 static bool positionChangeIsMovementOnly(const LengthBox&amp; a, const LengthBox&amp; b, const Length&amp; width)
 595 {
 596     // If any unit types are different, then we can&#39;t guarantee
 597     // that this was just a movement.
 598     if (a.left().type() != b.left().type()
 599         || a.right().type() != b.right().type()
 600         || a.top().type() != b.top().type()
 601         || a.bottom().type() != b.bottom().type())
 602         return false;
 603 
 604     // Only one unit can be non-auto in the horizontal direction and
 605     // in the vertical direction.  Otherwise the adjustment of values
 606     // is changing the size of the box.
 607     if (!a.left().isIntrinsicOrAuto() &amp;&amp; !a.right().isIntrinsicOrAuto())
 608         return false;
 609     if (!a.top().isIntrinsicOrAuto() &amp;&amp; !a.bottom().isIntrinsicOrAuto())
 610         return false;
 611     // If our width is auto and left or right is specified then this
 612     // is not just a movement - we need to resize to our container.
 613     if ((!a.left().isIntrinsicOrAuto() || !a.right().isIntrinsicOrAuto()) &amp;&amp; width.isIntrinsicOrAuto())
</pre>
<hr />
<pre>
 749 #if ENABLE(TEXT_AUTOSIZING)
 750         || first.textSizeAdjust != second.textSizeAdjust
 751 #endif
 752         || first.wordBreak != second.wordBreak
 753         || first.overflowWrap != second.overflowWrap
 754         || first.nbspMode != second.nbspMode
 755         || first.lineBreak != second.lineBreak
 756         || first.textSecurity != second.textSecurity
 757         || first.hyphens != second.hyphens
 758         || first.hyphenationLimitBefore != second.hyphenationLimitBefore
 759         || first.hyphenationLimitAfter != second.hyphenationLimitAfter
 760         || first.hyphenationString != second.hyphenationString
 761         || first.rubyPosition != second.rubyPosition
 762         || first.textEmphasisMark != second.textEmphasisMark
 763         || first.textEmphasisPosition != second.textEmphasisPosition
 764         || first.textEmphasisCustomMark != second.textEmphasisCustomMark
 765         || first.textOrientation != second.textOrientation
 766         || first.tabSize != second.tabSize
 767         || first.lineBoxContain != second.lineBoxContain
 768         || first.lineGrid != second.lineGrid
<span class="line-removed"> 769 #if ENABLE(CSS_IMAGE_ORIENTATION)</span>
 770         || first.imageOrientation != second.imageOrientation
<span class="line-removed"> 771 #endif</span>
 772 #if ENABLE(CSS_IMAGE_RESOLUTION)
 773         || first.imageResolutionSource != second.imageResolutionSource
 774         || first.imageResolutionSnap != second.imageResolutionSnap
 775         || first.imageResolution != second.imageResolution
 776 #endif
 777         || first.lineSnap != second.lineSnap
 778         || first.lineAlign != second.lineAlign
 779         || first.hangingPunctuation != second.hangingPunctuation
 780 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
 781         || first.useTouchOverflowScrolling != second.useTouchOverflowScrolling
 782 #endif
 783         || first.listStyleImage != second.listStyleImage) // FIXME: needs arePointingToEqualData()?
 784         return true;
 785 
 786     if (first.textStrokeWidth != second.textStrokeWidth)
 787         return true;
 788 
 789     // These properties affect the cached stroke bounding box rects.
 790     if (first.capStyle != second.capStyle
 791         || first.joinStyle != second.joinStyle
</pre>
<hr />
<pre>
 974     if (first.filter != second.filter) {
 975         changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::Filter);
 976         // Don&#39;t return true; keep looking for another change.
 977     }
 978 
 979 #if ENABLE(FILTERS_LEVEL_2)
 980     if (first.backdropFilter != second.backdropFilter) {
 981         changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::Filter);
 982         // Don&#39;t return true; keep looking for another change.
 983     }
 984 #endif
 985 
 986     if (first.mask != second.mask || first.maskBoxImage != second.maskBoxImage)
 987         return true;
 988 
 989     return false;
 990 }
 991 
 992 bool RenderStyle::changeRequiresLayerRepaint(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const
 993 {
<span class="line-modified"> 994     // StyleResolver has ensured that zIndex is non-auto only if it&#39;s applicable.</span>
<span class="line-modified"> 995     if (m_boxData-&gt;zIndex() != other.m_boxData-&gt;zIndex() || m_boxData-&gt;hasAutoZIndex() != other.m_boxData-&gt;hasAutoZIndex())</span>
 996         return true;
 997 
 998     if (position() != PositionType::Static) {
 999         if (m_visualData-&gt;clip != other.m_visualData-&gt;clip || m_visualData-&gt;hasClip != other.m_visualData-&gt;hasClip) {
1000             changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::ClipRect);
1001             return true;
1002         }
1003     }
1004 
1005     if (m_rareNonInheritedData.ptr() != other.m_rareNonInheritedData.ptr()
1006         &amp;&amp; rareNonInheritedDataChangeRequiresLayerRepaint(*m_rareNonInheritedData, *other.m_rareNonInheritedData, changedContextSensitiveProperties))
1007         return true;
1008 
1009     return false;
1010 }
1011 
1012 static bool requiresPainting(const RenderStyle&amp; style)
1013 {
1014     if (style.visibility() == Visibility::Hidden)
1015         return false;
</pre>
<hr />
<pre>
1392     for (auto&amp; operation : operations)
1393         operation-&gt;apply(transform, boundingBox.size());
1394 
1395     if (applyTransformOrigin)
1396         transform.translate3d(-originTranslate.x(), -originTranslate.y(), -originTranslate.z());
1397 }
1398 
1399 void RenderStyle::setPageScaleTransform(float scale)
1400 {
1401     if (scale == 1)
1402         return;
1403     TransformOperations transform;
1404     transform.operations().append(ScaleTransformOperation::create(scale, scale, ScaleTransformOperation::SCALE));
1405     setTransform(transform);
1406     setTransformOriginX(Length(0, Fixed));
1407     setTransformOriginY(Length(0, Fixed));
1408 }
1409 
1410 void RenderStyle::setTextShadow(std::unique_ptr&lt;ShadowData&gt; shadowData, bool add)
1411 {
<span class="line-modified">1412     ASSERT(!shadowData || (!shadowData-&gt;spread() &amp;&amp; shadowData-&gt;style() == Normal));</span>
1413 
1414     auto&amp; rareData = m_rareInheritedData.access();
1415     if (!add) {
1416         rareData.textShadow = WTFMove(shadowData);
1417         return;
1418     }
1419 
1420     shadowData-&gt;setNext(WTFMove(rareData.textShadow));
1421     rareData.textShadow = WTFMove(shadowData);
1422 }
1423 
1424 void RenderStyle::setBoxShadow(std::unique_ptr&lt;ShadowData&gt; shadowData, bool add)
1425 {
1426     auto&amp; rareData = m_rareNonInheritedData.access();
1427     if (!add) {
1428         rareData.boxShadow = WTFMove(shadowData);
1429         return;
1430     }
1431 
1432     shadowData-&gt;setNext(WTFMove(rareData.boxShadow));
1433     rareData.boxShadow = WTFMove(shadowData);
1434 }
1435 
1436 static RoundedRect::Radii calcRadiiFor(const BorderData&amp; border, const LayoutSize&amp; size)
1437 {
1438     return {
<span class="line-modified">1439         sizeForLengthSize(border.topLeft(), size),</span>
<span class="line-modified">1440         sizeForLengthSize(border.topRight(), size),</span>
<span class="line-modified">1441         sizeForLengthSize(border.bottomLeft(), size),</span>
<span class="line-modified">1442         sizeForLengthSize(border.bottomRight(), size)</span>
1443     };
1444 }
1445 
1446 StyleImage* RenderStyle::listStyleImage() const
1447 {
1448     return m_rareInheritedData-&gt;listStyleImage.get();
1449 }
1450 
1451 void RenderStyle::setListStyleImage(RefPtr&lt;StyleImage&gt;&amp;&amp; v)
1452 {
1453     if (m_rareInheritedData-&gt;listStyleImage != v)
1454         m_rareInheritedData.access().listStyleImage = WTFMove(v);
1455 }
1456 
1457 const Color&amp; RenderStyle::color() const
1458 {
1459     return m_inheritedData-&gt;color;
1460 }
1461 
1462 const Color&amp; RenderStyle::visitedLinkColor() const
</pre>
<hr />
<pre>
1654 
1655     // Repeat patterns into layers that don&#39;t have some properties set.
1656     transitionList-&gt;fillUnsetProperties();
1657 
1658     // Make sure there are no duplicate properties.
1659     // This is an O(n^2) algorithm but the lists tend to be short, so it is probably OK.
1660     for (size_t i = 0; i &lt; transitionList-&gt;size(); ++i) {
1661         for (size_t j = i + 1; j &lt; transitionList-&gt;size(); ++j) {
1662             if (transitionList-&gt;animation(i).property() == transitionList-&gt;animation(j).property()) {
1663                 // toss i
1664                 transitionList-&gt;remove(i);
1665                 j = i;
1666             }
1667         }
1668     }
1669 }
1670 
1671 AnimationList&amp; RenderStyle::ensureAnimations()
1672 {
1673     if (!m_rareNonInheritedData.access().animations)
<span class="line-modified">1674         m_rareNonInheritedData.access().animations = makeUnique&lt;AnimationList&gt;();</span>
1675     return *m_rareNonInheritedData-&gt;animations;
1676 }
1677 
1678 AnimationList&amp; RenderStyle::ensureTransitions()
1679 {
1680     if (!m_rareNonInheritedData.access().transitions)
<span class="line-modified">1681         m_rareNonInheritedData.access().transitions = makeUnique&lt;AnimationList&gt;();</span>
1682     return *m_rareNonInheritedData-&gt;transitions;
1683 }
1684 
1685 const Animation* RenderStyle::transitionForProperty(CSSPropertyID property) const
1686 {
1687     auto* transitions = this-&gt;transitions();
1688     if (!transitions)
1689         return nullptr;
1690     for (size_t i = 0, size = transitions-&gt;size(); i &lt; size; ++i) {
1691         auto&amp; animation = transitions-&gt;animation(i);
1692         if (animation.animationMode() == Animation::AnimateAll || animation.property() == property)
1693             return &amp;animation;
1694     }
1695     return nullptr;
1696 }
1697 
1698 const FontCascade&amp; RenderStyle::fontCascade() const
1699 {
1700     return m_inheritedData-&gt;fontCascade;
1701 }
</pre>
<hr />
<pre>
1866 }
1867 
1868 void RenderStyle::setFontItalic(Optional&lt;FontSelectionValue&gt; value)
1869 {
1870     FontSelector* currentFontSelector = fontCascade().fontSelector();
1871     auto description = fontDescription();
1872     description.setItalic(value);
1873 
1874     setFontDescription(WTFMove(description));
1875     fontCascade().update(currentFontSelector);
1876 }
1877 
1878 void RenderStyle::getShadowExtent(const ShadowData* shadow, LayoutUnit&amp; top, LayoutUnit&amp; right, LayoutUnit&amp; bottom, LayoutUnit&amp; left) const
1879 {
1880     top = 0;
1881     right = 0;
1882     bottom = 0;
1883     left = 0;
1884 
1885     for ( ; shadow; shadow = shadow-&gt;next()) {
<span class="line-modified">1886         if (shadow-&gt;style() == Inset)</span>
1887             continue;
1888 
<span class="line-modified">1889         int extentAndSpread = shadow-&gt;paintingExtent() + shadow-&gt;spread();</span>
1890         top = std::min&lt;LayoutUnit&gt;(top, shadow-&gt;y() - extentAndSpread);
1891         right = std::max&lt;LayoutUnit&gt;(right, shadow-&gt;x() + extentAndSpread);
1892         bottom = std::max&lt;LayoutUnit&gt;(bottom, shadow-&gt;y() + extentAndSpread);
1893         left = std::min&lt;LayoutUnit&gt;(left, shadow-&gt;x() - extentAndSpread);
1894     }
1895 }
1896 
1897 LayoutBoxExtent RenderStyle::getShadowInsetExtent(const ShadowData* shadow) const
1898 {
1899     LayoutUnit top;
1900     LayoutUnit right;
1901     LayoutUnit bottom;
1902     LayoutUnit left;
1903 
1904     for ( ; shadow; shadow = shadow-&gt;next()) {
<span class="line-modified">1905         if (shadow-&gt;style() == Normal)</span>
1906             continue;
1907 
<span class="line-modified">1908         int extentAndSpread = shadow-&gt;paintingExtent() + shadow-&gt;spread();</span>
1909         top = std::max&lt;LayoutUnit&gt;(top, shadow-&gt;y() + extentAndSpread);
1910         right = std::min&lt;LayoutUnit&gt;(right, shadow-&gt;x() - extentAndSpread);
1911         bottom = std::min&lt;LayoutUnit&gt;(bottom, shadow-&gt;y() - extentAndSpread);
1912         left = std::max&lt;LayoutUnit&gt;(left, shadow-&gt;x() + extentAndSpread);
1913     }
1914 
1915     return LayoutBoxExtent(WTFMove(top), WTFMove(right), WTFMove(bottom), WTFMove(left));
1916 }
1917 
1918 void RenderStyle::getShadowHorizontalExtent(const ShadowData* shadow, LayoutUnit &amp;left, LayoutUnit &amp;right) const
1919 {
1920     left = 0;
1921     right = 0;
1922 
1923     for ( ; shadow; shadow = shadow-&gt;next()) {
<span class="line-modified">1924         if (shadow-&gt;style() == Inset)</span>
1925             continue;
1926 
<span class="line-modified">1927         int extentAndSpread = shadow-&gt;paintingExtent() + shadow-&gt;spread();</span>
1928         left = std::min&lt;LayoutUnit&gt;(left, shadow-&gt;x() - extentAndSpread);
1929         right = std::max&lt;LayoutUnit&gt;(right, shadow-&gt;x() + extentAndSpread);
1930     }
1931 }
1932 
1933 void RenderStyle::getShadowVerticalExtent(const ShadowData* shadow, LayoutUnit &amp;top, LayoutUnit &amp;bottom) const
1934 {
1935     top = 0;
1936     bottom = 0;
1937 
1938     for ( ; shadow; shadow = shadow-&gt;next()) {
<span class="line-modified">1939         if (shadow-&gt;style() == Inset)</span>
1940             continue;
1941 
<span class="line-modified">1942         int extentAndSpread = shadow-&gt;paintingExtent() + shadow-&gt;spread();</span>
1943         top = std::min&lt;LayoutUnit&gt;(top, shadow-&gt;y() - extentAndSpread);
1944         bottom = std::max&lt;LayoutUnit&gt;(bottom, shadow-&gt;y() + extentAndSpread);
1945     }
1946 }
1947 
1948 Color RenderStyle::colorIncludingFallback(CSSPropertyID colorProperty, bool visitedLink) const
1949 {
1950     Color result;
1951     BorderStyle borderStyle = BorderStyle::None;
1952     switch (colorProperty) {
1953     case CSSPropertyBackgroundColor:
1954         return visitedLink ? visitedLinkBackgroundColor() : backgroundColor(); // Background color doesn&#39;t fall back.
1955     case CSSPropertyBorderLeftColor:
1956         result = visitedLink ? visitedLinkBorderLeftColor() : borderLeftColor();
1957         borderStyle = borderLeftStyle();
1958         break;
1959     case CSSPropertyBorderRightColor:
1960         result = visitedLink ? visitedLinkBorderRightColor() : borderRightColor();
1961         borderStyle = borderRightStyle();
1962         break;
</pre>
</td>
<td>
<hr />
<pre>
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;RenderStyle.h&quot;
  25 
  26 #include &quot;CSSComputedStyleDeclaration.h&quot;
  27 #include &quot;CSSCustomPropertyValue.h&quot;
  28 #include &quot;CSSParser.h&quot;
  29 #include &quot;CSSPropertyNames.h&quot;
  30 #include &quot;CSSPropertyParser.h&quot;
  31 #include &quot;ContentData.h&quot;
  32 #include &quot;CursorList.h&quot;
  33 #include &quot;FloatRoundedRect.h&quot;
  34 #include &quot;FontCascade.h&quot;
  35 #include &quot;FontSelector.h&quot;
  36 #include &quot;InlineTextBoxStyle.h&quot;
  37 #include &quot;Pagination.h&quot;
  38 #include &quot;QuotesData.h&quot;
  39 #include &quot;RenderObject.h&quot;
  40 #include &quot;RenderTheme.h&quot;

  41 #include &quot;ScaleTransformOperation.h&quot;
  42 #include &quot;ShadowData.h&quot;
  43 #include &quot;StyleBuilderConverter.h&quot;
  44 #include &quot;StyleImage.h&quot;
  45 #include &quot;StyleInheritedData.h&quot;
  46 #include &quot;StyleResolver.h&quot;
  47 #include &quot;StyleScrollSnapPoints.h&quot;
  48 #include &quot;StyleSelfAlignmentData.h&quot;
  49 #include &quot;StyleTreeResolver.h&quot;
  50 #include &quot;WillChangeData.h&quot;
  51 #include &lt;wtf/MathExtras.h&gt;
  52 #include &lt;wtf/PointerComparison.h&gt;
  53 #include &lt;wtf/StdLibExtras.h&gt;
  54 #include &lt;algorithm&gt;
  55 
  56 #if ENABLE(TEXT_AUTOSIZING)
  57 #include &lt;wtf/text/StringHash.h&gt;
  58 #endif
  59 
  60 namespace WebCore {
  61 
  62 struct SameSizeAsBorderValue {
  63     Color m_color;
  64     float m_width;
  65     int m_restBits;
  66 };
  67 
  68 COMPILE_ASSERT(sizeof(BorderValue) == sizeof(SameSizeAsBorderValue), BorderValue_should_not_grow);
  69 
  70 struct SameSizeAsRenderStyle {
  71     void* dataRefs[7];
  72     void* ownPtrs[1];
  73     void* dataRefSvgStyle;
  74     struct InheritedFlags {
  75         unsigned m_bitfields[2];
  76     } m_inheritedFlags;
  77 
  78     struct NonInheritedFlags {
  79         unsigned m_bitfields[2];
  80     } m_nonInheritedFlags;
<span class="line-modified">  81 #if ASSERT_ENABLED || ENABLE(SECURITY_ASSERTIONS)</span>
  82     bool deletionCheck;
  83 #endif
  84 };
  85 
  86 static_assert(sizeof(RenderStyle) == sizeof(SameSizeAsRenderStyle), &quot;RenderStyle should stay small&quot;);
  87 
<span class="line-added">  88 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(RenderStyle);</span>
<span class="line-added">  89 </span>
  90 RenderStyle&amp; RenderStyle::defaultStyle()
  91 {
  92     static NeverDestroyed&lt;RenderStyle&gt; style { CreateDefaultStyle };
  93     return style;
  94 }
  95 
  96 RenderStyle RenderStyle::create()
  97 {
  98     return clone(defaultStyle());
  99 }
 100 
 101 std::unique_ptr&lt;RenderStyle&gt; RenderStyle::createPtr()
 102 {
 103     return clonePtr(defaultStyle());
 104 }
 105 
 106 RenderStyle RenderStyle::clone(const RenderStyle&amp; style)
 107 {
 108     return RenderStyle(style, Clone);
 109 }
</pre>
<hr />
<pre>
 214 {
 215 }
 216 
 217 inline RenderStyle::RenderStyle(RenderStyle&amp; a, RenderStyle&amp;&amp; b)
 218     : m_boxData(a.m_boxData.replace(WTFMove(b.m_boxData)))
 219     , m_visualData(a.m_visualData.replace(WTFMove(b.m_visualData)))
 220     , m_backgroundData(a.m_backgroundData.replace(WTFMove(b.m_backgroundData)))
 221     , m_surroundData(a.m_surroundData.replace(WTFMove(b.m_surroundData)))
 222     , m_rareNonInheritedData(a.m_rareNonInheritedData.replace(WTFMove(b.m_rareNonInheritedData)))
 223     , m_nonInheritedFlags(std::exchange(a.m_nonInheritedFlags, b.m_nonInheritedFlags))
 224     , m_rareInheritedData(a.m_rareInheritedData.replace(WTFMove(b.m_rareInheritedData)))
 225     , m_inheritedData(a.m_inheritedData.replace(WTFMove(b.m_inheritedData)))
 226     , m_inheritedFlags(std::exchange(a.m_inheritedFlags, b.m_inheritedFlags))
 227     , m_cachedPseudoStyles(std::exchange(a.m_cachedPseudoStyles, WTFMove(b.m_cachedPseudoStyles)))
 228     , m_svgStyle(a.m_svgStyle.replace(WTFMove(b.m_svgStyle)))
 229 {
 230 }
 231 
 232 RenderStyle::~RenderStyle()
 233 {
<span class="line-modified"> 234 #if ASSERT_ENABLED || ENABLE(SECURITY_ASSERTIONS)</span>
 235     ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);
 236     m_deletionHasBegun = true;
 237 #endif
 238 }
 239 
 240 RenderStyle RenderStyle::replace(RenderStyle&amp;&amp; newStyle)
 241 {
 242     return RenderStyle { *this, WTFMove(newStyle) };
 243 }
 244 
 245 static StyleSelfAlignmentData resolvedSelfAlignment(const StyleSelfAlignmentData&amp; value, ItemPosition normalValueBehavior)
 246 {
 247     if (value.position() == ItemPosition::Legacy || value.position() == ItemPosition::Normal || value.position() == ItemPosition::Auto)
 248         return { normalValueBehavior, OverflowAlignment::Default };
 249     return value;
 250 }
 251 
 252 StyleSelfAlignmentData RenderStyle::resolvedAlignItems(ItemPosition normalValueBehaviour) const
 253 {
 254     return resolvedSelfAlignment(alignItems(), normalValueBehaviour);
</pre>
<hr />
<pre>
 413         m_cachedPseudoStyles = makeUnique&lt;PseudoStyleCache&gt;();
 414 
 415     m_cachedPseudoStyles-&gt;append(WTFMove(pseudo));
 416 
 417     return result;
 418 }
 419 
 420 void RenderStyle::removeCachedPseudoStyle(PseudoId pid)
 421 {
 422     if (!m_cachedPseudoStyles)
 423         return;
 424     for (size_t i = 0; i &lt; m_cachedPseudoStyles-&gt;size(); ++i) {
 425         RenderStyle* pseudoStyle = m_cachedPseudoStyles-&gt;at(i).get();
 426         if (pseudoStyle-&gt;styleType() == pid) {
 427             m_cachedPseudoStyles-&gt;remove(i);
 428             return;
 429         }
 430     }
 431 }
 432 
<span class="line-modified"> 433 bool RenderStyle::inheritedEqual(const RenderStyle&amp; other) const</span>
<span class="line-added"> 434 {</span>
<span class="line-added"> 435     return m_inheritedFlags == other.m_inheritedFlags</span>
<span class="line-added"> 436         &amp;&amp; m_inheritedData == other.m_inheritedData</span>
<span class="line-added"> 437         &amp;&amp; (m_svgStyle.ptr() == other.m_svgStyle.ptr() || m_svgStyle-&gt;inheritedEqual(other.m_svgStyle))</span>
<span class="line-added"> 438         &amp;&amp; m_rareInheritedData == other.m_rareInheritedData;</span>
<span class="line-added"> 439 }</span>
<span class="line-added"> 440 </span>
<span class="line-added"> 441 bool RenderStyle::descendantAffectingNonInheritedPropertiesEqual(const RenderStyle&amp; other) const</span>
 442 {
<span class="line-modified"> 443     if (m_rareNonInheritedData.ptr() == other.m_rareNonInheritedData.ptr())</span>
<span class="line-modified"> 444         return true;</span>
<span class="line-modified"> 445 </span>
<span class="line-modified"> 446     return m_rareNonInheritedData-&gt;alignItems == other.m_rareNonInheritedData-&gt;alignItems</span>
<span class="line-added"> 447         &amp;&amp; m_rareNonInheritedData-&gt;justifyItems == other.m_rareNonInheritedData-&gt;justifyItems;</span>
 448 }
 449 
 450 #if ENABLE(TEXT_AUTOSIZING)
 451 
 452 static inline unsigned computeFontHash(const FontCascade&amp; font)
 453 {
 454     IntegerHasher hasher;
 455     hasher.add(ASCIICaseInsensitiveHash::hash(font.fontDescription().firstFamily()));
 456     hasher.add(font.fontDescription().specifiedSize());
 457     return hasher.hash();
 458 }
 459 
 460 unsigned RenderStyle::hashForTextAutosizing() const
 461 {
 462     // FIXME: Not a very smart hash. Could be improved upon. See &lt;https://bugs.webkit.org/show_bug.cgi?id=121131&gt;.
 463     unsigned hash = m_rareNonInheritedData-&gt;appearance;
 464     hash ^= m_rareNonInheritedData-&gt;marginBeforeCollapse;
 465     hash ^= m_rareNonInheritedData-&gt;marginAfterCollapse;
 466     hash ^= m_rareNonInheritedData-&gt;lineClamp.value();
 467     hash ^= m_rareInheritedData-&gt;overflowWrap;
</pre>
<hr />
<pre>
 575     }
 576 
 577     if (hasBackgroundImage() &amp;&amp; backgroundRepeatX() == FillRepeat::NoRepeat &amp;&amp; backgroundRepeatY() == FillRepeat::NoRepeat)
 578         return false;
 579 
 580     return true;
 581 }
 582 
 583 AutosizeStatus RenderStyle::autosizeStatus() const
 584 {
 585     return OptionSet&lt;AutosizeStatus::Fields&gt;::fromRaw(m_inheritedFlags.autosizeStatus);
 586 }
 587 
 588 void RenderStyle::setAutosizeStatus(AutosizeStatus autosizeStatus)
 589 {
 590     m_inheritedFlags.autosizeStatus = autosizeStatus.fields().toRaw();
 591 }
 592 
 593 #endif // ENABLE(TEXT_AUTOSIZING)
 594 









 595 static bool positionChangeIsMovementOnly(const LengthBox&amp; a, const LengthBox&amp; b, const Length&amp; width)
 596 {
 597     // If any unit types are different, then we can&#39;t guarantee
 598     // that this was just a movement.
 599     if (a.left().type() != b.left().type()
 600         || a.right().type() != b.right().type()
 601         || a.top().type() != b.top().type()
 602         || a.bottom().type() != b.bottom().type())
 603         return false;
 604 
 605     // Only one unit can be non-auto in the horizontal direction and
 606     // in the vertical direction.  Otherwise the adjustment of values
 607     // is changing the size of the box.
 608     if (!a.left().isIntrinsicOrAuto() &amp;&amp; !a.right().isIntrinsicOrAuto())
 609         return false;
 610     if (!a.top().isIntrinsicOrAuto() &amp;&amp; !a.bottom().isIntrinsicOrAuto())
 611         return false;
 612     // If our width is auto and left or right is specified then this
 613     // is not just a movement - we need to resize to our container.
 614     if ((!a.left().isIntrinsicOrAuto() || !a.right().isIntrinsicOrAuto()) &amp;&amp; width.isIntrinsicOrAuto())
</pre>
<hr />
<pre>
 750 #if ENABLE(TEXT_AUTOSIZING)
 751         || first.textSizeAdjust != second.textSizeAdjust
 752 #endif
 753         || first.wordBreak != second.wordBreak
 754         || first.overflowWrap != second.overflowWrap
 755         || first.nbspMode != second.nbspMode
 756         || first.lineBreak != second.lineBreak
 757         || first.textSecurity != second.textSecurity
 758         || first.hyphens != second.hyphens
 759         || first.hyphenationLimitBefore != second.hyphenationLimitBefore
 760         || first.hyphenationLimitAfter != second.hyphenationLimitAfter
 761         || first.hyphenationString != second.hyphenationString
 762         || first.rubyPosition != second.rubyPosition
 763         || first.textEmphasisMark != second.textEmphasisMark
 764         || first.textEmphasisPosition != second.textEmphasisPosition
 765         || first.textEmphasisCustomMark != second.textEmphasisCustomMark
 766         || first.textOrientation != second.textOrientation
 767         || first.tabSize != second.tabSize
 768         || first.lineBoxContain != second.lineBoxContain
 769         || first.lineGrid != second.lineGrid

 770         || first.imageOrientation != second.imageOrientation

 771 #if ENABLE(CSS_IMAGE_RESOLUTION)
 772         || first.imageResolutionSource != second.imageResolutionSource
 773         || first.imageResolutionSnap != second.imageResolutionSnap
 774         || first.imageResolution != second.imageResolution
 775 #endif
 776         || first.lineSnap != second.lineSnap
 777         || first.lineAlign != second.lineAlign
 778         || first.hangingPunctuation != second.hangingPunctuation
 779 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
 780         || first.useTouchOverflowScrolling != second.useTouchOverflowScrolling
 781 #endif
 782         || first.listStyleImage != second.listStyleImage) // FIXME: needs arePointingToEqualData()?
 783         return true;
 784 
 785     if (first.textStrokeWidth != second.textStrokeWidth)
 786         return true;
 787 
 788     // These properties affect the cached stroke bounding box rects.
 789     if (first.capStyle != second.capStyle
 790         || first.joinStyle != second.joinStyle
</pre>
<hr />
<pre>
 973     if (first.filter != second.filter) {
 974         changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::Filter);
 975         // Don&#39;t return true; keep looking for another change.
 976     }
 977 
 978 #if ENABLE(FILTERS_LEVEL_2)
 979     if (first.backdropFilter != second.backdropFilter) {
 980         changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::Filter);
 981         // Don&#39;t return true; keep looking for another change.
 982     }
 983 #endif
 984 
 985     if (first.mask != second.mask || first.maskBoxImage != second.maskBoxImage)
 986         return true;
 987 
 988     return false;
 989 }
 990 
 991 bool RenderStyle::changeRequiresLayerRepaint(const RenderStyle&amp; other, OptionSet&lt;StyleDifferenceContextSensitiveProperty&gt;&amp; changedContextSensitiveProperties) const
 992 {
<span class="line-modified"> 993     // Style::Resolver has ensured that zIndex is non-auto only if it&#39;s applicable.</span>
<span class="line-modified"> 994     if (m_boxData-&gt;usedZIndex() != other.m_boxData-&gt;usedZIndex() || m_boxData-&gt;hasAutoUsedZIndex() != other.m_boxData-&gt;hasAutoUsedZIndex())</span>
 995         return true;
 996 
 997     if (position() != PositionType::Static) {
 998         if (m_visualData-&gt;clip != other.m_visualData-&gt;clip || m_visualData-&gt;hasClip != other.m_visualData-&gt;hasClip) {
 999             changedContextSensitiveProperties.add(StyleDifferenceContextSensitiveProperty::ClipRect);
1000             return true;
1001         }
1002     }
1003 
1004     if (m_rareNonInheritedData.ptr() != other.m_rareNonInheritedData.ptr()
1005         &amp;&amp; rareNonInheritedDataChangeRequiresLayerRepaint(*m_rareNonInheritedData, *other.m_rareNonInheritedData, changedContextSensitiveProperties))
1006         return true;
1007 
1008     return false;
1009 }
1010 
1011 static bool requiresPainting(const RenderStyle&amp; style)
1012 {
1013     if (style.visibility() == Visibility::Hidden)
1014         return false;
</pre>
<hr />
<pre>
1391     for (auto&amp; operation : operations)
1392         operation-&gt;apply(transform, boundingBox.size());
1393 
1394     if (applyTransformOrigin)
1395         transform.translate3d(-originTranslate.x(), -originTranslate.y(), -originTranslate.z());
1396 }
1397 
1398 void RenderStyle::setPageScaleTransform(float scale)
1399 {
1400     if (scale == 1)
1401         return;
1402     TransformOperations transform;
1403     transform.operations().append(ScaleTransformOperation::create(scale, scale, ScaleTransformOperation::SCALE));
1404     setTransform(transform);
1405     setTransformOriginX(Length(0, Fixed));
1406     setTransformOriginY(Length(0, Fixed));
1407 }
1408 
1409 void RenderStyle::setTextShadow(std::unique_ptr&lt;ShadowData&gt; shadowData, bool add)
1410 {
<span class="line-modified">1411     ASSERT(!shadowData || (!shadowData-&gt;spread() &amp;&amp; shadowData-&gt;style() == ShadowStyle::Normal));</span>
1412 
1413     auto&amp; rareData = m_rareInheritedData.access();
1414     if (!add) {
1415         rareData.textShadow = WTFMove(shadowData);
1416         return;
1417     }
1418 
1419     shadowData-&gt;setNext(WTFMove(rareData.textShadow));
1420     rareData.textShadow = WTFMove(shadowData);
1421 }
1422 
1423 void RenderStyle::setBoxShadow(std::unique_ptr&lt;ShadowData&gt; shadowData, bool add)
1424 {
1425     auto&amp; rareData = m_rareNonInheritedData.access();
1426     if (!add) {
1427         rareData.boxShadow = WTFMove(shadowData);
1428         return;
1429     }
1430 
1431     shadowData-&gt;setNext(WTFMove(rareData.boxShadow));
1432     rareData.boxShadow = WTFMove(shadowData);
1433 }
1434 
1435 static RoundedRect::Radii calcRadiiFor(const BorderData&amp; border, const LayoutSize&amp; size)
1436 {
1437     return {
<span class="line-modified">1438         sizeForLengthSize(border.topLeftRadius(), size),</span>
<span class="line-modified">1439         sizeForLengthSize(border.topRightRadius(), size),</span>
<span class="line-modified">1440         sizeForLengthSize(border.bottomLeftRadius(), size),</span>
<span class="line-modified">1441         sizeForLengthSize(border.bottomRightRadius(), size)</span>
1442     };
1443 }
1444 
1445 StyleImage* RenderStyle::listStyleImage() const
1446 {
1447     return m_rareInheritedData-&gt;listStyleImage.get();
1448 }
1449 
1450 void RenderStyle::setListStyleImage(RefPtr&lt;StyleImage&gt;&amp;&amp; v)
1451 {
1452     if (m_rareInheritedData-&gt;listStyleImage != v)
1453         m_rareInheritedData.access().listStyleImage = WTFMove(v);
1454 }
1455 
1456 const Color&amp; RenderStyle::color() const
1457 {
1458     return m_inheritedData-&gt;color;
1459 }
1460 
1461 const Color&amp; RenderStyle::visitedLinkColor() const
</pre>
<hr />
<pre>
1653 
1654     // Repeat patterns into layers that don&#39;t have some properties set.
1655     transitionList-&gt;fillUnsetProperties();
1656 
1657     // Make sure there are no duplicate properties.
1658     // This is an O(n^2) algorithm but the lists tend to be short, so it is probably OK.
1659     for (size_t i = 0; i &lt; transitionList-&gt;size(); ++i) {
1660         for (size_t j = i + 1; j &lt; transitionList-&gt;size(); ++j) {
1661             if (transitionList-&gt;animation(i).property() == transitionList-&gt;animation(j).property()) {
1662                 // toss i
1663                 transitionList-&gt;remove(i);
1664                 j = i;
1665             }
1666         }
1667     }
1668 }
1669 
1670 AnimationList&amp; RenderStyle::ensureAnimations()
1671 {
1672     if (!m_rareNonInheritedData.access().animations)
<span class="line-modified">1673         m_rareNonInheritedData.access().animations = AnimationList::create();</span>
1674     return *m_rareNonInheritedData-&gt;animations;
1675 }
1676 
1677 AnimationList&amp; RenderStyle::ensureTransitions()
1678 {
1679     if (!m_rareNonInheritedData.access().transitions)
<span class="line-modified">1680         m_rareNonInheritedData.access().transitions = AnimationList::create();</span>
1681     return *m_rareNonInheritedData-&gt;transitions;
1682 }
1683 
1684 const Animation* RenderStyle::transitionForProperty(CSSPropertyID property) const
1685 {
1686     auto* transitions = this-&gt;transitions();
1687     if (!transitions)
1688         return nullptr;
1689     for (size_t i = 0, size = transitions-&gt;size(); i &lt; size; ++i) {
1690         auto&amp; animation = transitions-&gt;animation(i);
1691         if (animation.animationMode() == Animation::AnimateAll || animation.property() == property)
1692             return &amp;animation;
1693     }
1694     return nullptr;
1695 }
1696 
1697 const FontCascade&amp; RenderStyle::fontCascade() const
1698 {
1699     return m_inheritedData-&gt;fontCascade;
1700 }
</pre>
<hr />
<pre>
1865 }
1866 
1867 void RenderStyle::setFontItalic(Optional&lt;FontSelectionValue&gt; value)
1868 {
1869     FontSelector* currentFontSelector = fontCascade().fontSelector();
1870     auto description = fontDescription();
1871     description.setItalic(value);
1872 
1873     setFontDescription(WTFMove(description));
1874     fontCascade().update(currentFontSelector);
1875 }
1876 
1877 void RenderStyle::getShadowExtent(const ShadowData* shadow, LayoutUnit&amp; top, LayoutUnit&amp; right, LayoutUnit&amp; bottom, LayoutUnit&amp; left) const
1878 {
1879     top = 0;
1880     right = 0;
1881     bottom = 0;
1882     left = 0;
1883 
1884     for ( ; shadow; shadow = shadow-&gt;next()) {
<span class="line-modified">1885         if (shadow-&gt;style() == ShadowStyle::Inset)</span>
1886             continue;
1887 
<span class="line-modified">1888         auto extentAndSpread = shadow-&gt;paintingExtent() + shadow-&gt;spread();</span>
1889         top = std::min&lt;LayoutUnit&gt;(top, shadow-&gt;y() - extentAndSpread);
1890         right = std::max&lt;LayoutUnit&gt;(right, shadow-&gt;x() + extentAndSpread);
1891         bottom = std::max&lt;LayoutUnit&gt;(bottom, shadow-&gt;y() + extentAndSpread);
1892         left = std::min&lt;LayoutUnit&gt;(left, shadow-&gt;x() - extentAndSpread);
1893     }
1894 }
1895 
1896 LayoutBoxExtent RenderStyle::getShadowInsetExtent(const ShadowData* shadow) const
1897 {
1898     LayoutUnit top;
1899     LayoutUnit right;
1900     LayoutUnit bottom;
1901     LayoutUnit left;
1902 
1903     for ( ; shadow; shadow = shadow-&gt;next()) {
<span class="line-modified">1904         if (shadow-&gt;style() == ShadowStyle::Normal)</span>
1905             continue;
1906 
<span class="line-modified">1907         auto extentAndSpread = shadow-&gt;paintingExtent() + shadow-&gt;spread();</span>
1908         top = std::max&lt;LayoutUnit&gt;(top, shadow-&gt;y() + extentAndSpread);
1909         right = std::min&lt;LayoutUnit&gt;(right, shadow-&gt;x() - extentAndSpread);
1910         bottom = std::min&lt;LayoutUnit&gt;(bottom, shadow-&gt;y() - extentAndSpread);
1911         left = std::max&lt;LayoutUnit&gt;(left, shadow-&gt;x() + extentAndSpread);
1912     }
1913 
1914     return LayoutBoxExtent(WTFMove(top), WTFMove(right), WTFMove(bottom), WTFMove(left));
1915 }
1916 
1917 void RenderStyle::getShadowHorizontalExtent(const ShadowData* shadow, LayoutUnit &amp;left, LayoutUnit &amp;right) const
1918 {
1919     left = 0;
1920     right = 0;
1921 
1922     for ( ; shadow; shadow = shadow-&gt;next()) {
<span class="line-modified">1923         if (shadow-&gt;style() == ShadowStyle::Inset)</span>
1924             continue;
1925 
<span class="line-modified">1926         auto extentAndSpread = shadow-&gt;paintingExtent() + shadow-&gt;spread();</span>
1927         left = std::min&lt;LayoutUnit&gt;(left, shadow-&gt;x() - extentAndSpread);
1928         right = std::max&lt;LayoutUnit&gt;(right, shadow-&gt;x() + extentAndSpread);
1929     }
1930 }
1931 
1932 void RenderStyle::getShadowVerticalExtent(const ShadowData* shadow, LayoutUnit &amp;top, LayoutUnit &amp;bottom) const
1933 {
1934     top = 0;
1935     bottom = 0;
1936 
1937     for ( ; shadow; shadow = shadow-&gt;next()) {
<span class="line-modified">1938         if (shadow-&gt;style() == ShadowStyle::Inset)</span>
1939             continue;
1940 
<span class="line-modified">1941         auto extentAndSpread = shadow-&gt;paintingExtent() + shadow-&gt;spread();</span>
1942         top = std::min&lt;LayoutUnit&gt;(top, shadow-&gt;y() - extentAndSpread);
1943         bottom = std::max&lt;LayoutUnit&gt;(bottom, shadow-&gt;y() + extentAndSpread);
1944     }
1945 }
1946 
1947 Color RenderStyle::colorIncludingFallback(CSSPropertyID colorProperty, bool visitedLink) const
1948 {
1949     Color result;
1950     BorderStyle borderStyle = BorderStyle::None;
1951     switch (colorProperty) {
1952     case CSSPropertyBackgroundColor:
1953         return visitedLink ? visitedLinkBackgroundColor() : backgroundColor(); // Background color doesn&#39;t fall back.
1954     case CSSPropertyBorderLeftColor:
1955         result = visitedLink ? visitedLinkBorderLeftColor() : borderLeftColor();
1956         borderStyle = borderLeftStyle();
1957         break;
1958     case CSSPropertyBorderRightColor:
1959         result = visitedLink ? visitedLinkBorderRightColor() : borderRightColor();
1960         borderStyle = borderRightStyle();
1961         break;
</pre>
</td>
</tr>
</table>
<center><a href="NinePieceImage.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderStyle.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGTypeCheckHoistingPhase.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGTypeCheckHoistingPhase.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGTypeCheckHoistingPhase.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGTypeCheckHoistingPhase.cpp
@@ -141,37 +141,46 @@
                     RELEASE_ASSERT(origin.exitOK);
 
                     Node* getLocal = insertionSet.insertNode(
                         indexInBlock + 1, variable->prediction(), GetLocal, origin,
                         OpInfo(variable), Edge(node));
-                    if (iter->value.m_structure) {
-                        auto checkOp = CheckStructure;
-                        if (SpecCellCheck & SpecEmpty) {
-                            VirtualRegister local = node->variableAccessData()->local();
-                            auto* inlineCallFrame = node->origin.semantic.inlineCallFrame();
-                            if ((local - (inlineCallFrame ? inlineCallFrame->stackOffset : 0)) == virtualRegisterForArgument(0)) {
-                                // |this| can be the TDZ value. The call entrypoint won't have |this| as TDZ,
-                                // but a catch or a loop OSR entry may have |this| be TDZ.
-                                checkOp = CheckStructureOrEmpty;
-                            }
+
+                    auto needsEmptyCheck = [](Node* node) -> bool {
+                        if (!(SpecCellCheck & SpecEmpty))
+                            return false;
+                        VirtualRegister local = node->variableAccessData()->operand().virtualRegister();
+                        auto* inlineCallFrame = node->origin.semantic.inlineCallFrame();
+                        if ((local - (inlineCallFrame ? inlineCallFrame->stackOffset : 0)) == virtualRegisterForArgumentIncludingThis(0)) {
+                            // |this| can be the TDZ value. The call entrypoint won't have |this| as TDZ,
+                            // but a catch or a loop OSR entry may have |this| be TDZ.
+                            return true;
                         }
+                        return false;
+                    };
 
+                    if (iter->value.m_structure) {
+                        auto checkOp = CheckStructure;
+                        if (needsEmptyCheck(node))
+                            checkOp = CheckStructureOrEmpty;
                         insertionSet.insertNode(
                             indexInBlock + 1, SpecNone, checkOp, origin,
                             OpInfo(m_graph.addStructureSet(iter->value.m_structure)),
                             Edge(getLocal, CellUse));
                     } else if (iter->value.m_arrayModeIsValid) {
                         ASSERT(iter->value.m_arrayModeHoistingOkay);
+                        auto checkOp = CheckArray;
+                        if (needsEmptyCheck(node))
+                            checkOp = CheckArrayOrEmpty;
                         insertionSet.insertNode(
-                            indexInBlock + 1, SpecNone, CheckArray, origin,
+                            indexInBlock + 1, SpecNone, checkOp, origin,
                             OpInfo(iter->value.m_arrayMode.asWord()),
                             Edge(getLocal, CellUse));
                     } else
                         RELEASE_ASSERT_NOT_REACHED();
 
-                    if (block->variablesAtTail.operand(variable->local()) == node)
-                        block->variablesAtTail.operand(variable->local()) = getLocal;
+                    if (block->variablesAtTail.operand(variable->operand()) == node)
+                        block->variablesAtTail.operand(variable->operand()) = getLocal;
 
                     m_graph.substituteGetLocal(*block, indexInBlock, variable, getLocal);
 
                     changed = true;
                     break;
@@ -186,25 +195,25 @@
                         break;
 
                     NodeOrigin origin = node->origin;
                     Edge child1 = node->child1();
 
+                    // Note: On 64-bit platforms, cell checks allow the empty value to flow through.
+                    // This means that this structure/array check may see the empty value as input. We need
+                    // to emit a node that explicitly handles the empty value. Most of the time, CheckStructureOrEmpty/CheckArrayOrEmpty
+                    // will be folded to CheckStructure/CheckArray because AI proves that the incoming value is
+                    // definitely not empty.
                     if (iter->value.m_structure) {
-                        // Note: On 64-bit platforms, cell checks allow the empty value to flow through.
-                        // This means that this structure check may see the empty value as input. We need
-                        // to emit a node that explicitly handles the empty value. Most of the time, CheckStructureOrEmpty
-                        // will be folded to CheckStructure because AI proves that the incoming value is
-                        // definitely not empty.
                         insertionSet.insertNode(
                             indexForChecks, SpecNone, (SpecCellCheck & SpecEmpty) ? CheckStructureOrEmpty : CheckStructure,
                             originForChecks.withSemantic(origin.semantic),
                             OpInfo(m_graph.addStructureSet(iter->value.m_structure)),
                             Edge(child1.node(), CellUse));
                     } else if (iter->value.m_arrayModeIsValid) {
                         ASSERT(iter->value.m_arrayModeHoistingOkay);
                         insertionSet.insertNode(
-                            indexForChecks, SpecNone, CheckArray,
+                            indexForChecks, SpecNone, (SpecCellCheck & SpecEmpty) ? CheckArrayOrEmpty : CheckArray,
                             originForChecks.withSemantic(origin.semantic),
                             OpInfo(iter->value.m_arrayMode.asWord()),
                             Edge(child1.node(), CellUse));
                     } else
                         RELEASE_ASSERT_NOT_REACHED();
@@ -269,10 +278,11 @@
                 case PutByValDirect:
                 case PutByVal:
                 case PutByValAlias:
                 case GetArrayLength:
                 case CheckArray:
+                case CheckNeutered:
                 case GetIndexedPropertyStorage:
                 case GetTypedArrayByteOffset:
                 case Phantom:
                 case MovHint:
                 case MultiGetByOffset:
@@ -334,10 +344,11 @@
                     noticeCheckArray(variable, node->arrayMode());
                     break;
                 }
 
                 case CheckStructure:
+                case CheckNeutered:
                 case GetByOffset:
                 case PutByOffset:
                 case PutStructure:
                 case ReallocatePropertyStorage:
                 case GetButterfly:
@@ -444,11 +455,11 @@
                 continue;
             if (block->bytecodeBegin != m_graph.m_plan.osrEntryBytecodeIndex())
                 continue;
             const Operands<Optional<JSValue>>& mustHandleValues = m_graph.m_plan.mustHandleValues();
             for (size_t i = 0; i < mustHandleValues.size(); ++i) {
-                int operand = mustHandleValues.operandForIndex(i);
+                Operand operand = mustHandleValues.operandForIndex(i);
                 Node* node = block->variablesAtHead.operand(operand);
                 if (!node)
                     continue;
                 VariableAccessData* variable = node->variableAccessData();
                 HashMap<VariableAccessData*, CheckData>::iterator iter = m_map.find(variable);

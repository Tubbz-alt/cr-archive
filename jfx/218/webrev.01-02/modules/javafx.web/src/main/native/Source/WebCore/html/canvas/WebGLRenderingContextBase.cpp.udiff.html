<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContextBase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebGLRenderingContext.idl.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLRenderingContextBase.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLRenderingContextBase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -38,11 +38,11 @@</span>
  #include &quot;EXTFragDepth.h&quot;
  #include &quot;EXTShaderTextureLOD.h&quot;
  #include &quot;EXTTextureFilterAnisotropic.h&quot;
  #include &quot;EXTsRGB.h&quot;
  #include &quot;EventNames.h&quot;
<span class="udiff-line-modified-removed">- #include &quot;Extensions3D.h&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;ExtensionsGL.h&quot;</span>
  #include &quot;Frame.h&quot;
  #include &quot;FrameLoader.h&quot;
  #include &quot;FrameLoaderClient.h&quot;
  #include &quot;FrameView.h&quot;
  #include &quot;GraphicsContext.h&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -61,20 +61,21 @@</span>
  #include &quot;OESTextureFloat.h&quot;
  #include &quot;OESTextureFloatLinear.h&quot;
  #include &quot;OESTextureHalfFloat.h&quot;
  #include &quot;OESTextureHalfFloatLinear.h&quot;
  #include &quot;OESVertexArrayObject.h&quot;
<span class="udiff-line-removed">- #include &quot;OffscreenCanvas.h&quot;</span>
  #include &quot;Page.h&quot;
  #include &quot;RenderBox.h&quot;
  #include &quot;RuntimeEnabledFeatures.h&quot;
  #include &quot;Settings.h&quot;
  #include &quot;WebGL2RenderingContext.h&quot;
  #include &quot;WebGLActiveInfo.h&quot;
  #include &quot;WebGLBuffer.h&quot;
  #include &quot;WebGLCompressedTextureASTC.h&quot;
  #include &quot;WebGLCompressedTextureATC.h&quot;
<span class="udiff-line-added">+ #include &quot;WebGLCompressedTextureETC.h&quot;</span>
<span class="udiff-line-added">+ #include &quot;WebGLCompressedTextureETC1.h&quot;</span>
  #include &quot;WebGLCompressedTexturePVRTC.h&quot;
  #include &quot;WebGLCompressedTextureS3TC.h&quot;
  #include &quot;WebGLContextAttributes.h&quot;
  #include &quot;WebGLContextEvent.h&quot;
  #include &quot;WebGLContextGroup.h&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -105,21 +106,25 @@</span>
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/UniqueArray.h&gt;
  #include &lt;wtf/text/CString.h&gt;
  #include &lt;wtf/text/StringBuilder.h&gt;
  
<span class="udiff-line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="udiff-line-added">+ #include &quot;OffscreenCanvas.h&quot;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
  namespace WebCore {
  
  WTF_MAKE_ISO_ALLOCATED_IMPL(WebGLRenderingContextBase);
  
  static const Seconds secondsBetweenRestoreAttempts { 1_s };
  const int maxGLErrorsAllowedToConsole = 256;
  static const Seconds checkContextLossHandlingDelay { 3_s };
  
  namespace {
  
<span class="udiff-line-modified-removed">-     GC3Dint clamp(GC3Dint value, GC3Dint min, GC3Dint max)</span>
<span class="udiff-line-modified-added">+     GCGLint clamp(GCGLint value, GCGLint min, GCGLint max)</span>
      {
          if (value &lt; min)
              value = min;
          if (value &gt; max)
              value = max;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -332,23 +337,23 @@</span>
          }
      }
  } // namespace anonymous
  
  // Returns false if no clipping is necessary, i.e., x, y, width, height stay the same.
<span class="udiff-line-modified-removed">- static bool clip2D(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height,</span>
<span class="udiff-line-modified-removed">-     GC3Dsizei sourceWidth, GC3Dsizei sourceHeight,</span>
<span class="udiff-line-modified-removed">-     GC3Dint* clippedX, GC3Dint* clippedY, GC3Dsizei* clippedWidth, GC3Dsizei*clippedHeight)</span>
<span class="udiff-line-modified-added">+ static bool clip2D(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height,</span>
<span class="udiff-line-modified-added">+     GCGLsizei sourceWidth, GCGLsizei sourceHeight,</span>
<span class="udiff-line-modified-added">+     GCGLint* clippedX, GCGLint* clippedY, GCGLsizei* clippedWidth, GCGLsizei*clippedHeight)</span>
  {
      ASSERT(clippedX &amp;&amp; clippedY &amp;&amp; clippedWidth &amp;&amp; clippedHeight);
  
<span class="udiff-line-modified-removed">-     GC3Dint left = std::max(x, 0);</span>
<span class="udiff-line-modified-removed">-     GC3Dint top = std::max(y, 0);</span>
<span class="udiff-line-modified-removed">-     GC3Dint right = 0;</span>
<span class="udiff-line-modified-removed">-     GC3Dint bottom = 0;</span>
<span class="udiff-line-modified-added">+     GCGLint left = std::max(x, 0);</span>
<span class="udiff-line-modified-added">+     GCGLint top = std::max(y, 0);</span>
<span class="udiff-line-modified-added">+     GCGLint right = 0;</span>
<span class="udiff-line-modified-added">+     GCGLint bottom = 0;</span>
  
<span class="udiff-line-modified-removed">-     Checked&lt;GC3Dint, RecordOverflow&gt; checkedInputRight = Checked&lt;GC3Dint&gt;(x) + Checked&lt;GC3Dsizei&gt;(width);</span>
<span class="udiff-line-modified-removed">-     Checked&lt;GC3Dint, RecordOverflow&gt; checkedInputBottom = Checked&lt;GC3Dint&gt;(y) + Checked&lt;GC3Dsizei&gt;(height);</span>
<span class="udiff-line-modified-added">+     Checked&lt;GCGLint, RecordOverflow&gt; checkedInputRight = Checked&lt;GCGLint&gt;(x) + Checked&lt;GCGLsizei&gt;(width);</span>
<span class="udiff-line-modified-added">+     Checked&lt;GCGLint, RecordOverflow&gt; checkedInputBottom = Checked&lt;GCGLint&gt;(y) + Checked&lt;GCGLsizei&gt;(height);</span>
      if (!checkedInputRight.hasOverflowed() &amp;&amp; !checkedInputBottom.hasOverflowed()) {
          right = std::min(checkedInputRight.unsafeGet(), sourceWidth);
          bottom = std::min(checkedInputBottom.unsafeGet(), sourceHeight);
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -366,36 +371,10 @@</span>
      *clippedHeight = bottom - top;
  
      return (*clippedX != x || *clippedY != y || *clippedWidth != width || *clippedHeight != height);
  }
  
<span class="udiff-line-removed">- class WebGLRenderingContextLostCallback : public GraphicsContext3D::ContextLostCallback {</span>
<span class="udiff-line-removed">-     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="udiff-line-removed">- public:</span>
<span class="udiff-line-removed">-     explicit WebGLRenderingContextLostCallback(WebGLRenderingContextBase* cb) : m_context(cb) { }</span>
<span class="udiff-line-removed">-     virtual ~WebGLRenderingContextLostCallback() = default;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     void onContextLost() override { m_context-&gt;forceLostContext(WebGLRenderingContext::RealLostContext); }</span>
<span class="udiff-line-removed">- private:</span>
<span class="udiff-line-removed">-     WebGLRenderingContextBase* m_context;</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- class WebGLRenderingContextErrorMessageCallback : public GraphicsContext3D::ErrorMessageCallback {</span>
<span class="udiff-line-removed">-     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="udiff-line-removed">- public:</span>
<span class="udiff-line-removed">-     explicit WebGLRenderingContextErrorMessageCallback(WebGLRenderingContextBase* cb) : m_context(cb) { }</span>
<span class="udiff-line-removed">-     virtual ~WebGLRenderingContextErrorMessageCallback() = default;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     void onErrorMessage(const String&amp; message, GC3Dint) override</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         if (m_context-&gt;m_synthesizedErrorsToConsole)</span>
<span class="udiff-line-removed">-             m_context-&gt;printToConsole(MessageLevel::Error, message);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- private:</span>
<span class="udiff-line-removed">-     WebGLRenderingContextBase* m_context;</span>
<span class="udiff-line-removed">- };</span>
<span class="udiff-line-removed">- </span>
  class InspectorScopedShaderProgramHighlight {
  public:
      InspectorScopedShaderProgramHighlight(WebGLRenderingContextBase&amp; context, WebGLProgram* program)
          : m_context(context)
          , m_program(program)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -409,55 +388,55 @@</span>
      }
  
  private:
      void showHightlight()
      {
<span class="udiff-line-modified-removed">-         if (!m_program || LIKELY(!InspectorInstrumentation::isShaderProgramHighlighted(m_context, *m_program)))</span>
<span class="udiff-line-modified-added">+         if (!m_program || LIKELY(!InspectorInstrumentation::isWebGLProgramHighlighted(m_context, *m_program)))</span>
              return;
  
<span class="udiff-line-modified-removed">-         if (hasBufferBinding(GraphicsContext3D::FRAMEBUFFER_BINDING)) {</span>
<span class="udiff-line-modified-removed">-             if (!hasBufferBinding(GraphicsContext3D::RENDERBUFFER_BINDING))</span>
<span class="udiff-line-modified-added">+         if (hasBufferBinding(GraphicsContextGL::FRAMEBUFFER_BINDING)) {</span>
<span class="udiff-line-modified-added">+             if (!hasBufferBinding(GraphicsContextGL::RENDERBUFFER_BINDING))</span>
                  return;
<span class="udiff-line-modified-removed">-             if (hasFramebufferParameterAttachment(GraphicsContext3D::DEPTH_ATTACHMENT))</span>
<span class="udiff-line-modified-added">+             if (hasFramebufferParameterAttachment(GraphicsContextGL::DEPTH_ATTACHMENT))</span>
                  return;
<span class="udiff-line-modified-removed">-             if (hasFramebufferParameterAttachment(GraphicsContext3D::STENCIL_ATTACHMENT))</span>
<span class="udiff-line-modified-added">+             if (hasFramebufferParameterAttachment(GraphicsContextGL::STENCIL_ATTACHMENT))</span>
                  return;
  #if ENABLE(WEBGL2)
<span class="udiff-line-modified-removed">-             if (hasFramebufferParameterAttachment(GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT))</span>
<span class="udiff-line-modified-added">+             if (hasFramebufferParameterAttachment(GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT))</span>
                  return;
  #endif
          }
  
<span class="udiff-line-modified-removed">-         saveBlendValue(GraphicsContext3D::BLEND_COLOR, m_savedBlend.color);</span>
<span class="udiff-line-modified-removed">-         saveBlendValue(GraphicsContext3D::BLEND_EQUATION_RGB, m_savedBlend.equationRGB);</span>
<span class="udiff-line-modified-removed">-         saveBlendValue(GraphicsContext3D::BLEND_EQUATION_ALPHA, m_savedBlend.equationAlpha);</span>
<span class="udiff-line-modified-removed">-         saveBlendValue(GraphicsContext3D::BLEND_SRC_RGB, m_savedBlend.srcRGB);</span>
<span class="udiff-line-modified-removed">-         saveBlendValue(GraphicsContext3D::BLEND_SRC_ALPHA, m_savedBlend.srcAlpha);</span>
<span class="udiff-line-modified-removed">-         saveBlendValue(GraphicsContext3D::BLEND_DST_RGB, m_savedBlend.dstRGB);</span>
<span class="udiff-line-modified-removed">-         saveBlendValue(GraphicsContext3D::BLEND_DST_ALPHA, m_savedBlend.dstAlpha);</span>
<span class="udiff-line-modified-removed">-         saveBlendValue(GraphicsContext3D::BLEND, m_savedBlend.enabled);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         static const GC3Dfloat red = 111.0 / 255.0;</span>
<span class="udiff-line-modified-removed">-         static const GC3Dfloat green = 168.0 / 255.0;</span>
<span class="udiff-line-modified-removed">-         static const GC3Dfloat blue = 220.0 / 255.0;</span>
<span class="udiff-line-modified-removed">-         static const GC3Dfloat alpha = 2.0 / 3.0;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         m_context.enable(GraphicsContext3D::BLEND);</span>
<span class="udiff-line-modified-added">+         saveBlendValue(GraphicsContextGL::BLEND_COLOR, m_savedBlend.color);</span>
<span class="udiff-line-modified-added">+         saveBlendValue(GraphicsContextGL::BLEND_EQUATION_RGB, m_savedBlend.equationRGB);</span>
<span class="udiff-line-modified-added">+         saveBlendValue(GraphicsContextGL::BLEND_EQUATION_ALPHA, m_savedBlend.equationAlpha);</span>
<span class="udiff-line-modified-added">+         saveBlendValue(GraphicsContextGL::BLEND_SRC_RGB, m_savedBlend.srcRGB);</span>
<span class="udiff-line-modified-added">+         saveBlendValue(GraphicsContextGL::BLEND_SRC_ALPHA, m_savedBlend.srcAlpha);</span>
<span class="udiff-line-modified-added">+         saveBlendValue(GraphicsContextGL::BLEND_DST_RGB, m_savedBlend.dstRGB);</span>
<span class="udiff-line-modified-added">+         saveBlendValue(GraphicsContextGL::BLEND_DST_ALPHA, m_savedBlend.dstAlpha);</span>
<span class="udiff-line-modified-added">+         saveBlendValue(GraphicsContextGL::BLEND, m_savedBlend.enabled);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         static const GCGLfloat red = 111.0 / 255.0;</span>
<span class="udiff-line-modified-added">+         static const GCGLfloat green = 168.0 / 255.0;</span>
<span class="udiff-line-modified-added">+         static const GCGLfloat blue = 220.0 / 255.0;</span>
<span class="udiff-line-modified-added">+         static const GCGLfloat alpha = 2.0 / 3.0;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+         m_context.enable(GraphicsContextGL::BLEND);</span>
          m_context.blendColor(red, green, blue, alpha);
<span class="udiff-line-modified-removed">-         m_context.blendEquation(GraphicsContext3D::FUNC_ADD);</span>
<span class="udiff-line-modified-removed">-         m_context.blendFunc(GraphicsContext3D::CONSTANT_COLOR, GraphicsContext3D::ONE_MINUS_SRC_ALPHA);</span>
<span class="udiff-line-modified-added">+         m_context.blendEquation(GraphicsContextGL::FUNC_ADD);</span>
<span class="udiff-line-modified-added">+         m_context.blendFunc(GraphicsContextGL::CONSTANT_COLOR, GraphicsContextGL::ONE_MINUS_SRC_ALPHA);</span>
  
          m_didApply = true;
      }
  
      void hideHighlight()
      {
          if (!m_didApply)
              return;
  
          if (!m_savedBlend.enabled)
<span class="udiff-line-modified-removed">-             m_context.disable(GraphicsContext3D::BLEND);</span>
<span class="udiff-line-modified-added">+             m_context.disable(GraphicsContextGL::BLEND);</span>
  
          const RefPtr&lt;Float32Array&gt;&amp; color = m_savedBlend.color;
          m_context.blendColor(color-&gt;item(0), color-&gt;item(1), color-&gt;item(2), color-&gt;item(3));
          m_context.blendEquationSeparate(m_savedBlend.equationRGB, m_savedBlend.equationAlpha);
          m_context.blendFuncSeparate(m_savedBlend.srcRGB, m_savedBlend.dstRGB, m_savedBlend.srcAlpha, m_savedBlend.dstAlpha);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -466,33 +445,33 @@</span>
  
          m_didApply = false;
      }
  
      template &lt;typename T&gt;
<span class="udiff-line-modified-removed">-     void saveBlendValue(GC3Denum attachment, T&amp; destination)</span>
<span class="udiff-line-modified-added">+     void saveBlendValue(GCGLenum attachment, T&amp; destination)</span>
      {
          WebGLAny param = m_context.getParameter(attachment);
          if (WTF::holds_alternative&lt;T&gt;(param))
              destination = WTF::get&lt;T&gt;(param);
      }
  
<span class="udiff-line-modified-removed">-     bool hasBufferBinding(GC3Denum pname)</span>
<span class="udiff-line-modified-added">+     bool hasBufferBinding(GCGLenum pname)</span>
      {
          WebGLAny binding = m_context.getParameter(pname);
<span class="udiff-line-modified-removed">-         if (pname == GraphicsContext3D::FRAMEBUFFER_BINDING)</span>
<span class="udiff-line-modified-added">+         if (pname == GraphicsContextGL::FRAMEBUFFER_BINDING)</span>
              return WTF::holds_alternative&lt;RefPtr&lt;WebGLFramebuffer&gt;&gt;(binding) &amp;&amp; WTF::get&lt;RefPtr&lt;WebGLFramebuffer&gt;&gt;(binding);
<span class="udiff-line-modified-removed">-         if (pname == GraphicsContext3D::RENDERBUFFER_BINDING)</span>
<span class="udiff-line-modified-added">+         if (pname == GraphicsContextGL::RENDERBUFFER_BINDING)</span>
              return WTF::holds_alternative&lt;RefPtr&lt;WebGLRenderbuffer&gt;&gt;(binding) &amp;&amp; WTF::get&lt;RefPtr&lt;WebGLRenderbuffer&gt;&gt;(binding);
          return false;
      }
  
<span class="udiff-line-modified-removed">-     bool hasFramebufferParameterAttachment(GC3Denum attachment)</span>
<span class="udiff-line-modified-added">+     bool hasFramebufferParameterAttachment(GCGLenum attachment)</span>
      {
<span class="udiff-line-modified-removed">-         WebGLAny attachmentParameter = m_context.getFramebufferAttachmentParameter(GraphicsContext3D::FRAMEBUFFER, attachment, GraphicsContext3D::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE);</span>
<span class="udiff-line-modified-added">+         WebGLAny attachmentParameter = m_context.getFramebufferAttachmentParameter(GraphicsContextGL::FRAMEBUFFER, attachment, GraphicsContextGL::FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE);</span>
          if (!WTF::holds_alternative&lt;unsigned&gt;(attachmentParameter))
              return false;
<span class="udiff-line-modified-removed">-         if (WTF::get&lt;unsigned&gt;(attachmentParameter) != static_cast&lt;unsigned&gt;(GraphicsContext3D::RENDERBUFFER))</span>
<span class="udiff-line-modified-added">+         if (WTF::get&lt;unsigned&gt;(attachmentParameter) != static_cast&lt;unsigned&gt;(GraphicsContextGL::RENDERBUFFER))</span>
              return false;
          return true;
      }
  
      struct {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -509,11 +488,11 @@</span>
      WebGLRenderingContextBase&amp; m_context;
      WebGLProgram* m_program { nullptr };
      bool m_didApply { false };
  };
  
<span class="udiff-line-modified-removed">- static bool isHighPerformanceContext(const RefPtr&lt;GraphicsContext3D&gt;&amp; context)</span>
<span class="udiff-line-modified-added">+ static bool isHighPerformanceContext(const RefPtr&lt;GraphicsContextGLOpenGL&gt;&amp; context)</span>
  {
      return context-&gt;powerPreferenceUsedForCreation() == WebGLPowerPreference::HighPerformance;
  }
  
  std::unique_ptr&lt;WebGLRenderingContextBase&gt; WebGLRenderingContextBase::create(CanvasBase&amp; canvas, WebGLContextAttributes&amp; attributes, const String&amp; type)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -561,13 +540,13 @@</span>
                  isPendingPolicyResolution = true;
              }
          }
  
          if (frame-&gt;settings().forceWebGLUsesLowPower()) {
<span class="udiff-line-modified-removed">-             if (attributes.powerPreference == GraphicsContext3DPowerPreference::HighPerformance)</span>
<span class="udiff-line-modified-added">+             if (attributes.powerPreference == GraphicsContextGLPowerPreference::HighPerformance)</span>
                  LOG(WebGL, &quot;Overriding powerPreference from high-performance to low-power.&quot;);
<span class="udiff-line-modified-removed">-             attributes.powerPreference = GraphicsContext3DPowerPreference::LowPower;</span>
<span class="udiff-line-modified-added">+             attributes.powerPreference = GraphicsContextGLPowerPreference::LowPower;</span>
          }
  
          if (page)
              attributes.devicePixelRatio = page-&gt;deviceScaleFactor();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -596,11 +575,11 @@</span>
              renderingContext = WebGLRenderingContext::create(canvas, attributes);
          renderingContext-&gt;suspendIfNeeded();
          return renderingContext;
      }
  
<span class="udiff-line-modified-removed">-     auto context = GraphicsContext3D::create(attributes, hostWindow);</span>
<span class="udiff-line-modified-added">+     auto context = GraphicsContextGLOpenGL::create(attributes, hostWindow);</span>
      if (!context || !context-&gt;makeContextCurrent()) {
          if (canvasElement) {
              canvasElement-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextcreationerrorEvent,
                  Event::CanBubble::No, Event::IsCancelable::Yes, &quot;Could not create a WebGL context.&quot;));
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -609,11 +588,11 @@</span>
  
      auto&amp; extensions = context-&gt;getExtensions();
      if (extensions.supports(&quot;GL_EXT_debug_marker&quot;_s))
          extensions.pushGroupMarkerEXT(&quot;WebGLRenderingContext&quot;_s);
  
<span class="udiff-line-modified-removed">- #if ENABLE(WEBGL2) &amp;&amp; PLATFORM(MAC)</span>
<span class="udiff-line-modified-added">+ #if ENABLE(WEBGL2) &amp;&amp; PLATFORM(MAC) &amp;&amp; !USE(ANGLE)</span>
      // glTexStorage() was only added to Core in OpenGL 4.2.
      // However, according to https://developer.apple.com/opengl/capabilities/ all Apple GPUs support this extension.
      if (attributes.isWebGL2 &amp;&amp; !extensions.supports(&quot;GL_ARB_texture_storage&quot;))
          return nullptr;
  #endif
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -630,37 +609,47 @@</span>
      return renderingContext;
  }
  
  WebGLRenderingContextBase::WebGLRenderingContextBase(CanvasBase&amp; canvas, WebGLContextAttributes attributes)
      : GPUBasedCanvasRenderingContext(canvas)
<span class="udiff-line-modified-removed">-     , m_dispatchContextLostEventTimer(*this, &amp;WebGLRenderingContextBase::dispatchContextLostEvent)</span>
<span class="udiff-line-modified-removed">-     , m_restoreTimer(*this, &amp;WebGLRenderingContextBase::maybeRestoreContext)</span>
<span class="udiff-line-modified-added">+     , m_dispatchContextLostEventTimer(canvas.scriptExecutionContext(), *this, &amp;WebGLRenderingContextBase::dispatchContextLostEvent)</span>
<span class="udiff-line-modified-added">+     , m_dispatchContextChangedEventTimer(canvas.scriptExecutionContext(), *this, &amp;WebGLRenderingContextBase::dispatchContextChangedEvent)</span>
<span class="udiff-line-added">+     , m_restoreTimer(canvas.scriptExecutionContext(), *this, &amp;WebGLRenderingContextBase::maybeRestoreContext)</span>
      , m_attributes(attributes)
      , m_numGLErrorsToConsoleAllowed(maxGLErrorsAllowedToConsole)
      , m_isPendingPolicyResolution(true)
      , m_checkForContextLossHandlingTimer(*this, &amp;WebGLRenderingContextBase::checkForContextLossHandling)
  {
<span class="udiff-line-added">+     m_dispatchContextLostEventTimer.suspendIfNeeded();</span>
<span class="udiff-line-added">+     m_dispatchContextChangedEventTimer.suspendIfNeeded();</span>
<span class="udiff-line-added">+     m_restoreTimer.suspendIfNeeded();</span>
<span class="udiff-line-added">+ </span>
      registerWithWebGLStateTracker();
      m_checkForContextLossHandlingTimer.startOneShot(checkContextLossHandlingDelay);
  }
  
<span class="udiff-line-modified-removed">- WebGLRenderingContextBase::WebGLRenderingContextBase(CanvasBase&amp; canvas, Ref&lt;GraphicsContext3D&gt;&amp;&amp; context, WebGLContextAttributes attributes)</span>
<span class="udiff-line-modified-added">+ WebGLRenderingContextBase::WebGLRenderingContextBase(CanvasBase&amp; canvas, Ref&lt;GraphicsContextGLOpenGL&gt;&amp;&amp; context, WebGLContextAttributes attributes)</span>
      : GPUBasedCanvasRenderingContext(canvas)
      , m_context(WTFMove(context))
<span class="udiff-line-modified-removed">-     , m_dispatchContextLostEventTimer(*this, &amp;WebGLRenderingContextBase::dispatchContextLostEvent)</span>
<span class="udiff-line-modified-removed">-     , m_restoreTimer(*this, &amp;WebGLRenderingContextBase::maybeRestoreContext)</span>
<span class="udiff-line-modified-added">+     , m_dispatchContextLostEventTimer(canvas.scriptExecutionContext(), *this, &amp;WebGLRenderingContextBase::dispatchContextLostEvent)</span>
<span class="udiff-line-modified-added">+     , m_dispatchContextChangedEventTimer(canvas.scriptExecutionContext(), *this, &amp;WebGLRenderingContextBase::dispatchContextChangedEvent)</span>
<span class="udiff-line-added">+     , m_restoreTimer(canvas.scriptExecutionContext(), *this, &amp;WebGLRenderingContextBase::maybeRestoreContext)</span>
      , m_generatedImageCache(4)
      , m_attributes(attributes)
      , m_numGLErrorsToConsoleAllowed(maxGLErrorsAllowedToConsole)
      , m_checkForContextLossHandlingTimer(*this, &amp;WebGLRenderingContextBase::checkForContextLossHandling)
  {
<span class="udiff-line-added">+     m_dispatchContextLostEventTimer.suspendIfNeeded();</span>
<span class="udiff-line-added">+     m_dispatchContextChangedEventTimer.suspendIfNeeded();</span>
<span class="udiff-line-added">+     m_restoreTimer.suspendIfNeeded();</span>
<span class="udiff-line-added">+ </span>
      m_contextGroup = WebGLContextGroup::create();
      m_contextGroup-&gt;addContext(*this);
  
      m_context-&gt;addClient(*this);
  
<span class="udiff-line-modified-removed">-     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_VIEWPORT_DIMS, m_maxViewportDims);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;getIntegerv(GraphicsContextGL::MAX_VIEWPORT_DIMS, m_maxViewportDims);</span>
  
      setupFlags();
      initializeNewContext();
      registerWithWebGLStateTracker();
      m_checkForContextLossHandlingTimer.startOneShot(checkContextLossHandlingDelay);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -669,22 +658,26 @@</span>
  }
  
  WebGLCanvas WebGLRenderingContextBase::canvas()
  {
      auto&amp; base = canvasBase();
<span class="udiff-line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
      if (is&lt;OffscreenCanvas&gt;(base))
          return &amp;downcast&lt;OffscreenCanvas&gt;(base);
<span class="udiff-line-added">+ #endif</span>
      return &amp;downcast&lt;HTMLCanvasElement&gt;(base);
  }
  
<span class="udiff-line-added">+ #if ENABLE(OFFSCREEN_CANVAS)</span>
  OffscreenCanvas* WebGLRenderingContextBase::offscreenCanvas()
  {
      auto&amp; base = canvasBase();
      if (!is&lt;OffscreenCanvas&gt;(base))
          return nullptr;
      return &amp;downcast&lt;OffscreenCanvas&gt;(base);
  }
<span class="udiff-line-added">+ #endif</span>
  
  // We check for context loss handling after a few seconds to give the JS a chance to register the event listeners
  // and to discard temporary GL contexts (e.g. feature detection).
  void WebGLRenderingContextBase::checkForContextLossHandling()
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -728,11 +721,11 @@</span>
      m_activeTextureUnit = 0;
      m_packAlignment = 4;
      m_unpackAlignment = 4;
      m_unpackFlipY = false;
      m_unpackPremultiplyAlpha = false;
<span class="udiff-line-modified-removed">-     m_unpackColorspaceConversion = GraphicsContext3D::BROWSER_DEFAULT_WEBGL;</span>
<span class="udiff-line-modified-added">+     m_unpackColorspaceConversion = GraphicsContextGL::BROWSER_DEFAULT_WEBGL;</span>
      m_boundArrayBuffer = nullptr;
      m_currentProgram = nullptr;
      m_framebufferBinding = nullptr;
      m_readFramebufferBinding = nullptr;
      m_renderbufferBinding = nullptr;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -751,35 +744,35 @@</span>
      m_scissorEnabled = false;
      m_clearDepth = 1;
      m_clearStencil = 0;
      m_colorMask[0] = m_colorMask[1] = m_colorMask[2] = m_colorMask[3] = true;
  
<span class="udiff-line-modified-removed">-     GC3Dint numCombinedTextureImageUnits = 0;</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_COMBINED_TEXTURE_IMAGE_UNITS, &amp;numCombinedTextureImageUnits);</span>
<span class="udiff-line-modified-added">+     GCGLint numCombinedTextureImageUnits = 0;</span>
<span class="udiff-line-modified-added">+     m_context-&gt;getIntegerv(GraphicsContextGL::MAX_COMBINED_TEXTURE_IMAGE_UNITS, &amp;numCombinedTextureImageUnits);</span>
      m_textureUnits.clear();
      m_textureUnits.resize(numCombinedTextureImageUnits);
<span class="udiff-line-modified-removed">-     for (GC3Dint i = 0; i &lt; numCombinedTextureImageUnits; ++i)</span>
<span class="udiff-line-modified-added">+     for (GCGLint i = 0; i &lt; numCombinedTextureImageUnits; ++i)</span>
          m_unrenderableTextureUnits.add(i);
  
<span class="udiff-line-modified-removed">-     GC3Dint numVertexAttribs = 0;</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_VERTEX_ATTRIBS, &amp;numVertexAttribs);</span>
<span class="udiff-line-modified-added">+     GCGLint numVertexAttribs = 0;</span>
<span class="udiff-line-modified-added">+     m_context-&gt;getIntegerv(GraphicsContextGL::MAX_VERTEX_ATTRIBS, &amp;numVertexAttribs);</span>
      m_maxVertexAttribs = numVertexAttribs;
  
      m_maxTextureSize = 0;
<span class="udiff-line-modified-removed">-     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_TEXTURE_SIZE, &amp;m_maxTextureSize);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;getIntegerv(GraphicsContextGL::MAX_TEXTURE_SIZE, &amp;m_maxTextureSize);</span>
      m_maxTextureLevel = WebGLTexture::computeLevelCount(m_maxTextureSize, m_maxTextureSize);
      m_maxCubeMapTextureSize = 0;
<span class="udiff-line-modified-removed">-     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_CUBE_MAP_TEXTURE_SIZE, &amp;m_maxCubeMapTextureSize);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;getIntegerv(GraphicsContextGL::MAX_CUBE_MAP_TEXTURE_SIZE, &amp;m_maxCubeMapTextureSize);</span>
      m_maxCubeMapTextureLevel = WebGLTexture::computeLevelCount(m_maxCubeMapTextureSize, m_maxCubeMapTextureSize);
      m_maxRenderbufferSize = 0;
<span class="udiff-line-modified-removed">-     m_context-&gt;getIntegerv(GraphicsContext3D::MAX_RENDERBUFFER_SIZE, &amp;m_maxRenderbufferSize);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;getIntegerv(GraphicsContextGL::MAX_RENDERBUFFER_SIZE, &amp;m_maxRenderbufferSize);</span>
  
      // These two values from EXT_draw_buffers are lazily queried.
      m_maxDrawBuffers = 0;
      m_maxColorAttachments = 0;
  
<span class="udiff-line-modified-removed">-     m_backDrawBuffer = GraphicsContext3D::BACK;</span>
<span class="udiff-line-modified-added">+     m_backDrawBuffer = GraphicsContextGL::BACK;</span>
      m_drawBuffersWebGLRequirementsChecked = false;
      m_drawBuffersSupported = false;
  
      m_vertexAttribValue.resize(m_maxVertexAttribs);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -788,13 +781,10 @@</span>
  
      IntSize canvasSize = clampedCanvasSize();
      m_context-&gt;reshape(canvasSize.width(), canvasSize.height());
      m_context-&gt;viewport(0, 0, canvasSize.width(), canvasSize.height());
      m_context-&gt;scissor(0, 0, canvasSize.width(), canvasSize.height());
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     m_context-&gt;setContextLostCallback(makeUnique&lt;WebGLRenderingContextLostCallback&gt;(this));</span>
<span class="udiff-line-removed">-     m_context-&gt;setErrorMessageCallback(makeUnique&lt;WebGLRenderingContextErrorMessageCallback&gt;(this));</span>
  }
  
  void WebGLRenderingContextBase::setupFlags()
  {
      ASSERT(m_context);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -806,19 +796,19 @@</span>
      }
  
      m_isGLES2Compliant = m_context-&gt;isGLES2Compliant();
      if (m_isGLES2Compliant) {
          m_isGLES2NPOTStrict = !m_context-&gt;getExtensions().isEnabled(&quot;GL_OES_texture_npot&quot;);
<span class="udiff-line-modified-removed">-         m_isDepthStencilSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_OES_packed_depth_stencil&quot;);</span>
<span class="udiff-line-modified-added">+         m_isDepthStencilSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_OES_packed_depth_stencil&quot;) || m_context-&gt;getExtensions().isEnabled(&quot;GL_ANGLE_depth_texture&quot;);</span>
      } else {
          m_isGLES2NPOTStrict = !m_context-&gt;getExtensions().isEnabled(&quot;GL_ARB_texture_non_power_of_two&quot;);
<span class="udiff-line-modified-removed">-         m_isDepthStencilSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_EXT_packed_depth_stencil&quot;);</span>
<span class="udiff-line-modified-added">+         m_isDepthStencilSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_EXT_packed_depth_stencil&quot;) || m_context-&gt;getExtensions().isEnabled(&quot;GL_ANGLE_depth_texture&quot;);</span>
      }
      m_isRobustnessEXTSupported = m_context-&gt;getExtensions().isEnabled(&quot;GL_EXT_robustness&quot;);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::addCompressedTextureFormat(GC3Denum format)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::addCompressedTextureFormat(GCGLenum format)</span>
  {
      if (!m_compressedTextureFormats.contains(format))
          m_compressedTextureFormats.append(format);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -875,11 +865,11 @@</span>
      m_blackTexture2D = nullptr;
      m_blackTextureCubeMap = nullptr;
  
      if (!m_isPendingPolicyResolution) {
          detachAndRemoveAllObjects();
<span class="udiff-line-modified-removed">-         destroyGraphicsContext3D();</span>
<span class="udiff-line-modified-added">+         destroyGraphicsContextGL();</span>
          m_contextGroup-&gt;removeContext(*this);
      }
  
      {
          LockHolder lock(WebGLProgram::instancesMutex());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -891,21 +881,19 @@</span>
              }
          }
      }
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::destroyGraphicsContext3D()</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::destroyGraphicsContextGL()</span>
  {
      if (m_isPendingPolicyResolution)
          return;
  
      removeActivityStateChangeObserver();
  
      if (m_context) {
          m_context-&gt;removeClient(*this);
<span class="udiff-line-removed">-         m_context-&gt;setContextLostCallback(nullptr);</span>
<span class="udiff-line-removed">-         m_context-&gt;setErrorMessageCallback(nullptr);</span>
          m_context = nullptr;
      }
  }
  
  void WebGLRenderingContextBase::markContextChanged()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -947,11 +935,11 @@</span>
      RenderBox* renderBox = canvas-&gt;renderBox();
      if (renderBox &amp;&amp; renderBox-&gt;hasAcceleratedCompositing())
          canvas-&gt;notifyObserversCanvasChanged(FloatRect(FloatPoint(0, 0), clampedCanvasSize()));
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::clearIfComposited(GC3Dbitfield mask)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::clearIfComposited(GCGLbitfield mask)</span>
  {
      if (isContextLostOrPending())
          return false;
  
      if (!m_context-&gt;layerComposited() || m_layerCleared
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -963,58 +951,58 @@</span>
      ASSERT(contextAttributes);
  
      // Determine if it&#39;s possible to combine the clear the user asked for and this clear.
      bool combinedClear = mask &amp;&amp; !m_scissorEnabled;
  
<span class="udiff-line-modified-removed">-     m_context-&gt;disable(GraphicsContext3D::SCISSOR_TEST);</span>
<span class="udiff-line-modified-removed">-     if (combinedClear &amp;&amp; (mask &amp; GraphicsContext3D::COLOR_BUFFER_BIT))</span>
<span class="udiff-line-modified-added">+     m_context-&gt;disable(GraphicsContextGL::SCISSOR_TEST);</span>
<span class="udiff-line-modified-added">+     if (combinedClear &amp;&amp; (mask &amp; GraphicsContextGL::COLOR_BUFFER_BIT)) {</span>
          m_context-&gt;clearColor(m_colorMask[0] ? m_clearColor[0] : 0,
                                m_colorMask[1] ? m_clearColor[1] : 0,
                                m_colorMask[2] ? m_clearColor[2] : 0,
                                m_colorMask[3] ? m_clearColor[3] : 0);
<span class="udiff-line-modified-removed">-     else</span>
<span class="udiff-line-modified-added">+     } else</span>
          m_context-&gt;clearColor(0, 0, 0, 0);
      m_context-&gt;colorMask(true, true, true, true);
<span class="udiff-line-modified-removed">-     GC3Dbitfield clearMask = GraphicsContext3D::COLOR_BUFFER_BIT;</span>
<span class="udiff-line-modified-added">+     GCGLbitfield clearMask = GraphicsContextGL::COLOR_BUFFER_BIT;</span>
      if (contextAttributes-&gt;depth) {
<span class="udiff-line-modified-removed">-         if (!combinedClear || !m_depthMask || !(mask &amp; GraphicsContext3D::DEPTH_BUFFER_BIT))</span>
<span class="udiff-line-modified-added">+         if (!combinedClear || !m_depthMask || !(mask &amp; GraphicsContextGL::DEPTH_BUFFER_BIT))</span>
              m_context-&gt;clearDepth(1.0f);
<span class="udiff-line-modified-removed">-         clearMask |= GraphicsContext3D::DEPTH_BUFFER_BIT;</span>
<span class="udiff-line-modified-added">+         clearMask |= GraphicsContextGL::DEPTH_BUFFER_BIT;</span>
          m_context-&gt;depthMask(true);
      }
      if (contextAttributes-&gt;stencil) {
<span class="udiff-line-modified-removed">-         if (combinedClear &amp;&amp; (mask &amp; GraphicsContext3D::STENCIL_BUFFER_BIT))</span>
<span class="udiff-line-modified-added">+         if (combinedClear &amp;&amp; (mask &amp; GraphicsContextGL::STENCIL_BUFFER_BIT))</span>
              m_context-&gt;clearStencil(m_clearStencil &amp; m_stencilMask);
          else
              m_context-&gt;clearStencil(0);
<span class="udiff-line-modified-removed">-         clearMask |= GraphicsContext3D::STENCIL_BUFFER_BIT;</span>
<span class="udiff-line-modified-removed">-         m_context-&gt;stencilMaskSeparate(GraphicsContext3D::FRONT, 0xFFFFFFFF);</span>
<span class="udiff-line-modified-added">+         clearMask |= GraphicsContextGL::STENCIL_BUFFER_BIT;</span>
<span class="udiff-line-modified-added">+         m_context-&gt;stencilMaskSeparate(GraphicsContextGL::FRONT, 0xFFFFFFFF);</span>
      }
      if (m_framebufferBinding)
<span class="udiff-line-modified-removed">-         m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, 0);</span>
<span class="udiff-line-modified-added">+         m_context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, 0);</span>
      m_context-&gt;clear(clearMask);
  
      restoreStateAfterClear();
      if (m_framebufferBinding)
<span class="udiff-line-modified-removed">-         m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, objectOrZero(m_framebufferBinding.get()));</span>
<span class="udiff-line-modified-added">+         m_context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, objectOrZero(m_framebufferBinding.get()));</span>
      m_layerCleared = true;
  
      return combinedClear;
  }
  
  void WebGLRenderingContextBase::restoreStateAfterClear()
  {
      // Restore the state that the context set.
      if (m_scissorEnabled)
<span class="udiff-line-modified-removed">-         m_context-&gt;enable(GraphicsContext3D::SCISSOR_TEST);</span>
<span class="udiff-line-modified-added">+         m_context-&gt;enable(GraphicsContextGL::SCISSOR_TEST);</span>
      m_context-&gt;clearColor(m_clearColor[0], m_clearColor[1],
                            m_clearColor[2], m_clearColor[3]);
      m_context-&gt;colorMask(m_colorMask[0], m_colorMask[1],
                           m_colorMask[2], m_colorMask[3]);
      m_context-&gt;clearDepth(m_clearDepth);
      m_context-&gt;clearStencil(m_clearStencil);
<span class="udiff-line-modified-removed">-     m_context-&gt;stencilMaskSeparate(GraphicsContext3D::FRONT, m_stencilMask);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;stencilMaskSeparate(GraphicsContextGL::FRONT, m_stencilMask);</span>
      m_context-&gt;depthMask(m_depthMask);
  }
  
  void WebGLRenderingContextBase::markLayerComposited()
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1072,13 +1060,13 @@</span>
      if (isContextLostOrPending())
          return;
  
      // This is an approximation because at WebGLRenderingContext level we don&#39;t
      // know if the underlying FBO uses textures or renderbuffers.
<span class="udiff-line-modified-removed">-     GC3Dint maxSize = std::min(m_maxTextureSize, m_maxRenderbufferSize);</span>
<span class="udiff-line-modified-removed">-     GC3Dint maxWidth = std::min(maxSize, m_maxViewportDims[0]);</span>
<span class="udiff-line-modified-removed">-     GC3Dint maxHeight = std::min(maxSize, m_maxViewportDims[1]);</span>
<span class="udiff-line-modified-added">+     GCGLint maxSize = std::min(m_maxTextureSize, m_maxRenderbufferSize);</span>
<span class="udiff-line-modified-added">+     GCGLint maxWidth = std::min(maxSize, m_maxViewportDims[0]);</span>
<span class="udiff-line-modified-added">+     GCGLint maxHeight = std::min(maxSize, m_maxViewportDims[1]);</span>
      width = clamp(width, 1, maxWidth);
      height = clamp(height, 1, maxHeight);
  
      if (m_needsUpdate) {
          notifyCanvasContentChanged();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1088,16 +1076,16 @@</span>
      // We don&#39;t have to mark the canvas as dirty, since the newly created image buffer will also start off
      // clear (and this matches what reshape will do).
      m_context-&gt;reshape(width, height);
  
      auto&amp; textureUnit = m_textureUnits[m_activeTextureUnit];
<span class="udiff-line-modified-removed">-     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, objectOrZero(textureUnit.texture2DBinding.get()));</span>
<span class="udiff-line-modified-added">+     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, objectOrZero(textureUnit.texture2DBinding.get()));</span>
      if (textureUnit.texture2DBinding &amp;&amp; textureUnit.texture2DBinding-&gt;needToUseBlackTexture(textureExtensionFlags()))
          m_unrenderableTextureUnits.add(m_activeTextureUnit);
<span class="udiff-line-modified-removed">-     m_context-&gt;bindRenderbuffer(GraphicsContext3D::RENDERBUFFER, objectOrZero(m_renderbufferBinding.get()));</span>
<span class="udiff-line-modified-added">+     m_context-&gt;bindRenderbuffer(GraphicsContextGL::RENDERBUFFER, objectOrZero(m_renderbufferBinding.get()));</span>
      if (m_framebufferBinding)
<span class="udiff-line-modified-removed">-       m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, objectOrZero(m_framebufferBinding.get()));</span>
<span class="udiff-line-modified-added">+         m_context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, objectOrZero(m_framebufferBinding.get()));</span>
  }
  
  int WebGLRenderingContextBase::drawingBufferWidth() const
  {
      if (isContextLost())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1118,70 +1106,70 @@</span>
          return 0;
  
      return m_context-&gt;getInternalFramebufferSize().height();
  }
  
<span class="udiff-line-modified-removed">- unsigned WebGLRenderingContextBase::sizeInBytes(GC3Denum type)</span>
<span class="udiff-line-modified-added">+ unsigned WebGLRenderingContextBase::sizeInBytes(GCGLenum type)</span>
  {
      switch (type) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::BYTE:</span>
<span class="udiff-line-modified-removed">-         return sizeof(GC3Dbyte);</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_BYTE:</span>
<span class="udiff-line-modified-removed">-         return sizeof(GC3Dubyte);</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::SHORT:</span>
<span class="udiff-line-modified-removed">-         return sizeof(GC3Dshort);</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_SHORT:</span>
<span class="udiff-line-modified-removed">-         return sizeof(GC3Dushort);</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::INT:</span>
<span class="udiff-line-modified-removed">-         return sizeof(GC3Dint);</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_INT:</span>
<span class="udiff-line-modified-removed">-         return sizeof(GC3Duint);</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::FLOAT:</span>
<span class="udiff-line-modified-removed">-         return sizeof(GC3Dfloat);</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::BYTE:</span>
<span class="udiff-line-modified-added">+         return sizeof(GCGLbyte);</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_BYTE:</span>
<span class="udiff-line-modified-added">+         return sizeof(GCGLubyte);</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::SHORT:</span>
<span class="udiff-line-modified-added">+         return sizeof(GCGLshort);</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_SHORT:</span>
<span class="udiff-line-modified-added">+         return sizeof(GCGLushort);</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::INT:</span>
<span class="udiff-line-modified-added">+         return sizeof(GCGLint);</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_INT:</span>
<span class="udiff-line-modified-added">+         return sizeof(GCGLuint);</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::FLOAT:</span>
<span class="udiff-line-modified-added">+         return sizeof(GCGLfloat);</span>
      }
      ASSERT_NOT_REACHED();
      return 0;
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::activeTexture(GC3Denum texture)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::activeTexture(GCGLenum texture)</span>
  {
      if (isContextLostOrPending())
          return;
<span class="udiff-line-modified-removed">-     if (texture - GraphicsContext3D::TEXTURE0 &gt;= m_textureUnits.size()) {</span>
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;activeTexture&quot;, &quot;texture unit out of range&quot;);</span>
<span class="udiff-line-modified-added">+     if (texture - GraphicsContextGL::TEXTURE0 &gt;= m_textureUnits.size()) {</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;activeTexture&quot;, &quot;texture unit out of range&quot;);</span>
          return;
      }
<span class="udiff-line-modified-removed">-     m_activeTextureUnit = texture - GraphicsContext3D::TEXTURE0;</span>
<span class="udiff-line-modified-added">+     m_activeTextureUnit = texture - GraphicsContextGL::TEXTURE0;</span>
      m_context-&gt;activeTexture(texture);
  }
  
  void WebGLRenderingContextBase::attachShader(WebGLProgram* program, WebGLShader* shader)
  {
      if (isContextLostOrPending() || !validateWebGLObject(&quot;attachShader&quot;, program) || !validateWebGLObject(&quot;attachShader&quot;, shader))
          return;
      if (!program-&gt;attachShader(shader)) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;attachShader&quot;, &quot;shader attachment already has shader&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;attachShader&quot;, &quot;shader attachment already has shader&quot;);</span>
          return;
      }
      m_context-&gt;attachShader(objectOrZero(program), objectOrZero(shader));
      shader-&gt;onAttached();
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::bindAttribLocation(WebGLProgram* program, GC3Duint index, const String&amp; name)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::bindAttribLocation(WebGLProgram* program, GCGLuint index, const String&amp; name)</span>
  {
      if (isContextLostOrPending() || !validateWebGLObject(&quot;bindAttribLocation&quot;, program))
          return;
      if (!validateLocationLength(&quot;bindAttribLocation&quot;, name))
          return;
      if (!validateString(&quot;bindAttribLocation&quot;, name))
          return;
      if (isPrefixReserved(name)) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;bindAttribLocation&quot;, &quot;reserved prefix&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;bindAttribLocation&quot;, &quot;reserved prefix&quot;);</span>
          return;
      }
      if (index &gt;= m_maxVertexAttribs) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bindAttribLocation&quot;, &quot;index out of range&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bindAttribLocation&quot;, &quot;index out of range&quot;);</span>
          return;
      }
      m_context-&gt;bindAttribLocation(objectOrZero(program), index, name);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1190,156 +1178,171 @@</span>
      deleted = false;
      if (isContextLostOrPending())
          return false;
      if (object) {
          if (!object-&gt;validate(contextGroup(), *this)) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;object not from this context&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;object not from this context&quot;);</span>
              return false;
          }
          deleted = !object-&gt;object();
      }
      return true;
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::bindBuffer(GC3Denum target, WebGLBuffer* buffer)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateAndCacheBufferBinding(const char* functionName, GCGLenum target, WebGLBuffer* buffer)</span>
  {
      bool deleted;
<span class="udiff-line-modified-removed">-     if (!checkObjectToBeBound(&quot;bindBuffer&quot;, buffer, deleted))</span>
<span class="udiff-line-modified-removed">-         return;</span>
<span class="udiff-line-modified-added">+     if (!checkObjectToBeBound(functionName, buffer, deleted))</span>
<span class="udiff-line-modified-added">+         return false;</span>
      if (deleted)
          buffer = nullptr;
<span class="udiff-line-modified-removed">-     if (buffer &amp;&amp; buffer-&gt;getTarget() &amp;&amp; buffer-&gt;getTarget() != target) {</span>
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;bindBuffer&quot;, &quot;buffers can not be used with multiple targets&quot;);</span>
<span class="udiff-line-modified-removed">-         return;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     if (buffer) {</span>
<span class="udiff-line-modified-added">+         // In WebGL, a buffer may only be bound to one of the ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER target in its lifetime.</span>
<span class="udiff-line-added">+         if (target == GraphicsContextGL::ARRAY_BUFFER || target == GraphicsContextGL::ELEMENT_ARRAY_BUFFER) {</span>
<span class="udiff-line-added">+             if (buffer-&gt;arrayBufferOrElementArrayBuffer() &amp;&amp; target != buffer-&gt;arrayBufferOrElementArrayBuffer()) {</span>
<span class="udiff-line-added">+                 synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;buffers can only be bound to one of ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER&quot;);</span>
<span class="udiff-line-added">+                 return false;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         buffer-&gt;setTarget(target);</span>
      }
<span class="udiff-line-modified-removed">-     if (target == GraphicsContext3D::ARRAY_BUFFER)</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     if (target == GraphicsContextGL::ARRAY_BUFFER)</span>
          m_boundArrayBuffer = buffer;
<span class="udiff-line-modified-removed">-     else if (target == GraphicsContext3D::ELEMENT_ARRAY_BUFFER)</span>
<span class="udiff-line-modified-added">+     else if (target == GraphicsContextGL::ELEMENT_ARRAY_BUFFER)</span>
          m_boundVertexArrayObject-&gt;setElementArrayBuffer(buffer);
      else {
          bool success = false;
  #if ENABLE(WEBGL2)
          if (isWebGL2()) {
              success = true;
              switch (target) {
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::COPY_READ_BUFFER:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::COPY_READ_BUFFER:</span>
                  m_boundCopyReadBuffer = buffer;
                  break;
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::COPY_WRITE_BUFFER:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::COPY_WRITE_BUFFER:</span>
                  m_boundCopyWriteBuffer = buffer;
                  break;
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::PIXEL_PACK_BUFFER:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::PIXEL_PACK_BUFFER:</span>
                  m_boundPixelPackBuffer = buffer;
                  break;
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::PIXEL_UNPACK_BUFFER:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::PIXEL_UNPACK_BUFFER:</span>
                  m_boundPixelUnpackBuffer = buffer;
                  break;
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:</span>
                  m_boundTransformFeedbackBuffer = buffer;
                  break;
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::UNIFORM_BUFFER:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::UNIFORM_BUFFER:</span>
                  m_boundUniformBuffer = buffer;
                  break;
              default:
                  success = false;
                  break;
              }
          }
  #endif
          if (!success) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;bindBuffer&quot;, &quot;invalid target&quot;);</span>
<span class="udiff-line-modified-removed">-             return;</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;bindBuffer&quot;, &quot;invalid target&quot;);</span>
<span class="udiff-line-modified-added">+             return false;</span>
          }
      }
  
<span class="udiff-line-added">+     return true;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void WebGLRenderingContextBase::bindBuffer(GCGLenum target, WebGLBuffer* buffer)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (!validateAndCacheBufferBinding(&quot;bindBuffer&quot;, target, buffer))</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+ </span>
      m_context-&gt;bindBuffer(target, objectOrZero(buffer));
<span class="udiff-line-removed">-     if (buffer)</span>
<span class="udiff-line-removed">-         buffer-&gt;setTarget(target, isWebGL2());</span>
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::bindFramebuffer(GC3Denum target, WebGLFramebuffer* buffer)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::bindFramebuffer(GCGLenum target, WebGLFramebuffer* buffer)</span>
  {
      bool deleted;
      if (!checkObjectToBeBound(&quot;bindFramebuffer&quot;, buffer, deleted))
          return;
      if (deleted)
          buffer = 0;
  
      bool isWebGL2DrawFramebufferTarget = false;
  #if ENABLE(WEBGL2)
<span class="udiff-line-modified-removed">-     isWebGL2DrawFramebufferTarget = isWebGL2() &amp;&amp; target == GraphicsContext3D::DRAW_FRAMEBUFFER;</span>
<span class="udiff-line-modified-added">+     isWebGL2DrawFramebufferTarget = isWebGL2() &amp;&amp; target == GraphicsContextGL::DRAW_FRAMEBUFFER;</span>
  #endif
      bool success = false;
  
<span class="udiff-line-modified-removed">-     if (target == GraphicsContext3D::FRAMEBUFFER || isWebGL2DrawFramebufferTarget) {</span>
<span class="udiff-line-modified-added">+     if (target == GraphicsContextGL::FRAMEBUFFER || isWebGL2DrawFramebufferTarget) {</span>
          m_framebufferBinding = buffer;
          success = true;
      }
  #if ENABLE(WEBGL2)
<span class="udiff-line-modified-removed">-     if (isWebGL2() &amp;&amp; (target == GraphicsContext3D::FRAMEBUFFER || target == GraphicsContext3D::READ_FRAMEBUFFER)) {</span>
<span class="udiff-line-modified-added">+     if (isWebGL2() &amp;&amp; (target == GraphicsContextGL::FRAMEBUFFER || target == GraphicsContextGL::READ_FRAMEBUFFER)) {</span>
          m_readFramebufferBinding = buffer;
          success = true;
      }
  #endif
  
      if (!success) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;bindFramebuffer&quot;, &quot;invalid target&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;bindFramebuffer&quot;, &quot;invalid target&quot;);</span>
          return;
      }
  
      m_context-&gt;bindFramebuffer(target, objectOrZero(buffer));
      if (buffer)
          buffer-&gt;setHasEverBeenBound();
      applyStencilTest();
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::bindRenderbuffer(GC3Denum target, WebGLRenderbuffer* renderBuffer)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::bindRenderbuffer(GCGLenum target, WebGLRenderbuffer* renderBuffer)</span>
  {
      bool deleted;
      if (!checkObjectToBeBound(&quot;bindRenderbuffer&quot;, renderBuffer, deleted))
          return;
      if (deleted)
          renderBuffer = 0;
<span class="udiff-line-modified-removed">-     if (target != GraphicsContext3D::RENDERBUFFER) {</span>
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;bindRenderbuffer&quot;, &quot;invalid target&quot;);</span>
<span class="udiff-line-modified-added">+     if (target != GraphicsContextGL::RENDERBUFFER) {</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;bindRenderbuffer&quot;, &quot;invalid target&quot;);</span>
          return;
      }
      m_renderbufferBinding = renderBuffer;
      m_context-&gt;bindRenderbuffer(target, objectOrZero(renderBuffer));
      if (renderBuffer)
          renderBuffer-&gt;setHasEverBeenBound();
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::bindTexture(GC3Denum target, WebGLTexture* texture)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::bindTexture(GCGLenum target, WebGLTexture* texture)</span>
  {
      bool deleted;
      if (!checkObjectToBeBound(&quot;bindTexture&quot;, texture, deleted))
          return;
      if (deleted)
          texture = nullptr;
      if (texture &amp;&amp; texture-&gt;getTarget() &amp;&amp; texture-&gt;getTarget() != target) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;bindTexture&quot;, &quot;textures can not be used with multiple targets&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;bindTexture&quot;, &quot;textures can not be used with multiple targets&quot;);</span>
          return;
      }
<span class="udiff-line-modified-removed">-     GC3Dint maxLevel = 0;</span>
<span class="udiff-line-modified-added">+     GCGLint maxLevel = 0;</span>
      auto&amp; textureUnit = m_textureUnits[m_activeTextureUnit];
<span class="udiff-line-modified-removed">-     if (target == GraphicsContext3D::TEXTURE_2D) {</span>
<span class="udiff-line-modified-added">+     if (target == GraphicsContextGL::TEXTURE_2D) {</span>
          textureUnit.texture2DBinding = texture;
          maxLevel = m_maxTextureLevel;
          if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
              m_unrenderableTextureUnits.add(m_activeTextureUnit);
          else
              m_unrenderableTextureUnits.remove(m_activeTextureUnit);
<span class="udiff-line-modified-removed">-     } else if (target == GraphicsContext3D::TEXTURE_CUBE_MAP) {</span>
<span class="udiff-line-modified-added">+     } else if (target == GraphicsContextGL::TEXTURE_CUBE_MAP) {</span>
          textureUnit.textureCubeMapBinding = texture;
          maxLevel = m_maxCubeMapTextureLevel;
          if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
              m_unrenderableTextureUnits.add(m_activeTextureUnit);
          else
              m_unrenderableTextureUnits.remove(m_activeTextureUnit);
      } else {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;bindTexture&quot;, &quot;invalid target&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;bindTexture&quot;, &quot;invalid target&quot;);</span>
          return;
      }
      m_context-&gt;bindTexture(target, objectOrZero(texture));
      if (texture)
          texture-&gt;setTarget(target, maxLevel);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1352,90 +1355,90 @@</span>
      // platforms is fairly involved (will require a HashMap from texture ID
      // in all ports), and we have not had any complaints, so the logic has
      // been removed.
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::blendColor(GC3Dfloat red, GC3Dfloat green, GC3Dfloat blue, GC3Dfloat alpha)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::blendColor(GCGLfloat red, GCGLfloat green, GCGLfloat blue, GCGLfloat alpha)</span>
  {
      if (isContextLostOrPending())
          return;
      m_context-&gt;blendColor(red, green, blue, alpha);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::blendEquation(GC3Denum mode)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::blendEquation(GCGLenum mode)</span>
  {
      if (isContextLostOrPending() || !validateBlendEquation(&quot;blendEquation&quot;, mode))
          return;
      m_context-&gt;blendEquation(mode);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::blendEquationSeparate(GC3Denum modeRGB, GC3Denum modeAlpha)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::blendEquationSeparate(GCGLenum modeRGB, GCGLenum modeAlpha)</span>
  {
      if (isContextLostOrPending() || !validateBlendEquation(&quot;blendEquation&quot;, modeRGB) || !validateBlendEquation(&quot;blendEquation&quot;, modeAlpha))
          return;
      m_context-&gt;blendEquationSeparate(modeRGB, modeAlpha);
  }
  
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::blendFunc(GC3Denum sfactor, GC3Denum dfactor)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::blendFunc(GCGLenum sfactor, GCGLenum dfactor)</span>
  {
      if (isContextLostOrPending() || !validateBlendFuncFactors(&quot;blendFunc&quot;, sfactor, dfactor))
          return;
      m_context-&gt;blendFunc(sfactor, dfactor);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::blendFuncSeparate(GC3Denum srcRGB, GC3Denum dstRGB, GC3Denum srcAlpha, GC3Denum dstAlpha)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::blendFuncSeparate(GCGLenum srcRGB, GCGLenum dstRGB, GCGLenum srcAlpha, GCGLenum dstAlpha)</span>
  {
      // Note: Alpha does not have the same restrictions as RGB.
      if (isContextLostOrPending() || !validateBlendFuncFactors(&quot;blendFunc&quot;, srcRGB, dstRGB))
          return;
      m_context-&gt;blendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::bufferData(GC3Denum target, long long size, GC3Denum usage)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::bufferData(GCGLenum target, long long size, GCGLenum usage)</span>
  {
      if (isContextLostOrPending())
          return;
      RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferData&quot;, target, usage);
      if (!buffer)
          return;
      if (size &lt; 0) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferData&quot;, &quot;size &lt; 0&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferData&quot;, &quot;size &lt; 0&quot;);</span>
          return;
      }
      if (!size) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferData&quot;, &quot;size == 0&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferData&quot;, &quot;size == 0&quot;);</span>
          return;
      }
<span class="udiff-line-modified-removed">-     if (!buffer-&gt;associateBufferData(static_cast&lt;GC3Dsizeiptr&gt;(size))) {</span>
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferData&quot;, &quot;invalid buffer&quot;);</span>
<span class="udiff-line-modified-added">+     if (!buffer-&gt;associateBufferData(static_cast&lt;GCGLsizeiptr&gt;(size))) {</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferData&quot;, &quot;invalid buffer&quot;);</span>
          return;
      }
  
      m_context-&gt;moveErrorsToSyntheticErrorList();
<span class="udiff-line-modified-removed">-     m_context-&gt;bufferData(target, static_cast&lt;GC3Dsizeiptr&gt;(size), usage);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;bufferData(target, static_cast&lt;GCGLsizeiptr&gt;(size), usage);</span>
      if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
          // The bufferData function failed. Tell the buffer it doesn&#39;t have the data it thinks it does.
          buffer-&gt;disassociateBufferData();
      }
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::bufferData(GC3Denum target, Optional&lt;BufferDataSource&gt;&amp;&amp; data, GC3Denum usage)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::bufferData(GCGLenum target, Optional&lt;BufferDataSource&gt;&amp;&amp; data, GCGLenum usage)</span>
  {
      if (isContextLostOrPending())
          return;
      if (!data) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferData&quot;, &quot;null data&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferData&quot;, &quot;null data&quot;);</span>
          return;
      }
      RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferData&quot;, target, usage);
      if (!buffer)
          return;
  
      WTF::visit([&amp;](auto&amp; data) {
          if (!buffer-&gt;associateBufferData(data.get())) {
<span class="udiff-line-modified-removed">-             this-&gt;synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferData&quot;, &quot;invalid buffer&quot;);</span>
<span class="udiff-line-modified-added">+             this-&gt;synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferData&quot;, &quot;invalid buffer&quot;);</span>
              return;
          }
  
          m_context-&gt;moveErrorsToSyntheticErrorList();
          m_context-&gt;bufferData(target, data-&gt;byteLength(), data-&gt;data(), usage);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1444,70 +1447,70 @@</span>
              buffer-&gt;disassociateBufferData();
          }
      }, data.value());
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::bufferSubData(GC3Denum target, long long offset, Optional&lt;BufferDataSource&gt;&amp;&amp; data)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::bufferSubData(GCGLenum target, long long offset, Optional&lt;BufferDataSource&gt;&amp;&amp; data)</span>
  {
      if (isContextLostOrPending())
          return;
<span class="udiff-line-modified-removed">-     RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferSubData&quot;, target, GraphicsContext3D::STATIC_DRAW);</span>
<span class="udiff-line-modified-added">+     RefPtr&lt;WebGLBuffer&gt; buffer = validateBufferDataParameters(&quot;bufferSubData&quot;, target, GraphicsContextGL::STATIC_DRAW);</span>
      if (!buffer)
          return;
      if (offset &lt; 0) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferSubData&quot;, &quot;offset &lt; 0&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferSubData&quot;, &quot;offset &lt; 0&quot;);</span>
          return;
      }
      if (!data)
          return;
  
      WTF::visit([&amp;](auto&amp; data) {
<span class="udiff-line-modified-removed">-         if (!buffer-&gt;associateBufferSubData(static_cast&lt;GC3Dintptr&gt;(offset), data.get())) {</span>
<span class="udiff-line-modified-removed">-             this-&gt;synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;bufferSubData&quot;, &quot;offset out of range&quot;);</span>
<span class="udiff-line-modified-added">+         if (!buffer-&gt;associateBufferSubData(static_cast&lt;GCGLintptr&gt;(offset), data.get())) {</span>
<span class="udiff-line-modified-added">+             this-&gt;synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;bufferSubData&quot;, &quot;offset out of range&quot;);</span>
              return;
          }
  
          m_context-&gt;moveErrorsToSyntheticErrorList();
<span class="udiff-line-modified-removed">-         m_context-&gt;bufferSubData(target, static_cast&lt;GC3Dintptr&gt;(offset), data-&gt;byteLength(), data-&gt;data());</span>
<span class="udiff-line-modified-added">+         m_context-&gt;bufferSubData(target, static_cast&lt;GCGLintptr&gt;(offset), data-&gt;byteLength(), data-&gt;data());</span>
          if (m_context-&gt;moveErrorsToSyntheticErrorList()) {
              // The bufferSubData function failed. Tell the buffer it doesn&#39;t have the data it thinks it does.
              buffer-&gt;disassociateBufferData();
          }
      }, data.value());
  }
  
<span class="udiff-line-modified-removed">- GC3Denum WebGLRenderingContextBase::checkFramebufferStatus(GC3Denum target)</span>
<span class="udiff-line-modified-added">+ GCGLenum WebGLRenderingContextBase::checkFramebufferStatus(GCGLenum target)</span>
  {
      if (isContextLostOrPending())
<span class="udiff-line-modified-removed">-         return GraphicsContext3D::FRAMEBUFFER_UNSUPPORTED;</span>
<span class="udiff-line-modified-removed">-     if (target != GraphicsContext3D::FRAMEBUFFER) {</span>
<span class="udiff-line-modified-added">+         return GraphicsContextGL::FRAMEBUFFER_UNSUPPORTED;</span>
<span class="udiff-line-modified-added">+     if (target != GraphicsContextGL::FRAMEBUFFER) {</span>
  #if ENABLE(WEBGL2)
<span class="udiff-line-modified-removed">-         if (isWebGL1() || (target != GraphicsContext3D::DRAW_FRAMEBUFFER &amp;&amp; target != GraphicsContext3D::READ_FRAMEBUFFER)) {</span>
<span class="udiff-line-modified-added">+         if (isWebGL1() || (target != GraphicsContextGL::DRAW_FRAMEBUFFER &amp;&amp; target != GraphicsContextGL::READ_FRAMEBUFFER)) {</span>
  #endif
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;checkFramebufferStatus&quot;, &quot;invalid target&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;checkFramebufferStatus&quot;, &quot;invalid target&quot;);</span>
              return 0;
  #if ENABLE(WEBGL2)
          }
  #endif
      }
  
<span class="udiff-line-modified-removed">-     auto targetFramebuffer = (target == GraphicsContext3D::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;</span>
<span class="udiff-line-modified-added">+     auto targetFramebuffer = (target == GraphicsContextGL::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;</span>
  
      if (!targetFramebuffer || !targetFramebuffer-&gt;object())
<span class="udiff-line-modified-removed">-         return GraphicsContext3D::FRAMEBUFFER_COMPLETE;</span>
<span class="udiff-line-modified-added">+         return GraphicsContextGL::FRAMEBUFFER_COMPLETE;</span>
      const char* reason = &quot;framebuffer incomplete&quot;;
<span class="udiff-line-modified-removed">-     GC3Denum result = targetFramebuffer-&gt;checkStatus(&amp;reason);</span>
<span class="udiff-line-modified-removed">-     if (result != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {</span>
<span class="udiff-line-modified-added">+     GCGLenum result = targetFramebuffer-&gt;checkStatus(&amp;reason);</span>
<span class="udiff-line-modified-added">+     if (result != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {</span>
          String str = &quot;WebGL: checkFramebufferStatus:&quot; + String(reason);
          printToConsole(MessageLevel::Warning, str);
          return result;
      }
      result = m_context-&gt;checkFramebufferStatus(target);
      return result;
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::clearColor(GC3Dfloat r, GC3Dfloat g, GC3Dfloat b, GC3Dfloat a)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::clearColor(GCGLfloat r, GCGLfloat g, GCGLfloat b, GCGLfloat a)</span>
  {
      if (isContextLostOrPending())
          return;
      if (std::isnan(r))
          r = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1522,27 +1525,27 @@</span>
      m_clearColor[2] = b;
      m_clearColor[3] = a;
      m_context-&gt;clearColor(r, g, b, a);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::clearDepth(GC3Dfloat depth)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::clearDepth(GCGLfloat depth)</span>
  {
      if (isContextLostOrPending())
          return;
      m_clearDepth = depth;
      m_context-&gt;clearDepth(depth);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::clearStencil(GC3Dint s)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::clearStencil(GCGLint s)</span>
  {
      if (isContextLostOrPending())
          return;
      m_clearStencil = s;
      m_context-&gt;clearStencil(s);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::colorMask(GC3Dboolean red, GC3Dboolean green, GC3Dboolean blue, GC3Dboolean alpha)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::colorMask(GCGLboolean red, GCGLboolean green, GCGLboolean blue, GCGLboolean alpha)</span>
  {
      if (isContextLostOrPending())
          return;
      m_colorMask[0] = red;
      m_colorMask[1] = green;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1554,12 +1557,12 @@</span>
  void WebGLRenderingContextBase::compileShader(WebGLShader* shader)
  {
      if (isContextLostOrPending() || !validateWebGLObject(&quot;compileShader&quot;, shader))
          return;
      m_context-&gt;compileShader(objectOrZero(shader));
<span class="udiff-line-modified-removed">-     GC3Dint value;</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;getShaderiv(objectOrZero(shader), GraphicsContext3D::COMPILE_STATUS, &amp;value);</span>
<span class="udiff-line-modified-added">+     GCGLint value;</span>
<span class="udiff-line-modified-added">+     m_context-&gt;getShaderiv(objectOrZero(shader), GraphicsContextGL::COMPILE_STATUS, &amp;value);</span>
      shader-&gt;setValid(value);
  
      auto* canvas = htmlCanvas();
  
      if (canvas &amp;&amp; m_synthesizedErrorsToConsole &amp;&amp; !value) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1568,23 +1571,23 @@</span>
          for (auto&amp; error : getShaderInfoLog(shader).split(&#39;\n&#39;))
              canvas-&gt;document().addConsoleMessage(makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, MessageLevel::Error, &quot;WebGL: &quot; + error, stackTrace.copyRef()));
      }
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::compressedTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, ArrayBufferView&amp; data)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, ArrayBufferView&amp; data)</span>
  {
      if (isContextLostOrPending())
          return;
      if (!validateTexFuncLevel(&quot;compressedTexImage2D&quot;, target, level))
          return;
  
      if (!validateCompressedTexFormat(internalformat)) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;compressedTexImage2D&quot;, &quot;invalid internalformat&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;compressedTexImage2D&quot;, &quot;invalid internalformat&quot;);</span>
          return;
      }
      if (border) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;compressedTexImage2D&quot;, &quot;border not 0&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;compressedTexImage2D&quot;, &quot;border not 0&quot;);</span>
          return;
      }
      if (!validateCompressedTexDimensions(&quot;compressedTexImage2D&quot;, target, level, width, height, internalformat))
          return;
      if (!validateCompressedTexFuncData(&quot;compressedTexImage2D&quot;, width, height, internalformat, data))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1602,62 +1605,62 @@</span>
          // The compressedTexImage2D function failed. Tell the WebGLTexture it doesn&#39;t have the data for this level.
          tex-&gt;markInvalid(target, level);
          return;
      }
  
<span class="udiff-line-modified-removed">-     tex-&gt;setLevelInfo(target, level, internalformat, width, height, GraphicsContext3D::UNSIGNED_BYTE);</span>
<span class="udiff-line-modified-added">+     tex-&gt;setLevelInfo(target, level, internalformat, width, height, GraphicsContextGL::UNSIGNED_BYTE);</span>
      tex-&gt;setCompressed();
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::compressedTexSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum format, ArrayBufferView&amp; data)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::compressedTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, ArrayBufferView&amp; data)</span>
  {
      if (isContextLostOrPending())
          return;
      if (!validateTexFuncLevel(&quot;compressedTexSubImage2D&quot;, target, level))
          return;
      if (!validateCompressedTexFormat(format)) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;compressedTexSubImage2D&quot;, &quot;invalid format&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;compressedTexSubImage2D&quot;, &quot;invalid format&quot;);</span>
          return;
      }
      if (!validateCompressedTexFuncData(&quot;compressedTexSubImage2D&quot;, width, height, format, data))
          return;
  
      auto tex = validateTextureBinding(&quot;compressedTexSubImage2D&quot;, target, true);
      if (!tex)
          return;
  
      if (format != tex-&gt;getInternalFormat(target, level)) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;compressedTexSubImage2D&quot;, &quot;format does not match texture format&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;compressedTexSubImage2D&quot;, &quot;format does not match texture format&quot;);</span>
          return;
      }
  
      if (!validateCompressedTexSubDimensions(&quot;compressedTexSubImage2D&quot;, target, level, xoffset, yoffset, width, height, format, tex.get()))
          return;
  
<span class="udiff-line-modified-removed">-     graphicsContext3D()-&gt;compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data.byteLength(), data.baseAddress());</span>
<span class="udiff-line-modified-added">+     graphicsContextGL()-&gt;compressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, data.byteLength(), data.baseAddress());</span>
      tex-&gt;setCompressed();
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateSettableTexInternalFormat(const char* functionName, GC3Denum internalFormat)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateSettableTexInternalFormat(const char* functionName, GCGLenum internalFormat)</span>
  {
      switch (internalFormat) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::DEPTH_COMPONENT:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::DEPTH_STENCIL:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::DEPTH_COMPONENT16:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::DEPTH_COMPONENT24:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::DEPTH_COMPONENT32F:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::DEPTH24_STENCIL8:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::DEPTH32F_STENCIL8:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::STENCIL_INDEX8:</span>
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;format can not be set, only rendered to&quot;);</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::DEPTH_COMPONENT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::DEPTH_STENCIL:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::DEPTH_COMPONENT16:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::DEPTH_COMPONENT24:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::DEPTH_COMPONENT32F:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::DEPTH24_STENCIL8:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::DEPTH32F_STENCIL8:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::STENCIL_INDEX8:</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;format can not be set, only rendered to&quot;);</span>
          return false;
      default:
          return true;
      }
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::copyTexSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::copyTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)</span>
  {
      if (isContextLostOrPending())
          return;
      if (!validateTexFuncLevel(&quot;copyTexSubImage2D&quot;, target, level))
          return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1666,51 +1669,51 @@</span>
          return;
      if (!validateSize(&quot;copyTexSubImage2D&quot;, xoffset, yoffset) || !validateSize(&quot;copyTexSubImage2D&quot;, width, height))
          return;
      // Before checking if it is in the range, check if overflow happens first.
      if (xoffset + width &lt; 0 || yoffset + height &lt; 0) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;bad dimensions&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;bad dimensions&quot;);</span>
          return;
      }
      if (xoffset + width &gt; tex-&gt;getWidth(target, level) || yoffset + height &gt; tex-&gt;getHeight(target, level)) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;rectangle out of range&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;rectangle out of range&quot;);</span>
          return;
      }
<span class="udiff-line-modified-removed">-     GC3Denum internalFormat = tex-&gt;getInternalFormat(target, level);</span>
<span class="udiff-line-modified-added">+     GCGLenum internalFormat = tex-&gt;getInternalFormat(target, level);</span>
      if (!validateSettableTexInternalFormat(&quot;copyTexSubImage2D&quot;, internalFormat))
          return;
      if (!isTexInternalFormatColorBufferCombinationValid(internalFormat, getBoundFramebufferColorFormat())) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;copyTexSubImage2D&quot;, &quot;framebuffer is incompatible format&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;copyTexSubImage2D&quot;, &quot;framebuffer is incompatible format&quot;);</span>
          return;
      }
      const char* reason = &quot;framebuffer incomplete&quot;;
<span class="udiff-line-modified-removed">-     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContext3D(), &amp;reason)) {</span>
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, &quot;copyTexSubImage2D&quot;, reason);</span>
<span class="udiff-line-modified-added">+     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContextGL(), &amp;reason)) {</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, &quot;copyTexSubImage2D&quot;, reason);</span>
          return;
      }
      clearIfComposited();
  
<span class="udiff-line-modified-removed">-     GC3Dint clippedX, clippedY;</span>
<span class="udiff-line-modified-removed">-     GC3Dsizei clippedWidth, clippedHeight;</span>
<span class="udiff-line-modified-added">+     GCGLint clippedX, clippedY;</span>
<span class="udiff-line-modified-added">+     GCGLsizei clippedWidth, clippedHeight;</span>
      if (clip2D(x, y, width, height, getBoundFramebufferWidth(), getBoundFramebufferHeight(), &amp;clippedX, &amp;clippedY, &amp;clippedWidth, &amp;clippedHeight)) {
<span class="udiff-line-modified-removed">-         GC3Denum format;</span>
<span class="udiff-line-modified-removed">-         GC3Denum type;</span>
<span class="udiff-line-modified-removed">-         if (!GraphicsContext3D::possibleFormatAndTypeForInternalFormat(tex-&gt;getInternalFormat(target, level), format, type)) {</span>
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;copyTexSubImage2D&quot;, &quot;Texture has unknown internal format&quot;);</span>
<span class="udiff-line-modified-added">+         GCGLenum format;</span>
<span class="udiff-line-modified-added">+         GCGLenum type;</span>
<span class="udiff-line-modified-added">+         if (!GraphicsContextGLOpenGL::possibleFormatAndTypeForInternalFormat(tex-&gt;getInternalFormat(target, level), format, type)) {</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;copyTexSubImage2D&quot;, &quot;Texture has unknown internal format&quot;);</span>
              return;
          }
          UniqueArray&lt;unsigned char&gt; zero;
          if (width &amp;&amp; height) {
              unsigned size;
<span class="udiff-line-modified-removed">-             GC3Denum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_unpackAlignment, &amp;size, nullptr);</span>
<span class="udiff-line-modified-removed">-             if (error != GraphicsContext3D::NO_ERROR) {</span>
<span class="udiff-line-modified-added">+             GCGLenum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_unpackAlignment, &amp;size, nullptr);</span>
<span class="udiff-line-modified-added">+             if (error != GraphicsContextGL::NO_ERROR) {</span>
                  synthesizeGLError(error, &quot;copyTexSubImage2D&quot;, &quot;bad dimensions&quot;);
                  return;
              }
              zero = makeUniqueArray&lt;unsigned char&gt;(size);
              if (!zero) {
<span class="udiff-line-modified-removed">-                 synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;out of memory&quot;);</span>
<span class="udiff-line-modified-added">+                 synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;copyTexSubImage2D&quot;, &quot;out of memory&quot;);</span>
                  return;
              }
              memset(zero.get(), 0, size);
          }
          m_context-&gt;texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, zero.get());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1752,11 +1755,11 @@</span>
      if (isContextLostOrPending())
          return nullptr;
      auto program = WebGLProgram::create(*this);
      addSharedObject(program.get());
  
<span class="udiff-line-modified-removed">-     InspectorInstrumentation::didCreateProgram(*this, program.get());</span>
<span class="udiff-line-modified-added">+     InspectorInstrumentation::didCreateWebGLProgram(*this, program.get());</span>
  
      return program;
  }
  
  RefPtr&lt;WebGLRenderbuffer&gt; WebGLRenderingContextBase::createRenderbuffer()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1766,25 +1769,25 @@</span>
      auto buffer = WebGLRenderbuffer::create(*this);
      addSharedObject(buffer.get());
      return buffer;
  }
  
<span class="udiff-line-modified-removed">- RefPtr&lt;WebGLShader&gt; WebGLRenderingContextBase::createShader(GC3Denum type)</span>
<span class="udiff-line-modified-added">+ RefPtr&lt;WebGLShader&gt; WebGLRenderingContextBase::createShader(GCGLenum type)</span>
  {
      if (isContextLostOrPending())
          return nullptr;
<span class="udiff-line-modified-removed">-     if (type != GraphicsContext3D::VERTEX_SHADER &amp;&amp; type != GraphicsContext3D::FRAGMENT_SHADER) {</span>
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;createShader&quot;, &quot;invalid shader type&quot;);</span>
<span class="udiff-line-modified-added">+     if (type != GraphicsContextGL::VERTEX_SHADER &amp;&amp; type != GraphicsContextGL::FRAGMENT_SHADER) {</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;createShader&quot;, &quot;invalid shader type&quot;);</span>
          return nullptr;
      }
  
      auto shader = WebGLShader::create(*this, type);
      addSharedObject(shader.get());
      return shader;
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::cullFace(GC3Denum mode)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::cullFace(GCGLenum mode)</span>
  {
      if (isContextLostOrPending())
          return;
      m_context-&gt;cullFace(mode);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1792,57 +1795,72 @@</span>
  bool WebGLRenderingContextBase::deleteObject(WebGLObject* object)
  {
      if (isContextLostOrPending() || !object)
          return false;
      if (!object-&gt;validate(contextGroup(), *this)) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;delete&quot;, &quot;object does not belong to this context&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;delete&quot;, &quot;object does not belong to this context&quot;);</span>
          return false;
      }
      if (object-&gt;isDeleted())
          return false;
      if (object-&gt;object())
          // We need to pass in context here because we want
          // things in this context unbound.
<span class="udiff-line-modified-removed">-         object-&gt;deleteObject(graphicsContext3D());</span>
<span class="udiff-line-modified-added">+         object-&gt;deleteObject(graphicsContextGL());</span>
      return true;
  }
  
<span class="udiff-line-added">+ #define REMOVE_BUFFER_FROM_BINDING(binding) \</span>
<span class="udiff-line-added">+     if (binding == buffer) \</span>
<span class="udiff-line-added">+         binding = nullptr;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void WebGLRenderingContextBase::uncacheDeletedBuffer(WebGLBuffer* buffer)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     REMOVE_BUFFER_FROM_BINDING(m_boundArrayBuffer);</span>
<span class="udiff-line-added">+     REMOVE_BUFFER_FROM_BINDING(m_boundCopyReadBuffer);</span>
<span class="udiff-line-added">+     REMOVE_BUFFER_FROM_BINDING(m_boundCopyWriteBuffer);</span>
<span class="udiff-line-added">+     REMOVE_BUFFER_FROM_BINDING(m_boundPixelPackBuffer);</span>
<span class="udiff-line-added">+     REMOVE_BUFFER_FROM_BINDING(m_boundPixelUnpackBuffer);</span>
<span class="udiff-line-added">+     REMOVE_BUFFER_FROM_BINDING(m_boundTransformFeedbackBuffer);</span>
<span class="udiff-line-added">+     REMOVE_BUFFER_FROM_BINDING(m_boundUniformBuffer);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     m_boundVertexArrayObject-&gt;unbindBuffer(*buffer);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  void WebGLRenderingContextBase::deleteBuffer(WebGLBuffer* buffer)
  {
      if (!deleteObject(buffer))
          return;
<span class="udiff-line-removed">-     if (m_boundArrayBuffer == buffer)</span>
<span class="udiff-line-removed">-         m_boundArrayBuffer = nullptr;</span>
  
<span class="udiff-line-modified-removed">-     m_boundVertexArrayObject-&gt;unbindBuffer(*buffer);</span>
<span class="udiff-line-modified-added">+     uncacheDeletedBuffer(buffer);</span>
  }
  
  void WebGLRenderingContextBase::deleteFramebuffer(WebGLFramebuffer* framebuffer)
  {
      if (!deleteObject(framebuffer))
          return;
  #if ENABLE(WEBGL2)
      if (isWebGL2() &amp;&amp; framebuffer == m_readFramebufferBinding) {
          m_readFramebufferBinding = nullptr;
<span class="udiff-line-modified-removed">-         m_context-&gt;bindFramebuffer(GraphicsContext3D::READ_FRAMEBUFFER, 0);</span>
<span class="udiff-line-modified-added">+         m_context-&gt;bindFramebuffer(GraphicsContextGL::READ_FRAMEBUFFER, 0);</span>
      }
  #endif
      if (framebuffer == m_framebufferBinding) {
          m_framebufferBinding = nullptr;
  #if ENABLE(WEBGL2)
          if (isWebGL2())
<span class="udiff-line-modified-removed">-             m_context-&gt;bindFramebuffer(GraphicsContext3D::DRAW_FRAMEBUFFER, 0);</span>
<span class="udiff-line-modified-added">+             m_context-&gt;bindFramebuffer(GraphicsContextGL::DRAW_FRAMEBUFFER, 0);</span>
          else
  #endif
<span class="udiff-line-modified-removed">-             m_context-&gt;bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, 0);</span>
<span class="udiff-line-modified-added">+             m_context-&gt;bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, 0);</span>
      }
  }
  
  void WebGLRenderingContextBase::deleteProgram(WebGLProgram* program)
  {
      if (program)
<span class="udiff-line-modified-removed">-         InspectorInstrumentation::willDeleteProgram(*this, *program);</span>
<span class="udiff-line-modified-added">+         InspectorInstrumentation::willDestroyWebGLProgram(*program);</span>
  
      deleteObject(program);
      // We don&#39;t reset m_currentProgram to 0 here because the deletion of the
      // current program is delayed.
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1881,129 +1899,129 @@</span>
      }
      if (m_framebufferBinding)
          m_framebufferBinding-&gt;removeAttachmentFromBoundFramebuffer(texture);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::depthFunc(GC3Denum func)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::depthFunc(GCGLenum func)</span>
  {
      if (isContextLostOrPending())
          return;
      m_context-&gt;depthFunc(func);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::depthMask(GC3Dboolean flag)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::depthMask(GCGLboolean flag)</span>
  {
      if (isContextLostOrPending())
          return;
      m_depthMask = flag;
      m_context-&gt;depthMask(flag);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::depthRange(GC3Dfloat zNear, GC3Dfloat zFar)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::depthRange(GCGLfloat zNear, GCGLfloat zFar)</span>
  {
      if (isContextLostOrPending())
          return;
      if (zNear &gt; zFar) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;depthRange&quot;, &quot;zNear &gt; zFar&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;depthRange&quot;, &quot;zNear &gt; zFar&quot;);</span>
          return;
      }
      m_context-&gt;depthRange(zNear, zFar);
  }
  
  void WebGLRenderingContextBase::detachShader(WebGLProgram* program, WebGLShader* shader)
  {
      if (isContextLostOrPending() || !validateWebGLObject(&quot;detachShader&quot;, program) || !validateWebGLObject(&quot;detachShader&quot;, shader))
          return;
      if (!program-&gt;detachShader(shader)) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;detachShader&quot;, &quot;shader not attached&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;detachShader&quot;, &quot;shader not attached&quot;);</span>
          return;
      }
      m_context-&gt;detachShader(objectOrZero(program), objectOrZero(shader));
<span class="udiff-line-modified-removed">-     shader-&gt;onDetached(graphicsContext3D());</span>
<span class="udiff-line-modified-added">+     shader-&gt;onDetached(graphicsContextGL());</span>
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::disable(GC3Denum cap)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::disable(GCGLenum cap)</span>
  {
      if (isContextLostOrPending() || !validateCapability(&quot;disable&quot;, cap))
          return;
<span class="udiff-line-modified-removed">-     if (cap == GraphicsContext3D::STENCIL_TEST) {</span>
<span class="udiff-line-modified-added">+     if (cap == GraphicsContextGL::STENCIL_TEST) {</span>
          m_stencilEnabled = false;
          applyStencilTest();
          return;
      }
<span class="udiff-line-modified-removed">-     if (cap == GraphicsContext3D::SCISSOR_TEST)</span>
<span class="udiff-line-modified-added">+     if (cap == GraphicsContextGL::SCISSOR_TEST)</span>
          m_scissorEnabled = false;
      m_context-&gt;disable(cap);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::disableVertexAttribArray(GC3Duint index)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::disableVertexAttribArray(GCGLuint index)</span>
  {
      if (isContextLostOrPending())
          return;
      if (index &gt;= m_maxVertexAttribs) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;disableVertexAttribArray&quot;, &quot;index out of range&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;disableVertexAttribArray&quot;, &quot;index out of range&quot;);</span>
          return;
      }
  
      WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(index);
      state.enabled = false;
  
      if (index &gt; 0 || isGLES2Compliant())
          m_context-&gt;disableVertexAttribArray(index);
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateNPOTTextureLevel(GC3Dsizei width, GC3Dsizei height, GC3Dint level, const char* functionName)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateNPOTTextureLevel(GCGLsizei width, GCGLsizei height, GCGLint level, const char* functionName)</span>
  {
      if (!isGLES2NPOTStrict() &amp;&amp; level &amp;&amp; WebGLTexture::isNPOT(width, height)) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;level &gt; 0 not power of 2&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;level &gt; 0 not power of 2&quot;);</span>
          return false;
      }
  
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateElementArraySize(GC3Dsizei count, GC3Denum type, GC3Dintptr offset)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateElementArraySize(GCGLsizei count, GCGLenum type, GCGLintptr offset)</span>
  {
      RefPtr&lt;WebGLBuffer&gt; elementArrayBuffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
  
      if (!elementArrayBuffer)
          return false;
  
      if (offset &lt; 0)
          return false;
  
<span class="udiff-line-modified-removed">-     if (type == GraphicsContext3D::UNSIGNED_INT) {</span>
<span class="udiff-line-modified-added">+     if (type == GraphicsContextGL::UNSIGNED_INT) {</span>
          // For an unsigned int array, offset must be divisible by 4 for alignment reasons.
          if (offset % 4)
              return false;
  
          // Make uoffset an element offset.
          offset /= 4;
  
<span class="udiff-line-modified-removed">-         GC3Dsizeiptr n = elementArrayBuffer-&gt;byteLength() / 4;</span>
<span class="udiff-line-modified-added">+         GCGLsizeiptr n = elementArrayBuffer-&gt;byteLength() / 4;</span>
          if (offset &gt; n || count &gt; n - offset)
              return false;
<span class="udiff-line-modified-removed">-     } else if (type == GraphicsContext3D::UNSIGNED_SHORT) {</span>
<span class="udiff-line-modified-added">+     } else if (type == GraphicsContextGL::UNSIGNED_SHORT) {</span>
          // For an unsigned short array, offset must be divisible by 2 for alignment reasons.
          if (offset % 2)
              return false;
  
          // Make uoffset an element offset.
          offset /= 2;
  
<span class="udiff-line-modified-removed">-         GC3Dsizeiptr n = elementArrayBuffer-&gt;byteLength() / 2;</span>
<span class="udiff-line-modified-added">+         GCGLsizeiptr n = elementArrayBuffer-&gt;byteLength() / 2;</span>
          if (offset &gt; n || count &gt; n - offset)
              return false;
<span class="udiff-line-modified-removed">-     } else if (type == GraphicsContext3D::UNSIGNED_BYTE) {</span>
<span class="udiff-line-modified-removed">-         GC3Dsizeiptr n = elementArrayBuffer-&gt;byteLength();</span>
<span class="udiff-line-modified-added">+     } else if (type == GraphicsContextGL::UNSIGNED_BYTE) {</span>
<span class="udiff-line-modified-added">+         GCGLsizeiptr n = elementArrayBuffer-&gt;byteLength();</span>
          if (offset &gt; n || count &gt; n - offset)
              return false;
      }
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateIndexArrayPrecise(GC3Dsizei count, GC3Denum type, GC3Dintptr offset, unsigned&amp; numElementsRequired)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateIndexArrayPrecise(GCGLsizei count, GCGLenum type, GCGLintptr offset, unsigned&amp; numElementsRequired)</span>
  {
      ASSERT(count &gt;= 0 &amp;&amp; offset &gt;= 0);
      unsigned maxIndex = 0;
  
      RefPtr&lt;WebGLBuffer&gt; elementArrayBuffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2019,18 +2037,18 @@</span>
      auto buffer = elementArrayBuffer-&gt;elementArrayBuffer();
      if (!buffer)
          return false;
  
      switch (type) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_INT:</span>
<span class="udiff-line-modified-removed">-         maxIndex = getMaxIndex&lt;GC3Duint&gt;(buffer, offset, count);</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_INT:</span>
<span class="udiff-line-modified-added">+         maxIndex = getMaxIndex&lt;GCGLuint&gt;(buffer, offset, count);</span>
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_SHORT:</span>
<span class="udiff-line-modified-removed">-         maxIndex = getMaxIndex&lt;GC3Dushort&gt;(buffer, offset, count);</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_SHORT:</span>
<span class="udiff-line-modified-added">+         maxIndex = getMaxIndex&lt;GCGLushort&gt;(buffer, offset, count);</span>
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_BYTE:</span>
<span class="udiff-line-modified-removed">-         maxIndex = getMaxIndex&lt;GC3Dubyte&gt;(buffer, offset, count);</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_BYTE:</span>
<span class="udiff-line-modified-added">+         maxIndex = getMaxIndex&lt;GCGLubyte&gt;(buffer, offset, count);</span>
          break;
      }
  
      // Then set the maxiumum index in the index array and make sure it is valid.
      auto checkedNumElementsRequired = checkedAddAndMultiply&lt;unsigned&gt;(maxIndex, 1, 1);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2040,11 +2058,14 @@</span>
      return true;
  }
  
  bool WebGLRenderingContextBase::validateVertexAttributes(unsigned elementCount, unsigned primitiveCount)
  {
<span class="udiff-line-modified-removed">- #if !USE(ANGLE)</span>
<span class="udiff-line-modified-added">+ #if USE(ANGLE)</span>
<span class="udiff-line-added">+     UNUSED_PARAM(elementCount);</span>
<span class="udiff-line-added">+     UNUSED_PARAM(primitiveCount);</span>
<span class="udiff-line-added">+ #else</span>
      if (!m_currentProgram)
          return false;
  
      // Look in each enabled vertex attrib and check if they&#39;ve been bound to a buffer.
      for (unsigned i = 0; i &lt; m_maxVertexAttribs; ++i) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2101,11 +2122,11 @@</span>
      if (elementCount &amp;&amp; sawEnabledAttrib) {
          if (!m_boundArrayBuffer &amp;&amp; !m_boundVertexArrayObject-&gt;getElementArrayBuffer()) {
              if (usingSimulatedArrayBuffer) {
                  auto&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
                  if (state.enabled &amp;&amp; state.isBound()) {
<span class="udiff-line-modified-removed">-                     if (state.bufferBinding-&gt;getTarget() == GraphicsContext3D::ARRAY_BUFFER || state.bufferBinding-&gt;getTarget() == GraphicsContext3D::ELEMENT_ARRAY_BUFFER)</span>
<span class="udiff-line-modified-added">+                     if (state.bufferBinding-&gt;getTarget() == GraphicsContextGL::ARRAY_BUFFER || state.bufferBinding-&gt;getTarget() == GraphicsContextGL::ELEMENT_ARRAY_BUFFER)</span>
                          return !!state.bufferBinding-&gt;byteLength();
                  }
              }
              return false;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2116,158 +2137,158 @@</span>
  }
  
  bool WebGLRenderingContextBase::validateWebGLObject(const char* functionName, WebGLObject* object)
  {
      if (!object || !object-&gt;object()) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no object or object deleted&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no object or object deleted&quot;);</span>
          return false;
      }
      if (!object-&gt;validate(contextGroup(), *this)) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;object does not belong to this context&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;object does not belong to this context&quot;);</span>
          return false;
      }
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateDrawArrays(const char* functionName, GC3Denum mode, GC3Dint first, GC3Dsizei count, GC3Dsizei primitiveCount)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateDrawArrays(const char* functionName, GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei primitiveCount)</span>
  {
      if (isContextLostOrPending() || !validateDrawMode(functionName, mode))
          return false;
  
      if (!validateStencilSettings(functionName))
          return false;
  
      if (first &lt; 0 || count &lt; 0) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;first or count &lt; 0&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;first or count &lt; 0&quot;);</span>
          return false;
      }
  
      if (!count) {
          markContextChanged();
          return false;
      }
  
      if (primitiveCount &lt; 0) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;primcount &lt; 0&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;primcount &lt; 0&quot;);</span>
          return false;
      }
  
      // Ensure we have a valid rendering state.
<span class="udiff-line-modified-removed">-     Checked&lt;GC3Dint, RecordOverflow&gt; checkedSum = Checked&lt;GC3Dint, RecordOverflow&gt;(first) + Checked&lt;GC3Dint, RecordOverflow&gt;(count);</span>
<span class="udiff-line-modified-removed">-     Checked&lt;GC3Dint, RecordOverflow&gt; checkedPrimitiveCount(primitiveCount);</span>
<span class="udiff-line-modified-added">+     Checked&lt;GCGLint, RecordOverflow&gt; checkedSum = Checked&lt;GCGLint, RecordOverflow&gt;(first) + Checked&lt;GCGLint, RecordOverflow&gt;(count);</span>
<span class="udiff-line-modified-added">+     Checked&lt;GCGLint, RecordOverflow&gt; checkedPrimitiveCount(primitiveCount);</span>
      if (checkedSum.hasOverflowed() || checkedPrimitiveCount.hasOverflowed() || !validateVertexAttributes(checkedSum.unsafeGet(), checkedPrimitiveCount.unsafeGet())) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;attempt to access out of bounds arrays&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;attempt to access out of bounds arrays&quot;);</span>
          return false;
      }
      if (!validateSimulatedVertexAttrib0(checkedSum.unsafeGet() - 1)) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;attempt to access outside the bounds of the simulated vertexAttrib0 array&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;attempt to access outside the bounds of the simulated vertexAttrib0 array&quot;);</span>
          return false;
      }
  
      const char* reason = &quot;framebuffer incomplete&quot;;
<span class="udiff-line-modified-removed">-     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContext3D(), &amp;reason)) {</span>
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, functionName, reason);</span>
<span class="udiff-line-modified-added">+     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContextGL(), &amp;reason)) {</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, functionName, reason);</span>
          return false;
      }
  
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateDrawElements(const char* functionName, GC3Denum mode, GC3Dsizei count, GC3Denum type, long long offset, unsigned&amp; numElements, GC3Dsizei primitiveCount)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateDrawElements(const char* functionName, GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset, unsigned&amp; numElements, GCGLsizei primitiveCount)</span>
  {
      if (isContextLostOrPending() || !validateDrawMode(functionName, mode))
          return false;
  
      if (!validateStencilSettings(functionName))
          return false;
  
      switch (type) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_BYTE:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_SHORT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_BYTE:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_SHORT:</span>
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_INT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_INT:</span>
          if (m_oesElementIndexUint || isWebGL2())
              break;
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid type&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid type&quot;);</span>
          return false;
      default:
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid type&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid type&quot;);</span>
          return false;
      }
  
      if (count &lt; 0 || offset &lt; 0) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;count or offset &lt; 0&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;count or offset &lt; 0&quot;);</span>
          return false;
      }
  
      if (!count) {
          markContextChanged();
          return false;
      }
  
      if (primitiveCount &lt; 0) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;primcount &lt; 0&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;primcount &lt; 0&quot;);</span>
          return false;
      }
  
      if (!m_boundVertexArrayObject-&gt;getElementArrayBuffer()) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;no ELEMENT_ARRAY_BUFFER bound&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;no ELEMENT_ARRAY_BUFFER bound&quot;);</span>
          return false;
      }
  
      // Ensure we have a valid rendering state.
<span class="udiff-line-modified-removed">-     if (!validateElementArraySize(count, type, static_cast&lt;GC3Dintptr&gt;(offset))) {</span>
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;request out of bounds for current ELEMENT_ARRAY_BUFFER&quot;);</span>
<span class="udiff-line-modified-added">+     if (!validateElementArraySize(count, type, static_cast&lt;GCGLintptr&gt;(offset))) {</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;request out of bounds for current ELEMENT_ARRAY_BUFFER&quot;);</span>
          return false;
      }
      if (!count)
          return false;
  
<span class="udiff-line-modified-removed">-     Checked&lt;GC3Dint, RecordOverflow&gt; checkedCount(count);</span>
<span class="udiff-line-modified-removed">-     Checked&lt;GC3Dint, RecordOverflow&gt; checkedPrimitiveCount(primitiveCount);</span>
<span class="udiff-line-modified-added">+     Checked&lt;GCGLint, RecordOverflow&gt; checkedCount(count);</span>
<span class="udiff-line-modified-added">+     Checked&lt;GCGLint, RecordOverflow&gt; checkedPrimitiveCount(primitiveCount);</span>
      if (checkedCount.hasOverflowed() || checkedPrimitiveCount.hasOverflowed()) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;attempt to access out of bounds arrays&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;attempt to access out of bounds arrays&quot;);</span>
          return false;
      }
  
      if (!validateIndexArrayConservative(type, numElements) || !validateVertexAttributes(numElements, checkedPrimitiveCount.unsafeGet())) {
<span class="udiff-line-modified-removed">-         if (!validateIndexArrayPrecise(checkedCount.unsafeGet(), type, static_cast&lt;GC3Dintptr&gt;(offset), numElements) || !validateVertexAttributes(numElements, checkedPrimitiveCount.unsafeGet())) {</span>
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;attempt to access out of bounds arrays&quot;);</span>
<span class="udiff-line-modified-added">+         if (!validateIndexArrayPrecise(checkedCount.unsafeGet(), type, static_cast&lt;GCGLintptr&gt;(offset), numElements) || !validateVertexAttributes(numElements, checkedPrimitiveCount.unsafeGet())) {</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;attempt to access out of bounds arrays&quot;);</span>
              return false;
          }
      }
  
      if (!validateSimulatedVertexAttrib0(numElements)) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;attempt to access outside the bounds of the simulated vertexAttrib0 array&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;attempt to access outside the bounds of the simulated vertexAttrib0 array&quot;);</span>
          return false;
      }
  
      const char* reason = &quot;framebuffer incomplete&quot;;
<span class="udiff-line-modified-removed">-     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContext3D(), &amp;reason)) {</span>
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, functionName, reason);</span>
<span class="udiff-line-modified-added">+     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContextGL(), &amp;reason)) {</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, functionName, reason);</span>
          return false;
      }
  
      return true;
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::drawArrays(GC3Denum mode, GC3Dint first, GC3Dsizei count)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::drawArrays(GCGLenum mode, GCGLint first, GCGLsizei count)</span>
  {
      if (!validateDrawArrays(&quot;drawArrays&quot;, mode, first, count, 0))
          return;
  
<span class="udiff-line-modified-removed">-     if (m_currentProgram &amp;&amp; InspectorInstrumentation::isShaderProgramDisabled(*this, *m_currentProgram))</span>
<span class="udiff-line-modified-added">+     if (m_currentProgram &amp;&amp; InspectorInstrumentation::isWebGLProgramDisabled(*this, *m_currentProgram))</span>
          return;
  
      clearIfComposited();
  
      bool vertexAttrib0Simulated = false;
      if (!isGLES2Compliant()) {
          auto simulateVertexAttrib0Status = simulateVertexAttrib0(first + count - 1);
          if (!simulateVertexAttrib0Status) {
              // We were unable to simulate the attribute buffer.
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawArrays&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawArrays&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);</span>
              return;
          }
          vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
      }
      bool usesFallbackTexture = false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2286,44 +2307,44 @@</span>
          checkTextureCompleteness(&quot;drawArrays&quot;, false);
      markContextChangedAndNotifyCanvasObserver();
  }
  
  #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
<span class="udiff-line-modified-removed">- static GC3Duint getRestartIndex(GC3Denum type)</span>
<span class="udiff-line-modified-added">+ static GCGLuint getRestartIndex(GCGLenum type)</span>
  {
      switch (type) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_BYTE:</span>
<span class="udiff-line-modified-removed">-         return std::numeric_limits&lt;GC3Dubyte&gt;::max();</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_SHORT:</span>
<span class="udiff-line-modified-removed">-         return std::numeric_limits&lt;GC3Dushort&gt;::max();</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_INT:</span>
<span class="udiff-line-modified-removed">-         return std::numeric_limits&lt;GC3Duint&gt;::max();</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_BYTE:</span>
<span class="udiff-line-modified-added">+         return std::numeric_limits&lt;GCGLubyte&gt;::max();</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_SHORT:</span>
<span class="udiff-line-modified-added">+         return std::numeric_limits&lt;GCGLushort&gt;::max();</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_INT:</span>
<span class="udiff-line-modified-added">+         return std::numeric_limits&lt;GCGLuint&gt;::max();</span>
      }
  
      return 0;
  }
  #endif
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::drawElements(GC3Denum mode, GC3Dsizei count, GC3Denum type, long long offset)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::drawElements(GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset)</span>
  {
      unsigned numElements = 0;
      if (!validateDrawElements(&quot;drawElements&quot;, mode, count, type, offset, numElements, 0))
          return;
  
<span class="udiff-line-modified-removed">-     if (m_currentProgram &amp;&amp; InspectorInstrumentation::isShaderProgramDisabled(*this, *m_currentProgram))</span>
<span class="udiff-line-modified-added">+     if (m_currentProgram &amp;&amp; InspectorInstrumentation::isWebGLProgramDisabled(*this, *m_currentProgram))</span>
          return;
  
      clearIfComposited();
  
      bool vertexAttrib0Simulated = false;
      if (!isGLES2Compliant()) {
          if (!numElements)
<span class="udiff-line-modified-removed">-             validateIndexArrayPrecise(count, type, static_cast&lt;GC3Dintptr&gt;(offset), numElements);</span>
<span class="udiff-line-modified-added">+             validateIndexArrayPrecise(count, type, static_cast&lt;GCGLintptr&gt;(offset), numElements);</span>
          auto simulateVertexAttrib0Status = simulateVertexAttrib0(numElements);
          if (!simulateVertexAttrib0Status) {
              // We were unable to simulate the attribute buffer.
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawElements&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawElements&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);</span>
              return;
          }
          vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2337,40 +2358,40 @@</span>
  #endif
  
      {
          InspectorScopedShaderProgramHighlight scopedHighlight(*this, m_currentProgram.get());
  
<span class="udiff-line-modified-removed">-         m_context-&gt;drawElements(mode, count, type, static_cast&lt;GC3Dintptr&gt;(offset));</span>
<span class="udiff-line-modified-added">+         m_context-&gt;drawElements(mode, count, type, static_cast&lt;GCGLintptr&gt;(offset));</span>
      }
  
      if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
          restoreStatesAfterVertexAttrib0Simulation();
      if (usesFallbackTexture)
          checkTextureCompleteness(&quot;drawElements&quot;, false);
      markContextChangedAndNotifyCanvasObserver();
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::enable(GC3Denum cap)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::enable(GCGLenum cap)</span>
  {
      if (isContextLostOrPending() || !validateCapability(&quot;enable&quot;, cap))
          return;
<span class="udiff-line-modified-removed">-     if (cap == GraphicsContext3D::STENCIL_TEST) {</span>
<span class="udiff-line-modified-added">+     if (cap == GraphicsContextGL::STENCIL_TEST) {</span>
          m_stencilEnabled = true;
          applyStencilTest();
          return;
      }
<span class="udiff-line-modified-removed">-     if (cap == GraphicsContext3D::SCISSOR_TEST)</span>
<span class="udiff-line-modified-added">+     if (cap == GraphicsContextGL::SCISSOR_TEST)</span>
          m_scissorEnabled = true;
      m_context-&gt;enable(cap);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::enableVertexAttribArray(GC3Duint index)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::enableVertexAttribArray(GCGLuint index)</span>
  {
      if (isContextLostOrPending())
          return;
      if (index &gt;= m_maxVertexAttribs) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;enableVertexAttribArray&quot;, &quot;index out of range&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;enableVertexAttribArray&quot;, &quot;index out of range&quot;);</span>
          return;
      }
  
      WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(index);
      state.enabled = true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2390,147 +2411,145 @@</span>
      if (isContextLostOrPending())
          return;
      m_context-&gt;flush();
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::framebufferRenderbuffer(GC3Denum target, GC3Denum attachment, GC3Denum renderbuffertarget, WebGLRenderbuffer* buffer)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::framebufferRenderbuffer(GCGLenum target, GCGLenum attachment, GCGLenum renderbuffertarget, WebGLRenderbuffer* buffer)</span>
  {
      if (isContextLostOrPending() || !validateFramebufferFuncParameters(&quot;framebufferRenderbuffer&quot;, target, attachment))
          return;
<span class="udiff-line-modified-removed">-     if (renderbuffertarget != GraphicsContext3D::RENDERBUFFER) {</span>
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;framebufferRenderbuffer&quot;, &quot;invalid target&quot;);</span>
<span class="udiff-line-modified-added">+     if (renderbuffertarget != GraphicsContextGL::RENDERBUFFER) {</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;framebufferRenderbuffer&quot;, &quot;invalid target&quot;);</span>
          return;
      }
      if (buffer &amp;&amp; !buffer-&gt;validate(contextGroup(), *this)) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;framebufferRenderbuffer&quot;, &quot;no buffer or buffer not from this context&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;framebufferRenderbuffer&quot;, &quot;no buffer or buffer not from this context&quot;);</span>
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     if (buffer &amp;&amp; !buffer-&gt;hasEverBeenBound()) {</span>
<span class="udiff-line-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;framebufferRenderbuffer&quot;, &quot;buffer has never been bound&quot;);</span>
          return;
      }
  
<span class="udiff-line-modified-removed">-     auto targetFramebuffer = (target == GraphicsContext3D::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;</span>
<span class="udiff-line-modified-added">+     auto targetFramebuffer = (target == GraphicsContextGL::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;</span>
  
      // Don&#39;t allow the default framebuffer to be mutated; all current
      // implementations use an FBO internally in place of the default
      // FBO.
      if (!targetFramebuffer || !targetFramebuffer-&gt;object()) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;framebufferRenderbuffer&quot;, &quot;no framebuffer bound&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;framebufferRenderbuffer&quot;, &quot;no framebuffer bound&quot;);</span>
          return;
      }
<span class="udiff-line-modified-removed">-     Platform3DObject bufferObject = objectOrZero(buffer);</span>
<span class="udiff-line-modified-removed">-     switch (attachment) {</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT:</span>
<span class="udiff-line-modified-removed">-         m_context-&gt;framebufferRenderbuffer(target, GraphicsContext3D::DEPTH_ATTACHMENT, renderbuffertarget, bufferObject);</span>
<span class="udiff-line-modified-removed">-         m_context-&gt;framebufferRenderbuffer(target, GraphicsContext3D::STENCIL_ATTACHMENT, renderbuffertarget, bufferObject);</span>
<span class="udiff-line-modified-removed">-         break;</span>
<span class="udiff-line-modified-removed">-     default:</span>
<span class="udiff-line-modified-added">+     PlatformGLObject bufferObject = objectOrZero(buffer);</span>
<span class="udiff-line-modified-added">+ #if !USE(ANGLE)</span>
<span class="udiff-line-modified-added">+     if (attachment == GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT) {</span>
<span class="udiff-line-modified-added">+         m_context-&gt;framebufferRenderbuffer(target, GraphicsContextGL::DEPTH_ATTACHMENT, renderbuffertarget, bufferObject);</span>
<span class="udiff-line-modified-added">+         m_context-&gt;framebufferRenderbuffer(target, GraphicsContextGL::STENCIL_ATTACHMENT, renderbuffertarget, bufferObject);</span>
<span class="udiff-line-modified-added">+     } else</span>
<span class="udiff-line-modified-added">+ #endif</span>
          m_context-&gt;framebufferRenderbuffer(target, attachment, renderbuffertarget, bufferObject);
<span class="udiff-line-removed">-     }</span>
      targetFramebuffer-&gt;setAttachmentForBoundFramebuffer(attachment, buffer);
      applyStencilTest();
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::framebufferTexture2D(GC3Denum target, GC3Denum attachment, GC3Denum textarget, WebGLTexture* texture, GC3Dint level)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::framebufferTexture2D(GCGLenum target, GCGLenum attachment, GCGLenum textarget, WebGLTexture* texture, GCGLint level)</span>
  {
      if (isContextLostOrPending() || !validateFramebufferFuncParameters(&quot;framebufferTexture2D&quot;, target, attachment))
          return;
      if (level &amp;&amp; isWebGL1()) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;framebufferTexture2D&quot;, &quot;level not 0&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;framebufferTexture2D&quot;, &quot;level not 0&quot;);</span>
          return;
      }
      if (texture &amp;&amp; !texture-&gt;validate(contextGroup(), *this)) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;framebufferTexture2D&quot;, &quot;no texture or texture not from this context&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;framebufferTexture2D&quot;, &quot;no texture or texture not from this context&quot;);</span>
          return;
      }
  
<span class="udiff-line-modified-removed">-     auto targetFramebuffer = (target == GraphicsContext3D::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;</span>
<span class="udiff-line-modified-added">+     auto targetFramebuffer = (target == GraphicsContextGL::READ_FRAMEBUFFER) ? m_readFramebufferBinding : m_framebufferBinding;</span>
  
      // Don&#39;t allow the default framebuffer to be mutated; all current
      // implementations use an FBO internally in place of the default
      // FBO.
      if (!targetFramebuffer || !targetFramebuffer-&gt;object()) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;framebufferTexture2D&quot;, &quot;no framebuffer bound&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;framebufferTexture2D&quot;, &quot;no framebuffer bound&quot;);</span>
          return;
      }
<span class="udiff-line-modified-removed">-     Platform3DObject textureObject = objectOrZero(texture);</span>
<span class="udiff-line-modified-removed">-     switch (attachment) {</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT:</span>
<span class="udiff-line-modified-removed">-         m_context-&gt;framebufferTexture2D(target, GraphicsContext3D::DEPTH_ATTACHMENT, textarget, textureObject, level);</span>
<span class="udiff-line-modified-removed">-         m_context-&gt;framebufferTexture2D(target, GraphicsContext3D::STENCIL_ATTACHMENT, textarget, textureObject, level);</span>
<span class="udiff-line-modified-removed">-         break;</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::DEPTH_ATTACHMENT:</span>
<span class="udiff-line-modified-removed">-         m_context-&gt;framebufferTexture2D(target, attachment, textarget, textureObject, level);</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-     case GraphicsContext3D::STENCIL_ATTACHMENT:</span>
<span class="udiff-line-removed">-         m_context-&gt;framebufferTexture2D(target, attachment, textarget, textureObject, level);</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-     default:</span>
<span class="udiff-line-modified-added">+     PlatformGLObject textureObject = objectOrZero(texture);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ #if !USE_ANGLE</span>
<span class="udiff-line-modified-added">+     if (attachment == GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT) {</span>
<span class="udiff-line-modified-added">+         m_context-&gt;framebufferTexture2D(target, GraphicsContextGL::DEPTH_ATTACHMENT, textarget, textureObject, level);</span>
<span class="udiff-line-modified-added">+         m_context-&gt;framebufferTexture2D(target, GraphicsContextGL::STENCIL_ATTACHMENT, textarget, textureObject, level);</span>
<span class="udiff-line-modified-added">+     } else</span>
<span class="udiff-line-modified-added">+ #endif</span>
          m_context-&gt;framebufferTexture2D(target, attachment, textarget, textureObject, level);
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+ </span>
      targetFramebuffer-&gt;setAttachmentForBoundFramebuffer(attachment, textarget, texture, level);
      applyStencilTest();
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::frontFace(GC3Denum mode)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::frontFace(GCGLenum mode)</span>
  {
      if (isContextLostOrPending())
          return;
      m_context-&gt;frontFace(mode);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::generateMipmap(GC3Denum target)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::generateMipmap(GCGLenum target)</span>
  {
      if (isContextLostOrPending())
          return;
      auto tex = validateTextureBinding(&quot;generateMipmap&quot;, target, false);
      if (!tex)
          return;
      if (!tex-&gt;canGenerateMipmaps()) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;generateMipmap&quot;, &quot;level 0 not power of 2 or not all the same size&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;generateMipmap&quot;, &quot;level 0 not power of 2 or not all the same size&quot;);</span>
          return;
      }
      // FIXME: https://bugs.webkit.org/show_bug.cgi?id=123916. Compressed textures should be allowed in WebGL 2:
      if (tex-&gt;isCompressed()) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;generateMipmap&quot;, &quot;trying to generate mipmaps from compressed texture&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;generateMipmap&quot;, &quot;trying to generate mipmaps from compressed texture&quot;);</span>
          return;
      }
      if (!validateSettableTexInternalFormat(&quot;generateMipmap&quot;, tex-&gt;getInternalFormat(target, 0)))
          return;
  
      // generateMipmap won&#39;t work properly if minFilter is not NEAREST_MIPMAP_LINEAR
      // on Mac.  Remove the hack once this driver bug is fixed.
  #if OS(DARWIN)
      bool needToResetMinFilter = false;
<span class="udiff-line-modified-removed">-     if (tex-&gt;getMinFilter() != GraphicsContext3D::NEAREST_MIPMAP_LINEAR) {</span>
<span class="udiff-line-modified-removed">-         m_context-&gt;texParameteri(target, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::NEAREST_MIPMAP_LINEAR);</span>
<span class="udiff-line-modified-added">+     if (tex-&gt;getMinFilter() != GraphicsContextGL::NEAREST_MIPMAP_LINEAR) {</span>
<span class="udiff-line-modified-added">+         m_context-&gt;texParameteri(target, GraphicsContextGL::TEXTURE_MIN_FILTER, GraphicsContextGL::NEAREST_MIPMAP_LINEAR);</span>
          needToResetMinFilter = true;
      }
  #endif
      m_context-&gt;generateMipmap(target);
  #if OS(DARWIN)
      if (needToResetMinFilter)
<span class="udiff-line-modified-removed">-         m_context-&gt;texParameteri(target, GraphicsContext3D::TEXTURE_MIN_FILTER, tex-&gt;getMinFilter());</span>
<span class="udiff-line-modified-added">+         m_context-&gt;texParameteri(target, GraphicsContextGL::TEXTURE_MIN_FILTER, tex-&gt;getMinFilter());</span>
  #endif
      tex-&gt;generateMipmapLevelInfo();
  }
  
<span class="udiff-line-modified-removed">- RefPtr&lt;WebGLActiveInfo&gt; WebGLRenderingContextBase::getActiveAttrib(WebGLProgram* program, GC3Duint index)</span>
<span class="udiff-line-modified-added">+ RefPtr&lt;WebGLActiveInfo&gt; WebGLRenderingContextBase::getActiveAttrib(WebGLProgram* program, GCGLuint index)</span>
  {
      if (isContextLostOrPending() || !validateWebGLObject(&quot;getActiveAttrib&quot;, program))
          return nullptr;
<span class="udiff-line-modified-removed">-     ActiveInfo info;</span>
<span class="udiff-line-modified-added">+     GraphicsContextGL::ActiveInfo info;</span>
      if (!m_context-&gt;getActiveAttrib(objectOrZero(program), index, info))
          return nullptr;
  
      LOG(WebGL, &quot;Returning active attribute %d: %s&quot;, index, info.name.utf8().data());
  
      return WebGLActiveInfo::create(info.name, info.type, info.size);
  }
  
<span class="udiff-line-modified-removed">- RefPtr&lt;WebGLActiveInfo&gt; WebGLRenderingContextBase::getActiveUniform(WebGLProgram* program, GC3Duint index)</span>
<span class="udiff-line-modified-added">+ RefPtr&lt;WebGLActiveInfo&gt; WebGLRenderingContextBase::getActiveUniform(WebGLProgram* program, GCGLuint index)</span>
  {
      if (isContextLostOrPending() || !validateWebGLObject(&quot;getActiveUniform&quot;, program))
          return nullptr;
<span class="udiff-line-modified-removed">-     ActiveInfo info;</span>
<span class="udiff-line-modified-added">+     GraphicsContextGL::ActiveInfo info;</span>
      if (!m_context-&gt;getActiveUniform(objectOrZero(program), index, info))
          return nullptr;
      if (!isGLES2Compliant())
          if (info.size &gt; 1 &amp;&amp; !info.name.endsWith(&quot;[0]&quot;))
              info.name.append(&quot;[0]&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2543,74 +2562,74 @@</span>
  Optional&lt;Vector&lt;RefPtr&lt;WebGLShader&gt;&gt;&gt; WebGLRenderingContextBase::getAttachedShaders(WebGLProgram* program)
  {
      if (isContextLostOrPending() || !validateWebGLObject(&quot;getAttachedShaders&quot;, program))
          return WTF::nullopt;
  
<span class="udiff-line-modified-removed">-     const GC3Denum shaderTypes[] = {</span>
<span class="udiff-line-modified-removed">-         GraphicsContext3D::VERTEX_SHADER,</span>
<span class="udiff-line-modified-removed">-         GraphicsContext3D::FRAGMENT_SHADER</span>
<span class="udiff-line-modified-added">+     const GCGLenum shaderTypes[] = {</span>
<span class="udiff-line-modified-added">+         GraphicsContextGL::VERTEX_SHADER,</span>
<span class="udiff-line-modified-added">+         GraphicsContextGL::FRAGMENT_SHADER</span>
      };
      Vector&lt;RefPtr&lt;WebGLShader&gt;&gt; shaderObjects;
      for (auto shaderType : shaderTypes) {
          RefPtr&lt;WebGLShader&gt; shader = program-&gt;getAttachedShader(shaderType);
          if (shader)
              shaderObjects.append(shader);
      }
      return shaderObjects;
  }
  
<span class="udiff-line-modified-removed">- GC3Dint WebGLRenderingContextBase::getAttribLocation(WebGLProgram* program, const String&amp; name)</span>
<span class="udiff-line-modified-added">+ GCGLint WebGLRenderingContextBase::getAttribLocation(WebGLProgram* program, const String&amp; name)</span>
  {
      if (isContextLostOrPending() || !validateWebGLObject(&quot;getAttribLocation&quot;, program))
          return -1;
      if (!validateLocationLength(&quot;getAttribLocation&quot;, name))
          return -1;
      if (!validateString(&quot;getAttribLocation&quot;, name))
          return -1;
      if (isPrefixReserved(name))
          return -1;
      if (!program-&gt;getLinkStatus()) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getAttribLocation&quot;, &quot;program not linked&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getAttribLocation&quot;, &quot;program not linked&quot;);</span>
          return -1;
      }
      return m_context-&gt;getAttribLocation(objectOrZero(program), name);
  }
  
<span class="udiff-line-modified-removed">- WebGLAny WebGLRenderingContextBase::getBufferParameter(GC3Denum target, GC3Denum pname)</span>
<span class="udiff-line-modified-added">+ WebGLAny WebGLRenderingContextBase::getBufferParameter(GCGLenum target, GCGLenum pname)</span>
  {
      if (isContextLostOrPending())
          return nullptr;
  
      bool valid = false;
<span class="udiff-line-modified-removed">-     if (target == GraphicsContext3D::ARRAY_BUFFER || target == GraphicsContext3D::ELEMENT_ARRAY_BUFFER)</span>
<span class="udiff-line-modified-added">+     if (target == GraphicsContextGL::ARRAY_BUFFER || target == GraphicsContextGL::ELEMENT_ARRAY_BUFFER)</span>
          valid = true;
  #if ENABLE(WEBGL2)
      if (isWebGL2()) {
          switch (target) {
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::COPY_READ_BUFFER:</span>
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::COPY_WRITE_BUFFER:</span>
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::PIXEL_PACK_BUFFER:</span>
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::PIXEL_UNPACK_BUFFER:</span>
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::UNIFORM_BUFFER:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::COPY_READ_BUFFER:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::COPY_WRITE_BUFFER:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::PIXEL_PACK_BUFFER:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::PIXEL_UNPACK_BUFFER:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::UNIFORM_BUFFER:</span>
              valid = true;
          }
      }
  #endif
      if (!valid) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getBufferParameter&quot;, &quot;invalid target&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getBufferParameter&quot;, &quot;invalid target&quot;);</span>
          return nullptr;
      }
  
<span class="udiff-line-modified-removed">-     if (pname != GraphicsContext3D::BUFFER_SIZE &amp;&amp; pname != GraphicsContext3D::BUFFER_USAGE) {</span>
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getBufferParameter&quot;, &quot;invalid parameter name&quot;);</span>
<span class="udiff-line-modified-added">+     if (pname != GraphicsContextGL::BUFFER_SIZE &amp;&amp; pname != GraphicsContextGL::BUFFER_USAGE) {</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getBufferParameter&quot;, &quot;invalid parameter name&quot;);</span>
          return nullptr;
      }
  
<span class="udiff-line-modified-removed">-     GC3Dint value = 0;</span>
<span class="udiff-line-modified-added">+     GCGLint value = 0;</span>
      m_context-&gt;getBufferParameteriv(target, pname, &amp;value);
<span class="udiff-line-modified-removed">-     if (pname == GraphicsContext3D::BUFFER_SIZE)</span>
<span class="udiff-line-modified-added">+     if (pname == GraphicsContextGL::BUFFER_SIZE)</span>
          return value;
      return static_cast&lt;unsigned&gt;(value);
  }
  
  Optional&lt;WebGLContextAttributes&gt; WebGLRenderingContextBase::getContextAttributes()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2618,54 +2637,67 @@</span>
      if (isContextLostOrPending())
          return WTF::nullopt;
  
      // Also, we need to enforce requested values of &quot;false&quot; for depth
      // and stencil, regardless of the properties of the underlying
<span class="udiff-line-modified-removed">-     // GraphicsContext3D.</span>
<span class="udiff-line-modified-added">+     // GraphicsContextGLOpenGL.</span>
  
<span class="udiff-line-modified-removed">-     auto attributes = m_context-&gt;getContextAttributes();</span>
<span class="udiff-line-modified-added">+     auto attributes = m_context-&gt;contextAttributes();</span>
      if (!m_attributes.depth)
          attributes.depth = false;
      if (!m_attributes.stencil)
          attributes.stencil = false;
      return attributes;
  }
  
<span class="udiff-line-modified-removed">- GC3Denum WebGLRenderingContextBase::getError()</span>
<span class="udiff-line-modified-added">+ GCGLenum WebGLRenderingContextBase::getError()</span>
  {
      if (m_isPendingPolicyResolution)
<span class="udiff-line-modified-removed">-         return GraphicsContext3D::NO_ERROR;</span>
<span class="udiff-line-modified-added">+         return GraphicsContextGL::NO_ERROR;</span>
      return m_context-&gt;getError();
  }
  
<span class="udiff-line-modified-removed">- WebGLAny WebGLRenderingContextBase::getProgramParameter(WebGLProgram* program, GC3Denum pname)</span>
<span class="udiff-line-modified-added">+ WebGLAny WebGLRenderingContextBase::getProgramParameter(WebGLProgram* program, GCGLenum pname)</span>
  {
      if (isContextLostOrPending() || !validateWebGLObject(&quot;getProgramParameter&quot;, program))
          return nullptr;
  
<span class="udiff-line-modified-removed">-     GC3Dint value = 0;</span>
<span class="udiff-line-modified-added">+     GCGLint value = 0;</span>
      switch (pname) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::DELETE_STATUS:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::DELETE_STATUS:</span>
          return program-&gt;isDeleted();
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::VALIDATE_STATUS:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::VALIDATE_STATUS:</span>
          m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
          return static_cast&lt;bool&gt;(value);
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::LINK_STATUS:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::LINK_STATUS:</span>
          return program-&gt;getLinkStatus();
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::ATTACHED_SHADERS:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::ATTACHED_SHADERS:</span>
          m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
          return value;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::ACTIVE_ATTRIBUTES:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::ACTIVE_UNIFORMS:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::ACTIVE_ATTRIBUTES:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::ACTIVE_UNIFORMS:</span>
  #if USE(ANGLE)
          m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);
  #else
          m_context-&gt;getNonBuiltInActiveSymbolCount(objectOrZero(program), pname, &amp;value);
  #endif // USE(ANGLE)
          return value;
      default:
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getProgramParameter&quot;, &quot;invalid parameter name&quot;);</span>
<span class="udiff-line-modified-added">+ #if ENABLE(WEBGL2)</span>
<span class="udiff-line-added">+         if (isWebGL2()) {</span>
<span class="udiff-line-added">+             switch (pname) {</span>
<span class="udiff-line-added">+             case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER_MODE:</span>
<span class="udiff-line-added">+             case GraphicsContextGL::TRANSFORM_FEEDBACK_VARYINGS:</span>
<span class="udiff-line-added">+             case GraphicsContextGL::ACTIVE_UNIFORM_BLOCKS:</span>
<span class="udiff-line-added">+                 m_context-&gt;getProgramiv(objectOrZero(program), pname, &amp;value);</span>
<span class="udiff-line-added">+                 return value;</span>
<span class="udiff-line-added">+             default:</span>
<span class="udiff-line-added">+                 break;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ #endif // ENABLE(WEBGL2)</span>
<span class="udiff-line-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getProgramParameter&quot;, &quot;invalid parameter name&quot;);</span>
          return nullptr;
      }
  }
  
  String WebGLRenderingContextBase::getProgramInfoLog(WebGLProgram* program)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2673,91 +2705,91 @@</span>
      if (isContextLostOrPending() || !validateWebGLObject(&quot;getProgramInfoLog&quot;, program))
          return String();
      return ensureNotNull(m_context-&gt;getProgramInfoLog(objectOrZero(program)));
  }
  
<span class="udiff-line-modified-removed">- WebGLAny WebGLRenderingContextBase::getRenderbufferParameter(GC3Denum target, GC3Denum pname)</span>
<span class="udiff-line-modified-added">+ WebGLAny WebGLRenderingContextBase::getRenderbufferParameter(GCGLenum target, GCGLenum pname)</span>
  {
      if (isContextLostOrPending())
          return nullptr;
<span class="udiff-line-modified-removed">-     if (target != GraphicsContext3D::RENDERBUFFER) {</span>
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid target&quot;);</span>
<span class="udiff-line-modified-added">+     if (target != GraphicsContextGL::RENDERBUFFER) {</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid target&quot;);</span>
          return nullptr;
      }
      if (!m_renderbufferBinding || !m_renderbufferBinding-&gt;object()) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getRenderbufferParameter&quot;, &quot;no renderbuffer bound&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getRenderbufferParameter&quot;, &quot;no renderbuffer bound&quot;);</span>
          return nullptr;
      }
  
<span class="udiff-line-modified-removed">-     if (m_renderbufferBinding-&gt;getInternalFormat() == GraphicsContext3D::DEPTH_STENCIL</span>
<span class="udiff-line-modified-added">+     if (m_renderbufferBinding-&gt;getInternalFormat() == GraphicsContextGL::DEPTH_STENCIL</span>
          &amp;&amp; !m_renderbufferBinding-&gt;isValid()) {
          ASSERT(!isDepthStencilSupported());
          int value = 0;
          switch (pname) {
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::RENDERBUFFER_WIDTH:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::RENDERBUFFER_WIDTH:</span>
              value = m_renderbufferBinding-&gt;getWidth();
              break;
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::RENDERBUFFER_HEIGHT:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::RENDERBUFFER_HEIGHT:</span>
              value = m_renderbufferBinding-&gt;getHeight();
              break;
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::RENDERBUFFER_RED_SIZE:</span>
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::RENDERBUFFER_GREEN_SIZE:</span>
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::RENDERBUFFER_BLUE_SIZE:</span>
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::RENDERBUFFER_ALPHA_SIZE:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::RENDERBUFFER_RED_SIZE:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::RENDERBUFFER_GREEN_SIZE:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::RENDERBUFFER_BLUE_SIZE:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::RENDERBUFFER_ALPHA_SIZE:</span>
              value = 0;
              break;
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::RENDERBUFFER_DEPTH_SIZE:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::RENDERBUFFER_DEPTH_SIZE:</span>
              value = 24;
              break;
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::RENDERBUFFER_STENCIL_SIZE:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::RENDERBUFFER_STENCIL_SIZE:</span>
              value = 8;
              break;
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::RENDERBUFFER_INTERNAL_FORMAT:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::RENDERBUFFER_INTERNAL_FORMAT:</span>
              return m_renderbufferBinding-&gt;getInternalFormat();
          default:
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid parameter name&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid parameter name&quot;);</span>
              return nullptr;
          }
          return value;
      }
  
<span class="udiff-line-modified-removed">-     GC3Dint value = 0;</span>
<span class="udiff-line-modified-added">+     GCGLint value = 0;</span>
      switch (pname) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RENDERBUFFER_WIDTH:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RENDERBUFFER_HEIGHT:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RENDERBUFFER_RED_SIZE:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RENDERBUFFER_GREEN_SIZE:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RENDERBUFFER_BLUE_SIZE:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RENDERBUFFER_ALPHA_SIZE:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RENDERBUFFER_DEPTH_SIZE:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RENDERBUFFER_STENCIL_SIZE:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RENDERBUFFER_WIDTH:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RENDERBUFFER_HEIGHT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RENDERBUFFER_RED_SIZE:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RENDERBUFFER_GREEN_SIZE:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RENDERBUFFER_BLUE_SIZE:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RENDERBUFFER_ALPHA_SIZE:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RENDERBUFFER_DEPTH_SIZE:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RENDERBUFFER_STENCIL_SIZE:</span>
          m_context-&gt;getRenderbufferParameteriv(target, pname, &amp;value);
          return value;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RENDERBUFFER_INTERNAL_FORMAT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RENDERBUFFER_INTERNAL_FORMAT:</span>
          return m_renderbufferBinding-&gt;getInternalFormat();
      default:
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid parameter name&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getRenderbufferParameter&quot;, &quot;invalid parameter name&quot;);</span>
          return nullptr;
      }
  }
  
<span class="udiff-line-modified-removed">- WebGLAny WebGLRenderingContextBase::getShaderParameter(WebGLShader* shader, GC3Denum pname)</span>
<span class="udiff-line-modified-added">+ WebGLAny WebGLRenderingContextBase::getShaderParameter(WebGLShader* shader, GCGLenum pname)</span>
  {
      if (isContextLostOrPending() || !validateWebGLObject(&quot;getShaderParameter&quot;, shader))
          return nullptr;
<span class="udiff-line-modified-removed">-     GC3Dint value = 0;</span>
<span class="udiff-line-modified-added">+     GCGLint value = 0;</span>
      switch (pname) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::DELETE_STATUS:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::DELETE_STATUS:</span>
          return shader-&gt;isDeleted();
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::COMPILE_STATUS:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::COMPILE_STATUS:</span>
          m_context-&gt;getShaderiv(objectOrZero(shader), pname, &amp;value);
          return static_cast&lt;bool&gt;(value);
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::SHADER_TYPE:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::SHADER_TYPE:</span>
          m_context-&gt;getShaderiv(objectOrZero(shader), pname, &amp;value);
          return static_cast&lt;unsigned&gt;(value);
      default:
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getShaderParameter&quot;, &quot;invalid parameter name&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getShaderParameter&quot;, &quot;invalid parameter name&quot;);</span>
          return nullptr;
      }
  }
  
  String WebGLRenderingContextBase::getShaderInfoLog(WebGLShader* shader)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2765,37 +2797,37 @@</span>
      if (isContextLostOrPending() || !validateWebGLObject(&quot;getShaderInfoLog&quot;, shader))
          return String();
      return ensureNotNull(m_context-&gt;getShaderInfoLog(objectOrZero(shader)));
  }
  
<span class="udiff-line-modified-removed">- RefPtr&lt;WebGLShaderPrecisionFormat&gt; WebGLRenderingContextBase::getShaderPrecisionFormat(GC3Denum shaderType, GC3Denum precisionType)</span>
<span class="udiff-line-modified-added">+ RefPtr&lt;WebGLShaderPrecisionFormat&gt; WebGLRenderingContextBase::getShaderPrecisionFormat(GCGLenum shaderType, GCGLenum precisionType)</span>
  {
      if (isContextLostOrPending())
          return nullptr;
      switch (shaderType) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::VERTEX_SHADER:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::FRAGMENT_SHADER:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::VERTEX_SHADER:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::FRAGMENT_SHADER:</span>
          break;
      default:
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getShaderPrecisionFormat&quot;, &quot;invalid shader type&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getShaderPrecisionFormat&quot;, &quot;invalid shader type&quot;);</span>
          return nullptr;
      }
      switch (precisionType) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::LOW_FLOAT:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::MEDIUM_FLOAT:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::HIGH_FLOAT:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::LOW_INT:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::MEDIUM_INT:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::HIGH_INT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::LOW_FLOAT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::MEDIUM_FLOAT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::HIGH_FLOAT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::LOW_INT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::MEDIUM_INT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::HIGH_INT:</span>
          break;
      default:
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getShaderPrecisionFormat&quot;, &quot;invalid precision type&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getShaderPrecisionFormat&quot;, &quot;invalid precision type&quot;);</span>
          return nullptr;
      }
  
<span class="udiff-line-modified-removed">-     GC3Dint range[2] = {0, 0};</span>
<span class="udiff-line-modified-removed">-     GC3Dint precision = 0;</span>
<span class="udiff-line-modified-added">+     GCGLint range[2] = {0, 0};</span>
<span class="udiff-line-modified-added">+     GCGLint precision = 0;</span>
      m_context-&gt;getShaderPrecisionFormat(shaderType, precisionType, range, &amp;precision);
      return WebGLShaderPrecisionFormat::create(range[0], range[1], precision);
  }
  
  String WebGLRenderingContextBase::getShaderSource(WebGLShader* shader)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2803,146 +2835,147 @@</span>
      if (isContextLostOrPending() || !validateWebGLObject(&quot;getShaderSource&quot;, shader))
          return String();
      return ensureNotNull(shader-&gt;getSource());
  }
  
<span class="udiff-line-modified-removed">- WebGLAny WebGLRenderingContextBase::getTexParameter(GC3Denum target, GC3Denum pname)</span>
<span class="udiff-line-modified-added">+ WebGLAny WebGLRenderingContextBase::getTexParameter(GCGLenum target, GCGLenum pname)</span>
  {
      if (isContextLostOrPending())
          return nullptr;
      auto tex = validateTextureBinding(&quot;getTexParameter&quot;, target, false);
      if (!tex)
          return nullptr;
<span class="udiff-line-modified-removed">-     GC3Dint value = 0;</span>
<span class="udiff-line-modified-added">+     GCGLint value = 0;</span>
<span class="udiff-line-added">+     GCGLfloat fValue = 0;</span>
      switch (pname) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_MAG_FILTER:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_MIN_FILTER:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_WRAP_S:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_WRAP_T:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_MAG_FILTER:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_MIN_FILTER:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_WRAP_S:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_WRAP_T:</span>
          m_context-&gt;getTexParameteriv(target, pname, &amp;value);
          return static_cast&lt;unsigned&gt;(value);
<span class="udiff-line-modified-removed">-     case Extensions3D::TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic</span>
          if (m_extTextureFilterAnisotropic) {
<span class="udiff-line-modified-removed">-             m_context-&gt;getTexParameteriv(target, pname, &amp;value);</span>
<span class="udiff-line-modified-removed">-             return static_cast&lt;unsigned&gt;(value);</span>
<span class="udiff-line-modified-added">+             m_context-&gt;getTexParameterfv(target, pname, &amp;fValue);</span>
<span class="udiff-line-modified-added">+             return static_cast&lt;float&gt;(fValue);</span>
          }
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getTexParameter&quot;, &quot;invalid parameter name, EXT_texture_filter_anisotropic not enabled&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getTexParameter&quot;, &quot;invalid parameter name, EXT_texture_filter_anisotropic not enabled&quot;);</span>
          return nullptr;
      default:
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getTexParameter&quot;, &quot;invalid parameter name&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getTexParameter&quot;, &quot;invalid parameter name&quot;);</span>
          return nullptr;
      }
  }
  
  WebGLAny WebGLRenderingContextBase::getUniform(WebGLProgram* program, const WebGLUniformLocation* uniformLocation)
  {
      if (isContextLostOrPending() || !validateWebGLObject(&quot;getUniform&quot;, program))
          return nullptr;
      if (!uniformLocation || uniformLocation-&gt;program() != program) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getUniform&quot;, &quot;no uniformlocation or not valid for this program&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getUniform&quot;, &quot;no uniformlocation or not valid for this program&quot;);</span>
          return nullptr;
      }
<span class="udiff-line-modified-removed">-     GC3Dint location = uniformLocation-&gt;location();</span>
<span class="udiff-line-modified-added">+     GCGLint location = uniformLocation-&gt;location();</span>
  
<span class="udiff-line-modified-removed">-     GC3Denum baseType;</span>
<span class="udiff-line-modified-added">+     GCGLenum baseType;</span>
      unsigned length;
      switch (uniformLocation-&gt;type()) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::BOOL:</span>
<span class="udiff-line-modified-removed">-         baseType = GraphicsContext3D::BOOL;</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::BOOL:</span>
<span class="udiff-line-modified-added">+         baseType = GraphicsContextGL::BOOL;</span>
          length = 1;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::BOOL_VEC2:</span>
<span class="udiff-line-modified-removed">-         baseType = GraphicsContext3D::BOOL;</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::BOOL_VEC2:</span>
<span class="udiff-line-modified-added">+         baseType = GraphicsContextGL::BOOL;</span>
          length = 2;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::BOOL_VEC3:</span>
<span class="udiff-line-modified-removed">-         baseType = GraphicsContext3D::BOOL;</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::BOOL_VEC3:</span>
<span class="udiff-line-modified-added">+         baseType = GraphicsContextGL::BOOL;</span>
          length = 3;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::BOOL_VEC4:</span>
<span class="udiff-line-modified-removed">-         baseType = GraphicsContext3D::BOOL;</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::BOOL_VEC4:</span>
<span class="udiff-line-modified-added">+         baseType = GraphicsContextGL::BOOL;</span>
          length = 4;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::INT:</span>
<span class="udiff-line-modified-removed">-         baseType = GraphicsContext3D::INT;</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::INT:</span>
<span class="udiff-line-modified-added">+         baseType = GraphicsContextGL::INT;</span>
          length = 1;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::INT_VEC2:</span>
<span class="udiff-line-modified-removed">-         baseType = GraphicsContext3D::INT;</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::INT_VEC2:</span>
<span class="udiff-line-modified-added">+         baseType = GraphicsContextGL::INT;</span>
          length = 2;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::INT_VEC3:</span>
<span class="udiff-line-modified-removed">-         baseType = GraphicsContext3D::INT;</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::INT_VEC3:</span>
<span class="udiff-line-modified-added">+         baseType = GraphicsContextGL::INT;</span>
          length = 3;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::INT_VEC4:</span>
<span class="udiff-line-modified-removed">-         baseType = GraphicsContext3D::INT;</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::INT_VEC4:</span>
<span class="udiff-line-modified-added">+         baseType = GraphicsContextGL::INT;</span>
          length = 4;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::FLOAT:</span>
<span class="udiff-line-modified-removed">-         baseType = GraphicsContext3D::FLOAT;</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::FLOAT:</span>
<span class="udiff-line-modified-added">+         baseType = GraphicsContextGL::FLOAT;</span>
          length = 1;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::FLOAT_VEC2:</span>
<span class="udiff-line-modified-removed">-         baseType = GraphicsContext3D::FLOAT;</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::FLOAT_VEC2:</span>
<span class="udiff-line-modified-added">+         baseType = GraphicsContextGL::FLOAT;</span>
          length = 2;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::FLOAT_VEC3:</span>
<span class="udiff-line-modified-removed">-         baseType = GraphicsContext3D::FLOAT;</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::FLOAT_VEC3:</span>
<span class="udiff-line-modified-added">+         baseType = GraphicsContextGL::FLOAT;</span>
          length = 3;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::FLOAT_VEC4:</span>
<span class="udiff-line-modified-removed">-         baseType = GraphicsContext3D::FLOAT;</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::FLOAT_VEC4:</span>
<span class="udiff-line-modified-added">+         baseType = GraphicsContextGL::FLOAT;</span>
          length = 4;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::FLOAT_MAT2:</span>
<span class="udiff-line-modified-removed">-         baseType = GraphicsContext3D::FLOAT;</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::FLOAT_MAT2:</span>
<span class="udiff-line-modified-added">+         baseType = GraphicsContextGL::FLOAT;</span>
          length = 4;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::FLOAT_MAT3:</span>
<span class="udiff-line-modified-removed">-         baseType = GraphicsContext3D::FLOAT;</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::FLOAT_MAT3:</span>
<span class="udiff-line-modified-added">+         baseType = GraphicsContextGL::FLOAT;</span>
          length = 9;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::FLOAT_MAT4:</span>
<span class="udiff-line-modified-removed">-         baseType = GraphicsContext3D::FLOAT;</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::FLOAT_MAT4:</span>
<span class="udiff-line-modified-added">+         baseType = GraphicsContextGL::FLOAT;</span>
          length = 16;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::SAMPLER_2D:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::SAMPLER_CUBE:</span>
<span class="udiff-line-modified-removed">-         baseType = GraphicsContext3D::INT;</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::SAMPLER_2D:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::SAMPLER_CUBE:</span>
<span class="udiff-line-modified-added">+         baseType = GraphicsContextGL::INT;</span>
          length = 1;
          break;
      default:
          // Can&#39;t handle this type
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;getUniform&quot;, &quot;unhandled type&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;getUniform&quot;, &quot;unhandled type&quot;);</span>
          return nullptr;
      }
      switch (baseType) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::FLOAT: {</span>
<span class="udiff-line-modified-removed">-         GC3Dfloat value[16] = {0};</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::FLOAT: {</span>
<span class="udiff-line-modified-added">+         GCGLfloat value[16] = {0};</span>
          if (m_isRobustnessEXTSupported)
<span class="udiff-line-modified-removed">-             m_context-&gt;getExtensions().getnUniformfvEXT(objectOrZero(program), location, 16 * sizeof(GC3Dfloat), value);</span>
<span class="udiff-line-modified-added">+             m_context-&gt;getExtensions().getnUniformfvEXT(objectOrZero(program), location, 16 * sizeof(GCGLfloat), value);</span>
          else
              m_context-&gt;getUniformfv(objectOrZero(program), location, value);
          if (length == 1)
              return value[0];
          return Float32Array::tryCreate(value, length);
      }
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::INT: {</span>
<span class="udiff-line-modified-removed">-         GC3Dint value[4] = {0};</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::INT: {</span>
<span class="udiff-line-modified-added">+         GCGLint value[4] = {0};</span>
          if (m_isRobustnessEXTSupported)
<span class="udiff-line-modified-removed">-             m_context-&gt;getExtensions().getnUniformivEXT(objectOrZero(program), location, 4 * sizeof(GC3Dint), value);</span>
<span class="udiff-line-modified-added">+             m_context-&gt;getExtensions().getnUniformivEXT(objectOrZero(program), location, 4 * sizeof(GCGLint), value);</span>
          else
              m_context-&gt;getUniformiv(objectOrZero(program), location, value);
          if (length == 1)
              return value[0];
          return Int32Array::tryCreate(value, length);
      }
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::BOOL: {</span>
<span class="udiff-line-modified-removed">-         GC3Dint value[4] = {0};</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::BOOL: {</span>
<span class="udiff-line-modified-added">+         GCGLint value[4] = {0};</span>
          if (m_isRobustnessEXTSupported)
<span class="udiff-line-modified-removed">-             m_context-&gt;getExtensions().getnUniformivEXT(objectOrZero(program), location, 4 * sizeof(GC3Dint), value);</span>
<span class="udiff-line-modified-added">+             m_context-&gt;getExtensions().getnUniformivEXT(objectOrZero(program), location, 4 * sizeof(GCGLint), value);</span>
          else
              m_context-&gt;getUniformiv(objectOrZero(program), location, value);
          if (length &gt; 1) {
              Vector&lt;bool&gt; vector(length);
              for (unsigned j = 0; j &lt; length; j++)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2954,11 +2987,11 @@</span>
      default:
          notImplemented();
      }
  
      // If we get here, something went wrong in our unfortunately complex logic above
<span class="udiff-line-modified-removed">-     synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;getUniform&quot;, &quot;unknown error&quot;);</span>
<span class="udiff-line-modified-added">+     synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;getUniform&quot;, &quot;unknown error&quot;);</span>
      return nullptr;
  }
  
  RefPtr&lt;WebGLUniformLocation&gt; WebGLRenderingContextBase::getUniformLocation(WebGLProgram* program, const String&amp; name)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2969,82 +3002,82 @@</span>
      if (!validateString(&quot;getUniformLocation&quot;, name))
          return nullptr;
      if (isPrefixReserved(name))
          return nullptr;
      if (!program-&gt;getLinkStatus()) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;getUniformLocation&quot;, &quot;program not linked&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;getUniformLocation&quot;, &quot;program not linked&quot;);</span>
          return nullptr;
      }
<span class="udiff-line-modified-removed">-     GC3Dint uniformLocation = m_context-&gt;getUniformLocation(objectOrZero(program), name);</span>
<span class="udiff-line-modified-added">+     GCGLint uniformLocation = m_context-&gt;getUniformLocation(objectOrZero(program), name);</span>
      if (uniformLocation == -1)
          return nullptr;
  
<span class="udiff-line-modified-removed">-     GC3Dint activeUniforms = 0;</span>
<span class="udiff-line-modified-added">+     GCGLint activeUniforms = 0;</span>
  #if USE(ANGLE)
<span class="udiff-line-modified-removed">-     m_context-&gt;getProgramiv(objectOrZero(program), GraphicsContext3D::ACTIVE_UNIFORMS, &amp;activeUniforms);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;getProgramiv(objectOrZero(program), GraphicsContextGL::ACTIVE_UNIFORMS, &amp;activeUniforms);</span>
  #else
<span class="udiff-line-modified-removed">-     m_context-&gt;getNonBuiltInActiveSymbolCount(objectOrZero(program), GraphicsContext3D::ACTIVE_UNIFORMS, &amp;activeUniforms);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;getNonBuiltInActiveSymbolCount(objectOrZero(program), GraphicsContextGL::ACTIVE_UNIFORMS, &amp;activeUniforms);</span>
  #endif
<span class="udiff-line-modified-removed">-     for (GC3Dint i = 0; i &lt; activeUniforms; i++) {</span>
<span class="udiff-line-modified-removed">-         ActiveInfo info;</span>
<span class="udiff-line-modified-added">+     for (GCGLint i = 0; i &lt; activeUniforms; i++) {</span>
<span class="udiff-line-modified-added">+         GraphicsContextGL::ActiveInfo info;</span>
          if (!m_context-&gt;getActiveUniform(objectOrZero(program), i, info))
              return nullptr;
          // Strip &quot;[0]&quot; from the name if it&#39;s an array.
          if (info.name.endsWith(&quot;[0]&quot;))
              info.name = info.name.left(info.name.length() - 3);
          // If it&#39;s an array, we need to iterate through each element, appending &quot;[index]&quot; to the name.
<span class="udiff-line-modified-removed">-         for (GC3Dint index = 0; index &lt; info.size; ++index) {</span>
<span class="udiff-line-modified-added">+         for (GCGLint index = 0; index &lt; info.size; ++index) {</span>
              String uniformName = makeString(info.name, &#39;[&#39;, index, &#39;]&#39;);
  
              if (name == uniformName || name == info.name)
                  return WebGLUniformLocation::create(program, uniformLocation, info.type);
          }
      }
      return nullptr;
  }
  
<span class="udiff-line-modified-removed">- WebGLAny WebGLRenderingContextBase::getVertexAttrib(GC3Duint index, GC3Denum pname)</span>
<span class="udiff-line-modified-added">+ WebGLAny WebGLRenderingContextBase::getVertexAttrib(GCGLuint index, GCGLenum pname)</span>
  {
      if (isContextLostOrPending())
          return nullptr;
  
      if (index &gt;= m_maxVertexAttribs) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;getVertexAttrib&quot;, &quot;index out of range&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;getVertexAttrib&quot;, &quot;index out of range&quot;);</span>
          return nullptr;
      }
  
      const WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(index);
  
<span class="udiff-line-modified-removed">-     if ((isWebGL2() || m_angleInstancedArrays) &amp;&amp; pname == GraphicsContext3D::VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE)</span>
<span class="udiff-line-modified-added">+     if ((isWebGL2() || m_angleInstancedArrays) &amp;&amp; pname == GraphicsContextGL::VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE)</span>
          return state.divisor;
  
      switch (pname) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:</span>
          if ((!isGLES2Compliant() &amp;&amp; !index &amp;&amp; m_boundVertexArrayObject-&gt;getVertexAttribState(0).bufferBinding == m_vertexAttrib0Buffer)
              || !state.bufferBinding
              || !state.bufferBinding-&gt;object())
              return nullptr;
          return state.bufferBinding;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::VERTEX_ATTRIB_ARRAY_ENABLED:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::VERTEX_ATTRIB_ARRAY_ENABLED:</span>
          return state.enabled;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::VERTEX_ATTRIB_ARRAY_NORMALIZED:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::VERTEX_ATTRIB_ARRAY_NORMALIZED:</span>
          return state.normalized;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::VERTEX_ATTRIB_ARRAY_SIZE:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::VERTEX_ATTRIB_ARRAY_SIZE:</span>
          return state.size;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::VERTEX_ATTRIB_ARRAY_STRIDE:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::VERTEX_ATTRIB_ARRAY_STRIDE:</span>
          return state.originalStride;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::VERTEX_ATTRIB_ARRAY_TYPE:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::VERTEX_ATTRIB_ARRAY_TYPE:</span>
          return state.type;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::CURRENT_VERTEX_ATTRIB:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::CURRENT_VERTEX_ATTRIB:</span>
          return Float32Array::tryCreate(m_vertexAttribValue[index].value, 4);
      default:
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;getVertexAttrib&quot;, &quot;invalid parameter name&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;getVertexAttrib&quot;, &quot;invalid parameter name&quot;);</span>
          return nullptr;
      }
  }
  
<span class="udiff-line-modified-removed">- long long WebGLRenderingContextBase::getVertexAttribOffset(GC3Duint index, GC3Denum pname)</span>
<span class="udiff-line-modified-added">+ long long WebGLRenderingContextBase::getVertexAttribOffset(GCGLuint index, GCGLenum pname)</span>
  {
      if (isContextLostOrPending())
          return 0;
      return m_context-&gt;getVertexAttribOffset(index, pname);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3069,20 +3102,23 @@</span>
      CHECK_EXTENSION(m_oesVertexArrayObject, &quot;OES_vertex_array_object&quot;);
      CHECK_EXTENSION(m_oesElementIndexUint, &quot;OES_element_index_uint&quot;);
      CHECK_EXTENSION(m_webglLoseContext, &quot;WEBGL_lose_context&quot;);
      CHECK_EXTENSION(m_webglDebugRendererInfo, &quot;WEBGL_debug_renderer_info&quot;);
      CHECK_EXTENSION(m_webglDebugShaders, &quot;WEBGL_debug_shaders&quot;);
<span class="udiff-line-added">+     CHECK_EXTENSION(m_webglCompressedTextureASTC, &quot;WEBGL_compressed_texture_astc&quot;);</span>
      CHECK_EXTENSION(m_webglCompressedTextureATC, &quot;WEBKIT_WEBGL_compressed_texture_atc&quot;);
<span class="udiff-line-added">+     CHECK_EXTENSION(m_webglCompressedTextureETC, &quot;WEBGL_compressed_texture_etc&quot;);</span>
<span class="udiff-line-added">+     CHECK_EXTENSION(m_webglCompressedTextureETC1, &quot;WEBGL_compressed_texture_etc1&quot;);</span>
      CHECK_EXTENSION(m_webglCompressedTexturePVRTC, &quot;WEBKIT_WEBGL_compressed_texture_pvrtc&quot;);
      CHECK_EXTENSION(m_webglCompressedTextureS3TC, &quot;WEBGL_compressed_texture_s3tc&quot;);
      CHECK_EXTENSION(m_webglDepthTexture, &quot;WEBGL_depth_texture&quot;);
      CHECK_EXTENSION(m_webglDrawBuffers, &quot;WEBGL_draw_buffers&quot;);
      CHECK_EXTENSION(m_angleInstancedArrays, &quot;ANGLE_instanced_arrays&quot;);
      return false;
  }
  
<span class="udiff-line-modified-removed">- GC3Dboolean WebGLRenderingContextBase::isBuffer(WebGLBuffer* buffer)</span>
<span class="udiff-line-modified-added">+ GCGLboolean WebGLRenderingContextBase::isBuffer(WebGLBuffer* buffer)</span>
  {
      if (!buffer || isContextLostOrPending())
          return 0;
  
      if (!buffer-&gt;hasEverBeenBound())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3115,69 +3151,69 @@</span>
      }
  
      return m_contextLost || m_isPendingPolicyResolution;
  }
  
<span class="udiff-line-modified-removed">- GC3Dboolean WebGLRenderingContextBase::isEnabled(GC3Denum cap)</span>
<span class="udiff-line-modified-added">+ GCGLboolean WebGLRenderingContextBase::isEnabled(GCGLenum cap)</span>
  {
      if (isContextLostOrPending() || !validateCapability(&quot;isEnabled&quot;, cap))
          return 0;
<span class="udiff-line-modified-removed">-     if (cap == GraphicsContext3D::STENCIL_TEST)</span>
<span class="udiff-line-modified-added">+     if (cap == GraphicsContextGL::STENCIL_TEST)</span>
          return m_stencilEnabled;
      return m_context-&gt;isEnabled(cap);
  }
  
<span class="udiff-line-modified-removed">- GC3Dboolean WebGLRenderingContextBase::isFramebuffer(WebGLFramebuffer* framebuffer)</span>
<span class="udiff-line-modified-added">+ GCGLboolean WebGLRenderingContextBase::isFramebuffer(WebGLFramebuffer* framebuffer)</span>
  {
      if (!framebuffer || isContextLostOrPending())
          return 0;
  
      if (!framebuffer-&gt;hasEverBeenBound())
          return 0;
  
      return m_context-&gt;isFramebuffer(framebuffer-&gt;object());
  }
  
<span class="udiff-line-modified-removed">- GC3Dboolean WebGLRenderingContextBase::isProgram(WebGLProgram* program)</span>
<span class="udiff-line-modified-added">+ GCGLboolean WebGLRenderingContextBase::isProgram(WebGLProgram* program)</span>
  {
      if (!program || isContextLostOrPending())
          return 0;
  
      return m_context-&gt;isProgram(program-&gt;object());
  }
  
<span class="udiff-line-modified-removed">- GC3Dboolean WebGLRenderingContextBase::isRenderbuffer(WebGLRenderbuffer* renderbuffer)</span>
<span class="udiff-line-modified-added">+ GCGLboolean WebGLRenderingContextBase::isRenderbuffer(WebGLRenderbuffer* renderbuffer)</span>
  {
      if (!renderbuffer || isContextLostOrPending())
          return 0;
  
      if (!renderbuffer-&gt;hasEverBeenBound())
          return 0;
  
      return m_context-&gt;isRenderbuffer(renderbuffer-&gt;object());
  }
  
<span class="udiff-line-modified-removed">- GC3Dboolean WebGLRenderingContextBase::isShader(WebGLShader* shader)</span>
<span class="udiff-line-modified-added">+ GCGLboolean WebGLRenderingContextBase::isShader(WebGLShader* shader)</span>
  {
      if (!shader || isContextLostOrPending())
          return 0;
  
      return m_context-&gt;isShader(shader-&gt;object());
  }
  
<span class="udiff-line-modified-removed">- GC3Dboolean WebGLRenderingContextBase::isTexture(WebGLTexture* texture)</span>
<span class="udiff-line-modified-added">+ GCGLboolean WebGLRenderingContextBase::isTexture(WebGLTexture* texture)</span>
  {
      if (!texture || isContextLostOrPending())
          return 0;
  
      if (!texture-&gt;hasEverBeenBound())
          return 0;
  
      return m_context-&gt;isTexture(texture-&gt;object());
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::lineWidth(GC3Dfloat width)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::lineWidth(GCGLfloat width)</span>
  {
      if (isContextLostOrPending())
          return;
      m_context-&gt;lineWidth(width);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3193,12 +3229,12 @@</span>
  bool WebGLRenderingContextBase::linkProgramWithoutInvalidatingAttribLocations(WebGLProgram* program)
  {
      if (isContextLostOrPending() || !validateWebGLObject(&quot;linkProgram&quot;, program))
          return false;
  
<span class="udiff-line-modified-removed">-     RefPtr&lt;WebGLShader&gt; vertexShader = program-&gt;getAttachedShader(GraphicsContext3D::VERTEX_SHADER);</span>
<span class="udiff-line-modified-removed">-     RefPtr&lt;WebGLShader&gt; fragmentShader = program-&gt;getAttachedShader(GraphicsContext3D::FRAGMENT_SHADER);</span>
<span class="udiff-line-modified-added">+     RefPtr&lt;WebGLShader&gt; vertexShader = program-&gt;getAttachedShader(GraphicsContextGL::VERTEX_SHADER);</span>
<span class="udiff-line-modified-added">+     RefPtr&lt;WebGLShader&gt; fragmentShader = program-&gt;getAttachedShader(GraphicsContextGL::FRAGMENT_SHADER);</span>
      if (!vertexShader || !vertexShader-&gt;isValid() || !fragmentShader || !fragmentShader-&gt;isValid()) {
          program-&gt;setLinkStatus(false);
          return false;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3212,49 +3248,49 @@</span>
  
      m_context-&gt;linkProgram(objectOrZero(program));
      return true;
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::pixelStorei(GC3Denum pname, GC3Dint param)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::pixelStorei(GCGLenum pname, GCGLint param)</span>
  {
      if (isContextLostOrPending())
          return;
      switch (pname) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNPACK_FLIP_Y_WEBGL:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNPACK_FLIP_Y_WEBGL:</span>
          m_unpackFlipY = param;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNPACK_PREMULTIPLY_ALPHA_WEBGL:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNPACK_PREMULTIPLY_ALPHA_WEBGL:</span>
          m_unpackPremultiplyAlpha = param;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNPACK_COLORSPACE_CONVERSION_WEBGL:</span>
<span class="udiff-line-modified-removed">-         if (param == GraphicsContext3D::BROWSER_DEFAULT_WEBGL || param == GraphicsContext3D::NONE)</span>
<span class="udiff-line-modified-removed">-             m_unpackColorspaceConversion = static_cast&lt;GC3Denum&gt;(param);</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNPACK_COLORSPACE_CONVERSION_WEBGL:</span>
<span class="udiff-line-modified-added">+         if (param == GraphicsContextGL::BROWSER_DEFAULT_WEBGL || param == GraphicsContextGL::NONE)</span>
<span class="udiff-line-modified-added">+             m_unpackColorspaceConversion = static_cast&lt;GCGLenum&gt;(param);</span>
          else {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;pixelStorei&quot;, &quot;invalid parameter for UNPACK_COLORSPACE_CONVERSION_WEBGL&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;pixelStorei&quot;, &quot;invalid parameter for UNPACK_COLORSPACE_CONVERSION_WEBGL&quot;);</span>
              return;
          }
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::PACK_ALIGNMENT:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNPACK_ALIGNMENT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::PACK_ALIGNMENT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNPACK_ALIGNMENT:</span>
          if (param == 1 || param == 2 || param == 4 || param == 8) {
<span class="udiff-line-modified-removed">-             if (pname == GraphicsContext3D::PACK_ALIGNMENT)</span>
<span class="udiff-line-modified-added">+             if (pname == GraphicsContextGL::PACK_ALIGNMENT)</span>
                  m_packAlignment = param;
<span class="udiff-line-modified-removed">-             else // GraphicsContext3D::UNPACK_ALIGNMENT:</span>
<span class="udiff-line-modified-added">+             else // GraphicsContextGL::UNPACK_ALIGNMENT:</span>
                  m_unpackAlignment = param;
              m_context-&gt;pixelStorei(pname, param);
          } else {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;pixelStorei&quot;, &quot;invalid parameter for alignment&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;pixelStorei&quot;, &quot;invalid parameter for alignment&quot;);</span>
              return;
          }
          break;
      default:
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;pixelStorei&quot;, &quot;invalid parameter name&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;pixelStorei&quot;, &quot;invalid parameter name&quot;);</span>
          return;
      }
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::polygonOffset(GC3Dfloat factor, GC3Dfloat units)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::polygonOffset(GCGLfloat factor, GCGLfloat units)</span>
  {
      if (isContextLostOrPending())
          return;
      m_context-&gt;polygonOffset(factor, units);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3267,282 +3303,282 @@</span>
      FloatingPoint,
      SignedInteger,
      UnsignedInteger
  };
  
<span class="udiff-line-modified-removed">- static InternalFormatTheme internalFormatTheme(GC3Denum internalFormat)</span>
<span class="udiff-line-modified-added">+ static InternalFormatTheme internalFormatTheme(GCGLenum internalFormat)</span>
  {
      switch (internalFormat) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::LUMINANCE_ALPHA:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::LUMINANCE:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::ALPHA:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::R8:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RG8:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB8:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::SRGB8:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA8:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::SRGB8_ALPHA8:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::SRGB_ALPHA:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::LUMINANCE_ALPHA:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::LUMINANCE:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::ALPHA:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::R8:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RG8:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB8:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::SRGB8:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA8:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::SRGB8_ALPHA8:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::SRGB_ALPHA:</span>
          return InternalFormatTheme::NormalizedFixedPoint;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB565:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB5_A1:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA4:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB9_E5:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB10_A2:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::R11F_G11F_B10F:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB10_A2UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB565:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB5_A1:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA4:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB9_E5:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB10_A2:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::R11F_G11F_B10F:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB10_A2UI:</span>
          return InternalFormatTheme::Packed;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::R8_SNORM:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RG8_SNORM:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB8_SNORM:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA8_SNORM:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::R8_SNORM:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RG8_SNORM:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB8_SNORM:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA8_SNORM:</span>
          return InternalFormatTheme::SignedNormalizedFixedPoint;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::R16F:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::R32F:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RG16F:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RG32F:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB16F:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB32F:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA16F:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA32F:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::R16F:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::R32F:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RG16F:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RG32F:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB16F:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB32F:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA16F:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA32F:</span>
          return InternalFormatTheme::FloatingPoint;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::R8I:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::R16I:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::R32I:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RG8I:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RG16I:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RG32I:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB8I:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB16I:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB32I:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA8I:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA16I:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA32I:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::R8I:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::R16I:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::R32I:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RG8I:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RG16I:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RG32I:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB8I:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB16I:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB32I:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA8I:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA16I:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA32I:</span>
          return InternalFormatTheme::SignedInteger;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::R8UI:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::R16UI:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::R32UI:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RG8UI:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RG16UI:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RG32UI:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB8UI:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB16UI:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB32UI:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA8UI:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA16UI:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA32UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::R8UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::R16UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::R32UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RG8UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RG16UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RG32UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB8UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB16UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB32UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA8UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA16UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA32UI:</span>
          return InternalFormatTheme::UnsignedInteger;
      default:
          return InternalFormatTheme::None;
      }
  }
  
<span class="udiff-line-modified-removed">- static int numberOfComponentsForFormat(GC3Denum format)</span>
<span class="udiff-line-modified-added">+ static int numberOfComponentsForFormat(GCGLenum format)</span>
  {
      switch (format) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RED:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RED_INTEGER:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RED:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RED_INTEGER:</span>
          return 1;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RG:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RG_INTEGER:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RG:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RG_INTEGER:</span>
          return 2;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB_INTEGER:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB_INTEGER:</span>
          return 3;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA_INTEGER:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA_INTEGER:</span>
          return 4;
      default:
          return 0;
      }
  }
  
<span class="udiff-line-modified-removed">- static int numberOfComponentsForInternalFormat(GC3Denum internalFormat)</span>
<span class="udiff-line-modified-added">+ static int numberOfComponentsForInternalFormat(GCGLenum internalFormat)</span>
  {
      switch (internalFormat) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::LUMINANCE:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::ALPHA:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::R8:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::R8_SNORM:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::R16F:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::R32F:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::R8UI:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::R8I:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::R16UI:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::R16I:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::R32UI:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::R32I:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::DEPTH_COMPONENT16:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::DEPTH_COMPONENT24:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::DEPTH_COMPONENT32F:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::LUMINANCE:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::ALPHA:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::R8:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::R8_SNORM:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::R16F:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::R32F:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::R8UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::R8I:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::R16UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::R16I:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::R32UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::R32I:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::DEPTH_COMPONENT16:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::DEPTH_COMPONENT24:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::DEPTH_COMPONENT32F:</span>
          return 1;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RG8:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::LUMINANCE_ALPHA:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RG8_SNORM:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RG16F:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RG32F:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RG8UI:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RG8I:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RG16UI:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RG16I:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RG32UI:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RG32I:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::DEPTH24_STENCIL8:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::DEPTH32F_STENCIL8:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RG8:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::LUMINANCE_ALPHA:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RG8_SNORM:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RG16F:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RG32F:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RG8UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RG8I:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RG16UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RG16I:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RG32UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RG32I:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::DEPTH24_STENCIL8:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::DEPTH32F_STENCIL8:</span>
          return 2;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB8:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::SRGB8:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB565:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB8_SNORM:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::R11F_G11F_B10F:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB9_E5:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB16F:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB32F:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB8UI:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB8I:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB16UI:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB16I:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB32UI:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB32I:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB8:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::SRGB8:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB565:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB8_SNORM:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::R11F_G11F_B10F:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB9_E5:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB16F:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB32F:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB8UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB8I:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB16UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB16I:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB32UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB32I:</span>
          return 3;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA8:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::SRGB_ALPHA:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::SRGB8_ALPHA8:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA8_SNORM:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB5_A1:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA4:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB10_A2:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA16F:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA32F:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA8UI:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA8I:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB10_A2UI:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA16UI:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA16I:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA32UI:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA32I:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA8:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::SRGB_ALPHA:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::SRGB8_ALPHA8:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA8_SNORM:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB5_A1:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA4:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB10_A2:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA16F:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA32F:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA8UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA8I:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB10_A2UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA16UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA16I:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA32UI:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA32I:</span>
          return 4;
      default:
          return 0;
      }
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::readPixels(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, ArrayBufferView&amp; pixels)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::readPixels(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, ArrayBufferView&amp; pixels)</span>
  {
      if (isContextLostOrPending())
          return;
      // Due to WebGL&#39;s same-origin restrictions, it is not possible to
      // taint the origin using the WebGL API.
      ASSERT(canvasBase().originClean());
  
<span class="udiff-line-modified-removed">-     GC3Denum internalFormat = 0;</span>
<span class="udiff-line-modified-added">+     GCGLenum internalFormat = 0;</span>
      if (m_framebufferBinding) {
          const char* reason = &quot;framebuffer incomplete&quot;;
<span class="udiff-line-modified-removed">-         if (!m_framebufferBinding-&gt;onAccess(graphicsContext3D(), &amp;reason)) {</span>
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, &quot;readPixels&quot;, reason);</span>
<span class="udiff-line-modified-added">+         if (!m_framebufferBinding-&gt;onAccess(graphicsContextGL(), &amp;reason)) {</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, &quot;readPixels&quot;, reason);</span>
              return;
          }
          // FIXME: readBuffer() should affect this
          internalFormat = m_framebufferBinding-&gt;getColorBufferFormat();
      } else {
          if (m_attributes.alpha)
<span class="udiff-line-modified-removed">-             internalFormat = GraphicsContext3D::RGBA8;</span>
<span class="udiff-line-modified-added">+             internalFormat = GraphicsContextGL::RGBA8;</span>
          else
<span class="udiff-line-modified-removed">-             internalFormat = GraphicsContext3D::RGB8;</span>
<span class="udiff-line-modified-added">+             internalFormat = GraphicsContextGL::RGB8;</span>
      }
  
      if (!internalFormat) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Incorrect internal format&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;readPixels&quot;, &quot;Missing attachment&quot;);</span>
          return;
      }
  
      if (isWebGL1()) {
          switch (format) {
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::ALPHA:</span>
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::RGB:</span>
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::RGBA:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::ALPHA:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::RGB:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::RGBA:</span>
              break;
          default:
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid format&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid format&quot;);</span>
              return;
          }
          switch (type) {
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::UNSIGNED_BYTE:</span>
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::UNSIGNED_SHORT_5_6_5:</span>
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4:</span>
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::UNSIGNED_BYTE:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::UNSIGNED_SHORT_5_6_5:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1:</span>
              break;
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::FLOAT:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::FLOAT:</span>
              if (!m_oesTextureFloat &amp;&amp; !m_oesTextureHalfFloat) {
<span class="udiff-line-modified-removed">-                 synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid type&quot;);</span>
<span class="udiff-line-modified-added">+                 synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid type&quot;);</span>
                  return;
              }
              break;
          default:
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid type&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;invalid type&quot;);</span>
              return;
          }
<span class="udiff-line-modified-removed">-         if (format != GraphicsContext3D::RGBA || (type != GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; type != GraphicsContext3D::FLOAT)) {</span>
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;readPixels&quot;, &quot;format not RGBA or type not UNSIGNED_BYTE|FLOAT&quot;);</span>
<span class="udiff-line-modified-added">+         if (format != GraphicsContextGL::RGBA || (type != GraphicsContextGL::UNSIGNED_BYTE &amp;&amp; type != GraphicsContextGL::FLOAT)) {</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;readPixels&quot;, &quot;format not RGBA or type not UNSIGNED_BYTE|FLOAT&quot;);</span>
              return;
          }
      }
  
      InternalFormatTheme internalFormatTheme = WebCore::internalFormatTheme(internalFormat);
      int internalFormatComponentCount = numberOfComponentsForInternalFormat(internalFormat);
      if (internalFormatTheme == InternalFormatTheme::None || !internalFormatComponentCount) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Incorrect internal format&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;Incorrect internal format&quot;);</span>
          return;
      }
  
  #define CHECK_COMPONENT_COUNT \
      if (numberOfComponentsForFormat(format) &lt; internalFormatComponentCount) { \
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Not enough components in format&quot;); \</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;Not enough components in format&quot;); \</span>
          return; \
      }
  
  #define INTERNAL_FORMAT_CHECK(typeMacro, pixelTypeMacro) \
<span class="udiff-line-modified-removed">-     if (type != GraphicsContext3D::typeMacro || pixels.getType() != JSC::pixelTypeMacro) { \</span>
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
<span class="udiff-line-modified-added">+     if (type != GraphicsContextGLOpenGL::typeMacro || pixels.getType() != JSC::pixelTypeMacro) { \</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
          return; \
      } \
<span class="udiff-line-modified-removed">-     if (format != GraphicsContext3D::RED &amp;&amp; format != GraphicsContext3D::RG &amp;&amp; format != GraphicsContext3D::RGB &amp;&amp; format != GraphicsContext3D::RGBA) { \</span>
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Unknown format&quot;); \</span>
<span class="udiff-line-modified-added">+     if (format != GraphicsContextGL::RED &amp;&amp; format != GraphicsContextGL::RG &amp;&amp; format != GraphicsContextGL::RGB &amp;&amp; format != GraphicsContextGL::RGBA) { \</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;Unknown format&quot;); \</span>
          return; \
      } \
      CHECK_COMPONENT_COUNT
  
  #define INTERNAL_FORMAT_INTEGER_CHECK(typeMacro, pixelTypeMacro) \
<span class="udiff-line-modified-removed">-     if (type != GraphicsContext3D::typeMacro || pixels.getType() != JSC::pixelTypeMacro) { \</span>
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
<span class="udiff-line-modified-added">+     if (type != GraphicsContextGLOpenGL::typeMacro || pixels.getType() != JSC::pixelTypeMacro) { \</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
          return; \
      } \
<span class="udiff-line-modified-removed">-     if (format != GraphicsContext3D::RED_INTEGER &amp;&amp; format != GraphicsContext3D::RG_INTEGER &amp;&amp; format != GraphicsContext3D::RGB_INTEGER &amp;&amp; format != GraphicsContext3D::RGBA_INTEGER) { \</span>
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Unknown format&quot;); \</span>
<span class="udiff-line-modified-added">+     if (format != GraphicsContextGL::RED_INTEGER &amp;&amp; format != GraphicsContextGL::RG_INTEGER &amp;&amp; format != GraphicsContextGL::RGB_INTEGER &amp;&amp; format != GraphicsContextGL::RGBA_INTEGER) { \</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;Unknown format&quot;); \</span>
          return; \
      } \
      CHECK_COMPONENT_COUNT
  
<span class="udiff-line-modified-removed">- #define CASE_PACKED_INTERNAL_FORMAT_CHECK(internalFormatMacro, formatMacro, type0Macro, pixelType0Macro, type1Macro, pixelType1Macro) case GraphicsContext3D::internalFormatMacro: \</span>
<span class="udiff-line-modified-removed">-     if (!(type == GraphicsContext3D::type0Macro &amp;&amp; pixels.getType() == JSC::pixelType0Macro) \</span>
<span class="udiff-line-modified-removed">-         &amp;&amp; !(type == GraphicsContext3D::type1Macro &amp;&amp; pixels.getType() == JSC::pixelType1Macro)) { \</span>
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
<span class="udiff-line-modified-added">+ #define CASE_PACKED_INTERNAL_FORMAT_CHECK(internalFormatMacro, formatMacro, type0Macro, pixelType0Macro, type1Macro, pixelType1Macro) case GraphicsContextGLOpenGL::internalFormatMacro: \</span>
<span class="udiff-line-modified-added">+     if (!(type == GraphicsContextGLOpenGL::type0Macro &amp;&amp; pixels.getType() == JSC::pixelType0Macro) \</span>
<span class="udiff-line-modified-added">+         &amp;&amp; !(type == GraphicsContextGLOpenGL::type1Macro &amp;&amp; pixels.getType() == JSC::pixelType1Macro)) { \</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;type does not match internal format&quot;); \</span>
          return; \
      } \
<span class="udiff-line-modified-removed">-     if (format != GraphicsContext3D::formatMacro) { \</span>
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;readPixels&quot;, &quot;Invalid format&quot;); \</span>
<span class="udiff-line-modified-added">+     if (format != GraphicsContextGLOpenGL::formatMacro) { \</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;readPixels&quot;, &quot;Invalid format&quot;); \</span>
          return; \
      } \
      break;
  
      switch (internalFormatTheme) {
      case InternalFormatTheme::NormalizedFixedPoint:
<span class="udiff-line-modified-removed">-         if (type == GraphicsContext3D::FLOAT) {</span>
<span class="udiff-line-modified-added">+         if (type == GraphicsContextGL::FLOAT) {</span>
              INTERNAL_FORMAT_CHECK(FLOAT, TypeFloat32);
          } else {
              INTERNAL_FORMAT_CHECK(UNSIGNED_BYTE, TypeUint8);
          }
          break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3579,17 +3615,17 @@</span>
  
      // Calculate array size, taking into consideration of PACK_ALIGNMENT.
      unsigned totalBytesRequired = 0;
      unsigned padding = 0;
      if (!m_isRobustnessEXTSupported) {
<span class="udiff-line-modified-removed">-         GC3Denum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_packAlignment, &amp;totalBytesRequired, &amp;padding);</span>
<span class="udiff-line-modified-removed">-         if (error != GraphicsContext3D::NO_ERROR) {</span>
<span class="udiff-line-modified-added">+         GCGLenum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_packAlignment, &amp;totalBytesRequired, &amp;padding);</span>
<span class="udiff-line-modified-added">+         if (error != GraphicsContextGL::NO_ERROR) {</span>
              synthesizeGLError(error, &quot;readPixels&quot;, &quot;invalid dimensions&quot;);
              return;
          }
          if (pixels.byteLength() &lt; totalBytesRequired) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;readPixels&quot;, &quot;ArrayBufferView not large enough for dimensions&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;readPixels&quot;, &quot;ArrayBufferView not large enough for dimensions&quot;);</span>
              return;
          }
      }
  
      clearIfComposited();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3606,18 +3642,18 @@</span>
      if (isContextLostOrPending())
          return;
      m_context-&gt;releaseShaderCompiler();
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::sampleCoverage(GC3Dfloat value, GC3Dboolean invert)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::sampleCoverage(GCGLfloat value, GCGLboolean invert)</span>
  {
      if (isContextLostOrPending())
          return;
      m_context-&gt;sampleCoverage(value, invert);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::scissor(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::scissor(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)</span>
  {
      if (isContextLostOrPending())
          return;
      if (!validateSize(&quot;scissor&quot;, width, height))
          return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3626,18 +3662,22 @@</span>
  
  void WebGLRenderingContextBase::shaderSource(WebGLShader* shader, const String&amp; string)
  {
      if (isContextLostOrPending() || !validateWebGLObject(&quot;shaderSource&quot;, shader))
          return;
<span class="udiff-line-added">+ #if USE(ANGLE)</span>
<span class="udiff-line-added">+     m_context-&gt;shaderSource(objectOrZero(shader), string);</span>
<span class="udiff-line-added">+ #else</span>
      String stringWithoutComments = StripComments(string).result();
      if (!validateString(&quot;shaderSource&quot;, stringWithoutComments))
          return;
<span class="udiff-line-removed">-     shader-&gt;setSource(string);</span>
      m_context-&gt;shaderSource(objectOrZero(shader), stringWithoutComments);
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     shader-&gt;setSource(string);</span>
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::stencilFunc(GC3Denum func, GC3Dint ref, GC3Duint mask)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::stencilFunc(GCGLenum func, GCGLint ref, GCGLuint mask)</span>
  {
      if (isContextLostOrPending())
          return;
      if (!validateStencilFunc(&quot;stencilFunc&quot;, func))
          return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3646,84 +3686,84 @@</span>
      m_stencilFuncMask = mask;
      m_stencilFuncMaskBack = mask;
      m_context-&gt;stencilFunc(func, ref, mask);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::stencilFuncSeparate(GC3Denum face, GC3Denum func, GC3Dint ref, GC3Duint mask)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::stencilFuncSeparate(GCGLenum face, GCGLenum func, GCGLint ref, GCGLuint mask)</span>
  {
      if (isContextLostOrPending())
          return;
      if (!validateStencilFunc(&quot;stencilFuncSeparate&quot;, func))
          return;
      switch (face) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::FRONT_AND_BACK:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::FRONT_AND_BACK:</span>
          m_stencilFuncRef = ref;
          m_stencilFuncRefBack = ref;
          m_stencilFuncMask = mask;
          m_stencilFuncMaskBack = mask;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::FRONT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::FRONT:</span>
          m_stencilFuncRef = ref;
          m_stencilFuncMask = mask;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::BACK:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::BACK:</span>
          m_stencilFuncRefBack = ref;
          m_stencilFuncMaskBack = mask;
          break;
      default:
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;stencilFuncSeparate&quot;, &quot;invalid face&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;stencilFuncSeparate&quot;, &quot;invalid face&quot;);</span>
          return;
      }
      m_context-&gt;stencilFuncSeparate(face, func, ref, mask);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::stencilMask(GC3Duint mask)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::stencilMask(GCGLuint mask)</span>
  {
      if (isContextLostOrPending())
          return;
      m_stencilMask = mask;
      m_stencilMaskBack = mask;
      m_context-&gt;stencilMask(mask);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::stencilMaskSeparate(GC3Denum face, GC3Duint mask)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::stencilMaskSeparate(GCGLenum face, GCGLuint mask)</span>
  {
      if (isContextLostOrPending())
          return;
      switch (face) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::FRONT_AND_BACK:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::FRONT_AND_BACK:</span>
          m_stencilMask = mask;
          m_stencilMaskBack = mask;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::FRONT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::FRONT:</span>
          m_stencilMask = mask;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::BACK:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::BACK:</span>
          m_stencilMaskBack = mask;
          break;
      default:
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;stencilMaskSeparate&quot;, &quot;invalid face&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;stencilMaskSeparate&quot;, &quot;invalid face&quot;);</span>
          return;
      }
      m_context-&gt;stencilMaskSeparate(face, mask);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::stencilOp(GC3Denum fail, GC3Denum zfail, GC3Denum zpass)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::stencilOp(GCGLenum fail, GCGLenum zfail, GCGLenum zpass)</span>
  {
      if (isContextLostOrPending())
          return;
      m_context-&gt;stencilOp(fail, zfail, zpass);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::stencilOpSeparate(GC3Denum face, GC3Denum fail, GC3Denum zfail, GC3Denum zpass)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::stencilOpSeparate(GCGLenum face, GCGLenum fail, GCGLenum zfail, GCGLenum zpass)</span>
  {
      if (isContextLostOrPending())
          return;
      m_context-&gt;stencilOpSeparate(face, fail, zfail, zpass);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::texImage2DBase(GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, const void* pixels)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::texImage2DBase(GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, const void* pixels)</span>
  {
      // FIXME: For now we ignore any errors returned.
      auto tex = validateTextureBinding(&quot;texImage2D&quot;, target, true);
      ASSERT(validateTexFuncParameters(&quot;texImage2D&quot;, TexImage, target, level, internalFormat, width, height, border, format, type));
      ASSERT(tex);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3743,51 +3783,51 @@</span>
          }
      }
      tex-&gt;setLevelInfo(target, level, internalFormat, width, height, type);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::texImage2DImpl(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Denum format, GC3Denum type, Image* image, GraphicsContext3D::ImageHtmlDomSource domSource, bool flipY, bool premultiplyAlpha)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::texImage2DImpl(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLenum format, GCGLenum type, Image* image, GraphicsContextGL::DOMSource domSource, bool flipY, bool premultiplyAlpha)</span>
  {
      Vector&lt;uint8_t&gt; data;
<span class="udiff-line-modified-removed">-     GraphicsContext3D::ImageExtractor imageExtractor(image, domSource, premultiplyAlpha, m_unpackColorspaceConversion == GraphicsContext3D::NONE);</span>
<span class="udiff-line-modified-added">+     GraphicsContextGLOpenGL::ImageExtractor imageExtractor(image, domSource, premultiplyAlpha, m_unpackColorspaceConversion == GraphicsContextGL::NONE);</span>
      if (!imageExtractor.extractSucceeded()) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texImage2D&quot;, &quot;bad image data&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texImage2D&quot;, &quot;bad image data&quot;);</span>
          return;
      }
<span class="udiff-line-modified-removed">-     GraphicsContext3D::DataFormat sourceDataFormat = imageExtractor.imageSourceFormat();</span>
<span class="udiff-line-modified-removed">-     GraphicsContext3D::AlphaOp alphaOp = imageExtractor.imageAlphaOp();</span>
<span class="udiff-line-modified-added">+     GraphicsContextGL::DataFormat sourceDataFormat = imageExtractor.imageSourceFormat();</span>
<span class="udiff-line-modified-added">+     GraphicsContextGL::AlphaOp alphaOp = imageExtractor.imageAlphaOp();</span>
      const void* imagePixelData = imageExtractor.imagePixelData();
  
      bool needConversion = true;
<span class="udiff-line-modified-removed">-     if (type == GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; sourceDataFormat == GraphicsContext3D::DataFormatRGBA8 &amp;&amp; format == GraphicsContext3D::RGBA &amp;&amp; alphaOp == GraphicsContext3D::AlphaDoNothing &amp;&amp; !flipY)</span>
<span class="udiff-line-modified-added">+     if (type == GraphicsContextGL::UNSIGNED_BYTE &amp;&amp; sourceDataFormat == GraphicsContextGL::DataFormat::RGBA8 &amp;&amp; format == GraphicsContextGL::RGBA &amp;&amp; alphaOp == GraphicsContextGL::AlphaOp::DoNothing &amp;&amp; !flipY)</span>
          needConversion = false;
      else {
          if (!m_context-&gt;packImageData(image, imagePixelData, format, type, flipY, alphaOp, sourceDataFormat, imageExtractor.imageWidth(), imageExtractor.imageHeight(), imageExtractor.imageSourceUnpackAlignment(), data)) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texImage2D&quot;, &quot;packImage error&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texImage2D&quot;, &quot;packImage error&quot;);</span>
              return;
          }
      }
  
      if (m_unpackAlignment != 1)
<span class="udiff-line-modified-removed">-         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, 1);</span>
<span class="udiff-line-modified-added">+         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, 1);</span>
      texImage2DBase(target, level, internalformat, image-&gt;width(), image-&gt;height(), 0, format, type, needConversion ? data.data() : imagePixelData);
      if (m_unpackAlignment != 1)
<span class="udiff-line-modified-removed">-         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
<span class="udiff-line-modified-added">+         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateTexFunc(const char* functionName, TexFuncValidationFunctionType functionType, TexFuncValidationSourceType sourceType, GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, GC3Dint xoffset, GC3Dint yoffset)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateTexFunc(const char* functionName, TexFuncValidationFunctionType functionType, TexFuncValidationSourceType sourceType, GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, GCGLint xoffset, GCGLint yoffset)</span>
  {
      if (!validateTexFuncParameters(functionName, functionType, target, level, internalFormat, width, height, border, format, type))
          return false;
  
      auto texture = validateTextureBinding(functionName, target, true);
      if (!texture)
          return false;
  
      if (functionType != TexSubImage) {
          if (functionType == TexImage &amp;&amp; texture-&gt;immutable()) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;texStorage() called on this texture previously&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;texStorage() called on this texture previously&quot;);</span>
              return false;
          }
          if (!validateNPOTTextureLevel(width, height, level, functionName))
              return false;
          // For SourceArrayBufferView, function validateTexFuncData() would handle whether to validate the SettableTexFormat
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3801,27 +3841,27 @@</span>
              return false;
          if (!validateSize(functionName, xoffset, yoffset))
              return false;
          // Before checking if it is in the range, check if overflow happens first.
          if (xoffset + width &lt; 0 || yoffset + height &lt; 0) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;bad dimensions&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;bad dimensions&quot;);</span>
              return false;
          }
          if (xoffset + width &gt; texture-&gt;getWidth(target, level) || yoffset + height &gt; texture-&gt;getHeight(target, level)) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;dimensions out of range&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;dimensions out of range&quot;);</span>
              return false;
          }
          if (texture-&gt;getInternalFormat(target, level) != internalFormat || (isWebGL1() &amp;&amp; texture-&gt;getType(target, level) != type)) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;type and format do not match texture&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;type and format do not match texture&quot;);</span>
              return false;
          }
      }
  
      return true;
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::texImage2D(GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Dsizei width, GC3Dsizei height, GC3Dint border, GC3Denum format, GC3Denum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; pixels)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::texImage2D(GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; pixels)</span>
  {
      if (isContextLostOrPending() || !validateTexFuncData(&quot;texImage2D&quot;, level, width, height, internalFormat, format, type, pixels.get(), NullAllowed)
          || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceArrayBufferView, target, level, internalFormat, width, height, border, format, type, 0, 0))
          return;
      void* data = pixels ? pixels-&gt;baseAddress() : 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3836,59 +3876,59 @@</span>
              return;
          data = tempData.data();
          changeUnpackAlignment = true;
      }
      if (changeUnpackAlignment)
<span class="udiff-line-modified-removed">-         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, 1);</span>
<span class="udiff-line-modified-added">+         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, 1);</span>
      texImage2DBase(target, level, internalFormat, width, height, border, format, type, data);
      if (changeUnpackAlignment)
<span class="udiff-line-modified-removed">-         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
<span class="udiff-line-modified-added">+         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::texSubImage2DImpl(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Denum format, GC3Denum type, Image* image, GraphicsContext3D::ImageHtmlDomSource domSource, bool flipY, bool premultiplyAlpha)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::texSubImage2DImpl(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLenum format, GCGLenum type, Image* image, GraphicsContextGL::DOMSource domSource, bool flipY, bool premultiplyAlpha)</span>
  {
      Vector&lt;uint8_t&gt; data;
<span class="udiff-line-modified-removed">-     GraphicsContext3D::ImageExtractor imageExtractor(image, domSource, premultiplyAlpha, m_unpackColorspaceConversion == GraphicsContext3D::NONE);</span>
<span class="udiff-line-modified-added">+     GraphicsContextGLOpenGL::ImageExtractor imageExtractor(image, domSource, premultiplyAlpha, m_unpackColorspaceConversion == GraphicsContextGL::NONE);</span>
      if (!imageExtractor.extractSucceeded()) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;bad image&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;bad image&quot;);</span>
          return;
      }
<span class="udiff-line-modified-removed">-     GraphicsContext3D::DataFormat sourceDataFormat = imageExtractor.imageSourceFormat();</span>
<span class="udiff-line-modified-removed">-     GraphicsContext3D::AlphaOp alphaOp = imageExtractor.imageAlphaOp();</span>
<span class="udiff-line-modified-added">+     GraphicsContextGL::DataFormat sourceDataFormat = imageExtractor.imageSourceFormat();</span>
<span class="udiff-line-modified-added">+     GraphicsContextGL::AlphaOp alphaOp = imageExtractor.imageAlphaOp();</span>
      const void* imagePixelData = imageExtractor.imagePixelData();
  
      bool needConversion = true;
<span class="udiff-line-modified-removed">-     if (type == GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; sourceDataFormat == GraphicsContext3D::DataFormatRGBA8 &amp;&amp; format == GraphicsContext3D::RGBA &amp;&amp; alphaOp == GraphicsContext3D::AlphaDoNothing &amp;&amp; !flipY)</span>
<span class="udiff-line-modified-added">+     if (type == GraphicsContextGL::UNSIGNED_BYTE &amp;&amp; sourceDataFormat == GraphicsContextGL::DataFormat::RGBA8 &amp;&amp; format == GraphicsContextGL::RGBA &amp;&amp; alphaOp == GraphicsContextGL::AlphaOp::DoNothing &amp;&amp; !flipY)</span>
          needConversion = false;
      else {
          if (!m_context-&gt;packImageData(image, imagePixelData, format, type, flipY, alphaOp, sourceDataFormat, imageExtractor.imageWidth(), imageExtractor.imageHeight(), imageExtractor.imageSourceUnpackAlignment(), data)) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texImage2D&quot;, &quot;bad image data&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texImage2D&quot;, &quot;bad image data&quot;);</span>
              return;
          }
      }
  
      if (m_unpackAlignment != 1)
<span class="udiff-line-modified-removed">-         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, 1);</span>
<span class="udiff-line-modified-added">+         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, 1);</span>
  
      texSubImage2DBase(target, level, xoffset, yoffset, image-&gt;width(), image-&gt;height(), format, format, type, needConversion ? data.data() : imagePixelData);
  
      if (m_unpackAlignment != 1)
<span class="udiff-line-modified-removed">-         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
<span class="udiff-line-modified-added">+         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::texSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum format, GC3Denum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; pixels)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, RefPtr&lt;ArrayBufferView&gt;&amp;&amp; pixels)</span>
  {
      if (isContextLostOrPending())
          return;
  
      auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
      if (!texture)
          return;
  
<span class="udiff-line-modified-removed">-     GC3Denum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
<span class="udiff-line-modified-added">+     GCGLenum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
      if (!internalFormat) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
          return;
      }
  
      if (!validateTexFuncData(&quot;texSubImage2D&quot;, level, width, height, internalFormat, format, type, pixels.get(), NullNotAllowed))
          return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3904,22 +3944,22 @@</span>
              return;
          data = tempData.data();
          changeUnpackAlignment = true;
      }
      if (changeUnpackAlignment)
<span class="udiff-line-modified-removed">-         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, 1);</span>
<span class="udiff-line-modified-added">+         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, 1);</span>
  
      texSubImage2DBase(target, level, xoffset, yoffset, width, height, internalFormat, format, type, data);
  
      if (changeUnpackAlignment)
<span class="udiff-line-modified-removed">-         m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
<span class="udiff-line-modified-added">+         m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;void&gt; WebGLRenderingContextBase::texSubImage2D(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Denum format, GC3Denum type, Optional&lt;TexImageSource&gt;&amp;&amp; source)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;void&gt; WebGLRenderingContextBase::texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLenum format, GCGLenum type, Optional&lt;TexImageSource&gt;&amp;&amp; source)</span>
  {
      if (!source) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;source is null&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;source is null&quot;);</span>
          return { };
      }
  
      if (isContextLostOrPending())
          return { };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3927,60 +3967,60 @@</span>
      auto visitor = WTF::makeVisitor([&amp;](const RefPtr&lt;ImageBitmap&gt;&amp; bitmap) -&gt; ExceptionOr&lt;void&gt; {
          auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
          if (!texture)
              return { };
  
<span class="udiff-line-modified-removed">-         GC3Denum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
<span class="udiff-line-modified-added">+         GCGLenum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
          if (!internalFormat) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
              return { };
          }
  
          if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceImageBitmap, target, level, internalFormat, bitmap-&gt;width(), bitmap-&gt;height(), 0, format, type, xoffset, yoffset))
              return { };
  
          ImageBuffer* buffer = bitmap-&gt;buffer();
          if (!buffer)
              return { };
  
<span class="udiff-line-modified-removed">-         RefPtr&lt;Image&gt; image = buffer-&gt;copyImage(ImageBuffer::fastCopyImageMode());</span>
<span class="udiff-line-modified-added">+         RefPtr&lt;Image&gt; image = buffer-&gt;copyImage(DontCopyBackingStore);</span>
          if (image)
<span class="udiff-line-modified-removed">-             texSubImage2DImpl(target, level, xoffset, yoffset, format, type, image.get(), GraphicsContext3D::HtmlDomImage, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
<span class="udiff-line-modified-added">+             texSubImage2DImpl(target, level, xoffset, yoffset, format, type, image.get(), GraphicsContextGL::DOMSource::Image, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
          return { };
      }, [&amp;](const RefPtr&lt;ImageData&gt;&amp; pixels) -&gt; ExceptionOr&lt;void&gt; {
          auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
          if (!texture)
              return { };
  
<span class="udiff-line-modified-removed">-         GC3Denum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
<span class="udiff-line-modified-added">+         GCGLenum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
          if (!internalFormat) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
              return { };
          }
  
          if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceImageData, target, level, internalFormat, pixels-&gt;width(), pixels-&gt;height(), 0, format, type, xoffset, yoffset))
              return { };
  
          Vector&lt;uint8_t&gt; data;
          bool needConversion = true;
          // The data from ImageData is always of format RGBA8.
          // No conversion is needed if destination format is RGBA and type is USIGNED_BYTE and no Flip or Premultiply operation is required.
<span class="udiff-line-modified-removed">-         if (format == GraphicsContext3D::RGBA &amp;&amp; type == GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; !m_unpackFlipY &amp;&amp; !m_unpackPremultiplyAlpha)</span>
<span class="udiff-line-modified-added">+         if (format == GraphicsContextGL::RGBA &amp;&amp; type == GraphicsContextGL::UNSIGNED_BYTE &amp;&amp; !m_unpackFlipY &amp;&amp; !m_unpackPremultiplyAlpha)</span>
              needConversion = false;
          else {
              if (!m_context-&gt;extractImageData(pixels.get(), format, type, m_unpackFlipY, m_unpackPremultiplyAlpha, data)) {
<span class="udiff-line-modified-removed">-                 synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;bad image data&quot;);</span>
<span class="udiff-line-modified-added">+                 synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;bad image data&quot;);</span>
                  return { };
              }
          }
          if (m_unpackAlignment != 1)
<span class="udiff-line-modified-removed">-             m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, 1);</span>
<span class="udiff-line-modified-added">+             m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, 1);</span>
  
          texSubImage2DBase(target, level, xoffset, yoffset, pixels-&gt;width(), pixels-&gt;height(), format, format, type, needConversion ? data.data() : pixels-&gt;data()-&gt;data());
  
          if (m_unpackAlignment != 1)
<span class="udiff-line-modified-removed">-             m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
<span class="udiff-line-modified-added">+             m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
  
          return { };
      } , [&amp;](const RefPtr&lt;HTMLImageElement&gt;&amp; image) -&gt; ExceptionOr&lt;void&gt; {
          if (isContextLostOrPending())
              return { };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3992,27 +4032,27 @@</span>
  
          RefPtr&lt;Image&gt; imageForRender = image-&gt;cachedImage()-&gt;imageForRenderer(image-&gt;renderer());
          if (!imageForRender)
              return { };
  
<span class="udiff-line-modified-removed">-         if (imageForRender-&gt;isSVGImage())</span>
<span class="udiff-line-modified-added">+         if (imageForRender-&gt;isSVGImage() || imageForRender-&gt;orientation() != ImageOrientation::None)</span>
              imageForRender = drawImageIntoBuffer(*imageForRender, image-&gt;width(), image-&gt;height(), 1);
  
          auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
          if (!texture)
              return { };
  
<span class="udiff-line-modified-removed">-         GC3Denum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
<span class="udiff-line-modified-added">+         GCGLenum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
          if (!internalFormat) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
              return { };
          }
  
          if (!imageForRender || !validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceHTMLImageElement, target, level, internalFormat, imageForRender-&gt;width(), imageForRender-&gt;height(), 0, format, type, xoffset, yoffset))
              return { };
  
<span class="udiff-line-modified-removed">-         texSubImage2DImpl(target, level, xoffset, yoffset, format, type, imageForRender.get(), GraphicsContext3D::HtmlDomImage, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
<span class="udiff-line-modified-added">+         texSubImage2DImpl(target, level, xoffset, yoffset, format, type, imageForRender.get(), GraphicsContextGL::DOMSource::Image, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
          return { };
      }, [&amp;](const RefPtr&lt;HTMLCanvasElement&gt;&amp; canvas) -&gt; ExceptionOr&lt;void&gt; {
          if (isContextLostOrPending())
              return { };
          auto validationResult = validateHTMLCanvasElement(&quot;texSubImage2D&quot;, canvas.get());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4023,24 +4063,24 @@</span>
  
          auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
          if (!texture)
              return { };
  
<span class="udiff-line-modified-removed">-         GC3Denum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
<span class="udiff-line-modified-added">+         GCGLenum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
          if (!internalFormat) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
              return { };
          }
  
          if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceHTMLCanvasElement, target, level, internalFormat, canvas-&gt;width(), canvas-&gt;height(), 0, format, type, xoffset, yoffset))
              return { };
  
          RefPtr&lt;ImageData&gt; imageData = canvas-&gt;getImageData();
          if (imageData)
              texSubImage2D(target, level, xoffset, yoffset, format, type, TexImageSource(imageData.get()));
          else
<span class="udiff-line-modified-removed">-             texSubImage2DImpl(target, level, xoffset, yoffset, format, type, canvas-&gt;copiedImage(), GraphicsContext3D::HtmlDomCanvas, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
<span class="udiff-line-modified-added">+             texSubImage2DImpl(target, level, xoffset, yoffset, format, type, canvas-&gt;copiedImage(), GraphicsContextGL::DOMSource::Canvas, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
          return { };
      }
  #if ENABLE(VIDEO)
      , [&amp;](const RefPtr&lt;HTMLVideoElement&gt;&amp; video) -&gt; ExceptionOr&lt;void&gt; {
          if (isContextLostOrPending())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4053,85 +4093,79 @@</span>
  
          auto texture = validateTextureBinding(&quot;texSubImage2D&quot;, target, true);
          if (!texture)
              return { };
  
<span class="udiff-line-modified-removed">-         GC3Denum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
<span class="udiff-line-modified-added">+         GCGLenum internalFormat = texture-&gt;getInternalFormat(target, level);</span>
          if (!internalFormat) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texSubImage2D&quot;, &quot;invalid texture target or level&quot;);</span>
              return { };
          }
  
          if (!validateTexFunc(&quot;texSubImage2D&quot;, TexSubImage, SourceHTMLVideoElement, target, level, internalFormat, video-&gt;videoWidth(), video-&gt;videoHeight(), 0, format, type, xoffset, yoffset))
              return { };
  
<span class="udiff-line-modified-removed">-         RefPtr&lt;Image&gt; image = videoFrameToImage(video.get(), ImageBuffer::fastCopyImageMode());</span>
<span class="udiff-line-modified-added">+         RefPtr&lt;Image&gt; image = videoFrameToImage(video.get(), DontCopyBackingStore);</span>
          if (!image)
              return { };
<span class="udiff-line-modified-removed">-         texSubImage2DImpl(target, level, xoffset, yoffset, format, type, image.get(), GraphicsContext3D::HtmlDomVideo, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
<span class="udiff-line-modified-added">+         texSubImage2DImpl(target, level, xoffset, yoffset, format, type, image.get(), GraphicsContextGL::DOMSource::Video, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
          return { };
      }
  #endif
      );
  
      return WTF::visit(visitor, source.value());
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateArrayBufferType(const char* functionName, GC3Denum type, Optional&lt;JSC::TypedArrayType&gt; arrayType)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateArrayBufferType(const char* functionName, GCGLenum type, Optional&lt;JSC::TypedArrayType&gt; arrayType)</span>
  {
  #define TYPE_VALIDATION_CASE(arrayTypeMacro) if (arrayType &amp;&amp; arrayType.value() != JSC::arrayTypeMacro) { \
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;ArrayBufferView not &quot; #arrayTypeMacro); \</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;ArrayBufferView not &quot; #arrayTypeMacro); \</span>
              return false; \
          } \
          break;
  
      switch (type) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_BYTE:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_BYTE:</span>
          TYPE_VALIDATION_CASE(TypeUint8);
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::BYTE:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::BYTE:</span>
          TYPE_VALIDATION_CASE(TypeInt8);
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_SHORT:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_SHORT_5_6_5:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_SHORT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_SHORT_5_6_5:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1:</span>
          TYPE_VALIDATION_CASE(TypeUint16);
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::SHORT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::SHORT:</span>
          TYPE_VALIDATION_CASE(TypeInt16);
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_INT_2_10_10_10_REV:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_INT_10F_11F_11F_REV:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_INT_5_9_9_9_REV:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_INT_24_8:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_INT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_INT_10F_11F_11F_REV:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_INT_5_9_9_9_REV:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_INT_24_8:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_INT:</span>
          TYPE_VALIDATION_CASE(TypeUint32);
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::INT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::INT:</span>
          TYPE_VALIDATION_CASE(TypeInt32);
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::FLOAT: // OES_texture_float</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::FLOAT: // OES_texture_float</span>
          TYPE_VALIDATION_CASE(TypeFloat32);
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::HALF_FLOAT_OES: // OES_texture_half_float</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::HALF_FLOAT:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::FLOAT_32_UNSIGNED_INT_24_8_REV:</span>
<span class="udiff-line-modified-removed">-         // As per the specification, ArrayBufferView should be null when</span>
<span class="udiff-line-removed">-         // OES_texture_half_float is enabled.</span>
<span class="udiff-line-removed">-         if (arrayType) {</span>
<span class="udiff-line-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;type HALF_FLOAT_OES but ArrayBufferView is not NULL&quot;);</span>
<span class="udiff-line-removed">-             return false;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::HALF_FLOAT_OES: // OES_texture_half_float</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::HALF_FLOAT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::FLOAT_32_UNSIGNED_INT_24_8_REV:</span>
<span class="udiff-line-modified-added">+         TYPE_VALIDATION_CASE(TypeUint16);</span>
      default:
          ASSERT_NOT_REACHED();
          return false;
      }
  #undef TYPE_VALIDATION_CASE
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateTexFuncData(const char* functionName, GC3Dint level, GC3Dsizei width, GC3Dsizei height, GC3Denum internalFormat, GC3Denum format, GC3Denum type, ArrayBufferView* pixels, NullDisposition disposition)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateTexFuncData(const char* functionName, GCGLint level, GCGLsizei width, GCGLsizei height, GCGLenum internalFormat, GCGLenum format, GCGLenum type, ArrayBufferView* pixels, NullDisposition disposition)</span>
  {
      if (!pixels) {
          if (disposition == NullAllowed)
              return true;
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no pixels&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no pixels&quot;);</span>
          return false;
      }
  
      if (!validateTexFuncFormatAndType(functionName, internalFormat, format, type, level))
          return false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4139,284 +4173,284 @@</span>
          return false;
      if (!validateArrayBufferType(functionName, type, pixels ? Optional&lt;JSC::TypedArrayType&gt;(pixels-&gt;getType()) : WTF::nullopt))
          return false;
  
      unsigned totalBytesRequired;
<span class="udiff-line-modified-removed">-     GC3Denum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_unpackAlignment, &amp;totalBytesRequired, nullptr);</span>
<span class="udiff-line-modified-removed">-     if (error != GraphicsContext3D::NO_ERROR) {</span>
<span class="udiff-line-modified-added">+     GCGLenum error = m_context-&gt;computeImageSizeInBytes(format, type, width, height, m_unpackAlignment, &amp;totalBytesRequired, nullptr);</span>
<span class="udiff-line-modified-added">+     if (error != GraphicsContextGL::NO_ERROR) {</span>
          synthesizeGLError(error, functionName, &quot;invalid texture dimensions&quot;);
          return false;
      }
      if (pixels-&gt;byteLength() &lt; totalBytesRequired) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;ArrayBufferView not big enough for request&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;ArrayBufferView not big enough for request&quot;);</span>
          return false;
      }
      return true;
  }
  
  bool WebGLRenderingContextBase::validateTexFuncParameters(const char* functionName,
      TexFuncValidationFunctionType functionType,
<span class="udiff-line-modified-removed">-     GC3Denum target, GC3Dint level,</span>
<span class="udiff-line-modified-removed">-     GC3Denum internalformat,</span>
<span class="udiff-line-modified-removed">-     GC3Dsizei width, GC3Dsizei height, GC3Dint border,</span>
<span class="udiff-line-modified-removed">-     GC3Denum format, GC3Denum type)</span>
<span class="udiff-line-modified-added">+     GCGLenum target, GCGLint level,</span>
<span class="udiff-line-modified-added">+     GCGLenum internalformat,</span>
<span class="udiff-line-modified-added">+     GCGLsizei width, GCGLsizei height, GCGLint border,</span>
<span class="udiff-line-modified-added">+     GCGLenum format, GCGLenum type)</span>
  {
      // We absolutely have to validate the format and type combination.
      // The texImage2D entry points taking HTMLImage, etc. will produce
      // temporary data based on this combination, so it must be legal.
      if (!validateTexFuncFormatAndType(functionName, internalformat, format, type, level) || !validateTexFuncLevel(functionName, target, level))
          return false;
  
      if (width &lt; 0 || height &lt; 0) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;width or height &lt; 0&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;width or height &lt; 0&quot;);</span>
          return false;
      }
  
<span class="udiff-line-modified-removed">-     GC3Dint maxTextureSizeForLevel = pow(2.0, m_maxTextureLevel - 1 - level);</span>
<span class="udiff-line-modified-added">+     GCGLint maxTextureSizeForLevel = pow(2.0, m_maxTextureLevel - 1 - level);</span>
      switch (target) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_2D:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_2D:</span>
          if (width &gt; maxTextureSizeForLevel || height &gt; maxTextureSizeForLevel) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;width or height out of range&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;width or height out of range&quot;);</span>
              return false;
          }
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_X:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_X:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Y:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Y:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Z:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Z:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_X:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_X:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Y:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Y:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Z:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Z:</span>
          if (functionType != TexSubImage &amp;&amp; width != height) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;width != height for cube map&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;width != height for cube map&quot;);</span>
              return false;
          }
          // No need to check height here. For texImage width == height.
          // For texSubImage that will be checked when checking yoffset + height is in range.
          if (width &gt; maxTextureSizeForLevel) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;width or height out of range for cube map&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;width or height out of range for cube map&quot;);</span>
              return false;
          }
          break;
      default:
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid target&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid target&quot;);</span>
          return false;
      }
  
      if (border) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;border != 0&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;border != 0&quot;);</span>
          return false;
      }
  
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateTexFuncFormatAndType(const char* functionName, GC3Denum internalFormat, GC3Denum format, GC3Denum type, GC3Dint level)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateTexFuncFormatAndType(const char* functionName, GCGLenum internalFormat, GCGLenum format, GCGLenum type, GCGLint level)</span>
  {
      switch (format) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::ALPHA:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::LUMINANCE:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::LUMINANCE_ALPHA:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGB:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::RGBA:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::ALPHA:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::LUMINANCE:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::LUMINANCE_ALPHA:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGB:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::RGBA:</span>
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::DEPTH_STENCIL:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::DEPTH_COMPONENT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::DEPTH_STENCIL:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::DEPTH_COMPONENT:</span>
          if (!m_webglDepthTexture &amp;&amp; isWebGL1()) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;depth texture formats not enabled&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;depth texture formats not enabled&quot;);</span>
              return false;
          }
          if (level &gt; 0) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;level must be 0 for depth formats&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;level must be 0 for depth formats&quot;);</span>
              return false;
          }
          break;
<span class="udiff-line-modified-removed">-     case Extensions3D::SRGB_EXT:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::SRGB_ALPHA_EXT:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::SRGB_EXT:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::SRGB_ALPHA_EXT:</span>
          if (!m_extsRGB) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;sRGB texture formats not enabled&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;sRGB texture formats not enabled&quot;);</span>
              return false;
          }
          break;
      default:
  #if ENABLE(WEBGL2)
          if (!isWebGL1()) {
              switch (format) {
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::RED:</span>
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::RED_INTEGER:</span>
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::RG:</span>
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::RG_INTEGER:</span>
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::RGB_INTEGER:</span>
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::RGBA_INTEGER:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::RED:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::RED_INTEGER:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::RG:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::RG_INTEGER:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::RGB_INTEGER:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::RGBA_INTEGER:</span>
                  break;
              default:
<span class="udiff-line-modified-removed">-                 synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture format&quot;);</span>
<span class="udiff-line-modified-added">+                 synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture format&quot;);</span>
                  return false;
              }
          } else
  #endif
          {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture format&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture format&quot;);</span>
              return false;
          }
      }
  
      switch (type) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_BYTE:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_SHORT_5_6_5:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_BYTE:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_SHORT_5_6_5:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1:</span>
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::FLOAT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::FLOAT:</span>
          if (!m_oesTextureFloat &amp;&amp; isWebGL1()) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
              return false;
          }
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::HALF_FLOAT:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::HALF_FLOAT_OES:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::HALF_FLOAT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::HALF_FLOAT_OES:</span>
          if (!m_oesTextureHalfFloat &amp;&amp; isWebGL1()) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
              return false;
          }
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_INT:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_INT_24_8:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_SHORT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_INT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_INT_24_8:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_SHORT:</span>
          if (!m_webglDepthTexture &amp;&amp; isWebGL1()) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
              return false;
          }
          break;
      default:
  #if ENABLE(WEBGL2)
          if (!isWebGL1()) {
              switch (type) {
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::BYTE:</span>
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::SHORT:</span>
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::INT:</span>
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::UNSIGNED_INT_2_10_10_10_REV:</span>
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::UNSIGNED_INT_10F_11F_11F_REV:</span>
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::UNSIGNED_INT_5_9_9_9_REV:</span>
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::FLOAT_32_UNSIGNED_INT_24_8_REV:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::BYTE:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::SHORT:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::INT:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::UNSIGNED_INT_10F_11F_11F_REV:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::UNSIGNED_INT_5_9_9_9_REV:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::FLOAT_32_UNSIGNED_INT_24_8_REV:</span>
                  break;
              default:
<span class="udiff-line-modified-removed">-                 synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
<span class="udiff-line-modified-added">+                 synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
                  return false;
              }
          } else
  #endif
          {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture type&quot;);</span>
              return false;
          }
      }
  
      // Verify that the combination of internalformat, format, and type is supported.
<span class="udiff-line-modified-removed">- #define INTERNAL_FORMAT_CASE(internalFormatMacro, formatMacro, type0, type1, type2, type3, type4) case GraphicsContext3D::internalFormatMacro: \</span>
<span class="udiff-line-modified-removed">-     if (format != GraphicsContext3D::formatMacro) { \</span>
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;invalid format for internalformat&quot;); \</span>
<span class="udiff-line-modified-added">+ #define INTERNAL_FORMAT_CASE(internalFormatMacro, formatMacro, type0, type1, type2, type3, type4) case GraphicsContextGLOpenGL::internalFormatMacro: \</span>
<span class="udiff-line-modified-added">+     if (format != GraphicsContextGLOpenGL::formatMacro) { \</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;invalid format for internalformat&quot;); \</span>
          return false; \
      } \
      if (type != type0 &amp;&amp; type != type1 &amp;&amp; type != type2 &amp;&amp; type != type3 &amp;&amp; type != type4) { \
<span class="udiff-line-modified-removed">-         if (type != GraphicsContext3D::HALF_FLOAT_OES || (type0 != GraphicsContext3D::HALF_FLOAT &amp;&amp; type1 != GraphicsContext3D::HALF_FLOAT &amp;&amp; type2 != GraphicsContext3D::HALF_FLOAT &amp;&amp; type3 != GraphicsContext3D::HALF_FLOAT)) { \</span>
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;invalid type for internalformat&quot;); \</span>
<span class="udiff-line-modified-added">+         if (type != GraphicsContextGL::HALF_FLOAT_OES || (type0 != GraphicsContextGL::HALF_FLOAT &amp;&amp; type1 != GraphicsContextGL::HALF_FLOAT &amp;&amp; type2 != GraphicsContextGL::HALF_FLOAT &amp;&amp; type3 != GraphicsContextGL::HALF_FLOAT)) { \</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;invalid type for internalformat&quot;); \</span>
              return false; \
          } \
      } \
      break;
      switch (internalFormat) {
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGB               , RGB            , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::UNSIGNED_SHORT_5_6_5  , GraphicsContext3D::HALF_FLOAT                  , GraphicsContext3D::FLOAT     , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGBA              , RGBA           , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4, GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1      , GraphicsContext3D::HALF_FLOAT, GraphicsContext3D::FLOAT);</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(LUMINANCE_ALPHA   , LUMINANCE_ALPHA, GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::HALF_FLOAT            , GraphicsContext3D::FLOAT                       , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(LUMINANCE         , LUMINANCE      , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::HALF_FLOAT            , GraphicsContext3D::FLOAT                       , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(ALPHA             , ALPHA          , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::HALF_FLOAT            , GraphicsContext3D::FLOAT                       , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(R8                , RED            , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(R8_SNORM          , RED            , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(R16F              , RED            , GraphicsContext3D::HALF_FLOAT                    , GraphicsContext3D::FLOAT                 , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(R32F              , RED            , GraphicsContext3D::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(R8UI              , RED_INTEGER    , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(R8I               , RED_INTEGER    , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(R16UI             , RED_INTEGER    , GraphicsContext3D::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(R16I              , RED_INTEGER    , GraphicsContext3D::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(R32UI             , RED_INTEGER    , GraphicsContext3D::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(R32I              , RED_INTEGER    , GraphicsContext3D::INT                           , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RG8               , RG             , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RG8_SNORM         , RG             , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RG16F             , RG             , GraphicsContext3D::HALF_FLOAT                    , GraphicsContext3D::FLOAT                 , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RG32F             , RG             , GraphicsContext3D::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RG8UI             , RG_INTEGER     , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RG8I              , RG_INTEGER     , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RG16UI            , RG_INTEGER     , GraphicsContext3D::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RG16I             , RG_INTEGER     , GraphicsContext3D::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RG32UI            , RG_INTEGER     , GraphicsContext3D::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RG32I             , RG_INTEGER     , GraphicsContext3D::INT                           , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGB8              , RGB            , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(SRGB8             , RGB            , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGB565            , RGB            , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::UNSIGNED_SHORT_5_6_5  , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGB8_SNORM        , RGB            , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(R11F_G11F_B10F    , RGB            , GraphicsContext3D::UNSIGNED_INT_10F_11F_11F_REV  , GraphicsContext3D::HALF_FLOAT            , GraphicsContext3D::FLOAT                       , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGB9_E5           , RGB            , GraphicsContext3D::UNSIGNED_INT_5_9_9_9_REV      , GraphicsContext3D::HALF_FLOAT            , GraphicsContext3D::FLOAT                       , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGB16F            , RGB            , GraphicsContext3D::HALF_FLOAT                    , GraphicsContext3D::FLOAT                 , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGB32F            , RGB            , GraphicsContext3D::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGB8UI            , RGB_INTEGER    , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGB8I             , RGB_INTEGER    , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGB16UI           , RGB_INTEGER    , GraphicsContext3D::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGB16I            , RGB_INTEGER    , GraphicsContext3D::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGB32UI           , RGB_INTEGER    , GraphicsContext3D::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGB32I            , RGB_INTEGER    , GraphicsContext3D::INT                           , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGBA8             , RGBA           , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(SRGB8_ALPHA8      , RGBA           , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGBA8_SNORM       , RGBA           , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGB5_A1           , RGBA           , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1, GraphicsContext3D::UNSIGNED_INT_2_10_10_10_REV , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGBA4             , RGBA           , GraphicsContext3D::UNSIGNED_BYTE                 , GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4, 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGB10_A2          , RGBA           , GraphicsContext3D::UNSIGNED_INT_2_10_10_10_REV   , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGBA16F           , RGBA           , GraphicsContext3D::HALF_FLOAT                    , GraphicsContext3D::FLOAT                 , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGBA32F           , RGBA           , GraphicsContext3D::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGBA8UI           , RGBA_INTEGER   , GraphicsContext3D::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGBA8I            , RGBA_INTEGER   , GraphicsContext3D::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGB10_A2UI        , RGBA_INTEGER   , GraphicsContext3D::UNSIGNED_INT_2_10_10_10_REV   , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGBA16UI          , RGBA_INTEGER   , GraphicsContext3D::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGBA16I           , RGBA_INTEGER   , GraphicsContext3D::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGBA32I           , RGBA_INTEGER   , GraphicsContext3D::INT                           , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(RGBA32UI          , RGBA_INTEGER   , GraphicsContext3D::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT   , DEPTH_COMPONENT, GraphicsContext3D::UNSIGNED_SHORT                , GraphicsContext3D::UNSIGNED_INT          , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT16 , DEPTH_COMPONENT, GraphicsContext3D::UNSIGNED_SHORT                , GraphicsContext3D::UNSIGNED_INT          , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT24 , DEPTH_COMPONENT, GraphicsContext3D::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT32F, DEPTH_COMPONENT, GraphicsContext3D::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(DEPTH_STENCIL     , DEPTH_STENCIL  , GraphicsContext3D::UNSIGNED_INT_24_8             , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(DEPTH24_STENCIL8  , DEPTH_STENCIL  , GraphicsContext3D::UNSIGNED_INT_24_8             , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     INTERNAL_FORMAT_CASE(DEPTH32F_STENCIL8 , DEPTH_STENCIL  , GraphicsContext3D::FLOAT_32_UNSIGNED_INT_24_8_REV, 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::SRGB_EXT:</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGB               , RGB            , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::UNSIGNED_SHORT_5_6_5  , GraphicsContextGL::HALF_FLOAT                  , GraphicsContextGL::FLOAT     , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGBA              , RGBA           , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4, GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1      , GraphicsContextGL::HALF_FLOAT, GraphicsContextGL::FLOAT);</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(LUMINANCE_ALPHA   , LUMINANCE_ALPHA, GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::HALF_FLOAT            , GraphicsContextGL::FLOAT                       , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(LUMINANCE         , LUMINANCE      , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::HALF_FLOAT            , GraphicsContextGL::FLOAT                       , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(ALPHA             , ALPHA          , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::HALF_FLOAT            , GraphicsContextGL::FLOAT                       , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(R8                , RED            , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(R8_SNORM          , RED            , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(R16F              , RED            , GraphicsContextGL::HALF_FLOAT                    , GraphicsContextGL::FLOAT                 , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(R32F              , RED            , GraphicsContextGL::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(R8UI              , RED_INTEGER    , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(R8I               , RED_INTEGER    , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(R16UI             , RED_INTEGER    , GraphicsContextGL::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(R16I              , RED_INTEGER    , GraphicsContextGL::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(R32UI             , RED_INTEGER    , GraphicsContextGL::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(R32I              , RED_INTEGER    , GraphicsContextGL::INT                           , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RG8               , RG             , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RG8_SNORM         , RG             , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RG16F             , RG             , GraphicsContextGL::HALF_FLOAT                    , GraphicsContextGL::FLOAT                 , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RG32F             , RG             , GraphicsContextGL::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RG8UI             , RG_INTEGER     , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RG8I              , RG_INTEGER     , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RG16UI            , RG_INTEGER     , GraphicsContextGL::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RG16I             , RG_INTEGER     , GraphicsContextGL::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RG32UI            , RG_INTEGER     , GraphicsContextGL::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RG32I             , RG_INTEGER     , GraphicsContextGL::INT                           , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGB8              , RGB            , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(SRGB8             , RGB            , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGB565            , RGB            , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::UNSIGNED_SHORT_5_6_5  , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGB8_SNORM        , RGB            , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(R11F_G11F_B10F    , RGB            , GraphicsContextGL::UNSIGNED_INT_10F_11F_11F_REV  , GraphicsContextGL::HALF_FLOAT            , GraphicsContextGL::FLOAT                       , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGB9_E5           , RGB            , GraphicsContextGL::UNSIGNED_INT_5_9_9_9_REV      , GraphicsContextGL::HALF_FLOAT            , GraphicsContextGL::FLOAT                       , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGB16F            , RGB            , GraphicsContextGL::HALF_FLOAT                    , GraphicsContextGL::FLOAT                 , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGB32F            , RGB            , GraphicsContextGL::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGB8UI            , RGB_INTEGER    , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGB8I             , RGB_INTEGER    , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGB16UI           , RGB_INTEGER    , GraphicsContextGL::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGB16I            , RGB_INTEGER    , GraphicsContextGL::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGB32UI           , RGB_INTEGER    , GraphicsContextGL::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGB32I            , RGB_INTEGER    , GraphicsContextGL::INT                           , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGBA8             , RGBA           , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(SRGB8_ALPHA8      , RGBA           , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGBA8_SNORM       , RGBA           , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGB5_A1           , RGBA           , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1, GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGBA4             , RGBA           , GraphicsContextGL::UNSIGNED_BYTE                 , GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4, 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGB10_A2          , RGBA           , GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV   , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGBA16F           , RGBA           , GraphicsContextGL::HALF_FLOAT                    , GraphicsContextGL::FLOAT                 , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGBA32F           , RGBA           , GraphicsContextGL::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGBA8UI           , RGBA_INTEGER   , GraphicsContextGL::UNSIGNED_BYTE                 , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGBA8I            , RGBA_INTEGER   , GraphicsContextGL::BYTE                          , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGB10_A2UI        , RGBA_INTEGER   , GraphicsContextGL::UNSIGNED_INT_2_10_10_10_REV   , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGBA16UI          , RGBA_INTEGER   , GraphicsContextGL::UNSIGNED_SHORT                , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGBA16I           , RGBA_INTEGER   , GraphicsContextGL::SHORT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGBA32I           , RGBA_INTEGER   , GraphicsContextGL::INT                           , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(RGBA32UI          , RGBA_INTEGER   , GraphicsContextGL::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT   , DEPTH_COMPONENT, GraphicsContextGL::UNSIGNED_SHORT                , GraphicsContextGL::UNSIGNED_INT          , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT16 , DEPTH_COMPONENT, GraphicsContextGL::UNSIGNED_SHORT                , GraphicsContextGL::UNSIGNED_INT          , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT24 , DEPTH_COMPONENT, GraphicsContextGL::UNSIGNED_INT                  , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(DEPTH_COMPONENT32F, DEPTH_COMPONENT, GraphicsContextGL::FLOAT                         , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(DEPTH_STENCIL     , DEPTH_STENCIL  , GraphicsContextGL::UNSIGNED_INT_24_8             , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(DEPTH24_STENCIL8  , DEPTH_STENCIL  , GraphicsContextGL::UNSIGNED_INT_24_8             , 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     INTERNAL_FORMAT_CASE(DEPTH32F_STENCIL8 , DEPTH_STENCIL  , GraphicsContextGL::FLOAT_32_UNSIGNED_INT_24_8_REV, 0                                        , 0                                              , 0                            , 0                       );</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::SRGB_EXT:</span>
          if (format != internalFormat) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;format and internalformat must match&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;format and internalformat must match&quot;);</span>
              return false;
          }
<span class="udiff-line-modified-removed">-         if (type != GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; type != GraphicsContext3D::UNSIGNED_SHORT_5_6_5 &amp;&amp; type != GraphicsContext3D::FLOAT &amp;&amp; type != GraphicsContext3D::HALF_FLOAT_OES &amp;&amp; type != GraphicsContext3D::HALF_FLOAT) {</span>
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;invalid type for internal format&quot;);</span>
<span class="udiff-line-modified-added">+         if (type != GraphicsContextGL::UNSIGNED_BYTE &amp;&amp; type != GraphicsContextGL::UNSIGNED_SHORT_5_6_5 &amp;&amp; type != GraphicsContextGL::FLOAT &amp;&amp; type != GraphicsContextGL::HALF_FLOAT_OES &amp;&amp; type != GraphicsContextGL::HALF_FLOAT) {</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;invalid type for internal format&quot;);</span>
              return false;
          }
          break;
<span class="udiff-line-modified-removed">-     case Extensions3D::SRGB_ALPHA_EXT:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::SRGB_ALPHA_EXT:</span>
          if (format != internalFormat) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;format and internalformat must match&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;format and internalformat must match&quot;);</span>
              return false;
          }
<span class="udiff-line-modified-removed">-         if (type != GraphicsContext3D::UNSIGNED_BYTE &amp;&amp; type != GraphicsContext3D::UNSIGNED_SHORT_4_4_4_4 &amp;&amp; type != GraphicsContext3D::UNSIGNED_SHORT_5_5_5_1 &amp;&amp; type != GraphicsContext3D::FLOAT &amp;&amp; type != GraphicsContext3D::HALF_FLOAT_OES &amp;&amp; type != GraphicsContext3D::HALF_FLOAT) {</span>
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;invalid type for internal format&quot;);</span>
<span class="udiff-line-modified-added">+         if (type != GraphicsContextGL::UNSIGNED_BYTE &amp;&amp; type != GraphicsContextGL::UNSIGNED_SHORT_4_4_4_4 &amp;&amp; type != GraphicsContextGL::UNSIGNED_SHORT_5_5_5_1 &amp;&amp; type != GraphicsContextGL::FLOAT &amp;&amp; type != GraphicsContextGL::HALF_FLOAT_OES &amp;&amp; type != GraphicsContextGL::HALF_FLOAT) {</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;invalid type for internal format&quot;);</span>
              return false;
          }
          break;
      default:
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;Unknown internal format&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;Unknown internal format&quot;);</span>
          return false;
      }
  #undef INTERNAL_FORMAT_CASE
  
      return true;
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::texSubImage2DBase(GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset, GC3Dsizei width, GC3Dsizei height, GC3Denum internalFormat, GC3Denum format, GC3Denum type, const void* pixels)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::texSubImage2DBase(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum internalFormat, GCGLenum format, GCGLenum type, const void* pixels)</span>
  {
      ASSERT(!isContextLost());
      ASSERT(validateTexFuncParameters(&quot;texSubImage2D&quot;, TexSubImage, target, level, internalFormat, width, height, 0, format, type));
      ASSERT(validateSize(&quot;texSubImage2D&quot;, xoffset, yoffset));
      ASSERT(validateSettableTexInternalFormat(&quot;texSubImage2D&quot;, internalFormat));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4431,64 +4465,64 @@</span>
      ASSERT(tex-&gt;getHeight(target, level) &gt;= (yoffset + height));
      ASSERT_UNUSED(internalFormat, tex-&gt;getInternalFormat(target, level) == internalFormat);
      m_context-&gt;texSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::copyTexImage2D(GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height, GC3Dint border)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::copyTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLint border)</span>
  {
      if (isContextLostOrPending())
          return;
<span class="udiff-line-modified-removed">-     if (!validateTexFuncParameters(&quot;copyTexImage2D&quot;, CopyTexImage, target, level, internalFormat, width, height, border, internalFormat, GraphicsContext3D::UNSIGNED_BYTE))</span>
<span class="udiff-line-modified-added">+     if (!validateTexFuncParameters(&quot;copyTexImage2D&quot;, CopyTexImage, target, level, internalFormat, width, height, border, internalFormat, GraphicsContextGL::UNSIGNED_BYTE))</span>
          return;
      if (!validateSettableTexInternalFormat(&quot;copyTexImage2D&quot;, internalFormat))
          return;
      auto tex = validateTextureBinding(&quot;copyTexImage2D&quot;, target, true);
      if (!tex)
          return;
      if (!isTexInternalFormatColorBufferCombinationValid(internalFormat, getBoundFramebufferColorFormat())) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;copyTexImage2D&quot;, &quot;framebuffer is incompatible format&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;copyTexImage2D&quot;, &quot;framebuffer is incompatible format&quot;);</span>
          return;
      }
      if (!isGLES2NPOTStrict() &amp;&amp; level &amp;&amp; WebGLTexture::isNPOT(width, height)) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;copyTexImage2D&quot;, &quot;level &gt; 0 not power of 2&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;copyTexImage2D&quot;, &quot;level &gt; 0 not power of 2&quot;);</span>
          return;
      }
      const char* reason = &quot;framebuffer incomplete&quot;;
<span class="udiff-line-modified-removed">-     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContext3D(), &amp;reason)) {</span>
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION, &quot;copyTexImage2D&quot;, reason);</span>
<span class="udiff-line-modified-added">+     if (m_framebufferBinding &amp;&amp; !m_framebufferBinding-&gt;onAccess(graphicsContextGL(), &amp;reason)) {</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION, &quot;copyTexImage2D&quot;, reason);</span>
          return;
      }
      clearIfComposited();
  
<span class="udiff-line-modified-removed">-     GC3Dint clippedX, clippedY;</span>
<span class="udiff-line-modified-removed">-     GC3Dsizei clippedWidth, clippedHeight;</span>
<span class="udiff-line-modified-added">+     GCGLint clippedX, clippedY;</span>
<span class="udiff-line-modified-added">+     GCGLsizei clippedWidth, clippedHeight;</span>
      if (clip2D(x, y, width, height, getBoundFramebufferWidth(), getBoundFramebufferHeight(), &amp;clippedX, &amp;clippedY, &amp;clippedWidth, &amp;clippedHeight)) {
          m_context-&gt;texImage2DResourceSafe(target, level, internalFormat, width, height, border,
<span class="udiff-line-modified-removed">-             internalFormat, GraphicsContext3D::UNSIGNED_BYTE, m_unpackAlignment);</span>
<span class="udiff-line-modified-added">+             internalFormat, GraphicsContextGL::UNSIGNED_BYTE, m_unpackAlignment);</span>
          if (clippedWidth &gt; 0 &amp;&amp; clippedHeight &gt; 0) {
              m_context-&gt;copyTexSubImage2D(target, level, clippedX - x, clippedY - y,
                  clippedX, clippedY, clippedWidth, clippedHeight);
          }
      } else
          m_context-&gt;copyTexImage2D(target, level, internalFormat, x, y, width, height, border);
  
      // FIXME: if the framebuffer is not complete, none of the below should be executed.
<span class="udiff-line-modified-removed">-     tex-&gt;setLevelInfo(target, level, internalFormat, width, height, GraphicsContext3D::UNSIGNED_BYTE);</span>
<span class="udiff-line-modified-added">+     tex-&gt;setLevelInfo(target, level, internalFormat, width, height, GraphicsContextGL::UNSIGNED_BYTE);</span>
  }
  
<span class="udiff-line-modified-removed">- static bool isRGBFormat(GC3Denum internalFormat)</span>
<span class="udiff-line-modified-added">+ static bool isRGBFormat(GCGLenum internalFormat)</span>
  {
<span class="udiff-line-modified-removed">-     return internalFormat == GraphicsContext3D::RGB</span>
<span class="udiff-line-modified-removed">-         || internalFormat == GraphicsContext3D::RGBA</span>
<span class="udiff-line-modified-removed">-         || internalFormat == GraphicsContext3D::RGB8</span>
<span class="udiff-line-modified-removed">-         || internalFormat == GraphicsContext3D::RGBA8;</span>
<span class="udiff-line-modified-added">+     return internalFormat == GraphicsContextGL::RGB</span>
<span class="udiff-line-modified-added">+         || internalFormat == GraphicsContextGL::RGBA</span>
<span class="udiff-line-modified-added">+         || internalFormat == GraphicsContextGL::RGB8</span>
<span class="udiff-line-modified-added">+         || internalFormat == GraphicsContextGL::RGBA8;</span>
  }
  
<span class="udiff-line-modified-removed">- ExceptionOr&lt;void&gt; WebGLRenderingContextBase::texImage2D(GC3Denum target, GC3Dint level, GC3Denum internalformat, GC3Denum format, GC3Denum type, Optional&lt;TexImageSource&gt; source)</span>
<span class="udiff-line-modified-added">+ ExceptionOr&lt;void&gt; WebGLRenderingContextBase::texImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLenum format, GCGLenum type, Optional&lt;TexImageSource&gt; source)</span>
  {
      if (!source) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texImage2D&quot;, &quot;source is null&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texImage2D&quot;, &quot;source is null&quot;);</span>
          return { };
      }
  
      auto visitor = WTF::makeVisitor([&amp;](const RefPtr&lt;ImageBitmap&gt;&amp; bitmap) -&gt; ExceptionOr&lt;void&gt; {
          if (isContextLostOrPending() || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceImageBitmap, target, level, internalformat, bitmap-&gt;width(), bitmap-&gt;height(), 0, format, type, 0, 0))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4503,46 +4537,46 @@</span>
          // via the GPU, without a read-back to system memory.
          //
          // FIXME: restriction of (RGB || RGBA)/UNSIGNED_BYTE should be lifted when
          // ImageBuffer::copyToPlatformTexture implementations are fully functional.
          if (texture
<span class="udiff-line-modified-removed">-             &amp;&amp; (format == GraphicsContext3D::RGB || format == GraphicsContext3D::RGBA)</span>
<span class="udiff-line-modified-removed">-             &amp;&amp; type == GraphicsContext3D::UNSIGNED_BYTE) {</span>
<span class="udiff-line-modified-added">+             &amp;&amp; (format == GraphicsContextGL::RGB || format == GraphicsContextGL::RGBA)</span>
<span class="udiff-line-modified-added">+             &amp;&amp; type == GraphicsContextGL::UNSIGNED_BYTE) {</span>
              auto textureInternalFormat = texture-&gt;getInternalFormat(target, level);
              if (isRGBFormat(textureInternalFormat) || !texture-&gt;isValid(target, level)) {
                  if (buffer-&gt;copyToPlatformTexture(*m_context.get(), target, texture-&gt;object(), internalformat, m_unpackPremultiplyAlpha, m_unpackFlipY)) {
                      texture-&gt;setLevelInfo(target, level, internalformat, bitmap-&gt;width(), bitmap-&gt;height(), type);
                      return { };
                  }
              }
          }
  
          // Normal pure SW path.
<span class="udiff-line-modified-removed">-         RefPtr&lt;Image&gt; image = buffer-&gt;copyImage(ImageBuffer::fastCopyImageMode());</span>
<span class="udiff-line-modified-added">+         RefPtr&lt;Image&gt; image = buffer-&gt;copyImage(DontCopyBackingStore);</span>
          if (image)
<span class="udiff-line-modified-removed">-             texImage2DImpl(target, level, internalformat, format, type, image.get(), GraphicsContext3D::HtmlDomImage, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
<span class="udiff-line-modified-added">+             texImage2DImpl(target, level, internalformat, format, type, image.get(), GraphicsContextGL::DOMSource::Image, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
          return { };
      }, [&amp;](const RefPtr&lt;ImageData&gt;&amp; pixels) -&gt; ExceptionOr&lt;void&gt; {
          if (isContextLostOrPending() || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceImageData, target, level, internalformat, pixels-&gt;width(), pixels-&gt;height(), 0, format, type, 0, 0))
              return { };
          Vector&lt;uint8_t&gt; data;
          bool needConversion = true;
          // The data from ImageData is always of format RGBA8.
          // No conversion is needed if destination format is RGBA and type is USIGNED_BYTE and no Flip or Premultiply operation is required.
<span class="udiff-line-modified-removed">-         if (!m_unpackFlipY &amp;&amp; !m_unpackPremultiplyAlpha &amp;&amp; format == GraphicsContext3D::RGBA &amp;&amp; type == GraphicsContext3D::UNSIGNED_BYTE)</span>
<span class="udiff-line-modified-added">+         if (!m_unpackFlipY &amp;&amp; !m_unpackPremultiplyAlpha &amp;&amp; format == GraphicsContextGL::RGBA &amp;&amp; type == GraphicsContextGL::UNSIGNED_BYTE)</span>
              needConversion = false;
          else {
              if (!m_context-&gt;extractImageData(pixels.get(), format, type, m_unpackFlipY, m_unpackPremultiplyAlpha, data)) {
<span class="udiff-line-modified-removed">-                 synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;texImage2D&quot;, &quot;bad image data&quot;);</span>
<span class="udiff-line-modified-added">+                 synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;texImage2D&quot;, &quot;bad image data&quot;);</span>
                  return { };
              }
          }
          if (m_unpackAlignment != 1)
<span class="udiff-line-modified-removed">-             m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, 1);</span>
<span class="udiff-line-modified-added">+             m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, 1);</span>
          texImage2DBase(target, level, internalformat, pixels-&gt;width(), pixels-&gt;height(), 0, format, type, needConversion ? data.data() : pixels-&gt;data()-&gt;data());
          if (m_unpackAlignment != 1)
<span class="udiff-line-modified-removed">-             m_context-&gt;pixelStorei(GraphicsContext3D::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
<span class="udiff-line-modified-added">+             m_context-&gt;pixelStorei(GraphicsContextGL::UNPACK_ALIGNMENT, m_unpackAlignment);</span>
          return { };
      }, [&amp;](const RefPtr&lt;HTMLImageElement&gt;&amp; image) -&gt; ExceptionOr&lt;void&gt; {
          if (isContextLostOrPending())
              return { };
          auto validationResult = validateHTMLImageElement(&quot;texImage2D&quot;, image.get());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4553,17 +4587,17 @@</span>
  
          RefPtr&lt;Image&gt; imageForRender = image-&gt;cachedImage()-&gt;imageForRenderer(image-&gt;renderer());
          if (!imageForRender)
              return { };
  
<span class="udiff-line-modified-removed">-         if (imageForRender-&gt;isSVGImage())</span>
<span class="udiff-line-modified-added">+         if (imageForRender-&gt;isSVGImage() || imageForRender-&gt;orientation() != ImageOrientation::None)</span>
              imageForRender = drawImageIntoBuffer(*imageForRender, image-&gt;width(), image-&gt;height(), 1);
  
          if (!imageForRender || !validateTexFunc(&quot;texImage2D&quot;, TexImage, SourceHTMLImageElement, target, level, internalformat, imageForRender-&gt;width(), imageForRender-&gt;height(), 0, format, type, 0, 0))
              return { };
  
<span class="udiff-line-modified-removed">-         texImage2DImpl(target, level, internalformat, format, type, imageForRender.get(), GraphicsContext3D::HtmlDomImage, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
<span class="udiff-line-modified-added">+         texImage2DImpl(target, level, internalformat, format, type, imageForRender.get(), GraphicsContextGL::DOMSource::Image, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
          return { };
      }, [&amp;](const RefPtr&lt;HTMLCanvasElement&gt;&amp; canvas) -&gt; ExceptionOr&lt;void&gt; {
          if (isContextLostOrPending())
              return { };
          auto validationResult = validateHTMLCanvasElement(&quot;texImage2D&quot;, canvas.get());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4579,12 +4613,12 @@</span>
          // via the GPU, without a read-back to system memory.
          //
          // FIXME: restriction of (RGB || RGBA)/UNSIGNED_BYTE should be lifted when
          // ImageBuffer::copyToPlatformTexture implementations are fully functional.
          if (texture
<span class="udiff-line-modified-removed">-             &amp;&amp; (format == GraphicsContext3D::RGB || format == GraphicsContext3D::RGBA)</span>
<span class="udiff-line-modified-removed">-             &amp;&amp; type == GraphicsContext3D::UNSIGNED_BYTE) {</span>
<span class="udiff-line-modified-added">+             &amp;&amp; (format == GraphicsContextGL::RGB || format == GraphicsContextGL::RGBA)</span>
<span class="udiff-line-modified-added">+             &amp;&amp; type == GraphicsContextGL::UNSIGNED_BYTE) {</span>
              auto textureInternalFormat = texture-&gt;getInternalFormat(target, level);
              if (isRGBFormat(textureInternalFormat) || !texture-&gt;isValid(target, level)) {
                  ImageBuffer* buffer = canvas-&gt;buffer();
                  if (buffer &amp;&amp; buffer-&gt;copyToPlatformTexture(*m_context.get(), target, texture-&gt;object(), internalformat, m_unpackPremultiplyAlpha, m_unpackFlipY)) {
                      texture-&gt;setLevelInfo(target, level, internalformat, canvas-&gt;width(), canvas-&gt;height(), type);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4595,11 +4629,11 @@</span>
  
          RefPtr&lt;ImageData&gt; imageData = canvas-&gt;getImageData();
          if (imageData)
              texImage2D(target, level, internalformat, format, type, TexImageSource(imageData.get()));
          else
<span class="udiff-line-modified-removed">-             texImage2DImpl(target, level, internalformat, format, type, canvas-&gt;copiedImage(), GraphicsContext3D::HtmlDomCanvas, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
<span class="udiff-line-modified-added">+             texImage2DImpl(target, level, internalformat, format, type, canvas-&gt;copiedImage(), GraphicsContextGL::DOMSource::Canvas, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
          return { };
      }
  #if ENABLE(VIDEO)
      , [&amp;](const RefPtr&lt;HTMLVideoElement&gt;&amp; video) -&gt; ExceptionOr&lt;void&gt; {
          if (isContextLostOrPending())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4615,13 +4649,13 @@</span>
          // Go through the fast path doing a GPU-GPU textures copy without a readback to system memory if possible.
          // Otherwise, it will fall back to the normal SW path.
          // FIXME: The current restrictions require that format shoud be RGB or RGBA,
          // type should be UNSIGNED_BYTE and level should be 0. It may be lifted in the future.
          auto texture = validateTextureBinding(&quot;texImage2D&quot;, target, true);
<span class="udiff-line-modified-removed">-         if (GraphicsContext3D::TEXTURE_2D == target &amp;&amp; texture</span>
<span class="udiff-line-modified-removed">-             &amp;&amp; (format == GraphicsContext3D::RGB || format == GraphicsContext3D::RGBA)</span>
<span class="udiff-line-modified-removed">-             &amp;&amp; type == GraphicsContext3D::UNSIGNED_BYTE</span>
<span class="udiff-line-modified-added">+         if (GraphicsContextGL::TEXTURE_2D == target &amp;&amp; texture</span>
<span class="udiff-line-modified-added">+             &amp;&amp; (format == GraphicsContextGL::RGB || format == GraphicsContextGL::RGBA)</span>
<span class="udiff-line-modified-added">+             &amp;&amp; type == GraphicsContextGL::UNSIGNED_BYTE</span>
              &amp;&amp; !level) {
              auto textureInternalFormat = texture-&gt;getInternalFormat(target, level);
              if (isRGBFormat(textureInternalFormat) || !texture-&gt;isValid(target, level)) {
                  if (video-&gt;copyVideoTextureToPlatformTexture(m_context.get(), texture-&gt;object(), target, level, internalformat, format, type, m_unpackPremultiplyAlpha, m_unpackFlipY)) {
                      texture-&gt;setLevelInfo(target, level, internalformat, video-&gt;videoWidth(), video-&gt;videoHeight(), type);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4629,14 +4663,14 @@</span>
                  }
              }
          }
  
          // Normal pure SW path.
<span class="udiff-line-modified-removed">-         RefPtr&lt;Image&gt; image = videoFrameToImage(video.get(), ImageBuffer::fastCopyImageMode());</span>
<span class="udiff-line-modified-added">+         RefPtr&lt;Image&gt; image = videoFrameToImage(video.get(), DontCopyBackingStore);</span>
          if (!image)
              return { };
<span class="udiff-line-modified-removed">-         texImage2DImpl(target, level, internalformat, format, type, image.get(), GraphicsContext3D::HtmlDomVideo, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
<span class="udiff-line-modified-added">+         texImage2DImpl(target, level, internalformat, format, type, image.get(), GraphicsContextGL::DOMSource::Video, m_unpackFlipY, m_unpackPremultiplyAlpha);</span>
          return { };
      }
  #endif
      );
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4647,65 +4681,65 @@</span>
  {
      IntSize size(width, height);
      size.scale(deviceScaleFactor);
      ImageBuffer* buf = m_generatedImageCache.imageBuffer(size);
      if (!buf) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::OUT_OF_MEMORY, &quot;texImage2D&quot;, &quot;out of memory&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::OUT_OF_MEMORY, &quot;texImage2D&quot;, &quot;out of memory&quot;);</span>
          return nullptr;
      }
  
      FloatRect srcRect(FloatPoint(), image.size());
      FloatRect destRect(FloatPoint(), size);
      buf-&gt;context().drawImage(image, destRect, srcRect);
<span class="udiff-line-modified-removed">-     return buf-&gt;copyImage(ImageBuffer::fastCopyImageMode());</span>
<span class="udiff-line-modified-added">+     return buf-&gt;copyImage(DontCopyBackingStore);</span>
  }
  
  #if ENABLE(VIDEO)
  
  RefPtr&lt;Image&gt; WebGLRenderingContextBase::videoFrameToImage(HTMLVideoElement* video, BackingStoreCopy backingStoreCopy)
  {
      IntSize size(video-&gt;videoWidth(), video-&gt;videoHeight());
      ImageBuffer* buf = m_generatedImageCache.imageBuffer(size);
      if (!buf) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::OUT_OF_MEMORY, &quot;texImage2D&quot;, &quot;out of memory&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::OUT_OF_MEMORY, &quot;texImage2D&quot;, &quot;out of memory&quot;);</span>
          return nullptr;
      }
      FloatRect destRect(0, 0, size.width(), size.height());
      // FIXME: Turn this into a GPU-GPU texture copy instead of CPU readback.
      video-&gt;paintCurrentFrameInContext(buf-&gt;context(), destRect);
      return buf-&gt;copyImage(backingStoreCopy);
  }
  
  #endif
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::texParameter(GC3Denum target, GC3Denum pname, GC3Dfloat paramf, GC3Dint parami, bool isFloat)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::texParameter(GCGLenum target, GCGLenum pname, GCGLfloat paramf, GCGLint parami, bool isFloat)</span>
  {
      if (isContextLostOrPending())
          return;
      auto tex = validateTextureBinding(&quot;texParameter&quot;, target, false);
      if (!tex)
          return;
      switch (pname) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_MIN_FILTER:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_MAG_FILTER:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_MIN_FILTER:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_MAG_FILTER:</span>
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_WRAP_S:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_WRAP_T:</span>
<span class="udiff-line-modified-removed">-         if ((isFloat &amp;&amp; paramf != GraphicsContext3D::CLAMP_TO_EDGE &amp;&amp; paramf != GraphicsContext3D::MIRRORED_REPEAT &amp;&amp; paramf != GraphicsContext3D::REPEAT)</span>
<span class="udiff-line-modified-removed">-             || (!isFloat &amp;&amp; parami != GraphicsContext3D::CLAMP_TO_EDGE &amp;&amp; parami != GraphicsContext3D::MIRRORED_REPEAT &amp;&amp; parami != GraphicsContext3D::REPEAT)) {</span>
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;texParameter&quot;, &quot;invalid parameter&quot;);</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_WRAP_S:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_WRAP_T:</span>
<span class="udiff-line-modified-added">+         if ((isFloat &amp;&amp; paramf != GraphicsContextGL::CLAMP_TO_EDGE &amp;&amp; paramf != GraphicsContextGL::MIRRORED_REPEAT &amp;&amp; paramf != GraphicsContextGL::REPEAT)</span>
<span class="udiff-line-modified-added">+             || (!isFloat &amp;&amp; parami != GraphicsContextGL::CLAMP_TO_EDGE &amp;&amp; parami != GraphicsContextGL::MIRRORED_REPEAT &amp;&amp; parami != GraphicsContextGL::REPEAT)) {</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;texParameter&quot;, &quot;invalid parameter&quot;);</span>
              return;
          }
          break;
<span class="udiff-line-modified-removed">-     case Extensions3D::TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::TEXTURE_MAX_ANISOTROPY_EXT: // EXT_texture_filter_anisotropic</span>
          if (!m_extTextureFilterAnisotropic) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;texParameter&quot;, &quot;invalid parameter, EXT_texture_filter_anisotropic not enabled&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;texParameter&quot;, &quot;invalid parameter, EXT_texture_filter_anisotropic not enabled&quot;);</span>
              return;
          }
          break;
      default:
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;texParameter&quot;, &quot;invalid parameter name&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;texParameter&quot;, &quot;invalid parameter name&quot;);</span>
          return;
      }
      if (isFloat) {
          tex-&gt;setParameterf(pname, paramf);
          m_context-&gt;texParameterf(target, pname, paramf);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4713,123 +4747,123 @@</span>
          tex-&gt;setParameteri(pname, parami);
          m_context-&gt;texParameteri(target, pname, parami);
      }
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::texParameterf(GC3Denum target, GC3Denum pname, GC3Dfloat param)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::texParameterf(GCGLenum target, GCGLenum pname, GCGLfloat param)</span>
  {
      texParameter(target, pname, param, 0, true);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::texParameteri(GC3Denum target, GC3Denum pname, GC3Dint param)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::texParameteri(GCGLenum target, GCGLenum pname, GCGLint param)</span>
  {
      texParameter(target, pname, 0, param, false);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::uniform1f(const WebGLUniformLocation* location, GC3Dfloat x)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::uniform1f(const WebGLUniformLocation* location, GCGLfloat x)</span>
  {
      if (isContextLostOrPending() || !location)
          return;
  
      if (location-&gt;program() != m_currentProgram) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform1f&quot;, &quot;location not for current program&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform1f&quot;, &quot;location not for current program&quot;);</span>
          return;
      }
  
      m_context-&gt;uniform1f(location-&gt;location(), x);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::uniform2f(const WebGLUniformLocation* location, GC3Dfloat x, GC3Dfloat y)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::uniform2f(const WebGLUniformLocation* location, GCGLfloat x, GCGLfloat y)</span>
  {
      if (isContextLostOrPending() || !location)
          return;
  
      if (location-&gt;program() != m_currentProgram) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform2f&quot;, &quot;location not for current program&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform2f&quot;, &quot;location not for current program&quot;);</span>
          return;
      }
  
      m_context-&gt;uniform2f(location-&gt;location(), x, y);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::uniform3f(const WebGLUniformLocation* location, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::uniform3f(const WebGLUniformLocation* location, GCGLfloat x, GCGLfloat y, GCGLfloat z)</span>
  {
      if (isContextLostOrPending() || !location)
          return;
  
      if (location-&gt;program() != m_currentProgram) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform3f&quot;, &quot;location not for current program&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform3f&quot;, &quot;location not for current program&quot;);</span>
          return;
      }
  
      m_context-&gt;uniform3f(location-&gt;location(), x, y, z);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::uniform4f(const WebGLUniformLocation* location, GC3Dfloat x, GC3Dfloat y, GC3Dfloat z, GC3Dfloat w)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::uniform4f(const WebGLUniformLocation* location, GCGLfloat x, GCGLfloat y, GCGLfloat z, GCGLfloat w)</span>
  {
      if (isContextLostOrPending() || !location)
          return;
  
      if (location-&gt;program() != m_currentProgram) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform4f&quot;, &quot;location not for current program&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform4f&quot;, &quot;location not for current program&quot;);</span>
          return;
      }
  
      m_context-&gt;uniform4f(location-&gt;location(), x, y, z, w);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::uniform1i(const WebGLUniformLocation* location, GC3Dint x)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::uniform1i(const WebGLUniformLocation* location, GCGLint x)</span>
  {
      if (isContextLostOrPending() || !location)
          return;
  
      if (location-&gt;program() != m_currentProgram) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform1i&quot;, &quot;location not for current program&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform1i&quot;, &quot;location not for current program&quot;);</span>
          return;
      }
  
<span class="udiff-line-modified-removed">-     if ((location-&gt;type() == GraphicsContext3D::SAMPLER_2D || location-&gt;type() == GraphicsContext3D::SAMPLER_CUBE) &amp;&amp; x &gt;= (int)m_textureUnits.size()) {</span>
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;uniform1i&quot;, &quot;invalid texture unit&quot;);</span>
<span class="udiff-line-modified-added">+     if ((location-&gt;type() == GraphicsContextGL::SAMPLER_2D || location-&gt;type() == GraphicsContextGL::SAMPLER_CUBE) &amp;&amp; x &gt;= (int)m_textureUnits.size()) {</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;uniform1i&quot;, &quot;invalid texture unit&quot;);</span>
          return;
      }
  
      m_context-&gt;uniform1i(location-&gt;location(), x);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::uniform2i(const WebGLUniformLocation* location, GC3Dint x, GC3Dint y)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::uniform2i(const WebGLUniformLocation* location, GCGLint x, GCGLint y)</span>
  {
      if (isContextLostOrPending() || !location)
          return;
  
      if (location-&gt;program() != m_currentProgram) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform2i&quot;, &quot;location not for current program&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform2i&quot;, &quot;location not for current program&quot;);</span>
          return;
      }
  
      m_context-&gt;uniform2i(location-&gt;location(), x, y);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::uniform3i(const WebGLUniformLocation* location, GC3Dint x, GC3Dint y, GC3Dint z)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::uniform3i(const WebGLUniformLocation* location, GCGLint x, GCGLint y, GCGLint z)</span>
  {
      if (isContextLostOrPending() || !location)
          return;
  
      if (location-&gt;program() != m_currentProgram) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform3i&quot;, &quot;location not for current program&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform3i&quot;, &quot;location not for current program&quot;);</span>
          return;
      }
  
      m_context-&gt;uniform3i(location-&gt;location(), x, y, z);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::uniform4i(const WebGLUniformLocation* location, GC3Dint x, GC3Dint y, GC3Dint z, GC3Dint w)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::uniform4i(const WebGLUniformLocation* location, GCGLint x, GCGLint y, GCGLint z, GCGLint w)</span>
  {
      if (isContextLostOrPending() || !location)
          return;
  
      if (location-&gt;program() != m_currentProgram) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;uniform4i&quot;, &quot;location not for current program&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;uniform4i&quot;, &quot;location not for current program&quot;);</span>
          return;
      }
  
      m_context-&gt;uniform4i(location-&gt;location(), x, y, z, w);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4872,15 +4906,15 @@</span>
          return;
  
      auto data = v.data();
      auto length = v.length();
  
<span class="udiff-line-modified-removed">-     if (location-&gt;type() == GraphicsContext3D::SAMPLER_2D || location-&gt;type() == GraphicsContext3D::SAMPLER_CUBE) {</span>
<span class="udiff-line-modified-added">+     if (location-&gt;type() == GraphicsContextGL::SAMPLER_2D || location-&gt;type() == GraphicsContextGL::SAMPLER_CUBE) {</span>
          for (auto i = 0; i &lt; length; ++i) {
              if (data[i] &gt;= static_cast&lt;int&gt;(m_textureUnits.size())) {
                  LOG(WebGL, &quot;Texture unit size=%zu, v[%d]=%d. Location type = %04X.&quot;, m_textureUnits.size(), i, data[i], location-&gt;type());
<span class="udiff-line-modified-removed">-                 synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;uniform1iv&quot;, &quot;invalid texture unit&quot;);</span>
<span class="udiff-line-modified-added">+                 synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;uniform1iv&quot;, &quot;invalid texture unit&quot;);</span>
                  return;
              }
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4909,25 +4943,25 @@</span>
          return;
  
      m_context-&gt;uniform4iv(location-&gt;location(), v.length() / 4, v.data());
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::uniformMatrix2fv(const WebGLUniformLocation* location, GC3Dboolean transpose, Float32List&amp;&amp; v)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::uniformMatrix2fv(const WebGLUniformLocation* location, GCGLboolean transpose, Float32List&amp;&amp; v)</span>
  {
      if (isContextLostOrPending() || !validateUniformMatrixParameters(&quot;uniformMatrix2fv&quot;, location, transpose, v, 4))
          return;
      m_context-&gt;uniformMatrix2fv(location-&gt;location(), v.length() / 4, transpose, v.data());
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::uniformMatrix3fv(const WebGLUniformLocation* location, GC3Dboolean transpose, Float32List&amp;&amp; v)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::uniformMatrix3fv(const WebGLUniformLocation* location, GCGLboolean transpose, Float32List&amp;&amp; v)</span>
  {
      if (isContextLostOrPending() || !validateUniformMatrixParameters(&quot;uniformMatrix3fv&quot;, location, transpose, v, 9))
          return;
      m_context-&gt;uniformMatrix3fv(location-&gt;location(), v.length() / 9, transpose, v.data());
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::uniformMatrix4fv(const WebGLUniformLocation* location, GC3Dboolean transpose, Float32List&amp;&amp; v)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::uniformMatrix4fv(const WebGLUniformLocation* location, GCGLboolean transpose, Float32List&amp;&amp; v)</span>
  {
      if (isContextLostOrPending() || !validateUniformMatrixParameters(&quot;uniformMatrix4fv&quot;, location, transpose, v, 16))
          return;
      m_context-&gt;uniformMatrix4fv(location-&gt;location(), v.length() / 16, transpose, v.data());
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4938,16 +4972,16 @@</span>
      if (!checkObjectToBeBound(&quot;useProgram&quot;, program, deleted))
          return;
      if (deleted)
          program = 0;
      if (program &amp;&amp; !program-&gt;getLinkStatus()) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;useProgram&quot;, &quot;program not valid&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;useProgram&quot;, &quot;program not valid&quot;);</span>
          return;
      }
      if (m_currentProgram != program) {
          if (m_currentProgram)
<span class="udiff-line-modified-removed">-             m_currentProgram-&gt;onDetached(graphicsContext3D());</span>
<span class="udiff-line-modified-added">+             m_currentProgram-&gt;onDetached(graphicsContextGL());</span>
          m_currentProgram = program;
          m_context-&gt;useProgram(objectOrZero(program));
          if (program)
              program-&gt;onAttached();
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4958,102 +4992,102 @@</span>
      if (isContextLostOrPending() || !validateWebGLObject(&quot;validateProgram&quot;, program))
          return;
      m_context-&gt;validateProgram(objectOrZero(program));
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::vertexAttrib1f(GC3Duint index, GC3Dfloat v0)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::vertexAttrib1f(GCGLuint index, GCGLfloat v0)</span>
  {
      vertexAttribfImpl(&quot;vertexAttrib1f&quot;, index, 1, v0, 0.0f, 0.0f, 1.0f);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::vertexAttrib2f(GC3Duint index, GC3Dfloat v0, GC3Dfloat v1)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::vertexAttrib2f(GCGLuint index, GCGLfloat v0, GCGLfloat v1)</span>
  {
      vertexAttribfImpl(&quot;vertexAttrib2f&quot;, index, 2, v0, v1, 0.0f, 1.0f);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::vertexAttrib3f(GC3Duint index, GC3Dfloat v0, GC3Dfloat v1, GC3Dfloat v2)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::vertexAttrib3f(GCGLuint index, GCGLfloat v0, GCGLfloat v1, GCGLfloat v2)</span>
  {
      vertexAttribfImpl(&quot;vertexAttrib3f&quot;, index, 3, v0, v1, v2, 1.0f);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::vertexAttrib4f(GC3Duint index, GC3Dfloat v0, GC3Dfloat v1, GC3Dfloat v2, GC3Dfloat v3)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::vertexAttrib4f(GCGLuint index, GCGLfloat v0, GCGLfloat v1, GCGLfloat v2, GCGLfloat v3)</span>
  {
      vertexAttribfImpl(&quot;vertexAttrib4f&quot;, index, 4, v0, v1, v2, v3);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::vertexAttrib1fv(GC3Duint index, Float32List&amp;&amp; v)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::vertexAttrib1fv(GCGLuint index, Float32List&amp;&amp; v)</span>
  {
      vertexAttribfvImpl(&quot;vertexAttrib1fv&quot;, index, WTFMove(v), 1);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::vertexAttrib2fv(GC3Duint index, Float32List&amp;&amp; v)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::vertexAttrib2fv(GCGLuint index, Float32List&amp;&amp; v)</span>
  {
      vertexAttribfvImpl(&quot;vertexAttrib2fv&quot;, index, WTFMove(v), 2);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::vertexAttrib3fv(GC3Duint index, Float32List&amp;&amp; v)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::vertexAttrib3fv(GCGLuint index, Float32List&amp;&amp; v)</span>
  {
      vertexAttribfvImpl(&quot;vertexAttrib3fv&quot;, index, WTFMove(v), 3);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::vertexAttrib4fv(GC3Duint index, Float32List&amp;&amp; v)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::vertexAttrib4fv(GCGLuint index, Float32List&amp;&amp; v)</span>
  {
      vertexAttribfvImpl(&quot;vertexAttrib4fv&quot;, index, WTFMove(v), 4);
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::vertexAttribPointer(GC3Duint index, GC3Dint size, GC3Denum type, GC3Dboolean normalized, GC3Dsizei stride, long long offset)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::vertexAttribPointer(GCGLuint index, GCGLint size, GCGLenum type, GCGLboolean normalized, GCGLsizei stride, long long offset)</span>
  {
      if (isContextLostOrPending())
          return;
      switch (type) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::BYTE:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_BYTE:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::SHORT:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::UNSIGNED_SHORT:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::FLOAT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::BYTE:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_BYTE:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::SHORT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::UNSIGNED_SHORT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::FLOAT:</span>
          break;
      default:
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;vertexAttribPointer&quot;, &quot;invalid type&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;vertexAttribPointer&quot;, &quot;invalid type&quot;);</span>
          return;
      }
      if (index &gt;= m_maxVertexAttribs) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;index out of range&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;index out of range&quot;);</span>
          return;
      }
      if (size &lt; 1 || size &gt; 4) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad size&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad size&quot;);</span>
          return;
      }
      if (stride &lt; 0 || stride &gt; 255) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad stride&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad stride&quot;);</span>
          return;
      }
      if (offset &lt; 0 || offset &gt; std::numeric_limits&lt;int32_t&gt;::max()) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad offset&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;vertexAttribPointer&quot;, &quot;bad offset&quot;);</span>
          return;
      }
      if (!m_boundArrayBuffer &amp;&amp; offset) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;vertexAttribPointer&quot;, &quot;no bound ARRAY_BUFFER&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;vertexAttribPointer&quot;, &quot;no bound ARRAY_BUFFER&quot;);</span>
          return;
      }
      // Determine the number of elements the bound buffer can hold, given the offset, size, type and stride
      auto typeSize = sizeInBytes(type);
      if (!typeSize) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, &quot;vertexAttribPointer&quot;, &quot;invalid type&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, &quot;vertexAttribPointer&quot;, &quot;invalid type&quot;);</span>
          return;
      }
<span class="udiff-line-modified-removed">-     if ((stride % typeSize) || (static_cast&lt;GC3Dintptr&gt;(offset) % typeSize)) {</span>
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;vertexAttribPointer&quot;, &quot;stride or offset not valid for type&quot;);</span>
<span class="udiff-line-modified-added">+     if ((stride % typeSize) || (static_cast&lt;GCGLintptr&gt;(offset) % typeSize)) {</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;vertexAttribPointer&quot;, &quot;stride or offset not valid for type&quot;);</span>
          return;
      }
<span class="udiff-line-modified-removed">-     GC3Dsizei bytesPerElement = size * typeSize;</span>
<span class="udiff-line-modified-added">+     GCGLsizei bytesPerElement = size * typeSize;</span>
  
<span class="udiff-line-modified-removed">-     m_boundVertexArrayObject-&gt;setVertexAttribState(index, bytesPerElement, size, type, normalized, stride, static_cast&lt;GC3Dintptr&gt;(offset), m_boundArrayBuffer.get());</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;vertexAttribPointer(index, size, type, normalized, stride, static_cast&lt;GC3Dintptr&gt;(offset));</span>
<span class="udiff-line-modified-added">+     m_boundVertexArrayObject-&gt;setVertexAttribState(index, bytesPerElement, size, type, normalized, stride, static_cast&lt;GCGLintptr&gt;(offset), m_boundArrayBuffer.get());</span>
<span class="udiff-line-modified-added">+     m_context-&gt;vertexAttribPointer(index, size, type, normalized, stride, static_cast&lt;GCGLintptr&gt;(offset));</span>
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::viewport(GC3Dint x, GC3Dint y, GC3Dsizei width, GC3Dsizei height)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::viewport(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)</span>
  {
      if (isContextLostOrPending())
          return;
      if (!validateSize(&quot;viewport&quot;, width, height))
          return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5061,11 +5095,11 @@</span>
  }
  
  void WebGLRenderingContextBase::forceLostContext(WebGLRenderingContextBase::LostContextMode mode)
  {
      if (isContextLostOrPending()) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;loseContext&quot;, &quot;context already lost&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;loseContext&quot;, &quot;context already lost&quot;);</span>
          return;
      }
  
      m_contextGroup-&gt;loseContextGroup(mode);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5093,15 +5127,15 @@</span>
      // There is no direct way to clear errors from a GL implementation and
      // looping until getError() becomes NO_ERROR might cause an infinite loop if
      // the driver or context implementation had a bug. So, loop a reasonably
      // large number of times to clear any existing errors.
      for (int i = 0; i &lt; 100; ++i) {
<span class="udiff-line-modified-removed">-         if (m_context-&gt;getError() == GraphicsContext3D::NO_ERROR)</span>
<span class="udiff-line-modified-added">+         if (m_context-&gt;getError() == GraphicsContextGL::NO_ERROR)</span>
              break;
      }
      ConsoleDisplayPreference display = (mode == RealLostContext) ? DisplayInConsole: DontDisplayInConsole;
<span class="udiff-line-modified-removed">-     synthesizeGLError(GraphicsContext3D::CONTEXT_LOST_WEBGL, &quot;loseContext&quot;, &quot;context lost&quot;, display);</span>
<span class="udiff-line-modified-added">+     synthesizeGLError(GraphicsContextGL::CONTEXT_LOST_WEBGL, &quot;loseContext&quot;, &quot;context lost&quot;, display);</span>
  
      // Don&#39;t allow restoration unless the context lost event has both been
      // dispatched and its default behavior prevented.
      m_restoreAllowed = false;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5111,17 +5145,17 @@</span>
  }
  
  void WebGLRenderingContextBase::forceRestoreContext()
  {
      if (!isContextLostOrPending()) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;restoreContext&quot;, &quot;context not lost&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;restoreContext&quot;, &quot;context not lost&quot;);</span>
          return;
      }
  
      if (!m_restoreAllowed) {
          if (m_contextLostMode == SyntheticLostContext)
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;restoreContext&quot;, &quot;context restoration not allowed&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;restoreContext&quot;, &quot;context restoration not allowed&quot;);</span>
          return;
      }
  
      if (!m_restoreTimer.isActive())
          m_restoreTimer.startOneShot(0_s);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5184,106 +5218,110 @@</span>
  
  void WebGLRenderingContextBase::stop()
  {
      if (!isContextLost() &amp;&amp; !m_isPendingPolicyResolution) {
          forceLostContext(SyntheticLostContext);
<span class="udiff-line-modified-removed">-         destroyGraphicsContext3D();</span>
<span class="udiff-line-modified-added">+         destroyGraphicsContextGL();</span>
      }
  }
  
  const char* WebGLRenderingContextBase::activeDOMObjectName() const
  {
      return &quot;WebGLRenderingContext&quot;;
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::canSuspendForDocumentSuspension() const</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::suspend(ReasonForSuspension)</span>
  {
<span class="udiff-line-modified-removed">-     // FIXME: We should try and do better here.</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-modified-added">+     m_isSuspended = true;</span>
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::getBooleanParameter(GC3Denum pname)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::resume()</span>
  {
<span class="udiff-line-modified-removed">-     GC3Dboolean value = 0;</span>
<span class="udiff-line-modified-added">+     m_isSuspended = false;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ bool WebGLRenderingContextBase::getBooleanParameter(GCGLenum pname)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     GCGLboolean value = 0;</span>
      m_context-&gt;getBooleanv(pname, &amp;value);
      return value;
  }
  
<span class="udiff-line-modified-removed">- Vector&lt;bool&gt; WebGLRenderingContextBase::getBooleanArrayParameter(GC3Denum pname)</span>
<span class="udiff-line-modified-added">+ Vector&lt;bool&gt; WebGLRenderingContextBase::getBooleanArrayParameter(GCGLenum pname)</span>
  {
<span class="udiff-line-modified-removed">-     if (pname != GraphicsContext3D::COLOR_WRITEMASK) {</span>
<span class="udiff-line-modified-added">+     if (pname != GraphicsContextGL::COLOR_WRITEMASK) {</span>
          notImplemented();
          return { };
      }
<span class="udiff-line-modified-removed">-     GC3Dboolean value[4] = { 0 };</span>
<span class="udiff-line-modified-added">+     GCGLboolean value[4] = { 0 };</span>
      m_context-&gt;getBooleanv(pname, value);
      Vector&lt;bool&gt; vector(4);
      for (unsigned i = 0; i &lt; 4; ++i)
          vector[i] = value[i];
      return vector;
  }
  
<span class="udiff-line-modified-removed">- float WebGLRenderingContextBase::getFloatParameter(GC3Denum pname)</span>
<span class="udiff-line-modified-added">+ float WebGLRenderingContextBase::getFloatParameter(GCGLenum pname)</span>
  {
<span class="udiff-line-modified-removed">-     GC3Dfloat value = 0;</span>
<span class="udiff-line-modified-added">+     GCGLfloat value = 0;</span>
      m_context-&gt;getFloatv(pname, &amp;value);
      return value;
  }
  
<span class="udiff-line-modified-removed">- int WebGLRenderingContextBase::getIntParameter(GC3Denum pname)</span>
<span class="udiff-line-modified-added">+ int WebGLRenderingContextBase::getIntParameter(GCGLenum pname)</span>
  {
<span class="udiff-line-modified-removed">-     GC3Dint value = 0;</span>
<span class="udiff-line-modified-added">+     GCGLint value = 0;</span>
      m_context-&gt;getIntegerv(pname, &amp;value);
      return value;
  }
  
<span class="udiff-line-modified-removed">- unsigned WebGLRenderingContextBase::getUnsignedIntParameter(GC3Denum pname)</span>
<span class="udiff-line-modified-added">+ unsigned WebGLRenderingContextBase::getUnsignedIntParameter(GCGLenum pname)</span>
  {
<span class="udiff-line-modified-removed">-     GC3Dint value = 0;</span>
<span class="udiff-line-modified-added">+     GCGLint value = 0;</span>
      m_context-&gt;getIntegerv(pname, &amp;value);
      return value;
  }
  
<span class="udiff-line-modified-removed">- long long WebGLRenderingContextBase::getInt64Parameter(GC3Denum pname)</span>
<span class="udiff-line-modified-added">+ long long WebGLRenderingContextBase::getInt64Parameter(GCGLenum pname)</span>
  {
<span class="udiff-line-modified-removed">-     GC3Dint64 value = 0;</span>
<span class="udiff-line-modified-added">+     GCGLint64 value = 0;</span>
      m_context-&gt;getInteger64v(pname, &amp;value);
      return value;
  }
  
<span class="udiff-line-modified-removed">- RefPtr&lt;Float32Array&gt; WebGLRenderingContextBase::getWebGLFloatArrayParameter(GC3Denum pname)</span>
<span class="udiff-line-modified-added">+ RefPtr&lt;Float32Array&gt; WebGLRenderingContextBase::getWebGLFloatArrayParameter(GCGLenum pname)</span>
  {
<span class="udiff-line-modified-removed">-     GC3Dfloat value[4] = {0};</span>
<span class="udiff-line-modified-added">+     GCGLfloat value[4] = {0};</span>
      m_context-&gt;getFloatv(pname, value);
      unsigned length = 0;
      switch (pname) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::ALIASED_POINT_SIZE_RANGE:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::ALIASED_LINE_WIDTH_RANGE:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::DEPTH_RANGE:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::ALIASED_POINT_SIZE_RANGE:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::ALIASED_LINE_WIDTH_RANGE:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::DEPTH_RANGE:</span>
          length = 2;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::BLEND_COLOR:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::COLOR_CLEAR_VALUE:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::BLEND_COLOR:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::COLOR_CLEAR_VALUE:</span>
          length = 4;
          break;
      default:
          notImplemented();
      }
      return Float32Array::tryCreate(value, length);
  }
  
<span class="udiff-line-modified-removed">- RefPtr&lt;Int32Array&gt; WebGLRenderingContextBase::getWebGLIntArrayParameter(GC3Denum pname)</span>
<span class="udiff-line-modified-added">+ RefPtr&lt;Int32Array&gt; WebGLRenderingContextBase::getWebGLIntArrayParameter(GCGLenum pname)</span>
  {
<span class="udiff-line-modified-removed">-     GC3Dint value[4] = {0};</span>
<span class="udiff-line-modified-added">+     GCGLint value[4] = {0};</span>
      m_context-&gt;getIntegerv(pname, value);
      unsigned length = 0;
      switch (pname) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::MAX_VIEWPORT_DIMS:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::MAX_VIEWPORT_DIMS:</span>
          length = 2;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::SCISSOR_BOX:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::VIEWPORT:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::SCISSOR_BOX:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::VIEWPORT:</span>
          length = 4;
          break;
      default:
          notImplemented();
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5309,14 +5347,14 @@</span>
          }
  
          usesAtLeastOneBlackTexture = true;
  
          if (badTexture != m_activeTextureUnit) {
<span class="udiff-line-modified-removed">-             m_context-&gt;activeTexture(badTexture + GraphicsContext3D::TEXTURE0);</span>
<span class="udiff-line-modified-added">+             m_context-&gt;activeTexture(badTexture + GraphicsContextGL::TEXTURE0);</span>
              resetActiveUnit = true;
          } else if (resetActiveUnit) {
<span class="udiff-line-modified-removed">-             m_context-&gt;activeTexture(badTexture + GraphicsContext3D::TEXTURE0);</span>
<span class="udiff-line-modified-added">+             m_context-&gt;activeTexture(badTexture + GraphicsContextGL::TEXTURE0);</span>
              resetActiveUnit = false;
          }
          RefPtr&lt;WebGLTexture&gt; tex2D;
          RefPtr&lt;WebGLTexture&gt; texCubeMap;
          if (prepareToDraw) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5328,16 +5366,16 @@</span>
          } else {
              tex2D = textureUnit.texture2DBinding.get();
              texCubeMap = textureUnit.textureCubeMapBinding.get();
          }
          if (needsToUseBlack2DTexture)
<span class="udiff-line-modified-removed">-             m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, objectOrZero(tex2D.get()));</span>
<span class="udiff-line-modified-added">+             m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, objectOrZero(tex2D.get()));</span>
          if (needsToUseBlack3DTexture)
<span class="udiff-line-modified-removed">-             m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_CUBE_MAP, objectOrZero(texCubeMap.get()));</span>
<span class="udiff-line-modified-added">+             m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_CUBE_MAP, objectOrZero(texCubeMap.get()));</span>
      }
      if (resetActiveUnit)
<span class="udiff-line-modified-removed">-         m_context-&gt;activeTexture(m_activeTextureUnit + GraphicsContext3D::TEXTURE0);</span>
<span class="udiff-line-modified-added">+         m_context-&gt;activeTexture(m_activeTextureUnit + GraphicsContextGL::TEXTURE0);</span>
  
      for (unsigned renderable : noLongerUnrenderable)
          m_unrenderableTextureUnits.remove(renderable);
  
      return usesAtLeastOneBlackTexture;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5345,46 +5383,45 @@</span>
  
  void WebGLRenderingContextBase::createFallbackBlackTextures1x1()
  {
      unsigned char black[] = {0, 0, 0, 255};
      m_blackTexture2D = createTexture();
<span class="udiff-line-modified-removed">-     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, m_blackTexture2D-&gt;object());</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_2D, 0, GraphicsContext3D::RGBA, 1, 1,</span>
<span class="udiff-line-modified-removed">-                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, 0);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, m_blackTexture2D-&gt;object());</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_2D, 0, GraphicsContextGL::RGBA, 1, 1,</span>
<span class="udiff-line-modified-added">+         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, 0);</span>
      m_blackTextureCubeMap = createTexture();
<span class="udiff-line-modified-removed">-     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_CUBE_MAP, m_blackTextureCubeMap-&gt;object());</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_X, 0, GraphicsContext3D::RGBA, 1, 1,</span>
<span class="udiff-line-modified-removed">-                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_X, 0, GraphicsContext3D::RGBA, 1, 1,</span>
<span class="udiff-line-modified-removed">-                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Y, 0, GraphicsContext3D::RGBA, 1, 1,</span>
<span class="udiff-line-modified-removed">-                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, GraphicsContext3D::RGBA, 1, 1,</span>
<span class="udiff-line-modified-removed">-                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Z, 0, GraphicsContext3D::RGBA, 1, 1,</span>
<span class="udiff-line-modified-removed">-                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;texImage2D(GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, GraphicsContext3D::RGBA, 1, 1,</span>
<span class="udiff-line-modified-removed">-                           0, GraphicsContext3D::RGBA, GraphicsContext3D::UNSIGNED_BYTE, black);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_CUBE_MAP, 0);</span>
<span class="udiff-line-modified-removed">- }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::isTexInternalFormatColorBufferCombinationValid(GC3Denum texInternalFormat,</span>
<span class="udiff-line-modified-removed">-                                                                            GC3Denum colorBufferFormat)</span>
<span class="udiff-line-modified-removed">- {</span>
<span class="udiff-line-modified-removed">-     unsigned need = GraphicsContext3D::getChannelBitsByFormat(texInternalFormat);</span>
<span class="udiff-line-removed">-     unsigned have = GraphicsContext3D::getChannelBitsByFormat(colorBufferFormat);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_CUBE_MAP, m_blackTextureCubeMap-&gt;object());</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_X, 0, GraphicsContextGL::RGBA, 1, 1,</span>
<span class="udiff-line-modified-added">+         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_X, 0, GraphicsContextGL::RGBA, 1, 1,</span>
<span class="udiff-line-modified-added">+         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Y, 0, GraphicsContextGL::RGBA, 1, 1,</span>
<span class="udiff-line-modified-added">+         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, GraphicsContextGL::RGBA, 1, 1,</span>
<span class="udiff-line-modified-added">+         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Z, 0, GraphicsContextGL::RGBA, 1, 1,</span>
<span class="udiff-line-modified-added">+         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;texImage2D(GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, GraphicsContextGL::RGBA, 1, 1,</span>
<span class="udiff-line-modified-added">+         0, GraphicsContextGL::RGBA, GraphicsContextGL::UNSIGNED_BYTE, black);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_CUBE_MAP, 0);</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::isTexInternalFormatColorBufferCombinationValid(GCGLenum texInternalFormat, GCGLenum colorBufferFormat)</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-modified-added">+     auto need = GraphicsContextGLOpenGL::getChannelBitsByFormat(texInternalFormat);</span>
<span class="udiff-line-modified-added">+     auto have = GraphicsContextGLOpenGL::getChannelBitsByFormat(colorBufferFormat);</span>
      return (need &amp; have) == need;
  }
  
<span class="udiff-line-modified-removed">- GC3Denum WebGLRenderingContextBase::getBoundFramebufferColorFormat()</span>
<span class="udiff-line-modified-added">+ GCGLenum WebGLRenderingContextBase::getBoundFramebufferColorFormat()</span>
  {
      if (m_framebufferBinding &amp;&amp; m_framebufferBinding-&gt;object())
          return m_framebufferBinding-&gt;getColorBufferFormat();
      if (m_attributes.alpha)
<span class="udiff-line-modified-removed">-         return GraphicsContext3D::RGBA;</span>
<span class="udiff-line-modified-removed">-     return GraphicsContext3D::RGB;</span>
<span class="udiff-line-modified-added">+         return GraphicsContextGL::RGBA;</span>
<span class="udiff-line-modified-added">+     return GraphicsContextGL::RGB;</span>
  }
  
  int WebGLRenderingContextBase::getBoundFramebufferWidth()
  {
      if (m_framebufferBinding &amp;&amp; m_framebufferBinding-&gt;object())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5397,129 +5434,129 @@</span>
      if (m_framebufferBinding &amp;&amp; m_framebufferBinding-&gt;object())
          return m_framebufferBinding-&gt;getColorBufferHeight();
      return m_context-&gt;getInternalFramebufferSize().height();
  }
  
<span class="udiff-line-modified-removed">- RefPtr&lt;WebGLTexture&gt; WebGLRenderingContextBase::validateTextureBinding(const char* functionName, GC3Denum target, bool useSixEnumsForCubeMap)</span>
<span class="udiff-line-modified-added">+ RefPtr&lt;WebGLTexture&gt; WebGLRenderingContextBase::validateTextureBinding(const char* functionName, GCGLenum target, bool useSixEnumsForCubeMap)</span>
  {
      RefPtr&lt;WebGLTexture&gt; texture;
      switch (target) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_2D:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_2D:</span>
          texture = m_textureUnits[m_activeTextureUnit].texture2DBinding;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_X:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_X:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Y:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Y:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Z:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Z:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_X:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_X:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Y:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Y:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Z:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Z:</span>
          if (!useSixEnumsForCubeMap) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture target&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture target&quot;);</span>
              return nullptr;
          }
          texture = m_textureUnits[m_activeTextureUnit].textureCubeMapBinding;
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_CUBE_MAP:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_CUBE_MAP:</span>
          if (useSixEnumsForCubeMap) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture target&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture target&quot;);</span>
              return nullptr;
          }
          texture = m_textureUnits[m_activeTextureUnit].textureCubeMapBinding;
          break;
      default:
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid texture target&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid texture target&quot;);</span>
          return nullptr;
      }
  
      if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
          m_unrenderableTextureUnits.add(m_activeTextureUnit);
  
      if (!texture)
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;no texture&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;no texture&quot;);</span>
      return texture;
  }
  
  bool WebGLRenderingContextBase::validateLocationLength(const char* functionName, const String&amp; string)
  {
      const unsigned maxWebGLLocationLength = 256;
      if (string.length() &gt; maxWebGLLocationLength) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;location length &gt; 256&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;location length &gt; 256&quot;);</span>
          return false;
      }
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateSize(const char* functionName, GC3Dint x, GC3Dint y)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateSize(const char* functionName, GCGLint x, GCGLint y)</span>
  {
      if (x &lt; 0 || y &lt; 0) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;size &lt; 0&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;size &lt; 0&quot;);</span>
          return false;
      }
      return true;
  }
  
  bool WebGLRenderingContextBase::validateString(const char* functionName, const String&amp; string)
  {
      for (size_t i = 0; i &lt; string.length(); ++i) {
          if (!validateCharacter(string[i])) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;string not ASCII&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;string not ASCII&quot;);</span>
              return false;
          }
      }
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateTexFuncLevel(const char* functionName, GC3Denum target, GC3Dint level)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateTexFuncLevel(const char* functionName, GCGLenum target, GCGLint level)</span>
  {
      if (level &lt; 0) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;level &lt; 0&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;level &lt; 0&quot;);</span>
          return false;
      }
      switch (target) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_2D:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_2D:</span>
          if (level &gt;= m_maxTextureLevel) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;level out of range&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;level out of range&quot;);</span>
              return false;
          }
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_X:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_X:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Y:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Y:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Z:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Z:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_X:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_X:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Y:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Y:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Z:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Z:</span>
          if (level &gt;= m_maxCubeMapTextureLevel) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;level out of range&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;level out of range&quot;);</span>
              return false;
          }
          break;
      }
      // This function only checks if level is legal, so we return true and don&#39;t
      // generate INVALID_ENUM if target is illegal.
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateCompressedTexFormat(GC3Denum format)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateCompressedTexFormat(GCGLenum format)</span>
  {
      return m_compressedTextureFormats.contains(format);
  }
  
  struct BlockParameters {
      const int width;
      const int height;
      const int size;
  };
  
<span class="udiff-line-modified-removed">- static inline unsigned calculateBytesForASTC(GC3Dsizei width, GC3Dsizei height, const BlockParameters&amp; parameters)</span>
<span class="udiff-line-modified-added">+ static inline unsigned calculateBytesForASTC(GCGLsizei width, GCGLsizei height, const BlockParameters&amp; parameters)</span>
  {
      return ((width + parameters.width - 1) / parameters.width) * ((height + parameters.height - 1) / parameters.height) * parameters.size;
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateCompressedTexFuncData(const char* functionName, GC3Dsizei width, GC3Dsizei height, GC3Denum format, ArrayBufferView&amp; pixels)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateCompressedTexFuncData(const char* functionName, GCGLsizei width, GCGLsizei height, GCGLenum format, ArrayBufferView&amp; pixels)</span>
  {
      if (width &lt; 0 || height &lt; 0) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;width or height &lt; 0&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;width or height &lt; 0&quot;);</span>
          return false;
      }
  
      unsigned bytesRequired = 0;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5539,252 +5576,322 @@</span>
          BlockParameters { 10, 8, kASTCBlockSize },
          BlockParameters { 10, 10, kASTCBlockSize },
          BlockParameters { 12, 10, kASTCBlockSize },
          BlockParameters { 12, 12, kASTCBlockSize }
      };
<span class="udiff-line-modified-removed">-     const GC3Denum ASTCEnumStartRGBA = Extensions3D::COMPRESSED_RGBA_ASTC_4x4_KHR;</span>
<span class="udiff-line-modified-removed">-     const GC3Denum ASTCEnumStartSRGB8 = Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;</span>
<span class="udiff-line-modified-added">+     const GCGLenum ASTCEnumStartRGBA = ExtensionsGL::COMPRESSED_RGBA_ASTC_4x4_KHR;</span>
<span class="udiff-line-modified-added">+     const GCGLenum ASTCEnumStartSRGB8 = ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     const int kEACAndETC2BlockSize = 4;</span>
  
      switch (format) {
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGB_S3TC_DXT1_EXT:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT1_EXT:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_ATC_RGB_AMD:</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-             const int kBlockSize = 8;</span>
<span class="udiff-line-modified-removed">-             const int kBlockWidth = 4;</span>
<span class="udiff-line-modified-removed">-             const int kBlockHeight = 4;</span>
<span class="udiff-line-modified-removed">-             int numBlocksAcross = (width + kBlockWidth - 1) / kBlockWidth;</span>
<span class="udiff-line-modified-removed">-             int numBlocksDown = (height + kBlockHeight - 1) / kBlockHeight;</span>
<span class="udiff-line-modified-removed">-             bytesRequired = numBlocksAcross * numBlocksDown * kBlockSize;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGB_S3TC_DXT1_EXT:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT1_EXT:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_ATC_RGB_AMD:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::ETC1_RGB8_OES: {</span>
<span class="udiff-line-modified-added">+         const int kBlockSize = 8;</span>
<span class="udiff-line-modified-added">+         const int kBlockWidth = 4;</span>
<span class="udiff-line-modified-added">+         const int kBlockHeight = 4;</span>
<span class="udiff-line-modified-added">+         int numBlocksAcross = (width + kBlockWidth - 1) / kBlockWidth;</span>
<span class="udiff-line-modified-added">+         int numBlocksDown = (height + kBlockHeight - 1) / kBlockHeight;</span>
<span class="udiff-line-modified-added">+         bytesRequired = numBlocksAcross * numBlocksDown * kBlockSize;</span>
          break;
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT3_EXT:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT5_EXT:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_ATC_RGBA_EXPLICIT_ALPHA_AMD:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_ATC_RGBA_INTERPOLATED_ALPHA_AMD:</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT3_EXT:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT5_EXT:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_ATC_RGBA_EXPLICIT_ALPHA_AMD:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_ATC_RGBA_INTERPOLATED_ALPHA_AMD:</span>
          {
              const int kBlockSize = 16;
              const int kBlockWidth = 4;
              const int kBlockHeight = 4;
              int numBlocksAcross = (width + kBlockWidth - 1) / kBlockWidth;
              int numBlocksDown = (height + kBlockHeight - 1) / kBlockHeight;
              bytesRequired = numBlocksAcross * numBlocksDown * kBlockSize;
          }
          break;
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGB_PVRTC_4BPPV1_IMG:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGB_PVRTC_4BPPV1_IMG:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:</span>
          {
              const int kBlockSize = 8;
              const int kBlockWidth = 8;
              const int kBlockHeight = 8;
              bytesRequired = (std::max(width, kBlockWidth) * std::max(height, kBlockHeight) * 4 + 7) / kBlockSize;
          }
          break;
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGB_PVRTC_2BPPV1_IMG:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGB_PVRTC_2BPPV1_IMG:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:</span>
          {
              const int kBlockSize = 8;
              const int kBlockWidth = 16;
              const int kBlockHeight = 8;
              bytesRequired = (std::max(width, kBlockWidth) * std::max(height, kBlockHeight) * 2 + 7) / kBlockSize;
          }
          break;
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_4x4_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_5x4_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_5x5_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_6x5_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_6x6_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_8x5_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_8x6_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_8x8_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_10x5_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_10x6_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_10x8_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_10x10_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_12x10_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_12x12_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_4x4_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_5x4_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_5x5_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_6x5_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_6x6_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_8x5_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_8x6_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_8x8_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x5_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x6_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x8_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x10_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_12x10_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_12x12_KHR:</span>
          bytesRequired = calculateBytesForASTC(width, height, ASTCParameters[format - ASTCEnumStartRGBA]);
          break;
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:</span>
          bytesRequired = calculateBytesForASTC(width, height, ASTCParameters[format - ASTCEnumStartSRGB8]);
          break;
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_R11_EAC:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_SIGNED_R11_EAC:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_RGB8_ETC2:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ETC2:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: {</span>
<span class="udiff-line-added">+         Checked&lt;unsigned, RecordOverflow&gt; checkedBytesRequired = (width + kEACAndETC2BlockSize - 1) / kEACAndETC2BlockSize;</span>
<span class="udiff-line-added">+         checkedBytesRequired *= (height + kEACAndETC2BlockSize - 1) / kEACAndETC2BlockSize;</span>
<span class="udiff-line-added">+         checkedBytesRequired *= 8;</span>
<span class="udiff-line-added">+         if (checkedBytesRequired.hasOverflowed()) {</span>
<span class="udiff-line-added">+             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;too large dimensions&quot;);</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         bytesRequired = checkedBytesRequired.unsafeGet();</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_RG11_EAC:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_SIGNED_RG11_EAC:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_RGBA8_ETC2_EAC:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: {</span>
<span class="udiff-line-added">+         Checked&lt;unsigned, RecordOverflow&gt; checkedBytesRequired = (width + kEACAndETC2BlockSize - 1) / kEACAndETC2BlockSize;</span>
<span class="udiff-line-added">+         checkedBytesRequired *= (height + kEACAndETC2BlockSize - 1) / kEACAndETC2BlockSize;</span>
<span class="udiff-line-added">+         checkedBytesRequired *= 16;</span>
<span class="udiff-line-added">+         if (checkedBytesRequired.hasOverflowed()) {</span>
<span class="udiff-line-added">+             synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;too large dimensions&quot;);</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         bytesRequired = checkedBytesRequired.unsafeGet();</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
      default:
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid format&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid format&quot;);</span>
          return false;
      }
  
      if (pixels.byteLength() != bytesRequired) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;length of ArrayBufferView is not correct for dimensions&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;length of ArrayBufferView is not correct for dimensions&quot;);</span>
          return false;
      }
  
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateCompressedTexDimensions(const char* functionName, GC3Denum target, GC3Dint level, GC3Dsizei width, GC3Dsizei height, GC3Denum format)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateCompressedTexDimensions(const char* functionName, GCGLenum target, GCGLint level, GCGLsizei width, GCGLsizei height, GCGLenum format)</span>
  {
      switch (format) {
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGB_S3TC_DXT1_EXT:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT1_EXT:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT3_EXT:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT5_EXT: {</span>
<span class="udiff-line-modified-removed">-         const GC3Dsizei kBlockWidth = 4;</span>
<span class="udiff-line-modified-removed">-         const GC3Dsizei kBlockHeight = 4;</span>
<span class="udiff-line-modified-removed">-         const GC3Dint maxTextureSize = target ? m_maxTextureSize : m_maxCubeMapTextureSize;</span>
<span class="udiff-line-modified-removed">-         const GC3Dsizei maxCompressedDimension = maxTextureSize &gt;&gt; level;</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGB_S3TC_DXT1_EXT:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT1_EXT:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT3_EXT:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT5_EXT: {</span>
<span class="udiff-line-modified-added">+         const GCGLsizei kBlockWidth = 4;</span>
<span class="udiff-line-modified-added">+         const GCGLsizei kBlockHeight = 4;</span>
<span class="udiff-line-modified-added">+         const GCGLint maxTextureSize = target ? m_maxTextureSize : m_maxCubeMapTextureSize;</span>
<span class="udiff-line-modified-added">+         const GCGLsizei maxCompressedDimension = maxTextureSize &gt;&gt; level;</span>
          bool widthValid = (level &amp;&amp; width == 1) || (level &amp;&amp; width == 2) || (!(width % kBlockWidth) &amp;&amp; width &lt;= maxCompressedDimension);
          bool heightValid = (level &amp;&amp; height == 1) || (level &amp;&amp; height == 2) || (!(height % kBlockHeight) &amp;&amp; height &lt;= maxCompressedDimension);
          if (!widthValid || !heightValid) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;width or height invalid for level&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;width or height invalid for level&quot;);</span>
              return false;
          }
          return true;
      }
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGB_PVRTC_4BPPV1_IMG:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGB_PVRTC_2BPPV1_IMG:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGB_PVRTC_4BPPV1_IMG:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGB_PVRTC_2BPPV1_IMG:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:</span>
          // Height and width must be powers of 2.
          if ((width &amp; (width - 1)) || (height &amp; (height - 1))) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;width or height invalid for level&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;width or height invalid for level&quot;);</span>
              return false;
          }
          return true;
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_4x4_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_5x4_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_5x5_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_6x5_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_6x6_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_8x5_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_8x6_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_8x8_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_10x5_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_10x6_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_10x8_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_10x10_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_12x10_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_ASTC_12x12_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:</span>
<span class="udiff-line-modified-removed">-         // No height and width restrictions on ASTC.</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_4x4_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_5x4_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_5x5_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_6x5_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_6x6_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_8x5_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_8x6_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_8x8_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x5_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x6_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x8_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_10x10_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_12x10_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_ASTC_12x12_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::ETC1_RGB8_OES:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_R11_EAC:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_SIGNED_R11_EAC:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_RG11_EAC:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_SIGNED_RG11_EAC:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_RGB8_ETC2:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ETC2:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_RGBA8_ETC2_EAC:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:</span>
<span class="udiff-line-added">+         // No height and width restrictions on ASTC, ETC1 or ETC2.</span>
          return true;
      default:
          return false;
      }
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateCompressedTexSubDimensions(const char* functionName, GC3Denum target, GC3Dint level, GC3Dint xoffset, GC3Dint yoffset,</span>
<span class="udiff-line-removed">-                                                                GC3Dsizei width, GC3Dsizei height, GC3Denum format, WebGLTexture* tex)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateCompressedTexSubDimensions(const char* functionName, GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, WebGLTexture* tex)</span>
  {
      if (xoffset &lt; 0 || yoffset &lt; 0) {
<span class="udiff-line-modified-removed">-       synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;xoffset or yoffset &lt; 0&quot;);</span>
<span class="udiff-line-modified-removed">-       return false;</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;xoffset or yoffset &lt; 0&quot;);</span>
<span class="udiff-line-modified-added">+         return false;</span>
      }
  
      switch (format) {
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGB_S3TC_DXT1_EXT:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT1_EXT:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT3_EXT:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_S3TC_DXT5_EXT: {</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGB_S3TC_DXT1_EXT:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT1_EXT:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT3_EXT:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_S3TC_DXT5_EXT: {</span>
          const int kBlockWidth = 4;
          const int kBlockHeight = 4;
          if ((xoffset % kBlockWidth) || (yoffset % kBlockHeight)) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;xoffset or yoffset not multiple of 4&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;xoffset or yoffset not multiple of 4&quot;);</span>
              return false;
          }
          if (width - xoffset &gt; tex-&gt;getWidth(target, level)
              || height - yoffset &gt; tex-&gt;getHeight(target, level)) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;dimensions out of range&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;dimensions out of range&quot;);</span>
              return false;
          }
          return validateCompressedTexDimensions(functionName, target, level, width, height, format);
      }
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGB_PVRTC_4BPPV1_IMG:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGB_PVRTC_2BPPV1_IMG:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:</span>
<span class="udiff-line-modified-removed">-     case Extensions3D::COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: {</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGB_PVRTC_4BPPV1_IMG:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGB_PVRTC_2BPPV1_IMG:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: {</span>
          if (xoffset || yoffset) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;xoffset and yoffset must be zero&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;xoffset and yoffset must be zero&quot;);</span>
              return false;
          }
          if (width != tex-&gt;getWidth(target, level)
              || height != tex-&gt;getHeight(target, level)) {
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;dimensions must match existing level&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;dimensions must match existing level&quot;);</span>
              return false;
          }
          return validateCompressedTexDimensions(functionName, target, level, width, height, format);
      }
<span class="udiff-line-added">+     case ExtensionsGL::ETC1_RGB8_OES:</span>
<span class="udiff-line-added">+         // Not supported for ETC1_RGB8_OES textures.</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_R11_EAC:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_SIGNED_R11_EAC:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_RG11_EAC:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_SIGNED_RG11_EAC:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_RGB8_ETC2:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ETC2:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_RGBA8_ETC2_EAC:</span>
<span class="udiff-line-added">+     case ExtensionsGL::COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: {</span>
<span class="udiff-line-added">+         if (target == GraphicsContextGL::TEXTURE_3D) {</span>
<span class="udiff-line-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;not supported on TEXTURE_3D textures&quot;);</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         const int kBlockSize = 4;</span>
<span class="udiff-line-added">+         int texWidth = tex-&gt;getWidth(target, level);</span>
<span class="udiff-line-added">+         int texHeight = tex-&gt;getHeight(target, level);</span>
<span class="udiff-line-added">+         if ((xoffset % kBlockSize) || (yoffset % kBlockSize)</span>
<span class="udiff-line-added">+             || ((width % kBlockSize) &amp;&amp; xoffset + width != texWidth)</span>
<span class="udiff-line-added">+             || ((height % kBlockSize) &amp;&amp; yoffset + height != texHeight)) {</span>
<span class="udiff-line-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;dimensions must match existing texture level dimensions&quot;);</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         return true;</span>
<span class="udiff-line-added">+     }</span>
      default:
          return false;
      }
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateDrawMode(const char* functionName, GC3Denum mode)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateDrawMode(const char* functionName, GCGLenum mode)</span>
  {
      switch (mode) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::POINTS:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::LINE_STRIP:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::LINE_LOOP:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::LINES:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TRIANGLE_STRIP:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TRIANGLE_FAN:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::TRIANGLES:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::POINTS:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::LINE_STRIP:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::LINE_LOOP:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::LINES:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TRIANGLE_STRIP:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TRIANGLE_FAN:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::TRIANGLES:</span>
          return true;
      default:
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid draw mode&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid draw mode&quot;);</span>
          return false;
      }
  }
  
  bool WebGLRenderingContextBase::validateStencilSettings(const char* functionName)
  {
      if (m_stencilMask != m_stencilMaskBack || m_stencilFuncRef != m_stencilFuncRefBack || m_stencilFuncMask != m_stencilFuncMaskBack) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;front and back stencils settings do not match&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;front and back stencils settings do not match&quot;);</span>
          return false;
      }
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateStencilFunc(const char* functionName, GC3Denum func)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateStencilFunc(const char* functionName, GCGLenum func)</span>
  {
      switch (func) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::NEVER:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::LESS:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::LEQUAL:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::GREATER:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::GEQUAL:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::EQUAL:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::NOTEQUAL:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::ALWAYS:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::NEVER:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::LESS:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::LEQUAL:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::GREATER:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::GEQUAL:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::EQUAL:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::NOTEQUAL:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::ALWAYS:</span>
          return true;
      default:
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid function&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid function&quot;);</span>
          return false;
      }
  }
  
  void WebGLRenderingContextBase::printToConsole(MessageLevel level, const String&amp; message)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5808,139 +5915,139 @@</span>
      --m_numGLErrorsToConsoleAllowed;
      if (!m_numGLErrorsToConsoleAllowed)
          printToConsole(MessageLevel::Warning, &quot;WebGL: too many errors, no more errors will be reported to the console for this context.&quot;);
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateBlendFuncFactors(const char* functionName, GC3Denum src, GC3Denum dst)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateBlendFuncFactors(const char* functionName, GCGLenum src, GCGLenum dst)</span>
  {
<span class="udiff-line-modified-removed">-     if (((src == GraphicsContext3D::CONSTANT_COLOR || src == GraphicsContext3D::ONE_MINUS_CONSTANT_COLOR)</span>
<span class="udiff-line-modified-removed">-          &amp;&amp; (dst == GraphicsContext3D::CONSTANT_ALPHA || dst == GraphicsContext3D::ONE_MINUS_CONSTANT_ALPHA))</span>
<span class="udiff-line-modified-removed">-         || ((dst == GraphicsContext3D::CONSTANT_COLOR || dst == GraphicsContext3D::ONE_MINUS_CONSTANT_COLOR)</span>
<span class="udiff-line-modified-removed">-             &amp;&amp; (src == GraphicsContext3D::CONSTANT_ALPHA || src == GraphicsContext3D::ONE_MINUS_CONSTANT_ALPHA))) {</span>
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;incompatible src and dst&quot;);</span>
<span class="udiff-line-modified-added">+     if (((src == GraphicsContextGL::CONSTANT_COLOR || src == GraphicsContextGL::ONE_MINUS_CONSTANT_COLOR)</span>
<span class="udiff-line-modified-added">+         &amp;&amp; (dst == GraphicsContextGL::CONSTANT_ALPHA || dst == GraphicsContextGL::ONE_MINUS_CONSTANT_ALPHA))</span>
<span class="udiff-line-modified-added">+         || ((dst == GraphicsContextGL::CONSTANT_COLOR || dst == GraphicsContextGL::ONE_MINUS_CONSTANT_COLOR)</span>
<span class="udiff-line-modified-added">+             &amp;&amp; (src == GraphicsContextGL::CONSTANT_ALPHA || src == GraphicsContextGL::ONE_MINUS_CONSTANT_ALPHA))) {</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;incompatible src and dst&quot;);</span>
          return false;
      }
      return true;
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateUniformParameters(const char* functionName, const WebGLUniformLocation* location, const Float32List&amp; v, GC3Dsizei requiredMinSize)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateUniformParameters(const char* functionName, const WebGLUniformLocation* location, const Float32List&amp; v, GCGLsizei requiredMinSize)</span>
  {
      return validateUniformMatrixParameters(functionName, location, false, v.data(), v.length(), requiredMinSize);
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateUniformParameters(const char* functionName, const WebGLUniformLocation* location, const Int32List&amp; v, GC3Dsizei requiredMinSize)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateUniformParameters(const char* functionName, const WebGLUniformLocation* location, const Int32List&amp; v, GCGLsizei requiredMinSize)</span>
  {
      return validateUniformMatrixParameters(functionName, location, false, v.data(), v.length(), requiredMinSize);
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateUniformParameters(const char* functionName, const WebGLUniformLocation* location, void* v, GC3Dsizei size, GC3Dsizei requiredMinSize)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateUniformParameters(const char* functionName, const WebGLUniformLocation* location, void* v, GCGLsizei size, GCGLsizei requiredMinSize)</span>
  {
      return validateUniformMatrixParameters(functionName, location, false, v, size, requiredMinSize);
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation* location, GC3Dboolean transpose, const Float32List&amp; v, GC3Dsizei requiredMinSize)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation* location, GCGLboolean transpose, const Float32List&amp; v, GCGLsizei requiredMinSize)</span>
  {
      return validateUniformMatrixParameters(functionName, location, transpose, v.data(), v.length(), requiredMinSize);
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation* location, GC3Dboolean transpose, const void* v, GC3Dsizei size, GC3Dsizei requiredMinSize)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateUniformMatrixParameters(const char* functionName, const WebGLUniformLocation* location, GCGLboolean transpose, const void* v, GCGLsizei size, GCGLsizei requiredMinSize)</span>
  {
      if (!location)
          return false;
      if (location-&gt;program() != m_currentProgram) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;location is not from current program&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;location is not from current program&quot;);</span>
          return false;
      }
      if (!v) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no array&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no array&quot;);</span>
          return false;
      }
      if (transpose) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;transpose not FALSE&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;transpose not FALSE&quot;);</span>
          return false;
      }
      if (size &lt; requiredMinSize || (size % requiredMinSize)) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;invalid size&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;invalid size&quot;);</span>
          return false;
      }
      return true;
  }
  
<span class="udiff-line-modified-removed">- WebGLBuffer* WebGLRenderingContextBase::validateBufferDataParameters(const char* functionName, GC3Denum target, GC3Denum usage)</span>
<span class="udiff-line-modified-added">+ WebGLBuffer* WebGLRenderingContextBase::validateBufferDataParameters(const char* functionName, GCGLenum target, GCGLenum usage)</span>
  {
      Optional&lt;WebGLBuffer*&gt; buffer;
      switch (target) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::ELEMENT_ARRAY_BUFFER:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::ELEMENT_ARRAY_BUFFER:</span>
          buffer = m_boundVertexArrayObject-&gt;getElementArrayBuffer();
          break;
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::ARRAY_BUFFER:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::ARRAY_BUFFER:</span>
          buffer = m_boundArrayBuffer.get();
          break;
      default:
  #if ENABLE(WEBGL2)
          if (isWebGL2()) {
              switch (target) {
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::COPY_READ_BUFFER:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::COPY_READ_BUFFER:</span>
                  buffer = m_boundCopyReadBuffer.get();
                  break;
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::COPY_WRITE_BUFFER:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::COPY_WRITE_BUFFER:</span>
                  buffer = m_boundCopyWriteBuffer.get();
                  break;
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::PIXEL_PACK_BUFFER:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::PIXEL_PACK_BUFFER:</span>
                  buffer = m_boundPixelPackBuffer.get();
                  break;
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::PIXEL_UNPACK_BUFFER:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::PIXEL_UNPACK_BUFFER:</span>
                  buffer = m_boundPixelUnpackBuffer.get();
                  break;
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::TRANSFORM_FEEDBACK_BUFFER:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::TRANSFORM_FEEDBACK_BUFFER:</span>
                  buffer = m_boundTransformFeedbackBuffer.get();
                  break;
<span class="udiff-line-modified-removed">-             case GraphicsContext3D::UNIFORM_BUFFER:</span>
<span class="udiff-line-modified-added">+             case GraphicsContextGL::UNIFORM_BUFFER:</span>
                  buffer = m_boundUniformBuffer.get();
                  break;
              }
              if (buffer)
                  break;
          }
  #endif
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid target&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid target&quot;);</span>
          return nullptr;
      }
      if (!buffer || !buffer.value()) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, functionName, &quot;no buffer&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, functionName, &quot;no buffer&quot;);</span>
          return nullptr;
      }
      switch (usage) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::STREAM_DRAW:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::STATIC_DRAW:</span>
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::DYNAMIC_DRAW:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::STREAM_DRAW:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::STATIC_DRAW:</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::DYNAMIC_DRAW:</span>
          return buffer.value();
      }
<span class="udiff-line-modified-removed">-     synthesizeGLError(GraphicsContext3D::INVALID_ENUM, functionName, &quot;invalid usage&quot;);</span>
<span class="udiff-line-modified-added">+     synthesizeGLError(GraphicsContextGL::INVALID_ENUM, functionName, &quot;invalid usage&quot;);</span>
      return nullptr;
  }
  
  ExceptionOr&lt;bool&gt; WebGLRenderingContextBase::validateHTMLImageElement(const char* functionName, HTMLImageElement* image)
  {
      if (!image || !image-&gt;cachedImage()) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no image&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no image&quot;);</span>
          return false;
      }
      const URL&amp; url = image-&gt;cachedImage()-&gt;response().url();
      if (url.isNull() || url.isEmpty() || !url.isValid()) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;invalid image&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;invalid image&quot;);</span>
          return false;
      }
      if (wouldTaintOrigin(image))
          return Exception { SecurityError };
      return true;
  }
  
  ExceptionOr&lt;bool&gt; WebGLRenderingContextBase::validateHTMLCanvasElement(const char* functionName, HTMLCanvasElement* canvas)
  {
      if (!canvas || !canvas-&gt;buffer()) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no canvas&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no canvas&quot;);</span>
          return false;
      }
      if (wouldTaintOrigin(canvas))
          return Exception { SecurityError };
      return true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5949,26 +6056,26 @@</span>
  #if ENABLE(VIDEO)
  
  ExceptionOr&lt;bool&gt; WebGLRenderingContextBase::validateHTMLVideoElement(const char* functionName, HTMLVideoElement* video)
  {
      if (!video || !video-&gt;videoWidth() || !video-&gt;videoHeight()) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no video&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no video&quot;);</span>
          return false;
      }
      if (wouldTaintOrigin(video))
          return Exception { SecurityError };
      return true;
  }
  
  #endif
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::vertexAttribfImpl(const char* functionName, GC3Duint index, GC3Dsizei expectedSize, GC3Dfloat v0, GC3Dfloat v1, GC3Dfloat v2, GC3Dfloat v3)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::vertexAttribfImpl(const char* functionName, GCGLuint index, GCGLsizei expectedSize, GCGLfloat v0, GCGLfloat v1, GCGLfloat v2, GCGLfloat v3)</span>
  {
      if (isContextLostOrPending())
          return;
      if (index &gt;= m_maxVertexAttribs) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;index out of range&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;index out of range&quot;);</span>
          return;
      }
      // In GL, we skip setting vertexAttrib0 values.
      if (index || isGLES2Compliant()) {
          switch (expectedSize) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5991,28 +6098,28 @@</span>
      attribValue.value[1] = v1;
      attribValue.value[2] = v2;
      attribValue.value[3] = v3;
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::vertexAttribfvImpl(const char* functionName, GC3Duint index, Float32List&amp;&amp; list, GC3Dsizei expectedSize)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::vertexAttribfvImpl(const char* functionName, GCGLuint index, Float32List&amp;&amp; list, GCGLsizei expectedSize)</span>
  {
      if (isContextLostOrPending())
          return;
  
      auto data = list.data();
      if (!data) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;no array&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;no array&quot;);</span>
          return;
      }
  
      int size = list.length();
      if (size &lt; expectedSize) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;invalid size&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;invalid size&quot;);</span>
          return;
      }
      if (index &gt;= m_maxVertexAttribs) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, functionName, &quot;index out of range&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, functionName, &quot;index out of range&quot;);</span>
          return;
      }
      // In GL, we skip setting vertexAttrib0 values.
      if (index || isGLES2Compliant()) {
          switch (expectedSize) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6039,26 +6146,26 @@</span>
  void WebGLRenderingContextBase::initVertexAttrib0()
  {
      WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
  
      m_vertexAttrib0Buffer = createBuffer();
<span class="udiff-line-modified-removed">-     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, m_vertexAttrib0Buffer-&gt;object());</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;bufferData(GraphicsContext3D::ARRAY_BUFFER, 0, GraphicsContext3D::DYNAMIC_DRAW);</span>
<span class="udiff-line-modified-removed">-     m_context-&gt;vertexAttribPointer(0, 4, GraphicsContext3D::FLOAT, false, 0, 0);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, m_vertexAttrib0Buffer-&gt;object());</span>
<span class="udiff-line-modified-added">+     m_context-&gt;bufferData(GraphicsContextGL::ARRAY_BUFFER, 0, GraphicsContextGL::DYNAMIC_DRAW);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;vertexAttribPointer(0, 4, GraphicsContextGL::FLOAT, false, 0, 0);</span>
      state.bufferBinding = m_vertexAttrib0Buffer;
<span class="udiff-line-modified-removed">-     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, 0);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, 0);</span>
      m_context-&gt;enableVertexAttribArray(0);
      m_vertexAttrib0BufferSize = 0;
      m_vertexAttrib0BufferValue[0] = 0.0f;
      m_vertexAttrib0BufferValue[1] = 0.0f;
      m_vertexAttrib0BufferValue[2] = 0.0f;
      m_vertexAttrib0BufferValue[3] = 1.0f;
      m_forceAttrib0BufferRefill = false;
      m_vertexAttrib0UsedBefore = false;
  }
  
<span class="udiff-line-modified-removed">- bool WebGLRenderingContextBase::validateSimulatedVertexAttrib0(GC3Duint numVertex)</span>
<span class="udiff-line-modified-added">+ bool WebGLRenderingContextBase::validateSimulatedVertexAttrib0(GCGLuint numVertex)</span>
  {
      if (!m_currentProgram)
          return true;
  
      bool usingVertexAttrib0 = m_currentProgram-&gt;isUsingVertexAttrib0();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6067,20 +6174,20 @@</span>
  
      auto&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
      if (state.enabled)
          return true;
  
<span class="udiff-line-modified-removed">-     auto bufferSize = checkedAddAndMultiply&lt;GC3Duint&gt;(numVertex, 1, 4);</span>
<span class="udiff-line-modified-added">+     auto bufferSize = checkedAddAndMultiply&lt;GCGLuint&gt;(numVertex, 1, 4);</span>
      if (!bufferSize)
          return false;
  
<span class="udiff-line-modified-removed">-     Checked&lt;GC3Dsizeiptr, RecordOverflow&gt; bufferDataSize(bufferSize.value());</span>
<span class="udiff-line-modified-removed">-     bufferDataSize *= Checked&lt;GC3Dsizeiptr&gt;(sizeof(GC3Dfloat));</span>
<span class="udiff-line-modified-added">+     Checked&lt;GCGLsizeiptr, RecordOverflow&gt; bufferDataSize(bufferSize.value());</span>
<span class="udiff-line-modified-added">+     bufferDataSize *= Checked&lt;GCGLsizeiptr&gt;(sizeof(GCGLfloat));</span>
      return !bufferDataSize.hasOverflowed() &amp;&amp; bufferDataSize.unsafeGet() &gt; 0;
  }
  
<span class="udiff-line-modified-removed">- Optional&lt;bool&gt; WebGLRenderingContextBase::simulateVertexAttrib0(GC3Duint numVertex)</span>
<span class="udiff-line-modified-added">+ Optional&lt;bool&gt; WebGLRenderingContextBase::simulateVertexAttrib0(GCGLuint numVertex)</span>
  {
      if (!m_currentProgram)
          return false;
      bool usingVertexAttrib0 = m_currentProgram-&gt;isUsingVertexAttrib0();
      if (usingVertexAttrib0)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6090,20 +6197,20 @@</span>
      if (state.enabled &amp;&amp; usingVertexAttrib0)
          return false;
      if (!usingVertexAttrib0 &amp;&amp; !m_vertexAttrib0UsedBefore)
          return false;
      m_vertexAttrib0UsedBefore = true;
<span class="udiff-line-modified-removed">-     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, m_vertexAttrib0Buffer-&gt;object());</span>
<span class="udiff-line-modified-added">+     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, m_vertexAttrib0Buffer-&gt;object());</span>
  
      // We know bufferSize and bufferDataSize won&#39;t overflow or go negative, thanks to validateSimulatedVertexAttrib0
<span class="udiff-line-modified-removed">-     GC3Duint bufferSize = (numVertex + 1) * 4;</span>
<span class="udiff-line-modified-removed">-     GC3Dsizeiptr bufferDataSize = bufferSize * sizeof(GC3Dfloat);</span>
<span class="udiff-line-modified-added">+     GCGLuint bufferSize = (numVertex + 1) * 4;</span>
<span class="udiff-line-modified-added">+     GCGLsizeiptr bufferDataSize = bufferSize * sizeof(GCGLfloat);</span>
  
      if (bufferDataSize &gt; m_vertexAttrib0BufferSize) {
          m_context-&gt;moveErrorsToSyntheticErrorList();
<span class="udiff-line-modified-removed">-         m_context-&gt;bufferData(GraphicsContext3D::ARRAY_BUFFER, bufferDataSize, 0, GraphicsContext3D::DYNAMIC_DRAW);</span>
<span class="udiff-line-modified-removed">-         if (m_context-&gt;getError() != GraphicsContext3D::NO_ERROR) {</span>
<span class="udiff-line-modified-added">+         m_context-&gt;bufferData(GraphicsContextGL::ARRAY_BUFFER, bufferDataSize, 0, GraphicsContextGL::DYNAMIC_DRAW);</span>
<span class="udiff-line-modified-added">+         if (m_context-&gt;getError() != GraphicsContextGL::NO_ERROR) {</span>
              // We were unable to create a buffer.
              m_vertexAttrib0UsedBefore = false;
              m_vertexAttrib0BufferSize = 0;
              m_forceAttrib0BufferRefill = true;
              return WTF::nullopt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6119,40 +6226,41 @@</span>
              || attribValue.value[0] != m_vertexAttrib0BufferValue[0]
              || attribValue.value[1] != m_vertexAttrib0BufferValue[1]
              || attribValue.value[2] != m_vertexAttrib0BufferValue[2]
              || attribValue.value[3] != m_vertexAttrib0BufferValue[3])) {
  
<span class="udiff-line-modified-removed">-         auto bufferData = makeUniqueArray&lt;GC3Dfloat&gt;(bufferSize);</span>
<span class="udiff-line-modified-removed">-         for (GC3Duint ii = 0; ii &lt; numVertex + 1; ++ii) {</span>
<span class="udiff-line-modified-added">+         auto bufferData = makeUniqueArray&lt;GCGLfloat&gt;(bufferSize);</span>
<span class="udiff-line-modified-added">+         for (GCGLuint ii = 0; ii &lt; numVertex + 1; ++ii) {</span>
              bufferData[ii * 4] = attribValue.value[0];
              bufferData[ii * 4 + 1] = attribValue.value[1];
              bufferData[ii * 4 + 2] = attribValue.value[2];
              bufferData[ii * 4 + 3] = attribValue.value[3];
          }
          m_vertexAttrib0BufferValue[0] = attribValue.value[0];
          m_vertexAttrib0BufferValue[1] = attribValue.value[1];
          m_vertexAttrib0BufferValue[2] = attribValue.value[2];
          m_vertexAttrib0BufferValue[3] = attribValue.value[3];
          m_forceAttrib0BufferRefill = false;
<span class="udiff-line-modified-removed">-         m_context-&gt;bufferSubData(GraphicsContext3D::ARRAY_BUFFER, 0, bufferDataSize, bufferData.get());</span>
<span class="udiff-line-modified-added">+         m_context-&gt;bufferSubData(GraphicsContextGL::ARRAY_BUFFER, 0, bufferDataSize, bufferData.get());</span>
      }
<span class="udiff-line-modified-removed">-     m_context-&gt;vertexAttribPointer(0, 4, GraphicsContext3D::FLOAT, 0, 0, 0);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;vertexAttribPointer(0, 4, GraphicsContextGL::FLOAT, 0, 0, 0);</span>
      return true;
  }
  
  void WebGLRenderingContextBase::restoreStatesAfterVertexAttrib0Simulation()
  {
      const WebGLVertexArrayObjectBase::VertexAttribState&amp; state = m_boundVertexArrayObject-&gt;getVertexAttribState(0);
      if (state.bufferBinding != m_vertexAttrib0Buffer) {
<span class="udiff-line-modified-removed">-         m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, objectOrZero(state.bufferBinding.get()));</span>
<span class="udiff-line-modified-added">+         m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, objectOrZero(state.bufferBinding.get()));</span>
          m_context-&gt;vertexAttribPointer(0, state.size, state.type, state.normalized, state.originalStride, state.offset);
      }
<span class="udiff-line-modified-removed">-     m_context-&gt;bindBuffer(GraphicsContext3D::ARRAY_BUFFER, objectOrZero(m_boundArrayBuffer.get()));</span>
<span class="udiff-line-modified-added">+     m_context-&gt;bindBuffer(GraphicsContextGL::ARRAY_BUFFER, objectOrZero(m_boundArrayBuffer.get()));</span>
  }
  
  void WebGLRenderingContextBase::dispatchContextLostEvent()
  {
<span class="udiff-line-added">+     RELEASE_ASSERT(!m_isSuspended);</span>
      auto* canvas = htmlCanvas();
      if (!canvas)
          return;
  
      Ref&lt;WebGLContextEvent&gt; event = WebGLContextEvent::create(eventNames().webglcontextlostEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6162,10 +6270,11 @@</span>
          m_restoreTimer.startOneShot(0_s);
  }
  
  void WebGLRenderingContextBase::maybeRestoreContext()
  {
<span class="udiff-line-added">+     RELEASE_ASSERT(!m_isSuspended);</span>
      ASSERT(m_contextLost);
      if (!m_contextLost)
          return;
  
      // The rendering context is not restored unless the default behavior of the
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6178,25 +6287,25 @@</span>
          return;
  
      int contextLostReason = m_context-&gt;getExtensions().getGraphicsResetStatusARB();
  
      switch (contextLostReason) {
<span class="udiff-line-modified-removed">-     case GraphicsContext3D::NO_ERROR:</span>
<span class="udiff-line-modified-removed">-         // The GraphicsContext3D implementation might not fully</span>
<span class="udiff-line-modified-added">+     case GraphicsContextGL::NO_ERROR:</span>
<span class="udiff-line-modified-added">+         // The GraphicsContextGLOpenGL implementation might not fully</span>
          // support GL_ARB_robustness semantics yet. Alternatively, the
          // WEBGL_lose_context extension might have been used to force
          // a lost context.
          break;
<span class="udiff-line-modified-removed">-     case Extensions3D::GUILTY_CONTEXT_RESET_ARB:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::GUILTY_CONTEXT_RESET_ARB:</span>
          // The rendering context is not restored if this context was
          // guilty of causing the graphics reset.
          printToConsole(MessageLevel::Warning, &quot;WARNING: WebGL content on the page caused the graphics card to reset; not restoring the context&quot;);
          return;
<span class="udiff-line-modified-removed">-     case Extensions3D::INNOCENT_CONTEXT_RESET_ARB:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::INNOCENT_CONTEXT_RESET_ARB:</span>
          // Always allow the context to be restored.
          break;
<span class="udiff-line-modified-removed">-     case Extensions3D::UNKNOWN_CONTEXT_RESET_ARB:</span>
<span class="udiff-line-modified-added">+     case ExtensionsGL::UNKNOWN_CONTEXT_RESET_ARB:</span>
          // Warn. Ideally, prompt the user telling them that WebGL
          // content on the page might have caused the graphics card to
          // reset and ask them whether they want to continue running
          // the content. Only if they say &quot;yes&quot; should we start
          // attempting to restore the context.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6223,17 +6332,17 @@</span>
          return;
      HostWindow* hostWindow = root-&gt;hostWindow();
      if (!hostWindow)
          return;
  
<span class="udiff-line-modified-removed">-     RefPtr&lt;GraphicsContext3D&gt; context(GraphicsContext3D::create(m_attributes, hostWindow));</span>
<span class="udiff-line-modified-added">+     RefPtr&lt;GraphicsContextGLOpenGL&gt; context(GraphicsContextGLOpenGL::create(m_attributes, hostWindow));</span>
      if (!context) {
          if (m_contextLostMode == RealLostContext)
              m_restoreTimer.startOneShot(secondsBetweenRestoreAttempts);
          else
              // This likely shouldn&#39;t happen but is the best way to report it to the WebGL app.
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;&quot;, &quot;error restoring context&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;&quot;, &quot;error restoring context&quot;);</span>
          return;
      }
  
      m_context = context;
      addActivityStateChangeObserverIfNecessary();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6275,11 +6384,11 @@</span>
          buf-&gt;context().clearRect(FloatRect({ }, FloatSize(size)));
          return buf;
      }
  
      // FIXME (149423): Should this ImageBuffer be unconditionally unaccelerated?
<span class="udiff-line-modified-removed">-     std::unique_ptr&lt;ImageBuffer&gt; temp = ImageBuffer::create(size, Unaccelerated);</span>
<span class="udiff-line-modified-added">+     std::unique_ptr&lt;ImageBuffer&gt; temp = ImageBuffer::create(size, RenderingMode::Unaccelerated);</span>
      if (!temp)
          return nullptr;
      ASSERT(m_buffers.size() &gt; 0);
      i = std::min(m_buffers.size() - 1, i);
      m_buffers[i] = WTFMove(temp);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6295,33 +6404,33 @@</span>
          m_buffers[i].swap(m_buffers[i-1]);
  }
  
  namespace {
  
<span class="udiff-line-modified-removed">-     String GetErrorString(GC3Denum error)</span>
<span class="udiff-line-modified-added">+     String GetErrorString(GCGLenum error)</span>
      {
          switch (error) {
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::INVALID_ENUM:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::INVALID_ENUM:</span>
              return &quot;INVALID_ENUM&quot;_s;
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::INVALID_VALUE:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::INVALID_VALUE:</span>
              return &quot;INVALID_VALUE&quot;_s;
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::INVALID_OPERATION:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::INVALID_OPERATION:</span>
              return &quot;INVALID_OPERATION&quot;_s;
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::OUT_OF_MEMORY:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::OUT_OF_MEMORY:</span>
              return &quot;OUT_OF_MEMORY&quot;_s;
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::INVALID_FRAMEBUFFER_OPERATION:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::INVALID_FRAMEBUFFER_OPERATION:</span>
              return &quot;INVALID_FRAMEBUFFER_OPERATION&quot;_s;
<span class="udiff-line-modified-removed">-         case GraphicsContext3D::CONTEXT_LOST_WEBGL:</span>
<span class="udiff-line-modified-added">+         case GraphicsContextGL::CONTEXT_LOST_WEBGL:</span>
              return &quot;CONTEXT_LOST_WEBGL&quot;_s;
          default:
              return makeString(&quot;WebGL ERROR(&quot;, hex(error, 4, Lowercase), &#39;)&#39;);
          }
      }
  
  } // namespace anonymous
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::synthesizeGLError(GC3Denum error, const char* functionName, const char* description, ConsoleDisplayPreference display)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::synthesizeGLError(GCGLenum error, const char* functionName, const char* description, ConsoleDisplayPreference display)</span>
  {
      if (m_synthesizedErrorsToConsole &amp;&amp; display == DisplayInConsole) {
          String str = &quot;WebGL: &quot; + GetErrorString(error) +  &quot;: &quot; + String(functionName) + &quot;: &quot; + String(description);
          printToConsole(MessageLevel::Error, str);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6337,14 +6446,14 @@</span>
      else {
          auto attributes = getContextAttributes();
          ASSERT(attributes);
          haveStencilBuffer = attributes-&gt;stencil;
      }
<span class="udiff-line-modified-removed">-     enableOrDisable(GraphicsContext3D::STENCIL_TEST, m_stencilEnabled &amp;&amp; haveStencilBuffer);</span>
<span class="udiff-line-modified-added">+     enableOrDisable(GraphicsContextGL::STENCIL_TEST, m_stencilEnabled &amp;&amp; haveStencilBuffer);</span>
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::enableOrDisable(GC3Denum capability, bool enable)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::enableOrDisable(GCGLenum capability, bool enable)</span>
  {
      if (enable)
          m_context-&gt;enable(capability);
      else
          m_context-&gt;disable(capability);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6354,45 +6463,45 @@</span>
  {
      return IntSize(clamp(canvasBase().width(), 1, m_maxViewportDims[0]),
          clamp(canvasBase().height(), 1, m_maxViewportDims[1]));
  }
  
<span class="udiff-line-modified-removed">- GC3Dint WebGLRenderingContextBase::getMaxDrawBuffers()</span>
<span class="udiff-line-modified-added">+ GCGLint WebGLRenderingContextBase::getMaxDrawBuffers()</span>
  {
      if (!supportsDrawBuffers())
          return 0;
      if (!m_maxDrawBuffers)
<span class="udiff-line-modified-removed">-         m_context-&gt;getIntegerv(Extensions3D::MAX_DRAW_BUFFERS_EXT, &amp;m_maxDrawBuffers);</span>
<span class="udiff-line-modified-added">+         m_context-&gt;getIntegerv(ExtensionsGL::MAX_DRAW_BUFFERS_EXT, &amp;m_maxDrawBuffers);</span>
      if (!m_maxColorAttachments)
<span class="udiff-line-modified-removed">-         m_context-&gt;getIntegerv(Extensions3D::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);</span>
<span class="udiff-line-modified-added">+         m_context-&gt;getIntegerv(ExtensionsGL::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);</span>
      // WEBGL_draw_buffers requires MAX_COLOR_ATTACHMENTS &gt;= MAX_DRAW_BUFFERS.
      return std::min(m_maxDrawBuffers, m_maxColorAttachments);
  }
  
<span class="udiff-line-modified-removed">- GC3Dint WebGLRenderingContextBase::getMaxColorAttachments()</span>
<span class="udiff-line-modified-added">+ GCGLint WebGLRenderingContextBase::getMaxColorAttachments()</span>
  {
      if (!supportsDrawBuffers())
          return 0;
      if (!m_maxColorAttachments)
<span class="udiff-line-modified-removed">-         m_context-&gt;getIntegerv(Extensions3D::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);</span>
<span class="udiff-line-modified-added">+         m_context-&gt;getIntegerv(ExtensionsGL::MAX_COLOR_ATTACHMENTS_EXT, &amp;m_maxColorAttachments);</span>
      return m_maxColorAttachments;
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::setBackDrawBuffer(GC3Denum buf)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::setBackDrawBuffer(GCGLenum buf)</span>
  {
      m_backDrawBuffer = buf;
  }
  
  void WebGLRenderingContextBase::restoreCurrentFramebuffer()
  {
<span class="udiff-line-modified-removed">-     bindFramebuffer(GraphicsContext3D::FRAMEBUFFER, m_framebufferBinding.get());</span>
<span class="udiff-line-modified-added">+     bindFramebuffer(GraphicsContextGL::FRAMEBUFFER, m_framebufferBinding.get());</span>
  }
  
  void WebGLRenderingContextBase::restoreCurrentTexture2D()
  {
      auto texture = m_textureUnits[m_activeTextureUnit].texture2DBinding.get();
<span class="udiff-line-modified-removed">-     bindTexture(GraphicsContext3D::TEXTURE_2D, texture);</span>
<span class="udiff-line-modified-added">+     bindTexture(GraphicsContextGL::TEXTURE_2D, texture);</span>
      if (texture &amp;&amp; texture-&gt;needToUseBlackTexture(textureExtensionFlags()))
          m_unrenderableTextureUnits.add(m_activeTextureUnit);
  }
  
  bool WebGLRenderingContextBase::supportsDrawBuffers()
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6402,11 +6511,11 @@</span>
          m_drawBuffersSupported = WebGLDrawBuffers::supported(*this);
      }
      return m_drawBuffersSupported;
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::drawArraysInstanced(GC3Denum mode, GC3Dint first, GC3Dsizei count, GC3Dsizei primcount)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::drawArraysInstanced(GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei primcount)</span>
  {
      if (!primcount) {
          markContextChanged();
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6419,11 +6528,11 @@</span>
      bool vertexAttrib0Simulated = false;
      if (!isGLES2Compliant()) {
          auto simulateVertexAttrib0Status = simulateVertexAttrib0(first + count - 1);
          if (!simulateVertexAttrib0Status) {
              // We were unable to simulate the attribute buffer.
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawArraysInstanced&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawArraysInstanced&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);</span>
              return;
          }
          vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
      }
      if (!isGLES2NPOTStrict())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6436,11 +6545,11 @@</span>
      if (!isGLES2NPOTStrict())
          checkTextureCompleteness(&quot;drawArraysInstanced&quot;, false);
      markContextChangedAndNotifyCanvasObserver();
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::drawElementsInstanced(GC3Denum mode, GC3Dsizei count, GC3Denum type, long long offset, GC3Dsizei primcount)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::drawElementsInstanced(GCGLenum mode, GCGLsizei count, GCGLenum type, long long offset, GCGLsizei primcount)</span>
  {
      if (!primcount) {
          markContextChanged();
          return;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6452,15 +6561,15 @@</span>
      clearIfComposited();
  
      bool vertexAttrib0Simulated = false;
      if (!isGLES2Compliant()) {
          if (!numElements)
<span class="udiff-line-modified-removed">-             validateIndexArrayPrecise(count, type, static_cast&lt;GC3Dintptr&gt;(offset), numElements);</span>
<span class="udiff-line-modified-added">+             validateIndexArrayPrecise(count, type, static_cast&lt;GCGLintptr&gt;(offset), numElements);</span>
          auto simulateVertexAttrib0Status = simulateVertexAttrib0(numElements);
          if (!simulateVertexAttrib0Status) {
              // We were unable to simulate the attribute buffer.
<span class="udiff-line-modified-removed">-             synthesizeGLError(GraphicsContext3D::INVALID_OPERATION, &quot;drawArraysInstanced&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);</span>
<span class="udiff-line-modified-added">+             synthesizeGLError(GraphicsContextGL::INVALID_OPERATION, &quot;drawArraysInstanced&quot;, &quot;unable to simulate vertexAttrib0 array&quot;);</span>
              return;
          }
          vertexAttrib0Simulated = simulateVertexAttrib0Status.value();
      }
      if (!isGLES2NPOTStrict())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6469,26 +6578,26 @@</span>
  #if USE(OPENGL) &amp;&amp; ENABLE(WEBGL2)
      if (isWebGL2())
          m_context-&gt;primitiveRestartIndex(getRestartIndex(type));
  #endif
  
<span class="udiff-line-modified-removed">-     m_context-&gt;drawElementsInstanced(mode, count, type, static_cast&lt;GC3Dintptr&gt;(offset), primcount);</span>
<span class="udiff-line-modified-added">+     m_context-&gt;drawElementsInstanced(mode, count, type, static_cast&lt;GCGLintptr&gt;(offset), primcount);</span>
  
      if (!isGLES2Compliant() &amp;&amp; vertexAttrib0Simulated)
          restoreStatesAfterVertexAttrib0Simulation();
      if (!isGLES2NPOTStrict())
          checkTextureCompleteness(&quot;drawElementsInstanced&quot;, false);
      markContextChangedAndNotifyCanvasObserver();
  }
  
<span class="udiff-line-modified-removed">- void WebGLRenderingContextBase::vertexAttribDivisor(GC3Duint index, GC3Duint divisor)</span>
<span class="udiff-line-modified-added">+ void WebGLRenderingContextBase::vertexAttribDivisor(GCGLuint index, GCGLuint divisor)</span>
  {
      if (isContextLostOrPending())
          return;
  
      if (index &gt;= m_maxVertexAttribs) {
<span class="udiff-line-modified-removed">-         synthesizeGLError(GraphicsContext3D::INVALID_VALUE, &quot;vertexAttribDivisor&quot;, &quot;index out of range&quot;);</span>
<span class="udiff-line-modified-added">+         synthesizeGLError(GraphicsContextGL::INVALID_VALUE, &quot;vertexAttribDivisor&quot;, &quot;index out of range&quot;);</span>
          return;
      }
  
      m_boundVertexArrayObject-&gt;setVertexAttribDivisor(index, divisor);
      m_context-&gt;vertexAttribDivisor(index, divisor);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -6538,15 +6647,22 @@</span>
  {
      printToConsole(MessageLevel::Error, &quot;There are too many active WebGL contexts on this page, the oldest context will be lost.&quot;);
      // Using SyntheticLostContext means the developer won&#39;t be able to force the restoration
      // of the context by calling preventDefault() in a &quot;webglcontextlost&quot; event handler.
      forceLostContext(SyntheticLostContext);
<span class="udiff-line-modified-removed">-     destroyGraphicsContext3D();</span>
<span class="udiff-line-modified-added">+     destroyGraphicsContextGL();</span>
  }
  
  void WebGLRenderingContextBase::dispatchContextChangedNotification()
  {
<span class="udiff-line-added">+     if (!m_dispatchContextChangedEventTimer.isActive())</span>
<span class="udiff-line-added">+         m_dispatchContextChangedEventTimer.startOneShot(0_s);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void WebGLRenderingContextBase::dispatchContextChangedEvent()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     RELEASE_ASSERT(!m_isSuspended);</span>
      auto* canvas = htmlCanvas();
      if (!canvas)
          return;
  
      canvas-&gt;dispatchEvent(WebGLContextEvent::create(eventNames().webglcontextchangedEvent, Event::CanBubble::No, Event::IsCancelable::Yes, emptyString()));
</pre>
<center><a href="WebGLRenderingContext.idl.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLRenderingContextBase.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
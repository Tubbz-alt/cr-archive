<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineTextBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InlineFlowBox.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InlineTextBox.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineTextBox.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public License
  17  * along with this library; see the file COPYING.LIB.  If not, write to
  18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;InlineTextBox.h&quot;
  25 
  26 #include &quot;BreakLines.h&quot;

  27 #include &quot;DashArray.h&quot;
  28 #include &quot;Document.h&quot;
  29 #include &quot;DocumentMarkerController.h&quot;
  30 #include &quot;Editor.h&quot;

  31 #include &quot;EllipsisBox.h&quot;
  32 #include &quot;EventRegion.h&quot;

  33 #include &quot;Frame.h&quot;
  34 #include &quot;GraphicsContext.h&quot;

  35 #include &quot;HitTestResult.h&quot;
  36 #include &quot;ImageBuffer.h&quot;
  37 #include &quot;InlineTextBoxStyle.h&quot;
  38 #include &quot;MarkedText.h&quot;
  39 #include &quot;Page.h&quot;
  40 #include &quot;PaintInfo.h&quot;
  41 #include &quot;RenderBlock.h&quot;
  42 #include &quot;RenderCombineText.h&quot;
  43 #include &quot;RenderLineBreak.h&quot;
  44 #include &quot;RenderRubyRun.h&quot;
  45 #include &quot;RenderRubyText.h&quot;
  46 #include &quot;RenderTheme.h&quot;
  47 #include &quot;RenderView.h&quot;
  48 #include &quot;RenderedDocumentMarker.h&quot;


  49 #include &quot;Text.h&quot;
  50 #include &quot;TextDecorationPainter.h&quot;
  51 #include &quot;TextPaintStyle.h&quot;
  52 #include &quot;TextPainter.h&quot;
  53 #include &lt;stdio.h&gt;
  54 #include &lt;wtf/IsoMallocInlines.h&gt;
  55 #include &lt;wtf/text/CString.h&gt;
  56 #include &lt;wtf/text/TextStream.h&gt;
  57 
  58 namespace WebCore {
  59 
  60 WTF_MAKE_ISO_ALLOCATED_IMPL(InlineTextBox);
  61 
  62 struct SameSizeAsInlineTextBox : public InlineBox {
  63     unsigned variables[1];
  64     unsigned short variables2[2];
  65     void* pointers[2];
  66 };
  67 
  68 COMPILE_ASSERT(sizeof(InlineTextBox) == sizeof(SameSizeAsInlineTextBox), InlineTextBox_should_stay_small);
</pre>
<hr />
<pre>
 135     return root().selectionTop();
 136 }
 137 
 138 LayoutUnit InlineTextBox::selectionBottom() const
 139 {
 140     return root().selectionBottom();
 141 }
 142 
 143 LayoutUnit InlineTextBox::selectionHeight() const
 144 {
 145     return root().selectionHeight();
 146 }
 147 
 148 bool InlineTextBox::isSelected(unsigned startPosition, unsigned endPosition) const
 149 {
 150     return clampedOffset(startPosition) &lt; clampedOffset(endPosition);
 151 }
 152 
 153 RenderObject::SelectionState InlineTextBox::selectionState()
 154 {
<span class="line-modified"> 155     RenderObject::SelectionState state = renderer().selectionState();</span>
<span class="line-removed"> 156     if (state == RenderObject::SelectionStart || state == RenderObject::SelectionEnd || state == RenderObject::SelectionBoth) {</span>
<span class="line-removed"> 157         auto&amp; selection = renderer().view().selection();</span>
<span class="line-removed"> 158         auto startPos = selection.startPosition();</span>
<span class="line-removed"> 159         auto endPos = selection.endPosition();</span>
<span class="line-removed"> 160         // The position after a hard line break is considered to be past its end.</span>
<span class="line-removed"> 161         ASSERT(start() + len() &gt;= (isLineBreak() ? 1 : 0));</span>
<span class="line-removed"> 162         unsigned lastSelectable = start() + len() - (isLineBreak() ? 1 : 0);</span>
<span class="line-removed"> 163 </span>
<span class="line-removed"> 164         bool start = (state != RenderObject::SelectionEnd &amp;&amp; startPos &gt;= m_start &amp;&amp; startPos &lt; m_start + m_len);</span>
<span class="line-removed"> 165         bool end = (state != RenderObject::SelectionStart &amp;&amp; endPos &gt; m_start &amp;&amp; endPos &lt;= lastSelectable);</span>
<span class="line-removed"> 166         if (start &amp;&amp; end)</span>
<span class="line-removed"> 167             state = RenderObject::SelectionBoth;</span>
<span class="line-removed"> 168         else if (start)</span>
<span class="line-removed"> 169             state = RenderObject::SelectionStart;</span>
<span class="line-removed"> 170         else if (end)</span>
<span class="line-removed"> 171             state = RenderObject::SelectionEnd;</span>
<span class="line-removed"> 172         else if ((state == RenderObject::SelectionEnd || startPos &lt; m_start) &amp;&amp;</span>
<span class="line-removed"> 173                  (state == RenderObject::SelectionStart || endPos &gt; lastSelectable))</span>
<span class="line-removed"> 174             state = RenderObject::SelectionInside;</span>
<span class="line-removed"> 175         else if (state == RenderObject::SelectionBoth)</span>
<span class="line-removed"> 176             state = RenderObject::SelectionNone;</span>
<span class="line-removed"> 177     }</span>
 178 




 179     // If there are ellipsis following, make sure their selection is updated.
 180     if (m_truncation != cNoTruncation &amp;&amp; root().ellipsisBox()) {
 181         EllipsisBox* ellipsis = root().ellipsisBox();
 182         if (state != RenderObject::SelectionNone) {
 183             auto [selectionStart, selectionEnd] = selectionStartEnd();
 184             // The ellipsis should be considered to be selected if the end of
 185             // the selection is past the beginning of the truncation and the
 186             // beginning of the selection is before or at the beginning of the
 187             // truncation.
 188             ellipsis-&gt;setSelectionState(selectionEnd &gt;= m_truncation &amp;&amp; selectionStart &lt;= m_truncation ?
 189                 RenderObject::SelectionInside : RenderObject::SelectionNone);
 190         } else
 191             ellipsis-&gt;setSelectionState(RenderObject::SelectionNone);
 192     }
 193 
 194     return state;
 195 }
 196 



























 197 inline const FontCascade&amp; InlineTextBox::lineFont() const
 198 {
 199     return combinedText() ? combinedText()-&gt;textCombineFont() : lineStyle().fontCascade();
 200 }
 201 
























 202 // FIXME: Share more code with paintMarkedTextBackground().
 203 LayoutRect InlineTextBox::localSelectionRect(unsigned startPos, unsigned endPos) const
 204 {
 205     unsigned sPos = clampedOffset(startPos);
 206     unsigned ePos = clampedOffset(endPos);
 207 
 208     if (sPos &gt;= ePos &amp;&amp; !(startPos == endPos &amp;&amp; startPos &gt;= start() &amp;&amp; startPos &lt;= (start() + len())))
 209         return { };
 210 
 211     LayoutUnit selectionTop = this-&gt;selectionTop();
 212     LayoutUnit selectionHeight = this-&gt;selectionHeight();
 213 
 214     TextRun textRun = createTextRun();
 215 
 216     LayoutRect selectionRect { LayoutUnit(logicalLeft()), selectionTop, LayoutUnit(logicalWidth()), selectionHeight };
 217     // Avoid measuring the text when the entire line box is selected as an optimization.
 218     if (sPos || ePos != textRun.length())
 219         lineFont().adjustSelectionRectForText(textRun, selectionRect, sPos, ePos);
 220     // FIXME: The computation of the snapped selection rect differs from the computation of this rect
 221     // in paintMarkedTextBackground(). See &lt;https://bugs.webkit.org/show_bug.cgi?id=138913&gt;.
<span class="line-modified"> 222     IntRect snappedSelectionRect = enclosingIntRect(selectionRect);</span>
<span class="line-removed"> 223     LayoutUnit logicalWidth = snappedSelectionRect.width();</span>
<span class="line-removed"> 224     if (snappedSelectionRect.x() &gt; logicalRight())</span>
<span class="line-removed"> 225         logicalWidth  = 0;</span>
<span class="line-removed"> 226     else if (snappedSelectionRect.maxX() &gt; logicalRight())</span>
<span class="line-removed"> 227         logicalWidth = logicalRight() - snappedSelectionRect.x();</span>
<span class="line-removed"> 228 </span>
<span class="line-removed"> 229     LayoutPoint topPoint = isHorizontal() ? LayoutPoint(snappedSelectionRect.x(), selectionTop) : LayoutPoint(selectionTop, snappedSelectionRect.x());</span>
<span class="line-removed"> 230     LayoutUnit width = isHorizontal() ? logicalWidth : selectionHeight;</span>
<span class="line-removed"> 231     LayoutUnit height = isHorizontal() ? selectionHeight : logicalWidth;</span>
<span class="line-removed"> 232 </span>
<span class="line-removed"> 233     return LayoutRect(topPoint, LayoutSize(width, height));</span>
 234 }
 235 
 236 void InlineTextBox::deleteLine()
 237 {
 238     renderer().removeTextBox(*this);
 239     delete this;
 240 }
 241 
 242 void InlineTextBox::extractLine()
 243 {
 244     if (extracted())
 245         return;
 246 
 247     renderer().extractTextBox(*this);
 248 }
 249 
 250 void InlineTextBox::attachLine()
 251 {
 252     if (!extracted())
 253         return;
</pre>
<hr />
<pre>
 507 
 508     auto* combinedText = this-&gt;combinedText();
 509 
 510     bool shouldRotate = !isHorizontal() &amp;&amp; !combinedText;
 511     if (shouldRotate)
 512         context.concatCTM(rotation(boxRect, Clockwise));
 513 
 514     // Determine whether or not we have composition underlines to draw.
 515     bool containsComposition = renderer().textNode() &amp;&amp; renderer().frame().editor().compositionNode() == renderer().textNode();
 516     bool useCustomUnderlines = containsComposition &amp;&amp; renderer().frame().editor().compositionUsesCustomUnderlines();
 517 
 518     MarkedTextStyle unmarkedStyle = computeStyleForUnmarkedMarkedText(paintInfo);
 519 
 520     // 1. Paint backgrounds behind text if needed. Examples of such backgrounds include selection
 521     // and composition underlines.
 522     if (paintInfo.phase != PaintPhase::Selection &amp;&amp; paintInfo.phase != PaintPhase::TextClip &amp;&amp; !isPrinting) {
 523         if (containsComposition &amp;&amp; !useCustomUnderlines)
 524             paintCompositionBackground(paintInfo, boxOrigin);
 525 
 526         Vector&lt;MarkedText&gt; markedTexts = collectMarkedTextsForDocumentMarkers(TextPaintPhase::Background);



 527 #if ENABLE(TEXT_SELECTION)
 528         if (haveSelection &amp;&amp; !useCustomUnderlines &amp;&amp; !context.paintingDisabled()) {
 529             auto selectionMarkedText = createMarkedTextFromSelectionInBox(*this);
 530             if (!selectionMarkedText.isEmpty())
 531                 markedTexts.append(WTFMove(selectionMarkedText));
 532         }
 533 #endif
 534         auto styledMarkedTexts = subdivideAndResolveStyle(markedTexts, unmarkedStyle, paintInfo);
 535 
 536         // Coalesce styles of adjacent marked texts to minimize the number of drawing commands.
 537         auto coalescedStyledMarkedTexts = coalesceAdjacentMarkedTexts(styledMarkedTexts, &amp;MarkedTextStyle::areBackgroundMarkedTextStylesEqual);
 538 
 539         paintMarkedTexts(paintInfo, TextPaintPhase::Background, boxRect, coalescedStyledMarkedTexts);
 540     }
 541 
 542     // FIXME: Right now, InlineTextBoxes never call addRelevantUnpaintedObject() even though they might
 543     // legitimately be unpainted if they are waiting on a slow-loading web font. We should fix that, and
 544     // when we do, we will have to account for the fact the InlineTextBoxes do not always have unique
 545     // renderers and Page currently relies on each unpainted object having a unique renderer.
 546     if (paintInfo.phase == PaintPhase::Foreground)
 547         renderer().page().addRelevantRepaintedObject(&amp;renderer(), IntRect(boxOrigin.x(), boxOrigin.y(), logicalWidth(), logicalHeight()));
 548 
 549     if (paintInfo.phase == PaintPhase::Foreground)
 550         paintPlatformDocumentMarkers(context, boxOrigin);
 551 
 552     // 2. Now paint the foreground, including text and decorations like underline/overline (in quirks mode only).
 553     bool shouldPaintSelectionForeground = haveSelection &amp;&amp; !useCustomUnderlines;
 554     Vector&lt;MarkedText&gt; markedTexts;
 555     if (paintInfo.phase != PaintPhase::Selection) {
 556         // The marked texts for the gaps between document markers and selection are implicitly created by subdividing the entire line.
<span class="line-modified"> 557         markedTexts.append({ clampedOffset(m_start), clampedOffset(end() + 1), MarkedText::Unmarked });</span>
 558         if (!isPrinting) {
 559             markedTexts.appendVector(collectMarkedTextsForDocumentMarkers(TextPaintPhase::Foreground));



 560 
 561             bool shouldPaintDraggedContent = !(paintInfo.paintBehavior.contains(PaintBehavior::ExcludeSelection));
 562             if (shouldPaintDraggedContent) {
 563                 auto markedTextsForDraggedContent = collectMarkedTextsForDraggedContent();
 564                 if (!markedTextsForDraggedContent.isEmpty()) {
 565                     shouldPaintSelectionForeground = false;
 566                     markedTexts.appendVector(markedTextsForDraggedContent);
 567                 }
 568             }
 569         }
 570     }
 571     // The selection marked text acts as a placeholder when computing the marked texts for the gaps...
 572     if (shouldPaintSelectionForeground) {
 573         ASSERT(!isPrinting);
 574         auto selectionMarkedText = createMarkedTextFromSelectionInBox(*this);
 575         if (!selectionMarkedText.isEmpty())
 576             markedTexts.append(WTFMove(selectionMarkedText));
 577     }
 578 
 579     auto styledMarkedTexts = subdivideAndResolveStyle(markedTexts, unmarkedStyle, paintInfo);
</pre>
<hr />
<pre>
 635 
 636 unsigned InlineTextBox::clampedOffset(unsigned x) const
 637 {
 638     unsigned offset = std::max(std::min(x, m_start + m_len), m_start) - m_start;
 639     if (m_truncation == cFullTruncation)
 640         return offset;
 641     if (m_truncation != cNoTruncation)
 642         offset = std::min&lt;unsigned&gt;(offset, m_truncation);
 643     else if (offset == m_len) {
 644         // Fix up the offset if we are combined text or have a hyphen because we manage these embellishments.
 645         // That is, they are not reflected in renderer().text(). We treat combined text as a single unit.
 646         // We also treat the last codepoint in this box and the hyphen as a single unit.
 647         if (auto* combinedText = this-&gt;combinedText())
 648             offset = combinedText-&gt;combinedStringForRendering().length();
 649         else if (hasHyphen())
 650             offset += lineStyle().hyphenString().length();
 651     }
 652     return offset;
 653 }
 654 
<span class="line-modified"> 655 std::pair&lt;unsigned, unsigned&gt; InlineTextBox::selectionStartEnd() const</span>
 656 {
<span class="line-removed"> 657     auto selectionState = renderer().selectionState();</span>
 658     if (selectionState == RenderObject::SelectionInside)
 659         return { 0, clampedOffset(m_start + m_len) };
 660 
<span class="line-removed"> 661     auto start = renderer().view().selection().startPosition();</span>
<span class="line-removed"> 662     auto end = renderer().view().selection().endPosition();</span>
 663     if (selectionState == RenderObject::SelectionStart)
 664         end = renderer().text().length();
 665     else if (selectionState == RenderObject::SelectionEnd)
 666         start = 0;
 667     return { clampedOffset(start), clampedOffset(end) };
 668 }
 669 


















 670 bool InlineTextBox::hasMarkers() const
 671 {
 672     return collectMarkedTextsForDocumentMarkers(TextPaintPhase::Decoration).size();
 673 }
 674 
 675 void InlineTextBox::paintPlatformDocumentMarkers(GraphicsContext&amp; context, const FloatPoint&amp; boxOrigin)
 676 {
 677     // This must match calculateUnionOfAllDocumentMarkerBounds().
 678     for (auto&amp; markedText : subdivide(collectMarkedTextsForDocumentMarkers(TextPaintPhase::Decoration), OverlapStrategy::Frontmost))
 679         paintPlatformDocumentMarker(context, boxOrigin, markedText);
 680 }
 681 
 682 FloatRect InlineTextBox::calculateUnionOfAllDocumentMarkerBounds() const
 683 {
 684     // This must match paintPlatformDocumentMarkers().
 685     FloatRect result;
 686     for (auto&amp; markedText : subdivide(collectMarkedTextsForDocumentMarkers(TextPaintPhase::Decoration), OverlapStrategy::Frontmost))
 687         result = unionRect(result, calculateDocumentMarkerBounds(markedText));
 688     return result;
 689 }
 690 
 691 FloatRect InlineTextBox::calculateDocumentMarkerBounds(const MarkedText&amp; markedText) const
 692 {
 693     auto&amp; font = lineFont();
 694     auto ascent = font.fontMetrics().ascent();
 695     auto fontSize = std::min(std::max(font.size(), 10.0f), 40.0f);
 696     auto y = ascent + 0.11035 * fontSize;
 697     auto height = 0.13247 * fontSize;
 698 
 699     // Avoid measuring the text when the entire line box is selected as an optimization.
<span class="line-modified"> 700     if (markedText.startOffset || markedText.endOffset != clampedOffset(end() + 1)) {</span>
 701         TextRun run = createTextRun();
 702         LayoutRect selectionRect = LayoutRect(0, y, 0, height);
 703         lineFont().adjustSelectionRectForText(run, selectionRect, markedText.startOffset, markedText.endOffset);
 704         return selectionRect;
 705     }
 706 
 707     return FloatRect(0, y, logicalWidth(), height);
 708 }
 709 
 710 void InlineTextBox::paintPlatformDocumentMarker(GraphicsContext&amp; context, const FloatPoint&amp; boxOrigin, const MarkedText&amp; markedText)
 711 {
 712     // Never print spelling/grammar markers (5327887)
 713     if (renderer().document().printing())
 714         return;
 715 
 716     if (m_truncation == cFullTruncation)
 717         return;
 718 
 719     auto bounds = calculateDocumentMarkerBounds(markedText);
 720 
</pre>
<hr />
<pre>
 753     style.textStyles = computeTextPaintStyle(renderer().frame(), lineStyle, paintInfo);
 754     style.textShadow = ShadowData::clone(paintInfo.forceTextColor() ? nullptr : lineStyle.textShadow());
 755     style.alpha = 1;
 756     return style;
 757 }
 758 
 759 auto InlineTextBox::resolveStyleForMarkedText(const MarkedText&amp; markedText, const MarkedTextStyle&amp; baseStyle, const PaintInfo&amp; paintInfo) -&gt; StyledMarkedText
 760 {
 761     MarkedTextStyle style = baseStyle;
 762     switch (markedText.type) {
 763     case MarkedText::Correction:
 764     case MarkedText::DictationAlternatives:
 765 #if PLATFORM(IOS_FAMILY)
 766     // FIXME: See &lt;rdar://problem/8933352&gt;. Also, remove the PLATFORM(IOS_FAMILY)-guard.
 767     case MarkedText::DictationPhraseWithAlternatives:
 768 #endif
 769     case MarkedText::GrammarError:
 770     case MarkedText::SpellingError:
 771     case MarkedText::Unmarked:
 772         break;
















 773     case MarkedText::DraggedContent:
 774         style.alpha = 0.25;
 775         break;
 776     case MarkedText::Selection: {
 777         style.textStyles = computeTextSelectionPaintStyle(style.textStyles, renderer(), lineStyle(), paintInfo, style.textShadow);
 778 
 779         Color selectionBackgroundColor = renderer().selectionBackgroundColor();
 780         style.backgroundColor = selectionBackgroundColor;
 781         if (selectionBackgroundColor.isValid() &amp;&amp; selectionBackgroundColor.alpha() &amp;&amp; style.textStyles.fillColor == selectionBackgroundColor)
 782             style.backgroundColor = { 0xff - selectionBackgroundColor.red(), 0xff - selectionBackgroundColor.green(), 0xff - selectionBackgroundColor.blue() };
 783         break;
 784     }
 785     case MarkedText::TextMatch: {
 786         // Text matches always use the light system appearance.
 787         OptionSet&lt;StyleColor::Options&gt; styleColorOptions = { StyleColor::Options::UseSystemAppearance };
 788 #if PLATFORM(MAC)
 789         style.textStyles.fillColor = renderer().theme().systemColor(CSSValueAppleSystemLabel, styleColorOptions);
 790 #endif
 791         style.backgroundColor = markedText.marker-&gt;isActiveMatch() ? renderer().theme().activeTextSearchHighlightColor(styleColorOptions) : renderer().theme().inactiveTextSearchHighlightColor(styleColorOptions);
 792         break;
</pre>
<hr />
<pre>
 915                 continue;
 916             break;
 917 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
 918         case DocumentMarker::TelephoneNumber:
 919             if (!renderer().frame().editor().markedTextMatchesAreHighlighted())
 920                 continue;
 921             if (phase != TextPaintPhase::Background)
 922                 continue;
 923             break;
 924 #endif
 925         default:
 926             continue;
 927         }
 928 
 929         if (marker-&gt;endOffset() &lt;= start()) {
 930             // Marker is completely before this run. This might be a marker that sits before the
 931             // first run we draw, or markers that were within runs we skipped due to truncation.
 932             continue;
 933         }
 934 
<span class="line-modified"> 935         if (marker-&gt;startOffset() &gt; end()) {</span>
 936             // Marker is completely after this run, bail. A later run will paint it.
 937             break;
 938         }
 939 
 940         // Marker intersects this run. Collect it.
 941         switch (marker-&gt;type()) {
 942         case DocumentMarker::Spelling:
 943         case DocumentMarker::CorrectionIndicator:
 944         case DocumentMarker::DictationAlternatives:
 945         case DocumentMarker::Grammar:
 946 #if PLATFORM(IOS_FAMILY)
 947         // FIXME: See &lt;rdar://problem/8933352&gt;. Also, remove the PLATFORM(IOS_FAMILY)-guard.
 948         case DocumentMarker::DictationPhraseWithAlternatives:
 949 #endif
 950         case DocumentMarker::TextMatch:
 951             markedTexts.uncheckedAppend({ clampedOffset(marker-&gt;startOffset()), clampedOffset(marker-&gt;endOffset()), markedTextTypeForMarkerType(marker-&gt;type()), marker });
 952             break;
 953         case DocumentMarker::Replacement:
 954             break;
 955 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
 956         case DocumentMarker::TelephoneNumber:
 957             break;
 958 #endif
 959         default:
 960             ASSERT_NOT_REACHED();
 961         }
 962     }
 963     return markedTexts;
 964 }
 965 







































 966 FloatPoint InlineTextBox::textOriginFromBoxRect(const FloatRect&amp; boxRect) const
 967 {
 968     FloatPoint textOrigin { boxRect.x(), boxRect.y() + lineFont().fontMetrics().ascent() };
 969     if (auto* combinedText = this-&gt;combinedText()) {
 970         if (auto newOrigin = combinedText-&gt;computeTextOrigin(boxRect))
 971             textOrigin = newOrigin.value();
 972     }
 973     if (isHorizontal())
 974         textOrigin.setY(roundToDevicePixel(LayoutUnit { textOrigin.y() }, renderer().document().deviceScaleFactor()));
 975     else
 976         textOrigin.setX(roundToDevicePixel(LayoutUnit { textOrigin.x() }, renderer().document().deviceScaleFactor()));
 977     return textOrigin;
 978 }
 979 
 980 void InlineTextBox::paintMarkedTexts(PaintInfo&amp; paintInfo, TextPaintPhase phase, const FloatRect&amp; boxRect, const Vector&lt;StyledMarkedText&gt;&amp; markedTexts, const FloatRect&amp; decorationClipOutRect)
 981 {
 982     switch (phase) {
 983     case TextPaintPhase::Background:
 984         for (auto&amp; markedText : markedTexts)
 985             paintMarkedTextBackground(paintInfo, boxRect.location(), markedText.style.backgroundColor, markedText.startOffset, markedText.endOffset);
</pre>
<hr />
<pre>
1105 
1106     {
1107         GraphicsContextStateSaver stateSaver { context, false };
1108         bool isDraggedContent = markedText.type == MarkedText::DraggedContent;
1109         if (isDraggedContent || !clipOutRect.isEmpty()) {
1110             stateSaver.save();
1111             if (isDraggedContent)
1112                 context.setAlpha(markedText.style.alpha);
1113             if (!clipOutRect.isEmpty())
1114                 context.clipOut(clipOutRect);
1115         }
1116         decorationPainter.paintTextDecoration(textRun.subRun(startOffset, endOffset - startOffset), textOriginFromBoxRect(snappedSelectionRect), snappedSelectionRect.location());
1117     }
1118 
1119     if (isCombinedText)
1120         context.concatCTM(rotation(boxRect, Counterclockwise));
1121 }
1122 
1123 void InlineTextBox::paintCompositionBackground(PaintInfo&amp; paintInfo, const FloatPoint&amp; boxOrigin)
1124 {
<span class="line-modified">1125     paintMarkedTextBackground(paintInfo, boxOrigin, Color::compositionFill, clampedOffset(renderer().frame().editor().compositionStart()), clampedOffset(renderer().frame().editor().compositionEnd()));</span>
















1126 }
1127 
1128 void InlineTextBox::paintCompositionUnderlines(PaintInfo&amp; paintInfo, const FloatPoint&amp; boxOrigin) const
1129 {
1130     if (m_truncation == cFullTruncation)
1131         return;
1132 
1133     for (auto&amp; underline : renderer().frame().editor().customCompositionUnderlines()) {
1134         if (underline.endOffset &lt;= m_start) {
1135             // Underline is completely before this run. This might be an underline that sits
1136             // before the first run we draw, or underlines that were within runs we skipped
1137             // due to truncation.
1138             continue;
1139         }
1140 
<span class="line-modified">1141         if (underline.startOffset &gt; end())</span>
1142             break; // Underline is completely after this run, bail. A later run will paint it.
1143 
1144         // Underline intersects this run. Paint it.
1145         paintCompositionUnderline(paintInfo, boxOrigin, underline);
1146 
<span class="line-modified">1147         if (underline.endOffset &gt; end() + 1)</span>
1148             break; // Underline also runs into the next run. Bail now, no more marker advancement.
1149     }
1150 }
1151 
1152 static inline void mirrorRTLSegment(float logicalWidth, TextDirection direction, float&amp; start, float width)
1153 {
1154     if (direction == TextDirection::LTR)
1155         return;
1156     start = logicalWidth - width - start;
1157 }
1158 
1159 void InlineTextBox::paintCompositionUnderline(PaintInfo&amp; paintInfo, const FloatPoint&amp; boxOrigin, const CompositionUnderline&amp; underline) const
1160 {
1161     if (m_truncation == cFullTruncation)
1162         return;
1163 
1164     float start = 0; // start of line to draw, relative to tx
1165     float width = logicalWidth(); // how much line to draw
1166     bool useWholeWidth = true;
1167     unsigned paintStart = m_start;
<span class="line-modified">1168     unsigned paintEnd = end() + 1; // end points at the last char, not past it</span>
1169     if (paintStart &lt;= underline.startOffset) {
1170         paintStart = underline.startOffset;
1171         useWholeWidth = false;
1172         start = renderer().width(m_start, paintStart - m_start, textPos(), isFirstLine());
1173     }
1174     if (paintEnd != underline.endOffset) {      // end points at the last char, not past it
1175         paintEnd = std::min(paintEnd, (unsigned)underline.endOffset);
1176         useWholeWidth = false;
1177     }
1178     if (m_truncation != cNoTruncation) {
1179         paintEnd = std::min(paintEnd, (unsigned)m_start + m_truncation);
1180         useWholeWidth = false;
1181     }
1182     if (!useWholeWidth) {
1183         width = renderer().width(paintStart, paintEnd - paintStart, textPos() + start, isFirstLine());
1184         mirrorRTLSegment(logicalWidth(), direction(), start, width);
1185     }
1186 
1187     // Thick marked text underlines are 2px thick as long as there is room for the 2px line under the baseline.
1188     // All other marked text underlines are 1px thick.
</pre>
<hr />
<pre>
1287 }
1288 
1289 inline const RenderCombineText* InlineTextBox::combinedText() const
1290 {
1291     return lineStyle().hasTextCombine() &amp;&amp; is&lt;RenderCombineText&gt;(renderer()) &amp;&amp; downcast&lt;RenderCombineText&gt;(renderer()).isCombined() ? &amp;downcast&lt;RenderCombineText&gt;(renderer()) : nullptr;
1292 }
1293 
1294 ExpansionBehavior InlineTextBox::expansionBehavior() const
1295 {
1296     ExpansionBehavior leadingBehavior;
1297     if (forceLeadingExpansion())
1298         leadingBehavior = ForceLeadingExpansion;
1299     else if (canHaveLeadingExpansion())
1300         leadingBehavior = AllowLeadingExpansion;
1301     else
1302         leadingBehavior = ForbidLeadingExpansion;
1303 
1304     ExpansionBehavior trailingBehavior;
1305     if (forceTrailingExpansion())
1306         trailingBehavior = ForceTrailingExpansion;
<span class="line-modified">1307     else if (expansion() &amp;&amp; nextLeafChild() &amp;&amp; !nextLeafChild()-&gt;isLineBreak())</span>
1308         trailingBehavior = AllowTrailingExpansion;
1309     else
1310         trailingBehavior = ForbidTrailingExpansion;
1311 
1312     return leadingBehavior | trailingBehavior;
1313 }
1314 
1315 #if ENABLE(TREE_DEBUGGING)
1316 
1317 const char* InlineTextBox::boxName() const
1318 {
1319     return &quot;InlineTextBox&quot;;
1320 }
1321 
1322 void InlineTextBox::outputLineBox(TextStream&amp; stream, bool mark, int depth) const
1323 {
1324     stream &lt;&lt; &quot;-------- &quot; &lt;&lt; (isDirty() ? &quot;D&quot; : &quot;-&quot;) &lt;&lt; &quot;-&quot;;
1325 
1326     int printedCharacters = 0;
1327     if (mark) {
</pre>
</td>
<td>
<hr />
<pre>
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public License
  17  * along with this library; see the file COPYING.LIB.  If not, write to
  18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 #include &quot;InlineTextBox.h&quot;
  25 
  26 #include &quot;BreakLines.h&quot;
<span class="line-added">  27 #include &quot;CompositionHighlight.h&quot;</span>
  28 #include &quot;DashArray.h&quot;
  29 #include &quot;Document.h&quot;
  30 #include &quot;DocumentMarkerController.h&quot;
  31 #include &quot;Editor.h&quot;
<span class="line-added">  32 #include &quot;ElementRuleCollector.h&quot;</span>
  33 #include &quot;EllipsisBox.h&quot;
  34 #include &quot;EventRegion.h&quot;
<span class="line-added">  35 #include &quot;FloatRoundedRect.h&quot;</span>
  36 #include &quot;Frame.h&quot;
  37 #include &quot;GraphicsContext.h&quot;
<span class="line-added">  38 #include &quot;HighlightMap.h&quot;</span>
  39 #include &quot;HitTestResult.h&quot;
  40 #include &quot;ImageBuffer.h&quot;
  41 #include &quot;InlineTextBoxStyle.h&quot;
  42 #include &quot;MarkedText.h&quot;
  43 #include &quot;Page.h&quot;
  44 #include &quot;PaintInfo.h&quot;
  45 #include &quot;RenderBlock.h&quot;
  46 #include &quot;RenderCombineText.h&quot;
  47 #include &quot;RenderLineBreak.h&quot;
  48 #include &quot;RenderRubyRun.h&quot;
  49 #include &quot;RenderRubyText.h&quot;
  50 #include &quot;RenderTheme.h&quot;
  51 #include &quot;RenderView.h&quot;
  52 #include &quot;RenderedDocumentMarker.h&quot;
<span class="line-added">  53 #include &quot;RuntimeEnabledFeatures.h&quot;</span>
<span class="line-added">  54 #include &quot;SelectionRangeData.h&quot;</span>
  55 #include &quot;Text.h&quot;
  56 #include &quot;TextDecorationPainter.h&quot;
  57 #include &quot;TextPaintStyle.h&quot;
  58 #include &quot;TextPainter.h&quot;
  59 #include &lt;stdio.h&gt;
  60 #include &lt;wtf/IsoMallocInlines.h&gt;
  61 #include &lt;wtf/text/CString.h&gt;
  62 #include &lt;wtf/text/TextStream.h&gt;
  63 
  64 namespace WebCore {
  65 
  66 WTF_MAKE_ISO_ALLOCATED_IMPL(InlineTextBox);
  67 
  68 struct SameSizeAsInlineTextBox : public InlineBox {
  69     unsigned variables[1];
  70     unsigned short variables2[2];
  71     void* pointers[2];
  72 };
  73 
  74 COMPILE_ASSERT(sizeof(InlineTextBox) == sizeof(SameSizeAsInlineTextBox), InlineTextBox_should_stay_small);
</pre>
<hr />
<pre>
 141     return root().selectionTop();
 142 }
 143 
 144 LayoutUnit InlineTextBox::selectionBottom() const
 145 {
 146     return root().selectionBottom();
 147 }
 148 
 149 LayoutUnit InlineTextBox::selectionHeight() const
 150 {
 151     return root().selectionHeight();
 152 }
 153 
 154 bool InlineTextBox::isSelected(unsigned startPosition, unsigned endPosition) const
 155 {
 156     return clampedOffset(startPosition) &lt; clampedOffset(endPosition);
 157 }
 158 
 159 RenderObject::SelectionState InlineTextBox::selectionState()
 160 {
<span class="line-modified"> 161     auto state = verifySelectionState(renderer().selectionState(), renderer().view().selection());</span>






















 162 
<span class="line-added"> 163     // FIXME: this code mutates selection state, but it&#39;s used at a simple getter elsewhere</span>
<span class="line-added"> 164     // in this file. This code should likely live in SelectionRangeData, or somewhere else.</span>
<span class="line-added"> 165     // &lt;rdar://problem/58125978&gt;</span>
<span class="line-added"> 166     // https://bugs.webkit.org/show_bug.cgi?id=205528</span>
 167     // If there are ellipsis following, make sure their selection is updated.
 168     if (m_truncation != cNoTruncation &amp;&amp; root().ellipsisBox()) {
 169         EllipsisBox* ellipsis = root().ellipsisBox();
 170         if (state != RenderObject::SelectionNone) {
 171             auto [selectionStart, selectionEnd] = selectionStartEnd();
 172             // The ellipsis should be considered to be selected if the end of
 173             // the selection is past the beginning of the truncation and the
 174             // beginning of the selection is before or at the beginning of the
 175             // truncation.
 176             ellipsis-&gt;setSelectionState(selectionEnd &gt;= m_truncation &amp;&amp; selectionStart &lt;= m_truncation ?
 177                 RenderObject::SelectionInside : RenderObject::SelectionNone);
 178         } else
 179             ellipsis-&gt;setSelectionState(RenderObject::SelectionNone);
 180     }
 181 
 182     return state;
 183 }
 184 
<span class="line-added"> 185 RenderObject::SelectionState InlineTextBox::verifySelectionState(RenderObject::SelectionState state, SelectionRangeData&amp; selection) const</span>
<span class="line-added"> 186 {</span>
<span class="line-added"> 187     if (state == RenderObject::SelectionStart || state == RenderObject::SelectionEnd || state == RenderObject::SelectionBoth) {</span>
<span class="line-added"> 188         auto startOffset = selection.startOffset();</span>
<span class="line-added"> 189         auto endOffset = selection.endOffset();</span>
<span class="line-added"> 190         // The position after a hard line break is considered to be past its end.</span>
<span class="line-added"> 191         ASSERT(start() + len() &gt;= (isLineBreak() ? 1 : 0));</span>
<span class="line-added"> 192         unsigned lastSelectable = start() + len() - (isLineBreak() ? 1 : 0);</span>
<span class="line-added"> 193 </span>
<span class="line-added"> 194         bool start = (state != RenderObject::SelectionEnd &amp;&amp; startOffset &gt;= m_start &amp;&amp; startOffset &lt; m_start + m_len);</span>
<span class="line-added"> 195         bool end = (state != RenderObject::SelectionStart &amp;&amp; endOffset &gt; m_start &amp;&amp; endOffset &lt;= lastSelectable);</span>
<span class="line-added"> 196         if (start &amp;&amp; end)</span>
<span class="line-added"> 197             state = RenderObject::SelectionBoth;</span>
<span class="line-added"> 198         else if (start)</span>
<span class="line-added"> 199             state = RenderObject::SelectionStart;</span>
<span class="line-added"> 200         else if (end)</span>
<span class="line-added"> 201             state = RenderObject::SelectionEnd;</span>
<span class="line-added"> 202         else if ((state == RenderObject::SelectionEnd || startOffset &lt; m_start)</span>
<span class="line-added"> 203             &amp;&amp; (state == RenderObject::SelectionStart || endOffset &gt; lastSelectable))</span>
<span class="line-added"> 204             state = RenderObject::SelectionInside;</span>
<span class="line-added"> 205         else if (state == RenderObject::SelectionBoth)</span>
<span class="line-added"> 206             state = RenderObject::SelectionNone;</span>
<span class="line-added"> 207     }</span>
<span class="line-added"> 208 </span>
<span class="line-added"> 209     return state;</span>
<span class="line-added"> 210 }</span>
<span class="line-added"> 211 </span>
 212 inline const FontCascade&amp; InlineTextBox::lineFont() const
 213 {
 214     return combinedText() ? combinedText()-&gt;textCombineFont() : lineStyle().fontCascade();
 215 }
 216 
<span class="line-added"> 217 LayoutRect snappedSelectionRect(const LayoutRect&amp; selectionRect, float logicalRight, float selectionTop, float selectionHeight, bool isHorizontal)</span>
<span class="line-added"> 218 {</span>
<span class="line-added"> 219     auto snappedSelectionRect = enclosingIntRect(selectionRect);</span>
<span class="line-added"> 220     LayoutUnit logicalWidth = snappedSelectionRect.width();</span>
<span class="line-added"> 221     if (snappedSelectionRect.x() &gt; logicalRight)</span>
<span class="line-added"> 222         logicalWidth = 0;</span>
<span class="line-added"> 223     else if (snappedSelectionRect.maxX() &gt; logicalRight)</span>
<span class="line-added"> 224         logicalWidth = logicalRight - snappedSelectionRect.x();</span>
<span class="line-added"> 225 </span>
<span class="line-added"> 226     LayoutPoint topPoint;</span>
<span class="line-added"> 227     LayoutUnit width;</span>
<span class="line-added"> 228     LayoutUnit height;</span>
<span class="line-added"> 229     if (isHorizontal) {</span>
<span class="line-added"> 230         topPoint = LayoutPoint { snappedSelectionRect.x(), selectionTop };</span>
<span class="line-added"> 231         width = logicalWidth;</span>
<span class="line-added"> 232         height = selectionHeight;</span>
<span class="line-added"> 233     } else {</span>
<span class="line-added"> 234         topPoint = LayoutPoint { selectionTop, snappedSelectionRect.x() };</span>
<span class="line-added"> 235         width = selectionHeight;</span>
<span class="line-added"> 236         height = logicalWidth;</span>
<span class="line-added"> 237     }</span>
<span class="line-added"> 238     return LayoutRect { topPoint, LayoutSize { width, height } };</span>
<span class="line-added"> 239 }</span>
<span class="line-added"> 240 </span>
 241 // FIXME: Share more code with paintMarkedTextBackground().
 242 LayoutRect InlineTextBox::localSelectionRect(unsigned startPos, unsigned endPos) const
 243 {
 244     unsigned sPos = clampedOffset(startPos);
 245     unsigned ePos = clampedOffset(endPos);
 246 
 247     if (sPos &gt;= ePos &amp;&amp; !(startPos == endPos &amp;&amp; startPos &gt;= start() &amp;&amp; startPos &lt;= (start() + len())))
 248         return { };
 249 
 250     LayoutUnit selectionTop = this-&gt;selectionTop();
 251     LayoutUnit selectionHeight = this-&gt;selectionHeight();
 252 
 253     TextRun textRun = createTextRun();
 254 
 255     LayoutRect selectionRect { LayoutUnit(logicalLeft()), selectionTop, LayoutUnit(logicalWidth()), selectionHeight };
 256     // Avoid measuring the text when the entire line box is selected as an optimization.
 257     if (sPos || ePos != textRun.length())
 258         lineFont().adjustSelectionRectForText(textRun, selectionRect, sPos, ePos);
 259     // FIXME: The computation of the snapped selection rect differs from the computation of this rect
 260     // in paintMarkedTextBackground(). See &lt;https://bugs.webkit.org/show_bug.cgi?id=138913&gt;.
<span class="line-modified"> 261     return snappedSelectionRect(selectionRect, logicalRight(), selectionTop, selectionHeight, isHorizontal());</span>











 262 }
 263 
 264 void InlineTextBox::deleteLine()
 265 {
 266     renderer().removeTextBox(*this);
 267     delete this;
 268 }
 269 
 270 void InlineTextBox::extractLine()
 271 {
 272     if (extracted())
 273         return;
 274 
 275     renderer().extractTextBox(*this);
 276 }
 277 
 278 void InlineTextBox::attachLine()
 279 {
 280     if (!extracted())
 281         return;
</pre>
<hr />
<pre>
 535 
 536     auto* combinedText = this-&gt;combinedText();
 537 
 538     bool shouldRotate = !isHorizontal() &amp;&amp; !combinedText;
 539     if (shouldRotate)
 540         context.concatCTM(rotation(boxRect, Clockwise));
 541 
 542     // Determine whether or not we have composition underlines to draw.
 543     bool containsComposition = renderer().textNode() &amp;&amp; renderer().frame().editor().compositionNode() == renderer().textNode();
 544     bool useCustomUnderlines = containsComposition &amp;&amp; renderer().frame().editor().compositionUsesCustomUnderlines();
 545 
 546     MarkedTextStyle unmarkedStyle = computeStyleForUnmarkedMarkedText(paintInfo);
 547 
 548     // 1. Paint backgrounds behind text if needed. Examples of such backgrounds include selection
 549     // and composition underlines.
 550     if (paintInfo.phase != PaintPhase::Selection &amp;&amp; paintInfo.phase != PaintPhase::TextClip &amp;&amp; !isPrinting) {
 551         if (containsComposition &amp;&amp; !useCustomUnderlines)
 552             paintCompositionBackground(paintInfo, boxOrigin);
 553 
 554         Vector&lt;MarkedText&gt; markedTexts = collectMarkedTextsForDocumentMarkers(TextPaintPhase::Background);
<span class="line-added"> 555         auto highlightMarkedTexts = collectMarkedTextsForHighlights(TextPaintPhase::Background);</span>
<span class="line-added"> 556         if (!highlightMarkedTexts.isEmpty())</span>
<span class="line-added"> 557             markedTexts.appendVector(WTFMove(highlightMarkedTexts));</span>
 558 #if ENABLE(TEXT_SELECTION)
 559         if (haveSelection &amp;&amp; !useCustomUnderlines &amp;&amp; !context.paintingDisabled()) {
 560             auto selectionMarkedText = createMarkedTextFromSelectionInBox(*this);
 561             if (!selectionMarkedText.isEmpty())
 562                 markedTexts.append(WTFMove(selectionMarkedText));
 563         }
 564 #endif
 565         auto styledMarkedTexts = subdivideAndResolveStyle(markedTexts, unmarkedStyle, paintInfo);
 566 
 567         // Coalesce styles of adjacent marked texts to minimize the number of drawing commands.
 568         auto coalescedStyledMarkedTexts = coalesceAdjacentMarkedTexts(styledMarkedTexts, &amp;MarkedTextStyle::areBackgroundMarkedTextStylesEqual);
 569 
 570         paintMarkedTexts(paintInfo, TextPaintPhase::Background, boxRect, coalescedStyledMarkedTexts);
 571     }
 572 
 573     // FIXME: Right now, InlineTextBoxes never call addRelevantUnpaintedObject() even though they might
 574     // legitimately be unpainted if they are waiting on a slow-loading web font. We should fix that, and
 575     // when we do, we will have to account for the fact the InlineTextBoxes do not always have unique
 576     // renderers and Page currently relies on each unpainted object having a unique renderer.
 577     if (paintInfo.phase == PaintPhase::Foreground)
 578         renderer().page().addRelevantRepaintedObject(&amp;renderer(), IntRect(boxOrigin.x(), boxOrigin.y(), logicalWidth(), logicalHeight()));
 579 
 580     if (paintInfo.phase == PaintPhase::Foreground)
 581         paintPlatformDocumentMarkers(context, boxOrigin);
 582 
 583     // 2. Now paint the foreground, including text and decorations like underline/overline (in quirks mode only).
 584     bool shouldPaintSelectionForeground = haveSelection &amp;&amp; !useCustomUnderlines;
 585     Vector&lt;MarkedText&gt; markedTexts;
 586     if (paintInfo.phase != PaintPhase::Selection) {
 587         // The marked texts for the gaps between document markers and selection are implicitly created by subdividing the entire line.
<span class="line-modified"> 588         markedTexts.append({ clampedOffset(m_start), clampedOffset(end()), MarkedText::Unmarked });</span>
 589         if (!isPrinting) {
 590             markedTexts.appendVector(collectMarkedTextsForDocumentMarkers(TextPaintPhase::Foreground));
<span class="line-added"> 591             auto highlightMarkedTexts = collectMarkedTextsForHighlights(TextPaintPhase::Foreground);</span>
<span class="line-added"> 592             if (!highlightMarkedTexts.isEmpty())</span>
<span class="line-added"> 593                 markedTexts.appendVector(WTFMove(highlightMarkedTexts));</span>
 594 
 595             bool shouldPaintDraggedContent = !(paintInfo.paintBehavior.contains(PaintBehavior::ExcludeSelection));
 596             if (shouldPaintDraggedContent) {
 597                 auto markedTextsForDraggedContent = collectMarkedTextsForDraggedContent();
 598                 if (!markedTextsForDraggedContent.isEmpty()) {
 599                     shouldPaintSelectionForeground = false;
 600                     markedTexts.appendVector(markedTextsForDraggedContent);
 601                 }
 602             }
 603         }
 604     }
 605     // The selection marked text acts as a placeholder when computing the marked texts for the gaps...
 606     if (shouldPaintSelectionForeground) {
 607         ASSERT(!isPrinting);
 608         auto selectionMarkedText = createMarkedTextFromSelectionInBox(*this);
 609         if (!selectionMarkedText.isEmpty())
 610             markedTexts.append(WTFMove(selectionMarkedText));
 611     }
 612 
 613     auto styledMarkedTexts = subdivideAndResolveStyle(markedTexts, unmarkedStyle, paintInfo);
</pre>
<hr />
<pre>
 669 
 670 unsigned InlineTextBox::clampedOffset(unsigned x) const
 671 {
 672     unsigned offset = std::max(std::min(x, m_start + m_len), m_start) - m_start;
 673     if (m_truncation == cFullTruncation)
 674         return offset;
 675     if (m_truncation != cNoTruncation)
 676         offset = std::min&lt;unsigned&gt;(offset, m_truncation);
 677     else if (offset == m_len) {
 678         // Fix up the offset if we are combined text or have a hyphen because we manage these embellishments.
 679         // That is, they are not reflected in renderer().text(). We treat combined text as a single unit.
 680         // We also treat the last codepoint in this box and the hyphen as a single unit.
 681         if (auto* combinedText = this-&gt;combinedText())
 682             offset = combinedText-&gt;combinedStringForRendering().length();
 683         else if (hasHyphen())
 684             offset += lineStyle().hyphenString().length();
 685     }
 686     return offset;
 687 }
 688 
<span class="line-modified"> 689 std::pair&lt;unsigned, unsigned&gt; InlineTextBox::clampedStartEndForState(unsigned start, unsigned end, RenderObject::SelectionState selectionState) const</span>
 690 {

 691     if (selectionState == RenderObject::SelectionInside)
 692         return { 0, clampedOffset(m_start + m_len) };
 693 


 694     if (selectionState == RenderObject::SelectionStart)
 695         end = renderer().text().length();
 696     else if (selectionState == RenderObject::SelectionEnd)
 697         start = 0;
 698     return { clampedOffset(start), clampedOffset(end) };
 699 }
 700 
<span class="line-added"> 701 std::pair&lt;unsigned, unsigned&gt; InlineTextBox::selectionStartEnd() const</span>
<span class="line-added"> 702 {</span>
<span class="line-added"> 703     auto selectionState = renderer().selectionState();</span>
<span class="line-added"> 704 </span>
<span class="line-added"> 705     return clampedStartEndForState(renderer().view().selection().startOffset(), renderer().view().selection().endOffset(), selectionState);</span>
<span class="line-added"> 706 }</span>
<span class="line-added"> 707 </span>
<span class="line-added"> 708 std::pair&lt;unsigned, unsigned&gt; InlineTextBox::highlightStartEnd(SelectionRangeData &amp;rangeData) const</span>
<span class="line-added"> 709 {</span>
<span class="line-added"> 710     auto state = rangeData.selectionStateForRenderer(renderer());</span>
<span class="line-added"> 711     state = verifySelectionState(state, rangeData);</span>
<span class="line-added"> 712 </span>
<span class="line-added"> 713     if (state == RenderObject::SelectionNone)</span>
<span class="line-added"> 714         return {0, 0};</span>
<span class="line-added"> 715 </span>
<span class="line-added"> 716     return clampedStartEndForState(rangeData.startOffset(), rangeData.endOffset(), state);</span>
<span class="line-added"> 717 }</span>
<span class="line-added"> 718 </span>
 719 bool InlineTextBox::hasMarkers() const
 720 {
 721     return collectMarkedTextsForDocumentMarkers(TextPaintPhase::Decoration).size();
 722 }
 723 
 724 void InlineTextBox::paintPlatformDocumentMarkers(GraphicsContext&amp; context, const FloatPoint&amp; boxOrigin)
 725 {
 726     // This must match calculateUnionOfAllDocumentMarkerBounds().
 727     for (auto&amp; markedText : subdivide(collectMarkedTextsForDocumentMarkers(TextPaintPhase::Decoration), OverlapStrategy::Frontmost))
 728         paintPlatformDocumentMarker(context, boxOrigin, markedText);
 729 }
 730 
 731 FloatRect InlineTextBox::calculateUnionOfAllDocumentMarkerBounds() const
 732 {
 733     // This must match paintPlatformDocumentMarkers().
 734     FloatRect result;
 735     for (auto&amp; markedText : subdivide(collectMarkedTextsForDocumentMarkers(TextPaintPhase::Decoration), OverlapStrategy::Frontmost))
 736         result = unionRect(result, calculateDocumentMarkerBounds(markedText));
 737     return result;
 738 }
 739 
 740 FloatRect InlineTextBox::calculateDocumentMarkerBounds(const MarkedText&amp; markedText) const
 741 {
 742     auto&amp; font = lineFont();
 743     auto ascent = font.fontMetrics().ascent();
 744     auto fontSize = std::min(std::max(font.size(), 10.0f), 40.0f);
 745     auto y = ascent + 0.11035 * fontSize;
 746     auto height = 0.13247 * fontSize;
 747 
 748     // Avoid measuring the text when the entire line box is selected as an optimization.
<span class="line-modified"> 749     if (markedText.startOffset || markedText.endOffset != clampedOffset(end())) {</span>
 750         TextRun run = createTextRun();
 751         LayoutRect selectionRect = LayoutRect(0, y, 0, height);
 752         lineFont().adjustSelectionRectForText(run, selectionRect, markedText.startOffset, markedText.endOffset);
 753         return selectionRect;
 754     }
 755 
 756     return FloatRect(0, y, logicalWidth(), height);
 757 }
 758 
 759 void InlineTextBox::paintPlatformDocumentMarker(GraphicsContext&amp; context, const FloatPoint&amp; boxOrigin, const MarkedText&amp; markedText)
 760 {
 761     // Never print spelling/grammar markers (5327887)
 762     if (renderer().document().printing())
 763         return;
 764 
 765     if (m_truncation == cFullTruncation)
 766         return;
 767 
 768     auto bounds = calculateDocumentMarkerBounds(markedText);
 769 
</pre>
<hr />
<pre>
 802     style.textStyles = computeTextPaintStyle(renderer().frame(), lineStyle, paintInfo);
 803     style.textShadow = ShadowData::clone(paintInfo.forceTextColor() ? nullptr : lineStyle.textShadow());
 804     style.alpha = 1;
 805     return style;
 806 }
 807 
 808 auto InlineTextBox::resolveStyleForMarkedText(const MarkedText&amp; markedText, const MarkedTextStyle&amp; baseStyle, const PaintInfo&amp; paintInfo) -&gt; StyledMarkedText
 809 {
 810     MarkedTextStyle style = baseStyle;
 811     switch (markedText.type) {
 812     case MarkedText::Correction:
 813     case MarkedText::DictationAlternatives:
 814 #if PLATFORM(IOS_FAMILY)
 815     // FIXME: See &lt;rdar://problem/8933352&gt;. Also, remove the PLATFORM(IOS_FAMILY)-guard.
 816     case MarkedText::DictationPhraseWithAlternatives:
 817 #endif
 818     case MarkedText::GrammarError:
 819     case MarkedText::SpellingError:
 820     case MarkedText::Unmarked:
 821         break;
<span class="line-added"> 822     case MarkedText::Highlight:</span>
<span class="line-added"> 823         if (auto renderStyle = parent()-&gt;renderer().getUncachedPseudoStyle({ PseudoId::Highlight, markedText.highlightName }, &amp;parent()-&gt;renderer().style())) {</span>
<span class="line-added"> 824             style.backgroundColor = renderStyle-&gt;backgroundColor();</span>
<span class="line-added"> 825             style.textStyles.fillColor = renderStyle-&gt;computedStrokeColor();</span>
<span class="line-added"> 826             style.textStyles.strokeColor = renderStyle-&gt;computedStrokeColor();</span>
<span class="line-added"> 827 </span>
<span class="line-added"> 828             auto color = renderStyle-&gt;visitedDependentColorWithColorFilter(CSSPropertyWebkitTextFillColor);</span>
<span class="line-added"> 829             auto decorationStyle = renderStyle-&gt;textDecorationStyle();</span>
<span class="line-added"> 830             auto decorations = renderStyle-&gt;textDecorationsInEffect();</span>
<span class="line-added"> 831 </span>
<span class="line-added"> 832             if (decorations.containsAny({ TextDecoration::Underline, TextDecoration::Overline, TextDecoration::LineThrough })) {</span>
<span class="line-added"> 833                 style.textDecorationStyles.underlineColor = color;</span>
<span class="line-added"> 834                 style.textDecorationStyles.underlineStyle = decorationStyle;</span>
<span class="line-added"> 835             }</span>
<span class="line-added"> 836         }</span>
<span class="line-added"> 837         break;</span>
 838     case MarkedText::DraggedContent:
 839         style.alpha = 0.25;
 840         break;
 841     case MarkedText::Selection: {
 842         style.textStyles = computeTextSelectionPaintStyle(style.textStyles, renderer(), lineStyle(), paintInfo, style.textShadow);
 843 
 844         Color selectionBackgroundColor = renderer().selectionBackgroundColor();
 845         style.backgroundColor = selectionBackgroundColor;
 846         if (selectionBackgroundColor.isValid() &amp;&amp; selectionBackgroundColor.alpha() &amp;&amp; style.textStyles.fillColor == selectionBackgroundColor)
 847             style.backgroundColor = { 0xff - selectionBackgroundColor.red(), 0xff - selectionBackgroundColor.green(), 0xff - selectionBackgroundColor.blue() };
 848         break;
 849     }
 850     case MarkedText::TextMatch: {
 851         // Text matches always use the light system appearance.
 852         OptionSet&lt;StyleColor::Options&gt; styleColorOptions = { StyleColor::Options::UseSystemAppearance };
 853 #if PLATFORM(MAC)
 854         style.textStyles.fillColor = renderer().theme().systemColor(CSSValueAppleSystemLabel, styleColorOptions);
 855 #endif
 856         style.backgroundColor = markedText.marker-&gt;isActiveMatch() ? renderer().theme().activeTextSearchHighlightColor(styleColorOptions) : renderer().theme().inactiveTextSearchHighlightColor(styleColorOptions);
 857         break;
</pre>
<hr />
<pre>
 980                 continue;
 981             break;
 982 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
 983         case DocumentMarker::TelephoneNumber:
 984             if (!renderer().frame().editor().markedTextMatchesAreHighlighted())
 985                 continue;
 986             if (phase != TextPaintPhase::Background)
 987                 continue;
 988             break;
 989 #endif
 990         default:
 991             continue;
 992         }
 993 
 994         if (marker-&gt;endOffset() &lt;= start()) {
 995             // Marker is completely before this run. This might be a marker that sits before the
 996             // first run we draw, or markers that were within runs we skipped due to truncation.
 997             continue;
 998         }
 999 
<span class="line-modified">1000         if (marker-&gt;startOffset() &gt;= end()) {</span>
1001             // Marker is completely after this run, bail. A later run will paint it.
1002             break;
1003         }
1004 
1005         // Marker intersects this run. Collect it.
1006         switch (marker-&gt;type()) {
1007         case DocumentMarker::Spelling:
1008         case DocumentMarker::CorrectionIndicator:
1009         case DocumentMarker::DictationAlternatives:
1010         case DocumentMarker::Grammar:
1011 #if PLATFORM(IOS_FAMILY)
1012         // FIXME: See &lt;rdar://problem/8933352&gt;. Also, remove the PLATFORM(IOS_FAMILY)-guard.
1013         case DocumentMarker::DictationPhraseWithAlternatives:
1014 #endif
1015         case DocumentMarker::TextMatch:
1016             markedTexts.uncheckedAppend({ clampedOffset(marker-&gt;startOffset()), clampedOffset(marker-&gt;endOffset()), markedTextTypeForMarkerType(marker-&gt;type()), marker });
1017             break;
1018         case DocumentMarker::Replacement:
1019             break;
1020 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
1021         case DocumentMarker::TelephoneNumber:
1022             break;
1023 #endif
1024         default:
1025             ASSERT_NOT_REACHED();
1026         }
1027     }
1028     return markedTexts;
1029 }
1030 
<span class="line-added">1031 </span>
<span class="line-added">1032 Vector&lt;MarkedText&gt; InlineTextBox::collectMarkedTextsForHighlights(TextPaintPhase phase) const</span>
<span class="line-added">1033 {</span>
<span class="line-added">1034     if (!RuntimeEnabledFeatures::sharedFeatures().highlightAPIEnabled())</span>
<span class="line-added">1035         return { };</span>
<span class="line-added">1036     ASSERT_ARG(phase, phase == TextPaintPhase::Background || phase == TextPaintPhase::Foreground || phase == TextPaintPhase::Decoration);</span>
<span class="line-added">1037     UNUSED_PARAM(phase);</span>
<span class="line-added">1038     if (!renderer().textNode())</span>
<span class="line-added">1039         return { };</span>
<span class="line-added">1040 </span>
<span class="line-added">1041     Vector&lt;MarkedText&gt; markedTexts;</span>
<span class="line-added">1042     auto&amp; parentRenderer = parent()-&gt;renderer();</span>
<span class="line-added">1043     auto&amp; parentStyle = parentRenderer.style();</span>
<span class="line-added">1044     for (auto&amp; highlight : renderer().document().highlightMap().map()) {</span>
<span class="line-added">1045         auto renderStyle = parentRenderer.getUncachedPseudoStyle({ PseudoId::Highlight, highlight.key }, &amp;parentStyle);</span>
<span class="line-added">1046         if (!renderStyle)</span>
<span class="line-added">1047             continue;</span>
<span class="line-added">1048         for (auto&amp; rangeData : highlight.value-&gt;rangesData()) {</span>
<span class="line-added">1049             if (rangeData-&gt;startPosition &amp;&amp; rangeData-&gt;endPosition) {</span>
<span class="line-added">1050                 Position startPos = rangeData-&gt;startPosition.value();</span>
<span class="line-added">1051                 Position endPos = rangeData-&gt;endPosition.value();</span>
<span class="line-added">1052                 RenderObject* startRenderer = startPos.deprecatedNode()-&gt;renderer();</span>
<span class="line-added">1053                 int startOffset = startPos.deprecatedEditingOffset();</span>
<span class="line-added">1054                 RenderObject* endRenderer = endPos.deprecatedNode()-&gt;renderer();</span>
<span class="line-added">1055                 int endOffset = endPos.deprecatedEditingOffset();</span>
<span class="line-added">1056                 ASSERT(startOffset &gt;= 0 &amp;&amp; endOffset &gt;= 0);</span>
<span class="line-added">1057                 if (!startRenderer || !endRenderer)</span>
<span class="line-added">1058                     continue;</span>
<span class="line-added">1059                 auto highlightData = SelectionRangeData(renderer().view());</span>
<span class="line-added">1060                 highlightData.setContext({startRenderer, endRenderer, static_cast&lt;unsigned&gt;(startOffset), static_cast&lt;unsigned&gt;(endOffset)});</span>
<span class="line-added">1061                 auto [highlightStart, highlightEnd] = highlightStartEnd(highlightData);</span>
<span class="line-added">1062                 if (highlightStart &lt; highlightEnd)</span>
<span class="line-added">1063                     markedTexts.append({ highlightStart, highlightEnd, MarkedText::Highlight, nullptr, highlight.key });</span>
<span class="line-added">1064             }</span>
<span class="line-added">1065         }</span>
<span class="line-added">1066     }</span>
<span class="line-added">1067     return markedTexts;</span>
<span class="line-added">1068 }</span>
<span class="line-added">1069 </span>
1070 FloatPoint InlineTextBox::textOriginFromBoxRect(const FloatRect&amp; boxRect) const
1071 {
1072     FloatPoint textOrigin { boxRect.x(), boxRect.y() + lineFont().fontMetrics().ascent() };
1073     if (auto* combinedText = this-&gt;combinedText()) {
1074         if (auto newOrigin = combinedText-&gt;computeTextOrigin(boxRect))
1075             textOrigin = newOrigin.value();
1076     }
1077     if (isHorizontal())
1078         textOrigin.setY(roundToDevicePixel(LayoutUnit { textOrigin.y() }, renderer().document().deviceScaleFactor()));
1079     else
1080         textOrigin.setX(roundToDevicePixel(LayoutUnit { textOrigin.x() }, renderer().document().deviceScaleFactor()));
1081     return textOrigin;
1082 }
1083 
1084 void InlineTextBox::paintMarkedTexts(PaintInfo&amp; paintInfo, TextPaintPhase phase, const FloatRect&amp; boxRect, const Vector&lt;StyledMarkedText&gt;&amp; markedTexts, const FloatRect&amp; decorationClipOutRect)
1085 {
1086     switch (phase) {
1087     case TextPaintPhase::Background:
1088         for (auto&amp; markedText : markedTexts)
1089             paintMarkedTextBackground(paintInfo, boxRect.location(), markedText.style.backgroundColor, markedText.startOffset, markedText.endOffset);
</pre>
<hr />
<pre>
1209 
1210     {
1211         GraphicsContextStateSaver stateSaver { context, false };
1212         bool isDraggedContent = markedText.type == MarkedText::DraggedContent;
1213         if (isDraggedContent || !clipOutRect.isEmpty()) {
1214             stateSaver.save();
1215             if (isDraggedContent)
1216                 context.setAlpha(markedText.style.alpha);
1217             if (!clipOutRect.isEmpty())
1218                 context.clipOut(clipOutRect);
1219         }
1220         decorationPainter.paintTextDecoration(textRun.subRun(startOffset, endOffset - startOffset), textOriginFromBoxRect(snappedSelectionRect), snappedSelectionRect.location());
1221     }
1222 
1223     if (isCombinedText)
1224         context.concatCTM(rotation(boxRect, Counterclockwise));
1225 }
1226 
1227 void InlineTextBox::paintCompositionBackground(PaintInfo&amp; paintInfo, const FloatPoint&amp; boxOrigin)
1228 {
<span class="line-modified">1229     if (!renderer().frame().editor().compositionUsesCustomHighlights()) {</span>
<span class="line-added">1230         paintMarkedTextBackground(paintInfo, boxOrigin, Color::compositionFill, clampedOffset(renderer().frame().editor().compositionStart()), clampedOffset(renderer().frame().editor().compositionEnd()));</span>
<span class="line-added">1231         return;</span>
<span class="line-added">1232     }</span>
<span class="line-added">1233 </span>
<span class="line-added">1234     for (auto&amp; highlight : renderer().frame().editor().customCompositionHighlights()) {</span>
<span class="line-added">1235         if (highlight.endOffset &lt;= m_start)</span>
<span class="line-added">1236             continue;</span>
<span class="line-added">1237 </span>
<span class="line-added">1238         if (highlight.startOffset &gt;= end())</span>
<span class="line-added">1239             break;</span>
<span class="line-added">1240 </span>
<span class="line-added">1241         paintMarkedTextBackground(paintInfo, boxOrigin, highlight.color, clampedOffset(highlight.startOffset), clampedOffset(highlight.endOffset));</span>
<span class="line-added">1242 </span>
<span class="line-added">1243         if (highlight.endOffset &gt; end())</span>
<span class="line-added">1244             break;</span>
<span class="line-added">1245     }</span>
1246 }
1247 
1248 void InlineTextBox::paintCompositionUnderlines(PaintInfo&amp; paintInfo, const FloatPoint&amp; boxOrigin) const
1249 {
1250     if (m_truncation == cFullTruncation)
1251         return;
1252 
1253     for (auto&amp; underline : renderer().frame().editor().customCompositionUnderlines()) {
1254         if (underline.endOffset &lt;= m_start) {
1255             // Underline is completely before this run. This might be an underline that sits
1256             // before the first run we draw, or underlines that were within runs we skipped
1257             // due to truncation.
1258             continue;
1259         }
1260 
<span class="line-modified">1261         if (underline.startOffset &gt;= end())</span>
1262             break; // Underline is completely after this run, bail. A later run will paint it.
1263 
1264         // Underline intersects this run. Paint it.
1265         paintCompositionUnderline(paintInfo, boxOrigin, underline);
1266 
<span class="line-modified">1267         if (underline.endOffset &gt; end())</span>
1268             break; // Underline also runs into the next run. Bail now, no more marker advancement.
1269     }
1270 }
1271 
1272 static inline void mirrorRTLSegment(float logicalWidth, TextDirection direction, float&amp; start, float width)
1273 {
1274     if (direction == TextDirection::LTR)
1275         return;
1276     start = logicalWidth - width - start;
1277 }
1278 
1279 void InlineTextBox::paintCompositionUnderline(PaintInfo&amp; paintInfo, const FloatPoint&amp; boxOrigin, const CompositionUnderline&amp; underline) const
1280 {
1281     if (m_truncation == cFullTruncation)
1282         return;
1283 
1284     float start = 0; // start of line to draw, relative to tx
1285     float width = logicalWidth(); // how much line to draw
1286     bool useWholeWidth = true;
1287     unsigned paintStart = m_start;
<span class="line-modified">1288     unsigned paintEnd = end();</span>
1289     if (paintStart &lt;= underline.startOffset) {
1290         paintStart = underline.startOffset;
1291         useWholeWidth = false;
1292         start = renderer().width(m_start, paintStart - m_start, textPos(), isFirstLine());
1293     }
1294     if (paintEnd != underline.endOffset) {      // end points at the last char, not past it
1295         paintEnd = std::min(paintEnd, (unsigned)underline.endOffset);
1296         useWholeWidth = false;
1297     }
1298     if (m_truncation != cNoTruncation) {
1299         paintEnd = std::min(paintEnd, (unsigned)m_start + m_truncation);
1300         useWholeWidth = false;
1301     }
1302     if (!useWholeWidth) {
1303         width = renderer().width(paintStart, paintEnd - paintStart, textPos() + start, isFirstLine());
1304         mirrorRTLSegment(logicalWidth(), direction(), start, width);
1305     }
1306 
1307     // Thick marked text underlines are 2px thick as long as there is room for the 2px line under the baseline.
1308     // All other marked text underlines are 1px thick.
</pre>
<hr />
<pre>
1407 }
1408 
1409 inline const RenderCombineText* InlineTextBox::combinedText() const
1410 {
1411     return lineStyle().hasTextCombine() &amp;&amp; is&lt;RenderCombineText&gt;(renderer()) &amp;&amp; downcast&lt;RenderCombineText&gt;(renderer()).isCombined() ? &amp;downcast&lt;RenderCombineText&gt;(renderer()) : nullptr;
1412 }
1413 
1414 ExpansionBehavior InlineTextBox::expansionBehavior() const
1415 {
1416     ExpansionBehavior leadingBehavior;
1417     if (forceLeadingExpansion())
1418         leadingBehavior = ForceLeadingExpansion;
1419     else if (canHaveLeadingExpansion())
1420         leadingBehavior = AllowLeadingExpansion;
1421     else
1422         leadingBehavior = ForbidLeadingExpansion;
1423 
1424     ExpansionBehavior trailingBehavior;
1425     if (forceTrailingExpansion())
1426         trailingBehavior = ForceTrailingExpansion;
<span class="line-modified">1427     else if (expansion() &amp;&amp; nextLeafOnLine() &amp;&amp; !nextLeafOnLine()-&gt;isLineBreak())</span>
1428         trailingBehavior = AllowTrailingExpansion;
1429     else
1430         trailingBehavior = ForbidTrailingExpansion;
1431 
1432     return leadingBehavior | trailingBehavior;
1433 }
1434 
1435 #if ENABLE(TREE_DEBUGGING)
1436 
1437 const char* InlineTextBox::boxName() const
1438 {
1439     return &quot;InlineTextBox&quot;;
1440 }
1441 
1442 void InlineTextBox::outputLineBox(TextStream&amp; stream, bool mark, int depth) const
1443 {
1444     stream &lt;&lt; &quot;-------- &quot; &lt;&lt; (isDirty() ? &quot;D&quot; : &quot;-&quot;) &lt;&lt; &quot;-&quot;;
1445 
1446     int printedCharacters = 0;
1447     if (mark) {
</pre>
</td>
</tr>
</table>
<center><a href="InlineFlowBox.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InlineTextBox.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderDeprecatedFlexibleBox.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  44 #include &quot;LengthFunctions.h&quot;
  45 #include &quot;Logging.h&quot;
  46 #include &quot;Page.h&quot;
  47 #include &quot;PathUtilities.h&quot;
  48 #include &quot;RenderBlock.h&quot;
  49 #include &quot;RenderChildIterator.h&quot;
  50 #include &quot;RenderCounter.h&quot;
  51 #include &quot;RenderDeprecatedFlexibleBox.h&quot;
  52 #include &quot;RenderDescendantIterator.h&quot;
  53 #include &quot;RenderFlexibleBox.h&quot;
  54 #include &quot;RenderFragmentedFlow.h&quot;
  55 #include &quot;RenderGrid.h&quot;
  56 #include &quot;RenderImage.h&quot;
  57 #include &quot;RenderImageResourceStyleImage.h&quot;
  58 #include &quot;RenderInline.h&quot;
  59 #include &quot;RenderIterator.h&quot;
  60 #include &quot;RenderLayer.h&quot;
  61 #include &quot;RenderLayerCompositor.h&quot;
  62 #include &quot;RenderLineBreak.h&quot;
  63 #include &quot;RenderListItem.h&quot;
<span class="line-modified">  64 #if !ASSERT_DISABLED</span>
  65 #include &quot;RenderListMarker.h&quot;
  66 #endif
  67 #include &quot;RenderFragmentContainer.h&quot;
  68 #include &quot;RenderTableCaption.h&quot;
  69 #include &quot;RenderTableCell.h&quot;
  70 #include &quot;RenderTableCol.h&quot;
  71 #include &quot;RenderTableRow.h&quot;
  72 #include &quot;RenderText.h&quot;
  73 #include &quot;RenderTheme.h&quot;
  74 #include &quot;RenderTreeBuilder.h&quot;
  75 #include &quot;RenderView.h&quot;
  76 #include &quot;SVGImage.h&quot;
  77 #include &quot;SVGRenderSupport.h&quot;
  78 #include &quot;Settings.h&quot;
  79 #include &quot;ShadowRoot.h&quot;
  80 #include &quot;StylePendingResources.h&quot;
  81 #include &quot;StyleResolver.h&quot;
  82 #include &quot;TextAutoSizing.h&quot;
  83 #include &lt;wtf/IsoMallocInlines.h&gt;
  84 #include &lt;wtf/MathExtras.h&gt;
</pre>
<hr />
<pre>
 147     const ContentData* contentData = style.contentData();
 148     if (creationType == CreateAllRenderers &amp;&amp; contentData &amp;&amp; !contentData-&gt;next() &amp;&amp; is&lt;ImageContentData&gt;(*contentData) &amp;&amp; !element.isPseudoElement()) {
 149         Style::loadPendingResources(style, element.document(), &amp;element);
 150         auto&amp; styleImage = downcast&lt;ImageContentData&gt;(*contentData).image();
 151         auto image = createRenderer&lt;RenderImage&gt;(element, WTFMove(style), const_cast&lt;StyleImage*&gt;(&amp;styleImage));
 152         image-&gt;setIsGeneratedContent();
 153         return image;
 154     }
 155 
 156     switch (style.display()) {
 157     case DisplayType::None:
 158     case DisplayType::Contents:
 159         return nullptr;
 160     case DisplayType::Inline:
 161         if (creationType == CreateAllRenderers)
 162             return createRenderer&lt;RenderInline&gt;(element, WTFMove(style));
 163         FALLTHROUGH; // Fieldsets should make a block flow if display:inline is set.
 164     case DisplayType::Block:
 165     case DisplayType::FlowRoot:
 166     case DisplayType::InlineBlock:
<span class="line-removed"> 167     case DisplayType::Compact:</span>
 168         return createRenderer&lt;RenderBlockFlow&gt;(element, WTFMove(style));
 169     case DisplayType::ListItem:
 170         return createRenderer&lt;RenderListItem&gt;(element, WTFMove(style));
 171     case DisplayType::Flex:
 172     case DisplayType::InlineFlex:
 173     case DisplayType::WebKitFlex:
 174     case DisplayType::WebKitInlineFlex:
 175         return createRenderer&lt;RenderFlexibleBox&gt;(element, WTFMove(style));
 176     case DisplayType::Grid:
 177     case DisplayType::InlineGrid:
 178         return createRenderer&lt;RenderGrid&gt;(element, WTFMove(style));
 179     case DisplayType::Box:
 180     case DisplayType::InlineBox:
 181         return createRenderer&lt;RenderDeprecatedFlexibleBox&gt;(element, WTFMove(style));
 182     default: {
 183         if (creationType == OnlyCreateBlockAndFlexboxRenderers)
 184             return createRenderer&lt;RenderBlockFlow&gt;(element, WTFMove(style));
 185         switch (style.display()) {
 186         case DisplayType::Table:
 187         case DisplayType::InlineTable:
</pre>
<hr />
<pre>
 453     if (updatedDiff == StyleDifference::RepaintLayer || shouldRepaintForStyleDifference(updatedDiff)) {
 454         // Do a repaint with the new style now, e.g., for example if we go from
 455         // not having an outline to having an outline.
 456         repaint();
 457     }
 458 }
 459 
 460 void RenderElement::didAttachChild(RenderObject&amp; child, RenderObject*)
 461 {
 462     if (is&lt;RenderText&gt;(child))
 463         downcast&lt;RenderText&gt;(child).styleDidChange(StyleDifference::Equal, nullptr);
 464     // SVG creates renderers for &lt;g display=&quot;none&quot;&gt;, as SVG requires children of hidden
 465     // &lt;g&gt;s to have renderers - at least that&#39;s how our implementation works. Consider:
 466     // &lt;g display=&quot;none&quot;&gt;&lt;foreignObject&gt;&lt;body style=&quot;position: relative&quot;&gt;FOO...
 467     // - requiresLayer() would return true for the &lt;body&gt;, creating a new RenderLayer
 468     // - when the document is painted, both layers are painted. The &lt;body&gt; layer doesn&#39;t
 469     //   know that it&#39;s inside a &quot;hidden SVG subtree&quot;, and thus paints, even if it shouldn&#39;t.
 470     // To avoid the problem alltogether, detect early if we&#39;re inside a hidden SVG subtree
 471     // and stop creating layers at all for these cases - they&#39;re not used anyways.
 472     if (child.hasLayer() &amp;&amp; !layerCreationAllowedForSubtree())
<span class="line-modified"> 473         downcast&lt;RenderLayerModelObject&gt;(child).layer()-&gt;removeOnlyThisLayer();</span>
 474 }
 475 
 476 RenderObject* RenderElement::attachRendererInternal(RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
 477 {
 478     child-&gt;setParent(this);
 479 
 480     if (m_firstChild == beforeChild)
 481         m_firstChild = child.get();
 482 
 483     if (beforeChild) {
 484         auto* previousSibling = beforeChild-&gt;previousSibling();
 485         if (previousSibling)
 486             previousSibling-&gt;setNextSibling(child.get());
 487         child-&gt;setPreviousSibling(previousSibling);
 488         child-&gt;setNextSibling(beforeChild);
 489         beforeChild-&gt;setPreviousSibling(child.get());
 490         return child.release();
 491     }
 492     if (m_lastChild)
 493         m_lastChild-&gt;setNextSibling(child.get());
</pre>
<hr />
<pre>
 694 
 695 void RenderElement::invalidateCachedFirstLineStyle()
 696 {
 697     if (!m_hasValidCachedFirstLineStyle)
 698         return;
 699     m_hasValidCachedFirstLineStyle = false;
 700     // Invalidate the subtree as descendant&#39;s first line style may depend on ancestor&#39;s.
 701     for (auto&amp; descendant : descendantsOfType&lt;RenderElement&gt;(*this))
 702         descendant.m_hasValidCachedFirstLineStyle = false;
 703 }
 704 
 705 void RenderElement::styleWillChange(StyleDifference diff, const RenderStyle&amp; newStyle)
 706 {
 707     ASSERT(settings().shouldAllowUserInstalledFonts() || newStyle.fontDescription().shouldAllowUserInstalledFonts() == AllowUserInstalledFonts::No);
 708 
 709     auto* oldStyle = hasInitializedStyle() ? &amp;style() : nullptr;
 710     if (oldStyle) {
 711         // If our z-index changes value or our visibility changes,
 712         // we need to dirty our stacking context&#39;s z-order list.
 713         bool visibilityChanged = m_style.visibility() != newStyle.visibility()
<span class="line-modified"> 714             || m_style.zIndex() != newStyle.zIndex()</span>
<span class="line-modified"> 715             || m_style.hasAutoZIndex() != newStyle.hasAutoZIndex();</span>
 716 
 717         if (visibilityChanged)
 718             document().invalidateRenderingDependentRegions();
 719 
 720         if (visibilityChanged) {
 721             if (AXObjectCache* cache = document().existingAXObjectCache())
 722                 cache-&gt;childrenChanged(parent(), this);
 723         }
 724 
 725         // Keep layer hierarchy visibility bits up to date if visibility changes.
 726         if (m_style.visibility() != newStyle.visibility()) {
 727             if (RenderLayer* layer = enclosingLayer()) {
 728                 if (newStyle.visibility() == Visibility::Visible)
 729                     layer-&gt;setHasVisibleContent();
 730                 else if (layer-&gt;hasVisibleContent() &amp;&amp; (this == &amp;layer-&gt;renderer() || layer-&gt;renderer().style().visibility() != Visibility::Visible)) {
 731                     layer-&gt;dirtyVisibleContentStatus();
 732                     if (diff &gt; StyleDifference::RepaintLayer)
 733                         repaint();
 734                 }
 735             }
</pre>
<hr />
<pre>
 869         issueRepaintForOutlineAuto(hasOutlineAuto ? outlineStyleForRepaint().outlineSize() : oldStyle-&gt;outlineSize());
 870     }
 871 }
 872 
 873 void RenderElement::insertedIntoTree()
 874 {
 875     // Keep our layer hierarchy updated. Optimize for the common case where we don&#39;t have any children
 876     // and don&#39;t have a layer attached to ourselves.
 877     RenderLayer* layer = nullptr;
 878     if (firstChild() || hasLayer()) {
 879         layer = parent()-&gt;enclosingLayer();
 880         addLayers(layer);
 881     }
 882 
 883     // If |this| is visible but this object was not, tell the layer it has some visible content
 884     // that needs to be drawn and layer visibility optimization can&#39;t be used
 885     if (parent()-&gt;style().visibility() != Visibility::Visible &amp;&amp; style().visibility() == Visibility::Visible &amp;&amp; !hasLayer()) {
 886         if (!layer)
 887             layer = parent()-&gt;enclosingLayer();
 888         if (layer)
<span class="line-modified"> 889             layer-&gt;setHasVisibleContent();</span>
 890     }
 891 
 892     RenderObject::insertedIntoTree();
 893 }
 894 
 895 void RenderElement::willBeRemovedFromTree()
 896 {
 897     // If we remove a visible child from an invisible parent, we don&#39;t know the layer visibility any more.
 898     RenderLayer* layer = nullptr;
 899     if (parent()-&gt;style().visibility() != Visibility::Visible &amp;&amp; style().visibility() == Visibility::Visible &amp;&amp; !hasLayer()) {
 900         if ((layer = parent()-&gt;enclosingLayer()))
 901             layer-&gt;dirtyVisibleContentStatus();
 902     }
 903     // Keep our layer hierarchy updated.
 904     if (firstChild() || hasLayer()) {
 905         if (!layer)
 906             layer = parent()-&gt;enclosingLayer();
 907         removeLayers(layer);
 908     }
 909 
</pre>
<hr />
<pre>
1341         else
1342             image-&gt;startAnimation();
1343     }
1344 
1345     // For directly-composited animated GIFs it does not suffice to call repaint() to resume animation. We need to mark the image as changed.
1346     if (is&lt;RenderBoxModelObject&gt;(*this))
1347         downcast&lt;RenderBoxModelObject&gt;(*this).contentChanged(ImageChanged);
1348 
1349     return true;
1350 }
1351 
1352 const RenderStyle* RenderElement::getCachedPseudoStyle(PseudoId pseudo, const RenderStyle* parentStyle) const
1353 {
1354     if (pseudo &lt; PseudoId::FirstInternalPseudoId &amp;&amp; !style().hasPseudoStyle(pseudo))
1355         return nullptr;
1356 
1357     RenderStyle* cachedStyle = style().getCachedPseudoStyle(pseudo);
1358     if (cachedStyle)
1359         return cachedStyle;
1360 
<span class="line-modified">1361     std::unique_ptr&lt;RenderStyle&gt; result = getUncachedPseudoStyle(PseudoStyleRequest(pseudo), parentStyle);</span>
1362     if (result)
1363         return const_cast&lt;RenderStyle&amp;&gt;(m_style).addCachedPseudoStyle(WTFMove(result));
1364     return nullptr;
1365 }
1366 
<span class="line-modified">1367 std::unique_ptr&lt;RenderStyle&gt; RenderElement::getUncachedPseudoStyle(const PseudoStyleRequest&amp; pseudoStyleRequest, const RenderStyle* parentStyle, const RenderStyle* ownStyle) const</span>
1368 {
<span class="line-modified">1369     if (pseudoStyleRequest.pseudoId &lt; PseudoId::FirstInternalPseudoId &amp;&amp; !ownStyle &amp;&amp; !style().hasPseudoStyle(pseudoStyleRequest.pseudoId))</span>
1370         return nullptr;
1371 
1372     if (!parentStyle) {
1373         ASSERT(!ownStyle);
1374         parentStyle = &amp;style();
1375     }
1376 
1377     if (isAnonymous())
1378         return nullptr;
1379 
1380     auto&amp; styleResolver = element()-&gt;styleResolver();
1381 
<span class="line-modified">1382     std::unique_ptr&lt;RenderStyle&gt; style = styleResolver.pseudoStyleForElement(*element(), pseudoStyleRequest, *parentStyle);</span>
1383 
1384     if (style)
1385         Style::loadPendingResources(*style, document(), element());
1386 
1387     return style;
1388 }
1389 
1390 Color RenderElement::selectionColor(CSSPropertyID colorProperty) const
1391 {
1392     // If the element is unselectable, or we are only painting the selection,
1393     // don&#39;t override the foreground color with the selection foreground color.
1394     if (style().userSelect() == UserSelect::None
1395         || (view().frameView().paintBehavior().containsAny({ PaintBehavior::SelectionOnly, PaintBehavior::SelectionAndBackgroundsOnly })))
1396         return Color();
1397 
1398     if (std::unique_ptr&lt;RenderStyle&gt; pseudoStyle = selectionPseudoStyle()) {
1399         Color color = pseudoStyle-&gt;visitedDependentColorWithColorFilter(colorProperty);
1400         if (!color.isValid())
1401             color = pseudoStyle-&gt;visitedDependentColorWithColorFilter(CSSPropertyColor);
1402         return color;
1403     }
1404 
1405     if (frame().selection().isFocusedAndActive())
1406         return theme().activeSelectionForegroundColor(styleColorOptions());
1407     return theme().inactiveSelectionForegroundColor(styleColorOptions());
1408 }
1409 
1410 std::unique_ptr&lt;RenderStyle&gt; RenderElement::selectionPseudoStyle() const
1411 {
1412     if (isAnonymous())
1413         return nullptr;
1414 
1415     if (ShadowRoot* root = element()-&gt;containingShadowRoot()) {
1416         if (root-&gt;mode() == ShadowRootMode::UserAgent) {
<span class="line-modified">1417             if (Element* shadowHost = element()-&gt;shadowHost())</span>
<span class="line-modified">1418                 return shadowHost-&gt;renderer()-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::Selection));</span>





1419         }
1420     }
1421 
<span class="line-modified">1422     return getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::Selection));</span>
1423 }
1424 
1425 Color RenderElement::selectionForegroundColor() const
1426 {
1427     return selectionColor(CSSPropertyWebkitTextFillColor);
1428 }
1429 
1430 Color RenderElement::selectionEmphasisMarkColor() const
1431 {
1432     return selectionColor(CSSPropertyWebkitTextEmphasisColor);
1433 }
1434 
1435 Color RenderElement::selectionBackgroundColor() const
1436 {
1437     if (style().userSelect() == UserSelect::None)
1438         return Color();
1439 
1440     if (frame().selection().shouldShowBlockCursor() &amp;&amp; frame().selection().isCaret())
1441         return theme().transformSelectionBackgroundColor(style().visitedDependentColorWithColorFilter(CSSPropertyColor), styleColorOptions());
1442 
</pre>
<hr />
<pre>
2016 {
2017     for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(*this)) {
2018         if (hasOutlineAuto == child.hasOutlineAutoAncestor())
2019             continue;
2020         child.setHasOutlineAutoAncestor(hasOutlineAuto);
2021         bool childHasOutlineAuto = child.outlineStyleForRepaint().outlineStyleIsAuto() == OutlineIsAuto::On;
2022         if (childHasOutlineAuto)
2023             continue;
2024         if (!is&lt;RenderElement&gt;(child))
2025             continue;
2026         downcast&lt;RenderElement&gt;(child).updateOutlineAutoAncestor(hasOutlineAuto);
2027     }
2028     if (is&lt;RenderBoxModelObject&gt;(*this)) {
2029         if (auto* continuation = downcast&lt;RenderBoxModelObject&gt;(*this).continuation())
2030             continuation-&gt;updateOutlineAutoAncestor(hasOutlineAuto);
2031     }
2032 }
2033 
2034 bool RenderElement::hasOutlineAnnotation() const
2035 {
<span class="line-modified">2036     return element() &amp;&amp; element()-&gt;isLink() &amp;&amp; document().printing();</span>
2037 }
2038 
2039 bool RenderElement::hasSelfPaintingLayer() const
2040 {
2041     if (!hasLayer())
2042         return false;
2043     auto&amp; layerModelObject = downcast&lt;RenderLayerModelObject&gt;(*this);
2044     return layerModelObject.hasSelfPaintingLayer();
2045 }
2046 
2047 bool RenderElement::checkForRepaintDuringLayout() const
2048 {
2049     if (document().view()-&gt;layoutContext().needsFullRepaint() || !everHadLayout() || hasSelfPaintingLayer())
2050         return false;
2051     return !settings().repaintOutsideLayoutEnabled();
2052 }
2053 
2054 ImageOrientation RenderElement::imageOrientation() const
2055 {
<span class="line-removed">2056 #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)</span>
<span class="line-removed">2057     // This can only be enabled for ports which honor the orientation flag in their drawing code.</span>
<span class="line-removed">2058     if (document().isImageDocument())</span>
<span class="line-removed">2059         return ImageOrientation::FromImage;</span>
<span class="line-removed">2060 #endif</span>
<span class="line-removed">2061     // Respect the image&#39;s orientation if it&#39;s being used as a full-page image or it&#39;s</span>
<span class="line-removed">2062     // an &lt;img&gt; and the setting to respect it everywhere is set.</span>
<span class="line-removed">2063     if (settings().shouldRespectImageOrientation() &amp;&amp; is&lt;HTMLImageElement&gt;(element()))</span>
<span class="line-removed">2064         return ImageOrientation::FromImage;</span>
2065     return style().imageOrientation();
2066 }
2067 
2068 void RenderElement::adjustFragmentedFlowStateOnContainingBlockChangeIfNeeded()
2069 {
2070     if (fragmentedFlowState() == NotInsideFragmentedFlow)
2071         return;
2072 
2073     // Invalidate the containing block caches.
2074     if (is&lt;RenderBlock&gt;(*this))
2075         downcast&lt;RenderBlock&gt;(*this).resetEnclosingFragmentedFlowAndChildInfoIncludingDescendants();
2076 
2077     // Adjust the flow tread state on the subtree.
2078     setFragmentedFlowState(RenderObject::computedFragmentedFlowState(*this));
2079     for (auto&amp; descendant : descendantsOfType&lt;RenderObject&gt;(*this))
2080         descendant.setFragmentedFlowState(RenderObject::computedFragmentedFlowState(descendant));
2081 }
2082 
2083 void RenderElement::removeFromRenderFragmentedFlow()
2084 {
</pre>
</td>
<td>
<hr />
<pre>
  44 #include &quot;LengthFunctions.h&quot;
  45 #include &quot;Logging.h&quot;
  46 #include &quot;Page.h&quot;
  47 #include &quot;PathUtilities.h&quot;
  48 #include &quot;RenderBlock.h&quot;
  49 #include &quot;RenderChildIterator.h&quot;
  50 #include &quot;RenderCounter.h&quot;
  51 #include &quot;RenderDeprecatedFlexibleBox.h&quot;
  52 #include &quot;RenderDescendantIterator.h&quot;
  53 #include &quot;RenderFlexibleBox.h&quot;
  54 #include &quot;RenderFragmentedFlow.h&quot;
  55 #include &quot;RenderGrid.h&quot;
  56 #include &quot;RenderImage.h&quot;
  57 #include &quot;RenderImageResourceStyleImage.h&quot;
  58 #include &quot;RenderInline.h&quot;
  59 #include &quot;RenderIterator.h&quot;
  60 #include &quot;RenderLayer.h&quot;
  61 #include &quot;RenderLayerCompositor.h&quot;
  62 #include &quot;RenderLineBreak.h&quot;
  63 #include &quot;RenderListItem.h&quot;
<span class="line-modified">  64 #if ASSERT_ENABLED</span>
  65 #include &quot;RenderListMarker.h&quot;
  66 #endif
  67 #include &quot;RenderFragmentContainer.h&quot;
  68 #include &quot;RenderTableCaption.h&quot;
  69 #include &quot;RenderTableCell.h&quot;
  70 #include &quot;RenderTableCol.h&quot;
  71 #include &quot;RenderTableRow.h&quot;
  72 #include &quot;RenderText.h&quot;
  73 #include &quot;RenderTheme.h&quot;
  74 #include &quot;RenderTreeBuilder.h&quot;
  75 #include &quot;RenderView.h&quot;
  76 #include &quot;SVGImage.h&quot;
  77 #include &quot;SVGRenderSupport.h&quot;
  78 #include &quot;Settings.h&quot;
  79 #include &quot;ShadowRoot.h&quot;
  80 #include &quot;StylePendingResources.h&quot;
  81 #include &quot;StyleResolver.h&quot;
  82 #include &quot;TextAutoSizing.h&quot;
  83 #include &lt;wtf/IsoMallocInlines.h&gt;
  84 #include &lt;wtf/MathExtras.h&gt;
</pre>
<hr />
<pre>
 147     const ContentData* contentData = style.contentData();
 148     if (creationType == CreateAllRenderers &amp;&amp; contentData &amp;&amp; !contentData-&gt;next() &amp;&amp; is&lt;ImageContentData&gt;(*contentData) &amp;&amp; !element.isPseudoElement()) {
 149         Style::loadPendingResources(style, element.document(), &amp;element);
 150         auto&amp; styleImage = downcast&lt;ImageContentData&gt;(*contentData).image();
 151         auto image = createRenderer&lt;RenderImage&gt;(element, WTFMove(style), const_cast&lt;StyleImage*&gt;(&amp;styleImage));
 152         image-&gt;setIsGeneratedContent();
 153         return image;
 154     }
 155 
 156     switch (style.display()) {
 157     case DisplayType::None:
 158     case DisplayType::Contents:
 159         return nullptr;
 160     case DisplayType::Inline:
 161         if (creationType == CreateAllRenderers)
 162             return createRenderer&lt;RenderInline&gt;(element, WTFMove(style));
 163         FALLTHROUGH; // Fieldsets should make a block flow if display:inline is set.
 164     case DisplayType::Block:
 165     case DisplayType::FlowRoot:
 166     case DisplayType::InlineBlock:

 167         return createRenderer&lt;RenderBlockFlow&gt;(element, WTFMove(style));
 168     case DisplayType::ListItem:
 169         return createRenderer&lt;RenderListItem&gt;(element, WTFMove(style));
 170     case DisplayType::Flex:
 171     case DisplayType::InlineFlex:
 172     case DisplayType::WebKitFlex:
 173     case DisplayType::WebKitInlineFlex:
 174         return createRenderer&lt;RenderFlexibleBox&gt;(element, WTFMove(style));
 175     case DisplayType::Grid:
 176     case DisplayType::InlineGrid:
 177         return createRenderer&lt;RenderGrid&gt;(element, WTFMove(style));
 178     case DisplayType::Box:
 179     case DisplayType::InlineBox:
 180         return createRenderer&lt;RenderDeprecatedFlexibleBox&gt;(element, WTFMove(style));
 181     default: {
 182         if (creationType == OnlyCreateBlockAndFlexboxRenderers)
 183             return createRenderer&lt;RenderBlockFlow&gt;(element, WTFMove(style));
 184         switch (style.display()) {
 185         case DisplayType::Table:
 186         case DisplayType::InlineTable:
</pre>
<hr />
<pre>
 452     if (updatedDiff == StyleDifference::RepaintLayer || shouldRepaintForStyleDifference(updatedDiff)) {
 453         // Do a repaint with the new style now, e.g., for example if we go from
 454         // not having an outline to having an outline.
 455         repaint();
 456     }
 457 }
 458 
 459 void RenderElement::didAttachChild(RenderObject&amp; child, RenderObject*)
 460 {
 461     if (is&lt;RenderText&gt;(child))
 462         downcast&lt;RenderText&gt;(child).styleDidChange(StyleDifference::Equal, nullptr);
 463     // SVG creates renderers for &lt;g display=&quot;none&quot;&gt;, as SVG requires children of hidden
 464     // &lt;g&gt;s to have renderers - at least that&#39;s how our implementation works. Consider:
 465     // &lt;g display=&quot;none&quot;&gt;&lt;foreignObject&gt;&lt;body style=&quot;position: relative&quot;&gt;FOO...
 466     // - requiresLayer() would return true for the &lt;body&gt;, creating a new RenderLayer
 467     // - when the document is painted, both layers are painted. The &lt;body&gt; layer doesn&#39;t
 468     //   know that it&#39;s inside a &quot;hidden SVG subtree&quot;, and thus paints, even if it shouldn&#39;t.
 469     // To avoid the problem alltogether, detect early if we&#39;re inside a hidden SVG subtree
 470     // and stop creating layers at all for these cases - they&#39;re not used anyways.
 471     if (child.hasLayer() &amp;&amp; !layerCreationAllowedForSubtree())
<span class="line-modified"> 472         downcast&lt;RenderLayerModelObject&gt;(child).layer()-&gt;removeOnlyThisLayer(RenderLayer::LayerChangeTiming::RenderTreeConstruction);</span>
 473 }
 474 
 475 RenderObject* RenderElement::attachRendererInternal(RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
 476 {
 477     child-&gt;setParent(this);
 478 
 479     if (m_firstChild == beforeChild)
 480         m_firstChild = child.get();
 481 
 482     if (beforeChild) {
 483         auto* previousSibling = beforeChild-&gt;previousSibling();
 484         if (previousSibling)
 485             previousSibling-&gt;setNextSibling(child.get());
 486         child-&gt;setPreviousSibling(previousSibling);
 487         child-&gt;setNextSibling(beforeChild);
 488         beforeChild-&gt;setPreviousSibling(child.get());
 489         return child.release();
 490     }
 491     if (m_lastChild)
 492         m_lastChild-&gt;setNextSibling(child.get());
</pre>
<hr />
<pre>
 693 
 694 void RenderElement::invalidateCachedFirstLineStyle()
 695 {
 696     if (!m_hasValidCachedFirstLineStyle)
 697         return;
 698     m_hasValidCachedFirstLineStyle = false;
 699     // Invalidate the subtree as descendant&#39;s first line style may depend on ancestor&#39;s.
 700     for (auto&amp; descendant : descendantsOfType&lt;RenderElement&gt;(*this))
 701         descendant.m_hasValidCachedFirstLineStyle = false;
 702 }
 703 
 704 void RenderElement::styleWillChange(StyleDifference diff, const RenderStyle&amp; newStyle)
 705 {
 706     ASSERT(settings().shouldAllowUserInstalledFonts() || newStyle.fontDescription().shouldAllowUserInstalledFonts() == AllowUserInstalledFonts::No);
 707 
 708     auto* oldStyle = hasInitializedStyle() ? &amp;style() : nullptr;
 709     if (oldStyle) {
 710         // If our z-index changes value or our visibility changes,
 711         // we need to dirty our stacking context&#39;s z-order list.
 712         bool visibilityChanged = m_style.visibility() != newStyle.visibility()
<span class="line-modified"> 713             || m_style.usedZIndex() != newStyle.usedZIndex()</span>
<span class="line-modified"> 714             || m_style.hasAutoUsedZIndex() != newStyle.hasAutoUsedZIndex();</span>
 715 
 716         if (visibilityChanged)
 717             document().invalidateRenderingDependentRegions();
 718 
 719         if (visibilityChanged) {
 720             if (AXObjectCache* cache = document().existingAXObjectCache())
 721                 cache-&gt;childrenChanged(parent(), this);
 722         }
 723 
 724         // Keep layer hierarchy visibility bits up to date if visibility changes.
 725         if (m_style.visibility() != newStyle.visibility()) {
 726             if (RenderLayer* layer = enclosingLayer()) {
 727                 if (newStyle.visibility() == Visibility::Visible)
 728                     layer-&gt;setHasVisibleContent();
 729                 else if (layer-&gt;hasVisibleContent() &amp;&amp; (this == &amp;layer-&gt;renderer() || layer-&gt;renderer().style().visibility() != Visibility::Visible)) {
 730                     layer-&gt;dirtyVisibleContentStatus();
 731                     if (diff &gt; StyleDifference::RepaintLayer)
 732                         repaint();
 733                 }
 734             }
</pre>
<hr />
<pre>
 868         issueRepaintForOutlineAuto(hasOutlineAuto ? outlineStyleForRepaint().outlineSize() : oldStyle-&gt;outlineSize());
 869     }
 870 }
 871 
 872 void RenderElement::insertedIntoTree()
 873 {
 874     // Keep our layer hierarchy updated. Optimize for the common case where we don&#39;t have any children
 875     // and don&#39;t have a layer attached to ourselves.
 876     RenderLayer* layer = nullptr;
 877     if (firstChild() || hasLayer()) {
 878         layer = parent()-&gt;enclosingLayer();
 879         addLayers(layer);
 880     }
 881 
 882     // If |this| is visible but this object was not, tell the layer it has some visible content
 883     // that needs to be drawn and layer visibility optimization can&#39;t be used
 884     if (parent()-&gt;style().visibility() != Visibility::Visible &amp;&amp; style().visibility() == Visibility::Visible &amp;&amp; !hasLayer()) {
 885         if (!layer)
 886             layer = parent()-&gt;enclosingLayer();
 887         if (layer)
<span class="line-modified"> 888             layer-&gt;dirtyVisibleContentStatus();</span>
 889     }
 890 
 891     RenderObject::insertedIntoTree();
 892 }
 893 
 894 void RenderElement::willBeRemovedFromTree()
 895 {
 896     // If we remove a visible child from an invisible parent, we don&#39;t know the layer visibility any more.
 897     RenderLayer* layer = nullptr;
 898     if (parent()-&gt;style().visibility() != Visibility::Visible &amp;&amp; style().visibility() == Visibility::Visible &amp;&amp; !hasLayer()) {
 899         if ((layer = parent()-&gt;enclosingLayer()))
 900             layer-&gt;dirtyVisibleContentStatus();
 901     }
 902     // Keep our layer hierarchy updated.
 903     if (firstChild() || hasLayer()) {
 904         if (!layer)
 905             layer = parent()-&gt;enclosingLayer();
 906         removeLayers(layer);
 907     }
 908 
</pre>
<hr />
<pre>
1340         else
1341             image-&gt;startAnimation();
1342     }
1343 
1344     // For directly-composited animated GIFs it does not suffice to call repaint() to resume animation. We need to mark the image as changed.
1345     if (is&lt;RenderBoxModelObject&gt;(*this))
1346         downcast&lt;RenderBoxModelObject&gt;(*this).contentChanged(ImageChanged);
1347 
1348     return true;
1349 }
1350 
1351 const RenderStyle* RenderElement::getCachedPseudoStyle(PseudoId pseudo, const RenderStyle* parentStyle) const
1352 {
1353     if (pseudo &lt; PseudoId::FirstInternalPseudoId &amp;&amp; !style().hasPseudoStyle(pseudo))
1354         return nullptr;
1355 
1356     RenderStyle* cachedStyle = style().getCachedPseudoStyle(pseudo);
1357     if (cachedStyle)
1358         return cachedStyle;
1359 
<span class="line-modified">1360     std::unique_ptr&lt;RenderStyle&gt; result = getUncachedPseudoStyle({ pseudo }, parentStyle);</span>
1361     if (result)
1362         return const_cast&lt;RenderStyle&amp;&gt;(m_style).addCachedPseudoStyle(WTFMove(result));
1363     return nullptr;
1364 }
1365 
<span class="line-modified">1366 std::unique_ptr&lt;RenderStyle&gt; RenderElement::getUncachedPseudoStyle(const Style::PseudoElementRequest&amp; pseudoElementRequest, const RenderStyle* parentStyle, const RenderStyle* ownStyle) const</span>
1367 {
<span class="line-modified">1368     if (pseudoElementRequest.pseudoId &lt; PseudoId::FirstInternalPseudoId &amp;&amp; !ownStyle &amp;&amp; !style().hasPseudoStyle(pseudoElementRequest.pseudoId))</span>
1369         return nullptr;
1370 
1371     if (!parentStyle) {
1372         ASSERT(!ownStyle);
1373         parentStyle = &amp;style();
1374     }
1375 
1376     if (isAnonymous())
1377         return nullptr;
1378 
1379     auto&amp; styleResolver = element()-&gt;styleResolver();
1380 
<span class="line-modified">1381     std::unique_ptr&lt;RenderStyle&gt; style = styleResolver.pseudoStyleForElement(*element(), pseudoElementRequest, *parentStyle);</span>
1382 
1383     if (style)
1384         Style::loadPendingResources(*style, document(), element());
1385 
1386     return style;
1387 }
1388 
1389 Color RenderElement::selectionColor(CSSPropertyID colorProperty) const
1390 {
1391     // If the element is unselectable, or we are only painting the selection,
1392     // don&#39;t override the foreground color with the selection foreground color.
1393     if (style().userSelect() == UserSelect::None
1394         || (view().frameView().paintBehavior().containsAny({ PaintBehavior::SelectionOnly, PaintBehavior::SelectionAndBackgroundsOnly })))
1395         return Color();
1396 
1397     if (std::unique_ptr&lt;RenderStyle&gt; pseudoStyle = selectionPseudoStyle()) {
1398         Color color = pseudoStyle-&gt;visitedDependentColorWithColorFilter(colorProperty);
1399         if (!color.isValid())
1400             color = pseudoStyle-&gt;visitedDependentColorWithColorFilter(CSSPropertyColor);
1401         return color;
1402     }
1403 
1404     if (frame().selection().isFocusedAndActive())
1405         return theme().activeSelectionForegroundColor(styleColorOptions());
1406     return theme().inactiveSelectionForegroundColor(styleColorOptions());
1407 }
1408 
1409 std::unique_ptr&lt;RenderStyle&gt; RenderElement::selectionPseudoStyle() const
1410 {
1411     if (isAnonymous())
1412         return nullptr;
1413 
1414     if (ShadowRoot* root = element()-&gt;containingShadowRoot()) {
1415         if (root-&gt;mode() == ShadowRootMode::UserAgent) {
<span class="line-modified">1416             auto* currentElement = element()-&gt;shadowHost();</span>
<span class="line-modified">1417             // When an element has display: contents, this element doesn&#39;t have a renderer</span>
<span class="line-added">1418             // and its children will render as children of the parent element.</span>
<span class="line-added">1419             while (currentElement &amp;&amp; currentElement-&gt;hasDisplayContents())</span>
<span class="line-added">1420                 currentElement = currentElement-&gt;parentElement();</span>
<span class="line-added">1421             if (currentElement &amp;&amp; currentElement-&gt;renderer())</span>
<span class="line-added">1422                 return currentElement-&gt;renderer()-&gt;getUncachedPseudoStyle({ PseudoId::Selection });</span>
1423         }
1424     }
1425 
<span class="line-modified">1426     return getUncachedPseudoStyle({ PseudoId::Selection });</span>
1427 }
1428 
1429 Color RenderElement::selectionForegroundColor() const
1430 {
1431     return selectionColor(CSSPropertyWebkitTextFillColor);
1432 }
1433 
1434 Color RenderElement::selectionEmphasisMarkColor() const
1435 {
1436     return selectionColor(CSSPropertyWebkitTextEmphasisColor);
1437 }
1438 
1439 Color RenderElement::selectionBackgroundColor() const
1440 {
1441     if (style().userSelect() == UserSelect::None)
1442         return Color();
1443 
1444     if (frame().selection().shouldShowBlockCursor() &amp;&amp; frame().selection().isCaret())
1445         return theme().transformSelectionBackgroundColor(style().visitedDependentColorWithColorFilter(CSSPropertyColor), styleColorOptions());
1446 
</pre>
<hr />
<pre>
2020 {
2021     for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(*this)) {
2022         if (hasOutlineAuto == child.hasOutlineAutoAncestor())
2023             continue;
2024         child.setHasOutlineAutoAncestor(hasOutlineAuto);
2025         bool childHasOutlineAuto = child.outlineStyleForRepaint().outlineStyleIsAuto() == OutlineIsAuto::On;
2026         if (childHasOutlineAuto)
2027             continue;
2028         if (!is&lt;RenderElement&gt;(child))
2029             continue;
2030         downcast&lt;RenderElement&gt;(child).updateOutlineAutoAncestor(hasOutlineAuto);
2031     }
2032     if (is&lt;RenderBoxModelObject&gt;(*this)) {
2033         if (auto* continuation = downcast&lt;RenderBoxModelObject&gt;(*this).continuation())
2034             continuation-&gt;updateOutlineAutoAncestor(hasOutlineAuto);
2035     }
2036 }
2037 
2038 bool RenderElement::hasOutlineAnnotation() const
2039 {
<span class="line-modified">2040     return element() &amp;&amp; element()-&gt;isLink() &amp;&amp; (document().printing() || (view().frameView().paintBehavior() &amp; PaintBehavior::AnnotateLinks));</span>
2041 }
2042 
2043 bool RenderElement::hasSelfPaintingLayer() const
2044 {
2045     if (!hasLayer())
2046         return false;
2047     auto&amp; layerModelObject = downcast&lt;RenderLayerModelObject&gt;(*this);
2048     return layerModelObject.hasSelfPaintingLayer();
2049 }
2050 
2051 bool RenderElement::checkForRepaintDuringLayout() const
2052 {
2053     if (document().view()-&gt;layoutContext().needsFullRepaint() || !everHadLayout() || hasSelfPaintingLayer())
2054         return false;
2055     return !settings().repaintOutsideLayoutEnabled();
2056 }
2057 
2058 ImageOrientation RenderElement::imageOrientation() const
2059 {









2060     return style().imageOrientation();
2061 }
2062 
2063 void RenderElement::adjustFragmentedFlowStateOnContainingBlockChangeIfNeeded()
2064 {
2065     if (fragmentedFlowState() == NotInsideFragmentedFlow)
2066         return;
2067 
2068     // Invalidate the containing block caches.
2069     if (is&lt;RenderBlock&gt;(*this))
2070         downcast&lt;RenderBlock&gt;(*this).resetEnclosingFragmentedFlowAndChildInfoIncludingDescendants();
2071 
2072     // Adjust the flow tread state on the subtree.
2073     setFragmentedFlowState(RenderObject::computedFragmentedFlowState(*this));
2074     for (auto&amp; descendant : descendantsOfType&lt;RenderObject&gt;(*this))
2075         descendant.setFragmentedFlowState(RenderObject::computedFragmentedFlowState(descendant));
2076 }
2077 
2078 void RenderElement::removeFromRenderFragmentedFlow()
2079 {
</pre>
</td>
</tr>
</table>
<center><a href="RenderDeprecatedFlexibleBox.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
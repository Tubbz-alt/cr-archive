<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/ThreadTimers.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ThreadGlobalData.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Timer.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/ThreadTimers.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 39 class ThreadTimers;
 40 class TimerBase;
 41 
 42 struct ThreadTimerHeapItem;
 43 typedef Vector&lt;RefPtr&lt;ThreadTimerHeapItem&gt;&gt; ThreadTimerHeap;
 44 
 45 // A collection of timers per thread. Kept in ThreadGlobalData.
 46 class ThreadTimers {
 47     WTF_MAKE_NONCOPYABLE(ThreadTimers); WTF_MAKE_FAST_ALLOCATED;
 48 public:
 49     ThreadTimers();
 50 
 51     // On a thread different then main, we should set the thread&#39;s instance of the SharedTimer.
 52     void setSharedTimer(SharedTimer*);
 53 
 54     ThreadTimerHeap&amp; timerHeap() { return m_timerHeap; }
 55 
 56     void updateSharedTimer();
 57     void fireTimersInNestedEventLoop();
 58 


 59 private:
 60     void sharedTimerFiredInternal();
 61     void fireTimersInNestedEventLoopInternal();
 62 
 63     ThreadTimerHeap m_timerHeap;
 64     SharedTimer* m_sharedTimer { nullptr }; // External object, can be a run loop on a worker thread. Normally set/reset by worker thread.
 65     bool m_firingTimers { false }; // Reentrancy guard.

 66     MonotonicTime m_pendingSharedTimerFireTime;
 67 };
 68 
 69 struct ThreadTimerHeapItem : ThreadSafeRefCounted&lt;ThreadTimerHeapItem&gt; {
 70     static RefPtr&lt;ThreadTimerHeapItem&gt; create(TimerBase&amp;, MonotonicTime, unsigned);
 71 
 72     bool hasTimer() const { return m_timer; }
 73     TimerBase&amp; timer();
 74     void clearTimer();
 75 
 76     ThreadTimerHeap&amp; timerHeap() const;
 77 
 78     unsigned heapIndex() const;
 79     void setHeapIndex(unsigned newIndex);
 80     void setNotInHeap() { m_heapIndex = invalidHeapIndex; }
 81 
 82     bool isInHeap() const { return m_heapIndex != invalidHeapIndex; }
 83     bool isFirstInHeap() const { return !m_heapIndex; }
 84 
 85     MonotonicTime time;
</pre>
</td>
<td>
<hr />
<pre>
 39 class ThreadTimers;
 40 class TimerBase;
 41 
 42 struct ThreadTimerHeapItem;
 43 typedef Vector&lt;RefPtr&lt;ThreadTimerHeapItem&gt;&gt; ThreadTimerHeap;
 44 
 45 // A collection of timers per thread. Kept in ThreadGlobalData.
 46 class ThreadTimers {
 47     WTF_MAKE_NONCOPYABLE(ThreadTimers); WTF_MAKE_FAST_ALLOCATED;
 48 public:
 49     ThreadTimers();
 50 
 51     // On a thread different then main, we should set the thread&#39;s instance of the SharedTimer.
 52     void setSharedTimer(SharedTimer*);
 53 
 54     ThreadTimerHeap&amp; timerHeap() { return m_timerHeap; }
 55 
 56     void updateSharedTimer();
 57     void fireTimersInNestedEventLoop();
 58 
<span class="line-added"> 59     unsigned nextHeapInsertionCount() { return m_currentHeapInsertionOrder++; }</span>
<span class="line-added"> 60 </span>
 61 private:
 62     void sharedTimerFiredInternal();
 63     void fireTimersInNestedEventLoopInternal();
 64 
 65     ThreadTimerHeap m_timerHeap;
 66     SharedTimer* m_sharedTimer { nullptr }; // External object, can be a run loop on a worker thread. Normally set/reset by worker thread.
 67     bool m_firingTimers { false }; // Reentrancy guard.
<span class="line-added"> 68     unsigned m_currentHeapInsertionOrder { 0 };</span>
 69     MonotonicTime m_pendingSharedTimerFireTime;
 70 };
 71 
 72 struct ThreadTimerHeapItem : ThreadSafeRefCounted&lt;ThreadTimerHeapItem&gt; {
 73     static RefPtr&lt;ThreadTimerHeapItem&gt; create(TimerBase&amp;, MonotonicTime, unsigned);
 74 
 75     bool hasTimer() const { return m_timer; }
 76     TimerBase&amp; timer();
 77     void clearTimer();
 78 
 79     ThreadTimerHeap&amp; timerHeap() const;
 80 
 81     unsigned heapIndex() const;
 82     void setHeapIndex(unsigned newIndex);
 83     void setNotInHeap() { m_heapIndex = invalidHeapIndex; }
 84 
 85     bool isInHeap() const { return m_heapIndex != invalidHeapIndex; }
 86     bool isFirstInHeap() const { return !m_heapIndex; }
 87 
 88     MonotonicTime time;
</pre>
</td>
</tr>
</table>
<center><a href="ThreadGlobalData.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Timer.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/testair.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="opcode_generator.rb.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../testb3.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/testair.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (C) 2016-2018 Apple Inc. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -36,12 +36,14 @@</span>
  #include &quot;B3PatchpointSpecial.h&quot;
  #include &quot;CCallHelpers.h&quot;
  #include &quot;InitializeThreading.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;LinkBuffer.h&quot;
<span class="udiff-line-added">+ #include &quot;ProbeContext.h&quot;</span>
  #include &quot;PureNaN.h&quot;
  #include &lt;cmath&gt;
<span class="udiff-line-added">+ #include &lt;regex&gt;</span>
  #include &lt;string&gt;
  #include &lt;wtf/Lock.h&gt;
  #include &lt;wtf/NumberOfCores.h&gt;
  #include &lt;wtf/StdMap.h&gt;
  #include &lt;wtf/Threading.h&gt;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2061,10 +2063,166 @@</span>
  
      int32_t r = compileAndRun&lt;int32_t&gt;(proc, a);
      CHECK(r == a + b);
  }
  
<span class="udiff-line-added">+ inline Vector&lt;String&gt; matchAll(const CString&amp; source, std::regex regex)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     Vector&lt;String&gt; matches;</span>
<span class="udiff-line-added">+     std::smatch match;</span>
<span class="udiff-line-added">+     for (std::string str = source.data(); std::regex_search(str, match, regex); str = match.suffix()) {</span>
<span class="udiff-line-added">+         ASSERT(match.size() == 1);</span>
<span class="udiff-line-added">+         matches.append(match[0].str().c_str());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     return matches;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void testElideSimpleMove()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     for (unsigned tmpCount = 1; tmpCount &lt; 100; tmpCount++) {</span>
<span class="udiff-line-added">+         B3::Procedure proc;</span>
<span class="udiff-line-added">+         Code&amp; code = proc.code();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         BasicBlock* root = code.addBlock();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         Tmp tmp = code.newTmp(B3::GP);</span>
<span class="udiff-line-added">+         root-&gt;append(Move, nullptr, Tmp(GPRInfo::argumentGPR0), tmp);</span>
<span class="udiff-line-added">+         for (unsigned i = 0; i &lt; tmpCount; i++) {</span>
<span class="udiff-line-added">+             Tmp newTmp = code.newTmp(B3::GP);</span>
<span class="udiff-line-added">+             root-&gt;append(Move, nullptr, tmp, newTmp);</span>
<span class="udiff-line-added">+             tmp = newTmp;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         root-&gt;append(Move, nullptr, tmp, Tmp(GPRInfo::returnValueGPR));</span>
<span class="udiff-line-added">+         root-&gt;append(Ret32, nullptr, Tmp(GPRInfo::returnValueGPR));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         auto compilation = compile(proc);</span>
<span class="udiff-line-added">+         CString disassembly = compilation-&gt;disassembly();</span>
<span class="udiff-line-added">+         std::regex findRRMove(isARM64() ? &quot;mov r\\d+, r\\d+\\n&quot; : &quot;mov %\\w+, %\\w+\\n&quot;);</span>
<span class="udiff-line-added">+         auto result = matchAll(disassembly, findRRMove);</span>
<span class="udiff-line-added">+         // sp -&gt; fp; arg0 -&gt; ret0; fp -&gt; sp</span>
<span class="udiff-line-added">+         // fp -&gt; sp only happens in O0 because we don&#39;t actually need to move the stack in general.</span>
<span class="udiff-line-added">+         CHECK(result.size() == 2 + !Options::defaultB3OptLevel());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void testElideHandlesEarlyClobber()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     B3::Procedure proc;</span>
<span class="udiff-line-added">+     Code&amp; code = proc.code();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     BasicBlock* root = code.addBlock();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     const unsigned tmpCount = RegisterSet::allGPRs().numberOfSetRegisters() * 2;</span>
<span class="udiff-line-added">+     Vector&lt;Tmp&gt; tmps(tmpCount);</span>
<span class="udiff-line-added">+     for (unsigned i = 0; i &lt; tmpCount; ++i) {</span>
<span class="udiff-line-added">+         tmps[i] = code.newTmp(B3::GP);</span>
<span class="udiff-line-added">+         root-&gt;append(Move, nullptr, Arg::imm(i), tmps[i]);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     RegisterSet registers = RegisterSet::allGPRs();</span>
<span class="udiff-line-added">+     registers.exclude(RegisterSet::reservedHardwareRegisters());</span>
<span class="udiff-line-added">+     registers.exclude(RegisterSet::stackRegisters());</span>
<span class="udiff-line-added">+     Reg firstCalleeSave;</span>
<span class="udiff-line-added">+     Reg lastCalleeSave;</span>
<span class="udiff-line-added">+     auto* patch = proc.add&lt;B3::PatchpointValue&gt;(B3::Int32, B3::Origin());</span>
<span class="udiff-line-added">+     patch-&gt;clobberEarly(registers);</span>
<span class="udiff-line-added">+     for (Reg reg : registers) {</span>
<span class="udiff-line-added">+         if (!firstCalleeSave)</span>
<span class="udiff-line-added">+             firstCalleeSave = reg;</span>
<span class="udiff-line-added">+         lastCalleeSave = reg;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     ASSERT(firstCalleeSave != lastCalleeSave);</span>
<span class="udiff-line-added">+     patch-&gt;earlyClobbered().clear(firstCalleeSave);</span>
<span class="udiff-line-added">+     patch-&gt;resultConstraints.append({ B3::ValueRep::reg(firstCalleeSave) });</span>
<span class="udiff-line-added">+     patch-&gt;earlyClobbered().clear(lastCalleeSave);</span>
<span class="udiff-line-added">+     patch-&gt;clobber(RegisterSet(lastCalleeSave));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     patch-&gt;setGenerator([=] (CCallHelpers&amp; jit, const JSC::B3::StackmapGenerationParams&amp;) {</span>
<span class="udiff-line-added">+         jit.probe([=] (Probe::Context&amp; context) {</span>
<span class="udiff-line-added">+             for (Reg reg : registers)</span>
<span class="udiff-line-added">+                 context.gpr(reg.gpr()) = 0;</span>
<span class="udiff-line-added">+         });</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Inst inst(Patch, patch, Arg::special(code.addSpecial(WTF::makeUnique&lt;JSC::B3::PatchpointSpecial&gt;())));</span>
<span class="udiff-line-added">+     inst.args.append(Tmp(firstCalleeSave));</span>
<span class="udiff-line-added">+     root-&gt;appendInst(WTFMove(inst));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     Tmp result = code.newTmp(B3::GP);</span>
<span class="udiff-line-added">+     root-&gt;append(Move, nullptr, tmps[0], result);</span>
<span class="udiff-line-added">+     for (Tmp tmp : tmps)</span>
<span class="udiff-line-added">+         root-&gt;append(Add32, nullptr, tmp, result);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     root-&gt;append(Move, nullptr, result, Tmp(GPRInfo::returnValueGPR));</span>
<span class="udiff-line-added">+     root-&gt;append(Ret32, nullptr, Tmp(GPRInfo::returnValueGPR));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     auto runResult = compileAndRun&lt;uint32_t&gt;(proc);</span>
<span class="udiff-line-added">+     CHECK(runResult == (tmpCount * (tmpCount - 1)) / 2);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void testElideMoveThenRealloc()</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     RegisterSet registers = RegisterSet::allGPRs();</span>
<span class="udiff-line-added">+     registers.exclude(RegisterSet::stackRegisters());</span>
<span class="udiff-line-added">+     registers.exclude(RegisterSet::reservedHardwareRegisters());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     for (Reg reg : registers) {</span>
<span class="udiff-line-added">+         B3::Procedure proc;</span>
<span class="udiff-line-added">+         Code&amp; code = proc.code();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         BasicBlock* root = code.addBlock();</span>
<span class="udiff-line-added">+         BasicBlock* taken = code.addBlock();</span>
<span class="udiff-line-added">+         BasicBlock* notTaken = code.addBlock();</span>
<span class="udiff-line-added">+         BasicBlock* notTakenReturn = code.addBlock();</span>
<span class="udiff-line-added">+         BasicBlock* ret = code.addBlock();</span>
<span class="udiff-line-added">+         BasicBlock* continuation = code.addBlock();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         Tmp tmp = code.newTmp(B3::GP);</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             root-&gt;append(Move, nullptr, Arg::imm(1), Tmp(reg));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             root-&gt;append(BranchTest32, nullptr, Arg::resCond(MacroAssembler::NonZero), Tmp(reg), Arg::bitImm(-1));</span>
<span class="udiff-line-added">+             root-&gt;setSuccessors(taken, notTaken);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             taken-&gt;append(Jump, nullptr);</span>
<span class="udiff-line-added">+             taken-&gt;setSuccessors(continuation);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             notTaken-&gt;append(BranchTest32, nullptr, Arg::resCond(MacroAssembler::NonZero), Tmp(reg), Arg::bitImm(-1));</span>
<span class="udiff-line-added">+             notTaken-&gt;setSuccessors(continuation, notTakenReturn);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             tmp = code.newTmp(B3::GP);</span>
<span class="udiff-line-added">+             continuation-&gt;append(Move, nullptr, Arg::imm(42), tmp);</span>
<span class="udiff-line-added">+             continuation-&gt;append(BranchTest32, nullptr, Arg::resCond(MacroAssembler::NonZero), tmp, Arg::bitImm(-1));</span>
<span class="udiff-line-added">+             continuation-&gt;setSuccessors(ret, notTakenReturn);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             tmp = code.newTmp(B3::GP);</span>
<span class="udiff-line-added">+             ret-&gt;append(Move, nullptr, Arg::imm(42), tmp);</span>
<span class="udiff-line-added">+             ret-&gt;append(Move, nullptr, tmp, Tmp(reg));</span>
<span class="udiff-line-added">+             ret-&gt;append(Move, nullptr, Tmp(reg), Tmp(GPRInfo::returnValueGPR));</span>
<span class="udiff-line-added">+             ret-&gt;append(Add32, nullptr, Tmp(reg), Tmp(reg));</span>
<span class="udiff-line-added">+             ret-&gt;append(Ret32, nullptr, Tmp(GPRInfo::returnValueGPR));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             notTakenReturn-&gt;append(Move, nullptr, Tmp(reg), Tmp(GPRInfo::returnValueGPR));</span>
<span class="udiff-line-added">+             notTakenReturn-&gt;append(Ret32, nullptr, Tmp(GPRInfo::returnValueGPR));</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         code.resetReachability();</span>
<span class="udiff-line-added">+         auto runResult = compileAndRun&lt;uint32_t&gt;(proc);</span>
<span class="udiff-line-added">+         CHECK(runResult == static_cast&lt;unsigned&gt;(42 + (42 * (reg == GPRInfo::returnValueGPR))));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  #define PREFIX &quot;O&quot;, Options::defaultB3OptLevel(), &quot;: &quot;
  
  #define RUN(test) do {                                 \
          if (!shouldRun(#test))                         \
              break;                                     \
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2149,10 +2307,14 @@</span>
      RUN(testArgumentRegPinned3());
  
      RUN(testLea32());
      RUN(testLea64());
  
<span class="udiff-line-added">+     RUN(testElideSimpleMove());</span>
<span class="udiff-line-added">+     RUN(testElideHandlesEarlyClobber());</span>
<span class="udiff-line-added">+     RUN(testElideMoveThenRealloc());</span>
<span class="udiff-line-added">+ </span>
      if (tasks.isEmpty())
          usage();
  
      Lock lock;
  
</pre>
<center><a href="opcode_generator.rb.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../testb3.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
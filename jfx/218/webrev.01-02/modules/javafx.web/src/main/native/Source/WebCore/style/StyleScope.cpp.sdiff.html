<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/style/StyleScope.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StyleResolveForDocument.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleScope.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/style/StyleScope.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 71 {
 72 }
 73 
 74 Scope::~Scope()
 75 {
 76     ASSERT(!hasPendingSheets());
 77 }
 78 
 79 bool Scope::shouldUseSharedUserAgentShadowTreeStyleResolver() const
 80 {
 81     if (!m_shadowRoot)
 82         return false;
 83     if (m_shadowRoot-&gt;mode() != ShadowRootMode::UserAgent)
 84         return false;
 85     // If we have stylesheets in the user agent shadow tree use per-scope resolver.
 86     if (!m_styleSheetCandidateNodes.isEmpty())
 87         return false;
 88     return true;
 89 }
 90 
<span class="line-modified"> 91 StyleResolver&amp; Scope::resolver()</span>
 92 {
 93     if (shouldUseSharedUserAgentShadowTreeStyleResolver())
 94         return m_document.userAgentShadowTreeStyleResolver();
 95 
 96     if (!m_resolver) {
 97         SetForScope&lt;bool&gt; isUpdatingStyleResolver { m_isUpdatingStyleResolver, true };
 98 
<span class="line-modified"> 99         m_resolver = makeUnique&lt;StyleResolver&gt;(m_document);</span>
100 
101         if (!m_shadowRoot) {
102             m_document.fontSelector().buildStarted();
103             m_resolver-&gt;ruleSets().initializeUserStyle();
104         } else {
105             m_resolver-&gt;ruleSets().setIsForShadowScope();
106             m_resolver-&gt;ruleSets().setUsesSharedUserStyle(m_shadowRoot-&gt;mode() != ShadowRootMode::UserAgent);
107         }
108 
109         m_resolver-&gt;addCurrentSVGFontFaceRules();
110         m_resolver-&gt;appendAuthorStyleSheets(m_activeStyleSheets);
111 
112         if (!m_shadowRoot)
113             m_document.fontSelector().buildCompleted();
114     }
115     ASSERT(!m_shadowRoot || &amp;m_document == &amp;m_shadowRoot-&gt;document());
116     ASSERT(&amp;m_resolver-&gt;document() == &amp;m_document);
117     return *m_resolver;
118 }
119 
<span class="line-modified">120 StyleResolver* Scope::resolverIfExists()</span>
121 {
122     if (shouldUseSharedUserAgentShadowTreeStyleResolver())
123         return &amp;m_document.userAgentShadowTreeStyleResolver();
124 
125     return m_resolver.get();
126 }
127 
128 void Scope::clearResolver()
129 {
130     m_resolver = nullptr;
131 
132     if (!m_shadowRoot)
133         m_document.didClearStyleResolver();
134 }
135 
136 void Scope::releaseMemory()
137 {
138     if (!m_shadowRoot) {
139         for (auto* descendantShadowRoot : m_document.inDocumentShadowRoots())
140             descendantShadowRoot-&gt;styleScope().releaseMemory();
</pre>
<hr />
<pre>
364                 if (m_preferredStylesheetSetName.isEmpty()) {
365                     // No preferred set has been established. If
366                     // we are NOT an alternate sheet, then establish
367                     // us as the preferred set. Otherwise, just ignore
368                     // this sheet.
369                     if (is&lt;HTMLStyleElement&gt;(element) || !rel.contains(&quot;alternate&quot;))
370                         m_preferredStylesheetSetName = title;
371                 }
372                 if (title != m_preferredStylesheetSetName)
373                     sheet = nullptr;
374             }
375 
376             if (rel.contains(&quot;alternate&quot;) &amp;&amp; title.isEmpty())
377                 sheet = nullptr;
378         }
379         if (sheet)
380             sheets.append(WTFMove(sheet));
381     }
382 }
383 
<span class="line-modified">384 Scope::StyleResolverUpdateType Scope::analyzeStyleSheetChange(const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; newStylesheets, bool&amp; requiresFullStyleRecalc)</span>
385 {
<span class="line-removed">386     requiresFullStyleRecalc = true;</span>
<span class="line-removed">387 </span>
388     unsigned newStylesheetCount = newStylesheets.size();
389 
390     if (!resolverIfExists())
<span class="line-modified">391         return Reconstruct;</span>
<span class="line-removed">392 </span>
<span class="line-removed">393     auto&amp; styleResolver = *resolverIfExists();</span>
394 
395     // Find out which stylesheets are new.
396     unsigned oldStylesheetCount = m_activeStyleSheets.size();
397     if (newStylesheetCount &lt; oldStylesheetCount)
<span class="line-modified">398         return Reconstruct;</span>
399 
400     Vector&lt;StyleSheetContents*&gt; addedSheets;
401     unsigned newIndex = 0;
402     for (unsigned oldIndex = 0; oldIndex &lt; oldStylesheetCount; ++oldIndex) {
403         if (newIndex &gt;= newStylesheetCount)
<span class="line-modified">404             return Reconstruct;</span>

405         while (m_activeStyleSheets[oldIndex] != newStylesheets[newIndex]) {
406             addedSheets.append(&amp;newStylesheets[newIndex]-&gt;contents());
407             ++newIndex;
408             if (newIndex == newStylesheetCount)
<span class="line-modified">409                 return Reconstruct;</span>
410         }
411         ++newIndex;
412     }
413     bool hasInsertions = !addedSheets.isEmpty();
414     while (newIndex &lt; newStylesheetCount) {
415         addedSheets.append(&amp;newStylesheets[newIndex]-&gt;contents());
416         ++newIndex;
417     }
<span class="line-removed">418     // If all new sheets were added at the end of the list we can just add them to existing StyleResolver.</span>
<span class="line-removed">419     // If there were insertions we need to re-add all the stylesheets so rules are ordered correctly.</span>
<span class="line-removed">420     auto styleResolverUpdateType = hasInsertions ? Reset : Additive;</span>
<span class="line-removed">421 </span>
<span class="line-removed">422     // If we are already parsing the body and so may have significant amount of elements, put some effort into trying to avoid style recalcs.</span>
<span class="line-removed">423     if (!m_document.bodyOrFrameset() || m_document.hasNodesWithNonFinalStyle() || m_document.hasNodesWithMissingStyle())</span>
<span class="line-removed">424         return styleResolverUpdateType;</span>
425 
<span class="line-modified">426     Invalidator invalidator(addedSheets, styleResolver.mediaQueryEvaluator());</span>
<span class="line-modified">427     if (invalidator.dirtiesAllStyle())</span>
<span class="line-modified">428         return styleResolverUpdateType;</span>
<span class="line-removed">429 </span>
<span class="line-removed">430     if (m_shadowRoot)</span>
<span class="line-removed">431         invalidator.invalidateStyle(*m_shadowRoot);</span>
<span class="line-removed">432     else</span>
<span class="line-removed">433         invalidator.invalidateStyle(m_document);</span>
<span class="line-removed">434 </span>
<span class="line-removed">435     requiresFullStyleRecalc = false;</span>
<span class="line-removed">436 </span>
<span class="line-removed">437     return styleResolverUpdateType;</span>
438 }
439 
440 static void filterEnabledNonemptyCSSStyleSheets(Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; result, const Vector&lt;RefPtr&lt;StyleSheet&gt;&gt;&amp; sheets)
441 {
442     for (auto&amp; sheet : sheets) {
443         if (!is&lt;CSSStyleSheet&gt;(*sheet))
444             continue;
445         CSSStyleSheet&amp; styleSheet = downcast&lt;CSSStyleSheet&gt;(*sheet);
446         if (styleSheet.isLoading())
447             continue;
448         if (styleSheet.disabled())
449             continue;
450         if (!styleSheet.length())
451             continue;
452         result.append(&amp;styleSheet);
453     }
454 }
455 
<span class="line-removed">456 static void invalidateHostAndSlottedStyleIfNeeded(ShadowRoot&amp; shadowRoot, StyleResolver&amp; resolver)</span>
<span class="line-removed">457 {</span>
<span class="line-removed">458     auto&amp; host = *shadowRoot.host();</span>
<span class="line-removed">459     if (!resolver.ruleSets().authorStyle().hostPseudoClassRules().isEmpty())</span>
<span class="line-removed">460         host.invalidateStyle();</span>
<span class="line-removed">461 </span>
<span class="line-removed">462     if (!resolver.ruleSets().authorStyle().slottedPseudoElementRules().isEmpty()) {</span>
<span class="line-removed">463         for (auto&amp; shadowChild : childrenOfType&lt;Element&gt;(host))</span>
<span class="line-removed">464             shadowChild.invalidateStyle();</span>
<span class="line-removed">465     }</span>
<span class="line-removed">466 }</span>
<span class="line-removed">467 </span>
468 void Scope::updateActiveStyleSheets(UpdateType updateType)
469 {
470     ASSERT(!m_pendingUpdate);
471 
472     if (!m_document.hasLivingRenderTree())
473         return;
474 
475     if (m_document.inStyleRecalc() || m_document.inRenderTreeUpdate()) {
476         // Protect against deleting style resolver in the middle of a style resolution.
477         // Crash stacks indicate we can get here when a resource load fails synchronously (for example due to content blocking).
478         // FIXME: These kind of cases should be eliminated and this path replaced by an assert.
479         m_pendingUpdate = UpdateType::ContentsOrInterpretation;
480         m_document.scheduleFullStyleRebuild();
481         return;
482     }
483 
484     Vector&lt;RefPtr&lt;StyleSheet&gt;&gt; activeStyleSheets;
485     collectActiveStyleSheets(activeStyleSheets);
486 
487     Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt; activeCSSStyleSheets;
488     activeCSSStyleSheets.appendVector(m_document.extensionStyleSheets().injectedAuthorStyleSheets());
489     activeCSSStyleSheets.appendVector(m_document.extensionStyleSheets().authorStyleSheetsForTesting());
490     filterEnabledNonemptyCSSStyleSheets(activeCSSStyleSheets, activeStyleSheets);
491 
<span class="line-modified">492     bool requiresFullStyleRecalc = true;</span>
<span class="line-removed">493     StyleResolverUpdateType styleResolverUpdateType = Reconstruct;</span>
494     if (updateType == UpdateType::ActiveSet)
<span class="line-modified">495         styleResolverUpdateType = analyzeStyleSheetChange(activeCSSStyleSheets, requiresFullStyleRecalc);</span>
496 
<span class="line-modified">497     updateStyleResolver(activeCSSStyleSheets, styleResolverUpdateType);</span>
498 
499     m_weakCopyOfActiveStyleSheetListForFastLookup = nullptr;
500     m_activeStyleSheets.swap(activeCSSStyleSheets);
501     m_styleSheetsForStyleSheetList.swap(activeStyleSheets);
502 
503     InspectorInstrumentation::activeStyleSheetsUpdated(m_document);
504 
505     for (const auto&amp; sheet : m_activeStyleSheets) {
506         if (sheet-&gt;contents().usesStyleBasedEditability())
507             m_usesStyleBasedEditability = true;
508     }
509 
<span class="line-modified">510     // FIXME: Move this code somewhere else.</span>
<span class="line-modified">511     if (requiresFullStyleRecalc) {</span>
<span class="line-modified">512         if (m_shadowRoot) {</span>
<span class="line-modified">513             for (auto&amp; shadowChild : childrenOfType&lt;Element&gt;(*m_shadowRoot))</span>
<span class="line-modified">514                 shadowChild.invalidateStyleForSubtree();</span>
<span class="line-modified">515             invalidateHostAndSlottedStyleIfNeeded(*m_shadowRoot, resolver());</span>
<span class="line-modified">516         } else</span>
<span class="line-modified">517             m_document.scheduleFullStyleRebuild();</span>



518     }



519 }
520 
<span class="line-modified">521 void Scope::updateStyleResolver(Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; activeStyleSheets, StyleResolverUpdateType updateType)</span>
522 {
<span class="line-modified">523     if (updateType == Reconstruct) {</span>
524         clearResolver();
525         return;
526     }
527     auto&amp; styleResolver = resolver();
528 
529     SetForScope&lt;bool&gt; isUpdatingStyleResolver { m_isUpdatingStyleResolver, true };
<span class="line-modified">530     if (updateType == Reset) {</span>
531         styleResolver.ruleSets().resetAuthorStyle();
532         styleResolver.appendAuthorStyleSheets(activeStyleSheets);
533     } else {
<span class="line-modified">534         ASSERT(updateType == Additive);</span>
535         unsigned firstNewIndex = m_activeStyleSheets.size();
536         Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt; newStyleSheets;
537         newStyleSheets.appendRange(activeStyleSheets.begin() + firstNewIndex, activeStyleSheets.end());
538         styleResolver.appendAuthorStyleSheets(newStyleSheets);
539     }
540 }
541 
542 const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt; Scope::activeStyleSheetsForInspector()
543 {
544     Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt; result;
545 




546     result.appendVector(m_document.extensionStyleSheets().injectedAuthorStyleSheets());
547     result.appendVector(m_document.extensionStyleSheets().authorStyleSheetsForTesting());
548 
549     for (auto&amp; styleSheet : m_styleSheetsForStyleSheetList) {
550         if (!is&lt;CSSStyleSheet&gt;(*styleSheet))
551             continue;
552 
553         CSSStyleSheet&amp; sheet = downcast&lt;CSSStyleSheet&gt;(*styleSheet);
554         if (sheet.disabled())
555             continue;
556 
557         result.append(&amp;sheet);
558     }
559 
560     return result;
561 }
562 
563 bool Scope::activeStyleSheetsContains(const CSSStyleSheet* sheet) const
564 {
565     if (!m_weakCopyOfActiveStyleSheetListForFastLookup) {
</pre>
<hr />
<pre>
582 
583 void Scope::flushPendingDescendantUpdates()
584 {
585     ASSERT(m_hasDescendantWithPendingUpdate);
586     ASSERT(!m_shadowRoot);
587     for (auto* descendantShadowRoot : m_document.inDocumentShadowRoots())
588         descendantShadowRoot-&gt;styleScope().flushPendingUpdate();
589     m_hasDescendantWithPendingUpdate = false;
590 }
591 
592 void Scope::clearPendingUpdate()
593 {
594     m_pendingUpdateTimer.stop();
595     m_pendingUpdate = { };
596 }
597 
598 void Scope::scheduleUpdate(UpdateType update)
599 {
600     if (update == UpdateType::ContentsOrInterpretation) {
601         // :host and ::slotted rules might go away.
<span class="line-modified">602         if (m_shadowRoot &amp;&amp; m_resolver)</span>
<span class="line-modified">603             invalidateHostAndSlottedStyleIfNeeded(*m_shadowRoot, *m_resolver);</span>
604         // FIXME: Animation code may trigger resource load in middle of style recalc and that can add a rule to a content extension stylesheet.
605         //        Fix and remove isResolvingTreeStyle() test below, see https://bugs.webkit.org/show_bug.cgi?id=194335
<span class="line-modified">606         // FIXME: The m_isUpdatingStyleResolver test is here because extension stylesheets can get us here from StyleResolver::appendAuthorStyleSheets.</span>
607         if (!m_isUpdatingStyleResolver &amp;&amp; !m_document.isResolvingTreeStyle())
608             clearResolver();
609     }
610 
611     if (!m_pendingUpdate || *m_pendingUpdate &lt; update) {
612         m_pendingUpdate = update;
613         if (m_shadowRoot)
614             m_document.styleScope().m_hasDescendantWithPendingUpdate = true;
615     }
616 
617     if (m_pendingUpdateTimer.isActive())
618         return;
619     m_pendingUpdateTimer.startOneShot(0_s);
620 }
621 
622 void Scope::evaluateMediaQueriesForViewportChange()
623 {
<span class="line-modified">624     evaluateMediaQueries([] (StyleResolver&amp; resolver) {</span>
<span class="line-modified">625         return resolver.hasMediaQueriesAffectedByViewportChange();</span>
626     });
627 }
628 
629 void Scope::evaluateMediaQueriesForAccessibilitySettingsChange()
630 {
<span class="line-modified">631     evaluateMediaQueries([] (StyleResolver&amp; resolver) {</span>
<span class="line-modified">632         return resolver.hasMediaQueriesAffectedByAccessibilitySettingsChange();</span>
633     });
634 }
635 
636 void Scope::evaluateMediaQueriesForAppearanceChange()
637 {
<span class="line-modified">638     evaluateMediaQueries([] (StyleResolver&amp; resolver) {</span>
<span class="line-modified">639         return resolver.hasMediaQueriesAffectedByAppearanceChange();</span>
640     });
641 }
642 
643 template &lt;typename TestFunction&gt;
644 void Scope::evaluateMediaQueries(TestFunction&amp;&amp; testFunction)
645 {




















646     if (!m_shadowRoot) {
647         for (auto* descendantShadowRoot : m_document.inDocumentShadowRoots())
648             descendantShadowRoot-&gt;styleScope().evaluateMediaQueries(testFunction);
649     }
<span class="line-removed">650     auto* resolver = resolverIfExists();</span>
<span class="line-removed">651     if (!resolver)</span>
<span class="line-removed">652         return;</span>
<span class="line-removed">653     if (!testFunction(*resolver))</span>
<span class="line-removed">654         return;</span>
<span class="line-removed">655     scheduleUpdate(UpdateType::ContentsOrInterpretation);</span>
<span class="line-removed">656     InspectorInstrumentation::mediaQueryResultChanged(m_document);</span>
657 }
658 
659 void Scope::didChangeActiveStyleSheetCandidates()
660 {
661     scheduleUpdate(UpdateType::ActiveSet);
662 }
663 
664 void Scope::didChangeStyleSheetContents()
665 {
666     scheduleUpdate(UpdateType::ContentsOrInterpretation);
667 }
668 
669 void Scope::didChangeStyleSheetEnvironment()
670 {
671     if (!m_shadowRoot) {
672         for (auto* descendantShadowRoot : m_document.inDocumentShadowRoots()) {
673             // Stylesheets is author shadow roots are potentially affected.
674             if (descendantShadowRoot-&gt;mode() != ShadowRootMode::UserAgent)
675                 descendantShadowRoot-&gt;styleScope().scheduleUpdate(UpdateType::ContentsOrInterpretation);
676         }
677     }
678     scheduleUpdate(UpdateType::ContentsOrInterpretation);
679 }
680 












681 void Scope::pendingUpdateTimerFired()
682 {
683     flushPendingUpdate();
684 }
685 
686 const Vector&lt;RefPtr&lt;StyleSheet&gt;&gt;&amp; Scope::styleSheetsForStyleSheetList()
687 {
688     // FIXME: StyleSheetList content should be updated separately from style resolver updates.
689     flushPendingUpdate();
690     return m_styleSheetsForStyleSheetList;
691 }
692 
693 }
694 }
</pre>
</td>
<td>
<hr />
<pre>
 71 {
 72 }
 73 
 74 Scope::~Scope()
 75 {
 76     ASSERT(!hasPendingSheets());
 77 }
 78 
 79 bool Scope::shouldUseSharedUserAgentShadowTreeStyleResolver() const
 80 {
 81     if (!m_shadowRoot)
 82         return false;
 83     if (m_shadowRoot-&gt;mode() != ShadowRootMode::UserAgent)
 84         return false;
 85     // If we have stylesheets in the user agent shadow tree use per-scope resolver.
 86     if (!m_styleSheetCandidateNodes.isEmpty())
 87         return false;
 88     return true;
 89 }
 90 
<span class="line-modified"> 91 Resolver&amp; Scope::resolver()</span>
 92 {
 93     if (shouldUseSharedUserAgentShadowTreeStyleResolver())
 94         return m_document.userAgentShadowTreeStyleResolver();
 95 
 96     if (!m_resolver) {
 97         SetForScope&lt;bool&gt; isUpdatingStyleResolver { m_isUpdatingStyleResolver, true };
 98 
<span class="line-modified"> 99         m_resolver = makeUnique&lt;Resolver&gt;(m_document);</span>
100 
101         if (!m_shadowRoot) {
102             m_document.fontSelector().buildStarted();
103             m_resolver-&gt;ruleSets().initializeUserStyle();
104         } else {
105             m_resolver-&gt;ruleSets().setIsForShadowScope();
106             m_resolver-&gt;ruleSets().setUsesSharedUserStyle(m_shadowRoot-&gt;mode() != ShadowRootMode::UserAgent);
107         }
108 
109         m_resolver-&gt;addCurrentSVGFontFaceRules();
110         m_resolver-&gt;appendAuthorStyleSheets(m_activeStyleSheets);
111 
112         if (!m_shadowRoot)
113             m_document.fontSelector().buildCompleted();
114     }
115     ASSERT(!m_shadowRoot || &amp;m_document == &amp;m_shadowRoot-&gt;document());
116     ASSERT(&amp;m_resolver-&gt;document() == &amp;m_document);
117     return *m_resolver;
118 }
119 
<span class="line-modified">120 Resolver* Scope::resolverIfExists()</span>
121 {
122     if (shouldUseSharedUserAgentShadowTreeStyleResolver())
123         return &amp;m_document.userAgentShadowTreeStyleResolver();
124 
125     return m_resolver.get();
126 }
127 
128 void Scope::clearResolver()
129 {
130     m_resolver = nullptr;
131 
132     if (!m_shadowRoot)
133         m_document.didClearStyleResolver();
134 }
135 
136 void Scope::releaseMemory()
137 {
138     if (!m_shadowRoot) {
139         for (auto* descendantShadowRoot : m_document.inDocumentShadowRoots())
140             descendantShadowRoot-&gt;styleScope().releaseMemory();
</pre>
<hr />
<pre>
364                 if (m_preferredStylesheetSetName.isEmpty()) {
365                     // No preferred set has been established. If
366                     // we are NOT an alternate sheet, then establish
367                     // us as the preferred set. Otherwise, just ignore
368                     // this sheet.
369                     if (is&lt;HTMLStyleElement&gt;(element) || !rel.contains(&quot;alternate&quot;))
370                         m_preferredStylesheetSetName = title;
371                 }
372                 if (title != m_preferredStylesheetSetName)
373                     sheet = nullptr;
374             }
375 
376             if (rel.contains(&quot;alternate&quot;) &amp;&amp; title.isEmpty())
377                 sheet = nullptr;
378         }
379         if (sheet)
380             sheets.append(WTFMove(sheet));
381     }
382 }
383 
<span class="line-modified">384 Scope::StyleSheetChange Scope::analyzeStyleSheetChange(const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; newStylesheets)</span>
385 {


386     unsigned newStylesheetCount = newStylesheets.size();
387 
388     if (!resolverIfExists())
<span class="line-modified">389         return { ResolverUpdateType::Reconstruct };</span>


390 
391     // Find out which stylesheets are new.
392     unsigned oldStylesheetCount = m_activeStyleSheets.size();
393     if (newStylesheetCount &lt; oldStylesheetCount)
<span class="line-modified">394         return { ResolverUpdateType::Reconstruct };</span>
395 
396     Vector&lt;StyleSheetContents*&gt; addedSheets;
397     unsigned newIndex = 0;
398     for (unsigned oldIndex = 0; oldIndex &lt; oldStylesheetCount; ++oldIndex) {
399         if (newIndex &gt;= newStylesheetCount)
<span class="line-modified">400             return { ResolverUpdateType::Reconstruct };</span>
<span class="line-added">401 </span>
402         while (m_activeStyleSheets[oldIndex] != newStylesheets[newIndex]) {
403             addedSheets.append(&amp;newStylesheets[newIndex]-&gt;contents());
404             ++newIndex;
405             if (newIndex == newStylesheetCount)
<span class="line-modified">406                 return { ResolverUpdateType::Reconstruct };</span>
407         }
408         ++newIndex;
409     }
410     bool hasInsertions = !addedSheets.isEmpty();
411     while (newIndex &lt; newStylesheetCount) {
412         addedSheets.append(&amp;newStylesheets[newIndex]-&gt;contents());
413         ++newIndex;
414     }







415 
<span class="line-modified">416     // If all new sheets were added at the end of the list we can just add them to existing Resolver.</span>
<span class="line-modified">417     // If there were insertions we need to re-add all the stylesheets so rules are ordered correctly.</span>
<span class="line-modified">418     return { hasInsertions ? ResolverUpdateType::Reset : ResolverUpdateType::Additive, WTFMove(addedSheets) };</span>









419 }
420 
421 static void filterEnabledNonemptyCSSStyleSheets(Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; result, const Vector&lt;RefPtr&lt;StyleSheet&gt;&gt;&amp; sheets)
422 {
423     for (auto&amp; sheet : sheets) {
424         if (!is&lt;CSSStyleSheet&gt;(*sheet))
425             continue;
426         CSSStyleSheet&amp; styleSheet = downcast&lt;CSSStyleSheet&gt;(*sheet);
427         if (styleSheet.isLoading())
428             continue;
429         if (styleSheet.disabled())
430             continue;
431         if (!styleSheet.length())
432             continue;
433         result.append(&amp;styleSheet);
434     }
435 }
436 












437 void Scope::updateActiveStyleSheets(UpdateType updateType)
438 {
439     ASSERT(!m_pendingUpdate);
440 
441     if (!m_document.hasLivingRenderTree())
442         return;
443 
444     if (m_document.inStyleRecalc() || m_document.inRenderTreeUpdate()) {
445         // Protect against deleting style resolver in the middle of a style resolution.
446         // Crash stacks indicate we can get here when a resource load fails synchronously (for example due to content blocking).
447         // FIXME: These kind of cases should be eliminated and this path replaced by an assert.
448         m_pendingUpdate = UpdateType::ContentsOrInterpretation;
449         m_document.scheduleFullStyleRebuild();
450         return;
451     }
452 
453     Vector&lt;RefPtr&lt;StyleSheet&gt;&gt; activeStyleSheets;
454     collectActiveStyleSheets(activeStyleSheets);
455 
456     Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt; activeCSSStyleSheets;
457     activeCSSStyleSheets.appendVector(m_document.extensionStyleSheets().injectedAuthorStyleSheets());
458     activeCSSStyleSheets.appendVector(m_document.extensionStyleSheets().authorStyleSheetsForTesting());
459     filterEnabledNonemptyCSSStyleSheets(activeCSSStyleSheets, activeStyleSheets);
460 
<span class="line-modified">461     auto styleSheetChange = StyleSheetChange { ResolverUpdateType::Reconstruct };</span>

462     if (updateType == UpdateType::ActiveSet)
<span class="line-modified">463         styleSheetChange = analyzeStyleSheetChange(activeCSSStyleSheets);</span>
464 
<span class="line-modified">465     updateResolver(activeCSSStyleSheets, styleSheetChange.resolverUpdateType);</span>
466 
467     m_weakCopyOfActiveStyleSheetListForFastLookup = nullptr;
468     m_activeStyleSheets.swap(activeCSSStyleSheets);
469     m_styleSheetsForStyleSheetList.swap(activeStyleSheets);
470 
471     InspectorInstrumentation::activeStyleSheetsUpdated(m_document);
472 
473     for (const auto&amp; sheet : m_activeStyleSheets) {
474         if (sheet-&gt;contents().usesStyleBasedEditability())
475             m_usesStyleBasedEditability = true;
476     }
477 
<span class="line-modified">478     invalidateStyleAfterStyleSheetChange(styleSheetChange);</span>
<span class="line-modified">479 }</span>
<span class="line-modified">480 </span>
<span class="line-modified">481 void Scope::invalidateStyleAfterStyleSheetChange(const StyleSheetChange&amp; styleSheetChange)</span>
<span class="line-modified">482 {</span>
<span class="line-modified">483     // If we are already parsing the body and so may have significant amount of elements, put some effort into trying to avoid style recalcs.</span>
<span class="line-modified">484     bool invalidateAll = !m_document.bodyOrFrameset() || m_document.hasNodesWithNonFinalStyle() || m_document.hasNodesWithMissingStyle();</span>
<span class="line-modified">485 </span>
<span class="line-added">486     if (styleSheetChange.resolverUpdateType == ResolverUpdateType::Reconstruct || invalidateAll) {</span>
<span class="line-added">487         Invalidator::invalidateAllStyle(*this);</span>
<span class="line-added">488         return;</span>
489     }
<span class="line-added">490 </span>
<span class="line-added">491     Invalidator invalidator(styleSheetChange.addedSheets, m_resolver-&gt;mediaQueryEvaluator());</span>
<span class="line-added">492     invalidator.invalidateStyle(*this);</span>
493 }
494 
<span class="line-modified">495 void Scope::updateResolver(Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; activeStyleSheets, ResolverUpdateType updateType)</span>
496 {
<span class="line-modified">497     if (updateType == ResolverUpdateType::Reconstruct) {</span>
498         clearResolver();
499         return;
500     }
501     auto&amp; styleResolver = resolver();
502 
503     SetForScope&lt;bool&gt; isUpdatingStyleResolver { m_isUpdatingStyleResolver, true };
<span class="line-modified">504     if (updateType == ResolverUpdateType::Reset) {</span>
505         styleResolver.ruleSets().resetAuthorStyle();
506         styleResolver.appendAuthorStyleSheets(activeStyleSheets);
507     } else {
<span class="line-modified">508         ASSERT(updateType == ResolverUpdateType::Additive);</span>
509         unsigned firstNewIndex = m_activeStyleSheets.size();
510         Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt; newStyleSheets;
511         newStyleSheets.appendRange(activeStyleSheets.begin() + firstNewIndex, activeStyleSheets.end());
512         styleResolver.appendAuthorStyleSheets(newStyleSheets);
513     }
514 }
515 
516 const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt; Scope::activeStyleSheetsForInspector()
517 {
518     Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt; result;
519 
<span class="line-added">520     if (auto* pageUserSheet = m_document.extensionStyleSheets().pageUserSheet())</span>
<span class="line-added">521         result.append(pageUserSheet);</span>
<span class="line-added">522     result.appendVector(m_document.extensionStyleSheets().documentUserStyleSheets());</span>
<span class="line-added">523     result.appendVector(m_document.extensionStyleSheets().injectedUserStyleSheets());</span>
524     result.appendVector(m_document.extensionStyleSheets().injectedAuthorStyleSheets());
525     result.appendVector(m_document.extensionStyleSheets().authorStyleSheetsForTesting());
526 
527     for (auto&amp; styleSheet : m_styleSheetsForStyleSheetList) {
528         if (!is&lt;CSSStyleSheet&gt;(*styleSheet))
529             continue;
530 
531         CSSStyleSheet&amp; sheet = downcast&lt;CSSStyleSheet&gt;(*styleSheet);
532         if (sheet.disabled())
533             continue;
534 
535         result.append(&amp;sheet);
536     }
537 
538     return result;
539 }
540 
541 bool Scope::activeStyleSheetsContains(const CSSStyleSheet* sheet) const
542 {
543     if (!m_weakCopyOfActiveStyleSheetListForFastLookup) {
</pre>
<hr />
<pre>
560 
561 void Scope::flushPendingDescendantUpdates()
562 {
563     ASSERT(m_hasDescendantWithPendingUpdate);
564     ASSERT(!m_shadowRoot);
565     for (auto* descendantShadowRoot : m_document.inDocumentShadowRoots())
566         descendantShadowRoot-&gt;styleScope().flushPendingUpdate();
567     m_hasDescendantWithPendingUpdate = false;
568 }
569 
570 void Scope::clearPendingUpdate()
571 {
572     m_pendingUpdateTimer.stop();
573     m_pendingUpdate = { };
574 }
575 
576 void Scope::scheduleUpdate(UpdateType update)
577 {
578     if (update == UpdateType::ContentsOrInterpretation) {
579         // :host and ::slotted rules might go away.
<span class="line-modified">580         if (m_shadowRoot)</span>
<span class="line-modified">581             Invalidator::invalidateHostAndSlottedStyleIfNeeded(*m_shadowRoot);</span>
582         // FIXME: Animation code may trigger resource load in middle of style recalc and that can add a rule to a content extension stylesheet.
583         //        Fix and remove isResolvingTreeStyle() test below, see https://bugs.webkit.org/show_bug.cgi?id=194335
<span class="line-modified">584         // FIXME: The m_isUpdatingStyleResolver test is here because extension stylesheets can get us here from Resolver::appendAuthorStyleSheets.</span>
585         if (!m_isUpdatingStyleResolver &amp;&amp; !m_document.isResolvingTreeStyle())
586             clearResolver();
587     }
588 
589     if (!m_pendingUpdate || *m_pendingUpdate &lt; update) {
590         m_pendingUpdate = update;
591         if (m_shadowRoot)
592             m_document.styleScope().m_hasDescendantWithPendingUpdate = true;
593     }
594 
595     if (m_pendingUpdateTimer.isActive())
596         return;
597     m_pendingUpdateTimer.startOneShot(0_s);
598 }
599 
600 void Scope::evaluateMediaQueriesForViewportChange()
601 {
<span class="line-modified">602     evaluateMediaQueries([] (Resolver&amp; resolver) {</span>
<span class="line-modified">603         return resolver.evaluateDynamicMediaQueries();</span>
604     });
605 }
606 
607 void Scope::evaluateMediaQueriesForAccessibilitySettingsChange()
608 {
<span class="line-modified">609     evaluateMediaQueries([] (Resolver&amp; resolver) {</span>
<span class="line-modified">610         return resolver.evaluateDynamicMediaQueries();</span>
611     });
612 }
613 
614 void Scope::evaluateMediaQueriesForAppearanceChange()
615 {
<span class="line-modified">616     evaluateMediaQueries([] (Resolver&amp; resolver) {</span>
<span class="line-modified">617         return resolver.evaluateDynamicMediaQueries();</span>
618     });
619 }
620 
621 template &lt;typename TestFunction&gt;
622 void Scope::evaluateMediaQueries(TestFunction&amp;&amp; testFunction)
623 {
<span class="line-added">624     auto* resolver = resolverIfExists();</span>
<span class="line-added">625     if (!resolver)</span>
<span class="line-added">626         return;</span>
<span class="line-added">627 </span>
<span class="line-added">628     auto evaluationChanges = testFunction(*resolver);</span>
<span class="line-added">629     if (evaluationChanges) {</span>
<span class="line-added">630         switch (evaluationChanges-&gt;type) {</span>
<span class="line-added">631         case DynamicMediaQueryEvaluationChanges::Type::InvalidateStyle: {</span>
<span class="line-added">632             Invalidator invalidator(evaluationChanges-&gt;invalidationRuleSets);</span>
<span class="line-added">633             invalidator.invalidateStyle(*this);</span>
<span class="line-added">634             break;</span>
<span class="line-added">635         }</span>
<span class="line-added">636         case DynamicMediaQueryEvaluationChanges::Type::ResetStyle:</span>
<span class="line-added">637             scheduleUpdate(UpdateType::ContentsOrInterpretation);</span>
<span class="line-added">638             break;</span>
<span class="line-added">639         }</span>
<span class="line-added">640 </span>
<span class="line-added">641         InspectorInstrumentation::mediaQueryResultChanged(m_document);</span>
<span class="line-added">642     }</span>
<span class="line-added">643 </span>
644     if (!m_shadowRoot) {
645         for (auto* descendantShadowRoot : m_document.inDocumentShadowRoots())
646             descendantShadowRoot-&gt;styleScope().evaluateMediaQueries(testFunction);
647     }







648 }
649 
650 void Scope::didChangeActiveStyleSheetCandidates()
651 {
652     scheduleUpdate(UpdateType::ActiveSet);
653 }
654 
655 void Scope::didChangeStyleSheetContents()
656 {
657     scheduleUpdate(UpdateType::ContentsOrInterpretation);
658 }
659 
660 void Scope::didChangeStyleSheetEnvironment()
661 {
662     if (!m_shadowRoot) {
663         for (auto* descendantShadowRoot : m_document.inDocumentShadowRoots()) {
664             // Stylesheets is author shadow roots are potentially affected.
665             if (descendantShadowRoot-&gt;mode() != ShadowRootMode::UserAgent)
666                 descendantShadowRoot-&gt;styleScope().scheduleUpdate(UpdateType::ContentsOrInterpretation);
667         }
668     }
669     scheduleUpdate(UpdateType::ContentsOrInterpretation);
670 }
671 
<span class="line-added">672 void Scope::invalidateMatchedDeclarationsCache()</span>
<span class="line-added">673 {</span>
<span class="line-added">674     if (!m_shadowRoot) {</span>
<span class="line-added">675         for (auto* descendantShadowRoot : m_document.inDocumentShadowRoots())</span>
<span class="line-added">676             descendantShadowRoot-&gt;styleScope().invalidateMatchedDeclarationsCache();</span>
<span class="line-added">677     }</span>
<span class="line-added">678 </span>
<span class="line-added">679     if (auto* resolver = resolverIfExists())</span>
<span class="line-added">680         resolver-&gt;invalidateMatchedDeclarationsCache();</span>
<span class="line-added">681 }</span>
<span class="line-added">682 </span>
<span class="line-added">683 </span>
684 void Scope::pendingUpdateTimerFired()
685 {
686     flushPendingUpdate();
687 }
688 
689 const Vector&lt;RefPtr&lt;StyleSheet&gt;&gt;&amp; Scope::styleSheetsForStyleSheetList()
690 {
691     // FIXME: StyleSheetList content should be updated separately from style resolver updates.
692     flushPendingUpdate();
693     return m_styleSheetsForStyleSheetList;
694 }
695 
696 }
697 }
</pre>
</td>
</tr>
</table>
<center><a href="StyleResolveForDocument.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StyleScope.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/text/TextEncodingRegistry.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/text/TextEncodingRegistry.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/text/TextEncodingRegistry.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/text/TextEncodingRegistry.cpp
@@ -42,10 +42,14 @@
 #include <wtf/Lock.h>
 #include <wtf/MainThread.h>
 #include <wtf/StdLibExtras.h>
 #include <wtf/text/CString.h>
 
+#if USE(JAVA_UNICODE)
+#include "java/TextCodecJava.h"
+#endif
+
 namespace WebCore {
 
 const size_t maxEncodingNameLength = 63;
 
 // Hash for all-ASCII strings that does case folding.
@@ -116,44 +120,44 @@
 static void addToTextEncodingNameMap(const char* alias, const char* name)
 {
     ASSERT(strlen(alias) <= maxEncodingNameLength);
     if (isUndesiredAlias(alias))
         return;
-    const char* atomicName = textEncodingNameMap->get(name);
-    ASSERT(strcmp(alias, name) == 0 || atomicName);
-    if (!atomicName)
-        atomicName = name;
+    const char* atomName = textEncodingNameMap->get(name);
+    ASSERT(!strcmp(alias, name) || atomName);
+    if (!atomName)
+        atomName = name;
 
-    ASSERT_WITH_MESSAGE(!textEncodingNameMap->get(alias), "Duplicate text encoding name %s for %s (previously registered as %s)", alias, atomicName, textEncodingNameMap->get(alias));
+    ASSERT_WITH_MESSAGE(!textEncodingNameMap->get(alias), "Duplicate text encoding name %s for %s (previously registered as %s)", alias, atomName, textEncodingNameMap->get(alias));
 
-    textEncodingNameMap->add(alias, atomicName);
+    textEncodingNameMap->add(alias, atomName);
 }
 
 static void addToTextCodecMap(const char* name, NewTextCodecFunction&& function)
 {
-    const char* atomicName = textEncodingNameMap->get(name);
-    ASSERT(atomicName);
-    textCodecMap->add(atomicName, WTFMove(function));
+    const char* atomName = textEncodingNameMap->get(name);
+    ASSERT(atomName);
+    textCodecMap->add(atomName, WTFMove(function));
 }
 
 static void pruneBlacklistedCodecs()
 {
     for (auto& nameFromBlacklist : textEncodingNameBlacklist) {
-        auto* atomicName = textEncodingNameMap->get(nameFromBlacklist);
-        if (!atomicName)
+        auto* atomName = textEncodingNameMap->get(nameFromBlacklist);
+        if (!atomName)
             continue;
 
         Vector<const char*> names;
         for (auto& entry : *textEncodingNameMap) {
-            if (entry.value == atomicName)
+            if (entry.value == atomName)
                 names.append(entry.key);
         }
 
         for (auto* name : names)
             textEncodingNameMap->remove(name);
 
-        textCodecMap->remove(atomicName);
+        textCodecMap->remove(atomName);
     }
 }
 
 static void buildBaseTextCodecMaps(const std::lock_guard<Lock>&)
 {
@@ -176,14 +180,14 @@
     TextCodecUserDefined::registerCodecs(addToTextCodecMap);
 }
 
 static void addEncodingName(HashSet<const char*>* set, const char* name)
 {
-    // We must not use atomicCanonicalTextEncodingName() because this function is called in it.
-    const char* atomicName = textEncodingNameMap->get(name);
-    if (atomicName)
-        set->add(atomicName);
+    // We must not use atomCanonicalTextEncodingName() because this function is called in it.
+    const char* atomName = textEncodingNameMap->get(name);
+    if (atomName)
+        set->add(atomName);
 }
 
 static void buildQuirksSets()
 {
     // FIXME: Having isJapaneseEncoding() and shouldShowBackslashAsCurrencySymbolIn()
@@ -235,10 +239,15 @@
     TextCodecReplacement::registerCodecs(addToTextCodecMap);
 
     TextCodecICU::registerEncodingNames(addToTextEncodingNameMap);
     TextCodecICU::registerCodecs(addToTextCodecMap);
 
+#if USE(JAVA_UNICODE)
+    TextCodecJava::registerEncodingNames(addToTextEncodingNameMap);
+    TextCodecJava::registerCodecs(addToTextCodecMap);
+#endif
+
     pruneBlacklistedCodecs();
     buildQuirksSets();
 }
 
 std::unique_ptr<TextCodec> newTextCodec(const TextEncoding& encoding)
@@ -249,52 +258,52 @@
     auto result = textCodecMap->find(encoding.name());
     ASSERT(result != textCodecMap->end());
     return result->value();
 }
 
-const char* atomicCanonicalTextEncodingName(const char* name)
+const char* atomCanonicalTextEncodingName(const char* name)
 {
     if (!name || !name[0])
         return nullptr;
 
     std::lock_guard<Lock> lock(encodingRegistryMutex);
 
     if (!textEncodingNameMap)
         buildBaseTextCodecMaps(lock);
 
-    if (const char* atomicName = textEncodingNameMap->get(name))
-        return atomicName;
+    if (const char* atomName = textEncodingNameMap->get(name))
+        return atomName;
     if (didExtendTextCodecMaps)
         return nullptr;
 
     extendTextCodecMaps();
     didExtendTextCodecMaps = true;
     return textEncodingNameMap->get(name);
 }
 
-template<typename CharacterType> static const char* atomicCanonicalTextEncodingName(const CharacterType* characters, size_t length)
+template<typename CharacterType> static const char* atomCanonicalTextEncodingName(const CharacterType* characters, size_t length)
 {
     char buffer[maxEncodingNameLength + 1];
     size_t j = 0;
     for (size_t i = 0; i < length; ++i) {
         if (j == maxEncodingNameLength)
             return nullptr;
         buffer[j++] = characters[i];
     }
     buffer[j] = 0;
-    return atomicCanonicalTextEncodingName(buffer);
+    return atomCanonicalTextEncodingName(buffer);
 }
 
-const char* atomicCanonicalTextEncodingName(const String& alias)
+const char* atomCanonicalTextEncodingName(const String& alias)
 {
     if (alias.isEmpty() || !alias.isAllASCII())
         return nullptr;
 
     if (alias.is8Bit())
-        return atomicCanonicalTextEncodingName(alias.characters8(), alias.length());
+        return atomCanonicalTextEncodingName(alias.characters8(), alias.length());
 
-    return atomicCanonicalTextEncodingName(alias.characters16(), alias.length());
+    return atomCanonicalTextEncodingName(alias.characters16(), alias.length());
 }
 
 bool noExtendedTextEncodingNameUsed()
 {
     // If the calling thread did not use extended encoding names, it is fine for it to use a stale false value.

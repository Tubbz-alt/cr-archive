<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGArgumentsEliminationPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DFGArgumentsEliminationPhase.h&quot;
  28 
  29 #if ENABLE(DFG_JIT)
  30 
  31 #include &quot;ArrayPrototype.h&quot;
  32 #include &quot;BytecodeLivenessAnalysisInlines.h&quot;
  33 #include &quot;ClonedArguments.h&quot;
  34 #include &quot;DFGArgumentsUtilities.h&quot;
  35 #include &quot;DFGBasicBlockInlines.h&quot;
  36 #include &quot;DFGBlockMapInlines.h&quot;
  37 #include &quot;DFGClobberize.h&quot;
  38 #include &quot;DFGCombinedLiveness.h&quot;
  39 #include &quot;DFGForAllKills.h&quot;
  40 #include &quot;DFGGraph.h&quot;
  41 #include &quot;DFGInsertionSet.h&quot;
  42 #include &quot;DFGLivenessAnalysisPhase.h&quot;
  43 #include &quot;DFGOSRAvailabilityAnalysisPhase.h&quot;
  44 #include &quot;DFGPhase.h&quot;
  45 #include &quot;JSCInlines.h&quot;
  46 #include &lt;wtf/HashSet.h&gt;
  47 #include &lt;wtf/ListDump.h&gt;
  48 #include &lt;wtf/RecursableLambda.h&gt;
  49 
  50 namespace JSC { namespace DFG {
  51 
  52 namespace {
  53 
  54 namespace DFGArgumentsEliminationPhaseInternal {
<a name="1" id="anc1"></a><span class="line-modified">  55 static constexpr bool verbose = false;</span>
  56 }
  57 
  58 class ArgumentsEliminationPhase : public Phase {
  59 public:
  60     ArgumentsEliminationPhase(Graph&amp; graph)
  61         : Phase(graph, &quot;arguments elimination&quot;)
  62     {
  63     }
  64 
  65     bool run()
  66     {
  67         // For now this phase only works on SSA. This could be changed; we could have a block-local
  68         // version over LoadStore.
  69         DFG_ASSERT(m_graph, nullptr, m_graph.m_form == SSA);
  70 
  71         if (DFGArgumentsEliminationPhaseInternal::verbose) {
  72             dataLog(&quot;Graph before arguments elimination:\n&quot;);
  73             m_graph.dump();
  74         }
  75 
  76         identifyCandidates();
  77         if (m_candidates.isEmpty())
  78             return false;
  79 
  80         eliminateCandidatesThatEscape();
  81         if (m_candidates.isEmpty())
  82             return false;
  83 
  84         eliminateCandidatesThatInterfere();
  85         if (m_candidates.isEmpty())
  86             return false;
  87 
  88         transform();
  89 
  90         return true;
  91     }
  92 
  93 private:
  94     // Just finds nodes that we know how to work with.
  95     void identifyCandidates()
  96     {
  97         for (BasicBlock* block : m_graph.blocksInPreOrder()) {
  98             for (Node* node : *block) {
  99                 switch (node-&gt;op()) {
 100                 case CreateDirectArguments:
 101                 case CreateClonedArguments:
 102                     m_candidates.add(node);
 103                     break;
 104 
 105                 case CreateRest:
 106                     if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
 107                         // If we&#39;re watching the HavingABadTime watchpoint it means that we will be invalidated
 108                         // when it fires (it may or may not have actually fired yet). We don&#39;t try to eliminate
 109                         // this allocation when we&#39;re not watching the watchpoint because it could entail calling
 110                         // indexed accessors (and probably more crazy things) on out of bound accesses to the
 111                         // rest parameter. It&#39;s also much easier to reason about this way.
 112                         m_candidates.add(node);
 113                     }
 114                     break;
 115 
 116                 case Spread:
 117                     if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
 118                         // We check ArrayUse here because ArrayUse indicates that the iterator
 119                         // protocol for Arrays is non-observable by user code (e.g, it hasn&#39;t
 120                         // been changed).
 121                         if (node-&gt;child1().useKind() == ArrayUse) {
 122                             if ((node-&gt;child1()-&gt;op() == CreateRest || node-&gt;child1()-&gt;op() == NewArrayBuffer) &amp;&amp; m_candidates.contains(node-&gt;child1().node()))
 123                                 m_candidates.add(node);
 124                         }
 125                     }
 126                     break;
 127 
 128                 case NewArrayWithSpread: {
 129                     if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
 130                         BitVector* bitVector = node-&gt;bitVector();
 131                         // We only allow for Spreads to be of CreateRest or NewArrayBuffer nodes for now.
 132                         bool isOK = true;
 133                         for (unsigned i = 0; i &lt; node-&gt;numChildren(); i++) {
 134                             if (bitVector-&gt;get(i)) {
 135                                 Node* child = m_graph.varArgChild(node, i).node();
 136                                 isOK = child-&gt;op() == Spread &amp;&amp; (child-&gt;child1()-&gt;op() == CreateRest || child-&gt;child1()-&gt;op() == NewArrayBuffer) &amp;&amp; m_candidates.contains(child);
 137                                 if (!isOK)
 138                                     break;
 139                             }
 140                         }
 141 
 142                         if (!isOK)
 143                             break;
 144 
 145                         m_candidates.add(node);
 146                     }
 147                     break;
 148                 }
 149 
 150                 case NewArrayBuffer: {
 151                     if (m_graph.isWatchingHavingABadTimeWatchpoint(node) &amp;&amp; !hasAnyArrayStorage(node-&gt;indexingMode()))
 152                         m_candidates.add(node);
 153                     break;
 154                 }
 155 
 156                 case CreateScopedArguments:
 157                     // FIXME: We could handle this if it wasn&#39;t for the fact that scoped arguments are
 158                     // always stored into the activation.
 159                     // https://bugs.webkit.org/show_bug.cgi?id=143072 and
 160                     // https://bugs.webkit.org/show_bug.cgi?id=143073
 161                     break;
 162 
 163                 default:
 164                     break;
 165                 }
 166                 if (node-&gt;isPseudoTerminal())
 167                     break;
 168             }
 169         }
 170 
 171         if (DFGArgumentsEliminationPhaseInternal::verbose)
 172             dataLog(&quot;Candidates: &quot;, listDump(m_candidates), &quot;\n&quot;);
 173     }
 174 
 175     bool isStillValidCandidate(Node* candidate)
 176     {
 177         switch (candidate-&gt;op()) {
 178         case Spread:
 179             return m_candidates.contains(candidate-&gt;child1().node());
 180 
 181         case NewArrayWithSpread: {
 182             BitVector* bitVector = candidate-&gt;bitVector();
 183             for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
 184                 if (bitVector-&gt;get(i)) {
 185                     if (!m_candidates.contains(m_graph.varArgChild(candidate, i).node()))
 186                         return false;
 187                 }
 188             }
 189             return true;
 190         }
 191 
 192         default:
 193             return true;
 194         }
 195 
 196         RELEASE_ASSERT_NOT_REACHED();
 197         return false;
 198     }
 199 
 200     void removeInvalidCandidates()
 201     {
 202         bool changed;
 203         do {
 204             changed = false;
 205             Vector&lt;Node*, 1&gt; toRemove;
 206 
 207             for (Node* candidate : m_candidates) {
 208                 if (!isStillValidCandidate(candidate))
 209                     toRemove.append(candidate);
 210             }
 211 
 212             if (toRemove.size()) {
 213                 changed = true;
 214                 for (Node* node : toRemove)
 215                     m_candidates.remove(node);
 216             }
 217 
 218         } while (changed);
 219     }
 220 
 221     void transitivelyRemoveCandidate(Node* node, Node* source = nullptr)
 222     {
 223         bool removed = m_candidates.remove(node);
 224         if (removed &amp;&amp; DFGArgumentsEliminationPhaseInternal::verbose &amp;&amp; source)
 225             dataLog(&quot;eliminating candidate: &quot;, node, &quot; because it escapes from: &quot;, source, &quot;\n&quot;);
 226 
 227         if (removed)
 228             removeInvalidCandidates();
 229     }
 230 
 231     // Look for escaping sites, and remove from the candidates set if we see an escape.
 232     void eliminateCandidatesThatEscape()
 233     {
 234         auto escape = [&amp;] (Edge edge, Node* source) {
 235             if (!edge)
 236                 return;
 237             transitivelyRemoveCandidate(edge.node(), source);
 238         };
 239 
 240         auto escapeBasedOnArrayMode = [&amp;] (ArrayMode mode, Edge edge, Node* source) {
 241             switch (mode.type()) {
 242             case Array::DirectArguments: {
 243                 if (edge-&gt;op() != CreateDirectArguments) {
 244                     escape(edge, source);
 245                     break;
 246                 }
 247 
 248                 // Everything is fine if we&#39;re doing an in-bounds access.
 249                 if (mode.isInBounds())
 250                     break;
 251 
 252                 // If we&#39;re out-of-bounds then we proceed only if the prototype chain
 253                 // for the allocation is sane (i.e. doesn&#39;t have indexed properties).
 254                 JSGlobalObject* globalObject = m_graph.globalObjectFor(edge-&gt;origin.semantic);
 255                 Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(m_graph.m_vm);
 256                 if (objectPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
 257                     &amp;&amp; globalObject-&gt;objectPrototypeIsSane()) {
 258                     m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);
 259                     break;
 260                 }
 261                 escape(edge, source);
 262                 break;
 263             }
 264 
 265             case Array::Contiguous: {
 266                 if (edge-&gt;op() != CreateClonedArguments &amp;&amp; edge-&gt;op() != CreateRest) {
 267                     escape(edge, source);
 268                     break;
 269                 }
 270 
 271                 // Everything is fine if we&#39;re doing an in-bounds access.
 272                 if (mode.isInBounds())
 273                     break;
 274 
 275                 // If we&#39;re out-of-bounds then we proceed only if the prototype chain
 276                 // for the allocation is sane (i.e. doesn&#39;t have indexed properties).
 277                 JSGlobalObject* globalObject = m_graph.globalObjectFor(edge-&gt;origin.semantic);
 278                 Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(m_graph.m_vm);
 279                 if (edge-&gt;op() == CreateRest) {
 280                     Structure* arrayPrototypeStructure = globalObject-&gt;arrayPrototype()-&gt;structure(m_graph.m_vm);
 281                     if (arrayPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
 282                         &amp;&amp; objectPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
 283                         &amp;&amp; globalObject-&gt;arrayPrototypeChainIsSane()) {
 284                         m_graph.registerAndWatchStructureTransition(arrayPrototypeStructure);
 285                         m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);
 286                         break;
 287                     }
 288                 } else {
 289                     if (objectPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
 290                         &amp;&amp; globalObject-&gt;objectPrototypeIsSane()) {
 291                         m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);
 292                         break;
 293                     }
 294                 }
 295                 escape(edge, source);
 296                 break;
 297             }
 298 
 299             case Array::ForceExit:
 300                 break;
 301 
 302             default:
 303                 escape(edge, source);
 304                 break;
 305             }
 306         };
 307 
 308         removeInvalidCandidates();
 309 
 310         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
 311             for (Node* node : *block) {
 312                 switch (node-&gt;op()) {
 313                 case GetFromArguments:
 314                     break;
 315 
 316                 case GetByVal:
 317                     escapeBasedOnArrayMode(node-&gt;arrayMode(), m_graph.varArgChild(node, 0), node);
 318                     escape(m_graph.varArgChild(node, 1), node);
 319                     escape(m_graph.varArgChild(node, 2), node);
 320                     break;
 321 
 322                 case GetArrayLength:
 323                     escape(node-&gt;child2(), node);
 324                     // Computing the length of a NewArrayWithSpread can require some additions.
 325                     // These additions can overflow if the array is sufficiently enormous, and in that case we will need to exit.
 326                     if ((node-&gt;child1()-&gt;op() == NewArrayWithSpread) &amp;&amp; !node-&gt;origin.exitOK)
 327                         escape(node-&gt;child1(), node);
 328                     break;
 329 
 330                 case NewArrayWithSpread: {
 331                     BitVector* bitVector = node-&gt;bitVector();
 332                     bool isWatchingHavingABadTimeWatchpoint = m_graph.isWatchingHavingABadTimeWatchpoint(node);
 333                     for (unsigned i = 0; i &lt; node-&gt;numChildren(); i++) {
 334                         Edge child = m_graph.varArgChild(node, i);
 335                         bool dontEscape;
 336                         if (bitVector-&gt;get(i)) {
 337                             dontEscape = child-&gt;op() == Spread
 338                                 &amp;&amp; child-&gt;child1().useKind() == ArrayUse
 339                                 &amp;&amp; (child-&gt;child1()-&gt;op() == CreateRest || child-&gt;child1()-&gt;op() == NewArrayBuffer)
 340                                 &amp;&amp; isWatchingHavingABadTimeWatchpoint;
 341                         } else
 342                             dontEscape = false;
 343 
 344                         if (!dontEscape)
 345                             escape(child, node);
 346                     }
 347 
 348                     break;
 349                 }
 350 
 351                 case Spread: {
 352                     bool isOK = node-&gt;child1().useKind() == ArrayUse &amp;&amp; (node-&gt;child1()-&gt;op() == CreateRest || node-&gt;child1()-&gt;op() == NewArrayBuffer);
 353                     if (!isOK)
 354                         escape(node-&gt;child1(), node);
 355                     break;
 356                 }
 357 
 358                 case NewArrayBuffer:
 359                     break;
 360 
<a name="2" id="anc2"></a><span class="line-added"> 361                 case VarargsLength:</span>
<span class="line-added"> 362                     break;</span>
<span class="line-added"> 363 </span>
 364                 case LoadVarargs:
<a name="3" id="anc3"></a><span class="line-modified"> 365                     if (node-&gt;loadVarargsData()-&gt;offset &amp;&amp; (node-&gt;argumentsChild()-&gt;op() == NewArrayWithSpread || node-&gt;argumentsChild()-&gt;op() == Spread || node-&gt;argumentsChild()-&gt;op() == NewArrayBuffer))</span>
<span class="line-modified"> 366                         escape(node-&gt;argumentsChild(), node);</span>
 367                     break;
 368 
 369                 case CallVarargs:
 370                 case ConstructVarargs:
 371                 case TailCallVarargs:
 372                 case TailCallVarargsInlinedCaller:
 373                     escape(node-&gt;child1(), node);
 374                     escape(node-&gt;child2(), node);
 375                     if (node-&gt;callVarargsData()-&gt;firstVarArgOffset &amp;&amp; (node-&gt;child3()-&gt;op() == NewArrayWithSpread || node-&gt;child3()-&gt;op() == Spread || node-&gt;child1()-&gt;op() == NewArrayBuffer))
 376                         escape(node-&gt;child3(), node);
 377                     break;
 378 
 379                 case Check:
 380                 case CheckVarargs:
 381                     m_graph.doToChildren(
 382                         node,
 383                         [&amp;] (Edge edge) {
 384                             if (edge.willNotHaveCheck())
 385                                 return;
 386 
 387                             if (alreadyChecked(edge.useKind(), SpecObject))
 388                                 return;
 389 
 390                             escape(edge, node);
 391                         });
 392                     break;
 393 
 394                 case MovHint:
 395                 case PutHint:
 396                     break;
 397 
 398                 case GetButterfly:
 399                     // This barely works. The danger is that the GetButterfly is used by something that
 400                     // does something escaping to a candidate. Fortunately, the only butterfly-using ops
 401                     // that we exempt here also use the candidate directly. If there ever was a
 402                     // butterfly-using op that we wanted to exempt, then we&#39;d have to look at the
 403                     // butterfly&#39;s child and check if it&#39;s a candidate.
 404                     break;
 405 
<a name="4" id="anc4"></a><span class="line-modified"> 406                 case FilterGetByStatus:</span>
 407                 case FilterPutByIdStatus:
 408                 case FilterCallLinkStatus:
 409                 case FilterInByIdStatus:
 410                     break;
 411 
<a name="5" id="anc5"></a><span class="line-added"> 412                 case CheckArrayOrEmpty:</span>
 413                 case CheckArray:
 414                     escapeBasedOnArrayMode(node-&gt;arrayMode(), node-&gt;child1(), node);
 415                     break;
 416 
 417                 case CheckStructureOrEmpty:
 418                 case CheckStructure: {
 419                     Node* target = node-&gt;child1().node();
 420                     if (!m_candidates.contains(target))
 421                         break;
 422 
 423                     Structure* structure = nullptr;
 424                     JSGlobalObject* globalObject = m_graph.globalObjectFor(target-&gt;origin.semantic);
 425                     switch (target-&gt;op()) {
 426                     case CreateDirectArguments:
 427                         structure = globalObject-&gt;directArgumentsStructure();
 428                         break;
 429                     case CreateClonedArguments:
 430                         structure = globalObject-&gt;clonedArgumentsStructure();
 431                         break;
 432                     case CreateRest:
 433                         ASSERT(m_graph.isWatchingHavingABadTimeWatchpoint(target));
 434                         structure = globalObject-&gt;restParameterStructure();
 435                         break;
 436                     case NewArrayWithSpread:
 437                         ASSERT(m_graph.isWatchingHavingABadTimeWatchpoint(target));
 438                         structure = globalObject-&gt;originalArrayStructureForIndexingType(ArrayWithContiguous);
 439                         break;
 440                     case NewArrayBuffer: {
 441                         ASSERT(m_graph.isWatchingHavingABadTimeWatchpoint(target));
 442                         IndexingType indexingMode = target-&gt;indexingMode();
 443                         ASSERT(!hasAnyArrayStorage(indexingMode));
 444                         structure = globalObject-&gt;originalArrayStructureForIndexingType(indexingMode);
 445                         break;
 446                     }
 447                     default:
 448                         RELEASE_ASSERT_NOT_REACHED();
 449                     }
 450                     ASSERT(structure);
 451 
 452                     if (!node-&gt;structureSet().contains(m_graph.registerStructure(structure)))
 453                         escape(node-&gt;child1(), node);
 454                     break;
 455                 }
 456 
 457                 // FIXME: We should be able to handle GetById/GetByOffset on callee.
 458                 // https://bugs.webkit.org/show_bug.cgi?id=143075
 459 
 460                 case GetByOffset:
 461                     if (node-&gt;child2()-&gt;op() == CreateClonedArguments &amp;&amp; node-&gt;storageAccessData().offset == clonedArgumentsLengthPropertyOffset)
 462                         break;
 463                     FALLTHROUGH;
 464                 default:
 465                     m_graph.doToChildren(node, [&amp;] (Edge edge) { return escape(edge, node); });
 466                     break;
 467                 }
 468                 if (node-&gt;isPseudoTerminal())
 469                     break;
 470             }
 471         }
 472 
 473         if (DFGArgumentsEliminationPhaseInternal::verbose)
 474             dataLog(&quot;After escape analysis: &quot;, listDump(m_candidates), &quot;\n&quot;);
 475     }
 476 
 477     // Anywhere that a candidate is live (in bytecode or in DFG), check if there is a chance of
 478     // interference between the stack area that the arguments object copies from and the arguments
 479     // object&#39;s payload. Conservatively this means that the stack region doesn&#39;t get stored to.
 480     void eliminateCandidatesThatInterfere()
 481     {
 482         performLivenessAnalysis(m_graph);
 483         performOSRAvailabilityAnalysis(m_graph);
 484         m_graph.initializeNodeOwners();
 485         CombinedLiveness combinedLiveness(m_graph);
 486 
 487         BlockMap&lt;Operands&lt;bool&gt;&gt; clobberedByBlock(m_graph);
 488         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
 489             Operands&lt;bool&gt;&amp; clobberedByThisBlock = clobberedByBlock[block];
 490             clobberedByThisBlock = Operands&lt;bool&gt;(OperandsLike, m_graph.block(0)-&gt;variablesAtHead);
 491             for (Node* node : *block) {
 492                 clobberize(
 493                     m_graph, node, NoOpClobberize(),
 494                     [&amp;] (AbstractHeap heap) {
 495                         if (heap.kind() != Stack) {
 496                             ASSERT(!heap.overlaps(Stack));
 497                             return;
 498                         }
 499                         ASSERT(!heap.payload().isTop());
<a name="6" id="anc6"></a><span class="line-modified"> 500                         Operand operand = heap.operand();</span>
 501                         // The register may not point to an argument or local, for example if we are looking at SetArgumentCountIncludingThis.
<a name="7" id="anc7"></a><span class="line-modified"> 502                         if (!operand.isHeader())</span>
<span class="line-modified"> 503                             clobberedByThisBlock.operand(operand) = true;</span>
 504                     },
 505                     NoOpClobberize());
 506             }
 507         }
 508 
 509         using InlineCallFrames = HashSet&lt;InlineCallFrame*, WTF::DefaultHash&lt;InlineCallFrame*&gt;::Hash, WTF::NullableHashTraits&lt;InlineCallFrame*&gt;&gt;;
 510         using InlineCallFramesForCanditates = HashMap&lt;Node*, InlineCallFrames&gt;;
 511         InlineCallFramesForCanditates inlineCallFramesForCandidate;
 512         auto forEachDependentNode = recursableLambda([&amp;](auto self, Node* node, const auto&amp; functor) -&gt; void {
 513             functor(node);
 514 
 515             if (node-&gt;op() == Spread) {
 516                 self(node-&gt;child1().node(), functor);
 517                 return;
 518             }
 519 
 520             if (node-&gt;op() == NewArrayWithSpread) {
 521                 BitVector* bitVector = node-&gt;bitVector();
 522                 for (unsigned i = node-&gt;numChildren(); i--; ) {
 523                     if (bitVector-&gt;get(i))
 524                         self(m_graph.varArgChild(node, i).node(), functor);
 525                 }
 526                 return;
 527             }
 528         });
 529         for (Node* candidate : m_candidates) {
 530             auto&amp; set = inlineCallFramesForCandidate.add(candidate, InlineCallFrames()).iterator-&gt;value;
 531             forEachDependentNode(candidate, [&amp;](Node* dependent) {
 532                 set.add(dependent-&gt;origin.semantic.inlineCallFrame());
 533             });
 534         }
 535 
 536         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
 537             // Stop if we&#39;ve already removed all candidates.
 538             if (m_candidates.isEmpty())
 539                 return;
 540 
 541             // Ignore blocks that don&#39;t write to the stack.
 542             bool writesToStack = false;
 543             for (unsigned i = clobberedByBlock[block].size(); i--;) {
 544                 if (clobberedByBlock[block][i]) {
 545                     writesToStack = true;
 546                     break;
 547                 }
 548             }
 549             if (!writesToStack)
 550                 continue;
 551 
 552             forAllKillsInBlock(
 553                 m_graph, combinedLiveness, block,
 554                 [&amp;] (unsigned nodeIndex, Node* candidate) {
 555                     if (!m_candidates.contains(candidate))
 556                         return;
 557 
 558                     for (InlineCallFrame* inlineCallFrame : inlineCallFramesForCandidate.get(candidate)) {
 559                         // Check if this block has any clobbers that affect this candidate. This is a fairly
 560                         // fast check.
 561                         bool isClobberedByBlock = false;
 562                         Operands&lt;bool&gt;&amp; clobberedByThisBlock = clobberedByBlock[block];
 563 
 564                         if (inlineCallFrame) {
 565                             if (inlineCallFrame-&gt;isVarargs()) {
 566                                 isClobberedByBlock |= clobberedByThisBlock.operand(
<a name="8" id="anc8"></a><span class="line-modified"> 567                                     VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCountIncludingThis));</span>
 568                             }
 569 
 570                             if (!isClobberedByBlock || inlineCallFrame-&gt;isClosureCall) {
 571                                 isClobberedByBlock |= clobberedByThisBlock.operand(
<a name="9" id="anc9"></a><span class="line-modified"> 572                                     VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee));</span>
 573                             }
 574 
 575                             if (!isClobberedByBlock) {
<a name="10" id="anc10"></a><span class="line-modified"> 576                                 for (unsigned i = 0; i &lt; static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1); ++i) {</span>
 577                                     VirtualRegister reg =
 578                                         VirtualRegister(inlineCallFrame-&gt;stackOffset) +
 579                                         CallFrame::argumentOffset(i);
 580                                     if (clobberedByThisBlock.operand(reg)) {
 581                                         isClobberedByBlock = true;
 582                                         break;
 583                                     }
 584                                 }
 585                             }
 586                         } else {
 587                             // We don&#39;t include the ArgumentCount or Callee in this case because we can be
 588                             // damn sure that this won&#39;t be clobbered.
 589                             for (unsigned i = 1; i &lt; static_cast&lt;unsigned&gt;(codeBlock()-&gt;numParameters()); ++i) {
 590                                 if (clobberedByThisBlock.argument(i)) {
 591                                     isClobberedByBlock = true;
 592                                     break;
 593                                 }
 594                             }
 595                         }
 596 
 597                         if (!isClobberedByBlock)
 598                             continue;
 599 
 600                         // Check if we can immediately eliminate this candidate. If the block has a clobber
 601                         // for this arguments allocation, and we&#39;d have to examine every node in the block,
 602                         // then we can just eliminate the candidate.
 603                         if (nodeIndex == block-&gt;size() &amp;&amp; candidate-&gt;owner != block) {
 604                             if (DFGArgumentsEliminationPhaseInternal::verbose)
 605                                 dataLog(&quot;eliminating candidate: &quot;, candidate, &quot; because it is clobbered by: &quot;, block-&gt;at(nodeIndex), &quot;\n&quot;);
 606                             transitivelyRemoveCandidate(candidate);
 607                             return;
 608                         }
 609 
 610                         // This loop considers all nodes up to the nodeIndex, excluding the nodeIndex.
 611                         //
 612                         // Note: nodeIndex here has a double meaning. Before entering this
 613                         // while loop, it refers to the remaining number of nodes that have
 614                         // yet to be processed. Inside the look, it refers to the index
 615                         // of the current node to process (after we decrement it).
 616                         //
 617                         // If the remaining number of nodes is 0, we should not decrement nodeIndex.
 618                         // Hence, we must only decrement nodeIndex inside the while loop instead of
 619                         // in its condition statement. Note that this while loop is embedded in an
 620                         // outer for loop. If we decrement nodeIndex in the condition statement, a
 621                         // nodeIndex of 0 will become UINT_MAX, and the outer loop will wrongly
 622                         // treat this as there being UINT_MAX remaining nodes to process.
 623                         while (nodeIndex) {
 624                             --nodeIndex;
 625                             Node* node = block-&gt;at(nodeIndex);
 626                             if (node == candidate)
 627                                 break;
 628 
 629                             bool found = false;
 630                             clobberize(
 631                                 m_graph, node, NoOpClobberize(),
 632                                 [&amp;] (AbstractHeap heap) {
 633                                     if (heap.kind() == Stack &amp;&amp; !heap.payload().isTop()) {
<a name="11" id="anc11"></a><span class="line-modified"> 634                                         if (argumentsInvolveStackSlot(inlineCallFrame, heap.operand()))</span>
 635                                             found = true;
 636                                         return;
 637                                     }
 638                                     if (heap.overlaps(Stack))
 639                                         found = true;
 640                                 },
 641                                 NoOpClobberize());
 642 
 643                             if (found) {
 644                                 if (DFGArgumentsEliminationPhaseInternal::verbose)
 645                                     dataLog(&quot;eliminating candidate: &quot;, candidate, &quot; because it is clobbered by &quot;, block-&gt;at(nodeIndex), &quot;\n&quot;);
 646                                 transitivelyRemoveCandidate(candidate);
 647                                 return;
 648                             }
 649                         }
 650                     }
 651                 });
 652         }
 653 
 654         // Q: How do we handle OSR exit with a live PhantomArguments at a point where the inline call
 655         // frame is dead?  A: Naively we could say that PhantomArguments must escape the stack slots. But
 656         // that would break PutStack sinking, which in turn would break object allocation sinking, in
 657         // cases where we have a varargs call to an otherwise pure method. So, we need something smarter.
 658         // For the outermost arguments, we just have a PhantomArguments that magically knows that it
 659         // should load the arguments from the call frame. For the inline arguments, we have the heap map
 660         // in the availabiltiy map track each possible inline argument as a promoted heap location. If the
 661         // PutStacks for those arguments aren&#39;t sunk, those heap locations will map to very trivial
 662         // availabilities (they will be flush availabilities). But if sinking happens then those
 663         // availabilities may become whatever. OSR exit should be able to handle this quite naturally,
 664         // since those availabilities speak of the stack before the optimizing compiler stack frame is
 665         // torn down.
 666 
 667         if (DFGArgumentsEliminationPhaseInternal::verbose)
 668             dataLog(&quot;After interference analysis: &quot;, listDump(m_candidates), &quot;\n&quot;);
 669     }
 670 
 671     void transform()
 672     {
 673         bool modifiedCFG = false;
 674 
 675         InsertionSet insertionSet(m_graph);
 676 
 677         for (BasicBlock* block : m_graph.blocksInPreOrder()) {
 678             Node* pseudoTerminal = nullptr;
 679             for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
 680                 Node* node = block-&gt;at(nodeIndex);
 681 
 682                 auto getArrayLength = [&amp;] (Node* candidate) -&gt; Node* {
 683                     return emitCodeToGetArgumentsArrayLength(
 684                         insertionSet, candidate, nodeIndex, node-&gt;origin);
 685                 };
 686 
 687                 auto isEliminatedAllocation = [&amp;] (Node* candidate) -&gt; bool {
 688                     if (!m_candidates.contains(candidate))
 689                         return false;
 690                     // We traverse in such a way that we are guaranteed to see a def before a use.
 691                     // Therefore, we should have already transformed the allocation before the use
 692                     // of an allocation.
 693                     ASSERT(candidate-&gt;op() == PhantomCreateRest || candidate-&gt;op() == PhantomDirectArguments || candidate-&gt;op() == PhantomClonedArguments
 694                         || candidate-&gt;op() == PhantomSpread || candidate-&gt;op() == PhantomNewArrayWithSpread || candidate-&gt;op() == PhantomNewArrayBuffer);
 695                     return true;
 696                 };
 697 
 698                 switch (node-&gt;op()) {
 699                 case CreateDirectArguments:
 700                     if (!m_candidates.contains(node))
 701                         break;
 702 
 703                     node-&gt;setOpAndDefaultFlags(PhantomDirectArguments);
 704                     break;
 705 
 706                 case CreateRest:
 707                     if (!m_candidates.contains(node))
 708                         break;
 709 
 710                     ASSERT(node-&gt;origin.exitOK);
 711                     ASSERT(node-&gt;child1().useKind() == Int32Use);
 712                     insertionSet.insertNode(
 713                         nodeIndex, SpecNone, Check, node-&gt;origin,
 714                         node-&gt;child1());
 715 
 716                     node-&gt;setOpAndDefaultFlags(PhantomCreateRest);
 717                     // We don&#39;t need this parameter for OSR exit, we can find out all the information
 718                     // we need via the static parameter count and the dynamic argument count.
 719                     node-&gt;child1() = Edge();
 720                     break;
 721 
 722                 case CreateClonedArguments:
 723                     if (!m_candidates.contains(node))
 724                         break;
 725 
 726                     node-&gt;setOpAndDefaultFlags(PhantomClonedArguments);
 727                     break;
 728 
 729                 case Spread:
 730                     if (!m_candidates.contains(node))
 731                         break;
 732 
 733                     node-&gt;setOpAndDefaultFlags(PhantomSpread);
 734                     break;
 735 
 736                 case NewArrayWithSpread:
 737                     if (!m_candidates.contains(node))
 738                         break;
 739 
 740                     node-&gt;setOpAndDefaultFlags(PhantomNewArrayWithSpread);
 741                     break;
 742 
 743                 case NewArrayBuffer:
 744                     if (!m_candidates.contains(node))
 745                         break;
 746 
 747                     node-&gt;setOpAndDefaultFlags(PhantomNewArrayBuffer);
 748                     node-&gt;child1() = Edge(insertionSet.insertConstant(nodeIndex, node-&gt;origin, node-&gt;cellOperand()));
 749                     break;
 750 
 751                 case GetFromArguments: {
 752                     Node* candidate = node-&gt;child1().node();
 753                     if (!isEliminatedAllocation(candidate))
 754                         break;
 755 
 756                     DFG_ASSERT(
 757                         m_graph, node, node-&gt;child1()-&gt;op() == PhantomDirectArguments, node-&gt;child1()-&gt;op());
 758                     VirtualRegister reg =
<a name="12" id="anc12"></a><span class="line-modified"> 759                         virtualRegisterForArgumentIncludingThis(node-&gt;capturedArgumentsOffset().offset() + 1) +</span>
 760                         node-&gt;origin.semantic.stackOffset();
 761                     StackAccessData* data = m_graph.m_stackAccessData.add(reg, FlushedJSValue);
 762                     node-&gt;convertToGetStack(data);
 763                     break;
 764                 }
 765 
 766                 case GetByOffset: {
 767                     Node* candidate = node-&gt;child2().node();
 768                     if (!isEliminatedAllocation(candidate))
 769                         break;
 770 
 771                     ASSERT(candidate-&gt;op() == PhantomClonedArguments);
 772                     ASSERT(node-&gt;storageAccessData().offset == clonedArgumentsLengthPropertyOffset);
 773 
 774                     // Meh, this is kind of hackish - we use an Identity so that we can reuse the
 775                     // getArrayLength() helper.
 776                     node-&gt;convertToIdentityOn(getArrayLength(candidate));
 777                     break;
 778                 }
 779 
 780                 case GetArrayLength: {
 781                     Node* candidate = node-&gt;child1().node();
 782                     if (!isEliminatedAllocation(candidate))
 783                         break;
 784 
 785                     node-&gt;convertToIdentityOn(getArrayLength(candidate));
 786                     break;
 787                 }
 788 
 789                 case GetByVal: {
 790                     // FIXME: For ClonedArguments, we would have already done a separate bounds check.
 791                     // This code will cause us to have two bounds checks - the original one that we
 792                     // already factored out in SSALoweringPhase, and the new one we insert here, which is
 793                     // often implicitly part of GetMyArgumentByVal. B3 will probably eliminate the
 794                     // second bounds check, but still - that&#39;s just silly.
 795                     // https://bugs.webkit.org/show_bug.cgi?id=143076
 796 
 797                     Node* candidate = m_graph.varArgChild(node, 0).node();
 798                     if (!isEliminatedAllocation(candidate))
 799                         break;
 800 
 801                     unsigned numberOfArgumentsToSkip = 0;
 802                     if (candidate-&gt;op() == PhantomCreateRest)
 803                         numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
 804 
 805                     Node* result = nullptr;
 806                     if (m_graph.varArgChild(node, 1)-&gt;isInt32Constant()) {
 807                         unsigned index = m_graph.varArgChild(node, 1)-&gt;asUInt32();
 808                         InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
 809                         index += numberOfArgumentsToSkip;
 810 
 811                         bool safeToGetStack = index &gt;= numberOfArgumentsToSkip;
 812                         if (inlineCallFrame)
<a name="13" id="anc13"></a><span class="line-modified"> 813                             safeToGetStack &amp;= index &lt; static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1);</span>
 814                         else {
 815                             safeToGetStack &amp;=
 816                                 index &lt; static_cast&lt;unsigned&gt;(codeBlock()-&gt;numParameters()) - 1;
 817                         }
 818                         if (safeToGetStack) {
 819                             StackAccessData* data;
<a name="14" id="anc14"></a><span class="line-modified"> 820                             VirtualRegister arg = virtualRegisterForArgumentIncludingThis(index + 1);</span>
 821                             if (inlineCallFrame)
 822                                 arg += inlineCallFrame-&gt;stackOffset;
 823                             data = m_graph.m_stackAccessData.add(arg, FlushedJSValue);
 824 
 825                             Node* check = nullptr;
 826                             if (!inlineCallFrame || inlineCallFrame-&gt;isVarargs()) {
 827                                 check = insertionSet.insertNode(
 828                                     nodeIndex, SpecNone, CheckInBounds, node-&gt;origin,
 829                                     m_graph.varArgChild(node, 1), Edge(getArrayLength(candidate), Int32Use));
 830                             }
 831 
 832                             result = insertionSet.insertNode(
 833                                 nodeIndex, node-&gt;prediction(), GetStack, node-&gt;origin, OpInfo(data), Edge(check, UntypedUse));
 834                         }
 835                     }
 836 
 837                     if (!result) {
 838                         NodeType op;
 839                         if (node-&gt;arrayMode().isInBounds())
 840                             op = GetMyArgumentByVal;
 841                         else
 842                             op = GetMyArgumentByValOutOfBounds;
 843                         result = insertionSet.insertNode(
 844                             nodeIndex, node-&gt;prediction(), op, node-&gt;origin, OpInfo(numberOfArgumentsToSkip),
 845                             m_graph.varArgChild(node, 0), m_graph.varArgChild(node, 1));
 846                     }
 847 
 848                     // Need to do this because we may have a data format conversion here.
 849                     node-&gt;convertToIdentityOn(result);
 850                     break;
 851                 }
 852 
<a name="15" id="anc15"></a><span class="line-added"> 853                 case VarargsLength: {</span>
<span class="line-added"> 854                     Node* candidate = node-&gt;argumentsChild().node();</span>
<span class="line-added"> 855                     if (!isEliminatedAllocation(candidate))</span>
<span class="line-added"> 856                         break;</span>
<span class="line-added"> 857 </span>
<span class="line-added"> 858                     // VarargsLength can exit, so it better be exitOK.</span>
<span class="line-added"> 859                     DFG_ASSERT(m_graph, node, node-&gt;origin.exitOK);</span>
<span class="line-added"> 860                     NodeOrigin origin = node-&gt;origin.withExitOK(true);</span>
<span class="line-added"> 861 </span>
<span class="line-added"> 862 </span>
<span class="line-added"> 863                     node-&gt;convertToIdentityOn(emitCodeToGetArgumentsArrayLength(insertionSet, candidate, nodeIndex, origin, /* addThis = */ true));</span>
<span class="line-added"> 864                     break;</span>
<span class="line-added"> 865                 }</span>
<span class="line-added"> 866 </span>
 867                 case LoadVarargs: {
<a name="16" id="anc16"></a><span class="line-modified"> 868                     Node* candidate = node-&gt;argumentsChild().node();</span>
 869                     if (!isEliminatedAllocation(candidate))
 870                         break;
 871 
 872                     // LoadVarargs can exit, so it better be exitOK.
 873                     DFG_ASSERT(m_graph, node, node-&gt;origin.exitOK);
 874                     bool canExit = true;
 875                     LoadVarargsData* varargsData = node-&gt;loadVarargsData();
 876 
 877                     auto storeArgumentCountIncludingThis = [&amp;] (unsigned argumentCountIncludingThis) {
 878                         Node* argumentCountIncludingThisNode = insertionSet.insertConstant(
 879                             nodeIndex, node-&gt;origin.withExitOK(canExit),
 880                             jsNumber(argumentCountIncludingThis));
 881                         insertionSet.insertNode(
 882                             nodeIndex, SpecNone, KillStack, node-&gt;origin.takeValidExit(canExit),
<a name="17" id="anc17"></a><span class="line-modified"> 883                             OpInfo(varargsData-&gt;count));</span>
 884                         insertionSet.insertNode(
 885                             nodeIndex, SpecNone, MovHint, node-&gt;origin.takeValidExit(canExit),
<a name="18" id="anc18"></a><span class="line-modified"> 886                             OpInfo(varargsData-&gt;count), Edge(argumentCountIncludingThisNode));</span>
 887                         insertionSet.insertNode(
 888                             nodeIndex, SpecNone, PutStack, node-&gt;origin.withExitOK(canExit),
 889                             OpInfo(m_graph.m_stackAccessData.add(varargsData-&gt;count, FlushedInt32)),
 890                             Edge(argumentCountIncludingThisNode, KnownInt32Use));
 891                     };
 892 
 893                     auto storeValue = [&amp;] (Node* value, unsigned storeIndex) {
 894                         VirtualRegister reg = varargsData-&gt;start + storeIndex;
<a name="19" id="anc19"></a><span class="line-added"> 895                         ASSERT(reg.isLocal());</span>
 896                         StackAccessData* data =
 897                             m_graph.m_stackAccessData.add(reg, FlushedJSValue);
 898 
 899                         insertionSet.insertNode(
<a name="20" id="anc20"></a><span class="line-modified"> 900                             nodeIndex, SpecNone, KillStack, node-&gt;origin.takeValidExit(canExit), OpInfo(reg));</span>
 901                         insertionSet.insertNode(
 902                             nodeIndex, SpecNone, MovHint, node-&gt;origin.takeValidExit(canExit),
<a name="21" id="anc21"></a><span class="line-modified"> 903                             OpInfo(reg), Edge(value));</span>
 904                         insertionSet.insertNode(
 905                             nodeIndex, SpecNone, PutStack, node-&gt;origin.withExitOK(canExit),
 906                             OpInfo(data), Edge(value));
 907                     };
 908 
 909                     if (candidate-&gt;op() == PhantomNewArrayWithSpread || candidate-&gt;op() == PhantomNewArrayBuffer || candidate-&gt;op() == PhantomSpread) {
 910                         auto canConvertToStaticLoadStores = recursableLambda([&amp;] (auto self, Node* candidate) -&gt; bool {
 911                             if (candidate-&gt;op() == PhantomSpread)
 912                                 return self(candidate-&gt;child1().node());
 913 
 914                             if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
 915                                 BitVector* bitVector = candidate-&gt;bitVector();
 916                                 for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
 917                                     if (bitVector-&gt;get(i)) {
 918                                         if (!self(m_graph.varArgChild(candidate, i).node()))
 919                                             return false;
 920                                     }
 921                                 }
 922                                 return true;
 923                             }
 924 
 925                             // PhantomNewArrayBuffer only contains constants. It can always convert LoadVarargs to static load stores.
 926                             if (candidate-&gt;op() == PhantomNewArrayBuffer)
 927                                 return true;
 928 
 929                             ASSERT(candidate-&gt;op() == PhantomCreateRest);
 930                             InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
 931                             return inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs();
 932                         });
 933 
 934                         if (canConvertToStaticLoadStores(candidate)) {
 935                             auto countNumberOfArguments = recursableLambda([&amp;](auto self, Node* candidate) -&gt; unsigned {
 936                                 if (candidate-&gt;op() == PhantomSpread)
 937                                     return self(candidate-&gt;child1().node());
 938 
 939                                 if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
 940                                     BitVector* bitVector = candidate-&gt;bitVector();
 941                                     unsigned result = 0;
 942                                     for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
 943                                         if (bitVector-&gt;get(i))
 944                                             result += self(m_graph.varArgChild(candidate, i).node());
 945                                         else
 946                                             ++result;
 947                                     }
 948                                     return result;
 949                                 }
 950 
 951                                 if (candidate-&gt;op() == PhantomNewArrayBuffer)
 952                                     return candidate-&gt;castOperand&lt;JSImmutableButterfly*&gt;()-&gt;length();
 953 
 954                                 ASSERT(candidate-&gt;op() == PhantomCreateRest);
 955                                 unsigned numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
 956                                 InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
<a name="22" id="anc22"></a><span class="line-modified"> 957                                 unsigned frameArgumentCount = static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1);</span>
 958                                 if (frameArgumentCount &gt;= numberOfArgumentsToSkip)
 959                                     return frameArgumentCount - numberOfArgumentsToSkip;
 960                                 return 0;
 961                             });
 962 
 963                             unsigned argumentCountIncludingThis = 1 + countNumberOfArguments(candidate); // |this|
 964                             if (argumentCountIncludingThis &lt;= varargsData-&gt;limit) {
 965                                 storeArgumentCountIncludingThis(argumentCountIncludingThis);
 966 
 967                                 DFG_ASSERT(m_graph, node, varargsData-&gt;limit - 1 &gt;= varargsData-&gt;mandatoryMinimum, varargsData-&gt;limit, varargsData-&gt;mandatoryMinimum);
 968                                 // Define our limit to exclude &quot;this&quot;, since that&#39;s a bit easier to reason about.
 969                                 unsigned limit = varargsData-&gt;limit - 1;
 970 
 971                                 auto forwardNode = recursableLambda([&amp;](auto self, Node* candidate, unsigned storeIndex) -&gt; unsigned {
 972                                     if (candidate-&gt;op() == PhantomSpread)
 973                                         return self(candidate-&gt;child1().node(), storeIndex);
 974 
 975                                     if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
 976                                         BitVector* bitVector = candidate-&gt;bitVector();
 977                                         for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
 978                                             if (bitVector-&gt;get(i))
 979                                                 storeIndex = self(m_graph.varArgChild(candidate, i).node(), storeIndex);
 980                                             else {
 981                                                 Node* value = m_graph.varArgChild(candidate, i).node();
 982                                                 storeValue(value, storeIndex++);
 983                                             }
 984                                         }
 985                                         return storeIndex;
 986                                     }
 987 
 988                                     if (candidate-&gt;op() == PhantomNewArrayBuffer) {
 989                                         auto* array = candidate-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
 990                                         for (unsigned index = 0; index &lt; array-&gt;length(); ++index) {
 991                                             JSValue constant;
 992                                             if (candidate-&gt;indexingType() == ArrayWithDouble)
 993                                                 constant = jsDoubleNumber(array-&gt;get(index).asNumber());
 994                                             else
 995                                                 constant = array-&gt;get(index);
 996                                             Node* value = insertionSet.insertConstant(nodeIndex, node-&gt;origin.withExitOK(canExit), constant);
 997                                             storeValue(value, storeIndex++);
 998                                         }
 999                                         return storeIndex;
1000                                     }
1001 
1002                                     ASSERT(candidate-&gt;op() == PhantomCreateRest);
1003                                     unsigned numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
1004                                     InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
<a name="23" id="anc23"></a><span class="line-modified">1005                                     unsigned frameArgumentCount = static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1);</span>
1006                                     for (unsigned loadIndex = numberOfArgumentsToSkip; loadIndex &lt; frameArgumentCount; ++loadIndex) {
<a name="24" id="anc24"></a><span class="line-modified">1007                                         VirtualRegister reg = virtualRegisterForArgumentIncludingThis(loadIndex + 1) + inlineCallFrame-&gt;stackOffset;</span>
1008                                         StackAccessData* data = m_graph.m_stackAccessData.add(reg, FlushedJSValue);
1009                                         Node* value = insertionSet.insertNode(
1010                                             nodeIndex, SpecNone, GetStack, node-&gt;origin.withExitOK(canExit),
1011                                             OpInfo(data));
1012                                         storeValue(value, storeIndex++);
1013                                     }
1014                                     return storeIndex;
1015                                 });
1016 
1017                                 unsigned storeIndex = forwardNode(candidate, 0);
1018                                 RELEASE_ASSERT(storeIndex &lt;= limit);
1019                                 Node* undefined = nullptr;
1020                                 for (; storeIndex &lt; limit; ++storeIndex) {
1021                                     if (!undefined) {
1022                                         undefined = insertionSet.insertConstant(
1023                                             nodeIndex, node-&gt;origin.withExitOK(canExit), jsUndefined());
1024                                     }
1025                                     storeValue(undefined, storeIndex);
1026                                 }
1027 
1028                                 node-&gt;remove(m_graph);
1029                                 node-&gt;origin.exitOK = canExit;
1030                                 break;
1031                             }
1032                         }
1033                     } else {
1034                         unsigned numberOfArgumentsToSkip = 0;
1035                         if (candidate-&gt;op() == PhantomCreateRest)
1036                             numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
1037                         varargsData-&gt;offset += numberOfArgumentsToSkip;
1038 
1039                         InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
1040 
<a name="25" id="anc25"></a><span class="line-modified">1041                         if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {</span>


1042                             unsigned argumentCountIncludingThis = inlineCallFrame-&gt;argumentCountIncludingThis;
1043                             if (argumentCountIncludingThis &gt; varargsData-&gt;offset)
1044                                 argumentCountIncludingThis -= varargsData-&gt;offset;
1045                             else
1046                                 argumentCountIncludingThis = 1;
1047                             RELEASE_ASSERT(argumentCountIncludingThis &gt;= 1);
1048 
1049                             if (argumentCountIncludingThis &lt;= varargsData-&gt;limit) {
<a name="26" id="anc26"></a>
1050                                 storeArgumentCountIncludingThis(argumentCountIncludingThis);
1051 
1052                                 DFG_ASSERT(m_graph, node, varargsData-&gt;limit - 1 &gt;= varargsData-&gt;mandatoryMinimum, varargsData-&gt;limit, varargsData-&gt;mandatoryMinimum);
1053                                 // Define our limit to exclude &quot;this&quot;, since that&#39;s a bit easier to reason about.
1054                                 unsigned limit = varargsData-&gt;limit - 1;
1055                                 Node* undefined = nullptr;
1056                                 for (unsigned storeIndex = 0; storeIndex &lt; limit; ++storeIndex) {
1057                                     // First determine if we have an element we can load, and load it if
1058                                     // possible.
1059 
1060                                     Node* value = nullptr;
1061                                     unsigned loadIndex = storeIndex + varargsData-&gt;offset;
1062 
1063                                     if (loadIndex + 1 &lt; inlineCallFrame-&gt;argumentCountIncludingThis) {
<a name="27" id="anc27"></a><span class="line-modified">1064                                         VirtualRegister reg = virtualRegisterForArgumentIncludingThis(loadIndex + 1) + inlineCallFrame-&gt;stackOffset;</span>
1065                                         StackAccessData* data = m_graph.m_stackAccessData.add(
1066                                             reg, FlushedJSValue);
1067 
1068                                         value = insertionSet.insertNode(
1069                                             nodeIndex, SpecNone, GetStack, node-&gt;origin.withExitOK(canExit),
1070                                             OpInfo(data));
1071                                     } else {
1072                                         // FIXME: We shouldn&#39;t have to store anything if
1073                                         // storeIndex &gt;= varargsData-&gt;mandatoryMinimum, but we will still
1074                                         // have GetStacks in that range. So if we don&#39;t do the stores, we&#39;ll
1075                                         // have degenerate IR: we&#39;ll have GetStacks of something that didn&#39;t
1076                                         // have PutStacks.
1077                                         // https://bugs.webkit.org/show_bug.cgi?id=147434
1078 
1079                                         if (!undefined) {
1080                                             undefined = insertionSet.insertConstant(
1081                                                 nodeIndex, node-&gt;origin.withExitOK(canExit), jsUndefined());
1082                                         }
1083                                         value = undefined;
1084                                     }
1085 
1086                                     // Now that we have a value, store it.
1087                                     storeValue(value, storeIndex);
1088                                 }
1089 
1090                                 node-&gt;remove(m_graph);
1091                                 node-&gt;origin.exitOK = canExit;
1092                                 break;
1093                             }
1094                         }
1095                     }
1096 
1097                     node-&gt;setOpAndDefaultFlags(ForwardVarargs);
1098                     break;
1099                 }
1100 
1101                 case CallVarargs:
1102                 case ConstructVarargs:
1103                 case TailCallVarargs:
1104                 case TailCallVarargsInlinedCaller: {
1105                     Node* candidate = node-&gt;child3().node();
1106                     if (!isEliminatedAllocation(candidate))
1107                         break;
1108 
1109                     auto convertToStaticArgumentCountCall = [&amp;] (const Vector&lt;Node*&gt;&amp; arguments) {
1110                         unsigned firstChild = m_graph.m_varArgChildren.size();
1111                         m_graph.m_varArgChildren.append(node-&gt;child1());
1112                         m_graph.m_varArgChildren.append(node-&gt;child2());
1113                         for (Node* argument : arguments)
1114                             m_graph.m_varArgChildren.append(Edge(argument));
1115                         switch (node-&gt;op()) {
1116                         case CallVarargs:
1117                             node-&gt;setOpAndDefaultFlags(Call);
1118                             break;
1119                         case ConstructVarargs:
1120                             node-&gt;setOpAndDefaultFlags(Construct);
1121                             break;
1122                         case TailCallVarargs:
1123                             node-&gt;setOpAndDefaultFlags(TailCall);
1124                             break;
1125                         case TailCallVarargsInlinedCaller:
1126                             node-&gt;setOpAndDefaultFlags(TailCallInlinedCaller);
1127                             break;
1128                         default:
1129                             RELEASE_ASSERT_NOT_REACHED();
1130                         }
1131                         node-&gt;children = AdjacencyList(
1132                             AdjacencyList::Variable,
1133                             firstChild, m_graph.m_varArgChildren.size() - firstChild);
1134                     };
1135 
1136                     auto convertToForwardsCall = [&amp;] () {
1137                         switch (node-&gt;op()) {
1138                         case CallVarargs:
1139                             node-&gt;setOpAndDefaultFlags(CallForwardVarargs);
1140                             break;
1141                         case ConstructVarargs:
1142                             node-&gt;setOpAndDefaultFlags(ConstructForwardVarargs);
1143                             break;
1144                         case TailCallVarargs:
1145                             node-&gt;setOpAndDefaultFlags(TailCallForwardVarargs);
1146                             break;
1147                         case TailCallVarargsInlinedCaller:
1148                             node-&gt;setOpAndDefaultFlags(TailCallForwardVarargsInlinedCaller);
1149                             break;
1150                         default:
1151                             RELEASE_ASSERT_NOT_REACHED();
1152                         }
1153                     };
1154 
1155                     if (candidate-&gt;op() == PhantomNewArrayWithSpread || candidate-&gt;op() == PhantomNewArrayBuffer || candidate-&gt;op() == PhantomSpread) {
1156                         auto canTransformToStaticArgumentCountCall = recursableLambda([&amp;](auto self, Node* candidate) -&gt; bool {
1157                             if (candidate-&gt;op() == PhantomSpread)
1158                                 return self(candidate-&gt;child1().node());
1159 
1160                             if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
1161                                 BitVector* bitVector = candidate-&gt;bitVector();
1162                                 for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
1163                                     if (bitVector-&gt;get(i)) {
1164                                         Node* spread = m_graph.varArgChild(candidate, i).node();
1165                                         if (!self(spread))
1166                                             return false;
1167                                     }
1168                                 }
1169                                 return true;
1170                             }
1171 
1172                             // PhantomNewArrayBuffer only contains constants. It can always convert LoadVarargs to static load stores.
1173                             if (candidate-&gt;op() == PhantomNewArrayBuffer)
1174                                 return true;
1175 
1176                             ASSERT(candidate-&gt;op() == PhantomCreateRest);
1177                             InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
1178                             return inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs();
1179                         });
1180 
1181                         if (canTransformToStaticArgumentCountCall(candidate)) {
1182                             Vector&lt;Node*&gt; arguments;
1183                             auto appendNode = recursableLambda([&amp;](auto self, Node* candidate) -&gt; void {
1184                                 if (candidate-&gt;op() == PhantomSpread) {
1185                                     self(candidate-&gt;child1().node());
1186                                     return;
1187                                 }
1188 
1189                                 if (candidate-&gt;op() == PhantomNewArrayWithSpread) {
1190                                     BitVector* bitVector = candidate-&gt;bitVector();
1191                                     for (unsigned i = 0; i &lt; candidate-&gt;numChildren(); i++) {
1192                                         Node* child = m_graph.varArgChild(candidate, i).node();
1193                                         if (bitVector-&gt;get(i))
1194                                             self(child);
1195                                         else
1196                                             arguments.append(child);
1197                                     }
1198                                     return;
1199                                 }
1200 
1201                                 if (candidate-&gt;op() == PhantomNewArrayBuffer) {
1202                                     bool canExit = true;
1203                                     auto* array = candidate-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
1204                                     for (unsigned index = 0; index &lt; array-&gt;length(); ++index) {
1205                                         JSValue constant;
1206                                         if (candidate-&gt;indexingType() == ArrayWithDouble)
1207                                             constant = jsDoubleNumber(array-&gt;get(index).asNumber());
1208                                         else
1209                                             constant = array-&gt;get(index);
1210                                         arguments.append(insertionSet.insertConstant(nodeIndex, node-&gt;origin.withExitOK(canExit), constant));
1211                                     }
1212                                     return;
1213                                 }
1214 
1215                                 ASSERT(candidate-&gt;op() == PhantomCreateRest);
1216                                 InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
1217                                 unsigned numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
1218                                 for (unsigned i = 1 + numberOfArgumentsToSkip; i &lt; inlineCallFrame-&gt;argumentCountIncludingThis; ++i) {
1219                                     StackAccessData* data = m_graph.m_stackAccessData.add(
<a name="28" id="anc28"></a><span class="line-modified">1220                                         virtualRegisterForArgumentIncludingThis(i) + inlineCallFrame-&gt;stackOffset,</span>
1221                                         FlushedJSValue);
1222 
1223                                     Node* value = insertionSet.insertNode(
1224                                         nodeIndex, SpecNone, GetStack, node-&gt;origin, OpInfo(data));
1225 
1226                                     arguments.append(value);
1227                                 }
1228                             });
1229 
1230                             appendNode(candidate);
1231                             convertToStaticArgumentCountCall(arguments);
1232                         } else
1233                             convertToForwardsCall();
1234                     } else {
1235                         unsigned numberOfArgumentsToSkip = 0;
1236                         if (candidate-&gt;op() == PhantomCreateRest)
1237                             numberOfArgumentsToSkip = candidate-&gt;numberOfArgumentsToSkip();
1238                         CallVarargsData* varargsData = node-&gt;callVarargsData();
1239                         varargsData-&gt;firstVarArgOffset += numberOfArgumentsToSkip;
1240 
1241                         InlineCallFrame* inlineCallFrame = candidate-&gt;origin.semantic.inlineCallFrame();
1242                         if (inlineCallFrame &amp;&amp; !inlineCallFrame-&gt;isVarargs()) {
1243                             Vector&lt;Node*&gt; arguments;
1244                             for (unsigned i = 1 + varargsData-&gt;firstVarArgOffset; i &lt; inlineCallFrame-&gt;argumentCountIncludingThis; ++i) {
1245                                 StackAccessData* data = m_graph.m_stackAccessData.add(
<a name="29" id="anc29"></a><span class="line-modified">1246                                     virtualRegisterForArgumentIncludingThis(i) + inlineCallFrame-&gt;stackOffset,</span>
1247                                     FlushedJSValue);
1248 
1249                                 Node* value = insertionSet.insertNode(
1250                                     nodeIndex, SpecNone, GetStack, node-&gt;origin, OpInfo(data));
1251 
1252                                 arguments.append(value);
1253                             }
1254 
1255                             convertToStaticArgumentCountCall(arguments);
1256                         } else
1257                             convertToForwardsCall();
1258                     }
1259 
1260                     break;
1261                 }
1262 
<a name="30" id="anc30"></a><span class="line-added">1263                 case CheckArrayOrEmpty:</span>
1264                 case CheckArray:
1265                 case GetButterfly:
<a name="31" id="anc31"></a><span class="line-modified">1266                 case FilterGetByStatus:</span>
1267                 case FilterPutByIdStatus:
1268                 case FilterCallLinkStatus:
1269                 case FilterInByIdStatus: {
1270                     if (!isEliminatedAllocation(node-&gt;child1().node()))
1271                         break;
1272                     node-&gt;remove(m_graph);
1273                     break;
1274                 }
1275 
1276                 case CheckStructureOrEmpty:
1277                 case CheckStructure:
1278                     if (!isEliminatedAllocation(node-&gt;child1().node()))
1279                         break;
1280                     node-&gt;child1() = Edge(); // Remove the cell check since we&#39;ve proven it&#39;s not needed and FTL lowering might botch this.
1281                     node-&gt;remove(m_graph);
1282                     break;
1283 
1284                 default:
1285                     break;
1286                 }
1287 
1288                 if (node-&gt;isPseudoTerminal()) {
1289                     pseudoTerminal = node;
1290                     break;
1291                 }
1292             }
1293 
1294             insertionSet.execute(block);
1295 
1296             if (pseudoTerminal) {
1297                 for (unsigned i = 0; i &lt; block-&gt;size(); ++i) {
1298                     Node* node = block-&gt;at(i);
1299                     if (node != pseudoTerminal)
1300                         continue;
1301                     block-&gt;resize(i + 1);
1302                     block-&gt;append(m_graph.addNode(SpecNone, Unreachable, node-&gt;origin));
1303                     modifiedCFG = true;
1304                     break;
1305                 }
1306             }
1307         }
1308 
1309         if (modifiedCFG) {
1310             m_graph.invalidateCFG();
1311             m_graph.resetReachability();
1312             m_graph.killUnreachableBlocks();
1313         }
1314     }
1315 
1316     HashSet&lt;Node*&gt; m_candidates;
1317 };
1318 
1319 } // anonymous namespace
1320 
1321 bool performArgumentsElimination(Graph&amp; graph)
1322 {
1323     return runPhase&lt;ArgumentsEliminationPhase&gt;(graph);
1324 }
1325 
1326 } } // namespace JSC::DFG
1327 
1328 #endif // ENABLE(DFG_JIT)
1329 
<a name="32" id="anc32"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="32" type="hidden" />
</body>
</html>
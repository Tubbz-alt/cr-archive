<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/line/LineLayoutTraversal.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;InlineElementBox.h&quot;
 29 #include &quot;LineLayoutTraversalComplexPath.h&quot;
 30 #include &quot;LineLayoutTraversalDisplayRunPath.h&quot;
 31 #include &quot;LineLayoutTraversalSimplePath.h&quot;
 32 #include &quot;RenderText.h&quot;
 33 #include &lt;wtf/HashMap.h&gt;
 34 #include &lt;wtf/IteratorRange.h&gt;
 35 #include &lt;wtf/Variant.h&gt;
 36 #include &lt;wtf/text/StringView.h&gt;
 37 
 38 namespace WebCore {
 39 
 40 class RenderLineBreak;
 41 
 42 namespace LineLayoutTraversal {
 43 
 44 class ElementBoxIterator;
 45 class TextBoxIterator;
 46 
 47 struct EndIterator { };
 48 
 49 class Box {
 50 public:
 51     using PathVariant = Variant&lt;
 52 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 53         DisplayRunPath,
 54 #endif
 55         ComplexPath,
 56         SimplePath
 57     &gt;;
 58 
 59     Box(PathVariant&amp;&amp;);
 60 
 61     FloatRect rect() const;
 62 
 63     float baselineOffset() const;
 64 
 65     bool isLeftToRightDirection() const;
 66     bool isHorizontal() const;
 67     bool dirOverride() const;
 68     bool isLineBreak() const;
 69     bool useLineBreakBoxRenderTreeDumpQuirk() const;
 70 
 71 protected:
 72     friend class ElementBoxIterator;
 73     friend class TextBoxIterator;
 74 
 75     PathVariant m_pathVariant;
 76 };
 77 
 78 class TextBox : public Box {
 79 public:
 80     TextBox(PathVariant&amp;&amp;);
 81 
 82     bool hasHyphen() const;
 83     StringView text() const;
 84 
 85     // These offsets are relative to the text renderer (not flow).
 86     unsigned localStartOffset() const;
 87     unsigned localEndOffset() const;
 88     unsigned length() const;
 89 
 90     bool isLastOnLine() const;
 91     bool isLast() const;
 92 };
 93 
 94 class TextBoxIterator {
 95 public:
 96     TextBoxIterator() : m_textBox(ComplexPath { nullptr, { } }) { };
 97     TextBoxIterator(Box::PathVariant&amp;&amp;);
 98 
 99     TextBoxIterator&amp; operator++() { return traverseNextInVisualOrder(); }
100     TextBoxIterator&amp; traverseNextInVisualOrder();
101     TextBoxIterator&amp; traverseNextInTextOrder();
102 
103     explicit operator bool() const { return !atEnd(); }
104 
105     bool operator==(const TextBoxIterator&amp;) const;
106     bool operator!=(const TextBoxIterator&amp; other) const { return !(*this == other); }
107 
108     bool operator==(EndIterator) const { return atEnd(); }
109     bool operator!=(EndIterator) const { return !atEnd(); }
110 
111     const TextBox&amp; operator*() const { return m_textBox; }
112     const TextBox* operator-&gt;() const { return &amp;m_textBox; }
113 
114     bool atEnd() const;
115 
116 private:
117     TextBox m_textBox;
118 };
119 
120 class ElementBoxIterator {
121 public:
122     ElementBoxIterator() : m_box(ComplexPath { nullptr, { } }) { };
123     ElementBoxIterator(Box::PathVariant&amp;&amp;);
124 
125     explicit operator bool() const { return !atEnd(); }
126 
127     const Box&amp; operator*() const { return m_box; }
128     const Box* operator-&gt;() const { return &amp;m_box; }
129 
130     bool atEnd() const;
131 
132 private:
133     Box m_box;
134 };
135 
136 class TextBoxRange {
137 public:
138     TextBoxRange(TextBoxIterator begin)
139         : m_begin(begin)
140     {
141     }
142 
143     TextBoxIterator begin() const { return m_begin; }
144     EndIterator end() const { return { }; }
145 
146 private:
147     TextBoxIterator m_begin;
148 };
149 
150 TextBoxIterator firstTextBoxFor(const RenderText&amp;);
151 TextBoxIterator firstTextBoxInTextOrderFor(const RenderText&amp;);
152 TextBoxRange textBoxesFor(const RenderText&amp;);
153 ElementBoxIterator elementBoxFor(const RenderLineBreak&amp;);
154 
155 // -----------------------------------------------
156 
157 inline Box::Box(PathVariant&amp;&amp; path)
158     : m_pathVariant(WTFMove(path))
159 {
160 }
161 
162 inline FloatRect Box::rect() const
163 {
164     return WTF::switchOn(m_pathVariant, [](auto&amp; path) {
165         return path.rect();
166     });
167 }
168 
169 inline float Box::baselineOffset() const
170 {
171     return WTF::switchOn(m_pathVariant, [](auto&amp; path) {
172         return path.baselineOffset();
173     });
174 }
175 
176 inline bool Box::isLeftToRightDirection() const
177 {
178     return WTF::switchOn(m_pathVariant, [](auto&amp; path) {
179         return path.isLeftToRightDirection();
180     });
181 }
182 
183 inline bool Box::isHorizontal() const
184 {
185     return WTF::switchOn(m_pathVariant, [](auto&amp; path) {
186         return path.isHorizontal();
187     });
188 }
189 
190 inline bool Box::dirOverride() const
191 {
192     return WTF::switchOn(m_pathVariant, [](auto&amp; path) {
193         return path.dirOverride();
194     });
195 }
196 
197 inline bool Box::isLineBreak() const
198 {
199     return WTF::switchOn(m_pathVariant, [](auto&amp; path) {
200         return path.isLineBreak();
201     });
202 }
203 
204 inline bool Box::useLineBreakBoxRenderTreeDumpQuirk() const
205 {
206     return WTF::switchOn(m_pathVariant, [](auto&amp; path) {
207         return path.useLineBreakBoxRenderTreeDumpQuirk();
208     });
209 }
210 
211 inline bool TextBox::hasHyphen() const
212 {
213     return WTF::switchOn(m_pathVariant, [](auto&amp; path) {
214         return path.hasHyphen();
215     });
216 }
217 
218 inline TextBox::TextBox(PathVariant&amp;&amp; path)
219     : Box(WTFMove(path))
220 {
221 }
222 
223 inline StringView TextBox::text() const
224 {
225     return WTF::switchOn(m_pathVariant, [](auto&amp; path) {
226         return path.text();
227     });
228 }
229 
230 inline unsigned TextBox::localStartOffset() const
231 {
232     return WTF::switchOn(m_pathVariant, [](auto&amp; path) {
233         return path.localStartOffset();
234     });
235 }
236 
237 inline unsigned TextBox::localEndOffset() const
238 {
239     return WTF::switchOn(m_pathVariant, [](auto&amp; path) {
240         return path.localEndOffset();
241     });
242 }
243 
244 inline unsigned TextBox::length() const
245 {
246     return WTF::switchOn(m_pathVariant, [](auto&amp; path) {
247         return path.length();
248     });
249 }
250 
251 inline bool TextBox::isLastOnLine() const
252 {
253     return WTF::switchOn(m_pathVariant, [](auto&amp; path) {
254         return path.isLastOnLine();
255     });
256 }
257 
258 inline bool TextBox::isLast() const
259 {
260     return WTF::switchOn(m_pathVariant, [](auto&amp; path) {
261         return path.isLast();
262     });
263 }
264 
265 
266 }
267 }
    </pre>
  </body>
</html>
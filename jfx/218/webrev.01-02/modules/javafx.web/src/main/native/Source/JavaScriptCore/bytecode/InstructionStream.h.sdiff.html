<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/InstructionStream.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InstructionStream.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InternalFunctionAllocationProfile.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/InstructionStream.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 
 27 #pragma once
 28 

 29 #include &quot;Instruction.h&quot;
 30 #include &lt;wtf/Vector.h&gt;
 31 
 32 namespace JSC {
 33 
<span class="line-modified"> 34 struct Instruction;</span>
 35 
 36 class InstructionStream {
 37     WTF_MAKE_FAST_ALLOCATED;
 38 
<span class="line-modified"> 39     using InstructionBuffer = Vector&lt;uint8_t, 0, UnsafeVectorOverflow&gt;;</span>
 40 
 41     friend class InstructionStreamWriter;
 42     friend class CachedInstructionStream;
 43 public:
 44     size_t sizeInBytes() const;
 45 
 46     using Offset = unsigned;
 47 
 48 private:
 49     template&lt;class InstructionBuffer&gt;
 50     class BaseRef {
 51         WTF_MAKE_FAST_ALLOCATED;
 52 
 53         friend class InstructionStream;
 54 
 55     public:
 56         BaseRef(const BaseRef&lt;InstructionBuffer&gt;&amp; other)
 57             : m_instructions(other.m_instructions)
 58             ,  m_index(other.m_index)
 59         { }
 60 
 61         void operator=(const BaseRef&lt;InstructionBuffer&gt;&amp; other)
 62         {
 63             m_instructions = other.m_instructions;
 64             m_index = other.m_index;
 65         }
 66 
 67         inline const Instruction* operator-&gt;() const { return unwrap(); }
 68         inline const Instruction* ptr() const { return unwrap(); }
 69 
 70         bool operator!=(const BaseRef&lt;InstructionBuffer&gt;&amp; other) const
 71         {
 72             return &amp;m_instructions != &amp;other.m_instructions || m_index != other.m_index;
 73         }
 74 
 75         BaseRef next() const
 76         {
 77             return BaseRef { m_instructions, m_index + ptr()-&gt;size() };
 78         }
 79 
<span class="line-modified"> 80         inline Offset offset() const</span>
<span class="line-modified"> 81         {</span>
<span class="line-removed"> 82             return m_index;</span>
<span class="line-removed"> 83         }</span>
 84 
 85         bool isValid() const
 86         {
 87             return m_index &lt; m_instructions.size();
 88         }
 89 
 90     private:
 91         inline const Instruction* unwrap() const { return reinterpret_cast&lt;const Instruction*&gt;(&amp;m_instructions[m_index]); }
 92 
 93     protected:
 94         BaseRef(InstructionBuffer&amp; instructions, size_t index)
 95             : m_instructions(instructions)
 96             , m_index(index)
 97         { }
 98 
 99         InstructionBuffer&amp; m_instructions;
100         Offset m_index;
101     };
102 
103 public:
104     using Ref = BaseRef&lt;const InstructionBuffer&gt;;
105 
106     class MutableRef : public BaseRef&lt;InstructionBuffer&gt; {
107         friend class InstructionStreamWriter;
108 
109     protected:
110         using BaseRef&lt;InstructionBuffer&gt;::BaseRef;
111 
112     public:
113         Ref freeze() const  { return Ref { m_instructions, m_index }; }
114         inline Instruction* operator-&gt;() { return unwrap(); }

115         inline Instruction* ptr() { return unwrap(); }

116         inline operator Ref()
117         {
118             return Ref { m_instructions, m_index };
119         }
120 
121     private:
122         inline Instruction* unwrap() { return reinterpret_cast&lt;Instruction*&gt;(&amp;m_instructions[m_index]); }

123     };
124 
125 private:
126     class iterator : public Ref {
127         friend class InstructionStream;
128 
129     public:
130         using Ref::Ref;
131 
132         Ref&amp; operator*()
133         {
134             return *this;
135         }
136 
<span class="line-modified">137         iterator operator++()</span>
138         {
<span class="line-modified">139             m_index += ptr()-&gt;size();</span>
140             return *this;
141         }





142     };
143 
144 public:
145     inline iterator begin() const
146     {
147         return iterator { m_instructions, 0 };
148     }
149 
150     inline iterator end() const
151     {
152         return iterator { m_instructions, m_instructions.size() };
153     }
154 

155     inline const Ref at(Offset offset) const
156     {
157         ASSERT(offset &lt; m_instructions.size());
158         return Ref { m_instructions, offset };
159     }
160 
161     inline size_t size() const
162     {
163         return m_instructions.size();
164     }
165 
166     const void* rawPointer() const
167     {
168         return m_instructions.data();
169     }
170 
171     bool contains(Instruction *) const;
172 
173 protected:
174     explicit InstructionStream(InstructionBuffer&amp;&amp;);
</pre>
<hr />
<pre>
261     void swap(InstructionStreamWriter&amp; other)
262     {
263         std::swap(m_finalized, other.m_finalized);
264         std::swap(m_position, other.m_position);
265         m_instructions.swap(other.m_instructions);
266     }
267 
268 private:
269     class iterator : public MutableRef {
270         friend class InstructionStreamWriter;
271 
272     protected:
273         using MutableRef::MutableRef;
274 
275     public:
276         MutableRef&amp; operator*()
277         {
278             return *this;
279         }
280 
<span class="line-modified">281         iterator operator++()</span>
282         {
<span class="line-modified">283             m_index += ptr()-&gt;size();</span>
284             return *this;
285         }





286     };
287 
288 public:
289     iterator begin()
290     {
291         return iterator { m_instructions, 0 };
292     }
293 
294     iterator end()
295     {
296         return iterator { m_instructions, m_instructions.size() };
297     }
298 
299 private:
300     unsigned m_position { 0 };
301     bool m_finalized { false };
302 };
303 
304 
305 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 
 27 #pragma once
 28 
<span class="line-added"> 29 #include &quot;BytecodeIndex.h&quot;</span>
 30 #include &quot;Instruction.h&quot;
 31 #include &lt;wtf/Vector.h&gt;
 32 
 33 namespace JSC {
 34 
<span class="line-modified"> 35 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(InstructionStream);</span>
 36 
 37 class InstructionStream {
 38     WTF_MAKE_FAST_ALLOCATED;
 39 
<span class="line-modified"> 40     using InstructionBuffer = Vector&lt;uint8_t, 0, UnsafeVectorOverflow, 16, InstructionStreamMalloc&gt;;</span>
 41 
 42     friend class InstructionStreamWriter;
 43     friend class CachedInstructionStream;
 44 public:
 45     size_t sizeInBytes() const;
 46 
 47     using Offset = unsigned;
 48 
 49 private:
 50     template&lt;class InstructionBuffer&gt;
 51     class BaseRef {
 52         WTF_MAKE_FAST_ALLOCATED;
 53 
 54         friend class InstructionStream;
 55 
 56     public:
 57         BaseRef(const BaseRef&lt;InstructionBuffer&gt;&amp; other)
 58             : m_instructions(other.m_instructions)
 59             ,  m_index(other.m_index)
 60         { }
 61 
 62         void operator=(const BaseRef&lt;InstructionBuffer&gt;&amp; other)
 63         {
 64             m_instructions = other.m_instructions;
 65             m_index = other.m_index;
 66         }
 67 
 68         inline const Instruction* operator-&gt;() const { return unwrap(); }
 69         inline const Instruction* ptr() const { return unwrap(); }
 70 
 71         bool operator!=(const BaseRef&lt;InstructionBuffer&gt;&amp; other) const
 72         {
 73             return &amp;m_instructions != &amp;other.m_instructions || m_index != other.m_index;
 74         }
 75 
 76         BaseRef next() const
 77         {
 78             return BaseRef { m_instructions, m_index + ptr()-&gt;size() };
 79         }
 80 
<span class="line-modified"> 81         inline Offset offset() const { return m_index; }</span>
<span class="line-modified"> 82         inline BytecodeIndex index() const { return BytecodeIndex(offset()); }</span>


 83 
 84         bool isValid() const
 85         {
 86             return m_index &lt; m_instructions.size();
 87         }
 88 
 89     private:
 90         inline const Instruction* unwrap() const { return reinterpret_cast&lt;const Instruction*&gt;(&amp;m_instructions[m_index]); }
 91 
 92     protected:
 93         BaseRef(InstructionBuffer&amp; instructions, size_t index)
 94             : m_instructions(instructions)
 95             , m_index(index)
 96         { }
 97 
 98         InstructionBuffer&amp; m_instructions;
 99         Offset m_index;
100     };
101 
102 public:
103     using Ref = BaseRef&lt;const InstructionBuffer&gt;;
104 
105     class MutableRef : public BaseRef&lt;InstructionBuffer&gt; {
106         friend class InstructionStreamWriter;
107 
108     protected:
109         using BaseRef&lt;InstructionBuffer&gt;::BaseRef;
110 
111     public:
112         Ref freeze() const  { return Ref { m_instructions, m_index }; }
113         inline Instruction* operator-&gt;() { return unwrap(); }
<span class="line-added">114         inline const Instruction* operator-&gt;() const { return unwrap(); }</span>
115         inline Instruction* ptr() { return unwrap(); }
<span class="line-added">116         inline const Instruction* ptr() const { return unwrap(); }</span>
117         inline operator Ref()
118         {
119             return Ref { m_instructions, m_index };
120         }
121 
122     private:
123         inline Instruction* unwrap() { return reinterpret_cast&lt;Instruction*&gt;(&amp;m_instructions[m_index]); }
<span class="line-added">124         inline const Instruction* unwrap() const { return reinterpret_cast&lt;const Instruction*&gt;(&amp;m_instructions[m_index]); }</span>
125     };
126 
127 private:
128     class iterator : public Ref {
129         friend class InstructionStream;
130 
131     public:
132         using Ref::Ref;
133 
134         Ref&amp; operator*()
135         {
136             return *this;
137         }
138 
<span class="line-modified">139         iterator&amp; operator+=(size_t size)</span>
140         {
<span class="line-modified">141             m_index += size;</span>
142             return *this;
143         }
<span class="line-added">144 </span>
<span class="line-added">145         iterator&amp; operator++()</span>
<span class="line-added">146         {</span>
<span class="line-added">147             return *this += ptr()-&gt;size();</span>
<span class="line-added">148         }</span>
149     };
150 
151 public:
152     inline iterator begin() const
153     {
154         return iterator { m_instructions, 0 };
155     }
156 
157     inline iterator end() const
158     {
159         return iterator { m_instructions, m_instructions.size() };
160     }
161 
<span class="line-added">162     inline const Ref at(BytecodeIndex index) const { return at(index.offset()); }</span>
163     inline const Ref at(Offset offset) const
164     {
165         ASSERT(offset &lt; m_instructions.size());
166         return Ref { m_instructions, offset };
167     }
168 
169     inline size_t size() const
170     {
171         return m_instructions.size();
172     }
173 
174     const void* rawPointer() const
175     {
176         return m_instructions.data();
177     }
178 
179     bool contains(Instruction *) const;
180 
181 protected:
182     explicit InstructionStream(InstructionBuffer&amp;&amp;);
</pre>
<hr />
<pre>
269     void swap(InstructionStreamWriter&amp; other)
270     {
271         std::swap(m_finalized, other.m_finalized);
272         std::swap(m_position, other.m_position);
273         m_instructions.swap(other.m_instructions);
274     }
275 
276 private:
277     class iterator : public MutableRef {
278         friend class InstructionStreamWriter;
279 
280     protected:
281         using MutableRef::MutableRef;
282 
283     public:
284         MutableRef&amp; operator*()
285         {
286             return *this;
287         }
288 
<span class="line-modified">289         iterator&amp; operator+=(size_t size)</span>
290         {
<span class="line-modified">291             m_index += size;</span>
292             return *this;
293         }
<span class="line-added">294 </span>
<span class="line-added">295         iterator&amp; operator++()</span>
<span class="line-added">296         {</span>
<span class="line-added">297             return *this += ptr()-&gt;size();</span>
<span class="line-added">298         }</span>
299     };
300 
301 public:
302     iterator begin()
303     {
304         return iterator { m_instructions, 0 };
305     }
306 
307     iterator end()
308     {
309         return iterator { m_instructions, m_instructions.size() };
310     }
311 
312 private:
313     unsigned m_position { 0 };
314     bool m_finalized { false };
315 };
316 
317 
318 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="InstructionStream.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InternalFunctionAllocationProfile.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
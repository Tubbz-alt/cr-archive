<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/Element.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Element.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Element.idl.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Element.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  *
 23  */
 24 
 25 #pragma once
 26 
 27 #include &quot;AXTextStateChangeIntent.h&quot;
 28 #include &quot;Document.h&quot;
 29 #include &quot;ElementData.h&quot;
 30 #include &quot;HTMLNames.h&quot;
<span class="line-removed"> 31 #include &quot;KeyframeAnimationOptions.h&quot;</span>
<span class="line-removed"> 32 #include &quot;ScrollToOptions.h&quot;</span>
 33 #include &quot;ScrollTypes.h&quot;
 34 #include &quot;ShadowRootMode.h&quot;
 35 #include &quot;SimulatedClickOptions.h&quot;
 36 #include &quot;StyleChange.h&quot;

 37 
 38 namespace WebCore {
 39 
 40 class CustomElementReactionQueue;
 41 class DatasetDOMStringMap;
 42 class DOMRect;
 43 class DOMRectList;
 44 class DOMTokenList;
 45 class ElementRareData;
 46 class Frame;
 47 class HTMLDocument;
 48 class IntSize;
 49 class JSCustomElementInterface;

 50 class KeyboardEvent;
 51 class Locale;
 52 class PlatformKeyboardEvent;
 53 class PlatformMouseEvent;
 54 class PlatformWheelEvent;
 55 class PseudoElement;
 56 class RenderTreePosition;
 57 class StylePropertyMap;
 58 class WebAnimation;
<span class="line-modified"> 59 struct ElementStyle;</span>


 60 struct ScrollIntoViewOptions;

 61 
 62 #if ENABLE(INTERSECTION_OBSERVER)
 63 struct IntersectionObserverData;
 64 #endif
 65 
 66 #if ENABLE(RESIZE_OBSERVER)
 67 struct ResizeObserverData;
 68 #endif
 69 
<span class="line-modified"> 70 enum SpellcheckAttributeState {</span>
<span class="line-modified"> 71     SpellcheckAttributeTrue,</span>
<span class="line-modified"> 72     SpellcheckAttributeFalse,</span>
<span class="line-modified"> 73     SpellcheckAttributeDefault</span>
<span class="line-modified"> 74 };</span>
 75 
 76 class Element : public ContainerNode {
 77     WTF_MAKE_ISO_ALLOCATED(Element);
 78 public:
 79     static Ref&lt;Element&gt; create(const QualifiedName&amp;, Document&amp;);
 80     virtual ~Element();
 81 
 82     WEBCORE_EXPORT bool hasAttribute(const QualifiedName&amp;) const;
 83     WEBCORE_EXPORT const AtomString&amp; getAttribute(const QualifiedName&amp;) const;
 84     template&lt;typename... QualifiedNames&gt;
 85     const AtomString&amp; getAttribute(const QualifiedName&amp;, const QualifiedNames&amp;...) const;
 86     WEBCORE_EXPORT void setAttribute(const QualifiedName&amp;, const AtomString&amp; value);
 87     WEBCORE_EXPORT void setAttributeWithoutSynchronization(const QualifiedName&amp;, const AtomString&amp; value);
 88     void setSynchronizedLazyAttribute(const QualifiedName&amp;, const AtomString&amp; value);
 89     bool removeAttribute(const QualifiedName&amp;);
 90     Vector&lt;String&gt; getAttributeNames() const;
 91 
 92     // Typed getters and setters for language bindings.
 93     WEBCORE_EXPORT int getIntegralAttribute(const QualifiedName&amp; attributeName) const;
 94     WEBCORE_EXPORT void setIntegralAttribute(const QualifiedName&amp; attributeName, int value);
 95     WEBCORE_EXPORT unsigned getUnsignedIntegralAttribute(const QualifiedName&amp; attributeName) const;
 96     WEBCORE_EXPORT void setUnsignedIntegralAttribute(const QualifiedName&amp; attributeName, unsigned value);
 97 
 98     // Call this to get the value of an attribute that is known not to be the style
 99     // attribute or one of the SVG animatable attributes.
100     bool hasAttributeWithoutSynchronization(const QualifiedName&amp;) const;
101     const AtomString&amp; attributeWithoutSynchronization(const QualifiedName&amp;) const;
<span class="line-removed">102 #ifndef NDEBUG</span>
<span class="line-removed">103     WEBCORE_EXPORT bool fastAttributeLookupAllowed(const QualifiedName&amp;) const;</span>
<span class="line-removed">104 #endif</span>
105 
106 #if DUMP_NODE_STATISTICS
107     bool hasNamedNodeMap() const;
108 #endif

109     WEBCORE_EXPORT bool hasAttributes() const;

110     // This variant will not update the potentially invalid attributes. To be used when not interested
111     // in style attribute or one of the SVG animation attributes.
112     bool hasAttributesWithoutUpdate() const;
113 
114     WEBCORE_EXPORT bool hasAttribute(const AtomString&amp; qualifiedName) const;
115     WEBCORE_EXPORT bool hasAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName) const;
116 
117     WEBCORE_EXPORT const AtomString&amp; getAttribute(const AtomString&amp; qualifiedName) const;
118     WEBCORE_EXPORT const AtomString&amp; getAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName) const;
119 
120     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setAttribute(const AtomString&amp; qualifiedName, const AtomString&amp; value);
121     static ExceptionOr&lt;QualifiedName&gt; parseAttributeName(const AtomString&amp; namespaceURI, const AtomString&amp; qualifiedName);
122     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; qualifiedName, const AtomString&amp; value);
123 
124     ExceptionOr&lt;bool&gt; toggleAttribute(const AtomString&amp; qualifiedName, Optional&lt;bool&gt; force);
125 
126     const AtomString&amp; getIdAttribute() const;
127     void setIdAttribute(const AtomString&amp;);
128 
129     const AtomString&amp; getNameAttribute() const;
</pre>
<hr />
<pre>
177     WEBCORE_EXPORT double clientHeight();
178 
179     virtual int scrollLeft();
180     virtual int scrollTop();
181     virtual void setScrollLeft(int);
182     virtual void setScrollTop(int);
183     virtual int scrollWidth();
184     virtual int scrollHeight();
185 
186     WEBCORE_EXPORT IntRect boundsInRootViewSpace();
187 
188     Optional&lt;std::pair&lt;RenderObject*, FloatRect&gt;&gt; boundingAbsoluteRectWithoutLayout();
189 
190     WEBCORE_EXPORT FloatRect boundingClientRect();
191 
192     WEBCORE_EXPORT Ref&lt;DOMRectList&gt; getClientRects();
193     Ref&lt;DOMRect&gt; getBoundingClientRect();
194 
195     // Returns the absolute bounding box translated into client coordinates.
196     WEBCORE_EXPORT IntRect clientRect() const;

197     // Returns the absolute bounding box translated into screen coordinates.
198     WEBCORE_EXPORT IntRect screenRect() const;
199 
200     WEBCORE_EXPORT bool removeAttribute(const AtomString&amp; qualifiedName);
201     WEBCORE_EXPORT bool removeAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName);
202 
203     Ref&lt;Attr&gt; detachAttribute(unsigned index);
204 
205     WEBCORE_EXPORT RefPtr&lt;Attr&gt; getAttributeNode(const AtomString&amp; qualifiedName);
206     WEBCORE_EXPORT RefPtr&lt;Attr&gt; getAttributeNodeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName);
207     WEBCORE_EXPORT ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; setAttributeNode(Attr&amp;);
208     WEBCORE_EXPORT ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; setAttributeNodeNS(Attr&amp;);
209     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Attr&gt;&gt; removeAttributeNode(Attr&amp;);
210 
211     RefPtr&lt;Attr&gt; attrIfExists(const QualifiedName&amp;);
212     RefPtr&lt;Attr&gt; attrIfExists(const AtomString&amp; localName, bool shouldIgnoreAttributeCase);
213     Ref&lt;Attr&gt; ensureAttr(const QualifiedName&amp;);
214 
215     const Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; attrNodeList();
216 
217     const QualifiedName&amp; tagQName() const { return m_tagName; }
218 #if ENABLE(JIT)
219     static ptrdiff_t tagQNameMemoryOffset() { return OBJECT_OFFSETOF(Element, m_tagName); }
<span class="line-modified">220 #endif // ENABLE(JIT)</span>
221     String tagName() const { return nodeName(); }
222     bool hasTagName(const QualifiedName&amp; tagName) const { return m_tagName.matches(tagName); }
223     bool hasTagName(const HTMLQualifiedName&amp; tagName) const { return ContainerNode::hasTagName(tagName); }
224     bool hasTagName(const MathMLQualifiedName&amp; tagName) const { return ContainerNode::hasTagName(tagName); }
225     bool hasTagName(const SVGQualifiedName&amp; tagName) const { return ContainerNode::hasTagName(tagName); }
226 
<span class="line-removed">227     // A fast function for checking the local name against another atomic string.</span>
228     bool hasLocalName(const AtomString&amp; other) const { return m_tagName.localName() == other; }
229 
230     const AtomString&amp; localName() const final { return m_tagName.localName(); }
231     const AtomString&amp; prefix() const final { return m_tagName.prefix(); }
232     const AtomString&amp; namespaceURI() const final { return m_tagName.namespaceURI(); }
233 
234     ExceptionOr&lt;void&gt; setPrefix(const AtomString&amp;) final;
235 
236     String nodeName() const override;
237 
238     Ref&lt;Element&gt; cloneElementWithChildren(Document&amp;);
239     Ref&lt;Element&gt; cloneElementWithoutChildren(Document&amp;);
240 
241     void normalizeAttributes();
242     String nodeNamePreservingCase() const;
243 
244     WEBCORE_EXPORT void setBooleanAttribute(const QualifiedName&amp; name, bool);
245 
246     // For exposing to DOM only.
247     WEBCORE_EXPORT NamedNodeMap&amp; attributes() const;
248 
249     enum AttributeModificationReason {
250         ModifiedDirectly,
251         ModifiedByCloning
252     };
253 
<span class="line-modified">254     // This method is called whenever an attribute is added, changed or removed.</span>
255     virtual void attributeChanged(const QualifiedName&amp;, const AtomString&amp; oldValue, const AtomString&amp; newValue, AttributeModificationReason = ModifiedDirectly);
256     virtual void parseAttribute(const QualifiedName&amp;, const AtomString&amp;) { }
257 
258     // Only called by the parser immediately after element construction.
259     void parserSetAttributes(const Vector&lt;Attribute&gt;&amp;);
260 
261     bool isEventHandlerAttribute(const Attribute&amp;) const;
262     bool isJavaScriptURLAttribute(const Attribute&amp;) const;
263 
264     // Remove attributes that might introduce scripting from the vector leaving the element unchanged.
265     void stripScriptingAttributes(Vector&lt;Attribute&gt;&amp;) const;
266 
267     const ElementData* elementData() const { return m_elementData.get(); }
268     static ptrdiff_t elementDataMemoryOffset() { return OBJECT_OFFSETOF(Element, m_elementData); }
269     UniqueElementData&amp; ensureUniqueElementData();
270 
271     void synchronizeAllAttributes() const;
272 
273     // Clones attributes only.
274     void cloneAttributesFromElement(const Element&amp;);
275 
276     // Clones all attribute-derived data, including subclass specifics (through copyNonAttributeProperties.)
277     void cloneDataFromElement(const Element&amp;);
278 
279     virtual void didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument);
280 
281     bool hasEquivalentAttributes(const Element&amp; other) const;
282 
283     virtual void copyNonAttributePropertiesFromElement(const Element&amp;) { }
284 
285     virtual RenderPtr&lt;RenderElement&gt; createElementRenderer(RenderStyle&amp;&amp;, const RenderTreePosition&amp;);
286     virtual bool rendererIsNeeded(const RenderStyle&amp;);

287 
288     WEBCORE_EXPORT ShadowRoot* shadowRoot() const;
<span class="line-modified">289     ShadowRoot* shadowRootForBindings(JSC::ExecState&amp;) const;</span>
290 
291     struct ShadowRootInit {
292         ShadowRootMode mode;

293     };
294     ExceptionOr&lt;ShadowRoot&amp;&gt; attachShadow(const ShadowRootInit&amp;);
295 
296     RefPtr&lt;ShadowRoot&gt; userAgentShadowRoot() const;
297     WEBCORE_EXPORT ShadowRoot&amp; ensureUserAgentShadowRoot();
298 
299     void setIsDefinedCustomElement(JSCustomElementInterface&amp;);
300     void setIsFailedCustomElement(JSCustomElementInterface&amp;);
301     void setIsCustomElementUpgradeCandidate();
302     void enqueueToUpgrade(JSCustomElementInterface&amp;);
303     CustomElementReactionQueue* reactionQueue() const;
304 
<span class="line-modified">305     // FIXME: this should not be virtual, do not override this.</span>
306     virtual const AtomString&amp; shadowPseudoId() const;
307 
308     bool isInActiveChain() const { return isUserActionElement() &amp;&amp; isUserActionElementInActiveChain(); }
309     bool active() const { return isUserActionElement() &amp;&amp; isUserActionElementActive(); }
310     bool hovered() const { return isUserActionElement() &amp;&amp; isUserActionElementHovered(); }
311     bool focused() const { return isUserActionElement() &amp;&amp; isUserActionElementFocused(); }
312     bool hasFocusWithin() const { return getFlag(HasFocusWithin); };
313 
314     virtual void setActive(bool flag = true, bool pause = false);
315     virtual void setHovered(bool flag = true);
316     virtual void setFocus(bool flag);
317     void setHasFocusWithin(bool flag);
318 
319     Optional&lt;int&gt; tabIndexSetExplicitly() const;
320     bool shouldBeIgnoredInSequentialFocusNavigation() const { return defaultTabIndex() &lt; 0 &amp;&amp; !supportsFocus(); }
321     virtual bool supportsFocus() const;
322     virtual bool isFocusable() const;
323     virtual bool isKeyboardFocusable(KeyboardEvent*) const;
324     virtual bool isMouseFocusable() const;
325 
</pre>
<hr />
<pre>
399 
400     WEBCORE_EXPORT String innerHTML() const;
401     WEBCORE_EXPORT String outerHTML() const;
402     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setInnerHTML(const String&amp;);
403     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setOuterHTML(const String&amp;);
404     WEBCORE_EXPORT String innerText();
405     WEBCORE_EXPORT String outerText();
406 
407     virtual String title() const;
408 
409     const AtomString&amp; pseudo() const;
410     WEBCORE_EXPORT void setPseudo(const AtomString&amp;);
411 
412     LayoutSize minimumSizeForResizing() const;
413     void setMinimumSizeForResizing(const LayoutSize&amp;);
414 
415     // Use Document::registerForDocumentActivationCallbacks() to subscribe to these
416     virtual void prepareForDocumentSuspension() { }
417     virtual void resumeFromDocumentSuspension() { }
418 
<span class="line-removed">419     // Use Document::registerForMediaVolumeCallbacks() to subscribe to this</span>
<span class="line-removed">420     virtual void mediaVolumeDidChange() { }</span>
<span class="line-removed">421 </span>
<span class="line-removed">422     // Use Document::registerForPrivateBrowsingStateChangedCallbacks() to subscribe to this.</span>
<span class="line-removed">423     virtual void privateBrowsingStateDidChange(PAL::SessionID) { }</span>
<span class="line-removed">424 </span>
425     virtual void willBecomeFullscreenElement();
426     virtual void ancestorWillEnterFullscreen() { }
427     virtual void didBecomeFullscreenElement() { }
428     virtual void willStopBeingFullscreenElement() { }
429 
<span class="line-removed">430 #if ENABLE(VIDEO_TRACK)</span>
<span class="line-removed">431     virtual void captionPreferencesChanged() { }</span>
<span class="line-removed">432 #endif</span>
<span class="line-removed">433 </span>
434     bool isFinishedParsingChildren() const { return isParsingChildrenFinished(); }
435     void finishParsingChildren() override;
436     void beginParsingChildren() final;
437 
438     WEBCORE_EXPORT PseudoElement* beforePseudoElement() const;
439     WEBCORE_EXPORT PseudoElement* afterPseudoElement() const;
440     bool childNeedsShadowWalker() const;
441     void didShadowTreeAwareChildrenChange();
442 
443     virtual bool matchesValidPseudoClass() const;
444     virtual bool matchesInvalidPseudoClass() const;
445     virtual bool matchesReadWritePseudoClass() const;
446     virtual bool matchesIndeterminatePseudoClass() const;
447     virtual bool matchesDefaultPseudoClass() const;
448     WEBCORE_EXPORT ExceptionOr&lt;bool&gt; matches(const String&amp; selectors);
449     WEBCORE_EXPORT ExceptionOr&lt;Element*&gt; closest(const String&amp; selectors);
450     virtual bool shouldAppearIndeterminate() const;
451 
452     WEBCORE_EXPORT DOMTokenList&amp; classList();
453 



454     DatasetDOMStringMap&amp; dataset();
455 
456 #if ENABLE(VIDEO)
457     virtual bool isMediaElement() const { return false; }
458 #endif
459 
460     virtual bool isFormControlElement() const { return false; }
461     virtual bool isSpinButtonElement() const { return false; }
462     virtual bool isTextFormControlElement() const { return false; }
463     virtual bool isTextField() const { return false; }
464     virtual bool isOptionalFormControl() const { return false; }
465     virtual bool isRequiredFormControl() const { return false; }
466     virtual bool isInRange() const { return false; }
467     virtual bool isOutOfRange() const { return false; }
468     virtual bool isUploadButton() const { return false; }
469     virtual bool isSliderContainerElement() const { return false; }
470 
471     bool canContainRangeEndPoint() const override;
472 
473     // Used for disabled form elements; if true, prevents mouse events from being dispatched
474     // to event listeners, and prevents DOMActivate events from being sent at all.
475     virtual bool isDisabledFormControl() const { return false; }
476 
477     virtual bool childShouldCreateRenderer(const Node&amp;) const;
478 
479     bool hasPendingResources() const;
480     void setHasPendingResources();
481     void clearHasPendingResources();
482     virtual void buildPendingResource() { };
483 
484     bool hasCSSAnimation() const;
485     void setHasCSSAnimation();
486     void clearHasCSSAnimation();
487 





488 #if ENABLE(FULLSCREEN_API)
489     WEBCORE_EXPORT bool containsFullScreenElement() const;
490     void setContainsFullScreenElement(bool);
491     void setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(bool);
492     WEBCORE_EXPORT virtual void webkitRequestFullscreen();
493 #endif
494 
495 #if ENABLE(POINTER_EVENTS)
496     ExceptionOr&lt;void&gt; setPointerCapture(int32_t);
497     ExceptionOr&lt;void&gt; releasePointerCapture(int32_t);
498     bool hasPointerCapture(int32_t);
499 #endif
500 
501 #if ENABLE(POINTER_LOCK)
502     WEBCORE_EXPORT void requestPointerLock();
503 #endif
504 
505     bool isSpellCheckingEnabled() const;
506 
507     bool hasID() const;
</pre>
<hr />
<pre>
514 
515     bool dispatchMouseEvent(const PlatformMouseEvent&amp;, const AtomString&amp; eventType, int clickCount = 0, Element* relatedTarget = nullptr);
516     bool dispatchWheelEvent(const PlatformWheelEvent&amp;);
517     bool dispatchKeyEvent(const PlatformKeyboardEvent&amp;);
518     void dispatchSimulatedClick(Event* underlyingEvent, SimulatedClickMouseEventOptions = SendNoEvents, SimulatedClickVisualOptions = ShowPressedLook);
519     void dispatchFocusInEvent(const AtomString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement);
520     void dispatchFocusOutEvent(const AtomString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement);
521     virtual void dispatchFocusEvent(RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement, FocusDirection);
522     virtual void dispatchBlurEvent(RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement);
523     void dispatchWebKitImageReadyEventForTesting();
524 
525     WEBCORE_EXPORT bool dispatchMouseForceWillBegin();
526 
527     virtual void willRecalcStyle(Style::Change);
528     virtual void didRecalcStyle(Style::Change);
529     virtual void willResetComputedStyle();
530     virtual void willAttachRenderers();
531     virtual void didAttachRenderers();
532     virtual void willDetachRenderers();
533     virtual void didDetachRenderers();
<span class="line-modified">534     virtual Optional&lt;ElementStyle&gt; resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle* shadowHostStyle);</span>
535 
536     LayoutRect absoluteEventHandlerBounds(bool&amp; includesFixedPositionElements) override;
537 
538     const RenderStyle* existingComputedStyle() const;
539     WEBCORE_EXPORT const RenderStyle* renderOrDisplayContentsStyle() const;
540 
541     void setBeforePseudoElement(Ref&lt;PseudoElement&gt;&amp;&amp;);
542     void setAfterPseudoElement(Ref&lt;PseudoElement&gt;&amp;&amp;);
543     void clearBeforePseudoElement();
544     void clearAfterPseudoElement();
545     void resetComputedStyle();
546     void resetStyleRelations();
547     void clearHoverAndActiveStatusBeforeDetachingRenderer();
548 
549     WEBCORE_EXPORT URL absoluteLinkURL() const;
550 
551 #if ENABLE(TOUCH_EVENTS)
552     bool allowsDoubleTapGesture() const override;
553 #endif
554 
<span class="line-modified">555     StyleResolver&amp; styleResolver();</span>
<span class="line-modified">556     ElementStyle resolveStyle(const RenderStyle* parentStyle);</span>
557 
558     // Invalidates the style of a single element. Style is resolved lazily.
559     // Descendant elements are resolved as needed, for example if an inherited property changes.
560     // This should be called whenever an element changes in a manner that can affect its style.
561     void invalidateStyle();
562 
563     // As above but also call RenderElement::setStyle with StyleDifference::RecompositeLayer flag for
564     // the element even when the style doesn&#39;t change. This is mostly needed by the animation code.
565     WEBCORE_EXPORT void invalidateStyleAndLayerComposition();
566 
567     // Invalidate the element and all its descendants. This is used when there is some sort of change
568     // in the tree that may affect the style of any of the descendants and we don&#39;t know how to optimize
569     // the case to limit the scope. This is expensive and should be avoided.
570     void invalidateStyleForSubtree();
571 
572     // Invalidates renderers for the element and all its descendants causing them to be torn down
573     // and rebuild during style resolution. Style is also recomputed. This is used in code dealing with
574     // custom (not style based) renderers. This is expensive and should be avoided.
575     // Elements newly added to the tree are also in this state.
576     void invalidateStyleAndRenderersForSubtree();
</pre>
<hr />
<pre>
579     void invalidateStyleForSubtreeInternal();
580 
581     bool hasDisplayContents() const;
582     void storeDisplayContentsStyle(std::unique_ptr&lt;RenderStyle&gt;);
583 
584     using ContainerNode::setAttributeEventListener;
585     void setAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; value);
586 
587 #if ENABLE(INTERSECTION_OBSERVER)
588     IntersectionObserverData&amp; ensureIntersectionObserverData();
589     IntersectionObserverData* intersectionObserverData();
590 #endif
591 
592 #if ENABLE(RESIZE_OBSERVER)
593     ResizeObserverData&amp; ensureResizeObserverData();
594     ResizeObserverData* resizeObserverData();
595 #endif
596 
597     Element* findAnchorElementForLink(String&amp; outAnchorName);
598 
<span class="line-modified">599     ExceptionOr&lt;Ref&lt;WebAnimation&gt;&gt; animate(JSC::ExecState&amp;, JSC::Strong&lt;JSC::JSObject&gt;&amp;&amp;, Optional&lt;Variant&lt;double, KeyframeAnimationOptions&gt;&gt;&amp;&amp;);</span>
<span class="line-modified">600     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; getAnimations();</span>
601 
602     ElementIdentifier createElementIdentifier();
603 
604 protected:
605     Element(const QualifiedName&amp;, Document&amp;, ConstructionType);
606 
607     InsertedIntoAncestorResult insertedIntoAncestor(InsertionType, ContainerNode&amp;) override;
608     void removedFromAncestor(RemovalType, ContainerNode&amp;) override;
609     void childrenChanged(const ChildChange&amp;) override;
610     void removeAllEventListeners() final;
611     virtual void parserDidSetAttributes();
612 
613     void clearTabIndexExplicitlyIfNeeded();
614     void setTabIndexExplicitly(int);
615 
<span class="line-removed">616     // classAttributeChanged() exists to share code between</span>
<span class="line-removed">617     // parseAttribute (called via setAttribute()) and</span>
<span class="line-removed">618     // svgAttributeChanged (called when element.className.baseValue is set)</span>
619     void classAttributeChanged(const AtomString&amp; newClassString);

620 
621     void addShadowRoot(Ref&lt;ShadowRoot&gt;&amp;&amp;);
622 
623     static ExceptionOr&lt;void&gt; mergeWithNextTextNode(Text&amp;);
624 
625 #if ENABLE(CSS_TYPED_OM)
626     StylePropertyMap* attributeStyleMap();
627     void setAttributeStyleMap(Ref&lt;StylePropertyMap&gt;&amp;&amp;);
628 #endif
629 
630 private:
631     Frame* documentFrameWithNonNullView() const;
632 
633     bool isTextNode() const;
634 
635     bool isUserActionElementInActiveChain() const;
636     bool isUserActionElementActive() const;
637     bool isUserActionElementFocused() const;
638     bool isUserActionElementHovered() const;
639 
</pre>
<hr />
<pre>
680 
681 #if ENABLE(INTERSECTION_OBSERVER)
682     void disconnectFromIntersectionObservers();
683 #endif
684 
685 #if ENABLE(RESIZE_OBSERVER)
686     void disconnectFromResizeObservers();
687 #endif
688 
689     // The cloneNode function is private so that non-virtual cloneElementWith/WithoutChildren are used instead.
690     Ref&lt;Node&gt; cloneNodeInternal(Document&amp;, CloningOperation) override;
691     virtual Ref&lt;Element&gt; cloneElementWithoutAttributesAndChildren(Document&amp;);
692 
693     void removeShadowRoot();
694 
695     const RenderStyle&amp; resolveComputedStyle();
696     const RenderStyle&amp; resolvePseudoElementStyle(PseudoId);
697 
698     unsigned rareDataChildIndex() const;
699 
<span class="line-removed">700     SpellcheckAttributeState spellcheckAttributeState() const;</span>
<span class="line-removed">701 </span>
702     void createUniqueElementData();
703 
704     ElementRareData* elementRareData() const;
705     ElementRareData&amp; ensureElementRareData();
706 
707     virtual int defaultTabIndex() const;
708 
709     void detachAllAttrNodesFromElement();
710     void detachAttrNodeFromElementWithValue(Attr*, const AtomString&amp; value);
711 
712     // Anyone thinking of using this should call document instead of ownerDocument.
713     void ownerDocument() const = delete;
714 
715     void attachAttributeNodeIfNeeded(Attr&amp;);
716 




717     QualifiedName m_tagName;
718     RefPtr&lt;ElementData&gt; m_elementData;
719 };
720 
721 inline bool Node::hasAttributes() const
722 {
723     return is&lt;Element&gt;(*this) &amp;&amp; downcast&lt;Element&gt;(*this).hasAttributes();
724 }
725 
726 inline NamedNodeMap* Node::attributes() const
727 {
728     return is&lt;Element&gt;(*this) ? &amp;downcast&lt;Element&gt;(*this).attributes() : nullptr;
729 }
730 
731 inline Element* Node::parentElement() const
732 {
733     ContainerNode* parent = parentNode();
734     return is&lt;Element&gt;(parent) ? downcast&lt;Element&gt;(parent) : nullptr;
735 }
736 
</pre>
</td>
<td>
<hr />
<pre>
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  *
 23  */
 24 
 25 #pragma once
 26 
 27 #include &quot;AXTextStateChangeIntent.h&quot;
 28 #include &quot;Document.h&quot;
 29 #include &quot;ElementData.h&quot;
 30 #include &quot;HTMLNames.h&quot;


 31 #include &quot;ScrollTypes.h&quot;
 32 #include &quot;ShadowRootMode.h&quot;
 33 #include &quot;SimulatedClickOptions.h&quot;
 34 #include &quot;StyleChange.h&quot;
<span class="line-added"> 35 #include &lt;JavaScriptCore/Strong.h&gt;</span>
 36 
 37 namespace WebCore {
 38 
 39 class CustomElementReactionQueue;
 40 class DatasetDOMStringMap;
 41 class DOMRect;
 42 class DOMRectList;
 43 class DOMTokenList;
 44 class ElementRareData;
 45 class Frame;
 46 class HTMLDocument;
 47 class IntSize;
 48 class JSCustomElementInterface;
<span class="line-added"> 49 class KeyframeEffectStack;</span>
 50 class KeyboardEvent;
 51 class Locale;
 52 class PlatformKeyboardEvent;
 53 class PlatformMouseEvent;
 54 class PlatformWheelEvent;
 55 class PseudoElement;
 56 class RenderTreePosition;
 57 class StylePropertyMap;
 58 class WebAnimation;
<span class="line-modified"> 59 </span>
<span class="line-added"> 60 struct GetAnimationsOptions;</span>
<span class="line-added"> 61 struct KeyframeAnimationOptions;</span>
 62 struct ScrollIntoViewOptions;
<span class="line-added"> 63 struct ScrollToOptions;</span>
 64 
 65 #if ENABLE(INTERSECTION_OBSERVER)
 66 struct IntersectionObserverData;
 67 #endif
 68 
 69 #if ENABLE(RESIZE_OBSERVER)
 70 struct ResizeObserverData;
 71 #endif
 72 
<span class="line-modified"> 73 namespace Style {</span>
<span class="line-modified"> 74 struct ElementStyle;</span>
<span class="line-modified"> 75 }</span>
<span class="line-modified"> 76 </span>
<span class="line-modified"> 77 enum class AnimationImpact;</span>
 78 
 79 class Element : public ContainerNode {
 80     WTF_MAKE_ISO_ALLOCATED(Element);
 81 public:
 82     static Ref&lt;Element&gt; create(const QualifiedName&amp;, Document&amp;);
 83     virtual ~Element();
 84 
 85     WEBCORE_EXPORT bool hasAttribute(const QualifiedName&amp;) const;
 86     WEBCORE_EXPORT const AtomString&amp; getAttribute(const QualifiedName&amp;) const;
 87     template&lt;typename... QualifiedNames&gt;
 88     const AtomString&amp; getAttribute(const QualifiedName&amp;, const QualifiedNames&amp;...) const;
 89     WEBCORE_EXPORT void setAttribute(const QualifiedName&amp;, const AtomString&amp; value);
 90     WEBCORE_EXPORT void setAttributeWithoutSynchronization(const QualifiedName&amp;, const AtomString&amp; value);
 91     void setSynchronizedLazyAttribute(const QualifiedName&amp;, const AtomString&amp; value);
 92     bool removeAttribute(const QualifiedName&amp;);
 93     Vector&lt;String&gt; getAttributeNames() const;
 94 
 95     // Typed getters and setters for language bindings.
 96     WEBCORE_EXPORT int getIntegralAttribute(const QualifiedName&amp; attributeName) const;
 97     WEBCORE_EXPORT void setIntegralAttribute(const QualifiedName&amp; attributeName, int value);
 98     WEBCORE_EXPORT unsigned getUnsignedIntegralAttribute(const QualifiedName&amp; attributeName) const;
 99     WEBCORE_EXPORT void setUnsignedIntegralAttribute(const QualifiedName&amp; attributeName, unsigned value);
100 
101     // Call this to get the value of an attribute that is known not to be the style
102     // attribute or one of the SVG animatable attributes.
103     bool hasAttributeWithoutSynchronization(const QualifiedName&amp;) const;
104     const AtomString&amp; attributeWithoutSynchronization(const QualifiedName&amp;) const;



105 
106 #if DUMP_NODE_STATISTICS
107     bool hasNamedNodeMap() const;
108 #endif
<span class="line-added">109 </span>
110     WEBCORE_EXPORT bool hasAttributes() const;
<span class="line-added">111 </span>
112     // This variant will not update the potentially invalid attributes. To be used when not interested
113     // in style attribute or one of the SVG animation attributes.
114     bool hasAttributesWithoutUpdate() const;
115 
116     WEBCORE_EXPORT bool hasAttribute(const AtomString&amp; qualifiedName) const;
117     WEBCORE_EXPORT bool hasAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName) const;
118 
119     WEBCORE_EXPORT const AtomString&amp; getAttribute(const AtomString&amp; qualifiedName) const;
120     WEBCORE_EXPORT const AtomString&amp; getAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName) const;
121 
122     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setAttribute(const AtomString&amp; qualifiedName, const AtomString&amp; value);
123     static ExceptionOr&lt;QualifiedName&gt; parseAttributeName(const AtomString&amp; namespaceURI, const AtomString&amp; qualifiedName);
124     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; qualifiedName, const AtomString&amp; value);
125 
126     ExceptionOr&lt;bool&gt; toggleAttribute(const AtomString&amp; qualifiedName, Optional&lt;bool&gt; force);
127 
128     const AtomString&amp; getIdAttribute() const;
129     void setIdAttribute(const AtomString&amp;);
130 
131     const AtomString&amp; getNameAttribute() const;
</pre>
<hr />
<pre>
179     WEBCORE_EXPORT double clientHeight();
180 
181     virtual int scrollLeft();
182     virtual int scrollTop();
183     virtual void setScrollLeft(int);
184     virtual void setScrollTop(int);
185     virtual int scrollWidth();
186     virtual int scrollHeight();
187 
188     WEBCORE_EXPORT IntRect boundsInRootViewSpace();
189 
190     Optional&lt;std::pair&lt;RenderObject*, FloatRect&gt;&gt; boundingAbsoluteRectWithoutLayout();
191 
192     WEBCORE_EXPORT FloatRect boundingClientRect();
193 
194     WEBCORE_EXPORT Ref&lt;DOMRectList&gt; getClientRects();
195     Ref&lt;DOMRect&gt; getBoundingClientRect();
196 
197     // Returns the absolute bounding box translated into client coordinates.
198     WEBCORE_EXPORT IntRect clientRect() const;
<span class="line-added">199 </span>
200     // Returns the absolute bounding box translated into screen coordinates.
201     WEBCORE_EXPORT IntRect screenRect() const;
202 
203     WEBCORE_EXPORT bool removeAttribute(const AtomString&amp; qualifiedName);
204     WEBCORE_EXPORT bool removeAttributeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName);
205 
206     Ref&lt;Attr&gt; detachAttribute(unsigned index);
207 
208     WEBCORE_EXPORT RefPtr&lt;Attr&gt; getAttributeNode(const AtomString&amp; qualifiedName);
209     WEBCORE_EXPORT RefPtr&lt;Attr&gt; getAttributeNodeNS(const AtomString&amp; namespaceURI, const AtomString&amp; localName);
210     WEBCORE_EXPORT ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; setAttributeNode(Attr&amp;);
211     WEBCORE_EXPORT ExceptionOr&lt;RefPtr&lt;Attr&gt;&gt; setAttributeNodeNS(Attr&amp;);
212     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Attr&gt;&gt; removeAttributeNode(Attr&amp;);
213 
214     RefPtr&lt;Attr&gt; attrIfExists(const QualifiedName&amp;);
215     RefPtr&lt;Attr&gt; attrIfExists(const AtomString&amp; localName, bool shouldIgnoreAttributeCase);
216     Ref&lt;Attr&gt; ensureAttr(const QualifiedName&amp;);
217 
218     const Vector&lt;RefPtr&lt;Attr&gt;&gt;&amp; attrNodeList();
219 
220     const QualifiedName&amp; tagQName() const { return m_tagName; }
221 #if ENABLE(JIT)
222     static ptrdiff_t tagQNameMemoryOffset() { return OBJECT_OFFSETOF(Element, m_tagName); }
<span class="line-modified">223 #endif</span>
224     String tagName() const { return nodeName(); }
225     bool hasTagName(const QualifiedName&amp; tagName) const { return m_tagName.matches(tagName); }
226     bool hasTagName(const HTMLQualifiedName&amp; tagName) const { return ContainerNode::hasTagName(tagName); }
227     bool hasTagName(const MathMLQualifiedName&amp; tagName) const { return ContainerNode::hasTagName(tagName); }
228     bool hasTagName(const SVGQualifiedName&amp; tagName) const { return ContainerNode::hasTagName(tagName); }
229 

230     bool hasLocalName(const AtomString&amp; other) const { return m_tagName.localName() == other; }
231 
232     const AtomString&amp; localName() const final { return m_tagName.localName(); }
233     const AtomString&amp; prefix() const final { return m_tagName.prefix(); }
234     const AtomString&amp; namespaceURI() const final { return m_tagName.namespaceURI(); }
235 
236     ExceptionOr&lt;void&gt; setPrefix(const AtomString&amp;) final;
237 
238     String nodeName() const override;
239 
240     Ref&lt;Element&gt; cloneElementWithChildren(Document&amp;);
241     Ref&lt;Element&gt; cloneElementWithoutChildren(Document&amp;);
242 
243     void normalizeAttributes();
244     String nodeNamePreservingCase() const;
245 
246     WEBCORE_EXPORT void setBooleanAttribute(const QualifiedName&amp; name, bool);
247 
248     // For exposing to DOM only.
249     WEBCORE_EXPORT NamedNodeMap&amp; attributes() const;
250 
251     enum AttributeModificationReason {
252         ModifiedDirectly,
253         ModifiedByCloning
254     };
255 
<span class="line-modified">256     // These functions are called whenever an attribute is added, changed or removed.</span>
257     virtual void attributeChanged(const QualifiedName&amp;, const AtomString&amp; oldValue, const AtomString&amp; newValue, AttributeModificationReason = ModifiedDirectly);
258     virtual void parseAttribute(const QualifiedName&amp;, const AtomString&amp;) { }
259 
260     // Only called by the parser immediately after element construction.
261     void parserSetAttributes(const Vector&lt;Attribute&gt;&amp;);
262 
263     bool isEventHandlerAttribute(const Attribute&amp;) const;
264     bool isJavaScriptURLAttribute(const Attribute&amp;) const;
265 
266     // Remove attributes that might introduce scripting from the vector leaving the element unchanged.
267     void stripScriptingAttributes(Vector&lt;Attribute&gt;&amp;) const;
268 
269     const ElementData* elementData() const { return m_elementData.get(); }
270     static ptrdiff_t elementDataMemoryOffset() { return OBJECT_OFFSETOF(Element, m_elementData); }
271     UniqueElementData&amp; ensureUniqueElementData();
272 
273     void synchronizeAllAttributes() const;
274 
275     // Clones attributes only.
276     void cloneAttributesFromElement(const Element&amp;);
277 
278     // Clones all attribute-derived data, including subclass specifics (through copyNonAttributeProperties.)
279     void cloneDataFromElement(const Element&amp;);
280 
281     virtual void didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument);
282 
283     bool hasEquivalentAttributes(const Element&amp; other) const;
284 
285     virtual void copyNonAttributePropertiesFromElement(const Element&amp;) { }
286 
287     virtual RenderPtr&lt;RenderElement&gt; createElementRenderer(RenderStyle&amp;&amp;, const RenderTreePosition&amp;);
288     virtual bool rendererIsNeeded(const RenderStyle&amp;);
<span class="line-added">289     virtual bool rendererIsEverNeeded() { return true; }</span>
290 
291     WEBCORE_EXPORT ShadowRoot* shadowRoot() const;
<span class="line-modified">292     ShadowRoot* shadowRootForBindings(JSC::JSGlobalObject&amp;) const;</span>
293 
294     struct ShadowRootInit {
295         ShadowRootMode mode;
<span class="line-added">296         bool delegatesFocus { false };</span>
297     };
298     ExceptionOr&lt;ShadowRoot&amp;&gt; attachShadow(const ShadowRootInit&amp;);
299 
300     RefPtr&lt;ShadowRoot&gt; userAgentShadowRoot() const;
301     WEBCORE_EXPORT ShadowRoot&amp; ensureUserAgentShadowRoot();
302 
303     void setIsDefinedCustomElement(JSCustomElementInterface&amp;);
304     void setIsFailedCustomElement(JSCustomElementInterface&amp;);
305     void setIsCustomElementUpgradeCandidate();
306     void enqueueToUpgrade(JSCustomElementInterface&amp;);
307     CustomElementReactionQueue* reactionQueue() const;
308 
<span class="line-modified">309     // FIXME: This should not be virtual. Please do not add additional overrides of this function.</span>
310     virtual const AtomString&amp; shadowPseudoId() const;
311 
312     bool isInActiveChain() const { return isUserActionElement() &amp;&amp; isUserActionElementInActiveChain(); }
313     bool active() const { return isUserActionElement() &amp;&amp; isUserActionElementActive(); }
314     bool hovered() const { return isUserActionElement() &amp;&amp; isUserActionElementHovered(); }
315     bool focused() const { return isUserActionElement() &amp;&amp; isUserActionElementFocused(); }
316     bool hasFocusWithin() const { return getFlag(HasFocusWithin); };
317 
318     virtual void setActive(bool flag = true, bool pause = false);
319     virtual void setHovered(bool flag = true);
320     virtual void setFocus(bool flag);
321     void setHasFocusWithin(bool flag);
322 
323     Optional&lt;int&gt; tabIndexSetExplicitly() const;
324     bool shouldBeIgnoredInSequentialFocusNavigation() const { return defaultTabIndex() &lt; 0 &amp;&amp; !supportsFocus(); }
325     virtual bool supportsFocus() const;
326     virtual bool isFocusable() const;
327     virtual bool isKeyboardFocusable(KeyboardEvent*) const;
328     virtual bool isMouseFocusable() const;
329 
</pre>
<hr />
<pre>
403 
404     WEBCORE_EXPORT String innerHTML() const;
405     WEBCORE_EXPORT String outerHTML() const;
406     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setInnerHTML(const String&amp;);
407     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setOuterHTML(const String&amp;);
408     WEBCORE_EXPORT String innerText();
409     WEBCORE_EXPORT String outerText();
410 
411     virtual String title() const;
412 
413     const AtomString&amp; pseudo() const;
414     WEBCORE_EXPORT void setPseudo(const AtomString&amp;);
415 
416     LayoutSize minimumSizeForResizing() const;
417     void setMinimumSizeForResizing(const LayoutSize&amp;);
418 
419     // Use Document::registerForDocumentActivationCallbacks() to subscribe to these
420     virtual void prepareForDocumentSuspension() { }
421     virtual void resumeFromDocumentSuspension() { }
422 






423     virtual void willBecomeFullscreenElement();
424     virtual void ancestorWillEnterFullscreen() { }
425     virtual void didBecomeFullscreenElement() { }
426     virtual void willStopBeingFullscreenElement() { }
427 




428     bool isFinishedParsingChildren() const { return isParsingChildrenFinished(); }
429     void finishParsingChildren() override;
430     void beginParsingChildren() final;
431 
432     WEBCORE_EXPORT PseudoElement* beforePseudoElement() const;
433     WEBCORE_EXPORT PseudoElement* afterPseudoElement() const;
434     bool childNeedsShadowWalker() const;
435     void didShadowTreeAwareChildrenChange();
436 
437     virtual bool matchesValidPseudoClass() const;
438     virtual bool matchesInvalidPseudoClass() const;
439     virtual bool matchesReadWritePseudoClass() const;
440     virtual bool matchesIndeterminatePseudoClass() const;
441     virtual bool matchesDefaultPseudoClass() const;
442     WEBCORE_EXPORT ExceptionOr&lt;bool&gt; matches(const String&amp; selectors);
443     WEBCORE_EXPORT ExceptionOr&lt;Element*&gt; closest(const String&amp; selectors);
444     virtual bool shouldAppearIndeterminate() const;
445 
446     WEBCORE_EXPORT DOMTokenList&amp; classList();
447 
<span class="line-added">448     SpaceSplitString partNames() const;</span>
<span class="line-added">449     DOMTokenList&amp; part();</span>
<span class="line-added">450 </span>
451     DatasetDOMStringMap&amp; dataset();
452 
453 #if ENABLE(VIDEO)
454     virtual bool isMediaElement() const { return false; }
455 #endif
456 
457     virtual bool isFormControlElement() const { return false; }
458     virtual bool isSpinButtonElement() const { return false; }
459     virtual bool isTextFormControlElement() const { return false; }
460     virtual bool isTextField() const { return false; }
461     virtual bool isOptionalFormControl() const { return false; }
462     virtual bool isRequiredFormControl() const { return false; }
463     virtual bool isInRange() const { return false; }
464     virtual bool isOutOfRange() const { return false; }
465     virtual bool isUploadButton() const { return false; }
466     virtual bool isSliderContainerElement() const { return false; }
467 
468     bool canContainRangeEndPoint() const override;
469 
470     // Used for disabled form elements; if true, prevents mouse events from being dispatched
471     // to event listeners, and prevents DOMActivate events from being sent at all.
472     virtual bool isDisabledFormControl() const { return false; }
473 
474     virtual bool childShouldCreateRenderer(const Node&amp;) const;
475 
476     bool hasPendingResources() const;
477     void setHasPendingResources();
478     void clearHasPendingResources();
479     virtual void buildPendingResource() { };
480 
481     bool hasCSSAnimation() const;
482     void setHasCSSAnimation();
483     void clearHasCSSAnimation();
484 
<span class="line-added">485     KeyframeEffectStack* keyframeEffectStack() const;</span>
<span class="line-added">486     KeyframeEffectStack&amp; ensureKeyframeEffectStack();</span>
<span class="line-added">487     bool hasKeyframeEffects() const;</span>
<span class="line-added">488     OptionSet&lt;AnimationImpact&gt; applyKeyframeEffects(RenderStyle&amp;);</span>
<span class="line-added">489 </span>
490 #if ENABLE(FULLSCREEN_API)
491     WEBCORE_EXPORT bool containsFullScreenElement() const;
492     void setContainsFullScreenElement(bool);
493     void setContainsFullScreenElementOnAncestorsCrossingFrameBoundaries(bool);
494     WEBCORE_EXPORT virtual void webkitRequestFullscreen();
495 #endif
496 
497 #if ENABLE(POINTER_EVENTS)
498     ExceptionOr&lt;void&gt; setPointerCapture(int32_t);
499     ExceptionOr&lt;void&gt; releasePointerCapture(int32_t);
500     bool hasPointerCapture(int32_t);
501 #endif
502 
503 #if ENABLE(POINTER_LOCK)
504     WEBCORE_EXPORT void requestPointerLock();
505 #endif
506 
507     bool isSpellCheckingEnabled() const;
508 
509     bool hasID() const;
</pre>
<hr />
<pre>
516 
517     bool dispatchMouseEvent(const PlatformMouseEvent&amp;, const AtomString&amp; eventType, int clickCount = 0, Element* relatedTarget = nullptr);
518     bool dispatchWheelEvent(const PlatformWheelEvent&amp;);
519     bool dispatchKeyEvent(const PlatformKeyboardEvent&amp;);
520     void dispatchSimulatedClick(Event* underlyingEvent, SimulatedClickMouseEventOptions = SendNoEvents, SimulatedClickVisualOptions = ShowPressedLook);
521     void dispatchFocusInEvent(const AtomString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement);
522     void dispatchFocusOutEvent(const AtomString&amp; eventType, RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement);
523     virtual void dispatchFocusEvent(RefPtr&lt;Element&gt;&amp;&amp; oldFocusedElement, FocusDirection);
524     virtual void dispatchBlurEvent(RefPtr&lt;Element&gt;&amp;&amp; newFocusedElement);
525     void dispatchWebKitImageReadyEventForTesting();
526 
527     WEBCORE_EXPORT bool dispatchMouseForceWillBegin();
528 
529     virtual void willRecalcStyle(Style::Change);
530     virtual void didRecalcStyle(Style::Change);
531     virtual void willResetComputedStyle();
532     virtual void willAttachRenderers();
533     virtual void didAttachRenderers();
534     virtual void willDetachRenderers();
535     virtual void didDetachRenderers();
<span class="line-modified">536     virtual Optional&lt;Style::ElementStyle&gt; resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle* shadowHostStyle);</span>
537 
538     LayoutRect absoluteEventHandlerBounds(bool&amp; includesFixedPositionElements) override;
539 
540     const RenderStyle* existingComputedStyle() const;
541     WEBCORE_EXPORT const RenderStyle* renderOrDisplayContentsStyle() const;
542 
543     void setBeforePseudoElement(Ref&lt;PseudoElement&gt;&amp;&amp;);
544     void setAfterPseudoElement(Ref&lt;PseudoElement&gt;&amp;&amp;);
545     void clearBeforePseudoElement();
546     void clearAfterPseudoElement();
547     void resetComputedStyle();
548     void resetStyleRelations();
549     void clearHoverAndActiveStatusBeforeDetachingRenderer();
550 
551     WEBCORE_EXPORT URL absoluteLinkURL() const;
552 
553 #if ENABLE(TOUCH_EVENTS)
554     bool allowsDoubleTapGesture() const override;
555 #endif
556 
<span class="line-modified">557     Style::Resolver&amp; styleResolver();</span>
<span class="line-modified">558     Style::ElementStyle resolveStyle(const RenderStyle* parentStyle);</span>
559 
560     // Invalidates the style of a single element. Style is resolved lazily.
561     // Descendant elements are resolved as needed, for example if an inherited property changes.
562     // This should be called whenever an element changes in a manner that can affect its style.
563     void invalidateStyle();
564 
565     // As above but also call RenderElement::setStyle with StyleDifference::RecompositeLayer flag for
566     // the element even when the style doesn&#39;t change. This is mostly needed by the animation code.
567     WEBCORE_EXPORT void invalidateStyleAndLayerComposition();
568 
569     // Invalidate the element and all its descendants. This is used when there is some sort of change
570     // in the tree that may affect the style of any of the descendants and we don&#39;t know how to optimize
571     // the case to limit the scope. This is expensive and should be avoided.
572     void invalidateStyleForSubtree();
573 
574     // Invalidates renderers for the element and all its descendants causing them to be torn down
575     // and rebuild during style resolution. Style is also recomputed. This is used in code dealing with
576     // custom (not style based) renderers. This is expensive and should be avoided.
577     // Elements newly added to the tree are also in this state.
578     void invalidateStyleAndRenderersForSubtree();
</pre>
<hr />
<pre>
581     void invalidateStyleForSubtreeInternal();
582 
583     bool hasDisplayContents() const;
584     void storeDisplayContentsStyle(std::unique_ptr&lt;RenderStyle&gt;);
585 
586     using ContainerNode::setAttributeEventListener;
587     void setAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; value);
588 
589 #if ENABLE(INTERSECTION_OBSERVER)
590     IntersectionObserverData&amp; ensureIntersectionObserverData();
591     IntersectionObserverData* intersectionObserverData();
592 #endif
593 
594 #if ENABLE(RESIZE_OBSERVER)
595     ResizeObserverData&amp; ensureResizeObserverData();
596     ResizeObserverData* resizeObserverData();
597 #endif
598 
599     Element* findAnchorElementForLink(String&amp; outAnchorName);
600 
<span class="line-modified">601     ExceptionOr&lt;Ref&lt;WebAnimation&gt;&gt; animate(JSC::JSGlobalObject&amp;, JSC::Strong&lt;JSC::JSObject&gt;&amp;&amp;, Optional&lt;Variant&lt;double, KeyframeAnimationOptions&gt;&gt;&amp;&amp;);</span>
<span class="line-modified">602     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; getAnimations(Optional&lt;GetAnimationsOptions&gt;);</span>
603 
604     ElementIdentifier createElementIdentifier();
605 
606 protected:
607     Element(const QualifiedName&amp;, Document&amp;, ConstructionType);
608 
609     InsertedIntoAncestorResult insertedIntoAncestor(InsertionType, ContainerNode&amp;) override;
610     void removedFromAncestor(RemovalType, ContainerNode&amp;) override;
611     void childrenChanged(const ChildChange&amp;) override;
612     void removeAllEventListeners() final;
613     virtual void parserDidSetAttributes();
614 
615     void clearTabIndexExplicitlyIfNeeded();
616     void setTabIndexExplicitly(int);
617 



618     void classAttributeChanged(const AtomString&amp; newClassString);
<span class="line-added">619     void partAttributeChanged(const AtomString&amp; newValue);</span>
620 
621     void addShadowRoot(Ref&lt;ShadowRoot&gt;&amp;&amp;);
622 
623     static ExceptionOr&lt;void&gt; mergeWithNextTextNode(Text&amp;);
624 
625 #if ENABLE(CSS_TYPED_OM)
626     StylePropertyMap* attributeStyleMap();
627     void setAttributeStyleMap(Ref&lt;StylePropertyMap&gt;&amp;&amp;);
628 #endif
629 
630 private:
631     Frame* documentFrameWithNonNullView() const;
632 
633     bool isTextNode() const;
634 
635     bool isUserActionElementInActiveChain() const;
636     bool isUserActionElementActive() const;
637     bool isUserActionElementFocused() const;
638     bool isUserActionElementHovered() const;
639 
</pre>
<hr />
<pre>
680 
681 #if ENABLE(INTERSECTION_OBSERVER)
682     void disconnectFromIntersectionObservers();
683 #endif
684 
685 #if ENABLE(RESIZE_OBSERVER)
686     void disconnectFromResizeObservers();
687 #endif
688 
689     // The cloneNode function is private so that non-virtual cloneElementWith/WithoutChildren are used instead.
690     Ref&lt;Node&gt; cloneNodeInternal(Document&amp;, CloningOperation) override;
691     virtual Ref&lt;Element&gt; cloneElementWithoutAttributesAndChildren(Document&amp;);
692 
693     void removeShadowRoot();
694 
695     const RenderStyle&amp; resolveComputedStyle();
696     const RenderStyle&amp; resolvePseudoElementStyle(PseudoId);
697 
698     unsigned rareDataChildIndex() const;
699 


700     void createUniqueElementData();
701 
702     ElementRareData* elementRareData() const;
703     ElementRareData&amp; ensureElementRareData();
704 
705     virtual int defaultTabIndex() const;
706 
707     void detachAllAttrNodesFromElement();
708     void detachAttrNodeFromElementWithValue(Attr*, const AtomString&amp; value);
709 
710     // Anyone thinking of using this should call document instead of ownerDocument.
711     void ownerDocument() const = delete;
712 
713     void attachAttributeNodeIfNeeded(Attr&amp;);
714 
<span class="line-added">715 #if ASSERT_ENABLED</span>
<span class="line-added">716     WEBCORE_EXPORT bool fastAttributeLookupAllowed(const QualifiedName&amp;) const;</span>
<span class="line-added">717 #endif</span>
<span class="line-added">718 </span>
719     QualifiedName m_tagName;
720     RefPtr&lt;ElementData&gt; m_elementData;
721 };
722 
723 inline bool Node::hasAttributes() const
724 {
725     return is&lt;Element&gt;(*this) &amp;&amp; downcast&lt;Element&gt;(*this).hasAttributes();
726 }
727 
728 inline NamedNodeMap* Node::attributes() const
729 {
730     return is&lt;Element&gt;(*this) ? &amp;downcast&lt;Element&gt;(*this).attributes() : nullptr;
731 }
732 
733 inline Element* Node::parentElement() const
734 {
735     ContainerNode* parent = parentNode();
736     return is&lt;Element&gt;(parent) ? downcast&lt;Element&gt;(parent) : nullptr;
737 }
738 
</pre>
</td>
</tr>
</table>
<center><a href="Element.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Element.idl.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/ArrayPrototype.js</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ArrayIteratorPrototype.js.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AsyncFromSyncIteratorPrototype.js.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/ArrayPrototype.js</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 22,44 ***</span>
   * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
<span class="line-removed">- @constructor</span>
<span class="line-removed">- @globalPrivate</span>
<span class="line-removed">- function ArrayIterator(iteratedObject, kind, iterationFunction)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     &quot;use strict&quot;;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     @putByIdDirectPrivate(this, &quot;iteratedObject&quot;, iteratedObject);</span>
<span class="line-removed">-     @putByIdDirectPrivate(this, &quot;arrayIteratorKind&quot;, kind);</span>
<span class="line-removed">-     @putByIdDirectPrivate(this, &quot;arrayIteratorNextIndex&quot;, 0);</span>
<span class="line-removed">-     @putByIdDirectPrivate(this, &quot;arrayIteratorNext&quot;, iterationFunction);</span>
<span class="line-removed">-     @putByIdDirectPrivate(this, &quot;arrayIteratorIsDone&quot;, false);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- function values()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     &quot;use strict&quot;;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return new @ArrayIterator(@toObject(this, &quot;Array.prototype.values requires that |this| not be null or undefined&quot;), &quot;value&quot;, @arrayIteratorValueNext);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- function keys()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     &quot;use strict&quot;;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return new @ArrayIterator(@toObject(this, &quot;Array.prototype.keys requires that |this| not be null or undefined&quot;), &quot;key&quot;, @arrayIteratorKeyNext);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- function entries()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     &quot;use strict&quot;;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return new @ArrayIterator(@toObject(this, &quot;Array.prototype.entries requires that |this| not be null or undefined&quot;), &quot;key+value&quot;, @arrayIteratorKeyValueNext);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  function reduce(callback /*, initialValue */)
  {
      &quot;use strict&quot;;
  
      var array = @toObject(this, &quot;Array.prototype.reduce requires that |this| not be null or undefined&quot;);
<span class="line-new-header">--- 22,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 349,20 ***</span>
          return a &lt; b ? a : b;
      }
  
      function stringComparator(a, b)
      {
<span class="line-modified">!         let aString = a.string;</span>
<span class="line-modified">!         let bString = b.string;</span>
  
<span class="line-modified">!         let aLength = aString.length;</span>
<span class="line-modified">!         let bLength = bString.length;</span>
<span class="line-modified">!         let length = min(aLength, bLength);</span>
  
<span class="line-modified">!         for (let i = 0; i &lt; length; ++i) {</span>
<span class="line-modified">!             let aCharCode = aString.@charCodeAt(i);</span>
<span class="line-modified">!             let bCharCode = bString.@charCodeAt(i);</span>
  
              if (aCharCode == bCharCode)
                  continue;
  
              return aCharCode - bCharCode;
<span class="line-new-header">--- 315,20 ---</span>
          return a &lt; b ? a : b;
      }
  
      function stringComparator(a, b)
      {
<span class="line-modified">!         var aString = a.string;</span>
<span class="line-modified">!         var bString = b.string;</span>
  
<span class="line-modified">!         var aLength = aString.length;</span>
<span class="line-modified">!         var bLength = bString.length;</span>
<span class="line-modified">!         var length = min(aLength, bLength);</span>
  
<span class="line-modified">!         for (var i = 0; i &lt; length; ++i) {</span>
<span class="line-modified">!             var aCharCode = aString.@charCodeAt(i);</span>
<span class="line-modified">!             var bCharCode = bString.@charCodeAt(i);</span>
  
              if (aCharCode == bCharCode)
                  continue;
  
              return aCharCode - bCharCode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 372,29 ***</span>
      }
  
      // Move undefineds and holes to the end of a sparse array. Result is [values..., undefineds..., holes...].
      function compactSparse(array, dst, src, length)
      {
<span class="line-modified">!         let values = [ ];</span>
<span class="line-modified">!         let seen = { };</span>
<span class="line-modified">!         let valueCount = 0;</span>
<span class="line-modified">!         let undefinedCount = 0;</span>
  
          // Clean up after the in-progress non-sparse compaction that failed.
<span class="line-modified">!         for (let i = dst; i &lt; src; ++i)</span>
              delete array[i];
  
<span class="line-modified">!         for (let object = array; object; object = @Object.@getPrototypeOf(object)) {</span>
<span class="line-modified">!             let propertyNames = @Object.@getOwnPropertyNames(object);</span>
<span class="line-modified">!             for (let i = 0; i &lt; propertyNames.length; ++i) {</span>
<span class="line-modified">!                 let index = propertyNames[i];</span>
                  if (index &lt; length) { // Exclude non-numeric properties and properties past length.
                      if (seen[index]) // Exclude duplicates.
                          continue;
                      seen[index] = 1;
  
<span class="line-modified">!                     let value = array[index];</span>
                      delete array[index];
  
                      if (value === @undefined) {
                          ++undefinedCount;
                          continue;
<span class="line-new-header">--- 338,29 ---</span>
      }
  
      // Move undefineds and holes to the end of a sparse array. Result is [values..., undefineds..., holes...].
      function compactSparse(array, dst, src, length)
      {
<span class="line-modified">!         var values = [ ];</span>
<span class="line-modified">!         var seen = { };</span>
<span class="line-modified">!         var valueCount = 0;</span>
<span class="line-modified">!         var undefinedCount = 0;</span>
  
          // Clean up after the in-progress non-sparse compaction that failed.
<span class="line-modified">!         for (var i = dst; i &lt; src; ++i)</span>
              delete array[i];
  
<span class="line-modified">!         for (var object = array; object; object = @Object.@getPrototypeOf(object)) {</span>
<span class="line-modified">!             var propertyNames = @Object.@getOwnPropertyNames(object);</span>
<span class="line-modified">!             for (var i = 0; i &lt; propertyNames.length; ++i) {</span>
<span class="line-modified">!                 var index = propertyNames[i];</span>
                  if (index &lt; length) { // Exclude non-numeric properties and properties past length.
                      if (seen[index]) // Exclude duplicates.
                          continue;
                      seen[index] = 1;
  
<span class="line-modified">!                     var value = array[index];</span>
                      delete array[index];
  
                      if (value === @undefined) {
                          ++undefinedCount;
                          continue;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 403,75 ***</span>
                      array[valueCount++] = value;
                  }
              }
          }
  
<span class="line-modified">!         for (let i = valueCount; i &lt; valueCount + undefinedCount; ++i)</span>
              array[i] = @undefined;
  
          return valueCount;
      }
  
      function compactSlow(array, length)
      {
<span class="line-modified">!         let holeCount = 0;</span>
  
<span class="line-modified">!         let dst = 0;</span>
<span class="line-modified">!         let src = 0;</span>
          for (; src &lt; length; ++src) {
              if (!(src in array)) {
                  ++holeCount;
                  if (holeCount &lt; 256)
                      continue;
                  return compactSparse(array, dst, src, length);
              }
  
<span class="line-modified">!             let value = array[src];</span>
              if (value === @undefined)
                  continue;
  
              array[dst++] = value;
          }
  
<span class="line-modified">!         let valueCount = dst;</span>
<span class="line-modified">!         let undefinedCount = length - valueCount - holeCount;</span>
  
<span class="line-modified">!         for (let i = valueCount; i &lt; valueCount + undefinedCount; ++i)</span>
              array[i] = @undefined;
  
<span class="line-modified">!         for (let i = valueCount + undefinedCount; i &lt; length; ++i)</span>
              delete array[i];
  
          return valueCount;
      }
  
      // Move undefineds and holes to the end of an array. Result is [values..., undefineds..., holes...].
      function compact(array, length)
      {
<span class="line-modified">!         for (let i = 0; i &lt; array.length; ++i) {</span>
              if (array[i] === @undefined)
                  return compactSlow(array, length);
          }
  
          return length;
      }
  
      function merge(dst, src, srcIndex, srcEnd, width, comparator)
      {
<span class="line-modified">!         let left = srcIndex;</span>
<span class="line-modified">!         let leftEnd = min(left + width, srcEnd);</span>
<span class="line-modified">!         let right = leftEnd;</span>
<span class="line-modified">!         let rightEnd = min(right + width, srcEnd);</span>
  
<span class="line-modified">!         for (let dstIndex = left; dstIndex &lt; rightEnd; ++dstIndex) {</span>
              if (right &lt; rightEnd) {
                  if (left &gt;= leftEnd) {
                      dst[dstIndex] = src[right++];
                      continue;
                  }
  
<span class="line-modified">!                 let comparisonResult = comparator(src[right], src[left]);</span>
                  if ((typeof comparisonResult === &quot;boolean&quot; &amp;&amp; !comparisonResult) || comparisonResult &lt; 0) {
                      dst[dstIndex] = src[right++];
                      continue;
                  }
  
<span class="line-new-header">--- 369,75 ---</span>
                      array[valueCount++] = value;
                  }
              }
          }
  
<span class="line-modified">!         for (var i = valueCount; i &lt; valueCount + undefinedCount; ++i)</span>
              array[i] = @undefined;
  
          return valueCount;
      }
  
      function compactSlow(array, length)
      {
<span class="line-modified">!         var holeCount = 0;</span>
  
<span class="line-modified">!         var dst = 0;</span>
<span class="line-modified">!         var src = 0;</span>
          for (; src &lt; length; ++src) {
              if (!(src in array)) {
                  ++holeCount;
                  if (holeCount &lt; 256)
                      continue;
                  return compactSparse(array, dst, src, length);
              }
  
<span class="line-modified">!             var value = array[src];</span>
              if (value === @undefined)
                  continue;
  
              array[dst++] = value;
          }
  
<span class="line-modified">!         var valueCount = dst;</span>
<span class="line-modified">!         var undefinedCount = length - valueCount - holeCount;</span>
  
<span class="line-modified">!         for (var i = valueCount; i &lt; valueCount + undefinedCount; ++i)</span>
              array[i] = @undefined;
  
<span class="line-modified">!         for (var i = valueCount + undefinedCount; i &lt; length; ++i)</span>
              delete array[i];
  
          return valueCount;
      }
  
      // Move undefineds and holes to the end of an array. Result is [values..., undefineds..., holes...].
      function compact(array, length)
      {
<span class="line-modified">!         for (var i = 0; i &lt; array.length; ++i) {</span>
              if (array[i] === @undefined)
                  return compactSlow(array, length);
          }
  
          return length;
      }
  
      function merge(dst, src, srcIndex, srcEnd, width, comparator)
      {
<span class="line-modified">!         var left = srcIndex;</span>
<span class="line-modified">!         var leftEnd = min(left + width, srcEnd);</span>
<span class="line-modified">!         var right = leftEnd;</span>
<span class="line-modified">!         var rightEnd = min(right + width, srcEnd);</span>
  
<span class="line-modified">!         for (var dstIndex = left; dstIndex &lt; rightEnd; ++dstIndex) {</span>
              if (right &lt; rightEnd) {
                  if (left &gt;= leftEnd) {
                      dst[dstIndex] = src[right++];
                      continue;
                  }
  
<span class="line-modified">!                 var comparisonResult = comparator(src[right], src[left]);</span>
                  if ((typeof comparisonResult === &quot;boolean&quot; &amp;&amp; !comparisonResult) || comparisonResult &lt; 0) {
                      dst[dstIndex] = src[right++];
                      continue;
                  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 481,91 ***</span>
          }
      }
  
      function mergeSort(array, valueCount, comparator)
      {
<span class="line-modified">!         let buffer = [ ];</span>
          buffer.length = valueCount;
  
<span class="line-modified">!         let dst = buffer;</span>
<span class="line-modified">!         let src = array;</span>
<span class="line-modified">!         for (let width = 1; width &lt; valueCount; width *= 2) {</span>
<span class="line-modified">!             for (let srcIndex = 0; srcIndex &lt; valueCount; srcIndex += 2 * width)</span>
                  merge(dst, src, srcIndex, valueCount, width, comparator);
  
<span class="line-modified">!             let tmp = src;</span>
              src = dst;
              dst = tmp;
          }
  
          if (src != array) {
<span class="line-modified">!             for(let i = 0; i &lt; valueCount; i++)</span>
                  array[i] = src[i];
          }
      }
  
      function bucketSort(array, dst, bucket, depth)
      {
          if (bucket.length &lt; 32 || depth &gt; 32) {
              mergeSort(bucket, bucket.length, stringComparator);
<span class="line-modified">!             for (let i = 0; i &lt; bucket.length; ++i)</span>
                  array[dst++] = bucket[i].value;
              return dst;
          }
  
<span class="line-modified">!         let buckets = [ ];</span>
<span class="line-modified">!         for (let i = 0; i &lt; bucket.length; ++i) {</span>
<span class="line-modified">!             let entry = bucket[i];</span>
<span class="line-modified">!             let string = entry.string;</span>
              if (string.length == depth) {
                  array[dst++] = entry.value;
                  continue;
              }
  
<span class="line-modified">!             let c = string.@charCodeAt(depth);</span>
              if (!buckets[c])
                  buckets[c] = [ ];
              buckets[c][buckets[c].length] = entry;
          }
  
<span class="line-modified">!         for (let i = 0; i &lt; buckets.length; ++i) {</span>
              if (!buckets[i])
                  continue;
              dst = bucketSort(array, dst, buckets[i], depth + 1);
          }
  
          return dst;
      }
  
      function comparatorSort(array, length, comparator)
      {
<span class="line-modified">!         let valueCount = compact(array, length);</span>
          mergeSort(array, valueCount, comparator);
      }
  
      function stringSort(array, length)
      {
<span class="line-modified">!         let valueCount = compact(array, length);</span>
  
<span class="line-modified">!         let strings = @newArrayWithSize(valueCount);</span>
<span class="line-modified">!         for (let i = 0; i &lt; valueCount; ++i)</span>
              strings[i] = { string: @toString(array[i]), value: array[i] };
  
          bucketSort(array, 0, strings, 0);
      }
  
<span class="line-modified">!     let sortFunction;</span>
      if (typeof comparator == &quot;function&quot;)
          sortFunction = comparatorSort;
      else if (comparator === @undefined)
          sortFunction = stringSort;
      else
          @throwTypeError(&quot;Array.prototype.sort requires the comparsion function be a function or undefined&quot;);
  
<span class="line-modified">!     let array = @toObject(this, &quot;Array.prototype.sort requires that |this| not be null or undefined&quot;);</span>
  
<span class="line-modified">!     let length = @toLength(array.length);</span>
  
      // For compatibility with Firefox and Chrome, do nothing observable
      // to the target array if it has 0 or 1 sortable properties.
      if (length &lt; 2)
          return array;
<span class="line-new-header">--- 447,91 ---</span>
          }
      }
  
      function mergeSort(array, valueCount, comparator)
      {
<span class="line-modified">!         var buffer = [ ];</span>
          buffer.length = valueCount;
  
<span class="line-modified">!         var dst = buffer;</span>
<span class="line-modified">!         var src = array;</span>
<span class="line-modified">!         for (var width = 1; width &lt; valueCount; width *= 2) {</span>
<span class="line-modified">!             for (var srcIndex = 0; srcIndex &lt; valueCount; srcIndex += 2 * width)</span>
                  merge(dst, src, srcIndex, valueCount, width, comparator);
  
<span class="line-modified">!             var tmp = src;</span>
              src = dst;
              dst = tmp;
          }
  
          if (src != array) {
<span class="line-modified">!             for(var i = 0; i &lt; valueCount; i++)</span>
                  array[i] = src[i];
          }
      }
  
      function bucketSort(array, dst, bucket, depth)
      {
          if (bucket.length &lt; 32 || depth &gt; 32) {
              mergeSort(bucket, bucket.length, stringComparator);
<span class="line-modified">!             for (var i = 0; i &lt; bucket.length; ++i)</span>
                  array[dst++] = bucket[i].value;
              return dst;
          }
  
<span class="line-modified">!         var buckets = [ ];</span>
<span class="line-modified">!         for (var i = 0; i &lt; bucket.length; ++i) {</span>
<span class="line-modified">!             var entry = bucket[i];</span>
<span class="line-modified">!             var string = entry.string;</span>
              if (string.length == depth) {
                  array[dst++] = entry.value;
                  continue;
              }
  
<span class="line-modified">!             var c = string.@charCodeAt(depth);</span>
              if (!buckets[c])
                  buckets[c] = [ ];
              buckets[c][buckets[c].length] = entry;
          }
  
<span class="line-modified">!         for (var i = 0; i &lt; buckets.length; ++i) {</span>
              if (!buckets[i])
                  continue;
              dst = bucketSort(array, dst, buckets[i], depth + 1);
          }
  
          return dst;
      }
  
      function comparatorSort(array, length, comparator)
      {
<span class="line-modified">!         var valueCount = compact(array, length);</span>
          mergeSort(array, valueCount, comparator);
      }
  
      function stringSort(array, length)
      {
<span class="line-modified">!         var valueCount = compact(array, length);</span>
  
<span class="line-modified">!         var strings = @newArrayWithSize(valueCount);</span>
<span class="line-modified">!         for (var i = 0; i &lt; valueCount; ++i)</span>
              strings[i] = { string: @toString(array[i]), value: array[i] };
  
          bucketSort(array, 0, strings, 0);
      }
  
<span class="line-modified">!     var sortFunction;</span>
      if (typeof comparator == &quot;function&quot;)
          sortFunction = comparatorSort;
      else if (comparator === @undefined)
          sortFunction = stringSort;
      else
          @throwTypeError(&quot;Array.prototype.sort requires the comparsion function be a function or undefined&quot;);
  
<span class="line-modified">!     var array = @toObject(this, &quot;Array.prototype.sort requires that |this| not be null or undefined&quot;);</span>
  
<span class="line-modified">!     var length = @toLength(array.length);</span>
  
      // For compatibility with Firefox and Chrome, do nothing observable
      // to the target array if it has 0 or 1 sortable properties.
      if (length &lt; 2)
          return array;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 587,13 ***</span>
  
      var resultIndex = 0;
      var argIndex = 0;
  
      do {
<span class="line-modified">!         let spreadable = @isObject(currentElement) &amp;&amp; currentElement.@isConcatSpreadableSymbol;</span>
          if ((spreadable === @undefined &amp;&amp; @isArray(currentElement)) || spreadable) {
<span class="line-modified">!             let length = @toLength(currentElement.length);</span>
              if (length + resultIndex &gt; @MAX_ARRAY_INDEX)
                  @throwRangeError(&quot;Length exceeded the maximum array length&quot;);
              if (resultIsArray &amp;&amp; @isJSArray(currentElement)) {
                  @appendMemcpy(result, currentElement, resultIndex);
                  resultIndex += length;
<span class="line-new-header">--- 553,13 ---</span>
  
      var resultIndex = 0;
      var argIndex = 0;
  
      do {
<span class="line-modified">!         var spreadable = @isObject(currentElement) &amp;&amp; currentElement.@isConcatSpreadableSymbol;</span>
          if ((spreadable === @undefined &amp;&amp; @isArray(currentElement)) || spreadable) {
<span class="line-modified">!             var length = @toLength(currentElement.length);</span>
              if (length + resultIndex &gt; @MAX_ARRAY_INDEX)
                  @throwRangeError(&quot;Length exceeded the maximum array length&quot;);
              if (resultIsArray &amp;&amp; @isJSArray(currentElement)) {
                  @appendMemcpy(result, currentElement, resultIndex);
                  resultIndex += length;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 623,11 ***</span>
      if (@argumentCount() === 1
          &amp;&amp; @isJSArray(this)
          &amp;&amp; this.@isConcatSpreadableSymbol === @undefined
          &amp;&amp; (!@isObject(first) || (!@isProxyObject(first) &amp;&amp; first.@isConcatSpreadableSymbol === @undefined))) {
  
<span class="line-modified">!         let result = @concatMemcpy(this, first);</span>
          if (result !== null)
              return result;
      }
  
      return @tailCallForwardArguments(@concatSlowPath, this);
<span class="line-new-header">--- 589,11 ---</span>
      if (@argumentCount() === 1
          &amp;&amp; @isJSArray(this)
          &amp;&amp; this.@isConcatSpreadableSymbol === @undefined
          &amp;&amp; (!@isObject(first) || (!@isProxyObject(first) &amp;&amp; first.@isConcatSpreadableSymbol === @undefined))) {
  
<span class="line-modified">!         var result = @concatMemcpy(this, first);</span>
          if (result !== null)
              return result;
      }
  
      return @tailCallForwardArguments(@concatSlowPath, this);
</pre>
<center><a href="ArrayIteratorPrototype.js.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AsyncFromSyncIteratorPrototype.js.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/ScriptDebugServer.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/ScriptDebugServer.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/ScriptDebugServer.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/ScriptDebugServer.cpp
@@ -39,14 +39,14 @@
 #include "JavaScriptCallFrame.h"
 #include "SourceProvider.h"
 #include <wtf/NeverDestroyed.h>
 #include <wtf/SetForScope.h>
 
-using namespace JSC;
-
 namespace Inspector {
 
+using namespace JSC;
+
 ScriptDebugServer::ScriptDebugServer(VM& vm)
     : Debugger(vm)
 {
 }
 
@@ -91,20 +91,20 @@
     DebuggerCallFrame& debuggerCallFrame = currentDebuggerCallFrame();
 
     switch (breakpointAction.type) {
     case ScriptBreakpointActionTypeLog:
         dispatchFunctionToListeners([&] (ScriptDebugListener& listener) {
-            listener.breakpointActionLog(*debuggerCallFrame.globalExec(), breakpointAction.data);
+            listener.breakpointActionLog(debuggerCallFrame.globalObject(), breakpointAction.data);
         });
         break;
 
     case ScriptBreakpointActionTypeEvaluate: {
         NakedPtr<Exception> exception;
         JSObject* scopeExtensionObject = nullptr;
         debuggerCallFrame.evaluateWithScopeExtension(breakpointAction.data, scopeExtensionObject, exception);
         if (exception)
-            reportException(debuggerCallFrame.globalExec(), exception);
+            reportException(debuggerCallFrame.globalObject(), exception);
         break;
     }
 
     case ScriptBreakpointActionTypeSound:
         dispatchFunctionToListeners([&] (ScriptDebugListener& listener) {
@@ -114,16 +114,16 @@
 
     case ScriptBreakpointActionTypeProbe: {
         NakedPtr<Exception> exception;
         JSObject* scopeExtensionObject = nullptr;
         JSValue result = debuggerCallFrame.evaluateWithScopeExtension(breakpointAction.data, scopeExtensionObject, exception);
-        JSC::ExecState* exec = debuggerCallFrame.globalExec();
+        JSC::JSGlobalObject* globalObject = debuggerCallFrame.globalObject();
         if (exception)
-            reportException(exec, exception);
+            reportException(globalObject, exception);
 
         dispatchFunctionToListeners([&] (ScriptDebugListener& listener) {
-            listener.breakpointActionProbe(*exec, breakpointAction, m_currentProbeBatchId, m_nextProbeSampleId++, exception ? exception->value() : result);
+            listener.breakpointActionProbe(globalObject, breakpointAction, m_currentProbeBatchId, m_nextProbeSampleId++, exception ? exception->value() : result);
         });
         break;
     }
 
     default:
@@ -131,11 +131,11 @@
     }
 
     return true;
 }
 
-void ScriptDebugServer::sourceParsed(ExecState* exec, SourceProvider* sourceProvider, int errorLine, const String& errorMessage)
+void ScriptDebugServer::sourceParsed(JSGlobalObject* globalObject, SourceProvider* sourceProvider, int errorLine, const String& errorMessage)
 {
     // Preemptively check whether we can dispatch so that we don't do any unnecessary allocations.
     if (!canDispatchFunctionToListeners())
         return;
 
@@ -156,11 +156,11 @@
     script.sourceProvider = sourceProvider;
     script.url = sourceProvider->url();
     script.source = sourceProvider->source().toString();
     script.startLine = sourceProvider->startPosition().m_line.zeroBasedInt();
     script.startColumn = sourceProvider->startPosition().m_column.zeroBasedInt();
-    script.isContentScript = isContentScript(exec);
+    script.isContentScript = isContentScript(globalObject);
     script.sourceURL = sourceProvider->sourceURLDirective();
     script.sourceMappingURL = sourceProvider->sourceMappingURLDirective();
 
     int sourceLength = script.source.length();
     int lineCount = 1;
@@ -238,32 +238,31 @@
                 return;
         }
     }
 }
 
-void ScriptDebugServer::handleExceptionInBreakpointCondition(JSC::ExecState* exec, JSC::Exception* exception) const
+void ScriptDebugServer::handleExceptionInBreakpointCondition(JSC::JSGlobalObject* globalObject, JSC::Exception* exception) const
 {
-    reportException(exec, exception);
+    reportException(globalObject, exception);
 }
 
-void ScriptDebugServer::handlePause(JSGlobalObject* vmEntryGlobalObject, Debugger::ReasonForPause)
+void ScriptDebugServer::handlePause(JSGlobalObject* globalObject, Debugger::ReasonForPause)
 {
     dispatchFunctionToListeners([&] (ScriptDebugListener& listener) {
         ASSERT(isPaused());
         auto& debuggerCallFrame = currentDebuggerCallFrame();
         auto* globalObject = debuggerCallFrame.scope()->globalObject();
-        auto& state = *globalObject->globalExec();
-        auto jsCallFrame = toJS(&state, globalObject, JavaScriptCallFrame::create(debuggerCallFrame).ptr());
-        listener.didPause(state, jsCallFrame, exceptionOrCaughtValue(&state));
+        auto jsCallFrame = toJS(globalObject, globalObject, JavaScriptCallFrame::create(debuggerCallFrame).ptr());
+        listener.didPause(globalObject, jsCallFrame, exceptionOrCaughtValue(globalObject));
     });
 
-    didPause(vmEntryGlobalObject);
+    didPause(globalObject);
 
     m_doneProcessingDebuggerEvents = false;
     runEventLoopWhilePaused();
 
-    didContinue(vmEntryGlobalObject);
+    didContinue(globalObject);
 
     dispatchFunctionToListeners([&] (ScriptDebugListener& listener) {
         listener.didContinue();
     });
 }
@@ -289,19 +288,19 @@
     // Last listener. Detach the debugger.
     if (m_listeners.isEmpty())
         detachDebugger(isBeingDestroyed);
 }
 
-JSC::JSValue ScriptDebugServer::exceptionOrCaughtValue(JSC::ExecState* state)
+JSC::JSValue ScriptDebugServer::exceptionOrCaughtValue(JSC::JSGlobalObject* globalObject)
 {
     if (reasonForPause() == PausedForException)
         return currentException();
 
     for (RefPtr<DebuggerCallFrame> frame = &currentDebuggerCallFrame(); frame; frame = frame->callerFrame()) {
         DebuggerScope& scope = *frame->scope();
         if (scope.isCatchScope())
-            return scope.caughtValue(state);
+            return scope.caughtValue(globalObject);
     }
 
     return { };
 }
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSBigInt.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSBigInt.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSBoundFunction.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSBigInt.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;CPU.h&quot;
 30 #include &quot;ExceptionHelpers.h&quot;
 31 #include &quot;JSObject.h&quot;
<span class="line-modified"> 32 #include &lt;wtf/CagedPtr.h&gt;</span>
 33 #include &lt;wtf/text/StringBuilder.h&gt;
 34 #include &lt;wtf/text/StringView.h&gt;
 35 #include &lt;wtf/text/WTFString.h&gt;
 36 
 37 namespace JSC {
 38 
 39 class JSBigInt final : public JSCell {

 40     using Base = JSCell;
<span class="line-modified"> 41     static const unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal | OverridesToThis;</span>


 42     friend class CachedBigInt;
 43 
<span class="line-modified"> 44 public:</span>

 45 
<span class="line-modified"> 46     JSBigInt(VM&amp;, Structure*, unsigned length);</span>




 47 
 48     enum class InitializationType { None, WithZero };
 49     void initialize(InitializationType);
 50 
 51     static size_t estimatedSize(JSCell*, VM&amp;);
 52 
 53     static Structure* createStructure(VM&amp;, JSGlobalObject*, JSValue prototype);
 54     static JSBigInt* createZero(VM&amp;);
<span class="line-modified"> 55     static JSBigInt* tryCreateWithLength(ExecState*, unsigned length);</span>
 56     static JSBigInt* createWithLengthUnchecked(VM&amp;, unsigned length);
 57 
 58     static JSBigInt* createFrom(VM&amp;, int32_t value);
 59     static JSBigInt* createFrom(VM&amp;, uint32_t value);
 60     static JSBigInt* createFrom(VM&amp;, int64_t value);
 61     static JSBigInt* createFrom(VM&amp;, bool value);
 62 
 63     static size_t offsetOfLength()
 64     {
 65         return OBJECT_OFFSETOF(JSBigInt, m_length);
 66     }
 67 
 68     DECLARE_EXPORT_INFO;
 69 
<span class="line-modified"> 70     JSValue toPrimitive(ExecState*, PreferredPrimitiveType) const;</span>
 71 
 72     void setSign(bool sign) { m_sign = sign; }
 73     bool sign() const { return m_sign; }
 74 
 75     unsigned length() const { return m_length; }
 76 
 77     enum class ErrorParseMode {
 78         ThrowExceptions,
 79         IgnoreExceptions
 80     };
 81 
 82     enum class ParseIntMode { DisallowEmptyString, AllowEmptyString };
 83     enum class ParseIntSign { Unsigned, Signed };
 84 
<span class="line-modified"> 85     static JSBigInt* parseInt(ExecState*, VM&amp;, StringView, uint8_t radix, ErrorParseMode = ErrorParseMode::ThrowExceptions, ParseIntSign = ParseIntSign::Unsigned);</span>
<span class="line-modified"> 86     static JSBigInt* parseInt(ExecState*, StringView, ErrorParseMode = ErrorParseMode::ThrowExceptions);</span>
<span class="line-modified"> 87     static JSBigInt* stringToBigInt(ExecState*, StringView);</span>
 88 
 89     static String tryGetString(VM&amp;, JSBigInt*, unsigned radix);
 90 
 91     Optional&lt;uint8_t&gt; singleDigitValueForString();
<span class="line-modified"> 92     String toString(ExecState*, unsigned radix);</span>
 93 
 94     enum class ComparisonMode {
 95         LessThan,
 96         LessThanOrEqual
 97     };
 98 
 99     enum class ComparisonResult {
100         Equal,
101         Undefined,
102         GreaterThan,
103         LessThan
104     };
105 
106     JS_EXPORT_PRIVATE static bool equals(JSBigInt*, JSBigInt*);
107     bool equalsToNumber(JSValue);
108     static ComparisonResult compare(JSBigInt* x, JSBigInt* y);
109 
<span class="line-modified">110     bool getPrimitiveNumber(ExecState*, double&amp; number, JSValue&amp; result) const;</span>
<span class="line-modified">111     double toNumber(ExecState*) const;</span>
112 
<span class="line-modified">113     JSObject* toObject(ExecState*, JSGlobalObject*) const;</span>
114     inline bool toBoolean() const { return !isZero(); }
115 
<span class="line-modified">116     static JSBigInt* exponentiate(ExecState*, JSBigInt* base, JSBigInt* exponent);</span>
117 
<span class="line-modified">118     static JSBigInt* multiply(ExecState*, JSBigInt* x, JSBigInt* y);</span>
119 
120     ComparisonResult static compareToDouble(JSBigInt* x, double y);
121 
<span class="line-modified">122     static JSBigInt* add(ExecState*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">123     static JSBigInt* sub(ExecState*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">124     static JSBigInt* divide(ExecState*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">125     static JSBigInt* remainder(ExecState*, JSBigInt* x, JSBigInt* y);</span>


126     static JSBigInt* unaryMinus(VM&amp;, JSBigInt* x);
127 
<span class="line-modified">128     static JSBigInt* bitwiseAnd(ExecState*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">129     static JSBigInt* bitwiseOr(ExecState*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">130     static JSBigInt* bitwiseXor(ExecState*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">131     static JSBigInt* bitwiseNot(ExecState*, JSBigInt* x);</span>
132 
<span class="line-modified">133     static JSBigInt* leftShift(ExecState*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">134     static JSBigInt* signedRightShift(ExecState*, JSBigInt* x, JSBigInt* y);</span>
135 
136 private:

137 
<span class="line-removed">138     using Digit = UCPURegister;</span>
139     static constexpr unsigned bitsPerByte = 8;
140     static constexpr unsigned digitBits = sizeof(Digit) * bitsPerByte;
141     static constexpr unsigned halfDigitBits = digitBits / 2;
142     static constexpr Digit halfDigitMask = (1ull &lt;&lt; halfDigitBits) - 1;
143     static constexpr int maxInt = 0x7FFFFFFF;
144 
145     // The maximum length that the current implementation supports would be
146     // maxInt / digitBits. However, we use a lower limit for now, because
147     // raising it later is easier than lowering it.
148     // Support up to 1 million bits.
149     static constexpr unsigned maxLength = 1024 * 1024 / (sizeof(void*) * bitsPerByte);
150     static constexpr unsigned maxLengthBits = maxInt - sizeof(void*) * bitsPerByte - 1;
151 
152     static uint64_t calculateMaximumCharactersRequired(unsigned length, unsigned radix, Digit lastDigit, bool sign);
153 
154     static ComparisonResult absoluteCompare(JSBigInt* x, JSBigInt* y);
155     static void absoluteDivWithDigitDivisor(VM&amp;, JSBigInt* x, Digit divisor, JSBigInt** quotient, Digit&amp; remainder);
156     static void internalMultiplyAdd(JSBigInt* source, Digit factor, Digit summand, unsigned, JSBigInt* result);
157     static void multiplyAccumulate(JSBigInt* multiplicand, Digit multiplier, JSBigInt* accumulator, unsigned accumulatorIndex);
<span class="line-modified">158     static void absoluteDivWithBigIntDivisor(ExecState*, JSBigInt* dividend, JSBigInt* divisor, JSBigInt** quotient, JSBigInt** remainder);</span>
159 
160     enum class LeftShiftMode {
161         SameSizeResult,
162         AlwaysAddOneDigit
163     };
164 
<span class="line-modified">165     static JSBigInt* absoluteLeftShiftAlwaysCopy(ExecState*, JSBigInt* x, unsigned shift, LeftShiftMode);</span>
166     static bool productGreaterThan(Digit factor1, Digit factor2, Digit high, Digit low);
167 
168     Digit absoluteInplaceAdd(JSBigInt* summand, unsigned startIndex);
169     Digit absoluteInplaceSub(JSBigInt* subtrahend, unsigned startIndex);
170     void inplaceRightShift(unsigned shift);
171 
172     enum class ExtraDigitsHandling {
173         Copy,
174         Skip
175     };
176 
177     enum class SymmetricOp {
178         Symmetric,
179         NotSymmetric
180     };
181 
182     template&lt;typename BitwiseOp&gt;
183     static JSBigInt* absoluteBitwiseOp(VM&amp;, JSBigInt* x, JSBigInt* y, ExtraDigitsHandling, SymmetricOp, BitwiseOp&amp;&amp;);
184 
185     static JSBigInt* absoluteAnd(VM&amp;, JSBigInt* x, JSBigInt* y);
186     static JSBigInt* absoluteOr(VM&amp;, JSBigInt* x, JSBigInt* y);
187     static JSBigInt* absoluteAndNot(VM&amp;, JSBigInt* x, JSBigInt* y);
188     static JSBigInt* absoluteXor(VM&amp;, JSBigInt* x, JSBigInt* y);
189 
190     enum class SignOption {
191         Signed,
192         Unsigned
193     };
194 
<span class="line-modified">195     static JSBigInt* absoluteAddOne(ExecState*, JSBigInt* x, SignOption);</span>
<span class="line-modified">196     static JSBigInt* absoluteSubOne(ExecState*, JSBigInt* x, unsigned resultLength);</span>
197 
198     // Digit arithmetic helpers.
199     static Digit digitAdd(Digit a, Digit b, Digit&amp; carry);
200     static Digit digitSub(Digit a, Digit b, Digit&amp; borrow);
201     static Digit digitMul(Digit a, Digit b, Digit&amp; high);
202     static Digit digitDiv(Digit high, Digit low, Digit divisor, Digit&amp; remainder);
203     static Digit digitPow(Digit base, Digit exponent);
204 
<span class="line-modified">205     static String toStringBasePowerOfTwo(VM&amp;, ExecState*, JSBigInt*, unsigned radix);</span>
<span class="line-modified">206     static String toStringGeneric(VM&amp;, ExecState*, JSBigInt*, unsigned radix);</span>
207 
208     inline bool isZero() const
209     {
210         ASSERT(length() || !sign());
211         return length() == 0;
212     }
213 
214     template &lt;typename CharType&gt;
<span class="line-modified">215     static JSBigInt* parseInt(ExecState*, CharType*  data, unsigned length, ErrorParseMode);</span>
216 
217     template &lt;typename CharType&gt;
<span class="line-modified">218     static JSBigInt* parseInt(ExecState*, VM&amp;, CharType* data, unsigned length, unsigned startIndex, unsigned radix, ErrorParseMode, ParseIntSign = ParseIntSign::Signed, ParseIntMode = ParseIntMode::AllowEmptyString);</span>
219 
<span class="line-modified">220     static JSBigInt* allocateFor(ExecState*, VM&amp;, unsigned radix, unsigned charcount);</span>
221 
222     static JSBigInt* copy(VM&amp;, JSBigInt* x);
223     JSBigInt* rightTrim(VM&amp;);
224 
225     void inplaceMultiplyAdd(Digit multiplier, Digit part);
<span class="line-modified">226     static JSBigInt* absoluteAdd(ExecState*, JSBigInt* x, JSBigInt* y, bool resultSign);</span>
227     static JSBigInt* absoluteSub(VM&amp;, JSBigInt* x, JSBigInt* y, bool resultSign);
228 
<span class="line-modified">229     static JSBigInt* leftShiftByAbsolute(ExecState*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">230     static JSBigInt* rightShiftByAbsolute(ExecState*, JSBigInt* x, JSBigInt* y);</span>
231 
232     static JSBigInt* rightShiftByMaximum(VM&amp;, bool sign);
233 
234     static Optional&lt;Digit&gt; toShiftAmount(JSBigInt* x);
235 
<span class="line-removed">236     static size_t allocationSize(unsigned length);</span>
237     inline static size_t offsetOfData()
238     {
<span class="line-modified">239         return WTF::roundUpToMultipleOf&lt;sizeof(Digit)&gt;(sizeof(JSBigInt));</span>
240     }
241 
<span class="line-modified">242     inline Digit* dataStorage()</span>
<span class="line-removed">243     {</span>
<span class="line-removed">244         return bitwise_cast&lt;Digit*&gt;(reinterpret_cast&lt;char*&gt;(this) + offsetOfData());</span>
<span class="line-removed">245     }</span>
246 
247     Digit digit(unsigned);
248     void setDigit(unsigned, Digit);
249 
250     const unsigned m_length;
251     bool m_sign { false };

252 };
253 
254 inline JSBigInt* asBigInt(JSValue value)
255 {
256     ASSERT(value.asCell()-&gt;isBigInt());
257     return jsCast&lt;JSBigInt*&gt;(value.asCell());
258 }
259 
260 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;CPU.h&quot;
 30 #include &quot;ExceptionHelpers.h&quot;
 31 #include &quot;JSObject.h&quot;
<span class="line-modified"> 32 #include &lt;wtf/CagedUniquePtr.h&gt;</span>
 33 #include &lt;wtf/text/StringBuilder.h&gt;
 34 #include &lt;wtf/text/StringView.h&gt;
 35 #include &lt;wtf/text/WTFString.h&gt;
 36 
 37 namespace JSC {
 38 
 39 class JSBigInt final : public JSCell {
<span class="line-added"> 40 public:</span>
 41     using Base = JSCell;
<span class="line-modified"> 42     using Digit = UCPURegister;</span>
<span class="line-added"> 43 </span>
<span class="line-added"> 44     static constexpr unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal | OverridesToThis;</span>
 45     friend class CachedBigInt;
 46 
<span class="line-modified"> 47     static constexpr bool needsDestruction = true;</span>
<span class="line-added"> 48     static void destroy(JSCell*);</span>
 49 
<span class="line-modified"> 50     template&lt;typename CellType, SubspaceAccess&gt;</span>
<span class="line-added"> 51     static IsoSubspace* subspaceFor(VM&amp; vm)</span>
<span class="line-added"> 52     {</span>
<span class="line-added"> 53         return &amp;vm.bigIntSpace;</span>
<span class="line-added"> 54     }</span>
 55 
 56     enum class InitializationType { None, WithZero };
 57     void initialize(InitializationType);
 58 
 59     static size_t estimatedSize(JSCell*, VM&amp;);
 60 
 61     static Structure* createStructure(VM&amp;, JSGlobalObject*, JSValue prototype);
 62     static JSBigInt* createZero(VM&amp;);
<span class="line-modified"> 63     static JSBigInt* tryCreateWithLength(JSGlobalObject*, unsigned length);</span>
 64     static JSBigInt* createWithLengthUnchecked(VM&amp;, unsigned length);
 65 
 66     static JSBigInt* createFrom(VM&amp;, int32_t value);
 67     static JSBigInt* createFrom(VM&amp;, uint32_t value);
 68     static JSBigInt* createFrom(VM&amp;, int64_t value);
 69     static JSBigInt* createFrom(VM&amp;, bool value);
 70 
 71     static size_t offsetOfLength()
 72     {
 73         return OBJECT_OFFSETOF(JSBigInt, m_length);
 74     }
 75 
 76     DECLARE_EXPORT_INFO;
 77 
<span class="line-modified"> 78     JSValue toPrimitive(JSGlobalObject*, PreferredPrimitiveType) const;</span>
 79 
 80     void setSign(bool sign) { m_sign = sign; }
 81     bool sign() const { return m_sign; }
 82 
 83     unsigned length() const { return m_length; }
 84 
 85     enum class ErrorParseMode {
 86         ThrowExceptions,
 87         IgnoreExceptions
 88     };
 89 
 90     enum class ParseIntMode { DisallowEmptyString, AllowEmptyString };
 91     enum class ParseIntSign { Unsigned, Signed };
 92 
<span class="line-modified"> 93     static JSBigInt* parseInt(JSGlobalObject*, VM&amp;, StringView, uint8_t radix, ErrorParseMode = ErrorParseMode::ThrowExceptions, ParseIntSign = ParseIntSign::Unsigned);</span>
<span class="line-modified"> 94     static JSBigInt* parseInt(JSGlobalObject*, StringView, ErrorParseMode = ErrorParseMode::ThrowExceptions);</span>
<span class="line-modified"> 95     static JSBigInt* stringToBigInt(JSGlobalObject*, StringView);</span>
 96 
 97     static String tryGetString(VM&amp;, JSBigInt*, unsigned radix);
 98 
 99     Optional&lt;uint8_t&gt; singleDigitValueForString();
<span class="line-modified">100     String toString(JSGlobalObject*, unsigned radix);</span>
101 
102     enum class ComparisonMode {
103         LessThan,
104         LessThanOrEqual
105     };
106 
107     enum class ComparisonResult {
108         Equal,
109         Undefined,
110         GreaterThan,
111         LessThan
112     };
113 
114     JS_EXPORT_PRIVATE static bool equals(JSBigInt*, JSBigInt*);
115     bool equalsToNumber(JSValue);
116     static ComparisonResult compare(JSBigInt* x, JSBigInt* y);
117 
<span class="line-modified">118     bool getPrimitiveNumber(JSGlobalObject*, double&amp; number, JSValue&amp; result) const;</span>
<span class="line-modified">119     double toNumber(JSGlobalObject*) const;</span>
120 
<span class="line-modified">121     JSObject* toObject(JSGlobalObject*) const;</span>
122     inline bool toBoolean() const { return !isZero(); }
123 
<span class="line-modified">124     static JSBigInt* exponentiate(JSGlobalObject*, JSBigInt* base, JSBigInt* exponent);</span>
125 
<span class="line-modified">126     static JSBigInt* multiply(JSGlobalObject*, JSBigInt* x, JSBigInt* y);</span>
127 
128     ComparisonResult static compareToDouble(JSBigInt* x, double y);
129 
<span class="line-modified">130     static JSBigInt* inc(JSGlobalObject*, JSBigInt* x);</span>
<span class="line-modified">131     static JSBigInt* dec(JSGlobalObject*, JSBigInt* x);</span>
<span class="line-modified">132     static JSBigInt* add(JSGlobalObject*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">133     static JSBigInt* sub(JSGlobalObject*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-added">134     static JSBigInt* divide(JSGlobalObject*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-added">135     static JSBigInt* remainder(JSGlobalObject*, JSBigInt* x, JSBigInt* y);</span>
136     static JSBigInt* unaryMinus(VM&amp;, JSBigInt* x);
137 
<span class="line-modified">138     static JSBigInt* bitwiseAnd(JSGlobalObject*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">139     static JSBigInt* bitwiseOr(JSGlobalObject*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">140     static JSBigInt* bitwiseXor(JSGlobalObject*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">141     static JSBigInt* bitwiseNot(JSGlobalObject*, JSBigInt* x);</span>
142 
<span class="line-modified">143     static JSBigInt* leftShift(JSGlobalObject*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">144     static JSBigInt* signedRightShift(JSGlobalObject*, JSBigInt* x, JSBigInt* y);</span>
145 
146 private:
<span class="line-added">147     JSBigInt(VM&amp;, Structure*, Digit*, unsigned length);</span>
148 

149     static constexpr unsigned bitsPerByte = 8;
150     static constexpr unsigned digitBits = sizeof(Digit) * bitsPerByte;
151     static constexpr unsigned halfDigitBits = digitBits / 2;
152     static constexpr Digit halfDigitMask = (1ull &lt;&lt; halfDigitBits) - 1;
153     static constexpr int maxInt = 0x7FFFFFFF;
154 
155     // The maximum length that the current implementation supports would be
156     // maxInt / digitBits. However, we use a lower limit for now, because
157     // raising it later is easier than lowering it.
158     // Support up to 1 million bits.
159     static constexpr unsigned maxLength = 1024 * 1024 / (sizeof(void*) * bitsPerByte);
160     static constexpr unsigned maxLengthBits = maxInt - sizeof(void*) * bitsPerByte - 1;
161 
162     static uint64_t calculateMaximumCharactersRequired(unsigned length, unsigned radix, Digit lastDigit, bool sign);
163 
164     static ComparisonResult absoluteCompare(JSBigInt* x, JSBigInt* y);
165     static void absoluteDivWithDigitDivisor(VM&amp;, JSBigInt* x, Digit divisor, JSBigInt** quotient, Digit&amp; remainder);
166     static void internalMultiplyAdd(JSBigInt* source, Digit factor, Digit summand, unsigned, JSBigInt* result);
167     static void multiplyAccumulate(JSBigInt* multiplicand, Digit multiplier, JSBigInt* accumulator, unsigned accumulatorIndex);
<span class="line-modified">168     static void absoluteDivWithBigIntDivisor(JSGlobalObject*, JSBigInt* dividend, JSBigInt* divisor, JSBigInt** quotient, JSBigInt** remainder);</span>
169 
170     enum class LeftShiftMode {
171         SameSizeResult,
172         AlwaysAddOneDigit
173     };
174 
<span class="line-modified">175     static JSBigInt* absoluteLeftShiftAlwaysCopy(JSGlobalObject*, JSBigInt* x, unsigned shift, LeftShiftMode);</span>
176     static bool productGreaterThan(Digit factor1, Digit factor2, Digit high, Digit low);
177 
178     Digit absoluteInplaceAdd(JSBigInt* summand, unsigned startIndex);
179     Digit absoluteInplaceSub(JSBigInt* subtrahend, unsigned startIndex);
180     void inplaceRightShift(unsigned shift);
181 
182     enum class ExtraDigitsHandling {
183         Copy,
184         Skip
185     };
186 
187     enum class SymmetricOp {
188         Symmetric,
189         NotSymmetric
190     };
191 
192     template&lt;typename BitwiseOp&gt;
193     static JSBigInt* absoluteBitwiseOp(VM&amp;, JSBigInt* x, JSBigInt* y, ExtraDigitsHandling, SymmetricOp, BitwiseOp&amp;&amp;);
194 
195     static JSBigInt* absoluteAnd(VM&amp;, JSBigInt* x, JSBigInt* y);
196     static JSBigInt* absoluteOr(VM&amp;, JSBigInt* x, JSBigInt* y);
197     static JSBigInt* absoluteAndNot(VM&amp;, JSBigInt* x, JSBigInt* y);
198     static JSBigInt* absoluteXor(VM&amp;, JSBigInt* x, JSBigInt* y);
199 
200     enum class SignOption {
201         Signed,
202         Unsigned
203     };
204 
<span class="line-modified">205     static JSBigInt* absoluteAddOne(JSGlobalObject*, JSBigInt* x, SignOption);</span>
<span class="line-modified">206     static JSBigInt* absoluteSubOne(JSGlobalObject*, JSBigInt* x, unsigned resultLength);</span>
207 
208     // Digit arithmetic helpers.
209     static Digit digitAdd(Digit a, Digit b, Digit&amp; carry);
210     static Digit digitSub(Digit a, Digit b, Digit&amp; borrow);
211     static Digit digitMul(Digit a, Digit b, Digit&amp; high);
212     static Digit digitDiv(Digit high, Digit low, Digit divisor, Digit&amp; remainder);
213     static Digit digitPow(Digit base, Digit exponent);
214 
<span class="line-modified">215     static String toStringBasePowerOfTwo(VM&amp;, JSGlobalObject*, JSBigInt*, unsigned radix);</span>
<span class="line-modified">216     static String toStringGeneric(VM&amp;, JSGlobalObject*, JSBigInt*, unsigned radix);</span>
217 
218     inline bool isZero() const
219     {
220         ASSERT(length() || !sign());
221         return length() == 0;
222     }
223 
224     template &lt;typename CharType&gt;
<span class="line-modified">225     static JSBigInt* parseInt(JSGlobalObject*, CharType*  data, unsigned length, ErrorParseMode);</span>
226 
227     template &lt;typename CharType&gt;
<span class="line-modified">228     static JSBigInt* parseInt(JSGlobalObject*, VM&amp;, CharType* data, unsigned length, unsigned startIndex, unsigned radix, ErrorParseMode, ParseIntSign = ParseIntSign::Signed, ParseIntMode = ParseIntMode::AllowEmptyString);</span>
229 
<span class="line-modified">230     static JSBigInt* allocateFor(JSGlobalObject*, VM&amp;, unsigned radix, unsigned charcount);</span>
231 
232     static JSBigInt* copy(VM&amp;, JSBigInt* x);
233     JSBigInt* rightTrim(VM&amp;);
234 
235     void inplaceMultiplyAdd(Digit multiplier, Digit part);
<span class="line-modified">236     static JSBigInt* absoluteAdd(JSGlobalObject*, JSBigInt* x, JSBigInt* y, bool resultSign);</span>
237     static JSBigInt* absoluteSub(VM&amp;, JSBigInt* x, JSBigInt* y, bool resultSign);
238 
<span class="line-modified">239     static JSBigInt* leftShiftByAbsolute(JSGlobalObject*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">240     static JSBigInt* rightShiftByAbsolute(JSGlobalObject*, JSBigInt* x, JSBigInt* y);</span>
241 
242     static JSBigInt* rightShiftByMaximum(VM&amp;, bool sign);
243 
244     static Optional&lt;Digit&gt; toShiftAmount(JSBigInt* x);
245 

246     inline static size_t offsetOfData()
247     {
<span class="line-modified">248         return OBJECT_OFFSETOF(JSBigInt, m_data);</span>
249     }
250 
<span class="line-modified">251     inline Digit* dataStorage() { return m_data.get(m_length); }</span>



252 
253     Digit digit(unsigned);
254     void setDigit(unsigned, Digit);
255 
256     const unsigned m_length;
257     bool m_sign { false };
<span class="line-added">258     CagedUniquePtr&lt;Gigacage::Primitive, Digit&gt; m_data;</span>
259 };
260 
261 inline JSBigInt* asBigInt(JSValue value)
262 {
263     ASSERT(value.asCell()-&gt;isBigInt());
264     return jsCast&lt;JSBigInt*&gt;(value.asCell());
265 }
266 
267 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="JSBigInt.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSBoundFunction.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
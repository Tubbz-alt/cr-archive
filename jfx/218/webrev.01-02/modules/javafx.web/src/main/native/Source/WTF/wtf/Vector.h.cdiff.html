<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WTF/wtf/Vector.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Variant.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VectorTraits.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/Vector.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  *  Copyright (C) 2005-2017 Apple Inc. All rights reserved.</span>
   *
   *  This library is free software; you can redistribute it and/or
   *  modify it under the terms of the GNU Library General Public
   *  License as published by the Free Software Foundation; either
   *  version 2 of the License, or (at your option) any later version.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  *  Copyright (C) 2005-2019 Apple Inc. All rights reserved.</span>
   *
   *  This library is free software; you can redistribute it and/or
   *  modify it under the terms of the GNU Library General Public
   *  License as published by the Free Software Foundation; either
   *  version 2 of the License, or (at your option) any later version.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 44,10 ***</span>
<span class="line-new-header">--- 44,12 ---</span>
  class LLIntOffsetsExtractor;
  }
  
  namespace WTF {
  
<span class="line-added">+ DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(Vector);</span>
<span class="line-added">+ </span>
  template &lt;bool needsDestruction, typename T&gt;
  struct VectorDestructor;
  
  template&lt;typename T&gt;
  struct VectorDestructor&lt;false, T&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 202,14 ***</span>
  struct VectorFiller&lt;true, T&gt;
  {
      static void uninitializedFill(T* dst, T* dstEnd, const T&amp; val)
      {
          static_assert(sizeof(T) == 1, &quot;Size of type T should be equal to one!&quot;);
<span class="line-modified">! #if COMPILER(GCC_COMPATIBLE) &amp;&amp; defined(_FORTIFY_SOURCE)</span>
<span class="line-removed">-         if (!__builtin_constant_p(dstEnd - dst) || (!(dstEnd - dst)))</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-             memset(dst, val, dstEnd - dst);</span>
      }
  };
  
  template&lt;bool canCompareWithMemcmp, typename T&gt;
  struct VectorComparer;
<span class="line-new-header">--- 204,11 ---</span>
  struct VectorFiller&lt;true, T&gt;
  {
      static void uninitializedFill(T* dst, T* dstEnd, const T&amp; val)
      {
          static_assert(sizeof(T) == 1, &quot;Size of type T should be equal to one!&quot;);
<span class="line-modified">!         memset(dst, val, dstEnd - dst);</span>
      }
  };
  
  template&lt;bool canCompareWithMemcmp, typename T&gt;
  struct VectorComparer;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 277,38 ***</span>
      {
          return VectorComparer&lt;VectorTraits&lt;T&gt;::canCompareWithMemcmp, T&gt;::compare(a, b, size);
      }
  };
  
<span class="line-modified">! template&lt;typename T&gt;</span>
  class VectorBufferBase {
      WTF_MAKE_NONCOPYABLE(VectorBufferBase);
  public:
      void allocateBuffer(size_t newCapacity)
      {
          ASSERT(newCapacity);
          if (newCapacity &gt; std::numeric_limits&lt;unsigned&gt;::max() / sizeof(T))
              CRASH();
          size_t sizeToAllocate = newCapacity * sizeof(T);
          m_capacity = sizeToAllocate / sizeof(T);
<span class="line-modified">!         m_buffer = static_cast&lt;T*&gt;(fastMalloc(sizeToAllocate));</span>
      }
  
      bool tryAllocateBuffer(size_t newCapacity)
      {
          ASSERT(newCapacity);
          if (newCapacity &gt; std::numeric_limits&lt;unsigned&gt;::max() / sizeof(T))
              return false;
  
          size_t sizeToAllocate = newCapacity * sizeof(T);
<span class="line-modified">!         T* newBuffer;</span>
<span class="line-modified">!         if (tryFastMalloc(sizeToAllocate).getValue(newBuffer)) {</span>
<span class="line-modified">!             m_capacity = sizeToAllocate / sizeof(T);</span>
<span class="line-modified">!             m_buffer = newBuffer;</span>
<span class="line-modified">!             return true;</span>
<span class="line-modified">!         }</span>
<span class="line-removed">-         return false;</span>
      }
  
      bool shouldReallocateBuffer(size_t newCapacity) const
      {
          return VectorTraits&lt;T&gt;::canMoveWithMemcpy &amp;&amp; m_capacity &amp;&amp; newCapacity;
<span class="line-new-header">--- 276,37 ---</span>
      {
          return VectorComparer&lt;VectorTraits&lt;T&gt;::canCompareWithMemcmp, T&gt;::compare(a, b, size);
      }
  };
  
<span class="line-modified">! template&lt;typename T, typename Malloc&gt;</span>
  class VectorBufferBase {
      WTF_MAKE_NONCOPYABLE(VectorBufferBase);
  public:
      void allocateBuffer(size_t newCapacity)
      {
          ASSERT(newCapacity);
          if (newCapacity &gt; std::numeric_limits&lt;unsigned&gt;::max() / sizeof(T))
              CRASH();
          size_t sizeToAllocate = newCapacity * sizeof(T);
          m_capacity = sizeToAllocate / sizeof(T);
<span class="line-modified">!         m_buffer = static_cast&lt;T*&gt;(Malloc::malloc(sizeToAllocate));</span>
      }
  
      bool tryAllocateBuffer(size_t newCapacity)
      {
          ASSERT(newCapacity);
          if (newCapacity &gt; std::numeric_limits&lt;unsigned&gt;::max() / sizeof(T))
              return false;
  
          size_t sizeToAllocate = newCapacity * sizeof(T);
<span class="line-modified">!         T* newBuffer = static_cast&lt;T*&gt;(Malloc::tryMalloc(sizeToAllocate));</span>
<span class="line-modified">!         if (!newBuffer)</span>
<span class="line-modified">!             return false;</span>
<span class="line-modified">!         m_capacity = sizeToAllocate / sizeof(T);</span>
<span class="line-modified">!         m_buffer = newBuffer;</span>
<span class="line-modified">!         return true;</span>
      }
  
      bool shouldReallocateBuffer(size_t newCapacity) const
      {
          return VectorTraits&lt;T&gt;::canMoveWithMemcpy &amp;&amp; m_capacity &amp;&amp; newCapacity;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 319,11 ***</span>
          ASSERT(shouldReallocateBuffer(newCapacity));
          if (newCapacity &gt; std::numeric_limits&lt;size_t&gt;::max() / sizeof(T))
              CRASH();
          size_t sizeToAllocate = newCapacity * sizeof(T);
          m_capacity = sizeToAllocate / sizeof(T);
<span class="line-modified">!         m_buffer = static_cast&lt;T*&gt;(fastRealloc(m_buffer, sizeToAllocate));</span>
      }
  
      void deallocateBuffer(T* bufferToDeallocate)
      {
          if (!bufferToDeallocate)
<span class="line-new-header">--- 317,11 ---</span>
          ASSERT(shouldReallocateBuffer(newCapacity));
          if (newCapacity &gt; std::numeric_limits&lt;size_t&gt;::max() / sizeof(T))
              CRASH();
          size_t sizeToAllocate = newCapacity * sizeof(T);
          m_capacity = sizeToAllocate / sizeof(T);
<span class="line-modified">!         m_buffer = static_cast&lt;T*&gt;(Malloc::realloc(m_buffer, sizeToAllocate));</span>
      }
  
      void deallocateBuffer(T* bufferToDeallocate)
      {
          if (!bufferToDeallocate)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 332,24 ***</span>
          if (m_buffer == bufferToDeallocate) {
              m_buffer = 0;
              m_capacity = 0;
          }
  
<span class="line-modified">!         fastFree(bufferToDeallocate);</span>
      }
  
      T* buffer() { return m_buffer; }
      const T* buffer() const { return m_buffer; }
      static ptrdiff_t bufferMemoryOffset() { return OBJECT_OFFSETOF(VectorBufferBase, m_buffer); }
      size_t capacity() const { return m_capacity; }
  
<span class="line-modified">!     MallocPtr&lt;T&gt; releaseBuffer()</span>
      {
          T* buffer = m_buffer;
          m_buffer = 0;
          m_capacity = 0;
<span class="line-modified">!         return adoptMallocPtr(buffer);</span>
      }
  
  protected:
      VectorBufferBase()
          : m_buffer(0)
<span class="line-new-header">--- 330,24 ---</span>
          if (m_buffer == bufferToDeallocate) {
              m_buffer = 0;
              m_capacity = 0;
          }
  
<span class="line-modified">!         Malloc::free(bufferToDeallocate);</span>
      }
  
      T* buffer() { return m_buffer; }
      const T* buffer() const { return m_buffer; }
      static ptrdiff_t bufferMemoryOffset() { return OBJECT_OFFSETOF(VectorBufferBase, m_buffer); }
      size_t capacity() const { return m_capacity; }
  
<span class="line-modified">!     MallocPtr&lt;T, Malloc&gt; releaseBuffer()</span>
      {
          T* buffer = m_buffer;
          m_buffer = 0;
          m_capacity = 0;
<span class="line-modified">!         return adoptMallocPtr&lt;T, Malloc&gt;(buffer);</span>
      }
  
  protected:
      VectorBufferBase()
          : m_buffer(0)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 373,17 ***</span>
      T* m_buffer;
      unsigned m_capacity;
      unsigned m_size; // Only used by the Vector subclass, but placed here to avoid padding the struct.
  };
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity&gt;</span>
<span class="line-removed">- class VectorBuffer;</span>
  
<span class="line-modified">! template&lt;typename T&gt;</span>
<span class="line-modified">! class VectorBuffer&lt;T, 0&gt; : private VectorBufferBase&lt;T&gt; {</span>
  private:
<span class="line-modified">!     typedef VectorBufferBase&lt;T&gt; Base;</span>
  public:
      VectorBuffer()
      {
      }
  
<span class="line-new-header">--- 371,16 ---</span>
      T* m_buffer;
      unsigned m_capacity;
      unsigned m_size; // Only used by the Vector subclass, but placed here to avoid padding the struct.
  };
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename Malloc = VectorMalloc&gt; class VectorBuffer;</span>
  
<span class="line-modified">! template&lt;typename T, typename Malloc&gt;</span>
<span class="line-modified">! class VectorBuffer&lt;T, 0, Malloc&gt; : private VectorBufferBase&lt;T, Malloc&gt; {</span>
  private:
<span class="line-modified">!     typedef VectorBufferBase&lt;T, Malloc&gt; Base;</span>
  public:
      VectorBuffer()
      {
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 399,11 ***</span>
      ~VectorBuffer()
      {
          deallocateBuffer(buffer());
      }
  
<span class="line-modified">!     void swap(VectorBuffer&lt;T, 0&gt;&amp; other, size_t, size_t)</span>
      {
          std::swap(m_buffer, other.m_buffer);
          std::swap(m_capacity, other.m_capacity);
      }
  
<span class="line-new-header">--- 396,11 ---</span>
      ~VectorBuffer()
      {
          deallocateBuffer(buffer());
      }
  
<span class="line-modified">!     void swap(VectorBuffer&lt;T, 0, Malloc&gt;&amp; other, size_t, size_t)</span>
      {
          std::swap(m_buffer, other.m_buffer);
          std::swap(m_capacity, other.m_capacity);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 435,15 ***</span>
      friend class JSC::LLIntOffsetsExtractor;
      using Base::m_buffer;
      using Base::m_capacity;
  };
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity&gt;</span>
<span class="line-modified">! class VectorBuffer : private VectorBufferBase&lt;T&gt; {</span>
      WTF_MAKE_NONCOPYABLE(VectorBuffer);
  private:
<span class="line-modified">!     typedef VectorBufferBase&lt;T&gt; Base;</span>
  public:
      VectorBuffer()
          : Base(inlineBuffer(), inlineCapacity, 0)
      {
      }
<span class="line-new-header">--- 432,15 ---</span>
      friend class JSC::LLIntOffsetsExtractor;
      using Base::m_buffer;
      using Base::m_capacity;
  };
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename Malloc&gt;</span>
<span class="line-modified">! class VectorBuffer : private VectorBufferBase&lt;T, Malloc&gt; {</span>
      WTF_MAKE_NONCOPYABLE(VectorBuffer);
  private:
<span class="line-modified">!     typedef VectorBufferBase&lt;T, Malloc&gt; Base;</span>
  public:
      VectorBuffer()
          : Base(inlineBuffer(), inlineCapacity, 0)
      {
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 546,14 ***</span>
  
      using Base::buffer;
      using Base::capacity;
      using Base::bufferMemoryOffset;
  
<span class="line-modified">!     MallocPtr&lt;T&gt; releaseBuffer()</span>
      {
          if (buffer() == inlineBuffer())
<span class="line-modified">!             return nullptr;</span>
          return Base::releaseBuffer();
      }
  
  protected:
      using Base::m_size;
<span class="line-new-header">--- 543,14 ---</span>
  
      using Base::buffer;
      using Base::capacity;
      using Base::bufferMemoryOffset;
  
<span class="line-modified">!     MallocPtr&lt;T, Malloc&gt; releaseBuffer()</span>
      {
          if (buffer() == inlineBuffer())
<span class="line-modified">!             return { };</span>
          return Base::releaseBuffer();
      }
  
  protected:
      using Base::m_size;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 588,12 ***</span>
      const T* inlineBuffer() const { return reinterpret_cast_ptr&lt;const T*&gt;(m_inlineBuffer); }
  
  #if ASAN_ENABLED
      // ASan needs the buffer to begin and end on 8-byte boundaries for annotations to work.
      // FIXME: Add a redzone before the buffer to catch off by one accesses. We don&#39;t need a guard after, because the buffer is the last member variable.
<span class="line-modified">!     static const size_t asanInlineBufferAlignment = std::alignment_of&lt;T&gt;::value &gt;= 8 ? std::alignment_of&lt;T&gt;::value : 8;</span>
<span class="line-modified">!     static const size_t asanAdjustedInlineCapacity = ((sizeof(T) * inlineCapacity + 7) &amp; ~7) / sizeof(T);</span>
      typename std::aligned_storage&lt;sizeof(T), asanInlineBufferAlignment&gt;::type m_inlineBuffer[asanAdjustedInlineCapacity];
  #else
      typename std::aligned_storage&lt;sizeof(T), std::alignment_of&lt;T&gt;::value&gt;::type m_inlineBuffer[inlineCapacity];
  #endif
  };
<span class="line-new-header">--- 585,12 ---</span>
      const T* inlineBuffer() const { return reinterpret_cast_ptr&lt;const T*&gt;(m_inlineBuffer); }
  
  #if ASAN_ENABLED
      // ASan needs the buffer to begin and end on 8-byte boundaries for annotations to work.
      // FIXME: Add a redzone before the buffer to catch off by one accesses. We don&#39;t need a guard after, because the buffer is the last member variable.
<span class="line-modified">!     static constexpr size_t asanInlineBufferAlignment = std::alignment_of&lt;T&gt;::value &gt;= 8 ? std::alignment_of&lt;T&gt;::value : 8;</span>
<span class="line-modified">!     static constexpr size_t asanAdjustedInlineCapacity = ((sizeof(T) * inlineCapacity + 7) &amp; ~7) / sizeof(T);</span>
      typename std::aligned_storage&lt;sizeof(T), asanInlineBufferAlignment&gt;::type m_inlineBuffer[asanAdjustedInlineCapacity];
  #else
      typename std::aligned_storage&lt;sizeof(T), std::alignment_of&lt;T&gt;::value&gt;::type m_inlineBuffer[inlineCapacity];
  #endif
  };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 604,15 ***</span>
          ASSERT_NOT_REACHED();
      }
  };
  
  // Template default values are in Forward.h.
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! class Vector : private VectorBuffer&lt;T, inlineCapacity&gt; {</span>
      WTF_MAKE_FAST_ALLOCATED;
  private:
<span class="line-modified">!     typedef VectorBuffer&lt;T, inlineCapacity&gt; Base;</span>
      typedef VectorTypeOperations&lt;T&gt; TypeOperations;
      friend class JSC::LLIntOffsetsExtractor;
  
  public:
      typedef T ValueType;
<span class="line-new-header">--- 601,15 ---</span>
          ASSERT_NOT_REACHED();
      }
  };
  
  // Template default values are in Forward.h.
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! class Vector : private VectorBuffer&lt;T, inlineCapacity, Malloc&gt; {</span>
      WTF_MAKE_FAST_ALLOCATED;
  private:
<span class="line-modified">!     typedef VectorBuffer&lt;T, inlineCapacity, Malloc&gt; Base;</span>
      typedef VectorTypeOperations&lt;T&gt; TypeOperations;
      friend class JSC::LLIntOffsetsExtractor;
  
  public:
      typedef T ValueType;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 667,25 ***</span>
  
          result.uncheckedInitialize&lt;0&gt;(std::forward&lt;Items&gt;(items)...);
          return result;
      }
  
      ~Vector()
      {
          if (m_size)
              TypeOperations::destruct(begin(), end());
  
          asanSetBufferSizeToFullCapacity(0);
      }
  
      Vector(const Vector&amp;);
<span class="line-modified">!     template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity&gt;</span>
<span class="line-modified">!     explicit Vector(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity&gt;&amp;);</span>
  
      Vector&amp; operator=(const Vector&amp;);
<span class="line-modified">!     template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity&gt;</span>
<span class="line-modified">!     Vector&amp; operator=(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity&gt;&amp;);</span>
  
      Vector(Vector&amp;&amp;);
      Vector&amp; operator=(Vector&amp;&amp;);
  
      size_t size() const { return m_size; }
<span class="line-new-header">--- 664,30 ---</span>
  
          result.uncheckedInitialize&lt;0&gt;(std::forward&lt;Items&gt;(items)...);
          return result;
      }
  
<span class="line-added">+     Vector(WTF::HashTableDeletedValueType)</span>
<span class="line-added">+         : Base(0, std::numeric_limits&lt;decltype(m_size)&gt;::max())</span>
<span class="line-added">+     {</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      ~Vector()
      {
          if (m_size)
              TypeOperations::destruct(begin(), end());
  
          asanSetBufferSizeToFullCapacity(0);
      }
  
      Vector(const Vector&amp;);
<span class="line-modified">!     template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;</span>
<span class="line-modified">!     explicit Vector(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp;);</span>
  
      Vector&amp; operator=(const Vector&amp;);
<span class="line-modified">!     template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;</span>
<span class="line-modified">!     Vector&amp; operator=(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp;);</span>
  
      Vector(Vector&amp;&amp;);
      Vector&amp; operator=(Vector&amp;&amp;);
  
      size_t size() const { return m_size; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 777,15 ***</span>
      template&lt;typename U&gt; void uncheckedAppend(U&amp;&amp;);
      template&lt;typename... Args&gt; void uncheckedConstructAndAppend(Args&amp;&amp;...);
  
      template&lt;typename U&gt; void append(const U*, size_t);
      template&lt;typename U, size_t otherCapacity&gt; void appendVector(const Vector&lt;U, otherCapacity&gt;&amp;);
      template&lt;typename U&gt; bool tryAppend(const U*, size_t);
  
      template&lt;typename U&gt; void insert(size_t position, const U*, size_t);
      template&lt;typename U&gt; void insert(size_t position, U&amp;&amp;);
<span class="line-modified">!     template&lt;typename U, size_t c, typename OH&gt; void insertVector(size_t position, const Vector&lt;U, c, OH&gt;&amp;);</span>
  
      void remove(size_t position);
      void remove(size_t position, size_t length);
      template&lt;typename U&gt; bool removeFirst(const U&amp;);
      template&lt;typename MatchFunction&gt; bool removeFirstMatching(const MatchFunction&amp;, size_t startIndex = 0);
<span class="line-new-header">--- 779,16 ---</span>
      template&lt;typename U&gt; void uncheckedAppend(U&amp;&amp;);
      template&lt;typename... Args&gt; void uncheckedConstructAndAppend(Args&amp;&amp;...);
  
      template&lt;typename U&gt; void append(const U*, size_t);
      template&lt;typename U, size_t otherCapacity&gt; void appendVector(const Vector&lt;U, otherCapacity&gt;&amp;);
<span class="line-added">+     template&lt;typename U, size_t otherCapacity&gt; void appendVector(Vector&lt;U, otherCapacity&gt;&amp;&amp;);</span>
      template&lt;typename U&gt; bool tryAppend(const U*, size_t);
  
      template&lt;typename U&gt; void insert(size_t position, const U*, size_t);
      template&lt;typename U&gt; void insert(size_t position, U&amp;&amp;);
<span class="line-modified">!     template&lt;typename U, size_t c, typename OH, size_t m, typename M&gt; void insertVector(size_t position, const Vector&lt;U, c, OH, m, M&gt;&amp;);</span>
  
      void remove(size_t position);
      void remove(size_t position, size_t length);
      template&lt;typename U&gt; bool removeFirst(const U&amp;);
      template&lt;typename MatchFunction&gt; bool removeFirstMatching(const MatchFunction&amp;, size_t startIndex = 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 802,13 ***</span>
      void fill(const T&amp;, size_t);
      void fill(const T&amp; val) { fill(val, size()); }
  
      template&lt;typename Iterator&gt; void appendRange(Iterator start, Iterator end);
  
<span class="line-modified">!     MallocPtr&lt;T&gt; releaseBuffer();</span>
  
<span class="line-modified">!     void swap(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; other)</span>
      {
  #if ASAN_ENABLED
          if (this == std::addressof(other)) // ASan will crash if we try to restrict access to the same buffer twice.
              return;
  #endif
<span class="line-new-header">--- 805,13 ---</span>
      void fill(const T&amp;, size_t);
      void fill(const T&amp; val) { fill(val, size()); }
  
      template&lt;typename Iterator&gt; void appendRange(Iterator start, Iterator end);
  
<span class="line-modified">!     MallocPtr&lt;T, Malloc&gt; releaseBuffer();</span>
  
<span class="line-modified">!     void swap(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; other)</span>
      {
  #if ASAN_ENABLED
          if (this == std::addressof(other)) // ASan will crash if we try to restrict access to the same buffer twice.
              return;
  #endif
</pre>
<hr />
<pre>
<span class="line-old-header">*** 828,10 ***</span>
<span class="line-new-header">--- 831,12 ---</span>
  
      void checkConsistency();
  
      template&lt;typename MapFunction, typename R = typename std::result_of&lt;MapFunction(const T&amp;)&gt;::type&gt; Vector&lt;R&gt; map(MapFunction) const;
  
<span class="line-added">+     bool isHashTableDeletedValue() const { return m_size == std::numeric_limits&lt;decltype(m_size)&gt;::max(); }</span>
<span class="line-added">+ </span>
  private:
      void expandCapacity(size_t newMinCapacity);
      T* expandCapacity(size_t newMinCapacity, T*);
      bool tryExpandCapacity(size_t newMinCapacity);
      const T* tryExpandCapacity(size_t newMinCapacity, const T*);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 874,33 ***</span>
  #if ASAN_ENABLED
      using Base::endOfBuffer;
  #endif
  };
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::Vector(const Vector&amp; other)</span>
      : Base(other.capacity(), other.size())
  {
      asanSetInitialBufferSizeTo(other.size());
  
      if (begin())
          TypeOperations::uninitializedCopy(other.begin(), other.end(), begin());
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity&gt;</span>
<span class="line-modified">! Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::Vector(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity&gt;&amp; other)</span>
      : Base(other.capacity(), other.size())
  {
      asanSetInitialBufferSizeTo(other.size());
  
      if (begin())
          TypeOperations::uninitializedCopy(other.begin(), other.end(), begin());
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::operator=(const Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; other)</span>
  {
      if (&amp;other == this)
          return *this;
  
      if (size() &gt; other.size())
<span class="line-new-header">--- 879,33 ---</span>
  #if ASAN_ENABLED
      using Base::endOfBuffer;
  #endif
  };
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::Vector(const Vector&amp; other)</span>
      : Base(other.capacity(), other.size())
  {
      asanSetInitialBufferSizeTo(other.size());
  
      if (begin())
          TypeOperations::uninitializedCopy(other.begin(), other.end(), begin());
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;</span>
<span class="line-modified">! Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::Vector(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp; other)</span>
      : Base(other.capacity(), other.size())
  {
      asanSetInitialBufferSizeTo(other.size());
  
      if (begin())
          TypeOperations::uninitializedCopy(other.begin(), other.end(), begin());
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::operator=(const Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; other)</span>
  {
      if (&amp;other == this)
          return *this;
  
      if (size() &gt; other.size())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 920,13 ***</span>
      return *this;
  }
  
  inline bool typelessPointersAreEqual(const void* a, const void* b) { return a == b; }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity&gt;</span>
<span class="line-modified">! Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::operator=(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity&gt;&amp; other)</span>
  {
      // If the inline capacities match, we should call the more specific
      // template.  If the inline capacities don&#39;t match, the two objects
      // shouldn&#39;t be allocated the same address.
      ASSERT(!typelessPointersAreEqual(&amp;other, this));
<span class="line-new-header">--- 925,13 ---</span>
      return *this;
  }
  
  inline bool typelessPointersAreEqual(const void* a, const void* b) { return a == b; }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;</span>
<span class="line-modified">! Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::operator=(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp; other)</span>
  {
      // If the inline capacities match, we should call the more specific
      // template.  If the inline capacities don&#39;t match, the two objects
      // shouldn&#39;t be allocated the same address.
      ASSERT(!typelessPointersAreEqual(&amp;other, this));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 946,74 ***</span>
      m_size = other.size();
  
      return *this;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! inline Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::Vector(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp;&amp; other)</span>
  {
      swap(other);
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! inline Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::operator=(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp;&amp; other)</span>
  {
      swap(other);
      return *this;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::contains(const U&amp; value) const</span>
  {
      return find(value) != notFound;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename MatchFunction&gt;
<span class="line-modified">! size_t Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::findMatching(const MatchFunction&amp; matches) const</span>
  {
      for (size_t i = 0; i &lt; size(); ++i) {
          if (matches(at(i)))
              return i;
      }
      return notFound;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! size_t Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::find(const U&amp; value) const</span>
  {
      return findMatching([&amp;](auto&amp; item) {
          return item == value;
      });
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! size_t Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::reverseFind(const U&amp; value) const</span>
  {
      for (size_t i = 1; i &lt;= size(); ++i) {
          const size_t index = size() - i;
          if (at(index) == value)
              return index;
      }
      return notFound;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::appendIfNotContains(const U&amp; value)</span>
  {
      if (contains(value))
          return false;
      append(value);
      return true;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::fill(const T&amp; val, size_t newSize)</span>
  {
      if (size() &gt; newSize)
          shrink(newSize);
      else if (newSize &gt; capacity()) {
          clear();
<span class="line-new-header">--- 951,74 ---</span>
      m_size = other.size();
  
      return *this;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! inline Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::Vector(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp;&amp; other)</span>
  {
      swap(other);
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! inline Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::operator=(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp;&amp; other)</span>
  {
      swap(other);
      return *this;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::contains(const U&amp; value) const</span>
  {
      return find(value) != notFound;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename MatchFunction&gt;
<span class="line-modified">! size_t Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::findMatching(const MatchFunction&amp; matches) const</span>
  {
      for (size_t i = 0; i &lt; size(); ++i) {
          if (matches(at(i)))
              return i;
      }
      return notFound;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! size_t Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::find(const U&amp; value) const</span>
  {
      return findMatching([&amp;](auto&amp; item) {
          return item == value;
      });
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! size_t Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::reverseFind(const U&amp; value) const</span>
  {
      for (size_t i = 1; i &lt;= size(); ++i) {
          const size_t index = size() - i;
          if (at(index) == value)
              return index;
      }
      return notFound;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::appendIfNotContains(const U&amp; value)</span>
  {
      if (contains(value))
          return false;
      append(value);
      return true;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::fill(const T&amp; val, size_t newSize)</span>
  {
      if (size() &gt; newSize)
          shrink(newSize);
      else if (newSize &gt; capacity()) {
          clear();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1026,44 ***</span>
      std::fill(begin(), end(), val);
      TypeOperations::uninitializedFill(end(), begin() + newSize, val);
      m_size = newSize;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename Iterator&gt;
<span class="line-modified">! void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::appendRange(Iterator start, Iterator end)</span>
  {
      for (Iterator it = start; it != end; ++it)
          append(*it);
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::expandCapacity(size_t newMinCapacity)</span>
  {
      reserveCapacity(std::max(newMinCapacity, std::max(static_cast&lt;size_t&gt;(minCapacity), capacity() + capacity() / 4 + 1)));
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! NEVER_INLINE T* Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::expandCapacity(size_t newMinCapacity, T* ptr)</span>
  {
      if (ptr &lt; begin() || ptr &gt;= end()) {
          expandCapacity(newMinCapacity);
          return ptr;
      }
      size_t index = ptr - begin();
      expandCapacity(newMinCapacity);
      return begin() + index;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::tryExpandCapacity(size_t newMinCapacity)</span>
  {
      return tryReserveCapacity(std::max(newMinCapacity, std::max(static_cast&lt;size_t&gt;(minCapacity), capacity() + capacity() / 4 + 1)));
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! const T* Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::tryExpandCapacity(size_t newMinCapacity, const T* ptr)</span>
  {
      if (ptr &lt; begin() || ptr &gt;= end()) {
          if (!tryExpandCapacity(newMinCapacity))
              return 0;
          return ptr;
<span class="line-new-header">--- 1031,44 ---</span>
      std::fill(begin(), end(), val);
      TypeOperations::uninitializedFill(end(), begin() + newSize, val);
      m_size = newSize;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename Iterator&gt;
<span class="line-modified">! void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::appendRange(Iterator start, Iterator end)</span>
  {
      for (Iterator it = start; it != end; ++it)
          append(*it);
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::expandCapacity(size_t newMinCapacity)</span>
  {
      reserveCapacity(std::max(newMinCapacity, std::max(static_cast&lt;size_t&gt;(minCapacity), capacity() + capacity() / 4 + 1)));
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! NEVER_INLINE T* Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::expandCapacity(size_t newMinCapacity, T* ptr)</span>
  {
      if (ptr &lt; begin() || ptr &gt;= end()) {
          expandCapacity(newMinCapacity);
          return ptr;
      }
      size_t index = ptr - begin();
      expandCapacity(newMinCapacity);
      return begin() + index;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::tryExpandCapacity(size_t newMinCapacity)</span>
  {
      return tryReserveCapacity(std::max(newMinCapacity, std::max(static_cast&lt;size_t&gt;(minCapacity), capacity() + capacity() / 4 + 1)));
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! const T* Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::tryExpandCapacity(size_t newMinCapacity, const T* ptr)</span>
  {
      if (ptr &lt; begin() || ptr &gt;= end()) {
          if (!tryExpandCapacity(newMinCapacity))
              return 0;
          return ptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1072,20 ***</span>
      if (!tryExpandCapacity(newMinCapacity))
          return 0;
      return begin() + index;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! inline U* Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::expandCapacity(size_t newMinCapacity, U* ptr)</span>
  {
      expandCapacity(newMinCapacity);
      return ptr;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::resize(size_t size)</span>
  {
      if (size &lt;= m_size) {
          TypeOperations::destruct(begin() + size, end());
          asanBufferSizeWillChangeTo(size);
      } else {
<span class="line-new-header">--- 1077,20 ---</span>
      if (!tryExpandCapacity(newMinCapacity))
          return 0;
      return begin() + index;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! inline U* Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::expandCapacity(size_t newMinCapacity, U* ptr)</span>
  {
      expandCapacity(newMinCapacity);
      return ptr;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::resize(size_t size)</span>
  {
      if (size &lt;= m_size) {
          TypeOperations::destruct(begin() + size, end());
          asanBufferSizeWillChangeTo(size);
      } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1097,40 ***</span>
      }
  
      m_size = size;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::resizeToFit(size_t size)</span>
  {
      reserveCapacity(size);
      resize(size);
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::shrink(size_t size)</span>
  {
      ASSERT(size &lt;= m_size);
      TypeOperations::destruct(begin() + size, end());
      asanBufferSizeWillChangeTo(size);
      m_size = size;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::grow(size_t size)</span>
  {
      ASSERT(size &gt;= m_size);
      if (size &gt; capacity())
          expandCapacity(size);
      asanBufferSizeWillChangeTo(size);
      if (begin())
          TypeOperations::initializeIfNonPOD(end(), begin() + size);
      m_size = size;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::asanSetInitialBufferSizeTo(size_t size)</span>
  {
  #if ASAN_ENABLED
      if (!buffer())
          return;
  
<span class="line-new-header">--- 1102,40 ---</span>
      }
  
      m_size = size;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::resizeToFit(size_t size)</span>
  {
      reserveCapacity(size);
      resize(size);
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::shrink(size_t size)</span>
  {
      ASSERT(size &lt;= m_size);
      TypeOperations::destruct(begin() + size, end());
      asanBufferSizeWillChangeTo(size);
      m_size = size;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::grow(size_t size)</span>
  {
      ASSERT(size &gt;= m_size);
      if (size &gt; capacity())
          expandCapacity(size);
      asanBufferSizeWillChangeTo(size);
      if (begin())
          TypeOperations::initializeIfNonPOD(end(), begin() + size);
      m_size = size;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::asanSetInitialBufferSizeTo(size_t size)</span>
  {
  #if ASAN_ENABLED
      if (!buffer())
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1141,12 ***</span>
  #else
      UNUSED_PARAM(size);
  #endif
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::asanSetBufferSizeToFullCapacity(size_t size)</span>
  {
  #if ASAN_ENABLED
      if (!buffer())
          return;
  
<span class="line-new-header">--- 1146,12 ---</span>
  #else
      UNUSED_PARAM(size);
  #endif
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::asanSetBufferSizeToFullCapacity(size_t size)</span>
  {
  #if ASAN_ENABLED
      if (!buffer())
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1155,12 ***</span>
  #else
      UNUSED_PARAM(size);
  #endif
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::asanBufferSizeWillChangeTo(size_t newSize)</span>
  {
  #if ASAN_ENABLED
      if (!buffer())
          return;
  
<span class="line-new-header">--- 1160,12 ---</span>
  #else
      UNUSED_PARAM(size);
  #endif
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::asanBufferSizeWillChangeTo(size_t newSize)</span>
  {
  #if ASAN_ENABLED
      if (!buffer())
          return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1169,12 ***</span>
  #else
      UNUSED_PARAM(newSize);
  #endif
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::reserveCapacity(size_t newCapacity)</span>
  {
      if (newCapacity &lt;= capacity())
          return;
      T* oldBuffer = begin();
      T* oldEnd = end();
<span class="line-new-header">--- 1174,12 ---</span>
  #else
      UNUSED_PARAM(newSize);
  #endif
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::reserveCapacity(size_t newCapacity)</span>
  {
      if (newCapacity &lt;= capacity())
          return;
      T* oldBuffer = begin();
      T* oldEnd = end();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1188,12 ***</span>
  
      TypeOperations::move(oldBuffer, oldEnd, begin());
      Base::deallocateBuffer(oldBuffer);
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::tryReserveCapacity(size_t newCapacity)</span>
  {
      if (newCapacity &lt;= capacity())
          return true;
      T* oldBuffer = begin();
      T* oldEnd = end();
<span class="line-new-header">--- 1193,12 ---</span>
  
      TypeOperations::move(oldBuffer, oldEnd, begin());
      Base::deallocateBuffer(oldBuffer);
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::tryReserveCapacity(size_t newCapacity)</span>
  {
      if (newCapacity &lt;= capacity())
          return true;
      T* oldBuffer = begin();
      T* oldEnd = end();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1211,21 ***</span>
      TypeOperations::move(oldBuffer, oldEnd, begin());
      Base::deallocateBuffer(oldBuffer);
      return true;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::reserveInitialCapacity(size_t initialCapacity)</span>
  {
      ASSERT(!m_size);
      ASSERT(capacity() == inlineCapacity);
      if (initialCapacity &gt; inlineCapacity)
          Base::allocateBuffer(initialCapacity);
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::shrinkCapacity(size_t newCapacity)</span>
  {
      if (newCapacity &gt;= capacity())
          return;
  
      if (newCapacity &lt; size())
<span class="line-new-header">--- 1216,21 ---</span>
      TypeOperations::move(oldBuffer, oldEnd, begin());
      Base::deallocateBuffer(oldBuffer);
      return true;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::reserveInitialCapacity(size_t initialCapacity)</span>
  {
      ASSERT(!m_size);
      ASSERT(capacity() == inlineCapacity);
      if (initialCapacity &gt; inlineCapacity)
          Base::allocateBuffer(initialCapacity);
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::shrinkCapacity(size_t newCapacity)</span>
  {
      if (newCapacity &gt;= capacity())
          return;
  
      if (newCapacity &lt; size())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1251,13 ***</span>
      Base::restoreInlineBufferIfNeeded();
  
      asanSetInitialBufferSizeTo(size());
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::append(const U* data, size_t dataSize)</span>
  {
      size_t newSize = m_size + dataSize;
      if (newSize &gt; capacity()) {
          data = expandCapacity(newSize, data);
          ASSERT(begin());
<span class="line-new-header">--- 1256,13 ---</span>
      Base::restoreInlineBufferIfNeeded();
  
      asanSetInitialBufferSizeTo(size());
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::append(const U* data, size_t dataSize)</span>
  {
      size_t newSize = m_size + dataSize;
      if (newSize &gt; capacity()) {
          data = expandCapacity(newSize, data);
          ASSERT(begin());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1268,13 ***</span>
      T* dest = end();
      VectorCopier&lt;std::is_trivial&lt;T&gt;::value, U&gt;::uninitializedCopy(data, std::addressof(data[dataSize]), dest);
      m_size = newSize;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! ALWAYS_INLINE bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::tryAppend(const U* data, size_t dataSize)</span>
  {
      size_t newSize = m_size + dataSize;
      if (newSize &gt; capacity()) {
          data = tryExpandCapacity(newSize, data);
          if (!data)
<span class="line-new-header">--- 1273,13 ---</span>
      T* dest = end();
      VectorCopier&lt;std::is_trivial&lt;T&gt;::value, U&gt;::uninitializedCopy(data, std::addressof(data[dataSize]), dest);
      m_size = newSize;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! ALWAYS_INLINE bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::tryAppend(const U* data, size_t dataSize)</span>
  {
      size_t newSize = m_size + dataSize;
      if (newSize &gt; capacity()) {
          data = tryExpandCapacity(newSize, data);
          if (!data)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1288,13 ***</span>
      VectorCopier&lt;std::is_trivial&lt;T&gt;::value, U&gt;::uninitializedCopy(data, std::addressof(data[dataSize]), dest);
      m_size = newSize;
      return true;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::append(U&amp;&amp; value)</span>
  {
      if (size() != capacity()) {
          asanBufferSizeWillChangeTo(m_size + 1);
          new (NotNull, end()) T(std::forward&lt;U&gt;(value));
          ++m_size;
<span class="line-new-header">--- 1293,13 ---</span>
      VectorCopier&lt;std::is_trivial&lt;T&gt;::value, U&gt;::uninitializedCopy(data, std::addressof(data[dataSize]), dest);
      m_size = newSize;
      return true;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::append(U&amp;&amp; value)</span>
  {
      if (size() != capacity()) {
          asanBufferSizeWillChangeTo(m_size + 1);
          new (NotNull, end()) T(std::forward&lt;U&gt;(value));
          ++m_size;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1302,13 ***</span>
      }
  
      appendSlowCase(std::forward&lt;U&gt;(value));
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename... Args&gt;
<span class="line-modified">! ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::constructAndAppend(Args&amp;&amp;... args)</span>
  {
      if (size() != capacity()) {
          asanBufferSizeWillChangeTo(m_size + 1);
          new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
          ++m_size;
<span class="line-new-header">--- 1307,13 ---</span>
      }
  
      appendSlowCase(std::forward&lt;U&gt;(value));
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename... Args&gt;
<span class="line-modified">! ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::constructAndAppend(Args&amp;&amp;... args)</span>
  {
      if (size() != capacity()) {
          asanBufferSizeWillChangeTo(m_size + 1);
          new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
          ++m_size;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1316,13 ***</span>
      }
  
      constructAndAppendSlowCase(std::forward&lt;Args&gt;(args)...);
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename... Args&gt;
<span class="line-modified">! ALWAYS_INLINE bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::tryConstructAndAppend(Args&amp;&amp;... args)</span>
  {
      if (size() != capacity()) {
          asanBufferSizeWillChangeTo(m_size + 1);
          new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
          ++m_size;
<span class="line-new-header">--- 1321,13 ---</span>
      }
  
      constructAndAppendSlowCase(std::forward&lt;Args&gt;(args)...);
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename... Args&gt;
<span class="line-modified">! ALWAYS_INLINE bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::tryConstructAndAppend(Args&amp;&amp;... args)</span>
  {
      if (size() != capacity()) {
          asanBufferSizeWillChangeTo(m_size + 1);
          new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
          ++m_size;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1330,13 ***</span>
      }
  
      return tryConstructAndAppendSlowCase(std::forward&lt;Args&gt;(args)...);
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::appendSlowCase(U&amp;&amp; value)</span>
  {
      ASSERT(size() == capacity());
  
      auto ptr = const_cast&lt;typename std::remove_const&lt;typename std::remove_reference&lt;U&gt;::type&gt;::type*&gt;(std::addressof(value));
      ptr = expandCapacity(size() + 1, ptr);
<span class="line-new-header">--- 1335,13 ---</span>
      }
  
      return tryConstructAndAppendSlowCase(std::forward&lt;Args&gt;(args)...);
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::appendSlowCase(U&amp;&amp; value)</span>
  {
      ASSERT(size() == capacity());
  
      auto ptr = const_cast&lt;typename std::remove_const&lt;typename std::remove_reference&lt;U&gt;::type&gt;::type*&gt;(std::addressof(value));
      ptr = expandCapacity(size() + 1, ptr);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1345,13 ***</span>
      asanBufferSizeWillChangeTo(m_size + 1);
      new (NotNull, end()) T(std::forward&lt;U&gt;(*ptr));
      ++m_size;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename... Args&gt;
<span class="line-modified">! void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::constructAndAppendSlowCase(Args&amp;&amp;... args)</span>
  {
      ASSERT(size() == capacity());
  
      expandCapacity(size() + 1);
      ASSERT(begin());
<span class="line-new-header">--- 1350,13 ---</span>
      asanBufferSizeWillChangeTo(m_size + 1);
      new (NotNull, end()) T(std::forward&lt;U&gt;(*ptr));
      ++m_size;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename... Args&gt;
<span class="line-modified">! void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::constructAndAppendSlowCase(Args&amp;&amp;... args)</span>
  {
      ASSERT(size() == capacity());
  
      expandCapacity(size() + 1);
      ASSERT(begin());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1359,13 ***</span>
      asanBufferSizeWillChangeTo(m_size + 1);
      new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
      ++m_size;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename... Args&gt;
<span class="line-modified">! bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::tryConstructAndAppendSlowCase(Args&amp;&amp;... args)</span>
  {
      ASSERT(size() == capacity());
  
      if (UNLIKELY(!tryExpandCapacity(size() + 1)))
          return false;
<span class="line-new-header">--- 1364,13 ---</span>
      asanBufferSizeWillChangeTo(m_size + 1);
      new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
      ++m_size;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename... Args&gt;
<span class="line-modified">! bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::tryConstructAndAppendSlowCase(Args&amp;&amp;... args)</span>
  {
      ASSERT(size() == capacity());
  
      if (UNLIKELY(!tryExpandCapacity(size() + 1)))
          return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1378,44 ***</span>
  }
  
  // This version of append saves a branch in the case where you know that the
  // vector&#39;s capacity is large enough for the append to succeed.
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::uncheckedAppend(U&amp;&amp; value)</span>
  {
      ASSERT(size() &lt; capacity());
  
      asanBufferSizeWillChangeTo(m_size + 1);
  
      new (NotNull, end()) T(std::forward&lt;U&gt;(value));
      ++m_size;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename... Args&gt;
<span class="line-modified">! ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::uncheckedConstructAndAppend(Args&amp;&amp;... args)</span>
  {
      ASSERT(size() &lt; capacity());
  
      asanBufferSizeWillChangeTo(m_size + 1);
  
      new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
      ++m_size;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename U, size_t otherCapacity&gt;
<span class="line-modified">! inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::appendVector(const Vector&lt;U, otherCapacity&gt;&amp; val)</span>
  {
      append(val.begin(), val.size());
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::insert(size_t position, const U* data, size_t dataSize)</span>
  {
      ASSERT_WITH_SECURITY_IMPLICATION(position &lt;= size());
      size_t newSize = m_size + dataSize;
      if (newSize &gt; capacity()) {
          data = expandCapacity(newSize, data);
<span class="line-new-header">--- 1383,55 ---</span>
  }
  
  // This version of append saves a branch in the case where you know that the
  // vector&#39;s capacity is large enough for the append to succeed.
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::uncheckedAppend(U&amp;&amp; value)</span>
  {
      ASSERT(size() &lt; capacity());
  
      asanBufferSizeWillChangeTo(m_size + 1);
  
      new (NotNull, end()) T(std::forward&lt;U&gt;(value));
      ++m_size;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename... Args&gt;
<span class="line-modified">! ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::uncheckedConstructAndAppend(Args&amp;&amp;... args)</span>
  {
      ASSERT(size() &lt; capacity());
  
      asanBufferSizeWillChangeTo(m_size + 1);
  
      new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
      ++m_size;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U, size_t otherCapacity&gt;
<span class="line-modified">! inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::appendVector(const Vector&lt;U, otherCapacity&gt;&amp; val)</span>
  {
      append(val.begin(), val.size());
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-added">+ template&lt;typename U, size_t otherCapacity&gt;</span>
<span class="line-added">+ inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::appendVector(Vector&lt;U, otherCapacity&gt;&amp;&amp; val)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     size_t newSize = m_size + val.size();</span>
<span class="line-added">+     if (newSize &gt; capacity())</span>
<span class="line-added">+         expandCapacity(newSize);</span>
<span class="line-added">+     for (auto&amp; item : val)</span>
<span class="line-added">+         uncheckedAppend(WTFMove(item));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::insert(size_t position, const U* data, size_t dataSize)</span>
  {
      ASSERT_WITH_SECURITY_IMPLICATION(position &lt;= size());
      size_t newSize = m_size + dataSize;
      if (newSize &gt; capacity()) {
          data = expandCapacity(newSize, data);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1428,13 ***</span>
      TypeOperations::moveOverlapping(spot, end(), spot + dataSize);
      VectorCopier&lt;std::is_trivial&lt;T&gt;::value, U&gt;::uninitializedCopy(data, std::addressof(data[dataSize]), spot);
      m_size = newSize;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::insert(size_t position, U&amp;&amp; value)</span>
  {
      ASSERT_WITH_SECURITY_IMPLICATION(position &lt;= size());
  
      auto ptr = const_cast&lt;typename std::remove_const&lt;typename std::remove_reference&lt;U&gt;::type&gt;::type*&gt;(std::addressof(value));
      if (size() == capacity()) {
<span class="line-new-header">--- 1444,13 ---</span>
      TypeOperations::moveOverlapping(spot, end(), spot + dataSize);
      VectorCopier&lt;std::is_trivial&lt;T&gt;::value, U&gt;::uninitializedCopy(data, std::addressof(data[dataSize]), spot);
      m_size = newSize;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::insert(size_t position, U&amp;&amp; value)</span>
  {
      ASSERT_WITH_SECURITY_IMPLICATION(position &lt;= size());
  
      auto ptr = const_cast&lt;typename std::remove_const&lt;typename std::remove_reference&lt;U&gt;::type&gt;::type*&gt;(std::addressof(value));
      if (size() == capacity()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1448,30 ***</span>
      TypeOperations::moveOverlapping(spot, end(), spot + 1);
      new (NotNull, spot) T(std::forward&lt;U&gt;(*ptr));
      ++m_size;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! template&lt;typename U, size_t c, typename OH&gt;</span>
<span class="line-modified">! inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::insertVector(size_t position, const Vector&lt;U, c, OH&gt;&amp; val)</span>
  {
      insert(position, val.begin(), val.size());
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::remove(size_t position)</span>
  {
      ASSERT_WITH_SECURITY_IMPLICATION(position &lt; size());
      T* spot = begin() + position;
      spot-&gt;~T();
      TypeOperations::moveOverlapping(spot + 1, end(), spot);
      asanBufferSizeWillChangeTo(m_size - 1);
      --m_size;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::remove(size_t position, size_t length)</span>
  {
      ASSERT_WITH_SECURITY_IMPLICATION(position &lt;= size());
      ASSERT_WITH_SECURITY_IMPLICATION(position + length &lt;= size());
      T* beginSpot = begin() + position;
      T* endSpot = beginSpot + length;
<span class="line-new-header">--- 1464,30 ---</span>
      TypeOperations::moveOverlapping(spot, end(), spot + 1);
      new (NotNull, spot) T(std::forward&lt;U&gt;(*ptr));
      ++m_size;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! template&lt;typename U, size_t c, typename OH, size_t m, typename M&gt;</span>
<span class="line-modified">! inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::insertVector(size_t position, const Vector&lt;U, c, OH, m, M&gt;&amp; val)</span>
  {
      insert(position, val.begin(), val.size());
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::remove(size_t position)</span>
  {
      ASSERT_WITH_SECURITY_IMPLICATION(position &lt; size());
      T* spot = begin() + position;
      spot-&gt;~T();
      TypeOperations::moveOverlapping(spot + 1, end(), spot);
      asanBufferSizeWillChangeTo(m_size - 1);
      --m_size;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::remove(size_t position, size_t length)</span>
  {
      ASSERT_WITH_SECURITY_IMPLICATION(position &lt;= size());
      ASSERT_WITH_SECURITY_IMPLICATION(position + length &lt;= size());
      T* beginSpot = begin() + position;
      T* endSpot = beginSpot + length;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1479,44 ***</span>
      TypeOperations::moveOverlapping(endSpot, end(), beginSpot);
      asanBufferSizeWillChangeTo(m_size - length);
      m_size -= length;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! inline bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::removeFirst(const U&amp; value)</span>
  {
      return removeFirstMatching([&amp;value] (const T&amp; current) {
          return current == value;
      });
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename MatchFunction&gt;
<span class="line-modified">! inline bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::removeFirstMatching(const MatchFunction&amp; matches, size_t startIndex)</span>
  {
      for (size_t i = startIndex; i &lt; size(); ++i) {
          if (matches(at(i))) {
              remove(i);
              return true;
          }
      }
      return false;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! inline unsigned Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::removeAll(const U&amp; value)</span>
  {
      return removeAllMatching([&amp;value] (const T&amp; current) {
          return current == value;
      });
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename MatchFunction&gt;
<span class="line-modified">! inline unsigned Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::removeAllMatching(const MatchFunction&amp; matches, size_t startIndex)</span>
  {
      iterator holeBegin = end();
      iterator holeEnd = end();
      unsigned matchCount = 0;
      for (auto it = begin() + startIndex, itEnd = end(); it &lt; itEnd; ++it) {
<span class="line-new-header">--- 1495,44 ---</span>
      TypeOperations::moveOverlapping(endSpot, end(), beginSpot);
      asanBufferSizeWillChangeTo(m_size - length);
      m_size -= length;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! inline bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::removeFirst(const U&amp; value)</span>
  {
      return removeFirstMatching([&amp;value] (const T&amp; current) {
          return current == value;
      });
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename MatchFunction&gt;
<span class="line-modified">! inline bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::removeFirstMatching(const MatchFunction&amp; matches, size_t startIndex)</span>
  {
      for (size_t i = startIndex; i &lt; size(); ++i) {
          if (matches(at(i))) {
              remove(i);
              return true;
          }
      }
      return false;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! inline unsigned Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::removeAll(const U&amp; value)</span>
  {
      return removeAllMatching([&amp;value] (const T&amp; current) {
          return current == value;
      });
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename MatchFunction&gt;
<span class="line-modified">! inline unsigned Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::removeAllMatching(const MatchFunction&amp; matches, size_t startIndex)</span>
  {
      iterator holeBegin = end();
      iterator holeEnd = end();
      unsigned matchCount = 0;
      for (auto it = begin() + startIndex, itEnd = end(); it &lt; itEnd; ++it) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1537,30 ***</span>
      asanBufferSizeWillChangeTo(m_size - matchCount);
      m_size -= matchCount;
      return matchCount;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::reverse()</span>
  {
      for (size_t i = 0; i &lt; m_size / 2; ++i)
          std::swap(at(i), at(m_size - 1 - i));
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename MapFunction, typename R&gt;
<span class="line-modified">! inline Vector&lt;R&gt; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::map(MapFunction mapFunction) const</span>
  {
      Vector&lt;R&gt; result;
      result.reserveInitialCapacity(size());
      for (size_t i = 0; i &lt; size(); ++i)
          result.uncheckedAppend(mapFunction(at(i)));
      return result;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! inline MallocPtr&lt;T&gt; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::releaseBuffer()</span>
  {
      // FIXME: Find a way to preserve annotations on the returned buffer.
      // ASan requires that all annotations are removed before deallocation,
      // and MallocPtr doesn&#39;t implement that.
      asanSetBufferSizeToFullCapacity();
<span class="line-new-header">--- 1553,30 ---</span>
      asanBufferSizeWillChangeTo(m_size - matchCount);
      m_size -= matchCount;
      return matchCount;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::reverse()</span>
  {
      for (size_t i = 0; i &lt; m_size / 2; ++i)
          std::swap(at(i), at(m_size - 1 - i));
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename MapFunction, typename R&gt;
<span class="line-modified">! inline Vector&lt;R&gt; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::map(MapFunction mapFunction) const</span>
  {
      Vector&lt;R&gt; result;
      result.reserveInitialCapacity(size());
      for (size_t i = 0; i &lt; size(); ++i)
          result.uncheckedAppend(mapFunction(at(i)));
      return result;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! inline MallocPtr&lt;T, Malloc&gt; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::releaseBuffer()</span>
  {
      // FIXME: Find a way to preserve annotations on the returned buffer.
      // ASan requires that all annotations are removed before deallocation,
      // and MallocPtr doesn&#39;t implement that.
      asanSetBufferSizeToFullCapacity();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1569,61 ***</span>
      if (inlineCapacity &amp;&amp; !buffer &amp;&amp; m_size) {
          // If the vector had some data, but no buffer to release,
          // that means it was using the inline buffer. In that case,
          // we create a brand new buffer so the caller always gets one.
          size_t bytes = m_size * sizeof(T);
<span class="line-modified">!         buffer = adoptMallocPtr(static_cast&lt;T*&gt;(fastMalloc(bytes)));</span>
          memcpy(buffer.get(), data(), bytes);
      }
      m_size = 0;
      // FIXME: Should we call Base::restoreInlineBufferIfNeeded() here?
      return buffer;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::checkConsistency()</span>
  {
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      for (size_t i = 0; i &lt; size(); ++i)
          ValueCheck&lt;T&gt;::checkConsistency(at(i));
  #endif
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! inline void swap(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; a, Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; b)</span>
  {
      a.swap(b);
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! bool operator==(const Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; a, const Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; b)</span>
  {
      if (a.size() != b.size())
          return false;
  
      return VectorTypeOperations&lt;T&gt;::compare(a.data(), b.data(), a.size());
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! inline bool operator!=(const Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; a, const Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; b)</span>
  {
      return !(a == b);
  }
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
  template&lt;typename T&gt; struct ValueCheck&lt;Vector&lt;T&gt;&gt; {
      typedef Vector&lt;T&gt; TraitType;
      static void checkConsistency(const Vector&lt;T&gt;&amp; v)
      {
          v.checkConsistency();
      }
  };
<span class="line-modified">! #endif</span>
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! inline Vector&lt;U&gt; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;::isolatedCopy() const</span>
  {
      Vector&lt;U&gt; copy;
      copy.reserveInitialCapacity(size());
      for (const auto&amp; element : *this)
          copy.uncheckedAppend(element.isolatedCopy());
<span class="line-new-header">--- 1585,61 ---</span>
      if (inlineCapacity &amp;&amp; !buffer &amp;&amp; m_size) {
          // If the vector had some data, but no buffer to release,
          // that means it was using the inline buffer. In that case,
          // we create a brand new buffer so the caller always gets one.
          size_t bytes = m_size * sizeof(T);
<span class="line-modified">!         buffer = adoptMallocPtr&lt;T, Malloc&gt;(static_cast&lt;T*&gt;(Malloc::malloc(bytes)));</span>
          memcpy(buffer.get(), data(), bytes);
      }
      m_size = 0;
      // FIXME: Should we call Base::restoreInlineBufferIfNeeded() here?
      return buffer;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::checkConsistency()</span>
  {
<span class="line-modified">! #if ASSERT_ENABLED</span>
      for (size_t i = 0; i &lt; size(); ++i)
          ValueCheck&lt;T&gt;::checkConsistency(at(i));
  #endif
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! inline void swap(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; a, Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; b)</span>
  {
      a.swap(b);
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacityA, typename OverflowHandlerA, size_t minCapacityA, typename MallocA, size_t inlineCapacityB, typename OverflowHandlerB, size_t minCapacityB, typename MallocB&gt;</span>
<span class="line-modified">! bool operator==(const Vector&lt;T, inlineCapacityA, OverflowHandlerA, minCapacityA, MallocA&gt;&amp; a, const Vector&lt;T, inlineCapacityB, OverflowHandlerB, minCapacityB, MallocB&gt;&amp; b)</span>
  {
      if (a.size() != b.size())
          return false;
  
      return VectorTypeOperations&lt;T&gt;::compare(a.data(), b.data(), a.size());
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacityA, typename OverflowHandlerA, size_t minCapacityA, typename MallocA, size_t inlineCapacityB, typename OverflowHandlerB, size_t minCapacityB, typename MallocB&gt;</span>
<span class="line-modified">! inline bool operator!=(const Vector&lt;T, inlineCapacityA, OverflowHandlerA, minCapacityA, MallocA&gt;&amp; a, const Vector&lt;T, inlineCapacityB, OverflowHandlerB, minCapacityB, MallocB&gt;&amp; b)</span>
  {
      return !(a == b);
  }
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
  template&lt;typename T&gt; struct ValueCheck&lt;Vector&lt;T&gt;&gt; {
      typedef Vector&lt;T&gt; TraitType;
      static void checkConsistency(const Vector&lt;T&gt;&amp; v)
      {
          v.checkConsistency();
      }
  };
<span class="line-modified">! #endif // ASSERT_ENABLED</span>
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
  template&lt;typename U&gt;
<span class="line-modified">! inline Vector&lt;U&gt; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::isolatedCopy() const</span>
  {
      Vector&lt;U&gt; copy;
      copy.reserveInitialCapacity(size());
      for (const auto&amp; element : *this)
          copy.uncheckedAppend(element.isolatedCopy());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1637,12 ***</span>
      size_t newSize = end - vector.begin();
      vector.shrink(newSize);
      return newSize;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity&gt;</span>
<span class="line-modified">! size_t removeRepeatedElements(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity&gt;&amp; vector)</span>
  {
      return removeRepeatedElements(vector, [] (T&amp; a, T&amp; b) { return a == b; });
  }
  
  template&lt;typename SourceType&gt;
<span class="line-new-header">--- 1653,12 ---</span>
      size_t newSize = end - vector.begin();
      vector.shrink(newSize);
      return newSize;
  }
  
<span class="line-modified">! template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;</span>
<span class="line-modified">! size_t removeRepeatedElements(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; vector)</span>
  {
      return removeRepeatedElements(vector, [] (T&amp; a, T&amp; b) { return a == b; });
  }
  
  template&lt;typename SourceType&gt;
</pre>
<center><a href="Variant.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VectorTraits.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
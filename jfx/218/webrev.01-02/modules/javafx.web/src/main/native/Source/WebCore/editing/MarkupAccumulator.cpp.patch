diff a/modules/javafx.web/src/main/native/Source/WebCore/editing/MarkupAccumulator.cpp b/modules/javafx.web/src/main/native/Source/WebCore/editing/MarkupAccumulator.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/editing/MarkupAccumulator.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/editing/MarkupAccumulator.cpp
@@ -148,16 +148,16 @@
     size_t positionAfterLastEntity = 0;
     for (size_t i = 0; i < length; ++i) {
         CharacterType character = text[i];
         uint8_t substitution = character < WTF_ARRAY_LENGTH(entityMap) ? entityMap[character] : static_cast<uint8_t>(EntitySubstitutionNullIndex);
         if (UNLIKELY(substitution != EntitySubstitutionNullIndex) && entitySubstitutionList[substitution].mask & entityMask) {
-            result.appendCharacters(text + positionAfterLastEntity, i - positionAfterLastEntity);
+            result.appendSubstring(source, offset + positionAfterLastEntity, i - positionAfterLastEntity);
             result.appendCharacters(entitySubstitutionList[substitution].characters, entitySubstitutionList[substitution].length);
             positionAfterLastEntity = i + 1;
         }
     }
-    result.appendCharacters(text + positionAfterLastEntity, length - positionAfterLastEntity);
+    result.appendSubstring(source, offset + positionAfterLastEntity, length - positionAfterLastEntity);
 }
 
 void MarkupAccumulator::appendCharactersReplacingEntities(StringBuilder& result, const String& source, unsigned offset, unsigned length, EntityMask entityMask)
 {
     if (!(offset + length))
@@ -349,15 +349,12 @@
 void MarkupAccumulator::appendNamespace(StringBuilder& result, const AtomString& prefix, const AtomString& namespaceURI, Namespaces& namespaces, bool allowEmptyDefaultNS)
 {
     namespaces.checkConsistency();
     if (namespaceURI.isEmpty()) {
         // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-xhtml-syntax.html#xml-fragment-serialization-algorithm
-        if (allowEmptyDefaultNS && namespaces.get(emptyAtom().impl())) {
-            result.append(' ');
-            result.append(xmlnsAtom().string());
-            result.appendLiteral("=\"\"");
-        }
+        if (allowEmptyDefaultNS && namespaces.get(emptyAtom().impl()))
+            result.append(' ', xmlnsAtom(), "=\"\"");
         return;
     }
 
     // Use emptyAtom()s's impl() for both null and empty strings since the HashMap can't handle 0 as a key
     AtomStringImpl* pre = prefix.isEmpty() ? emptyAtom().impl() : prefix.impl();
@@ -368,27 +365,24 @@
         if (inXMLFragmentSerialization() && !prefix.isEmpty())
             namespaces.set(namespaceURI.impl(), pre);
         // Make sure xml prefix and namespace are always known to uphold the constraints listed at http://www.w3.org/TR/xml-names11/#xmlReserved.
         if (namespaceURI.impl() == XMLNames::xmlNamespaceURI->impl())
             return;
-        result.append(' ');
-        result.append(xmlnsAtom().string());
-        if (!prefix.isEmpty()) {
-            result.append(':');
-            result.append(prefix);
-        }
+        result.append(' ', xmlnsAtom());
+        if (!prefix.isEmpty())
+            result.append(':', prefix);
 
         result.append('=');
         result.append('"');
         appendAttributeValue(result, namespaceURI, false);
         result.append('"');
     }
 }
 
 EntityMask MarkupAccumulator::entityMaskForText(const Text& text) const
 {
-    if (!text.document().isHTMLDocument())
+    if (!text.document().isHTMLDocument() || inXMLFragmentSerialization())
         return EntityMaskInPCDATA;
 
     const QualifiedName* parentName = nullptr;
     if (text.parentElement())
         parentName = &text.parentElement()->tagQName();

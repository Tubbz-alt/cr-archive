<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmCodeBlock.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmCodeBlock.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
 31 #include &quot;WasmBBQPlan.h&quot;
 32 #include &quot;WasmCallee.h&quot;
 33 #include &quot;WasmFormat.h&quot;
 34 #include &quot;WasmLLIntPlan.h&quot;
 35 #include &quot;WasmWorklist.h&quot;
 36 
 37 namespace JSC { namespace Wasm {
 38 
 39 Ref&lt;CodeBlock&gt; CodeBlock::create(Context* context, MemoryMode mode, ModuleInformation&amp; moduleInformation, RefPtr&lt;LLIntCallees&gt; llintCallees)
 40 {
 41     auto* result = new (NotNull, fastMalloc(sizeof(CodeBlock))) CodeBlock(context, mode, moduleInformation, llintCallees);
 42     return adoptRef(*result);
 43 }
 44 
 45 CodeBlock::CodeBlock(Context* context, MemoryMode mode, ModuleInformation&amp; moduleInformation, RefPtr&lt;LLIntCallees&gt; llintCallees)
 46     : m_calleeCount(moduleInformation.internalFunctionCount())
 47     , m_mode(mode)
 48     , m_llintCallees(llintCallees)
 49 {
 50     RefPtr&lt;CodeBlock&gt; protectedThis = this;
 51 
 52     if (Options::useWasmLLInt()) {
 53         m_plan = adoptRef(*new LLIntPlan(context, makeRef(moduleInformation), m_llintCallees-&gt;data(), createSharedTask&lt;Plan::CallbackType&gt;([this, protectedThis = WTFMove(protectedThis)] (Plan&amp;) {
 54             auto locker = holdLock(m_lock);
 55             if (m_plan-&gt;failed()) {
 56                 m_errorMessage = m_plan-&gt;errorMessage();
 57                 setCompilationFinished();
 58                 return;
 59             }
 60 
 61             // FIXME: we should eventually collect the BBQ code.
 62             m_bbqCallees.resize(m_calleeCount);
 63             m_omgCallees.resize(m_calleeCount);
 64             m_wasmIndirectCallEntryPoints.resize(m_calleeCount);
 65 
 66             for (unsigned i = 0; i &lt; m_calleeCount; ++i)
 67                 m_wasmIndirectCallEntryPoints[i] = m_llintCallees-&gt;at(i)-&gt;entrypoint();
 68 
 69             m_wasmToWasmExitStubs = m_plan-&gt;takeWasmToWasmExitStubs();
 70             m_wasmToWasmCallsites = m_plan-&gt;takeWasmToWasmCallsites();
 71             m_embedderCallees = static_cast&lt;LLIntPlan*&gt;(m_plan.get())-&gt;takeEmbedderCallees();
 72 
 73             setCompilationFinished();
 74         })));
 75     } else {
 76         m_plan = adoptRef(*new BBQPlan(context, makeRef(moduleInformation), EntryPlan::FullCompile, createSharedTask&lt;Plan::CallbackType&gt;([this, protectedThis = WTFMove(protectedThis)] (Plan&amp;) {
 77             auto locker = holdLock(m_lock);
 78             if (m_plan-&gt;failed()) {
 79                 m_errorMessage = m_plan-&gt;errorMessage();
 80                 setCompilationFinished();
 81                 return;
 82             }
 83 
 84             // FIXME: we should eventually collect the BBQ code.
 85             m_bbqCallees.resize(m_calleeCount);
 86             m_omgCallees.resize(m_calleeCount);
 87             m_wasmIndirectCallEntryPoints.resize(m_calleeCount);
 88 
 89             BBQPlan* bbqPlan = static_cast&lt;BBQPlan*&gt;(m_plan.get());
 90             bbqPlan-&gt;initializeCallees([&amp;] (unsigned calleeIndex, RefPtr&lt;EmbedderEntrypointCallee&gt;&amp;&amp; embedderEntrypointCallee, RefPtr&lt;BBQCallee&gt;&amp;&amp; wasmEntrypoint) {
 91                 if (embedderEntrypointCallee) {
 92                     auto result = m_embedderCallees.set(calleeIndex, WTFMove(embedderEntrypointCallee));
 93                     ASSERT_UNUSED(result, result.isNewEntry);
 94                 }
 95                 m_wasmIndirectCallEntryPoints[calleeIndex] = wasmEntrypoint-&gt;entrypoint();
 96                 m_bbqCallees[calleeIndex] = adoptRef(static_cast&lt;BBQCallee*&gt;(wasmEntrypoint.leakRef()));
 97             });
 98 
 99             m_wasmToWasmExitStubs = m_plan-&gt;takeWasmToWasmExitStubs();
100             m_wasmToWasmCallsites = m_plan-&gt;takeWasmToWasmCallsites();
101 
102             setCompilationFinished();
103         })));
104     }
105     m_plan-&gt;setMode(mode);
106 
107     auto&amp; worklist = Wasm::ensureWorklist();
108     // Note, immediately after we enqueue the plan, there is a chance the above callback will be called.
109     worklist.enqueue(makeRef(*m_plan.get()));
110 }
111 
112 CodeBlock::~CodeBlock() { }
113 
114 void CodeBlock::waitUntilFinished()
115 {
116     RefPtr&lt;Plan&gt; plan;
117     {
118         auto locker = holdLock(m_lock);
119         plan = m_plan;
120     }
121 
122     if (plan) {
123         auto&amp; worklist = Wasm::ensureWorklist();
124         worklist.completePlanSynchronously(*plan.get());
125     }
126     // else, if we don&#39;t have a plan, we&#39;re already compiled.
127 }
128 
129 void CodeBlock::compileAsync(Context* context, AsyncCompilationCallback&amp;&amp; task)
130 {
131     RefPtr&lt;Plan&gt; plan;
132     {
133         auto locker = holdLock(m_lock);
134         plan = m_plan;
135     }
136 
137     if (plan) {
138         // We don&#39;t need to keep a RefPtr on the Plan because the worklist will keep
139         // a RefPtr on the Plan until the plan finishes notifying all of its callbacks.
140         RefPtr&lt;CodeBlock&gt; protectedThis = this;
141         plan-&gt;addCompletionTask(context, createSharedTask&lt;Plan::CallbackType&gt;([this, task = WTFMove(task), protectedThis = WTFMove(protectedThis)] (Plan&amp;) {
142             task-&gt;run(makeRef(*this));
143         }));
144     } else
145         task-&gt;run(makeRef(*this));
146 }
147 
148 bool CodeBlock::isSafeToRun(MemoryMode memoryMode)
149 {
150     if (!runnable())
151         return false;
152 
153     switch (m_mode) {
154     case Wasm::MemoryMode::BoundsChecking:
155         return true;
156     case Wasm::MemoryMode::Signaling:
157         // Code being in Signaling mode means that it performs no bounds checks.
158         // Its memory, even if empty, absolutely must also be in Signaling mode
159         // because the page protection detects out-of-bounds accesses.
160         return memoryMode == Wasm::MemoryMode::Signaling;
161     }
162     RELEASE_ASSERT_NOT_REACHED();
163     return false;
164 }
165 
166 
167 void CodeBlock::setCompilationFinished()
168 {
169     m_plan = nullptr;
170     m_compilationFinished.store(true);
171 }
172 
173 } } // namespace JSC::Wasm
174 
175 #endif // ENABLE(WEBASSEMBLY)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/angle/GraphicsContextGLANGLE.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2010, 2013 Apple Inc. All rights reserved.
   3  * Copyright (C) 2019 Google Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 
  29 #if ENABLE(GRAPHICS_CONTEXT_GL) &amp;&amp; USE(ANGLE)
  30 #include &quot;GraphicsContextGL.h&quot;
  31 
  32 #if PLATFORM(IOS_FAMILY)
  33 #include &quot;GraphicsContextGLOpenGLESIOS.h&quot;
  34 #endif
  35 #include &quot;ExtensionsGLANGLE.h&quot;
  36 #include &quot;ImageBuffer.h&quot;
  37 #include &quot;ImageData.h&quot;
  38 #include &quot;IntRect.h&quot;
  39 #include &quot;IntSize.h&quot;
  40 #include &quot;Logging.h&quot;
  41 #include &quot;NotImplemented.h&quot;
  42 #include &quot;TemporaryANGLESetting.h&quot;
  43 #include &lt;JavaScriptCore/RegularExpression.h&gt;
  44 #include &lt;algorithm&gt;
  45 #include &lt;cstring&gt;
  46 #include &lt;wtf/HexNumber.h&gt;
  47 #include &lt;wtf/ThreadSpecific.h&gt;
  48 #include &lt;wtf/text/CString.h&gt;
  49 #include &lt;wtf/text/StringBuilder.h&gt;
  50 
  51 #if USE(ACCELERATE)
  52 #include &lt;Accelerate/Accelerate.h&gt;
  53 #endif
  54 
  55 // Skip the inclusion of ANGLE&#39;s explicit context entry points for now.
  56 #define GL_ANGLE_explicit_context
  57 #define GL_ANGLE_explicit_context_gles1
  58 typedef void* GLeglContext;
  59 #include &lt;ANGLE/entry_points_gles_2_0_autogen.h&gt;
  60 #include &lt;ANGLE/entry_points_gles_3_0_autogen.h&gt;
  61 #include &lt;ANGLE/entry_points_gles_ext_autogen.h&gt;
  62 #include &lt;ANGLE/gl2ext.h&gt;
  63 #include &lt;ANGLE/gl2ext_angle.h&gt;
  64 
  65 // Note: this file can&#39;t be compiled in the same unified source file
  66 // as others which include the system&#39;s OpenGL headers.
  67 
  68 // This one definition short-circuits the need for gl2ext.h, which
  69 // would need more work to be included from WebCore.
  70 #define GL_MAX_SAMPLES_EXT 0x8D57
  71 
  72 #if USE(COORDINATED_GRAPHICS) &amp;&amp; USE(TEXTURE_MAPPER)
  73 #define GL_COLOR_ATTACHMENT0_EXT 0x8CE0
  74 #define GL_FRAMEBUFFER_EXT 0x8D40
  75 #endif
  76 
  77 namespace WebCore {
  78 
  79 static const char* packedDepthStencilExtensionName = &quot;GL_OES_packed_depth_stencil&quot;;
  80 
  81 void GraphicsContextGLOpenGL::releaseShaderCompiler()
  82 {
  83     makeContextCurrent();
  84     notImplemented();
  85 }
  86 
  87 #if PLATFORM(MAC)
  88 static void wipeAlphaChannelFromPixels(int width, int height, unsigned char* pixels)
  89 {
  90     // We can assume this doesn&#39;t overflow because the calling functions
  91     // use checked arithmetic.
  92     int totalBytes = width * height * 4;
  93     for (int i = 0; i &lt; totalBytes; i += 4)
  94         pixels[i + 3] = 255;
  95 }
  96 #endif
  97 
  98 void GraphicsContextGLOpenGL::readPixelsAndConvertToBGRAIfNecessary(int x, int y, int width, int height, unsigned char* pixels)
  99 {
 100     // NVIDIA drivers have a bug where calling readPixels in BGRA can return the wrong values for the alpha channel when the alpha is off for the context.
 101     gl::ReadPixels(x, y, width, height, GL_RGBA, GL_UNSIGNED_BYTE, pixels);
 102 #if USE(ACCELERATE)
 103     vImage_Buffer src;
 104     src.height = height;
 105     src.width = width;
 106     src.rowBytes = width * 4;
 107     src.data = pixels;
 108 
 109     vImage_Buffer dest;
 110     dest.height = height;
 111     dest.width = width;
 112     dest.rowBytes = width * 4;
 113     dest.data = pixels;
 114 
 115     // Swap pixel channels from RGBA to BGRA.
 116     const uint8_t map[4] = { 2, 1, 0, 3 };
 117     vImagePermuteChannels_ARGB8888(&amp;src, &amp;dest, map, kvImageNoFlags);
 118 #else
 119     int totalBytes = width * height * 4;
 120     for (int i = 0; i &lt; totalBytes; i += 4)
 121         std::swap(pixels[i], pixels[i + 2]);
 122 #endif
 123 
 124 #if PLATFORM(MAC)
 125     if (!contextAttributes().alpha)
 126         wipeAlphaChannelFromPixels(width, height, pixels);
 127 #endif
 128 }
 129 
 130 void GraphicsContextGLOpenGL::validateAttributes()
 131 {
 132     validateDepthStencil(packedDepthStencilExtensionName);
 133 }
 134 
 135 bool GraphicsContextGLOpenGL::reshapeFBOs(const IntSize&amp; size)
 136 {
 137     auto attrs = contextAttributes();
 138     const int width = size.width();
 139     const int height = size.height();
 140     GLuint colorFormat, internalDepthStencilFormat = 0;
 141     if (attrs.alpha) {
 142         m_internalColorFormat = GL_RGBA8;
 143         colorFormat = GL_RGBA;
 144     } else {
 145         m_internalColorFormat = GL_RGB8;
 146         colorFormat = GL_RGB;
 147     }
 148     if (attrs.stencil || attrs.depth) {
 149         // We don&#39;t allow the logic where stencil is required and depth is not.
 150         // See GraphicsContextGLOpenGL::validateAttributes.
 151 
 152         ExtensionsGL&amp; extensions = getExtensions();
 153         // Use a 24 bit depth buffer where we know we have it.
 154         if (extensions.supports(packedDepthStencilExtensionName))
 155             internalDepthStencilFormat = GL_DEPTH24_STENCIL8_OES;
 156         else
 157             internalDepthStencilFormat = GL_DEPTH_COMPONENT16;
 158     }
 159 
 160     // Resize multisample FBO.
 161     if (attrs.antialias) {
 162         GLint maxSampleCount;
 163         gl::GetIntegerv(GL_MAX_SAMPLES_ANGLE, &amp;maxSampleCount);
 164         // Using more than 4 samples is slow on some hardware and is unlikely to
 165         // produce a significantly better result.
 166         GLint sampleCount = std::min(4, maxSampleCount);
 167         gl::BindFramebuffer(GL_FRAMEBUFFER, m_multisampleFBO);
 168         gl::BindRenderbuffer(GL_RENDERBUFFER, m_multisampleColorBuffer);
 169         getExtensions().renderbufferStorageMultisample(GL_RENDERBUFFER, sampleCount, m_internalColorFormat, width, height);
 170         gl::FramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, m_multisampleColorBuffer);
 171         if (attrs.stencil || attrs.depth) {
 172             gl::BindRenderbuffer(GL_RENDERBUFFER, m_multisampleDepthStencilBuffer);
 173             getExtensions().renderbufferStorageMultisample(GL_RENDERBUFFER, sampleCount, internalDepthStencilFormat, width, height);
 174             // WebGL 1.0&#39;s rules state that combined depth/stencil renderbuffers
 175             // have to be attached to the synthetic DEPTH_STENCIL_ATTACHMENT point.
 176             if (!isGLES2Compliant() &amp;&amp; internalDepthStencilFormat == GL_DEPTH24_STENCIL8_OES)
 177                 gl::FramebufferRenderbuffer(GL_FRAMEBUFFER, DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, m_multisampleDepthStencilBuffer);
 178             else {
 179                 if (attrs.stencil)
 180                     gl::FramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, m_multisampleDepthStencilBuffer);
 181                 if (attrs.depth)
 182                     gl::FramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, m_multisampleDepthStencilBuffer);
 183             }
 184         }
 185         gl::BindRenderbuffer(GL_RENDERBUFFER, 0);
 186         if (gl::CheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
 187             // FIXME: cleanup.
 188             notImplemented();
 189         }
 190     }
 191 
 192     // resize regular FBO
 193     gl::BindFramebuffer(GL_FRAMEBUFFER, m_fbo);
 194     ASSERT(m_texture);
 195 
 196 #if PLATFORM(COCOA)
 197     allocateIOSurfaceBackingStore(IntSize(width, height));
 198     updateFramebufferTextureBackingStoreFromLayer();
 199     gl::FramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GraphicsContextGL::IOSurfaceTextureTarget, m_texture, 0);
 200 #elif PLATFORM(GTK)
 201     gl::BindTexture(GL_TEXTURE_RECTANGLE_ANGLE, m_texture);
 202     gl::TexImage2D(GL_TEXTURE_RECTANGLE_ANGLE, 0, m_internalColorFormat, width, height, 0, colorFormat, GL_UNSIGNED_BYTE, 0);
 203     gl::FramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_RECTANGLE_ANGLE, m_texture, 0);
 204     if (m_compositorTexture) {
 205         gl::BindTexture(GL_TEXTURE_RECTANGLE_ANGLE, m_compositorTexture);
 206         gl::TexImage2D(GL_TEXTURE_RECTANGLE_ANGLE, 0, m_internalColorFormat, width, height, 0, colorFormat, GL_UNSIGNED_BYTE, 0);
 207         gl::BindTexture(GL_TEXTURE_RECTANGLE_ANGLE, 0);
 208         gl::BindTexture(GL_TEXTURE_RECTANGLE_ANGLE, m_intermediateTexture);
 209         gl::TexImage2D(GL_TEXTURE_RECTANGLE_ANGLE, 0, m_internalColorFormat, width, height, 0, colorFormat, GL_UNSIGNED_BYTE, 0);
 210         gl::BindTexture(GL_TEXTURE_RECTANGLE_ANGLE, 0);
 211     }
 212 #else
 213 #error FIXME: Port to non-Cocoa platforms.
 214 #endif // PLATFORM(COCOA)
 215 
 216     attachDepthAndStencilBufferIfNeeded(internalDepthStencilFormat, width, height);
 217 
 218     bool mustRestoreFBO = true;
 219     if (attrs.antialias) {
 220         gl::BindFramebuffer(GL_FRAMEBUFFER, m_multisampleFBO);
 221         if (m_state.boundFBO == m_multisampleFBO)
 222             mustRestoreFBO = false;
 223     } else {
 224         if (m_state.boundFBO == m_fbo)
 225             mustRestoreFBO = false;
 226     }
 227 
 228     return mustRestoreFBO;
 229 }
 230 
 231 void GraphicsContextGLOpenGL::attachDepthAndStencilBufferIfNeeded(GLuint internalDepthStencilFormat, int width, int height)
 232 {
 233     auto attrs = contextAttributes();
 234 
 235     if (!attrs.antialias &amp;&amp; (attrs.stencil || attrs.depth)) {
 236         gl::BindRenderbuffer(GL_RENDERBUFFER, m_depthStencilBuffer);
 237         gl::RenderbufferStorage(GL_RENDERBUFFER, internalDepthStencilFormat, width, height);
 238         // WebGL 1.0&#39;s rules state that combined depth/stencil renderbuffers
 239         // have to be attached to the synthetic DEPTH_STENCIL_ATTACHMENT point.
 240         if (!isGLES2Compliant() &amp;&amp; internalDepthStencilFormat == GL_DEPTH24_STENCIL8_OES)
 241             gl::FramebufferRenderbuffer(GL_FRAMEBUFFER, DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, m_depthStencilBuffer);
 242         else {
 243             if (attrs.stencil)
 244                 gl::FramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, m_depthStencilBuffer);
 245             if (attrs.depth)
 246                 gl::FramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, m_depthStencilBuffer);
 247         }
 248         gl::BindRenderbuffer(GL_RENDERBUFFER, 0);
 249     }
 250 
 251     if (gl::CheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
 252         // FIXME: cleanup
 253         notImplemented();
 254     }
 255 }
 256 
 257 void GraphicsContextGLOpenGL::resolveMultisamplingIfNecessary(const IntRect&amp; rect)
 258 {
 259     TemporaryANGLESetting scopedScissor(GL_SCISSOR_TEST, GL_FALSE);
 260     TemporaryANGLESetting scopedDither(GL_DITHER, GL_FALSE);
 261 
 262     GLint boundFrameBuffer;
 263     gl::GetIntegerv(GL_FRAMEBUFFER_BINDING, &amp;boundFrameBuffer);
 264     gl::BindFramebuffer(GL_READ_FRAMEBUFFER_ANGLE, m_multisampleFBO);
 265     gl::BindFramebuffer(GL_DRAW_FRAMEBUFFER_ANGLE, m_fbo);
 266 
 267     // FIXME: figure out more efficient solution for iOS.
 268     IntRect resolveRect = rect;
 269     // When using an ES 2.0 context, the full framebuffer must always be
 270     // resolved; partial blits are not allowed.
 271     if (!isGLES2Compliant() || rect.isEmpty())
 272         resolveRect = IntRect(0, 0, m_currentWidth, m_currentHeight);
 273 
 274     gl::BlitFramebufferANGLE(resolveRect.x(), resolveRect.y(), resolveRect.maxX(), resolveRect.maxY(), resolveRect.x(), resolveRect.y(), resolveRect.maxX(), resolveRect.maxY(), GL_COLOR_BUFFER_BIT, GL_NEAREST);
 275     gl::BindFramebuffer(GL_FRAMEBUFFER, boundFrameBuffer);
 276 }
 277 
 278 void GraphicsContextGLOpenGL::renderbufferStorage(GCGLenum target, GCGLenum internalformat, GCGLsizei width, GCGLsizei height)
 279 {
 280     makeContextCurrent();
 281     gl::RenderbufferStorage(target, internalformat, width, height);
 282 }
 283 
 284 void GraphicsContextGLOpenGL::getIntegerv(GCGLenum pname, GCGLint* value)
 285 {
 286     makeContextCurrent();
 287     switch (pname) {
 288     case MAX_TEXTURE_SIZE:
 289         gl::GetIntegerv(MAX_TEXTURE_SIZE, value);
 290         if (getExtensions().requiresRestrictedMaximumTextureSize())
 291             *value = std::min(4096, *value);
 292         break;
 293     case MAX_CUBE_MAP_TEXTURE_SIZE:
 294         gl::GetIntegerv(MAX_CUBE_MAP_TEXTURE_SIZE, value);
 295         if (getExtensions().requiresRestrictedMaximumTextureSize())
 296             *value = std::min(1024, *value);
 297         break;
 298 #if PLATFORM(MAC)
 299     // Some older hardware advertises a larger maximum than they
 300     // can actually handle. Rather than detecting such devices, simply
 301     // clamp the maximum to 8192, which is big enough for a 5K display.
 302     case MAX_RENDERBUFFER_SIZE:
 303         gl::GetIntegerv(MAX_RENDERBUFFER_SIZE, value);
 304         *value = std::min(8192, *value);
 305         break;
 306     case MAX_VIEWPORT_DIMS:
 307         gl::GetIntegerv(MAX_VIEWPORT_DIMS, value);
 308         value[0] = std::min(8192, value[0]);
 309         value[1] = std::min(8192, value[1]);
 310         break;
 311 #endif
 312     default:
 313         gl::GetIntegerv(pname, value);
 314     }
 315 }
 316 
 317 void GraphicsContextGLOpenGL::getShaderPrecisionFormat(GCGLenum shaderType, GCGLenum precisionType, GCGLint* range, GCGLint* precision)
 318 {
 319     UNUSED_PARAM(shaderType);
 320     ASSERT(range);
 321     ASSERT(precision);
 322 
 323     makeContextCurrent();
 324 
 325     switch (precisionType) {
 326     case GraphicsContextGL::LOW_INT:
 327     case GraphicsContextGL::MEDIUM_INT:
 328     case GraphicsContextGL::HIGH_INT:
 329         // These values are for a 32-bit twos-complement integer format.
 330         range[0] = 31;
 331         range[1] = 30;
 332         precision[0] = 0;
 333         break;
 334     case GraphicsContextGL::LOW_FLOAT:
 335     case GraphicsContextGL::MEDIUM_FLOAT:
 336     case GraphicsContextGL::HIGH_FLOAT:
 337         // These values are for an IEEE single-precision floating-point format.
 338         range[0] = 127;
 339         range[1] = 127;
 340         precision[0] = 23;
 341         break;
 342     default:
 343         ASSERT_NOT_REACHED();
 344         break;
 345     }
 346 }
 347 
 348 bool GraphicsContextGLOpenGL::texImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, const void* pixels)
 349 {
 350     if (width &amp;&amp; height &amp;&amp; !pixels) {
 351         synthesizeGLError(INVALID_VALUE);
 352         return false;
 353     }
 354 
 355     texImage2DDirect(target, level, internalformat, width, height, border, format, type, pixels);
 356     return true;
 357 }
 358 
 359 void GraphicsContextGLOpenGL::depthRange(GCGLclampf zNear, GCGLclampf zFar)
 360 {
 361     makeContextCurrent();
 362     gl::DepthRangef(static_cast&lt;float&gt;(zNear), static_cast&lt;float&gt;(zFar));
 363 }
 364 
 365 void GraphicsContextGLOpenGL::clearDepth(GCGLclampf depth)
 366 {
 367     makeContextCurrent();
 368     gl::ClearDepthf(static_cast&lt;float&gt;(depth));
 369 }
 370 
 371 ExtensionsGL&amp; GraphicsContextGLOpenGL::getExtensions()
 372 {
 373     if (!m_extensions)
 374         m_extensions = makeUnique&lt;ExtensionsGLANGLE&gt;(this);
 375     return *m_extensions;
 376 }
 377 
 378 void GraphicsContextGLOpenGL::readPixels(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, void* data)
 379 {
 380     // FIXME: remove the two glFlush calls when the driver bug is fixed, i.e.,
 381     // all previous rendering calls should be done before reading pixels.
 382     makeContextCurrent();
 383     gl::Flush();
 384     auto attrs = contextAttributes();
 385     if (attrs.antialias &amp;&amp; m_state.boundFBO == m_multisampleFBO) {
 386         resolveMultisamplingIfNecessary(IntRect(x, y, width, height));
 387         gl::BindFramebuffer(GraphicsContextGL::FRAMEBUFFER, m_fbo);
 388         gl::Flush();
 389     }
 390     gl::ReadPixels(x, y, width, height, format, type, data);
 391     if (attrs.antialias &amp;&amp; m_state.boundFBO == m_multisampleFBO)
 392         gl::BindFramebuffer(GraphicsContextGL::FRAMEBUFFER, m_multisampleFBO);
 393 
 394 #if PLATFORM(MAC)
 395     if (!attrs.alpha &amp;&amp; (format == GraphicsContextGL::RGBA || format == GraphicsContextGL::BGRA) &amp;&amp; (m_state.boundFBO == m_fbo || (attrs.antialias &amp;&amp; m_state.boundFBO == m_multisampleFBO)))
 396         wipeAlphaChannelFromPixels(width, height, static_cast&lt;unsigned char*&gt;(data));
 397 #endif
 398 }
 399 
 400 
 401 // The contents of GraphicsContextGLOpenGLCommon follow, ported to use ANGLE.
 402 
 403 void GraphicsContextGLOpenGL::validateDepthStencil(const char* packedDepthStencilExtension)
 404 {
 405     ExtensionsGL&amp; extensions = getExtensions();
 406     auto attrs = contextAttributes();
 407 
 408     if (attrs.stencil) {
 409         if (extensions.supports(packedDepthStencilExtension)) {
 410             extensions.ensureEnabled(packedDepthStencilExtension);
 411             // Force depth if stencil is true.
 412             attrs.depth = true;
 413         } else
 414             attrs.stencil = false;
 415         setContextAttributes(attrs);
 416     }
 417     if (attrs.antialias) {
 418         // FIXME: must adjust this when upgrading to WebGL 2.0 / OpenGL ES 3.0 support.
 419         if (!extensions.supports(&quot;GL_ANGLE_framebuffer_multisample&quot;) || !extensions.supports(&quot;GL_ANGLE_framebuffer_blit&quot;) || !extensions.supports(&quot;GL_OES_rgb8_rgba8&quot;)) {
 420             attrs.antialias = false;
 421             setContextAttributes(attrs);
 422         } else {
 423             extensions.ensureEnabled(&quot;GL_ANGLE_framebuffer_multisample&quot;);
 424             extensions.ensureEnabled(&quot;GL_ANGLE_framebuffer_blit&quot;);
 425             extensions.ensureEnabled(&quot;GL_OES_rgb8_rgba8&quot;);
 426         }
 427     }
 428 }
 429 
 430 void GraphicsContextGLOpenGL::paintRenderingResultsToCanvas(ImageBuffer* imageBuffer)
 431 {
 432     Checked&lt;int, RecordOverflow&gt; rowBytes = Checked&lt;int, RecordOverflow&gt;(m_currentWidth) * 4;
 433     if (rowBytes.hasOverflowed())
 434         return;
 435 
 436     Checked&lt;int, RecordOverflow&gt; totalBytesChecked = rowBytes * m_currentHeight;
 437     if (totalBytesChecked.hasOverflowed())
 438         return;
 439     int totalBytes = totalBytesChecked.unsafeGet();
 440 
 441     auto pixels = makeUniqueArray&lt;unsigned char&gt;(totalBytes);
 442     if (!pixels)
 443         return;
 444 
 445     readRenderingResults(pixels.get(), totalBytes);
 446 
 447     if (!contextAttributes().premultipliedAlpha) {
 448         for (int i = 0; i &lt; totalBytes; i += 4) {
 449             // Premultiply alpha.
 450             pixels[i + 0] = std::min(255, pixels[i + 0] * pixels[i + 3] / 255);
 451             pixels[i + 1] = std::min(255, pixels[i + 1] * pixels[i + 3] / 255);
 452             pixels[i + 2] = std::min(255, pixels[i + 2] * pixels[i + 3] / 255);
 453         }
 454     }
 455 
 456     paintToCanvas(pixels.get(), IntSize(m_currentWidth, m_currentHeight), imageBuffer-&gt;internalSize(), imageBuffer-&gt;context());
 457 
 458 #if PLATFORM(COCOA) &amp;&amp; USE(OPENGL_ES)
 459     // FIXME: work on iOS integration.
 460     presentRenderbuffer();
 461 #endif
 462 }
 463 
 464 bool GraphicsContextGLOpenGL::paintCompositedResultsToCanvas(ImageBuffer*)
 465 {
 466     // Not needed at the moment, so return that nothing was done.
 467     return false;
 468 }
 469 
 470 RefPtr&lt;ImageData&gt; GraphicsContextGLOpenGL::paintRenderingResultsToImageData()
 471 {
 472     // Reading premultiplied alpha would involve unpremultiplying, which is
 473     // lossy.
 474     if (contextAttributes().premultipliedAlpha)
 475         return nullptr;
 476 
 477     auto imageData = ImageData::create(IntSize(m_currentWidth, m_currentHeight));
 478     unsigned char* pixels = imageData-&gt;data()-&gt;data();
 479     Checked&lt;int, RecordOverflow&gt; totalBytesChecked = 4 * Checked&lt;int, RecordOverflow&gt;(m_currentWidth) * Checked&lt;int, RecordOverflow&gt;(m_currentHeight);
 480     if (totalBytesChecked.hasOverflowed())
 481         return imageData;
 482     int totalBytes = totalBytesChecked.unsafeGet();
 483 
 484     readRenderingResults(pixels, totalBytes);
 485 
 486     // Convert to RGBA.
 487     for (int i = 0; i &lt; totalBytes; i += 4)
 488         std::swap(pixels[i], pixels[i + 2]);
 489 
 490     return imageData;
 491 }
 492 
 493 void GraphicsContextGLOpenGL::prepareTexture()
 494 {
 495     if (m_layerComposited)
 496         return;
 497 
 498     makeContextCurrent();
 499 
 500     if (contextAttributes().antialias)
 501         resolveMultisamplingIfNecessary();
 502 
 503 #if USE(COORDINATED_GRAPHICS)
 504     std::swap(m_texture, m_compositorTexture);
 505     std::swap(m_texture, m_intermediateTexture);
 506     gl::BindFramebuffer(GL_FRAMEBUFFER, m_fbo);
 507     gl::FramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_RECTANGLE_ANGLE, m_texture, 0);
 508     gl::Flush();
 509 
 510     if (m_state.boundFBO != m_fbo)
 511         gl::BindFramebuffer(GraphicsContextGL::FRAMEBUFFER, m_state.boundFBO);
 512     else
 513         gl::BindFramebuffer(GraphicsContextGL::FRAMEBUFFER, m_fbo);
 514 #else
 515     gl::Flush();
 516 #endif
 517 }
 518 
 519 void GraphicsContextGLOpenGL::readRenderingResults(unsigned char *pixels, int pixelsSize)
 520 {
 521     if (pixelsSize &lt; m_currentWidth * m_currentHeight * 4)
 522         return;
 523 
 524     makeContextCurrent();
 525 
 526     bool mustRestoreFBO = false;
 527     if (contextAttributes().antialias) {
 528         resolveMultisamplingIfNecessary();
 529         gl::BindFramebuffer(GraphicsContextGL::FRAMEBUFFER, m_fbo);
 530         mustRestoreFBO = true;
 531     } else {
 532         if (m_state.boundFBO != m_fbo) {
 533             mustRestoreFBO = true;
 534             gl::BindFramebuffer(GraphicsContextGL::FRAMEBUFFER, m_fbo);
 535         }
 536     }
 537 
 538     GLint packAlignment = 4;
 539     bool mustRestorePackAlignment = false;
 540     gl::GetIntegerv(GL_PACK_ALIGNMENT, &amp;packAlignment);
 541     if (packAlignment &gt; 4) {
 542         gl::PixelStorei(GL_PACK_ALIGNMENT, 4);
 543         mustRestorePackAlignment = true;
 544     }
 545 
 546     readPixelsAndConvertToBGRAIfNecessary(0, 0, m_currentWidth, m_currentHeight, pixels);
 547 
 548     if (mustRestorePackAlignment)
 549         gl::PixelStorei(GL_PACK_ALIGNMENT, packAlignment);
 550 
 551     if (mustRestoreFBO)
 552         gl::BindFramebuffer(GraphicsContextGL::FRAMEBUFFER, m_state.boundFBO);
 553 }
 554 
 555 void GraphicsContextGLOpenGL::reshape(int width, int height)
 556 {
 557     if (!platformGraphicsContextGL())
 558         return;
 559 
 560     if (width == m_currentWidth &amp;&amp; height == m_currentHeight)
 561         return;
 562 
 563     ASSERT(width &gt;= 0 &amp;&amp; height &gt;= 0);
 564     if (width &lt; 0 || height &lt; 0)
 565         return;
 566 
 567     markContextChanged();
 568 
 569     m_currentWidth = width;
 570     m_currentHeight = height;
 571 
 572     makeContextCurrent();
 573     validateAttributes();
 574 
 575     TemporaryANGLESetting scopedScissor(GL_SCISSOR_TEST, GL_FALSE);
 576     TemporaryANGLESetting scopedDither(GL_DITHER, GL_FALSE);
 577 
 578     bool mustRestoreFBO = reshapeFBOs(IntSize(width, height));
 579     auto attrs = contextAttributes();
 580 
 581     // Initialize renderbuffers to 0.
 582     GLfloat clearColor[] = {0, 0, 0, 0}, clearDepth = 0;
 583     GLint clearStencil = 0;
 584     GLboolean colorMask[] = {GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE}, depthMask = GL_TRUE;
 585     GLuint stencilMask = 0xffffffff, stencilMaskBack = 0xffffffff;
 586     GLbitfield clearMask = GL_COLOR_BUFFER_BIT;
 587     gl::GetFloatv(GL_COLOR_CLEAR_VALUE, clearColor);
 588     gl::ClearColor(0, 0, 0, 0);
 589     gl::GetBooleanv(GL_COLOR_WRITEMASK, colorMask);
 590     gl::ColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
 591     if (attrs.depth) {
 592         gl::GetFloatv(GL_DEPTH_CLEAR_VALUE, &amp;clearDepth);
 593         GraphicsContextGLOpenGL::clearDepth(1);
 594         gl::GetBooleanv(GL_DEPTH_WRITEMASK, &amp;depthMask);
 595         gl::DepthMask(GL_TRUE);
 596         clearMask |= GL_DEPTH_BUFFER_BIT;
 597     }
 598     if (attrs.stencil) {
 599         gl::GetIntegerv(GL_STENCIL_CLEAR_VALUE, &amp;clearStencil);
 600         gl::ClearStencil(0);
 601         gl::GetIntegerv(GL_STENCIL_WRITEMASK, reinterpret_cast&lt;GLint*&gt;(&amp;stencilMask));
 602         gl::GetIntegerv(GL_STENCIL_BACK_WRITEMASK, reinterpret_cast&lt;GLint*&gt;(&amp;stencilMaskBack));
 603         gl::StencilMaskSeparate(GL_FRONT, 0xffffffff);
 604         gl::StencilMaskSeparate(GL_BACK, 0xffffffff);
 605         clearMask |= GL_STENCIL_BUFFER_BIT;
 606     }
 607 
 608     gl::Clear(clearMask);
 609 
 610     gl::ClearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
 611     gl::ColorMask(colorMask[0], colorMask[1], colorMask[2], colorMask[3]);
 612     if (attrs.depth) {
 613         GraphicsContextGLOpenGL::clearDepth(clearDepth);
 614         gl::DepthMask(depthMask);
 615     }
 616     if (attrs.stencil) {
 617         gl::ClearStencil(clearStencil);
 618         gl::StencilMaskSeparate(GL_FRONT, stencilMask);
 619         gl::StencilMaskSeparate(GL_BACK, stencilMaskBack);
 620     }
 621 
 622     if (mustRestoreFBO)
 623         gl::BindFramebuffer(GraphicsContextGL::FRAMEBUFFER, m_state.boundFBO);
 624 
 625     gl::Flush();
 626 }
 627 
 628 IntSize GraphicsContextGLOpenGL::getInternalFramebufferSize() const
 629 {
 630     return IntSize(m_currentWidth, m_currentHeight);
 631 }
 632 
 633 void GraphicsContextGLOpenGL::activeTexture(GCGLenum texture)
 634 {
 635     makeContextCurrent();
 636     m_state.activeTextureUnit = texture;
 637     gl::ActiveTexture(texture);
 638 }
 639 
 640 void GraphicsContextGLOpenGL::attachShader(PlatformGLObject program, PlatformGLObject shader)
 641 {
 642     ASSERT(program);
 643     ASSERT(shader);
 644     makeContextCurrent();
 645     gl::AttachShader(program, shader);
 646 }
 647 
 648 void GraphicsContextGLOpenGL::bindAttribLocation(PlatformGLObject program, GCGLuint index, const String&amp; name)
 649 {
 650     ASSERT(program);
 651     makeContextCurrent();
 652     gl::BindAttribLocation(program, index, name.utf8().data());
 653 }
 654 
 655 void GraphicsContextGLOpenGL::bindBuffer(GCGLenum target, PlatformGLObject buffer)
 656 {
 657     makeContextCurrent();
 658     gl::BindBuffer(target, buffer);
 659 }
 660 
 661 void GraphicsContextGLOpenGL::bindFramebuffer(GCGLenum target, PlatformGLObject buffer)
 662 {
 663     makeContextCurrent();
 664     GLuint fbo;
 665     if (buffer)
 666         fbo = buffer;
 667     else
 668         fbo = (contextAttributes().antialias ? m_multisampleFBO : m_fbo);
 669     if (fbo != m_state.boundFBO) {
 670         gl::BindFramebuffer(target, fbo);
 671         m_state.boundFBO = fbo;
 672     }
 673 }
 674 
 675 void GraphicsContextGLOpenGL::bindRenderbuffer(GCGLenum target, PlatformGLObject renderbuffer)
 676 {
 677     makeContextCurrent();
 678     gl::BindRenderbuffer(target, renderbuffer);
 679 }
 680 
 681 
 682 void GraphicsContextGLOpenGL::bindTexture(GCGLenum target, PlatformGLObject texture)
 683 {
 684     makeContextCurrent();
 685     m_state.setBoundTexture(m_state.activeTextureUnit, texture, target);
 686     gl::BindTexture(target, texture);
 687 }
 688 
 689 void GraphicsContextGLOpenGL::blendColor(GCGLclampf red, GCGLclampf green, GCGLclampf blue, GCGLclampf alpha)
 690 {
 691     makeContextCurrent();
 692     gl::BlendColor(red, green, blue, alpha);
 693 }
 694 
 695 void GraphicsContextGLOpenGL::blendEquation(GCGLenum mode)
 696 {
 697     makeContextCurrent();
 698     gl::BlendEquation(mode);
 699 }
 700 
 701 void GraphicsContextGLOpenGL::blendEquationSeparate(GCGLenum modeRGB, GCGLenum modeAlpha)
 702 {
 703     makeContextCurrent();
 704     gl::BlendEquationSeparate(modeRGB, modeAlpha);
 705 }
 706 
 707 
 708 void GraphicsContextGLOpenGL::blendFunc(GCGLenum sfactor, GCGLenum dfactor)
 709 {
 710     makeContextCurrent();
 711     gl::BlendFunc(sfactor, dfactor);
 712 }
 713 
 714 void GraphicsContextGLOpenGL::blendFuncSeparate(GCGLenum srcRGB, GCGLenum dstRGB, GCGLenum srcAlpha, GCGLenum dstAlpha)
 715 {
 716     makeContextCurrent();
 717     gl::BlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha);
 718 }
 719 
 720 void GraphicsContextGLOpenGL::bufferData(GCGLenum target, GCGLsizeiptr size, GCGLenum usage)
 721 {
 722     makeContextCurrent();
 723     gl::BufferData(target, size, 0, usage);
 724 }
 725 
 726 void GraphicsContextGLOpenGL::bufferData(GCGLenum target, GCGLsizeiptr size, const void* data, GCGLenum usage)
 727 {
 728     makeContextCurrent();
 729     gl::BufferData(target, size, data, usage);
 730 }
 731 
 732 void GraphicsContextGLOpenGL::bufferSubData(GCGLenum target, GCGLintptr offset, GCGLsizeiptr size, const void* data)
 733 {
 734     makeContextCurrent();
 735     gl::BufferSubData(target, offset, size, data);
 736 }
 737 
 738 void* GraphicsContextGLOpenGL::mapBufferRange(GCGLenum target, GCGLintptr offset, GCGLsizeiptr length, GCGLbitfield access)
 739 {
 740     makeContextCurrent();
 741     return gl::MapBufferRange(target, offset, length, access);
 742 }
 743 
 744 GCGLboolean GraphicsContextGLOpenGL::unmapBuffer(GCGLenum target)
 745 {
 746     makeContextCurrent();
 747     return gl::UnmapBuffer(target);
 748 }
 749 
 750 void GraphicsContextGLOpenGL::copyBufferSubData(GCGLenum readTarget, GCGLenum writeTarget, GCGLintptr readOffset, GCGLintptr writeOffset, GCGLsizeiptr size)
 751 {
 752     makeContextCurrent();
 753     gl::CopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);
 754 }
 755 
 756 void GraphicsContextGLOpenGL::getInternalformativ(GCGLenum target, GCGLenum internalformat, GCGLenum pname, GCGLsizei bufSize, GCGLint* params)
 757 {
 758     makeContextCurrent();
 759     gl::GetInternalformativ(target, internalformat, pname, bufSize, params);
 760 }
 761 
 762 void GraphicsContextGLOpenGL::renderbufferStorageMultisample(GCGLenum target, GCGLsizei samples, GCGLenum internalformat, GCGLsizei width, GCGLsizei height)
 763 {
 764     makeContextCurrent();
 765     gl::RenderbufferStorageMultisample(target, samples, internalformat, width, height);
 766 }
 767 
 768 void GraphicsContextGLOpenGL::texStorage2D(GCGLenum target, GCGLsizei levels, GCGLenum internalformat, GCGLsizei width, GCGLsizei height)
 769 {
 770     makeContextCurrent();
 771     gl::TexStorage2D(target, levels, internalformat, width, height);
 772     m_state.textureSeedCount.add(m_state.currentBoundTexture());
 773 }
 774 
 775 void GraphicsContextGLOpenGL::texStorage3D(GCGLenum target, GCGLsizei levels, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth)
 776 {
 777     makeContextCurrent();
 778     gl::TexStorage3D(target, levels, internalformat, width, height, depth);
 779     m_state.textureSeedCount.add(m_state.currentBoundTexture());
 780 }
 781 
 782 void GraphicsContextGLOpenGL::getActiveUniforms(PlatformGLObject program, const Vector&lt;GCGLuint&gt;&amp; uniformIndices, GCGLenum pname, Vector&lt;GCGLint&gt;&amp; params)
 783 {
 784     ASSERT(program);
 785     makeContextCurrent();
 786 
 787     gl::GetActiveUniformsiv(program, uniformIndices.size(), uniformIndices.data(), pname, params.data());
 788 }
 789 
 790 GCGLenum GraphicsContextGLOpenGL::checkFramebufferStatus(GCGLenum target)
 791 {
 792     makeContextCurrent();
 793     return gl::CheckFramebufferStatus(target);
 794 }
 795 
 796 void GraphicsContextGLOpenGL::clearColor(GCGLclampf r, GCGLclampf g, GCGLclampf b, GCGLclampf a)
 797 {
 798     makeContextCurrent();
 799     gl::ClearColor(r, g, b, a);
 800 }
 801 
 802 void GraphicsContextGLOpenGL::clear(GCGLbitfield mask)
 803 {
 804     makeContextCurrent();
 805     gl::Clear(mask);
 806     checkGPUStatus();
 807 }
 808 
 809 void GraphicsContextGLOpenGL::clearStencil(GCGLint s)
 810 {
 811     makeContextCurrent();
 812     gl::ClearStencil(s);
 813 }
 814 
 815 void GraphicsContextGLOpenGL::colorMask(GCGLboolean red, GCGLboolean green, GCGLboolean blue, GCGLboolean alpha)
 816 {
 817     makeContextCurrent();
 818     gl::ColorMask(red, green, blue, alpha);
 819 }
 820 
 821 void GraphicsContextGLOpenGL::compileShader(PlatformGLObject shader)
 822 {
 823     ASSERT(shader);
 824     makeContextCurrent();
 825     // We need the ANGLE_texture_rectangle extension to support IOSurface
 826     // backbuffers, but we don&#39;t want it exposed to WebGL user shaders.
 827     // Temporarily disable it during shader compilation.
 828     gl::Disable(GL_TEXTURE_RECTANGLE_ANGLE);
 829     gl::CompileShader(shader);
 830     gl::Enable(GL_TEXTURE_RECTANGLE_ANGLE);
 831 }
 832 
 833 void GraphicsContextGLOpenGL::compileShaderDirect(PlatformGLObject shader)
 834 {
 835     ASSERT(shader);
 836     makeContextCurrent();
 837     gl::CompileShader(shader);
 838 }
 839 
 840 void GraphicsContextGLOpenGL::copyTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLint border)
 841 {
 842     makeContextCurrent();
 843     auto attrs = contextAttributes();
 844 
 845     if (attrs.antialias &amp;&amp; m_state.boundFBO == m_multisampleFBO) {
 846         resolveMultisamplingIfNecessary(IntRect(x, y, width, height));
 847         gl::BindFramebuffer(GraphicsContextGL::FRAMEBUFFER, m_fbo);
 848     }
 849     gl::CopyTexImage2D(target, level, internalformat, x, y, width, height, border);
 850     if (attrs.antialias &amp;&amp; m_state.boundFBO == m_multisampleFBO)
 851         gl::BindFramebuffer(GraphicsContextGL::FRAMEBUFFER, m_multisampleFBO);
 852 }
 853 
 854 void GraphicsContextGLOpenGL::copyTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)
 855 {
 856     makeContextCurrent();
 857     auto attrs = contextAttributes();
 858 
 859     if (attrs.antialias &amp;&amp; m_state.boundFBO == m_multisampleFBO) {
 860         resolveMultisamplingIfNecessary(IntRect(x, y, width, height));
 861         gl::BindFramebuffer(GraphicsContextGL::FRAMEBUFFER, m_fbo);
 862     }
 863     gl::CopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
 864     if (attrs.antialias &amp;&amp; m_state.boundFBO == m_multisampleFBO)
 865         gl::BindFramebuffer(GraphicsContextGL::FRAMEBUFFER, m_multisampleFBO);
 866 }
 867 
 868 void GraphicsContextGLOpenGL::cullFace(GCGLenum mode)
 869 {
 870     makeContextCurrent();
 871     gl::CullFace(mode);
 872 }
 873 
 874 void GraphicsContextGLOpenGL::depthFunc(GCGLenum func)
 875 {
 876     makeContextCurrent();
 877     gl::DepthFunc(func);
 878 }
 879 
 880 void GraphicsContextGLOpenGL::depthMask(GCGLboolean flag)
 881 {
 882     makeContextCurrent();
 883     gl::DepthMask(flag);
 884 }
 885 
 886 void GraphicsContextGLOpenGL::detachShader(PlatformGLObject program, PlatformGLObject shader)
 887 {
 888     ASSERT(program);
 889     ASSERT(shader);
 890     makeContextCurrent();
 891     gl::DetachShader(program, shader);
 892 }
 893 
 894 void GraphicsContextGLOpenGL::disable(GCGLenum cap)
 895 {
 896     makeContextCurrent();
 897     gl::Disable(cap);
 898 }
 899 
 900 void GraphicsContextGLOpenGL::disableVertexAttribArray(GCGLuint index)
 901 {
 902     makeContextCurrent();
 903     gl::DisableVertexAttribArray(index);
 904 }
 905 
 906 void GraphicsContextGLOpenGL::drawArrays(GCGLenum mode, GCGLint first, GCGLsizei count)
 907 {
 908     makeContextCurrent();
 909     gl::DrawArrays(mode, first, count);
 910     checkGPUStatus();
 911 }
 912 
 913 void GraphicsContextGLOpenGL::drawElements(GCGLenum mode, GCGLsizei count, GCGLenum type, GCGLintptr offset)
 914 {
 915     makeContextCurrent();
 916     gl::DrawElements(mode, count, type, reinterpret_cast&lt;GLvoid*&gt;(static_cast&lt;intptr_t&gt;(offset)));
 917     checkGPUStatus();
 918 }
 919 
 920 void GraphicsContextGLOpenGL::enable(GCGLenum cap)
 921 {
 922     makeContextCurrent();
 923     gl::Enable(cap);
 924 }
 925 
 926 void GraphicsContextGLOpenGL::enableVertexAttribArray(GCGLuint index)
 927 {
 928     makeContextCurrent();
 929     gl::EnableVertexAttribArray(index);
 930 }
 931 
 932 void GraphicsContextGLOpenGL::finish()
 933 {
 934     makeContextCurrent();
 935     gl::Finish();
 936 }
 937 
 938 void GraphicsContextGLOpenGL::flush()
 939 {
 940     makeContextCurrent();
 941     gl::Flush();
 942 }
 943 
 944 void GraphicsContextGLOpenGL::framebufferRenderbuffer(GCGLenum target, GCGLenum attachment, GCGLenum renderbuffertarget, PlatformGLObject buffer)
 945 {
 946     makeContextCurrent();
 947     gl::FramebufferRenderbuffer(target, attachment, renderbuffertarget, buffer);
 948 }
 949 
 950 void GraphicsContextGLOpenGL::framebufferTexture2D(GCGLenum target, GCGLenum attachment, GCGLenum textarget, PlatformGLObject texture, GCGLint level)
 951 {
 952     makeContextCurrent();
 953     gl::FramebufferTexture2D(target, attachment, textarget, texture, level);
 954     m_state.textureSeedCount.add(m_state.currentBoundTexture());
 955 }
 956 
 957 void GraphicsContextGLOpenGL::frontFace(GCGLenum mode)
 958 {
 959     makeContextCurrent();
 960     gl::FrontFace(mode);
 961 }
 962 
 963 void GraphicsContextGLOpenGL::generateMipmap(GCGLenum target)
 964 {
 965     makeContextCurrent();
 966     gl::GenerateMipmap(target);
 967 }
 968 
 969 bool GraphicsContextGLOpenGL::getActiveAttribImpl(PlatformGLObject program, GCGLuint index, ActiveInfo&amp; info)
 970 {
 971     if (!program) {
 972         synthesizeGLError(INVALID_VALUE);
 973         return false;
 974     }
 975     makeContextCurrent();
 976     GLint maxAttributeSize = 0;
 977     gl::GetProgramiv(program, GL_ACTIVE_ATTRIBUTE_MAX_LENGTH, &amp;maxAttributeSize);
 978     Vector&lt;GLchar&gt; name(maxAttributeSize); // GL_ACTIVE_ATTRIBUTE_MAX_LENGTH includes null termination.
 979     GLsizei nameLength = 0;
 980     GLint size = 0;
 981     GLenum type = 0;
 982     gl::GetActiveAttrib(program, index, maxAttributeSize, &amp;nameLength, &amp;size, &amp;type, name.data());
 983     if (!nameLength)
 984         return false;
 985 
 986     info.name = String(name.data(), nameLength);
 987     info.type = type;
 988     info.size = size;
 989     return true;
 990 }
 991 
 992 bool GraphicsContextGLOpenGL::getActiveAttrib(PlatformGLObject program, GCGLuint index, ActiveInfo&amp; info)
 993 {
 994     return getActiveAttribImpl(program, index, info);
 995 }
 996 
 997 bool GraphicsContextGLOpenGL::getActiveUniformImpl(PlatformGLObject program, GCGLuint index, ActiveInfo&amp; info)
 998 {
 999     if (!program) {
1000         synthesizeGLError(INVALID_VALUE);
1001         return false;
1002     }
1003 
1004     makeContextCurrent();
1005     GLint maxUniformSize = 0;
1006     gl::GetProgramiv(program, GL_ACTIVE_UNIFORM_MAX_LENGTH, &amp;maxUniformSize);
1007 
1008     Vector&lt;GLchar&gt; name(maxUniformSize); // GL_ACTIVE_UNIFORM_MAX_LENGTH includes null termination.
1009     GLsizei nameLength = 0;
1010     GLint size = 0;
1011     GLenum type = 0;
1012     gl::GetActiveUniform(program, index, maxUniformSize, &amp;nameLength, &amp;size, &amp;type, name.data());
1013     if (!nameLength)
1014         return false;
1015 
1016     info.name = String(name.data(), nameLength);
1017     info.type = type;
1018     info.size = size;
1019     return true;
1020 }
1021 
1022 bool GraphicsContextGLOpenGL::getActiveUniform(PlatformGLObject program, GCGLuint index, ActiveInfo&amp; info)
1023 {
1024     return getActiveUniformImpl(program, index, info);
1025 }
1026 
1027 void GraphicsContextGLOpenGL::getAttachedShaders(PlatformGLObject program, GCGLsizei maxCount, GCGLsizei* count, PlatformGLObject* shaders)
1028 {
1029     if (!program) {
1030         synthesizeGLError(INVALID_VALUE);
1031         return;
1032     }
1033     makeContextCurrent();
1034     gl::GetAttachedShaders(program, maxCount, count, shaders);
1035 }
1036 
1037 int GraphicsContextGLOpenGL::getAttribLocation(PlatformGLObject program, const String&amp; name)
1038 {
1039     if (!program)
1040         return -1;
1041 
1042     makeContextCurrent();
1043 
1044     return gl::GetAttribLocation(program, name.utf8().data());
1045 }
1046 
1047 int GraphicsContextGLOpenGL::getAttribLocationDirect(PlatformGLObject program, const String&amp; name)
1048 {
1049     return getAttribLocation(program, name);
1050 }
1051 
1052 bool GraphicsContextGLOpenGL::moveErrorsToSyntheticErrorList()
1053 {
1054     makeContextCurrent();
1055     bool movedAnError = false;
1056 
1057     // Set an arbitrary limit of 100 here to avoid creating a hang if
1058     // a problem driver has a bug that causes it to never clear the error.
1059     // Otherwise, we would just loop until we got NO_ERROR.
1060     for (unsigned i = 0; i &lt; 100; ++i) {
1061         GCGLenum error = gl::GetError();
1062         if (error == NO_ERROR)
1063             break;
1064         m_syntheticErrors.add(error);
1065         movedAnError = true;
1066     }
1067 
1068     return movedAnError;
1069 }
1070 
1071 GCGLenum GraphicsContextGLOpenGL::getError()
1072 {
1073     if (!m_syntheticErrors.isEmpty()) {
1074         // Need to move the current errors to the synthetic error list in case
1075         // that error is already there, since the expected behavior of both
1076         // glGetError and getError is to only report each error code once.
1077         moveErrorsToSyntheticErrorList();
1078         return m_syntheticErrors.takeFirst();
1079     }
1080 
1081     makeContextCurrent();
1082     return gl::GetError();
1083 }
1084 
1085 String GraphicsContextGLOpenGL::getString(GCGLenum name)
1086 {
1087     makeContextCurrent();
1088     return String(reinterpret_cast&lt;const char*&gt;(gl::GetString(name)));
1089 }
1090 
1091 void GraphicsContextGLOpenGL::hint(GCGLenum target, GCGLenum mode)
1092 {
1093     makeContextCurrent();
1094     gl::Hint(target, mode);
1095 }
1096 
1097 GCGLboolean GraphicsContextGLOpenGL::isBuffer(PlatformGLObject buffer)
1098 {
1099     if (!buffer)
1100         return GL_FALSE;
1101 
1102     makeContextCurrent();
1103     return gl::IsBuffer(buffer);
1104 }
1105 
1106 GCGLboolean GraphicsContextGLOpenGL::isEnabled(GCGLenum cap)
1107 {
1108     makeContextCurrent();
1109     return gl::IsEnabled(cap);
1110 }
1111 
1112 GCGLboolean GraphicsContextGLOpenGL::isFramebuffer(PlatformGLObject framebuffer)
1113 {
1114     if (!framebuffer)
1115         return GL_FALSE;
1116 
1117     makeContextCurrent();
1118     return gl::IsFramebuffer(framebuffer);
1119 }
1120 
1121 GCGLboolean GraphicsContextGLOpenGL::isProgram(PlatformGLObject program)
1122 {
1123     if (!program)
1124         return GL_FALSE;
1125 
1126     makeContextCurrent();
1127     return gl::IsProgram(program);
1128 }
1129 
1130 GCGLboolean GraphicsContextGLOpenGL::isRenderbuffer(PlatformGLObject renderbuffer)
1131 {
1132     if (!renderbuffer)
1133         return GL_FALSE;
1134 
1135     makeContextCurrent();
1136     return gl::IsRenderbuffer(renderbuffer);
1137 }
1138 
1139 GCGLboolean GraphicsContextGLOpenGL::isShader(PlatformGLObject shader)
1140 {
1141     if (!shader)
1142         return GL_FALSE;
1143 
1144     makeContextCurrent();
1145     return gl::IsShader(shader);
1146 }
1147 
1148 GCGLboolean GraphicsContextGLOpenGL::isTexture(PlatformGLObject texture)
1149 {
1150     if (!texture)
1151         return GL_FALSE;
1152 
1153     makeContextCurrent();
1154     return gl::IsTexture(texture);
1155 }
1156 
1157 void GraphicsContextGLOpenGL::lineWidth(GCGLfloat width)
1158 {
1159     makeContextCurrent();
1160     gl::LineWidth(width);
1161 }
1162 
1163 void GraphicsContextGLOpenGL::linkProgram(PlatformGLObject program)
1164 {
1165     ASSERT(program);
1166     makeContextCurrent();
1167     gl::LinkProgram(program);
1168 }
1169 
1170 void GraphicsContextGLOpenGL::pixelStorei(GCGLenum pname, GCGLint param)
1171 {
1172     makeContextCurrent();
1173     gl::PixelStorei(pname, param);
1174 }
1175 
1176 void GraphicsContextGLOpenGL::polygonOffset(GCGLfloat factor, GCGLfloat units)
1177 {
1178     makeContextCurrent();
1179     gl::PolygonOffset(factor, units);
1180 }
1181 
1182 void GraphicsContextGLOpenGL::sampleCoverage(GCGLclampf value, GCGLboolean invert)
1183 {
1184     makeContextCurrent();
1185     gl::SampleCoverage(value, invert);
1186 }
1187 
1188 void GraphicsContextGLOpenGL::scissor(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)
1189 {
1190     makeContextCurrent();
1191     gl::Scissor(x, y, width, height);
1192 }
1193 
1194 void GraphicsContextGLOpenGL::shaderSource(PlatformGLObject shader, const String&amp; string)
1195 {
1196     ASSERT(shader);
1197 
1198     makeContextCurrent();
1199 
1200     const CString&amp; shaderSourceCString = string.utf8();
1201     const char* shaderSourcePtr = shaderSourceCString.data();
1202     int shaderSourceLength = shaderSourceCString.length();
1203     gl::ShaderSource(shader, 1, &amp;shaderSourcePtr, &amp;shaderSourceLength);
1204 }
1205 
1206 void GraphicsContextGLOpenGL::stencilFunc(GCGLenum func, GCGLint ref, GCGLuint mask)
1207 {
1208     makeContextCurrent();
1209     gl::StencilFunc(func, ref, mask);
1210 }
1211 
1212 void GraphicsContextGLOpenGL::stencilFuncSeparate(GCGLenum face, GCGLenum func, GCGLint ref, GCGLuint mask)
1213 {
1214     makeContextCurrent();
1215     gl::StencilFuncSeparate(face, func, ref, mask);
1216 }
1217 
1218 void GraphicsContextGLOpenGL::stencilMask(GCGLuint mask)
1219 {
1220     makeContextCurrent();
1221     gl::StencilMask(mask);
1222 }
1223 
1224 void GraphicsContextGLOpenGL::stencilMaskSeparate(GCGLenum face, GCGLuint mask)
1225 {
1226     makeContextCurrent();
1227     gl::StencilMaskSeparate(face, mask);
1228 }
1229 
1230 void GraphicsContextGLOpenGL::stencilOp(GCGLenum fail, GCGLenum zfail, GCGLenum zpass)
1231 {
1232     makeContextCurrent();
1233     gl::StencilOp(fail, zfail, zpass);
1234 }
1235 
1236 void GraphicsContextGLOpenGL::stencilOpSeparate(GCGLenum face, GCGLenum fail, GCGLenum zfail, GCGLenum zpass)
1237 {
1238     makeContextCurrent();
1239     gl::StencilOpSeparate(face, fail, zfail, zpass);
1240 }
1241 
1242 void GraphicsContextGLOpenGL::texParameterf(GCGLenum target, GCGLenum pname, GCGLfloat value)
1243 {
1244     makeContextCurrent();
1245     gl::TexParameterf(target, pname, value);
1246 }
1247 
1248 void GraphicsContextGLOpenGL::texParameteri(GCGLenum target, GCGLenum pname, GCGLint value)
1249 {
1250     makeContextCurrent();
1251     gl::TexParameteri(target, pname, value);
1252 }
1253 
1254 void GraphicsContextGLOpenGL::uniform1f(GCGLint location, GCGLfloat v0)
1255 {
1256     makeContextCurrent();
1257     gl::Uniform1f(location, v0);
1258 }
1259 
1260 void GraphicsContextGLOpenGL::uniform1fv(GCGLint location, GCGLsizei size, const GCGLfloat* array)
1261 {
1262     makeContextCurrent();
1263     gl::Uniform1fv(location, size, array);
1264 }
1265 
1266 void GraphicsContextGLOpenGL::uniform2f(GCGLint location, GCGLfloat v0, GCGLfloat v1)
1267 {
1268     makeContextCurrent();
1269     gl::Uniform2f(location, v0, v1);
1270 }
1271 
1272 void GraphicsContextGLOpenGL::uniform2fv(GCGLint location, GCGLsizei size, const GCGLfloat* array)
1273 {
1274     // FIXME: length needs to be a multiple of 2.
1275     makeContextCurrent();
1276     gl::Uniform2fv(location, size, array);
1277 }
1278 
1279 void GraphicsContextGLOpenGL::uniform3f(GCGLint location, GCGLfloat v0, GCGLfloat v1, GCGLfloat v2)
1280 {
1281     makeContextCurrent();
1282     gl::Uniform3f(location, v0, v1, v2);
1283 }
1284 
1285 void GraphicsContextGLOpenGL::uniform3fv(GCGLint location, GCGLsizei size, const GCGLfloat* array)
1286 {
1287     // FIXME: length needs to be a multiple of 3.
1288     makeContextCurrent();
1289     gl::Uniform3fv(location, size, array);
1290 }
1291 
1292 void GraphicsContextGLOpenGL::uniform4f(GCGLint location, GCGLfloat v0, GCGLfloat v1, GCGLfloat v2, GCGLfloat v3)
1293 {
1294     makeContextCurrent();
1295     gl::Uniform4f(location, v0, v1, v2, v3);
1296 }
1297 
1298 void GraphicsContextGLOpenGL::uniform4fv(GCGLint location, GCGLsizei size, const GCGLfloat* array)
1299 {
1300     // FIXME: length needs to be a multiple of 4.
1301     makeContextCurrent();
1302     gl::Uniform4fv(location, size, array);
1303 }
1304 
1305 void GraphicsContextGLOpenGL::uniform1i(GCGLint location, GCGLint v0)
1306 {
1307     makeContextCurrent();
1308     gl::Uniform1i(location, v0);
1309 }
1310 
1311 void GraphicsContextGLOpenGL::uniform1iv(GCGLint location, GCGLsizei size, const GCGLint* array)
1312 {
1313     makeContextCurrent();
1314     gl::Uniform1iv(location, size, array);
1315 }
1316 
1317 void GraphicsContextGLOpenGL::uniform2i(GCGLint location, GCGLint v0, GCGLint v1)
1318 {
1319     makeContextCurrent();
1320     gl::Uniform2i(location, v0, v1);
1321 }
1322 
1323 void GraphicsContextGLOpenGL::uniform2iv(GCGLint location, GCGLsizei size, const GCGLint* array)
1324 {
1325     // FIXME: length needs to be a multiple of 2.
1326     makeContextCurrent();
1327     gl::Uniform2iv(location, size, array);
1328 }
1329 
1330 void GraphicsContextGLOpenGL::uniform3i(GCGLint location, GCGLint v0, GCGLint v1, GCGLint v2)
1331 {
1332     makeContextCurrent();
1333     gl::Uniform3i(location, v0, v1, v2);
1334 }
1335 
1336 void GraphicsContextGLOpenGL::uniform3iv(GCGLint location, GCGLsizei size, const GCGLint* array)
1337 {
1338     // FIXME: length needs to be a multiple of 3.
1339     makeContextCurrent();
1340     gl::Uniform3iv(location, size, array);
1341 }
1342 
1343 void GraphicsContextGLOpenGL::uniform4i(GCGLint location, GCGLint v0, GCGLint v1, GCGLint v2, GCGLint v3)
1344 {
1345     makeContextCurrent();
1346     gl::Uniform4i(location, v0, v1, v2, v3);
1347 }
1348 
1349 void GraphicsContextGLOpenGL::uniform4iv(GCGLint location, GCGLsizei size, const GCGLint* array)
1350 {
1351     // FIXME: length needs to be a multiple of 4.
1352     makeContextCurrent();
1353     gl::Uniform4iv(location, size, array);
1354 }
1355 
1356 void GraphicsContextGLOpenGL::uniformMatrix2fv(GCGLint location, GCGLsizei size, GCGLboolean transpose, const GCGLfloat* array)
1357 {
1358     // FIXME: length needs to be a multiple of 4.
1359     makeContextCurrent();
1360     gl::UniformMatrix2fv(location, size, transpose, array);
1361 }
1362 
1363 void GraphicsContextGLOpenGL::uniformMatrix3fv(GCGLint location, GCGLsizei size, GCGLboolean transpose, const GCGLfloat* array)
1364 {
1365     // FIXME: length needs to be a multiple of 9.
1366     makeContextCurrent();
1367     gl::UniformMatrix3fv(location, size, transpose, array);
1368 }
1369 
1370 void GraphicsContextGLOpenGL::uniformMatrix4fv(GCGLint location, GCGLsizei size, GCGLboolean transpose, const GCGLfloat* array)
1371 {
1372     // FIXME: length needs to be a multiple of 16.
1373     makeContextCurrent();
1374     gl::UniformMatrix4fv(location, size, transpose, array);
1375 }
1376 
1377 void GraphicsContextGLOpenGL::useProgram(PlatformGLObject program)
1378 {
1379     makeContextCurrent();
1380     gl::UseProgram(program);
1381 }
1382 
1383 void GraphicsContextGLOpenGL::validateProgram(PlatformGLObject program)
1384 {
1385     ASSERT(program);
1386 
1387     makeContextCurrent();
1388     gl::ValidateProgram(program);
1389 }
1390 
1391 void GraphicsContextGLOpenGL::vertexAttrib1f(GCGLuint index, GCGLfloat v0)
1392 {
1393     makeContextCurrent();
1394     gl::VertexAttrib1f(index, v0);
1395 }
1396 
1397 void GraphicsContextGLOpenGL::vertexAttrib1fv(GCGLuint index, const GCGLfloat* array)
1398 {
1399     makeContextCurrent();
1400     gl::VertexAttrib1fv(index, array);
1401 }
1402 
1403 void GraphicsContextGLOpenGL::vertexAttrib2f(GCGLuint index, GCGLfloat v0, GCGLfloat v1)
1404 {
1405     makeContextCurrent();
1406     gl::VertexAttrib2f(index, v0, v1);
1407 }
1408 
1409 void GraphicsContextGLOpenGL::vertexAttrib2fv(GCGLuint index, const GCGLfloat* array)
1410 {
1411     makeContextCurrent();
1412     gl::VertexAttrib2fv(index, array);
1413 }
1414 
1415 void GraphicsContextGLOpenGL::vertexAttrib3f(GCGLuint index, GCGLfloat v0, GCGLfloat v1, GCGLfloat v2)
1416 {
1417     makeContextCurrent();
1418     gl::VertexAttrib3f(index, v0, v1, v2);
1419 }
1420 
1421 void GraphicsContextGLOpenGL::vertexAttrib3fv(GCGLuint index, const GCGLfloat* array)
1422 {
1423     makeContextCurrent();
1424     gl::VertexAttrib3fv(index, array);
1425 }
1426 
1427 void GraphicsContextGLOpenGL::vertexAttrib4f(GCGLuint index, GCGLfloat v0, GCGLfloat v1, GCGLfloat v2, GCGLfloat v3)
1428 {
1429     makeContextCurrent();
1430     gl::VertexAttrib4f(index, v0, v1, v2, v3);
1431 }
1432 
1433 void GraphicsContextGLOpenGL::vertexAttrib4fv(GCGLuint index, const GCGLfloat* array)
1434 {
1435     makeContextCurrent();
1436     gl::VertexAttrib4fv(index, array);
1437 }
1438 
1439 void GraphicsContextGLOpenGL::vertexAttribPointer(GCGLuint index, GCGLint size, GCGLenum type, GCGLboolean normalized, GCGLsizei stride, GCGLintptr offset)
1440 {
1441     makeContextCurrent();
1442     gl::VertexAttribPointer(index, size, type, normalized, stride, reinterpret_cast&lt;GLvoid*&gt;(static_cast&lt;intptr_t&gt;(offset)));
1443 }
1444 
1445 void GraphicsContextGLOpenGL::vertexAttribIPointer(GCGLuint index, GCGLint size, GCGLenum type, GCGLsizei stride, GCGLintptr offset)
1446 {
1447     makeContextCurrent();
1448     gl::VertexAttribIPointer(index, size, type, stride, reinterpret_cast&lt;GLvoid*&gt;(static_cast&lt;intptr_t&gt;(offset)));
1449 }
1450 
1451 void GraphicsContextGLOpenGL::viewport(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)
1452 {
1453     makeContextCurrent();
1454     gl::Viewport(x, y, width, height);
1455 }
1456 
1457 PlatformGLObject GraphicsContextGLOpenGL::createVertexArray()
1458 {
1459     makeContextCurrent();
1460     GLuint array = 0;
1461     gl::GenVertexArrays(1, &amp;array);
1462     return array;
1463 }
1464 
1465 void GraphicsContextGLOpenGL::deleteVertexArray(PlatformGLObject array)
1466 {
1467     if (!array)
1468         return;
1469     makeContextCurrent();
1470     gl::DeleteVertexArrays(1, &amp;array);
1471 }
1472 
1473 GCGLboolean GraphicsContextGLOpenGL::isVertexArray(PlatformGLObject array)
1474 {
1475     if (!array)
1476         return GL_FALSE;
1477     makeContextCurrent();
1478     return gl::IsVertexArray(array);
1479 }
1480 
1481 void GraphicsContextGLOpenGL::bindVertexArray(PlatformGLObject array)
1482 {
1483     makeContextCurrent();
1484     gl::BindVertexArray(array);
1485 }
1486 
1487 void GraphicsContextGLOpenGL::getBooleanv(GCGLenum pname, GCGLboolean* value)
1488 {
1489     makeContextCurrent();
1490     gl::GetBooleanv(pname, value);
1491 }
1492 
1493 void GraphicsContextGLOpenGL::getBufferParameteriv(GCGLenum target, GCGLenum pname, GCGLint* value)
1494 {
1495     makeContextCurrent();
1496     gl::GetBufferParameteriv(target, pname, value);
1497 }
1498 
1499 void GraphicsContextGLOpenGL::getFloatv(GCGLenum pname, GCGLfloat* value)
1500 {
1501     makeContextCurrent();
1502     gl::GetFloatv(pname, value);
1503 }
1504 
1505 void GraphicsContextGLOpenGL::getInteger64v(GCGLenum pname, GCGLint64* value)
1506 {
1507     UNUSED_PARAM(pname);
1508     makeContextCurrent();
1509     *value = 0;
1510     // FIXME 141178: Before enabling this we must first switch over to using gl3.h and creating and initialing the WebGL2 context using OpenGL ES 3.0.
1511     // gl::GetInteger64v(pname, value);
1512 }
1513 
1514 void GraphicsContextGLOpenGL::getFramebufferAttachmentParameteriv(GCGLenum target, GCGLenum attachment, GCGLenum pname, GCGLint* value)
1515 {
1516     makeContextCurrent();
1517     if (attachment == DEPTH_STENCIL_ATTACHMENT)
1518         attachment = DEPTH_ATTACHMENT; // Or STENCIL_ATTACHMENT, either works.
1519     gl::GetFramebufferAttachmentParameteriv(target, attachment, pname, value);
1520 }
1521 
1522 void GraphicsContextGLOpenGL::getProgramiv(PlatformGLObject program, GCGLenum pname, GCGLint* value)
1523 {
1524     makeContextCurrent();
1525     gl::GetProgramiv(program, pname, value);
1526 }
1527 
1528 String GraphicsContextGLOpenGL::getUnmangledInfoLog(PlatformGLObject shaders[2], GCGLsizei count, const String&amp; log)
1529 {
1530     UNUSED_PARAM(shaders);
1531     UNUSED_PARAM(count);
1532     LOG(WebGL, &quot;Original ShaderInfoLog:\n%s&quot;, log.utf8().data());
1533 
1534     StringBuilder processedLog;
1535 
1536     // ANGLE inserts a &quot;#extension&quot; line into the shader source that
1537     // causes a warning in some compilers. There is no point showing
1538     // this warning to the user since they didn&#39;t write the code that
1539     // is causing it.
1540     static const NeverDestroyed&lt;String&gt; angleWarning { &quot;WARNING: 0:1: extension &#39;GL_ARB_gpu_shader5&#39; is not supported\n&quot;_s };
1541     int startFrom = log.startsWith(angleWarning) ? angleWarning.get().length() : 0;
1542     processedLog.append(log.substring(startFrom, log.length() - startFrom));
1543 
1544     LOG(WebGL, &quot;Unmangled ShaderInfoLog:\n%s&quot;, processedLog.toString().utf8().data());
1545     return processedLog.toString();
1546 }
1547 
1548 String GraphicsContextGLOpenGL::getProgramInfoLog(PlatformGLObject program)
1549 {
1550     ASSERT(program);
1551 
1552     makeContextCurrent();
1553     GLint length = 0;
1554     gl::GetProgramiv(program, GL_INFO_LOG_LENGTH, &amp;length);
1555     if (!length)
1556         return String();
1557 
1558     GLsizei size = 0;
1559     Vector&lt;GLchar&gt; info(length);
1560     gl::GetProgramInfoLog(program, length, &amp;size, info.data());
1561 
1562     GCGLsizei count;
1563     PlatformGLObject shaders[2];
1564     getAttachedShaders(program, 2, &amp;count, shaders);
1565 
1566     return getUnmangledInfoLog(shaders, count, String(info.data(), size));
1567 }
1568 
1569 void GraphicsContextGLOpenGL::getRenderbufferParameteriv(GCGLenum target, GCGLenum pname, GCGLint* value)
1570 {
1571     makeContextCurrent();
1572     gl::GetRenderbufferParameteriv(target, pname, value);
1573 }
1574 
1575 void GraphicsContextGLOpenGL::getShaderiv(PlatformGLObject shader, GCGLenum pname, GCGLint* value)
1576 {
1577     ASSERT(shader);
1578 
1579     makeContextCurrent();
1580     gl::GetShaderiv(shader, pname, value);
1581 }
1582 
1583 String GraphicsContextGLOpenGL::getShaderInfoLog(PlatformGLObject shader)
1584 {
1585     ASSERT(shader);
1586 
1587     makeContextCurrent();
1588     GLint length = 0;
1589     gl::GetShaderiv(shader, GL_INFO_LOG_LENGTH, &amp;length);
1590     if (!length)
1591         return String();
1592 
1593     GLsizei size = 0;
1594     Vector&lt;GLchar&gt; info(length);
1595     gl::GetShaderInfoLog(shader, length, &amp;size, info.data());
1596 
1597     PlatformGLObject shaders[2] = { shader, 0 };
1598     return getUnmangledInfoLog(shaders, 1, String(info.data(), size));
1599 }
1600 
1601 String GraphicsContextGLOpenGL::getShaderSource(PlatformGLObject)
1602 {
1603     return emptyString();
1604 }
1605 
1606 void GraphicsContextGLOpenGL::getTexParameterfv(GCGLenum target, GCGLenum pname, GCGLfloat* value)
1607 {
1608     makeContextCurrent();
1609     gl::GetTexParameterfv(target, pname, value);
1610 }
1611 
1612 void GraphicsContextGLOpenGL::getTexParameteriv(GCGLenum target, GCGLenum pname, GCGLint* value)
1613 {
1614     makeContextCurrent();
1615     gl::GetTexParameteriv(target, pname, value);
1616 }
1617 
1618 void GraphicsContextGLOpenGL::getUniformfv(PlatformGLObject program, GCGLint location, GCGLfloat* value)
1619 {
1620     makeContextCurrent();
1621     gl::GetUniformfv(program, location, value);
1622 }
1623 
1624 void GraphicsContextGLOpenGL::getUniformiv(PlatformGLObject program, GCGLint location, GCGLint* value)
1625 {
1626     makeContextCurrent();
1627     gl::GetUniformiv(program, location, value);
1628 }
1629 
1630 GCGLint GraphicsContextGLOpenGL::getUniformLocation(PlatformGLObject program, const String&amp; name)
1631 {
1632     ASSERT(program);
1633 
1634     makeContextCurrent();
1635     return gl::GetUniformLocation(program, name.utf8().data());
1636 }
1637 
1638 void GraphicsContextGLOpenGL::getVertexAttribfv(GCGLuint index, GCGLenum pname, GCGLfloat* value)
1639 {
1640     makeContextCurrent();
1641     gl::GetVertexAttribfv(index, pname, value);
1642 }
1643 
1644 void GraphicsContextGLOpenGL::getVertexAttribiv(GCGLuint index, GCGLenum pname, GCGLint* value)
1645 {
1646     makeContextCurrent();
1647     gl::GetVertexAttribiv(index, pname, value);
1648 }
1649 
1650 GCGLsizeiptr GraphicsContextGLOpenGL::getVertexAttribOffset(GCGLuint index, GCGLenum pname)
1651 {
1652     makeContextCurrent();
1653 
1654     GLvoid* pointer = 0;
1655     gl::GetVertexAttribPointerv(index, pname, &amp;pointer);
1656     return static_cast&lt;GCGLsizeiptr&gt;(reinterpret_cast&lt;intptr_t&gt;(pointer));
1657 }
1658 
1659 void GraphicsContextGLOpenGL::texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoff, GCGLint yoff, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, const void* pixels)
1660 {
1661     makeContextCurrent();
1662 
1663     // FIXME: we will need to deal with PixelStore params when dealing with image buffers that differ from the subimage size.
1664     gl::TexSubImage2D(target, level, xoff, yoff, width, height, format, type, pixels);
1665     m_state.textureSeedCount.add(m_state.currentBoundTexture());
1666 }
1667 
1668 void GraphicsContextGLOpenGL::compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLsizei imageSize, const void* data)
1669 {
1670     makeContextCurrent();
1671     gl::CompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
1672     m_state.textureSeedCount.add(m_state.currentBoundTexture());
1673 }
1674 
1675 void GraphicsContextGLOpenGL::compressedTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLsizei imageSize, const void* data)
1676 {
1677     makeContextCurrent();
1678     gl::CompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
1679     m_state.textureSeedCount.add(m_state.currentBoundTexture());
1680 }
1681 
1682 PlatformGLObject GraphicsContextGLOpenGL::createBuffer()
1683 {
1684     makeContextCurrent();
1685     GLuint o = 0;
1686     gl::GenBuffers(1, &amp;o);
1687     return o;
1688 }
1689 
1690 PlatformGLObject GraphicsContextGLOpenGL::createFramebuffer()
1691 {
1692     makeContextCurrent();
1693     GLuint o = 0;
1694     gl::GenFramebuffers(1, &amp;o);
1695     return o;
1696 }
1697 
1698 PlatformGLObject GraphicsContextGLOpenGL::createProgram()
1699 {
1700     makeContextCurrent();
1701     return gl::CreateProgram();
1702 }
1703 
1704 PlatformGLObject GraphicsContextGLOpenGL::createRenderbuffer()
1705 {
1706     makeContextCurrent();
1707     GLuint o = 0;
1708     gl::GenRenderbuffers(1, &amp;o);
1709     return o;
1710 }
1711 
1712 PlatformGLObject GraphicsContextGLOpenGL::createShader(GCGLenum type)
1713 {
1714     makeContextCurrent();
1715     return gl::CreateShader((type == FRAGMENT_SHADER) ? GL_FRAGMENT_SHADER : GL_VERTEX_SHADER);
1716 }
1717 
1718 PlatformGLObject GraphicsContextGLOpenGL::createTexture()
1719 {
1720     makeContextCurrent();
1721     GLuint o = 0;
1722     gl::GenTextures(1, &amp;o);
1723     m_state.textureSeedCount.add(o);
1724     return o;
1725 }
1726 
1727 void GraphicsContextGLOpenGL::deleteBuffer(PlatformGLObject buffer)
1728 {
1729     makeContextCurrent();
1730     gl::DeleteBuffers(1, &amp;buffer);
1731 }
1732 
1733 void GraphicsContextGLOpenGL::deleteFramebuffer(PlatformGLObject framebuffer)
1734 {
1735     makeContextCurrent();
1736     if (framebuffer == m_state.boundFBO) {
1737         // Make sure the framebuffer is not going to be used for drawing
1738         // operations after it gets deleted.
1739         bindFramebuffer(FRAMEBUFFER, 0);
1740     }
1741     gl::DeleteFramebuffers(1, &amp;framebuffer);
1742 }
1743 
1744 void GraphicsContextGLOpenGL::deleteProgram(PlatformGLObject program)
1745 {
1746     makeContextCurrent();
1747     gl::DeleteProgram(program);
1748 }
1749 
1750 void GraphicsContextGLOpenGL::deleteRenderbuffer(PlatformGLObject renderbuffer)
1751 {
1752     makeContextCurrent();
1753     gl::DeleteRenderbuffers(1, &amp;renderbuffer);
1754 }
1755 
1756 void GraphicsContextGLOpenGL::deleteShader(PlatformGLObject shader)
1757 {
1758     makeContextCurrent();
1759     gl::DeleteShader(shader);
1760 }
1761 
1762 void GraphicsContextGLOpenGL::deleteTexture(PlatformGLObject texture)
1763 {
1764     makeContextCurrent();
1765     m_state.boundTextureMap.removeIf([texture] (auto&amp; keyValue) {
1766         return keyValue.value.first == texture;
1767     });
1768     gl::DeleteTextures(1, &amp;texture);
1769     m_state.textureSeedCount.removeAll(texture);
1770 }
1771 
1772 void GraphicsContextGLOpenGL::synthesizeGLError(GCGLenum error)
1773 {
1774     // Need to move the current errors to the synthetic error list to
1775     // preserve the order of errors, so a caller to getError will get
1776     // any errors from gl::Error before the error we are synthesizing.
1777     moveErrorsToSyntheticErrorList();
1778     m_syntheticErrors.add(error);
1779 }
1780 
1781 void GraphicsContextGLOpenGL::markContextChanged()
1782 {
1783     m_layerComposited = false;
1784 }
1785 
1786 void GraphicsContextGLOpenGL::markLayerComposited()
1787 {
1788     m_layerComposited = true;
1789 
1790     for (auto* client : copyToVector(m_clients))
1791         client-&gt;didComposite();
1792 }
1793 
1794 bool GraphicsContextGLOpenGL::layerComposited() const
1795 {
1796     return m_layerComposited;
1797 }
1798 
1799 void GraphicsContextGLOpenGL::forceContextLost()
1800 {
1801     for (auto* client : copyToVector(m_clients))
1802         client-&gt;forceContextLost();
1803 }
1804 
1805 void GraphicsContextGLOpenGL::recycleContext()
1806 {
1807     for (auto* client : copyToVector(m_clients))
1808         client-&gt;recycleContext();
1809 }
1810 
1811 void GraphicsContextGLOpenGL::dispatchContextChangedNotification()
1812 {
1813     for (auto* client : copyToVector(m_clients))
1814         client-&gt;dispatchContextChangedNotification();
1815 }
1816 
1817 void GraphicsContextGLOpenGL::texImage2DDirect(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLenum format, GCGLenum type, const void* pixels)
1818 {
1819     makeContextCurrent();
1820     gl::TexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
1821     m_state.textureSeedCount.add(m_state.currentBoundTexture());
1822 }
1823 
1824 void GraphicsContextGLOpenGL::drawArraysInstanced(GCGLenum mode, GCGLint first, GCGLsizei count, GCGLsizei primcount)
1825 {
1826     getExtensions().drawArraysInstanced(mode, first, count, primcount);
1827     checkGPUStatus();
1828 }
1829 
1830 void GraphicsContextGLOpenGL::drawElementsInstanced(GCGLenum mode, GCGLsizei count, GCGLenum type, GCGLintptr offset, GCGLsizei primcount)
1831 {
1832     getExtensions().drawElementsInstanced(mode, count, type, offset, primcount);
1833     checkGPUStatus();
1834 }
1835 
1836 void GraphicsContextGLOpenGL::vertexAttribDivisor(GCGLuint index, GCGLuint divisor)
1837 {
1838     getExtensions().vertexAttribDivisor(index, divisor);
1839 }
1840 
1841 GCGLuint GraphicsContextGLOpenGL::getUniformBlockIndex(PlatformGLObject program, const String&amp; uniformBlockName)
1842 {
1843     UNUSED_PARAM(program);
1844     UNUSED_PARAM(uniformBlockName);
1845 
1846     return 0;
1847 }
1848 
1849 void GraphicsContextGLOpenGL::getActiveUniformBlockiv(PlatformGLObject program, GCGLuint uniformBlockIndex, GCGLenum pname, GCGLint* params)
1850 {
1851     UNUSED_PARAM(program);
1852     UNUSED_PARAM(uniformBlockIndex);
1853     UNUSED_PARAM(pname);
1854     UNUSED_PARAM(params);
1855 }
1856 
1857 String GraphicsContextGLOpenGL::getActiveUniformBlockName(PlatformGLObject program, GCGLuint uniformBlockIndex)
1858 {
1859     UNUSED_PARAM(program);
1860     UNUSED_PARAM(uniformBlockIndex);
1861 
1862     return emptyString();
1863 }
1864 
1865 void GraphicsContextGLOpenGL::uniformBlockBinding(PlatformGLObject program, GCGLuint uniformBlockIndex, GCGLuint uniformBlockBinding)
1866 {
1867     UNUSED_PARAM(program);
1868     UNUSED_PARAM(uniformBlockIndex);
1869     UNUSED_PARAM(uniformBlockBinding);
1870 
1871 }
1872 
1873 // Query Functions
1874 
1875 PlatformGLObject GraphicsContextGLOpenGL::createQuery()
1876 {
1877     makeContextCurrent();
1878     GLuint name = 0;
1879     gl::GenQueries(1, &amp;name);
1880     return name;
1881 }
1882 
1883 void GraphicsContextGLOpenGL::beginQuery(GCGLenum target, PlatformGLObject query)
1884 {
1885     makeContextCurrent();
1886     gl::BeginQuery(target, query);
1887 }
1888 
1889 void GraphicsContextGLOpenGL::endQuery(GCGLenum target)
1890 {
1891     makeContextCurrent();
1892     gl::EndQuery(target);
1893 }
1894 
1895 void GraphicsContextGLOpenGL::getQueryObjectuiv(GCGLuint id, GCGLenum pname, GCGLuint* params)
1896 {
1897     makeContextCurrent();
1898     gl::GetQueryObjectuiv(id, pname, params);
1899 }
1900 
1901 // Transform Feedback Functions
1902 
1903 PlatformGLObject GraphicsContextGLOpenGL::createTransformFeedback()
1904 {
1905     makeContextCurrent();
1906     GLuint name = 0;
1907     gl::GenTransformFeedbacks(1, &amp;name);
1908     return name;
1909 }
1910 
1911 void GraphicsContextGLOpenGL::deleteTransformFeedback(PlatformGLObject transformFeedback)
1912 {
1913     makeContextCurrent();
1914     gl::DeleteTransformFeedbacks(1, &amp;transformFeedback);
1915 }
1916 
1917 GCGLboolean GraphicsContextGLOpenGL::isTransformFeedback(PlatformGLObject transformFeedback)
1918 {
1919     makeContextCurrent();
1920     return gl::IsTransformFeedback(transformFeedback);
1921 }
1922 
1923 void GraphicsContextGLOpenGL::bindTransformFeedback(GCGLenum target, PlatformGLObject transformFeedback)
1924 {
1925     makeContextCurrent();
1926     gl::BindTransformFeedback(target, transformFeedback);
1927 }
1928 
1929 void GraphicsContextGLOpenGL::beginTransformFeedback(GCGLenum primitiveMode)
1930 {
1931     makeContextCurrent();
1932     gl::BeginTransformFeedback(primitiveMode);
1933 }
1934 
1935 void GraphicsContextGLOpenGL::endTransformFeedback()
1936 {
1937     makeContextCurrent();
1938     gl::EndTransformFeedback();
1939 }
1940 
1941 void GraphicsContextGLOpenGL::transformFeedbackVaryings(PlatformGLObject program, const Vector&lt;String&gt;&amp; varyings, GCGLenum bufferMode)
1942 {
1943     auto convertedVaryings = varyings.map([](const String&amp; varying) -&gt; const char* {
1944         return varying.utf8().data();
1945     });
1946     makeContextCurrent();
1947     gl::TransformFeedbackVaryings(program, varyings.size(), convertedVaryings.data(), bufferMode);
1948 }
1949 
1950 void GraphicsContextGLOpenGL::getTransformFeedbackVarying(PlatformGLObject program, GCGLuint index, ActiveInfo&amp; info)
1951 {
1952     makeContextCurrent();
1953     GCGLsizei bufSize = 0;
1954     gl::GetProgramiv(program, GraphicsContextGLOpenGL::TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH, &amp;bufSize);
1955     if (!bufSize)
1956         return;
1957 
1958     GCGLsizei length = 0;
1959     GCGLsizei size = 0;
1960     GCGLenum type = 0;
1961     Vector&lt;GCGLchar&gt; name(bufSize);
1962 
1963     gl::GetTransformFeedbackVarying(program, index, bufSize, &amp;length, &amp;size, &amp;type, name.data());
1964 
1965     info.name = String(name.data(), length);
1966     info.size = size;
1967     info.type = type;
1968 }
1969 
1970 void GraphicsContextGLOpenGL::bindBufferBase(GCGLenum target, GCGLuint index, PlatformGLObject buffer)
1971 {
1972     makeContextCurrent();
1973     gl::BindBufferBase(target, index, buffer);
1974 }
1975 
1976 void GraphicsContextGLOpenGL::bufferData(GCGLenum target, const void* data, GCGLenum usage, GCGLuint srcOffset, GCGLuint length)
1977 {
1978     UNUSED_PARAM(target);
1979     UNUSED_PARAM(data);
1980     UNUSED_PARAM(usage);
1981     UNUSED_PARAM(srcOffset);
1982     UNUSED_PARAM(length);
1983 }
1984 
1985 void GraphicsContextGLOpenGL::bufferSubData(GCGLenum target, GCGLintptr dstByteOffset, const void* srcData, GCGLuint srcOffset, GCGLuint length)
1986 {
1987     UNUSED_PARAM(target);
1988     UNUSED_PARAM(dstByteOffset);
1989     UNUSED_PARAM(srcData);
1990     UNUSED_PARAM(srcOffset);
1991     UNUSED_PARAM(length);
1992 }
1993 
1994 
1995 void GraphicsContextGLOpenGL::getBufferSubData(GCGLenum target, GCGLintptr srcByteOffset, const void* dstData, GCGLuint dstOffset, GCGLuint length)
1996 {
1997     UNUSED_PARAM(target);
1998     UNUSED_PARAM(srcByteOffset);
1999     UNUSED_PARAM(dstData);
2000     UNUSED_PARAM(dstOffset);
2001     UNUSED_PARAM(length);
2002 }
2003 
2004 void GraphicsContextGLOpenGL::blitFramebuffer(GCGLint srcX0, GCGLint srcY0, GCGLint srcX1, GCGLint srcY1, GCGLint dstX0, GCGLint dstY0, GCGLint dstX1, GCGLint dstY1, GCGLbitfield mask, GCGLenum filter)
2005 {
2006     UNUSED_PARAM(srcX0);
2007     UNUSED_PARAM(srcY0);
2008     UNUSED_PARAM(srcX1);
2009     UNUSED_PARAM(srcY1);
2010     UNUSED_PARAM(dstX0);
2011     UNUSED_PARAM(dstY0);
2012     UNUSED_PARAM(dstX1);
2013     UNUSED_PARAM(dstY1);
2014     UNUSED_PARAM(mask);
2015     UNUSED_PARAM(filter);
2016 }
2017 
2018 void GraphicsContextGLOpenGL::framebufferTextureLayer(GCGLenum target, GCGLenum attachment, PlatformGLObject texture, GCGLint level, GCGLint layer)
2019 {
2020     UNUSED_PARAM(target);
2021     UNUSED_PARAM(attachment);
2022     UNUSED_PARAM(texture);
2023     UNUSED_PARAM(level);
2024     UNUSED_PARAM(layer);
2025 }
2026 
2027 void GraphicsContextGLOpenGL::invalidateFramebuffer(GCGLenum target, const Vector&lt;GCGLenum&gt;&amp; attachments)
2028 {
2029     UNUSED_PARAM(target);
2030     UNUSED_PARAM(attachments);
2031 }
2032 
2033 void GraphicsContextGLOpenGL::invalidateSubFramebuffer(GCGLenum target, const Vector&lt;GCGLenum&gt;&amp; attachments, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)
2034 {
2035     UNUSED_PARAM(target);
2036     UNUSED_PARAM(attachments);
2037     UNUSED_PARAM(x);
2038     UNUSED_PARAM(y);
2039     UNUSED_PARAM(width);
2040     UNUSED_PARAM(height);
2041 }
2042 
2043 void GraphicsContextGLOpenGL::readBuffer(GCGLenum src)
2044 {
2045     UNUSED_PARAM(src);
2046 }
2047 
2048 void GraphicsContextGLOpenGL::texImage3D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLenum format, GCGLenum type, GCGLintptr pboOffset)
2049 {
2050     UNUSED_PARAM(target);
2051     UNUSED_PARAM(level);
2052     UNUSED_PARAM(internalformat);
2053     UNUSED_PARAM(width);
2054     UNUSED_PARAM(height);
2055     UNUSED_PARAM(depth);
2056     UNUSED_PARAM(border);
2057     UNUSED_PARAM(format);
2058     UNUSED_PARAM(type);
2059     UNUSED_PARAM(pboOffset);
2060 }
2061 
2062 void GraphicsContextGLOpenGL::texImage3D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLenum format, GCGLenum type, const void* pixels)
2063 {
2064     UNUSED_PARAM(target);
2065     UNUSED_PARAM(level);
2066     UNUSED_PARAM(internalformat);
2067     UNUSED_PARAM(width);
2068     UNUSED_PARAM(height);
2069     UNUSED_PARAM(depth);
2070     UNUSED_PARAM(border);
2071     UNUSED_PARAM(format);
2072     UNUSED_PARAM(type);
2073     UNUSED_PARAM(pixels);
2074 }
2075 
2076 void GraphicsContextGLOpenGL::texImage3D(GCGLenum target, GCGLint level, GCGLint internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLenum format, GCGLenum type, const void* srcData, GCGLuint srcOffset)
2077 {
2078     UNUSED_PARAM(target);
2079     UNUSED_PARAM(level);
2080     UNUSED_PARAM(internalformat);
2081     UNUSED_PARAM(width);
2082     UNUSED_PARAM(height);
2083     UNUSED_PARAM(depth);
2084     UNUSED_PARAM(border);
2085     UNUSED_PARAM(format);
2086     UNUSED_PARAM(type);
2087     UNUSED_PARAM(srcData);
2088     UNUSED_PARAM(srcOffset);
2089 }
2090 
2091 void GraphicsContextGLOpenGL::texSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, GCGLenum type, GCGLintptr pboOffset)
2092 {
2093     UNUSED_PARAM(target);
2094     UNUSED_PARAM(level);
2095     UNUSED_PARAM(xoffset);
2096     UNUSED_PARAM(yoffset);
2097     UNUSED_PARAM(zoffset);
2098     UNUSED_PARAM(width);
2099     UNUSED_PARAM(height);
2100     UNUSED_PARAM(depth);
2101     UNUSED_PARAM(format);
2102     UNUSED_PARAM(type);
2103     UNUSED_PARAM(pboOffset);
2104 }
2105 
2106 void GraphicsContextGLOpenGL::texSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, GCGLenum type, const void* srcData, GCGLuint srcOffset)
2107 {
2108     UNUSED_PARAM(target);
2109     UNUSED_PARAM(level);
2110     UNUSED_PARAM(xoffset);
2111     UNUSED_PARAM(yoffset);
2112     UNUSED_PARAM(zoffset);
2113     UNUSED_PARAM(width);
2114     UNUSED_PARAM(height);
2115     UNUSED_PARAM(depth);
2116     UNUSED_PARAM(format);
2117     UNUSED_PARAM(type);
2118     UNUSED_PARAM(srcData);
2119     UNUSED_PARAM(srcOffset);
2120 }
2121 
2122 void GraphicsContextGLOpenGL::copyTexSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height)
2123 {
2124     UNUSED_PARAM(target);
2125     UNUSED_PARAM(level);
2126     UNUSED_PARAM(xoffset);
2127     UNUSED_PARAM(yoffset);
2128     UNUSED_PARAM(zoffset);
2129     UNUSED_PARAM(x);
2130     UNUSED_PARAM(y);
2131     UNUSED_PARAM(width);
2132     UNUSED_PARAM(height);
2133 }
2134 
2135 void GraphicsContextGLOpenGL::compressedTexImage3D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, GCGLsizei imageSize, GCGLintptr offset)
2136 {
2137     UNUSED_PARAM(target);
2138     UNUSED_PARAM(level);
2139     UNUSED_PARAM(internalformat);
2140     UNUSED_PARAM(width);
2141     UNUSED_PARAM(height);
2142     UNUSED_PARAM(depth);
2143     UNUSED_PARAM(border);
2144     UNUSED_PARAM(imageSize);
2145     UNUSED_PARAM(offset);
2146 }
2147 
2148 void GraphicsContextGLOpenGL::compressedTexImage3D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLint border, const void* srcData, GCGLuint srcOffset, GCGLuint srcLengthOverride)
2149 {
2150     UNUSED_PARAM(target);
2151     UNUSED_PARAM(level);
2152     UNUSED_PARAM(internalformat);
2153     UNUSED_PARAM(width);
2154     UNUSED_PARAM(height);
2155     UNUSED_PARAM(depth);
2156     UNUSED_PARAM(border);
2157     UNUSED_PARAM(srcData);
2158     UNUSED_PARAM(srcOffset);
2159     UNUSED_PARAM(srcLengthOverride);
2160 }
2161 
2162 void GraphicsContextGLOpenGL::compressedTexSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, GCGLsizei imageSize, GCGLintptr offset)
2163 {
2164     UNUSED_PARAM(target);
2165     UNUSED_PARAM(level);
2166     UNUSED_PARAM(xoffset);
2167     UNUSED_PARAM(yoffset);
2168     UNUSED_PARAM(zoffset);
2169     UNUSED_PARAM(width);
2170     UNUSED_PARAM(height);
2171     UNUSED_PARAM(depth);
2172     UNUSED_PARAM(format);
2173     UNUSED_PARAM(imageSize);
2174     UNUSED_PARAM(offset);
2175 }
2176 
2177 void GraphicsContextGLOpenGL::compressedTexSubImage3D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLint zoffset, GCGLsizei width, GCGLsizei height, GCGLsizei depth, GCGLenum format, const void* srcData, GCGLuint srcOffset, GCGLuint srcLengthOverride)
2178 {
2179     UNUSED_PARAM(target);
2180     UNUSED_PARAM(level);
2181     UNUSED_PARAM(xoffset);
2182     UNUSED_PARAM(yoffset);
2183     UNUSED_PARAM(zoffset);
2184     UNUSED_PARAM(width);
2185     UNUSED_PARAM(height);
2186     UNUSED_PARAM(depth);
2187     UNUSED_PARAM(format);
2188     UNUSED_PARAM(srcData);
2189     UNUSED_PARAM(srcOffset);
2190     UNUSED_PARAM(srcLengthOverride);
2191 }
2192 
2193 GCGLint GraphicsContextGLOpenGL::getFragDataLocation(PlatformGLObject program, const String&amp; name)
2194 {
2195     UNUSED_PARAM(program);
2196     UNUSED_PARAM(name);
2197 
2198     return 0;
2199 }
2200 
2201 void GraphicsContextGLOpenGL::uniform1ui(GCGLint location, GCGLuint v0)
2202 {
2203     UNUSED_PARAM(location);
2204     UNUSED_PARAM(v0);
2205 }
2206 
2207 void GraphicsContextGLOpenGL::uniform2ui(GCGLint location, GCGLuint v0, GCGLuint v1)
2208 {
2209     UNUSED_PARAM(location);
2210     UNUSED_PARAM(v0);
2211     UNUSED_PARAM(v1);
2212 }
2213 
2214 void GraphicsContextGLOpenGL::uniform3ui(GCGLint location, GCGLuint v0, GCGLuint v1, GCGLuint v2)
2215 {
2216     UNUSED_PARAM(location);
2217     UNUSED_PARAM(v0);
2218     UNUSED_PARAM(v1);
2219     UNUSED_PARAM(v2);
2220 }
2221 
2222 void GraphicsContextGLOpenGL::uniform4ui(GCGLint location, GCGLuint v0, GCGLuint v1, GCGLuint v2, GCGLuint v3)
2223 {
2224     UNUSED_PARAM(location);
2225     UNUSED_PARAM(v0);
2226     UNUSED_PARAM(v1);
2227     UNUSED_PARAM(v2);
2228     UNUSED_PARAM(v3);
2229 }
2230 
2231 void GraphicsContextGLOpenGL::uniform1uiv(GCGLint location, const GCGLuint* data, GCGLuint srcOffset, GCGLuint srcLength)
2232 {
2233     UNUSED_PARAM(location);
2234     UNUSED_PARAM(data);
2235     UNUSED_PARAM(srcOffset);
2236     UNUSED_PARAM(srcLength);
2237 }
2238 
2239 void GraphicsContextGLOpenGL::uniform2uiv(GCGLint location, const GCGLuint* data, GCGLuint srcOffset, GCGLuint srcLength)
2240 {
2241     UNUSED_PARAM(location);
2242     UNUSED_PARAM(data);
2243     UNUSED_PARAM(srcOffset);
2244     UNUSED_PARAM(srcLength);
2245 }
2246 
2247 void GraphicsContextGLOpenGL::uniform3uiv(GCGLint location, const GCGLuint* data, GCGLuint srcOffset, GCGLuint srcLength)
2248 {
2249     UNUSED_PARAM(location);
2250     UNUSED_PARAM(data);
2251     UNUSED_PARAM(srcOffset);
2252     UNUSED_PARAM(srcLength);
2253 }
2254 
2255 void GraphicsContextGLOpenGL::uniform4uiv(GCGLint location, const GCGLuint* data, GCGLuint srcOffset, GCGLuint srcLength)
2256 {
2257     UNUSED_PARAM(location);
2258     UNUSED_PARAM(data);
2259     UNUSED_PARAM(srcOffset);
2260     UNUSED_PARAM(srcLength);
2261 }
2262 
2263 void GraphicsContextGLOpenGL::uniformMatrix2x3fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2264 {
2265     UNUSED_PARAM(location);
2266     UNUSED_PARAM(transpose);
2267     UNUSED_PARAM(data);
2268     UNUSED_PARAM(srcOffset);
2269     UNUSED_PARAM(srcLength);
2270 }
2271 
2272 void GraphicsContextGLOpenGL::uniformMatrix3x2fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2273 {
2274     UNUSED_PARAM(location);
2275     UNUSED_PARAM(transpose);
2276     UNUSED_PARAM(data);
2277     UNUSED_PARAM(srcOffset);
2278     UNUSED_PARAM(srcLength);
2279 }
2280 
2281 void GraphicsContextGLOpenGL::uniformMatrix2x4fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2282 {
2283     UNUSED_PARAM(location);
2284     UNUSED_PARAM(transpose);
2285     UNUSED_PARAM(data);
2286     UNUSED_PARAM(srcOffset);
2287     UNUSED_PARAM(srcLength);
2288 }
2289 
2290 void GraphicsContextGLOpenGL::uniformMatrix4x2fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2291 {
2292     UNUSED_PARAM(location);
2293     UNUSED_PARAM(transpose);
2294     UNUSED_PARAM(data);
2295     UNUSED_PARAM(srcOffset);
2296     UNUSED_PARAM(srcLength);
2297 }
2298 
2299 void GraphicsContextGLOpenGL::uniformMatrix3x4fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2300 {
2301     UNUSED_PARAM(location);
2302     UNUSED_PARAM(transpose);
2303     UNUSED_PARAM(data);
2304     UNUSED_PARAM(srcOffset);
2305     UNUSED_PARAM(srcLength);
2306 }
2307 
2308 void GraphicsContextGLOpenGL::uniformMatrix4x3fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2309 {
2310     UNUSED_PARAM(location);
2311     UNUSED_PARAM(transpose);
2312     UNUSED_PARAM(data);
2313     UNUSED_PARAM(srcOffset);
2314     UNUSED_PARAM(srcLength);
2315 }
2316 
2317 void GraphicsContextGLOpenGL::vertexAttribI4i(GCGLuint index, GCGLint x, GCGLint y, GCGLint z, GCGLint w)
2318 {
2319     UNUSED_PARAM(index);
2320     UNUSED_PARAM(x);
2321     UNUSED_PARAM(y);
2322     UNUSED_PARAM(z);
2323     UNUSED_PARAM(w);
2324 }
2325 
2326 void GraphicsContextGLOpenGL::vertexAttribI4iv(GCGLuint index, const GCGLint* values)
2327 {
2328     UNUSED_PARAM(index);
2329     UNUSED_PARAM(values);
2330 }
2331 
2332 void GraphicsContextGLOpenGL::vertexAttribI4ui(GCGLuint index, GCGLuint x, GCGLuint y, GCGLuint z, GCGLuint w)
2333 {
2334     UNUSED_PARAM(index);
2335     UNUSED_PARAM(x);
2336     UNUSED_PARAM(y);
2337     UNUSED_PARAM(z);
2338     UNUSED_PARAM(w);
2339 }
2340 
2341 void GraphicsContextGLOpenGL::vertexAttribI4uiv(GCGLuint index, const GCGLuint* values)
2342 {
2343     UNUSED_PARAM(index);
2344     UNUSED_PARAM(values);
2345 }
2346 
2347 void GraphicsContextGLOpenGL::drawRangeElements(GCGLenum mode, GCGLuint start, GCGLuint end, GCGLsizei count, GCGLenum type, GCGLintptr offset)
2348 {
2349     UNUSED_PARAM(mode);
2350     UNUSED_PARAM(start);
2351     UNUSED_PARAM(end);
2352     UNUSED_PARAM(count);
2353     UNUSED_PARAM(type);
2354     UNUSED_PARAM(offset);
2355 }
2356 
2357 void GraphicsContextGLOpenGL::drawBuffers(const Vector&lt;GCGLenum&gt;&amp; buffers)
2358 {
2359     UNUSED_PARAM(buffers);
2360 }
2361 
2362 void GraphicsContextGLOpenGL::clearBufferiv(GCGLenum buffer, GCGLint drawbuffer, const GCGLint* values, GCGLuint srcOffset)
2363 {
2364     UNUSED_PARAM(buffer);
2365     UNUSED_PARAM(drawbuffer);
2366     UNUSED_PARAM(values);
2367     UNUSED_PARAM(srcOffset);
2368 }
2369 
2370 void GraphicsContextGLOpenGL::clearBufferuiv(GCGLenum buffer, GCGLint drawbuffer, const GCGLuint* values, GCGLuint srcOffset)
2371 {
2372     UNUSED_PARAM(buffer);
2373     UNUSED_PARAM(drawbuffer);
2374     UNUSED_PARAM(values);
2375     UNUSED_PARAM(srcOffset);
2376 }
2377 
2378 void GraphicsContextGLOpenGL::clearBufferfv(GCGLenum buffer, GCGLint drawbuffer, const GCGLfloat* values, GCGLuint srcOffset)
2379 {
2380     UNUSED_PARAM(buffer);
2381     UNUSED_PARAM(drawbuffer);
2382     UNUSED_PARAM(values);
2383     UNUSED_PARAM(srcOffset);
2384 }
2385 
2386 void GraphicsContextGLOpenGL::clearBufferfi(GCGLenum buffer, GCGLint drawbuffer, GCGLfloat depth, GCGLint stencil)
2387 {
2388     UNUSED_PARAM(buffer);
2389     UNUSED_PARAM(drawbuffer);
2390     UNUSED_PARAM(depth);
2391     UNUSED_PARAM(stencil);
2392 }
2393 
2394 void GraphicsContextGLOpenGL::deleteQuery(PlatformGLObject query)
2395 {
2396     UNUSED_PARAM(query);
2397 }
2398 
2399 GCGLboolean GraphicsContextGLOpenGL::isQuery(PlatformGLObject query)
2400 {
2401     UNUSED_PARAM(query);
2402 
2403     return false;
2404 }
2405 
2406 PlatformGLObject GraphicsContextGLOpenGL::getQuery(GCGLenum target, GCGLenum pname)
2407 {
2408     UNUSED_PARAM(target);
2409     UNUSED_PARAM(pname);
2410 
2411     return 0;
2412 }
2413 
2414 PlatformGLObject GraphicsContextGLOpenGL::createSampler()
2415 {
2416     makeContextCurrent();
2417     GLuint name = 0;
2418     gl::GenSamplers(1, &amp;name);
2419     return name;
2420 }
2421 
2422 void GraphicsContextGLOpenGL::deleteSampler(PlatformGLObject sampler)
2423 {
2424     makeContextCurrent();
2425     gl::DeleteSamplers(1, &amp;sampler);
2426 }
2427 
2428 GCGLboolean GraphicsContextGLOpenGL::isSampler(PlatformGLObject sampler)
2429 {
2430     makeContextCurrent();
2431     return gl::IsSampler(sampler);
2432 }
2433 
2434 void GraphicsContextGLOpenGL::bindSampler(GCGLuint unit, PlatformGLObject sampler)
2435 {
2436     makeContextCurrent();
2437     gl::BindSampler(unit, sampler);
2438 }
2439 
2440 void GraphicsContextGLOpenGL::samplerParameteri(PlatformGLObject sampler, GCGLenum pname, GCGLint param)
2441 {
2442     makeContextCurrent();
2443     gl::SamplerParameteri(sampler, pname, param);
2444 }
2445 
2446 void GraphicsContextGLOpenGL::samplerParameterf(PlatformGLObject sampler, GCGLenum pname, GCGLfloat param)
2447 {
2448     makeContextCurrent();
2449     gl::SamplerParameterf(sampler, pname, param);
2450 }
2451 
2452 void GraphicsContextGLOpenGL::getSamplerParameterfv(PlatformGLObject sampler, GCGLenum pname, GCGLfloat* value)
2453 {
2454     makeContextCurrent();
2455     gl::GetSamplerParameterfv(sampler, pname, value);
2456 }
2457 
2458 void GraphicsContextGLOpenGL::getSamplerParameteriv(PlatformGLObject sampler, GCGLenum pname, GCGLint* value)
2459 {
2460     makeContextCurrent();
2461     gl::GetSamplerParameteriv(sampler, pname, value);
2462 }
2463 
2464 PlatformGLObject GraphicsContextGLOpenGL::fenceSync(GCGLenum condition, GCGLbitfield flags)
2465 {
2466     UNUSED_PARAM(condition);
2467     UNUSED_PARAM(flags);
2468 
2469     return 0;
2470 }
2471 
2472 GCGLboolean GraphicsContextGLOpenGL::isSync(PlatformGLObject sync)
2473 {
2474     UNUSED_PARAM(sync);
2475 
2476     return false;
2477 }
2478 
2479 void GraphicsContextGLOpenGL::deleteSync(PlatformGLObject sync)
2480 {
2481     UNUSED_PARAM(sync);
2482 }
2483 
2484 GCGLenum GraphicsContextGLOpenGL::clientWaitSync(PlatformGLObject sync, GCGLbitfield flags, GCGLuint64 timeout)
2485 {
2486     UNUSED_PARAM(sync);
2487     UNUSED_PARAM(flags);
2488     UNUSED_PARAM(timeout);
2489 
2490     return 0;
2491 }
2492 
2493 void GraphicsContextGLOpenGL::waitSync(PlatformGLObject sync, GCGLbitfield flags, GCGLint64 timeout)
2494 {
2495     UNUSED_PARAM(sync);
2496     UNUSED_PARAM(flags);
2497     UNUSED_PARAM(timeout);
2498 }
2499 
2500 void GraphicsContextGLOpenGL::getSynciv(PlatformGLObject sync, GCGLenum pname, GCGLsizei bufSize, GCGLint *value)
2501 {
2502     UNUSED_PARAM(sync);
2503     UNUSED_PARAM(pname);
2504     UNUSED_PARAM(bufSize);
2505     UNUSED_PARAM(value);
2506 }
2507 
2508 void GraphicsContextGLOpenGL::pauseTransformFeedback()
2509 {
2510 }
2511 
2512 void GraphicsContextGLOpenGL::resumeTransformFeedback()
2513 {
2514 }
2515 
2516 void GraphicsContextGLOpenGL::bindBufferRange(GCGLenum target, GCGLuint index, PlatformGLObject buffer, GCGLintptr offset, GCGLsizeiptr size)
2517 {
2518     UNUSED_PARAM(target);
2519     UNUSED_PARAM(index);
2520     UNUSED_PARAM(buffer);
2521     UNUSED_PARAM(offset);
2522     UNUSED_PARAM(size);
2523 }
2524 
2525 Vector&lt;GCGLuint&gt; GraphicsContextGLOpenGL::getUniformIndices(PlatformGLObject program, const Vector&lt;String&gt;&amp; uniformNames)
2526 {
2527     UNUSED_PARAM(program);
2528     UNUSED_PARAM(uniformNames);
2529 
2530     return { };
2531 }
2532 
2533 void GraphicsContextGLOpenGL::texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, GCGLintptr pboOffset)
2534 {
2535     UNUSED_PARAM(target);
2536     UNUSED_PARAM(level);
2537     UNUSED_PARAM(xoffset);
2538     UNUSED_PARAM(yoffset);
2539     UNUSED_PARAM(width);
2540     UNUSED_PARAM(height);
2541     UNUSED_PARAM(format);
2542     UNUSED_PARAM(type);
2543     UNUSED_PARAM(pboOffset);
2544 }
2545 
2546 void GraphicsContextGLOpenGL::texSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, const void* srcData, GCGLuint srcOffset)
2547 {
2548     UNUSED_PARAM(target);
2549     UNUSED_PARAM(level);
2550     UNUSED_PARAM(xoffset);
2551     UNUSED_PARAM(yoffset);
2552     UNUSED_PARAM(width);
2553     UNUSED_PARAM(height);
2554     UNUSED_PARAM(format);
2555     UNUSED_PARAM(type);
2556     UNUSED_PARAM(srcData);
2557     UNUSED_PARAM(srcOffset);
2558 }
2559 
2560 void GraphicsContextGLOpenGL::compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, GCGLsizei imageSize, GCGLintptr offset)
2561 {
2562     UNUSED_PARAM(target);
2563     UNUSED_PARAM(level);
2564     UNUSED_PARAM(internalformat);
2565     UNUSED_PARAM(width);
2566     UNUSED_PARAM(height);
2567     UNUSED_PARAM(border);
2568     UNUSED_PARAM(imageSize);
2569     UNUSED_PARAM(offset);
2570 }
2571 
2572 void GraphicsContextGLOpenGL::compressedTexImage2D(GCGLenum target, GCGLint level, GCGLenum internalformat, GCGLsizei width, GCGLsizei height, GCGLint border, const void* srcData, GCGLuint srcOffset, GCGLuint srcLengthOverride)
2573 {
2574     UNUSED_PARAM(target);
2575     UNUSED_PARAM(level);
2576     UNUSED_PARAM(internalformat);
2577     UNUSED_PARAM(width);
2578     UNUSED_PARAM(height);
2579     UNUSED_PARAM(border);
2580     UNUSED_PARAM(srcData);
2581     UNUSED_PARAM(srcOffset);
2582     UNUSED_PARAM(srcLengthOverride);
2583 }
2584 
2585 void GraphicsContextGLOpenGL::compressedTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLsizei imageSize, GCGLintptr offset)
2586 {
2587     UNUSED_PARAM(target);
2588     UNUSED_PARAM(level);
2589     UNUSED_PARAM(xoffset);
2590     UNUSED_PARAM(yoffset);
2591     UNUSED_PARAM(width);
2592     UNUSED_PARAM(height);
2593     UNUSED_PARAM(format);
2594     UNUSED_PARAM(imageSize);
2595     UNUSED_PARAM(offset);
2596 }
2597 
2598 void GraphicsContextGLOpenGL::compressedTexSubImage2D(GCGLenum target, GCGLint level, GCGLint xoffset, GCGLint yoffset, GCGLsizei width, GCGLsizei height, GCGLenum format, const void* srcData, GCGLuint srcOffset, GCGLuint srcLengthOverride)
2599 {
2600     UNUSED_PARAM(target);
2601     UNUSED_PARAM(level);
2602     UNUSED_PARAM(xoffset);
2603     UNUSED_PARAM(yoffset);
2604     UNUSED_PARAM(width);
2605     UNUSED_PARAM(height);
2606     UNUSED_PARAM(format);
2607     UNUSED_PARAM(srcData);
2608     UNUSED_PARAM(srcOffset);
2609     UNUSED_PARAM(srcLengthOverride);
2610 }
2611 
2612 void GraphicsContextGLOpenGL::uniform1fv(GCGLint location, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2613 {
2614     UNUSED_PARAM(location);
2615     UNUSED_PARAM(data);
2616     UNUSED_PARAM(srcOffset);
2617     UNUSED_PARAM(srcLength);
2618 }
2619 
2620 void GraphicsContextGLOpenGL::uniform2fv(GCGLint location, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2621 {
2622     UNUSED_PARAM(location);
2623     UNUSED_PARAM(data);
2624     UNUSED_PARAM(srcOffset);
2625     UNUSED_PARAM(srcLength);
2626 }
2627 
2628 void GraphicsContextGLOpenGL::uniform3fv(GCGLint location, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2629 {
2630     UNUSED_PARAM(location);
2631     UNUSED_PARAM(data);
2632     UNUSED_PARAM(srcOffset);
2633     UNUSED_PARAM(srcLength);
2634 }
2635 
2636 void GraphicsContextGLOpenGL::uniform4fv(GCGLint location, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2637 {
2638     UNUSED_PARAM(location);
2639     UNUSED_PARAM(data);
2640     UNUSED_PARAM(srcOffset);
2641     UNUSED_PARAM(srcLength);
2642 }
2643 
2644 void GraphicsContextGLOpenGL::uniform1iv(GCGLint location, const GCGLint* data, GCGLuint srcOffset, GCGLuint srcLength)
2645 {
2646     UNUSED_PARAM(location);
2647     UNUSED_PARAM(data);
2648     UNUSED_PARAM(srcOffset);
2649     UNUSED_PARAM(srcLength);
2650 }
2651 
2652 void GraphicsContextGLOpenGL::uniform2iv(GCGLint location, const GCGLint* data, GCGLuint srcOffset, GCGLuint srcLength)
2653 {
2654     UNUSED_PARAM(location);
2655     UNUSED_PARAM(data);
2656     UNUSED_PARAM(srcOffset);
2657     UNUSED_PARAM(srcLength);
2658 }
2659 
2660 void GraphicsContextGLOpenGL::uniform3iv(GCGLint location, const GCGLint* data, GCGLuint srcOffset, GCGLuint srcLength)
2661 {
2662     UNUSED_PARAM(location);
2663     UNUSED_PARAM(data);
2664     UNUSED_PARAM(srcOffset);
2665     UNUSED_PARAM(srcLength);
2666 }
2667 
2668 void GraphicsContextGLOpenGL::uniform4iv(GCGLint location, const GCGLint* data, GCGLuint srcOffset, GCGLuint srcLength)
2669 {
2670     UNUSED_PARAM(location);
2671     UNUSED_PARAM(data);
2672     UNUSED_PARAM(srcOffset);
2673     UNUSED_PARAM(srcLength);
2674 }
2675 
2676 void GraphicsContextGLOpenGL::uniformMatrix2fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2677 {
2678     UNUSED_PARAM(location);
2679     UNUSED_PARAM(transpose);
2680     UNUSED_PARAM(data);
2681     UNUSED_PARAM(srcOffset);
2682     UNUSED_PARAM(srcLength);
2683 }
2684 
2685 void GraphicsContextGLOpenGL::uniformMatrix3fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2686 {
2687     UNUSED_PARAM(location);
2688     UNUSED_PARAM(transpose);
2689     UNUSED_PARAM(data);
2690     UNUSED_PARAM(srcOffset);
2691     UNUSED_PARAM(srcLength);
2692 }
2693 
2694 void GraphicsContextGLOpenGL::uniformMatrix4fv(GCGLint location, GCGLboolean transpose, const GCGLfloat* data, GCGLuint srcOffset, GCGLuint srcLength)
2695 {
2696     UNUSED_PARAM(location);
2697     UNUSED_PARAM(transpose);
2698     UNUSED_PARAM(data);
2699     UNUSED_PARAM(srcOffset);
2700     UNUSED_PARAM(srcLength);
2701 }
2702 
2703 void GraphicsContextGLOpenGL::readPixels(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, GCGLintptr offset)
2704 {
2705     UNUSED_PARAM(x);
2706     UNUSED_PARAM(y);
2707     UNUSED_PARAM(width);
2708     UNUSED_PARAM(height);
2709     UNUSED_PARAM(format);
2710     UNUSED_PARAM(type);
2711     UNUSED_PARAM(offset);
2712 }
2713 
2714 void GraphicsContextGLOpenGL::readPixels(GCGLint x, GCGLint y, GCGLsizei width, GCGLsizei height, GCGLenum format, GCGLenum type, const void* dstData, GCGLuint dstOffset)
2715 {
2716     UNUSED_PARAM(x);
2717     UNUSED_PARAM(y);
2718     UNUSED_PARAM(width);
2719     UNUSED_PARAM(height);
2720     UNUSED_PARAM(format);
2721     UNUSED_PARAM(type);
2722     UNUSED_PARAM(dstData);
2723     UNUSED_PARAM(dstOffset);
2724 }
2725 
2726 }
2727 
2728 #endif // ENABLE(GRAPHICS_CONTEXT_GL) &amp;&amp; USE(ANGLE)
    </pre>
  </body>
</html>
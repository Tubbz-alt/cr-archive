<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorDOMAgent.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorDOMAgent.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorDOMDebuggerAgent.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorDOMAgent.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 29 
 30 #pragma once
 31 
 32 #include &quot;EventTarget.h&quot;
 33 #include &quot;InspectorWebAgentBase.h&quot;
 34 #include &quot;Timer.h&quot;
 35 #include &lt;JavaScriptCore/InspectorBackendDispatchers.h&gt;
 36 #include &lt;JavaScriptCore/InspectorFrontendDispatchers.h&gt;
 37 #include &lt;wtf/HashMap.h&gt;
 38 #include &lt;wtf/HashSet.h&gt;
 39 #include &lt;wtf/JSONValues.h&gt;
 40 #include &lt;wtf/RefPtr.h&gt;
 41 #include &lt;wtf/Vector.h&gt;
 42 #include &lt;wtf/text/AtomString.h&gt;
 43 
 44 namespace Inspector {
 45 class InjectedScriptManager;
 46 }
 47 
 48 namespace JSC {
<span class="line-modified"> 49 class ExecState;</span>
 50 class JSValue;
 51 }
 52 
 53 namespace WebCore {
 54 
<span class="line-modified"> 55 class AccessibilityObject;</span>
 56 class CharacterData;
 57 class DOMEditor;
 58 class Document;
 59 class Element;
 60 class Event;
 61 class Exception;
 62 class FloatQuad;
 63 class Frame;
 64 class InspectorHistory;
 65 class InspectorOverlay;
 66 #if ENABLE(VIDEO)
 67 class HTMLMediaElement;
 68 #endif
 69 class HitTestResult;
 70 class Node;
 71 class Page;
 72 class PseudoElement;
 73 class RevalidateStyleAttributeTask;
 74 class ShadowRoot;
 75 
 76 struct HighlightConfig;
 77 
 78 typedef String ErrorString;
 79 
 80 class InspectorDOMAgent final : public InspectorAgentBase, public Inspector::DOMBackendDispatcherHandler {
 81     WTF_MAKE_NONCOPYABLE(InspectorDOMAgent);
 82     WTF_MAKE_FAST_ALLOCATED;
 83 public:
 84     InspectorDOMAgent(PageAgentContext&amp;, InspectorOverlay*);
<span class="line-modified"> 85     virtual ~InspectorDOMAgent();</span>
 86 
 87     static String toErrorString(ExceptionCode);
 88     static String toErrorString(Exception&amp;&amp;);
 89 
 90     static String documentURLString(Document*);
 91 
 92     // We represent embedded doms as a part of the same hierarchy. Hence we treat children of frame owners differently.
 93     // We also skip whitespace text nodes conditionally. Following methods encapsulate these specifics.
 94     static Node* innerFirstChild(Node*);
 95     static Node* innerNextSibling(Node*);
 96     static Node* innerPreviousSibling(Node*);
 97     static unsigned innerChildNodeCount(Node*);
 98     static Node* innerParentNode(Node*);
 99 
100     static Node* scriptValueAsNode(JSC::JSValue);
<span class="line-modified">101     static JSC::JSValue nodeAsScriptValue(JSC::ExecState&amp;, Node*);</span>
102 
103     // InspectorAgentBase
<span class="line-modified">104     void didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*);</span>
<span class="line-modified">105     void willDestroyFrontendAndBackend(Inspector::DisconnectReason);</span>
106 
107     // DOMBackendDispatcherHandler
<span class="line-modified">108     void querySelector(ErrorString&amp;, int nodeId, const String&amp; selectors, int* elementId);</span>
<span class="line-modified">109     void querySelectorAll(ErrorString&amp;, int nodeId, const String&amp; selectors, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; result);</span>
<span class="line-modified">110     void getDocument(ErrorString&amp;, RefPtr&lt;Inspector::Protocol::DOM::Node&gt;&amp; root);</span>
<span class="line-modified">111     void requestChildNodes(ErrorString&amp;, int nodeId, const int* depth);</span>
<span class="line-modified">112     void setAttributeValue(ErrorString&amp;, int elementId, const String&amp; name, const String&amp; value);</span>
<span class="line-modified">113     void setAttributesAsText(ErrorString&amp;, int elementId, const String&amp; text, const String* name);</span>
<span class="line-modified">114     void removeAttribute(ErrorString&amp;, int elementId, const String&amp; name);</span>
<span class="line-modified">115     void removeNode(ErrorString&amp;, int nodeId);</span>
<span class="line-modified">116     void setNodeName(ErrorString&amp;, int nodeId, const String&amp; name, int* newId);</span>
<span class="line-modified">117     void getOuterHTML(ErrorString&amp;, int nodeId, WTF::String* outerHTML);</span>
<span class="line-modified">118     void setOuterHTML(ErrorString&amp;, int nodeId, const String&amp; outerHTML);</span>
<span class="line-modified">119     void insertAdjacentHTML(ErrorString&amp;, int nodeId, const String&amp; position, const String&amp; html);</span>
<span class="line-modified">120     void setNodeValue(ErrorString&amp;, int nodeId, const String&amp; value);</span>
<span class="line-modified">121     void getSupportedEventNames(ErrorString&amp;, RefPtr&lt;JSON::ArrayOf&lt;String&gt;&gt;&amp; eventNames);</span>
<span class="line-modified">122     void getDataBindingsForNode(ErrorString&amp;, int nodeId, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::DataBinding&gt;&gt;&amp; dataArray);</span>
<span class="line-modified">123     void getAssociatedDataForNode(ErrorString&amp;, int nodeId, Optional&lt;String&gt;&amp; associatedData);</span>
<span class="line-modified">124     void getEventListenersForNode(ErrorString&amp;, int nodeId, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::EventListener&gt;&gt;&amp; listenersArray);</span>
<span class="line-modified">125     void setEventListenerDisabled(ErrorString&amp;, int eventListenerId, bool disabled);</span>
<span class="line-modified">126     void setBreakpointForEventListener(ErrorString&amp;, int eventListenerId);</span>
<span class="line-modified">127     void removeBreakpointForEventListener(ErrorString&amp;, int eventListenerId);</span>
<span class="line-modified">128     void getAccessibilityPropertiesForNode(ErrorString&amp;, int nodeId, RefPtr&lt;Inspector::Protocol::DOM::AccessibilityProperties&gt;&amp; axProperties);</span>
<span class="line-modified">129     void performSearch(ErrorString&amp;, const String&amp; query, const JSON::Array* nodeIds, const bool* caseSensitive, String* searchId, int* resultCount);</span>
<span class="line-modified">130     void getSearchResults(ErrorString&amp;, const String&amp; searchId, int fromIndex, int toIndex, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp;);</span>
<span class="line-modified">131     void discardSearchResults(ErrorString&amp;, const String&amp; searchId);</span>
<span class="line-modified">132     void resolveNode(ErrorString&amp;, int nodeId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result);</span>
<span class="line-modified">133     void getAttributes(ErrorString&amp;, int nodeId, RefPtr&lt;JSON::ArrayOf&lt;String&gt;&gt;&amp; result);</span>
<span class="line-modified">134     void setInspectModeEnabled(ErrorString&amp;, bool enabled, const JSON::Object* highlightConfig, const bool* showRulers);</span>
<span class="line-modified">135     void requestNode(ErrorString&amp;, const String&amp; objectId, int* nodeId);</span>
<span class="line-modified">136     void pushNodeByPathToFrontend(ErrorString&amp;, const String&amp; path, int* nodeId);</span>
<span class="line-modified">137     void hideHighlight(ErrorString&amp;);</span>
<span class="line-modified">138     void highlightRect(ErrorString&amp;, int x, int y, int width, int height, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates);</span>
<span class="line-modified">139     void highlightQuad(ErrorString&amp;, const JSON::Array&amp; quad, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates);</span>
<span class="line-modified">140     void highlightSelector(ErrorString&amp;, const JSON::Object&amp; highlightConfig, const String&amp; selectorString, const String* frameId);</span>
<span class="line-modified">141     void highlightNode(ErrorString&amp;, const JSON::Object&amp; highlightConfig, const int* nodeId, const String* objectId);</span>
<span class="line-modified">142     void highlightNodeList(ErrorString&amp;, const JSON::Array&amp; nodeIds, const JSON::Object&amp; highlightConfig);</span>
<span class="line-modified">143     void highlightFrame(ErrorString&amp;, const String&amp; frameId, const JSON::Object* color, const JSON::Object* outlineColor);</span>
<span class="line-modified">144     void moveTo(ErrorString&amp;, int nodeId, int targetNodeId, const int* anchorNodeId, int* newNodeId);</span>
<span class="line-modified">145     void undo(ErrorString&amp;);</span>
<span class="line-modified">146     void redo(ErrorString&amp;);</span>
<span class="line-modified">147     void markUndoableState(ErrorString&amp;);</span>
<span class="line-modified">148     void focus(ErrorString&amp;, int nodeId);</span>
<span class="line-modified">149     void setInspectedNode(ErrorString&amp;, int nodeId);</span>

150 
151     // InspectorInstrumentation
152     int identifierForNode(Node&amp;);
153     void addEventListenersToNode(Node&amp;);
154     void didInsertDOMNode(Node&amp;);
155     void didRemoveDOMNode(Node&amp;);
156     void willModifyDOMAttr(Element&amp;, const AtomString&amp; oldValue, const AtomString&amp; newValue);
157     void didModifyDOMAttr(Element&amp;, const AtomString&amp; name, const AtomString&amp; value);
158     void didRemoveDOMAttr(Element&amp;, const AtomString&amp; name);
159     void characterDataModified(CharacterData&amp;);
160     void didInvalidateStyleAttr(Element&amp;);
161     void didPushShadowRoot(Element&amp; host, ShadowRoot&amp;);
162     void willPopShadowRoot(Element&amp; host, ShadowRoot&amp;);
163     void didChangeCustomElementState(Element&amp;);
164     bool handleTouchEvent(Node&amp;);
165     void didCommitLoad(Document*);
166     void frameDocumentUpdated(Frame&amp;);
167     void pseudoElementCreated(PseudoElement&amp;);
168     void pseudoElementDestroyed(PseudoElement&amp;);
169     void didAddEventListener(EventTarget&amp;);
170     void willRemoveEventListener(EventTarget&amp;, const AtomString&amp; eventType, EventListener&amp;, bool capture);
171     bool isEventListenerDisabled(EventTarget&amp;, const AtomString&amp; eventType, EventListener&amp;, bool capture);
172     void eventDidResetAfterDispatch(const Event&amp;);
173 
174     // Callbacks that don&#39;t directly correspond to an instrumentation entry point.
175     void setDocument(Document*);
176     void releaseDanglingNodes();
177 
178     void styleAttributeInvalidated(const Vector&lt;Element*&gt;&amp; elements);
179 

180     int pushNodeToFrontend(ErrorString&amp;, int documentNodeId, Node*);


181     Node* nodeForId(int nodeId);
182     int boundNodeId(const Node*);
183 
184     RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt; resolveNode(Node*, const String&amp; objectGroup);
185     bool handleMousePress();
186     void mouseDidMoveOverElement(const HitTestResult&amp;, unsigned modifierFlags);
187     void inspect(Node*);
188     void focusNode();
189 
190     InspectorHistory* history() { return m_history.get(); }
191     Vector&lt;Document*&gt; documents();
192     void reset();
193 
194     Node* assertNode(ErrorString&amp;, int nodeId);
195     Element* assertElement(ErrorString&amp;, int nodeId);
196     Document* assertDocument(ErrorString&amp;, int nodeId);
197 
198     bool hasBreakpointForEventListener(EventTarget&amp;, const AtomString&amp; eventType, EventListener&amp;, bool capture);
199     int idForEventListener(EventTarget&amp;, const AtomString&amp; eventType, EventListener&amp;, bool capture);
200 
201 private:
202 #if ENABLE(VIDEO)
203     void mediaMetricsTimerFired();
204 #endif
205 
206     void highlightMousedOverNode();
207     void setSearchingForNode(ErrorString&amp;, bool enabled, const JSON::Object* highlightConfig, bool showRulers);
208     std::unique_ptr&lt;HighlightConfig&gt; highlightConfigFromInspectorObject(ErrorString&amp;, const JSON::Object* highlightInspectorObject);
209 
210     // Node-related methods.
211     typedef HashMap&lt;RefPtr&lt;Node&gt;, int&gt; NodeToIdMap;
212     int bind(Node*, NodeToIdMap*);
213     void unbind(Node*, NodeToIdMap*);
214 
215     Node* assertEditableNode(ErrorString&amp;, int nodeId);
216     Element* assertEditableElement(ErrorString&amp;, int nodeId);
217 
<span class="line-removed">218     int pushNodePathToFrontend(Node*);</span>
219     void pushChildNodesToFrontend(int nodeId, int depth = 1);
220 
221     Ref&lt;Inspector::Protocol::DOM::Node&gt; buildObjectForNode(Node*, int depth, NodeToIdMap*);
222     Ref&lt;JSON::ArrayOf&lt;String&gt;&gt; buildArrayForElementAttributes(Element*);
223     Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;&gt; buildArrayForContainerChildren(Node* container, int depth, NodeToIdMap* nodesMap);
224     RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;&gt; buildArrayForPseudoElements(const Element&amp;, NodeToIdMap* nodesMap);
225     Ref&lt;Inspector::Protocol::DOM::EventListener&gt; buildObjectForEventListener(const RegisteredEventListener&amp;, int identifier, EventTarget&amp;, const AtomString&amp; eventType, bool disabled, bool hasBreakpoint);
226     RefPtr&lt;Inspector::Protocol::DOM::AccessibilityProperties&gt; buildObjectForAccessibilityProperties(Node*);
<span class="line-modified">227     void processAccessibilityChildren(AccessibilityObject&amp;, JSON::ArrayOf&lt;int&gt;&amp;);</span>
228 
229     Node* nodeForPath(const String&amp; path);
230     Node* nodeForObjectId(const String&amp; objectId);
231 
232     void discardBindings();
233 
234     void innerHighlightQuad(std::unique_ptr&lt;FloatQuad&gt;, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates);
235 
236     Inspector::InjectedScriptManager&amp; m_injectedScriptManager;
237     std::unique_ptr&lt;Inspector::DOMFrontendDispatcher&gt; m_frontendDispatcher;
238     RefPtr&lt;Inspector::DOMBackendDispatcher&gt; m_backendDispatcher;
239     Page&amp; m_inspectedPage;
240     InspectorOverlay* m_overlay { nullptr };
241     NodeToIdMap m_documentNodeToIdMap;
242     // Owns node mappings for dangling nodes.
243     Vector&lt;std::unique_ptr&lt;NodeToIdMap&gt;&gt; m_danglingNodeToIdMaps;
244     HashMap&lt;int, Node*&gt; m_idToNode;
245     HashMap&lt;int, NodeToIdMap*&gt; m_idToNodesMap;
246     HashSet&lt;int&gt; m_childrenRequested;
247     int m_lastNodeId { 1 };
248     RefPtr&lt;Document&gt; m_document;
249     typedef HashMap&lt;String, Vector&lt;RefPtr&lt;Node&gt;&gt;&gt; SearchResults;
250     SearchResults m_searchResults;
251     std::unique_ptr&lt;RevalidateStyleAttributeTask&gt; m_revalidateStyleAttrTask;
252     RefPtr&lt;Node&gt; m_nodeToFocus;
253     RefPtr&lt;Node&gt; m_mousedOverNode;
254     RefPtr&lt;Node&gt; m_inspectedNode;
255     std::unique_ptr&lt;HighlightConfig&gt; m_inspectModeHighlightConfig;
256     std::unique_ptr&lt;InspectorHistory&gt; m_history;
257     std::unique_ptr&lt;DOMEditor&gt; m_domEditor;
<span class="line-removed">258     bool m_searchingForNode { false };</span>
<span class="line-removed">259     bool m_suppressAttributeModifiedEvent { false };</span>
<span class="line-removed">260     bool m_suppressEventListenerChangedEvent { false };</span>
<span class="line-removed">261     bool m_documentRequested { false };</span>
262 
263 #if ENABLE(VIDEO)
264     Timer m_mediaMetricsTimer;
265     struct MediaMetrics {
266         unsigned displayCompositedFrames { 0 };
267         bool isPowerEfficient { false };
268 
269         MediaMetrics() { }
270 
271         MediaMetrics(unsigned displayCompositedFrames)
272             : displayCompositedFrames(displayCompositedFrames)
273         {
274         }
275     };
276 
277     // The pointer key for this map should not be used for anything other than matching.
278     HashMap&lt;HTMLMediaElement*, MediaMetrics&gt; m_mediaMetrics;
279 #endif
280 
281     struct InspectorEventListener {
</pre>
<hr />
<pre>
300 
301         bool matches(EventTarget&amp; target, const AtomString&amp; type, EventListener&amp; listener, bool capture)
302         {
303             if (eventTarget.get() != &amp;target)
304                 return false;
305             if (eventListener.get() != &amp;listener)
306                 return false;
307             if (eventType != type)
308                 return false;
309             if (useCapture != capture)
310                 return false;
311             return true;
312         }
313     };
314 
315     friend class EventFiredCallback;
316 
317     HashSet&lt;const Event*&gt; m_dispatchedEvents;
318     HashMap&lt;int, InspectorEventListener&gt; m_eventListenerEntries;
319     int m_lastEventListenerId { 1 };






320 };
321 
322 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 29 
 30 #pragma once
 31 
 32 #include &quot;EventTarget.h&quot;
 33 #include &quot;InspectorWebAgentBase.h&quot;
 34 #include &quot;Timer.h&quot;
 35 #include &lt;JavaScriptCore/InspectorBackendDispatchers.h&gt;
 36 #include &lt;JavaScriptCore/InspectorFrontendDispatchers.h&gt;
 37 #include &lt;wtf/HashMap.h&gt;
 38 #include &lt;wtf/HashSet.h&gt;
 39 #include &lt;wtf/JSONValues.h&gt;
 40 #include &lt;wtf/RefPtr.h&gt;
 41 #include &lt;wtf/Vector.h&gt;
 42 #include &lt;wtf/text/AtomString.h&gt;
 43 
 44 namespace Inspector {
 45 class InjectedScriptManager;
 46 }
 47 
 48 namespace JSC {
<span class="line-modified"> 49 class CallFrame;</span>
 50 class JSValue;
 51 }
 52 
 53 namespace WebCore {
 54 
<span class="line-modified"> 55 class AXCoreObject;</span>
 56 class CharacterData;
 57 class DOMEditor;
 58 class Document;
 59 class Element;
 60 class Event;
 61 class Exception;
 62 class FloatQuad;
 63 class Frame;
 64 class InspectorHistory;
 65 class InspectorOverlay;
 66 #if ENABLE(VIDEO)
 67 class HTMLMediaElement;
 68 #endif
 69 class HitTestResult;
 70 class Node;
 71 class Page;
 72 class PseudoElement;
 73 class RevalidateStyleAttributeTask;
 74 class ShadowRoot;
 75 
 76 struct HighlightConfig;
 77 
 78 typedef String ErrorString;
 79 
 80 class InspectorDOMAgent final : public InspectorAgentBase, public Inspector::DOMBackendDispatcherHandler {
 81     WTF_MAKE_NONCOPYABLE(InspectorDOMAgent);
 82     WTF_MAKE_FAST_ALLOCATED;
 83 public:
 84     InspectorDOMAgent(PageAgentContext&amp;, InspectorOverlay*);
<span class="line-modified"> 85     ~InspectorDOMAgent() override;</span>
 86 
 87     static String toErrorString(ExceptionCode);
 88     static String toErrorString(Exception&amp;&amp;);
 89 
 90     static String documentURLString(Document*);
 91 
 92     // We represent embedded doms as a part of the same hierarchy. Hence we treat children of frame owners differently.
 93     // We also skip whitespace text nodes conditionally. Following methods encapsulate these specifics.
 94     static Node* innerFirstChild(Node*);
 95     static Node* innerNextSibling(Node*);
 96     static Node* innerPreviousSibling(Node*);
 97     static unsigned innerChildNodeCount(Node*);
 98     static Node* innerParentNode(Node*);
 99 
100     static Node* scriptValueAsNode(JSC::JSValue);
<span class="line-modified">101     static JSC::JSValue nodeAsScriptValue(JSC::JSGlobalObject&amp;, Node*);</span>
102 
103     // InspectorAgentBase
<span class="line-modified">104     void didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*) override;</span>
<span class="line-modified">105     void willDestroyFrontendAndBackend(Inspector::DisconnectReason) override;</span>
106 
107     // DOMBackendDispatcherHandler
<span class="line-modified">108     void querySelector(ErrorString&amp;, int nodeId, const String&amp; selectors, int* elementId) override;</span>
<span class="line-modified">109     void querySelectorAll(ErrorString&amp;, int nodeId, const String&amp; selectors, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; result) override;</span>
<span class="line-modified">110     void getDocument(ErrorString&amp;, RefPtr&lt;Inspector::Protocol::DOM::Node&gt;&amp; root) override;</span>
<span class="line-modified">111     void requestChildNodes(ErrorString&amp;, int nodeId, const int* depth) override;</span>
<span class="line-modified">112     void setAttributeValue(ErrorString&amp;, int elementId, const String&amp; name, const String&amp; value) override;</span>
<span class="line-modified">113     void setAttributesAsText(ErrorString&amp;, int elementId, const String&amp; text, const String* name) override;</span>
<span class="line-modified">114     void removeAttribute(ErrorString&amp;, int elementId, const String&amp; name) override;</span>
<span class="line-modified">115     void removeNode(ErrorString&amp;, int nodeId) override;</span>
<span class="line-modified">116     void setNodeName(ErrorString&amp;, int nodeId, const String&amp; name, int* newId) override;</span>
<span class="line-modified">117     void getOuterHTML(ErrorString&amp;, int nodeId, WTF::String* outerHTML) override;</span>
<span class="line-modified">118     void setOuterHTML(ErrorString&amp;, int nodeId, const String&amp; outerHTML) override;</span>
<span class="line-modified">119     void insertAdjacentHTML(ErrorString&amp;, int nodeId, const String&amp; position, const String&amp; html) override;</span>
<span class="line-modified">120     void setNodeValue(ErrorString&amp;, int nodeId, const String&amp; value) override;</span>
<span class="line-modified">121     void getSupportedEventNames(ErrorString&amp;, RefPtr&lt;JSON::ArrayOf&lt;String&gt;&gt;&amp; eventNames) override;</span>
<span class="line-modified">122     void getDataBindingsForNode(ErrorString&amp;, int nodeId, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::DataBinding&gt;&gt;&amp; dataArray) override;</span>
<span class="line-modified">123     void getAssociatedDataForNode(ErrorString&amp;, int nodeId, Optional&lt;String&gt;&amp; associatedData) override;</span>
<span class="line-modified">124     void getEventListenersForNode(ErrorString&amp;, int nodeId, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::EventListener&gt;&gt;&amp; listenersArray) override;</span>
<span class="line-modified">125     void setEventListenerDisabled(ErrorString&amp;, int eventListenerId, bool disabled) override;</span>
<span class="line-modified">126     void setBreakpointForEventListener(ErrorString&amp;, int eventListenerId) override;</span>
<span class="line-modified">127     void removeBreakpointForEventListener(ErrorString&amp;, int eventListenerId) override;</span>
<span class="line-modified">128     void getAccessibilityPropertiesForNode(ErrorString&amp;, int nodeId, RefPtr&lt;Inspector::Protocol::DOM::AccessibilityProperties&gt;&amp; axProperties) override;</span>
<span class="line-modified">129     void performSearch(ErrorString&amp;, const String&amp; query, const JSON::Array* nodeIds, const bool* caseSensitive, String* searchId, int* resultCount) override;</span>
<span class="line-modified">130     void getSearchResults(ErrorString&amp;, const String&amp; searchId, int fromIndex, int toIndex, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp;) override;</span>
<span class="line-modified">131     void discardSearchResults(ErrorString&amp;, const String&amp; searchId) override;</span>
<span class="line-modified">132     void resolveNode(ErrorString&amp;, int nodeId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result) override;</span>
<span class="line-modified">133     void getAttributes(ErrorString&amp;, int nodeId, RefPtr&lt;JSON::ArrayOf&lt;String&gt;&gt;&amp; result) override;</span>
<span class="line-modified">134     void setInspectModeEnabled(ErrorString&amp;, bool enabled, const JSON::Object* highlightConfig, const bool* showRulers) override;</span>
<span class="line-modified">135     void requestNode(ErrorString&amp;, const String&amp; objectId, int* nodeId) override;</span>
<span class="line-modified">136     void pushNodeByPathToFrontend(ErrorString&amp;, const String&amp; path, int* nodeId) override;</span>
<span class="line-modified">137     void hideHighlight(ErrorString&amp;) override;</span>
<span class="line-modified">138     void highlightRect(ErrorString&amp;, int x, int y, int width, int height, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates) override;</span>
<span class="line-modified">139     void highlightQuad(ErrorString&amp;, const JSON::Array&amp; quad, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates) override;</span>
<span class="line-modified">140     void highlightSelector(ErrorString&amp;, const JSON::Object&amp; highlightConfig, const String&amp; selectorString, const String* frameId) override;</span>
<span class="line-modified">141     void highlightNode(ErrorString&amp;, const JSON::Object&amp; highlightConfig, const int* nodeId, const String* objectId) override;</span>
<span class="line-modified">142     void highlightNodeList(ErrorString&amp;, const JSON::Array&amp; nodeIds, const JSON::Object&amp; highlightConfig) override;</span>
<span class="line-modified">143     void highlightFrame(ErrorString&amp;, const String&amp; frameId, const JSON::Object* color, const JSON::Object* outlineColor) override;</span>
<span class="line-modified">144     void moveTo(ErrorString&amp;, int nodeId, int targetNodeId, const int* anchorNodeId, int* newNodeId) override;</span>
<span class="line-modified">145     void undo(ErrorString&amp;) override;</span>
<span class="line-modified">146     void redo(ErrorString&amp;) override;</span>
<span class="line-modified">147     void markUndoableState(ErrorString&amp;) override;</span>
<span class="line-modified">148     void focus(ErrorString&amp;, int nodeId) override;</span>
<span class="line-modified">149     void setInspectedNode(ErrorString&amp;, int nodeId) override;</span>
<span class="line-added">150     void setAllowEditingUserAgentShadowTrees(ErrorString&amp;, bool allow) final;</span>
151 
152     // InspectorInstrumentation
153     int identifierForNode(Node&amp;);
154     void addEventListenersToNode(Node&amp;);
155     void didInsertDOMNode(Node&amp;);
156     void didRemoveDOMNode(Node&amp;);
157     void willModifyDOMAttr(Element&amp;, const AtomString&amp; oldValue, const AtomString&amp; newValue);
158     void didModifyDOMAttr(Element&amp;, const AtomString&amp; name, const AtomString&amp; value);
159     void didRemoveDOMAttr(Element&amp;, const AtomString&amp; name);
160     void characterDataModified(CharacterData&amp;);
161     void didInvalidateStyleAttr(Element&amp;);
162     void didPushShadowRoot(Element&amp; host, ShadowRoot&amp;);
163     void willPopShadowRoot(Element&amp; host, ShadowRoot&amp;);
164     void didChangeCustomElementState(Element&amp;);
165     bool handleTouchEvent(Node&amp;);
166     void didCommitLoad(Document*);
167     void frameDocumentUpdated(Frame&amp;);
168     void pseudoElementCreated(PseudoElement&amp;);
169     void pseudoElementDestroyed(PseudoElement&amp;);
170     void didAddEventListener(EventTarget&amp;);
171     void willRemoveEventListener(EventTarget&amp;, const AtomString&amp; eventType, EventListener&amp;, bool capture);
172     bool isEventListenerDisabled(EventTarget&amp;, const AtomString&amp; eventType, EventListener&amp;, bool capture);
173     void eventDidResetAfterDispatch(const Event&amp;);
174 
175     // Callbacks that don&#39;t directly correspond to an instrumentation entry point.
176     void setDocument(Document*);
177     void releaseDanglingNodes();
178 
179     void styleAttributeInvalidated(const Vector&lt;Element*&gt;&amp; elements);
180 
<span class="line-added">181     int pushNodeToFrontend(Node*);</span>
182     int pushNodeToFrontend(ErrorString&amp;, int documentNodeId, Node*);
<span class="line-added">183     int pushNodePathToFrontend(Node*);</span>
<span class="line-added">184     int pushNodePathToFrontend(ErrorString, Node*);</span>
185     Node* nodeForId(int nodeId);
186     int boundNodeId(const Node*);
187 
188     RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt; resolveNode(Node*, const String&amp; objectGroup);
189     bool handleMousePress();
190     void mouseDidMoveOverElement(const HitTestResult&amp;, unsigned modifierFlags);
191     void inspect(Node*);
192     void focusNode();
193 
194     InspectorHistory* history() { return m_history.get(); }
195     Vector&lt;Document*&gt; documents();
196     void reset();
197 
198     Node* assertNode(ErrorString&amp;, int nodeId);
199     Element* assertElement(ErrorString&amp;, int nodeId);
200     Document* assertDocument(ErrorString&amp;, int nodeId);
201 
202     bool hasBreakpointForEventListener(EventTarget&amp;, const AtomString&amp; eventType, EventListener&amp;, bool capture);
203     int idForEventListener(EventTarget&amp;, const AtomString&amp; eventType, EventListener&amp;, bool capture);
204 
205 private:
206 #if ENABLE(VIDEO)
207     void mediaMetricsTimerFired();
208 #endif
209 
210     void highlightMousedOverNode();
211     void setSearchingForNode(ErrorString&amp;, bool enabled, const JSON::Object* highlightConfig, bool showRulers);
212     std::unique_ptr&lt;HighlightConfig&gt; highlightConfigFromInspectorObject(ErrorString&amp;, const JSON::Object* highlightInspectorObject);
213 
214     // Node-related methods.
215     typedef HashMap&lt;RefPtr&lt;Node&gt;, int&gt; NodeToIdMap;
216     int bind(Node*, NodeToIdMap*);
217     void unbind(Node*, NodeToIdMap*);
218 
219     Node* assertEditableNode(ErrorString&amp;, int nodeId);
220     Element* assertEditableElement(ErrorString&amp;, int nodeId);
221 

222     void pushChildNodesToFrontend(int nodeId, int depth = 1);
223 
224     Ref&lt;Inspector::Protocol::DOM::Node&gt; buildObjectForNode(Node*, int depth, NodeToIdMap*);
225     Ref&lt;JSON::ArrayOf&lt;String&gt;&gt; buildArrayForElementAttributes(Element*);
226     Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;&gt; buildArrayForContainerChildren(Node* container, int depth, NodeToIdMap* nodesMap);
227     RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;&gt; buildArrayForPseudoElements(const Element&amp;, NodeToIdMap* nodesMap);
228     Ref&lt;Inspector::Protocol::DOM::EventListener&gt; buildObjectForEventListener(const RegisteredEventListener&amp;, int identifier, EventTarget&amp;, const AtomString&amp; eventType, bool disabled, bool hasBreakpoint);
229     RefPtr&lt;Inspector::Protocol::DOM::AccessibilityProperties&gt; buildObjectForAccessibilityProperties(Node*);
<span class="line-modified">230     void processAccessibilityChildren(AXCoreObject&amp;, JSON::ArrayOf&lt;int&gt;&amp;);</span>
231 
232     Node* nodeForPath(const String&amp; path);
233     Node* nodeForObjectId(const String&amp; objectId);
234 
235     void discardBindings();
236 
237     void innerHighlightQuad(std::unique_ptr&lt;FloatQuad&gt;, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates);
238 
239     Inspector::InjectedScriptManager&amp; m_injectedScriptManager;
240     std::unique_ptr&lt;Inspector::DOMFrontendDispatcher&gt; m_frontendDispatcher;
241     RefPtr&lt;Inspector::DOMBackendDispatcher&gt; m_backendDispatcher;
242     Page&amp; m_inspectedPage;
243     InspectorOverlay* m_overlay { nullptr };
244     NodeToIdMap m_documentNodeToIdMap;
245     // Owns node mappings for dangling nodes.
246     Vector&lt;std::unique_ptr&lt;NodeToIdMap&gt;&gt; m_danglingNodeToIdMaps;
247     HashMap&lt;int, Node*&gt; m_idToNode;
248     HashMap&lt;int, NodeToIdMap*&gt; m_idToNodesMap;
249     HashSet&lt;int&gt; m_childrenRequested;
250     int m_lastNodeId { 1 };
251     RefPtr&lt;Document&gt; m_document;
252     typedef HashMap&lt;String, Vector&lt;RefPtr&lt;Node&gt;&gt;&gt; SearchResults;
253     SearchResults m_searchResults;
254     std::unique_ptr&lt;RevalidateStyleAttributeTask&gt; m_revalidateStyleAttrTask;
255     RefPtr&lt;Node&gt; m_nodeToFocus;
256     RefPtr&lt;Node&gt; m_mousedOverNode;
257     RefPtr&lt;Node&gt; m_inspectedNode;
258     std::unique_ptr&lt;HighlightConfig&gt; m_inspectModeHighlightConfig;
259     std::unique_ptr&lt;InspectorHistory&gt; m_history;
260     std::unique_ptr&lt;DOMEditor&gt; m_domEditor;




261 
262 #if ENABLE(VIDEO)
263     Timer m_mediaMetricsTimer;
264     struct MediaMetrics {
265         unsigned displayCompositedFrames { 0 };
266         bool isPowerEfficient { false };
267 
268         MediaMetrics() { }
269 
270         MediaMetrics(unsigned displayCompositedFrames)
271             : displayCompositedFrames(displayCompositedFrames)
272         {
273         }
274     };
275 
276     // The pointer key for this map should not be used for anything other than matching.
277     HashMap&lt;HTMLMediaElement*, MediaMetrics&gt; m_mediaMetrics;
278 #endif
279 
280     struct InspectorEventListener {
</pre>
<hr />
<pre>
299 
300         bool matches(EventTarget&amp; target, const AtomString&amp; type, EventListener&amp; listener, bool capture)
301         {
302             if (eventTarget.get() != &amp;target)
303                 return false;
304             if (eventListener.get() != &amp;listener)
305                 return false;
306             if (eventType != type)
307                 return false;
308             if (useCapture != capture)
309                 return false;
310             return true;
311         }
312     };
313 
314     friend class EventFiredCallback;
315 
316     HashSet&lt;const Event*&gt; m_dispatchedEvents;
317     HashMap&lt;int, InspectorEventListener&gt; m_eventListenerEntries;
318     int m_lastEventListenerId { 1 };
<span class="line-added">319 </span>
<span class="line-added">320     bool m_searchingForNode { false };</span>
<span class="line-added">321     bool m_suppressAttributeModifiedEvent { false };</span>
<span class="line-added">322     bool m_suppressEventListenerChangedEvent { false };</span>
<span class="line-added">323     bool m_documentRequested { false };</span>
<span class="line-added">324     bool m_allowEditingUserAgentShadowTrees { false };</span>
325 };
326 
327 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="InspectorDOMAgent.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorDOMDebuggerAgent.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
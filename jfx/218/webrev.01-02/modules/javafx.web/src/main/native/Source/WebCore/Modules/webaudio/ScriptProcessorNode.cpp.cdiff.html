<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webaudio/ScriptProcessorNode.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RealtimeAnalyser.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScriptProcessorNode.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webaudio/ScriptProcessorNode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 49,19 ***</span>
      return adoptRef(*new ScriptProcessorNode(context, sampleRate, bufferSize, numberOfInputChannels, numberOfOutputChannels));
  }
  
  ScriptProcessorNode::ScriptProcessorNode(AudioContext&amp; context, float sampleRate, size_t bufferSize, unsigned numberOfInputChannels, unsigned numberOfOutputChannels)
      : AudioNode(context, sampleRate)
      , m_doubleBufferIndex(0)
      , m_doubleBufferIndexForEvent(0)
      , m_bufferSize(bufferSize)
      , m_bufferReadWriteIndex(0)
      , m_isRequestOutstanding(false)
      , m_numberOfInputChannels(numberOfInputChannels)
      , m_numberOfOutputChannels(numberOfOutputChannels)
      , m_internalInputBus(AudioBus::create(numberOfInputChannels, AudioNode::ProcessingSizeInFrames, false))
<span class="line-removed">-     , m_hasAudioProcessListener(false)</span>
  {
      // Regardless of the allowed buffer sizes, we still need to process at the granularity of the AudioNode.
      if (m_bufferSize &lt; AudioNode::ProcessingSizeInFrames)
          m_bufferSize = AudioNode::ProcessingSizeInFrames;
  
<span class="line-new-header">--- 49,19 ---</span>
      return adoptRef(*new ScriptProcessorNode(context, sampleRate, bufferSize, numberOfInputChannels, numberOfOutputChannels));
  }
  
  ScriptProcessorNode::ScriptProcessorNode(AudioContext&amp; context, float sampleRate, size_t bufferSize, unsigned numberOfInputChannels, unsigned numberOfOutputChannels)
      : AudioNode(context, sampleRate)
<span class="line-added">+     , ActiveDOMObject(context.scriptExecutionContext())</span>
      , m_doubleBufferIndex(0)
      , m_doubleBufferIndexForEvent(0)
      , m_bufferSize(bufferSize)
      , m_bufferReadWriteIndex(0)
      , m_isRequestOutstanding(false)
      , m_numberOfInputChannels(numberOfInputChannels)
      , m_numberOfOutputChannels(numberOfOutputChannels)
      , m_internalInputBus(AudioBus::create(numberOfInputChannels, AudioNode::ProcessingSizeInFrames, false))
  {
      // Regardless of the allowed buffer sizes, we still need to process at the granularity of the AudioNode.
      if (m_bufferSize &lt; AudioNode::ProcessingSizeInFrames)
          m_bufferSize = AudioNode::ProcessingSizeInFrames;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 70,14 ***</span>
<span class="line-new-header">--- 70,17 ---</span>
      setNodeType(NodeTypeJavaScript);
      addInput(makeUnique&lt;AudioNodeInput&gt;(this));
      addOutput(makeUnique&lt;AudioNodeOutput&gt;(this, numberOfOutputChannels));
  
      initialize();
<span class="line-added">+     suspendIfNeeded();</span>
<span class="line-added">+     m_pendingActivity = makePendingActivity(*this);</span>
  }
  
  ScriptProcessorNode::~ScriptProcessorNode()
  {
<span class="line-added">+     ASSERT(!hasPendingActivity());</span>
      uninitialize();
  }
  
  void ScriptProcessorNode::initialize()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 108,22 ***</span>
      m_outputBuffers.clear();
  
      AudioNode::uninitialize();
  }
  
  void ScriptProcessorNode::process(size_t framesToProcess)
  {
      // Discussion about inputs and outputs:
      // As in other AudioNodes, ScriptProcessorNode uses an AudioBus for its input and output (see inputBus and outputBus below).
      // Additionally, there is a double-buffering for input and output which is exposed directly to JavaScript (see inputBuffer and outputBuffer below).
      // This node is the producer for inputBuffer and the consumer for outputBuffer.
      // The JavaScript code is the consumer of inputBuffer and the producer for outputBuffer.
  
<span class="line-removed">-     // Check if audioprocess listener is set.</span>
<span class="line-removed">-     if (!m_hasAudioProcessListener)</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">- </span>
      // Get input and output busses.
      AudioBus* inputBus = this-&gt;input(0)-&gt;bus();
      AudioBus* outputBus = this-&gt;output(0)-&gt;bus();
  
      // Get input and output buffers. We double-buffer both the input and output sides.
<span class="line-new-header">--- 111,25 ---</span>
      m_outputBuffers.clear();
  
      AudioNode::uninitialize();
  }
  
<span class="line-added">+ void ScriptProcessorNode::didBecomeMarkedForDeletion()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(context().isGraphOwner());</span>
<span class="line-added">+     m_pendingActivity = nullptr;</span>
<span class="line-added">+     ASSERT(!hasPendingActivity());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void ScriptProcessorNode::process(size_t framesToProcess)
  {
      // Discussion about inputs and outputs:
      // As in other AudioNodes, ScriptProcessorNode uses an AudioBus for its input and output (see inputBus and outputBus below).
      // Additionally, there is a double-buffering for input and output which is exposed directly to JavaScript (see inputBuffer and outputBuffer below).
      // This node is the producer for inputBuffer and the consumer for outputBuffer.
      // The JavaScript code is the consumer of inputBuffer and the producer for outputBuffer.
  
      // Get input and output busses.
      AudioBus* inputBus = this-&gt;input(0)-&gt;bus();
      AudioBus* outputBus = this-&gt;output(0)-&gt;bus();
  
      // Get input and output buffers. We double-buffer both the input and output sides.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 190,13 ***</span>
              // Fire the event on the main thread, not this one (which is the realtime audio thread).
              m_doubleBufferIndexForEvent = m_doubleBufferIndex;
              m_isRequestOutstanding = true;
  
              callOnMainThread([this] {
<span class="line-removed">-                 if (!m_hasAudioProcessListener)</span>
<span class="line-removed">-                     return;</span>
<span class="line-removed">- </span>
                  fireProcessEvent();
  
                  // De-reference to match the ref() call in process().
                  deref();
              });
<span class="line-new-header">--- 196,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 254,30 ***</span>
  double ScriptProcessorNode::latencyTime() const
  {
      return std::numeric_limits&lt;double&gt;::infinity();
  }
  
<span class="line-removed">- bool ScriptProcessorNode::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     bool success = AudioNode::addEventListener(eventType, WTFMove(listener), options);</span>
<span class="line-removed">-     if (success &amp;&amp; eventType == eventNames().audioprocessEvent)</span>
<span class="line-removed">-         m_hasAudioProcessListener = hasEventListeners(eventNames().audioprocessEvent);</span>
<span class="line-removed">-     return success;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- bool ScriptProcessorNode::removeEventListener(const AtomString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     bool success = AudioNode::removeEventListener(eventType, listener, options);</span>
<span class="line-removed">-     if (success &amp;&amp; eventType == eventNames().audioprocessEvent)</span>
<span class="line-removed">-         m_hasAudioProcessListener = hasEventListeners(eventNames().audioprocessEvent);</span>
<span class="line-removed">-     return success;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void ScriptProcessorNode::removeAllEventListeners()</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     m_hasAudioProcessListener = false;</span>
<span class="line-removed">-     AudioNode::removeAllEventListeners();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  } // namespace WebCore
  
  #endif // ENABLE(WEB_AUDIO)
<span class="line-new-header">--- 257,8 ---</span>
</pre>
<center><a href="RealtimeAnalyser.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScriptProcessorNode.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
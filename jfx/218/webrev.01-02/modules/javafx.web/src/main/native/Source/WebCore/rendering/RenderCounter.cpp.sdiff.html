<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderCounter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderBoxModelObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderDeprecatedFlexibleBox.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderCounter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 58 }
 59 
 60 // This function processes the renderer tree in the order of the DOM tree
 61 // including pseudo elements as defined in CSS 2.1.
 62 static RenderElement* previousInPreOrder(const RenderElement&amp; renderer)
 63 {
 64     ASSERT(renderer.element());
 65     Element* previous = ElementTraversal::previousIncludingPseudo(*renderer.element());
 66     while (previous &amp;&amp; !previous-&gt;renderer())
 67         previous = ElementTraversal::previousIncludingPseudo(*previous);
 68     return previous ? previous-&gt;renderer() : 0;
 69 }
 70 
 71 static inline Element* parentOrPseudoHostElement(const RenderElement&amp; renderer)
 72 {
 73     if (renderer.isPseudoElement())
 74         return renderer.generatingElement();
 75     return renderer.element() ? renderer.element()-&gt;parentElement() : nullptr;
 76 }
 77 
























 78 // This function processes the renderer tree in the order of the DOM tree
 79 // including pseudo elements as defined in CSS 2.1.
 80 static RenderElement* previousSiblingOrParent(const RenderElement&amp; renderer)
 81 {
 82     ASSERT(renderer.element());
<span class="line-modified"> 83     Element* previous = ElementTraversal::pseudoAwarePreviousSibling(*renderer.element());</span>
<span class="line-modified"> 84     while (previous &amp;&amp; !previous-&gt;renderer())</span>
<span class="line-removed"> 85         previous = ElementTraversal::pseudoAwarePreviousSibling(*previous);</span>
<span class="line-removed"> 86     if (previous)</span>
<span class="line-removed"> 87         return previous-&gt;renderer();</span>
<span class="line-removed"> 88     previous = parentOrPseudoHostElement(renderer);</span>
 89     return previous ? previous-&gt;renderer() : nullptr;
 90 }
 91 
 92 static inline bool areRenderersElementsSiblings(const RenderElement&amp; first, const RenderElement&amp; second)
 93 {
 94     return parentOrPseudoHostElement(first) == parentOrPseudoHostElement(second);
 95 }
 96 
 97 // This function processes the renderer tree in the order of the DOM tree
 98 // including pseudo elements as defined in CSS 2.1.
 99 static RenderElement* nextInPreOrder(const RenderElement&amp; renderer, const Element* stayWithin, bool skipDescendants = false)
100 {
101     ASSERT(renderer.element());
102     Element&amp; self = *renderer.element();
103     Element* next = skipDescendants ? ElementTraversal::nextIncludingPseudoSkippingChildren(self, stayWithin) : ElementTraversal::nextIncludingPseudo(self, stayWithin);
104     while (next &amp;&amp; !next-&gt;renderer())
105         next = skipDescendants ? ElementTraversal::nextIncludingPseudoSkippingChildren(*next, stayWithin) : ElementTraversal::nextIncludingPseudo(*next, stayWithin);
106     return next ? next-&gt;renderer() : nullptr;
107 }
108 
</pre>
</td>
<td>
<hr />
<pre>
 58 }
 59 
 60 // This function processes the renderer tree in the order of the DOM tree
 61 // including pseudo elements as defined in CSS 2.1.
 62 static RenderElement* previousInPreOrder(const RenderElement&amp; renderer)
 63 {
 64     ASSERT(renderer.element());
 65     Element* previous = ElementTraversal::previousIncludingPseudo(*renderer.element());
 66     while (previous &amp;&amp; !previous-&gt;renderer())
 67         previous = ElementTraversal::previousIncludingPseudo(*previous);
 68     return previous ? previous-&gt;renderer() : 0;
 69 }
 70 
 71 static inline Element* parentOrPseudoHostElement(const RenderElement&amp; renderer)
 72 {
 73     if (renderer.isPseudoElement())
 74         return renderer.generatingElement();
 75     return renderer.element() ? renderer.element()-&gt;parentElement() : nullptr;
 76 }
 77 
<span class="line-added"> 78 static Element* previousSiblingOrParentElement(const Element&amp; element)</span>
<span class="line-added"> 79 {</span>
<span class="line-added"> 80     if (auto* previous = ElementTraversal::pseudoAwarePreviousSibling(element)) {</span>
<span class="line-added"> 81         while (previous &amp;&amp; !previous-&gt;renderer())</span>
<span class="line-added"> 82             previous = ElementTraversal::pseudoAwarePreviousSibling(*previous);</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84         if (previous)</span>
<span class="line-added"> 85             return previous;</span>
<span class="line-added"> 86     }</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88     if (is&lt;PseudoElement&gt;(element)) {</span>
<span class="line-added"> 89         auto* hostElement = downcast&lt;PseudoElement&gt;(element).hostElement();</span>
<span class="line-added"> 90         ASSERT(hostElement);</span>
<span class="line-added"> 91         if (hostElement-&gt;renderer())</span>
<span class="line-added"> 92             return hostElement;</span>
<span class="line-added"> 93         return previousSiblingOrParentElement(*hostElement);</span>
<span class="line-added"> 94     }</span>
<span class="line-added"> 95 </span>
<span class="line-added"> 96     auto* parent = element.parentElement();</span>
<span class="line-added"> 97     if (parent &amp;&amp; !parent-&gt;renderer())</span>
<span class="line-added"> 98         parent = previousSiblingOrParentElement(*parent);</span>
<span class="line-added"> 99     return parent;</span>
<span class="line-added">100 }</span>
<span class="line-added">101 </span>
102 // This function processes the renderer tree in the order of the DOM tree
103 // including pseudo elements as defined in CSS 2.1.
104 static RenderElement* previousSiblingOrParent(const RenderElement&amp; renderer)
105 {
106     ASSERT(renderer.element());
<span class="line-modified">107 </span>
<span class="line-modified">108     auto* previous = previousSiblingOrParentElement(*renderer.element());</span>




109     return previous ? previous-&gt;renderer() : nullptr;
110 }
111 
112 static inline bool areRenderersElementsSiblings(const RenderElement&amp; first, const RenderElement&amp; second)
113 {
114     return parentOrPseudoHostElement(first) == parentOrPseudoHostElement(second);
115 }
116 
117 // This function processes the renderer tree in the order of the DOM tree
118 // including pseudo elements as defined in CSS 2.1.
119 static RenderElement* nextInPreOrder(const RenderElement&amp; renderer, const Element* stayWithin, bool skipDescendants = false)
120 {
121     ASSERT(renderer.element());
122     Element&amp; self = *renderer.element();
123     Element* next = skipDescendants ? ElementTraversal::nextIncludingPseudoSkippingChildren(self, stayWithin) : ElementTraversal::nextIncludingPseudo(self, stayWithin);
124     while (next &amp;&amp; !next-&gt;renderer())
125         next = skipDescendants ? ElementTraversal::nextIncludingPseudoSkippingChildren(*next, stayWithin) : ElementTraversal::nextIncludingPseudo(*next, stayWithin);
126     return next ? next-&gt;renderer() : nullptr;
127 }
128 
</pre>
</td>
</tr>
</table>
<center><a href="RenderBoxModelObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderDeprecatedFlexibleBox.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
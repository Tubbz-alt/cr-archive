<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSCustomElementInterface.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSCanvasRenderingContext2DCustom.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSCustomElementInterface.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSCustomElementInterface.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 53,11 ***</span>
  {
  }
  
  JSCustomElementInterface::~JSCustomElementInterface() = default;
  
<span class="line-modified">! static RefPtr&lt;Element&gt; constructCustomElementSynchronously(Document&amp;, VM&amp;, ExecState&amp;, JSObject* constructor, const AtomString&amp; localName);</span>
  
  Ref&lt;Element&gt; JSCustomElementInterface::constructElementWithFallback(Document&amp; document, const AtomString&amp; localName)
  {
      if (auto element = tryToConstructCustomElement(document, localName))
          return element.releaseNonNull();
<span class="line-new-header">--- 53,11 ---</span>
  {
  }
  
  JSCustomElementInterface::~JSCustomElementInterface() = default;
  
<span class="line-modified">! static RefPtr&lt;Element&gt; constructCustomElementSynchronously(Document&amp;, VM&amp;, JSGlobalObject&amp;, JSObject* constructor, const AtomString&amp; localName);</span>
  
  Ref&lt;Element&gt; JSCustomElementInterface::constructElementWithFallback(Document&amp; document, const AtomString&amp; localName)
  {
      if (auto element = tryToConstructCustomElement(document, localName))
          return element.releaseNonNull();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 97,68 ***</span>
  
      if (!m_constructor)
          return nullptr;
  
      ASSERT(&amp;document == scriptExecutionContext());
<span class="line-modified">!     auto&amp; state = *document.execState();</span>
<span class="line-modified">!     auto element = constructCustomElementSynchronously(document, vm, state, m_constructor.get(), localName);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !element);
      if (!element) {
          auto* exception = scope.exception();
          scope.clearException();
<span class="line-modified">!         reportException(&amp;state, exception);</span>
          return nullptr;
      }
  
      return element;
  }
  
  // https://dom.spec.whatwg.org/#concept-create-element
  // 6. 1. If the synchronous custom elements flag is set
<span class="line-modified">! static RefPtr&lt;Element&gt; constructCustomElementSynchronously(Document&amp; document, VM&amp; vm, ExecState&amp; state, JSObject* constructor, const AtomString&amp; localName)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
      ConstructData constructData;
      ConstructType constructType = constructor-&gt;methodTable(vm)-&gt;getConstructData(constructor, constructData);
      if (constructType == ConstructType::None) {
          ASSERT_NOT_REACHED();
          return nullptr;
      }
  
<span class="line-modified">!     InspectorInstrumentationCookie cookie = JSExecState::instrumentFunctionConstruct(&amp;document, constructType, constructData);</span>
      MarkedArgumentBuffer args;
      ASSERT(!args.hasOverflowed());
<span class="line-modified">!     JSValue newElement = construct(&amp;state, constructor, constructType, constructData, args);</span>
<span class="line-modified">!     InspectorInstrumentation::didCallFunction(cookie, &amp;document);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      ASSERT(!newElement.isEmpty());
      HTMLElement* wrappedElement = JSHTMLElement::toWrapped(vm, newElement);
      if (!wrappedElement) {
<span class="line-modified">!         throwTypeError(&amp;state, scope, &quot;The result of constructing a custom element must be a HTMLElement&quot;_s);</span>
          return nullptr;
      }
  
      if (wrappedElement-&gt;hasAttributes()) {
<span class="line-modified">!         throwNotSupportedError(state, scope, &quot;A newly constructed custom element must not have attributes&quot;_s);</span>
          return nullptr;
      }
      if (wrappedElement-&gt;hasChildNodes()) {
<span class="line-modified">!         throwNotSupportedError(state, scope, &quot;A newly constructed custom element must not have child nodes&quot;_s);</span>
          return nullptr;
      }
      if (wrappedElement-&gt;parentNode()) {
<span class="line-modified">!         throwNotSupportedError(state, scope, &quot;A newly constructed custom element must not have a parent node&quot;_s);</span>
          return nullptr;
      }
      if (&amp;wrappedElement-&gt;document() != &amp;document) {
<span class="line-modified">!         throwNotSupportedError(state, scope, &quot;A newly constructed custom element belongs to a wrong document&quot;_s);</span>
          return nullptr;
      }
      ASSERT(wrappedElement-&gt;namespaceURI() == HTMLNames::xhtmlNamespaceURI);
      if (wrappedElement-&gt;localName() != localName) {
<span class="line-modified">!         throwNotSupportedError(state, scope, &quot;A newly constructed custom element has incorrect local name&quot;_s);</span>
          return nullptr;
      }
  
      return wrappedElement;
  }
<span class="line-new-header">--- 97,68 ---</span>
  
      if (!m_constructor)
          return nullptr;
  
      ASSERT(&amp;document == scriptExecutionContext());
<span class="line-modified">!     auto&amp; lexicalGlobalObject = *document.execState();</span>
<span class="line-modified">!     auto element = constructCustomElementSynchronously(document, vm, lexicalGlobalObject, m_constructor.get(), localName);</span>
      EXCEPTION_ASSERT(!!scope.exception() == !element);
      if (!element) {
          auto* exception = scope.exception();
          scope.clearException();
<span class="line-modified">!         reportException(&amp;lexicalGlobalObject, exception);</span>
          return nullptr;
      }
  
      return element;
  }
  
  // https://dom.spec.whatwg.org/#concept-create-element
  // 6. 1. If the synchronous custom elements flag is set
<span class="line-modified">! static RefPtr&lt;Element&gt; constructCustomElementSynchronously(Document&amp; document, VM&amp; vm, JSGlobalObject&amp; lexicalGlobalObject, JSObject* constructor, const AtomString&amp; localName)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
      ConstructData constructData;
      ConstructType constructType = constructor-&gt;methodTable(vm)-&gt;getConstructData(constructor, constructData);
      if (constructType == ConstructType::None) {
          ASSERT_NOT_REACHED();
          return nullptr;
      }
  
<span class="line-modified">!     JSExecState::instrumentFunctionConstruct(&amp;document, constructType, constructData);</span>
      MarkedArgumentBuffer args;
      ASSERT(!args.hasOverflowed());
<span class="line-modified">!     JSValue newElement = construct(&amp;lexicalGlobalObject, constructor, constructType, constructData, args);</span>
<span class="line-modified">!     InspectorInstrumentation::didCallFunction(&amp;document);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
  
      ASSERT(!newElement.isEmpty());
      HTMLElement* wrappedElement = JSHTMLElement::toWrapped(vm, newElement);
      if (!wrappedElement) {
<span class="line-modified">!         throwTypeError(&amp;lexicalGlobalObject, scope, &quot;The result of constructing a custom element must be a HTMLElement&quot;_s);</span>
          return nullptr;
      }
  
      if (wrappedElement-&gt;hasAttributes()) {
<span class="line-modified">!         throwNotSupportedError(lexicalGlobalObject, scope, &quot;A newly constructed custom element must not have attributes&quot;_s);</span>
          return nullptr;
      }
      if (wrappedElement-&gt;hasChildNodes()) {
<span class="line-modified">!         throwNotSupportedError(lexicalGlobalObject, scope, &quot;A newly constructed custom element must not have child nodes&quot;_s);</span>
          return nullptr;
      }
      if (wrappedElement-&gt;parentNode()) {
<span class="line-modified">!         throwNotSupportedError(lexicalGlobalObject, scope, &quot;A newly constructed custom element must not have a parent node&quot;_s);</span>
          return nullptr;
      }
      if (&amp;wrappedElement-&gt;document() != &amp;document) {
<span class="line-modified">!         throwNotSupportedError(lexicalGlobalObject, scope, &quot;A newly constructed custom element belongs to a wrong document&quot;_s);</span>
          return nullptr;
      }
      ASSERT(wrappedElement-&gt;namespaceURI() == HTMLNames::xhtmlNamespaceURI);
      if (wrappedElement-&gt;localName() != localName) {
<span class="line-modified">!         throwNotSupportedError(lexicalGlobalObject, scope, &quot;A newly constructed custom element has incorrect local name&quot;_s);</span>
          return nullptr;
      }
  
      return wrappedElement;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 182,11 ***</span>
      if (!context)
          return;
      auto* globalObject = toJSDOMWindow(downcast&lt;Document&gt;(*context).frame(), m_isolatedWorld);
      if (!globalObject)
          return;
<span class="line-modified">!     ExecState* state = globalObject-&gt;globalExec();</span>
  
      ConstructData constructData;
      ConstructType constructType = m_constructor-&gt;methodTable(vm)-&gt;getConstructData(m_constructor.get(), constructData);
      if (constructType == ConstructType::None) {
          ASSERT_NOT_REACHED();
<span class="line-new-header">--- 182,11 ---</span>
      if (!context)
          return;
      auto* globalObject = toJSDOMWindow(downcast&lt;Document&gt;(*context).frame(), m_isolatedWorld);
      if (!globalObject)
          return;
<span class="line-modified">!     JSGlobalObject* lexicalGlobalObject = globalObject;</span>
  
      ConstructData constructData;
      ConstructType constructType = m_constructor-&gt;methodTable(vm)-&gt;getConstructData(m_constructor.get(), constructData);
      if (constructType == ConstructType::None) {
          ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 197,32 ***</span>
  
      m_constructionStack.append(&amp;element);
  
      MarkedArgumentBuffer args;
      ASSERT(!args.hasOverflowed());
<span class="line-modified">!     InspectorInstrumentationCookie cookie = JSExecState::instrumentFunctionConstruct(context, constructType, constructData);</span>
<span class="line-modified">!     JSValue returnedElement = construct(state, m_constructor.get(), constructType, constructData, args);</span>
<span class="line-modified">!     InspectorInstrumentation::didCallFunction(cookie, context);</span>
  
      m_constructionStack.removeLast();
  
      if (UNLIKELY(scope.exception())) {
          element.setIsFailedCustomElement(*this);
<span class="line-modified">!         reportException(state, scope.exception());</span>
          return;
      }
  
      Element* wrappedElement = JSElement::toWrapped(vm, returnedElement);
      if (!wrappedElement || wrappedElement != &amp;element) {
          element.setIsFailedCustomElement(*this);
<span class="line-modified">!         reportException(state, createDOMException(state, TypeError, &quot;Custom element constructor returned a wrong element&quot;));</span>
          return;
      }
      element.setIsDefinedCustomElement(*this);
  }
  
<span class="line-modified">! void JSCustomElementInterface::invokeCallback(Element&amp; element, JSObject* callback, const WTF::Function&lt;void(ExecState*, JSDOMGlobalObject*, MarkedArgumentBuffer&amp;)&gt;&amp; addArguments)</span>
  {
      if (!canInvokeCallback())
          return;
  
      auto* context = scriptExecutionContext();
<span class="line-new-header">--- 197,32 ---</span>
  
      m_constructionStack.append(&amp;element);
  
      MarkedArgumentBuffer args;
      ASSERT(!args.hasOverflowed());
<span class="line-modified">!     JSExecState::instrumentFunctionConstruct(context, constructType, constructData);</span>
<span class="line-modified">!     JSValue returnedElement = construct(lexicalGlobalObject, m_constructor.get(), constructType, constructData, args);</span>
<span class="line-modified">!     InspectorInstrumentation::didCallFunction(context);</span>
  
      m_constructionStack.removeLast();
  
      if (UNLIKELY(scope.exception())) {
          element.setIsFailedCustomElement(*this);
<span class="line-modified">!         reportException(lexicalGlobalObject, scope.exception());</span>
          return;
      }
  
      Element* wrappedElement = JSElement::toWrapped(vm, returnedElement);
      if (!wrappedElement || wrappedElement != &amp;element) {
          element.setIsFailedCustomElement(*this);
<span class="line-modified">!         reportException(lexicalGlobalObject, createDOMException(lexicalGlobalObject, TypeError, &quot;Custom element constructor returned a wrong element&quot;));</span>
          return;
      }
      element.setIsDefinedCustomElement(*this);
  }
  
<span class="line-modified">! void JSCustomElementInterface::invokeCallback(Element&amp; element, JSObject* callback, const WTF::Function&lt;void(JSGlobalObject*, JSDOMGlobalObject*, MarkedArgumentBuffer&amp;)&gt;&amp; addArguments)</span>
  {
      if (!canInvokeCallback())
          return;
  
      auto* context = scriptExecutionContext();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 234,31 ***</span>
      JSLockHolder lock(vm);
  
      auto* globalObject = toJSDOMWindow(downcast&lt;Document&gt;(*context).frame(), m_isolatedWorld);
      if (!globalObject)
          return;
<span class="line-modified">!     ExecState* state = globalObject-&gt;globalExec();</span>
  
<span class="line-modified">!     JSObject* jsElement = asObject(toJS(state, globalObject, element));</span>
  
      CallData callData;
      CallType callType = callback-&gt;methodTable(vm)-&gt;getCallData(callback, callData);
      ASSERT(callType != CallType::None);
  
      MarkedArgumentBuffer args;
<span class="line-modified">!     addArguments(state, globalObject, args);</span>
      RELEASE_ASSERT(!args.hasOverflowed());
  
<span class="line-modified">!     InspectorInstrumentationCookie cookie = JSExecState::instrumentFunctionCall(context, callType, callData);</span>
  
      NakedPtr&lt;JSC::Exception&gt; exception;
<span class="line-modified">!     JSExecState::call(state, callback, callType, callData, jsElement, args, exception);</span>
  
<span class="line-modified">!     InspectorInstrumentation::didCallFunction(cookie, context);</span>
  
      if (exception)
<span class="line-modified">!         reportException(state, exception);</span>
  }
  
  void JSCustomElementInterface::setConnectedCallback(JSC::JSObject* callback)
  {
      m_connectedCallback = callback;
<span class="line-new-header">--- 234,31 ---</span>
      JSLockHolder lock(vm);
  
      auto* globalObject = toJSDOMWindow(downcast&lt;Document&gt;(*context).frame(), m_isolatedWorld);
      if (!globalObject)
          return;
<span class="line-modified">!     JSGlobalObject* lexicalGlobalObject = globalObject;</span>
  
<span class="line-modified">!     JSObject* jsElement = asObject(toJS(lexicalGlobalObject, globalObject, element));</span>
  
      CallData callData;
      CallType callType = callback-&gt;methodTable(vm)-&gt;getCallData(callback, callData);
      ASSERT(callType != CallType::None);
  
      MarkedArgumentBuffer args;
<span class="line-modified">!     addArguments(lexicalGlobalObject, globalObject, args);</span>
      RELEASE_ASSERT(!args.hasOverflowed());
  
<span class="line-modified">!     JSExecState::instrumentFunctionCall(context, callType, callData);</span>
  
      NakedPtr&lt;JSC::Exception&gt; exception;
<span class="line-modified">!     JSExecState::call(lexicalGlobalObject, callback, callType, callData, jsElement, args, exception);</span>
  
<span class="line-modified">!     InspectorInstrumentation::didCallFunction(context);</span>
  
      if (exception)
<span class="line-modified">!         reportException(lexicalGlobalObject, exception);</span>
  }
  
  void JSCustomElementInterface::setConnectedCallback(JSC::JSObject* callback)
  {
      m_connectedCallback = callback;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 284,13 ***</span>
      m_adoptedCallback = callback;
  }
  
  void JSCustomElementInterface::invokeAdoptedCallback(Element&amp; element, Document&amp; oldDocument, Document&amp; newDocument)
  {
<span class="line-modified">!     invokeCallback(element, m_adoptedCallback.get(), [&amp;](ExecState* state, JSDOMGlobalObject* globalObject, MarkedArgumentBuffer&amp; args) {</span>
<span class="line-modified">!         args.append(toJS(state, globalObject, oldDocument));</span>
<span class="line-modified">!         args.append(toJS(state, globalObject, newDocument));</span>
      });
  }
  
  void JSCustomElementInterface::setAttributeChangedCallback(JSC::JSObject* callback, const Vector&lt;String&gt;&amp; observedAttributes)
  {
<span class="line-new-header">--- 284,13 ---</span>
      m_adoptedCallback = callback;
  }
  
  void JSCustomElementInterface::invokeAdoptedCallback(Element&amp; element, Document&amp; oldDocument, Document&amp; newDocument)
  {
<span class="line-modified">!     invokeCallback(element, m_adoptedCallback.get(), [&amp;](JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, MarkedArgumentBuffer&amp; args) {</span>
<span class="line-modified">!         args.append(toJS(lexicalGlobalObject, globalObject, oldDocument));</span>
<span class="line-modified">!         args.append(toJS(lexicalGlobalObject, globalObject, newDocument));</span>
      });
  }
  
  void JSCustomElementInterface::setAttributeChangedCallback(JSC::JSObject* callback, const Vector&lt;String&gt;&amp; observedAttributes)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 300,15 ***</span>
          m_observedAttributes.add(name);
  }
  
  void JSCustomElementInterface::invokeAttributeChangedCallback(Element&amp; element, const QualifiedName&amp; attributeName, const AtomString&amp; oldValue, const AtomString&amp; newValue)
  {
<span class="line-modified">!     invokeCallback(element, m_attributeChangedCallback.get(), [&amp;](ExecState* state, JSDOMGlobalObject*, MarkedArgumentBuffer&amp; args) {</span>
<span class="line-modified">!         args.append(toJS&lt;IDLDOMString&gt;(*state, attributeName.localName()));</span>
<span class="line-modified">!         args.append(toJS&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(*state, oldValue));</span>
<span class="line-modified">!         args.append(toJS&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(*state, newValue));</span>
<span class="line-modified">!         args.append(toJS&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(*state, attributeName.namespaceURI()));</span>
      });
  }
  
  void JSCustomElementInterface::didUpgradeLastElementInConstructionStack()
  {
<span class="line-new-header">--- 300,15 ---</span>
          m_observedAttributes.add(name);
  }
  
  void JSCustomElementInterface::invokeAttributeChangedCallback(Element&amp; element, const QualifiedName&amp; attributeName, const AtomString&amp; oldValue, const AtomString&amp; newValue)
  {
<span class="line-modified">!     invokeCallback(element, m_attributeChangedCallback.get(), [&amp;](JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject*, MarkedArgumentBuffer&amp; args) {</span>
<span class="line-modified">!         args.append(toJS&lt;IDLDOMString&gt;(*lexicalGlobalObject, attributeName.localName()));</span>
<span class="line-modified">!         args.append(toJS&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(*lexicalGlobalObject, oldValue));</span>
<span class="line-modified">!         args.append(toJS&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(*lexicalGlobalObject, newValue));</span>
<span class="line-modified">!         args.append(toJS&lt;IDLNullable&lt;IDLDOMString&gt;&gt;(*lexicalGlobalObject, attributeName.namespaceURI()));</span>
      });
  }
  
  void JSCustomElementInterface::didUpgradeLastElementInConstructionStack()
  {
</pre>
<center><a href="JSCanvasRenderingContext2DCustom.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSCustomElementInterface.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
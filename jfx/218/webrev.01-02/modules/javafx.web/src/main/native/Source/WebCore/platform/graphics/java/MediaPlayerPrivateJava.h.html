<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/java/MediaPlayerPrivateJava.h</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef MediaPlayerPrivateJava_h
 27 #define MediaPlayerPrivateJava_h
 28 
 29 #include &quot;MediaPlayerPrivate.h&quot;
 30 #include &lt;jni.h&gt;
 31 #include &quot;RQRef.h&quot;
 32 #include &quot;TimeRanges.h&quot;
 33 
 34 namespace WebCore {
 35     class MediaPlayerPrivate : public MediaPlayerPrivateInterface {
 36     public:
 37         //typedef MediaPlayerPrivateInterface* (*CreateMediaEnginePlayer)(MediaPlayer*);
 38         //typedef void (*MediaEngineSupportedTypes)(HashSet&lt;String&gt;&amp; types);
 39         //typedef MediaPlayer::SupportsType (*MediaEngineSupportsType)(const String&amp; type, const String&amp; codecs);
 40         //typedef void (*MediaEngineRegistrar)(CreateMediaEnginePlayer, MediaEngineSupportedTypes, MediaEngineSupportsType);
 41         MediaPlayerPrivate(MediaPlayer *player);
 42 
 43         static void MediaEngineSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; types);
 44 
 45         static MediaPlayer::SupportsType MediaEngineSupportsType(const MediaEngineSupportParameters&amp;);
 46 
 47         static void registerMediaEngine(MediaEngineRegistrar registrar);
 48     private:
 49         // the method caches the set
 50         static HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp; GetSupportedTypes();
 51 
 52     public:
 53         virtual ~MediaPlayerPrivate();
 54 
 55         virtual void load(const String&amp; url);
 56         virtual void cancelLoad();
 57 
 58         virtual void prepareToPlay();
 59         //virtual PlatformMedia platformMedia() const { return NoPlatformMedia; }
 60 #if USE(ACCELERATED_COMPOSITING)
 61         //virtual PlatformLayer* platformLayer() const { return 0; }
 62 #endif
 63 
 64         virtual void play();
 65         virtual void pause();
 66 
 67         //virtual bool supportsFullscreen() const { return false; }
 68         //virtual bool supportsSave() const { return false; }
 69 
 70         virtual FloatSize naturalSize() const;
 71 
 72         virtual bool hasVideo() const;
 73         virtual bool hasAudio() const;
 74 
 75         virtual void setVisible(bool);
 76 
 77         virtual float duration() const;
 78 
 79         virtual float currentTime() const;
 80         virtual void seek(float time);
 81         virtual bool seeking() const;
 82 
 83         virtual MediaTime startTime() const;
 84 
 85         virtual void setRate(float);
 86         virtual void setPreservesPitch(bool);
 87 
 88         virtual bool paused() const;
 89 
 90         virtual void setVolume(float);
 91 
 92         virtual bool supportsMuting() const;
 93         virtual void setMuted(bool);
 94 
 95         //virtual bool hasClosedCaptions() const { return false; }
 96         //virtual void setClosedCaptionsVisible(bool) { }
 97 
 98         virtual MediaPlayer::NetworkState networkState() const;
 99         virtual MediaPlayer::ReadyState readyState() const;
100 
101         virtual float maxTimeSeekable() const;
102         virtual bool didLoadingProgress() const;
103         virtual std::unique_ptr&lt;PlatformTimeRanges&gt; buffered() const;
104 
105         virtual unsigned bytesLoaded() const;
106 
107         virtual void setSize(const IntSize&amp;);
108 
109         virtual void paint(GraphicsContext&amp;, const FloatRect&amp;);
110 
111         //virtual void paintCurrentFrameInContext(GraphicsContext* c, const IntRect&amp; r) { paint(c, r); }
112 
113         virtual void setPreload(MediaPlayer::Preload);
114 
115         //virtual bool hasAvailableVideoFrame() const { return readyState() &gt;= MediaPlayer::HaveCurrentData; }
116 
117         //virtual bool canLoadPoster() const { return false; }
118         //virtual void setPoster(const String&amp;) { }
119 
120 //#if ENABLE(PLUGIN_PROXY_FOR_VIDEO)
121 //        virtual void deliverNotification(MediaPlayerProxyNotificationType) = 0;
122 //        virtual void setMediaPlayerProxy(WebMediaPlayerProxy*) = 0;
123 //#endif
124 
125 #if USE(ACCELERATED_COMPOSITING)
126         // whether accelerated rendering is supported by the media engine for the current media.
127         //virtual bool supportsAcceleratedRendering() const { return false; }
128         // called when the rendering system flips the into or out of accelerated rendering mode.
129         //virtual void acceleratedRenderingStateChanged() { }
130 #endif
131 
132         virtual bool hasSingleSecurityOrigin() const { return true; }
133 
134         //virtual MediaPlayer::MovieLoadType movieLoadType() const { return MediaPlayer::Unknown; }
135 
136         //virtual double maximumDurationToCacheMediaTime() const { return 0.5; }
137     // implementation
138     public:
139         static inline MediaPlayerPrivate* getPlayer(jlong ptr);
140         void notifyNetworkStateChanged(int networkState);
141         void notifyReadyStateChanged(int readyState);
142         void notifyPaused(bool paused);
143         void notifySeeking(bool seeking);
144         void notifyFinished();
145         void notifyReady(bool hasVideo, bool hasAudio);
146         void notifyDurationChanged(float duration);
147         void notifySizeChanged(int width, int height);
148         void notifyNewFrame();
149         void notifyBufferChanged(std::unique_ptr&lt;PlatformTimeRanges&gt; timeRanges, int bytesLoaded);
150 
151     private:
152         MediaPlayer* m_player;
153 
154         volatile MediaPlayer::NetworkState m_networkState;
155         volatile MediaPlayer::ReadyState m_readyState;
156 
157         bool m_isVisible;
158         bool m_hasVideo;
159         bool m_hasAudio;
160         FloatSize m_naturalSize;
161         bool m_paused;
162         bool m_seeking;
163         float m_seekTime;   // valid only when m_seeking is true
164         float m_duration;
165         std::unique_ptr&lt;PlatformTimeRanges&gt; m_buffered;
166         unsigned m_bytesLoaded;
167         mutable bool m_didLoadingProgress;  // mutable because didLoadingProgress() is declared const
168 
169         RefPtr&lt;RQRef&gt; m_jPlayer;
170 
171         void setNetworkState(MediaPlayer::NetworkState networkState);
172         void setReadyState(MediaPlayer::ReadyState readyState);
173     };
174 }
175 
176 #endif // MediaPlayerPrivateJava_h
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/image-decoders/jpeg/JPEGImageDecoder.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2006 Apple Inc.
  3  *
  4  * Portions are Copyright (C) 2001-6 mozilla.org
  5  *
  6  * Other contributors:
  7  *   Stuart Parmenter &lt;stuart@mozilla.com&gt;
  8  *
  9  * Copyright (C) 2007-2009 Torch Mobile, Inc.
 10  *
 11  * This library is free software; you can redistribute it and/or
 12  * modify it under the terms of the GNU Lesser General Public
 13  * License as published by the Free Software Foundation; either
 14  * version 2.1 of the License, or (at your option) any later version.
 15  *
 16  * This library is distributed in the hope that it will be useful,
 17  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 18  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 19  * Lesser General Public License for more details.
 20  *
 21  * You should have received a copy of the GNU Lesser General Public
 22  * License along with this library; if not, write to the Free Software
 23  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 24  *
 25  * Alternatively, the contents of this file may be used under the terms
 26  * of either the Mozilla Public License Version 1.1, found at
 27  * http://www.mozilla.org/MPL/ (the &quot;MPL&quot;) or the GNU General Public
 28  * License Version 2.0, found at http://www.fsf.org/copyleft/gpl.html
 29  * (the &quot;GPL&quot;), in which case the provisions of the MPL or the GPL are
 30  * applicable instead of those above.  If you wish to allow use of your
 31  * version of this file only under the terms of one of those two
 32  * licenses (the MPL or the GPL) and not to allow others to use your
 33  * version of this file under the LGPL, indicate your decision by
 34  * deletingthe provisions above and replace them with the notice and
 35  * other provisions required by the MPL or the GPL, as the case may be.
 36  * If you do not delete the provisions above, a recipient may use your
 37  * version of this file under any of the LGPL, the MPL or the GPL.
 38  */
 39 
 40 #include &quot;config.h&quot;
 41 #include &quot;JPEGImageDecoder.h&quot;
 42 
 43 extern &quot;C&quot; {
 44 #if USE(ICCJPEG)
 45 #include &lt;iccjpeg.h&gt;
 46 #endif
 47 #include &lt;setjmp.h&gt;
 48 }
 49 
 50 #if CPU(BIG_ENDIAN) || CPU(MIDDLE_ENDIAN)
 51 #define ASSUME_LITTLE_ENDIAN 0
 52 #else
 53 #define ASSUME_LITTLE_ENDIAN 1
 54 #endif
 55 
 56 #if defined(JCS_ALPHA_EXTENSIONS) &amp;&amp; ASSUME_LITTLE_ENDIAN
 57 #define TURBO_JPEG_RGB_SWIZZLE
 58 inline J_COLOR_SPACE rgbOutputColorSpace() { return JCS_EXT_BGRA; }
 59 inline bool turboSwizzled(J_COLOR_SPACE colorSpace) { return colorSpace == JCS_EXT_RGBA || colorSpace == JCS_EXT_BGRA; }
 60 #else
 61 inline J_COLOR_SPACE rgbOutputColorSpace() { return JCS_RGB; }
 62 #endif
 63 
 64 #if USE(LOW_QUALITY_IMAGE_NO_JPEG_DITHERING)
 65 inline J_DCT_METHOD dctMethod() { return JDCT_IFAST; }
 66 inline J_DITHER_MODE ditherMode() { return JDITHER_NONE; }
 67 #else
 68 inline J_DCT_METHOD dctMethod() { return JDCT_ISLOW; }
 69 inline J_DITHER_MODE ditherMode() { return JDITHER_FS; }
 70 #endif
 71 
 72 #if USE(LOW_QUALITY_IMAGE_NO_JPEG_FANCY_UPSAMPLING)
 73 inline bool doFancyUpsampling() { return false; }
 74 #else
 75 inline bool doFancyUpsampling() { return true; }
 76 #endif
 77 
 78 const int exifMarker = JPEG_APP0 + 1;
 79 
 80 namespace WebCore {
 81 
 82 struct decoder_error_mgr {
 83     struct jpeg_error_mgr pub; // &quot;public&quot; fields for IJG library
 84     jmp_buf setjmp_buffer;     // For handling catastropic errors
 85 };
 86 
 87 enum jstate {
 88     JPEG_HEADER,                 // Reading JFIF headers
 89     JPEG_START_DECOMPRESS,
 90     JPEG_DECOMPRESS_PROGRESSIVE, // Output progressive pixels
 91     JPEG_DECOMPRESS_SEQUENTIAL,  // Output sequential pixels
 92     JPEG_DONE,
 93     JPEG_ERROR
 94 };
 95 
 96 void init_source(j_decompress_ptr jd);
 97 boolean fill_input_buffer(j_decompress_ptr jd);
 98 void skip_input_data(j_decompress_ptr jd, long num_bytes);
 99 void term_source(j_decompress_ptr jd);
100 void error_exit(j_common_ptr cinfo);
101 
102 // Implementation of a JPEG src object that understands our state machine
103 struct decoder_source_mgr {
104     // public fields; must be first in this struct!
105     struct jpeg_source_mgr pub;
106 
107     JPEGImageReader* decoder;
108 };
109 
110 static unsigned readUint16(JOCTET* data, bool isBigEndian)
111 {
112     if (isBigEndian)
113         return (GETJOCTET(data[0]) &lt;&lt; 8) | GETJOCTET(data[1]);
114     return (GETJOCTET(data[1]) &lt;&lt; 8) | GETJOCTET(data[0]);
115 }
116 
117 static unsigned readUint32(JOCTET* data, bool isBigEndian)
118 {
119     if (isBigEndian)
120         return (GETJOCTET(data[0]) &lt;&lt; 24) | (GETJOCTET(data[1]) &lt;&lt; 16) | (GETJOCTET(data[2]) &lt;&lt; 8) | GETJOCTET(data[3]);
121     return (GETJOCTET(data[3]) &lt;&lt; 24) | (GETJOCTET(data[2]) &lt;&lt; 16) | (GETJOCTET(data[1]) &lt;&lt; 8) | GETJOCTET(data[0]);
122 }
123 
124 static bool checkExifHeader(jpeg_saved_marker_ptr marker, bool&amp; isBigEndian, unsigned&amp; ifdOffset)
125 {
126     // For exif data, the APP1 block is followed by &#39;E&#39;, &#39;x&#39;, &#39;i&#39;, &#39;f&#39;, &#39;\0&#39;,
127     // then a fill byte, and then a tiff file that contains the metadata.
128     // A tiff file starts with &#39;I&#39;, &#39;I&#39; (intel / little endian byte order) or
129     // &#39;M&#39;, &#39;M&#39; (motorola / big endian byte order), followed by (uint16_t)42,
130     // followed by an uint32_t with the offset to the tag block, relative to the
131     // tiff file start.
132     const unsigned exifHeaderSize = 14;
133     if (!(marker-&gt;marker == exifMarker
134         &amp;&amp; marker-&gt;data_length &gt;= exifHeaderSize
135         &amp;&amp; marker-&gt;data[0] == &#39;E&#39;
136         &amp;&amp; marker-&gt;data[1] == &#39;x&#39;
137         &amp;&amp; marker-&gt;data[2] == &#39;i&#39;
138         &amp;&amp; marker-&gt;data[3] == &#39;f&#39;
139         &amp;&amp; marker-&gt;data[4] == &#39;\0&#39;
140         // data[5] is a fill byte
141         &amp;&amp; ((marker-&gt;data[6] == &#39;I&#39; &amp;&amp; marker-&gt;data[7] == &#39;I&#39;)
142             || (marker-&gt;data[6] == &#39;M&#39; &amp;&amp; marker-&gt;data[7] == &#39;M&#39;))))
143         return false;
144 
145     isBigEndian = marker-&gt;data[6] == &#39;M&#39;;
146     if (readUint16(marker-&gt;data + 8, isBigEndian) != 42)
147         return false;
148 
149     ifdOffset = readUint32(marker-&gt;data + 10, isBigEndian);
150     return true;
151 }
152 
153 static ImageOrientation readImageOrientation(jpeg_decompress_struct* info)
154 {
155     // The JPEG decoder looks at EXIF metadata.
156     // FIXME: Possibly implement XMP and IPTC support.
157     const unsigned orientationTag = 0x112;
158     const unsigned shortType = 3;
159     for (jpeg_saved_marker_ptr marker = info-&gt;marker_list; marker; marker = marker-&gt;next) {
160         bool isBigEndian;
161         unsigned ifdOffset;
162         if (!checkExifHeader(marker, isBigEndian, ifdOffset))
163             continue;
164         const unsigned offsetToTiffData = 6; // Account for &#39;Exif\0&lt;fill byte&gt;&#39; header.
165         if (marker-&gt;data_length &lt; offsetToTiffData || ifdOffset &gt;= marker-&gt;data_length - offsetToTiffData)
166             continue;
167         ifdOffset += offsetToTiffData;
168 
169         // The jpeg exif container format contains a tiff block for metadata.
170         // A tiff image file directory (ifd) consists of a uint16_t describing
171         // the number of ifd entries, followed by that many entries.
172         // When touching this code, it&#39;s useful to look at the tiff spec:
173         // http://partners.adobe.com/public/developer/en/tiff/TIFF6.pdf
174         JOCTET* ifd = marker-&gt;data + ifdOffset;
175         JOCTET* end = marker-&gt;data + marker-&gt;data_length;
176         if (end - ifd &lt; 2)
177             continue;
178         unsigned tagCount = readUint16(ifd, isBigEndian);
179         ifd += 2; // Skip over the uint16 that was just read.
180 
181         // Every ifd entry is 2 bytes of tag, 2 bytes of contents datatype,
182         // 4 bytes of number-of-elements, and 4 bytes of either offset to the
183         // tag data, or if the data is small enough, the inlined data itself.
184         const int ifdEntrySize = 12;
185         for (unsigned i = 0; i &lt; tagCount &amp;&amp; end - ifd &gt;= ifdEntrySize; ++i, ifd += ifdEntrySize) {
186             unsigned tag = readUint16(ifd, isBigEndian);
187             unsigned type = readUint16(ifd + 2, isBigEndian);
188             unsigned count = readUint32(ifd + 4, isBigEndian);
189             if (tag == orientationTag &amp;&amp; type == shortType &amp;&amp; count == 1)
190                 return ImageOrientation::fromEXIFValue(readUint16(ifd + 8, isBigEndian));
191         }
192     }
193 
194     return ImageOrientation::None;
195 }
196 
197 class JPEGImageReader {
198     WTF_MAKE_FAST_ALLOCATED;
199 public:
200     JPEGImageReader(JPEGImageDecoder* decoder)
201         : m_decoder(decoder)
202         , m_bufferLength(0)
203         , m_bytesToSkip(0)
204         , m_state(JPEG_HEADER)
205         , m_samples(0)
206     {
207         memset(&amp;m_info, 0, sizeof(jpeg_decompress_struct));
208 
209         // We set up the normal JPEG error routines, then override error_exit.
210         m_info.err = jpeg_std_error(&amp;m_err.pub);
211         m_err.pub.error_exit = error_exit;
212 
213         // Allocate and initialize JPEG decompression object.
214         jpeg_create_decompress(&amp;m_info);
215 
216         decoder_source_mgr* src = 0;
217         if (!m_info.src) {
218             src = (decoder_source_mgr*)fastCalloc(sizeof(decoder_source_mgr), 1);
219             if (!src) {
220                 m_state = JPEG_ERROR;
221                 return;
222             }
223         }
224 
225         m_info.src = (jpeg_source_mgr*)src;
226 
227         // Set up callback functions.
228         src-&gt;pub.init_source = init_source;
229         src-&gt;pub.fill_input_buffer = fill_input_buffer;
230         src-&gt;pub.skip_input_data = skip_input_data;
231         src-&gt;pub.resync_to_restart = jpeg_resync_to_restart;
232         src-&gt;pub.term_source = term_source;
233         src-&gt;decoder = this;
234 
235 #if USE(ICCJPEG)
236         // Retain ICC color profile markers for color management.
237         setup_read_icc_profile(&amp;m_info);
238 #endif
239 
240         // Keep APP1 blocks, for obtaining exif data.
241         jpeg_save_markers(&amp;m_info, exifMarker, 0xFFFF);
242     }
243 
244     ~JPEGImageReader()
245     {
246         close();
247     }
248 
249     void close()
250     {
251         decoder_source_mgr* src = (decoder_source_mgr*)m_info.src;
252         if (src)
253             fastFree(src);
254         m_info.src = 0;
255 
256         jpeg_destroy_decompress(&amp;m_info);
257     }
258 
259     void skipBytes(long numBytes)
260     {
261         decoder_source_mgr* src = (decoder_source_mgr*)m_info.src;
262         long bytesToSkip = std::min(numBytes, (long)src-&gt;pub.bytes_in_buffer);
263         src-&gt;pub.bytes_in_buffer -= (size_t)bytesToSkip;
264         src-&gt;pub.next_input_byte += bytesToSkip;
265 
266         m_bytesToSkip = std::max(numBytes - bytesToSkip, static_cast&lt;long&gt;(0));
267     }
268 
269     bool decode(const SharedBuffer::DataSegment&amp; data, bool onlySize)
270     {
271         m_decodingSizeOnly = onlySize;
272 
273         unsigned newByteCount = data.size() - m_bufferLength;
274         unsigned readOffset = m_bufferLength - m_info.src-&gt;bytes_in_buffer;
275 
276         m_info.src-&gt;bytes_in_buffer += newByteCount;
277         m_info.src-&gt;next_input_byte = (JOCTET*)(data.data()) + readOffset;
278 
279         // If we still have bytes to skip, try to skip those now.
280         if (m_bytesToSkip)
281             skipBytes(m_bytesToSkip);
282 
283         m_bufferLength = data.size();
284 
285         // We need to do the setjmp here. Otherwise bad things will happen
286         if (setjmp(m_err.setjmp_buffer))
287             return m_decoder-&gt;setFailed();
288 
289         switch (m_state) {
290         case JPEG_HEADER:
291             // Read file parameters with jpeg_read_header().
292             if (jpeg_read_header(&amp;m_info, TRUE) == JPEG_SUSPENDED)
293                 return false; // I/O suspension.
294 
295             switch (m_info.jpeg_color_space) {
296             case JCS_GRAYSCALE:
297             case JCS_RGB:
298             case JCS_YCbCr:
299                 // libjpeg can convert GRAYSCALE and YCbCr image pixels to RGB.
300                 m_info.out_color_space = rgbOutputColorSpace();
301                 break;
302             case JCS_CMYK:
303             case JCS_YCCK:
304                 // libjpeg can convert YCCK to CMYK, but neither to RGB, so we
305                 // manually convert CMKY to RGB.
306                 m_info.out_color_space = JCS_CMYK;
307                 break;
308             default:
309                 return m_decoder-&gt;setFailed();
310             }
311 
312             m_state = JPEG_START_DECOMPRESS;
313 
314             // We can fill in the size now that the header is available.
315             if (!m_decoder-&gt;setSize(IntSize(m_info.image_width, m_info.image_height)))
316                 return false;
317 
318             m_decoder-&gt;setOrientation(readImageOrientation(info()));
319 
320             // Don&#39;t allocate a giant and superfluous memory buffer when the
321             // image is a sequential JPEG.
322             m_info.buffered_image = jpeg_has_multiple_scans(&amp;m_info);
323 
324             // Used to set up image size so arrays can be allocated.
325             jpeg_calc_output_dimensions(&amp;m_info);
326 
327             // Make a one-row-high sample array that will go away when done with
328             // image. Always make it big enough to hold an RGB row. Since this
329             // uses the IJG memory manager, it must be allocated before the call
330             // to jpeg_start_compress().
331             // FIXME: note that some output color spaces do not need the samples
332             // buffer. Remove this allocation for those color spaces.
333             m_samples = (*m_info.mem-&gt;alloc_sarray)((j_common_ptr) &amp;m_info, JPOOL_IMAGE, m_info.output_width * 4, 1);
334 
335             if (m_decodingSizeOnly) {
336                 // We can stop here. Reduce our buffer length and available data.
337                 m_bufferLength -= m_info.src-&gt;bytes_in_buffer;
338                 m_info.src-&gt;bytes_in_buffer = 0;
339                 return true;
340             }
341         // FALL THROUGH
342 
343         case JPEG_START_DECOMPRESS:
344             // Set parameters for decompression.
345             // FIXME -- Should reset dct_method and dither mode for final pass
346             // of progressive JPEG.
347             m_info.dct_method = dctMethod();
348             m_info.dither_mode = ditherMode();
349             m_info.do_fancy_upsampling = doFancyUpsampling() ? TRUE : FALSE;
350             m_info.enable_2pass_quant = FALSE;
351             m_info.do_block_smoothing = TRUE;
352 
353             // Start decompressor.
354             if (!jpeg_start_decompress(&amp;m_info))
355                 return false; // I/O suspension.
356 
357             // If this is a progressive JPEG ...
358             m_state = (m_info.buffered_image) ? JPEG_DECOMPRESS_PROGRESSIVE : JPEG_DECOMPRESS_SEQUENTIAL;
359         // FALL THROUGH
360 
361         case JPEG_DECOMPRESS_SEQUENTIAL:
362             if (m_state == JPEG_DECOMPRESS_SEQUENTIAL) {
363 
364                 if (!m_decoder-&gt;outputScanlines())
365                     return false; // I/O suspension.
366 
367                 // If we&#39;ve completed image output...
368                 ASSERT(m_info.output_scanline == m_info.output_height);
369                 m_state = JPEG_DONE;
370             }
371         // FALL THROUGH
372 
373         case JPEG_DECOMPRESS_PROGRESSIVE:
374             if (m_state == JPEG_DECOMPRESS_PROGRESSIVE) {
375                 int status;
376                 do {
377                     status = jpeg_consume_input(&amp;m_info);
378                 } while ((status != JPEG_SUSPENDED) &amp;&amp; (status != JPEG_REACHED_EOI));
379 
380                 for (;;) {
381                     if (!m_info.output_scanline) {
382                         int scan = m_info.input_scan_number;
383 
384                         // If we haven&#39;t displayed anything yet
385                         // (output_scan_number == 0) and we have enough data for
386                         // a complete scan, force output of the last full scan.
387                         if (!m_info.output_scan_number &amp;&amp; (scan &gt; 1) &amp;&amp; (status != JPEG_REACHED_EOI))
388                             --scan;
389 
390                         if (!jpeg_start_output(&amp;m_info, scan))
391                             return false; // I/O suspension.
392                     }
393 
394                     if (m_info.output_scanline == 0xffffff)
395                         m_info.output_scanline = 0;
396 
397                     // If outputScanlines() fails, it deletes |this|. Therefore,
398                     // copy the decoder pointer and use it to check for failure
399                     // to avoid member access in the failure case.
400                     JPEGImageDecoder* decoder = m_decoder;
401                     if (!decoder-&gt;outputScanlines()) {
402                         if (decoder-&gt;failed()) // Careful; |this| is deleted.
403                             return false;
404                         if (!m_info.output_scanline)
405                             // Didn&#39;t manage to read any lines - flag so we
406                             // don&#39;t call jpeg_start_output() multiple times for
407                             // the same scan.
408                             m_info.output_scanline = 0xffffff;
409                         return false; // I/O suspension.
410                     }
411 
412                     if (m_info.output_scanline == m_info.output_height) {
413                         if (!jpeg_finish_output(&amp;m_info))
414                             return false; // I/O suspension.
415 
416                         if (jpeg_input_complete(&amp;m_info) &amp;&amp; (m_info.input_scan_number == m_info.output_scan_number))
417                             break;
418 
419                         m_info.output_scanline = 0;
420                     }
421                 }
422 
423                 m_state = JPEG_DONE;
424             }
425         // FALL THROUGH
426 
427         case JPEG_DONE:
428             // Finish decompression.
429             return jpeg_finish_decompress(&amp;m_info);
430 
431         case JPEG_ERROR:
432             // We can get here if the constructor failed.
433             return m_decoder-&gt;setFailed();
434         }
435 
436         return true;
437     }
438 
439     jpeg_decompress_struct* info() { return &amp;m_info; }
440     JSAMPARRAY samples() const { return m_samples; }
441     JPEGImageDecoder* decoder() { return m_decoder; }
442 
443 private:
444     JPEGImageDecoder* m_decoder;
445     unsigned m_bufferLength;
446     int m_bytesToSkip;
447     bool m_decodingSizeOnly;
448 
449     jpeg_decompress_struct m_info;
450     decoder_error_mgr m_err;
451     jstate m_state;
452 
453     JSAMPARRAY m_samples;
454 };
455 
456 // Override the standard error method in the IJG JPEG decoder code.
457 void error_exit(j_common_ptr cinfo)
458 {
459     // Return control to the setjmp point.
460     decoder_error_mgr *err = reinterpret_cast_ptr&lt;decoder_error_mgr *&gt;(cinfo-&gt;err);
461     longjmp(err-&gt;setjmp_buffer, -1);
462 }
463 
464 void init_source(j_decompress_ptr)
465 {
466 }
467 
468 void skip_input_data(j_decompress_ptr jd, long num_bytes)
469 {
470     decoder_source_mgr *src = (decoder_source_mgr *)jd-&gt;src;
471     src-&gt;decoder-&gt;skipBytes(num_bytes);
472 }
473 
474 boolean fill_input_buffer(j_decompress_ptr)
475 {
476     // Our decode step always sets things up properly, so if this method is ever
477     // called, then we have hit the end of the buffer.  A return value of false
478     // indicates that we have no data to supply yet.
479     return FALSE;
480 }
481 
482 void term_source(j_decompress_ptr jd)
483 {
484     decoder_source_mgr *src = (decoder_source_mgr *)jd-&gt;src;
485     src-&gt;decoder-&gt;decoder()-&gt;jpegComplete();
486 }
487 
488 JPEGImageDecoder::JPEGImageDecoder(AlphaOption alphaOption, GammaAndColorProfileOption gammaAndColorProfileOption)
489     : ScalableImageDecoder(alphaOption, gammaAndColorProfileOption)
490 {
491 }
492 
493 JPEGImageDecoder::~JPEGImageDecoder() = default;
494 
495 ScalableImageDecoderFrame* JPEGImageDecoder::frameBufferAtIndex(size_t index)
496 {
497     if (index)
498         return 0;
499 
500     if (m_frameBufferCache.isEmpty())
501         m_frameBufferCache.grow(1);
502 
503     auto&amp; frame = m_frameBufferCache[0];
504     if (!frame.isComplete())
505         decode(false, isAllDataReceived());
506     return &amp;frame;
507 }
508 
509 bool JPEGImageDecoder::setFailed()
510 {
511     m_reader = nullptr;
512     return ScalableImageDecoder::setFailed();
513 }
514 
515 template &lt;J_COLOR_SPACE colorSpace&gt;
516 void setPixel(ScalableImageDecoderFrame&amp; buffer, uint32_t* currentAddress, JSAMPARRAY samples, int column)
517 {
518     JSAMPLE* jsample = *samples + column * (colorSpace == JCS_RGB ? 3 : 4);
519 
520     switch (colorSpace) {
521     case JCS_RGB:
522         buffer.backingStore()-&gt;setPixel(currentAddress, jsample[0], jsample[1], jsample[2], 0xFF);
523         break;
524     case JCS_CMYK:
525         // Source is &#39;Inverted CMYK&#39;, output is RGB.
526         // See: http://www.easyrgb.com/math.php?MATH=M12#text12
527         // Or: http://www.ilkeratalay.com/colorspacesfaq.php#rgb
528         // From CMYK to CMY:
529         // X =   X    * (1 -   K   ) +   K  [for X = C, M, or Y]
530         // Thus, from Inverted CMYK to CMY is:
531         // X = (1-iX) * (1 - (1-iK)) + (1-iK) =&gt; 1 - iX*iK
532         // From CMY (0..1) to RGB (0..1):
533         // R = 1 - C =&gt; 1 - (1 - iC*iK) =&gt; iC*iK  [G and B similar]
534         unsigned k = jsample[3];
535         buffer.backingStore()-&gt;setPixel(currentAddress, jsample[0] * k / 255, jsample[1] * k / 255, jsample[2] * k / 255, 0xFF);
536         break;
537     }
538 }
539 
540 template &lt;J_COLOR_SPACE colorSpace&gt;
541 bool JPEGImageDecoder::outputScanlines(ScalableImageDecoderFrame&amp; buffer)
542 {
543     JSAMPARRAY samples = m_reader-&gt;samples();
544     jpeg_decompress_struct* info = m_reader-&gt;info();
545     int width = info-&gt;output_width;
546 
547     while (info-&gt;output_scanline &lt; info-&gt;output_height) {
548         // jpeg_read_scanlines will increase the scanline counter, so we
549         // save the scanline before calling it.
550         int sourceY = info-&gt;output_scanline;
551         /* Request one scanline.  Returns 0 or 1 scanlines. */
552         if (jpeg_read_scanlines(info, samples, 1) != 1)
553             return false;
554 
555         auto* currentAddress = buffer.backingStore()-&gt;pixelAt(0, sourceY);
556         for (int x = 0; x &lt; width; ++x) {
557             setPixel&lt;colorSpace&gt;(buffer, currentAddress, samples, x);
558             ++currentAddress;
559         }
560     }
561     return true;
562 }
563 
564 bool JPEGImageDecoder::outputScanlines()
565 {
566     if (m_frameBufferCache.isEmpty())
567         return false;
568 
569     // Initialize the framebuffer if needed.
570     auto&amp; buffer = m_frameBufferCache[0];
571     if (buffer.isInvalid()) {
572         if (!buffer.initialize(size(), m_premultiplyAlpha))
573             return setFailed();
574         buffer.setDecodingStatus(DecodingStatus::Partial);
575         // The buffer is transparent outside the decoded area while the image is
576         // loading. The completed image will be marked fully opaque in jpegComplete().
577         buffer.setHasAlpha(true);
578     }
579 
580     jpeg_decompress_struct* info = m_reader-&gt;info();
581 
582 #if defined(TURBO_JPEG_RGB_SWIZZLE)
583     if (turboSwizzled(info-&gt;out_color_space)) {
584         while (info-&gt;output_scanline &lt; info-&gt;output_height) {
585             unsigned char* row = reinterpret_cast&lt;unsigned char*&gt;(buffer.backingStore()-&gt;pixelAt(0, info-&gt;output_scanline));
586             if (jpeg_read_scanlines(info, &amp;row, 1) != 1)
587                 return false;
588          }
589          return true;
590      }
591 #endif
592 
593     switch (info-&gt;out_color_space) {
594     // The code inside outputScanlines&lt;int&gt; will be executed
595     // for each pixel, so we want to avoid any extra comparisons there.
596     // That is why we use template and template specializations here so
597     // the proper code will be generated at compile time.
598     case JCS_RGB:
599         return outputScanlines&lt;JCS_RGB&gt;(buffer);
600     case JCS_CMYK:
601         return outputScanlines&lt;JCS_CMYK&gt;(buffer);
602     default:
603         ASSERT_NOT_REACHED();
604     }
605 
606     return setFailed();
607 }
608 
609 void JPEGImageDecoder::jpegComplete()
610 {
611     if (m_frameBufferCache.isEmpty())
612         return;
613 
614     // Hand back an appropriately sized buffer, even if the image ended up being
615     // empty.
616     auto&amp; buffer = m_frameBufferCache[0];
617     buffer.setHasAlpha(false);
618     buffer.setDecodingStatus(DecodingStatus::Complete);
619 }
620 
621 void JPEGImageDecoder::decode(bool onlySize, bool allDataReceived)
622 {
623     if (failed())
624         return;
625 
626     if (!m_reader)
627         m_reader = makeUnique&lt;JPEGImageReader&gt;(this);
628 
629     // If we couldn&#39;t decode the image but we&#39;ve received all the data, decoding
630     // has failed.
631     if (!m_reader-&gt;decode(*m_data, onlySize) &amp;&amp; allDataReceived)
632         setFailed();
633     // If we&#39;re done decoding the image, we don&#39;t need the JPEGImageReader
634     // anymore.  (If we failed, |m_reader| has already been cleared.)
635     else if (!m_frameBufferCache.isEmpty() &amp;&amp; (m_frameBufferCache[0].isComplete()))
636         m_reader = nullptr;
637 }
638 
639 }
    </pre>
  </body>
</html>
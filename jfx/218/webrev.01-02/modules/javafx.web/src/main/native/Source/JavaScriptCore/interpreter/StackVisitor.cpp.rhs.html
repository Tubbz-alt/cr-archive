<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/StackVisitor.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;StackVisitor.h&quot;
 28 
<a name="1" id="anc1"></a>
 29 #include &quot;ClonedArguments.h&quot;
 30 #include &quot;DebuggerPrimitives.h&quot;
 31 #include &quot;InlineCallFrame.h&quot;
 32 #include &quot;Interpreter.h&quot;
 33 #include &quot;JSCInlines.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 34 #include &quot;RegisterAtOffsetList.h&quot;</span>
 35 #include &quot;WasmCallee.h&quot;
 36 #include &quot;WasmIndexOrName.h&quot;
 37 #include &quot;WebAssemblyFunction.h&quot;
 38 #include &lt;wtf/text/StringBuilder.h&gt;
 39 
 40 namespace JSC {
 41 
<a name="3" id="anc3"></a><span class="line-modified"> 42 StackVisitor::StackVisitor(CallFrame* startFrame, VM&amp; vm)</span>
 43 {
 44     m_frame.m_index = 0;
 45     m_frame.m_isWasmFrame = false;
 46     CallFrame* topFrame;
 47     if (startFrame) {
<a name="4" id="anc4"></a><span class="line-modified"> 48         ASSERT(!vm.topCallFrame || reinterpret_cast&lt;void*&gt;(vm.topCallFrame) != vm.topEntryFrame);</span>

 49 
<a name="5" id="anc5"></a><span class="line-modified"> 50         m_frame.m_entryFrame = vm.topEntryFrame;</span>
<span class="line-modified"> 51         topFrame = vm.topCallFrame;</span>
 52 
 53         if (topFrame &amp;&amp; topFrame-&gt;isStackOverflowFrame()) {
 54             topFrame = topFrame-&gt;callerFrame(m_frame.m_entryFrame);
<a name="6" id="anc6"></a><span class="line-modified"> 55             m_topEntryFrameIsEmpty = (m_frame.m_entryFrame != vm.topEntryFrame);</span>
<span class="line-modified"> 56             if (startFrame == vm.topCallFrame)</span>
 57                 startFrame = topFrame;
 58         }
 59 
 60     } else {
 61         m_frame.m_entryFrame = 0;
 62         topFrame = 0;
 63     }
 64     m_frame.m_callerIsEntryFrame = false;
 65     readFrame(topFrame);
 66 
 67     // Find the frame the caller wants to start unwinding from.
 68     while (m_frame.callFrame() &amp;&amp; m_frame.callFrame() != startFrame)
 69         gotoNextFrame();
 70 }
 71 
 72 void StackVisitor::gotoNextFrame()
 73 {
 74     m_frame.m_index++;
 75 #if ENABLE(DFG_JIT)
 76     if (m_frame.isInlinedFrame()) {
 77         InlineCallFrame* inlineCallFrame = m_frame.inlineCallFrame();
 78         CodeOrigin* callerCodeOrigin = inlineCallFrame-&gt;getCallerSkippingTailCalls();
 79         if (!callerCodeOrigin) {
 80             while (inlineCallFrame) {
 81                 readInlinedFrame(m_frame.callFrame(), &amp;inlineCallFrame-&gt;directCaller);
 82                 inlineCallFrame = m_frame.inlineCallFrame();
 83             }
 84             m_frame.m_entryFrame = m_frame.m_callerEntryFrame;
 85             readFrame(m_frame.callerFrame());
 86         } else
 87             readInlinedFrame(m_frame.callFrame(), callerCodeOrigin);
 88         return;
 89     }
 90 #endif // ENABLE(DFG_JIT)
 91     m_frame.m_entryFrame = m_frame.m_callerEntryFrame;
 92     readFrame(m_frame.callerFrame());
 93 }
 94 
 95 void StackVisitor::unwindToMachineCodeBlockFrame()
 96 {
 97 #if ENABLE(DFG_JIT)
 98     if (m_frame.isInlinedFrame()) {
 99         CodeOrigin codeOrigin = m_frame.inlineCallFrame()-&gt;directCaller;
100         while (codeOrigin.inlineCallFrame())
101             codeOrigin = codeOrigin.inlineCallFrame()-&gt;directCaller;
102         readNonInlinedFrame(m_frame.callFrame(), &amp;codeOrigin);
103     }
104 #endif
105 }
106 
107 void StackVisitor::readFrame(CallFrame* callFrame)
108 {
109     if (!callFrame) {
110         m_frame.setToEnd();
111         return;
112     }
113 
114     if (callFrame-&gt;isAnyWasmCallee()) {
115         readNonInlinedFrame(callFrame);
116         return;
117     }
118 
119 #if !ENABLE(DFG_JIT)
120     readNonInlinedFrame(callFrame);
121 
122 #else // !ENABLE(DFG_JIT)
123     // If the frame doesn&#39;t have a code block, then it&#39;s not a DFG frame.
124     // Hence, we&#39;re not at an inlined frame.
125     CodeBlock* codeBlock = callFrame-&gt;codeBlock();
126     if (!codeBlock) {
127         readNonInlinedFrame(callFrame);
128         return;
129     }
130 
131     // If the code block does not have any code origins, then there&#39;s no
132     // inlining. Hence, we&#39;re not at an inlined frame.
133     if (!codeBlock-&gt;hasCodeOrigins()) {
134         readNonInlinedFrame(callFrame);
135         return;
136     }
137 
138     CallSiteIndex index = callFrame-&gt;callSiteIndex();
139     ASSERT(codeBlock-&gt;canGetCodeOrigin(index));
140     if (!codeBlock-&gt;canGetCodeOrigin(index)) {
141         // See assertion above. In release builds, we try to protect ourselves
142         // from crashing even though stack walking will be goofed up.
143         m_frame.setToEnd();
144         return;
145     }
146 
147     CodeOrigin codeOrigin = codeBlock-&gt;codeOrigin(index);
148     if (!codeOrigin.inlineCallFrame()) {
149         readNonInlinedFrame(callFrame, &amp;codeOrigin);
150         return;
151     }
152 
153     readInlinedFrame(callFrame, &amp;codeOrigin);
154 #endif // !ENABLE(DFG_JIT)
155 }
156 
157 void StackVisitor::readNonInlinedFrame(CallFrame* callFrame, CodeOrigin* codeOrigin)
158 {
159     m_frame.m_callFrame = callFrame;
160     m_frame.m_argumentCountIncludingThis = callFrame-&gt;argumentCountIncludingThis();
161     m_frame.m_callerEntryFrame = m_frame.m_entryFrame;
162     m_frame.m_callerFrame = callFrame-&gt;callerFrame(m_frame.m_callerEntryFrame);
163     m_frame.m_callerIsEntryFrame = m_frame.m_callerEntryFrame != m_frame.m_entryFrame;
164     m_frame.m_isWasmFrame = false;
165 
166     CalleeBits callee = callFrame-&gt;callee();
167     m_frame.m_callee = callee;
168 
169     if (callFrame-&gt;isAnyWasmCallee()) {
170         m_frame.m_isWasmFrame = true;
171         m_frame.m_codeBlock = nullptr;
<a name="7" id="anc7"></a><span class="line-modified">172         m_frame.m_bytecodeIndex = BytecodeIndex();</span>
173 #if ENABLE(WEBASSEMBLY)
174         CalleeBits bits = callFrame-&gt;callee();
175         if (bits.isWasm())
176             m_frame.m_wasmFunctionIndexOrName = bits.asWasmCallee()-&gt;indexOrName();
177 #endif
178     } else {
179         m_frame.m_codeBlock = callFrame-&gt;codeBlock();
<a name="8" id="anc8"></a><span class="line-modified">180         m_frame.m_bytecodeIndex = !m_frame.codeBlock() ? BytecodeIndex(0)</span>
181             : codeOrigin ? codeOrigin-&gt;bytecodeIndex()
<a name="9" id="anc9"></a><span class="line-modified">182             : callFrame-&gt;bytecodeIndex();</span>
183 
184     }
185 
186 #if ENABLE(DFG_JIT)
187     m_frame.m_inlineCallFrame = 0;
188 #endif
189 }
190 
191 #if ENABLE(DFG_JIT)
192 static int inlinedFrameOffset(CodeOrigin* codeOrigin)
193 {
194     InlineCallFrame* inlineCallFrame = codeOrigin-&gt;inlineCallFrame();
195     int frameOffset = inlineCallFrame ? inlineCallFrame-&gt;stackOffset : 0;
196     return frameOffset;
197 }
198 
199 void StackVisitor::readInlinedFrame(CallFrame* callFrame, CodeOrigin* codeOrigin)
200 {
201     ASSERT(codeOrigin);
202     m_frame.m_isWasmFrame = false;
203 
204     int frameOffset = inlinedFrameOffset(codeOrigin);
205     bool isInlined = !!frameOffset;
206     if (isInlined) {
207         InlineCallFrame* inlineCallFrame = codeOrigin-&gt;inlineCallFrame();
208 
209         m_frame.m_callFrame = callFrame;
210         m_frame.m_inlineCallFrame = inlineCallFrame;
211         if (inlineCallFrame-&gt;argumentCountRegister.isValid())
<a name="10" id="anc10"></a><span class="line-modified">212             m_frame.m_argumentCountIncludingThis = callFrame-&gt;r(inlineCallFrame-&gt;argumentCountRegister).unboxedInt32();</span>
213         else
214             m_frame.m_argumentCountIncludingThis = inlineCallFrame-&gt;argumentCountIncludingThis;
215         m_frame.m_codeBlock = inlineCallFrame-&gt;baselineCodeBlock.get();
<a name="11" id="anc11"></a><span class="line-modified">216         m_frame.m_bytecodeIndex = codeOrigin-&gt;bytecodeIndex();</span>
217 
218         JSFunction* callee = inlineCallFrame-&gt;calleeForCallFrame(callFrame);
219         m_frame.m_callee = callee;
220         ASSERT(!!m_frame.callee().rawPtr());
221 
222         // The callerFrame just needs to be non-null to indicate that we
223         // haven&#39;t reached the last frame yet. Setting it to the root
224         // frame (i.e. the callFrame that this inlined frame is called from)
225         // would work just fine.
226         m_frame.m_callerFrame = callFrame;
227         return;
228     }
229 
230     readNonInlinedFrame(callFrame, codeOrigin);
231 }
232 #endif // ENABLE(DFG_JIT)
233 
234 StackVisitor::Frame::CodeType StackVisitor::Frame::codeType() const
235 {
236     if (isWasmFrame())
237         return CodeType::Wasm;
238 
239     if (!codeBlock())
240         return CodeType::Native;
241 
242     switch (codeBlock()-&gt;codeType()) {
243     case EvalCode:
244         return CodeType::Eval;
245     case ModuleCode:
246         return CodeType::Module;
247     case FunctionCode:
248         return CodeType::Function;
249     case GlobalCode:
250         return CodeType::Global;
251     }
252     RELEASE_ASSERT_NOT_REACHED();
253     return CodeType::Global;
254 }
255 
256 #if ENABLE(ASSEMBLER)
257 Optional&lt;RegisterAtOffsetList&gt; StackVisitor::Frame::calleeSaveRegistersForUnwinding()
258 {
259     if (!NUMBER_OF_CALLEE_SAVES_REGISTERS)
260         return WTF::nullopt;
261 
262     if (isInlinedFrame())
263         return WTF::nullopt;
264 
265 #if ENABLE(WEBASSEMBLY)
266     if (isWasmFrame()) {
267         if (callee().isCell()) {
<a name="12" id="anc12"></a><span class="line-modified">268             RELEASE_ASSERT(isWebAssemblyModule(callee().asCell()));</span>
269             return WTF::nullopt;
270         }
271         Wasm::Callee* wasmCallee = callee().asWasmCallee();
272         return *wasmCallee-&gt;calleeSaveRegisters();
273     }
274 
275     if (callee().isCell()) {
276         if (auto* jsToWasmICCallee = jsDynamicCast&lt;JSToWasmICCallee*&gt;(callee().asCell()-&gt;vm(), callee().asCell()))
277             return jsToWasmICCallee-&gt;function()-&gt;usedCalleeSaveRegisters();
278     }
279 #endif // ENABLE(WEBASSEMBLY)
280 
281     if (CodeBlock* codeBlock = this-&gt;codeBlock())
282         return *codeBlock-&gt;calleeSaveRegisters();
283 
284     return WTF::nullopt;
285 }
286 #endif // ENABLE(ASSEMBLER)
287 
288 String StackVisitor::Frame::functionName() const
289 {
290     String traceLine;
291 
292     switch (codeType()) {
293     case CodeType::Wasm:
294         traceLine = makeString(m_wasmFunctionIndexOrName);
295         break;
296     case CodeType::Eval:
297         traceLine = &quot;eval code&quot;_s;
298         break;
299     case CodeType::Module:
300         traceLine = &quot;module code&quot;_s;
301         break;
302     case CodeType::Native: {
303         JSCell* callee = this-&gt;callee().asCell();
304         if (callee)
<a name="13" id="anc13"></a><span class="line-modified">305             traceLine = getCalculatedDisplayName(callFrame()-&gt;deprecatedVM(), jsCast&lt;JSObject*&gt;(callee)).impl();</span>
306         break;
307     }
308     case CodeType::Function:
<a name="14" id="anc14"></a><span class="line-modified">309         traceLine = getCalculatedDisplayName(callFrame()-&gt;deprecatedVM(), jsCast&lt;JSObject*&gt;(this-&gt;callee().asCell())).impl();</span>
310         break;
311     case CodeType::Global:
312         traceLine = &quot;global code&quot;_s;
313         break;
314     }
315     return traceLine.isNull() ? emptyString() : traceLine;
316 }
317 
318 String StackVisitor::Frame::sourceURL() const
319 {
320     String traceLine;
321 
322     switch (codeType()) {
323     case CodeType::Eval:
324     case CodeType::Module:
325     case CodeType::Function:
326     case CodeType::Global: {
327         String sourceURL = codeBlock()-&gt;ownerExecutable()-&gt;sourceURL();
328         if (!sourceURL.isEmpty())
329             traceLine = sourceURL.impl();
330         break;
331     }
332     case CodeType::Native:
333         traceLine = &quot;[native code]&quot;_s;
334         break;
335     case CodeType::Wasm:
336         traceLine = &quot;[wasm code]&quot;_s;
337         break;
338     }
339     return traceLine.isNull() ? emptyString() : traceLine;
340 }
341 
342 String StackVisitor::Frame::toString() const
343 {
344     StringBuilder traceBuild;
345     String functionName = this-&gt;functionName();
346     String sourceURL = this-&gt;sourceURL();
347     traceBuild.append(functionName);
348     if (!sourceURL.isEmpty()) {
349         if (!functionName.isEmpty())
350             traceBuild.append(&#39;@&#39;);
351         traceBuild.append(sourceURL);
352         if (hasLineAndColumnInfo()) {
353             unsigned line = 0;
354             unsigned column = 0;
355             computeLineAndColumn(line, column);
356             traceBuild.append(&#39;:&#39;);
357             traceBuild.appendNumber(line);
358             traceBuild.append(&#39;:&#39;);
359             traceBuild.appendNumber(column);
360         }
361     }
362     return traceBuild.toString().impl();
363 }
364 
365 intptr_t StackVisitor::Frame::sourceID()
366 {
367     if (CodeBlock* codeBlock = this-&gt;codeBlock())
368         return codeBlock-&gt;ownerExecutable()-&gt;sourceID();
369     return noSourceID;
370 }
371 
<a name="15" id="anc15"></a><span class="line-modified">372 ClonedArguments* StackVisitor::Frame::createArguments(VM&amp; vm)</span>
373 {
374     ASSERT(m_callFrame);
375     CallFrame* physicalFrame = m_callFrame;
<a name="16" id="anc16"></a><span class="line-added">376     // FIXME: Revisit JSGlobalObject.</span>
<span class="line-added">377     // https://bugs.webkit.org/show_bug.cgi?id=203204</span>
<span class="line-added">378     JSGlobalObject* globalObject = physicalFrame-&gt;lexicalGlobalObject(vm);</span>
379     ClonedArguments* arguments;
380     ArgumentsMode mode;
381     if (Options::useFunctionDotArguments())
382         mode = ArgumentsMode::Cloned;
383     else
384         mode = ArgumentsMode::FakeValues;
385 #if ENABLE(DFG_JIT)
386     if (isInlinedFrame()) {
387         ASSERT(m_inlineCallFrame);
<a name="17" id="anc17"></a><span class="line-modified">388         arguments = ClonedArguments::createWithInlineFrame(globalObject, physicalFrame, m_inlineCallFrame, mode);</span>
389     } else
390 #endif
<a name="18" id="anc18"></a><span class="line-modified">391         arguments = ClonedArguments::createWithMachineFrame(globalObject, physicalFrame, mode);</span>
392     return arguments;
393 }
394 
395 bool StackVisitor::Frame::hasLineAndColumnInfo() const
396 {
397     return !!codeBlock();
398 }
399 
400 void StackVisitor::Frame::computeLineAndColumn(unsigned&amp; line, unsigned&amp; column) const
401 {
402     CodeBlock* codeBlock = this-&gt;codeBlock();
403     if (!codeBlock) {
404         line = 0;
405         column = 0;
406         return;
407     }
408 
409     int divot = 0;
410     int unusedStartOffset = 0;
411     int unusedEndOffset = 0;
412     unsigned divotLine = 0;
413     unsigned divotColumn = 0;
414     retrieveExpressionInfo(divot, unusedStartOffset, unusedEndOffset, divotLine, divotColumn);
415 
416     line = divotLine + codeBlock-&gt;ownerExecutable()-&gt;firstLine();
417     column = divotColumn + (divotLine ? 1 : codeBlock-&gt;firstLineColumnOffset());
418 
419     if (Optional&lt;int&gt; overrideLineNumber = codeBlock-&gt;ownerExecutable()-&gt;overrideLineNumber(codeBlock-&gt;vm()))
420         line = overrideLineNumber.value();
421 }
422 
423 void StackVisitor::Frame::retrieveExpressionInfo(int&amp; divot, int&amp; startOffset, int&amp; endOffset, unsigned&amp; line, unsigned&amp; column) const
424 {
425     CodeBlock* codeBlock = this-&gt;codeBlock();
<a name="19" id="anc19"></a><span class="line-modified">426     codeBlock-&gt;unlinkedCodeBlock()-&gt;expressionRangeForBytecodeIndex(bytecodeIndex(), divot, startOffset, endOffset, line, column);</span>
427     divot += codeBlock-&gt;sourceOffset();
428 }
429 
430 void StackVisitor::Frame::setToEnd()
431 {
432     m_callFrame = 0;
433 #if ENABLE(DFG_JIT)
434     m_inlineCallFrame = 0;
435 #endif
436     m_isWasmFrame = false;
437 }
438 
439 void StackVisitor::Frame::dump(PrintStream&amp; out, Indenter indent) const
440 {
441     dump(out, indent, [] (PrintStream&amp;) { });
442 }
443 
444 void StackVisitor::Frame::dump(PrintStream&amp; out, Indenter indent, WTF::Function&lt;void(PrintStream&amp;)&gt; prefix) const
445 {
446     if (!this-&gt;callFrame()) {
447         out.print(indent, &quot;frame 0x0\n&quot;);
448         return;
449     }
450 
451     CodeBlock* codeBlock = this-&gt;codeBlock();
452     out.print(indent);
453     prefix(out);
454     out.print(&quot;frame &quot;, RawPointer(this-&gt;callFrame()), &quot; {\n&quot;);
455 
456     {
457         indent++;
458 
459         CallFrame* callFrame = m_callFrame;
460         CallFrame* callerFrame = this-&gt;callerFrame();
461         const void* returnPC = callFrame-&gt;hasReturnPC() ? callFrame-&gt;returnPC().value() : nullptr;
462 
463         out.print(indent, &quot;name: &quot;, functionName(), &quot;\n&quot;);
464         out.print(indent, &quot;sourceURL: &quot;, sourceURL(), &quot;\n&quot;);
465 
466         bool isInlined = false;
467 #if ENABLE(DFG_JIT)
468         isInlined = isInlinedFrame();
469         out.print(indent, &quot;isInlinedFrame: &quot;, isInlinedFrame(), &quot;\n&quot;);
470         if (isInlinedFrame())
471             out.print(indent, &quot;InlineCallFrame: &quot;, RawPointer(m_inlineCallFrame), &quot;\n&quot;);
472 #endif
473 
474         out.print(indent, &quot;callee: &quot;, RawPointer(callee().rawPtr()), &quot;\n&quot;);
475         out.print(indent, &quot;returnPC: &quot;, RawPointer(returnPC), &quot;\n&quot;);
476         out.print(indent, &quot;callerFrame: &quot;, RawPointer(callerFrame), &quot;\n&quot;);
477         uintptr_t locationRawBits = callFrame-&gt;callSiteAsRawBits();
478         out.print(indent, &quot;rawLocationBits: &quot;, locationRawBits,
479             &quot; &quot;, RawPointer(reinterpret_cast&lt;void*&gt;(locationRawBits)), &quot;\n&quot;);
480         out.print(indent, &quot;codeBlock: &quot;, RawPointer(codeBlock));
481         if (codeBlock)
482             out.print(&quot; &quot;, *codeBlock);
483         out.print(&quot;\n&quot;);
484         if (codeBlock &amp;&amp; !isInlined) {
485             indent++;
486 
487             if (callFrame-&gt;callSiteBitsAreBytecodeOffset()) {
<a name="20" id="anc20"></a><span class="line-modified">488                 BytecodeIndex bytecodeIndex = callFrame-&gt;bytecodeIndex();</span>
<span class="line-modified">489                 out.print(indent, bytecodeIndex, &quot; of &quot;, codeBlock-&gt;instructions().size(), &quot;\n&quot;);</span>
490 #if ENABLE(DFG_JIT)
491             } else {
492                 out.print(indent, &quot;hasCodeOrigins: &quot;, codeBlock-&gt;hasCodeOrigins(), &quot;\n&quot;);
493                 if (codeBlock-&gt;hasCodeOrigins()) {
494                     CallSiteIndex callSiteIndex = callFrame-&gt;callSiteIndex();
495                     out.print(indent, &quot;callSiteIndex: &quot;, callSiteIndex.bits(), &quot; of &quot;, codeBlock-&gt;codeOrigins().size(), &quot;\n&quot;);
496 
497                     JITType jitType = codeBlock-&gt;jitType();
498                     if (jitType != JITType::FTLJIT) {
499                         JITCode* jitCode = codeBlock-&gt;jitCode().get();
500                         out.print(indent, &quot;jitCode: &quot;, RawPointer(jitCode),
501                             &quot; start &quot;, RawPointer(jitCode-&gt;start()),
502                             &quot; end &quot;, RawPointer(jitCode-&gt;end()), &quot;\n&quot;);
503                     }
504                 }
505 #endif
506             }
507             unsigned line = 0;
508             unsigned column = 0;
509             computeLineAndColumn(line, column);
510             out.print(indent, &quot;line: &quot;, line, &quot;\n&quot;);
511             out.print(indent, &quot;column: &quot;, column, &quot;\n&quot;);
512 
513             indent--;
514         }
515         out.print(indent, &quot;EntryFrame: &quot;, RawPointer(m_entryFrame), &quot;\n&quot;);
516         indent--;
517     }
518     out.print(indent, &quot;}\n&quot;);
519 }
520 
521 } // namespace JSC
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
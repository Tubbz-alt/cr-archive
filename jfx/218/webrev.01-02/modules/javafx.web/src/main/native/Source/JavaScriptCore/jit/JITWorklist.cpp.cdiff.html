<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITWorklist.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JITToDFGDeferredCompilationCallback.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITWorklist.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITWorklist.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 34,13 ***</span>
  
  namespace JSC {
  
  class JITWorklist::Plan : public ThreadSafeRefCounted&lt;JITWorklist::Plan&gt; {
  public:
<span class="line-modified">!     Plan(CodeBlock* codeBlock, unsigned loopOSREntryBytecodeOffset)</span>
          : m_codeBlock(codeBlock)
<span class="line-modified">!         , m_jit(codeBlock-&gt;vm(), codeBlock, loopOSREntryBytecodeOffset)</span>
      {
          m_jit.doMainThreadPreparationBeforeCompile();
      }
  
      void compileInThread()
<span class="line-new-header">--- 34,13 ---</span>
  
  namespace JSC {
  
  class JITWorklist::Plan : public ThreadSafeRefCounted&lt;JITWorklist::Plan&gt; {
  public:
<span class="line-modified">!     Plan(CodeBlock* codeBlock, BytecodeIndex loopOSREntryBytecodeIndex)</span>
          : m_codeBlock(codeBlock)
<span class="line-modified">!         , m_jit(codeBlock-&gt;vm(), codeBlock, loopOSREntryBytecodeIndex)</span>
      {
          m_jit.doMainThreadPreparationBeforeCompile();
      }
  
      void compileInThread()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 55,18 ***</span>
      {
          CompilationResult result = m_jit.link();
          switch (result) {
          case CompilationFailed:
              CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;delayJITCompile&quot;, (&quot;compilation failed&quot;));
<span class="line-modified">!             if (Options::verboseOSR())</span>
<span class="line-removed">-                 dataLogF(&quot;    JIT compilation failed.\n&quot;);</span>
              m_codeBlock-&gt;dontJITAnytimeSoon();
              m_codeBlock-&gt;m_didFailJITCompilation = true;
              return;
          case CompilationSuccessful:
<span class="line-modified">!             if (Options::verboseOSR())</span>
<span class="line-removed">-                 dataLogF(&quot;    JIT compilation successful.\n&quot;);</span>
              m_codeBlock-&gt;ownerExecutable()-&gt;installCode(m_codeBlock);
              m_codeBlock-&gt;jitSoon();
              return;
          default:
              RELEASE_ASSERT_NOT_REACHED();
<span class="line-new-header">--- 55,16 ---</span>
      {
          CompilationResult result = m_jit.link();
          switch (result) {
          case CompilationFailed:
              CODEBLOCK_LOG_EVENT(m_codeBlock, &quot;delayJITCompile&quot;, (&quot;compilation failed&quot;));
<span class="line-modified">!             dataLogLnIf(Options::verboseOSR(), &quot;    JIT compilation failed.&quot;);</span>
              m_codeBlock-&gt;dontJITAnytimeSoon();
              m_codeBlock-&gt;m_didFailJITCompilation = true;
              return;
          case CompilationSuccessful:
<span class="line-modified">!             dataLogLnIf(Options::verboseOSR(), &quot;    JIT compilation successful.&quot;);</span>
              m_codeBlock-&gt;ownerExecutable()-&gt;installCode(m_codeBlock);
              m_codeBlock-&gt;jitSoon();
              return;
          default:
              RELEASE_ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 81,13 ***</span>
      {
          LockHolder locker(m_lock);
          return m_isFinishedCompiling;
      }
  
<span class="line-modified">!     static void compileNow(CodeBlock* codeBlock, unsigned loopOSREntryBytecodeOffset)</span>
      {
<span class="line-modified">!         Plan plan(codeBlock, loopOSREntryBytecodeOffset);</span>
          plan.compileInThread();
          plan.finalize();
      }
  
  private:
<span class="line-new-header">--- 79,13 ---</span>
      {
          LockHolder locker(m_lock);
          return m_isFinishedCompiling;
      }
  
<span class="line-modified">!     static void compileNow(CodeBlock* codeBlock, BytecodeIndex loopOSREntryBytecodeIndex)</span>
      {
<span class="line-modified">!         Plan plan(codeBlock, loopOSREntryBytecodeIndex);</span>
          plan.compileInThread();
          plan.finalize();
      }
  
  private:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 226,22 ***</span>
      }
  
      finalizePlans(myPlans);
  }
  
<span class="line-modified">! void JITWorklist::compileLater(CodeBlock* codeBlock, unsigned loopOSREntryBytecodeOffset)</span>
  {
      DeferGC deferGC(codeBlock-&gt;vm().heap);
      RELEASE_ASSERT(codeBlock-&gt;jitType() == JITType::InterpreterThunk);
  
      if (codeBlock-&gt;m_didFailJITCompilation) {
          codeBlock-&gt;dontJITAnytimeSoon();
          return;
      }
  
      if (!Options::useConcurrentJIT()) {
<span class="line-modified">!         Plan::compileNow(codeBlock, loopOSREntryBytecodeOffset);</span>
          return;
      }
  
      codeBlock-&gt;jitSoon();
  
<span class="line-new-header">--- 224,22 ---</span>
      }
  
      finalizePlans(myPlans);
  }
  
<span class="line-modified">! void JITWorklist::compileLater(CodeBlock* codeBlock, BytecodeIndex loopOSREntryBytecodeIndex)</span>
  {
      DeferGC deferGC(codeBlock-&gt;vm().heap);
      RELEASE_ASSERT(codeBlock-&gt;jitType() == JITType::InterpreterThunk);
  
      if (codeBlock-&gt;m_didFailJITCompilation) {
          codeBlock-&gt;dontJITAnytimeSoon();
          return;
      }
  
      if (!Options::useConcurrentJIT()) {
<span class="line-modified">!         Plan::compileNow(codeBlock, loopOSREntryBytecodeIndex);</span>
          return;
      }
  
      codeBlock-&gt;jitSoon();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 251,11 ***</span>
          if (m_planned.contains(codeBlock))
              return;
  
          if (m_numAvailableThreads) {
              m_planned.add(codeBlock);
<span class="line-modified">!             RefPtr&lt;Plan&gt; plan = adoptRef(new Plan(codeBlock, loopOSREntryBytecodeOffset));</span>
              m_plans.append(plan);
              m_queue.append(plan);
              m_condition-&gt;notifyAll(locker);
              return;
          }
<span class="line-new-header">--- 249,11 ---</span>
          if (m_planned.contains(codeBlock))
              return;
  
          if (m_numAvailableThreads) {
              m_planned.add(codeBlock);
<span class="line-modified">!             RefPtr&lt;Plan&gt; plan = adoptRef(new Plan(codeBlock, loopOSREntryBytecodeIndex));</span>
              m_plans.append(plan);
              m_queue.append(plan);
              m_condition-&gt;notifyAll(locker);
              return;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 275,14 ***</span>
      // The single-threaded concurrent JIT has this tendency to convoy everything while at the same
      // time postponing when it happens, which means that the convoy delays are less predictable.
      // This works around the issue. If the concurrent JIT thread is convoyed, we revert to main
      // thread compiles. This is probably not as good as if we had multiple JIT threads. Maybe we
      // can do that someday.
<span class="line-modified">!     Plan::compileNow(codeBlock, loopOSREntryBytecodeOffset);</span>
  }
  
<span class="line-modified">! void JITWorklist::compileNow(CodeBlock* codeBlock, unsigned loopOSREntryBytecodeOffset)</span>
  {
      VM&amp; vm = codeBlock-&gt;vm();
      DeferGC deferGC(vm.heap);
      if (codeBlock-&gt;jitType() != JITType::InterpreterThunk)
          return;
<span class="line-new-header">--- 273,14 ---</span>
      // The single-threaded concurrent JIT has this tendency to convoy everything while at the same
      // time postponing when it happens, which means that the convoy delays are less predictable.
      // This works around the issue. If the concurrent JIT thread is convoyed, we revert to main
      // thread compiles. This is probably not as good as if we had multiple JIT threads. Maybe we
      // can do that someday.
<span class="line-modified">!     Plan::compileNow(codeBlock, loopOSREntryBytecodeIndex);</span>
  }
  
<span class="line-modified">! void JITWorklist::compileNow(CodeBlock* codeBlock, BytecodeIndex loopOSREntryBytecodeIndex)</span>
  {
      VM&amp; vm = codeBlock-&gt;vm();
      DeferGC deferGC(vm.heap);
      if (codeBlock-&gt;jitType() != JITType::InterpreterThunk)
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 306,11 ***</span>
      // We do this in case we had previously attempted, and then failed, to compile with the
      // baseline JIT.
      codeBlock-&gt;resetJITData();
  
      // OK, just compile it.
<span class="line-modified">!     JIT::compile(vm, codeBlock, JITCompilationMustSucceed, loopOSREntryBytecodeOffset);</span>
      codeBlock-&gt;ownerExecutable()-&gt;installCode(codeBlock);
  }
  
  void JITWorklist::finalizePlans(Plans&amp; myPlans)
  {
<span class="line-new-header">--- 304,11 ---</span>
      // We do this in case we had previously attempted, and then failed, to compile with the
      // baseline JIT.
      codeBlock-&gt;resetJITData();
  
      // OK, just compile it.
<span class="line-modified">!     JIT::compile(vm, codeBlock, JITCompilationMustSucceed, loopOSREntryBytecodeIndex);</span>
      codeBlock-&gt;ownerExecutable()-&gt;installCode(codeBlock);
  }
  
  void JITWorklist::finalizePlans(Plans&amp; myPlans)
  {
</pre>
<center><a href="JITToDFGDeferredCompilationCallback.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITWorklist.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/ShadowChicken.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Register.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ShadowChicken.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/ShadowChicken.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2016 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ShadowChicken.h&quot;
 28 
 29 #include &quot;CodeBlock.h&quot;
 30 #include &quot;JSCInlines.h&quot;
 31 #include &quot;ShadowChickenInlines.h&quot;
 32 #include &lt;wtf/ListDump.h&gt;
 33 
 34 namespace JSC {
 35 
 36 namespace ShadowChickenInternal {
<span class="line-modified"> 37 static const bool verbose = false;</span>
 38 }
 39 
 40 void ShadowChicken::Packet::dump(PrintStream&amp; out) const
 41 {
 42     if (!*this) {
 43         out.print(&quot;empty&quot;);
 44         return;
 45     }
 46 
 47     if (isPrologue()) {







 48         out.print(
 49             &quot;{callee = &quot;, RawPointer(callee), &quot;, frame = &quot;, RawPointer(frame), &quot;, callerFrame = &quot;,
<span class="line-modified"> 50             RawPointer(callerFrame), &quot;}&quot;);</span>
 51         return;
 52     }
 53 
 54     if (isTail()) {
 55         out.print(&quot;tail-packet:{frame = &quot;, RawPointer(frame), &quot;}&quot;);
 56         return;
 57     }
 58 
 59     ASSERT(isThrow());
 60     out.print(&quot;throw&quot;);
 61 }
 62 
 63 void ShadowChicken::Frame::dump(PrintStream&amp; out) const
 64 {







 65     out.print(
<span class="line-modified"> 66         &quot;{callee = &quot;, RawPointer(callee), &quot;, frame = &quot;, RawPointer(frame), &quot;, isTailDeleted = &quot;,</span>
<span class="line-modified"> 67         isTailDeleted, &quot;}&quot;);</span>
 68 }
 69 
 70 ShadowChicken::ShadowChicken()
 71     : m_logSize(Options::shadowChickenLogSize())
 72 {
<span class="line-modified"> 73     m_log = static_cast&lt;Packet*&gt;(fastZeroedMalloc(sizeof(Packet) * m_logSize));</span>





 74     m_logCursor = m_log;
 75     m_logEnd = m_log + m_logSize;
 76 }
 77 
 78 ShadowChicken::~ShadowChicken()
 79 {
 80     fastFree(m_log);
 81 }
 82 
<span class="line-modified"> 83 void ShadowChicken::log(VM&amp; vm, ExecState* exec, const Packet&amp; packet)</span>
 84 {
<span class="line-modified"> 85     update(vm, exec);</span>
 86     *m_logCursor++ = packet;

 87 }
 88 
<span class="line-modified"> 89 void ShadowChicken::update(VM&amp; vm, ExecState* exec)</span>
 90 {
 91     if (ShadowChickenInternal::verbose) {
 92         dataLog(&quot;Running update on: &quot;, *this, &quot;\n&quot;);
 93         WTFReportBacktrace();
 94     }
 95 
 96     const unsigned logCursorIndex = m_logCursor - m_log;
 97 
 98     // We need to figure out how to reconcile the current machine stack with our shadow stack. We do
 99     // that by figuring out how much of the shadow stack to pop. We apply three different rules. The
100     // precise rule relies on the log. The log contains caller frames, which means that we know
101     // where we bottomed out after making any call. If we bottomed out but made no calls then &#39;exec&#39;
102     // will tell us. That&#39;s why &quot;highestPointSinceLastTime&quot; will go no lower than exec. The third
103     // rule, based on comparing to the current real stack, is executed in a later loop.
<span class="line-modified">104     CallFrame* highestPointSinceLastTime = exec;</span>
105     for (unsigned i = logCursorIndex; i--;) {
106         Packet packet = m_log[i];
107         if (packet.isPrologue()) {
108             CallFrame* watermark;
109             if (i &amp;&amp; m_log[i - 1].isTail())
110                 watermark = packet.frame;
111             else
112                 watermark = packet.callerFrame;
113             highestPointSinceLastTime = std::max(highestPointSinceLastTime, watermark);
114         }
115     }
116 
117     if (ShadowChickenInternal::verbose)
118         dataLog(&quot;Highest point since last time: &quot;, RawPointer(highestPointSinceLastTime), &quot;\n&quot;);
119 
120     while (!m_stack.isEmpty() &amp;&amp; (m_stack.last().frame &lt; highestPointSinceLastTime || m_stack.last().isTailDeleted))
121         m_stack.removeLast();
122 
123     if (ShadowChickenInternal::verbose)
124         dataLog(&quot;    Revised stack: &quot;, listDump(m_stack), &quot;\n&quot;);
125 
126     // It&#39;s possible that the top of stack is now tail-deleted. The stack no longer contains any
127     // frames below the log&#39;s high watermark. That means that we just need to look for the first
128     // occurence of a tail packet for the current stack top.
129     if (!m_stack.isEmpty()) {
130         ASSERT(!m_stack.last().isTailDeleted);
131         for (unsigned i = 0; i &lt; logCursorIndex; ++i) {
132             Packet&amp; packet = m_log[i];
133             if (packet.isTail() &amp;&amp; packet.frame == m_stack.last().frame) {
134                 Frame&amp; frame = m_stack.last();
135                 frame.thisValue = packet.thisValue;
136                 frame.scope = packet.scope;
137                 frame.codeBlock = packet.codeBlock;
138                 frame.callSiteIndex = packet.callSiteIndex;
139                 frame.isTailDeleted = true;
140                 break;
141             }
142         }
143     }
144 
<span class="line-removed">145 </span>
146     if (ShadowChickenInternal::verbose)
147         dataLog(&quot;    Revised stack: &quot;, listDump(m_stack), &quot;\n&quot;);
148 
<span class="line-modified">149     // The log-based and exec-based rules require that ShadowChicken was enabled. The point of</span>
150     // ShadowChicken is to give sensible-looking results even if we had not logged. This means that
151     // we need to reconcile the shadow stack and the real stack by actually looking at the real
152     // stack. This reconciliation allows the shadow stack to have extra tail-deleted frames, but it
153     // forbids it from diverging from the real stack on normal frames.
154     if (!m_stack.isEmpty()) {
155         Vector&lt;Frame&gt; stackRightNow;
156         StackVisitor::visit(
<span class="line-modified">157             exec, &amp;vm, [&amp;] (StackVisitor&amp; visitor) -&gt; StackVisitor::Status {</span>
158                 if (visitor-&gt;isInlinedFrame())
159                     return StackVisitor::Continue;
160                 if (visitor-&gt;isWasmFrame()) {
161                     // FIXME: Make shadow chicken work with Wasm.
162                     // https://bugs.webkit.org/show_bug.cgi?id=165441
163                     return StackVisitor::Continue;
164                 }
165 
166                 bool isTailDeleted = false;
167                 // FIXME: Make shadow chicken work with Wasm.
168                 // https://bugs.webkit.org/show_bug.cgi?id=165441
169                 stackRightNow.append(Frame(jsCast&lt;JSObject*&gt;(visitor-&gt;callee().asCell()), visitor-&gt;callFrame(), isTailDeleted));
170                 return StackVisitor::Continue;
171             });
172         stackRightNow.reverse();
173 
174         if (ShadowChickenInternal::verbose)
175             dataLog(&quot;    Stack right now: &quot;, listDump(stackRightNow), &quot;\n&quot;);
176 
177         unsigned shadowIndex = 0;
</pre>
<hr />
<pre>
258         // - Leaving the log index at -1, which will prevent the log from being considered. This is
259         //   the most conservative. It means that we will not be able to recover tail-deleted frames
260         //   from anything that sits above a frame that didn&#39;t log a prologue packet. This means
261         //   that everyone who creates prologues must log prologue packets.
262         //
263         // - Restoring the log index to what it was before. This prevents us from considering
264         //   whether this frame has tail-deleted frames behind it, but that&#39;s about it. The problem
265         //   with this approach is that it might recover tail-deleted frames that aren&#39;t relevant.
266         //   I haven&#39;t thought about this too deeply, though.
267         //
268         // It seems like the latter option is less harmful, so that&#39;s what we do.
269         indexInLog = oldIndexInLog;
270 
271         if (ShadowChickenInternal::verbose)
272             dataLog(&quot;    Didn&#39;t find it.\n&quot;);
273         return false;
274     };
275 
276     Vector&lt;Frame&gt; toPush;
277     StackVisitor::visit(
<span class="line-modified">278         exec, &amp;vm, [&amp;] (StackVisitor&amp; visitor) -&gt; StackVisitor::Status {</span>
279             if (visitor-&gt;isInlinedFrame()) {
280                 // FIXME: Handle inlining.
281                 // https://bugs.webkit.org/show_bug.cgi?id=155686
282                 return StackVisitor::Continue;
283             }
284 
285             if (visitor-&gt;isWasmFrame()) {
286                 // FIXME: Make shadow chicken work with Wasm.
287                 return StackVisitor::Continue;
288             }
289 
290             CallFrame* callFrame = visitor-&gt;callFrame();
<span class="line-modified">291             if (ShadowChickenInternal::verbose)</span>
<span class="line-modified">292                 dataLog(&quot;    Examining &quot;, RawPointer(callFrame), &quot;\n&quot;);</span>





293             if (callFrame == highestPointSinceLastTime) {
294                 if (ShadowChickenInternal::verbose)
<span class="line-modified">295                     dataLog(&quot;    Bailing at &quot;, RawPointer(callFrame), &quot; because it&#39;s the highest point since last time.\n&quot;);</span>





296                 return StackVisitor::Done;
297             }
298 
299             bool foundFrame = advanceIndexInLogTo(callFrame, callFrame-&gt;jsCallee(), callFrame-&gt;callerFrame());
300             bool isTailDeleted = false;
301             JSScope* scope = nullptr;
302             CodeBlock* codeBlock = callFrame-&gt;codeBlock();
<span class="line-modified">303             JSValue scopeValue = callFrame-&gt;bytecodeOffset() &amp;&amp; codeBlock &amp;&amp; codeBlock-&gt;scopeRegister().isValid()</span>
304                 ? callFrame-&gt;registers()[codeBlock-&gt;scopeRegister().offset()].jsValue()
305                 : jsUndefined();
306             if (!scopeValue.isUndefined() &amp;&amp; codeBlock-&gt;wasCompiledWithDebuggingOpcodes()) {
307                 scope = jsCast&lt;JSScope*&gt;(scopeValue.asCell());
308                 RELEASE_ASSERT(scope-&gt;inherits&lt;JSScope&gt;(vm));
309             } else if (foundFrame) {
310                 scope = m_log[indexInLog].scope;
311                 if (scope)
312                     RELEASE_ASSERT(scope-&gt;inherits&lt;JSScope&gt;(vm));
313             }
314             toPush.append(Frame(jsCast&lt;JSObject*&gt;(visitor-&gt;callee().asCell()), callFrame, isTailDeleted, callFrame-&gt;thisValue(), scope, codeBlock, callFrame-&gt;callSiteIndex()));
315 
316             if (indexInLog &lt; logCursorIndex
317                 // This condition protects us from the case where advanceIndexInLogTo didn&#39;t find
318                 // anything.
319                 &amp;&amp; m_log[indexInLog].frame == toPush.last().frame) {
320                 if (ShadowChickenInternal::verbose)
<span class="line-modified">321                     dataLog(&quot;    Going to loop through to find tail deleted frames with indexInLog = &quot;, indexInLog, &quot; and push-stack top = &quot;, toPush.last(), &quot;\n&quot;);</span>
322                 for (;;) {
323                     ASSERT(m_log[indexInLog].frame == toPush.last().frame);
324 
325                     // Right now the index is pointing at a prologue packet of the last frame that
326                     // we pushed. Peek behind that packet to see if there is a tail packet. If there
327                     // is one then we know that there is a corresponding prologue packet that will
328                     // tell us about a tail-deleted frame.
329 
330                     if (!indexInLog)
331                         break;
332                     Packet tailPacket = m_log[indexInLog - 1];
333                     if (!tailPacket.isTail()) {
334                         // Last frame that we recorded was not the outcome of a tail call. So, there
335                         // will not be any more deleted frames.
336                         // FIXME: We might want to have a filter here. Consider that this was a tail
337                         // marker for a tail call to something that didn&#39;t log anything. It should
338                         // be sufficient to give the tail marker a copy of the caller frame.
339                         // https://bugs.webkit.org/show_bug.cgi?id=155687
340                         break;
341                     }
342                     indexInLog--; // Skip over the tail packet.
343 




344                     if (!advanceIndexInLogTo(tailPacket.frame, nullptr, nullptr)) {
345                         if (ShadowChickenInternal::verbose)
346                             dataLog(&quot;Can&#39;t find prologue packet for tail: &quot;, RawPointer(tailPacket.frame), &quot;\n&quot;);
347                         // We were unable to locate the prologue packet for this tail packet.
348                         // This is rare but can happen in a situation like:
349                         // function foo() {
350                         //     ... call some deeply tail-recursive function, causing a random number of log processings.
351                         //     return bar(); // tail call
352                         // }
353                         break;
354                     }
355                     Packet packet = m_log[indexInLog];
356                     bool isTailDeleted = true;
357                     RELEASE_ASSERT(tailPacket.scope-&gt;inherits&lt;JSScope&gt;(vm));
358                     toPush.append(Frame(packet.callee, packet.frame, isTailDeleted, tailPacket.thisValue, tailPacket.scope, tailPacket.codeBlock, tailPacket.callSiteIndex));
359                 }
360             }
361 
362             return StackVisitor::Continue;
363         });
364 
365     if (ShadowChickenInternal::verbose)
366         dataLog(&quot;    Pushing: &quot;, listDump(toPush), &quot;\n&quot;);
367 
368     for (unsigned i = toPush.size(); i--;)
369         m_stack.append(toPush[i]);
370 
371     // We want to reset the log. There is a fun corner-case: there could be a tail marker at the end
372     // of this log. We could make that work by setting isTailDeleted on the top of stack, but that
373     // would require more corner cases in the complicated reconciliation code above. That code
374     // already knows how to handle a tail packet at the beginning, so we just leverage that here.
375     if (logCursorIndex &amp;&amp; m_log[logCursorIndex - 1].isTail()) {
376         m_log[0] = m_log[logCursorIndex - 1];
377         m_logCursor = m_log + 1;
378     } else
379         m_logCursor = m_log;
380 
381     if (ShadowChickenInternal::verbose)
<span class="line-modified">382         dataLog(&quot;    After pushing: &quot;, *this, &quot;\n&quot;);</span>
383 
384     // Remove tail frames until the number of tail deleted frames is small enough.
385     const unsigned maxTailDeletedFrames = Options::shadowChickenMaxTailDeletedFramesSize();
386     if (m_stack.size() &gt; maxTailDeletedFrames) {
387         unsigned numberOfTailDeletedFrames = 0;
388         for (const Frame&amp; frame : m_stack) {
389             if (frame.isTailDeleted)
390                 numberOfTailDeletedFrames++;
391         }
392         if (numberOfTailDeletedFrames &gt; maxTailDeletedFrames) {
393             unsigned dstIndex = 0;
394             unsigned srcIndex = 0;
395             while (srcIndex &lt; m_stack.size()) {
396                 Frame frame = m_stack[srcIndex++];
397                 if (numberOfTailDeletedFrames &gt; maxTailDeletedFrames &amp;&amp; frame.isTailDeleted) {
398                     numberOfTailDeletedFrames--;
399                     continue;
400                 }
401                 m_stack[dstIndex++] = frame;
402             }
</pre>
<hr />
<pre>
430             visitor.appendUnbarriered(frame.scope);
431         if (frame.codeBlock)
432             visitor.appendUnbarriered(frame.codeBlock);
433     }
434 }
435 
436 void ShadowChicken::reset()
437 {
438     m_logCursor = m_log;
439     m_stack.clear();
440 }
441 
442 void ShadowChicken::dump(PrintStream&amp; out) const
443 {
444     out.print(&quot;{stack = [&quot;, listDump(m_stack), &quot;], log = [&quot;);
445 
446     CommaPrinter comma;
447     unsigned limit = static_cast&lt;unsigned&gt;(m_logCursor - m_log);
448     out.print(&quot;\n&quot;);
449     for (unsigned i = 0; i &lt; limit; ++i)
<span class="line-modified">450         out.print(&quot;\t&quot;, comma, m_log[i], &quot;\n&quot;);</span>
451     out.print(&quot;]}&quot;);
452 }
453 
<span class="line-modified">454 JSArray* ShadowChicken::functionsOnStack(ExecState* exec)</span>
455 {
<span class="line-modified">456     VM&amp; vm = exec-&gt;vm();</span>
457     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">458     JSArray* result = constructEmptyArray(exec, 0);</span>
459     RETURN_IF_EXCEPTION(scope, nullptr);
460 
461     iterate(
<span class="line-modified">462         vm, exec,</span>
463         [&amp;] (const Frame&amp; frame) -&gt; bool {
<span class="line-modified">464             result-&gt;push(exec, frame.callee);</span>
465             scope.releaseAssertNoException(); // This function is only called from tests.
466             return true;
467         });
468 
469     return result;
470 }
471 
472 } // namespace JSC
473 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ShadowChicken.h&quot;
 28 
 29 #include &quot;CodeBlock.h&quot;
 30 #include &quot;JSCInlines.h&quot;
 31 #include &quot;ShadowChickenInlines.h&quot;
 32 #include &lt;wtf/ListDump.h&gt;
 33 
 34 namespace JSC {
 35 
 36 namespace ShadowChickenInternal {
<span class="line-modified"> 37 static constexpr bool verbose = false;</span>
 38 }
 39 
 40 void ShadowChicken::Packet::dump(PrintStream&amp; out) const
 41 {
 42     if (!*this) {
 43         out.print(&quot;empty&quot;);
 44         return;
 45     }
 46 
 47     if (isPrologue()) {
<span class="line-added"> 48         String name = &quot;?&quot;_s;</span>
<span class="line-added"> 49         if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(callee-&gt;vm(), callee)) {</span>
<span class="line-added"> 50             name = function-&gt;name(callee-&gt;vm());</span>
<span class="line-added"> 51             if (name.isEmpty())</span>
<span class="line-added"> 52                 name = &quot;?&quot;_s;</span>
<span class="line-added"> 53         }</span>
<span class="line-added"> 54 </span>
 55         out.print(
 56             &quot;{callee = &quot;, RawPointer(callee), &quot;, frame = &quot;, RawPointer(frame), &quot;, callerFrame = &quot;,
<span class="line-modified"> 57             RawPointer(callerFrame), &quot;, name = &quot;, name, &quot;}&quot;);</span>
 58         return;
 59     }
 60 
 61     if (isTail()) {
 62         out.print(&quot;tail-packet:{frame = &quot;, RawPointer(frame), &quot;}&quot;);
 63         return;
 64     }
 65 
 66     ASSERT(isThrow());
 67     out.print(&quot;throw&quot;);
 68 }
 69 
 70 void ShadowChicken::Frame::dump(PrintStream&amp; out) const
 71 {
<span class="line-added"> 72     String name = &quot;?&quot;_s;</span>
<span class="line-added"> 73     if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(callee-&gt;vm(), callee)) {</span>
<span class="line-added"> 74         name = function-&gt;name(callee-&gt;vm());</span>
<span class="line-added"> 75         if (name.isEmpty())</span>
<span class="line-added"> 76             name = &quot;?&quot;_s;</span>
<span class="line-added"> 77     }</span>
<span class="line-added"> 78 </span>
 79     out.print(
<span class="line-modified"> 80         &quot;{callee = &quot;, *callee, &quot;, frame = &quot;, RawPointer(frame), &quot;, isTailDeleted = &quot;,</span>
<span class="line-modified"> 81         isTailDeleted, &quot;, name = &quot;, name, &quot;}&quot;);</span>
 82 }
 83 
 84 ShadowChicken::ShadowChicken()
 85     : m_logSize(Options::shadowChickenLogSize())
 86 {
<span class="line-modified"> 87     // Allow one additional packet beyond m_logEnd. This is useful for the moment we</span>
<span class="line-added"> 88     // log a packet when the log is full and force an update. At that moment the packet</span>
<span class="line-added"> 89     // that is being logged should be included in the update because it may be</span>
<span class="line-added"> 90     // a critical prologue needed to rationalize the current machine stack with the</span>
<span class="line-added"> 91     // shadow stack.</span>
<span class="line-added"> 92     m_log = static_cast&lt;Packet*&gt;(fastZeroedMalloc(sizeof(Packet) * (m_logSize + 1)));</span>
 93     m_logCursor = m_log;
 94     m_logEnd = m_log + m_logSize;
 95 }
 96 
 97 ShadowChicken::~ShadowChicken()
 98 {
 99     fastFree(m_log);
100 }
101 
<span class="line-modified">102 void ShadowChicken::log(VM&amp; vm, CallFrame* callFrame, const Packet&amp; packet)</span>
103 {
<span class="line-modified">104     // This write is allowed because we construct the log with space for 1 additional packet.</span>
105     *m_logCursor++ = packet;
<span class="line-added">106     update(vm, callFrame);</span>
107 }
108 
<span class="line-modified">109 void ShadowChicken::update(VM&amp; vm, CallFrame* callFrame)</span>
110 {
111     if (ShadowChickenInternal::verbose) {
112         dataLog(&quot;Running update on: &quot;, *this, &quot;\n&quot;);
113         WTFReportBacktrace();
114     }
115 
116     const unsigned logCursorIndex = m_logCursor - m_log;
117 
118     // We need to figure out how to reconcile the current machine stack with our shadow stack. We do
119     // that by figuring out how much of the shadow stack to pop. We apply three different rules. The
120     // precise rule relies on the log. The log contains caller frames, which means that we know
121     // where we bottomed out after making any call. If we bottomed out but made no calls then &#39;exec&#39;
122     // will tell us. That&#39;s why &quot;highestPointSinceLastTime&quot; will go no lower than exec. The third
123     // rule, based on comparing to the current real stack, is executed in a later loop.
<span class="line-modified">124     CallFrame* highestPointSinceLastTime = callFrame;</span>
125     for (unsigned i = logCursorIndex; i--;) {
126         Packet packet = m_log[i];
127         if (packet.isPrologue()) {
128             CallFrame* watermark;
129             if (i &amp;&amp; m_log[i - 1].isTail())
130                 watermark = packet.frame;
131             else
132                 watermark = packet.callerFrame;
133             highestPointSinceLastTime = std::max(highestPointSinceLastTime, watermark);
134         }
135     }
136 
137     if (ShadowChickenInternal::verbose)
138         dataLog(&quot;Highest point since last time: &quot;, RawPointer(highestPointSinceLastTime), &quot;\n&quot;);
139 
140     while (!m_stack.isEmpty() &amp;&amp; (m_stack.last().frame &lt; highestPointSinceLastTime || m_stack.last().isTailDeleted))
141         m_stack.removeLast();
142 
143     if (ShadowChickenInternal::verbose)
144         dataLog(&quot;    Revised stack: &quot;, listDump(m_stack), &quot;\n&quot;);
145 
146     // It&#39;s possible that the top of stack is now tail-deleted. The stack no longer contains any
147     // frames below the log&#39;s high watermark. That means that we just need to look for the first
148     // occurence of a tail packet for the current stack top.
149     if (!m_stack.isEmpty()) {
150         ASSERT(!m_stack.last().isTailDeleted);
151         for (unsigned i = 0; i &lt; logCursorIndex; ++i) {
152             Packet&amp; packet = m_log[i];
153             if (packet.isTail() &amp;&amp; packet.frame == m_stack.last().frame) {
154                 Frame&amp; frame = m_stack.last();
155                 frame.thisValue = packet.thisValue;
156                 frame.scope = packet.scope;
157                 frame.codeBlock = packet.codeBlock;
158                 frame.callSiteIndex = packet.callSiteIndex;
159                 frame.isTailDeleted = true;
160                 break;
161             }
162         }
163     }
164 

165     if (ShadowChickenInternal::verbose)
166         dataLog(&quot;    Revised stack: &quot;, listDump(m_stack), &quot;\n&quot;);
167 
<span class="line-modified">168     // The log-based and callFrame-based rules require that ShadowChicken was enabled. The point of</span>
169     // ShadowChicken is to give sensible-looking results even if we had not logged. This means that
170     // we need to reconcile the shadow stack and the real stack by actually looking at the real
171     // stack. This reconciliation allows the shadow stack to have extra tail-deleted frames, but it
172     // forbids it from diverging from the real stack on normal frames.
173     if (!m_stack.isEmpty()) {
174         Vector&lt;Frame&gt; stackRightNow;
175         StackVisitor::visit(
<span class="line-modified">176             callFrame, vm, [&amp;] (StackVisitor&amp; visitor) -&gt; StackVisitor::Status {</span>
177                 if (visitor-&gt;isInlinedFrame())
178                     return StackVisitor::Continue;
179                 if (visitor-&gt;isWasmFrame()) {
180                     // FIXME: Make shadow chicken work with Wasm.
181                     // https://bugs.webkit.org/show_bug.cgi?id=165441
182                     return StackVisitor::Continue;
183                 }
184 
185                 bool isTailDeleted = false;
186                 // FIXME: Make shadow chicken work with Wasm.
187                 // https://bugs.webkit.org/show_bug.cgi?id=165441
188                 stackRightNow.append(Frame(jsCast&lt;JSObject*&gt;(visitor-&gt;callee().asCell()), visitor-&gt;callFrame(), isTailDeleted));
189                 return StackVisitor::Continue;
190             });
191         stackRightNow.reverse();
192 
193         if (ShadowChickenInternal::verbose)
194             dataLog(&quot;    Stack right now: &quot;, listDump(stackRightNow), &quot;\n&quot;);
195 
196         unsigned shadowIndex = 0;
</pre>
<hr />
<pre>
277         // - Leaving the log index at -1, which will prevent the log from being considered. This is
278         //   the most conservative. It means that we will not be able to recover tail-deleted frames
279         //   from anything that sits above a frame that didn&#39;t log a prologue packet. This means
280         //   that everyone who creates prologues must log prologue packets.
281         //
282         // - Restoring the log index to what it was before. This prevents us from considering
283         //   whether this frame has tail-deleted frames behind it, but that&#39;s about it. The problem
284         //   with this approach is that it might recover tail-deleted frames that aren&#39;t relevant.
285         //   I haven&#39;t thought about this too deeply, though.
286         //
287         // It seems like the latter option is less harmful, so that&#39;s what we do.
288         indexInLog = oldIndexInLog;
289 
290         if (ShadowChickenInternal::verbose)
291             dataLog(&quot;    Didn&#39;t find it.\n&quot;);
292         return false;
293     };
294 
295     Vector&lt;Frame&gt; toPush;
296     StackVisitor::visit(
<span class="line-modified">297         callFrame, vm, [&amp;] (StackVisitor&amp; visitor) -&gt; StackVisitor::Status {</span>
298             if (visitor-&gt;isInlinedFrame()) {
299                 // FIXME: Handle inlining.
300                 // https://bugs.webkit.org/show_bug.cgi?id=155686
301                 return StackVisitor::Continue;
302             }
303 
304             if (visitor-&gt;isWasmFrame()) {
305                 // FIXME: Make shadow chicken work with Wasm.
306                 return StackVisitor::Continue;
307             }
308 
309             CallFrame* callFrame = visitor-&gt;callFrame();
<span class="line-modified">310             if (ShadowChickenInternal::verbose) {</span>
<span class="line-modified">311                 dataLog(&quot;    Examining callFrame:&quot;, RawPointer(callFrame), &quot;, callee:&quot;, RawPointer(callFrame-&gt;jsCallee()), &quot;, callerFrame:&quot;, RawPointer(callFrame-&gt;callerFrame()), &quot;\n&quot;);</span>
<span class="line-added">312                 JSObject* callee = callFrame-&gt;jsCallee();</span>
<span class="line-added">313                 if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(callee-&gt;vm(), callee))</span>
<span class="line-added">314                     dataLog(&quot;      Function = &quot;, function-&gt;name(callee-&gt;vm()), &quot;\n&quot;);</span>
<span class="line-added">315             }</span>
<span class="line-added">316 </span>
317             if (callFrame == highestPointSinceLastTime) {
318                 if (ShadowChickenInternal::verbose)
<span class="line-modified">319                     dataLog(&quot;    Bailing at &quot;, RawPointer(callFrame), &quot; because it&#39;s the highest point since last time\n&quot;);</span>
<span class="line-added">320 </span>
<span class="line-added">321                 // FIXME: At this point the shadow stack may still have tail deleted frames</span>
<span class="line-added">322                 // that do not run into the current call frame but are left in the shadow stack.</span>
<span class="line-added">323                 // Those tail deleted frames should be validated somehow.</span>
<span class="line-added">324 </span>
325                 return StackVisitor::Done;
326             }
327 
328             bool foundFrame = advanceIndexInLogTo(callFrame, callFrame-&gt;jsCallee(), callFrame-&gt;callerFrame());
329             bool isTailDeleted = false;
330             JSScope* scope = nullptr;
331             CodeBlock* codeBlock = callFrame-&gt;codeBlock();
<span class="line-modified">332             JSValue scopeValue = callFrame-&gt;bytecodeIndex() &amp;&amp; codeBlock &amp;&amp; codeBlock-&gt;scopeRegister().isValid()</span>
333                 ? callFrame-&gt;registers()[codeBlock-&gt;scopeRegister().offset()].jsValue()
334                 : jsUndefined();
335             if (!scopeValue.isUndefined() &amp;&amp; codeBlock-&gt;wasCompiledWithDebuggingOpcodes()) {
336                 scope = jsCast&lt;JSScope*&gt;(scopeValue.asCell());
337                 RELEASE_ASSERT(scope-&gt;inherits&lt;JSScope&gt;(vm));
338             } else if (foundFrame) {
339                 scope = m_log[indexInLog].scope;
340                 if (scope)
341                     RELEASE_ASSERT(scope-&gt;inherits&lt;JSScope&gt;(vm));
342             }
343             toPush.append(Frame(jsCast&lt;JSObject*&gt;(visitor-&gt;callee().asCell()), callFrame, isTailDeleted, callFrame-&gt;thisValue(), scope, codeBlock, callFrame-&gt;callSiteIndex()));
344 
345             if (indexInLog &lt; logCursorIndex
346                 // This condition protects us from the case where advanceIndexInLogTo didn&#39;t find
347                 // anything.
348                 &amp;&amp; m_log[indexInLog].frame == toPush.last().frame) {
349                 if (ShadowChickenInternal::verbose)
<span class="line-modified">350                     dataLog(&quot;    Going to loop through to find tail deleted frames using &quot;, RawPointer(callFrame), &quot; with indexInLog = &quot;, indexInLog, &quot; and push-stack top = &quot;, toPush.last(), &quot;\n&quot;);</span>
351                 for (;;) {
352                     ASSERT(m_log[indexInLog].frame == toPush.last().frame);
353 
354                     // Right now the index is pointing at a prologue packet of the last frame that
355                     // we pushed. Peek behind that packet to see if there is a tail packet. If there
356                     // is one then we know that there is a corresponding prologue packet that will
357                     // tell us about a tail-deleted frame.
358 
359                     if (!indexInLog)
360                         break;
361                     Packet tailPacket = m_log[indexInLog - 1];
362                     if (!tailPacket.isTail()) {
363                         // Last frame that we recorded was not the outcome of a tail call. So, there
364                         // will not be any more deleted frames.
365                         // FIXME: We might want to have a filter here. Consider that this was a tail
366                         // marker for a tail call to something that didn&#39;t log anything. It should
367                         // be sufficient to give the tail marker a copy of the caller frame.
368                         // https://bugs.webkit.org/show_bug.cgi?id=155687
369                         break;
370                     }
371                     indexInLog--; // Skip over the tail packet.
372 
<span class="line-added">373                     // FIXME: After a few iterations the tail packet referenced frame may not be the</span>
<span class="line-added">374                     // same as the original callFrame for the real stack frame we started with.</span>
<span class="line-added">375                     // It is unclear when we should break.</span>
<span class="line-added">376 </span>
377                     if (!advanceIndexInLogTo(tailPacket.frame, nullptr, nullptr)) {
378                         if (ShadowChickenInternal::verbose)
379                             dataLog(&quot;Can&#39;t find prologue packet for tail: &quot;, RawPointer(tailPacket.frame), &quot;\n&quot;);
380                         // We were unable to locate the prologue packet for this tail packet.
381                         // This is rare but can happen in a situation like:
382                         // function foo() {
383                         //     ... call some deeply tail-recursive function, causing a random number of log processings.
384                         //     return bar(); // tail call
385                         // }
386                         break;
387                     }
388                     Packet packet = m_log[indexInLog];
389                     bool isTailDeleted = true;
390                     RELEASE_ASSERT(tailPacket.scope-&gt;inherits&lt;JSScope&gt;(vm));
391                     toPush.append(Frame(packet.callee, packet.frame, isTailDeleted, tailPacket.thisValue, tailPacket.scope, tailPacket.codeBlock, tailPacket.callSiteIndex));
392                 }
393             }
394 
395             return StackVisitor::Continue;
396         });
397 
398     if (ShadowChickenInternal::verbose)
399         dataLog(&quot;    Pushing: &quot;, listDump(toPush), &quot;\n&quot;);
400 
401     for (unsigned i = toPush.size(); i--;)
402         m_stack.append(toPush[i]);
403 
404     // We want to reset the log. There is a fun corner-case: there could be a tail marker at the end
405     // of this log. We could make that work by setting isTailDeleted on the top of stack, but that
406     // would require more corner cases in the complicated reconciliation code above. That code
407     // already knows how to handle a tail packet at the beginning, so we just leverage that here.
408     if (logCursorIndex &amp;&amp; m_log[logCursorIndex - 1].isTail()) {
409         m_log[0] = m_log[logCursorIndex - 1];
410         m_logCursor = m_log + 1;
411     } else
412         m_logCursor = m_log;
413 
414     if (ShadowChickenInternal::verbose)
<span class="line-modified">415         dataLog(&quot;    After pushing: &quot;, listDump(m_stack), &quot;\n&quot;);</span>
416 
417     // Remove tail frames until the number of tail deleted frames is small enough.
418     const unsigned maxTailDeletedFrames = Options::shadowChickenMaxTailDeletedFramesSize();
419     if (m_stack.size() &gt; maxTailDeletedFrames) {
420         unsigned numberOfTailDeletedFrames = 0;
421         for (const Frame&amp; frame : m_stack) {
422             if (frame.isTailDeleted)
423                 numberOfTailDeletedFrames++;
424         }
425         if (numberOfTailDeletedFrames &gt; maxTailDeletedFrames) {
426             unsigned dstIndex = 0;
427             unsigned srcIndex = 0;
428             while (srcIndex &lt; m_stack.size()) {
429                 Frame frame = m_stack[srcIndex++];
430                 if (numberOfTailDeletedFrames &gt; maxTailDeletedFrames &amp;&amp; frame.isTailDeleted) {
431                     numberOfTailDeletedFrames--;
432                     continue;
433                 }
434                 m_stack[dstIndex++] = frame;
435             }
</pre>
<hr />
<pre>
463             visitor.appendUnbarriered(frame.scope);
464         if (frame.codeBlock)
465             visitor.appendUnbarriered(frame.codeBlock);
466     }
467 }
468 
469 void ShadowChicken::reset()
470 {
471     m_logCursor = m_log;
472     m_stack.clear();
473 }
474 
475 void ShadowChicken::dump(PrintStream&amp; out) const
476 {
477     out.print(&quot;{stack = [&quot;, listDump(m_stack), &quot;], log = [&quot;);
478 
479     CommaPrinter comma;
480     unsigned limit = static_cast&lt;unsigned&gt;(m_logCursor - m_log);
481     out.print(&quot;\n&quot;);
482     for (unsigned i = 0; i &lt; limit; ++i)
<span class="line-modified">483         out.print(&quot;\t&quot;, comma, &quot;[&quot;, i, &quot;] &quot;, m_log[i], &quot;\n&quot;);</span>
484     out.print(&quot;]}&quot;);
485 }
486 
<span class="line-modified">487 JSArray* ShadowChicken::functionsOnStack(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
488 {
<span class="line-modified">489     VM&amp; vm = globalObject-&gt;vm();</span>
490     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">491     JSArray* result = constructEmptyArray(globalObject, nullptr);</span>
492     RETURN_IF_EXCEPTION(scope, nullptr);
493 
494     iterate(
<span class="line-modified">495         vm, callFrame,</span>
496         [&amp;] (const Frame&amp; frame) -&gt; bool {
<span class="line-modified">497             result-&gt;push(globalObject, frame.callee);</span>
498             scope.releaseAssertNoException(); // This function is only called from tests.
499             return true;
500         });
501 
502     return result;
503 }
504 
505 } // namespace JSC
506 
</pre>
</td>
</tr>
</table>
<center><a href="Register.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ShadowChicken.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
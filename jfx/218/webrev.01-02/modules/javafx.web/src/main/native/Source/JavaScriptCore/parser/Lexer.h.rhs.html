<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Lexer.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2002-2019 Apple Inc. All rights reserved.
  4  *  Copyright (C) 2010 Zoltan Herczeg (zherczeg@inf.u-szeged.hu)
  5  *
  6  *  This library is free software; you can redistribute it and/or
  7  *  modify it under the terms of the GNU Library General Public
  8  *  License as published by the Free Software Foundation; either
  9  *  version 2 of the License, or (at your option) any later version.
 10  *
 11  *  This library is distributed in the hope that it will be useful,
 12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  *  Library General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Library General Public License
 17  *  along with this library; see the file COPYING.LIB.  If not, write to
 18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  *  Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #pragma once
 24 
 25 #include &quot;Lookup.h&quot;
 26 #include &quot;ParserArena.h&quot;
 27 #include &quot;ParserModes.h&quot;
 28 #include &quot;ParserTokens.h&quot;
 29 #include &quot;SourceCode.h&quot;
 30 #include &lt;wtf/ASCIICType.h&gt;
 31 #include &lt;wtf/Vector.h&gt;
 32 
 33 namespace JSC {
 34 
<a name="1" id="anc1"></a><span class="line-modified"> 35 enum class LexerFlags : uint8_t {</span>
<span class="line-modified"> 36     IgnoreReservedWords = 1 &lt;&lt; 0,</span>
<span class="line-modified"> 37     DontBuildStrings = 1 &lt;&lt; 1,</span>
<span class="line-modified"> 38     DontBuildKeywords = 1 &lt;&lt; 2</span>
 39 };
 40 
 41 enum class LexerEscapeParseMode { Template, String };
 42 
 43 struct ParsedUnicodeEscapeValue;
 44 
 45 bool isLexerKeyword(const Identifier&amp;);
 46 
 47 template &lt;typename T&gt;
 48 class Lexer {
 49     WTF_MAKE_NONCOPYABLE(Lexer);
 50     WTF_MAKE_FAST_ALLOCATED;
 51 
 52 public:
 53     Lexer(VM&amp;, JSParserBuiltinMode, JSParserScriptMode);
 54     ~Lexer();
 55 
 56     // Character manipulation functions.
 57     static bool isWhiteSpace(T character);
 58     static bool isLineTerminator(T character);
 59     static unsigned char convertHex(int c1, int c2);
 60     static UChar convertUnicode(int c1, int c2, int c3, int c4);
 61 
 62     // Functions to set up parsing.
 63     void setCode(const SourceCode&amp;, ParserArena*);
 64     void setIsReparsingFunction() { m_isReparsingFunction = true; }
 65     bool isReparsingFunction() const { return m_isReparsingFunction; }
 66 
<a name="2" id="anc2"></a><span class="line-modified"> 67     JSTokenType lex(JSToken*, OptionSet&lt;LexerFlags&gt;, bool strictMode);</span>
<span class="line-modified"> 68     JSTokenType lexWithoutClearingLineTerminator(JSToken*, OptionSet&lt;LexerFlags&gt;, bool strictMode);</span>
 69     bool nextTokenIsColon();
 70     int lineNumber() const { return m_lineNumber; }
 71     ALWAYS_INLINE int currentOffset() const { return offsetFromSourcePtr(m_code); }
 72     ALWAYS_INLINE int currentLineStartOffset() const { return offsetFromSourcePtr(m_lineStart); }
 73     ALWAYS_INLINE JSTextPosition currentPosition() const
 74     {
 75         return JSTextPosition(m_lineNumber, currentOffset(), currentLineStartOffset());
 76     }
 77     JSTextPosition positionBeforeLastNewline() const { return m_positionBeforeLastNewline; }
 78     JSTokenLocation lastTokenLocation() const { return m_lastTokenLocation; }
 79     void setLastLineNumber(int lastLineNumber) { m_lastLineNumber = lastLineNumber; }
 80     int lastLineNumber() const { return m_lastLineNumber; }
 81     bool hasLineTerminatorBeforeToken() const { return m_hasLineTerminatorBeforeToken; }
 82     JSTokenType scanRegExp(JSToken*, UChar patternPrefix = 0);
 83     enum class RawStringsBuildMode { BuildRawStrings, DontBuildRawStrings };
 84     JSTokenType scanTemplateString(JSToken*, RawStringsBuildMode);
 85 
 86     // Functions for use after parsing.
 87     bool sawError() const { return m_error; }
 88     void setSawError(bool sawError) { m_error = sawError; }
 89     String getErrorMessage() const { return m_lexErrorMessage; }
 90     void setErrorMessage(const String&amp; errorMessage) { m_lexErrorMessage = errorMessage; }
 91     String sourceURLDirective() const { return m_sourceURLDirective; }
 92     String sourceMappingURLDirective() const { return m_sourceMappingURLDirective; }
 93     void clear();
 94     void setOffset(int offset, int lineStartOffset)
 95     {
 96         m_error = 0;
 97         m_lexErrorMessage = String();
 98 
 99         m_code = sourcePtrFromOffset(offset);
100         m_lineStart = sourcePtrFromOffset(lineStartOffset);
101         ASSERT(currentOffset() &gt;= currentLineStartOffset());
102 
103         m_buffer8.shrink(0);
104         m_buffer16.shrink(0);
105         if (LIKELY(m_code &lt; m_codeEnd))
106             m_current = *m_code;
107         else
108             m_current = 0;
109     }
110     void setLineNumber(int line)
111     {
<a name="3" id="anc3"></a><span class="line-added">112         ASSERT(line &gt;= 0);</span>
113         m_lineNumber = line;
114     }
115     void setHasLineTerminatorBeforeToken(bool terminator)
116     {
117         m_hasLineTerminatorBeforeToken = terminator;
118     }
119 
<a name="4" id="anc4"></a><span class="line-modified">120     JSTokenType lexExpectIdentifier(JSToken*, OptionSet&lt;LexerFlags&gt;, bool strictMode);</span>
121 
122     ALWAYS_INLINE StringView getToken(const JSToken&amp; token)
123     {
124         SourceProvider* sourceProvider = m_source-&gt;provider();
125         ASSERT_WITH_MESSAGE(token.m_location.startOffset &lt;= token.m_location.endOffset, &quot;Calling this function with the baked token.&quot;);
126         return sourceProvider-&gt;getRange(token.m_location.startOffset, token.m_location.endOffset);
127     }
128 
129 private:
130     void record8(int);
131     void append8(const T*, size_t);
132     void record16(int);
133     void record16(T);
134     void recordUnicodeCodePoint(UChar32);
135     void append16(const LChar*, size_t);
136     void append16(const UChar* characters, size_t length) { m_buffer16.append(characters, length); }
137 
138     ALWAYS_INLINE void shift();
139     ALWAYS_INLINE bool atEnd() const;
140     ALWAYS_INLINE T peek(int offset) const;
141 
142     ParsedUnicodeEscapeValue parseUnicodeEscape();
143     void shiftLineTerminator();
144 
145     ALWAYS_INLINE int offsetFromSourcePtr(const T* ptr) const { return ptr - m_codeStart; }
146     ALWAYS_INLINE const T* sourcePtrFromOffset(int offset) const { return m_codeStart + offset; }
147 
148     String invalidCharacterMessage() const;
149     ALWAYS_INLINE const T* currentSourcePtr() const;
150     ALWAYS_INLINE void setOffsetFromSourcePtr(const T* sourcePtr, unsigned lineStartOffset) { setOffset(offsetFromSourcePtr(sourcePtr), lineStartOffset); }
151 
152     ALWAYS_INLINE void setCodeStart(const StringView&amp;);
153 
154     ALWAYS_INLINE const Identifier* makeIdentifier(const LChar* characters, size_t length);
155     ALWAYS_INLINE const Identifier* makeIdentifier(const UChar* characters, size_t length);
156     ALWAYS_INLINE const Identifier* makeLCharIdentifier(const LChar* characters, size_t length);
157     ALWAYS_INLINE const Identifier* makeLCharIdentifier(const UChar* characters, size_t length);
158     ALWAYS_INLINE const Identifier* makeRightSizedIdentifier(const UChar* characters, size_t length, UChar orAllChars);
159     ALWAYS_INLINE const Identifier* makeIdentifierLCharFromUChar(const UChar* characters, size_t length);
160     ALWAYS_INLINE const Identifier* makeEmptyIdentifier();
161 
162     ALWAYS_INLINE bool lastTokenWasRestrKeyword() const;
163 
164     ALWAYS_INLINE void skipWhitespace();
165 
166     template &lt;int shiftAmount&gt; void internalShift();
167     template &lt;bool shouldCreateIdentifier&gt; ALWAYS_INLINE JSTokenType parseKeyword(JSTokenData*);
<a name="5" id="anc5"></a><span class="line-modified">168     template &lt;bool shouldBuildIdentifiers&gt; ALWAYS_INLINE JSTokenType parseIdentifier(JSTokenData*, OptionSet&lt;LexerFlags&gt;, bool strictMode);</span>
<span class="line-modified">169     template &lt;bool shouldBuildIdentifiers&gt; NEVER_INLINE JSTokenType parseIdentifierSlowCase(JSTokenData*, OptionSet&lt;LexerFlags&gt;, bool strictMode);</span>
170     enum StringParseResult {
171         StringParsedSuccessfully,
172         StringUnterminated,
173         StringCannotBeParsed
174     };
175     template &lt;bool shouldBuildStrings&gt; ALWAYS_INLINE StringParseResult parseString(JSTokenData*, bool strictMode);
176     template &lt;bool shouldBuildStrings&gt; NEVER_INLINE StringParseResult parseStringSlowCase(JSTokenData*, bool strictMode);
177 
178 
179     template &lt;bool shouldBuildStrings, LexerEscapeParseMode escapeParseMode&gt; ALWAYS_INLINE StringParseResult parseComplexEscape(bool strictMode, T stringQuoteCharacter);
180     ALWAYS_INLINE StringParseResult parseTemplateLiteral(JSTokenData*, RawStringsBuildMode);
181 
182     using NumberParseResult = Variant&lt;double, const Identifier*&gt;;
183     ALWAYS_INLINE Optional&lt;NumberParseResult&gt; parseHex();
184     ALWAYS_INLINE Optional&lt;NumberParseResult&gt; parseBinary();
185     ALWAYS_INLINE Optional&lt;NumberParseResult&gt; parseOctal();
186     ALWAYS_INLINE Optional&lt;NumberParseResult&gt; parseDecimal();
187     ALWAYS_INLINE bool parseNumberAfterDecimalPoint();
188     ALWAYS_INLINE bool parseNumberAfterExponentIndicator();
189     ALWAYS_INLINE bool parseMultilineComment();
190 
191     ALWAYS_INLINE void parseCommentDirective();
192     ALWAYS_INLINE String parseCommentDirectiveValue();
193 
194     template &lt;unsigned length&gt;
195     ALWAYS_INLINE bool consume(const char (&amp;input)[length]);
196 
197     void fillTokenInfo(JSToken*, JSTokenType, int lineNumber, int endOffset, int lineStartOffset, JSTextPosition endPosition);
198 
<a name="6" id="anc6"></a><span class="line-modified">199     static constexpr size_t initialReadBufferCapacity = 32;</span>
200 
201     int m_lineNumber;
202     int m_lastLineNumber;
203 
204     Vector&lt;LChar&gt; m_buffer8;
205     Vector&lt;UChar&gt; m_buffer16;
206     Vector&lt;UChar&gt; m_bufferForRawTemplateString16;
207     bool m_hasLineTerminatorBeforeToken;
208     int m_lastToken;
209 
210     const SourceCode* m_source;
211     unsigned m_sourceOffset;
212     const T* m_code;
213     const T* m_codeStart;
214     const T* m_codeEnd;
215     const T* m_codeStartPlusOffset;
216     const T* m_lineStart;
217     JSTextPosition m_positionBeforeLastNewline;
218     JSTokenLocation m_lastTokenLocation;
219     bool m_isReparsingFunction;
220     bool m_atLineStart;
221     bool m_error;
222     String m_lexErrorMessage;
223 
224     String m_sourceURLDirective;
225     String m_sourceMappingURLDirective;
226 
227     T m_current;
228 
229     IdentifierArena* m_arena;
230 
231     VM&amp; m_vm;
232     bool m_parsingBuiltinFunction;
233     JSParserScriptMode m_scriptMode;
234 };
235 
236 template &lt;&gt;
237 ALWAYS_INLINE bool Lexer&lt;LChar&gt;::isWhiteSpace(LChar ch)
238 {
239     return ch == &#39; &#39; || ch == &#39;\t&#39; || ch == 0xB || ch == 0xC || ch == 0xA0;
240 }
241 
242 template &lt;&gt;
243 ALWAYS_INLINE bool Lexer&lt;UChar&gt;::isWhiteSpace(UChar ch)
244 {
245     return isLatin1(ch) ? Lexer&lt;LChar&gt;::isWhiteSpace(static_cast&lt;LChar&gt;(ch)) : (u_charType(ch) == U_SPACE_SEPARATOR || ch == 0xFEFF);
246 }
247 
248 template &lt;&gt;
249 ALWAYS_INLINE bool Lexer&lt;LChar&gt;::isLineTerminator(LChar ch)
250 {
251     return ch == &#39;\r&#39; || ch == &#39;\n&#39;;
252 }
253 
254 template &lt;&gt;
255 ALWAYS_INLINE bool Lexer&lt;UChar&gt;::isLineTerminator(UChar ch)
256 {
257     return ch == &#39;\r&#39; || ch == &#39;\n&#39; || (ch &amp; ~1) == 0x2028;
258 }
259 
260 template &lt;typename T&gt;
261 inline unsigned char Lexer&lt;T&gt;::convertHex(int c1, int c2)
262 {
263     return (toASCIIHexValue(c1) &lt;&lt; 4) | toASCIIHexValue(c2);
264 }
265 
266 template &lt;typename T&gt;
267 inline UChar Lexer&lt;T&gt;::convertUnicode(int c1, int c2, int c3, int c4)
268 {
269     return (convertHex(c1, c2) &lt;&lt; 8) | convertHex(c3, c4);
270 }
271 
272 template &lt;typename T&gt;
273 ALWAYS_INLINE const Identifier* Lexer&lt;T&gt;::makeIdentifier(const LChar* characters, size_t length)
274 {
275     return &amp;m_arena-&gt;makeIdentifier(m_vm, characters, length);
276 }
277 
278 template &lt;typename T&gt;
279 ALWAYS_INLINE const Identifier* Lexer&lt;T&gt;::makeIdentifier(const UChar* characters, size_t length)
280 {
281     return &amp;m_arena-&gt;makeIdentifier(m_vm, characters, length);
282 }
283 
284 template &lt;&gt;
285 ALWAYS_INLINE const Identifier* Lexer&lt;LChar&gt;::makeRightSizedIdentifier(const UChar* characters, size_t length, UChar)
286 {
287     return &amp;m_arena-&gt;makeIdentifierLCharFromUChar(m_vm, characters, length);
288 }
289 
290 template &lt;&gt;
291 ALWAYS_INLINE const Identifier* Lexer&lt;UChar&gt;::makeRightSizedIdentifier(const UChar* characters, size_t length, UChar orAllChars)
292 {
293     if (!(orAllChars &amp; ~0xff))
294         return &amp;m_arena-&gt;makeIdentifierLCharFromUChar(m_vm, characters, length);
295 
296     return &amp;m_arena-&gt;makeIdentifier(m_vm, characters, length);
297 }
298 
299 template &lt;typename T&gt;
300 ALWAYS_INLINE const Identifier* Lexer&lt;T&gt;::makeEmptyIdentifier()
301 {
302     return &amp;m_arena-&gt;makeEmptyIdentifier(m_vm);
303 }
304 
305 template &lt;&gt;
306 ALWAYS_INLINE void Lexer&lt;LChar&gt;::setCodeStart(const StringView&amp; sourceString)
307 {
308     ASSERT(sourceString.is8Bit());
309     m_codeStart = sourceString.characters8();
310 }
311 
312 template &lt;&gt;
313 ALWAYS_INLINE void Lexer&lt;UChar&gt;::setCodeStart(const StringView&amp; sourceString)
314 {
315     ASSERT(!sourceString.is8Bit());
316     m_codeStart = sourceString.characters16();
317 }
318 
319 template &lt;typename T&gt;
320 ALWAYS_INLINE const Identifier* Lexer&lt;T&gt;::makeIdentifierLCharFromUChar(const UChar* characters, size_t length)
321 {
322     return &amp;m_arena-&gt;makeIdentifierLCharFromUChar(m_vm, characters, length);
323 }
324 
325 template &lt;typename T&gt;
326 ALWAYS_INLINE const Identifier* Lexer&lt;T&gt;::makeLCharIdentifier(const LChar* characters, size_t length)
327 {
328     return &amp;m_arena-&gt;makeIdentifier(m_vm, characters, length);
329 }
330 
331 template &lt;typename T&gt;
332 ALWAYS_INLINE const Identifier* Lexer&lt;T&gt;::makeLCharIdentifier(const UChar* characters, size_t length)
333 {
334     return &amp;m_arena-&gt;makeIdentifierLCharFromUChar(m_vm, characters, length);
335 }
336 
<a name="7" id="anc7"></a><span class="line-modified">337 #if ASSERT_ENABLED</span>


338 bool isSafeBuiltinIdentifier(VM&amp;, const Identifier*);
<a name="8" id="anc8"></a><span class="line-modified">339 #else</span>
<span class="line-added">340 ALWAYS_INLINE bool isSafeBuiltinIdentifier(VM&amp;, const Identifier*) { return true; }</span>
<span class="line-added">341 #endif // ASSERT_ENABLED</span>
342 
343 template &lt;typename T&gt;
<a name="9" id="anc9"></a><span class="line-modified">344 ALWAYS_INLINE JSTokenType Lexer&lt;T&gt;::lexExpectIdentifier(JSToken* tokenRecord, OptionSet&lt;LexerFlags&gt; lexerFlags, bool strictMode)</span>
345 {
346     JSTokenData* tokenData = &amp;tokenRecord-&gt;m_data;
347     JSTokenLocation* tokenLocation = &amp;tokenRecord-&gt;m_location;
<a name="10" id="anc10"></a><span class="line-modified">348     ASSERT(lexerFlags.contains(LexerFlags::IgnoreReservedWords));</span>
349     const T* start = m_code;
350     const T* ptr = start;
351     const T* end = m_codeEnd;
352     JSTextPosition startPosition = currentPosition();
353     if (ptr &gt;= end) {
354         ASSERT(ptr == end);
355         goto slowCase;
356     }
357     if (!WTF::isASCIIAlpha(*ptr))
358         goto slowCase;
359     ++ptr;
360     while (ptr &lt; end) {
361         if (!WTF::isASCIIAlphanumeric(*ptr))
362             break;
363         ++ptr;
364     }
365 
366     // Here&#39;s the shift
367     if (ptr &lt; end) {
368         if ((!WTF::isASCII(*ptr)) || (*ptr == &#39;\\&#39;) || (*ptr == &#39;_&#39;) || (*ptr == &#39;$&#39;))
369             goto slowCase;
370         m_current = *ptr;
371     } else
372         m_current = 0;
373 
374     m_code = ptr;
375     ASSERT(currentOffset() &gt;= currentLineStartOffset());
376 
377     // Create the identifier if needed
<a name="11" id="anc11"></a><span class="line-modified">378     if (lexerFlags.contains(LexerFlags::DontBuildKeywords)</span>
<span class="line-modified">379 #if ASSERT_ENABLED</span>
380         &amp;&amp; !m_parsingBuiltinFunction
381 #endif
382         )
383         tokenData-&gt;ident = 0;
384     else
385         tokenData-&gt;ident = makeLCharIdentifier(start, ptr - start);
386 
387     tokenLocation-&gt;line = m_lineNumber;
388     tokenLocation-&gt;lineStartOffset = currentLineStartOffset();
389     tokenLocation-&gt;startOffset = offsetFromSourcePtr(start);
390     tokenLocation-&gt;endOffset = currentOffset();
391     ASSERT(tokenLocation-&gt;startOffset &gt;= tokenLocation-&gt;lineStartOffset);
392     tokenRecord-&gt;m_startPosition = startPosition;
393     tokenRecord-&gt;m_endPosition = currentPosition();
<a name="12" id="anc12"></a><span class="line-modified">394 #if ASSERT_ENABLED</span>
395     if (m_parsingBuiltinFunction) {
396         if (!isSafeBuiltinIdentifier(m_vm, tokenData-&gt;ident))
397             return ERRORTOK;
398     }
399 #endif
400 
401     m_lastToken = IDENT;
402     return IDENT;
403 
404 slowCase:
405     return lex(tokenRecord, lexerFlags, strictMode);
406 }
407 
408 template &lt;typename T&gt;
<a name="13" id="anc13"></a><span class="line-modified">409 ALWAYS_INLINE JSTokenType Lexer&lt;T&gt;::lex(JSToken* tokenRecord, OptionSet&lt;LexerFlags&gt; lexerFlags, bool strictMode)</span>
410 {
411     m_hasLineTerminatorBeforeToken = false;
412     return lexWithoutClearingLineTerminator(tokenRecord, lexerFlags, strictMode);
413 }
414 
415 } // namespace JSC
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
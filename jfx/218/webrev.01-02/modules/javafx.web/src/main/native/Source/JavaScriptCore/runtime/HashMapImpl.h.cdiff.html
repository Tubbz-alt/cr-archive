<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/HashMapImpl.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GlobalExecutable.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Identifier.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/HashMapImpl.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 51,12 ***</span>
      WriteBarrier&lt;Unknown&gt; key;
      WriteBarrier&lt;Unknown&gt; value;
  };
  
  template &lt;typename Data&gt;
<span class="line-modified">! class HashMapBucket : public JSCell {</span>
<span class="line-modified">!     typedef JSCell Base;</span>
  
      template &lt;typename T = Data&gt;
      static typename std::enable_if&lt;std::is_same&lt;T, HashMapBucketDataKey&gt;::value, Structure*&gt;::type selectStructure(VM&amp; vm)
      {
          return vm.hashMapBucketSetStructure.get();
<span class="line-new-header">--- 51,12 ---</span>
      WriteBarrier&lt;Unknown&gt; key;
      WriteBarrier&lt;Unknown&gt; value;
  };
  
  template &lt;typename Data&gt;
<span class="line-modified">! class HashMapBucket final : public JSCell {</span>
<span class="line-modified">!     using Base = JSCell;</span>
  
      template &lt;typename T = Data&gt;
      static typename std::enable_if&lt;std::is_same&lt;T, HashMapBucketDataKey&gt;::value, Structure*&gt;::type selectStructure(VM&amp; vm)
      {
          return vm.hashMapBucketSetStructure.get();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 70,20 ***</span>
  
  public:
      static const HashTableType Type = Data::Type;
      static const ClassInfo s_info; // This is never accessed directly, since that would break linkage on some compilers.
  
  
      static const ClassInfo* info()
      {
<span class="line-modified">!         switch (Type) {</span>
<span class="line-removed">-         case HashTableType::Key:</span>
              return getHashMapBucketKeyClassInfo();
<span class="line-modified">!         case HashTableType::KeyValue:</span>
              return getHashMapBucketKeyValueClassInfo();
<span class="line-removed">-         }</span>
<span class="line-removed">-         RELEASE_ASSERT_NOT_REACHED();</span>
      }
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
          return Structure::create(vm, globalObject, prototype, TypeInfo(CellType, StructureFlags), info());
<span class="line-new-header">--- 70,25 ---</span>
  
  public:
      static const HashTableType Type = Data::Type;
      static const ClassInfo s_info; // This is never accessed directly, since that would break linkage on some compilers.
  
<span class="line-added">+     template&lt;typename CellType, SubspaceAccess mode&gt;</span>
<span class="line-added">+     static IsoSubspace* subspaceFor(VM&amp; vm)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if constexpr (Type == HashTableType::Key)</span>
<span class="line-added">+             return vm.setBucketSpace&lt;mode&gt;();</span>
<span class="line-added">+         else</span>
<span class="line-added">+             return vm.mapBucketSpace&lt;mode&gt;();</span>
<span class="line-added">+     }</span>
  
      static const ClassInfo* info()
      {
<span class="line-modified">!         if constexpr (Type == HashTableType::Key)</span>
              return getHashMapBucketKeyClassInfo();
<span class="line-modified">!         else</span>
              return getHashMapBucketKeyValueClassInfo();
      }
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
          return Structure::create(vm, globalObject, prototype, TypeInfo(CellType, StructureFlags), info());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 202,17 ***</span>
      ALWAYS_INLINE BucketType** buffer() const
      {
          return bitwise_cast&lt;BucketType**&gt;(this);
      }
  
<span class="line-modified">!     static HashMapBuffer* create(ExecState* exec, VM&amp; vm, JSCell*, uint32_t capacity)</span>
      {
          auto scope = DECLARE_THROW_SCOPE(vm);
          size_t allocationSize = HashMapBuffer::allocationSize(capacity);
          void* data = vm.jsValueGigacageAuxiliarySpace.allocateNonVirtual(vm, allocationSize, nullptr, AllocationFailureMode::ReturnNull);
          if (!data) {
<span class="line-modified">!             throwOutOfMemoryError(exec, scope);</span>
              return nullptr;
          }
  
          HashMapBuffer* buffer = static_cast&lt;HashMapBuffer*&gt;(data);
          buffer-&gt;reset(capacity);
<span class="line-new-header">--- 207,17 ---</span>
      ALWAYS_INLINE BucketType** buffer() const
      {
          return bitwise_cast&lt;BucketType**&gt;(this);
      }
  
<span class="line-modified">!     static HashMapBuffer* create(JSGlobalObject* globalObject, VM&amp; vm, JSCell*, uint32_t capacity)</span>
      {
          auto scope = DECLARE_THROW_SCOPE(vm);
          size_t allocationSize = HashMapBuffer::allocationSize(capacity);
          void* data = vm.jsValueGigacageAuxiliarySpace.allocateNonVirtual(vm, allocationSize, nullptr, AllocationFailureMode::ReturnNull);
          if (!data) {
<span class="line-modified">!             throwOutOfMemoryError(globalObject, scope);</span>
              return nullptr;
          }
  
          HashMapBuffer* buffer = static_cast&lt;HashMapBuffer*&gt;(data);
          buffer-&gt;reset(capacity);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 223,17 ***</span>
      {
          memset(this, -1, allocationSize(capacity));
      }
  };
  
<span class="line-modified">! ALWAYS_INLINE static bool areKeysEqual(ExecState* exec, JSValue a, JSValue b)</span>
  {
      // We want +0 and -0 to be compared to true here. sameValue() itself doesn&#39;t
      // guarantee that, however, we normalize all keys before comparing and storing
      // them in the map. The normalization will convert -0.0 and 0.0 to the integer
      // representation for 0.
<span class="line-modified">!     return sameValue(exec, a, b);</span>
  }
  
  // Note that normalization is inlined in DFG&#39;s NormalizeMapKey.
  // Keep in sync with the implementation of DFG and FTL normalization.
  ALWAYS_INLINE JSValue normalizeMapKey(JSValue key)
<span class="line-new-header">--- 228,17 ---</span>
      {
          memset(this, -1, allocationSize(capacity));
      }
  };
  
<span class="line-modified">! ALWAYS_INLINE static bool areKeysEqual(JSGlobalObject* globalObject, JSValue a, JSValue b)</span>
  {
      // We want +0 and -0 to be compared to true here. sameValue() itself doesn&#39;t
      // guarantee that, however, we normalize all keys before comparing and storing
      // them in the map. The normalization will convert -0.0 and 0.0 to the integer
      // representation for 0.
<span class="line-modified">!     return sameValue(globalObject, a, b);</span>
  }
  
  // Note that normalization is inlined in DFG&#39;s NormalizeMapKey.
  // Keep in sync with the implementation of DFG and FTL normalization.
  ALWAYS_INLINE JSValue normalizeMapKey(JSValue key)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 269,17 ***</span>
      key += ~(key &lt;&lt; 27);
      key ^= (key &gt;&gt; 31);
      return static_cast&lt;unsigned&gt;(key);
  }
  
<span class="line-modified">! ALWAYS_INLINE uint32_t jsMapHash(ExecState* exec, VM&amp; vm, JSValue value)</span>
  {
      ASSERT_WITH_MESSAGE(normalizeMapKey(value) == value, &quot;We expect normalized values flowing into this function.&quot;);
  
      if (value.isString()) {
          auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!         const String&amp; wtfString = asString(value)-&gt;value(exec);</span>
          RETURN_IF_EXCEPTION(scope, UINT_MAX);
          return wtfString.impl()-&gt;hash();
      }
  
      return wangsInt64Hash(JSValue::encode(value));
<span class="line-new-header">--- 274,17 ---</span>
      key += ~(key &lt;&lt; 27);
      key ^= (key &gt;&gt; 31);
      return static_cast&lt;unsigned&gt;(key);
  }
  
<span class="line-modified">! ALWAYS_INLINE uint32_t jsMapHash(JSGlobalObject* globalObject, VM&amp; vm, JSValue value)</span>
  {
      ASSERT_WITH_MESSAGE(normalizeMapKey(value) == value, &quot;We expect normalized values flowing into this function.&quot;);
  
      if (value.isString()) {
          auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">!         const String&amp; wtfString = asString(value)-&gt;value(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, UINT_MAX);
          return wtfString.impl()-&gt;hash();
      }
  
      return wangsInt64Hash(JSValue::encode(value));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 370,42 ***</span>
      ALWAYS_INLINE HashMapBucketType** buffer() const
      {
          return m_buffer-&gt;buffer();
      }
  
<span class="line-modified">!     void finishCreation(ExecState* exec, VM&amp; vm)</span>
      {
          ASSERT_WITH_MESSAGE(HashMapBucket&lt;HashMapBucketDataKey&gt;::offsetOfKey() == HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey(), &quot;We assume this to be true in the DFG and FTL JIT.&quot;);
  
          auto scope = DECLARE_THROW_SCOPE(vm);
          Base::finishCreation(vm);
  
<span class="line-modified">!         makeAndSetNewBuffer(exec, vm);</span>
          RETURN_IF_EXCEPTION(scope, void());
  
<span class="line-modified">!         setUpHeadAndTail(exec, vm);</span>
      }
  
<span class="line-modified">!     void finishCreation(ExecState* exec, VM&amp; vm, HashMapImpl* base)</span>
      {
          auto scope = DECLARE_THROW_SCOPE(vm);
          Base::finishCreation(vm);
  
          // This size should be the same to the case when you clone the map by calling add() repeatedly.
          uint32_t capacity = ((Checked&lt;uint32_t&gt;(base-&gt;m_keyCount) * 2) + 1).unsafeGet();
          RELEASE_ASSERT(capacity &lt;= (1U &lt;&lt; 31));
          capacity = std::max&lt;uint32_t&gt;(WTF::roundUpToPowerOfTwo(capacity), 4U);
          m_capacity = capacity;
<span class="line-modified">!         makeAndSetNewBuffer(exec, vm);</span>
          RETURN_IF_EXCEPTION(scope, void());
  
<span class="line-modified">!         setUpHeadAndTail(exec, vm);</span>
  
          HashMapBucketType* bucket = base-&gt;m_head.get()-&gt;next();
          while (bucket) {
              if (!bucket-&gt;deleted()) {
<span class="line-modified">!                 addNormalizedNonExistingForCloning(exec, bucket-&gt;key(), HashMapBucketType::extractValue(*bucket));</span>
                  RETURN_IF_EXCEPTION(scope, void());
              }
              bucket = bucket-&gt;next();
          }
          checkConsistency();
<span class="line-new-header">--- 375,42 ---</span>
      ALWAYS_INLINE HashMapBucketType** buffer() const
      {
          return m_buffer-&gt;buffer();
      }
  
<span class="line-modified">!     void finishCreation(JSGlobalObject* globalObject, VM&amp; vm)</span>
      {
          ASSERT_WITH_MESSAGE(HashMapBucket&lt;HashMapBucketDataKey&gt;::offsetOfKey() == HashMapBucket&lt;HashMapBucketDataKeyValue&gt;::offsetOfKey(), &quot;We assume this to be true in the DFG and FTL JIT.&quot;);
  
          auto scope = DECLARE_THROW_SCOPE(vm);
          Base::finishCreation(vm);
  
<span class="line-modified">!         makeAndSetNewBuffer(globalObject, vm);</span>
          RETURN_IF_EXCEPTION(scope, void());
  
<span class="line-modified">!         setUpHeadAndTail(globalObject, vm);</span>
      }
  
<span class="line-modified">!     void finishCreation(JSGlobalObject* globalObject, VM&amp; vm, HashMapImpl* base)</span>
      {
          auto scope = DECLARE_THROW_SCOPE(vm);
          Base::finishCreation(vm);
  
          // This size should be the same to the case when you clone the map by calling add() repeatedly.
          uint32_t capacity = ((Checked&lt;uint32_t&gt;(base-&gt;m_keyCount) * 2) + 1).unsafeGet();
          RELEASE_ASSERT(capacity &lt;= (1U &lt;&lt; 31));
          capacity = std::max&lt;uint32_t&gt;(WTF::roundUpToPowerOfTwo(capacity), 4U);
          m_capacity = capacity;
<span class="line-modified">!         makeAndSetNewBuffer(globalObject, vm);</span>
          RETURN_IF_EXCEPTION(scope, void());
  
<span class="line-modified">!         setUpHeadAndTail(globalObject, vm);</span>
  
          HashMapBucketType* bucket = base-&gt;m_head.get()-&gt;next();
          while (bucket) {
              if (!bucket-&gt;deleted()) {
<span class="line-modified">!                 addNormalizedNonExistingForCloning(globalObject, bucket-&gt;key(), HashMapBucketType::extractValue(*bucket));</span>
                  RETURN_IF_EXCEPTION(scope, void());
              }
              bucket = bucket-&gt;next();
          }
          checkConsistency();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 429,69 ***</span>
      static ALWAYS_INLINE bool isDeleted(HashMapBucketType* bucket)
      {
          return bucket == deletedValue();
      }
  
<span class="line-modified">!     ALWAYS_INLINE HashMapBucketType** findBucket(ExecState* exec, JSValue key)</span>
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
          key = normalizeMapKey(key);
<span class="line-modified">!         uint32_t hash = jsMapHash(exec, vm, key);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!         return findBucket(exec, key, hash);</span>
      }
  
<span class="line-modified">!     ALWAYS_INLINE HashMapBucketType** findBucket(ExecState* exec, JSValue key, uint32_t hash)</span>
      {
          ASSERT_WITH_MESSAGE(normalizeMapKey(key) == key, &quot;We expect normalized values flowing into this function.&quot;);
<span class="line-modified">!         return findBucketAlreadyHashedAndNormalized(exec, key, hash);</span>
      }
  
      template &lt;typename T = HashMapBucketType&gt;
<span class="line-modified">!     ALWAYS_INLINE typename std::enable_if&lt;std::is_same&lt;T, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;&gt;::value, JSValue&gt;::type get(ExecState* exec, JSValue key)</span>
      {
<span class="line-modified">!         if (HashMapBucketType** bucket = findBucket(exec, key))</span>
              return (*bucket)-&gt;value();
          return jsUndefined();
      }
  
<span class="line-modified">!     ALWAYS_INLINE bool has(ExecState* exec, JSValue key)</span>
      {
<span class="line-modified">!         return !!findBucket(exec, key);</span>
      }
  
<span class="line-modified">!     ALWAYS_INLINE void add(ExecState* exec, JSValue key, JSValue value = JSValue())</span>
      {
          key = normalizeMapKey(key);
<span class="line-modified">!         addNormalizedInternal(exec, key, value, [&amp;] (HashMapBucketType* bucket) {</span>
<span class="line-modified">!             return !isDeleted(bucket) &amp;&amp; areKeysEqual(exec, key, bucket-&gt;key());</span>
          });
          if (shouldRehashAfterAdd())
<span class="line-modified">!             rehash(exec);</span>
      }
  
<span class="line-modified">!     ALWAYS_INLINE HashMapBucketType* addNormalized(ExecState* exec, JSValue key, JSValue value, uint32_t hash)</span>
      {
          ASSERT_WITH_MESSAGE(normalizeMapKey(key) == key, &quot;We expect normalized values flowing into this function.&quot;);
<span class="line-modified">!         ASSERT_WITH_MESSAGE(jsMapHash(exec, exec-&gt;vm(), key) == hash, &quot;We expect hash value is what we expect.&quot;);</span>
  
<span class="line-modified">!         auto* bucket = addNormalizedInternal(exec-&gt;vm(), key, value, hash, [&amp;] (HashMapBucketType* bucket) {</span>
<span class="line-modified">!             return !isDeleted(bucket) &amp;&amp; areKeysEqual(exec, key, bucket-&gt;key());</span>
          });
          if (shouldRehashAfterAdd())
<span class="line-modified">!             rehash(exec);</span>
          return bucket;
      }
  
<span class="line-modified">!     ALWAYS_INLINE bool remove(ExecState* exec, JSValue key)</span>
      {
<span class="line-modified">!         HashMapBucketType** bucket = findBucket(exec, key);</span>
          if (!bucket)
              return false;
  
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          HashMapBucketType* impl = *bucket;
          impl-&gt;next()-&gt;setPrev(vm, impl-&gt;prev());
          impl-&gt;prev()-&gt;setNext(vm, impl-&gt;next());
          impl-&gt;makeDeleted(vm);
  
<span class="line-new-header">--- 434,69 ---</span>
      static ALWAYS_INLINE bool isDeleted(HashMapBucketType* bucket)
      {
          return bucket == deletedValue();
      }
  
<span class="line-modified">!     ALWAYS_INLINE HashMapBucketType** findBucket(JSGlobalObject* globalObject, JSValue key)</span>
      {
<span class="line-modified">!         VM&amp; vm = getVM(globalObject);</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
          key = normalizeMapKey(key);
<span class="line-modified">!         uint32_t hash = jsMapHash(globalObject, vm, key);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!         return findBucket(globalObject, key, hash);</span>
      }
  
<span class="line-modified">!     ALWAYS_INLINE HashMapBucketType** findBucket(JSGlobalObject* globalObject, JSValue key, uint32_t hash)</span>
      {
          ASSERT_WITH_MESSAGE(normalizeMapKey(key) == key, &quot;We expect normalized values flowing into this function.&quot;);
<span class="line-modified">!         return findBucketAlreadyHashedAndNormalized(globalObject, key, hash);</span>
      }
  
      template &lt;typename T = HashMapBucketType&gt;
<span class="line-modified">!     ALWAYS_INLINE typename std::enable_if&lt;std::is_same&lt;T, HashMapBucket&lt;HashMapBucketDataKeyValue&gt;&gt;::value, JSValue&gt;::type get(JSGlobalObject* globalObject, JSValue key)</span>
      {
<span class="line-modified">!         if (HashMapBucketType** bucket = findBucket(globalObject, key))</span>
              return (*bucket)-&gt;value();
          return jsUndefined();
      }
  
<span class="line-modified">!     ALWAYS_INLINE bool has(JSGlobalObject* globalObject, JSValue key)</span>
      {
<span class="line-modified">!         return !!findBucket(globalObject, key);</span>
      }
  
<span class="line-modified">!     ALWAYS_INLINE void add(JSGlobalObject* globalObject, JSValue key, JSValue value = JSValue())</span>
      {
          key = normalizeMapKey(key);
<span class="line-modified">!         addNormalizedInternal(globalObject, key, value, [&amp;] (HashMapBucketType* bucket) {</span>
<span class="line-modified">!             return !isDeleted(bucket) &amp;&amp; areKeysEqual(globalObject, key, bucket-&gt;key());</span>
          });
          if (shouldRehashAfterAdd())
<span class="line-modified">!             rehash(globalObject);</span>
      }
  
<span class="line-modified">!     ALWAYS_INLINE HashMapBucketType* addNormalized(JSGlobalObject* globalObject, JSValue key, JSValue value, uint32_t hash)</span>
      {
          ASSERT_WITH_MESSAGE(normalizeMapKey(key) == key, &quot;We expect normalized values flowing into this function.&quot;);
<span class="line-modified">!         ASSERT_WITH_MESSAGE(jsMapHash(globalObject, getVM(globalObject), key) == hash, &quot;We expect hash value is what we expect.&quot;);</span>
  
<span class="line-modified">!         auto* bucket = addNormalizedInternal(getVM(globalObject), key, value, hash, [&amp;] (HashMapBucketType* bucket) {</span>
<span class="line-modified">!             return !isDeleted(bucket) &amp;&amp; areKeysEqual(globalObject, key, bucket-&gt;key());</span>
          });
          if (shouldRehashAfterAdd())
<span class="line-modified">!             rehash(globalObject);</span>
          return bucket;
      }
  
<span class="line-modified">!     ALWAYS_INLINE bool remove(JSGlobalObject* globalObject, JSValue key)</span>
      {
<span class="line-modified">!         HashMapBucketType** bucket = findBucket(globalObject, key);</span>
          if (!bucket)
              return false;
  
<span class="line-modified">!         VM&amp; vm = getVM(globalObject);</span>
          HashMapBucketType* impl = *bucket;
          impl-&gt;next()-&gt;setPrev(vm, impl-&gt;prev());
          impl-&gt;prev()-&gt;setNext(vm, impl-&gt;next());
          impl-&gt;makeDeleted(vm);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 500,23 ***</span>
          ++m_deleteCount;
          ASSERT(m_keyCount &gt; 0);
          --m_keyCount;
  
          if (shouldShrink())
<span class="line-modified">!             rehash(exec);</span>
  
          return true;
      }
  
      ALWAYS_INLINE uint32_t size() const
      {
          return m_keyCount;
      }
  
<span class="line-modified">!     ALWAYS_INLINE void clear(ExecState* exec)</span>
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          m_keyCount = 0;
          m_deleteCount = 0;
          HashMapBucketType* head = m_head.get();
          HashMapBucketType* bucket = m_head-&gt;next();
          HashMapBucketType* tail = m_tail.get();
<span class="line-new-header">--- 505,23 ---</span>
          ++m_deleteCount;
          ASSERT(m_keyCount &gt; 0);
          --m_keyCount;
  
          if (shouldShrink())
<span class="line-modified">!             rehash(globalObject);</span>
  
          return true;
      }
  
      ALWAYS_INLINE uint32_t size() const
      {
          return m_keyCount;
      }
  
<span class="line-modified">!     ALWAYS_INLINE void clear(JSGlobalObject* globalObject)</span>
      {
<span class="line-modified">!         VM&amp; vm = getVM(globalObject);</span>
          m_keyCount = 0;
          m_deleteCount = 0;
          HashMapBucketType* head = m_head.get();
          HashMapBucketType* bucket = m_head-&gt;next();
          HashMapBucketType* tail = m_tail.get();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 528,11 ***</span>
              bucket = next;
          }
          m_head-&gt;setNext(vm, m_tail.get());
          m_tail-&gt;setPrev(vm, m_head.get());
          m_capacity = 4;
<span class="line-modified">!         makeAndSetNewBuffer(exec, vm);</span>
          checkConsistency();
      }
  
      ALWAYS_INLINE size_t bufferSizeInBytes() const
      {
<span class="line-new-header">--- 533,11 ---</span>
              bucket = next;
          }
          m_head-&gt;setNext(vm, m_tail.get());
          m_tail-&gt;setPrev(vm, m_head.get());
          m_capacity = 4;
<span class="line-modified">!         makeAndSetNewBuffer(globalObject, vm);</span>
          checkConsistency();
      }
  
      ALWAYS_INLINE size_t bufferSizeInBytes() const
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 575,35 ***</span>
      ALWAYS_INLINE uint32_t shouldShrink() const
      {
          return JSC::shouldShrink(m_capacity, m_keyCount);
      }
  
<span class="line-modified">!     ALWAYS_INLINE void setUpHeadAndTail(ExecState*, VM&amp; vm)</span>
      {
          m_head.set(vm, this, HashMapBucketType::create(vm));
          m_tail.set(vm, this, HashMapBucketType::create(vm));
  
          m_head-&gt;setNext(vm, m_tail.get());
          m_tail-&gt;setPrev(vm, m_head.get());
          ASSERT(m_head-&gt;deleted());
          ASSERT(m_tail-&gt;deleted());
      }
  
<span class="line-modified">!     ALWAYS_INLINE void addNormalizedNonExistingForCloning(ExecState* exec, JSValue key, JSValue value = JSValue())</span>
      {
<span class="line-modified">!         addNormalizedInternal(exec, key, value, [&amp;] (HashMapBucketType*) {</span>
              return false;
          });
      }
  
      template&lt;typename CanUseBucket&gt;
<span class="line-modified">!     ALWAYS_INLINE void addNormalizedInternal(ExecState* exec, JSValue key, JSValue value, const CanUseBucket&amp; canUseBucket)</span>
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!         uint32_t hash = jsMapHash(exec, vm, key);</span>
          RETURN_IF_EXCEPTION(scope, void());
          scope.release();
          addNormalizedInternal(vm, key, value, hash, canUseBucket);
      }
  
<span class="line-new-header">--- 580,35 ---</span>
      ALWAYS_INLINE uint32_t shouldShrink() const
      {
          return JSC::shouldShrink(m_capacity, m_keyCount);
      }
  
<span class="line-modified">!     ALWAYS_INLINE void setUpHeadAndTail(JSGlobalObject*, VM&amp; vm)</span>
      {
          m_head.set(vm, this, HashMapBucketType::create(vm));
          m_tail.set(vm, this, HashMapBucketType::create(vm));
  
          m_head-&gt;setNext(vm, m_tail.get());
          m_tail-&gt;setPrev(vm, m_head.get());
          ASSERT(m_head-&gt;deleted());
          ASSERT(m_tail-&gt;deleted());
      }
  
<span class="line-modified">!     ALWAYS_INLINE void addNormalizedNonExistingForCloning(JSGlobalObject* globalObject, JSValue key, JSValue value = JSValue())</span>
      {
<span class="line-modified">!         addNormalizedInternal(globalObject, key, value, [&amp;] (HashMapBucketType*) {</span>
              return false;
          });
      }
  
      template&lt;typename CanUseBucket&gt;
<span class="line-modified">!     ALWAYS_INLINE void addNormalizedInternal(JSGlobalObject* globalObject, JSValue key, JSValue value, const CanUseBucket&amp; canUseBucket)</span>
      {
<span class="line-modified">!         VM&amp; vm = getVM(globalObject);</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!         uint32_t hash = jsMapHash(globalObject, vm, key);</span>
          RETURN_IF_EXCEPTION(scope, void());
          scope.release();
          addNormalizedInternal(vm, key, value, hash, canUseBucket);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 638,36 ***</span>
  
          ++m_keyCount;
          return newEntry;
      }
  
<span class="line-modified">!     ALWAYS_INLINE HashMapBucketType** findBucketAlreadyHashedAndNormalized(ExecState* exec, JSValue key, uint32_t hash)</span>
      {
          const uint32_t mask = m_capacity - 1;
          uint32_t index = hash &amp; mask;
          HashMapBucketType** buffer = this-&gt;buffer();
          HashMapBucketType* bucket = buffer[index];
  
          while (!isEmpty(bucket)) {
<span class="line-modified">!             if (!isDeleted(bucket) &amp;&amp; areKeysEqual(exec, key, bucket-&gt;key()))</span>
                  return buffer + index;
              index = (index + 1) &amp; mask;
              bucket = buffer[index];
          }
          return nullptr;
      }
  
<span class="line-modified">!     void rehash(ExecState* exec)</span>
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
  
          uint32_t oldCapacity = m_capacity;
          m_capacity = nextCapacity(m_capacity, m_keyCount);
  
          if (m_capacity != oldCapacity) {
<span class="line-modified">!             makeAndSetNewBuffer(exec, vm);</span>
              RETURN_IF_EXCEPTION(scope, void());
          } else {
              m_buffer-&gt;reset(m_capacity);
              assertBufferIsEmpty();
          }
<span class="line-new-header">--- 643,36 ---</span>
  
          ++m_keyCount;
          return newEntry;
      }
  
<span class="line-modified">!     ALWAYS_INLINE HashMapBucketType** findBucketAlreadyHashedAndNormalized(JSGlobalObject* globalObject, JSValue key, uint32_t hash)</span>
      {
          const uint32_t mask = m_capacity - 1;
          uint32_t index = hash &amp; mask;
          HashMapBucketType** buffer = this-&gt;buffer();
          HashMapBucketType* bucket = buffer[index];
  
          while (!isEmpty(bucket)) {
<span class="line-modified">!             if (!isDeleted(bucket) &amp;&amp; areKeysEqual(globalObject, key, bucket-&gt;key()))</span>
                  return buffer + index;
              index = (index + 1) &amp; mask;
              bucket = buffer[index];
          }
          return nullptr;
      }
  
<span class="line-modified">!     void rehash(JSGlobalObject* globalObject)</span>
      {
<span class="line-modified">!         VM&amp; vm = getVM(globalObject);</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
  
          uint32_t oldCapacity = m_capacity;
          m_capacity = nextCapacity(m_capacity, m_keyCount);
  
          if (m_capacity != oldCapacity) {
<span class="line-modified">!             makeAndSetNewBuffer(globalObject, vm);</span>
              RETURN_IF_EXCEPTION(scope, void());
          } else {
              m_buffer-&gt;reset(m_capacity);
              assertBufferIsEmpty();
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 676,11 ***</span>
          HashMapBucketType* end = m_tail.get();
          const uint32_t mask = m_capacity - 1;
          RELEASE_ASSERT(!(m_capacity &amp; (m_capacity - 1)));
          HashMapBucketType** buffer = this-&gt;buffer();
          while (iter != end) {
<span class="line-modified">!             uint32_t index = jsMapHash(exec, vm, iter-&gt;key()) &amp; mask;</span>
              EXCEPTION_ASSERT_WITH_MESSAGE(!scope.exception(), &quot;All keys should already be hashed before, so this should not throw because it won&#39;t resolve ropes.&quot;);
              {
                  HashMapBucketType* bucket = buffer[index];
                  while (!isEmpty(bucket)) {
                      index = (index + 1) &amp; mask;
<span class="line-new-header">--- 681,11 ---</span>
          HashMapBucketType* end = m_tail.get();
          const uint32_t mask = m_capacity - 1;
          RELEASE_ASSERT(!(m_capacity &amp; (m_capacity - 1)));
          HashMapBucketType** buffer = this-&gt;buffer();
          while (iter != end) {
<span class="line-modified">!             uint32_t index = jsMapHash(globalObject, vm, iter-&gt;key()) &amp; mask;</span>
              EXCEPTION_ASSERT_WITH_MESSAGE(!scope.exception(), &quot;All keys should already be hashed before, so this should not throw because it won&#39;t resolve ropes.&quot;);
              {
                  HashMapBucketType* bucket = buffer[index];
                  while (!isEmpty(bucket)) {
                      index = (index + 1) &amp; mask;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 696,11 ***</span>
          checkConsistency();
      }
  
      ALWAYS_INLINE void checkConsistency() const
      {
<span class="line-modified">!         if (!ASSERT_DISABLED) {</span>
              HashMapBucketType* iter = m_head-&gt;next();
              HashMapBucketType* end = m_tail.get();
              uint32_t size = 0;
              while (iter != end) {
                  ++size;
<span class="line-new-header">--- 701,11 ---</span>
          checkConsistency();
      }
  
      ALWAYS_INLINE void checkConsistency() const
      {
<span class="line-modified">!         if (ASSERT_ENABLED) {</span>
              HashMapBucketType* iter = m_head-&gt;next();
              HashMapBucketType* end = m_tail.get();
              uint32_t size = 0;
              while (iter != end) {
                  ++size;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 708,25 ***</span>
              }
              ASSERT(size == m_keyCount);
          }
      }
  
<span class="line-modified">!     void makeAndSetNewBuffer(ExecState* exec, VM&amp; vm)</span>
      {
          ASSERT(!(m_capacity &amp; (m_capacity - 1)));
  
<span class="line-modified">!         HashMapBufferType* buffer = HashMapBufferType::create(exec, vm, this, m_capacity);</span>
          if (UNLIKELY(!buffer))
              return;
  
          m_buffer.set(vm, this, buffer);
          assertBufferIsEmpty();
      }
  
      ALWAYS_INLINE void assertBufferIsEmpty() const
      {
<span class="line-modified">!         if (!ASSERT_DISABLED) {</span>
              for (unsigned i = 0; i &lt; m_capacity; i++)
                  ASSERT(isEmpty(buffer()[i]));
          }
      }
  
<span class="line-new-header">--- 713,25 ---</span>
              }
              ASSERT(size == m_keyCount);
          }
      }
  
<span class="line-modified">!     void makeAndSetNewBuffer(JSGlobalObject* globalObject, VM&amp; vm)</span>
      {
          ASSERT(!(m_capacity &amp; (m_capacity - 1)));
  
<span class="line-modified">!         HashMapBufferType* buffer = HashMapBufferType::create(globalObject, vm, this, m_capacity);</span>
          if (UNLIKELY(!buffer))
              return;
  
          m_buffer.set(vm, this, buffer);
          assertBufferIsEmpty();
      }
  
      ALWAYS_INLINE void assertBufferIsEmpty() const
      {
<span class="line-modified">!         if (ASSERT_ENABLED) {</span>
              for (unsigned i = 0; i &lt; m_capacity; i++)
                  ASSERT(isEmpty(buffer()[i]));
          }
      }
  
</pre>
<center><a href="GlobalExecutable.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Identifier.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
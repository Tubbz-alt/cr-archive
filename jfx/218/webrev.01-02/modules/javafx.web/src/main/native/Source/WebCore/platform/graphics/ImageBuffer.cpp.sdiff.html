<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ImageBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ImageBackingStore.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ImageBuffer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ImageBuffer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 97     scale = clampedSize / size;
 98     ASSERT(!sizeNeedsClamping(clampedSize));
 99     ASSERT(!sizeNeedsClamping(size, scale));
100     return clampedSize;
101 }
102 
103 FloatRect ImageBuffer::clampedRect(const FloatRect&amp; rect)
104 {
105     return FloatRect(rect.location(), clampedSize(rect.size()));
106 }
107 
108 #if !USE(CG) &amp;&amp; !USE(CAIRO)
109 Vector&lt;uint8_t&gt; ImageBuffer::toBGRAData() const
110 {
111     // FIXME: Implement this for other backends.
112     return { };
113 }
114 #endif
115 
116 #if !(USE(CG) || USE(DIRECT2D))
<span class="line-removed">117 </span>
<span class="line-removed">118 FloatSize ImageBuffer::sizeForDestinationSize(FloatSize size) const</span>
<span class="line-removed">119 {</span>
<span class="line-removed">120     return size;</span>
<span class="line-removed">121 }</span>
<span class="line-removed">122 </span>
123 void ImageBuffer::transformColorSpace(ColorSpace srcColorSpace, ColorSpace dstColorSpace)
124 {
125     if (srcColorSpace == dstColorSpace)
126         return;
127 
128     // only sRGB &lt;-&gt; linearRGB are supported at the moment
<span class="line-modified">129     if ((srcColorSpace != ColorSpaceLinearRGB &amp;&amp; srcColorSpace != ColorSpaceSRGB)</span>
<span class="line-modified">130         || (dstColorSpace != ColorSpaceLinearRGB &amp;&amp; dstColorSpace != ColorSpaceSRGB))</span>
131         return;
132 
<span class="line-modified">133     if (dstColorSpace == ColorSpaceLinearRGB) {</span>
134         static const std::array&lt;uint8_t, 256&gt; linearRgbLUT = [] {
135             std::array&lt;uint8_t, 256&gt; array;
136             for (unsigned i = 0; i &lt; 256; i++) {
137                 float color = i / 255.0f;
138                 color = sRGBToLinearColorComponent(color);
139                 array[i] = static_cast&lt;uint8_t&gt;(round(color * 255));
140             }
141             return array;
142         }();
143         platformTransformColorSpace(linearRgbLUT);
<span class="line-modified">144     } else if (dstColorSpace == ColorSpaceSRGB) {</span>
145         static const std::array&lt;uint8_t, 256&gt; deviceRgbLUT= [] {
146             std::array&lt;uint8_t, 256&gt; array;
147             for (unsigned i = 0; i &lt; 256; i++) {
148                 float color = i / 255.0f;
149                 color = linearToSRGBColorComponent(color);
150                 array[i] = static_cast&lt;uint8_t&gt;(round(color * 255));
151             }
152             return array;
153         }();
154         platformTransformColorSpace(deviceRgbLUT);
155     }
156 }
157 
158 #endif // USE(CG)
159 
160 inline void ImageBuffer::genericConvertToLuminanceMask()
161 {
162     IntRect luminanceRect(IntPoint(), internalSize());
163     auto srcPixelArray = getUnmultipliedImageData(luminanceRect);
164     if (!srcPixelArray)
</pre>
<hr />
<pre>
174         uint8_t b = srcPixelArray-&gt;item(pixelOffset + 2);
175 
176         double luma = (r * 0.2125 + g * 0.7154 + b * 0.0721) * ((double)a / 255.0);
177         srcPixelArray-&gt;set(pixelOffset + 3, luma);
178     }
179     putByteArray(*srcPixelArray, AlphaPremultiplication::Unpremultiplied, luminanceRect.size(), luminanceRect, IntPoint());
180 }
181 
182 void ImageBuffer::convertToLuminanceMask()
183 {
184     // Add platform specific functions with platformConvertToLuminanceMask here later.
185     genericConvertToLuminanceMask();
186 }
187 
188 #if !USE(CAIRO)
189 PlatformLayer* ImageBuffer::platformLayer() const
190 {
191     return 0;
192 }
193 
<span class="line-modified">194 bool ImageBuffer::copyToPlatformTexture(GraphicsContext3D&amp;, GC3Denum, Platform3DObject, GC3Denum, bool, bool)</span>
195 {
196     return false;
197 }
198 #endif
199 
200 std::unique_ptr&lt;ImageBuffer&gt; ImageBuffer::copyRectToBuffer(const FloatRect&amp; rect, ColorSpace colorSpace, const GraphicsContext&amp; context)
201 {
202     if (rect.isEmpty())
203         return nullptr;
204 
205     IntSize scaledSize = ImageBuffer::compatibleBufferSize(rect.size(), context);
206 
207     auto buffer = ImageBuffer::createCompatibleBuffer(scaledSize, 1, colorSpace, context);
208     if (!buffer)
209         return nullptr;
210 
211     buffer-&gt;context().drawImageBuffer(*this, -rect.location());
212     return buffer;
213 }
214 
</pre>
<hr />
<pre>
227     buffer-&gt;context().scale(scaledSize / size);
228     return buffer;
229 }
230 
231 std::unique_ptr&lt;ImageBuffer&gt; ImageBuffer::createCompatibleBuffer(const FloatSize&amp; size, float resolutionScale, ColorSpace colorSpace, const GraphicsContext&amp; context)
232 {
233 #if USE(DIRECT2D)
234     return create(size, context.renderingMode(), &amp;context, resolutionScale, colorSpace);
235 #else
236     return create(size, context.renderingMode(), resolutionScale, colorSpace);
237 #endif
238 }
239 
240 IntSize ImageBuffer::compatibleBufferSize(const FloatSize&amp; size, const GraphicsContext&amp; context)
241 {
242     // Enlarge the buffer size if the context&#39;s transform is scaling it so we need a higher
243     // resolution than one pixel per unit.
244     return expandedIntSize(size * context.scaleFactor());
245 }
246 
<span class="line-removed">247 bool ImageBuffer::isCompatibleWithContext(const GraphicsContext&amp; context) const</span>
<span class="line-removed">248 {</span>
<span class="line-removed">249     return areEssentiallyEqual(context.scaleFactor(), this-&gt;context().scaleFactor());</span>
<span class="line-removed">250 }</span>
<span class="line-removed">251 </span>
252 #if !USE(IOSURFACE_CANVAS_BACKING_STORE)
253 size_t ImageBuffer::memoryCost() const
254 {
255     // memoryCost() may be invoked concurrently from a GC thread, and we need to be careful about what data we access here and how.
256     // It&#39;s safe to access internalSize() because it doesn&#39;t do any pointer chasing.
257     return 4 * internalSize().width() * internalSize().height();
258 }
259 
260 size_t ImageBuffer::externalMemoryCost() const
261 {
262     return 0;
263 }
264 #endif
265 
266 }
</pre>
</td>
<td>
<hr />
<pre>
 97     scale = clampedSize / size;
 98     ASSERT(!sizeNeedsClamping(clampedSize));
 99     ASSERT(!sizeNeedsClamping(size, scale));
100     return clampedSize;
101 }
102 
103 FloatRect ImageBuffer::clampedRect(const FloatRect&amp; rect)
104 {
105     return FloatRect(rect.location(), clampedSize(rect.size()));
106 }
107 
108 #if !USE(CG) &amp;&amp; !USE(CAIRO)
109 Vector&lt;uint8_t&gt; ImageBuffer::toBGRAData() const
110 {
111     // FIXME: Implement this for other backends.
112     return { };
113 }
114 #endif
115 
116 #if !(USE(CG) || USE(DIRECT2D))






117 void ImageBuffer::transformColorSpace(ColorSpace srcColorSpace, ColorSpace dstColorSpace)
118 {
119     if (srcColorSpace == dstColorSpace)
120         return;
121 
122     // only sRGB &lt;-&gt; linearRGB are supported at the moment
<span class="line-modified">123     if ((srcColorSpace != ColorSpace::LinearRGB &amp;&amp; srcColorSpace != ColorSpace::SRGB)</span>
<span class="line-modified">124         || (dstColorSpace != ColorSpace::LinearRGB &amp;&amp; dstColorSpace != ColorSpace::SRGB))</span>
125         return;
126 
<span class="line-modified">127     if (dstColorSpace == ColorSpace::LinearRGB) {</span>
128         static const std::array&lt;uint8_t, 256&gt; linearRgbLUT = [] {
129             std::array&lt;uint8_t, 256&gt; array;
130             for (unsigned i = 0; i &lt; 256; i++) {
131                 float color = i / 255.0f;
132                 color = sRGBToLinearColorComponent(color);
133                 array[i] = static_cast&lt;uint8_t&gt;(round(color * 255));
134             }
135             return array;
136         }();
137         platformTransformColorSpace(linearRgbLUT);
<span class="line-modified">138     } else if (dstColorSpace == ColorSpace::SRGB) {</span>
139         static const std::array&lt;uint8_t, 256&gt; deviceRgbLUT= [] {
140             std::array&lt;uint8_t, 256&gt; array;
141             for (unsigned i = 0; i &lt; 256; i++) {
142                 float color = i / 255.0f;
143                 color = linearToSRGBColorComponent(color);
144                 array[i] = static_cast&lt;uint8_t&gt;(round(color * 255));
145             }
146             return array;
147         }();
148         platformTransformColorSpace(deviceRgbLUT);
149     }
150 }
151 
152 #endif // USE(CG)
153 
154 inline void ImageBuffer::genericConvertToLuminanceMask()
155 {
156     IntRect luminanceRect(IntPoint(), internalSize());
157     auto srcPixelArray = getUnmultipliedImageData(luminanceRect);
158     if (!srcPixelArray)
</pre>
<hr />
<pre>
168         uint8_t b = srcPixelArray-&gt;item(pixelOffset + 2);
169 
170         double luma = (r * 0.2125 + g * 0.7154 + b * 0.0721) * ((double)a / 255.0);
171         srcPixelArray-&gt;set(pixelOffset + 3, luma);
172     }
173     putByteArray(*srcPixelArray, AlphaPremultiplication::Unpremultiplied, luminanceRect.size(), luminanceRect, IntPoint());
174 }
175 
176 void ImageBuffer::convertToLuminanceMask()
177 {
178     // Add platform specific functions with platformConvertToLuminanceMask here later.
179     genericConvertToLuminanceMask();
180 }
181 
182 #if !USE(CAIRO)
183 PlatformLayer* ImageBuffer::platformLayer() const
184 {
185     return 0;
186 }
187 
<span class="line-modified">188 bool ImageBuffer::copyToPlatformTexture(GraphicsContextGLOpenGL&amp;, GCGLenum, PlatformGLObject, GCGLenum, bool, bool)</span>
189 {
190     return false;
191 }
192 #endif
193 
194 std::unique_ptr&lt;ImageBuffer&gt; ImageBuffer::copyRectToBuffer(const FloatRect&amp; rect, ColorSpace colorSpace, const GraphicsContext&amp; context)
195 {
196     if (rect.isEmpty())
197         return nullptr;
198 
199     IntSize scaledSize = ImageBuffer::compatibleBufferSize(rect.size(), context);
200 
201     auto buffer = ImageBuffer::createCompatibleBuffer(scaledSize, 1, colorSpace, context);
202     if (!buffer)
203         return nullptr;
204 
205     buffer-&gt;context().drawImageBuffer(*this, -rect.location());
206     return buffer;
207 }
208 
</pre>
<hr />
<pre>
221     buffer-&gt;context().scale(scaledSize / size);
222     return buffer;
223 }
224 
225 std::unique_ptr&lt;ImageBuffer&gt; ImageBuffer::createCompatibleBuffer(const FloatSize&amp; size, float resolutionScale, ColorSpace colorSpace, const GraphicsContext&amp; context)
226 {
227 #if USE(DIRECT2D)
228     return create(size, context.renderingMode(), &amp;context, resolutionScale, colorSpace);
229 #else
230     return create(size, context.renderingMode(), resolutionScale, colorSpace);
231 #endif
232 }
233 
234 IntSize ImageBuffer::compatibleBufferSize(const FloatSize&amp; size, const GraphicsContext&amp; context)
235 {
236     // Enlarge the buffer size if the context&#39;s transform is scaling it so we need a higher
237     // resolution than one pixel per unit.
238     return expandedIntSize(size * context.scaleFactor());
239 }
240 





241 #if !USE(IOSURFACE_CANVAS_BACKING_STORE)
242 size_t ImageBuffer::memoryCost() const
243 {
244     // memoryCost() may be invoked concurrently from a GC thread, and we need to be careful about what data we access here and how.
245     // It&#39;s safe to access internalSize() because it doesn&#39;t do any pointer chasing.
246     return 4 * internalSize().width() * internalSize().height();
247 }
248 
249 size_t ImageBuffer::externalMemoryCost() const
250 {
251     return 0;
252 }
253 #endif
254 
255 }
</pre>
</td>
</tr>
</table>
<center><a href="ImageBackingStore.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ImageBuffer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/style/StyleBuilderCustom.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2013 Google Inc. All rights reserved.
   3  * Copyright (C) 2014-2017 Apple Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  15  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  16  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  18  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  19  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  21  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  22  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  23  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  24  * THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #pragma once
  28 
  29 #include &quot;CSSAspectRatioValue.h&quot;
  30 #include &quot;CSSCursorImageValue.h&quot;
  31 #include &quot;CSSFontFamily.h&quot;
  32 #include &quot;CSSFontValue.h&quot;
  33 #include &quot;CSSGradientValue.h&quot;
  34 #include &quot;CSSGridTemplateAreasValue.h&quot;
  35 #include &quot;CSSRegisteredCustomProperty.h&quot;
  36 #include &quot;CSSShadowValue.h&quot;
  37 #include &quot;Counter.h&quot;
  38 #include &quot;CounterContent.h&quot;
  39 #include &quot;CursorList.h&quot;
  40 #include &quot;ElementAncestorIterator.h&quot;
  41 #include &quot;FontVariantBuilder.h&quot;
  42 #include &quot;Frame.h&quot;
  43 #include &quot;HTMLElement.h&quot;
  44 #include &quot;Rect.h&quot;
  45 #include &quot;SVGElement.h&quot;
  46 #include &quot;SVGRenderStyle.h&quot;
  47 #include &quot;StyleBuilderConverter.h&quot;
  48 #include &quot;StyleCachedImage.h&quot;
  49 #include &quot;StyleCursorImage.h&quot;
  50 #include &quot;StyleFontSizeFunctions.h&quot;
  51 #include &quot;StyleGeneratedImage.h&quot;
  52 #include &quot;StyleImageSet.h&quot;
  53 #include &quot;StyleResolver.h&quot;
  54 #include &quot;WillChangeData.h&quot;
  55 
  56 namespace WebCore {
  57 namespace Style {
  58 
  59 #define DECLARE_PROPERTY_CUSTOM_HANDLERS(property) \
  60     static void applyInherit##property(BuilderState&amp;); \
  61     static void applyInitial##property(BuilderState&amp;); \
  62     static void applyValue##property(BuilderState&amp;, CSSValue&amp;)
  63 
  64 template&lt;typename T&gt; inline T forwardInheritedValue(T&amp;&amp; value) { return std::forward&lt;T&gt;(value); }
  65 inline Length forwardInheritedValue(const Length&amp; value) { auto copy = value; return copy; }
  66 inline LengthSize forwardInheritedValue(const LengthSize&amp; value) { auto copy = value; return copy; }
  67 inline LengthBox forwardInheritedValue(const LengthBox&amp; value) { auto copy = value; return copy; }
  68 inline GapLength forwardInheritedValue(const GapLength&amp; value) { auto copy = value; return copy; }
  69 
  70 // Note that we assume the CSS parser only allows valid CSSValue types.
  71 class BuilderCustom {
  72 public:
  73     // Custom handling of inherit, initial and value setting.
  74     DECLARE_PROPERTY_CUSTOM_HANDLERS(BorderImageOutset);
  75     DECLARE_PROPERTY_CUSTOM_HANDLERS(BorderImageRepeat);
  76     DECLARE_PROPERTY_CUSTOM_HANDLERS(BorderImageSlice);
  77     DECLARE_PROPERTY_CUSTOM_HANDLERS(BorderImageWidth);
  78     DECLARE_PROPERTY_CUSTOM_HANDLERS(BoxShadow);
  79     DECLARE_PROPERTY_CUSTOM_HANDLERS(Clip);
  80     DECLARE_PROPERTY_CUSTOM_HANDLERS(Content);
  81     DECLARE_PROPERTY_CUSTOM_HANDLERS(CounterIncrement);
  82     DECLARE_PROPERTY_CUSTOM_HANDLERS(CounterReset);
  83     DECLARE_PROPERTY_CUSTOM_HANDLERS(Cursor);
  84     DECLARE_PROPERTY_CUSTOM_HANDLERS(Fill);
  85     DECLARE_PROPERTY_CUSTOM_HANDLERS(FontFamily);
  86     DECLARE_PROPERTY_CUSTOM_HANDLERS(FontSize);
  87     DECLARE_PROPERTY_CUSTOM_HANDLERS(FontStyle);
  88 #if ENABLE(CSS_IMAGE_RESOLUTION)
  89     DECLARE_PROPERTY_CUSTOM_HANDLERS(ImageResolution);
  90 #endif
  91 #if ENABLE(TEXT_AUTOSIZING)
  92     DECLARE_PROPERTY_CUSTOM_HANDLERS(LineHeight);
  93 #endif
  94     DECLARE_PROPERTY_CUSTOM_HANDLERS(OutlineStyle);
  95     DECLARE_PROPERTY_CUSTOM_HANDLERS(Size);
  96     DECLARE_PROPERTY_CUSTOM_HANDLERS(Stroke);
  97     DECLARE_PROPERTY_CUSTOM_HANDLERS(TextIndent);
  98     DECLARE_PROPERTY_CUSTOM_HANDLERS(TextShadow);
  99     DECLARE_PROPERTY_CUSTOM_HANDLERS(WebkitAspectRatio);
 100     DECLARE_PROPERTY_CUSTOM_HANDLERS(WebkitBoxShadow);
 101     DECLARE_PROPERTY_CUSTOM_HANDLERS(FontVariantLigatures);
 102     DECLARE_PROPERTY_CUSTOM_HANDLERS(FontVariantNumeric);
 103     DECLARE_PROPERTY_CUSTOM_HANDLERS(FontVariantEastAsian);
 104     DECLARE_PROPERTY_CUSTOM_HANDLERS(GridTemplateAreas);
 105     DECLARE_PROPERTY_CUSTOM_HANDLERS(GridTemplateColumns);
 106     DECLARE_PROPERTY_CUSTOM_HANDLERS(GridTemplateRows);
 107     DECLARE_PROPERTY_CUSTOM_HANDLERS(WebkitMaskBoxImageOutset);
 108     DECLARE_PROPERTY_CUSTOM_HANDLERS(WebkitMaskBoxImageRepeat);
 109     DECLARE_PROPERTY_CUSTOM_HANDLERS(WebkitMaskBoxImageSlice);
 110     DECLARE_PROPERTY_CUSTOM_HANDLERS(WebkitMaskBoxImageWidth);
 111     DECLARE_PROPERTY_CUSTOM_HANDLERS(WebkitTextEmphasisStyle);
 112     DECLARE_PROPERTY_CUSTOM_HANDLERS(Zoom);
 113 
 114     // Custom handling of initial + inherit value setting only.
 115     static void applyInitialWebkitMaskImage(BuilderState&amp;) { }
 116     static void applyInheritWebkitMaskImage(BuilderState&amp;) { }
 117     static void applyInitialFontFeatureSettings(BuilderState&amp;) { }
 118     static void applyInheritFontFeatureSettings(BuilderState&amp;) { }
 119 #if ENABLE(VARIATION_FONTS)
 120     static void applyInitialFontVariationSettings(BuilderState&amp;) { }
 121     static void applyInheritFontVariationSettings(BuilderState&amp;) { }
 122 #endif
 123 
 124     // Custom handling of inherit + value setting only.
 125     static void applyInheritDisplay(BuilderState&amp;);
 126     static void applyValueDisplay(BuilderState&amp;, CSSValue&amp;);
 127 
 128     // Custom handling of value setting only.
 129     static void applyValueBaselineShift(BuilderState&amp;, CSSValue&amp;);
 130     static void applyValueDirection(BuilderState&amp;, CSSValue&amp;);
 131     static void applyValueVerticalAlign(BuilderState&amp;, CSSValue&amp;);
 132     static void applyInitialTextAlign(BuilderState&amp;);
 133     static void applyValueTextAlign(BuilderState&amp;, CSSValue&amp;);
 134     static void applyValueWebkitLocale(BuilderState&amp;, CSSValue&amp;);
 135     static void applyValueWebkitTextOrientation(BuilderState&amp;, CSSValue&amp;);
 136 #if ENABLE(TEXT_AUTOSIZING)
 137     static void applyValueWebkitTextSizeAdjust(BuilderState&amp;, CSSValue&amp;);
 138 #endif
 139     static void applyValueWebkitTextZoom(BuilderState&amp;, CSSValue&amp;);
 140     static void applyValueWritingMode(BuilderState&amp;, CSSValue&amp;);
 141     static void applyValueAlt(BuilderState&amp;, CSSValue&amp;);
 142     static void applyValueWillChange(BuilderState&amp;, CSSValue&amp;);
 143 
 144 #if ENABLE(DARK_MODE_CSS)
 145     static void applyValueColorScheme(BuilderState&amp;, CSSValue&amp;);
 146 #endif
 147 
 148     static void applyValueStrokeWidth(BuilderState&amp;, CSSValue&amp;);
 149     static void applyValueStrokeColor(BuilderState&amp;, CSSValue&amp;);
 150 
 151     static void applyInitialCustomProperty(BuilderState&amp;, const CSSRegisteredCustomProperty*, const AtomString&amp; name);
 152     static void applyInheritCustomProperty(BuilderState&amp;, const CSSRegisteredCustomProperty*, const AtomString&amp; name);
 153     static void applyValueCustomProperty(BuilderState&amp;, const CSSRegisteredCustomProperty*, CSSCustomPropertyValue&amp;);
 154 
 155 private:
 156     static void resetEffectiveZoom(BuilderState&amp;);
 157 
 158     static Length mmLength(double mm);
 159     static Length inchLength(double inch);
 160     static bool getPageSizeFromName(CSSPrimitiveValue* pageSizeName, CSSPrimitiveValue* pageOrientation, Length&amp; width, Length&amp; height);
 161 
 162     template &lt;CSSPropertyID id&gt;
 163     static void applyTextOrBoxShadowValue(BuilderState&amp;, CSSValue&amp;);
 164     static bool isValidDisplayValue(BuilderState&amp;, DisplayType);
 165 
 166     enum CounterBehavior {Increment = 0, Reset};
 167     template &lt;CounterBehavior counterBehavior&gt;
 168     static void applyInheritCounter(BuilderState&amp;);
 169     template &lt;CounterBehavior counterBehavior&gt;
 170     static void applyValueCounter(BuilderState&amp;, CSSValue&amp;);
 171 
 172     static float largerFontSize(float size);
 173     static float smallerFontSize(float size);
 174     static float determineRubyTextSizeMultiplier(BuilderState&amp;);
 175 };
 176 
 177 inline void BuilderCustom::applyValueDirection(BuilderState&amp; builderState, CSSValue&amp; value)
 178 {
 179     builderState.style().setDirection(downcast&lt;CSSPrimitiveValue&gt;(value));
 180     builderState.style().setHasExplicitlySetDirection(true);
 181 }
 182 
 183 inline void BuilderCustom::applyInitialTextAlign(BuilderState&amp; builderState)
 184 {
 185     builderState.style().setTextAlign(RenderStyle::initialTextAlign());
 186     builderState.style().setHasExplicitlySetTextAlign(true);
 187 }
 188 
 189 inline void BuilderCustom::applyValueTextAlign(BuilderState&amp; builderState, CSSValue&amp; value)
 190 {
 191     builderState.style().setTextAlign(BuilderConverter::convertTextAlign(builderState, value));
 192     builderState.style().setHasExplicitlySetTextAlign(true);
 193 }
 194 
 195 inline void BuilderCustom::resetEffectiveZoom(BuilderState&amp; builderState)
 196 {
 197     // Reset the zoom in effect. This allows the setZoom method to accurately compute a new zoom in effect.
 198     builderState.setEffectiveZoom(builderState.parentStyle().effectiveZoom());
 199 }
 200 
 201 inline void BuilderCustom::applyInitialZoom(BuilderState&amp; builderState)
 202 {
 203     resetEffectiveZoom(builderState);
 204     builderState.setZoom(RenderStyle::initialZoom());
 205 }
 206 
 207 inline void BuilderCustom::applyInheritZoom(BuilderState&amp; builderState)
 208 {
 209     resetEffectiveZoom(builderState);
 210     builderState.setZoom(builderState.parentStyle().zoom());
 211 }
 212 
 213 inline void BuilderCustom::applyValueZoom(BuilderState&amp; builderState, CSSValue&amp; value)
 214 {
 215     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 216 
 217     if (primitiveValue.valueID() == CSSValueNormal) {
 218         resetEffectiveZoom(builderState);
 219         builderState.setZoom(RenderStyle::initialZoom());
 220     } else if (primitiveValue.valueID() == CSSValueReset) {
 221         builderState.setEffectiveZoom(RenderStyle::initialZoom());
 222         builderState.setZoom(RenderStyle::initialZoom());
 223     } else if (primitiveValue.valueID() == CSSValueDocument) {
 224         float docZoom = builderState.rootElementStyle() ? builderState.rootElementStyle()-&gt;zoom() : RenderStyle::initialZoom();
 225         builderState.setEffectiveZoom(docZoom);
 226         builderState.setZoom(docZoom);
 227     } else if (primitiveValue.isPercentage()) {
 228         resetEffectiveZoom(builderState);
 229         if (float percent = primitiveValue.floatValue())
 230             builderState.setZoom(percent / 100.0f);
 231     } else if (primitiveValue.isNumber()) {
 232         resetEffectiveZoom(builderState);
 233         if (float number = primitiveValue.floatValue())
 234             builderState.setZoom(number);
 235     }
 236 }
 237 inline Length BuilderCustom::mmLength(double mm)
 238 {
 239     Ref&lt;CSSPrimitiveValue&gt; value(CSSPrimitiveValue::create(mm, CSSUnitType::CSS_MM));
 240     return value.get().computeLength&lt;Length&gt;(CSSToLengthConversionData());
 241 }
 242 inline Length BuilderCustom::inchLength(double inch)
 243 {
 244     Ref&lt;CSSPrimitiveValue&gt; value(CSSPrimitiveValue::create(inch, CSSUnitType::CSS_IN));
 245     return value.get().computeLength&lt;Length&gt;(CSSToLengthConversionData());
 246 }
 247 bool BuilderCustom::getPageSizeFromName(CSSPrimitiveValue* pageSizeName, CSSPrimitiveValue* pageOrientation, Length&amp; width, Length&amp; height)
 248 {
 249     static NeverDestroyed&lt;Length&gt; a5Width(mmLength(148));
 250     static NeverDestroyed&lt;Length&gt; a5Height(mmLength(210));
 251     static NeverDestroyed&lt;Length&gt; a4Width(mmLength(210));
 252     static NeverDestroyed&lt;Length&gt; a4Height(mmLength(297));
 253     static NeverDestroyed&lt;Length&gt; a3Width(mmLength(297));
 254     static NeverDestroyed&lt;Length&gt; a3Height(mmLength(420));
 255     static NeverDestroyed&lt;Length&gt; b5Width(mmLength(176));
 256     static NeverDestroyed&lt;Length&gt; b5Height(mmLength(250));
 257     static NeverDestroyed&lt;Length&gt; b4Width(mmLength(250));
 258     static NeverDestroyed&lt;Length&gt; b4Height(mmLength(353));
 259     static NeverDestroyed&lt;Length&gt; letterWidth(inchLength(8.5));
 260     static NeverDestroyed&lt;Length&gt; letterHeight(inchLength(11));
 261     static NeverDestroyed&lt;Length&gt; legalWidth(inchLength(8.5));
 262     static NeverDestroyed&lt;Length&gt; legalHeight(inchLength(14));
 263     static NeverDestroyed&lt;Length&gt; ledgerWidth(inchLength(11));
 264     static NeverDestroyed&lt;Length&gt; ledgerHeight(inchLength(17));
 265 
 266     if (!pageSizeName)
 267         return false;
 268 
 269     switch (pageSizeName-&gt;valueID()) {
 270     case CSSValueA5:
 271         width = a5Width;
 272         height = a5Height;
 273         break;
 274     case CSSValueA4:
 275         width = a4Width;
 276         height = a4Height;
 277         break;
 278     case CSSValueA3:
 279         width = a3Width;
 280         height = a3Height;
 281         break;
 282     case CSSValueB5:
 283         width = b5Width;
 284         height = b5Height;
 285         break;
 286     case CSSValueB4:
 287         width = b4Width;
 288         height = b4Height;
 289         break;
 290     case CSSValueLetter:
 291         width = letterWidth;
 292         height = letterHeight;
 293         break;
 294     case CSSValueLegal:
 295         width = legalWidth;
 296         height = legalHeight;
 297         break;
 298     case CSSValueLedger:
 299         width = ledgerWidth;
 300         height = ledgerHeight;
 301         break;
 302     default:
 303         return false;
 304     }
 305 
 306     if (pageOrientation) {
 307         switch (pageOrientation-&gt;valueID()) {
 308         case CSSValueLandscape:
 309             std::swap(width, height);
 310             break;
 311         case CSSValuePortrait:
 312             // Nothing to do.
 313             break;
 314         default:
 315             return false;
 316         }
 317     }
 318     return true;
 319 }
 320 
 321 inline void BuilderCustom::applyValueVerticalAlign(BuilderState&amp; builderState, CSSValue&amp; value)
 322 {
 323     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 324     if (primitiveValue.valueID())
 325         builderState.style().setVerticalAlign(primitiveValue);
 326     else
 327         builderState.style().setVerticalAlignLength(primitiveValue.convertToLength&lt;FixedIntegerConversion | PercentConversion | CalculatedConversion&gt;(builderState.cssToLengthConversionData()));
 328 }
 329 
 330 #if ENABLE(CSS_IMAGE_RESOLUTION)
 331 
 332 inline void BuilderCustom::applyInheritImageResolution(BuilderState&amp; builderState)
 333 {
 334     builderState.style().setImageResolutionSource(builderState.parentStyle().imageResolutionSource());
 335     builderState.style().setImageResolutionSnap(builderState.parentStyle().imageResolutionSnap());
 336     builderState.style().setImageResolution(builderState.parentStyle().imageResolution());
 337 }
 338 
 339 inline void BuilderCustom::applyInitialImageResolution(BuilderState&amp; builderState)
 340 {
 341     builderState.style().setImageResolutionSource(RenderStyle::initialImageResolutionSource());
 342     builderState.style().setImageResolutionSnap(RenderStyle::initialImageResolutionSnap());
 343     builderState.style().setImageResolution(RenderStyle::initialImageResolution());
 344 }
 345 
 346 inline void BuilderCustom::applyValueImageResolution(BuilderState&amp; builderState, CSSValue&amp; value)
 347 {
 348     ImageResolutionSource source = RenderStyle::initialImageResolutionSource();
 349     ImageResolutionSnap snap = RenderStyle::initialImageResolutionSnap();
 350     double resolution = RenderStyle::initialImageResolution();
 351     for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {
 352         CSSPrimitiveValue&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(item.get());
 353         if (primitiveValue.valueID() == CSSValueFromImage)
 354             source = ImageResolutionSource::FromImage;
 355         else if (primitiveValue.valueID() == CSSValueSnap)
 356             snap = ImageResolutionSnap::Pixels;
 357         else
 358             resolution = primitiveValue.doubleValue(CSSUnitType::CSS_DPPX);
 359     }
 360     builderState.style().setImageResolutionSource(source);
 361     builderState.style().setImageResolutionSnap(snap);
 362     builderState.style().setImageResolution(resolution);
 363 }
 364 
 365 #endif // ENABLE(CSS_IMAGE_RESOLUTION)
 366 
 367 inline void BuilderCustom::applyInheritSize(BuilderState&amp;) { }
 368 
 369 inline void BuilderCustom::applyInitialSize(BuilderState&amp;) { }
 370 
 371 inline void BuilderCustom::applyValueSize(BuilderState&amp; builderState, CSSValue&amp; value)
 372 {
 373     builderState.style().resetPageSizeType();
 374 
 375     if (!is&lt;CSSValueList&gt;(value))
 376         return;
 377 
 378     Length width;
 379     Length height;
 380     PageSizeType pageSizeType = PAGE_SIZE_AUTO;
 381 
 382     auto&amp; valueList = downcast&lt;CSSValueList&gt;(value);
 383     switch (valueList.length()) {
 384     case 2: {
 385         auto firstValue = valueList.itemWithoutBoundsCheck(0);
 386         auto secondValue = valueList.itemWithoutBoundsCheck(1);
 387         // &lt;length&gt;{2} | &lt;page-size&gt; &lt;orientation&gt;
 388         if (!is&lt;CSSPrimitiveValue&gt;(*firstValue) || !is&lt;CSSPrimitiveValue&gt;(*secondValue))
 389             return;
 390         auto&amp; firstPrimitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*firstValue);
 391         auto&amp; secondPrimitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*secondValue);
 392         if (firstPrimitiveValue.isLength()) {
 393             // &lt;length&gt;{2}
 394             if (!secondPrimitiveValue.isLength())
 395                 return;
 396             CSSToLengthConversionData conversionData = builderState.cssToLengthConversionData().copyWithAdjustedZoom(1.0f);
 397             width = firstPrimitiveValue.computeLength&lt;Length&gt;(conversionData);
 398             height = secondPrimitiveValue.computeLength&lt;Length&gt;(conversionData);
 399         } else {
 400             // &lt;page-size&gt; &lt;orientation&gt;
 401             // The value order is guaranteed. See CSSParser::parseSizeParameter.
 402             if (!getPageSizeFromName(&amp;firstPrimitiveValue, &amp;secondPrimitiveValue, width, height))
 403                 return;
 404         }
 405         pageSizeType = PAGE_SIZE_RESOLVED;
 406         break;
 407     }
 408     case 1: {
 409         auto value = valueList.itemWithoutBoundsCheck(0);
 410         // &lt;length&gt; | auto | &lt;page-size&gt; | [ portrait | landscape]
 411         if (!is&lt;CSSPrimitiveValue&gt;(*value))
 412             return;
 413         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*value);
 414         if (primitiveValue.isLength()) {
 415             // &lt;length&gt;
 416             pageSizeType = PAGE_SIZE_RESOLVED;
 417             width = height = primitiveValue.computeLength&lt;Length&gt;(builderState.cssToLengthConversionData().copyWithAdjustedZoom(1.0f));
 418         } else {
 419             switch (primitiveValue.valueID()) {
 420             case 0:
 421                 return;
 422             case CSSValueAuto:
 423                 pageSizeType = PAGE_SIZE_AUTO;
 424                 break;
 425             case CSSValuePortrait:
 426                 pageSizeType = PAGE_SIZE_AUTO_PORTRAIT;
 427                 break;
 428             case CSSValueLandscape:
 429                 pageSizeType = PAGE_SIZE_AUTO_LANDSCAPE;
 430                 break;
 431             default:
 432                 // &lt;page-size&gt;
 433                 pageSizeType = PAGE_SIZE_RESOLVED;
 434                 if (!getPageSizeFromName(&amp;primitiveValue, nullptr, width, height))
 435                     return;
 436             }
 437         }
 438         break;
 439     }
 440     default:
 441         return;
 442     }
 443     builderState.style().setPageSizeType(pageSizeType);
 444     builderState.style().setPageSize({ WTFMove(width), WTFMove(height) });
 445 }
 446 
 447 inline void BuilderCustom::applyInheritTextIndent(BuilderState&amp; builderState)
 448 {
 449     builderState.style().setTextIndent(Length { builderState.parentStyle().textIndent() });
 450 #if ENABLE(CSS3_TEXT)
 451     builderState.style().setTextIndentLine(builderState.parentStyle().textIndentLine());
 452     builderState.style().setTextIndentType(builderState.parentStyle().textIndentType());
 453 #endif
 454 }
 455 
 456 inline void BuilderCustom::applyInitialTextIndent(BuilderState&amp; builderState)
 457 {
 458     builderState.style().setTextIndent(RenderStyle::initialTextIndent());
 459 #if ENABLE(CSS3_TEXT)
 460     builderState.style().setTextIndentLine(RenderStyle::initialTextIndentLine());
 461     builderState.style().setTextIndentType(RenderStyle::initialTextIndentType());
 462 #endif
 463 }
 464 
 465 inline void BuilderCustom::applyValueTextIndent(BuilderState&amp; builderState, CSSValue&amp; value)
 466 {
 467     Length lengthOrPercentageValue;
 468 #if ENABLE(CSS3_TEXT)
 469     TextIndentLine textIndentLineValue = RenderStyle::initialTextIndentLine();
 470     TextIndentType textIndentTypeValue = RenderStyle::initialTextIndentType();
 471 #endif
 472     for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {
 473         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(item.get());
 474         if (!primitiveValue.valueID())
 475             lengthOrPercentageValue = primitiveValue.convertToLength&lt;FixedIntegerConversion | PercentConversion | CalculatedConversion&gt;(builderState.cssToLengthConversionData());
 476 #if ENABLE(CSS3_TEXT)
 477         else if (primitiveValue.valueID() == CSSValueWebkitEachLine)
 478             textIndentLineValue = TextIndentLine::EachLine;
 479         else if (primitiveValue.valueID() == CSSValueWebkitHanging)
 480             textIndentTypeValue = TextIndentType::Hanging;
 481 #endif
 482     }
 483 
 484     if (lengthOrPercentageValue.isUndefined())
 485         return;
 486 
 487     builderState.style().setTextIndent(WTFMove(lengthOrPercentageValue));
 488 #if ENABLE(CSS3_TEXT)
 489     builderState.style().setTextIndentLine(textIndentLineValue);
 490     builderState.style().setTextIndentType(textIndentTypeValue);
 491 #endif
 492 }
 493 
 494 enum BorderImageType { BorderImage, WebkitMaskBoxImage };
 495 enum BorderImageModifierType { Outset, Repeat, Slice, Width };
 496 template &lt;BorderImageType type, BorderImageModifierType modifier&gt;
 497 class ApplyPropertyBorderImageModifier {
 498 public:
 499     static void applyInheritValue(BuilderState&amp; builderState)
 500     {
 501         NinePieceImage image(getValue(builderState.style()));
 502         switch (modifier) {
 503         case Outset:
 504             image.copyOutsetFrom(getValue(builderState.parentStyle()));
 505             break;
 506         case Repeat:
 507             image.copyRepeatFrom(getValue(builderState.parentStyle()));
 508             break;
 509         case Slice:
 510             image.copyImageSlicesFrom(getValue(builderState.parentStyle()));
 511             break;
 512         case Width:
 513             image.copyBorderSlicesFrom(getValue(builderState.parentStyle()));
 514             break;
 515         }
 516         setValue(builderState.style(), image);
 517     }
 518 
 519     static void applyInitialValue(BuilderState&amp; builderState)
 520     {
 521         NinePieceImage image(getValue(builderState.style()));
 522         switch (modifier) {
 523         case Outset:
 524             image.setOutset(LengthBox(0));
 525             break;
 526         case Repeat:
 527             image.setHorizontalRule(NinePieceImageRule::Stretch);
 528             image.setVerticalRule(NinePieceImageRule::Stretch);
 529             break;
 530         case Slice:
 531             // Masks have a different initial value for slices. Preserve the value of 0 for backwards compatibility.
 532             image.setImageSlices(type == BorderImage ? LengthBox(Length(100, Percent), Length(100, Percent), Length(100, Percent), Length(100, Percent)) : LengthBox());
 533             image.setFill(false);
 534             break;
 535         case Width:
 536             // FIXME: This is a local variable to work around a bug in the GCC 8.1 Address Sanitizer.
 537             // Might be slightly less efficient when the type is not BorderImage since this is unused in that case.
 538             // Should be switched back to a temporary when possible. See https://webkit.org/b/186980
 539             LengthBox lengthBox(Length(1, Relative), Length(1, Relative), Length(1, Relative), Length(1, Relative));
 540             // Masks have a different initial value for widths. They use an &#39;auto&#39; value rather than trying to fit to the border.
 541             image.setBorderSlices(type == BorderImage ? lengthBox : LengthBox());
 542             break;
 543         }
 544         setValue(builderState.style(), image);
 545     }
 546 
 547     static void applyValue(BuilderState&amp; builderState, CSSValue&amp; value)
 548     {
 549         NinePieceImage image(getValue(builderState.style()));
 550         switch (modifier) {
 551         case Outset:
 552             image.setOutset(builderState.styleMap().mapNinePieceImageQuad(value));
 553             break;
 554         case Repeat:
 555             builderState.styleMap().mapNinePieceImageRepeat(value, image);
 556             break;
 557         case Slice:
 558             builderState.styleMap().mapNinePieceImageSlice(value, image);
 559             break;
 560         case Width:
 561             image.setBorderSlices(builderState.styleMap().mapNinePieceImageQuad(value));
 562             break;
 563         }
 564         setValue(builderState.style(), image);
 565     }
 566 
 567 private:
 568     static const NinePieceImage&amp; getValue(const RenderStyle&amp; style)
 569     {
 570         return type == BorderImage ? style.borderImage() : style.maskBoxImage();
 571     }
 572 
 573     static void setValue(RenderStyle&amp; style, const NinePieceImage&amp; value)
 574     {
 575         return type == BorderImage ? style.setBorderImage(value) : style.setMaskBoxImage(value);
 576     }
 577 };
 578 
 579 #define DEFINE_BORDER_IMAGE_MODIFIER_HANDLER(type, modifier) \
 580 inline void BuilderCustom::applyInherit##type##modifier(BuilderState&amp; builderState) \
 581 { \
 582     ApplyPropertyBorderImageModifier&lt;type, modifier&gt;::applyInheritValue(builderState); \
 583 } \
 584 inline void BuilderCustom::applyInitial##type##modifier(BuilderState&amp; builderState) \
 585 { \
 586     ApplyPropertyBorderImageModifier&lt;type, modifier&gt;::applyInitialValue(builderState); \
 587 } \
 588 inline void BuilderCustom::applyValue##type##modifier(BuilderState&amp; builderState, CSSValue&amp; value) \
 589 { \
 590     ApplyPropertyBorderImageModifier&lt;type, modifier&gt;::applyValue(builderState, value); \
 591 }
 592 
 593 DEFINE_BORDER_IMAGE_MODIFIER_HANDLER(BorderImage, Outset)
 594 DEFINE_BORDER_IMAGE_MODIFIER_HANDLER(BorderImage, Repeat)
 595 DEFINE_BORDER_IMAGE_MODIFIER_HANDLER(BorderImage, Slice)
 596 DEFINE_BORDER_IMAGE_MODIFIER_HANDLER(BorderImage, Width)
 597 DEFINE_BORDER_IMAGE_MODIFIER_HANDLER(WebkitMaskBoxImage, Outset)
 598 DEFINE_BORDER_IMAGE_MODIFIER_HANDLER(WebkitMaskBoxImage, Repeat)
 599 DEFINE_BORDER_IMAGE_MODIFIER_HANDLER(WebkitMaskBoxImage, Slice)
 600 DEFINE_BORDER_IMAGE_MODIFIER_HANDLER(WebkitMaskBoxImage, Width)
 601 
 602 #if ENABLE(TEXT_AUTOSIZING)
 603 
 604 inline void BuilderCustom::applyInheritLineHeight(BuilderState&amp; builderState)
 605 {
 606     builderState.style().setLineHeight(Length { builderState.parentStyle().lineHeight() });
 607     builderState.style().setSpecifiedLineHeight(Length { builderState.parentStyle().specifiedLineHeight() });
 608 }
 609 
 610 inline void BuilderCustom::applyInitialLineHeight(BuilderState&amp; builderState)
 611 {
 612     builderState.style().setLineHeight(RenderStyle::initialLineHeight());
 613     builderState.style().setSpecifiedLineHeight(RenderStyle::initialSpecifiedLineHeight());
 614 }
 615 
 616 static inline float computeBaseSpecifiedFontSize(const Document&amp; document, const RenderStyle&amp; style, bool percentageAutosizingEnabled)
 617 {
 618     float result = style.specifiedFontSize();
 619     auto* frame = document.frame();
 620     if (frame &amp;&amp; style.textZoom() != TextZoom::Reset)
 621         result *= frame-&gt;textZoomFactor();
 622     result *= style.effectiveZoom();
 623     if (percentageAutosizingEnabled &amp;&amp; !document.settings().textAutosizingUsesIdempotentMode())
 624         result *= style.textSizeAdjust().multiplier();
 625     return result;
 626 }
 627 
 628 static inline float computeLineHeightMultiplierDueToFontSize(const Document&amp; document, const RenderStyle&amp; style, const CSSPrimitiveValue&amp; value)
 629 {
 630     bool percentageAutosizingEnabled = document.settings().textAutosizingEnabled() &amp;&amp; style.textSizeAdjust().isPercentage();
 631 
 632     if (value.isLength()) {
 633         auto minimumFontSize = document.settings().minimumFontSize();
 634         if (minimumFontSize &gt; 0) {
 635             auto specifiedFontSize = computeBaseSpecifiedFontSize(document, style, percentageAutosizingEnabled);
 636             // Small font sizes cause a preposterously large (near infinity) line-height. Add a fuzz-factor of 1px which opts out of
 637             // boosted line-height.
 638             if (specifiedFontSize &lt; minimumFontSize &amp;&amp; specifiedFontSize &gt;= 1) {
 639                 // FIXME: There are two settings which are relevant here: minimum font size, and minimum logical font size (as
 640                 // well as things like the zoom property, text zoom on the page, and text autosizing). The minimum logical font
 641                 // size is nonzero by default, and already incorporated into the computed font size, so if we just use the ratio
 642                 // of the computed : specified font size, it will be &gt; 1 in the cases where the minimum logical font size kicks
 643                 // in. In general, this is the right thing to do, however, this kind of blanket change is too risky to perform
 644                 // right now. https://bugs.webkit.org/show_bug.cgi?id=174570 tracks turning this on. For now, we can just pretend
 645                 // that the minimum font size is the only thing affecting the computed font size.
 646 
 647                 // This calculation matches the line-height computed size calculation in
 648                 // TextAutoSizing::Value::adjustTextNodeSizes().
 649                 auto scaleChange = minimumFontSize / specifiedFontSize;
 650                 return scaleChange;
 651             }
 652         }
 653     }
 654 
 655     if (percentageAutosizingEnabled &amp;&amp; !document.settings().textAutosizingUsesIdempotentMode())
 656         return style.textSizeAdjust().multiplier();
 657     return 1;
 658 }
 659 
 660 inline void BuilderCustom::applyValueLineHeight(BuilderState&amp; builderState, CSSValue&amp; value)
 661 {
 662     Optional&lt;Length&gt; lineHeight = BuilderConverter::convertLineHeight(builderState, value, 1);
 663     if (!lineHeight)
 664         return;
 665 
 666     Length computedLineHeight;
 667     if (lineHeight.value().isNegative())
 668         computedLineHeight = lineHeight.value();
 669     else {
 670         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 671         auto multiplier = computeLineHeightMultiplierDueToFontSize(builderState.document(), builderState.style(), primitiveValue);
 672         if (multiplier == 1)
 673             computedLineHeight = lineHeight.value();
 674         else
 675             computedLineHeight = BuilderConverter::convertLineHeight(builderState, value, multiplier).value();
 676     }
 677 
 678     builderState.style().setLineHeight(WTFMove(computedLineHeight));
 679     builderState.style().setSpecifiedLineHeight(WTFMove(lineHeight.value()));
 680 }
 681 
 682 #endif
 683 
 684 inline void BuilderCustom::applyInheritOutlineStyle(BuilderState&amp; builderState)
 685 {
 686     builderState.style().setOutlineStyleIsAuto(builderState.parentStyle().outlineStyleIsAuto());
 687     builderState.style().setOutlineStyle(builderState.parentStyle().outlineStyle());
 688 }
 689 
 690 inline void BuilderCustom::applyInitialOutlineStyle(BuilderState&amp; builderState)
 691 {
 692     builderState.style().setOutlineStyleIsAuto(RenderStyle::initialOutlineStyleIsAuto());
 693     builderState.style().setOutlineStyle(RenderStyle::initialBorderStyle());
 694 }
 695 
 696 inline void BuilderCustom::applyValueOutlineStyle(BuilderState&amp; builderState, CSSValue&amp; value)
 697 {
 698     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 699 
 700     builderState.style().setOutlineStyleIsAuto(primitiveValue);
 701     builderState.style().setOutlineStyle(primitiveValue);
 702 }
 703 
 704 inline void BuilderCustom::applyInitialClip(BuilderState&amp; builderState)
 705 {
 706     builderState.style().setClip(Length(), Length(), Length(), Length());
 707     builderState.style().setHasClip(false);
 708 }
 709 
 710 inline void BuilderCustom::applyInheritClip(BuilderState&amp; builderState)
 711 {
 712     auto&amp; parentStyle = builderState.parentStyle();
 713     if (!parentStyle.hasClip())
 714         return applyInitialClip(builderState);
 715     builderState.style().setClip(Length { parentStyle.clipTop() }, Length { parentStyle.clipRight() },
 716         Length { parentStyle.clipBottom() }, Length { parentStyle.clipLeft() });
 717     builderState.style().setHasClip(true);
 718 }
 719 
 720 inline void BuilderCustom::applyValueClip(BuilderState&amp; builderState, CSSValue&amp; value)
 721 {
 722     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 723     if (auto* rect = primitiveValue.rectValue()) {
 724         auto conversionData = builderState.cssToLengthConversionData();
 725         auto top = rect-&gt;top()-&gt;convertToLength&lt;FixedIntegerConversion | PercentConversion | AutoConversion&gt;(conversionData);
 726         auto right = rect-&gt;right()-&gt;convertToLength&lt;FixedIntegerConversion | PercentConversion | AutoConversion&gt;(conversionData);
 727         auto bottom = rect-&gt;bottom()-&gt;convertToLength&lt;FixedIntegerConversion | PercentConversion | AutoConversion&gt;(conversionData);
 728         auto left = rect-&gt;left()-&gt;convertToLength&lt;FixedIntegerConversion | PercentConversion | AutoConversion&gt;(conversionData);
 729         builderState.style().setClip(WTFMove(top), WTFMove(right), WTFMove(bottom), WTFMove(left));
 730         builderState.style().setHasClip(true);
 731     } else {
 732         ASSERT(primitiveValue.valueID() == CSSValueAuto);
 733         applyInitialClip(builderState);
 734     }
 735 }
 736 
 737 inline void BuilderCustom::applyValueWebkitLocale(BuilderState&amp; builderState, CSSValue&amp; value)
 738 {
 739     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 740 
 741     FontCascadeDescription fontDescription = builderState.style().fontDescription();
 742     if (primitiveValue.valueID() == CSSValueAuto)
 743         fontDescription.setLocale(nullAtom());
 744     else
 745         fontDescription.setLocale(primitiveValue.stringValue());
 746     builderState.setFontDescription(WTFMove(fontDescription));
 747 }
 748 
 749 inline void BuilderCustom::applyValueWritingMode(BuilderState&amp; builderState, CSSValue&amp; value)
 750 {
 751     builderState.setWritingMode(downcast&lt;CSSPrimitiveValue&gt;(value));
 752     builderState.style().setHasExplicitlySetWritingMode(true);
 753 }
 754 
 755 inline void BuilderCustom::applyValueWebkitTextOrientation(BuilderState&amp; builderState, CSSValue&amp; value)
 756 {
 757     builderState.setTextOrientation(downcast&lt;CSSPrimitiveValue&gt;(value));
 758 }
 759 
 760 #if ENABLE(TEXT_AUTOSIZING)
 761 inline void BuilderCustom::applyValueWebkitTextSizeAdjust(BuilderState&amp; builderState, CSSValue&amp; value)
 762 {
 763     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 764     if (primitiveValue.valueID() == CSSValueAuto)
 765         builderState.style().setTextSizeAdjust(TextSizeAdjustment(AutoTextSizeAdjustment));
 766     else if (primitiveValue.valueID() == CSSValueNone)
 767         builderState.style().setTextSizeAdjust(TextSizeAdjustment(NoTextSizeAdjustment));
 768     else
 769         builderState.style().setTextSizeAdjust(TextSizeAdjustment(primitiveValue.floatValue()));
 770 
 771     builderState.setFontDirty();
 772 }
 773 #endif
 774 
 775 inline void BuilderCustom::applyValueWebkitTextZoom(BuilderState&amp; builderState, CSSValue&amp; value)
 776 {
 777     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
 778     if (primitiveValue.valueID() == CSSValueNormal)
 779         builderState.style().setTextZoom(TextZoom::Normal);
 780     else if (primitiveValue.valueID() == CSSValueReset)
 781         builderState.style().setTextZoom(TextZoom::Reset);
 782     builderState.setFontDirty();
 783 }
 784 
 785 #if ENABLE(DARK_MODE_CSS)
 786 inline void BuilderCustom::applyValueColorScheme(BuilderState&amp; builderState, CSSValue&amp; value)
 787 {
 788     builderState.style().setColorScheme(BuilderConverter::convertColorScheme(builderState, value));
 789     builderState.style().setHasExplicitlySetColorScheme(true);
 790 }
 791 #endif
 792 
 793 template&lt;CSSPropertyID property&gt;
 794 inline void BuilderCustom::applyTextOrBoxShadowValue(BuilderState&amp; builderState, CSSValue&amp; value)
 795 {
 796     if (is&lt;CSSPrimitiveValue&gt;(value)) {
 797         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone);
 798         if (property == CSSPropertyTextShadow)
 799             builderState.style().setTextShadow(nullptr);
 800         else
 801             builderState.style().setBoxShadow(nullptr);
 802         return;
 803     }
 804 
 805     bool isFirstEntry = true;
 806     for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {
 807         auto&amp; shadowValue = downcast&lt;CSSShadowValue&gt;(item.get());
 808         auto conversionData = builderState.cssToLengthConversionData();
 809         auto x = shadowValue.x-&gt;computeLength&lt;LayoutUnit&gt;(conversionData);
 810         auto y = shadowValue.y-&gt;computeLength&lt;LayoutUnit&gt;(conversionData);
 811         int blur = shadowValue.blur ? shadowValue.blur-&gt;computeLength&lt;int&gt;(conversionData) : 0;
 812         auto spread = shadowValue.spread ? shadowValue.spread-&gt;computeLength&lt;LayoutUnit&gt;(conversionData) : LayoutUnit(0);
 813         ShadowStyle shadowStyle = shadowValue.style &amp;&amp; shadowValue.style-&gt;valueID() == CSSValueInset ? ShadowStyle::Inset : ShadowStyle::Normal;
 814         Color color;
 815         if (shadowValue.color)
 816             color = builderState.colorFromPrimitiveValue(*shadowValue.color);
 817         else
 818             color = builderState.style().color();
 819         auto shadowData = makeUnique&lt;ShadowData&gt;(LayoutPoint(x, y), blur, spread, shadowStyle, property == CSSPropertyWebkitBoxShadow, color.isValid() ? color : Color::transparent);
 820         if (property == CSSPropertyTextShadow)
 821             builderState.style().setTextShadow(WTFMove(shadowData), !isFirstEntry); // add to the list if this is not the first entry
 822         else
 823             builderState.style().setBoxShadow(WTFMove(shadowData), !isFirstEntry); // add to the list if this is not the first entry
 824         isFirstEntry = false;
 825     }
 826 }
 827 
 828 inline void BuilderCustom::applyInitialTextShadow(BuilderState&amp; builderState)
 829 {
 830     builderState.style().setTextShadow(nullptr);
 831 }
 832 
 833 inline void BuilderCustom::applyInheritTextShadow(BuilderState&amp; builderState)
 834 {
 835     builderState.style().setTextShadow(builderState.parentStyle().textShadow() ? makeUnique&lt;ShadowData&gt;(*builderState.parentStyle().textShadow()) : nullptr);
 836 }
 837 
 838 inline void BuilderCustom::applyValueTextShadow(BuilderState&amp; builderState, CSSValue&amp; value)
 839 {
 840     applyTextOrBoxShadowValue&lt;CSSPropertyTextShadow&gt;(builderState, value);
 841 }
 842 
 843 inline void BuilderCustom::applyInitialBoxShadow(BuilderState&amp; builderState)
 844 {
 845     builderState.style().setBoxShadow(nullptr);
 846 }
 847 
 848 inline void BuilderCustom::applyInheritBoxShadow(BuilderState&amp; builderState)
 849 {
 850     builderState.style().setBoxShadow(builderState.parentStyle().boxShadow() ? makeUnique&lt;ShadowData&gt;(*builderState.parentStyle().boxShadow()) : nullptr);
 851 }
 852 
 853 inline void BuilderCustom::applyValueBoxShadow(BuilderState&amp; builderState, CSSValue&amp; value)
 854 {
 855     applyTextOrBoxShadowValue&lt;CSSPropertyBoxShadow&gt;(builderState, value);
 856 }
 857 
 858 inline void BuilderCustom::applyInitialWebkitBoxShadow(BuilderState&amp; builderState)
 859 {
 860     applyInitialBoxShadow(builderState);
 861 }
 862 
 863 inline void BuilderCustom::applyInheritWebkitBoxShadow(BuilderState&amp; builderState)
 864 {
 865     applyInheritBoxShadow(builderState);
 866 }
 867 
 868 inline void BuilderCustom::applyValueWebkitBoxShadow(BuilderState&amp; builderState, CSSValue&amp; value)
 869 {
 870     applyTextOrBoxShadowValue&lt;CSSPropertyWebkitBoxShadow&gt;(builderState, value);
 871 }
 872 
 873 inline void BuilderCustom::applyInitialFontFamily(BuilderState&amp; builderState)
 874 {
 875     auto fontDescription = builderState.style().fontDescription();
 876     auto initialDesc = FontCascadeDescription();
 877 
 878     // We need to adjust the size to account for the generic family change from monospace to non-monospace.
 879     if (fontDescription.useFixedDefaultSize()) {
 880         if (CSSValueID sizeIdentifier = fontDescription.keywordSizeAsIdentifier())
 881             builderState.setFontSize(fontDescription, Style::fontSizeForKeyword(sizeIdentifier, false, builderState.document()));
 882     }
 883     if (!initialDesc.firstFamily().isEmpty())
 884         fontDescription.setFamilies(initialDesc.families());
 885 
 886     builderState.setFontDescription(WTFMove(fontDescription));
 887 }
 888 
 889 inline void BuilderCustom::applyInheritFontFamily(BuilderState&amp; builderState)
 890 {
 891     auto fontDescription = builderState.style().fontDescription();
 892     auto parentFontDescription = builderState.parentStyle().fontDescription();
 893 
 894     fontDescription.setFamilies(parentFontDescription.families());
 895     fontDescription.setIsSpecifiedFont(parentFontDescription.isSpecifiedFont());
 896     builderState.setFontDescription(WTFMove(fontDescription));
 897 }
 898 
 899 inline void BuilderCustom::applyValueFontFamily(BuilderState&amp; builderState, CSSValue&amp; value)
 900 {
 901     auto&amp; valueList = downcast&lt;CSSValueList&gt;(value);
 902 
 903     auto fontDescription = builderState.style().fontDescription();
 904     // Before mapping in a new font-family property, we should reset the generic family.
 905     bool oldFamilyUsedFixedDefaultSize = fontDescription.useFixedDefaultSize();
 906 
 907     Vector&lt;AtomString&gt; families;
 908     families.reserveInitialCapacity(valueList.length());
 909 
 910     for (auto&amp; item : valueList) {
 911         auto&amp; contentValue = downcast&lt;CSSPrimitiveValue&gt;(item.get());
 912         AtomString family;
 913         bool isGenericFamily = false;
 914         if (contentValue.isFontFamily()) {
 915             const CSSFontFamily&amp; fontFamily = contentValue.fontFamily();
 916             family = fontFamily.familyName;
 917             // If the family name was resolved by the CSS parser from a system font ID, then it is generic.
 918             isGenericFamily = fontFamily.fromSystemFontID;
 919         } else {
 920             switch (contentValue.valueID()) {
 921             case CSSValueWebkitBody:
 922                 family = builderState.document().settings().standardFontFamily();
 923                 break;
 924             case CSSValueSerif:
 925                 family = serifFamily;
 926                 isGenericFamily = true;
 927                 break;
 928             case CSSValueSansSerif:
 929                 family = sansSerifFamily;
 930                 isGenericFamily = true;
 931                 break;
 932             case CSSValueCursive:
 933                 family = cursiveFamily;
 934                 isGenericFamily = true;
 935                 break;
 936             case CSSValueFantasy:
 937                 family = fantasyFamily;
 938                 isGenericFamily = true;
 939                 break;
 940             case CSSValueMonospace:
 941                 family = monospaceFamily;
 942                 isGenericFamily = true;
 943                 break;
 944             case CSSValueWebkitPictograph:
 945                 family = pictographFamily;
 946                 isGenericFamily = true;
 947                 break;
 948             case CSSValueSystemUi:
 949                 family = systemUiFamily;
 950                 isGenericFamily = true;
 951                 break;
 952             default:
 953                 break;
 954             }
 955         }
 956 
 957         if (family.isEmpty())
 958             continue;
 959         if (families.isEmpty())
 960             fontDescription.setIsSpecifiedFont(!isGenericFamily);
 961         families.uncheckedAppend(family);
 962     }
 963 
 964     if (families.isEmpty())
 965         return;
 966     fontDescription.setFamilies(families);
 967 
 968     if (fontDescription.useFixedDefaultSize() != oldFamilyUsedFixedDefaultSize) {
 969         if (CSSValueID sizeIdentifier = fontDescription.keywordSizeAsIdentifier())
 970             builderState.setFontSize(fontDescription, Style::fontSizeForKeyword(sizeIdentifier, !oldFamilyUsedFixedDefaultSize, builderState.document()));
 971     }
 972 
 973     builderState.setFontDescription(WTFMove(fontDescription));
 974 }
 975 
 976 inline bool BuilderCustom::isValidDisplayValue(BuilderState&amp; builderState, DisplayType display)
 977 {
 978     if (is&lt;SVGElement&gt;(builderState.element()) &amp;&amp; builderState.style().styleType() == PseudoId::None)
 979         return display == DisplayType::Inline || display == DisplayType::Block || display == DisplayType::None;
 980     return true;
 981 }
 982 
 983 inline void BuilderCustom::applyInheritDisplay(BuilderState&amp; builderState)
 984 {
 985     DisplayType display = builderState.parentStyle().display();
 986     if (isValidDisplayValue(builderState, display))
 987         builderState.style().setDisplay(display);
 988 }
 989 
 990 inline void BuilderCustom::applyValueDisplay(BuilderState&amp; builderState, CSSValue&amp; value)
 991 {
 992     DisplayType display = downcast&lt;CSSPrimitiveValue&gt;(value);
 993     if (isValidDisplayValue(builderState, display))
 994         builderState.style().setDisplay(display);
 995 }
 996 
 997 inline void BuilderCustom::applyValueBaselineShift(BuilderState&amp; builderState, CSSValue&amp; value)
 998 {
 999     SVGRenderStyle&amp; svgStyle = builderState.style().accessSVGStyle();
1000     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1001     if (primitiveValue.isValueID()) {
1002         switch (primitiveValue.valueID()) {
1003         case CSSValueBaseline:
1004             svgStyle.setBaselineShift(BaselineShift::Baseline);
1005             break;
1006         case CSSValueSub:
1007             svgStyle.setBaselineShift(BaselineShift::Sub);
1008             break;
1009         case CSSValueSuper:
1010             svgStyle.setBaselineShift(BaselineShift::Super);
1011             break;
1012         default:
1013             break;
1014         }
1015     } else {
1016         svgStyle.setBaselineShift(BaselineShift::Length);
1017         svgStyle.setBaselineShiftValue(SVGLengthValue::fromCSSPrimitiveValue(primitiveValue));
1018     }
1019 }
1020 
1021 inline void BuilderCustom::applyInitialWebkitAspectRatio(BuilderState&amp; builderState)
1022 {
1023     builderState.style().setAspectRatioType(RenderStyle::initialAspectRatioType());
1024     builderState.style().setAspectRatioDenominator(RenderStyle::initialAspectRatioDenominator());
1025     builderState.style().setAspectRatioNumerator(RenderStyle::initialAspectRatioNumerator());
1026 }
1027 
1028 inline void BuilderCustom::applyInheritWebkitAspectRatio(BuilderState&amp; builderState)
1029 {
1030     if (builderState.parentStyle().aspectRatioType() == AspectRatioType::Auto)
1031         return;
1032     builderState.style().setAspectRatioType(builderState.parentStyle().aspectRatioType());
1033     builderState.style().setAspectRatioDenominator(builderState.parentStyle().aspectRatioDenominator());
1034     builderState.style().setAspectRatioNumerator(builderState.parentStyle().aspectRatioNumerator());
1035 }
1036 
1037 inline void BuilderCustom::applyValueWebkitAspectRatio(BuilderState&amp; builderState, CSSValue&amp; value)
1038 {
1039     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1040         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1041 
1042         if (primitiveValue.valueID() == CSSValueFromDimensions)
1043             return builderState.style().setAspectRatioType(AspectRatioType::FromDimensions);
1044         if (primitiveValue.valueID() == CSSValueFromIntrinsic)
1045             return builderState.style().setAspectRatioType(AspectRatioType::FromIntrinsic);
1046 
1047         ASSERT(primitiveValue.valueID() == CSSValueAuto);
1048         return builderState.style().setAspectRatioType(AspectRatioType::Auto);
1049     }
1050 
1051     auto&amp; aspectRatioValue = downcast&lt;CSSAspectRatioValue&gt;(value);
1052     builderState.style().setAspectRatioType(AspectRatioType::Specified);
1053     builderState.style().setAspectRatioDenominator(aspectRatioValue.denominatorValue());
1054     builderState.style().setAspectRatioNumerator(aspectRatioValue.numeratorValue());
1055 }
1056 
1057 inline void BuilderCustom::applyInitialWebkitTextEmphasisStyle(BuilderState&amp; builderState)
1058 {
1059     builderState.style().setTextEmphasisFill(RenderStyle::initialTextEmphasisFill());
1060     builderState.style().setTextEmphasisMark(RenderStyle::initialTextEmphasisMark());
1061     builderState.style().setTextEmphasisCustomMark(RenderStyle::initialTextEmphasisCustomMark());
1062 }
1063 
1064 inline void BuilderCustom::applyInheritWebkitTextEmphasisStyle(BuilderState&amp; builderState)
1065 {
1066     builderState.style().setTextEmphasisFill(builderState.parentStyle().textEmphasisFill());
1067     builderState.style().setTextEmphasisMark(builderState.parentStyle().textEmphasisMark());
1068     builderState.style().setTextEmphasisCustomMark(builderState.parentStyle().textEmphasisCustomMark());
1069 }
1070 
1071 inline void BuilderCustom::applyValueWebkitTextEmphasisStyle(BuilderState&amp; builderState, CSSValue&amp; value)
1072 {
1073     if (is&lt;CSSValueList&gt;(value)) {
1074         auto&amp; list = downcast&lt;CSSValueList&gt;(value);
1075         ASSERT(list.length() == 2);
1076 
1077         for (auto&amp; item : list) {
1078             CSSPrimitiveValue&amp; value = downcast&lt;CSSPrimitiveValue&gt;(item.get());
1079             if (value.valueID() == CSSValueFilled || value.valueID() == CSSValueOpen)
1080                 builderState.style().setTextEmphasisFill(value);
1081             else
1082                 builderState.style().setTextEmphasisMark(value);
1083         }
1084         builderState.style().setTextEmphasisCustomMark(nullAtom());
1085         return;
1086     }
1087 
1088     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1089     if (primitiveValue.isString()) {
1090         builderState.style().setTextEmphasisFill(TextEmphasisFill::Filled);
1091         builderState.style().setTextEmphasisMark(TextEmphasisMark::Custom);
1092         builderState.style().setTextEmphasisCustomMark(primitiveValue.stringValue());
1093         return;
1094     }
1095 
1096     builderState.style().setTextEmphasisCustomMark(nullAtom());
1097 
1098     if (primitiveValue.valueID() == CSSValueFilled || primitiveValue.valueID() == CSSValueOpen) {
1099         builderState.style().setTextEmphasisFill(primitiveValue);
1100         builderState.style().setTextEmphasisMark(TextEmphasisMark::Auto);
1101     } else {
1102         builderState.style().setTextEmphasisFill(TextEmphasisFill::Filled);
1103         builderState.style().setTextEmphasisMark(primitiveValue);
1104     }
1105 }
1106 
1107 template &lt;BuilderCustom::CounterBehavior counterBehavior&gt;
1108 inline void BuilderCustom::applyInheritCounter(BuilderState&amp; builderState)
1109 {
1110     auto&amp; map = builderState.style().accessCounterDirectives();
1111     for (auto&amp; keyValue : const_cast&lt;RenderStyle&amp;&gt;(builderState.parentStyle()).accessCounterDirectives()) {
1112         auto&amp; directives = map.add(keyValue.key, CounterDirectives { }).iterator-&gt;value;
1113         if (counterBehavior == Reset)
1114             directives.resetValue = keyValue.value.resetValue;
1115         else
1116             directives.incrementValue = keyValue.value.incrementValue;
1117     }
1118 }
1119 
1120 template &lt;BuilderCustom::CounterBehavior counterBehavior&gt;
1121 inline void BuilderCustom::applyValueCounter(BuilderState&amp; builderState, CSSValue&amp; value)
1122 {
1123     bool setCounterIncrementToNone = counterBehavior == Increment &amp;&amp; is&lt;CSSPrimitiveValue&gt;(value) &amp;&amp; downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone;
1124 
1125     if (!is&lt;CSSValueList&gt;(value) &amp;&amp; !setCounterIncrementToNone)
1126         return;
1127 
1128     CounterDirectiveMap&amp; map = builderState.style().accessCounterDirectives();
1129     for (auto&amp; keyValue : map) {
1130         if (counterBehavior == Reset)
1131             keyValue.value.resetValue = WTF::nullopt;
1132         else
1133             keyValue.value.incrementValue = WTF::nullopt;
1134     }
1135 
1136     if (setCounterIncrementToNone)
1137         return;
1138 
1139     for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {
1140         Pair* pair = downcast&lt;CSSPrimitiveValue&gt;(item.get()).pairValue();
1141         AtomString identifier = pair-&gt;first()-&gt;stringValue();
1142         int value = pair-&gt;second()-&gt;intValue();
1143         auto&amp; directives = map.add(identifier, CounterDirectives { }).iterator-&gt;value;
1144         if (counterBehavior == Reset)
1145             directives.resetValue = value;
1146         else
1147             directives.incrementValue = saturatedAddition(directives.incrementValue.valueOr(0), value);
1148     }
1149 }
1150 
1151 inline void BuilderCustom::applyInitialCounterIncrement(BuilderState&amp;) { }
1152 
1153 inline void BuilderCustom::applyInheritCounterIncrement(BuilderState&amp; builderState)
1154 {
1155     applyInheritCounter&lt;Increment&gt;(builderState);
1156 }
1157 
1158 inline void BuilderCustom::applyValueCounterIncrement(BuilderState&amp; builderState, CSSValue&amp; value)
1159 {
1160     applyValueCounter&lt;Increment&gt;(builderState, value);
1161 }
1162 
1163 inline void BuilderCustom::applyInitialCounterReset(BuilderState&amp;) { }
1164 
1165 inline void BuilderCustom::applyInheritCounterReset(BuilderState&amp; builderState)
1166 {
1167     applyInheritCounter&lt;Reset&gt;(builderState);
1168 }
1169 
1170 inline void BuilderCustom::applyValueCounterReset(BuilderState&amp; builderState, CSSValue&amp; value)
1171 {
1172     applyValueCounter&lt;Reset&gt;(builderState, value);
1173 }
1174 
1175 inline void BuilderCustom::applyInitialCursor(BuilderState&amp; builderState)
1176 {
1177     builderState.style().clearCursorList();
1178     builderState.style().setCursor(RenderStyle::initialCursor());
1179 }
1180 
1181 inline void BuilderCustom::applyInheritCursor(BuilderState&amp; builderState)
1182 {
1183     builderState.style().setCursor(builderState.parentStyle().cursor());
1184     builderState.style().setCursorList(builderState.parentStyle().cursors());
1185 }
1186 
1187 inline void BuilderCustom::applyValueCursor(BuilderState&amp; builderState, CSSValue&amp; value)
1188 {
1189     builderState.style().clearCursorList();
1190     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1191         CursorType cursor = downcast&lt;CSSPrimitiveValue&gt;(value);
1192         if (builderState.style().cursor() != cursor)
1193             builderState.style().setCursor(cursor);
1194         return;
1195     }
1196 
1197     builderState.style().setCursor(CursorType::Auto);
1198     auto&amp; list = downcast&lt;CSSValueList&gt;(value);
1199     for (auto&amp; item : list) {
1200         if (is&lt;CSSCursorImageValue&gt;(item)) {
1201             auto&amp; image = downcast&lt;CSSCursorImageValue&gt;(item.get());
1202             builderState.style().addCursor(builderState.createStyleImage(image), image.hotSpot());
1203             continue;
1204         }
1205 
1206         builderState.style().setCursor(downcast&lt;CSSPrimitiveValue&gt;(item.get()));
1207         ASSERT_WITH_MESSAGE(item.ptr() == list.item(list.length() - 1), &quot;Cursor ID fallback should always be last in the list&quot;);
1208         return;
1209     }
1210 }
1211 
1212 inline void BuilderCustom::applyInitialFill(BuilderState&amp; builderState)
1213 {
1214     auto&amp; svgStyle = builderState.style().accessSVGStyle();
1215     svgStyle.setFillPaint(SVGRenderStyle::initialFillPaintType(), SVGRenderStyle::initialFillPaintColor(), SVGRenderStyle::initialFillPaintUri(), builderState.applyPropertyToRegularStyle(), builderState.applyPropertyToVisitedLinkStyle());
1216 }
1217 
1218 inline void BuilderCustom::applyInheritFill(BuilderState&amp; builderState)
1219 {
1220     auto&amp; svgStyle = builderState.style().accessSVGStyle();
1221     auto&amp; svgParentStyle = builderState.parentStyle().svgStyle();
1222     svgStyle.setFillPaint(svgParentStyle.fillPaintType(), svgParentStyle.fillPaintColor(), svgParentStyle.fillPaintUri(), builderState.applyPropertyToRegularStyle(), builderState.applyPropertyToVisitedLinkStyle());
1223 
1224 }
1225 
1226 inline void BuilderCustom::applyValueFill(BuilderState&amp; builderState, CSSValue&amp; value)
1227 {
1228     auto&amp; svgStyle = builderState.style().accessSVGStyle();
1229     const auto* localValue = value.isPrimitiveValue() ? &amp;downcast&lt;CSSPrimitiveValue&gt;(value) : nullptr;
1230     String url;
1231     if (value.isValueList()) {
1232         const CSSValueList&amp; list = downcast&lt;CSSValueList&gt;(value);
1233         url = downcast&lt;CSSPrimitiveValue&gt;(list.item(0))-&gt;stringValue();
1234         localValue = downcast&lt;CSSPrimitiveValue&gt;(list.item(1));
1235     }
1236 
1237     if (!localValue)
1238         return;
1239 
1240     Color color;
1241     auto paintType = SVGPaintType::RGBColor;
1242     if (localValue-&gt;isURI()) {
1243         paintType = SVGPaintType::URI;
1244         url = localValue-&gt;stringValue();
1245     } else if (localValue-&gt;isValueID() &amp;&amp; localValue-&gt;valueID() == CSSValueNone)
1246         paintType = url.isEmpty() ? SVGPaintType::None : SVGPaintType::URINone;
1247     else if (localValue-&gt;isValueID() &amp;&amp; localValue-&gt;valueID() == CSSValueCurrentcolor) {
1248         color = builderState.style().color();
1249         paintType = url.isEmpty() ? SVGPaintType::CurrentColor : SVGPaintType::URICurrentColor;
1250     } else {
1251         color = builderState.colorFromPrimitiveValue(*localValue);
1252         paintType = url.isEmpty() ? SVGPaintType::RGBColor : SVGPaintType::URIRGBColor;
1253     }
1254     svgStyle.setFillPaint(paintType, color, url, builderState.applyPropertyToRegularStyle(), builderState.applyPropertyToVisitedLinkStyle());
1255 }
1256 
1257 inline void BuilderCustom::applyInitialStroke(BuilderState&amp; builderState)
1258 {
1259     SVGRenderStyle&amp; svgStyle = builderState.style().accessSVGStyle();
1260     svgStyle.setStrokePaint(SVGRenderStyle::initialStrokePaintType(), SVGRenderStyle::initialStrokePaintColor(), SVGRenderStyle::initialStrokePaintUri(), builderState.applyPropertyToRegularStyle(), builderState.applyPropertyToVisitedLinkStyle());
1261 }
1262 
1263 inline void BuilderCustom::applyInheritStroke(BuilderState&amp; builderState)
1264 {
1265     auto&amp; svgStyle = builderState.style().accessSVGStyle();
1266     auto&amp; svgParentStyle = builderState.parentStyle().svgStyle();
1267     svgStyle.setStrokePaint(svgParentStyle.strokePaintType(), svgParentStyle.strokePaintColor(), svgParentStyle.strokePaintUri(), builderState.applyPropertyToRegularStyle(), builderState.applyPropertyToVisitedLinkStyle());
1268 }
1269 
1270 inline void BuilderCustom::applyValueStroke(BuilderState&amp; builderState, CSSValue&amp; value)
1271 {
1272     auto&amp; svgStyle = builderState.style().accessSVGStyle();
1273     const auto* localValue = value.isPrimitiveValue() ? &amp;downcast&lt;CSSPrimitiveValue&gt;(value) : nullptr;
1274     String url;
1275     if (value.isValueList()) {
1276         const CSSValueList&amp; list = downcast&lt;CSSValueList&gt;(value);
1277         url = downcast&lt;CSSPrimitiveValue&gt;(list.item(0))-&gt;stringValue();
1278         localValue = downcast&lt;CSSPrimitiveValue&gt;(list.item(1));
1279     }
1280 
1281     if (!localValue)
1282         return;
1283 
1284     Color color;
1285     auto paintType = SVGPaintType::RGBColor;
1286     if (localValue-&gt;isURI()) {
1287         paintType = SVGPaintType::URI;
1288         url = downcast&lt;CSSPrimitiveValue&gt;(localValue)-&gt;stringValue();
1289     } else if (localValue-&gt;isValueID() &amp;&amp; localValue-&gt;valueID() == CSSValueNone)
1290         paintType = url.isEmpty() ? SVGPaintType::None : SVGPaintType::URINone;
1291     else if (localValue-&gt;isValueID() &amp;&amp; localValue-&gt;valueID() == CSSValueCurrentcolor) {
1292         color = builderState.style().color();
1293         paintType = url.isEmpty() ? SVGPaintType::CurrentColor : SVGPaintType::URICurrentColor;
1294     } else {
1295         color = builderState.colorFromPrimitiveValue(*localValue);
1296         paintType = url.isEmpty() ? SVGPaintType::RGBColor : SVGPaintType::URIRGBColor;
1297     }
1298     svgStyle.setStrokePaint(paintType, color, url, builderState.applyPropertyToRegularStyle(), builderState.applyPropertyToVisitedLinkStyle());
1299 }
1300 
1301 inline void BuilderCustom::applyInitialContent(BuilderState&amp; builderState)
1302 {
1303     builderState.style().clearContent();
1304 }
1305 
1306 inline void BuilderCustom::applyInheritContent(BuilderState&amp;)
1307 {
1308     // FIXME: In CSS3, it will be possible to inherit content. In CSS2 it is not. This
1309     // note is a reminder that eventually &quot;inherit&quot; needs to be supported.
1310 }
1311 
1312 inline void BuilderCustom::applyValueContent(BuilderState&amp; builderState, CSSValue&amp; value)
1313 {
1314     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1315         const auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1316         ASSERT_UNUSED(primitiveValue, primitiveValue.valueID() == CSSValueNormal || primitiveValue.valueID() == CSSValueNone);
1317         builderState.style().clearContent();
1318         return;
1319     }
1320 
1321     bool didSet = false;
1322     for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {
1323         if (is&lt;CSSImageGeneratorValue&gt;(item)) {
1324             if (is&lt;CSSGradientValue&gt;(item))
1325                 builderState.style().setContent(StyleGeneratedImage::create(downcast&lt;CSSGradientValue&gt;(item.get()).gradientWithStylesResolved(builderState)), didSet);
1326             else
1327                 builderState.style().setContent(StyleGeneratedImage::create(downcast&lt;CSSImageGeneratorValue&gt;(item.get())), didSet);
1328             didSet = true;
1329         }
1330 
1331         if (is&lt;CSSImageSetValue&gt;(item)) {
1332             builderState.style().setContent(StyleImageSet::create(downcast&lt;CSSImageSetValue&gt;(item.get()).imageSetWithStylesResolved(builderState)), didSet);
1333             didSet = true;
1334         }
1335 
1336         if (is&lt;CSSImageValue&gt;(item)) {
1337             builderState.style().setContent(StyleCachedImage::create(downcast&lt;CSSImageValue&gt;(item.get())), didSet);
1338             didSet = true;
1339             continue;
1340         }
1341 
1342         if (!is&lt;CSSPrimitiveValue&gt;(item))
1343             continue;
1344 
1345         auto&amp; contentValue = downcast&lt;CSSPrimitiveValue&gt;(item.get());
1346         if (contentValue.isString()) {
1347             builderState.style().setContent(contentValue.stringValue().impl(), didSet);
1348             didSet = true;
1349         } else if (contentValue.isAttr()) {
1350             // FIXME: Can a namespace be specified for an attr(foo)?
1351             if (builderState.style().styleType() == PseudoId::None)
1352                 builderState.style().setHasAttrContent();
1353             else
1354                 const_cast&lt;RenderStyle&amp;&gt;(builderState.parentStyle()).setHasAttrContent();
1355             QualifiedName attr(nullAtom(), contentValue.stringValue().impl(), nullAtom());
1356             const AtomString&amp; value = builderState.element() ? builderState.element()-&gt;getAttribute(attr) : nullAtom();
1357             builderState.style().setContent(value.isNull() ? emptyAtom() : value.impl(), didSet);
1358             didSet = true;
1359             // Register the fact that the attribute value affects the style.
1360             builderState.registerContentAttribute(attr.localName());
1361         } else if (contentValue.isCounter()) {
1362             auto* counterValue = contentValue.counterValue();
1363             ListStyleType listStyleType = ListStyleType::None;
1364             CSSValueID listStyleIdent = counterValue-&gt;listStyleIdent();
1365             if (listStyleIdent != CSSValueNone)
1366                 listStyleType = static_cast&lt;ListStyleType&gt;(listStyleIdent - CSSValueDisc);
1367             auto counter = makeUnique&lt;CounterContent&gt;(counterValue-&gt;identifier(), listStyleType, counterValue-&gt;separator());
1368             builderState.style().setContent(WTFMove(counter), didSet);
1369             didSet = true;
1370         } else {
1371             switch (contentValue.valueID()) {
1372             case CSSValueOpenQuote:
1373                 builderState.style().setContent(QuoteType::OpenQuote, didSet);
1374                 didSet = true;
1375                 break;
1376             case CSSValueCloseQuote:
1377                 builderState.style().setContent(QuoteType::CloseQuote, didSet);
1378                 didSet = true;
1379                 break;
1380             case CSSValueNoOpenQuote:
1381                 builderState.style().setContent(QuoteType::NoOpenQuote, didSet);
1382                 didSet = true;
1383                 break;
1384             case CSSValueNoCloseQuote:
1385                 builderState.style().setContent(QuoteType::NoCloseQuote, didSet);
1386                 didSet = true;
1387                 break;
1388             default:
1389                 // normal and none do not have any effect.
1390                 break;
1391             }
1392         }
1393     }
1394     if (!didSet)
1395         builderState.style().clearContent();
1396 }
1397 
1398 inline void BuilderCustom::applyInheritFontVariantLigatures(BuilderState&amp; builderState)
1399 {
1400     auto fontDescription = builderState.fontDescription();
1401     fontDescription.setVariantCommonLigatures(builderState.parentFontDescription().variantCommonLigatures());
1402     fontDescription.setVariantDiscretionaryLigatures(builderState.parentFontDescription().variantDiscretionaryLigatures());
1403     fontDescription.setVariantHistoricalLigatures(builderState.parentFontDescription().variantHistoricalLigatures());
1404     fontDescription.setVariantContextualAlternates(builderState.parentFontDescription().variantContextualAlternates());
1405     builderState.setFontDescription(WTFMove(fontDescription));
1406 }
1407 
1408 inline void BuilderCustom::applyInitialFontVariantLigatures(BuilderState&amp; builderState)
1409 {
1410     auto fontDescription = builderState.fontDescription();
1411     fontDescription.setVariantCommonLigatures(FontVariantLigatures::Normal);
1412     fontDescription.setVariantDiscretionaryLigatures(FontVariantLigatures::Normal);
1413     fontDescription.setVariantHistoricalLigatures(FontVariantLigatures::Normal);
1414     fontDescription.setVariantContextualAlternates(FontVariantLigatures::Normal);
1415     builderState.setFontDescription(WTFMove(fontDescription));
1416 }
1417 
1418 inline void BuilderCustom::applyValueFontVariantLigatures(BuilderState&amp; builderState, CSSValue&amp; value)
1419 {
1420     auto fontDescription = builderState.fontDescription();
1421     auto variantLigatures = extractFontVariantLigatures(value);
1422     fontDescription.setVariantCommonLigatures(variantLigatures.commonLigatures);
1423     fontDescription.setVariantDiscretionaryLigatures(variantLigatures.discretionaryLigatures);
1424     fontDescription.setVariantHistoricalLigatures(variantLigatures.historicalLigatures);
1425     fontDescription.setVariantContextualAlternates(variantLigatures.contextualAlternates);
1426     builderState.setFontDescription(WTFMove(fontDescription));
1427 }
1428 
1429 inline void BuilderCustom::applyInheritFontVariantNumeric(BuilderState&amp; builderState)
1430 {
1431     auto fontDescription = builderState.fontDescription();
1432     fontDescription.setVariantNumericFigure(builderState.parentFontDescription().variantNumericFigure());
1433     fontDescription.setVariantNumericSpacing(builderState.parentFontDescription().variantNumericSpacing());
1434     fontDescription.setVariantNumericFraction(builderState.parentFontDescription().variantNumericFraction());
1435     fontDescription.setVariantNumericOrdinal(builderState.parentFontDescription().variantNumericOrdinal());
1436     fontDescription.setVariantNumericSlashedZero(builderState.parentFontDescription().variantNumericSlashedZero());
1437     builderState.setFontDescription(WTFMove(fontDescription));
1438 }
1439 
1440 inline void BuilderCustom::applyInitialFontVariantNumeric(BuilderState&amp; builderState)
1441 {
1442     auto fontDescription = builderState.fontDescription();
1443     fontDescription.setVariantNumericFigure(FontVariantNumericFigure::Normal);
1444     fontDescription.setVariantNumericSpacing(FontVariantNumericSpacing::Normal);
1445     fontDescription.setVariantNumericFraction(FontVariantNumericFraction::Normal);
1446     fontDescription.setVariantNumericOrdinal(FontVariantNumericOrdinal::Normal);
1447     fontDescription.setVariantNumericSlashedZero(FontVariantNumericSlashedZero::Normal);
1448     builderState.setFontDescription(WTFMove(fontDescription));
1449 }
1450 
1451 inline void BuilderCustom::applyValueFontVariantNumeric(BuilderState&amp; builderState, CSSValue&amp; value)
1452 {
1453     auto fontDescription = builderState.fontDescription();
1454     auto variantNumeric = extractFontVariantNumeric(value);
1455     fontDescription.setVariantNumericFigure(variantNumeric.figure);
1456     fontDescription.setVariantNumericSpacing(variantNumeric.spacing);
1457     fontDescription.setVariantNumericFraction(variantNumeric.fraction);
1458     fontDescription.setVariantNumericOrdinal(variantNumeric.ordinal);
1459     fontDescription.setVariantNumericSlashedZero(variantNumeric.slashedZero);
1460     builderState.setFontDescription(WTFMove(fontDescription));
1461 }
1462 
1463 inline void BuilderCustom::applyInheritFontVariantEastAsian(BuilderState&amp; builderState)
1464 {
1465     auto fontDescription = builderState.fontDescription();
1466     fontDescription.setVariantEastAsianVariant(builderState.parentFontDescription().variantEastAsianVariant());
1467     fontDescription.setVariantEastAsianWidth(builderState.parentFontDescription().variantEastAsianWidth());
1468     fontDescription.setVariantEastAsianRuby(builderState.parentFontDescription().variantEastAsianRuby());
1469     builderState.setFontDescription(WTFMove(fontDescription));
1470 }
1471 
1472 inline void BuilderCustom::applyInitialFontVariantEastAsian(BuilderState&amp; builderState)
1473 {
1474     auto fontDescription = builderState.fontDescription();
1475     fontDescription.setVariantEastAsianVariant(FontVariantEastAsianVariant::Normal);
1476     fontDescription.setVariantEastAsianWidth(FontVariantEastAsianWidth::Normal);
1477     fontDescription.setVariantEastAsianRuby(FontVariantEastAsianRuby::Normal);
1478     builderState.setFontDescription(WTFMove(fontDescription));
1479 }
1480 
1481 inline void BuilderCustom::applyValueFontVariantEastAsian(BuilderState&amp; builderState, CSSValue&amp; value)
1482 {
1483     auto fontDescription = builderState.fontDescription();
1484     auto variantEastAsian = extractFontVariantEastAsian(value);
1485     fontDescription.setVariantEastAsianVariant(variantEastAsian.variant);
1486     fontDescription.setVariantEastAsianWidth(variantEastAsian.width);
1487     fontDescription.setVariantEastAsianRuby(variantEastAsian.ruby);
1488     builderState.setFontDescription(WTFMove(fontDescription));
1489 }
1490 
1491 inline void BuilderCustom::applyInitialFontSize(BuilderState&amp; builderState)
1492 {
1493     auto fontDescription = builderState.style().fontDescription();
1494     float size = Style::fontSizeForKeyword(CSSValueMedium, fontDescription.useFixedDefaultSize(), builderState.document());
1495 
1496     if (size &lt; 0)
1497         return;
1498 
1499     fontDescription.setKeywordSizeFromIdentifier(CSSValueMedium);
1500     builderState.setFontSize(fontDescription, size);
1501     builderState.setFontDescription(WTFMove(fontDescription));
1502 }
1503 
1504 inline void BuilderCustom::applyInheritFontSize(BuilderState&amp; builderState)
1505 {
1506     const auto&amp; parentFontDescription = builderState.parentStyle().fontDescription();
1507     float size = parentFontDescription.specifiedSize();
1508 
1509     if (size &lt; 0)
1510         return;
1511 
1512     auto fontDescription = builderState.style().fontDescription();
1513     fontDescription.setKeywordSize(parentFontDescription.keywordSize());
1514     builderState.setFontSize(fontDescription, size);
1515     builderState.setFontDescription(WTFMove(fontDescription));
1516 }
1517 
1518 // When the CSS keyword &quot;larger&quot; is used, this function will attempt to match within the keyword
1519 // table, and failing that, will simply multiply by 1.2.
1520 inline float BuilderCustom::largerFontSize(float size)
1521 {
1522     // FIXME: Figure out where we fall in the size ranges (xx-small to xxx-large) and scale up to
1523     // the next size level.
1524     return size * 1.2f;
1525 }
1526 
1527 // Like the previous function, but for the keyword &quot;smaller&quot;.
1528 inline float BuilderCustom::smallerFontSize(float size)
1529 {
1530     // FIXME: Figure out where we fall in the size ranges (xx-small to xxx-large) and scale down to
1531     // the next size level.
1532     return size / 1.2f;
1533 }
1534 
1535 inline float BuilderCustom::determineRubyTextSizeMultiplier(BuilderState&amp; builderState)
1536 {
1537     if (builderState.style().rubyPosition() != RubyPosition::InterCharacter)
1538         return 0.5f;
1539 
1540     // FIXME: This hack is to ensure tone marks are the same size as
1541     // the bopomofo. This code will go away if we make a special renderer
1542     // for the tone marks eventually.
1543     if (auto* element = builderState.element()) {
1544         for (auto&amp; ancestor : ancestorsOfType&lt;HTMLElement&gt;(*element)) {
1545             if (ancestor.hasTagName(HTMLNames::rtTag))
1546                 return 1.0f;
1547         }
1548     }
1549     return 0.25f;
1550 }
1551 
1552 inline void BuilderCustom::applyInitialFontStyle(BuilderState&amp; builderState)
1553 {
1554     auto fontDescription = builderState.fontDescription();
1555     fontDescription.setItalic(FontCascadeDescription::initialItalic());
1556     fontDescription.setFontStyleAxis(FontCascadeDescription::initialFontStyleAxis());
1557     builderState.setFontDescription(WTFMove(fontDescription));
1558 }
1559 
1560 inline void BuilderCustom::applyInheritFontStyle(BuilderState&amp; builderState)
1561 {
1562     auto fontDescription = builderState.fontDescription();
1563     fontDescription.setItalic(builderState.parentFontDescription().italic());
1564     fontDescription.setFontStyleAxis(builderState.parentFontDescription().fontStyleAxis());
1565     builderState.setFontDescription(WTFMove(fontDescription));
1566 }
1567 
1568 inline void BuilderCustom::applyValueFontStyle(BuilderState&amp; builderState, CSSValue&amp; value)
1569 {
1570     auto&amp; fontStyleValue = downcast&lt;CSSFontStyleValue&gt;(value);
1571     auto fontDescription = builderState.fontDescription();
1572     fontDescription.setItalic(BuilderConverter::convertFontStyleFromValue(fontStyleValue));
1573     fontDescription.setFontStyleAxis(fontStyleValue.fontStyleValue-&gt;valueID() == CSSValueItalic ? FontStyleAxis::ital : FontStyleAxis::slnt);
1574     builderState.setFontDescription(WTFMove(fontDescription));
1575 }
1576 
1577 inline void BuilderCustom::applyValueFontSize(BuilderState&amp; builderState, CSSValue&amp; value)
1578 {
1579     auto fontDescription = builderState.style().fontDescription();
1580     fontDescription.setKeywordSizeFromIdentifier(CSSValueInvalid);
1581 
1582     float parentSize = builderState.parentStyle().fontDescription().specifiedSize();
1583     bool parentIsAbsoluteSize = builderState.parentStyle().fontDescription().isAbsoluteSize();
1584 
1585     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1586     float size;
1587     if (CSSValueID ident = primitiveValue.valueID()) {
1588         fontDescription.setIsAbsoluteSize(parentIsAbsoluteSize &amp;&amp; (ident == CSSValueLarger || ident == CSSValueSmaller || ident == CSSValueWebkitRubyText));
1589 
1590         // Keywords are being used.
1591         switch (ident) {
1592         case CSSValueXxSmall:
1593         case CSSValueXSmall:
1594         case CSSValueSmall:
1595         case CSSValueMedium:
1596         case CSSValueLarge:
1597         case CSSValueXLarge:
1598         case CSSValueXxLarge:
1599         case CSSValueWebkitXxxLarge:
1600             size = Style::fontSizeForKeyword(ident, fontDescription.useFixedDefaultSize(), builderState.document());
1601             fontDescription.setKeywordSizeFromIdentifier(ident);
1602             break;
1603         case CSSValueLarger:
1604             size = largerFontSize(parentSize);
1605             break;
1606         case CSSValueSmaller:
1607             size = smallerFontSize(parentSize);
1608             break;
1609         case CSSValueWebkitRubyText:
1610             size = determineRubyTextSizeMultiplier(builderState) * parentSize;
1611             break;
1612         default:
1613             return;
1614         }
1615     } else {
1616         fontDescription.setIsAbsoluteSize(parentIsAbsoluteSize || !(primitiveValue.isPercentage() || primitiveValue.isFontRelativeLength()));
1617         if (primitiveValue.isLength()) {
1618             size = primitiveValue.computeLength&lt;float&gt;(CSSToLengthConversionData(&amp;builderState.parentStyle(), builderState.rootElementStyle(), builderState.document().renderView(), 1.0f, true));
1619             if (primitiveValue.isViewportPercentageLength())
1620                 builderState.style().setHasViewportUnits();
1621         } else if (primitiveValue.isPercentage())
1622             size = (primitiveValue.floatValue() * parentSize) / 100.0f;
1623         else if (primitiveValue.isCalculatedPercentageWithLength()) {
1624             const auto&amp; conversionData = builderState.cssToLengthConversionData();
1625             CSSToLengthConversionData parentConversionData { &amp;builderState.parentStyle(), conversionData.rootStyle(), builderState.document().renderView(), 1.0f, true };
1626             size = primitiveValue.cssCalcValue()-&gt;createCalculationValue(parentConversionData)-&gt;evaluate(parentSize);
1627         } else
1628             return;
1629     }
1630 
1631     if (size &lt; 0)
1632         return;
1633 
1634     builderState.setFontSize(fontDescription, std::min(maximumAllowedFontSize, size));
1635     builderState.setFontDescription(WTFMove(fontDescription));
1636 }
1637 
1638 inline void BuilderCustom::applyInitialGridTemplateAreas(BuilderState&amp; builderState)
1639 {
1640     builderState.style().setNamedGridArea(RenderStyle::initialNamedGridArea());
1641     builderState.style().setNamedGridAreaRowCount(RenderStyle::initialNamedGridAreaCount());
1642     builderState.style().setNamedGridAreaColumnCount(RenderStyle::initialNamedGridAreaCount());
1643 }
1644 
1645 inline void BuilderCustom::applyInheritGridTemplateAreas(BuilderState&amp; builderState)
1646 {
1647     builderState.style().setNamedGridArea(builderState.parentStyle().namedGridArea());
1648     builderState.style().setNamedGridAreaRowCount(builderState.parentStyle().namedGridAreaRowCount());
1649     builderState.style().setNamedGridAreaColumnCount(builderState.parentStyle().namedGridAreaColumnCount());
1650 }
1651 
1652 inline void BuilderCustom::applyValueGridTemplateAreas(BuilderState&amp; builderState, CSSValue&amp; value)
1653 {
1654     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1655         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueNone);
1656         return;
1657     }
1658 
1659     auto&amp; gridTemplateAreasValue = downcast&lt;CSSGridTemplateAreasValue&gt;(value);
1660     const NamedGridAreaMap&amp; newNamedGridAreas = gridTemplateAreasValue.gridAreaMap();
1661 
1662     NamedGridLinesMap namedGridColumnLines = builderState.style().namedGridColumnLines();
1663     NamedGridLinesMap namedGridRowLines = builderState.style().namedGridRowLines();
1664     BuilderConverter::createImplicitNamedGridLinesFromGridArea(newNamedGridAreas, namedGridColumnLines, ForColumns);
1665     BuilderConverter::createImplicitNamedGridLinesFromGridArea(newNamedGridAreas, namedGridRowLines, ForRows);
1666     builderState.style().setNamedGridColumnLines(namedGridColumnLines);
1667     builderState.style().setNamedGridRowLines(namedGridRowLines);
1668 
1669     builderState.style().setNamedGridArea(gridTemplateAreasValue.gridAreaMap());
1670     builderState.style().setNamedGridAreaRowCount(gridTemplateAreasValue.rowCount());
1671     builderState.style().setNamedGridAreaColumnCount(gridTemplateAreasValue.columnCount());
1672 }
1673 
1674 inline void BuilderCustom::applyInitialGridTemplateColumns(BuilderState&amp; builderState)
1675 {
1676     builderState.style().setGridColumns(RenderStyle::initialGridColumns());
1677     builderState.style().setNamedGridColumnLines(RenderStyle::initialNamedGridColumnLines());
1678     builderState.style().setOrderedNamedGridColumnLines(RenderStyle::initialOrderedNamedGridColumnLines());
1679 }
1680 
1681 inline void BuilderCustom::applyInheritGridTemplateColumns(BuilderState&amp; builderState)
1682 {
1683     builderState.style().setGridColumns(builderState.parentStyle().gridColumns());
1684     builderState.style().setNamedGridColumnLines(builderState.parentStyle().namedGridColumnLines());
1685     builderState.style().setOrderedNamedGridColumnLines(builderState.parentStyle().orderedNamedGridColumnLines());
1686 }
1687 
1688 #define SET_TRACKS_DATA(tracksData, style, TrackType) \
1689     style.setGrid##TrackType##s(tracksData.m_trackSizes); \
1690     style.setNamedGrid##TrackType##Lines(tracksData.m_namedGridLines); \
1691     style.setOrderedNamedGrid##TrackType##Lines(tracksData.m_orderedNamedGridLines); \
1692     style.setGridAutoRepeat##TrackType##s(tracksData.m_autoRepeatTrackSizes); \
1693     style.setGridAutoRepeat##TrackType##sInsertionPoint(tracksData.m_autoRepeatInsertionPoint); \
1694     style.setAutoRepeatNamedGrid##TrackType##Lines(tracksData.m_autoRepeatNamedGridLines); \
1695     style.setAutoRepeatOrderedNamedGrid##TrackType##Lines(tracksData.m_autoRepeatOrderedNamedGridLines); \
1696     style.setGridAutoRepeat##TrackType##sType(tracksData.m_autoRepeatType); \
1697     style.setGridAutoRepeat##TrackType##sInsertionPoint(tracksData.m_autoRepeatInsertionPoint);
1698 
1699 inline void BuilderCustom::applyValueGridTemplateColumns(BuilderState&amp; builderState, CSSValue&amp; value)
1700 {
1701     BuilderConverter::TracksData tracksData;
1702     if (!BuilderConverter::createGridTrackList(value, tracksData, builderState))
1703         return;
1704     const NamedGridAreaMap&amp; namedGridAreas = builderState.style().namedGridArea();
1705     if (!namedGridAreas.isEmpty())
1706         BuilderConverter::createImplicitNamedGridLinesFromGridArea(namedGridAreas, tracksData.m_namedGridLines, ForColumns);
1707 
1708     SET_TRACKS_DATA(tracksData, builderState.style(), Column);
1709 }
1710 
1711 inline void BuilderCustom::applyInitialGridTemplateRows(BuilderState&amp; builderState)
1712 {
1713     builderState.style().setGridRows(RenderStyle::initialGridRows());
1714     builderState.style().setNamedGridRowLines(RenderStyle::initialNamedGridRowLines());
1715     builderState.style().setOrderedNamedGridRowLines(RenderStyle::initialOrderedNamedGridRowLines());
1716 }
1717 
1718 inline void BuilderCustom::applyInheritGridTemplateRows(BuilderState&amp; builderState)
1719 {
1720     builderState.style().setGridRows(builderState.parentStyle().gridRows());
1721     builderState.style().setNamedGridRowLines(builderState.parentStyle().namedGridRowLines());
1722     builderState.style().setOrderedNamedGridRowLines(builderState.parentStyle().orderedNamedGridRowLines());
1723 }
1724 
1725 inline void BuilderCustom::applyValueGridTemplateRows(BuilderState&amp; builderState, CSSValue&amp; value)
1726 {
1727     BuilderConverter::TracksData tracksData;
1728     if (!BuilderConverter::createGridTrackList(value, tracksData, builderState))
1729         return;
1730     const NamedGridAreaMap&amp; namedGridAreas = builderState.style().namedGridArea();
1731     if (!namedGridAreas.isEmpty())
1732         BuilderConverter::createImplicitNamedGridLinesFromGridArea(namedGridAreas, tracksData.m_namedGridLines, ForRows);
1733 
1734     SET_TRACKS_DATA(tracksData, builderState.style(), Row);
1735 }
1736 
1737 void BuilderCustom::applyValueAlt(BuilderState&amp; builderState, CSSValue&amp; value)
1738 {
1739     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1740     if (primitiveValue.isString())
1741         builderState.style().setContentAltText(primitiveValue.stringValue());
1742     else if (primitiveValue.isAttr()) {
1743         // FIXME: Can a namespace be specified for an attr(foo)?
1744         if (builderState.style().styleType() == PseudoId::None)
1745             builderState.style().setUnique();
1746         else
1747             const_cast&lt;RenderStyle&amp;&gt;(builderState.parentStyle()).setUnique();
1748 
1749         QualifiedName attr(nullAtom(), primitiveValue.stringValue(), nullAtom());
1750         const AtomString&amp; value = builderState.element() ? builderState.element()-&gt;getAttribute(attr) : nullAtom();
1751         builderState.style().setContentAltText(value.isNull() ? emptyAtom() : value);
1752 
1753         // Register the fact that the attribute value affects the style.
1754         builderState.registerContentAttribute(attr.localName());
1755     } else
1756         builderState.style().setContentAltText(emptyAtom());
1757 }
1758 
1759 inline void BuilderCustom::applyValueWillChange(BuilderState&amp; builderState, CSSValue&amp; value)
1760 {
1761     if (is&lt;CSSPrimitiveValue&gt;(value)) {
1762         ASSERT(downcast&lt;CSSPrimitiveValue&gt;(value).valueID() == CSSValueAuto);
1763         builderState.style().setWillChange(nullptr);
1764         return;
1765     }
1766 
1767     auto willChange = WillChangeData::create();
1768     for (auto&amp; item : downcast&lt;CSSValueList&gt;(value)) {
1769         if (!is&lt;CSSPrimitiveValue&gt;(item))
1770             continue;
1771         auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(item.get());
1772         switch (primitiveValue.valueID()) {
1773         case CSSValueScrollPosition:
1774             willChange-&gt;addFeature(WillChangeData::Feature::ScrollPosition);
1775             break;
1776         case CSSValueContents:
1777             willChange-&gt;addFeature(WillChangeData::Feature::Contents);
1778             break;
1779         default:
1780             if (primitiveValue.isPropertyID())
1781                 willChange-&gt;addFeature(WillChangeData::Feature::Property, primitiveValue.propertyID());
1782             break;
1783         }
1784     }
1785     builderState.style().setWillChange(WTFMove(willChange));
1786 }
1787 
1788 inline void BuilderCustom::applyValueStrokeWidth(BuilderState&amp; builderState, CSSValue&amp; value)
1789 {
1790     builderState.style().setStrokeWidth(BuilderConverter::convertLength(builderState, value));
1791     builderState.style().setHasExplicitlySetStrokeWidth(true);
1792 }
1793 
1794 inline void BuilderCustom::applyValueStrokeColor(BuilderState&amp; builderState, CSSValue&amp; value)
1795 {
1796     auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(value);
1797     if (builderState.applyPropertyToRegularStyle())
1798         builderState.style().setStrokeColor(builderState.colorFromPrimitiveValue(primitiveValue, /* forVisitedLink */ false));
1799     if (builderState.applyPropertyToVisitedLinkStyle())
1800         builderState.style().setVisitedLinkStrokeColor(builderState.colorFromPrimitiveValue(primitiveValue, /* forVisitedLink */ true));
1801     builderState.style().setHasExplicitlySetStrokeColor(true);
1802 }
1803 
1804 inline void BuilderCustom::applyInitialCustomProperty(BuilderState&amp; builderState, const CSSRegisteredCustomProperty* registered, const AtomString&amp; name)
1805 {
1806     if (registered &amp;&amp; registered-&gt;initialValue()) {
1807         auto initialValue = registered-&gt;initialValueCopy();
1808         applyValueCustomProperty(builderState, registered, *initialValue);
1809         return;
1810     }
1811 
1812     auto invalid = CSSCustomPropertyValue::createUnresolved(name, CSSValueInvalid);
1813     applyValueCustomProperty(builderState, registered, invalid.get());
1814 }
1815 
1816 inline void BuilderCustom::applyInheritCustomProperty(BuilderState&amp; builderState, const CSSRegisteredCustomProperty* registered, const AtomString&amp; name)
1817 {
1818     auto* parentValue = builderState.parentStyle().inheritedCustomProperties().get(name);
1819     if (parentValue &amp;&amp; !(registered &amp;&amp; !registered-&gt;inherits))
1820         applyValueCustomProperty(builderState, registered, *parentValue);
1821     else
1822         applyInitialCustomProperty(builderState, registered, name);
1823 }
1824 
1825 inline void BuilderCustom::applyValueCustomProperty(BuilderState&amp; builderState, const CSSRegisteredCustomProperty* registered, CSSCustomPropertyValue&amp; value)
1826 {
1827     ASSERT(value.isResolved());
1828     const auto&amp; name = value.name();
1829 
1830     if (!registered || registered-&gt;inherits)
1831         builderState.style().setInheritedCustomPropertyValue(name, makeRef(value));
1832     else
1833         builderState.style().setNonInheritedCustomPropertyValue(name, makeRef(value));
1834 }
1835 
1836 }
1837 }
    </pre>
  </body>
</html>
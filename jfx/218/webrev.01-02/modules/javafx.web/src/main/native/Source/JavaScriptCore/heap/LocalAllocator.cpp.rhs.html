<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/LocalAllocator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2018-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;LocalAllocator.h&quot;
 28 
 29 #include &quot;AllocatingScope.h&quot;
 30 #include &quot;FreeListInlines.h&quot;
 31 #include &quot;GCDeferralContext.h&quot;
 32 #include &quot;JSCInlines.h&quot;
 33 #include &quot;LocalAllocatorInlines.h&quot;
 34 #include &quot;Options.h&quot;
 35 #include &quot;SuperSampler.h&quot;
 36 
 37 namespace JSC {
 38 
 39 LocalAllocator::LocalAllocator(BlockDirectory* directory)
 40     : m_directory(directory)
 41     , m_freeList(directory-&gt;m_cellSize)
 42 {
 43     auto locker = holdLock(directory-&gt;m_localAllocatorsLock);
 44     directory-&gt;m_localAllocators.append(this);
 45 }
 46 
 47 void LocalAllocator::reset()
 48 {
 49     m_freeList.clear();
 50     m_currentBlock = nullptr;
 51     m_lastActiveBlock = nullptr;
 52     m_allocationCursor = 0;
 53 }
 54 
 55 LocalAllocator::~LocalAllocator()
 56 {
 57     if (isOnList()) {
 58         auto locker = holdLock(m_directory-&gt;m_localAllocatorsLock);
 59         remove();
 60     }
 61 
 62     bool ok = true;
 63     if (!m_freeList.allocationWillFail()) {
 64         dataLog(&quot;FATAL: &quot;, RawPointer(this), &quot;-&gt;~LocalAllocator has non-empty free-list.\n&quot;);
 65         ok = false;
 66     }
 67     if (m_currentBlock) {
 68         dataLog(&quot;FATAL: &quot;, RawPointer(this), &quot;-&gt;~LocalAllocator has non-null current block.\n&quot;);
 69         ok = false;
 70     }
 71     if (m_lastActiveBlock) {
 72         dataLog(&quot;FATAL: &quot;, RawPointer(this), &quot;-&gt;~LocalAllocator has non-null last active block.\n&quot;);
 73         ok = false;
 74     }
 75     RELEASE_ASSERT(ok);
 76 }
 77 
 78 void LocalAllocator::stopAllocating()
 79 {
 80     ASSERT(!m_lastActiveBlock);
 81     if (!m_currentBlock) {
 82         ASSERT(m_freeList.allocationWillFail());
 83         return;
 84     }
 85 
 86     m_currentBlock-&gt;stopAllocating(m_freeList);
 87     m_lastActiveBlock = m_currentBlock;
 88     m_currentBlock = nullptr;
 89     m_freeList.clear();
 90 }
 91 
 92 void LocalAllocator::resumeAllocating()
 93 {
 94     if (!m_lastActiveBlock)
 95         return;
 96 
 97     m_lastActiveBlock-&gt;resumeAllocating(m_freeList);
 98     m_currentBlock = m_lastActiveBlock;
 99     m_lastActiveBlock = nullptr;
100 }
101 
102 void LocalAllocator::prepareForAllocation()
103 {
104     reset();
105 }
106 
107 void LocalAllocator::stopAllocatingForGood()
108 {
109     stopAllocating();
110     reset();
111 }
112 
<a name="1" id="anc1"></a><span class="line-modified">113 void* LocalAllocator::allocateSlowCase(Heap&amp; heap, GCDeferralContext* deferralContext, AllocationFailureMode failureMode)</span>
114 {
115     SuperSamplerScope superSamplerScope(false);
<a name="2" id="anc2"></a>
116     ASSERT(heap.vm().currentThreadIsHoldingAPILock());
<a name="3" id="anc3"></a><span class="line-modified">117     doTestCollectionsIfNeeded(heap, deferralContext);</span>
118 
119     ASSERT(!m_directory-&gt;markedSpace().isIterating());
120     heap.didAllocate(m_freeList.originalSize());
121 
122     didConsumeFreeList();
123 
124     AllocatingScope helpingHeap(heap);
125 
126     heap.collectIfNecessaryOrDefer(deferralContext);
127 
128     // Goofy corner case: the GC called a callback and now this directory has a currentBlock. This only
129     // happens when running WebKit tests, which inject a callback into the GC&#39;s finalization.
130     if (UNLIKELY(m_currentBlock))
<a name="4" id="anc4"></a><span class="line-modified">131         return allocate(heap, deferralContext, failureMode);</span>
132 
133     void* result = tryAllocateWithoutCollecting();
134 
<a name="5" id="anc5"></a><span class="line-modified">135     if (LIKELY(result != nullptr))</span>
136         return result;
137 
<a name="6" id="anc6"></a><span class="line-modified">138     Subspace* subspace = m_directory-&gt;m_subspace;</span>
<span class="line-added">139     if (subspace-&gt;isIsoSubspace()) {</span>
<span class="line-added">140         if (void* result = static_cast&lt;IsoSubspace*&gt;(subspace)-&gt;tryAllocateFromLowerTier())</span>
<span class="line-added">141             return result;</span>
<span class="line-added">142     }</span>
<span class="line-added">143 </span>
<span class="line-added">144     MarkedBlock::Handle* block = m_directory-&gt;tryAllocateBlock(heap);</span>
145     if (!block) {
146         if (failureMode == AllocationFailureMode::Assert)
147             RELEASE_ASSERT_NOT_REACHED();
148         else
149             return nullptr;
150     }
151     m_directory-&gt;addBlock(block);
152     result = allocateIn(block);
153     ASSERT(result);
154     return result;
155 }
156 
157 void LocalAllocator::didConsumeFreeList()
158 {
159     if (m_currentBlock)
160         m_currentBlock-&gt;didConsumeFreeList();
161 
162     m_freeList.clear();
163     m_currentBlock = nullptr;
164 }
165 
166 void* LocalAllocator::tryAllocateWithoutCollecting()
167 {
168     // FIXME: If we wanted this to be used for real multi-threaded allocations then we would have to
169     // come up with some concurrency protocol here. That protocol would need to be able to handle:
170     //
171     // - The basic case of multiple LocalAllocators trying to do an allocationCursor search on the
172     //   same bitvector. That probably needs the bitvector lock at least.
173     //
174     // - The harder case of some LocalAllocator triggering a steal from a different BlockDirectory
175     //   via a search in the AlignedMemoryAllocator&#39;s list. Who knows what locks that needs.
176     //
177     // One way to make this work is to have a single per-Heap lock that protects all mutator lock
178     // allocation slow paths. That would probably be scalable enough for years. It would certainly be
179     // for using TLC allocation from JIT threads.
180     // https://bugs.webkit.org/show_bug.cgi?id=181635
181 
182     SuperSamplerScope superSamplerScope(false);
183 
184     ASSERT(!m_currentBlock);
185     ASSERT(m_freeList.allocationWillFail());
186 
187     for (;;) {
188         MarkedBlock::Handle* block = m_directory-&gt;findBlockForAllocation(*this);
189         if (!block)
190             break;
191 
192         if (void* result = tryAllocateIn(block))
193             return result;
194     }
195 
196     if (Options::stealEmptyBlocksFromOtherAllocators()) {
197         if (MarkedBlock::Handle* block = m_directory-&gt;m_subspace-&gt;findEmptyBlockToSteal()) {
198             RELEASE_ASSERT(block-&gt;alignedMemoryAllocator() == m_directory-&gt;m_subspace-&gt;alignedMemoryAllocator());
199 
200             block-&gt;sweep(nullptr);
201 
202             // It&#39;s good that this clears canAllocateButNotEmpty as well as all other bits,
203             // because there is a remote chance that a block may have both canAllocateButNotEmpty
204             // and empty set at the same time.
205             block-&gt;removeFromDirectory();
206             m_directory-&gt;addBlock(block);
207             return allocateIn(block);
208         }
209     }
210 
211     return nullptr;
212 }
213 
214 void* LocalAllocator::allocateIn(MarkedBlock::Handle* block)
215 {
216     void* result = tryAllocateIn(block);
217     RELEASE_ASSERT(result);
218     return result;
219 }
220 
221 void* LocalAllocator::tryAllocateIn(MarkedBlock::Handle* block)
222 {
223     ASSERT(block);
224     ASSERT(!block-&gt;isFreeListed());
225 
226     block-&gt;sweep(&amp;m_freeList);
227 
228     // It&#39;s possible to stumble on a completely full block. Marking tries to retire these, but
229     // that algorithm is racy and may forget to do it sometimes.
230     if (m_freeList.allocationWillFail()) {
231         ASSERT(block-&gt;isFreeListed());
232         block-&gt;unsweepWithNoNewlyAllocated();
233         ASSERT(!block-&gt;isFreeListed());
234         ASSERT(!m_directory-&gt;isEmpty(NoLockingNecessary, block));
235         ASSERT(!m_directory-&gt;isCanAllocateButNotEmpty(NoLockingNecessary, block));
236         return nullptr;
237     }
238 
239     m_currentBlock = block;
240 
241     void* result = m_freeList.allocate(
242         [] () -&gt; HeapCell* {
243             RELEASE_ASSERT_NOT_REACHED();
244             return nullptr;
245         });
246     m_directory-&gt;setIsEden(NoLockingNecessary, m_currentBlock, true);
247     m_directory-&gt;markedSpace().didAllocateInBlock(m_currentBlock);
248     return result;
249 }
250 
<a name="7" id="anc7"></a><span class="line-modified">251 void LocalAllocator::doTestCollectionsIfNeeded(Heap&amp; heap, GCDeferralContext* deferralContext)</span>
252 {
253     if (!Options::slowPathAllocsBetweenGCs())
254         return;
255 
256     static unsigned allocationCount = 0;
257     if (!allocationCount) {
<a name="8" id="anc8"></a><span class="line-modified">258         if (!heap.isDeferred()) {</span>
259             if (deferralContext)
260                 deferralContext-&gt;m_shouldGC = true;
261             else
<a name="9" id="anc9"></a><span class="line-modified">262                 heap.collectNow(Sync, CollectionScope::Full);</span>
263         }
264     }
265     if (++allocationCount &gt;= Options::slowPathAllocsBetweenGCs())
266         allocationCount = 0;
267 }
268 
269 bool LocalAllocator::isFreeListedCell(const void* target) const
270 {
271     // This abomination exists to detect when an object is in the dead-but-not-destructed state.
272     // Therefore, it&#39;s not even clear that this needs to do anything beyond returning &quot;false&quot;, since
273     // if we know that the block owning the object is free-listed, then it&#39;s impossible for any
274     // objects to be in the dead-but-not-destructed state.
275     // FIXME: Get rid of this abomination. https://bugs.webkit.org/show_bug.cgi?id=181655
276     return m_freeList.contains(bitwise_cast&lt;HeapCell*&gt;(target));
277 }
278 
279 } // namespace JSC
280 
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
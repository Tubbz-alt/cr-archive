<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/animation/DocumentTimeline.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DocumentTimeline.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="KeyframeEffect.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/animation/DocumentTimeline.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 29,14 ***</span>
  #include &quot;DocumentTimelineOptions.h&quot;
  #include &quot;GenericTaskQueue.h&quot;
  #include &quot;Timer.h&quot;
  #include &lt;wtf/Markable.h&gt;
  #include &lt;wtf/Ref.h&gt;
  
  namespace WebCore {
  
<span class="line-modified">! class AnimationPlaybackEvent;</span>
  class RenderElement;
  
  class DocumentTimeline final : public AnimationTimeline
  {
  public:
<span class="line-new-header">--- 29,15 ---</span>
  #include &quot;DocumentTimelineOptions.h&quot;
  #include &quot;GenericTaskQueue.h&quot;
  #include &quot;Timer.h&quot;
  #include &lt;wtf/Markable.h&gt;
  #include &lt;wtf/Ref.h&gt;
<span class="line-added">+ #include &lt;wtf/WeakPtr.h&gt;</span>
  
  namespace WebCore {
  
<span class="line-modified">! class AnimationEventBase;</span>
  class RenderElement;
  
  class DocumentTimeline final : public AnimationTimeline
  {
  public:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 65,16 ***</span>
      bool isRunningAnimationOnRenderer(RenderElement&amp;, CSSPropertyID) const;
      bool isRunningAcceleratedAnimationOnRenderer(RenderElement&amp;, CSSPropertyID) const;
      void animationAcceleratedRunningStateDidChange(WebAnimation&amp;);
      void applyPendingAcceleratedAnimations();
      bool runningAnimationsForElementAreAllAccelerated(Element&amp;) const;
<span class="line-removed">-     bool resolveAnimationsForElement(Element&amp;, RenderStyle&amp;);</span>
      void detachFromDocument();
  
<span class="line-modified">!     void enqueueAnimationPlaybackEvent(AnimationPlaybackEvent&amp;);</span>
  
<span class="line-modified">!     void updateAnimationsAndSendEvents(DOMHighResTimeStamp timestamp);</span>
  
      void updateThrottlingState();
      WEBCORE_EXPORT Seconds animationInterval() const;
      WEBCORE_EXPORT void suspendAnimations();
      WEBCORE_EXPORT void resumeAnimations();
<span class="line-new-header">--- 66,17 ---</span>
      bool isRunningAnimationOnRenderer(RenderElement&amp;, CSSPropertyID) const;
      bool isRunningAcceleratedAnimationOnRenderer(RenderElement&amp;, CSSPropertyID) const;
      void animationAcceleratedRunningStateDidChange(WebAnimation&amp;);
      void applyPendingAcceleratedAnimations();
      bool runningAnimationsForElementAreAllAccelerated(Element&amp;) const;
      void detachFromDocument();
  
<span class="line-modified">!     void enqueueAnimationEvent(AnimationEventBase&amp;);</span>
  
<span class="line-modified">!     bool scheduledUpdate() const { return m_animationResolutionScheduled; }</span>
<span class="line-added">+     void updateCurrentTime(DOMHighResTimeStamp timestamp);</span>
<span class="line-added">+     void updateAnimationsAndSendEvents();</span>
  
      void updateThrottlingState();
      WEBCORE_EXPORT Seconds animationInterval() const;
      WEBCORE_EXPORT void suspendAnimations();
      WEBCORE_EXPORT void resumeAnimations();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 88,31 ***</span>
  
      DOMHighResTimeStamp liveCurrentTime() const;
      void cacheCurrentTime(DOMHighResTimeStamp);
      void maybeClearCachedCurrentTime();
      void scheduleInvalidationTaskIfNeeded();
<span class="line-removed">-     void performInvalidationTask();</span>
      void scheduleAnimationResolution();
<span class="line-modified">!     void unscheduleAnimationResolution();</span>
      void internalUpdateAnimationsAndSendEvents();
<span class="line-removed">-     void performEventDispatchTask();</span>
      void updateListOfElementsWithRunningAcceleratedAnimationsForElement(Element&amp;);
      void transitionDidComplete(RefPtr&lt;CSSTransition&gt;);
      void scheduleNextTick();
  
      Timer m_tickScheduleTimer;
      GenericTaskQueue&lt;Timer&gt; m_currentTimeClearingTaskQueue;
      HashSet&lt;RefPtr&lt;WebAnimation&gt;&gt; m_acceleratedAnimationsPendingRunningStateChange;
      HashSet&lt;Element*&gt; m_elementsWithRunningAcceleratedAnimations;
<span class="line-modified">!     Vector&lt;Ref&lt;AnimationPlaybackEvent&gt;&gt; m_pendingAnimationEvents;</span>
<span class="line-modified">!     RefPtr&lt;Document&gt; m_document;</span>
      Markable&lt;Seconds, Seconds::MarkableTraits&gt; m_cachedCurrentTime;
      Seconds m_originTime;
      unsigned m_numberOfAnimationTimelineInvalidationsForTesting { 0 };
      bool m_isSuspended { false };
      bool m_waitingOnVMIdle { false };
      bool m_animationResolutionScheduled { false };
  };
  
  } // namespace WebCore
  
  SPECIALIZE_TYPE_TRAITS_ANIMATION_TIMELINE(DocumentTimeline, isDocumentTimeline())
<span class="line-new-header">--- 90,33 ---</span>
  
      DOMHighResTimeStamp liveCurrentTime() const;
      void cacheCurrentTime(DOMHighResTimeStamp);
      void maybeClearCachedCurrentTime();
      void scheduleInvalidationTaskIfNeeded();
      void scheduleAnimationResolution();
<span class="line-modified">!     void clearTickScheduleTimer();</span>
      void internalUpdateAnimationsAndSendEvents();
      void updateListOfElementsWithRunningAcceleratedAnimationsForElement(Element&amp;);
      void transitionDidComplete(RefPtr&lt;CSSTransition&gt;);
      void scheduleNextTick();
<span class="line-added">+     void removeReplacedAnimations();</span>
<span class="line-added">+     bool animationCanBeRemoved(WebAnimation&amp;);</span>
<span class="line-added">+     bool shouldRunUpdateAnimationsAndSendEventsIgnoringSuspensionState() const;</span>
  
      Timer m_tickScheduleTimer;
      GenericTaskQueue&lt;Timer&gt; m_currentTimeClearingTaskQueue;
      HashSet&lt;RefPtr&lt;WebAnimation&gt;&gt; m_acceleratedAnimationsPendingRunningStateChange;
      HashSet&lt;Element*&gt; m_elementsWithRunningAcceleratedAnimations;
<span class="line-modified">!     Vector&lt;Ref&lt;AnimationEventBase&gt;&gt; m_pendingAnimationEvents;</span>
<span class="line-modified">!     WeakPtr&lt;Document&gt; m_document;</span>
      Markable&lt;Seconds, Seconds::MarkableTraits&gt; m_cachedCurrentTime;
      Seconds m_originTime;
      unsigned m_numberOfAnimationTimelineInvalidationsForTesting { 0 };
      bool m_isSuspended { false };
      bool m_waitingOnVMIdle { false };
      bool m_animationResolutionScheduled { false };
<span class="line-added">+     bool m_shouldScheduleAnimationResolutionForNewPendingEvents { true };</span>
  };
  
  } // namespace WebCore
  
  SPECIALIZE_TYPE_TRAITS_ANIMATION_TIMELINE(DocumentTimeline, isDocumentTimeline())
</pre>
<center><a href="DocumentTimeline.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="KeyframeEffect.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
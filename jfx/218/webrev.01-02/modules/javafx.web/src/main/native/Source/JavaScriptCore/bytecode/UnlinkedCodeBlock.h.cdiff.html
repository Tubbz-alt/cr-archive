<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedCodeBlock.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="UnlinkedCodeBlock.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UnlinkedEvalCodeBlock.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedCodeBlock.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 35,37 ***</span>
  #include &quot;JSCast.h&quot;
  #include &quot;LockDuringMarking.h&quot;
  #include &quot;Opcode.h&quot;
  #include &quot;ParserModes.h&quot;
  #include &quot;RegExp.h&quot;
<span class="line-removed">- #include &quot;SpecialPointer.h&quot;</span>
  #include &quot;UnlinkedFunctionExecutable.h&quot;
  #include &quot;UnlinkedMetadataTable.h&quot;
  #include &quot;VirtualRegister.h&quot;
  #include &lt;algorithm&gt;
  #include &lt;wtf/BitVector.h&gt;
  #include &lt;wtf/HashSet.h&gt;
  #include &lt;wtf/TriState.h&gt;
  #include &lt;wtf/Vector.h&gt;
  #include &lt;wtf/text/UniquedStringImpl.h&gt;
  
  namespace JSC {
  
<span class="line-removed">- class BytecodeGenerator;</span>
  class BytecodeLivenessAnalysis;
  class BytecodeRewriter;
  class CodeBlock;
  class Debugger;
  class FunctionExecutable;
  class ParserError;
  class ScriptExecutable;
  class SourceCode;
  class SourceProvider;
  class UnlinkedCodeBlock;
  class UnlinkedFunctionCodeBlock;
  class UnlinkedFunctionExecutable;
  struct ExecutableInfo;
  
  template&lt;typename CodeBlockType&gt;
  class CachedCodeBlock;
  
  typedef unsigned UnlinkedValueProfile;
<span class="line-new-header">--- 35,38 ---</span>
  #include &quot;JSCast.h&quot;
  #include &quot;LockDuringMarking.h&quot;
  #include &quot;Opcode.h&quot;
  #include &quot;ParserModes.h&quot;
  #include &quot;RegExp.h&quot;
  #include &quot;UnlinkedFunctionExecutable.h&quot;
  #include &quot;UnlinkedMetadataTable.h&quot;
  #include &quot;VirtualRegister.h&quot;
  #include &lt;algorithm&gt;
  #include &lt;wtf/BitVector.h&gt;
  #include &lt;wtf/HashSet.h&gt;
<span class="line-added">+ #include &lt;wtf/RefCountedArray.h&gt;</span>
  #include &lt;wtf/TriState.h&gt;
  #include &lt;wtf/Vector.h&gt;
  #include &lt;wtf/text/UniquedStringImpl.h&gt;
  
  namespace JSC {
  
  class BytecodeLivenessAnalysis;
  class BytecodeRewriter;
  class CodeBlock;
  class Debugger;
  class FunctionExecutable;
  class ParserError;
  class ScriptExecutable;
  class SourceCode;
  class SourceProvider;
  class UnlinkedCodeBlock;
<span class="line-added">+ class UnlinkedCodeBlockGenerator;</span>
  class UnlinkedFunctionCodeBlock;
  class UnlinkedFunctionExecutable;
  struct ExecutableInfo;
<span class="line-added">+ enum class LinkTimeConstant : int32_t;</span>
  
  template&lt;typename CodeBlockType&gt;
  class CachedCodeBlock;
  
  typedef unsigned UnlinkedValueProfile;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 93,11 ***</span>
      }
  
  };
  
  struct UnlinkedSimpleJumpTable {
<span class="line-modified">!     Vector&lt;int32_t&gt; branchOffsets;</span>
      int32_t min;
  
      int32_t offsetForValue(int32_t value, int32_t defaultOffset);
      void add(int32_t key, int32_t offset)
      {
<span class="line-new-header">--- 94,11 ---</span>
      }
  
  };
  
  struct UnlinkedSimpleJumpTable {
<span class="line-modified">!     RefCountedArray&lt;int32_t&gt; branchOffsets;</span>
      int32_t min;
  
      int32_t offsetForValue(int32_t value, int32_t defaultOffset);
      void add(int32_t key, int32_t offset)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 107,13 ***</span>
  };
  
  class UnlinkedCodeBlock : public JSCell {
  public:
      typedef JSCell Base;
<span class="line-modified">!     static const unsigned StructureFlags = Base::StructureFlags;</span>
  
<span class="line-modified">!     static const bool needsDestruction = true;</span>
  
      enum { CallFunction, ApplyFunction };
  
      bool isConstructor() const { return m_isConstructor; }
      bool isStrictMode() const { return m_isStrictMode; }
<span class="line-new-header">--- 108,19 ---</span>
  };
  
  class UnlinkedCodeBlock : public JSCell {
  public:
      typedef JSCell Base;
<span class="line-modified">!     static constexpr unsigned StructureFlags = Base::StructureFlags;</span>
  
<span class="line-modified">!     static constexpr bool needsDestruction = true;</span>
<span class="line-added">+ </span>
<span class="line-added">+     template&lt;typename, SubspaceAccess&gt;</span>
<span class="line-added">+     static void subspaceFor(VM&amp;)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+     }</span>
  
      enum { CallFunction, ApplyFunction };
  
      bool isConstructor() const { return m_isConstructor; }
      bool isStrictMode() const { return m_isStrictMode; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 126,172 ***</span>
      bool isClassContext() const { return m_isClassContext; }
      bool hasTailCalls() const { return m_hasTailCalls; }
      void setHasTailCalls() { m_hasTailCalls = true; }
      bool allowDirectEvalCache() const { return !(m_features &amp; NoEvalCacheFeature); }
  
<span class="line-removed">-     void addExpressionInfo(unsigned instructionOffset, int divot,</span>
<span class="line-removed">-         int startOffset, int endOffset, unsigned line, unsigned column);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void addTypeProfilerExpressionInfo(unsigned instructionOffset, unsigned startDivot, unsigned endDivot);</span>
<span class="line-removed">- </span>
      bool hasExpressionInfo() { return m_expressionInfo.size(); }
<span class="line-modified">!     const Vector&lt;ExpressionRangeInfo&gt;&amp; expressionInfo() { return m_expressionInfo; }</span>
  
      // Special registers
      void setThisRegister(VirtualRegister thisRegister) { m_thisRegister = thisRegister; }
      void setScopeRegister(VirtualRegister scopeRegister) { m_scopeRegister = scopeRegister; }
  
      // Parameter information
      void setNumParameters(int newValue) { m_numParameters = newValue; }
<span class="line-removed">-     void addParameter() { m_numParameters++; }</span>
      unsigned numParameters() const { return m_numParameters; }
  
      // Constant Pools
  
      size_t numberOfIdentifiers() const { return m_identifiers.size(); }
<span class="line-removed">-     void addIdentifier(const Identifier&amp; i) { return m_identifiers.append(i); }</span>
      const Identifier&amp; identifier(int index) const { return m_identifiers[index]; }
<span class="line-modified">!     const Vector&lt;Identifier&gt;&amp; identifiers() const { return m_identifiers; }</span>
  
      BitVector&amp; bitVector(size_t i) { ASSERT(m_rareData); return m_rareData-&gt;m_bitVectors[i]; }
<span class="line-removed">-     unsigned addBitVector(BitVector&amp;&amp; bitVector)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         createRareDataIfNecessary();</span>
<span class="line-removed">-         m_rareData-&gt;m_bitVectors.append(WTFMove(bitVector));</span>
<span class="line-removed">-         return m_rareData-&gt;m_bitVectors.size() - 1;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     void addSetConstant(IdentifierSet&amp; set)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         createRareDataIfNecessary();</span>
<span class="line-modified">!         VM&amp; vm = this-&gt;vm();</span>
<span class="line-removed">-         auto locker = lockDuringMarking(vm.heap, cellLock());</span>
<span class="line-removed">-         unsigned result = m_constantRegisters.size();</span>
<span class="line-removed">-         m_constantRegisters.append(WriteBarrier&lt;Unknown&gt;());</span>
<span class="line-removed">-         m_constantsSourceCodeRepresentation.append(SourceCodeRepresentation::Other);</span>
<span class="line-removed">-         m_rareData-&gt;m_constantIdentifierSets.append(ConstantIdentifierSetEntry(set, result));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     unsigned addConstant(JSValue v, SourceCodeRepresentation sourceCodeRepresentation = SourceCodeRepresentation::Other)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         VM&amp; vm = this-&gt;vm();</span>
<span class="line-removed">-         auto locker = lockDuringMarking(vm.heap, cellLock());</span>
<span class="line-removed">-         unsigned result = m_constantRegisters.size();</span>
<span class="line-removed">-         m_constantRegisters.append(WriteBarrier&lt;Unknown&gt;());</span>
<span class="line-removed">-         m_constantRegisters.last().set(vm, this, v);</span>
<span class="line-removed">-         m_constantsSourceCodeRepresentation.append(sourceCodeRepresentation);</span>
<span class="line-removed">-         return result;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     unsigned addConstant(LinkTimeConstant type)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         VM&amp; vm = this-&gt;vm();</span>
<span class="line-removed">-         auto locker = lockDuringMarking(vm.heap, cellLock());</span>
<span class="line-removed">-         unsigned result = m_constantRegisters.size();</span>
<span class="line-removed">-         ASSERT(result);</span>
<span class="line-removed">-         unsigned index = static_cast&lt;unsigned&gt;(type);</span>
<span class="line-removed">-         ASSERT(index &lt; LinkTimeConstantCount);</span>
<span class="line-removed">-         m_linkTimeConstants[index] = result;</span>
<span class="line-removed">-         m_constantRegisters.append(WriteBarrier&lt;Unknown&gt;());</span>
<span class="line-removed">-         m_constantsSourceCodeRepresentation.append(SourceCodeRepresentation::Other);</span>
<span class="line-removed">-         return result;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     unsigned registerIndexForLinkTimeConstant(LinkTimeConstant type)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         unsigned index = static_cast&lt;unsigned&gt;(type);</span>
<span class="line-removed">-         ASSERT(index &lt; LinkTimeConstantCount);</span>
<span class="line-removed">-         return m_linkTimeConstants[index];</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     const Vector&lt;WriteBarrier&lt;Unknown&gt;&gt;&amp; constantRegisters() { return m_constantRegisters; }</span>
<span class="line-removed">-     const WriteBarrier&lt;Unknown&gt;&amp; constantRegister(int index) const { return m_constantRegisters[index - FirstConstantRegisterIndex]; }</span>
<span class="line-removed">-     ALWAYS_INLINE bool isConstantRegisterIndex(int index) const { return index &gt;= FirstConstantRegisterIndex; }</span>
<span class="line-removed">-     ALWAYS_INLINE JSValue getConstant(int index) const { return m_constantRegisters[index - FirstConstantRegisterIndex].get(); }</span>
<span class="line-removed">-     const Vector&lt;SourceCodeRepresentation&gt;&amp; constantsSourceCodeRepresentation() { return m_constantsSourceCodeRepresentation; }</span>
  
      unsigned numberOfConstantIdentifierSets() const { return m_rareData ? m_rareData-&gt;m_constantIdentifierSets.size() : 0; }
<span class="line-modified">!     const Vector&lt;ConstantIdentifierSetEntry&gt;&amp; constantIdentifierSets() { ASSERT(m_rareData); return m_rareData-&gt;m_constantIdentifierSets; }</span>
  
      // Jumps
      size_t numberOfJumpTargets() const { return m_jumpTargets.size(); }
<span class="line-removed">-     void addJumpTarget(unsigned jumpTarget) { m_jumpTargets.append(jumpTarget); }</span>
      unsigned jumpTarget(int index) const { return m_jumpTargets[index]; }
      unsigned lastJumpTarget() const { return m_jumpTargets.last(); }
  
<span class="line-modified">!     UnlinkedHandlerInfo* handlerForBytecodeOffset(unsigned bytecodeOffset, RequiredHandler = RequiredHandler::AnyHandler);</span>
      UnlinkedHandlerInfo* handlerForIndex(unsigned, RequiredHandler = RequiredHandler::AnyHandler);
  
      bool isBuiltinFunction() const { return m_isBuiltinFunction; }
  
      ConstructorKind constructorKind() const { return static_cast&lt;ConstructorKind&gt;(m_constructorKind); }
      SuperBinding superBinding() const { return static_cast&lt;SuperBinding&gt;(m_superBinding); }
      JSParserScriptMode scriptMode() const { return static_cast&lt;JSParserScriptMode&gt;(m_scriptMode); }
  
<span class="line-removed">-     void shrinkToFit();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void setInstructions(std::unique_ptr&lt;InstructionStream&gt;);</span>
      const InstructionStream&amp; instructions() const;
  
      int numCalleeLocals() const { return m_numCalleeLocals; }
      int numVars() const { return m_numVars; }
  
      // Jump Tables
  
      size_t numberOfSwitchJumpTables() const { return m_rareData ? m_rareData-&gt;m_switchJumpTables.size() : 0; }
<span class="line-removed">-     UnlinkedSimpleJumpTable&amp; addSwitchJumpTable() { createRareDataIfNecessary(); m_rareData-&gt;m_switchJumpTables.append(UnlinkedSimpleJumpTable()); return m_rareData-&gt;m_switchJumpTables.last(); }</span>
      UnlinkedSimpleJumpTable&amp; switchJumpTable(int tableIndex) { ASSERT(m_rareData); return m_rareData-&gt;m_switchJumpTables[tableIndex]; }
  
      size_t numberOfStringSwitchJumpTables() const { return m_rareData ? m_rareData-&gt;m_stringSwitchJumpTables.size() : 0; }
<span class="line-removed">-     UnlinkedStringJumpTable&amp; addStringSwitchJumpTable() { createRareDataIfNecessary(); m_rareData-&gt;m_stringSwitchJumpTables.append(UnlinkedStringJumpTable()); return m_rareData-&gt;m_stringSwitchJumpTables.last(); }</span>
      UnlinkedStringJumpTable&amp; stringSwitchJumpTable(int tableIndex) { ASSERT(m_rareData); return m_rareData-&gt;m_stringSwitchJumpTables[tableIndex]; }
  
<span class="line-removed">-     unsigned addFunctionDecl(UnlinkedFunctionExecutable* n)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         VM&amp; vm = this-&gt;vm();</span>
<span class="line-removed">-         auto locker = lockDuringMarking(vm.heap, cellLock());</span>
<span class="line-removed">-         unsigned size = m_functionDecls.size();</span>
<span class="line-removed">-         m_functionDecls.append(WriteBarrier&lt;UnlinkedFunctionExecutable&gt;());</span>
<span class="line-removed">-         m_functionDecls.last().set(vm, this, n);</span>
<span class="line-removed">-         return size;</span>
<span class="line-removed">-     }</span>
      UnlinkedFunctionExecutable* functionDecl(int index) { return m_functionDecls[index].get(); }
      size_t numberOfFunctionDecls() { return m_functionDecls.size(); }
<span class="line-removed">-     unsigned addFunctionExpr(UnlinkedFunctionExecutable* n)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         VM&amp; vm = this-&gt;vm();</span>
<span class="line-removed">-         auto locker = lockDuringMarking(vm.heap, cellLock());</span>
<span class="line-removed">-         unsigned size = m_functionExprs.size();</span>
<span class="line-removed">-         m_functionExprs.append(WriteBarrier&lt;UnlinkedFunctionExecutable&gt;());</span>
<span class="line-removed">-         m_functionExprs.last().set(vm, this, n);</span>
<span class="line-removed">-         return size;</span>
<span class="line-removed">-     }</span>
      UnlinkedFunctionExecutable* functionExpr(int index) { return m_functionExprs[index].get(); }
      size_t numberOfFunctionExprs() { return m_functionExprs.size(); }
  
      // Exception handling support
      size_t numberOfExceptionHandlers() const { return m_rareData ? m_rareData-&gt;m_exceptionHandlers.size() : 0; }
<span class="line-removed">-     void addExceptionHandler(const UnlinkedHandlerInfo&amp; handler) { createRareDataIfNecessary(); return m_rareData-&gt;m_exceptionHandlers.append(handler); }</span>
      UnlinkedHandlerInfo&amp; exceptionHandler(int index) { ASSERT(m_rareData); return m_rareData-&gt;m_exceptionHandlers[index]; }
  
      CodeType codeType() const { return static_cast&lt;CodeType&gt;(m_codeType); }
  
      VirtualRegister thisRegister() const { return m_thisRegister; }
      VirtualRegister scopeRegister() const { return m_scopeRegister; }
  
<span class="line-removed">-     void addPropertyAccessInstruction(InstructionStream::Offset propertyAccessInstruction)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         m_propertyAccessInstructions.append(propertyAccessInstruction);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     size_t numberOfPropertyAccessInstructions() const { return m_propertyAccessInstructions.size(); }</span>
<span class="line-removed">-     const Vector&lt;InstructionStream::Offset&gt;&amp; propertyAccessInstructions() const { return m_propertyAccessInstructions; }</span>
<span class="line-removed">- </span>
      bool hasRareData() const { return m_rareData.get(); }
  
<span class="line-modified">!     int lineNumberForBytecodeOffset(unsigned bytecodeOffset);</span>
  
<span class="line-modified">!     void expressionRangeForBytecodeOffset(unsigned bytecodeOffset, int&amp; divot,</span>
          int&amp; startOffset, int&amp; endOffset, unsigned&amp; line, unsigned&amp; column) const;
  
      bool typeProfilerExpressionInfoForBytecodeOffset(unsigned bytecodeOffset, unsigned&amp; startDivot, unsigned&amp; endDivot);
  
      void recordParse(CodeFeatures features, bool hasCapturedVariables, unsigned lineCount, unsigned endColumn)
<span class="line-new-header">--- 133,86 ---</span>
      bool isClassContext() const { return m_isClassContext; }
      bool hasTailCalls() const { return m_hasTailCalls; }
      void setHasTailCalls() { m_hasTailCalls = true; }
      bool allowDirectEvalCache() const { return !(m_features &amp; NoEvalCacheFeature); }
  
      bool hasExpressionInfo() { return m_expressionInfo.size(); }
<span class="line-modified">!     const RefCountedArray&lt;ExpressionRangeInfo&gt;&amp; expressionInfo() { return m_expressionInfo; }</span>
<span class="line-added">+ </span>
<span class="line-added">+     bool hasCheckpoints() const { return m_hasCheckpoints; }</span>
<span class="line-added">+     void setHasCheckpoints() { m_hasCheckpoints = true; }</span>
  
      // Special registers
      void setThisRegister(VirtualRegister thisRegister) { m_thisRegister = thisRegister; }
      void setScopeRegister(VirtualRegister scopeRegister) { m_scopeRegister = scopeRegister; }
  
      // Parameter information
      void setNumParameters(int newValue) { m_numParameters = newValue; }
      unsigned numParameters() const { return m_numParameters; }
  
      // Constant Pools
  
      size_t numberOfIdentifiers() const { return m_identifiers.size(); }
      const Identifier&amp; identifier(int index) const { return m_identifiers[index]; }
<span class="line-modified">!     const RefCountedArray&lt;Identifier&gt;&amp; identifiers() const { return m_identifiers; }</span>
  
      BitVector&amp; bitVector(size_t i) { ASSERT(m_rareData); return m_rareData-&gt;m_bitVectors[i]; }
  
<span class="line-modified">!     const RefCountedArray&lt;WriteBarrier&lt;Unknown&gt;&gt;&amp; constantRegisters() { return m_constantRegisters; }</span>
<span class="line-modified">!     const WriteBarrier&lt;Unknown&gt;&amp; constantRegister(VirtualRegister reg) const { return m_constantRegisters[reg.toConstantIndex()]; }</span>
<span class="line-modified">!     ALWAYS_INLINE JSValue getConstant(VirtualRegister reg) const { return m_constantRegisters[reg.toConstantIndex()].get(); }</span>
<span class="line-modified">!     const RefCountedArray&lt;SourceCodeRepresentation&gt;&amp; constantsSourceCodeRepresentation() { return m_constantsSourceCodeRepresentation; }</span>
  
      unsigned numberOfConstantIdentifierSets() const { return m_rareData ? m_rareData-&gt;m_constantIdentifierSets.size() : 0; }
<span class="line-modified">!     const RefCountedArray&lt;ConstantIdentifierSetEntry&gt;&amp; constantIdentifierSets() { ASSERT(m_rareData); return m_rareData-&gt;m_constantIdentifierSets; }</span>
  
      // Jumps
      size_t numberOfJumpTargets() const { return m_jumpTargets.size(); }
      unsigned jumpTarget(int index) const { return m_jumpTargets[index]; }
      unsigned lastJumpTarget() const { return m_jumpTargets.last(); }
  
<span class="line-modified">!     UnlinkedHandlerInfo* handlerForBytecodeIndex(BytecodeIndex, RequiredHandler = RequiredHandler::AnyHandler);</span>
      UnlinkedHandlerInfo* handlerForIndex(unsigned, RequiredHandler = RequiredHandler::AnyHandler);
  
      bool isBuiltinFunction() const { return m_isBuiltinFunction; }
  
      ConstructorKind constructorKind() const { return static_cast&lt;ConstructorKind&gt;(m_constructorKind); }
      SuperBinding superBinding() const { return static_cast&lt;SuperBinding&gt;(m_superBinding); }
      JSParserScriptMode scriptMode() const { return static_cast&lt;JSParserScriptMode&gt;(m_scriptMode); }
  
      const InstructionStream&amp; instructions() const;
  
      int numCalleeLocals() const { return m_numCalleeLocals; }
      int numVars() const { return m_numVars; }
  
      // Jump Tables
  
      size_t numberOfSwitchJumpTables() const { return m_rareData ? m_rareData-&gt;m_switchJumpTables.size() : 0; }
      UnlinkedSimpleJumpTable&amp; switchJumpTable(int tableIndex) { ASSERT(m_rareData); return m_rareData-&gt;m_switchJumpTables[tableIndex]; }
  
      size_t numberOfStringSwitchJumpTables() const { return m_rareData ? m_rareData-&gt;m_stringSwitchJumpTables.size() : 0; }
      UnlinkedStringJumpTable&amp; stringSwitchJumpTable(int tableIndex) { ASSERT(m_rareData); return m_rareData-&gt;m_stringSwitchJumpTables[tableIndex]; }
  
      UnlinkedFunctionExecutable* functionDecl(int index) { return m_functionDecls[index].get(); }
      size_t numberOfFunctionDecls() { return m_functionDecls.size(); }
      UnlinkedFunctionExecutable* functionExpr(int index) { return m_functionExprs[index].get(); }
      size_t numberOfFunctionExprs() { return m_functionExprs.size(); }
  
      // Exception handling support
      size_t numberOfExceptionHandlers() const { return m_rareData ? m_rareData-&gt;m_exceptionHandlers.size() : 0; }
      UnlinkedHandlerInfo&amp; exceptionHandler(int index) { ASSERT(m_rareData); return m_rareData-&gt;m_exceptionHandlers[index]; }
  
      CodeType codeType() const { return static_cast&lt;CodeType&gt;(m_codeType); }
  
      VirtualRegister thisRegister() const { return m_thisRegister; }
      VirtualRegister scopeRegister() const { return m_scopeRegister; }
  
      bool hasRareData() const { return m_rareData.get(); }
  
<span class="line-modified">!     int lineNumberForBytecodeIndex(BytecodeIndex);</span>
  
<span class="line-modified">!     void expressionRangeForBytecodeIndex(BytecodeIndex, int&amp; divot,</span>
          int&amp; startOffset, int&amp; endOffset, unsigned&amp; line, unsigned&amp; column) const;
  
      bool typeProfilerExpressionInfoForBytecodeOffset(unsigned bytecodeOffset, unsigned&amp; startDivot, unsigned&amp; endDivot);
  
      void recordParse(CodeFeatures features, bool hasCapturedVariables, unsigned lineCount, unsigned endColumn)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 301,27 ***</span>
          m_lineCount = lineCount;
          // For the UnlinkedCodeBlock, startColumn is always 0.
          m_endColumn = endColumn;
      }
  
<span class="line-modified">!     const String&amp; sourceURLDirective() const { return m_sourceURLDirective; }</span>
<span class="line-modified">!     const String&amp; sourceMappingURLDirective() const { return m_sourceMappingURLDirective; }</span>
<span class="line-modified">!     void setSourceURLDirective(const String&amp; sourceURL) { m_sourceURLDirective = sourceURL; }</span>
<span class="line-modified">!     void setSourceMappingURLDirective(const String&amp; sourceMappingURL) { m_sourceMappingURLDirective = sourceMappingURL; }</span>
  
      CodeFeatures codeFeatures() const { return m_features; }
      bool hasCapturedVariables() const { return m_hasCapturedVariables; }
      unsigned lineCount() const { return m_lineCount; }
      ALWAYS_INLINE unsigned startColumn() const { return 0; }
      unsigned endColumn() const { return m_endColumn; }
  
<span class="line-modified">!     void addOpProfileControlFlowBytecodeOffset(InstructionStream::Offset offset)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         createRareDataIfNecessary();</span>
<span class="line-removed">-         m_rareData-&gt;m_opProfileControlFlowBytecodeOffsets.append(offset);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     const Vector&lt;InstructionStream::Offset&gt;&amp; opProfileControlFlowBytecodeOffsets() const</span>
      {
          ASSERT(m_rareData);
          return m_rareData-&gt;m_opProfileControlFlowBytecodeOffsets;
      }
      bool hasOpProfileControlFlowBytecodeOffsets() const
<span class="line-new-header">--- 222,22 ---</span>
          m_lineCount = lineCount;
          // For the UnlinkedCodeBlock, startColumn is always 0.
          m_endColumn = endColumn;
      }
  
<span class="line-modified">!     StringImpl* sourceURLDirective() const { return m_sourceURLDirective.get(); }</span>
<span class="line-modified">!     StringImpl* sourceMappingURLDirective() const { return m_sourceMappingURLDirective.get(); }</span>
<span class="line-modified">!     void setSourceURLDirective(const String&amp; sourceURL) { m_sourceURLDirective = sourceURL.impl(); }</span>
<span class="line-modified">!     void setSourceMappingURLDirective(const String&amp; sourceMappingURL) { m_sourceMappingURLDirective = sourceMappingURL.impl(); }</span>
  
      CodeFeatures codeFeatures() const { return m_features; }
      bool hasCapturedVariables() const { return m_hasCapturedVariables; }
      unsigned lineCount() const { return m_lineCount; }
      ALWAYS_INLINE unsigned startColumn() const { return 0; }
      unsigned endColumn() const { return m_endColumn; }
  
<span class="line-modified">!     const RefCountedArray&lt;InstructionStream::Offset&gt;&amp; opProfileControlFlowBytecodeOffsets() const</span>
      {
          ASSERT(m_rareData);
          return m_rareData-&gt;m_opProfileControlFlowBytecodeOffsets;
      }
      bool hasOpProfileControlFlowBytecodeOffsets() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 342,10 ***</span>
<span class="line-new-header">--- 258,17 ---</span>
      static constexpr unsigned maxAge = 7;
  
      unsigned age() const { return m_age; }
      void resetAge() { m_age = 0; }
  
<span class="line-added">+     NeedsClassFieldInitializer needsClassFieldInitializer() const</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (m_rareData)</span>
<span class="line-added">+             return static_cast&lt;NeedsClassFieldInitializer&gt;(m_rareData-&gt;m_needsClassFieldInitializer);</span>
<span class="line-added">+         return NeedsClassFieldInitializer::No;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      void dump(PrintStream&amp;) const;
  
      BytecodeLivenessAnalysis&amp; livenessAnalysis(CodeBlock* codeBlock)
      {
          if (m_liveness)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 389,34 ***</span>
          Base::finishCreation(vm);
      }
  
  private:
      friend class BytecodeRewriter;
<span class="line-modified">!     friend class BytecodeGenerator;</span>
  
      template&lt;typename CodeBlockType&gt;
      friend class CachedCodeBlock;
  
<span class="line-modified">!     void applyModification(BytecodeRewriter&amp;, InstructionStreamWriter&amp;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     void createRareDataIfNecessary()</span>
      {
<span class="line-modified">!         if (!m_rareData) {</span>
<span class="line-removed">-             auto locker = lockDuringMarking(*heap(), cellLock());</span>
              m_rareData = makeUnique&lt;RareData&gt;();
<span class="line-removed">-         }</span>
      }
  
      void getLineAndColumn(const ExpressionRangeInfo&amp;, unsigned&amp; line, unsigned&amp; column) const;
      BytecodeLivenessAnalysis&amp; livenessAnalysisSlow(CodeBlock*);
  
  
      VirtualRegister m_thisRegister;
      VirtualRegister m_scopeRegister;
  
<span class="line-removed">-     std::array&lt;unsigned, LinkTimeConstantCount&gt; m_linkTimeConstants;</span>
<span class="line-removed">- </span>
      unsigned m_usesEval : 1;
      unsigned m_isStrictMode : 1;
      unsigned m_isConstructor : 1;
      unsigned m_hasCapturedVariables : 1;
      unsigned m_isBuiltinFunction : 1;
<span class="line-new-header">--- 312,30 ---</span>
          Base::finishCreation(vm);
      }
  
  private:
      friend class BytecodeRewriter;
<span class="line-modified">!     friend class UnlinkedCodeBlockGenerator;</span>
<span class="line-added">+     template&lt;typename Traits&gt;</span>
<span class="line-added">+     friend class BytecodeGeneratorBase;</span>
  
      template&lt;typename CodeBlockType&gt;
      friend class CachedCodeBlock;
  
<span class="line-modified">!     void createRareDataIfNecessary(const AbstractLocker&amp;)</span>
      {
<span class="line-modified">!         if (!m_rareData)</span>
              m_rareData = makeUnique&lt;RareData&gt;();
      }
  
      void getLineAndColumn(const ExpressionRangeInfo&amp;, unsigned&amp; line, unsigned&amp; column) const;
      BytecodeLivenessAnalysis&amp; livenessAnalysisSlow(CodeBlock*);
  
  
      VirtualRegister m_thisRegister;
      VirtualRegister m_scopeRegister;
  
      unsigned m_usesEval : 1;
      unsigned m_isStrictMode : 1;
      unsigned m_isConstructor : 1;
      unsigned m_hasCapturedVariables : 1;
      unsigned m_isBuiltinFunction : 1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 430,10 ***</span>
<span class="line-new-header">--- 349,11 ---</span>
      unsigned m_evalContextType : 2;
      unsigned m_codeType : 2;
      unsigned m_didOptimize : 2;
      unsigned m_age : 3;
      static_assert(((1U &lt;&lt; 3) - 1) &gt;= maxAge);
<span class="line-added">+     bool m_hasCheckpoints : 1;</span>
  public:
      ConcurrentJSLock m_lock;
  private:
      CodeFeatures m_features { 0 };
      SourceParseMode m_parseMode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 444,76 ***</span>
  
      int m_numVars { 0 };
      int m_numCalleeLocals { 0 };
      int m_numParameters { 0 };
  
<span class="line-modified">!     String m_sourceURLDirective;</span>
<span class="line-modified">!     String m_sourceMappingURLDirective;</span>
  
<span class="line-modified">!     Vector&lt;InstructionStream::Offset&gt; m_jumpTargets;</span>
      Ref&lt;UnlinkedMetadataTable&gt; m_metadata;
      std::unique_ptr&lt;InstructionStream&gt; m_instructions;
      std::unique_ptr&lt;BytecodeLivenessAnalysis&gt; m_liveness;
  
  
  #if ENABLE(DFG_JIT)
      DFG::ExitProfile m_exitProfile;
  #endif
  
<span class="line-removed">- </span>
<span class="line-removed">-     Vector&lt;InstructionStream::Offset&gt; m_propertyAccessInstructions;</span>
<span class="line-removed">- </span>
      // Constant Pools
<span class="line-modified">!     Vector&lt;Identifier&gt; m_identifiers;</span>
<span class="line-modified">!     Vector&lt;WriteBarrier&lt;Unknown&gt;&gt; m_constantRegisters;</span>
<span class="line-modified">!     Vector&lt;SourceCodeRepresentation&gt; m_constantsSourceCodeRepresentation;</span>
<span class="line-modified">!     typedef Vector&lt;WriteBarrier&lt;UnlinkedFunctionExecutable&gt;&gt; FunctionExpressionVector;</span>
      FunctionExpressionVector m_functionDecls;
      FunctionExpressionVector m_functionExprs;
  
  public:
      struct RareData {
          WTF_MAKE_STRUCT_FAST_ALLOCATED;
  
<span class="line-modified">!         Vector&lt;UnlinkedHandlerInfo&gt; m_exceptionHandlers;</span>
  
          // Jump Tables
<span class="line-modified">!         Vector&lt;UnlinkedSimpleJumpTable&gt; m_switchJumpTables;</span>
<span class="line-modified">!         Vector&lt;UnlinkedStringJumpTable&gt; m_stringSwitchJumpTables;</span>
  
<span class="line-modified">!         Vector&lt;ExpressionRangeInfo::FatPosition&gt; m_expressionInfoFatPositions;</span>
  
          struct TypeProfilerExpressionRange {
              unsigned m_startDivot;
              unsigned m_endDivot;
          };
          HashMap&lt;unsigned, TypeProfilerExpressionRange&gt; m_typeProfilerInfoMap;
<span class="line-modified">!         Vector&lt;InstructionStream::Offset&gt; m_opProfileControlFlowBytecodeOffsets;</span>
<span class="line-modified">!         Vector&lt;BitVector&gt; m_bitVectors;</span>
<span class="line-modified">!         Vector&lt;ConstantIdentifierSetEntry&gt; m_constantIdentifierSets;</span>
      };
  
<span class="line-removed">-     void addOutOfLineJumpTarget(InstructionStream::Offset, int target);</span>
      int outOfLineJumpOffset(InstructionStream::Offset);
      int outOfLineJumpOffset(const InstructionStream::Ref&amp; instruction)
      {
          return outOfLineJumpOffset(instruction.offset());
      }
  
  private:
      using OutOfLineJumpTargets = HashMap&lt;InstructionStream::Offset, int&gt;;
  
<span class="line-removed">-     OutOfLineJumpTargets replaceOutOfLineJumpTargets()</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         OutOfLineJumpTargets newJumpTargets;</span>
<span class="line-removed">-         std::swap(m_outOfLineJumpTargets, newJumpTargets);</span>
<span class="line-removed">-         return newJumpTargets;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      OutOfLineJumpTargets m_outOfLineJumpTargets;
      std::unique_ptr&lt;RareData&gt; m_rareData;
<span class="line-modified">!     Vector&lt;ExpressionRangeInfo&gt; m_expressionInfo;</span>
  
  protected:
      static void visitChildren(JSCell*, SlotVisitor&amp;);
      static size_t estimatedSize(JSCell*, VM&amp;);
  
<span class="line-new-header">--- 364,67 ---</span>
  
      int m_numVars { 0 };
      int m_numCalleeLocals { 0 };
      int m_numParameters { 0 };
  
<span class="line-modified">!     PackedRefPtr&lt;StringImpl&gt; m_sourceURLDirective;</span>
<span class="line-modified">!     PackedRefPtr&lt;StringImpl&gt; m_sourceMappingURLDirective;</span>
  
<span class="line-modified">!     RefCountedArray&lt;InstructionStream::Offset&gt; m_jumpTargets;</span>
      Ref&lt;UnlinkedMetadataTable&gt; m_metadata;
      std::unique_ptr&lt;InstructionStream&gt; m_instructions;
      std::unique_ptr&lt;BytecodeLivenessAnalysis&gt; m_liveness;
  
  
  #if ENABLE(DFG_JIT)
      DFG::ExitProfile m_exitProfile;
  #endif
  
      // Constant Pools
<span class="line-modified">!     RefCountedArray&lt;Identifier&gt; m_identifiers;</span>
<span class="line-modified">!     RefCountedArray&lt;WriteBarrier&lt;Unknown&gt;&gt; m_constantRegisters;</span>
<span class="line-modified">!     RefCountedArray&lt;SourceCodeRepresentation&gt; m_constantsSourceCodeRepresentation;</span>
<span class="line-modified">!     using FunctionExpressionVector = RefCountedArray&lt;WriteBarrier&lt;UnlinkedFunctionExecutable&gt;&gt;;</span>
      FunctionExpressionVector m_functionDecls;
      FunctionExpressionVector m_functionExprs;
  
  public:
      struct RareData {
          WTF_MAKE_STRUCT_FAST_ALLOCATED;
  
<span class="line-modified">!         RefCountedArray&lt;UnlinkedHandlerInfo&gt; m_exceptionHandlers;</span>
  
          // Jump Tables
<span class="line-modified">!         RefCountedArray&lt;UnlinkedSimpleJumpTable&gt; m_switchJumpTables;</span>
<span class="line-modified">!         RefCountedArray&lt;UnlinkedStringJumpTable&gt; m_stringSwitchJumpTables;</span>
  
<span class="line-modified">!         RefCountedArray&lt;ExpressionRangeInfo::FatPosition&gt; m_expressionInfoFatPositions;</span>
  
          struct TypeProfilerExpressionRange {
              unsigned m_startDivot;
              unsigned m_endDivot;
          };
          HashMap&lt;unsigned, TypeProfilerExpressionRange&gt; m_typeProfilerInfoMap;
<span class="line-modified">!         RefCountedArray&lt;InstructionStream::Offset&gt; m_opProfileControlFlowBytecodeOffsets;</span>
<span class="line-modified">!         RefCountedArray&lt;BitVector&gt; m_bitVectors;</span>
<span class="line-modified">!         RefCountedArray&lt;ConstantIdentifierSetEntry&gt; m_constantIdentifierSets;</span>
<span class="line-added">+ </span>
<span class="line-added">+         unsigned m_needsClassFieldInitializer : 1;</span>
      };
  
      int outOfLineJumpOffset(InstructionStream::Offset);
      int outOfLineJumpOffset(const InstructionStream::Ref&amp; instruction)
      {
          return outOfLineJumpOffset(instruction.offset());
      }
  
  private:
      using OutOfLineJumpTargets = HashMap&lt;InstructionStream::Offset, int&gt;;
  
      OutOfLineJumpTargets m_outOfLineJumpTargets;
      std::unique_ptr&lt;RareData&gt; m_rareData;
<span class="line-modified">!     RefCountedArray&lt;ExpressionRangeInfo&gt; m_expressionInfo;</span>
  
  protected:
      static void visitChildren(JSCell*, SlotVisitor&amp;);
      static size_t estimatedSize(JSCell*, VM&amp;);
  
</pre>
<center><a href="UnlinkedCodeBlock.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UnlinkedEvalCodeBlock.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/HTMLTextAreaElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
  5  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.
  6  *           (C) 2006 Alexey Proskuryakov (ap@nypop.com)
  7  * Copyright (C) 2007 Samuel Weinig (sam@webkit.org)
  8  *
  9  * This library is free software; you can redistribute it and/or
 10  * modify it under the terms of the GNU Library General Public
 11  * License as published by the Free Software Foundation; either
 12  * version 2 of the License, or (at your option) any later version.
 13  *
 14  * This library is distributed in the hope that it will be useful,
 15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 17  * Library General Public License for more details.
 18  *
 19  * You should have received a copy of the GNU Library General Public License
 20  * along with this library; see the file COPYING.LIB.  If not, write to
 21  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 22  * Boston, MA 02110-1301, USA.
 23  *
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;HTMLTextAreaElement.h&quot;
 28 
 29 #include &quot;BeforeTextInsertedEvent.h&quot;
 30 #include &quot;CSSValueKeywords.h&quot;
 31 #include &quot;DOMFormData.h&quot;
 32 #include &quot;Document.h&quot;
 33 #include &quot;Editor.h&quot;
 34 #include &quot;ElementChildIterator.h&quot;
 35 #include &quot;Event.h&quot;
 36 #include &quot;EventNames.h&quot;
 37 #include &quot;FormController.h&quot;
 38 #include &quot;Frame.h&quot;
 39 #include &quot;FrameSelection.h&quot;
 40 #include &quot;HTMLNames.h&quot;
 41 #include &quot;HTMLParserIdioms.h&quot;
 42 #include &quot;LocalizedStrings.h&quot;
 43 #include &quot;RenderTextControlMultiLine.h&quot;
 44 #include &quot;ShadowRoot.h&quot;
 45 #include &quot;Text.h&quot;
 46 #include &quot;TextControlInnerElements.h&quot;
 47 #include &quot;TextIterator.h&quot;
 48 #include &quot;TextNodeTraversal.h&quot;
 49 #include &lt;wtf/IsoMallocInlines.h&gt;
 50 #include &lt;wtf/Ref.h&gt;
 51 #include &lt;wtf/StdLibExtras.h&gt;
 52 
 53 namespace WebCore {
 54 
 55 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLTextAreaElement);
 56 
 57 using namespace HTMLNames;
 58 
 59 static const int defaultRows = 2;
 60 static const int defaultCols = 20;
 61 
 62 // On submission, LF characters are converted into CRLF.
 63 // This function returns number of characters considering this.
 64 static inline unsigned computeLengthForSubmission(StringView text, unsigned numberOfLineBreaks)
 65 {
 66     return numGraphemeClusters(text) + numberOfLineBreaks;
 67 }
 68 
 69 static unsigned numberOfLineBreaks(StringView text)
 70 {
 71     unsigned length = text.length();
 72     unsigned count = 0;
 73     for (unsigned i = 0; i &lt; length; i++) {
 74         if (text[i] == &#39;\n&#39;)
 75             count++;
 76     }
 77     return count;
 78 }
 79 
 80 static inline unsigned computeLengthForSubmission(StringView text)
 81 {
 82     return numGraphemeClusters(text) + numberOfLineBreaks(text);
 83 }
 84 
 85 static inline unsigned upperBoundForLengthForSubmission(StringView text, unsigned numberOfLineBreaks)
 86 {
 87     return text.length() + numberOfLineBreaks;
 88 }
 89 
 90 HTMLTextAreaElement::HTMLTextAreaElement(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form)
 91     : HTMLTextFormControlElement(tagName, document, form)
 92     , m_rows(defaultRows)
 93     , m_cols(defaultCols)
 94 {
 95     ASSERT(hasTagName(textareaTag));
 96     setFormControlValueMatchesRenderer(true);
 97 }
 98 
 99 Ref&lt;HTMLTextAreaElement&gt; HTMLTextAreaElement::create(const QualifiedName&amp; tagName, Document&amp; document, HTMLFormElement* form)
100 {
101     auto textArea = adoptRef(*new HTMLTextAreaElement(tagName, document, form));
102     textArea-&gt;ensureUserAgentShadowRoot();
103     return textArea;
104 }
105 
106 void HTMLTextAreaElement::didAddUserAgentShadowRoot(ShadowRoot&amp; root)
107 {
108     root.appendChild(TextControlInnerTextElement::create(document()));
109     updateInnerTextElementEditability();
110 }
111 
112 const AtomString&amp; HTMLTextAreaElement::formControlType() const
113 {
114     static NeverDestroyed&lt;const AtomString&gt; textarea(&quot;textarea&quot;, AtomString::ConstructFromLiteral);
115     return textarea;
116 }
117 
118 FormControlState HTMLTextAreaElement::saveFormControlState() const
119 {
120     return m_isDirty ? FormControlState { { value() } } : FormControlState { };
121 }
122 
123 void HTMLTextAreaElement::restoreFormControlState(const FormControlState&amp; state)
124 {
125     setValue(state[0]);
126 }
127 
128 void HTMLTextAreaElement::childrenChanged(const ChildChange&amp; change)
129 {
130     HTMLElement::childrenChanged(change);
131     setLastChangeWasNotUserEdit();
132     if (m_isDirty)
133         setInnerTextValue(value());
134     else
135         setNonDirtyValue(defaultValue());
136 }
137 
138 bool HTMLTextAreaElement::isPresentationAttribute(const QualifiedName&amp; name) const
139 {
140     if (name == alignAttr) {
141         // Don&#39;t map &#39;align&#39; attribute.  This matches what Firefox, Opera and IE do.
142         // See http://bugs.webkit.org/show_bug.cgi?id=7075
143         return false;
144     }
145 
146     if (name == wrapAttr)
147         return true;
148     return HTMLTextFormControlElement::isPresentationAttribute(name);
149 }
150 
151 void HTMLTextAreaElement::collectStyleForPresentationAttribute(const QualifiedName&amp; name, const AtomString&amp; value, MutableStyleProperties&amp; style)
152 {
153     if (name == wrapAttr) {
154         if (shouldWrapText()) {
155             addPropertyToPresentationAttributeStyle(style, CSSPropertyWhiteSpace, CSSValuePreWrap);
156             addPropertyToPresentationAttributeStyle(style, CSSPropertyWordWrap, CSSValueBreakWord);
157         } else {
158             addPropertyToPresentationAttributeStyle(style, CSSPropertyWhiteSpace, CSSValuePre);
159             addPropertyToPresentationAttributeStyle(style, CSSPropertyWordWrap, CSSValueNormal);
160         }
161     } else
162         HTMLTextFormControlElement::collectStyleForPresentationAttribute(name, value, style);
163 }
164 
165 void HTMLTextAreaElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
166 {
167     if (name == rowsAttr) {
168         unsigned rows = limitToOnlyHTMLNonNegativeNumbersGreaterThanZero(value, defaultRows);
169         if (m_rows != rows) {
170             m_rows = rows;
171             if (renderer())
172                 renderer()-&gt;setNeedsLayoutAndPrefWidthsRecalc();
173         }
174     } else if (name == colsAttr) {
175         unsigned cols = limitToOnlyHTMLNonNegativeNumbersGreaterThanZero(value, defaultCols);
176         if (m_cols != cols) {
177             m_cols = cols;
178             if (renderer())
179                 renderer()-&gt;setNeedsLayoutAndPrefWidthsRecalc();
180         }
181     } else if (name == wrapAttr) {
182         // The virtual/physical values were a Netscape extension of HTML 3.0, now deprecated.
183         // The soft/hard /off values are a recommendation for HTML 4 extension by IE and NS 4.
184         WrapMethod wrap;
185         if (equalLettersIgnoringASCIICase(value, &quot;physical&quot;) || equalLettersIgnoringASCIICase(value, &quot;hard&quot;) || equalLettersIgnoringASCIICase(value, &quot;on&quot;))
186             wrap = HardWrap;
187         else if (equalLettersIgnoringASCIICase(value, &quot;off&quot;))
188             wrap = NoWrap;
189         else
190             wrap = SoftWrap;
191         if (wrap != m_wrap) {
192             m_wrap = wrap;
193             if (renderer())
194                 renderer()-&gt;setNeedsLayoutAndPrefWidthsRecalc();
195         }
196     } else if (name == maxlengthAttr)
197         maxLengthAttributeChanged(value);
198     else if (name == minlengthAttr)
199         minLengthAttributeChanged(value);
200     else
201         HTMLTextFormControlElement::parseAttribute(name, value);
202 }
203 
204 void HTMLTextAreaElement::maxLengthAttributeChanged(const AtomString&amp; newValue)
205 {
206     internalSetMaxLength(parseHTMLNonNegativeInteger(newValue).value_or(-1));
207     updateValidity();
208 }
209 
210 void HTMLTextAreaElement::minLengthAttributeChanged(const AtomString&amp; newValue)
211 {
212     internalSetMinLength(parseHTMLNonNegativeInteger(newValue).value_or(-1));
213     updateValidity();
214 }
215 
216 RenderPtr&lt;RenderElement&gt; HTMLTextAreaElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
217 {
218     return createRenderer&lt;RenderTextControlMultiLine&gt;(*this, WTFMove(style));
219 }
220 
221 bool HTMLTextAreaElement::appendFormData(DOMFormData&amp; formData, bool)
222 {
223     if (name().isEmpty())
224         return false;
225 
226     Ref&lt;HTMLTextAreaElement&gt; protectedThis(*this);
227     document().updateLayout();
228 
229     formData.append(name(), m_wrap == HardWrap ? valueWithHardLineBreaks() : value());
230 
231     auto&amp; dirnameAttrValue = attributeWithoutSynchronization(dirnameAttr);
232     if (!dirnameAttrValue.isNull())
233         formData.append(dirnameAttrValue, directionForFormData());
234 
235     return true;
236 }
237 
238 void HTMLTextAreaElement::reset()
239 {
240     setNonDirtyValue(defaultValue());
241 }
242 
243 bool HTMLTextAreaElement::hasCustomFocusLogic() const
244 {
245     return true;
246 }
247 
248 int HTMLTextAreaElement::defaultTabIndex() const
249 {
250     return 0;
251 }
252 
253 bool HTMLTextAreaElement::isKeyboardFocusable(KeyboardEvent*) const
254 {
255     // If a given text area can be focused at all, then it will always be keyboard focusable.
256     return isFocusable();
257 }
258 
259 bool HTMLTextAreaElement::isMouseFocusable() const
260 {
261     return isFocusable();
262 }
263 
264 void HTMLTextAreaElement::updateFocusAppearance(SelectionRestorationMode restorationMode, SelectionRevealMode revealMode)
265 {
266     if (restorationMode == SelectionRestorationMode::SetDefault || !hasCachedSelection()) {
267         // If this is the first focus, set a caret at the beginning of the text.
268         // This matches some browsers&#39; behavior; see bug 11746 Comment #15.
269         // http://bugs.webkit.org/show_bug.cgi?id=11746#c15
270         setSelectionRange(0, 0, SelectionHasNoDirection, revealMode, Element::defaultFocusTextStateChangeIntent());
271     } else
272         restoreCachedSelection(revealMode, Element::defaultFocusTextStateChangeIntent());
273 }
274 
275 void HTMLTextAreaElement::defaultEventHandler(Event&amp; event)
276 {
277     if (renderer() &amp;&amp; (event.isMouseEvent() || event.type() == eventNames().blurEvent))
278         forwardEvent(event);
279     else if (renderer() &amp;&amp; is&lt;BeforeTextInsertedEvent&gt;(event))
280         handleBeforeTextInsertedEvent(downcast&lt;BeforeTextInsertedEvent&gt;(event));
281 
282     HTMLTextFormControlElement::defaultEventHandler(event);
283 }
284 
285 void HTMLTextAreaElement::subtreeHasChanged()
286 {
<a name="1" id="anc1"></a>
287     setFormControlValueMatchesRenderer(false);
288     updateValidity();
289 
290     if (!focused())
291         return;
292 
<a name="2" id="anc2"></a><span class="line-added">293     setChangedSinceLastFormControlChangeEvent(true);</span>
<span class="line-added">294 </span>
295     if (RefPtr&lt;Frame&gt; frame = document().frame())
296         frame-&gt;editor().textDidChangeInTextArea(this);
297     // When typing in a textarea, childrenChanged is not called, so we need to force the directionality check.
298     calculateAndAdjustDirectionality();
299 }
300 
301 void HTMLTextAreaElement::handleBeforeTextInsertedEvent(BeforeTextInsertedEvent&amp; event) const
302 {
303     ASSERT(renderer());
304     int signedMaxLength = effectiveMaxLength();
305     if (signedMaxLength &lt; 0)
306         return;
307     unsigned unsignedMaxLength = static_cast&lt;unsigned&gt;(signedMaxLength);
308 
309     const String&amp; currentValue = innerTextValue();
310     unsigned numberOfLineBreaksInCurrentValue = numberOfLineBreaks(currentValue);
311     if (upperBoundForLengthForSubmission(currentValue, numberOfLineBreaksInCurrentValue)
312         + upperBoundForLengthForSubmission(event.text(), numberOfLineBreaks(event.text())) &lt; unsignedMaxLength)
313         return;
314 
315     unsigned currentLength = computeLengthForSubmission(currentValue, numberOfLineBreaksInCurrentValue);
316     // selectionLength represents the selection length of this text field to be
317     // removed by this insertion.
318     // If the text field has no focus, we don&#39;t need to take account of the
319     // selection length. The selection is the source of text drag-and-drop in
320     // that case, and nothing in the text field will be removed.
321     unsigned selectionLength = focused() ? computeLengthForSubmission(plainText(document().frame()-&gt;selection().selection().toNormalizedRange().get())) : 0;
322     ASSERT(currentLength &gt;= selectionLength);
323     unsigned baseLength = currentLength - selectionLength;
324     unsigned appendableLength = unsignedMaxLength &gt; baseLength ? unsignedMaxLength - baseLength : 0;
325     event.setText(sanitizeUserInputValue(event.text(), appendableLength));
326 }
327 
328 String HTMLTextAreaElement::sanitizeUserInputValue(const String&amp; proposedValue, unsigned maxLength)
329 {
330     return proposedValue.left(numCodeUnitsInGraphemeClusters(proposedValue, maxLength));
331 }
332 
333 RefPtr&lt;TextControlInnerTextElement&gt; HTMLTextAreaElement::innerTextElement() const
334 {
335     RefPtr&lt;ShadowRoot&gt; root = userAgentShadowRoot();
336     if (!root)
337         return nullptr;
338 
339     return childrenOfType&lt;TextControlInnerTextElement&gt;(*root).first();
340 }
341 
342 void HTMLTextAreaElement::rendererWillBeDestroyed()
343 {
344     updateValue();
345 }
346 
347 void HTMLTextAreaElement::updateValue() const
348 {
349     if (formControlValueMatchesRenderer())
350         return;
351 
352     ASSERT(renderer());
353     m_value = innerTextValue();
354     const_cast&lt;HTMLTextAreaElement*&gt;(this)-&gt;setFormControlValueMatchesRenderer(true);
355     m_isDirty = true;
356     m_wasModifiedByUser = true;
357     const_cast&lt;HTMLTextAreaElement*&gt;(this)-&gt;updatePlaceholderVisibility();
358 }
359 
360 String HTMLTextAreaElement::value() const
361 {
362     updateValue();
363     return m_value;
364 }
365 
366 void HTMLTextAreaElement::setValue(const String&amp; value)
367 {
368     setValueCommon(value);
369     m_isDirty = true;
370     updateValidity();
371 }
372 
373 void HTMLTextAreaElement::setNonDirtyValue(const String&amp; value)
374 {
375     setValueCommon(value);
376     m_isDirty = false;
377     updateValidity();
378 }
379 
380 void HTMLTextAreaElement::setValueCommon(const String&amp; newValue)
381 {
382     m_wasModifiedByUser = false;
383     // Code elsewhere normalizes line endings added by the user via the keyboard or pasting.
384     // We normalize line endings coming from JavaScript here.
385     String normalizedValue = newValue.isNull() ? emptyString() : newValue;
386     normalizedValue.replace(&quot;\r\n&quot;, &quot;\n&quot;);
387     normalizedValue.replace(&#39;\r&#39;, &#39;\n&#39;);
388 
389     // Return early because we don&#39;t want to move the caret or trigger other side effects
390     // when the value isn&#39;t changing. This matches Firefox behavior, at least.
391     if (normalizedValue == value())
392         return;
393 
394     m_value = normalizedValue;
395     setInnerTextValue(m_value);
396     setLastChangeWasNotUserEdit();
397     updatePlaceholderVisibility();
398     invalidateStyleForSubtree();
399     setFormControlValueMatchesRenderer(true);
400 
401     // Set the caret to the end of the text value.
402     if (document().focusedElement() == this) {
403         unsigned endOfString = m_value.length();
404         setSelectionRange(endOfString, endOfString);
405     }
406 
407     setTextAsOfLastFormControlChangeEvent(normalizedValue);
408 }
409 
410 String HTMLTextAreaElement::defaultValue() const
411 {
412     return TextNodeTraversal::childTextContent(*this);
413 }
414 
415 void HTMLTextAreaElement::setDefaultValue(const String&amp; defaultValue)
416 {
417     setTextContent(defaultValue);
418 }
419 
420 String HTMLTextAreaElement::validationMessage() const
421 {
422     if (!willValidate())
423         return String();
424 
425     if (customError())
426         return customValidationMessage();
427 
428     if (valueMissing())
429         return validationMessageValueMissingText();
430 
431     if (tooShort())
432         return validationMessageTooShortText(computeLengthForSubmission(value()), minLength());
433 
434     if (tooLong())
435         return validationMessageTooLongText(computeLengthForSubmission(value()), effectiveMaxLength());
436 
437     return String();
438 }
439 
440 bool HTMLTextAreaElement::valueMissing() const
441 {
442     return willValidate() &amp;&amp; valueMissing(value());
443 }
444 
445 bool HTMLTextAreaElement::tooShort() const
446 {
447     return willValidate() &amp;&amp; tooShort(value(), CheckDirtyFlag);
448 }
449 
450 bool HTMLTextAreaElement::tooShort(StringView value, NeedsToCheckDirtyFlag check) const
451 {
452     // Return false for the default value or value set by script even if it is
453     // shorter than minLength.
454     if (check == CheckDirtyFlag &amp;&amp; !m_wasModifiedByUser)
455         return false;
456 
457     int min = minLength();
458     if (min &lt;= 0)
459         return false;
460 
461     // The empty string is excluded from tooShort validation.
462     if (value.isEmpty())
463         return false;
464 
465     // FIXME: The HTML specification says that the &quot;number of characters&quot; is measured using code-unit length and,
466     // in the case of textarea elements, with all line breaks normalized to a single character (as opposed to CRLF pairs).
467     unsigned unsignedMin = static_cast&lt;unsigned&gt;(min);
468     unsigned numberOfLineBreaksInValue = numberOfLineBreaks(value);
469     return upperBoundForLengthForSubmission(value, numberOfLineBreaksInValue) &lt; unsignedMin
470         &amp;&amp; computeLengthForSubmission(value, numberOfLineBreaksInValue) &lt; unsignedMin;
471 }
472 
473 bool HTMLTextAreaElement::tooLong() const
474 {
475     return willValidate() &amp;&amp; tooLong(value(), CheckDirtyFlag);
476 }
477 
478 bool HTMLTextAreaElement::tooLong(StringView value, NeedsToCheckDirtyFlag check) const
479 {
480     // Return false for the default value or value set by script even if it is
481     // longer than maxLength.
482     if (check == CheckDirtyFlag &amp;&amp; !m_wasModifiedByUser)
483         return false;
484 
485     int max = effectiveMaxLength();
486     if (max &lt; 0)
487         return false;
488 
489     // FIXME: The HTML specification says that the &quot;number of characters&quot; is measured using code-unit length and,
490     // in the case of textarea elements, with all line breaks normalized to a single character (as opposed to CRLF pairs).
491     unsigned unsignedMax = static_cast&lt;unsigned&gt;(max);
492     unsigned numberOfLineBreaksInValue = numberOfLineBreaks(value);
493     return upperBoundForLengthForSubmission(value, numberOfLineBreaksInValue) &gt; unsignedMax
494         &amp;&amp; computeLengthForSubmission(value, numberOfLineBreaksInValue) &gt; unsignedMax;
495 }
496 
497 bool HTMLTextAreaElement::isValidValue(const String&amp; candidate) const
498 {
499     return !valueMissing(candidate) &amp;&amp; !tooShort(candidate, IgnoreDirtyFlag) &amp;&amp; !tooLong(candidate, IgnoreDirtyFlag);
500 }
501 
502 void HTMLTextAreaElement::accessKeyAction(bool)
503 {
504     focus();
505 }
506 
507 void HTMLTextAreaElement::setCols(unsigned cols)
508 {
509     setUnsignedIntegralAttribute(colsAttr, limitToOnlyHTMLNonNegativeNumbersGreaterThanZero(cols, defaultCols));
510 }
511 
512 void HTMLTextAreaElement::setRows(unsigned rows)
513 {
514     setUnsignedIntegralAttribute(rowsAttr, limitToOnlyHTMLNonNegativeNumbersGreaterThanZero(rows, defaultRows));
515 }
516 
517 bool HTMLTextAreaElement::shouldUseInputMethod()
518 {
519     return true;
520 }
521 
522 HTMLElement* HTMLTextAreaElement::placeholderElement() const
523 {
524     return m_placeholder.get();
525 }
526 
527 bool HTMLTextAreaElement::matchesReadWritePseudoClass() const
528 {
529     return !isDisabledOrReadOnly();
530 }
531 
532 void HTMLTextAreaElement::updatePlaceholderText()
533 {
534     String placeholderText = strippedPlaceholder();
535     if (placeholderText.isEmpty()) {
536         if (m_placeholder) {
537             userAgentShadowRoot()-&gt;removeChild(*m_placeholder);
538             m_placeholder = nullptr;
539         }
540         return;
541     }
542     if (!m_placeholder) {
543         m_placeholder = TextControlPlaceholderElement::create(document());
544         userAgentShadowRoot()-&gt;insertBefore(*m_placeholder, innerTextElement()-&gt;nextSibling());
545     }
546     m_placeholder-&gt;setInnerText(placeholderText);
547 }
548 
549 bool HTMLTextAreaElement::willRespondToMouseClickEvents()
550 {
551     return !isDisabledFormControl();
552 }
553 
554 RenderStyle HTMLTextAreaElement::createInnerTextStyle(const RenderStyle&amp; style)
555 {
556     auto textBlockStyle = RenderStyle::create();
557     textBlockStyle.inheritFrom(style);
558     adjustInnerTextStyle(style, textBlockStyle);
559     textBlockStyle.setDisplay(DisplayType::Block);
560     return textBlockStyle;
561 }
562 
563 void HTMLTextAreaElement::copyNonAttributePropertiesFromElement(const Element&amp; source)
564 {
565     auto&amp; sourceElement = downcast&lt;HTMLTextAreaElement&gt;(source);
566 
567     setValueCommon(sourceElement.value());
568     m_isDirty = sourceElement.m_isDirty;
569     HTMLTextFormControlElement::copyNonAttributePropertiesFromElement(source);
570 
571     updateValidity();
572 }
573 
574 } // namespace WebCore
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
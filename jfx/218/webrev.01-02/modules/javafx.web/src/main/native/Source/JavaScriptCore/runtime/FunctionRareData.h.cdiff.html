<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/FunctionRareData.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FunctionRareData.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="GeneratorFunctionConstructor.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/FunctionRareData.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 31,10 ***</span>
<span class="line-new-header">--- 31,11 ---</span>
  #include &quot;PackedCellPtr.h&quot;
  #include &quot;Watchpoint.h&quot;
  
  namespace JSC {
  
<span class="line-added">+ class ExecutableBase;</span>
  class JSGlobalObject;
  class LLIntOffsetsExtractor;
  namespace DFG {
  class SpeculativeJIT;
  class JITCompiler;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 46,30 ***</span>
      friend class DFG::JITCompiler;
      friend class VM;
  
  public:
      typedef JSCell Base;
<span class="line-modified">!     static const unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;</span>
  
<span class="line-modified">!     static FunctionRareData* create(VM&amp;);</span>
  
<span class="line-removed">-     static const bool needsDestruction = true;</span>
      static void destroy(JSCell*);
  
      static Structure* createStructure(VM&amp;, JSGlobalObject*, JSValue prototype);
  
      static void visitChildren(JSCell*, SlotVisitor&amp;);
  
      DECLARE_INFO;
  
      static inline ptrdiff_t offsetOfObjectAllocationProfile() { return OBJECT_OFFSETOF(FunctionRareData, m_objectAllocationProfile); }
<span class="line-modified">!     static inline ptrdiff_t offsetOfObjectAllocationProfileWatchpoint() { return OBJECT_OFFSETOF(FunctionRareData, m_objectAllocationProfileWatchpoint); }</span>
      static inline ptrdiff_t offsetOfInternalFunctionAllocationProfile() { return OBJECT_OFFSETOF(FunctionRareData, m_internalFunctionAllocationProfile); }
      static inline ptrdiff_t offsetOfBoundFunctionStructure() { return OBJECT_OFFSETOF(FunctionRareData, m_boundFunctionStructure); }
      static inline ptrdiff_t offsetOfAllocationProfileClearingWatchpoint() { return OBJECT_OFFSETOF(FunctionRareData, m_allocationProfileClearingWatchpoint); }
<span class="line-removed">-     static inline ptrdiff_t offsetOfHasReifiedLength() { return OBJECT_OFFSETOF(FunctionRareData, m_hasReifiedLength); }</span>
<span class="line-removed">-     static inline ptrdiff_t offsetOfHasReifiedName() { return OBJECT_OFFSETOF(FunctionRareData, m_hasReifiedName); }</span>
  
      ObjectAllocationProfileWithPrototype* objectAllocationProfile()
      {
          return &amp;m_objectAllocationProfile;
      }
<span class="line-new-header">--- 47,36 ---</span>
      friend class DFG::JITCompiler;
      friend class VM;
  
  public:
      typedef JSCell Base;
<span class="line-modified">!     static constexpr unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;</span>
  
<span class="line-modified">!     static FunctionRareData* create(VM&amp;, ExecutableBase*);</span>
<span class="line-added">+ </span>
<span class="line-added">+     static constexpr bool needsDestruction = true;</span>
<span class="line-added">+ </span>
<span class="line-added">+     template&lt;typename CellType, SubspaceAccess mode&gt;</span>
<span class="line-added">+     static IsoSubspace* subspaceFor(VM&amp; vm)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         return vm.functionRareDataSpace&lt;mode&gt;();</span>
<span class="line-added">+     }</span>
  
      static void destroy(JSCell*);
  
      static Structure* createStructure(VM&amp;, JSGlobalObject*, JSValue prototype);
  
      static void visitChildren(JSCell*, SlotVisitor&amp;);
  
      DECLARE_INFO;
  
      static inline ptrdiff_t offsetOfObjectAllocationProfile() { return OBJECT_OFFSETOF(FunctionRareData, m_objectAllocationProfile); }
<span class="line-modified">!     static inline ptrdiff_t offsetOfAllocationProfileWatchpointSet() { return OBJECT_OFFSETOF(FunctionRareData, m_allocationProfileWatchpointSet); }</span>
      static inline ptrdiff_t offsetOfInternalFunctionAllocationProfile() { return OBJECT_OFFSETOF(FunctionRareData, m_internalFunctionAllocationProfile); }
      static inline ptrdiff_t offsetOfBoundFunctionStructure() { return OBJECT_OFFSETOF(FunctionRareData, m_boundFunctionStructure); }
<span class="line-added">+     static inline ptrdiff_t offsetOfExecutable() { return OBJECT_OFFSETOF(FunctionRareData, m_executable); }</span>
      static inline ptrdiff_t offsetOfAllocationProfileClearingWatchpoint() { return OBJECT_OFFSETOF(FunctionRareData, m_allocationProfileClearingWatchpoint); }
  
      ObjectAllocationProfileWithPrototype* objectAllocationProfile()
      {
          return &amp;m_objectAllocationProfile;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 77,43 ***</span>
      Structure* objectAllocationStructure() { return m_objectAllocationProfile.structure(); }
      JSObject* objectAllocationPrototype() { return m_objectAllocationProfile.prototype(); }
  
      InlineWatchpointSet&amp; allocationProfileWatchpointSet()
      {
<span class="line-modified">!         return m_objectAllocationProfileWatchpoint;</span>
      }
  
      void clear(const char* reason);
  
      void initializeObjectAllocationProfile(VM&amp;, JSGlobalObject*, JSObject* prototype, size_t inlineCapacity, JSFunction* constructor);
  
      bool isObjectAllocationProfileInitialized() { return !m_objectAllocationProfile.isNull(); }
  
      Structure* internalFunctionAllocationStructure() { return m_internalFunctionAllocationProfile.structure(); }
<span class="line-modified">!     Structure* createInternalFunctionAllocationStructureFromBase(VM&amp; vm, JSGlobalObject* globalObject, JSObject* prototype, Structure* baseStructure)</span>
      {
<span class="line-modified">!         return m_internalFunctionAllocationProfile.createAllocationStructureFromBase(vm, globalObject, this, prototype, baseStructure);</span>
      }
<span class="line-modified">!     void clearInternalFunctionAllocationProfile()</span>
      {
          m_internalFunctionAllocationProfile.clear();
      }
  
      Structure* getBoundFunctionStructure() { return m_boundFunctionStructure.get(); }
      void setBoundFunctionStructure(VM&amp; vm, Structure* structure) { m_boundFunctionStructure.set(vm, this, structure); }
  
      bool hasReifiedLength() const { return m_hasReifiedLength; }
      void setHasReifiedLength() { m_hasReifiedLength = true; }
      bool hasReifiedName() const { return m_hasReifiedName; }
      void setHasReifiedName() { m_hasReifiedName = true; }
  
      bool hasAllocationProfileClearingWatchpoint() const { return !!m_allocationProfileClearingWatchpoint; }
      Watchpoint* createAllocationProfileClearingWatchpoint();
      class AllocationProfileClearingWatchpoint;
  
  protected:
<span class="line-modified">!     FunctionRareData(VM&amp;);</span>
      ~FunctionRareData();
  
  private:
      friend class LLIntOffsetsExtractor;
  
<span class="line-new-header">--- 84,64 ---</span>
      Structure* objectAllocationStructure() { return m_objectAllocationProfile.structure(); }
      JSObject* objectAllocationPrototype() { return m_objectAllocationProfile.prototype(); }
  
      InlineWatchpointSet&amp; allocationProfileWatchpointSet()
      {
<span class="line-modified">!         return m_allocationProfileWatchpointSet;</span>
      }
  
      void clear(const char* reason);
  
      void initializeObjectAllocationProfile(VM&amp;, JSGlobalObject*, JSObject* prototype, size_t inlineCapacity, JSFunction* constructor);
  
      bool isObjectAllocationProfileInitialized() { return !m_objectAllocationProfile.isNull(); }
  
      Structure* internalFunctionAllocationStructure() { return m_internalFunctionAllocationProfile.structure(); }
<span class="line-modified">!     Structure* createInternalFunctionAllocationStructureFromBase(VM&amp; vm, JSGlobalObject* baseGlobalObject, JSObject* prototype, Structure* baseStructure)</span>
      {
<span class="line-modified">!         initializeAllocationProfileWatchpointSet();</span>
<span class="line-added">+         return m_internalFunctionAllocationProfile.createAllocationStructureFromBase(vm, baseGlobalObject, this, prototype, baseStructure);</span>
      }
<span class="line-modified">!     void clearInternalFunctionAllocationProfile(const char* reason)</span>
      {
          m_internalFunctionAllocationProfile.clear();
<span class="line-added">+         m_allocationProfileWatchpointSet.fireAll(vm(), reason);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void initializeAllocationProfileWatchpointSet()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (m_allocationProfileWatchpointSet.isStillValid())</span>
<span class="line-added">+             m_allocationProfileWatchpointSet.startWatching();</span>
      }
  
      Structure* getBoundFunctionStructure() { return m_boundFunctionStructure.get(); }
      void setBoundFunctionStructure(VM&amp; vm, Structure* structure) { m_boundFunctionStructure.set(vm, this, structure); }
  
<span class="line-added">+     ExecutableBase* executable() const { return m_executable.get(); }</span>
<span class="line-added">+ </span>
      bool hasReifiedLength() const { return m_hasReifiedLength; }
      void setHasReifiedLength() { m_hasReifiedLength = true; }
      bool hasReifiedName() const { return m_hasReifiedName; }
      void setHasReifiedName() { m_hasReifiedName = true; }
  
<span class="line-added">+     bool hasModifiedLength() const { return m_hasModifiedLength; }</span>
<span class="line-added">+     void setHasModifiedLength()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         m_hasModifiedLength = true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     bool hasModifiedName() const { return m_hasModifiedName; }</span>
<span class="line-added">+     void setHasModifiedName()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         m_hasModifiedName = true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      bool hasAllocationProfileClearingWatchpoint() const { return !!m_allocationProfileClearingWatchpoint; }
      Watchpoint* createAllocationProfileClearingWatchpoint();
      class AllocationProfileClearingWatchpoint;
  
  protected:
<span class="line-modified">!     explicit FunctionRareData(VM&amp;, ExecutableBase*);</span>
      ~FunctionRareData();
  
  private:
      friend class LLIntOffsetsExtractor;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 129,16 ***</span>
      //      the Array constructor will set the allocation profile of myConstructor to hold an Array structure
      //
      // We don&#39;t really care about 1) since this memory is rare and small in total. 2) is unfortunate but is
      // probably outweighed by the cost of 3).
      ObjectAllocationProfileWithPrototype m_objectAllocationProfile;
<span class="line-modified">!     InlineWatchpointSet m_objectAllocationProfileWatchpoint;</span>
      InternalFunctionAllocationProfile m_internalFunctionAllocationProfile;
      WriteBarrier&lt;Structure&gt; m_boundFunctionStructure;
      std::unique_ptr&lt;AllocationProfileClearingWatchpoint&gt; m_allocationProfileClearingWatchpoint;
<span class="line-modified">!     bool m_hasReifiedLength { false };</span>
<span class="line-modified">!     bool m_hasReifiedName { false };</span>
  };
  
  class FunctionRareData::AllocationProfileClearingWatchpoint final : public Watchpoint {
  public:
      AllocationProfileClearingWatchpoint(FunctionRareData* rareData)
<span class="line-new-header">--- 157,19 ---</span>
      //      the Array constructor will set the allocation profile of myConstructor to hold an Array structure
      //
      // We don&#39;t really care about 1) since this memory is rare and small in total. 2) is unfortunate but is
      // probably outweighed by the cost of 3).
      ObjectAllocationProfileWithPrototype m_objectAllocationProfile;
<span class="line-modified">!     InlineWatchpointSet m_allocationProfileWatchpointSet;</span>
      InternalFunctionAllocationProfile m_internalFunctionAllocationProfile;
      WriteBarrier&lt;Structure&gt; m_boundFunctionStructure;
<span class="line-added">+     WriteBarrier&lt;ExecutableBase&gt; m_executable;</span>
      std::unique_ptr&lt;AllocationProfileClearingWatchpoint&gt; m_allocationProfileClearingWatchpoint;
<span class="line-modified">!     bool m_hasReifiedLength : 1;</span>
<span class="line-modified">!     bool m_hasReifiedName : 1;</span>
<span class="line-added">+     bool m_hasModifiedLength : 1;</span>
<span class="line-added">+     bool m_hasModifiedName : 1;</span>
  };
  
  class FunctionRareData::AllocationProfileClearingWatchpoint final : public Watchpoint {
  public:
      AllocationProfileClearingWatchpoint(FunctionRareData* rareData)
</pre>
<center><a href="FunctionRareData.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="GeneratorFunctionConstructor.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
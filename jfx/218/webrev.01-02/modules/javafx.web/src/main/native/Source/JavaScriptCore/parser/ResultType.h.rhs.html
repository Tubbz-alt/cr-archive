<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/ResultType.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2008 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 namespace JSC {
 29 
<a name="1" id="anc1"></a><span class="line-added"> 30     // FIXME: Consider whether this is actually necessary. Is LLInt and Baseline&#39;s profiling information enough?</span>
<span class="line-added"> 31     // https://bugs.webkit.org/show_bug.cgi?id=201659</span>
 32     struct ResultType {
 33     private:
 34         friend struct OperandTypes;
 35 
 36         using Type = uint8_t;
 37         static constexpr Type TypeInt32       = 0x1 &lt;&lt; 0;
 38         static constexpr Type TypeMaybeNumber = 0x1 &lt;&lt; 1;
 39         static constexpr Type TypeMaybeString = 0x1 &lt;&lt; 2;
 40         static constexpr Type TypeMaybeBigInt = 0x1 &lt;&lt; 3;
 41         static constexpr Type TypeMaybeNull   = 0x1 &lt;&lt; 4;
 42         static constexpr Type TypeMaybeBool   = 0x1 &lt;&lt; 5;
 43         static constexpr Type TypeMaybeOther  = 0x1 &lt;&lt; 6;
 44 
 45         static constexpr Type TypeBits = TypeMaybeNumber | TypeMaybeString | TypeMaybeBigInt | TypeMaybeNull | TypeMaybeBool | TypeMaybeOther;
 46 
 47     public:
 48         static constexpr int numBitsNeeded = 7;
 49         static_assert((TypeBits &amp; ((1 &lt;&lt; numBitsNeeded) - 1)) == TypeBits, &quot;This is necessary for correctness.&quot;);
 50 
<a name="2" id="anc2"></a><span class="line-added"> 51         constexpr explicit ResultType()</span>
<span class="line-added"> 52             : ResultType(unknownType())</span>
<span class="line-added"> 53         {</span>
<span class="line-added"> 54         }</span>
 55         constexpr explicit ResultType(Type type)
 56             : m_bits(type)
 57         {
 58         }
 59 
 60         constexpr bool isInt32() const
 61         {
 62             return m_bits &amp; TypeInt32;
 63         }
 64 
 65         constexpr bool definitelyIsNumber() const
 66         {
 67             return (m_bits &amp; TypeBits) == TypeMaybeNumber;
 68         }
 69 
 70         constexpr bool definitelyIsString() const
 71         {
 72             return (m_bits &amp; TypeBits) == TypeMaybeString;
 73         }
 74 
 75         constexpr bool definitelyIsBoolean() const
 76         {
 77             return (m_bits &amp; TypeBits) == TypeMaybeBool;
 78         }
 79 
 80         constexpr bool definitelyIsBigInt() const
 81         {
 82             return (m_bits &amp; TypeBits) == TypeMaybeBigInt;
 83         }
 84 
 85         constexpr bool definitelyIsNull() const
 86         {
 87             return (m_bits &amp; TypeBits) == TypeMaybeNull;
 88         }
 89 
 90         constexpr bool mightBeUndefinedOrNull() const
 91         {
 92             return m_bits &amp; (TypeMaybeNull | TypeMaybeOther);
 93         }
 94 
 95         constexpr bool mightBeNumber() const
 96         {
 97             return m_bits &amp; TypeMaybeNumber;
 98         }
 99 
100         constexpr bool isNotNumber() const
101         {
102             return !mightBeNumber();
103         }
104 
105         constexpr bool mightBeBigInt() const
106         {
107             return m_bits &amp; TypeMaybeBigInt;
108         }
109 
110         constexpr bool isNotBigInt() const
111         {
112             return !mightBeBigInt();
113         }
114 
115         static constexpr ResultType nullType()
116         {
117             return ResultType(TypeMaybeNull);
118         }
119 
120         static constexpr ResultType booleanType()
121         {
122             return ResultType(TypeMaybeBool);
123         }
124 
125         static constexpr ResultType numberType()
126         {
127             return ResultType(TypeMaybeNumber);
128         }
129 
130         static constexpr ResultType numberTypeIsInt32()
131         {
132             return ResultType(TypeInt32 | TypeMaybeNumber);
133         }
134 
135         static constexpr ResultType stringOrNumberType()
136         {
137             return ResultType(TypeMaybeNumber | TypeMaybeString);
138         }
139 
140         static constexpr ResultType addResultType()
141         {
142             return ResultType(TypeMaybeNumber | TypeMaybeString | TypeMaybeBigInt);
143         }
144 
145         static constexpr ResultType stringType()
146         {
147             return ResultType(TypeMaybeString);
148         }
149 
150         static constexpr ResultType bigIntType()
151         {
152             return ResultType(TypeMaybeBigInt);
153         }
154 
155         static constexpr ResultType bigIntOrInt32Type()
156         {
<a name="3" id="anc3"></a><span class="line-modified">157             return ResultType(TypeMaybeBigInt | TypeInt32 | TypeMaybeNumber);</span>
<span class="line-added">158         }</span>
<span class="line-added">159 </span>
<span class="line-added">160         static constexpr ResultType bigIntOrNumberType()</span>
<span class="line-added">161         {</span>
<span class="line-added">162             return ResultType(TypeMaybeBigInt | TypeMaybeNumber);</span>
163         }
164 
165         static constexpr ResultType unknownType()
166         {
167             return ResultType(TypeBits);
168         }
169 
170         static constexpr ResultType forAdd(ResultType op1, ResultType op2)
171         {
172             if (op1.definitelyIsNumber() &amp;&amp; op2.definitelyIsNumber())
173                 return numberType();
174             if (op1.definitelyIsString() || op2.definitelyIsString())
175                 return stringType();
176             if (op1.definitelyIsBigInt() &amp;&amp; op2.definitelyIsBigInt())
177                 return bigIntType();
178             return addResultType();
179         }
180 
<a name="4" id="anc4"></a><span class="line-added">181         static constexpr ResultType forNonAddArith(ResultType op1, ResultType op2)</span>
<span class="line-added">182         {</span>
<span class="line-added">183             if (op1.definitelyIsNumber() &amp;&amp; op2.definitelyIsNumber())</span>
<span class="line-added">184                 return numberType();</span>
<span class="line-added">185             if (op1.definitelyIsBigInt() &amp;&amp; op2.definitelyIsBigInt())</span>
<span class="line-added">186                 return bigIntType();</span>
<span class="line-added">187             return bigIntOrNumberType();</span>
<span class="line-added">188         }</span>
<span class="line-added">189 </span>
<span class="line-added">190         static constexpr ResultType forUnaryArith(ResultType op)</span>
<span class="line-added">191         {</span>
<span class="line-added">192             if (op.definitelyIsNumber())</span>
<span class="line-added">193                 return numberType();</span>
<span class="line-added">194             if (op.definitelyIsBigInt())</span>
<span class="line-added">195                 return bigIntType();</span>
<span class="line-added">196             return bigIntOrNumberType();</span>
<span class="line-added">197         }</span>
<span class="line-added">198 </span>
199         // Unlike in C, a logical op produces the value of the
200         // last expression evaluated (and not true or false).
201         static constexpr ResultType forLogicalOp(ResultType op1, ResultType op2)
202         {
203             if (op1.definitelyIsBoolean() &amp;&amp; op2.definitelyIsBoolean())
204                 return booleanType();
205             if (op1.definitelyIsNumber() &amp;&amp; op2.definitelyIsNumber())
206                 return numberType();
207             if (op1.definitelyIsString() &amp;&amp; op2.definitelyIsString())
208                 return stringType();
209             if (op1.definitelyIsBigInt() &amp;&amp; op2.definitelyIsBigInt())
210                 return bigIntType();
211             return unknownType();
212         }
213 
214         static constexpr ResultType forCoalesce(ResultType op1, ResultType op2)
215         {
216             if (op1.definitelyIsNull())
217                 return op2;
218             if (!op1.mightBeUndefinedOrNull())
219                 return op1;
220             return unknownType();
221         }
222 
223         static constexpr ResultType forBitOp()
224         {
225             return bigIntOrInt32Type();
226         }
227 
228         constexpr Type bits() const { return m_bits; }
229 
230         void dump(PrintStream&amp; out) const
231         {
232             // FIXME: more meaningful information
233             // https://bugs.webkit.org/show_bug.cgi?id=190930
234             out.print(bits());
235         }
236 
237     private:
238         Type m_bits;
239     };
240 
241     struct OperandTypes
242     {
243         OperandTypes(ResultType first = ResultType::unknownType(), ResultType second = ResultType::unknownType())
244         {
245             m_first = first.m_bits;
246             m_second = second.m_bits;
247         }
248 
249         ResultType::Type m_first;
250         ResultType::Type m_second;
251 
252         ResultType first() const
253         {
254             return ResultType(m_first);
255         }
256 
257         ResultType second() const
258         {
259             return ResultType(m_second);
260         }
261 
262         uint16_t bits()
263         {
264             static_assert(sizeof(OperandTypes) == sizeof(uint16_t));
265             return bitwise_cast&lt;uint16_t&gt;(*this);
266         }
267 
268         static OperandTypes fromBits(uint16_t bits)
269         {
270             return bitwise_cast&lt;OperandTypes&gt;(bits);
271         }
272 
273         void dump(PrintStream&amp; out) const
274         {
275             out.print(&quot;OperandTypes(&quot;, first(),  &quot;, &quot;, second(), &quot;)&quot;);
276         }
277     };
278 
279 } // namespace JSC
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
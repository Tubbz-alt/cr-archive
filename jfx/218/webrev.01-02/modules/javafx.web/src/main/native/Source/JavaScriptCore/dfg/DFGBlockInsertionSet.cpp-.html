<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGBlockInsertionSet.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013, 2014 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGBlockInsertionSet.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;JSCInlines.h&quot;
 32 
 33 namespace JSC { namespace DFG {
 34 
 35 BlockInsertionSet::BlockInsertionSet(Graph&amp; graph)
 36     : m_graph(graph)
 37 {
 38 }
 39 
 40 BlockInsertionSet::~BlockInsertionSet() { }
 41 
 42 void BlockInsertionSet::insert(const BlockInsertion&amp; insertion)
 43 {
 44     m_insertions.append(insertion);
 45 }
 46 
 47 void BlockInsertionSet::insert(size_t index, Ref&lt;BasicBlock&gt;&amp;&amp; block)
 48 {
 49     insert(BlockInsertion(index, WTFMove(block)));
 50 }
 51 
 52 BasicBlock* BlockInsertionSet::insert(size_t index, float executionCount)
 53 {
 54     Ref&lt;BasicBlock&gt; block = adoptRef(*new BasicBlock(
 55         UINT_MAX,
 56         m_graph.block(0)-&gt;variablesAtHead.numberOfArguments(),
 57         m_graph.block(0)-&gt;variablesAtHead.numberOfLocals(),
 58         executionCount));
 59     block-&gt;isReachable = true;
 60     auto* result = block.ptr();
 61     insert(index, WTFMove(block));
 62     return result;
 63 }
 64 
 65 BasicBlock* BlockInsertionSet::insertBefore(BasicBlock* before, float executionCount)
 66 {
 67     return insert(before-&gt;index, executionCount);
 68 }
 69 
 70 bool BlockInsertionSet::execute()
 71 {
 72     if (m_insertions.isEmpty())
 73         return false;
 74 
 75     // We allow insertions to be given to us in any order. So, we need to sort them before
 76     // running WTF::executeInsertions. Also, we don&#39;t really care if the sort is stable since
 77     // basic block order doesn&#39;t have semantics - it&#39;s just to make code easier to read.
 78     std::sort(m_insertions.begin(), m_insertions.end());
 79 
 80     executeInsertions(m_graph.m_blocks, m_insertions);
 81 
 82     // Prune out empty entries. This isn&#39;t strictly necessary but it&#39;s
 83     // healthy to keep the block list from growing.
 84     unsigned targetIndex = 0;
 85     for (unsigned sourceIndex = 0; sourceIndex &lt; m_graph.m_blocks.size();) {
 86         RefPtr&lt;BasicBlock&gt; block = m_graph.m_blocks[sourceIndex++];
 87         if (!block)
 88             continue;
 89         m_graph.m_blocks[targetIndex++] = block;
 90     }
 91     m_graph.m_blocks.shrink(targetIndex);
 92 
 93     // Make sure that the blocks know their new indices.
 94     for (unsigned i = 0; i &lt; m_graph.m_blocks.size(); ++i)
 95         m_graph.m_blocks[i]-&gt;index = i;
 96 
 97     // And finally, invalidate all analyses that rely on the CFG.
 98     m_graph.invalidateCFG();
 99     m_graph.dethread();
100 
101     return true;
102 }
103 
104 } } // namespace JSC::DFG
105 
106 #endif // ENABLE(DFG_JIT)
107 
    </pre>
  </body>
</html>
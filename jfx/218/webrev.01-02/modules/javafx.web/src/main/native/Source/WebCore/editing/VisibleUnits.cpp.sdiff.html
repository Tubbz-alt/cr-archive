<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/editing/VisibleUnits.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="VisibleSelection.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WebContentReader.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/VisibleUnits.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 807     RootInlineBox* rootBox = RenderedPosition(c).rootBox();
 808     if (!rootBox) {
 809         // There are VisiblePositions at offset 0 in blocks without
 810         // RootInlineBoxes, like empty editable blocks and bordered blocks.
 811         Position p = c.deepEquivalent();
 812         if (p.deprecatedNode()-&gt;renderer() &amp;&amp; p.deprecatedNode()-&gt;renderer()-&gt;isRenderBlock() &amp;&amp; !p.deprecatedEditingOffset())
 813             return c;
 814 
 815         return VisiblePosition();
 816     }
 817 
 818     Node* startNode;
 819     InlineBox* startBox;
 820     if (mode == UseLogicalOrdering) {
 821         startNode = rootBox-&gt;getLogicalStartBoxWithNode(startBox);
 822         if (!startNode)
 823             return VisiblePosition();
 824     } else {
 825         // Generated content (e.g. list markers and CSS :before and :after pseudoelements) have no corresponding DOM element,
 826         // and so cannot be represented by a VisiblePosition. Use whatever follows instead.
<span class="line-modified"> 827         startBox = rootBox-&gt;firstLeafChild();</span>
 828         while (true) {
 829             if (!startBox)
 830                 return VisiblePosition();
 831 
 832             startNode = startBox-&gt;renderer().nonPseudoNode();
 833             if (startNode)
 834                 break;
 835 
<span class="line-modified"> 836             startBox = startBox-&gt;nextLeafChild();</span>
 837         }
 838     }
 839 
 840     return is&lt;Text&gt;(*startNode) ? Position(downcast&lt;Text&gt;(startNode), downcast&lt;InlineTextBox&gt;(*startBox).start())
 841         : positionBeforeNode(startNode);
 842 }
 843 
 844 static VisiblePosition startOfLine(const VisiblePosition&amp; c, LineEndpointComputationMode mode, bool* reachedBoundary)
 845 {
 846     if (reachedBoundary)
 847         *reachedBoundary = false;
 848     // TODO: this is the current behavior that might need to be fixed.
 849     // Please refer to https://bugs.webkit.org/show_bug.cgi?id=49107 for detail.
 850     VisiblePosition visPos = startPositionForLine(c, mode);
 851 
 852     if (mode == UseLogicalOrdering) {
 853         if (Node* editableRoot = highestEditableRoot(c.deepEquivalent())) {
 854             if (!editableRoot-&gt;contains(visPos.deepEquivalent().containerNode())) {
 855                 VisiblePosition newPosition = firstPositionInNode(editableRoot);
 856                 if (reachedBoundary)
</pre>
<hr />
<pre>
 881 
 882     RootInlineBox* rootBox = RenderedPosition(c).rootBox();
 883     if (!rootBox) {
 884         // There are VisiblePositions at offset 0 in blocks without
 885         // RootInlineBoxes, like empty editable blocks and bordered blocks.
 886         Position p = c.deepEquivalent();
 887         if (p.deprecatedNode()-&gt;renderer() &amp;&amp; p.deprecatedNode()-&gt;renderer()-&gt;isRenderBlock() &amp;&amp; !p.deprecatedEditingOffset())
 888             return c;
 889         return VisiblePosition();
 890     }
 891 
 892     Node* endNode;
 893     InlineBox* endBox;
 894     if (mode == UseLogicalOrdering) {
 895         endNode = rootBox-&gt;getLogicalEndBoxWithNode(endBox);
 896         if (!endNode)
 897             return VisiblePosition();
 898     } else {
 899         // Generated content (e.g. list markers and CSS :before and :after pseudoelements) have no corresponding DOM element,
 900         // and so cannot be represented by a VisiblePosition. Use whatever precedes instead.
<span class="line-modified"> 901         endBox = rootBox-&gt;lastLeafChild();</span>
 902         while (true) {
 903             if (!endBox)
 904                 return VisiblePosition();
 905 
 906             endNode = endBox-&gt;renderer().nonPseudoNode();
 907             if (endNode)
 908                 break;
 909 
<span class="line-modified"> 910             endBox = endBox-&gt;prevLeafChild();</span>
 911         }
 912     }
 913 
 914     Position pos;
 915     if (is&lt;HTMLBRElement&gt;(*endNode))
 916         pos = positionBeforeNode(endNode);
 917     else if (is&lt;InlineTextBox&gt;(*endBox) &amp;&amp; is&lt;Text&gt;(*endNode)) {
 918         auto&amp; endTextBox = downcast&lt;InlineTextBox&gt;(*endBox);
 919         int endOffset = endTextBox.start();
 920         if (!endTextBox.isLineBreak())
 921             endOffset += endTextBox.len();
 922         pos = Position(downcast&lt;Text&gt;(endNode), endOffset);
 923     } else
 924         pos = positionAfterNode(endNode);
 925 
 926     return VisiblePosition(pos, VP_UPSTREAM_IF_POSSIBLE);
 927 }
 928 
 929 static bool inSameLogicalLine(const VisiblePosition&amp; a, const VisiblePosition&amp; b)
 930 {
</pre>
<hr />
<pre>
1029     Position p = visiblePosition.deepEquivalent();
1030     Node* node = p.deprecatedNode();
1031 
1032     if (!node)
1033         return VisiblePosition();
1034 
1035     node-&gt;document().updateLayoutIgnorePendingStylesheets();
1036 
1037     RenderObject* renderer = node-&gt;renderer();
1038     if (!renderer)
1039         return VisiblePosition();
1040 
1041     RootInlineBox* root = nullptr;
1042     InlineBox* box;
1043     int ignoredCaretOffset;
1044     visiblePosition.getInlineBoxAndOffset(box, ignoredCaretOffset);
1045     if (box) {
1046         root = box-&gt;root().prevRootBox();
1047         // We want to skip zero height boxes.
1048         // This could happen in case it is a TrailingFloatsRootInlineBox.
<span class="line-modified">1049         if (!root || !root-&gt;logicalHeight() || !root-&gt;firstLeafChild())</span>
1050             root = nullptr;
1051     }
1052 
1053     if (!root) {
1054         Position position = previousRootInlineBoxCandidatePosition(node, visiblePosition, editableType);
1055         if (position.isNotNull()) {
1056             RenderedPosition renderedPosition(position);
1057             root = renderedPosition.rootBox();
1058             if (!root)
1059                 return position;
1060         }
1061     }
1062 
1063     if (root) {
1064         // FIXME: Can be wrong for multi-column layout and with transforms.
1065         IntPoint pointInLine = absoluteLineDirectionPointToLocalPointInBlock(*root, lineDirectionPoint);
1066         RenderObject&amp; renderer = root-&gt;closestLeafChildForPoint(pointInLine, isEditablePosition(p))-&gt;renderer();
1067         Node* node = renderer.node();
1068         if (node &amp;&amp; editingIgnoresContent(*node))
1069             return positionInParentBeforeNode(node);
</pre>
<hr />
<pre>
1084     Position p = visiblePosition.deepEquivalent();
1085     Node* node = p.deprecatedNode();
1086 
1087     if (!node)
1088         return VisiblePosition();
1089 
1090     node-&gt;document().updateLayoutIgnorePendingStylesheets();
1091 
1092     RenderObject* renderer = node-&gt;renderer();
1093     if (!renderer)
1094         return VisiblePosition();
1095 
1096     RootInlineBox* root = nullptr;
1097     InlineBox* box;
1098     int ignoredCaretOffset;
1099     visiblePosition.getInlineBoxAndOffset(box, ignoredCaretOffset);
1100     if (box) {
1101         root = box-&gt;root().nextRootBox();
1102         // We want to skip zero height boxes.
1103         // This could happen in case it is a TrailingFloatsRootInlineBox.
<span class="line-modified">1104         if (!root || !root-&gt;logicalHeight() || !root-&gt;firstLeafChild())</span>
1105             root = nullptr;
1106     }
1107 
1108     if (!root) {
1109         // FIXME: We need do the same in previousLinePosition.
1110         Node* child = node-&gt;traverseToChildAt(p.deprecatedEditingOffset());
1111         node = child ? child : node-&gt;lastDescendant();
1112         Position position = nextRootInlineBoxCandidatePosition(node, visiblePosition, editableType);
1113         if (position.isNotNull()) {
1114             RenderedPosition renderedPosition(position);
1115             root = renderedPosition.rootBox();
1116             if (!root)
1117                 return position;
1118         }
1119     }
1120 
1121     if (root) {
1122         // FIXME: Can be wrong for multi-column layout and with transforms.
1123         IntPoint pointInLine = absoluteLineDirectionPointToLocalPointInBlock(*root, lineDirectionPoint);
1124         RenderObject&amp; renderer = root-&gt;closestLeafChildForPoint(pointInLine, isEditablePosition(p))-&gt;renderer();
</pre>
<hr />
<pre>
1574 {
1575     if (granularity == CharacterGranularity)
1576         return true;
1577 
1578     VisiblePosition boundary;
1579 
1580     bool useDownstream = directionIsDownstream(direction);
1581 
1582     switch (granularity) {
1583     case WordGranularity:
1584         // visible_units claims erroneously that the start and the end
1585         // of a paragraph are the end and start of a word, respectively.
1586         if ((useDownstream &amp;&amp; isStartOfParagraph(vp)) || (!useDownstream &amp;&amp; isEndOfParagraph(vp)))
1587             return false;
1588 
1589         // Note that &quot;Left&quot; and &quot;Right&quot; in this context apparently mean &quot;upstream/previous&quot; and &quot;downstream/next&quot;.
1590         boundary = useDownstream ? endOfWord(vp, LeftWordIfOnBoundary) : startOfWord(vp, RightWordIfOnBoundary);
1591         break;
1592 
1593     case SentenceGranularity:
<span class="line-modified">1594         boundary = useDownstream ? endOfSentence(vp) : startOfSentence(vp);</span>
1595         break;
1596 
1597     case LineGranularity:
1598         // Affinity has to be set to get right boundary of the line.
1599         boundary = vp;
1600         boundary.setAffinity(useDownstream ? VP_UPSTREAM_IF_POSSIBLE : DOWNSTREAM);
1601         boundary = useDownstream ? endOfLine(boundary) : startOfLine(boundary);
1602         break;
1603 
1604     case ParagraphGranularity:
1605         boundary = useDownstream ? endOfParagraph(vp) : startOfParagraph(vp);
1606         break;
1607 
1608     case DocumentGranularity:
1609         boundary = useDownstream ? endOfDocument(vp) : startOfDocument(vp);
1610         break;
1611 
1612     default:
1613         ASSERT_NOT_REACHED();
1614         break;
</pre>
<hr />
<pre>
1759 
1760 static VisiblePosition nextSentenceBoundaryInDirection(const VisiblePosition&amp; vp, SelectionDirection direction)
1761 {
1762     bool useDownstream = directionIsDownstream(direction);
1763     bool withinUnitOfGranularity = withinTextUnitOfGranularity(vp, SentenceGranularity, direction);
1764     VisiblePosition result;
1765 
1766     if (withinUnitOfGranularity)
1767         result = useDownstream ? endOfSentence(vp) : startOfSentence(vp);
1768     else {
1769         result = useDownstream ? nextSentencePosition(vp) : previousSentencePosition(vp);
1770         if (result.isNull() || result == vp)
1771             return VisiblePosition();
1772 
1773         result = useDownstream ? startOfSentence(vp) : endOfSentence(vp);
1774     }
1775 
1776     if (result == vp)
1777         return VisiblePosition();
1778 
<span class="line-modified">1779     ASSERT(useDownstream ? (result &gt; vp) : (result &lt; vp));</span>

1780 
1781     return result;
1782 }
1783 
1784 static VisiblePosition nextLineBoundaryInDirection(const VisiblePosition&amp; vp, SelectionDirection direction)
1785 {
1786     bool useDownstream = directionIsDownstream(direction);
1787     VisiblePosition result = vp;
1788 
1789     if (useDownstream) {
1790         result.setAffinity(DOWNSTREAM);
1791         result = isEndOfLine(result) ? startOfLine(nextLinePosition(result, result.lineDirectionPointForBlockDirectionNavigation())) : endOfLine(result);
1792     } else {
1793         result.setAffinity(VP_UPSTREAM_IF_POSSIBLE);
1794         result = isStartOfLine(result) ? endOfLine(previousLinePosition(result, result.lineDirectionPointForBlockDirectionNavigation())) : startOfLine(result);
1795     }
1796 
1797     return result;
1798 }
1799 
<span class="line-modified">1800 static VisiblePosition nextParagraphBoundaryInDirection(const VisiblePosition&amp; vp, SelectionDirection direction)</span>
1801 {
<span class="line-modified">1802     bool useDownstream = directionIsDownstream(direction);</span>
<span class="line-modified">1803     bool withinUnitOfGranularity = withinTextUnitOfGranularity(vp, ParagraphGranularity, direction);</span>
<span class="line-modified">1804     VisiblePosition result;</span>
<span class="line-modified">1805 </span>
<span class="line-modified">1806     if (!withinUnitOfGranularity)</span>
<span class="line-modified">1807         result =  useDownstream ? startOfParagraph(nextParagraphPosition(vp, vp.lineDirectionPointForBlockDirectionNavigation())) : endOfParagraph(previousParagraphPosition(vp, vp.lineDirectionPointForBlockDirectionNavigation()));</span>
<span class="line-removed">1808     else</span>
<span class="line-removed">1809         result = useDownstream ? endOfParagraph(vp) : startOfParagraph(vp);</span>
<span class="line-removed">1810 </span>
<span class="line-removed">1811     return result;</span>
1812 }
1813 
1814 static VisiblePosition nextDocumentBoundaryInDirection(const VisiblePosition&amp; vp, SelectionDirection direction)
1815 {
1816     return directionIsDownstream(direction) ? endOfDocument(vp) : startOfDocument(vp);
1817 }
1818 
1819 VisiblePosition positionOfNextBoundaryOfGranularity(const VisiblePosition&amp; vp, TextGranularity granularity, SelectionDirection direction)
1820 {
1821     switch (granularity) {
1822     case CharacterGranularity:
1823         return nextCharacterBoundaryInDirection(vp, direction, CanCrossEditingBoundary);
1824     case WordGranularity:
1825         return nextWordBoundaryInDirection(vp, direction);
1826     case SentenceGranularity:
1827         return nextSentenceBoundaryInDirection(vp, direction);
1828     case LineGranularity:
1829         return nextLineBoundaryInDirection(vp, direction);
1830     case ParagraphGranularity:
1831         return nextParagraphBoundaryInDirection(vp, direction);
</pre>
<hr />
<pre>
1952             characters[index++] = characterString[i];
1953         }
1954     }
1955     oneAfter = characters[0];
1956     oneBefore = characters[1];
1957     twoBefore = characters[2];
1958 }
1959 
1960 RefPtr&lt;Range&gt; wordRangeFromPosition(const VisiblePosition&amp; position)
1961 {
1962     // The selection could be in a non visible element and we don&#39;t have a VisiblePosition.
1963     if (position.isNull())
1964         return nullptr;
1965 
1966     RefPtr&lt;Range&gt; range = enclosingTextUnitOfGranularity(position, WordGranularity, DirectionBackward);
1967 
1968     if (!range) {
1969         // We could be at the start of a word, try forward.
1970         range = enclosingTextUnitOfGranularity(position, WordGranularity, DirectionForward);
1971     }

1972     if (range)
1973         return range;
1974 
1975     VisiblePosition currentPosition = position;
1976     do {
1977         currentPosition = positionOfNextBoundaryOfGranularity(currentPosition, WordGranularity, DirectionBackward);
1978     } while (currentPosition.isNotNull() &amp;&amp; !atBoundaryOfGranularity(currentPosition, WordGranularity, DirectionBackward));
1979 
<span class="line-removed">1980     // If the position is an empty paragraph and at the end of the document</span>
<span class="line-removed">1981     // the word iterator could not pass the paragraph boundary, therefore iterating to</span>
<span class="line-removed">1982     // the previous line is required.</span>
<span class="line-removed">1983     if (currentPosition.isNull() &amp;&amp; isEndOfDocument(position)) {</span>
<span class="line-removed">1984         VisiblePosition previousLinePosition = positionOfNextBoundaryOfGranularity(position, LineGranularity, DirectionBackward);</span>
<span class="line-removed">1985         if (previousLinePosition.isNotNull()) {</span>
<span class="line-removed">1986             currentPosition = positionOfNextBoundaryOfGranularity(previousLinePosition, WordGranularity, DirectionBackward);</span>
<span class="line-removed">1987             if (currentPosition.isNull())</span>
<span class="line-removed">1988                 currentPosition = previousLinePosition;</span>
<span class="line-removed">1989         }</span>
<span class="line-removed">1990     }</span>
<span class="line-removed">1991 </span>
1992     if (currentPosition.isNull())
1993         currentPosition = positionOfNextBoundaryOfGranularity(position, WordGranularity, DirectionForward);
1994 
1995     if (currentPosition.isNotNull()) {
1996         range = Range::create(position.deepEquivalent().deprecatedNode()-&gt;document(), currentPosition, position);
1997         ASSERT(range);
1998     }

1999     return range;
2000 }
2001 
2002 VisiblePosition closestWordBoundaryForPosition(const VisiblePosition&amp; position)
2003 {
2004     VisiblePosition result;
2005 
2006     // move the position at the end of the word
2007     if (atBoundaryOfGranularity(position, LineGranularity, DirectionForward)) {
2008         // Don&#39;t cross line boundaries.
2009         result = position;
2010     } else if (withinTextUnitOfGranularity(position, WordGranularity, DirectionForward)) {
2011         // The position lies within a word.
2012         RefPtr&lt;Range&gt; wordRange = enclosingTextUnitOfGranularity(position, WordGranularity, DirectionForward);
2013 
2014         result = wordRange-&gt;startPosition();
2015         if (distanceBetweenPositions(position, result) &gt; 1)
2016             result = wordRange-&gt;endPosition();
2017     } else if (atBoundaryOfGranularity(position, WordGranularity, DirectionBackward)) {
2018         // The position is at the end of a word.
</pre>
</td>
<td>
<hr />
<pre>
 807     RootInlineBox* rootBox = RenderedPosition(c).rootBox();
 808     if (!rootBox) {
 809         // There are VisiblePositions at offset 0 in blocks without
 810         // RootInlineBoxes, like empty editable blocks and bordered blocks.
 811         Position p = c.deepEquivalent();
 812         if (p.deprecatedNode()-&gt;renderer() &amp;&amp; p.deprecatedNode()-&gt;renderer()-&gt;isRenderBlock() &amp;&amp; !p.deprecatedEditingOffset())
 813             return c;
 814 
 815         return VisiblePosition();
 816     }
 817 
 818     Node* startNode;
 819     InlineBox* startBox;
 820     if (mode == UseLogicalOrdering) {
 821         startNode = rootBox-&gt;getLogicalStartBoxWithNode(startBox);
 822         if (!startNode)
 823             return VisiblePosition();
 824     } else {
 825         // Generated content (e.g. list markers and CSS :before and :after pseudoelements) have no corresponding DOM element,
 826         // and so cannot be represented by a VisiblePosition. Use whatever follows instead.
<span class="line-modified"> 827         startBox = rootBox-&gt;firstLeafDescendant();</span>
 828         while (true) {
 829             if (!startBox)
 830                 return VisiblePosition();
 831 
 832             startNode = startBox-&gt;renderer().nonPseudoNode();
 833             if (startNode)
 834                 break;
 835 
<span class="line-modified"> 836             startBox = startBox-&gt;nextLeafOnLine();</span>
 837         }
 838     }
 839 
 840     return is&lt;Text&gt;(*startNode) ? Position(downcast&lt;Text&gt;(startNode), downcast&lt;InlineTextBox&gt;(*startBox).start())
 841         : positionBeforeNode(startNode);
 842 }
 843 
 844 static VisiblePosition startOfLine(const VisiblePosition&amp; c, LineEndpointComputationMode mode, bool* reachedBoundary)
 845 {
 846     if (reachedBoundary)
 847         *reachedBoundary = false;
 848     // TODO: this is the current behavior that might need to be fixed.
 849     // Please refer to https://bugs.webkit.org/show_bug.cgi?id=49107 for detail.
 850     VisiblePosition visPos = startPositionForLine(c, mode);
 851 
 852     if (mode == UseLogicalOrdering) {
 853         if (Node* editableRoot = highestEditableRoot(c.deepEquivalent())) {
 854             if (!editableRoot-&gt;contains(visPos.deepEquivalent().containerNode())) {
 855                 VisiblePosition newPosition = firstPositionInNode(editableRoot);
 856                 if (reachedBoundary)
</pre>
<hr />
<pre>
 881 
 882     RootInlineBox* rootBox = RenderedPosition(c).rootBox();
 883     if (!rootBox) {
 884         // There are VisiblePositions at offset 0 in blocks without
 885         // RootInlineBoxes, like empty editable blocks and bordered blocks.
 886         Position p = c.deepEquivalent();
 887         if (p.deprecatedNode()-&gt;renderer() &amp;&amp; p.deprecatedNode()-&gt;renderer()-&gt;isRenderBlock() &amp;&amp; !p.deprecatedEditingOffset())
 888             return c;
 889         return VisiblePosition();
 890     }
 891 
 892     Node* endNode;
 893     InlineBox* endBox;
 894     if (mode == UseLogicalOrdering) {
 895         endNode = rootBox-&gt;getLogicalEndBoxWithNode(endBox);
 896         if (!endNode)
 897             return VisiblePosition();
 898     } else {
 899         // Generated content (e.g. list markers and CSS :before and :after pseudoelements) have no corresponding DOM element,
 900         // and so cannot be represented by a VisiblePosition. Use whatever precedes instead.
<span class="line-modified"> 901         endBox = rootBox-&gt;lastLeafDescendant();</span>
 902         while (true) {
 903             if (!endBox)
 904                 return VisiblePosition();
 905 
 906             endNode = endBox-&gt;renderer().nonPseudoNode();
 907             if (endNode)
 908                 break;
 909 
<span class="line-modified"> 910             endBox = endBox-&gt;previousLeafOnLine();</span>
 911         }
 912     }
 913 
 914     Position pos;
 915     if (is&lt;HTMLBRElement&gt;(*endNode))
 916         pos = positionBeforeNode(endNode);
 917     else if (is&lt;InlineTextBox&gt;(*endBox) &amp;&amp; is&lt;Text&gt;(*endNode)) {
 918         auto&amp; endTextBox = downcast&lt;InlineTextBox&gt;(*endBox);
 919         int endOffset = endTextBox.start();
 920         if (!endTextBox.isLineBreak())
 921             endOffset += endTextBox.len();
 922         pos = Position(downcast&lt;Text&gt;(endNode), endOffset);
 923     } else
 924         pos = positionAfterNode(endNode);
 925 
 926     return VisiblePosition(pos, VP_UPSTREAM_IF_POSSIBLE);
 927 }
 928 
 929 static bool inSameLogicalLine(const VisiblePosition&amp; a, const VisiblePosition&amp; b)
 930 {
</pre>
<hr />
<pre>
1029     Position p = visiblePosition.deepEquivalent();
1030     Node* node = p.deprecatedNode();
1031 
1032     if (!node)
1033         return VisiblePosition();
1034 
1035     node-&gt;document().updateLayoutIgnorePendingStylesheets();
1036 
1037     RenderObject* renderer = node-&gt;renderer();
1038     if (!renderer)
1039         return VisiblePosition();
1040 
1041     RootInlineBox* root = nullptr;
1042     InlineBox* box;
1043     int ignoredCaretOffset;
1044     visiblePosition.getInlineBoxAndOffset(box, ignoredCaretOffset);
1045     if (box) {
1046         root = box-&gt;root().prevRootBox();
1047         // We want to skip zero height boxes.
1048         // This could happen in case it is a TrailingFloatsRootInlineBox.
<span class="line-modified">1049         if (!root || !root-&gt;logicalHeight() || !root-&gt;firstLeafDescendant())</span>
1050             root = nullptr;
1051     }
1052 
1053     if (!root) {
1054         Position position = previousRootInlineBoxCandidatePosition(node, visiblePosition, editableType);
1055         if (position.isNotNull()) {
1056             RenderedPosition renderedPosition(position);
1057             root = renderedPosition.rootBox();
1058             if (!root)
1059                 return position;
1060         }
1061     }
1062 
1063     if (root) {
1064         // FIXME: Can be wrong for multi-column layout and with transforms.
1065         IntPoint pointInLine = absoluteLineDirectionPointToLocalPointInBlock(*root, lineDirectionPoint);
1066         RenderObject&amp; renderer = root-&gt;closestLeafChildForPoint(pointInLine, isEditablePosition(p))-&gt;renderer();
1067         Node* node = renderer.node();
1068         if (node &amp;&amp; editingIgnoresContent(*node))
1069             return positionInParentBeforeNode(node);
</pre>
<hr />
<pre>
1084     Position p = visiblePosition.deepEquivalent();
1085     Node* node = p.deprecatedNode();
1086 
1087     if (!node)
1088         return VisiblePosition();
1089 
1090     node-&gt;document().updateLayoutIgnorePendingStylesheets();
1091 
1092     RenderObject* renderer = node-&gt;renderer();
1093     if (!renderer)
1094         return VisiblePosition();
1095 
1096     RootInlineBox* root = nullptr;
1097     InlineBox* box;
1098     int ignoredCaretOffset;
1099     visiblePosition.getInlineBoxAndOffset(box, ignoredCaretOffset);
1100     if (box) {
1101         root = box-&gt;root().nextRootBox();
1102         // We want to skip zero height boxes.
1103         // This could happen in case it is a TrailingFloatsRootInlineBox.
<span class="line-modified">1104         if (!root || !root-&gt;logicalHeight() || !root-&gt;firstLeafDescendant())</span>
1105             root = nullptr;
1106     }
1107 
1108     if (!root) {
1109         // FIXME: We need do the same in previousLinePosition.
1110         Node* child = node-&gt;traverseToChildAt(p.deprecatedEditingOffset());
1111         node = child ? child : node-&gt;lastDescendant();
1112         Position position = nextRootInlineBoxCandidatePosition(node, visiblePosition, editableType);
1113         if (position.isNotNull()) {
1114             RenderedPosition renderedPosition(position);
1115             root = renderedPosition.rootBox();
1116             if (!root)
1117                 return position;
1118         }
1119     }
1120 
1121     if (root) {
1122         // FIXME: Can be wrong for multi-column layout and with transforms.
1123         IntPoint pointInLine = absoluteLineDirectionPointToLocalPointInBlock(*root, lineDirectionPoint);
1124         RenderObject&amp; renderer = root-&gt;closestLeafChildForPoint(pointInLine, isEditablePosition(p))-&gt;renderer();
</pre>
<hr />
<pre>
1574 {
1575     if (granularity == CharacterGranularity)
1576         return true;
1577 
1578     VisiblePosition boundary;
1579 
1580     bool useDownstream = directionIsDownstream(direction);
1581 
1582     switch (granularity) {
1583     case WordGranularity:
1584         // visible_units claims erroneously that the start and the end
1585         // of a paragraph are the end and start of a word, respectively.
1586         if ((useDownstream &amp;&amp; isStartOfParagraph(vp)) || (!useDownstream &amp;&amp; isEndOfParagraph(vp)))
1587             return false;
1588 
1589         // Note that &quot;Left&quot; and &quot;Right&quot; in this context apparently mean &quot;upstream/previous&quot; and &quot;downstream/next&quot;.
1590         boundary = useDownstream ? endOfWord(vp, LeftWordIfOnBoundary) : startOfWord(vp, RightWordIfOnBoundary);
1591         break;
1592 
1593     case SentenceGranularity:
<span class="line-modified">1594         boundary = useDownstream ? endOfSentence(previousSentencePosition(vp)) : startOfSentence(nextSentencePosition(vp));</span>
1595         break;
1596 
1597     case LineGranularity:
1598         // Affinity has to be set to get right boundary of the line.
1599         boundary = vp;
1600         boundary.setAffinity(useDownstream ? VP_UPSTREAM_IF_POSSIBLE : DOWNSTREAM);
1601         boundary = useDownstream ? endOfLine(boundary) : startOfLine(boundary);
1602         break;
1603 
1604     case ParagraphGranularity:
1605         boundary = useDownstream ? endOfParagraph(vp) : startOfParagraph(vp);
1606         break;
1607 
1608     case DocumentGranularity:
1609         boundary = useDownstream ? endOfDocument(vp) : startOfDocument(vp);
1610         break;
1611 
1612     default:
1613         ASSERT_NOT_REACHED();
1614         break;
</pre>
<hr />
<pre>
1759 
1760 static VisiblePosition nextSentenceBoundaryInDirection(const VisiblePosition&amp; vp, SelectionDirection direction)
1761 {
1762     bool useDownstream = directionIsDownstream(direction);
1763     bool withinUnitOfGranularity = withinTextUnitOfGranularity(vp, SentenceGranularity, direction);
1764     VisiblePosition result;
1765 
1766     if (withinUnitOfGranularity)
1767         result = useDownstream ? endOfSentence(vp) : startOfSentence(vp);
1768     else {
1769         result = useDownstream ? nextSentencePosition(vp) : previousSentencePosition(vp);
1770         if (result.isNull() || result == vp)
1771             return VisiblePosition();
1772 
1773         result = useDownstream ? startOfSentence(vp) : endOfSentence(vp);
1774     }
1775 
1776     if (result == vp)
1777         return VisiblePosition();
1778 
<span class="line-modified">1779     // Positions can only be compared if they are in the same tree scope.</span>
<span class="line-added">1780     ASSERT_IMPLIES(areVisiblePositionsInSameTreeScope(result, vp), useDownstream ? (result &gt; vp) : (result &lt; vp));</span>
1781 
1782     return result;
1783 }
1784 
1785 static VisiblePosition nextLineBoundaryInDirection(const VisiblePosition&amp; vp, SelectionDirection direction)
1786 {
1787     bool useDownstream = directionIsDownstream(direction);
1788     VisiblePosition result = vp;
1789 
1790     if (useDownstream) {
1791         result.setAffinity(DOWNSTREAM);
1792         result = isEndOfLine(result) ? startOfLine(nextLinePosition(result, result.lineDirectionPointForBlockDirectionNavigation())) : endOfLine(result);
1793     } else {
1794         result.setAffinity(VP_UPSTREAM_IF_POSSIBLE);
1795         result = isStartOfLine(result) ? endOfLine(previousLinePosition(result, result.lineDirectionPointForBlockDirectionNavigation())) : startOfLine(result);
1796     }
1797 
1798     return result;
1799 }
1800 
<span class="line-modified">1801 static VisiblePosition nextParagraphBoundaryInDirection(const VisiblePosition&amp; position, SelectionDirection direction)</span>
1802 {
<span class="line-modified">1803     auto useDownstream = directionIsDownstream(direction);</span>
<span class="line-modified">1804     auto lineDirection = position.lineDirectionPointForBlockDirectionNavigation();</span>
<span class="line-modified">1805     if (atBoundaryOfGranularity(position, ParagraphGranularity, direction))</span>
<span class="line-modified">1806         return useDownstream ? startOfParagraph(nextParagraphPosition(position, lineDirection)) : endOfParagraph(previousParagraphPosition(position, lineDirection));</span>
<span class="line-modified">1807     ASSERT(withinTextUnitOfGranularity(position, ParagraphGranularity, direction));</span>
<span class="line-modified">1808     return useDownstream ? endOfParagraph(position) : startOfParagraph(position);</span>




1809 }
1810 
1811 static VisiblePosition nextDocumentBoundaryInDirection(const VisiblePosition&amp; vp, SelectionDirection direction)
1812 {
1813     return directionIsDownstream(direction) ? endOfDocument(vp) : startOfDocument(vp);
1814 }
1815 
1816 VisiblePosition positionOfNextBoundaryOfGranularity(const VisiblePosition&amp; vp, TextGranularity granularity, SelectionDirection direction)
1817 {
1818     switch (granularity) {
1819     case CharacterGranularity:
1820         return nextCharacterBoundaryInDirection(vp, direction, CanCrossEditingBoundary);
1821     case WordGranularity:
1822         return nextWordBoundaryInDirection(vp, direction);
1823     case SentenceGranularity:
1824         return nextSentenceBoundaryInDirection(vp, direction);
1825     case LineGranularity:
1826         return nextLineBoundaryInDirection(vp, direction);
1827     case ParagraphGranularity:
1828         return nextParagraphBoundaryInDirection(vp, direction);
</pre>
<hr />
<pre>
1949             characters[index++] = characterString[i];
1950         }
1951     }
1952     oneAfter = characters[0];
1953     oneBefore = characters[1];
1954     twoBefore = characters[2];
1955 }
1956 
1957 RefPtr&lt;Range&gt; wordRangeFromPosition(const VisiblePosition&amp; position)
1958 {
1959     // The selection could be in a non visible element and we don&#39;t have a VisiblePosition.
1960     if (position.isNull())
1961         return nullptr;
1962 
1963     RefPtr&lt;Range&gt; range = enclosingTextUnitOfGranularity(position, WordGranularity, DirectionBackward);
1964 
1965     if (!range) {
1966         // We could be at the start of a word, try forward.
1967         range = enclosingTextUnitOfGranularity(position, WordGranularity, DirectionForward);
1968     }
<span class="line-added">1969 </span>
1970     if (range)
1971         return range;
1972 
1973     VisiblePosition currentPosition = position;
1974     do {
1975         currentPosition = positionOfNextBoundaryOfGranularity(currentPosition, WordGranularity, DirectionBackward);
1976     } while (currentPosition.isNotNull() &amp;&amp; !atBoundaryOfGranularity(currentPosition, WordGranularity, DirectionBackward));
1977 












1978     if (currentPosition.isNull())
1979         currentPosition = positionOfNextBoundaryOfGranularity(position, WordGranularity, DirectionForward);
1980 
1981     if (currentPosition.isNotNull()) {
1982         range = Range::create(position.deepEquivalent().deprecatedNode()-&gt;document(), currentPosition, position);
1983         ASSERT(range);
1984     }
<span class="line-added">1985 </span>
1986     return range;
1987 }
1988 
1989 VisiblePosition closestWordBoundaryForPosition(const VisiblePosition&amp; position)
1990 {
1991     VisiblePosition result;
1992 
1993     // move the position at the end of the word
1994     if (atBoundaryOfGranularity(position, LineGranularity, DirectionForward)) {
1995         // Don&#39;t cross line boundaries.
1996         result = position;
1997     } else if (withinTextUnitOfGranularity(position, WordGranularity, DirectionForward)) {
1998         // The position lies within a word.
1999         RefPtr&lt;Range&gt; wordRange = enclosingTextUnitOfGranularity(position, WordGranularity, DirectionForward);
2000 
2001         result = wordRange-&gt;startPosition();
2002         if (distanceBetweenPositions(position, result) &gt; 1)
2003             result = wordRange-&gt;endPosition();
2004     } else if (atBoundaryOfGranularity(position, WordGranularity, DirectionBackward)) {
2005         // The position is at the end of a word.
</pre>
</td>
</tr>
</table>
<center><a href="VisibleSelection.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WebContentReader.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
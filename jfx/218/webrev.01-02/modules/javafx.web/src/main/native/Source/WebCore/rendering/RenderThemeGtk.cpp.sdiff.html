<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderThemeGtk.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderThemeCocoa.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderThemeGtk.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderThemeGtk.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 257         break;
 258     case SpinButtonUpButton:
 259         if (theme.isPressed(renderObject) &amp;&amp; theme.isSpinUpButtonPartPressed(renderObject))
 260             stateFlags |= GTK_STATE_FLAG_ACTIVE;
 261         if (theme.isHovered(renderObject) &amp;&amp; !theme.isSpinUpButtonPartHovered(renderObject))
 262             stateFlags &amp;= ~GTK_STATE_FLAG_PRELIGHT;
 263         break;
 264     case SpinButtonDownButton:
 265         if (theme.isPressed(renderObject) &amp;&amp; !theme.isSpinUpButtonPartPressed(renderObject))
 266             stateFlags |= GTK_STATE_FLAG_ACTIVE;
 267         if (theme.isHovered(renderObject) &amp;&amp; theme.isSpinUpButtonPartHovered(renderObject))
 268             stateFlags &amp;= ~GTK_STATE_FLAG_PRELIGHT;
 269         break;
 270     default:
 271         break;
 272     }
 273 
 274     return static_cast&lt;GtkStateFlags&gt;(stateFlags);
 275 }
 276 
<span class="line-modified"> 277 void RenderThemeGtk::adjustButtonStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const</span>
 278 {
 279     // Some layout tests check explicitly that buttons ignore line-height.
 280     if (style.appearance() == PushButtonPart)
 281         style.setLineHeight(RenderStyle::initialLineHeight());
 282 }
 283 
 284 static void shrinkToMinimumSizeAndCenterRectangle(FloatRect&amp; rect, const IntSize&amp; minSize)
 285 {
 286     if (rect.width() &gt; minSize.width()) {
 287         rect.inflateX(-(rect.width() - minSize.width()) / 2);
 288         rect.setWidth(minSize.width()); // In case rect.width() was equal to minSize.width() + 1.
 289     }
 290 
 291     if (rect.height() &gt; minSize.height()) {
 292         rect.inflateY(-(rect.height() - minSize.height()) / 2);
 293         rect.setHeight(minSize.height()); // In case rect.height() was equal to minSize.height() + 1.
 294     }
 295 }
 296 
 297 static void setToggleSize(RenderThemePart themePart, RenderStyle&amp; style)
</pre>
<hr />
<pre>
 363 
 364 bool RenderThemeGtk::paintButton(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 365 {
 366     auto&amp; buttonWidget = static_cast&lt;RenderThemeButton&amp;&gt;(RenderThemeWidget::getOrCreate(isDefault(renderObject) ? RenderThemeWidget::Type::ButtonDefault : RenderThemeWidget::Type::Button));
 367     buttonWidget.button().setState(themePartStateFlags(*this, Button, renderObject));
 368     buttonWidget.button().render(paintInfo.context().platformContext()-&gt;cr(), rect);
 369     if (isFocused(renderObject))
 370         buttonWidget.button().renderFocus(paintInfo.context().platformContext()-&gt;cr(), rect);
 371     return false;
 372 }
 373 
 374 static Color menuListColor(const Element* element)
 375 {
 376     auto&amp; comboWidget = static_cast&lt;RenderThemeComboBox&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::ComboBox));
 377     GtkStateFlags state = element-&gt;isDisabledFormControl() ? GTK_STATE_FLAG_INSENSITIVE : GTK_STATE_FLAG_NORMAL;
 378     comboWidget.comboBox().setState(state);
 379     comboWidget.button().setState(state);
 380     return comboWidget.button().color();
 381 }
 382 
<span class="line-modified"> 383 void RenderThemeGtk::adjustMenuListStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element* element) const</span>
 384 {
 385     // The tests check explicitly that select menu buttons ignore line height.
 386     style.setLineHeight(RenderStyle::initialLineHeight());
 387 
 388     // We cannot give a proper rendering when border radius is active, unfortunately.
 389     style.resetBorderRadius();
 390 
 391     if (element)
 392         style.setColor(menuListColor(element));
 393 }
 394 
<span class="line-modified"> 395 void RenderThemeGtk::adjustMenuListButtonStyle(StyleResolver&amp; styleResolver, RenderStyle&amp; style, const Element* e) const</span>
 396 {
<span class="line-modified"> 397     adjustMenuListStyle(styleResolver, style, e);</span>
 398 }
 399 
 400 /*
 401  * GtkComboBox gadgets tree
 402  *
 403  * combobox
 404  * ├── box.linked
 405  * │   ╰── button.combo
 406  * │       ╰── box
 407  * │           ├── cellview
 408  * │           ╰── arrow
 409  * ╰── window.popup
 410  */
 411 LengthBox RenderThemeGtk::popupInternalPaddingBox(const RenderStyle&amp; style) const
 412 {
 413     if (style.appearance() == NoControlPart)
 414         return LengthBox(0);
 415 
 416     auto&amp; comboWidget = static_cast&lt;RenderThemeComboBox&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::ComboBox));
 417     comboWidget.comboBox().setState(GTK_STATE_FLAG_NORMAL);
</pre>
<hr />
<pre>
 458     return paintMenuList(object, info, rect);
 459 }
 460 
 461 static IntSize spinButtonSize()
 462 {
 463     auto&amp; spinButtonWidget = static_cast&lt;RenderThemeSpinButton&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::SpinButton));
 464     spinButtonWidget.spinButton().setState(GTK_STATE_FLAG_NORMAL);
 465     spinButtonWidget.entry().setState(GTK_STATE_FLAG_NORMAL);
 466     spinButtonWidget.up().setState(GTK_STATE_FLAG_NORMAL);
 467     spinButtonWidget.down().setState(GTK_STATE_FLAG_NORMAL);
 468 
 469     IntSize preferredSize = spinButtonWidget.spinButton().preferredSize();
 470     preferredSize = preferredSize.expandedTo(spinButtonWidget.entry().preferredSize());
 471     IntSize upPreferredSize = preferredSize.expandedTo(spinButtonWidget.up().preferredSize());
 472     IntSize downPreferredSize = preferredSize.expandedTo(spinButtonWidget.down().preferredSize());
 473 
 474     return IntSize(upPreferredSize.width() + downPreferredSize.width(), std::max(upPreferredSize.height(), downPreferredSize.height()));
 475 }
 476 
 477 
<span class="line-modified"> 478 void RenderThemeGtk::adjustTextFieldStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element* element) const</span>
 479 {
 480     if (!is&lt;HTMLInputElement&gt;(element) || !shouldHaveSpinButton(downcast&lt;HTMLInputElement&gt;(*element)))
 481         return;
 482 
 483     style.setMinHeight(Length(spinButtonSize().height(), Fixed));
 484 
 485     // The default theme for the GTK+ port uses very wide spin buttons (66px) compared to what other
 486     // browsers use (~13 px). And unfortunately, most of the web developers won&#39;t test how their site
 487     // renders on WebKitGTK. To ensure that spin buttons don&#39;t end up covering the values of the input
 488     // field, we override the width of the input element and always increment it with the width needed
 489     // for the spinbutton (when drawing the spinbutton).
 490     int minimumWidth = style.width().intValue() + spinButtonSize().width();
 491     style.setMinWidth(Length(minimumWidth, Fixed));
 492 }
 493 
 494 bool RenderThemeGtk::paintTextField(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const FloatRect&amp; rect)
 495 {
 496     if (is&lt;HTMLInputElement&gt;(renderObject.node()) &amp;&amp; shouldHaveSpinButton(downcast&lt;HTMLInputElement&gt;(*renderObject.node()))) {
 497         auto&amp; spinButtonWidget = static_cast&lt;RenderThemeSpinButton&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::SpinButton));
 498         auto spinButtonState = themePartStateFlags(*this, Entry, renderObject);
</pre>
<hr />
<pre>
 525     searchEntryWidget.rightIcon().setState(GTK_STATE_FLAG_NORMAL);
 526 
 527     // Get the icon size based on the font size.
 528     auto&amp; icon = static_cast&lt;RenderThemeIconGadget&amp;&gt;(themePart == EntryIconLeft ? searchEntryWidget.leftIcon() : searchEntryWidget.rightIcon());
 529     icon.setIconSize(style.computedFontPixelSize());
 530     IntSize preferredSize = icon.preferredSize();
 531     GtkBorder contentsBox = searchEntryWidget.entry().contentsBox();
 532     if (themePart == EntryIconLeft)
 533         preferredSize.expand(contentsBox.left, contentsBox.top + contentsBox.bottom);
 534     else
 535         preferredSize.expand(contentsBox.right, contentsBox.top + contentsBox.bottom);
 536     style.setWidth(Length(preferredSize.width(), Fixed));
 537     style.setHeight(Length(preferredSize.height(), Fixed));
 538 }
 539 
 540 bool RenderThemeGtk::paintTextArea(const RenderObject&amp; o, const PaintInfo&amp; i, const FloatRect&amp; r)
 541 {
 542     return paintTextField(o, i, r);
 543 }
 544 
<span class="line-modified"> 545 void RenderThemeGtk::adjustSearchFieldResultsButtonStyle(StyleResolver&amp; styleResolver, RenderStyle&amp; style, const Element* e) const</span>
 546 {
<span class="line-modified"> 547     adjustSearchFieldCancelButtonStyle(styleResolver, style, e);</span>
 548 }
 549 
 550 bool RenderThemeGtk::paintSearchFieldResultsButton(const RenderBox&amp; o, const PaintInfo&amp; i, const IntRect&amp; rect)
 551 {
 552     return paintSearchFieldResultsDecorationPart(o, i, rect);
 553 }
 554 
<span class="line-modified"> 555 void RenderThemeGtk::adjustSearchFieldResultsDecorationPartStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const</span>
 556 {
 557     adjustSearchFieldIconStyle(EntryIconLeft, style);
 558 }
 559 
<span class="line-modified"> 560 void RenderThemeGtk::adjustSearchFieldCancelButtonStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const</span>
 561 {
 562     adjustSearchFieldIconStyle(EntryIconRight, style);
 563 }
 564 
 565 static bool paintSearchFieldIcon(RenderThemeGtk* theme, RenderThemePart themePart, const RenderBox&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 566 {
 567     ASSERT(themePart == EntryIconLeft || themePart == EntryIconRight);
 568     auto&amp; searchEntryWidget = static_cast&lt;RenderThemeSearchEntry&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::SearchEntry));
 569     searchEntryWidget.entry().setState(themePartStateFlags(*theme, Entry, renderObject));
 570     auto&amp; icon = static_cast&lt;RenderThemeIconGadget&amp;&gt;(themePart == EntryIconLeft ? searchEntryWidget.leftIcon() : searchEntryWidget.rightIcon());
 571     icon.setState(themePartStateFlags(*theme, themePart, renderObject));
 572     icon.setIconSize(renderObject.style().computedFontPixelSize());
 573     GtkBorder contentsBox = searchEntryWidget.entry().contentsBox();
 574     IntRect iconRect = rect;
 575     if (themePart == EntryIconLeft) {
 576         iconRect.move(contentsBox.left, contentsBox.top);
 577         iconRect.contract(contentsBox.left, contentsBox.top + contentsBox.bottom);
 578     } else
 579         iconRect.contract(contentsBox.right, contentsBox.top + contentsBox.bottom);
 580     return !icon.render(paintInfo.context().platformContext()-&gt;cr(), iconRect);
 581 }
 582 bool RenderThemeGtk::paintSearchFieldResultsDecorationPart(const RenderBox&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 583 {
 584     return paintSearchFieldIcon(this, EntryIconLeft, renderObject, paintInfo, rect);
 585 }
 586 
 587 bool RenderThemeGtk::paintSearchFieldCancelButton(const RenderBox&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 588 {
 589     return paintSearchFieldIcon(this, EntryIconRight, renderObject, paintInfo, rect);
 590 }
 591 
 592 #if ENABLE(DATALIST_ELEMENT)
<span class="line-modified"> 593 void RenderThemeGtk::adjustListButtonStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const</span>
 594 {
 595     // Add a margin to place the button at end of the input field.
 596     if (style.isLeftToRightDirection())
 597         style.setMarginRight(Length(-4, Fixed));
 598     else
 599         style.setMarginLeft(Length(-4, Fixed));
 600 }
 601 
 602 void RenderThemeGtk::paintListButtonForInput(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const FloatRect&amp; rect)
 603 {
 604     // Use a combo box widget to render its arrow.
 605     auto&amp; comboWidget = static_cast&lt;RenderThemeComboBox&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::ComboBox));
 606     comboWidget.arrow().setState(themePartStateFlags(*this, ComboBoxButton, renderObject));
 607 
 608     // But a search entry widget to get the contents rect, since this is a text input field.
 609     auto&amp; searchEntryWidget = static_cast&lt;RenderThemeSearchEntry&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::SearchEntry));
 610     auto&amp; icon = static_cast&lt;RenderThemeIconGadget&amp;&gt;(searchEntryWidget.rightIcon());
 611     icon.setIconSize(comboWidget.arrow().preferredSize().width());
 612     GtkBorder contentsBox = searchEntryWidget.entry().contentsBox();
 613     FloatRect adjustedRect(rect);
 614     adjustedRect.move(contentsBox.left, contentsBox.top);
 615     adjustedRect.contract(contentsBox.right + 1, contentsBox.top + contentsBox.bottom);
 616     comboWidget.arrow().render(paintInfo.context().platformContext()-&gt;cr(), adjustedRect);
 617 }
 618 #endif
 619 
<span class="line-modified"> 620 void RenderThemeGtk::adjustSearchFieldStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const</span>
 621 {
 622     // We cannot give a proper rendering when border radius is active, unfortunately.
 623     style.resetBorderRadius();
 624     style.setLineHeight(RenderStyle::initialLineHeight());
 625 }
 626 
 627 bool RenderThemeGtk::paintSearchField(const RenderObject&amp; o, const PaintInfo&amp; i, const IntRect&amp; rect)
 628 {
 629     return paintTextField(o, i, rect);
 630 }
 631 
 632 bool RenderThemeGtk::shouldHaveCapsLockIndicator(const HTMLInputElement&amp; element) const
 633 {
 634     return element.isPasswordField();
 635 }
 636 
<span class="line-modified"> 637 void RenderThemeGtk::adjustSliderTrackStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const</span>
 638 {
 639     style.setBoxShadow(nullptr);
 640 }
 641 
<span class="line-modified"> 642 void RenderThemeGtk::adjustSliderThumbStyle(StyleResolver&amp; styleResolver, RenderStyle&amp; style, const Element* element) const</span>
 643 {
<span class="line-modified"> 644     RenderTheme::adjustSliderThumbStyle(styleResolver, style, element);</span>
 645     style.setBoxShadow(nullptr);
 646 }
 647 
 648 /*
 649  * GtkScale
 650  *
 651  * scale
 652  * ╰── contents
 653  *     ╰── trough
 654  *         ├── slider
 655  *         ╰── [highlight]
 656  */
 657 bool RenderThemeGtk::paintSliderTrack(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 658 {
 659     ControlPart part = renderObject.style().appearance();
 660     ASSERT(part == SliderHorizontalPart || part == SliderVerticalPart);
 661 
 662     auto&amp; sliderWidget = static_cast&lt;RenderThemeSlider&amp;&gt;(RenderThemeWidget::getOrCreate(part == SliderHorizontalPart ? RenderThemeWidget::Type::HorizontalSlider : RenderThemeWidget::Type::VerticalSlider));
 663     auto scaleState = themePartStateFlags(*this, Scale, renderObject);
 664     auto&amp; scale = sliderWidget.scale();
</pre>
<hr />
<pre>
 784 }
 785 
 786 bool RenderThemeGtk::paintProgressBar(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 787 {
 788     if (!renderObject.isProgress())
 789         return true;
 790 
 791     const auto&amp; renderProgress = downcast&lt;RenderProgress&gt;(renderObject);
 792     auto&amp; progressBarWidget = static_cast&lt;RenderThemeProgressBar&amp;&gt;(RenderThemeWidget::getOrCreate(renderProgress.isDeterminate() ? RenderThemeProgressBar::Type::ProgressBar : RenderThemeProgressBar::Type::IndeterminateProgressBar));
 793     progressBarWidget.progressBar().render(paintInfo.context().platformContext()-&gt;cr(), rect);
 794     progressBarWidget.trough().render(paintInfo.context().platformContext()-&gt;cr(), rect);
 795     progressBarWidget.progress().render(paintInfo.context().platformContext()-&gt;cr(), calculateProgressRect(renderObject, rect));
 796     return false;
 797 }
 798 
 799 RenderTheme::InnerSpinButtonLayout RenderThemeGtk::innerSpinButtonLayout(const RenderObject&amp; renderObject) const
 800 {
 801     return renderObject.style().direction() == TextDirection::RTL ? InnerSpinButtonLayout::HorizontalUpLeft : InnerSpinButtonLayout::HorizontalUpRight;
 802 }
 803 
<span class="line-modified"> 804 void RenderThemeGtk::adjustInnerSpinButtonStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const</span>
 805 {
 806     style.setWidth(Length(spinButtonSize().width(), Fixed));
 807     style.setHeight(Length(spinButtonSize().height(), Fixed));
 808 }
 809 
 810 bool RenderThemeGtk::paintInnerSpinButton(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 811 {
 812     auto&amp; spinButtonWidget = static_cast&lt;RenderThemeSpinButton&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::SpinButton));
 813     auto spinButtonState = themePartStateFlags(*this, SpinButton, renderObject);
 814     spinButtonWidget.spinButton().setState(spinButtonState);
 815     spinButtonWidget.entry().setState(spinButtonState);
 816     auto&amp; up = spinButtonWidget.up();
 817     up.setState(themePartStateFlags(*this, SpinButtonUpButton, renderObject));
 818     auto&amp; down = spinButtonWidget.down();
 819     down.setState(themePartStateFlags(*this, SpinButtonDownButton, renderObject));
 820 
 821     IntRect iconRect = rect;
 822     iconRect.setWidth(iconRect.width() / 2);
 823     if (renderObject.style().direction() == TextDirection::RTL)
 824         up.render(paintInfo.context().platformContext()-&gt;cr(), iconRect);
</pre>
<hr />
<pre>
1096 
1097     return false;
1098 }
1099 
1100 bool RenderThemeGtk::paintMediaVolumeSliderThumb(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
1101 {
1102     return paintMediaSliderThumb(renderObject, paintInfo, rect);
1103 }
1104 
1105 String RenderThemeGtk::formatMediaControlsCurrentTime(float currentTime, float duration) const
1106 {
1107     return formatMediaControlsTime(currentTime) + &quot; / &quot; + formatMediaControlsTime(duration);
1108 }
1109 
1110 bool RenderThemeGtk::paintMediaCurrentTime(const RenderObject&amp;, const PaintInfo&amp;, const IntRect&amp;)
1111 {
1112     return false;
1113 }
1114 #endif
1115 
<span class="line-modified">1116 void RenderThemeGtk::adjustProgressBarStyle(StyleResolver&amp;, RenderStyle&amp; style, const Element*) const</span>
1117 {
1118     style.setBoxShadow(nullptr);
1119 }
1120 
1121 // These values have been copied from RenderThemeChromiumSkia.cpp
1122 static const int progressActivityBlocks = 5;
1123 static const int progressAnimationFrames = 10;
1124 static const Seconds progressAnimationInterval { 125_ms };
1125 Seconds RenderThemeGtk::animationRepeatIntervalForProgressBar(RenderProgress&amp;) const
1126 {
1127     return progressAnimationInterval;
1128 }
1129 
1130 Seconds RenderThemeGtk::animationDurationForProgressBar(RenderProgress&amp;) const
1131 {
1132     return progressAnimationInterval * progressAnimationFrames * 2; // &quot;2&quot; for back and forth;
1133 }
1134 
1135 IntRect RenderThemeGtk::calculateProgressRect(const RenderObject&amp; renderObject, const IntRect&amp; fullBarRect)
1136 {
</pre>
</td>
<td>
<hr />
<pre>
 257         break;
 258     case SpinButtonUpButton:
 259         if (theme.isPressed(renderObject) &amp;&amp; theme.isSpinUpButtonPartPressed(renderObject))
 260             stateFlags |= GTK_STATE_FLAG_ACTIVE;
 261         if (theme.isHovered(renderObject) &amp;&amp; !theme.isSpinUpButtonPartHovered(renderObject))
 262             stateFlags &amp;= ~GTK_STATE_FLAG_PRELIGHT;
 263         break;
 264     case SpinButtonDownButton:
 265         if (theme.isPressed(renderObject) &amp;&amp; !theme.isSpinUpButtonPartPressed(renderObject))
 266             stateFlags |= GTK_STATE_FLAG_ACTIVE;
 267         if (theme.isHovered(renderObject) &amp;&amp; theme.isSpinUpButtonPartHovered(renderObject))
 268             stateFlags &amp;= ~GTK_STATE_FLAG_PRELIGHT;
 269         break;
 270     default:
 271         break;
 272     }
 273 
 274     return static_cast&lt;GtkStateFlags&gt;(stateFlags);
 275 }
 276 
<span class="line-modified"> 277 void RenderThemeGtk::adjustButtonStyle(RenderStyle&amp; style, const Element*) const</span>
 278 {
 279     // Some layout tests check explicitly that buttons ignore line-height.
 280     if (style.appearance() == PushButtonPart)
 281         style.setLineHeight(RenderStyle::initialLineHeight());
 282 }
 283 
 284 static void shrinkToMinimumSizeAndCenterRectangle(FloatRect&amp; rect, const IntSize&amp; minSize)
 285 {
 286     if (rect.width() &gt; minSize.width()) {
 287         rect.inflateX(-(rect.width() - minSize.width()) / 2);
 288         rect.setWidth(minSize.width()); // In case rect.width() was equal to minSize.width() + 1.
 289     }
 290 
 291     if (rect.height() &gt; minSize.height()) {
 292         rect.inflateY(-(rect.height() - minSize.height()) / 2);
 293         rect.setHeight(minSize.height()); // In case rect.height() was equal to minSize.height() + 1.
 294     }
 295 }
 296 
 297 static void setToggleSize(RenderThemePart themePart, RenderStyle&amp; style)
</pre>
<hr />
<pre>
 363 
 364 bool RenderThemeGtk::paintButton(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 365 {
 366     auto&amp; buttonWidget = static_cast&lt;RenderThemeButton&amp;&gt;(RenderThemeWidget::getOrCreate(isDefault(renderObject) ? RenderThemeWidget::Type::ButtonDefault : RenderThemeWidget::Type::Button));
 367     buttonWidget.button().setState(themePartStateFlags(*this, Button, renderObject));
 368     buttonWidget.button().render(paintInfo.context().platformContext()-&gt;cr(), rect);
 369     if (isFocused(renderObject))
 370         buttonWidget.button().renderFocus(paintInfo.context().platformContext()-&gt;cr(), rect);
 371     return false;
 372 }
 373 
 374 static Color menuListColor(const Element* element)
 375 {
 376     auto&amp; comboWidget = static_cast&lt;RenderThemeComboBox&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::ComboBox));
 377     GtkStateFlags state = element-&gt;isDisabledFormControl() ? GTK_STATE_FLAG_INSENSITIVE : GTK_STATE_FLAG_NORMAL;
 378     comboWidget.comboBox().setState(state);
 379     comboWidget.button().setState(state);
 380     return comboWidget.button().color();
 381 }
 382 
<span class="line-modified"> 383 void RenderThemeGtk::adjustMenuListStyle(RenderStyle&amp; style, const Element* element) const</span>
 384 {
 385     // The tests check explicitly that select menu buttons ignore line height.
 386     style.setLineHeight(RenderStyle::initialLineHeight());
 387 
 388     // We cannot give a proper rendering when border radius is active, unfortunately.
 389     style.resetBorderRadius();
 390 
 391     if (element)
 392         style.setColor(menuListColor(element));
 393 }
 394 
<span class="line-modified"> 395 void RenderThemeGtk::adjustMenuListButtonStyle(RenderStyle&amp; style, const Element* e) const</span>
 396 {
<span class="line-modified"> 397     adjustMenuListStyle(style, e);</span>
 398 }
 399 
 400 /*
 401  * GtkComboBox gadgets tree
 402  *
 403  * combobox
 404  * ├── box.linked
 405  * │   ╰── button.combo
 406  * │       ╰── box
 407  * │           ├── cellview
 408  * │           ╰── arrow
 409  * ╰── window.popup
 410  */
 411 LengthBox RenderThemeGtk::popupInternalPaddingBox(const RenderStyle&amp; style) const
 412 {
 413     if (style.appearance() == NoControlPart)
 414         return LengthBox(0);
 415 
 416     auto&amp; comboWidget = static_cast&lt;RenderThemeComboBox&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::ComboBox));
 417     comboWidget.comboBox().setState(GTK_STATE_FLAG_NORMAL);
</pre>
<hr />
<pre>
 458     return paintMenuList(object, info, rect);
 459 }
 460 
 461 static IntSize spinButtonSize()
 462 {
 463     auto&amp; spinButtonWidget = static_cast&lt;RenderThemeSpinButton&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::SpinButton));
 464     spinButtonWidget.spinButton().setState(GTK_STATE_FLAG_NORMAL);
 465     spinButtonWidget.entry().setState(GTK_STATE_FLAG_NORMAL);
 466     spinButtonWidget.up().setState(GTK_STATE_FLAG_NORMAL);
 467     spinButtonWidget.down().setState(GTK_STATE_FLAG_NORMAL);
 468 
 469     IntSize preferredSize = spinButtonWidget.spinButton().preferredSize();
 470     preferredSize = preferredSize.expandedTo(spinButtonWidget.entry().preferredSize());
 471     IntSize upPreferredSize = preferredSize.expandedTo(spinButtonWidget.up().preferredSize());
 472     IntSize downPreferredSize = preferredSize.expandedTo(spinButtonWidget.down().preferredSize());
 473 
 474     return IntSize(upPreferredSize.width() + downPreferredSize.width(), std::max(upPreferredSize.height(), downPreferredSize.height()));
 475 }
 476 
 477 
<span class="line-modified"> 478 void RenderThemeGtk::adjustTextFieldStyle(RenderStyle&amp; style, const Element* element) const</span>
 479 {
 480     if (!is&lt;HTMLInputElement&gt;(element) || !shouldHaveSpinButton(downcast&lt;HTMLInputElement&gt;(*element)))
 481         return;
 482 
 483     style.setMinHeight(Length(spinButtonSize().height(), Fixed));
 484 
 485     // The default theme for the GTK+ port uses very wide spin buttons (66px) compared to what other
 486     // browsers use (~13 px). And unfortunately, most of the web developers won&#39;t test how their site
 487     // renders on WebKitGTK. To ensure that spin buttons don&#39;t end up covering the values of the input
 488     // field, we override the width of the input element and always increment it with the width needed
 489     // for the spinbutton (when drawing the spinbutton).
 490     int minimumWidth = style.width().intValue() + spinButtonSize().width();
 491     style.setMinWidth(Length(minimumWidth, Fixed));
 492 }
 493 
 494 bool RenderThemeGtk::paintTextField(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const FloatRect&amp; rect)
 495 {
 496     if (is&lt;HTMLInputElement&gt;(renderObject.node()) &amp;&amp; shouldHaveSpinButton(downcast&lt;HTMLInputElement&gt;(*renderObject.node()))) {
 497         auto&amp; spinButtonWidget = static_cast&lt;RenderThemeSpinButton&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::SpinButton));
 498         auto spinButtonState = themePartStateFlags(*this, Entry, renderObject);
</pre>
<hr />
<pre>
 525     searchEntryWidget.rightIcon().setState(GTK_STATE_FLAG_NORMAL);
 526 
 527     // Get the icon size based on the font size.
 528     auto&amp; icon = static_cast&lt;RenderThemeIconGadget&amp;&gt;(themePart == EntryIconLeft ? searchEntryWidget.leftIcon() : searchEntryWidget.rightIcon());
 529     icon.setIconSize(style.computedFontPixelSize());
 530     IntSize preferredSize = icon.preferredSize();
 531     GtkBorder contentsBox = searchEntryWidget.entry().contentsBox();
 532     if (themePart == EntryIconLeft)
 533         preferredSize.expand(contentsBox.left, contentsBox.top + contentsBox.bottom);
 534     else
 535         preferredSize.expand(contentsBox.right, contentsBox.top + contentsBox.bottom);
 536     style.setWidth(Length(preferredSize.width(), Fixed));
 537     style.setHeight(Length(preferredSize.height(), Fixed));
 538 }
 539 
 540 bool RenderThemeGtk::paintTextArea(const RenderObject&amp; o, const PaintInfo&amp; i, const FloatRect&amp; r)
 541 {
 542     return paintTextField(o, i, r);
 543 }
 544 
<span class="line-modified"> 545 void RenderThemeGtk::adjustSearchFieldResultsButtonStyle(RenderStyle&amp; style, const Element* e) const</span>
 546 {
<span class="line-modified"> 547     adjustSearchFieldCancelButtonStyle(style, e);</span>
 548 }
 549 
 550 bool RenderThemeGtk::paintSearchFieldResultsButton(const RenderBox&amp; o, const PaintInfo&amp; i, const IntRect&amp; rect)
 551 {
 552     return paintSearchFieldResultsDecorationPart(o, i, rect);
 553 }
 554 
<span class="line-modified"> 555 void RenderThemeGtk::adjustSearchFieldResultsDecorationPartStyle(RenderStyle&amp; style, const Element*) const</span>
 556 {
 557     adjustSearchFieldIconStyle(EntryIconLeft, style);
 558 }
 559 
<span class="line-modified"> 560 void RenderThemeGtk::adjustSearchFieldCancelButtonStyle(RenderStyle&amp; style, const Element*) const</span>
 561 {
 562     adjustSearchFieldIconStyle(EntryIconRight, style);
 563 }
 564 
 565 static bool paintSearchFieldIcon(RenderThemeGtk* theme, RenderThemePart themePart, const RenderBox&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 566 {
 567     ASSERT(themePart == EntryIconLeft || themePart == EntryIconRight);
 568     auto&amp; searchEntryWidget = static_cast&lt;RenderThemeSearchEntry&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::SearchEntry));
 569     searchEntryWidget.entry().setState(themePartStateFlags(*theme, Entry, renderObject));
 570     auto&amp; icon = static_cast&lt;RenderThemeIconGadget&amp;&gt;(themePart == EntryIconLeft ? searchEntryWidget.leftIcon() : searchEntryWidget.rightIcon());
 571     icon.setState(themePartStateFlags(*theme, themePart, renderObject));
 572     icon.setIconSize(renderObject.style().computedFontPixelSize());
 573     GtkBorder contentsBox = searchEntryWidget.entry().contentsBox();
 574     IntRect iconRect = rect;
 575     if (themePart == EntryIconLeft) {
 576         iconRect.move(contentsBox.left, contentsBox.top);
 577         iconRect.contract(contentsBox.left, contentsBox.top + contentsBox.bottom);
 578     } else
 579         iconRect.contract(contentsBox.right, contentsBox.top + contentsBox.bottom);
 580     return !icon.render(paintInfo.context().platformContext()-&gt;cr(), iconRect);
 581 }
 582 bool RenderThemeGtk::paintSearchFieldResultsDecorationPart(const RenderBox&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 583 {
 584     return paintSearchFieldIcon(this, EntryIconLeft, renderObject, paintInfo, rect);
 585 }
 586 
 587 bool RenderThemeGtk::paintSearchFieldCancelButton(const RenderBox&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 588 {
 589     return paintSearchFieldIcon(this, EntryIconRight, renderObject, paintInfo, rect);
 590 }
 591 
 592 #if ENABLE(DATALIST_ELEMENT)
<span class="line-modified"> 593 void RenderThemeGtk::adjustListButtonStyle(RenderStyle&amp; style, const Element*) const</span>
 594 {
 595     // Add a margin to place the button at end of the input field.
 596     if (style.isLeftToRightDirection())
 597         style.setMarginRight(Length(-4, Fixed));
 598     else
 599         style.setMarginLeft(Length(-4, Fixed));
 600 }
 601 
 602 void RenderThemeGtk::paintListButtonForInput(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const FloatRect&amp; rect)
 603 {
 604     // Use a combo box widget to render its arrow.
 605     auto&amp; comboWidget = static_cast&lt;RenderThemeComboBox&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::ComboBox));
 606     comboWidget.arrow().setState(themePartStateFlags(*this, ComboBoxButton, renderObject));
 607 
 608     // But a search entry widget to get the contents rect, since this is a text input field.
 609     auto&amp; searchEntryWidget = static_cast&lt;RenderThemeSearchEntry&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::SearchEntry));
 610     auto&amp; icon = static_cast&lt;RenderThemeIconGadget&amp;&gt;(searchEntryWidget.rightIcon());
 611     icon.setIconSize(comboWidget.arrow().preferredSize().width());
 612     GtkBorder contentsBox = searchEntryWidget.entry().contentsBox();
 613     FloatRect adjustedRect(rect);
 614     adjustedRect.move(contentsBox.left, contentsBox.top);
 615     adjustedRect.contract(contentsBox.right + 1, contentsBox.top + contentsBox.bottom);
 616     comboWidget.arrow().render(paintInfo.context().platformContext()-&gt;cr(), adjustedRect);
 617 }
 618 #endif
 619 
<span class="line-modified"> 620 void RenderThemeGtk::adjustSearchFieldStyle(RenderStyle&amp; style, const Element*) const</span>
 621 {
 622     // We cannot give a proper rendering when border radius is active, unfortunately.
 623     style.resetBorderRadius();
 624     style.setLineHeight(RenderStyle::initialLineHeight());
 625 }
 626 
 627 bool RenderThemeGtk::paintSearchField(const RenderObject&amp; o, const PaintInfo&amp; i, const IntRect&amp; rect)
 628 {
 629     return paintTextField(o, i, rect);
 630 }
 631 
 632 bool RenderThemeGtk::shouldHaveCapsLockIndicator(const HTMLInputElement&amp; element) const
 633 {
 634     return element.isPasswordField();
 635 }
 636 
<span class="line-modified"> 637 void RenderThemeGtk::adjustSliderTrackStyle(RenderStyle&amp; style, const Element*) const</span>
 638 {
 639     style.setBoxShadow(nullptr);
 640 }
 641 
<span class="line-modified"> 642 void RenderThemeGtk::adjustSliderThumbStyle(RenderStyle&amp; style, const Element* element) const</span>
 643 {
<span class="line-modified"> 644     RenderTheme::adjustSliderThumbStyle(style, element);</span>
 645     style.setBoxShadow(nullptr);
 646 }
 647 
 648 /*
 649  * GtkScale
 650  *
 651  * scale
 652  * ╰── contents
 653  *     ╰── trough
 654  *         ├── slider
 655  *         ╰── [highlight]
 656  */
 657 bool RenderThemeGtk::paintSliderTrack(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 658 {
 659     ControlPart part = renderObject.style().appearance();
 660     ASSERT(part == SliderHorizontalPart || part == SliderVerticalPart);
 661 
 662     auto&amp; sliderWidget = static_cast&lt;RenderThemeSlider&amp;&gt;(RenderThemeWidget::getOrCreate(part == SliderHorizontalPart ? RenderThemeWidget::Type::HorizontalSlider : RenderThemeWidget::Type::VerticalSlider));
 663     auto scaleState = themePartStateFlags(*this, Scale, renderObject);
 664     auto&amp; scale = sliderWidget.scale();
</pre>
<hr />
<pre>
 784 }
 785 
 786 bool RenderThemeGtk::paintProgressBar(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 787 {
 788     if (!renderObject.isProgress())
 789         return true;
 790 
 791     const auto&amp; renderProgress = downcast&lt;RenderProgress&gt;(renderObject);
 792     auto&amp; progressBarWidget = static_cast&lt;RenderThemeProgressBar&amp;&gt;(RenderThemeWidget::getOrCreate(renderProgress.isDeterminate() ? RenderThemeProgressBar::Type::ProgressBar : RenderThemeProgressBar::Type::IndeterminateProgressBar));
 793     progressBarWidget.progressBar().render(paintInfo.context().platformContext()-&gt;cr(), rect);
 794     progressBarWidget.trough().render(paintInfo.context().platformContext()-&gt;cr(), rect);
 795     progressBarWidget.progress().render(paintInfo.context().platformContext()-&gt;cr(), calculateProgressRect(renderObject, rect));
 796     return false;
 797 }
 798 
 799 RenderTheme::InnerSpinButtonLayout RenderThemeGtk::innerSpinButtonLayout(const RenderObject&amp; renderObject) const
 800 {
 801     return renderObject.style().direction() == TextDirection::RTL ? InnerSpinButtonLayout::HorizontalUpLeft : InnerSpinButtonLayout::HorizontalUpRight;
 802 }
 803 
<span class="line-modified"> 804 void RenderThemeGtk::adjustInnerSpinButtonStyle(RenderStyle&amp; style, const Element*) const</span>
 805 {
 806     style.setWidth(Length(spinButtonSize().width(), Fixed));
 807     style.setHeight(Length(spinButtonSize().height(), Fixed));
 808 }
 809 
 810 bool RenderThemeGtk::paintInnerSpinButton(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
 811 {
 812     auto&amp; spinButtonWidget = static_cast&lt;RenderThemeSpinButton&amp;&gt;(RenderThemeWidget::getOrCreate(RenderThemeWidget::Type::SpinButton));
 813     auto spinButtonState = themePartStateFlags(*this, SpinButton, renderObject);
 814     spinButtonWidget.spinButton().setState(spinButtonState);
 815     spinButtonWidget.entry().setState(spinButtonState);
 816     auto&amp; up = spinButtonWidget.up();
 817     up.setState(themePartStateFlags(*this, SpinButtonUpButton, renderObject));
 818     auto&amp; down = spinButtonWidget.down();
 819     down.setState(themePartStateFlags(*this, SpinButtonDownButton, renderObject));
 820 
 821     IntRect iconRect = rect;
 822     iconRect.setWidth(iconRect.width() / 2);
 823     if (renderObject.style().direction() == TextDirection::RTL)
 824         up.render(paintInfo.context().platformContext()-&gt;cr(), iconRect);
</pre>
<hr />
<pre>
1096 
1097     return false;
1098 }
1099 
1100 bool RenderThemeGtk::paintMediaVolumeSliderThumb(const RenderObject&amp; renderObject, const PaintInfo&amp; paintInfo, const IntRect&amp; rect)
1101 {
1102     return paintMediaSliderThumb(renderObject, paintInfo, rect);
1103 }
1104 
1105 String RenderThemeGtk::formatMediaControlsCurrentTime(float currentTime, float duration) const
1106 {
1107     return formatMediaControlsTime(currentTime) + &quot; / &quot; + formatMediaControlsTime(duration);
1108 }
1109 
1110 bool RenderThemeGtk::paintMediaCurrentTime(const RenderObject&amp;, const PaintInfo&amp;, const IntRect&amp;)
1111 {
1112     return false;
1113 }
1114 #endif
1115 
<span class="line-modified">1116 void RenderThemeGtk::adjustProgressBarStyle(RenderStyle&amp; style, const Element*) const</span>
1117 {
1118     style.setBoxShadow(nullptr);
1119 }
1120 
1121 // These values have been copied from RenderThemeChromiumSkia.cpp
1122 static const int progressActivityBlocks = 5;
1123 static const int progressAnimationFrames = 10;
1124 static const Seconds progressAnimationInterval { 125_ms };
1125 Seconds RenderThemeGtk::animationRepeatIntervalForProgressBar(RenderProgress&amp;) const
1126 {
1127     return progressAnimationInterval;
1128 }
1129 
1130 Seconds RenderThemeGtk::animationDurationForProgressBar(RenderProgress&amp;) const
1131 {
1132     return progressAnimationInterval * progressAnimationFrames * 2; // &quot;2&quot; for back and forth;
1133 }
1134 
1135 IntRect RenderThemeGtk::calculateProgressRect(const RenderObject&amp; renderObject, const IntRect&amp; fullBarRect)
1136 {
</pre>
</td>
</tr>
</table>
<center><a href="RenderThemeCocoa.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderThemeGtk.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
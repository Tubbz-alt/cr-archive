<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebKitLegacy/Storage/StorageAreaImpl.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../PlatformJava.cmake.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StorageAreaImpl.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebKitLegacy/Storage/StorageAreaImpl.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 33 #include &lt;WebCore/SecurityOriginData.h&gt;
 34 #include &lt;WebCore/StorageEventDispatcher.h&gt;
 35 #include &lt;WebCore/StorageMap.h&gt;
 36 #include &lt;WebCore/StorageType.h&gt;
 37 #include &lt;wtf/MainThread.h&gt;
 38 
 39 using namespace WebCore;
 40 
 41 namespace WebKit {
 42 
 43 StorageAreaImpl::~StorageAreaImpl()
 44 {
 45     ASSERT(isMainThread());
 46 }
 47 
 48 inline StorageAreaImpl::StorageAreaImpl(StorageType storageType, const SecurityOriginData&amp; origin, RefPtr&lt;StorageSyncManager&gt;&amp;&amp; syncManager, unsigned quota)
 49     : m_storageType(storageType)
 50     , m_securityOrigin(origin)
 51     , m_storageMap(StorageMap::create(quota))
 52     , m_storageSyncManager(WTFMove(syncManager))
<span class="line-removed"> 53 #ifndef NDEBUG</span>
<span class="line-removed"> 54     , m_isShutdown(false)</span>
<span class="line-removed"> 55 #endif</span>
 56     , m_accessCount(0)
 57     , m_closeDatabaseTimer(*this, &amp;StorageAreaImpl::closeDatabaseTimerFired)
 58 {
 59     ASSERT(isMainThread());
 60     ASSERT(m_storageMap);
 61 
 62     // Accessing the shared global StorageTracker when a StorageArea is created
 63     // ensures that the tracker is properly initialized before anyone actually needs to use it.
 64     StorageTracker::tracker();
 65 }
 66 
 67 Ref&lt;StorageAreaImpl&gt; StorageAreaImpl::create(StorageType storageType, const SecurityOriginData&amp; origin, RefPtr&lt;StorageSyncManager&gt;&amp;&amp; syncManager, unsigned quota)
 68 {
 69     Ref&lt;StorageAreaImpl&gt; area = adoptRef(*new StorageAreaImpl(storageType, origin, WTFMove(syncManager), quota));
 70     // FIXME: If there&#39;s no backing storage for LocalStorage, the default WebKit behavior should be that of private browsing,
 71     // not silently ignoring it. https://bugs.webkit.org/show_bug.cgi?id=25894
 72     if (area-&gt;m_storageSyncManager) {
 73         area-&gt;m_storageAreaSync = StorageAreaSync::create(area-&gt;m_storageSyncManager.get(), area.copyRef(), area-&gt;m_securityOrigin.databaseIdentifier());
 74         ASSERT(area-&gt;m_storageAreaSync);
 75     }
 76     return area;
 77 }
 78 
 79 Ref&lt;StorageAreaImpl&gt; StorageAreaImpl::copy()
 80 {
 81     ASSERT(!m_isShutdown);
 82     return adoptRef(*new StorageAreaImpl(*this));
 83 }
 84 
 85 StorageAreaImpl::StorageAreaImpl(const StorageAreaImpl&amp; area)
 86     : m_storageType(area.m_storageType)
 87     , m_securityOrigin(area.m_securityOrigin)
 88     , m_storageMap(area.m_storageMap)
 89     , m_storageSyncManager(area.m_storageSyncManager)
<span class="line-modified"> 90 #ifndef NDEBUG</span>
 91     , m_isShutdown(area.m_isShutdown)
 92 #endif
 93     , m_accessCount(0)
 94     , m_closeDatabaseTimer(*this, &amp;StorageAreaImpl::closeDatabaseTimerFired)
 95 {
 96     ASSERT(isMainThread());
 97     ASSERT(m_storageMap);
 98     ASSERT(!m_isShutdown);
 99 }
100 
101 StorageType StorageAreaImpl::storageType() const
102 {
103     return m_storageType;
104 }
105 
106 unsigned StorageAreaImpl::length()
107 {
108     ASSERT(!m_isShutdown);
109     blockUntilImportComplete();
110 
</pre>
<hr />
<pre>
180     unsigned quota = m_storageMap-&gt;quota();
181     m_storageMap = StorageMap::create(quota);
182 
183     if (m_storageAreaSync)
184         m_storageAreaSync-&gt;scheduleClear();
185 
186     dispatchStorageEvent(String(), String(), String(), sourceFrame);
187 }
188 
189 bool StorageAreaImpl::contains(const String&amp; key)
190 {
191     ASSERT(!m_isShutdown);
192     blockUntilImportComplete();
193 
194     return m_storageMap-&gt;contains(key);
195 }
196 
197 void StorageAreaImpl::importItems(HashMap&lt;String, String&gt;&amp;&amp; items)
198 {
199     ASSERT(!m_isShutdown);

200 
201     m_storageMap-&gt;importItems(WTFMove(items));
202 }
203 
204 void StorageAreaImpl::close()
205 {
206     if (m_storageAreaSync)
207         m_storageAreaSync-&gt;scheduleFinalSync();
208 
<span class="line-modified">209 #ifndef NDEBUG</span>
210     m_isShutdown = true;
211 #endif
212 }
213 
214 void StorageAreaImpl::clearForOriginDeletion()
215 {
216     ASSERT(!m_isShutdown);
217     blockUntilImportComplete();
218 
219     if (m_storageMap-&gt;length()) {
220         unsigned quota = m_storageMap-&gt;quota();
221         m_storageMap = StorageMap::create(quota);
222     }
223 
224     if (m_storageAreaSync) {
225         m_storageAreaSync-&gt;scheduleClear();
226         m_storageAreaSync-&gt;scheduleCloseDatabase();
227     }
228 }
229 
</pre>
<hr />
<pre>
279     if (m_closeDatabaseTimer.isActive()) {
280         ASSERT(!m_accessCount);
281         m_closeDatabaseTimer.stop();
282 
283         closeDatabaseTimerFired();
284     }
285 }
286 
287 void StorageAreaImpl::dispatchStorageEvent(const String&amp; key, const String&amp; oldValue, const String&amp; newValue, Frame* sourceFrame)
288 {
289     if (isLocalStorage(m_storageType))
290         StorageEventDispatcher::dispatchLocalStorageEvents(key, oldValue, newValue, m_securityOrigin, sourceFrame);
291     else
292         StorageEventDispatcher::dispatchSessionStorageEvents(key, oldValue, newValue, m_securityOrigin, sourceFrame);
293 }
294 
295 void StorageAreaImpl::sessionChanged(bool isNewSessionPersistent)
296 {
297     ASSERT(isMainThread());
298 



299     unsigned quota = m_storageMap-&gt;quota();
300     m_storageMap = StorageMap::create(quota);
301 
302     if (isNewSessionPersistent &amp;&amp; !m_storageAreaSync &amp;&amp; m_storageSyncManager) {
303         m_storageAreaSync = StorageAreaSync::create(m_storageSyncManager.get(), *this, m_securityOrigin.databaseIdentifier());
304         return;
305     }
306 
307     if (!isNewSessionPersistent &amp;&amp; m_storageAreaSync) {
308         m_storageAreaSync-&gt;scheduleFinalSync();
309         m_storageAreaSync = nullptr;
310     }
311 }
312 
313 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 33 #include &lt;WebCore/SecurityOriginData.h&gt;
 34 #include &lt;WebCore/StorageEventDispatcher.h&gt;
 35 #include &lt;WebCore/StorageMap.h&gt;
 36 #include &lt;WebCore/StorageType.h&gt;
 37 #include &lt;wtf/MainThread.h&gt;
 38 
 39 using namespace WebCore;
 40 
 41 namespace WebKit {
 42 
 43 StorageAreaImpl::~StorageAreaImpl()
 44 {
 45     ASSERT(isMainThread());
 46 }
 47 
 48 inline StorageAreaImpl::StorageAreaImpl(StorageType storageType, const SecurityOriginData&amp; origin, RefPtr&lt;StorageSyncManager&gt;&amp;&amp; syncManager, unsigned quota)
 49     : m_storageType(storageType)
 50     , m_securityOrigin(origin)
 51     , m_storageMap(StorageMap::create(quota))
 52     , m_storageSyncManager(WTFMove(syncManager))



 53     , m_accessCount(0)
 54     , m_closeDatabaseTimer(*this, &amp;StorageAreaImpl::closeDatabaseTimerFired)
 55 {
 56     ASSERT(isMainThread());
 57     ASSERT(m_storageMap);
 58 
 59     // Accessing the shared global StorageTracker when a StorageArea is created
 60     // ensures that the tracker is properly initialized before anyone actually needs to use it.
 61     StorageTracker::tracker();
 62 }
 63 
 64 Ref&lt;StorageAreaImpl&gt; StorageAreaImpl::create(StorageType storageType, const SecurityOriginData&amp; origin, RefPtr&lt;StorageSyncManager&gt;&amp;&amp; syncManager, unsigned quota)
 65 {
 66     Ref&lt;StorageAreaImpl&gt; area = adoptRef(*new StorageAreaImpl(storageType, origin, WTFMove(syncManager), quota));
 67     // FIXME: If there&#39;s no backing storage for LocalStorage, the default WebKit behavior should be that of private browsing,
 68     // not silently ignoring it. https://bugs.webkit.org/show_bug.cgi?id=25894
 69     if (area-&gt;m_storageSyncManager) {
 70         area-&gt;m_storageAreaSync = StorageAreaSync::create(area-&gt;m_storageSyncManager.get(), area.copyRef(), area-&gt;m_securityOrigin.databaseIdentifier());
 71         ASSERT(area-&gt;m_storageAreaSync);
 72     }
 73     return area;
 74 }
 75 
 76 Ref&lt;StorageAreaImpl&gt; StorageAreaImpl::copy()
 77 {
 78     ASSERT(!m_isShutdown);
 79     return adoptRef(*new StorageAreaImpl(*this));
 80 }
 81 
 82 StorageAreaImpl::StorageAreaImpl(const StorageAreaImpl&amp; area)
 83     : m_storageType(area.m_storageType)
 84     , m_securityOrigin(area.m_securityOrigin)
 85     , m_storageMap(area.m_storageMap)
 86     , m_storageSyncManager(area.m_storageSyncManager)
<span class="line-modified"> 87 #if ASSERT_ENABLED</span>
 88     , m_isShutdown(area.m_isShutdown)
 89 #endif
 90     , m_accessCount(0)
 91     , m_closeDatabaseTimer(*this, &amp;StorageAreaImpl::closeDatabaseTimerFired)
 92 {
 93     ASSERT(isMainThread());
 94     ASSERT(m_storageMap);
 95     ASSERT(!m_isShutdown);
 96 }
 97 
 98 StorageType StorageAreaImpl::storageType() const
 99 {
100     return m_storageType;
101 }
102 
103 unsigned StorageAreaImpl::length()
104 {
105     ASSERT(!m_isShutdown);
106     blockUntilImportComplete();
107 
</pre>
<hr />
<pre>
177     unsigned quota = m_storageMap-&gt;quota();
178     m_storageMap = StorageMap::create(quota);
179 
180     if (m_storageAreaSync)
181         m_storageAreaSync-&gt;scheduleClear();
182 
183     dispatchStorageEvent(String(), String(), String(), sourceFrame);
184 }
185 
186 bool StorageAreaImpl::contains(const String&amp; key)
187 {
188     ASSERT(!m_isShutdown);
189     blockUntilImportComplete();
190 
191     return m_storageMap-&gt;contains(key);
192 }
193 
194 void StorageAreaImpl::importItems(HashMap&lt;String, String&gt;&amp;&amp; items)
195 {
196     ASSERT(!m_isShutdown);
<span class="line-added">197     ASSERT(!isMainThread());</span>
198 
199     m_storageMap-&gt;importItems(WTFMove(items));
200 }
201 
202 void StorageAreaImpl::close()
203 {
204     if (m_storageAreaSync)
205         m_storageAreaSync-&gt;scheduleFinalSync();
206 
<span class="line-modified">207 #if ASSERT_ENABLED</span>
208     m_isShutdown = true;
209 #endif
210 }
211 
212 void StorageAreaImpl::clearForOriginDeletion()
213 {
214     ASSERT(!m_isShutdown);
215     blockUntilImportComplete();
216 
217     if (m_storageMap-&gt;length()) {
218         unsigned quota = m_storageMap-&gt;quota();
219         m_storageMap = StorageMap::create(quota);
220     }
221 
222     if (m_storageAreaSync) {
223         m_storageAreaSync-&gt;scheduleClear();
224         m_storageAreaSync-&gt;scheduleCloseDatabase();
225     }
226 }
227 
</pre>
<hr />
<pre>
277     if (m_closeDatabaseTimer.isActive()) {
278         ASSERT(!m_accessCount);
279         m_closeDatabaseTimer.stop();
280 
281         closeDatabaseTimerFired();
282     }
283 }
284 
285 void StorageAreaImpl::dispatchStorageEvent(const String&amp; key, const String&amp; oldValue, const String&amp; newValue, Frame* sourceFrame)
286 {
287     if (isLocalStorage(m_storageType))
288         StorageEventDispatcher::dispatchLocalStorageEvents(key, oldValue, newValue, m_securityOrigin, sourceFrame);
289     else
290         StorageEventDispatcher::dispatchSessionStorageEvents(key, oldValue, newValue, m_securityOrigin, sourceFrame);
291 }
292 
293 void StorageAreaImpl::sessionChanged(bool isNewSessionPersistent)
294 {
295     ASSERT(isMainThread());
296 
<span class="line-added">297     // If import is not completed, background storage thread may be modifying m_storageMap.</span>
<span class="line-added">298     blockUntilImportComplete();</span>
<span class="line-added">299 </span>
300     unsigned quota = m_storageMap-&gt;quota();
301     m_storageMap = StorageMap::create(quota);
302 
303     if (isNewSessionPersistent &amp;&amp; !m_storageAreaSync &amp;&amp; m_storageSyncManager) {
304         m_storageAreaSync = StorageAreaSync::create(m_storageSyncManager.get(), *this, m_securityOrigin.databaseIdentifier());
305         return;
306     }
307 
308     if (!isNewSessionPersistent &amp;&amp; m_storageAreaSync) {
309         m_storageAreaSync-&gt;scheduleFinalSync();
310         m_storageAreaSync = nullptr;
311     }
312 }
313 
314 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="../PlatformJava.cmake.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StorageAreaImpl.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
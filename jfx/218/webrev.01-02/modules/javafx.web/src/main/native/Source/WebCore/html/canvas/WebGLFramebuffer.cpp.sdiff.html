<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLFramebuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebGLExtension.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLFramebuffer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLFramebuffer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebGLFramebuffer.h&quot;
 28 
 29 #if ENABLE(WEBGL)
 30 
<span class="line-modified"> 31 #include &quot;Extensions3D.h&quot;</span>
 32 #include &quot;WebGLContextGroup.h&quot;
 33 #include &quot;WebGLDrawBuffers.h&quot;
 34 #include &quot;WebGLRenderingContextBase.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 namespace {
 39 
 40     class WebGLRenderbufferAttachment : public WebGLFramebuffer::WebGLAttachment {
 41     public:
 42         static Ref&lt;WebGLFramebuffer::WebGLAttachment&gt; create(WebGLRenderbuffer*);
 43 
 44     private:
 45         WebGLRenderbufferAttachment(WebGLRenderbuffer*);
<span class="line-modified"> 46         GC3Dsizei getWidth() const override;</span>
<span class="line-modified"> 47         GC3Dsizei getHeight() const override;</span>
<span class="line-modified"> 48         GC3Denum getFormat() const override;</span>
 49         WebGLSharedObject* getObject() const override;
 50         bool isSharedObject(WebGLSharedObject*) const override;
 51         bool isValid() const override;
 52         bool isInitialized() const override;
 53         void setInitialized() override;
<span class="line-modified"> 54         void onDetached(GraphicsContext3D*) override;</span>
<span class="line-modified"> 55         void attach(GraphicsContext3D*, GC3Denum attachment) override;</span>
<span class="line-modified"> 56         void unattach(GraphicsContext3D*, GC3Denum attachment) override;</span>
 57 
 58         WebGLRenderbufferAttachment() { };
 59 
 60         RefPtr&lt;WebGLRenderbuffer&gt; m_renderbuffer;
 61     };
 62 
 63     Ref&lt;WebGLFramebuffer::WebGLAttachment&gt; WebGLRenderbufferAttachment::create(WebGLRenderbuffer* renderbuffer)
 64     {
 65         return adoptRef(*new WebGLRenderbufferAttachment(renderbuffer));
 66     }
 67 
 68     WebGLRenderbufferAttachment::WebGLRenderbufferAttachment(WebGLRenderbuffer* renderbuffer)
 69         : m_renderbuffer(renderbuffer)
 70     {
 71     }
 72 
<span class="line-modified"> 73     GC3Dsizei WebGLRenderbufferAttachment::getWidth() const</span>
 74     {
 75         return m_renderbuffer-&gt;getWidth();
 76     }
 77 
<span class="line-modified"> 78     GC3Dsizei WebGLRenderbufferAttachment::getHeight() const</span>
 79     {
 80         return m_renderbuffer-&gt;getHeight();
 81     }
 82 
<span class="line-modified"> 83     GC3Denum WebGLRenderbufferAttachment::getFormat() const</span>
 84     {
 85         return m_renderbuffer-&gt;getInternalFormat();
 86     }
 87 
 88     WebGLSharedObject* WebGLRenderbufferAttachment::getObject() const
 89     {
 90         return m_renderbuffer-&gt;object() ? m_renderbuffer.get() : 0;
 91     }
 92 
 93     bool WebGLRenderbufferAttachment::isSharedObject(WebGLSharedObject* object) const
 94     {
 95         return object == m_renderbuffer;
 96     }
 97 
 98     bool WebGLRenderbufferAttachment::isValid() const
 99     {
100         return m_renderbuffer-&gt;object();
101     }
102 
103     bool WebGLRenderbufferAttachment::isInitialized() const
104     {
105         return m_renderbuffer-&gt;object() &amp;&amp; m_renderbuffer-&gt;isInitialized();
106     }
107 
108     void WebGLRenderbufferAttachment::setInitialized()
109     {
110         if (m_renderbuffer-&gt;object())
111             m_renderbuffer-&gt;setInitialized();
112     }
113 
<span class="line-modified">114     void WebGLRenderbufferAttachment::onDetached(GraphicsContext3D* context)</span>
115     {
116         m_renderbuffer-&gt;onDetached(context);
117     }
118 
<span class="line-modified">119     void WebGLRenderbufferAttachment::attach(GraphicsContext3D* context, GC3Denum attachment)</span>
120     {
<span class="line-modified">121         Platform3DObject object = objectOrZero(m_renderbuffer.get());</span>
<span class="line-modified">122         context-&gt;framebufferRenderbuffer(GraphicsContext3D::FRAMEBUFFER, attachment, GraphicsContext3D::RENDERBUFFER, object);</span>
123     }
124 
<span class="line-modified">125     void WebGLRenderbufferAttachment::unattach(GraphicsContext3D* context, GC3Denum attachment)</span>
126     {
<span class="line-modified">127         if (attachment == GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT) {</span>
<span class="line-modified">128             context-&gt;framebufferRenderbuffer(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::DEPTH_ATTACHMENT, GraphicsContext3D::RENDERBUFFER, 0);</span>
<span class="line-modified">129             context-&gt;framebufferRenderbuffer(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::STENCIL_ATTACHMENT, GraphicsContext3D::RENDERBUFFER, 0);</span>

130         } else
<span class="line-modified">131             context-&gt;framebufferRenderbuffer(GraphicsContext3D::FRAMEBUFFER, attachment, GraphicsContext3D::RENDERBUFFER, 0);</span>

132     }
133 
134     class WebGLTextureAttachment : public WebGLFramebuffer::WebGLAttachment {
135     public:
<span class="line-modified">136         static Ref&lt;WebGLFramebuffer::WebGLAttachment&gt; create(WebGLTexture*, GC3Denum target, GC3Dint level);</span>
137 
138     private:
<span class="line-modified">139         WebGLTextureAttachment(WebGLTexture*, GC3Denum target, GC3Dint level);</span>
<span class="line-modified">140         GC3Dsizei getWidth() const override;</span>
<span class="line-modified">141         GC3Dsizei getHeight() const override;</span>
<span class="line-modified">142         GC3Denum getFormat() const override;</span>
143         WebGLSharedObject* getObject() const override;
144         bool isSharedObject(WebGLSharedObject*) const override;
145         bool isValid() const override;
146         bool isInitialized() const override;
147         void setInitialized() override;
<span class="line-modified">148         void onDetached(GraphicsContext3D*) override;</span>
<span class="line-modified">149         void attach(GraphicsContext3D*, GC3Denum attachment) override;</span>
<span class="line-modified">150         void unattach(GraphicsContext3D*, GC3Denum attachment) override;</span>
151 
152         WebGLTextureAttachment() { };
153 
154         RefPtr&lt;WebGLTexture&gt; m_texture;
<span class="line-modified">155         GC3Denum m_target;</span>
<span class="line-modified">156         GC3Dint m_level;</span>
157     };
158 
<span class="line-modified">159     Ref&lt;WebGLFramebuffer::WebGLAttachment&gt; WebGLTextureAttachment::create(WebGLTexture* texture, GC3Denum target, GC3Dint level)</span>
160     {
161         return adoptRef(*new WebGLTextureAttachment(texture, target, level));
162     }
163 
<span class="line-modified">164     WebGLTextureAttachment::WebGLTextureAttachment(WebGLTexture* texture, GC3Denum target, GC3Dint level)</span>
165         : m_texture(texture)
166         , m_target(target)
167         , m_level(level)
168     {
169     }
170 
<span class="line-modified">171     GC3Dsizei WebGLTextureAttachment::getWidth() const</span>
172     {
173         return m_texture-&gt;getWidth(m_target, m_level);
174     }
175 
<span class="line-modified">176     GC3Dsizei WebGLTextureAttachment::getHeight() const</span>
177     {
178         return m_texture-&gt;getHeight(m_target, m_level);
179     }
180 
<span class="line-modified">181     GC3Denum WebGLTextureAttachment::getFormat() const</span>
182     {
183         return m_texture-&gt;getInternalFormat(m_target, m_level);
184     }
185 
186     WebGLSharedObject* WebGLTextureAttachment::getObject() const
187     {
188         return m_texture-&gt;object() ? m_texture.get() : 0;
189     }
190 
191     bool WebGLTextureAttachment::isSharedObject(WebGLSharedObject* object) const
192     {
193         return object == m_texture;
194     }
195 
196     bool WebGLTextureAttachment::isValid() const
197     {
198         return m_texture-&gt;object();
199     }
200 
201     bool WebGLTextureAttachment::isInitialized() const
202     {
203         // Textures are assumed to be initialized.
204         return true;
205     }
206 
207     void WebGLTextureAttachment::setInitialized()
208     {
209         // Textures are assumed to be initialized.
210     }
211 
<span class="line-modified">212     void WebGLTextureAttachment::onDetached(GraphicsContext3D* context)</span>
213     {
214         m_texture-&gt;onDetached(context);
215     }
216 
<span class="line-modified">217     void WebGLTextureAttachment::attach(GraphicsContext3D* context, GC3Denum attachment)</span>
218     {
<span class="line-modified">219         Platform3DObject object = objectOrZero(m_texture.get());</span>
<span class="line-modified">220         context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, attachment, m_target, object, m_level);</span>
221     }
222 
<span class="line-modified">223     void WebGLTextureAttachment::unattach(GraphicsContext3D* context, GC3Denum attachment)</span>
224     {
<span class="line-modified">225         if (attachment == GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT) {</span>
<span class="line-modified">226             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::DEPTH_ATTACHMENT, m_target, 0, m_level);</span>
<span class="line-modified">227             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, GraphicsContext3D::STENCIL_ATTACHMENT, m_target, 0, m_level);</span>

228         } else
<span class="line-modified">229             context-&gt;framebufferTexture2D(GraphicsContext3D::FRAMEBUFFER, attachment, m_target, 0, m_level);</span>

230     }
231 
<span class="line-modified">232     bool isAttachmentComplete(WebGLFramebuffer::WebGLAttachment* attachedObject, GC3Denum attachment, const char** reason)</span>
233     {
234         ASSERT(attachedObject &amp;&amp; attachedObject-&gt;isValid());
235         ASSERT(reason);
<span class="line-modified">236         GC3Denum format = attachedObject-&gt;getFormat();</span>
<span class="line-modified">237         unsigned need = GraphicsContext3D::getClearBitsByAttachmentType(attachment);</span>
<span class="line-modified">238         unsigned have = GraphicsContext3D::getClearBitsByFormat(format);</span>
239 
240         if ((need &amp; have) != need) {
241             *reason = &quot;attachment type is not correct for attachment&quot;;
242             return false;
243         }
244         if (!attachedObject-&gt;getWidth() || !attachedObject-&gt;getHeight()) {
245             *reason = &quot;attachment has a 0 dimension&quot;;
246             return false;
247         }
<span class="line-modified">248         if ((attachment == GraphicsContext3D::DEPTH_ATTACHMENT || attachment == GraphicsContext3D::STENCIL_ATTACHMENT)</span>
<span class="line-modified">249             &amp;&amp; format == GraphicsContext3D::DEPTH_STENCIL) {</span>
250           *reason = &quot;attachment DEPTH_STENCIL not allowed on DEPTH or STENCIL attachment&quot;;
251           return false;
252         }
253         return true;
254     }
255 
256 } // anonymous namespace
257 
258 WebGLFramebuffer::WebGLAttachment::WebGLAttachment() = default;
259 
260 WebGLFramebuffer::WebGLAttachment::~WebGLAttachment() = default;
261 
262 Ref&lt;WebGLFramebuffer&gt; WebGLFramebuffer::create(WebGLRenderingContextBase&amp; ctx)
263 {
264     return adoptRef(*new WebGLFramebuffer(ctx));
265 }
266 
267 WebGLFramebuffer::WebGLFramebuffer(WebGLRenderingContextBase&amp; ctx)
268     : WebGLContextObject(ctx)
269     , m_hasEverBeenBound(false)
270 {
<span class="line-modified">271     setObject(ctx.graphicsContext3D()-&gt;createFramebuffer());</span>
272 }
273 
274 WebGLFramebuffer::~WebGLFramebuffer()
275 {
276     deleteObject(0);
277 }
278 
<span class="line-modified">279 void WebGLFramebuffer::setAttachmentForBoundFramebuffer(GC3Denum attachment, GC3Denum texTarget, WebGLTexture* texture, GC3Dint level)</span>
280 {
281     ASSERT(isBound());
282     removeAttachmentFromBoundFramebuffer(attachment);
283     if (!object())
284         return;
285     if (texture &amp;&amp; texture-&gt;object()) {
286         m_attachments.add(attachment, WebGLTextureAttachment::create(texture, texTarget, level));
287         drawBuffersIfNecessary(false);
288         texture-&gt;onAttached();
289     }
290 }
291 
<span class="line-modified">292 void WebGLFramebuffer::setAttachmentForBoundFramebuffer(GC3Denum attachment, WebGLRenderbuffer* renderbuffer)</span>
293 {
294     ASSERT(isBound());
295     removeAttachmentFromBoundFramebuffer(attachment);
296     if (!object())
297         return;
298     if (renderbuffer &amp;&amp; renderbuffer-&gt;object()) {
299         m_attachments.add(attachment, WebGLRenderbufferAttachment::create(renderbuffer));
300         drawBuffersIfNecessary(false);
301         renderbuffer-&gt;onAttached();
302     }
303 }
304 
<span class="line-modified">305 void WebGLFramebuffer::attach(GC3Denum attachment, GC3Denum attachmentPoint)</span>
306 {
307     ASSERT(isBound());
308     RefPtr&lt;WebGLAttachment&gt; attachmentObject = getAttachment(attachment);
309     if (attachmentObject)
<span class="line-modified">310         attachmentObject-&gt;attach(context()-&gt;graphicsContext3D(), attachmentPoint);</span>
311 }
312 
<span class="line-modified">313 WebGLSharedObject* WebGLFramebuffer::getAttachmentObject(GC3Denum attachment) const</span>
314 {
315     if (!object())
316         return 0;
317     RefPtr&lt;WebGLAttachment&gt; attachmentObject = getAttachment(attachment);
318     return attachmentObject ? attachmentObject-&gt;getObject() : 0;
319 }
320 
<span class="line-modified">321 WebGLFramebuffer::WebGLAttachment* WebGLFramebuffer::getAttachment(GC3Denum attachment) const</span>
322 {
323     const AttachmentMap::const_iterator it = m_attachments.find(attachment);
324     return (it != m_attachments.end()) ? it-&gt;value.get() : 0;
325 }
326 
<span class="line-modified">327 void WebGLFramebuffer::removeAttachmentFromBoundFramebuffer(GC3Denum attachment)</span>
328 {
329     ASSERT(isBound());
330     if (!object())
331         return;
332 
333     RefPtr&lt;WebGLAttachment&gt; attachmentObject = getAttachment(attachment);
334     if (attachmentObject) {
<span class="line-modified">335         attachmentObject-&gt;onDetached(context()-&gt;graphicsContext3D());</span>
336         m_attachments.remove(attachment);
337         drawBuffersIfNecessary(false);

338         switch (attachment) {
<span class="line-modified">339         case GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT:</span>
<span class="line-modified">340             attach(GraphicsContext3D::DEPTH_ATTACHMENT, GraphicsContext3D::DEPTH_ATTACHMENT);</span>
<span class="line-modified">341             attach(GraphicsContext3D::STENCIL_ATTACHMENT, GraphicsContext3D::STENCIL_ATTACHMENT);</span>
342             break;
<span class="line-modified">343         case GraphicsContext3D::DEPTH_ATTACHMENT:</span>
<span class="line-modified">344             attach(GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT, GraphicsContext3D::DEPTH_ATTACHMENT);</span>
345             break;
<span class="line-modified">346         case GraphicsContext3D::STENCIL_ATTACHMENT:</span>
<span class="line-modified">347             attach(GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT, GraphicsContext3D::STENCIL_ATTACHMENT);</span>
348             break;
349         }

350     }
351 }
352 
353 void WebGLFramebuffer::removeAttachmentFromBoundFramebuffer(WebGLSharedObject* attachment)
354 {
355     ASSERT(isBound());
356     if (!object())
357         return;
358     if (!attachment)
359         return;
360 
361     bool checkMore = true;
362     do {
363         checkMore = false;
364         for (auto&amp; entry : m_attachments) {
365             RefPtr&lt;WebGLAttachment&gt; attachmentObject = entry.value.get();
366             if (attachmentObject-&gt;isSharedObject(attachment)) {
<span class="line-modified">367                 GC3Denum attachmentType = entry.key;</span>
<span class="line-modified">368                 attachmentObject-&gt;unattach(context()-&gt;graphicsContext3D(), attachmentType);</span>
369                 removeAttachmentFromBoundFramebuffer(attachmentType);
370                 checkMore = true;
371                 break;
372             }
373         }
374     } while (checkMore);
375 }
376 
<span class="line-modified">377 GC3Dsizei WebGLFramebuffer::getColorBufferWidth() const</span>
378 {
379     if (!object())
380         return 0;
<span class="line-modified">381     RefPtr&lt;WebGLAttachment&gt; attachment = getAttachment(GraphicsContext3D::COLOR_ATTACHMENT0);</span>
382     if (!attachment)
383         return 0;
384 
385     return attachment-&gt;getWidth();
386 }
387 
<span class="line-modified">388 GC3Dsizei WebGLFramebuffer::getColorBufferHeight() const</span>
389 {
390     if (!object())
391         return 0;
<span class="line-modified">392     RefPtr&lt;WebGLAttachment&gt; attachment = getAttachment(GraphicsContext3D::COLOR_ATTACHMENT0);</span>
393     if (!attachment)
394         return 0;
395 
396     return attachment-&gt;getHeight();
397 }
398 
<span class="line-modified">399 GC3Denum WebGLFramebuffer::getColorBufferFormat() const</span>
400 {
401     if (!object())
402         return 0;
<span class="line-modified">403     RefPtr&lt;WebGLAttachment&gt; attachment = getAttachment(GraphicsContext3D::COLOR_ATTACHMENT0);</span>
404     if (!attachment)
405         return 0;
406     return attachment-&gt;getFormat();
407 }
408 
<span class="line-modified">409 GC3Denum WebGLFramebuffer::checkStatus(const char** reason) const</span>
410 {
411     unsigned int count = 0;
<span class="line-modified">412     GC3Dsizei width = 0, height = 0;</span>
413     bool haveDepth = false;
414     bool haveStencil = false;
415     bool haveDepthStencil = false;
416     for (auto&amp; entry : m_attachments) {
417         RefPtr&lt;WebGLAttachment&gt; attachment = entry.value.get();
418         if (!isAttachmentComplete(attachment.get(), entry.key, reason))
<span class="line-modified">419             return GraphicsContext3D::FRAMEBUFFER_INCOMPLETE_ATTACHMENT;</span>
420         if (!attachment-&gt;isValid()) {
421             *reason = &quot;attachment is not valid&quot;;
<span class="line-modified">422             return GraphicsContext3D::FRAMEBUFFER_UNSUPPORTED;</span>
423         }
<span class="line-modified">424         GC3Denum attachmentFormat = attachment-&gt;getFormat();</span>
425 
426         // Attaching an SRGB_EXT format attachment to a framebuffer is invalid.
<span class="line-modified">427         if (attachmentFormat == Extensions3D::SRGB_EXT)</span>
428             attachmentFormat = 0;
429 
430         if (!attachmentFormat) {
431             *reason = &quot;attachment is an unsupported format&quot;;
<span class="line-modified">432             return GraphicsContext3D::FRAMEBUFFER_INCOMPLETE_ATTACHMENT;</span>
433         }
434         switch (entry.key) {
<span class="line-modified">435         case GraphicsContext3D::DEPTH_ATTACHMENT:</span>
436             haveDepth = true;
437             break;
<span class="line-modified">438         case GraphicsContext3D::STENCIL_ATTACHMENT:</span>
439             haveStencil = true;
440             break;
<span class="line-modified">441         case GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT:</span>
442             haveDepthStencil = true;
443             break;
444         }
445         if (!count) {
446             width = attachment-&gt;getWidth();
447             height = attachment-&gt;getHeight();
448         } else {
449             if (width != attachment-&gt;getWidth() || height != attachment-&gt;getHeight()) {
450                 *reason = &quot;attachments do not have the same dimensions&quot;;
<span class="line-modified">451                 return GraphicsContext3D::FRAMEBUFFER_INCOMPLETE_DIMENSIONS;</span>
452             }
453         }
454         ++count;
455     }
456     if (!count) {
457         *reason = &quot;no attachments&quot;;
<span class="line-modified">458         return GraphicsContext3D::FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;</span>
459     }
460     if (!width || !height) {
461         *reason = &quot;framebuffer has a 0 dimension&quot;;
<span class="line-modified">462         return GraphicsContext3D::FRAMEBUFFER_INCOMPLETE_ATTACHMENT;</span>
463     }
464     // WebGL specific: no conflicting DEPTH/STENCIL/DEPTH_STENCIL attachments.
465     if ((haveDepthStencil &amp;&amp; (haveDepth || haveStencil)) || (haveDepth &amp;&amp; haveStencil)) {
466         *reason = &quot;conflicting DEPTH/STENCIL/DEPTH_STENCIL attachments&quot;;
<span class="line-modified">467         return GraphicsContext3D::FRAMEBUFFER_UNSUPPORTED;</span>
468     }
<span class="line-modified">469     return GraphicsContext3D::FRAMEBUFFER_COMPLETE;</span>
470 }
471 
<span class="line-modified">472 bool WebGLFramebuffer::onAccess(GraphicsContext3D* context3d, const char** reason)</span>
473 {
<span class="line-modified">474     if (checkStatus(reason) != GraphicsContext3D::FRAMEBUFFER_COMPLETE)</span>
475         return false;
476     return initializeAttachments(context3d, reason);
477 }
478 
479 bool WebGLFramebuffer::hasStencilBuffer() const
480 {
<span class="line-modified">481     RefPtr&lt;WebGLAttachment&gt; attachment = getAttachment(GraphicsContext3D::STENCIL_ATTACHMENT);</span>
482     if (!attachment)
<span class="line-modified">483         attachment = getAttachment(GraphicsContext3D::DEPTH_STENCIL_ATTACHMENT);</span>
484     return attachment &amp;&amp; attachment-&gt;isValid();
485 }
486 
<span class="line-modified">487 void WebGLFramebuffer::deleteObjectImpl(GraphicsContext3D* context3d, Platform3DObject object)</span>
488 {
489     for (auto&amp; attachment : m_attachments.values())
490         attachment-&gt;onDetached(context3d);
491 
492     context3d-&gt;deleteFramebuffer(object);
493 }
494 
<span class="line-modified">495 bool WebGLFramebuffer::initializeAttachments(GraphicsContext3D* g3d, const char** reason)</span>
496 {
497     ASSERT(object());
<span class="line-modified">498     GC3Dbitfield mask = 0;</span>
499 
500     for (auto&amp; entry : m_attachments) {
<span class="line-modified">501         GC3Denum attachmentType = entry.key;</span>
502         RefPtr&lt;WebGLAttachment&gt; attachment = entry.value.get();
503         if (!attachment-&gt;isInitialized())
<span class="line-modified">504            mask |= GraphicsContext3D::getClearBitsByAttachmentType(attachmentType);</span>
505     }
506     if (!mask)
507         return true;
508 
509     // We only clear un-initialized renderbuffers when they are ready to be
510     // read, i.e., when the framebuffer is complete.
<span class="line-modified">511     if (g3d-&gt;checkFramebufferStatus(GraphicsContext3D::FRAMEBUFFER) != GraphicsContext3D::FRAMEBUFFER_COMPLETE) {</span>
512         *reason = &quot;framebuffer not complete&quot;;
513         return false;
514     }
515 
<span class="line-modified">516     bool initColor = mask &amp; GraphicsContext3D::COLOR_BUFFER_BIT;</span>
<span class="line-modified">517     bool initDepth = mask &amp; GraphicsContext3D::DEPTH_BUFFER_BIT;</span>
<span class="line-modified">518     bool initStencil = mask &amp; GraphicsContext3D::STENCIL_BUFFER_BIT;</span>
519 
<span class="line-modified">520     GC3Dfloat colorClearValue[] = {0, 0, 0, 0}, depthClearValue = 0;</span>
<span class="line-modified">521     GC3Dint stencilClearValue = 0;</span>
<span class="line-modified">522     GC3Dboolean colorMask[] = {0, 0, 0, 0}, depthMask = 0;</span>
<span class="line-modified">523     GC3Duint stencilMask = 0xffffffff;</span>
<span class="line-modified">524     GC3Dboolean isScissorEnabled = 0;</span>
<span class="line-modified">525     GC3Dboolean isDitherEnabled = 0;</span>
526     if (initColor) {
<span class="line-modified">527         g3d-&gt;getFloatv(GraphicsContext3D::COLOR_CLEAR_VALUE, colorClearValue);</span>
<span class="line-modified">528         g3d-&gt;getBooleanv(GraphicsContext3D::COLOR_WRITEMASK, colorMask);</span>
529         g3d-&gt;clearColor(0, 0, 0, 0);
530         g3d-&gt;colorMask(true, true, true, true);
531     }
532     if (initDepth) {
<span class="line-modified">533         g3d-&gt;getFloatv(GraphicsContext3D::DEPTH_CLEAR_VALUE, &amp;depthClearValue);</span>
<span class="line-modified">534         g3d-&gt;getBooleanv(GraphicsContext3D::DEPTH_WRITEMASK, &amp;depthMask);</span>
535         g3d-&gt;clearDepth(1.0f);
536         g3d-&gt;depthMask(true);
537     }
538     if (initStencil) {
<span class="line-modified">539         g3d-&gt;getIntegerv(GraphicsContext3D::STENCIL_CLEAR_VALUE, &amp;stencilClearValue);</span>
<span class="line-modified">540         g3d-&gt;getIntegerv(GraphicsContext3D::STENCIL_WRITEMASK, reinterpret_cast&lt;GC3Dint*&gt;(&amp;stencilMask));</span>
541         g3d-&gt;clearStencil(0);
542         g3d-&gt;stencilMask(0xffffffff);
543     }
<span class="line-modified">544     isScissorEnabled = g3d-&gt;isEnabled(GraphicsContext3D::SCISSOR_TEST);</span>
<span class="line-modified">545     g3d-&gt;disable(GraphicsContext3D::SCISSOR_TEST);</span>
<span class="line-modified">546     isDitherEnabled = g3d-&gt;isEnabled(GraphicsContext3D::DITHER);</span>
<span class="line-modified">547     g3d-&gt;disable(GraphicsContext3D::DITHER);</span>
548 
549     g3d-&gt;clear(mask);
550 
551     if (initColor) {
552         g3d-&gt;clearColor(colorClearValue[0], colorClearValue[1], colorClearValue[2], colorClearValue[3]);
553         g3d-&gt;colorMask(colorMask[0], colorMask[1], colorMask[2], colorMask[3]);
554     }
555     if (initDepth) {
556         g3d-&gt;clearDepth(depthClearValue);
557         g3d-&gt;depthMask(depthMask);
558     }
559     if (initStencil) {
560         g3d-&gt;clearStencil(stencilClearValue);
561         g3d-&gt;stencilMask(stencilMask);
562     }
563     if (isScissorEnabled)
<span class="line-modified">564         g3d-&gt;enable(GraphicsContext3D::SCISSOR_TEST);</span>
565     else
<span class="line-modified">566         g3d-&gt;disable(GraphicsContext3D::SCISSOR_TEST);</span>
567     if (isDitherEnabled)
<span class="line-modified">568         g3d-&gt;enable(GraphicsContext3D::DITHER);</span>
569     else
<span class="line-modified">570         g3d-&gt;disable(GraphicsContext3D::DITHER);</span>
571 
572     for (AttachmentMap::iterator it = m_attachments.begin(); it != m_attachments.end(); ++it) {
<span class="line-modified">573         GC3Denum attachmentType = it-&gt;key;</span>
574         auto attachment = it-&gt;value;
<span class="line-modified">575         GC3Dbitfield bits = GraphicsContext3D::getClearBitsByAttachmentType(attachmentType);</span>
576         if (bits &amp; mask)
577             attachment-&gt;setInitialized();
578     }
579     return true;
580 }
581 
582 bool WebGLFramebuffer::isBound() const
583 {
584     return (context()-&gt;m_framebufferBinding.get() == this) || (context()-&gt;m_readFramebufferBinding.get() == this);
585 }
586 
<span class="line-modified">587 void WebGLFramebuffer::drawBuffers(const Vector&lt;GC3Denum&gt;&amp; bufs)</span>
588 {
589     m_drawBuffers = bufs;
590     m_filteredDrawBuffers.resize(m_drawBuffers.size());
591     for (auto&amp; buffer : m_filteredDrawBuffers)
<span class="line-modified">592         buffer = GraphicsContext3D::NONE;</span>
593     drawBuffersIfNecessary(true);
594 }
595 
596 void WebGLFramebuffer::drawBuffersIfNecessary(bool force)
597 {
598 #if ENABLE(WEBGL2)
599     // FIXME: The logic here seems wrong. If we don&#39;t have WebGL 2 enabled at all, then
600     // we skip the m_webglDrawBuffers check. But if we do have WebGL 2 enabled, then we
601     // perform this check, for WebGL 1 contexts only.
602     if (!context()-&gt;m_webglDrawBuffers &amp;&amp; !context()-&gt;isWebGL2())
603         return;
604 #endif
605     bool reset = force;
606     // This filtering works around graphics driver bugs on Mac OS X.
607     for (size_t i = 0; i &lt; m_drawBuffers.size(); ++i) {
<span class="line-modified">608         if (m_drawBuffers[i] != GraphicsContext3D::NONE &amp;&amp; getAttachment(m_drawBuffers[i])) {</span>
609             if (m_filteredDrawBuffers[i] != m_drawBuffers[i]) {
610                 m_filteredDrawBuffers[i] = m_drawBuffers[i];
611                 reset = true;
612             }
613         } else {
<span class="line-modified">614             if (m_filteredDrawBuffers[i] != GraphicsContext3D::NONE) {</span>
<span class="line-modified">615                 m_filteredDrawBuffers[i] = GraphicsContext3D::NONE;</span>
616                 reset = true;
617             }
618         }
619     }
620     if (reset) {
<span class="line-modified">621         context()-&gt;graphicsContext3D()-&gt;getExtensions().drawBuffersEXT(</span>
622             m_filteredDrawBuffers.size(), m_filteredDrawBuffers.data());
623     }
624 }
625 
<span class="line-modified">626 GC3Denum WebGLFramebuffer::getDrawBuffer(GC3Denum drawBuffer)</span>
627 {
<span class="line-modified">628     int index = static_cast&lt;int&gt;(drawBuffer - Extensions3D::DRAW_BUFFER0_EXT);</span>
629     ASSERT(index &gt;= 0);
630     if (index &lt; static_cast&lt;int&gt;(m_drawBuffers.size()))
631         return m_drawBuffers[index];
<span class="line-modified">632     if (drawBuffer == Extensions3D::DRAW_BUFFER0_EXT)</span>
<span class="line-modified">633         return GraphicsContext3D::COLOR_ATTACHMENT0;</span>
<span class="line-modified">634     return GraphicsContext3D::NONE;</span>
635 }
636 
637 }
638 
639 #endif // ENABLE(WEBGL)
</pre>
</td>
<td>
<hr />
<pre>
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebGLFramebuffer.h&quot;
 28 
 29 #if ENABLE(WEBGL)
 30 
<span class="line-modified"> 31 #include &quot;ExtensionsGL.h&quot;</span>
 32 #include &quot;WebGLContextGroup.h&quot;
 33 #include &quot;WebGLDrawBuffers.h&quot;
 34 #include &quot;WebGLRenderingContextBase.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 namespace {
 39 
 40     class WebGLRenderbufferAttachment : public WebGLFramebuffer::WebGLAttachment {
 41     public:
 42         static Ref&lt;WebGLFramebuffer::WebGLAttachment&gt; create(WebGLRenderbuffer*);
 43 
 44     private:
 45         WebGLRenderbufferAttachment(WebGLRenderbuffer*);
<span class="line-modified"> 46         GCGLsizei getWidth() const override;</span>
<span class="line-modified"> 47         GCGLsizei getHeight() const override;</span>
<span class="line-modified"> 48         GCGLenum getFormat() const override;</span>
 49         WebGLSharedObject* getObject() const override;
 50         bool isSharedObject(WebGLSharedObject*) const override;
 51         bool isValid() const override;
 52         bool isInitialized() const override;
 53         void setInitialized() override;
<span class="line-modified"> 54         void onDetached(GraphicsContextGLOpenGL*) override;</span>
<span class="line-modified"> 55         void attach(GraphicsContextGLOpenGL*, GCGLenum attachment) override;</span>
<span class="line-modified"> 56         void unattach(GraphicsContextGLOpenGL*, GCGLenum attachment) override;</span>
 57 
 58         WebGLRenderbufferAttachment() { };
 59 
 60         RefPtr&lt;WebGLRenderbuffer&gt; m_renderbuffer;
 61     };
 62 
 63     Ref&lt;WebGLFramebuffer::WebGLAttachment&gt; WebGLRenderbufferAttachment::create(WebGLRenderbuffer* renderbuffer)
 64     {
 65         return adoptRef(*new WebGLRenderbufferAttachment(renderbuffer));
 66     }
 67 
 68     WebGLRenderbufferAttachment::WebGLRenderbufferAttachment(WebGLRenderbuffer* renderbuffer)
 69         : m_renderbuffer(renderbuffer)
 70     {
 71     }
 72 
<span class="line-modified"> 73     GCGLsizei WebGLRenderbufferAttachment::getWidth() const</span>
 74     {
 75         return m_renderbuffer-&gt;getWidth();
 76     }
 77 
<span class="line-modified"> 78     GCGLsizei WebGLRenderbufferAttachment::getHeight() const</span>
 79     {
 80         return m_renderbuffer-&gt;getHeight();
 81     }
 82 
<span class="line-modified"> 83     GCGLenum WebGLRenderbufferAttachment::getFormat() const</span>
 84     {
 85         return m_renderbuffer-&gt;getInternalFormat();
 86     }
 87 
 88     WebGLSharedObject* WebGLRenderbufferAttachment::getObject() const
 89     {
 90         return m_renderbuffer-&gt;object() ? m_renderbuffer.get() : 0;
 91     }
 92 
 93     bool WebGLRenderbufferAttachment::isSharedObject(WebGLSharedObject* object) const
 94     {
 95         return object == m_renderbuffer;
 96     }
 97 
 98     bool WebGLRenderbufferAttachment::isValid() const
 99     {
100         return m_renderbuffer-&gt;object();
101     }
102 
103     bool WebGLRenderbufferAttachment::isInitialized() const
104     {
105         return m_renderbuffer-&gt;object() &amp;&amp; m_renderbuffer-&gt;isInitialized();
106     }
107 
108     void WebGLRenderbufferAttachment::setInitialized()
109     {
110         if (m_renderbuffer-&gt;object())
111             m_renderbuffer-&gt;setInitialized();
112     }
113 
<span class="line-modified">114     void WebGLRenderbufferAttachment::onDetached(GraphicsContextGLOpenGL* context)</span>
115     {
116         m_renderbuffer-&gt;onDetached(context);
117     }
118 
<span class="line-modified">119     void WebGLRenderbufferAttachment::attach(GraphicsContextGLOpenGL* context, GCGLenum attachment)</span>
120     {
<span class="line-modified">121         PlatformGLObject object = objectOrZero(m_renderbuffer.get());</span>
<span class="line-modified">122         context-&gt;framebufferRenderbuffer(GraphicsContextGL::FRAMEBUFFER, attachment, GraphicsContextGL::RENDERBUFFER, object);</span>
123     }
124 
<span class="line-modified">125     void WebGLRenderbufferAttachment::unattach(GraphicsContextGLOpenGL* context, GCGLenum attachment)</span>
126     {
<span class="line-modified">127 #if !USE(ANGLE)</span>
<span class="line-modified">128         if (attachment == GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT) {</span>
<span class="line-modified">129             context-&gt;framebufferRenderbuffer(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::DEPTH_ATTACHMENT, GraphicsContextGL::RENDERBUFFER, 0);</span>
<span class="line-added">130             context-&gt;framebufferRenderbuffer(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::STENCIL_ATTACHMENT, GraphicsContextGL::RENDERBUFFER, 0);</span>
131         } else
<span class="line-modified">132 #endif</span>
<span class="line-added">133             context-&gt;framebufferRenderbuffer(GraphicsContextGL::FRAMEBUFFER, attachment, GraphicsContextGL::RENDERBUFFER, 0);</span>
134     }
135 
136     class WebGLTextureAttachment : public WebGLFramebuffer::WebGLAttachment {
137     public:
<span class="line-modified">138         static Ref&lt;WebGLFramebuffer::WebGLAttachment&gt; create(WebGLTexture*, GCGLenum target, GCGLint level);</span>
139 
140     private:
<span class="line-modified">141         WebGLTextureAttachment(WebGLTexture*, GCGLenum target, GCGLint level);</span>
<span class="line-modified">142         GCGLsizei getWidth() const override;</span>
<span class="line-modified">143         GCGLsizei getHeight() const override;</span>
<span class="line-modified">144         GCGLenum getFormat() const override;</span>
145         WebGLSharedObject* getObject() const override;
146         bool isSharedObject(WebGLSharedObject*) const override;
147         bool isValid() const override;
148         bool isInitialized() const override;
149         void setInitialized() override;
<span class="line-modified">150         void onDetached(GraphicsContextGLOpenGL*) override;</span>
<span class="line-modified">151         void attach(GraphicsContextGLOpenGL*, GCGLenum attachment) override;</span>
<span class="line-modified">152         void unattach(GraphicsContextGLOpenGL*, GCGLenum attachment) override;</span>
153 
154         WebGLTextureAttachment() { };
155 
156         RefPtr&lt;WebGLTexture&gt; m_texture;
<span class="line-modified">157         GCGLenum m_target;</span>
<span class="line-modified">158         GCGLint m_level;</span>
159     };
160 
<span class="line-modified">161     Ref&lt;WebGLFramebuffer::WebGLAttachment&gt; WebGLTextureAttachment::create(WebGLTexture* texture, GCGLenum target, GCGLint level)</span>
162     {
163         return adoptRef(*new WebGLTextureAttachment(texture, target, level));
164     }
165 
<span class="line-modified">166     WebGLTextureAttachment::WebGLTextureAttachment(WebGLTexture* texture, GCGLenum target, GCGLint level)</span>
167         : m_texture(texture)
168         , m_target(target)
169         , m_level(level)
170     {
171     }
172 
<span class="line-modified">173     GCGLsizei WebGLTextureAttachment::getWidth() const</span>
174     {
175         return m_texture-&gt;getWidth(m_target, m_level);
176     }
177 
<span class="line-modified">178     GCGLsizei WebGLTextureAttachment::getHeight() const</span>
179     {
180         return m_texture-&gt;getHeight(m_target, m_level);
181     }
182 
<span class="line-modified">183     GCGLenum WebGLTextureAttachment::getFormat() const</span>
184     {
185         return m_texture-&gt;getInternalFormat(m_target, m_level);
186     }
187 
188     WebGLSharedObject* WebGLTextureAttachment::getObject() const
189     {
190         return m_texture-&gt;object() ? m_texture.get() : 0;
191     }
192 
193     bool WebGLTextureAttachment::isSharedObject(WebGLSharedObject* object) const
194     {
195         return object == m_texture;
196     }
197 
198     bool WebGLTextureAttachment::isValid() const
199     {
200         return m_texture-&gt;object();
201     }
202 
203     bool WebGLTextureAttachment::isInitialized() const
204     {
205         // Textures are assumed to be initialized.
206         return true;
207     }
208 
209     void WebGLTextureAttachment::setInitialized()
210     {
211         // Textures are assumed to be initialized.
212     }
213 
<span class="line-modified">214     void WebGLTextureAttachment::onDetached(GraphicsContextGLOpenGL* context)</span>
215     {
216         m_texture-&gt;onDetached(context);
217     }
218 
<span class="line-modified">219     void WebGLTextureAttachment::attach(GraphicsContextGLOpenGL* context, GCGLenum attachment)</span>
220     {
<span class="line-modified">221         PlatformGLObject object = objectOrZero(m_texture.get());</span>
<span class="line-modified">222         context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, attachment, m_target, object, m_level);</span>
223     }
224 
<span class="line-modified">225     void WebGLTextureAttachment::unattach(GraphicsContextGLOpenGL* context, GCGLenum attachment)</span>
226     {
<span class="line-modified">227 #if !USE(ANGLE)</span>
<span class="line-modified">228         if (attachment == GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT) {</span>
<span class="line-modified">229             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::DEPTH_ATTACHMENT, m_target, 0, m_level);</span>
<span class="line-added">230             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::STENCIL_ATTACHMENT, m_target, 0, m_level);</span>
231         } else
<span class="line-modified">232 #endif</span>
<span class="line-added">233             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, attachment, m_target, 0, m_level);</span>
234     }
235 
<span class="line-modified">236     bool isAttachmentComplete(WebGLFramebuffer::WebGLAttachment* attachedObject, GCGLenum attachment, const char** reason)</span>
237     {
238         ASSERT(attachedObject &amp;&amp; attachedObject-&gt;isValid());
239         ASSERT(reason);
<span class="line-modified">240         GCGLenum format = attachedObject-&gt;getFormat();</span>
<span class="line-modified">241         unsigned need = GraphicsContextGLOpenGL::getClearBitsByAttachmentType(attachment);</span>
<span class="line-modified">242         unsigned have = GraphicsContextGLOpenGL::getClearBitsByFormat(format);</span>
243 
244         if ((need &amp; have) != need) {
245             *reason = &quot;attachment type is not correct for attachment&quot;;
246             return false;
247         }
248         if (!attachedObject-&gt;getWidth() || !attachedObject-&gt;getHeight()) {
249             *reason = &quot;attachment has a 0 dimension&quot;;
250             return false;
251         }
<span class="line-modified">252         if ((attachment == GraphicsContextGL::DEPTH_ATTACHMENT || attachment == GraphicsContextGL::STENCIL_ATTACHMENT)</span>
<span class="line-modified">253             &amp;&amp; format == GraphicsContextGL::DEPTH_STENCIL) {</span>
254           *reason = &quot;attachment DEPTH_STENCIL not allowed on DEPTH or STENCIL attachment&quot;;
255           return false;
256         }
257         return true;
258     }
259 
260 } // anonymous namespace
261 
262 WebGLFramebuffer::WebGLAttachment::WebGLAttachment() = default;
263 
264 WebGLFramebuffer::WebGLAttachment::~WebGLAttachment() = default;
265 
266 Ref&lt;WebGLFramebuffer&gt; WebGLFramebuffer::create(WebGLRenderingContextBase&amp; ctx)
267 {
268     return adoptRef(*new WebGLFramebuffer(ctx));
269 }
270 
271 WebGLFramebuffer::WebGLFramebuffer(WebGLRenderingContextBase&amp; ctx)
272     : WebGLContextObject(ctx)
273     , m_hasEverBeenBound(false)
274 {
<span class="line-modified">275     setObject(ctx.graphicsContextGL()-&gt;createFramebuffer());</span>
276 }
277 
278 WebGLFramebuffer::~WebGLFramebuffer()
279 {
280     deleteObject(0);
281 }
282 
<span class="line-modified">283 void WebGLFramebuffer::setAttachmentForBoundFramebuffer(GCGLenum attachment, GCGLenum texTarget, WebGLTexture* texture, GCGLint level)</span>
284 {
285     ASSERT(isBound());
286     removeAttachmentFromBoundFramebuffer(attachment);
287     if (!object())
288         return;
289     if (texture &amp;&amp; texture-&gt;object()) {
290         m_attachments.add(attachment, WebGLTextureAttachment::create(texture, texTarget, level));
291         drawBuffersIfNecessary(false);
292         texture-&gt;onAttached();
293     }
294 }
295 
<span class="line-modified">296 void WebGLFramebuffer::setAttachmentForBoundFramebuffer(GCGLenum attachment, WebGLRenderbuffer* renderbuffer)</span>
297 {
298     ASSERT(isBound());
299     removeAttachmentFromBoundFramebuffer(attachment);
300     if (!object())
301         return;
302     if (renderbuffer &amp;&amp; renderbuffer-&gt;object()) {
303         m_attachments.add(attachment, WebGLRenderbufferAttachment::create(renderbuffer));
304         drawBuffersIfNecessary(false);
305         renderbuffer-&gt;onAttached();
306     }
307 }
308 
<span class="line-modified">309 void WebGLFramebuffer::attach(GCGLenum attachment, GCGLenum attachmentPoint)</span>
310 {
311     ASSERT(isBound());
312     RefPtr&lt;WebGLAttachment&gt; attachmentObject = getAttachment(attachment);
313     if (attachmentObject)
<span class="line-modified">314         attachmentObject-&gt;attach(context()-&gt;graphicsContextGL(), attachmentPoint);</span>
315 }
316 
<span class="line-modified">317 WebGLSharedObject* WebGLFramebuffer::getAttachmentObject(GCGLenum attachment) const</span>
318 {
319     if (!object())
320         return 0;
321     RefPtr&lt;WebGLAttachment&gt; attachmentObject = getAttachment(attachment);
322     return attachmentObject ? attachmentObject-&gt;getObject() : 0;
323 }
324 
<span class="line-modified">325 WebGLFramebuffer::WebGLAttachment* WebGLFramebuffer::getAttachment(GCGLenum attachment) const</span>
326 {
327     const AttachmentMap::const_iterator it = m_attachments.find(attachment);
328     return (it != m_attachments.end()) ? it-&gt;value.get() : 0;
329 }
330 
<span class="line-modified">331 void WebGLFramebuffer::removeAttachmentFromBoundFramebuffer(GCGLenum attachment)</span>
332 {
333     ASSERT(isBound());
334     if (!object())
335         return;
336 
337     RefPtr&lt;WebGLAttachment&gt; attachmentObject = getAttachment(attachment);
338     if (attachmentObject) {
<span class="line-modified">339         attachmentObject-&gt;onDetached(context()-&gt;graphicsContextGL());</span>
340         m_attachments.remove(attachment);
341         drawBuffersIfNecessary(false);
<span class="line-added">342 #if !USE(ANGLE)</span>
343         switch (attachment) {
<span class="line-modified">344         case GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT:</span>
<span class="line-modified">345             attach(GraphicsContextGL::DEPTH_ATTACHMENT, GraphicsContextGL::DEPTH_ATTACHMENT);</span>
<span class="line-modified">346             attach(GraphicsContextGL::STENCIL_ATTACHMENT, GraphicsContextGL::STENCIL_ATTACHMENT);</span>
347             break;
<span class="line-modified">348         case GraphicsContextGL::DEPTH_ATTACHMENT:</span>
<span class="line-modified">349             attach(GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT, GraphicsContextGL::DEPTH_ATTACHMENT);</span>
350             break;
<span class="line-modified">351         case GraphicsContextGL::STENCIL_ATTACHMENT:</span>
<span class="line-modified">352             attach(GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT, GraphicsContextGL::STENCIL_ATTACHMENT);</span>
353             break;
354         }
<span class="line-added">355 #endif</span>
356     }
357 }
358 
359 void WebGLFramebuffer::removeAttachmentFromBoundFramebuffer(WebGLSharedObject* attachment)
360 {
361     ASSERT(isBound());
362     if (!object())
363         return;
364     if (!attachment)
365         return;
366 
367     bool checkMore = true;
368     do {
369         checkMore = false;
370         for (auto&amp; entry : m_attachments) {
371             RefPtr&lt;WebGLAttachment&gt; attachmentObject = entry.value.get();
372             if (attachmentObject-&gt;isSharedObject(attachment)) {
<span class="line-modified">373                 GCGLenum attachmentType = entry.key;</span>
<span class="line-modified">374                 attachmentObject-&gt;unattach(context()-&gt;graphicsContextGL(), attachmentType);</span>
375                 removeAttachmentFromBoundFramebuffer(attachmentType);
376                 checkMore = true;
377                 break;
378             }
379         }
380     } while (checkMore);
381 }
382 
<span class="line-modified">383 GCGLsizei WebGLFramebuffer::getColorBufferWidth() const</span>
384 {
385     if (!object())
386         return 0;
<span class="line-modified">387     RefPtr&lt;WebGLAttachment&gt; attachment = getAttachment(GraphicsContextGL::COLOR_ATTACHMENT0);</span>
388     if (!attachment)
389         return 0;
390 
391     return attachment-&gt;getWidth();
392 }
393 
<span class="line-modified">394 GCGLsizei WebGLFramebuffer::getColorBufferHeight() const</span>
395 {
396     if (!object())
397         return 0;
<span class="line-modified">398     RefPtr&lt;WebGLAttachment&gt; attachment = getAttachment(GraphicsContextGL::COLOR_ATTACHMENT0);</span>
399     if (!attachment)
400         return 0;
401 
402     return attachment-&gt;getHeight();
403 }
404 
<span class="line-modified">405 GCGLenum WebGLFramebuffer::getColorBufferFormat() const</span>
406 {
407     if (!object())
408         return 0;
<span class="line-modified">409     RefPtr&lt;WebGLAttachment&gt; attachment = getAttachment(GraphicsContextGL::COLOR_ATTACHMENT0);</span>
410     if (!attachment)
411         return 0;
412     return attachment-&gt;getFormat();
413 }
414 
<span class="line-modified">415 GCGLenum WebGLFramebuffer::checkStatus(const char** reason) const</span>
416 {
417     unsigned int count = 0;
<span class="line-modified">418     GCGLsizei width = 0, height = 0;</span>
419     bool haveDepth = false;
420     bool haveStencil = false;
421     bool haveDepthStencil = false;
422     for (auto&amp; entry : m_attachments) {
423         RefPtr&lt;WebGLAttachment&gt; attachment = entry.value.get();
424         if (!isAttachmentComplete(attachment.get(), entry.key, reason))
<span class="line-modified">425             return GraphicsContextGL::FRAMEBUFFER_INCOMPLETE_ATTACHMENT;</span>
426         if (!attachment-&gt;isValid()) {
427             *reason = &quot;attachment is not valid&quot;;
<span class="line-modified">428             return GraphicsContextGL::FRAMEBUFFER_UNSUPPORTED;</span>
429         }
<span class="line-modified">430         GCGLenum attachmentFormat = attachment-&gt;getFormat();</span>
431 
432         // Attaching an SRGB_EXT format attachment to a framebuffer is invalid.
<span class="line-modified">433         if (attachmentFormat == ExtensionsGL::SRGB_EXT)</span>
434             attachmentFormat = 0;
435 
436         if (!attachmentFormat) {
437             *reason = &quot;attachment is an unsupported format&quot;;
<span class="line-modified">438             return GraphicsContextGL::FRAMEBUFFER_INCOMPLETE_ATTACHMENT;</span>
439         }
440         switch (entry.key) {
<span class="line-modified">441         case GraphicsContextGL::DEPTH_ATTACHMENT:</span>
442             haveDepth = true;
443             break;
<span class="line-modified">444         case GraphicsContextGL::STENCIL_ATTACHMENT:</span>
445             haveStencil = true;
446             break;
<span class="line-modified">447         case GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT:</span>
448             haveDepthStencil = true;
449             break;
450         }
451         if (!count) {
452             width = attachment-&gt;getWidth();
453             height = attachment-&gt;getHeight();
454         } else {
455             if (width != attachment-&gt;getWidth() || height != attachment-&gt;getHeight()) {
456                 *reason = &quot;attachments do not have the same dimensions&quot;;
<span class="line-modified">457                 return GraphicsContextGL::FRAMEBUFFER_INCOMPLETE_DIMENSIONS;</span>
458             }
459         }
460         ++count;
461     }
462     if (!count) {
463         *reason = &quot;no attachments&quot;;
<span class="line-modified">464         return GraphicsContextGL::FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;</span>
465     }
466     if (!width || !height) {
467         *reason = &quot;framebuffer has a 0 dimension&quot;;
<span class="line-modified">468         return GraphicsContextGL::FRAMEBUFFER_INCOMPLETE_ATTACHMENT;</span>
469     }
470     // WebGL specific: no conflicting DEPTH/STENCIL/DEPTH_STENCIL attachments.
471     if ((haveDepthStencil &amp;&amp; (haveDepth || haveStencil)) || (haveDepth &amp;&amp; haveStencil)) {
472         *reason = &quot;conflicting DEPTH/STENCIL/DEPTH_STENCIL attachments&quot;;
<span class="line-modified">473         return GraphicsContextGL::FRAMEBUFFER_UNSUPPORTED;</span>
474     }
<span class="line-modified">475     return GraphicsContextGL::FRAMEBUFFER_COMPLETE;</span>
476 }
477 
<span class="line-modified">478 bool WebGLFramebuffer::onAccess(GraphicsContextGLOpenGL* context3d, const char** reason)</span>
479 {
<span class="line-modified">480     if (checkStatus(reason) != GraphicsContextGL::FRAMEBUFFER_COMPLETE)</span>
481         return false;
482     return initializeAttachments(context3d, reason);
483 }
484 
485 bool WebGLFramebuffer::hasStencilBuffer() const
486 {
<span class="line-modified">487     RefPtr&lt;WebGLAttachment&gt; attachment = getAttachment(GraphicsContextGL::STENCIL_ATTACHMENT);</span>
488     if (!attachment)
<span class="line-modified">489         attachment = getAttachment(GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT);</span>
490     return attachment &amp;&amp; attachment-&gt;isValid();
491 }
492 
<span class="line-modified">493 void WebGLFramebuffer::deleteObjectImpl(GraphicsContextGLOpenGL* context3d, PlatformGLObject object)</span>
494 {
495     for (auto&amp; attachment : m_attachments.values())
496         attachment-&gt;onDetached(context3d);
497 
498     context3d-&gt;deleteFramebuffer(object);
499 }
500 
<span class="line-modified">501 bool WebGLFramebuffer::initializeAttachments(GraphicsContextGLOpenGL* g3d, const char** reason)</span>
502 {
503     ASSERT(object());
<span class="line-modified">504     GCGLbitfield mask = 0;</span>
505 
506     for (auto&amp; entry : m_attachments) {
<span class="line-modified">507         GCGLenum attachmentType = entry.key;</span>
508         RefPtr&lt;WebGLAttachment&gt; attachment = entry.value.get();
509         if (!attachment-&gt;isInitialized())
<span class="line-modified">510             mask |= GraphicsContextGLOpenGL::getClearBitsByAttachmentType(attachmentType);</span>
511     }
512     if (!mask)
513         return true;
514 
515     // We only clear un-initialized renderbuffers when they are ready to be
516     // read, i.e., when the framebuffer is complete.
<span class="line-modified">517     if (g3d-&gt;checkFramebufferStatus(GraphicsContextGL::FRAMEBUFFER) != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {</span>
518         *reason = &quot;framebuffer not complete&quot;;
519         return false;
520     }
521 
<span class="line-modified">522     bool initColor = mask &amp; GraphicsContextGL::COLOR_BUFFER_BIT;</span>
<span class="line-modified">523     bool initDepth = mask &amp; GraphicsContextGL::DEPTH_BUFFER_BIT;</span>
<span class="line-modified">524     bool initStencil = mask &amp; GraphicsContextGL::STENCIL_BUFFER_BIT;</span>
525 
<span class="line-modified">526     GCGLfloat colorClearValue[] = {0, 0, 0, 0}, depthClearValue = 0;</span>
<span class="line-modified">527     GCGLint stencilClearValue = 0;</span>
<span class="line-modified">528     GCGLboolean colorMask[] = {0, 0, 0, 0}, depthMask = 0;</span>
<span class="line-modified">529     GCGLuint stencilMask = 0xffffffff;</span>
<span class="line-modified">530     GCGLboolean isScissorEnabled = 0;</span>
<span class="line-modified">531     GCGLboolean isDitherEnabled = 0;</span>
532     if (initColor) {
<span class="line-modified">533         g3d-&gt;getFloatv(GraphicsContextGL::COLOR_CLEAR_VALUE, colorClearValue);</span>
<span class="line-modified">534         g3d-&gt;getBooleanv(GraphicsContextGL::COLOR_WRITEMASK, colorMask);</span>
535         g3d-&gt;clearColor(0, 0, 0, 0);
536         g3d-&gt;colorMask(true, true, true, true);
537     }
538     if (initDepth) {
<span class="line-modified">539         g3d-&gt;getFloatv(GraphicsContextGL::DEPTH_CLEAR_VALUE, &amp;depthClearValue);</span>
<span class="line-modified">540         g3d-&gt;getBooleanv(GraphicsContextGL::DEPTH_WRITEMASK, &amp;depthMask);</span>
541         g3d-&gt;clearDepth(1.0f);
542         g3d-&gt;depthMask(true);
543     }
544     if (initStencil) {
<span class="line-modified">545         g3d-&gt;getIntegerv(GraphicsContextGL::STENCIL_CLEAR_VALUE, &amp;stencilClearValue);</span>
<span class="line-modified">546         g3d-&gt;getIntegerv(GraphicsContextGL::STENCIL_WRITEMASK, reinterpret_cast&lt;GCGLint*&gt;(&amp;stencilMask));</span>
547         g3d-&gt;clearStencil(0);
548         g3d-&gt;stencilMask(0xffffffff);
549     }
<span class="line-modified">550     isScissorEnabled = g3d-&gt;isEnabled(GraphicsContextGL::SCISSOR_TEST);</span>
<span class="line-modified">551     g3d-&gt;disable(GraphicsContextGL::SCISSOR_TEST);</span>
<span class="line-modified">552     isDitherEnabled = g3d-&gt;isEnabled(GraphicsContextGL::DITHER);</span>
<span class="line-modified">553     g3d-&gt;disable(GraphicsContextGL::DITHER);</span>
554 
555     g3d-&gt;clear(mask);
556 
557     if (initColor) {
558         g3d-&gt;clearColor(colorClearValue[0], colorClearValue[1], colorClearValue[2], colorClearValue[3]);
559         g3d-&gt;colorMask(colorMask[0], colorMask[1], colorMask[2], colorMask[3]);
560     }
561     if (initDepth) {
562         g3d-&gt;clearDepth(depthClearValue);
563         g3d-&gt;depthMask(depthMask);
564     }
565     if (initStencil) {
566         g3d-&gt;clearStencil(stencilClearValue);
567         g3d-&gt;stencilMask(stencilMask);
568     }
569     if (isScissorEnabled)
<span class="line-modified">570         g3d-&gt;enable(GraphicsContextGL::SCISSOR_TEST);</span>
571     else
<span class="line-modified">572         g3d-&gt;disable(GraphicsContextGL::SCISSOR_TEST);</span>
573     if (isDitherEnabled)
<span class="line-modified">574         g3d-&gt;enable(GraphicsContextGL::DITHER);</span>
575     else
<span class="line-modified">576         g3d-&gt;disable(GraphicsContextGL::DITHER);</span>
577 
578     for (AttachmentMap::iterator it = m_attachments.begin(); it != m_attachments.end(); ++it) {
<span class="line-modified">579         GCGLenum attachmentType = it-&gt;key;</span>
580         auto attachment = it-&gt;value;
<span class="line-modified">581         GCGLbitfield bits = GraphicsContextGLOpenGL::getClearBitsByAttachmentType(attachmentType);</span>
582         if (bits &amp; mask)
583             attachment-&gt;setInitialized();
584     }
585     return true;
586 }
587 
588 bool WebGLFramebuffer::isBound() const
589 {
590     return (context()-&gt;m_framebufferBinding.get() == this) || (context()-&gt;m_readFramebufferBinding.get() == this);
591 }
592 
<span class="line-modified">593 void WebGLFramebuffer::drawBuffers(const Vector&lt;GCGLenum&gt;&amp; bufs)</span>
594 {
595     m_drawBuffers = bufs;
596     m_filteredDrawBuffers.resize(m_drawBuffers.size());
597     for (auto&amp; buffer : m_filteredDrawBuffers)
<span class="line-modified">598         buffer = GraphicsContextGL::NONE;</span>
599     drawBuffersIfNecessary(true);
600 }
601 
602 void WebGLFramebuffer::drawBuffersIfNecessary(bool force)
603 {
604 #if ENABLE(WEBGL2)
605     // FIXME: The logic here seems wrong. If we don&#39;t have WebGL 2 enabled at all, then
606     // we skip the m_webglDrawBuffers check. But if we do have WebGL 2 enabled, then we
607     // perform this check, for WebGL 1 contexts only.
608     if (!context()-&gt;m_webglDrawBuffers &amp;&amp; !context()-&gt;isWebGL2())
609         return;
610 #endif
611     bool reset = force;
612     // This filtering works around graphics driver bugs on Mac OS X.
613     for (size_t i = 0; i &lt; m_drawBuffers.size(); ++i) {
<span class="line-modified">614         if (m_drawBuffers[i] != GraphicsContextGL::NONE &amp;&amp; getAttachment(m_drawBuffers[i])) {</span>
615             if (m_filteredDrawBuffers[i] != m_drawBuffers[i]) {
616                 m_filteredDrawBuffers[i] = m_drawBuffers[i];
617                 reset = true;
618             }
619         } else {
<span class="line-modified">620             if (m_filteredDrawBuffers[i] != GraphicsContextGL::NONE) {</span>
<span class="line-modified">621                 m_filteredDrawBuffers[i] = GraphicsContextGL::NONE;</span>
622                 reset = true;
623             }
624         }
625     }
626     if (reset) {
<span class="line-modified">627         context()-&gt;graphicsContextGL()-&gt;getExtensions().drawBuffersEXT(</span>
628             m_filteredDrawBuffers.size(), m_filteredDrawBuffers.data());
629     }
630 }
631 
<span class="line-modified">632 GCGLenum WebGLFramebuffer::getDrawBuffer(GCGLenum drawBuffer)</span>
633 {
<span class="line-modified">634     int index = static_cast&lt;int&gt;(drawBuffer - ExtensionsGL::DRAW_BUFFER0_EXT);</span>
635     ASSERT(index &gt;= 0);
636     if (index &lt; static_cast&lt;int&gt;(m_drawBuffers.size()))
637         return m_drawBuffers[index];
<span class="line-modified">638     if (drawBuffer == ExtensionsGL::DRAW_BUFFER0_EXT)</span>
<span class="line-modified">639         return GraphicsContextGL::COLOR_ATTACHMENT0;</span>
<span class="line-modified">640     return GraphicsContextGL::NONE;</span>
641 }
642 
643 }
644 
645 #endif // ENABLE(WEBGL)
</pre>
</td>
</tr>
</table>
<center><a href="WebGLExtension.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLFramebuffer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/ImageBitmap.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ImageBitmap.h&quot;
 28 
 29 #include &quot;BitmapImage.h&quot;
 30 #include &quot;Blob.h&quot;
 31 #include &quot;CachedImage.h&quot;
 32 #include &quot;ExceptionOr.h&quot;
 33 #include &quot;FileReaderLoader.h&quot;
 34 #include &quot;FileReaderLoaderClient.h&quot;
 35 #include &quot;GraphicsContext.h&quot;
 36 #include &quot;HTMLCanvasElement.h&quot;
 37 #include &quot;HTMLImageElement.h&quot;
 38 #include &quot;HTMLVideoElement.h&quot;
 39 #include &quot;ImageBitmapOptions.h&quot;
 40 #include &quot;ImageBuffer.h&quot;
 41 #include &quot;ImageData.h&quot;
 42 #include &quot;IntRect.h&quot;
 43 #include &quot;JSDOMPromiseDeferred.h&quot;
 44 #include &quot;JSImageBitmap.h&quot;
 45 #include &quot;LayoutSize.h&quot;
 46 #if ENABLE(OFFSCREEN_CANVAS)
 47 #include &quot;OffscreenCanvas.h&quot;
 48 #endif
 49 #include &quot;RenderElement.h&quot;
 50 #include &quot;SharedBuffer.h&quot;
 51 #include &quot;SuspendableTimer.h&quot;
 52 #include &quot;TypedOMCSSImageValue.h&quot;
 53 #include &lt;wtf/IsoMallocInlines.h&gt;
 54 #include &lt;wtf/Optional.h&gt;
 55 #include &lt;wtf/Scope.h&gt;
 56 #include &lt;wtf/StdLibExtras.h&gt;
 57 #include &lt;wtf/Variant.h&gt;
 58 
 59 namespace WebCore {
 60 
 61 WTF_MAKE_ISO_ALLOCATED_IMPL(ImageBitmap);
 62 
 63 #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
 64 static RenderingMode bufferRenderingMode = RenderingMode::Accelerated;
 65 #else
 66 static RenderingMode bufferRenderingMode = RenderingMode::Unaccelerated;
 67 #endif
 68 
 69 Ref&lt;ImageBitmap&gt; ImageBitmap::create(IntSize size)
 70 {
 71     return create(ImageBuffer::create(FloatSize(size.width(), size.height()), bufferRenderingMode));
 72 }
 73 
 74 Ref&lt;ImageBitmap&gt; ImageBitmap::create(std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&amp;&amp; buffer)
 75 {
 76     auto imageBitmap = create(WTFMove(buffer.first));
 77     imageBitmap-&gt;m_originClean = buffer.second;
 78     return imageBitmap;
 79 }
 80 
 81 Ref&lt;ImageBitmap&gt; ImageBitmap::create(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp; buffer)
 82 {
 83     return adoptRef(*new ImageBitmap(WTFMove(buffer)));
 84 }
 85 
 86 void ImageBitmap::createPromise(ScriptExecutionContext&amp; scriptExecutionContext, ImageBitmap::Source&amp;&amp; source, ImageBitmapOptions&amp;&amp; options, ImageBitmap::Promise&amp;&amp; promise)
 87 {
 88     WTF::switchOn(source,
 89         [&amp;] (auto&amp; specificSource) {
 90             createPromise(scriptExecutionContext, specificSource, WTFMove(options), WTF::nullopt, WTFMove(promise));
 91         }
 92     );
 93 }
 94 
 95 Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt; ImageBitmap::detachBitmaps(Vector&lt;RefPtr&lt;ImageBitmap&gt;&gt;&amp;&amp; bitmaps)
 96 {
 97     Vector&lt;std::pair&lt;std::unique_ptr&lt;ImageBuffer&gt;, bool&gt;&gt; buffers;
 98     for (auto&amp; bitmap : bitmaps)
 99         buffers.append(std::make_pair(bitmap-&gt;transferOwnershipAndClose(), bitmap-&gt;originClean()));
100     return buffers;
101 }
102 
103 
104 void ImageBitmap::createPromise(ScriptExecutionContext&amp; scriptExecutionContext, ImageBitmap::Source&amp;&amp; source, ImageBitmapOptions&amp;&amp; options, int sx, int sy, int sw, int sh, ImageBitmap::Promise&amp;&amp; promise)
105 {
106     // 1. If either the sw or sh arguments are specified but zero, return a promise
107     //    rejected with an &quot;RangeError&quot; DOMException and abort these steps.
108     if (!sw || !sh) {
109         promise.reject(RangeError, &quot;Cannot create ImageBitmap with a width or height of 0&quot;);
110         return;
111     }
112 
113     auto left = sw &gt;= 0 ? sx : sx + sw;
114     auto top = sh &gt;= 0 ? sy : sy + sh;
115     auto width = std::abs(sw);
116     auto height = std::abs(sh);
117 
118     WTF::switchOn(source,
119         [&amp;] (auto&amp; specificSource) {
120             createPromise(scriptExecutionContext, specificSource, WTFMove(options), IntRect { left, top, width, height }, WTFMove(promise));
121         }
122     );
123 }
124 
125 static bool taintsOrigin(CachedImage&amp; cachedImage)
126 {
127     auto* image = cachedImage.image();
128     if (!image)
129         return false;
130 
131     if (image-&gt;sourceURL().protocolIsData())
132         return false;
133 
134     if (!image-&gt;hasSingleSecurityOrigin())
135         return true;
136 
137     if (!cachedImage.isCORSSameOrigin())
138         return true;
139 
140     return false;
141 }
142 
143 #if ENABLE(VIDEO)
144 static bool taintsOrigin(SecurityOrigin* origin, HTMLVideoElement&amp; video)
145 {
146     if (!video.hasSingleSecurityOrigin())
147         return true;
148 
149     if (video.player()-&gt;didPassCORSAccessCheck())
150         return false;
151 
152     auto url = video.currentSrc();
153     if (url.protocolIsData())
154         return false;
155 
156     return !origin-&gt;canRequest(url);
157 }
158 #endif
159 
160 // https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html#cropped-to-the-source-rectangle-with-formatting
161 static ExceptionOr&lt;IntRect&gt; croppedSourceRectangleWithFormatting(IntSize inputSize, ImageBitmapOptions&amp; options, Optional&lt;IntRect&gt; rect)
162 {
163     // 2. If either or both of resizeWidth and resizeHeight members of options are less
164     //    than or equal to 0, then return a promise rejected with &quot;InvalidStateError&quot;
165     //    DOMException and abort these steps.
166     if ((options.resizeWidth &amp;&amp; options.resizeWidth.value() &lt;= 0) || (options.resizeHeight &amp;&amp; options.resizeHeight.value() &lt;= 0))
167         return Exception { InvalidStateError, &quot;Invalid resize dimensions&quot; };
168 
169     // 3. If sx, sy, sw and sh are specified, let sourceRectangle be a rectangle whose
170     //    corners are the four points (sx, sy), (sx+sw, sy),(sx+sw, sy+sh), (sx,sy+sh).
171     //    Otherwise let sourceRectangle be a rectangle whose corners are the four points
172     //    (0,0), (width of input, 0), (width of input, height of input), (0, height of
173     //    input).
174     auto sourceRectangle = rect.valueOr(IntRect { 0, 0, inputSize.width(), inputSize.height() });
175 
176     // 4. Clip sourceRectangle to the dimensions of input.
177     sourceRectangle.intersect(IntRect { 0, 0, inputSize.width(), inputSize.height() });
178 
179     return { WTFMove(sourceRectangle) };
180 }
181 
182 static IntSize outputSizeForSourceRectangle(IntRect sourceRectangle, ImageBitmapOptions&amp; options)
183 {
184     // 5. Let outputWidth be determined as follows:
185     auto outputWidth = [&amp;] () -&gt; int {
186         if (options.resizeWidth)
187             return options.resizeWidth.value();
188         if (options.resizeHeight)
189             return ceil(sourceRectangle.width() * static_cast&lt;double&gt;(options.resizeHeight.value()) / sourceRectangle.height());
190         return sourceRectangle.width();
191     }();
192 
193     // 6. Let outputHeight be determined as follows:
194     auto outputHeight = [&amp;] () -&gt; int {
195         if (options.resizeHeight)
196             return options.resizeHeight.value();
197         if (options.resizeWidth)
198             return ceil(sourceRectangle.height() * static_cast&lt;double&gt;(options.resizeWidth.value()) / sourceRectangle.width());
199         return sourceRectangle.height();
200     }();
201 
202     return { outputWidth, outputHeight };
203 }
204 
205 static InterpolationQuality interpolationQualityForResizeQuality(ImageBitmapOptions::ResizeQuality resizeQuality)
206 {
207     switch (resizeQuality) {
208     case ImageBitmapOptions::ResizeQuality::Pixelated:
209         return InterpolationQuality::DoNotInterpolate;
210     case ImageBitmapOptions::ResizeQuality::Low:
211         return InterpolationQuality::Default; // Low is the default.
212     case ImageBitmapOptions::ResizeQuality::Medium:
213         return InterpolationQuality::Medium;
214     case ImageBitmapOptions::ResizeQuality::High:
215         return InterpolationQuality::High;
216     }
217     ASSERT_NOT_REACHED();
218     return InterpolationQuality::Default;
219 }
220 
221 // FIXME: More steps from https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html#cropped-to-the-source-rectangle-with-formatting
222 
223 // 7. Place input on an infinite transparent black grid plane, positioned so that its
224 //    top left corner is at the origin of the plane, with the x-coordinate increasing
225 //    to the right, and the y-coordinate increasing down, and with each pixel in the
226 //    input image data occupying a cell on the plane&#39;s grid.
227 
228 // 8. Let output be the rectangle on the plane denoted by sourceRectangle.
229 
230 // 9. Scale output to the size specified by outputWidth and outputHeight. The user
231 //    agent should use the value of the resizeQuality option to guide the choice of
232 //    scaling algorithm.
233 
234 // 10. If the value of the imageOrientation member of options is &quot;flipY&quot;, output must
235 //     be flipped vertically, disregarding any image orientation metadata of the source
236 //     (such as EXIF metadata), if any.
237 
238 // 11. If image is an img element or a Blob object, let val be the value of the
239 //     colorSpaceConversion member of options, and then run these substeps:
240 //
241 //     1. If val is &quot;default&quot;, the color space conversion behavior is implementation-specific,
242 //        and should be chosen according to the color space that the implementation uses for
243 //        drawing images onto the canvas.
244 //
245 //     2. If val is &quot;none&quot;, output must be decoded without performing any color space
246 //        conversions. This means that the image decoding algorithm must ignore color profile
247 //        metadata embedded in the source data as well as the display device color profile.
248 
249 // 12. Let val be the value of premultiplyAlpha member of options, and then run these substeps:
250 //
251 //     1. If val is &quot;default&quot;, the alpha premultiplication behavior is implementation-specific,
252 //        and should be chosen according to implementation deems optimal for drawing images
253 //        onto the canvas.
254 //
255 //     2. If val is &quot;premultiply&quot;, the output that is not premultiplied by alpha must have its
256 //        color components multiplied by alpha and that is premultiplied by alpha must be left
257 //        untouched.
258 //
259 //     3. If val is &quot;none&quot;, the output that is not premultiplied by alpha must be left untouched
260 //        and that is premultiplied by alpha must have its color components divided by alpha.
261 
262 // 13. Return output.
263 
264 void ImageBitmap::createPromise(ScriptExecutionContext&amp;, RefPtr&lt;HTMLImageElement&gt;&amp; imageElement, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)
265 {
266     // 2. If image is not completely available, then return a promise rejected with
267     // an &quot;InvalidStateError&quot; DOMException and abort these steps.
268 
269     auto* cachedImage = imageElement-&gt;cachedImage();
270     if (!cachedImage || !imageElement-&gt;complete()) {
271         promise.reject(InvalidStateError, &quot;Cannot create ImageBitmap that is not completely available&quot;);
272         return;
273     }
274 
275     // 3. If image&#39;s media data has no intrinsic dimensions (e.g. it&#39;s a vector graphic
276     //    with no specified content size), and both or either of the resizeWidth and
277     //    resizeHeight options are not specified, then return a promise rejected with
278     //    an &quot;InvalidStateError&quot; DOMException and abort these steps.
279 
280     auto imageSize = cachedImage-&gt;imageSizeForRenderer(imageElement-&gt;renderer(), 1.0f);
281     if ((!imageSize.width() || !imageSize.height()) &amp;&amp; (!options.resizeWidth || !options.resizeHeight)) {
282         promise.reject(InvalidStateError, &quot;Cannot create ImageBitmap from a source with no intrinsic size without providing resize dimensions&quot;);
283         return;
284     }
285 
286     // 4. If image&#39;s media data has no intrinsic dimensions (e.g. it&#39;s a vector graphics
287     //    with no specified content size), it should be rendered to a bitmap of the size
288     //    specified by the resizeWidth and the resizeHeight options.
289 
290     if (!imageSize.width() &amp;&amp; !imageSize.height()) {
291         imageSize.setWidth(options.resizeWidth.value());
292         imageSize.setHeight(options.resizeHeight.value());
293     }
294 
295     // 5. If the sw and sh arguments are not specified and image&#39;s media data has both or
296     //    either of its intrinsic width and intrinsic height values equal to 0, then return
297     //    a promise rejected with an &quot;InvalidStateError&quot; DOMException and abort these steps.
298     // 6. If the sh argument is not specified and image&#39;s media data has an intrinsic height
299     //    of 0, then return a promise rejected with an &quot;InvalidStateError&quot; DOMException and
300     //    abort these steps.
301 
302     // FIXME: It&#39;s unclear how these steps can happen, since step 4 required setting a
303     // width and height for the image.
304 
305     if (!rect &amp;&amp; (!imageSize.width() || !imageSize.height())) {
306         promise.reject(InvalidStateError, &quot;Cannot create ImageBitmap from a source with no intrinsic size without providing dimensions&quot;);
307         return;
308     }
309 
310     // 8. Let the ImageBitmap object&#39;s bitmap data be a copy of image&#39;s media data, cropped to
311     //    the source rectangle with formatting. If this is an animated image, the ImageBitmap
312     //    object&#39;s bitmap data must only be taken from the default image of the animation (the
313     //    one that the format defines is to be used when animation is not supported or is disabled),
314     //    or, if there is no such image, the first frame of the animation.
315 
316     auto sourceRectangle = croppedSourceRectangleWithFormatting(roundedIntSize(imageSize), options, WTFMove(rect));
317     if (sourceRectangle.hasException()) {
318         promise.reject(sourceRectangle.releaseException());
319         return;
320     }
321 
322     auto outputSize = outputSizeForSourceRectangle(sourceRectangle.returnValue(), options);
323     auto bitmapData = ImageBuffer::create(FloatSize(outputSize.width(), outputSize.height()), bufferRenderingMode);
324 
325     auto imageForRender = cachedImage-&gt;imageForRenderer(imageElement-&gt;renderer());
326     if (!imageForRender) {
327         promise.reject(InvalidStateError, &quot;Cannot create ImageBitmap from image that can&#39;t be rendered&quot;);
328         return;
329     }
330 
331     FloatRect destRect(FloatPoint(), outputSize);
332     bitmapData-&gt;context().drawImage(*imageForRender, destRect, sourceRectangle.releaseReturnValue(), { interpolationQualityForResizeQuality(options.resizeQuality) });
333 
334     // 7. Create a new ImageBitmap object.
335     auto imageBitmap = create(WTFMove(bitmapData));
336 
337     // 9. If the origin of image&#39;s image is not the same origin as the origin specified by the
338     //    entry settings object, then set the origin-clean flag of the ImageBitmap object&#39;s
339     //    bitmap to false.
340 
341     imageBitmap-&gt;m_originClean = !taintsOrigin(*cachedImage);
342 
343     // 10. Return a new promise, but continue running these steps in parallel.
344     // 11. Resolve the promise with the new ImageBitmap object as the value.
345 
346     promise.resolve(WTFMove(imageBitmap));
347 }
348 
349 void ImageBitmap::createPromise(ScriptExecutionContext&amp; context, RefPtr&lt;HTMLCanvasElement&gt;&amp; canvasElement, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)
350 {
351     createPromise(context, *canvasElement, WTFMove(options), WTFMove(rect), WTFMove(promise));
352 }
353 
354 #if ENABLE(OFFSCREEN_CANVAS)
355 void ImageBitmap::createPromise(ScriptExecutionContext&amp; context, RefPtr&lt;OffscreenCanvas&gt;&amp; canvasElement, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)
356 {
357     createPromise(context, *canvasElement, WTFMove(options), WTFMove(rect), WTFMove(promise));
358 }
359 #endif
360 
361 void ImageBitmap::createPromise(ScriptExecutionContext&amp;, CanvasBase&amp; canvas, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)
362 {
363     // 2. If the canvas element&#39;s bitmap has either a horizontal dimension or a vertical
364     //    dimension equal to zero, then return a promise rejected with an &quot;InvalidStateError&quot;
365     //    DOMException and abort these steps.
366     auto size = canvas.size();
367     if (!size.width() || !size.height()) {
368         promise.reject(InvalidStateError, &quot;Cannot create ImageBitmap from a canvas that has zero width or height&quot;);
369         return;
370     }
371 
372     // 4. Let the ImageBitmap object&#39;s bitmap data be a copy of the canvas element&#39;s bitmap
373     //    data, cropped to the source rectangle with formatting.
374 
375     auto sourceRectangle = croppedSourceRectangleWithFormatting(size, options, WTFMove(rect));
376     if (sourceRectangle.hasException()) {
377         promise.reject(sourceRectangle.releaseException());
378         return;
379     }
380 
381     auto outputSize = outputSizeForSourceRectangle(sourceRectangle.returnValue(), options);
382     auto bitmapData = ImageBuffer::create(FloatSize(outputSize.width(), outputSize.height()), bufferRenderingMode);
383 
384     auto imageForRender = canvas.copiedImage();
385     if (!imageForRender) {
386         promise.reject(InvalidStateError, &quot;Cannot create ImageBitmap from canvas that can&#39;t be rendered&quot;);
387         return;
388     }
389 
390     FloatRect destRect(FloatPoint(), outputSize);
391     bitmapData-&gt;context().drawImage(*imageForRender, destRect, sourceRectangle.releaseReturnValue(), { interpolationQualityForResizeQuality(options.resizeQuality) });
392 
393     // 3. Create a new ImageBitmap object.
394     auto imageBitmap = create(WTFMove(bitmapData));
395 
396     // 5. Set the origin-clean flag of the ImageBitmap object&#39;s bitmap to the same value as
397     //    the origin-clean flag of the canvas element&#39;s bitmap.
398 
399     imageBitmap-&gt;m_originClean = canvas.originClean();
400 
401     // 6. Return a new promise, but continue running these steps in parallel.
402     // 7. Resolve the promise with the new ImageBitmap object as the value.
403 
404     promise.resolve(WTFMove(imageBitmap));
405 }
406 
407 #if ENABLE(VIDEO)
408 void ImageBitmap::createPromise(ScriptExecutionContext&amp; scriptExecutionContext, RefPtr&lt;HTMLVideoElement&gt;&amp; video, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)
409 {
410     // https://html.spec.whatwg.org/multipage/#dom-createimagebitmap
411     // WHATWG HTML 2102913b313078cd8eeac7e81e6a8756cbd3e773
412     // Steps 3-7.
413     // (Step 3 is handled in croppedSourceRectangleWithFormatting.)
414 
415     // 4. Check the usability of the image argument. If this throws an exception
416     //    or returns bad, then return p rejected with an &quot;InvalidStateError&quot;
417     //    DOMException.
418     if (video-&gt;readyState() == HTMLMediaElement::HAVE_NOTHING || video-&gt;readyState() == HTMLMediaElement::HAVE_METADATA) {
419         promise.reject(InvalidStateError, &quot;Cannot create ImageBitmap before the HTMLVideoElement has data&quot;);
420         return;
421     }
422 
423     // 6.1. If image&#39;s networkState attribute is NETWORK_EMPTY, then return p
424     //      rejected with an &quot;InvalidStateError&quot; DOMException.
425     if (video-&gt;networkState() == HTMLMediaElement::NETWORK_EMPTY) {
426         promise.reject(InvalidStateError, &quot;Cannot create ImageBitmap before the HTMLVideoElement has data&quot;);
427         return;
428     }
429 
430     // 6.2. Set imageBitmap&#39;s bitmap data to a copy of the frame at the current
431     //      playback position, at the media resource&#39;s intrinsic width and
432     //      intrinsic height (i.e., after any aspect-ratio correction has been
433     //      applied), cropped to the source rectangle with formatting.
434     auto size = video-&gt;player() ? roundedIntSize(video-&gt;player()-&gt;naturalSize()) : IntSize();
435     auto maybeSourceRectangle = croppedSourceRectangleWithFormatting(size, options, WTFMove(rect));
436     if (maybeSourceRectangle.hasException()) {
437         promise.reject(maybeSourceRectangle.releaseException());
438         return;
439     }
440     auto sourceRectangle = maybeSourceRectangle.releaseReturnValue();
441 
442     auto outputSize = outputSizeForSourceRectangle(sourceRectangle, options);
443     auto bitmapData = ImageBuffer::create(FloatSize(outputSize.width(), outputSize.height()), bufferRenderingMode);
444 
445     {
446         GraphicsContext&amp; c = bitmapData-&gt;context();
447         GraphicsContextStateSaver stateSaver(c);
448         c.clip(FloatRect(FloatPoint(), outputSize));
449         auto scaleX = float(outputSize.width()) / float(sourceRectangle.width());
450         auto scaleY = float(outputSize.height()) / float(sourceRectangle.height());
451         c.scale(FloatSize(scaleX, scaleY));
452         c.translate(-sourceRectangle.location());
453         video-&gt;paintCurrentFrameInContext(c, FloatRect(FloatPoint(), size));
454     }
455 
456     // 5. Let imageBitmap be a new ImageBitmap object.
457     auto imageBitmap = create(WTFMove(bitmapData));
458 
459     // 6.3. If the origin of image&#39;s video is not same origin with entry
460     //      settings object&#39;s origin, then set the origin-clean flag of
461     //      image&#39;s bitmap to false.
462     imageBitmap-&gt;m_originClean = !taintsOrigin(scriptExecutionContext.securityOrigin(), *video);
463 
464     // 6.4.1. Resolve p with imageBitmap.
465     promise.resolve(WTFMove(imageBitmap));
466 }
467 #endif
468 
469 #if ENABLE(CSS_TYPED_OM)
470 void ImageBitmap::createPromise(ScriptExecutionContext&amp;, RefPtr&lt;TypedOMCSSImageValue&gt;&amp;, ImageBitmapOptions&amp;&amp;, Optional&lt;IntRect&gt;, ImageBitmap::Promise&amp;&amp; promise)
471 {
472     promise.reject(InvalidStateError, &quot;Not implemented&quot;);
473 }
474 #endif
475 
476 void ImageBitmap::createPromise(ScriptExecutionContext&amp;, RefPtr&lt;ImageBitmap&gt;&amp; existingImageBitmap, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)
477 {
478     // 2. If image&#39;s [[Detached]] internal slot value is true, return a promise
479     //    rejected with an &quot;InvalidStateError&quot; DOMException and abort these steps.
480     if (existingImageBitmap-&gt;isDetached() || !existingImageBitmap-&gt;buffer()) {
481         promise.reject(InvalidStateError, &quot;Cannot create ImageBitmap from a detached ImageBitmap&quot;);
482         return;
483     }
484 
485     // 4. Let the ImageBitmap object&#39;s bitmap data be a copy of the image argument&#39;s
486     //    bitmap data, cropped to the source rectangle with formatting.
487     auto sourceRectangle = croppedSourceRectangleWithFormatting(existingImageBitmap-&gt;buffer()-&gt;logicalSize(), options, WTFMove(rect));
488     if (sourceRectangle.hasException()) {
489         promise.reject(sourceRectangle.releaseException());
490         return;
491     }
492 
493     auto outputSize = outputSizeForSourceRectangle(sourceRectangle.returnValue(), options);
494     auto bitmapData = ImageBuffer::create(FloatSize(outputSize.width(), outputSize.height()), bufferRenderingMode);
495 
496     auto imageForRender = existingImageBitmap-&gt;buffer()-&gt;copyImage();
497 
498     FloatRect destRect(FloatPoint(), outputSize);
499     bitmapData-&gt;context().drawImage(*imageForRender, destRect, sourceRectangle.releaseReturnValue(), { interpolationQualityForResizeQuality(options.resizeQuality) });
500 
501     // 3. Create a new ImageBitmap object.
502     auto imageBitmap = create(WTFMove(bitmapData));
503 
504     // 5. Set the origin-clean flag of the ImageBitmap object&#39;s bitmap to the same
505     //    value as the origin-clean flag of the bitmap of the image argument.
506     imageBitmap-&gt;m_originClean = existingImageBitmap-&gt;originClean();
507 
508     // 6. Return a new promise, but continue running these steps in parallel.
509     // 7. Resolve the promise with the new ImageBitmap object as the value.
510     promise.resolve(WTFMove(imageBitmap));
511 }
512 
513 class ImageBitmapImageObserver final : public RefCounted&lt;ImageBitmapImageObserver&gt;, public ImageObserver {
514 public:
515     static Ref&lt;ImageBitmapImageObserver&gt; create(String mimeType, long long expectedContentLength, const URL&amp; sourceUrl)
516     {
517         return adoptRef(*new ImageBitmapImageObserver(mimeType, expectedContentLength, sourceUrl));
518     }
519 
520     URL sourceUrl() const override { return m_sourceUrl; }
521     String mimeType() const override { return m_mimeType; }
522     long long expectedContentLength() const override { return m_expectedContentLength; }
523 
524     void decodedSizeChanged(const Image&amp;, long long) override { }
525 
526     void didDraw(const Image&amp;) override { }
527 
528     bool canDestroyDecodedData(const Image&amp;) override { return true; }
529     void imageFrameAvailable(const Image&amp;, ImageAnimatingState, const IntRect* = nullptr, DecodingStatus = DecodingStatus::Invalid) override { }
530     void changedInRect(const Image&amp;, const IntRect* = nullptr) override { }
531 
532 private:
533     ImageBitmapImageObserver(String mimeType, long long expectedContentLength, const URL&amp; sourceUrl)
534         : m_mimeType(mimeType)
535         , m_expectedContentLength(expectedContentLength)
536         , m_sourceUrl(sourceUrl)
537     { }
538 
539     String m_mimeType;
540     long long m_expectedContentLength;
541     URL m_sourceUrl;
542 };
543 
544 class PendingImageBitmap final : public ActiveDOMObject, public FileReaderLoaderClient {
545     WTF_MAKE_FAST_ALLOCATED;
546 public:
547     static void fetch(ScriptExecutionContext&amp; scriptExecutionContext, RefPtr&lt;Blob&gt;&amp;&amp; blob, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)
548     {
549         auto pendingImageBitmap = new PendingImageBitmap(scriptExecutionContext, WTFMove(blob), WTFMove(options), WTFMove(rect), WTFMove(promise));
550         pendingImageBitmap-&gt;start(scriptExecutionContext);
551     }
552 
553 private:
554     PendingImageBitmap(ScriptExecutionContext&amp; scriptExecutionContext, RefPtr&lt;Blob&gt;&amp;&amp; blob, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)
555         : ActiveDOMObject(&amp;scriptExecutionContext)
556         , m_blobLoader(FileReaderLoader::ReadAsArrayBuffer, this)
557         , m_blob(WTFMove(blob))
558         , m_options(WTFMove(options))
559         , m_rect(WTFMove(rect))
560         , m_promise(WTFMove(promise))
561         , m_createImageBitmapTimer(&amp;scriptExecutionContext, *this, &amp;PendingImageBitmap::createImageBitmapAndResolvePromise)
562     {
563         suspendIfNeeded();
564         m_createImageBitmapTimer.suspendIfNeeded();
565     }
566 
567     void start(ScriptExecutionContext&amp; scriptExecutionContext)
568     {
569         m_blobLoader.start(&amp;scriptExecutionContext, *m_blob);
570     }
571 
572     // ActiveDOMObject
573 
574     const char* activeDOMObjectName() const final
575     {
576         return &quot;PendingImageBitmap&quot;;
577     }
578 
579     void stop() final
580     {
581         delete this;
582     }
583 
584     // FileReaderLoaderClient
585 
586     void didStartLoading() override
587     {
588     }
589 
590     void didReceiveData() override
591     {
592     }
593 
594     void didFinishLoading() override
595     {
596         createImageBitmapAndResolvePromiseSoon(m_blobLoader.arrayBufferResult());
597     }
598 
599     void didFail(int) override
600     {
601         createImageBitmapAndResolvePromiseSoon(nullptr);
602     }
603 
604     void createImageBitmapAndResolvePromiseSoon(RefPtr&lt;ArrayBuffer&gt;&amp;&amp; arrayBuffer)
605     {
606         ASSERT(!m_createImageBitmapTimer.isActive());
607         m_arrayBufferToProcess = WTFMove(arrayBuffer);
608         m_createImageBitmapTimer.startOneShot(0_s);
609     }
610 
611     void createImageBitmapAndResolvePromise()
612     {
613         auto destroyOnExit = makeScopeExit([this] {
614             delete this;
615         });
616 
617         if (!m_arrayBufferToProcess) {
618             m_promise.reject(InvalidStateError, &quot;An error occured reading the Blob argument to createImageBitmap&quot;);
619             return;
620         }
621 
622         ImageBitmap::createFromBuffer(m_arrayBufferToProcess.releaseNonNull(), m_blob-&gt;type(), m_blob-&gt;size(), m_blobLoader.url(), WTFMove(m_options), WTFMove(m_rect), WTFMove(m_promise));
623     }
624 
625     FileReaderLoader m_blobLoader;
626     RefPtr&lt;Blob&gt; m_blob;
627     ImageBitmapOptions m_options;
628     Optional&lt;IntRect&gt; m_rect;
629     ImageBitmap::Promise m_promise;
630     SuspendableTimer m_createImageBitmapTimer;
631     RefPtr&lt;ArrayBuffer&gt; m_arrayBufferToProcess;
632 };
633 
634 void ImageBitmap::createFromBuffer(
635     Ref&lt;ArrayBuffer&gt;&amp;&amp; arrayBuffer,
636     String mimeType,
637     long long expectedContentLength,
638     const URL&amp; sourceUrl,
639     ImageBitmapOptions&amp;&amp; options,
640     Optional&lt;IntRect&gt; rect,
641     ImageBitmap::Promise&amp;&amp; promise)
642 {
643     if (!arrayBuffer-&gt;byteLength()) {
644         promise.reject(InvalidStateError, &quot;Cannot create an ImageBitmap from an empty buffer&quot;);
645         return;
646     }
647 
648     auto sharedBuffer = SharedBuffer::create(static_cast&lt;const char*&gt;(arrayBuffer-&gt;data()), arrayBuffer-&gt;byteLength());
649     auto observer = ImageBitmapImageObserver::create(mimeType, expectedContentLength, sourceUrl);
650     auto image = Image::create(observer.get());
651     if (!image) {
652         promise.reject(InvalidStateError, &quot;The type of the argument to createImageBitmap is not supported&quot;);
653         return;
654     }
655 
656     auto result = image-&gt;setData(sharedBuffer.copyRef(), true);
657     if (result != EncodedDataStatus::Complete) {
658         promise.reject(InvalidStateError, &quot;Cannot decode the data in the argument to createImageBitmap&quot;);
659         return;
660     }
661 
662     auto sourceRectangle = croppedSourceRectangleWithFormatting(roundedIntSize(image-&gt;size()), options, rect);
663     if (sourceRectangle.hasException()) {
664         promise.reject(sourceRectangle.releaseException());
665         return;
666     }
667 
668     auto outputSize = outputSizeForSourceRectangle(sourceRectangle.returnValue(), options);
669     auto bitmapData = ImageBuffer::create(FloatSize(outputSize.width(), outputSize.height()), bufferRenderingMode);
670     if (!bitmapData) {
671         promise.reject(InvalidStateError, &quot;Cannot create an image buffer from the argument to createImageBitmap&quot;);
672         return;
673     }
674 
675     FloatRect destRect(FloatPoint(), outputSize);
676     bitmapData-&gt;context().drawImage(*image, destRect, sourceRectangle.releaseReturnValue(), { interpolationQualityForResizeQuality(options.resizeQuality) });
677 
678     auto imageBitmap = create(WTFMove(bitmapData));
679 
680     promise.resolve(WTFMove(imageBitmap));
681 }
682 
683 void ImageBitmap::createPromise(ScriptExecutionContext&amp; scriptExecutionContext, RefPtr&lt;Blob&gt;&amp; blob, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)
684 {
685     // 2. Return a new promise, but continue running these steps in parallel.
686     PendingImageBitmap::fetch(scriptExecutionContext, WTFMove(blob), WTFMove(options), WTFMove(rect), WTFMove(promise));
687 }
688 
689 void ImageBitmap::createPromise(ScriptExecutionContext&amp;, RefPtr&lt;ImageData&gt;&amp; imageData, ImageBitmapOptions&amp;&amp; options, Optional&lt;IntRect&gt; rect, ImageBitmap::Promise&amp;&amp; promise)
690 {
691     UNUSED_PARAM(imageData);
692     UNUSED_PARAM(options);
693     UNUSED_PARAM(rect);
694 
695     // 2. If the image object&#39;s data attribute value&#39;s [[Detached]] internal slot value
696     //    is true, return a promise rejected with an &quot;InvalidStateError&quot; DOMException
697     //    and abort these steps.
698 
699     // 3. Create a new ImageBitmap object.
700 
701     // 4. Let the ImageBitmap object&#39;s bitmap data be the image data given by the ImageData
702     //    object, cropped to the source rectangle with formatting.
703 
704     // 5. Return a new promise, but continue running these steps in parallel.
705     // 6. Resolve the promise with the new ImageBitmap object as the value.
706     promise.reject(TypeError, &quot;createImageBitmap with ImageData is not implemented&quot;);
707 }
708 
709 ImageBitmap::ImageBitmap(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp; buffer)
710     : m_bitmapData(WTFMove(buffer))
711 {
712     ASSERT(m_bitmapData);
713 }
714 
715 ImageBitmap::~ImageBitmap() = default;
716 
717 unsigned ImageBitmap::width() const
718 {
719     if (m_detached || !m_bitmapData)
720         return 0;
721 
722     // FIXME: Is this the right width?
723     return m_bitmapData-&gt;logicalSize().width();
724 }
725 
726 unsigned ImageBitmap::height() const
727 {
728     if (m_detached || !m_bitmapData)
729         return 0;
730 
731     // FIXME: Is this the right height?
732     return m_bitmapData-&gt;logicalSize().height();
733 }
734 
735 void ImageBitmap::close()
736 {
737     m_detached = true;
738     m_bitmapData = nullptr;
739 }
740 
741 std::unique_ptr&lt;ImageBuffer&gt; ImageBitmap::transferOwnershipAndClose()
742 {
743     m_detached = true;
744     return WTFMove(m_bitmapData);
745 }
746 
747 }
    </pre>
  </body>
</html>
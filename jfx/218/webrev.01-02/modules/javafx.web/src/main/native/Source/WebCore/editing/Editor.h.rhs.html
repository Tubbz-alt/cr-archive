<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/editing/Editor.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2006, 2007, 2008, 2013, 2014 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;CompositionUnderline.h&quot;
 29 #include &quot;DictationAlternative.h&quot;
 30 #include &quot;DocumentMarker.h&quot;
 31 #include &quot;EditAction.h&quot;
 32 #include &quot;EditingBehavior.h&quot;
 33 #include &quot;EditingStyle.h&quot;
 34 #include &quot;EditorInsertAction.h&quot;
 35 #include &quot;FindOptions.h&quot;
 36 #include &quot;FrameSelection.h&quot;
 37 #include &quot;PasteboardWriterData.h&quot;
 38 #include &quot;TextChecking.h&quot;
 39 #include &quot;TextEventInputType.h&quot;
 40 #include &quot;TextIteratorBehavior.h&quot;
 41 #include &quot;VisibleSelection.h&quot;
 42 #include &quot;WritingDirection.h&quot;
 43 #include &lt;memory&gt;
 44 
 45 #if PLATFORM(COCOA)
 46 OBJC_CLASS NSAttributedString;
 47 OBJC_CLASS NSDictionary;
 48 OBJC_CLASS NSMutableDictionary;
 49 #endif
 50 
 51 namespace PAL {
 52 class KillRing;
 53 }
 54 
 55 namespace WebCore {
 56 
 57 class AlternativeTextController;
 58 class ArchiveResource;
 59 class DataTransfer;
 60 class CompositeEditCommand;
 61 class CustomUndoStep;
 62 class DeleteButtonController;
 63 class EditCommand;
 64 class EditCommandComposition;
 65 class EditorClient;
 66 class EditorInternalCommand;
 67 class File;
 68 class Frame;
 69 class HTMLElement;
 70 class HitTestResult;
 71 class KeyboardEvent;
 72 class KillRing;
 73 class Pasteboard;
 74 class PasteboardWriterData;
<a name="1" id="anc1"></a><span class="line-added"> 75 class RenderLayer;</span>
 76 class SharedBuffer;
 77 class Font;
 78 class SpellCheckRequest;
 79 class SpellChecker;
 80 class StaticRange;
 81 class StyleProperties;
 82 class Text;
 83 class TextCheckerClient;
 84 class TextEvent;
 85 
<a name="2" id="anc2"></a><span class="line-added"> 86 struct CompositionHighlight;</span>
 87 struct FontAttributes;
 88 struct PasteboardPlainText;
 89 struct PasteboardURL;
 90 struct TextCheckingResult;
 91 
 92 #if ENABLE(ATTACHMENT_ELEMENT)
 93 struct SerializedAttachmentData;
 94 #endif
 95 
 96 enum EditorCommandSource { CommandFromMenuOrKeyBinding, CommandFromDOM, CommandFromDOMWithUserInterface };
 97 enum EditorParagraphSeparator { EditorParagraphSeparatorIsDiv, EditorParagraphSeparatorIsP };
 98 
 99 enum class MailBlockquoteHandling {
100     RespectBlockquote,
101     IgnoreBlockquote,
102 };
103 
104 #if ENABLE(ATTACHMENT_ELEMENT)
105 class HTMLAttachmentElement;
106 #endif
107 
108 enum class TemporarySelectionOption : uint8_t {
109     RevealSelection = 1 &lt;&lt; 0,
110     DoNotSetFocus = 1 &lt;&lt; 1,
111 
112     // Don&#39;t propagate selection changes to the client layer.
113     IgnoreSelectionChanges = 1 &lt;&lt; 2,
114 
115     // Force the render tree to update selection state. Only respected on iOS.
116     EnableAppearanceUpdates = 1 &lt;&lt; 3,
117 };
118 
119 class TemporarySelectionChange {
120 public:
121     TemporarySelectionChange(Frame&amp;, Optional&lt;VisibleSelection&gt; = WTF::nullopt, OptionSet&lt;TemporarySelectionOption&gt; = { });
122     ~TemporarySelectionChange();
123 
124 private:
125     void setSelection(const VisibleSelection&amp;);
126 
127     Ref&lt;Frame&gt; m_frame;
128     OptionSet&lt;TemporarySelectionOption&gt; m_options;
129     bool m_wasIgnoringSelectionChanges;
130 #if PLATFORM(IOS_FAMILY)
131     bool m_appearanceUpdatesWereEnabled;
132 #endif
133     Optional&lt;VisibleSelection&gt; m_selectionToRestore;
134 };
135 
136 class Editor {
137     WTF_MAKE_FAST_ALLOCATED;
138 public:
139     explicit Editor(Frame&amp;);
140     ~Editor();
141 
142     enum class PasteOption : uint8_t {
143         AllowPlainText = 1 &lt;&lt; 0,
144         IgnoreMailBlockquote = 1 &lt;&lt; 1,
145         AsQuotation = 1 &lt;&lt; 2,
146     };
147 
148     WEBCORE_EXPORT EditorClient* client() const;
149     WEBCORE_EXPORT TextCheckerClient* textChecker() const;
150 
151     CompositeEditCommand* lastEditCommand() { return m_lastEditCommand.get(); }
152 
153     void handleKeyboardEvent(KeyboardEvent&amp;);
154     void handleInputMethodKeydown(KeyboardEvent&amp;);
<a name="3" id="anc3"></a><span class="line-added">155     void didDispatchInputMethodKeydown(KeyboardEvent&amp;);</span>
156     bool handleTextEvent(TextEvent&amp;);
157 
158     WEBCORE_EXPORT bool canEdit() const;
159     WEBCORE_EXPORT bool canEditRichly() const;
160 
161     bool canDHTMLCut();
162     bool canDHTMLCopy();
163     WEBCORE_EXPORT bool canDHTMLPaste();
164     bool tryDHTMLCopy();
165     bool tryDHTMLCut();
166 
167     WEBCORE_EXPORT bool canCut() const;
168     WEBCORE_EXPORT bool canCopy() const;
169     WEBCORE_EXPORT bool canPaste() const;
170     WEBCORE_EXPORT bool canDelete() const;
171     WEBCORE_EXPORT bool canSmartCopyOrDelete();
172     bool shouldSmartDelete();
173 
174     WEBCORE_EXPORT void cut();
175     WEBCORE_EXPORT void copy();
176     WEBCORE_EXPORT void paste();
177     void paste(Pasteboard&amp;);
178     WEBCORE_EXPORT void pasteAsPlainText();
179     void pasteAsQuotation();
180     WEBCORE_EXPORT void performDelete();
181 
182     WEBCORE_EXPORT void copyURL(const URL&amp;, const String&amp; title);
183     void copyURL(const URL&amp;, const String&amp; title, Pasteboard&amp;);
184     PasteboardWriterData::URLData pasteboardWriterURL(const URL&amp;, const String&amp; title);
185 #if !PLATFORM(IOS_FAMILY)
186     WEBCORE_EXPORT void copyImage(const HitTestResult&amp;);
187 #endif
188 
<a name="4" id="anc4"></a><span class="line-added">189     void renderLayerDidScroll(const RenderLayer&amp;);</span>
<span class="line-added">190     void revealSelectionIfNeededAfterLoadingImageForElement(HTMLImageElement&amp;);</span>
<span class="line-added">191 </span>
192     String readPlainTextFromPasteboard(Pasteboard&amp;);
193 
194     WEBCORE_EXPORT void indent();
195     WEBCORE_EXPORT void outdent();
196     void transpose();
197 
198     bool shouldInsertFragment(DocumentFragment&amp;, Range*, EditorInsertAction);
199     bool shouldInsertText(const String&amp;, Range*, EditorInsertAction) const;
200     WEBCORE_EXPORT bool shouldDeleteRange(Range*) const;
201     bool shouldApplyStyle(StyleProperties*, Range*);
202 
203     void respondToChangedContents(const VisibleSelection&amp; endingSelection);
204 
205     bool selectionStartHasStyle(CSSPropertyID, const String&amp; value) const;
206     WEBCORE_EXPORT TriState selectionHasStyle(CSSPropertyID, const String&amp; value) const;
207     String selectionStartCSSPropertyValue(CSSPropertyID);
208 
209     TriState selectionUnorderedListState() const;
210     TriState selectionOrderedListState() const;
211     WEBCORE_EXPORT RefPtr&lt;Node&gt; insertOrderedList();
212     WEBCORE_EXPORT RefPtr&lt;Node&gt; insertUnorderedList();
213     WEBCORE_EXPORT bool canIncreaseSelectionListLevel();
214     WEBCORE_EXPORT bool canDecreaseSelectionListLevel();
215     WEBCORE_EXPORT RefPtr&lt;Node&gt; increaseSelectionListLevel();
216     WEBCORE_EXPORT RefPtr&lt;Node&gt; increaseSelectionListLevelOrdered();
217     WEBCORE_EXPORT RefPtr&lt;Node&gt; increaseSelectionListLevelUnordered();
218     WEBCORE_EXPORT void decreaseSelectionListLevel();
219     WEBCORE_EXPORT void changeSelectionListType();
220 
221     void removeFormattingAndStyle();
222 
223     void clearLastEditCommand();
224 #if PLATFORM(IOS_FAMILY)
225     WEBCORE_EXPORT void ensureLastEditCommandHasCurrentSelectionIfOpenForMoreTyping();
226 #endif
227 
228     WEBCORE_EXPORT bool deleteWithDirection(SelectionDirection, TextGranularity, bool killRing, bool isTypingAction);
229     WEBCORE_EXPORT void deleteSelectionWithSmartDelete(bool smartDelete, EditAction = EditAction::Delete);
230     void clearText();
231 #if PLATFORM(IOS_FAMILY)
232     WEBCORE_EXPORT void removeUnchangeableStyles();
233 #endif
234 
235     WEBCORE_EXPORT void applyStyle(StyleProperties*, EditAction = EditAction::Unspecified);
236     enum class ColorFilterMode { InvertColor, UseOriginalColor };
237     void applyStyle(RefPtr&lt;EditingStyle&gt;&amp;&amp;, EditAction, ColorFilterMode);
238     void applyParagraphStyle(StyleProperties*, EditAction = EditAction::Unspecified);
239     WEBCORE_EXPORT void applyStyleToSelection(StyleProperties*, EditAction);
240     WEBCORE_EXPORT void applyStyleToSelection(Ref&lt;EditingStyle&gt;&amp;&amp;, EditAction, ColorFilterMode);
241     void applyParagraphStyleToSelection(StyleProperties*, EditAction);
242 
243     // Returns whether or not we should proceed with editing.
244     bool willApplyEditing(CompositeEditCommand&amp;, Vector&lt;RefPtr&lt;StaticRange&gt;&gt;&amp;&amp;) const;
245     bool willUnapplyEditing(const EditCommandComposition&amp;) const;
246     bool willReapplyEditing(const EditCommandComposition&amp;) const;
247 
248     void appliedEditing(CompositeEditCommand&amp;);
249     void unappliedEditing(EditCommandComposition&amp;);
250     void reappliedEditing(EditCommandComposition&amp;);
251     void unappliedSpellCorrection(const VisibleSelection&amp; selectionOfCorrected, const String&amp; corrected, const String&amp; correction);
252 
253     // This is off by default, since most editors want this behavior (originally matched IE but not Firefox).
254     void setShouldStyleWithCSS(bool flag) { m_shouldStyleWithCSS = flag; }
255     bool shouldStyleWithCSS() const { return m_shouldStyleWithCSS; }
256 
257     class Command {
258     public:
259         WEBCORE_EXPORT Command();
260         Command(const EditorInternalCommand*, EditorCommandSource, Frame&amp;);
261 
262         WEBCORE_EXPORT bool execute(const String&amp; parameter = String(), Event* triggeringEvent = nullptr) const;
263         WEBCORE_EXPORT bool execute(Event* triggeringEvent) const;
264 
265         WEBCORE_EXPORT bool isSupported() const;
266         WEBCORE_EXPORT bool isEnabled(Event* triggeringEvent = nullptr) const;
267 
268         WEBCORE_EXPORT TriState state(Event* triggeringEvent = nullptr) const;
269         String value(Event* triggeringEvent = nullptr) const;
270 
271         WEBCORE_EXPORT bool isTextInsertion() const;
272         WEBCORE_EXPORT bool allowExecutionWhenDisabled() const;
273 
274     private:
275         const EditorInternalCommand* m_command { nullptr };
276         EditorCommandSource m_source;
277         RefPtr&lt;Frame&gt; m_frame;
278     };
279     WEBCORE_EXPORT Command command(const String&amp; commandName); // Command source is CommandFromMenuOrKeyBinding.
280     Command command(const String&amp; commandName, EditorCommandSource);
281     WEBCORE_EXPORT static bool commandIsSupportedFromMenuOrKeyBinding(const String&amp; commandName); // Works without a frame.
282 
283     WEBCORE_EXPORT bool insertText(const String&amp;, Event* triggeringEvent, TextEventInputType = TextEventInputKeyboard);
284     bool insertTextForConfirmedComposition(const String&amp; text);
285     WEBCORE_EXPORT bool insertDictatedText(const String&amp;, const Vector&lt;DictationAlternative&gt;&amp; dictationAlternatives, Event* triggeringEvent);
286     bool insertTextWithoutSendingTextEvent(const String&amp;, bool selectInsertedText, TextEvent* triggeringEvent);
287     bool insertLineBreak();
288     bool insertParagraphSeparator();
289     WEBCORE_EXPORT bool insertParagraphSeparatorInQuotedContent();
290 
291     WEBCORE_EXPORT bool isContinuousSpellCheckingEnabled() const;
292     WEBCORE_EXPORT void toggleContinuousSpellChecking();
293     bool isGrammarCheckingEnabled();
294     void toggleGrammarChecking();
295     void ignoreSpelling();
296     void learnSpelling();
297     int spellCheckerDocumentTag();
298     WEBCORE_EXPORT bool isSelectionUngrammatical();
299     String misspelledSelectionString() const;
300     String misspelledWordAtCaretOrRange(Node* clickedNode) const;
301     Vector&lt;String&gt; guessesForMisspelledWord(const String&amp;) const;
302     Vector&lt;String&gt; guessesForMisspelledOrUngrammatical(bool&amp; misspelled, bool&amp; ungrammatical);
303     bool isSpellCheckingEnabledInFocusedNode() const;
304     bool isSpellCheckingEnabledFor(Node*) const;
305     WEBCORE_EXPORT void markMisspellingsAfterTypingToWord(const VisiblePosition &amp;wordStart, const VisibleSelection&amp; selectionAfterTyping, bool doReplacement);
306     void markMisspellings(const VisibleSelection&amp;, RefPtr&lt;Range&gt;&amp; firstMisspellingRange);
307     void markBadGrammar(const VisibleSelection&amp;);
308     void markMisspellingsAndBadGrammar(const VisibleSelection&amp; spellingSelection, bool markGrammar, const VisibleSelection&amp; grammarSelection);
309     void markAndReplaceFor(const SpellCheckRequest&amp;, const Vector&lt;TextCheckingResult&gt;&amp;);
310     WEBCORE_EXPORT void replaceRangeForSpellChecking(Range&amp;, const String&amp;);
311 
312     bool isOverwriteModeEnabled() const { return m_overwriteModeEnabled; }
313     WEBCORE_EXPORT void toggleOverwriteModeEnabled();
314 
315     void markAllMisspellingsAndBadGrammarInRanges(OptionSet&lt;TextCheckingType&gt;, RefPtr&lt;Range&gt;&amp;&amp; spellingRange, RefPtr&lt;Range&gt;&amp;&amp; automaticReplacementRange, RefPtr&lt;Range&gt;&amp;&amp; grammarRange);
316 #if PLATFORM(IOS_FAMILY)
317     NO_RETURN_DUE_TO_ASSERT
318 #endif
319     void changeBackToReplacedString(const String&amp; replacedString);
320 
321 #if !PLATFORM(IOS_FAMILY)
322     WEBCORE_EXPORT void advanceToNextMisspelling(bool startBeforeSelection = false);
323 #endif
324     void showSpellingGuessPanel();
325     bool spellingPanelIsShowing();
326 
327     bool shouldBeginEditing(Range*);
328     bool shouldEndEditing(Range*);
329 
330     void clearUndoRedoOperations();
331     bool canUndo() const;
332     void undo();
333     bool canRedo() const;
334     void redo();
335 
336     void registerCustomUndoStep(Ref&lt;CustomUndoStep&gt;&amp;&amp;);
337 
338     void didBeginEditing();
339     void didEndEditing();
340     void willWriteSelectionToPasteboard(Range*);
341     void didWriteSelectionToPasteboard();
342 
343     void showFontPanel();
344     void showStylesPanel();
345     void showColorPanel();
346     void toggleBold();
347     void toggleUnderline();
348     WEBCORE_EXPORT void setBaseWritingDirection(WritingDirection);
349 
350     // smartInsertDeleteEnabled and selectTrailingWhitespaceEnabled are
351     // mutually exclusive, meaning that enabling one will disable the other.
352     bool smartInsertDeleteEnabled();
353     bool isSelectTrailingWhitespaceEnabled() const;
354 
355     WEBCORE_EXPORT bool hasBidiSelection() const;
356 
357     // international text input composition
358     bool hasComposition() const { return m_compositionNode; }
<a name="5" id="anc5"></a><span class="line-modified">359     WEBCORE_EXPORT void setComposition(const String&amp;, const Vector&lt;CompositionUnderline&gt;&amp;, const Vector&lt;CompositionHighlight&gt;&amp;, unsigned selectionStart, unsigned selectionEnd);</span>
360     WEBCORE_EXPORT void confirmComposition();
361     WEBCORE_EXPORT void confirmComposition(const String&amp;); // if no existing composition, replaces selection
362     WEBCORE_EXPORT void cancelComposition();
363     bool cancelCompositionIfSelectionIsInvalid();
364     WEBCORE_EXPORT RefPtr&lt;Range&gt; compositionRange() const;
365     WEBCORE_EXPORT bool getCompositionSelection(unsigned&amp; selectionStart, unsigned&amp; selectionEnd) const;
366 
367     // getting international text input composition state (for use by InlineTextBox)
368     Text* compositionNode() const { return m_compositionNode.get(); }
369     unsigned compositionStart() const { return m_compositionStart; }
370     unsigned compositionEnd() const { return m_compositionEnd; }
371     bool compositionUsesCustomUnderlines() const { return !m_customCompositionUnderlines.isEmpty(); }
372     const Vector&lt;CompositionUnderline&gt;&amp; customCompositionUnderlines() const { return m_customCompositionUnderlines; }
<a name="6" id="anc6"></a><span class="line-added">373     bool compositionUsesCustomHighlights() const { return !m_customCompositionHighlights.isEmpty(); }</span>
<span class="line-added">374     const Vector&lt;CompositionHighlight&gt;&amp; customCompositionHighlights() const { return m_customCompositionHighlights; }</span>
375 
376     enum class RevealSelection { No, Yes };
377     WEBCORE_EXPORT void setIgnoreSelectionChanges(bool, RevealSelection shouldRevealExistingSelection = RevealSelection::Yes);
378     bool ignoreSelectionChanges() const { return m_ignoreSelectionChanges; }
379 
380     WEBCORE_EXPORT RefPtr&lt;Range&gt; rangeForPoint(const IntPoint&amp; windowPoint);
381 
382     void clear();
383 
384     VisibleSelection selectionForCommand(Event*);
385 
386     PAL::KillRing&amp; killRing() const { return *m_killRing; }
387     SpellChecker&amp; spellChecker() const { return *m_spellChecker; }
388 
389     EditingBehavior behavior() const;
390 
391     RefPtr&lt;Range&gt; selectedRange();
392 
393 #if PLATFORM(IOS_FAMILY)
394     WEBCORE_EXPORT void confirmMarkedText();
395     WEBCORE_EXPORT void setTextAsChildOfElement(const String&amp;, Element&amp;);
396     WEBCORE_EXPORT void setTextAlignmentForChangedBaseWritingDirection(WritingDirection);
397     WEBCORE_EXPORT void insertDictationPhrases(Vector&lt;Vector&lt;String&gt;&gt;&amp;&amp; dictationPhrases, RetainPtr&lt;id&gt; metadata);
398     WEBCORE_EXPORT void setDictationPhrasesAsChildOfElement(const Vector&lt;Vector&lt;String&gt;&gt;&amp; dictationPhrases, RetainPtr&lt;id&gt; metadata, Element&amp;);
399 #endif
400 
401     enum class KillRingInsertionMode { PrependText, AppendText };
402     void addRangeToKillRing(const Range&amp;, KillRingInsertionMode);
403     void addTextToKillRing(const String&amp;, KillRingInsertionMode);
404     void setStartNewKillRingSequence(bool);
405 
406     void startAlternativeTextUITimer();
407     // If user confirmed a correction in the correction panel, correction has non-zero length, otherwise it means that user has dismissed the panel.
408     WEBCORE_EXPORT void handleAlternativeTextUIResult(const String&amp; correction);
409     void dismissCorrectionPanelAsIgnored();
410 
411     WEBCORE_EXPORT void pasteAsFragment(Ref&lt;DocumentFragment&gt;&amp;&amp;, bool smartReplace, bool matchStyle, MailBlockquoteHandling = MailBlockquoteHandling::RespectBlockquote);
412     WEBCORE_EXPORT void pasteAsPlainText(const String&amp;, bool smartReplace);
413 
414     // This is only called on the mac where paste is implemented primarily at the WebKit level.
415     WEBCORE_EXPORT void pasteAsPlainTextBypassingDHTML();
416 
417     void clearMisspellingsAndBadGrammar(const VisibleSelection&amp;);
418     void markMisspellingsAndBadGrammar(const VisibleSelection&amp;);
419 
420     Element* findEventTargetFrom(const VisibleSelection&amp; selection) const;
421 
422     WEBCORE_EXPORT String selectedText() const;
423     String selectedTextForDataTransfer() const;
424     WEBCORE_EXPORT bool findString(const String&amp;, FindOptions);
425 
426     WEBCORE_EXPORT RefPtr&lt;Range&gt; rangeOfString(const String&amp;, Range*, FindOptions);
427 
428     const VisibleSelection&amp; mark() const; // Mark, to be used as emacs uses it.
429     void setMark(const VisibleSelection&amp;);
430 
431     void computeAndSetTypingStyle(EditingStyle&amp; , EditAction = EditAction::Unspecified);
432     WEBCORE_EXPORT void computeAndSetTypingStyle(StyleProperties&amp; , EditAction = EditAction::Unspecified);
433     WEBCORE_EXPORT void applyEditingStyleToBodyElement() const;
434     void applyEditingStyleToElement(Element*) const;
435 
436     WEBCORE_EXPORT IntRect firstRectForRange(Range*) const;
437 
438     void selectionWillChange();
439     void respondToChangedSelection(const VisibleSelection&amp; oldSelection, OptionSet&lt;FrameSelection::SetSelectionOption&gt;);
440     WEBCORE_EXPORT void updateEditorUINowIfScheduled();
441     bool shouldChangeSelection(const VisibleSelection&amp; oldSelection, const VisibleSelection&amp; newSelection, EAffinity, bool stillSelecting) const;
442     WEBCORE_EXPORT unsigned countMatchesForText(const String&amp;, Range*, FindOptions, unsigned limit, bool markMatches, Vector&lt;RefPtr&lt;Range&gt;&gt;*);
443     bool markedTextMatchesAreHighlighted() const;
444     WEBCORE_EXPORT void setMarkedTextMatchesAreHighlighted(bool);
445 
446     void textFieldDidBeginEditing(Element*);
447     void textFieldDidEndEditing(Element*);
448     void textDidChangeInTextField(Element*);
449     bool doTextFieldCommandFromEvent(Element*, KeyboardEvent*);
450     void textWillBeDeletedInTextField(Element* input);
451     void textDidChangeInTextArea(Element*);
452     WEBCORE_EXPORT WritingDirection baseWritingDirectionForSelectionStart() const;
453 
454     enum class SelectReplacement : bool { No, Yes };
455     enum class SmartReplace : bool { No, Yes };
456     enum class MatchStyle : bool { No, Yes };
457     WEBCORE_EXPORT void replaceSelectionWithFragment(DocumentFragment&amp;, SelectReplacement, SmartReplace, MatchStyle, EditAction = EditAction::Insert, MailBlockquoteHandling = MailBlockquoteHandling::RespectBlockquote);
458     WEBCORE_EXPORT void replaceSelectionWithText(const String&amp;, SelectReplacement, SmartReplace, EditAction = EditAction::Insert);
459     WEBCORE_EXPORT bool selectionStartHasMarkerFor(DocumentMarker::MarkerType, int from, int length) const;
460     void updateMarkersForWordsAffectedByEditing(bool onlyHandleWordsContainingSelection);
461     void deletedAutocorrectionAtPosition(const Position&amp;, const String&amp; originalString);
462 
463     WEBCORE_EXPORT void simplifyMarkup(Node* startNode, Node* endNode);
464 
465     EditorParagraphSeparator defaultParagraphSeparator() const { return m_defaultParagraphSeparator; }
466     void setDefaultParagraphSeparator(EditorParagraphSeparator separator) { m_defaultParagraphSeparator = separator; }
467     Vector&lt;String&gt; dictationAlternativesForMarker(const DocumentMarker&amp;);
468     void applyDictationAlternativelternative(const String&amp; alternativeString);
469 
470 #if USE(APPKIT)
471     WEBCORE_EXPORT void uppercaseWord();
472     WEBCORE_EXPORT void lowercaseWord();
473     WEBCORE_EXPORT void capitalizeWord();
474 #endif
475 
476 #if USE(AUTOMATIC_TEXT_REPLACEMENT)
477     WEBCORE_EXPORT void showSubstitutionsPanel();
478     WEBCORE_EXPORT bool substitutionsPanelIsShowing();
479     WEBCORE_EXPORT void toggleSmartInsertDelete();
480     WEBCORE_EXPORT bool isAutomaticQuoteSubstitutionEnabled();
481     WEBCORE_EXPORT void toggleAutomaticQuoteSubstitution();
482     WEBCORE_EXPORT bool isAutomaticLinkDetectionEnabled();
483     WEBCORE_EXPORT void toggleAutomaticLinkDetection();
484     WEBCORE_EXPORT bool isAutomaticDashSubstitutionEnabled();
485     WEBCORE_EXPORT void toggleAutomaticDashSubstitution();
486     WEBCORE_EXPORT bool isAutomaticTextReplacementEnabled();
487     WEBCORE_EXPORT void toggleAutomaticTextReplacement();
488     WEBCORE_EXPORT bool isAutomaticSpellingCorrectionEnabled();
489     WEBCORE_EXPORT void toggleAutomaticSpellingCorrection();
490 #endif
491 
492     RefPtr&lt;DocumentFragment&gt; webContentFromPasteboard(Pasteboard&amp;, Range&amp; context, bool allowPlainText, bool&amp; chosePlainText);
493 
494     WEBCORE_EXPORT const Font* fontForSelection(bool&amp; hasMultipleFonts) const;
495     WEBCORE_EXPORT static const RenderStyle* styleForSelectionStart(Frame* , Node *&amp;nodeToRemove);
496     WEBCORE_EXPORT FontAttributes fontAttributesAtSelectionStart() const;
497 
498 #if PLATFORM(COCOA)
499     WEBCORE_EXPORT String stringSelectionForPasteboard();
500     String stringSelectionForPasteboardWithImageAltText();
501     void takeFindStringFromSelection();
502 #if !PLATFORM(IOS_FAMILY)
503     WEBCORE_EXPORT void readSelectionFromPasteboard(const String&amp; pasteboardName);
504     WEBCORE_EXPORT void replaceNodeFromPasteboard(Node*, const String&amp; pasteboardName);
505     WEBCORE_EXPORT RefPtr&lt;SharedBuffer&gt; dataSelectionForPasteboard(const String&amp; pasteboardName);
506 #endif // !PLATFORM(IOS_FAMILY)
507     WEBCORE_EXPORT void replaceSelectionWithAttributedString(NSAttributedString *, MailBlockquoteHandling = MailBlockquoteHandling::RespectBlockquote);
508 #endif
509 
510     bool canCopyExcludingStandaloneImages() const;
511 
512 #if !PLATFORM(WIN)
513     WEBCORE_EXPORT void writeSelectionToPasteboard(Pasteboard&amp;);
514     WEBCORE_EXPORT void writeImageToPasteboard(Pasteboard&amp;, Element&amp; imageElement, const URL&amp;, const String&amp; title);
515     void writeSelection(PasteboardWriterData&amp;);
516 #endif
517 
518 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
519     void scanSelectionForTelephoneNumbers();
520     const Vector&lt;RefPtr&lt;Range&gt;&gt;&amp; detectedTelephoneNumberRanges() const { return m_detectedTelephoneNumberRanges; }
521 #endif
522 
523     WEBCORE_EXPORT String stringForCandidateRequest() const;
524     WEBCORE_EXPORT void handleAcceptedCandidate(TextCheckingResult);
525     WEBCORE_EXPORT RefPtr&lt;Range&gt; contextRangeForCandidateRequest() const;
526     RefPtr&lt;Range&gt; rangeForTextCheckingResult(const TextCheckingResult&amp;) const;
527     bool isHandlingAcceptedCandidate() const { return m_isHandlingAcceptedCandidate; }
528 
529     void setIsGettingDictionaryPopupInfo(bool b) { m_isGettingDictionaryPopupInfo = b; }
530     bool isGettingDictionaryPopupInfo() const { return m_isGettingDictionaryPopupInfo; }
531 
532 #if ENABLE(ATTACHMENT_ELEMENT)
533     WEBCORE_EXPORT void insertAttachment(const String&amp; identifier, Optional&lt;uint64_t&gt;&amp;&amp; fileSize, const String&amp; fileName, const String&amp; contentType);
534     void registerAttachmentIdentifier(const String&amp;, const String&amp; contentType, const String&amp; preferredFileName, Ref&lt;SharedBuffer&gt;&amp;&amp; fileData);
535     void registerAttachments(Vector&lt;SerializedAttachmentData&gt;&amp;&amp;);
536     void registerAttachmentIdentifier(const String&amp;, const String&amp; contentType, const String&amp; filePath);
537     void registerAttachmentIdentifier(const String&amp;);
538     void cloneAttachmentData(const String&amp; fromIdentifier, const String&amp; toIdentifier);
539     void didInsertAttachmentElement(HTMLAttachmentElement&amp;);
540     void didRemoveAttachmentElement(HTMLAttachmentElement&amp;);
541 
542 #if PLATFORM(COCOA)
543     void getPasteboardTypesAndDataForAttachment(Element&amp;, Vector&lt;String&gt;&amp; outTypes, Vector&lt;RefPtr&lt;SharedBuffer&gt;&gt;&amp; outData);
544 #endif
545 #endif
546 
547     WEBCORE_EXPORT RefPtr&lt;HTMLImageElement&gt; insertEditableImage();
548 
549 private:
550     Document&amp; document() const;
551 
552     bool canDeleteRange(Range*) const;
553     bool canSmartReplaceWithPasteboard(Pasteboard&amp;);
554     void pasteAsPlainTextWithPasteboard(Pasteboard&amp;);
555     void pasteWithPasteboard(Pasteboard*, OptionSet&lt;PasteOption&gt;);
556     String plainTextFromPasteboard(const PasteboardPlainText&amp;);
557 
558     void quoteFragmentForPasting(DocumentFragment&amp;);
559 
560     void revealSelectionAfterEditingOperation(const ScrollAlignment&amp; = ScrollAlignment::alignCenterIfNeeded, RevealExtentOption = DoNotRevealExtent);
561     void markMisspellingsOrBadGrammar(const VisibleSelection&amp;, bool checkSpelling, RefPtr&lt;Range&gt;&amp; firstMisspellingRange);
562     OptionSet&lt;TextCheckingType&gt; resolveTextCheckingTypeMask(const Node&amp; rootEditableElement, OptionSet&lt;TextCheckingType&gt;);
563 
564     WEBCORE_EXPORT String selectedText(TextIteratorBehavior) const;
565 
566     void selectComposition();
567     enum SetCompositionMode { ConfirmComposition, CancelComposition };
568     void setComposition(const String&amp;, SetCompositionMode);
569 
570     void changeSelectionAfterCommand(const VisibleSelection&amp; newSelection, OptionSet&lt;FrameSelection::SetSelectionOption&gt;);
571 
572     enum EditorActionSpecifier { CutAction, CopyAction };
573     void performCutOrCopy(EditorActionSpecifier);
574 
575     void editorUIUpdateTimerFired();
576 
577     Element* findEventTargetFromSelection() const;
578 
579     bool unifiedTextCheckerEnabled() const;
580 
581     RefPtr&lt;Range&gt; adjustedSelectionRange();
582 
583 #if PLATFORM(COCOA)
584     RefPtr&lt;SharedBuffer&gt; selectionInWebArchiveFormat();
585     String selectionInHTMLFormat();
586     RefPtr&lt;SharedBuffer&gt; imageInWebArchiveFormat(Element&amp;);
587     static String userVisibleString(const URL&amp;);
588     static RefPtr&lt;SharedBuffer&gt; dataInRTFDFormat(NSAttributedString *);
589     static RefPtr&lt;SharedBuffer&gt; dataInRTFFormat(NSAttributedString *);
590 #endif
591     void platformFontAttributesAtSelectionStart(FontAttributes&amp;, const RenderStyle&amp;) const;
592 
593     void scheduleEditorUIUpdate();
594 
595 #if ENABLE(ATTACHMENT_ELEMENT)
596     void notifyClientOfAttachmentUpdates();
597 #endif
598 
599     void postTextStateChangeNotificationForCut(const String&amp;, const VisibleSelection&amp;);
600 
601     Frame&amp; m_frame;
602     RefPtr&lt;CompositeEditCommand&gt; m_lastEditCommand;
603     RefPtr&lt;Text&gt; m_compositionNode;
604     unsigned m_compositionStart;
605     unsigned m_compositionEnd;
606     Vector&lt;CompositionUnderline&gt; m_customCompositionUnderlines;
<a name="7" id="anc7"></a><span class="line-added">607     Vector&lt;CompositionHighlight&gt; m_customCompositionHighlights;</span>
608     bool m_ignoreSelectionChanges { false };
609     bool m_shouldStartNewKillRingSequence { false };
610     bool m_shouldStyleWithCSS { false };
611     const std::unique_ptr&lt;PAL::KillRing&gt; m_killRing;
612     const std::unique_ptr&lt;SpellChecker&gt; m_spellChecker;
613     const std::unique_ptr&lt;AlternativeTextController&gt; m_alternativeTextController;
614     EditorParagraphSeparator m_defaultParagraphSeparator { EditorParagraphSeparatorIsDiv };
615     bool m_overwriteModeEnabled { false };
616 
617 #if ENABLE(ATTACHMENT_ELEMENT)
618     HashSet&lt;String&gt; m_insertedAttachmentIdentifiers;
619     HashSet&lt;String&gt; m_removedAttachmentIdentifiers;
620 #endif
621 
622     VisibleSelection m_mark;
623     bool m_areMarkedTextMatchesHighlighted { false };
624 
625     VisibleSelection m_oldSelectionForEditorUIUpdate;
626     Timer m_editorUIUpdateTimer;
627     bool m_editorUIUpdateTimerShouldCheckSpellingAndGrammar { false };
628     bool m_editorUIUpdateTimerWasTriggeredByDictation { false };
629     bool m_isHandlingAcceptedCandidate { false };
630 
631 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
632     bool shouldDetectTelephoneNumbers();
633     void scanRangeForTelephoneNumbers(Range&amp;, const StringView&amp;, Vector&lt;RefPtr&lt;Range&gt;&gt;&amp; markedRanges);
634 
635     Timer m_telephoneNumberDetectionUpdateTimer;
636     Vector&lt;RefPtr&lt;Range&gt;&gt; m_detectedTelephoneNumberRanges;
637 #endif
638 
639     bool m_isGettingDictionaryPopupInfo { false };
<a name="8" id="anc8"></a><span class="line-added">640     HashSet&lt;RefPtr&lt;HTMLImageElement&gt;&gt; m_imageElementsToLoadBeforeRevealingSelection;</span>
641 };
642 
643 inline void Editor::setStartNewKillRingSequence(bool flag)
644 {
645     m_shouldStartNewKillRingSequence = flag;
646 }
647 
648 inline const VisibleSelection&amp; Editor::mark() const
649 {
650     return m_mark;
651 }
652 
653 inline void Editor::setMark(const VisibleSelection&amp; selection)
654 {
655     m_mark = selection;
656 }
657 
658 inline bool Editor::markedTextMatchesAreHighlighted() const
659 {
660     return m_areMarkedTextMatchesHighlighted;
661 }
662 
663 } // namespace WebCore
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/OffscreenCanvas.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MediaEncryptedEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="OffscreenCanvas.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/OffscreenCanvas.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;OffscreenCanvas.h&quot;
 28 



 29 #include &quot;CanvasRenderingContext.h&quot;
 30 #include &quot;ImageBitmap.h&quot;




 31 #include &quot;WebGLRenderingContext.h&quot;

 32 #include &lt;wtf/IsoMallocInlines.h&gt;
 33 
 34 namespace WebCore {
 35 
 36 WTF_MAKE_ISO_ALLOCATED_IMPL(OffscreenCanvas);
 37 












 38 Ref&lt;OffscreenCanvas&gt; OffscreenCanvas::create(ScriptExecutionContext&amp; context, unsigned width, unsigned height)
 39 {
 40     return adoptRef(*new OffscreenCanvas(context, width, height));
 41 }
 42 










 43 OffscreenCanvas::OffscreenCanvas(ScriptExecutionContext&amp; context, unsigned width, unsigned height)
<span class="line-modified"> 44     : ContextDestructionObserver(&amp;context)</span>
<span class="line-modified"> 45     , m_size(width, height)</span>
 46 {
 47 }
 48 
 49 OffscreenCanvas::~OffscreenCanvas()
 50 {
 51     notifyObserversCanvasDestroyed();
 52 
<span class="line-modified"> 53     m_context = nullptr;</span>

 54 }
 55 
 56 unsigned OffscreenCanvas::width() const
 57 {
<span class="line-modified"> 58     return m_size.width();</span>
<span class="line-modified"> 59 }</span>
<span class="line-modified"> 60 </span>
<span class="line-removed"> 61 void OffscreenCanvas::setWidth(unsigned newWidth)</span>
<span class="line-removed"> 62 {</span>
<span class="line-removed"> 63     return m_size.setWidth(newWidth);</span>
 64 }
 65 
 66 unsigned OffscreenCanvas::height() const
 67 {
<span class="line-modified"> 68     return m_size.height();</span>


 69 }
 70 
<span class="line-modified"> 71 void OffscreenCanvas::setHeight(unsigned newHeight)</span>
 72 {
<span class="line-modified"> 73     return m_size.setHeight(newHeight);</span>


 74 }
 75 
<span class="line-modified"> 76 const IntSize&amp; OffscreenCanvas::size() const</span>
 77 {
<span class="line-modified"> 78     return m_size;</span>


 79 }
 80 
 81 void OffscreenCanvas::setSize(const IntSize&amp; newSize)
 82 {
<span class="line-modified"> 83     m_size = newSize;</span>

 84 }
 85 
<span class="line-modified"> 86 #if ENABLE(WEBGL)</span>
<span class="line-removed"> 87 ExceptionOr&lt;OffscreenRenderingContext&gt; OffscreenCanvas::getContext(JSC::ExecState&amp; state, RenderingContextType contextType, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>
 88 {
<span class="line-modified"> 89     if (m_context &amp;&amp; contextType == RenderingContextType::Webgl)</span>
<span class="line-modified"> 90         return { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*m_context) } };</span>











 91 



 92     if (contextType == RenderingContextType::Webgl) {






 93         auto scope = DECLARE_THROW_SCOPE(state.vm());
 94         auto attributes = convert&lt;IDLDictionary&lt;WebGLContextAttributes&gt;&gt;(state, !arguments.isEmpty() ? arguments[0].get() : JSC::jsUndefined());
 95         RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
 96 
 97         m_context = WebGLRenderingContextBase::create(*this, attributes, &quot;webgl&quot;);
 98         if (!m_context)
<span class="line-modified"> 99             return { nullptr };</span>
100 
101         return { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*m_context) } };
102     }

103 
<span class="line-modified">104     return { nullptr };</span>
105 }
<span class="line-removed">106 #endif</span>
107 
<span class="line-modified">108 RefPtr&lt;ImageBitmap&gt; OffscreenCanvas::transferToImageBitmap()</span>
109 {
<span class="line-modified">110     if (!m_context)</span>
<span class="line-modified">111         return nullptr;</span>














112 
113 #if ENABLE(WEBGL)
<span class="line-modified">114     if (!is&lt;WebGLRenderingContext&gt;(*m_context))</span>

































































































115         return nullptr;
116 
<span class="line-modified">117     auto webGLContext = &amp;downcast&lt;WebGLRenderingContext&gt;(*m_context);</span>




















118 
<span class="line-modified">119     // FIXME: We&#39;re supposed to create an ImageBitmap using the backing</span>
<span class="line-modified">120     // store from this canvas (or its context), but for now we&#39;ll just</span>
<span class="line-modified">121     // create a new bitmap and paint into it.</span>




122 
<span class="line-modified">123     auto imageBitmap = ImageBitmap::create(m_size);</span>
<span class="line-modified">124     if (!imageBitmap-&gt;buffer())</span>



125         return nullptr;
126 
<span class="line-modified">127     auto* gc3d = webGLContext-&gt;graphicsContext3D();</span>
<span class="line-modified">128     gc3d-&gt;paintRenderingResultsToCanvas(imageBitmap-&gt;buffer());</span>
129 
<span class="line-modified">130     // FIXME: The transfer algorithm requires that the canvas effectively</span>
<span class="line-modified">131     // creates a new backing store. Since we&#39;re not doing that yet, we</span>
<span class="line-modified">132     // need to erase what&#39;s there.</span>


133 
<span class="line-modified">134     GC3Dfloat clearColor[4];</span>
<span class="line-modified">135     gc3d-&gt;getFloatv(GraphicsContext3D::COLOR_CLEAR_VALUE, clearColor);</span>
<span class="line-removed">136     gc3d-&gt;clearColor(0, 0, 0, 0);</span>
<span class="line-removed">137     gc3d-&gt;clear(GraphicsContext3D::COLOR_BUFFER_BIT | GraphicsContext3D::DEPTH_BUFFER_BIT | GraphicsContext3D::STENCIL_BUFFER_BIT);</span>
<span class="line-removed">138     gc3d-&gt;clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);</span>
139 
<span class="line-modified">140     return imageBitmap;</span>
<span class="line-removed">141 #else</span>
<span class="line-removed">142     return nullptr;</span>
<span class="line-removed">143 #endif</span>
144 }
145 
146 }


</pre>
</td>
<td>
<hr />
<pre>
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;OffscreenCanvas.h&quot;
 28 
<span class="line-added"> 29 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added"> 30 </span>
<span class="line-added"> 31 #include &quot;CSSValuePool.h&quot;</span>
 32 #include &quot;CanvasRenderingContext.h&quot;
 33 #include &quot;ImageBitmap.h&quot;
<span class="line-added"> 34 #include &quot;JSBlob.h&quot;</span>
<span class="line-added"> 35 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
<span class="line-added"> 36 #include &quot;MIMETypeRegistry.h&quot;</span>
<span class="line-added"> 37 #include &quot;OffscreenCanvasRenderingContext2D.h&quot;</span>
 38 #include &quot;WebGLRenderingContext.h&quot;
<span class="line-added"> 39 #include &quot;WorkerGlobalScope.h&quot;</span>
 40 #include &lt;wtf/IsoMallocInlines.h&gt;
 41 
 42 namespace WebCore {
 43 
 44 WTF_MAKE_ISO_ALLOCATED_IMPL(OffscreenCanvas);
 45 
<span class="line-added"> 46 DetachedOffscreenCanvas::DetachedOffscreenCanvas(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp; buffer, const IntSize&amp; size, bool originClean)</span>
<span class="line-added"> 47     : m_buffer(WTFMove(buffer))</span>
<span class="line-added"> 48     , m_size(size)</span>
<span class="line-added"> 49     , m_originClean(originClean)</span>
<span class="line-added"> 50 {</span>
<span class="line-added"> 51 }</span>
<span class="line-added"> 52 </span>
<span class="line-added"> 53 std::unique_ptr&lt;ImageBuffer&gt; DetachedOffscreenCanvas::takeImageBuffer()</span>
<span class="line-added"> 54 {</span>
<span class="line-added"> 55     return WTFMove(m_buffer);</span>
<span class="line-added"> 56 }</span>
<span class="line-added"> 57 </span>
 58 Ref&lt;OffscreenCanvas&gt; OffscreenCanvas::create(ScriptExecutionContext&amp; context, unsigned width, unsigned height)
 59 {
 60     return adoptRef(*new OffscreenCanvas(context, width, height));
 61 }
 62 
<span class="line-added"> 63 Ref&lt;OffscreenCanvas&gt; OffscreenCanvas::create(ScriptExecutionContext&amp; context, std::unique_ptr&lt;DetachedOffscreenCanvas&gt;&amp;&amp; detachedCanvas)</span>
<span class="line-added"> 64 {</span>
<span class="line-added"> 65     Ref&lt;OffscreenCanvas&gt; clone = adoptRef(*new OffscreenCanvas(context, detachedCanvas-&gt;size().width(), detachedCanvas-&gt;size().height()));</span>
<span class="line-added"> 66     clone-&gt;setImageBuffer(detachedCanvas-&gt;takeImageBuffer());</span>
<span class="line-added"> 67     if (!detachedCanvas-&gt;originClean())</span>
<span class="line-added"> 68         clone-&gt;setOriginTainted();</span>
<span class="line-added"> 69 </span>
<span class="line-added"> 70     return clone;</span>
<span class="line-added"> 71 }</span>
<span class="line-added"> 72 </span>
 73 OffscreenCanvas::OffscreenCanvas(ScriptExecutionContext&amp; context, unsigned width, unsigned height)
<span class="line-modified"> 74     : CanvasBase(IntSize(width, height))</span>
<span class="line-modified"> 75     , ContextDestructionObserver(&amp;context)</span>
 76 {
 77 }
 78 
 79 OffscreenCanvas::~OffscreenCanvas()
 80 {
 81     notifyObserversCanvasDestroyed();
 82 
<span class="line-modified"> 83     m_context = nullptr; // Ensure this goes away before the ImageBuffer.</span>
<span class="line-added"> 84     setImageBuffer(nullptr);</span>
 85 }
 86 
 87 unsigned OffscreenCanvas::width() const
 88 {
<span class="line-modified"> 89     if (m_detached)</span>
<span class="line-modified"> 90         return 0;</span>
<span class="line-modified"> 91     return CanvasBase::width();</span>



 92 }
 93 
 94 unsigned OffscreenCanvas::height() const
 95 {
<span class="line-modified"> 96     if (m_detached)</span>
<span class="line-added"> 97         return 0;</span>
<span class="line-added"> 98     return CanvasBase::height();</span>
 99 }
100 
<span class="line-modified">101 void OffscreenCanvas::setWidth(unsigned newWidth)</span>
102 {
<span class="line-modified">103     if (m_detached)</span>
<span class="line-added">104         return;</span>
<span class="line-added">105     setSize(IntSize(newWidth, height()));</span>
106 }
107 
<span class="line-modified">108 void OffscreenCanvas::setHeight(unsigned newHeight)</span>
109 {
<span class="line-modified">110     if (m_detached)</span>
<span class="line-added">111         return;</span>
<span class="line-added">112     setSize(IntSize(width(), newHeight));</span>
113 }
114 
115 void OffscreenCanvas::setSize(const IntSize&amp; newSize)
116 {
<span class="line-modified">117     CanvasBase::setSize(newSize);</span>
<span class="line-added">118     reset();</span>
119 }
120 
<span class="line-modified">121 ExceptionOr&lt;OffscreenRenderingContext&gt; OffscreenCanvas::getContext(JSC::JSGlobalObject&amp; state, RenderingContextType contextType, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>

122 {
<span class="line-modified">123     if (m_detached)</span>
<span class="line-modified">124         return Exception { InvalidStateError };</span>
<span class="line-added">125 </span>
<span class="line-added">126     if (contextType == RenderingContextType::_2d) {</span>
<span class="line-added">127         if (m_context) {</span>
<span class="line-added">128             if (!is&lt;OffscreenCanvasRenderingContext2D&gt;(*m_context))</span>
<span class="line-added">129                 return Exception { InvalidStateError };</span>
<span class="line-added">130             return { RefPtr&lt;OffscreenCanvasRenderingContext2D&gt; { &amp;downcast&lt;OffscreenCanvasRenderingContext2D&gt;(*m_context) } };</span>
<span class="line-added">131         }</span>
<span class="line-added">132 </span>
<span class="line-added">133         m_context = makeUnique&lt;OffscreenCanvasRenderingContext2D&gt;(*this);</span>
<span class="line-added">134         if (!m_context)</span>
<span class="line-added">135             return { RefPtr&lt;OffscreenCanvasRenderingContext2D&gt; { nullptr } };</span>
136 
<span class="line-added">137         return { RefPtr&lt;OffscreenCanvasRenderingContext2D&gt; { &amp;downcast&lt;OffscreenCanvasRenderingContext2D&gt;(*m_context) } };</span>
<span class="line-added">138     }</span>
<span class="line-added">139 #if ENABLE(WEBGL)</span>
140     if (contextType == RenderingContextType::Webgl) {
<span class="line-added">141         if (m_context) {</span>
<span class="line-added">142             if (!is&lt;WebGLRenderingContext&gt;(*m_context))</span>
<span class="line-added">143                 return Exception { InvalidStateError };</span>
<span class="line-added">144             return { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*m_context) } };</span>
<span class="line-added">145         }</span>
<span class="line-added">146 </span>
147         auto scope = DECLARE_THROW_SCOPE(state.vm());
148         auto attributes = convert&lt;IDLDictionary&lt;WebGLContextAttributes&gt;&gt;(state, !arguments.isEmpty() ? arguments[0].get() : JSC::jsUndefined());
149         RETURN_IF_EXCEPTION(scope, Exception { ExistingExceptionError });
150 
151         m_context = WebGLRenderingContextBase::create(*this, attributes, &quot;webgl&quot;);
152         if (!m_context)
<span class="line-modified">153             return { RefPtr&lt;WebGLRenderingContext&gt; { nullptr } };</span>
154 
155         return { RefPtr&lt;WebGLRenderingContext&gt; { &amp;downcast&lt;WebGLRenderingContext&gt;(*m_context) } };
156     }
<span class="line-added">157 #endif</span>
158 
<span class="line-modified">159     return Exception { NotSupportedError };</span>
160 }

161 
<span class="line-modified">162 ExceptionOr&lt;RefPtr&lt;ImageBitmap&gt;&gt; OffscreenCanvas::transferToImageBitmap()</span>
163 {
<span class="line-modified">164     if (m_detached || !m_context)</span>
<span class="line-modified">165         return Exception { InvalidStateError };</span>
<span class="line-added">166 </span>
<span class="line-added">167     if (is&lt;OffscreenCanvasRenderingContext2D&gt;(*m_context)) {</span>
<span class="line-added">168         if (!width() || !height())</span>
<span class="line-added">169             return { RefPtr&lt;ImageBitmap&gt; { nullptr } };</span>
<span class="line-added">170 </span>
<span class="line-added">171         if (!m_hasCreatedImageBuffer)</span>
<span class="line-added">172             return { ImageBitmap::create({ ImageBuffer::create(size(), RenderingMode::Unaccelerated), true }) };</span>
<span class="line-added">173 </span>
<span class="line-added">174         auto buffer = takeImageBuffer();</span>
<span class="line-added">175         if (!buffer)</span>
<span class="line-added">176             return { RefPtr&lt;ImageBitmap&gt; { nullptr } };</span>
<span class="line-added">177 </span>
<span class="line-added">178         return { ImageBitmap::create({ WTFMove(buffer), originClean() }) };</span>
<span class="line-added">179     }</span>
180 
181 #if ENABLE(WEBGL)
<span class="line-modified">182     if (is&lt;WebGLRenderingContext&gt;(*m_context)) {</span>
<span class="line-added">183         auto webGLContext = &amp;downcast&lt;WebGLRenderingContext&gt;(*m_context);</span>
<span class="line-added">184 </span>
<span class="line-added">185         // FIXME: We&#39;re supposed to create an ImageBitmap using the backing</span>
<span class="line-added">186         // store from this canvas (or its context), but for now we&#39;ll just</span>
<span class="line-added">187         // create a new bitmap and paint into it.</span>
<span class="line-added">188 </span>
<span class="line-added">189         auto imageBitmap = ImageBitmap::create(size());</span>
<span class="line-added">190         if (!imageBitmap-&gt;buffer())</span>
<span class="line-added">191             return { RefPtr&lt;ImageBitmap&gt; { nullptr } };</span>
<span class="line-added">192 </span>
<span class="line-added">193         auto* gc3d = webGLContext-&gt;graphicsContextGL();</span>
<span class="line-added">194         gc3d-&gt;paintRenderingResultsToCanvas(imageBitmap-&gt;buffer());</span>
<span class="line-added">195 </span>
<span class="line-added">196         // FIXME: The transfer algorithm requires that the canvas effectively</span>
<span class="line-added">197         // creates a new backing store. Since we&#39;re not doing that yet, we</span>
<span class="line-added">198         // need to erase what&#39;s there.</span>
<span class="line-added">199 </span>
<span class="line-added">200         GCGLfloat clearColor[4];</span>
<span class="line-added">201         gc3d-&gt;getFloatv(GraphicsContextGL::COLOR_CLEAR_VALUE, clearColor);</span>
<span class="line-added">202         gc3d-&gt;clearColor(0, 0, 0, 0);</span>
<span class="line-added">203         gc3d-&gt;clear(GraphicsContextGL::COLOR_BUFFER_BIT | GraphicsContextGL::DEPTH_BUFFER_BIT | GraphicsContextGL::STENCIL_BUFFER_BIT);</span>
<span class="line-added">204         gc3d-&gt;clearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);</span>
<span class="line-added">205 </span>
<span class="line-added">206         return { WTFMove(imageBitmap) };</span>
<span class="line-added">207     }</span>
<span class="line-added">208 #endif</span>
<span class="line-added">209 </span>
<span class="line-added">210     return Exception { NotSupportedError };</span>
<span class="line-added">211 }</span>
<span class="line-added">212 </span>
<span class="line-added">213 static String toEncodingMimeType(const String&amp; mimeType)</span>
<span class="line-added">214 {</span>
<span class="line-added">215     if (!MIMETypeRegistry::isSupportedImageMIMETypeForEncoding(mimeType))</span>
<span class="line-added">216         return &quot;image/png&quot;_s;</span>
<span class="line-added">217     return mimeType.convertToASCIILowercase();</span>
<span class="line-added">218 }</span>
<span class="line-added">219 </span>
<span class="line-added">220 static Optional&lt;double&gt; qualityFromDouble(double qualityNumber)</span>
<span class="line-added">221 {</span>
<span class="line-added">222     if (!(qualityNumber &gt;= 0 &amp;&amp; qualityNumber &lt;= 1))</span>
<span class="line-added">223         return WTF::nullopt;</span>
<span class="line-added">224 </span>
<span class="line-added">225     return qualityNumber;</span>
<span class="line-added">226 }</span>
<span class="line-added">227 </span>
<span class="line-added">228 void OffscreenCanvas::convertToBlob(ImageEncodeOptions&amp;&amp; options, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
<span class="line-added">229 {</span>
<span class="line-added">230     if (!originClean()) {</span>
<span class="line-added">231         promise-&gt;reject(SecurityError);</span>
<span class="line-added">232         return;</span>
<span class="line-added">233     }</span>
<span class="line-added">234     if (size().isEmpty()) {</span>
<span class="line-added">235         promise-&gt;reject(IndexSizeError);</span>
<span class="line-added">236         return;</span>
<span class="line-added">237     }</span>
<span class="line-added">238     if (m_detached || !buffer()) {</span>
<span class="line-added">239         promise-&gt;reject(InvalidStateError);</span>
<span class="line-added">240         return;</span>
<span class="line-added">241     }</span>
<span class="line-added">242 </span>
<span class="line-added">243     makeRenderingResultsAvailable();</span>
<span class="line-added">244 </span>
<span class="line-added">245     auto encodingMIMEType = toEncodingMimeType(options.type);</span>
<span class="line-added">246     auto quality = qualityFromDouble(options.quality);</span>
<span class="line-added">247 </span>
<span class="line-added">248     Vector&lt;uint8_t&gt; blobData = buffer()-&gt;toData(encodingMIMEType, quality);</span>
<span class="line-added">249     if (blobData.isEmpty()) {</span>
<span class="line-added">250         promise-&gt;reject(EncodingError);</span>
<span class="line-added">251         return;</span>
<span class="line-added">252     }</span>
<span class="line-added">253 </span>
<span class="line-added">254     Ref&lt;Blob&gt; blob = Blob::create(WTFMove(blobData), encodingMIMEType);</span>
<span class="line-added">255     promise-&gt;resolveWithNewlyCreated&lt;IDLInterface&lt;Blob&gt;&gt;(WTFMove(blob));</span>
<span class="line-added">256 }</span>
<span class="line-added">257 </span>
<span class="line-added">258 void OffscreenCanvas::didDraw(const FloatRect&amp; rect)</span>
<span class="line-added">259 {</span>
<span class="line-added">260     notifyObserversCanvasChanged(rect);</span>
<span class="line-added">261 }</span>
<span class="line-added">262 </span>
<span class="line-added">263 SecurityOrigin* OffscreenCanvas::securityOrigin() const</span>
<span class="line-added">264 {</span>
<span class="line-added">265     auto&amp; context = *canvasBaseScriptExecutionContext();</span>
<span class="line-added">266     if (is&lt;WorkerGlobalScope&gt;(context))</span>
<span class="line-added">267         return &amp;downcast&lt;WorkerGlobalScope&gt;(context).topOrigin();</span>
<span class="line-added">268 </span>
<span class="line-added">269     return &amp;downcast&lt;Document&gt;(context).securityOrigin();</span>
<span class="line-added">270 }</span>
<span class="line-added">271 </span>
<span class="line-added">272 bool OffscreenCanvas::canDetach() const</span>
<span class="line-added">273 {</span>
<span class="line-added">274     return !m_detached &amp;&amp; !m_context;</span>
<span class="line-added">275 }</span>
<span class="line-added">276 </span>
<span class="line-added">277 std::unique_ptr&lt;DetachedOffscreenCanvas&gt; OffscreenCanvas::detach()</span>
<span class="line-added">278 {</span>
<span class="line-added">279     if (!canDetach())</span>
280         return nullptr;
281 
<span class="line-modified">282     m_detached = true;</span>
<span class="line-added">283 </span>
<span class="line-added">284     return makeUnique&lt;DetachedOffscreenCanvas&gt;(takeImageBuffer(), size(), originClean());</span>
<span class="line-added">285 }</span>
<span class="line-added">286 </span>
<span class="line-added">287 CSSValuePool&amp; OffscreenCanvas::cssValuePool()</span>
<span class="line-added">288 {</span>
<span class="line-added">289     auto* context = canvasBaseScriptExecutionContext();</span>
<span class="line-added">290     if (context-&gt;isWorkerGlobalScope())</span>
<span class="line-added">291         return downcast&lt;WorkerGlobalScope&gt;(*context).cssValuePool();</span>
<span class="line-added">292 </span>
<span class="line-added">293     ASSERT(context-&gt;isDocument());</span>
<span class="line-added">294     return CSSValuePool::singleton();</span>
<span class="line-added">295 }</span>
<span class="line-added">296 </span>
<span class="line-added">297 void OffscreenCanvas::createImageBuffer() const</span>
<span class="line-added">298 {</span>
<span class="line-added">299     m_hasCreatedImageBuffer = true;</span>
<span class="line-added">300 </span>
<span class="line-added">301     if (!width() || !height())</span>
<span class="line-added">302         return;</span>
303 
<span class="line-modified">304     setImageBuffer(ImageBuffer::create(size(), RenderingMode::Unaccelerated));</span>
<span class="line-modified">305 }</span>
<span class="line-modified">306 </span>
<span class="line-added">307 std::unique_ptr&lt;ImageBuffer&gt; OffscreenCanvas::takeImageBuffer() const</span>
<span class="line-added">308 {</span>
<span class="line-added">309     if (!m_detached)</span>
<span class="line-added">310         m_hasCreatedImageBuffer = true;</span>
311 
<span class="line-modified">312     // This function is primarily for use with transferToImageBitmap, which</span>
<span class="line-modified">313     // requires that the canvas bitmap refer to a new, blank bitmap of the same</span>
<span class="line-added">314     // size after the existing bitmap is taken. In the case of a zero-size</span>
<span class="line-added">315     // bitmap, our buffer is null, so returning early here is valid.</span>
<span class="line-added">316     if (size().isEmpty())</span>
317         return nullptr;
318 
<span class="line-modified">319     return setImageBuffer(m_detached ? nullptr : ImageBuffer::create(size(), RenderingMode::Unaccelerated));</span>
<span class="line-modified">320 }</span>
321 
<span class="line-modified">322 void OffscreenCanvas::reset()</span>
<span class="line-modified">323 {</span>
<span class="line-modified">324     resetGraphicsContextState();</span>
<span class="line-added">325     if (is&lt;OffscreenCanvasRenderingContext2D&gt;(m_context.get()))</span>
<span class="line-added">326         downcast&lt;OffscreenCanvasRenderingContext2D&gt;(*m_context).reset();</span>
327 
<span class="line-modified">328     m_hasCreatedImageBuffer = false;</span>
<span class="line-modified">329     setImageBuffer(nullptr);</span>



330 
<span class="line-modified">331     notifyObserversCanvasResized();</span>



332 }
333 
334 }
<span class="line-added">335 </span>
<span class="line-added">336 #endif</span>
</pre>
</td>
</tr>
</table>
<center><a href="MediaEncryptedEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="OffscreenCanvas.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/css/TransformFunctions.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012 Apple Inc. All rights reserved.
  3  * Copyright (C) 2012 Google Inc. All rights reserved.
  4  * Copyright (C) 2012, 2013 Adobe Systems Incorporated. All rights reserved.
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  *
 10  * 1. Redistributions of source code must retain the above
 11  *    copyright notice, this list of conditions and the following
 12  *    disclaimer.
 13  * 2. Redistributions in binary form must reproduce the above
 14  *    copyright notice, this list of conditions and the following
 15  *    disclaimer in the documentation and/or other materials
 16  *    provided with the distribution.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY
 19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 20  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 21  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
 22  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 23  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 24  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 25  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
 27  * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 28  * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 29  * SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;TransformFunctions.h&quot;
 34 
 35 #include &quot;CSSFunctionValue.h&quot;
 36 #include &quot;CSSPrimitiveValueMappings.h&quot;
 37 #include &quot;CSSValueList.h&quot;
 38 #include &quot;Matrix3DTransformOperation.h&quot;
 39 #include &quot;MatrixTransformOperation.h&quot;
 40 #include &quot;PerspectiveTransformOperation.h&quot;
 41 #include &quot;RotateTransformOperation.h&quot;
 42 #include &quot;ScaleTransformOperation.h&quot;
 43 #include &quot;SkewTransformOperation.h&quot;
 44 #include &quot;TranslateTransformOperation.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 45 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;</span>
 46 
 47 namespace WebCore {
 48 
 49 static TransformOperation::OperationType transformOperationType(CSSValueID type)
 50 {
 51     switch (type) {
 52     case CSSValueScale:
 53         return TransformOperation::SCALE;
 54     case CSSValueScaleX:
 55         return TransformOperation::SCALE_X;
 56     case CSSValueScaleY:
 57         return TransformOperation::SCALE_Y;
 58     case CSSValueScaleZ:
 59         return TransformOperation::SCALE_Z;
 60     case CSSValueScale3d:
 61         return TransformOperation::SCALE_3D;
 62     case CSSValueTranslate:
 63         return TransformOperation::TRANSLATE;
 64     case CSSValueTranslateX:
 65         return TransformOperation::TRANSLATE_X;
 66     case CSSValueTranslateY:
 67         return TransformOperation::TRANSLATE_Y;
 68     case CSSValueTranslateZ:
 69         return TransformOperation::TRANSLATE_Z;
 70     case CSSValueTranslate3d:
 71         return TransformOperation::TRANSLATE_3D;
 72     case CSSValueRotate:
 73         return TransformOperation::ROTATE;
 74     case CSSValueRotateX:
 75         return TransformOperation::ROTATE_X;
 76     case CSSValueRotateY:
 77         return TransformOperation::ROTATE_Y;
 78     case CSSValueRotateZ:
 79         return TransformOperation::ROTATE_Z;
 80     case CSSValueRotate3d:
 81         return TransformOperation::ROTATE_3D;
 82     case CSSValueSkew:
 83         return TransformOperation::SKEW;
 84     case CSSValueSkewX:
 85         return TransformOperation::SKEW_X;
 86     case CSSValueSkewY:
 87         return TransformOperation::SKEW_Y;
 88     case CSSValueMatrix:
 89         return TransformOperation::MATRIX;
 90     case CSSValueMatrix3d:
 91         return TransformOperation::MATRIX_3D;
 92     case CSSValuePerspective:
 93         return TransformOperation::PERSPECTIVE;
 94     default:
 95         break;
 96     }
 97     return TransformOperation::NONE;
 98 }
 99 
100 Length convertToFloatLength(const CSSPrimitiveValue* primitiveValue, const CSSToLengthConversionData&amp; conversionData)
101 {
102     return primitiveValue ? primitiveValue-&gt;convertToLength&lt;FixedFloatConversion | PercentConversion | CalculatedConversion&gt;(conversionData) : Length(Undefined);
103 }
104 
105 bool transformsForValue(const CSSValue&amp; value, const CSSToLengthConversionData&amp; conversionData, TransformOperations&amp; outOperations)
106 {
107     if (!is&lt;CSSValueList&gt;(value)) {
108         outOperations.clear();
109         return false;
110     }
111 
112     TransformOperations operations;
113     for (auto&amp; currentValue : downcast&lt;CSSValueList&gt;(value)) {
114         if (!is&lt;CSSFunctionValue&gt;(currentValue))
115             continue;
116 
117         auto&amp; transformValue = downcast&lt;CSSFunctionValue&gt;(currentValue.get());
118         if (!transformValue.length())
119             continue;
120 
121         bool haveNonPrimitiveValue = false;
122         for (unsigned j = 0; j &lt; transformValue.length(); ++j) {
123             if (!is&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(j))) {
124                 haveNonPrimitiveValue = true;
125                 break;
126             }
127         }
128         if (haveNonPrimitiveValue)
129             continue;
130 
131         auto&amp; firstValue = downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(0));
132 
133         switch (transformValue.name()) {
134         case CSSValueScale:
135         case CSSValueScaleX:
136         case CSSValueScaleY: {
137             double sx = 1.0;
138             double sy = 1.0;
139             if (transformValue.name() == CSSValueScaleY)
140                 sy = firstValue.doubleValue();
141             else {
142                 sx = firstValue.doubleValue();
143                 if (transformValue.name() != CSSValueScaleX) {
144                     if (transformValue.length() &gt; 1) {
145                         auto&amp; secondValue = downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(1));
146                         sy = secondValue.doubleValue();
147                     } else
148                         sy = sx;
149                 }
150             }
151             operations.operations().append(ScaleTransformOperation::create(sx, sy, 1.0, transformOperationType(transformValue.name())));
152             break;
153         }
154         case CSSValueScaleZ:
155         case CSSValueScale3d: {
156             double sx = 1.0;
157             double sy = 1.0;
158             double sz = 1.0;
159             if (transformValue.name() == CSSValueScaleZ)
160                 sz = firstValue.doubleValue();
161             else if (transformValue.name() == CSSValueScaleY)
162                 sy = firstValue.doubleValue();
163             else {
164                 sx = firstValue.doubleValue();
165                 if (transformValue.name() != CSSValueScaleX) {
166                     if (transformValue.length() &gt; 2) {
167                         auto&amp; thirdValue = downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(2));
168                         sz = thirdValue.doubleValue();
169                     }
170                     if (transformValue.length() &gt; 1) {
171                         auto&amp; secondValue = downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(1));
172                         sy = secondValue.doubleValue();
173                     } else
174                         sy = sx;
175                 }
176             }
177             operations.operations().append(ScaleTransformOperation::create(sx, sy, sz, transformOperationType(transformValue.name())));
178             break;
179         }
180         case CSSValueTranslate:
181         case CSSValueTranslateX:
182         case CSSValueTranslateY: {
183             Length tx = Length(0, Fixed);
184             Length ty = Length(0, Fixed);
185             if (transformValue.name() == CSSValueTranslateY)
186                 ty = convertToFloatLength(&amp;firstValue, conversionData);
187             else {
188                 tx = convertToFloatLength(&amp;firstValue, conversionData);
189                 if (transformValue.name() != CSSValueTranslateX) {
190                     if (transformValue.length() &gt; 1) {
191                         auto&amp; secondValue = downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(1));
192                         ty = convertToFloatLength(&amp;secondValue, conversionData);
193                     }
194                 }
195             }
196 
197             if (tx.isUndefined() || ty.isUndefined())
198                 return false;
199 
200             operations.operations().append(TranslateTransformOperation::create(tx, ty, Length(0, Fixed), transformOperationType(transformValue.name())));
201             break;
202         }
203         case CSSValueTranslateZ:
204         case CSSValueTranslate3d: {
205             Length tx = Length(0, Fixed);
206             Length ty = Length(0, Fixed);
207             Length tz = Length(0, Fixed);
208             if (transformValue.name() == CSSValueTranslateZ)
209                 tz = convertToFloatLength(&amp;firstValue, conversionData);
210             else if (transformValue.name() == CSSValueTranslateY)
211                 ty = convertToFloatLength(&amp;firstValue, conversionData);
212             else {
213                 tx = convertToFloatLength(&amp;firstValue, conversionData);
214                 if (transformValue.name() != CSSValueTranslateX) {
215                     if (transformValue.length() &gt; 2) {
216                         auto&amp; thirdValue = downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(2));
217                         tz = convertToFloatLength(&amp;thirdValue, conversionData);
218                     }
219                     if (transformValue.length() &gt; 1) {
220                         auto&amp; secondValue = downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(1));
221                         ty = convertToFloatLength(&amp;secondValue, conversionData);
222                     }
223                 }
224             }
225 
226             if (tx.isUndefined() || ty.isUndefined() || tz.isUndefined())
227                 return false;
228 
229             operations.operations().append(TranslateTransformOperation::create(tx, ty, tz, transformOperationType(transformValue.name())));
230             break;
231         }
232         case CSSValueRotate: {
233             double angle = firstValue.computeDegrees();
234             operations.operations().append(RotateTransformOperation::create(0, 0, 1, angle, transformOperationType(transformValue.name())));
235             break;
236         }
237         case CSSValueRotateX:
238         case CSSValueRotateY:
239         case CSSValueRotateZ: {
240             double x = 0;
241             double y = 0;
242             double z = 0;
243             double angle = firstValue.computeDegrees();
244 
245             if (transformValue.name() == CSSValueRotateX)
246                 x = 1;
247             else if (transformValue.name() == CSSValueRotateY)
248                 y = 1;
249             else
250                 z = 1;
251             operations.operations().append(RotateTransformOperation::create(x, y, z, angle, transformOperationType(transformValue.name())));
252             break;
253         }
254         case CSSValueRotate3d: {
255             if (transformValue.length() &lt; 4)
256                 break;
257             auto&amp; secondValue = downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(1));
258             auto&amp; thirdValue = downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(2));
259             auto&amp; fourthValue = downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(3));
260             double x = firstValue.doubleValue();
261             double y = secondValue.doubleValue();
262             double z = thirdValue.doubleValue();
263             double angle = fourthValue.computeDegrees();
264             operations.operations().append(RotateTransformOperation::create(x, y, z, angle, transformOperationType(transformValue.name())));
265             break;
266         }
267         case CSSValueSkew:
268         case CSSValueSkewX:
269         case CSSValueSkewY: {
270             double angleX = 0;
271             double angleY = 0;
272             double angle = firstValue.computeDegrees();
273             if (transformValue.name() == CSSValueSkewY)
274                 angleY = angle;
275             else {
276                 angleX = angle;
277                 if (transformValue.name() == CSSValueSkew) {
278                     if (transformValue.length() &gt; 1) {
279                         auto&amp; secondValue = downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(1));
280                         angleY = secondValue.computeDegrees();
281                     }
282                 }
283             }
284             operations.operations().append(SkewTransformOperation::create(angleX, angleY, transformOperationType(transformValue.name())));
285             break;
286         }
287         case CSSValueMatrix: {
288             if (transformValue.length() &lt; 6)
289                 break;
290             double a = firstValue.doubleValue();
291             double b = downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(1)).doubleValue();
292             double c = downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(2)).doubleValue();
293             double d = downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(3)).doubleValue();
294             double e = conversionData.zoom() * downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(4)).doubleValue();
295             double f = conversionData.zoom() * downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(5)).doubleValue();
296             operations.operations().append(MatrixTransformOperation::create(a, b, c, d, e, f));
297             break;
298         }
299         case CSSValueMatrix3d: {
300             if (transformValue.length() &lt; 16)
301                 break;
302             TransformationMatrix matrix(downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(0)).doubleValue(),
303                 downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(1)).doubleValue(),
304                 downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(2)).doubleValue(),
305                 downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(3)).doubleValue(),
306                 downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(4)).doubleValue(),
307                 downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(5)).doubleValue(),
308                 downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(6)).doubleValue(),
309                 downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(7)).doubleValue(),
310                 downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(8)).doubleValue(),
311                 downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(9)).doubleValue(),
312                 downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(10)).doubleValue(),
313                 downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(11)).doubleValue(),
314                 conversionData.zoom() * downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(12)).doubleValue(),
315                 conversionData.zoom() * downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(13)).doubleValue(),
316                 downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(14)).doubleValue(),
317                 downcast&lt;CSSPrimitiveValue&gt;(*transformValue.itemWithoutBoundsCheck(15)).doubleValue());
318             operations.operations().append(Matrix3DTransformOperation::create(matrix));
319             break;
320         }
321         case CSSValuePerspective: {
322             Length p = Length(0, Fixed);
323             if (firstValue.isLength())
324                 p = convertToFloatLength(&amp;firstValue, conversionData);
325             else {
326                 // This is a quirk that should go away when 3d transforms are finalized.
327                 double val = firstValue.doubleValue();
328                 p = val &gt;= 0 ? Length(clampToPositiveInteger(val), Fixed) : Length(Undefined);
329             }
330 
331             if (p.isUndefined())
332                 return false;
333 
334             operations.operations().append(PerspectiveTransformOperation::create(p));
335             break;
336         }
337         default:
338             ASSERT_NOT_REACHED();
339             break;
340         }
341     }
342 
343     outOperations = operations;
344     return true;
345 }
346 
347 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
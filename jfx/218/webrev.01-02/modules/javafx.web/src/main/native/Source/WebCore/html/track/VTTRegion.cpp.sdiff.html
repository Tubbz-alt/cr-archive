<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/track/VTTRegion.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="VTTCue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="VTTRegion.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/track/VTTRegion.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
264 {
265     static NeverDestroyed&lt;const AtomString&gt; trackRegionCueContainerScrollingClass(&quot;scrolling&quot;, AtomString::ConstructFromLiteral);
266 
267     return trackRegionCueContainerScrollingClass;
268 }
269 
270 const AtomString&amp; VTTRegion::textTrackCueContainerShadowPseudoId()
271 {
272     static NeverDestroyed&lt;const AtomString&gt; trackRegionCueContainerPseudoId(&quot;-webkit-media-text-track-region-container&quot;, AtomString::ConstructFromLiteral);
273 
274     return trackRegionCueContainerPseudoId;
275 }
276 
277 const AtomString&amp; VTTRegion::textTrackRegionShadowPseudoId()
278 {
279     static NeverDestroyed&lt;const AtomString&gt; trackRegionShadowPseudoId(&quot;-webkit-media-text-track-region&quot;, AtomString::ConstructFromLiteral);
280 
281     return trackRegionShadowPseudoId;
282 }
283 
<span class="line-modified">284 void VTTRegion::appendTextTrackCueBox(Ref&lt;VTTCueBox&gt;&amp;&amp; displayBox)</span>
285 {
286     ASSERT(m_cueContainer);
287 
288     if (m_cueContainer-&gt;contains(displayBox.ptr()))
289         return;
290 
291     m_cueContainer-&gt;appendChild(displayBox);
292     displayLastTextTrackCueBox();
293 }
294 
295 void VTTRegion::displayLastTextTrackCueBox()
296 {
297     ASSERT(m_cueContainer);
298 
299     // The container needs to be rendered, if it is not empty and the region is not currently scrolling.
300     if (!m_cueContainer-&gt;renderer() || !m_cueContainer-&gt;hasChildNodes() || m_scrollTimer.isActive())
301         return;
302 
303     // If it&#39;s a scrolling region, add the scrolling class.
304     if (isScrollingRegion())
305         m_cueContainer-&gt;classList().add(textTrackCueContainerScrollingClass());
306 
307     float regionBottom = m_regionDisplayTree-&gt;getBoundingClientRect()-&gt;bottom();
308 
309     // Find first cue that is not entirely displayed and scroll it upwards.
310     for (auto&amp; child : childrenOfType&lt;Element&gt;(*m_cueContainer)) {
311         auto rect = child.getBoundingClientRect();
312         float childTop = rect-&gt;top();
313         float childBottom = rect-&gt;bottom();
314 
315         if (regionBottom &gt;= childBottom)
316             continue;
317 
318         float height = childBottom - childTop;
319 
320         m_currentTop -= std::min(height, childBottom - regionBottom);
<span class="line-modified">321         m_cueContainer-&gt;setInlineStyleProperty(CSSPropertyTop, m_currentTop, CSSPrimitiveValue::CSS_PX);</span>
322 
323         startTimer();
324         break;
325     }
326 }
327 
328 void VTTRegion::willRemoveTextTrackCueBox(VTTCueBox* box)
329 {
330     LOG(Media, &quot;VTTRegion::willRemoveTextTrackCueBox&quot;);
331     ASSERT(m_cueContainer-&gt;contains(box));
332 
333     double boxHeight = box-&gt;getBoundingClientRect()-&gt;bottom() - box-&gt;getBoundingClientRect()-&gt;top();
334 
335     m_cueContainer-&gt;classList().remove(textTrackCueContainerScrollingClass());
336 
337     m_currentTop += boxHeight;
<span class="line-modified">338     m_cueContainer-&gt;setInlineStyleProperty(CSSPropertyTop, m_currentTop, CSSPrimitiveValue::CSS_PX);</span>
339 }
340 
341 HTMLDivElement&amp; VTTRegion::getDisplayTree()
342 {
343     if (!m_regionDisplayTree) {
344         m_regionDisplayTree = HTMLDivElement::create(downcast&lt;Document&gt;(*m_scriptExecutionContext));
<span class="line-modified">345         prepareRegionDisplayTree();</span>

346     }
347 



348     return *m_regionDisplayTree;
349 }
350 
351 void VTTRegion::prepareRegionDisplayTree()
352 {
353     ASSERT(m_regionDisplayTree);
354 
355     // 7.2 Prepare region CSS boxes
356 
357     // FIXME: Change the code below to use viewport units when
358     // http://crbug/244618 is fixed.
359 
360     // Let regionWidth be the text track region width.
361     // Let width be &#39;regionWidth vw&#39; (&#39;vw&#39; is a CSS unit)
<span class="line-modified">362     m_regionDisplayTree-&gt;setInlineStyleProperty(CSSPropertyWidth, m_width, CSSPrimitiveValue::CSS_PERCENTAGE);</span>
363 
364     // Let lineHeight be &#39;0.0533vh&#39; (&#39;vh&#39; is a CSS unit) and regionHeight be
365     // the text track region height. Let height be &#39;lineHeight&#39; multiplied
366     // by regionHeight.
367     double height = lineHeight * m_lines;
<span class="line-modified">368     m_regionDisplayTree-&gt;setInlineStyleProperty(CSSPropertyHeight, height, CSSPrimitiveValue::CSS_VH);</span>
369 
370     // Let viewportAnchorX be the x dimension of the text track region viewport
371     // anchor and regionAnchorX be the x dimension of the text track region
372     // anchor. Let leftOffset be regionAnchorX multiplied by width divided by
373     // 100.0. Let left be leftOffset subtracted from &#39;viewportAnchorX vw&#39;.
374     double leftOffset = m_regionAnchor.x() * m_width / 100;
<span class="line-modified">375     m_regionDisplayTree-&gt;setInlineStyleProperty(CSSPropertyLeft, m_viewportAnchor.x() - leftOffset, CSSPrimitiveValue::CSS_PERCENTAGE);</span>
376 
377     // Let viewportAnchorY be the y dimension of the text track region viewport
378     // anchor and regionAnchorY be the y dimension of the text track region
379     // anchor. Let topOffset be regionAnchorY multiplied by height divided by
380     // 100.0. Let top be topOffset subtracted from &#39;viewportAnchorY vh&#39;.
381     double topOffset = m_regionAnchor.y() * height / 100;
<span class="line-modified">382     m_regionDisplayTree-&gt;setInlineStyleProperty(CSSPropertyTop, m_viewportAnchor.y() - topOffset, CSSPrimitiveValue::CSS_PERCENTAGE);</span>
383 
384     // The cue container is used to wrap the cues and it is the object which is
385     // gradually scrolled out as multiple cues are appended to the region.
<span class="line-modified">386     m_cueContainer = HTMLDivElement::create(downcast&lt;Document&gt;(*m_scriptExecutionContext));</span>
<span class="line-modified">387     m_cueContainer-&gt;setInlineStyleProperty(CSSPropertyTop, 0.0f, CSSPrimitiveValue::CSS_PX);</span>
<span class="line-modified">388 </span>
<span class="line-modified">389     m_cueContainer-&gt;setPseudo(textTrackCueContainerShadowPseudoId());</span>
<span class="line-modified">390     m_regionDisplayTree-&gt;appendChild(*m_cueContainer);</span>

391 
392     // 7.5 Every WebVTT region object is initialised with the following CSS
<span class="line-modified">393     m_regionDisplayTree-&gt;setPseudo(textTrackRegionShadowPseudoId());</span>

394 }
395 
396 void VTTRegion::startTimer()
397 {
398     LOG(Media, &quot;VTTRegion::startTimer&quot;);
399 
400     if (m_scrollTimer.isActive())
401         return;
402 
403     Seconds duration = isScrollingRegion() ? scrollTime : 0_s;
404     m_scrollTimer.startOneShot(duration);
405 }
406 
407 void VTTRegion::stopTimer()
408 {
409     LOG(Media, &quot;VTTRegion::stopTimer&quot;);
410 
411     if (m_scrollTimer.isActive())
412         m_scrollTimer.stop();
413 }
</pre>
</td>
<td>
<hr />
<pre>
264 {
265     static NeverDestroyed&lt;const AtomString&gt; trackRegionCueContainerScrollingClass(&quot;scrolling&quot;, AtomString::ConstructFromLiteral);
266 
267     return trackRegionCueContainerScrollingClass;
268 }
269 
270 const AtomString&amp; VTTRegion::textTrackCueContainerShadowPseudoId()
271 {
272     static NeverDestroyed&lt;const AtomString&gt; trackRegionCueContainerPseudoId(&quot;-webkit-media-text-track-region-container&quot;, AtomString::ConstructFromLiteral);
273 
274     return trackRegionCueContainerPseudoId;
275 }
276 
277 const AtomString&amp; VTTRegion::textTrackRegionShadowPseudoId()
278 {
279     static NeverDestroyed&lt;const AtomString&gt; trackRegionShadowPseudoId(&quot;-webkit-media-text-track-region&quot;, AtomString::ConstructFromLiteral);
280 
281     return trackRegionShadowPseudoId;
282 }
283 
<span class="line-modified">284 void VTTRegion::appendTextTrackCueBox(Ref&lt;TextTrackCueBox&gt;&amp;&amp; displayBox)</span>
285 {
286     ASSERT(m_cueContainer);
287 
288     if (m_cueContainer-&gt;contains(displayBox.ptr()))
289         return;
290 
291     m_cueContainer-&gt;appendChild(displayBox);
292     displayLastTextTrackCueBox();
293 }
294 
295 void VTTRegion::displayLastTextTrackCueBox()
296 {
297     ASSERT(m_cueContainer);
298 
299     // The container needs to be rendered, if it is not empty and the region is not currently scrolling.
300     if (!m_cueContainer-&gt;renderer() || !m_cueContainer-&gt;hasChildNodes() || m_scrollTimer.isActive())
301         return;
302 
303     // If it&#39;s a scrolling region, add the scrolling class.
304     if (isScrollingRegion())
305         m_cueContainer-&gt;classList().add(textTrackCueContainerScrollingClass());
306 
307     float regionBottom = m_regionDisplayTree-&gt;getBoundingClientRect()-&gt;bottom();
308 
309     // Find first cue that is not entirely displayed and scroll it upwards.
310     for (auto&amp; child : childrenOfType&lt;Element&gt;(*m_cueContainer)) {
311         auto rect = child.getBoundingClientRect();
312         float childTop = rect-&gt;top();
313         float childBottom = rect-&gt;bottom();
314 
315         if (regionBottom &gt;= childBottom)
316             continue;
317 
318         float height = childBottom - childTop;
319 
320         m_currentTop -= std::min(height, childBottom - regionBottom);
<span class="line-modified">321         m_cueContainer-&gt;setInlineStyleProperty(CSSPropertyTop, m_currentTop, CSSUnitType::CSS_PX);</span>
322 
323         startTimer();
324         break;
325     }
326 }
327 
328 void VTTRegion::willRemoveTextTrackCueBox(VTTCueBox* box)
329 {
330     LOG(Media, &quot;VTTRegion::willRemoveTextTrackCueBox&quot;);
331     ASSERT(m_cueContainer-&gt;contains(box));
332 
333     double boxHeight = box-&gt;getBoundingClientRect()-&gt;bottom() - box-&gt;getBoundingClientRect()-&gt;top();
334 
335     m_cueContainer-&gt;classList().remove(textTrackCueContainerScrollingClass());
336 
337     m_currentTop += boxHeight;
<span class="line-modified">338     m_cueContainer-&gt;setInlineStyleProperty(CSSPropertyTop, m_currentTop, CSSUnitType::CSS_PX);</span>
339 }
340 
341 HTMLDivElement&amp; VTTRegion::getDisplayTree()
342 {
343     if (!m_regionDisplayTree) {
344         m_regionDisplayTree = HTMLDivElement::create(downcast&lt;Document&gt;(*m_scriptExecutionContext));
<span class="line-modified">345         m_regionDisplayTree-&gt;setPseudo(textTrackRegionShadowPseudoId());</span>
<span class="line-added">346         m_recalculateStyles = true;</span>
347     }
348 
<span class="line-added">349     if (m_recalculateStyles)</span>
<span class="line-added">350         prepareRegionDisplayTree();</span>
<span class="line-added">351 </span>
352     return *m_regionDisplayTree;
353 }
354 
355 void VTTRegion::prepareRegionDisplayTree()
356 {
357     ASSERT(m_regionDisplayTree);
358 
359     // 7.2 Prepare region CSS boxes
360 
361     // FIXME: Change the code below to use viewport units when
362     // http://crbug/244618 is fixed.
363 
364     // Let regionWidth be the text track region width.
365     // Let width be &#39;regionWidth vw&#39; (&#39;vw&#39; is a CSS unit)
<span class="line-modified">366     m_regionDisplayTree-&gt;setInlineStyleProperty(CSSPropertyWidth, m_width, CSSUnitType::CSS_PERCENTAGE);</span>
367 
368     // Let lineHeight be &#39;0.0533vh&#39; (&#39;vh&#39; is a CSS unit) and regionHeight be
369     // the text track region height. Let height be &#39;lineHeight&#39; multiplied
370     // by regionHeight.
371     double height = lineHeight * m_lines;
<span class="line-modified">372     m_regionDisplayTree-&gt;setInlineStyleProperty(CSSPropertyHeight, height, CSSUnitType::CSS_VH);</span>
373 
374     // Let viewportAnchorX be the x dimension of the text track region viewport
375     // anchor and regionAnchorX be the x dimension of the text track region
376     // anchor. Let leftOffset be regionAnchorX multiplied by width divided by
377     // 100.0. Let left be leftOffset subtracted from &#39;viewportAnchorX vw&#39;.
378     double leftOffset = m_regionAnchor.x() * m_width / 100;
<span class="line-modified">379     m_regionDisplayTree-&gt;setInlineStyleProperty(CSSPropertyLeft, m_viewportAnchor.x() - leftOffset, CSSUnitType::CSS_PERCENTAGE);</span>
380 
381     // Let viewportAnchorY be the y dimension of the text track region viewport
382     // anchor and regionAnchorY be the y dimension of the text track region
383     // anchor. Let topOffset be regionAnchorY multiplied by height divided by
384     // 100.0. Let top be topOffset subtracted from &#39;viewportAnchorY vh&#39;.
385     double topOffset = m_regionAnchor.y() * height / 100;
<span class="line-modified">386     m_regionDisplayTree-&gt;setInlineStyleProperty(CSSPropertyTop, m_viewportAnchor.y() - topOffset, CSSUnitType::CSS_PERCENTAGE);</span>
387 
388     // The cue container is used to wrap the cues and it is the object which is
389     // gradually scrolled out as multiple cues are appended to the region.
<span class="line-modified">390     if (!m_cueContainer) {</span>
<span class="line-modified">391         m_cueContainer = HTMLDivElement::create(downcast&lt;Document&gt;(*m_scriptExecutionContext));</span>
<span class="line-modified">392         m_cueContainer-&gt;setPseudo(textTrackCueContainerShadowPseudoId());</span>
<span class="line-modified">393         m_regionDisplayTree-&gt;appendChild(*m_cueContainer);</span>
<span class="line-modified">394     }</span>
<span class="line-added">395     m_cueContainer-&gt;setInlineStyleProperty(CSSPropertyTop, 0.0f, CSSUnitType::CSS_PX);</span>
396 
397     // 7.5 Every WebVTT region object is initialised with the following CSS
<span class="line-modified">398 </span>
<span class="line-added">399     m_recalculateStyles = false;</span>
400 }
401 
402 void VTTRegion::startTimer()
403 {
404     LOG(Media, &quot;VTTRegion::startTimer&quot;);
405 
406     if (m_scrollTimer.isActive())
407         return;
408 
409     Seconds duration = isScrollingRegion() ? scrollTime : 0_s;
410     m_scrollTimer.startOneShot(duration);
411 }
412 
413 void VTTRegion::stopTimer()
414 {
415     LOG(Media, &quot;VTTRegion::stopTimer&quot;);
416 
417     if (m_scrollTimer.isActive())
418         m_scrollTimer.stop();
419 }
</pre>
</td>
</tr>
</table>
<center><a href="VTTCue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="VTTRegion.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
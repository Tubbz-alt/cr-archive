<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/NumberPrototype.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NumberObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="NumberPrototype.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/NumberPrototype.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 27 #include &quot;IntlNumberFormat.h&quot;
 28 #include &quot;IntlObject.h&quot;
 29 #include &quot;JSCInlines.h&quot;
 30 #include &quot;JSFunction.h&quot;
 31 #include &quot;JSGlobalObject.h&quot;
 32 #include &quot;JSString.h&quot;
 33 #include &quot;ParseInt.h&quot;
 34 #include &quot;Uint16WithFraction.h&quot;
 35 #include &lt;wtf/dtoa.h&gt;
 36 #include &lt;wtf/Assertions.h&gt;
 37 #include &lt;wtf/MathExtras.h&gt;
 38 #include &lt;wtf/dtoa/double-conversion.h&gt;
 39 
 40 using DoubleToStringConverter = WTF::double_conversion::DoubleToStringConverter;
 41 
 42 // To avoid conflict with WTF::StringBuilder.
 43 typedef WTF::double_conversion::StringBuilder DoubleConversionStringBuilder;
 44 
 45 namespace JSC {
 46 
<span class="line-modified"> 47 static EncodedJSValue JSC_HOST_CALL numberProtoFuncToString(ExecState*);</span>
<span class="line-modified"> 48 static EncodedJSValue JSC_HOST_CALL numberProtoFuncToLocaleString(ExecState*);</span>
<span class="line-modified"> 49 static EncodedJSValue JSC_HOST_CALL numberProtoFuncToFixed(ExecState*);</span>
<span class="line-modified"> 50 static EncodedJSValue JSC_HOST_CALL numberProtoFuncToExponential(ExecState*);</span>
<span class="line-removed"> 51 static EncodedJSValue JSC_HOST_CALL numberProtoFuncToPrecision(ExecState*);</span>
 52 
 53 }
 54 
 55 #include &quot;NumberPrototype.lut.h&quot;
 56 
 57 namespace JSC {
 58 
 59 const ClassInfo NumberPrototype::s_info = { &quot;Number&quot;, &amp;NumberObject::s_info, &amp;numberPrototypeTable, nullptr, CREATE_METHOD_TABLE(NumberPrototype) };
 60 
 61 /* Source for NumberPrototype.lut.h
 62 @begin numberPrototypeTable
 63   toLocaleString    numberProtoFuncToLocaleString   DontEnum|Function 0
 64   valueOf           numberProtoFuncValueOf          DontEnum|Function 0
 65   toFixed           numberProtoFuncToFixed          DontEnum|Function 1
 66   toExponential     numberProtoFuncToExponential    DontEnum|Function 1
 67   toPrecision       numberProtoFuncToPrecision      DontEnum|Function 1
 68 @end
 69 */
 70 
 71 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(NumberPrototype);
 72 
 73 NumberPrototype::NumberPrototype(VM&amp; vm, Structure* structure)
 74     : NumberObject(vm, structure)
 75 {
 76 }
 77 
 78 void NumberPrototype::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 79 {
 80     Base::finishCreation(vm);
 81     setInternalValue(vm, jsNumber(0));
<span class="line-modified"> 82 </span>
<span class="line-removed"> 83     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;toString, numberProtoFuncToString, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, NumberPrototypeToStringIntrinsic);</span>
 84     ASSERT(inherits(vm, info()));

 85 }
 86 
 87 // ------------------------------ Functions ---------------------------
 88 
 89 static ALWAYS_INLINE bool toThisNumber(VM&amp; vm, JSValue thisValue, double&amp; x)
 90 {
 91     if (thisValue.isInt32()) {
 92         x = thisValue.asInt32();
 93         return true;
 94     }
 95 
 96     if (thisValue.isDouble()) {
 97         x = thisValue.asDouble();
 98         return true;
 99     }
100 
101     if (auto* numberObject = jsDynamicCast&lt;NumberObject*&gt;(vm, thisValue)) {
102         x = numberObject-&gt;internalValue().asNumber();
103         return true;
104     }
105 
106     return false;
107 }
108 
<span class="line-modified">109 static ALWAYS_INLINE EncodedJSValue throwVMToThisNumberError(ExecState* exec, ThrowScope&amp; scope, JSValue thisValue)</span>
110 {
<span class="line-modified">111     auto typeString = asString(jsTypeStringForValue(exec-&gt;vm(), exec-&gt;lexicalGlobalObject(), thisValue))-&gt;value(exec);</span>
112     scope.assertNoException();
<span class="line-modified">113     return throwVMTypeError(exec, scope, WTF::makeString(&quot;thisNumberValue called on incompatible &quot;, typeString));</span>
<span class="line-removed">114 }</span>
<span class="line-removed">115 </span>
<span class="line-removed">116 static ALWAYS_INLINE bool getIntegerArgumentInRange(ExecState* exec, int low, int high, int&amp; result, bool&amp; isUndefined)</span>
<span class="line-removed">117 {</span>
<span class="line-removed">118     result = 0;</span>
<span class="line-removed">119     isUndefined = false;</span>
<span class="line-removed">120 </span>
<span class="line-removed">121     JSValue argument0 = exec-&gt;argument(0);</span>
<span class="line-removed">122     if (argument0.isUndefined()) {</span>
<span class="line-removed">123         isUndefined = true;</span>
<span class="line-removed">124         return true;</span>
<span class="line-removed">125     }</span>
<span class="line-removed">126 </span>
<span class="line-removed">127     double asDouble = argument0.toInteger(exec);</span>
<span class="line-removed">128     if (asDouble &lt; low || asDouble &gt; high)</span>
<span class="line-removed">129         return false;</span>
<span class="line-removed">130 </span>
<span class="line-removed">131     result = static_cast&lt;int&gt;(asDouble);</span>
<span class="line-removed">132     return true;</span>
133 }
134 
135 // The largest finite floating point number is 1.mantissa * 2^(0x7fe-0x3ff).
136 // Since 2^N in binary is a one bit followed by N zero bits. 1 * 2^3ff requires
137 // at most 1024 characters to the left of a decimal point, in base 2 (1025 if
138 // we include a minus sign). For the fraction, a value with an exponent of 0
139 // has up to 52 bits to the right of the decimal point. Each decrement of the
140 // exponent down to a minimum of -0x3fe adds an additional digit to the length
141 // of the fraction. As such the maximum fraction size is 1075 (1076 including
142 // a point). We pick a buffer size such that can simply place the point in the
143 // center of the buffer, and are guaranteed to have enough space in each direction
144 // fo any number of digits an IEEE number may require to represent.
145 typedef char RadixBuffer[2180];
146 
147 static inline char* int52ToStringWithRadix(char* startOfResultString, int64_t int52Value, unsigned radix)
148 {
149     bool negative = false;
150     uint64_t positiveNumber = int52Value;
151     if (int52Value &lt; 0) {
152         negative = true;
</pre>
<hr />
<pre>
388 
389 String toStringWithRadix(double doubleValue, int32_t radix)
390 {
391     ASSERT(2 &lt;= radix &amp;&amp; radix &lt;= 36);
392 
393     int32_t integerValue = static_cast&lt;int32_t&gt;(doubleValue);
394     if (integerValue == doubleValue)
395         return toStringWithRadixInternal(integerValue, radix);
396 
397     if (radix == 10 || !std::isfinite(doubleValue))
398         return String::number(doubleValue);
399 
400     RadixBuffer buffer;
401     return toStringWithRadixInternal(buffer, doubleValue, radix);
402 }
403 
404 // toExponential converts a number to a string, always formatting as an exponential.
405 // This method takes an optional argument specifying a number of *decimal places*
406 // to round the significand to (or, put another way, this method optionally rounds
407 // to argument-plus-one significant figures).
<span class="line-modified">408 EncodedJSValue JSC_HOST_CALL numberProtoFuncToExponential(ExecState* exec)</span>
409 {
<span class="line-modified">410     VM&amp; vm = exec-&gt;vm();</span>
411     auto scope = DECLARE_THROW_SCOPE(vm);
412 
413     double x;
<span class="line-modified">414     if (!toThisNumber(vm, exec-&gt;thisValue(), x))</span>
<span class="line-modified">415         return throwVMToThisNumberError(exec, scope, exec-&gt;thisValue());</span>
416 

417     // Perform ToInteger on the argument before remaining steps.
<span class="line-modified">418     int decimalPlacesInExponent;</span>
<span class="line-removed">419     bool isUndefined;</span>
<span class="line-removed">420     bool inRange = getIntegerArgumentInRange(exec, 0, 20, decimalPlacesInExponent, isUndefined);</span>
421     RETURN_IF_EXCEPTION(scope, { });
422 
423     // Handle NaN and Infinity.
424     if (!std::isfinite(x))
425         return JSValue::encode(jsNontrivialString(vm, String::number(x)));
426 
<span class="line-modified">427     if (!inRange)</span>
<span class="line-modified">428         return throwVMError(exec, scope, createRangeError(exec, &quot;toExponential() argument must be between 0 and 20&quot;_s));</span>
429 
430     // Round if the argument is not undefined, always format as exponential.
431     NumberToStringBuffer buffer;
432     DoubleConversionStringBuilder builder { &amp;buffer[0], sizeof(buffer) };
433     const DoubleToStringConverter&amp; converter = DoubleToStringConverter::EcmaScriptConverter();
434     builder.Reset();
<span class="line-modified">435     isUndefined</span>
<span class="line-modified">436         ? converter.ToExponential(x, -1, &amp;builder)</span>
<span class="line-modified">437         : converter.ToExponential(x, decimalPlacesInExponent, &amp;builder);</span>

438     return JSValue::encode(jsString(vm, builder.Finalize()));
439 }
440 
441 // toFixed converts a number to a string, always formatting as an a decimal fraction.
442 // This method takes an argument specifying a number of decimal places to round the
443 // significand to. However when converting large values (1e+21 and above) this
444 // method will instead fallback to calling ToString.
<span class="line-modified">445 EncodedJSValue JSC_HOST_CALL numberProtoFuncToFixed(ExecState* exec)</span>
446 {
<span class="line-modified">447     VM&amp; vm = exec-&gt;vm();</span>
448     auto scope = DECLARE_THROW_SCOPE(vm);
449 
450     double x;
<span class="line-modified">451     if (!toThisNumber(vm, exec-&gt;thisValue(), x))</span>
<span class="line-modified">452         return throwVMToThisNumberError(exec, scope, exec-&gt;thisValue());</span>
453 
<span class="line-modified">454     // Get the argument.</span>
<span class="line-removed">455     int decimalPlaces;</span>
<span class="line-removed">456     bool isUndefined; // This is ignored; undefined treated as 0.</span>
<span class="line-removed">457     bool inRange = getIntegerArgumentInRange(exec, 0, 20, decimalPlaces, isUndefined);</span>
458     RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">459     if (!inRange)</span>
<span class="line-modified">460         return throwVMError(exec, scope, createRangeError(exec, &quot;toFixed() argument must be between 0 and 20&quot;_s));</span>
461 
462     // 15.7.4.5.7 states &quot;If x &gt;= 10^21, then let m = ToString(x)&quot;
463     // This also covers Ininity, and structure the check so that NaN
464     // values are also handled by numberToString
465     if (!(fabs(x) &lt; 1e+21))
466         return JSValue::encode(jsString(vm, String::number(x)));
467 
468     // The check above will return false for NaN or Infinity, these will be
469     // handled by numberToString.
470     ASSERT(std::isfinite(x));
471 
472     return JSValue::encode(jsString(vm, String::numberToStringFixedWidth(x, decimalPlaces)));
473 }
474 
475 // toPrecision converts a number to a string, taking an argument specifying a
476 // number of significant figures to round the significand to. For positive
477 // exponent, all values that can be represented using a decimal fraction will
478 // be, e.g. when rounding to 3 s.f. any value up to 999 will be formated as a
479 // decimal, whilst 1000 is converted to the exponential representation 1.00e+3.
480 // For negative exponents values &gt;= 1e-6 are formated as decimal fractions,
481 // with smaller values converted to exponential representation.
<span class="line-modified">482 EncodedJSValue JSC_HOST_CALL numberProtoFuncToPrecision(ExecState* exec)</span>
483 {
<span class="line-modified">484     VM&amp; vm = exec-&gt;vm();</span>
485     auto scope = DECLARE_THROW_SCOPE(vm);
486 
487     double x;
<span class="line-modified">488     if (!toThisNumber(vm, exec-&gt;thisValue(), x))</span>
<span class="line-modified">489         return throwVMToThisNumberError(exec, scope, exec-&gt;thisValue());</span>
<span class="line-removed">490 </span>
<span class="line-removed">491     // Perform ToInteger on the argument before remaining steps.</span>
<span class="line-removed">492     int significantFigures;</span>
<span class="line-removed">493     bool isUndefined;</span>
<span class="line-removed">494     bool inRange = getIntegerArgumentInRange(exec, 1, 21, significantFigures, isUndefined);</span>
<span class="line-removed">495     RETURN_IF_EXCEPTION(scope, { });</span>
496 

497     // To precision called with no argument is treated as ToString.
<span class="line-modified">498     if (isUndefined)</span>
499         return JSValue::encode(jsString(vm, String::number(x)));
500 




501     // Handle NaN and Infinity.
502     if (!std::isfinite(x))
503         return JSValue::encode(jsNontrivialString(vm, String::number(x)));
504 
<span class="line-modified">505     if (!inRange)</span>
<span class="line-modified">506         return throwVMError(exec, scope, createRangeError(exec, &quot;toPrecision() argument must be between 1 and 21&quot;_s));</span>
507 
508     return JSValue::encode(jsString(vm, String::numberToStringFixedPrecision(x, significantFigures, KeepTrailingZeros)));
509 }
510 
511 static ALWAYS_INLINE JSString* int32ToStringInternal(VM&amp; vm, int32_t value, int32_t radix)
512 {
513     ASSERT(!(radix &lt; 2 || radix &gt; 36));
514     // A negative value casted to unsigned would be bigger than 36 (the max radix).
515     if (static_cast&lt;unsigned&gt;(value) &lt; static_cast&lt;unsigned&gt;(radix)) {
516         ASSERT(value &lt;= 36);
517         ASSERT(value &gt;= 0);
518         return vm.smallStrings.singleCharacterString(radixDigits[value]);
519     }
520 
521     if (radix == 10)
522         return jsNontrivialString(vm, vm.numericStrings.add(value));
523 
524     return jsNontrivialString(vm, toStringWithRadixInternal(value, radix));
525 
526 }
</pre>
<hr />
<pre>
559     }
560 
561     if (radix == 10)
562         return jsNontrivialString(vm, vm.numericStrings.add(static_cast&lt;double&gt;(value)));
563 
564     // Position the decimal point at the center of the string, set
565     // the startOfResultString pointer to point at the decimal point.
566     RadixBuffer buffer;
567     char* decimalPoint = buffer + sizeof(buffer) / 2;
568     char* startOfResultString = decimalPoint;
569     *decimalPoint = &#39;\0&#39;;
570 
571     return jsNontrivialString(vm, int52ToStringWithRadix(startOfResultString, value, radix));
572 }
573 
574 JSString* numberToString(VM&amp; vm, double doubleValue, int32_t radix)
575 {
576     return numberToStringInternal(vm, doubleValue, radix);
577 }
578 
<span class="line-modified">579 EncodedJSValue JSC_HOST_CALL numberProtoFuncToString(ExecState* state)</span>
580 {
<span class="line-modified">581     VM&amp; vm = state-&gt;vm();</span>
582     auto scope = DECLARE_THROW_SCOPE(vm);
583 
584     double doubleValue;
<span class="line-modified">585     if (!toThisNumber(vm, state-&gt;thisValue(), doubleValue))</span>
<span class="line-modified">586         return throwVMToThisNumberError(state, scope, state-&gt;thisValue());</span>
587 
<span class="line-modified">588     auto radix = extractToStringRadixArgument(state, state-&gt;argument(0), scope);</span>
589     RETURN_IF_EXCEPTION(scope, encodedJSValue());
590 
591     return JSValue::encode(numberToStringInternal(vm, doubleValue, radix));
592 }
593 
<span class="line-modified">594 EncodedJSValue JSC_HOST_CALL numberProtoFuncToLocaleString(ExecState* exec)</span>
595 {
<span class="line-modified">596     VM&amp; vm = exec-&gt;vm();</span>
597     auto scope = DECLARE_THROW_SCOPE(vm);
598 
599     double x;
<span class="line-modified">600     if (!toThisNumber(vm, exec-&gt;thisValue(), x))</span>
<span class="line-modified">601         return throwVMToThisNumberError(exec, scope, exec-&gt;thisValue());</span>
602 
603 #if ENABLE(INTL)
<span class="line-removed">604     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
605     IntlNumberFormat* numberFormat = IntlNumberFormat::create(vm, globalObject-&gt;numberFormatStructure());
<span class="line-modified">606     numberFormat-&gt;initializeNumberFormat(*exec, exec-&gt;argument(0), exec-&gt;argument(1));</span>
607     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">608     RELEASE_AND_RETURN(scope, JSValue::encode(numberFormat-&gt;formatNumber(*exec, x)));</span>
609 #else
<span class="line-modified">610     return JSValue::encode(jsNumber(x).toString(exec));</span>
611 #endif
612 }
613 
<span class="line-modified">614 EncodedJSValue JSC_HOST_CALL numberProtoFuncValueOf(ExecState* exec)</span>
615 {
<span class="line-modified">616     VM&amp; vm = exec-&gt;vm();</span>
617     auto scope = DECLARE_THROW_SCOPE(vm);
618 
619     double x;
<span class="line-modified">620     JSValue thisValue = exec-&gt;thisValue();</span>
621     if (!toThisNumber(vm, thisValue, x))
<span class="line-modified">622         return throwVMToThisNumberError(exec, scope, exec-&gt;thisValue());</span>
623     return JSValue::encode(jsNumber(x));
624 }
625 
<span class="line-modified">626 int32_t extractToStringRadixArgument(ExecState* state, JSValue radixValue, ThrowScope&amp; throwScope)</span>
627 {
628     if (radixValue.isUndefined())
629         return 10;
630 
631     if (radixValue.isInt32()) {
632         int32_t radix = radixValue.asInt32();
633         if (radix &gt;= 2 &amp;&amp; radix &lt;= 36)
634             return radix;
635     } else {
<span class="line-modified">636         double radixDouble = radixValue.toInteger(state);</span>
637         RETURN_IF_EXCEPTION(throwScope, 0);
638         if (radixDouble &gt;= 2 &amp;&amp; radixDouble &lt;= 36)
639             return static_cast&lt;int32_t&gt;(radixDouble);
640     }
641 
<span class="line-modified">642     throwRangeError(state, throwScope, &quot;toString() radix argument must be between 2 and 36&quot;_s);</span>
643     return 0;
644 }
645 
646 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 27 #include &quot;IntlNumberFormat.h&quot;
 28 #include &quot;IntlObject.h&quot;
 29 #include &quot;JSCInlines.h&quot;
 30 #include &quot;JSFunction.h&quot;
 31 #include &quot;JSGlobalObject.h&quot;
 32 #include &quot;JSString.h&quot;
 33 #include &quot;ParseInt.h&quot;
 34 #include &quot;Uint16WithFraction.h&quot;
 35 #include &lt;wtf/dtoa.h&gt;
 36 #include &lt;wtf/Assertions.h&gt;
 37 #include &lt;wtf/MathExtras.h&gt;
 38 #include &lt;wtf/dtoa/double-conversion.h&gt;
 39 
 40 using DoubleToStringConverter = WTF::double_conversion::DoubleToStringConverter;
 41 
 42 // To avoid conflict with WTF::StringBuilder.
 43 typedef WTF::double_conversion::StringBuilder DoubleConversionStringBuilder;
 44 
 45 namespace JSC {
 46 
<span class="line-modified"> 47 static EncodedJSValue JSC_HOST_CALL numberProtoFuncToLocaleString(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 48 static EncodedJSValue JSC_HOST_CALL numberProtoFuncToFixed(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 49 static EncodedJSValue JSC_HOST_CALL numberProtoFuncToExponential(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified"> 50 static EncodedJSValue JSC_HOST_CALL numberProtoFuncToPrecision(JSGlobalObject*, CallFrame*);</span>

 51 
 52 }
 53 
 54 #include &quot;NumberPrototype.lut.h&quot;
 55 
 56 namespace JSC {
 57 
 58 const ClassInfo NumberPrototype::s_info = { &quot;Number&quot;, &amp;NumberObject::s_info, &amp;numberPrototypeTable, nullptr, CREATE_METHOD_TABLE(NumberPrototype) };
 59 
 60 /* Source for NumberPrototype.lut.h
 61 @begin numberPrototypeTable
 62   toLocaleString    numberProtoFuncToLocaleString   DontEnum|Function 0
 63   valueOf           numberProtoFuncValueOf          DontEnum|Function 0
 64   toFixed           numberProtoFuncToFixed          DontEnum|Function 1
 65   toExponential     numberProtoFuncToExponential    DontEnum|Function 1
 66   toPrecision       numberProtoFuncToPrecision      DontEnum|Function 1
 67 @end
 68 */
 69 
 70 STATIC_ASSERT_IS_TRIVIALLY_DESTRUCTIBLE(NumberPrototype);
 71 
 72 NumberPrototype::NumberPrototype(VM&amp; vm, Structure* structure)
 73     : NumberObject(vm, structure)
 74 {
 75 }
 76 
 77 void NumberPrototype::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
 78 {
 79     Base::finishCreation(vm);
 80     setInternalValue(vm, jsNumber(0));
<span class="line-modified"> 81     putDirectWithoutTransition(vm, vm.propertyNames-&gt;toString, globalObject-&gt;numberProtoToStringFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>

 82     ASSERT(inherits(vm, info()));
<span class="line-added"> 83     globalObject-&gt;installNumberPrototypeWatchpoint(this);</span>
 84 }
 85 
 86 // ------------------------------ Functions ---------------------------
 87 
 88 static ALWAYS_INLINE bool toThisNumber(VM&amp; vm, JSValue thisValue, double&amp; x)
 89 {
 90     if (thisValue.isInt32()) {
 91         x = thisValue.asInt32();
 92         return true;
 93     }
 94 
 95     if (thisValue.isDouble()) {
 96         x = thisValue.asDouble();
 97         return true;
 98     }
 99 
100     if (auto* numberObject = jsDynamicCast&lt;NumberObject*&gt;(vm, thisValue)) {
101         x = numberObject-&gt;internalValue().asNumber();
102         return true;
103     }
104 
105     return false;
106 }
107 
<span class="line-modified">108 static ALWAYS_INLINE EncodedJSValue throwVMToThisNumberError(JSGlobalObject* globalObject, ThrowScope&amp; scope, JSValue thisValue)</span>
109 {
<span class="line-modified">110     auto typeString = asString(jsTypeStringForValue(globalObject-&gt;vm(), globalObject, thisValue))-&gt;value(globalObject);</span>
111     scope.assertNoException();
<span class="line-modified">112     return throwVMTypeError(globalObject, scope, WTF::makeString(&quot;thisNumberValue called on incompatible &quot;, typeString));</span>



















113 }
114 
115 // The largest finite floating point number is 1.mantissa * 2^(0x7fe-0x3ff).
116 // Since 2^N in binary is a one bit followed by N zero bits. 1 * 2^3ff requires
117 // at most 1024 characters to the left of a decimal point, in base 2 (1025 if
118 // we include a minus sign). For the fraction, a value with an exponent of 0
119 // has up to 52 bits to the right of the decimal point. Each decrement of the
120 // exponent down to a minimum of -0x3fe adds an additional digit to the length
121 // of the fraction. As such the maximum fraction size is 1075 (1076 including
122 // a point). We pick a buffer size such that can simply place the point in the
123 // center of the buffer, and are guaranteed to have enough space in each direction
124 // fo any number of digits an IEEE number may require to represent.
125 typedef char RadixBuffer[2180];
126 
127 static inline char* int52ToStringWithRadix(char* startOfResultString, int64_t int52Value, unsigned radix)
128 {
129     bool negative = false;
130     uint64_t positiveNumber = int52Value;
131     if (int52Value &lt; 0) {
132         negative = true;
</pre>
<hr />
<pre>
368 
369 String toStringWithRadix(double doubleValue, int32_t radix)
370 {
371     ASSERT(2 &lt;= radix &amp;&amp; radix &lt;= 36);
372 
373     int32_t integerValue = static_cast&lt;int32_t&gt;(doubleValue);
374     if (integerValue == doubleValue)
375         return toStringWithRadixInternal(integerValue, radix);
376 
377     if (radix == 10 || !std::isfinite(doubleValue))
378         return String::number(doubleValue);
379 
380     RadixBuffer buffer;
381     return toStringWithRadixInternal(buffer, doubleValue, radix);
382 }
383 
384 // toExponential converts a number to a string, always formatting as an exponential.
385 // This method takes an optional argument specifying a number of *decimal places*
386 // to round the significand to (or, put another way, this method optionally rounds
387 // to argument-plus-one significant figures).
<span class="line-modified">388 EncodedJSValue JSC_HOST_CALL numberProtoFuncToExponential(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
389 {
<span class="line-modified">390     VM&amp; vm = globalObject-&gt;vm();</span>
391     auto scope = DECLARE_THROW_SCOPE(vm);
392 
393     double x;
<span class="line-modified">394     if (!toThisNumber(vm, callFrame-&gt;thisValue(), x))</span>
<span class="line-modified">395         return throwVMToThisNumberError(globalObject, scope, callFrame-&gt;thisValue());</span>
396 
<span class="line-added">397     JSValue arg = callFrame-&gt;argument(0);</span>
398     // Perform ToInteger on the argument before remaining steps.
<span class="line-modified">399     int decimalPlaces = static_cast&lt;int&gt;(arg.toInteger(globalObject));</span>


400     RETURN_IF_EXCEPTION(scope, { });
401 
402     // Handle NaN and Infinity.
403     if (!std::isfinite(x))
404         return JSValue::encode(jsNontrivialString(vm, String::number(x)));
405 
<span class="line-modified">406     if (decimalPlaces &lt; 0 || decimalPlaces &gt; 100)</span>
<span class="line-modified">407         return throwVMRangeError(globalObject, scope, &quot;toExponential() argument must be between 0 and 100&quot;_s);</span>
408 
409     // Round if the argument is not undefined, always format as exponential.
410     NumberToStringBuffer buffer;
411     DoubleConversionStringBuilder builder { &amp;buffer[0], sizeof(buffer) };
412     const DoubleToStringConverter&amp; converter = DoubleToStringConverter::EcmaScriptConverter();
413     builder.Reset();
<span class="line-modified">414     if (arg.isUndefined())</span>
<span class="line-modified">415         converter.ToExponential(x, -1, &amp;builder);</span>
<span class="line-modified">416     else</span>
<span class="line-added">417         converter.ToExponential(x, decimalPlaces, &amp;builder);</span>
418     return JSValue::encode(jsString(vm, builder.Finalize()));
419 }
420 
421 // toFixed converts a number to a string, always formatting as an a decimal fraction.
422 // This method takes an argument specifying a number of decimal places to round the
423 // significand to. However when converting large values (1e+21 and above) this
424 // method will instead fallback to calling ToString.
<span class="line-modified">425 EncodedJSValue JSC_HOST_CALL numberProtoFuncToFixed(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
426 {
<span class="line-modified">427     VM&amp; vm = globalObject-&gt;vm();</span>
428     auto scope = DECLARE_THROW_SCOPE(vm);
429 
430     double x;
<span class="line-modified">431     if (!toThisNumber(vm, callFrame-&gt;thisValue(), x))</span>
<span class="line-modified">432         return throwVMToThisNumberError(globalObject, scope, callFrame-&gt;thisValue());</span>
433 
<span class="line-modified">434     int decimalPlaces = static_cast&lt;int&gt;(callFrame-&gt;argument(0).toInteger(globalObject));</span>



435     RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">436     if (decimalPlaces &lt; 0 || decimalPlaces &gt; 100)</span>
<span class="line-modified">437         return throwVMRangeError(globalObject, scope, &quot;toFixed() argument must be between 0 and 100&quot;_s);</span>
438 
439     // 15.7.4.5.7 states &quot;If x &gt;= 10^21, then let m = ToString(x)&quot;
440     // This also covers Ininity, and structure the check so that NaN
441     // values are also handled by numberToString
442     if (!(fabs(x) &lt; 1e+21))
443         return JSValue::encode(jsString(vm, String::number(x)));
444 
445     // The check above will return false for NaN or Infinity, these will be
446     // handled by numberToString.
447     ASSERT(std::isfinite(x));
448 
449     return JSValue::encode(jsString(vm, String::numberToStringFixedWidth(x, decimalPlaces)));
450 }
451 
452 // toPrecision converts a number to a string, taking an argument specifying a
453 // number of significant figures to round the significand to. For positive
454 // exponent, all values that can be represented using a decimal fraction will
455 // be, e.g. when rounding to 3 s.f. any value up to 999 will be formated as a
456 // decimal, whilst 1000 is converted to the exponential representation 1.00e+3.
457 // For negative exponents values &gt;= 1e-6 are formated as decimal fractions,
458 // with smaller values converted to exponential representation.
<span class="line-modified">459 EncodedJSValue JSC_HOST_CALL numberProtoFuncToPrecision(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
460 {
<span class="line-modified">461     VM&amp; vm = globalObject-&gt;vm();</span>
462     auto scope = DECLARE_THROW_SCOPE(vm);
463 
464     double x;
<span class="line-modified">465     if (!toThisNumber(vm, callFrame-&gt;thisValue(), x))</span>
<span class="line-modified">466         return throwVMToThisNumberError(globalObject, scope, callFrame-&gt;thisValue());</span>






467 
<span class="line-added">468     JSValue arg = callFrame-&gt;argument(0);</span>
469     // To precision called with no argument is treated as ToString.
<span class="line-modified">470     if (arg.isUndefined())</span>
471         return JSValue::encode(jsString(vm, String::number(x)));
472 
<span class="line-added">473     // Perform ToInteger on the argument before remaining steps.</span>
<span class="line-added">474     int significantFigures = static_cast&lt;int&gt;(arg.toInteger(globalObject));</span>
<span class="line-added">475     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">476 </span>
477     // Handle NaN and Infinity.
478     if (!std::isfinite(x))
479         return JSValue::encode(jsNontrivialString(vm, String::number(x)));
480 
<span class="line-modified">481     if (significantFigures &lt; 1 || significantFigures &gt; 100)</span>
<span class="line-modified">482         return throwVMRangeError(globalObject, scope, &quot;toPrecision() argument must be between 1 and 100&quot;_s);</span>
483 
484     return JSValue::encode(jsString(vm, String::numberToStringFixedPrecision(x, significantFigures, KeepTrailingZeros)));
485 }
486 
487 static ALWAYS_INLINE JSString* int32ToStringInternal(VM&amp; vm, int32_t value, int32_t radix)
488 {
489     ASSERT(!(radix &lt; 2 || radix &gt; 36));
490     // A negative value casted to unsigned would be bigger than 36 (the max radix).
491     if (static_cast&lt;unsigned&gt;(value) &lt; static_cast&lt;unsigned&gt;(radix)) {
492         ASSERT(value &lt;= 36);
493         ASSERT(value &gt;= 0);
494         return vm.smallStrings.singleCharacterString(radixDigits[value]);
495     }
496 
497     if (radix == 10)
498         return jsNontrivialString(vm, vm.numericStrings.add(value));
499 
500     return jsNontrivialString(vm, toStringWithRadixInternal(value, radix));
501 
502 }
</pre>
<hr />
<pre>
535     }
536 
537     if (radix == 10)
538         return jsNontrivialString(vm, vm.numericStrings.add(static_cast&lt;double&gt;(value)));
539 
540     // Position the decimal point at the center of the string, set
541     // the startOfResultString pointer to point at the decimal point.
542     RadixBuffer buffer;
543     char* decimalPoint = buffer + sizeof(buffer) / 2;
544     char* startOfResultString = decimalPoint;
545     *decimalPoint = &#39;\0&#39;;
546 
547     return jsNontrivialString(vm, int52ToStringWithRadix(startOfResultString, value, radix));
548 }
549 
550 JSString* numberToString(VM&amp; vm, double doubleValue, int32_t radix)
551 {
552     return numberToStringInternal(vm, doubleValue, radix);
553 }
554 
<span class="line-modified">555 EncodedJSValue JSC_HOST_CALL numberProtoFuncToString(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
556 {
<span class="line-modified">557     VM&amp; vm = globalObject-&gt;vm();</span>
558     auto scope = DECLARE_THROW_SCOPE(vm);
559 
560     double doubleValue;
<span class="line-modified">561     if (!toThisNumber(vm, callFrame-&gt;thisValue(), doubleValue))</span>
<span class="line-modified">562         return throwVMToThisNumberError(globalObject, scope, callFrame-&gt;thisValue());</span>
563 
<span class="line-modified">564     auto radix = extractToStringRadixArgument(globalObject, callFrame-&gt;argument(0), scope);</span>
565     RETURN_IF_EXCEPTION(scope, encodedJSValue());
566 
567     return JSValue::encode(numberToStringInternal(vm, doubleValue, radix));
568 }
569 
<span class="line-modified">570 EncodedJSValue JSC_HOST_CALL numberProtoFuncToLocaleString(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
571 {
<span class="line-modified">572     VM&amp; vm = globalObject-&gt;vm();</span>
573     auto scope = DECLARE_THROW_SCOPE(vm);
574 
575     double x;
<span class="line-modified">576     if (!toThisNumber(vm, callFrame-&gt;thisValue(), x))</span>
<span class="line-modified">577         return throwVMToThisNumberError(globalObject, scope, callFrame-&gt;thisValue());</span>
578 
579 #if ENABLE(INTL)

580     IntlNumberFormat* numberFormat = IntlNumberFormat::create(vm, globalObject-&gt;numberFormatStructure());
<span class="line-modified">581     numberFormat-&gt;initializeNumberFormat(globalObject, callFrame-&gt;argument(0), callFrame-&gt;argument(1));</span>
582     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">583     RELEASE_AND_RETURN(scope, JSValue::encode(numberFormat-&gt;formatNumber(globalObject, x)));</span>
584 #else
<span class="line-modified">585     return JSValue::encode(jsNumber(x).toString(globalObject));</span>
586 #endif
587 }
588 
<span class="line-modified">589 EncodedJSValue JSC_HOST_CALL numberProtoFuncValueOf(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
590 {
<span class="line-modified">591     VM&amp; vm = globalObject-&gt;vm();</span>
592     auto scope = DECLARE_THROW_SCOPE(vm);
593 
594     double x;
<span class="line-modified">595     JSValue thisValue = callFrame-&gt;thisValue();</span>
596     if (!toThisNumber(vm, thisValue, x))
<span class="line-modified">597         return throwVMToThisNumberError(globalObject, scope, callFrame-&gt;thisValue());</span>
598     return JSValue::encode(jsNumber(x));
599 }
600 
<span class="line-modified">601 int32_t extractToStringRadixArgument(JSGlobalObject* globalObject, JSValue radixValue, ThrowScope&amp; throwScope)</span>
602 {
603     if (radixValue.isUndefined())
604         return 10;
605 
606     if (radixValue.isInt32()) {
607         int32_t radix = radixValue.asInt32();
608         if (radix &gt;= 2 &amp;&amp; radix &lt;= 36)
609             return radix;
610     } else {
<span class="line-modified">611         double radixDouble = radixValue.toInteger(globalObject);</span>
612         RETURN_IF_EXCEPTION(throwScope, 0);
613         if (radixDouble &gt;= 2 &amp;&amp; radixDouble &lt;= 36)
614             return static_cast&lt;int32_t&gt;(radixDouble);
615     }
616 
<span class="line-modified">617     throwRangeError(globalObject, throwScope, &quot;toString() radix argument must be between 2 and 36&quot;_s);</span>
618     return 0;
619 }
620 
621 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="NumberObject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="NumberPrototype.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
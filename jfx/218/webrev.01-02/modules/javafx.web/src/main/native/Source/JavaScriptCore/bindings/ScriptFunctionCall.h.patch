diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bindings/ScriptFunctionCall.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bindings/ScriptFunctionCall.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bindings/ScriptFunctionCall.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bindings/ScriptFunctionCall.h
@@ -30,22 +30,24 @@
  */
 
 #pragma once
 
 #include "ArgList.h"
+#include "Exception.h"
 #include "ScriptObject.h"
+#include <wtf/Expected.h>
 #include <wtf/text/WTFString.h>
 
 namespace JSC {
 class JSValue;
 }
 
 namespace Deprecated {
 
 class JS_EXPORT_PRIVATE ScriptCallArgumentHandler {
 public:
-    ScriptCallArgumentHandler(JSC::ExecState* state) : m_exec(state) { }
+    ScriptCallArgumentHandler(JSC::JSGlobalObject* globalObject) : m_globalObject(globalObject) { }
 
     void appendArgument(const char*);
     void appendArgument(const String&);
     void appendArgument(JSC::JSValue);
     void appendArgument(long);
@@ -55,25 +57,24 @@
     void appendArgument(int);
     void appendArgument(bool);
 
 protected:
     JSC::MarkedArgumentBuffer m_arguments;
-    JSC::ExecState* m_exec;
+    JSC::JSGlobalObject* m_globalObject;
 
 private:
     // MarkedArgumentBuffer must be stack allocated, so prevent heap
     // alloc of ScriptFunctionCall as well.
     void* operator new(size_t) { ASSERT_NOT_REACHED(); return reinterpret_cast<void*>(0xbadbeef); }
     void* operator new[](size_t) { ASSERT_NOT_REACHED(); return reinterpret_cast<void*>(0xbadbeef); }
 };
 
 class JS_EXPORT_PRIVATE ScriptFunctionCall : public ScriptCallArgumentHandler {
 public:
-    typedef JSC::JSValue (*ScriptFunctionCallHandler)(JSC::ExecState* exec, JSC::JSValue functionObject, JSC::CallType callType, const JSC::CallData& callData, JSC::JSValue thisValue, const JSC::ArgList& args, NakedPtr<JSC::Exception>&);
+    typedef JSC::JSValue (*ScriptFunctionCallHandler)(JSC::JSGlobalObject* globalObject, JSC::JSValue functionObject, JSC::CallType callType, const JSC::CallData& callData, JSC::JSValue thisValue, const JSC::ArgList& args, NakedPtr<JSC::Exception>&);
     ScriptFunctionCall(const ScriptObject& thisObject, const String& name, ScriptFunctionCallHandler handler = nullptr);
-    JSC::JSValue call(bool& hadException);
-    JSC::JSValue call();
+    Expected<JSC::JSValue, NakedPtr<JSC::Exception>> call();
 
 protected:
     ScriptFunctionCallHandler m_callHandler;
     ScriptObject m_thisObject;
     String m_name;

diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperPlatformLayerBuffer.h b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperPlatformLayerBuffer.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperPlatformLayerBuffer.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperPlatformLayerBuffer.h
@@ -29,21 +29,40 @@
 
 #include "BitmapTextureGL.h"
 #include "TextureMapperGLHeaders.h"
 #include "TextureMapperPlatformLayer.h"
 #include <wtf/MonotonicTime.h>
+#include <wtf/Variant.h>
 
 namespace WebCore {
 
 class TextureMapperPlatformLayerBuffer : public TextureMapperPlatformLayer {
     WTF_MAKE_NONCOPYABLE(TextureMapperPlatformLayerBuffer);
     WTF_MAKE_FAST_ALLOCATED();
 public:
     TextureMapperPlatformLayerBuffer(RefPtr<BitmapTexture>&&, TextureMapperGL::Flags = 0);
+
     TextureMapperPlatformLayerBuffer(GLuint textureID, const IntSize&, TextureMapperGL::Flags, GLint internalFormat);
 
-    virtual ~TextureMapperPlatformLayerBuffer() = default;
+    struct RGBTexture {
+        GLuint id;
+    };
+    struct YUVTexture {
+        unsigned numberOfPlanes;
+        std::array<GLuint, 3> planes;
+        std::array<unsigned, 3> yuvPlane;
+        std::array<unsigned, 3> yuvPlaneOffset;
+        std::array<GLfloat, 9> yuvToRgbMatrix;
+    };
+    struct ExternalOESTexture {
+        GLuint id;
+    };
+    using TextureVariant = WTF::Variant<RGBTexture, YUVTexture, ExternalOESTexture>;
+
+    TextureMapperPlatformLayerBuffer(TextureVariant&&, const IntSize&, TextureMapperGL::Flags, GLint internalFormat);
+
+    virtual ~TextureMapperPlatformLayerBuffer();
 
     void paintToTextureMapper(TextureMapper&, const FloatRect&, const TransformationMatrix& modelViewMatrix = TransformationMatrix(), float opacity = 1.0) final;
 
     bool canReuseWithoutReset(const IntSize&, GLint internalFormat);
     BitmapTextureGL& textureGL() { return static_cast<BitmapTextureGL&>(*m_texture); }
@@ -55,10 +74,14 @@
         WTF_MAKE_NONCOPYABLE(UnmanagedBufferDataHolder);
         WTF_MAKE_FAST_ALLOCATED();
     public:
         UnmanagedBufferDataHolder() = default;
         virtual ~UnmanagedBufferDataHolder() = default;
+
+#if USE(GSTREAMER_GL)
+        virtual void waitForCPUSync() = 0;
+#endif // USE(GSTREAMER_GL)
     };
 
     bool hasManagedTexture() const { return m_hasManagedTexture; }
     void setUnmanagedBufferDataHolder(std::unique_ptr<UnmanagedBufferDataHolder> holder) { m_unmanagedBufferDataHolder = WTFMove(holder); }
     void setExtraFlags(TextureMapperGL::Flags flags) { m_extraFlags = flags; }
@@ -72,16 +95,18 @@
         virtual void setVideoRectangle(const IntRect&) = 0;
     };
 
     void setHolePunchClient(std::unique_ptr<HolePunchClient>&& client) { m_holePunchClient = WTFMove(client); }
 
+    const TextureVariant& textureVariant() { return m_variant; }
+
 private:
 
     RefPtr<BitmapTexture> m_texture;
     MonotonicTime m_timeLastUsed;
 
-    GLuint m_textureID;
+    TextureVariant m_variant;
     IntSize m_size;
     GLint m_internalFormat;
     TextureMapperGL::Flags m_extraFlags;
     bool m_hasManagedTexture;
     std::unique_ptr<UnmanagedBufferDataHolder> m_unmanagedBufferDataHolder;

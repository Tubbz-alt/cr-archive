<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2009-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ArrayBuffer.h&quot;
 28 
<a name="1" id="anc1"></a>
 29 #include &quot;JSArrayBufferView.h&quot;
 30 #include &quot;JSCInlines.h&quot;
 31 #include &lt;wtf/Gigacage.h&gt;
 32 
 33 namespace JSC {
 34 
<a name="2" id="anc2"></a><span class="line-added"> 35 Ref&lt;SharedTask&lt;void(void*)&gt;&gt; ArrayBuffer::primitiveGigacageDestructor()</span>
<span class="line-added"> 36 {</span>
<span class="line-added"> 37     static LazyNeverDestroyed&lt;Ref&lt;SharedTask&lt;void(void*)&gt;&gt;&gt; destructor;</span>
<span class="line-added"> 38     static std::once_flag onceKey;</span>
<span class="line-added"> 39     std::call_once(onceKey, [&amp;] {</span>
<span class="line-added"> 40         destructor.construct(createSharedTask&lt;void(void*)&gt;([] (void* p) { Gigacage::free(Gigacage::Primitive, p); }));</span>
<span class="line-added"> 41     });</span>
<span class="line-added"> 42     return destructor.get().copyRef();</span>
<span class="line-added"> 43 }</span>
<span class="line-added"> 44 </span>
 45 SharedArrayBufferContents::SharedArrayBufferContents(void* data, unsigned size, ArrayBufferDestructorFunction&amp;&amp; destructor)
 46     : m_data(data, size)
 47     , m_destructor(WTFMove(destructor))
 48     , m_sizeInBytes(size)
 49 {
 50 }
 51 
 52 SharedArrayBufferContents::~SharedArrayBufferContents()
 53 {
<a name="3" id="anc3"></a><span class="line-modified"> 54     if (m_destructor) {</span>
<span class="line-modified"> 55         // FIXME: we shouldn&#39;t use getUnsafe here https://bugs.webkit.org/show_bug.cgi?id=197698</span>
<span class="line-added"> 56         m_destructor-&gt;run(m_data.getUnsafe());</span>
<span class="line-added"> 57     }</span>
 58 }
 59 
 60 ArrayBufferContents::ArrayBufferContents()
 61 {
 62     reset();
 63 }
 64 
 65 ArrayBufferContents::ArrayBufferContents(ArrayBufferContents&amp;&amp; other)
 66 {
 67     reset();
 68     other.transferTo(*this);
 69 }
 70 
 71 ArrayBufferContents::ArrayBufferContents(void* data, unsigned sizeInBytes, ArrayBufferDestructorFunction&amp;&amp; destructor)
 72     : m_data(data, sizeInBytes)
 73     , m_sizeInBytes(sizeInBytes)
 74 {
 75     RELEASE_ASSERT(m_sizeInBytes &lt;= MAX_ARRAY_BUFFER_SIZE);
 76     m_destructor = WTFMove(destructor);
 77 }
 78 
 79 ArrayBufferContents&amp; ArrayBufferContents::operator=(ArrayBufferContents&amp;&amp; other)
 80 {
 81     other.transferTo(*this);
 82     return *this;
 83 }
 84 
 85 ArrayBufferContents::~ArrayBufferContents()
 86 {
 87     destroy();
 88 }
 89 
 90 void ArrayBufferContents::clear()
 91 {
 92     destroy();
 93     reset();
 94 }
 95 
 96 void ArrayBufferContents::destroy()
 97 {
<a name="4" id="anc4"></a><span class="line-modified"> 98     if (m_destructor) {</span>
<span class="line-modified"> 99         // FIXME: We shouldn&#39;t use getUnsafe here: https://bugs.webkit.org/show_bug.cgi?id=197698</span>
<span class="line-added">100         m_destructor-&gt;run(m_data.getUnsafe());</span>
<span class="line-added">101     }</span>
102 }
103 
104 void ArrayBufferContents::reset()
105 {
<a name="5" id="anc5"></a>

106     m_data = nullptr;
<a name="6" id="anc6"></a><span class="line-added">107     m_destructor = nullptr;</span>
<span class="line-added">108     m_shared = nullptr;</span>
109     m_sizeInBytes = 0;
110 }
111 
112 void ArrayBufferContents::tryAllocate(unsigned numElements, unsigned elementByteSize, InitializationPolicy policy)
113 {
114     // Do not allow 31-bit overflow of the total size.
115     if (numElements) {
116         unsigned totalSize = numElements * elementByteSize;
117         if (totalSize / numElements != elementByteSize || totalSize &gt; MAX_ARRAY_BUFFER_SIZE) {
118             reset();
119             return;
120         }
121     }
122     size_t sizeInBytes = static_cast&lt;size_t&gt;(numElements) * static_cast&lt;size_t&gt;(elementByteSize);
123     size_t allocationSize = sizeInBytes;
124     if (!allocationSize)
125         allocationSize = 1; // Make sure malloc actually allocates something, but not too much. We use null to mean that the buffer is neutered.
126 
127     void* data = Gigacage::tryMalloc(Gigacage::Primitive, allocationSize);
128     m_data = DataType(data, sizeInBytes);
129     if (!data) {
130         reset();
131         return;
132     }
133 
134     if (policy == ZeroInitialize)
135         memset(data, 0, allocationSize);
136 
137     m_sizeInBytes = sizeInBytes;
138     RELEASE_ASSERT(m_sizeInBytes &lt;= MAX_ARRAY_BUFFER_SIZE);
<a name="7" id="anc7"></a><span class="line-modified">139     m_destructor = ArrayBuffer::primitiveGigacageDestructor();</span>
140 }
141 
142 void ArrayBufferContents::makeShared()
143 {
144     m_shared = adoptRef(new SharedArrayBufferContents(data(), sizeInBytes(), WTFMove(m_destructor)));
<a name="8" id="anc8"></a><span class="line-modified">145     m_destructor = nullptr;</span>
146 }
147 
148 void ArrayBufferContents::transferTo(ArrayBufferContents&amp; other)
149 {
150     other.clear();
151     other.m_data = m_data;
152     other.m_sizeInBytes = m_sizeInBytes;
153     RELEASE_ASSERT(other.m_sizeInBytes &lt;= MAX_ARRAY_BUFFER_SIZE);
154     other.m_destructor = WTFMove(m_destructor);
155     other.m_shared = m_shared;
156     reset();
157 }
158 
159 void ArrayBufferContents::copyTo(ArrayBufferContents&amp; other)
160 {
161     ASSERT(!other.m_data);
162     other.tryAllocate(m_sizeInBytes, sizeof(char), ArrayBufferContents::DontInitialize);
163     if (!other.m_data)
164         return;
165     memcpy(other.data(), data(), m_sizeInBytes);
166     other.m_sizeInBytes = m_sizeInBytes;
167     RELEASE_ASSERT(other.m_sizeInBytes &lt;= MAX_ARRAY_BUFFER_SIZE);
168 }
169 
170 void ArrayBufferContents::shareWith(ArrayBufferContents&amp; other)
171 {
172     ASSERT(!other.m_data);
173     ASSERT(m_shared);
<a name="9" id="anc9"></a>

174     other.m_data = m_data;
<a name="10" id="anc10"></a><span class="line-added">175     other.m_destructor = nullptr;</span>
<span class="line-added">176     other.m_shared = m_shared;</span>
177     other.m_sizeInBytes = m_sizeInBytes;
178     RELEASE_ASSERT(other.m_sizeInBytes &lt;= MAX_ARRAY_BUFFER_SIZE);
179 }
180 
181 Ref&lt;ArrayBuffer&gt; ArrayBuffer::create(unsigned numElements, unsigned elementByteSize)
182 {
183     auto buffer = tryCreate(numElements, elementByteSize);
184     if (!buffer)
185         CRASH();
186     return buffer.releaseNonNull();
187 }
188 
189 Ref&lt;ArrayBuffer&gt; ArrayBuffer::create(ArrayBuffer&amp; other)
190 {
191     return ArrayBuffer::create(other.data(), other.byteLength());
192 }
193 
194 Ref&lt;ArrayBuffer&gt; ArrayBuffer::create(const void* source, unsigned byteLength)
195 {
196     auto buffer = tryCreate(source, byteLength);
197     if (!buffer)
198         CRASH();
199     return buffer.releaseNonNull();
200 }
201 
202 Ref&lt;ArrayBuffer&gt; ArrayBuffer::create(ArrayBufferContents&amp;&amp; contents)
203 {
204     return adoptRef(*new ArrayBuffer(WTFMove(contents)));
205 }
206 
207 // FIXME: We cannot use this except if the memory comes from the cage.
208 // Current this is only used from:
209 // - JSGenericTypedArrayView&lt;&gt;::slowDownAndWasteMemory. But in that case, the memory should have already come
210 //   from the cage.
211 Ref&lt;ArrayBuffer&gt; ArrayBuffer::createAdopted(const void* data, unsigned byteLength)
212 {
<a name="11" id="anc11"></a><span class="line-modified">213     return createFromBytes(data, byteLength, ArrayBuffer::primitiveGigacageDestructor());</span>
214 }
215 
216 // FIXME: We cannot use this except if the memory comes from the cage.
217 // Currently this is only used from:
218 // - The C API. We could support that by either having the system switch to a mode where typed arrays are no
219 //   longer caged, or we could introduce a new set of typed array types that are uncaged and get accessed
220 //   differently.
221 // - WebAssembly. Wasm should allocate from the cage.
222 Ref&lt;ArrayBuffer&gt; ArrayBuffer::createFromBytes(const void* data, unsigned byteLength, ArrayBufferDestructorFunction&amp;&amp; destructor)
223 {
224     if (data &amp;&amp; !Gigacage::isCaged(Gigacage::Primitive, data))
225         Gigacage::disablePrimitiveGigacage();
226 
227     ArrayBufferContents contents(const_cast&lt;void*&gt;(data), byteLength, WTFMove(destructor));
228     return create(WTFMove(contents));
229 }
230 
231 RefPtr&lt;ArrayBuffer&gt; ArrayBuffer::tryCreate(unsigned numElements, unsigned elementByteSize)
232 {
233     return tryCreate(numElements, elementByteSize, ArrayBufferContents::ZeroInitialize);
234 }
235 
236 RefPtr&lt;ArrayBuffer&gt; ArrayBuffer::tryCreate(ArrayBuffer&amp; other)
237 {
238     return tryCreate(other.data(), other.byteLength());
239 }
240 
241 RefPtr&lt;ArrayBuffer&gt; ArrayBuffer::tryCreate(const void* source, unsigned byteLength)
242 {
243     ArrayBufferContents contents;
244     contents.tryAllocate(byteLength, 1, ArrayBufferContents::DontInitialize);
245     if (!contents.m_data)
246         return nullptr;
247     return createInternal(WTFMove(contents), source, byteLength);
248 }
249 
250 Ref&lt;ArrayBuffer&gt; ArrayBuffer::createUninitialized(unsigned numElements, unsigned elementByteSize)
251 {
252     return create(numElements, elementByteSize, ArrayBufferContents::DontInitialize);
253 }
254 
255 RefPtr&lt;ArrayBuffer&gt; ArrayBuffer::tryCreateUninitialized(unsigned numElements, unsigned elementByteSize)
256 {
257     return tryCreate(numElements, elementByteSize, ArrayBufferContents::DontInitialize);
258 }
259 
260 Ref&lt;ArrayBuffer&gt; ArrayBuffer::create(unsigned numElements, unsigned elementByteSize, ArrayBufferContents::InitializationPolicy policy)
261 {
262     auto buffer = tryCreate(numElements, elementByteSize, policy);
263     if (!buffer)
264         CRASH();
265     return buffer.releaseNonNull();
266 }
267 
268 Ref&lt;ArrayBuffer&gt; ArrayBuffer::createInternal(ArrayBufferContents&amp;&amp; contents, const void* source, unsigned byteLength)
269 {
270     ASSERT(!byteLength || source);
271     auto buffer = adoptRef(*new ArrayBuffer(WTFMove(contents)));
272     memcpy(buffer-&gt;data(), source, byteLength);
273     return buffer;
274 }
275 
276 RefPtr&lt;ArrayBuffer&gt; ArrayBuffer::tryCreate(unsigned numElements, unsigned elementByteSize, ArrayBufferContents::InitializationPolicy policy)
277 {
278     ArrayBufferContents contents;
279     contents.tryAllocate(numElements, elementByteSize, policy);
280     if (!contents.m_data)
281         return nullptr;
282     return adoptRef(*new ArrayBuffer(WTFMove(contents)));
283 }
284 
285 ArrayBuffer::ArrayBuffer(ArrayBufferContents&amp;&amp; contents)
286     : m_contents(WTFMove(contents))
287     , m_pinCount(0)
288     , m_isWasmMemory(false)
289     , m_locked(false)
290 {
291 }
292 
293 unsigned ArrayBuffer::clampValue(double x, unsigned left, unsigned right)
294 {
295     ASSERT(left &lt;= right);
296     if (x &lt; left)
297         x = left;
298     if (right &lt; x)
299         x = right;
300     return x;
301 }
302 
303 unsigned ArrayBuffer::clampIndex(double index) const
304 {
305     unsigned currentLength = byteLength();
306     if (index &lt; 0)
307         index = currentLength + index;
308     return clampValue(index, 0, currentLength);
309 }
310 
<a name="12" id="anc12"></a><span class="line-modified">311 RefPtr&lt;ArrayBuffer&gt; ArrayBuffer::slice(double begin, double end) const</span>
312 {
313     return sliceImpl(clampIndex(begin), clampIndex(end));
314 }
315 
<a name="13" id="anc13"></a><span class="line-modified">316 RefPtr&lt;ArrayBuffer&gt; ArrayBuffer::slice(double begin) const</span>
317 {
318     return sliceImpl(clampIndex(begin), byteLength());
319 }
320 
<a name="14" id="anc14"></a><span class="line-modified">321 RefPtr&lt;ArrayBuffer&gt; ArrayBuffer::sliceImpl(unsigned begin, unsigned end) const</span>
322 {
323     unsigned size = begin &lt;= end ? end - begin : 0;
<a name="15" id="anc15"></a><span class="line-modified">324     auto result = ArrayBuffer::tryCreate(static_cast&lt;const char*&gt;(data()) + begin, size);</span>
<span class="line-modified">325     if (result)</span>
<span class="line-added">326         result-&gt;setSharingMode(sharingMode());</span>
327     return result;
328 }
329 
330 void ArrayBuffer::makeShared()
331 {
332     m_contents.makeShared();
333     m_locked = true;
334 }
335 
336 void ArrayBuffer::makeWasmMemory()
337 {
338     m_locked = true;
339     m_isWasmMemory = true;
340 }
341 
342 void ArrayBuffer::setSharingMode(ArrayBufferSharingMode newSharingMode)
343 {
344     if (newSharingMode == sharingMode())
345         return;
346     RELEASE_ASSERT(!isShared()); // Cannot revert sharing.
347     RELEASE_ASSERT(newSharingMode == ArrayBufferSharingMode::Shared);
348     makeShared();
349 }
350 
351 bool ArrayBuffer::shareWith(ArrayBufferContents&amp; result)
352 {
353     if (!m_contents.m_data || !isShared()) {
354         result.m_data = nullptr;
355         return false;
356     }
357 
358     m_contents.shareWith(result);
359     return true;
360 }
361 
362 bool ArrayBuffer::transferTo(VM&amp; vm, ArrayBufferContents&amp; result)
363 {
364     Ref&lt;ArrayBuffer&gt; protect(*this);
365 
366     if (!m_contents.m_data) {
367         result.m_data = nullptr;
368         return false;
369     }
370 
371     if (isShared()) {
372         m_contents.shareWith(result);
373         return true;
374     }
375 
376     bool isNeuterable = !m_pinCount &amp;&amp; !m_locked;
377 
378     if (!isNeuterable) {
379         m_contents.copyTo(result);
380         if (!result.m_data)
381             return false;
382         return true;
383     }
384 
385     m_contents.transferTo(result);
<a name="16" id="anc16"></a><span class="line-modified">386     notifyNeutering(vm);</span>
387     return true;
388 }
389 
390 // We allow neutering wasm memory ArrayBuffers even though they are locked.
391 void ArrayBuffer::neuter(VM&amp; vm)
392 {
393     ASSERT(isWasmMemory());
394     ArrayBufferContents unused;
395     m_contents.transferTo(unused);
<a name="17" id="anc17"></a><span class="line-modified">396     notifyNeutering(vm);</span>
397 }
398 
<a name="18" id="anc18"></a><span class="line-modified">399 void ArrayBuffer::notifyNeutering(VM&amp; vm)</span>
400 {
401     for (size_t i = numberOfIncomingReferences(); i--;) {
402         JSCell* cell = incomingReferenceAt(i);
403         if (JSArrayBufferView* view = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, cell))
404             view-&gt;neuter();
<a name="19" id="anc19"></a>

405     }
<a name="20" id="anc20"></a><span class="line-added">406     m_neuteringWatchpointSet.fireAll(vm, &quot;Array buffer was neutered&quot;);</span>
407 }
408 
409 ASCIILiteral errorMesasgeForTransfer(ArrayBuffer* buffer)
410 {
411     ASSERT(buffer-&gt;isLocked());
412     if (buffer-&gt;isShared())
413         return &quot;Cannot transfer a SharedArrayBuffer&quot;_s;
414     if (buffer-&gt;isWasmMemory())
415         return &quot;Cannot transfer a WebAssembly.Memory&quot;_s;
416     return &quot;Cannot transfer an ArrayBuffer whose backing store has been accessed by the JavaScriptCore C API&quot;_s;
417 }
418 
419 } // namespace JSC
420 
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
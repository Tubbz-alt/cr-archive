<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/style/StyleScope.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
  5  *           (C) 2006 Alexey Proskuryakov (ap@webkit.org)
  6  * Copyright (C) 2004-2010, 2012-2013, 2015-2017 Apple Inc. All rights reserved.
  7  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  8  * Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies)
  9  * Copyright (C) 2011 Google Inc. All rights reserved.
 10  *
 11  * This library is free software; you can redistribute it and/or
 12  * modify it under the terms of the GNU Library General Public
 13  * License as published by the Free Software Foundation; either
 14  * version 2 of the License, or (at your option) any later version.
 15  *
 16  * This library is distributed in the hope that it will be useful,
 17  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 18  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 19  * Library General Public License for more details.
 20  *
 21  * You should have received a copy of the GNU Library General Public License
 22  * along with this library; see the file COPYING.LIB.  If not, write to
 23  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 24  * Boston, MA 02110-1301, USA.
 25  *
 26  */
 27 
 28 #pragma once
 29 
 30 #include &quot;Timer.h&quot;
 31 #include &lt;memory&gt;
 32 #include &lt;wtf/FastMalloc.h&gt;
 33 #include &lt;wtf/HashSet.h&gt;
 34 #include &lt;wtf/ListHashSet.h&gt;
 35 #include &lt;wtf/RefPtr.h&gt;
 36 #include &lt;wtf/Vector.h&gt;
 37 #include &lt;wtf/text/WTFString.h&gt;
 38 
 39 namespace WebCore {
 40 
 41 class CSSStyleSheet;
 42 class Document;
 43 class Element;
 44 class Node;
 45 class ProcessingInstruction;
 46 class StyleSheet;
 47 class StyleSheetContents;
 48 class StyleSheetList;
 49 class ShadowRoot;
 50 class TreeScope;
 51 
 52 namespace Style {
 53 
 54 class Resolver;
 55 
 56 // This is used to identify style scopes that can affect an element.
 57 // Scopes are in tree-of-trees order. Styles from earlier scopes win over later ones (modulo !important).
 58 enum class ScopeOrdinal : int {
 59     ContainingHost = -1, // ::part rules and author-exposed UA pseudo classes from the host tree scope.
 60     Element = 0, // Normal rules in the same tree where the element is.
 61     FirstSlot = 1, // ::slotted rules in the parent&#39;s shadow tree. Values greater than FirstSlot indicate subsequent slots in the chain.
 62     Shadow = std::numeric_limits&lt;int&gt;::max(), // :host rules in element&#39;s own shadow tree.
 63 };
 64 
 65 class Scope {
 66     WTF_MAKE_FAST_ALLOCATED;
 67 public:
 68     explicit Scope(Document&amp;);
 69     explicit Scope(ShadowRoot&amp;);
 70 
 71     ~Scope();
 72 
 73     const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; activeStyleSheets() const { return m_activeStyleSheets; }
 74 
 75     const Vector&lt;RefPtr&lt;StyleSheet&gt;&gt;&amp; styleSheetsForStyleSheetList();
 76     const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt; activeStyleSheetsForInspector();
 77 
 78     void addStyleSheetCandidateNode(Node&amp;, bool createdByParser);
 79     void removeStyleSheetCandidateNode(Node&amp;);
 80 
 81     String preferredStylesheetSetName() const { return m_preferredStylesheetSetName; }
 82     void setPreferredStylesheetSetName(const String&amp;);
 83 
 84     void addPendingSheet(const Element&amp;);
 85     void removePendingSheet(const Element&amp;);
 86     void addPendingSheet(const ProcessingInstruction&amp;);
 87     void removePendingSheet(const ProcessingInstruction&amp;);
 88     bool hasPendingSheets() const;
 89     bool hasPendingSheetsBeforeBody() const;
 90     bool hasPendingSheetsInBody() const;
 91     bool hasPendingSheet(const Element&amp;) const;
 92     bool hasPendingSheetInBody(const Element&amp;) const;
 93     bool hasPendingSheet(const ProcessingInstruction&amp;) const;
 94 
 95     bool usesStyleBasedEditability() { return m_usesStyleBasedEditability; }
 96 
 97     bool activeStyleSheetsContains(const CSSStyleSheet*) const;
 98 
 99     void evaluateMediaQueriesForViewportChange();
100     void evaluateMediaQueriesForAccessibilitySettingsChange();
101     void evaluateMediaQueriesForAppearanceChange();
102 
103     // This is called when some stylesheet becomes newly enabled or disabled.
104     void didChangeActiveStyleSheetCandidates();
105     // This is called when contents of a stylesheet is mutated.
106     void didChangeStyleSheetContents();
107     // This is called when the environment where we intrepret the stylesheets changes (for example switching to printing).
108     // The change is assumed to potentially affect all author and user stylesheets including shadow roots.
109     WEBCORE_EXPORT void didChangeStyleSheetEnvironment();
110 
111     void invalidateMatchedDeclarationsCache();
112 
113     bool hasPendingUpdate() const { return m_pendingUpdate || m_hasDescendantWithPendingUpdate; }
114     void flushPendingUpdate();
115 
116 #if ENABLE(XSLT)
117     Vector&lt;Ref&lt;ProcessingInstruction&gt;&gt; collectXSLTransforms();
118 #endif
119 
120     WEBCORE_EXPORT Resolver&amp; resolver();
121     Resolver* resolverIfExists();
122     void clearResolver();
123     void releaseMemory();
124 
125     const Document&amp; document() const { return m_document; }
126     Document&amp; document() { return m_document; }
127     const ShadowRoot* shadowRoot() const { return m_shadowRoot; }
128     ShadowRoot* shadowRoot() { return m_shadowRoot; }
129 
130     static Scope&amp; forNode(Node&amp;);
131     static Scope* forOrdinal(Element&amp;, ScopeOrdinal);
132 
133 private:
134     bool shouldUseSharedUserAgentShadowTreeStyleResolver() const;
135 
136     void didRemovePendingStylesheet();
137 
138     enum class UpdateType { ActiveSet, ContentsOrInterpretation };
139     void updateActiveStyleSheets(UpdateType);
140     void scheduleUpdate(UpdateType);
141 
142     template &lt;typename TestFunction&gt; void evaluateMediaQueries(TestFunction&amp;&amp;);
143 
144     WEBCORE_EXPORT void flushPendingSelfUpdate();
145     WEBCORE_EXPORT void flushPendingDescendantUpdates();
146 
147     void collectActiveStyleSheets(Vector&lt;RefPtr&lt;StyleSheet&gt;&gt;&amp;);
148 
149     enum class ResolverUpdateType {
150         Reconstruct,
151         Reset,
152         Additive
153     };
154     struct StyleSheetChange {
155         ResolverUpdateType resolverUpdateType;
156         Vector&lt;StyleSheetContents*&gt; addedSheets { };
157     };
158     StyleSheetChange analyzeStyleSheetChange(const Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp; newStylesheets);
159     void invalidateStyleAfterStyleSheetChange(const StyleSheetChange&amp;);
160 
161     void updateResolver(Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt;&amp;, ResolverUpdateType);
162 
163     void pendingUpdateTimerFired();
164     void clearPendingUpdate();
165 
166     Document&amp; m_document;
167     ShadowRoot* m_shadowRoot { nullptr };
168 
169     std::unique_ptr&lt;Resolver&gt; m_resolver;
170 
171     Vector&lt;RefPtr&lt;StyleSheet&gt;&gt; m_styleSheetsForStyleSheetList;
172     Vector&lt;RefPtr&lt;CSSStyleSheet&gt;&gt; m_activeStyleSheets;
173 
174     Timer m_pendingUpdateTimer;
175 
176     mutable std::unique_ptr&lt;HashSet&lt;const CSSStyleSheet*&gt;&gt; m_weakCopyOfActiveStyleSheetListForFastLookup;
177 
178     // Track the currently loading top-level stylesheets needed for rendering.
179     // Sheets loaded using the @import directive are not included in this count.
180     // We use this count of pending sheets to detect when we can begin attaching
181     // elements and when it is safe to execute scripts.
182     HashSet&lt;const ProcessingInstruction*&gt; m_processingInstructionsWithPendingSheets;
183     HashSet&lt;const Element*&gt; m_elementsInHeadWithPendingSheets;
184     HashSet&lt;const Element*&gt; m_elementsInBodyWithPendingSheets;
185 
186     Optional&lt;UpdateType&gt; m_pendingUpdate;
187     bool m_hasDescendantWithPendingUpdate { false };
188 
189     ListHashSet&lt;Node*&gt; m_styleSheetCandidateNodes;
190 
191     String m_preferredStylesheetSetName;
192 
193     bool m_usesStyleBasedEditability { false };
194     bool m_isUpdatingStyleResolver { false };
195 };
196 
197 inline bool Scope::hasPendingSheets() const
198 {
199     return hasPendingSheetsBeforeBody() || !m_elementsInBodyWithPendingSheets.isEmpty();
200 }
201 
202 inline bool Scope::hasPendingSheetsBeforeBody() const
203 {
204     return !m_elementsInHeadWithPendingSheets.isEmpty() || !m_processingInstructionsWithPendingSheets.isEmpty();
205 }
206 
207 inline bool Scope::hasPendingSheetsInBody() const
208 {
209     return !m_elementsInBodyWithPendingSheets.isEmpty();
210 }
211 
212 inline void Scope::flushPendingUpdate()
213 {
214     if (m_hasDescendantWithPendingUpdate)
215         flushPendingDescendantUpdates();
216     if (m_pendingUpdate)
217         flushPendingSelfUpdate();
218 }
219 
220 inline ScopeOrdinal&amp; operator++(ScopeOrdinal&amp; ordinal)
221 {
222     ASSERT(ordinal &lt; ScopeOrdinal::Shadow);
223     return ordinal = static_cast&lt;ScopeOrdinal&gt;(static_cast&lt;int&gt;(ordinal) + 1);
224 }
225 
226 }
227 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTreeAsText.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderTreeAsText.h&quot;
 28 
 29 #include &quot;ClipRect.h&quot;
 30 #include &quot;Document.h&quot;
 31 #include &quot;Frame.h&quot;
 32 #include &quot;FrameSelection.h&quot;
 33 #include &quot;FrameView.h&quot;
 34 #include &quot;HTMLElement.h&quot;
 35 #include &quot;HTMLNames.h&quot;
 36 #include &quot;HTMLSpanElement.h&quot;
 37 #include &quot;InlineTextBox.h&quot;
<a name="1" id="anc1"></a><span class="line-modified"> 38 #include &quot;LineLayoutTraversal.h&quot;</span>
 39 #include &quot;Logging.h&quot;
 40 #include &quot;PrintContext.h&quot;
 41 #include &quot;PseudoElement.h&quot;
 42 #include &quot;RenderBlockFlow.h&quot;
 43 #include &quot;RenderCounter.h&quot;
 44 #include &quot;RenderDetailsMarker.h&quot;
 45 #include &quot;RenderFileUploadControl.h&quot;
 46 #include &quot;RenderFragmentContainer.h&quot;
 47 #include &quot;RenderInline.h&quot;
 48 #include &quot;RenderIterator.h&quot;
 49 #include &quot;RenderLayer.h&quot;
 50 #include &quot;RenderLayerBacking.h&quot;
 51 #include &quot;RenderLineBreak.h&quot;
 52 #include &quot;RenderListItem.h&quot;
 53 #include &quot;RenderListMarker.h&quot;
 54 #include &quot;RenderSVGContainer.h&quot;
 55 #include &quot;RenderSVGGradientStop.h&quot;
 56 #include &quot;RenderSVGImage.h&quot;
 57 #include &quot;RenderSVGInlineText.h&quot;
 58 #include &quot;RenderSVGPath.h&quot;
 59 #include &quot;RenderSVGResourceContainer.h&quot;
 60 #include &quot;RenderSVGRoot.h&quot;
 61 #include &quot;RenderSVGText.h&quot;
 62 #include &quot;RenderTableCell.h&quot;
 63 #include &quot;RenderView.h&quot;
 64 #include &quot;RenderWidget.h&quot;
 65 #include &quot;SVGRenderTreeAsText.h&quot;
 66 #include &quot;ShadowRoot.h&quot;
 67 #include &quot;StyleProperties.h&quot;
 68 #include &lt;wtf/HexNumber.h&gt;
 69 #include &lt;wtf/Vector.h&gt;
 70 #include &lt;wtf/text/TextStream.h&gt;
 71 #include &lt;wtf/unicode/CharacterNames.h&gt;
 72 
 73 #if PLATFORM(MAC)
 74 #include &quot;ScrollbarThemeMac.h&quot;
 75 #endif
 76 
 77 namespace WebCore {
 78 
 79 using namespace HTMLNames;
 80 
 81 static void writeLayers(TextStream&amp;, const RenderLayer&amp; rootLayer, RenderLayer&amp;, const LayoutRect&amp; paintDirtyRect, OptionSet&lt;RenderAsTextFlag&gt;);
 82 
 83 static void printBorderStyle(TextStream&amp; ts, const BorderStyle borderStyle)
 84 {
 85     switch (borderStyle) {
 86     case BorderStyle::None:
 87         ts &lt;&lt; &quot;none&quot;;
 88         break;
 89     case BorderStyle::Hidden:
 90         ts &lt;&lt; &quot;hidden&quot;;
 91         break;
 92     case BorderStyle::Inset:
 93         ts &lt;&lt; &quot;inset&quot;;
 94         break;
 95     case BorderStyle::Groove:
 96         ts &lt;&lt; &quot;groove&quot;;
 97         break;
 98     case BorderStyle::Ridge:
 99         ts &lt;&lt; &quot;ridge&quot;;
100         break;
101     case BorderStyle::Outset:
102         ts &lt;&lt; &quot;outset&quot;;
103         break;
104     case BorderStyle::Dotted:
105         ts &lt;&lt; &quot;dotted&quot;;
106         break;
107     case BorderStyle::Dashed:
108         ts &lt;&lt; &quot;dashed&quot;;
109         break;
110     case BorderStyle::Solid:
111         ts &lt;&lt; &quot;solid&quot;;
112         break;
113     case BorderStyle::Double:
114         ts &lt;&lt; &quot;double&quot;;
115         break;
116     }
117 
118     ts &lt;&lt; &quot; &quot;;
119 }
120 
121 static String getTagName(Node* n)
122 {
123     if (n-&gt;isDocumentNode())
124         return &quot;&quot;;
125     if (n-&gt;nodeType() == Node::COMMENT_NODE)
126         return &quot;COMMENT&quot;;
127     return n-&gt;nodeName();
128 }
129 
130 static bool isEmptyOrUnstyledAppleStyleSpan(const Node* node)
131 {
132     if (!is&lt;HTMLSpanElement&gt;(node))
133         return false;
134 
135     const HTMLElement&amp; element = downcast&lt;HTMLSpanElement&gt;(*node);
136     if (element.getAttribute(classAttr) != &quot;Apple-style-span&quot;)
137         return false;
138 
139     if (!node-&gt;hasChildNodes())
140         return true;
141 
142     const StyleProperties* inlineStyleDecl = element.inlineStyle();
143     return (!inlineStyleDecl || inlineStyleDecl-&gt;isEmpty());
144 }
145 
146 String quoteAndEscapeNonPrintables(StringView s)
147 {
148     StringBuilder result;
149     result.append(&#39;&quot;&#39;);
150     for (unsigned i = 0; i != s.length(); ++i) {
151         UChar c = s[i];
152         if (c == &#39;\\&#39;) {
153             result.appendLiteral(&quot;\\\\&quot;);
154         } else if (c == &#39;&quot;&#39;) {
155             result.appendLiteral(&quot;\\\&quot;&quot;);
156         } else if (c == &#39;\n&#39; || c == noBreakSpace)
157             result.append(&#39; &#39;);
158         else {
159             if (c &gt;= 0x20 &amp;&amp; c &lt; 0x7F)
160                 result.append(c);
161             else {
162                 result.appendLiteral(&quot;\\x{&quot;);
<a name="2" id="anc2"></a><span class="line-modified">163                 result.append(hex(c));</span>
164                 result.append(&#39;}&#39;);
165             }
166         }
167     }
168     result.append(&#39;&quot;&#39;);
169     return result.toString();
170 }
171 
172 void RenderTreeAsText::writeRenderObject(TextStream&amp; ts, const RenderObject&amp; o, OptionSet&lt;RenderAsTextFlag&gt; behavior)
173 {
174     ts &lt;&lt; o.renderName();
175 
176     if (behavior.contains(RenderAsTextFlag::ShowAddresses))
177         ts &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;const void*&gt;(&amp;o);
178 
<a name="3" id="anc3"></a><span class="line-modified">179     if (o.style().usedZIndex()) // FIXME: This should use !hasAutoUsedZIndex().</span>
<span class="line-modified">180         ts &lt;&lt; &quot; zI: &quot; &lt;&lt; o.style().usedZIndex();</span>
181 
182     if (o.node()) {
183         String tagName = getTagName(o.node());
184         // FIXME: Temporary hack to make tests pass by simulating the old generated content output.
185         if (o.isPseudoElement() || (o.parent() &amp;&amp; o.parent()-&gt;isPseudoElement()))
186             tagName = emptyAtom();
187         if (!tagName.isEmpty()) {
188             ts &lt;&lt; &quot; {&quot; &lt;&lt; tagName &lt;&lt; &quot;}&quot;;
189             // flag empty or unstyled AppleStyleSpan because we never
190             // want to leave them in the DOM
191             if (isEmptyOrUnstyledAppleStyleSpan(o.node()))
192                 ts &lt;&lt; &quot; *empty or unstyled AppleStyleSpan*&quot;;
193         }
194     }
195 
196     RenderBlock* cb = o.containingBlock();
197     bool adjustForTableCells = cb ? cb-&gt;isTableCell() : false;
198 
199     LayoutRect r;
200     if (is&lt;RenderText&gt;(o)) {
201         // FIXME: Would be better to dump the bounding box x and y rather than the first run&#39;s x and y, but that would involve updating
202         // many test results.
203         const RenderText&amp; text = downcast&lt;RenderText&gt;(o);
204         r = IntRect(text.firstRunLocation(), text.linesBoundingBox().size());
<a name="4" id="anc4"></a><span class="line-modified">205         if (!LineLayoutTraversal::firstTextBoxFor(text))</span>

206             adjustForTableCells = false;
207     } else if (o.isBR()) {
208         const RenderLineBreak&amp; br = downcast&lt;RenderLineBreak&gt;(o);
<a name="5" id="anc5"></a><span class="line-modified">209         IntRect linesBox = br.boundingBoxForRenderTreeDump();</span>
210         r = IntRect(linesBox.x(), linesBox.y(), linesBox.width(), linesBox.height());
211         if (!br.inlineBoxWrapper())
212             adjustForTableCells = false;
213     } else if (is&lt;RenderInline&gt;(o)) {
214         const RenderInline&amp; inlineFlow = downcast&lt;RenderInline&gt;(o);
215         // FIXME: Would be better not to just dump 0, 0 as the x and y here.
216         r = IntRect(0, 0, inlineFlow.linesBoundingBox().width(), inlineFlow.linesBoundingBox().height());
217         adjustForTableCells = false;
218     } else if (is&lt;RenderTableCell&gt;(o)) {
219         // FIXME: Deliberately dump the &quot;inner&quot; box of table cells, since that is what current results reflect.  We&#39;d like
220         // to clean up the results to dump both the outer box and the intrinsic padding so that both bits of information are
221         // captured by the results.
222         const RenderTableCell&amp; cell = downcast&lt;RenderTableCell&gt;(o);
223         r = LayoutRect(cell.x(), cell.y() + cell.intrinsicPaddingBefore(), cell.width(), cell.height() - cell.intrinsicPaddingBefore() - cell.intrinsicPaddingAfter());
224     } else if (is&lt;RenderBox&gt;(o))
225         r = downcast&lt;RenderBox&gt;(o).frameRect();
226 
227     // FIXME: Temporary in order to ensure compatibility with existing layout test results.
228     if (adjustForTableCells)
229         r.move(0_lu, -downcast&lt;RenderTableCell&gt;(*o.containingBlock()).intrinsicPaddingBefore());
230 
231     // FIXME: Convert layout test results to report sub-pixel values, in the meantime using enclosingIntRect
232     // for consistency with old results.
233     ts &lt;&lt; &quot; &quot; &lt;&lt; enclosingIntRect(r);
234 
235     if (!is&lt;RenderText&gt;(o)) {
236         if (is&lt;RenderFileUploadControl&gt;(o))
237             ts &lt;&lt; &quot; &quot; &lt;&lt; quoteAndEscapeNonPrintables(downcast&lt;RenderFileUploadControl&gt;(o).fileTextValue());
238 
239         if (o.parent()) {
240             Color color = o.style().visitedDependentColor(CSSPropertyColor);
241             if (o.parent()-&gt;style().visitedDependentColor(CSSPropertyColor).rgb() != color.rgb())
242                 ts &lt;&lt; &quot; [color=&quot; &lt;&lt; color.nameForRenderTreeAsText() &lt;&lt; &quot;]&quot;;
243 
244             // Do not dump invalid or transparent backgrounds, since that is the default.
245             Color backgroundColor = o.style().visitedDependentColor(CSSPropertyBackgroundColor);
246             if (o.parent()-&gt;style().visitedDependentColor(CSSPropertyBackgroundColor).rgb() != backgroundColor.rgb()
<a name="6" id="anc6"></a><span class="line-modified">247                 &amp;&amp; backgroundColor.rgb() != Color::transparent)</span>
248                 ts &lt;&lt; &quot; [bgcolor=&quot; &lt;&lt; backgroundColor.nameForRenderTreeAsText() &lt;&lt; &quot;]&quot;;
249 
250             Color textFillColor = o.style().visitedDependentColor(CSSPropertyWebkitTextFillColor);
251             if (o.parent()-&gt;style().visitedDependentColor(CSSPropertyWebkitTextFillColor).rgb() != textFillColor.rgb()
<a name="7" id="anc7"></a><span class="line-modified">252                 &amp;&amp; textFillColor.rgb() != color.rgb() &amp;&amp; textFillColor.rgb() != Color::transparent)</span>
253                 ts &lt;&lt; &quot; [textFillColor=&quot; &lt;&lt; textFillColor.nameForRenderTreeAsText() &lt;&lt; &quot;]&quot;;
254 
255             Color textStrokeColor = o.style().visitedDependentColor(CSSPropertyWebkitTextStrokeColor);
256             if (o.parent()-&gt;style().visitedDependentColor(CSSPropertyWebkitTextStrokeColor).rgb() != textStrokeColor.rgb()
<a name="8" id="anc8"></a><span class="line-modified">257                 &amp;&amp; textStrokeColor.rgb() != color.rgb() &amp;&amp; textStrokeColor.rgb() != Color::transparent)</span>
258                 ts &lt;&lt; &quot; [textStrokeColor=&quot; &lt;&lt; textStrokeColor.nameForRenderTreeAsText() &lt;&lt; &quot;]&quot;;
259 
260             if (o.parent()-&gt;style().textStrokeWidth() != o.style().textStrokeWidth() &amp;&amp; o.style().textStrokeWidth() &gt; 0)
261                 ts &lt;&lt; &quot; [textStrokeWidth=&quot; &lt;&lt; o.style().textStrokeWidth() &lt;&lt; &quot;]&quot;;
262         }
263 
264         if (!is&lt;RenderBoxModelObject&gt;(o) || is&lt;RenderLineBreak&gt;(o))
265             return;
266 
267         const RenderBoxModelObject&amp; box = downcast&lt;RenderBoxModelObject&gt;(o);
268         LayoutUnit borderTop = box.borderTop();
269         LayoutUnit borderRight = box.borderRight();
270         LayoutUnit borderBottom = box.borderBottom();
271         LayoutUnit borderLeft = box.borderLeft();
272         if (box.isFieldset()) {
273             const auto&amp; block = downcast&lt;RenderBlock&gt;(box);
274             if (o.style().writingMode() == TopToBottomWritingMode)
275                 borderTop -= block.intrinsicBorderForFieldset();
276             else if (o.style().writingMode() == BottomToTopWritingMode)
277                 borderBottom -= block.intrinsicBorderForFieldset();
278             else if (o.style().writingMode() == LeftToRightWritingMode)
279                 borderLeft -= block.intrinsicBorderForFieldset();
280             else if (o.style().writingMode() == RightToLeftWritingMode)
281                 borderRight -= block.intrinsicBorderForFieldset();
282 
283         }
284         if (borderTop || borderRight || borderBottom || borderLeft) {
285             ts &lt;&lt; &quot; [border:&quot;;
286 
287             BorderValue prevBorder = o.style().borderTop();
288             if (!borderTop)
289                 ts &lt;&lt; &quot; none&quot;;
290             else {
291                 ts &lt;&lt; &quot; (&quot; &lt;&lt; borderTop &lt;&lt; &quot;px &quot;;
292                 printBorderStyle(ts, o.style().borderTopStyle());
293                 Color col = o.style().borderTopColor();
294                 if (!col.isValid())
295                     col = o.style().color();
296                 ts &lt;&lt; col.nameForRenderTreeAsText() &lt;&lt; &quot;)&quot;;
297             }
298 
299             if (o.style().borderRight() != prevBorder) {
300                 prevBorder = o.style().borderRight();
301                 if (!borderRight)
302                     ts &lt;&lt; &quot; none&quot;;
303                 else {
304                     ts &lt;&lt; &quot; (&quot; &lt;&lt; borderRight &lt;&lt; &quot;px &quot;;
305                     printBorderStyle(ts, o.style().borderRightStyle());
306                     Color col = o.style().borderRightColor();
307                     if (!col.isValid())
308                         col = o.style().color();
309                     ts &lt;&lt; col.nameForRenderTreeAsText() &lt;&lt; &quot;)&quot;;
310                 }
311             }
312 
313             if (o.style().borderBottom() != prevBorder) {
314                 prevBorder = box.style().borderBottom();
315                 if (!borderBottom)
316                     ts &lt;&lt; &quot; none&quot;;
317                 else {
318                     ts &lt;&lt; &quot; (&quot; &lt;&lt; borderBottom &lt;&lt; &quot;px &quot;;
319                     printBorderStyle(ts, o.style().borderBottomStyle());
320                     Color col = o.style().borderBottomColor();
321                     if (!col.isValid())
322                         col = o.style().color();
323                     ts &lt;&lt; col.nameForRenderTreeAsText() &lt;&lt; &quot;)&quot;;
324                 }
325             }
326 
327             if (o.style().borderLeft() != prevBorder) {
328                 prevBorder = o.style().borderLeft();
329                 if (!borderLeft)
330                     ts &lt;&lt; &quot; none&quot;;
331                 else {
332                     ts &lt;&lt; &quot; (&quot; &lt;&lt; borderLeft &lt;&lt; &quot;px &quot;;
333                     printBorderStyle(ts, o.style().borderLeftStyle());
334                     Color col = o.style().borderLeftColor();
335                     if (!col.isValid())
336                         col = o.style().color();
337                     ts &lt;&lt; col.nameForRenderTreeAsText() &lt;&lt; &quot;)&quot;;
338                 }
339             }
340 
341             ts &lt;&lt; &quot;]&quot;;
342         }
343 
344 #if ENABLE(MATHML)
345         // We want to show any layout padding, both CSS padding and intrinsic padding, so we can&#39;t just check o.style().hasPadding().
346         if (o.isRenderMathMLBlock() &amp;&amp; (box.paddingTop() || box.paddingRight() || box.paddingBottom() || box.paddingLeft())) {
347             ts &lt;&lt; &quot; [&quot;;
348             LayoutUnit cssTop = box.computedCSSPaddingTop();
349             LayoutUnit cssRight = box.computedCSSPaddingRight();
350             LayoutUnit cssBottom = box.computedCSSPaddingBottom();
351             LayoutUnit cssLeft = box.computedCSSPaddingLeft();
352             if (box.paddingTop() != cssTop || box.paddingRight() != cssRight || box.paddingBottom() != cssBottom || box.paddingLeft() != cssLeft) {
353                 ts &lt;&lt; &quot;intrinsic &quot;;
354                 if (cssTop || cssRight || cssBottom || cssLeft)
355                     ts &lt;&lt; &quot;+ CSS &quot;;
356             }
357             ts &lt;&lt; &quot;padding: &quot; &lt;&lt; roundToInt(box.paddingTop()) &lt;&lt; &quot; &quot; &lt;&lt; roundToInt(box.paddingRight()) &lt;&lt; &quot; &quot; &lt;&lt; roundToInt(box.paddingBottom()) &lt;&lt; &quot; &quot; &lt;&lt; roundToInt(box.paddingLeft()) &lt;&lt; &quot;]&quot;;
358         }
359 #endif
360     }
361 
362     if (is&lt;RenderTableCell&gt;(o)) {
363         const RenderTableCell&amp; c = downcast&lt;RenderTableCell&gt;(o);
364         ts &lt;&lt; &quot; [r=&quot; &lt;&lt; c.rowIndex() &lt;&lt; &quot; c=&quot; &lt;&lt; c.col() &lt;&lt; &quot; rs=&quot; &lt;&lt; c.rowSpan() &lt;&lt; &quot; cs=&quot; &lt;&lt; c.colSpan() &lt;&lt; &quot;]&quot;;
365     }
366 
367     if (is&lt;RenderDetailsMarker&gt;(o)) {
368         ts &lt;&lt; &quot;: &quot;;
369         switch (downcast&lt;RenderDetailsMarker&gt;(o).orientation()) {
370         case RenderDetailsMarker::Left:
371             ts &lt;&lt; &quot;left&quot;;
372             break;
373         case RenderDetailsMarker::Right:
374             ts &lt;&lt; &quot;right&quot;;
375             break;
376         case RenderDetailsMarker::Up:
377             ts &lt;&lt; &quot;up&quot;;
378             break;
379         case RenderDetailsMarker::Down:
380             ts &lt;&lt; &quot;down&quot;;
381             break;
382         }
383     }
384 
385     if (is&lt;RenderListMarker&gt;(o)) {
386         String text = downcast&lt;RenderListMarker&gt;(o).text();
387         if (!text.isEmpty()) {
388             if (text.length() != 1)
389                 text = quoteAndEscapeNonPrintables(text);
390             else {
391                 switch (text[0]) {
392                     case bullet:
393                         text = &quot;bullet&quot;;
394                         break;
395                     case blackSquare:
396                         text = &quot;black square&quot;;
397                         break;
398                     case whiteBullet:
399                         text = &quot;white bullet&quot;;
400                         break;
401                     default:
402                         text = quoteAndEscapeNonPrintables(text);
403                 }
404             }
405             ts &lt;&lt; &quot;: &quot; &lt;&lt; text;
406         }
407     }
408 
409     writeDebugInfo(ts, o, behavior);
410 }
411 
412 void writeDebugInfo(TextStream&amp; ts, const RenderObject&amp; object, OptionSet&lt;RenderAsTextFlag&gt; behavior)
413 {
414     if (behavior.contains(RenderAsTextFlag::ShowIDAndClass)) {
415         if (Element* element = is&lt;Element&gt;(object.node()) ? downcast&lt;Element&gt;(object.node()) : nullptr) {
416             if (element-&gt;hasID())
417                 ts &lt;&lt; &quot; id=\&quot;&quot; + element-&gt;getIdAttribute() + &quot;\&quot;&quot;;
418 
419             if (element-&gt;hasClass()) {
420                 ts &lt;&lt; &quot; class=\&quot;&quot;;
421                 for (size_t i = 0; i &lt; element-&gt;classNames().size(); ++i) {
422                     if (i &gt; 0)
423                         ts &lt;&lt; &quot; &quot;;
424                     ts &lt;&lt; element-&gt;classNames()[i];
425                 }
426                 ts &lt;&lt; &quot;\&quot;&quot;;
427             }
428         }
429     }
430 
431     if (behavior.contains(RenderAsTextFlag::ShowLayoutState)) {
432         bool needsLayout = object.selfNeedsLayout() || object.needsPositionedMovementLayout() || object.posChildNeedsLayout() || object.normalChildNeedsLayout();
433         if (needsLayout)
434             ts &lt;&lt; &quot; (needs layout:&quot;;
435 
436         bool havePrevious = false;
437         if (object.selfNeedsLayout()) {
438             ts &lt;&lt; &quot; self&quot;;
439             havePrevious = true;
440         }
441 
442         if (object.needsPositionedMovementLayout()) {
443             if (havePrevious)
444                 ts &lt;&lt; &quot;,&quot;;
445             havePrevious = true;
446             ts &lt;&lt; &quot; positioned movement&quot;;
447         }
448 
449         if (object.normalChildNeedsLayout()) {
450             if (havePrevious)
451                 ts &lt;&lt; &quot;,&quot;;
452             havePrevious = true;
453             ts &lt;&lt; &quot; child&quot;;
454         }
455 
456         if (object.posChildNeedsLayout()) {
457             if (havePrevious)
458                 ts &lt;&lt; &quot;,&quot;;
459             ts &lt;&lt; &quot; positioned child&quot;;
460         }
461 
462         if (needsLayout)
463             ts &lt;&lt; &quot;)&quot;;
464     }
465 
466     if (behavior.contains(RenderAsTextFlag::ShowOverflow) &amp;&amp; is&lt;RenderBox&gt;(object)) {
467         const auto&amp; box = downcast&lt;RenderBox&gt;(object);
468         if (box.hasRenderOverflow()) {
469             LayoutRect layoutOverflow = box.layoutOverflowRect();
470             ts &lt;&lt; &quot; (layout overflow &quot; &lt;&lt; layoutOverflow.x().toInt() &lt;&lt; &quot;,&quot; &lt;&lt; layoutOverflow.y().toInt() &lt;&lt; &quot; &quot; &lt;&lt; layoutOverflow.width().toInt() &lt;&lt; &quot;x&quot; &lt;&lt; layoutOverflow.height().toInt() &lt;&lt; &quot;)&quot;;
471 
472             if (box.hasVisualOverflow()) {
473                 LayoutRect visualOverflow = box.visualOverflowRect();
474                 ts &lt;&lt; &quot; (visual overflow &quot; &lt;&lt; visualOverflow.x().toInt() &lt;&lt; &quot;,&quot; &lt;&lt; visualOverflow.y().toInt() &lt;&lt; &quot; &quot; &lt;&lt; visualOverflow.width().toInt() &lt;&lt; &quot;x&quot; &lt;&lt; visualOverflow.height().toInt() &lt;&lt; &quot;)&quot;;
475             }
476         }
477     }
478 }
479 
<a name="9" id="anc9"></a><span class="line-modified">480 static void writeTextBox(TextStream&amp; ts, const RenderText&amp; o, const LineLayoutTraversal::TextBox&amp; textBox)</span>
481 {
482     auto rect = textBox.rect();
<a name="10" id="anc10"></a>

483     int x = rect.x();
484     int y = rect.y();
<a name="11" id="anc11"></a><span class="line-modified">485     // FIXME: Use non-logical width. webkit.org/b/206809.</span>
<span class="line-modified">486     int logicalWidth = ceilf(rect.x() + (textBox.isHorizontal() ? rect.width() : rect.height())) - x;</span>


487     // FIXME: Table cell adjustment is temporary until results can be updated.
488     if (is&lt;RenderTableCell&gt;(*o.containingBlock()))
489         y -= floorToInt(downcast&lt;RenderTableCell&gt;(*o.containingBlock()).intrinsicPaddingBefore());
490 
491     ts &lt;&lt; &quot;text run at (&quot; &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; &quot;) width &quot; &lt;&lt; logicalWidth;
492     if (!textBox.isLeftToRightDirection() || textBox.dirOverride()) {
493         ts &lt;&lt; (!textBox.isLeftToRightDirection() ? &quot; RTL&quot; : &quot; LTR&quot;);
494         if (textBox.dirOverride())
495             ts &lt;&lt; &quot; override&quot;;
496     }
497     ts &lt;&lt; &quot;: &quot;
498         &lt;&lt; quoteAndEscapeNonPrintables(textBox.text());
499     if (textBox.hasHyphen())
500         ts &lt;&lt; &quot; + hyphen string &quot; &lt;&lt; quoteAndEscapeNonPrintables(o.style().hyphenString().string());
501     ts &lt;&lt; &quot;\n&quot;;
502 }
503 
504 void write(TextStream&amp; ts, const RenderObject&amp; o, OptionSet&lt;RenderAsTextFlag&gt; behavior)
505 {
506     if (is&lt;RenderSVGShape&gt;(o)) {
507         write(ts, downcast&lt;RenderSVGShape&gt;(o), behavior);
508         return;
509     }
510     if (is&lt;RenderSVGGradientStop&gt;(o)) {
511         writeSVGGradientStop(ts, downcast&lt;RenderSVGGradientStop&gt;(o), behavior);
512         return;
513     }
514     if (is&lt;RenderSVGResourceContainer&gt;(o)) {
515         writeSVGResourceContainer(ts, downcast&lt;RenderSVGResourceContainer&gt;(o), behavior);
516         return;
517     }
518     if (is&lt;RenderSVGContainer&gt;(o)) {
519         writeSVGContainer(ts, downcast&lt;RenderSVGContainer&gt;(o), behavior);
520         return;
521     }
522     if (is&lt;RenderSVGRoot&gt;(o)) {
523         write(ts, downcast&lt;RenderSVGRoot&gt;(o), behavior);
524         return;
525     }
526     if (is&lt;RenderSVGText&gt;(o)) {
527         writeSVGText(ts, downcast&lt;RenderSVGText&gt;(o), behavior);
528         return;
529     }
530     if (is&lt;RenderSVGInlineText&gt;(o)) {
531         writeSVGInlineText(ts, downcast&lt;RenderSVGInlineText&gt;(o), behavior);
532         return;
533     }
534     if (is&lt;RenderSVGImage&gt;(o)) {
535         writeSVGImage(ts, downcast&lt;RenderSVGImage&gt;(o), behavior);
536         return;
537     }
538 
539     ts &lt;&lt; indent;
540 
541     RenderTreeAsText::writeRenderObject(ts, o, behavior);
542     ts &lt;&lt; &quot;\n&quot;;
543 
544     TextStream::IndentScope indentScope(ts);
545 
546     if (is&lt;RenderText&gt;(o)) {
547         auto&amp; text = downcast&lt;RenderText&gt;(o);
<a name="12" id="anc12"></a><span class="line-modified">548         for (auto&amp; textBox : LineLayoutTraversal::textBoxesFor(text)) {</span>
549             ts &lt;&lt; indent;
550             writeTextBox(ts, text, textBox);
551         }
552     } else {
553         for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(downcast&lt;RenderElement&gt;(o))) {
554             if (child.hasLayer())
555                 continue;
556             write(ts, child, behavior);
557         }
558     }
559 
560     if (is&lt;RenderWidget&gt;(o)) {
561         Widget* widget = downcast&lt;RenderWidget&gt;(o).widget();
562         if (is&lt;FrameView&gt;(widget)) {
563             FrameView&amp; view = downcast&lt;FrameView&gt;(*widget);
564             if (RenderView* root = view.frame().contentRenderer()) {
565                 if (!(behavior.contains(RenderAsTextFlag::DontUpdateLayout)))
566                     view.layoutContext().layout();
567                 if (RenderLayer* layer = root-&gt;layer())
568                     writeLayers(ts, *layer, *layer, layer-&gt;rect(), behavior);
569             }
570         }
571     }
572 }
573 
574 enum LayerPaintPhase {
575     LayerPaintPhaseAll = 0,
576     LayerPaintPhaseBackground = -1,
577     LayerPaintPhaseForeground = 1
578 };
579 
580 static void writeLayer(TextStream&amp; ts, const RenderLayer&amp; layer, const LayoutRect&amp; layerBounds, const LayoutRect&amp; backgroundClipRect, const LayoutRect&amp; clipRect,
581     LayerPaintPhase paintPhase = LayerPaintPhaseAll, OptionSet&lt;RenderAsTextFlag&gt; behavior = { })
582 {
583     IntRect adjustedLayoutBounds = snappedIntRect(layerBounds);
584     IntRect adjustedBackgroundClipRect = snappedIntRect(backgroundClipRect);
585     IntRect adjustedClipRect = snappedIntRect(clipRect);
586 
587     ts &lt;&lt; indent &lt;&lt; &quot;layer &quot;;
588 
589     if (behavior.contains(RenderAsTextFlag::ShowAddresses))
590         ts &lt;&lt; static_cast&lt;const void*&gt;(&amp;layer) &lt;&lt; &quot; &quot;;
591 
592     ts &lt;&lt; adjustedLayoutBounds;
593 
594     if (!adjustedLayoutBounds.isEmpty()) {
595         if (!adjustedBackgroundClipRect.contains(adjustedLayoutBounds))
596             ts &lt;&lt; &quot; backgroundClip &quot; &lt;&lt; adjustedBackgroundClipRect;
597         if (!adjustedClipRect.contains(adjustedLayoutBounds))
598             ts &lt;&lt; &quot; clip &quot; &lt;&lt; adjustedClipRect;
599     }
600 
601     if (layer.renderer().hasOverflowClip()) {
602         if (layer.scrollOffset().x())
603             ts &lt;&lt; &quot; scrollX &quot; &lt;&lt; layer.scrollOffset().x();
604         if (layer.scrollOffset().y())
605             ts &lt;&lt; &quot; scrollY &quot; &lt;&lt; layer.scrollOffset().y();
606         if (layer.renderBox() &amp;&amp; roundToInt(layer.renderBox()-&gt;clientWidth()) != layer.scrollWidth())
607             ts &lt;&lt; &quot; scrollWidth &quot; &lt;&lt; layer.scrollWidth();
608         if (layer.renderBox() &amp;&amp; roundToInt(layer.renderBox()-&gt;clientHeight()) != layer.scrollHeight())
609             ts &lt;&lt; &quot; scrollHeight &quot; &lt;&lt; layer.scrollHeight();
610 #if PLATFORM(MAC)
611         ScrollbarTheme&amp; scrollbarTheme = ScrollbarTheme::theme();
612         if (!scrollbarTheme.isMockTheme() &amp;&amp; layer.hasVerticalScrollbar()) {
613             ScrollbarThemeMac&amp; macTheme = *static_cast&lt;ScrollbarThemeMac*&gt;(&amp;scrollbarTheme);
614             if (macTheme.isLayoutDirectionRTL(*layer.verticalScrollbar()))
615                 ts &lt;&lt; &quot; scrollbarHasRTLLayoutDirection&quot;;
616         }
617 #endif
618     }
619 
620     if (paintPhase == LayerPaintPhaseBackground)
621         ts &lt;&lt; &quot; layerType: background only&quot;;
622     else if (paintPhase == LayerPaintPhaseForeground)
623         ts &lt;&lt; &quot; layerType: foreground only&quot;;
624 
625     if (behavior.contains(RenderAsTextFlag::ShowCompositedLayers)) {
626         if (layer.isComposited()) {
627             ts &lt;&lt; &quot; (composited, bounds=&quot; &lt;&lt; layer.backing()-&gt;compositedBounds() &lt;&lt; &quot;, drawsContent=&quot; &lt;&lt; layer.backing()-&gt;graphicsLayer()-&gt;drawsContent()
628                 &lt;&lt; &quot;, paints into ancestor=&quot; &lt;&lt; layer.backing()-&gt;paintsIntoCompositedAncestor() &lt;&lt; &quot;)&quot;;
629         } else if (layer.paintsIntoProvidedBacking())
630             ts &lt;&lt; &quot; (shared backing of &quot; &lt;&lt; layer.backingProviderLayer() &lt;&lt; &quot;)&quot;;
631     }
632 
633 #if ENABLE(CSS_COMPOSITING)
634     if (layer.isolatesBlending())
635         ts &lt;&lt; &quot; isolatesBlending&quot;;
636     if (layer.hasBlendMode())
<a name="13" id="anc13"></a><span class="line-modified">637         ts &lt;&lt; &quot; blendMode: &quot; &lt;&lt; compositeOperatorName(CompositeOperator::SourceOver, layer.blendMode());</span>
638 #endif
639 
640     ts &lt;&lt; &quot;\n&quot;;
641 }
642 
643 static void writeLayerRenderers(TextStream&amp; ts, const RenderLayer&amp; layer, LayerPaintPhase paintPhase, OptionSet&lt;RenderAsTextFlag&gt; behavior)
644 {
645     if (paintPhase != LayerPaintPhaseBackground) {
646         TextStream::IndentScope indentScope(ts);
647         write(ts, layer.renderer(), behavior);
648     }
649 }
650 
651 static LayoutSize maxLayoutOverflow(const RenderBox* box)
652 {
653     LayoutRect overflowRect = box-&gt;layoutOverflowRect();
654     return LayoutSize(overflowRect.maxX(), overflowRect.maxY());
655 }
656 
657 static void writeLayers(TextStream&amp; ts, const RenderLayer&amp; rootLayer, RenderLayer&amp; layer, const LayoutRect&amp; paintRect, OptionSet&lt;RenderAsTextFlag&gt; behavior)
658 {
659     // FIXME: Apply overflow to the root layer to not break every test. Complete hack. Sigh.
660     LayoutRect paintDirtyRect(paintRect);
661     if (&amp;rootLayer == &amp;layer) {
662         paintDirtyRect.setWidth(std::max&lt;LayoutUnit&gt;(paintDirtyRect.width(), rootLayer.renderBox()-&gt;layoutOverflowRect().maxX()));
663         paintDirtyRect.setHeight(std::max&lt;LayoutUnit&gt;(paintDirtyRect.height(), rootLayer.renderBox()-&gt;layoutOverflowRect().maxY()));
664         layer.setSize(layer.size().expandedTo(snappedIntSize(maxLayoutOverflow(layer.renderBox()), LayoutPoint(0, 0))));
665     }
666 
667     // Calculate the clip rects we should use.
668     LayoutRect layerBounds;
669     ClipRect damageRect;
670     ClipRect clipRectToApply;
671     LayoutSize offsetFromRoot = layer.offsetFromAncestor(&amp;rootLayer);
672     layer.calculateRects(RenderLayer::ClipRectsContext(&amp;rootLayer, TemporaryClipRects), paintDirtyRect, layerBounds, damageRect, clipRectToApply, offsetFromRoot);
673 
674     // Ensure our lists are up-to-date.
675     layer.updateLayerListsIfNeeded();
676     layer.updateDescendantDependentFlags();
677 
678     bool shouldPaint = (behavior.contains(RenderAsTextFlag::ShowAllLayers)) ? true : layer.intersectsDamageRect(layerBounds, damageRect.rect(), &amp;rootLayer, layer.offsetFromAncestor(&amp;rootLayer));
679     auto negativeZOrderLayers = layer.negativeZOrderLayers();
680     bool paintsBackgroundSeparately = negativeZOrderLayers.size() &gt; 0;
681     if (shouldPaint &amp;&amp; paintsBackgroundSeparately) {
682         writeLayer(ts, layer, layerBounds, damageRect.rect(), clipRectToApply.rect(), LayerPaintPhaseBackground, behavior);
683         writeLayerRenderers(ts, layer, LayerPaintPhaseBackground, behavior);
684     }
685 
686     if (negativeZOrderLayers.size()) {
687         if (behavior.contains(RenderAsTextFlag::ShowLayerNesting)) {
688             ts &lt;&lt; indent &lt;&lt; &quot; negative z-order list (&quot; &lt;&lt; negativeZOrderLayers.size() &lt;&lt; &quot;)\n&quot;;
689             ts.increaseIndent();
690         }
691 
692         for (auto* currLayer : negativeZOrderLayers)
693             writeLayers(ts, rootLayer, *currLayer, paintDirtyRect, behavior);
694 
695         if (behavior.contains(RenderAsTextFlag::ShowLayerNesting))
696             ts.decreaseIndent();
697     }
698 
699     if (shouldPaint) {
700         writeLayer(ts, layer, layerBounds, damageRect.rect(), clipRectToApply.rect(), paintsBackgroundSeparately ? LayerPaintPhaseForeground : LayerPaintPhaseAll, behavior);
701 
702         if (behavior.contains(RenderAsTextFlag::ShowLayerFragments)) {
703             LayerFragments layerFragments;
704             layer.collectFragments(layerFragments, &amp;rootLayer, paintDirtyRect, RenderLayer::PaginationInclusionMode::ExcludeCompositedPaginatedLayers, TemporaryClipRects, IgnoreOverlayScrollbarSize, RespectOverflowClip, offsetFromRoot);
705 
706             if (layerFragments.size() &gt; 1) {
707                 TextStream::IndentScope indentScope(ts, 2);
708                 for (unsigned i = 0; i &lt; layerFragments.size(); ++i) {
709                     const auto&amp; fragment = layerFragments[i];
710                     ts &lt;&lt; indent &lt;&lt; &quot; fragment &quot; &lt;&lt; i &lt;&lt; &quot;: bounds in layer &quot; &lt;&lt; fragment.layerBounds &lt;&lt; &quot; fragment bounds &quot; &lt;&lt; fragment.boundingBox &lt;&lt; &quot;\n&quot;;
711                 }
712             }
713         }
714 
715         writeLayerRenderers(ts, layer, paintsBackgroundSeparately ? LayerPaintPhaseForeground : LayerPaintPhaseAll, behavior);
716     }
717 
718     auto normalFlowLayers = layer.normalFlowLayers();
719     if (normalFlowLayers.size()) {
720         if (behavior.contains(RenderAsTextFlag::ShowLayerNesting)) {
721             ts &lt;&lt; indent &lt;&lt; &quot; normal flow list (&quot; &lt;&lt; normalFlowLayers.size() &lt;&lt; &quot;)\n&quot;;
722             ts.increaseIndent();
723         }
724 
725         for (auto* currLayer : normalFlowLayers)
726             writeLayers(ts, rootLayer, *currLayer, paintDirtyRect, behavior);
727 
728         if (behavior.contains(RenderAsTextFlag::ShowLayerNesting))
729             ts.decreaseIndent();
730     }
731 
732     auto positiveZOrderLayers = layer.positiveZOrderLayers();
733     if (positiveZOrderLayers.size()) {
734         size_t layerCount = positiveZOrderLayers.size();
735 
736         if (layerCount) {
737             if (behavior.contains(RenderAsTextFlag::ShowLayerNesting)) {
738                 ts &lt;&lt; indent &lt;&lt; &quot; positive z-order list (&quot; &lt;&lt; layerCount &lt;&lt; &quot;)\n&quot;;
739                 ts.increaseIndent();
740             }
741 
742             for (auto* currLayer : positiveZOrderLayers)
743                 writeLayers(ts, rootLayer, *currLayer, paintDirtyRect, behavior);
744 
745             if (behavior.contains(RenderAsTextFlag::ShowLayerNesting))
746                 ts.decreaseIndent();
747         }
748     }
749 }
750 
751 static String nodePosition(Node* node)
752 {
753     StringBuilder result;
754 
755     auto* body = node-&gt;document().bodyOrFrameset();
756     Node* parent;
757     for (Node* n = node; n; n = parent) {
758         parent = n-&gt;parentOrShadowHostNode();
759         if (n != node)
760             result.appendLiteral(&quot; of &quot;);
761         if (parent) {
762             if (body &amp;&amp; n == body) {
763                 // We don&#39;t care what offset body may be in the document.
764                 result.appendLiteral(&quot;body&quot;);
765                 break;
766             }
767             if (n-&gt;isShadowRoot()) {
768                 result.append(&#39;{&#39;);
769                 result.append(getTagName(n));
770                 result.append(&#39;}&#39;);
771             } else {
772                 result.appendLiteral(&quot;child &quot;);
773                 result.appendNumber(n-&gt;computeNodeIndex());
774                 result.appendLiteral(&quot; {&quot;);
775                 result.append(getTagName(n));
776                 result.append(&#39;}&#39;);
777             }
778         } else
779             result.appendLiteral(&quot;document&quot;);
780     }
781 
782     return result.toString();
783 }
784 
785 static void writeSelection(TextStream&amp; ts, const RenderBox&amp; renderer)
786 {
787     if (!renderer.isRenderView())
788         return;
789 
790     Frame* frame = renderer.document().frame();
791     if (!frame)
792         return;
793 
794     VisibleSelection selection = frame-&gt;selection().selection();
795     if (selection.isCaret()) {
796         ts &lt;&lt; &quot;caret: position &quot; &lt;&lt; selection.start().deprecatedEditingOffset() &lt;&lt; &quot; of &quot; &lt;&lt; nodePosition(selection.start().deprecatedNode());
797         if (selection.affinity() == UPSTREAM)
798             ts &lt;&lt; &quot; (upstream affinity)&quot;;
799         ts &lt;&lt; &quot;\n&quot;;
800     } else if (selection.isRange())
801         ts &lt;&lt; &quot;selection start: position &quot; &lt;&lt; selection.start().deprecatedEditingOffset() &lt;&lt; &quot; of &quot; &lt;&lt; nodePosition(selection.start().deprecatedNode()) &lt;&lt; &quot;\n&quot;
802            &lt;&lt; &quot;selection end:   position &quot; &lt;&lt; selection.end().deprecatedEditingOffset() &lt;&lt; &quot; of &quot; &lt;&lt; nodePosition(selection.end().deprecatedNode()) &lt;&lt; &quot;\n&quot;;
803 }
804 
805 static String externalRepresentation(RenderBox&amp; renderer, OptionSet&lt;RenderAsTextFlag&gt; behavior)
806 {
807     TextStream ts(TextStream::LineMode::MultipleLine, TextStream::Formatting::SVGStyleRect | TextStream::Formatting::LayoutUnitsAsIntegers);
808     if (!renderer.hasLayer())
809         return ts.release();
810 
811     LOG(Layout, &quot;externalRepresentation: dumping layer tree&quot;);
812 
813     RenderLayer&amp; layer = *renderer.layer();
814     writeLayers(ts, layer, layer, layer.rect(), behavior);
815     writeSelection(ts, renderer);
816     return ts.release();
817 }
818 
819 static void updateLayoutIgnoringPendingStylesheetsIncludingSubframes(Document&amp; document)
820 {
821     document.updateLayoutIgnorePendingStylesheets();
822     auto* frame = document.frame();
823     for (auto* subframe = frame; subframe; subframe = subframe-&gt;tree().traverseNext(frame)) {
824         if (auto* document = subframe-&gt;document())
825             document-&gt;updateLayoutIgnorePendingStylesheets();
826     }
827 }
828 
829 String externalRepresentation(Frame* frame, OptionSet&lt;RenderAsTextFlag&gt; behavior)
830 {
831     ASSERT(frame);
832     ASSERT(frame-&gt;document());
833 
834     if (!(behavior.contains(RenderAsTextFlag::DontUpdateLayout)))
835         updateLayoutIgnoringPendingStylesheetsIncludingSubframes(*frame-&gt;document());
836 
837     auto* renderer = frame-&gt;contentRenderer();
838     if (!renderer)
839         return String();
840 
841     PrintContext printContext(frame);
842     if (behavior.contains(RenderAsTextFlag::PrintingMode))
843         printContext.begin(renderer-&gt;width());
844 
845     return externalRepresentation(*renderer, behavior);
846 }
847 
848 String externalRepresentation(Element* element, OptionSet&lt;RenderAsTextFlag&gt; behavior)
849 {
850     ASSERT(element);
851 
852     // This function doesn&#39;t support printing mode.
853     ASSERT(!(behavior.contains(RenderAsTextFlag::PrintingMode)));
854 
855     if (!(behavior.contains(RenderAsTextFlag::DontUpdateLayout)))
856         updateLayoutIgnoringPendingStylesheetsIncludingSubframes(element-&gt;document());
857 
858     auto* renderer = element-&gt;renderer();
859     if (!is&lt;RenderBox&gt;(renderer))
860         return String();
861 
862     return externalRepresentation(downcast&lt;RenderBox&gt;(*renderer), behavior | RenderAsTextFlag::ShowAllLayers);
863 }
864 
865 static void writeCounterValuesFromChildren(TextStream&amp; stream, const RenderElement* parent, bool&amp; isFirstCounter)
866 {
867     if (!parent)
868         return;
869     for (auto&amp; counter : childrenOfType&lt;RenderCounter&gt;(*parent)) {
870         if (!isFirstCounter)
871             stream &lt;&lt; &quot; &quot;;
872         isFirstCounter = false;
873         String str(counter.text());
874         stream &lt;&lt; str;
875     }
876 }
877 
878 String counterValueForElement(Element* element)
879 {
880     // Make sure the element is not freed during the layout.
881     RefPtr&lt;Element&gt; elementRef(element);
882     element-&gt;document().updateLayout();
883     TextStream stream(TextStream::LineMode::MultipleLine, TextStream::Formatting::SVGStyleRect | TextStream::Formatting::LayoutUnitsAsIntegers);
884     bool isFirstCounter = true;
885     // The counter renderers should be children of :before or :after pseudo-elements.
886     if (PseudoElement* before = element-&gt;beforePseudoElement())
887         writeCounterValuesFromChildren(stream, before-&gt;renderer(), isFirstCounter);
888     if (PseudoElement* after = element-&gt;afterPseudoElement())
889         writeCounterValuesFromChildren(stream, after-&gt;renderer(), isFirstCounter);
890     return stream.release();
891 }
892 
893 String markerTextForListItem(Element* element)
894 {
895     // Make sure the element is not freed during the layout.
896     RefPtr&lt;Element&gt; elementRef(element);
897     element-&gt;document().updateLayout();
898 
899     RenderElement* renderer = element-&gt;renderer();
900     if (!is&lt;RenderListItem&gt;(renderer))
901         return String();
902 
903     return downcast&lt;RenderListItem&gt;(*renderer).markerText();
904 }
905 
906 } // namespace WebCore
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
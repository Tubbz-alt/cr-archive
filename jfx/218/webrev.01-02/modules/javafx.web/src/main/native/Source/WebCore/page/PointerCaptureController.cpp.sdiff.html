<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/PointerCaptureController.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PlugInClient.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PointerCaptureController.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/PointerCaptureController.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 16  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 17  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 18  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 19  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 20  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 21  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 22  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 23  */
 24 
 25 #include &quot;config.h&quot;
 26 #include &quot;PointerCaptureController.h&quot;
 27 
 28 #if ENABLE(POINTER_EVENTS)
 29 
 30 #include &quot;Document.h&quot;
 31 #include &quot;Element.h&quot;
 32 #include &quot;EventHandler.h&quot;
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;EventTarget.h&quot;

 35 #include &quot;Page.h&quot;
 36 #include &quot;PointerEvent.h&quot;
 37 #include &lt;wtf/CheckedArithmetic.h&gt;
 38 
 39 #if ENABLE(POINTER_LOCK)
 40 #include &quot;PointerLockController.h&quot;
 41 #endif
 42 
 43 namespace WebCore {
 44 
 45 PointerCaptureController::PointerCaptureController(Page&amp; page)
 46     : m_page(page)
 47 {
 48     reset();
 49 }
 50 
 51 Element* PointerCaptureController::pointerCaptureElement(Document* document, PointerID pointerId)
 52 {
 53     auto iterator = m_activePointerIdsToCapturingData.find(pointerId);
 54     if (iterator != m_activePointerIdsToCapturingData.end()) {
</pre>
<hr />
<pre>
132     // method has been called if any element is set to be captured or pending to be captured.
133     for (auto&amp; capturingData : m_activePointerIdsToCapturingData.values()) {
134         capturingData.pendingTargetOverride = nullptr;
135         capturingData.targetOverride = nullptr;
136     }
137 }
138 
139 void PointerCaptureController::elementWasRemoved(Element&amp; element)
140 {
141     for (auto&amp; keyAndValue : m_activePointerIdsToCapturingData) {
142         auto&amp; capturingData = keyAndValue.value;
143         if (capturingData.pendingTargetOverride == &amp;element || capturingData.targetOverride == &amp;element) {
144             // https://w3c.github.io/pointerevents/#implicit-release-of-pointer-capture
145             // When the pointer capture target override is no longer connected, the pending pointer capture target override and pointer capture target
146             // override nodes SHOULD be cleared and also a PointerEvent named lostpointercapture corresponding to the captured pointer SHOULD be fired
147             // at the document.
148             ASSERT(WTF::isInBounds&lt;PointerID&gt;(keyAndValue.key));
149             auto pointerId = static_cast&lt;PointerID&gt;(keyAndValue.key);
150             auto pointerType = capturingData.pointerType;
151             releasePointerCapture(&amp;element, pointerId);
<span class="line-modified">152             element.document().enqueueDocumentEvent(PointerEvent::create(eventNames().lostpointercaptureEvent, pointerId, pointerType));</span>

153             return;
154         }
155     }
156 }
157 
158 void PointerCaptureController::reset()
159 {
160     m_activePointerIdsToCapturingData.clear();
<span class="line-modified">161 #if !ENABLE(TOUCH_EVENTS)</span>
162     CapturingData capturingData;
163     capturingData.pointerType = PointerEvent::mousePointerType();
164     m_activePointerIdsToCapturingData.add(mousePointerID, capturingData);
<span class="line-removed">165 #endif</span>
166 }
167 
168 void PointerCaptureController::touchWithIdentifierWasRemoved(PointerID pointerId)
169 {
170     m_activePointerIdsToCapturingData.remove(pointerId);
171 }
172 
173 bool PointerCaptureController::hasCancelledPointerEventForIdentifier(PointerID pointerId)
174 {
175     auto iterator = m_activePointerIdsToCapturingData.find(pointerId);
176     return iterator != m_activePointerIdsToCapturingData.end() &amp;&amp; iterator-&gt;value.cancelled;
177 }
178 
179 bool PointerCaptureController::preventsCompatibilityMouseEventsForIdentifier(PointerID pointerId)
180 {
181     auto iterator = m_activePointerIdsToCapturingData.find(pointerId);
182     return iterator != m_activePointerIdsToCapturingData.end() &amp;&amp; iterator-&gt;value.preventsCompatibilityMouseEvents;
183 }
184 
185 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)









186 void PointerCaptureController::dispatchEventForTouchAtIndex(EventTarget&amp; target, const PlatformTouchEvent&amp; platformTouchEvent, unsigned index, bool isPrimary, WindowProxy&amp; view)
187 {
<span class="line-modified">188     auto dispatchOverOrOutEvent = [&amp;](const String&amp; type) {</span>
<span class="line-modified">189         dispatchEvent(PointerEvent::create(type, platformTouchEvent, index, isPrimary, view), &amp;target);</span>


190     };
191 
192     auto dispatchEnterOrLeaveEvent = [&amp;](const String&amp; type) {
<span class="line-removed">193         if (!is&lt;Element&gt;(&amp;target))</span>
<span class="line-removed">194             return;</span>
<span class="line-removed">195 </span>
196         auto* targetElement = &amp;downcast&lt;Element&gt;(target);
197 
198         bool hasCapturingListenerInHierarchy = false;
199         for (ContainerNode* curr = targetElement; curr; curr = curr-&gt;parentInComposedTree()) {
200             if (curr-&gt;hasCapturingEventListeners(type)) {
201                 hasCapturingListenerInHierarchy = true;
202                 break;
203             }
204         }
205 
206         Vector&lt;Ref&lt;Element&gt;, 32&gt; targetChain;
207         for (Element* element = targetElement; element; element = element-&gt;parentElementInComposedTree()) {
208             if (hasCapturingListenerInHierarchy || element-&gt;hasEventListeners(type))
209                 targetChain.append(*element);
210         }
211 
212         if (type == eventNames().pointerenterEvent) {
213             for (auto&amp; element : WTF::makeReversedRange(targetChain))
214                 dispatchEvent(PointerEvent::create(type, platformTouchEvent, index, isPrimary, view), element.ptr());
215         } else {
216             for (auto&amp; element : targetChain)
217                 dispatchEvent(PointerEvent::create(type, platformTouchEvent, index, isPrimary, view), element.ptr());
218         }
219     };
220 
221     auto pointerEvent = PointerEvent::create(platformTouchEvent, index, isPrimary, view);
222 



















































223     if (pointerEvent-&gt;type() == eventNames().pointerdownEvent) {
224         // https://w3c.github.io/pointerevents/#the-pointerdown-event
225         // For input devices that do not support hover, a user agent MUST also fire a pointer event named pointerover followed by a pointer event named
226         // pointerenter prior to dispatching the pointerdown event.
<span class="line-modified">227         dispatchOverOrOutEvent(eventNames().pointeroverEvent);</span>
228         dispatchEnterOrLeaveEvent(eventNames().pointerenterEvent);
229     }
230 
231     dispatchEvent(pointerEvent, &amp;target);
232 
233     if (pointerEvent-&gt;type() == eventNames().pointerupEvent) {
234         // https://w3c.github.io/pointerevents/#the-pointerup-event
235         // For input devices that do not support hover, a user agent MUST also fire a pointer event named pointerout followed by a
236         // pointer event named pointerleave after dispatching the pointerup event.
<span class="line-modified">237         dispatchOverOrOutEvent(eventNames().pointeroutEvent);</span>
238         dispatchEnterOrLeaveEvent(eventNames().pointerleaveEvent);

239     }
240 }
241 #endif
242 
243 RefPtr&lt;PointerEvent&gt; PointerCaptureController::pointerEventForMouseEvent(const MouseEvent&amp; mouseEvent)
244 {
245     const auto&amp; type = mouseEvent.type();
246     const auto&amp; names = eventNames();
247 
248     auto iterator = m_activePointerIdsToCapturingData.find(mousePointerID);
249     ASSERT(iterator != m_activePointerIdsToCapturingData.end());
250     auto&amp; capturingData = iterator-&gt;value;
251 
252     short newButton = mouseEvent.button();
253     short button = (type == names.mousemoveEvent &amp;&amp; newButton == capturingData.previousMouseButton) ? -1 : newButton;
254 
255     // https://w3c.github.io/pointerevents/#chorded-button-interactions
256     // Some pointer devices, such as mouse or pen, support multiple buttons. In the Mouse Event model, each button
257     // press produces a mousedown and mouseup event. To better abstract this hardware difference and simplify
258     // cross-device input authoring, Pointer Events do not fire overlapping pointerdown and pointerup events
</pre>
<hr />
<pre>
308         if (iterator != m_activePointerIdsToCapturingData.end())
309             iterator-&gt;value.pointerIsPressed = isPointerdown;
310         return;
311     }
312 
313     if (!isPointerdown)
314         return;
315 
316     // https://w3c.github.io/pointerevents/#implicit-pointer-capture
317 
318     // Some input devices (such as touchscreens) implement a &quot;direct manipulation&quot; metaphor where a pointer is intended to act primarily on the UI
319     // element it became active upon (providing a physical illusion of direct contact, instead of indirect contact via a cursor that conceptually
320     // floats above the UI). Such devices are identified by the InputDeviceCapabilities.pointerMovementScrolls property and should have &quot;implicit
321     // pointer capture&quot; behavior as follows.
322 
323     // Direct manipulation devices should behave exactly as if setPointerCapture was called on the target element just before the invocation of any
324     // pointerdown listeners. The hasPointerCapture API may be used (eg. within any pointerdown listener) to determine whether this has occurred. If
325     // releasePointerCapture is not called for the pointer before the next pointer event is fired, then a gotpointercapture event will be dispatched
326     // to the target (as normal) indicating that capture is active.
327 
<span class="line-modified">328     CapturingData capturingData;</span>
<span class="line-removed">329     capturingData.pointerType = event.pointerType();</span>
330     capturingData.pointerIsPressed = true;
<span class="line-removed">331     m_activePointerIdsToCapturingData.set(pointerId, capturingData);</span>
332     setPointerCapture(downcast&lt;Element&gt;(target), pointerId);
333 }
334 









335 void PointerCaptureController::pointerEventWasDispatched(const PointerEvent&amp; event)
336 {
337     auto iterator = m_activePointerIdsToCapturingData.find(event.pointerId());
338     if (iterator != m_activePointerIdsToCapturingData.end()) {
339         auto&amp; capturingData = iterator-&gt;value;
340         capturingData.isPrimary = event.isPrimary();
341 
342         // Immediately after firing the pointerup or pointercancel events, a user agent MUST clear the pending pointer capture target
343         // override for the pointerId of the pointerup or pointercancel event that was just dispatched, and then run Process Pending
344         // Pointer Capture steps to fire lostpointercapture if necessary.
345         // https://w3c.github.io/pointerevents/#implicit-release-of-pointer-capture
346         if (event.type() == eventNames().pointerupEvent) {
347             capturingData.pendingTargetOverride = nullptr;
348             processPendingPointerCapture(event.pointerId());
349         }
350 
351         // If a mouse pointer has moved while it isn&#39;t pressed, make sure we reset the preventsCompatibilityMouseEvents flag since
352         // we could otherwise prevent compatibility mouse events while those are only supposed to be prevented while the pointer is pressed.
353         if (event.type() == eventNames().pointermoveEvent &amp;&amp; capturingData.pointerType == PointerEvent::mousePointerType() &amp;&amp; !capturingData.pointerIsPressed)
354             capturingData.preventsCompatibilityMouseEvents = false;
</pre>
<hr />
<pre>
373 
374     // https://w3c.github.io/pointerevents/#implicit-release-of-pointer-capture
375 
376     // Immediately after firing the pointerup or pointercancel events, a user agent MUST clear the pending pointer capture target
377     // override for the pointerId of the pointerup or pointercancel event that was just dispatched, and then run Process Pending
378     // Pointer Capture steps to fire lostpointercapture if necessary. After running Process Pending Pointer Capture steps, if the
379     // pointer supports hover, user agent MUST also send corresponding boundary events necessary to reflect the current position of
380     // the pointer with no capture.
381 
382     auto iterator = m_activePointerIdsToCapturingData.find(pointerId);
383     if (iterator == m_activePointerIdsToCapturingData.end())
384         return;
385 
386     auto&amp; capturingData = iterator-&gt;value;
387     if (capturingData.cancelled)
388         return;
389 
390     capturingData.pendingTargetOverride = nullptr;
391     capturingData.cancelled = true;
392 




393     auto&amp; target = capturingData.targetOverride;
394     if (!target)
395         target = m_page.mainFrame().eventHandler().hitTestResultAtPoint(documentPoint, HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::DisallowUserAgentShadowContent | HitTestRequest::AllowChildFrameContent).innerNonSharedElement();
396 
397     if (!target)
398         return;
399 
400     // After firing the pointercancel event, a user agent MUST also fire a pointer event named pointerout
401     // followed by firing a pointer event named pointerleave.
402     auto isPrimary = capturingData.isPrimary ? PointerEvent::IsPrimary::Yes : PointerEvent::IsPrimary::No;
403     auto cancelEvent = PointerEvent::create(eventNames().pointercancelEvent, pointerId, capturingData.pointerType, isPrimary);
404     target-&gt;dispatchEvent(cancelEvent);
405     target-&gt;dispatchEvent(PointerEvent::create(eventNames().pointeroutEvent, pointerId, capturingData.pointerType, isPrimary));
406     target-&gt;dispatchEvent(PointerEvent::create(eventNames().pointerleaveEvent, pointerId, capturingData.pointerType, isPrimary));
407     processPendingPointerCapture(pointerId);
408 }
409 
410 void PointerCaptureController::processPendingPointerCapture(PointerID pointerId)
411 {
412     auto iterator = m_activePointerIdsToCapturingData.find(pointerId);
</pre>
</td>
<td>
<hr />
<pre>
 15  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 16  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 17  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 18  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 19  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 20  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 21  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 22  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 23  */
 24 
 25 #include &quot;config.h&quot;
 26 #include &quot;PointerCaptureController.h&quot;
 27 
 28 #if ENABLE(POINTER_EVENTS)
 29 
 30 #include &quot;Document.h&quot;
 31 #include &quot;Element.h&quot;
 32 #include &quot;EventHandler.h&quot;
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;EventTarget.h&quot;
<span class="line-added"> 35 #include &quot;HitTestResult.h&quot;</span>
 36 #include &quot;Page.h&quot;
 37 #include &quot;PointerEvent.h&quot;
 38 #include &lt;wtf/CheckedArithmetic.h&gt;
 39 
 40 #if ENABLE(POINTER_LOCK)
 41 #include &quot;PointerLockController.h&quot;
 42 #endif
 43 
 44 namespace WebCore {
 45 
 46 PointerCaptureController::PointerCaptureController(Page&amp; page)
 47     : m_page(page)
 48 {
 49     reset();
 50 }
 51 
 52 Element* PointerCaptureController::pointerCaptureElement(Document* document, PointerID pointerId)
 53 {
 54     auto iterator = m_activePointerIdsToCapturingData.find(pointerId);
 55     if (iterator != m_activePointerIdsToCapturingData.end()) {
</pre>
<hr />
<pre>
133     // method has been called if any element is set to be captured or pending to be captured.
134     for (auto&amp; capturingData : m_activePointerIdsToCapturingData.values()) {
135         capturingData.pendingTargetOverride = nullptr;
136         capturingData.targetOverride = nullptr;
137     }
138 }
139 
140 void PointerCaptureController::elementWasRemoved(Element&amp; element)
141 {
142     for (auto&amp; keyAndValue : m_activePointerIdsToCapturingData) {
143         auto&amp; capturingData = keyAndValue.value;
144         if (capturingData.pendingTargetOverride == &amp;element || capturingData.targetOverride == &amp;element) {
145             // https://w3c.github.io/pointerevents/#implicit-release-of-pointer-capture
146             // When the pointer capture target override is no longer connected, the pending pointer capture target override and pointer capture target
147             // override nodes SHOULD be cleared and also a PointerEvent named lostpointercapture corresponding to the captured pointer SHOULD be fired
148             // at the document.
149             ASSERT(WTF::isInBounds&lt;PointerID&gt;(keyAndValue.key));
150             auto pointerId = static_cast&lt;PointerID&gt;(keyAndValue.key);
151             auto pointerType = capturingData.pointerType;
152             releasePointerCapture(&amp;element, pointerId);
<span class="line-modified">153             // FIXME: Spec doesn&#39;t specify which task source to use.</span>
<span class="line-added">154             element.document().queueTaskToDispatchEvent(TaskSource::UserInteraction, PointerEvent::create(eventNames().lostpointercaptureEvent, pointerId, pointerType));</span>
155             return;
156         }
157     }
158 }
159 
160 void PointerCaptureController::reset()
161 {
162     m_activePointerIdsToCapturingData.clear();
<span class="line-modified">163 </span>
164     CapturingData capturingData;
165     capturingData.pointerType = PointerEvent::mousePointerType();
166     m_activePointerIdsToCapturingData.add(mousePointerID, capturingData);

167 }
168 
169 void PointerCaptureController::touchWithIdentifierWasRemoved(PointerID pointerId)
170 {
171     m_activePointerIdsToCapturingData.remove(pointerId);
172 }
173 
174 bool PointerCaptureController::hasCancelledPointerEventForIdentifier(PointerID pointerId)
175 {
176     auto iterator = m_activePointerIdsToCapturingData.find(pointerId);
177     return iterator != m_activePointerIdsToCapturingData.end() &amp;&amp; iterator-&gt;value.cancelled;
178 }
179 
180 bool PointerCaptureController::preventsCompatibilityMouseEventsForIdentifier(PointerID pointerId)
181 {
182     auto iterator = m_activePointerIdsToCapturingData.find(pointerId);
183     return iterator != m_activePointerIdsToCapturingData.end() &amp;&amp; iterator-&gt;value.preventsCompatibilityMouseEvents;
184 }
185 
186 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)
<span class="line-added">187 static bool hierarchyHasCapturingEventListeners(Element* target, const AtomString&amp; eventName)</span>
<span class="line-added">188 {</span>
<span class="line-added">189     for (ContainerNode* curr = target; curr; curr = curr-&gt;parentInComposedTree()) {</span>
<span class="line-added">190         if (curr-&gt;hasCapturingEventListeners(eventName))</span>
<span class="line-added">191             return true;</span>
<span class="line-added">192     }</span>
<span class="line-added">193     return false;</span>
<span class="line-added">194 }</span>
<span class="line-added">195 </span>
196 void PointerCaptureController::dispatchEventForTouchAtIndex(EventTarget&amp; target, const PlatformTouchEvent&amp; platformTouchEvent, unsigned index, bool isPrimary, WindowProxy&amp; view)
197 {
<span class="line-modified">198     ASSERT(is&lt;Element&gt;(target));</span>
<span class="line-modified">199 </span>
<span class="line-added">200     auto dispatchOverOrOutEvent = [&amp;](const String&amp; type, EventTarget* target) {</span>
<span class="line-added">201         dispatchEvent(PointerEvent::create(type, platformTouchEvent, index, isPrimary, view), target);</span>
202     };
203 
204     auto dispatchEnterOrLeaveEvent = [&amp;](const String&amp; type) {



205         auto* targetElement = &amp;downcast&lt;Element&gt;(target);
206 
207         bool hasCapturingListenerInHierarchy = false;
208         for (ContainerNode* curr = targetElement; curr; curr = curr-&gt;parentInComposedTree()) {
209             if (curr-&gt;hasCapturingEventListeners(type)) {
210                 hasCapturingListenerInHierarchy = true;
211                 break;
212             }
213         }
214 
215         Vector&lt;Ref&lt;Element&gt;, 32&gt; targetChain;
216         for (Element* element = targetElement; element; element = element-&gt;parentElementInComposedTree()) {
217             if (hasCapturingListenerInHierarchy || element-&gt;hasEventListeners(type))
218                 targetChain.append(*element);
219         }
220 
221         if (type == eventNames().pointerenterEvent) {
222             for (auto&amp; element : WTF::makeReversedRange(targetChain))
223                 dispatchEvent(PointerEvent::create(type, platformTouchEvent, index, isPrimary, view), element.ptr());
224         } else {
225             for (auto&amp; element : targetChain)
226                 dispatchEvent(PointerEvent::create(type, platformTouchEvent, index, isPrimary, view), element.ptr());
227         }
228     };
229 
230     auto pointerEvent = PointerEvent::create(platformTouchEvent, index, isPrimary, view);
231 
<span class="line-added">232     auto&amp; capturingData = ensureCapturingDataForPointerEvent(pointerEvent);</span>
<span class="line-added">233 </span>
<span class="line-added">234     // Check if the target changed, which would require dispatching boundary events.</span>
<span class="line-added">235     RefPtr&lt;Element&gt; previousTarget = capturingData.previousTarget;</span>
<span class="line-added">236     RefPtr&lt;Element&gt; currentTarget = downcast&lt;Element&gt;(&amp;target);</span>
<span class="line-added">237 </span>
<span class="line-added">238     capturingData.previousTarget = currentTarget;</span>
<span class="line-added">239 </span>
<span class="line-added">240     if (pointerEvent-&gt;type() == eventNames().pointermoveEvent &amp;&amp; previousTarget != currentTarget) {</span>
<span class="line-added">241         // The pointerenter and pointerleave events are only dispatched if there is a capturing event listener on an ancestor</span>
<span class="line-added">242         // or a normal event listener on the element itself since those events do not bubble.</span>
<span class="line-added">243         // This optimization is necessary since these events can cause O(n^2) capturing event-handler checks. This follows the</span>
<span class="line-added">244         // code for similar mouse events in EventHandler::updateMouseEventTargetNode().</span>
<span class="line-added">245         bool hasCapturingPointerEnterListener = hierarchyHasCapturingEventListeners(currentTarget.get(), eventNames().pointerenterEvent);</span>
<span class="line-added">246         bool hasCapturingPointerLeaveListener = hierarchyHasCapturingEventListeners(previousTarget.get(), eventNames().pointerleaveEvent);</span>
<span class="line-added">247 </span>
<span class="line-added">248         Vector&lt;Ref&lt;Element&gt;, 32&gt; leftElementsChain;</span>
<span class="line-added">249         for (Element* element = previousTarget.get(); element; element = element-&gt;parentElementInComposedTree())</span>
<span class="line-added">250             leftElementsChain.append(*element);</span>
<span class="line-added">251         Vector&lt;Ref&lt;Element&gt;, 32&gt; enteredElementsChain;</span>
<span class="line-added">252         for (Element* element = currentTarget.get(); element; element = element-&gt;parentElementInComposedTree())</span>
<span class="line-added">253             enteredElementsChain.append(*element);</span>
<span class="line-added">254 </span>
<span class="line-added">255         if (!leftElementsChain.isEmpty() &amp;&amp; !enteredElementsChain.isEmpty() &amp;&amp; leftElementsChain.last().ptr() == enteredElementsChain.last().ptr()) {</span>
<span class="line-added">256             size_t minHeight = std::min(leftElementsChain.size(), enteredElementsChain.size());</span>
<span class="line-added">257             size_t i;</span>
<span class="line-added">258             for (i = 0; i &lt; minHeight; ++i) {</span>
<span class="line-added">259                 if (leftElementsChain[leftElementsChain.size() - i - 1].ptr() != enteredElementsChain[enteredElementsChain.size() - i - 1].ptr())</span>
<span class="line-added">260                     break;</span>
<span class="line-added">261             }</span>
<span class="line-added">262             leftElementsChain.shrink(leftElementsChain.size() - i);</span>
<span class="line-added">263             enteredElementsChain.shrink(enteredElementsChain.size() - i);</span>
<span class="line-added">264         }</span>
<span class="line-added">265 </span>
<span class="line-added">266         if (previousTarget)</span>
<span class="line-added">267             dispatchOverOrOutEvent(eventNames().pointeroutEvent, previousTarget.get());</span>
<span class="line-added">268 </span>
<span class="line-added">269         for (auto&amp; chain : leftElementsChain) {</span>
<span class="line-added">270             if (hasCapturingPointerLeaveListener || chain-&gt;hasEventListeners(eventNames().pointerleaveEvent))</span>
<span class="line-added">271                 dispatchEvent(PointerEvent::create(eventNames().pointerleaveEvent, platformTouchEvent, index, isPrimary, view), chain.ptr());</span>
<span class="line-added">272         }</span>
<span class="line-added">273 </span>
<span class="line-added">274         if (currentTarget)</span>
<span class="line-added">275             dispatchOverOrOutEvent(eventNames().pointeroverEvent, currentTarget.get());</span>
<span class="line-added">276 </span>
<span class="line-added">277         for (auto&amp; chain : WTF::makeReversedRange(enteredElementsChain)) {</span>
<span class="line-added">278             if (hasCapturingPointerEnterListener || chain-&gt;hasEventListeners(eventNames().pointerenterEvent))</span>
<span class="line-added">279                 dispatchEvent(PointerEvent::create(eventNames().pointerenterEvent, platformTouchEvent, index, isPrimary, view), chain.ptr());</span>
<span class="line-added">280         }</span>
<span class="line-added">281     }</span>
<span class="line-added">282 </span>
283     if (pointerEvent-&gt;type() == eventNames().pointerdownEvent) {
284         // https://w3c.github.io/pointerevents/#the-pointerdown-event
285         // For input devices that do not support hover, a user agent MUST also fire a pointer event named pointerover followed by a pointer event named
286         // pointerenter prior to dispatching the pointerdown event.
<span class="line-modified">287         dispatchOverOrOutEvent(eventNames().pointeroverEvent, currentTarget.get());</span>
288         dispatchEnterOrLeaveEvent(eventNames().pointerenterEvent);
289     }
290 
291     dispatchEvent(pointerEvent, &amp;target);
292 
293     if (pointerEvent-&gt;type() == eventNames().pointerupEvent) {
294         // https://w3c.github.io/pointerevents/#the-pointerup-event
295         // For input devices that do not support hover, a user agent MUST also fire a pointer event named pointerout followed by a
296         // pointer event named pointerleave after dispatching the pointerup event.
<span class="line-modified">297         dispatchOverOrOutEvent(eventNames().pointeroutEvent, currentTarget.get());</span>
298         dispatchEnterOrLeaveEvent(eventNames().pointerleaveEvent);
<span class="line-added">299         capturingData.previousTarget = nullptr;</span>
300     }
301 }
302 #endif
303 
304 RefPtr&lt;PointerEvent&gt; PointerCaptureController::pointerEventForMouseEvent(const MouseEvent&amp; mouseEvent)
305 {
306     const auto&amp; type = mouseEvent.type();
307     const auto&amp; names = eventNames();
308 
309     auto iterator = m_activePointerIdsToCapturingData.find(mousePointerID);
310     ASSERT(iterator != m_activePointerIdsToCapturingData.end());
311     auto&amp; capturingData = iterator-&gt;value;
312 
313     short newButton = mouseEvent.button();
314     short button = (type == names.mousemoveEvent &amp;&amp; newButton == capturingData.previousMouseButton) ? -1 : newButton;
315 
316     // https://w3c.github.io/pointerevents/#chorded-button-interactions
317     // Some pointer devices, such as mouse or pen, support multiple buttons. In the Mouse Event model, each button
318     // press produces a mousedown and mouseup event. To better abstract this hardware difference and simplify
319     // cross-device input authoring, Pointer Events do not fire overlapping pointerdown and pointerup events
</pre>
<hr />
<pre>
369         if (iterator != m_activePointerIdsToCapturingData.end())
370             iterator-&gt;value.pointerIsPressed = isPointerdown;
371         return;
372     }
373 
374     if (!isPointerdown)
375         return;
376 
377     // https://w3c.github.io/pointerevents/#implicit-pointer-capture
378 
379     // Some input devices (such as touchscreens) implement a &quot;direct manipulation&quot; metaphor where a pointer is intended to act primarily on the UI
380     // element it became active upon (providing a physical illusion of direct contact, instead of indirect contact via a cursor that conceptually
381     // floats above the UI). Such devices are identified by the InputDeviceCapabilities.pointerMovementScrolls property and should have &quot;implicit
382     // pointer capture&quot; behavior as follows.
383 
384     // Direct manipulation devices should behave exactly as if setPointerCapture was called on the target element just before the invocation of any
385     // pointerdown listeners. The hasPointerCapture API may be used (eg. within any pointerdown listener) to determine whether this has occurred. If
386     // releasePointerCapture is not called for the pointer before the next pointer event is fired, then a gotpointercapture event will be dispatched
387     // to the target (as normal) indicating that capture is active.
388 
<span class="line-modified">389     auto&amp; capturingData = ensureCapturingDataForPointerEvent(event);</span>

390     capturingData.pointerIsPressed = true;

391     setPointerCapture(downcast&lt;Element&gt;(target), pointerId);
392 }
393 
<span class="line-added">394 PointerCaptureController::CapturingData&amp; PointerCaptureController::ensureCapturingDataForPointerEvent(const PointerEvent&amp; event)</span>
<span class="line-added">395 {</span>
<span class="line-added">396     return m_activePointerIdsToCapturingData.ensure(event.pointerId(), [&amp;event] {</span>
<span class="line-added">397         CapturingData capturingData;</span>
<span class="line-added">398         capturingData.pointerType = event.pointerType();</span>
<span class="line-added">399         return capturingData;</span>
<span class="line-added">400     }).iterator-&gt;value;</span>
<span class="line-added">401 }</span>
<span class="line-added">402 </span>
403 void PointerCaptureController::pointerEventWasDispatched(const PointerEvent&amp; event)
404 {
405     auto iterator = m_activePointerIdsToCapturingData.find(event.pointerId());
406     if (iterator != m_activePointerIdsToCapturingData.end()) {
407         auto&amp; capturingData = iterator-&gt;value;
408         capturingData.isPrimary = event.isPrimary();
409 
410         // Immediately after firing the pointerup or pointercancel events, a user agent MUST clear the pending pointer capture target
411         // override for the pointerId of the pointerup or pointercancel event that was just dispatched, and then run Process Pending
412         // Pointer Capture steps to fire lostpointercapture if necessary.
413         // https://w3c.github.io/pointerevents/#implicit-release-of-pointer-capture
414         if (event.type() == eventNames().pointerupEvent) {
415             capturingData.pendingTargetOverride = nullptr;
416             processPendingPointerCapture(event.pointerId());
417         }
418 
419         // If a mouse pointer has moved while it isn&#39;t pressed, make sure we reset the preventsCompatibilityMouseEvents flag since
420         // we could otherwise prevent compatibility mouse events while those are only supposed to be prevented while the pointer is pressed.
421         if (event.type() == eventNames().pointermoveEvent &amp;&amp; capturingData.pointerType == PointerEvent::mousePointerType() &amp;&amp; !capturingData.pointerIsPressed)
422             capturingData.preventsCompatibilityMouseEvents = false;
</pre>
<hr />
<pre>
441 
442     // https://w3c.github.io/pointerevents/#implicit-release-of-pointer-capture
443 
444     // Immediately after firing the pointerup or pointercancel events, a user agent MUST clear the pending pointer capture target
445     // override for the pointerId of the pointerup or pointercancel event that was just dispatched, and then run Process Pending
446     // Pointer Capture steps to fire lostpointercapture if necessary. After running Process Pending Pointer Capture steps, if the
447     // pointer supports hover, user agent MUST also send corresponding boundary events necessary to reflect the current position of
448     // the pointer with no capture.
449 
450     auto iterator = m_activePointerIdsToCapturingData.find(pointerId);
451     if (iterator == m_activePointerIdsToCapturingData.end())
452         return;
453 
454     auto&amp; capturingData = iterator-&gt;value;
455     if (capturingData.cancelled)
456         return;
457 
458     capturingData.pendingTargetOverride = nullptr;
459     capturingData.cancelled = true;
460 
<span class="line-added">461 #if ENABLE(TOUCH_EVENTS) &amp;&amp; PLATFORM(IOS_FAMILY)</span>
<span class="line-added">462     capturingData.previousTarget = nullptr;</span>
<span class="line-added">463 #endif</span>
<span class="line-added">464 </span>
465     auto&amp; target = capturingData.targetOverride;
466     if (!target)
467         target = m_page.mainFrame().eventHandler().hitTestResultAtPoint(documentPoint, HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::DisallowUserAgentShadowContent | HitTestRequest::AllowChildFrameContent).innerNonSharedElement();
468 
469     if (!target)
470         return;
471 
472     // After firing the pointercancel event, a user agent MUST also fire a pointer event named pointerout
473     // followed by firing a pointer event named pointerleave.
474     auto isPrimary = capturingData.isPrimary ? PointerEvent::IsPrimary::Yes : PointerEvent::IsPrimary::No;
475     auto cancelEvent = PointerEvent::create(eventNames().pointercancelEvent, pointerId, capturingData.pointerType, isPrimary);
476     target-&gt;dispatchEvent(cancelEvent);
477     target-&gt;dispatchEvent(PointerEvent::create(eventNames().pointeroutEvent, pointerId, capturingData.pointerType, isPrimary));
478     target-&gt;dispatchEvent(PointerEvent::create(eventNames().pointerleaveEvent, pointerId, capturingData.pointerType, isPrimary));
479     processPendingPointerCapture(pointerId);
480 }
481 
482 void PointerCaptureController::processPendingPointerCapture(PointerID pointerId)
483 {
484     auto iterator = m_activePointerIdsToCapturingData.find(pointerId);
</pre>
</td>
</tr>
</table>
<center><a href="PlugInClient.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PointerCaptureController.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderReplaced.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderReplaced.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderReplaced.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderReplaced.cpp
@@ -27,19 +27,22 @@
 #include "DocumentMarkerController.h"
 #include "FloatRoundedRect.h"
 #include "Frame.h"
 #include "GraphicsContext.h"
 #include "HTMLElement.h"
+#include "HTMLImageElement.h"
+#include "HTMLParserIdioms.h"
 #include "InlineElementBox.h"
 #include "LayoutRepainter.h"
 #include "RenderBlock.h"
 #include "RenderFragmentedFlow.h"
 #include "RenderImage.h"
 #include "RenderLayer.h"
 #include "RenderTheme.h"
 #include "RenderView.h"
 #include "RenderedDocumentMarker.h"
+#include "Settings.h"
 #include "VisiblePosition.h"
 #include <wtf/IsoMallocInlines.h>
 #include <wtf/StackStats.h>
 
 namespace WebCore {
@@ -435,13 +438,32 @@
     // If there's an embeddedContentBox() of a remote, referenced document available, this code-path should never be used.
     ASSERT(!embeddedContentBox());
     intrinsicSize = FloatSize(intrinsicLogicalWidth(), intrinsicLogicalHeight());
 
     // Figure out if we need to compute an intrinsic ratio.
-    if (intrinsicSize.isEmpty() || !hasAspectRatio())
+    if (!hasAspectRatio())
         return;
 
+    if (intrinsicSize.isEmpty()) {
+        if (!settings().aspectRatioOfImgFromWidthAndHeightEnabled())
+            return;
+
+        auto* node = element();
+        // The aspectRatioOfImgFromWidthAndHeight only applies to <img>.
+        if (!node || !is<HTMLImageElement>(*node) || !node->hasAttribute(HTMLNames::widthAttr) || !node->hasAttribute(HTMLNames::heightAttr))
+            return;
+
+        // We shouldn't override the aspect-ratio when the <img> element has an empty src attribute.
+        if (!is<RenderImage>(*this) || !downcast<RenderImage>(*this).cachedImage())
+            return;
+
+        intrinsicSize.setWidth(parseValidHTMLFloatingPointNumber(node->getAttribute(HTMLNames::widthAttr)).valueOr(0));
+        intrinsicSize.setHeight(parseValidHTMLFloatingPointNumber(node->getAttribute(HTMLNames::heightAttr)).valueOr(0));
+        if (intrinsicSize.isEmpty())
+            return;
+    }
+
     intrinsicRatio = intrinsicSize.width() / intrinsicSize.height();
 }
 
 LayoutUnit RenderReplaced::computeConstrainedLogicalWidth(ShouldComputePreferred shouldComputePreferred) const
 {
@@ -456,11 +478,13 @@
     LayoutUnit logicalWidth = containingBlock()->availableLogicalWidth();
 
     // This solves above equation for 'width' (== logicalWidth).
     LayoutUnit marginStart = minimumValueForLength(style().marginStart(), logicalWidth);
     LayoutUnit marginEnd = minimumValueForLength(style().marginEnd(), logicalWidth);
-    logicalWidth = std::max(0_lu, (logicalWidth - (marginStart + marginEnd + (size().width() - clientWidth()))));
+
+    // FIXME: This expression does not align with the comment above, which is quoting https://www.w3.org/TR/CSS22/visudet.html#blockwidth.
+    logicalWidth = std::max(0_lu, (logicalWidth - (marginStart + marginEnd + borderLeft() + borderRight())));
     return computeReplacedLogicalWidthRespectingMinMaxWidth(logicalWidth, shouldComputePreferred);
 }
 
 LayoutUnit RenderReplaced::computeReplacedLogicalWidth(ShouldComputePreferred shouldComputePreferred) const
 {
@@ -663,12 +687,12 @@
     if (state == SelectionNone)
         return false;
     if (state == SelectionInside)
         return true;
 
-    auto selectionStart = view().selection().startPosition();
-    auto selectionEnd = view().selection().endPosition();
+    auto selectionStart = view().selection().startOffset();
+    auto selectionEnd = view().selection().endOffset();
     if (state == SelectionStart)
         return !selectionStart;
 
     unsigned end = element()->hasChildNodes() ? element()->countChildNodes() : 1;
     if (state == SelectionEnd)

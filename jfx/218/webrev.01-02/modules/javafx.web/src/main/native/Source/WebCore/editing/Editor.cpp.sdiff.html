<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/editing/Editor.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="EditingStyle.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Editor.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/Editor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;Editor.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;
  31 #include &quot;AlternativeTextController.h&quot;
  32 #include &quot;ApplyStyleCommand.h&quot;
  33 #include &quot;CSSComputedStyleDeclaration.h&quot;
  34 #include &quot;CSSPropertyNames.h&quot;
  35 #include &quot;CSSValueList.h&quot;
  36 #include &quot;CSSValuePool.h&quot;
  37 #include &quot;CachedResourceLoader.h&quot;
  38 #include &quot;ChangeListTypeCommand.h&quot;
  39 #include &quot;ClipboardEvent.h&quot;
  40 #include &quot;CompositionEvent.h&quot;

  41 #include &quot;CreateLinkCommand.h&quot;
  42 #include &quot;CustomUndoStep.h&quot;
  43 #include &quot;DataTransfer.h&quot;
  44 #include &quot;DeleteSelectionCommand.h&quot;
  45 #include &quot;DictationAlternative.h&quot;
  46 #include &quot;DictationCommand.h&quot;
  47 #include &quot;DocumentFragment.h&quot;
  48 #include &quot;DocumentMarkerController.h&quot;
  49 #include &quot;Editing.h&quot;
  50 #include &quot;EditorClient.h&quot;
  51 #include &quot;EventHandler.h&quot;
  52 #include &quot;EventNames.h&quot;
  53 #include &quot;File.h&quot;
  54 #include &quot;FocusController.h&quot;
  55 #include &quot;FontAttributes.h&quot;
  56 #include &quot;Frame.h&quot;
  57 #include &quot;FrameLoader.h&quot;
  58 #include &quot;FrameTree.h&quot;
  59 #include &quot;FrameView.h&quot;
  60 #include &quot;GraphicsContext.h&quot;
</pre>
<hr />
<pre>
  69 #include &quot;HTMLOListElement.h&quot;
  70 #include &quot;HTMLQuoteElement.h&quot;
  71 #include &quot;HTMLSpanElement.h&quot;
  72 #include &quot;HTMLUListElement.h&quot;
  73 #include &quot;HitTestResult.h&quot;
  74 #include &quot;IndentOutdentCommand.h&quot;
  75 #include &quot;InputEvent.h&quot;
  76 #include &quot;InsertEditableImageCommand.h&quot;
  77 #include &quot;InsertListCommand.h&quot;
  78 #include &quot;InsertTextCommand.h&quot;
  79 #include &quot;KeyboardEvent.h&quot;
  80 #include &quot;Logging.h&quot;
  81 #include &quot;ModifySelectionListLevel.h&quot;
  82 #include &quot;NodeList.h&quot;
  83 #include &quot;NodeTraversal.h&quot;
  84 #include &quot;Page.h&quot;
  85 #include &quot;Pasteboard.h&quot;
  86 #include &quot;Range.h&quot;
  87 #include &quot;RemoveFormatCommand.h&quot;
  88 #include &quot;RenderBlock.h&quot;

  89 #include &quot;RenderTextControl.h&quot;
  90 #include &quot;RenderedDocumentMarker.h&quot;
  91 #include &quot;RenderedPosition.h&quot;
  92 #include &quot;ReplaceRangeWithTextCommand.h&quot;
  93 #include &quot;ReplaceSelectionCommand.h&quot;
  94 #include &quot;RuntimeEnabledFeatures.h&quot;
  95 #include &quot;SerializedAttachmentData.h&quot;
  96 #include &quot;Settings.h&quot;
  97 #include &quot;ShadowRoot.h&quot;
  98 #include &quot;SharedBuffer.h&quot;
  99 #include &quot;SimplifyMarkupCommand.h&quot;
 100 #include &quot;SpellChecker.h&quot;
 101 #include &quot;SpellingCorrectionCommand.h&quot;
 102 #include &quot;StaticPasteboard.h&quot;
 103 #include &quot;StyleProperties.h&quot;
 104 #include &quot;TelephoneNumberDetector.h&quot;
 105 #include &quot;Text.h&quot;
 106 #include &quot;TextCheckerClient.h&quot;
 107 #include &quot;TextCheckingHelper.h&quot;
 108 #include &quot;TextEvent.h&quot;
</pre>
<hr />
<pre>
 284 
 285 TextCheckerClient* Editor::textChecker() const
 286 {
 287     if (EditorClient* owner = client())
 288         return owner-&gt;textChecker();
 289     return 0;
 290 }
 291 
 292 void Editor::handleKeyboardEvent(KeyboardEvent&amp; event)
 293 {
 294     if (auto* client = this-&gt;client())
 295         client-&gt;handleKeyboardEvent(event);
 296 }
 297 
 298 void Editor::handleInputMethodKeydown(KeyboardEvent&amp; event)
 299 {
 300     if (auto* client = this-&gt;client())
 301         client-&gt;handleInputMethodKeydown(event);
 302 }
 303 






 304 bool Editor::handleTextEvent(TextEvent&amp; event)
 305 {
 306     LOG(Editing, &quot;Editor %p handleTextEvent (data %s)&quot;, this, event.data().utf8().data());
 307 
 308     // Default event handling for Drag and Drop will be handled by DragController
 309     // so we leave the event for it.
 310     if (event.isDrop())
 311         return false;
 312 
 313     if (event.isPaste()) {
 314         if (event.pastingFragment()) {
 315 #if PLATFORM(IOS_FAMILY)
 316             if (client()-&gt;performsTwoStepPaste(event.pastingFragment()))
 317                 return true;
 318 #endif
 319             replaceSelectionWithFragment(*event.pastingFragment(), SelectReplacement::No, event.shouldSmartReplace() ? SmartReplace::Yes : SmartReplace::No, event.shouldMatchStyle() ? MatchStyle::Yes : MatchStyle::No, EditAction::Paste, event.mailBlockquoteHandling());
 320         } else
 321             replaceSelectionWithText(event.data(), SelectReplacement::No, event.shouldSmartReplace() ? SmartReplace::Yes : SmartReplace::No, EditAction::Paste);
 322         return true;
 323     }
</pre>
<hr />
<pre>
 657     VisibleSelection selection = m_frame.selection().selection();
 658     if (selection.isNone() || !selection.isContentEditable())
 659         return;
 660 
 661     AccessibilityReplacedText replacedText;
 662     if (AXObjectCache::accessibilityEnabled() &amp;&amp; editingAction == EditAction::Paste)
 663         replacedText = AccessibilityReplacedText(selection);
 664 
 665     OptionSet&lt;ReplaceSelectionCommand::CommandOption&gt; options { ReplaceSelectionCommand::PreventNesting, ReplaceSelectionCommand::SanitizeFragment };
 666     if (selectReplacement == SelectReplacement::Yes)
 667         options.add(ReplaceSelectionCommand::SelectReplacement);
 668     if (smartReplace == SmartReplace::Yes)
 669         options.add(ReplaceSelectionCommand::SmartReplace);
 670     if (matchStyle == MatchStyle::Yes)
 671         options.add(ReplaceSelectionCommand::MatchStyle);
 672     if (mailBlockquoteHandling == MailBlockquoteHandling::IgnoreBlockquote)
 673         options.add(ReplaceSelectionCommand::IgnoreMailBlockquote);
 674 
 675     auto command = ReplaceSelectionCommand::create(document(), &amp;fragment, options, editingAction);
 676     command-&gt;apply();
<span class="line-modified"> 677     revealSelectionAfterEditingOperation();</span>






 678 
 679     selection = m_frame.selection().selection();
 680     if (selection.isInPasswordField())
 681         return;
 682 
 683     if (AXObjectCache::accessibilityEnabled() &amp;&amp; editingAction == EditAction::Paste) {
 684         String text = AccessibilityObject::stringForVisiblePositionRange(command-&gt;visibleSelectionForInsertedText());
 685         replacedText.postTextStateChangeNotification(document().existingAXObjectCache(), AXTextEditTypePaste, text, m_frame.selection().selection());
 686         command-&gt;composition()-&gt;setRangeDeletedByUnapply(replacedText.replacedRange());
 687     }
 688 
 689     if (!isContinuousSpellCheckingEnabled())
 690         return;
 691 
 692     Node* nodeToCheck = selection.rootEditableElement();
 693     if (!nodeToCheck)
 694         return;
 695 
 696     auto rangeToCheck = Range::create(document(), firstPositionInNode(nodeToCheck), lastPositionInNode(nodeToCheck));
 697     if (auto request = SpellCheckRequest::create(resolveTextCheckingTypeMask(*nodeToCheck, { TextCheckingType::Spelling, TextCheckingType::Grammar }), TextCheckingProcessBatch, rangeToCheck.copyRef(), rangeToCheck.copyRef(), rangeToCheck.copyRef()))
</pre>
<hr />
<pre>
1187     , m_spellChecker(makeUnique&lt;SpellChecker&gt;(frame))
1188     , m_alternativeTextController(makeUnique&lt;AlternativeTextController&gt;(frame))
1189     , m_editorUIUpdateTimer(*this, &amp;Editor::editorUIUpdateTimerFired)
1190 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
1191     , m_telephoneNumberDetectionUpdateTimer(*this, &amp;Editor::scanSelectionForTelephoneNumbers)
1192 #endif
1193 {
1194 }
1195 
1196 Editor::~Editor() = default;
1197 
1198 void Editor::clear()
1199 {
1200     m_lastEditCommand = nullptr;
1201     if (m_compositionNode) {
1202         m_compositionNode = nullptr;
1203         if (EditorClient* client = this-&gt;client())
1204             client-&gt;discardedComposition(&amp;m_frame);
1205     }
1206     m_customCompositionUnderlines.clear();

1207     m_shouldStyleWithCSS = false;
1208     m_defaultParagraphSeparator = EditorParagraphSeparatorIsDiv;
1209     m_mark = { };
1210     m_oldSelectionForEditorUIUpdate = { };
1211     m_editorUIUpdateTimer.stop();
1212 
1213 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
1214     m_telephoneNumberDetectionUpdateTimer.stop();
1215     m_detectedTelephoneNumberRanges.clear();
1216 #endif
1217 }
1218 
1219 bool Editor::insertText(const String&amp; text, Event* triggeringEvent, TextEventInputType inputType)
1220 {
1221     return m_frame.eventHandler().handleTextInputEvent(text, triggeringEvent, inputType);
1222 }
1223 
1224 bool Editor::insertTextForConfirmedComposition(const String&amp; text)
1225 {
1226     return m_frame.eventHandler().handleTextInputEvent(text, 0, TextEventInputComposition);
</pre>
<hr />
<pre>
1554 void Editor::copyImage(const HitTestResult&amp; result)
1555 {
1556     Element* element = result.innerNonSharedElement();
1557     if (!element)
1558         return;
1559 
1560     URL url = result.absoluteLinkURL();
1561     if (url.isEmpty())
1562         url = result.absoluteImageURL();
1563 
1564 #if !PLATFORM(WIN)
1565     writeImageToPasteboard(*Pasteboard::createForCopyAndPaste(), *element, url, result.altDisplayString());
1566 #else
1567     // FIXME: Delete after &lt;http://webkit.org/b/177618&gt; lands.
1568     Pasteboard::createForCopyAndPaste()-&gt;writeImage(*element, url, result.altDisplayString());
1569 #endif
1570 }
1571 
1572 #endif
1573 






































1574 bool Editor::isContinuousSpellCheckingEnabled() const
1575 {
1576     return client() &amp;&amp; client()-&gt;isContinuousSpellCheckingEnabled();
1577 }
1578 
1579 void Editor::toggleContinuousSpellChecking()
1580 {
1581     if (client())
1582         client()-&gt;toggleContinuousSpellChecking();
1583 }
1584 
1585 bool Editor::isGrammarCheckingEnabled()
1586 {
1587     return client() &amp;&amp; client()-&gt;isGrammarCheckingEnabled();
1588 }
1589 
1590 void Editor::toggleGrammarChecking()
1591 {
1592     if (client())
1593         client()-&gt;toggleGrammarChecking();
</pre>
<hr />
<pre>
1902         if (auto* editorClient = m_frame-&gt;editor().client())
1903             editorClient-&gt;didUpdateComposition();
1904     }
1905 
1906     Ref&lt;Frame&gt; m_frame;
1907     UserTypingGestureIndicator m_typingGestureIndicator;
1908 };
1909 
1910 void Editor::setComposition(const String&amp; text, SetCompositionMode mode)
1911 {
1912     ASSERT(mode == ConfirmComposition || mode == CancelComposition);
1913     SetCompositionScope setCompositionScope(m_frame);
1914 
1915     if (mode == CancelComposition)
1916         ASSERT(text == emptyString());
1917     else
1918         selectComposition();
1919 
1920     m_compositionNode = nullptr;
1921     m_customCompositionUnderlines.clear();

1922 
1923     if (m_frame.selection().isNone())
1924         return;
1925 
1926     // Always delete the current composition before inserting the finalized composition text if we&#39;re confirming our composition.
1927     // Our default behavior (if the beforeinput event is not prevented) is to insert the finalized composition text back in.
1928     // We pass TypingCommand::TextCompositionPending here to indicate that we are deleting the pending composition.
1929     if (mode != CancelComposition)
1930         TypingCommand::deleteSelection(document(), 0, TypingCommand::TextCompositionPending);
1931 
1932     insertTextForConfirmedComposition(text);
1933 
1934     if (auto* target = document().focusedElement())
1935         target-&gt;dispatchEvent(CompositionEvent::create(eventNames().compositionendEvent, document().windowProxy(), text));
1936 
1937     if (mode == CancelComposition) {
1938         // An open typing command that disagrees about current selection would cause issues with typing later on.
1939         TypingCommand::closeTyping(&amp;m_frame);
1940     }
1941 }
1942 
<span class="line-modified">1943 void Editor::setComposition(const String&amp; text, const Vector&lt;CompositionUnderline&gt;&amp; underlines, unsigned selectionStart, unsigned selectionEnd)</span>
1944 {
1945     SetCompositionScope setCompositionScope(m_frame);
1946 
1947     // Updates styles before setting selection for composition to prevent
1948     // inserting the previous composition text into text nodes oddly.
1949     // See https://bugs.webkit.org/show_bug.cgi?id=46868
1950     document().updateStyleIfNeeded();
1951 
1952     selectComposition();
1953 
1954     if (m_frame.selection().isNone())
1955         return;
1956 
1957     String originalText = selectedText();
1958     bool isStartingToRecomposeExistingRange = !text.isEmpty() &amp;&amp; selectionStart &lt; selectionEnd &amp;&amp; !hasComposition();
1959     if (isStartingToRecomposeExistingRange) {
1960         // We pass TypingCommand::TextCompositionFinal here to indicate that we are removing composition text that has been finalized.
1961         TypingCommand::deleteSelection(document(), 0, TypingCommand::TextCompositionFinal);
1962         const VisibleSelection&amp; currentSelection = m_frame.selection().selection();
1963         if (currentSelection.isRange()) {
</pre>
<hr />
<pre>
1995                 target-&gt;dispatchEvent(CompositionEvent::create(eventNames().compositionstartEvent, document().windowProxy(), originalText));
1996                 event = CompositionEvent::create(eventNames().compositionupdateEvent, document().windowProxy(), text);
1997             }
1998         } else if (!text.isEmpty())
1999             event = CompositionEvent::create(eventNames().compositionupdateEvent, document().windowProxy(), text);
2000 
2001         if (event)
2002             target-&gt;dispatchEvent(*event);
2003     }
2004 
2005     // If text is empty, then delete the old composition here.  If text is non-empty, InsertTextCommand::input
2006     // will delete the old composition with an optimized replace operation.
2007     if (text.isEmpty()) {
2008         TypingCommand::deleteSelection(document(), TypingCommand::PreventSpellChecking, TypingCommand::TextCompositionPending);
2009         if (target)
2010             target-&gt;dispatchEvent(CompositionEvent::create(eventNames().compositionendEvent, document().windowProxy(), text));
2011     }
2012 
2013     m_compositionNode = nullptr;
2014     m_customCompositionUnderlines.clear();

2015 
2016     if (!text.isEmpty()) {
2017         TypingCommand::insertText(document(), text, TypingCommand::SelectInsertedText | TypingCommand::PreventSpellChecking, TypingCommand::TextCompositionPending);
2018 
2019         // Find out what node has the composition now.
2020         Position base = m_frame.selection().selection().base().downstream();
2021         Position extent = m_frame.selection().selection().extent();
2022         Node* baseNode = base.deprecatedNode();
2023         unsigned baseOffset = base.deprecatedEditingOffset();
2024         Node* extentNode = extent.deprecatedNode();
2025         unsigned extentOffset = extent.deprecatedEditingOffset();
2026 
2027         if (is&lt;Text&gt;(baseNode) &amp;&amp; baseNode == extentNode &amp;&amp; baseOffset + text.length() == extentOffset) {
2028             m_compositionNode = downcast&lt;Text&gt;(baseNode);
2029             m_compositionStart = baseOffset;
2030             m_compositionEnd = extentOffset;
2031             m_customCompositionUnderlines = underlines;
2032             for (auto&amp; underline : m_customCompositionUnderlines) {
2033                 underline.startOffset += baseOffset;
2034                 underline.endOffset += baseOffset;
2035             }





2036             if (baseNode-&gt;renderer())
2037                 baseNode-&gt;renderer()-&gt;repaint();
2038 
2039             unsigned start = std::min(baseOffset + selectionStart, extentOffset);
2040             unsigned end = std::min(std::max(start, baseOffset + selectionEnd), extentOffset);
2041             auto selectedRange = Range::create(baseNode-&gt;document(), baseNode, start, baseNode, end);
2042             m_frame.selection().setSelectedRange(selectedRange.ptr(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::No);
2043         }
2044     }
2045 
2046 #if PLATFORM(IOS_FAMILY)
2047     client()-&gt;stopDelayingAndCoalescingContentChangeNotifications();
2048 #endif
2049 }
2050 
2051 void Editor::ignoreSpelling()
2052 {
2053     if (!client())
2054         return;
2055 
</pre>
<hr />
<pre>
3558 }
3559 #endif
3560 
3561 void Editor::respondToChangedSelection(const VisibleSelection&amp;, OptionSet&lt;FrameSelection::SetSelectionOption&gt; options)
3562 {
3563 #if PLATFORM(IOS_FAMILY)
3564     // FIXME: Should suppress selection change notifications during a composition change &lt;https://webkit.org/b/38830&gt;
3565     if (m_ignoreSelectionChanges)
3566         return;
3567 #endif
3568 
3569     if (client())
3570         client()-&gt;respondToChangedSelection(&amp;m_frame);
3571 
3572 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
3573     if (shouldDetectTelephoneNumbers())
3574         m_telephoneNumberDetectionUpdateTimer.startOneShot(0_s);
3575 #endif
3576 
3577     setStartNewKillRingSequence(true);

3578 
3579     if (m_editorUIUpdateTimer.isActive())
3580         return;
3581 
3582     // Don&#39;t check spelling and grammar if the change of selection is triggered by spelling correction itself.
3583     m_editorUIUpdateTimerShouldCheckSpellingAndGrammar = options.contains(FrameSelection::CloseTyping) &amp;&amp; !options.contains(FrameSelection::SpellCorrectionTriggered);
3584     m_editorUIUpdateTimerWasTriggeredByDictation = options.contains(FrameSelection::DictationTriggered);
3585     scheduleEditorUIUpdate();
3586 }
3587 
3588 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
3589 
3590 bool Editor::shouldDetectTelephoneNumbers()
3591 {
3592     if (!m_frame.document())
3593         return false;
3594     return document().isTelephoneNumberParsingEnabled() &amp;&amp; TelephoneNumberDetector::isSupported();
3595 }
3596 
3597 void Editor::scanSelectionForTelephoneNumbers()
</pre>
</td>
<td>
<hr />
<pre>
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;Editor.h&quot;
  29 
  30 #include &quot;AXObjectCache.h&quot;
  31 #include &quot;AlternativeTextController.h&quot;
  32 #include &quot;ApplyStyleCommand.h&quot;
  33 #include &quot;CSSComputedStyleDeclaration.h&quot;
  34 #include &quot;CSSPropertyNames.h&quot;
  35 #include &quot;CSSValueList.h&quot;
  36 #include &quot;CSSValuePool.h&quot;
  37 #include &quot;CachedResourceLoader.h&quot;
  38 #include &quot;ChangeListTypeCommand.h&quot;
  39 #include &quot;ClipboardEvent.h&quot;
  40 #include &quot;CompositionEvent.h&quot;
<span class="line-added">  41 #include &quot;CompositionHighlight.h&quot;</span>
  42 #include &quot;CreateLinkCommand.h&quot;
  43 #include &quot;CustomUndoStep.h&quot;
  44 #include &quot;DataTransfer.h&quot;
  45 #include &quot;DeleteSelectionCommand.h&quot;
  46 #include &quot;DictationAlternative.h&quot;
  47 #include &quot;DictationCommand.h&quot;
  48 #include &quot;DocumentFragment.h&quot;
  49 #include &quot;DocumentMarkerController.h&quot;
  50 #include &quot;Editing.h&quot;
  51 #include &quot;EditorClient.h&quot;
  52 #include &quot;EventHandler.h&quot;
  53 #include &quot;EventNames.h&quot;
  54 #include &quot;File.h&quot;
  55 #include &quot;FocusController.h&quot;
  56 #include &quot;FontAttributes.h&quot;
  57 #include &quot;Frame.h&quot;
  58 #include &quot;FrameLoader.h&quot;
  59 #include &quot;FrameTree.h&quot;
  60 #include &quot;FrameView.h&quot;
  61 #include &quot;GraphicsContext.h&quot;
</pre>
<hr />
<pre>
  70 #include &quot;HTMLOListElement.h&quot;
  71 #include &quot;HTMLQuoteElement.h&quot;
  72 #include &quot;HTMLSpanElement.h&quot;
  73 #include &quot;HTMLUListElement.h&quot;
  74 #include &quot;HitTestResult.h&quot;
  75 #include &quot;IndentOutdentCommand.h&quot;
  76 #include &quot;InputEvent.h&quot;
  77 #include &quot;InsertEditableImageCommand.h&quot;
  78 #include &quot;InsertListCommand.h&quot;
  79 #include &quot;InsertTextCommand.h&quot;
  80 #include &quot;KeyboardEvent.h&quot;
  81 #include &quot;Logging.h&quot;
  82 #include &quot;ModifySelectionListLevel.h&quot;
  83 #include &quot;NodeList.h&quot;
  84 #include &quot;NodeTraversal.h&quot;
  85 #include &quot;Page.h&quot;
  86 #include &quot;Pasteboard.h&quot;
  87 #include &quot;Range.h&quot;
  88 #include &quot;RemoveFormatCommand.h&quot;
  89 #include &quot;RenderBlock.h&quot;
<span class="line-added">  90 #include &quot;RenderLayer.h&quot;</span>
  91 #include &quot;RenderTextControl.h&quot;
  92 #include &quot;RenderedDocumentMarker.h&quot;
  93 #include &quot;RenderedPosition.h&quot;
  94 #include &quot;ReplaceRangeWithTextCommand.h&quot;
  95 #include &quot;ReplaceSelectionCommand.h&quot;
  96 #include &quot;RuntimeEnabledFeatures.h&quot;
  97 #include &quot;SerializedAttachmentData.h&quot;
  98 #include &quot;Settings.h&quot;
  99 #include &quot;ShadowRoot.h&quot;
 100 #include &quot;SharedBuffer.h&quot;
 101 #include &quot;SimplifyMarkupCommand.h&quot;
 102 #include &quot;SpellChecker.h&quot;
 103 #include &quot;SpellingCorrectionCommand.h&quot;
 104 #include &quot;StaticPasteboard.h&quot;
 105 #include &quot;StyleProperties.h&quot;
 106 #include &quot;TelephoneNumberDetector.h&quot;
 107 #include &quot;Text.h&quot;
 108 #include &quot;TextCheckerClient.h&quot;
 109 #include &quot;TextCheckingHelper.h&quot;
 110 #include &quot;TextEvent.h&quot;
</pre>
<hr />
<pre>
 286 
 287 TextCheckerClient* Editor::textChecker() const
 288 {
 289     if (EditorClient* owner = client())
 290         return owner-&gt;textChecker();
 291     return 0;
 292 }
 293 
 294 void Editor::handleKeyboardEvent(KeyboardEvent&amp; event)
 295 {
 296     if (auto* client = this-&gt;client())
 297         client-&gt;handleKeyboardEvent(event);
 298 }
 299 
 300 void Editor::handleInputMethodKeydown(KeyboardEvent&amp; event)
 301 {
 302     if (auto* client = this-&gt;client())
 303         client-&gt;handleInputMethodKeydown(event);
 304 }
 305 
<span class="line-added"> 306 void Editor::didDispatchInputMethodKeydown(KeyboardEvent&amp; event)</span>
<span class="line-added"> 307 {</span>
<span class="line-added"> 308     if (auto* client = this-&gt;client())</span>
<span class="line-added"> 309         client-&gt;didDispatchInputMethodKeydown(event);</span>
<span class="line-added"> 310 }</span>
<span class="line-added"> 311 </span>
 312 bool Editor::handleTextEvent(TextEvent&amp; event)
 313 {
 314     LOG(Editing, &quot;Editor %p handleTextEvent (data %s)&quot;, this, event.data().utf8().data());
 315 
 316     // Default event handling for Drag and Drop will be handled by DragController
 317     // so we leave the event for it.
 318     if (event.isDrop())
 319         return false;
 320 
 321     if (event.isPaste()) {
 322         if (event.pastingFragment()) {
 323 #if PLATFORM(IOS_FAMILY)
 324             if (client()-&gt;performsTwoStepPaste(event.pastingFragment()))
 325                 return true;
 326 #endif
 327             replaceSelectionWithFragment(*event.pastingFragment(), SelectReplacement::No, event.shouldSmartReplace() ? SmartReplace::Yes : SmartReplace::No, event.shouldMatchStyle() ? MatchStyle::Yes : MatchStyle::No, EditAction::Paste, event.mailBlockquoteHandling());
 328         } else
 329             replaceSelectionWithText(event.data(), SelectReplacement::No, event.shouldSmartReplace() ? SmartReplace::Yes : SmartReplace::No, EditAction::Paste);
 330         return true;
 331     }
</pre>
<hr />
<pre>
 665     VisibleSelection selection = m_frame.selection().selection();
 666     if (selection.isNone() || !selection.isContentEditable())
 667         return;
 668 
 669     AccessibilityReplacedText replacedText;
 670     if (AXObjectCache::accessibilityEnabled() &amp;&amp; editingAction == EditAction::Paste)
 671         replacedText = AccessibilityReplacedText(selection);
 672 
 673     OptionSet&lt;ReplaceSelectionCommand::CommandOption&gt; options { ReplaceSelectionCommand::PreventNesting, ReplaceSelectionCommand::SanitizeFragment };
 674     if (selectReplacement == SelectReplacement::Yes)
 675         options.add(ReplaceSelectionCommand::SelectReplacement);
 676     if (smartReplace == SmartReplace::Yes)
 677         options.add(ReplaceSelectionCommand::SmartReplace);
 678     if (matchStyle == MatchStyle::Yes)
 679         options.add(ReplaceSelectionCommand::MatchStyle);
 680     if (mailBlockquoteHandling == MailBlockquoteHandling::IgnoreBlockquote)
 681         options.add(ReplaceSelectionCommand::IgnoreMailBlockquote);
 682 
 683     auto command = ReplaceSelectionCommand::create(document(), &amp;fragment, options, editingAction);
 684     command-&gt;apply();
<span class="line-modified"> 685 </span>
<span class="line-added"> 686     m_imageElementsToLoadBeforeRevealingSelection.clear();</span>
<span class="line-added"> 687     if (auto insertionRange = command-&gt;insertedContentRange())</span>
<span class="line-added"> 688         m_imageElementsToLoadBeforeRevealingSelection = visibleImageElementsInRangeWithNonLoadedImages(*insertionRange);</span>
<span class="line-added"> 689 </span>
<span class="line-added"> 690     if (m_imageElementsToLoadBeforeRevealingSelection.isEmpty())</span>
<span class="line-added"> 691         revealSelectionAfterEditingOperation();</span>
 692 
 693     selection = m_frame.selection().selection();
 694     if (selection.isInPasswordField())
 695         return;
 696 
 697     if (AXObjectCache::accessibilityEnabled() &amp;&amp; editingAction == EditAction::Paste) {
 698         String text = AccessibilityObject::stringForVisiblePositionRange(command-&gt;visibleSelectionForInsertedText());
 699         replacedText.postTextStateChangeNotification(document().existingAXObjectCache(), AXTextEditTypePaste, text, m_frame.selection().selection());
 700         command-&gt;composition()-&gt;setRangeDeletedByUnapply(replacedText.replacedRange());
 701     }
 702 
 703     if (!isContinuousSpellCheckingEnabled())
 704         return;
 705 
 706     Node* nodeToCheck = selection.rootEditableElement();
 707     if (!nodeToCheck)
 708         return;
 709 
 710     auto rangeToCheck = Range::create(document(), firstPositionInNode(nodeToCheck), lastPositionInNode(nodeToCheck));
 711     if (auto request = SpellCheckRequest::create(resolveTextCheckingTypeMask(*nodeToCheck, { TextCheckingType::Spelling, TextCheckingType::Grammar }), TextCheckingProcessBatch, rangeToCheck.copyRef(), rangeToCheck.copyRef(), rangeToCheck.copyRef()))
</pre>
<hr />
<pre>
1201     , m_spellChecker(makeUnique&lt;SpellChecker&gt;(frame))
1202     , m_alternativeTextController(makeUnique&lt;AlternativeTextController&gt;(frame))
1203     , m_editorUIUpdateTimer(*this, &amp;Editor::editorUIUpdateTimerFired)
1204 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
1205     , m_telephoneNumberDetectionUpdateTimer(*this, &amp;Editor::scanSelectionForTelephoneNumbers)
1206 #endif
1207 {
1208 }
1209 
1210 Editor::~Editor() = default;
1211 
1212 void Editor::clear()
1213 {
1214     m_lastEditCommand = nullptr;
1215     if (m_compositionNode) {
1216         m_compositionNode = nullptr;
1217         if (EditorClient* client = this-&gt;client())
1218             client-&gt;discardedComposition(&amp;m_frame);
1219     }
1220     m_customCompositionUnderlines.clear();
<span class="line-added">1221     m_customCompositionHighlights.clear();</span>
1222     m_shouldStyleWithCSS = false;
1223     m_defaultParagraphSeparator = EditorParagraphSeparatorIsDiv;
1224     m_mark = { };
1225     m_oldSelectionForEditorUIUpdate = { };
1226     m_editorUIUpdateTimer.stop();
1227 
1228 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
1229     m_telephoneNumberDetectionUpdateTimer.stop();
1230     m_detectedTelephoneNumberRanges.clear();
1231 #endif
1232 }
1233 
1234 bool Editor::insertText(const String&amp; text, Event* triggeringEvent, TextEventInputType inputType)
1235 {
1236     return m_frame.eventHandler().handleTextInputEvent(text, triggeringEvent, inputType);
1237 }
1238 
1239 bool Editor::insertTextForConfirmedComposition(const String&amp; text)
1240 {
1241     return m_frame.eventHandler().handleTextInputEvent(text, 0, TextEventInputComposition);
</pre>
<hr />
<pre>
1569 void Editor::copyImage(const HitTestResult&amp; result)
1570 {
1571     Element* element = result.innerNonSharedElement();
1572     if (!element)
1573         return;
1574 
1575     URL url = result.absoluteLinkURL();
1576     if (url.isEmpty())
1577         url = result.absoluteImageURL();
1578 
1579 #if !PLATFORM(WIN)
1580     writeImageToPasteboard(*Pasteboard::createForCopyAndPaste(), *element, url, result.altDisplayString());
1581 #else
1582     // FIXME: Delete after &lt;http://webkit.org/b/177618&gt; lands.
1583     Pasteboard::createForCopyAndPaste()-&gt;writeImage(*element, url, result.altDisplayString());
1584 #endif
1585 }
1586 
1587 #endif
1588 
<span class="line-added">1589 void Editor::revealSelectionIfNeededAfterLoadingImageForElement(HTMLImageElement&amp; element)</span>
<span class="line-added">1590 {</span>
<span class="line-added">1591     if (m_imageElementsToLoadBeforeRevealingSelection.isEmpty())</span>
<span class="line-added">1592         return;</span>
<span class="line-added">1593 </span>
<span class="line-added">1594     if (!m_imageElementsToLoadBeforeRevealingSelection.remove(&amp;element))</span>
<span class="line-added">1595         return;</span>
<span class="line-added">1596 </span>
<span class="line-added">1597     if (!m_imageElementsToLoadBeforeRevealingSelection.isEmpty())</span>
<span class="line-added">1598         return;</span>
<span class="line-added">1599 </span>
<span class="line-added">1600     // FIXME: This should be queued as a task for the next rendering update.</span>
<span class="line-added">1601     document().updateLayout();</span>
<span class="line-added">1602     revealSelectionAfterEditingOperation();</span>
<span class="line-added">1603 }</span>
<span class="line-added">1604 </span>
<span class="line-added">1605 void Editor::renderLayerDidScroll(const RenderLayer&amp; layer)</span>
<span class="line-added">1606 {</span>
<span class="line-added">1607     if (m_imageElementsToLoadBeforeRevealingSelection.isEmpty())</span>
<span class="line-added">1608         return;</span>
<span class="line-added">1609 </span>
<span class="line-added">1610     auto startContainer = makeRefPtr(m_frame.selection().selection().start().containerNode());</span>
<span class="line-added">1611     if (!startContainer)</span>
<span class="line-added">1612         return;</span>
<span class="line-added">1613 </span>
<span class="line-added">1614     auto* startContainerRenderer = startContainer-&gt;renderer();</span>
<span class="line-added">1615     if (!startContainerRenderer)</span>
<span class="line-added">1616         return;</span>
<span class="line-added">1617 </span>
<span class="line-added">1618     // FIXME: Ideally, this would also cancel deferred selection revealing if the selection is inside a subframe and a parent frame is scrolled.</span>
<span class="line-added">1619     for (auto* enclosingLayer = startContainerRenderer-&gt;enclosingLayer(); enclosingLayer; enclosingLayer = enclosingLayer-&gt;parent()) {</span>
<span class="line-added">1620         if (enclosingLayer == &amp;layer) {</span>
<span class="line-added">1621             m_imageElementsToLoadBeforeRevealingSelection.clear();</span>
<span class="line-added">1622             break;</span>
<span class="line-added">1623         }</span>
<span class="line-added">1624     }</span>
<span class="line-added">1625 }</span>
<span class="line-added">1626 </span>
1627 bool Editor::isContinuousSpellCheckingEnabled() const
1628 {
1629     return client() &amp;&amp; client()-&gt;isContinuousSpellCheckingEnabled();
1630 }
1631 
1632 void Editor::toggleContinuousSpellChecking()
1633 {
1634     if (client())
1635         client()-&gt;toggleContinuousSpellChecking();
1636 }
1637 
1638 bool Editor::isGrammarCheckingEnabled()
1639 {
1640     return client() &amp;&amp; client()-&gt;isGrammarCheckingEnabled();
1641 }
1642 
1643 void Editor::toggleGrammarChecking()
1644 {
1645     if (client())
1646         client()-&gt;toggleGrammarChecking();
</pre>
<hr />
<pre>
1955         if (auto* editorClient = m_frame-&gt;editor().client())
1956             editorClient-&gt;didUpdateComposition();
1957     }
1958 
1959     Ref&lt;Frame&gt; m_frame;
1960     UserTypingGestureIndicator m_typingGestureIndicator;
1961 };
1962 
1963 void Editor::setComposition(const String&amp; text, SetCompositionMode mode)
1964 {
1965     ASSERT(mode == ConfirmComposition || mode == CancelComposition);
1966     SetCompositionScope setCompositionScope(m_frame);
1967 
1968     if (mode == CancelComposition)
1969         ASSERT(text == emptyString());
1970     else
1971         selectComposition();
1972 
1973     m_compositionNode = nullptr;
1974     m_customCompositionUnderlines.clear();
<span class="line-added">1975     m_customCompositionHighlights.clear();</span>
1976 
1977     if (m_frame.selection().isNone())
1978         return;
1979 
1980     // Always delete the current composition before inserting the finalized composition text if we&#39;re confirming our composition.
1981     // Our default behavior (if the beforeinput event is not prevented) is to insert the finalized composition text back in.
1982     // We pass TypingCommand::TextCompositionPending here to indicate that we are deleting the pending composition.
1983     if (mode != CancelComposition)
1984         TypingCommand::deleteSelection(document(), 0, TypingCommand::TextCompositionPending);
1985 
1986     insertTextForConfirmedComposition(text);
1987 
1988     if (auto* target = document().focusedElement())
1989         target-&gt;dispatchEvent(CompositionEvent::create(eventNames().compositionendEvent, document().windowProxy(), text));
1990 
1991     if (mode == CancelComposition) {
1992         // An open typing command that disagrees about current selection would cause issues with typing later on.
1993         TypingCommand::closeTyping(&amp;m_frame);
1994     }
1995 }
1996 
<span class="line-modified">1997 void Editor::setComposition(const String&amp; text, const Vector&lt;CompositionUnderline&gt;&amp; underlines, const Vector&lt;CompositionHighlight&gt;&amp; highlights, unsigned selectionStart, unsigned selectionEnd)</span>
1998 {
1999     SetCompositionScope setCompositionScope(m_frame);
2000 
2001     // Updates styles before setting selection for composition to prevent
2002     // inserting the previous composition text into text nodes oddly.
2003     // See https://bugs.webkit.org/show_bug.cgi?id=46868
2004     document().updateStyleIfNeeded();
2005 
2006     selectComposition();
2007 
2008     if (m_frame.selection().isNone())
2009         return;
2010 
2011     String originalText = selectedText();
2012     bool isStartingToRecomposeExistingRange = !text.isEmpty() &amp;&amp; selectionStart &lt; selectionEnd &amp;&amp; !hasComposition();
2013     if (isStartingToRecomposeExistingRange) {
2014         // We pass TypingCommand::TextCompositionFinal here to indicate that we are removing composition text that has been finalized.
2015         TypingCommand::deleteSelection(document(), 0, TypingCommand::TextCompositionFinal);
2016         const VisibleSelection&amp; currentSelection = m_frame.selection().selection();
2017         if (currentSelection.isRange()) {
</pre>
<hr />
<pre>
2049                 target-&gt;dispatchEvent(CompositionEvent::create(eventNames().compositionstartEvent, document().windowProxy(), originalText));
2050                 event = CompositionEvent::create(eventNames().compositionupdateEvent, document().windowProxy(), text);
2051             }
2052         } else if (!text.isEmpty())
2053             event = CompositionEvent::create(eventNames().compositionupdateEvent, document().windowProxy(), text);
2054 
2055         if (event)
2056             target-&gt;dispatchEvent(*event);
2057     }
2058 
2059     // If text is empty, then delete the old composition here.  If text is non-empty, InsertTextCommand::input
2060     // will delete the old composition with an optimized replace operation.
2061     if (text.isEmpty()) {
2062         TypingCommand::deleteSelection(document(), TypingCommand::PreventSpellChecking, TypingCommand::TextCompositionPending);
2063         if (target)
2064             target-&gt;dispatchEvent(CompositionEvent::create(eventNames().compositionendEvent, document().windowProxy(), text));
2065     }
2066 
2067     m_compositionNode = nullptr;
2068     m_customCompositionUnderlines.clear();
<span class="line-added">2069     m_customCompositionHighlights.clear();</span>
2070 
2071     if (!text.isEmpty()) {
2072         TypingCommand::insertText(document(), text, TypingCommand::SelectInsertedText | TypingCommand::PreventSpellChecking, TypingCommand::TextCompositionPending);
2073 
2074         // Find out what node has the composition now.
2075         Position base = m_frame.selection().selection().base().downstream();
2076         Position extent = m_frame.selection().selection().extent();
2077         Node* baseNode = base.deprecatedNode();
2078         unsigned baseOffset = base.deprecatedEditingOffset();
2079         Node* extentNode = extent.deprecatedNode();
2080         unsigned extentOffset = extent.deprecatedEditingOffset();
2081 
2082         if (is&lt;Text&gt;(baseNode) &amp;&amp; baseNode == extentNode &amp;&amp; baseOffset + text.length() == extentOffset) {
2083             m_compositionNode = downcast&lt;Text&gt;(baseNode);
2084             m_compositionStart = baseOffset;
2085             m_compositionEnd = extentOffset;
2086             m_customCompositionUnderlines = underlines;
2087             for (auto&amp; underline : m_customCompositionUnderlines) {
2088                 underline.startOffset += baseOffset;
2089                 underline.endOffset += baseOffset;
2090             }
<span class="line-added">2091             m_customCompositionHighlights = highlights;</span>
<span class="line-added">2092             for (auto&amp; highlight : m_customCompositionHighlights) {</span>
<span class="line-added">2093                 highlight.startOffset += baseOffset;</span>
<span class="line-added">2094                 highlight.endOffset += baseOffset;</span>
<span class="line-added">2095             }</span>
2096             if (baseNode-&gt;renderer())
2097                 baseNode-&gt;renderer()-&gt;repaint();
2098 
2099             unsigned start = std::min(baseOffset + selectionStart, extentOffset);
2100             unsigned end = std::min(std::max(start, baseOffset + selectionEnd), extentOffset);
2101             auto selectedRange = Range::create(baseNode-&gt;document(), baseNode, start, baseNode, end);
2102             m_frame.selection().setSelectedRange(selectedRange.ptr(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::No);
2103         }
2104     }
2105 
2106 #if PLATFORM(IOS_FAMILY)
2107     client()-&gt;stopDelayingAndCoalescingContentChangeNotifications();
2108 #endif
2109 }
2110 
2111 void Editor::ignoreSpelling()
2112 {
2113     if (!client())
2114         return;
2115 
</pre>
<hr />
<pre>
3618 }
3619 #endif
3620 
3621 void Editor::respondToChangedSelection(const VisibleSelection&amp;, OptionSet&lt;FrameSelection::SetSelectionOption&gt; options)
3622 {
3623 #if PLATFORM(IOS_FAMILY)
3624     // FIXME: Should suppress selection change notifications during a composition change &lt;https://webkit.org/b/38830&gt;
3625     if (m_ignoreSelectionChanges)
3626         return;
3627 #endif
3628 
3629     if (client())
3630         client()-&gt;respondToChangedSelection(&amp;m_frame);
3631 
3632 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
3633     if (shouldDetectTelephoneNumbers())
3634         m_telephoneNumberDetectionUpdateTimer.startOneShot(0_s);
3635 #endif
3636 
3637     setStartNewKillRingSequence(true);
<span class="line-added">3638     m_imageElementsToLoadBeforeRevealingSelection.clear();</span>
3639 
3640     if (m_editorUIUpdateTimer.isActive())
3641         return;
3642 
3643     // Don&#39;t check spelling and grammar if the change of selection is triggered by spelling correction itself.
3644     m_editorUIUpdateTimerShouldCheckSpellingAndGrammar = options.contains(FrameSelection::CloseTyping) &amp;&amp; !options.contains(FrameSelection::SpellCorrectionTriggered);
3645     m_editorUIUpdateTimerWasTriggeredByDictation = options.contains(FrameSelection::DictationTriggered);
3646     scheduleEditorUIUpdate();
3647 }
3648 
3649 #if ENABLE(TELEPHONE_NUMBER_DETECTION) &amp;&amp; !PLATFORM(IOS_FAMILY)
3650 
3651 bool Editor::shouldDetectTelephoneNumbers()
3652 {
3653     if (!m_frame.document())
3654         return false;
3655     return document().isTelephoneNumberParsingEnabled() &amp;&amp; TelephoneNumberDetector::isSupported();
3656 }
3657 
3658 void Editor::scanSelectionForTelephoneNumbers()
</pre>
</td>
</tr>
</table>
<center><a href="EditingStyle.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Editor.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
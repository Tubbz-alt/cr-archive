<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/ElementAndTextDescendantIterator.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;Element.h&quot;
 29 #include &quot;ElementIteratorAssertions.h&quot;
 30 #include &quot;Text.h&quot;
 31 #include &lt;wtf/Vector.h&gt;
 32 
 33 namespace WebCore {
 34 
 35 class ElementAndTextDescendantIterator {
 36 public:
 37     ElementAndTextDescendantIterator();
 38     enum FirstChildTag { FirstChild };
 39     ElementAndTextDescendantIterator(ContainerNode&amp; root, FirstChildTag);
 40     ElementAndTextDescendantIterator(ContainerNode&amp; root, Node* current);
 41 
 42     ElementAndTextDescendantIterator&amp; operator++() { return traverseNext(); }
 43 
 44     Node&amp; operator*();
 45     Node* operator-&gt;();
 46     const Node&amp; operator*() const;
 47     const Node* operator-&gt;() const;
 48 
 49     bool operator==(const ElementAndTextDescendantIterator&amp; other) const;
 50     bool operator!=(const ElementAndTextDescendantIterator&amp; other) const;
 51 
 52     bool operator!() const { return !m_depth; }
 53     explicit operator bool() const { return m_depth; }
 54 
 55     void dropAssertions();
 56 
 57     ElementAndTextDescendantIterator&amp; traverseNext();
 58     ElementAndTextDescendantIterator&amp; traverseNextSkippingChildren();
 59     ElementAndTextDescendantIterator&amp; traverseNextSibling();
 60     ElementAndTextDescendantIterator&amp; traversePreviousSibling();
 61 
 62     unsigned depth() const { return m_depth; }
 63 
 64 private:
 65     static bool isElementOrText(const Node&amp; node) { return is&lt;Element&gt;(node) || is&lt;Text&gt;(node); }
 66     static Node* firstChild(Node&amp;);
 67     static Node* nextSibling(Node&amp;);
 68     static Node* previousSibling(Node&amp;);
 69 
 70     void popAncestorSiblingStack();
 71 
 72     Node* m_current;
 73     struct AncestorSibling {
 74         Node* node;
 75         unsigned depth;
 76     };
 77     Vector&lt;AncestorSibling, 16&gt; m_ancestorSiblingStack;
 78     unsigned m_depth { 0 };
 79 
<a name="1" id="anc1"></a><span class="line-modified"> 80 #if ASSERT_ENABLED</span>
 81     ElementIteratorAssertions m_assertions;
 82 #endif
 83 };
 84 
 85 class ElementAndTextDescendantIteratorAdapter {
 86 public:
 87     explicit ElementAndTextDescendantIteratorAdapter(ContainerNode&amp; root);
 88     ElementAndTextDescendantIterator begin();
 89     ElementAndTextDescendantIterator end();
 90 
 91 private:
 92     ContainerNode&amp; m_root;
 93 };
 94 
 95 ElementAndTextDescendantIteratorAdapter elementAndTextDescendants(ContainerNode&amp;);
 96 
 97 // ElementAndTextDescendantIterator
 98 
 99 inline ElementAndTextDescendantIterator::ElementAndTextDescendantIterator()
100     : m_current(nullptr)
101 {
102 }
103 
104 inline ElementAndTextDescendantIterator::ElementAndTextDescendantIterator(ContainerNode&amp; root, FirstChildTag)
105     : m_current(firstChild(root))
<a name="2" id="anc2"></a><span class="line-modified">106 #if ASSERT_ENABLED</span>
107     , m_assertions(m_current)
108 #endif
109 {
110     if (!m_current)
111         return;
112     m_ancestorSiblingStack.uncheckedAppend({ nullptr, 0 });
113     m_depth = 1;
114 }
115 
116 inline ElementAndTextDescendantIterator::ElementAndTextDescendantIterator(ContainerNode&amp; root, Node* current)
117     : m_current(current)
<a name="3" id="anc3"></a><span class="line-modified">118 #if ASSERT_ENABLED</span>
119     , m_assertions(m_current)
120 #endif
121 {
122     if (!m_current)
123         return;
124     ASSERT(isElementOrText(*m_current));
125     if (m_current == &amp;root)
126         return;
127 
128     Vector&lt;Node*, 20&gt; ancestorStack;
129     auto* ancestor = m_current-&gt;parentNode();
130     while (ancestor != &amp;root) {
131         ancestorStack.append(ancestor);
132         ancestor = ancestor-&gt;parentNode();
133     }
134 
135     m_ancestorSiblingStack.uncheckedAppend({ nullptr, 0 });
136     for (unsigned i = ancestorStack.size(); i; --i) {
137         if (auto* sibling = nextSibling(*ancestorStack[i - 1]))
138             m_ancestorSiblingStack.append({ sibling, i });
139     }
140 
141     m_depth = ancestorStack.size() + 1;
142 }
143 
144 inline void ElementAndTextDescendantIterator::dropAssertions()
145 {
<a name="4" id="anc4"></a><span class="line-modified">146 #if ASSERT_ENABLED</span>
147     m_assertions.clear();
148 #endif
149 }
150 
151 inline Node* ElementAndTextDescendantIterator::firstChild(Node&amp; current)
152 {
153     auto* node = current.firstChild();
154     while (node &amp;&amp; !isElementOrText(*node))
155         node = node-&gt;nextSibling();
156     return node;
157 }
158 
159 inline Node* ElementAndTextDescendantIterator::nextSibling(Node&amp; current)
160 {
161     auto* node = current.nextSibling();
162     while (node &amp;&amp; !isElementOrText(*node))
163         node = node-&gt;nextSibling();
164     return node;
165 }
166 
167 inline Node* ElementAndTextDescendantIterator::previousSibling(Node&amp; current)
168 {
169     auto* node = current.previousSibling();
170     while (node &amp;&amp; !isElementOrText(*node))
171         node = node-&gt;previousSibling();
172     return node;
173 }
174 
175 inline void ElementAndTextDescendantIterator::popAncestorSiblingStack()
176 {
177     m_current = m_ancestorSiblingStack.last().node;
178     m_depth = m_ancestorSiblingStack.last().depth;
179     m_ancestorSiblingStack.removeLast();
180 
<a name="5" id="anc5"></a><span class="line-modified">181 #if ASSERT_ENABLED</span>
182     // Drop the assertion when the iterator reaches the end.
183     if (!m_current)
184         m_assertions.dropEventDispatchAssertion();
185 #endif
186 }
187 
188 inline ElementAndTextDescendantIterator&amp; ElementAndTextDescendantIterator::traverseNext()
189 {
190     ASSERT(m_current);
191     ASSERT(!m_assertions.domTreeHasMutated());
192 
193     auto* firstChild = ElementAndTextDescendantIterator::firstChild(*m_current);
194     auto* nextSibling = ElementAndTextDescendantIterator::nextSibling(*m_current);
195     if (firstChild) {
196         if (nextSibling)
197             m_ancestorSiblingStack.append({ nextSibling, m_depth });
198         ++m_depth;
199         m_current = firstChild;
200         return *this;
201     }
202     if (!nextSibling) {
203         popAncestorSiblingStack();
204         return *this;
205     }
206 
207     m_current = nextSibling;
208     return *this;
209 }
210 
211 inline ElementAndTextDescendantIterator&amp; ElementAndTextDescendantIterator::traverseNextSkippingChildren()
212 {
213     ASSERT(m_current);
214     ASSERT(!m_assertions.domTreeHasMutated());
215 
216     auto* nextSibling = ElementAndTextDescendantIterator::nextSibling(*m_current);
217     if (!nextSibling) {
218         popAncestorSiblingStack();
219         return *this;
220     }
221 
222     m_current = nextSibling;
223     return *this;
224 }
225 
226 inline ElementAndTextDescendantIterator&amp; ElementAndTextDescendantIterator::traverseNextSibling()
227 {
228     ASSERT(m_current);
229     ASSERT(!m_assertions.domTreeHasMutated());
230 
231     m_current = nextSibling(*m_current);
232 
<a name="6" id="anc6"></a><span class="line-modified">233 #if ASSERT_ENABLED</span>
234     if (!m_current)
235         m_assertions.dropEventDispatchAssertion();
236 #endif
237     return *this;
238 }
239 
240 inline ElementAndTextDescendantIterator&amp; ElementAndTextDescendantIterator::traversePreviousSibling()
241 {
242     ASSERT(m_current);
243     ASSERT(!m_assertions.domTreeHasMutated());
244 
245     m_current = previousSibling(*m_current);
246 
<a name="7" id="anc7"></a><span class="line-modified">247 #if ASSERT_ENABLED</span>
248     if (!m_current)
249         m_assertions.dropEventDispatchAssertion();
250 #endif
251     return *this;
252 }
253 
254 inline Node&amp; ElementAndTextDescendantIterator::operator*()
255 {
256     ASSERT(m_current);
257     ASSERT(isElementOrText(*m_current));
258     ASSERT(!m_assertions.domTreeHasMutated());
259     return *m_current;
260 }
261 
262 inline Node* ElementAndTextDescendantIterator::operator-&gt;()
263 {
264     ASSERT(m_current);
265     ASSERT(isElementOrText(*m_current));
266     ASSERT(!m_assertions.domTreeHasMutated());
267     return m_current;
268 }
269 
270 inline const Node&amp; ElementAndTextDescendantIterator::operator*() const
271 {
272     ASSERT(m_current);
273     ASSERT(isElementOrText(*m_current));
274     ASSERT(!m_assertions.domTreeHasMutated());
275     return *m_current;
276 }
277 
278 inline const Node* ElementAndTextDescendantIterator::operator-&gt;() const
279 {
280     ASSERT(m_current);
281     ASSERT(isElementOrText(*m_current));
282     ASSERT(!m_assertions.domTreeHasMutated());
283     return m_current;
284 }
285 
286 inline bool ElementAndTextDescendantIterator::operator==(const ElementAndTextDescendantIterator&amp; other) const
287 {
288     ASSERT(!m_assertions.domTreeHasMutated());
289     return m_current == other.m_current || (!m_depth &amp;&amp; !other.m_depth);
290 }
291 
292 inline bool ElementAndTextDescendantIterator::operator!=(const ElementAndTextDescendantIterator&amp; other) const
293 {
294     return !(*this == other);
295 }
296 
297 // ElementAndTextDescendantIteratorAdapter
298 
299 inline ElementAndTextDescendantIteratorAdapter::ElementAndTextDescendantIteratorAdapter(ContainerNode&amp; root)
300     : m_root(root)
301 {
302 }
303 
304 inline ElementAndTextDescendantIterator ElementAndTextDescendantIteratorAdapter::begin()
305 {
306     return ElementAndTextDescendantIterator(m_root, ElementAndTextDescendantIterator::FirstChild);
307 }
308 
309 inline ElementAndTextDescendantIterator ElementAndTextDescendantIteratorAdapter::end()
310 {
311     return { };
312 }
313 
314 // Standalone functions
315 
316 inline ElementAndTextDescendantIteratorAdapter elementAndTextDescendants(ContainerNode&amp; root)
317 {
318     return ElementAndTextDescendantIteratorAdapter(root);
319 }
320 
321 } // namespace WebCore
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
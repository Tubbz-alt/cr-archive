<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/svg/animation/SVGSMILElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SMILTimeContainer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGSMILElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/svg/animation/SVGSMILElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 228     if (namespaceURI.isEmpty())
 229         return anyQName();
 230 
 231     return { nullAtom(), localName, namespaceURI };
 232 }
 233 
 234 inline void SVGSMILElement::updateAttributeName()
 235 {
 236     setAttributeName(constructAttributeName());
 237 }
 238 
 239 static inline void clearTimesWithDynamicOrigins(Vector&lt;SMILTimeWithOrigin&gt;&amp; timeList)
 240 {
 241     timeList.removeAllMatching([] (const SMILTimeWithOrigin&amp; time) {
 242         return time.originIsScript();
 243     });
 244 }
 245 
 246 void SVGSMILElement::reset()
 247 {
<span class="line-modified"> 248     clearAnimatedType(m_targetElement);</span>
 249 
 250     m_activeState = Inactive;
 251     m_isWaitingForFirstInterval = true;
 252     m_intervalBegin = SMILTime::unresolved();
 253     m_intervalEnd = SMILTime::unresolved();
 254     m_previousIntervalBegin = SMILTime::unresolved();
 255     m_lastPercent = 0;
 256     m_lastRepeat = 0;
 257     m_nextProgressTime = 0;
 258     resolveFirstInterval();
 259 }
 260 
 261 Node::InsertedIntoAncestorResult SVGSMILElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
 262 {
 263     SVGElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
 264     if (!insertionType.connectedToDocument)
 265         return InsertedIntoAncestorResult::Done;
 266 
 267     // Verify we are not in &lt;use&gt; instance tree.
 268     ASSERT(!isInShadowTree() || !is&lt;SVGUseElement&gt;(shadowHost()));
</pre>
<hr />
<pre>
 593             if (condition.m_syncbase)
 594                 downcast&lt;SVGSMILElement&gt;(condition.m_syncbase.get())-&gt;removeTimeDependent(this);
 595         }
 596         condition.m_syncbase = nullptr;
 597     }
 598 }
 599 
 600 void SVGSMILElement::setAttributeName(const QualifiedName&amp; attributeName)
 601 {
 602     if (m_timeContainer &amp;&amp; m_targetElement &amp;&amp; m_attributeName != attributeName) {
 603         if (hasValidAttributeName())
 604             m_timeContainer-&gt;unschedule(this, m_targetElement, m_attributeName);
 605         m_attributeName = attributeName;
 606         if (hasValidAttributeName())
 607             m_timeContainer-&gt;schedule(this, m_targetElement, m_attributeName);
 608     } else
 609         m_attributeName = attributeName;
 610 
 611     // Only clear the animated type, if we had a target before.
 612     if (m_targetElement)
<span class="line-modified"> 613         clearAnimatedType(m_targetElement);</span>
 614 }
 615 
 616 void SVGSMILElement::setTargetElement(SVGElement* target)
 617 {
 618     if (m_timeContainer &amp;&amp; hasValidAttributeName()) {
 619         if (m_targetElement)
 620             m_timeContainer-&gt;unschedule(this, m_targetElement, m_attributeName);
 621         if (target)
 622             m_timeContainer-&gt;schedule(this, target, m_attributeName);
 623     }
 624 
 625     if (m_targetElement) {
 626         // Clear values that may depend on the previous target.
<span class="line-modified"> 627         clearAnimatedType(m_targetElement);</span>
 628         disconnectConditions();
 629     }
 630 
 631     // If the animation state is not Inactive, always reset to a clear state before leaving the old target element.
 632     if (m_activeState != Inactive)
 633         endedActiveInterval();
 634 
 635     m_targetElement = target;
 636 }
 637 
 638 SMILTime SVGSMILElement::elapsed() const
 639 {
 640     return m_timeContainer ? m_timeContainer-&gt;elapsed() : 0;
 641 }
 642 
 643 bool SVGSMILElement::isInactive() const
 644 {
 645      return m_activeState == Inactive;
 646 }
 647 
</pre>
<hr />
<pre>
1053         }
1054         return elapsed + m_timeContainer-&gt;animationFrameDelay();
1055     }
1056     return m_intervalBegin &gt;= elapsed ? m_intervalBegin : SMILTime::unresolved();
1057 }
1058 
1059 SVGSMILElement::ActiveState SVGSMILElement::determineActiveState(SMILTime elapsed) const
1060 {
1061     if (elapsed &gt;= m_intervalBegin &amp;&amp; elapsed &lt; m_intervalEnd)
1062         return Active;
1063 
1064     return fill() == FillFreeze ? Frozen : Inactive;
1065 }
1066 
1067 bool SVGSMILElement::isContributing(SMILTime elapsed) const
1068 {
1069     // Animation does not contribute during the active time if it is past its repeating duration and has fill=remove.
1070     return (m_activeState == Active &amp;&amp; (fill() == FillFreeze || elapsed &lt;= m_intervalBegin + repeatingDuration())) || m_activeState == Frozen;
1071 }
1072 
<span class="line-modified">1073 bool SVGSMILElement::progress(SMILTime elapsed, SVGSMILElement* resultElement, bool seekToTime)</span>
1074 {
<span class="line-removed">1075     ASSERT(resultElement);</span>
1076     ASSERT(m_timeContainer);
1077     ASSERT(m_isWaitingForFirstInterval || m_intervalBegin.isFinite());
1078 
1079     if (!m_intervalBegin.isFinite()) {
1080         ASSERT(m_activeState == Inactive);
1081         m_nextProgressTime = SMILTime::unresolved();
1082         return false;
1083     }
1084 
1085     if (elapsed &lt; m_intervalBegin) {
1086         ASSERT(m_activeState != Active);
1087         if (m_activeState == Frozen) {
<span class="line-modified">1088             if (this == resultElement)</span>
<span class="line-modified">1089                 resetAnimatedType();</span>
<span class="line-modified">1090             updateAnimation(m_lastPercent, m_lastRepeat, resultElement);</span>
1091         }
1092         m_nextProgressTime = m_intervalBegin;
1093         return false;
1094     }
1095 
1096     m_previousIntervalBegin = m_intervalBegin;
1097 
1098     if (m_isWaitingForFirstInterval) {
1099         m_isWaitingForFirstInterval = false;
1100         resolveFirstInterval();
1101     }
1102 
1103     // This call may obtain a new interval -- never call calculateAnimationPercentAndRepeat() before!
1104     if (seekToTime) {
1105         seekToIntervalCorrespondingToTime(elapsed);
1106         if (elapsed &lt; m_intervalBegin) {
1107             // elapsed is not within an interval.
1108             m_nextProgressTime = m_intervalBegin;
1109             return false;
1110         }
1111     }
1112 
1113     unsigned repeat = 0;
1114     float percent = calculateAnimationPercentAndRepeat(elapsed, repeat);
1115     checkRestart(elapsed);
1116 
1117     ActiveState oldActiveState = m_activeState;
1118     m_activeState = determineActiveState(elapsed);
1119     bool animationIsContributing = isContributing(elapsed);
1120 
<span class="line-removed">1121     // Only reset the animated type to the base value once for the lowest priority animation that animates and contributes to a particular element/attribute pair.</span>
<span class="line-removed">1122     if (this == resultElement &amp;&amp; animationIsContributing)</span>
<span class="line-removed">1123         resetAnimatedType();</span>
<span class="line-removed">1124 </span>
1125     if (animationIsContributing) {




1126         if (oldActiveState == Inactive)
1127             startedActiveInterval();
1128 
<span class="line-modified">1129         updateAnimation(percent, repeat, resultElement);</span>
1130         m_lastPercent = percent;
1131         m_lastRepeat = repeat;
1132     }
1133 
1134     if (oldActiveState == Active &amp;&amp; m_activeState != Active) {
1135         smilEndEventSender().dispatchEventSoon(*this);
1136         endedActiveInterval();
1137         if (m_activeState != Frozen)
<span class="line-modified">1138             clearAnimatedType(m_targetElement);</span>
1139     } else if (oldActiveState != Active &amp;&amp; m_activeState == Active)
1140         smilBeginEventSender().dispatchEventSoon(*this);
1141 
1142     // Triggering all the pending events if the animation timeline is changed.
1143     if (seekToTime) {
1144         if (m_activeState == Inactive || m_activeState == Frozen)
1145             smilEndEventSender().dispatchEventSoon(*this);
1146     }
1147 
1148     m_nextProgressTime = calculateNextProgressTime(elapsed);
1149     return animationIsContributing;
1150 }
1151 
1152 void SVGSMILElement::notifyDependentsIntervalChanged(NewOrExistingInterval newOrExisting)
1153 {
1154     ASSERT(m_intervalBegin.isFinite());
1155     static NeverDestroyed&lt;HashSet&lt;SVGSMILElement*&gt;&gt; loopBreaker;
1156     if (loopBreaker.get().contains(this))
1157         return;
1158     loopBreaker.get().add(this);
</pre>
</td>
<td>
<hr />
<pre>
 228     if (namespaceURI.isEmpty())
 229         return anyQName();
 230 
 231     return { nullAtom(), localName, namespaceURI };
 232 }
 233 
 234 inline void SVGSMILElement::updateAttributeName()
 235 {
 236     setAttributeName(constructAttributeName());
 237 }
 238 
 239 static inline void clearTimesWithDynamicOrigins(Vector&lt;SMILTimeWithOrigin&gt;&amp; timeList)
 240 {
 241     timeList.removeAllMatching([] (const SMILTimeWithOrigin&amp; time) {
 242         return time.originIsScript();
 243     });
 244 }
 245 
 246 void SVGSMILElement::reset()
 247 {
<span class="line-modified"> 248     stopAnimation(m_targetElement);</span>
 249 
 250     m_activeState = Inactive;
 251     m_isWaitingForFirstInterval = true;
 252     m_intervalBegin = SMILTime::unresolved();
 253     m_intervalEnd = SMILTime::unresolved();
 254     m_previousIntervalBegin = SMILTime::unresolved();
 255     m_lastPercent = 0;
 256     m_lastRepeat = 0;
 257     m_nextProgressTime = 0;
 258     resolveFirstInterval();
 259 }
 260 
 261 Node::InsertedIntoAncestorResult SVGSMILElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
 262 {
 263     SVGElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
 264     if (!insertionType.connectedToDocument)
 265         return InsertedIntoAncestorResult::Done;
 266 
 267     // Verify we are not in &lt;use&gt; instance tree.
 268     ASSERT(!isInShadowTree() || !is&lt;SVGUseElement&gt;(shadowHost()));
</pre>
<hr />
<pre>
 593             if (condition.m_syncbase)
 594                 downcast&lt;SVGSMILElement&gt;(condition.m_syncbase.get())-&gt;removeTimeDependent(this);
 595         }
 596         condition.m_syncbase = nullptr;
 597     }
 598 }
 599 
 600 void SVGSMILElement::setAttributeName(const QualifiedName&amp; attributeName)
 601 {
 602     if (m_timeContainer &amp;&amp; m_targetElement &amp;&amp; m_attributeName != attributeName) {
 603         if (hasValidAttributeName())
 604             m_timeContainer-&gt;unschedule(this, m_targetElement, m_attributeName);
 605         m_attributeName = attributeName;
 606         if (hasValidAttributeName())
 607             m_timeContainer-&gt;schedule(this, m_targetElement, m_attributeName);
 608     } else
 609         m_attributeName = attributeName;
 610 
 611     // Only clear the animated type, if we had a target before.
 612     if (m_targetElement)
<span class="line-modified"> 613         stopAnimation(m_targetElement);</span>
 614 }
 615 
 616 void SVGSMILElement::setTargetElement(SVGElement* target)
 617 {
 618     if (m_timeContainer &amp;&amp; hasValidAttributeName()) {
 619         if (m_targetElement)
 620             m_timeContainer-&gt;unschedule(this, m_targetElement, m_attributeName);
 621         if (target)
 622             m_timeContainer-&gt;schedule(this, target, m_attributeName);
 623     }
 624 
 625     if (m_targetElement) {
 626         // Clear values that may depend on the previous target.
<span class="line-modified"> 627         stopAnimation(m_targetElement);</span>
 628         disconnectConditions();
 629     }
 630 
 631     // If the animation state is not Inactive, always reset to a clear state before leaving the old target element.
 632     if (m_activeState != Inactive)
 633         endedActiveInterval();
 634 
 635     m_targetElement = target;
 636 }
 637 
 638 SMILTime SVGSMILElement::elapsed() const
 639 {
 640     return m_timeContainer ? m_timeContainer-&gt;elapsed() : 0;
 641 }
 642 
 643 bool SVGSMILElement::isInactive() const
 644 {
 645      return m_activeState == Inactive;
 646 }
 647 
</pre>
<hr />
<pre>
1053         }
1054         return elapsed + m_timeContainer-&gt;animationFrameDelay();
1055     }
1056     return m_intervalBegin &gt;= elapsed ? m_intervalBegin : SMILTime::unresolved();
1057 }
1058 
1059 SVGSMILElement::ActiveState SVGSMILElement::determineActiveState(SMILTime elapsed) const
1060 {
1061     if (elapsed &gt;= m_intervalBegin &amp;&amp; elapsed &lt; m_intervalEnd)
1062         return Active;
1063 
1064     return fill() == FillFreeze ? Frozen : Inactive;
1065 }
1066 
1067 bool SVGSMILElement::isContributing(SMILTime elapsed) const
1068 {
1069     // Animation does not contribute during the active time if it is past its repeating duration and has fill=remove.
1070     return (m_activeState == Active &amp;&amp; (fill() == FillFreeze || elapsed &lt;= m_intervalBegin + repeatingDuration())) || m_activeState == Frozen;
1071 }
1072 
<span class="line-modified">1073 bool SVGSMILElement::progress(SMILTime elapsed, SVGSMILElement&amp; firstAnimation, bool seekToTime)</span>
1074 {

1075     ASSERT(m_timeContainer);
1076     ASSERT(m_isWaitingForFirstInterval || m_intervalBegin.isFinite());
1077 
1078     if (!m_intervalBegin.isFinite()) {
1079         ASSERT(m_activeState == Inactive);
1080         m_nextProgressTime = SMILTime::unresolved();
1081         return false;
1082     }
1083 
1084     if (elapsed &lt; m_intervalBegin) {
1085         ASSERT(m_activeState != Active);
1086         if (m_activeState == Frozen) {
<span class="line-modified">1087             if (this == &amp;firstAnimation)</span>
<span class="line-modified">1088                 startAnimation();</span>
<span class="line-modified">1089             updateAnimation(m_lastPercent, m_lastRepeat);</span>
1090         }
1091         m_nextProgressTime = m_intervalBegin;
1092         return false;
1093     }
1094 
1095     m_previousIntervalBegin = m_intervalBegin;
1096 
1097     if (m_isWaitingForFirstInterval) {
1098         m_isWaitingForFirstInterval = false;
1099         resolveFirstInterval();
1100     }
1101 
1102     // This call may obtain a new interval -- never call calculateAnimationPercentAndRepeat() before!
1103     if (seekToTime) {
1104         seekToIntervalCorrespondingToTime(elapsed);
1105         if (elapsed &lt; m_intervalBegin) {
1106             // elapsed is not within an interval.
1107             m_nextProgressTime = m_intervalBegin;
1108             return false;
1109         }
1110     }
1111 
1112     unsigned repeat = 0;
1113     float percent = calculateAnimationPercentAndRepeat(elapsed, repeat);
1114     checkRestart(elapsed);
1115 
1116     ActiveState oldActiveState = m_activeState;
1117     m_activeState = determineActiveState(elapsed);
1118     bool animationIsContributing = isContributing(elapsed);
1119 




1120     if (animationIsContributing) {
<span class="line-added">1121         // Only start the animation of the lowest priority animation that animates and contributes to a particular element/attribute pair.</span>
<span class="line-added">1122         if (this == &amp;firstAnimation)</span>
<span class="line-added">1123             startAnimation();</span>
<span class="line-added">1124 </span>
1125         if (oldActiveState == Inactive)
1126             startedActiveInterval();
1127 
<span class="line-modified">1128         updateAnimation(percent, repeat);</span>
1129         m_lastPercent = percent;
1130         m_lastRepeat = repeat;
1131     }
1132 
1133     if (oldActiveState == Active &amp;&amp; m_activeState != Active) {
1134         smilEndEventSender().dispatchEventSoon(*this);
1135         endedActiveInterval();
1136         if (m_activeState != Frozen)
<span class="line-modified">1137             stopAnimation(m_targetElement);</span>
1138     } else if (oldActiveState != Active &amp;&amp; m_activeState == Active)
1139         smilBeginEventSender().dispatchEventSoon(*this);
1140 
1141     // Triggering all the pending events if the animation timeline is changed.
1142     if (seekToTime) {
1143         if (m_activeState == Inactive || m_activeState == Frozen)
1144             smilEndEventSender().dispatchEventSoon(*this);
1145     }
1146 
1147     m_nextProgressTime = calculateNextProgressTime(elapsed);
1148     return animationIsContributing;
1149 }
1150 
1151 void SVGSMILElement::notifyDependentsIntervalChanged(NewOrExistingInterval newOrExisting)
1152 {
1153     ASSERT(m_intervalBegin.isFinite());
1154     static NeverDestroyed&lt;HashSet&lt;SVGSMILElement*&gt;&gt; loopBreaker;
1155     if (loopBreaker.get().contains(this))
1156         return;
1157     loopBreaker.get().add(this);
</pre>
</td>
</tr>
</table>
<center><a href="SMILTimeContainer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGSMILElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WTF/wtf/Language.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2010, 2013, 2016, 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &lt;wtf/Language.h&gt;
 28 
 29 #include &lt;wtf/HashMap.h&gt;
 30 #include &lt;wtf/NeverDestroyed.h&gt;
 31 #include &lt;wtf/RetainPtr.h&gt;
 32 #include &lt;wtf/text/WTFString.h&gt;
 33 
 34 #if USE(CF) &amp;&amp; !PLATFORM(WIN)
 35 #include &lt;CoreFoundation/CoreFoundation.h&gt;
 36 #endif
 37 
 38 namespace WTF {
 39 
 40 static Lock userPreferredLanguagesMutex;
 41 
 42 typedef HashMap&lt;void*, LanguageChangeObserverFunction&gt; ObserverMap;
 43 static ObserverMap&amp; observerMap()
 44 {
 45     static NeverDestroyed&lt;ObserverMap&gt; map;
 46     return map.get();
 47 }
 48 
 49 void addLanguageChangeObserver(void* context, LanguageChangeObserverFunction customObserver)
 50 {
 51     observerMap().set(context, customObserver);
 52 }
 53 
 54 void removeLanguageChangeObserver(void* context)
 55 {
 56     ASSERT(observerMap().contains(context));
 57     observerMap().remove(context);
 58 }
 59 
 60 void languageDidChange()
 61 {
 62     ObserverMap::iterator end = observerMap().end();
 63     for (ObserverMap::iterator iter = observerMap().begin(); iter != end; ++iter)
 64         iter-&gt;value(iter-&gt;key);
 65 }
 66 
 67 String defaultLanguage()
 68 {
 69     Vector&lt;String&gt; languages = userPreferredLanguages();
 70     if (languages.size())
 71         return languages[0];
 72 
 73     return emptyString();
 74 }
 75 
 76 static Vector&lt;String&gt;&amp; preferredLanguagesOverride()
 77 {
 78     static NeverDestroyed&lt;Vector&lt;String&gt;&gt; override;
 79     return override;
 80 }
 81 
 82 Vector&lt;String&gt; userPreferredLanguagesOverride()
 83 {
 84     return preferredLanguagesOverride();
 85 }
 86 
 87 void overrideUserPreferredLanguages(const Vector&lt;String&gt;&amp; override)
 88 {
 89     preferredLanguagesOverride() = override;
 90     languageDidChange();
 91 }
 92 
 93 static Vector&lt;String&gt; isolatedCopy(const Vector&lt;String&gt;&amp; strings)
 94 {
 95     Vector&lt;String&gt; copy;
 96     copy.reserveInitialCapacity(strings.size());
 97     for (auto&amp; language : strings)
 98         copy.uncheckedAppend(language.isolatedCopy());
 99     return copy;
100 }
101 
102 Vector&lt;String&gt; userPreferredLanguages()
103 {
104     {
105         std::lock_guard&lt;Lock&gt; lock(userPreferredLanguagesMutex);
106         Vector&lt;String&gt;&amp; override = preferredLanguagesOverride();
107         if (!override.isEmpty())
108             return isolatedCopy(override);
109     }
110 
111     return platformUserPreferredLanguages();
112 }
113 
114 static String canonicalLanguageIdentifier(const String&amp; languageCode)
115 {
116     String lowercaseLanguageCode = languageCode.convertToASCIILowercase();
117 
118     if (lowercaseLanguageCode.length() &gt;= 3 &amp;&amp; lowercaseLanguageCode[2] == &#39;_&#39;)
119         lowercaseLanguageCode.replace(2, 1, &quot;-&quot;);
120 
121     return lowercaseLanguageCode;
122 }
123 
124 size_t indexOfBestMatchingLanguageInList(const String&amp; language, const Vector&lt;String&gt;&amp; languageList, bool&amp; exactMatch)
125 {
126     String lowercaseLanguage = language.convertToASCIILowercase();
127     String languageWithoutLocaleMatch;
128     String languageMatchButNotLocale;
129     size_t languageWithoutLocaleMatchIndex = 0;
130     size_t languageMatchButNotLocaleMatchIndex = 0;
131     bool canMatchLanguageOnly = (lowercaseLanguage.length() == 2 || (lowercaseLanguage.length() &gt;= 3 &amp;&amp; lowercaseLanguage[2] == &#39;-&#39;));
132 
133     for (size_t i = 0; i &lt; languageList.size(); ++i) {
134         String canonicalizedLanguageFromList = canonicalLanguageIdentifier(languageList[i]);
135 
136         if (lowercaseLanguage == canonicalizedLanguageFromList) {
137             exactMatch = true;
138             return i;
139         }
140 
141         if (canMatchLanguageOnly &amp;&amp; canonicalizedLanguageFromList.length() &gt;= 2) {
142             if (lowercaseLanguage[0] == canonicalizedLanguageFromList[0] &amp;&amp; lowercaseLanguage[1] == canonicalizedLanguageFromList[1]) {
143                 if (!languageWithoutLocaleMatch.length() &amp;&amp; canonicalizedLanguageFromList.length() == 2) {
144                     languageWithoutLocaleMatch = languageList[i];
145                     languageWithoutLocaleMatchIndex = i;
146                 }
147                 if (!languageMatchButNotLocale.length() &amp;&amp; canonicalizedLanguageFromList.length() &gt;= 3) {
148                     languageMatchButNotLocale = languageList[i];
149                     languageMatchButNotLocaleMatchIndex = i;
150                 }
151             }
152         }
153     }
154 
155     exactMatch = false;
156 
157     // If we have both a language-only match and a languge-but-not-locale match, return the
158     // languge-only match as is considered a &quot;better&quot; match. For example, if the list
159     // provided has both &quot;en-GB&quot; and &quot;en&quot; and the user prefers &quot;en-US&quot; we will return &quot;en&quot;.
160     if (languageWithoutLocaleMatch.length())
161         return languageWithoutLocaleMatchIndex;
162 
163     if (languageMatchButNotLocale.length())
164         return languageMatchButNotLocaleMatchIndex;
165 
166     return languageList.size();
167 }
168 
169 String displayNameForLanguageLocale(const String&amp; localeName)
170 {
171 #if USE(CF) &amp;&amp; !PLATFORM(WIN)
172     if (!localeName.isEmpty())
173         return adoptCF(CFLocaleCopyDisplayNameForPropertyValue(adoptCF(CFLocaleCopyCurrent()).get(), kCFLocaleIdentifier, localeName.createCFString().get())).get();
174 #endif
175     return localeName;
176 }
177 
178 }
    </pre>
  </body>
</html>
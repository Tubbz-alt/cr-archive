diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGClobberize.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGClobberize.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGClobberize.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGClobberize.h
@@ -33,11 +33,10 @@
 #include "DFGLazyNode.h"
 #include "DFGPureValue.h"
 #include "DOMJITCallDOMGetterSnippet.h"
 #include "DOMJITSignature.h"
 #include "InlineCallFrame.h"
-#include "JSFixedArray.h"
 #include "JSImmutableButterfly.h"
 
 namespace JSC { namespace DFG {
 
 template<typename ReadFunctor, typename WriteFunctor, typename DefFunctor>
@@ -110,13 +109,13 @@
     // by calls into the runtime. For debugging we might replace the implementation of any node with a call
     // to the runtime, and that call may walk stack. Therefore, each node must read() anything that a stack
     // scan would read. That's what this does.
     for (InlineCallFrame* inlineCallFrame = node->origin.semantic.inlineCallFrame(); inlineCallFrame; inlineCallFrame = inlineCallFrame->directCaller.inlineCallFrame()) {
         if (inlineCallFrame->isClosureCall)
-            read(AbstractHeap(Stack, inlineCallFrame->stackOffset + CallFrameSlot::callee));
+            read(AbstractHeap(Stack, VirtualRegister(inlineCallFrame->stackOffset + CallFrameSlot::callee)));
         if (inlineCallFrame->isVarargs())
-            read(AbstractHeap(Stack, inlineCallFrame->stackOffset + CallFrameSlot::argumentCount));
+            read(AbstractHeap(Stack, VirtualRegister(inlineCallFrame->stackOffset + CallFrameSlot::argumentCountIncludingThis)));
     }
 
     // We don't want to specifically account which nodes can read from the scope
     // when the debugger is enabled. It's helpful to just claim all nodes do.
     // Specifically, if a node allocates, this may call into the debugger's machinery.
@@ -166,10 +165,11 @@
     case ArithPow:
     case GetScope:
     case SkipScope:
     case GetGlobalObject:
     case StringCharCodeAt:
+    case StringCodePointAt:
     case CompareStrictEq:
     case SameValue:
     case IsEmpty:
     case IsUndefined:
     case IsUndefinedOrNull:
@@ -279,11 +279,11 @@
 
     case ArithBitAnd:
     case ArithBitOr:
     case ArithBitXor:
     case ArithBitLShift:
-    case BitRShift:
+    case ArithBitRShift:
     case BitURShift:
         if (node->child1().useKind() == UntypedUse || node->child2().useKind() == UntypedUse) {
             read(World);
             write(Heap);
             return;
@@ -430,20 +430,20 @@
 
     case AssertNotEmpty:
         write(SideState);
         return;
 
-    case CheckStringIdent:
-        def(PureValue(CheckStringIdent, AdjacencyList(AdjacencyList::Fixed, node->child1()), node->uidOperand()));
+    case CheckIdent:
+        def(PureValue(CheckIdent, AdjacencyList(AdjacencyList::Fixed, node->child1()), node->uidOperand()));
         return;
 
     case ConstantStoragePointer:
         def(PureValue(node, node->storagePointer()));
         return;
 
     case KillStack:
-        write(AbstractHeap(Stack, node->unlinkedLocal()));
+        write(AbstractHeap(Stack, node->unlinkedOperand()));
         return;
 
     case MovHint:
     case ZombieHint:
     case ExitOK:
@@ -468,11 +468,11 @@
     case ProfileType:
     case ProfileControlFlow:
     case PutHint:
     case InitializeEntrypointArguments:
     case FilterCallLinkStatus:
-    case FilterGetByIdStatus:
+    case FilterGetByStatus:
     case FilterPutByIdStatus:
     case FilterInByIdStatus:
         write(SideState);
         return;
 
@@ -495,11 +495,11 @@
         write(SideState);
         def(HeapLocation(InvalidationPointLoc, Watchpoint_fire), LazyNode(node));
         return;
 
     case Flush:
-        read(AbstractHeap(Stack, node->local()));
+        read(AbstractHeap(Stack, node->operand()));
         write(SideState);
         return;
 
     case NotifyWrite:
         write(Watchpoint_fire);
@@ -522,10 +522,11 @@
     }
 
     case CreateDirectArguments:
     case CreateScopedArguments:
     case CreateClonedArguments:
+    case CreateArgumentsButterfly:
         read(Stack);
         read(HeapObjectCount);
         write(HeapObjectCount);
         return;
 
@@ -646,10 +647,11 @@
     case TailCallVarargsInlinedCaller:
     case TailCallForwardVarargsInlinedCaller:
     case ConstructVarargs:
     case ConstructForwardVarargs:
     case ToPrimitive:
+    case ToPropertyKey:
     case InByVal:
     case InById:
     case HasOwnProperty:
     case ValueNegate:
     case SetFunctionName:
@@ -662,29 +664,51 @@
     case HasStructureProperty:
     case GetPropertyEnumerator:
     case GetDirectPname:
     case InstanceOfCustom:
     case ToNumber:
+    case ToNumeric:
     case NumberToStringWithRadix:
     case CreateThis:
+    case CreatePromise:
+    case CreateGenerator:
+    case CreateAsyncGenerator:
     case InstanceOf:
     case StringValueOf:
     case ObjectKeys:
         read(World);
         write(Heap);
         return;
 
+    case Inc:
+    case Dec:
+        switch (node->child1().useKind()) {
+        case Int32Use:
+        case Int52RepUse:
+        case DoubleRepUse:
+        case BigIntUse:
+            def(PureValue(node));
+            return;
+        case UntypedUse:
+            read(World);
+            write(Heap);
+            return;
+        default:
+            DFG_CRASH(graph, node, "Bad use kind");
+        }
+
     case ValueBitAnd:
     case ValueBitXor:
     case ValueBitOr:
     case ValueAdd:
     case ValueSub:
     case ValueMul:
     case ValueDiv:
     case ValueMod:
     case ValuePow:
     case ValueBitLShift:
+    case ValueBitRShift:
         if (node->isBinaryUseKind(BigIntUse)) {
             def(PureValue(node));
             return;
         }
         read(World);
@@ -714,11 +738,11 @@
     }
 
     case CallEval:
         ASSERT(!node->origin.semantic.inlineCallFrame());
         read(AbstractHeap(Stack, graph.m_codeBlock->scopeRegister()));
-        read(AbstractHeap(Stack, virtualRegisterForArgument(0)));
+        read(AbstractHeap(Stack, virtualRegisterForArgumentIncludingThis(0)));
         read(World);
         write(Heap);
         return;
 
     case Throw:
@@ -740,75 +764,81 @@
         read(GetterSetter_setter);
         def(HeapLocation(SetterLoc, GetterSetter_setter, node->child1()), LazyNode(node));
         return;
 
     case GetCallee:
-        read(AbstractHeap(Stack, CallFrameSlot::callee));
-        def(HeapLocation(StackLoc, AbstractHeap(Stack, CallFrameSlot::callee)), LazyNode(node));
+        read(AbstractHeap(Stack, VirtualRegister(CallFrameSlot::callee)));
+        def(HeapLocation(StackLoc, AbstractHeap(Stack, VirtualRegister(CallFrameSlot::callee))), LazyNode(node));
         return;
 
     case SetCallee:
-        write(AbstractHeap(Stack, CallFrameSlot::callee));
+        write(AbstractHeap(Stack, VirtualRegister(CallFrameSlot::callee)));
         return;
 
     case GetArgumentCountIncludingThis: {
-        auto heap = AbstractHeap(Stack, remapOperand(node->argumentsInlineCallFrame(), VirtualRegister(CallFrameSlot::argumentCount)));
+        auto heap = AbstractHeap(Stack, remapOperand(node->argumentsInlineCallFrame(), VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));
         read(heap);
         def(HeapLocation(StackPayloadLoc, heap), LazyNode(node));
         return;
     }
 
     case SetArgumentCountIncludingThis:
-        write(AbstractHeap(Stack, CallFrameSlot::argumentCount));
+        write(AbstractHeap(Stack, VirtualRegister(CallFrameSlot::argumentCountIncludingThis)));
         return;
 
     case GetRestLength:
         read(Stack);
         return;
 
     case GetLocal:
-        read(AbstractHeap(Stack, node->local()));
-        def(HeapLocation(StackLoc, AbstractHeap(Stack, node->local())), LazyNode(node));
+        read(AbstractHeap(Stack, node->operand()));
+        def(HeapLocation(StackLoc, AbstractHeap(Stack, node->operand())), LazyNode(node));
         return;
 
     case SetLocal:
-        write(AbstractHeap(Stack, node->local()));
-        def(HeapLocation(StackLoc, AbstractHeap(Stack, node->local())), LazyNode(node->child1().node()));
+        write(AbstractHeap(Stack, node->operand()));
+        def(HeapLocation(StackLoc, AbstractHeap(Stack, node->operand())), LazyNode(node->child1().node()));
         return;
 
     case GetStack: {
-        AbstractHeap heap(Stack, node->stackAccessData()->local);
+        AbstractHeap heap(Stack, node->stackAccessData()->operand);
         read(heap);
         def(HeapLocation(StackLoc, heap), LazyNode(node));
         return;
     }
 
     case PutStack: {
-        AbstractHeap heap(Stack, node->stackAccessData()->local);
+        AbstractHeap heap(Stack, node->stackAccessData()->operand);
         write(heap);
         def(HeapLocation(StackLoc, heap), LazyNode(node->child1().node()));
         return;
     }
 
+    case VarargsLength: {
+        read(World);
+        write(Heap);
+        return;
+    }
+
     case LoadVarargs: {
         read(World);
         write(Heap);
         LoadVarargsData* data = node->loadVarargsData();
-        write(AbstractHeap(Stack, data->count.offset()));
+        write(AbstractHeap(Stack, data->count));
         for (unsigned i = data->limit; i--;)
-            write(AbstractHeap(Stack, data->start.offset() + static_cast<int>(i)));
+            write(AbstractHeap(Stack, data->start + static_cast<int>(i)));
         return;
     }
 
     case ForwardVarargs: {
         // We could be way more precise here.
         read(Stack);
 
         LoadVarargsData* data = node->loadVarargsData();
-        write(AbstractHeap(Stack, data->count.offset()));
+        write(AbstractHeap(Stack, data->count));
         for (unsigned i = data->limit; i--;)
-            write(AbstractHeap(Stack, data->start.offset() + static_cast<int>(i)));
+            write(AbstractHeap(Stack, data->start + static_cast<int>(i)));
         return;
     }
 
     case GetByVal: {
         ArrayMode mode = node->arrayMode();
@@ -1016,12 +1046,12 @@
                 write(Heap);
                 return;
             }
             read(Butterfly_publicLength);
             read(Butterfly_vectorLength);
-            read(ArrayStorageProperties);
-            write(ArrayStorageProperties);
+            read(IndexedArrayStorageProperties);
+            write(IndexedArrayStorageProperties);
             if (node->arrayMode().mayStoreToHole())
                 write(Butterfly_publicLength);
             return;
 
         case Array::SlowPutArrayStorage:
@@ -1030,12 +1060,12 @@
                 write(Heap);
                 return;
             }
             read(Butterfly_publicLength);
             read(Butterfly_vectorLength);
-            read(ArrayStorageProperties);
-            write(ArrayStorageProperties);
+            read(IndexedArrayStorageProperties);
+            write(IndexedArrayStorageProperties);
             return;
 
         case Array::Int8Array:
         case Array::Int16Array:
         case Array::Int32Array:
@@ -1064,16 +1094,20 @@
     case CheckStructureOrEmpty:
     case CheckStructure:
         read(JSCell_structureID);
         return;
 
+    case CheckArrayOrEmpty:
     case CheckArray:
         read(JSCell_indexingType);
-        read(JSCell_typeInfoType);
         read(JSCell_structureID);
         return;
 
+    case CheckNeutered:
+        read(MiscFields);
+        return;
+
     case CheckTypeInfoFlags:
         read(JSCell_typeInfoFlags);
         def(HeapLocation(CheckTypeInfoFlagsLoc, JSCell_typeInfoFlags, node->child1()), LazyNode(node));
         return;
 
@@ -1094,11 +1128,10 @@
         return;
 
     case PutStructure:
         read(JSObject_butterfly);
         write(JSCell_structureID);
-        write(JSCell_typeInfoType);
         write(JSCell_typeInfoFlags);
         write(JSCell_indexingType);
         return;
 
     case AllocatePropertyStorage:
@@ -1314,10 +1347,24 @@
     case PutClosureVar:
         write(AbstractHeap(ScopeProperties, node->scopeOffset().offset()));
         def(HeapLocation(ClosureVariableLoc, AbstractHeap(ScopeProperties, node->scopeOffset().offset()), node->child1()), LazyNode(node->child2().node()));
         return;
 
+    case GetInternalField: {
+        AbstractHeap heap(JSInternalFields, node->internalFieldIndex());
+        read(heap);
+        def(HeapLocation(InternalFieldObjectLoc, heap, node->child1()), LazyNode(node));
+        return;
+    }
+
+    case PutInternalField: {
+        AbstractHeap heap(JSInternalFields, node->internalFieldIndex());
+        write(heap);
+        def(HeapLocation(InternalFieldObjectLoc, heap, node->child1()), LazyNode(node->child2().node()));
+        return;
+    }
+
     case GetRegExpObjectLastIndex:
         read(RegExpObject_lastIndex);
         def(HeapLocation(RegExpObjectLastIndexLoc, RegExpObject_lastIndex, node->child1()), LazyNode(node));
         return;
 
@@ -1381,12 +1428,12 @@
             DFG_CRASH(graph, node, "Bad use kind");
         }
         break;
 
     case NewArrayWithSpread: {
-        // This also reads from JSFixedArray's data store, but we don't have any way of describing that yet.
         read(HeapObjectCount);
+        // This appears to read nothing because it's only reading immutable butterfly data.
         for (unsigned i = 0; i < node->numChildren(); i++) {
             Node* child = graph.varArgChild(node, i).node();
             if (child->op() == PhantomSpread) {
                 read(Stack);
                 break;
@@ -1547,19 +1594,25 @@
             return;
         }
     }
 
     case NewObject:
+    case NewPromise:
+    case NewGenerator:
+    case NewAsyncGenerator:
+    case NewArrayIterator:
     case NewRegexp:
     case NewSymbol:
     case NewStringObject:
     case PhantomNewObject:
     case MaterializeNewObject:
     case PhantomNewFunction:
     case PhantomNewGeneratorFunction:
     case PhantomNewAsyncFunction:
     case PhantomNewAsyncGeneratorFunction:
+    case PhantomNewArrayIterator:
+    case MaterializeNewInternalFieldObject:
     case PhantomCreateActivation:
     case MaterializeCreateActivation:
     case PhantomNewRegexp:
         read(HeapObjectCount);
         write(HeapObjectCount);
@@ -1789,10 +1842,17 @@
         return;
 
     case NumberToStringWithValidRadixConstant:
         def(PureValue(node, node->validRadixConstant()));
         return;
+
+    case DateGetTime:
+    case DateGetInt32OrNaN: {
+        read(JSDateFields);
+        def(HeapLocation(DateFieldLoc, AbstractHeap(JSDateFields, static_cast<uint64_t>(node->intrinsic())), node->child1()), LazyNode(node));
+        return;
+    }
 
     case DataViewGetFloat:
     case DataViewGetInt: {
         read(MiscFields);
         read(TypedArrayProperties);

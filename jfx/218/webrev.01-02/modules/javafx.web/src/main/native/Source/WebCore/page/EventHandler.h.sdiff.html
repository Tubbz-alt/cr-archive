<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/EventHandler.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="EventHandler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EventSource.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/EventHandler.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2006-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
158     Node* mousePressNode() const { return m_mousePressNode.get(); }
159 
160     WEBCORE_EXPORT void setCapturingMouseEventsElement(Element*);
161 #if ENABLE(POINTER_EVENTS)
162     void pointerCaptureElementDidChange(Element*);
163 #endif
164 
165 #if ENABLE(DRAG_SUPPORT)
166     struct DragTargetResponse {
167         bool accept { false };
168         Optional&lt;DragOperation&gt; operation;
169     };
170     DragTargetResponse updateDragAndDrop(const PlatformMouseEvent&amp;, const std::function&lt;std::unique_ptr&lt;Pasteboard&gt;()&gt;&amp;, DragOperation sourceOperation, bool draggingFiles);
171     void cancelDragAndDrop(const PlatformMouseEvent&amp;, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp;, DragOperation, bool draggingFiles);
172     bool performDragAndDrop(const PlatformMouseEvent&amp;, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp;, DragOperation, bool draggingFiles);
173     void updateDragStateAfterEditDragIfNeeded(Element&amp; rootEditableElement);
174     RefPtr&lt;Element&gt; draggedElement() const;
175 #endif
176 
177     void scheduleHoverStateUpdate();
<span class="line-removed">178 #if ENABLE(CURSOR_SUPPORT)</span>
179     void scheduleCursorUpdate();
<span class="line-removed">180 #endif</span>
181 
182     void setResizingFrameSet(HTMLFrameSetElement*);
183 
184     void resizeLayerDestroyed();
185 
186     IntPoint lastKnownMousePosition() const;
187     IntPoint lastKnownMouseGlobalPosition() const { return m_lastKnownMouseGlobalPosition; }
188     Cursor currentMouseCursor() const { return m_currentMouseCursor; }
189 
190     IntPoint targetPositionInWindowForSelectionAutoscroll() const;
191     bool shouldUpdateAutoscroll();
192 
193     static Frame* subframeForTargetNode(Node*);
194     static Frame* subframeForHitTestResult(const MouseEventWithHitTestResults&amp;);
195 
196     WEBCORE_EXPORT bool scrollOverflow(ScrollDirection, ScrollGranularity, Node* startingNode = nullptr);
197     WEBCORE_EXPORT bool scrollRecursively(ScrollDirection, ScrollGranularity, Node* startingNode = nullptr);
198     WEBCORE_EXPORT bool logicalScrollRecursively(ScrollLogicalDirection, ScrollGranularity, Node* startingNode = nullptr);
199 
200     bool tabsToLinks(KeyboardEvent*) const;
</pre>
<hr />
<pre>
205 
206     void lostMouseCapture();
207 
208     WEBCORE_EXPORT bool handleMousePressEvent(const PlatformMouseEvent&amp;);
209     bool handleMouseMoveEvent(const PlatformMouseEvent&amp;, HitTestResult* hoveredNode = nullptr, bool onlyUpdateScrollbars = false);
210     WEBCORE_EXPORT bool handleMouseReleaseEvent(const PlatformMouseEvent&amp;);
211     bool handleMouseForceEvent(const PlatformMouseEvent&amp;);
212     WEBCORE_EXPORT bool handleWheelEvent(const PlatformWheelEvent&amp;);
213     void defaultWheelEventHandler(Node*, WheelEvent&amp;);
214     bool handlePasteGlobalSelection(const PlatformMouseEvent&amp;);
215 
216     void platformPrepareForWheelEvents(const PlatformWheelEvent&amp;, const HitTestResult&amp;, RefPtr&lt;Element&gt;&amp; eventTarget, RefPtr&lt;ContainerNode&gt;&amp; scrollableContainer, WeakPtr&lt;ScrollableArea&gt;&amp;, bool&amp; isOverWidget);
217     void platformRecordWheelEvent(const PlatformWheelEvent&amp;);
218     bool platformCompleteWheelEvent(const PlatformWheelEvent&amp;, ContainerNode* scrollableContainer, const WeakPtr&lt;ScrollableArea&gt;&amp;);
219     bool platformCompletePlatformWidgetWheelEvent(const PlatformWheelEvent&amp;, const Widget&amp;, ContainerNode* scrollableContainer);
220     void platformNotifyIfEndGesture(const PlatformWheelEvent&amp;, const WeakPtr&lt;ScrollableArea&gt;&amp;);
221 
222 #if ENABLE(IOS_TOUCH_EVENTS) || ENABLE(IOS_GESTURE_EVENTS)
223     using TouchArray = Vector&lt;RefPtr&lt;Touch&gt;&gt;;
224     using EventTargetTouchMap = HashMap&lt;EventTarget*, TouchArray*&gt;;

225 #endif
226 
227 #if ENABLE(IOS_TOUCH_EVENTS) || ENABLE(IOS_GESTURE_EVENTS) || ENABLE(MAC_GESTURE_EVENTS)
228     using EventTargetSet = HashSet&lt;RefPtr&lt;EventTarget&gt;&gt;;
229 #endif
230 
231 #if ENABLE(IOS_TOUCH_EVENTS)
232     bool dispatchTouchEvent(const PlatformTouchEvent&amp;, const AtomString&amp;, const EventTargetTouchMap&amp;, float, float);

233     bool dispatchSimulatedTouchEvent(IntPoint location);
234     Frame* touchEventTargetSubframe() const { return m_touchEventTargetSubframe.get(); }
235     const TouchArray&amp; touches() const { return m_touches; }
236 #endif
237 
238 #if ENABLE(IOS_GESTURE_EVENTS)
239     bool dispatchGestureEvent(const PlatformTouchEvent&amp;, const AtomString&amp;, const EventTargetSet&amp;, float, float);
240 #elif ENABLE(MAC_GESTURE_EVENTS)
241     bool dispatchGestureEvent(const PlatformGestureEvent&amp;, const AtomString&amp;, const EventTargetSet&amp;, float, float);
242     WEBCORE_EXPORT bool handleGestureEvent(const PlatformGestureEvent&amp;);
243 #endif
244 
245 #if PLATFORM(IOS_FAMILY)
246     void defaultTouchEventHandler(Node&amp;, TouchEvent&amp;);
247     WEBCORE_EXPORT void dispatchSyntheticMouseOut(const PlatformMouseEvent&amp;);
248     WEBCORE_EXPORT void dispatchSyntheticMouseMove(const PlatformMouseEvent&amp;);
249 #endif
250 
<span class="line-modified">251 #if ENABLE(CONTEXT_MENUS)</span>
252     WEBCORE_EXPORT bool sendContextMenuEvent(const PlatformMouseEvent&amp;);
253     WEBCORE_EXPORT bool sendContextMenuEventForKey();
254 #endif
255 
256     void setMouseDownMayStartAutoscroll() { m_mouseDownMayStartAutoscroll = true; }
257 
258     bool needsKeyboardEventDisambiguationQuirks() const;
259 
260     WEBCORE_EXPORT static OptionSet&lt;PlatformEvent::Modifier&gt; accessKeyModifiers();
261     WEBCORE_EXPORT bool handleAccessKey(const PlatformKeyboardEvent&amp;);
262     WEBCORE_EXPORT bool keyEvent(const PlatformKeyboardEvent&amp;);
263     void defaultKeyboardEventHandler(KeyboardEvent&amp;);
264     WEBCORE_EXPORT void capsLockStateMayHaveChanged() const;
265 
266     bool accessibilityPreventsEventPropagation(KeyboardEvent&amp;);
267     WEBCORE_EXPORT void handleKeyboardSelectionMovementForAccessibility(KeyboardEvent&amp;);
268 
269     bool handleTextInputEvent(const String&amp; text, Event* underlyingEvent = nullptr, TextEventInputType = TextEventInputKeyboard);
270     void defaultTextInputEventHandler(TextEvent&amp;);
271 
</pre>
<hr />
<pre>
324     WEBCORE_EXPORT bool handleTouchEvent(const PlatformTouchEvent&amp;);
325 #endif
326 
327     bool useHandCursor(Node*, bool isOverLink, bool shiftKey);
328     void updateCursor();
329 
330     bool isHandlingWheelEvent() const { return m_isHandlingWheelEvent; }
331 
332     WEBCORE_EXPORT void setImmediateActionStage(ImmediateActionStage stage);
333     ImmediateActionStage immediateActionStage() const { return m_immediateActionStage; }
334 
335     static Widget* widgetForEventTarget(Element* eventTarget);
336 
337 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(DRAG_SUPPORT)
338     WEBCORE_EXPORT bool tryToBeginDragAtPoint(const IntPoint&amp; clientPosition, const IntPoint&amp; globalPosition);
339 #endif
340 
341 #if PLATFORM(IOS_FAMILY)
342     WEBCORE_EXPORT void startSelectionAutoscroll(RenderObject* renderer, const FloatPoint&amp; positionInWindow);
343     WEBCORE_EXPORT void cancelSelectionAutoscroll();
<span class="line-removed">344     IntPoint m_targetAutoscrollPositionInWindow;</span>
<span class="line-removed">345     bool m_isAutoscrolling { false };</span>
346 #endif
347 


348 private:
349 #if ENABLE(DRAG_SUPPORT)
350     static DragState&amp; dragState();
351     static const Seconds TextDragDelay;
352 #endif
353 
354     bool eventActivatedView(const PlatformMouseEvent&amp;) const;
355     bool updateSelectionForMouseDownDispatchingSelectStart(Node*, const VisibleSelection&amp;, TextGranularity);
356     void selectClosestWordFromHitTestResult(const HitTestResult&amp;, AppendTrailingWhitespace);
357     VisibleSelection selectClosestWordFromHitTestResultBasedOnLookup(const HitTestResult&amp;);
358     void selectClosestWordFromMouseEvent(const MouseEventWithHitTestResults&amp;);
359     void selectClosestContextualWordFromMouseEvent(const MouseEventWithHitTestResults&amp;);
360     void selectClosestContextualWordOrLinkFromMouseEvent(const MouseEventWithHitTestResults&amp;);
361 
362     bool handleMouseDoubleClickEvent(const PlatformMouseEvent&amp;);
363 
364     WEBCORE_EXPORT bool handleMousePressEvent(const MouseEventWithHitTestResults&amp;);
365     bool handleMousePressEventSingleClick(const MouseEventWithHitTestResults&amp;);
366     bool handleMousePressEventDoubleClick(const MouseEventWithHitTestResults&amp;);
367     bool handleMousePressEventTripleClick(const MouseEventWithHitTestResults&amp;);
368 
369 #if ENABLE(DRAG_SUPPORT)
370     bool handleMouseDraggedEvent(const MouseEventWithHitTestResults&amp;, CheckDragHysteresis = ShouldCheckDragHysteresis);
371     bool shouldAllowMouseDownToStartDrag() const;
372 #endif
373 
374     WEBCORE_EXPORT bool handleMouseReleaseEvent(const MouseEventWithHitTestResults&amp;);
375 
376     bool internalKeyEvent(const PlatformKeyboardEvent&amp;);
377 
<span class="line-removed">378     Optional&lt;Cursor&gt; selectCursor(const HitTestResult&amp;, bool shiftKey);</span>
379     void updateCursor(FrameView&amp;, const HitTestResult&amp;, bool shiftKey);
380 
381     void hoverTimerFired();
<span class="line-removed">382 </span>
<span class="line-removed">383 #if ENABLE(CURSOR_SUPPORT)</span>
384     void cursorUpdateTimerFired();
<span class="line-removed">385 #endif</span>
386 
387     bool logicalScrollOverflow(ScrollLogicalDirection, ScrollGranularity, Node* startingNode = nullptr);
388 
389     bool shouldSwapScrollDirection(const HitTestResult&amp;, const PlatformWheelEvent&amp;) const;
390 
391     bool mouseDownMayStartSelect() const { return m_mouseDownMayStartSelect; }
392 
393     static bool isKeyboardOptionTab(KeyboardEvent&amp;);
394     static bool eventInvertsTabsToLinksClientCallResult(KeyboardEvent&amp;);
395 
396 #if !ENABLE(IOS_TOUCH_EVENTS)
397     void fakeMouseMoveEventTimerFired();
398     void cancelFakeMouseMoveEvent();
399 #endif
400 
401     bool isInsideScrollbar(const IntPoint&amp;) const;
402 
403 #if ENABLE(TOUCH_EVENTS)
404     bool dispatchSyntheticTouchEventIfEnabled(const PlatformMouseEvent&amp;);
405 #endif
</pre>
<hr />
<pre>
413     enum class FireMouseOverOut { No, Yes };
414     void updateMouseEventTargetNode(Node*, const PlatformMouseEvent&amp;, FireMouseOverOut);
415 
416     MouseEventWithHitTestResults prepareMouseEvent(const HitTestRequest&amp;, const PlatformMouseEvent&amp;);
417 
418     bool dispatchMouseEvent(const AtomString&amp; eventType, Node* target, bool cancelable, int clickCount, const PlatformMouseEvent&amp;, bool setUnder);
419 
420 #if ENABLE(DRAG_SUPPORT)
421     bool dispatchDragEvent(const AtomString&amp; eventType, Element&amp; target, const PlatformMouseEvent&amp;, DataTransfer&amp;);
422     DragTargetResponse dispatchDragEnterOrDragOverEvent(const AtomString&amp; eventType, Element&amp; target, const PlatformMouseEvent&amp;, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; , DragOperation, bool draggingFiles);
423     void invalidateDataTransfer();
424 
425     bool handleDrag(const MouseEventWithHitTestResults&amp;, CheckDragHysteresis);
426 #endif
427 
428     bool handleMouseUp(const MouseEventWithHitTestResults&amp;);
429 
430 #if ENABLE(DRAG_SUPPORT)
431     void clearDragState();
432 
<span class="line-modified">433     void dispatchDragSrcEvent(const AtomString&amp; eventType, const PlatformMouseEvent&amp;);</span>

434     bool dispatchDragStartEventOnSourceElement(DataTransfer&amp;);
435 
436     bool dragHysteresisExceeded(const FloatPoint&amp;) const;
437     bool dragHysteresisExceeded(const IntPoint&amp;) const;
438 #endif
439 
440     bool mouseMovementExceedsThreshold(const FloatPoint&amp;, int pointsThreshold) const;
441 
442     bool passMousePressEventToSubframe(MouseEventWithHitTestResults&amp;, Frame* subframe);
443     bool passMouseMoveEventToSubframe(MouseEventWithHitTestResults&amp;, Frame* subframe, HitTestResult* hoveredNode = nullptr);
444     bool passMouseReleaseEventToSubframe(MouseEventWithHitTestResults&amp;, Frame* subframe);
445 
446     bool passSubframeEventToSubframe(MouseEventWithHitTestResults&amp;, Frame* subframe, HitTestResult* hoveredNode = nullptr);
447 
448     bool passMousePressEventToScrollbar(MouseEventWithHitTestResults&amp;, Scrollbar*);
449 
450     bool passWidgetMouseDownEventToWidget(const MouseEventWithHitTestResults&amp;);
451     bool passWidgetMouseDownEventToWidget(RenderWidget*);
452 
453     bool passMouseDownEventToWidget(Widget*);
</pre>
<hr />
<pre>
486     PlatformMouseEvent currentPlatformMouseEvent() const;
487 #endif
488 
489 #if ENABLE(FULLSCREEN_API)
490     bool isKeyEventAllowedInFullScreen(const PlatformKeyboardEvent&amp;) const;
491 #endif
492 
493     void setLastKnownMousePosition(const PlatformMouseEvent&amp;);
494 
495 #if ENABLE(CURSOR_VISIBILITY)
496     void startAutoHideCursorTimer();
497     void cancelAutoHideCursorTimer();
498     void autoHideCursorTimerFired();
499 #endif
500 
501     void clearOrScheduleClearingLatchedStateIfNeeded(const PlatformWheelEvent&amp;);
502     void clearLatchedState();
503 
504     bool shouldSendMouseEventsToInactiveWindows() const;
505 


506     Frame&amp; m_frame;
507 
508     bool m_mousePressed { false };
509     bool m_capturesDragging { false };
510     RefPtr&lt;Node&gt; m_mousePressNode;
511 
512     bool m_mouseDownMayStartSelect { false };
513 
514 #if ENABLE(DRAG_SUPPORT)
515     bool m_mouseDownMayStartDrag { false };
516     bool m_dragMayStartSelectionInstead { false };
517 #endif
518 
519     bool m_mouseDownWasSingleClickInSelection { false };
520     enum SelectionInitiationState { HaveNotStartedSelection, PlacedCaret, ExtendedSelection };
521     SelectionInitiationState m_selectionInitiationState { HaveNotStartedSelection };
522 
523 #if ENABLE(DRAG_SUPPORT)
524     LayoutPoint m_dragStartPosition;
525 #endif
526 
527     Timer m_hoverTimer;
<span class="line-removed">528 </span>
<span class="line-removed">529 #if ENABLE(CURSOR_SUPPORT)</span>
530     Timer m_cursorUpdateTimer;
<span class="line-removed">531 #endif</span>
532 
533 #if PLATFORM(MAC)
534     Timer m_pendingMomentumWheelEventsTimer;
535 #endif
536 
537     std::unique_ptr&lt;AutoscrollController&gt; m_autoscrollController;
538     bool m_mouseDownMayStartAutoscroll { false };
539     bool m_mouseDownWasInSubframe { false };
540 
541 #if !ENABLE(IOS_TOUCH_EVENTS)
542     Timer m_fakeMouseMoveEventTimer;
543 #endif
544 
545     bool m_svgPan { false };
546 
547     RenderLayer* m_resizeLayer { nullptr };
548 
549     RefPtr&lt;Element&gt; m_capturingMouseEventsElement;
550     bool m_eventHandlerWillResetCapturingMouseEventsElement { false };
551 
</pre>
<hr />
<pre>
613     TouchTargetMap m_originatingTouchPointTargets;
614     RefPtr&lt;Document&gt; m_originatingTouchPointDocument;
615     unsigned m_originatingTouchPointTargetKey { 0 };
616     bool m_touchPressed { false };
617 #endif
618 
619 #if ENABLE(IOS_TOUCH_EVENTS)
620     unsigned touchIdentifierForMouseEvents { 0 };
621 #endif
622 
623 #if ENABLE(POINTER_EVENTS) &amp;&amp; ENABLE(IOS_TOUCH_EVENTS)
624     unsigned m_touchIdentifierForPrimaryTouch { 0 };
625 #endif
626 
627     double m_maxMouseMovedDuration { 0 };
628     bool m_didStartDrag { false };
629     bool m_isHandlingWheelEvent { false };
630 
631 #if PLATFORM(IOS_FAMILY)
632     bool m_shouldAllowMouseDownToStartDrag { false };


633 #endif
634 
635 #if ENABLE(CURSOR_VISIBILITY)
636     Timer m_autoHideCursorTimer;
637 #endif
638 
639     ImmediateActionStage m_immediateActionStage { ImmediateActionStage::None };
640 };
641 
642 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2006-2020 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
158     Node* mousePressNode() const { return m_mousePressNode.get(); }
159 
160     WEBCORE_EXPORT void setCapturingMouseEventsElement(Element*);
161 #if ENABLE(POINTER_EVENTS)
162     void pointerCaptureElementDidChange(Element*);
163 #endif
164 
165 #if ENABLE(DRAG_SUPPORT)
166     struct DragTargetResponse {
167         bool accept { false };
168         Optional&lt;DragOperation&gt; operation;
169     };
170     DragTargetResponse updateDragAndDrop(const PlatformMouseEvent&amp;, const std::function&lt;std::unique_ptr&lt;Pasteboard&gt;()&gt;&amp;, DragOperation sourceOperation, bool draggingFiles);
171     void cancelDragAndDrop(const PlatformMouseEvent&amp;, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp;, DragOperation, bool draggingFiles);
172     bool performDragAndDrop(const PlatformMouseEvent&amp;, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp;, DragOperation, bool draggingFiles);
173     void updateDragStateAfterEditDragIfNeeded(Element&amp; rootEditableElement);
174     RefPtr&lt;Element&gt; draggedElement() const;
175 #endif
176 
177     void scheduleHoverStateUpdate();

178     void scheduleCursorUpdate();

179 
180     void setResizingFrameSet(HTMLFrameSetElement*);
181 
182     void resizeLayerDestroyed();
183 
184     IntPoint lastKnownMousePosition() const;
185     IntPoint lastKnownMouseGlobalPosition() const { return m_lastKnownMouseGlobalPosition; }
186     Cursor currentMouseCursor() const { return m_currentMouseCursor; }
187 
188     IntPoint targetPositionInWindowForSelectionAutoscroll() const;
189     bool shouldUpdateAutoscroll();
190 
191     static Frame* subframeForTargetNode(Node*);
192     static Frame* subframeForHitTestResult(const MouseEventWithHitTestResults&amp;);
193 
194     WEBCORE_EXPORT bool scrollOverflow(ScrollDirection, ScrollGranularity, Node* startingNode = nullptr);
195     WEBCORE_EXPORT bool scrollRecursively(ScrollDirection, ScrollGranularity, Node* startingNode = nullptr);
196     WEBCORE_EXPORT bool logicalScrollRecursively(ScrollLogicalDirection, ScrollGranularity, Node* startingNode = nullptr);
197 
198     bool tabsToLinks(KeyboardEvent*) const;
</pre>
<hr />
<pre>
203 
204     void lostMouseCapture();
205 
206     WEBCORE_EXPORT bool handleMousePressEvent(const PlatformMouseEvent&amp;);
207     bool handleMouseMoveEvent(const PlatformMouseEvent&amp;, HitTestResult* hoveredNode = nullptr, bool onlyUpdateScrollbars = false);
208     WEBCORE_EXPORT bool handleMouseReleaseEvent(const PlatformMouseEvent&amp;);
209     bool handleMouseForceEvent(const PlatformMouseEvent&amp;);
210     WEBCORE_EXPORT bool handleWheelEvent(const PlatformWheelEvent&amp;);
211     void defaultWheelEventHandler(Node*, WheelEvent&amp;);
212     bool handlePasteGlobalSelection(const PlatformMouseEvent&amp;);
213 
214     void platformPrepareForWheelEvents(const PlatformWheelEvent&amp;, const HitTestResult&amp;, RefPtr&lt;Element&gt;&amp; eventTarget, RefPtr&lt;ContainerNode&gt;&amp; scrollableContainer, WeakPtr&lt;ScrollableArea&gt;&amp;, bool&amp; isOverWidget);
215     void platformRecordWheelEvent(const PlatformWheelEvent&amp;);
216     bool platformCompleteWheelEvent(const PlatformWheelEvent&amp;, ContainerNode* scrollableContainer, const WeakPtr&lt;ScrollableArea&gt;&amp;);
217     bool platformCompletePlatformWidgetWheelEvent(const PlatformWheelEvent&amp;, const Widget&amp;, ContainerNode* scrollableContainer);
218     void platformNotifyIfEndGesture(const PlatformWheelEvent&amp;, const WeakPtr&lt;ScrollableArea&gt;&amp;);
219 
220 #if ENABLE(IOS_TOUCH_EVENTS) || ENABLE(IOS_GESTURE_EVENTS)
221     using TouchArray = Vector&lt;RefPtr&lt;Touch&gt;&gt;;
222     using EventTargetTouchMap = HashMap&lt;EventTarget*, TouchArray*&gt;;
<span class="line-added">223     using EventTargetTouchArrayMap = HashMap&lt;Ref&lt;EventTarget&gt;, std::unique_ptr&lt;TouchArray&gt;&gt;;</span>
224 #endif
225 
226 #if ENABLE(IOS_TOUCH_EVENTS) || ENABLE(IOS_GESTURE_EVENTS) || ENABLE(MAC_GESTURE_EVENTS)
227     using EventTargetSet = HashSet&lt;RefPtr&lt;EventTarget&gt;&gt;;
228 #endif
229 
230 #if ENABLE(IOS_TOUCH_EVENTS)
231     bool dispatchTouchEvent(const PlatformTouchEvent&amp;, const AtomString&amp;, const EventTargetTouchMap&amp;, float, float);
<span class="line-added">232     bool dispatchTouchEvent(const PlatformTouchEvent&amp;, const AtomString&amp;, const EventTargetTouchArrayMap&amp;, float, float);</span>
233     bool dispatchSimulatedTouchEvent(IntPoint location);
234     Frame* touchEventTargetSubframe() const { return m_touchEventTargetSubframe.get(); }
235     const TouchArray&amp; touches() const { return m_touches; }
236 #endif
237 
238 #if ENABLE(IOS_GESTURE_EVENTS)
239     bool dispatchGestureEvent(const PlatformTouchEvent&amp;, const AtomString&amp;, const EventTargetSet&amp;, float, float);
240 #elif ENABLE(MAC_GESTURE_EVENTS)
241     bool dispatchGestureEvent(const PlatformGestureEvent&amp;, const AtomString&amp;, const EventTargetSet&amp;, float, float);
242     WEBCORE_EXPORT bool handleGestureEvent(const PlatformGestureEvent&amp;);
243 #endif
244 
245 #if PLATFORM(IOS_FAMILY)
246     void defaultTouchEventHandler(Node&amp;, TouchEvent&amp;);
247     WEBCORE_EXPORT void dispatchSyntheticMouseOut(const PlatformMouseEvent&amp;);
248     WEBCORE_EXPORT void dispatchSyntheticMouseMove(const PlatformMouseEvent&amp;);
249 #endif
250 
<span class="line-modified">251 #if ENABLE(CONTEXT_MENU_EVENT)</span>
252     WEBCORE_EXPORT bool sendContextMenuEvent(const PlatformMouseEvent&amp;);
253     WEBCORE_EXPORT bool sendContextMenuEventForKey();
254 #endif
255 
256     void setMouseDownMayStartAutoscroll() { m_mouseDownMayStartAutoscroll = true; }
257 
258     bool needsKeyboardEventDisambiguationQuirks() const;
259 
260     WEBCORE_EXPORT static OptionSet&lt;PlatformEvent::Modifier&gt; accessKeyModifiers();
261     WEBCORE_EXPORT bool handleAccessKey(const PlatformKeyboardEvent&amp;);
262     WEBCORE_EXPORT bool keyEvent(const PlatformKeyboardEvent&amp;);
263     void defaultKeyboardEventHandler(KeyboardEvent&amp;);
264     WEBCORE_EXPORT void capsLockStateMayHaveChanged() const;
265 
266     bool accessibilityPreventsEventPropagation(KeyboardEvent&amp;);
267     WEBCORE_EXPORT void handleKeyboardSelectionMovementForAccessibility(KeyboardEvent&amp;);
268 
269     bool handleTextInputEvent(const String&amp; text, Event* underlyingEvent = nullptr, TextEventInputType = TextEventInputKeyboard);
270     void defaultTextInputEventHandler(TextEvent&amp;);
271 
</pre>
<hr />
<pre>
324     WEBCORE_EXPORT bool handleTouchEvent(const PlatformTouchEvent&amp;);
325 #endif
326 
327     bool useHandCursor(Node*, bool isOverLink, bool shiftKey);
328     void updateCursor();
329 
330     bool isHandlingWheelEvent() const { return m_isHandlingWheelEvent; }
331 
332     WEBCORE_EXPORT void setImmediateActionStage(ImmediateActionStage stage);
333     ImmediateActionStage immediateActionStage() const { return m_immediateActionStage; }
334 
335     static Widget* widgetForEventTarget(Element* eventTarget);
336 
337 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(DRAG_SUPPORT)
338     WEBCORE_EXPORT bool tryToBeginDragAtPoint(const IntPoint&amp; clientPosition, const IntPoint&amp; globalPosition);
339 #endif
340 
341 #if PLATFORM(IOS_FAMILY)
342     WEBCORE_EXPORT void startSelectionAutoscroll(RenderObject* renderer, const FloatPoint&amp; positionInWindow);
343     WEBCORE_EXPORT void cancelSelectionAutoscroll();


344 #endif
345 
<span class="line-added">346     WEBCORE_EXPORT Optional&lt;Cursor&gt; selectCursor(const HitTestResult&amp;, bool shiftKey);</span>
<span class="line-added">347 </span>
348 private:
349 #if ENABLE(DRAG_SUPPORT)
350     static DragState&amp; dragState();
351     static const Seconds TextDragDelay;
352 #endif
353 
354     bool eventActivatedView(const PlatformMouseEvent&amp;) const;
355     bool updateSelectionForMouseDownDispatchingSelectStart(Node*, const VisibleSelection&amp;, TextGranularity);
356     void selectClosestWordFromHitTestResult(const HitTestResult&amp;, AppendTrailingWhitespace);
357     VisibleSelection selectClosestWordFromHitTestResultBasedOnLookup(const HitTestResult&amp;);
358     void selectClosestWordFromMouseEvent(const MouseEventWithHitTestResults&amp;);
359     void selectClosestContextualWordFromMouseEvent(const MouseEventWithHitTestResults&amp;);
360     void selectClosestContextualWordOrLinkFromMouseEvent(const MouseEventWithHitTestResults&amp;);
361 
362     bool handleMouseDoubleClickEvent(const PlatformMouseEvent&amp;);
363 
364     WEBCORE_EXPORT bool handleMousePressEvent(const MouseEventWithHitTestResults&amp;);
365     bool handleMousePressEventSingleClick(const MouseEventWithHitTestResults&amp;);
366     bool handleMousePressEventDoubleClick(const MouseEventWithHitTestResults&amp;);
367     bool handleMousePressEventTripleClick(const MouseEventWithHitTestResults&amp;);
368 
369 #if ENABLE(DRAG_SUPPORT)
370     bool handleMouseDraggedEvent(const MouseEventWithHitTestResults&amp;, CheckDragHysteresis = ShouldCheckDragHysteresis);
371     bool shouldAllowMouseDownToStartDrag() const;
372 #endif
373 
374     WEBCORE_EXPORT bool handleMouseReleaseEvent(const MouseEventWithHitTestResults&amp;);
375 
376     bool internalKeyEvent(const PlatformKeyboardEvent&amp;);
377 

378     void updateCursor(FrameView&amp;, const HitTestResult&amp;, bool shiftKey);
379 
380     void hoverTimerFired();


381     void cursorUpdateTimerFired();

382 
383     bool logicalScrollOverflow(ScrollLogicalDirection, ScrollGranularity, Node* startingNode = nullptr);
384 
385     bool shouldSwapScrollDirection(const HitTestResult&amp;, const PlatformWheelEvent&amp;) const;
386 
387     bool mouseDownMayStartSelect() const { return m_mouseDownMayStartSelect; }
388 
389     static bool isKeyboardOptionTab(KeyboardEvent&amp;);
390     static bool eventInvertsTabsToLinksClientCallResult(KeyboardEvent&amp;);
391 
392 #if !ENABLE(IOS_TOUCH_EVENTS)
393     void fakeMouseMoveEventTimerFired();
394     void cancelFakeMouseMoveEvent();
395 #endif
396 
397     bool isInsideScrollbar(const IntPoint&amp;) const;
398 
399 #if ENABLE(TOUCH_EVENTS)
400     bool dispatchSyntheticTouchEventIfEnabled(const PlatformMouseEvent&amp;);
401 #endif
</pre>
<hr />
<pre>
409     enum class FireMouseOverOut { No, Yes };
410     void updateMouseEventTargetNode(Node*, const PlatformMouseEvent&amp;, FireMouseOverOut);
411 
412     MouseEventWithHitTestResults prepareMouseEvent(const HitTestRequest&amp;, const PlatformMouseEvent&amp;);
413 
414     bool dispatchMouseEvent(const AtomString&amp; eventType, Node* target, bool cancelable, int clickCount, const PlatformMouseEvent&amp;, bool setUnder);
415 
416 #if ENABLE(DRAG_SUPPORT)
417     bool dispatchDragEvent(const AtomString&amp; eventType, Element&amp; target, const PlatformMouseEvent&amp;, DataTransfer&amp;);
418     DragTargetResponse dispatchDragEnterOrDragOverEvent(const AtomString&amp; eventType, Element&amp; target, const PlatformMouseEvent&amp;, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; , DragOperation, bool draggingFiles);
419     void invalidateDataTransfer();
420 
421     bool handleDrag(const MouseEventWithHitTestResults&amp;, CheckDragHysteresis);
422 #endif
423 
424     bool handleMouseUp(const MouseEventWithHitTestResults&amp;);
425 
426 #if ENABLE(DRAG_SUPPORT)
427     void clearDragState();
428 
<span class="line-modified">429     static bool shouldDispatchEventsToDragSourceElement();</span>
<span class="line-added">430     void dispatchEventToDragSourceElement(const AtomString&amp; eventType, const PlatformMouseEvent&amp;);</span>
431     bool dispatchDragStartEventOnSourceElement(DataTransfer&amp;);
432 
433     bool dragHysteresisExceeded(const FloatPoint&amp;) const;
434     bool dragHysteresisExceeded(const IntPoint&amp;) const;
435 #endif
436 
437     bool mouseMovementExceedsThreshold(const FloatPoint&amp;, int pointsThreshold) const;
438 
439     bool passMousePressEventToSubframe(MouseEventWithHitTestResults&amp;, Frame* subframe);
440     bool passMouseMoveEventToSubframe(MouseEventWithHitTestResults&amp;, Frame* subframe, HitTestResult* hoveredNode = nullptr);
441     bool passMouseReleaseEventToSubframe(MouseEventWithHitTestResults&amp;, Frame* subframe);
442 
443     bool passSubframeEventToSubframe(MouseEventWithHitTestResults&amp;, Frame* subframe, HitTestResult* hoveredNode = nullptr);
444 
445     bool passMousePressEventToScrollbar(MouseEventWithHitTestResults&amp;, Scrollbar*);
446 
447     bool passWidgetMouseDownEventToWidget(const MouseEventWithHitTestResults&amp;);
448     bool passWidgetMouseDownEventToWidget(RenderWidget*);
449 
450     bool passMouseDownEventToWidget(Widget*);
</pre>
<hr />
<pre>
483     PlatformMouseEvent currentPlatformMouseEvent() const;
484 #endif
485 
486 #if ENABLE(FULLSCREEN_API)
487     bool isKeyEventAllowedInFullScreen(const PlatformKeyboardEvent&amp;) const;
488 #endif
489 
490     void setLastKnownMousePosition(const PlatformMouseEvent&amp;);
491 
492 #if ENABLE(CURSOR_VISIBILITY)
493     void startAutoHideCursorTimer();
494     void cancelAutoHideCursorTimer();
495     void autoHideCursorTimerFired();
496 #endif
497 
498     void clearOrScheduleClearingLatchedStateIfNeeded(const PlatformWheelEvent&amp;);
499     void clearLatchedState();
500 
501     bool shouldSendMouseEventsToInactiveWindows() const;
502 
<span class="line-added">503     bool canMouseDownStartSelect(const MouseEventWithHitTestResults&amp;);</span>
<span class="line-added">504 </span>
505     Frame&amp; m_frame;
506 
507     bool m_mousePressed { false };
508     bool m_capturesDragging { false };
509     RefPtr&lt;Node&gt; m_mousePressNode;
510 
511     bool m_mouseDownMayStartSelect { false };
512 
513 #if ENABLE(DRAG_SUPPORT)
514     bool m_mouseDownMayStartDrag { false };
515     bool m_dragMayStartSelectionInstead { false };
516 #endif
517 
518     bool m_mouseDownWasSingleClickInSelection { false };
519     enum SelectionInitiationState { HaveNotStartedSelection, PlacedCaret, ExtendedSelection };
520     SelectionInitiationState m_selectionInitiationState { HaveNotStartedSelection };
521 
522 #if ENABLE(DRAG_SUPPORT)
523     LayoutPoint m_dragStartPosition;
524 #endif
525 
526     Timer m_hoverTimer;


527     Timer m_cursorUpdateTimer;

528 
529 #if PLATFORM(MAC)
530     Timer m_pendingMomentumWheelEventsTimer;
531 #endif
532 
533     std::unique_ptr&lt;AutoscrollController&gt; m_autoscrollController;
534     bool m_mouseDownMayStartAutoscroll { false };
535     bool m_mouseDownWasInSubframe { false };
536 
537 #if !ENABLE(IOS_TOUCH_EVENTS)
538     Timer m_fakeMouseMoveEventTimer;
539 #endif
540 
541     bool m_svgPan { false };
542 
543     RenderLayer* m_resizeLayer { nullptr };
544 
545     RefPtr&lt;Element&gt; m_capturingMouseEventsElement;
546     bool m_eventHandlerWillResetCapturingMouseEventsElement { false };
547 
</pre>
<hr />
<pre>
609     TouchTargetMap m_originatingTouchPointTargets;
610     RefPtr&lt;Document&gt; m_originatingTouchPointDocument;
611     unsigned m_originatingTouchPointTargetKey { 0 };
612     bool m_touchPressed { false };
613 #endif
614 
615 #if ENABLE(IOS_TOUCH_EVENTS)
616     unsigned touchIdentifierForMouseEvents { 0 };
617 #endif
618 
619 #if ENABLE(POINTER_EVENTS) &amp;&amp; ENABLE(IOS_TOUCH_EVENTS)
620     unsigned m_touchIdentifierForPrimaryTouch { 0 };
621 #endif
622 
623     double m_maxMouseMovedDuration { 0 };
624     bool m_didStartDrag { false };
625     bool m_isHandlingWheelEvent { false };
626 
627 #if PLATFORM(IOS_FAMILY)
628     bool m_shouldAllowMouseDownToStartDrag { false };
<span class="line-added">629     IntPoint m_targetAutoscrollPositionInWindow;</span>
<span class="line-added">630     bool m_isAutoscrolling { false };</span>
631 #endif
632 
633 #if ENABLE(CURSOR_VISIBILITY)
634     Timer m_autoHideCursorTimer;
635 #endif
636 
637     ImmediateActionStage m_immediateActionStage { ImmediateActionStage::None };
638 };
639 
640 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="EventHandler.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="EventSource.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
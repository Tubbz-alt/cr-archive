<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/editing/MarkupAccumulator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InsertListCommand.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderedPosition.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/editing/MarkupAccumulator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
133 {
134     if (syntax != SerializationSyntax::XML &amp;&amp; element.document().isHTMLDocument())
135         return false;
136     if (element.hasChildNodes())
137         return false;
138     if (element.isHTMLElement() &amp;&amp; !elementCannotHaveEndTag(element))
139         return false;
140     return true;
141 }
142 
143 template&lt;typename CharacterType&gt;
144 static inline void appendCharactersReplacingEntitiesInternal(StringBuilder&amp; result, const String&amp; source, unsigned offset, unsigned length, EntityMask entityMask)
145 {
146     const CharacterType* text = source.characters&lt;CharacterType&gt;() + offset;
147 
148     size_t positionAfterLastEntity = 0;
149     for (size_t i = 0; i &lt; length; ++i) {
150         CharacterType character = text[i];
151         uint8_t substitution = character &lt; WTF_ARRAY_LENGTH(entityMap) ? entityMap[character] : static_cast&lt;uint8_t&gt;(EntitySubstitutionNullIndex);
152         if (UNLIKELY(substitution != EntitySubstitutionNullIndex) &amp;&amp; entitySubstitutionList[substitution].mask &amp; entityMask) {
<span class="line-modified">153             result.appendCharacters(text + positionAfterLastEntity, i - positionAfterLastEntity);</span>
154             result.appendCharacters(entitySubstitutionList[substitution].characters, entitySubstitutionList[substitution].length);
155             positionAfterLastEntity = i + 1;
156         }
157     }
<span class="line-modified">158     result.appendCharacters(text + positionAfterLastEntity, length - positionAfterLastEntity);</span>
159 }
160 
161 void MarkupAccumulator::appendCharactersReplacingEntities(StringBuilder&amp; result, const String&amp; source, unsigned offset, unsigned length, EntityMask entityMask)
162 {
163     if (!(offset + length))
164         return;
165 
166     ASSERT(offset + length &lt;= source.length());
167 
168     if (source.is8Bit())
169         appendCharactersReplacingEntitiesInternal&lt;LChar&gt;(result, source, offset, length, entityMask);
170     else
171         appendCharactersReplacingEntitiesInternal&lt;UChar&gt;(result, source, offset, length, entityMask);
172 }
173 
174 MarkupAccumulator::MarkupAccumulator(Vector&lt;Node*&gt;* nodes, ResolveURLs resolveURLs, SerializationSyntax serializationSyntax)
175     : m_nodes(nodes)
176     , m_resolveURLs(resolveURLs)
177     , m_serializationSyntax(serializationSyntax)
178 {
</pre>
<hr />
<pre>
334     if (attribute.name().localName() == xmlnsAtom() &amp;&amp; (attribute.namespaceURI().isEmpty() || attribute.namespaceURI() == XMLNSNames::xmlnsNamespaceURI)) {
335         namespaces.set(emptyAtom().impl(), attribute.value().impl());
336         return false;
337     }
338 
339     QualifiedName xmlnsPrefixAttr(xmlnsAtom(), attribute.localName(), XMLNSNames::xmlnsNamespaceURI);
340     if (attribute.name() == xmlnsPrefixAttr) {
341         namespaces.set(attribute.localName().impl(), attribute.value().impl());
342         namespaces.set(attribute.value().impl(), attribute.localName().impl());
343         return false;
344     }
345 
346     return true;
347 }
348 
349 void MarkupAccumulator::appendNamespace(StringBuilder&amp; result, const AtomString&amp; prefix, const AtomString&amp; namespaceURI, Namespaces&amp; namespaces, bool allowEmptyDefaultNS)
350 {
351     namespaces.checkConsistency();
352     if (namespaceURI.isEmpty()) {
353         // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-xhtml-syntax.html#xml-fragment-serialization-algorithm
<span class="line-modified">354         if (allowEmptyDefaultNS &amp;&amp; namespaces.get(emptyAtom().impl())) {</span>
<span class="line-modified">355             result.append(&#39; &#39;);</span>
<span class="line-removed">356             result.append(xmlnsAtom().string());</span>
<span class="line-removed">357             result.appendLiteral(&quot;=\&quot;\&quot;&quot;);</span>
<span class="line-removed">358         }</span>
359         return;
360     }
361 
362     // Use emptyAtom()s&#39;s impl() for both null and empty strings since the HashMap can&#39;t handle 0 as a key
363     AtomStringImpl* pre = prefix.isEmpty() ? emptyAtom().impl() : prefix.impl();
364     AtomStringImpl* foundNS = namespaces.get(pre);
365     if (foundNS != namespaceURI.impl()) {
366         namespaces.set(pre, namespaceURI.impl());
367         // Add namespace to prefix pair so we can do constraint checking later.
368         if (inXMLFragmentSerialization() &amp;&amp; !prefix.isEmpty())
369             namespaces.set(namespaceURI.impl(), pre);
370         // Make sure xml prefix and namespace are always known to uphold the constraints listed at http://www.w3.org/TR/xml-names11/#xmlReserved.
371         if (namespaceURI.impl() == XMLNames::xmlNamespaceURI-&gt;impl())
372             return;
<span class="line-modified">373         result.append(&#39; &#39;);</span>
<span class="line-modified">374         result.append(xmlnsAtom().string());</span>
<span class="line-modified">375         if (!prefix.isEmpty()) {</span>
<span class="line-removed">376             result.append(&#39;:&#39;);</span>
<span class="line-removed">377             result.append(prefix);</span>
<span class="line-removed">378         }</span>
379 
380         result.append(&#39;=&#39;);
381         result.append(&#39;&quot;&#39;);
382         appendAttributeValue(result, namespaceURI, false);
383         result.append(&#39;&quot;&#39;);
384     }
385 }
386 
387 EntityMask MarkupAccumulator::entityMaskForText(const Text&amp; text) const
388 {
<span class="line-modified">389     if (!text.document().isHTMLDocument())</span>
390         return EntityMaskInPCDATA;
391 
392     const QualifiedName* parentName = nullptr;
393     if (text.parentElement())
394         parentName = &amp;text.parentElement()-&gt;tagQName();
395 
396     if (parentName &amp;&amp; (*parentName == scriptTag || *parentName == styleTag || *parentName == xmpTag))
397         return EntityMaskInCDATA;
398     return EntityMaskInHTMLPCDATA;
399 }
400 
401 void MarkupAccumulator::appendText(StringBuilder&amp; result, const Text&amp; text)
402 {
403     const String&amp; textData = text.data();
404     appendCharactersReplacingEntities(result, textData, 0, textData.length(), entityMaskForText(text));
405 }
406 
407 static void appendComment(StringBuilder&amp; result, const String&amp; comment)
408 {
409     // FIXME: Comment content is not escaped, but XMLSerializer (and possibly other callers) should raise an exception if it includes &quot;--&gt;&quot;.
</pre>
</td>
<td>
<hr />
<pre>
133 {
134     if (syntax != SerializationSyntax::XML &amp;&amp; element.document().isHTMLDocument())
135         return false;
136     if (element.hasChildNodes())
137         return false;
138     if (element.isHTMLElement() &amp;&amp; !elementCannotHaveEndTag(element))
139         return false;
140     return true;
141 }
142 
143 template&lt;typename CharacterType&gt;
144 static inline void appendCharactersReplacingEntitiesInternal(StringBuilder&amp; result, const String&amp; source, unsigned offset, unsigned length, EntityMask entityMask)
145 {
146     const CharacterType* text = source.characters&lt;CharacterType&gt;() + offset;
147 
148     size_t positionAfterLastEntity = 0;
149     for (size_t i = 0; i &lt; length; ++i) {
150         CharacterType character = text[i];
151         uint8_t substitution = character &lt; WTF_ARRAY_LENGTH(entityMap) ? entityMap[character] : static_cast&lt;uint8_t&gt;(EntitySubstitutionNullIndex);
152         if (UNLIKELY(substitution != EntitySubstitutionNullIndex) &amp;&amp; entitySubstitutionList[substitution].mask &amp; entityMask) {
<span class="line-modified">153             result.appendSubstring(source, offset + positionAfterLastEntity, i - positionAfterLastEntity);</span>
154             result.appendCharacters(entitySubstitutionList[substitution].characters, entitySubstitutionList[substitution].length);
155             positionAfterLastEntity = i + 1;
156         }
157     }
<span class="line-modified">158     result.appendSubstring(source, offset + positionAfterLastEntity, length - positionAfterLastEntity);</span>
159 }
160 
161 void MarkupAccumulator::appendCharactersReplacingEntities(StringBuilder&amp; result, const String&amp; source, unsigned offset, unsigned length, EntityMask entityMask)
162 {
163     if (!(offset + length))
164         return;
165 
166     ASSERT(offset + length &lt;= source.length());
167 
168     if (source.is8Bit())
169         appendCharactersReplacingEntitiesInternal&lt;LChar&gt;(result, source, offset, length, entityMask);
170     else
171         appendCharactersReplacingEntitiesInternal&lt;UChar&gt;(result, source, offset, length, entityMask);
172 }
173 
174 MarkupAccumulator::MarkupAccumulator(Vector&lt;Node*&gt;* nodes, ResolveURLs resolveURLs, SerializationSyntax serializationSyntax)
175     : m_nodes(nodes)
176     , m_resolveURLs(resolveURLs)
177     , m_serializationSyntax(serializationSyntax)
178 {
</pre>
<hr />
<pre>
334     if (attribute.name().localName() == xmlnsAtom() &amp;&amp; (attribute.namespaceURI().isEmpty() || attribute.namespaceURI() == XMLNSNames::xmlnsNamespaceURI)) {
335         namespaces.set(emptyAtom().impl(), attribute.value().impl());
336         return false;
337     }
338 
339     QualifiedName xmlnsPrefixAttr(xmlnsAtom(), attribute.localName(), XMLNSNames::xmlnsNamespaceURI);
340     if (attribute.name() == xmlnsPrefixAttr) {
341         namespaces.set(attribute.localName().impl(), attribute.value().impl());
342         namespaces.set(attribute.value().impl(), attribute.localName().impl());
343         return false;
344     }
345 
346     return true;
347 }
348 
349 void MarkupAccumulator::appendNamespace(StringBuilder&amp; result, const AtomString&amp; prefix, const AtomString&amp; namespaceURI, Namespaces&amp; namespaces, bool allowEmptyDefaultNS)
350 {
351     namespaces.checkConsistency();
352     if (namespaceURI.isEmpty()) {
353         // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-xhtml-syntax.html#xml-fragment-serialization-algorithm
<span class="line-modified">354         if (allowEmptyDefaultNS &amp;&amp; namespaces.get(emptyAtom().impl()))</span>
<span class="line-modified">355             result.append(&#39; &#39;, xmlnsAtom(), &quot;=\&quot;\&quot;&quot;);</span>



356         return;
357     }
358 
359     // Use emptyAtom()s&#39;s impl() for both null and empty strings since the HashMap can&#39;t handle 0 as a key
360     AtomStringImpl* pre = prefix.isEmpty() ? emptyAtom().impl() : prefix.impl();
361     AtomStringImpl* foundNS = namespaces.get(pre);
362     if (foundNS != namespaceURI.impl()) {
363         namespaces.set(pre, namespaceURI.impl());
364         // Add namespace to prefix pair so we can do constraint checking later.
365         if (inXMLFragmentSerialization() &amp;&amp; !prefix.isEmpty())
366             namespaces.set(namespaceURI.impl(), pre);
367         // Make sure xml prefix and namespace are always known to uphold the constraints listed at http://www.w3.org/TR/xml-names11/#xmlReserved.
368         if (namespaceURI.impl() == XMLNames::xmlNamespaceURI-&gt;impl())
369             return;
<span class="line-modified">370         result.append(&#39; &#39;, xmlnsAtom());</span>
<span class="line-modified">371         if (!prefix.isEmpty())</span>
<span class="line-modified">372             result.append(&#39;:&#39;, prefix);</span>



373 
374         result.append(&#39;=&#39;);
375         result.append(&#39;&quot;&#39;);
376         appendAttributeValue(result, namespaceURI, false);
377         result.append(&#39;&quot;&#39;);
378     }
379 }
380 
381 EntityMask MarkupAccumulator::entityMaskForText(const Text&amp; text) const
382 {
<span class="line-modified">383     if (!text.document().isHTMLDocument() || inXMLFragmentSerialization())</span>
384         return EntityMaskInPCDATA;
385 
386     const QualifiedName* parentName = nullptr;
387     if (text.parentElement())
388         parentName = &amp;text.parentElement()-&gt;tagQName();
389 
390     if (parentName &amp;&amp; (*parentName == scriptTag || *parentName == styleTag || *parentName == xmpTag))
391         return EntityMaskInCDATA;
392     return EntityMaskInHTMLPCDATA;
393 }
394 
395 void MarkupAccumulator::appendText(StringBuilder&amp; result, const Text&amp; text)
396 {
397     const String&amp; textData = text.data();
398     appendCharactersReplacingEntities(result, textData, 0, textData.length(), entityMaskForText(text));
399 }
400 
401 static void appendComment(StringBuilder&amp; result, const String&amp; comment)
402 {
403     // FIXME: Comment content is not escaped, but XMLSerializer (and possibly other callers) should raise an exception if it includes &quot;--&gt;&quot;.
</pre>
</td>
</tr>
</table>
<center><a href="InsertListCommand.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderedPosition.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/java/MediaPlayerPrivateJava.cpp b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/java/MediaPlayerPrivateJava.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/java/MediaPlayerPrivateJava.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/java/MediaPlayerPrivateJava.cpp
@@ -70,39 +70,39 @@
     #include <stdio.h>
     #include <wtf/Threading.h>
 
     const char* networkStateStr(MediaPlayer::NetworkState networkState) {
         switch (networkState) {
-        case MediaPlayer::Empty:
+        case MediaPlayer::NetworkState::Empty:
             return "Empty";
-        case MediaPlayer::Idle:
+        case MediaPlayer::NetworkState::Idle:
             return "Idle";
-        case MediaPlayer::Loading:
+        case MediaPlayer::NetworkState::Loading:
             return "Loading";
-        case MediaPlayer::Loaded:
+        case MediaPlayer::NetworkState::Loaded:
             return "Loaded";
-        case MediaPlayer::FormatError:
+        case MediaPlayer::NetworkState::FormatError:
             return "FormatError";
-        case MediaPlayer::NetworkError:
+        case MediaPlayer::NetworkState::NetworkError:
             return "NetworkError";
-        case MediaPlayer::DecodeError:
+        case MediaPlayer::NetworkState::DecodeError:
             return "DecodeError";
         }
         return "<unknown network state>";
     }
 
     const char* readyStateStr(MediaPlayer::ReadyState readyState) {
         switch (readyState) {
-        case MediaPlayer::HaveNothing:
+        case MediaPlayer::ReadyState::HaveNothing:
             return "HaveNothing";
-        case MediaPlayer::HaveMetadata:
+        case MediaPlayer::ReadyState::HaveMetadata:
             return "HaveMetadata";
-        case MediaPlayer::HaveCurrentData:
+        case MediaPlayer::ReadyState::HaveCurrentData:
             return "HaveCurrentData";
-        case MediaPlayer::HaveFutureData:
+        case MediaPlayer::ReadyState::HaveFutureData:
             return "HaveFutureData";
-        case MediaPlayer::HaveEnoughData:
+        case MediaPlayer::ReadyState::HaveEnoughData:
             return "HaveEnoughData";
         }
         return "<unknown ready state>";
     }
 
@@ -161,26 +161,41 @@
 
 #endif
 
 ////////////////////////
 
+class MediaPlayerFactoryJava final : public MediaPlayerFactory {
+private:
+    MediaPlayerEnums::MediaEngineIdentifier identifier() const final { return MediaPlayerEnums::MediaEngineIdentifier::MediaFoundation; };
 
+    std::unique_ptr<MediaPlayerPrivateInterface> createMediaEnginePlayer(MediaPlayer* player) const final
+    {
+        return makeUnique<MediaPlayerPrivate>(player);
+    }
 
+    void getSupportedTypes(HashSet<String, ASCIICaseInsensitiveHash>& types) const final
+    {
+        return MediaPlayerPrivate::MediaEngineSupportedTypes(types);
+    }
+
+    MediaPlayer::SupportsType supportsTypeAndCodecs(const MediaEngineSupportParameters& parameters) const final
+    {
+        return MediaPlayerPrivate::MediaEngineSupportsType(parameters);
+    }
+};
 
 void MediaPlayerPrivate::registerMediaEngine(MediaEngineRegistrar registrar)
 {
     LOG_TRACE0(">>registerMediaEngine\n");
     JNIEnv* env = WTF::GetJavaEnv();
     jclass playerCls = PG_GetMediaPlayerClass(env);
     if (!playerCls) {
         LOG_ERROR0("<<registerMediaEngine ERROR: MediaPlayer class is unavailable\n");
         return;
     }
-    //CreateMediaEnginePlayer, MediaEngineSupportedTypes, MediaEngineSupportsType,
-    //MediaEngineGetSitesInMediaCache, MediaEngineClearMediaCache, MediaEngineClearMediaCacheForSite
-    registrar([] (MediaPlayer* player) { return std::unique_ptr<MediaPlayerPrivate>(new MediaPlayerPrivate(player)); },
-        MediaEngineSupportedTypes, MediaEngineSupportsType, 0, 0, 0, 0);
+
+    registrar(makeUnique<MediaPlayerFactoryJava>());
 }
 
 void MediaPlayerPrivate::MediaEngineSupportedTypes(HashSet<String, ASCIICaseInsensitiveHash>& types)
 {
     LOG_TRACE0(">>MediaEngineSupportedTypes\n");
@@ -198,20 +213,20 @@
         LOG_TRACE2(">>MediaEngineSupportsType, type=%s, codecs=%s\n", parameters.type.raw().utf8().data(), codecValue.utf8().data());
     }
 
     if (parameters.type.isEmpty()) {
         LOG_TRACE0("<<MediaEngineSupportsType: NOT supported (type is empty)\n");
-        return MediaPlayer::IsNotSupported;
+        return MediaPlayer::SupportsType::IsNotSupported;
     }
 
     if (GetSupportedTypes().contains(parameters.type.containerType())) {
         LOG_TRACE0("<<MediaEngineSupportsType: MayBeSupported/IsSupported\n");
         auto codecs = parameters.type.parameter(ContentType::codecsParameter());
-        return codecs.isEmpty() ? MediaPlayer::MayBeSupported : MediaPlayer::IsSupported;
+        return codecs.isEmpty() ? MediaPlayer::SupportsType::MayBeSupported : MediaPlayer::SupportsType::IsSupported;
     }
     LOG_TRACE0("<<MediaEngineSupportsType: NOT supported\n");
-    return MediaPlayer::IsNotSupported;
+    return MediaPlayer::SupportsType::IsNotSupported;
 }
 
 HashSet<String, ASCIICaseInsensitiveHash>& MediaPlayerPrivate::GetSupportedTypes()
 {
     static HashSet<String, ASCIICaseInsensitiveHash> supportedTypes;
@@ -245,12 +260,12 @@
 // *********************************************************
 // MediaPlayerPrivate
 // *********************************************************
 MediaPlayerPrivate::MediaPlayerPrivate(MediaPlayer *player)
     : m_player(player)
-    , m_networkState(MediaPlayer::Empty)
-    , m_readyState(MediaPlayer::HaveNothing)
+    , m_networkState(MediaPlayer::NetworkState::Empty)
+    , m_readyState(MediaPlayer::ReadyState::HaveNothing)
     , m_isVisible(false)
     , m_hasVideo(false)
     , m_hasAudio(false)
     , m_paused(true)
     , m_seeking(false)
@@ -284,11 +299,11 @@
     WTF::CheckAndClearException(env);
 }
 
 void MediaPlayerPrivate::load(const String& url)
 {
-    if (m_networkState == MediaPlayer::Loading) {
+    if (m_networkState == MediaPlayer::NetworkState::Loading) {
         cancelLoad();
     }
 
     String userAgent;
     // MediaPlayerClient mpClient = m_player->client();
@@ -584,13 +599,13 @@
 void MediaPlayerPrivate::setPreload(MediaPlayer::Preload preload)
 {
     // enum Preload { None, MetaData, Auto };
     PLOG_TRACE1("MediaPlayerPrivate setPreload, preload=%u\n", (int)preload);
     jint jPreload =
-        (preload == MediaPlayer::None) ? com_sun_webkit_graphics_WCMediaPlayer_PRELOAD_NONE
-        : (preload == MediaPlayer::MetaData) ? com_sun_webkit_graphics_WCMediaPlayer_PRELOAD_METADATA
-        : (preload == MediaPlayer::Auto) ? com_sun_webkit_graphics_WCMediaPlayer_PRELOAD_AUTO
+        (preload == MediaPlayer::Preload::None) ? com_sun_webkit_graphics_WCMediaPlayer_PRELOAD_NONE
+        : (preload == MediaPlayer::Preload::MetaData) ? com_sun_webkit_graphics_WCMediaPlayer_PRELOAD_METADATA
+        : (preload == MediaPlayer::Preload::Auto) ? com_sun_webkit_graphics_WCMediaPlayer_PRELOAD_AUTO
         : -1;
     if (jPreload < 0) {
         // unexpected preload value
         return;
     }
@@ -601,11 +616,11 @@
 
     env->CallVoidMethod(*m_jPlayer, s_mID, jPreload);
     WTF::CheckAndClearException(env);
 }
 
-//bool MediaPlayerPrivate::hasAvailableVideoFrame() const { return readyState() >= MediaPlayer::HaveCurrentData; }
+//bool MediaPlayerPrivate::hasAvailableVideoFrame() const { return readyState() >= MediaPlayer::ReadyState::HaveCurrentData; }
 
 //bool MediaPlayerPrivate::canLoadPoster() const { return false; }
 //void MediaPlayerPrivate::setPoster(const String&) { }
 
 //#if ENABLE(PLUGIN_PROXY_FOR_VIDEO)
@@ -620,11 +635,11 @@
 //        virtual void acceleratedRenderingStateChanged() { }
 //#endif
 
 //bool MediaPlayerPrivate::hasSingleSecurityOrigin() const { return false; }
 
-//MediaPlayer::MovieLoadType MediaPlayerPrivate::movieLoadType() const { return MediaPlayer::Unknown; }
+//MediaPlayer::MovieLoadType MediaPlayerPrivate::movieLoadType() const { return MediaPlayer::MovieLoadType::Unknown; }
 
 void MediaPlayerPrivate::setNetworkState(MediaPlayer::NetworkState networkState)
 {
     if (m_networkState != networkState) {
         PLOG_TRACE4("MediaPlayerPrivate NetworkState: %s (%d) => %s (%d)\n",
@@ -652,50 +667,50 @@
 
 void MediaPlayerPrivate::notifyNetworkStateChanged(int networkState)
 {
     switch (networkState) {
     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_EMPTY:
-        setNetworkState(MediaPlayer::Empty);
+        setNetworkState(MediaPlayer::NetworkState::Empty);
         break;
     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_IDLE:
-        setNetworkState(MediaPlayer::Idle);
+        setNetworkState(MediaPlayer::NetworkState::Idle);
         break;
     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_LOADING:
-        setNetworkState(MediaPlayer::Loading);
+        setNetworkState(MediaPlayer::NetworkState::Loading);
         break;
     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_LOADED:
-        setNetworkState(MediaPlayer::Loaded);
+        setNetworkState(MediaPlayer::NetworkState::Loaded);
         break;
     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_FORMAT_ERROR:
-        setNetworkState(MediaPlayer::FormatError);
+        setNetworkState(MediaPlayer::NetworkState::FormatError);
         break;
     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_NETWORK_ERROR:
-        setNetworkState(MediaPlayer::NetworkError);
+        setNetworkState(MediaPlayer::NetworkState::NetworkError);
         break;
     case com_sun_webkit_graphics_WCMediaPlayer_NETWORK_STATE_DECODE_ERROR:
-        setNetworkState(MediaPlayer::DecodeError);
+        setNetworkState(MediaPlayer::NetworkState::DecodeError);
         break;
     }
 }
 
 void MediaPlayerPrivate::notifyReadyStateChanged(int readyState)
 {
     switch (readyState) {
     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_NOTHING:
-        setReadyState(MediaPlayer::HaveNothing);
+        setReadyState(MediaPlayer::ReadyState::HaveNothing);
         break;
     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_METADATA:
-        setReadyState(MediaPlayer::HaveMetadata);
+        setReadyState(MediaPlayer::ReadyState::HaveMetadata);
         break;
     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_CURRENT_DATA:
-        setReadyState(MediaPlayer::HaveCurrentData);
+        setReadyState(MediaPlayer::ReadyState::HaveCurrentData);
         break;
     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_FUTURE_DATA:
-        setReadyState(MediaPlayer::HaveFutureData);
+        setReadyState(MediaPlayer::ReadyState::HaveFutureData);
         break;
     case com_sun_webkit_graphics_WCMediaPlayer_READY_STATE_HAVE_ENOUGH_DATA:
-        setReadyState(MediaPlayer::HaveEnoughData);
+        setReadyState(MediaPlayer::ReadyState::HaveEnoughData);
         break;
     }
 }
 
 void MediaPlayerPrivate::notifyPaused(bool paused)

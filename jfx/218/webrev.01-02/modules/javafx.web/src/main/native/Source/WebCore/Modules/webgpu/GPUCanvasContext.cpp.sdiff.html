<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/GPUCanvasContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GPUBufferUsage.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GPUCanvasContext.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/GPUCanvasContext.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;GPUCanvasContext.h&quot;
 28 #include &quot;InspectorInstrumentation.h&quot;
 29 #include &quot;Logging.h&quot;
 30 #include &quot;WebGPUSwapChainDescriptor.h&quot;
 31 
 32 #if ENABLE(WEBGPU)
 33 
 34 #include &lt;wtf/IsoMallocInlines.h&gt;
 35 
 36 namespace WebCore {
 37 
 38 WTF_MAKE_ISO_ALLOCATED_IMPL(GPUCanvasContext);
 39 
 40 std::unique_ptr&lt;GPUCanvasContext&gt; GPUCanvasContext::create(CanvasBase&amp; canvas)
 41 {
 42     auto context = std::unique_ptr&lt;GPUCanvasContext&gt;(new GPUCanvasContext(canvas));
 43     context-&gt;suspendIfNeeded();
<span class="line-removed"> 44 </span>
<span class="line-removed"> 45     InspectorInstrumentation::didCreateCanvasRenderingContext(*context);</span>
<span class="line-removed"> 46 </span>
 47     return context;
 48 }
 49 
 50 GPUCanvasContext::GPUCanvasContext(CanvasBase&amp; canvas)
 51     : GPUBasedCanvasRenderingContext(canvas)
 52 {
 53 }
 54 
 55 Ref&lt;WebGPUSwapChain&gt; GPUCanvasContext::configureSwapChain(const WebGPUSwapChainDescriptor&amp; descriptor)
 56 {
 57     auto gpuDescriptor = descriptor.asGPUSwapChainDescriptor();
 58     if (!gpuDescriptor)
 59         return WebGPUSwapChain::create(nullptr);
 60 
 61     auto gpuSwapChain = GPUSwapChain::tryCreate(*gpuDescriptor, canvasBase().width(), canvasBase().height());
 62     bool success = gpuSwapChain;
 63     auto newSwapChain = WebGPUSwapChain::create(WTFMove(gpuSwapChain));
 64 
 65     // Upon success, invalidate and replace any existing swap chain.
 66     if (success) {
 67         // FIXME: Test that this works as expected with error reporting.
 68         if (m_swapChain)
 69             m_swapChain-&gt;destroy();
 70 


 71         m_swapChain = newSwapChain.copyRef();

 72         notifyCanvasContentChanged();
 73     }
 74 
 75     return newSwapChain;
 76 }
 77 
 78 CALayer* GPUCanvasContext::platformLayer() const
 79 {
 80     if (m_swapChain &amp;&amp; m_swapChain-&gt;swapChain())
 81         return m_swapChain-&gt;swapChain()-&gt;platformLayer();
 82     return nullptr;
 83 }
 84 
 85 void GPUCanvasContext::reshape(int width, int height)
 86 {
 87     if (m_swapChain &amp;&amp; m_swapChain-&gt;swapChain())
 88         m_swapChain-&gt;swapChain()-&gt;reshape(width, height);
 89 
 90     notifyCanvasContentChanged();
 91 }
</pre>
</td>
<td>
<hr />
<pre>
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;GPUCanvasContext.h&quot;
 28 #include &quot;InspectorInstrumentation.h&quot;
 29 #include &quot;Logging.h&quot;
 30 #include &quot;WebGPUSwapChainDescriptor.h&quot;
 31 
 32 #if ENABLE(WEBGPU)
 33 
 34 #include &lt;wtf/IsoMallocInlines.h&gt;
 35 
 36 namespace WebCore {
 37 
 38 WTF_MAKE_ISO_ALLOCATED_IMPL(GPUCanvasContext);
 39 
 40 std::unique_ptr&lt;GPUCanvasContext&gt; GPUCanvasContext::create(CanvasBase&amp; canvas)
 41 {
 42     auto context = std::unique_ptr&lt;GPUCanvasContext&gt;(new GPUCanvasContext(canvas));
 43     context-&gt;suspendIfNeeded();



 44     return context;
 45 }
 46 
 47 GPUCanvasContext::GPUCanvasContext(CanvasBase&amp; canvas)
 48     : GPUBasedCanvasRenderingContext(canvas)
 49 {
 50 }
 51 
 52 Ref&lt;WebGPUSwapChain&gt; GPUCanvasContext::configureSwapChain(const WebGPUSwapChainDescriptor&amp; descriptor)
 53 {
 54     auto gpuDescriptor = descriptor.asGPUSwapChainDescriptor();
 55     if (!gpuDescriptor)
 56         return WebGPUSwapChain::create(nullptr);
 57 
 58     auto gpuSwapChain = GPUSwapChain::tryCreate(*gpuDescriptor, canvasBase().width(), canvasBase().height());
 59     bool success = gpuSwapChain;
 60     auto newSwapChain = WebGPUSwapChain::create(WTFMove(gpuSwapChain));
 61 
 62     // Upon success, invalidate and replace any existing swap chain.
 63     if (success) {
 64         // FIXME: Test that this works as expected with error reporting.
 65         if (m_swapChain)
 66             m_swapChain-&gt;destroy();
 67 
<span class="line-added"> 68         InspectorInstrumentation::willConfigureSwapChain(*this, newSwapChain.get());</span>
<span class="line-added"> 69 </span>
 70         m_swapChain = newSwapChain.copyRef();
<span class="line-added"> 71 </span>
 72         notifyCanvasContentChanged();
 73     }
 74 
 75     return newSwapChain;
 76 }
 77 
 78 CALayer* GPUCanvasContext::platformLayer() const
 79 {
 80     if (m_swapChain &amp;&amp; m_swapChain-&gt;swapChain())
 81         return m_swapChain-&gt;swapChain()-&gt;platformLayer();
 82     return nullptr;
 83 }
 84 
 85 void GPUCanvasContext::reshape(int width, int height)
 86 {
 87     if (m_swapChain &amp;&amp; m_swapChain-&gt;swapChain())
 88         m_swapChain-&gt;swapChain()-&gt;reshape(width, height);
 89 
 90     notifyCanvasContentChanged();
 91 }
</pre>
</td>
</tr>
</table>
<center><a href="GPUBufferUsage.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="GPUCanvasContext.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
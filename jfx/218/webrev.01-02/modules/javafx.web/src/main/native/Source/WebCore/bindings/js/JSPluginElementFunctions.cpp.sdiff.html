<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSPluginElementFunctions.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSPerformanceEntryCustom.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSPluginElementFunctions.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSPluginElementFunctions.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 48 
 49 static JSObject* pluginScriptObjectFromPluginViewBase(HTMLPlugInElement&amp; pluginElement, JSGlobalObject* globalObject)
 50 {
 51     Widget* pluginWidget = pluginElement.pluginWidget();
 52     if (!is&lt;PluginViewBase&gt;(pluginWidget))
 53         return nullptr;
 54 
 55     return downcast&lt;PluginViewBase&gt;(*pluginWidget).scriptObject(globalObject);
 56 }
 57 
 58 static JSObject* pluginScriptObjectFromPluginViewBase(JSHTMLElement* jsHTMLElement)
 59 {
 60     HTMLElement&amp; element = jsHTMLElement-&gt;wrapped();
 61     if (!is&lt;HTMLPlugInElement&gt;(element))
 62         return nullptr;
 63 
 64     HTMLPlugInElement&amp; pluginElement = downcast&lt;HTMLPlugInElement&gt;(element);
 65     return pluginScriptObjectFromPluginViewBase(pluginElement, jsHTMLElement-&gt;globalObject());
 66 }
 67 
<span class="line-modified"> 68 JSObject* pluginScriptObject(ExecState* exec, JSHTMLElement* jsHTMLElement)</span>
 69 {
 70     HTMLElement&amp; element = jsHTMLElement-&gt;wrapped();
 71     if (!is&lt;HTMLPlugInElement&gt;(element))
 72         return nullptr;
 73 
 74     auto&amp; pluginElement = downcast&lt;HTMLPlugInElement&gt;(element);
 75 
 76     // Choke point for script/plugin interaction; notify DOMTimer of the event.
 77     DOMTimer::scriptDidInteractWithPlugin(pluginElement);
 78 
 79     // First, see if the element has a plug-in replacement with a script.
 80     if (auto* scriptObject = pluginElement.scriptObjectForPluginReplacement())
 81         return scriptObject;
 82 
 83     // Next, see if we can ask the plug-in view for its script object.
 84     if (auto* scriptObject = pluginScriptObjectFromPluginViewBase(pluginElement, jsHTMLElement-&gt;globalObject()))
 85         return scriptObject;
 86 
 87     // Otherwise, fall back to getting the object from the instance.
 88 
 89     // The plugin element holds an owning reference, so we don&#39;t have to.
 90     auto* instance = pluginElement.bindingsInstance();
 91     if (!instance || !instance-&gt;rootObject())
 92         return nullptr;
 93 
<span class="line-modified"> 94     return instance-&gt;createRuntimeObject(exec);</span>
 95 }
 96 
<span class="line-modified"> 97 static EncodedJSValue pluginElementPropertyGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName propertyName)</span>
 98 {
<span class="line-modified"> 99     VM&amp; vm = exec-&gt;vm();</span>
100     auto scope = DECLARE_THROW_SCOPE(vm);
101 
102     JSHTMLElement* thisObject = jsDynamicCast&lt;JSHTMLElement*&gt;(vm, JSValue::decode(thisValue));
103     if (!thisObject)
<span class="line-modified">104         return throwVMTypeError(exec, scope);</span>
<span class="line-modified">105     JSObject* scriptObject = pluginScriptObject(exec, thisObject);</span>
106     if (!scriptObject)
107         return JSValue::encode(jsUndefined());
108 
<span class="line-modified">109     return JSValue::encode(scriptObject-&gt;get(exec, propertyName));</span>
110 }
111 
<span class="line-modified">112 bool pluginElementCustomGetOwnPropertySlot(JSHTMLElement* element, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
113 {
114     if (!element-&gt;globalObject()-&gt;world().isNormal()) {
<span class="line-modified">115         JSC::JSValue proto = element-&gt;getPrototypeDirect(exec-&gt;vm());</span>
<span class="line-modified">116         if (proto.isObject() &amp;&amp; JSC::jsCast&lt;JSC::JSObject*&gt;(asObject(proto))-&gt;hasProperty(exec, propertyName))</span>
117             return false;
118     }
119 
<span class="line-modified">120     JSObject* scriptObject = pluginScriptObject(exec, element);</span>
121     if (!scriptObject)
122         return false;
123 
<span class="line-modified">124     if (!scriptObject-&gt;hasProperty(exec, propertyName))</span>
125         return false;
126 
127     slot.setCustom(element, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum, pluginElementPropertyGetter);
128     return true;
129 }
130 
<span class="line-modified">131 bool pluginElementCustomPut(JSHTMLElement* element, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot, bool&amp; putResult)</span>
132 {
<span class="line-modified">133     JSObject* scriptObject = pluginScriptObject(exec, element);</span>
134     if (!scriptObject)
135         return false;
<span class="line-modified">136     if (!scriptObject-&gt;hasProperty(exec, propertyName))</span>
137         return false;
<span class="line-modified">138     putResult = scriptObject-&gt;methodTable(exec-&gt;vm())-&gt;put(scriptObject, exec, propertyName, value, slot);</span>
139     return true;
140 }
141 
<span class="line-modified">142 static EncodedJSValue JSC_HOST_CALL callPlugin(ExecState* exec)</span>
143 {
<span class="line-modified">144     JSHTMLElement* element = jsCast&lt;JSHTMLElement*&gt;(exec-&gt;jsCallee());</span>
145 
146     // Get the plug-in script object.
<span class="line-modified">147     JSObject* scriptObject = pluginScriptObject(exec, element);</span>
148     ASSERT(scriptObject);
149 
<span class="line-modified">150     size_t argumentCount = exec-&gt;argumentCount();</span>
151     MarkedArgumentBuffer argumentList;
152     for (size_t i = 0; i &lt; argumentCount; i++)
<span class="line-modified">153         argumentList.append(exec-&gt;argument(i));</span>
154     ASSERT(!argumentList.hasOverflowed());
155 
156     CallData callData;
<span class="line-modified">157     CallType callType = getCallData(exec-&gt;vm(), scriptObject, callData);</span>
158     ASSERT(callType == CallType::Host);
159 
160     // Call the object.
<span class="line-modified">161     JSValue result = call(exec, scriptObject, callType, callData, exec-&gt;thisValue(), argumentList);</span>
162     return JSValue::encode(result);
163 }
164 
165 CallType pluginElementCustomGetCallData(JSHTMLElement* element, CallData&amp; callData)
166 {
167     // First, ask the plug-in view base for its runtime object.
168     if (JSObject* scriptObject = pluginScriptObjectFromPluginViewBase(element)) {
169         CallData scriptObjectCallData;
170 
171         VM&amp; vm = scriptObject-&gt;vm();
172         if (scriptObject-&gt;methodTable(vm)-&gt;getCallData(scriptObject, scriptObjectCallData) == CallType::None)
173             return CallType::None;
174 
175         callData.native.function = callPlugin;
176         return CallType::Host;
177     }
178 
179     Instance* instance = pluginInstance(element-&gt;wrapped());
180     if (!instance || !instance-&gt;supportsInvokeDefaultMethod())
181         return CallType::None;
</pre>
</td>
<td>
<hr />
<pre>
 48 
 49 static JSObject* pluginScriptObjectFromPluginViewBase(HTMLPlugInElement&amp; pluginElement, JSGlobalObject* globalObject)
 50 {
 51     Widget* pluginWidget = pluginElement.pluginWidget();
 52     if (!is&lt;PluginViewBase&gt;(pluginWidget))
 53         return nullptr;
 54 
 55     return downcast&lt;PluginViewBase&gt;(*pluginWidget).scriptObject(globalObject);
 56 }
 57 
 58 static JSObject* pluginScriptObjectFromPluginViewBase(JSHTMLElement* jsHTMLElement)
 59 {
 60     HTMLElement&amp; element = jsHTMLElement-&gt;wrapped();
 61     if (!is&lt;HTMLPlugInElement&gt;(element))
 62         return nullptr;
 63 
 64     HTMLPlugInElement&amp; pluginElement = downcast&lt;HTMLPlugInElement&gt;(element);
 65     return pluginScriptObjectFromPluginViewBase(pluginElement, jsHTMLElement-&gt;globalObject());
 66 }
 67 
<span class="line-modified"> 68 JSObject* pluginScriptObject(JSGlobalObject* lexicalGlobalObject, JSHTMLElement* jsHTMLElement)</span>
 69 {
 70     HTMLElement&amp; element = jsHTMLElement-&gt;wrapped();
 71     if (!is&lt;HTMLPlugInElement&gt;(element))
 72         return nullptr;
 73 
 74     auto&amp; pluginElement = downcast&lt;HTMLPlugInElement&gt;(element);
 75 
 76     // Choke point for script/plugin interaction; notify DOMTimer of the event.
 77     DOMTimer::scriptDidInteractWithPlugin(pluginElement);
 78 
 79     // First, see if the element has a plug-in replacement with a script.
 80     if (auto* scriptObject = pluginElement.scriptObjectForPluginReplacement())
 81         return scriptObject;
 82 
 83     // Next, see if we can ask the plug-in view for its script object.
 84     if (auto* scriptObject = pluginScriptObjectFromPluginViewBase(pluginElement, jsHTMLElement-&gt;globalObject()))
 85         return scriptObject;
 86 
 87     // Otherwise, fall back to getting the object from the instance.
 88 
 89     // The plugin element holds an owning reference, so we don&#39;t have to.
 90     auto* instance = pluginElement.bindingsInstance();
 91     if (!instance || !instance-&gt;rootObject())
 92         return nullptr;
 93 
<span class="line-modified"> 94     return instance-&gt;createRuntimeObject(lexicalGlobalObject);</span>
 95 }
 96 
<span class="line-modified"> 97 static EncodedJSValue pluginElementPropertyGetter(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName propertyName)</span>
 98 {
<span class="line-modified"> 99     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
100     auto scope = DECLARE_THROW_SCOPE(vm);
101 
102     JSHTMLElement* thisObject = jsDynamicCast&lt;JSHTMLElement*&gt;(vm, JSValue::decode(thisValue));
103     if (!thisObject)
<span class="line-modified">104         return throwVMTypeError(lexicalGlobalObject, scope);</span>
<span class="line-modified">105     JSObject* scriptObject = pluginScriptObject(lexicalGlobalObject, thisObject);</span>
106     if (!scriptObject)
107         return JSValue::encode(jsUndefined());
108 
<span class="line-modified">109     return JSValue::encode(scriptObject-&gt;get(lexicalGlobalObject, propertyName));</span>
110 }
111 
<span class="line-modified">112 bool pluginElementCustomGetOwnPropertySlot(JSHTMLElement* element, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
113 {
114     if (!element-&gt;globalObject()-&gt;world().isNormal()) {
<span class="line-modified">115         JSC::JSValue proto = element-&gt;getPrototypeDirect(lexicalGlobalObject-&gt;vm());</span>
<span class="line-modified">116         if (proto.isObject() &amp;&amp; JSC::jsCast&lt;JSC::JSObject*&gt;(asObject(proto))-&gt;hasProperty(lexicalGlobalObject, propertyName))</span>
117             return false;
118     }
119 
<span class="line-modified">120     JSObject* scriptObject = pluginScriptObject(lexicalGlobalObject, element);</span>
121     if (!scriptObject)
122         return false;
123 
<span class="line-modified">124     if (!scriptObject-&gt;hasProperty(lexicalGlobalObject, propertyName))</span>
125         return false;
126 
127     slot.setCustom(element, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum, pluginElementPropertyGetter);
128     return true;
129 }
130 
<span class="line-modified">131 bool pluginElementCustomPut(JSHTMLElement* element, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot, bool&amp; putResult)</span>
132 {
<span class="line-modified">133     JSObject* scriptObject = pluginScriptObject(lexicalGlobalObject, element);</span>
134     if (!scriptObject)
135         return false;
<span class="line-modified">136     if (!scriptObject-&gt;hasProperty(lexicalGlobalObject, propertyName))</span>
137         return false;
<span class="line-modified">138     putResult = scriptObject-&gt;methodTable(lexicalGlobalObject-&gt;vm())-&gt;put(scriptObject, lexicalGlobalObject, propertyName, value, slot);</span>
139     return true;
140 }
141 
<span class="line-modified">142 static EncodedJSValue JSC_HOST_CALL callPlugin(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)</span>
143 {
<span class="line-modified">144     JSHTMLElement* element = jsCast&lt;JSHTMLElement*&gt;(callFrame-&gt;jsCallee());</span>
145 
146     // Get the plug-in script object.
<span class="line-modified">147     JSObject* scriptObject = pluginScriptObject(lexicalGlobalObject, element);</span>
148     ASSERT(scriptObject);
149 
<span class="line-modified">150     size_t argumentCount = callFrame-&gt;argumentCount();</span>
151     MarkedArgumentBuffer argumentList;
152     for (size_t i = 0; i &lt; argumentCount; i++)
<span class="line-modified">153         argumentList.append(callFrame-&gt;argument(i));</span>
154     ASSERT(!argumentList.hasOverflowed());
155 
156     CallData callData;
<span class="line-modified">157     CallType callType = getCallData(lexicalGlobalObject-&gt;vm(), scriptObject, callData);</span>
158     ASSERT(callType == CallType::Host);
159 
160     // Call the object.
<span class="line-modified">161     JSValue result = call(lexicalGlobalObject, scriptObject, callType, callData, callFrame-&gt;thisValue(), argumentList);</span>
162     return JSValue::encode(result);
163 }
164 
165 CallType pluginElementCustomGetCallData(JSHTMLElement* element, CallData&amp; callData)
166 {
167     // First, ask the plug-in view base for its runtime object.
168     if (JSObject* scriptObject = pluginScriptObjectFromPluginViewBase(element)) {
169         CallData scriptObjectCallData;
170 
171         VM&amp; vm = scriptObject-&gt;vm();
172         if (scriptObject-&gt;methodTable(vm)-&gt;getCallData(scriptObject, scriptObjectCallData) == CallType::None)
173             return CallType::None;
174 
175         callData.native.function = callPlugin;
176         return CallType::Host;
177     }
178 
179     Instance* instance = pluginInstance(element-&gt;wrapped());
180     if (!instance || !instance-&gt;supportsInvokeDefaultMethod())
181         return CallType::None;
</pre>
</td>
</tr>
</table>
<center><a href="JSPerformanceEntryCustom.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSPluginElementFunctions.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
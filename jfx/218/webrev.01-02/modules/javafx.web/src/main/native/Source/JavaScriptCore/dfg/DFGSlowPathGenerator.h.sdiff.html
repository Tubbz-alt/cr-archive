<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSlowPathGenerator.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGScoreBoard.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSpeculativeJIT.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSlowPathGenerator.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 35 namespace JSC { namespace DFG {
 36 
 37 class SlowPathGenerator {
 38     WTF_MAKE_FAST_ALLOCATED;
 39 public:
 40     SlowPathGenerator(SpeculativeJIT* jit)
 41         : m_currentNode(jit-&gt;m_currentNode)
 42         , m_streamIndex(jit-&gt;m_stream-&gt;size())
 43         , m_origin(jit-&gt;m_origin)
 44     {
 45     }
 46     virtual ~SlowPathGenerator() { }
 47     void generate(SpeculativeJIT* jit)
 48     {
 49         m_label = jit-&gt;m_jit.label();
 50         jit-&gt;m_currentNode = m_currentNode;
 51         jit-&gt;m_outOfLineStreamIndex = m_streamIndex;
 52         jit-&gt;m_origin = m_origin;
 53         generateInternal(jit);
 54         jit-&gt;m_outOfLineStreamIndex = WTF::nullopt;
<span class="line-modified"> 55         if (!ASSERT_DISABLED)</span>
 56             jit-&gt;m_jit.abortWithReason(DFGSlowPathGeneratorFellThrough);
 57     }
 58     MacroAssembler::Label label() const { return m_label; }
 59     virtual MacroAssembler::Call call() const
 60     {
 61         RELEASE_ASSERT_NOT_REACHED(); // By default slow path generators don&#39;t have a call.
 62         return MacroAssembler::Call();
 63     }
 64 
 65     const NodeOrigin&amp; origin() const  { return m_origin; }
 66 
 67 protected:
 68     virtual void generateInternal(SpeculativeJIT*) = 0;
 69     Node* m_currentNode;
 70     MacroAssembler::Label m_label;
 71     unsigned m_streamIndex;
 72     NodeOrigin m_origin;
 73 };
 74 
 75 template&lt;typename JumpType&gt;
</pre>
<hr />
<pre>
 85 protected:
 86     void linkFrom(SpeculativeJIT* jit)
 87     {
 88         m_from.link(&amp;jit-&gt;m_jit);
 89     }
 90 
 91     void jumpTo(SpeculativeJIT* jit)
 92     {
 93         jit-&gt;m_jit.jump().linkTo(m_to, &amp;jit-&gt;m_jit);
 94     }
 95 
 96     JumpType m_from;
 97     MacroAssembler::Label m_to;
 98 };
 99 
100 enum class ExceptionCheckRequirement : uint8_t {
101     CheckNeeded,
102     CheckNotNeeded
103 };
104 
<span class="line-modified">105 template&lt;typename JumpType, typename FunctionType, typename ResultType&gt;</span>
106 class CallSlowPathGenerator : public JumpingSlowPathGenerator&lt;JumpType&gt; {
107 public:
108     CallSlowPathGenerator(
<span class="line-modified">109         JumpType from, SpeculativeJIT* jit, FunctionType function,</span>
110         SpillRegistersMode spillMode, ExceptionCheckRequirement requirement, ResultType result)
111         : JumpingSlowPathGenerator&lt;JumpType&gt;(from, jit)
112         , m_spillMode(spillMode)
113         , m_exceptionCheckRequirement(requirement)
114         , m_result(result)
<span class="line-removed">115         , m_function(function)</span>
116     {
117         if (m_spillMode == NeedToSpill)
118             jit-&gt;silentSpillAllRegistersImpl(false, m_plans, extractResult(result));
119     }
120 
121     MacroAssembler::Call call() const override
122     {
123         return m_call;
124     }
125 
126 protected:
127     void setUp(SpeculativeJIT* jit)
128     {
129         this-&gt;linkFrom(jit);
130         if (m_spillMode == NeedToSpill) {
131             for (unsigned i = 0; i &lt; m_plans.size(); ++i)
132                 jit-&gt;silentSpill(m_plans[i]);
133         }
134     }
135 
136     void recordCall(MacroAssembler::Call call)
137     {
138         m_call = call;
139     }
140 
141     void tearDown(SpeculativeJIT* jit)
142     {
143         if (m_spillMode == NeedToSpill) {
144             for (unsigned i = m_plans.size(); i--;)
145                 jit-&gt;silentFill(m_plans[i]);
146         }
147         if (m_exceptionCheckRequirement == ExceptionCheckRequirement::CheckNeeded)
148             jit-&gt;m_jit.exceptionCheck();
149         this-&gt;jumpTo(jit);
150     }
151 
152     MacroAssembler::Call m_call;
153     SpillRegistersMode m_spillMode;
154     ExceptionCheckRequirement m_exceptionCheckRequirement;
155     ResultType m_result;
<span class="line-removed">156     FunctionType m_function;</span>
157     Vector&lt;SilentRegisterSavePlan, 2&gt; m_plans;
158 };
159 
160 template&lt;typename JumpType, typename FunctionType, typename ResultType, typename... Arguments&gt;
161 class CallResultAndArgumentsSlowPathGenerator
<span class="line-modified">162     : public CallSlowPathGenerator&lt;JumpType, FunctionType, ResultType&gt; {</span>
163 public:
164     CallResultAndArgumentsSlowPathGenerator(
165         JumpType from, SpeculativeJIT* jit, FunctionType function,
166         SpillRegistersMode spillMode, ExceptionCheckRequirement requirement, ResultType result, Arguments... arguments)
<span class="line-modified">167         : CallSlowPathGenerator&lt;JumpType, FunctionType, ResultType&gt;(</span>
<span class="line-modified">168             from, jit, function, spillMode, requirement, result)</span>
169         , m_arguments(std::forward&lt;Arguments&gt;(arguments)...)
170     {
171     }
172 
173 protected:
174     template&lt;size_t... ArgumentsIndex&gt;
175     void unpackAndGenerate(SpeculativeJIT* jit, std::index_sequence&lt;ArgumentsIndex...&gt;)
176     {
177         this-&gt;setUp(jit);
<span class="line-modified">178         this-&gt;recordCall(jit-&gt;callOperation(this-&gt;m_function, extractResult(this-&gt;m_result), std::get&lt;ArgumentsIndex&gt;(m_arguments)...));</span>



179         this-&gt;tearDown(jit);
180     }
181 
182     void generateInternal(SpeculativeJIT* jit) override
183     {
184         unpackAndGenerate(jit, std::make_index_sequence&lt;std::tuple_size&lt;std::tuple&lt;Arguments...&gt;&gt;::value&gt;());
185     }
186 

187     std::tuple&lt;Arguments...&gt; m_arguments;
188 };
189 
190 template&lt;typename JumpType, typename FunctionType, typename ResultType, typename... Arguments&gt;
191 inline std::unique_ptr&lt;SlowPathGenerator&gt; slowPathCall(
192     JumpType from, SpeculativeJIT* jit, FunctionType function,
193     SpillRegistersMode spillMode, ExceptionCheckRequirement requirement,
194     ResultType result, Arguments... arguments)
195 {
196     return makeUnique&lt;CallResultAndArgumentsSlowPathGenerator&lt;JumpType, FunctionType, ResultType, Arguments...&gt;&gt;(
197         from, jit, function, spillMode, requirement, result, arguments...);
198 }
199 
200 template&lt;typename JumpType, typename FunctionType, typename ResultType, typename... Arguments&gt;
201 inline std::unique_ptr&lt;SlowPathGenerator&gt; slowPathCall(
202     JumpType from, SpeculativeJIT* jit, FunctionType function,
203     ResultType result, Arguments... arguments)
204 {
205     return slowPathCall(
206         from, jit, function, NeedToSpill, ExceptionCheckRequirement::CheckNeeded, result, arguments...);
</pre>
</td>
<td>
<hr />
<pre>
 35 namespace JSC { namespace DFG {
 36 
 37 class SlowPathGenerator {
 38     WTF_MAKE_FAST_ALLOCATED;
 39 public:
 40     SlowPathGenerator(SpeculativeJIT* jit)
 41         : m_currentNode(jit-&gt;m_currentNode)
 42         , m_streamIndex(jit-&gt;m_stream-&gt;size())
 43         , m_origin(jit-&gt;m_origin)
 44     {
 45     }
 46     virtual ~SlowPathGenerator() { }
 47     void generate(SpeculativeJIT* jit)
 48     {
 49         m_label = jit-&gt;m_jit.label();
 50         jit-&gt;m_currentNode = m_currentNode;
 51         jit-&gt;m_outOfLineStreamIndex = m_streamIndex;
 52         jit-&gt;m_origin = m_origin;
 53         generateInternal(jit);
 54         jit-&gt;m_outOfLineStreamIndex = WTF::nullopt;
<span class="line-modified"> 55         if (ASSERT_ENABLED)</span>
 56             jit-&gt;m_jit.abortWithReason(DFGSlowPathGeneratorFellThrough);
 57     }
 58     MacroAssembler::Label label() const { return m_label; }
 59     virtual MacroAssembler::Call call() const
 60     {
 61         RELEASE_ASSERT_NOT_REACHED(); // By default slow path generators don&#39;t have a call.
 62         return MacroAssembler::Call();
 63     }
 64 
 65     const NodeOrigin&amp; origin() const  { return m_origin; }
 66 
 67 protected:
 68     virtual void generateInternal(SpeculativeJIT*) = 0;
 69     Node* m_currentNode;
 70     MacroAssembler::Label m_label;
 71     unsigned m_streamIndex;
 72     NodeOrigin m_origin;
 73 };
 74 
 75 template&lt;typename JumpType&gt;
</pre>
<hr />
<pre>
 85 protected:
 86     void linkFrom(SpeculativeJIT* jit)
 87     {
 88         m_from.link(&amp;jit-&gt;m_jit);
 89     }
 90 
 91     void jumpTo(SpeculativeJIT* jit)
 92     {
 93         jit-&gt;m_jit.jump().linkTo(m_to, &amp;jit-&gt;m_jit);
 94     }
 95 
 96     JumpType m_from;
 97     MacroAssembler::Label m_to;
 98 };
 99 
100 enum class ExceptionCheckRequirement : uint8_t {
101     CheckNeeded,
102     CheckNotNeeded
103 };
104 
<span class="line-modified">105 template&lt;typename JumpType, typename ResultType&gt;</span>
106 class CallSlowPathGenerator : public JumpingSlowPathGenerator&lt;JumpType&gt; {
107 public:
108     CallSlowPathGenerator(
<span class="line-modified">109         JumpType from, SpeculativeJIT* jit,</span>
110         SpillRegistersMode spillMode, ExceptionCheckRequirement requirement, ResultType result)
111         : JumpingSlowPathGenerator&lt;JumpType&gt;(from, jit)
112         , m_spillMode(spillMode)
113         , m_exceptionCheckRequirement(requirement)
114         , m_result(result)

115     {
116         if (m_spillMode == NeedToSpill)
117             jit-&gt;silentSpillAllRegistersImpl(false, m_plans, extractResult(result));
118     }
119 
120     MacroAssembler::Call call() const override
121     {
122         return m_call;
123     }
124 
125 protected:
126     void setUp(SpeculativeJIT* jit)
127     {
128         this-&gt;linkFrom(jit);
129         if (m_spillMode == NeedToSpill) {
130             for (unsigned i = 0; i &lt; m_plans.size(); ++i)
131                 jit-&gt;silentSpill(m_plans[i]);
132         }
133     }
134 
135     void recordCall(MacroAssembler::Call call)
136     {
137         m_call = call;
138     }
139 
140     void tearDown(SpeculativeJIT* jit)
141     {
142         if (m_spillMode == NeedToSpill) {
143             for (unsigned i = m_plans.size(); i--;)
144                 jit-&gt;silentFill(m_plans[i]);
145         }
146         if (m_exceptionCheckRequirement == ExceptionCheckRequirement::CheckNeeded)
147             jit-&gt;m_jit.exceptionCheck();
148         this-&gt;jumpTo(jit);
149     }
150 
151     MacroAssembler::Call m_call;
152     SpillRegistersMode m_spillMode;
153     ExceptionCheckRequirement m_exceptionCheckRequirement;
154     ResultType m_result;

155     Vector&lt;SilentRegisterSavePlan, 2&gt; m_plans;
156 };
157 
158 template&lt;typename JumpType, typename FunctionType, typename ResultType, typename... Arguments&gt;
159 class CallResultAndArgumentsSlowPathGenerator
<span class="line-modified">160     : public CallSlowPathGenerator&lt;JumpType, ResultType&gt; {</span>
161 public:
162     CallResultAndArgumentsSlowPathGenerator(
163         JumpType from, SpeculativeJIT* jit, FunctionType function,
164         SpillRegistersMode spillMode, ExceptionCheckRequirement requirement, ResultType result, Arguments... arguments)
<span class="line-modified">165         : CallSlowPathGenerator&lt;JumpType, ResultType&gt;(from, jit, spillMode, requirement, result)</span>
<span class="line-modified">166         , m_function(function)</span>
167         , m_arguments(std::forward&lt;Arguments&gt;(arguments)...)
168     {
169     }
170 
171 protected:
172     template&lt;size_t... ArgumentsIndex&gt;
173     void unpackAndGenerate(SpeculativeJIT* jit, std::index_sequence&lt;ArgumentsIndex...&gt;)
174     {
175         this-&gt;setUp(jit);
<span class="line-modified">176         if constexpr (std::is_same&lt;ResultType, NoResultTag&gt;::value)</span>
<span class="line-added">177             this-&gt;recordCall(jit-&gt;callOperation(this-&gt;m_function, std::get&lt;ArgumentsIndex&gt;(m_arguments)...));</span>
<span class="line-added">178         else</span>
<span class="line-added">179             this-&gt;recordCall(jit-&gt;callOperation(this-&gt;m_function, extractResult(this-&gt;m_result), std::get&lt;ArgumentsIndex&gt;(m_arguments)...));</span>
180         this-&gt;tearDown(jit);
181     }
182 
183     void generateInternal(SpeculativeJIT* jit) override
184     {
185         unpackAndGenerate(jit, std::make_index_sequence&lt;std::tuple_size&lt;std::tuple&lt;Arguments...&gt;&gt;::value&gt;());
186     }
187 
<span class="line-added">188     FunctionType m_function;</span>
189     std::tuple&lt;Arguments...&gt; m_arguments;
190 };
191 
192 template&lt;typename JumpType, typename FunctionType, typename ResultType, typename... Arguments&gt;
193 inline std::unique_ptr&lt;SlowPathGenerator&gt; slowPathCall(
194     JumpType from, SpeculativeJIT* jit, FunctionType function,
195     SpillRegistersMode spillMode, ExceptionCheckRequirement requirement,
196     ResultType result, Arguments... arguments)
197 {
198     return makeUnique&lt;CallResultAndArgumentsSlowPathGenerator&lt;JumpType, FunctionType, ResultType, Arguments...&gt;&gt;(
199         from, jit, function, spillMode, requirement, result, arguments...);
200 }
201 
202 template&lt;typename JumpType, typename FunctionType, typename ResultType, typename... Arguments&gt;
203 inline std::unique_ptr&lt;SlowPathGenerator&gt; slowPathCall(
204     JumpType from, SpeculativeJIT* jit, FunctionType function,
205     ResultType result, Arguments... arguments)
206 {
207     return slowPathCall(
208         from, jit, function, NeedToSpill, ExceptionCheckRequirement::CheckNeeded, result, arguments...);
</pre>
</td>
</tr>
</table>
<center><a href="DFGScoreBoard.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSpeculativeJIT.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
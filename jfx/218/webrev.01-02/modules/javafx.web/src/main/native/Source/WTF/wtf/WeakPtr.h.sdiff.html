<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/WeakPtr.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WeakHashSet.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WordLock.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/WeakPtr.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 51     WTF_MAKE_FAST_ALLOCATED;
 52 public:
 53     template&lt;typename T&gt; static Ref&lt;WeakPtrImpl&gt; create(T* ptr)
 54     {
 55         return adoptRef(*new WeakPtrImpl(ptr));
 56     }
 57 
 58     ~WeakPtrImpl()
 59     {
 60         WILL_DESTROY_WEAK_PTR_IMPL(m_ptr);
 61     }
 62 
 63     template&lt;typename T&gt; typename T::WeakValueType* get()
 64     {
 65         return static_cast&lt;typename T::WeakValueType*&gt;(m_ptr);
 66     }
 67 
 68     explicit operator bool() const { return m_ptr; }
 69     void clear() { m_ptr = nullptr; }
 70 
<span class="line-modified"> 71 #if !ASSERT_DISABLED</span>
 72     bool wasConstructedOnMainThread() const { return m_wasConstructedOnMainThread; }
 73 #endif
 74 
 75 private:
 76     template&lt;typename T&gt; explicit WeakPtrImpl(T* ptr)
 77         : m_ptr(static_cast&lt;typename T::WeakValueType*&gt;(ptr))
<span class="line-modified"> 78 #if !ASSERT_DISABLED</span>
 79         , m_wasConstructedOnMainThread(isMainThread())
 80 #endif
 81     {
 82         DID_CREATE_WEAK_PTR_IMPL(ptr);
 83     }
 84 
 85     void* m_ptr;
<span class="line-modified"> 86 #if !ASSERT_DISABLED</span>
 87     bool m_wasConstructedOnMainThread;
 88 #endif
 89 };
 90 
 91 template&lt;typename T&gt;
 92 class WeakPtr {
 93     WTF_MAKE_FAST_ALLOCATED;
 94 public:
 95     WeakPtr() { }
 96     WeakPtr(std::nullptr_t) { }
 97     template&lt;typename U&gt; WeakPtr(const WeakPtr&lt;U&gt;&amp;);
 98     template&lt;typename U&gt; WeakPtr(WeakPtr&lt;U&gt;&amp;&amp;);
 99 
100     T* get() const
101     {
102         // FIXME: Our GC threads currently need to get opaque pointers from WeakPtrs and have to be special-cased.
103         ASSERT(!m_impl || Thread::mayBeGCThread() || m_impl-&gt;wasConstructedOnMainThread() == isMainThread());
104         return m_impl ? static_cast&lt;T*&gt;(m_impl-&gt;get&lt;T&gt;()) : nullptr;
105     }
106 
</pre>
<hr />
<pre>
124 
125     void clear() { m_impl = nullptr; }
126 
127 private:
128     explicit WeakPtr(Ref&lt;WeakPtrImpl&gt;&amp;&amp; ref) : m_impl(WTFMove(ref)) { }
129     template&lt;typename&gt; friend class WeakHashSet;
130     template&lt;typename&gt; friend class WeakPtr;
131     template&lt;typename&gt; friend class WeakPtrFactory;
132     template&lt;typename U&gt; friend WeakPtr&lt;U&gt; makeWeakPtr(U&amp;);
133 
134     RefPtr&lt;WeakPtrImpl&gt; m_impl;
135 };
136 
137 // Note: you probably want to inherit from CanMakeWeakPtr rather than use this directly.
138 template&lt;typename T&gt;
139 class WeakPtrFactory {
140     WTF_MAKE_NONCOPYABLE(WeakPtrFactory&lt;T&gt;);
141     WTF_MAKE_FAST_ALLOCATED;
142 public:
143     WeakPtrFactory()
<span class="line-modified">144 #if !ASSERT_DISABLED</span>
145         : m_wasConstructedOnMainThread(isMainThread())
146 #endif
147     {
148     }
149 
150     ~WeakPtrFactory()
151     {
152         if (!m_impl)
153             return;
154         m_impl-&gt;clear();
155     }
156 
157     void initializeIfNeeded(const T&amp; object) const
158     {
159         if (m_impl)
160             return;
161 
162         ASSERT(m_wasConstructedOnMainThread == isMainThread());
163         m_impl = WeakPtrImpl::create(const_cast&lt;T*&gt;(&amp;object));
164     }
</pre>
<hr />
<pre>
175     {
176         initializeIfNeeded(object);
177 
178         ASSERT(&amp;object == m_impl-&gt;get&lt;T&gt;());
179         return WeakPtr&lt;T&gt;(makeRef(*m_impl));
180     }
181 
182     void revokeAll()
183     {
184         if (!m_impl)
185             return;
186 
187         m_impl-&gt;clear();
188         m_impl = nullptr;
189     }
190 
191 private:
192     template&lt;typename&gt; friend class WeakHashSet;
193 
194     mutable RefPtr&lt;WeakPtrImpl&gt; m_impl;
<span class="line-modified">195 #if !ASSERT_DISABLED</span>
196     bool m_wasConstructedOnMainThread;
197 #endif
198 };
199 
200 // We use lazy initialization of the WeakPtrFactory by default to avoid unnecessary initialization. Eager
201 // initialization is however useful if you plan to call makeWeakPtr() from other threads.
202 enum class WeakPtrFactoryInitialization { Lazy, Eager };
203 
204 template&lt;typename T, WeakPtrFactoryInitialization initializationMode = WeakPtrFactoryInitialization::Lazy&gt; class CanMakeWeakPtr {
205 public:
206     using WeakValueType = T;
207 
208     const WeakPtrFactory&lt;T&gt;&amp; weakPtrFactory() const { return m_weakPtrFactory; }
209     WeakPtrFactory&lt;T&gt;&amp; weakPtrFactory() { return m_weakPtrFactory; }
210 
211 protected:
212     CanMakeWeakPtr()
213     {
214         if (initializationMode == WeakPtrFactoryInitialization::Eager)
215             m_weakPtrFactory.initializeIfNeeded(static_cast&lt;T&amp;&gt;(*this));
</pre>
</td>
<td>
<hr />
<pre>
 51     WTF_MAKE_FAST_ALLOCATED;
 52 public:
 53     template&lt;typename T&gt; static Ref&lt;WeakPtrImpl&gt; create(T* ptr)
 54     {
 55         return adoptRef(*new WeakPtrImpl(ptr));
 56     }
 57 
 58     ~WeakPtrImpl()
 59     {
 60         WILL_DESTROY_WEAK_PTR_IMPL(m_ptr);
 61     }
 62 
 63     template&lt;typename T&gt; typename T::WeakValueType* get()
 64     {
 65         return static_cast&lt;typename T::WeakValueType*&gt;(m_ptr);
 66     }
 67 
 68     explicit operator bool() const { return m_ptr; }
 69     void clear() { m_ptr = nullptr; }
 70 
<span class="line-modified"> 71 #if ASSERT_ENABLED</span>
 72     bool wasConstructedOnMainThread() const { return m_wasConstructedOnMainThread; }
 73 #endif
 74 
 75 private:
 76     template&lt;typename T&gt; explicit WeakPtrImpl(T* ptr)
 77         : m_ptr(static_cast&lt;typename T::WeakValueType*&gt;(ptr))
<span class="line-modified"> 78 #if ASSERT_ENABLED</span>
 79         , m_wasConstructedOnMainThread(isMainThread())
 80 #endif
 81     {
 82         DID_CREATE_WEAK_PTR_IMPL(ptr);
 83     }
 84 
 85     void* m_ptr;
<span class="line-modified"> 86 #if ASSERT_ENABLED</span>
 87     bool m_wasConstructedOnMainThread;
 88 #endif
 89 };
 90 
 91 template&lt;typename T&gt;
 92 class WeakPtr {
 93     WTF_MAKE_FAST_ALLOCATED;
 94 public:
 95     WeakPtr() { }
 96     WeakPtr(std::nullptr_t) { }
 97     template&lt;typename U&gt; WeakPtr(const WeakPtr&lt;U&gt;&amp;);
 98     template&lt;typename U&gt; WeakPtr(WeakPtr&lt;U&gt;&amp;&amp;);
 99 
100     T* get() const
101     {
102         // FIXME: Our GC threads currently need to get opaque pointers from WeakPtrs and have to be special-cased.
103         ASSERT(!m_impl || Thread::mayBeGCThread() || m_impl-&gt;wasConstructedOnMainThread() == isMainThread());
104         return m_impl ? static_cast&lt;T*&gt;(m_impl-&gt;get&lt;T&gt;()) : nullptr;
105     }
106 
</pre>
<hr />
<pre>
124 
125     void clear() { m_impl = nullptr; }
126 
127 private:
128     explicit WeakPtr(Ref&lt;WeakPtrImpl&gt;&amp;&amp; ref) : m_impl(WTFMove(ref)) { }
129     template&lt;typename&gt; friend class WeakHashSet;
130     template&lt;typename&gt; friend class WeakPtr;
131     template&lt;typename&gt; friend class WeakPtrFactory;
132     template&lt;typename U&gt; friend WeakPtr&lt;U&gt; makeWeakPtr(U&amp;);
133 
134     RefPtr&lt;WeakPtrImpl&gt; m_impl;
135 };
136 
137 // Note: you probably want to inherit from CanMakeWeakPtr rather than use this directly.
138 template&lt;typename T&gt;
139 class WeakPtrFactory {
140     WTF_MAKE_NONCOPYABLE(WeakPtrFactory&lt;T&gt;);
141     WTF_MAKE_FAST_ALLOCATED;
142 public:
143     WeakPtrFactory()
<span class="line-modified">144 #if ASSERT_ENABLED</span>
145         : m_wasConstructedOnMainThread(isMainThread())
146 #endif
147     {
148     }
149 
150     ~WeakPtrFactory()
151     {
152         if (!m_impl)
153             return;
154         m_impl-&gt;clear();
155     }
156 
157     void initializeIfNeeded(const T&amp; object) const
158     {
159         if (m_impl)
160             return;
161 
162         ASSERT(m_wasConstructedOnMainThread == isMainThread());
163         m_impl = WeakPtrImpl::create(const_cast&lt;T*&gt;(&amp;object));
164     }
</pre>
<hr />
<pre>
175     {
176         initializeIfNeeded(object);
177 
178         ASSERT(&amp;object == m_impl-&gt;get&lt;T&gt;());
179         return WeakPtr&lt;T&gt;(makeRef(*m_impl));
180     }
181 
182     void revokeAll()
183     {
184         if (!m_impl)
185             return;
186 
187         m_impl-&gt;clear();
188         m_impl = nullptr;
189     }
190 
191 private:
192     template&lt;typename&gt; friend class WeakHashSet;
193 
194     mutable RefPtr&lt;WeakPtrImpl&gt; m_impl;
<span class="line-modified">195 #if ASSERT_ENABLED</span>
196     bool m_wasConstructedOnMainThread;
197 #endif
198 };
199 
200 // We use lazy initialization of the WeakPtrFactory by default to avoid unnecessary initialization. Eager
201 // initialization is however useful if you plan to call makeWeakPtr() from other threads.
202 enum class WeakPtrFactoryInitialization { Lazy, Eager };
203 
204 template&lt;typename T, WeakPtrFactoryInitialization initializationMode = WeakPtrFactoryInitialization::Lazy&gt; class CanMakeWeakPtr {
205 public:
206     using WeakValueType = T;
207 
208     const WeakPtrFactory&lt;T&gt;&amp; weakPtrFactory() const { return m_weakPtrFactory; }
209     WeakPtrFactory&lt;T&gt;&amp; weakPtrFactory() { return m_weakPtrFactory; }
210 
211 protected:
212     CanMakeWeakPtr()
213     {
214         if (initializationMode == WeakPtrFactoryInitialization::Eager)
215             m_weakPtrFactory.initializeIfNeeded(static_cast&lt;T&amp;&gt;(*this));
</pre>
</td>
</tr>
</table>
<center><a href="WeakHashSet.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WordLock.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
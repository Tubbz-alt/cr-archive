<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityListBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2008 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;AccessibilityListBox.h&quot;
 31 
 32 #include &quot;AXObjectCache.h&quot;
 33 #include &quot;AccessibilityListBoxOption.h&quot;
 34 #include &quot;HTMLNames.h&quot;
 35 #include &quot;HTMLSelectElement.h&quot;
 36 #include &quot;HitTestResult.h&quot;
 37 #include &quot;RenderListBox.h&quot;
 38 #include &quot;RenderObject.h&quot;
 39 
 40 namespace WebCore {
 41 
 42 using namespace HTMLNames;
 43 
 44 AccessibilityListBox::AccessibilityListBox(RenderObject* renderer)
 45     : AccessibilityRenderObject(renderer)
 46 {
 47 }
 48 
 49 AccessibilityListBox::~AccessibilityListBox() = default;
 50 
 51 Ref&lt;AccessibilityListBox&gt; AccessibilityListBox::create(RenderObject* renderer)
 52 {
 53     return adoptRef(*new AccessibilityListBox(renderer));
 54 }
 55 
 56 bool AccessibilityListBox::canSetSelectedChildrenAttribute() const
 57 {
 58     Node* selectNode = m_renderer-&gt;node();
 59     if (!selectNode)
 60         return false;
 61 
 62     return !downcast&lt;HTMLSelectElement&gt;(*selectNode).isDisabledFormControl();
 63 }
 64 
 65 void AccessibilityListBox::addChildren()
 66 {
 67     Node* selectNode = m_renderer-&gt;node();
 68     if (!selectNode)
 69         return;
 70 
 71     m_haveChildren = true;
 72 
 73     for (const auto&amp; listItem : downcast&lt;HTMLSelectElement&gt;(*selectNode).listItems()) {
 74         // The cast to HTMLElement below is safe because the only other possible listItem type
 75         // would be a WMLElement, but WML builds don&#39;t use accessibility features at all.
 76         AccessibilityObject* listOption = listBoxOptionAccessibilityObject(listItem);
 77         if (listOption &amp;&amp; !listOption-&gt;accessibilityIsIgnored())
 78             m_children.append(listOption);
 79     }
 80 }
 81 
 82 void AccessibilityListBox::setSelectedChildren(const AccessibilityChildrenVector&amp; children)
 83 {
 84     if (!canSetSelectedChildrenAttribute())
 85         return;
 86 
 87     Node* selectNode = m_renderer-&gt;node();
 88     if (!selectNode)
 89         return;
 90 
 91     // disable any selected options
 92     for (const auto&amp; child : m_children) {
 93         auto&amp; listBoxOption = downcast&lt;AccessibilityListBoxOption&gt;(*child);
 94         if (listBoxOption.isSelected())
 95             listBoxOption.setSelected(false);
 96     }
 97 
 98     for (const auto&amp; obj : children) {
 99         if (obj-&gt;roleValue() != AccessibilityRole::ListBoxOption)
100             continue;
101 
102         downcast&lt;AccessibilityListBoxOption&gt;(*obj).setSelected(true);
103     }
104 }
105 
106 void AccessibilityListBox::selectedChildren(AccessibilityChildrenVector&amp; result)
107 {
108     ASSERT(result.isEmpty());
109 
110     if (!hasChildren())
111         addChildren();
112 
113     for (const auto&amp; child : m_children) {
114         if (downcast&lt;AccessibilityListBoxOption&gt;(*child).isSelected())
115             result.append(child.get());
116     }
117 }
118 
119 void AccessibilityListBox::visibleChildren(AccessibilityChildrenVector&amp; result)
120 {
121     ASSERT(result.isEmpty());
122 
123     if (!hasChildren())
124         addChildren();
125 
126     unsigned length = m_children.size();
127     for (unsigned i = 0; i &lt; length; i++) {
128         if (downcast&lt;RenderListBox&gt;(*m_renderer).listIndexIsVisible(i))
129             result.append(m_children[i]);
130     }
131 }
132 
133 AccessibilityObject* AccessibilityListBox::listBoxOptionAccessibilityObject(HTMLElement* element) const
134 {
135     // skip hr elements
136     if (!element || element-&gt;hasTagName(hrTag))
137         return nullptr;
138 
139     AccessibilityObject&amp; listBoxObject = *m_renderer-&gt;document().axObjectCache()-&gt;getOrCreate(AccessibilityRole::ListBoxOption);
140     downcast&lt;AccessibilityListBoxOption&gt;(listBoxObject).setHTMLElement(element);
141 
142     return &amp;listBoxObject;
143 }
144 
<a name="1" id="anc1"></a><span class="line-modified">145 AccessibilityObject* AccessibilityListBox::elementAccessibilityHitTest(const IntPoint&amp; point) const</span>
146 {
147     // the internal HTMLSelectElement methods for returning a listbox option at a point
148     // ignore optgroup elements.
149     if (!m_renderer)
150         return nullptr;
151 
152     Node* node = m_renderer-&gt;node();
153     if (!node)
154         return nullptr;
155 
156     LayoutRect parentRect = boundingBoxRect();
157 
<a name="2" id="anc2"></a><span class="line-modified">158     AccessibilityObject* listBoxOption = nullptr;</span>
159     unsigned length = m_children.size();
160     for (unsigned i = 0; i &lt; length; ++i) {
161         LayoutRect rect = downcast&lt;RenderListBox&gt;(*m_renderer).itemBoundingBoxRect(parentRect.location(), i);
162         // The cast to HTMLElement below is safe because the only other possible listItem type
163         // would be a WMLElement, but WML builds don&#39;t use accessibility features at all.
164         if (rect.contains(point)) {
165             listBoxOption = m_children[i].get();
166             break;
167         }
168     }
169 
170     if (listBoxOption &amp;&amp; !listBoxOption-&gt;accessibilityIsIgnored())
171         return listBoxOption;
172 
173     return axObjectCache()-&gt;getOrCreate(renderer());
174 }
175 
176 } // namespace WebCore
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
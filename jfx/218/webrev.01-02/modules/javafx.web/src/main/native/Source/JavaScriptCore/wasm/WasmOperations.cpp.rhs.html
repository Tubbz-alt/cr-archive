<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmOperations.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
<a name="1" id="anc1"></a><span class="line-added"> 31 #include &quot;ButterflyInlines.h&quot;</span>
<span class="line-added"> 32 #include &quot;FrameTracers.h&quot;</span>
<span class="line-added"> 33 #include &quot;IteratorOperations.h&quot;</span>
<span class="line-added"> 34 #include &quot;JITExceptions.h&quot;</span>
<span class="line-added"> 35 #include &quot;JSCJSValueInlines.h&quot;</span>
<span class="line-added"> 36 #include &quot;JSGlobalObjectInlines.h&quot;</span>
<span class="line-added"> 37 #include &quot;JSWebAssemblyHelpers.h&quot;</span>
<span class="line-added"> 38 #include &quot;JSWebAssemblyInstance.h&quot;</span>
<span class="line-added"> 39 #include &quot;JSWebAssemblyRuntimeError.h&quot;</span>
 40 #include &quot;ProbeContext.h&quot;
 41 #include &quot;WasmCallee.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 42 #include &quot;WasmCallingConvention.h&quot;</span>
 43 #include &quot;WasmContextInlines.h&quot;
 44 #include &quot;WasmInstance.h&quot;
 45 #include &quot;WasmMemory.h&quot;
 46 #include &quot;WasmNameSection.h&quot;
 47 #include &quot;WasmOMGForOSREntryPlan.h&quot;
 48 #include &quot;WasmOMGPlan.h&quot;
 49 #include &quot;WasmOSREntryData.h&quot;
 50 #include &quot;WasmSignatureInlines.h&quot;
 51 #include &quot;WasmWorklist.h&quot;
 52 #include &lt;wtf/DataLog.h&gt;
 53 #include &lt;wtf/Locker.h&gt;
 54 #include &lt;wtf/MonotonicTime.h&gt;
 55 #include &lt;wtf/StdLibExtras.h&gt;
 56 
<a name="3" id="anc3"></a><span class="line-added"> 57 IGNORE_WARNINGS_BEGIN(&quot;frame-address&quot;)</span>
<span class="line-added"> 58 </span>
 59 namespace JSC { namespace Wasm {
 60 
<a name="4" id="anc4"></a><span class="line-added"> 61 void JIT_OPERATION operationWasmThrowBadI64(JSWebAssemblyInstance* instance)</span>
<span class="line-added"> 62 {</span>
<span class="line-added"> 63     VM&amp; vm = instance-&gt;vm();</span>
<span class="line-added"> 64     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added"> 65     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added"> 66 </span>
<span class="line-added"> 67     {</span>
<span class="line-added"> 68         auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added"> 69         JSGlobalObject* globalObject = instance-&gt;globalObject();</span>
<span class="line-added"> 70         auto* error = ErrorInstance::create(globalObject, vm, globalObject-&gt;errorStructure(ErrorType::TypeError), &quot;i64 not allowed as return type or argument to an imported function&quot;_s);</span>
<span class="line-added"> 71         throwException(globalObject, throwScope, error);</span>
<span class="line-added"> 72     }</span>
<span class="line-added"> 73 </span>
<span class="line-added"> 74     genericUnwind(vm, callFrame);</span>
<span class="line-added"> 75     ASSERT(!!vm.callFrameForCatch);</span>
<span class="line-added"> 76 }</span>
<span class="line-added"> 77 </span>
 78 static bool shouldTriggerOMGCompile(TierUpCount&amp; tierUp, OMGCallee* replacement, uint32_t functionIndex)
 79 {
 80     if (!replacement &amp;&amp; !tierUp.checkIfOptimizationThresholdReached()) {
 81         dataLogLnIf(Options::verboseOSR(), &quot;delayOMGCompile counter = &quot;, tierUp, &quot; for &quot;, functionIndex);
 82         dataLogLnIf(Options::verboseOSR(), &quot;Choosing not to OMG-optimize &quot;, functionIndex, &quot; yet.&quot;);
 83         return false;
 84     }
 85     return true;
 86 }
 87 
 88 static void triggerOMGReplacementCompile(TierUpCount&amp; tierUp, OMGCallee* replacement, Instance* instance, Wasm::CodeBlock&amp; codeBlock, uint32_t functionIndex)
 89 {
 90     if (replacement) {
 91         tierUp.optimizeSoon(functionIndex);
 92         return;
 93     }
 94 
 95     bool compile = false;
 96     {
 97         auto locker = holdLock(tierUp.getLock());
 98         switch (tierUp.m_compilationStatusForOMG) {
 99         case TierUpCount::CompilationStatus::StartCompilation:
100             tierUp.setOptimizationThresholdBasedOnCompilationResult(functionIndex, CompilationDeferred);
101             return;
102         case TierUpCount::CompilationStatus::NotCompiled:
103             compile = true;
104             tierUp.m_compilationStatusForOMG = TierUpCount::CompilationStatus::StartCompilation;
105             break;
106         default:
107             break;
108         }
109     }
110 
111     if (compile) {
112         dataLogLnIf(Options::verboseOSR(), &quot;triggerOMGReplacement for &quot;, functionIndex);
113         // We need to compile the code.
114         Ref&lt;Plan&gt; plan = adoptRef(*new OMGPlan(instance-&gt;context(), Ref&lt;Wasm::Module&gt;(instance-&gt;module()), functionIndex, codeBlock.mode(), Plan::dontFinalize()));
115         ensureWorklist().enqueue(plan.copyRef());
116         if (UNLIKELY(!Options::useConcurrentJIT()))
117             plan-&gt;waitForCompletion();
118         else
119             tierUp.setOptimizationThresholdBasedOnCompilationResult(functionIndex, CompilationDeferred);
120     }
121 }
122 
123 SUPPRESS_ASAN
124 static void doOSREntry(Instance* instance, Probe::Context&amp; context, BBQCallee&amp; callee, OMGForOSREntryCallee&amp; osrEntryCallee, OSREntryData&amp; osrEntryData)
125 {
126     auto returnWithoutOSREntry = [&amp;] {
127         context.gpr(GPRInfo::argumentGPR0) = 0;
128     };
129 
<a name="5" id="anc5"></a><span class="line-added">130     RELEASE_ASSERT(osrEntryCallee.osrEntryScratchBufferSize() == osrEntryData.values().size());</span>
<span class="line-added">131 </span>
132     uint64_t* buffer = instance-&gt;context()-&gt;scratchBufferForSize(osrEntryCallee.osrEntryScratchBufferSize());
133     if (!buffer)
134         return returnWithoutOSREntry();
135 
136     dataLogLnIf(Options::verboseOSR(), osrEntryData.functionIndex(), &quot;:OMG OSR entry: got entry callee &quot;, RawPointer(&amp;osrEntryCallee));
137 
138     // 1. Place required values in scratch buffer.
139     for (unsigned index = 0; index &lt; osrEntryData.values().size(); ++index) {
140         const OSREntryValue&amp; value = osrEntryData.values()[index];
141         dataLogLnIf(Options::verboseOSR(), &quot;OMG OSR entry values[&quot;, index, &quot;] &quot;, value.type(), &quot; &quot;, value);
142         if (value.isGPR()) {
143             switch (value.type().kind()) {
144             case B3::Float:
145             case B3::Double:
146                 RELEASE_ASSERT_NOT_REACHED();
147             default:
148                 *bitwise_cast&lt;uint64_t*&gt;(buffer + index) = context.gpr(value.gpr());
149             }
150         } else if (value.isFPR()) {
151             switch (value.type().kind()) {
152             case B3::Float:
153             case B3::Double:
154                 *bitwise_cast&lt;double*&gt;(buffer + index) = context.fpr(value.fpr());
155                 break;
156             default:
157                 RELEASE_ASSERT_NOT_REACHED();
158             }
159         } else if (value.isConstant()) {
160             switch (value.type().kind()) {
161             case B3::Float:
162                 *bitwise_cast&lt;float*&gt;(buffer + index) = value.floatValue();
163                 break;
164             case B3::Double:
165                 *bitwise_cast&lt;double*&gt;(buffer + index) = value.doubleValue();
166                 break;
167             default:
168                 *bitwise_cast&lt;uint64_t*&gt;(buffer + index) = value.value();
169             }
170         } else if (value.isStack()) {
171             switch (value.type().kind()) {
172             case B3::Float:
173                 *bitwise_cast&lt;float*&gt;(buffer + index) = *bitwise_cast&lt;float*&gt;(bitwise_cast&lt;uint8_t*&gt;(context.fp()) + value.offsetFromFP());
174                 break;
175             case B3::Double:
176                 *bitwise_cast&lt;double*&gt;(buffer + index) = *bitwise_cast&lt;double*&gt;(bitwise_cast&lt;uint8_t*&gt;(context.fp()) + value.offsetFromFP());
177                 break;
178             default:
179                 *bitwise_cast&lt;uint64_t*&gt;(buffer + index) = *bitwise_cast&lt;uint64_t*&gt;(bitwise_cast&lt;uint8_t*&gt;(context.fp()) + value.offsetFromFP());
180                 break;
181             }
182         } else if (value.isStackArgument()) {
183             switch (value.type().kind()) {
184             case B3::Float:
185                 *bitwise_cast&lt;float*&gt;(buffer + index) = *bitwise_cast&lt;float*&gt;(bitwise_cast&lt;uint8_t*&gt;(context.sp()) + value.offsetFromSP());
186                 break;
187             case B3::Double:
188                 *bitwise_cast&lt;double*&gt;(buffer + index) = *bitwise_cast&lt;double*&gt;(bitwise_cast&lt;uint8_t*&gt;(context.sp()) + value.offsetFromSP());
189                 break;
190             default:
191                 *bitwise_cast&lt;uint64_t*&gt;(buffer + index) = *bitwise_cast&lt;uint64_t*&gt;(bitwise_cast&lt;uint8_t*&gt;(context.sp()) + value.offsetFromSP());
192                 break;
193             }
194         } else
195             RELEASE_ASSERT_NOT_REACHED();
196     }
197 
198     // 2. Restore callee saves.
199     RegisterSet dontRestoreRegisters = RegisterSet::stackRegisters();
200     for (const RegisterAtOffset&amp; entry : *callee.calleeSaveRegisters()) {
201         if (dontRestoreRegisters.get(entry.reg()))
202             continue;
203         if (entry.reg().isGPR())
204             context.gpr(entry.reg().gpr()) = *bitwise_cast&lt;UCPURegister*&gt;(bitwise_cast&lt;uint8_t*&gt;(context.fp()) + entry.offset());
205         else
206             context.fpr(entry.reg().fpr()) = *bitwise_cast&lt;double*&gt;(bitwise_cast&lt;uint8_t*&gt;(context.fp()) + entry.offset());
207     }
208 
209     // 3. Function epilogue, like a tail-call.
210     UCPURegister* framePointer = bitwise_cast&lt;UCPURegister*&gt;(context.fp());
211 #if CPU(X86_64)
212     // move(framePointerRegister, stackPointerRegister);
213     // pop(framePointerRegister);
214     context.fp() = bitwise_cast&lt;UCPURegister*&gt;(*framePointer);
215     context.sp() = framePointer + 1;
216     static_assert(AssemblyHelpers::prologueStackPointerDelta() == sizeof(void*) * 1);
217 #elif CPU(ARM64E) || CPU(ARM64)
218     // move(framePointerRegister, stackPointerRegister);
219     // popPair(framePointerRegister, linkRegister);
220     context.fp() = bitwise_cast&lt;UCPURegister*&gt;(*framePointer);
221     context.gpr(ARM64Registers::lr) = bitwise_cast&lt;UCPURegister&gt;(*(framePointer + 1));
222     context.sp() = framePointer + 2;
223     static_assert(AssemblyHelpers::prologueStackPointerDelta() == sizeof(void*) * 2);
224 #if CPU(ARM64E)
225     // LR needs to be untagged since OSR entry function prologue will tag it with SP. This is similar to tail-call.
226     context.gpr(ARM64Registers::lr) = bitwise_cast&lt;UCPURegister&gt;(untagCodePtr(context.gpr&lt;void*&gt;(ARM64Registers::lr), bitwise_cast&lt;PtrTag&gt;(context.sp())));
227 #endif
228 #else
229 #error Unsupported architecture.
230 #endif
231     // 4. Configure argument registers to jump to OSR entry from the caller of this runtime function.
232     context.gpr(GPRInfo::argumentGPR0) = bitwise_cast&lt;UCPURegister&gt;(buffer);
233     context.gpr(GPRInfo::argumentGPR1) = bitwise_cast&lt;UCPURegister&gt;(osrEntryCallee.entrypoint().executableAddress&lt;&gt;());
234 }
235 
<a name="6" id="anc6"></a><span class="line-modified">236 void JIT_OPERATION operationWasmTriggerOSREntryNow(Probe::Context&amp; context)</span>
237 {
238     OSREntryData&amp; osrEntryData = *context.arg&lt;OSREntryData*&gt;();
239     uint32_t functionIndex = osrEntryData.functionIndex();
240     uint32_t loopIndex = osrEntryData.loopIndex();
241     Instance* instance = Wasm::Context::tryLoadInstanceFromTLS();
242     if (!instance)
243         instance = context.gpr&lt;Instance*&gt;(Wasm::PinnedRegisterInfo::get().wasmContextInstancePointer);
244 
245     auto returnWithoutOSREntry = [&amp;] {
246         context.gpr(GPRInfo::argumentGPR0) = 0;
247     };
248 
249     Wasm::CodeBlock&amp; codeBlock = *instance-&gt;codeBlock();
250     ASSERT(instance-&gt;memory()-&gt;mode() == codeBlock.mode());
251 
252     uint32_t functionIndexInSpace = functionIndex + codeBlock.functionImportCount();
253     ASSERT(codeBlock.wasmBBQCalleeFromFunctionIndexSpace(functionIndexInSpace).compilationMode() == Wasm::CompilationMode::BBQMode);
254     BBQCallee&amp; callee = static_cast&lt;BBQCallee&amp;&gt;(codeBlock.wasmBBQCalleeFromFunctionIndexSpace(functionIndexInSpace));
255     TierUpCount&amp; tierUp = *callee.tierUpCount();
256     dataLogLnIf(Options::verboseOSR(), &quot;Consider OMGForOSREntryPlan for [&quot;, functionIndex, &quot;] loopIndex#&quot;, loopIndex, &quot; with executeCounter = &quot;, tierUp, &quot; &quot;, RawPointer(callee.replacement()));
257 
258     if (!Options::useWebAssemblyOSR()) {
259         if (shouldTriggerOMGCompile(tierUp, callee.replacement(), functionIndex))
260             triggerOMGReplacementCompile(tierUp, callee.replacement(), instance, codeBlock, functionIndex);
261 
262         // We already have an OMG replacement.
263         if (callee.replacement()) {
264             // No OSR entry points. Just defer indefinitely.
265             if (tierUp.osrEntryTriggers().isEmpty()) {
266                 tierUp.dontOptimizeAnytimeSoon(functionIndex);
267                 return;
268             }
269 
270             // Found one OSR entry point. Since we do not have a way to jettison Wasm::Callee right now, this means that tierUp function is now meaningless.
271             // Not call it as much as possible.
272             if (callee.osrEntryCallee()) {
273                 tierUp.dontOptimizeAnytimeSoon(functionIndex);
274                 return;
275             }
276         }
277         return returnWithoutOSREntry();
278     }
279 
280     TierUpCount::CompilationStatus compilationStatus = TierUpCount::CompilationStatus::NotCompiled;
281     {
282         auto locker = holdLock(tierUp.getLock());
283         compilationStatus = tierUp.m_compilationStatusForOMGForOSREntry;
284     }
285 
286     bool triggeredSlowPathToStartCompilation = false;
287     switch (tierUp.osrEntryTriggers()[loopIndex]) {
288     case TierUpCount::TriggerReason::DontTrigger:
289         // The trigger isn&#39;t set, we entered because the counter reached its
290         // threshold.
291         break;
292     case TierUpCount::TriggerReason::CompilationDone:
293         // The trigger was set because compilation completed. Don&#39;t unset it
294         // so that further BBQ executions OSR enter as well.
295         break;
296     case TierUpCount::TriggerReason::StartCompilation: {
297         // We were asked to enter as soon as possible and start compiling an
298         // entry for the current loopIndex. Unset this trigger so we
299         // don&#39;t continually enter.
300         auto locker = holdLock(tierUp.getLock());
301         TierUpCount::TriggerReason reason = tierUp.osrEntryTriggers()[loopIndex];
302         if (reason == TierUpCount::TriggerReason::StartCompilation) {
303             tierUp.osrEntryTriggers()[loopIndex] = TierUpCount::TriggerReason::DontTrigger;
304             triggeredSlowPathToStartCompilation = true;
305         }
306         break;
307     }
308     }
309 
310     if (compilationStatus == TierUpCount::CompilationStatus::StartCompilation) {
311         dataLogLnIf(Options::verboseOSR(), &quot;delayOMGCompile still compiling for &quot;, functionIndex);
312         tierUp.setOptimizationThresholdBasedOnCompilationResult(functionIndex, CompilationDeferred);
313         return returnWithoutOSREntry();
314     }
315 
316     if (OMGForOSREntryCallee* osrEntryCallee = callee.osrEntryCallee()) {
317         if (osrEntryCallee-&gt;loopIndex() == loopIndex)
318             return doOSREntry(instance, context, callee, *osrEntryCallee, osrEntryData);
319     }
320 
321     if (!shouldTriggerOMGCompile(tierUp, callee.replacement(), functionIndex) &amp;&amp; !triggeredSlowPathToStartCompilation)
322         return returnWithoutOSREntry();
323 
324     if (!triggeredSlowPathToStartCompilation) {
325         triggerOMGReplacementCompile(tierUp, callee.replacement(), instance, codeBlock, functionIndex);
326 
327         if (!callee.replacement())
328             return returnWithoutOSREntry();
329     }
330 
331     if (OMGForOSREntryCallee* osrEntryCallee = callee.osrEntryCallee()) {
332         if (osrEntryCallee-&gt;loopIndex() == loopIndex)
333             return doOSREntry(instance, context, callee, *osrEntryCallee, osrEntryData);
334         tierUp.dontOptimizeAnytimeSoon(functionIndex);
335         return returnWithoutOSREntry();
336     }
337 
338     // Instead of triggering OSR entry compilation in inner loop, try outer loop&#39;s trigger immediately effective (setting TriggerReason::StartCompilation) and
339     // let outer loop attempt to compile.
340     if (!triggeredSlowPathToStartCompilation) {
341         // An inner loop didn&#39;t specifically ask for us to kick off a compilation. This means the counter
342         // crossed its threshold. We either fall through and kick off a compile for originBytecodeIndex,
343         // or we flag an outer loop to immediately try to compile itself. If there are outer loops,
344         // we first try to make them compile themselves. But we will eventually fall back to compiling
345         // a progressively inner loop if it takes too long for control to reach an outer loop.
346 
347         auto tryTriggerOuterLoopToCompile = [&amp;] {
348             // We start with the outermost loop and make our way inwards (hence why we iterate the vector in reverse).
349             // Our policy is that we will trigger an outer loop to compile immediately when program control reaches it.
350             // If program control is taking too long to reach that outer loop, we progressively move inwards, meaning,
351             // we&#39;ll eventually trigger some loop that is executing to compile. We start with trying to compile outer
352             // loops since we believe outer loop compilations reveal the best opportunities for optimizing code.
353             uint32_t currentLoopIndex = tierUp.outerLoops()[loopIndex];
354             auto locker = holdLock(tierUp.getLock());
355 
356             // We already started OMGForOSREntryPlan.
357             if (callee.didStartCompilingOSREntryCallee())
358                 return false;
359 
360             while (currentLoopIndex != UINT32_MAX) {
361                 if (tierUp.osrEntryTriggers()[currentLoopIndex] == TierUpCount::TriggerReason::StartCompilation) {
362                     // This means that we already asked this loop to compile. If we&#39;ve reached here, it
363                     // means program control has not yet reached that loop. So it&#39;s taking too long to compile.
364                     // So we move on to asking the inner loop of this loop to compile itself.
365                     currentLoopIndex = tierUp.outerLoops()[currentLoopIndex];
366                     continue;
367                 }
368 
369                 // This is where we ask the outer to loop to immediately compile itself if program
370                 // control reaches it.
371                 dataLogLnIf(Options::verboseOSR(), &quot;Inner-loop loopIndex#&quot;, loopIndex, &quot; in &quot;, functionIndex, &quot; setting parent loop loopIndex#&quot;, currentLoopIndex, &quot;&#39;s trigger and backing off.&quot;);
372                 tierUp.osrEntryTriggers()[currentLoopIndex] = TierUpCount::TriggerReason::StartCompilation;
373                 return true;
374             }
375             return false;
376         };
377 
378         if (tryTriggerOuterLoopToCompile()) {
379             tierUp.setOptimizationThresholdBasedOnCompilationResult(functionIndex, CompilationDeferred);
380             return returnWithoutOSREntry();
381         }
382     }
383 
384     bool startOSREntryCompilation = false;
385     {
386         auto locker = holdLock(tierUp.getLock());
387         if (tierUp.m_compilationStatusForOMGForOSREntry == TierUpCount::CompilationStatus::NotCompiled) {
388             tierUp.m_compilationStatusForOMGForOSREntry = TierUpCount::CompilationStatus::StartCompilation;
389             startOSREntryCompilation = true;
390             // Currently, we do not have a way to jettison wasm code. This means that once we decide to compile OSR entry code for a particular loopIndex,
391             // we cannot throw the compiled code so long as Wasm module is live. We immediately disable all the triggers.
392             for (auto&amp; trigger : tierUp.osrEntryTriggers())
393                 trigger = TierUpCount::TriggerReason::DontTrigger;
394         }
395     }
396 
397     if (startOSREntryCompilation) {
398         dataLogLnIf(Options::verboseOSR(), &quot;triggerOMGOSR for &quot;, functionIndex);
399         Ref&lt;Plan&gt; plan = adoptRef(*new OMGForOSREntryPlan(instance-&gt;context(), Ref&lt;Wasm::Module&gt;(instance-&gt;module()), Ref&lt;Wasm::BBQCallee&gt;(callee), functionIndex, loopIndex, codeBlock.mode(), Plan::dontFinalize()));
400         ensureWorklist().enqueue(plan.copyRef());
401         if (UNLIKELY(!Options::useConcurrentJIT()))
402             plan-&gt;waitForCompletion();
403         else
404             tierUp.setOptimizationThresholdBasedOnCompilationResult(functionIndex, CompilationDeferred);
405     }
406 
407     OMGForOSREntryCallee* osrEntryCallee = callee.osrEntryCallee();
408     if (!osrEntryCallee) {
409         tierUp.setOptimizationThresholdBasedOnCompilationResult(functionIndex, CompilationDeferred);
410         return returnWithoutOSREntry();
411     }
412 
413     if (osrEntryCallee-&gt;loopIndex() == loopIndex)
414         return doOSREntry(instance, context, callee, *osrEntryCallee, osrEntryData);
415 
416     tierUp.dontOptimizeAnytimeSoon(functionIndex);
417     return returnWithoutOSREntry();
418 }
419 
<a name="7" id="anc7"></a><span class="line-modified">420 void JIT_OPERATION operationWasmTriggerTierUpNow(Instance* instance, uint32_t functionIndex)</span>
421 {
422     Wasm::CodeBlock&amp; codeBlock = *instance-&gt;codeBlock();
423     ASSERT(instance-&gt;memory()-&gt;mode() == codeBlock.mode());
424 
425     uint32_t functionIndexInSpace = functionIndex + codeBlock.functionImportCount();
426     ASSERT(codeBlock.wasmBBQCalleeFromFunctionIndexSpace(functionIndexInSpace).compilationMode() == Wasm::CompilationMode::BBQMode);
427     BBQCallee&amp; callee = static_cast&lt;BBQCallee&amp;&gt;(codeBlock.wasmBBQCalleeFromFunctionIndexSpace(functionIndexInSpace));
428     TierUpCount&amp; tierUp = *callee.tierUpCount();
429     dataLogLnIf(Options::verboseOSR(), &quot;Consider OMGPlan for [&quot;, functionIndex, &quot;] with executeCounter = &quot;, tierUp, &quot; &quot;, RawPointer(callee.replacement()));
430 
431     if (shouldTriggerOMGCompile(tierUp, callee.replacement(), functionIndex))
432         triggerOMGReplacementCompile(tierUp, callee.replacement(), instance, codeBlock, functionIndex);
433 
434     // We already have an OMG replacement.
435     if (callee.replacement()) {
436         // No OSR entry points. Just defer indefinitely.
437         if (tierUp.osrEntryTriggers().isEmpty()) {
438             dataLogLnIf(Options::verboseOSR(), &quot;delayOMGCompile replacement in place, delaying indefinitely for &quot;, functionIndex);
439             tierUp.dontOptimizeAnytimeSoon(functionIndex);
440             return;
441         }
442 
443         // Found one OSR entry point. Since we do not have a way to jettison Wasm::Callee right now, this means that tierUp function is now meaningless.
444         // Not call it as much as possible.
445         if (callee.osrEntryCallee()) {
446             dataLogLnIf(Options::verboseOSR(), &quot;delayOMGCompile trigger in place, delaying indefinitely for &quot;, functionIndex);
447             tierUp.dontOptimizeAnytimeSoon(functionIndex);
448             return;
449         }
450     }
451 }
452 
<a name="8" id="anc8"></a><span class="line-added">453 void JIT_OPERATION operationWasmUnwind(CallFrame* callFrame)</span>
<span class="line-added">454 {</span>
<span class="line-added">455     // FIXME: Consider passing JSWebAssemblyInstance* instead.</span>
<span class="line-added">456     // https://bugs.webkit.org/show_bug.cgi?id=203206</span>
<span class="line-added">457     VM&amp; vm = callFrame-&gt;deprecatedVM();</span>
<span class="line-added">458     NativeCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">459     genericUnwind(vm, callFrame);</span>
<span class="line-added">460     ASSERT(!!vm.callFrameForCatch);</span>
<span class="line-added">461 }</span>
<span class="line-added">462 </span>
<span class="line-added">463 double JIT_OPERATION operationConvertToF64(CallFrame* callFrame, JSValue v)</span>
<span class="line-added">464 {</span>
<span class="line-added">465     // FIXME: Consider passing JSWebAssemblyInstance* instead.</span>
<span class="line-added">466     // https://bugs.webkit.org/show_bug.cgi?id=203206</span>
<span class="line-added">467     VM&amp; vm = callFrame-&gt;deprecatedVM();</span>
<span class="line-added">468     NativeCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">469     return v.toNumber(callFrame-&gt;lexicalGlobalObject(vm));</span>
<span class="line-added">470 }</span>
<span class="line-added">471 </span>
<span class="line-added">472 int32_t JIT_OPERATION operationConvertToI32(CallFrame* callFrame, JSValue v)</span>
<span class="line-added">473 {</span>
<span class="line-added">474     // FIXME: Consider passing JSWebAssemblyInstance* instead.</span>
<span class="line-added">475     // https://bugs.webkit.org/show_bug.cgi?id=203206</span>
<span class="line-added">476     VM&amp; vm = callFrame-&gt;deprecatedVM();</span>
<span class="line-added">477     NativeCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">478     return v.toInt32(callFrame-&gt;lexicalGlobalObject(vm));</span>
<span class="line-added">479 }</span>
<span class="line-added">480 </span>
<span class="line-added">481 float JIT_OPERATION operationConvertToF32(CallFrame* callFrame, JSValue v)</span>
<span class="line-added">482 {</span>
<span class="line-added">483     // FIXME: Consider passing JSWebAssemblyInstance* instead.</span>
<span class="line-added">484     // https://bugs.webkit.org/show_bug.cgi?id=203206</span>
<span class="line-added">485     VM&amp; vm = callFrame-&gt;deprecatedVM();</span>
<span class="line-added">486     NativeCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">487     return static_cast&lt;float&gt;(v.toNumber(callFrame-&gt;lexicalGlobalObject(vm)));</span>
<span class="line-added">488 }</span>
<span class="line-added">489 </span>
<span class="line-added">490 void JIT_OPERATION operationIterateResults(CallFrame* callFrame, Instance* instance, const Signature* signature, JSValue result, uint64_t* registerResults, uint64_t* calleeFramePointer)</span>
<span class="line-added">491 {</span>
<span class="line-added">492     // FIXME: Consider passing JSWebAssemblyInstance* instead.</span>
<span class="line-added">493     // https://bugs.webkit.org/show_bug.cgi?id=203206</span>
<span class="line-added">494     JSWebAssemblyInstance* jsInstance = instance-&gt;owner&lt;JSWebAssemblyInstance&gt;();</span>
<span class="line-added">495     JSGlobalObject* globalObject = jsInstance-&gt;globalObject();</span>
<span class="line-added">496     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">497     NativeCallFrameTracer(vm, callFrame);</span>
<span class="line-added">498     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">499 </span>
<span class="line-added">500     auto wasmCallInfo = wasmCallingConvention().callInformationFor(*signature, CallRole::Callee);</span>
<span class="line-added">501     RegisterAtOffsetList registerResultOffsets = wasmCallInfo.computeResultsOffsetList();</span>
<span class="line-added">502 </span>
<span class="line-added">503     unsigned itemsInserted = 0;</span>
<span class="line-added">504     forEachInIterable(globalObject, result, [&amp;] (VM&amp; vm, JSGlobalObject* globalObject, JSValue value) -&gt; void {</span>
<span class="line-added">505         auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">506         if (itemsInserted &lt; signature-&gt;returnCount()) {</span>
<span class="line-added">507             uint64_t unboxedValue;</span>
<span class="line-added">508             switch (signature-&gt;returnType(itemsInserted)) {</span>
<span class="line-added">509             case I32:</span>
<span class="line-added">510                 unboxedValue = value.toInt32(globalObject);</span>
<span class="line-added">511                 break;</span>
<span class="line-added">512             case F32:</span>
<span class="line-added">513                 unboxedValue = bitwise_cast&lt;uint32_t&gt;(value.toFloat(globalObject));</span>
<span class="line-added">514                 break;</span>
<span class="line-added">515             case F64:</span>
<span class="line-added">516                 unboxedValue = bitwise_cast&lt;uint64_t&gt;(value.toNumber(globalObject));</span>
<span class="line-added">517                 break;</span>
<span class="line-added">518             case Funcref:</span>
<span class="line-added">519                 if (!value.isFunction(vm)) {</span>
<span class="line-added">520                     throwTypeError(globalObject, scope, &quot;Funcref value is not a function&quot;_s);</span>
<span class="line-added">521                     return;</span>
<span class="line-added">522                 }</span>
<span class="line-added">523                 FALLTHROUGH;</span>
<span class="line-added">524             case Anyref:</span>
<span class="line-added">525                 unboxedValue = bitwise_cast&lt;uint64_t&gt;(value);</span>
<span class="line-added">526                 RELEASE_ASSERT(Options::useWebAssemblyReferences());</span>
<span class="line-added">527                 break;</span>
<span class="line-added">528             default:</span>
<span class="line-added">529                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">530             }</span>
<span class="line-added">531 </span>
<span class="line-added">532             RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-added">533             auto rep = wasmCallInfo.results[itemsInserted];</span>
<span class="line-added">534             if (rep.isReg())</span>
<span class="line-added">535                 registerResults[registerResultOffsets.find(rep.reg())-&gt;offset() / sizeof(uint64_t)] = unboxedValue;</span>
<span class="line-added">536             else</span>
<span class="line-added">537                 calleeFramePointer[rep.offsetFromFP() / sizeof(uint64_t)] = unboxedValue;</span>
<span class="line-added">538         }</span>
<span class="line-added">539         itemsInserted++;</span>
<span class="line-added">540     });</span>
<span class="line-added">541     RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-added">542     if (itemsInserted != signature-&gt;returnCount())</span>
<span class="line-added">543         throwVMTypeError(globalObject, scope, &quot;Incorrect number of values returned to Wasm from JS&quot;);</span>
<span class="line-added">544 }</span>
<span class="line-added">545 </span>
<span class="line-added">546 // FIXME: It would be much easier to inline this when we have a global GC, which could probably mean we could avoid</span>
<span class="line-added">547 // spilling the results onto the stack.</span>
<span class="line-added">548 // Saved result registers should be placed on the stack just above the last stack result.</span>
<span class="line-added">549 JSArray* JIT_OPERATION operationAllocateResultsArray(CallFrame* callFrame, Wasm::Instance* instance, const Signature* signature, IndexingType indexingType, JSValue* stackPointerFromCallee)</span>
<span class="line-added">550 {</span>
<span class="line-added">551     JSWebAssemblyInstance* jsInstance = instance-&gt;owner&lt;JSWebAssemblyInstance&gt;();</span>
<span class="line-added">552     VM&amp; vm = jsInstance-&gt;vm();</span>
<span class="line-added">553     NativeCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">554 </span>
<span class="line-added">555     JSGlobalObject* globalObject = jsInstance-&gt;globalObject();</span>
<span class="line-added">556     ObjectInitializationScope initializationScope(globalObject-&gt;vm());</span>
<span class="line-added">557     JSArray* result = JSArray::tryCreateUninitializedRestricted(initializationScope, nullptr, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingType), signature-&gt;returnCount());</span>
<span class="line-added">558 </span>
<span class="line-added">559     // FIXME: Handle allocation failure...</span>
<span class="line-added">560     RELEASE_ASSERT(result);</span>
<span class="line-added">561 </span>
<span class="line-added">562     auto wasmCallInfo = wasmCallingConvention().callInformationFor(*signature);</span>
<span class="line-added">563     RegisterAtOffsetList registerResults = wasmCallInfo.computeResultsOffsetList();</span>
<span class="line-added">564 </span>
<span class="line-added">565     static_assert(sizeof(JSValue) == sizeof(CPURegister), &quot;The code below relies on this.&quot;);</span>
<span class="line-added">566     for (unsigned i = 0; i &lt; signature-&gt;returnCount(); ++i) {</span>
<span class="line-added">567         B3::ValueRep rep = wasmCallInfo.results[i];</span>
<span class="line-added">568         JSValue value;</span>
<span class="line-added">569         if (rep.isReg())</span>
<span class="line-added">570             value = stackPointerFromCallee[(registerResults.find(rep.reg())-&gt;offset() + wasmCallInfo.headerAndArgumentStackSizeInBytes) / sizeof(JSValue)];</span>
<span class="line-added">571         else</span>
<span class="line-added">572             value = stackPointerFromCallee[rep.offsetFromSP() / sizeof(JSValue)];</span>
<span class="line-added">573         result-&gt;initializeIndex(initializationScope, i, value);</span>
<span class="line-added">574     }</span>
<span class="line-added">575 </span>
<span class="line-added">576     ASSERT(result-&gt;indexingType() == indexingType);</span>
<span class="line-added">577     return result;</span>
<span class="line-added">578 }</span>
<span class="line-added">579 </span>
<span class="line-added">580 void JIT_OPERATION operationWasmWriteBarrierSlowPath(JSCell* cell, VM* vmPointer)</span>
<span class="line-added">581 {</span>
<span class="line-added">582     ASSERT(cell);</span>
<span class="line-added">583     ASSERT(vmPointer);</span>
<span class="line-added">584     VM&amp; vm = *vmPointer;</span>
<span class="line-added">585     vm.heap.writeBarrierSlowPath(cell);</span>
<span class="line-added">586 }</span>
<span class="line-added">587 </span>
<span class="line-added">588 uint32_t JIT_OPERATION operationPopcount32(int32_t value)</span>
<span class="line-added">589 {</span>
<span class="line-added">590     return __builtin_popcount(value);</span>
<span class="line-added">591 }</span>
<span class="line-added">592 </span>
<span class="line-added">593 uint64_t JIT_OPERATION operationPopcount64(int64_t value)</span>
<span class="line-added">594 {</span>
<span class="line-added">595     return __builtin_popcountll(value);</span>
<span class="line-added">596 }</span>
<span class="line-added">597 </span>
<span class="line-added">598 int32_t JIT_OPERATION operationGrowMemory(void* callFrame, Instance* instance, int32_t delta)</span>
<span class="line-added">599 {</span>
<span class="line-added">600     instance-&gt;storeTopCallFrame(callFrame);</span>
<span class="line-added">601 </span>
<span class="line-added">602     if (delta &lt; 0)</span>
<span class="line-added">603         return -1;</span>
<span class="line-added">604 </span>
<span class="line-added">605     auto grown = instance-&gt;memory()-&gt;grow(PageCount(delta));</span>
<span class="line-added">606     if (!grown) {</span>
<span class="line-added">607         switch (grown.error()) {</span>
<span class="line-added">608         case Memory::GrowFailReason::InvalidDelta:</span>
<span class="line-added">609         case Memory::GrowFailReason::InvalidGrowSize:</span>
<span class="line-added">610         case Memory::GrowFailReason::WouldExceedMaximum:</span>
<span class="line-added">611         case Memory::GrowFailReason::OutOfMemory:</span>
<span class="line-added">612             return -1;</span>
<span class="line-added">613         }</span>
<span class="line-added">614         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">615     }</span>
<span class="line-added">616 </span>
<span class="line-added">617     return grown.value().pageCount();</span>
<span class="line-added">618 }</span>
<span class="line-added">619 </span>
<span class="line-added">620 EncodedJSValue JIT_OPERATION operationGetWasmTableElement(Instance* instance, unsigned tableIndex, int32_t signedIndex)</span>
<span class="line-added">621 {</span>
<span class="line-added">622     ASSERT(tableIndex &lt; instance-&gt;module().moduleInformation().tableCount());</span>
<span class="line-added">623     if (signedIndex &lt; 0)</span>
<span class="line-added">624         return 0;</span>
<span class="line-added">625 </span>
<span class="line-added">626     uint32_t index = signedIndex;</span>
<span class="line-added">627     if (index &gt;= instance-&gt;table(tableIndex)-&gt;length())</span>
<span class="line-added">628         return 0;</span>
<span class="line-added">629 </span>
<span class="line-added">630     return JSValue::encode(instance-&gt;table(tableIndex)-&gt;get(index));</span>
<span class="line-added">631 }</span>
<span class="line-added">632 </span>
<span class="line-added">633 static bool setWasmTableElement(Instance* instance, unsigned tableIndex, int32_t signedIndex, EncodedJSValue encValue)</span>
<span class="line-added">634 {</span>
<span class="line-added">635     ASSERT(tableIndex &lt; instance-&gt;module().moduleInformation().tableCount());</span>
<span class="line-added">636     if (signedIndex &lt; 0)</span>
<span class="line-added">637         return false;</span>
<span class="line-added">638 </span>
<span class="line-added">639     uint32_t index = signedIndex;</span>
<span class="line-added">640     if (index &gt;= instance-&gt;table(tableIndex)-&gt;length())</span>
<span class="line-added">641         return false;</span>
<span class="line-added">642 </span>
<span class="line-added">643     JSValue value = JSValue::decode(encValue);</span>
<span class="line-added">644     if (instance-&gt;table(tableIndex)-&gt;type() == Wasm::TableElementType::Anyref)</span>
<span class="line-added">645         instance-&gt;table(tableIndex)-&gt;set(index, value);</span>
<span class="line-added">646     else if (instance-&gt;table(tableIndex)-&gt;type() == Wasm::TableElementType::Funcref) {</span>
<span class="line-added">647         WebAssemblyFunction* wasmFunction;</span>
<span class="line-added">648         WebAssemblyWrapperFunction* wasmWrapperFunction;</span>
<span class="line-added">649 </span>
<span class="line-added">650         if (isWebAssemblyHostFunction(instance-&gt;owner&lt;JSObject&gt;()-&gt;vm(), value, wasmFunction, wasmWrapperFunction)) {</span>
<span class="line-added">651             ASSERT(!!wasmFunction || !!wasmWrapperFunction);</span>
<span class="line-added">652             if (wasmFunction)</span>
<span class="line-added">653                 instance-&gt;table(tableIndex)-&gt;asFuncrefTable()-&gt;setFunction(index, jsCast&lt;JSObject*&gt;(value), wasmFunction-&gt;importableFunction(), &amp;wasmFunction-&gt;instance()-&gt;instance());</span>
<span class="line-added">654             else</span>
<span class="line-added">655                 instance-&gt;table(tableIndex)-&gt;asFuncrefTable()-&gt;setFunction(index, jsCast&lt;JSObject*&gt;(value), wasmWrapperFunction-&gt;importableFunction(), &amp;wasmWrapperFunction-&gt;instance()-&gt;instance());</span>
<span class="line-added">656         } else if (value.isNull())</span>
<span class="line-added">657             instance-&gt;table(tableIndex)-&gt;clear(index);</span>
<span class="line-added">658         else</span>
<span class="line-added">659             ASSERT_NOT_REACHED();</span>
<span class="line-added">660     } else</span>
<span class="line-added">661         ASSERT_NOT_REACHED();</span>
<span class="line-added">662 </span>
<span class="line-added">663     return true;</span>
<span class="line-added">664 }</span>
<span class="line-added">665 </span>
<span class="line-added">666 bool JIT_OPERATION operationSetWasmTableElement(Instance* instance, unsigned tableIndex, int32_t signedIndex, EncodedJSValue encValue)</span>
<span class="line-added">667 {</span>
<span class="line-added">668     return setWasmTableElement(instance, tableIndex, signedIndex, encValue);</span>
<span class="line-added">669 }</span>
<span class="line-added">670 </span>
<span class="line-added">671 int32_t JIT_OPERATION operationWasmTableGrow(Instance* instance, unsigned tableIndex, EncodedJSValue fill, int32_t delta)</span>
<span class="line-added">672 {</span>
<span class="line-added">673     ASSERT(tableIndex &lt; instance-&gt;module().moduleInformation().tableCount());</span>
<span class="line-added">674     auto oldSize = instance-&gt;table(tableIndex)-&gt;length();</span>
<span class="line-added">675     if (delta &lt; 0)</span>
<span class="line-added">676         return oldSize;</span>
<span class="line-added">677     auto newSize = instance-&gt;table(tableIndex)-&gt;grow(delta);</span>
<span class="line-added">678     if (!newSize || *newSize == oldSize)</span>
<span class="line-added">679         return -1;</span>
<span class="line-added">680 </span>
<span class="line-added">681     for (unsigned i = oldSize; i &lt; instance-&gt;table(tableIndex)-&gt;length(); ++i)</span>
<span class="line-added">682         setWasmTableElement(instance, tableIndex, i, fill);</span>
<span class="line-added">683 </span>
<span class="line-added">684     return oldSize;</span>
<span class="line-added">685 }</span>
<span class="line-added">686 </span>
<span class="line-added">687 bool JIT_OPERATION operationWasmTableFill(Instance* instance, unsigned tableIndex, int32_t unsafeOffset, EncodedJSValue fill, int32_t unsafeCount)</span>
<span class="line-added">688 {</span>
<span class="line-added">689     ASSERT(tableIndex &lt; instance-&gt;module().moduleInformation().tableCount());</span>
<span class="line-added">690     if (unsafeOffset &lt; 0 || unsafeCount &lt; 0)</span>
<span class="line-added">691         return false;</span>
<span class="line-added">692 </span>
<span class="line-added">693     unsigned offset = unsafeOffset;</span>
<span class="line-added">694     unsigned count = unsafeCount;</span>
<span class="line-added">695 </span>
<span class="line-added">696     if (offset &gt;= instance-&gt;table(tableIndex)-&gt;length() || offset + count &gt; instance-&gt;table(tableIndex)-&gt;length())</span>
<span class="line-added">697         return false;</span>
<span class="line-added">698 </span>
<span class="line-added">699     for (unsigned j = 0; j &lt; count; ++j)</span>
<span class="line-added">700         setWasmTableElement(instance, tableIndex, offset + j, fill);</span>
<span class="line-added">701 </span>
<span class="line-added">702     return true;</span>
<span class="line-added">703 }</span>
<span class="line-added">704 </span>
<span class="line-added">705 EncodedJSValue JIT_OPERATION operationWasmRefFunc(Instance* instance, uint32_t index)</span>
<span class="line-added">706 {</span>
<span class="line-added">707     JSValue value = instance-&gt;getFunctionWrapper(index);</span>
<span class="line-added">708     ASSERT(value.isFunction(instance-&gt;owner&lt;JSObject&gt;()-&gt;vm()));</span>
<span class="line-added">709     return JSValue::encode(value);</span>
<span class="line-added">710 }</span>
<span class="line-added">711 </span>
<span class="line-added">712 int32_t JIT_OPERATION operationGetWasmTableSize(Instance* instance, unsigned tableIndex)</span>
<span class="line-added">713 {</span>
<span class="line-added">714     return instance-&gt;table(tableIndex)-&gt;length();</span>
<span class="line-added">715 }</span>
<span class="line-added">716 </span>
<span class="line-added">717 void* JIT_OPERATION operationWasmToJSException(CallFrame* callFrame, Wasm::ExceptionType type, Instance* wasmInstance)</span>
<span class="line-added">718 {</span>
<span class="line-added">719     wasmInstance-&gt;storeTopCallFrame(callFrame);</span>
<span class="line-added">720     JSWebAssemblyInstance* instance = wasmInstance-&gt;owner&lt;JSWebAssemblyInstance&gt;();</span>
<span class="line-added">721     JSGlobalObject* globalObject = instance-&gt;globalObject();</span>
<span class="line-added">722 </span>
<span class="line-added">723     // Do not retrieve VM&amp; from CallFrame since CallFrame&#39;s callee is not a JSCell.</span>
<span class="line-added">724     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">725 </span>
<span class="line-added">726     {</span>
<span class="line-added">727         auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">728 </span>
<span class="line-added">729         JSObject* error;</span>
<span class="line-added">730         if (type == ExceptionType::StackOverflow)</span>
<span class="line-added">731             error = createStackOverflowError(globalObject);</span>
<span class="line-added">732         else</span>
<span class="line-added">733             error = JSWebAssemblyRuntimeError::create(globalObject, vm, globalObject-&gt;webAssemblyRuntimeErrorStructure(), Wasm::errorMessageForExceptionType(type));</span>
<span class="line-added">734         throwException(globalObject, throwScope, error);</span>
<span class="line-added">735     }</span>
<span class="line-added">736 </span>
<span class="line-added">737     genericUnwind(vm, callFrame);</span>
<span class="line-added">738     ASSERT(!!vm.callFrameForCatch);</span>
<span class="line-added">739     ASSERT(!!vm.targetMachinePCForThrow);</span>
<span class="line-added">740     // FIXME: We could make this better:</span>
<span class="line-added">741     // This is a total hack, but the llint (both op_catch and handleUncaughtException)</span>
<span class="line-added">742     // require a cell in the callee field to load the VM. (The baseline JIT does not require</span>
<span class="line-added">743     // this since it is compiled with a constant VM pointer.) We could make the calling convention</span>
<span class="line-added">744     // for exceptions first load callFrameForCatch info call frame register before jumping</span>
<span class="line-added">745     // to the exception handler. If we did this, we could remove this terrible hack.</span>
<span class="line-added">746     // https://bugs.webkit.org/show_bug.cgi?id=170440</span>
<span class="line-added">747     bitwise_cast&lt;uint64_t*&gt;(callFrame)[static_cast&lt;int&gt;(CallFrameSlot::callee)] = bitwise_cast&lt;uint64_t&gt;(instance-&gt;module());</span>
<span class="line-added">748     return vm.targetMachinePCForThrow;</span>
<span class="line-added">749 }</span>
<span class="line-added">750 </span>
751 } } // namespace JSC::Wasm
752 
<a name="9" id="anc9"></a><span class="line-added">753 IGNORE_WARNINGS_END</span>
<span class="line-added">754 </span>
755 #endif // ENABLE(WEBASSEMBLY)
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/TextFieldInputType.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2010 Google Inc. All rights reserved.
  3  * Copyright (C) 2011-2018 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;TextFieldInputType.h&quot;
 34 
 35 #include &quot;BeforeTextInsertedEvent.h&quot;
 36 #include &quot;Chrome.h&quot;
 37 #include &quot;ChromeClient.h&quot;
 38 #include &quot;DOMFormData.h&quot;
 39 #include &quot;Editor.h&quot;
 40 #include &quot;EventNames.h&quot;
 41 #include &quot;Frame.h&quot;
 42 #include &quot;FrameSelection.h&quot;
 43 #include &quot;HTMLInputElement.h&quot;
 44 #include &quot;HTMLNames.h&quot;
 45 #include &quot;HTMLParserIdioms.h&quot;
 46 #include &quot;KeyboardEvent.h&quot;
 47 #include &quot;LocalizedStrings.h&quot;
 48 #include &quot;NodeRenderStyle.h&quot;
 49 #include &quot;Page.h&quot;
 50 #include &quot;PlatformKeyboardEvent.h&quot;
 51 #include &quot;RenderLayer.h&quot;
 52 #include &quot;RenderTextControlSingleLine.h&quot;
 53 #include &quot;RenderTheme.h&quot;
 54 #include &quot;RuntimeEnabledFeatures.h&quot;
 55 #include &quot;ScriptDisallowedScope.h&quot;
 56 #include &quot;ShadowRoot.h&quot;
 57 #include &quot;TextControlInnerElements.h&quot;
 58 #include &quot;TextEvent.h&quot;
 59 #include &quot;TextIterator.h&quot;
 60 #include &quot;TextNodeTraversal.h&quot;
 61 #include &quot;UserTypingGestureIndicator.h&quot;
 62 #include &quot;WheelEvent.h&quot;
 63 
 64 #if ENABLE(DATALIST_ELEMENT)
 65 #include &quot;HTMLDataListElement.h&quot;
 66 #include &quot;HTMLOptionElement.h&quot;
 67 #endif
 68 
 69 namespace WebCore {
 70 
 71 using namespace HTMLNames;
 72 
 73 TextFieldInputType::TextFieldInputType(HTMLInputElement&amp; element)
 74     : InputType(element)
 75 {
 76 }
 77 
 78 TextFieldInputType::~TextFieldInputType()
 79 {
 80     if (m_innerSpinButton)
 81         m_innerSpinButton-&gt;removeSpinButtonOwner();
 82 #if ENABLE(DATALIST_ELEMENT)
 83     closeSuggestions();
 84 #endif
 85 }
 86 
 87 bool TextFieldInputType::isKeyboardFocusable(KeyboardEvent*) const
 88 {
 89     ASSERT(element());
 90 #if PLATFORM(IOS_FAMILY)
 91     if (element()-&gt;isReadOnly())
 92         return false;
 93 #endif
 94     return element()-&gt;isTextFormControlFocusable();
 95 }
 96 
 97 bool TextFieldInputType::isMouseFocusable() const
 98 {
 99     ASSERT(element());
100     return element()-&gt;isTextFormControlFocusable();
101 }
102 
103 bool TextFieldInputType::isTextField() const
104 {
105     return true;
106 }
107 
108 bool TextFieldInputType::isEmptyValue() const
109 {
110     auto innerText = innerTextElement();
111     ASSERT(innerText);
112 
113     for (Text* text = TextNodeTraversal::firstWithin(*innerText); text; text = TextNodeTraversal::next(*text, innerText.get())) {
114         if (text-&gt;length())
115             return false;
116     }
117     return true;
118 }
119 
120 bool TextFieldInputType::valueMissing(const String&amp; value) const
121 {
122     ASSERT(element());
123     return element()-&gt;isRequired() &amp;&amp; value.isEmpty();
124 }
125 
126 void TextFieldInputType::setValue(const String&amp; sanitizedValue, bool valueChanged, TextFieldEventBehavior eventBehavior)
127 {
128     ASSERT(element());
129 
130     // Grab this input element to keep reference even if JS event handler
131     // changes input type.
132     Ref&lt;HTMLInputElement&gt; input(*element());
133 
134     // We don&#39;t ask InputType::setValue to dispatch events because
135     // TextFieldInputType dispatches events different way from InputType.
136     InputType::setValue(sanitizedValue, valueChanged, DispatchNoEvent);
137 
138     if (valueChanged)
139         updateInnerTextValue();
140 
141     unsigned max = visibleValue().length();
142     if (input-&gt;focused())
143         input-&gt;setSelectionRange(max, max);
144     else
145         input-&gt;cacheSelectionInResponseToSetValue(max);
146 
147     if (!valueChanged)
148         return;
149 
150     switch (eventBehavior) {
151     case DispatchChangeEvent:
152         // If the user is still editing this field, dispatch an input event rather than a change event.
153         // The change event will be dispatched when editing finishes.
154         if (input-&gt;focused())
155             input-&gt;dispatchFormControlInputEvent();
156         else
157             input-&gt;dispatchFormControlChangeEvent();
158         break;
159 
160     case DispatchInputAndChangeEvent: {
161         input-&gt;dispatchFormControlInputEvent();
162         input-&gt;dispatchFormControlChangeEvent();
163         break;
164     }
165 
166     case DispatchNoEvent:
167         break;
168     }
169 
170     // FIXME: Why do we do this when eventBehavior == DispatchNoEvent
171     if (!input-&gt;focused() || eventBehavior == DispatchNoEvent)
172         input-&gt;setTextAsOfLastFormControlChangeEvent(sanitizedValue);
173 
174     if (UserTypingGestureIndicator::processingUserTypingGesture())
175         didSetValueByUserEdit();
176 }
177 
178 #if ENABLE(DATALIST_ELEMENT)
179 void TextFieldInputType::handleClickEvent(MouseEvent&amp;)
180 {
181     if (element()-&gt;focused() &amp;&amp; element()-&gt;list())
182         displaySuggestions(DataListSuggestionActivationType::ControlClicked);
183 }
184 #endif
185 
186 auto TextFieldInputType::handleKeydownEvent(KeyboardEvent&amp; event) -&gt; ShouldCallBaseEventHandler
187 {
188     ASSERT(element());
189     if (!element()-&gt;focused())
190         return ShouldCallBaseEventHandler::Yes;
191 #if ENABLE(DATALIST_ELEMENT)
192     const String&amp; key = event.keyIdentifier();
193     if (m_suggestionPicker &amp;&amp; (key == &quot;Enter&quot; || key == &quot;Up&quot; || key == &quot;Down&quot;)) {
194         m_suggestionPicker-&gt;handleKeydownWithIdentifier(key);
195         event.setDefaultHandled();
196     }
197 #endif
198     RefPtr&lt;Frame&gt; frame = element()-&gt;document().frame();
199     if (frame &amp;&amp; frame-&gt;editor().doTextFieldCommandFromEvent(element(), &amp;event))
200         event.setDefaultHandled();
201     return ShouldCallBaseEventHandler::Yes;
202 }
203 
204 void TextFieldInputType::handleKeydownEventForSpinButton(KeyboardEvent&amp; event)
205 {
206     ASSERT(element());
207     if (element()-&gt;isDisabledOrReadOnly())
208         return;
209 #if ENABLE(DATALIST_ELEMENT)
210     if (m_suggestionPicker)
211         return;
212 #endif
213     const String&amp; key = event.keyIdentifier();
214     if (key == &quot;Up&quot;)
215         spinButtonStepUp();
216     else if (key == &quot;Down&quot;)
217         spinButtonStepDown();
218     else
219         return;
220     event.setDefaultHandled();
221 }
222 
223 void TextFieldInputType::forwardEvent(Event&amp; event)
224 {
225     if (m_innerSpinButton) {
226         m_innerSpinButton-&gt;forwardEvent(event);
227         if (event.defaultHandled())
228             return;
229     }
230 
231     bool isFocusEvent = event.type() == eventNames().focusEvent;
232     bool isBlurEvent = event.type() == eventNames().blurEvent;
233     if (isFocusEvent || isBlurEvent)
234         capsLockStateMayHaveChanged();
235     if (event.isMouseEvent() || isFocusEvent || isBlurEvent) {
236         ASSERT(element());
237         element()-&gt;forwardEvent(event);
238     }
239 }
240 
241 void TextFieldInputType::elementDidBlur()
242 {
243     ASSERT(element());
244     auto* renderer = element()-&gt;renderer();
245     if (!renderer)
246         return;
247 
248     auto* innerTextRenderer = innerTextElement()-&gt;renderer();
249     if (!innerTextRenderer)
250         return;
251 
252     auto* innerLayer = innerTextRenderer-&gt;layer();
253     if (!innerLayer)
254         return;
255 
256     bool isLeftToRightDirection = downcast&lt;RenderTextControlSingleLine&gt;(*renderer).style().isLeftToRightDirection();
257     ScrollOffset scrollOffset(isLeftToRightDirection ? 0 : innerLayer-&gt;scrollWidth(), 0);
258     innerLayer-&gt;scrollToOffset(scrollOffset);
259 
260 #if ENABLE(DATALIST_ELEMENT)
261     closeSuggestions();
262 #endif
263 }
264 
265 void TextFieldInputType::handleFocusEvent(Node* oldFocusedNode, FocusDirection)
266 {
267     ASSERT(element());
268     ASSERT_UNUSED(oldFocusedNode, oldFocusedNode != element());
269     if (RefPtr&lt;Frame&gt; frame = element()-&gt;document().frame()) {
270         frame-&gt;editor().textFieldDidBeginEditing(element());
271 #if ENABLE(DATALIST_ELEMENT) &amp;&amp; PLATFORM(IOS_FAMILY)
272         if (element()-&gt;list() &amp;&amp; m_dataListDropdownIndicator)
273             m_dataListDropdownIndicator-&gt;setInlineStyleProperty(CSSPropertyDisplay, suggestions().size() ? CSSValueBlock : CSSValueNone, true);
274 #endif
275     }
276 }
277 
278 void TextFieldInputType::handleBlurEvent()
279 {
280     InputType::handleBlurEvent();
281     ASSERT(element());
282     element()-&gt;endEditing();
283 #if ENABLE(DATALIST_ELEMENT) &amp;&amp; PLATFORM(IOS_FAMILY)
284     if (element()-&gt;list() &amp;&amp; m_dataListDropdownIndicator)
285         m_dataListDropdownIndicator-&gt;setInlineStyleProperty(CSSPropertyDisplay, CSSValueNone, true);
286 #endif
287 }
288 
289 bool TextFieldInputType::shouldSubmitImplicitly(Event&amp; event)
290 {
291     return (event.type() == eventNames().textInputEvent &amp;&amp; is&lt;TextEvent&gt;(event) &amp;&amp; downcast&lt;TextEvent&gt;(event).data() == &quot;\n&quot;)
292         || InputType::shouldSubmitImplicitly(event);
293 }
294 
295 RenderPtr&lt;RenderElement&gt; TextFieldInputType::createInputRenderer(RenderStyle&amp;&amp; style)
296 {
297     ASSERT(element());
298     return createRenderer&lt;RenderTextControlSingleLine&gt;(*element(), WTFMove(style));
299 }
300 
301 bool TextFieldInputType::needsContainer() const
302 {
303     return false;
304 }
305 
306 bool TextFieldInputType::shouldHaveSpinButton() const
307 {
308     ASSERT(element());
309     return RenderTheme::singleton().shouldHaveSpinButton(*element());
310 }
311 
312 bool TextFieldInputType::shouldHaveCapsLockIndicator() const
313 {
314     ASSERT(element());
315     return RenderTheme::singleton().shouldHaveCapsLockIndicator(*element());
316 }
317 
318 void TextFieldInputType::createShadowSubtree()
319 {
320     ASSERT(element());
321     ASSERT(element()-&gt;shadowRoot());
322 
323     ASSERT(!m_innerText);
324     ASSERT(!m_innerBlock);
325     ASSERT(!m_innerSpinButton);
326     ASSERT(!m_capsLockIndicator);
327     ASSERT(!m_autoFillButton);
328 
329     Document&amp; document = element()-&gt;document();
330     bool shouldHaveSpinButton = this-&gt;shouldHaveSpinButton();
331     bool shouldHaveCapsLockIndicator = this-&gt;shouldHaveCapsLockIndicator();
332     bool createsContainer = shouldHaveSpinButton || shouldHaveCapsLockIndicator || needsContainer();
333 
334     m_innerText = TextControlInnerTextElement::create(document);
335 
336     if (!createsContainer) {
337         element()-&gt;userAgentShadowRoot()-&gt;appendChild(*m_innerText);
338         updatePlaceholderText();
339         return;
340     }
341 
342     createContainer();
343     updatePlaceholderText();
344 
345     if (shouldHaveSpinButton) {
346         m_innerSpinButton = SpinButtonElement::create(document, *this);
347         m_container-&gt;appendChild(*m_innerSpinButton);
348     }
349 
350     if (shouldHaveCapsLockIndicator) {
351         m_capsLockIndicator = HTMLDivElement::create(document);
352         m_capsLockIndicator-&gt;setPseudo(AtomString(&quot;-webkit-caps-lock-indicator&quot;, AtomString::ConstructFromLiteral));
353 
354         bool shouldDrawCapsLockIndicator = this-&gt;shouldDrawCapsLockIndicator();
355         m_capsLockIndicator-&gt;setInlineStyleProperty(CSSPropertyDisplay, shouldDrawCapsLockIndicator ? CSSValueBlock : CSSValueNone, true);
356 
357         m_container-&gt;appendChild(*m_capsLockIndicator);
358     }
359     updateAutoFillButton();
360 }
361 
362 HTMLElement* TextFieldInputType::containerElement() const
363 {
364     return m_container.get();
365 }
366 
367 HTMLElement* TextFieldInputType::innerBlockElement() const
368 {
369     return m_innerBlock.get();
370 }
371 
372 RefPtr&lt;TextControlInnerTextElement&gt; TextFieldInputType::innerTextElement() const
373 {
374     ASSERT(m_innerText);
375     return m_innerText;
376 }
377 
378 HTMLElement* TextFieldInputType::innerSpinButtonElement() const
379 {
380     return m_innerSpinButton.get();
381 }
382 
383 HTMLElement* TextFieldInputType::capsLockIndicatorElement() const
384 {
385     return m_capsLockIndicator.get();
386 }
387 
388 HTMLElement* TextFieldInputType::autoFillButtonElement() const
389 {
390     return m_autoFillButton.get();
391 }
392 
393 HTMLElement* TextFieldInputType::placeholderElement() const
394 {
395     return m_placeholder.get();
396 }
397 
398 void TextFieldInputType::destroyShadowSubtree()
399 {
400     InputType::destroyShadowSubtree();
401     m_innerText = nullptr;
402     m_placeholder = nullptr;
403     m_innerBlock = nullptr;
404     if (m_innerSpinButton)
405         m_innerSpinButton-&gt;removeSpinButtonOwner();
406     m_innerSpinButton = nullptr;
407     m_capsLockIndicator = nullptr;
408     m_autoFillButton = nullptr;
409 #if ENABLE(DATALIST)
410     m_dataListDropdownIndicator = nullptr;
411 #endif
412     m_container = nullptr;
413 }
414 
415 void TextFieldInputType::attributeChanged(const QualifiedName&amp; name)
416 {
417     if (name == valueAttr || name == placeholderAttr) {
418         if (element())
419             updateInnerTextValue();
420     }
421     InputType::attributeChanged(name);
422 }
423 
424 void TextFieldInputType::disabledStateChanged()
425 {
426     if (m_innerSpinButton)
427         m_innerSpinButton-&gt;releaseCapture();
428     capsLockStateMayHaveChanged();
429     updateAutoFillButton();
430 }
431 
432 void TextFieldInputType::readOnlyStateChanged()
433 {
434     if (m_innerSpinButton)
435         m_innerSpinButton-&gt;releaseCapture();
436     capsLockStateMayHaveChanged();
437     updateAutoFillButton();
438 }
439 
440 bool TextFieldInputType::supportsReadOnly() const
441 {
442     return true;
443 }
444 
445 bool TextFieldInputType::shouldUseInputMethod() const
446 {
447     return true;
448 }
449 
450 #if ENABLE(DATALIST_ELEMENT)
451 void TextFieldInputType::createDataListDropdownIndicator()
452 {
453     ASSERT(!m_dataListDropdownIndicator);
454     if (!m_container)
455         createContainer();
456 
457     ScriptDisallowedScope::EventAllowedScope allowedScope(*m_container);
458     m_dataListDropdownIndicator = DataListButtonElement::create(element()-&gt;document(), *this);
459     m_container-&gt;appendChild(*m_dataListDropdownIndicator);
460     m_dataListDropdownIndicator-&gt;setPseudo(AtomString(&quot;-webkit-list-button&quot;, AtomString::ConstructFromLiteral));
461     m_dataListDropdownIndicator-&gt;setInlineStyleProperty(CSSPropertyDisplay, CSSValueNone, true);
462 
463 }
464 #endif
465 
<a name="1" id="anc1"></a>




466 static String limitLength(const String&amp; string, unsigned maxNumGraphemeClusters)
467 {
468     StringView stringView { string };
<a name="2" id="anc2"></a><span class="line-modified">469 </span>
<span class="line-modified">470     if (!stringView.is8Bit())</span>
<span class="line-modified">471         maxNumGraphemeClusters = numCodeUnitsInGraphemeClusters(stringView, maxNumGraphemeClusters);</span>
<span class="line-modified">472 </span>
<span class="line-modified">473     return string.left(maxNumGraphemeClusters);</span>




474 }
475 
476 static String autoFillButtonTypeToAccessibilityLabel(AutoFillButtonType autoFillButtonType)
477 {
478     switch (autoFillButtonType) {
479     case AutoFillButtonType::Contacts:
480         return AXAutoFillContactsLabel();
481     case AutoFillButtonType::Credentials:
482         return AXAutoFillCredentialsLabel();
483     case AutoFillButtonType::StrongPassword:
484         return AXAutoFillStrongPasswordLabel();
485     case AutoFillButtonType::CreditCard:
486         return AXAutoFillCreditCardLabel();
487     case AutoFillButtonType::None:
488         ASSERT_NOT_REACHED();
489         return { };
490     }
491     ASSERT_NOT_REACHED();
492     return { };
493 }
494 
495 static String autoFillButtonTypeToAutoFillButtonText(AutoFillButtonType autoFillButtonType)
496 {
497     switch (autoFillButtonType) {
498     case AutoFillButtonType::Contacts:
499     case AutoFillButtonType::Credentials:
500     case AutoFillButtonType::CreditCard:
501         return emptyString();
502     case AutoFillButtonType::StrongPassword:
503         return autoFillStrongPasswordLabel();
504     case AutoFillButtonType::None:
505         ASSERT_NOT_REACHED();
506         return { };
507     }
508     ASSERT_NOT_REACHED();
509     return { };
510 }
511 
512 static AtomString autoFillButtonTypeToAutoFillButtonPseudoClassName(AutoFillButtonType autoFillButtonType)
513 {
514     switch (autoFillButtonType) {
515     case AutoFillButtonType::Contacts:
516         return { &quot;-webkit-contacts-auto-fill-button&quot;, AtomString::ConstructFromLiteral };
517     case AutoFillButtonType::Credentials:
518         return { &quot;-webkit-credentials-auto-fill-button&quot;, AtomString::ConstructFromLiteral };
519     case AutoFillButtonType::StrongPassword:
520         return { &quot;-webkit-strong-password-auto-fill-button&quot;, AtomString::ConstructFromLiteral };
521     case AutoFillButtonType::CreditCard:
522         return { &quot;-webkit-credit-card-auto-fill-button&quot;, AtomString::ConstructFromLiteral };
523     case AutoFillButtonType::None:
524         ASSERT_NOT_REACHED();
525         return emptyAtom();
526     }
527     ASSERT_NOT_REACHED();
528     return { };
529 }
530 
531 static bool isAutoFillButtonTypeChanged(const AtomString&amp; attribute, AutoFillButtonType autoFillButtonType)
532 {
533     if (attribute == &quot;-webkit-contacts-auto-fill-button&quot; &amp;&amp; autoFillButtonType != AutoFillButtonType::Contacts)
534         return true;
535     if (attribute == &quot;-webkit-credentials-auto-fill-button&quot; &amp;&amp; autoFillButtonType != AutoFillButtonType::Credentials)
536         return true;
537     if (attribute == &quot;-webkit-strong-password-auto-fill-button&quot; &amp;&amp; autoFillButtonType != AutoFillButtonType::StrongPassword)
538         return true;
539     if (attribute == &quot;-webkit-credit-card-auto-fill-button&quot; &amp;&amp; autoFillButtonType != AutoFillButtonType::CreditCard)
540         return true;
541     return false;
542 }
543 
544 String TextFieldInputType::sanitizeValue(const String&amp; proposedValue) const
545 {
546     return limitLength(proposedValue.removeCharacters(isHTMLLineBreak), HTMLInputElement::maxEffectiveLength);
547 }
548 
549 void TextFieldInputType::handleBeforeTextInsertedEvent(BeforeTextInsertedEvent&amp; event)
550 {
551     ASSERT(element());
552     // Make sure that the text to be inserted will not violate the maxLength.
553 
554     // We use RenderTextControlSingleLine::text() instead of InputElement::value()
555     // because they can be mismatched by sanitizeValue() in
556     // HTMLInputElement::subtreeHasChanged() in some cases.
557     String innerText = element()-&gt;innerTextValue();
558     unsigned oldLength = numGraphemeClusters(innerText);
559 
560     // selectionLength represents the selection length of this text field to be
561     // removed by this insertion.
562     // If the text field has no focus, we don&#39;t need to take account of the
563     // selection length. The selection is the source of text drag-and-drop in
564     // that case, and nothing in the text field will be removed.
565     unsigned selectionLength = 0;
566     if (element()-&gt;focused()) {
567         ASSERT(enclosingTextFormControl(element()-&gt;document().frame()-&gt;selection().selection().start()) == element());
568         int selectionStart = element()-&gt;selectionStart();
569         ASSERT(selectionStart &lt;= element()-&gt;selectionEnd());
570         int selectionCodeUnitCount = element()-&gt;selectionEnd() - selectionStart;
571         selectionLength = selectionCodeUnitCount ? numGraphemeClusters(StringView(innerText).substring(selectionStart, selectionCodeUnitCount)) : 0;
572     }
573     ASSERT(oldLength &gt;= selectionLength);
574 
575     // Selected characters will be removed by the next text event.
576     unsigned baseLength = oldLength - selectionLength;
577     unsigned maxLength = isTextType() ? element()-&gt;effectiveMaxLength() : HTMLInputElement::maxEffectiveLength;
578     unsigned appendableLength = maxLength &gt; baseLength ? maxLength - baseLength : 0;
579 
580     // Truncate the inserted text to avoid violating the maxLength and other constraints.
581     String eventText = event.text();
582     unsigned textLength = eventText.length();
583     while (textLength &gt; 0 &amp;&amp; isHTMLLineBreak(eventText[textLength - 1]))
584         textLength--;
585     eventText.truncate(textLength);
586     eventText.replace(&quot;\r\n&quot;, &quot; &quot;);
587     eventText.replace(&#39;\r&#39;, &#39; &#39;);
588     eventText.replace(&#39;\n&#39;, &#39; &#39;);
589     event.setText(limitLength(eventText, appendableLength));
590 }
591 
592 bool TextFieldInputType::shouldRespectListAttribute()
593 {
594 #if ENABLE(DATALIST_ELEMENT)
595     return RuntimeEnabledFeatures::sharedFeatures().dataListElementEnabled();
596 #else
597     return InputType::themeSupportsDataListUI(this);
598 #endif
599 }
600 
601 void TextFieldInputType::updatePlaceholderText()
602 {
603     if (!supportsPlaceholder())
604         return;
605     ASSERT(element());
606     String placeholderText = element()-&gt;strippedPlaceholder();
607     if (placeholderText.isEmpty()) {
608         if (m_placeholder) {
609             m_placeholder-&gt;parentNode()-&gt;removeChild(*m_placeholder);
610             m_placeholder = nullptr;
611         }
612         return;
613     }
614     if (!m_placeholder) {
615         m_placeholder = TextControlPlaceholderElement::create(element()-&gt;document());
616         element()-&gt;userAgentShadowRoot()-&gt;insertBefore(*m_placeholder, m_container ? m_container.get() : innerTextElement().get());
617     }
618     m_placeholder-&gt;setInnerText(placeholderText);
619 }
620 
621 bool TextFieldInputType::appendFormData(DOMFormData&amp; formData, bool multipart) const
622 {
623     InputType::appendFormData(formData, multipart);
624     ASSERT(element());
625     auto&amp; dirnameAttrValue = element()-&gt;attributeWithoutSynchronization(dirnameAttr);
626     if (!dirnameAttrValue.isNull())
627         formData.append(dirnameAttrValue, element()-&gt;directionForFormData());
628     return true;
629 }
630 
631 String TextFieldInputType::convertFromVisibleValue(const String&amp; visibleValue) const
632 {
633     return visibleValue;
634 }
635 
636 void TextFieldInputType::subtreeHasChanged()
637 {
638     ASSERT(element());
639     element()-&gt;setChangedSinceLastFormControlChangeEvent(true);
640 
641     // We don&#39;t need to call sanitizeUserInputValue() function here because
642     // HTMLInputElement::handleBeforeTextInsertedEvent() has already called
643     // sanitizeUserInputValue().
644     // ---
645     // sanitizeValue() is needed because IME input doesn&#39;t dispatch BeforeTextInsertedEvent.
646     // ---
647     // Input types that support the selection API do *not* sanitize their
648     // user input in order to retain parity between what&#39;s in the model and
649     // what&#39;s on the screen. Otherwise, we retain the sanitization process for
650     // backward compatibility. https://bugs.webkit.org/show_bug.cgi?id=150346
651     String innerText = convertFromVisibleValue(element()-&gt;innerTextValue());
652     if (!supportsSelectionAPI())
653         innerText = sanitizeValue(innerText);
654     element()-&gt;setValueFromRenderer(innerText);
655     element()-&gt;updatePlaceholderVisibility();
656     // Recalc for :invalid change.
657     element()-&gt;invalidateStyleForSubtree();
658 
659     didSetValueByUserEdit();
660 }
661 
662 void TextFieldInputType::didSetValueByUserEdit()
663 {
664     ASSERT(element());
665     if (!element()-&gt;focused())
666         return;
667     if (RefPtr&lt;Frame&gt; frame = element()-&gt;document().frame())
668         frame-&gt;editor().textDidChangeInTextField(element());
669 #if ENABLE(DATALIST_ELEMENT)
670 #if PLATFORM(IOS_FAMILY)
671     if (element()-&gt;list() &amp;&amp; m_dataListDropdownIndicator)
672         m_dataListDropdownIndicator-&gt;setInlineStyleProperty(CSSPropertyDisplay, suggestions().size() ? CSSValueBlock : CSSValueNone, true);
673 #endif
674     if (element()-&gt;list())
675         displaySuggestions(DataListSuggestionActivationType::TextChanged);
676 #endif
677 }
678 
679 void TextFieldInputType::spinButtonStepDown()
680 {
681     stepUpFromRenderer(-1);
682 }
683 
684 void TextFieldInputType::spinButtonStepUp()
685 {
686     stepUpFromRenderer(1);
687 }
688 
689 void TextFieldInputType::updateInnerTextValue()
690 {
691     ASSERT(element());
692     if (!element()-&gt;formControlValueMatchesRenderer()) {
693         // Update the renderer value if the formControlValueMatchesRenderer() flag is false.
694         // It protects an unacceptable renderer value from being overwritten with the DOM value.
695         element()-&gt;setInnerTextValue(visibleValue());
696         element()-&gt;updatePlaceholderVisibility();
697     }
698 }
699 
700 void TextFieldInputType::focusAndSelectSpinButtonOwner()
701 {
702     ASSERT(element());
703     Ref&lt;HTMLInputElement&gt; input(*element());
704     input-&gt;focus();
705     input-&gt;select();
706 }
707 
708 bool TextFieldInputType::shouldSpinButtonRespondToMouseEvents()
709 {
710     ASSERT(element());
711     return !element()-&gt;isDisabledOrReadOnly();
712 }
713 
714 bool TextFieldInputType::shouldSpinButtonRespondToWheelEvents()
715 {
716     ASSERT(element());
717     return shouldSpinButtonRespondToMouseEvents() &amp;&amp; element()-&gt;focused();
718 }
719 
720 bool TextFieldInputType::shouldDrawCapsLockIndicator() const
721 {
722     ASSERT(element());
723     if (element()-&gt;document().focusedElement() != element())
724         return false;
725 
726     if (element()-&gt;isDisabledOrReadOnly())
727         return false;
728 
729     if (element()-&gt;hasAutoFillStrongPasswordButton())
730         return false;
731 
732     RefPtr&lt;Frame&gt; frame = element()-&gt;document().frame();
733     if (!frame)
734         return false;
735 
736     if (!frame-&gt;selection().isFocusedAndActive())
737         return false;
738 
739     return PlatformKeyboardEvent::currentCapsLockState();
740 }
741 
742 void TextFieldInputType::capsLockStateMayHaveChanged()
743 {
744     if (!m_capsLockIndicator)
745         return;
746 
747     bool shouldDrawCapsLockIndicator = this-&gt;shouldDrawCapsLockIndicator();
748     m_capsLockIndicator-&gt;setInlineStyleProperty(CSSPropertyDisplay, shouldDrawCapsLockIndicator ? CSSValueBlock : CSSValueNone, true);
749 }
750 
751 bool TextFieldInputType::shouldDrawAutoFillButton() const
752 {
753     ASSERT(element());
754     return !element()-&gt;isDisabledOrReadOnly() &amp;&amp; element()-&gt;autoFillButtonType() != AutoFillButtonType::None;
755 }
756 
757 void TextFieldInputType::autoFillButtonElementWasClicked()
758 {
759     ASSERT(element());
760     Page* page = element()-&gt;document().page();
761     if (!page)
762         return;
763 
764     page-&gt;chrome().client().handleAutoFillButtonClick(*element());
765 }
766 
767 void TextFieldInputType::createContainer()
768 {
769     ASSERT(!m_container);
770     ASSERT(element());
771 
772     ScriptDisallowedScope::EventAllowedScope allowedScope(*element()-&gt;userAgentShadowRoot());
773 
774     m_container = TextControlInnerContainer::create(element()-&gt;document());
775     element()-&gt;userAgentShadowRoot()-&gt;appendChild(*m_container);
776     m_container-&gt;setPseudo(AtomString(&quot;-webkit-textfield-decoration-container&quot;, AtomString::ConstructFromLiteral));
777 
778     m_innerBlock = TextControlInnerElement::create(element()-&gt;document());
779     m_container-&gt;appendChild(*m_innerBlock);
780     m_innerBlock-&gt;appendChild(*m_innerText);
781 }
782 
783 void TextFieldInputType::createAutoFillButton(AutoFillButtonType autoFillButtonType)
784 {
785     ASSERT(!m_autoFillButton);
786 
787     if (autoFillButtonType == AutoFillButtonType::None)
788         return;
789 
790     ASSERT(element());
791     m_autoFillButton = AutoFillButtonElement::create(element()-&gt;document(), *this);
792     m_autoFillButton-&gt;setPseudo(autoFillButtonTypeToAutoFillButtonPseudoClassName(autoFillButtonType));
793     m_autoFillButton-&gt;setAttributeWithoutSynchronization(roleAttr, AtomString(&quot;button&quot;, AtomString::ConstructFromLiteral));
794     m_autoFillButton-&gt;setAttributeWithoutSynchronization(aria_labelAttr, autoFillButtonTypeToAccessibilityLabel(autoFillButtonType));
795     m_autoFillButton-&gt;setTextContent(autoFillButtonTypeToAutoFillButtonText(autoFillButtonType));
796     m_container-&gt;appendChild(*m_autoFillButton);
797 }
798 
799 void TextFieldInputType::updateAutoFillButton()
800 {
801     capsLockStateMayHaveChanged();
802 
803     if (shouldDrawAutoFillButton()) {
804         if (!m_container)
805             createContainer();
806 
807         ASSERT(element());
808         AutoFillButtonType autoFillButtonType = element()-&gt;autoFillButtonType();
809         if (!m_autoFillButton)
810             createAutoFillButton(autoFillButtonType);
811 
812         const AtomString&amp; attribute = m_autoFillButton-&gt;attributeWithoutSynchronization(pseudoAttr);
813         bool shouldUpdateAutoFillButtonType = isAutoFillButtonTypeChanged(attribute, autoFillButtonType);
814         if (shouldUpdateAutoFillButtonType) {
815             m_autoFillButton-&gt;setPseudo(autoFillButtonTypeToAutoFillButtonPseudoClassName(autoFillButtonType));
816             m_autoFillButton-&gt;setAttributeWithoutSynchronization(aria_labelAttr, autoFillButtonTypeToAccessibilityLabel(autoFillButtonType));
817             m_autoFillButton-&gt;setTextContent(autoFillButtonTypeToAutoFillButtonText(autoFillButtonType));
818         }
819         m_autoFillButton-&gt;setInlineStyleProperty(CSSPropertyDisplay, CSSValueBlock, true);
820         return;
821     }
822 
823     if (m_autoFillButton)
824         m_autoFillButton-&gt;setInlineStyleProperty(CSSPropertyDisplay, CSSValueNone, true);
825 }
826 
827 #if ENABLE(DATALIST_ELEMENT)
828 
829 void TextFieldInputType::listAttributeTargetChanged()
830 {
831     m_cachedSuggestions = std::make_pair(String(), Vector&lt;String&gt;());
832 
833     if (!m_dataListDropdownIndicator)
834         createDataListDropdownIndicator();
835 
836 #if !PLATFORM(IOS_FAMILY)
837     m_dataListDropdownIndicator-&gt;setInlineStyleProperty(CSSPropertyDisplay, element()-&gt;list() ? CSSValueBlock : CSSValueNone, true);
838 #endif
839 }
840 
841 HTMLElement* TextFieldInputType::dataListButtonElement() const
842 {
843     return m_dataListDropdownIndicator.get();
844 }
845 
846 void TextFieldInputType::dataListButtonElementWasClicked()
847 {
848     if (element()-&gt;list())
849         displaySuggestions(DataListSuggestionActivationType::IndicatorClicked);
850 }
851 
852 IntRect TextFieldInputType::elementRectInRootViewCoordinates() const
853 {
854     if (!element()-&gt;renderer())
855         return IntRect();
856     return element()-&gt;document().view()-&gt;contentsToRootView(element()-&gt;renderer()-&gt;absoluteBoundingBoxRect());
857 }
858 
859 Vector&lt;String&gt; TextFieldInputType::suggestions()
860 {
861     Vector&lt;String&gt; suggestions;
862     Vector&lt;String&gt; matchesContainingValue;
863 
864     String elementValue = element()-&gt;value();
865 
866     if (!m_cachedSuggestions.first.isNull() &amp;&amp; equalIgnoringASCIICase(m_cachedSuggestions.first, elementValue))
867         return m_cachedSuggestions.second;
868 
869     if (auto dataList = element()-&gt;dataList()) {
870         Ref&lt;HTMLCollection&gt; options = dataList-&gt;options();
871         for (unsigned i = 0; auto* option = downcast&lt;HTMLOptionElement&gt;(options-&gt;item(i)); ++i) {
872             if (!element()-&gt;isValidValue(option-&gt;value()))
873                 continue;
874 
875             String value = sanitizeValue(option-&gt;value());
876             if (elementValue.isEmpty())
877                 suggestions.append(value);
878             else if (value.startsWithIgnoringASCIICase(elementValue))
879                 suggestions.append(value);
880             else if (value.containsIgnoringASCIICase(elementValue))
881                 matchesContainingValue.append(value);
882         }
883     }
884 
885     suggestions.appendVector(matchesContainingValue);
886     m_cachedSuggestions = std::make_pair(elementValue, suggestions);
887 
888     return suggestions;
889 }
890 
891 void TextFieldInputType::didSelectDataListOption(const String&amp; selectedOption)
892 {
893     element()-&gt;setValue(selectedOption, DispatchInputAndChangeEvent);
894 }
895 
896 void TextFieldInputType::didCloseSuggestions()
897 {
898     m_cachedSuggestions = std::make_pair(String(), Vector&lt;String&gt;());
899     m_suggestionPicker = nullptr;
900     if (element()-&gt;renderer())
901         element()-&gt;renderer()-&gt;repaint();
902 }
903 
904 void TextFieldInputType::displaySuggestions(DataListSuggestionActivationType type)
905 {
906     if (element()-&gt;isDisabledFormControl() || !element()-&gt;renderer())
907         return;
908 
909     if (!UserGestureIndicator::processingUserGesture() &amp;&amp; type != DataListSuggestionActivationType::TextChanged)
910         return;
911 
912     if (!m_suggestionPicker &amp;&amp; suggestions().size() &gt; 0)
913         m_suggestionPicker = chrome()-&gt;createDataListSuggestionPicker(*this);
914 
915     if (!m_suggestionPicker)
916         return;
917 
918     m_suggestionPicker-&gt;displayWithActivationType(type);
919 }
920 
921 void TextFieldInputType::closeSuggestions()
922 {
923     if (m_suggestionPicker)
924         m_suggestionPicker-&gt;close();
925 }
926 
927 bool TextFieldInputType::isPresentingAttachedView() const
928 {
929     return !!m_suggestionPicker;
930 }
931 
932 #endif
933 
934 } // namespace WebCore
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
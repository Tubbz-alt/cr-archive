<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServerWorker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SWServerToContextConnection.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SWServerWorker.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServerWorker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 49,10 ***</span>
<span class="line-new-header">--- 49,11 ---</span>
  
  // FIXME: Use r-value references for script and contentSecurityPolicy
  SWServerWorker::SWServerWorker(SWServer&amp; server, SWServerRegistration&amp; registration, const URL&amp; scriptURL, const String&amp; script, const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicy, String&amp;&amp; referrerPolicy, WorkerType type, ServiceWorkerIdentifier identifier, HashMap&lt;URL, ServiceWorkerContextData::ImportedScript&gt;&amp;&amp; scriptResourceMap)
      : m_server(makeWeakPtr(server))
      , m_registrationKey(registration.key())
<span class="line-added">+     , m_registration(makeWeakPtr(registration))</span>
      , m_data { identifier, scriptURL, ServiceWorkerState::Redundant, type, registration.identifier() }
      , m_script(script)
      , m_contentSecurityPolicy(contentSecurityPolicy)
      , m_referrerPolicy(WTFMove(referrerPolicy))
      , m_registrableDomain(m_data.scriptURL)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 61,27 ***</span>
      m_data.scriptURL.removeFragmentIdentifier();
  
      auto result = allWorkers().add(identifier, this);
      ASSERT_UNUSED(result, result.isNewEntry);
  
<span class="line-modified">!     ASSERT(m_server-&gt;getRegistration(m_registrationKey));</span>
  }
  
  SWServerWorker::~SWServerWorker()
  {
      callWhenActivatedHandler(false);
  
      auto taken = allWorkers().take(identifier());
      ASSERT_UNUSED(taken, taken == this);
  }
  
  ServiceWorkerContextData SWServerWorker::contextData() const
  {
<span class="line-modified">!     auto* registration = m_server-&gt;getRegistration(m_registrationKey);</span>
<span class="line-removed">-     ASSERT(registration);</span>
  
<span class="line-modified">!     return { WTF::nullopt, registration-&gt;data(), m_data.identifier, m_script, m_contentSecurityPolicy, m_referrerPolicy, m_data.scriptURL, m_data.type, m_server-&gt;sessionID(), false, m_scriptResourceMap };</span>
  }
  
  void SWServerWorker::terminate()
  {
      if (isRunning())
<span class="line-new-header">--- 62,27 ---</span>
      m_data.scriptURL.removeFragmentIdentifier();
  
      auto result = allWorkers().add(identifier, this);
      ASSERT_UNUSED(result, result.isNewEntry);
  
<span class="line-modified">!     ASSERT(m_server-&gt;getRegistration(m_registrationKey) == &amp;registration);</span>
  }
  
  SWServerWorker::~SWServerWorker()
  {
<span class="line-added">+     ASSERT(m_whenActivatedHandlers.isEmpty());</span>
      callWhenActivatedHandler(false);
  
      auto taken = allWorkers().take(identifier());
      ASSERT_UNUSED(taken, taken == this);
  }
  
  ServiceWorkerContextData SWServerWorker::contextData() const
  {
<span class="line-modified">!     ASSERT(m_registration);</span>
  
<span class="line-modified">!     return { WTF::nullopt, m_registration-&gt;data(), m_data.identifier, m_script, m_contentSecurityPolicy, m_referrerPolicy, m_data.scriptURL, m_data.type, false, m_scriptResourceMap };</span>
  }
  
  void SWServerWorker::terminate()
  {
      if (isRunning())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 96,37 ***</span>
      return *m_origin;
  }
  
  SWServerToContextConnection* SWServerWorker::contextConnection()
  {
<span class="line-modified">!     return SWServerToContextConnection::connectionForRegistrableDomain(registrableDomain());</span>
  }
  
  void SWServerWorker::scriptContextFailedToStart(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier, const String&amp; message)
  {
      ASSERT(m_server);
      if (m_server)
          m_server-&gt;scriptContextFailedToStart(jobDataIdentifier, *this, message);
  }
  
<span class="line-modified">! void SWServerWorker::scriptContextStarted(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier)</span>
  {
      ASSERT(m_server);
      if (m_server)
          m_server-&gt;scriptContextStarted(jobDataIdentifier, *this);
  }
  
  void SWServerWorker::didFinishInstall(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier, bool wasSuccessful)
  {
      ASSERT(m_server);
      if (m_server)
          m_server-&gt;didFinishInstall(jobDataIdentifier, *this, wasSuccessful);
  }
  
  void SWServerWorker::didFinishActivation()
  {
      ASSERT(m_server);
      if (m_server)
          m_server-&gt;didFinishActivation(*this);
  }
  
  void SWServerWorker::contextTerminated()
<span class="line-new-header">--- 97,48 ---</span>
      return *m_origin;
  }
  
  SWServerToContextConnection* SWServerWorker::contextConnection()
  {
<span class="line-modified">!     return m_server ? m_server-&gt;contextConnectionForRegistrableDomain(registrableDomain()) : nullptr;</span>
  }
  
  void SWServerWorker::scriptContextFailedToStart(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier, const String&amp; message)
  {
      ASSERT(m_server);
      if (m_server)
          m_server-&gt;scriptContextFailedToStart(jobDataIdentifier, *this, message);
  }
  
<span class="line-modified">! void SWServerWorker::scriptContextStarted(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier, bool doesHandleFetch)</span>
  {
<span class="line-added">+     m_shouldSkipHandleFetch = !doesHandleFetch;</span>
      ASSERT(m_server);
      if (m_server)
          m_server-&gt;scriptContextStarted(jobDataIdentifier, *this);
  }
  
  void SWServerWorker::didFinishInstall(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier, bool wasSuccessful)
  {
<span class="line-added">+     auto state = this-&gt;state();</span>
<span class="line-added">+     if (state == ServiceWorkerState::Redundant)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
      ASSERT(m_server);
<span class="line-added">+     RELEASE_ASSERT(state == ServiceWorkerState::Installing);</span>
      if (m_server)
          m_server-&gt;didFinishInstall(jobDataIdentifier, *this, wasSuccessful);
  }
  
  void SWServerWorker::didFinishActivation()
  {
<span class="line-added">+     auto state = this-&gt;state();</span>
<span class="line-added">+     if (state == ServiceWorkerState::Redundant)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
      ASSERT(m_server);
<span class="line-added">+     RELEASE_ASSERT(state == ServiceWorkerState::Activating);</span>
      if (m_server)
          m_server-&gt;didFinishActivation(*this);
  }
  
  void SWServerWorker::contextTerminated()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 174,14 ***</span>
  
  void SWServerWorker::skipWaiting()
  {
      m_isSkipWaitingFlagSet = true;
  
<span class="line-modified">!     auto* registration = m_server-&gt;getRegistration(m_registrationKey);</span>
<span class="line-modified">!     ASSERT(registration || isTerminating());</span>
<span class="line-modified">!     if (registration)</span>
<span class="line-removed">-         registration-&gt;tryActivate();</span>
  }
  
  void SWServerWorker::setHasPendingEvents(bool hasPendingEvents)
  {
      if (m_hasPendingEvents == hasPendingEvents)
<span class="line-new-header">--- 186,13 ---</span>
  
  void SWServerWorker::skipWaiting()
  {
      m_isSkipWaitingFlagSet = true;
  
<span class="line-modified">!     ASSERT(m_registration || isTerminating());</span>
<span class="line-modified">!     if (m_registration)</span>
<span class="line-modified">!         m_registration-&gt;tryActivate();</span>
  }
  
  void SWServerWorker::setHasPendingEvents(bool hasPendingEvents)
  {
      if (m_hasPendingEvents == hasPendingEvents)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 190,39 ***</span>
      m_hasPendingEvents = hasPendingEvents;
      if (m_hasPendingEvents)
          return;
  
      // Do tryClear/tryActivate, as per https://w3c.github.io/ServiceWorker/#wait-until-method.
<span class="line-modified">!     auto* registration = m_server-&gt;getRegistration(m_registrationKey);</span>
<span class="line-removed">-     if (!registration)</span>
          return;
  
<span class="line-modified">!     if (registration-&gt;isUninstalling() &amp;&amp; registration-&gt;tryClear())</span>
          return;
<span class="line-modified">!     registration-&gt;tryActivate();</span>
  }
  
<span class="line-modified">! void SWServerWorker::whenActivated(WTF::Function&lt;void(bool)&gt;&amp;&amp; handler)</span>
  {
      if (state() == ServiceWorkerState::Activated) {
          handler(true);
          return;
      }
      m_whenActivatedHandlers.append(WTFMove(handler));
  }
  
  void SWServerWorker::setState(ServiceWorkerState state)
  {
      if (state == ServiceWorkerState::Redundant)
          terminate();
  
      m_data.state = state;
  
<span class="line-modified">!     auto* registration = m_server-&gt;getRegistration(m_registrationKey);</span>
<span class="line-modified">!     ASSERT(registration || state == ServiceWorkerState::Redundant);</span>
<span class="line-modified">!     if (registration) {</span>
<span class="line-removed">-         registration-&gt;forEachConnection([&amp;](auto&amp; connection) {</span>
              connection.updateWorkerStateInClient(this-&gt;identifier(), state);
          });
      }
  
      if (state == ServiceWorkerState::Activated || state == ServiceWorkerState::Redundant)
<span class="line-new-header">--- 201,38 ---</span>
      m_hasPendingEvents = hasPendingEvents;
      if (m_hasPendingEvents)
          return;
  
      // Do tryClear/tryActivate, as per https://w3c.github.io/ServiceWorker/#wait-until-method.
<span class="line-modified">!     if (!m_registration)</span>
          return;
  
<span class="line-modified">!     if (m_registration-&gt;isUnregistered() &amp;&amp; m_registration-&gt;tryClear())</span>
          return;
<span class="line-modified">!     m_registration-&gt;tryActivate();</span>
  }
  
<span class="line-modified">! void SWServerWorker::whenActivated(CompletionHandler&lt;void(bool)&gt;&amp;&amp; handler)</span>
  {
      if (state() == ServiceWorkerState::Activated) {
          handler(true);
          return;
      }
<span class="line-added">+     ASSERT(state() == ServiceWorkerState::Activating);</span>
      m_whenActivatedHandlers.append(WTFMove(handler));
  }
  
  void SWServerWorker::setState(ServiceWorkerState state)
  {
      if (state == ServiceWorkerState::Redundant)
          terminate();
  
      m_data.state = state;
  
<span class="line-modified">!     ASSERT(m_registration || state == ServiceWorkerState::Redundant);</span>
<span class="line-modified">!     if (m_registration) {</span>
<span class="line-modified">!         m_registration-&gt;forEachConnection([&amp;](auto&amp; connection) {</span>
              connection.updateWorkerStateInClient(this-&gt;identifier(), state);
          });
      }
  
      if (state == ServiceWorkerState::Activated || state == ServiceWorkerState::Redundant)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 236,12 ***</span>
          handler(success);
  }
  
  void SWServerWorker::setState(State state)
  {
<span class="line-modified">!     ASSERT(state != State::Running || m_server-&gt;getRegistration(m_registrationKey));</span>
      m_state = state;
  }
  
  } // namespace WebCore
  
  #endif // ENABLE(SERVICE_WORKER)
<span class="line-new-header">--- 246,33 ---</span>
          handler(success);
  }
  
  void SWServerWorker::setState(State state)
  {
<span class="line-modified">!     ASSERT(state != State::Running || m_registration);</span>
      m_state = state;
<span class="line-added">+ </span>
<span class="line-added">+     switch (state) {</span>
<span class="line-added">+     case State::Running:</span>
<span class="line-added">+         m_shouldSkipHandleFetch = false;</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     case State::Terminating:</span>
<span class="line-added">+     case State::NotRunning:</span>
<span class="line-added">+         callWhenActivatedHandler(false);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ SWServerRegistration* SWServerWorker::registration() const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return m_registration.get();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void SWServerWorker::didFailHeartBeatCheck()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_server &amp;&amp; isRunning())</span>
<span class="line-added">+         m_server-&gt;terminateWorker(*this);</span>
  }
  
  } // namespace WebCore
  
  #endif // ENABLE(SERVICE_WORKER)
</pre>
<center><a href="SWServerToContextConnection.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SWServerWorker.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
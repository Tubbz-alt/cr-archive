<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/css/SelectorChecker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
   3  *           (C) 2004-2005 Allan Sandfeld Jensen (kde@carewolf.com)
   4  * Copyright (C) 2006, 2007 Nicholas Shanks (webkit@nickshanks.com)
   5  * Copyright (C) 2005-2016 Apple Inc. All rights reserved.
   6  * Copyright (C) 2007 Alexey Proskuryakov &lt;ap@webkit.org&gt;
   7  * Copyright (C) 2007, 2008 Eric Seidel &lt;eric@webkit.org&gt;
   8  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   9  * Copyright (c) 2011, Code Aurora Forum. All rights reserved.
  10  * Copyright (C) Research In Motion Limited 2011. All rights reserved.
  11  * Copyright (C) 2014 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;
  12  *
  13  * This library is free software; you can redistribute it and/or
  14  * modify it under the terms of the GNU Library General Public
  15  * License as published by the Free Software Foundation; either
  16  * version 2 of the License, or (at your option) any later version.
  17  *
  18  * This library is distributed in the hope that it will be useful,
  19  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  20  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  21  * Library General Public License for more details.
  22  *
  23  * You should have received a copy of the GNU Library General Public License
  24  * along with this library; see the file COPYING.LIB.  If not, write to
  25  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  26  * Boston, MA 02110-1301, USA.
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;SelectorChecker.h&quot;
  31 
  32 #include &quot;CSSSelector.h&quot;
  33 #include &quot;CSSSelectorList.h&quot;
  34 #include &quot;Document.h&quot;
  35 #include &quot;ElementTraversal.h&quot;
  36 #include &quot;Frame.h&quot;
  37 #include &quot;FrameSelection.h&quot;
  38 #include &quot;HTMLDocument.h&quot;
  39 #include &quot;HTMLNames.h&quot;
  40 #include &quot;HTMLParserIdioms.h&quot;
  41 #include &quot;HTMLSlotElement.h&quot;
  42 #include &quot;InspectorInstrumentation.h&quot;
  43 #include &quot;Page.h&quot;
  44 #include &quot;RenderElement.h&quot;
  45 #include &quot;SelectorCheckerTestFunctions.h&quot;
  46 #include &quot;ShadowRoot.h&quot;
  47 #include &quot;Text.h&quot;
  48 
  49 namespace WebCore {
  50 
  51 using namespace HTMLNames;
  52 
  53 enum class VisitedMatchType : unsigned char {
  54     Disabled, Enabled
  55 };
  56 
  57 struct SelectorChecker::LocalContext {
  58     LocalContext(const CSSSelector&amp; selector, const Element&amp; element, VisitedMatchType visitedMatchType, PseudoId pseudoId)
  59         : selector(&amp;selector)
  60         , element(&amp;element)
  61         , visitedMatchType(visitedMatchType)
  62         , firstSelectorOfTheFragment(&amp;selector)
  63         , pseudoId(pseudoId)
  64     { }
  65 
  66     const CSSSelector* selector;
  67     const Element* element;
  68     VisitedMatchType visitedMatchType;
  69     const CSSSelector* firstSelectorOfTheFragment;
  70     PseudoId pseudoId;
  71     bool isMatchElement { true };
  72     bool isSubjectOrAdjacentElement { true };
  73     bool inFunctionalPseudoClass { false };
  74     bool pseudoElementEffective { true };
  75     bool hasScrollbarPseudo { false };
  76     bool hasSelectionPseudo { false };
  77     bool mayMatchHostPseudoClass { false };
  78 
  79 };
  80 
  81 static inline void addStyleRelation(SelectorChecker::CheckingContext&amp; checkingContext, const Element&amp; element, Style::Relation::Type type, unsigned value = 1)
  82 {
  83     ASSERT(value == 1 || type == Style::Relation::NthChildIndex || type == Style::Relation::AffectedByEmpty);
  84     if (checkingContext.resolvingMode != SelectorChecker::Mode::ResolvingStyle)
  85         return;
  86     if (type == Style::Relation::AffectsNextSibling &amp;&amp; !checkingContext.styleRelations.isEmpty()) {
  87         auto&amp; last = checkingContext.styleRelations.last();
  88         if (last.type == Style::Relation::AffectsNextSibling &amp;&amp; last.element == element.nextElementSibling()) {
  89             ++last.value;
  90             last.element = &amp;element;
  91             return;
  92         }
  93     }
  94     checkingContext.styleRelations.append({ element, type, value });
  95 }
  96 
  97 static inline bool isFirstChildElement(const Element&amp; element)
  98 {
  99     return !ElementTraversal::previousSibling(element);
 100 }
 101 
 102 static inline bool isLastChildElement(const Element&amp; element)
 103 {
 104     return !ElementTraversal::nextSibling(element);
 105 }
 106 
 107 static inline bool isFirstOfType(const Element&amp; element, const QualifiedName&amp; type)
 108 {
 109     for (const Element* sibling = ElementTraversal::previousSibling(element); sibling; sibling = ElementTraversal::previousSibling(*sibling)) {
 110         if (sibling-&gt;hasTagName(type))
 111             return false;
 112     }
 113     return true;
 114 }
 115 
 116 static inline bool isLastOfType(const Element&amp; element, const QualifiedName&amp; type)
 117 {
 118     for (const Element* sibling = ElementTraversal::nextSibling(element); sibling; sibling = ElementTraversal::nextSibling(*sibling)) {
 119         if (sibling-&gt;hasTagName(type))
 120             return false;
 121     }
 122     return true;
 123 }
 124 
 125 static inline int countElementsBefore(const Element&amp; element)
 126 {
 127     int count = 0;
 128     for (const Element* sibling = ElementTraversal::previousSibling(element); sibling; sibling = ElementTraversal::previousSibling(*sibling)) {
 129         unsigned index = sibling-&gt;childIndex();
 130         if (index) {
 131             count += index;
 132             break;
 133         }
 134         count++;
 135     }
 136     return count;
 137 }
 138 
 139 static inline int countElementsOfTypeBefore(const Element&amp; element, const QualifiedName&amp; type)
 140 {
 141     int count = 0;
 142     for (const Element* sibling = ElementTraversal::previousSibling(element); sibling; sibling = ElementTraversal::previousSibling(*sibling)) {
 143         if (sibling-&gt;hasTagName(type))
 144             ++count;
 145     }
 146     return count;
 147 }
 148 
 149 static inline int countElementsAfter(const Element&amp; element)
 150 {
 151     int count = 0;
 152     for (const Element* sibling = ElementTraversal::nextSibling(element); sibling; sibling = ElementTraversal::nextSibling(*sibling))
 153         ++count;
 154     return count;
 155 }
 156 
 157 static inline int countElementsOfTypeAfter(const Element&amp; element, const QualifiedName&amp; type)
 158 {
 159     int count = 0;
 160     for (const Element* sibling = ElementTraversal::nextSibling(element); sibling; sibling = ElementTraversal::nextSibling(*sibling)) {
 161         if (sibling-&gt;hasTagName(type))
 162             ++count;
 163     }
 164     return count;
 165 }
 166 
 167 SelectorChecker::SelectorChecker(Document&amp; document)
 168     : m_strictParsing(!document.inQuirksMode())
 169     , m_documentIsHTML(document.isHTMLDocument())
 170 {
 171 }
 172 
 173 bool SelectorChecker::match(const CSSSelector&amp; selector, const Element&amp; element, CheckingContext&amp; checkingContext, unsigned&amp; specificity) const
 174 {
 175     specificity = 0;
 176 
 177     LocalContext context(selector, element, checkingContext.resolvingMode == SelectorChecker::Mode::QueryingRules ? VisitedMatchType::Disabled : VisitedMatchType::Enabled, checkingContext.pseudoId);
 178 
 179     if (checkingContext.isMatchingHostPseudoClass) {
 180         ASSERT(element.shadowRoot());
 181         context.mayMatchHostPseudoClass = true;
 182     }
 183 
 184     PseudoIdSet pseudoIdSet;
 185     MatchResult result = matchRecursively(checkingContext, context, pseudoIdSet, specificity);
 186     if (result.match != Match::SelectorMatches)
 187         return false;
 188     if (checkingContext.pseudoId != PseudoId::None &amp;&amp; !pseudoIdSet.has(checkingContext.pseudoId))
 189         return false;
 190 
 191     if (checkingContext.pseudoId == PseudoId::None &amp;&amp; pseudoIdSet) {
 192         PseudoIdSet publicPseudoIdSet = pseudoIdSet &amp; PseudoIdSet::fromMask(static_cast&lt;unsigned&gt;(PseudoId::PublicPseudoIdMask));
 193         if (checkingContext.resolvingMode == Mode::ResolvingStyle &amp;&amp; publicPseudoIdSet)
 194             checkingContext.pseudoIDSet = publicPseudoIdSet;
 195 
 196         // When ignoring virtual pseudo elements, the context&#39;s pseudo should also be PseudoId::None but that does
 197         // not cause a failure.
 198         return checkingContext.resolvingMode == Mode::CollectingRulesIgnoringVirtualPseudoElements || result.matchType == MatchType::Element;
 199     }
 200     return true;
 201 }
 202 
 203 bool SelectorChecker::matchHostPseudoClass(const CSSSelector&amp; selector, const Element&amp; element, CheckingContext&amp; checkingContext, unsigned&amp; specificity) const
 204 {
 205     ASSERT(element.shadowRoot());
 206     ASSERT(selector.match() == CSSSelector::PseudoClass &amp;&amp; selector.pseudoClassType() == CSSSelector::PseudoClassHost);
 207 
 208     specificity = selector.simpleSelectorSpecificity();
 209 
 210     if (auto* selectorList = selector.selectorList()) {
 211         LocalContext context(*selectorList-&gt;first(), element, VisitedMatchType::Enabled, PseudoId::None);
 212         context.inFunctionalPseudoClass = true;
 213         context.pseudoElementEffective = false;
 214         PseudoIdSet ignoreDynamicPseudo;
 215         unsigned subselectorSpecificity = 0;
 216         if (matchRecursively(checkingContext, context, ignoreDynamicPseudo, subselectorSpecificity).match != Match::SelectorMatches)
 217             return false;
 218         specificity = CSSSelector::addSpecificities(specificity, subselectorSpecificity);
 219     }
 220     return true;
 221 }
 222 
 223 inline static bool hasScrollbarPseudoElement(const PseudoIdSet&amp; dynamicPseudoIdSet)
 224 {
 225     PseudoIdSet scrollbarIdSet = { PseudoId::Scrollbar, PseudoId::ScrollbarThumb, PseudoId::ScrollbarButton, PseudoId::ScrollbarTrack, PseudoId::ScrollbarTrackPiece, PseudoId::ScrollbarCorner };
 226     if (dynamicPseudoIdSet &amp; scrollbarIdSet)
 227         return true;
 228 
 229     // PseudoId::Resizer does not always have a scrollbar but it is a scrollbar-like pseudo element
 230     // because it can have more than one pseudo element.
 231     return dynamicPseudoIdSet.has(PseudoId::Resizer);
 232 }
 233 
 234 static SelectorChecker::LocalContext localContextForParent(const SelectorChecker::LocalContext&amp; context)
 235 {
 236     SelectorChecker::LocalContext updatedContext(context);
 237     // Disable :visited matching when we see the first link.
 238     if (context.element-&gt;isLink())
 239         updatedContext.visitedMatchType = VisitedMatchType::Disabled;
 240 
 241     updatedContext.isMatchElement = false;
 242     updatedContext.isSubjectOrAdjacentElement = false;
 243 
 244     if (updatedContext.mayMatchHostPseudoClass) {
 245         updatedContext.element = nullptr;
 246         return updatedContext;
 247     }
 248 
 249     // Move to the shadow host if matching :host and the parent is the shadow root.
 250     if (context.selector-&gt;match() == CSSSelector::PseudoClass &amp;&amp; context.selector-&gt;pseudoClassType() == CSSSelector::PseudoClassHost &amp;&amp; is&lt;ShadowRoot&gt;(context.element-&gt;parentNode())) {
 251         updatedContext.element = downcast&lt;ShadowRoot&gt;(*context.element-&gt;parentNode()).host();
 252         updatedContext.mayMatchHostPseudoClass = true;
 253         return updatedContext;
 254     }
 255 
 256     updatedContext.element = context.element-&gt;parentElement();
 257     return updatedContext;
 258 }
 259 
 260 // Recursive check of selectors and combinators
 261 // It can return 4 different values:
 262 // * SelectorMatches          - the selector matches the element e
 263 // * SelectorFailsLocally     - the selector fails for the element e
 264 // * SelectorFailsAllSiblings - the selector fails for e and any sibling of e
 265 // * SelectorFailsCompletely  - the selector fails for e and any sibling or ancestor of e
 266 SelectorChecker::MatchResult SelectorChecker::matchRecursively(CheckingContext&amp; checkingContext, const LocalContext&amp; context, PseudoIdSet&amp; dynamicPseudoIdSet, unsigned&amp; specificity) const
 267 {
 268     MatchType matchType = MatchType::Element;
 269 
 270     // The first selector has to match.
<a name="1" id="anc1"></a><span class="line-modified"> 271     if (!checkOne(checkingContext, context, matchType, specificity))</span>
 272         return MatchResult::fails(Match::SelectorFailsLocally);
 273 
 274     if (context.selector-&gt;match() == CSSSelector::PseudoElement) {
 275         if (context.selector-&gt;isCustomPseudoElement()) {
 276             // In functional pseudo class, custom pseudo elements are always disabled.
 277             // FIXME: We should accept custom pseudo elements inside :matches().
 278             if (context.inFunctionalPseudoClass)
 279                 return MatchResult::fails(Match::SelectorFailsCompletely);
 280             if (ShadowRoot* root = context.element-&gt;containingShadowRoot()) {
 281                 if (context.element-&gt;shadowPseudoId() != context.selector-&gt;value())
 282                     return MatchResult::fails(Match::SelectorFailsLocally);
 283 
 284                 if (context.selector-&gt;isWebKitCustomPseudoElement() &amp;&amp; root-&gt;mode() != ShadowRootMode::UserAgent)
 285                     return MatchResult::fails(Match::SelectorFailsLocally);
 286             } else
 287                 return MatchResult::fails(Match::SelectorFailsLocally);
 288         } else {
 289             if (!context.pseudoElementEffective)
 290                 return MatchResult::fails(Match::SelectorFailsCompletely);
 291 
 292             if (checkingContext.resolvingMode == Mode::QueryingRules)
 293                 return MatchResult::fails(Match::SelectorFailsCompletely);
 294 
 295             PseudoId pseudoId = CSSSelector::pseudoId(context.selector-&gt;pseudoElementType());
 296             if (pseudoId != PseudoId::None)
 297                 dynamicPseudoIdSet.add(pseudoId);
 298             matchType = MatchType::VirtualPseudoElementOnly;
 299         }
 300     }
 301 
 302     // The rest of the selectors has to match
 303     auto relation = context.selector-&gt;relation();
 304 
 305     // Prepare next selector
 306     const CSSSelector* leftSelector = context.selector-&gt;tagHistory();
 307     if (!leftSelector)
 308         return MatchResult::matches(matchType);
 309 
 310     LocalContext nextContext(context);
 311     nextContext.selector = leftSelector;
 312 
 313     if (relation != CSSSelector::Subselector) {
 314         // Bail-out if this selector is irrelevant for the pseudoId
 315         if (context.pseudoId != PseudoId::None &amp;&amp; !dynamicPseudoIdSet.has(context.pseudoId))
 316             return MatchResult::fails(Match::SelectorFailsCompletely);
 317 
 318         // Disable :visited matching when we try to match anything else than an ancestors.
 319         if (!context.selector-&gt;hasDescendantOrChildRelation())
 320             nextContext.visitedMatchType = VisitedMatchType::Disabled;
 321 
 322         nextContext.pseudoId = PseudoId::None;
<a name="2" id="anc2"></a><span class="line-added"> 323 </span>
<span class="line-added"> 324         bool nextIsPart = leftSelector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; leftSelector-&gt;pseudoElementType() == CSSSelector::PseudoElementPart;</span>
<span class="line-added"> 325         bool allowMultiplePseudoElements = relation == CSSSelector::ShadowDescendant &amp;&amp; nextIsPart;</span>
 326         // Virtual pseudo element is only effective in the rightmost fragment.
<a name="3" id="anc3"></a><span class="line-modified"> 327         if (!allowMultiplePseudoElements)</span>
<span class="line-added"> 328             nextContext.pseudoElementEffective = false;</span>
<span class="line-added"> 329 </span>
 330         nextContext.isMatchElement = false;
 331     }
 332 
 333     switch (relation) {
 334     case CSSSelector::DescendantSpace:
 335         nextContext = localContextForParent(nextContext);
 336         nextContext.firstSelectorOfTheFragment = nextContext.selector;
 337         for (; nextContext.element; nextContext = localContextForParent(nextContext)) {
 338             PseudoIdSet ignoreDynamicPseudo;
 339             unsigned descendantsSpecificity = 0;
 340             MatchResult result = matchRecursively(checkingContext, nextContext, ignoreDynamicPseudo, descendantsSpecificity);
 341             ASSERT(!nextContext.pseudoElementEffective &amp;&amp; !ignoreDynamicPseudo);
 342 
 343             if (result.match == Match::SelectorMatches)
 344                 specificity = CSSSelector::addSpecificities(specificity, descendantsSpecificity);
 345 
 346             if (result.match == Match::SelectorMatches || result.match == Match::SelectorFailsCompletely)
 347                 return MatchResult::updateWithMatchType(result, matchType);
 348         }
 349         return MatchResult::fails(Match::SelectorFailsCompletely);
 350 
 351     case CSSSelector::Child:
 352         {
 353             nextContext = localContextForParent(nextContext);
 354             if (!nextContext.element)
 355                 return MatchResult::fails(Match::SelectorFailsCompletely);
 356             nextContext.firstSelectorOfTheFragment = nextContext.selector;
 357             PseudoIdSet ignoreDynamicPseudo;
 358             unsigned childSpecificity = 0;
 359             MatchResult result = matchRecursively(checkingContext, nextContext, ignoreDynamicPseudo, childSpecificity);
 360             ASSERT(!nextContext.pseudoElementEffective &amp;&amp; !ignoreDynamicPseudo);
 361 
 362             if (result.match == Match::SelectorMatches)
 363                 specificity = CSSSelector::addSpecificities(specificity, childSpecificity);
 364 
 365             if (result.match == Match::SelectorMatches || result.match == Match::SelectorFailsCompletely)
 366                 return MatchResult::updateWithMatchType(result, matchType);
 367             return MatchResult::fails(Match::SelectorFailsAllSiblings);
 368         }
 369 
 370     case CSSSelector::DirectAdjacent:
 371         {
 372             auto relation = context.isMatchElement ? Style::Relation::AffectedByPreviousSibling : Style::Relation::DescendantsAffectedByPreviousSibling;
 373             addStyleRelation(checkingContext, *context.element, relation);
 374 
 375             Element* previousElement = context.element-&gt;previousElementSibling();
 376             if (!previousElement)
 377                 return MatchResult::fails(Match::SelectorFailsAllSiblings);
 378 
 379             addStyleRelation(checkingContext, *previousElement, Style::Relation::AffectsNextSibling);
 380 
 381             nextContext.element = previousElement;
 382             nextContext.firstSelectorOfTheFragment = nextContext.selector;
 383             PseudoIdSet ignoreDynamicPseudo;
 384             unsigned adjacentSpecificity = 0;
 385             MatchResult result = matchRecursively(checkingContext, nextContext, ignoreDynamicPseudo, adjacentSpecificity);
 386             ASSERT(!nextContext.pseudoElementEffective &amp;&amp; !ignoreDynamicPseudo);
 387 
 388             if (result.match == Match::SelectorMatches)
 389                 specificity = CSSSelector::addSpecificities(specificity, adjacentSpecificity);
 390 
 391             return MatchResult::updateWithMatchType(result, matchType);
 392         }
 393     case CSSSelector::IndirectAdjacent: {
 394         auto relation = context.isMatchElement ? Style::Relation::AffectedByPreviousSibling : Style::Relation::DescendantsAffectedByPreviousSibling;
 395         addStyleRelation(checkingContext, *context.element, relation);
 396 
 397         nextContext.element = context.element-&gt;previousElementSibling();
 398         nextContext.firstSelectorOfTheFragment = nextContext.selector;
 399         for (; nextContext.element; nextContext.element = nextContext.element-&gt;previousElementSibling()) {
 400             addStyleRelation(checkingContext, *nextContext.element, Style::Relation::AffectsNextSibling);
 401 
 402             PseudoIdSet ignoreDynamicPseudo;
 403             unsigned indirectAdjacentSpecificity = 0;
 404             MatchResult result = matchRecursively(checkingContext, nextContext, ignoreDynamicPseudo, indirectAdjacentSpecificity);
 405             ASSERT(!nextContext.pseudoElementEffective &amp;&amp; !ignoreDynamicPseudo);
 406 
 407             if (result.match == Match::SelectorMatches)
 408                 specificity = CSSSelector::addSpecificities(specificity, indirectAdjacentSpecificity);
 409 
 410             if (result.match == Match::SelectorMatches || result.match == Match::SelectorFailsAllSiblings || result.match == Match::SelectorFailsCompletely)
 411                 return MatchResult::updateWithMatchType(result, matchType);
 412         };
 413         return MatchResult::fails(Match::SelectorFailsAllSiblings);
 414     }
 415     case CSSSelector::Subselector:
 416         {
 417             // a selector is invalid if something follows a pseudo-element
 418             // We make an exception for scrollbar pseudo elements and allow a set of pseudo classes (but nothing else)
 419             // to follow the pseudo elements.
 420             nextContext.hasScrollbarPseudo = hasScrollbarPseudoElement(dynamicPseudoIdSet);
 421             nextContext.hasSelectionPseudo = dynamicPseudoIdSet.has(PseudoId::Selection);
 422             if ((context.isMatchElement || checkingContext.resolvingMode == Mode::CollectingRules) &amp;&amp; dynamicPseudoIdSet
 423                 &amp;&amp; !nextContext.hasSelectionPseudo
 424                 &amp;&amp; !(nextContext.hasScrollbarPseudo &amp;&amp; nextContext.selector-&gt;match() == CSSSelector::PseudoClass))
 425                 return MatchResult::fails(Match::SelectorFailsCompletely);
 426 
 427             unsigned subselectorSpecificity = 0;
 428             MatchResult result = matchRecursively(checkingContext, nextContext, dynamicPseudoIdSet, subselectorSpecificity);
 429 
 430             if (result.match == Match::SelectorMatches)
 431                 specificity = CSSSelector::addSpecificities(specificity, subselectorSpecificity);
 432 
 433             return MatchResult::updateWithMatchType(result, matchType);
 434         }
 435     case CSSSelector::ShadowDescendant:
 436         {
<a name="4" id="anc4"></a><span class="line-modified"> 437             // When matching foo::part(bar) we skip directly to the tree of element &#39;foo&#39;.</span>
<span class="line-modified"> 438             bool isPart = context.selector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; context.selector-&gt;pseudoElementType() == CSSSelector::PseudoElementPart;</span>
<span class="line-added"> 439             auto* shadowHost = isPart ? checkingContext.shadowHostInPartRuleScope : context.element-&gt;shadowHost();</span>
<span class="line-added"> 440             if (!shadowHost)</span>
 441                 return MatchResult::fails(Match::SelectorFailsCompletely);
<a name="5" id="anc5"></a><span class="line-modified"> 442             nextContext.element = shadowHost;</span>
 443             nextContext.firstSelectorOfTheFragment = nextContext.selector;
 444             nextContext.isSubjectOrAdjacentElement = false;
 445             PseudoIdSet ignoreDynamicPseudo;
 446             unsigned shadowDescendantSpecificity = 0;
 447             MatchResult result = matchRecursively(checkingContext, nextContext, ignoreDynamicPseudo, shadowDescendantSpecificity);
 448 
 449             if (result.match == Match::SelectorMatches)
 450                 specificity = CSSSelector::addSpecificities(specificity, shadowDescendantSpecificity);
 451 
 452             return MatchResult::updateWithMatchType(result, matchType);
 453         }
 454     }
 455 
 456 
 457     ASSERT_NOT_REACHED();
 458     return MatchResult::fails(Match::SelectorFailsCompletely);
 459 }
 460 
 461 static bool attributeValueMatches(const Attribute&amp; attribute, CSSSelector::Match match, const AtomString&amp; selectorValue, bool caseSensitive)
 462 {
 463     const AtomString&amp; value = attribute.value();
 464     ASSERT(!value.isNull());
 465 
 466     switch (match) {
 467     case CSSSelector::Set:
 468         break;
 469     case CSSSelector::Exact:
 470         if (caseSensitive ? selectorValue != value : !equalIgnoringASCIICase(selectorValue, value))
 471             return false;
 472         break;
 473     case CSSSelector::List:
 474         {
 475             // Ignore empty selectors or selectors containing spaces.
 476             if (selectorValue.isEmpty() || selectorValue.find(isHTMLSpace&lt;UChar&gt;) != notFound)
 477                 return false;
 478 
 479             unsigned startSearchAt = 0;
 480             while (true) {
 481                 size_t foundPos;
 482                 if (caseSensitive)
 483                     foundPos = value.find(selectorValue, startSearchAt);
 484                 else
 485                     foundPos = value.findIgnoringASCIICase(selectorValue, startSearchAt);
 486                 if (foundPos == notFound)
 487                     return false;
 488                 if (!foundPos || isHTMLSpace(value[foundPos - 1])) {
 489                     unsigned endStr = foundPos + selectorValue.length();
 490                     if (endStr == value.length() || isHTMLSpace(value[endStr]))
 491                         break; // We found a match.
 492                 }
 493 
 494                 // No match. Keep looking.
 495                 startSearchAt = foundPos + 1;
 496             }
 497             break;
 498         }
 499     case CSSSelector::Contain: {
 500         bool valueContainsSelectorValue;
 501         if (caseSensitive)
 502             valueContainsSelectorValue = value.contains(selectorValue);
 503         else
 504             valueContainsSelectorValue = value.containsIgnoringASCIICase(selectorValue);
 505 
 506         if (!valueContainsSelectorValue || selectorValue.isEmpty())
 507             return false;
 508 
 509         break;
 510     }
 511     case CSSSelector::Begin:
 512         if (selectorValue.isEmpty())
 513             return false;
 514         if (caseSensitive) {
 515             if (!value.startsWith(selectorValue))
 516                 return false;
 517         } else {
 518             if (!value.startsWithIgnoringASCIICase(selectorValue))
 519                 return false;
 520         }
 521         break;
 522     case CSSSelector::End:
 523         if (selectorValue.isEmpty())
 524             return false;
 525         if (caseSensitive) {
 526             if (!value.endsWith(selectorValue))
 527                 return false;
 528         } else {
 529             if (!value.endsWithIgnoringASCIICase(selectorValue))
 530                 return false;
 531         }
 532         break;
 533     case CSSSelector::Hyphen:
 534         if (value.length() &lt; selectorValue.length())
 535             return false;
 536         if (caseSensitive) {
 537             if (!value.startsWith(selectorValue))
 538                 return false;
 539         } else {
 540             if (!value.startsWithIgnoringASCIICase(selectorValue))
 541                 return false;
 542         }
 543         // It they start the same, check for exact match or following &#39;-&#39;:
 544         if (value.length() != selectorValue.length() &amp;&amp; value[selectorValue.length()] != &#39;-&#39;)
 545             return false;
 546         break;
 547     default:
 548         ASSERT_NOT_REACHED();
 549         return false;
 550     }
 551 
 552     return true;
 553 }
 554 
 555 static bool anyAttributeMatches(const Element&amp; element, const CSSSelector&amp; selector, const QualifiedName&amp; selectorAttr, bool caseSensitive)
 556 {
 557     ASSERT(element.hasAttributesWithoutUpdate());
 558     for (const Attribute&amp; attribute : element.attributesIterator()) {
 559         if (!attribute.matches(selectorAttr.prefix(), element.isHTMLElement() ? selector.attributeCanonicalLocalName() : selectorAttr.localName(), selectorAttr.namespaceURI()))
 560             continue;
 561 
 562         if (attributeValueMatches(attribute, selector.match(), selector.value(), caseSensitive))
 563             return true;
 564     }
 565 
 566     return false;
 567 }
 568 
 569 bool SelectorChecker::attributeSelectorMatches(const Element&amp; element, const QualifiedName&amp; attributeName, const AtomString&amp; attributeValue, const CSSSelector&amp; selector)
 570 {
 571     ASSERT(selector.isAttributeSelector());
 572     auto&amp; selectorAttribute = selector.attribute();
 573     auto&amp; selectorName = element.isHTMLElement() ? selector.attributeCanonicalLocalName() : selectorAttribute.localName();
 574     if (!Attribute::nameMatchesFilter(attributeName, selectorAttribute.prefix(), selectorName, selectorAttribute.namespaceURI()))
 575         return false;
 576     bool caseSensitive = true;
 577     if (selector.attributeValueMatchingIsCaseInsensitive())
 578         caseSensitive = false;
 579     else if (element.document().isHTMLDocument() &amp;&amp; element.isHTMLElement() &amp;&amp; !HTMLDocument::isCaseSensitiveAttribute(selector.attribute()))
 580         caseSensitive = false;
 581     return attributeValueMatches(Attribute(attributeName, attributeValue), selector.match(), selector.value(), caseSensitive);
 582 }
 583 
 584 static bool canMatchHoverOrActiveInQuirksMode(const SelectorChecker::LocalContext&amp; context)
 585 {
 586     // For quirks mode, follow this: http://quirks.spec.whatwg.org/#the-:active-and-:hover-quirk
 587     // In quirks mode, a compound selector &#39;selector&#39; that matches the following conditions must not match elements that would not also match the &#39;:any-link&#39; selector.
 588     //
 589     //    selector uses the &#39;:active&#39; or &#39;:hover&#39; pseudo-classes.
 590     //    selector does not use a type selector.
 591     //    selector does not use an attribute selector.
 592     //    selector does not use an ID selector.
 593     //    selector does not use a class selector.
 594     //    selector does not use a pseudo-class selector other than &#39;:active&#39; and &#39;:hover&#39;.
 595     //    selector does not use a pseudo-element selector.
 596     //    selector is not part of an argument to a functional pseudo-class or pseudo-element.
 597     if (context.inFunctionalPseudoClass)
 598         return true;
 599 
 600     for (const CSSSelector* selector = context.firstSelectorOfTheFragment; selector; selector = selector-&gt;tagHistory()) {
 601         switch (selector-&gt;match()) {
 602         case CSSSelector::Tag:
 603             if (selector-&gt;tagQName() != anyQName())
 604                 return true;
 605             break;
 606         case CSSSelector::PseudoClass: {
 607             CSSSelector::PseudoClassType pseudoClassType = selector-&gt;pseudoClassType();
 608             if (pseudoClassType != CSSSelector::PseudoClassHover &amp;&amp; pseudoClassType != CSSSelector::PseudoClassActive)
 609                 return true;
 610             break;
 611         }
 612         case CSSSelector::Id:
 613         case CSSSelector::Class:
 614         case CSSSelector::Exact:
 615         case CSSSelector::Set:
 616         case CSSSelector::List:
 617         case CSSSelector::Hyphen:
 618         case CSSSelector::Contain:
 619         case CSSSelector::Begin:
 620         case CSSSelector::End:
 621         case CSSSelector::PagePseudoClass:
 622         case CSSSelector::PseudoElement:
 623             return true;
 624         case CSSSelector::Unknown:
 625             ASSERT_NOT_REACHED();
 626             break;
 627         }
 628 
 629         auto relation = selector-&gt;relation();
 630         if (relation == CSSSelector::ShadowDescendant)
 631             return true;
 632 
 633         if (relation != CSSSelector::Subselector)
 634             return false;
 635     }
 636     return false;
 637 }
 638 
 639 static inline bool tagMatches(const Element&amp; element, const CSSSelector&amp; simpleSelector)
 640 {
 641     const QualifiedName&amp; tagQName = simpleSelector.tagQName();
 642 
 643     if (tagQName == anyQName())
 644         return true;
 645 
 646     const AtomString&amp; localName = (element.isHTMLElement() &amp;&amp; element.document().isHTMLDocument()) ? simpleSelector.tagLowercaseLocalName() : tagQName.localName();
 647 
 648     if (localName != starAtom() &amp;&amp; localName != element.localName())
 649         return false;
 650     const AtomString&amp; namespaceURI = tagQName.namespaceURI();
 651     return namespaceURI == starAtom() || namespaceURI == element.namespaceURI();
 652 }
 653 
<a name="6" id="anc6"></a><span class="line-modified"> 654 bool SelectorChecker::checkOne(CheckingContext&amp; checkingContext, const LocalContext&amp; context, MatchType&amp; matchType, unsigned&amp; specificity) const</span>
 655 {
 656     const Element&amp; element = *context.element;
 657     const CSSSelector&amp; selector = *context.selector;
 658 
 659     specificity = CSSSelector::addSpecificities(specificity, selector.simpleSelectorSpecificity());
 660 
 661     if (context.mayMatchHostPseudoClass) {
 662         // :host doesn&#39;t combine with anything except pseudo elements.
 663         bool isHostPseudoClass = selector.match() == CSSSelector::PseudoClass &amp;&amp; selector.pseudoClassType() == CSSSelector::PseudoClassHost;
 664         bool isPseudoElement = selector.match() == CSSSelector::PseudoElement;
 665         if (!isHostPseudoClass &amp;&amp; !isPseudoElement)
 666             return false;
 667     }
 668 
 669     if (selector.match() == CSSSelector::Tag)
 670         return tagMatches(element, selector);
 671 
 672     if (selector.match() == CSSSelector::Class)
 673         return element.hasClass() &amp;&amp; element.classNames().contains(selector.value());
 674 
 675     if (selector.match() == CSSSelector::Id) {
 676         ASSERT(!selector.value().isNull());
 677         return element.idForStyleResolution() == selector.value();
 678     }
 679 
 680     if (selector.isAttributeSelector()) {
 681         if (!element.hasAttributes())
 682             return false;
 683 
 684         const QualifiedName&amp; attr = selector.attribute();
 685         bool caseSensitive = true;
 686         if (selector.attributeValueMatchingIsCaseInsensitive())
 687             caseSensitive = false;
 688         else if (m_documentIsHTML &amp;&amp; element.isHTMLElement() &amp;&amp; !HTMLDocument::isCaseSensitiveAttribute(attr))
 689             caseSensitive = false;
 690 
 691         return anyAttributeMatches(element, selector, attr, caseSensitive);
 692     }
 693 
 694     if (selector.match() == CSSSelector::PseudoClass) {
 695         // Handle :not up front.
 696         if (selector.pseudoClassType() == CSSSelector::PseudoClassNot) {
 697             const CSSSelectorList* selectorList = selector.selectorList();
 698 
 699             for (const CSSSelector* subselector = selectorList-&gt;first(); subselector; subselector = CSSSelectorList::next(subselector)) {
 700                 LocalContext subcontext(context);
 701                 subcontext.inFunctionalPseudoClass = true;
 702                 subcontext.pseudoElementEffective = false;
 703                 subcontext.selector = subselector;
 704                 subcontext.firstSelectorOfTheFragment = selectorList-&gt;first();
 705                 PseudoIdSet ignoreDynamicPseudo;
 706 
 707                 unsigned ignoredSpecificity;
 708                 if (matchRecursively(checkingContext, subcontext, ignoreDynamicPseudo, ignoredSpecificity).match == Match::SelectorMatches) {
 709                     ASSERT(!ignoreDynamicPseudo);
 710                     return false;
 711                 }
 712             }
 713             return true;
 714         }
 715         if (context.hasScrollbarPseudo) {
 716             // CSS scrollbars match a specific subset of pseudo classes, and they have specialized rules for each
 717             // (since there are no elements involved except with window-inactive).
 718             return checkScrollbarPseudoClass(checkingContext, element, selector);
 719         }
 720 
 721         // Normal element pseudo class checking.
 722         switch (selector.pseudoClassType()) {
 723             // Pseudo classes:
 724         case CSSSelector::PseudoClassNot:
 725             break; // Already handled up above.
 726         case CSSSelector::PseudoClassEmpty:
 727             {
 728                 bool result = true;
 729                 for (Node* node = element.firstChild(); node; node = node-&gt;nextSibling()) {
 730                     if (is&lt;Element&gt;(*node)) {
 731                         result = false;
 732                         break;
 733                     }
 734                     if (is&lt;Text&gt;(*node)) {
 735                         Text&amp; textNode = downcast&lt;Text&gt;(*node);
 736                         if (!textNode.data().isEmpty()) {
 737                             result = false;
 738                             break;
 739                         }
 740                     }
 741                 }
 742                 addStyleRelation(checkingContext, *context.element, Style::Relation::AffectedByEmpty, result);
 743 
 744                 return result;
 745             }
 746         case CSSSelector::PseudoClassFirstChild: {
 747             // first-child matches the first child that is an element
 748             bool isFirstChild = isFirstChildElement(element);
 749             auto* parent = element.parentNode();
 750             if (is&lt;Element&gt;(parent))
 751                 addStyleRelation(checkingContext, downcast&lt;Element&gt;(*parent), Style::Relation::ChildrenAffectedByFirstChildRules);
 752             else if (!is&lt;ShadowRoot&gt;(parent))
 753                 break; // FIXME: Add the support for specifying relations on ShadowRoot.
 754             if (!isFirstChild)
 755                 break;
 756             addStyleRelation(checkingContext, element, Style::Relation::FirstChild);
 757             return true;
 758         }
 759         case CSSSelector::PseudoClassFirstOfType: {
 760             // first-of-type matches the first element of its type
 761             auto* parent = element.parentNode();
 762             if (is&lt;Element&gt;(parent)) {
 763                 auto relation = context.isSubjectOrAdjacentElement ? Style::Relation::ChildrenAffectedByForwardPositionalRules : Style::Relation::DescendantsAffectedByForwardPositionalRules;
 764                 addStyleRelation(checkingContext, downcast&lt;Element&gt;(*parent), relation);
 765             } else if (!is&lt;ShadowRoot&gt;(parent))
 766                 break; // FIXME: Add the support for specifying relations on ShadowRoot.
 767             return isFirstOfType(element, element.tagQName());
 768         }
 769         case CSSSelector::PseudoClassLastChild: {
 770             // last-child matches the last child that is an element
 771             auto* parent = element.parentNode();
 772             bool isLastChild = isLastChildElement(element);
 773             if (is&lt;Element&gt;(parent)) {
 774                 auto&amp; parentElement = downcast&lt;Element&gt;(*parent);
 775                 if (!parentElement.isFinishedParsingChildren())
 776                     isLastChild = false;
 777                 addStyleRelation(checkingContext, parentElement, Style::Relation::ChildrenAffectedByLastChildRules);
 778             } else if (!is&lt;ShadowRoot&gt;(parent))
 779                 break; // FIXME: Add the support for specifying relations on ShadowRoot.
 780             if (!isLastChild)
 781                 break;
 782             addStyleRelation(checkingContext, element, Style::Relation::LastChild);
 783             return true;
 784         }
 785         case CSSSelector::PseudoClassLastOfType: {
 786             // last-of-type matches the last element of its type
 787             auto* parent = element.parentNode();
 788             if (is&lt;Element&gt;(parent)) {
 789                 auto&amp; parentElement = downcast&lt;Element&gt;(*parent);
 790                 auto relation = context.isSubjectOrAdjacentElement ? Style::Relation::ChildrenAffectedByBackwardPositionalRules : Style::Relation::DescendantsAffectedByBackwardPositionalRules;
 791                 addStyleRelation(checkingContext, parentElement, relation);
 792                 if (!parentElement.isFinishedParsingChildren())
 793                     return false;
 794             } else if (!is&lt;ShadowRoot&gt;(parent))
 795                 break; // FIXME: Add the support for specifying relations on ShadowRoot.
 796             return isLastOfType(element, element.tagQName());
 797         }
 798         case CSSSelector::PseudoClassOnlyChild: {
 799             auto* parent = element.parentNode();
 800             bool firstChild = isFirstChildElement(element);
 801             bool onlyChild = firstChild &amp;&amp; isLastChildElement(element);
 802             if (is&lt;Element&gt;(parent)) {
 803                 auto&amp; parentElement = downcast&lt;Element&gt;(*parent);
 804                 addStyleRelation(checkingContext, parentElement, Style::Relation::ChildrenAffectedByFirstChildRules);
 805                 addStyleRelation(checkingContext, parentElement, Style::Relation::ChildrenAffectedByLastChildRules);
 806                 if (!parentElement.isFinishedParsingChildren())
 807                     onlyChild = false;
 808             } else if (!is&lt;ShadowRoot&gt;(parent))
 809                 break; // FIXME: Add the support for specifying relations on ShadowRoot.
 810             if (firstChild)
 811                 addStyleRelation(checkingContext, element, Style::Relation::FirstChild);
 812             if (onlyChild)
 813                 addStyleRelation(checkingContext, element, Style::Relation::LastChild);
 814             return onlyChild;
 815         }
 816         case CSSSelector::PseudoClassOnlyOfType: {
 817             // FIXME: This selector is very slow.
 818             auto* parent = element.parentNode();
 819             if (is&lt;Element&gt;(parent)) {
 820                 auto&amp; parentElement = downcast&lt;Element&gt;(*parent);
 821                 auto forwardRelation = context.isSubjectOrAdjacentElement ? Style::Relation::ChildrenAffectedByForwardPositionalRules : Style::Relation::DescendantsAffectedByForwardPositionalRules;
 822                 addStyleRelation(checkingContext, parentElement, forwardRelation);
 823                 auto backwardRelation = context.isSubjectOrAdjacentElement ? Style::Relation::ChildrenAffectedByBackwardPositionalRules : Style::Relation::DescendantsAffectedByBackwardPositionalRules;
 824                 addStyleRelation(checkingContext, parentElement, backwardRelation);
 825 
 826                 if (!parentElement.isFinishedParsingChildren())
 827                     return false;
 828             } else if (!is&lt;ShadowRoot&gt;(parent))
 829                 break; // FIXME: Add the support for specifying relations on ShadowRoot.
 830             return isFirstOfType(element, element.tagQName()) &amp;&amp; isLastOfType(element, element.tagQName());
 831         }
 832         case CSSSelector::PseudoClassMatches:
 833             {
 834                 bool hasMatchedAnything = false;
 835                 unsigned maxSpecificity = 0;
 836 
 837                 MatchType localMatchType = MatchType::VirtualPseudoElementOnly;
 838                 for (const CSSSelector* subselector = selector.selectorList()-&gt;first(); subselector; subselector = CSSSelectorList::next(subselector)) {
 839                     LocalContext subcontext(context);
 840                     subcontext.inFunctionalPseudoClass = true;
 841                     subcontext.pseudoElementEffective = context.pseudoElementEffective;
 842                     subcontext.selector = subselector;
 843                     subcontext.firstSelectorOfTheFragment = subselector;
<a name="7" id="anc7"></a><span class="line-added"> 844                     subcontext.pseudoId = PseudoId::None;</span>
 845                     PseudoIdSet localDynamicPseudoIdSet;
 846                     unsigned localSpecificity = 0;
 847                     MatchResult result = matchRecursively(checkingContext, subcontext, localDynamicPseudoIdSet, localSpecificity);
<a name="8" id="anc8"></a><span class="line-added"> 848 </span>
<span class="line-added"> 849                     // Pseudo elements are not valid inside :matches</span>
<span class="line-added"> 850                     if (localDynamicPseudoIdSet)</span>
<span class="line-added"> 851                         continue;</span>
<span class="line-added"> 852 </span>
 853                     if (result.match == Match::SelectorMatches) {
 854                         maxSpecificity = std::max(maxSpecificity, localSpecificity);
 855 
 856                         if (result.matchType == MatchType::Element)
 857                             localMatchType = MatchType::Element;
 858 
<a name="9" id="anc9"></a>
 859                         hasMatchedAnything = true;
 860                     }
 861                 }
 862                 if (hasMatchedAnything) {
 863                     matchType = localMatchType;
 864                     specificity = CSSSelector::addSpecificities(specificity, maxSpecificity);
 865                 }
 866                 return hasMatchedAnything;
 867             }
 868         case CSSSelector::PseudoClassPlaceholderShown:
 869             if (is&lt;HTMLTextFormControlElement&gt;(element)) {
 870                 addStyleRelation(checkingContext, element, Style::Relation::Unique);
 871                 return downcast&lt;HTMLTextFormControlElement&gt;(element).isPlaceholderVisible();
 872             }
 873             return false;
 874         case CSSSelector::PseudoClassNthChild: {
 875             auto* parent = element.parentNode();
 876             if (is&lt;Element&gt;(parent)) {
 877                 auto relation = context.isSubjectOrAdjacentElement ? Style::Relation::ChildrenAffectedByForwardPositionalRules : Style::Relation::DescendantsAffectedByForwardPositionalRules;
 878                 addStyleRelation(checkingContext, downcast&lt;Element&gt;(*parent), relation);
 879             } else if (!is&lt;ShadowRoot&gt;(parent))
 880                 break; // FIXME: Add the support for specifying relations on ShadowRoot.
 881 
 882             if (const CSSSelectorList* selectorList = selector.selectorList()) {
 883                 unsigned selectorListSpecificity;
 884                 if (!matchSelectorList(checkingContext, context, element, *selectorList, selectorListSpecificity))
 885                     return false;
 886                 specificity = CSSSelector::addSpecificities(specificity, selectorListSpecificity);
 887             }
 888 
 889             int count = 1;
 890             if (const CSSSelectorList* selectorList = selector.selectorList()) {
 891                 for (Element* sibling = ElementTraversal::previousSibling(element); sibling; sibling = ElementTraversal::previousSibling(*sibling)) {
 892                     unsigned ignoredSpecificity;
 893                     if (matchSelectorList(checkingContext, context, *sibling, *selectorList, ignoredSpecificity))
 894                         ++count;
 895                 }
 896             } else {
 897                 count += countElementsBefore(element);
 898                 addStyleRelation(checkingContext, element, Style::Relation::NthChildIndex, count);
 899             }
 900 
 901             if (selector.matchNth(count))
 902                 return true;
 903             break;
 904         }
 905         case CSSSelector::PseudoClassNthOfType: {
 906             auto* parent = element.parentNode();
 907             if (is&lt;Element&gt;(parent)) {
 908                 auto relation = context.isSubjectOrAdjacentElement ? Style::Relation::ChildrenAffectedByForwardPositionalRules : Style::Relation::DescendantsAffectedByForwardPositionalRules;
 909                 addStyleRelation(checkingContext, downcast&lt;Element&gt;(*parent), relation);
 910             } else if (!is&lt;ShadowRoot&gt;(parent))
 911                 break; // FIXME: Add the support for specifying relations on ShadowRoot.
 912 
 913             int count = 1 + countElementsOfTypeBefore(element, element.tagQName());
 914             if (selector.matchNth(count))
 915                 return true;
 916             break;
 917         }
 918         case CSSSelector::PseudoClassNthLastChild: {
 919             auto* parent = element.parentNode();
 920             if (is&lt;Element&gt;(parent)) {
 921                 auto&amp; parentElement = downcast&lt;Element&gt;(*parent);
 922                 if (const CSSSelectorList* selectorList = selector.selectorList()) {
 923                     unsigned selectorListSpecificity;
 924                     if (!matchSelectorList(checkingContext, context, element, *selectorList, selectorListSpecificity))
 925                         return false;
 926                     specificity = CSSSelector::addSpecificities(specificity, selectorListSpecificity);
 927 
 928                     addStyleRelation(checkingContext, parentElement, Style::Relation::ChildrenAffectedByPropertyBasedBackwardPositionalRules);
 929                 } else {
 930                     auto relation = context.isSubjectOrAdjacentElement ? Style::Relation::ChildrenAffectedByBackwardPositionalRules : Style::Relation::DescendantsAffectedByBackwardPositionalRules;
 931                     addStyleRelation(checkingContext, parentElement, relation);
 932                 }
 933                 if (!parentElement.isFinishedParsingChildren())
 934                     return false;
 935             } else if (!is&lt;ShadowRoot&gt;(parent))
 936                 break; // FIXME: Add the support for specifying relations on ShadowRoot.
 937 
 938             int count = 1;
 939             if (const CSSSelectorList* selectorList = selector.selectorList()) {
 940                 for (Element* sibling = ElementTraversal::nextSibling(element); sibling; sibling = ElementTraversal::nextSibling(*sibling)) {
 941                     unsigned ignoredSpecificity;
 942                     if (matchSelectorList(checkingContext, context, *sibling, *selectorList, ignoredSpecificity))
 943                         ++count;
 944                 }
 945             } else
 946                 count += countElementsAfter(element);
 947 
 948             return selector.matchNth(count);
 949         }
 950         case CSSSelector::PseudoClassNthLastOfType: {
 951             auto* parent = element.parentNode();
 952             if (is&lt;Element&gt;(parent)) {
 953                 auto&amp; parentElement = downcast&lt;Element&gt;(*parent);
 954                 auto relation = context.isSubjectOrAdjacentElement ? Style::Relation::ChildrenAffectedByBackwardPositionalRules : Style::Relation::DescendantsAffectedByBackwardPositionalRules;
 955                 addStyleRelation(checkingContext, parentElement, relation);
 956 
 957                 if (!parentElement.isFinishedParsingChildren())
 958                     return false;
 959             } else if (!is&lt;ShadowRoot&gt;(parent))
 960                 break; // FIXME: Add the support for specifying relations on ShadowRoot.
 961             int count = 1 + countElementsOfTypeAfter(element, element.tagQName());
 962             return selector.matchNth(count);
 963         }
 964         case CSSSelector::PseudoClassTarget:
 965             if (&amp;element == element.document().cssTarget())
 966                 return true;
 967             break;
 968         case CSSSelector::PseudoClassAny:
 969             {
 970                 LocalContext subcontext(context);
 971                 subcontext.inFunctionalPseudoClass = true;
 972                 subcontext.pseudoElementEffective = false;
 973                 for (subcontext.selector = selector.selectorList()-&gt;first(); subcontext.selector; subcontext.selector = CSSSelectorList::next(subcontext.selector)) {
 974                     subcontext.firstSelectorOfTheFragment = subcontext.selector;
 975                     PseudoIdSet ignoreDynamicPseudo;
 976                     unsigned ingoredSpecificity = 0;
 977                     if (matchRecursively(checkingContext, subcontext, ignoreDynamicPseudo, ingoredSpecificity).match == Match::SelectorMatches)
 978                         return true;
 979                 }
 980             }
 981             break;
 982         case CSSSelector::PseudoClassAutofill:
 983             return isAutofilled(element);
 984         case CSSSelector::PseudoClassAutofillStrongPassword:
 985             return isAutofilledStrongPassword(element);
 986         case CSSSelector::PseudoClassAutofillStrongPasswordViewable:
 987             return isAutofilledStrongPasswordViewable(element);
 988         case CSSSelector::PseudoClassAnyLink:
 989         case CSSSelector::PseudoClassAnyLinkDeprecated:
 990         case CSSSelector::PseudoClassLink:
 991             // :visited and :link matches are separated later when applying the style. Here both classes match all links...
 992             return element.isLink();
 993         case CSSSelector::PseudoClassVisited:
 994             // ...except if :visited matching is disabled for ancestor/sibling matching.
 995             // Inside functional pseudo class except for :not, :visited never matches.
 996             if (context.inFunctionalPseudoClass)
 997                 return false;
 998             return element.isLink() &amp;&amp; context.visitedMatchType == VisitedMatchType::Enabled;
<a name="10" id="anc10"></a><span class="line-added"> 999         case CSSSelector::PseudoClassDirectFocus:</span>
<span class="line-added">1000             return matchesDirectFocusPseudoClass(element);</span>
1001         case CSSSelector::PseudoClassDrag:
1002             addStyleRelation(checkingContext, element, Style::Relation::AffectedByDrag);
1003 
1004             if (element.renderer() &amp;&amp; element.renderer()-&gt;isDragging())
1005                 return true;
1006             break;
1007         case CSSSelector::PseudoClassFocus:
1008             return matchesFocusPseudoClass(element);
1009         case CSSSelector::PseudoClassFocusWithin:
1010             addStyleRelation(checkingContext, element, Style::Relation::AffectedByFocusWithin);
1011             return element.hasFocusWithin();
1012         case CSSSelector::PseudoClassHover:
1013             if (m_strictParsing || element.isLink() || canMatchHoverOrActiveInQuirksMode(context)) {
1014                 addStyleRelation(checkingContext, element, Style::Relation::AffectedByHover);
1015 
1016                 // See the comment in generateElementIsHovered() in SelectorCompiler.
1017                 if (checkingContext.resolvingMode == SelectorChecker::Mode::CollectingRulesIgnoringVirtualPseudoElements &amp;&amp; !context.isMatchElement)
1018                     return true;
1019 
1020                 if (element.hovered() || InspectorInstrumentation::forcePseudoState(element, CSSSelector::PseudoClassHover))
1021                     return true;
1022             }
1023             break;
1024         case CSSSelector::PseudoClassActive:
1025             if (m_strictParsing || element.isLink() || canMatchHoverOrActiveInQuirksMode(context)) {
1026                 addStyleRelation(checkingContext, element, Style::Relation::AffectedByActive);
1027 
1028                 if (element.active() || InspectorInstrumentation::forcePseudoState(element, CSSSelector::PseudoClassActive))
1029                     return true;
1030             }
1031             break;
1032         case CSSSelector::PseudoClassEnabled:
1033             return matchesEnabledPseudoClass(element);
1034         case CSSSelector::PseudoClassFullPageMedia:
1035             return isMediaDocument(element);
1036         case CSSSelector::PseudoClassDefault:
1037             return matchesDefaultPseudoClass(element);
1038         case CSSSelector::PseudoClassDisabled:
1039             return matchesDisabledPseudoClass(element);
1040         case CSSSelector::PseudoClassReadOnly:
1041             return matchesReadOnlyPseudoClass(element);
1042         case CSSSelector::PseudoClassReadWrite:
1043             return matchesReadWritePseudoClass(element);
1044         case CSSSelector::PseudoClassOptional:
1045             return isOptionalFormControl(element);
1046         case CSSSelector::PseudoClassRequired:
1047             return isRequiredFormControl(element);
1048         case CSSSelector::PseudoClassValid:
1049             return isValid(element);
1050         case CSSSelector::PseudoClassInvalid:
1051             return isInvalid(element);
1052         case CSSSelector::PseudoClassChecked:
1053             return isChecked(element);
1054         case CSSSelector::PseudoClassIndeterminate:
1055             return matchesIndeterminatePseudoClass(element);
1056         case CSSSelector::PseudoClassRoot:
1057             if (&amp;element == element.document().documentElement())
1058                 return true;
1059             break;
1060         case CSSSelector::PseudoClassLang:
1061             {
<a name="11" id="anc11"></a><span class="line-modified">1062                 ASSERT(selector.argumentList() &amp;&amp; !selector.argumentList()-&gt;isEmpty());</span>
<span class="line-modified">1063                 return matchesLangPseudoClass(element, *selector.argumentList());</span>
1064             }
1065 #if ENABLE(FULLSCREEN_API)
1066         case CSSSelector::PseudoClassFullScreen:
1067             return matchesFullScreenPseudoClass(element);
1068         case CSSSelector::PseudoClassAnimatingFullScreenTransition:
1069             return matchesFullScreenAnimatingFullScreenTransitionPseudoClass(element);
1070         case CSSSelector::PseudoClassFullScreenAncestor:
1071             return matchesFullScreenAncestorPseudoClass(element);
1072         case CSSSelector::PseudoClassFullScreenDocument:
1073             return matchesFullScreenDocumentPseudoClass(element);
1074         case CSSSelector::PseudoClassFullScreenControlsHidden:
1075             return matchesFullScreenControlsHiddenPseudoClass(element);
<a name="12" id="anc12"></a><span class="line-added">1076 #endif</span>
<span class="line-added">1077 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added">1078         case CSSSelector::PseudoClassPictureInPicture:</span>
<span class="line-added">1079             return matchesPictureInPicturePseudoClass(element);</span>
1080 #endif
1081         case CSSSelector::PseudoClassInRange:
1082             return isInRange(element);
1083         case CSSSelector::PseudoClassOutOfRange:
1084             return isOutOfRange(element);
1085 #if ENABLE(VIDEO_TRACK)
1086         case CSSSelector::PseudoClassFuture:
1087             return matchesFutureCuePseudoClass(element);
1088         case CSSSelector::PseudoClassPast:
1089             return matchesPastCuePseudoClass(element);
1090 #endif
1091 
1092         case CSSSelector::PseudoClassScope: {
1093             const Node* contextualReferenceNode = !checkingContext.scope ? element.document().documentElement() : checkingContext.scope;
1094             if (&amp;element == contextualReferenceNode)
1095                 return true;
1096             break;
1097         }
1098         case CSSSelector::PseudoClassHost: {
1099             if (!context.mayMatchHostPseudoClass)
1100                 return false;
1101             unsigned hostSpecificity;
1102             if (!matchHostPseudoClass(selector, element, checkingContext, hostSpecificity))
1103                 return false;
1104             specificity = CSSSelector::addSpecificities(specificity, hostSpecificity);
1105             return true;
1106         }
1107         case CSSSelector::PseudoClassDefined:
1108             return isDefinedElement(element);
1109         case CSSSelector::PseudoClassWindowInactive:
1110             return isWindowInactive(element);
1111 
1112         case CSSSelector::PseudoClassHorizontal:
1113         case CSSSelector::PseudoClassVertical:
1114         case CSSSelector::PseudoClassDecrement:
1115         case CSSSelector::PseudoClassIncrement:
1116         case CSSSelector::PseudoClassStart:
1117         case CSSSelector::PseudoClassEnd:
1118         case CSSSelector::PseudoClassDoubleButton:
1119         case CSSSelector::PseudoClassSingleButton:
1120         case CSSSelector::PseudoClassNoButton:
1121         case CSSSelector::PseudoClassCornerPresent:
1122             return false;
1123 
1124 #if ENABLE(CSS_SELECTORS_LEVEL4)
1125         // FIXME: Implement :dir() selector.
1126         case CSSSelector::PseudoClassDir:
1127             return false;
1128 
1129         // FIXME: Implement :role() selector.
1130         case CSSSelector::PseudoClassRole:
1131             return false;
1132 #endif
1133 
1134 #if ENABLE(ATTACHMENT_ELEMENT)
1135         case CSSSelector::PseudoClassHasAttachment:
1136             return hasAttachment(element);
1137 #endif
1138 
1139         case CSSSelector::PseudoClassUnknown:
1140             ASSERT_NOT_REACHED();
1141             break;
1142         }
1143         return false;
1144     }
<a name="13" id="anc13"></a><span class="line-added">1145 </span>
<span class="line-added">1146     if (selector.match() == CSSSelector::PseudoElement) {</span>
<span class="line-added">1147         switch (selector.pseudoElementType()) {</span>
1148 #if ENABLE(VIDEO_TRACK)
<a name="14" id="anc14"></a><span class="line-modified">1149         case CSSSelector::PseudoElementCue: {</span>
<span class="line-modified">1150             LocalContext subcontext(context);</span>
1151 
<a name="15" id="anc15"></a><span class="line-modified">1152             const CSSSelector* const &amp; selector = context.selector;</span>
<span class="line-modified">1153             for (subcontext.selector = selector-&gt;selectorList()-&gt;first(); subcontext.selector; subcontext.selector = CSSSelectorList::next(subcontext.selector)) {</span>
<span class="line-modified">1154                 subcontext.firstSelectorOfTheFragment = subcontext.selector;</span>
<span class="line-modified">1155                 subcontext.inFunctionalPseudoClass = true;</span>
<span class="line-modified">1156                 subcontext.pseudoElementEffective = false;</span>
<span class="line-modified">1157                 PseudoIdSet ignoredDynamicPseudo;</span>
<span class="line-modified">1158                 unsigned ignoredSpecificity = 0;</span>
<span class="line-modified">1159                 if (matchRecursively(checkingContext, subcontext, ignoredDynamicPseudo, ignoredSpecificity).match == Match::SelectorMatches)</span>
<span class="line-modified">1160                     return true;</span>
<span class="line-added">1161             }</span>
<span class="line-added">1162             return false;</span>
1163         }
<a name="16" id="anc16"></a>

1164 #endif
<a name="17" id="anc17"></a><span class="line-modified">1165         case CSSSelector::PseudoElementSlotted:</span>
<span class="line-modified">1166             // We see ::slotted() pseudo elements when collecting slotted rules from the slot shadow tree only.</span>
<span class="line-modified">1167             ASSERT(checkingContext.resolvingMode == Mode::CollectingRules);</span>
<span class="line-modified">1168             return is&lt;HTMLSlotElement&gt;(element);</span>
<span class="line-added">1169 </span>
<span class="line-added">1170         case CSSSelector::PseudoElementPart: {</span>
<span class="line-added">1171             auto translatePartNameToRuleScope = [&amp;](AtomString partName) {</span>
<span class="line-added">1172                 Vector&lt;AtomString, 1&gt; mappedNames { partName };</span>
<span class="line-added">1173                 for (auto* shadowRoot = element.containingShadowRoot(); shadowRoot; shadowRoot = shadowRoot-&gt;host()-&gt;containingShadowRoot()) {</span>
<span class="line-added">1174                     // Apply mappings up to the scope the rules are coming from.</span>
<span class="line-added">1175                     if (shadowRoot-&gt;host() == checkingContext.shadowHostInPartRuleScope)</span>
<span class="line-added">1176                         break;</span>
<span class="line-added">1177 </span>
<span class="line-added">1178                     Vector&lt;AtomString, 1&gt; newMappedNames;</span>
<span class="line-added">1179                     for (auto&amp; name : mappedNames)</span>
<span class="line-added">1180                         newMappedNames.appendVector(shadowRoot-&gt;partMappings().get(name));</span>
<span class="line-added">1181                     mappedNames = newMappedNames;</span>
<span class="line-added">1182 </span>
<span class="line-added">1183                     if (mappedNames.isEmpty())</span>
<span class="line-added">1184                         break;</span>
<span class="line-added">1185                 }</span>
<span class="line-added">1186                 return mappedNames;</span>
<span class="line-added">1187             };</span>
<span class="line-added">1188 </span>
<span class="line-added">1189             Vector&lt;AtomString, 4&gt; translatedPartNames;</span>
<span class="line-added">1190             for (unsigned i = 0; i &lt; element.partNames().size(); ++i)</span>
<span class="line-added">1191                 translatedPartNames.appendVector(translatePartNameToRuleScope(element.partNames()[i]));</span>
<span class="line-added">1192 </span>
<span class="line-added">1193             for (auto&amp; part : *selector.argumentList()) {</span>
<span class="line-added">1194                 if (!translatedPartNames.contains(part))</span>
<span class="line-added">1195                     return false;</span>
<span class="line-added">1196             }</span>
<span class="line-added">1197             return true;</span>
<span class="line-added">1198         }</span>
<span class="line-added">1199 </span>
<span class="line-added">1200         case CSSSelector::PseudoElementHighlight:</span>
<span class="line-added">1201             // Always matches when not specifically requested so it gets added to the pseudoIdSet.</span>
<span class="line-added">1202             if (checkingContext.pseudoId == PseudoId::None)</span>
<span class="line-added">1203                 return true;</span>
<span class="line-added">1204             if (checkingContext.pseudoId != PseudoId::Highlight)</span>
<span class="line-added">1205                 return false;</span>
<span class="line-added">1206             return selector.argumentList()-&gt;first() == checkingContext.nameForHightlightPseudoElement;</span>
<span class="line-added">1207 </span>
<span class="line-added">1208         default:</span>
<span class="line-added">1209             return true;</span>
<span class="line-added">1210         }</span>
1211     }
1212     return true;
1213 }
1214 
1215 bool SelectorChecker::matchSelectorList(CheckingContext&amp; checkingContext, const LocalContext&amp; context, const Element&amp; element, const CSSSelectorList&amp; selectorList, unsigned&amp; specificity) const
1216 {
1217     specificity = 0;
1218     bool hasMatchedAnything = false;
1219 
1220     for (const CSSSelector* subselector = selectorList.first(); subselector; subselector = CSSSelectorList::next(subselector)) {
1221         LocalContext subcontext(context);
1222         subcontext.element = &amp;element;
1223         subcontext.selector = subselector;
1224         subcontext.inFunctionalPseudoClass = true;
1225         subcontext.pseudoElementEffective = false;
1226         subcontext.firstSelectorOfTheFragment = subselector;
1227         PseudoIdSet ignoreDynamicPseudo;
1228         unsigned localSpecificity = 0;
1229         if (matchRecursively(checkingContext, subcontext, ignoreDynamicPseudo, localSpecificity).match == Match::SelectorMatches) {
1230             ASSERT(!ignoreDynamicPseudo);
1231 
1232             hasMatchedAnything = true;
1233             specificity = std::max(specificity, localSpecificity);
1234         }
1235     }
1236     return hasMatchedAnything;
1237 }
1238 
1239 bool SelectorChecker::checkScrollbarPseudoClass(const CheckingContext&amp; checkingContext, const Element&amp; element, const CSSSelector&amp; selector) const
1240 {
1241     ASSERT(selector.match() == CSSSelector::PseudoClass);
1242 
1243     switch (selector.pseudoClassType()) {
1244     case CSSSelector::PseudoClassWindowInactive:
1245         return isWindowInactive(element);
1246     case CSSSelector::PseudoClassEnabled:
1247         return scrollbarMatchesEnabledPseudoClass(checkingContext);
1248     case CSSSelector::PseudoClassDisabled:
1249         return scrollbarMatchesDisabledPseudoClass(checkingContext);
1250     case CSSSelector::PseudoClassHover:
1251         return scrollbarMatchesHoverPseudoClass(checkingContext);
1252     case CSSSelector::PseudoClassActive:
1253         return scrollbarMatchesActivePseudoClass(checkingContext);
1254     case CSSSelector::PseudoClassHorizontal:
1255         return scrollbarMatchesHorizontalPseudoClass(checkingContext);
1256     case CSSSelector::PseudoClassVertical:
1257         return scrollbarMatchesVerticalPseudoClass(checkingContext);
1258     case CSSSelector::PseudoClassDecrement:
1259         return scrollbarMatchesDecrementPseudoClass(checkingContext);
1260     case CSSSelector::PseudoClassIncrement:
1261         return scrollbarMatchesIncrementPseudoClass(checkingContext);
1262     case CSSSelector::PseudoClassStart:
1263         return scrollbarMatchesStartPseudoClass(checkingContext);
1264     case CSSSelector::PseudoClassEnd:
1265         return scrollbarMatchesEndPseudoClass(checkingContext);
1266     case CSSSelector::PseudoClassDoubleButton:
1267         return scrollbarMatchesDoubleButtonPseudoClass(checkingContext);
1268     case CSSSelector::PseudoClassSingleButton:
1269         return scrollbarMatchesSingleButtonPseudoClass(checkingContext);
1270     case CSSSelector::PseudoClassNoButton:
1271         return scrollbarMatchesNoButtonPseudoClass(checkingContext);
1272     case CSSSelector::PseudoClassCornerPresent:
1273         return scrollbarMatchesCornerPresentPseudoClass(checkingContext);
1274     default:
1275         return false;
1276     }
1277 }
1278 
1279 unsigned SelectorChecker::determineLinkMatchType(const CSSSelector* selector)
1280 {
1281     unsigned linkMatchType = MatchAll;
1282 
1283     // Statically determine if this selector will match a link in visited, unvisited or any state, or never.
1284     // :visited never matches other elements than the innermost link element.
1285     for (; selector; selector = selector-&gt;tagHistory()) {
1286         if (selector-&gt;match() == CSSSelector::PseudoClass) {
1287             switch (selector-&gt;pseudoClassType()) {
1288             case CSSSelector::PseudoClassLink:
1289                 linkMatchType &amp;= ~SelectorChecker::MatchVisited;
1290                 break;
1291             case CSSSelector::PseudoClassVisited:
1292                 linkMatchType &amp;= ~SelectorChecker::MatchLink;
1293                 break;
1294             default:
1295                 break;
1296             }
1297         }
1298         auto relation = selector-&gt;relation();
1299         if (relation == CSSSelector::Subselector)
1300             continue;
1301         if (!selector-&gt;hasDescendantOrChildRelation())
1302             return linkMatchType;
1303         if (linkMatchType != MatchAll)
1304             return linkMatchType;
1305     }
1306     return linkMatchType;
1307 }
1308 
1309 static bool isFrameFocused(const Element&amp; element)
1310 {
1311     return element.document().frame() &amp;&amp; element.document().frame()-&gt;selection().isFocusedAndActive();
1312 }
1313 
<a name="18" id="anc18"></a><span class="line-added">1314 static bool doesShadowTreeContainFocusedElement(const Element&amp; element)</span>
<span class="line-added">1315 {</span>
<span class="line-added">1316     auto* shadowRoot = element.shadowRoot();</span>
<span class="line-added">1317     return shadowRoot &amp;&amp; shadowRoot-&gt;containsFocusedElement();</span>
<span class="line-added">1318 }</span>
<span class="line-added">1319 </span>
1320 bool SelectorChecker::matchesFocusPseudoClass(const Element&amp; element)
1321 {
1322     if (InspectorInstrumentation::forcePseudoState(element, CSSSelector::PseudoClassFocus))
1323         return true;
<a name="19" id="anc19"></a><span class="line-added">1324 </span>
<span class="line-added">1325     return (element.focused() || doesShadowTreeContainFocusedElement(element)) &amp;&amp; isFrameFocused(element);</span>
<span class="line-added">1326 }</span>
<span class="line-added">1327 </span>
<span class="line-added">1328 // This needs to match a subset of elements matchesFocusPseudoClass match since direct focus is treated</span>
<span class="line-added">1329 // as a part of focus pseudo class selectors in ElementRuleCollector::collectMatchingRules.</span>
<span class="line-added">1330 bool SelectorChecker::matchesDirectFocusPseudoClass(const Element&amp; element)</span>
<span class="line-added">1331 {</span>
<span class="line-added">1332     if (InspectorInstrumentation::forcePseudoState(element, CSSSelector::PseudoClassFocus))</span>
<span class="line-added">1333         return true;</span>
<span class="line-added">1334 </span>
1335     return element.focused() &amp;&amp; isFrameFocused(element);
1336 }
1337 
1338 }
<a name="20" id="anc20"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="20" type="hidden" />
</body>
</html>
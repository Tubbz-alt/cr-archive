<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBCursor.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SQLiteIDBBackingStore.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SQLiteIDBCursor.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/server/SQLiteIDBCursor.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 40,11 ***</span>
  #include &lt;wtf/text/StringBuilder.h&gt;
  
  namespace WebCore {
  namespace IDBServer {
  
<span class="line-modified">! static const size_t prefetchLimit = 8;</span>
  
  std::unique_ptr&lt;SQLiteIDBCursor&gt; SQLiteIDBCursor::maybeCreate(SQLiteIDBTransaction&amp; transaction, const IDBCursorInfo&amp; info)
  {
      auto cursor = makeUnique&lt;SQLiteIDBCursor&gt;(transaction, info);
  
<span class="line-new-header">--- 40,12 ---</span>
  #include &lt;wtf/text/StringBuilder.h&gt;
  
  namespace WebCore {
  namespace IDBServer {
  
<span class="line-modified">! static const size_t prefetchLimit = 256;</span>
<span class="line-added">+ static const size_t prefetchSizeLimit = 1 * MB;</span>
  
  std::unique_ptr&lt;SQLiteIDBCursor&gt; SQLiteIDBCursor::maybeCreate(SQLiteIDBTransaction&amp; transaction, const IDBCursorInfo&amp; info)
  {
      auto cursor = makeUnique&lt;SQLiteIDBCursor&gt;(transaction, info);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 99,29 ***</span>
  {
      if (m_backingStoreCursor)
          m_transaction-&gt;closeCursor(*this);
  }
  
<span class="line-modified">! void SQLiteIDBCursor::currentData(IDBGetResult&amp; result, const Optional&lt;IDBKeyPath&gt;&amp; keyPath)</span>
  {
      ASSERT(!m_fetchedRecords.isEmpty());
  
      auto&amp; currentRecord = m_fetchedRecords.first();
      if (currentRecord.completed) {
          ASSERT(!currentRecord.errored);
          result = { };
          return;
      }
  
<span class="line-modified">!     result = { currentRecord.record.key, currentRecord.record.primaryKey, currentRecord.record.value ? *currentRecord.record.value : IDBValue(), keyPath};</span>
  }
  
  static String buildIndexStatement(const IDBKeyRangeData&amp; keyRange, IndexedDB::CursorDirection cursorDirection)
  {
      StringBuilder builder;
  
<span class="line-modified">!     builder.appendLiteral(&quot;SELECT rowid, key, value FROM IndexRecords WHERE indexID = ? AND objectStoreID = ? AND key &quot;);</span>
      if (!keyRange.lowerKey.isNull() &amp;&amp; !keyRange.lowerOpen)
          builder.appendLiteral(&quot;&gt;=&quot;);
      else
          builder.append(&#39;&gt;&#39;);
  
<span class="line-new-header">--- 100,66 ---</span>
  {
      if (m_backingStoreCursor)
          m_transaction-&gt;closeCursor(*this);
  }
  
<span class="line-modified">! void SQLiteIDBCursor::currentData(IDBGetResult&amp; result, const Optional&lt;IDBKeyPath&gt;&amp; keyPath, ShouldIncludePrefetchedRecords shouldIncludePrefetchedRecords)</span>
  {
      ASSERT(!m_fetchedRecords.isEmpty());
  
      auto&amp; currentRecord = m_fetchedRecords.first();
      if (currentRecord.completed) {
          ASSERT(!currentRecord.errored);
          result = { };
          return;
      }
  
<span class="line-modified">!     if (shouldIncludePrefetchedRecords == ShouldIncludePrefetchedRecords::No) {</span>
<span class="line-added">+         result = { currentRecord.record.key, currentRecord.record.primaryKey, IDBValue(currentRecord.record.value), keyPath };</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     Vector&lt;IDBCursorRecord&gt; prefetchedRecords;</span>
<span class="line-added">+     prefetchedRecords.reserveCapacity(m_fetchedRecords.size());</span>
<span class="line-added">+     for (auto&amp; record : m_fetchedRecords) {</span>
<span class="line-added">+         if (record.isTerminalRecord())</span>
<span class="line-added">+             break;</span>
<span class="line-added">+ </span>
<span class="line-added">+         prefetchedRecords.append(record.record);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // First record will be returned as current record.</span>
<span class="line-added">+     if (!prefetchedRecords.isEmpty())</span>
<span class="line-added">+         prefetchedRecords.remove(0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     result = { currentRecord.record.key, currentRecord.record.primaryKey, IDBValue(currentRecord.record.value), keyPath, WTFMove(prefetchedRecords) };</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static String buildPreIndexStatement(bool isDirectionNext)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     StringBuilder builder;</span>
<span class="line-added">+ </span>
<span class="line-added">+     builder.appendLiteral(&quot;SELECT rowid, key, value FROM IndexRecords WHERE indexID = ? AND key = CAST(? AS TEXT) AND value &quot;);</span>
<span class="line-added">+     if (isDirectionNext)</span>
<span class="line-added">+         builder.append(&#39;&gt;&#39;);</span>
<span class="line-added">+     else</span>
<span class="line-added">+         builder.append(&#39;&lt;&#39;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     builder.appendLiteral(&quot; CAST(? AS TEXT) ORDER BY value&quot;);</span>
<span class="line-added">+     if (!isDirectionNext)</span>
<span class="line-added">+         builder.appendLiteral(&quot; DESC&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     builder.append(&#39;;&#39;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return builder.toString();</span>
  }
  
  static String buildIndexStatement(const IDBKeyRangeData&amp; keyRange, IndexedDB::CursorDirection cursorDirection)
  {
      StringBuilder builder;
  
<span class="line-modified">!     builder.appendLiteral(&quot;SELECT rowid, key, value FROM IndexRecords WHERE indexID = ? AND key &quot;);</span>
      if (!keyRange.lowerKey.isNull() &amp;&amp; !keyRange.lowerOpen)
          builder.appendLiteral(&quot;&gt;=&quot;);
      else
          builder.append(&#39;&gt;&#39;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 215,27 ***</span>
          return;
  
      ASSERT(!m_fetchedRecords.isEmpty());
  
      m_currentKeyForUniqueness = m_fetchedRecords.first().record.key;
<span class="line-modified">! </span>
<span class="line-modified">!     if (m_cursorDirection != IndexedDB::CursorDirection::Nextunique &amp;&amp; m_cursorDirection != IndexedDB::CursorDirection::Prevunique) {</span>
<span class="line-removed">-         if (!m_fetchedRecords.last().isTerminalRecord())</span>
<span class="line-removed">-             fetch(ShouldFetchForSameKey::Yes);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         while (m_fetchedRecords.last().record.key != m_fetchedRecords.first().record.key)</span>
<span class="line-removed">-             m_fetchedRecords.removeLast();</span>
<span class="line-removed">-     } else</span>
<span class="line-removed">-         m_fetchedRecords.clear();</span>
  
      // If ObjectStore or Index contents changed, we need to reset the statement and bind new parameters to it.
      // This is to pick up any changes that might exist.
<span class="line-removed">-     // We also need to throw away any fetched records as they may no longer be valid.</span>
<span class="line-removed">- </span>
      m_statementNeedsReset = true;
  
<span class="line-modified">!     if (m_cursorDirection == IndexedDB::CursorDirection::Next || m_cursorDirection == IndexedDB::CursorDirection::Nextunique) {</span>
          m_currentLowerKey = m_currentKeyForUniqueness;
          if (!m_keyRange.lowerOpen) {
              m_keyRange.lowerOpen = true;
              m_keyRange.lowerKey = m_currentLowerKey;
              m_statement = nullptr;
<span class="line-new-header">--- 253,18 ---</span>
          return;
  
      ASSERT(!m_fetchedRecords.isEmpty());
  
      m_currentKeyForUniqueness = m_fetchedRecords.first().record.key;
<span class="line-modified">!     if (m_indexID != IDBIndexInfo::InvalidId)</span>
<span class="line-modified">!         m_currentIndexRecordValue = m_fetchedRecords.first().record.primaryKey;</span>
  
      // If ObjectStore or Index contents changed, we need to reset the statement and bind new parameters to it.
      // This is to pick up any changes that might exist.
      m_statementNeedsReset = true;
  
<span class="line-modified">!     if (isDirectionNext()) {</span>
          m_currentLowerKey = m_currentKeyForUniqueness;
          if (!m_keyRange.lowerOpen) {
              m_keyRange.lowerOpen = true;
              m_keyRange.lowerKey = m_currentLowerKey;
              m_statement = nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 246,10 ***</span>
<span class="line-new-header">--- 275,16 ---</span>
              m_keyRange.upperOpen = true;
              m_keyRange.upperKey = m_currentUpperKey;
              m_statement = nullptr;
          }
      }
<span class="line-added">+ </span>
<span class="line-added">+     // We also need to throw away any fetched records as they may no longer be valid.</span>
<span class="line-added">+     m_fetchedRecords.clear();</span>
<span class="line-added">+     m_fetchedRecordsSize = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_prefetchCount = 0;</span>
  }
  
  void SQLiteIDBCursor::resetAndRebindStatement()
  {
      ASSERT(!m_currentLowerKey.isNull());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 281,15 ***</span>
      if (m_statement-&gt;bindInt64(currentBindArgument++, m_boundID) != SQLITE_OK) {
          LOG_ERROR(&quot;Could not bind id argument (bound ID)&quot;);
          return false;
      }
  
<span class="line-removed">-     if (m_indexID != IDBIndexInfo::InvalidId &amp;&amp; m_statement-&gt;bindInt64(currentBindArgument++, m_objectStoreID) != SQLITE_OK) {</span>
<span class="line-removed">-         LOG_ERROR(&quot;Could not bind object store id argument for an index cursor&quot;);</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      RefPtr&lt;SharedBuffer&gt; buffer = serializeIDBKeyData(m_currentLowerKey);
      if (m_statement-&gt;bindBlob(currentBindArgument++, buffer-&gt;data(), buffer-&gt;size()) != SQLITE_OK) {
          LOG_ERROR(&quot;Could not create cursor statement (lower key)&quot;);
          return false;
      }
<span class="line-new-header">--- 316,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 301,21 ***</span>
      }
  
      return true;
  }
  
<span class="line-modified">! bool SQLiteIDBCursor::prefetch()</span>
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;SQLiteIDBCursor::prefetch() - Cursor already has %zu fetched records&quot;, m_fetchedRecords.size());</span>
  
<span class="line-modified">!     if (m_fetchedRecords.isEmpty() || m_fetchedRecords.size() &gt;= prefetchLimit || m_fetchedRecords.last().isTerminalRecord())</span>
          return false;
  
      m_currentKeyForUniqueness = m_fetchedRecords.last().record.key;
<span class="line-removed">-     fetch();</span>
  
<span class="line-modified">!     return m_fetchedRecords.size() &lt; prefetchLimit;</span>
  }
  
  bool SQLiteIDBCursor::advance(uint64_t count)
  {
      LOG(IndexedDB, &quot;SQLiteIDBCursor::advance() - Count %&quot; PRIu64 &quot;, %zu fetched records&quot;, count, m_fetchedRecords.size());
<span class="line-new-header">--- 331,82 ---</span>
      }
  
      return true;
  }
  
<span class="line-modified">! bool SQLiteIDBCursor::resetAndRebindPreIndexStatementIfNecessary()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_indexID == IDBIndexInfo::InvalidId)</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_currentIndexRecordValue.isNull())</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto&amp; database = m_transaction-&gt;sqliteTransaction()-&gt;database();</span>
<span class="line-added">+     if (!m_preIndexStatement) {</span>
<span class="line-added">+         m_preIndexStatement = makeUnique&lt;SQLiteStatement&gt;(database, buildPreIndexStatement(isDirectionNext()));</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (m_preIndexStatement-&gt;prepare() != SQLITE_OK) {</span>
<span class="line-added">+             LOG_ERROR(&quot;Could not prepare pre statement - &#39;%s&#39;&quot;, database.lastErrorMsg());</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_preIndexStatement-&gt;reset() != SQLITE_OK) {</span>
<span class="line-added">+         LOG_ERROR(&quot;Could not reset pre statement - &#39;%s&#39;&quot;, database.lastErrorMsg());</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto key = isDirectionNext() ? m_currentLowerKey : m_currentUpperKey;</span>
<span class="line-added">+     int currentBindArgument = 1;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (m_preIndexStatement-&gt;bindInt64(currentBindArgument++, m_boundID) != SQLITE_OK) {</span>
<span class="line-added">+         LOG_ERROR(&quot;Could not bind id argument to pre statement (bound ID)&quot;);</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     RefPtr&lt;SharedBuffer&gt; buffer = serializeIDBKeyData(key);</span>
<span class="line-added">+     if (m_preIndexStatement-&gt;bindBlob(currentBindArgument++, buffer-&gt;data(), buffer-&gt;size()) != SQLITE_OK) {</span>
<span class="line-added">+         LOG_ERROR(&quot;Could not bind id argument to pre statement (key)&quot;);</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     buffer = serializeIDBKeyData(m_currentIndexRecordValue);</span>
<span class="line-added">+     if (m_preIndexStatement-&gt;bindBlob(currentBindArgument++, buffer-&gt;data(), buffer-&gt;size()) != SQLITE_OK) {</span>
<span class="line-added">+         LOG_ERROR(&quot;Could not bind id argument to pre statement (value)&quot;);</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool SQLiteIDBCursor::prefetchOneRecord()</span>
  {
<span class="line-modified">!     LOG(IndexedDB, &quot;SQLiteIDBCursor::prefetchOneRecord() - Cursor already has %zu fetched records&quot;, m_fetchedRecords.size());</span>
  
<span class="line-modified">!     if (m_fetchedRecordsSize &gt;= prefetchSizeLimit || m_fetchedRecords.isEmpty() || m_fetchedRecords.size() &gt;= prefetchLimit || m_fetchedRecords.last().isTerminalRecord())</span>
          return false;
  
      m_currentKeyForUniqueness = m_fetchedRecords.last().record.key;
  
<span class="line-modified">!     return fetch() &amp;&amp; m_fetchedRecords.size() &lt; prefetchLimit &amp;&amp; m_fetchedRecordsSize &lt; prefetchSizeLimit;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void SQLiteIDBCursor::increaseCountToPrefetch()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_prefetchCount = m_prefetchCount ? m_prefetchCount * 2 : 1;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool SQLiteIDBCursor::prefetch()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     for (unsigned i = 0; i &lt; m_prefetchCount; ++i) {</span>
<span class="line-added">+         if (!prefetchOneRecord())</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     increaseCountToPrefetch();</span>
<span class="line-added">+     return true;</span>
  }
  
  bool SQLiteIDBCursor::advance(uint64_t count)
  {
      LOG(IndexedDB, &quot;SQLiteIDBCursor::advance() - Count %&quot; PRIu64 &quot;, %zu fetched records&quot;, count, m_fetchedRecords.size());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 333,10 ***</span>
<span class="line-new-header">--- 424,12 ---</span>
      bool hadCurrentRecord = !m_fetchedRecords.isEmpty();
      for (; count &amp;&amp; !m_fetchedRecords.isEmpty(); --count) {
          if (m_fetchedRecords.first().isTerminalRecord())
              break;
  
<span class="line-added">+         ASSERT(m_fetchedRecordsSize &gt;= m_fetchedRecords.first().record.size());</span>
<span class="line-added">+         m_fetchedRecordsSize -= m_fetchedRecords.first().record.size();</span>
          m_fetchedRecords.removeFirst();
      }
  
      // If we still have any records left, the first record is our new current record.
      if (!m_fetchedRecords.isEmpty())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 351,10 ***</span>
<span class="line-new-header">--- 444,13 ---</span>
  
      for (; count; --count) {
          if (!m_fetchedRecords.isEmpty()) {
              ASSERT(m_fetchedRecords.size() == 1);
              m_currentKeyForUniqueness = m_fetchedRecords.first().record.key;
<span class="line-added">+ </span>
<span class="line-added">+             ASSERT(m_fetchedRecordsSize &gt;= m_fetchedRecords.first().record.size());</span>
<span class="line-added">+             m_fetchedRecordsSize -= m_fetchedRecords.first().record.size();</span>
              m_fetchedRecords.removeFirst();
          }
  
          if (!fetch())
              return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 366,38 ***</span>
      }
  
      return true;
  }
  
<span class="line-modified">! bool SQLiteIDBCursor::fetch(ShouldFetchForSameKey shouldFetchForSameKey)</span>
  {
      ASSERT(m_fetchedRecords.isEmpty() || !m_fetchedRecords.last().isTerminalRecord());
  
      m_fetchedRecords.append({ });
  
<span class="line-modified">!     bool isUnique = m_cursorDirection == IndexedDB::CursorDirection::Nextunique || m_cursorDirection == IndexedDB::CursorDirection::Prevunique || shouldFetchForSameKey == ShouldFetchForSameKey::Yes;</span>
<span class="line-modified">!     if (!isUnique)</span>
<span class="line-modified">!         return fetchNextRecord(m_fetchedRecords.last());</span>
  
      while (fetchNextRecord(m_fetchedRecords.last())) {
          if (m_currentKeyForUniqueness.compare(m_fetchedRecords.last().record.key))
              return true;
  
          if (m_fetchedRecords.last().completed)
              return false;
  
<span class="line-modified">!         if (shouldFetchForSameKey == ShouldFetchForSameKey::Yes)</span>
<span class="line-removed">-             m_fetchedRecords.append({ });</span>
      }
  
      return false;
  }
  
  bool SQLiteIDBCursor::fetchNextRecord(SQLiteCursorRecord&amp; record)
  {
<span class="line-modified">!     if (m_statementNeedsReset)</span>
          resetAndRebindStatement();
  
      FetchResult result;
      do {
          result = internalFetchNextRecord(record);
      } while (result == FetchResult::ShouldFetchAgain);
<span class="line-new-header">--- 462,45 ---</span>
      }
  
      return true;
  }
  
<span class="line-modified">! bool SQLiteIDBCursor::fetch()</span>
  {
      ASSERT(m_fetchedRecords.isEmpty() || !m_fetchedRecords.last().isTerminalRecord());
  
      m_fetchedRecords.append({ });
  
<span class="line-modified">!     bool isUnique = m_cursorDirection == IndexedDB::CursorDirection::Nextunique || m_cursorDirection == IndexedDB::CursorDirection::Prevunique;</span>
<span class="line-modified">!     if (!isUnique) {</span>
<span class="line-modified">!         bool fetchSucceeded = fetchNextRecord(m_fetchedRecords.last());</span>
<span class="line-added">+         if (fetchSucceeded)</span>
<span class="line-added">+             m_fetchedRecordsSize += m_fetchedRecords.last().record.size();</span>
<span class="line-added">+         return fetchSucceeded;</span>
<span class="line-added">+     }</span>
  
      while (fetchNextRecord(m_fetchedRecords.last())) {
<span class="line-added">+         m_fetchedRecordsSize += m_fetchedRecords.last().record.size();</span>
<span class="line-added">+ </span>
          if (m_currentKeyForUniqueness.compare(m_fetchedRecords.last().record.key))
              return true;
  
          if (m_fetchedRecords.last().completed)
              return false;
  
<span class="line-modified">!         m_fetchedRecordsSize -= m_fetchedRecords.last().record.size();</span>
      }
  
      return false;
  }
  
  bool SQLiteIDBCursor::fetchNextRecord(SQLiteCursorRecord&amp; record)
  {
<span class="line-modified">!     if (m_statementNeedsReset) {</span>
<span class="line-added">+         resetAndRebindPreIndexStatementIfNecessary();</span>
          resetAndRebindStatement();
<span class="line-added">+     }</span>
  
      FetchResult result;
      do {
          result = internalFetchNextRecord(record);
      } while (result == FetchResult::ShouldFetchAgain);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 418,40 ***</span>
      ASSERT(m_transaction-&gt;sqliteTransaction());
      ASSERT(m_statement);
      ASSERT(!m_fetchedRecords.isEmpty());
      ASSERT(!m_fetchedRecords.last().isTerminalRecord());
  
<span class="line-modified">!     record.record.value = nullptr;</span>
  
<span class="line-modified">!     int result = m_statement-&gt;step();</span>
<span class="line-modified">!     if (result == SQLITE_DONE) {</span>
<span class="line-modified">!         // When a cursor reaches its end, that is indicated by having undefined keys/values</span>
<span class="line-removed">-         record = { };</span>
<span class="line-removed">-         record.completed = true;</span>
  
<span class="line-modified">!         return FetchResult::Success;</span>
      }
  
<span class="line-modified">!     if (result != SQLITE_ROW) {</span>
<span class="line-modified">!         LOG_ERROR(&quot;Error advancing cursor - (%i) %s&quot;, result, m_transaction-&gt;sqliteTransaction()-&gt;database().lastErrorMsg());</span>
<span class="line-modified">!         markAsErrored(record);</span>
<span class="line-modified">!         return FetchResult::Failure;</span>
      }
  
<span class="line-modified">!     record.rowID = m_statement-&gt;getColumnInt64(0);</span>
      ASSERT(record.rowID);
  
      Vector&lt;uint8_t&gt; keyData;
<span class="line-modified">!     m_statement-&gt;getColumnBlobAsVector(1, keyData);</span>
  
      if (!deserializeIDBKeyData(keyData.data(), keyData.size(), record.record.key)) {
          LOG_ERROR(&quot;Unable to deserialize key data from database while advancing cursor&quot;);
          markAsErrored(record);
          return FetchResult::Failure;
      }
  
<span class="line-modified">!     m_statement-&gt;getColumnBlobAsVector(2, keyData);</span>
  
      // The primaryKey of an ObjectStore cursor is the same as its key.
      if (m_indexID == IDBIndexInfo::InvalidId) {
          record.record.primaryKey = record.record.key;
  
<span class="line-new-header">--- 521,54 ---</span>
      ASSERT(m_transaction-&gt;sqliteTransaction());
      ASSERT(m_statement);
      ASSERT(!m_fetchedRecords.isEmpty());
      ASSERT(!m_fetchedRecords.last().isTerminalRecord());
  
<span class="line-modified">!     record.record.value = { };</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto&amp; database = m_transaction-&gt;sqliteTransaction()-&gt;database();</span>
<span class="line-added">+     SQLiteStatement* statement = nullptr;</span>
  
<span class="line-modified">!     int result;</span>
<span class="line-modified">!     if (m_preIndexStatement) {</span>
<span class="line-modified">!         ASSERT(m_indexID != IDBIndexInfo::InvalidId);</span>
  
<span class="line-modified">!         result = m_preIndexStatement-&gt;step();</span>
<span class="line-added">+         if (result == SQLITE_ROW)</span>
<span class="line-added">+             statement = m_preIndexStatement.get();</span>
<span class="line-added">+         else if (result != SQLITE_DONE)</span>
<span class="line-added">+             LOG_ERROR(&quot;Error advancing with pre statement - (%i) %s&quot;, result, database.lastErrorMsg());</span>
      }
  
<span class="line-modified">!     if (!statement) {</span>
<span class="line-modified">!         result = m_statement-&gt;step();</span>
<span class="line-modified">!         if (result == SQLITE_DONE) {</span>
<span class="line-modified">!             record = { };</span>
<span class="line-added">+             record.completed = true;</span>
<span class="line-added">+             return FetchResult::Success;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         if (result != SQLITE_ROW) {</span>
<span class="line-added">+             LOG_ERROR(&quot;Error advancing cursor - (%i) %s&quot;, result, database.lastErrorMsg());</span>
<span class="line-added">+             markAsErrored(record);</span>
<span class="line-added">+             return FetchResult::Failure;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         statement = m_statement.get();</span>
      }
  
<span class="line-modified">!     record.rowID = statement-&gt;getColumnInt64(0);</span>
      ASSERT(record.rowID);
  
      Vector&lt;uint8_t&gt; keyData;
<span class="line-modified">!     statement-&gt;getColumnBlobAsVector(1, keyData);</span>
  
      if (!deserializeIDBKeyData(keyData.data(), keyData.size(), record.record.key)) {
          LOG_ERROR(&quot;Unable to deserialize key data from database while advancing cursor&quot;);
          markAsErrored(record);
          return FetchResult::Failure;
      }
  
<span class="line-modified">!     statement-&gt;getColumnBlobAsVector(2, keyData);</span>
  
      // The primaryKey of an ObjectStore cursor is the same as its key.
      if (m_indexID == IDBIndexInfo::InvalidId) {
          record.record.primaryKey = record.record.key;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 462,39 ***</span>
              markAsErrored(record);
              return FetchResult::Failure;
          }
  
          if (m_cursorType == IndexedDB::CursorType::KeyAndValue)
<span class="line-modified">!             record.record.value = makeUnique&lt;IDBValue&gt;(ThreadSafeDataBuffer::create(WTFMove(keyData)), blobURLs, blobFilePaths);</span>
      } else {
          if (!deserializeIDBKeyData(keyData.data(), keyData.size(), record.record.primaryKey)) {
              LOG_ERROR(&quot;Unable to deserialize value data from database while advancing index cursor&quot;);
              markAsErrored(record);
              return FetchResult::Failure;
          }
  
<span class="line-modified">!         SQLiteStatement objectStoreStatement(m_statement-&gt;database(), &quot;SELECT value FROM Records WHERE key = CAST(? AS TEXT) and objectStoreID = ?;&quot;);</span>
  
<span class="line-modified">!         if (objectStoreStatement.prepare() != SQLITE_OK</span>
<span class="line-modified">!             || objectStoreStatement.bindBlob(1, keyData.data(), keyData.size()) != SQLITE_OK</span>
<span class="line-modified">!             || objectStoreStatement.bindInt64(2, m_objectStoreID) != SQLITE_OK) {</span>
<span class="line-modified">!             LOG_ERROR(&quot;Could not create index cursor statement into object store records (%i) &#39;%s&#39;&quot;, m_statement-&gt;database().lastError(), m_statement-&gt;database().lastErrorMsg());</span>
              markAsErrored(record);
              return FetchResult::Failure;
          }
  
<span class="line-modified">!         int result = objectStoreStatement.step();</span>
  
          if (result == SQLITE_ROW) {
<span class="line-modified">!             objectStoreStatement.getColumnBlobAsVector(0, keyData);</span>
<span class="line-modified">!             record.record.value = makeUnique&lt;IDBValue&gt;(ThreadSafeDataBuffer::create(WTFMove(keyData)));</span>
          } else if (result == SQLITE_DONE) {
              // This indicates that the record we&#39;re trying to retrieve has been removed from the object store.
              // Skip over it.
              return FetchResult::ShouldFetchAgain;
          } else {
<span class="line-modified">!             LOG_ERROR(&quot;Could not step index cursor statement into object store records (%i) &#39;%s&#39;&quot;, m_statement-&gt;database().lastError(), m_statement-&gt;database().lastErrorMsg());</span>
              markAsErrored(record);
              return FetchResult::Failure;
  
          }
      }
<span class="line-new-header">--- 579,43 ---</span>
              markAsErrored(record);
              return FetchResult::Failure;
          }
  
          if (m_cursorType == IndexedDB::CursorType::KeyAndValue)
<span class="line-modified">!             record.record.value = { ThreadSafeDataBuffer::create(WTFMove(keyData)), blobURLs, blobFilePaths };</span>
      } else {
          if (!deserializeIDBKeyData(keyData.data(), keyData.size(), record.record.primaryKey)) {
              LOG_ERROR(&quot;Unable to deserialize value data from database while advancing index cursor&quot;);
              markAsErrored(record);
              return FetchResult::Failure;
          }
  
<span class="line-modified">!         if (!m_cachedObjectStoreStatement || m_cachedObjectStoreStatement-&gt;reset() != SQLITE_OK) {</span>
<span class="line-added">+             m_cachedObjectStoreStatement = makeUnique&lt;SQLiteStatement&gt;(database, &quot;SELECT value FROM Records WHERE key = CAST(? AS TEXT) and objectStoreID = ?;&quot;);</span>
<span class="line-added">+             if (m_cachedObjectStoreStatement-&gt;prepare() != SQLITE_OK)</span>
<span class="line-added">+                 m_cachedObjectStoreStatement = nullptr;</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         if (!m_cachedObjectStoreStatement</span>
<span class="line-modified">!             || m_cachedObjectStoreStatement-&gt;bindBlob(1, keyData.data(), keyData.size()) != SQLITE_OK</span>
<span class="line-modified">!             || m_cachedObjectStoreStatement-&gt;bindInt64(2, m_objectStoreID) != SQLITE_OK) {</span>
<span class="line-modified">!             LOG_ERROR(&quot;Could not create index cursor statement into object store records (%i) &#39;%s&#39;&quot;, database.lastError(), database.lastErrorMsg());</span>
              markAsErrored(record);
              return FetchResult::Failure;
          }
  
<span class="line-modified">!         int result = m_cachedObjectStoreStatement-&gt;step();</span>
  
          if (result == SQLITE_ROW) {
<span class="line-modified">!             m_cachedObjectStoreStatement-&gt;getColumnBlobAsVector(0, keyData);</span>
<span class="line-modified">!             record.record.value = { ThreadSafeDataBuffer::create(WTFMove(keyData)) };</span>
          } else if (result == SQLITE_DONE) {
              // This indicates that the record we&#39;re trying to retrieve has been removed from the object store.
              // Skip over it.
              return FetchResult::ShouldFetchAgain;
          } else {
<span class="line-modified">!             LOG_ERROR(&quot;Could not step index cursor statement into object store records (%i) &#39;%s&#39;&quot;, database.lastError(), database.lastErrorMsg());</span>
              markAsErrored(record);
              return FetchResult::Failure;
  
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 557,14 ***</span>
  {
      ASSERT(!m_fetchedRecords.isEmpty());
      return m_fetchedRecords.first().record.primaryKey;
  }
  
<span class="line-modified">! IDBValue* SQLiteIDBCursor::currentValue() const</span>
  {
      ASSERT(!m_fetchedRecords.isEmpty());
<span class="line-modified">!     return m_fetchedRecords.first().record.value.get();</span>
  }
  
  bool SQLiteIDBCursor::didComplete() const
  {
      ASSERT(!m_fetchedRecords.isEmpty());
<span class="line-new-header">--- 678,14 ---</span>
  {
      ASSERT(!m_fetchedRecords.isEmpty());
      return m_fetchedRecords.first().record.primaryKey;
  }
  
<span class="line-modified">! const IDBValue&amp; SQLiteIDBCursor::currentValue() const</span>
  {
      ASSERT(!m_fetchedRecords.isEmpty());
<span class="line-modified">!     return m_fetchedRecords.first().record.value;</span>
  }
  
  bool SQLiteIDBCursor::didComplete() const
  {
      ASSERT(!m_fetchedRecords.isEmpty());
</pre>
<center><a href="SQLiteIDBBackingStore.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SQLiteIDBCursor.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
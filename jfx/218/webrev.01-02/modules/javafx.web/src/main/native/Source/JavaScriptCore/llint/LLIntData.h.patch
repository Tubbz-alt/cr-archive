diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/llint/LLIntData.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/llint/LLIntData.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/llint/LLIntData.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/llint/LLIntData.h
@@ -23,42 +23,45 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #pragma once
 
+#include "GPRInfo.h"
+#include "Instruction.h"
 #include "JSCJSValue.h"
 #include "MacroAssemblerCodeRef.h"
 #include "Opcode.h"
 
 namespace JSC {
 
 class VM;
-struct Instruction;
 
 #if ENABLE(C_LOOP)
 typedef OpcodeID LLIntCode;
 #else
 typedef void (*LLIntCode)();
 #endif
 
 namespace LLInt {
 
-extern "C" JS_EXPORT_PRIVATE Opcode g_opcodeMap[numOpcodeIDs];
-extern "C" JS_EXPORT_PRIVATE Opcode g_opcodeMapWide16[numOpcodeIDs];
-extern "C" JS_EXPORT_PRIVATE Opcode g_opcodeMapWide32[numOpcodeIDs];
+extern "C" JS_EXPORT_PRIVATE Opcode g_opcodeMap[numOpcodeIDs + numWasmOpcodeIDs];
+extern "C" JS_EXPORT_PRIVATE Opcode g_opcodeMapWide16[numOpcodeIDs + numWasmOpcodeIDs];
+extern "C" JS_EXPORT_PRIVATE Opcode g_opcodeMapWide32[numOpcodeIDs + numWasmOpcodeIDs];
 
 class Data {
 
 public:
     static void performAssertions(VM&);
 
 private:
     static uint8_t s_exceptionInstructions[maxOpcodeLength + 1];
+    static uint8_t s_wasmExceptionInstructions[maxOpcodeLength + 1];
 
     friend void initialize();
 
     friend Instruction* exceptionInstructions();
+    friend Instruction* wasmExceptionInstructions();
     friend Opcode* opcodeMap();
     friend Opcode* opcodeMapWide16();
     friend Opcode* opcodeMapWide32();
     friend Opcode getOpcode(OpcodeID);
     friend Opcode getOpcodeWide16(OpcodeID);
@@ -74,10 +77,15 @@
 inline Instruction* exceptionInstructions()
 {
     return reinterpret_cast<Instruction*>(Data::s_exceptionInstructions);
 }
 
+inline Instruction* wasmExceptionInstructions()
+{
+    return bitwise_cast<Instruction*>(Data::s_wasmExceptionInstructions);
+}
+
 inline Opcode* opcodeMap()
 {
     return g_opcodeMap;
 }
 
@@ -140,10 +148,20 @@
     void* address = reinterpret_cast<void*>(getOpcodeWide32(opcodeID));
     address = retagCodePtr<BytecodePtrTag, tag>(address);
     return MacroAssemblerCodePtr<tag>::createFromExecutableAddress(address);
 }
 
+template<PtrTag tag>
+ALWAYS_INLINE MacroAssemblerCodePtr<tag> getCodePtr(const Instruction& instruction)
+{
+    if (instruction.isWide16())
+        return getWide16CodePtr<tag>(instruction.opcodeID());
+    if (instruction.isWide32())
+        return getWide32CodePtr<tag>(instruction.opcodeID());
+    return getCodePtr<tag>(instruction.opcodeID());
+}
+
 template<PtrTag tag>
 ALWAYS_INLINE MacroAssemblerCodeRef<tag> getCodeRef(OpcodeID opcodeID)
 {
     return MacroAssemblerCodeRef<tag>::createSelfManagedCodeRef(getCodePtr<tag>(opcodeID));
 }
@@ -180,6 +198,26 @@
 ALWAYS_INLINE void* getCodePtr(JSC::EncodedJSValue glueHelper())
 {
     return bitwise_cast<void*>(glueHelper);
 }
 
+#if ENABLE(JIT)
+struct Registers {
+    static constexpr GPRReg pcGPR = GPRInfo::regT4;
+
+#if CPU(X86_64) && !OS(WINDOWS)
+    static constexpr GPRReg metadataTableGPR = GPRInfo::regCS1;
+    static constexpr GPRReg pbGPR = GPRInfo::regCS2;
+#elif CPU(X86_64) && OS(WINDOWS)
+    static constexpr GPRReg metadataTableGPR = GPRInfo::regCS3;
+    static constexpr GPRReg pbGPR = GPRInfo::regCS4;
+#elif CPU(ARM64)
+    static constexpr GPRReg metadataTableGPR = GPRInfo::regCS6;
+    static constexpr GPRReg pbGPR = GPRInfo::regCS7;
+#elif CPU(MIPS) || CPU(ARM_THUMB2)
+    static constexpr GPRReg metadataTableGPR = GPRInfo::regCS0;
+    static constexpr GPRReg pbGPR = GPRInfo::regCS1;
+#endif
+};
+#endif
+
 } } // namespace JSC::LLInt

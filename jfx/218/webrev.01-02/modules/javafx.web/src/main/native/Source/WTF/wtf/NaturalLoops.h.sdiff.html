<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/NaturalLoops.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MonotonicTime.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="NeverDestroyed.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/NaturalLoops.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013-2017 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
109 };
110 
111 template&lt;typename Graph&gt;
112 class NaturalLoops {
113     WTF_MAKE_FAST_ALLOCATED;
114 public:
115     typedef std::array&lt;unsigned, 2&gt; InnerMostLoopIndices;
116 
117     NaturalLoops(Graph&amp; graph, Dominators&lt;Graph&gt;&amp; dominators, bool selfCheck = false)
118         : m_graph(graph)
119         , m_innerMostLoopIndices(graph.template newMap&lt;InnerMostLoopIndices&gt;())
120     {
121         // Implement the classic dominator-based natural loop finder. The first
122         // step is to find all control flow edges A -&gt; B where B dominates A.
123         // Then B is a loop header and A is a backward branching block. We will
124         // then accumulate, for each loop header, multiple backward branching
125         // blocks. Then we backwards graph search from the backward branching
126         // blocks to their loop headers, which gives us all of the blocks in the
127         // loop body.
128 
<span class="line-modified">129         static const bool verbose = false;</span>
130 
131         if (verbose) {
132             dataLog(&quot;Dominators:\n&quot;);
133             dominators.dump(WTF::dataFile());
134         }
135 
136         m_loops.shrink(0);
137 
138         for (unsigned blockIndex = graph.numNodes(); blockIndex--;) {
139             typename Graph::Node header = graph.node(blockIndex);
140             if (!header)
141                 continue;
142 
143             for (unsigned i = graph.predecessors(header).size(); i--;) {
144                 typename Graph::Node footer = graph.predecessors(header)[i];
145                 if (!dominators.dominates(header, footer))
146                     continue;
147                 // At this point, we&#39;ve proven &#39;header&#39; is actually a loop header and
148                 // that &#39;footer&#39; is a loop footer.
149                 bool found = false;
</pre>
<hr />
<pre>
270     Graph&amp; graph() { return m_graph; }
271 
272     unsigned numLoops() const
273     {
274         return m_loops.size();
275     }
276     const NaturalLoop&lt;Graph&gt;&amp; loop(unsigned i) const
277     {
278         return m_loops[i];
279     }
280 
281     // Return either null if the block isn&#39;t a loop header, or the
282     // loop it belongs to.
283     const NaturalLoop&lt;Graph&gt;* headerOf(typename Graph::Node block) const
284     {
285         const NaturalLoop&lt;Graph&gt;* loop = innerMostLoopOf(block);
286         if (!loop)
287             return nullptr;
288         if (loop-&gt;header() == block)
289             return loop;
<span class="line-modified">290         if (!ASSERT_DISABLED) {</span>
291             for (; loop; loop = innerMostOuterLoop(*loop))
292                 ASSERT(loop-&gt;header() != block);
293         }
294         return nullptr;
295     }
296 
297     const NaturalLoop&lt;Graph&gt;* innerMostLoopOf(typename Graph::Node block) const
298     {
299         unsigned index = m_innerMostLoopIndices[block][0];
300         if (index == UINT_MAX)
301             return nullptr;
302         return &amp;m_loops[index];
303     }
304 
305     const NaturalLoop&lt;Graph&gt;* innerMostOuterLoop(const NaturalLoop&lt;Graph&gt;&amp; loop) const
306     {
307         if (loop.m_outerLoopIndex == UINT_MAX)
308             return nullptr;
309         return &amp;m_loops[loop.m_outerLoopIndex];
310     }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
109 };
110 
111 template&lt;typename Graph&gt;
112 class NaturalLoops {
113     WTF_MAKE_FAST_ALLOCATED;
114 public:
115     typedef std::array&lt;unsigned, 2&gt; InnerMostLoopIndices;
116 
117     NaturalLoops(Graph&amp; graph, Dominators&lt;Graph&gt;&amp; dominators, bool selfCheck = false)
118         : m_graph(graph)
119         , m_innerMostLoopIndices(graph.template newMap&lt;InnerMostLoopIndices&gt;())
120     {
121         // Implement the classic dominator-based natural loop finder. The first
122         // step is to find all control flow edges A -&gt; B where B dominates A.
123         // Then B is a loop header and A is a backward branching block. We will
124         // then accumulate, for each loop header, multiple backward branching
125         // blocks. Then we backwards graph search from the backward branching
126         // blocks to their loop headers, which gives us all of the blocks in the
127         // loop body.
128 
<span class="line-modified">129         static constexpr bool verbose = false;</span>
130 
131         if (verbose) {
132             dataLog(&quot;Dominators:\n&quot;);
133             dominators.dump(WTF::dataFile());
134         }
135 
136         m_loops.shrink(0);
137 
138         for (unsigned blockIndex = graph.numNodes(); blockIndex--;) {
139             typename Graph::Node header = graph.node(blockIndex);
140             if (!header)
141                 continue;
142 
143             for (unsigned i = graph.predecessors(header).size(); i--;) {
144                 typename Graph::Node footer = graph.predecessors(header)[i];
145                 if (!dominators.dominates(header, footer))
146                     continue;
147                 // At this point, we&#39;ve proven &#39;header&#39; is actually a loop header and
148                 // that &#39;footer&#39; is a loop footer.
149                 bool found = false;
</pre>
<hr />
<pre>
270     Graph&amp; graph() { return m_graph; }
271 
272     unsigned numLoops() const
273     {
274         return m_loops.size();
275     }
276     const NaturalLoop&lt;Graph&gt;&amp; loop(unsigned i) const
277     {
278         return m_loops[i];
279     }
280 
281     // Return either null if the block isn&#39;t a loop header, or the
282     // loop it belongs to.
283     const NaturalLoop&lt;Graph&gt;* headerOf(typename Graph::Node block) const
284     {
285         const NaturalLoop&lt;Graph&gt;* loop = innerMostLoopOf(block);
286         if (!loop)
287             return nullptr;
288         if (loop-&gt;header() == block)
289             return loop;
<span class="line-modified">290         if (ASSERT_ENABLED) {</span>
291             for (; loop; loop = innerMostOuterLoop(*loop))
292                 ASSERT(loop-&gt;header() != block);
293         }
294         return nullptr;
295     }
296 
297     const NaturalLoop&lt;Graph&gt;* innerMostLoopOf(typename Graph::Node block) const
298     {
299         unsigned index = m_innerMostLoopIndices[block][0];
300         if (index == UINT_MAX)
301             return nullptr;
302         return &amp;m_loops[index];
303     }
304 
305     const NaturalLoop&lt;Graph&gt;* innerMostOuterLoop(const NaturalLoop&lt;Graph&gt;&amp; loop) const
306     {
307         if (loop.m_outerLoopIndex == UINT_MAX)
308             return nullptr;
309         return &amp;m_loops[loop.m_outerLoopIndex];
310     }
</pre>
</td>
</tr>
</table>
<center><a href="MonotonicTime.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="NeverDestroyed.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
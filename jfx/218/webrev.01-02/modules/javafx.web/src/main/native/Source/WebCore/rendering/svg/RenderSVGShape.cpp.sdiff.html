<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGShape.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderSVGResourcePattern.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderSVGShape.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGShape.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 62     {
 63         SVGRenderSupport::applyStrokeStyleToContext(context, m_renderer.style(), m_renderer);
 64     }
 65 
 66 private:
 67     const RenderSVGShape&amp; m_renderer;
 68 };
 69 
 70 RenderSVGShape::RenderSVGShape(SVGGraphicsElement&amp; element, RenderStyle&amp;&amp; style)
 71     : RenderSVGModelObject(element, WTFMove(style))
 72     , m_needsBoundariesUpdate(false) // Default is false, the cached rects are empty from the beginning.
 73     , m_needsShapeUpdate(true) // Default is true, so we grab a Path object once from SVGGraphicsElement.
 74     , m_needsTransformUpdate(true) // Default is true, so we grab a AffineTransform object once from SVGGraphicsElement.
 75 {
 76 }
 77 
 78 RenderSVGShape::~RenderSVGShape() = default;
 79 
 80 void RenderSVGShape::updateShapeFromElement()
 81 {
<span class="line-modified"> 82     m_path = makeUnique&lt;Path&gt;(pathFromGraphicsElement(&amp;graphicsElement()));</span>
 83     processMarkerPositions();
 84 
 85     m_fillBoundingBox = calculateObjectBoundingBox();
 86     m_strokeBoundingBox = calculateStrokeBoundingBox();
 87 }
 88 
 89 bool RenderSVGShape::isEmpty() const
 90 {
 91     // This function should never be called before assigning a new Path to m_path.
 92     // But this bug can happen if this renderer was created and its layout was not
 93     // done before painting. Assert this did not happen but do not crash.
 94     ASSERT(hasPath());
 95     return !hasPath() || path().isEmpty();
 96 }
 97 
 98 void RenderSVGShape::fillShape(GraphicsContext&amp; context) const
 99 {
100     context.fillPath(path());
101 }
102 
103 void RenderSVGShape::strokeShape(GraphicsContext&amp; context) const
104 {
105     ASSERT(m_path);
106     Path* usePath = m_path.get();
107 
108     if (hasNonScalingStroke())
109         usePath = nonScalingStrokePath(usePath, nonScalingStrokeTransform());
110 
111     context.strokePath(*usePath);
112 }
113 
114 bool RenderSVGShape::shapeDependentStrokeContains(const FloatPoint&amp; point, PointCoordinateSpace pointCoordinateSpace)
115 {
116     ASSERT(m_path);
117     BoundingRectStrokeStyleApplier applier(*this);
118 
119     if (hasNonScalingStroke() &amp;&amp; pointCoordinateSpace != LocalCoordinateSpace) {
120         AffineTransform nonScalingTransform = nonScalingStrokeTransform();
121         Path* usePath = nonScalingStrokePath(m_path.get(), nonScalingTransform);
122 
<span class="line-modified">123         return usePath-&gt;strokeContains(&amp;applier, nonScalingTransform.mapPoint(point));</span>
124     }
125 
<span class="line-modified">126     return m_path-&gt;strokeContains(&amp;applier, point);</span>
127 }
128 
129 bool RenderSVGShape::shapeDependentFillContains(const FloatPoint&amp; point, const WindRule fillRule) const
130 {
131     return path().contains(point, fillRule);
132 }
133 
134 bool RenderSVGShape::fillContains(const FloatPoint&amp; point, bool requiresFill, const WindRule fillRule)
135 {
<span class="line-modified">136     if (!m_fillBoundingBox.contains(point))</span>
137         return false;
138 
139     Color fallbackColor;
140     if (requiresFill &amp;&amp; !RenderSVGResource::fillPaintingResource(*this, style(), fallbackColor))
141         return false;
142 
143     return shapeDependentFillContains(point, fillRule);
144 }
145 
146 bool RenderSVGShape::strokeContains(const FloatPoint&amp; point, bool requiresStroke)
147 {
<span class="line-modified">148     if (!strokeBoundingBox().contains(point))</span>
149         return false;
150 
151     Color fallbackColor;
152     if (requiresStroke &amp;&amp; !RenderSVGResource::strokePaintingResource(*this, style(), fallbackColor))
153         return false;
154 
155     return shapeDependentStrokeContains(point);
156 }
157 
158 void RenderSVGShape::layout()
159 {
160     StackStats::LayoutCheckPoint layoutCheckPoint;
161     LayoutRepainter repainter(*this, SVGRenderSupport::checkForSVGRepaintDuringLayout(*this) &amp;&amp; selfNeedsLayout());
162 
163     bool updateCachedBoundariesInParents = false;
164 
165     if (m_needsShapeUpdate || m_needsBoundariesUpdate) {
166         updateShapeFromElement();
167         m_needsShapeUpdate = false;
168         updateRepaintBoundingBox();
</pre>
<hr />
<pre>
330     LayoutRect rect = LayoutRect(repaintRectInLocalCoordinates());
331     if (!rect.isEmpty())
332         rects.append(rect);
333 }
334 
335 bool RenderSVGShape::isPointInFill(const FloatPoint&amp; point)
336 {
337     return shapeDependentFillContains(point, style().svgStyle().fillRule());
338 }
339 
340 bool RenderSVGShape::isPointInStroke(const FloatPoint&amp; point)
341 {
342     if (!style().svgStyle().hasStroke())
343         return false;
344 
345     return shapeDependentStrokeContains(point, LocalCoordinateSpace);
346 }
347 
348 float RenderSVGShape::getTotalLength() const
349 {
<span class="line-modified">350     if (m_path)</span>
<span class="line-removed">351         return m_path-&gt;length();</span>
<span class="line-removed">352 </span>
<span class="line-removed">353     return 0;</span>
354 }
355 
<span class="line-modified">356 void RenderSVGShape::getPointAtLength(FloatPoint&amp; point, float distance) const</span>
357 {
<span class="line-modified">358     if (!m_path)</span>
<span class="line-removed">359         return;</span>
<span class="line-removed">360 </span>
<span class="line-removed">361     bool isValid;</span>
<span class="line-removed">362     point = m_path-&gt;pointAtLength(distance, isValid);</span>
363 }
364 
365 bool RenderSVGShape::nodeAtFloatPoint(const HitTestRequest&amp; request, HitTestResult&amp; result, const FloatPoint&amp; pointInParent, HitTestAction hitTestAction)
366 {
367     // We only draw in the forground phase, so we only hit-test then.
368     if (hitTestAction != HitTestForeground)
369         return false;
370 
371     FloatPoint localPoint = m_localTransform.inverse().valueOr(AffineTransform()).mapPoint(pointInParent);
372 
373     if (!SVGRenderSupport::pointInClippingArea(*this, localPoint))
374         return false;
375 
376     PointerEventsHitRules hitRules(PointerEventsHitRules::SVG_PATH_HITTESTING, request, style().pointerEvents());
377     bool isVisible = (style().visibility() == Visibility::Visible);
378     if (isVisible || !hitRules.requireVisible) {
379         const SVGRenderStyle&amp; svgStyle = style().svgStyle();
380         WindRule fillRule = svgStyle.fillRule();
381         if (request.svgClipContent())
382             fillRule = svgStyle.clipRule();
383         if ((hitRules.canHitStroke &amp;&amp; (svgStyle.hasStroke() || !hitRules.requireStroke) &amp;&amp; strokeContains(localPoint, hitRules.requireStroke))
<span class="line-modified">384             || (hitRules.canHitFill &amp;&amp; (svgStyle.hasFill() || !hitRules.requireFill) &amp;&amp; fillContains(localPoint, hitRules.requireFill, fillRule))) {</span>

385             updateHitTestResult(result, LayoutPoint(localPoint));
386             if (result.addNodeToListBasedTestResult(&amp;graphicsElement(), request, localPoint) == HitTestProgress::Stop)
387                 return true;
388         }
389     }
390     return false;
391 }
392 
393 static inline RenderSVGResourceMarker* markerForType(SVGMarkerType type, RenderSVGResourceMarker* markerStart, RenderSVGResourceMarker* markerMid, RenderSVGResourceMarker* markerEnd)
394 {
395     switch (type) {
396     case StartMarker:
397         return markerStart;
398     case MidMarker:
399         return markerMid;
400     case EndMarker:
401         return markerEnd;
402     }
403 
404     ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
485     ASSERT(!m_markerPositions.isEmpty());
486 
487     auto* resources = SVGResourcesCache::cachedResourcesForRenderer(*this);
488     if (!resources)
489         return;
490 
491     RenderSVGResourceMarker* markerStart = resources-&gt;markerStart();
492     RenderSVGResourceMarker* markerMid = resources-&gt;markerMid();
493     RenderSVGResourceMarker* markerEnd = resources-&gt;markerEnd();
494     if (!markerStart &amp;&amp; !markerMid &amp;&amp; !markerEnd)
495         return;
496 
497     float strokeWidth = this-&gt;strokeWidth();
498     unsigned size = m_markerPositions.size();
499     for (unsigned i = 0; i &lt; size; ++i) {
500         if (RenderSVGResourceMarker* marker = markerForType(m_markerPositions[i].type, markerStart, markerMid, markerEnd))
501             marker-&gt;draw(paintInfo, marker-&gt;markerTransformation(m_markerPositions[i].origin, m_markerPositions[i].angle, strokeWidth));
502     }
503 }
504 





505 void RenderSVGShape::processMarkerPositions()
506 {
507     m_markerPositions.clear();
508 
509     if (!shouldGenerateMarkerPositions())
510         return;
511 
512     ASSERT(m_path);
513 
514     SVGMarkerData markerData(m_markerPositions, SVGResourcesCache::cachedResourcesForRenderer(*this)-&gt;markerReverseStart());
515     m_path-&gt;apply([&amp;markerData](const PathElement&amp; pathElement) {
516         SVGMarkerData::updateFromPathElement(markerData, pathElement);
517     });
518     markerData.pathIsDone();
519 }
520 
521 }
</pre>
</td>
<td>
<hr />
<pre>
 62     {
 63         SVGRenderSupport::applyStrokeStyleToContext(context, m_renderer.style(), m_renderer);
 64     }
 65 
 66 private:
 67     const RenderSVGShape&amp; m_renderer;
 68 };
 69 
 70 RenderSVGShape::RenderSVGShape(SVGGraphicsElement&amp; element, RenderStyle&amp;&amp; style)
 71     : RenderSVGModelObject(element, WTFMove(style))
 72     , m_needsBoundariesUpdate(false) // Default is false, the cached rects are empty from the beginning.
 73     , m_needsShapeUpdate(true) // Default is true, so we grab a Path object once from SVGGraphicsElement.
 74     , m_needsTransformUpdate(true) // Default is true, so we grab a AffineTransform object once from SVGGraphicsElement.
 75 {
 76 }
 77 
 78 RenderSVGShape::~RenderSVGShape() = default;
 79 
 80 void RenderSVGShape::updateShapeFromElement()
 81 {
<span class="line-modified"> 82     m_path = createPath();</span>
 83     processMarkerPositions();
 84 
 85     m_fillBoundingBox = calculateObjectBoundingBox();
 86     m_strokeBoundingBox = calculateStrokeBoundingBox();
 87 }
 88 
 89 bool RenderSVGShape::isEmpty() const
 90 {
 91     // This function should never be called before assigning a new Path to m_path.
 92     // But this bug can happen if this renderer was created and its layout was not
 93     // done before painting. Assert this did not happen but do not crash.
 94     ASSERT(hasPath());
 95     return !hasPath() || path().isEmpty();
 96 }
 97 
 98 void RenderSVGShape::fillShape(GraphicsContext&amp; context) const
 99 {
100     context.fillPath(path());
101 }
102 
103 void RenderSVGShape::strokeShape(GraphicsContext&amp; context) const
104 {
105     ASSERT(m_path);
106     Path* usePath = m_path.get();
107 
108     if (hasNonScalingStroke())
109         usePath = nonScalingStrokePath(usePath, nonScalingStrokeTransform());
110 
111     context.strokePath(*usePath);
112 }
113 
114 bool RenderSVGShape::shapeDependentStrokeContains(const FloatPoint&amp; point, PointCoordinateSpace pointCoordinateSpace)
115 {
116     ASSERT(m_path);
117     BoundingRectStrokeStyleApplier applier(*this);
118 
119     if (hasNonScalingStroke() &amp;&amp; pointCoordinateSpace != LocalCoordinateSpace) {
120         AffineTransform nonScalingTransform = nonScalingStrokeTransform();
121         Path* usePath = nonScalingStrokePath(m_path.get(), nonScalingTransform);
122 
<span class="line-modified">123         return usePath-&gt;strokeContains(applier, nonScalingTransform.mapPoint(point));</span>
124     }
125 
<span class="line-modified">126     return m_path-&gt;strokeContains(applier, point);</span>
127 }
128 
129 bool RenderSVGShape::shapeDependentFillContains(const FloatPoint&amp; point, const WindRule fillRule) const
130 {
131     return path().contains(point, fillRule);
132 }
133 
134 bool RenderSVGShape::fillContains(const FloatPoint&amp; point, bool requiresFill, const WindRule fillRule)
135 {
<span class="line-modified">136     if (m_fillBoundingBox.isEmpty() || !m_fillBoundingBox.contains(point))</span>
137         return false;
138 
139     Color fallbackColor;
140     if (requiresFill &amp;&amp; !RenderSVGResource::fillPaintingResource(*this, style(), fallbackColor))
141         return false;
142 
143     return shapeDependentFillContains(point, fillRule);
144 }
145 
146 bool RenderSVGShape::strokeContains(const FloatPoint&amp; point, bool requiresStroke)
147 {
<span class="line-modified">148     if (strokeBoundingBox().isEmpty() || !strokeBoundingBox().contains(point))</span>
149         return false;
150 
151     Color fallbackColor;
152     if (requiresStroke &amp;&amp; !RenderSVGResource::strokePaintingResource(*this, style(), fallbackColor))
153         return false;
154 
155     return shapeDependentStrokeContains(point);
156 }
157 
158 void RenderSVGShape::layout()
159 {
160     StackStats::LayoutCheckPoint layoutCheckPoint;
161     LayoutRepainter repainter(*this, SVGRenderSupport::checkForSVGRepaintDuringLayout(*this) &amp;&amp; selfNeedsLayout());
162 
163     bool updateCachedBoundariesInParents = false;
164 
165     if (m_needsShapeUpdate || m_needsBoundariesUpdate) {
166         updateShapeFromElement();
167         m_needsShapeUpdate = false;
168         updateRepaintBoundingBox();
</pre>
<hr />
<pre>
330     LayoutRect rect = LayoutRect(repaintRectInLocalCoordinates());
331     if (!rect.isEmpty())
332         rects.append(rect);
333 }
334 
335 bool RenderSVGShape::isPointInFill(const FloatPoint&amp; point)
336 {
337     return shapeDependentFillContains(point, style().svgStyle().fillRule());
338 }
339 
340 bool RenderSVGShape::isPointInStroke(const FloatPoint&amp; point)
341 {
342     if (!style().svgStyle().hasStroke())
343         return false;
344 
345     return shapeDependentStrokeContains(point, LocalCoordinateSpace);
346 }
347 
348 float RenderSVGShape::getTotalLength() const
349 {
<span class="line-modified">350     return hasPath() ? path().length() : createPath()-&gt;length();</span>



351 }
352 
<span class="line-modified">353 FloatPoint RenderSVGShape::getPointAtLength(float distance) const</span>
354 {
<span class="line-modified">355     return hasPath() ? path().pointAtLength(distance) : createPath()-&gt;pointAtLength(distance);</span>




356 }
357 
358 bool RenderSVGShape::nodeAtFloatPoint(const HitTestRequest&amp; request, HitTestResult&amp; result, const FloatPoint&amp; pointInParent, HitTestAction hitTestAction)
359 {
360     // We only draw in the forground phase, so we only hit-test then.
361     if (hitTestAction != HitTestForeground)
362         return false;
363 
364     FloatPoint localPoint = m_localTransform.inverse().valueOr(AffineTransform()).mapPoint(pointInParent);
365 
366     if (!SVGRenderSupport::pointInClippingArea(*this, localPoint))
367         return false;
368 
369     PointerEventsHitRules hitRules(PointerEventsHitRules::SVG_PATH_HITTESTING, request, style().pointerEvents());
370     bool isVisible = (style().visibility() == Visibility::Visible);
371     if (isVisible || !hitRules.requireVisible) {
372         const SVGRenderStyle&amp; svgStyle = style().svgStyle();
373         WindRule fillRule = svgStyle.fillRule();
374         if (request.svgClipContent())
375             fillRule = svgStyle.clipRule();
376         if ((hitRules.canHitStroke &amp;&amp; (svgStyle.hasStroke() || !hitRules.requireStroke) &amp;&amp; strokeContains(localPoint, hitRules.requireStroke))
<span class="line-modified">377             || (hitRules.canHitFill &amp;&amp; (svgStyle.hasFill() || !hitRules.requireFill) &amp;&amp; fillContains(localPoint, hitRules.requireFill, fillRule))</span>
<span class="line-added">378             || (hitRules.canHitBoundingBox &amp;&amp; objectBoundingBox().contains(localPoint))) {</span>
379             updateHitTestResult(result, LayoutPoint(localPoint));
380             if (result.addNodeToListBasedTestResult(&amp;graphicsElement(), request, localPoint) == HitTestProgress::Stop)
381                 return true;
382         }
383     }
384     return false;
385 }
386 
387 static inline RenderSVGResourceMarker* markerForType(SVGMarkerType type, RenderSVGResourceMarker* markerStart, RenderSVGResourceMarker* markerMid, RenderSVGResourceMarker* markerEnd)
388 {
389     switch (type) {
390     case StartMarker:
391         return markerStart;
392     case MidMarker:
393         return markerMid;
394     case EndMarker:
395         return markerEnd;
396     }
397 
398     ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
479     ASSERT(!m_markerPositions.isEmpty());
480 
481     auto* resources = SVGResourcesCache::cachedResourcesForRenderer(*this);
482     if (!resources)
483         return;
484 
485     RenderSVGResourceMarker* markerStart = resources-&gt;markerStart();
486     RenderSVGResourceMarker* markerMid = resources-&gt;markerMid();
487     RenderSVGResourceMarker* markerEnd = resources-&gt;markerEnd();
488     if (!markerStart &amp;&amp; !markerMid &amp;&amp; !markerEnd)
489         return;
490 
491     float strokeWidth = this-&gt;strokeWidth();
492     unsigned size = m_markerPositions.size();
493     for (unsigned i = 0; i &lt; size; ++i) {
494         if (RenderSVGResourceMarker* marker = markerForType(m_markerPositions[i].type, markerStart, markerMid, markerEnd))
495             marker-&gt;draw(paintInfo, marker-&gt;markerTransformation(m_markerPositions[i].origin, m_markerPositions[i].angle, strokeWidth));
496     }
497 }
498 
<span class="line-added">499 std::unique_ptr&lt;Path&gt; RenderSVGShape::createPath() const</span>
<span class="line-added">500 {</span>
<span class="line-added">501     return makeUnique&lt;Path&gt;(pathFromGraphicsElement(&amp;graphicsElement()));</span>
<span class="line-added">502 }</span>
<span class="line-added">503 </span>
504 void RenderSVGShape::processMarkerPositions()
505 {
506     m_markerPositions.clear();
507 
508     if (!shouldGenerateMarkerPositions())
509         return;
510 
511     ASSERT(m_path);
512 
513     SVGMarkerData markerData(m_markerPositions, SVGResourcesCache::cachedResourcesForRenderer(*this)-&gt;markerReverseStart());
514     m_path-&gt;apply([&amp;markerData](const PathElement&amp; pathElement) {
515         SVGMarkerData::updateFromPathElement(markerData, pathElement);
516     });
517     markerData.pathIsDone();
518 }
519 
520 }
</pre>
</td>
</tr>
</table>
<center><a href="RenderSVGResourcePattern.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderSVGShape.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
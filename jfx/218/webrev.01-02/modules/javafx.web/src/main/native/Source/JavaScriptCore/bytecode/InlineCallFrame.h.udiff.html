<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/InlineCallFrame.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InlineCallFrame.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InstanceOfAccessCase.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/InlineCallFrame.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -35,11 +35,11 @@</span>
  #include &lt;wtf/Vector.h&gt;
  
  namespace JSC {
  
  struct InlineCallFrame;
<span class="udiff-line-modified-removed">- class ExecState;</span>
<span class="udiff-line-modified-added">+ class CallFrame;</span>
  class JSFunction;
  
  struct InlineCallFrame {
      enum Kind {
          Call,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -177,11 +177,12 @@</span>
  
      Vector&lt;ValueRecovery&gt; argumentsWithFixup; // Includes &#39;this&#39; and arity fixups.
      WriteBarrier&lt;CodeBlock&gt; baselineCodeBlock;
      CodeOrigin directCaller;
  
<span class="udiff-line-modified-removed">-     unsigned argumentCountIncludingThis { 0 }; // Do not include fixups.</span>
<span class="udiff-line-modified-added">+     unsigned argumentCountIncludingThis : 22; // Do not include fixups.</span>
<span class="udiff-line-added">+     unsigned tmpOffset : 10;</span>
      signed stackOffset : 28;
      unsigned kind : 3; // real type is Kind
      bool isClosureCall : 1; // If false then we know that callee/scope are constants and the DFG won&#39;t treat them as variables, i.e. they have to be recovered manually.
      VirtualRegister argumentCountRegister; // Only set when we inline a varargs call.
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -189,11 +190,13 @@</span>
  
      // There is really no good notion of a &quot;default&quot; set of values for
      // InlineCallFrame&#39;s fields. This constructor is here just to reduce confusion if
      // we forgot to initialize explicitly.
      InlineCallFrame()
<span class="udiff-line-modified-removed">-         : stackOffset(0)</span>
<span class="udiff-line-modified-added">+         : argumentCountIncludingThis(0)</span>
<span class="udiff-line-added">+         , tmpOffset(0)</span>
<span class="udiff-line-added">+         , stackOffset(0)</span>
          , kind(Call)
          , isClosureCall(false)
      {
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -205,11 +208,11 @@</span>
      CodeSpecializationKind specializationKind() const { return specializationKindFor(static_cast&lt;Kind&gt;(kind)); }
  
      JSFunction* calleeConstant() const;
  
      // Get the callee given a machine call frame to which this InlineCallFrame belongs.
<span class="udiff-line-modified-removed">-     JSFunction* calleeForCallFrame(ExecState*) const;</span>
<span class="udiff-line-modified-added">+     JSFunction* calleeForCallFrame(CallFrame*) const;</span>
  
      CString inferredName() const;
      CodeBlockHash hash() const;
      CString hashAsStringIfPossible() const;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -217,10 +220,16 @@</span>
      {
          stackOffset = offset;
          RELEASE_ASSERT(static_cast&lt;signed&gt;(stackOffset) == offset);
      }
  
<span class="udiff-line-added">+     void setTmpOffset(unsigned offset)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+         tmpOffset = offset;</span>
<span class="udiff-line-added">+         RELEASE_ASSERT(static_cast&lt;unsigned&gt;(tmpOffset) == offset);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      ptrdiff_t callerFrameOffset() const { return stackOffset * sizeof(Register) + CallFrame::callerFrameOffset(); }
      ptrdiff_t returnPCOffset() const { return stackOffset * sizeof(Register) + CallFrame::returnPCOffset(); }
  
      bool isStrictMode() const { return baselineCodeBlock-&gt;isStrictMode(); }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -238,20 +247,20 @@</span>
      return inlineCallFrame-&gt;baselineCodeBlock.get();
  }
  
  inline CodeBlock* baselineCodeBlockForOriginAndBaselineCodeBlock(const CodeOrigin&amp; codeOrigin, CodeBlock* baselineCodeBlock)
  {
<span class="udiff-line-modified-removed">-     ASSERT(baselineCodeBlock-&gt;jitType() == JITType::BaselineJIT);</span>
<span class="udiff-line-modified-added">+     ASSERT(JITCode::isBaselineCode(baselineCodeBlock-&gt;jitType()));</span>
      auto* inlineCallFrame = codeOrigin.inlineCallFrame();
      if (inlineCallFrame)
          return baselineCodeBlockForInlineCallFrame(inlineCallFrame);
      return baselineCodeBlock;
  }
  
<span class="udiff-line-modified-removed">- // This function is defined here and not in CodeOrigin because it needs access to the directCaller field in InlineCallFrame</span>
<span class="udiff-line-modified-added">+ // These function is defined here and not in CodeOrigin because it needs access to the directCaller field in InlineCallFrame</span>
  template &lt;typename Function&gt;
<span class="udiff-line-modified-removed">- inline void CodeOrigin::walkUpInlineStack(const Function&amp; function)</span>
<span class="udiff-line-modified-added">+ inline void CodeOrigin::walkUpInlineStack(const Function&amp; function) const</span>
  {
      CodeOrigin codeOrigin = *this;
      while (true) {
          function(codeOrigin);
          auto* inlineCallFrame = codeOrigin.inlineCallFrame();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -259,15 +268,42 @@</span>
              break;
          codeOrigin = inlineCallFrame-&gt;directCaller;
      }
  }
  
<span class="udiff-line-modified-removed">- ALWAYS_INLINE VirtualRegister remapOperand(InlineCallFrame* inlineCallFrame, VirtualRegister reg)</span>
<span class="udiff-line-modified-added">+ inline bool CodeOrigin::inlineStackContainsActiveCheckpoint() const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     bool result = false;</span>
<span class="udiff-line-added">+     walkUpInlineStack([&amp;] (CodeOrigin origin) {</span>
<span class="udiff-line-added">+         if (origin.bytecodeIndex().checkpoint())</span>
<span class="udiff-line-added">+             result = true;</span>
<span class="udiff-line-added">+     });</span>
<span class="udiff-line-added">+     return result;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ ALWAYS_INLINE Operand remapOperand(InlineCallFrame* inlineCallFrame, Operand operand)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (inlineCallFrame)</span>
<span class="udiff-line-added">+         return operand.isTmp() ? Operand::tmp(operand.value() + inlineCallFrame-&gt;tmpOffset) : operand.virtualRegister() + inlineCallFrame-&gt;stackOffset;</span>
<span class="udiff-line-added">+     return operand;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ ALWAYS_INLINE Operand remapOperand(InlineCallFrame* inlineCallFrame, VirtualRegister reg)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return remapOperand(inlineCallFrame, Operand(reg));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ ALWAYS_INLINE Operand unmapOperand(InlineCallFrame* inlineCallFrame, Operand operand)</span>
  {
      if (inlineCallFrame)
<span class="udiff-line-modified-removed">-         return VirtualRegister(reg.offset() + inlineCallFrame-&gt;stackOffset);</span>
<span class="udiff-line-modified-removed">-     return reg;</span>
<span class="udiff-line-modified-added">+         return operand.isTmp() ? Operand::tmp(operand.value() - inlineCallFrame-&gt;tmpOffset) : Operand(operand.virtualRegister() - inlineCallFrame-&gt;stackOffset);</span>
<span class="udiff-line-modified-added">+     return operand;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ ALWAYS_INLINE Operand unmapOperand(InlineCallFrame* inlineCallFrame, VirtualRegister reg)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return unmapOperand(inlineCallFrame, Operand(reg));</span>
  }
  
  } // namespace JSC
  
  namespace WTF {
</pre>
<center><a href="InlineCallFrame.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InstanceOfAccessCase.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityRenderObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AccessibilityObjectInterface.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityRenderObject.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityRenderObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 116 #ifndef NDEBUG
 117     m_renderer-&gt;setHasAXObject(true);
 118 #endif
 119 }
 120 
 121 AccessibilityRenderObject::~AccessibilityRenderObject()
 122 {
 123     ASSERT(isDetached());
 124 }
 125 
 126 void AccessibilityRenderObject::init()
 127 {
 128     AccessibilityNodeObject::init();
 129 }
 130 
 131 Ref&lt;AccessibilityRenderObject&gt; AccessibilityRenderObject::create(RenderObject* renderer)
 132 {
 133     return adoptRef(*new AccessibilityRenderObject(renderer));
 134 }
 135 
<span class="line-modified"> 136 void AccessibilityRenderObject::detach(AccessibilityDetachmentType detachmentType, AXObjectCache* cache)</span>
 137 {
<span class="line-modified"> 138     AccessibilityNodeObject::detach(detachmentType, cache);</span>
 139 
 140     detachRemoteSVGRoot();
 141 
 142 #ifndef NDEBUG
 143     if (m_renderer)
 144         m_renderer-&gt;setHasAXObject(false);
 145 #endif
 146     m_renderer = nullptr;
 147 }
 148 
 149 RenderBoxModelObject* AccessibilityRenderObject::renderBoxModelObject() const
 150 {
 151     if (!is&lt;RenderBoxModelObject&gt;(renderer()))
 152         return nullptr;
 153     return downcast&lt;RenderBoxModelObject&gt;(renderer());
 154 }
 155 
 156 void AccessibilityRenderObject::setRenderer(RenderObject* renderer)
 157 {
 158     m_renderer = makeWeakPtr(renderer);
</pre>
<hr />
<pre>
 959     URL documentURL = m_renderer-&gt;document().url();
 960     if (!equalIgnoringFragmentIdentifier(documentURL, linkURL))
 961         return nullptr;
 962 
 963     Node* linkedNode = m_renderer-&gt;document().findAnchor(fragmentIdentifier);
 964     if (!linkedNode)
 965         return nullptr;
 966 
 967     // The element we find may not be accessible, so find the first accessible object.
 968     return firstAccessibleObjectFromNode(linkedNode);
 969 }
 970 
 971 OptionSet&lt;SpeakAs&gt; AccessibilityRenderObject::speakAsProperty() const
 972 {
 973     if (!m_renderer)
 974         return AccessibilityObject::speakAsProperty();
 975 
 976     return m_renderer-&gt;style().speakAs();
 977 }
 978 
<span class="line-modified"> 979 void AccessibilityRenderObject::addRadioButtonGroupChildren(AccessibilityObject* parent, AccessibilityChildrenVector&amp; linkedUIElements) const</span>
 980 {
 981     for (const auto&amp; child : parent-&gt;children()) {
 982         if (child-&gt;roleValue() == AccessibilityRole::RadioButton)
 983             linkedUIElements.append(child);
 984         else
 985             addRadioButtonGroupChildren(child.get(), linkedUIElements);
 986     }
 987 }
 988 
 989 void AccessibilityRenderObject::addRadioButtonGroupMembers(AccessibilityChildrenVector&amp; linkedUIElements) const
 990 {
 991     if (roleValue() != AccessibilityRole::RadioButton)
 992         return;
 993 
 994     Node* node = this-&gt;node();
 995     if (is&lt;HTMLInputElement&gt;(node)) {
 996         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
 997         for (auto&amp; radioSibling : input.radioButtonGroup()) {
<span class="line-modified"> 998             if (AccessibilityObject* object = axObjectCache()-&gt;getOrCreate(radioSibling))</span>
 999                 linkedUIElements.append(object);
1000         }
1001     } else {
1002         // If we didn&#39;t find any radio button siblings with the traditional naming, lets search for a radio group role and find its children.
1003         for (AccessibilityObject* parent = parentObject(); parent; parent = parent-&gt;parentObject()) {
1004             if (parent-&gt;roleValue() == AccessibilityRole::RadioGroup)
1005                 addRadioButtonGroupChildren(parent, linkedUIElements);
1006         }
1007     }
1008 }
1009 
1010 // linked ui elements could be all the related radio buttons in a group
1011 // or an internal anchor connection
1012 void AccessibilityRenderObject::linkedUIElements(AccessibilityChildrenVector&amp; linkedUIElements) const
1013 {
1014     ariaFlowToElements(linkedUIElements);
1015 
1016     if (isLink()) {
1017         AccessibilityObject* linkedAXElement = internalLinkElement();
1018         if (linkedAXElement)
1019             linkedUIElements.append(linkedAXElement);
1020     }
1021 
1022     if (roleValue() == AccessibilityRole::RadioButton)
1023         addRadioButtonGroupMembers(linkedUIElements);
1024 }
1025 
1026 bool AccessibilityRenderObject::hasTextAlternative() const
1027 {
1028     // ARIA: section 2A, bullet #3 says if aria-labeledby or aria-label appears, it should
1029     // override the &quot;label&quot; element association.
1030     return ariaAccessibilityDescription().length();
1031 }
1032 
1033 bool AccessibilityRenderObject::hasPopup() const
1034 {
1035     // Return true if this has the aria-haspopup attribute, or if it has an ancestor of type link with the aria-haspopup attribute.
<span class="line-modified">1036     return AccessibilityObject::matchedParent(*this, true, [this] (const AccessibilityObject&amp; object) {</span>
1037         return (this == &amp;object) ? !equalLettersIgnoringASCIICase(object.popupValue(), &quot;false&quot;)
1038             : object.isLink() &amp;&amp; !equalLettersIgnoringASCIICase(object.popupValue(), &quot;false&quot;);
1039     });
1040 }
1041 
1042 bool AccessibilityRenderObject::supportsARIADropping() const
1043 {
1044     const AtomString&amp; dropEffect = getAttribute(aria_dropeffectAttr);
1045     return !dropEffect.isEmpty();
1046 }
1047 
1048 bool AccessibilityRenderObject::supportsARIADragging() const
1049 {
1050     const AtomString&amp; grabbed = getAttribute(aria_grabbedAttr);
1051     return equalLettersIgnoringASCIICase(grabbed, &quot;true&quot;) || equalLettersIgnoringASCIICase(grabbed, &quot;false&quot;);
1052 }
1053 
1054 bool AccessibilityRenderObject::isARIAGrabbed()
1055 {
1056     return elementAttributeValue(aria_grabbedAttr);
</pre>
<hr />
<pre>
1264     if (!isAllowedChildOfTree())
1265         return true;
1266 
1267     // Allow the platform to decide if the attachment is ignored or not.
1268     if (isAttachment())
1269         return accessibilityIgnoreAttachment();
1270 
1271     // ignore popup menu items because AppKit does
1272     if (m_renderer &amp;&amp; ancestorsOfType&lt;RenderMenuList&gt;(*m_renderer).first())
1273         return true;
1274 
1275     // https://webkit.org/b/161276 Getting the controlObject might cause the m_renderer to be nullptr.
1276     if (!m_renderer)
1277         return true;
1278 
1279     if (m_renderer-&gt;isBR())
1280         return true;
1281 
1282     if (is&lt;RenderText&gt;(*m_renderer)) {
1283         // static text beneath MenuItems and MenuButtons are just reported along with the menu item, so it&#39;s ignored on an individual level
<span class="line-modified">1284         AccessibilityObject* parent = parentObjectUnignored();</span>
1285         if (parent &amp;&amp; (parent-&gt;isMenuItem() || parent-&gt;ariaRoleAttribute() == AccessibilityRole::MenuButton))
1286             return true;
1287         auto&amp; renderText = downcast&lt;RenderText&gt;(*m_renderer);
1288         if (!renderText.hasRenderedText())
1289             return true;
1290 
1291         if (renderText.parent()-&gt;isFirstLetter())
1292             return true;
1293 
1294         // static text beneath TextControls is reported along with the text control text so it&#39;s ignored.
1295         for (AccessibilityObject* parent = parentObject(); parent; parent = parent-&gt;parentObject()) {
1296             if (parent-&gt;roleValue() == AccessibilityRole::TextField)
1297                 return true;
1298         }
1299 
1300         // Walking up the parent chain might reset the m_renderer.
1301         if (!m_renderer)
1302             return true;
1303 
1304         // The alt attribute may be set on a text fragment through CSS, which should be honored.
</pre>
<hr />
<pre>
1416                 LayoutSize imageSize = image.cachedImage()-&gt;imageSizeForRenderer(&amp;image, image.view().zoomFactor());
1417                 return imageSize.height() &lt;= 1 || imageSize.width() &lt;= 1;
1418             }
1419         }
1420         return false;
1421     }
1422 
1423     if (isCanvas()) {
1424         if (canvasHasFallbackContent())
1425             return false;
1426 
1427         if (is&lt;RenderBox&gt;(*m_renderer)) {
1428             auto&amp; canvasBox = downcast&lt;RenderBox&gt;(*m_renderer);
1429             if (canvasBox.height() &lt;= 1 || canvasBox.width() &lt;= 1)
1430                 return true;
1431         }
1432         // Otherwise fall through; use presence of help text, title, or description to decide.
1433     }
1434 
1435     if (m_renderer-&gt;isListMarker()) {
<span class="line-modified">1436         AccessibilityObject* parent = parentObjectUnignored();</span>
1437         return parent &amp;&amp; !parent-&gt;isListItem();
1438     }
1439 
1440     if (isWebArea())
1441         return false;
1442 
1443 #if ENABLE(METER_ELEMENT)
1444     // The render tree of meter includes a RenderBlock (meter) and a RenderMeter (div).
1445     // We expose the latter and thus should ignore the former. However, if the author
1446     // includes a title attribute on the element, hasAttributesRequiredForInclusion()
1447     // will return true, potentially resulting in a redundant accessible object.
1448     if (is&lt;HTMLMeterElement&gt;(node))
1449         return true;
1450 #endif
1451 
1452     // Using the presence of an accessible name to decide an element&#39;s visibility is not
1453     // as definitive as previous checks, so this should remain as one of the last.
1454     if (hasAttributesRequiredForInclusion())
1455         return false;
1456 
</pre>
<hr />
<pre>
1553     int end = indexForVisiblePosition(visibleSelection.end());
1554 
1555     return PlainTextRange(start, end - start);
1556 }
1557 
1558 String AccessibilityRenderObject::selectedText() const
1559 {
1560     ASSERT(isTextControl());
1561 
1562     if (isPasswordField())
1563         return String(); // need to return something distinct from empty string
1564 
1565     if (isNativeTextControl()) {
1566         HTMLTextFormControlElement&amp; textControl = downcast&lt;RenderTextControl&gt;(*m_renderer).textFormControlElement();
1567         return textControl.selectedText();
1568     }
1569 
1570     return doAXStringForRange(documentBasedSelectedTextRange());
1571 }
1572 
<span class="line-modified">1573 const AtomString&amp; AccessibilityRenderObject::accessKey() const</span>
1574 {
1575     Node* node = m_renderer-&gt;node();
1576     if (!is&lt;Element&gt;(node))
1577         return nullAtom();
1578     return downcast&lt;Element&gt;(*node).attributeWithoutSynchronization(accesskeyAttr);
1579 }
1580 
1581 VisibleSelection AccessibilityRenderObject::selection() const
1582 {
1583     return m_renderer-&gt;frame().selection().selection();
1584 }
1585 
1586 PlainTextRange AccessibilityRenderObject::selectedTextRange() const
1587 {
1588     ASSERT(isTextControl());
1589 
1590     if (isPasswordField())
1591         return PlainTextRange();
1592 
1593     AccessibilityRole ariaRole = ariaRoleAttribute();
</pre>
<hr />
<pre>
2353     return elementText.substring(range.start, range.length);
2354 }
2355 
2356 // The bounding rectangle of the text associated with this accessibility object that is
2357 // specified by the given range. This is the bounding rectangle a sighted user would see
2358 // on the display screen, in pixels.
2359 IntRect AccessibilityRenderObject::doAXBoundsForRange(const PlainTextRange&amp; range) const
2360 {
2361     if (allowsTextRanges())
2362         return boundsForVisiblePositionRange(visiblePositionRangeForRange(range));
2363     return IntRect();
2364 }
2365 
2366 IntRect AccessibilityRenderObject::doAXBoundsForRangeUsingCharacterOffset(const PlainTextRange&amp; range) const
2367 {
2368     if (allowsTextRanges())
2369         return boundsForRange(rangeForPlainTextRange(range));
2370     return IntRect();
2371 }
2372 
<span class="line-modified">2373 AccessibilityObject* AccessibilityRenderObject::accessibilityImageMapHitTest(HTMLAreaElement* area, const IntPoint&amp; point) const</span>
2374 {
2375     if (!area)
2376         return nullptr;
2377 
2378     AccessibilityObject* parent = nullptr;
2379     for (Element* mapParent = area-&gt;parentElement(); mapParent; mapParent = mapParent-&gt;parentElement()) {
2380         if (is&lt;HTMLMapElement&gt;(*mapParent)) {
2381             parent = accessibilityParentForImageMap(downcast&lt;HTMLMapElement&gt;(mapParent));
2382             break;
2383         }
2384     }
2385     if (!parent)
2386         return nullptr;
2387 
2388     for (const auto&amp; child : parent-&gt;children()) {
2389         if (child-&gt;elementRect().contains(point))
2390             return child.get();
2391     }
2392 
2393     return nullptr;
2394 }
2395 
<span class="line-modified">2396 AccessibilityObjectInterface* AccessibilityRenderObject::remoteSVGElementHitTest(const IntPoint&amp; point) const</span>
2397 {
2398     AccessibilityObject* remote = remoteSVGRootElement(Create);
2399     if (!remote)
2400         return nullptr;
2401 
2402     IntSize offset = point - roundedIntPoint(boundingBoxRect().location());
2403     return remote-&gt;accessibilityHitTest(IntPoint(offset));
2404 }
2405 
<span class="line-modified">2406 AccessibilityObjectInterface* AccessibilityRenderObject::elementAccessibilityHitTest(const IntPoint&amp; point) const</span>
2407 {
2408     if (isSVGImage())
2409         return remoteSVGElementHitTest(point);
2410 
2411     return AccessibilityObject::elementAccessibilityHitTest(point);
2412 }
2413 
2414 static bool shouldUseShadowHostForHitTesting(Node* shadowHost)
2415 {
2416     // We need to allow automation of mouse events on video tags.
2417     return shadowHost &amp;&amp; !shadowHost-&gt;hasTagName(videoTag);
2418 }
2419 
<span class="line-modified">2420 AccessibilityObjectInterface* AccessibilityRenderObject::accessibilityHitTest(const IntPoint&amp; point) const</span>
2421 {
2422     if (!m_renderer || !m_renderer-&gt;hasLayer())
2423         return nullptr;
2424 
2425     m_renderer-&gt;document().updateLayout();
2426 
2427     if (!m_renderer || !m_renderer-&gt;hasLayer())
2428         return nullptr;
2429 
2430     RenderLayer* layer = downcast&lt;RenderBox&gt;(*m_renderer).layer();
2431 
2432     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::AccessibilityHitTest);
2433     HitTestResult hitTestResult = HitTestResult(point);
2434     layer-&gt;hitTest(request, hitTestResult);
2435     Node* node = hitTestResult.innerNode();
2436     if (!node)
2437         return nullptr;
2438     Node* shadowAncestorNode = node-&gt;shadowHost();
2439     if (shouldUseShadowHostForHitTesting(shadowAncestorNode))
2440         node = shadowAncestorNode;
2441     ASSERT(node);
2442 
2443     if (is&lt;HTMLAreaElement&gt;(*node))
2444         return accessibilityImageMapHitTest(downcast&lt;HTMLAreaElement&gt;(node), point);
2445 
2446     if (is&lt;HTMLOptionElement&gt;(*node))
2447         node = downcast&lt;HTMLOptionElement&gt;(*node).ownerSelectElement();
2448 
2449     RenderObject* obj = node-&gt;renderer();
2450     if (!obj)
2451         return nullptr;
2452 
<span class="line-modified">2453     AccessibilityObject* result = obj-&gt;document().axObjectCache()-&gt;getOrCreate(obj);</span>
2454     result-&gt;updateChildrenIfNecessary();
2455 
2456     // Allow the element to perform any hit-testing it might need to do to reach non-render children.
2457     result = static_cast&lt;AccessibilityObject*&gt;(result-&gt;elementAccessibilityHitTest(point));
2458 
2459     if (result &amp;&amp; result-&gt;accessibilityIsIgnored()) {
2460         // If this element is the label of a control, a hit test should return the control.
<span class="line-modified">2461         AccessibilityObject* controlObject = result-&gt;correspondingControlForLabelElement();</span>
2462         if (controlObject &amp;&amp; !controlObject-&gt;exposesTitleUIElement())
2463             return controlObject;
2464 
2465         result = result-&gt;parentObjectUnignored();
2466     }
2467 
2468     return result;
2469 }
2470 
2471 bool AccessibilityRenderObject::shouldNotifyActiveDescendant() const
2472 {
2473 #if USE(ATK)
2474     // According to the Core AAM spec, ATK expects object:state-changed:focused notifications
2475     // whenever the active descendant changes.
2476     return true;
2477 #endif
2478     // We want to notify that the combo box has changed its active descendant,
2479     // but we do not want to change the focus, because focus should remain with the combo box.
2480     if (isComboBox())
2481         return true;
</pre>
<hr />
<pre>
3119 {
3120     RenderBoxModelObject* cssBox = renderBoxModelObject();
3121     if (!is&lt;RenderImage&gt;(cssBox))
3122         return;
3123 
3124     HTMLMapElement* map = downcast&lt;RenderImage&gt;(*cssBox).imageMap();
3125     if (!map)
3126         return;
3127 
3128     for (auto&amp; area : descendantsOfType&lt;HTMLAreaElement&gt;(*map)) {
3129         // add an &lt;area&gt; element for this child if it has a link
3130         if (!area.isLink())
3131             continue;
3132         auto&amp; areaObject = downcast&lt;AccessibilityImageMapLink&gt;(*axObjectCache()-&gt;getOrCreate(AccessibilityRole::ImageMapLink));
3133         areaObject.setHTMLAreaElement(&amp;area);
3134         areaObject.setHTMLMapElement(map);
3135         areaObject.setParent(this);
3136         if (!areaObject.accessibilityIsIgnored())
3137             m_children.append(&amp;areaObject);
3138         else
<span class="line-modified">3139             axObjectCache()-&gt;remove(areaObject.axObjectID());</span>
3140     }
3141 }
3142 
3143 void AccessibilityRenderObject::updateChildrenIfNecessary()
3144 {
3145     if (needsToUpdateChildren())
3146         clearChildren();
3147 
3148     AccessibilityObject::updateChildrenIfNecessary();
3149 }
3150 
3151 void AccessibilityRenderObject::addTextFieldChildren()
3152 {
3153     Node* node = this-&gt;node();
3154     if (!is&lt;HTMLInputElement&gt;(node))
3155         return;
3156 
3157     HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
3158     if (HTMLElement* autoFillElement = input.autoFillButtonElement()) {
3159         if (AccessibilityObject* axAutoFill = axObjectCache()-&gt;getOrCreate(autoFillElement))
</pre>
<hr />
<pre>
3291 
3292     // First do a quick run through to determine if we have any hidden nodes (most often we will not).
3293     // If we do have hidden nodes, we need to determine where to insert them so they match DOM order as close as possible.
3294     bool shouldInsertHiddenNodes = false;
3295     for (Node* child = node-&gt;firstChild(); child; child = child-&gt;nextSibling()) {
3296         if (!child-&gt;renderer() &amp;&amp; isNodeAriaVisible(child)) {
3297             shouldInsertHiddenNodes = true;
3298             break;
3299         }
3300     }
3301 
3302     if (!shouldInsertHiddenNodes)
3303         return;
3304 
3305     // Iterate through all of the children, including those that may have already been added, and
3306     // try to insert hidden nodes in the correct place in the DOM order.
3307     unsigned insertionIndex = 0;
3308     for (Node* child = node-&gt;firstChild(); child; child = child-&gt;nextSibling()) {
3309         if (child-&gt;renderer()) {
3310             // Find out where the last render sibling is located within m_children.
<span class="line-modified">3311             AccessibilityObject* childObject = axObjectCache()-&gt;get(child-&gt;renderer());</span>
3312             if (childObject &amp;&amp; childObject-&gt;accessibilityIsIgnored()) {
3313                 auto&amp; children = childObject-&gt;children();
3314                 if (children.size())
3315                     childObject = children.last().get();
3316                 else
3317                     childObject = nullptr;
3318             }
3319 
3320             if (childObject)
3321                 insertionIndex = m_children.find(childObject) + 1;
3322             continue;
3323         }
3324 
3325         if (!isNodeAriaVisible(child))
3326             continue;
3327 
3328         unsigned previousSize = m_children.size();
3329         if (insertionIndex &gt; previousSize)
3330             insertionIndex = previousSize;
3331 
</pre>
<hr />
<pre>
3508 }
3509 
3510 void AccessibilityRenderObject::selectedChildren(AccessibilityChildrenVector&amp; result)
3511 {
3512     ASSERT(result.isEmpty());
3513 
3514     if (!canHaveSelectedChildren())
3515         return;
3516 
3517     switch (roleValue()) {
3518     case AccessibilityRole::ListBox:
3519         // native list boxes would be AccessibilityListBoxes, so only check for aria list boxes
3520         ariaListboxSelectedChildren(result);
3521         return;
3522     case AccessibilityRole::Grid:
3523     case AccessibilityRole::Tree:
3524     case AccessibilityRole::TreeGrid:
3525         ariaSelectedRows(result);
3526         return;
3527     case AccessibilityRole::TabList:
<span class="line-modified">3528         if (AccessibilityObject* selectedTab = selectedTabItem())</span>
3529             result.append(selectedTab);
3530         return;
3531     case AccessibilityRole::List:
3532         if (auto* selectedListItemChild = selectedListItem())
3533             result.append(selectedListItemChild);
3534         return;
3535     case AccessibilityRole::Menu:
3536     case AccessibilityRole::MenuBar:
3537         if (AccessibilityObject* descendant = activeDescendant()) {
3538             result.append(descendant);
3539             return;
3540         }
3541         if (AccessibilityObject* focusedElement = static_cast&lt;AccessibilityObject*&gt;(focusedUIElement())) {
3542             result.append(focusedElement);
3543             return;
3544         }
3545         return;
3546     default:
3547         ASSERT_NOT_REACHED();
3548     }
3549 }
3550 
3551 void AccessibilityRenderObject::ariaListboxVisibleChildren(AccessibilityChildrenVector&amp; result)
3552 {
3553     if (!hasChildren())
3554         addChildren();
3555 
3556     for (const auto&amp; child : children()) {
3557         if (child-&gt;isOffScreen())
3558             result.append(child);
3559     }
3560 }
3561 
3562 void AccessibilityRenderObject::visibleChildren(AccessibilityChildrenVector&amp; result)
3563 {
3564     ASSERT(result.isEmpty());
3565 
<span class="line-modified">3566     // only listboxes are asked for their visible children.</span>
<span class="line-modified">3567     if (ariaRoleAttribute() != AccessibilityRole::ListBox) {</span>
<span class="line-modified">3568         // native list boxes would be AccessibilityListBoxes, so only check for aria list boxes</span>
<span class="line-removed">3569         ASSERT_NOT_REACHED();</span>
3570         return;
<span class="line-removed">3571     }</span>
3572     return ariaListboxVisibleChildren(result);
3573 }
3574 
3575 void AccessibilityRenderObject::tabChildren(AccessibilityChildrenVector&amp; result)
3576 {
<span class="line-modified">3577     ASSERT(roleValue() == AccessibilityRole::TabList);</span>

3578 
3579     for (const auto&amp; child : children()) {
3580         if (child-&gt;isTabItem())
3581             result.append(child);
3582     }
3583 }
3584 
<span class="line-modified">3585 const String&amp; AccessibilityRenderObject::actionVerb() const</span>
3586 {
3587 #if !PLATFORM(IOS_FAMILY)
3588     // FIXME: Need to add verbs for select elements.
3589     static NeverDestroyed&lt;const String&gt; buttonAction(AXButtonActionVerb());
3590     static NeverDestroyed&lt;const String&gt; textFieldAction(AXTextFieldActionVerb());
3591     static NeverDestroyed&lt;const String&gt; radioButtonAction(AXRadioButtonActionVerb());
3592     static NeverDestroyed&lt;const String&gt; checkedCheckBoxAction(AXUncheckedCheckBoxActionVerb());
3593     static NeverDestroyed&lt;const String&gt; uncheckedCheckBoxAction(AXUncheckedCheckBoxActionVerb());
3594     static NeverDestroyed&lt;const String&gt; linkAction(AXLinkActionVerb());
3595 
3596     switch (roleValue()) {
3597     case AccessibilityRole::Button:
3598     case AccessibilityRole::ToggleButton:
3599         return buttonAction;
3600     case AccessibilityRole::TextField:
3601     case AccessibilityRole::TextArea:
3602         return textFieldAction;
3603     case AccessibilityRole::RadioButton:
3604         return radioButtonAction;
3605     case AccessibilityRole::CheckBox:
</pre>
</td>
<td>
<hr />
<pre>
 116 #ifndef NDEBUG
 117     m_renderer-&gt;setHasAXObject(true);
 118 #endif
 119 }
 120 
 121 AccessibilityRenderObject::~AccessibilityRenderObject()
 122 {
 123     ASSERT(isDetached());
 124 }
 125 
 126 void AccessibilityRenderObject::init()
 127 {
 128     AccessibilityNodeObject::init();
 129 }
 130 
 131 Ref&lt;AccessibilityRenderObject&gt; AccessibilityRenderObject::create(RenderObject* renderer)
 132 {
 133     return adoptRef(*new AccessibilityRenderObject(renderer));
 134 }
 135 
<span class="line-modified"> 136 void AccessibilityRenderObject::detachRemoteParts(AccessibilityDetachmentType detachmentType)</span>
 137 {
<span class="line-modified"> 138     AccessibilityNodeObject::detachRemoteParts(detachmentType);</span>
 139 
 140     detachRemoteSVGRoot();
 141 
 142 #ifndef NDEBUG
 143     if (m_renderer)
 144         m_renderer-&gt;setHasAXObject(false);
 145 #endif
 146     m_renderer = nullptr;
 147 }
 148 
 149 RenderBoxModelObject* AccessibilityRenderObject::renderBoxModelObject() const
 150 {
 151     if (!is&lt;RenderBoxModelObject&gt;(renderer()))
 152         return nullptr;
 153     return downcast&lt;RenderBoxModelObject&gt;(renderer());
 154 }
 155 
 156 void AccessibilityRenderObject::setRenderer(RenderObject* renderer)
 157 {
 158     m_renderer = makeWeakPtr(renderer);
</pre>
<hr />
<pre>
 959     URL documentURL = m_renderer-&gt;document().url();
 960     if (!equalIgnoringFragmentIdentifier(documentURL, linkURL))
 961         return nullptr;
 962 
 963     Node* linkedNode = m_renderer-&gt;document().findAnchor(fragmentIdentifier);
 964     if (!linkedNode)
 965         return nullptr;
 966 
 967     // The element we find may not be accessible, so find the first accessible object.
 968     return firstAccessibleObjectFromNode(linkedNode);
 969 }
 970 
 971 OptionSet&lt;SpeakAs&gt; AccessibilityRenderObject::speakAsProperty() const
 972 {
 973     if (!m_renderer)
 974         return AccessibilityObject::speakAsProperty();
 975 
 976     return m_renderer-&gt;style().speakAs();
 977 }
 978 
<span class="line-modified"> 979 void AccessibilityRenderObject::addRadioButtonGroupChildren(AXCoreObject* parent, AccessibilityChildrenVector&amp; linkedUIElements) const</span>
 980 {
 981     for (const auto&amp; child : parent-&gt;children()) {
 982         if (child-&gt;roleValue() == AccessibilityRole::RadioButton)
 983             linkedUIElements.append(child);
 984         else
 985             addRadioButtonGroupChildren(child.get(), linkedUIElements);
 986     }
 987 }
 988 
 989 void AccessibilityRenderObject::addRadioButtonGroupMembers(AccessibilityChildrenVector&amp; linkedUIElements) const
 990 {
 991     if (roleValue() != AccessibilityRole::RadioButton)
 992         return;
 993 
 994     Node* node = this-&gt;node();
 995     if (is&lt;HTMLInputElement&gt;(node)) {
 996         HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
 997         for (auto&amp; radioSibling : input.radioButtonGroup()) {
<span class="line-modified"> 998             if (AccessibilityObject* object = axObjectCache()-&gt;getOrCreate(radioSibling.ptr()))</span>
 999                 linkedUIElements.append(object);
1000         }
1001     } else {
1002         // If we didn&#39;t find any radio button siblings with the traditional naming, lets search for a radio group role and find its children.
1003         for (AccessibilityObject* parent = parentObject(); parent; parent = parent-&gt;parentObject()) {
1004             if (parent-&gt;roleValue() == AccessibilityRole::RadioGroup)
1005                 addRadioButtonGroupChildren(parent, linkedUIElements);
1006         }
1007     }
1008 }
1009 
1010 // linked ui elements could be all the related radio buttons in a group
1011 // or an internal anchor connection
1012 void AccessibilityRenderObject::linkedUIElements(AccessibilityChildrenVector&amp; linkedUIElements) const
1013 {
1014     ariaFlowToElements(linkedUIElements);
1015 
1016     if (isLink()) {
1017         AccessibilityObject* linkedAXElement = internalLinkElement();
1018         if (linkedAXElement)
1019             linkedUIElements.append(linkedAXElement);
1020     }
1021 
1022     if (roleValue() == AccessibilityRole::RadioButton)
1023         addRadioButtonGroupMembers(linkedUIElements);
1024 }
1025 
1026 bool AccessibilityRenderObject::hasTextAlternative() const
1027 {
1028     // ARIA: section 2A, bullet #3 says if aria-labeledby or aria-label appears, it should
1029     // override the &quot;label&quot; element association.
1030     return ariaAccessibilityDescription().length();
1031 }
1032 
1033 bool AccessibilityRenderObject::hasPopup() const
1034 {
1035     // Return true if this has the aria-haspopup attribute, or if it has an ancestor of type link with the aria-haspopup attribute.
<span class="line-modified">1036     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, true, [this] (const AccessibilityObject&amp; object) {</span>
1037         return (this == &amp;object) ? !equalLettersIgnoringASCIICase(object.popupValue(), &quot;false&quot;)
1038             : object.isLink() &amp;&amp; !equalLettersIgnoringASCIICase(object.popupValue(), &quot;false&quot;);
1039     });
1040 }
1041 
1042 bool AccessibilityRenderObject::supportsARIADropping() const
1043 {
1044     const AtomString&amp; dropEffect = getAttribute(aria_dropeffectAttr);
1045     return !dropEffect.isEmpty();
1046 }
1047 
1048 bool AccessibilityRenderObject::supportsARIADragging() const
1049 {
1050     const AtomString&amp; grabbed = getAttribute(aria_grabbedAttr);
1051     return equalLettersIgnoringASCIICase(grabbed, &quot;true&quot;) || equalLettersIgnoringASCIICase(grabbed, &quot;false&quot;);
1052 }
1053 
1054 bool AccessibilityRenderObject::isARIAGrabbed()
1055 {
1056     return elementAttributeValue(aria_grabbedAttr);
</pre>
<hr />
<pre>
1264     if (!isAllowedChildOfTree())
1265         return true;
1266 
1267     // Allow the platform to decide if the attachment is ignored or not.
1268     if (isAttachment())
1269         return accessibilityIgnoreAttachment();
1270 
1271     // ignore popup menu items because AppKit does
1272     if (m_renderer &amp;&amp; ancestorsOfType&lt;RenderMenuList&gt;(*m_renderer).first())
1273         return true;
1274 
1275     // https://webkit.org/b/161276 Getting the controlObject might cause the m_renderer to be nullptr.
1276     if (!m_renderer)
1277         return true;
1278 
1279     if (m_renderer-&gt;isBR())
1280         return true;
1281 
1282     if (is&lt;RenderText&gt;(*m_renderer)) {
1283         // static text beneath MenuItems and MenuButtons are just reported along with the menu item, so it&#39;s ignored on an individual level
<span class="line-modified">1284         AXCoreObject* parent = parentObjectUnignored();</span>
1285         if (parent &amp;&amp; (parent-&gt;isMenuItem() || parent-&gt;ariaRoleAttribute() == AccessibilityRole::MenuButton))
1286             return true;
1287         auto&amp; renderText = downcast&lt;RenderText&gt;(*m_renderer);
1288         if (!renderText.hasRenderedText())
1289             return true;
1290 
1291         if (renderText.parent()-&gt;isFirstLetter())
1292             return true;
1293 
1294         // static text beneath TextControls is reported along with the text control text so it&#39;s ignored.
1295         for (AccessibilityObject* parent = parentObject(); parent; parent = parent-&gt;parentObject()) {
1296             if (parent-&gt;roleValue() == AccessibilityRole::TextField)
1297                 return true;
1298         }
1299 
1300         // Walking up the parent chain might reset the m_renderer.
1301         if (!m_renderer)
1302             return true;
1303 
1304         // The alt attribute may be set on a text fragment through CSS, which should be honored.
</pre>
<hr />
<pre>
1416                 LayoutSize imageSize = image.cachedImage()-&gt;imageSizeForRenderer(&amp;image, image.view().zoomFactor());
1417                 return imageSize.height() &lt;= 1 || imageSize.width() &lt;= 1;
1418             }
1419         }
1420         return false;
1421     }
1422 
1423     if (isCanvas()) {
1424         if (canvasHasFallbackContent())
1425             return false;
1426 
1427         if (is&lt;RenderBox&gt;(*m_renderer)) {
1428             auto&amp; canvasBox = downcast&lt;RenderBox&gt;(*m_renderer);
1429             if (canvasBox.height() &lt;= 1 || canvasBox.width() &lt;= 1)
1430                 return true;
1431         }
1432         // Otherwise fall through; use presence of help text, title, or description to decide.
1433     }
1434 
1435     if (m_renderer-&gt;isListMarker()) {
<span class="line-modified">1436         AXCoreObject* parent = parentObjectUnignored();</span>
1437         return parent &amp;&amp; !parent-&gt;isListItem();
1438     }
1439 
1440     if (isWebArea())
1441         return false;
1442 
1443 #if ENABLE(METER_ELEMENT)
1444     // The render tree of meter includes a RenderBlock (meter) and a RenderMeter (div).
1445     // We expose the latter and thus should ignore the former. However, if the author
1446     // includes a title attribute on the element, hasAttributesRequiredForInclusion()
1447     // will return true, potentially resulting in a redundant accessible object.
1448     if (is&lt;HTMLMeterElement&gt;(node))
1449         return true;
1450 #endif
1451 
1452     // Using the presence of an accessible name to decide an element&#39;s visibility is not
1453     // as definitive as previous checks, so this should remain as one of the last.
1454     if (hasAttributesRequiredForInclusion())
1455         return false;
1456 
</pre>
<hr />
<pre>
1553     int end = indexForVisiblePosition(visibleSelection.end());
1554 
1555     return PlainTextRange(start, end - start);
1556 }
1557 
1558 String AccessibilityRenderObject::selectedText() const
1559 {
1560     ASSERT(isTextControl());
1561 
1562     if (isPasswordField())
1563         return String(); // need to return something distinct from empty string
1564 
1565     if (isNativeTextControl()) {
1566         HTMLTextFormControlElement&amp; textControl = downcast&lt;RenderTextControl&gt;(*m_renderer).textFormControlElement();
1567         return textControl.selectedText();
1568     }
1569 
1570     return doAXStringForRange(documentBasedSelectedTextRange());
1571 }
1572 
<span class="line-modified">1573 String AccessibilityRenderObject::accessKey() const</span>
1574 {
1575     Node* node = m_renderer-&gt;node();
1576     if (!is&lt;Element&gt;(node))
1577         return nullAtom();
1578     return downcast&lt;Element&gt;(*node).attributeWithoutSynchronization(accesskeyAttr);
1579 }
1580 
1581 VisibleSelection AccessibilityRenderObject::selection() const
1582 {
1583     return m_renderer-&gt;frame().selection().selection();
1584 }
1585 
1586 PlainTextRange AccessibilityRenderObject::selectedTextRange() const
1587 {
1588     ASSERT(isTextControl());
1589 
1590     if (isPasswordField())
1591         return PlainTextRange();
1592 
1593     AccessibilityRole ariaRole = ariaRoleAttribute();
</pre>
<hr />
<pre>
2353     return elementText.substring(range.start, range.length);
2354 }
2355 
2356 // The bounding rectangle of the text associated with this accessibility object that is
2357 // specified by the given range. This is the bounding rectangle a sighted user would see
2358 // on the display screen, in pixels.
2359 IntRect AccessibilityRenderObject::doAXBoundsForRange(const PlainTextRange&amp; range) const
2360 {
2361     if (allowsTextRanges())
2362         return boundsForVisiblePositionRange(visiblePositionRangeForRange(range));
2363     return IntRect();
2364 }
2365 
2366 IntRect AccessibilityRenderObject::doAXBoundsForRangeUsingCharacterOffset(const PlainTextRange&amp; range) const
2367 {
2368     if (allowsTextRanges())
2369         return boundsForRange(rangeForPlainTextRange(range));
2370     return IntRect();
2371 }
2372 
<span class="line-modified">2373 AXCoreObject* AccessibilityRenderObject::accessibilityImageMapHitTest(HTMLAreaElement* area, const IntPoint&amp; point) const</span>
2374 {
2375     if (!area)
2376         return nullptr;
2377 
2378     AccessibilityObject* parent = nullptr;
2379     for (Element* mapParent = area-&gt;parentElement(); mapParent; mapParent = mapParent-&gt;parentElement()) {
2380         if (is&lt;HTMLMapElement&gt;(*mapParent)) {
2381             parent = accessibilityParentForImageMap(downcast&lt;HTMLMapElement&gt;(mapParent));
2382             break;
2383         }
2384     }
2385     if (!parent)
2386         return nullptr;
2387 
2388     for (const auto&amp; child : parent-&gt;children()) {
2389         if (child-&gt;elementRect().contains(point))
2390             return child.get();
2391     }
2392 
2393     return nullptr;
2394 }
2395 
<span class="line-modified">2396 AXCoreObject* AccessibilityRenderObject::remoteSVGElementHitTest(const IntPoint&amp; point) const</span>
2397 {
2398     AccessibilityObject* remote = remoteSVGRootElement(Create);
2399     if (!remote)
2400         return nullptr;
2401 
2402     IntSize offset = point - roundedIntPoint(boundingBoxRect().location());
2403     return remote-&gt;accessibilityHitTest(IntPoint(offset));
2404 }
2405 
<span class="line-modified">2406 AXCoreObject* AccessibilityRenderObject::elementAccessibilityHitTest(const IntPoint&amp; point) const</span>
2407 {
2408     if (isSVGImage())
2409         return remoteSVGElementHitTest(point);
2410 
2411     return AccessibilityObject::elementAccessibilityHitTest(point);
2412 }
2413 
2414 static bool shouldUseShadowHostForHitTesting(Node* shadowHost)
2415 {
2416     // We need to allow automation of mouse events on video tags.
2417     return shadowHost &amp;&amp; !shadowHost-&gt;hasTagName(videoTag);
2418 }
2419 
<span class="line-modified">2420 AXCoreObject* AccessibilityRenderObject::accessibilityHitTest(const IntPoint&amp; point) const</span>
2421 {
2422     if (!m_renderer || !m_renderer-&gt;hasLayer())
2423         return nullptr;
2424 
2425     m_renderer-&gt;document().updateLayout();
2426 
2427     if (!m_renderer || !m_renderer-&gt;hasLayer())
2428         return nullptr;
2429 
2430     RenderLayer* layer = downcast&lt;RenderBox&gt;(*m_renderer).layer();
2431 
2432     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::AccessibilityHitTest);
2433     HitTestResult hitTestResult = HitTestResult(point);
2434     layer-&gt;hitTest(request, hitTestResult);
2435     Node* node = hitTestResult.innerNode();
2436     if (!node)
2437         return nullptr;
2438     Node* shadowAncestorNode = node-&gt;shadowHost();
2439     if (shouldUseShadowHostForHitTesting(shadowAncestorNode))
2440         node = shadowAncestorNode;
2441     ASSERT(node);
2442 
2443     if (is&lt;HTMLAreaElement&gt;(*node))
2444         return accessibilityImageMapHitTest(downcast&lt;HTMLAreaElement&gt;(node), point);
2445 
2446     if (is&lt;HTMLOptionElement&gt;(*node))
2447         node = downcast&lt;HTMLOptionElement&gt;(*node).ownerSelectElement();
2448 
2449     RenderObject* obj = node-&gt;renderer();
2450     if (!obj)
2451         return nullptr;
2452 
<span class="line-modified">2453     AXCoreObject* result = obj-&gt;document().axObjectCache()-&gt;getOrCreate(obj);</span>
2454     result-&gt;updateChildrenIfNecessary();
2455 
2456     // Allow the element to perform any hit-testing it might need to do to reach non-render children.
2457     result = static_cast&lt;AccessibilityObject*&gt;(result-&gt;elementAccessibilityHitTest(point));
2458 
2459     if (result &amp;&amp; result-&gt;accessibilityIsIgnored()) {
2460         // If this element is the label of a control, a hit test should return the control.
<span class="line-modified">2461         AXCoreObject* controlObject = result-&gt;correspondingControlForLabelElement();</span>
2462         if (controlObject &amp;&amp; !controlObject-&gt;exposesTitleUIElement())
2463             return controlObject;
2464 
2465         result = result-&gt;parentObjectUnignored();
2466     }
2467 
2468     return result;
2469 }
2470 
2471 bool AccessibilityRenderObject::shouldNotifyActiveDescendant() const
2472 {
2473 #if USE(ATK)
2474     // According to the Core AAM spec, ATK expects object:state-changed:focused notifications
2475     // whenever the active descendant changes.
2476     return true;
2477 #endif
2478     // We want to notify that the combo box has changed its active descendant,
2479     // but we do not want to change the focus, because focus should remain with the combo box.
2480     if (isComboBox())
2481         return true;
</pre>
<hr />
<pre>
3119 {
3120     RenderBoxModelObject* cssBox = renderBoxModelObject();
3121     if (!is&lt;RenderImage&gt;(cssBox))
3122         return;
3123 
3124     HTMLMapElement* map = downcast&lt;RenderImage&gt;(*cssBox).imageMap();
3125     if (!map)
3126         return;
3127 
3128     for (auto&amp; area : descendantsOfType&lt;HTMLAreaElement&gt;(*map)) {
3129         // add an &lt;area&gt; element for this child if it has a link
3130         if (!area.isLink())
3131             continue;
3132         auto&amp; areaObject = downcast&lt;AccessibilityImageMapLink&gt;(*axObjectCache()-&gt;getOrCreate(AccessibilityRole::ImageMapLink));
3133         areaObject.setHTMLAreaElement(&amp;area);
3134         areaObject.setHTMLMapElement(map);
3135         areaObject.setParent(this);
3136         if (!areaObject.accessibilityIsIgnored())
3137             m_children.append(&amp;areaObject);
3138         else
<span class="line-modified">3139             axObjectCache()-&gt;remove(areaObject.objectID());</span>
3140     }
3141 }
3142 
3143 void AccessibilityRenderObject::updateChildrenIfNecessary()
3144 {
3145     if (needsToUpdateChildren())
3146         clearChildren();
3147 
3148     AccessibilityObject::updateChildrenIfNecessary();
3149 }
3150 
3151 void AccessibilityRenderObject::addTextFieldChildren()
3152 {
3153     Node* node = this-&gt;node();
3154     if (!is&lt;HTMLInputElement&gt;(node))
3155         return;
3156 
3157     HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
3158     if (HTMLElement* autoFillElement = input.autoFillButtonElement()) {
3159         if (AccessibilityObject* axAutoFill = axObjectCache()-&gt;getOrCreate(autoFillElement))
</pre>
<hr />
<pre>
3291 
3292     // First do a quick run through to determine if we have any hidden nodes (most often we will not).
3293     // If we do have hidden nodes, we need to determine where to insert them so they match DOM order as close as possible.
3294     bool shouldInsertHiddenNodes = false;
3295     for (Node* child = node-&gt;firstChild(); child; child = child-&gt;nextSibling()) {
3296         if (!child-&gt;renderer() &amp;&amp; isNodeAriaVisible(child)) {
3297             shouldInsertHiddenNodes = true;
3298             break;
3299         }
3300     }
3301 
3302     if (!shouldInsertHiddenNodes)
3303         return;
3304 
3305     // Iterate through all of the children, including those that may have already been added, and
3306     // try to insert hidden nodes in the correct place in the DOM order.
3307     unsigned insertionIndex = 0;
3308     for (Node* child = node-&gt;firstChild(); child; child = child-&gt;nextSibling()) {
3309         if (child-&gt;renderer()) {
3310             // Find out where the last render sibling is located within m_children.
<span class="line-modified">3311             AXCoreObject* childObject = axObjectCache()-&gt;get(child-&gt;renderer());</span>
3312             if (childObject &amp;&amp; childObject-&gt;accessibilityIsIgnored()) {
3313                 auto&amp; children = childObject-&gt;children();
3314                 if (children.size())
3315                     childObject = children.last().get();
3316                 else
3317                     childObject = nullptr;
3318             }
3319 
3320             if (childObject)
3321                 insertionIndex = m_children.find(childObject) + 1;
3322             continue;
3323         }
3324 
3325         if (!isNodeAriaVisible(child))
3326             continue;
3327 
3328         unsigned previousSize = m_children.size();
3329         if (insertionIndex &gt; previousSize)
3330             insertionIndex = previousSize;
3331 
</pre>
<hr />
<pre>
3508 }
3509 
3510 void AccessibilityRenderObject::selectedChildren(AccessibilityChildrenVector&amp; result)
3511 {
3512     ASSERT(result.isEmpty());
3513 
3514     if (!canHaveSelectedChildren())
3515         return;
3516 
3517     switch (roleValue()) {
3518     case AccessibilityRole::ListBox:
3519         // native list boxes would be AccessibilityListBoxes, so only check for aria list boxes
3520         ariaListboxSelectedChildren(result);
3521         return;
3522     case AccessibilityRole::Grid:
3523     case AccessibilityRole::Tree:
3524     case AccessibilityRole::TreeGrid:
3525         ariaSelectedRows(result);
3526         return;
3527     case AccessibilityRole::TabList:
<span class="line-modified">3528         if (AXCoreObject* selectedTab = selectedTabItem())</span>
3529             result.append(selectedTab);
3530         return;
3531     case AccessibilityRole::List:
3532         if (auto* selectedListItemChild = selectedListItem())
3533             result.append(selectedListItemChild);
3534         return;
3535     case AccessibilityRole::Menu:
3536     case AccessibilityRole::MenuBar:
3537         if (AccessibilityObject* descendant = activeDescendant()) {
3538             result.append(descendant);
3539             return;
3540         }
3541         if (AccessibilityObject* focusedElement = static_cast&lt;AccessibilityObject*&gt;(focusedUIElement())) {
3542             result.append(focusedElement);
3543             return;
3544         }
3545         return;
3546     default:
3547         ASSERT_NOT_REACHED();
3548     }
3549 }
3550 
3551 void AccessibilityRenderObject::ariaListboxVisibleChildren(AccessibilityChildrenVector&amp; result)
3552 {
3553     if (!hasChildren())
3554         addChildren();
3555 
3556     for (const auto&amp; child : children()) {
3557         if (child-&gt;isOffScreen())
3558             result.append(child);
3559     }
3560 }
3561 
3562 void AccessibilityRenderObject::visibleChildren(AccessibilityChildrenVector&amp; result)
3563 {
3564     ASSERT(result.isEmpty());
3565 
<span class="line-modified">3566     // Only listboxes are asked for their visible children.</span>
<span class="line-modified">3567     // Native list boxes would be AccessibilityListBoxes, so only check for aria list boxes.</span>
<span class="line-modified">3568     if (ariaRoleAttribute() != AccessibilityRole::ListBox)</span>

3569         return;

3570     return ariaListboxVisibleChildren(result);
3571 }
3572 
3573 void AccessibilityRenderObject::tabChildren(AccessibilityChildrenVector&amp; result)
3574 {
<span class="line-modified">3575     if (roleValue() != AccessibilityRole::TabList)</span>
<span class="line-added">3576         return;</span>
3577 
3578     for (const auto&amp; child : children()) {
3579         if (child-&gt;isTabItem())
3580             result.append(child);
3581     }
3582 }
3583 
<span class="line-modified">3584 String AccessibilityRenderObject::actionVerb() const</span>
3585 {
3586 #if !PLATFORM(IOS_FAMILY)
3587     // FIXME: Need to add verbs for select elements.
3588     static NeverDestroyed&lt;const String&gt; buttonAction(AXButtonActionVerb());
3589     static NeverDestroyed&lt;const String&gt; textFieldAction(AXTextFieldActionVerb());
3590     static NeverDestroyed&lt;const String&gt; radioButtonAction(AXRadioButtonActionVerb());
3591     static NeverDestroyed&lt;const String&gt; checkedCheckBoxAction(AXUncheckedCheckBoxActionVerb());
3592     static NeverDestroyed&lt;const String&gt; uncheckedCheckBoxAction(AXUncheckedCheckBoxActionVerb());
3593     static NeverDestroyed&lt;const String&gt; linkAction(AXLinkActionVerb());
3594 
3595     switch (roleValue()) {
3596     case AccessibilityRole::Button:
3597     case AccessibilityRole::ToggleButton:
3598         return buttonAction;
3599     case AccessibilityRole::TextField:
3600     case AccessibilityRole::TextArea:
3601         return textFieldAction;
3602     case AccessibilityRole::RadioButton:
3603         return radioButtonAction;
3604     case AccessibilityRole::CheckBox:
</pre>
</td>
</tr>
</table>
<center><a href="AccessibilityObjectInterface.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityRenderObject.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
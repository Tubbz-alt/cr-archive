<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/JSToWasm.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JSToWasm.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
 31 #include &quot;CCallHelpers.h&quot;
 32 #include &quot;DisallowMacroScratchRegisterUsage.h&quot;
<a name="1" id="anc1"></a>
 33 #include &quot;JSCInlines.h&quot;
 34 #include &quot;JSWebAssemblyHelpers.h&quot;
 35 #include &quot;JSWebAssemblyInstance.h&quot;
 36 #include &quot;JSWebAssemblyRuntimeError.h&quot;
 37 #include &quot;MaxFrameExtentForSlowPathCall.h&quot;
 38 #include &quot;WasmCallingConvention.h&quot;
 39 #include &quot;WasmContextInlines.h&quot;
<a name="2" id="anc2"></a>
 40 #include &quot;WasmSignatureInlines.h&quot;
 41 #include &quot;WasmToJS.h&quot;
 42 
 43 namespace JSC { namespace Wasm {
 44 
<a name="3" id="anc3"></a><span class="line-modified"> 45 std::unique_ptr&lt;InternalFunction&gt; createJSToWasmWrapper(CompilationContext&amp; compilationContext, const Signature&amp; signature, Vector&lt;UnlinkedWasmToWasmCall&gt;* unlinkedWasmToWasmCalls, const ModuleInformation&amp; info, MemoryMode mode, unsigned functionIndex)</span>
 46 {
<a name="4" id="anc4"></a><span class="line-modified"> 47     CCallHelpers&amp; jit = *compilationContext.embedderEntrypointJIT;</span>














































































 48 
<a name="5" id="anc5"></a>

 49     auto result = makeUnique&lt;InternalFunction&gt;();
 50     jit.emitFunctionPrologue();
 51 
 52     // FIXME Stop using 0 as codeBlocks. https://bugs.webkit.org/show_bug.cgi?id=165321
 53     jit.store64(CCallHelpers::TrustedImm64(0), CCallHelpers::Address(GPRInfo::callFrameRegister, CallFrameSlot::codeBlock * static_cast&lt;int&gt;(sizeof(Register))));
 54     MacroAssembler::DataLabelPtr calleeMoveLocation = jit.moveWithPatch(MacroAssembler::TrustedImmPtr(nullptr), GPRInfo::nonPreservedNonReturnGPR);
 55     jit.storePtr(GPRInfo::nonPreservedNonReturnGPR, CCallHelpers::Address(GPRInfo::callFrameRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register))));
 56     CodeLocationDataLabelPtr&lt;WasmEntryPtrTag&gt;* linkedCalleeMove = &amp;result-&gt;calleeMoveLocation;
 57     jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 58         *linkedCalleeMove = linkBuffer.locationOf&lt;WasmEntryPtrTag&gt;(calleeMoveLocation);
 59     });
 60 
 61     const PinnedRegisterInfo&amp; pinnedRegs = PinnedRegisterInfo::get();
 62     RegisterSet toSave = pinnedRegs.toSave(mode);
 63 
<a name="6" id="anc6"></a><span class="line-modified"> 64 #if !ASSERT_DISABLED</span>
 65     unsigned toSaveSize = toSave.numberOfSetGPRs();
 66     // They should all be callee saves.
 67     toSave.filter(RegisterSet::calleeSaveRegisters());
 68     ASSERT(toSave.numberOfSetGPRs() == toSaveSize);
 69 #endif
 70 
 71     RegisterAtOffsetList registersToSpill(toSave, RegisterAtOffsetList::OffsetBaseType::FramePointerBased);
 72     result-&gt;entrypoint.calleeSaveRegisters = registersToSpill;
 73 
<a name="7" id="anc7"></a><span class="line-modified"> 74     unsigned totalFrameSize = registersToSpill.size() * sizeof(void*);</span>
<span class="line-modified"> 75     totalFrameSize += WasmCallingConvention::headerSizeInBytes();</span>
<span class="line-modified"> 76     totalFrameSize -= sizeof(CallerFrameAndPC);</span>
<span class="line-modified"> 77     unsigned numGPRs = 0;</span>
<span class="line-modified"> 78     unsigned numFPRs = 0;</span>
<span class="line-removed"> 79     bool argumentsIncludeI64 = false;</span>
<span class="line-removed"> 80     for (unsigned i = 0; i &lt; signature.argumentCount(); i++) {</span>
<span class="line-removed"> 81         switch (signature.argument(i)) {</span>
<span class="line-removed"> 82         case Wasm::I64:</span>
<span class="line-removed"> 83             argumentsIncludeI64 = true;</span>
<span class="line-removed"> 84             FALLTHROUGH;</span>
<span class="line-removed"> 85         case Wasm::I32:</span>
<span class="line-removed"> 86         case Wasm::Anyref:</span>
<span class="line-removed"> 87         case Wasm::Funcref:</span>
<span class="line-removed"> 88             if (numGPRs &gt;= wasmCallingConvention().m_gprArgs.size())</span>
<span class="line-removed"> 89                 totalFrameSize += sizeof(void*);</span>
<span class="line-removed"> 90             ++numGPRs;</span>
<span class="line-removed"> 91             break;</span>
<span class="line-removed"> 92         case Wasm::F32:</span>
<span class="line-removed"> 93         case Wasm::F64:</span>
<span class="line-removed"> 94             if (numFPRs &gt;= wasmCallingConvention().m_fprArgs.size())</span>
<span class="line-removed"> 95                 totalFrameSize += sizeof(void*);</span>
<span class="line-removed"> 96             ++numFPRs;</span>
<span class="line-removed"> 97             break;</span>
<span class="line-removed"> 98         default:</span>
<span class="line-removed"> 99             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed">100         }</span>
<span class="line-removed">101     }</span>
102 
103     totalFrameSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), totalFrameSize);
104     jit.subPtr(MacroAssembler::TrustedImm32(totalFrameSize), MacroAssembler::stackPointerRegister);
105 
106     // We save all these registers regardless of having a memory or not.
107     // The reason is that we use one of these as a scratch. That said,
108     // almost all real wasm programs use memory, so it&#39;s not really
109     // worth optimizing for the case that they don&#39;t.
110     for (const RegisterAtOffset&amp; regAtOffset : registersToSpill) {
111         GPRReg reg = regAtOffset.reg().gpr();
112         ptrdiff_t offset = regAtOffset.offset();
113         jit.storePtr(reg, CCallHelpers::Address(GPRInfo::callFrameRegister, offset));
114     }
115 
<a name="8" id="anc8"></a><span class="line-modified">116     if (argumentsIncludeI64 || signature.returnType() == Wasm::I64) {</span>
117         if (Context::useFastTLS())
118             jit.loadWasmContextInstance(GPRInfo::argumentGPR2);
119         else {
120             // vmEntryToWasm passes the JSWebAssemblyInstance corresponding to Wasm::Context*&#39;s
121             // instance as the first JS argument when we&#39;re not using fast TLS to hold the
122             // Wasm::Context*&#39;s instance.
123             jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, CallFrameSlot::thisArgument * sizeof(EncodedJSValue)), GPRInfo::argumentGPR2);
124             jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR2, JSWebAssemblyInstance::offsetOfInstance()), GPRInfo::argumentGPR2);
125         }
126 
<a name="9" id="anc9"></a><span class="line-modified">127         emitThrowWasmToJSException(jit, GPRInfo::argumentGPR2, argumentsIncludeI64 ? ExceptionType::I64ArgumentType : ExceptionType::I64ReturnType);</span>
128         return result;
129     }
130 
131     GPRReg wasmContextInstanceGPR = pinnedRegs.wasmContextInstancePointer;
132 
133     {
<a name="10" id="anc10"></a><span class="line-modified">134         CCallHelpers::Address calleeFrame = CCallHelpers::Address(MacroAssembler::stackPointerRegister, -static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC)));</span>
<span class="line-modified">135         numGPRs = 0;</span>
<span class="line-modified">136         numFPRs = 0;</span>

137         // We&#39;re going to set the pinned registers after this. So
138         // we can use this as a scratch for now since we saved it above.
139         GPRReg scratchReg = pinnedRegs.baseMemoryPointer;
140 
<a name="11" id="anc11"></a><span class="line-removed">141         ptrdiff_t jsOffset = CallFrameSlot::thisArgument * sizeof(EncodedJSValue);</span>
<span class="line-removed">142 </span>
<span class="line-removed">143         // vmEntryToWasm passes the JSWebAssemblyInstance corresponding to Wasm::Context*&#39;s</span>
<span class="line-removed">144         // instance as the first JS argument when we&#39;re not using fast TLS to hold the</span>
<span class="line-removed">145         // Wasm::Context*&#39;s instance.</span>
146         if (!Context::useFastTLS()) {
<a name="12" id="anc12"></a><span class="line-modified">147             jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), wasmContextInstanceGPR);</span>
148             jit.loadPtr(CCallHelpers::Address(wasmContextInstanceGPR, JSWebAssemblyInstance::offsetOfInstance()), wasmContextInstanceGPR);
<a name="13" id="anc13"></a><span class="line-removed">149             jsOffset += sizeof(EncodedJSValue);</span>
150         }
151 
<a name="14" id="anc14"></a><span class="line-removed">152         ptrdiff_t wasmOffset = CallFrame::headerSizeInRegisters * sizeof(void*);</span>
153         for (unsigned i = 0; i &lt; signature.argumentCount(); i++) {
<a name="15" id="anc15"></a><span class="line-modified">154             switch (signature.argument(i)) {</span>
<span class="line-modified">155             case Wasm::I32:</span>
<span class="line-modified">156             case Wasm::I64:</span>
<span class="line-modified">157             case Wasm::Funcref:</span>
<span class="line-modified">158             case Wasm::Anyref:</span>
<span class="line-modified">159                 if (numGPRs &gt;= wasmCallingConvention().m_gprArgs.size()) {</span>
<span class="line-modified">160                     if (signature.argument(i) == Wasm::I32) {</span>
<span class="line-modified">161                         jit.load32(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchReg);</span>
<span class="line-removed">162                         jit.store32(scratchReg, calleeFrame.withOffset(wasmOffset));</span>
<span class="line-removed">163                     } else {</span>
<span class="line-removed">164                         jit.load64(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchReg);</span>
<span class="line-removed">165                         jit.store64(scratchReg, calleeFrame.withOffset(wasmOffset));</span>
<span class="line-removed">166                     }</span>
<span class="line-removed">167                     wasmOffset += sizeof(void*);</span>
<span class="line-removed">168                 } else {</span>
<span class="line-removed">169                     if (signature.argument(i) == Wasm::I32)</span>
<span class="line-removed">170                         jit.load32(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), wasmCallingConvention().m_gprArgs[numGPRs].gpr());</span>
<span class="line-removed">171                     else</span>
<span class="line-removed">172                         jit.load64(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), wasmCallingConvention().m_gprArgs[numGPRs].gpr());</span>
<span class="line-removed">173                 }</span>
<span class="line-removed">174                 ++numGPRs;</span>
<span class="line-removed">175                 break;</span>
<span class="line-removed">176             case Wasm::F32:</span>
<span class="line-removed">177             case Wasm::F64:</span>
<span class="line-removed">178                 if (numFPRs &gt;= wasmCallingConvention().m_fprArgs.size()) {</span>
<span class="line-removed">179                     if (signature.argument(i) == Wasm::F32) {</span>
<span class="line-removed">180                         jit.load32(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchReg);</span>
<span class="line-removed">181                         jit.store32(scratchReg, calleeFrame.withOffset(wasmOffset));</span>
<span class="line-removed">182                     } else {</span>
<span class="line-removed">183                         jit.load64(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchReg);</span>
<span class="line-removed">184                         jit.store64(scratchReg, calleeFrame.withOffset(wasmOffset));</span>
<span class="line-removed">185                     }</span>
<span class="line-removed">186                     wasmOffset += sizeof(void*);</span>
187                 } else {
<a name="16" id="anc16"></a><span class="line-modified">188                     if (signature.argument(i) == Wasm::F32)</span>
<span class="line-modified">189                         jit.loadFloat(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), wasmCallingConvention().m_fprArgs[numFPRs].fpr());</span>
<span class="line-removed">190                     else</span>
<span class="line-removed">191                         jit.loadDouble(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), wasmCallingConvention().m_fprArgs[numFPRs].fpr());</span>
192                 }
<a name="17" id="anc17"></a><span class="line-modified">193                 ++numFPRs;</span>
<span class="line-modified">194                 break;</span>
<span class="line-modified">195             default:</span>
<span class="line-modified">196                 RELEASE_ASSERT_NOT_REACHED();</span>

197             }
<a name="18" id="anc18"></a><span class="line-removed">198 </span>
<span class="line-removed">199             jsOffset += sizeof(EncodedJSValue);</span>
200         }
201     }
202 
203     if (!!info.memory) {
204         GPRReg baseMemory = pinnedRegs.baseMemoryPointer;
<a name="19" id="anc19"></a><span class="line-modified">205         GPRReg scratchOrSize = wasmCallingConventionAir().prologueScratch(0);</span>
206 
207         if (Context::useFastTLS())
208             jit.loadWasmContextInstance(baseMemory);
209 
210         GPRReg currentInstanceGPR = Context::useFastTLS() ? baseMemory : wasmContextInstanceGPR;
211         if (isARM64E()) {
212             if (mode != Wasm::MemoryMode::Signaling)
213                 scratchOrSize = pinnedRegs.sizeRegister;
214             jit.loadPtr(CCallHelpers::Address(currentInstanceGPR, Wasm::Instance::offsetOfCachedMemorySize()), scratchOrSize);
215         } else {
216             if (mode != Wasm::MemoryMode::Signaling)
217                 jit.loadPtr(CCallHelpers::Address(currentInstanceGPR, Wasm::Instance::offsetOfCachedMemorySize()), pinnedRegs.sizeRegister);
218         }
219 
220         jit.loadPtr(CCallHelpers::Address(currentInstanceGPR, Wasm::Instance::offsetOfCachedMemory()), baseMemory);
221         jit.cageConditionally(Gigacage::Primitive, baseMemory, scratchOrSize, scratchOrSize);
222     }
223 
224     CCallHelpers::Call call = jit.threadSafePatchableNearCall();
225     unsigned functionIndexSpace = functionIndex + info.importFunctionCount();
226     ASSERT(functionIndexSpace &lt; info.functionIndexSpaceSize());
227     jit.addLinkTask([unlinkedWasmToWasmCalls, call, functionIndexSpace] (LinkBuffer&amp; linkBuffer) {
228         unlinkedWasmToWasmCalls-&gt;append({ linkBuffer.locationOfNearCall&lt;WasmEntryPtrTag&gt;(call), functionIndexSpace });
229     });
230 
<a name="20" id="anc20"></a>

231     for (const RegisterAtOffset&amp; regAtOffset : registersToSpill) {
232         GPRReg reg = regAtOffset.reg().gpr();
233         ASSERT(reg != GPRInfo::returnValueGPR);
234         ptrdiff_t offset = regAtOffset.offset();
235         jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, offset), reg);
236     }
237 
<a name="21" id="anc21"></a><span class="line-removed">238     switch (signature.returnType()) {</span>
<span class="line-removed">239     case Wasm::Void:</span>
<span class="line-removed">240         jit.moveTrustedValue(jsUndefined(), JSValueRegs { GPRInfo::returnValueGPR });</span>
<span class="line-removed">241         break;</span>
<span class="line-removed">242     case Wasm::Anyref:</span>
<span class="line-removed">243     case Wasm::Funcref:</span>
<span class="line-removed">244         break;</span>
<span class="line-removed">245     case Wasm::I32:</span>
<span class="line-removed">246         jit.zeroExtend32ToPtr(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR);</span>
<span class="line-removed">247         jit.boxInt32(GPRInfo::returnValueGPR, JSValueRegs { GPRInfo::returnValueGPR }, DoNotHaveTagRegisters);</span>
<span class="line-removed">248         break;</span>
<span class="line-removed">249     case Wasm::F32:</span>
<span class="line-removed">250         jit.convertFloatToDouble(FPRInfo::returnValueFPR, FPRInfo::returnValueFPR);</span>
<span class="line-removed">251         FALLTHROUGH;</span>
<span class="line-removed">252     case Wasm::F64: {</span>
<span class="line-removed">253         jit.moveTrustedValue(jsNumber(pureNaN()), JSValueRegs { GPRInfo::returnValueGPR });</span>
<span class="line-removed">254         auto isNaN = jit.branchIfNaN(FPRInfo::returnValueFPR);</span>
<span class="line-removed">255         jit.boxDouble(FPRInfo::returnValueFPR, JSValueRegs { GPRInfo::returnValueGPR }, DoNotHaveTagRegisters);</span>
<span class="line-removed">256         isNaN.link(&amp;jit);</span>
<span class="line-removed">257         break;</span>
<span class="line-removed">258     }</span>
<span class="line-removed">259     case Wasm::I64:</span>
<span class="line-removed">260     case Wasm::Func:</span>
<span class="line-removed">261         jit.breakpoint();</span>
<span class="line-removed">262         break;</span>
<span class="line-removed">263     default:</span>
<span class="line-removed">264         break;</span>
<span class="line-removed">265     }</span>
<span class="line-removed">266 </span>
267     jit.emitFunctionEpilogue();
268     jit.ret();
269 
270     return result;
271 }
272 
273 } } // namespace JSC::Wasm
274 
275 #endif // ENABLE(WEBASSEMBLY)
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>
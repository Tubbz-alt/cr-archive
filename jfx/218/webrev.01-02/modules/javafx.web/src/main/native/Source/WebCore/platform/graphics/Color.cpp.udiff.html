<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Color.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BitmapImage.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Color.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Color.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (C) 2003, 2004, 2005, 2006, 2008 Apple Inc. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (C) 2003-2020 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -25,30 +25,22 @@</span>
  
  #include &quot;config.h&quot;
  #include &quot;Color.h&quot;
  
  #include &quot;AnimationUtilities.h&quot;
<span class="udiff-line-added">+ #include &quot;ColorUtilities.h&quot;</span>
  #include &quot;HashTools.h&quot;
  #include &lt;wtf/Assertions.h&gt;
  #include &lt;wtf/HexNumber.h&gt;
  #include &lt;wtf/MathExtras.h&gt;
  #include &lt;wtf/text/StringBuilder.h&gt;
  #include &lt;wtf/text/TextStream.h&gt;
  
  namespace WebCore {
  
<span class="udiff-line-modified-removed">- #if !COMPILER(MSVC)</span>
<span class="udiff-line-modified-removed">- const RGBA32 Color::black;</span>
<span class="udiff-line-removed">- const RGBA32 Color::white;</span>
<span class="udiff-line-removed">- const RGBA32 Color::darkGray;</span>
<span class="udiff-line-removed">- const RGBA32 Color::gray;</span>
<span class="udiff-line-removed">- const RGBA32 Color::lightGray;</span>
<span class="udiff-line-removed">- const RGBA32 Color::transparent;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static const RGBA32 lightenedBlack = 0xFF545454;</span>
<span class="udiff-line-removed">- static const RGBA32 darkenedWhite = 0xFFABABAB;</span>
<span class="udiff-line-modified-added">+ static constexpr SimpleColor lightenedBlack { 0xFF545454 };</span>
<span class="udiff-line-modified-added">+ static constexpr SimpleColor darkenedWhite { 0xFFABABAB };</span>
  
  static inline unsigned premultipliedChannel(unsigned c, unsigned a, bool ceiling = true)
  {
      return fastDivideBy255(ceiling ? c * a + 254 : c * a);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -58,16 +50,16 @@</span>
      return (fastMultiplyBy255(c) + a - 1) / a;
  }
  
  RGBA32 makeRGB(int r, int g, int b)
  {
<span class="udiff-line-modified-removed">-     return 0xFF000000 | std::max(0, std::min(r, 255)) &lt;&lt; 16 | std::max(0, std::min(g, 255)) &lt;&lt; 8 | std::max(0, std::min(b, 255));</span>
<span class="udiff-line-modified-added">+     return makeRGBA(r, g, b, 0xFF);</span>
  }
  
  RGBA32 makeRGBA(int r, int g, int b, int a)
  {
<span class="udiff-line-modified-removed">-     return std::max(0, std::min(a, 255)) &lt;&lt; 24 | std::max(0, std::min(r, 255)) &lt;&lt; 16 | std::max(0, std::min(g, 255)) &lt;&lt; 8 | std::max(0, std::min(b, 255));</span>
<span class="udiff-line-modified-added">+     return { static_cast&lt;unsigned&gt;(std::max(0, std::min(a, 0xFF)) &lt;&lt; 24 | std::max(0, std::min(r, 0xFF)) &lt;&lt; 16 | std::max(0, std::min(g, 0xFF)) &lt;&lt; 8 | std::max(0, std::min(b, 0xFF))) };</span>
  }
  
  RGBA32 makePremultipliedRGBA(int r, int g, int b, int a, bool ceiling)
  {
      return makeRGBA(premultipliedChannel(r, a, ceiling), premultipliedChannel(g, a, ceiling), premultipliedChannel(b, a, ceiling), a);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -84,57 +76,27 @@</span>
      return std::max(0, std::min(static_cast&lt;int&gt;(lroundf(255.0f * f)), 255));
  }
  
  RGBA32 makeRGBA32FromFloats(float r, float g, float b, float a)
  {
<span class="udiff-line-modified-removed">-     return colorFloatToRGBAByte(a) &lt;&lt; 24 | colorFloatToRGBAByte(r) &lt;&lt; 16 | colorFloatToRGBAByte(g) &lt;&lt; 8 | colorFloatToRGBAByte(b);</span>
<span class="udiff-line-modified-added">+     return makeRGBA(colorFloatToRGBAByte(r), colorFloatToRGBAByte(g), colorFloatToRGBAByte(b), colorFloatToRGBAByte(a));</span>
  }
  
  RGBA32 colorWithOverrideAlpha(RGBA32 color, float overrideAlpha)
  {
<span class="udiff-line-modified-removed">-     RGBA32 rgbOnly = color &amp; 0x00FFFFFF;</span>
<span class="udiff-line-removed">-     RGBA32 rgba = rgbOnly | colorFloatToRGBAByte(overrideAlpha) &lt;&lt; 24;</span>
<span class="udiff-line-removed">-     return rgba;</span>
<span class="udiff-line-modified-added">+     return { (color.value() &amp; 0x00FFFFFF) | colorFloatToRGBAByte(overrideAlpha) &lt;&lt; 24 };</span>
  }
  
<span class="udiff-line-modified-removed">- static double calcHue(double temp1, double temp2, double hueVal)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     if (hueVal &lt; 0.0)</span>
<span class="udiff-line-removed">-         hueVal += 6.0;</span>
<span class="udiff-line-removed">-     else if (hueVal &gt;= 6.0)</span>
<span class="udiff-line-removed">-         hueVal -= 6.0;</span>
<span class="udiff-line-removed">-     if (hueVal &lt; 1.0)</span>
<span class="udiff-line-removed">-         return temp1 + (temp2 - temp1) * hueVal;</span>
<span class="udiff-line-removed">-     if (hueVal &lt; 3.0)</span>
<span class="udiff-line-removed">-         return temp2;</span>
<span class="udiff-line-removed">-     if (hueVal &lt; 4.0)</span>
<span class="udiff-line-removed">-         return temp1 + (temp2 - temp1) * (4.0 - hueVal);</span>
<span class="udiff-line-removed">-     return temp1;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Explanation of this algorithm can be found in the CSS Color 4 Module</span>
<span class="udiff-line-removed">- // specification at https://drafts.csswg.org/css-color-4/#hsl-to-rgb with</span>
<span class="udiff-line-removed">- // further explanation available at http://en.wikipedia.org/wiki/HSL_color_space</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- // Hue is in the range of 0 to 6.0, the remainder are in the range 0 to 1.0</span>
<span class="udiff-line-removed">- // FIXME: Use HSLToSRGB().</span>
<span class="udiff-line-removed">- RGBA32 makeRGBAFromHSLA(double hue, double saturation, double lightness, double alpha)</span>
<span class="udiff-line-modified-added">+ RGBA32 makeRGBAFromHSLA(float hue, float saturation, float lightness, float alpha)</span>
  {
<span class="udiff-line-modified-removed">-     const double scaleFactor = nextafter(256.0, 0.0);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     if (!saturation) {</span>
<span class="udiff-line-modified-removed">-         int greyValue = static_cast&lt;int&gt;(lightness * scaleFactor);</span>
<span class="udiff-line-modified-removed">-         return makeRGBA(greyValue, greyValue, greyValue, static_cast&lt;int&gt;(alpha * scaleFactor));</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-     double temp2 = lightness &lt;= 0.5 ? lightness * (1.0 + saturation) : lightness + saturation - lightness * saturation;</span>
<span class="udiff-line-removed">-     double temp1 = 2.0 * lightness - temp2;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     return makeRGBA(static_cast&lt;int&gt;(calcHue(temp1, temp2, hue + 2.0) * scaleFactor),</span>
<span class="udiff-line-removed">-                     static_cast&lt;int&gt;(calcHue(temp1, temp2, hue) * scaleFactor),</span>
<span class="udiff-line-removed">-                     static_cast&lt;int&gt;(calcHue(temp1, temp2, hue - 2.0) * scaleFactor),</span>
<span class="udiff-line-removed">-                     static_cast&lt;int&gt;(alpha * scaleFactor));</span>
<span class="udiff-line-modified-added">+     const float scaleFactor = 255.0;</span>
<span class="udiff-line-modified-added">+     FloatComponents floatResult = HSLToSRGB({ hue, saturation, lightness, alpha });</span>
<span class="udiff-line-modified-added">+     return makeRGBA(</span>
<span class="udiff-line-modified-added">+         round(floatResult.components[0] * scaleFactor),</span>
<span class="udiff-line-modified-added">+         round(floatResult.components[1] * scaleFactor),</span>
<span class="udiff-line-modified-added">+         round(floatResult.components[2] * scaleFactor),</span>
<span class="udiff-line-modified-added">+         round(floatResult.components[3] * scaleFactor));</span>
  }
  
  RGBA32 makeRGBAFromCMYKA(float c, float m, float y, float k, float a)
  {
      double colors = 1 - k;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -156,32 +118,32 @@</span>
              return false;
          value &lt;&lt;= 4;
          value |= toASCIIHexValue(name[i]);
      }
      if (length == 6) {
<span class="udiff-line-modified-removed">-         rgb = 0xFF000000 | value;</span>
<span class="udiff-line-modified-added">+         rgb = { 0xFF000000 | value };</span>
          return true;
      }
      if (length == 8) {
          // We parsed the values into RGBA order, but the RGBA32 type
          // expects them to be in ARGB order, so we right rotate eight bits.
<span class="udiff-line-modified-removed">-         rgb = value &lt;&lt; 24 | value &gt;&gt; 8;</span>
<span class="udiff-line-modified-added">+         rgb = { value &lt;&lt; 24 | value &gt;&gt; 8 };</span>
          return true;
      }
      if (length == 4) {
          // #abcd converts to ddaabbcc in RGBA32.
<span class="udiff-line-modified-removed">-         rgb = (value &amp; 0xF) &lt;&lt; 28 | (value &amp; 0xF) &lt;&lt; 24</span>
<span class="udiff-line-modified-added">+         rgb = { (value &amp; 0xF) &lt;&lt; 28 | (value &amp; 0xF) &lt;&lt; 24</span>
              | (value &amp; 0xF000) &lt;&lt; 8 | (value &amp; 0xF000) &lt;&lt; 4
              | (value &amp; 0xF00) &lt;&lt; 4 | (value &amp; 0xF00)
<span class="udiff-line-modified-removed">-             | (value &amp; 0xF0) | (value &amp; 0xF0) &gt;&gt; 4;</span>
<span class="udiff-line-modified-added">+             | (value &amp; 0xF0) | (value &amp; 0xF0) &gt;&gt; 4 };</span>
          return true;
      }
      // #abc converts to #aabbcc
<span class="udiff-line-modified-removed">-     rgb = 0xFF000000</span>
<span class="udiff-line-modified-added">+     rgb = { 0xFF000000</span>
          | (value &amp; 0xF00) &lt;&lt; 12 | (value &amp; 0xF00) &lt;&lt; 8
          | (value &amp; 0xF0) &lt;&lt; 8 | (value &amp; 0xF0) &lt;&lt; 4
<span class="udiff-line-modified-removed">-         | (value &amp; 0xF) &lt;&lt; 4 | (value &amp; 0xF);</span>
<span class="udiff-line-modified-added">+         | (value &amp; 0xF) &lt;&lt; 4 | (value &amp; 0xF) };</span>
      return true;
  }
  
  bool Color::parseHexColor(const LChar* name, unsigned length, RGBA32&amp; rgb)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -194,11 +156,10 @@</span>
  }
  
  bool Color::parseHexColor(const String&amp; name, RGBA32&amp; rgb)
  {
      unsigned length = name.length();
<span class="udiff-line-removed">- </span>
      if (!length)
          return false;
      if (name.is8Bit())
          return parseHexColor(name.characters8(), name.length(), rgb);
      return parseHexColor(name.characters16(), name.length(), rgb);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -261,30 +222,22 @@</span>
  
          if (valid)
              setRGB(color);
      } else {
          if (auto* foundColor = findNamedColor(name))
<span class="udiff-line-modified-removed">-             setRGB(foundColor-&gt;ARGBValue);</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             m_colorData.rgbaAndFlags = invalidRGBAColor;</span>
<span class="udiff-line-modified-added">+             setRGB({ foundColor-&gt;ARGBValue });</span>
      }
  }
  
  Color::Color(const char* name)
  {
<span class="udiff-line-modified-removed">-     RGBA32 color;</span>
<span class="udiff-line-modified-removed">-     bool valid;</span>
<span class="udiff-line-modified-removed">-     if (name[0] == &#39;#&#39;)</span>
<span class="udiff-line-modified-removed">-         valid = parseHexColor((String)&amp;name[1], color);</span>
<span class="udiff-line-modified-removed">-     else {</span>
<span class="udiff-line-modified-removed">-         const NamedColor* foundColor = findColor(name, strlen(name));</span>
<span class="udiff-line-removed">-         color = foundColor ? foundColor-&gt;ARGBValue : 0;</span>
<span class="udiff-line-removed">-         valid = foundColor;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (valid)</span>
<span class="udiff-line-removed">-         setRGB(color);</span>
<span class="udiff-line-modified-added">+     if (name[0] == &#39;#&#39;) {</span>
<span class="udiff-line-modified-added">+         SimpleColor color;</span>
<span class="udiff-line-modified-added">+         if (parseHexColor(reinterpret_cast&lt;const LChar*&gt;(&amp;name[1]), std::strlen(&amp;name[1]), color))</span>
<span class="udiff-line-modified-added">+             setRGB(color);</span>
<span class="udiff-line-modified-added">+     } else if (auto* foundColor = findColor(name, strlen(name)))</span>
<span class="udiff-line-modified-added">+         setRGB({ foundColor-&gt;ARGBValue });</span>
  }
  
  Color::Color(const Color&amp; other)
      : m_colorData(other.m_colorData)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -334,64 +287,71 @@</span>
      other.m_colorData.rgbaAndFlags = invalidRGBAColor;
  
      return *this;
  }
  
<span class="udiff-line-added">+ String SimpleColor::serializationForHTML() const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     if (isOpaque())</span>
<span class="udiff-line-added">+         return makeString(&#39;#&#39;, hex(redComponent(), 2, Lowercase), hex(greenComponent(), 2, Lowercase), hex(blueComponent(), 2, Lowercase));</span>
<span class="udiff-line-added">+     return serializationForCSS();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  String Color::serialized() const
  {
      if (isExtended())
          return asExtended().cssText();
<span class="udiff-line-added">+     return rgb().serializationForHTML();</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-     if (isOpaque()) {</span>
<span class="udiff-line-modified-removed">-         StringBuilder builder;</span>
<span class="udiff-line-modified-removed">-         builder.reserveCapacity(7);</span>
<span class="udiff-line-modified-removed">-         builder.append(&#39;#&#39;);</span>
<span class="udiff-line-modified-removed">-         appendByteAsHex(red(), builder, Lowercase);</span>
<span class="udiff-line-removed">-         appendByteAsHex(green(), builder, Lowercase);</span>
<span class="udiff-line-removed">-         appendByteAsHex(blue(), builder, Lowercase);</span>
<span class="udiff-line-removed">-         return builder.toString();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+ static char decimalDigit(unsigned number)</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-modified-added">+     ASSERT(number &lt; 10);</span>
<span class="udiff-line-modified-added">+     return &#39;0&#39; + number;</span>
<span class="udiff-line-modified-added">+ }</span>
  
<span class="udiff-line-modified-removed">-     return cssText();</span>
<span class="udiff-line-modified-added">+ static std::array&lt;char, 4&gt; fractionDigitsForFractionalAlphaValue(uint8_t alpha)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     ASSERT(alpha &gt; 0);</span>
<span class="udiff-line-added">+     ASSERT(alpha &lt; 0xFF);</span>
<span class="udiff-line-added">+     if (((alpha * 100 + 0x7F) / 0xFF * 0xFF + 50) / 100 != alpha)</span>
<span class="udiff-line-added">+         return { { decimalDigit(alpha * 10 / 0xFF % 10), decimalDigit(alpha * 100 / 0xFF % 10), decimalDigit((alpha * 1000 + 0x7F) / 0xFF % 10), &#39;\0&#39; } };</span>
<span class="udiff-line-added">+     if (int thirdDigit = (alpha * 100 + 0x7F) / 0xFF % 10)</span>
<span class="udiff-line-added">+         return { { decimalDigit(alpha * 10 / 0xFF), decimalDigit(thirdDigit), &#39;\0&#39;, &#39;\0&#39; } };</span>
<span class="udiff-line-added">+     return { { decimalDigit((alpha * 10 + 0x7F) / 0xFF), &#39;\0&#39;, &#39;\0&#39;, &#39;\0&#39; } };</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ String SimpleColor::serializationForCSS() const</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     switch (alphaComponent()) {</span>
<span class="udiff-line-added">+     case 0:</span>
<span class="udiff-line-added">+         return makeString(&quot;rgba(&quot;, redComponent(), &quot;, &quot;, greenComponent(), &quot;, &quot;, blueComponent(), &quot;, 0)&quot;);</span>
<span class="udiff-line-added">+     case 0xFF:</span>
<span class="udiff-line-added">+         return makeString(&quot;rgb(&quot;, redComponent(), &quot;, &quot;, greenComponent(), &quot;, &quot;, blueComponent(), &#39;)&#39;);</span>
<span class="udiff-line-added">+     default:</span>
<span class="udiff-line-added">+         return makeString(&quot;rgba(&quot;, redComponent(), &quot;, &quot;, greenComponent(), &quot;, &quot;, blueComponent(), &quot;, 0.&quot;, fractionDigitsForFractionalAlphaValue(alphaComponent()).data(), &#39;)&#39;);</span>
<span class="udiff-line-added">+     }</span>
  }
  
  String Color::cssText() const
  {
      if (isExtended())
          return asExtended().cssText();
<span class="udiff-line-added">+     return rgb().serializationForCSS();</span>
<span class="udiff-line-added">+ }</span>
  
<span class="udiff-line-modified-removed">-     StringBuilder builder;</span>
<span class="udiff-line-modified-removed">-     builder.reserveCapacity(28);</span>
<span class="udiff-line-modified-removed">-     bool colorHasAlpha = !isOpaque();</span>
<span class="udiff-line-modified-removed">-     if (colorHasAlpha)</span>
<span class="udiff-line-modified-removed">-         builder.appendLiteral(&quot;rgba(&quot;);</span>
<span class="udiff-line-removed">-     else</span>
<span class="udiff-line-removed">-         builder.appendLiteral(&quot;rgb(&quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     builder.appendNumber(static_cast&lt;unsigned char&gt;(red()));</span>
<span class="udiff-line-removed">-     builder.appendLiteral(&quot;, &quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     builder.appendNumber(static_cast&lt;unsigned char&gt;(green()));</span>
<span class="udiff-line-removed">-     builder.appendLiteral(&quot;, &quot;);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     builder.appendNumber(static_cast&lt;unsigned char&gt;(blue()));</span>
<span class="udiff-line-removed">-     if (colorHasAlpha) {</span>
<span class="udiff-line-removed">-         builder.appendLiteral(&quot;, &quot;);</span>
<span class="udiff-line-removed">-         builder.appendFixedPrecisionNumber(alpha() / 255.0f);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     builder.append(&#39;)&#39;);</span>
<span class="udiff-line-removed">-     return builder.toString();</span>
<span class="udiff-line-modified-added">+ String RGBA32::serializationForRenderTreeAsText() const</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-modified-added">+     if (alphaComponent() &lt; 0xFF)</span>
<span class="udiff-line-modified-added">+         return makeString(&#39;#&#39;, hex(redComponent(), 2), hex(greenComponent(), 2), hex(blueComponent(), 2), hex(alphaComponent(), 2));</span>
<span class="udiff-line-modified-added">+     return makeString(&#39;#&#39;, hex(redComponent(), 2), hex(greenComponent(), 2), hex(blueComponent(), 2));</span>
  }
  
  String Color::nameForRenderTreeAsText() const
  {
<span class="udiff-line-modified-removed">-     // FIXME: Handle ExtendedColors.</span>
<span class="udiff-line-modified-removed">-     if (alpha() &lt; 0xFF)</span>
<span class="udiff-line-removed">-         return makeString(&#39;#&#39;, hex(red(), 2), hex(green(), 2), hex(blue(), 2), hex(alpha(), 2));</span>
<span class="udiff-line-removed">-     return makeString(&#39;#&#39;, hex(red(), 2), hex(green(), 2), hex(blue(), 2));</span>
<span class="udiff-line-modified-added">+     // FIXME: Handle extended colors.</span>
<span class="udiff-line-modified-added">+     return rgb().serializationForRenderTreeAsText();</span>
  }
  
  Color Color::light() const
  {
      // Hardcode this common case for speed.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -605,14 +565,13 @@</span>
      value = max;
  }
  
  Color colorFromPremultipliedARGB(RGBA32 pixelColor)
  {
<span class="udiff-line-modified-removed">-     int alpha = alphaChannel(pixelColor);</span>
<span class="udiff-line-modified-removed">-     if (alpha &amp;&amp; alpha &lt; 255)</span>
<span class="udiff-line-modified-removed">-         pixelColor = makeUnPremultipliedRGBA(redChannel(pixelColor), greenChannel(pixelColor), blueChannel(pixelColor), alpha);</span>
<span class="udiff-line-removed">-     return Color(pixelColor);</span>
<span class="udiff-line-modified-added">+     if (pixelColor.isVisible() &amp;&amp; !pixelColor.isOpaque())</span>
<span class="udiff-line-modified-added">+         return makeUnPremultipliedRGBA(pixelColor.redComponent(), pixelColor.greenComponent(), pixelColor.blueComponent(), pixelColor.alphaComponent());</span>
<span class="udiff-line-modified-added">+     return pixelColor;</span>
  }
  
  RGBA32 premultipliedARGBFromColor(const Color&amp; color)
  {
      if (color.isOpaque()) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -633,14 +592,13 @@</span>
      // We need to preserve the state of the valid flag at the end of the animation
      if (progress == 1 &amp;&amp; !to.isValid())
          return Color();
  
      if (blendPremultiplied) {
<span class="udiff-line-modified-removed">-         // Contrary to the name, RGBA32 actually stores ARGB, so we can initialize Color directly from premultipliedARGBFromColor().</span>
<span class="udiff-line-modified-removed">-         // Also, premultipliedARGBFromColor() bails on zero alpha, so special-case that.</span>
<span class="udiff-line-modified-removed">-         Color premultFrom = from.alpha() ? premultipliedARGBFromColor(from) : 0;</span>
<span class="udiff-line-removed">-         Color premultTo = to.alpha() ? premultipliedARGBFromColor(to) : 0;</span>
<span class="udiff-line-modified-added">+         // Since premultipliedARGBFromColor() bails on zero alpha, special-case that.</span>
<span class="udiff-line-modified-added">+         Color premultFrom = from.alpha() ? premultipliedARGBFromColor(from) : Color::transparent;</span>
<span class="udiff-line-modified-added">+         Color premultTo = to.alpha() ? premultipliedARGBFromColor(to) : Color::transparent;</span>
  
          Color premultBlended(blend(premultFrom.red(), premultTo.red(), progress),
              blend(premultFrom.green(), premultTo.green(), progress),
              blend(premultFrom.blue(), premultTo.blue(), progress),
              blend(premultFrom.alpha(), premultTo.alpha(), progress));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -671,17 +629,17 @@</span>
  }
  
  TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, ColorSpace colorSpace)
  {
      switch (colorSpace) {
<span class="udiff-line-modified-removed">-     case ColorSpaceSRGB:</span>
<span class="udiff-line-modified-added">+     case ColorSpace::SRGB:</span>
          ts &lt;&lt; &quot;sRGB&quot;;
          break;
<span class="udiff-line-modified-removed">-     case ColorSpaceLinearRGB:</span>
<span class="udiff-line-modified-added">+     case ColorSpace::LinearRGB:</span>
          ts &lt;&lt; &quot;LinearRGB&quot;;
          break;
<span class="udiff-line-modified-removed">-     case ColorSpaceDisplayP3:</span>
<span class="udiff-line-modified-added">+     case ColorSpace::DisplayP3:</span>
          ts &lt;&lt; &quot;DisplayP3&quot;;
          break;
      }
      return ts;
  }
</pre>
<center><a href="BitmapImage.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Color.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
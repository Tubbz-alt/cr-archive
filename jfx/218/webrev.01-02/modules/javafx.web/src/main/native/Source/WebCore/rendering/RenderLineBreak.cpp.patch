diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLineBreak.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLineBreak.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLineBreak.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLineBreak.cpp
@@ -25,15 +25,15 @@
 #include "Document.h"
 #include "FontMetrics.h"
 #include "HTMLElement.h"
 #include "HTMLWBRElement.h"
 #include "InlineElementBox.h"
+#include "LineLayoutTraversal.h"
 #include "LogicalSelectionOffsetCaches.h"
 #include "RenderBlock.h"
 #include "RenderView.h"
 #include "RootInlineBox.h"
-#include "SimpleLineLayoutFunctions.h"
 #include "VisiblePosition.h"
 #include <wtf/IsoMallocInlines.h>
 
 #if PLATFORM(IOS_FAMILY)
 #include "SelectionRect.h"
@@ -43,17 +43,10 @@
 
 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderLineBreak);
 
 static const int invalidLineHeight = -1;
 
-static const SimpleLineLayout::Layout* simpleLineLayout(const RenderLineBreak& renderer)
-{
-    if (!is<RenderBlockFlow>(*renderer.parent()))
-        return nullptr;
-    return downcast<RenderBlockFlow>(*renderer.parent()).simpleLineLayout();
-}
-
 RenderLineBreak::RenderLineBreak(HTMLElement& element, RenderStyle&& style)
     : RenderBoxModelObject(element, WTFMove(style), 0)
     , m_inlineBoxWrapper(nullptr)
     , m_cachedLineHeight(invalidLineHeight)
     , m_isWBR(is<HTMLWBRElement>(element))
@@ -131,16 +124,10 @@
     if (!is<RenderBlockFlow>(*parent()))
         return;
     downcast<RenderBlockFlow>(*parent()).ensureLineBoxes();
 }
 
-void RenderLineBreak::deleteLineBoxesBeforeSimpleLineLayout()
-{
-    delete m_inlineBoxWrapper;
-    m_inlineBoxWrapper = nullptr;
-}
-
 int RenderLineBreak::caretMinOffset() const
 {
     return 0;
 }
 
@@ -181,49 +168,57 @@
     return rootBox.computeCaretRect(inlineBox->logicalLeft(), caretWidth, extraWidthToEndOfLine);
 }
 
 IntRect RenderLineBreak::linesBoundingBox() const
 {
-    if (auto* layout = simpleLineLayout(*this))
-        return SimpleLineLayout::computeBoundingBox(*this, *layout);
-
-    if (!m_inlineBoxWrapper)
-        return IntRect();
+    auto box = LineLayoutTraversal::elementBoxFor(*this);
+    if (!box)
+        return { };
 
-    float logicalLeftSide = m_inlineBoxWrapper->logicalLeft();
-    float logicalRightSide = m_inlineBoxWrapper->logicalRight();
+    return enclosingIntRect(box->rect());
+}
 
-    bool isHorizontal = style().isHorizontalWritingMode();
+IntRect RenderLineBreak::boundingBoxForRenderTreeDump() const
+{
+    auto box = LineLayoutTraversal::elementBoxFor(*this);
+    if (!box)
+        return { };
+
+    auto rect = box->rect();
+
+    // FIXME: Remove and rebase the tests.
+    bool inQuirksMode = !document().inNoQuirksMode();
+    if (inQuirksMode && !isWBR() && box->useLineBreakBoxRenderTreeDumpQuirk()) {
+        if (!box->isHorizontal()) {
+            auto baseline = style().isFlippedBlocksWritingMode() ? rect.x() + box->baselineOffset() : rect.maxX() - box->baselineOffset();
+            return enclosingIntRect(FloatRect(FloatPoint(baseline, rect.y()), FloatSize(0, rect.height())));
+        }
+        auto baseline = rect.y() + box->baselineOffset();
+        return enclosingIntRect(FloatRect(FloatPoint(rect.x(), baseline), FloatSize(rect.width(), 0)));
+    }
 
-    float x = isHorizontal ? logicalLeftSide : m_inlineBoxWrapper->x();
-    float y = isHorizontal ? m_inlineBoxWrapper->y() : logicalLeftSide;
-    float width = isHorizontal ? logicalRightSide - logicalLeftSide : m_inlineBoxWrapper->logicalBottom() - x;
-    float height = isHorizontal ? m_inlineBoxWrapper->logicalBottom() - y : logicalRightSide - logicalLeftSide;
-    return enclosingIntRect(FloatRect(x, y, width, height));
+    return enclosingIntRect(rect);
 }
 
 void RenderLineBreak::absoluteRects(Vector<IntRect>& rects, const LayoutPoint& accumulatedOffset) const
 {
-    if (auto* layout = simpleLineLayout(*this)) {
-        rects.appendVector(SimpleLineLayout::collectAbsoluteRects(*this, *layout, accumulatedOffset));
+    auto box = LineLayoutTraversal::elementBoxFor(*this);
+    if (!box)
         return;
-    }
 
-    if (!m_inlineBoxWrapper)
-        return;
-    rects.append(enclosingIntRect(FloatRect(accumulatedOffset + m_inlineBoxWrapper->topLeft(), m_inlineBoxWrapper->size())));
+    auto rect = box->rect();
+    rects.append(enclosingIntRect(FloatRect(accumulatedOffset + rect.location(), rect.size())));
 }
 
 void RenderLineBreak::absoluteQuads(Vector<FloatQuad>& quads, bool* wasFixed) const
 {
-    if (auto* layout = simpleLineLayout(*this)) {
-        quads.appendVector(SimpleLineLayout::collectAbsoluteQuads(*this, *layout, wasFixed));
-        return;
-    }
-    if (!m_inlineBoxWrapper)
+    auto box = LineLayoutTraversal::elementBoxFor(*this);
+    if (!box)
         return;
-    quads.append(localToAbsoluteQuad(FloatRect(m_inlineBoxWrapper->topLeft(), m_inlineBoxWrapper->size()), UseTransforms, wasFixed));
+
+    auto rect = box->rect();
+    quads.append(localToAbsoluteQuad(FloatRect(rect.location(), rect.size()), UseTransforms, wasFixed));
 }
 
 void RenderLineBreak::updateFromStyle()
 {
     m_cachedLineHeight = invalidLineHeight;

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/FrameViewLayoutContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FrameView.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FrameViewLayoutContext.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/FrameViewLayoutContext.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FrameViewLayoutContext.h&quot;
 28 
 29 #include &quot;CSSAnimationController.h&quot;
 30 #include &quot;DebugPageOverlays.h&quot;
 31 #include &quot;Document.h&quot;
 32 #include &quot;FrameView.h&quot;
 33 #include &quot;InspectorInstrumentation.h&quot;
 34 #include &quot;LayoutDisallowedScope.h&quot;
 35 #include &quot;Logging.h&quot;
 36 #include &quot;RenderElement.h&quot;
 37 #include &quot;RenderLayoutState.h&quot;
 38 #include &quot;RenderView.h&quot;
 39 #include &quot;RuntimeEnabledFeatures.h&quot;
 40 #include &quot;ScriptDisallowedScope.h&quot;
 41 #include &quot;Settings.h&quot;
 42 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)




 43 #include &quot;LayoutState.h&quot;


 44 #endif
 45 
 46 #include &lt;wtf/SetForScope.h&gt;
 47 #include &lt;wtf/SystemTracing.h&gt;
 48 #include &lt;wtf/text/TextStream.h&gt;
 49 
 50 namespace WebCore {
 51 
 52 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
<span class="line-modified"> 53 static void layoutUsingFormattingContext(const RenderView&amp; renderView)</span>
 54 {
 55     if (!RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextEnabled())
 56         return;
<span class="line-modified"> 57     Layout::LayoutState::run(renderView);</span>





































 58 }
 59 #endif
 60 
 61 static bool isObjectAncestorContainerOf(RenderElement&amp; ancestor, RenderElement&amp; descendant)
 62 {
 63     for (auto* renderer = &amp;descendant; renderer; renderer = renderer-&gt;container()) {
 64         if (renderer == &amp;ancestor)
 65             return true;
 66     }
 67     return false;
 68 }
 69 
 70 #ifndef NDEBUG
 71 class RenderTreeNeedsLayoutChecker {
 72 public :
 73     RenderTreeNeedsLayoutChecker(const RenderElement&amp; layoutRoot)
 74         : m_layoutRoot(layoutRoot)
 75     {
 76     }
 77 
</pre>
<hr />
<pre>
128 FrameViewLayoutContext::FrameViewLayoutContext(FrameView&amp; frameView)
129     : m_frameView(frameView)
130     , m_layoutTimer(*this, &amp;FrameViewLayoutContext::layoutTimerFired)
131     , m_asynchronousTasksTimer(*this, &amp;FrameViewLayoutContext::runAsynchronousTasks)
132 {
133 }
134 
135 FrameViewLayoutContext::~FrameViewLayoutContext()
136 {
137 }
138 
139 void FrameViewLayoutContext::layout()
140 {
141     LOG_WITH_STREAM(Layout, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; &amp;view() &lt;&lt; &quot; FrameViewLayoutContext::layout() with size &quot; &lt;&lt; view().layoutSize());
142 
143     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!frame().document()-&gt;inRenderTreeUpdate());
144     ASSERT(LayoutDisallowedScope::isLayoutAllowed());
145     ASSERT(!view().isPainting());
146     ASSERT(frame().view() == &amp;view());
147     ASSERT(frame().document());
<span class="line-modified">148     ASSERT(frame().document()-&gt;pageCacheState() == Document::NotInPageCache</span>
<span class="line-modified">149         || frame().document()-&gt;pageCacheState() == Document::AboutToEnterPageCache);</span>
150     if (!canPerformLayout()) {
151         LOG(Layout, &quot;  is not allowed, bailing&quot;);
152         return;
153     }
154 
155     Ref&lt;FrameView&gt; protectView(view());
156     LayoutScope layoutScope(*this);
157     TraceScope tracingScope(LayoutStart, LayoutEnd);
<span class="line-modified">158     InspectorInstrumentationCookie inspectorLayoutScope(InspectorInstrumentation::willLayout(view().frame()));</span>
159     AnimationUpdateBlock animationUpdateBlock(&amp;view().frame().animation());
160     WeakPtr&lt;RenderElement&gt; layoutRoot;
161 
162     m_layoutTimer.stop();
163     m_delayedLayout = false;
164     m_setNeedsLayoutWasDeferred = false;
165 
166 #if !LOG_DISABLED
167     if (m_firstLayout &amp;&amp; !frame().ownerElement())
168         LOG(Layout, &quot;FrameView %p elapsed time before first layout: %.3fs&quot;, this, document()-&gt;timeSinceDocumentCreation().value());
169 #endif
170 #if PLATFORM(IOS_FAMILY)
171     if (view().updateFixedPositionLayoutRect() &amp;&amp; subtreeLayoutRoot())
172         convertSubtreeLayoutToFullLayout();
173 #endif
174     if (handleLayoutWithFrameFlatteningIfNeeded())
175         return;
176 
177     {
178         SetForScope&lt;LayoutPhase&gt; layoutPhase(m_layoutPhase, LayoutPhase::InPreLayout);
</pre>
<hr />
<pre>
187 
188         view().autoSizeIfEnabled();
189         if (!renderView())
190             return;
191 
192         layoutRoot = makeWeakPtr(subtreeLayoutRoot() ? subtreeLayoutRoot() : renderView());
193         m_needsFullRepaint = is&lt;RenderView&gt;(layoutRoot.get()) &amp;&amp; (m_firstLayout || renderView()-&gt;printing());
194         view().willDoLayout(layoutRoot);
195         m_firstLayout = false;
196     }
197     {
198         SetForScope&lt;LayoutPhase&gt; layoutPhase(m_layoutPhase, LayoutPhase::InRenderTreeLayout);
199         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
200         SubtreeLayoutStateMaintainer subtreeLayoutStateMaintainer(subtreeLayoutRoot());
201         RenderView::RepaintRegionAccumulator repaintRegionAccumulator(renderView());
202 #ifndef NDEBUG
203         RenderTreeNeedsLayoutChecker checker(*layoutRoot);
204 #endif
205         layoutRoot-&gt;layout();
206 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
<span class="line-modified">207         layoutUsingFormattingContext(*renderView());</span>
208 #endif
209         ++m_layoutCount;
210 #if ENABLE(TEXT_AUTOSIZING)
211         applyTextSizingIfNeeded(*layoutRoot.get());
212 #endif
213         clearSubtreeLayoutRoot();
214     }
215     {
216         SetForScope&lt;LayoutPhase&gt; layoutPhase(m_layoutPhase, LayoutPhase::InViewSizeAdjust);
217         if (is&lt;RenderView&gt;(layoutRoot.get()) &amp;&amp; !renderView()-&gt;printing()) {
218             // This is to protect m_needsFullRepaint&#39;s value when layout() is getting re-entered through adjustViewSize().
219             SetForScope&lt;bool&gt; needsFullRepaint(m_needsFullRepaint);
220             view().adjustViewSize();
221             // FIXME: Firing media query callbacks synchronously on nested frames could produced a detached FrameView here by
222             // navigating away from the current document (see webkit.org/b/173329).
223             if (view().hasOneRef())
224                 return;
225         }
226     }
227     {
228         SetForScope&lt;LayoutPhase&gt; layoutPhase(m_layoutPhase, LayoutPhase::InPostLayout);
229         if (m_needsFullRepaint)
230             renderView()-&gt;repaintRootContents();
231         ASSERT(!layoutRoot-&gt;needsLayout());
232         view().didLayout(layoutRoot);
233         runOrScheduleAsynchronousTasks();
234     }
<span class="line-modified">235     InspectorInstrumentation::didLayout(inspectorLayoutScope, *layoutRoot);</span>
236     DebugPageOverlays::didLayout(view().frame());
237 }
238 
239 void FrameViewLayoutContext::runOrScheduleAsynchronousTasks()
240 {
241     if (m_asynchronousTasksTimer.isActive())
242         return;
243 
244     if (view().isInChildFrameWithFrameFlattening()) {
245         // While flattening frames, we defer post layout tasks to avoid getting stuck in a cycle,
246         // except updateWidgetPositions() which is required to kick off subframe layout in certain cases.
247         if (!m_inAsynchronousTasks)
248             view().updateWidgetPositions();
249         m_asynchronousTasksTimer.startOneShot(0_s);
250         return;
251     }
252 
253     // If we are already in performPostLayoutTasks(), defer post layout tasks until after we return
254     // to avoid re-entrancy.
255     if (m_inAsynchronousTasks) {
</pre>
<hr />
<pre>
317         ASSERT(!frame().document()-&gt;inHitTesting());
318         renderView-&gt;setNeedsLayout();
319         scheduleLayout();
320     }
321 }
322 
323 void FrameViewLayoutContext::enableSetNeedsLayout()
324 {
325     ASSERT(m_disableSetNeedsLayoutCount);
326     if (!--m_disableSetNeedsLayoutCount)
327         m_setNeedsLayoutWasDeferred = false; // FIXME: Find a way to make the deferred layout actually happen.
328 }
329 
330 void FrameViewLayoutContext::disableSetNeedsLayout()
331 {
332     ++m_disableSetNeedsLayoutCount;
333 }
334 
335 void FrameViewLayoutContext::scheduleLayout()
336 {
<span class="line-modified">337     // FIXME: We should assert the page is not in the page cache, but that is causing</span>
338     // too many false assertions. See &lt;rdar://problem/7218118&gt;.
339     ASSERT(frame().view() == &amp;view());
340 
341     if (subtreeLayoutRoot())
342         convertSubtreeLayoutToFullLayout();
343     if (!isLayoutSchedulingEnabled())
344         return;
345     if (!needsLayout())
346         return;
347     if (!frame().document()-&gt;shouldScheduleLayout())
348         return;
349     InspectorInstrumentation::didInvalidateLayout(frame());
350     // When frame flattening is enabled, the contents of the frame could affect the layout of the parent frames.
351     // Also invalidate parent frame starting from the owner element of this frame.
352     if (frame().ownerRenderer() &amp;&amp; view().isInChildFrameWithFrameFlattening())
353         frame().ownerRenderer()-&gt;setNeedsLayout(MarkContainingBlockChain);
354 
355     Seconds delay = frame().document()-&gt;minimumLayoutDelay();
356     if (m_layoutTimer.isActive() &amp;&amp; m_delayedLayout &amp;&amp; !delay)
357         unscheduleLayout();
</pre>
<hr />
<pre>
502         return;
503     layoutRoot.adjustComputedFontSizesOnBlocks(minimumZoomFontSize, textAutosizingWidth);
504     if (!layoutRoot.needsLayout())
505         return;
506     LOG(TextAutosizing, &quot;Text Autosizing: minimumZoomFontSize=%.2f textAutosizingWidth=%.2f&quot;, minimumZoomFontSize, textAutosizingWidth);
507     layoutRoot.layout();
508 }
509 #endif
510 
511 void FrameViewLayoutContext::updateStyleForLayout()
512 {
513     Document&amp; document = *frame().document();
514 
515     // FIXME: This shouldn&#39;t be necessary, but see rdar://problem/36670246.
516     if (!document.styleScope().resolverIfExists())
517         document.styleScope().didChangeStyleSheetEnvironment();
518 
519     // Viewport-dependent media queries may cause us to need completely different style information.
520     document.styleScope().evaluateMediaQueriesForViewportChange();
521 
<span class="line-modified">522     document.evaluateMediaQueryList();</span>
523     // If there is any pagination to apply, it will affect the RenderView&#39;s style, so we should
524     // take care of that now.
525     view().applyPaginationToViewport();
526     // Always ensure our style info is up-to-date. This can happen in situations where
527     // the layout beats any sort of style recalc update that needs to occur.
528     document.updateStyleIfNeeded();
529 }
530 
531 bool FrameViewLayoutContext::handleLayoutWithFrameFlatteningIfNeeded()
532 {
533     if (!view().isInChildFrameWithFrameFlattening())
534         return false;
535 
536     startLayoutAtMainFrameViewIfNeeded();
537     auto* layoutRoot = subtreeLayoutRoot() ? subtreeLayoutRoot() : frame().document()-&gt;renderView();
538     return !layoutRoot || !layoutRoot-&gt;needsLayout();
539 }
540 
541 void FrameViewLayoutContext::startLayoutAtMainFrameViewIfNeeded()
542 {
</pre>
<hr />
<pre>
558     while (parentView-&gt;parentFrameView())
559         parentView = parentView-&gt;parentFrameView();
560 
561     LOG(Layout, &quot;  frame flattening, starting from root&quot;);
562     parentView-&gt;layoutContext().layout();
563 }
564 
565 LayoutSize FrameViewLayoutContext::layoutDelta() const
566 {
567     if (auto* layoutState = this-&gt;layoutState())
568         return layoutState-&gt;layoutDelta();
569     return { };
570 }
571 
572 void FrameViewLayoutContext::addLayoutDelta(const LayoutSize&amp; delta)
573 {
574     if (auto* layoutState = this-&gt;layoutState())
575         layoutState-&gt;addLayoutDelta(delta);
576 }
577 
<span class="line-modified">578 #if !ASSERT_DISABLED</span>
579 bool FrameViewLayoutContext::layoutDeltaMatches(const LayoutSize&amp; delta)
580 {
581     if (auto* layoutState = this-&gt;layoutState())
582         return layoutState-&gt;layoutDeltaMatches(delta);
583     return false;
584 }
585 #endif
586 
587 RenderLayoutState* FrameViewLayoutContext::layoutState() const
588 {
589     if (m_layoutStateStack.isEmpty())
590         return nullptr;
591     return m_layoutStateStack.last().get();
592 }
593 
594 void FrameViewLayoutContext::pushLayoutState(RenderElement&amp; root)
595 {
596     ASSERT(!m_paintOffsetCacheDisableCount);
597     ASSERT(!layoutState());
598 
</pre>
</td>
<td>
<hr />
<pre>
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FrameViewLayoutContext.h&quot;
 28 
 29 #include &quot;CSSAnimationController.h&quot;
 30 #include &quot;DebugPageOverlays.h&quot;
 31 #include &quot;Document.h&quot;
 32 #include &quot;FrameView.h&quot;
 33 #include &quot;InspectorInstrumentation.h&quot;
 34 #include &quot;LayoutDisallowedScope.h&quot;
 35 #include &quot;Logging.h&quot;
 36 #include &quot;RenderElement.h&quot;
 37 #include &quot;RenderLayoutState.h&quot;
 38 #include &quot;RenderView.h&quot;
 39 #include &quot;RuntimeEnabledFeatures.h&quot;
 40 #include &quot;ScriptDisallowedScope.h&quot;
 41 #include &quot;Settings.h&quot;
 42 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
<span class="line-added"> 43 #include &quot;DisplayBox.h&quot;</span>
<span class="line-added"> 44 #include &quot;InvalidationContext.h&quot;</span>
<span class="line-added"> 45 #include &quot;InvalidationState.h&quot;</span>
<span class="line-added"> 46 #include &quot;LayoutContext.h&quot;</span>
 47 #include &quot;LayoutState.h&quot;
<span class="line-added"> 48 #include &quot;LayoutTreeBuilder.h&quot;</span>
<span class="line-added"> 49 #include &quot;RenderDescendantIterator.h&quot;</span>
 50 #endif
 51 
 52 #include &lt;wtf/SetForScope.h&gt;
 53 #include &lt;wtf/SystemTracing.h&gt;
 54 #include &lt;wtf/text/TextStream.h&gt;
 55 
 56 namespace WebCore {
 57 
 58 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
<span class="line-modified"> 59 void FrameViewLayoutContext::layoutUsingFormattingContext()</span>
 60 {
 61     if (!RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextEnabled())
 62         return;
<span class="line-modified"> 63 </span>
<span class="line-added"> 64     // FrameView::setContentsSize temporary disables layout.</span>
<span class="line-added"> 65     if (m_disableSetNeedsLayoutCount)</span>
<span class="line-added"> 66         return;</span>
<span class="line-added"> 67 </span>
<span class="line-added"> 68     auto&amp; renderView = *this-&gt;renderView();</span>
<span class="line-added"> 69     if (!m_layoutTreeContent) {</span>
<span class="line-added"> 70         m_layoutTreeContent = Layout::TreeBuilder::buildLayoutTree(renderView);</span>
<span class="line-added"> 71         // FIXME: New layout tree requires a new state for now.</span>
<span class="line-added"> 72         m_layoutState = nullptr;</span>
<span class="line-added"> 73     }</span>
<span class="line-added"> 74     if (!m_layoutState)</span>
<span class="line-added"> 75         m_layoutState = makeUnique&lt;Layout::LayoutState&gt;(*document(), m_layoutTreeContent-&gt;rootLayoutBox());</span>
<span class="line-added"> 76 </span>
<span class="line-added"> 77     // FIXME: This is not the real invalidation yet.</span>
<span class="line-added"> 78     auto invalidationState = Layout::InvalidationState { };</span>
<span class="line-added"> 79     auto layoutContext = Layout::LayoutContext { *m_layoutState };</span>
<span class="line-added"> 80     layoutContext.layout(view().layoutSize(), invalidationState);</span>
<span class="line-added"> 81 </span>
<span class="line-added"> 82     // Clean up the render tree state when we don&#39;t run RenderView::layout.</span>
<span class="line-added"> 83     if (renderView.needsLayout()) {</span>
<span class="line-added"> 84         auto contentSize = m_layoutState-&gt;displayBoxForLayoutBox(*m_layoutState-&gt;root().firstChild()).size();</span>
<span class="line-added"> 85         renderView.setSize(contentSize);</span>
<span class="line-added"> 86         renderView.repaintViewRectangle({ 0, 0, contentSize.width(), contentSize.height() });</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88         for (auto&amp; descendant : descendantsOfType&lt;RenderObject&gt;(renderView))</span>
<span class="line-added"> 89             descendant.clearNeedsLayout();</span>
<span class="line-added"> 90         renderView.clearNeedsLayout();</span>
<span class="line-added"> 91     }</span>
<span class="line-added"> 92 </span>
<span class="line-added"> 93 #ifndef NDEBUG</span>
<span class="line-added"> 94     Layout::LayoutContext::verifyAndOutputMismatchingLayoutTree(*m_layoutState, renderView);</span>
<span class="line-added"> 95 #endif</span>
<span class="line-added"> 96 }</span>
<span class="line-added"> 97 </span>
<span class="line-added"> 98 void FrameViewLayoutContext::invalidateLayoutTreeContent()</span>
<span class="line-added"> 99 {</span>
<span class="line-added">100     m_layoutTreeContent = nullptr;</span>
101 }
102 #endif
103 
104 static bool isObjectAncestorContainerOf(RenderElement&amp; ancestor, RenderElement&amp; descendant)
105 {
106     for (auto* renderer = &amp;descendant; renderer; renderer = renderer-&gt;container()) {
107         if (renderer == &amp;ancestor)
108             return true;
109     }
110     return false;
111 }
112 
113 #ifndef NDEBUG
114 class RenderTreeNeedsLayoutChecker {
115 public :
116     RenderTreeNeedsLayoutChecker(const RenderElement&amp; layoutRoot)
117         : m_layoutRoot(layoutRoot)
118     {
119     }
120 
</pre>
<hr />
<pre>
171 FrameViewLayoutContext::FrameViewLayoutContext(FrameView&amp; frameView)
172     : m_frameView(frameView)
173     , m_layoutTimer(*this, &amp;FrameViewLayoutContext::layoutTimerFired)
174     , m_asynchronousTasksTimer(*this, &amp;FrameViewLayoutContext::runAsynchronousTasks)
175 {
176 }
177 
178 FrameViewLayoutContext::~FrameViewLayoutContext()
179 {
180 }
181 
182 void FrameViewLayoutContext::layout()
183 {
184     LOG_WITH_STREAM(Layout, stream &lt;&lt; &quot;FrameView &quot; &lt;&lt; &amp;view() &lt;&lt; &quot; FrameViewLayoutContext::layout() with size &quot; &lt;&lt; view().layoutSize());
185 
186     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!frame().document()-&gt;inRenderTreeUpdate());
187     ASSERT(LayoutDisallowedScope::isLayoutAllowed());
188     ASSERT(!view().isPainting());
189     ASSERT(frame().view() == &amp;view());
190     ASSERT(frame().document());
<span class="line-modified">191     ASSERT(frame().document()-&gt;backForwardCacheState() == Document::NotInBackForwardCache</span>
<span class="line-modified">192         || frame().document()-&gt;backForwardCacheState() == Document::AboutToEnterBackForwardCache);</span>
193     if (!canPerformLayout()) {
194         LOG(Layout, &quot;  is not allowed, bailing&quot;);
195         return;
196     }
197 
198     Ref&lt;FrameView&gt; protectView(view());
199     LayoutScope layoutScope(*this);
200     TraceScope tracingScope(LayoutStart, LayoutEnd);
<span class="line-modified">201     InspectorInstrumentation::willLayout(view().frame());</span>
202     AnimationUpdateBlock animationUpdateBlock(&amp;view().frame().animation());
203     WeakPtr&lt;RenderElement&gt; layoutRoot;
204 
205     m_layoutTimer.stop();
206     m_delayedLayout = false;
207     m_setNeedsLayoutWasDeferred = false;
208 
209 #if !LOG_DISABLED
210     if (m_firstLayout &amp;&amp; !frame().ownerElement())
211         LOG(Layout, &quot;FrameView %p elapsed time before first layout: %.3fs&quot;, this, document()-&gt;timeSinceDocumentCreation().value());
212 #endif
213 #if PLATFORM(IOS_FAMILY)
214     if (view().updateFixedPositionLayoutRect() &amp;&amp; subtreeLayoutRoot())
215         convertSubtreeLayoutToFullLayout();
216 #endif
217     if (handleLayoutWithFrameFlatteningIfNeeded())
218         return;
219 
220     {
221         SetForScope&lt;LayoutPhase&gt; layoutPhase(m_layoutPhase, LayoutPhase::InPreLayout);
</pre>
<hr />
<pre>
230 
231         view().autoSizeIfEnabled();
232         if (!renderView())
233             return;
234 
235         layoutRoot = makeWeakPtr(subtreeLayoutRoot() ? subtreeLayoutRoot() : renderView());
236         m_needsFullRepaint = is&lt;RenderView&gt;(layoutRoot.get()) &amp;&amp; (m_firstLayout || renderView()-&gt;printing());
237         view().willDoLayout(layoutRoot);
238         m_firstLayout = false;
239     }
240     {
241         SetForScope&lt;LayoutPhase&gt; layoutPhase(m_layoutPhase, LayoutPhase::InRenderTreeLayout);
242         ScriptDisallowedScope::InMainThread scriptDisallowedScope;
243         SubtreeLayoutStateMaintainer subtreeLayoutStateMaintainer(subtreeLayoutRoot());
244         RenderView::RepaintRegionAccumulator repaintRegionAccumulator(renderView());
245 #ifndef NDEBUG
246         RenderTreeNeedsLayoutChecker checker(*layoutRoot);
247 #endif
248         layoutRoot-&gt;layout();
249 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
<span class="line-modified">250         layoutUsingFormattingContext();</span>
251 #endif
252         ++m_layoutCount;
253 #if ENABLE(TEXT_AUTOSIZING)
254         applyTextSizingIfNeeded(*layoutRoot.get());
255 #endif
256         clearSubtreeLayoutRoot();
257     }
258     {
259         SetForScope&lt;LayoutPhase&gt; layoutPhase(m_layoutPhase, LayoutPhase::InViewSizeAdjust);
260         if (is&lt;RenderView&gt;(layoutRoot.get()) &amp;&amp; !renderView()-&gt;printing()) {
261             // This is to protect m_needsFullRepaint&#39;s value when layout() is getting re-entered through adjustViewSize().
262             SetForScope&lt;bool&gt; needsFullRepaint(m_needsFullRepaint);
263             view().adjustViewSize();
264             // FIXME: Firing media query callbacks synchronously on nested frames could produced a detached FrameView here by
265             // navigating away from the current document (see webkit.org/b/173329).
266             if (view().hasOneRef())
267                 return;
268         }
269     }
270     {
271         SetForScope&lt;LayoutPhase&gt; layoutPhase(m_layoutPhase, LayoutPhase::InPostLayout);
272         if (m_needsFullRepaint)
273             renderView()-&gt;repaintRootContents();
274         ASSERT(!layoutRoot-&gt;needsLayout());
275         view().didLayout(layoutRoot);
276         runOrScheduleAsynchronousTasks();
277     }
<span class="line-modified">278     InspectorInstrumentation::didLayout(view().frame(), *layoutRoot);</span>
279     DebugPageOverlays::didLayout(view().frame());
280 }
281 
282 void FrameViewLayoutContext::runOrScheduleAsynchronousTasks()
283 {
284     if (m_asynchronousTasksTimer.isActive())
285         return;
286 
287     if (view().isInChildFrameWithFrameFlattening()) {
288         // While flattening frames, we defer post layout tasks to avoid getting stuck in a cycle,
289         // except updateWidgetPositions() which is required to kick off subframe layout in certain cases.
290         if (!m_inAsynchronousTasks)
291             view().updateWidgetPositions();
292         m_asynchronousTasksTimer.startOneShot(0_s);
293         return;
294     }
295 
296     // If we are already in performPostLayoutTasks(), defer post layout tasks until after we return
297     // to avoid re-entrancy.
298     if (m_inAsynchronousTasks) {
</pre>
<hr />
<pre>
360         ASSERT(!frame().document()-&gt;inHitTesting());
361         renderView-&gt;setNeedsLayout();
362         scheduleLayout();
363     }
364 }
365 
366 void FrameViewLayoutContext::enableSetNeedsLayout()
367 {
368     ASSERT(m_disableSetNeedsLayoutCount);
369     if (!--m_disableSetNeedsLayoutCount)
370         m_setNeedsLayoutWasDeferred = false; // FIXME: Find a way to make the deferred layout actually happen.
371 }
372 
373 void FrameViewLayoutContext::disableSetNeedsLayout()
374 {
375     ++m_disableSetNeedsLayoutCount;
376 }
377 
378 void FrameViewLayoutContext::scheduleLayout()
379 {
<span class="line-modified">380     // FIXME: We should assert the page is not in the back/forward cache, but that is causing</span>
381     // too many false assertions. See &lt;rdar://problem/7218118&gt;.
382     ASSERT(frame().view() == &amp;view());
383 
384     if (subtreeLayoutRoot())
385         convertSubtreeLayoutToFullLayout();
386     if (!isLayoutSchedulingEnabled())
387         return;
388     if (!needsLayout())
389         return;
390     if (!frame().document()-&gt;shouldScheduleLayout())
391         return;
392     InspectorInstrumentation::didInvalidateLayout(frame());
393     // When frame flattening is enabled, the contents of the frame could affect the layout of the parent frames.
394     // Also invalidate parent frame starting from the owner element of this frame.
395     if (frame().ownerRenderer() &amp;&amp; view().isInChildFrameWithFrameFlattening())
396         frame().ownerRenderer()-&gt;setNeedsLayout(MarkContainingBlockChain);
397 
398     Seconds delay = frame().document()-&gt;minimumLayoutDelay();
399     if (m_layoutTimer.isActive() &amp;&amp; m_delayedLayout &amp;&amp; !delay)
400         unscheduleLayout();
</pre>
<hr />
<pre>
545         return;
546     layoutRoot.adjustComputedFontSizesOnBlocks(minimumZoomFontSize, textAutosizingWidth);
547     if (!layoutRoot.needsLayout())
548         return;
549     LOG(TextAutosizing, &quot;Text Autosizing: minimumZoomFontSize=%.2f textAutosizingWidth=%.2f&quot;, minimumZoomFontSize, textAutosizingWidth);
550     layoutRoot.layout();
551 }
552 #endif
553 
554 void FrameViewLayoutContext::updateStyleForLayout()
555 {
556     Document&amp; document = *frame().document();
557 
558     // FIXME: This shouldn&#39;t be necessary, but see rdar://problem/36670246.
559     if (!document.styleScope().resolverIfExists())
560         document.styleScope().didChangeStyleSheetEnvironment();
561 
562     // Viewport-dependent media queries may cause us to need completely different style information.
563     document.styleScope().evaluateMediaQueriesForViewportChange();
564 
<span class="line-modified">565     document.updateElementsAffectedByMediaQueries();</span>
566     // If there is any pagination to apply, it will affect the RenderView&#39;s style, so we should
567     // take care of that now.
568     view().applyPaginationToViewport();
569     // Always ensure our style info is up-to-date. This can happen in situations where
570     // the layout beats any sort of style recalc update that needs to occur.
571     document.updateStyleIfNeeded();
572 }
573 
574 bool FrameViewLayoutContext::handleLayoutWithFrameFlatteningIfNeeded()
575 {
576     if (!view().isInChildFrameWithFrameFlattening())
577         return false;
578 
579     startLayoutAtMainFrameViewIfNeeded();
580     auto* layoutRoot = subtreeLayoutRoot() ? subtreeLayoutRoot() : frame().document()-&gt;renderView();
581     return !layoutRoot || !layoutRoot-&gt;needsLayout();
582 }
583 
584 void FrameViewLayoutContext::startLayoutAtMainFrameViewIfNeeded()
585 {
</pre>
<hr />
<pre>
601     while (parentView-&gt;parentFrameView())
602         parentView = parentView-&gt;parentFrameView();
603 
604     LOG(Layout, &quot;  frame flattening, starting from root&quot;);
605     parentView-&gt;layoutContext().layout();
606 }
607 
608 LayoutSize FrameViewLayoutContext::layoutDelta() const
609 {
610     if (auto* layoutState = this-&gt;layoutState())
611         return layoutState-&gt;layoutDelta();
612     return { };
613 }
614 
615 void FrameViewLayoutContext::addLayoutDelta(const LayoutSize&amp; delta)
616 {
617     if (auto* layoutState = this-&gt;layoutState())
618         layoutState-&gt;addLayoutDelta(delta);
619 }
620 
<span class="line-modified">621 #if ASSERT_ENABLED</span>
622 bool FrameViewLayoutContext::layoutDeltaMatches(const LayoutSize&amp; delta)
623 {
624     if (auto* layoutState = this-&gt;layoutState())
625         return layoutState-&gt;layoutDeltaMatches(delta);
626     return false;
627 }
628 #endif
629 
630 RenderLayoutState* FrameViewLayoutContext::layoutState() const
631 {
632     if (m_layoutStateStack.isEmpty())
633         return nullptr;
634     return m_layoutStateStack.last().get();
635 }
636 
637 void FrameViewLayoutContext::pushLayoutState(RenderElement&amp; root)
638 {
639     ASSERT(!m_paintOffsetCacheDisableCount);
640     ASSERT(!layoutState());
641 
</pre>
</td>
</tr>
</table>
<center><a href="FrameView.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FrameViewLayoutContext.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
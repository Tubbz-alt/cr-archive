<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/gpu/Texture.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="GPUTextureUsage.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="Texture.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/gpu/Texture.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 32,62 ***</span>
  
  #if ENABLE(ACCELERATED_2D_CANVAS)
  
  #include &quot;Texture.h&quot;
  
<span class="line-modified">! #include &quot;Extensions3D.h&quot;</span>
  #include &quot;FloatRect.h&quot;
<span class="line-modified">! #include &quot;GraphicsContext3D.h&quot;</span>
  #include &quot;IntRect.h&quot;
  #include &lt;algorithm&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/UniqueArray.h&gt;
  
  namespace WebCore {
  
<span class="line-modified">! Texture::Texture(GraphicsContext3D* context, std::unique_ptr&lt;Vector&lt;unsigned&gt;&gt; tileTextureIds, Format format, int width, int height, int maxTextureSize)</span>
      : m_context(context)
      , m_format(format)
      , m_tiles(IntSize(maxTextureSize, maxTextureSize), IntSize(width, height), true)
      , m_tileTextureIds(WTFMove(tileTextureIds))
  {
  }
  
  Texture::~Texture()
  {
<span class="line-modified">!     for (unsigned int i = 0; i &lt; m_tileTextureIds-&gt;size(); i++)</span>
          m_context-&gt;deleteTexture(m_tileTextureIds-&gt;at(i));
  }
  
<span class="line-modified">! static void convertFormat(GraphicsContext3D* context, Texture::Format format, unsigned int* glFormat, unsigned int* glType, bool* swizzle)</span>
  {
      *swizzle = false;
      switch (format) {
      case Texture::RGBA8:
<span class="line-modified">!         *glFormat = GraphicsContext3D::RGBA;</span>
<span class="line-modified">!         *glType = GraphicsContext3D::UNSIGNED_BYTE;</span>
          break;
      case Texture::BGRA8:
          if (context-&gt;getExtensions().supports(&quot;GL_EXT_texture_format_BGRA8888&quot;)) {
<span class="line-modified">!             *glFormat = Extensions3D::BGRA_EXT;</span>
<span class="line-modified">!             *glType = GraphicsContext3D::UNSIGNED_BYTE;</span>
          } else {
<span class="line-modified">!             *glFormat = GraphicsContext3D::RGBA;</span>
<span class="line-modified">!             *glType = GraphicsContext3D::UNSIGNED_BYTE;</span>
              *swizzle = true;
          }
          break;
      default:
          ASSERT_NOT_REACHED();
          break;
      }
  }
  
<span class="line-modified">! RefPtr&lt;Texture&gt; Texture::create(GraphicsContext3D* context, Format format, int width, int height)</span>
  {
      int maxTextureSize = 0;
<span class="line-modified">!     context-&gt;getIntegerv(GraphicsContext3D::MAX_TEXTURE_SIZE, &amp;maxTextureSize);</span>
      TilingData tiling(IntSize(maxTextureSize, maxTextureSize), IntSize(width, height), true);
  
      // Check for overflow.
      int numTiles = tiling.numTilesX() * tiling.numTilesY();
      if (numTiles / tiling.numTilesX() != tiling.numTilesY()) {
<span class="line-new-header">--- 32,62 ---</span>
  
  #if ENABLE(ACCELERATED_2D_CANVAS)
  
  #include &quot;Texture.h&quot;
  
<span class="line-modified">! #include &quot;ExtensionsGL.h&quot;</span>
  #include &quot;FloatRect.h&quot;
<span class="line-modified">! #include &quot;GraphicsContextGLOpenGL.h&quot;</span>
  #include &quot;IntRect.h&quot;
  #include &lt;algorithm&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/UniqueArray.h&gt;
  
  namespace WebCore {
  
<span class="line-modified">! Texture::Texture(GraphicsContextGLOpenGL* context, std::unique_ptr&lt;Vector&lt;unsigned&gt;&gt; tileTextureIds, Format format, int width, int height, int maxTextureSize)</span>
      : m_context(context)
      , m_format(format)
      , m_tiles(IntSize(maxTextureSize, maxTextureSize), IntSize(width, height), true)
      , m_tileTextureIds(WTFMove(tileTextureIds))
  {
  }
  
  Texture::~Texture()
  {
<span class="line-modified">!     for (unsigned i = 0; i &lt; m_tileTextureIds-&gt;size(); i++)</span>
          m_context-&gt;deleteTexture(m_tileTextureIds-&gt;at(i));
  }
  
<span class="line-modified">! static void convertFormat(GraphicsContextGLOpenGL* context, Texture::Format format, unsigned* glFormat, unsigned* glType, bool* swizzle)</span>
  {
      *swizzle = false;
      switch (format) {
      case Texture::RGBA8:
<span class="line-modified">!         *glFormat = GraphicsContextGL::RGBA;</span>
<span class="line-modified">!         *glType = GraphicsContextGL::UNSIGNED_BYTE;</span>
          break;
      case Texture::BGRA8:
          if (context-&gt;getExtensions().supports(&quot;GL_EXT_texture_format_BGRA8888&quot;)) {
<span class="line-modified">!             *glFormat = ExtensionsGL::BGRA_EXT;</span>
<span class="line-modified">!             *glType = GraphicsContextGL::UNSIGNED_BYTE;</span>
          } else {
<span class="line-modified">!             *glFormat = GraphicsContextGL::RGBA;</span>
<span class="line-modified">!             *glType = GraphicsContextGL::UNSIGNED_BYTE;</span>
              *swizzle = true;
          }
          break;
      default:
          ASSERT_NOT_REACHED();
          break;
      }
  }
  
<span class="line-modified">! RefPtr&lt;Texture&gt; Texture::create(GraphicsContextGLOpenGL* context, Format format, int width, int height)</span>
  {
      int maxTextureSize = 0;
<span class="line-modified">!     context-&gt;getIntegerv(GraphicsContextGL::MAX_TEXTURE_SIZE, &amp;maxTextureSize);</span>
      TilingData tiling(IntSize(maxTextureSize, maxTextureSize), IntSize(width, height), true);
  
      // Check for overflow.
      int numTiles = tiling.numTilesX() * tiling.numTilesY();
      if (numTiles / tiling.numTilesX() != tiling.numTilesY()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 113,12 ***</span>
  
          unsigned int glFormat = 0;
          unsigned int glType = 0;
          bool swizzle;
          convertFormat(context, format, &amp;glFormat, &amp;glType, &amp;swizzle);
<span class="line-modified">!         context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, textureId);</span>
<span class="line-modified">!         context-&gt;texImage2DResourceSafe(GraphicsContext3D::TEXTURE_2D, 0, glFormat,</span>
                                          tileBoundsWithBorder.width(),
                                          tileBoundsWithBorder.height(),
                                          0, glFormat, glType);
      }
      return adoptRef(new Texture(context, WTFMove(textureIds), format, width, height, maxTextureSize));
<span class="line-new-header">--- 113,12 ---</span>
  
          unsigned int glFormat = 0;
          unsigned int glType = 0;
          bool swizzle;
          convertFormat(context, format, &amp;glFormat, &amp;glType, &amp;swizzle);
<span class="line-modified">!         context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, textureId);</span>
<span class="line-modified">!         context-&gt;texImage2DResourceSafe(GraphicsContextGL::TEXTURE_2D, 0, glFormat,</span>
                                          tileBoundsWithBorder.width(),
                                          tileBoundsWithBorder.height(),
                                          0, glFormat, glType);
      }
      return adoptRef(new Texture(context, WTFMove(textureIds), format, width, height, maxTextureSize));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 163,11 ***</span>
      unsigned int glFormat = 0;
      unsigned int glType = 0;
      bool swizzle;
      convertFormat(m_context, m_format, &amp;glFormat, &amp;glType, &amp;swizzle);
      if (swizzle) {
<span class="line-modified">!         ASSERT(glFormat == GraphicsContext3D::RGBA &amp;&amp; glType == GraphicsContext3D::UNSIGNED_BYTE);</span>
          // FIXME:  This could use PBO&#39;s to save doing an extra copy here.
      }
      int tempBuffSize = // Temporary buffer size is the smaller of the max texture size or the updateRectSanitized
          std::min(m_tiles.maxTextureSize().width(), m_tiles.borderTexels() + updateRectSanitized.width()) *
          std::min(m_tiles.maxTextureSize().height(), m_tiles.borderTexels() + updateRectSanitized.height());
<span class="line-new-header">--- 163,11 ---</span>
      unsigned int glFormat = 0;
      unsigned int glType = 0;
      bool swizzle;
      convertFormat(m_context, m_format, &amp;glFormat, &amp;glType, &amp;swizzle);
      if (swizzle) {
<span class="line-modified">!         ASSERT(glFormat == GraphicsContextGL::RGBA &amp;&amp; glType == GraphicsContextGL::UNSIGNED_BYTE);</span>
          // FIXME:  This could use PBO&#39;s to save doing an extra copy here.
      }
      int tempBuffSize = // Temporary buffer size is the smaller of the max texture size or the updateRectSanitized
          std::min(m_tiles.maxTextureSize().width(), m_tiles.borderTexels() + updateRectSanitized.width()) *
          std::min(m_tiles.maxTextureSize().height(), m_tiles.borderTexels() + updateRectSanitized.height());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 199,26 ***</span>
              uploadBuff = copySubRect&lt;false&gt;(
              pixels32, updateRectIntersected.x(), updateRectIntersected.y(),
              tempBuff.get(), updateRectIntersected.width(), updateRectIntersected.height(), m_tiles.totalSize().width());
          }
  
<span class="line-modified">!         m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, m_tileTextureIds-&gt;at(tile));</span>
<span class="line-modified">!         m_context-&gt;texSubImage2D(GraphicsContext3D::TEXTURE_2D, 0 /* level */,</span>
              dstRect.x(),
              dstRect.y(),
              updateRectIntersected.width(),
              updateRectIntersected.height(), glFormat, glType, uploadBuff);
      }
  }
  
  void Texture::bindTile(int tile)
  {
<span class="line-modified">!     m_context-&gt;bindTexture(GraphicsContext3D::TEXTURE_2D, m_tileTextureIds-&gt;at(tile));</span>
<span class="line-modified">!     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_MIN_FILTER, GraphicsContext3D::LINEAR);</span>
<span class="line-modified">!     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_MAG_FILTER, GraphicsContext3D::LINEAR);</span>
<span class="line-modified">!     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_WRAP_S, GraphicsContext3D::CLAMP_TO_EDGE);</span>
<span class="line-modified">!     m_context-&gt;texParameteri(GraphicsContext3D::TEXTURE_2D, GraphicsContext3D::TEXTURE_WRAP_T, GraphicsContext3D::CLAMP_TO_EDGE);</span>
  }
  
  }
  
  #endif
<span class="line-new-header">--- 199,26 ---</span>
              uploadBuff = copySubRect&lt;false&gt;(
              pixels32, updateRectIntersected.x(), updateRectIntersected.y(),
              tempBuff.get(), updateRectIntersected.width(), updateRectIntersected.height(), m_tiles.totalSize().width());
          }
  
<span class="line-modified">!         m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, m_tileTextureIds-&gt;at(tile));</span>
<span class="line-modified">!         m_context-&gt;texSubImage2D(GraphicsContextGL::TEXTURE_2D, 0 /* level */,</span>
              dstRect.x(),
              dstRect.y(),
              updateRectIntersected.width(),
              updateRectIntersected.height(), glFormat, glType, uploadBuff);
      }
  }
  
  void Texture::bindTile(int tile)
  {
<span class="line-modified">!     m_context-&gt;bindTexture(GraphicsContextGL::TEXTURE_2D, m_tileTextureIds-&gt;at(tile));</span>
<span class="line-modified">!     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_MIN_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="line-modified">!     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_MAG_FILTER, GraphicsContextGL::LINEAR);</span>
<span class="line-modified">!     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_WRAP_S, GraphicsContextGL::CLAMP_TO_EDGE);</span>
<span class="line-modified">!     m_context-&gt;texParameteri(GraphicsContextGL::TEXTURE_2D, GraphicsContextGL::TEXTURE_WRAP_T, GraphicsContextGL::CLAMP_TO_EDGE);</span>
  }
  
  }
  
  #endif
</pre>
<center><a href="GPUTextureUsage.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="Texture.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/mediastream/AudioTrackPrivateMediaStream.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017-2020 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;AudioTrackPrivateMediaStream.h&quot;
 28 
 29 #if ENABLE(VIDEO_TRACK) &amp;&amp; ENABLE(MEDIA_STREAM)
 30 
 31 #include &quot;AudioMediaStreamTrackRenderer.h&quot;
 32 #include &quot;Logging.h&quot;
 33 
 34 namespace WebCore {
 35 
 36 AudioTrackPrivateMediaStream::AudioTrackPrivateMediaStream(MediaStreamTrackPrivate&amp; track)
 37     : m_streamTrack(track)
 38     , m_id(track.id())
 39     , m_label(track.label())
 40     , m_timelineOffset(MediaTime::invalidTime())
 41     , m_renderer { AudioMediaStreamTrackRenderer::create() }
 42 {
 43     track.addObserver(*this);
 44 }
 45 
 46 AudioTrackPrivateMediaStream::~AudioTrackPrivateMediaStream()
 47 {
 48     clear();
 49 }
 50 
 51 #if !RELEASE_LOG_DISABLED
 52 void AudioTrackPrivateMediaStream::setLogger(const Logger&amp; logger, const void* identifier)
 53 {
 54     TrackPrivateBase::setLogger(logger, identifier);
 55     m_renderer-&gt;setLogger(logger, identifier);
 56 }
 57 #endif
 58 
 59 void AudioTrackPrivateMediaStream::clear()
 60 {
 61     if (m_isCleared)
 62         return;
 63 
 64     m_isCleared = true;
 65     streamTrack().removeObserver(*this);
 66 
 67     m_renderer-&gt;clear();
 68 }
 69 
 70 void AudioTrackPrivateMediaStream::playInternal()
 71 {
 72     ASSERT(isMainThread());
 73 
 74     if (m_isPlaying)
 75         return;
 76 
 77     m_isPlaying = true;
 78     m_autoPlay = false;
 79 
 80     m_renderer-&gt;start();
 81 }
 82 
 83 void AudioTrackPrivateMediaStream::play()
 84 {
 85     playInternal();
 86 }
 87 
 88 void AudioTrackPrivateMediaStream::pause()
 89 {
 90     ASSERT(isMainThread());
 91 
 92     if (!m_isPlaying)
 93         return;
 94 
 95     m_isPlaying = false;
 96     m_autoPlay = false;
 97 
 98     m_renderer-&gt;stop();
 99 }
100 
101 void AudioTrackPrivateMediaStream::setVolume(float volume)
102 {
103     m_renderer-&gt;setVolume(volume);
104 }
105 
106 float AudioTrackPrivateMediaStream::volume() const
107 {
108     return m_renderer-&gt;volume();
109 }
110 
111 // May get called on a background thread.
112 void AudioTrackPrivateMediaStream::audioSamplesAvailable(MediaStreamTrackPrivate&amp;, const MediaTime&amp; sampleTime, const PlatformAudioData&amp; audioData, const AudioStreamDescription&amp; description, size_t sampleCount)
113 {
114     if (!m_isPlaying) {
115         m_renderer-&gt;stop();
116         return;
117     }
118 
119     m_renderer-&gt;pushSamples(sampleTime, audioData, description, sampleCount);
120 
121     if (m_autoPlay &amp;&amp; !m_hasStartedAutoplay) {
122         m_hasStartedAutoplay = true;
123         callOnMainThread([this, protectedThis = makeRef(*this)] {
124             if (m_autoPlay)
125                 playInternal();
126         });
127     }
128 }
129 
130 void AudioTrackPrivateMediaStream::trackMutedChanged(MediaStreamTrackPrivate&amp;)
131 {
132     updateRendererMutedState();
133 }
134 
135 void AudioTrackPrivateMediaStream::trackEnabledChanged(MediaStreamTrackPrivate&amp;)
136 {
137     updateRendererMutedState();
138 }
139 
140 void AudioTrackPrivateMediaStream::updateRendererMutedState()
141 {
142     m_renderer-&gt;setMuted(streamTrack().muted() || streamTrack().ended() || !streamTrack().enabled());
143 }
144 
145 void AudioTrackPrivateMediaStream::trackEnded(MediaStreamTrackPrivate&amp;)
146 {
147     pause();
148 }
149 
150 } // namespace WebCore
151 
152 #endif // ENABLE(VIDEO_TRACK) &amp;&amp; ENABLE(MEDIA_STREAM)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/PODIntervalTree.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2010 Google Inc. All rights reserved.
  3  * Copyright (C) 2019-2020 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1.  Redistributions of source code must retain the above copyright
 10  *     notice, this list of conditions and the following disclaimer.
 11  * 2.  Redistributions in binary form must reproduce the above copyright
 12  *     notice, this list of conditions and the following disclaimer in the
 13  *     documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 17  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 18  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 19  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 20  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 21  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 22  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 24  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;PODInterval.h&quot;
 30 #include &quot;PODRedBlackTree.h&quot;
 31 #include &lt;wtf/Optional.h&gt;
 32 #include &lt;wtf/Vector.h&gt;
 33 
 34 // FIXME: The prefix &quot;POD&quot; here isn&#39;t correct; this tree works with non-POD types.
 35 
 36 namespace WebCore {
 37 
 38 struct PODIntervalNodeUpdater;
 39 
 40 // An interval tree, which is a form of augmented red-black tree. It
 41 // supports efficient (O(lg n)) insertion, removal and querying of
 42 // intervals in the tree.
 43 template&lt;typename T, typename UserData&gt; class PODIntervalTree final : public PODRedBlackTree&lt;PODInterval&lt;T, UserData&gt;, PODIntervalNodeUpdater&gt; {
 44     WTF_MAKE_FAST_ALLOCATED;
 45 public:
 46     using IntervalType = PODInterval&lt;T, UserData&gt;;
 47     class OverlapsSearchAdapter;
 48 
 49     // Returns all intervals in the tree which overlap the given query interval, sorted by the &lt; operator.
 50     Vector&lt;IntervalType&gt; allOverlaps(const IntervalType&amp; interval) const
 51     {
 52         Vector&lt;IntervalType&gt; result;
 53         OverlapsSearchAdapter adapter(result, interval);
 54         allOverlapsWithAdapter(adapter);
 55         return result;
 56     }
 57 
 58     template&lt;typename AdapterType&gt; void allOverlapsWithAdapter(AdapterType&amp; adapter) const
 59     {
 60         searchForOverlapsFrom(this-&gt;root(), adapter);
 61     }
 62 
 63     Optional&lt;IntervalType&gt; nextIntervalAfter(const T&amp; point)
 64     {
 65         auto next = smallestNodeGreaterThanFrom(point, this-&gt;root());
 66         if (!next)
 67             return WTF::nullopt;
 68         return next-&gt;data();
 69     }
 70 
 71 #ifndef NDEBUG
 72 
 73     bool checkInvariants() const
 74     {
 75         if (!Base::checkInvariants())
 76             return false;
 77         if (!this-&gt;root())
 78             return true;
 79         return checkInvariantsFromNode(this-&gt;root(), nullptr);
 80     }
 81 
 82 #endif
 83 
 84 private:
 85     using Base = PODRedBlackTree&lt;PODInterval&lt;T, UserData&gt;, PODIntervalNodeUpdater&gt;;
 86     using IntervalNode = typename Base::Node;
 87 
 88     // Starting from the given node, adds all overlaps with the given
 89     // interval to the result vector. The intervals are sorted by
 90     // increasing low endpoint.
 91     template&lt;typename AdapterType&gt; void searchForOverlapsFrom(IntervalNode* node, AdapterType&amp; adapter) const
 92     {
 93         if (!node)
 94             return;
 95 
 96         // Because the intervals are sorted by left endpoint, inorder
 97         // traversal produces results sorted as desired.
 98 
 99         // See whether we need to traverse the left subtree.
100         IntervalNode* left = node-&gt;left();
101         if (left
102             // This is phrased this way to avoid the need for operator
103             // &lt;= on type T.
104             &amp;&amp; !(left-&gt;data().maxHigh() &lt; adapter.lowValue()))
105             searchForOverlapsFrom&lt;AdapterType&gt;(left, adapter);
106 
107         // Check for overlap with current node.
108         adapter.collectIfNeeded(node-&gt;data());
109 
110         // See whether we need to traverse the right subtree.
111         // This is phrased this way to avoid the need for operator &lt;=
112         // on type T.
113         if (!(adapter.highValue() &lt; node-&gt;data().low()))
114             searchForOverlapsFrom&lt;AdapterType&gt;(node-&gt;right(), adapter);
115     }
116 
117     IntervalNode* smallestNodeGreaterThanFrom(const T&amp; point, IntervalNode* node) const
118     {
119         if (!node)
120             return nullptr;
121 
122         if (!(point &lt; node-&gt;data().low()))
123             return smallestNodeGreaterThanFrom(point, node-&gt;right());
124 
125         if (auto left = smallestNodeGreaterThanFrom(point, node-&gt;right()))
126             return left;
127 
128         return node;
129     }
130 
131 #ifndef NDEBUG
132 
133     bool checkInvariantsFromNode(IntervalNode* node, T* currentMaxValue) const
134     {
135         // These assignments are only done in order to avoid requiring
136         // a default constructor on type T.
137         T leftMaxValue(node-&gt;data().maxHigh());
138         T rightMaxValue(node-&gt;data().maxHigh());
139         IntervalNode* left = node-&gt;left();
140         IntervalNode* right = node-&gt;right();
141         if (left) {
142             if (!checkInvariantsFromNode(left, &amp;leftMaxValue))
143                 return false;
144         }
145         if (right) {
146             if (!checkInvariantsFromNode(right, &amp;rightMaxValue))
147                 return false;
148         }
149         if (!left &amp;&amp; !right) {
150             // Base case.
151             if (currentMaxValue)
152                 *currentMaxValue = node-&gt;data().high();
153             return (node-&gt;data().high() == node-&gt;data().maxHigh());
154         }
155         T localMaxValue(node-&gt;data().maxHigh());
156         if (!left || !right) {
157             if (left)
158                 localMaxValue = leftMaxValue;
159             else
160                 localMaxValue = rightMaxValue;
161         } else
162             localMaxValue = (leftMaxValue &lt; rightMaxValue) ? rightMaxValue : leftMaxValue;
163         if (localMaxValue &lt; node-&gt;data().high())
164             localMaxValue = node-&gt;data().high();
165         if (!(localMaxValue == node-&gt;data().maxHigh())) {
166             TextStream stream;
167             stream &lt;&lt; &quot;localMaxValue=&quot; &lt;&lt; localMaxValue &lt;&lt; &quot;and data =&quot; &lt;&lt; node-&gt;data();
168             LOG_ERROR(&quot;PODIntervalTree verification failed at node 0x%p: %s&quot;,
169                 node, stream.release().utf8().data());
170             return false;
171         }
172         if (currentMaxValue)
173             *currentMaxValue = localMaxValue;
174         return true;
175     }
176 
177 #endif
178 
179 };
180 
181 template&lt;typename T, typename UserData&gt; class PODIntervalTree&lt;T, UserData&gt;::OverlapsSearchAdapter {
182 public:
183     using IntervalType = PODInterval&lt;T, UserData&gt;;
184 
185     OverlapsSearchAdapter(Vector&lt;IntervalType&gt;&amp; result, const IntervalType&amp; interval)
186         : m_result(result)
187         , m_interval(interval)
188     {
189     }
190 
191     const T&amp; lowValue() const { return m_interval.low(); }
192     const T&amp; highValue() const { return m_interval.high(); }
193     void collectIfNeeded(const IntervalType&amp; data) const
194     {
195         if (data.overlaps(m_interval))
196             m_result.append(data);
197     }
198 
199 private:
200     Vector&lt;IntervalType&gt;&amp; m_result;
201     const IntervalType&amp; m_interval;
202 };
203 
204 struct PODIntervalNodeUpdater {
205     template&lt;typename Node&gt; static bool update(Node&amp; node)
206     {
207         auto* curMax = &amp;node.data().high();
208         auto* left = node.left();
209         if (left) {
210             if (*curMax &lt; left-&gt;data().maxHigh())
211                 curMax = &amp;left-&gt;data().maxHigh();
212         }
213         auto* right = node.right();
214         if (right) {
215             if (*curMax &lt; right-&gt;data().maxHigh())
216                 curMax = &amp;right-&gt;data().maxHigh();
217         }
218         // This is phrased like this to avoid needing operator!= on type T.
219         if (!(*curMax == node.data().maxHigh())) {
220             node.data().setMaxHigh(*curMax);
221             return true;
222         }
223         return false;
224     }
225 };
226 
227 } // namespace WebCore
    </pre>
  </body>
</html>
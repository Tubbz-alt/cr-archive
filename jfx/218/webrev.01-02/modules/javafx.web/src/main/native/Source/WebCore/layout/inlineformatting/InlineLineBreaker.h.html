<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineLineBreaker.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 29 
 30 #include &quot;LayoutUnits.h&quot;
 31 
 32 namespace WebCore {
 33 
 34 class RenderStyle;
 35 
 36 namespace Layout {
 37 
 38 class InlineItem;
 39 class InlineTextItem;
 40 struct ContinuousContent;
 41 struct WrappedTextContent;
 42 
 43 class LineBreaker {
 44 public:
 45     struct PartialRun {
 46         unsigned length { 0 };
 47         InlineLayoutUnit logicalWidth { 0 };
 48         bool needsHyphen { false };
 49     };
 50     enum class IsEndOfLine { No, Yes };
 51     struct Result {
 52         enum class Action {
 53             Keep, // Keep content on the current line.
 54             Split, // Partial content is on the current line.
 55             Push, // Content is pushed to the next line.
 56             Revert // The current content overflows and can&#39;t get wrapped. The line needs to be reverted back to the last line wrapping opportunity.
 57         };
 58         struct PartialTrailingContent {
 59             size_t trailingRunIndex { 0 };
 60             Optional&lt;PartialRun&gt; partialRun; // nullopt partial run means the trailing run is a complete run.
 61         };
 62 
 63         Action action { Action::Keep };
 64         IsEndOfLine isEndOfLine { IsEndOfLine::No };
 65         Optional&lt;PartialTrailingContent&gt; partialTrailingContent { };
 66         const InlineItem* revertTo { nullptr };
 67     };
 68 
 69     struct Run {
 70         Run(const InlineItem&amp;, InlineLayoutUnit);
 71         Run(const Run&amp;);
 72         Run&amp; operator=(const Run&amp;);
 73 
 74         const InlineItem&amp; inlineItem;
 75         InlineLayoutUnit logicalWidth { 0 };
 76     };
 77     using RunList = Vector&lt;Run, 3&gt;;
 78 
 79     struct LineStatus {
 80         InlineLayoutUnit availableWidth { 0 };
 81         InlineLayoutUnit collapsibleWidth { 0 };
 82         bool lineHasFullyCollapsibleTrailingRun { false };
 83         bool lineIsEmpty { true };
 84     };
 85     Result shouldWrapInlineContent(const RunList&amp; candidateRuns, InlineLayoutUnit candidateContentLogicalWidth, const LineStatus&amp;);
 86     bool shouldWrapFloatBox(InlineLayoutUnit floatLogicalWidth, InlineLayoutUnit availableWidth, bool lineIsEmpty);
 87 
 88     void setHyphenationDisabled() { n_hyphenationIsDisabled = true; }
 89 
 90 private:
 91     // This struct represents the amount of content committed to line breaking at a time e.g.
 92     // text content &lt;span&gt;span1&lt;/span&gt;between&lt;span&gt;span2&lt;/span&gt;
 93     // [text][ ][content][ ][container start][span1][container end][between][container start][span2][container end]
 94     // -&gt; content chunks -&gt;
 95     // [text]
 96     // [ ]
 97     // [content]
 98     // [container start][span1][container end][between][container start][span2][container end]
 99     // see https://drafts.csswg.org/css-text-3/#line-break-details
100     Optional&lt;WrappedTextContent&gt; wrapTextContent(const RunList&amp;, const LineStatus&amp;) const;
101     Result tryWrappingInlineContent(const RunList&amp;, InlineLayoutUnit candidateContentLogicalWidth, const LineStatus&amp;) const;
102     Optional&lt;PartialRun&gt; tryBreakingTextRun(const Run&amp; overflowRun, InlineLayoutUnit availableWidth) const;
103 
104     enum class WordBreakRule {
105         NoBreak,
106         AtArbitraryPosition,
107         OnlyHyphenationAllowed
108     };
109     WordBreakRule wordBreakBehavior(const RenderStyle&amp;) const;
110     bool shouldKeepEndOfLineWhitespace(const ContinuousContent&amp;) const;
111     bool isContentWrappingAllowed(const ContinuousContent&amp;) const;
112 
113     bool n_hyphenationIsDisabled { false };
114     const InlineItem* m_lastWrapOpportunity { nullptr };
115 };
116 
117 inline LineBreaker::Run::Run(const InlineItem&amp; inlineItem, InlineLayoutUnit logicalWidth)
118     : inlineItem(inlineItem)
119     , logicalWidth(logicalWidth)
120 {
121 }
122 
123 inline LineBreaker::Run::Run(const Run&amp; other)
124     : inlineItem(other.inlineItem)
125     , logicalWidth(other.logicalWidth)
126 {
127 }
128 
129 }
130 }
131 #endif
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderText.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * (C) 1999 Lars Knoll (knoll@kde.org)
   3  * (C) 2000 Dirk Mueller (mueller@kde.org)
   4  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   5  * Copyright (C) 2006 Andrew Wellington (proton@wiretapped.net)
   6  * Copyright (C) 2006 Graham Dennis (graham.dennis@gmail.com)
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public License
  19  * along with this library; see the file COPYING.LIB.  If not, write to
  20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 #include &quot;RenderText.h&quot;
  27 
  28 #include &quot;AXObjectCache.h&quot;
  29 #include &quot;BreakLines.h&quot;
  30 #include &quot;BreakingContext.h&quot;
  31 #include &quot;CharacterProperties.h&quot;
  32 #include &quot;DocumentMarkerController.h&quot;
  33 #include &quot;EllipsisBox.h&quot;
  34 #include &quot;FloatQuad.h&quot;
  35 #include &quot;Frame.h&quot;
  36 #include &quot;FrameView.h&quot;
  37 #include &quot;HTMLParserIdioms.h&quot;
  38 #include &quot;Hyphenation.h&quot;
  39 #include &quot;InlineTextBox.h&quot;
  40 #include &quot;LineLayoutTraversal.h&quot;
  41 #include &quot;Range.h&quot;
  42 #include &quot;RenderBlock.h&quot;
  43 #include &quot;RenderCombineText.h&quot;
  44 #include &quot;RenderInline.h&quot;
  45 #include &quot;RenderLayer.h&quot;
  46 #include &quot;RenderView.h&quot;
  47 #include &quot;RenderedDocumentMarker.h&quot;
  48 #include &quot;Settings.h&quot;
  49 #include &quot;SimpleLineLayoutFunctions.h&quot;
  50 #include &quot;Text.h&quot;
  51 #include &quot;TextResourceDecoder.h&quot;
  52 #include &quot;VisiblePosition.h&quot;
  53 #include &lt;wtf/IsoMallocInlines.h&gt;
  54 #include &lt;wtf/NeverDestroyed.h&gt;
  55 #include &lt;wtf/text/StringBuilder.h&gt;
  56 #include &lt;wtf/text/TextBreakIterator.h&gt;
  57 #include &lt;wtf/unicode/CharacterNames.h&gt;
  58 
  59 #if PLATFORM(IOS_FAMILY)
  60 #include &quot;Document.h&quot;
  61 #include &quot;EditorClient.h&quot;
  62 #include &quot;LogicalSelectionOffsetCaches.h&quot;
  63 #include &quot;Page.h&quot;
  64 #include &quot;SelectionRect.h&quot;
  65 #endif
  66 
  67 namespace WebCore {
  68 
  69 using namespace WTF::Unicode;
  70 
  71 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderText);
  72 
  73 struct SameSizeAsRenderText : public RenderObject {
  74     void* pointers[2];
  75     uint32_t bitfields : 16;
  76 #if ENABLE(TEXT_AUTOSIZING)
  77     float candidateTextSize;
  78 #endif
  79     float widths[4];
  80     String text;
  81 };
  82 
  83 COMPILE_ASSERT(sizeof(RenderText) == sizeof(SameSizeAsRenderText), RenderText_should_stay_small);
  84 
  85 class SecureTextTimer final : private TimerBase {
  86     WTF_MAKE_FAST_ALLOCATED;
  87 public:
  88     explicit SecureTextTimer(RenderText&amp;);
  89     void restart(unsigned offsetAfterLastTypedCharacter);
  90 
  91     unsigned takeOffsetAfterLastTypedCharacter();
  92 
  93 private:
  94     void fired() override;
  95     RenderText&amp; m_renderer;
  96     unsigned m_offsetAfterLastTypedCharacter { 0 };
  97 };
  98 
  99 typedef HashMap&lt;RenderText*, std::unique_ptr&lt;SecureTextTimer&gt;&gt; SecureTextTimerMap;
 100 
 101 static SecureTextTimerMap&amp; secureTextTimers()
 102 {
 103     static NeverDestroyed&lt;SecureTextTimerMap&gt; map;
 104     return map.get();
 105 }
 106 
 107 inline SecureTextTimer::SecureTextTimer(RenderText&amp; renderer)
 108     : m_renderer(renderer)
 109 {
 110 }
 111 
 112 inline void SecureTextTimer::restart(unsigned offsetAfterLastTypedCharacter)
 113 {
 114     m_offsetAfterLastTypedCharacter = offsetAfterLastTypedCharacter;
 115     startOneShot(1_s * m_renderer.settings().passwordEchoDurationInSeconds());
 116 }
 117 
 118 inline unsigned SecureTextTimer::takeOffsetAfterLastTypedCharacter()
 119 {
 120     unsigned offset = m_offsetAfterLastTypedCharacter;
 121     m_offsetAfterLastTypedCharacter = 0;
 122     return offset;
 123 }
 124 
 125 void SecureTextTimer::fired()
 126 {
 127     ASSERT(secureTextTimers().get(&amp;m_renderer) == this);
 128     m_offsetAfterLastTypedCharacter = 0;
 129     m_renderer.setText(m_renderer.text(), true /* forcing setting text as it may be masked later */);
 130 }
 131 
 132 static HashMap&lt;const RenderText*, String&gt;&amp; originalTextMap()
 133 {
 134     static NeverDestroyed&lt;HashMap&lt;const RenderText*, String&gt;&gt; map;
 135     return map;
 136 }
 137 
 138 static HashMap&lt;const RenderText*, WeakPtr&lt;RenderInline&gt;&gt;&amp; inlineWrapperForDisplayContentsMap()
 139 {
 140     static NeverDestroyed&lt;HashMap&lt;const RenderText*, WeakPtr&lt;RenderInline&gt;&gt;&gt; map;
 141     return map;
 142 }
 143 
 144 static constexpr UChar convertNoBreakSpaceToSpace(UChar character)
 145 {
 146     return character == noBreakSpace ? &#39; &#39; : character;
 147 }
 148 
 149 String capitalize(const String&amp; string, UChar previousCharacter)
 150 {
 151     // FIXME: Change this to use u_strToTitle instead of u_totitle and to consider locale.
 152 
 153     unsigned length = string.length();
 154     auto&amp; stringImpl = *string.impl();
 155 
 156     static_assert(String::MaxLength &lt; std::numeric_limits&lt;unsigned&gt;::max(), &quot;Must be able to add one without overflowing unsigned&quot;);
 157 
 158     // Replace NO BREAK SPACE with a normal spaces since ICU does not treat it as a word separator.
 159     Vector&lt;UChar&gt; stringWithPrevious(length + 1);
 160     stringWithPrevious[0] = convertNoBreakSpaceToSpace(previousCharacter);
 161     for (unsigned i = 1; i &lt; length + 1; i++)
 162         stringWithPrevious[i] = convertNoBreakSpaceToSpace(stringImpl[i - 1]);
 163 
 164     auto* breakIterator = wordBreakIterator(StringView { stringWithPrevious.data(), length + 1 });
 165     if (!breakIterator)
 166         return string;
 167 
 168     StringBuilder result;
 169     result.reserveCapacity(length);
 170 
 171     int32_t startOfWord = ubrk_first(breakIterator);
 172     int32_t endOfWord;
 173     for (endOfWord = ubrk_next(breakIterator); endOfWord != UBRK_DONE; startOfWord = endOfWord, endOfWord = ubrk_next(breakIterator)) {
 174         if (startOfWord) // Do not append the first character, since it&#39;s the previous character, not from this string.
 175             result.appendCharacter(u_totitle(stringImpl[startOfWord - 1]));
 176         for (int i = startOfWord + 1; i &lt; endOfWord; i++)
 177             result.append(stringImpl[i - 1]);
 178     }
 179 
 180     return result == string ? string : result.toString();
 181 }
 182 
 183 inline RenderText::RenderText(Node&amp; node, const String&amp; text)
 184     : RenderObject(node)
 185     , m_hasTab(false)
 186     , m_linesDirty(false)
 187     , m_containsReversedText(false)
 188     , m_isAllASCII(text.impl()-&gt;isAllASCII())
 189     , m_knownToHaveNoOverflowAndNoFallbackFonts(false)
 190     , m_useBackslashAsYenSymbol(false)
 191     , m_originalTextDiffersFromRendered(false)
 192     , m_hasInlineWrapperForDisplayContents(false)
 193     , m_text(text)
 194 {
 195     ASSERT(!m_text.isNull());
 196     setIsText();
 197     m_canUseSimpleFontCodePath = computeCanUseSimpleFontCodePath();
 198 
 199     // FIXME: Find out how to increment the visually non empty character count when the font becomes available.
 200     auto isTextVisible = false;
 201     if (auto* parentElement = node.parentElement()) {
 202         auto* style = parentElement-&gt;renderer() ? &amp;parentElement-&gt;renderer()-&gt;style() : nullptr;
 203         isTextVisible = style &amp;&amp; style-&gt;visibility() == Visibility::Visible &amp;&amp; !style-&gt;fontCascade().isLoadingCustomFonts();
 204     }
 205 
 206     if (isTextVisible)
 207         view().frameView().incrementVisuallyNonEmptyCharacterCount(text);
 208 }
 209 
 210 RenderText::RenderText(Text&amp; textNode, const String&amp; text)
 211     : RenderText(static_cast&lt;Node&amp;&gt;(textNode), text)
 212 {
 213 }
 214 
 215 RenderText::RenderText(Document&amp; document, const String&amp; text)
 216     : RenderText(static_cast&lt;Node&amp;&gt;(document), text)
 217 {
 218 }
 219 
 220 RenderText::~RenderText()
 221 {
 222     // Do not add any code here. Add it to willBeDestroyed() instead.
 223     ASSERT(!originalTextMap().contains(this));
 224 }
 225 
 226 const char* RenderText::renderName() const
 227 {
 228     return &quot;RenderText&quot;;
 229 }
 230 
 231 Text* RenderText::textNode() const
 232 {
 233     return downcast&lt;Text&gt;(RenderObject::node());
 234 }
 235 
 236 bool RenderText::isTextFragment() const
 237 {
 238     return false;
 239 }
 240 
 241 bool RenderText::computeUseBackslashAsYenSymbol() const
 242 {
 243     const RenderStyle&amp; style = this-&gt;style();
 244     const auto&amp; fontDescription = style.fontDescription();
 245     if (style.fontCascade().useBackslashAsYenSymbol())
 246         return true;
 247     if (fontDescription.isSpecifiedFont())
 248         return false;
 249     const TextEncoding* encoding = document().decoder() ? &amp;document().decoder()-&gt;encoding() : 0;
 250     if (encoding &amp;&amp; encoding-&gt;backslashAsCurrencySymbol() != &#39;\\&#39;)
 251         return true;
 252     return false;
 253 }
 254 
 255 void RenderText::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
 256 {
 257     // There is no need to ever schedule repaints from a style change of a text run, since
 258     // we already did this for the parent of the text run.
 259     // We do have to schedule layouts, though, since a style change can force us to
 260     // need to relayout.
 261     if (diff == StyleDifference::Layout) {
 262         setNeedsLayoutAndPrefWidthsRecalc();
 263         m_knownToHaveNoOverflowAndNoFallbackFonts = false;
 264     }
 265 
 266     const RenderStyle&amp; newStyle = style();
 267     bool needsResetText = false;
 268     if (!oldStyle) {
 269         m_useBackslashAsYenSymbol = computeUseBackslashAsYenSymbol();
 270         needsResetText = m_useBackslashAsYenSymbol;
 271     } else if (oldStyle-&gt;fontCascade().useBackslashAsYenSymbol() != newStyle.fontCascade().useBackslashAsYenSymbol()) {
 272         m_useBackslashAsYenSymbol = computeUseBackslashAsYenSymbol();
 273         needsResetText = true;
 274     }
 275 
 276     if (!oldStyle || oldStyle-&gt;fontCascade() != newStyle.fontCascade())
 277         m_canUseSimplifiedTextMeasuring = computeCanUseSimplifiedTextMeasuring();
 278 
 279     TextTransform oldTransform = oldStyle ? oldStyle-&gt;textTransform() : TextTransform::None;
 280     TextSecurity oldSecurity = oldStyle ? oldStyle-&gt;textSecurity() : TextSecurity::None;
 281     if (needsResetText || oldTransform != newStyle.textTransform() || oldSecurity != newStyle.textSecurity())
 282         RenderText::setText(originalText(), true);
 283 }
 284 
 285 void RenderText::removeAndDestroyTextBoxes()
 286 {
 287     if (!renderTreeBeingDestroyed())
 288         m_lineBoxes.removeAllFromParent(*this);
 289 #if !ASSERT_WITH_SECURITY_IMPLICATION_DISABLED
 290     else
 291         m_lineBoxes.invalidateParentChildLists();
 292 #endif
 293     m_lineBoxes.deleteAll();
 294 }
 295 
 296 void RenderText::willBeDestroyed()
 297 {
 298     secureTextTimers().remove(this);
 299 
 300     removeAndDestroyTextBoxes();
 301 
 302     if (m_originalTextDiffersFromRendered)
 303         originalTextMap().remove(this);
 304 
 305     setInlineWrapperForDisplayContents(nullptr);
 306 
 307     RenderObject::willBeDestroyed();
 308 }
 309 
 310 String RenderText::originalText() const
 311 {
 312     return m_originalTextDiffersFromRendered ? originalTextMap().get(this) : m_text;
 313 }
 314 
 315 void RenderText::absoluteRects(Vector&lt;IntRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset) const
 316 {
 317     for (auto&amp; box : LineLayoutTraversal::textBoxesFor(*this)) {
 318         auto rect = box.rect();
 319         rects.append(enclosingIntRect(FloatRect(accumulatedOffset + rect.location(), rect.size())));
 320     }
 321 }
 322 
 323 Vector&lt;IntRect&gt; RenderText::absoluteRectsForRange(unsigned start, unsigned end, bool useSelectionHeight, bool* wasFixed) const
 324 {
 325     const_cast&lt;RenderText&amp;&gt;(*this).ensureLineBoxes();
 326 
 327     // Work around signed/unsigned issues. This function takes unsigneds, and is often passed UINT_MAX
 328     // to mean &quot;all the way to the end&quot;. InlineTextBox coordinates are unsigneds, so changing this
 329     // function to take ints causes various internal mismatches. But selectionRect takes ints, and
 330     // passing UINT_MAX to it causes trouble. Ideally we&#39;d change selectionRect to take unsigneds, but
 331     // that would cause many ripple effects, so for now we&#39;ll just clamp our unsigned parameters to INT_MAX.
 332     ASSERT(end == UINT_MAX || end &lt;= INT_MAX);
 333     ASSERT(start &lt;= INT_MAX);
 334     start = std::min(start, static_cast&lt;unsigned&gt;(INT_MAX));
 335     end = std::min(end, static_cast&lt;unsigned&gt;(INT_MAX));
 336 
 337     return m_lineBoxes.absoluteRectsForRange(*this, start, end, useSelectionHeight, wasFixed);
 338 }
 339 
 340 #if PLATFORM(IOS_FAMILY)
 341 // This function is similar in spirit to addLineBoxRects, but returns rectangles
 342 // which are annotated with additional state which helps the iPhone draw selections in its unique way.
 343 // Full annotations are added in this class.
 344 void RenderText::collectSelectionRects(Vector&lt;SelectionRect&gt;&amp; rects, unsigned start, unsigned end)
 345 {
 346     // FIXME: Work around signed/unsigned issues. This function takes unsigneds, and is often passed UINT_MAX
 347     // to mean &quot;all the way to the end&quot;. InlineTextBox coordinates are unsigneds, so changing this
 348     // function to take ints causes various internal mismatches. But selectionRect takes ints, and
 349     // passing UINT_MAX to it causes trouble. Ideally we&#39;d change selectionRect to take unsigneds, but
 350     // that would cause many ripple effects, so for now we&#39;ll just clamp our unsigned parameters to INT_MAX.
 351     ASSERT(end == std::numeric_limits&lt;unsigned&gt;::max() || end &lt;= std::numeric_limits&lt;int&gt;::max());
 352     ASSERT(start &lt;= std::numeric_limits&lt;int&gt;::max());
 353     start = std::min(start, static_cast&lt;unsigned&gt;(std::numeric_limits&lt;int&gt;::max()));
 354     end = std::min(end, static_cast&lt;unsigned&gt;(std::numeric_limits&lt;int&gt;::max()));
 355 
 356     for (InlineTextBox* box = firstTextBox(); box; box = box-&gt;nextTextBox()) {
 357         LayoutRect rect;
 358         if (start &lt;= box-&gt;start() &amp;&amp; box-&gt;end() &lt;= end)
 359             rect = box-&gt;localSelectionRect(start, end);
 360         else {
 361             unsigned realEnd = std::min(box-&gt;end(), end);
 362             rect = box-&gt;localSelectionRect(start, realEnd);
 363             if (rect.isEmpty())
 364                 continue;
 365         }
 366 
 367         if (box-&gt;root().isFirstAfterPageBreak()) {
 368             if (box-&gt;isHorizontal())
 369                 rect.shiftYEdgeTo(box-&gt;root().lineTopWithLeading());
 370             else
 371                 rect.shiftXEdgeTo(box-&gt;root().lineTopWithLeading());
 372         }
 373 
 374         RenderBlock* containingBlock = this-&gt;containingBlock();
 375         // Map rect, extended left to leftOffset, and right to rightOffset, through transforms to get minX and maxX.
 376         LogicalSelectionOffsetCaches cache(*containingBlock);
 377         LayoutUnit leftOffset = containingBlock-&gt;logicalLeftSelectionOffset(*containingBlock, LayoutUnit(box-&gt;logicalTop()), cache);
 378         LayoutUnit rightOffset = containingBlock-&gt;logicalRightSelectionOffset(*containingBlock, LayoutUnit(box-&gt;logicalTop()), cache);
 379         LayoutRect extentsRect = rect;
 380         if (box-&gt;isHorizontal()) {
 381             extentsRect.setX(leftOffset);
 382             extentsRect.setWidth(rightOffset - leftOffset);
 383         } else {
 384             extentsRect.setY(leftOffset);
 385             extentsRect.setHeight(rightOffset - leftOffset);
 386         }
 387         extentsRect = localToAbsoluteQuad(FloatRect(extentsRect)).enclosingBoundingBox();
 388         if (!box-&gt;isHorizontal())
 389             extentsRect = extentsRect.transposedRect();
 390         bool isFirstOnLine = !box-&gt;previousOnLineExists();
 391         bool isLastOnLine = !box-&gt;nextOnLineExists();
 392         if (containingBlock-&gt;isRubyBase() || containingBlock-&gt;isRubyText())
 393             isLastOnLine = !containingBlock-&gt;containingBlock()-&gt;inlineBoxWrapper()-&gt;nextOnLineExists();
 394 
 395         bool containsStart = box-&gt;start() &lt;= start &amp;&amp; box-&gt;end() &gt;= start;
 396         bool containsEnd = box-&gt;start() &lt;= end &amp;&amp; box-&gt;end() &gt;= end;
 397 
 398         bool isFixed = false;
 399         IntRect absRect = localToAbsoluteQuad(FloatRect(rect), UseTransforms, &amp;isFixed).enclosingBoundingBox();
 400         bool boxIsHorizontal = !box-&gt;isSVGInlineTextBox() ? box-&gt;isHorizontal() : !style().isVerticalWritingMode();
 401         // If the containing block is an inline element, we want to check the inlineBoxWrapper orientation
 402         // to determine the orientation of the block. In this case we also use the inlineBoxWrapper to
 403         // determine if the element is the last on the line.
 404         if (containingBlock-&gt;inlineBoxWrapper()) {
 405             if (containingBlock-&gt;inlineBoxWrapper()-&gt;isHorizontal() != boxIsHorizontal) {
 406                 boxIsHorizontal = containingBlock-&gt;inlineBoxWrapper()-&gt;isHorizontal();
 407                 isLastOnLine = !containingBlock-&gt;inlineBoxWrapper()-&gt;nextOnLineExists();
 408             }
 409         }
 410 
 411         rects.append(SelectionRect(absRect, box-&gt;direction(), extentsRect.x(), extentsRect.maxX(), extentsRect.maxY(), 0, box-&gt;isLineBreak(), isFirstOnLine, isLastOnLine, containsStart, containsEnd, boxIsHorizontal, isFixed, containingBlock-&gt;isRubyText(), view().pageNumberForBlockProgressionOffset(absRect.x())));
 412     }
 413 }
 414 #endif
 415 
 416 static Vector&lt;FloatQuad&gt; collectAbsoluteQuadsForNonComplexPaths(const RenderText&amp; textRenderer, bool* wasFixed)
 417 {
 418     // FIXME: This generic function doesn&#39;t currently cover everything that is needed for the complex line layout path.
 419     ASSERT(!textRenderer.usesComplexLineLayoutPath());
 420 
 421     Vector&lt;FloatQuad&gt; quads;
 422     for (auto&amp; box : LineLayoutTraversal::textBoxesFor(textRenderer))
 423         quads.append(textRenderer.localToAbsoluteQuad(FloatQuad(box.rect()), UseTransforms, wasFixed));
 424     return quads;
 425 }
 426 
 427 Vector&lt;FloatQuad&gt; RenderText::absoluteQuadsClippedToEllipsis() const
 428 {
 429     if (!usesComplexLineLayoutPath()) {
 430         ASSERT(style().textOverflow() != TextOverflow::Ellipsis);
 431         return collectAbsoluteQuadsForNonComplexPaths(*this, nullptr);
 432     }
 433     return m_lineBoxes.absoluteQuads(*this, nullptr, RenderTextLineBoxes::ClipToEllipsis);
 434 }
 435 
 436 void RenderText::absoluteQuads(Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const
 437 {
 438     if (!usesComplexLineLayoutPath()) {
 439         quads.appendVector(collectAbsoluteQuadsForNonComplexPaths(*this, wasFixed));
 440         return;
 441     }
 442     quads.appendVector(m_lineBoxes.absoluteQuads(*this, wasFixed, RenderTextLineBoxes::NoClipping));
 443 }
 444 
 445 Vector&lt;FloatQuad&gt; RenderText::absoluteQuadsForRange(unsigned start, unsigned end, bool useSelectionHeight, bool ignoreEmptyTextSelections, bool* wasFixed) const
 446 {
 447     // Work around signed/unsigned issues. This function takes unsigneds, and is often passed UINT_MAX
 448     // to mean &quot;all the way to the end&quot;. InlineTextBox coordinates are unsigneds, so changing this
 449     // function to take ints causes various internal mismatches. But selectionRect takes ints, and
 450     // passing UINT_MAX to it causes trouble. Ideally we&#39;d change selectionRect to take unsigneds, but
 451     // that would cause many ripple effects, so for now we&#39;ll just clamp our unsigned parameters to INT_MAX.
 452     ASSERT(end == UINT_MAX || end &lt;= INT_MAX);
 453     ASSERT(start &lt;= INT_MAX);
 454     start = std::min(start, static_cast&lt;unsigned&gt;(INT_MAX));
 455     end = std::min(end, static_cast&lt;unsigned&gt;(INT_MAX));
 456     if (simpleLineLayout() &amp;&amp; !useSelectionHeight)
 457         return collectAbsoluteQuadsForRange(*this, start, end, *simpleLineLayout(), ignoreEmptyTextSelections, wasFixed);
 458     const_cast&lt;RenderText&amp;&gt;(*this).ensureLineBoxes();
 459     return m_lineBoxes.absoluteQuadsForRange(*this, start, end, useSelectionHeight, ignoreEmptyTextSelections, wasFixed);
 460 }
 461 
 462 Position RenderText::positionForPoint(const LayoutPoint&amp; point)
 463 {
 464     if (simpleLineLayout() &amp;&amp; parent()-&gt;firstChild() == parent()-&gt;lastChild()) {
 465         auto offset = SimpleLineLayout::textOffsetForPoint(point, *this, *simpleLineLayout());
 466         // Did not find a valid offset. Fall back to the normal line layout based Position.
 467         if (offset == text().length())
 468             return positionForPoint(point, nullptr).deepEquivalent();
 469         auto position = Position(textNode(), offset);
 470         ASSERT(position == positionForPoint(point, nullptr).deepEquivalent());
 471         return position;
 472     }
 473     return positionForPoint(point, nullptr).deepEquivalent();
 474 }
 475 
 476 VisiblePosition RenderText::positionForPoint(const LayoutPoint&amp; point, const RenderFragmentContainer*)
 477 {
 478     ensureLineBoxes();
 479     return m_lineBoxes.positionForPoint(*this, point);
 480 }
 481 
 482 LayoutRect RenderText::localCaretRect(InlineBox* inlineBox, unsigned caretOffset, LayoutUnit* extraWidthToEndOfLine)
 483 {
 484     if (!inlineBox)
 485         return LayoutRect();
 486 
 487     auto&amp; box = downcast&lt;InlineTextBox&gt;(*inlineBox);
 488     float left = box.positionForOffset(caretOffset);
 489     return box.root().computeCaretRect(left, caretWidth, extraWidthToEndOfLine);
 490 }
 491 
 492 ALWAYS_INLINE float RenderText::widthFromCache(const FontCascade&amp; f, unsigned start, unsigned len, float xPos, HashSet&lt;const Font*&gt;* fallbackFonts, GlyphOverflow* glyphOverflow, const RenderStyle&amp; style) const
 493 {
 494     if (style.hasTextCombine() &amp;&amp; is&lt;RenderCombineText&gt;(*this)) {
 495         const RenderCombineText&amp; combineText = downcast&lt;RenderCombineText&gt;(*this);
 496         if (combineText.isCombined())
 497             return combineText.combinedTextWidth(f);
 498     }
 499 
 500     if (f.isFixedPitch() &amp;&amp; f.fontDescription().variantSettings().isAllNormal() &amp;&amp; m_isAllASCII &amp;&amp; (!glyphOverflow || !glyphOverflow-&gt;computeBounds)) {
 501         float monospaceCharacterWidth = f.spaceWidth();
 502         float w = 0;
 503         bool isSpace;
 504         for (unsigned i = start; i &lt; start + len; i++) {
 505             char c = text()[i];
 506             if (c &lt;= &#39; &#39;) {
 507                 if (c == &#39; &#39; || c == &#39;\n&#39;) {
 508                     w += monospaceCharacterWidth;
 509                     isSpace = true;
 510                 } else if (c == &#39;\t&#39;) {
 511                     if (style.collapseWhiteSpace()) {
 512                         w += monospaceCharacterWidth;
 513                         isSpace = true;
 514                     } else {
 515                         w += f.tabWidth(style.tabSize(), xPos + w);
 516                         isSpace = false;
 517                     }
 518                 } else
 519                     isSpace = false;
 520             } else {
 521                 w += monospaceCharacterWidth;
 522                 isSpace = false;
 523             }
 524             if (isSpace &amp;&amp; i &gt; start)
 525                 w += f.wordSpacing();
 526         }
 527         return w;
 528     }
 529 
 530     TextRun run = RenderBlock::constructTextRun(*this, start, len, style);
 531     run.setCharacterScanForCodePath(!canUseSimpleFontCodePath());
 532     run.setTabSize(!style.collapseWhiteSpace(), style.tabSize());
 533     run.setXPos(xPos);
 534     return f.width(run, fallbackFonts, glyphOverflow);
 535 }
 536 
 537 inline bool isHangablePunctuationAtLineStart(UChar c)
 538 {
 539     return U_GET_GC_MASK(c) &amp; (U_GC_PS_MASK | U_GC_PI_MASK | U_GC_PF_MASK);
 540 }
 541 
 542 inline bool isHangablePunctuationAtLineEnd(UChar c)
 543 {
 544     return U_GET_GC_MASK(c) &amp; (U_GC_PE_MASK | U_GC_PI_MASK | U_GC_PF_MASK);
 545 }
 546 
 547 float RenderText::hangablePunctuationStartWidth(unsigned index) const
 548 {
 549     unsigned length = text().length();
 550     if (index &gt;= length)
 551         return 0;
 552 
 553     if (!isHangablePunctuationAtLineStart(text()[index]))
 554         return 0;
 555 
 556     auto&amp; style = this-&gt;style();
 557     return widthFromCache(style.fontCascade(), index, 1, 0, 0, 0, style);
 558 }
 559 
 560 float RenderText::hangablePunctuationEndWidth(unsigned index) const
 561 {
 562     unsigned length = text().length();
 563     if (index &gt;= length)
 564         return 0;
 565 
 566     if (!isHangablePunctuationAtLineEnd(text()[index]))
 567         return 0;
 568 
 569     auto&amp; style = this-&gt;style();
 570     return widthFromCache(style.fontCascade(), index, 1, 0, 0, 0, style);
 571 }
 572 
 573 bool RenderText::isHangableStopOrComma(UChar c)
 574 {
 575     return c == 0x002C || c == 0x002E || c == 0x060C || c == 0x06D4 || c == 0x3001
 576         || c == 0x3002 || c == 0xFF0C || c == 0xFF0E || c == 0xFE50 || c == 0xFE51
 577         || c == 0xFE52 || c == 0xFF61 || c == 0xFF64;
 578 }
 579 
 580 unsigned RenderText::firstCharacterIndexStrippingSpaces() const
 581 {
 582     if (!style().collapseWhiteSpace())
 583         return 0;
 584 
 585     unsigned i = 0;
 586     for (unsigned length = text().length() ; i &lt; length; ++i) {
 587         if (text()[i] != &#39; &#39; &amp;&amp; (text()[i] != &#39;\n&#39; || style().preserveNewline()) &amp;&amp; text()[i] != &#39;\t&#39;)
 588             break;
 589     }
 590     return i;
 591 }
 592 
 593 unsigned RenderText::lastCharacterIndexStrippingSpaces() const
 594 {
 595     if (!text().length())
 596         return 0;
 597 
 598     if (!style().collapseWhiteSpace())
 599         return text().length() - 1;
 600 
 601     int i = text().length() - 1;
 602     for ( ; i  &gt;= 0; --i) {
 603         if (text()[i] != &#39; &#39; &amp;&amp; (text()[i] != &#39;\n&#39; || style().preserveNewline()) &amp;&amp; text()[i] != &#39;\t&#39;)
 604             break;
 605     }
 606     return i;
 607 }
 608 
 609 RenderText::Widths RenderText::trimmedPreferredWidths(float leadWidth, bool&amp; stripFrontSpaces)
 610 {
 611     auto&amp; style = this-&gt;style();
 612     bool collapseWhiteSpace = style.collapseWhiteSpace();
 613 
 614     if (!collapseWhiteSpace)
 615         stripFrontSpaces = false;
 616 
 617     if (m_hasTab || preferredLogicalWidthsDirty())
 618         computePreferredLogicalWidths(leadWidth);
 619 
 620     Widths widths;
 621 
 622     widths.beginWS = !stripFrontSpaces &amp;&amp; m_hasBeginWS;
 623     widths.endWS = m_hasEndWS;
 624 
 625     unsigned length = this-&gt;length();
 626 
 627     if (!length || (stripFrontSpaces &amp;&amp; text().isAllSpecialCharacters&lt;isHTMLSpace&gt;()))
 628         return widths;
 629 
 630     widths.min = m_minWidth;
 631     widths.max = m_maxWidth;
 632 
 633     widths.beginMin = m_beginMinWidth;
 634     widths.endMin = m_endMinWidth;
 635 
 636     widths.hasBreakableChar = m_hasBreakableChar;
 637     widths.hasBreak = m_hasBreak;
 638 
 639     if (text()[0] == &#39; &#39; || (text()[0] == &#39;\n&#39; &amp;&amp; !style.preserveNewline()) || text()[0] == &#39;\t&#39;) {
 640         auto&amp; font = style.fontCascade(); // FIXME: This ignores first-line.
 641         if (stripFrontSpaces)
 642             widths.max -= font.width(RenderBlock::constructTextRun(&amp;space, 1, style));
 643         else
 644             widths.max += font.wordSpacing();
 645     }
 646 
 647     stripFrontSpaces = collapseWhiteSpace &amp;&amp; m_hasEndWS;
 648 
 649     if (!style.autoWrap() || widths.min &gt; widths.max)
 650         widths.min = widths.max;
 651 
 652     // Compute our max widths by scanning the string for newlines.
 653     if (widths.hasBreak) {
 654         auto&amp; font = style.fontCascade(); // FIXME: This ignores first-line.
 655         bool firstLine = true;
 656         widths.beginMax = widths.max;
 657         widths.endMax = widths.max;
 658         for (unsigned i = 0; i &lt; length; i++) {
 659             unsigned lineLength = 0;
 660             while (i + lineLength &lt; length &amp;&amp; text()[i + lineLength] != &#39;\n&#39;)
 661                 lineLength++;
 662 
 663             if (lineLength) {
 664                 widths.endMax = widthFromCache(font, i, lineLength, leadWidth + widths.endMax, 0, 0, style);
 665                 if (firstLine) {
 666                     firstLine = false;
 667                     leadWidth = 0;
 668                     widths.beginMax = widths.endMax;
 669                 }
 670                 i += lineLength;
 671             } else if (firstLine) {
 672                 widths.beginMax = 0;
 673                 firstLine = false;
 674                 leadWidth = 0;
 675             }
 676 
 677             if (i == length - 1) {
 678                 // A &lt;pre&gt; run that ends with a newline, as in, e.g.,
 679                 // &lt;pre&gt;Some text\n\n&lt;span&gt;More text&lt;/pre&gt;
 680                 widths.endMax = 0;
 681             }
 682         }
 683     }
 684 
 685     return widths;
 686 }
 687 
 688 static inline bool isSpaceAccordingToStyle(UChar c, const RenderStyle&amp; style)
 689 {
 690     return c == &#39; &#39; || (c == noBreakSpace &amp;&amp; style.nbspMode() == NBSPMode::Space);
 691 }
 692 
 693 float RenderText::minLogicalWidth() const
 694 {
 695     if (preferredLogicalWidthsDirty())
 696         const_cast&lt;RenderText*&gt;(this)-&gt;computePreferredLogicalWidths(0);
 697 
 698     return m_minWidth;
 699 }
 700 
 701 float RenderText::maxLogicalWidth() const
 702 {
 703     if (preferredLogicalWidthsDirty())
 704         const_cast&lt;RenderText*&gt;(this)-&gt;computePreferredLogicalWidths(0);
 705 
 706     return m_maxWidth;
 707 }
 708 
 709 LineBreakIteratorMode mapLineBreakToIteratorMode(LineBreak lineBreak)
 710 {
 711     switch (lineBreak) {
 712     case LineBreak::Auto:
 713     case LineBreak::AfterWhiteSpace:
 714     case LineBreak::Anywhere:
 715         return LineBreakIteratorMode::Default;
 716     case LineBreak::Loose:
 717         return LineBreakIteratorMode::Loose;
 718     case LineBreak::Normal:
 719         return LineBreakIteratorMode::Normal;
 720     case LineBreak::Strict:
 721         return LineBreakIteratorMode::Strict;
 722     }
 723     ASSERT_NOT_REACHED();
 724     return LineBreakIteratorMode::Default;
 725 }
 726 
 727 void RenderText::computePreferredLogicalWidths(float leadWidth)
 728 {
 729     HashSet&lt;const Font*&gt; fallbackFonts;
 730     GlyphOverflow glyphOverflow;
 731     computePreferredLogicalWidths(leadWidth, fallbackFonts, glyphOverflow);
 732     if (fallbackFonts.isEmpty() &amp;&amp; !glyphOverflow.left &amp;&amp; !glyphOverflow.right &amp;&amp; !glyphOverflow.top &amp;&amp; !glyphOverflow.bottom)
 733         m_knownToHaveNoOverflowAndNoFallbackFonts = true;
 734 }
 735 
 736 static inline float hyphenWidth(RenderText&amp; renderer, const FontCascade&amp; font)
 737 {
 738     const RenderStyle&amp; style = renderer.style();
 739     auto textRun = RenderBlock::constructTextRun(style.hyphenString().string(), style);
 740     return font.width(textRun);
 741 }
 742 
 743 static float maxWordFragmentWidth(RenderText&amp; renderer, const RenderStyle&amp; style, const FontCascade&amp; font, StringView word, unsigned minimumPrefixLength, unsigned minimumSuffixLength, unsigned&amp; suffixStart, HashSet&lt;const Font*&gt;&amp; fallbackFonts, GlyphOverflow&amp; glyphOverflow)
 744 {
 745     suffixStart = 0;
 746     if (word.length() &lt;= minimumSuffixLength)
 747         return 0;
 748 
 749     Vector&lt;int, 8&gt; hyphenLocations;
 750     ASSERT(word.length() &gt;= minimumSuffixLength);
 751     unsigned hyphenLocation = word.length() - minimumSuffixLength;
 752     while ((hyphenLocation = lastHyphenLocation(word, hyphenLocation, style.locale())) &gt;= std::max(minimumPrefixLength, 1U))
 753         hyphenLocations.append(hyphenLocation);
 754 
 755     if (hyphenLocations.isEmpty())
 756         return 0;
 757 
 758     hyphenLocations.reverse();
 759 
 760     // FIXME: Breaking the string at these places in the middle of words is completely broken with complex text.
 761     float minimumFragmentWidthToConsider = font.pixelSize() * 5 / 4 + hyphenWidth(renderer, font);
 762     float maxFragmentWidth = 0;
 763     for (size_t k = 0; k &lt; hyphenLocations.size(); ++k) {
 764         int fragmentLength = hyphenLocations[k] - suffixStart;
 765         StringBuilder fragmentWithHyphen;
 766         fragmentWithHyphen.append(word.substring(suffixStart, fragmentLength));
 767         fragmentWithHyphen.append(style.hyphenString());
 768 
 769         TextRun run = RenderBlock::constructTextRun(fragmentWithHyphen.toString(), style);
 770         run.setCharacterScanForCodePath(!renderer.canUseSimpleFontCodePath());
 771         float fragmentWidth = font.width(run, &amp;fallbackFonts, &amp;glyphOverflow);
 772 
 773         // Narrow prefixes are ignored. See tryHyphenating in RenderBlockLineLayout.cpp.
 774         if (fragmentWidth &lt;= minimumFragmentWidthToConsider)
 775             continue;
 776 
 777         suffixStart += fragmentLength;
 778         maxFragmentWidth = std::max(maxFragmentWidth, fragmentWidth);
 779     }
 780 
 781     return maxFragmentWidth;
 782 }
 783 
 784 void RenderText::computePreferredLogicalWidths(float leadWidth, HashSet&lt;const Font*&gt;&amp; fallbackFonts, GlyphOverflow&amp; glyphOverflow)
 785 {
 786     ASSERT(m_hasTab || preferredLogicalWidthsDirty() || !m_knownToHaveNoOverflowAndNoFallbackFonts);
 787 
 788     m_minWidth = 0;
 789     m_beginMinWidth = 0;
 790     m_endMinWidth = 0;
 791     m_maxWidth = 0;
 792 
 793     float currMaxWidth = 0;
 794     m_hasBreakableChar = false;
 795     m_hasBreak = false;
 796     m_hasTab = false;
 797     m_hasBeginWS = false;
 798     m_hasEndWS = false;
 799 
 800     auto&amp; style = this-&gt;style();
 801     auto&amp; font = style.fontCascade(); // FIXME: This ignores first-line.
 802     float wordSpacing = font.wordSpacing();
 803     auto&amp; string = text();
 804     unsigned length = string.length();
 805     auto iteratorMode = mapLineBreakToIteratorMode(style.lineBreak());
 806     LazyLineBreakIterator breakIterator(string, style.locale(), iteratorMode);
 807     bool needsWordSpacing = false;
 808     bool ignoringSpaces = false;
 809     bool isSpace = false;
 810     bool firstWord = true;
 811     bool firstLine = true;
 812     Optional&lt;unsigned&gt; nextBreakable;
 813     unsigned lastWordBoundary = 0;
 814 
 815     WordTrailingSpace wordTrailingSpace(style);
 816     // If automatic hyphenation is allowed, we keep track of the width of the widest word (or word
 817     // fragment) encountered so far, and only try hyphenating words that are wider.
 818     float maxWordWidth = std::numeric_limits&lt;float&gt;::max();
 819     unsigned minimumPrefixLength = 0;
 820     unsigned minimumSuffixLength = 0;
 821     if (style.hyphens() == Hyphens::Auto &amp;&amp; canHyphenate(style.locale())) {
 822         maxWordWidth = 0;
 823 
 824         // Map &#39;hyphenate-limit-{before,after}: auto;&#39; to 2.
 825         auto before = style.hyphenationLimitBefore();
 826         minimumPrefixLength = before &lt; 0 ? 2 : before;
 827 
 828         auto after = style.hyphenationLimitAfter();
 829         minimumSuffixLength = after &lt; 0 ? 2 : after;
 830     }
 831 
 832     Optional&lt;int&gt; firstGlyphLeftOverflow;
 833 
 834     bool breakNBSP = style.autoWrap() &amp;&amp; style.nbspMode() == NBSPMode::Space;
 835 
 836     // Note the deliberate omission of word-wrap and overflow-wrap from this breakAll check. Those
 837     // do not affect minimum preferred sizes. Note that break-word is a non-standard value for
 838     // word-break, but we support it as though it means break-all.
 839     bool breakAnywhere = style.lineBreak() == LineBreak::Anywhere &amp;&amp; style.autoWrap();
 840     bool breakAll = (style.wordBreak() == WordBreak::BreakAll || style.wordBreak() == WordBreak::BreakWord) &amp;&amp; style.autoWrap();
 841     bool keepAllWords = style.wordBreak() == WordBreak::KeepAll;
 842     bool canUseLineBreakShortcut = iteratorMode == LineBreakIteratorMode::Default;
 843 
 844     for (unsigned i = 0; i &lt; length; i++) {
 845         UChar c = string[i];
 846 
 847         bool previousCharacterIsSpace = isSpace;
 848 
 849         bool isNewline = false;
 850         if (c == &#39;\n&#39;) {
 851             if (style.preserveNewline()) {
 852                 m_hasBreak = true;
 853                 isNewline = true;
 854                 isSpace = false;
 855             } else
 856                 isSpace = true;
 857         } else if (c == &#39;\t&#39;) {
 858             if (!style.collapseWhiteSpace()) {
 859                 m_hasTab = true;
 860                 isSpace = false;
 861             } else
 862                 isSpace = true;
 863         } else
 864             isSpace = c == &#39; &#39;;
 865 
 866         if ((isSpace || isNewline) &amp;&amp; !i)
 867             m_hasBeginWS = true;
 868         if ((isSpace || isNewline) &amp;&amp; i == length - 1)
 869             m_hasEndWS = true;
 870 
 871         ignoringSpaces |= style.collapseWhiteSpace() &amp;&amp; previousCharacterIsSpace &amp;&amp; isSpace;
 872         ignoringSpaces &amp;= isSpace;
 873 
 874         // Ignore spaces and soft hyphens
 875         if (ignoringSpaces) {
 876             ASSERT(lastWordBoundary == i);
 877             lastWordBoundary++;
 878             continue;
 879         } else if (c == softHyphen &amp;&amp; style.hyphens() != Hyphens::None) {
 880             ASSERT(i &gt;= lastWordBoundary);
 881             currMaxWidth += widthFromCache(font, lastWordBoundary, i - lastWordBoundary, leadWidth + currMaxWidth, &amp;fallbackFonts, &amp;glyphOverflow, style);
 882             if (!firstGlyphLeftOverflow)
 883                 firstGlyphLeftOverflow = glyphOverflow.left;
 884             lastWordBoundary = i + 1;
 885             continue;
 886         }
 887 
 888         bool hasBreak = breakAll || isBreakable(breakIterator, i, nextBreakable, breakNBSP, canUseLineBreakShortcut, keepAllWords, breakAnywhere);
 889         bool betweenWords = true;
 890         unsigned j = i;
 891         while (c != &#39;\n&#39; &amp;&amp; !isSpaceAccordingToStyle(c, style) &amp;&amp; c != &#39;\t&#39; &amp;&amp; (c != softHyphen || style.hyphens() == Hyphens::None)) {
 892             j++;
 893             if (j == length)
 894                 break;
 895             c = string[j];
 896             if (isBreakable(breakIterator, j, nextBreakable, breakNBSP, canUseLineBreakShortcut, keepAllWords, breakAnywhere) &amp;&amp; characterAt(j - 1) != softHyphen)
 897                 break;
 898             if (breakAll) {
 899                 betweenWords = false;
 900                 break;
 901             }
 902         }
 903 
 904         unsigned wordLen = j - i;
 905         if (wordLen) {
 906             float currMinWidth = 0;
 907             bool isSpace = (j &lt; length) &amp;&amp; isSpaceAccordingToStyle(c, style);
 908             float w;
 909             Optional&lt;float&gt; wordTrailingSpaceWidth;
 910             if (isSpace)
 911                 wordTrailingSpaceWidth = wordTrailingSpace.width(fallbackFonts);
 912             if (wordTrailingSpaceWidth)
 913                 w = widthFromCache(font, i, wordLen + 1, leadWidth + currMaxWidth, &amp;fallbackFonts, &amp;glyphOverflow, style) - wordTrailingSpaceWidth.value();
 914             else {
 915                 w = widthFromCache(font, i, wordLen, leadWidth + currMaxWidth, &amp;fallbackFonts, &amp;glyphOverflow, style);
 916                 if (c == softHyphen &amp;&amp; style.hyphens() != Hyphens::None)
 917                     currMinWidth = hyphenWidth(*this, font);
 918             }
 919 
 920             if (w &gt; maxWordWidth) {
 921                 unsigned suffixStart;
 922                 float maxFragmentWidth = maxWordFragmentWidth(*this, style, font, StringView(string).substring(i, wordLen), minimumPrefixLength, minimumSuffixLength, suffixStart, fallbackFonts, glyphOverflow);
 923 
 924                 if (suffixStart) {
 925                     float suffixWidth;
 926                     Optional&lt;float&gt; wordTrailingSpaceWidth;
 927                     if (isSpace)
 928                         wordTrailingSpaceWidth = wordTrailingSpace.width(fallbackFonts);
 929                     if (wordTrailingSpaceWidth)
 930                         suffixWidth = widthFromCache(font, i + suffixStart, wordLen - suffixStart + 1, leadWidth + currMaxWidth, 0, 0, style) - wordTrailingSpaceWidth.value();
 931                     else
 932                         suffixWidth = widthFromCache(font, i + suffixStart, wordLen - suffixStart, leadWidth + currMaxWidth, 0, 0, style);
 933 
 934                     maxFragmentWidth = std::max(maxFragmentWidth, suffixWidth);
 935 
 936                     currMinWidth += maxFragmentWidth - w;
 937                     maxWordWidth = std::max(maxWordWidth, maxFragmentWidth);
 938                 } else
 939                     maxWordWidth = w;
 940             }
 941 
 942             if (!firstGlyphLeftOverflow)
 943                 firstGlyphLeftOverflow = glyphOverflow.left;
 944             currMinWidth += w;
 945             if (betweenWords) {
 946                 if (lastWordBoundary == i)
 947                     currMaxWidth += w;
 948                 else {
 949                     ASSERT(j &gt;= lastWordBoundary);
 950                     currMaxWidth += widthFromCache(font, lastWordBoundary, j - lastWordBoundary, leadWidth + currMaxWidth, &amp;fallbackFonts, &amp;glyphOverflow, style);
 951                 }
 952                 lastWordBoundary = j;
 953             }
 954 
 955             bool isCollapsibleWhiteSpace = (j &lt; length) &amp;&amp; style.isCollapsibleWhiteSpace(c);
 956             if (j &lt; length &amp;&amp; style.autoWrap())
 957                 m_hasBreakableChar = true;
 958 
 959             // Add in wordSpacing to our currMaxWidth, but not if this is the last word on a line or the
 960             // last word in the run.
 961             if ((isSpace || isCollapsibleWhiteSpace) &amp;&amp; !containsOnlyHTMLWhitespace(j, length - j))
 962                 currMaxWidth += wordSpacing;
 963 
 964             if (firstWord) {
 965                 firstWord = false;
 966                 // If the first character in the run is breakable, then we consider ourselves to have a beginning
 967                 // minimum width of 0, since a break could occur right before our run starts, preventing us from ever
 968                 // being appended to a previous text run when considering the total minimum width of the containing block.
 969                 if (hasBreak)
 970                     m_hasBreakableChar = true;
 971                 m_beginMinWidth = hasBreak ? 0 : currMinWidth;
 972             }
 973             m_endMinWidth = currMinWidth;
 974 
 975             m_minWidth = std::max(currMinWidth, m_minWidth);
 976 
 977             i += wordLen - 1;
 978         } else {
 979             // Nowrap can never be broken, so don&#39;t bother setting the
 980             // breakable character boolean. Pre can only be broken if we encounter a newline.
 981             if (style.autoWrap() || isNewline)
 982                 m_hasBreakableChar = true;
 983 
 984             if (isNewline) { // Only set if preserveNewline was true and we saw a newline.
 985                 if (firstLine) {
 986                     firstLine = false;
 987                     leadWidth = 0;
 988                     if (!style.autoWrap())
 989                         m_beginMinWidth = currMaxWidth;
 990                 }
 991 
 992                 if (currMaxWidth &gt; m_maxWidth)
 993                     m_maxWidth = currMaxWidth;
 994                 currMaxWidth = 0;
 995             } else {
 996                 TextRun run = RenderBlock::constructTextRun(*this, i, 1, style);
 997                 run.setTabSize(!style.collapseWhiteSpace(), style.tabSize());
 998                 run.setXPos(leadWidth + currMaxWidth);
 999 
1000                 currMaxWidth += font.width(run, &amp;fallbackFonts);
1001                 glyphOverflow.right = 0;
1002                 needsWordSpacing = isSpace &amp;&amp; !previousCharacterIsSpace &amp;&amp; i == length - 1;
1003             }
1004             ASSERT(lastWordBoundary == i);
1005             lastWordBoundary++;
1006         }
1007     }
1008 
1009     glyphOverflow.left = firstGlyphLeftOverflow.valueOr(glyphOverflow.left);
1010 
1011     if ((needsWordSpacing &amp;&amp; length &gt; 1) || (ignoringSpaces &amp;&amp; !firstWord))
1012         currMaxWidth += wordSpacing;
1013 
1014     m_maxWidth = std::max(currMaxWidth, m_maxWidth);
1015 
1016     if (!style.autoWrap())
1017         m_minWidth = m_maxWidth;
1018 
1019     if (style.whiteSpace() == WhiteSpace::Pre) {
1020         if (firstLine)
1021             m_beginMinWidth = m_maxWidth;
1022         m_endMinWidth = currMaxWidth;
1023     }
1024 
1025     setPreferredLogicalWidthsDirty(false);
1026 }
1027 
1028 template&lt;typename CharacterType&gt; static inline bool isAllCollapsibleWhitespace(const CharacterType* characters, unsigned length, const RenderStyle&amp; style)
1029 {
1030     for (unsigned i = 0; i &lt; length; ++i) {
1031         if (!style.isCollapsibleWhiteSpace(characters[i]))
1032             return false;
1033     }
1034     return true;
1035 }
1036 
1037 bool RenderText::isAllCollapsibleWhitespace() const
1038 {
1039     if (text().is8Bit())
1040         return WebCore::isAllCollapsibleWhitespace(text().characters8(), text().length(), style());
1041     return WebCore::isAllCollapsibleWhitespace(text().characters16(), text().length(), style());
1042 }
1043 
1044 template&lt;typename CharacterType&gt; static inline bool isAllPossiblyCollapsibleWhitespace(const CharacterType* characters, unsigned length)
1045 {
1046     for (unsigned i = 0; i &lt; length; ++i) {
1047         if (!(characters[i] == &#39;\n&#39; || characters[i] == &#39; &#39; || characters[i] == &#39;\t&#39;))
1048             return false;
1049     }
1050     return true;
1051 }
1052 
1053 bool RenderText::containsOnlyHTMLWhitespace(unsigned from, unsigned length) const
1054 {
1055     ASSERT(from &lt;= text().length());
1056     ASSERT(length &lt;= text().length());
1057     ASSERT(from + length &lt;= text().length());
1058     if (text().is8Bit())
1059         return isAllPossiblyCollapsibleWhitespace(text().characters8() + from, length);
1060     return isAllPossiblyCollapsibleWhitespace(text().characters16() + from, length);
1061 }
1062 
1063 Vector&lt;std::pair&lt;unsigned, unsigned&gt;&gt; RenderText::draggedContentRangesBetweenOffsets(unsigned startOffset, unsigned endOffset) const
1064 {
1065     if (!textNode())
1066         return { };
1067 
1068     auto markers = document().markers().markersFor(*textNode(), DocumentMarker::DraggedContent);
1069     if (markers.isEmpty())
1070         return { };
1071 
1072     Vector&lt;std::pair&lt;unsigned, unsigned&gt;&gt; draggedContentRanges;
1073     for (auto* marker : markers) {
1074         unsigned markerStart = std::max(marker-&gt;startOffset(), startOffset);
1075         unsigned markerEnd = std::min(marker-&gt;endOffset(), endOffset);
1076         if (markerStart &gt;= markerEnd || markerStart &gt; endOffset || markerEnd &lt; startOffset)
1077             continue;
1078 
1079         std::pair&lt;unsigned, unsigned&gt; draggedContentRange;
1080         draggedContentRange.first = markerStart;
1081         draggedContentRange.second = markerEnd;
1082         draggedContentRanges.append(draggedContentRange);
1083     }
1084     return draggedContentRanges;
1085 }
1086 
1087 IntPoint RenderText::firstRunLocation() const
1088 {
1089     auto first = LineLayoutTraversal::firstTextBoxFor(*this);
1090     if (!first)
1091         return { };
1092     return IntPoint(first-&gt;rect().location());
1093 }
1094 
1095 void RenderText::setSelectionState(SelectionState state)
1096 {
1097     if (state != SelectionNone)
1098         ensureLineBoxes();
1099 
1100     RenderObject::setSelectionState(state);
1101 
1102     if (canUpdateSelectionOnRootLineBoxes())
1103         m_lineBoxes.setSelectionState(*this, state);
1104 
1105     // The containing block can be null in case of an orphaned tree.
1106     RenderBlock* containingBlock = this-&gt;containingBlock();
1107     if (containingBlock &amp;&amp; !containingBlock-&gt;isRenderView())
1108         containingBlock-&gt;setSelectionState(state);
1109 }
1110 
1111 void RenderText::setTextWithOffset(const String&amp; newText, unsigned offset, unsigned length, bool force)
1112 {
1113     if (!force &amp;&amp; text() == newText)
1114         return;
1115 
1116     int delta = newText.length() - text().length();
1117     unsigned end = offset + length;
1118 
1119     m_linesDirty = simpleLineLayout() || m_lineBoxes.dirtyRange(*this, offset, end, delta);
1120 
1121     setText(newText, force || m_linesDirty);
1122 }
1123 
1124 static inline bool isInlineFlowOrEmptyText(const RenderObject&amp; renderer)
1125 {
1126     return is&lt;RenderInline&gt;(renderer) || (is&lt;RenderText&gt;(renderer) &amp;&amp; downcast&lt;RenderText&gt;(renderer).text().isEmpty());
1127 }
1128 
1129 UChar RenderText::previousCharacter() const
1130 {
1131     // find previous text renderer if one exists
1132     const RenderObject* previousText = this;
1133     while ((previousText = previousText-&gt;previousInPreOrder())) {
1134         if (!isInlineFlowOrEmptyText(*previousText))
1135             break;
1136     }
1137     if (!is&lt;RenderText&gt;(previousText))
1138         return &#39; &#39;;
1139     auto&amp; previousString = downcast&lt;RenderText&gt;(*previousText).text();
1140     return previousString[previousString.length() - 1];
1141 }
1142 
1143 LayoutUnit RenderText::topOfFirstText() const
1144 {
1145     return firstTextBox()-&gt;root().lineTop();
1146 }
1147 
1148 String applyTextTransform(const RenderStyle&amp; style, const String&amp; text, UChar previousCharacter)
1149 {
1150     switch (style.textTransform()) {
1151     case TextTransform::None:
1152         return text;
1153     case TextTransform::Capitalize:
1154         return capitalize(text, previousCharacter); // FIXME: Need to take locale into account.
1155     case TextTransform::Uppercase:
1156         return text.convertToUppercaseWithLocale(style.locale());
1157     case TextTransform::Lowercase:
1158         return text.convertToLowercaseWithLocale(style.locale());
1159     }
1160     ASSERT_NOT_REACHED();
1161     return text;
1162 }
1163 
1164 void RenderText::setRenderedText(const String&amp; newText)
1165 {
1166     ASSERT(!newText.isNull());
1167 
1168     String originalText = this-&gt;originalText();
1169 
1170     m_text = newText;
1171 
1172     if (m_useBackslashAsYenSymbol)
1173         m_text.replace(&#39;\\&#39;, yenSign);
1174 
1175     const auto&amp; style = this-&gt;style();
1176     if (style.textTransform() != TextTransform::None)
1177         m_text = applyTextTransform(style, m_text, previousCharacter());
1178 
1179     switch (style.textSecurity()) {
1180     case TextSecurity::None:
1181         break;
1182 #if !PLATFORM(IOS_FAMILY)
1183     // We use the same characters here as for list markers.
1184     // See the listMarkerText function in RenderListMarker.cpp.
1185     case TextSecurity::Circle:
1186         secureText(whiteBullet);
1187         break;
1188     case TextSecurity::Disc:
1189         secureText(bullet);
1190         break;
1191     case TextSecurity::Square:
1192         secureText(blackSquare);
1193         break;
1194 #else
1195     // FIXME: Why this quirk on iOS?
1196     case TextSecurity::Circle:
1197     case TextSecurity::Disc:
1198     case TextSecurity::Square:
1199         secureText(blackCircle);
1200         break;
1201 #endif
1202     }
1203 
1204     m_isAllASCII = text().isAllASCII();
1205     m_canUseSimpleFontCodePath = computeCanUseSimpleFontCodePath();
1206     m_canUseSimplifiedTextMeasuring = computeCanUseSimplifiedTextMeasuring();
1207 
1208     if (m_text != originalText) {
1209         originalTextMap().set(this, originalText);
1210         m_originalTextDiffersFromRendered = true;
1211     } else if (m_originalTextDiffersFromRendered) {
1212         originalTextMap().remove(this);
1213         m_originalTextDiffersFromRendered = false;
1214     }
1215 }
1216 
1217 void RenderText::secureText(UChar maskingCharacter)
1218 {
1219     // This hides the text by replacing all the characters with the masking character.
1220     // Offsets within the hidden text have to match offsets within the original text
1221     // to handle things like carets and selection, so this won&#39;t work right if any
1222     // of the characters are surrogate pairs or combining marks. Thus, this function
1223     // does not attempt to handle either of those.
1224 
1225     unsigned length = text().length();
1226     if (!length)
1227         return;
1228 
1229     UChar characterToReveal = 0;
1230     unsigned revealedCharactersOffset = 0;
1231 
1232     if (SecureTextTimer* timer = secureTextTimers().get(this)) {
1233         // We take the offset out of the timer to make this one-shot. We count on this being called only once.
1234         // If it&#39;s called a second time we assume the text is different and a character should not be revealed.
1235         revealedCharactersOffset = timer-&gt;takeOffsetAfterLastTypedCharacter();
1236         if (revealedCharactersOffset &amp;&amp; revealedCharactersOffset &lt;= length)
1237             characterToReveal = text()[--revealedCharactersOffset];
1238     }
1239 
1240     UChar* characters;
1241     m_text = String::createUninitialized(length, characters);
1242 
1243     for (unsigned i = 0; i &lt; length; ++i)
1244         characters[i] = maskingCharacter;
1245     if (characterToReveal)
1246         characters[revealedCharactersOffset] = characterToReveal;
1247 }
1248 
1249 bool RenderText::computeCanUseSimplifiedTextMeasuring() const
1250 {
1251     if (!m_canUseSimpleFontCodePath)
1252         return false;
1253 
1254     auto&amp; font = style().fontCascade();
1255     if (font.wordSpacing() || font.letterSpacing())
1256         return false;
1257 
1258     // Additional check on the font codepath.
1259     TextRun run(m_text);
1260     run.setCharacterScanForCodePath(false);
1261     if (font.codePath(run) != FontCascade::Simple)
1262         return false;
1263 
1264     auto whitespaceIsCollapsed = style().collapseWhiteSpace();
1265     for (unsigned i = 0; i &lt; text().length(); ++i) {
1266         if ((!whitespaceIsCollapsed &amp;&amp; text()[i] == &#39;\t&#39;) || text()[i] == noBreakSpace || text()[i] &gt;= HiraganaLetterSmallA)
1267             return false;
1268     }
1269     return true;
1270 }
1271 
1272 void RenderText::setText(const String&amp; text, bool force)
1273 {
1274     ASSERT(!text.isNull());
1275 
1276     if (!force &amp;&amp; text == originalText())
1277         return;
1278 
1279     m_text = text;
1280     if (m_originalTextDiffersFromRendered) {
1281         originalTextMap().remove(this);
1282         m_originalTextDiffersFromRendered = false;
1283     }
1284 
1285     setRenderedText(text);
1286 
1287     setNeedsLayoutAndPrefWidthsRecalc();
1288     m_knownToHaveNoOverflowAndNoFallbackFonts = false;
1289 
1290     if (is&lt;RenderBlockFlow&gt;(*parent()))
1291         downcast&lt;RenderBlockFlow&gt;(*parent()).invalidateLineLayoutPath();
1292 
1293     if (AXObjectCache* cache = document().existingAXObjectCache())
1294         cache-&gt;deferTextChangedIfNeeded(textNode());
1295 }
1296 
1297 String RenderText::textWithoutConvertingBackslashToYenSymbol() const
1298 {
1299     if (!m_useBackslashAsYenSymbol || style().textSecurity() != TextSecurity::None)
1300         return text();
1301 
1302     if (style().textTransform() == TextTransform::None)
1303         return originalText();
1304 
1305     return applyTextTransform(style(), originalText(), previousCharacter());
1306 }
1307 
1308 void RenderText::dirtyLineBoxes(bool fullLayout)
1309 {
1310     if (fullLayout)
1311         m_lineBoxes.deleteAll();
1312     else if (!m_linesDirty)
1313         m_lineBoxes.dirtyAll();
1314     m_linesDirty = false;
1315 }
1316 
1317 std::unique_ptr&lt;InlineTextBox&gt; RenderText::createTextBox()
1318 {
1319     return makeUnique&lt;InlineTextBox&gt;(*this);
1320 }
1321 
1322 void RenderText::positionLineBox(InlineTextBox&amp; textBox)
1323 {
1324     if (!textBox.hasTextContent())
1325         return;
1326     m_containsReversedText |= !textBox.isLeftToRightDirection();
1327 }
1328 
1329 void RenderText::ensureLineBoxes()
1330 {
1331     if (!is&lt;RenderBlockFlow&gt;(*parent()))
1332         return;
1333     downcast&lt;RenderBlockFlow&gt;(*parent()).ensureLineBoxes();
1334 }
1335 
1336 const SimpleLineLayout::Layout* RenderText::simpleLineLayout() const
1337 {
1338     if (!is&lt;RenderBlockFlow&gt;(*parent()))
1339         return nullptr;
1340     return downcast&lt;RenderBlockFlow&gt;(*parent()).simpleLineLayout();
1341 }
1342 
1343 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
1344 const LayoutIntegration::LineLayout* RenderText::layoutFormattingContextLineLayout() const
1345 {
1346     if (!is&lt;RenderBlockFlow&gt;(*parent()))
1347         return nullptr;
1348     return downcast&lt;RenderBlockFlow&gt;(*parent()).layoutFormattingContextLineLayout();
1349 }
1350 #endif
1351 
1352 bool RenderText::usesComplexLineLayoutPath() const
1353 {
1354     if (simpleLineLayout())
1355         return false;
1356 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
1357     if (layoutFormattingContextLineLayout())
1358         return false;
1359 #endif
1360     return true;
1361 }
1362 
1363 float RenderText::width(unsigned from, unsigned len, float xPos, bool firstLine, HashSet&lt;const Font*&gt;* fallbackFonts, GlyphOverflow* glyphOverflow) const
1364 {
1365     if (from &gt;= text().length())
1366         return 0;
1367 
1368     if (from + len &gt; text().length())
1369         len = text().length() - from;
1370 
1371     const RenderStyle&amp; lineStyle = firstLine ? firstLineStyle() : style();
1372     return width(from, len, lineStyle.fontCascade(), xPos, fallbackFonts, glyphOverflow);
1373 }
1374 
1375 float RenderText::width(unsigned from, unsigned len, const FontCascade&amp; f, float xPos, HashSet&lt;const Font*&gt;* fallbackFonts, GlyphOverflow* glyphOverflow) const
1376 {
1377     ASSERT(from + len &lt;= text().length());
1378     if (!text().length())
1379         return 0;
1380 
1381     const RenderStyle&amp; style = this-&gt;style();
1382     float w;
1383     if (&amp;f == &amp;style.fontCascade()) {
1384         if (!style.preserveNewline() &amp;&amp; !from &amp;&amp; len == text().length() &amp;&amp; (!glyphOverflow || !glyphOverflow-&gt;computeBounds)) {
1385             if (fallbackFonts) {
1386                 ASSERT(glyphOverflow);
1387                 if (preferredLogicalWidthsDirty() || !m_knownToHaveNoOverflowAndNoFallbackFonts) {
1388                     const_cast&lt;RenderText*&gt;(this)-&gt;computePreferredLogicalWidths(0, *fallbackFonts, *glyphOverflow);
1389                     if (fallbackFonts-&gt;isEmpty() &amp;&amp; !glyphOverflow-&gt;left &amp;&amp; !glyphOverflow-&gt;right &amp;&amp; !glyphOverflow-&gt;top &amp;&amp; !glyphOverflow-&gt;bottom)
1390                         m_knownToHaveNoOverflowAndNoFallbackFonts = true;
1391                 }
1392                 w = m_maxWidth;
1393             } else
1394                 w = maxLogicalWidth();
1395         } else
1396             w = widthFromCache(f, from, len, xPos, fallbackFonts, glyphOverflow, style);
1397     } else {
1398         TextRun run = RenderBlock::constructTextRun(*this, from, len, style);
1399         run.setCharacterScanForCodePath(!canUseSimpleFontCodePath());
1400         run.setTabSize(!style.collapseWhiteSpace(), style.tabSize());
1401         run.setXPos(xPos);
1402 
1403         w = f.width(run, fallbackFonts, glyphOverflow);
1404     }
1405 
1406     return w;
1407 }
1408 
1409 IntRect RenderText::linesBoundingBox() const
1410 {
1411     auto first = LineLayoutTraversal::firstTextBoxFor(*this);
1412     if (!first)
1413         return { };
1414 
1415     auto boundingBox = first-&gt;rect();
1416     for (auto box = first; ++box;)
1417         boundingBox.uniteEvenIfEmpty(box-&gt;rect());
1418 
1419     return enclosingIntRect(boundingBox);
1420 }
1421 
1422 LayoutRect RenderText::linesVisualOverflowBoundingBox() const
1423 {
1424     ASSERT(!simpleLineLayout());
1425     return m_lineBoxes.visualOverflowBoundingBox(*this);
1426 }
1427 
1428 LayoutRect RenderText::clippedOverflowRectForRepaint(const RenderLayerModelObject* repaintContainer) const
1429 {
1430     RenderObject* rendererToRepaint = containingBlock();
1431 
1432     // Do not cross self-painting layer boundaries.
1433     RenderObject&amp; enclosingLayerRenderer = enclosingLayer()-&gt;renderer();
1434     if (&amp;enclosingLayerRenderer != rendererToRepaint &amp;&amp; !rendererToRepaint-&gt;isDescendantOf(&amp;enclosingLayerRenderer))
1435         rendererToRepaint = &amp;enclosingLayerRenderer;
1436 
1437     // The renderer we chose to repaint may be an ancestor of repaintContainer, but we need to do a repaintContainer-relative repaint.
1438     if (repaintContainer &amp;&amp; repaintContainer != rendererToRepaint &amp;&amp; !rendererToRepaint-&gt;isDescendantOf(repaintContainer))
1439         return repaintContainer-&gt;clippedOverflowRectForRepaint(repaintContainer);
1440 
1441     return rendererToRepaint-&gt;clippedOverflowRectForRepaint(repaintContainer);
1442 }
1443 
1444 LayoutRect RenderText::collectSelectionRectsForLineBoxes(const RenderLayerModelObject* repaintContainer, bool clipToVisibleContent, Vector&lt;LayoutRect&gt;* rects)
1445 {
1446     ASSERT(!needsLayout());
1447     ASSERT(!simpleLineLayout());
1448 
1449     if (selectionState() == SelectionNone)
1450         return LayoutRect();
1451     if (!containingBlock())
1452         return LayoutRect();
1453 
1454     // Now calculate startPos and endPos for painting selection.
1455     // We include a selection while endPos &gt; 0
1456     unsigned startOffset;
1457     unsigned endOffset;
1458     if (selectionState() == SelectionInside) {
1459         // We are fully selected.
1460         startOffset = 0;
1461         endOffset = text().length();
1462     } else {
1463         startOffset = view().selection().startOffset();
1464         endOffset = view().selection().endOffset();
1465         if (selectionState() == SelectionStart)
1466             endOffset = text().length();
1467         else if (selectionState() == SelectionEnd)
1468             startOffset = 0;
1469     }
1470 
1471     if (startOffset == endOffset)
1472         return IntRect();
1473 
1474     LayoutRect resultRect;
1475     if (!rects)
1476         resultRect = m_lineBoxes.selectionRectForRange(startOffset, endOffset);
1477     else {
1478         m_lineBoxes.collectSelectionRectsForRange(startOffset, endOffset, *rects);
1479         for (auto&amp; rect : *rects) {
1480             resultRect.unite(rect);
1481             rect = localToContainerQuad(FloatRect(rect), repaintContainer).enclosingBoundingBox();
1482         }
1483     }
1484 
1485     if (clipToVisibleContent)
1486         return computeRectForRepaint(resultRect, repaintContainer);
1487     return localToContainerQuad(FloatRect(resultRect), repaintContainer).enclosingBoundingBox();
1488 }
1489 
1490 LayoutRect RenderText::collectSelectionRectsForLineBoxes(const RenderLayerModelObject* repaintContainer, bool clipToVisibleContent, Vector&lt;LayoutRect&gt;&amp; rects)
1491 {
1492     return collectSelectionRectsForLineBoxes(repaintContainer, clipToVisibleContent, &amp;rects);
1493 }
1494 
1495 LayoutRect RenderText::selectionRectForRepaint(const RenderLayerModelObject* repaintContainer, bool clipToVisibleContent)
1496 {
1497     return collectSelectionRectsForLineBoxes(repaintContainer, clipToVisibleContent, nullptr);
1498 }
1499 
1500 int RenderText::caretMinOffset() const
1501 {
1502     auto first = LineLayoutTraversal::firstTextBoxFor(*this);
1503     if (!first)
1504         return 0;
1505 
1506     int minOffset = first-&gt;localStartOffset();
1507     for (auto box = first; ++box;)
1508         minOffset = std::min&lt;int&gt;(minOffset, box-&gt;localStartOffset());
1509 
1510     return minOffset;
1511 }
1512 
1513 int RenderText::caretMaxOffset() const
1514 {
1515     auto first = LineLayoutTraversal::firstTextBoxFor(*this);
1516     if (!first)
1517         return text().length();
1518 
1519     int maxOffset = first-&gt;localEndOffset();
1520     for (auto box = first; ++box;)
1521         maxOffset = std::max&lt;int&gt;(maxOffset, box-&gt;localEndOffset());
1522 
1523     return maxOffset;
1524 }
1525 
1526 unsigned RenderText::countRenderedCharacterOffsetsUntil(unsigned offset) const
1527 {
1528     unsigned result = 0;
1529     for (auto&amp; box : LineLayoutTraversal::textBoxesFor(*this)) {
1530         auto start = box.localStartOffset();
1531         auto length = box.length();
1532         if (offset &lt; start)
1533             return result;
1534         if (offset &lt;= start + length) {
1535             result += offset - start;
1536             return result;
1537         }
1538         result += length;
1539     }
1540     return result;
1541 }
1542 
1543 enum class OffsetType { Character, Caret };
1544 static bool containsOffset(const RenderText&amp; text, unsigned offset, OffsetType type)
1545 {
1546     for (auto box = LineLayoutTraversal::firstTextBoxInTextOrderFor(text); box; box.traverseNextInTextOrder()) {
1547         auto start = box-&gt;localStartOffset();
1548         if (offset &lt; start)
1549             return false;
1550         unsigned end = box-&gt;localEndOffset();
1551         if (offset &gt;= start &amp;&amp; offset &lt;= end) {
1552             if (offset == end &amp;&amp; (type == OffsetType::Character || box-&gt;isLineBreak()))
1553                 continue;
1554             if (type == OffsetType::Character)
1555                 return true;
1556             // Return false for offsets inside composed characters.
1557             return !offset || offset == static_cast&lt;unsigned&gt;(text.nextOffset(text.previousOffset(offset)));
1558         }
1559     }
1560     return false;
1561 }
1562 
1563 bool RenderText::containsRenderedCharacterOffset(unsigned offset) const
1564 {
1565     return containsOffset(*this, offset, OffsetType::Character);
1566 }
1567 
1568 bool RenderText::containsCaretOffset(unsigned offset) const
1569 {
1570     return containsOffset(*this, offset, OffsetType::Caret);
1571 }
1572 
1573 bool RenderText::hasRenderedText() const
1574 {
1575     for (auto&amp; box : LineLayoutTraversal::textBoxesFor(*this)) {
1576         if (box.length())
1577             return true;
1578     }
1579     return false;
1580 }
1581 
1582 int RenderText::previousOffset(int current) const
1583 {
1584     if (m_isAllASCII || text().is8Bit())
1585         return current - 1;
1586 
1587     CachedTextBreakIterator iterator(text(), TextBreakIterator::Mode::Caret, nullAtom());
1588     return iterator.preceding(current).valueOr(current - 1);
1589 }
1590 
1591 int RenderText::previousOffsetForBackwardDeletion(int current) const
1592 {
1593     CachedTextBreakIterator iterator(text(), TextBreakIterator::Mode::Delete, nullAtom());
1594     return iterator.preceding(current).valueOr(0);
1595 }
1596 
1597 int RenderText::nextOffset(int current) const
1598 {
1599     if (m_isAllASCII || text().is8Bit())
1600         return current + 1;
1601 
1602     CachedTextBreakIterator iterator(text(), TextBreakIterator::Mode::Caret, nullAtom());
1603     return iterator.following(current).valueOr(current + 1);
1604 }
1605 
1606 bool RenderText::computeCanUseSimpleFontCodePath() const
1607 {
1608     if (m_isAllASCII || text().is8Bit())
1609         return true;
1610     return FontCascade::characterRangeCodePath(text().characters16(), length()) == FontCascade::Simple;
1611 }
1612 
1613 void RenderText::momentarilyRevealLastTypedCharacter(unsigned offsetAfterLastTypedCharacter)
1614 {
1615     if (style().textSecurity() == TextSecurity::None)
1616         return;
1617     auto&amp; secureTextTimer = secureTextTimers().add(this, nullptr).iterator-&gt;value;
1618     if (!secureTextTimer)
1619         secureTextTimer = makeUnique&lt;SecureTextTimer&gt;(*this);
1620     secureTextTimer-&gt;restart(offsetAfterLastTypedCharacter);
1621 }
1622 
1623 StringView RenderText::stringView(unsigned start, Optional&lt;unsigned&gt; stop) const
1624 {
1625     unsigned destination = stop.valueOr(text().length());
1626     ASSERT(start &lt;= length());
1627     ASSERT(destination &lt;= length());
1628     ASSERT(start &lt;= destination);
1629     if (text().is8Bit())
1630         return { text().characters8() + start, destination - start };
1631     return { text().characters16() + start, destination - start };
1632 }
1633 
1634 RenderInline* RenderText::inlineWrapperForDisplayContents()
1635 {
1636     ASSERT(m_hasInlineWrapperForDisplayContents == inlineWrapperForDisplayContentsMap().contains(this));
1637 
1638     if (!m_hasInlineWrapperForDisplayContents)
1639         return nullptr;
1640     return inlineWrapperForDisplayContentsMap().get(this).get();
1641 }
1642 
1643 void RenderText::setInlineWrapperForDisplayContents(RenderInline* wrapper)
1644 {
1645     ASSERT(m_hasInlineWrapperForDisplayContents == inlineWrapperForDisplayContentsMap().contains(this));
1646 
1647     if (!wrapper) {
1648         if (!m_hasInlineWrapperForDisplayContents)
1649             return;
1650         inlineWrapperForDisplayContentsMap().remove(this);
1651         m_hasInlineWrapperForDisplayContents = false;
1652         return;
1653     }
1654     inlineWrapperForDisplayContentsMap().add(this, makeWeakPtr(wrapper));
1655     m_hasInlineWrapperForDisplayContents = true;
1656 }
1657 
1658 RenderText* RenderText::findByDisplayContentsInlineWrapperCandidate(RenderElement&amp; renderer)
1659 {
1660     auto* firstChild = renderer.firstChild();
1661     if (!is&lt;RenderText&gt;(firstChild))
1662         return nullptr;
1663     auto&amp; textRenderer = downcast&lt;RenderText&gt;(*firstChild);
1664     if (textRenderer.inlineWrapperForDisplayContents() != &amp;renderer)
1665         return nullptr;
1666     ASSERT(textRenderer.textNode());
1667     ASSERT(renderer.firstChild() == renderer.lastChild());
1668     return &amp;textRenderer;
1669 
1670 }
1671 
1672 } // namespace WebCore
    </pre>
  </body>
</html>
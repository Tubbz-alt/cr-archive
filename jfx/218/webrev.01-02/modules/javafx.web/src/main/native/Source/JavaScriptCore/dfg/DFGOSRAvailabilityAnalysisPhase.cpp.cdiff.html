<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOSRAvailabilityAnalysisPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGNodeType.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGOSREntry.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGOSRAvailabilityAnalysisPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 33,15 ***</span>
  #include &quot;DFGInsertionSet.h&quot;
  #include &quot;DFGPhase.h&quot;
  #include &quot;JSCInlines.h&quot;
  
  namespace JSC { namespace DFG {
<span class="line-removed">- namespace DFGOSRAvailabilityAnalysisPhaseInternal {</span>
<span class="line-removed">- static constexpr bool verbose = false;</span>
<span class="line-removed">- }</span>
  
  class OSRAvailabilityAnalysisPhase : public Phase {
  public:
      OSRAvailabilityAnalysisPhase(Graph&amp; graph)
          : Phase(graph, &quot;OSR availability analysis&quot;)
      {
      }
<span class="line-new-header">--- 33,13 ---</span>
  #include &quot;DFGInsertionSet.h&quot;
  #include &quot;DFGPhase.h&quot;
  #include &quot;JSCInlines.h&quot;
  
  namespace JSC { namespace DFG {
  
  class OSRAvailabilityAnalysisPhase : public Phase {
<span class="line-added">+     static constexpr bool verbose = false;</span>
  public:
      OSRAvailabilityAnalysisPhase(Graph&amp; graph)
          : Phase(graph, &quot;OSR availability analysis&quot;)
      {
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 73,12 ***</span>
  
          auto dumpBytecodeLivenessAtHead = [&amp;] (BasicBlock* block) {
              dataLog(&quot;Live: &quot;);
              m_graph.forAllLiveInBytecode(
                  block-&gt;at(0)-&gt;origin.forExit,
<span class="line-modified">!                 [&amp;] (VirtualRegister reg) {</span>
<span class="line-modified">!                     dataLog(reg, &quot; &quot;);</span>
                  });
              dataLogLn(&quot;&quot;);
          };
  
          LocalOSRAvailabilityCalculator calculator(m_graph);
<span class="line-new-header">--- 71,12 ---</span>
  
          auto dumpBytecodeLivenessAtHead = [&amp;] (BasicBlock* block) {
              dataLog(&quot;Live: &quot;);
              m_graph.forAllLiveInBytecode(
                  block-&gt;at(0)-&gt;origin.forExit,
<span class="line-modified">!                 [&amp;] (Operand operand) {</span>
<span class="line-modified">!                     dataLog(operand, &quot; &quot;);</span>
                  });
              dataLogLn(&quot;&quot;);
          };
  
          LocalOSRAvailabilityCalculator calculator(m_graph);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 89,11 ***</span>
              for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
                  BasicBlock* block = m_graph.block(blockIndex);
                  if (!block)
                      continue;
  
<span class="line-modified">!                 if (DFGOSRAvailabilityAnalysisPhaseInternal::verbose) {</span>
                      dataLogLn(&quot;Before changing Block #&quot;, block-&gt;index);
                      dumpAvailability(block);
                  }
                  calculator.beginBlock(block);
  
<span class="line-new-header">--- 87,11 ---</span>
              for (BlockIndex blockIndex = 0; blockIndex &lt; m_graph.numBlocks(); ++blockIndex) {
                  BasicBlock* block = m_graph.block(blockIndex);
                  if (!block)
                      continue;
  
<span class="line-modified">!                 if (verbose) {</span>
                      dataLogLn(&quot;Before changing Block #&quot;, block-&gt;index);
                      dumpAvailability(block);
                  }
                  calculator.beginBlock(block);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 104,11 ***</span>
                      continue;
  
                  block-&gt;ssa-&gt;availabilityAtTail = calculator.m_availability;
                  changed = true;
  
<span class="line-modified">!                 if (DFGOSRAvailabilityAnalysisPhaseInternal::verbose) {</span>
                      dataLogLn(&quot;After changing Block #&quot;, block-&gt;index);
                      dumpAvailability(block);
                  }
  
                  for (unsigned successorIndex = block-&gt;numSuccessors(); successorIndex--;) {
<span class="line-new-header">--- 102,11 ---</span>
                      continue;
  
                  block-&gt;ssa-&gt;availabilityAtTail = calculator.m_availability;
                  changed = true;
  
<span class="line-modified">!                 if (verbose) {</span>
                      dataLogLn(&quot;After changing Block #&quot;, block-&gt;index);
                      dumpAvailability(block);
                  }
  
                  for (unsigned successorIndex = block-&gt;numSuccessors(); successorIndex--;) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 118,11 ***</span>
  
                  for (unsigned successorIndex = block-&gt;numSuccessors(); successorIndex--;) {
                      BasicBlock* successor = block-&gt;successor(successorIndex);
                      successor-&gt;ssa-&gt;availabilityAtHead.pruneByLiveness(
                          m_graph, successor-&gt;at(0)-&gt;origin.forExit);
<span class="line-modified">!                     if (DFGOSRAvailabilityAnalysisPhaseInternal::verbose) {</span>
                          dataLogLn(&quot;After pruning Block #&quot;, successor-&gt;index);
                          dumpAvailability(successor);
                          dumpBytecodeLivenessAtHead(successor);
                      }
                  }
<span class="line-new-header">--- 116,11 ---</span>
  
                  for (unsigned successorIndex = block-&gt;numSuccessors(); successorIndex--;) {
                      BasicBlock* successor = block-&gt;successor(successorIndex);
                      successor-&gt;ssa-&gt;availabilityAtHead.pruneByLiveness(
                          m_graph, successor-&gt;at(0)-&gt;origin.forExit);
<span class="line-modified">!                     if (verbose) {</span>
                          dataLogLn(&quot;After pruning Block #&quot;, successor-&gt;index);
                          dumpAvailability(successor);
                          dumpBytecodeLivenessAtHead(successor);
                      }
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 206,53 ***</span>
  void LocalOSRAvailabilityCalculator::executeNode(Node* node)
  {
      switch (node-&gt;op()) {
      case PutStack: {
          StackAccessData* data = node-&gt;stackAccessData();
<span class="line-modified">!         m_availability.m_locals.operand(data-&gt;local).setFlush(data-&gt;flushedAt());</span>
          break;
      }
  
      case KillStack: {
<span class="line-modified">!         m_availability.m_locals.operand(node-&gt;unlinkedLocal()).setFlush(FlushedAt(ConflictingFlush));</span>
          break;
      }
  
      case GetStack: {
          StackAccessData* data = node-&gt;stackAccessData();
<span class="line-modified">!         m_availability.m_locals.operand(data-&gt;local) = Availability(node, data-&gt;flushedAt());</span>
          break;
      }
  
      case MovHint: {
<span class="line-modified">!         m_availability.m_locals.operand(node-&gt;unlinkedLocal()).setNode(node-&gt;child1().node());</span>
          break;
      }
  
      case ZombieHint: {
<span class="line-modified">!         m_availability.m_locals.operand(node-&gt;unlinkedLocal()).setNodeUnavailable();</span>
          break;
      }
  
      case InitializeEntrypointArguments: {
          unsigned entrypointIndex = node-&gt;entrypointIndex();
          const Vector&lt;FlushFormat&gt;&amp; argumentFormats = m_graph.m_argumentFormats[entrypointIndex];
          for (unsigned argument = argumentFormats.size(); argument--; ) {
<span class="line-modified">!             FlushedAt flushedAt = FlushedAt(argumentFormats[argument], virtualRegisterForArgument(argument));</span>
              m_availability.m_locals.argument(argument) = Availability(flushedAt);
          }
          break;
      }
  
      case LoadVarargs:
      case ForwardVarargs: {
          LoadVarargsData* data = node-&gt;loadVarargsData();
<span class="line-modified">!         m_availability.m_locals.operand(data-&gt;count) =</span>
<span class="line-removed">-             Availability(FlushedAt(FlushedInt32, data-&gt;machineCount));</span>
          for (unsigned i = data-&gt;limit; i--;) {
<span class="line-modified">!             m_availability.m_locals.operand(VirtualRegister(data-&gt;start.offset() + i)) =</span>
<span class="line-modified">!                 Availability(FlushedAt(FlushedJSValue, VirtualRegister(data-&gt;machineStart.offset() + i)));</span>
          }
          break;
      }
  
      case PhantomCreateRest:
<span class="line-new-header">--- 204,56 ---</span>
  void LocalOSRAvailabilityCalculator::executeNode(Node* node)
  {
      switch (node-&gt;op()) {
      case PutStack: {
          StackAccessData* data = node-&gt;stackAccessData();
<span class="line-modified">!         m_availability.m_locals.operand(data-&gt;operand).setFlush(data-&gt;flushedAt());</span>
          break;
      }
  
      case KillStack: {
<span class="line-modified">!         m_availability.m_locals.operand(node-&gt;unlinkedOperand()).setFlush(FlushedAt(ConflictingFlush));</span>
          break;
      }
  
      case GetStack: {
          StackAccessData* data = node-&gt;stackAccessData();
<span class="line-modified">!         m_availability.m_locals.operand(data-&gt;operand) = Availability(node, data-&gt;flushedAt());</span>
          break;
      }
  
      case MovHint: {
<span class="line-modified">!         m_availability.m_locals.operand(node-&gt;unlinkedOperand()).setNode(node-&gt;child1().node());</span>
          break;
      }
  
      case ZombieHint: {
<span class="line-modified">!         m_availability.m_locals.operand(node-&gt;unlinkedOperand()).setNodeUnavailable();</span>
          break;
      }
  
      case InitializeEntrypointArguments: {
          unsigned entrypointIndex = node-&gt;entrypointIndex();
          const Vector&lt;FlushFormat&gt;&amp; argumentFormats = m_graph.m_argumentFormats[entrypointIndex];
          for (unsigned argument = argumentFormats.size(); argument--; ) {
<span class="line-modified">!             FlushedAt flushedAt = FlushedAt(argumentFormats[argument], virtualRegisterForArgumentIncludingThis(argument));</span>
              m_availability.m_locals.argument(argument) = Availability(flushedAt);
          }
          break;
      }
  
<span class="line-added">+     case VarargsLength: {</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      case LoadVarargs:
      case ForwardVarargs: {
          LoadVarargsData* data = node-&gt;loadVarargsData();
<span class="line-modified">!         m_availability.m_locals.operand(data-&gt;count) = Availability(FlushedAt(FlushedInt32, data-&gt;machineCount));</span>
          for (unsigned i = data-&gt;limit; i--;) {
<span class="line-modified">!             m_availability.m_locals.operand(data-&gt;start + i) =</span>
<span class="line-modified">!                 Availability(FlushedAt(FlushedJSValue, data-&gt;machineStart + i));</span>
          }
          break;
      }
  
      case PhantomCreateRest:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 270,24 ***</span>
              numberOfArgumentsToSkip = node-&gt;numberOfArgumentsToSkip();
  
          if (inlineCallFrame-&gt;isVarargs()) {
              // Record how to read each argument and the argument count.
              Availability argumentCount =
<span class="line-modified">!                 m_availability.m_locals.operand(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCount);</span>
  
              m_availability.m_heap.set(PromotedHeapLocation(ArgumentCountPLoc, node), argumentCount);
          }
  
          if (inlineCallFrame-&gt;isClosureCall) {
              Availability callee = m_availability.m_locals.operand(
<span class="line-modified">!                 inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee);</span>
              m_availability.m_heap.set(PromotedHeapLocation(ArgumentsCalleePLoc, node), callee);
          }
  
<span class="line-modified">!         for (unsigned i = numberOfArgumentsToSkip; i &lt; inlineCallFrame-&gt;argumentCountIncludingThis - 1; ++i) {</span>
              Availability argument = m_availability.m_locals.operand(
<span class="line-modified">!                 inlineCallFrame-&gt;stackOffset + CallFrame::argumentOffset(i));</span>
  
              m_availability.m_heap.set(PromotedHeapLocation(ArgumentPLoc, node, i), argument);
          }
          break;
      }
<span class="line-new-header">--- 271,24 ---</span>
              numberOfArgumentsToSkip = node-&gt;numberOfArgumentsToSkip();
  
          if (inlineCallFrame-&gt;isVarargs()) {
              // Record how to read each argument and the argument count.
              Availability argumentCount =
<span class="line-modified">!                 m_availability.m_locals.operand(VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::argumentCountIncludingThis));</span>
  
              m_availability.m_heap.set(PromotedHeapLocation(ArgumentCountPLoc, node), argumentCount);
          }
  
          if (inlineCallFrame-&gt;isClosureCall) {
              Availability callee = m_availability.m_locals.operand(
<span class="line-modified">!                 VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrameSlot::callee));</span>
              m_availability.m_heap.set(PromotedHeapLocation(ArgumentsCalleePLoc, node), callee);
          }
  
<span class="line-modified">!         for (unsigned i = numberOfArgumentsToSkip; i &lt; static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1); ++i) {</span>
              Availability argument = m_availability.m_locals.operand(
<span class="line-modified">!                 VirtualRegister(inlineCallFrame-&gt;stackOffset + CallFrame::argumentOffset(i)));</span>
  
              m_availability.m_heap.set(PromotedHeapLocation(ArgumentPLoc, node, i), argument);
          }
          break;
      }
</pre>
<center><a href="DFGNodeType.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGOSREntry.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
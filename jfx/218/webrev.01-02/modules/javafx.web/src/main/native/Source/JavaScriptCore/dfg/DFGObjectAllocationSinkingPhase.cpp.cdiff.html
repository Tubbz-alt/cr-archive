<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGObjectAllocationSinkingPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGOSRExitCompilerCommon.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGOpInfo.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGObjectAllocationSinkingPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2015-2018 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2015-2020 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 38,19 ***</span>
  #include &quot;DFGOSRAvailabilityAnalysisPhase.h&quot;
  #include &quot;DFGPhase.h&quot;
  #include &quot;DFGPromotedHeapLocation.h&quot;
  #include &quot;DFGSSACalculator.h&quot;
  #include &quot;DFGValidate.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &lt;wtf/StdList.h&gt;
  
  namespace JSC { namespace DFG {
  
  namespace {
  
  namespace DFGObjectAllocationSinkingPhaseInternal {
<span class="line-modified">! static const bool verbose = false;</span>
  }
  
  // In order to sink object cycles, we use a points-to analysis coupled
  // with an escape analysis. This analysis is actually similar to an
  // abstract interpreter focused on local allocations and ignoring
<span class="line-new-header">--- 38,20 ---</span>
  #include &quot;DFGOSRAvailabilityAnalysisPhase.h&quot;
  #include &quot;DFGPhase.h&quot;
  #include &quot;DFGPromotedHeapLocation.h&quot;
  #include &quot;DFGSSACalculator.h&quot;
  #include &quot;DFGValidate.h&quot;
<span class="line-added">+ #include &quot;JSArrayIterator.h&quot;</span>
  #include &quot;JSCInlines.h&quot;
  #include &lt;wtf/StdList.h&gt;
  
  namespace JSC { namespace DFG {
  
  namespace {
  
  namespace DFGObjectAllocationSinkingPhaseInternal {
<span class="line-modified">! static constexpr bool verbose = false;</span>
  }
  
  // In order to sink object cycles, we use a points-to analysis coupled
  // with an escape analysis. This analysis is actually similar to an
  // abstract interpreter focused on local allocations and ignoring
</pre>
<hr />
<pre>
<span class="line-old-header">*** 138,11 ***</span>
      // We use Escaped as a special allocation kind because when we
      // decide to sink an allocation, we still need to keep track of it
      // once it is escaped if it still has pointers to it in order to
      // replace any use of those pointers by the corresponding
      // materialization
<span class="line-modified">!     enum class Kind { Escaped, Object, Activation, Function, GeneratorFunction, AsyncFunction, AsyncGeneratorFunction, RegExpObject };</span>
  
      using Fields = HashMap&lt;PromotedLocationDescriptor, Node*&gt;;
  
      explicit Allocation(Node* identifier = nullptr, Kind kind = Kind::Escaped)
          : m_identifier(identifier)
<span class="line-new-header">--- 139,11 ---</span>
      // We use Escaped as a special allocation kind because when we
      // decide to sink an allocation, we still need to keep track of it
      // once it is escaped if it still has pointers to it in order to
      // replace any use of those pointers by the corresponding
      // materialization
<span class="line-modified">!     enum class Kind { Escaped, Object, Activation, Function, GeneratorFunction, AsyncFunction, AsyncGeneratorFunction, InternalFieldObject, RegExpObject };</span>
  
      using Fields = HashMap&lt;PromotedLocationDescriptor, Node*&gt;;
  
      explicit Allocation(Node* identifier = nullptr, Kind kind = Kind::Escaped)
          : m_identifier(identifier)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 243,10 ***</span>
<span class="line-new-header">--- 244,15 ---</span>
      bool isFunctionAllocation() const
      {
          return m_kind == Kind::Function || m_kind == Kind::GeneratorFunction || m_kind == Kind::AsyncFunction;
      }
  
<span class="line-added">+     bool isInternalFieldObjectAllocation() const</span>
<span class="line-added">+     {</span>
<span class="line-added">+         return m_kind == Kind::InternalFieldObject;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      bool isRegExpObjectAllocation() const
      {
          return m_kind == Kind::RegExpObject;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 289,10 ***</span>
<span class="line-new-header">--- 295,14 ---</span>
  
          case Kind::AsyncFunction:
              out.print(&quot;AsyncFunction&quot;);
              break;
  
<span class="line-added">+         case Kind::InternalFieldObject:</span>
<span class="line-added">+             out.print(&quot;InternalFieldObject&quot;);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+ </span>
          case Kind::AsyncGeneratorFunction:
              out.print(&quot;AsyncGeneratorFunction&quot;);
              break;
  
          case Kind::Activation:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 390,19 ***</span>
      // different nodes can never point to an unescaped local
      // allocation.
      Node* follow(Node* node) const
      {
          auto iter = m_pointers.find(node);
<span class="line-modified">!         ASSERT(iter == m_pointers.end() || m_allocations.contains(iter-&gt;value));</span>
          return iter == m_pointers.end() ? nullptr : iter-&gt;value;
      }
  
      Node* follow(PromotedHeapLocation location) const
      {
          const Allocation&amp; base = m_allocations.find(location.base())-&gt;value;
          auto iter = base.fields().find(location.descriptor());
<span class="line-removed">- </span>
          if (iter == base.fields().end())
              return nullptr;
  
          return iter-&gt;value;
      }
<span class="line-new-header">--- 400,18 ---</span>
      // different nodes can never point to an unescaped local
      // allocation.
      Node* follow(Node* node) const
      {
          auto iter = m_pointers.find(node);
<span class="line-modified">!         ASSERT(iter == m_pointers.end() || (!iter-&gt;value || m_allocations.contains(iter-&gt;value)));</span>
          return iter == m_pointers.end() ? nullptr : iter-&gt;value;
      }
  
      Node* follow(PromotedHeapLocation location) const
      {
          const Allocation&amp; base = m_allocations.find(location.base())-&gt;value;
          auto iter = base.fields().find(location.descriptor());
          if (iter == base.fields().end())
              return nullptr;
  
          return iter-&gt;value;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 426,10 ***</span>
<span class="line-new-header">--- 435,16 ---</span>
              return nullptr;
  
          return &amp;getAllocation(identifier);
      }
  
<span class="line-added">+     bool isUnescapedAllocation(Node* identifier) const</span>
<span class="line-added">+     {</span>
<span class="line-added">+         auto iter = m_allocations.find(identifier);</span>
<span class="line-added">+         return iter != m_allocations.end() &amp;&amp; !iter-&gt;value.isEscapedAllocation();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      // This allows us to store the escapees only when necessary. If
      // set, the current escapees can be retrieved at any time using
      // takeEscapees(), which will clear the cached set of escapees;
      // otherwise the heap won&#39;t remember escaping allocations.
      void setWantEscapees()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 487,16 ***</span>
                  mergePointerSets(allocationEntry.value.fields(), allocationIter-&gt;value.fields(), toEscape);
                  allocationEntry.value.mergeStructures(allocationIter-&gt;value.structures());
              }
          }
  
<span class="line-modified">!         mergePointerSets(m_pointers, other.m_pointers, toEscape);</span>
  
          for (Node* identifier : toEscape)
              escapeAllocation(identifier);
  
<span class="line-modified">!         if (!ASSERT_DISABLED) {</span>
              for (const auto&amp; entry : m_allocations)
                  ASSERT_UNUSED(entry, entry.value.isEscapedAllocation() || other.m_allocations.contains(entry.key));
          }
  
          // If there is no remaining pointer to an allocation, we can
<span class="line-new-header">--- 502,79 ---</span>
                  mergePointerSets(allocationEntry.value.fields(), allocationIter-&gt;value.fields(), toEscape);
                  allocationEntry.value.mergeStructures(allocationIter-&gt;value.structures());
              }
          }
  
<span class="line-modified">!         {</span>
<span class="line-added">+             // This works because we won&#39;t collect all pointers until all of our predecessors</span>
<span class="line-added">+             // merge their pointer sets with ours. That allows us to see the full state of the</span>
<span class="line-added">+             // world during our fixpoint analysis. Once we have the full set of pointers, we</span>
<span class="line-added">+             // only mark pointers to TOP, so we will eventually converge.</span>
<span class="line-added">+             for (auto entry : other.m_pointers) {</span>
<span class="line-added">+                 auto addResult = m_pointers.add(entry.key, entry.value);</span>
<span class="line-added">+                 if (addResult.iterator-&gt;value != entry.value) {</span>
<span class="line-added">+                     if (addResult.iterator-&gt;value) {</span>
<span class="line-added">+                         toEscape.addVoid(addResult.iterator-&gt;value);</span>
<span class="line-added">+                         addResult.iterator-&gt;value = nullptr;</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                     if (entry.value)</span>
<span class="line-added">+                         toEscape.addVoid(entry.value);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+             // This allows us to rule out pointers for graphs like this:</span>
<span class="line-added">+             // bb#0</span>
<span class="line-added">+             // branch #1, #2</span>
<span class="line-added">+             // #1:</span>
<span class="line-added">+             // x = pointer A</span>
<span class="line-added">+             // jump #3</span>
<span class="line-added">+             // #2:</span>
<span class="line-added">+             // y = pointer B</span>
<span class="line-added">+             // jump #3</span>
<span class="line-added">+             // #3:</span>
<span class="line-added">+             // ...</span>
<span class="line-added">+             //</span>
<span class="line-added">+             // When we merge state at #3, we&#39;ll very likely prune away the x and y pointer,</span>
<span class="line-added">+             // since they&#39;re not live. But if they do happen to make it to this merge function, when</span>
<span class="line-added">+             // #3 merges with #2 and #1, it&#39;ll eventually rule out x and y as not existing</span>
<span class="line-added">+             // in the other, and therefore not existing in #3, which is the desired behavior.</span>
<span class="line-added">+             //</span>
<span class="line-added">+             // This also is necessary for a graph like this:</span>
<span class="line-added">+             // #0</span>
<span class="line-added">+             // o = {}</span>
<span class="line-added">+             // o2 = {}</span>
<span class="line-added">+             // jump #1</span>
<span class="line-added">+             //</span>
<span class="line-added">+             // #1</span>
<span class="line-added">+             // o.f = o2</span>
<span class="line-added">+             // effects()</span>
<span class="line-added">+             // x = o.f</span>
<span class="line-added">+             // escape(o)</span>
<span class="line-added">+             // branch #2, #1</span>
<span class="line-added">+             //</span>
<span class="line-added">+             // #2</span>
<span class="line-added">+             // x cannot be o2 here, it has to be TOP</span>
<span class="line-added">+             // ...</span>
<span class="line-added">+             //</span>
<span class="line-added">+             // On the first fixpoint iteration, we might think that x is o2 at the head</span>
<span class="line-added">+             // of #2. However, when we fixpoint our analysis, we determine that o gets</span>
<span class="line-added">+             // escaped. This means that when we fixpoint, x will eventually not be a pointer.</span>
<span class="line-added">+             // When we merge again here, we&#39;ll notice and mark o2 as escaped.</span>
<span class="line-added">+             for (auto&amp; entry : m_pointers) {</span>
<span class="line-added">+                 if (!other.m_pointers.contains(entry.key)) {</span>
<span class="line-added">+                     if (entry.value) {</span>
<span class="line-added">+                         toEscape.addVoid(entry.value);</span>
<span class="line-added">+                         entry.value = nullptr;</span>
<span class="line-added">+                         ASSERT(!m_pointers.find(entry.key)-&gt;value);</span>
<span class="line-added">+                     }</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
  
          for (Node* identifier : toEscape)
              escapeAllocation(identifier);
  
<span class="line-modified">!         if (ASSERT_ENABLED) {</span>
              for (const auto&amp; entry : m_allocations)
                  ASSERT_UNUSED(entry, entry.value.isEscapedAllocation() || other.m_allocations.contains(entry.key));
          }
  
          // If there is no remaining pointer to an allocation, we can
</pre>
<hr />
<pre>
<span class="line-old-header">*** 517,17 ***</span>
          prune();
      }
  
      void assertIsValid() const
      {
<span class="line-modified">!         if (ASSERT_DISABLED)</span>
              return;
  
          // Pointers should point to an actual allocation
          for (const auto&amp; entry : m_pointers) {
<span class="line-modified">!             ASSERT_UNUSED(entry, entry.value);</span>
<span class="line-modified">!             ASSERT(m_allocations.contains(entry.value));</span>
          }
  
          for (const auto&amp; allocationEntry : m_allocations) {
              // Fields should point to an actual allocation
              for (const auto&amp; fieldEntry : allocationEntry.value.fields()) {
<span class="line-new-header">--- 595,17 ---</span>
          prune();
      }
  
      void assertIsValid() const
      {
<span class="line-modified">!         if (!ASSERT_ENABLED)</span>
              return;
  
          // Pointers should point to an actual allocation
          for (const auto&amp; entry : m_pointers) {
<span class="line-modified">!             if (entry.value)</span>
<span class="line-modified">!                 ASSERT(m_allocations.contains(entry.value));</span>
          }
  
          for (const auto&amp; allocationEntry : m_allocations) {
              // Fields should point to an actual allocation
              for (const auto&amp; fieldEntry : allocationEntry.value.fields()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 553,23 ***</span>
      const HashMap&lt;Node*, Allocation&gt;&amp; allocations() const
      {
          return m_allocations;
      }
  
<span class="line-removed">-     const HashMap&lt;Node*, Node*&gt;&amp; pointers() const</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         return m_pointers;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      void dump(PrintStream&amp; out) const
      {
          out.print(&quot;  Allocations:\n&quot;);
          for (const auto&amp; entry : m_allocations)
              out.print(&quot;    #&quot;, entry.key, &quot;: &quot;, entry.value, &quot;\n&quot;);
          out.print(&quot;  Pointers:\n&quot;);
<span class="line-modified">!         for (const auto&amp; entry : m_pointers)</span>
<span class="line-modified">!             out.print(&quot;    &quot;, entry.key, &quot; =&gt; #&quot;, entry.value, &quot;\n&quot;);</span>
      }
  
      bool reached() const
      {
          return m_reached;
<span class="line-new-header">--- 631,23 ---</span>
      const HashMap&lt;Node*, Allocation&gt;&amp; allocations() const
      {
          return m_allocations;
      }
  
      void dump(PrintStream&amp; out) const
      {
          out.print(&quot;  Allocations:\n&quot;);
          for (const auto&amp; entry : m_allocations)
              out.print(&quot;    #&quot;, entry.key, &quot;: &quot;, entry.value, &quot;\n&quot;);
          out.print(&quot;  Pointers:\n&quot;);
<span class="line-modified">!         for (const auto&amp; entry : m_pointers) {</span>
<span class="line-modified">!             out.print(&quot;    &quot;, entry.key, &quot; =&gt; #&quot;);</span>
<span class="line-added">+             if (entry.value)</span>
<span class="line-added">+                 out.print(entry.value, &quot;\n&quot;);</span>
<span class="line-added">+             else</span>
<span class="line-added">+                 out.print(&quot;TOP\n&quot;);</span>
<span class="line-added">+         }</span>
      }
  
      bool reached() const
      {
          return m_reached;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 659,12 ***</span>
      }
  
      void prune()
      {
          NodeSet reachable;
<span class="line-modified">!         for (const auto&amp; entry : m_pointers)</span>
<span class="line-modified">!             reachable.addVoid(entry.value);</span>
  
          // Repeatedly mark as reachable allocations in fields of other
          // reachable allocations
          {
              Vector&lt;Node*&gt; worklist;
<span class="line-new-header">--- 737,14 ---</span>
      }
  
      void prune()
      {
          NodeSet reachable;
<span class="line-modified">!         for (const auto&amp; entry : m_pointers) {</span>
<span class="line-modified">!             if (entry.value)</span>
<span class="line-added">+                 reachable.addVoid(entry.value);</span>
<span class="line-added">+         }</span>
  
          // Repeatedly mark as reachable allocations in fields of other
          // reachable allocations
          {
              Vector&lt;Node*&gt; worklist;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 730,11 ***</span>
          performLivenessAnalysis(m_graph);
          performOSRAvailabilityAnalysis(m_graph);
          m_combinedLiveness = CombinedLiveness(m_graph);
  
          CString graphBeforeSinking;
<span class="line-modified">!         if (Options::verboseValidationFailure() &amp;&amp; Options::validateGraphAtEachPhase()) {</span>
              StringPrintStream out;
              m_graph.dump(out);
              graphBeforeSinking = out.toCString();
          }
  
<span class="line-new-header">--- 810,11 ---</span>
          performLivenessAnalysis(m_graph);
          performOSRAvailabilityAnalysis(m_graph);
          m_combinedLiveness = CombinedLiveness(m_graph);
  
          CString graphBeforeSinking;
<span class="line-modified">!         if (UNLIKELY(Options::verboseValidationFailure() &amp;&amp; Options::validateGraphAtEachPhase())) {</span>
              StringPrintStream out;
              m_graph.dump(out);
              graphBeforeSinking = out.toCString();
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 798,25 ***</span>
                  // We keep only pointers that are live, and only
                  // allocations that are either live, pointed to by a
                  // live pointer, or (recursively) stored in a field of
                  // a live allocation.
                  //
<span class="line-modified">!                 // This means we can accidentaly leak non-dominating</span>
                  // nodes into the successor. However, due to the
                  // non-dominance property, we are guaranteed that the
                  // successor has at least one predecessor that is not
                  // dominated either: this means any reference to a
                  // non-dominating allocation in the successor will
                  // trigger an escape and get pruned during the merge.
                  m_heap.pruneByLiveness(m_combinedLiveness.liveAtTail[block]);
  
<span class="line-modified">!                 for (BasicBlock* successorBlock : block-&gt;successors())</span>
                      m_heapAtHead[successorBlock].merge(m_heap);
              }
          } while (changed);
      }
  
      template&lt;typename WriteFunctor, typename ResolveFunctor&gt;
      void handleNode(
          Node* node,
          const WriteFunctor&amp; heapWrite,
          const ResolveFunctor&amp; heapResolve)
<span class="line-new-header">--- 878,47 ---</span>
                  // We keep only pointers that are live, and only
                  // allocations that are either live, pointed to by a
                  // live pointer, or (recursively) stored in a field of
                  // a live allocation.
                  //
<span class="line-modified">!                 // This means we can accidentally leak non-dominating</span>
                  // nodes into the successor. However, due to the
                  // non-dominance property, we are guaranteed that the
                  // successor has at least one predecessor that is not
                  // dominated either: this means any reference to a
                  // non-dominating allocation in the successor will
                  // trigger an escape and get pruned during the merge.
                  m_heap.pruneByLiveness(m_combinedLiveness.liveAtTail[block]);
  
<span class="line-modified">!                 for (BasicBlock* successorBlock : block-&gt;successors()) {</span>
<span class="line-added">+                     // FIXME: Maybe we should:</span>
<span class="line-added">+                     // 1. Store the liveness pruned heap as part of m_heapAtTail</span>
<span class="line-added">+                     // 2. Move this code above where we make block merge with</span>
<span class="line-added">+                     // its predecessors before walking the block forward.</span>
<span class="line-added">+                     // https://bugs.webkit.org/show_bug.cgi?id=206041</span>
<span class="line-added">+                     LocalHeap heap = m_heapAtHead[successorBlock];</span>
                      m_heapAtHead[successorBlock].merge(m_heap);
<span class="line-added">+                     if (heap != m_heapAtHead[successorBlock])</span>
<span class="line-added">+                         changed = true;</span>
<span class="line-added">+                 }</span>
              }
          } while (changed);
      }
  
<span class="line-added">+     template&lt;typename InternalFieldClass&gt;</span>
<span class="line-added">+     Allocation* handleInternalFieldClass(Node* node, HashMap&lt;PromotedLocationDescriptor, LazyNode&gt;&amp; writes)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         Allocation* result = &amp;m_heap.newAllocation(node, Allocation::Kind::InternalFieldObject);</span>
<span class="line-added">+         writes.add(StructurePLoc, LazyNode(m_graph.freeze(node-&gt;structure().get())));</span>
<span class="line-added">+         auto initialValues = InternalFieldClass::initialValues();</span>
<span class="line-added">+         static_assert(initialValues.size() == InternalFieldClass::numberOfInternalFields);</span>
<span class="line-added">+         for (unsigned index = 0; index &lt; initialValues.size(); ++index)</span>
<span class="line-added">+             writes.add(PromotedLocationDescriptor(InternalFieldObjectPLoc, index), LazyNode(m_graph.freeze(initialValues[index])));</span>
<span class="line-added">+ </span>
<span class="line-added">+         return result;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      template&lt;typename WriteFunctor, typename ResolveFunctor&gt;
      void handleNode(
          Node* node,
          const WriteFunctor&amp; heapWrite,
          const ResolveFunctor&amp; heapResolve)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 857,10 ***</span>
<span class="line-new-header">--- 959,15 ---</span>
              writes.add(FunctionExecutablePLoc, LazyNode(node-&gt;cellOperand()));
              writes.add(FunctionActivationPLoc, LazyNode(node-&gt;child1().node()));
              break;
          }
  
<span class="line-added">+         case NewArrayIterator: {</span>
<span class="line-added">+             target = handleInternalFieldClass&lt;JSArrayIterator&gt;(node, writes);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          case NewRegexp: {
              target = &amp;m_heap.newAllocation(node, Allocation::Kind::RegExpObject);
  
              writes.add(RegExpObjectRegExpPLoc, LazyNode(node-&gt;cellOperand()));
              writes.add(RegExpObjectLastIndexPLoc, LazyNode(node-&gt;child1().node()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1067,10 ***</span>
<span class="line-new-header">--- 1174,30 ---</span>
                  m_heap.escape(node-&gt;child1().node());
                  m_heap.escape(node-&gt;child2().node());
              }
              break;
  
<span class="line-added">+         case GetInternalField: {</span>
<span class="line-added">+             target = m_heap.onlyLocalAllocation(node-&gt;child1().node());</span>
<span class="line-added">+             if (target &amp;&amp; target-&gt;isInternalFieldObjectAllocation())</span>
<span class="line-added">+                 exactRead = PromotedLocationDescriptor(InternalFieldObjectPLoc, node-&gt;internalFieldIndex());</span>
<span class="line-added">+             else</span>
<span class="line-added">+                 m_heap.escape(node-&gt;child1().node());</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         case PutInternalField: {</span>
<span class="line-added">+             target = m_heap.onlyLocalAllocation(node-&gt;child1().node());</span>
<span class="line-added">+             if (target &amp;&amp; target-&gt;isInternalFieldObjectAllocation())</span>
<span class="line-added">+                 writes.add(PromotedLocationDescriptor(InternalFieldObjectPLoc, node-&gt;internalFieldIndex()), LazyNode(node-&gt;child2().node()));</span>
<span class="line-added">+             else {</span>
<span class="line-added">+                 m_heap.escape(node-&gt;child1().node());</span>
<span class="line-added">+                 m_heap.escape(node-&gt;child2().node());</span>
<span class="line-added">+             }</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          case Check:
          case CheckVarargs:
              m_graph.doToChildren(
                  node,
                  [&amp;] (Edge edge) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1088,11 ***</span>
          case PutHint:
              // Handled by OSR availability analysis
              break;
  
          case FilterCallLinkStatus:
<span class="line-modified">!         case FilterGetByIdStatus:</span>
          case FilterPutByIdStatus:
          case FilterInByIdStatus:
              break;
  
          default:
<span class="line-new-header">--- 1215,11 ---</span>
          case PutHint:
              // Handled by OSR availability analysis
              break;
  
          case FilterCallLinkStatus:
<span class="line-modified">!         case FilterGetByStatus:</span>
          case FilterPutByIdStatus:
          case FilterInByIdStatus:
              break;
  
          default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1559,10 ***</span>
<span class="line-new-header">--- 1686,19 ---</span>
                  where-&gt;origin.withSemantic(
                      allocation.identifier()-&gt;origin.semantic),
                  OpInfo(executable));
          }
  
<span class="line-added">+         case Allocation::Kind::InternalFieldObject: {</span>
<span class="line-added">+             ObjectMaterializationData* data = m_graph.m_objectMaterializationData.add();</span>
<span class="line-added">+             return m_graph.addNode(</span>
<span class="line-added">+                 allocation.identifier()-&gt;prediction(), Node::VarArg, MaterializeNewInternalFieldObject,</span>
<span class="line-added">+                 where-&gt;origin.withSemantic(</span>
<span class="line-added">+                     allocation.identifier()-&gt;origin.semantic),</span>
<span class="line-added">+                 OpInfo(allocation.identifier()-&gt;structure()), OpInfo(data), 0, 0);</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          case Allocation::Kind::Activation: {
              ObjectMaterializationData* data = m_graph.m_objectMaterializationData.add();
              FrozenValue* symbolTable = allocation.identifier()-&gt;cellOperand();
  
              return m_graph.addNode(
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1813,11 ***</span>
                  insertOSRHintsForUpdate(
                      0, block-&gt;at(0)-&gt;origin, canExit,
                      availabilityCalculator.m_availability, identifier, phiDef-&gt;value());
  
                  for (PromotedHeapLocation location : hintsForPhi[variable-&gt;index()]) {
<span class="line-modified">!                     if (m_heap.onlyLocalAllocation(location.base())) {</span>
                          m_insertionSet.insert(0,
                              location.createHint(m_graph, block-&gt;at(0)-&gt;origin.withInvalidExit(), phiDef-&gt;value()));
                          m_localMapping.set(location, phiDef-&gt;value());
                      }
                  }
<span class="line-new-header">--- 1949,11 ---</span>
                  insertOSRHintsForUpdate(
                      0, block-&gt;at(0)-&gt;origin, canExit,
                      availabilityCalculator.m_availability, identifier, phiDef-&gt;value());
  
                  for (PromotedHeapLocation location : hintsForPhi[variable-&gt;index()]) {
<span class="line-modified">!                     if (m_heap.isUnescapedAllocation(location.base())) {</span>
                          m_insertionSet.insert(0,
                              location.createHint(m_graph, block-&gt;at(0)-&gt;origin.withInvalidExit(), phiDef-&gt;value()));
                          m_localMapping.set(location, phiDef-&gt;value());
                      }
                  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1946,10 ***</span>
<span class="line-new-header">--- 2082,14 ---</span>
  
                      case NewAsyncFunction:
                          node-&gt;convertToPhantomNewAsyncFunction();
                          break;
  
<span class="line-added">+                     case NewArrayIterator:</span>
<span class="line-added">+                         node-&gt;convertToPhantomNewArrayIterator();</span>
<span class="line-added">+                         break;</span>
<span class="line-added">+ </span>
                      case CreateActivation:
                          node-&gt;convertToPhantomCreateActivation();
                          break;
  
                      case NewRegexp:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2105,11 ***</span>
              if (!availability.m_locals[i].hasNode())
                  continue;
              if (m_heap.follow(availability.m_locals[i].node()) != escapee)
                  continue;
  
<span class="line-modified">!             int operand = availability.m_locals.operandForIndex(i);</span>
              m_insertionSet.insertNode(
                  nodeIndex, SpecNone, MovHint, origin.takeValidExit(canExit), OpInfo(operand),
                  materialization-&gt;defaultEdge());
          }
      }
<span class="line-new-header">--- 2245,11 ---</span>
              if (!availability.m_locals[i].hasNode())
                  continue;
              if (m_heap.follow(availability.m_locals[i].node()) != escapee)
                  continue;
  
<span class="line-modified">!             Operand operand = availability.m_locals.operandForIndex(i);</span>
              m_insertionSet.insertNode(
                  nodeIndex, SpecNone, MovHint, origin.takeValidExit(canExit), OpInfo(operand),
                  materialization-&gt;defaultEdge());
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2222,10 ***</span>
<span class="line-new-header">--- 2362,50 ---</span>
  
              node-&gt;child1() = Edge(resolve(block, activation), KnownCellUse);
              break;
          }
  
<span class="line-added">+         case MaterializeNewInternalFieldObject: {</span>
<span class="line-added">+             ObjectMaterializationData&amp; data = node-&gt;objectMaterializationData();</span>
<span class="line-added">+ </span>
<span class="line-added">+             unsigned firstChild = m_graph.m_varArgChildren.size();</span>
<span class="line-added">+ </span>
<span class="line-added">+             Vector&lt;PromotedHeapLocation&gt; locations = m_locationsForAllocation.get(escapee);</span>
<span class="line-added">+ </span>
<span class="line-added">+             PromotedHeapLocation structure(StructurePLoc, allocation.identifier());</span>
<span class="line-added">+             ASSERT(locations.contains(structure));</span>
<span class="line-added">+             m_graph.m_varArgChildren.append(Edge(resolve(block, structure), KnownCellUse));</span>
<span class="line-added">+ </span>
<span class="line-added">+             for (PromotedHeapLocation location : locations) {</span>
<span class="line-added">+                 switch (location.kind()) {</span>
<span class="line-added">+                 case StructurePLoc: {</span>
<span class="line-added">+                     ASSERT(location == structure);</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 case InternalFieldObjectPLoc: {</span>
<span class="line-added">+                     ASSERT(location.base() == allocation.identifier());</span>
<span class="line-added">+                     data.m_properties.append(location.descriptor());</span>
<span class="line-added">+                     Node* value = resolve(block, location);</span>
<span class="line-added">+                     if (m_sinkCandidates.contains(value))</span>
<span class="line-added">+                         m_graph.m_varArgChildren.append(m_bottom);</span>
<span class="line-added">+                     else</span>
<span class="line-added">+                         m_graph.m_varArgChildren.append(value);</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+                 }</span>
<span class="line-added">+ </span>
<span class="line-added">+                 default:</span>
<span class="line-added">+                     DFG_CRASH(m_graph, node, &quot;Bad location kind&quot;);</span>
<span class="line-added">+                 }</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
<span class="line-added">+             node-&gt;children = AdjacencyList(</span>
<span class="line-added">+                 AdjacencyList::Variable,</span>
<span class="line-added">+                 firstChild, m_graph.m_varArgChildren.size() - firstChild);</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          case NewRegexp: {
              Vector&lt;PromotedHeapLocation&gt; locations = m_locationsForAllocation.get(escapee);
              ASSERT(locations.size() == 2);
  
              PromotedHeapLocation regExp(RegExpObjectRegExpPLoc, allocation.identifier());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2353,10 ***</span>
<span class="line-new-header">--- 2533,19 ---</span>
                  OpInfo(location.info()),
                  Edge(base, KnownCellUse),
                  value-&gt;defaultEdge());
          }
  
<span class="line-added">+         case InternalFieldObjectPLoc: {</span>
<span class="line-added">+             return m_graph.addNode(</span>
<span class="line-added">+                 PutInternalField,</span>
<span class="line-added">+                 origin.takeValidExit(canExit),</span>
<span class="line-added">+                 OpInfo(location.info()),</span>
<span class="line-added">+                 Edge(base, KnownCellUse),</span>
<span class="line-added">+                 value-&gt;defaultEdge());</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          case RegExpObjectLastIndexPLoc: {
              return m_graph.addNode(
                  SetRegExpObjectLastIndex,
                  origin.takeValidExit(canExit),
                  OpInfo(true),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2376,11 ***</span>
      {
          for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
              for (Node* node : *block) {
                  switch (node-&gt;op()) {
                  case FilterCallLinkStatus:
<span class="line-modified">!                 case FilterGetByIdStatus:</span>
                  case FilterPutByIdStatus:
                  case FilterInByIdStatus:
                      if (node-&gt;child1()-&gt;isPhantomAllocation())
                          node-&gt;removeWithoutChecks();
                      break;
<span class="line-new-header">--- 2565,11 ---</span>
      {
          for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
              for (Node* node : *block) {
                  switch (node-&gt;op()) {
                  case FilterCallLinkStatus:
<span class="line-modified">!                 case FilterGetByStatus:</span>
                  case FilterPutByIdStatus:
                  case FilterInByIdStatus:
                      if (node-&gt;child1()-&gt;isPhantomAllocation())
                          node-&gt;removeWithoutChecks();
                      break;
</pre>
<center><a href="DFGOSRExitCompilerCommon.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGOpInfo.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
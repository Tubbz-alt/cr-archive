<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderFragmentedFlow.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderFragmentContainer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderFragmentedFlow.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderFragmentedFlow.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  18  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  19  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
  20  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
  21  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  24  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
  25  * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
  26  * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  27  * SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;RenderFragmentedFlow.h&quot;
  32 
  33 #include &quot;HitTestRequest.h&quot;
  34 #include &quot;HitTestResult.h&quot;
  35 #include &quot;InlineElementBox.h&quot;
  36 #include &quot;Node.h&quot;
<span class="line-removed">  37 #include &quot;PODIntervalTree.h&quot;</span>
  38 #include &quot;RenderBoxFragmentInfo.h&quot;
  39 #include &quot;RenderFragmentContainer.h&quot;
  40 #include &quot;RenderInline.h&quot;
  41 #include &quot;RenderLayer.h&quot;
  42 #include &quot;RenderLayerCompositor.h&quot;
  43 #include &quot;RenderLayoutState.h&quot;
  44 #include &quot;RenderTableCell.h&quot;
  45 #include &quot;RenderTableSection.h&quot;
  46 #include &quot;RenderTheme.h&quot;
  47 #include &quot;RenderView.h&quot;
  48 #include &quot;TransformState.h&quot;
  49 #include &lt;wtf/IsoMallocInlines.h&gt;
  50 #include &lt;wtf/StackStats.h&gt;
  51 
  52 namespace WebCore {
  53 
  54 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderFragmentedFlow);
  55 
  56 RenderFragmentedFlow::RenderFragmentedFlow(Document&amp; document, RenderStyle&amp;&amp; style)
  57     : RenderBlockFlow(document, WTFMove(style))
</pre>
<hr />
<pre>
 202 
 203 bool RenderFragmentedFlow::shouldRepaint(const LayoutRect&amp; r) const
 204 {
 205     if (view().printing() || r.isEmpty())
 206         return false;
 207 
 208     return true;
 209 }
 210 
 211 void RenderFragmentedFlow::repaintRectangleInFragments(const LayoutRect&amp; repaintRect) const
 212 {
 213     if (!shouldRepaint(repaintRect) || !hasValidFragmentInfo())
 214         return;
 215 
 216     LayoutStateDisabler layoutStateDisabler(view().frameView().layoutContext()); // We can&#39;t use layout state to repaint, since the fragments are somewhere else.
 217 
 218     for (auto&amp; fragment : m_fragmentList)
 219         fragment-&gt;repaintFragmentedFlowContent(repaintRect);
 220 }
 221 

























 222 RenderFragmentContainer* RenderFragmentedFlow::fragmentAtBlockOffset(const RenderBox* clampBox, LayoutUnit offset, bool extendLastFragment) const
 223 {
 224     ASSERT(!m_fragmentsInvalidated);
 225 
 226     if (m_fragmentList.isEmpty())
 227         return nullptr;
 228 
 229     if (m_fragmentList.size() == 1 &amp;&amp; extendLastFragment)
 230         return m_fragmentList.first();
 231 




 232     if (offset &lt;= 0)
<span class="line-modified"> 233         return clampBox ? clampBox-&gt;clampToStartAndEndFragments(m_fragmentList.first()) : m_fragmentList.first();</span>
 234 
 235     FragmentSearchAdapter adapter(offset);
<span class="line-modified"> 236     m_fragmentIntervalTree.allOverlapsWithAdapter&lt;FragmentSearchAdapter&gt;(adapter);</span>


 237 
 238     // If no fragment was found, the offset is in the flow thread overflow.
 239     // The last fragment will contain the offset if extendLastFragment is set or if the last fragment is a set.
<span class="line-modified"> 240     if (!adapter.result() &amp;&amp; (extendLastFragment || m_fragmentList.last()-&gt;isRenderFragmentContainerSet()))</span>
<span class="line-modified"> 241         return clampBox ? clampBox-&gt;clampToStartAndEndFragments(m_fragmentList.last()) : m_fragmentList.last();</span>
 242 
<span class="line-modified"> 243     RenderFragmentContainer* fragment = adapter.result();</span>
<span class="line-removed"> 244     if (!clampBox)</span>
<span class="line-removed"> 245         return fragment;</span>
<span class="line-removed"> 246     return fragment ? clampBox-&gt;clampToStartAndEndFragments(fragment) : nullptr;</span>
 247 }
 248 
 249 LayoutPoint RenderFragmentedFlow::adjustedPositionRelativeToOffsetParent(const RenderBoxModelObject&amp; boxModelObject, const LayoutPoint&amp; startPoint) const
 250 {
 251     LayoutPoint referencePoint = startPoint;
 252 
 253     const RenderBlock* objContainingBlock = boxModelObject.containingBlock();
 254     // FIXME: This needs to be adapted for different writing modes inside the flow thread.
 255     RenderFragmentContainer* startFragment = fragmentAtBlockOffset(objContainingBlock, referencePoint.y());
 256     if (startFragment) {
 257         // Take into account the offset coordinates of the fragment.
 258         RenderBoxModelObject* startFragmentBox = startFragment;
 259         RenderBoxModelObject* currObject = startFragmentBox;
 260         RenderBoxModelObject* currOffsetParent;
 261         while ((currOffsetParent = currObject-&gt;offsetParent())) {
 262             referencePoint.move(currObject-&gt;offsetLeft(), currObject-&gt;offsetTop());
 263 
 264             // Since we&#39;re looking for the offset relative to the body, we must also
 265             // take into consideration the borders of the fragment&#39;s offsetParent.
 266             if (is&lt;RenderBox&gt;(*currOffsetParent) &amp;&amp; !currOffsetParent-&gt;isBody())
</pre>
<hr />
<pre>
 764 }
 765 
 766 void RenderFragmentedFlow::willBeDestroyed()
 767 {
 768     clearLinesToFragmentMap();
 769     RenderBlockFlow::willBeDestroyed();
 770 }
 771 
 772 void RenderFragmentedFlow::markFragmentsForOverflowLayoutIfNeeded()
 773 {
 774     if (!hasFragments())
 775         return;
 776 
 777     for (auto&amp; fragment : m_fragmentList)
 778         fragment-&gt;setNeedsSimplifiedNormalFlowLayout();
 779 }
 780 
 781 void RenderFragmentedFlow::updateFragmentsFragmentedFlowPortionRect()
 782 {
 783     LayoutUnit logicalHeight;
<span class="line-modified"> 784     // FIXME: Optimize not to clear the interval all the time. This implies manually managing the tree nodes lifecycle.</span>
 785     m_fragmentIntervalTree.clear();
 786     for (auto&amp; fragment : m_fragmentList) {
 787         LayoutUnit fragmentLogicalWidth = fragment-&gt;pageLogicalWidth();
 788         LayoutUnit fragmentLogicalHeight = std::min&lt;LayoutUnit&gt;(RenderFragmentedFlow::maxLogicalHeight() - logicalHeight, fragment-&gt;logicalHeightOfAllFragmentedFlowContent());
 789 
 790         LayoutRect fragmentRect(style().direction() == TextDirection::LTR ? 0_lu : logicalWidth() - fragmentLogicalWidth, logicalHeight, fragmentLogicalWidth, fragmentLogicalHeight);
 791 
 792         fragment-&gt;setFragmentedFlowPortionRect(isHorizontalWritingMode() ? fragmentRect : fragmentRect.transposedRect());
 793 
<span class="line-modified"> 794         m_fragmentIntervalTree.add(FragmentIntervalTree::createInterval(logicalHeight, logicalHeight + fragmentLogicalHeight, makeWeakPtr(fragment)));</span>
 795 
 796         logicalHeight += fragmentLogicalHeight;
 797     }
 798 }
 799 
 800 // Even if we require the break to occur at offsetBreakInFragmentedFlow, because fragments may have min/max-height values,
 801 // it is possible that the break will occur at a different offset than the original one required.
 802 // offsetBreakAdjustment measures the different between the requested break offset and the current break offset.
 803 bool RenderFragmentedFlow::addForcedFragmentBreak(const RenderBlock* block, LayoutUnit offsetBreakInFragmentedFlow, RenderBox*, bool, LayoutUnit* offsetBreakAdjustment)
 804 {
 805     // We need to update the fragments flow thread portion rect because we are going to process
 806     // a break on these fragments.
 807     updateFragmentsFragmentedFlowPortionRect();
 808 
 809     // Simulate a fragment break at offsetBreakInFragmentedFlow. If it points inside an auto logical height fragment,
 810     // then it determines the fragment computed auto height.
 811     RenderFragmentContainer* fragment = fragmentAtBlockOffset(block, offsetBreakInFragmentedFlow);
 812     if (!fragment)
 813         return false;
 814 
</pre>
<hr />
<pre>
 865         }
 866 
 867         if (containerBlock-&gt;style().writingMode() != currentBlock-&gt;style().writingMode()) {
 868             // We have to put the block rect in container coordinates
 869             // and we have to take into account both the container and current block flipping modes
 870             if (containerBlock-&gt;style().isFlippedBlocksWritingMode()) {
 871                 if (containerBlock-&gt;isHorizontalWritingMode())
 872                     blockRect.setY(currentBlock-&gt;height() - blockRect.maxY());
 873                 else
 874                     blockRect.setX(currentBlock-&gt;width() - blockRect.maxX());
 875             }
 876             currentBlock-&gt;flipForWritingMode(blockRect);
 877         }
 878         blockRect.moveBy(currentBlockLocation);
 879         currentBlock = containerBlock;
 880     }
 881 
 882     return currentBlock-&gt;isHorizontalWritingMode() ? blockRect.y() : blockRect.x();
 883 }
 884 
<span class="line-removed"> 885 void RenderFragmentedFlow::FragmentSearchAdapter::collectIfNeeded(const FragmentInterval&amp; interval)</span>
<span class="line-removed"> 886 {</span>
<span class="line-removed"> 887     if (m_result)</span>
<span class="line-removed"> 888         return;</span>
<span class="line-removed"> 889     if (interval.low() &lt;= m_offset &amp;&amp; interval.high() &gt; m_offset)</span>
<span class="line-removed"> 890         m_result = interval.data();</span>
<span class="line-removed"> 891 }</span>
<span class="line-removed"> 892 </span>
 893 void RenderFragmentedFlow::mapLocalToContainer(const RenderLayerModelObject* repaintContainer, TransformState&amp; transformState, MapCoordinatesFlags mode, bool* wasFixed) const
 894 {
 895     if (this == repaintContainer)
 896         return;
 897 
 898     if (RenderFragmentContainer* fragment = mapFromFlowToFragment(transformState)) {
 899         // FIXME: The cast below is probably not the best solution, we may need to find a better way.
 900         const RenderObject* fragmentObject = static_cast&lt;const RenderObject*&gt;(fragment);
 901 
 902         // If the repaint container is nullptr, we have to climb up to the RenderView, otherwise swap
 903         // it with the fragment&#39;s repaint container.
 904         repaintContainer = repaintContainer ? fragment-&gt;containerForRepaint() : nullptr;
 905 
 906         if (RenderFragmentedFlow* fragmentFragmentedFlow = fragment-&gt;enclosingFragmentedFlow()) {
 907             RenderFragmentContainer* startFragment = nullptr;
 908             RenderFragmentContainer* endFragment = nullptr;
 909             if (fragmentFragmentedFlow-&gt;getFragmentRangeForBox(fragment, startFragment, endFragment)) {
 910                 CurrentRenderFragmentContainerMaintainer fragmentMaintainer(*startFragment);
 911                 fragmentObject-&gt;mapLocalToContainer(repaintContainer, transformState, mode, wasFixed);
 912                 return;
</pre>
</td>
<td>
<hr />
<pre>
  17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  18  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  19  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
  20  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
  21  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  22  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  23  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  24  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
  25  * TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
  26  * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  27  * SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;RenderFragmentedFlow.h&quot;
  32 
  33 #include &quot;HitTestRequest.h&quot;
  34 #include &quot;HitTestResult.h&quot;
  35 #include &quot;InlineElementBox.h&quot;
  36 #include &quot;Node.h&quot;

  37 #include &quot;RenderBoxFragmentInfo.h&quot;
  38 #include &quot;RenderFragmentContainer.h&quot;
  39 #include &quot;RenderInline.h&quot;
  40 #include &quot;RenderLayer.h&quot;
  41 #include &quot;RenderLayerCompositor.h&quot;
  42 #include &quot;RenderLayoutState.h&quot;
  43 #include &quot;RenderTableCell.h&quot;
  44 #include &quot;RenderTableSection.h&quot;
  45 #include &quot;RenderTheme.h&quot;
  46 #include &quot;RenderView.h&quot;
  47 #include &quot;TransformState.h&quot;
  48 #include &lt;wtf/IsoMallocInlines.h&gt;
  49 #include &lt;wtf/StackStats.h&gt;
  50 
  51 namespace WebCore {
  52 
  53 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderFragmentedFlow);
  54 
  55 RenderFragmentedFlow::RenderFragmentedFlow(Document&amp; document, RenderStyle&amp;&amp; style)
  56     : RenderBlockFlow(document, WTFMove(style))
</pre>
<hr />
<pre>
 201 
 202 bool RenderFragmentedFlow::shouldRepaint(const LayoutRect&amp; r) const
 203 {
 204     if (view().printing() || r.isEmpty())
 205         return false;
 206 
 207     return true;
 208 }
 209 
 210 void RenderFragmentedFlow::repaintRectangleInFragments(const LayoutRect&amp; repaintRect) const
 211 {
 212     if (!shouldRepaint(repaintRect) || !hasValidFragmentInfo())
 213         return;
 214 
 215     LayoutStateDisabler layoutStateDisabler(view().frameView().layoutContext()); // We can&#39;t use layout state to repaint, since the fragments are somewhere else.
 216 
 217     for (auto&amp; fragment : m_fragmentList)
 218         fragment-&gt;repaintFragmentedFlowContent(repaintRect);
 219 }
 220 
<span class="line-added"> 221 class RenderFragmentedFlow::FragmentSearchAdapter {</span>
<span class="line-added"> 222 public:</span>
<span class="line-added"> 223     explicit FragmentSearchAdapter(LayoutUnit offset)</span>
<span class="line-added"> 224         : m_offset(offset)</span>
<span class="line-added"> 225     {</span>
<span class="line-added"> 226     }</span>
<span class="line-added"> 227 </span>
<span class="line-added"> 228     const LayoutUnit&amp; lowValue() const { return m_offset; }</span>
<span class="line-added"> 229     const LayoutUnit&amp; highValue() const { return m_offset; }</span>
<span class="line-added"> 230 </span>
<span class="line-added"> 231     void collectIfNeeded(const PODInterval&lt;LayoutUnit, WeakPtr&lt;RenderFragmentContainer&gt;&gt;&amp; interval)</span>
<span class="line-added"> 232     {</span>
<span class="line-added"> 233         if (m_result)</span>
<span class="line-added"> 234             return;</span>
<span class="line-added"> 235         if (interval.low() &lt;= m_offset &amp;&amp; interval.high() &gt; m_offset)</span>
<span class="line-added"> 236             m_result = interval.data();</span>
<span class="line-added"> 237     }</span>
<span class="line-added"> 238 </span>
<span class="line-added"> 239     RenderFragmentContainer* result() const { return m_result.get(); }</span>
<span class="line-added"> 240 </span>
<span class="line-added"> 241 private:</span>
<span class="line-added"> 242     LayoutUnit m_offset;</span>
<span class="line-added"> 243     WeakPtr&lt;RenderFragmentContainer&gt; m_result;</span>
<span class="line-added"> 244 };</span>
<span class="line-added"> 245 </span>
 246 RenderFragmentContainer* RenderFragmentedFlow::fragmentAtBlockOffset(const RenderBox* clampBox, LayoutUnit offset, bool extendLastFragment) const
 247 {
 248     ASSERT(!m_fragmentsInvalidated);
 249 
 250     if (m_fragmentList.isEmpty())
 251         return nullptr;
 252 
 253     if (m_fragmentList.size() == 1 &amp;&amp; extendLastFragment)
 254         return m_fragmentList.first();
 255 
<span class="line-added"> 256     auto clamp = [clampBox](RenderFragmentContainer* fragment)  {</span>
<span class="line-added"> 257         return clampBox ? clampBox-&gt;clampToStartAndEndFragments(fragment) : fragment;</span>
<span class="line-added"> 258     };</span>
<span class="line-added"> 259 </span>
 260     if (offset &lt;= 0)
<span class="line-modified"> 261         return clamp(m_fragmentList.first());</span>
 262 
 263     FragmentSearchAdapter adapter(offset);
<span class="line-modified"> 264     m_fragmentIntervalTree.allOverlapsWithAdapter(adapter);</span>
<span class="line-added"> 265     if (auto* fragment = adapter.result())</span>
<span class="line-added"> 266         return clamp(fragment);</span>
 267 
 268     // If no fragment was found, the offset is in the flow thread overflow.
 269     // The last fragment will contain the offset if extendLastFragment is set or if the last fragment is a set.
<span class="line-modified"> 270     if (extendLastFragment || m_fragmentList.last()-&gt;isRenderFragmentContainerSet())</span>
<span class="line-modified"> 271         return clamp(m_fragmentList.last());</span>
 272 
<span class="line-modified"> 273     return nullptr;</span>



 274 }
 275 
 276 LayoutPoint RenderFragmentedFlow::adjustedPositionRelativeToOffsetParent(const RenderBoxModelObject&amp; boxModelObject, const LayoutPoint&amp; startPoint) const
 277 {
 278     LayoutPoint referencePoint = startPoint;
 279 
 280     const RenderBlock* objContainingBlock = boxModelObject.containingBlock();
 281     // FIXME: This needs to be adapted for different writing modes inside the flow thread.
 282     RenderFragmentContainer* startFragment = fragmentAtBlockOffset(objContainingBlock, referencePoint.y());
 283     if (startFragment) {
 284         // Take into account the offset coordinates of the fragment.
 285         RenderBoxModelObject* startFragmentBox = startFragment;
 286         RenderBoxModelObject* currObject = startFragmentBox;
 287         RenderBoxModelObject* currOffsetParent;
 288         while ((currOffsetParent = currObject-&gt;offsetParent())) {
 289             referencePoint.move(currObject-&gt;offsetLeft(), currObject-&gt;offsetTop());
 290 
 291             // Since we&#39;re looking for the offset relative to the body, we must also
 292             // take into consideration the borders of the fragment&#39;s offsetParent.
 293             if (is&lt;RenderBox&gt;(*currOffsetParent) &amp;&amp; !currOffsetParent-&gt;isBody())
</pre>
<hr />
<pre>
 791 }
 792 
 793 void RenderFragmentedFlow::willBeDestroyed()
 794 {
 795     clearLinesToFragmentMap();
 796     RenderBlockFlow::willBeDestroyed();
 797 }
 798 
 799 void RenderFragmentedFlow::markFragmentsForOverflowLayoutIfNeeded()
 800 {
 801     if (!hasFragments())
 802         return;
 803 
 804     for (auto&amp; fragment : m_fragmentList)
 805         fragment-&gt;setNeedsSimplifiedNormalFlowLayout();
 806 }
 807 
 808 void RenderFragmentedFlow::updateFragmentsFragmentedFlowPortionRect()
 809 {
 810     LayoutUnit logicalHeight;
<span class="line-modified"> 811     // FIXME: Optimize not to clear the interval tree all the time. This would involve manually managing the tree nodes&#39; lifecycle.</span>
 812     m_fragmentIntervalTree.clear();
 813     for (auto&amp; fragment : m_fragmentList) {
 814         LayoutUnit fragmentLogicalWidth = fragment-&gt;pageLogicalWidth();
 815         LayoutUnit fragmentLogicalHeight = std::min&lt;LayoutUnit&gt;(RenderFragmentedFlow::maxLogicalHeight() - logicalHeight, fragment-&gt;logicalHeightOfAllFragmentedFlowContent());
 816 
 817         LayoutRect fragmentRect(style().direction() == TextDirection::LTR ? 0_lu : logicalWidth() - fragmentLogicalWidth, logicalHeight, fragmentLogicalWidth, fragmentLogicalHeight);
 818 
 819         fragment-&gt;setFragmentedFlowPortionRect(isHorizontalWritingMode() ? fragmentRect : fragmentRect.transposedRect());
 820 
<span class="line-modified"> 821         m_fragmentIntervalTree.add({ logicalHeight, logicalHeight + fragmentLogicalHeight, makeWeakPtr(fragment) });</span>
 822 
 823         logicalHeight += fragmentLogicalHeight;
 824     }
 825 }
 826 
 827 // Even if we require the break to occur at offsetBreakInFragmentedFlow, because fragments may have min/max-height values,
 828 // it is possible that the break will occur at a different offset than the original one required.
 829 // offsetBreakAdjustment measures the different between the requested break offset and the current break offset.
 830 bool RenderFragmentedFlow::addForcedFragmentBreak(const RenderBlock* block, LayoutUnit offsetBreakInFragmentedFlow, RenderBox*, bool, LayoutUnit* offsetBreakAdjustment)
 831 {
 832     // We need to update the fragments flow thread portion rect because we are going to process
 833     // a break on these fragments.
 834     updateFragmentsFragmentedFlowPortionRect();
 835 
 836     // Simulate a fragment break at offsetBreakInFragmentedFlow. If it points inside an auto logical height fragment,
 837     // then it determines the fragment computed auto height.
 838     RenderFragmentContainer* fragment = fragmentAtBlockOffset(block, offsetBreakInFragmentedFlow);
 839     if (!fragment)
 840         return false;
 841 
</pre>
<hr />
<pre>
 892         }
 893 
 894         if (containerBlock-&gt;style().writingMode() != currentBlock-&gt;style().writingMode()) {
 895             // We have to put the block rect in container coordinates
 896             // and we have to take into account both the container and current block flipping modes
 897             if (containerBlock-&gt;style().isFlippedBlocksWritingMode()) {
 898                 if (containerBlock-&gt;isHorizontalWritingMode())
 899                     blockRect.setY(currentBlock-&gt;height() - blockRect.maxY());
 900                 else
 901                     blockRect.setX(currentBlock-&gt;width() - blockRect.maxX());
 902             }
 903             currentBlock-&gt;flipForWritingMode(blockRect);
 904         }
 905         blockRect.moveBy(currentBlockLocation);
 906         currentBlock = containerBlock;
 907     }
 908 
 909     return currentBlock-&gt;isHorizontalWritingMode() ? blockRect.y() : blockRect.x();
 910 }
 911 








 912 void RenderFragmentedFlow::mapLocalToContainer(const RenderLayerModelObject* repaintContainer, TransformState&amp; transformState, MapCoordinatesFlags mode, bool* wasFixed) const
 913 {
 914     if (this == repaintContainer)
 915         return;
 916 
 917     if (RenderFragmentContainer* fragment = mapFromFlowToFragment(transformState)) {
 918         // FIXME: The cast below is probably not the best solution, we may need to find a better way.
 919         const RenderObject* fragmentObject = static_cast&lt;const RenderObject*&gt;(fragment);
 920 
 921         // If the repaint container is nullptr, we have to climb up to the RenderView, otherwise swap
 922         // it with the fragment&#39;s repaint container.
 923         repaintContainer = repaintContainer ? fragment-&gt;containerForRepaint() : nullptr;
 924 
 925         if (RenderFragmentedFlow* fragmentFragmentedFlow = fragment-&gt;enclosingFragmentedFlow()) {
 926             RenderFragmentContainer* startFragment = nullptr;
 927             RenderFragmentContainer* endFragment = nullptr;
 928             if (fragmentFragmentedFlow-&gt;getFragmentRangeForBox(fragment, startFragment, endFragment)) {
 929                 CurrentRenderFragmentContainerMaintainer fragmentMaintainer(*startFragment);
 930                 fragmentObject-&gt;mapLocalToContainer(repaintContainer, transformState, mode, wasFixed);
 931                 return;
</pre>
</td>
</tr>
</table>
<center><a href="RenderFragmentContainer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderFragmentedFlow.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/java/com/sun/javafx/webkit/drt/DumpRenderTree.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.javafx.webkit.drt;
 27 
 28 import com.sun.javafx.application.PlatformImpl;
 29 import com.sun.javafx.logging.PlatformLogger;
 30 import com.sun.javafx.logging.PlatformLogger.Level;
 31 import com.sun.webkit.*;
 32 import com.sun.webkit.graphics.*;
 33 
 34 import static com.sun.webkit.network.URLs.newURL;
 35 import java.io.BufferedReader;
 36 import java.io.BufferedWriter;
 37 import java.io.File;
 38 import java.io.InputStreamReader;
 39 import java.io.OutputStreamWriter;
 40 import java.io.PrintWriter;
 41 import java.io.UnsupportedEncodingException;
 42 import java.net.MalformedURLException;
 43 import java.net.URL;
 44 import java.nio.ByteBuffer;
 45 import java.util.Date;
 46 import java.util.Map;
 47 import java.util.List;
 48 import java.util.Timer;
 49 import java.util.TimerTask;
 50 import java.util.concurrent.CountDownLatch;
 51 import javafx.scene.web.WebEngine;
 52 
 53 public final class DumpRenderTree {
 54     private final static PlatformLogger log = PlatformLogger.getLogger(&quot;DumpRenderTree&quot;);
 55     private final static long PID = (new Date()).getTime() &amp; 0xFFFF;
 56     private final static String fileSep = System.getProperty(&quot;file.separator&quot;);
 57     private static boolean forceDumpAsText = false;
 58 
 59     final static PrintWriter out;
 60     static {
 61         try {
 62             out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(
 63                     System.out, &quot;UTF-8&quot;)), true);
 64         } catch (UnsupportedEncodingException ex) {
 65             throw new RuntimeException(ex);
 66         }
 67     }
 68     static volatile DumpRenderTree drt;
 69 
 70     private final WebPage webPage;
 71     private final UIClientImpl uiClient;
 72     private EventSender eventSender;
 73 
 74     private CountDownLatch latch;
 75     private Timer timer;
 76     private String testPath;
 77     private boolean loaded;
 78     private boolean waiting;
 79     private boolean complete;
 80 
 81     static class RenderUpdateHelper extends TimerTask {
 82         private WebPage webPage;
 83 
 84         public RenderUpdateHelper(WebPage webPage) {
 85             this.webPage = webPage;
 86         }
 87 
 88         @Override
 89         public void run() {
 90             Invoker.getInvoker().invokeOnEventThread(() -&gt; {
 91                     webPage.forceRepaint();
 92             });
 93         }
 94     };
 95 
 96     static class ThemeClientImplStub extends ThemeClient {
 97         @Override
 98         protected RenderTheme createRenderTheme() {
 99             return new RenderThemeStub();
100         }
101 
102         @Override
103         protected ScrollBarTheme createScrollBarTheme() {
104             return new ScrollBarThemeStub();
105         }
106     };
107 
108     static class RenderThemeStub extends RenderTheme {
109         @Override
110         protected Ref createWidget(long id, int widgetIndex, int state, int w, int h, int bgColor, ByteBuffer extParams) {
111             return null;
112         }
113 
114         @Override
115         public void drawWidget(WCGraphicsContext g, Ref widget, int x, int y) {
116         }
117 
118         @Override
119         protected int getRadioButtonSize() {
120             return 0;
121         }
122 
123         @Override
124         protected int getSelectionColor(int index) {
125             return 0;
126         }
127 
128         @Override
129         public WCSize getWidgetSize(Ref widget) {
130             return new WCSize(0, 0);
131         }
132     }
133 
134     static class ScrollBarThemeStub extends ScrollBarTheme {
135         @Override
136         protected Ref createWidget(long id, int w, int h, int orientation, int value, int visibleSize, int totalSize) {
137             return null;
138         }
139 
140         @Override
141         protected void getScrollBarPartRect(long id, int part, int rect[]) {}
142 
143         @Override
144         public void paint(WCGraphicsContext g, Ref sbRef, int x, int y, int pressedPart, int hoveredPart) {
145         }
146 
147         @Override
148         public WCSize getWidgetSize(Ref widget) {
149             return new WCSize(0, 0);
150         }
151     }
152 
153     // called on FX thread
154     private DumpRenderTree() {
155         uiClient = new UIClientImpl();
156         webPage = new WebPage(new WebPageClientImpl(), uiClient, null, null,
157                               new ThemeClientImplStub(), false);
158         uiClient.setWebPage(webPage);
159 
160         webPage.setBounds(0, 0, 800, 600);
161         webPage.setDeveloperExtrasEnabled(true);
162         webPage.addLoadListenerClient(new DRTLoadListener());
163 
164     }
165 
166     private String getTestPath(String testString) {
167         int t = testString.indexOf(&quot;&#39;&quot;);
168         String pixelsHash = &quot;&quot;;
169         if ((t &gt; 0) &amp;&amp; (t &lt; testString.length() - 1)) {
170             pixelsHash = testString.substring(t + 1);
171             testString = testString.substring(0, t);
172         }
173         this.testPath = testString;
174         initTest(testString, pixelsHash);
175         return testString;
176     }
177 
178     protected String getTestURL() {
179         return testPath;
180     }
181 
182 /*
183     private static boolean isDebug()
184     {
185         return log.isLoggable(Level.FINE);
186     }
187 */
188 
189     private static void mlog(String msg) {
190         if (log.isLoggable(Level.FINE)) {
191             log.fine(&quot;PID:&quot; + Long.toHexString(PID)
192                     + &quot; TID:&quot; + Thread.currentThread().getId()
193                         + &quot;(&quot; + Thread.currentThread().getName() + &quot;) &quot;
194                     + msg);
195         }
196     }
197 
198     private static void initPlatform() throws Exception {
199         // initialize default toolkit
200         final CountDownLatch latch = new CountDownLatch(1);
201         PlatformImpl.startup(() -&gt; {
202             // initialize Webkit classes
203             try {
204                 Class.forName(WebEngine.class.getName());
205                 Class.forName(WebPage.class.getName());
206             } catch (Exception e) {}
207 
208             System.loadLibrary(&quot;DumpRenderTreeJava&quot;);
209             initDRT();
210             new WebEngine();
211             drt = new DumpRenderTree();
212             PageCache.setCapacity(1);
213             latch.countDown();
214         });
215         // wait for libraries to load
216         latch.await();
217     }
218 
219     boolean complete() { return this.complete; }
220 
221     private void resetToConsistentStateBeforeTesting(final TestOptions options) {
222         // Reset native objects associated with WebPage
223         webPage.resetToConsistentStateBeforeTesting();
224 
225         // Assign default values for all supported TestOptions
226         webPage.overridePreference(&quot;experimental:CSSCustomPropertiesAndValuesEnabled&quot;, &quot;false&quot;);
227         webPage.overridePreference(&quot;enableColorFilter&quot;, &quot;false&quot;);
228         webPage.overridePreference(&quot;enableIntersectionObserver&quot;, &quot;false&quot;);
229         // Enable features based on TestOption
230         for (Map.Entry&lt;String, String&gt; option : options.getOptions().entrySet()) {
231             webPage.overridePreference(option.getKey(), option.getValue());
232         }
233     }
234 
235     private void reset(final TestOptions options) {
236         mlog(&quot;reset&quot;);
237         // newly create EventSender for each test
238         eventSender = new EventSender(webPage);
239         resetToConsistentStateBeforeTesting(options);
240         // Clear frame name
241         webPage.reset(webPage.getMainFrame());
242         // Reset zoom factors
243         webPage.setZoomFactor(1.0f, true);
244         webPage.setZoomFactor(1.0f, false);
245         // Reset DRT internal states
246         complete = false;
247         loaded = false;
248         waiting = false;
249     }
250 
251     // called on FX thread
252     private void run(final String testString, final CountDownLatch latch) {
253         this.latch = latch;
254         String file = getTestPath(testString);
255         mlog(&quot;{runTest: &quot; + file);
256         long mainFrame = webPage.getMainFrame();
257         try {
258             new URL(file);
259         } catch (MalformedURLException ex) {
260             file = &quot;file:///&quot; + file;
261         }
262         // parse test options from the html test header
263         final TestOptions options = new TestOptions(file);
264         reset(options);
265         webPage.open(mainFrame, file);
266         mlog(&quot;}runTest&quot;);
267     }
268 
269     private void runTest(final String testString) throws Exception {
270         final CountDownLatch l = new CountDownLatch(1);
271         Invoker.getInvoker().invokeOnEventThread(() -&gt; {
272             run(testString, l);
273         });
274 
275         timer = new Timer();
276         TimerTask task = new RenderUpdateHelper(webPage);
277         timer.schedule(task, 1000/60, 1000/60);
278         // wait until test is finished
279         l.await();
280         task.cancel();
281         timer.cancel();
282         final CountDownLatch latchForEvents = new CountDownLatch(1);
283         Invoker.getInvoker().invokeOnEventThread(() -&gt; {
284             mlog(&quot;dispose&quot;);
285             webPage.stop();
286             dispose();
287             latchForEvents.countDown();
288         });
289         latchForEvents.await();
290     }
291 
292     // called from native
293     private static void waitUntilDone() {
294         mlog(&quot;waitUntilDone&quot;);
295         drt.setWaiting(true); // TODO: handle timeout
296     }
297 
298     // called from native
299     private static void notifyDone() {
300         mlog(&quot;notifyDone&quot;);
301         drt.setWaiting(false);
302     }
303 
304     private static void overridePreference(String key, String value) {
305         mlog(&quot;overridePreference&quot;);
306         drt.webPage.overridePreference(key, value);
307     }
308 
309     private synchronized void setLoaded(boolean loaded) {
310         this.loaded = loaded;
311         done();
312     }
313 
314     private synchronized void setWaiting(boolean waiting) {
315         this.waiting = waiting;
316         done();
317     }
318 
319     private synchronized void dump(long frame) {
320         boolean dumpAsText = dumpAsText() || forceDumpAsText;
321         mlog(&quot;dumpAsText = &quot; + dumpAsText);
322         if (dumpAsText) {
323             String innerText = webPage.getInnerText(frame);
324             if (frame == webPage.getMainFrame()) {
325                 if (innerText != null) {
326                     // don&#39;t use println() here as it varies from platform
327                     // to platform, but DRT expects it always to be 0x0A
328                     out.print(innerText + &#39;\n&#39;);
329                 }
330             } else {
331                 out.printf(&quot;\n--------\nFrame: &#39;%s&#39;\n--------\n%s\n&quot;,
332                         webPage.getName(frame), innerText);
333             }
334             if (dumpChildFramesAsText()) {
335                 List&lt;Long&gt; children = webPage.getChildFrames(frame);
336                 if (children != null) {
337                     for (long child : children) {
338                         dump(child);
339                     }
340                 }
341             }
342             if (dumpBackForwardList() &amp;&amp; frame == webPage.getMainFrame()) {
343                 drt.dumpBfl();
344             }
345         } else {
346             String renderTree = webPage.getRenderTree(frame);
347             out.print(renderTree);
348         }
349     }
350 
351     private synchronized void done() {
352         if (waiting || !loaded || complete) {
353             return;
354         }
355         mlog(&quot;dump&quot;);
356         dump(webPage.getMainFrame());
357 
358         mlog(&quot;done&quot;);
359         out.print(&quot;#EOF&quot; + &#39;\n&#39;);
360         // TODO: dump pixels here
361         out.print(&quot;#EOF&quot; + &#39;\n&#39;);
362         out.flush();
363 
364         System.err.print(&quot;#EOF&quot; + &#39;\n&#39;);
365         System.err.flush();
366 
367         complete = true;
368         // notify main thread that test is finished
369         this.latch.countDown();
370     }
371 
372     private static native void initDRT();
373     private static native void initTest(String testPath, String pixelsHash);
374     private static native void didClearWindowObject(long pContext,
375             long pWindowObject, EventSender eventSender);
376     private static native void dispose();
377 
378     private static native boolean dumpAsText();
379     private static native boolean dumpChildFramesAsText();
380     private static native boolean dumpBackForwardList();
381     protected static native boolean shouldStayOnPageAfterHandlingBeforeUnload();
382     protected static native String[] openPanelFiles();
383 
384     private final class DRTLoadListener implements LoadListenerClient {
385         @Override
386         public void dispatchLoadEvent(long frame, int state,
387                                       String url, String contentType,
388                                       double progress, int errorCode)
389         {
390             mlog(&quot;dispatchLoadEvent: ENTER&quot;);
391             if (frame == webPage.getMainFrame()) {
392                 mlog(&quot;dispatchLoadEvent: STATE = &quot; + state);
393                 switch (state) {
394                     case PAGE_STARTED:
395                         mlog(&quot;PAGE_STARTED&quot;);
396                         setLoaded(false);
397                         break;
398                     case PAGE_FINISHED:
399                         mlog(&quot;PAGE_FINISHED&quot;);
400                         if (didFinishLoad()) {
401                             setLoaded(true);
402                         }
403                         break;
404                     case DOCUMENT_AVAILABLE:
405                         dumpUnloadListeners(webPage, frame);
406                         break;
407                     case LOAD_FAILED:
408                         mlog(&quot;LOAD_FAILED&quot;);
409                         // safety net: if load fails, e.g. command line
410                         // parameters were bad, let&#39;s not hang forever
411                         setLoaded(true);
412                         break;
413                 }
414             }
415             mlog(&quot;dispatchLoadEvent: EXIT&quot;);
416         }
417         @Override
418         public void dispatchResourceLoadEvent(long frame, int state,
419                                               String url, String contentType,
420                                               double progress, int errorCode)
421         {
422         }
423     }
424 
425 
426     public static void main(final String[] args) throws Exception {
427 /*
428         if ( isDebug() ) {
429             // &#39;log&#39; here is from java.util.logging
430             log.setLevel(Level.FINEST);
431             FileHandler handler = new FileHandler(&quot;drt.log&quot;, true);
432             handler.setFormatter(new Formatter() {
433                 @Override
434                 public String format(LogRecord record) {
435                     return formatMessage(record) + &quot;\n&quot;;
436                 }
437             });
438             log.addHandler(handler);
439         }
440 */
441         mlog(&quot;{main&quot;);
442         initPlatform();
443         assert drt != null;
444         for (String arg: args) {
445             if (&quot;--dump-as-text&quot;.equals(arg)) {
446                 forceDumpAsText = true;
447             } else if (&quot;-&quot;.equals(arg)) {
448                 // read from stdin
449                 BufferedReader in = new BufferedReader(
450                         new InputStreamReader(System.in));
451                 String testPath;
452                 while ((testPath = in.readLine()) != null) {
453                     drt.runTest(testPath);
454                 }
455                 in.close();
456             } else {
457                 drt.runTest(arg);
458             }
459         }
460         PlatformImpl.exit();
461         mlog(&quot;}main&quot;);
462         System.exit(0); // workaround to kill media threads
463     }
464 
465     // called from native
466     private static int getWorkerThreadCount() {
467         return WebPage.getWorkerThreadCount();
468     }
469 
470     // called from native
471     private static String resolveURL(String relativeURL) {
472         String testDir = new File(drt.testPath).getParentFile().getPath();
473         File f = new File(testDir, relativeURL);
474         String url = &quot;file:///&quot; + f.toString().replace(fileSep, &quot;/&quot;);
475         mlog(&quot;resolveURL: &quot; + url);
476         return url;
477     }
478 
479     // called from native
480     private static void loadURL(String url) {
481         drt.webPage.open(drt.webPage.getMainFrame(), url);
482     }
483 
484     // called from native
485     private static void goBackForward(int dist) {
486         // TODO: honor the dist
487         if (dist &gt; 0) {
488             drt.webPage.goForward();
489         } else {
490             drt.webPage.goBack();
491         }
492     }
493 
494     // called from native
495     private static int getBackForwardItemCount() {
496         return drt.getBackForwardList().size();
497     }
498 
499     // called from native
500     private static void clearBackForwardList() {
501         drt.getBackForwardList().clearBackForwardListForDRT();
502     }
503 
504     private static final String TEST_DIR_NAME = &quot;LayoutTests&quot;;
505     private static final int TEST_DIR_LEN = TEST_DIR_NAME.length();
506     private static final String CUR_ITEM_STR = &quot;curr-&gt;&quot;;
507     private static final int CUR_ITEM_STR_LEN = CUR_ITEM_STR.length();
508     private static final String INDENT = &quot;    &quot;;
509 
510     private BackForwardList bfl;
511     private BackForwardList getBackForwardList() {
512         if (bfl == null) {
513             bfl = webPage.createBackForwardList();
514         }
515         return bfl;
516     }
517 
518     private void dumpBfl() {
519         out.print(&quot;\n============== Back Forward List ==============\n&quot;);
520         getBackForwardList();
521         BackForwardList.Entry curItem = bfl.getCurrentEntry();
522         for (BackForwardList.Entry e: bfl.toArray()) {
523             dumpBflItem(e, 2, e == curItem);
524         }
525         out.print(&quot;===============================================\n&quot;);
526     }
527 
528     private void dumpBflItem(BackForwardList.Entry item, int indent, boolean isCurrent) {
529         StringBuilder str = new StringBuilder();
530         for (int i = indent; i &gt; 0; i--) str.append(INDENT);
531 
532         if (isCurrent) str.replace(0, CUR_ITEM_STR_LEN, CUR_ITEM_STR);
533 
534         String url = item.getURL().toString();
535         if (url.contains(&quot;file:/&quot;)) {
536             String subUrl = url.substring(url.indexOf(TEST_DIR_NAME) + TEST_DIR_LEN + 1);
537             str.append(&quot;(file test):&quot; + subUrl);
538         } else {
539             str.append(url);
540         }
541         if (item.getTarget() != null) {
542             str.append(&quot; (in frame \&quot;&quot; + item.getTarget() + &quot;\&quot;)&quot;);
543         }
544         if (item.isTargetItem()) {
545             str.append(&quot;  **nav target**\n&quot;);
546         } else {
547             str.append(&quot;\n&quot;);
548         }
549         out.print(str);
550         if (item.getChildren() != null)
551             for (BackForwardList.Entry child: item.getChildren())
552                 dumpBflItem(child, indent + 1, false);
553     }
554 
555     void dumpUnloadListeners(WebPage page, long frame) {
556         if (waiting == true &amp;&amp; dumpAsText()) {
557             String dump = getUnloadListenersDescription(page, frame);
558             if (dump != null) {
559                 out.print(dump + &#39;\n&#39;);
560             }
561         }
562     }
563 
564     private static String getUnloadListenersDescription(WebPage page, long frame) {
565         int count = page.getUnloadEventListenersCount(frame);
566         if (count &gt; 0) {
567             return getFrameDescription(page, frame) +
568                    &quot; - has &quot; + count + &quot; onunload handler(s)&quot;;
569         }
570         return null;
571     }
572 
573     private static String getFrameDescription(WebPage page, long frame) {
574         String name = page.getName(frame);
575         if (frame == page.getMainFrame()) {
576             return name == null ? &quot;main frame&quot; : &quot;main frame &quot; + name;
577         }
578         return name == null ? &quot;frame (anonymous)&quot; : &quot;frame &quot; + name;
579     }
580 
581     private native static boolean didFinishLoad();
582 
583     private final class WebPageClientImpl implements WebPageClient&lt;Void&gt; {
584 
585         @Override
586         public void setCursor(long cursorID) {
587         }
588 
589         @Override
590         public void setFocus(boolean focus) {
591         }
592 
593         @Override
594         public void transferFocus(boolean forward) {
595         }
596 
597         @Override
598         public void setTooltip(String tooltip) {
599         }
600 
601         @Override
602         public WCRectangle getScreenBounds(boolean available) {
603             return new WCRectangle(0, 0, 800, 600);
604         }
605 
606         @Override
607         public int getScreenDepth() {
608             return 24;
609         }
610 
611         @Override
612         public Void getContainer() {
613             return null;
614         }
615 
616         @Override
617         public WCPoint screenToWindow(WCPoint ptScreen) {
618             return ptScreen;
619         }
620 
621         @Override
622         public WCPoint windowToScreen(WCPoint ptWindow) {
623             return ptWindow;
624         }
625 
626         @Override
627         public WCPageBackBuffer createBackBuffer() {
628             throw new UnsupportedOperationException();
629         }
630 
631         @Override
632         public boolean isBackBufferSupported() {
633             return false;
634         }
635 
636         @Override
637         public void addMessageToConsole(String message, int lineNumber,
638                                         String sourceId)
639         {
640             if (complete) {
641                 return;
642             }
643             if (!message.isEmpty()) {
644                 int pos = message.indexOf(&quot;file://&quot;);
645                 if (pos != -1) {
646                     String s1 = message.substring(0, pos);
647                     String s2 = message.substring(pos);
648                     try {
649                         // Extract the last path component aka file name
650                         s2 = new File(newURL(s2).getPath()).getName();
651                     } catch (MalformedURLException ignore) {}
652                     message = s1 + s2;
653                 }
654             }
655             if (lineNumber == 0) {
656                 out.printf(&quot;CONSOLE MESSAGE: %s\n&quot;, message);
657             } else {
658                 out.printf(&quot;CONSOLE MESSAGE: line %d: %s\n&quot;,
659                            lineNumber, message);
660             }
661         }
662 
663         @Override
664         public void didClearWindowObject(long context, long windowObject) {
665             mlog(&quot;didClearWindowObject&quot;);
666             if (eventSender != null) {
667                 DumpRenderTree.didClearWindowObject(context, windowObject,
668                                                     eventSender);
669             }
670         }
671     }
672 }
    </pre>
  </body>
</html>
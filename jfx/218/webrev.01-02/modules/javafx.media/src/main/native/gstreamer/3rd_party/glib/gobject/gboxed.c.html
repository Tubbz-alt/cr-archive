<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gboxed.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /* GObject - GLib Type, Object, Parameter and Signal Library
  2  * Copyright (C) 2000-2001 Red Hat, Inc.
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Lesser General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2.1 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Lesser General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Lesser General
 15  * Public License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
 16  */
 17 
 18 #include &quot;config.h&quot;
 19 
 20 #include &lt;string.h&gt;
 21 
 22 /* for GValueArray */
 23 #define GLIB_DISABLE_DEPRECATION_WARNINGS
 24 
 25 #include &quot;gboxed.h&quot;
 26 #include &quot;gclosure.h&quot;
 27 #include &quot;gtype-private.h&quot;
 28 #include &quot;gvalue.h&quot;
 29 #include &quot;gvaluearray.h&quot;
 30 #include &quot;gvaluecollector.h&quot;
 31 
 32 
 33 /**
 34  * SECTION:gboxed
 35  * @short_description: A mechanism to wrap opaque C structures registered
 36  *     by the type system
 37  * @see_also: #GParamSpecBoxed, g_param_spec_boxed()
 38  * @title: Boxed Types
 39  *
 40  * #GBoxed is a generic wrapper mechanism for arbitrary C structures. The only
 41  * thing the type system needs to know about the structures is how to copy them
 42  * (a #GBoxedCopyFunc) and how to free them (a #GBoxedFreeFunc) - beyond that
 43  * they are treated as opaque chunks of memory.
 44  *
 45  * Boxed types are useful for simple value-holder structures like rectangles or
 46  * points. They can also be used for wrapping structures defined in non-#GObject
 47  * based libraries. They allow arbitrary structures to be handled in a uniform
 48  * way, allowing uniform copying (or referencing) and freeing (or unreferencing)
 49  * of them, and uniform representation of the type of the contained structure.
 50  * In turn, this allows any type which can be boxed to be set as the data in a
 51  * #GValue, which allows for polymorphic handling of a much wider range of data
 52  * types, and hence usage of such types as #GObject property values.
 53  *
 54  * #GBoxed is designed so that reference counted types can be boxed. Use the
 55  * type&#39;s &#39;ref&#39; function as the #GBoxedCopyFunc, and its &#39;unref&#39; function as the
 56  * #GBoxedFreeFunc. For example, for #GBytes, the #GBoxedCopyFunc is
 57  * g_bytes_ref(), and the #GBoxedFreeFunc is g_bytes_unref().
 58  */
 59 
 60 static inline void              /* keep this function in sync with gvalue.c */
 61 value_meminit (GValue *value,
 62          GType   value_type)
 63 {
 64   value-&gt;g_type = value_type;
 65   memset (value-&gt;data, 0, sizeof (value-&gt;data));
 66 }
 67 
 68 static GValue *
 69 value_copy (GValue *src_value)
 70 {
 71   GValue *dest_value = g_new0 (GValue, 1);
 72 
 73   if (G_VALUE_TYPE (src_value))
 74     {
 75       g_value_init (dest_value, G_VALUE_TYPE (src_value));
 76       g_value_copy (src_value, dest_value);
 77     }
 78   return dest_value;
 79 }
 80 
 81 static void
 82 value_free (GValue *value)
 83 {
 84   if (G_VALUE_TYPE (value))
 85     g_value_unset (value);
 86   g_free (value);
 87 }
 88 
 89 static GPollFD *
 90 pollfd_copy (GPollFD *src)
 91 {
 92   GPollFD *dest = g_new0 (GPollFD, 1);
 93   /* just a couple of integers */
 94   memcpy (dest, src, sizeof (GPollFD));
 95   return dest;
 96 }
 97 
 98 void
 99 _g_boxed_type_init (void)
100 {
101   const GTypeInfo info = {
102     0,                          /* class_size */
103     NULL,                       /* base_init */
104     NULL,                       /* base_destroy */
105     NULL,                       /* class_init */
106     NULL,                       /* class_destroy */
107     NULL,                       /* class_data */
108     0,                          /* instance_size */
109     0,                          /* n_preallocs */
110     NULL,                       /* instance_init */
111     NULL,                       /* value_table */
112   };
113   const GTypeFundamentalInfo finfo = { G_TYPE_FLAG_DERIVABLE, };
114   GType type G_GNUC_UNUSED  /* when compiling with G_DISABLE_ASSERT */;
115 
116   /* G_TYPE_BOXED
117    */
118   type = g_type_register_fundamental (G_TYPE_BOXED, g_intern_static_string (&quot;GBoxed&quot;), &amp;info, &amp;finfo,
119               G_TYPE_FLAG_ABSTRACT | G_TYPE_FLAG_VALUE_ABSTRACT);
120   g_assert (type == G_TYPE_BOXED);
121 }
122 
123 static GString *
124 gstring_copy (GString *src_gstring)
125 {
126   return g_string_new_len (src_gstring-&gt;str, src_gstring-&gt;len);
127 }
128 
129 static void
130 gstring_free (GString *gstring)
131 {
132   g_string_free (gstring, TRUE);
133 }
134 
135 G_DEFINE_BOXED_TYPE (GClosure, g_closure, g_closure_ref, g_closure_unref)
136 G_DEFINE_BOXED_TYPE (GValue, g_value, value_copy, value_free)
137 G_DEFINE_BOXED_TYPE (GValueArray, g_value_array, g_value_array_copy, g_value_array_free)
138 G_DEFINE_BOXED_TYPE (GDate, g_date, g_date_copy, g_date_free)
139 /* the naming is a bit odd, but GString is obviously not G_TYPE_STRING */
140 G_DEFINE_BOXED_TYPE (GString, g_gstring, gstring_copy, gstring_free)
141 G_DEFINE_BOXED_TYPE (GHashTable, g_hash_table, g_hash_table_ref, g_hash_table_unref)
142 G_DEFINE_BOXED_TYPE (GArray, g_array, g_array_ref, g_array_unref)
143 G_DEFINE_BOXED_TYPE (GPtrArray, g_ptr_array,g_ptr_array_ref, g_ptr_array_unref)
144 G_DEFINE_BOXED_TYPE (GByteArray, g_byte_array, g_byte_array_ref, g_byte_array_unref)
145 G_DEFINE_BOXED_TYPE (GBytes, g_bytes, g_bytes_ref, g_bytes_unref)
146 
147 #ifndef GSTREAMER_LITE
148 G_DEFINE_BOXED_TYPE (GRegex, g_regex, g_regex_ref, g_regex_unref)
149 G_DEFINE_BOXED_TYPE (GMatchInfo, g_match_info, g_match_info_ref, g_match_info_unref)
150 #endif // GSTREAMER_LITE
151 
152 #define g_variant_type_get_type g_variant_type_get_gtype
153 G_DEFINE_BOXED_TYPE (GVariantType, g_variant_type, g_variant_type_copy, g_variant_type_free)
154 #undef g_variant_type_get_type
155 
156 G_DEFINE_BOXED_TYPE (GVariantBuilder, g_variant_builder, g_variant_builder_ref, g_variant_builder_unref)
157 G_DEFINE_BOXED_TYPE (GVariantDict, g_variant_dict, g_variant_dict_ref, g_variant_dict_unref)
158 
159 G_DEFINE_BOXED_TYPE (GError, g_error, g_error_copy, g_error_free)
160 
161 G_DEFINE_BOXED_TYPE (GDateTime, g_date_time, g_date_time_ref, g_date_time_unref)
162 G_DEFINE_BOXED_TYPE (GTimeZone, g_time_zone, g_time_zone_ref, g_time_zone_unref)
163 G_DEFINE_BOXED_TYPE (GKeyFile, g_key_file, g_key_file_ref, g_key_file_unref)
164 G_DEFINE_BOXED_TYPE (GMappedFile, g_mapped_file, g_mapped_file_ref, g_mapped_file_unref)
165 
166 G_DEFINE_BOXED_TYPE (GMainLoop, g_main_loop, g_main_loop_ref, g_main_loop_unref)
167 G_DEFINE_BOXED_TYPE (GMainContext, g_main_context, g_main_context_ref, g_main_context_unref)
168 G_DEFINE_BOXED_TYPE (GSource, g_source, g_source_ref, g_source_unref)
169 G_DEFINE_BOXED_TYPE (GPollFD, g_pollfd, pollfd_copy, g_free)
170 G_DEFINE_BOXED_TYPE (GMarkupParseContext, g_markup_parse_context, g_markup_parse_context_ref, g_markup_parse_context_unref)
171 
172 G_DEFINE_BOXED_TYPE (GThread, g_thread, g_thread_ref, g_thread_unref)
173 G_DEFINE_BOXED_TYPE (GChecksum, g_checksum, g_checksum_copy, g_checksum_free)
174 
175 G_DEFINE_BOXED_TYPE (GOptionGroup, g_option_group, g_option_group_ref, g_option_group_unref)
176 
177 /* This one can&#39;t use G_DEFINE_BOXED_TYPE (GStrv, g_strv, g_strdupv, g_strfreev) */
178 GType
179 g_strv_get_type (void)
180 {
181   static volatile gsize g_define_type_id__volatile = 0;
182 
183   if (g_once_init_enter (&amp;g_define_type_id__volatile))
184     {
185       GType g_define_type_id =
186         g_boxed_type_register_static (g_intern_static_string (&quot;GStrv&quot;),
187                                       (GBoxedCopyFunc) g_strdupv,
188                                       (GBoxedFreeFunc) g_strfreev);
189 
190       g_once_init_leave (&amp;g_define_type_id__volatile, g_define_type_id);
191     }
192 
193   return g_define_type_id__volatile;
194 }
195 
196 GType
197 g_variant_get_gtype (void)
198 {
199   return G_TYPE_VARIANT;
200 }
201 
202 static void
203 boxed_proxy_value_init (GValue *value)
204 {
205   value-&gt;data[0].v_pointer = NULL;
206 }
207 
208 static void
209 boxed_proxy_value_free (GValue *value)
210 {
211   if (value-&gt;data[0].v_pointer &amp;&amp; !(value-&gt;data[1].v_uint &amp; G_VALUE_NOCOPY_CONTENTS))
212     _g_type_boxed_free (G_VALUE_TYPE (value), value-&gt;data[0].v_pointer);
213 }
214 
215 static void
216 boxed_proxy_value_copy (const GValue *src_value,
217       GValue       *dest_value)
218 {
219   if (src_value-&gt;data[0].v_pointer)
220     dest_value-&gt;data[0].v_pointer = _g_type_boxed_copy (G_VALUE_TYPE (src_value), src_value-&gt;data[0].v_pointer);
221   else
222     dest_value-&gt;data[0].v_pointer = src_value-&gt;data[0].v_pointer;
223 }
224 
225 static gpointer
226 boxed_proxy_value_peek_pointer (const GValue *value)
227 {
228   return value-&gt;data[0].v_pointer;
229 }
230 
231 static gchar*
232 boxed_proxy_collect_value (GValue      *value,
233          guint        n_collect_values,
234          GTypeCValue *collect_values,
235          guint        collect_flags)
236 {
237   if (!collect_values[0].v_pointer)
238     value-&gt;data[0].v_pointer = NULL;
239   else
240     {
241       if (collect_flags &amp; G_VALUE_NOCOPY_CONTENTS)
242   {
243     value-&gt;data[0].v_pointer = collect_values[0].v_pointer;
244     value-&gt;data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;
245   }
246       else
247   value-&gt;data[0].v_pointer = _g_type_boxed_copy (G_VALUE_TYPE (value), collect_values[0].v_pointer);
248     }
249 
250   return NULL;
251 }
252 
253 static gchar*
254 boxed_proxy_lcopy_value (const GValue *value,
255        guint         n_collect_values,
256        GTypeCValue  *collect_values,
257        guint         collect_flags)
258 {
259   gpointer *boxed_p = collect_values[0].v_pointer;
260 
261   if (!boxed_p)
262     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
263 
264   if (!value-&gt;data[0].v_pointer)
265     *boxed_p = NULL;
266   else if (collect_flags &amp; G_VALUE_NOCOPY_CONTENTS)
267     *boxed_p = value-&gt;data[0].v_pointer;
268   else
269     *boxed_p = _g_type_boxed_copy (G_VALUE_TYPE (value), value-&gt;data[0].v_pointer);
270 
271   return NULL;
272 }
273 
274 /**
275  * g_boxed_type_register_static:
276  * @name: Name of the new boxed type.
277  * @boxed_copy: Boxed structure copy function.
278  * @boxed_free: Boxed structure free function.
279  *
280  * This function creates a new %G_TYPE_BOXED derived type id for a new
281  * boxed type with name @name. Boxed type handling functions have to be
282  * provided to copy and free opaque boxed structures of this type.
283  *
284  * Returns: New %G_TYPE_BOXED derived type id for @name.
285  */
286 GType
287 g_boxed_type_register_static (const gchar   *name,
288             GBoxedCopyFunc boxed_copy,
289             GBoxedFreeFunc boxed_free)
290 {
291   static const GTypeValueTable vtable = {
292     boxed_proxy_value_init,
293     boxed_proxy_value_free,
294     boxed_proxy_value_copy,
295     boxed_proxy_value_peek_pointer,
296     &quot;p&quot;,
297     boxed_proxy_collect_value,
298     &quot;p&quot;,
299     boxed_proxy_lcopy_value,
300   };
301   GTypeInfo type_info = {
302     0,      /* class_size */
303     NULL,   /* base_init */
304     NULL,   /* base_finalize */
305     NULL,   /* class_init */
306     NULL,   /* class_finalize */
307     NULL,   /* class_data */
308     0,      /* instance_size */
309     0,      /* n_preallocs */
310     NULL,   /* instance_init */
311     &amp;vtable,    /* value_table */
312   };
313   GType type;
314 
315   g_return_val_if_fail (name != NULL, 0);
316   g_return_val_if_fail (boxed_copy != NULL, 0);
317   g_return_val_if_fail (boxed_free != NULL, 0);
318   g_return_val_if_fail (g_type_from_name (name) == 0, 0);
319 
320   type = g_type_register_static (G_TYPE_BOXED, name, &amp;type_info, 0);
321 
322   /* install proxy functions upon successful registration */
323   if (type)
324     _g_type_boxed_init (type, boxed_copy, boxed_free);
325 
326   return type;
327 }
328 
329 /**
330  * g_boxed_copy:
331  * @boxed_type: The type of @src_boxed.
332  * @src_boxed: (not nullable): The boxed structure to be copied.
333  *
334  * Provide a copy of a boxed structure @src_boxed which is of type @boxed_type.
335  *
336  * Returns: (transfer full) (not nullable): The newly created copy of the boxed
337  *    structure.
338  */
339 gpointer
340 g_boxed_copy (GType         boxed_type,
341         gconstpointer src_boxed)
342 {
343   GTypeValueTable *value_table;
344   gpointer dest_boxed;
345 
346   g_return_val_if_fail (G_TYPE_IS_BOXED (boxed_type), NULL);
347   g_return_val_if_fail (G_TYPE_IS_ABSTRACT (boxed_type) == FALSE, NULL);
348   g_return_val_if_fail (src_boxed != NULL, NULL);
349 
350   value_table = g_type_value_table_peek (boxed_type);
351   if (!value_table)
352     g_return_val_if_fail (G_TYPE_IS_VALUE_TYPE (boxed_type), NULL);
353 
354   /* check if our proxying implementation is used, we can short-cut here */
355   if (value_table-&gt;value_copy == boxed_proxy_value_copy)
356     dest_boxed = _g_type_boxed_copy (boxed_type, (gpointer) src_boxed);
357   else
358     {
359       GValue src_value, dest_value;
360 
361       /* we heavily rely on third-party boxed type value vtable
362        * implementations to follow normal boxed value storage
363        * (data[0].v_pointer is the boxed struct, and
364        * data[1].v_uint holds the G_VALUE_NOCOPY_CONTENTS flag,
365        * rest zero).
366        * but then, we can expect that since we laid out the
367        * g_boxed_*() API.
368        * data[1].v_uint&amp;G_VALUE_NOCOPY_CONTENTS shouldn&#39;t be set
369        * after a copy.
370        */
371       /* equiv. to g_value_set_static_boxed() */
372       value_meminit (&amp;src_value, boxed_type);
373       src_value.data[0].v_pointer = (gpointer) src_boxed;
374       src_value.data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;
375 
376       /* call third-party code copy function, fingers-crossed */
377       value_meminit (&amp;dest_value, boxed_type);
378       value_table-&gt;value_copy (&amp;src_value, &amp;dest_value);
379 
380       /* double check and grouse if things went wrong */
381       if (dest_value.data[1].v_ulong)
382   g_warning (&quot;the copy_value() implementation of type &#39;%s&#39; seems to make use of reserved GValue fields&quot;,
383        g_type_name (boxed_type));
384 
385       dest_boxed = dest_value.data[0].v_pointer;
386     }
387 
388   return dest_boxed;
389 }
390 
391 /**
392  * g_boxed_free:
393  * @boxed_type: The type of @boxed.
394  * @boxed: (not nullable): The boxed structure to be freed.
395  *
396  * Free the boxed structure @boxed which is of type @boxed_type.
397  */
398 void
399 g_boxed_free (GType    boxed_type,
400         gpointer boxed)
401 {
402   GTypeValueTable *value_table;
403 
404   g_return_if_fail (G_TYPE_IS_BOXED (boxed_type));
405   g_return_if_fail (G_TYPE_IS_ABSTRACT (boxed_type) == FALSE);
406   g_return_if_fail (boxed != NULL);
407 
408   value_table = g_type_value_table_peek (boxed_type);
409   if (!value_table)
410     g_return_if_fail (G_TYPE_IS_VALUE_TYPE (boxed_type));
411 
412   /* check if our proxying implementation is used, we can short-cut here */
413   if (value_table-&gt;value_free == boxed_proxy_value_free)
414     _g_type_boxed_free (boxed_type, boxed);
415   else
416     {
417       GValue value;
418 
419       /* see g_boxed_copy() on why we think we can do this */
420       value_meminit (&amp;value, boxed_type);
421       value.data[0].v_pointer = boxed;
422       value_table-&gt;value_free (&amp;value);
423     }
424 }
425 
426 /**
427  * g_value_get_boxed:
428  * @value: a valid #GValue of %G_TYPE_BOXED derived type
429  *
430  * Get the contents of a %G_TYPE_BOXED derived #GValue.
431  *
432  * Returns: (transfer none): boxed contents of @value
433  */
434 gpointer
435 g_value_get_boxed (const GValue *value)
436 {
437   g_return_val_if_fail (G_VALUE_HOLDS_BOXED (value), NULL);
438   g_return_val_if_fail (G_TYPE_IS_VALUE (G_VALUE_TYPE (value)), NULL);
439 
440   return value-&gt;data[0].v_pointer;
441 }
442 
443 /**
444  * g_value_dup_boxed: (skip)
445  * @value: a valid #GValue of %G_TYPE_BOXED derived type
446  *
447  * Get the contents of a %G_TYPE_BOXED derived #GValue.  Upon getting,
448  * the boxed value is duplicated and needs to be later freed with
449  * g_boxed_free(), e.g. like: g_boxed_free (G_VALUE_TYPE (@value),
450  * return_value);
451  *
452  * Returns: boxed contents of @value
453  */
454 gpointer
455 g_value_dup_boxed (const GValue *value)
456 {
457   g_return_val_if_fail (G_VALUE_HOLDS_BOXED (value), NULL);
458   g_return_val_if_fail (G_TYPE_IS_VALUE (G_VALUE_TYPE (value)), NULL);
459 
460   return value-&gt;data[0].v_pointer ? g_boxed_copy (G_VALUE_TYPE (value), value-&gt;data[0].v_pointer) : NULL;
461 }
462 
463 static inline void
464 value_set_boxed_internal (GValue       *value,
465         gconstpointer boxed,
466         gboolean      need_copy,
467         gboolean      need_free)
468 {
469   if (!boxed)
470     {
471       /* just resetting to NULL might not be desired, need to
472        * have value reinitialized also (for values defaulting
473        * to other default value states than a NULL data pointer),
474        * g_value_reset() will handle this
475        */
476       g_value_reset (value);
477       return;
478     }
479 
480   if (value-&gt;data[0].v_pointer &amp;&amp; !(value-&gt;data[1].v_uint &amp; G_VALUE_NOCOPY_CONTENTS))
481     g_boxed_free (G_VALUE_TYPE (value), value-&gt;data[0].v_pointer);
482   value-&gt;data[1].v_uint = need_free ? 0 : G_VALUE_NOCOPY_CONTENTS;
483   value-&gt;data[0].v_pointer = need_copy ? g_boxed_copy (G_VALUE_TYPE (value), boxed) : (gpointer) boxed;
484 }
485 
486 /**
487  * g_value_set_boxed:
488  * @value: a valid #GValue of %G_TYPE_BOXED derived type
489  * @v_boxed: (nullable): boxed value to be set
490  *
491  * Set the contents of a %G_TYPE_BOXED derived #GValue to @v_boxed.
492  */
493 void
494 g_value_set_boxed (GValue       *value,
495        gconstpointer boxed)
496 {
497   g_return_if_fail (G_VALUE_HOLDS_BOXED (value));
498   g_return_if_fail (G_TYPE_IS_VALUE (G_VALUE_TYPE (value)));
499 
500   value_set_boxed_internal (value, boxed, TRUE, TRUE);
501 }
502 
503 /**
504  * g_value_set_static_boxed:
505  * @value: a valid #GValue of %G_TYPE_BOXED derived type
506  * @v_boxed: (nullable): static boxed value to be set
507  *
508  * Set the contents of a %G_TYPE_BOXED derived #GValue to @v_boxed.
509  * The boxed value is assumed to be static, and is thus not duplicated
510  * when setting the #GValue.
511  */
512 void
513 g_value_set_static_boxed (GValue       *value,
514         gconstpointer boxed)
515 {
516   g_return_if_fail (G_VALUE_HOLDS_BOXED (value));
517   g_return_if_fail (G_TYPE_IS_VALUE (G_VALUE_TYPE (value)));
518 
519   value_set_boxed_internal (value, boxed, FALSE, FALSE);
520 }
521 
522 /**
523  * g_value_set_boxed_take_ownership:
524  * @value: a valid #GValue of %G_TYPE_BOXED derived type
525  * @v_boxed: (nullable): duplicated unowned boxed value to be set
526  *
527  * This is an internal function introduced mainly for C marshallers.
528  *
529  * Deprecated: 2.4: Use g_value_take_boxed() instead.
530  */
531 void
532 g_value_set_boxed_take_ownership (GValue       *value,
533           gconstpointer boxed)
534 {
535   g_value_take_boxed (value, boxed);
536 }
537 
538 /**
539  * g_value_take_boxed:
540  * @value: a valid #GValue of %G_TYPE_BOXED derived type
541  * @v_boxed: (nullable): duplicated unowned boxed value to be set
542  *
543  * Sets the contents of a %G_TYPE_BOXED derived #GValue to @v_boxed
544  * and takes over the ownership of the caller&#39;s reference to @v_boxed;
545  * the caller doesn&#39;t have to unref it any more.
546  *
547  * Since: 2.4
548  */
549 void
550 g_value_take_boxed (GValue       *value,
551         gconstpointer boxed)
552 {
553   g_return_if_fail (G_VALUE_HOLDS_BOXED (value));
554   g_return_if_fail (G_TYPE_IS_VALUE (G_VALUE_TYPE (value)));
555 
556   value_set_boxed_internal (value, boxed, FALSE, TRUE);
557 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/libffi/src/x86/ffi.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /* -----------------------------------------------------------------------
<a name="1" id="anc1"></a><span class="line-modified">  2    ffi.c - Copyright (c) 2017  Anthony Green</span>
<span class="line-added">  3            Copyright (c) 1996, 1998, 1999, 2001, 2007, 2008  Red Hat, Inc.</span>
  4            Copyright (c) 2002  Ranjit Mathew
  5            Copyright (c) 2002  Bo Thorsen
  6            Copyright (c) 2002  Roger Sayle
  7            Copyright (C) 2008, 2010  Free Software Foundation, Inc.
  8 
  9    x86 Foreign Function Interface
 10 
 11    Permission is hereby granted, free of charge, to any person obtaining
 12    a copy of this software and associated documentation files (the
 13    ``Software&#39;&#39;), to deal in the Software without restriction, including
 14    without limitation the rights to use, copy, modify, merge, publish,
 15    distribute, sublicense, and/or sell copies of the Software, and to
 16    permit persons to whom the Software is furnished to do so, subject to
 17    the following conditions:
 18 
 19    The above copyright notice and this permission notice shall be included
 20    in all copies or substantial portions of the Software.
 21 
 22    THE SOFTWARE IS PROVIDED ``AS IS&#39;&#39;, WITHOUT WARRANTY OF ANY KIND,
 23    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 24    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 25    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 26    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 27    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 28    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 29    DEALINGS IN THE SOFTWARE.
 30    ----------------------------------------------------------------------- */
 31 
<a name="2" id="anc2"></a><span class="line-modified"> 32 #if defined(__i386__) || defined(_M_IX86)</span>





 33 #include &lt;ffi.h&gt;
 34 #include &lt;ffi_common.h&gt;
<a name="3" id="anc3"></a><span class="line-modified"> 35 #include &lt;stdint.h&gt;</span>
 36 #include &lt;stdlib.h&gt;
<a name="4" id="anc4"></a><span class="line-modified"> 37 #include &quot;internal.h&quot;</span>
<span class="line-modified"> 38 </span>
<span class="line-modified"> 39 /* Force FFI_TYPE_LONGDOUBLE to be different than FFI_TYPE_DOUBLE;</span>
<span class="line-modified"> 40    all further uses in this file will refer to the 80-bit type.  */</span>
<span class="line-modified"> 41 #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE</span>
<span class="line-modified"> 42 # if FFI_TYPE_LONGDOUBLE != 4</span>
<span class="line-modified"> 43 #  error FFI_TYPE_LONGDOUBLE out of date</span>
<span class="line-modified"> 44 # endif</span>










 45 #else
<a name="5" id="anc5"></a><span class="line-modified"> 46 # undef FFI_TYPE_LONGDOUBLE</span>
<span class="line-added"> 47 # define FFI_TYPE_LONGDOUBLE 4</span>
 48 #endif
 49 
<a name="6" id="anc6"></a><span class="line-modified"> 50 #if defined(__GNUC__) &amp;&amp; !defined(__declspec)</span>
<span class="line-modified"> 51 # define __declspec(x)  __attribute__((x))</span>




 52 #endif
<a name="7" id="anc7"></a><span class="line-modified"> 53 </span>
<span class="line-modified"> 54 #if defined(_MSC_VER) &amp;&amp; defined(_M_IX86)</span>
<span class="line-modified"> 55 /* Stack is not 16-byte aligned on Windows.  */</span>
<span class="line-modified"> 56 #define STACK_ALIGN(bytes) (bytes)</span>
<span class="line-modified"> 57 #else</span>
<span class="line-modified"> 58 #define STACK_ALIGN(bytes) FFI_ALIGN (bytes, 16)</span>




 59 #endif
 60 
<a name="8" id="anc8"></a><span class="line-modified"> 61 /* Perform machine dependent cif processing.  */</span>
<span class="line-modified"> 62 ffi_status FFI_HIDDEN</span>
<span class="line-modified"> 63 ffi_prep_cif_machdep(ffi_cif *cif)</span>
<span class="line-added"> 64     {</span>
<span class="line-added"> 65   size_t bytes = 0;</span>
<span class="line-added"> 66   int i, n, flags, cabi = cif-&gt;abi;</span>
 67 
<a name="9" id="anc9"></a><span class="line-modified"> 68   switch (cabi)</span>


 69     {
<a name="10" id="anc10"></a><span class="line-modified"> 70     case FFI_SYSV:</span>
<span class="line-modified"> 71     case FFI_STDCALL:</span>
<span class="line-modified"> 72     case FFI_THISCALL:</span>
<span class="line-modified"> 73     case FFI_FASTCALL:</span>
<span class="line-modified"> 74     case FFI_MS_CDECL:</span>
<span class="line-added"> 75     case FFI_PASCAL:</span>
<span class="line-added"> 76     case FFI_REGISTER:</span>
<span class="line-added"> 77       break;</span>
<span class="line-added"> 78     default:</span>
<span class="line-added"> 79       return FFI_BAD_ABI;</span>
 80       }
<a name="11" id="anc11"></a>
 81 
<a name="12" id="anc12"></a><span class="line-modified"> 82   switch (cif-&gt;rtype-&gt;type)</span>


 83     {
<a name="13" id="anc13"></a><span class="line-modified"> 84     case FFI_TYPE_VOID:</span>
<span class="line-modified"> 85       flags = X86_RET_VOID;</span>





































 86               break;
<a name="14" id="anc14"></a><span class="line-modified"> 87     case FFI_TYPE_FLOAT:</span>
<span class="line-added"> 88       flags = X86_RET_FLOAT;</span>
<span class="line-added"> 89       break;</span>
<span class="line-added"> 90     case FFI_TYPE_DOUBLE:</span>
<span class="line-added"> 91       flags = X86_RET_DOUBLE;</span>
<span class="line-added"> 92       break;</span>
<span class="line-added"> 93     case FFI_TYPE_LONGDOUBLE:</span>
<span class="line-added"> 94       flags = X86_RET_LDOUBLE;</span>
<span class="line-added"> 95       break;</span>
 96             case FFI_TYPE_UINT8:
<a name="15" id="anc15"></a><span class="line-modified"> 97       flags = X86_RET_UINT8;</span>
 98               break;
<a name="16" id="anc16"></a><span class="line-modified"> 99     case FFI_TYPE_UINT16:</span>
<span class="line-added">100       flags = X86_RET_UINT16;</span>
<span class="line-added">101       break;</span>
<span class="line-added">102     case FFI_TYPE_SINT8:</span>
<span class="line-added">103       flags = X86_RET_SINT8;</span>
<span class="line-added">104       break;</span>
105             case FFI_TYPE_SINT16:
<a name="17" id="anc17"></a><span class="line-modified">106       flags = X86_RET_SINT16;</span>
107               break;
<a name="18" id="anc18"></a><span class="line-modified">108     case FFI_TYPE_INT:</span>




109             case FFI_TYPE_SINT32:
<a name="19" id="anc19"></a>


110             case FFI_TYPE_UINT32:
<a name="20" id="anc20"></a><span class="line-modified">111     case FFI_TYPE_POINTER:</span>
<span class="line-added">112       flags = X86_RET_INT32;</span>
113               break;
<a name="21" id="anc21"></a><span class="line-modified">114     case FFI_TYPE_SINT64:</span>
<span class="line-added">115     case FFI_TYPE_UINT64:</span>
<span class="line-added">116       flags = X86_RET_INT64;</span>
<span class="line-added">117       break;</span>
118             case FFI_TYPE_STRUCT:
<a name="22" id="anc22"></a><span class="line-modified">119 #ifndef X86</span>
<span class="line-added">120       /* ??? This should be a different ABI rather than an ifdef.  */</span>
<span class="line-added">121       if (cif-&gt;rtype-&gt;size == 1)</span>
<span class="line-added">122     flags = X86_RET_STRUCT_1B;</span>
<span class="line-added">123       else if (cif-&gt;rtype-&gt;size == 2)</span>
<span class="line-added">124     flags = X86_RET_STRUCT_2B;</span>
<span class="line-added">125       else if (cif-&gt;rtype-&gt;size == 4)</span>
<span class="line-added">126     flags = X86_RET_INT32;</span>
<span class="line-added">127       else if (cif-&gt;rtype-&gt;size == 8)</span>
<span class="line-added">128     flags = X86_RET_INT64;</span>
<span class="line-added">129       else</span>
<span class="line-added">130 #endif</span>
<span class="line-added">131     {</span>
<span class="line-added">132     do_struct:</span>
<span class="line-added">133       switch (cabi)</span>
<span class="line-added">134         {</span>
<span class="line-added">135         case FFI_THISCALL:</span>
<span class="line-added">136         case FFI_FASTCALL:</span>
<span class="line-added">137         case FFI_STDCALL:</span>
<span class="line-added">138         case FFI_MS_CDECL:</span>
<span class="line-added">139           flags = X86_RET_STRUCTARG;</span>
140               break;
<a name="23" id="anc23"></a>
141             default:
<a name="24" id="anc24"></a><span class="line-modified">142           flags = X86_RET_STRUCTPOP;</span>
<span class="line-added">143           break;</span>
144             }
<a name="25" id="anc25"></a><span class="line-added">145       /* Allocate space for return value pointer.  */</span>
<span class="line-added">146       bytes += FFI_ALIGN (sizeof(void*), FFI_SIZEOF_ARG);</span>
147         }
<a name="26" id="anc26"></a><span class="line-modified">148       break;</span>
<span class="line-added">149     case FFI_TYPE_COMPLEX:</span>
<span class="line-added">150       switch (cif-&gt;rtype-&gt;elements[0]-&gt;type)</span>
151         {
<a name="27" id="anc27"></a><span class="line-modified">152     case FFI_TYPE_DOUBLE:</span>
<span class="line-added">153     case FFI_TYPE_LONGDOUBLE:</span>
<span class="line-added">154     case FFI_TYPE_SINT64:</span>
<span class="line-added">155     case FFI_TYPE_UINT64:</span>
<span class="line-added">156       goto do_struct;</span>
<span class="line-added">157     case FFI_TYPE_FLOAT:</span>
<span class="line-added">158     case FFI_TYPE_INT:</span>
<span class="line-added">159     case FFI_TYPE_SINT32:</span>
<span class="line-added">160     case FFI_TYPE_UINT32:</span>
<span class="line-added">161       flags = X86_RET_INT64;</span>
<span class="line-added">162       break;</span>
<span class="line-added">163     case FFI_TYPE_SINT16:</span>
<span class="line-added">164     case FFI_TYPE_UINT16:</span>
<span class="line-added">165       flags = X86_RET_INT32;</span>
<span class="line-added">166       break;</span>
<span class="line-added">167     case FFI_TYPE_SINT8:</span>
<span class="line-added">168     case FFI_TYPE_UINT8:</span>
<span class="line-added">169       flags = X86_RET_STRUCT_2B;</span>
<span class="line-added">170       break;</span>
<span class="line-added">171     default:</span>
<span class="line-added">172       return FFI_BAD_TYPEDEF;</span>
173         }
<a name="28" id="anc28"></a><span class="line-added">174       break;</span>
<span class="line-added">175     default:</span>
<span class="line-added">176       return FFI_BAD_TYPEDEF;</span>
<span class="line-added">177     }</span>
<span class="line-added">178   cif-&gt;flags = flags;</span>
179 
<a name="29" id="anc29"></a><span class="line-modified">180   for (i = 0, n = cif-&gt;nargs; i &lt; n; i++)</span>









181       {
<a name="30" id="anc30"></a><span class="line-modified">182       ffi_type *t = cif-&gt;arg_types[i];</span>
<span class="line-modified">183 </span>
<span class="line-modified">184       bytes = FFI_ALIGN (bytes, t-&gt;alignment);</span>
<span class="line-modified">185       bytes += FFI_ALIGN (t-&gt;size, FFI_SIZEOF_ARG);</span>







186       }
<a name="31" id="anc31"></a><span class="line-modified">187   cif-&gt;bytes = bytes;</span>
188 
<a name="32" id="anc32"></a><span class="line-modified">189   return FFI_OK;</span>




190     }
191 
<a name="33" id="anc33"></a><span class="line-modified">192 static ffi_arg</span>
<span class="line-modified">193 extend_basic_type(void *arg, int type)</span>


194     {
<a name="34" id="anc34"></a><span class="line-modified">195   switch (type)</span>



196         {
<a name="35" id="anc35"></a><span class="line-modified">197     case FFI_TYPE_SINT8:</span>
<span class="line-modified">198       return *(SINT8 *)arg;</span>
<span class="line-modified">199     case FFI_TYPE_UINT8:</span>
<span class="line-modified">200       return *(UINT8 *)arg;</span>
<span class="line-modified">201     case FFI_TYPE_SINT16:</span>
<span class="line-added">202       return *(SINT16 *)arg;</span>
<span class="line-added">203     case FFI_TYPE_UINT16:</span>
<span class="line-added">204       return *(UINT16 *)arg;</span>
205 
<a name="36" id="anc36"></a><span class="line-modified">206     case FFI_TYPE_SINT32:</span>
<span class="line-modified">207     case FFI_TYPE_UINT32:</span>
<span class="line-modified">208     case FFI_TYPE_POINTER:</span>
<span class="line-modified">209     case FFI_TYPE_FLOAT:</span>
<span class="line-modified">210       return *(UINT32 *)arg;</span>






211 
<a name="37" id="anc37"></a><span class="line-modified">212     default:</span>
<span class="line-added">213       abort();</span>
214         }
215     }
216 
<a name="38" id="anc38"></a><span class="line-modified">217 struct call_frame</span>






218 {
<a name="39" id="anc39"></a><span class="line-modified">219   void *ebp;        /* 0 */</span>
<span class="line-modified">220   void *retaddr;    /* 4 */</span>
<span class="line-modified">221   void (*fn)(void); /* 8 */</span>
<span class="line-modified">222   int flags;        /* 12 */</span>
<span class="line-modified">223   void *rvalue;     /* 16 */</span>
<span class="line-modified">224   unsigned regs[3]; /* 20-28 */</span>
<span class="line-modified">225 };</span>
<span class="line-modified">226 </span>
<span class="line-modified">227 struct abi_params</span>
<span class="line-modified">228 {</span>
<span class="line-modified">229   int dir;      /* parameter growth direction */</span>
<span class="line-modified">230   int static_chain; /* the static chain register used by gcc */</span>
<span class="line-modified">231   int nregs;        /* number of register parameters */</span>
<span class="line-modified">232   int regs[3];</span>
<span class="line-modified">233 };</span>
<span class="line-modified">234 </span>
<span class="line-modified">235 static const struct abi_params abi_params[FFI_LAST_ABI] = {</span>
<span class="line-modified">236   [FFI_SYSV] = { 1, R_ECX, 0 },</span>
<span class="line-modified">237   [FFI_THISCALL] = { 1, R_EAX, 1, { R_ECX } },</span>
<span class="line-modified">238   [FFI_FASTCALL] = { 1, R_EAX, 2, { R_ECX, R_EDX } },</span>
<span class="line-modified">239   [FFI_STDCALL] = { 1, R_ECX, 0 },</span>
<span class="line-added">240   [FFI_PASCAL] = { -1, R_ECX, 0 },</span>
<span class="line-added">241   /* ??? No defined static chain; gcc does not support REGISTER.  */</span>
<span class="line-added">242   [FFI_REGISTER] = { -1, R_ECX, 3, { R_EAX, R_EDX, R_ECX } },</span>
<span class="line-added">243   [FFI_MS_CDECL] = { 1, R_ECX, 0 }</span>
<span class="line-added">244 };</span>
<span class="line-added">245 </span>
<span class="line-added">246 #ifdef HAVE_FASTCALL</span>
<span class="line-added">247   #ifdef _MSC_VER</span>
<span class="line-added">248     #define FFI_DECLARE_FASTCALL __fastcall</span>
<span class="line-added">249   #else</span>
<span class="line-added">250     #define FFI_DECLARE_FASTCALL __declspec(fastcall)</span>
251 #endif
<a name="40" id="anc40"></a><span class="line-added">252 #else</span>
<span class="line-added">253   #define FFI_DECLARE_FASTCALL</span>
254 #endif
<a name="41" id="anc41"></a>

255 
<a name="42" id="anc42"></a><span class="line-modified">256 extern void FFI_DECLARE_FASTCALL ffi_call_i386(struct call_frame *, char *) FFI_HIDDEN;</span>





257 
<a name="43" id="anc43"></a><span class="line-modified">258 static void</span>
<span class="line-modified">259 ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue,</span>
<span class="line-modified">260           void **avalue, void *closure)</span>








261         {
<a name="44" id="anc44"></a><span class="line-modified">262   size_t rsize, bytes;</span>
<span class="line-modified">263   struct call_frame *frame;</span>
<span class="line-modified">264   char *stack, *argp;</span>
<span class="line-modified">265   ffi_type **arg_types;</span>
<span class="line-modified">266   int flags, cabi, i, n, dir, narg_reg;</span>
<span class="line-modified">267   const struct abi_params *pabi;</span>
<span class="line-modified">268 </span>
<span class="line-added">269   flags = cif-&gt;flags;</span>
<span class="line-added">270   cabi = cif-&gt;abi;</span>
<span class="line-added">271   pabi = &amp;abi_params[cabi];</span>
<span class="line-added">272   dir = pabi-&gt;dir;</span>
<span class="line-added">273 </span>
<span class="line-added">274   rsize = 0;</span>
<span class="line-added">275   if (rvalue == NULL)</span>
276         {
<a name="45" id="anc45"></a><span class="line-modified">277       switch (flags)</span>



278         {
<a name="46" id="anc46"></a><span class="line-modified">279     case X86_RET_FLOAT:</span>
<span class="line-modified">280     case X86_RET_DOUBLE:</span>
<span class="line-modified">281     case X86_RET_LDOUBLE:</span>
<span class="line-modified">282     case X86_RET_STRUCTPOP:</span>
<span class="line-modified">283     case X86_RET_STRUCTARG:</span>
<span class="line-modified">284       /* The float cases need to pop the 387 stack.</span>
<span class="line-modified">285          The struct cases need to pass a valid pointer to the callee.  */</span>
<span class="line-modified">286       rsize = cif-&gt;rtype-&gt;size;</span>

287       break;
<a name="47" id="anc47"></a>
288     default:
<a name="48" id="anc48"></a><span class="line-modified">289       /* We can pretend that the callee returns nothing.  */</span>
<span class="line-modified">290       flags = X86_RET_VOID;</span>






291       break;
292     }
<a name="49" id="anc49"></a>





293     }
294 
<a name="50" id="anc50"></a><span class="line-modified">295   bytes = STACK_ALIGN (cif-&gt;bytes);</span>
<span class="line-modified">296   stack = alloca(bytes + sizeof(*frame) + rsize);</span>
<span class="line-modified">297   argp = (dir &lt; 0 ? stack + bytes : stack);</span>
<span class="line-modified">298   frame = (struct call_frame *)(stack + bytes);</span>
<span class="line-added">299   if (rsize)</span>
<span class="line-added">300     rvalue = frame + 1;</span>
301 
<a name="51" id="anc51"></a><span class="line-modified">302   frame-&gt;fn = fn;</span>
<span class="line-modified">303   frame-&gt;flags = flags;</span>
<span class="line-modified">304   frame-&gt;rvalue = rvalue;</span>
<span class="line-modified">305   frame-&gt;regs[pabi-&gt;static_chain] = (unsigned)closure;</span>


306 
<a name="52" id="anc52"></a><span class="line-modified">307   narg_reg = 0;</span>
<span class="line-added">308   switch (flags)</span>
<span class="line-added">309     {</span>
<span class="line-added">310     case X86_RET_STRUCTARG:</span>
<span class="line-added">311       /* The pointer is passed as the first argument.  */</span>
<span class="line-added">312       if (pabi-&gt;nregs &gt; 0)</span>
<span class="line-added">313     {</span>
<span class="line-added">314       frame-&gt;regs[pabi-&gt;regs[0]] = (unsigned)rvalue;</span>
<span class="line-added">315       narg_reg = 1;</span>
<span class="line-added">316       break;</span>
317 }
<a name="53" id="anc53"></a><span class="line-added">318       /* fallthru */</span>
<span class="line-added">319     case X86_RET_STRUCTPOP:</span>
<span class="line-added">320       *(void **)argp = rvalue;</span>
<span class="line-added">321       argp += sizeof(void *);</span>
<span class="line-added">322       break;</span>
<span class="line-added">323     }</span>
324 
<a name="54" id="anc54"></a><span class="line-modified">325   arg_types = cif-&gt;arg_types;</span>
<span class="line-modified">326   for (i = 0, n = cif-&gt;nargs; i &lt; n; i++)</span>
<span class="line-modified">327     {</span>
<span class="line-modified">328       ffi_type *ty = arg_types[i];</span>
<span class="line-modified">329       void *valp = avalue[i];</span>
<span class="line-modified">330       size_t z = ty-&gt;size;</span>
<span class="line-modified">331       int t = ty-&gt;type;</span>




332 
<a name="55" id="anc55"></a><span class="line-modified">333       if (z &lt;= FFI_SIZEOF_ARG &amp;&amp; t != FFI_TYPE_STRUCT)</span>
334 {
<a name="56" id="anc56"></a><span class="line-modified">335       ffi_arg val = extend_basic_type (valp, t);</span>
336 
<a name="57" id="anc57"></a><span class="line-modified">337       if (t != FFI_TYPE_FLOAT &amp;&amp; narg_reg &lt; pabi-&gt;nregs)</span>
<span class="line-modified">338         frame-&gt;regs[pabi-&gt;regs[narg_reg++]] = val;</span>
<span class="line-modified">339       else if (dir &lt; 0)</span>







340     {
<a name="58" id="anc58"></a><span class="line-modified">341           argp -= 4;</span>
<span class="line-added">342           *(ffi_arg *)argp = val;</span>
343     }
<a name="59" id="anc59"></a><span class="line-modified">344       else</span>



345     {
<a name="60" id="anc60"></a><span class="line-modified">346           *(ffi_arg *)argp = val;</span>
<span class="line-added">347           argp += 4;</span>
<span class="line-added">348     }</span>
349     }
<a name="61" id="anc61"></a>
350   else
<a name="62" id="anc62"></a>



351     {
<a name="63" id="anc63"></a><span class="line-modified">352       size_t za = FFI_ALIGN (z, FFI_SIZEOF_ARG);</span>
<span class="line-modified">353       size_t align = FFI_SIZEOF_ARG;</span>
<span class="line-modified">354 </span>
<span class="line-modified">355       /* Issue 434: For thiscall and fastcall, if the paramter passed</span>
<span class="line-modified">356          as 64-bit integer or struct, all following integer paramters</span>
<span class="line-modified">357          will be passed on stack.  */</span>
<span class="line-modified">358       if ((cabi == FFI_THISCALL || cabi == FFI_FASTCALL)</span>
<span class="line-modified">359           &amp;&amp; (t == FFI_TYPE_SINT64</span>
<span class="line-modified">360           || t == FFI_TYPE_UINT64</span>
<span class="line-modified">361           || t == FFI_TYPE_STRUCT))</span>
<span class="line-modified">362         narg_reg = 2;</span>
<span class="line-modified">363 </span>
<span class="line-modified">364       /* Alignment rules for arguments are quite complex.  Vectors and</span>
<span class="line-modified">365          structures with 16 byte alignment get it.  Note that long double</span>
<span class="line-modified">366          on Darwin does have 16 byte alignment, and does not get this</span>
<span class="line-modified">367          alignment if passed directly; a structure with a long double</span>
<span class="line-modified">368          inside, however, would get 16 byte alignment.  Since libffi does</span>
<span class="line-modified">369          not support vectors, we need non concern ourselves with other</span>
<span class="line-modified">370          cases.  */</span>
<span class="line-modified">371       if (t == FFI_TYPE_STRUCT &amp;&amp; ty-&gt;alignment &gt;= 16)</span>
<span class="line-modified">372         align = 16;</span>
<span class="line-modified">373 </span>
<span class="line-modified">374       if (dir &lt; 0)</span>
<span class="line-modified">375     {</span>
<span class="line-modified">376           /* ??? These reverse argument ABIs are probably too old</span>
<span class="line-modified">377          to have cared about alignment.  Someone should check.  */</span>
<span class="line-modified">378           argp -= za;</span>
<span class="line-added">379           memcpy (argp, valp, z);</span>
380     }
<a name="64" id="anc64"></a><span class="line-added">381       else</span>
<span class="line-added">382         {</span>
<span class="line-added">383           argp = (char *)FFI_ALIGN (argp, align);</span>
<span class="line-added">384           memcpy (argp, valp, z);</span>
<span class="line-added">385           argp += za;</span>
386 }
<a name="65" id="anc65"></a><span class="line-added">387     }</span>
<span class="line-added">388     }</span>
<span class="line-added">389   FFI_ASSERT (dir &gt; 0 || argp == stack);</span>
390 
<a name="66" id="anc66"></a><span class="line-modified">391   ffi_call_i386 (frame, stack);</span>
























































392 }
393 
<a name="67" id="anc67"></a><span class="line-modified">394 void</span>
<span class="line-modified">395 ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)</span>

396 {
<a name="68" id="anc68"></a><span class="line-modified">397   ffi_call_int (cif, fn, rvalue, avalue, NULL);</span>

















398 }
399 
<a name="69" id="anc69"></a><span class="line-modified">400 void</span>
<span class="line-modified">401 ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,</span>
<span class="line-added">402          void **avalue, void *closure)</span>
403 {
<a name="70" id="anc70"></a><span class="line-modified">404   ffi_call_int (cif, fn, rvalue, avalue, closure);</span>


















405 }
<a name="71" id="anc71"></a>
406 
<a name="72" id="anc72"></a><span class="line-modified">407 /** private members **/</span>



















408 
<a name="73" id="anc73"></a><span class="line-modified">409 void FFI_HIDDEN ffi_closure_i386(void);</span>
<span class="line-modified">410 void FFI_HIDDEN ffi_closure_STDCALL(void);</span>
<span class="line-modified">411 void FFI_HIDDEN ffi_closure_REGISTER(void);</span>

412 
<a name="74" id="anc74"></a><span class="line-modified">413 struct closure_frame</span>
<span class="line-modified">414 {</span>
<span class="line-modified">415   unsigned rettemp[4];              /* 0 */</span>
<span class="line-modified">416   unsigned regs[3];             /* 16-24 */</span>
<span class="line-modified">417   ffi_cif *cif;                 /* 28 */</span>
<span class="line-modified">418   void (*fun)(ffi_cif*,void*,void**,void*); /* 32 */</span>
<span class="line-added">419   void *user_data;              /* 36 */</span>
<span class="line-added">420 };</span>
<span class="line-added">421 </span>
<span class="line-added">422 int FFI_HIDDEN FFI_DECLARE_FASTCALL</span>
<span class="line-added">423 ffi_closure_inner (struct closure_frame *frame, char *stack)</span>
<span class="line-added">424 {</span>
<span class="line-added">425   ffi_cif *cif = frame-&gt;cif;</span>
<span class="line-added">426   int cabi, i, n, flags, dir, narg_reg;</span>
<span class="line-added">427   const struct abi_params *pabi;</span>
<span class="line-added">428   ffi_type **arg_types;</span>
<span class="line-added">429   char *argp;</span>
<span class="line-added">430   void *rvalue;</span>
<span class="line-added">431   void **avalue;</span>
<span class="line-added">432 </span>
<span class="line-added">433   cabi = cif-&gt;abi;</span>
<span class="line-added">434   flags = cif-&gt;flags;</span>
<span class="line-added">435   narg_reg = 0;</span>
<span class="line-added">436   rvalue = frame-&gt;rettemp;</span>
<span class="line-added">437   pabi = &amp;abi_params[cabi];</span>
<span class="line-added">438   dir = pabi-&gt;dir;</span>
<span class="line-added">439   argp = (dir &lt; 0 ? stack + STACK_ALIGN (cif-&gt;bytes) : stack);</span>
<span class="line-added">440 </span>
<span class="line-added">441   switch (flags)</span>
442     {
<a name="75" id="anc75"></a><span class="line-modified">443     case X86_RET_STRUCTARG:</span>
<span class="line-modified">444       if (pabi-&gt;nregs &gt; 0)</span>
445         {
<a name="76" id="anc76"></a><span class="line-modified">446       rvalue = (void *)frame-&gt;regs[pabi-&gt;regs[0]];</span>
<span class="line-modified">447       narg_reg = 1;</span>
<span class="line-added">448       frame-&gt;rettemp[0] = (unsigned)rvalue;</span>
<span class="line-added">449       break;</span>
450         }
<a name="77" id="anc77"></a><span class="line-modified">451       /* fallthru */</span>
<span class="line-modified">452     case X86_RET_STRUCTPOP:</span>
<span class="line-modified">453       rvalue = *(void **)argp;</span>

454           argp += sizeof(void *);
<a name="78" id="anc78"></a><span class="line-added">455       frame-&gt;rettemp[0] = (unsigned)rvalue;</span>
<span class="line-added">456       break;</span>
457         }
<a name="79" id="anc79"></a>
458 
<a name="80" id="anc80"></a><span class="line-modified">459   n = cif-&gt;nargs;</span>
<span class="line-modified">460   avalue = alloca(sizeof(void *) * n);</span>
<span class="line-modified">461 </span>
<span class="line-modified">462   arg_types = cif-&gt;arg_types;</span>
<span class="line-modified">463   for (i = 0; i &lt; n; ++i)</span>
464   {
<a name="81" id="anc81"></a><span class="line-modified">465       ffi_type *ty = arg_types[i];</span>
<span class="line-modified">466       size_t z = ty-&gt;size;</span>
<span class="line-modified">467       int t = ty-&gt;type;</span>
<span class="line-modified">468       void *valp;</span>
















469 
<a name="82" id="anc82"></a><span class="line-modified">470       if (z &lt;= FFI_SIZEOF_ARG &amp;&amp; t != FFI_TYPE_STRUCT)</span>


471     {
<a name="83" id="anc83"></a><span class="line-modified">472       if (t != FFI_TYPE_FLOAT &amp;&amp; narg_reg &lt; pabi-&gt;nregs)</span>
<span class="line-modified">473         valp = &amp;frame-&gt;regs[pabi-&gt;regs[narg_reg++]];</span>
<span class="line-added">474       else if (dir &lt; 0)</span>
475       {
<a name="84" id="anc84"></a><span class="line-modified">476           argp -= 4;</span>
<span class="line-modified">477           valp = argp;</span>
478       }
<a name="85" id="anc85"></a><span class="line-added">479       else</span>
<span class="line-added">480         {</span>
<span class="line-added">481           valp = argp;</span>
<span class="line-added">482           argp += 4;</span>
483     }
<a name="86" id="anc86"></a><span class="line-modified">484     }</span>
<span class="line-modified">485       else</span>


486     {
<a name="87" id="anc87"></a><span class="line-modified">487       size_t za = FFI_ALIGN (z, FFI_SIZEOF_ARG);</span>
<span class="line-modified">488       size_t align = FFI_SIZEOF_ARG;</span>
<span class="line-modified">489 </span>
<span class="line-modified">490       /* See the comment in ffi_call_int.  */</span>
<span class="line-modified">491       if (t == FFI_TYPE_STRUCT &amp;&amp; ty-&gt;alignment &gt;= 16)</span>
<span class="line-modified">492         align = 16;</span>
<span class="line-modified">493 </span>
<span class="line-modified">494       /* Issue 434: For thiscall and fastcall, if the paramter passed</span>
<span class="line-modified">495          as 64-bit integer or struct, all following integer paramters</span>
<span class="line-modified">496          will be passed on stack.  */</span>
<span class="line-modified">497       if ((cabi == FFI_THISCALL || cabi == FFI_FASTCALL)</span>
<span class="line-modified">498           &amp;&amp; (t == FFI_TYPE_SINT64</span>
<span class="line-modified">499           || t == FFI_TYPE_UINT64</span>
<span class="line-modified">500           || t == FFI_TYPE_STRUCT))</span>
<span class="line-modified">501         narg_reg = 2;</span>
<span class="line-modified">502 </span>
<span class="line-modified">503       if (dir &lt; 0)</span>




504         {
<a name="88" id="anc88"></a><span class="line-modified">505           /* ??? These reverse argument ABIs are probably too old</span>
<span class="line-modified">506          to have cared about alignment.  Someone should check.  */</span>
<span class="line-added">507           argp -= za;</span>
<span class="line-added">508           valp = argp;</span>
509         }
510       else
<a name="89" id="anc89"></a>





511         {
<a name="90" id="anc90"></a><span class="line-modified">512           argp = (char *)FFI_ALIGN (argp, align);</span>
<span class="line-modified">513           valp = argp;</span>
<span class="line-added">514           argp += za;</span>
515         }
<a name="91" id="anc91"></a>




516         }
517 
<a name="92" id="anc92"></a><span class="line-modified">518       avalue[i] = valp;</span>




519     }
520 
<a name="93" id="anc93"></a><span class="line-modified">521   frame-&gt;fun (cif, rvalue, avalue, frame-&gt;user_data);</span>

522 
<a name="94" id="anc94"></a><span class="line-modified">523   if (cabi == FFI_STDCALL)</span>
<span class="line-modified">524     return flags + (cif-&gt;bytes &lt;&lt; X86_RET_POP_SHIFT);</span>
<span class="line-modified">525   else</span>
<span class="line-modified">526     return flags;</span>































































527  }
528 
<a name="95" id="anc95"></a>

529 ffi_status
530 ffi_prep_closure_loc (ffi_closure* closure,
531                       ffi_cif* cif,
532                       void (*fun)(ffi_cif*,void*,void**,void*),
533                       void *user_data,
534                       void *codeloc)
535 {
<a name="96" id="anc96"></a><span class="line-modified">536   char *tramp = closure-&gt;tramp;</span>
<span class="line-modified">537   void (*dest)(void);</span>
<span class="line-modified">538   int op = 0xb8;  /* movl imm, %eax */</span>
<span class="line-modified">539 </span>
<span class="line-modified">540   switch (cif-&gt;abi)</span>


























541     {
<a name="97" id="anc97"></a><span class="line-modified">542     case FFI_SYSV:</span>
<span class="line-modified">543     case FFI_THISCALL:</span>
<span class="line-modified">544     case FFI_FASTCALL:</span>
<span class="line-added">545     case FFI_MS_CDECL:</span>
<span class="line-added">546       dest = ffi_closure_i386;</span>
<span class="line-added">547       break;</span>
<span class="line-added">548     case FFI_STDCALL:</span>
<span class="line-added">549     case FFI_PASCAL:</span>
<span class="line-added">550       dest = ffi_closure_STDCALL;</span>
<span class="line-added">551       break;</span>
<span class="line-added">552     case FFI_REGISTER:</span>
<span class="line-added">553       dest = ffi_closure_REGISTER;</span>
<span class="line-added">554       op = 0x68;  /* pushl imm */</span>
<span class="line-added">555       break;</span>
<span class="line-added">556     default:</span>
<span class="line-added">557       return FFI_BAD_ABI;</span>
558     }
<a name="98" id="anc98"></a><span class="line-modified">559 </span>
<span class="line-modified">560   /* movl or pushl immediate.  */</span>
<span class="line-modified">561   tramp[0] = op;</span>
<span class="line-modified">562   *(void **)(tramp + 1) = codeloc;</span>
<span class="line-modified">563 </span>
<span class="line-added">564   /* jmp dest */</span>
<span class="line-added">565   tramp[5] = 0xe9;</span>
<span class="line-added">566   *(unsigned *)(tramp + 6) = (unsigned)dest - ((unsigned)codeloc + 10);</span>
<span class="line-added">567 </span>
<span class="line-added">568   closure-&gt;cif = cif;</span>
<span class="line-added">569   closure-&gt;fun = fun;</span>
<span class="line-added">570   closure-&gt;user_data = user_data;</span>
<span class="line-added">571 </span>
<span class="line-added">572   return FFI_OK;</span>
573     }
<a name="99" id="anc99"></a><span class="line-modified">574 </span>
<span class="line-modified">575 void FFI_HIDDEN ffi_go_closure_EAX(void);</span>
<span class="line-added">576 void FFI_HIDDEN ffi_go_closure_ECX(void);</span>
<span class="line-added">577 void FFI_HIDDEN ffi_go_closure_STDCALL(void);</span>
<span class="line-added">578 </span>
<span class="line-added">579 ffi_status</span>
<span class="line-added">580 ffi_prep_go_closure (ffi_go_closure* closure, ffi_cif* cif,</span>
<span class="line-added">581              void (*fun)(ffi_cif*,void*,void**,void*))</span>
582     {
<a name="100" id="anc100"></a><span class="line-modified">583   void (*dest)(void);</span>
<span class="line-modified">584 </span>
<span class="line-modified">585   switch (cif-&gt;abi)</span>




586     {
<a name="101" id="anc101"></a><span class="line-added">587     case FFI_SYSV:</span>
<span class="line-added">588     case FFI_MS_CDECL:</span>
<span class="line-added">589       dest = ffi_go_closure_ECX;</span>
<span class="line-added">590       break;</span>
<span class="line-added">591     case FFI_THISCALL:</span>
<span class="line-added">592     case FFI_FASTCALL:</span>
<span class="line-added">593       dest = ffi_go_closure_EAX;</span>
<span class="line-added">594       break;</span>
<span class="line-added">595     case FFI_STDCALL:</span>
<span class="line-added">596     case FFI_PASCAL:</span>
<span class="line-added">597       dest = ffi_go_closure_STDCALL;</span>
<span class="line-added">598       break;</span>
<span class="line-added">599     case FFI_REGISTER:</span>
<span class="line-added">600     default:</span>
601       return FFI_BAD_ABI;
602     }
603 
<a name="102" id="anc102"></a><span class="line-modified">604   closure-&gt;tramp = dest;</span>
<span class="line-modified">605   closure-&gt;cif = cif;</span>
<span class="line-modified">606   closure-&gt;fun = fun;</span>
607 
608   return FFI_OK;
609 }
610 
611 /* ------- Native raw API support -------------------------------- */
612 
613 #if !FFI_NO_RAW_API
614 
<a name="103" id="anc103"></a><span class="line-added">615 void FFI_HIDDEN ffi_closure_raw_SYSV(void);</span>
<span class="line-added">616 void FFI_HIDDEN ffi_closure_raw_THISCALL(void);</span>
<span class="line-added">617 </span>
618 ffi_status
<a name="104" id="anc104"></a><span class="line-modified">619 ffi_prep_raw_closure_loc (ffi_raw_closure *closure,</span>
<span class="line-modified">620                           ffi_cif *cif,</span>
621                           void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
622                           void *user_data,
623                           void *codeloc)
624 {
<a name="105" id="anc105"></a><span class="line-added">625   char *tramp = closure-&gt;tramp;</span>
<span class="line-added">626   void (*dest)(void);</span>
627   int i;
628 
<a name="106" id="anc106"></a><span class="line-modified">629   /* We currently don&#39;t support certain kinds of arguments for raw</span>







630      closures.  This should be implemented by a separate assembly
631      language routine, since it would require argument processing,
632      something we don&#39;t do now for performance.  */
<a name="107" id="anc107"></a>
633   for (i = cif-&gt;nargs-1; i &gt;= 0; i--)
<a name="108" id="anc108"></a><span class="line-added">634     switch (cif-&gt;arg_types[i]-&gt;type)</span>
635     {
<a name="109" id="anc109"></a><span class="line-modified">636       case FFI_TYPE_STRUCT:</span>
<span class="line-modified">637       case FFI_TYPE_LONGDOUBLE:</span>
<span class="line-added">638     return FFI_BAD_TYPEDEF;</span>
639     }
640 
<a name="110" id="anc110"></a><span class="line-modified">641   switch (cif-&gt;abi)</span>








642     {
<a name="111" id="anc111"></a><span class="line-modified">643     case FFI_THISCALL:</span>
<span class="line-added">644       dest = ffi_closure_raw_THISCALL;</span>
<span class="line-added">645       break;</span>
<span class="line-added">646     case FFI_SYSV:</span>
<span class="line-added">647       dest = ffi_closure_raw_SYSV;</span>
<span class="line-added">648       break;</span>
<span class="line-added">649     default:</span>
<span class="line-added">650       return FFI_BAD_ABI;</span>
651     }
<a name="112" id="anc112"></a><span class="line-modified">652 </span>
<span class="line-modified">653   /* movl imm, %eax.  */</span>
<span class="line-added">654   tramp[0] = 0xb8;</span>
<span class="line-added">655   *(void **)(tramp + 1) = codeloc;</span>
<span class="line-added">656 </span>
<span class="line-added">657   /* jmp dest */</span>
<span class="line-added">658   tramp[5] = 0xe9;</span>
<span class="line-added">659   *(unsigned *)(tramp + 6) = (unsigned)dest - ((unsigned)codeloc + 10);</span>
<span class="line-added">660 </span>
<span class="line-added">661   closure-&gt;cif = cif;</span>
<span class="line-added">662   closure-&gt;fun = fun;</span>
663   closure-&gt;user_data = user_data;
<a name="113" id="anc113"></a>
664 
665   return FFI_OK;
666 }
667 
<a name="114" id="anc114"></a><span class="line-modified">668 void</span>
<span class="line-modified">669 ffi_raw_call(ffi_cif *cif, void (*fn)(void), void *rvalue, ffi_raw *avalue)</span>
670 {
<a name="115" id="anc115"></a><span class="line-modified">671   size_t rsize, bytes;</span>
<span class="line-modified">672   struct call_frame *frame;</span>
<span class="line-added">673   char *stack, *argp;</span>
<span class="line-added">674   ffi_type **arg_types;</span>
<span class="line-added">675   int flags, cabi, i, n, narg_reg;</span>
<span class="line-added">676   const struct abi_params *pabi;</span>
<span class="line-added">677 </span>
<span class="line-added">678   flags = cif-&gt;flags;</span>
<span class="line-added">679   cabi = cif-&gt;abi;</span>
<span class="line-added">680   pabi = &amp;abi_params[cabi];</span>
<span class="line-added">681 </span>
<span class="line-added">682   rsize = 0;</span>
<span class="line-added">683   if (rvalue == NULL)</span>
<span class="line-added">684     {</span>
<span class="line-added">685       switch (flags)</span>
<span class="line-added">686     {</span>
<span class="line-added">687     case X86_RET_FLOAT:</span>
<span class="line-added">688     case X86_RET_DOUBLE:</span>
<span class="line-added">689     case X86_RET_LDOUBLE:</span>
<span class="line-added">690     case X86_RET_STRUCTPOP:</span>
<span class="line-added">691     case X86_RET_STRUCTARG:</span>
<span class="line-added">692       /* The float cases need to pop the 387 stack.</span>
<span class="line-added">693          The struct cases need to pass a valid pointer to the callee.  */</span>
<span class="line-added">694       rsize = cif-&gt;rtype-&gt;size;</span>
<span class="line-added">695       break;</span>
<span class="line-added">696     default:</span>
<span class="line-added">697       /* We can pretend that the callee returns nothing.  */</span>
<span class="line-added">698       flags = X86_RET_VOID;</span>
<span class="line-added">699       break;</span>
<span class="line-added">700     }</span>
<span class="line-added">701     }</span>
702 
<a name="116" id="anc116"></a><span class="line-modified">703   bytes = STACK_ALIGN (cif-&gt;bytes);</span>
<span class="line-modified">704   argp = stack =</span>
<span class="line-modified">705       (void *)((uintptr_t)alloca(bytes + sizeof(*frame) + rsize + 15) &amp; ~16);</span>
<span class="line-modified">706   frame = (struct call_frame *)(stack + bytes);</span>
<span class="line-modified">707   if (rsize)</span>
<span class="line-modified">708     rvalue = frame + 1;</span>
709 
<a name="117" id="anc117"></a><span class="line-modified">710   frame-&gt;fn = fn;</span>
<span class="line-modified">711   frame-&gt;flags = flags;</span>
<span class="line-added">712   frame-&gt;rvalue = rvalue;</span>
713 
<a name="118" id="anc118"></a><span class="line-modified">714   narg_reg = 0;</span>
<span class="line-added">715   switch (flags)</span>
716     {
<a name="119" id="anc119"></a><span class="line-modified">717     case X86_RET_STRUCTARG:</span>
<span class="line-modified">718       /* The pointer is passed as the first argument.  */</span>
<span class="line-modified">719       if (pabi-&gt;nregs &gt; 0)</span>
<span class="line-modified">720     {</span>
<span class="line-modified">721       frame-&gt;regs[pabi-&gt;regs[0]] = (unsigned)rvalue;</span>
<span class="line-modified">722       narg_reg = 1;</span>
<span class="line-modified">723       break;</span>














724 }
<a name="120" id="anc120"></a><span class="line-added">725       /* fallthru */</span>
<span class="line-added">726     case X86_RET_STRUCTPOP:</span>
<span class="line-added">727       *(void **)argp = rvalue;</span>
<span class="line-added">728       argp += sizeof(void *);</span>
<span class="line-added">729       bytes -= sizeof(void *);</span>
<span class="line-added">730       break;</span>
<span class="line-added">731     }</span>
732 
<a name="121" id="anc121"></a><span class="line-modified">733   arg_types = cif-&gt;arg_types;</span>
<span class="line-modified">734   for (i = 0, n = cif-&gt;nargs; narg_reg &lt; pabi-&gt;nregs &amp;&amp; i &lt; n; i++)</span>





735 {
<a name="122" id="anc122"></a><span class="line-modified">736       ffi_type *ty = arg_types[i];</span>
<span class="line-modified">737       size_t z = ty-&gt;size;</span>
<span class="line-modified">738       int t = ty-&gt;type;</span>





739 
<a name="123" id="anc123"></a><span class="line-modified">740       if (z &lt;= FFI_SIZEOF_ARG &amp;&amp; t != FFI_TYPE_STRUCT &amp;&amp; t != FFI_TYPE_FLOAT)</span>


741     {
<a name="124" id="anc124"></a><span class="line-modified">742       ffi_arg val = extend_basic_type (avalue, t);</span>
<span class="line-added">743       frame-&gt;regs[pabi-&gt;regs[narg_reg++]] = val;</span>
<span class="line-added">744       z = FFI_SIZEOF_ARG;</span>
745     }
746   else
<a name="125" id="anc125"></a>



747     {
<a name="126" id="anc126"></a><span class="line-modified">748       memcpy (argp, avalue, z);</span>
<span class="line-modified">749       z = FFI_ALIGN (z, FFI_SIZEOF_ARG);</span>
<span class="line-modified">750       argp += z;</span>



















751     }
<a name="127" id="anc127"></a><span class="line-added">752       avalue += z;</span>
<span class="line-added">753       bytes -= z;</span>
754 }
<a name="128" id="anc128"></a><span class="line-added">755   if (i &lt; n)</span>
<span class="line-added">756     memcpy (argp, avalue, bytes);</span>
757 
<a name="129" id="anc129"></a><span class="line-modified">758   ffi_call_i386 (frame, stack);</span>
<span class="line-modified">759 }</span>
<span class="line-modified">760 #endif /* !FFI_NO_RAW_API */</span>
<span class="line-modified">761 #endif /* __i386__ */</span>
<a name="130" id="anc130"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="130" type="hidden" />
</body>
</html>
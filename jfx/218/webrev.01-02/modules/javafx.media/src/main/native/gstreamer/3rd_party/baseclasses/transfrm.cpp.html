<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/baseclasses/transfrm.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 //------------------------------------------------------------------------------
   2 // File: Transfrm.cpp
   3 //
   4 // Desc: DirectShow base classes - implements class for simple transform
   5 //       filters such as video decompressors.
   6 //
   7 // Copyright (c) 1992-2001 Microsoft Corporation.  All rights reserved.
   8 //------------------------------------------------------------------------------
   9 
  10 
  11 #include &lt;streams.h&gt;
  12 #include &lt;measure.h&gt;
  13 
  14 
  15 // =================================================================
  16 // Implements the CTransformFilter class
  17 // =================================================================
  18 
  19 CTransformFilter::CTransformFilter(__in_opt LPCTSTR pName,
  20                                    __inout_opt LPUNKNOWN pUnk,
  21                                    REFCLSID  clsid) :
  22     CBaseFilter(pName,pUnk,&amp;m_csFilter, clsid),
  23     m_pInput(NULL),
  24     m_pOutput(NULL),
  25     m_bEOSDelivered(FALSE),
  26     m_bQualityChanged(FALSE),
  27     m_bSampleSkipped(FALSE)
  28 {
  29 #ifdef PERF
  30     RegisterPerfId();
  31 #endif //  PERF
  32 }
  33 
  34 #ifdef UNICODE
  35 CTransformFilter::CTransformFilter(__in_opt LPCSTR pName,
  36                                    __inout_opt LPUNKNOWN pUnk,
  37                                    REFCLSID  clsid) :
  38     CBaseFilter(pName,pUnk,&amp;m_csFilter, clsid),
  39     m_pInput(NULL),
  40     m_pOutput(NULL),
  41     m_bEOSDelivered(FALSE),
  42     m_bQualityChanged(FALSE),
  43     m_bSampleSkipped(FALSE)
  44 {
  45 #ifdef PERF
  46     RegisterPerfId();
  47 #endif //  PERF
  48 }
  49 #endif
  50 
  51 // destructor
  52 
  53 CTransformFilter::~CTransformFilter()
  54 {
  55     // Delete the pins
  56 
  57     delete m_pInput;
  58     delete m_pOutput;
  59 }
  60 
  61 
  62 // Transform place holder - should never be called
  63 HRESULT CTransformFilter::Transform(IMediaSample * pIn, IMediaSample *pOut)
  64 {
  65     UNREFERENCED_PARAMETER(pIn);
  66     UNREFERENCED_PARAMETER(pOut);
  67     DbgBreak(&quot;CTransformFilter::Transform() should never be called&quot;);
  68     return E_UNEXPECTED;
  69 }
  70 
  71 
  72 // return the number of pins we provide
  73 
  74 int CTransformFilter::GetPinCount()
  75 {
  76     return 2;
  77 }
  78 
  79 
  80 // return a non-addrefed CBasePin * for the user to addref if he holds onto it
  81 // for longer than his pointer to us. We create the pins dynamically when they
  82 // are asked for rather than in the constructor. This is because we want to
  83 // give the derived class an oppportunity to return different pin objects
  84 
  85 // We return the objects as and when they are needed. If either of these fails
  86 // then we return NULL, the assumption being that the caller will realise the
  87 // whole deal is off and destroy us - which in turn will delete everything.
  88 
  89 CBasePin *
  90 CTransformFilter::GetPin(int n)
  91 {
  92     HRESULT hr = S_OK;
  93 
  94     // Create an input pin if necessary
  95 
  96     if (m_pInput == NULL) {
  97 
  98         m_pInput = new CTransformInputPin(NAME(&quot;Transform input pin&quot;),
  99                                           this,              // Owner filter
 100                                           &amp;hr,               // Result code
 101                                           L&quot;XForm In&quot;);      // Pin name
 102 
 103 
 104         //  Can&#39;t fail
 105         ASSERT(SUCCEEDED(hr));
 106         if (m_pInput == NULL) {
 107             return NULL;
 108         }
 109         m_pOutput = (CTransformOutputPin *)
 110            new CTransformOutputPin(NAME(&quot;Transform output pin&quot;),
 111                                             this,            // Owner filter
 112                                             &amp;hr,             // Result code
 113                                             L&quot;XForm Out&quot;);   // Pin name
 114 
 115 
 116         // Can&#39;t fail
 117         ASSERT(SUCCEEDED(hr));
 118         if (m_pOutput == NULL) {
 119             delete m_pInput;
 120             m_pInput = NULL;
 121         }
 122     }
 123 
 124     // Return the appropriate pin
 125 
 126     if (n == 0) {
 127         return m_pInput;
 128     } else
 129     if (n == 1) {
 130         return m_pOutput;
 131     } else {
 132         return NULL;
 133     }
 134 }
 135 
 136 
 137 //
 138 // FindPin
 139 //
 140 // If Id is In or Out then return the IPin* for that pin
 141 // creating the pin if need be.  Otherwise return NULL with an error.
 142 
 143 STDMETHODIMP CTransformFilter::FindPin(LPCWSTR Id, __deref_out IPin **ppPin)
 144 {
 145     CheckPointer(ppPin,E_POINTER);
 146     ValidateReadWritePtr(ppPin,sizeof(IPin *));
 147 
 148     if (0==lstrcmpW(Id,L&quot;In&quot;)) {
 149         *ppPin = GetPin(0);
 150     } else if (0==lstrcmpW(Id,L&quot;Out&quot;)) {
 151         *ppPin = GetPin(1);
 152     } else {
 153         *ppPin = NULL;
 154         return VFW_E_NOT_FOUND;
 155     }
 156 
 157     HRESULT hr = NOERROR;
 158     //  AddRef() returned pointer - but GetPin could fail if memory is low.
 159     if (*ppPin) {
 160         (*ppPin)-&gt;AddRef();
 161     } else {
 162         hr = E_OUTOFMEMORY;  // probably.  There&#39;s no pin anyway.
 163     }
 164     return hr;
 165 }
 166 
 167 
 168 // override these two functions if you want to inform something
 169 // about entry to or exit from streaming state.
 170 
 171 HRESULT
 172 CTransformFilter::StartStreaming()
 173 {
 174     return NOERROR;
 175 }
 176 
 177 
 178 HRESULT
 179 CTransformFilter::StopStreaming()
 180 {
 181     return NOERROR;
 182 }
 183 
 184 
 185 // override this to grab extra interfaces on connection
 186 
 187 HRESULT
 188 CTransformFilter::CheckConnect(PIN_DIRECTION dir, IPin *pPin)
 189 {
 190     UNREFERENCED_PARAMETER(dir);
 191     UNREFERENCED_PARAMETER(pPin);
 192     return NOERROR;
 193 }
 194 
 195 
 196 // place holder to allow derived classes to release any extra interfaces
 197 
 198 HRESULT
 199 CTransformFilter::BreakConnect(PIN_DIRECTION dir)
 200 {
 201     UNREFERENCED_PARAMETER(dir);
 202     return NOERROR;
 203 }
 204 
 205 
 206 // Let derived classes know about connection completion
 207 
 208 HRESULT
 209 CTransformFilter::CompleteConnect(PIN_DIRECTION direction,IPin *pReceivePin)
 210 {
 211     UNREFERENCED_PARAMETER(direction);
 212     UNREFERENCED_PARAMETER(pReceivePin);
 213     return NOERROR;
 214 }
 215 
 216 
 217 // override this to know when the media type is really set
 218 
 219 HRESULT
 220 CTransformFilter::SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt)
 221 {
 222     UNREFERENCED_PARAMETER(direction);
 223     UNREFERENCED_PARAMETER(pmt);
 224     return NOERROR;
 225 }
 226 
 227 
 228 // Set up our output sample
 229 HRESULT
 230 CTransformFilter::InitializeOutputSample(IMediaSample *pSample, __deref_out IMediaSample **ppOutSample)
 231 {
 232     IMediaSample *pOutSample;
 233 
 234     // default - times are the same
 235 
 236     AM_SAMPLE2_PROPERTIES * const pProps = m_pInput-&gt;SampleProps();
 237     DWORD dwFlags = m_bSampleSkipped ? AM_GBF_PREVFRAMESKIPPED : 0;
 238 
 239     // This will prevent the image renderer from switching us to DirectDraw
 240     // when we can&#39;t do it without skipping frames because we&#39;re not on a
 241     // keyframe.  If it really has to switch us, it still will, but then we
 242     // will have to wait for the next keyframe
 243     if (!(pProps-&gt;dwSampleFlags &amp; AM_SAMPLE_SPLICEPOINT)) {
 244     dwFlags |= AM_GBF_NOTASYNCPOINT;
 245     }
 246 
 247     ASSERT(m_pOutput-&gt;m_pAllocator != NULL);
 248     HRESULT hr = m_pOutput-&gt;m_pAllocator-&gt;GetBuffer(
 249              &amp;pOutSample
 250              , pProps-&gt;dwSampleFlags &amp; AM_SAMPLE_TIMEVALID ?
 251                    &amp;pProps-&gt;tStart : NULL
 252              , pProps-&gt;dwSampleFlags &amp; AM_SAMPLE_STOPVALID ?
 253                    &amp;pProps-&gt;tStop : NULL
 254              , dwFlags
 255          );
 256     *ppOutSample = pOutSample;
 257     if (FAILED(hr)) {
 258         return hr;
 259     }
 260 
 261     ASSERT(pOutSample);
 262     IMediaSample2 *pOutSample2;
 263     if (SUCCEEDED(pOutSample-&gt;QueryInterface(IID_IMediaSample2,
 264                                              (void **)&amp;pOutSample2))) {
 265         /*  Modify it */
 266         AM_SAMPLE2_PROPERTIES OutProps;
 267         EXECUTE_ASSERT(SUCCEEDED(pOutSample2-&gt;GetProperties(
 268             FIELD_OFFSET(AM_SAMPLE2_PROPERTIES, tStart), (PBYTE)&amp;OutProps)
 269         ));
 270         OutProps.dwTypeSpecificFlags = pProps-&gt;dwTypeSpecificFlags;
 271         OutProps.dwSampleFlags =
 272             (OutProps.dwSampleFlags &amp; AM_SAMPLE_TYPECHANGED) |
 273             (pProps-&gt;dwSampleFlags &amp; ~AM_SAMPLE_TYPECHANGED);
 274         OutProps.tStart = pProps-&gt;tStart;
 275         OutProps.tStop  = pProps-&gt;tStop;
 276         OutProps.cbData = FIELD_OFFSET(AM_SAMPLE2_PROPERTIES, dwStreamId);
 277         hr = pOutSample2-&gt;SetProperties(
 278             FIELD_OFFSET(AM_SAMPLE2_PROPERTIES, dwStreamId),
 279             (PBYTE)&amp;OutProps
 280         );
 281         if (pProps-&gt;dwSampleFlags &amp; AM_SAMPLE_DATADISCONTINUITY) {
 282             m_bSampleSkipped = FALSE;
 283         }
 284         pOutSample2-&gt;Release();
 285     } else {
 286         if (pProps-&gt;dwSampleFlags &amp; AM_SAMPLE_TIMEVALID) {
 287             pOutSample-&gt;SetTime(&amp;pProps-&gt;tStart,
 288                                 &amp;pProps-&gt;tStop);
 289         }
 290         if (pProps-&gt;dwSampleFlags &amp; AM_SAMPLE_SPLICEPOINT) {
 291             pOutSample-&gt;SetSyncPoint(TRUE);
 292         }
 293         if (pProps-&gt;dwSampleFlags &amp; AM_SAMPLE_DATADISCONTINUITY) {
 294             pOutSample-&gt;SetDiscontinuity(TRUE);
 295             m_bSampleSkipped = FALSE;
 296         }
 297         // Copy the media times
 298 
 299         LONGLONG MediaStart, MediaEnd;
 300         if (pSample-&gt;GetMediaTime(&amp;MediaStart,&amp;MediaEnd) == NOERROR) {
 301             pOutSample-&gt;SetMediaTime(&amp;MediaStart,&amp;MediaEnd);
 302         }
 303     }
 304     return S_OK;
 305 }
 306 
 307 // override this to customize the transform process
 308 
 309 HRESULT
 310 CTransformFilter::Receive(IMediaSample *pSample)
 311 {
 312     /*  Check for other streams and pass them on */
 313     AM_SAMPLE2_PROPERTIES * const pProps = m_pInput-&gt;SampleProps();
 314     if (pProps-&gt;dwStreamId != AM_STREAM_MEDIA) {
 315         return m_pOutput-&gt;m_pInputPin-&gt;Receive(pSample);
 316     }
 317     HRESULT hr;
 318     ASSERT(pSample);
 319     IMediaSample * pOutSample;
 320 
 321     // If no output to deliver to then no point sending us data
 322 
 323     ASSERT (m_pOutput != NULL) ;
 324 
 325     // Set up the output sample
 326     hr = InitializeOutputSample(pSample, &amp;pOutSample);
 327 
 328     if (FAILED(hr)) {
 329         return hr;
 330     }
 331 
 332     // Start timing the transform (if PERF is defined)
 333     MSR_START(m_idTransform);
 334 
 335     // have the derived class transform the data
 336 
 337     hr = Transform(pSample, pOutSample);
 338 
 339     // Stop the clock and log it (if PERF is defined)
 340     MSR_STOP(m_idTransform);
 341 
 342     if (FAILED(hr)) {
 343     DbgLog((LOG_TRACE,1,TEXT(&quot;Error from transform&quot;)));
 344     } else {
 345         // the Transform() function can return S_FALSE to indicate that the
 346         // sample should not be delivered; we only deliver the sample if it&#39;s
 347         // really S_OK (same as NOERROR, of course.)
 348         if (hr == NOERROR) {
 349             hr = m_pOutput-&gt;m_pInputPin-&gt;Receive(pOutSample);
 350             m_bSampleSkipped = FALSE;   // last thing no longer dropped
 351         } else {
 352             // S_FALSE returned from Transform is a PRIVATE agreement
 353             // We should return NOERROR from Receive() in this cause because returning S_FALSE
 354             // from Receive() means that this is the end of the stream and no more data should
 355             // be sent.
 356             if (S_FALSE == hr) {
 357 
 358                 //  Release the sample before calling notify to avoid
 359                 //  deadlocks if the sample holds a lock on the system
 360                 //  such as DirectDraw buffers do
 361                 pOutSample-&gt;Release();
 362                 m_bSampleSkipped = TRUE;
 363                 if (!m_bQualityChanged) {
 364                     NotifyEvent(EC_QUALITY_CHANGE,0,0);
 365                     m_bQualityChanged = TRUE;
 366                 }
 367                 return NOERROR;
 368             }
 369         }
 370     }
 371 
 372     // release the output buffer. If the connected pin still needs it,
 373     // it will have addrefed it itself.
 374     pOutSample-&gt;Release();
 375 
 376     return hr;
 377 }
 378 
 379 
 380 // Return S_FALSE to mean &quot;pass the note on upstream&quot;
 381 // Return NOERROR (Same as S_OK)
 382 // to mean &quot;I&#39;ve done something about it, don&#39;t pass it on&quot;
 383 HRESULT CTransformFilter::AlterQuality(Quality q)
 384 {
 385     UNREFERENCED_PARAMETER(q);
 386     return S_FALSE;
 387 }
 388 
 389 
 390 // EndOfStream received. Default behaviour is to deliver straight
 391 // downstream, since we have no queued data. If you overrode Receive
 392 // and have queue data, then you need to handle this and deliver EOS after
 393 // all queued data is sent
 394 HRESULT
 395 CTransformFilter::EndOfStream(void)
 396 {
 397     HRESULT hr = NOERROR;
 398     if (m_pOutput != NULL) {
 399         hr = m_pOutput-&gt;DeliverEndOfStream();
 400     }
 401 
 402     return hr;
 403 }
 404 
 405 
 406 // enter flush state. Receives already blocked
 407 // must override this if you have queued data or a worker thread
 408 HRESULT
 409 CTransformFilter::BeginFlush(void)
 410 {
 411     HRESULT hr = NOERROR;
 412     if (m_pOutput != NULL) {
 413     // block receives -- done by caller (CBaseInputPin::BeginFlush)
 414 
 415     // discard queued data -- we have no queued data
 416 
 417     // free anyone blocked on receive - not possible in this filter
 418 
 419     // call downstream
 420     hr = m_pOutput-&gt;DeliverBeginFlush();
 421     }
 422     return hr;
 423 }
 424 
 425 
 426 // leave flush state. must override this if you have queued data
 427 // or a worker thread
 428 HRESULT
 429 CTransformFilter::EndFlush(void)
 430 {
 431     // sync with pushing thread -- we have no worker thread
 432 
 433     // ensure no more data to go downstream -- we have no queued data
 434 
 435     // call EndFlush on downstream pins
 436     ASSERT (m_pOutput != NULL);
 437     return m_pOutput-&gt;DeliverEndFlush();
 438 
 439     // caller (the input pin&#39;s method) will unblock Receives
 440 }
 441 
 442 
 443 // override these so that the derived filter can catch them
 444 
 445 STDMETHODIMP
 446 CTransformFilter::Stop()
 447 {
 448     CAutoLock lck1(&amp;m_csFilter);
 449     if (m_State == State_Stopped) {
 450         return NOERROR;
 451     }
 452 
 453     // Succeed the Stop if we are not completely connected
 454 
 455     ASSERT(m_pInput == NULL || m_pOutput != NULL);
 456     if (m_pInput == NULL || m_pInput-&gt;IsConnected() == FALSE ||
 457         m_pOutput-&gt;IsConnected() == FALSE) {
 458                 m_State = State_Stopped;
 459                 m_bEOSDelivered = FALSE;
 460                 return NOERROR;
 461     }
 462 
 463     ASSERT(m_pInput);
 464     ASSERT(m_pOutput);
 465 
 466     // decommit the input pin before locking or we can deadlock
 467     m_pInput-&gt;Inactive();
 468 
 469     // synchronize with Receive calls
 470 
 471     CAutoLock lck2(&amp;m_csReceive);
 472     m_pOutput-&gt;Inactive();
 473 
 474     // allow a class derived from CTransformFilter
 475     // to know about starting and stopping streaming
 476 
 477     HRESULT hr = StopStreaming();
 478     if (SUCCEEDED(hr)) {
 479     // complete the state transition
 480     m_State = State_Stopped;
 481     m_bEOSDelivered = FALSE;
 482     }
 483     return hr;
 484 }
 485 
 486 
 487 STDMETHODIMP
 488 CTransformFilter::Pause()
 489 {
 490     CAutoLock lck(&amp;m_csFilter);
 491     HRESULT hr = NOERROR;
 492 
 493     if (m_State == State_Paused) {
 494         // (This space left deliberately blank)
 495     }
 496 
 497     // If we have no input pin or it isn&#39;t yet connected then when we are
 498     // asked to pause we deliver an end of stream to the downstream filter.
 499     // This makes sure that it doesn&#39;t sit there forever waiting for
 500     // samples which we cannot ever deliver without an input connection.
 501 
 502     else if (m_pInput == NULL || m_pInput-&gt;IsConnected() == FALSE) {
 503         if (m_pOutput &amp;&amp; m_bEOSDelivered == FALSE) {
 504             m_pOutput-&gt;DeliverEndOfStream();
 505             m_bEOSDelivered = TRUE;
 506         }
 507         m_State = State_Paused;
 508     }
 509 
 510     // We may have an input connection but no output connection
 511     // However, if we have an input pin we do have an output pin
 512 
 513     else if (m_pOutput-&gt;IsConnected() == FALSE) {
 514         m_State = State_Paused;
 515     }
 516 
 517     else {
 518     if (m_State == State_Stopped) {
 519         // allow a class derived from CTransformFilter
 520         // to know about starting and stopping streaming
 521             CAutoLock lck2(&amp;m_csReceive);
 522         hr = StartStreaming();
 523     }
 524     if (SUCCEEDED(hr)) {
 525         hr = CBaseFilter::Pause();
 526     }
 527     }
 528 
 529     m_bSampleSkipped = FALSE;
 530     m_bQualityChanged = FALSE;
 531     return hr;
 532 }
 533 
 534 HRESULT
 535 CTransformFilter::NewSegment(
 536     REFERENCE_TIME tStart,
 537     REFERENCE_TIME tStop,
 538     double dRate)
 539 {
 540     if (m_pOutput != NULL) {
 541         return m_pOutput-&gt;DeliverNewSegment(tStart, tStop, dRate);
 542     }
 543     return S_OK;
 544 }
 545 
 546 // Check streaming status
 547 HRESULT
 548 CTransformInputPin::CheckStreaming()
 549 {
 550     ASSERT(m_pTransformFilter-&gt;m_pOutput != NULL);
 551     if (!m_pTransformFilter-&gt;m_pOutput-&gt;IsConnected()) {
 552         return VFW_E_NOT_CONNECTED;
 553     } else {
 554         //  Shouldn&#39;t be able to get any data if we&#39;re not connected!
 555         ASSERT(IsConnected());
 556 
 557         //  we&#39;re flushing
 558         if (m_bFlushing) {
 559             return S_FALSE;
 560         }
 561         //  Don&#39;t process stuff in Stopped state
 562         if (IsStopped()) {
 563             return VFW_E_WRONG_STATE;
 564         }
 565         if (m_bRunTimeError) {
 566             return VFW_E_RUNTIME_ERROR;
 567         }
 568         return S_OK;
 569     }
 570 }
 571 
 572 
 573 // =================================================================
 574 // Implements the CTransformInputPin class
 575 // =================================================================
 576 
 577 
 578 // constructor
 579 
 580 CTransformInputPin::CTransformInputPin(
 581     __in_opt LPCTSTR pObjectName,
 582     __inout CTransformFilter *pTransformFilter,
 583     __inout HRESULT * phr,
 584     __in_opt LPCWSTR pName)
 585     : CBaseInputPin(pObjectName, pTransformFilter, &amp;pTransformFilter-&gt;m_csFilter, phr, pName)
 586 {
 587     DbgLog((LOG_TRACE,2,TEXT(&quot;CTransformInputPin::CTransformInputPin&quot;)));
 588     m_pTransformFilter = pTransformFilter;
 589 }
 590 
 591 #ifdef UNICODE
 592 CTransformInputPin::CTransformInputPin(
 593     __in_opt LPCSTR pObjectName,
 594     __inout CTransformFilter *pTransformFilter,
 595     __inout HRESULT * phr,
 596     __in_opt LPCWSTR pName)
 597     : CBaseInputPin(pObjectName, pTransformFilter, &amp;pTransformFilter-&gt;m_csFilter, phr, pName)
 598 {
 599     DbgLog((LOG_TRACE,2,TEXT(&quot;CTransformInputPin::CTransformInputPin&quot;)));
 600     m_pTransformFilter = pTransformFilter;
 601 }
 602 #endif
 603 
 604 // provides derived filter a chance to grab extra interfaces
 605 
 606 HRESULT
 607 CTransformInputPin::CheckConnect(IPin *pPin)
 608 {
 609     HRESULT hr = m_pTransformFilter-&gt;CheckConnect(PINDIR_INPUT,pPin);
 610     if (FAILED(hr)) {
 611         return hr;
 612     }
 613     return CBaseInputPin::CheckConnect(pPin);
 614 }
 615 
 616 
 617 // provides derived filter a chance to release it&#39;s extra interfaces
 618 
 619 HRESULT
 620 CTransformInputPin::BreakConnect()
 621 {
 622     //  Can&#39;t disconnect unless stopped
 623     ASSERT(IsStopped());
 624     m_pTransformFilter-&gt;BreakConnect(PINDIR_INPUT);
 625     return CBaseInputPin::BreakConnect();
 626 }
 627 
 628 
 629 // Let derived class know when the input pin is connected
 630 
 631 HRESULT
 632 CTransformInputPin::CompleteConnect(IPin *pReceivePin)
 633 {
 634     HRESULT hr = m_pTransformFilter-&gt;CompleteConnect(PINDIR_INPUT,pReceivePin);
 635     if (FAILED(hr)) {
 636         return hr;
 637     }
 638     return CBaseInputPin::CompleteConnect(pReceivePin);
 639 }
 640 
 641 
 642 // check that we can support a given media type
 643 
 644 HRESULT
 645 CTransformInputPin::CheckMediaType(const CMediaType* pmt)
 646 {
 647     // Check the input type
 648 
 649     HRESULT hr = m_pTransformFilter-&gt;CheckInputType(pmt);
 650     if (S_OK != hr) {
 651         return hr;
 652     }
 653 
 654     // if the output pin is still connected, then we have
 655     // to check the transform not just the input format
 656 
 657     if ((m_pTransformFilter-&gt;m_pOutput != NULL) &amp;&amp;
 658         (m_pTransformFilter-&gt;m_pOutput-&gt;IsConnected())) {
 659             return m_pTransformFilter-&gt;CheckTransform(
 660                       pmt,
 661               &amp;m_pTransformFilter-&gt;m_pOutput-&gt;CurrentMediaType());
 662     } else {
 663         return hr;
 664     }
 665 }
 666 
 667 
 668 // set the media type for this connection
 669 
 670 HRESULT
 671 CTransformInputPin::SetMediaType(const CMediaType* mtIn)
 672 {
 673     // Set the base class media type (should always succeed)
 674     HRESULT hr = CBasePin::SetMediaType(mtIn);
 675     if (FAILED(hr)) {
 676         return hr;
 677     }
 678 
 679     // check the transform can be done (should always succeed)
 680     ASSERT(SUCCEEDED(m_pTransformFilter-&gt;CheckInputType(mtIn)));
 681 
 682     return m_pTransformFilter-&gt;SetMediaType(PINDIR_INPUT,mtIn);
 683 }
 684 
 685 
 686 // =================================================================
 687 // Implements IMemInputPin interface
 688 // =================================================================
 689 
 690 
 691 // provide EndOfStream that passes straight downstream
 692 // (there is no queued data)
 693 STDMETHODIMP
 694 CTransformInputPin::EndOfStream(void)
 695 {
 696     CAutoLock lck(&amp;m_pTransformFilter-&gt;m_csReceive);
 697     HRESULT hr = CheckStreaming();
 698     if (S_OK == hr) {
 699        hr = m_pTransformFilter-&gt;EndOfStream();
 700     }
 701     return hr;
 702 }
 703 
 704 
 705 // enter flushing state. Call default handler to block Receives, then
 706 // pass to overridable method in filter
 707 STDMETHODIMP
 708 CTransformInputPin::BeginFlush(void)
 709 {
 710     CAutoLock lck(&amp;m_pTransformFilter-&gt;m_csFilter);
 711     //  Are we actually doing anything?
 712     ASSERT(m_pTransformFilter-&gt;m_pOutput != NULL);
 713     if (!IsConnected() ||
 714         !m_pTransformFilter-&gt;m_pOutput-&gt;IsConnected()) {
 715         return VFW_E_NOT_CONNECTED;
 716     }
 717     HRESULT hr = CBaseInputPin::BeginFlush();
 718     if (FAILED(hr)) {
 719         return hr;
 720     }
 721 
 722     return m_pTransformFilter-&gt;BeginFlush();
 723 }
 724 
 725 
 726 // leave flushing state.
 727 // Pass to overridable method in filter, then call base class
 728 // to unblock receives (finally)
 729 STDMETHODIMP
 730 CTransformInputPin::EndFlush(void)
 731 {
 732     CAutoLock lck(&amp;m_pTransformFilter-&gt;m_csFilter);
 733     //  Are we actually doing anything?
 734     ASSERT(m_pTransformFilter-&gt;m_pOutput != NULL);
 735     if (!IsConnected() ||
 736         !m_pTransformFilter-&gt;m_pOutput-&gt;IsConnected()) {
 737         return VFW_E_NOT_CONNECTED;
 738     }
 739 
 740     HRESULT hr = m_pTransformFilter-&gt;EndFlush();
 741     if (FAILED(hr)) {
 742         return hr;
 743     }
 744 
 745     return CBaseInputPin::EndFlush();
 746 }
 747 
 748 
 749 // here&#39;s the next block of data from the stream.
 750 // AddRef it yourself if you need to hold it beyond the end
 751 // of this call.
 752 
 753 HRESULT
 754 CTransformInputPin::Receive(IMediaSample * pSample)
 755 {
 756     HRESULT hr;
 757     CAutoLock lck(&amp;m_pTransformFilter-&gt;m_csReceive);
 758     ASSERT(pSample);
 759 
 760     // check all is well with the base class
 761     hr = CBaseInputPin::Receive(pSample);
 762     if (S_OK == hr) {
 763         hr = m_pTransformFilter-&gt;Receive(pSample);
 764     }
 765     return hr;
 766 }
 767 
 768 
 769 
 770 
 771 // override to pass downstream
 772 STDMETHODIMP
 773 CTransformInputPin::NewSegment(
 774     REFERENCE_TIME tStart,
 775     REFERENCE_TIME tStop,
 776     double dRate)
 777 {
 778     //  Save the values in the pin
 779     CBasePin::NewSegment(tStart, tStop, dRate);
 780     return m_pTransformFilter-&gt;NewSegment(tStart, tStop, dRate);
 781 }
 782 
 783 
 784 
 785 
 786 // =================================================================
 787 // Implements the CTransformOutputPin class
 788 // =================================================================
 789 
 790 
 791 // constructor
 792 
 793 CTransformOutputPin::CTransformOutputPin(
 794     __in_opt LPCTSTR pObjectName,
 795     __inout CTransformFilter *pTransformFilter,
 796     __inout HRESULT * phr,
 797     __in_opt LPCWSTR pPinName)
 798     : CBaseOutputPin(pObjectName, pTransformFilter, &amp;pTransformFilter-&gt;m_csFilter, phr, pPinName),
 799       m_pPosition(NULL)
 800 {
 801     DbgLog((LOG_TRACE,2,TEXT(&quot;CTransformOutputPin::CTransformOutputPin&quot;)));
 802     m_pTransformFilter = pTransformFilter;
 803 
 804 }
 805 
 806 #ifdef UNICODE
 807 CTransformOutputPin::CTransformOutputPin(
 808     __in_opt LPCSTR pObjectName,
 809     __inout CTransformFilter *pTransformFilter,
 810     __inout HRESULT * phr,
 811     __in_opt LPCWSTR pPinName)
 812     : CBaseOutputPin(pObjectName, pTransformFilter, &amp;pTransformFilter-&gt;m_csFilter, phr, pPinName),
 813       m_pPosition(NULL)
 814 {
 815     DbgLog((LOG_TRACE,2,TEXT(&quot;CTransformOutputPin::CTransformOutputPin&quot;)));
 816     m_pTransformFilter = pTransformFilter;
 817 
 818 }
 819 #endif
 820 
 821 // destructor
 822 
 823 CTransformOutputPin::~CTransformOutputPin()
 824 {
 825     DbgLog((LOG_TRACE,2,TEXT(&quot;CTransformOutputPin::~CTransformOutputPin&quot;)));
 826 
 827     if (m_pPosition) m_pPosition-&gt;Release();
 828 }
 829 
 830 
 831 // overriden to expose IMediaPosition and IMediaSeeking control interfaces
 832 
 833 STDMETHODIMP
 834 CTransformOutputPin::NonDelegatingQueryInterface(REFIID riid, __deref_out void **ppv)
 835 {
 836     CheckPointer(ppv,E_POINTER);
 837     ValidateReadWritePtr(ppv,sizeof(PVOID));
 838     *ppv = NULL;
 839 
 840     if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking) {
 841 
 842         // we should have an input pin by now
 843 
 844         ASSERT(m_pTransformFilter-&gt;m_pInput != NULL);
 845 
 846         if (m_pPosition == NULL) {
 847 
 848             HRESULT hr = CreatePosPassThru(
 849                              GetOwner(),
 850                              FALSE,
 851                              (IPin *)m_pTransformFilter-&gt;m_pInput,
 852                              &amp;m_pPosition);
 853             if (FAILED(hr)) {
 854                 return hr;
 855             }
 856         }
 857         return m_pPosition-&gt;QueryInterface(riid, ppv);
 858     } else {
 859         return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
 860     }
 861 }
 862 
 863 
 864 // provides derived filter a chance to grab extra interfaces
 865 
 866 HRESULT
 867 CTransformOutputPin::CheckConnect(IPin *pPin)
 868 {
 869     // we should have an input connection first
 870 
 871     ASSERT(m_pTransformFilter-&gt;m_pInput != NULL);
 872     if ((m_pTransformFilter-&gt;m_pInput-&gt;IsConnected() == FALSE)) {
 873         return E_UNEXPECTED;
 874     }
 875 
 876     HRESULT hr = m_pTransformFilter-&gt;CheckConnect(PINDIR_OUTPUT,pPin);
 877     if (FAILED(hr)) {
 878         return hr;
 879     }
 880     return CBaseOutputPin::CheckConnect(pPin);
 881 }
 882 
 883 
 884 // provides derived filter a chance to release it&#39;s extra interfaces
 885 
 886 HRESULT
 887 CTransformOutputPin::BreakConnect()
 888 {
 889     //  Can&#39;t disconnect unless stopped
 890     ASSERT(IsStopped());
 891     m_pTransformFilter-&gt;BreakConnect(PINDIR_OUTPUT);
 892     return CBaseOutputPin::BreakConnect();
 893 }
 894 
 895 
 896 // Let derived class know when the output pin is connected
 897 
 898 HRESULT
 899 CTransformOutputPin::CompleteConnect(IPin *pReceivePin)
 900 {
 901     HRESULT hr = m_pTransformFilter-&gt;CompleteConnect(PINDIR_OUTPUT,pReceivePin);
 902     if (FAILED(hr)) {
 903         return hr;
 904     }
 905     return CBaseOutputPin::CompleteConnect(pReceivePin);
 906 }
 907 
 908 
 909 // check a given transform - must have selected input type first
 910 
 911 HRESULT
 912 CTransformOutputPin::CheckMediaType(const CMediaType* pmtOut)
 913 {
 914     // must have selected input first
 915     ASSERT(m_pTransformFilter-&gt;m_pInput != NULL);
 916     if ((m_pTransformFilter-&gt;m_pInput-&gt;IsConnected() == FALSE)) {
 917             return E_INVALIDARG;
 918     }
 919 
 920     return m_pTransformFilter-&gt;CheckTransform(
 921                     &amp;m_pTransformFilter-&gt;m_pInput-&gt;CurrentMediaType(),
 922                     pmtOut);
 923 }
 924 
 925 
 926 // called after we have agreed a media type to actually set it in which case
 927 // we run the CheckTransform function to get the output format type again
 928 
 929 HRESULT
 930 CTransformOutputPin::SetMediaType(const CMediaType* pmtOut)
 931 {
 932     HRESULT hr = NOERROR;
 933     ASSERT(m_pTransformFilter-&gt;m_pInput != NULL);
 934 
 935     ASSERT(m_pTransformFilter-&gt;m_pInput-&gt;CurrentMediaType().IsValid());
 936 
 937     // Set the base class media type (should always succeed)
 938     hr = CBasePin::SetMediaType(pmtOut);
 939     if (FAILED(hr)) {
 940         return hr;
 941     }
 942 
 943 #ifdef DEBUG
 944     if (FAILED(m_pTransformFilter-&gt;CheckTransform(&amp;m_pTransformFilter-&gt;
 945                     m_pInput-&gt;CurrentMediaType(),pmtOut))) {
 946     DbgLog((LOG_ERROR,0,TEXT(&quot;*** This filter is accepting an output media type&quot;)));
 947     DbgLog((LOG_ERROR,0,TEXT(&quot;    that it can&#39;t currently transform to.  I hope&quot;)));
 948     DbgLog((LOG_ERROR,0,TEXT(&quot;    it&#39;s smart enough to reconnect its input.&quot;)));
 949     }
 950 #endif
 951 
 952     return m_pTransformFilter-&gt;SetMediaType(PINDIR_OUTPUT,pmtOut);
 953 }
 954 
 955 
 956 // pass the buffer size decision through to the main transform class
 957 
 958 HRESULT
 959 CTransformOutputPin::DecideBufferSize(
 960     IMemAllocator * pAllocator,
 961     __inout ALLOCATOR_PROPERTIES* pProp)
 962 {
 963     return m_pTransformFilter-&gt;DecideBufferSize(pAllocator, pProp);
 964 }
 965 
 966 
 967 
 968 // return a specific media type indexed by iPosition
 969 
 970 HRESULT
 971 CTransformOutputPin::GetMediaType(
 972     int iPosition,
 973     __inout CMediaType *pMediaType)
 974 {
 975     ASSERT(m_pTransformFilter-&gt;m_pInput != NULL);
 976 
 977     //  We don&#39;t have any media types if our input is not connected
 978 
 979     if (m_pTransformFilter-&gt;m_pInput-&gt;IsConnected()) {
 980         return m_pTransformFilter-&gt;GetMediaType(iPosition,pMediaType);
 981     } else {
 982         return VFW_S_NO_MORE_ITEMS;
 983     }
 984 }
 985 
 986 
 987 // Override this if you can do something constructive to act on the
 988 // quality message.  Consider passing it upstream as well
 989 
 990 // Pass the quality mesage on upstream.
 991 
 992 STDMETHODIMP
 993 CTransformOutputPin::Notify(IBaseFilter * pSender, Quality q)
 994 {
 995     UNREFERENCED_PARAMETER(pSender);
 996     ValidateReadPtr(pSender,sizeof(IBaseFilter));
 997 
 998     // First see if we want to handle this ourselves
 999     HRESULT hr = m_pTransformFilter-&gt;AlterQuality(q);
1000     if (hr!=S_FALSE) {
1001         return hr;        // either S_OK or a failure
1002     }
1003 
1004     // S_FALSE means we pass the message on.
1005     // Find the quality sink for our input pin and send it there
1006 
1007     ASSERT(m_pTransformFilter-&gt;m_pInput != NULL);
1008 
1009     return m_pTransformFilter-&gt;m_pInput-&gt;PassNotify(q);
1010 
1011 } // Notify
1012 
1013 
1014 // the following removes a very large number of level 4 warnings from the microsoft
1015 // compiler output, which are not useful at all in this case.
1016 #pragma warning(disable:4514)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/baseclasses/dllsetup.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 //------------------------------------------------------------------------------
  2 // File: DllSetup.cpp
  3 //
  4 // Desc: DirectShow base classes.
  5 //
  6 // Copyright (c) 1992-2001 Microsoft Corporation.  All rights reserved.
  7 //------------------------------------------------------------------------------
  8 
  9 
 10 #include &lt;streams.h&gt;
 11 #include &lt;strsafe.h&gt;
 12 
 13 //---------------------------------------------------------------------------
 14 // defines
 15 
 16 #define MAX_KEY_LEN  260
 17 
 18 
 19 //---------------------------------------------------------------------------
 20 // externally defined functions/variable
 21 
 22 extern int g_cTemplates;
 23 extern CFactoryTemplate g_Templates[];
 24 
 25 //---------------------------------------------------------------------------
 26 //
 27 // EliminateSubKey
 28 //
 29 // Try to enumerate all keys under this one.
 30 // if we find anything, delete it completely.
 31 // Otherwise just delete it.
 32 //
 33 // note - this was pinched/duplicated from
 34 // Filgraph\Mapper.cpp - so should it be in
 35 // a lib somewhere?
 36 //
 37 //---------------------------------------------------------------------------
 38 
 39 STDAPI
 40 EliminateSubKey( HKEY hkey, LPCTSTR strSubKey )
 41 {
 42   HKEY hk;
 43   if (0 == lstrlen(strSubKey) ) {
 44       // defensive approach
 45       return E_FAIL;
 46   }
 47 
 48   LONG lreturn = RegOpenKeyEx( hkey
 49                              , strSubKey
 50                              , 0
 51                              , MAXIMUM_ALLOWED
 52                              , &amp;hk );
 53 
 54   ASSERT(    lreturn == ERROR_SUCCESS
 55           || lreturn == ERROR_FILE_NOT_FOUND
 56           || lreturn == ERROR_INVALID_HANDLE );
 57 
 58   if( ERROR_SUCCESS == lreturn )
 59   {
 60     // Keep on enumerating the first (zero-th)
 61     // key and deleting that
 62 
 63     for( ; ; )
 64     {
 65       TCHAR Buffer[MAX_KEY_LEN];
 66       DWORD dw = MAX_KEY_LEN;
 67       FILETIME ft;
 68 
 69       lreturn = RegEnumKeyEx( hk
 70                             , 0
 71                             , Buffer
 72                             , &amp;dw
 73                             , NULL
 74                             , NULL
 75                             , NULL
 76                             , &amp;ft);
 77 
 78       ASSERT(    lreturn == ERROR_SUCCESS
 79               || lreturn == ERROR_NO_MORE_ITEMS );
 80 
 81       if( ERROR_SUCCESS == lreturn )
 82       {
 83         EliminateSubKey(hk, Buffer);
 84       }
 85       else
 86       {
 87         break;
 88       }
 89     }
 90 
 91     RegCloseKey(hk);
 92     RegDeleteKey(hkey, strSubKey);
 93   }
 94 
 95   return NOERROR;
 96 }
 97 
 98 
 99 //---------------------------------------------------------------------------
100 //
101 // AMovieSetupRegisterServer()
102 //
103 // registers specfied file &quot;szFileName&quot; as server for
104 // CLSID &quot;clsServer&quot;.  A description is also required.
105 // The ThreadingModel and ServerType are optional, as
106 // they default to InprocServer32 (i.e. dll) and Both.
107 //
108 //---------------------------------------------------------------------------
109 
110 STDAPI
111 AMovieSetupRegisterServer( CLSID   clsServer
112                          , LPCWSTR szDescription
113                          , LPCWSTR szFileName
114                          , LPCWSTR szThreadingModel = L&quot;Both&quot;
115                          , LPCWSTR szServerType     = L&quot;InprocServer32&quot; )
116 {
117   // temp buffer
118   //
119   TCHAR achTemp[MAX_PATH];
120 
121   // convert CLSID uuid to string and write
122   // out subkey as string - CLSID\{}
123   //
124   OLECHAR szCLSID[CHARS_IN_GUID];
125   HRESULT hr = StringFromGUID2( clsServer
126                               , szCLSID
127                               , CHARS_IN_GUID );
128   ASSERT( SUCCEEDED(hr) );
129 
130   // create key
131   //
132   HKEY hkey;
133   (void)StringCchPrintf( achTemp, NUMELMS(achTemp), TEXT(&quot;CLSID\\%ls&quot;), szCLSID );
134   LONG lreturn = RegCreateKey( HKEY_CLASSES_ROOT
135                              , (LPCTSTR)achTemp
136                              , &amp;hkey              );
137   if( ERROR_SUCCESS != lreturn )
138   {
139     return AmHresultFromWin32(lreturn);
140   }
141 
142   // set description string
143   //
144 
145   (void)StringCchPrintf( achTemp, NUMELMS(achTemp), TEXT(&quot;%ls&quot;), szDescription );
146   lreturn = RegSetValue( hkey
147                        , (LPCTSTR)NULL
148                        , REG_SZ
149                        , achTemp
150                        , sizeof(achTemp) );
151   if( ERROR_SUCCESS != lreturn )
152   {
153     RegCloseKey( hkey );
154     return AmHresultFromWin32(lreturn);
155   }
156 
157   // create CLSID\\{&quot;CLSID&quot;}\\&quot;ServerType&quot; key,
158   // using key to CLSID\\{&quot;CLSID&quot;} passed back by
159   // last call to RegCreateKey().
160   //
161   HKEY hsubkey;
162 
163   (void)StringCchPrintf( achTemp, NUMELMS(achTemp), TEXT(&quot;%ls&quot;), szServerType );
164   lreturn = RegCreateKey( hkey
165                         , achTemp
166                         , &amp;hsubkey     );
167   if( ERROR_SUCCESS != lreturn )
168   {
169     RegCloseKey( hkey );
170     return AmHresultFromWin32(lreturn);
171   }
172 
173   // set Server string
174   //
175   (void)StringCchPrintf( achTemp, NUMELMS(achTemp), TEXT(&quot;%ls&quot;), szFileName );
176   lreturn = RegSetValue( hsubkey
177                        , (LPCTSTR)NULL
178                        , REG_SZ
179                        , (LPCTSTR)achTemp
180                        , sizeof(TCHAR) * (lstrlen(achTemp)+1) );
181   if( ERROR_SUCCESS != lreturn )
182   {
183     RegCloseKey( hkey );
184     RegCloseKey( hsubkey );
185     return AmHresultFromWin32(lreturn);
186   }
187 
188   (void)StringCchPrintf( achTemp, NUMELMS(achTemp), TEXT(&quot;%ls&quot;), szThreadingModel );
189   lreturn = RegSetValueEx( hsubkey
190                          , TEXT(&quot;ThreadingModel&quot;)
191                          , 0L
192                          , REG_SZ
193                          , (CONST BYTE *)achTemp
194                          , sizeof(TCHAR) * (lstrlen(achTemp)+1) );
195 
196   // close hkeys
197   //
198   RegCloseKey( hkey );
199   RegCloseKey( hsubkey );
200 
201   // and return
202   //
203   return HRESULT_FROM_WIN32(lreturn);
204 
205 }
206 
207 
208 //---------------------------------------------------------------------------
209 //
210 // AMovieSetupUnregisterServer()
211 //
212 // default ActiveMovie dll setup function
213 // - to use must be called from an exported
214 //   function named DllRegisterServer()
215 //
216 //---------------------------------------------------------------------------
217 
218 STDAPI
219 AMovieSetupUnregisterServer( CLSID clsServer )
220 {
221   // convert CLSID uuid to string and write
222   // out subkey CLSID\{}
223   //
224   OLECHAR szCLSID[CHARS_IN_GUID];
225   HRESULT hr = StringFromGUID2( clsServer
226                               , szCLSID
227                               , CHARS_IN_GUID );
228   ASSERT( SUCCEEDED(hr) );
229 
230   TCHAR achBuffer[MAX_KEY_LEN];
231   (void)StringCchPrintf( achBuffer, NUMELMS(achBuffer), TEXT(&quot;CLSID\\%ls&quot;), szCLSID );
232 
233   // delete subkey
234   //
235 
236   hr = EliminateSubKey( HKEY_CLASSES_ROOT, achBuffer );
237   ASSERT( SUCCEEDED(hr) );
238 
239   // return
240   //
241   return NOERROR;
242 }
243 
244 
245 //---------------------------------------------------------------------------
246 //
247 // AMovieSetupRegisterFilter through IFilterMapper2
248 //
249 //---------------------------------------------------------------------------
250 
251 STDAPI
252 AMovieSetupRegisterFilter2( const AMOVIESETUP_FILTER * const psetupdata
253                           , IFilterMapper2 *                 pIFM2
254                           , BOOL                             bRegister  )
255 {
256   DbgLog((LOG_TRACE, 3, TEXT(&quot;= AMovieSetupRegisterFilter&quot;)));
257 
258   // check we&#39;ve got data
259   //
260   if( NULL == psetupdata ) return S_FALSE;
261 
262 
263   // unregister filter
264   // (as pins are subkeys of filter&#39;s CLSID key
265   // they do not need to be removed separately).
266   //
267   DbgLog((LOG_TRACE, 3, TEXT(&quot;= = unregister filter&quot;)));
268   HRESULT hr = pIFM2-&gt;UnregisterFilter(
269       0,                        // default category
270       0,                        // default instance name
271       *psetupdata-&gt;clsID );
272 
273 
274   if( bRegister )
275   {
276     REGFILTER2 rf2;
277     rf2.dwVersion = 1;
278     rf2.dwMerit = psetupdata-&gt;dwMerit;
279     rf2.cPins = psetupdata-&gt;nPins;
280     rf2.rgPins = psetupdata-&gt;lpPin;
281 
282     // register filter
283     //
284     DbgLog((LOG_TRACE, 3, TEXT(&quot;= = register filter&quot;)));
285     hr = pIFM2-&gt;RegisterFilter(*psetupdata-&gt;clsID
286                              , psetupdata-&gt;strName
287                              , 0 // moniker
288                              , 0 // category
289                              , NULL // instance
290                              , &amp;rf2);
291   }
292 
293   // handle one acceptable &quot;error&quot; - that
294   // of filter not being registered!
295   // (couldn&#39;t find a suitable #define&#39;d
296   // name for the error!)
297   //
298   if( 0x80070002 == hr)
299     return NOERROR;
300   else
301     return hr;
302 }
303 
304 
305 //---------------------------------------------------------------------------
306 //
307 // RegisterAllServers()
308 //
309 //---------------------------------------------------------------------------
310 
311 STDAPI
312 RegisterAllServers( LPCWSTR szFileName, BOOL bRegister )
313 {
314   HRESULT hr = NOERROR;
315 
316   for( int i = 0; i &lt; g_cTemplates; i++ )
317   {
318     // get i&#39;th template
319     //
320     const CFactoryTemplate *pT = &amp;g_Templates[i];
321 
322     DbgLog((LOG_TRACE, 2, TEXT(&quot;- - register %ls&quot;),
323            (LPCWSTR)pT-&gt;m_Name ));
324 
325     // register CLSID and InprocServer32
326     //
327     if( bRegister )
328     {
329       hr = AMovieSetupRegisterServer( *(pT-&gt;m_ClsID)
330                                     , (LPCWSTR)pT-&gt;m_Name
331                                     , szFileName );
332     }
333     else
334     {
335       hr = AMovieSetupUnregisterServer( *(pT-&gt;m_ClsID) );
336     }
337 
338     // check final error for this pass
339     // and break loop if we failed
340     //
341     if( FAILED(hr) )
342       break;
343   }
344 
345   return hr;
346 }
347 
348 
349 //---------------------------------------------------------------------------
350 //
351 // AMovieDllRegisterServer2()
352 //
353 // default ActiveMovie dll setup function
354 // - to use must be called from an exported
355 //   function named DllRegisterServer()
356 //
357 // this function is table driven using the
358 // static members of the CFactoryTemplate
359 // class defined in the dll.
360 //
361 // it registers the Dll as the InprocServer32
362 // and then calls the IAMovieSetup.Register
363 // method.
364 //
365 //---------------------------------------------------------------------------
366 
367 STDAPI
368 AMovieDllRegisterServer2( BOOL bRegister )
369 {
370   HRESULT hr = NOERROR;
371 
372   DbgLog((LOG_TRACE, 2, TEXT(&quot;AMovieDllRegisterServer2()&quot;)));
373 
374   // get file name (where g_hInst is the
375   // instance handle of the filter dll)
376   //
377   WCHAR achFileName[MAX_PATH];
378 
379   // WIN95 doesn&#39;t support GetModuleFileNameW
380   //
381   {
382     char achTemp[MAX_PATH];
383 
384     DbgLog((LOG_TRACE, 2, TEXT(&quot;- get module file name&quot;)));
385 
386     // g_hInst handle is set in our dll entry point. Make sure
387     // DllEntryPoint in dllentry.cpp is called
388     ASSERT(g_hInst != 0);
389 
390     if( 0 == GetModuleFileNameA( g_hInst
391                               , achTemp
392                               , sizeof(achTemp) ) )
393     {
394       // we&#39;ve failed!
395       DWORD dwerr = GetLastError();
396       return AmHresultFromWin32(dwerr);
397     }
398 
399     MultiByteToWideChar( CP_ACP
400                        , 0L
401                        , achTemp
402                        , lstrlenA(achTemp) + 1
403                        , achFileName
404                        , NUMELMS(achFileName) );
405   }
406 
407   //
408   // first registering, register all OLE servers
409   //
410   if( bRegister )
411   {
412     DbgLog((LOG_TRACE, 2, TEXT(&quot;- register OLE Servers&quot;)));
413     hr = RegisterAllServers( achFileName, TRUE );
414   }
415 
416   //
417   // next, register/unregister all filters
418   //
419 
420   if( SUCCEEDED(hr) )
421   {
422     // init is ref counted so call just in case
423     // we&#39;re being called cold.
424     //
425     DbgLog((LOG_TRACE, 2, TEXT(&quot;- CoInitialize&quot;)));
426     hr = CoInitialize( (LPVOID)NULL );
427     ASSERT( SUCCEEDED(hr) );
428 
429     // get hold of IFilterMapper2
430     //
431     DbgLog((LOG_TRACE, 2, TEXT(&quot;- obtain IFilterMapper2&quot;)));
432     IFilterMapper2 *pIFM2 = 0;
433     IFilterMapper *pIFM = 0;
434     hr = CoCreateInstance( CLSID_FilterMapper2
435                          , NULL
436                          , CLSCTX_INPROC_SERVER
437                          , IID_IFilterMapper2
438                          , (void **)&amp;pIFM2       );
439     if(FAILED(hr))
440     {
441         DbgLog((LOG_TRACE, 2, TEXT(&quot;- trying IFilterMapper instead&quot;)));
442 
443         hr = CoCreateInstance(
444             CLSID_FilterMapper,
445             NULL,
446             CLSCTX_INPROC_SERVER,
447             IID_IFilterMapper,
448             (void **)&amp;pIFM);
449     }
450     if( SUCCEEDED(hr) )
451     {
452       // scan through array of CFactoryTemplates
453       // registering servers and filters.
454       //
455       DbgLog((LOG_TRACE, 2, TEXT(&quot;- register Filters&quot;)));
456       for( int i = 0; i &lt; g_cTemplates; i++ )
457       {
458         // get i&#39;th template
459         //
460         const CFactoryTemplate *pT = &amp;g_Templates[i];
461 
462         if( NULL != pT-&gt;m_pAMovieSetup_Filter )
463         {
464           DbgLog((LOG_TRACE, 2, TEXT(&quot;- - register %ls&quot;), (LPCWSTR)pT-&gt;m_Name ));
465 
466           if(pIFM2)
467           {
468               hr = AMovieSetupRegisterFilter2( pT-&gt;m_pAMovieSetup_Filter, pIFM2, bRegister );
469           }
470           else
471           {
472               hr = AMovieSetupRegisterFilter( pT-&gt;m_pAMovieSetup_Filter, pIFM, bRegister );
473           }
474         }
475 
476         // check final error for this pass
477         // and break loop if we failed
478         //
479         if( FAILED(hr) )
480           break;
481       }
482 
483       // release interface
484       //
485       if(pIFM2)
486           pIFM2-&gt;Release();
487       else
488           pIFM-&gt;Release();
489 
490     }
491 
492     // and clear up
493     //
494     CoFreeUnusedLibraries();
495     CoUninitialize();
496   }
497 
498   //
499   // if unregistering, unregister all OLE servers
500   //
501   if( SUCCEEDED(hr) &amp;&amp; !bRegister )
502   {
503     DbgLog((LOG_TRACE, 2, TEXT(&quot;- register OLE Servers&quot;)));
504     hr = RegisterAllServers( achFileName, FALSE );
505   }
506 
507   DbgLog((LOG_TRACE, 2, TEXT(&quot;- return %0x&quot;), hr));
508   return hr;
509 }
510 
511 
512 //---------------------------------------------------------------------------
513 //
514 // AMovieDllRegisterServer()
515 //
516 // default ActiveMovie dll setup function
517 // - to use must be called from an exported
518 //   function named DllRegisterServer()
519 //
520 // this function is table driven using the
521 // static members of the CFactoryTemplate
522 // class defined in the dll.
523 //
524 // it registers the Dll as the InprocServer32
525 // and then calls the IAMovieSetup.Register
526 // method.
527 //
528 //---------------------------------------------------------------------------
529 
530 
531 STDAPI
532 AMovieDllRegisterServer( void )
533 {
534   HRESULT hr = NOERROR;
535 
536   // get file name (where g_hInst is the
537   // instance handle of the filter dll)
538   //
539   WCHAR achFileName[MAX_PATH];
540 
541   {
542     // WIN95 doesn&#39;t support GetModuleFileNameW
543     //
544     char achTemp[MAX_PATH];
545 
546     if( 0 == GetModuleFileNameA( g_hInst
547                               , achTemp
548                               , sizeof(achTemp) ) )
549     {
550       // we&#39;ve failed!
551       DWORD dwerr = GetLastError();
552       return AmHresultFromWin32(dwerr);
553     }
554 
555     MultiByteToWideChar( CP_ACP
556                        , 0L
557                        , achTemp
558                        , lstrlenA(achTemp) + 1
559                        , achFileName
560                        , NUMELMS(achFileName) );
561   }
562 
563   // scan through array of CFactoryTemplates
564   // registering servers and filters.
565   //
566   for( int i = 0; i &lt; g_cTemplates; i++ )
567   {
568     // get i&#39;th template
569     //
570     const CFactoryTemplate *pT = &amp;g_Templates[i];
571 
572     // register CLSID and InprocServer32
573     //
574     hr = AMovieSetupRegisterServer( *(pT-&gt;m_ClsID)
575                                   , (LPCWSTR)pT-&gt;m_Name
576                                   , achFileName );
577 
578     // instantiate all servers and get hold of
579     // IAMovieSetup, if implemented, and call
580     // IAMovieSetup.Register() method
581     //
582     if( SUCCEEDED(hr) &amp;&amp; (NULL != pT-&gt;m_lpfnNew) )
583     {
584       // instantiate object
585       //
586       PAMOVIESETUP psetup;
587       hr = CoCreateInstance( *(pT-&gt;m_ClsID)
588                            , 0
589                            , CLSCTX_INPROC_SERVER
590                            , IID_IAMovieSetup
591                            , reinterpret_cast&lt;void**&gt;(&amp;psetup) );
592       if( SUCCEEDED(hr) )
593       {
594         hr = psetup-&gt;Unregister();
595         if( SUCCEEDED(hr) )
596           hr = psetup-&gt;Register();
597         psetup-&gt;Release();
598       }
599       else
600       {
601         if(    (E_NOINTERFACE      == hr )
602             || (VFW_E_NEED_OWNER == hr ) )
603           hr = NOERROR;
604       }
605     }
606 
607     // check final error for this pass
608     // and break loop if we failed
609     //
610     if( FAILED(hr) )
611       break;
612 
613   } // end-for
614 
615   return hr;
616 }
617 
618 
619 //---------------------------------------------------------------------------
620 //
621 // AMovieDllUnregisterServer()
622 //
623 // default ActiveMovie dll uninstall function
624 // - to use must be called from an exported
625 //   function named DllRegisterServer()
626 //
627 // this function is table driven using the
628 // static members of the CFactoryTemplate
629 // class defined in the dll.
630 //
631 // it calls the IAMovieSetup.Unregister
632 // method and then unregisters the Dll
633 // as the InprocServer32
634 //
635 //---------------------------------------------------------------------------
636 
637 STDAPI
638 AMovieDllUnregisterServer()
639 {
640   // initialize return code
641   //
642   HRESULT hr = NOERROR;
643 
644   // scan through CFactory template and unregister
645   // all OLE servers and filters.
646   //
647   for( int i = g_cTemplates; i--; )
648   {
649     // get i&#39;th template
650     //
651     const CFactoryTemplate *pT = &amp;g_Templates[i];
652 
653     // check method exists
654     //
655     if( NULL != pT-&gt;m_lpfnNew )
656     {
657       // instantiate object
658       //
659       PAMOVIESETUP psetup;
660       hr = CoCreateInstance( *(pT-&gt;m_ClsID)
661                            , 0
662                            , CLSCTX_INPROC_SERVER
663                            , IID_IAMovieSetup
664                            , reinterpret_cast&lt;void**&gt;(&amp;psetup) );
665       if( SUCCEEDED(hr) )
666       {
667         hr = psetup-&gt;Unregister();
668         psetup-&gt;Release();
669       }
670       else
671       {
672         if(    (E_NOINTERFACE      == hr )
673             || (VFW_E_NEED_OWNER == hr ) )
674            hr = NOERROR;
675       }
676     }
677 
678     // unregister CLSID and InprocServer32
679     //
680     if( SUCCEEDED(hr) )
681     {
682       hr = AMovieSetupUnregisterServer( *(pT-&gt;m_ClsID) );
683     }
684 
685     // check final error for this pass
686     // and break loop if we failed
687     //
688     if( FAILED(hr) )
689       break;
690   }
691 
692   return hr;
693 }
    </pre>
  </body>
</html>
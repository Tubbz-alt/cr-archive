<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/libffi/src/raw_api.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="prep_cif.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="types.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/libffi/src/raw_api.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12    the following conditions:
 13 
 14    The above copyright notice and this permission notice shall be included
 15    in all copies or substantial portions of the Software.
 16 
 17    THE SOFTWARE IS PROVIDED ``AS IS&#39;&#39;, WITHOUT WARRANTY OF ANY KIND,
 18    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 19    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 20    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 21    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 22    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 23    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 24    DEALINGS IN THE SOFTWARE.
 25    ----------------------------------------------------------------------- */
 26 
 27 /* This file defines generic functions for use with the raw api. */
 28 
 29 #include &lt;ffi.h&gt;
 30 #include &lt;ffi_common.h&gt;
 31 




 32 #if !FFI_NO_RAW_API
 33 
 34 size_t
 35 ffi_raw_size (ffi_cif *cif)
 36 {
 37   size_t result = 0;
 38   int i;
 39 
 40   ffi_type **at = cif-&gt;arg_types;
 41 
 42   for (i = cif-&gt;nargs-1; i &gt;= 0; i--, at++)
 43     {
 44 #if !FFI_NO_STRUCTS
 45       if ((*at)-&gt;type == FFI_TYPE_STRUCT)
<span class="line-modified"> 46     result += ALIGN (sizeof (void*), FFI_SIZEOF_ARG);</span>
 47       else
 48 #endif
<span class="line-modified"> 49     result += ALIGN ((*at)-&gt;size, FFI_SIZEOF_ARG);</span>
 50     }
 51 
 52   return result;
 53 }
 54 
 55 
 56 void
 57 ffi_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args)
 58 {
 59   unsigned i;
 60   ffi_type **tp = cif-&gt;arg_types;
 61 
 62 #if WORDS_BIGENDIAN
 63 
 64   for (i = 0; i &lt; cif-&gt;nargs; i++, tp++, args++)
 65     {
 66       switch ((*tp)-&gt;type)
 67     {
 68     case FFI_TYPE_UINT8:
 69     case FFI_TYPE_SINT8:
</pre>
<hr />
<pre>
 81       *args = (void*) ((char*)(raw++) + FFI_SIZEOF_ARG - 4);
 82       break;
 83 #endif
 84 
 85 #if !FFI_NO_STRUCTS
 86     case FFI_TYPE_STRUCT:
 87       *args = (raw++)-&gt;ptr;
 88       break;
 89 #endif
 90 
 91     case FFI_TYPE_COMPLEX:
 92       *args = (raw++)-&gt;ptr;
 93       break;
 94 
 95     case FFI_TYPE_POINTER:
 96       *args = (void*) &amp;(raw++)-&gt;ptr;
 97       break;
 98 
 99     default:
100       *args = raw;
<span class="line-modified">101       raw += ALIGN ((*tp)-&gt;size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;</span>
102     }
103     }
104 
105 #else /* WORDS_BIGENDIAN */
106 
107 #if !PDP
108 
109   /* then assume little endian */
110   for (i = 0; i &lt; cif-&gt;nargs; i++, tp++, args++)
111     {
112 #if !FFI_NO_STRUCTS
113       if ((*tp)-&gt;type == FFI_TYPE_STRUCT)
114     {
115       *args = (raw++)-&gt;ptr;
116     }
117       else
118 #endif
119       if ((*tp)-&gt;type == FFI_TYPE_COMPLEX)
120     {
121       *args = (raw++)-&gt;ptr;
122     }
123       else
124     {
125       *args = (void*) raw;
<span class="line-modified">126       raw += ALIGN ((*tp)-&gt;size, sizeof (void*)) / sizeof (void*);</span>
127     }
128     }
129 
130 #else
131 #error &quot;pdp endian not supported&quot;
132 #endif /* ! PDP */
133 
134 #endif /* WORDS_BIGENDIAN */
135 }
136 
137 void
138 ffi_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw)
139 {
140   unsigned i;
141   ffi_type **tp = cif-&gt;arg_types;
142 
143   for (i = 0; i &lt; cif-&gt;nargs; i++, tp++, args++)
144     {
145       switch ((*tp)-&gt;type)
146     {
</pre>
<hr />
<pre>
169       (raw++)-&gt;sint = *(SINT32*) (*args);
170       break;
171 #endif
172 
173 #if !FFI_NO_STRUCTS
174     case FFI_TYPE_STRUCT:
175       (raw++)-&gt;ptr = *args;
176       break;
177 #endif
178 
179     case FFI_TYPE_COMPLEX:
180       (raw++)-&gt;ptr = *args;
181       break;
182 
183     case FFI_TYPE_POINTER:
184       (raw++)-&gt;ptr = **(void***) args;
185       break;
186 
187     default:
188       memcpy ((void*) raw-&gt;data, (void*)*args, (*tp)-&gt;size);
<span class="line-modified">189       raw += ALIGN ((*tp)-&gt;size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;</span>
190     }
191     }
192 }
193 
194 #if !FFI_NATIVE_RAW_API
195 
196 
197 /* This is a generic definition of ffi_raw_call, to be used if the
198  * native system does not provide a machine-specific implementation.
199  * Having this, allows code to be written for the raw API, without
200  * the need for system-specific code to handle input in that format;
201  * these following couple of functions will handle the translation forth
202  * and back automatically. */
203 
204 void ffi_raw_call (ffi_cif *cif, void (*fn)(void), void *rvalue, ffi_raw *raw)
205 {
206   void **avalue = (void**) alloca (cif-&gt;nargs * sizeof (void*));
207   ffi_raw_to_ptrarray (cif, raw, avalue);
208   ffi_call (cif, fn, rvalue, avalue);
209 }
</pre>
</td>
<td>
<hr />
<pre>
 12    the following conditions:
 13 
 14    The above copyright notice and this permission notice shall be included
 15    in all copies or substantial portions of the Software.
 16 
 17    THE SOFTWARE IS PROVIDED ``AS IS&#39;&#39;, WITHOUT WARRANTY OF ANY KIND,
 18    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 19    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 20    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 21    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 22    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 23    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 24    DEALINGS IN THE SOFTWARE.
 25    ----------------------------------------------------------------------- */
 26 
 27 /* This file defines generic functions for use with the raw api. */
 28 
 29 #include &lt;ffi.h&gt;
 30 #include &lt;ffi_common.h&gt;
 31 
<span class="line-added"> 32 #ifdef GSTREAMER_LITE</span>
<span class="line-added"> 33 #include &lt;string.h&gt;</span>
<span class="line-added"> 34 #endif // GSTREAMER_LITE</span>
<span class="line-added"> 35 </span>
 36 #if !FFI_NO_RAW_API
 37 
 38 size_t
 39 ffi_raw_size (ffi_cif *cif)
 40 {
 41   size_t result = 0;
 42   int i;
 43 
 44   ffi_type **at = cif-&gt;arg_types;
 45 
 46   for (i = cif-&gt;nargs-1; i &gt;= 0; i--, at++)
 47     {
 48 #if !FFI_NO_STRUCTS
 49       if ((*at)-&gt;type == FFI_TYPE_STRUCT)
<span class="line-modified"> 50     result += FFI_ALIGN (sizeof (void*), FFI_SIZEOF_ARG);</span>
 51       else
 52 #endif
<span class="line-modified"> 53     result += FFI_ALIGN ((*at)-&gt;size, FFI_SIZEOF_ARG);</span>
 54     }
 55 
 56   return result;
 57 }
 58 
 59 
 60 void
 61 ffi_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args)
 62 {
 63   unsigned i;
 64   ffi_type **tp = cif-&gt;arg_types;
 65 
 66 #if WORDS_BIGENDIAN
 67 
 68   for (i = 0; i &lt; cif-&gt;nargs; i++, tp++, args++)
 69     {
 70       switch ((*tp)-&gt;type)
 71     {
 72     case FFI_TYPE_UINT8:
 73     case FFI_TYPE_SINT8:
</pre>
<hr />
<pre>
 85       *args = (void*) ((char*)(raw++) + FFI_SIZEOF_ARG - 4);
 86       break;
 87 #endif
 88 
 89 #if !FFI_NO_STRUCTS
 90     case FFI_TYPE_STRUCT:
 91       *args = (raw++)-&gt;ptr;
 92       break;
 93 #endif
 94 
 95     case FFI_TYPE_COMPLEX:
 96       *args = (raw++)-&gt;ptr;
 97       break;
 98 
 99     case FFI_TYPE_POINTER:
100       *args = (void*) &amp;(raw++)-&gt;ptr;
101       break;
102 
103     default:
104       *args = raw;
<span class="line-modified">105       raw += FFI_ALIGN ((*tp)-&gt;size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;</span>
106     }
107     }
108 
109 #else /* WORDS_BIGENDIAN */
110 
111 #if !PDP
112 
113   /* then assume little endian */
114   for (i = 0; i &lt; cif-&gt;nargs; i++, tp++, args++)
115     {
116 #if !FFI_NO_STRUCTS
117       if ((*tp)-&gt;type == FFI_TYPE_STRUCT)
118     {
119       *args = (raw++)-&gt;ptr;
120     }
121       else
122 #endif
123       if ((*tp)-&gt;type == FFI_TYPE_COMPLEX)
124     {
125       *args = (raw++)-&gt;ptr;
126     }
127       else
128     {
129       *args = (void*) raw;
<span class="line-modified">130       raw += FFI_ALIGN ((*tp)-&gt;size, sizeof (void*)) / sizeof (void*);</span>
131     }
132     }
133 
134 #else
135 #error &quot;pdp endian not supported&quot;
136 #endif /* ! PDP */
137 
138 #endif /* WORDS_BIGENDIAN */
139 }
140 
141 void
142 ffi_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw)
143 {
144   unsigned i;
145   ffi_type **tp = cif-&gt;arg_types;
146 
147   for (i = 0; i &lt; cif-&gt;nargs; i++, tp++, args++)
148     {
149       switch ((*tp)-&gt;type)
150     {
</pre>
<hr />
<pre>
173       (raw++)-&gt;sint = *(SINT32*) (*args);
174       break;
175 #endif
176 
177 #if !FFI_NO_STRUCTS
178     case FFI_TYPE_STRUCT:
179       (raw++)-&gt;ptr = *args;
180       break;
181 #endif
182 
183     case FFI_TYPE_COMPLEX:
184       (raw++)-&gt;ptr = *args;
185       break;
186 
187     case FFI_TYPE_POINTER:
188       (raw++)-&gt;ptr = **(void***) args;
189       break;
190 
191     default:
192       memcpy ((void*) raw-&gt;data, (void*)*args, (*tp)-&gt;size);
<span class="line-modified">193       raw += FFI_ALIGN ((*tp)-&gt;size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;</span>
194     }
195     }
196 }
197 
198 #if !FFI_NATIVE_RAW_API
199 
200 
201 /* This is a generic definition of ffi_raw_call, to be used if the
202  * native system does not provide a machine-specific implementation.
203  * Having this, allows code to be written for the raw API, without
204  * the need for system-specific code to handle input in that format;
205  * these following couple of functions will handle the translation forth
206  * and back automatically. */
207 
208 void ffi_raw_call (ffi_cif *cif, void (*fn)(void), void *rvalue, ffi_raw *raw)
209 {
210   void **avalue = (void**) alloca (cif-&gt;nargs * sizeof (void*));
211   ffi_raw_to_ptrarray (cif, raw, avalue);
212   ffi_call (cif, fn, rvalue, avalue);
213 }
</pre>
</td>
</tr>
</table>
<center><a href="prep_cif.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="types.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
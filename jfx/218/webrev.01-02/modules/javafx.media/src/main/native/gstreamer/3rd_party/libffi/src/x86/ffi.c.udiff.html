<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.media/src/main/native/gstreamer/3rd_party/libffi/src/x86/ffi.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../types.c.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ffi64.c.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/libffi/src/x86/ffi.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,8 @@</span>
  /* -----------------------------------------------------------------------
<span class="udiff-line-modified-removed">-    ffi.c - Copyright (c) 1996, 1998, 1999, 2001, 2007, 2008  Red Hat, Inc.</span>
<span class="udiff-line-modified-added">+    ffi.c - Copyright (c) 2017  Anthony Green</span>
<span class="udiff-line-added">+            Copyright (c) 1996, 1998, 1999, 2001, 2007, 2008  Red Hat, Inc.</span>
             Copyright (c) 2002  Ranjit Mathew
             Copyright (c) 2002  Bo Thorsen
             Copyright (c) 2002  Roger Sayle
             Copyright (C) 2008, 2010  Free Software Foundation, Inc.
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -26,940 +27,735 @@</span>
     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
     DEALINGS IN THE SOFTWARE.
     ----------------------------------------------------------------------- */
  
<span class="udiff-line-modified-removed">- #if !defined(__x86_64__) || defined(_WIN64) || defined(__CYGWIN__)</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef _WIN64</span>
<span class="udiff-line-removed">- #include &lt;windows.h&gt;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+ #if defined(__i386__) || defined(_M_IX86)</span>
  #include &lt;ffi.h&gt;
  #include &lt;ffi_common.h&gt;
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+ #include &lt;stdint.h&gt;</span>
  #include &lt;stdlib.h&gt;
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- /* ffi_prep_args is called by the assembly routine once stack space</span>
<span class="udiff-line-modified-removed">-    has been allocated for the function&#39;s arguments */</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- unsigned int ffi_prep_args(char *stack, extended_cif *ecif);</span>
<span class="udiff-line-modified-removed">- unsigned int ffi_prep_args(char *stack, extended_cif *ecif)</span>
<span class="udiff-line-modified-removed">- {</span>
<span class="udiff-line-removed">-   register unsigned int i;</span>
<span class="udiff-line-removed">-   register void **p_argv;</span>
<span class="udiff-line-removed">-   register char *argp;</span>
<span class="udiff-line-removed">-   register ffi_type **p_arg;</span>
<span class="udiff-line-removed">- #ifndef X86_WIN64</span>
<span class="udiff-line-removed">-   const int cabi = ecif-&gt;cif-&gt;abi;</span>
<span class="udiff-line-removed">-   const int dir = (cabi == FFI_PASCAL || cabi == FFI_REGISTER) ? -1 : +1;</span>
<span class="udiff-line-removed">-   unsigned int stack_args_count = 0;</span>
<span class="udiff-line-removed">-   void *p_stack_data[3];</span>
<span class="udiff-line-removed">-   char *argp2 = stack;</span>
<span class="udiff-line-modified-added">+ #include &quot;internal.h&quot;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ /* Force FFI_TYPE_LONGDOUBLE to be different than FFI_TYPE_DOUBLE;</span>
<span class="udiff-line-modified-added">+    all further uses in this file will refer to the 80-bit type.  */</span>
<span class="udiff-line-modified-added">+ #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE</span>
<span class="udiff-line-modified-added">+ # if FFI_TYPE_LONGDOUBLE != 4</span>
<span class="udiff-line-modified-added">+ #  error FFI_TYPE_LONGDOUBLE out of date</span>
<span class="udiff-line-modified-added">+ # endif</span>
  #else
<span class="udiff-line-modified-removed">-   #define dir 1</span>
<span class="udiff-line-modified-added">+ # undef FFI_TYPE_LONGDOUBLE</span>
<span class="udiff-line-added">+ # define FFI_TYPE_LONGDOUBLE 4</span>
  #endif
  
<span class="udiff-line-modified-removed">-   argp = stack;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-   if ((ecif-&gt;cif-&gt;flags == FFI_TYPE_STRUCT</span>
<span class="udiff-line-removed">-        || ecif-&gt;cif-&gt;flags == FFI_TYPE_MS_STRUCT)</span>
<span class="udiff-line-removed">- #ifdef X86_WIN64</span>
<span class="udiff-line-removed">-       &amp;&amp; ((ecif-&gt;cif-&gt;rtype-&gt;size &amp; (1 | 2 | 4 | 8)) == 0)</span>
<span class="udiff-line-modified-added">+ #if defined(__GNUC__) &amp;&amp; !defined(__declspec)</span>
<span class="udiff-line-modified-added">+ # define __declspec(x)  __attribute__((x))</span>
  #endif
<span class="udiff-line-modified-removed">-       )</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">- #ifndef X86_WIN64</span>
<span class="udiff-line-modified-removed">-       /* For fastcall/thiscall/register this is first register-passed</span>
<span class="udiff-line-modified-removed">-          argument.  */</span>
<span class="udiff-line-modified-removed">-       if (cabi == FFI_THISCALL || cabi == FFI_FASTCALL || cabi == FFI_REGISTER)</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-           p_stack_data[stack_args_count] = argp;</span>
<span class="udiff-line-removed">-           ++stack_args_count;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ #if defined(_MSC_VER) &amp;&amp; defined(_M_IX86)</span>
<span class="udiff-line-modified-added">+ /* Stack is not 16-byte aligned on Windows.  */</span>
<span class="udiff-line-modified-added">+ #define STACK_ALIGN(bytes) (bytes)</span>
<span class="udiff-line-modified-added">+ #else</span>
<span class="udiff-line-modified-added">+ #define STACK_ALIGN(bytes) FFI_ALIGN (bytes, 16)</span>
  #endif
  
<span class="udiff-line-modified-removed">-       *(void **) argp = ecif-&gt;rvalue;</span>
<span class="udiff-line-modified-removed">-       argp += sizeof(void*);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+ /* Perform machine dependent cif processing.  */</span>
<span class="udiff-line-modified-added">+ ffi_status FFI_HIDDEN</span>
<span class="udiff-line-modified-added">+ ffi_prep_cif_machdep(ffi_cif *cif)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+   size_t bytes = 0;</span>
<span class="udiff-line-added">+   int i, n, flags, cabi = cif-&gt;abi;</span>
  
<span class="udiff-line-modified-removed">-   p_arg  = ecif-&gt;cif-&gt;arg_types;</span>
<span class="udiff-line-removed">-   p_argv = ecif-&gt;avalue;</span>
<span class="udiff-line-removed">-   if (dir &lt; 0)</span>
<span class="udiff-line-modified-added">+   switch (cabi)</span>
      {
<span class="udiff-line-modified-removed">-       const int nargs = ecif-&gt;cif-&gt;nargs - 1;</span>
<span class="udiff-line-modified-removed">-       if (nargs &gt; 0)</span>
<span class="udiff-line-modified-removed">-       {</span>
<span class="udiff-line-modified-removed">-         p_arg  += nargs;</span>
<span class="udiff-line-modified-removed">-         p_argv += nargs;</span>
<span class="udiff-line-modified-added">+     case FFI_SYSV:</span>
<span class="udiff-line-modified-added">+     case FFI_STDCALL:</span>
<span class="udiff-line-modified-added">+     case FFI_THISCALL:</span>
<span class="udiff-line-modified-added">+     case FFI_FASTCALL:</span>
<span class="udiff-line-modified-added">+     case FFI_MS_CDECL:</span>
<span class="udiff-line-added">+     case FFI_PASCAL:</span>
<span class="udiff-line-added">+     case FFI_REGISTER:</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     default:</span>
<span class="udiff-line-added">+       return FFI_BAD_ABI;</span>
        }
<span class="udiff-line-removed">-     }</span>
  
<span class="udiff-line-modified-removed">-   for (i = ecif-&gt;cif-&gt;nargs;</span>
<span class="udiff-line-removed">-        i != 0;</span>
<span class="udiff-line-removed">-        i--, p_arg += dir, p_argv += dir)</span>
<span class="udiff-line-modified-added">+   switch (cif-&gt;rtype-&gt;type)</span>
      {
<span class="udiff-line-modified-removed">- #ifdef GSTREAMER_LITE</span>
<span class="udiff-line-modified-removed">-       size_t z = 0;</span>
<span class="udiff-line-removed">- #endif // GSTREAMER_LITE</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       /* Align if necessary */</span>
<span class="udiff-line-removed">-       if ((sizeof(void*) - 1) &amp; (size_t) argp)</span>
<span class="udiff-line-removed">-         argp = (char *) ALIGN(argp, sizeof(void*));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef GSTREAMER_LITE</span>
<span class="udiff-line-removed">-       z = (*p_arg)-&gt;size;</span>
<span class="udiff-line-removed">- #else // GSTREAMER_LITE</span>
<span class="udiff-line-removed">-       size_t z = (*p_arg)-&gt;size;</span>
<span class="udiff-line-removed">- #endif // GSTREAMER_LITE</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef X86_WIN64</span>
<span class="udiff-line-removed">-       if (z &gt; FFI_SIZEOF_ARG</span>
<span class="udiff-line-removed">-           || ((*p_arg)-&gt;type == FFI_TYPE_STRUCT</span>
<span class="udiff-line-removed">-               &amp;&amp; (z &amp; (1 | 2 | 4 | 8)) == 0)</span>
<span class="udiff-line-removed">- #if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE</span>
<span class="udiff-line-removed">-           || ((*p_arg)-&gt;type == FFI_TYPE_LONGDOUBLE)</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-           )</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-           z = FFI_SIZEOF_ARG;</span>
<span class="udiff-line-removed">-           *(void **)argp = *p_argv;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       else if ((*p_arg)-&gt;type == FFI_TYPE_FLOAT)</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-           memcpy(argp, *p_argv, z);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       else</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-       if (z &lt; FFI_SIZEOF_ARG)</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-           z = FFI_SIZEOF_ARG;</span>
<span class="udiff-line-removed">-           switch ((*p_arg)-&gt;type)</span>
<span class="udiff-line-removed">-             {</span>
<span class="udiff-line-removed">-             case FFI_TYPE_SINT8:</span>
<span class="udiff-line-removed">-               *(ffi_sarg *) argp = (ffi_sarg)*(SINT8 *)(* p_argv);</span>
<span class="udiff-line-modified-added">+     case FFI_TYPE_VOID:</span>
<span class="udiff-line-modified-added">+       flags = X86_RET_VOID;</span>
                break;
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+     case FFI_TYPE_FLOAT:</span>
<span class="udiff-line-added">+       flags = X86_RET_FLOAT;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_TYPE_DOUBLE:</span>
<span class="udiff-line-added">+       flags = X86_RET_DOUBLE;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_TYPE_LONGDOUBLE:</span>
<span class="udiff-line-added">+       flags = X86_RET_LDOUBLE;</span>
<span class="udiff-line-added">+       break;</span>
              case FFI_TYPE_UINT8:
<span class="udiff-line-modified-removed">-               *(ffi_arg *) argp = (ffi_arg)*(UINT8 *)(* p_argv);</span>
<span class="udiff-line-modified-added">+       flags = X86_RET_UINT8;</span>
                break;
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+     case FFI_TYPE_UINT16:</span>
<span class="udiff-line-added">+       flags = X86_RET_UINT16;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_TYPE_SINT8:</span>
<span class="udiff-line-added">+       flags = X86_RET_SINT8;</span>
<span class="udiff-line-added">+       break;</span>
              case FFI_TYPE_SINT16:
<span class="udiff-line-modified-removed">-               *(ffi_sarg *) argp = (ffi_sarg)*(SINT16 *)(* p_argv);</span>
<span class="udiff-line-modified-added">+       flags = X86_RET_SINT16;</span>
                break;
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-             case FFI_TYPE_UINT16:</span>
<span class="udiff-line-removed">-               *(ffi_arg *) argp = (ffi_arg)*(UINT16 *)(* p_argv);</span>
<span class="udiff-line-removed">-               break;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+     case FFI_TYPE_INT:</span>
              case FFI_TYPE_SINT32:
<span class="udiff-line-removed">-               *(ffi_sarg *) argp = (ffi_sarg)*(SINT32 *)(* p_argv);</span>
<span class="udiff-line-removed">-               break;</span>
<span class="udiff-line-removed">- </span>
              case FFI_TYPE_UINT32:
<span class="udiff-line-modified-removed">-               *(ffi_arg *) argp = (ffi_arg)*(UINT32 *)(* p_argv);</span>
<span class="udiff-line-modified-added">+     case FFI_TYPE_POINTER:</span>
<span class="udiff-line-added">+       flags = X86_RET_INT32;</span>
                break;
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+     case FFI_TYPE_SINT64:</span>
<span class="udiff-line-added">+     case FFI_TYPE_UINT64:</span>
<span class="udiff-line-added">+       flags = X86_RET_INT64;</span>
<span class="udiff-line-added">+       break;</span>
              case FFI_TYPE_STRUCT:
<span class="udiff-line-modified-removed">-               *(ffi_arg *) argp = *(ffi_arg *)(* p_argv);</span>
<span class="udiff-line-modified-added">+ #ifndef X86</span>
<span class="udiff-line-added">+       /* ??? This should be a different ABI rather than an ifdef.  */</span>
<span class="udiff-line-added">+       if (cif-&gt;rtype-&gt;size == 1)</span>
<span class="udiff-line-added">+     flags = X86_RET_STRUCT_1B;</span>
<span class="udiff-line-added">+       else if (cif-&gt;rtype-&gt;size == 2)</span>
<span class="udiff-line-added">+     flags = X86_RET_STRUCT_2B;</span>
<span class="udiff-line-added">+       else if (cif-&gt;rtype-&gt;size == 4)</span>
<span class="udiff-line-added">+     flags = X86_RET_INT32;</span>
<span class="udiff-line-added">+       else if (cif-&gt;rtype-&gt;size == 8)</span>
<span class="udiff-line-added">+     flags = X86_RET_INT64;</span>
<span class="udiff-line-added">+       else</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+     do_struct:</span>
<span class="udiff-line-added">+       switch (cabi)</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+         case FFI_THISCALL:</span>
<span class="udiff-line-added">+         case FFI_FASTCALL:</span>
<span class="udiff-line-added">+         case FFI_STDCALL:</span>
<span class="udiff-line-added">+         case FFI_MS_CDECL:</span>
<span class="udiff-line-added">+           flags = X86_RET_STRUCTARG;</span>
                break;
<span class="udiff-line-removed">- </span>
              default:
<span class="udiff-line-modified-removed">-               FFI_ASSERT(0);</span>
<span class="udiff-line-modified-added">+           flags = X86_RET_STRUCTPOP;</span>
<span class="udiff-line-added">+           break;</span>
              }
<span class="udiff-line-added">+       /* Allocate space for return value pointer.  */</span>
<span class="udiff-line-added">+       bytes += FFI_ALIGN (sizeof(void*), FFI_SIZEOF_ARG);</span>
          }
<span class="udiff-line-modified-removed">-       else</span>
<span class="udiff-line-modified-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_TYPE_COMPLEX:</span>
<span class="udiff-line-added">+       switch (cif-&gt;rtype-&gt;elements[0]-&gt;type)</span>
          {
<span class="udiff-line-modified-removed">-           memcpy(argp, *p_argv, z);</span>
<span class="udiff-line-modified-added">+     case FFI_TYPE_DOUBLE:</span>
<span class="udiff-line-added">+     case FFI_TYPE_LONGDOUBLE:</span>
<span class="udiff-line-added">+     case FFI_TYPE_SINT64:</span>
<span class="udiff-line-added">+     case FFI_TYPE_UINT64:</span>
<span class="udiff-line-added">+       goto do_struct;</span>
<span class="udiff-line-added">+     case FFI_TYPE_FLOAT:</span>
<span class="udiff-line-added">+     case FFI_TYPE_INT:</span>
<span class="udiff-line-added">+     case FFI_TYPE_SINT32:</span>
<span class="udiff-line-added">+     case FFI_TYPE_UINT32:</span>
<span class="udiff-line-added">+       flags = X86_RET_INT64;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_TYPE_SINT16:</span>
<span class="udiff-line-added">+     case FFI_TYPE_UINT16:</span>
<span class="udiff-line-added">+       flags = X86_RET_INT32;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_TYPE_SINT8:</span>
<span class="udiff-line-added">+     case FFI_TYPE_UINT8:</span>
<span class="udiff-line-added">+       flags = X86_RET_STRUCT_2B;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     default:</span>
<span class="udiff-line-added">+       return FFI_BAD_TYPEDEF;</span>
          }
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     default:</span>
<span class="udiff-line-added">+       return FFI_BAD_TYPEDEF;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   cif-&gt;flags = flags;</span>
  
<span class="udiff-line-modified-removed">- #ifndef X86_WIN64</span>
<span class="udiff-line-removed">-     /* For thiscall/fastcall/register convention register-passed arguments</span>
<span class="udiff-line-removed">-        are the first two none-floating-point arguments with a size</span>
<span class="udiff-line-removed">-        smaller or equal to sizeof (void*).  */</span>
<span class="udiff-line-removed">-     if ((z == FFI_SIZEOF_ARG)</span>
<span class="udiff-line-removed">-         &amp;&amp; ((cabi == FFI_REGISTER)</span>
<span class="udiff-line-removed">-           || (cabi == FFI_THISCALL &amp;&amp; stack_args_count &lt; 1)</span>
<span class="udiff-line-removed">-           || (cabi == FFI_FASTCALL &amp;&amp; stack_args_count &lt; 2))</span>
<span class="udiff-line-removed">-         &amp;&amp; ((*p_arg)-&gt;type != FFI_TYPE_FLOAT &amp;&amp; (*p_arg)-&gt;type != FFI_TYPE_STRUCT)</span>
<span class="udiff-line-removed">-        )</span>
<span class="udiff-line-modified-added">+   for (i = 0, n = cif-&gt;nargs; i &lt; n; i++)</span>
        {
<span class="udiff-line-modified-removed">-         if (dir &lt; 0 &amp;&amp; stack_args_count &gt; 2)</span>
<span class="udiff-line-modified-removed">-           {</span>
<span class="udiff-line-modified-removed">-             /* Iterating arguments backwards, so first register-passed argument</span>
<span class="udiff-line-modified-removed">-                will be passed last. Shift temporary values to make place. */</span>
<span class="udiff-line-removed">-             p_stack_data[0] = p_stack_data[1];</span>
<span class="udiff-line-removed">-             p_stack_data[1] = p_stack_data[2];</span>
<span class="udiff-line-removed">-             stack_args_count = 2;</span>
<span class="udiff-line-removed">-           }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         p_stack_data[stack_args_count] = argp;</span>
<span class="udiff-line-removed">-         ++stack_args_count;</span>
<span class="udiff-line-modified-added">+       ffi_type *t = cif-&gt;arg_types[i];</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       bytes = FFI_ALIGN (bytes, t-&gt;alignment);</span>
<span class="udiff-line-modified-added">+       bytes += FFI_ALIGN (t-&gt;size, FFI_SIZEOF_ARG);</span>
        }
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-added">+   cif-&gt;bytes = bytes;</span>
  
<span class="udiff-line-modified-removed">- #ifdef X86_WIN64</span>
<span class="udiff-line-removed">-       argp += (z + sizeof(void*) - 1) &amp; ~(sizeof(void*) - 1);</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-       argp += z;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-modified-added">+   return FFI_OK;</span>
      }
  
<span class="udiff-line-modified-removed">- #ifndef X86_WIN64</span>
<span class="udiff-line-modified-removed">-   /* We need to move the register-passed arguments for thiscall/fastcall/register</span>
<span class="udiff-line-removed">-      on top of stack, so that those can be moved to registers by call-handler.  */</span>
<span class="udiff-line-removed">-   if (stack_args_count &gt; 0)</span>
<span class="udiff-line-modified-added">+ static ffi_arg</span>
<span class="udiff-line-modified-added">+ extend_basic_type(void *arg, int type)</span>
      {
<span class="udiff-line-modified-removed">- #ifdef GSTREAMER_LITE</span>
<span class="udiff-line-removed">-       int i;</span>
<span class="udiff-line-removed">- #endif // GSTREAMER_LITE</span>
<span class="udiff-line-removed">-       if (dir &lt; 0 &amp;&amp; stack_args_count &gt; 1)</span>
<span class="udiff-line-modified-added">+   switch (type)</span>
          {
<span class="udiff-line-modified-removed">-           /* Reverse order if iterating arguments backwards */</span>
<span class="udiff-line-modified-removed">-           ffi_arg tmp = *(ffi_arg*) p_stack_data[0];</span>
<span class="udiff-line-modified-removed">-           *(ffi_arg*) p_stack_data[0] = *(ffi_arg*) p_stack_data[stack_args_count - 1];</span>
<span class="udiff-line-modified-removed">-           *(ffi_arg*) p_stack_data[stack_args_count - 1] = tmp;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+     case FFI_TYPE_SINT8:</span>
<span class="udiff-line-modified-added">+       return *(SINT8 *)arg;</span>
<span class="udiff-line-modified-added">+     case FFI_TYPE_UINT8:</span>
<span class="udiff-line-modified-added">+       return *(UINT8 *)arg;</span>
<span class="udiff-line-modified-added">+     case FFI_TYPE_SINT16:</span>
<span class="udiff-line-added">+       return *(SINT16 *)arg;</span>
<span class="udiff-line-added">+     case FFI_TYPE_UINT16:</span>
<span class="udiff-line-added">+       return *(UINT16 *)arg;</span>
  
<span class="udiff-line-modified-removed">- #ifndef GSTREAMER_LITE</span>
<span class="udiff-line-modified-removed">-       int i;</span>
<span class="udiff-line-modified-removed">- #endif // GSTREAMER_LITE</span>
<span class="udiff-line-modified-removed">-       for (i = 0; i &lt; stack_args_count; i++)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-removed">-           if (p_stack_data[i] != argp2)</span>
<span class="udiff-line-removed">-             {</span>
<span class="udiff-line-removed">-               ffi_arg tmp = *(ffi_arg*) p_stack_data[i];</span>
<span class="udiff-line-removed">-               memmove (argp2 + FFI_SIZEOF_ARG, argp2, (size_t) ((char*) p_stack_data[i] - (char*)argp2));</span>
<span class="udiff-line-removed">-               *(ffi_arg *) argp2 = tmp;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+     case FFI_TYPE_SINT32:</span>
<span class="udiff-line-modified-added">+     case FFI_TYPE_UINT32:</span>
<span class="udiff-line-modified-added">+     case FFI_TYPE_POINTER:</span>
<span class="udiff-line-modified-added">+     case FFI_TYPE_FLOAT:</span>
<span class="udiff-line-modified-added">+       return *(UINT32 *)arg;</span>
  
<span class="udiff-line-modified-removed">-           argp2 += FFI_SIZEOF_ARG;</span>
<span class="udiff-line-modified-added">+     default:</span>
<span class="udiff-line-added">+       abort();</span>
          }
      }
  
<span class="udiff-line-modified-removed">-     return stack_args_count;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-     return 0;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- /* Perform machine dependent cif processing */</span>
<span class="udiff-line-removed">- ffi_status ffi_prep_cif_machdep(ffi_cif *cif)</span>
<span class="udiff-line-modified-added">+ struct call_frame</span>
  {
<span class="udiff-line-modified-removed">-   unsigned int i;</span>
<span class="udiff-line-modified-removed">-   ffi_type **ptr;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   /* Set the return type flag */</span>
<span class="udiff-line-modified-removed">-   switch (cif-&gt;rtype-&gt;type)</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-     case FFI_TYPE_VOID:</span>
<span class="udiff-line-modified-removed">-     case FFI_TYPE_UINT8:</span>
<span class="udiff-line-modified-removed">-     case FFI_TYPE_UINT16:</span>
<span class="udiff-line-modified-removed">-     case FFI_TYPE_SINT8:</span>
<span class="udiff-line-modified-removed">-     case FFI_TYPE_SINT16:</span>
<span class="udiff-line-modified-removed">- #ifdef X86_WIN64</span>
<span class="udiff-line-modified-removed">-     case FFI_TYPE_UINT32:</span>
<span class="udiff-line-modified-removed">-     case FFI_TYPE_SINT32:</span>
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-removed">-     case FFI_TYPE_SINT64:</span>
<span class="udiff-line-modified-removed">-     case FFI_TYPE_FLOAT:</span>
<span class="udiff-line-modified-removed">-     case FFI_TYPE_DOUBLE:</span>
<span class="udiff-line-modified-removed">- #ifndef X86_WIN64</span>
<span class="udiff-line-modified-removed">- #if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE</span>
<span class="udiff-line-modified-removed">-     case FFI_TYPE_LONGDOUBLE:</span>
<span class="udiff-line-modified-added">+   void *ebp;        /* 0 */</span>
<span class="udiff-line-modified-added">+   void *retaddr;    /* 4 */</span>
<span class="udiff-line-modified-added">+   void (*fn)(void); /* 8 */</span>
<span class="udiff-line-modified-added">+   int flags;        /* 12 */</span>
<span class="udiff-line-modified-added">+   void *rvalue;     /* 16 */</span>
<span class="udiff-line-modified-added">+   unsigned regs[3]; /* 20-28 */</span>
<span class="udiff-line-modified-added">+ };</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ struct abi_params</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-modified-added">+   int dir;      /* parameter growth direction */</span>
<span class="udiff-line-modified-added">+   int static_chain; /* the static chain register used by gcc */</span>
<span class="udiff-line-modified-added">+   int nregs;        /* number of register parameters */</span>
<span class="udiff-line-modified-added">+   int regs[3];</span>
<span class="udiff-line-modified-added">+ };</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ static const struct abi_params abi_params[FFI_LAST_ABI] = {</span>
<span class="udiff-line-modified-added">+   [FFI_SYSV] = { 1, R_ECX, 0 },</span>
<span class="udiff-line-modified-added">+   [FFI_THISCALL] = { 1, R_EAX, 1, { R_ECX } },</span>
<span class="udiff-line-modified-added">+   [FFI_FASTCALL] = { 1, R_EAX, 2, { R_ECX, R_EDX } },</span>
<span class="udiff-line-modified-added">+   [FFI_STDCALL] = { 1, R_ECX, 0 },</span>
<span class="udiff-line-added">+   [FFI_PASCAL] = { -1, R_ECX, 0 },</span>
<span class="udiff-line-added">+   /* ??? No defined static chain; gcc does not support REGISTER.  */</span>
<span class="udiff-line-added">+   [FFI_REGISTER] = { -1, R_ECX, 3, { R_EAX, R_EDX, R_ECX } },</span>
<span class="udiff-line-added">+   [FFI_MS_CDECL] = { 1, R_ECX, 0 }</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef HAVE_FASTCALL</span>
<span class="udiff-line-added">+   #ifdef _MSC_VER</span>
<span class="udiff-line-added">+     #define FFI_DECLARE_FASTCALL __fastcall</span>
<span class="udiff-line-added">+   #else</span>
<span class="udiff-line-added">+     #define FFI_DECLARE_FASTCALL __declspec(fastcall)</span>
  #endif
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+   #define FFI_DECLARE_FASTCALL</span>
  #endif
<span class="udiff-line-removed">-       cif-&gt;flags = (unsigned) cif-&gt;rtype-&gt;type;</span>
<span class="udiff-line-removed">-       break;</span>
  
<span class="udiff-line-modified-removed">-     case FFI_TYPE_UINT64:</span>
<span class="udiff-line-removed">- #ifdef X86_WIN64</span>
<span class="udiff-line-removed">-     case FFI_TYPE_POINTER:</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-       cif-&gt;flags = FFI_TYPE_SINT64;</span>
<span class="udiff-line-removed">-       break;</span>
<span class="udiff-line-modified-added">+ extern void FFI_DECLARE_FASTCALL ffi_call_i386(struct call_frame *, char *) FFI_HIDDEN;</span>
  
<span class="udiff-line-modified-removed">-     case FFI_TYPE_STRUCT:</span>
<span class="udiff-line-modified-removed">- #ifndef X86</span>
<span class="udiff-line-modified-removed">-       if (cif-&gt;rtype-&gt;size == 1)</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-           cif-&gt;flags = FFI_TYPE_SMALL_STRUCT_1B; /* same as char size */</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       else if (cif-&gt;rtype-&gt;size == 2)</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-           cif-&gt;flags = FFI_TYPE_SMALL_STRUCT_2B; /* same as short size */</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       else if (cif-&gt;rtype-&gt;size == 4)</span>
<span class="udiff-line-modified-added">+ static void</span>
<span class="udiff-line-modified-added">+ ffi_call_int (ffi_cif *cif, void (*fn)(void), void *rvalue,</span>
<span class="udiff-line-modified-added">+           void **avalue, void *closure)</span>
          {
<span class="udiff-line-modified-removed">- #ifdef X86_WIN64</span>
<span class="udiff-line-modified-removed">-           cif-&gt;flags = FFI_TYPE_SMALL_STRUCT_4B;</span>
<span class="udiff-line-modified-removed">- #else</span>
<span class="udiff-line-modified-removed">-           cif-&gt;flags = FFI_TYPE_INT; /* same as int type */</span>
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-       else if (cif-&gt;rtype-&gt;size == 8)</span>
<span class="udiff-line-modified-added">+   size_t rsize, bytes;</span>
<span class="udiff-line-modified-added">+   struct call_frame *frame;</span>
<span class="udiff-line-modified-added">+   char *stack, *argp;</span>
<span class="udiff-line-modified-added">+   ffi_type **arg_types;</span>
<span class="udiff-line-modified-added">+   int flags, cabi, i, n, dir, narg_reg;</span>
<span class="udiff-line-modified-added">+   const struct abi_params *pabi;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   flags = cif-&gt;flags;</span>
<span class="udiff-line-added">+   cabi = cif-&gt;abi;</span>
<span class="udiff-line-added">+   pabi = &amp;abi_params[cabi];</span>
<span class="udiff-line-added">+   dir = pabi-&gt;dir;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   rsize = 0;</span>
<span class="udiff-line-added">+   if (rvalue == NULL)</span>
          {
<span class="udiff-line-modified-removed">-           cif-&gt;flags = FFI_TYPE_SINT64; /* same as int64 type */</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       else</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-modified-added">+       switch (flags)</span>
          {
<span class="udiff-line-modified-removed">- #ifdef X86_WIN32</span>
<span class="udiff-line-modified-removed">-           if (cif-&gt;abi == FFI_MS_CDECL)</span>
<span class="udiff-line-modified-removed">-             cif-&gt;flags = FFI_TYPE_MS_STRUCT;</span>
<span class="udiff-line-modified-removed">-           else</span>
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-removed">-             cif-&gt;flags = FFI_TYPE_STRUCT;</span>
<span class="udiff-line-modified-removed">-           /* allocate space for return value pointer */</span>
<span class="udiff-line-modified-removed">-           cif-&gt;bytes += ALIGN(sizeof(void*), FFI_SIZEOF_ARG);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+     case X86_RET_FLOAT:</span>
<span class="udiff-line-modified-added">+     case X86_RET_DOUBLE:</span>
<span class="udiff-line-modified-added">+     case X86_RET_LDOUBLE:</span>
<span class="udiff-line-modified-added">+     case X86_RET_STRUCTPOP:</span>
<span class="udiff-line-modified-added">+     case X86_RET_STRUCTARG:</span>
<span class="udiff-line-modified-added">+       /* The float cases need to pop the 387 stack.</span>
<span class="udiff-line-modified-added">+          The struct cases need to pass a valid pointer to the callee.  */</span>
<span class="udiff-line-modified-added">+       rsize = cif-&gt;rtype-&gt;size;</span>
        break;
<span class="udiff-line-removed">- </span>
      default:
<span class="udiff-line-modified-removed">- #ifdef X86_WIN64</span>
<span class="udiff-line-modified-removed">-       cif-&gt;flags = FFI_TYPE_SINT64;</span>
<span class="udiff-line-removed">-       break;</span>
<span class="udiff-line-removed">-     case FFI_TYPE_INT:</span>
<span class="udiff-line-removed">-       cif-&gt;flags = FFI_TYPE_SINT32;</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-       cif-&gt;flags = FFI_TYPE_INT;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-modified-added">+       /* We can pretend that the callee returns nothing.  */</span>
<span class="udiff-line-modified-added">+       flags = X86_RET_VOID;</span>
        break;
      }
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   for (ptr = cif-&gt;arg_types, i = cif-&gt;nargs; i &gt; 0; i--, ptr++)</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-       if (((*ptr)-&gt;alignment - 1) &amp; cif-&gt;bytes)</span>
<span class="udiff-line-removed">-         cif-&gt;bytes = ALIGN(cif-&gt;bytes, (*ptr)-&gt;alignment);</span>
<span class="udiff-line-removed">-       cif-&gt;bytes += (unsigned)ALIGN((*ptr)-&gt;size, FFI_SIZEOF_ARG);</span>
      }
  
<span class="udiff-line-modified-removed">- #ifdef X86_WIN64</span>
<span class="udiff-line-modified-removed">-   /* ensure space for storing four registers */</span>
<span class="udiff-line-modified-removed">-   cif-&gt;bytes += 4 * FFI_SIZEOF_ARG;</span>
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-added">+   bytes = STACK_ALIGN (cif-&gt;bytes);</span>
<span class="udiff-line-modified-added">+   stack = alloca(bytes + sizeof(*frame) + rsize);</span>
<span class="udiff-line-modified-added">+   argp = (dir &lt; 0 ? stack + bytes : stack);</span>
<span class="udiff-line-modified-added">+   frame = (struct call_frame *)(stack + bytes);</span>
<span class="udiff-line-added">+   if (rsize)</span>
<span class="udiff-line-added">+     rvalue = frame + 1;</span>
  
<span class="udiff-line-modified-removed">- #ifndef X86_WIN32</span>
<span class="udiff-line-modified-removed">- #ifndef X86_WIN64</span>
<span class="udiff-line-modified-removed">-   if (cif-&gt;abi == FFI_SYSV || cif-&gt;abi == FFI_UNIX64)</span>
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-removed">-     cif-&gt;bytes = (cif-&gt;bytes + 15) &amp; ~0xF;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-modified-added">+   frame-&gt;fn = fn;</span>
<span class="udiff-line-modified-added">+   frame-&gt;flags = flags;</span>
<span class="udiff-line-modified-added">+   frame-&gt;rvalue = rvalue;</span>
<span class="udiff-line-modified-added">+   frame-&gt;regs[pabi-&gt;static_chain] = (unsigned)closure;</span>
  
<span class="udiff-line-modified-removed">-   return FFI_OK;</span>
<span class="udiff-line-modified-added">+   narg_reg = 0;</span>
<span class="udiff-line-added">+   switch (flags)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+     case X86_RET_STRUCTARG:</span>
<span class="udiff-line-added">+       /* The pointer is passed as the first argument.  */</span>
<span class="udiff-line-added">+       if (pabi-&gt;nregs &gt; 0)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       frame-&gt;regs[pabi-&gt;regs[0]] = (unsigned)rvalue;</span>
<span class="udiff-line-added">+       narg_reg = 1;</span>
<span class="udiff-line-added">+       break;</span>
  }
<span class="udiff-line-added">+       /* fallthru */</span>
<span class="udiff-line-added">+     case X86_RET_STRUCTPOP:</span>
<span class="udiff-line-added">+       *(void **)argp = rvalue;</span>
<span class="udiff-line-added">+       argp += sizeof(void *);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">- #ifdef X86_WIN64</span>
<span class="udiff-line-modified-removed">- extern int</span>
<span class="udiff-line-modified-removed">- ffi_call_win64(unsigned int (*)(char *, extended_cif *), extended_cif *,</span>
<span class="udiff-line-modified-removed">-                unsigned, unsigned, unsigned *, void (*fn)(void));</span>
<span class="udiff-line-modified-removed">- #else</span>
<span class="udiff-line-modified-removed">- extern void</span>
<span class="udiff-line-modified-removed">- ffi_call_win32(unsigned int (*)(char *, extended_cif *), extended_cif *,</span>
<span class="udiff-line-removed">-                unsigned, unsigned, unsigned, unsigned *, void (*fn)(void));</span>
<span class="udiff-line-removed">- extern void ffi_call_SYSV(void (*)(char *, extended_cif *), extended_cif *,</span>
<span class="udiff-line-removed">-                           unsigned, unsigned, unsigned *, void (*fn)(void));</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-modified-added">+   arg_types = cif-&gt;arg_types;</span>
<span class="udiff-line-modified-added">+   for (i = 0, n = cif-&gt;nargs; i &lt; n; i++)</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       ffi_type *ty = arg_types[i];</span>
<span class="udiff-line-modified-added">+       void *valp = avalue[i];</span>
<span class="udiff-line-modified-added">+       size_t z = ty-&gt;size;</span>
<span class="udiff-line-modified-added">+       int t = ty-&gt;type;</span>
  
<span class="udiff-line-modified-removed">- void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)</span>
<span class="udiff-line-modified-added">+       if (z &lt;= FFI_SIZEOF_ARG &amp;&amp; t != FFI_TYPE_STRUCT)</span>
  {
<span class="udiff-line-modified-removed">-   extended_cif ecif;</span>
<span class="udiff-line-modified-added">+       ffi_arg val = extend_basic_type (valp, t);</span>
  
<span class="udiff-line-modified-removed">-   ecif.cif = cif;</span>
<span class="udiff-line-modified-removed">-   ecif.avalue = avalue;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-   /* If the return value is a struct and we don&#39;t have a return */</span>
<span class="udiff-line-removed">-   /* value address then we need to make one                     */</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef X86_WIN64</span>
<span class="udiff-line-removed">-   if (rvalue == NULL</span>
<span class="udiff-line-removed">-       &amp;&amp; cif-&gt;flags == FFI_TYPE_STRUCT</span>
<span class="udiff-line-removed">-       &amp;&amp; ((cif-&gt;rtype-&gt;size &amp; (1 | 2 | 4 | 8)) == 0))</span>
<span class="udiff-line-modified-added">+       if (t != FFI_TYPE_FLOAT &amp;&amp; narg_reg &lt; pabi-&gt;nregs)</span>
<span class="udiff-line-modified-added">+         frame-&gt;regs[pabi-&gt;regs[narg_reg++]] = val;</span>
<span class="udiff-line-modified-added">+       else if (dir &lt; 0)</span>
      {
<span class="udiff-line-modified-removed">-       ecif.rvalue = alloca((cif-&gt;rtype-&gt;size + 0xF) &amp; ~0xF);</span>
<span class="udiff-line-modified-added">+           argp -= 4;</span>
<span class="udiff-line-added">+           *(ffi_arg *)argp = val;</span>
      }
<span class="udiff-line-modified-removed">- #else</span>
<span class="udiff-line-removed">-   if (rvalue == NULL</span>
<span class="udiff-line-removed">-       &amp;&amp; (cif-&gt;flags == FFI_TYPE_STRUCT</span>
<span class="udiff-line-removed">-           || cif-&gt;flags == FFI_TYPE_MS_STRUCT))</span>
<span class="udiff-line-modified-added">+       else</span>
      {
<span class="udiff-line-modified-removed">-       ecif.rvalue = alloca(cif-&gt;rtype-&gt;size);</span>
<span class="udiff-line-modified-added">+           *(ffi_arg *)argp = val;</span>
<span class="udiff-line-added">+           argp += 4;</span>
<span class="udiff-line-added">+     }</span>
      }
<span class="udiff-line-removed">- #endif</span>
    else
<span class="udiff-line-removed">-     ecif.rvalue = rvalue;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   switch (cif-&gt;abi)</span>
      {
<span class="udiff-line-modified-removed">- #ifdef X86_WIN64</span>
<span class="udiff-line-modified-removed">-     case FFI_WIN64:</span>
<span class="udiff-line-modified-removed">-       ffi_call_win64(ffi_prep_args, &amp;ecif, cif-&gt;bytes,</span>
<span class="udiff-line-modified-removed">-                      cif-&gt;flags, ecif.rvalue, fn);</span>
<span class="udiff-line-modified-removed">-       break;</span>
<span class="udiff-line-modified-removed">- #else</span>
<span class="udiff-line-modified-removed">- #ifndef X86_WIN32</span>
<span class="udiff-line-modified-removed">-     case FFI_SYSV:</span>
<span class="udiff-line-modified-removed">-       ffi_call_SYSV(ffi_prep_args, &amp;ecif, cif-&gt;bytes, cif-&gt;flags, ecif.rvalue,</span>
<span class="udiff-line-modified-removed">-                     fn);</span>
<span class="udiff-line-modified-removed">-       break;</span>
<span class="udiff-line-modified-removed">- #else</span>
<span class="udiff-line-modified-removed">-     case FFI_SYSV:</span>
<span class="udiff-line-modified-removed">-     case FFI_MS_CDECL:</span>
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-removed">-     case FFI_STDCALL:</span>
<span class="udiff-line-modified-removed">-     case FFI_THISCALL:</span>
<span class="udiff-line-modified-removed">-     case FFI_FASTCALL:</span>
<span class="udiff-line-modified-removed">-     case FFI_PASCAL:</span>
<span class="udiff-line-modified-removed">-     case FFI_REGISTER:</span>
<span class="udiff-line-modified-removed">-       ffi_call_win32(ffi_prep_args, &amp;ecif, cif-&gt;abi, cif-&gt;bytes, cif-&gt;flags,</span>
<span class="udiff-line-modified-removed">-                      ecif.rvalue, fn);</span>
<span class="udiff-line-modified-removed">-       break;</span>
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-removed">-     default:</span>
<span class="udiff-line-modified-removed">-       FFI_ASSERT(0);</span>
<span class="udiff-line-modified-removed">-       break;</span>
<span class="udiff-line-modified-added">+       size_t za = FFI_ALIGN (z, FFI_SIZEOF_ARG);</span>
<span class="udiff-line-modified-added">+       size_t align = FFI_SIZEOF_ARG;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       /* Issue 434: For thiscall and fastcall, if the paramter passed</span>
<span class="udiff-line-modified-added">+          as 64-bit integer or struct, all following integer paramters</span>
<span class="udiff-line-modified-added">+          will be passed on stack.  */</span>
<span class="udiff-line-modified-added">+       if ((cabi == FFI_THISCALL || cabi == FFI_FASTCALL)</span>
<span class="udiff-line-modified-added">+           &amp;&amp; (t == FFI_TYPE_SINT64</span>
<span class="udiff-line-modified-added">+           || t == FFI_TYPE_UINT64</span>
<span class="udiff-line-modified-added">+           || t == FFI_TYPE_STRUCT))</span>
<span class="udiff-line-modified-added">+         narg_reg = 2;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       /* Alignment rules for arguments are quite complex.  Vectors and</span>
<span class="udiff-line-modified-added">+          structures with 16 byte alignment get it.  Note that long double</span>
<span class="udiff-line-modified-added">+          on Darwin does have 16 byte alignment, and does not get this</span>
<span class="udiff-line-modified-added">+          alignment if passed directly; a structure with a long double</span>
<span class="udiff-line-modified-added">+          inside, however, would get 16 byte alignment.  Since libffi does</span>
<span class="udiff-line-modified-added">+          not support vectors, we need non concern ourselves with other</span>
<span class="udiff-line-modified-added">+          cases.  */</span>
<span class="udiff-line-modified-added">+       if (t == FFI_TYPE_STRUCT &amp;&amp; ty-&gt;alignment &gt;= 16)</span>
<span class="udiff-line-modified-added">+         align = 16;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       if (dir &lt; 0)</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+           /* ??? These reverse argument ABIs are probably too old</span>
<span class="udiff-line-modified-added">+          to have cared about alignment.  Someone should check.  */</span>
<span class="udiff-line-modified-added">+           argp -= za;</span>
<span class="udiff-line-added">+           memcpy (argp, valp, z);</span>
      }
<span class="udiff-line-added">+       else</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+           argp = (char *)FFI_ALIGN (argp, align);</span>
<span class="udiff-line-added">+           memcpy (argp, valp, z);</span>
<span class="udiff-line-added">+           argp += za;</span>
  }
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   FFI_ASSERT (dir &gt; 0 || argp == stack);</span>
  
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">- /** private members **/</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- /* The following __attribute__((regparm(1))) decorations will have no effect</span>
<span class="udiff-line-removed">-    on MSVC or SUNPRO_C -- standard conventions apply. */</span>
<span class="udiff-line-removed">- static unsigned int ffi_prep_incoming_args (char *stack, void **ret,</span>
<span class="udiff-line-removed">-                                             void** args, ffi_cif* cif);</span>
<span class="udiff-line-removed">- void FFI_HIDDEN ffi_closure_SYSV (ffi_closure *)</span>
<span class="udiff-line-removed">-      __attribute__ ((regparm(1)));</span>
<span class="udiff-line-removed">- unsigned int FFI_HIDDEN ffi_closure_SYSV_inner (ffi_closure *, void **, void *)</span>
<span class="udiff-line-removed">-      __attribute__ ((regparm(1)));</span>
<span class="udiff-line-removed">- unsigned int FFI_HIDDEN ffi_closure_WIN32_inner (ffi_closure *, void **, void *)</span>
<span class="udiff-line-removed">-      __attribute__ ((regparm(1)));</span>
<span class="udiff-line-removed">- void FFI_HIDDEN ffi_closure_raw_SYSV (ffi_raw_closure *)</span>
<span class="udiff-line-removed">-      __attribute__ ((regparm(1)));</span>
<span class="udiff-line-removed">- #ifdef X86_WIN32</span>
<span class="udiff-line-removed">- void FFI_HIDDEN ffi_closure_raw_THISCALL (ffi_raw_closure *)</span>
<span class="udiff-line-removed">-      __attribute__ ((regparm(1)));</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- #ifndef X86_WIN64</span>
<span class="udiff-line-removed">- void FFI_HIDDEN ffi_closure_STDCALL (ffi_closure *);</span>
<span class="udiff-line-removed">- void FFI_HIDDEN ffi_closure_THISCALL (ffi_closure *);</span>
<span class="udiff-line-removed">- void FFI_HIDDEN ffi_closure_FASTCALL (ffi_closure *);</span>
<span class="udiff-line-removed">- void FFI_HIDDEN ffi_closure_REGISTER (ffi_closure *);</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">- void FFI_HIDDEN ffi_closure_win64 (ffi_closure *);</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- /* This function is jumped to by the trampoline */</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef X86_WIN64</span>
<span class="udiff-line-removed">- void * FFI_HIDDEN</span>
<span class="udiff-line-removed">- ffi_closure_win64_inner (ffi_closure *closure, void *args) {</span>
<span class="udiff-line-removed">-   ffi_cif       *cif;</span>
<span class="udiff-line-removed">-   void         **arg_area;</span>
<span class="udiff-line-removed">-   void          *result;</span>
<span class="udiff-line-removed">-   void          *resp = &amp;result;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   cif         = closure-&gt;cif;</span>
<span class="udiff-line-removed">-   arg_area    = (void**) alloca (cif-&gt;nargs * sizeof (void*));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   /* this call will initialize ARG_AREA, such that each</span>
<span class="udiff-line-removed">-    * element in that array points to the corresponding</span>
<span class="udiff-line-removed">-    * value on the stack; and if the function returns</span>
<span class="udiff-line-removed">-    * a structure, it will change RESP to point to the</span>
<span class="udiff-line-removed">-    * structure return address.  */</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   ffi_prep_incoming_args(args, &amp;resp, arg_area, cif);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   (closure-&gt;fun) (cif, resp, arg_area, closure-&gt;user_data);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   /* The result is returned in rax.  This does the right thing for</span>
<span class="udiff-line-removed">-      result types except for floats; we have to &#39;mov xmm0, rax&#39; in the</span>
<span class="udiff-line-removed">-      caller to correct this.</span>
<span class="udiff-line-removed">-      TODO: structure sizes of 3 5 6 7 are returned by reference, too!!!</span>
<span class="udiff-line-removed">-   */</span>
<span class="udiff-line-removed">-   return cif-&gt;rtype-&gt;size &gt; sizeof(void *) ? resp : *(void **)resp;</span>
<span class="udiff-line-modified-added">+   ffi_call_i386 (frame, stack);</span>
  }
  
<span class="udiff-line-modified-removed">- #else</span>
<span class="udiff-line-modified-removed">- unsigned int FFI_HIDDEN __attribute__ ((regparm(1)))</span>
<span class="udiff-line-removed">- ffi_closure_SYSV_inner (ffi_closure *closure, void **respp, void *args)</span>
<span class="udiff-line-modified-added">+ void</span>
<span class="udiff-line-modified-added">+ ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)</span>
  {
<span class="udiff-line-modified-removed">-   /* our various things...  */</span>
<span class="udiff-line-removed">-   ffi_cif       *cif;</span>
<span class="udiff-line-removed">-   void         **arg_area;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   cif         = closure-&gt;cif;</span>
<span class="udiff-line-removed">-   arg_area    = (void**) alloca (cif-&gt;nargs * sizeof (void*));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   /* this call will initialize ARG_AREA, such that each</span>
<span class="udiff-line-removed">-    * element in that array points to the corresponding</span>
<span class="udiff-line-removed">-    * value on the stack; and if the function returns</span>
<span class="udiff-line-removed">-    * a structure, it will change RESP to point to the</span>
<span class="udiff-line-removed">-    * structure return address.  */</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   ffi_prep_incoming_args(args, respp, arg_area, cif);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   (closure-&gt;fun) (cif, *respp, arg_area, closure-&gt;user_data);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return cif-&gt;flags;</span>
<span class="udiff-line-modified-added">+   ffi_call_int (cif, fn, rvalue, avalue, NULL);</span>
  }
  
<span class="udiff-line-modified-removed">- unsigned int FFI_HIDDEN __attribute__ ((regparm(1)))</span>
<span class="udiff-line-modified-removed">- ffi_closure_WIN32_inner (ffi_closure *closure, void **respp, void *args)</span>
<span class="udiff-line-modified-added">+ void</span>
<span class="udiff-line-modified-added">+ ffi_call_go (ffi_cif *cif, void (*fn)(void), void *rvalue,</span>
<span class="udiff-line-added">+          void **avalue, void *closure)</span>
  {
<span class="udiff-line-modified-removed">-   /* our various things...  */</span>
<span class="udiff-line-removed">-   ffi_cif       *cif;</span>
<span class="udiff-line-removed">-   void         **arg_area;</span>
<span class="udiff-line-removed">-   unsigned int   ret;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   cif         = closure-&gt;cif;</span>
<span class="udiff-line-removed">-   arg_area    = (void**) alloca (cif-&gt;nargs * sizeof (void*));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   /* this call will initialize ARG_AREA, such that each</span>
<span class="udiff-line-removed">-    * element in that array points to the corresponding</span>
<span class="udiff-line-removed">-    * value on the stack; and if the function returns</span>
<span class="udiff-line-removed">-    * a structure, it will change RESP to point to the</span>
<span class="udiff-line-removed">-    * structure return address.  */</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   ret = ffi_prep_incoming_args(args, respp, arg_area, cif);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   (closure-&gt;fun) (cif, *respp, arg_area, closure-&gt;user_data);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return ret;</span>
<span class="udiff-line-modified-added">+   ffi_call_int (cif, fn, rvalue, avalue, closure);</span>
  }
<span class="udiff-line-removed">- #endif /* !X86_WIN64 */</span>
  
<span class="udiff-line-modified-removed">- static unsigned int</span>
<span class="udiff-line-removed">- ffi_prep_incoming_args(char *stack, void **rvalue, void **avalue,</span>
<span class="udiff-line-removed">-                        ffi_cif *cif)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   register unsigned int i;</span>
<span class="udiff-line-removed">-   register void **p_argv;</span>
<span class="udiff-line-removed">-   register char *argp;</span>
<span class="udiff-line-removed">-   register ffi_type **p_arg;</span>
<span class="udiff-line-removed">- #ifndef X86_WIN64</span>
<span class="udiff-line-removed">-   const int cabi = cif-&gt;abi;</span>
<span class="udiff-line-removed">-   const int dir = (cabi == FFI_PASCAL || cabi == FFI_REGISTER) ? -1 : +1;</span>
<span class="udiff-line-removed">-   const unsigned int max_stack_count = (cabi == FFI_THISCALL) ? 1</span>
<span class="udiff-line-removed">-                                      : (cabi == FFI_FASTCALL) ? 2</span>
<span class="udiff-line-removed">-                                      : (cabi == FFI_REGISTER) ? 3</span>
<span class="udiff-line-removed">-                                      : 0;</span>
<span class="udiff-line-removed">-   unsigned int passed_regs = 0;</span>
<span class="udiff-line-removed">-   void *p_stack_data[3] = { stack - 1 };</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-   #define dir 1</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-modified-added">+ /** private members **/</span>
  
<span class="udiff-line-modified-removed">-   argp = stack;</span>
<span class="udiff-line-modified-removed">- #ifndef X86_WIN64</span>
<span class="udiff-line-modified-removed">-   argp += max_stack_count * FFI_SIZEOF_ARG;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-modified-added">+ void FFI_HIDDEN ffi_closure_i386(void);</span>
<span class="udiff-line-modified-added">+ void FFI_HIDDEN ffi_closure_STDCALL(void);</span>
<span class="udiff-line-modified-added">+ void FFI_HIDDEN ffi_closure_REGISTER(void);</span>
  
<span class="udiff-line-modified-removed">-   if ((cif-&gt;flags == FFI_TYPE_STRUCT</span>
<span class="udiff-line-modified-removed">-        || cif-&gt;flags == FFI_TYPE_MS_STRUCT)</span>
<span class="udiff-line-modified-removed">- #ifdef X86_WIN64</span>
<span class="udiff-line-modified-removed">-       &amp;&amp; ((cif-&gt;rtype-&gt;size &amp; (1 | 2 | 4 | 8)) == 0)</span>
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-removed">-       )</span>
<span class="udiff-line-modified-added">+ struct closure_frame</span>
<span class="udiff-line-modified-added">+ {</span>
<span class="udiff-line-modified-added">+   unsigned rettemp[4];              /* 0 */</span>
<span class="udiff-line-modified-added">+   unsigned regs[3];             /* 16-24 */</span>
<span class="udiff-line-modified-added">+   ffi_cif *cif;                 /* 28 */</span>
<span class="udiff-line-modified-added">+   void (*fun)(ffi_cif*,void*,void**,void*); /* 32 */</span>
<span class="udiff-line-added">+   void *user_data;              /* 36 */</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ int FFI_HIDDEN FFI_DECLARE_FASTCALL</span>
<span class="udiff-line-added">+ ffi_closure_inner (struct closure_frame *frame, char *stack)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   ffi_cif *cif = frame-&gt;cif;</span>
<span class="udiff-line-added">+   int cabi, i, n, flags, dir, narg_reg;</span>
<span class="udiff-line-added">+   const struct abi_params *pabi;</span>
<span class="udiff-line-added">+   ffi_type **arg_types;</span>
<span class="udiff-line-added">+   char *argp;</span>
<span class="udiff-line-added">+   void *rvalue;</span>
<span class="udiff-line-added">+   void **avalue;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   cabi = cif-&gt;abi;</span>
<span class="udiff-line-added">+   flags = cif-&gt;flags;</span>
<span class="udiff-line-added">+   narg_reg = 0;</span>
<span class="udiff-line-added">+   rvalue = frame-&gt;rettemp;</span>
<span class="udiff-line-added">+   pabi = &amp;abi_params[cabi];</span>
<span class="udiff-line-added">+   dir = pabi-&gt;dir;</span>
<span class="udiff-line-added">+   argp = (dir &lt; 0 ? stack + STACK_ALIGN (cif-&gt;bytes) : stack);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   switch (flags)</span>
      {
<span class="udiff-line-modified-removed">- #ifndef X86_WIN64</span>
<span class="udiff-line-modified-removed">-       if (passed_regs &lt; max_stack_count)</span>
<span class="udiff-line-modified-added">+     case X86_RET_STRUCTARG:</span>
<span class="udiff-line-modified-added">+       if (pabi-&gt;nregs &gt; 0)</span>
          {
<span class="udiff-line-modified-removed">-           *rvalue = *(void**) (stack + (passed_regs*FFI_SIZEOF_ARG));</span>
<span class="udiff-line-modified-removed">-           ++passed_regs;</span>
<span class="udiff-line-modified-added">+       rvalue = (void *)frame-&gt;regs[pabi-&gt;regs[0]];</span>
<span class="udiff-line-modified-added">+       narg_reg = 1;</span>
<span class="udiff-line-added">+       frame-&gt;rettemp[0] = (unsigned)rvalue;</span>
<span class="udiff-line-added">+       break;</span>
          }
<span class="udiff-line-modified-removed">-       else</span>
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-removed">-           *rvalue = *(void **) argp;</span>
<span class="udiff-line-modified-added">+       /* fallthru */</span>
<span class="udiff-line-modified-added">+     case X86_RET_STRUCTPOP:</span>
<span class="udiff-line-modified-added">+       rvalue = *(void **)argp;</span>
            argp += sizeof(void *);
<span class="udiff-line-added">+       frame-&gt;rettemp[0] = (unsigned)rvalue;</span>
<span class="udiff-line-added">+       break;</span>
          }
<span class="udiff-line-removed">-     }</span>
  
<span class="udiff-line-modified-removed">- #ifndef X86_WIN64</span>
<span class="udiff-line-modified-removed">-   /* Do register arguments first  */</span>
<span class="udiff-line-modified-removed">-   for (i = 0, p_arg = cif-&gt;arg_types;</span>
<span class="udiff-line-modified-removed">-        i &lt; cif-&gt;nargs &amp;&amp; passed_regs &lt; max_stack_count;</span>
<span class="udiff-line-modified-removed">-        i++, p_arg++)</span>
<span class="udiff-line-modified-added">+   n = cif-&gt;nargs;</span>
<span class="udiff-line-modified-added">+   avalue = alloca(sizeof(void *) * n);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   arg_types = cif-&gt;arg_types;</span>
<span class="udiff-line-modified-added">+   for (i = 0; i &lt; n; ++i)</span>
    {
<span class="udiff-line-modified-removed">- #ifdef GSTREAMER_LITE</span>
<span class="udiff-line-modified-removed">-       size_t sz = 0;</span>
<span class="udiff-line-modified-removed">- #endif // GSTREAMER_LITE</span>
<span class="udiff-line-modified-removed">-       if ((*p_arg)-&gt;type == FFI_TYPE_FLOAT</span>
<span class="udiff-line-removed">-          || (*p_arg)-&gt;type == FFI_TYPE_STRUCT)</span>
<span class="udiff-line-removed">-         continue;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef GSTREAMER_LITE</span>
<span class="udiff-line-removed">-       sz = (*p_arg)-&gt;size;</span>
<span class="udiff-line-removed">- #else // GSTREAMER_LITE</span>
<span class="udiff-line-removed">-       size_t sz = (*p_arg)-&gt;size;</span>
<span class="udiff-line-removed">- #endif // GSTREAMER_LITE</span>
<span class="udiff-line-removed">-       if(sz == 0 || sz &gt; FFI_SIZEOF_ARG)</span>
<span class="udiff-line-removed">-         continue;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       p_stack_data[passed_regs] = avalue + i;</span>
<span class="udiff-line-removed">-       avalue[i] = stack + (passed_regs*FFI_SIZEOF_ARG);</span>
<span class="udiff-line-removed">-       ++passed_regs;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-modified-added">+       ffi_type *ty = arg_types[i];</span>
<span class="udiff-line-modified-added">+       size_t z = ty-&gt;size;</span>
<span class="udiff-line-modified-added">+       int t = ty-&gt;type;</span>
<span class="udiff-line-modified-added">+       void *valp;</span>
  
<span class="udiff-line-modified-removed">-   p_arg = cif-&gt;arg_types;</span>
<span class="udiff-line-removed">-   p_argv = avalue;</span>
<span class="udiff-line-removed">-   if (dir &lt; 0)</span>
<span class="udiff-line-modified-added">+       if (z &lt;= FFI_SIZEOF_ARG &amp;&amp; t != FFI_TYPE_STRUCT)</span>
      {
<span class="udiff-line-modified-removed">-       const int nargs = cif-&gt;nargs - 1;</span>
<span class="udiff-line-modified-removed">-       if (nargs &gt; 0)</span>
<span class="udiff-line-modified-added">+       if (t != FFI_TYPE_FLOAT &amp;&amp; narg_reg &lt; pabi-&gt;nregs)</span>
<span class="udiff-line-modified-added">+         valp = &amp;frame-&gt;regs[pabi-&gt;regs[narg_reg++]];</span>
<span class="udiff-line-added">+       else if (dir &lt; 0)</span>
        {
<span class="udiff-line-modified-removed">-         p_arg  += nargs;</span>
<span class="udiff-line-modified-removed">-         p_argv += nargs;</span>
<span class="udiff-line-modified-added">+           argp -= 4;</span>
<span class="udiff-line-modified-added">+           valp = argp;</span>
        }
<span class="udiff-line-added">+       else</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+           valp = argp;</span>
<span class="udiff-line-added">+           argp += 4;</span>
      }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   for (i = cif-&gt;nargs;</span>
<span class="udiff-line-removed">-        i != 0;</span>
<span class="udiff-line-removed">-        i--, p_arg += dir, p_argv += dir)</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+       else</span>
      {
<span class="udiff-line-modified-removed">- #ifdef GSTREAMER_LITE</span>
<span class="udiff-line-modified-removed">-       size_t z = 0;</span>
<span class="udiff-line-modified-removed">- #endif // GSTREAMER_LITE</span>
<span class="udiff-line-modified-removed">-       /* Align if necessary */</span>
<span class="udiff-line-modified-removed">-       if ((sizeof(void*) - 1) &amp; (size_t) argp)</span>
<span class="udiff-line-modified-removed">-         argp = (char *) ALIGN(argp, sizeof(void*));</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- #ifdef GSTREAMER_LITE</span>
<span class="udiff-line-modified-removed">-       z = (*p_arg)-&gt;size;</span>
<span class="udiff-line-modified-removed">- #else // GSTREAMER_LITE</span>
<span class="udiff-line-modified-removed">-       size_t z = (*p_arg)-&gt;size;</span>
<span class="udiff-line-modified-removed">- #endif // GSTREAMER_LITE</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- #ifdef X86_WIN64</span>
<span class="udiff-line-modified-removed">-       if (z &gt; FFI_SIZEOF_ARG</span>
<span class="udiff-line-modified-removed">-           || ((*p_arg)-&gt;type == FFI_TYPE_STRUCT</span>
<span class="udiff-line-modified-removed">-               &amp;&amp; (z &amp; (1 | 2 | 4 | 8)) == 0)</span>
<span class="udiff-line-removed">- #if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE</span>
<span class="udiff-line-removed">-           || ((*p_arg)-&gt;type == FFI_TYPE_LONGDOUBLE)</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-           )</span>
<span class="udiff-line-modified-added">+       size_t za = FFI_ALIGN (z, FFI_SIZEOF_ARG);</span>
<span class="udiff-line-modified-added">+       size_t align = FFI_SIZEOF_ARG;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       /* See the comment in ffi_call_int.  */</span>
<span class="udiff-line-modified-added">+       if (t == FFI_TYPE_STRUCT &amp;&amp; ty-&gt;alignment &gt;= 16)</span>
<span class="udiff-line-modified-added">+         align = 16;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       /* Issue 434: For thiscall and fastcall, if the paramter passed</span>
<span class="udiff-line-modified-added">+          as 64-bit integer or struct, all following integer paramters</span>
<span class="udiff-line-modified-added">+          will be passed on stack.  */</span>
<span class="udiff-line-modified-added">+       if ((cabi == FFI_THISCALL || cabi == FFI_FASTCALL)</span>
<span class="udiff-line-modified-added">+           &amp;&amp; (t == FFI_TYPE_SINT64</span>
<span class="udiff-line-modified-added">+           || t == FFI_TYPE_UINT64</span>
<span class="udiff-line-modified-added">+           || t == FFI_TYPE_STRUCT))</span>
<span class="udiff-line-modified-added">+         narg_reg = 2;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       if (dir &lt; 0)</span>
          {
<span class="udiff-line-modified-removed">-           z = FFI_SIZEOF_ARG;</span>
<span class="udiff-line-modified-removed">-           *p_argv = *(void **)argp;</span>
<span class="udiff-line-modified-added">+           /* ??? These reverse argument ABIs are probably too old</span>
<span class="udiff-line-modified-added">+          to have cared about alignment.  Someone should check.  */</span>
<span class="udiff-line-added">+           argp -= za;</span>
<span class="udiff-line-added">+           valp = argp;</span>
          }
        else
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-       if (passed_regs &gt; 0</span>
<span class="udiff-line-removed">-           &amp;&amp; z &lt;= FFI_SIZEOF_ARG</span>
<span class="udiff-line-removed">-           &amp;&amp; (p_argv == p_stack_data[0]</span>
<span class="udiff-line-removed">-             || p_argv == p_stack_data[1]</span>
<span class="udiff-line-removed">-             || p_argv == p_stack_data[2]))</span>
          {
<span class="udiff-line-modified-removed">-           /* Already assigned a register value */</span>
<span class="udiff-line-modified-removed">-           continue;</span>
<span class="udiff-line-modified-added">+           argp = (char *)FFI_ALIGN (argp, align);</span>
<span class="udiff-line-modified-added">+           valp = argp;</span>
<span class="udiff-line-added">+           argp += za;</span>
          }
<span class="udiff-line-removed">-       else</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-           /* because we&#39;re little endian, this is what it turns into.   */</span>
<span class="udiff-line-removed">-           *p_argv = (void*) argp;</span>
          }
  
<span class="udiff-line-modified-removed">- #ifdef X86_WIN64</span>
<span class="udiff-line-removed">-       argp += (z + sizeof(void*) - 1) &amp; ~(sizeof(void*) - 1);</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-       argp += z;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-modified-added">+       avalue[i] = valp;</span>
      }
  
<span class="udiff-line-modified-removed">-   return (size_t)argp - (size_t)stack;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-modified-added">+   frame-&gt;fun (cif, rvalue, avalue, frame-&gt;user_data);</span>
  
<span class="udiff-line-modified-removed">- #define FFI_INIT_TRAMPOLINE_WIN64(TRAMP,FUN,CTX,MASK) \</span>
<span class="udiff-line-modified-removed">- { unsigned char *__tramp = (unsigned char*)(TRAMP); \</span>
<span class="udiff-line-modified-removed">-    void*  __fun = (void*)(FUN); \</span>
<span class="udiff-line-modified-removed">-    void*  __ctx = (void*)(CTX); \</span>
<span class="udiff-line-removed">-    *(unsigned char*) &amp;__tramp[0] = 0x41; \</span>
<span class="udiff-line-removed">-    *(unsigned char*) &amp;__tramp[1] = 0xbb; \</span>
<span class="udiff-line-removed">-    *(unsigned int*) &amp;__tramp[2] = MASK; /* mov $mask, %r11 */ \</span>
<span class="udiff-line-removed">-    *(unsigned char*) &amp;__tramp[6] = 0x48; \</span>
<span class="udiff-line-removed">-    *(unsigned char*) &amp;__tramp[7] = 0xb8; \</span>
<span class="udiff-line-removed">-    *(void**) &amp;__tramp[8] = __ctx; /* mov __ctx, %rax */ \</span>
<span class="udiff-line-removed">-    *(unsigned char *)  &amp;__tramp[16] = 0x49; \</span>
<span class="udiff-line-removed">-    *(unsigned char *)  &amp;__tramp[17] = 0xba; \</span>
<span class="udiff-line-removed">-    *(void**) &amp;__tramp[18] = __fun; /* mov __fun, %r10 */ \</span>
<span class="udiff-line-removed">-    *(unsigned char *)  &amp;__tramp[26] = 0x41; \</span>
<span class="udiff-line-removed">-    *(unsigned char *)  &amp;__tramp[27] = 0xff; \</span>
<span class="udiff-line-removed">-    *(unsigned char *)  &amp;__tramp[28] = 0xe2; /* jmp %r10 */ \</span>
<span class="udiff-line-removed">-  }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- /* How to make a trampoline.  Derived from gcc/config/i386/i386.c. */</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #define FFI_INIT_TRAMPOLINE(TRAMP,FUN,CTX) \</span>
<span class="udiff-line-removed">- { unsigned char *__tramp = (unsigned char*)(TRAMP); \</span>
<span class="udiff-line-removed">-    unsigned int  __fun = (unsigned int)(FUN); \</span>
<span class="udiff-line-removed">-    unsigned int  __ctx = (unsigned int)(CTX); \</span>
<span class="udiff-line-removed">-    unsigned int  __dis = __fun - (__ctx + 10);  \</span>
<span class="udiff-line-removed">-    *(unsigned char*) &amp;__tramp[0] = 0xb8; \</span>
<span class="udiff-line-removed">-    *(unsigned int*)  &amp;__tramp[1] = __ctx; /* movl __ctx, %eax */ \</span>
<span class="udiff-line-removed">-    *(unsigned char*) &amp;__tramp[5] = 0xe9; \</span>
<span class="udiff-line-removed">-    *(unsigned int*)  &amp;__tramp[6] = __dis; /* jmp __fun  */ \</span>
<span class="udiff-line-removed">-  }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #define FFI_INIT_TRAMPOLINE_RAW_THISCALL(TRAMP,FUN,CTX,SIZE) \</span>
<span class="udiff-line-removed">- { unsigned char *__tramp = (unsigned char*)(TRAMP); \</span>
<span class="udiff-line-removed">-    unsigned int  __fun = (unsigned int)(FUN); \</span>
<span class="udiff-line-removed">-    unsigned int  __ctx = (unsigned int)(CTX); \</span>
<span class="udiff-line-removed">-    unsigned int  __dis = __fun - (__ctx + 49);  \</span>
<span class="udiff-line-removed">-    unsigned short __size = (unsigned short)(SIZE); \</span>
<span class="udiff-line-removed">-    *(unsigned int *) &amp;__tramp[0] = 0x8324048b;      /* mov (%esp), %eax */ \</span>
<span class="udiff-line-removed">-    *(unsigned int *) &amp;__tramp[4] = 0x4c890cec;      /* sub $12, %esp */ \</span>
<span class="udiff-line-removed">-    *(unsigned int *) &amp;__tramp[8] = 0x04890424;      /* mov %ecx, 4(%esp) */ \</span>
<span class="udiff-line-removed">-    *(unsigned char*) &amp;__tramp[12] = 0x24;           /* mov %eax, (%esp) */ \</span>
<span class="udiff-line-removed">-    *(unsigned char*) &amp;__tramp[13] = 0xb8; \</span>
<span class="udiff-line-removed">-    *(unsigned int *) &amp;__tramp[14] = __size;         /* mov __size, %eax */ \</span>
<span class="udiff-line-removed">-    *(unsigned int *) &amp;__tramp[18] = 0x08244c8d;     /* lea 8(%esp), %ecx */ \</span>
<span class="udiff-line-removed">-    *(unsigned int *) &amp;__tramp[22] = 0x4802e8c1;     /* shr $2, %eax ; dec %eax */ \</span>
<span class="udiff-line-removed">-    *(unsigned short*) &amp;__tramp[26] = 0x0b74;        /* jz 1f */ \</span>
<span class="udiff-line-removed">-    *(unsigned int *) &amp;__tramp[28] = 0x8908518b;     /* 2b: mov 8(%ecx), %edx */ \</span>
<span class="udiff-line-removed">-    *(unsigned int *) &amp;__tramp[32] = 0x04c18311;     /* mov %edx, (%ecx) ; add $4, %ecx */ \</span>
<span class="udiff-line-removed">-    *(unsigned char*) &amp;__tramp[36] = 0x48;           /* dec %eax */ \</span>
<span class="udiff-line-removed">-    *(unsigned short*) &amp;__tramp[37] = 0xf575;        /* jnz 2b ; 1f: */ \</span>
<span class="udiff-line-removed">-    *(unsigned char*) &amp;__tramp[39] = 0xb8; \</span>
<span class="udiff-line-removed">-    *(unsigned int*)  &amp;__tramp[40] = __ctx;          /* movl __ctx, %eax */ \</span>
<span class="udiff-line-removed">-    *(unsigned char *)  &amp;__tramp[44] = 0xe8; \</span>
<span class="udiff-line-removed">-    *(unsigned int*)  &amp;__tramp[45] = __dis;          /* call __fun  */ \</span>
<span class="udiff-line-removed">-    *(unsigned char*)  &amp;__tramp[49] = 0xc2;          /* ret  */ \</span>
<span class="udiff-line-removed">-    *(unsigned short*)  &amp;__tramp[50] = (__size + 8); /* ret (__size + 8)  */ \</span>
<span class="udiff-line-removed">-  }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #define FFI_INIT_TRAMPOLINE_WIN32(TRAMP,FUN,CTX)  \</span>
<span class="udiff-line-removed">- { unsigned char *__tramp = (unsigned char*)(TRAMP); \</span>
<span class="udiff-line-removed">-    unsigned int  __fun = (unsigned int)(FUN); \</span>
<span class="udiff-line-removed">-    unsigned int  __ctx = (unsigned int)(CTX); \</span>
<span class="udiff-line-removed">-    unsigned int  __dis = __fun - (__ctx + 10); \</span>
<span class="udiff-line-removed">-    *(unsigned char*) &amp;__tramp[0] = 0x68; \</span>
<span class="udiff-line-removed">-    *(unsigned int*)  &amp;__tramp[1] = __ctx; /* push __ctx */ \</span>
<span class="udiff-line-removed">-    *(unsigned char*) &amp;__tramp[5] = 0xe9; \</span>
<span class="udiff-line-removed">-    *(unsigned int*)  &amp;__tramp[6] = __dis; /* jmp __fun  */ \</span>
<span class="udiff-line-modified-added">+   if (cabi == FFI_STDCALL)</span>
<span class="udiff-line-modified-added">+     return flags + (cif-&gt;bytes &lt;&lt; X86_RET_POP_SHIFT);</span>
<span class="udiff-line-modified-added">+   else</span>
<span class="udiff-line-modified-added">+     return flags;</span>
   }
  
<span class="udiff-line-removed">- /* the cif must already be prep&#39;ed */</span>
<span class="udiff-line-removed">- </span>
  ffi_status
  ffi_prep_closure_loc (ffi_closure* closure,
                        ffi_cif* cif,
                        void (*fun)(ffi_cif*,void*,void**,void*),
                        void *user_data,
                        void *codeloc)
  {
<span class="udiff-line-modified-removed">- #ifdef X86_WIN64</span>
<span class="udiff-line-modified-removed">- #define ISFLOAT(IDX) (cif-&gt;arg_types[IDX]-&gt;type == FFI_TYPE_FLOAT || cif-&gt;arg_types[IDX]-&gt;type == FFI_TYPE_DOUBLE)</span>
<span class="udiff-line-modified-removed">- #define FLAG(IDX) (cif-&gt;nargs&gt;(IDX)&amp;&amp;ISFLOAT(IDX)?(1&lt;&lt;(IDX)):0)</span>
<span class="udiff-line-modified-removed">-   if (cif-&gt;abi == FFI_WIN64)</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-removed">-       int mask = FLAG(0)|FLAG(1)|FLAG(2)|FLAG(3);</span>
<span class="udiff-line-removed">-       FFI_INIT_TRAMPOLINE_WIN64 (&amp;closure-&gt;tramp[0],</span>
<span class="udiff-line-removed">-                                  &amp;ffi_closure_win64,</span>
<span class="udiff-line-removed">-                                  codeloc, mask);</span>
<span class="udiff-line-removed">-       /* make sure we can execute here */</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-   if (cif-&gt;abi == FFI_SYSV)</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-       FFI_INIT_TRAMPOLINE (&amp;closure-&gt;tramp[0],</span>
<span class="udiff-line-removed">-                            &amp;ffi_closure_SYSV,</span>
<span class="udiff-line-removed">-                            (void*)codeloc);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   else if (cif-&gt;abi == FFI_REGISTER)</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-       FFI_INIT_TRAMPOLINE_WIN32 (&amp;closure-&gt;tramp[0],</span>
<span class="udiff-line-removed">-                                    &amp;ffi_closure_REGISTER,</span>
<span class="udiff-line-removed">-                                    (void*)codeloc);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   else if (cif-&gt;abi == FFI_FASTCALL)</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-       FFI_INIT_TRAMPOLINE_WIN32 (&amp;closure-&gt;tramp[0],</span>
<span class="udiff-line-removed">-                                    &amp;ffi_closure_FASTCALL,</span>
<span class="udiff-line-removed">-                                    (void*)codeloc);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   else if (cif-&gt;abi == FFI_THISCALL)</span>
<span class="udiff-line-modified-added">+   char *tramp = closure-&gt;tramp;</span>
<span class="udiff-line-modified-added">+   void (*dest)(void);</span>
<span class="udiff-line-modified-added">+   int op = 0xb8;  /* movl imm, %eax */</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   switch (cif-&gt;abi)</span>
      {
<span class="udiff-line-modified-removed">-       FFI_INIT_TRAMPOLINE_WIN32 (&amp;closure-&gt;tramp[0],</span>
<span class="udiff-line-modified-removed">-                                    &amp;ffi_closure_THISCALL,</span>
<span class="udiff-line-modified-removed">-                                    (void*)codeloc);</span>
<span class="udiff-line-modified-added">+     case FFI_SYSV:</span>
<span class="udiff-line-modified-added">+     case FFI_THISCALL:</span>
<span class="udiff-line-modified-added">+     case FFI_FASTCALL:</span>
<span class="udiff-line-added">+     case FFI_MS_CDECL:</span>
<span class="udiff-line-added">+       dest = ffi_closure_i386;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_STDCALL:</span>
<span class="udiff-line-added">+     case FFI_PASCAL:</span>
<span class="udiff-line-added">+       dest = ffi_closure_STDCALL;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_REGISTER:</span>
<span class="udiff-line-added">+       dest = ffi_closure_REGISTER;</span>
<span class="udiff-line-added">+       op = 0x68;  /* pushl imm */</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     default:</span>
<span class="udiff-line-added">+       return FFI_BAD_ABI;</span>
      }
<span class="udiff-line-modified-removed">-   else if (cif-&gt;abi == FFI_STDCALL || cif-&gt;abi == FFI_PASCAL)</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       FFI_INIT_TRAMPOLINE_WIN32 (&amp;closure-&gt;tramp[0],</span>
<span class="udiff-line-modified-removed">-                                    &amp;ffi_closure_STDCALL,</span>
<span class="udiff-line-modified-removed">-                                    (void*)codeloc);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   /* movl or pushl immediate.  */</span>
<span class="udiff-line-modified-added">+   tramp[0] = op;</span>
<span class="udiff-line-modified-added">+   *(void **)(tramp + 1) = codeloc;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   /* jmp dest */</span>
<span class="udiff-line-added">+   tramp[5] = 0xe9;</span>
<span class="udiff-line-added">+   *(unsigned *)(tramp + 6) = (unsigned)dest - ((unsigned)codeloc + 10);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   closure-&gt;cif = cif;</span>
<span class="udiff-line-added">+   closure-&gt;fun = fun;</span>
<span class="udiff-line-added">+   closure-&gt;user_data = user_data;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return FFI_OK;</span>
      }
<span class="udiff-line-modified-removed">- #ifdef X86_WIN32</span>
<span class="udiff-line-modified-removed">-   else if (cif-&gt;abi == FFI_MS_CDECL)</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ void FFI_HIDDEN ffi_go_closure_EAX(void);</span>
<span class="udiff-line-added">+ void FFI_HIDDEN ffi_go_closure_ECX(void);</span>
<span class="udiff-line-added">+ void FFI_HIDDEN ffi_go_closure_STDCALL(void);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ ffi_status</span>
<span class="udiff-line-added">+ ffi_prep_go_closure (ffi_go_closure* closure, ffi_cif* cif,</span>
<span class="udiff-line-added">+              void (*fun)(ffi_cif*,void*,void**,void*))</span>
      {
<span class="udiff-line-modified-removed">-       FFI_INIT_TRAMPOLINE (&amp;closure-&gt;tramp[0],</span>
<span class="udiff-line-modified-removed">-                            &amp;ffi_closure_SYSV,</span>
<span class="udiff-line-modified-removed">-                            (void*)codeloc);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- #endif /* X86_WIN32 */</span>
<span class="udiff-line-removed">- #endif /* !X86_WIN64 */</span>
<span class="udiff-line-removed">-   else</span>
<span class="udiff-line-modified-added">+   void (*dest)(void);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   switch (cif-&gt;abi)</span>
      {
<span class="udiff-line-added">+     case FFI_SYSV:</span>
<span class="udiff-line-added">+     case FFI_MS_CDECL:</span>
<span class="udiff-line-added">+       dest = ffi_go_closure_ECX;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_THISCALL:</span>
<span class="udiff-line-added">+     case FFI_FASTCALL:</span>
<span class="udiff-line-added">+       dest = ffi_go_closure_EAX;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_STDCALL:</span>
<span class="udiff-line-added">+     case FFI_PASCAL:</span>
<span class="udiff-line-added">+       dest = ffi_go_closure_STDCALL;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_REGISTER:</span>
<span class="udiff-line-added">+     default:</span>
        return FFI_BAD_ABI;
      }
  
<span class="udiff-line-modified-removed">-   closure-&gt;cif  = cif;</span>
<span class="udiff-line-modified-removed">-   closure-&gt;user_data = user_data;</span>
<span class="udiff-line-modified-removed">-   closure-&gt;fun  = fun;</span>
<span class="udiff-line-modified-added">+   closure-&gt;tramp = dest;</span>
<span class="udiff-line-modified-added">+   closure-&gt;cif = cif;</span>
<span class="udiff-line-modified-added">+   closure-&gt;fun = fun;</span>
  
    return FFI_OK;
  }
  
  /* ------- Native raw API support -------------------------------- */
  
  #if !FFI_NO_RAW_API
  
<span class="udiff-line-added">+ void FFI_HIDDEN ffi_closure_raw_SYSV(void);</span>
<span class="udiff-line-added">+ void FFI_HIDDEN ffi_closure_raw_THISCALL(void);</span>
<span class="udiff-line-added">+ </span>
  ffi_status
<span class="udiff-line-modified-removed">- ffi_prep_raw_closure_loc (ffi_raw_closure* closure,</span>
<span class="udiff-line-modified-removed">-                           ffi_cif* cif,</span>
<span class="udiff-line-modified-added">+ ffi_prep_raw_closure_loc (ffi_raw_closure *closure,</span>
<span class="udiff-line-modified-added">+                           ffi_cif *cif,</span>
                            void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
                            void *user_data,
                            void *codeloc)
  {
<span class="udiff-line-added">+   char *tramp = closure-&gt;tramp;</span>
<span class="udiff-line-added">+   void (*dest)(void);</span>
    int i;
  
<span class="udiff-line-modified-removed">-   if (cif-&gt;abi != FFI_SYSV</span>
<span class="udiff-line-removed">- #ifdef X86_WIN32</span>
<span class="udiff-line-removed">-       &amp;&amp; cif-&gt;abi != FFI_THISCALL</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-      )</span>
<span class="udiff-line-removed">-     return FFI_BAD_ABI;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   /* we currently don&#39;t support certain kinds of arguments for raw</span>
<span class="udiff-line-modified-added">+   /* We currently don&#39;t support certain kinds of arguments for raw</span>
       closures.  This should be implemented by a separate assembly
       language routine, since it would require argument processing,
       something we don&#39;t do now for performance.  */
<span class="udiff-line-removed">- </span>
    for (i = cif-&gt;nargs-1; i &gt;= 0; i--)
<span class="udiff-line-added">+     switch (cif-&gt;arg_types[i]-&gt;type)</span>
      {
<span class="udiff-line-modified-removed">-       FFI_ASSERT (cif-&gt;arg_types[i]-&gt;type != FFI_TYPE_STRUCT);</span>
<span class="udiff-line-modified-removed">-       FFI_ASSERT (cif-&gt;arg_types[i]-&gt;type != FFI_TYPE_LONGDOUBLE);</span>
<span class="udiff-line-modified-added">+       case FFI_TYPE_STRUCT:</span>
<span class="udiff-line-modified-added">+       case FFI_TYPE_LONGDOUBLE:</span>
<span class="udiff-line-added">+     return FFI_BAD_TYPEDEF;</span>
      }
  
<span class="udiff-line-modified-removed">- #ifdef X86_WIN32</span>
<span class="udiff-line-removed">-   if (cif-&gt;abi == FFI_SYSV)</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-   FFI_INIT_TRAMPOLINE (&amp;closure-&gt;tramp[0], &amp;ffi_closure_raw_SYSV,</span>
<span class="udiff-line-removed">-                        codeloc);</span>
<span class="udiff-line-removed">- #ifdef X86_WIN32</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   else if (cif-&gt;abi == FFI_THISCALL)</span>
<span class="udiff-line-modified-added">+   switch (cif-&gt;abi)</span>
      {
<span class="udiff-line-modified-removed">-       FFI_INIT_TRAMPOLINE_RAW_THISCALL (&amp;closure-&gt;tramp[0], &amp;ffi_closure_raw_THISCALL, codeloc, cif-&gt;bytes);</span>
<span class="udiff-line-modified-added">+     case FFI_THISCALL:</span>
<span class="udiff-line-added">+       dest = ffi_closure_raw_THISCALL;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     case FFI_SYSV:</span>
<span class="udiff-line-added">+       dest = ffi_closure_raw_SYSV;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     default:</span>
<span class="udiff-line-added">+       return FFI_BAD_ABI;</span>
      }
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-removed">-   closure-&gt;cif  = cif;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   /* movl imm, %eax.  */</span>
<span class="udiff-line-added">+   tramp[0] = 0xb8;</span>
<span class="udiff-line-added">+   *(void **)(tramp + 1) = codeloc;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   /* jmp dest */</span>
<span class="udiff-line-added">+   tramp[5] = 0xe9;</span>
<span class="udiff-line-added">+   *(unsigned *)(tramp + 6) = (unsigned)dest - ((unsigned)codeloc + 10);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   closure-&gt;cif = cif;</span>
<span class="udiff-line-added">+   closure-&gt;fun = fun;</span>
    closure-&gt;user_data = user_data;
<span class="udiff-line-removed">-   closure-&gt;fun  = fun;</span>
  
    return FFI_OK;
  }
  
<span class="udiff-line-modified-removed">- static unsigned int</span>
<span class="udiff-line-modified-removed">- ffi_prep_args_raw(char *stack, extended_cif *ecif)</span>
<span class="udiff-line-modified-added">+ void</span>
<span class="udiff-line-modified-added">+ ffi_raw_call(ffi_cif *cif, void (*fn)(void), void *rvalue, ffi_raw *avalue)</span>
  {
<span class="udiff-line-modified-removed">-   const ffi_cif *cif = ecif-&gt;cif;</span>
<span class="udiff-line-modified-removed">-   unsigned int i, passed_regs = 0;</span>
<span class="udiff-line-modified-added">+   size_t rsize, bytes;</span>
<span class="udiff-line-modified-added">+   struct call_frame *frame;</span>
<span class="udiff-line-added">+   char *stack, *argp;</span>
<span class="udiff-line-added">+   ffi_type **arg_types;</span>
<span class="udiff-line-added">+   int flags, cabi, i, n, narg_reg;</span>
<span class="udiff-line-added">+   const struct abi_params *pabi;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   flags = cif-&gt;flags;</span>
<span class="udiff-line-added">+   cabi = cif-&gt;abi;</span>
<span class="udiff-line-added">+   pabi = &amp;abi_params[cabi];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   rsize = 0;</span>
<span class="udiff-line-added">+   if (rvalue == NULL)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       switch (flags)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+     case X86_RET_FLOAT:</span>
<span class="udiff-line-added">+     case X86_RET_DOUBLE:</span>
<span class="udiff-line-added">+     case X86_RET_LDOUBLE:</span>
<span class="udiff-line-added">+     case X86_RET_STRUCTPOP:</span>
<span class="udiff-line-added">+     case X86_RET_STRUCTARG:</span>
<span class="udiff-line-added">+       /* The float cases need to pop the 387 stack.</span>
<span class="udiff-line-added">+          The struct cases need to pass a valid pointer to the callee.  */</span>
<span class="udiff-line-added">+       rsize = cif-&gt;rtype-&gt;size;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     default:</span>
<span class="udiff-line-added">+       /* We can pretend that the callee returns nothing.  */</span>
<span class="udiff-line-added">+       flags = X86_RET_VOID;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">- #ifndef X86_WIN64</span>
<span class="udiff-line-modified-removed">-   const unsigned int abi = cif-&gt;abi;</span>
<span class="udiff-line-modified-removed">-   const unsigned int max_regs = (abi == FFI_THISCALL) ? 1</span>
<span class="udiff-line-modified-removed">-                               : (abi == FFI_FASTCALL) ? 2</span>
<span class="udiff-line-modified-removed">-                               : (abi == FFI_REGISTER) ? 3</span>
<span class="udiff-line-modified-removed">-                               : 0;</span>
<span class="udiff-line-modified-added">+   bytes = STACK_ALIGN (cif-&gt;bytes);</span>
<span class="udiff-line-modified-added">+   argp = stack =</span>
<span class="udiff-line-modified-added">+       (void *)((uintptr_t)alloca(bytes + sizeof(*frame) + rsize + 15) &amp; ~16);</span>
<span class="udiff-line-modified-added">+   frame = (struct call_frame *)(stack + bytes);</span>
<span class="udiff-line-modified-added">+   if (rsize)</span>
<span class="udiff-line-modified-added">+     rvalue = frame + 1;</span>
  
<span class="udiff-line-modified-removed">-   if (cif-&gt;flags == FFI_TYPE_STRUCT)</span>
<span class="udiff-line-modified-removed">-     ++passed_regs;</span>
<span class="udiff-line-modified-added">+   frame-&gt;fn = fn;</span>
<span class="udiff-line-modified-added">+   frame-&gt;flags = flags;</span>
<span class="udiff-line-added">+   frame-&gt;rvalue = rvalue;</span>
  
<span class="udiff-line-modified-removed">-   for (i = 0; i &lt; cif-&gt;nargs &amp;&amp; passed_regs &lt;= max_regs; i++)</span>
<span class="udiff-line-modified-added">+   narg_reg = 0;</span>
<span class="udiff-line-added">+   switch (flags)</span>
      {
<span class="udiff-line-modified-removed">- #ifdef GSTREAMER_LITE</span>
<span class="udiff-line-modified-removed">-       size_t sz = 0;</span>
<span class="udiff-line-modified-removed">- #endif // GSTREAMER_LITE</span>
<span class="udiff-line-modified-removed">-       if (cif-&gt;arg_types[i]-&gt;type == FFI_TYPE_FLOAT</span>
<span class="udiff-line-modified-removed">-          || cif-&gt;arg_types[i]-&gt;type == FFI_TYPE_STRUCT)</span>
<span class="udiff-line-modified-removed">-         continue;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">- #ifdef GSTREAMER_LITE</span>
<span class="udiff-line-removed">-       sz = cif-&gt;arg_types[i]-&gt;size;</span>
<span class="udiff-line-removed">- #else // GSTREAMER_LITE</span>
<span class="udiff-line-removed">-       size_t sz = cif-&gt;arg_types[i]-&gt;size;</span>
<span class="udiff-line-removed">- #endif // GSTREAMER_LITE</span>
<span class="udiff-line-removed">-       if (sz == 0 || sz &gt; FFI_SIZEOF_ARG)</span>
<span class="udiff-line-removed">-         continue;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       ++passed_regs;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   memcpy (stack, ecif-&gt;avalue, cif-&gt;bytes);</span>
<span class="udiff-line-removed">-   return passed_regs;</span>
<span class="udiff-line-modified-added">+     case X86_RET_STRUCTARG:</span>
<span class="udiff-line-modified-added">+       /* The pointer is passed as the first argument.  */</span>
<span class="udiff-line-modified-added">+       if (pabi-&gt;nregs &gt; 0)</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       frame-&gt;regs[pabi-&gt;regs[0]] = (unsigned)rvalue;</span>
<span class="udiff-line-modified-added">+       narg_reg = 1;</span>
<span class="udiff-line-modified-added">+       break;</span>
  }
<span class="udiff-line-added">+       /* fallthru */</span>
<span class="udiff-line-added">+     case X86_RET_STRUCTPOP:</span>
<span class="udiff-line-added">+       *(void **)argp = rvalue;</span>
<span class="udiff-line-added">+       argp += sizeof(void *);</span>
<span class="udiff-line-added">+       bytes -= sizeof(void *);</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     }</span>
  
<span class="udiff-line-modified-removed">- /* we borrow this routine from libffi (it must be changed, though, to</span>
<span class="udiff-line-modified-removed">-  * actually call the function passed in the first argument.  as of</span>
<span class="udiff-line-removed">-  * libffi-1.20, this is not the case.)</span>
<span class="udiff-line-removed">-  */</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void</span>
<span class="udiff-line-removed">- ffi_raw_call(ffi_cif *cif, void (*fn)(void), void *rvalue, ffi_raw *fake_avalue)</span>
<span class="udiff-line-modified-added">+   arg_types = cif-&gt;arg_types;</span>
<span class="udiff-line-modified-added">+   for (i = 0, n = cif-&gt;nargs; narg_reg &lt; pabi-&gt;nregs &amp;&amp; i &lt; n; i++)</span>
  {
<span class="udiff-line-modified-removed">-   extended_cif ecif;</span>
<span class="udiff-line-modified-removed">-   void **avalue = (void **)fake_avalue;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-   ecif.cif = cif;</span>
<span class="udiff-line-removed">-   ecif.avalue = avalue;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   /* If the return value is a struct and we don&#39;t have a return */</span>
<span class="udiff-line-removed">-   /* value address then we need to make one                     */</span>
<span class="udiff-line-modified-added">+       ffi_type *ty = arg_types[i];</span>
<span class="udiff-line-modified-added">+       size_t z = ty-&gt;size;</span>
<span class="udiff-line-modified-added">+       int t = ty-&gt;type;</span>
  
<span class="udiff-line-modified-removed">-   if (rvalue == NULL</span>
<span class="udiff-line-removed">-       &amp;&amp; (cif-&gt;flags == FFI_TYPE_STRUCT</span>
<span class="udiff-line-removed">-           || cif-&gt;flags == FFI_TYPE_MS_STRUCT))</span>
<span class="udiff-line-modified-added">+       if (z &lt;= FFI_SIZEOF_ARG &amp;&amp; t != FFI_TYPE_STRUCT &amp;&amp; t != FFI_TYPE_FLOAT)</span>
      {
<span class="udiff-line-modified-removed">-       ecif.rvalue = alloca(cif-&gt;rtype-&gt;size);</span>
<span class="udiff-line-modified-added">+       ffi_arg val = extend_basic_type (avalue, t);</span>
<span class="udiff-line-added">+       frame-&gt;regs[pabi-&gt;regs[narg_reg++]] = val;</span>
<span class="udiff-line-added">+       z = FFI_SIZEOF_ARG;</span>
      }
    else
<span class="udiff-line-removed">-     ecif.rvalue = rvalue;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   switch (cif-&gt;abi)</span>
      {
<span class="udiff-line-modified-removed">- #ifndef X86_WIN32</span>
<span class="udiff-line-modified-removed">-     case FFI_SYSV:</span>
<span class="udiff-line-modified-removed">-       ffi_call_SYSV(ffi_prep_args_raw, &amp;ecif, cif-&gt;bytes, cif-&gt;flags,</span>
<span class="udiff-line-removed">-                     ecif.rvalue, fn);</span>
<span class="udiff-line-removed">-       break;</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">-     case FFI_SYSV:</span>
<span class="udiff-line-removed">-     case FFI_MS_CDECL:</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- #ifndef X86_WIN64</span>
<span class="udiff-line-removed">-     case FFI_STDCALL:</span>
<span class="udiff-line-removed">-     case FFI_THISCALL:</span>
<span class="udiff-line-removed">-     case FFI_FASTCALL:</span>
<span class="udiff-line-removed">-     case FFI_PASCAL:</span>
<span class="udiff-line-removed">-     case FFI_REGISTER:</span>
<span class="udiff-line-removed">-       ffi_call_win32(ffi_prep_args_raw, &amp;ecif, cif-&gt;abi, cif-&gt;bytes, cif-&gt;flags,</span>
<span class="udiff-line-removed">-                      ecif.rvalue, fn);</span>
<span class="udiff-line-removed">-       break;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-     default:</span>
<span class="udiff-line-removed">-       FFI_ASSERT(0);</span>
<span class="udiff-line-removed">-       break;</span>
<span class="udiff-line-modified-added">+       memcpy (argp, avalue, z);</span>
<span class="udiff-line-modified-added">+       z = FFI_ALIGN (z, FFI_SIZEOF_ARG);</span>
<span class="udiff-line-modified-added">+       argp += z;</span>
      }
<span class="udiff-line-added">+       avalue += z;</span>
<span class="udiff-line-added">+       bytes -= z;</span>
  }
<span class="udiff-line-added">+   if (i &lt; n)</span>
<span class="udiff-line-added">+     memcpy (argp, avalue, bytes);</span>
  
<span class="udiff-line-modified-removed">- #endif</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- #endif /* !__x86_64__  || X86_WIN64 */</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+   ffi_call_i386 (frame, stack);</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-modified-added">+ #endif /* !FFI_NO_RAW_API */</span>
<span class="udiff-line-modified-added">+ #endif /* __i386__ */</span>
</pre>
<center><a href="../types.c.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ffi64.c.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
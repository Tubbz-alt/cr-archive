<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstvalue.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) &lt;2003&gt; David A. Schleef &lt;ds@schleef.org&gt;
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Library General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Library General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Library General Public
  15  * License along with this library; if not, write to the
  16  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  17  * Boston, MA 02110-1301, USA.
  18  */
  19 
  20 /**
  21  * SECTION:gstvalue
  22  * @title: GstValue
  23  * @short_description: GValue implementations specific
  24  * to GStreamer
  25  *
  26  * GValue implementations specific to GStreamer.
  27  *
  28  * Note that operations on the same #GValue from multiple threads may lead to
  29  * undefined behaviour.
  30  */
  31 
  32 /* Suppress warnings for GValueAraray */
  33 #define GLIB_DISABLE_DEPRECATION_WARNINGS
  34 
  35 #ifdef HAVE_CONFIG_H
  36 #include &quot;config.h&quot;
  37 #endif
  38 #include &lt;math.h&gt;
  39 #include &lt;stdio.h&gt;
  40 #include &lt;stdlib.h&gt;
  41 #include &lt;string.h&gt;
  42 #include &lt;ctype.h&gt;
  43 
  44 #include &quot;gst_private.h&quot;
  45 #include &quot;glib-compat-private.h&quot;
  46 #include &lt;gst/gst.h&gt;
  47 #include &lt;gobject/gvaluecollector.h&gt;
  48 #include &quot;gstutils.h&quot;
  49 
  50 /* GstValueUnionFunc:
  51  * @dest: a #GValue for the result
  52  * @value1: a #GValue operand
  53  * @value2: a #GValue operand
  54  *
  55  * Used by gst_value_union() to perform unification for a specific #GValue
  56  * type. Register a new implementation with gst_value_register_union_func().
  57  *
  58  * Returns: %TRUE if a union was successful
  59  */
  60 typedef gboolean (*GstValueUnionFunc) (GValue * dest,
  61     const GValue * value1, const GValue * value2);
  62 
  63 /* GstValueIntersectFunc:
  64  * @dest: (out caller-allocates): a #GValue for the result
  65  * @value1: a #GValue operand
  66  * @value2: a #GValue operand
  67  *
  68  * Used by gst_value_intersect() to perform intersection for a specific #GValue
  69  * type. If the intersection is non-empty, the result is
  70  * placed in @dest and %TRUE is returned.  If the intersection is
  71  * empty, @dest is unmodified and %FALSE is returned.
  72  * Register a new implementation with gst_value_register_intersect_func().
  73  *
  74  * Returns: %TRUE if the values can intersect
  75  */
  76 typedef gboolean (*GstValueIntersectFunc) (GValue * dest,
  77     const GValue * value1, const GValue * value2);
  78 
  79 /* GstValueSubtractFunc:
  80  * @dest: (out caller-allocates): a #GValue for the result
  81  * @minuend: a #GValue operand
  82  * @subtrahend: a #GValue operand
  83  *
  84  * Used by gst_value_subtract() to perform subtraction for a specific #GValue
  85  * type. Register a new implementation with gst_value_register_subtract_func().
  86  *
  87  * Returns: %TRUE if the subtraction is not empty
  88  */
  89 typedef gboolean (*GstValueSubtractFunc) (GValue * dest,
  90     const GValue * minuend, const GValue * subtrahend);
  91 
  92 static void gst_value_register_union_func (GType type1,
  93     GType type2, GstValueUnionFunc func);
  94 static void gst_value_register_intersect_func (GType type1,
  95     GType type2, GstValueIntersectFunc func);
  96 static void gst_value_register_subtract_func (GType minuend_type,
  97     GType subtrahend_type, GstValueSubtractFunc func);
  98 
  99 static gboolean _priv_gst_value_parse_list (gchar * s, gchar ** after,
 100     GValue * value, GType type);
 101 static gboolean _priv_gst_value_parse_array (gchar * s, gchar ** after,
 102     GValue * value, GType type);
 103 
 104 typedef struct _GstValueUnionInfo GstValueUnionInfo;
 105 struct _GstValueUnionInfo
 106 {
 107   GType type1;
 108   GType type2;
 109   GstValueUnionFunc func;
 110 };
 111 
 112 typedef struct _GstValueIntersectInfo GstValueIntersectInfo;
 113 struct _GstValueIntersectInfo
 114 {
 115   GType type1;
 116   GType type2;
 117   GstValueIntersectFunc func;
 118 };
 119 
 120 typedef struct _GstValueSubtractInfo GstValueSubtractInfo;
 121 struct _GstValueSubtractInfo
 122 {
 123   GType minuend;
 124   GType subtrahend;
 125   GstValueSubtractFunc func;
 126 };
 127 
 128 struct _GstFlagSetClass
 129 {
 130   GTypeClass parent;
 131   GType flags_type;             /* Type of the GFlags this flagset carries (can be 0) */
 132 };
 133 
 134 typedef struct _GstFlagSetClass GstFlagSetClass;
 135 
 136 typedef struct _GstValueAbbreviation GstValueAbbreviation;
 137 
 138 struct _GstValueAbbreviation
 139 {
 140   const gchar *type_name;
 141   GType type;
 142 };
 143 
 144 #define FUNDAMENTAL_TYPE_ID_MAX \
 145     (G_TYPE_FUNDAMENTAL_MAX &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT)
 146 #define FUNDAMENTAL_TYPE_ID(type) \
 147     ((type) &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT)
 148 
 149 #define VALUE_LIST_ARRAY(v) ((GArray *) (v)-&gt;data[0].v_pointer)
 150 #define VALUE_LIST_SIZE(v) (VALUE_LIST_ARRAY(v)-&gt;len)
 151 #define VALUE_LIST_GET_VALUE(v, index) ((const GValue *) &amp;g_array_index (VALUE_LIST_ARRAY(v), GValue, (index)))
 152 
 153 static GArray *gst_value_table;
 154 static GHashTable *gst_value_hash;
 155 static GstValueTable *gst_value_tables_fundamental[FUNDAMENTAL_TYPE_ID_MAX + 1];
 156 static GArray *gst_value_union_funcs;
 157 static GArray *gst_value_intersect_funcs;
 158 static GArray *gst_value_subtract_funcs;
 159 
 160 /* Forward declarations */
 161 static gchar *gst_value_serialize_fraction (const GValue * value);
 162 
 163 static GstValueCompareFunc gst_value_get_compare_func (const GValue * value1);
 164 static gint gst_value_compare_with_func (const GValue * value1,
 165     const GValue * value2, GstValueCompareFunc compare);
 166 
 167 static gchar *gst_string_wrap (const gchar * s);
 168 static gchar *gst_string_unwrap (const gchar * s);
 169 
 170 static void gst_value_move (GValue * dest, GValue * src);
 171 static void _gst_value_list_append_and_take_value (GValue * value,
 172     GValue * append_value);
 173 static void _gst_value_array_append_and_take_value (GValue * value,
 174     GValue * append_value);
 175 
 176 static inline GstValueTable *
 177 gst_value_hash_lookup_type (GType type)
 178 {
 179   if (G_LIKELY (G_TYPE_IS_FUNDAMENTAL (type)))
 180     return gst_value_tables_fundamental[FUNDAMENTAL_TYPE_ID (type)];
 181   else
 182     return g_hash_table_lookup (gst_value_hash, (gpointer) type);
 183 }
 184 
 185 static void
 186 gst_value_hash_add_type (GType type, const GstValueTable * table)
 187 {
 188   if (G_TYPE_IS_FUNDAMENTAL (type))
 189     gst_value_tables_fundamental[FUNDAMENTAL_TYPE_ID (type)] = (gpointer) table;
 190 
 191   g_hash_table_insert (gst_value_hash, (gpointer) type, (gpointer) table);
 192 }
 193 
 194 /********
 195  * list *
 196  ********/
 197 
 198 /* two helper functions to serialize/stringify any type of list
 199  * regular lists are done with { }, arrays with &lt; &gt;
 200  */
 201 gchar *
 202 _priv_gst_value_serialize_any_list (const GValue * value, const gchar * begin,
 203     const gchar * end, gboolean print_type)
 204 {
 205   guint i;
 206   GArray *array = value-&gt;data[0].v_pointer;
 207   GString *s;
 208   GValue *v;
 209   gchar *s_val;
 210   guint alen = array-&gt;len;
 211 
 212   /* estimate minimum string length to minimise re-allocs in GString */
 213   s = g_string_sized_new (2 + (6 * alen) + 2);
 214   g_string_append (s, begin);
 215   for (i = 0; i &lt; alen; i++) {
 216     v = &amp;g_array_index (array, GValue, i);
 217     s_val = gst_value_serialize (v);
 218     if (s_val != NULL) {
 219       if (print_type) {
 220         g_string_append_c (s, &#39;(&#39;);
 221         g_string_append (s, _priv_gst_value_gtype_to_abbr (G_VALUE_TYPE (v)));
 222         g_string_append_c (s, &#39;)&#39;);
 223       }
 224       g_string_append (s, s_val);
 225       g_free (s_val);
 226       if (i &lt; alen - 1) {
 227         g_string_append_len (s, &quot;, &quot;, 2);
 228       }
 229     } else {
 230       GST_WARNING (&quot;Could not serialize list/array value of type &#39;%s&#39;&quot;,
 231           G_VALUE_TYPE_NAME (v));
 232     }
 233   }
 234   g_string_append (s, end);
 235   return g_string_free (s, FALSE);
 236 }
 237 
 238 static void
 239 gst_value_transform_any_list_string (const GValue * src_value,
 240     GValue * dest_value, const gchar * begin, const gchar * end)
 241 {
 242   GValue *list_value;
 243   GArray *array;
 244   GString *s;
 245   guint i;
 246   gchar *list_s;
 247   guint alen;
 248 
 249   array = src_value-&gt;data[0].v_pointer;
 250   alen = array-&gt;len;
 251 
 252   /* estimate minimum string length to minimise re-allocs in GString */
 253   s = g_string_sized_new (2 + (10 * alen) + 2);
 254   g_string_append (s, begin);
 255   for (i = 0; i &lt; alen; i++) {
 256     list_value = &amp;g_array_index (array, GValue, i);
 257 
 258     if (i != 0) {
 259       g_string_append_len (s, &quot;, &quot;, 2);
 260     }
 261     list_s = g_strdup_value_contents (list_value);
 262     g_string_append (s, list_s);
 263     g_free (list_s);
 264   }
 265   g_string_append (s, end);
 266 
 267   dest_value-&gt;data[0].v_pointer = g_string_free (s, FALSE);
 268 }
 269 
 270 static gchar *
 271 _gst_value_serialize_g_value_array (const GValue * value, const gchar * begin,
 272     const gchar * end)
 273 {
 274   guint i;
 275   GValueArray *array = value-&gt;data[0].v_pointer;
 276   GString *s;
 277   GValue *v;
 278   gchar *s_val;
 279   guint alen = 0;
 280 
 281   if (array)
 282     alen = array-&gt;n_values;
 283 
 284   /* estimate minimum string length to minimise re-allocs in GString */
 285   s = g_string_sized_new (2 + (6 * alen) + 2);
 286   g_string_append (s, begin);
 287   for (i = 0; i &lt; alen; i++) {
 288     v = g_value_array_get_nth (array, i);
 289     s_val = gst_value_serialize (v);
 290     if (s_val != NULL) {
 291       g_string_append (s, s_val);
 292       g_free (s_val);
 293       if (i &lt; alen - 1) {
 294         g_string_append_len (s, &quot;, &quot;, 2);
 295       }
 296     } else {
 297       GST_WARNING (&quot;Could not serialize list/array value of type &#39;%s&#39;&quot;,
 298           G_VALUE_TYPE_NAME (v));
 299     }
 300   }
 301   g_string_append (s, end);
 302   return g_string_free (s, FALSE);
 303 }
 304 
 305 static void
 306 _gst_value_transform_g_value_array_string (const GValue * src_value,
 307     GValue * dest_value, const gchar * begin, const gchar * end)
 308 {
 309   GValue *list_value;
 310   GValueArray *array;
 311   GString *s;
 312   guint i;
 313   gchar *list_s;
 314   guint alen;
 315 
 316   array = src_value-&gt;data[0].v_pointer;
 317   alen = array-&gt;n_values;
 318 
 319   /* estimate minimum string length to minimise re-allocs in GString */
 320   s = g_string_sized_new (2 + (10 * alen) + 2);
 321   g_string_append (s, begin);
 322   for (i = 0; i &lt; alen; i++) {
 323     list_value = g_value_array_get_nth (array, i);
 324 
 325     if (i != 0) {
 326       g_string_append_len (s, &quot;, &quot;, 2);
 327     }
 328     list_s = g_strdup_value_contents (list_value);
 329     g_string_append (s, list_s);
 330     g_free (list_s);
 331   }
 332   g_string_append (s, end);
 333 
 334   dest_value-&gt;data[0].v_pointer = g_string_free (s, FALSE);
 335 }
 336 
 337 /*
 338  * helper function to see if a type is fixed. Is used internally here and
 339  * there. Do not export, since it doesn&#39;t work for types where the content
 340  * decides the fixedness (e.g. GST_TYPE_ARRAY).
 341  */
 342 static gboolean
 343 gst_type_is_fixed (GType type)
 344 {
 345   /* the basic int, string, double types */
 346   if (type &lt;= G_TYPE_MAKE_FUNDAMENTAL (G_TYPE_RESERVED_GLIB_LAST)) {
 347     return TRUE;
 348   }
 349   /* our fundamental types that are certainly not fixed */
 350   if (type == GST_TYPE_INT_RANGE || type == GST_TYPE_DOUBLE_RANGE ||
 351       type == GST_TYPE_INT64_RANGE ||
 352       type == GST_TYPE_LIST || type == GST_TYPE_FRACTION_RANGE ||
 353       type == GST_TYPE_STRUCTURE) {
 354     return FALSE;
 355   }
 356   /* other (boxed) types that are fixed */
 357   if (type == GST_TYPE_BUFFER) {
 358     return TRUE;
 359   }
 360   /* heavy checks */
 361   if (G_TYPE_IS_FUNDAMENTAL (type) || G_TYPE_FUNDAMENTAL (type) &lt;=
 362       G_TYPE_MAKE_FUNDAMENTAL (G_TYPE_RESERVED_GLIB_LAST)) {
 363     return TRUE;
 364   }
 365 
 366   return FALSE;
 367 }
 368 
 369 /* GValue functions usable for both regular lists and arrays */
 370 static void
 371 gst_value_init_list_or_array (GValue * value)
 372 {
 373   value-&gt;data[0].v_pointer = g_array_new (FALSE, TRUE, sizeof (GValue));
 374 }
 375 
 376 static GArray *
 377 copy_garray_of_gstvalue (const GArray * src)
 378 {
 379   GArray *dest;
 380   guint i, len;
 381 
 382   len = src-&gt;len;
 383   dest = g_array_sized_new (FALSE, TRUE, sizeof (GValue), len);
 384   g_array_set_size (dest, len);
 385   for (i = 0; i &lt; len; i++) {
 386     gst_value_init_and_copy (&amp;g_array_index (dest, GValue, i),
 387         &amp;g_array_index (src, GValue, i));
 388   }
 389 
 390   return dest;
 391 }
 392 
 393 static void
 394 gst_value_copy_list_or_array (const GValue * src_value, GValue * dest_value)
 395 {
 396   dest_value-&gt;data[0].v_pointer =
 397       copy_garray_of_gstvalue ((GArray *) src_value-&gt;data[0].v_pointer);
 398 }
 399 
 400 static void
 401 gst_value_free_list_or_array (GValue * value)
 402 {
 403   guint i, len;
 404   GArray *src = (GArray *) value-&gt;data[0].v_pointer;
 405   len = src-&gt;len;
 406 
 407   if ((value-&gt;data[1].v_uint &amp; G_VALUE_NOCOPY_CONTENTS) == 0) {
 408     for (i = 0; i &lt; len; i++) {
 409       g_value_unset (&amp;g_array_index (src, GValue, i));
 410     }
 411     g_array_free (src, TRUE);
 412   }
 413 }
 414 
 415 static gpointer
 416 gst_value_list_or_array_peek_pointer (const GValue * value)
 417 {
 418   return value-&gt;data[0].v_pointer;
 419 }
 420 
 421 static gchar *
 422 gst_value_collect_list_or_array (GValue * value, guint n_collect_values,
 423     GTypeCValue * collect_values, guint collect_flags)
 424 {
 425   if (collect_flags &amp; G_VALUE_NOCOPY_CONTENTS) {
 426     value-&gt;data[0].v_pointer = collect_values[0].v_pointer;
 427     value-&gt;data[1].v_uint = G_VALUE_NOCOPY_CONTENTS;
 428   } else {
 429     value-&gt;data[0].v_pointer =
 430         copy_garray_of_gstvalue ((GArray *) collect_values[0].v_pointer);
 431   }
 432   return NULL;
 433 }
 434 
 435 static gchar *
 436 gst_value_lcopy_list_or_array (const GValue * value, guint n_collect_values,
 437     GTypeCValue * collect_values, guint collect_flags)
 438 {
 439   GArray **dest = collect_values[0].v_pointer;
 440 
 441   if (!dest)
 442     return g_strdup_printf (&quot;value location for `%s&#39; passed as NULL&quot;,
 443         G_VALUE_TYPE_NAME (value));
 444   if (!value-&gt;data[0].v_pointer)
 445     return g_strdup_printf (&quot;invalid value given for `%s&#39;&quot;,
 446         G_VALUE_TYPE_NAME (value));
 447   if (collect_flags &amp; G_VALUE_NOCOPY_CONTENTS) {
 448     *dest = (GArray *) value-&gt;data[0].v_pointer;
 449   } else {
 450     *dest = copy_garray_of_gstvalue ((GArray *) value-&gt;data[0].v_pointer);
 451   }
 452   return NULL;
 453 }
 454 
 455 static gboolean
 456 gst_value_list_or_array_get_basic_type (const GValue * value, GType * type)
 457 {
 458   if (G_UNLIKELY (value == NULL))
 459     return FALSE;
 460 
 461   if (GST_VALUE_HOLDS_LIST (value)) {
 462     if (VALUE_LIST_SIZE (value) == 0)
 463       return FALSE;
 464     return gst_value_list_or_array_get_basic_type (VALUE_LIST_GET_VALUE (value,
 465             0), type);
 466   }
 467   if (GST_VALUE_HOLDS_ARRAY (value)) {
 468     const GArray *array = (const GArray *) value-&gt;data[0].v_pointer;
 469     if (array-&gt;len == 0)
 470       return FALSE;
 471     return gst_value_list_or_array_get_basic_type (&amp;g_array_index (array,
 472             GValue, 0), type);
 473   }
 474 
 475   *type = G_VALUE_TYPE (value);
 476 
 477   return TRUE;
 478 }
 479 
 480 #define IS_RANGE_COMPAT(type1,type2,t1,t2) \
 481   (((t1) == (type1) &amp;&amp; (t2) == (type2)) || ((t2) == (type1) &amp;&amp; (t1) == (type2)))
 482 
 483 static gboolean
 484 gst_value_list_or_array_are_compatible (const GValue * value1,
 485     const GValue * value2)
 486 {
 487   GType basic_type1, basic_type2;
 488 
 489   /* empty or same type is OK */
 490   if (!gst_value_list_or_array_get_basic_type (value1, &amp;basic_type1) ||
 491       !gst_value_list_or_array_get_basic_type (value2, &amp;basic_type2) ||
 492       basic_type1 == basic_type2)
 493     return TRUE;
 494 
 495   /* ranges are distinct types for each bound type... */
 496   if (IS_RANGE_COMPAT (G_TYPE_INT, GST_TYPE_INT_RANGE, basic_type1,
 497           basic_type2))
 498     return TRUE;
 499   if (IS_RANGE_COMPAT (G_TYPE_INT64, GST_TYPE_INT64_RANGE, basic_type1,
 500           basic_type2))
 501     return TRUE;
 502   if (IS_RANGE_COMPAT (G_TYPE_DOUBLE, GST_TYPE_DOUBLE_RANGE, basic_type1,
 503           basic_type2))
 504     return TRUE;
 505   if (IS_RANGE_COMPAT (GST_TYPE_FRACTION, GST_TYPE_FRACTION_RANGE, basic_type1,
 506           basic_type2))
 507     return TRUE;
 508 
 509   return FALSE;
 510 }
 511 
 512 static inline void
 513 _gst_value_list_append_and_take_value (GValue * value, GValue * append_value)
 514 {
 515   g_array_append_vals ((GArray *) value-&gt;data[0].v_pointer, append_value, 1);
 516   memset (append_value, 0, sizeof (GValue));
 517 }
 518 
 519 /**
 520  * gst_value_list_append_and_take_value:
 521  * @value: a #GValue of type #GST_TYPE_LIST
 522  * @append_value: (transfer full): the value to append
 523  *
 524  * Appends @append_value to the GstValueList in @value.
 525  *
 526  * Since: 1.2
 527  */
 528 void
 529 gst_value_list_append_and_take_value (GValue * value, GValue * append_value)
 530 {
 531   g_return_if_fail (GST_VALUE_HOLDS_LIST (value));
 532   g_return_if_fail (G_IS_VALUE (append_value));
 533   g_return_if_fail (gst_value_list_or_array_are_compatible (value,
 534           append_value));
 535 
 536   _gst_value_list_append_and_take_value (value, append_value);
 537 }
 538 
 539 /**
 540  * gst_value_list_append_value:
 541  * @value: a #GValue of type #GST_TYPE_LIST
 542  * @append_value: (transfer none): the value to append
 543  *
 544  * Appends @append_value to the GstValueList in @value.
 545  */
 546 void
 547 gst_value_list_append_value (GValue * value, const GValue * append_value)
 548 {
 549   GValue val = { 0, };
 550 
 551   g_return_if_fail (GST_VALUE_HOLDS_LIST (value));
 552   g_return_if_fail (G_IS_VALUE (append_value));
 553   g_return_if_fail (gst_value_list_or_array_are_compatible (value,
 554           append_value));
 555 
 556   gst_value_init_and_copy (&amp;val, append_value);
 557   g_array_append_vals ((GArray *) value-&gt;data[0].v_pointer, &amp;val, 1);
 558 }
 559 
 560 /**
 561  * gst_value_list_prepend_value:
 562  * @value: a #GValue of type #GST_TYPE_LIST
 563  * @prepend_value: the value to prepend
 564  *
 565  * Prepends @prepend_value to the GstValueList in @value.
 566  */
 567 void
 568 gst_value_list_prepend_value (GValue * value, const GValue * prepend_value)
 569 {
 570   GValue val = { 0, };
 571 
 572   g_return_if_fail (GST_VALUE_HOLDS_LIST (value));
 573   g_return_if_fail (G_IS_VALUE (prepend_value));
 574   g_return_if_fail (gst_value_list_or_array_are_compatible (value,
 575           prepend_value));
 576 
 577   gst_value_init_and_copy (&amp;val, prepend_value);
 578   g_array_prepend_vals ((GArray *) value-&gt;data[0].v_pointer, &amp;val, 1);
 579 }
 580 
 581 /**
 582  * gst_value_list_concat:
 583  * @dest: (out caller-allocates): an uninitialized #GValue to take the result
 584  * @value1: a #GValue
 585  * @value2: a #GValue
 586  *
 587  * Concatenates copies of @value1 and @value2 into a list.  Values that are not
 588  * of type #GST_TYPE_LIST are treated as if they were lists of length 1.
 589  * @dest will be initialized to the type #GST_TYPE_LIST.
 590  */
 591 void
 592 gst_value_list_concat (GValue * dest, const GValue * value1,
 593     const GValue * value2)
 594 {
 595   guint i, value1_length, value2_length;
 596   GArray *array;
 597 
 598   g_return_if_fail (dest != NULL);
 599   g_return_if_fail (G_VALUE_TYPE (dest) == 0);
 600   g_return_if_fail (G_IS_VALUE (value1));
 601   g_return_if_fail (G_IS_VALUE (value2));
 602   g_return_if_fail (gst_value_list_or_array_are_compatible (value1, value2));
 603 
 604   value1_length =
 605       (GST_VALUE_HOLDS_LIST (value1) ? VALUE_LIST_SIZE (value1) : 1);
 606   value2_length =
 607       (GST_VALUE_HOLDS_LIST (value2) ? VALUE_LIST_SIZE (value2) : 1);
 608   g_value_init (dest, GST_TYPE_LIST);
 609   array = (GArray *) dest-&gt;data[0].v_pointer;
 610   g_array_set_size (array, value1_length + value2_length);
 611 
 612   if (GST_VALUE_HOLDS_LIST (value1)) {
 613     for (i = 0; i &lt; value1_length; i++) {
 614       gst_value_init_and_copy (&amp;g_array_index (array, GValue, i),
 615           VALUE_LIST_GET_VALUE (value1, i));
 616     }
 617   } else {
 618     gst_value_init_and_copy (&amp;g_array_index (array, GValue, 0), value1);
 619   }
 620 
 621   if (GST_VALUE_HOLDS_LIST (value2)) {
 622     for (i = 0; i &lt; value2_length; i++) {
 623       gst_value_init_and_copy (&amp;g_array_index (array, GValue,
 624               i + value1_length), VALUE_LIST_GET_VALUE (value2, i));
 625     }
 626   } else {
 627     gst_value_init_and_copy (&amp;g_array_index (array, GValue, value1_length),
 628         value2);
 629   }
 630 }
 631 
 632 /* same as gst_value_list_concat() but takes ownership of GValues */
 633 static void
 634 gst_value_list_concat_and_take_values (GValue * dest, GValue * val1,
 635     GValue * val2)
 636 {
 637   guint i, val1_length, val2_length;
 638   gboolean val1_is_list;
 639   gboolean val2_is_list;
 640   GArray *array;
 641 
 642   g_assert (dest != NULL);
 643   g_assert (G_VALUE_TYPE (dest) == 0);
 644   g_assert (G_IS_VALUE (val1));
 645   g_assert (G_IS_VALUE (val2));
 646   g_assert (gst_value_list_or_array_are_compatible (val1, val2));
 647 
 648   val1_is_list = GST_VALUE_HOLDS_LIST (val1);
 649   val1_length = (val1_is_list ? VALUE_LIST_SIZE (val1) : 1);
 650 
 651   val2_is_list = GST_VALUE_HOLDS_LIST (val2);
 652   val2_length = (val2_is_list ? VALUE_LIST_SIZE (val2) : 1);
 653 
 654   g_value_init (dest, GST_TYPE_LIST);
 655   array = (GArray *) dest-&gt;data[0].v_pointer;
 656   g_array_set_size (array, val1_length + val2_length);
 657 
 658   if (val1_is_list) {
 659     for (i = 0; i &lt; val1_length; i++) {
 660       g_array_index (array, GValue, i) = *VALUE_LIST_GET_VALUE (val1, i);
 661     }
 662     g_array_set_size (VALUE_LIST_ARRAY (val1), 0);
 663     g_value_unset (val1);
 664   } else {
 665     g_array_index (array, GValue, 0) = *val1;
 666     G_VALUE_TYPE (val1) = G_TYPE_INVALID;
 667   }
 668 
 669   if (val2_is_list) {
 670     for (i = 0; i &lt; val2_length; i++) {
 671       const GValue *v2 = VALUE_LIST_GET_VALUE (val2, i);
 672       g_array_index (array, GValue, i + val1_length) = *v2;
 673     }
 674     g_array_set_size (VALUE_LIST_ARRAY (val2), 0);
 675     g_value_unset (val2);
 676   } else {
 677     g_array_index (array, GValue, val1_length) = *val2;
 678     G_VALUE_TYPE (val2) = G_TYPE_INVALID;
 679   }
 680 }
 681 
 682 /**
 683  * gst_value_list_merge:
 684  * @dest: (out caller-allocates): an uninitialized #GValue to take the result
 685  * @value1: a #GValue
 686  * @value2: a #GValue
 687  *
 688  * Merges copies of @value1 and @value2.  Values that are not
 689  * of type #GST_TYPE_LIST are treated as if they were lists of length 1.
 690  *
 691  * The result will be put into @dest and will either be a list that will not
 692  * contain any duplicates, or a non-list type (if @value1 and @value2
 693  * were equal).
 694  */
 695 void
 696 gst_value_list_merge (GValue * dest, const GValue * value1,
 697     const GValue * value2)
 698 {
 699   guint i, j, k, value1_length, value2_length, skipped;
 700   const GValue *src;
 701   gboolean skip;
 702   GArray *array;
 703 
 704   g_return_if_fail (dest != NULL);
 705   g_return_if_fail (G_VALUE_TYPE (dest) == 0);
 706   g_return_if_fail (G_IS_VALUE (value1));
 707   g_return_if_fail (G_IS_VALUE (value2));
 708   g_return_if_fail (gst_value_list_or_array_are_compatible (value1, value2));
 709 
 710   value1_length =
 711       (GST_VALUE_HOLDS_LIST (value1) ? VALUE_LIST_SIZE (value1) : 1);
 712   value2_length =
 713       (GST_VALUE_HOLDS_LIST (value2) ? VALUE_LIST_SIZE (value2) : 1);
 714   g_value_init (dest, GST_TYPE_LIST);
 715   array = (GArray *) dest-&gt;data[0].v_pointer;
 716   g_array_set_size (array, value1_length + value2_length);
 717 
 718   if (GST_VALUE_HOLDS_LIST (value1)) {
 719     for (i = 0; i &lt; value1_length; i++) {
 720       gst_value_init_and_copy (&amp;g_array_index (array, GValue, i),
 721           VALUE_LIST_GET_VALUE (value1, i));
 722     }
 723   } else {
 724     gst_value_init_and_copy (&amp;g_array_index (array, GValue, 0), value1);
 725   }
 726 
 727   j = value1_length;
 728   skipped = 0;
 729   if (GST_VALUE_HOLDS_LIST (value2)) {
 730     for (i = 0; i &lt; value2_length; i++) {
 731       skip = FALSE;
 732       src = VALUE_LIST_GET_VALUE (value2, i);
 733       for (k = 0; k &lt; value1_length; k++) {
 734         if (gst_value_compare (&amp;g_array_index (array, GValue, k),
 735                 src) == GST_VALUE_EQUAL) {
 736           skip = TRUE;
 737           skipped++;
 738           break;
 739         }
 740       }
 741       if (!skip) {
 742         gst_value_init_and_copy (&amp;g_array_index (array, GValue, j), src);
 743         j++;
 744       }
 745     }
 746   } else {
 747     skip = FALSE;
 748     for (k = 0; k &lt; value1_length; k++) {
 749       if (gst_value_compare (&amp;g_array_index (array, GValue, k),
 750               value2) == GST_VALUE_EQUAL) {
 751         skip = TRUE;
 752         skipped++;
 753         break;
 754       }
 755     }
 756     if (!skip) {
 757       gst_value_init_and_copy (&amp;g_array_index (array, GValue, j), value2);
 758     }
 759   }
 760   if (skipped) {
 761     guint new_size = value1_length + (value2_length - skipped);
 762 
 763     if (new_size &gt; 1) {
 764       /* shrink list */
 765       g_array_set_size (array, new_size);
 766     } else {
 767       GValue single_dest;
 768 
 769       /* size is 1, take single value in list and make it new dest */
 770       single_dest = g_array_index (array, GValue, 0);
 771 
 772       /* clean up old value allocations: must set array size to 0, because
 773        * allocated values are not inited meaning g_value_unset() will not
 774        * work on them */
 775       g_array_set_size (array, 0);
 776       g_value_unset (dest);
 777 
 778       /* the single value is our new result */
 779       *dest = single_dest;
 780     }
 781   }
 782 }
 783 
 784 /**
 785  * gst_value_list_get_size:
 786  * @value: a #GValue of type #GST_TYPE_LIST
 787  *
 788  * Gets the number of values contained in @value.
 789  *
 790  * Returns: the number of values
 791  */
 792 guint
 793 gst_value_list_get_size (const GValue * value)
 794 {
 795   g_return_val_if_fail (GST_VALUE_HOLDS_LIST (value), 0);
 796 
 797   return ((GArray *) value-&gt;data[0].v_pointer)-&gt;len;
 798 }
 799 
 800 /**
 801  * gst_value_list_get_value:
 802  * @value: a #GValue of type #GST_TYPE_LIST
 803  * @index: index of value to get from the list
 804  *
 805  * Gets the value that is a member of the list contained in @value and
 806  * has the index @index.
 807  *
 808  * Returns: (transfer none): the value at the given index
 809  */
 810 const GValue *
 811 gst_value_list_get_value (const GValue * value, guint index)
 812 {
 813   g_return_val_if_fail (GST_VALUE_HOLDS_LIST (value), NULL);
 814   g_return_val_if_fail (index &lt; VALUE_LIST_SIZE (value), NULL);
 815 
 816   return (const GValue *) &amp;g_array_index ((GArray *) value-&gt;data[0].v_pointer,
 817       GValue, index);
 818 }
 819 
 820 /**
 821  * gst_value_array_append_value:
 822  * @value: a #GValue of type #GST_TYPE_ARRAY
 823  * @append_value: the value to append
 824  *
 825  * Appends @append_value to the GstValueArray in @value.
 826  */
 827 void
 828 gst_value_array_append_value (GValue * value, const GValue * append_value)
 829 {
 830   GValue val = { 0, };
 831 
 832   g_return_if_fail (GST_VALUE_HOLDS_ARRAY (value));
 833   g_return_if_fail (G_IS_VALUE (append_value));
 834   g_return_if_fail (gst_value_list_or_array_are_compatible (value,
 835           append_value));
 836 
 837   gst_value_init_and_copy (&amp;val, append_value);
 838   g_array_append_vals ((GArray *) value-&gt;data[0].v_pointer, &amp;val, 1);
 839 }
 840 
 841 static inline void
 842 _gst_value_array_append_and_take_value (GValue * value, GValue * append_value)
 843 {
 844   g_array_append_vals ((GArray *) value-&gt;data[0].v_pointer, append_value, 1);
 845   memset (append_value, 0, sizeof (GValue));
 846 }
 847 
 848 /**
 849  * gst_value_array_append_and_take_value:
 850  * @value: a #GValue of type #GST_TYPE_ARRAY
 851  * @append_value: (transfer full): the value to append
 852  *
 853  * Appends @append_value to the GstValueArray in @value.
 854  *
 855  * Since: 1.2
 856  */
 857 void
 858 gst_value_array_append_and_take_value (GValue * value, GValue * append_value)
 859 {
 860   g_return_if_fail (GST_VALUE_HOLDS_ARRAY (value));
 861   g_return_if_fail (G_IS_VALUE (append_value));
 862   g_return_if_fail (gst_value_list_or_array_are_compatible (value,
 863           append_value));
 864 
 865   _gst_value_array_append_and_take_value (value, append_value);
 866 }
 867 
 868 #ifndef GSTREAMER_LITE
 869 /**
 870  * gst_value_array_prepend_value:
 871  * @value: a #GValue of type #GST_TYPE_ARRAY
 872  * @prepend_value: the value to prepend
 873  *
 874  * Prepends @prepend_value to the GstValueArray in @value.
 875  */
 876 void
 877 gst_value_array_prepend_value (GValue * value, const GValue * prepend_value)
 878 {
 879   GValue val = { 0, };
 880 
 881   g_return_if_fail (GST_VALUE_HOLDS_ARRAY (value));
 882   g_return_if_fail (G_IS_VALUE (prepend_value));
 883   g_return_if_fail (gst_value_list_or_array_are_compatible (value,
 884           prepend_value));
 885 
 886   gst_value_init_and_copy (&amp;val, prepend_value);
 887   g_array_prepend_vals ((GArray *) value-&gt;data[0].v_pointer, &amp;val, 1);
 888 }
 889 #endif // GSTREAMER_LITE
 890 
 891 /**
 892  * gst_value_array_get_size:
 893  * @value: a #GValue of type #GST_TYPE_ARRAY
 894  *
 895  * Gets the number of values contained in @value.
 896  *
 897  * Returns: the number of values
 898  */
 899 guint
 900 gst_value_array_get_size (const GValue * value)
 901 {
 902   g_return_val_if_fail (GST_VALUE_HOLDS_ARRAY (value), 0);
 903 
 904   return ((GArray *) value-&gt;data[0].v_pointer)-&gt;len;
 905 }
 906 
 907 /**
 908  * gst_value_array_get_value:
 909  * @value: a #GValue of type #GST_TYPE_ARRAY
 910  * @index: index of value to get from the array
 911  *
 912  * Gets the value that is a member of the array contained in @value and
 913  * has the index @index.
 914  *
 915  * Returns: (transfer none): the value at the given index
 916  */
 917 const GValue *
 918 gst_value_array_get_value (const GValue * value, guint index)
 919 {
 920   g_return_val_if_fail (GST_VALUE_HOLDS_ARRAY (value), NULL);
 921   g_return_val_if_fail (index &lt; gst_value_array_get_size (value), NULL);
 922 
 923   return (const GValue *) &amp;g_array_index ((GArray *) value-&gt;data[0].v_pointer,
 924       GValue, index);
 925 }
 926 
 927 static void
 928 gst_value_transform_list_string (const GValue * src_value, GValue * dest_value)
 929 {
 930   gst_value_transform_any_list_string (src_value, dest_value, &quot;{ &quot;, &quot; }&quot;);
 931 }
 932 
 933 static void
 934 gst_value_transform_array_string (const GValue * src_value, GValue * dest_value)
 935 {
 936   gst_value_transform_any_list_string (src_value, dest_value, &quot;&lt; &quot;, &quot; &gt;&quot;);
 937 }
 938 
 939 static void
 940 gst_value_transform_g_value_array_string (const GValue * src_value,
 941     GValue * dest_value)
 942 {
 943   _gst_value_transform_g_value_array_string (src_value, dest_value, &quot;&lt; &quot;, &quot; &gt;&quot;);
 944 }
 945 
 946 static void
 947 gst_value_transform_g_value_array_any_list (const GValue * src_value,
 948     GValue * dest_value)
 949 {
 950   const GValueArray *varray;
 951   GArray *array;
 952   gint i;
 953 
 954   /* GLib will unset the value, memset to 0 the data instead of doing a proper
 955    * reset. That&#39;s why we need to allocate the array here */
 956   gst_value_init_list_or_array (dest_value);
 957 
 958   varray = g_value_get_boxed (src_value);
 959   array = dest_value-&gt;data[0].v_pointer;
 960 
 961   for (i = 0; i &lt; varray-&gt;n_values; i++) {
 962     GValue val = G_VALUE_INIT;
 963     gst_value_init_and_copy (&amp;val, &amp;varray-&gt;values[i]);
 964     g_array_append_vals (array, &amp;val, 1);
 965   }
 966 }
 967 
 968 static void
 969 gst_value_transform_any_list_g_value_array (const GValue * src_value,
 970     GValue * dest_value)
 971 {
 972   GValueArray *varray;
 973   const GArray *array;
 974   gint i;
 975 
 976   array = src_value-&gt;data[0].v_pointer;
 977   varray = g_value_array_new (array-&gt;len);
 978 
 979   for (i = 0; i &lt; array-&gt;len; i++)
 980     g_value_array_append (varray, &amp;g_array_index (array, GValue, i));
 981 
 982   g_value_take_boxed (dest_value, varray);
 983 }
 984 
 985 /* Do an unordered compare of the contents of a list */
 986 static gint
 987 gst_value_compare_value_list (const GValue * value1, const GValue * value2)
 988 {
 989   guint i, j;
 990   GArray *array1 = value1-&gt;data[0].v_pointer;
 991   GArray *array2 = value2-&gt;data[0].v_pointer;
 992   GValue *v1;
 993   GValue *v2;
 994   gint len, to_remove;
 995   guint8 *removed;
 996   GstValueCompareFunc compare;
 997 
 998   /* get length and do initial length check. */
 999   len = array1-&gt;len;
1000   if (len != array2-&gt;len)
1001     return GST_VALUE_UNORDERED;
1002 
1003   /* place to mark removed value indices of array2 */
1004   removed = g_newa (guint8, len);
1005   memset (removed, 0, len);
1006   to_remove = len;
1007 
1008   /* loop over array1, all items should be in array2. When we find an
1009    * item in array2, remove it from array2 by marking it as removed */
1010   for (i = 0; i &lt; len; i++) {
1011     v1 = &amp;g_array_index (array1, GValue, i);
1012     if ((compare = gst_value_get_compare_func (v1))) {
1013       for (j = 0; j &lt; len; j++) {
1014         /* item is removed, we can skip it */
1015         if (removed[j])
1016           continue;
1017         v2 = &amp;g_array_index (array2, GValue, j);
1018         if (gst_value_compare_with_func (v1, v2, compare) == GST_VALUE_EQUAL) {
1019           /* mark item as removed now that we found it in array2 and
1020            * decrement the number of remaining items in array2. */
1021           removed[j] = 1;
1022           to_remove--;
1023           break;
1024         }
1025       }
1026       /* item in array1 and not in array2, UNORDERED */
1027       if (j == len)
1028         return GST_VALUE_UNORDERED;
1029     } else
1030       return GST_VALUE_UNORDERED;
1031   }
1032   /* if not all items were removed, array2 contained something not in array1 */
1033   if (to_remove != 0)
1034     return GST_VALUE_UNORDERED;
1035 
1036   /* arrays are equal */
1037   return GST_VALUE_EQUAL;
1038 }
1039 
1040 /* Perform an ordered comparison of the contents of an array */
1041 static gint
1042 gst_value_compare_value_array (const GValue * value1, const GValue * value2)
1043 {
1044   guint i;
1045   GArray *array1 = value1-&gt;data[0].v_pointer;
1046   GArray *array2 = value2-&gt;data[0].v_pointer;
1047   guint len = array1-&gt;len;
1048   GValue *v1;
1049   GValue *v2;
1050 
1051   if (len != array2-&gt;len)
1052     return GST_VALUE_UNORDERED;
1053 
1054   for (i = 0; i &lt; len; i++) {
1055     v1 = &amp;g_array_index (array1, GValue, i);
1056     v2 = &amp;g_array_index (array2, GValue, i);
1057     if (gst_value_compare (v1, v2) != GST_VALUE_EQUAL)
1058       return GST_VALUE_UNORDERED;
1059   }
1060 
1061   return GST_VALUE_EQUAL;
1062 }
1063 
1064 static gint
1065 gst_value_compare_g_value_array (const GValue * value1, const GValue * value2)
1066 {
1067   guint i;
1068   GValueArray *array1 = value1-&gt;data[0].v_pointer;
1069   GValueArray *array2 = value2-&gt;data[0].v_pointer;
1070   guint len = array1-&gt;n_values;
1071   GValue *v1;
1072   GValue *v2;
1073 
1074   if (len != array2-&gt;n_values)
1075     return GST_VALUE_UNORDERED;
1076 
1077   for (i = 0; i &lt; len; i++) {
1078     v1 = g_value_array_get_nth (array1, i);
1079     v2 = g_value_array_get_nth (array2, i);
1080     if (gst_value_compare (v1, v2) != GST_VALUE_EQUAL)
1081       return GST_VALUE_UNORDERED;
1082   }
1083 
1084   return GST_VALUE_EQUAL;
1085 }
1086 
1087 static gchar *
1088 gst_value_serialize_value_list (const GValue * value)
1089 {
1090   return _priv_gst_value_serialize_any_list (value, &quot;{ &quot;, &quot; }&quot;, TRUE);
1091 }
1092 
1093 static gboolean
1094 gst_value_deserialize_value_list (GValue * dest, const gchar * s)
1095 {
1096   gchar *s2 = (gchar *) s;
1097   return _priv_gst_value_parse_list (s2, &amp;s2, dest, G_TYPE_INVALID);
1098 }
1099 
1100 static gchar *
1101 gst_value_serialize_value_array (const GValue * value)
1102 {
1103   return _priv_gst_value_serialize_any_list (value, &quot;&lt; &quot;, &quot; &gt;&quot;, TRUE);
1104 }
1105 
1106 static gboolean
1107 gst_value_deserialize_value_array (GValue * dest, const gchar * s)
1108 {
1109   gchar *s2 = (gchar *) s;
1110   return _priv_gst_value_parse_array (s2, &amp;s2, dest, G_TYPE_INVALID);
1111 }
1112 
1113 static gchar *
1114 gst_value_serialize_g_value_array (const GValue * value)
1115 {
1116   return _gst_value_serialize_g_value_array (value, &quot;&lt; &quot;, &quot; &gt;&quot;);
1117 }
1118 
1119 static gboolean
1120 gst_value_deserialize_g_value_array (GValue * dest, const gchar * s)
1121 {
1122   g_warning (&quot;gst_value_deserialize_g_value_array: unimplemented&quot;);
1123   return FALSE;
1124 }
1125 
1126 /*************
1127  * int range *
1128  *
1129  * Values in the range are defined as any value greater or equal
1130  * to min*step, AND lesser or equal to max*step.
1131  * For step == 1, this falls back to the traditional range semantics.
1132  *
1133  * data[0] = (min &lt;&lt; 32) | (max)
1134  * data[1] = step
1135  *
1136  *************/
1137 
1138 #define INT_RANGE_MIN(v) ((gint) (((v)-&gt;data[0].v_uint64) &gt;&gt; 32))
1139 #define INT_RANGE_MAX(v) ((gint) (((v)-&gt;data[0].v_uint64) &amp; 0xffffffff))
1140 #define INT_RANGE_STEP(v) ((v)-&gt;data[1].v_int)
1141 
1142 static void
1143 gst_value_init_int_range (GValue * value)
1144 {
1145   G_STATIC_ASSERT (sizeof (gint) &lt;= 2 * sizeof (guint64));
1146 
1147   value-&gt;data[0].v_uint64 = 0;
1148   value-&gt;data[1].v_int = 1;
1149 }
1150 
1151 static void
1152 gst_value_copy_int_range (const GValue * src_value, GValue * dest_value)
1153 {
1154   dest_value-&gt;data[0].v_uint64 = src_value-&gt;data[0].v_uint64;
1155   dest_value-&gt;data[1].v_int = src_value-&gt;data[1].v_int;
1156 }
1157 
1158 static gchar *
1159 gst_value_collect_int_range (GValue * value, guint n_collect_values,
1160     GTypeCValue * collect_values, guint collect_flags)
1161 {
1162   if (n_collect_values != 2)
1163     return g_strdup_printf (&quot;not enough value locations for `%s&#39; passed&quot;,
1164         G_VALUE_TYPE_NAME (value));
1165   if (collect_values[0].v_int &gt;= collect_values[1].v_int)
1166     return g_strdup_printf (&quot;range start is not smaller than end for `%s&#39;&quot;,
1167         G_VALUE_TYPE_NAME (value));
1168 
1169   gst_value_set_int_range_step (value, collect_values[0].v_int,
1170       collect_values[1].v_int, 1);
1171 
1172   return NULL;
1173 }
1174 
1175 static gchar *
1176 gst_value_lcopy_int_range (const GValue * value, guint n_collect_values,
1177     GTypeCValue * collect_values, guint collect_flags)
1178 {
1179   guint32 *int_range_start = collect_values[0].v_pointer;
1180   guint32 *int_range_end = collect_values[1].v_pointer;
1181 
1182   if (!int_range_start)
1183     return g_strdup_printf (&quot;start value location for `%s&#39; passed as NULL&quot;,
1184         G_VALUE_TYPE_NAME (value));
1185   if (!int_range_end)
1186     return g_strdup_printf (&quot;end value location for `%s&#39; passed as NULL&quot;,
1187         G_VALUE_TYPE_NAME (value));
1188 
1189   *int_range_start = INT_RANGE_MIN (value);
1190   *int_range_end = INT_RANGE_MAX (value);
1191 
1192   return NULL;
1193 }
1194 
1195 /**
1196  * gst_value_set_int_range_step:
1197  * @value: a GValue initialized to GST_TYPE_INT_RANGE
1198  * @start: the start of the range
1199  * @end: the end of the range
1200  * @step: the step of the range
1201  *
1202  * Sets @value to the range specified by @start, @end and @step.
1203  */
1204 void
1205 gst_value_set_int_range_step (GValue * value, gint start, gint end, gint step)
1206 {
1207   guint64 sstart, sstop;
1208 
1209   g_return_if_fail (GST_VALUE_HOLDS_INT_RANGE (value));
1210   g_return_if_fail (start &lt; end);
1211   g_return_if_fail (step &gt; 0);
1212   g_return_if_fail (start % step == 0);
1213   g_return_if_fail (end % step == 0);
1214 
1215   sstart = (guint) (start / step);
1216   sstop = (guint) (end / step);
1217   value-&gt;data[0].v_uint64 = (sstart &lt;&lt; 32) | sstop;
1218   value-&gt;data[1].v_int = step;
1219 }
1220 
1221 /**
1222  * gst_value_set_int_range:
1223  * @value: a GValue initialized to GST_TYPE_INT_RANGE
1224  * @start: the start of the range
1225  * @end: the end of the range
1226  *
1227  * Sets @value to the range specified by @start and @end.
1228  */
1229 void
1230 gst_value_set_int_range (GValue * value, gint start, gint end)
1231 {
1232   gst_value_set_int_range_step (value, start, end, 1);
1233 }
1234 
1235 /**
1236  * gst_value_get_int_range_min:
1237  * @value: a GValue initialized to GST_TYPE_INT_RANGE
1238  *
1239  * Gets the minimum of the range specified by @value.
1240  *
1241  * Returns: the minimum of the range
1242  */
1243 gint
1244 gst_value_get_int_range_min (const GValue * value)
1245 {
1246   g_return_val_if_fail (GST_VALUE_HOLDS_INT_RANGE (value), 0);
1247 
1248   return INT_RANGE_MIN (value) * INT_RANGE_STEP (value);
1249 }
1250 
1251 /**
1252  * gst_value_get_int_range_max:
1253  * @value: a GValue initialized to GST_TYPE_INT_RANGE
1254  *
1255  * Gets the maximum of the range specified by @value.
1256  *
1257  * Returns: the maximum of the range
1258  */
1259 gint
1260 gst_value_get_int_range_max (const GValue * value)
1261 {
1262   g_return_val_if_fail (GST_VALUE_HOLDS_INT_RANGE (value), 0);
1263 
1264   return INT_RANGE_MAX (value) * INT_RANGE_STEP (value);
1265 }
1266 
1267 /**
1268  * gst_value_get_int_range_step:
1269  * @value: a GValue initialized to GST_TYPE_INT_RANGE
1270  *
1271  * Gets the step of the range specified by @value.
1272  *
1273  * Returns: the step of the range
1274  */
1275 gint
1276 gst_value_get_int_range_step (const GValue * value)
1277 {
1278   g_return_val_if_fail (GST_VALUE_HOLDS_INT_RANGE (value), 0);
1279 
1280   return INT_RANGE_STEP (value);
1281 }
1282 
1283 static void
1284 gst_value_transform_int_range_string (const GValue * src_value,
1285     GValue * dest_value)
1286 {
1287   if (INT_RANGE_STEP (src_value) == 1)
1288     dest_value-&gt;data[0].v_pointer = g_strdup_printf (&quot;[%d,%d]&quot;,
1289         INT_RANGE_MIN (src_value), INT_RANGE_MAX (src_value));
1290   else
1291     dest_value-&gt;data[0].v_pointer = g_strdup_printf (&quot;[%d,%d,%d]&quot;,
1292         INT_RANGE_MIN (src_value) * INT_RANGE_STEP (src_value),
1293         INT_RANGE_MAX (src_value) * INT_RANGE_STEP (src_value),
1294         INT_RANGE_STEP (src_value));
1295 }
1296 
1297 static gint
1298 gst_value_compare_int_range (const GValue * value1, const GValue * value2)
1299 {
1300   /* calculate the number of values in each range */
1301   gint n1 = INT_RANGE_MAX (value1) - INT_RANGE_MIN (value1) + 1;
1302   gint n2 = INT_RANGE_MAX (value2) - INT_RANGE_MIN (value2) + 1;
1303 
1304   /* they must be equal */
1305   if (n1 != n2)
1306     return GST_VALUE_UNORDERED;
1307 
1308   /* if empty, equal */
1309   if (n1 == 0)
1310     return GST_VALUE_EQUAL;
1311 
1312   /* if more than one value, then it is only equal if the step is equal
1313      and bounds lie on the same value */
1314   if (n1 &gt; 1) {
1315     if (INT_RANGE_STEP (value1) == INT_RANGE_STEP (value2) &amp;&amp;
1316         INT_RANGE_MIN (value1) == INT_RANGE_MIN (value2) &amp;&amp;
1317         INT_RANGE_MAX (value1) == INT_RANGE_MAX (value2)) {
1318       return GST_VALUE_EQUAL;
1319     }
1320     return GST_VALUE_UNORDERED;
1321   } else {
1322     /* if just one, only if the value is equal */
1323     if (INT_RANGE_MIN (value1) == INT_RANGE_MIN (value2))
1324       return GST_VALUE_EQUAL;
1325     return GST_VALUE_UNORDERED;
1326   }
1327 }
1328 
1329 static gchar *
1330 gst_value_serialize_int_range (const GValue * value)
1331 {
1332   if (INT_RANGE_STEP (value) == 1)
1333     return g_strdup_printf (&quot;[ %d, %d ]&quot;, INT_RANGE_MIN (value),
1334         INT_RANGE_MAX (value));
1335   else
1336     return g_strdup_printf (&quot;[ %d, %d, %d ]&quot;,
1337         INT_RANGE_MIN (value) * INT_RANGE_STEP (value),
1338         INT_RANGE_MAX (value) * INT_RANGE_STEP (value), INT_RANGE_STEP (value));
1339 }
1340 
1341 static gboolean
1342 gst_value_deserialize_int_range (GValue * dest, const gchar * s)
1343 {
1344   g_warning (&quot;unimplemented&quot;);
1345   return FALSE;
1346 }
1347 
1348 /***************
1349  * int64 range *
1350  *
1351  * Values in the range are defined as any value greater or equal
1352  * to min*step, AND lesser or equal to max*step.
1353  * For step == 1, this falls back to the traditional range semantics.
1354  ***************/
1355 
1356 #define INT64_RANGE_MIN(v) (((gint64 *)((v)-&gt;data[0].v_pointer))[0])
1357 #define INT64_RANGE_MAX(v) (((gint64 *)((v)-&gt;data[0].v_pointer))[1])
1358 #define INT64_RANGE_STEP(v) (((gint64 *)((v)-&gt;data[0].v_pointer))[2])
1359 
1360 static void
1361 gst_value_init_int64_range (GValue * value)
1362 {
1363   gint64 *vals = g_slice_alloc0 (3 * sizeof (gint64));
1364   value-&gt;data[0].v_pointer = vals;
1365   INT64_RANGE_MIN (value) = 0;
1366   INT64_RANGE_MAX (value) = 0;
1367   INT64_RANGE_STEP (value) = 1;
1368 }
1369 
1370 static void
1371 gst_value_free_int64_range (GValue * value)
1372 {
1373   g_return_if_fail (GST_VALUE_HOLDS_INT64_RANGE (value));
1374   g_slice_free1 (3 * sizeof (gint64), value-&gt;data[0].v_pointer);
1375   value-&gt;data[0].v_pointer = NULL;
1376 }
1377 
1378 static void
1379 gst_value_copy_int64_range (const GValue * src_value, GValue * dest_value)
1380 {
1381   gint64 *vals = (gint64 *) dest_value-&gt;data[0].v_pointer;
1382   gint64 *src_vals = (gint64 *) src_value-&gt;data[0].v_pointer;
1383 
1384   if (vals == NULL) {
1385     gst_value_init_int64_range (dest_value);
1386   }
1387 
1388   if (src_vals != NULL) {
1389     INT64_RANGE_MIN (dest_value) = INT64_RANGE_MIN (src_value);
1390     INT64_RANGE_MAX (dest_value) = INT64_RANGE_MAX (src_value);
1391     INT64_RANGE_STEP (dest_value) = INT64_RANGE_STEP (src_value);
1392   }
1393 }
1394 
1395 static gchar *
1396 gst_value_collect_int64_range (GValue * value, guint n_collect_values,
1397     GTypeCValue * collect_values, guint collect_flags)
1398 {
1399   gint64 *vals = value-&gt;data[0].v_pointer;
1400 
1401   if (n_collect_values != 2)
1402     return g_strdup_printf (&quot;not enough value locations for `%s&#39; passed&quot;,
1403         G_VALUE_TYPE_NAME (value));
1404   if (collect_values[0].v_int64 &gt;= collect_values[1].v_int64)
1405     return g_strdup_printf (&quot;range start is not smaller than end for `%s&#39;&quot;,
1406         G_VALUE_TYPE_NAME (value));
1407 
1408   if (vals == NULL) {
1409     gst_value_init_int64_range (value);
1410   }
1411 
1412   gst_value_set_int64_range_step (value, collect_values[0].v_int64,
1413       collect_values[1].v_int64, 1);
1414 
1415   return NULL;
1416 }
1417 
1418 static gchar *
1419 gst_value_lcopy_int64_range (const GValue * value, guint n_collect_values,
1420     GTypeCValue * collect_values, guint collect_flags)
1421 {
1422   guint64 *int_range_start = collect_values[0].v_pointer;
1423   guint64 *int_range_end = collect_values[1].v_pointer;
1424   guint64 *int_range_step = collect_values[2].v_pointer;
1425   gint64 *vals = (gint64 *) value-&gt;data[0].v_pointer;
1426 
1427   if (!int_range_start)
1428     return g_strdup_printf (&quot;start value location for `%s&#39; passed as NULL&quot;,
1429         G_VALUE_TYPE_NAME (value));
1430   if (!int_range_end)
1431     return g_strdup_printf (&quot;end value location for `%s&#39; passed as NULL&quot;,
1432         G_VALUE_TYPE_NAME (value));
1433   if (!int_range_step)
1434     return g_strdup_printf (&quot;step value location for `%s&#39; passed as NULL&quot;,
1435         G_VALUE_TYPE_NAME (value));
1436 
1437   if (G_UNLIKELY (vals == NULL)) {
1438     return g_strdup_printf (&quot;Uninitialised `%s&#39; passed&quot;,
1439         G_VALUE_TYPE_NAME (value));
1440   }
1441 
1442   *int_range_start = INT64_RANGE_MIN (value);
1443   *int_range_end = INT64_RANGE_MAX (value);
1444   *int_range_step = INT64_RANGE_STEP (value);
1445 
1446   return NULL;
1447 }
1448 
1449 /**
1450  * gst_value_set_int64_range_step:
1451  * @value: a GValue initialized to GST_TYPE_INT64_RANGE
1452  * @start: the start of the range
1453  * @end: the end of the range
1454  * @step: the step of the range
1455  *
1456  * Sets @value to the range specified by @start, @end and @step.
1457  */
1458 void
1459 gst_value_set_int64_range_step (GValue * value, gint64 start, gint64 end,
1460     gint64 step)
1461 {
1462   g_return_if_fail (GST_VALUE_HOLDS_INT64_RANGE (value));
1463   g_return_if_fail (start &lt; end);
1464   g_return_if_fail (step &gt; 0);
1465   g_return_if_fail (start % step == 0);
1466   g_return_if_fail (end % step == 0);
1467 
1468   INT64_RANGE_MIN (value) = start / step;
1469   INT64_RANGE_MAX (value) = end / step;
1470   INT64_RANGE_STEP (value) = step;
1471 }
1472 
1473 /**
1474  * gst_value_set_int64_range:
1475  * @value: a GValue initialized to GST_TYPE_INT64_RANGE
1476  * @start: the start of the range
1477  * @end: the end of the range
1478  *
1479  * Sets @value to the range specified by @start and @end.
1480  */
1481 void
1482 gst_value_set_int64_range (GValue * value, gint64 start, gint64 end)
1483 {
1484   gst_value_set_int64_range_step (value, start, end, 1);
1485 }
1486 
1487 /**
1488  * gst_value_get_int64_range_min:
1489  * @value: a GValue initialized to GST_TYPE_INT64_RANGE
1490  *
1491  * Gets the minimum of the range specified by @value.
1492  *
1493  * Returns: the minimum of the range
1494  */
1495 gint64
1496 gst_value_get_int64_range_min (const GValue * value)
1497 {
1498   g_return_val_if_fail (GST_VALUE_HOLDS_INT64_RANGE (value), 0);
1499 
1500   return INT64_RANGE_MIN (value) * INT64_RANGE_STEP (value);
1501 }
1502 
1503 /**
1504  * gst_value_get_int64_range_max:
1505  * @value: a GValue initialized to GST_TYPE_INT64_RANGE
1506  *
1507  * Gets the maximum of the range specified by @value.
1508  *
1509  * Returns: the maximum of the range
1510  */
1511 gint64
1512 gst_value_get_int64_range_max (const GValue * value)
1513 {
1514   g_return_val_if_fail (GST_VALUE_HOLDS_INT64_RANGE (value), 0);
1515 
1516   return INT64_RANGE_MAX (value) * INT64_RANGE_STEP (value);
1517 }
1518 
1519 /**
1520  * gst_value_get_int64_range_step:
1521  * @value: a GValue initialized to GST_TYPE_INT64_RANGE
1522  *
1523  * Gets the step of the range specified by @value.
1524  *
1525  * Returns: the step of the range
1526  */
1527 gint64
1528 gst_value_get_int64_range_step (const GValue * value)
1529 {
1530   g_return_val_if_fail (GST_VALUE_HOLDS_INT64_RANGE (value), 0);
1531 
1532   return INT64_RANGE_STEP (value);
1533 }
1534 
1535 static void
1536 gst_value_transform_int64_range_string (const GValue * src_value,
1537     GValue * dest_value)
1538 {
1539   if (INT64_RANGE_STEP (src_value) == 1)
1540     dest_value-&gt;data[0].v_pointer =
1541         g_strdup_printf (&quot;(gint64)[%&quot; G_GINT64_FORMAT &quot;,%&quot; G_GINT64_FORMAT &quot;]&quot;,
1542         INT64_RANGE_MIN (src_value), INT64_RANGE_MAX (src_value));
1543   else
1544     dest_value-&gt;data[0].v_pointer =
1545         g_strdup_printf (&quot;(gint64)[%&quot; G_GINT64_FORMAT &quot;,%&quot; G_GINT64_FORMAT
1546         &quot;,%&quot; G_GINT64_FORMAT &quot;]&quot;,
1547         INT64_RANGE_MIN (src_value) * INT64_RANGE_STEP (src_value),
1548         INT64_RANGE_MAX (src_value) * INT64_RANGE_STEP (src_value),
1549         INT64_RANGE_STEP (src_value));
1550 }
1551 
1552 static gint
1553 gst_value_compare_int64_range (const GValue * value1, const GValue * value2)
1554 {
1555   /* calculate the number of values in each range */
1556   gint64 n1 = INT64_RANGE_MAX (value1) - INT64_RANGE_MIN (value1) + 1;
1557   gint64 n2 = INT64_RANGE_MAX (value2) - INT64_RANGE_MIN (value2) + 1;
1558 
1559   /* they must be equal */
1560   if (n1 != n2)
1561     return GST_VALUE_UNORDERED;
1562 
1563   /* if empty, equal */
1564   if (n1 == 0)
1565     return GST_VALUE_EQUAL;
1566 
1567   /* if more than one value, then it is only equal if the step is equal
1568      and bounds lie on the same value */
1569   if (n1 &gt; 1) {
1570     if (INT64_RANGE_STEP (value1) == INT64_RANGE_STEP (value2) &amp;&amp;
1571         INT64_RANGE_MIN (value1) == INT64_RANGE_MIN (value2) &amp;&amp;
1572         INT64_RANGE_MAX (value1) == INT64_RANGE_MAX (value2)) {
1573       return GST_VALUE_EQUAL;
1574     }
1575     return GST_VALUE_UNORDERED;
1576   } else {
1577     /* if just one, only if the value is equal */
1578     if (INT64_RANGE_MIN (value1) == INT64_RANGE_MIN (value2))
1579       return GST_VALUE_EQUAL;
1580     return GST_VALUE_UNORDERED;
1581   }
1582 }
1583 
1584 static gchar *
1585 gst_value_serialize_int64_range (const GValue * value)
1586 {
1587   if (INT64_RANGE_STEP (value) == 1)
1588     return g_strdup_printf (&quot;[ %&quot; G_GINT64_FORMAT &quot;, %&quot; G_GINT64_FORMAT &quot; ]&quot;,
1589         INT64_RANGE_MIN (value), INT64_RANGE_MAX (value));
1590   else
1591     return g_strdup_printf (&quot;[ %&quot; G_GINT64_FORMAT &quot;, %&quot; G_GINT64_FORMAT &quot;, %&quot;
1592         G_GINT64_FORMAT &quot; ]&quot;,
1593         INT64_RANGE_MIN (value) * INT64_RANGE_STEP (value),
1594         INT64_RANGE_MAX (value) * INT64_RANGE_STEP (value),
1595         INT64_RANGE_STEP (value));
1596 }
1597 
1598 static gboolean
1599 gst_value_deserialize_int64_range (GValue * dest, const gchar * s)
1600 {
1601   g_warning (&quot;unimplemented&quot;);
1602   return FALSE;
1603 }
1604 
1605 /****************
1606  * double range *
1607  ****************/
1608 
1609 static void
1610 gst_value_init_double_range (GValue * value)
1611 {
1612   value-&gt;data[0].v_double = 0;
1613   value-&gt;data[1].v_double = 0;
1614 }
1615 
1616 static void
1617 gst_value_copy_double_range (const GValue * src_value, GValue * dest_value)
1618 {
1619   dest_value-&gt;data[0].v_double = src_value-&gt;data[0].v_double;
1620   dest_value-&gt;data[1].v_double = src_value-&gt;data[1].v_double;
1621 }
1622 
1623 static gchar *
1624 gst_value_collect_double_range (GValue * value, guint n_collect_values,
1625     GTypeCValue * collect_values, guint collect_flags)
1626 {
1627   if (n_collect_values != 2)
1628     return g_strdup_printf (&quot;not enough value locations for `%s&#39; passed&quot;,
1629         G_VALUE_TYPE_NAME (value));
1630   if (collect_values[0].v_double &gt;= collect_values[1].v_double)
1631     return g_strdup_printf (&quot;range start is not smaller than end for `%s&#39;&quot;,
1632         G_VALUE_TYPE_NAME (value));
1633 
1634   value-&gt;data[0].v_double = collect_values[0].v_double;
1635   value-&gt;data[1].v_double = collect_values[1].v_double;
1636 
1637   return NULL;
1638 }
1639 
1640 static gchar *
1641 gst_value_lcopy_double_range (const GValue * value, guint n_collect_values,
1642     GTypeCValue * collect_values, guint collect_flags)
1643 {
1644   gdouble *double_range_start = collect_values[0].v_pointer;
1645   gdouble *double_range_end = collect_values[1].v_pointer;
1646 
1647   if (!double_range_start)
1648     return g_strdup_printf (&quot;start value location for `%s&#39; passed as NULL&quot;,
1649         G_VALUE_TYPE_NAME (value));
1650   if (!double_range_end)
1651     return g_strdup_printf (&quot;end value location for `%s&#39; passed as NULL&quot;,
1652         G_VALUE_TYPE_NAME (value));
1653 
1654   *double_range_start = value-&gt;data[0].v_double;
1655   *double_range_end = value-&gt;data[1].v_double;
1656 
1657   return NULL;
1658 }
1659 
1660 /**
1661  * gst_value_set_double_range:
1662  * @value: a GValue initialized to GST_TYPE_DOUBLE_RANGE
1663  * @start: the start of the range
1664  * @end: the end of the range
1665  *
1666  * Sets @value to the range specified by @start and @end.
1667  */
1668 void
1669 gst_value_set_double_range (GValue * value, gdouble start, gdouble end)
1670 {
1671   g_return_if_fail (GST_VALUE_HOLDS_DOUBLE_RANGE (value));
1672   g_return_if_fail (start &lt; end);
1673 
1674   value-&gt;data[0].v_double = start;
1675   value-&gt;data[1].v_double = end;
1676 }
1677 
1678 /**
1679  * gst_value_get_double_range_min:
1680  * @value: a GValue initialized to GST_TYPE_DOUBLE_RANGE
1681  *
1682  * Gets the minimum of the range specified by @value.
1683  *
1684  * Returns: the minimum of the range
1685  */
1686 gdouble
1687 gst_value_get_double_range_min (const GValue * value)
1688 {
1689   g_return_val_if_fail (GST_VALUE_HOLDS_DOUBLE_RANGE (value), 0);
1690 
1691   return value-&gt;data[0].v_double;
1692 }
1693 
1694 /**
1695  * gst_value_get_double_range_max:
1696  * @value: a GValue initialized to GST_TYPE_DOUBLE_RANGE
1697  *
1698  * Gets the maximum of the range specified by @value.
1699  *
1700  * Returns: the maximum of the range
1701  */
1702 gdouble
1703 gst_value_get_double_range_max (const GValue * value)
1704 {
1705   g_return_val_if_fail (GST_VALUE_HOLDS_DOUBLE_RANGE (value), 0);
1706 
1707   return value-&gt;data[1].v_double;
1708 }
1709 
1710 static void
1711 gst_value_transform_double_range_string (const GValue * src_value,
1712     GValue * dest_value)
1713 {
1714   gchar s1[G_ASCII_DTOSTR_BUF_SIZE], s2[G_ASCII_DTOSTR_BUF_SIZE];
1715 
1716   dest_value-&gt;data[0].v_pointer = g_strdup_printf (&quot;[%s,%s]&quot;,
1717       g_ascii_dtostr (s1, G_ASCII_DTOSTR_BUF_SIZE,
1718           src_value-&gt;data[0].v_double),
1719       g_ascii_dtostr (s2, G_ASCII_DTOSTR_BUF_SIZE,
1720           src_value-&gt;data[1].v_double));
1721 }
1722 
1723 static gint
1724 gst_value_compare_double_range (const GValue * value1, const GValue * value2)
1725 {
1726   if (value2-&gt;data[0].v_double == value1-&gt;data[0].v_double &amp;&amp;
1727       value2-&gt;data[1].v_double == value1-&gt;data[1].v_double)
1728     return GST_VALUE_EQUAL;
1729   return GST_VALUE_UNORDERED;
1730 }
1731 
1732 static gchar *
1733 gst_value_serialize_double_range (const GValue * value)
1734 {
1735   gchar d1[G_ASCII_DTOSTR_BUF_SIZE];
1736   gchar d2[G_ASCII_DTOSTR_BUF_SIZE];
1737 
1738   g_ascii_dtostr (d1, G_ASCII_DTOSTR_BUF_SIZE, value-&gt;data[0].v_double);
1739   g_ascii_dtostr (d2, G_ASCII_DTOSTR_BUF_SIZE, value-&gt;data[1].v_double);
1740   return g_strdup_printf (&quot;[ %s, %s ]&quot;, d1, d2);
1741 }
1742 
1743 static gboolean
1744 gst_value_deserialize_double_range (GValue * dest, const gchar * s)
1745 {
1746   g_warning (&quot;unimplemented&quot;);
1747   return FALSE;
1748 }
1749 
1750 /****************
1751  * fraction range *
1752  ****************/
1753 
1754 static void
1755 gst_value_init_fraction_range (GValue * value)
1756 {
1757   GValue *vals;
1758   GType ftype;
1759 
1760   ftype = GST_TYPE_FRACTION;
1761 
1762   value-&gt;data[0].v_pointer = vals = g_slice_alloc0 (2 * sizeof (GValue));
1763   g_value_init (&amp;vals[0], ftype);
1764   g_value_init (&amp;vals[1], ftype);
1765 }
1766 
1767 static void
1768 gst_value_free_fraction_range (GValue * value)
1769 {
1770   GValue *vals = (GValue *) value-&gt;data[0].v_pointer;
1771 
1772   if (vals != NULL) {
1773     /* we know the two values contain fractions without internal allocs */
1774     /* g_value_unset (&amp;vals[0]); */
1775     /* g_value_unset (&amp;vals[1]); */
1776     g_slice_free1 (2 * sizeof (GValue), vals);
1777     value-&gt;data[0].v_pointer = NULL;
1778   }
1779 }
1780 
1781 static void
1782 gst_value_copy_fraction_range (const GValue * src_value, GValue * dest_value)
1783 {
1784   GValue *vals = (GValue *) dest_value-&gt;data[0].v_pointer;
1785   GValue *src_vals = (GValue *) src_value-&gt;data[0].v_pointer;
1786 
1787   if (vals == NULL) {
1788     gst_value_init_fraction_range (dest_value);
1789     vals = dest_value-&gt;data[0].v_pointer;
1790   }
1791   if (src_vals != NULL) {
1792     g_value_copy (&amp;src_vals[0], &amp;vals[0]);
1793     g_value_copy (&amp;src_vals[1], &amp;vals[1]);
1794   }
1795 }
1796 
1797 static gchar *
1798 gst_value_collect_fraction_range (GValue * value, guint n_collect_values,
1799     GTypeCValue * collect_values, guint collect_flags)
1800 {
1801   GValue *vals = (GValue *) value-&gt;data[0].v_pointer;
1802 
1803   if (n_collect_values != 4)
1804     return g_strdup_printf (&quot;not enough value locations for `%s&#39; passed&quot;,
1805         G_VALUE_TYPE_NAME (value));
1806   if (collect_values[1].v_int == 0)
1807     return g_strdup_printf (&quot;passed &#39;0&#39; as first denominator for `%s&#39;&quot;,
1808         G_VALUE_TYPE_NAME (value));
1809   if (collect_values[3].v_int == 0)
1810     return g_strdup_printf (&quot;passed &#39;0&#39; as second denominator for `%s&#39;&quot;,
1811         G_VALUE_TYPE_NAME (value));
1812   if (gst_util_fraction_compare (collect_values[0].v_int,
1813           collect_values[1].v_int, collect_values[2].v_int,
1814           collect_values[3].v_int) &gt;= 0)
1815     return g_strdup_printf (&quot;range start is not smaller than end for `%s&#39;&quot;,
1816         G_VALUE_TYPE_NAME (value));
1817 
1818   if (vals == NULL) {
1819     gst_value_init_fraction_range (value);
1820     vals = value-&gt;data[0].v_pointer;
1821   }
1822 
1823   gst_value_set_fraction (&amp;vals[0], collect_values[0].v_int,
1824       collect_values[1].v_int);
1825   gst_value_set_fraction (&amp;vals[1], collect_values[2].v_int,
1826       collect_values[3].v_int);
1827 
1828   return NULL;
1829 }
1830 
1831 static gchar *
1832 gst_value_lcopy_fraction_range (const GValue * value, guint n_collect_values,
1833     GTypeCValue * collect_values, guint collect_flags)
1834 {
1835   gint i;
1836   gint *dest_values[4];
1837   GValue *vals = (GValue *) value-&gt;data[0].v_pointer;
1838 
1839   if (G_UNLIKELY (n_collect_values != 4))
1840     return g_strdup_printf (&quot;not enough value locations for `%s&#39; passed&quot;,
1841         G_VALUE_TYPE_NAME (value));
1842 
1843   for (i = 0; i &lt; 4; i++) {
1844     if (G_UNLIKELY (collect_values[i].v_pointer == NULL)) {
1845       return g_strdup_printf (&quot;value location for `%s&#39; passed as NULL&quot;,
1846           G_VALUE_TYPE_NAME (value));
1847     }
1848     dest_values[i] = collect_values[i].v_pointer;
1849   }
1850 
1851   if (G_UNLIKELY (vals == NULL)) {
1852     return g_strdup_printf (&quot;Uninitialised `%s&#39; passed&quot;,
1853         G_VALUE_TYPE_NAME (value));
1854   }
1855 
1856   dest_values[0][0] = gst_value_get_fraction_numerator (&amp;vals[0]);
1857   dest_values[1][0] = gst_value_get_fraction_denominator (&amp;vals[0]);
1858   dest_values[2][0] = gst_value_get_fraction_numerator (&amp;vals[1]);
1859   dest_values[3][0] = gst_value_get_fraction_denominator (&amp;vals[1]);
1860   return NULL;
1861 }
1862 
1863 /**
1864  * gst_value_set_fraction_range:
1865  * @value: a GValue initialized to GST_TYPE_FRACTION_RANGE
1866  * @start: the start of the range (a GST_TYPE_FRACTION GValue)
1867  * @end: the end of the range (a GST_TYPE_FRACTION GValue)
1868  *
1869  * Sets @value to the range specified by @start and @end.
1870  */
1871 void
1872 gst_value_set_fraction_range (GValue * value, const GValue * start,
1873     const GValue * end)
1874 {
1875   GValue *vals;
1876 
1877   g_return_if_fail (GST_VALUE_HOLDS_FRACTION_RANGE (value));
1878   g_return_if_fail (GST_VALUE_HOLDS_FRACTION (start));
1879   g_return_if_fail (GST_VALUE_HOLDS_FRACTION (end));
1880   g_return_if_fail (gst_util_fraction_compare (start-&gt;data[0].v_int,
1881           start-&gt;data[1].v_int, end-&gt;data[0].v_int, end-&gt;data[1].v_int) &lt; 0);
1882 
1883   vals = (GValue *) value-&gt;data[0].v_pointer;
1884   if (vals == NULL) {
1885     gst_value_init_fraction_range (value);
1886     vals = value-&gt;data[0].v_pointer;
1887   }
1888   g_value_copy (start, &amp;vals[0]);
1889   g_value_copy (end, &amp;vals[1]);
1890 }
1891 
1892 /**
1893  * gst_value_set_fraction_range_full:
1894  * @value: a GValue initialized to GST_TYPE_FRACTION_RANGE
1895  * @numerator_start: the numerator start of the range
1896  * @denominator_start: the denominator start of the range
1897  * @numerator_end: the numerator end of the range
1898  * @denominator_end: the denominator end of the range
1899  *
1900  * Sets @value to the range specified by @numerator_start/@denominator_start
1901  * and @numerator_end/@denominator_end.
1902  */
1903 void
1904 gst_value_set_fraction_range_full (GValue * value,
1905     gint numerator_start, gint denominator_start,
1906     gint numerator_end, gint denominator_end)
1907 {
1908   GValue start = { 0 };
1909   GValue end = { 0 };
1910 
1911   g_return_if_fail (value != NULL);
1912   g_return_if_fail (denominator_start != 0);
1913   g_return_if_fail (denominator_end != 0);
1914   g_return_if_fail (gst_util_fraction_compare (numerator_start,
1915           denominator_start, numerator_end, denominator_end) &lt; 0);
1916 
1917   g_value_init (&amp;start, GST_TYPE_FRACTION);
1918   g_value_init (&amp;end, GST_TYPE_FRACTION);
1919 
1920   gst_value_set_fraction (&amp;start, numerator_start, denominator_start);
1921   gst_value_set_fraction (&amp;end, numerator_end, denominator_end);
1922   gst_value_set_fraction_range (value, &amp;start, &amp;end);
1923 
1924   /* we know the two values contain fractions without internal allocs */
1925   /* g_value_unset (&amp;start); */
1926   /* g_value_unset (&amp;end);   */
1927 }
1928 
1929 /* FIXME 2.0: Don&#39;t leak the internal representation of fraction
1930  * ranges but instead return the numerator and denominator
1931  * separately.
1932  * This would allow to store fraction ranges as
1933  *  data[0] = (min_n &lt;&lt; 32) | (min_d)
1934  *  data[1] = (max_n &lt;&lt; 32) | (max_d)
1935  * without requiring an additional allocation for each value.
1936  */
1937 
1938 /**
1939  * gst_value_get_fraction_range_min:
1940  * @value: a GValue initialized to GST_TYPE_FRACTION_RANGE
1941  *
1942  * Gets the minimum of the range specified by @value.
1943  *
1944  * Returns: (nullable): the minimum of the range
1945  */
1946 const GValue *
1947 gst_value_get_fraction_range_min (const GValue * value)
1948 {
1949   GValue *vals;
1950 
1951   g_return_val_if_fail (GST_VALUE_HOLDS_FRACTION_RANGE (value), NULL);
1952 
1953   vals = (GValue *) value-&gt;data[0].v_pointer;
1954   if (vals != NULL) {
1955     return &amp;vals[0];
1956   }
1957 
1958   return NULL;
1959 }
1960 
1961 /**
1962  * gst_value_get_fraction_range_max:
1963  * @value: a GValue initialized to GST_TYPE_FRACTION_RANGE
1964  *
1965  * Gets the maximum of the range specified by @value.
1966  *
1967  * Returns: (nullable): the maximum of the range
1968  */
1969 const GValue *
1970 gst_value_get_fraction_range_max (const GValue * value)
1971 {
1972   GValue *vals;
1973 
1974   g_return_val_if_fail (GST_VALUE_HOLDS_FRACTION_RANGE (value), NULL);
1975 
1976   vals = (GValue *) value-&gt;data[0].v_pointer;
1977   if (vals != NULL) {
1978     return &amp;vals[1];
1979   }
1980 
1981   return NULL;
1982 }
1983 
1984 static gchar *
1985 gst_value_serialize_fraction_range (const GValue * value)
1986 {
1987   GValue *vals = (GValue *) value-&gt;data[0].v_pointer;
1988   gchar *retval;
1989 
1990   if (vals == NULL) {
1991     retval = g_strdup (&quot;[ 0/1, 0/1 ]&quot;);
1992   } else {
1993     gchar *start, *end;
1994 
1995     start = gst_value_serialize_fraction (&amp;vals[0]);
1996     end = gst_value_serialize_fraction (&amp;vals[1]);
1997 
1998     retval = g_strdup_printf (&quot;[ %s, %s ]&quot;, start, end);
1999     g_free (start);
2000     g_free (end);
2001   }
2002 
2003   return retval;
2004 }
2005 
2006 static void
2007 gst_value_transform_fraction_range_string (const GValue * src_value,
2008     GValue * dest_value)
2009 {
2010   dest_value-&gt;data[0].v_pointer =
2011       gst_value_serialize_fraction_range (src_value);
2012 }
2013 
2014 static gint
2015 gst_value_compare_fraction_range (const GValue * value1, const GValue * value2)
2016 {
2017   GValue *vals1, *vals2;
2018   GstValueCompareFunc compare;
2019 
2020   if (value2-&gt;data[0].v_pointer == value1-&gt;data[0].v_pointer)
2021     return GST_VALUE_EQUAL;     /* Only possible if both are NULL */
2022 
2023   if (value2-&gt;data[0].v_pointer == NULL || value1-&gt;data[0].v_pointer == NULL)
2024     return GST_VALUE_UNORDERED;
2025 
2026   vals1 = (GValue *) value1-&gt;data[0].v_pointer;
2027   vals2 = (GValue *) value2-&gt;data[0].v_pointer;
2028   if ((compare = gst_value_get_compare_func (&amp;vals1[0]))) {
2029     if (gst_value_compare_with_func (&amp;vals1[0], &amp;vals2[0], compare) ==
2030         GST_VALUE_EQUAL &amp;&amp;
2031         gst_value_compare_with_func (&amp;vals1[1], &amp;vals2[1], compare) ==
2032         GST_VALUE_EQUAL)
2033       return GST_VALUE_EQUAL;
2034   }
2035   return GST_VALUE_UNORDERED;
2036 }
2037 
2038 static gboolean
2039 gst_value_deserialize_fraction_range (GValue * dest, const gchar * s)
2040 {
2041   g_warning (&quot;unimplemented&quot;);
2042   return FALSE;
2043 }
2044 
2045 /***********
2046  * GstCaps *
2047  ***********/
2048 
2049 /**
2050  * gst_value_set_caps:
2051  * @value: a GValue initialized to GST_TYPE_CAPS
2052  * @caps: (transfer none): the caps to set the value to
2053  *
2054  * Sets the contents of @value to @caps. A reference to the
2055  * provided @caps will be taken by the @value.
2056  */
2057 void
2058 gst_value_set_caps (GValue * value, const GstCaps * caps)
2059 {
2060   g_return_if_fail (G_IS_VALUE (value));
2061   g_return_if_fail (G_VALUE_TYPE (value) == GST_TYPE_CAPS);
2062   g_return_if_fail (caps == NULL || GST_IS_CAPS (caps));
2063 
2064   g_value_set_boxed (value, caps);
2065 }
2066 
2067 /**
2068  * gst_value_get_caps:
2069  * @value: a GValue initialized to GST_TYPE_CAPS
2070  *
2071  * Gets the contents of @value. The reference count of the returned
2072  * #GstCaps will not be modified, therefore the caller must take one
2073  * before getting rid of the @value.
2074  *
2075  * Returns: (transfer none): the contents of @value
2076  */
2077 const GstCaps *
2078 gst_value_get_caps (const GValue * value)
2079 {
2080   g_return_val_if_fail (G_IS_VALUE (value), NULL);
2081   g_return_val_if_fail (G_VALUE_TYPE (value) == GST_TYPE_CAPS, NULL);
2082 
2083   return (GstCaps *) g_value_get_boxed (value);
2084 }
2085 
2086 static gint
2087 gst_value_compare_caps (const GValue * value1, const GValue * value2)
2088 {
2089   GstCaps *caps1 = GST_CAPS (gst_value_get_caps (value1));
2090   GstCaps *caps2 = GST_CAPS (gst_value_get_caps (value2));
2091 
2092   if (gst_caps_is_equal (caps1, caps2))
2093     return GST_VALUE_EQUAL;
2094   return GST_VALUE_UNORDERED;
2095 }
2096 
2097 static gchar *
2098 gst_value_serialize_caps (const GValue * value)
2099 {
2100   GstCaps *caps = g_value_get_boxed (value);
2101   return priv_gst_string_take_and_wrap (gst_caps_to_string (caps));
2102 }
2103 
2104 static gboolean
2105 gst_value_deserialize_caps (GValue * dest, const gchar * s)
2106 {
2107   GstCaps *caps;
2108 
2109   if (*s != &#39;&quot;&#39;) {
2110     caps = gst_caps_from_string (s);
2111   } else {
2112     gchar *str = gst_string_unwrap (s);
2113 
2114     if (G_UNLIKELY (!str))
2115       return FALSE;
2116 
2117     caps = gst_caps_from_string (str);
2118     g_free (str);
2119   }
2120 
2121   if (caps) {
2122     g_value_take_boxed (dest, caps);
2123     return TRUE;
2124   }
2125   return FALSE;
2126 }
2127 
2128 /********************************************
2129  * Serialization/deserialization of GValues *
2130  ********************************************/
2131 
2132 static GstValueAbbreviation *
2133 _priv_gst_value_get_abbrs (gint * n_abbrs)
2134 {
2135   static GstValueAbbreviation *abbrs = NULL;
2136   static volatile gsize num = 0;
2137 
2138   if (g_once_init_enter (&amp;num)) {
2139     /* dynamically generate the array */
2140     gsize _num;
2141     GstValueAbbreviation dyn_abbrs[] = {
2142       {&quot;int&quot;, G_TYPE_INT}
2143       ,
2144       {&quot;i&quot;, G_TYPE_INT}
2145       ,
2146       {&quot;uint&quot;, G_TYPE_UINT}
2147       ,
2148       {&quot;u&quot;, G_TYPE_UINT}
2149       ,
2150       {&quot;float&quot;, G_TYPE_FLOAT}
2151       ,
2152       {&quot;f&quot;, G_TYPE_FLOAT}
2153       ,
2154       {&quot;double&quot;, G_TYPE_DOUBLE}
2155       ,
2156       {&quot;d&quot;, G_TYPE_DOUBLE}
2157       ,
2158       {&quot;buffer&quot;, GST_TYPE_BUFFER}
2159       ,
2160       {&quot;fraction&quot;, GST_TYPE_FRACTION}
2161       ,
2162       {&quot;boolean&quot;, G_TYPE_BOOLEAN}
2163       ,
2164       {&quot;bool&quot;, G_TYPE_BOOLEAN}
2165       ,
2166       {&quot;b&quot;, G_TYPE_BOOLEAN}
2167       ,
2168       {&quot;string&quot;, G_TYPE_STRING}
2169       ,
2170       {&quot;str&quot;, G_TYPE_STRING}
2171       ,
2172       {&quot;s&quot;, G_TYPE_STRING}
2173       ,
2174       {&quot;structure&quot;, GST_TYPE_STRUCTURE}
2175       ,
2176       {&quot;date&quot;, G_TYPE_DATE}
2177       ,
2178       {&quot;datetime&quot;, GST_TYPE_DATE_TIME}
2179       ,
2180       {&quot;bitmask&quot;, GST_TYPE_BITMASK}
2181       ,
2182       {&quot;flagset&quot;, GST_TYPE_FLAG_SET}
2183       ,
2184       {&quot;sample&quot;, GST_TYPE_SAMPLE}
2185       ,
2186       {&quot;taglist&quot;, GST_TYPE_TAG_LIST}
2187       ,
2188       {&quot;type&quot;, G_TYPE_GTYPE}
2189       ,
2190       {&quot;array&quot;, GST_TYPE_ARRAY}
2191       ,
2192       {&quot;list&quot;, GST_TYPE_LIST}
2193     };
2194     _num = G_N_ELEMENTS (dyn_abbrs);
2195     /* permanently allocate and copy the array now */
2196     abbrs = g_new0 (GstValueAbbreviation, _num);
2197     memcpy (abbrs, dyn_abbrs, sizeof (GstValueAbbreviation) * _num);
2198     g_once_init_leave (&amp;num, _num);
2199   }
2200   *n_abbrs = num;
2201 
2202   return abbrs;
2203 }
2204 
2205 /* given a type_name that could be a type abbreviation or a registered GType,
2206  * return a matching GType */
2207 static GType
2208 _priv_gst_value_gtype_from_abbr (const char *type_name)
2209 {
2210   int i;
2211   GstValueAbbreviation *abbrs;
2212   gint n_abbrs;
2213   GType ret;
2214 
2215   g_return_val_if_fail (type_name != NULL, G_TYPE_INVALID);
2216 
2217   abbrs = _priv_gst_value_get_abbrs (&amp;n_abbrs);
2218 
2219   for (i = 0; i &lt; n_abbrs; i++) {
2220     if (strcmp (type_name, abbrs[i].type_name) == 0) {
2221       return abbrs[i].type;
2222     }
2223   }
2224 
2225   /* this is the fallback */
2226   ret = g_type_from_name (type_name);
2227   /* If not found, try it as a dynamic type */
2228   if (G_UNLIKELY (ret == 0))
2229     ret = gst_dynamic_type_factory_load (type_name);
2230   return ret;
2231 
2232 }
2233 
2234 const char *
2235 _priv_gst_value_gtype_to_abbr (GType type)
2236 {
2237   int i;
2238   GstValueAbbreviation *abbrs;
2239   gint n_abbrs;
2240 
2241   g_return_val_if_fail (type != G_TYPE_INVALID, NULL);
2242 
2243   abbrs = _priv_gst_value_get_abbrs (&amp;n_abbrs);
2244 
2245   for (i = 0; i &lt; n_abbrs; i++) {
2246     if (type == abbrs[i].type) {
2247       return abbrs[i].type_name;
2248     }
2249   }
2250 
2251   return g_type_name (type);
2252 }
2253 
2254 /*
2255  * _priv_gst_value_parse_string:
2256  * @s: string to parse
2257  * @end: out-pointer to char behind end of string
2258  * @next: out-pointer to start of unread data
2259  * @unescape: @TRUE if the substring is escaped.
2260  *
2261  * Find the end of a sub-string. If end == next, the string will not be
2262  * null-terminated. In all other cases it will be.
2263  *
2264  * Note: This function modifies the string in @s (if unescape == @TRUE).
2265  *
2266  * Returns: @TRUE if a sub-string was found and @FALSE if the string is not
2267  * terminated.
2268  */
2269 gboolean
2270 _priv_gst_value_parse_string (gchar * s, gchar ** end, gchar ** next,
2271     gboolean unescape)
2272 {
2273   gchar *w;
2274 
2275   if (*s == 0)
2276     return FALSE;
2277 
2278   if (*s != &#39;&quot;&#39;) {
2279     int ret = _priv_gst_value_parse_simple_string (s, end);
2280     *next = *end;
2281 
2282     return ret;
2283   }
2284 
2285   /* Find the closing quotes */
2286   if (unescape) {
2287     w = s;
2288     s++;
2289     while (*s != &#39;&quot;&#39;) {
2290       if (G_UNLIKELY (*s == 0))
2291         return FALSE;
2292       if (G_UNLIKELY (*s == &#39;\\&#39;)) {
2293         s++;
2294         if (G_UNLIKELY (*s == 0))
2295           return FALSE;
2296       }
2297       *w = *s;
2298       w++;
2299       s++;
2300     }
2301     s++;
2302   } else {
2303     s++;
2304     while (*s != &#39;&quot;&#39;) {
2305       if (G_UNLIKELY (*s == 0))
2306         return FALSE;
2307       if (G_UNLIKELY (*s == &#39;\\&#39;)) {
2308         s++;
2309         if (G_UNLIKELY (*s == 0))
2310           return FALSE;
2311       }
2312       s++;
2313     }
2314     s++;
2315     w = s;
2316   }
2317 
2318   *end = w;
2319   *next = s;
2320 
2321   return TRUE;
2322 }
2323 
2324 static gboolean
2325 _priv_gst_value_parse_range (gchar * s, gchar ** after, GValue * value,
2326     GType type)
2327 {
2328   GValue value1 = { 0 };
2329   GValue value2 = { 0 };
2330   GValue value3 = { 0 };
2331   GType range_type;
2332   gboolean ret, have_step = FALSE;
2333 
2334   if (*s != &#39;[&#39;)
2335     return FALSE;
2336   s++;
2337 
2338   ret = _priv_gst_value_parse_value (s, &amp;s, &amp;value1, type);
2339   if (!ret)
2340     return FALSE;
2341 
2342   while (g_ascii_isspace (*s))
2343     s++;
2344 
2345   if (*s != &#39;,&#39;)
2346     return FALSE;
2347   s++;
2348 
2349   while (g_ascii_isspace (*s))
2350     s++;
2351 
2352   ret = _priv_gst_value_parse_value (s, &amp;s, &amp;value2, type);
2353   if (!ret)
2354     return FALSE;
2355 
2356   while (g_ascii_isspace (*s))
2357     s++;
2358 
2359   /* optional step for int and int64 */
2360   if (G_VALUE_TYPE (&amp;value1) == G_TYPE_INT
2361       || G_VALUE_TYPE (&amp;value1) == G_TYPE_INT64) {
2362     if (*s == &#39;,&#39;) {
2363       s++;
2364 
2365       while (g_ascii_isspace (*s))
2366         s++;
2367 
2368       ret = _priv_gst_value_parse_value (s, &amp;s, &amp;value3, type);
2369       if (!ret)
2370         return FALSE;
2371 
2372       while (g_ascii_isspace (*s))
2373         s++;
2374 
2375       have_step = TRUE;
2376     }
2377   }
2378 
2379   if (*s != &#39;]&#39;)
2380     return FALSE;
2381   s++;
2382 
2383   if (G_VALUE_TYPE (&amp;value1) != G_VALUE_TYPE (&amp;value2))
2384     return FALSE;
2385   if (have_step &amp;&amp; G_VALUE_TYPE (&amp;value1) != G_VALUE_TYPE (&amp;value3))
2386     return FALSE;
2387 
2388   if (G_VALUE_TYPE (&amp;value1) == G_TYPE_DOUBLE) {
2389     range_type = GST_TYPE_DOUBLE_RANGE;
2390     g_value_init (value, range_type);
2391     gst_value_set_double_range (value,
2392         gst_g_value_get_double_unchecked (&amp;value1),
2393         gst_g_value_get_double_unchecked (&amp;value2));
2394   } else if (G_VALUE_TYPE (&amp;value1) == G_TYPE_INT) {
2395     range_type = GST_TYPE_INT_RANGE;
2396     g_value_init (value, range_type);
2397     if (have_step)
2398       gst_value_set_int_range_step (value,
2399           gst_g_value_get_int_unchecked (&amp;value1),
2400           gst_g_value_get_int_unchecked (&amp;value2),
2401           gst_g_value_get_int_unchecked (&amp;value3));
2402     else
2403       gst_value_set_int_range (value, gst_g_value_get_int_unchecked (&amp;value1),
2404           gst_g_value_get_int_unchecked (&amp;value2));
2405   } else if (G_VALUE_TYPE (&amp;value1) == G_TYPE_INT64) {
2406     range_type = GST_TYPE_INT64_RANGE;
2407     g_value_init (value, range_type);
2408     if (have_step)
2409       gst_value_set_int64_range_step (value,
2410           gst_g_value_get_int64_unchecked (&amp;value1),
2411           gst_g_value_get_int64_unchecked (&amp;value2),
2412           gst_g_value_get_int64_unchecked (&amp;value3));
2413     else
2414       gst_value_set_int64_range (value,
2415           gst_g_value_get_int64_unchecked (&amp;value1),
2416           gst_g_value_get_int64_unchecked (&amp;value2));
2417   } else if (G_VALUE_TYPE (&amp;value1) == GST_TYPE_FRACTION) {
2418     range_type = GST_TYPE_FRACTION_RANGE;
2419     g_value_init (value, range_type);
2420     gst_value_set_fraction_range (value, &amp;value1, &amp;value2);
2421   } else {
2422     return FALSE;
2423   }
2424 
2425   *after = s;
2426   return TRUE;
2427 }
2428 
2429 static gboolean
2430 _priv_gst_value_parse_any_list (gchar * s, gchar ** after, GValue * value,
2431     GType type, char begin, char end)
2432 {
2433   GValue list_value = { 0 };
2434   gboolean ret;
2435   GArray *array;
2436 
2437   array = g_value_peek_pointer (value);
2438 
2439   if (*s != begin)
2440     return FALSE;
2441   s++;
2442 
2443   while (g_ascii_isspace (*s))
2444     s++;
2445   if (*s == end) {
2446     s++;
2447     *after = s;
2448     return TRUE;
2449   }
2450 
2451   ret = _priv_gst_value_parse_value (s, &amp;s, &amp;list_value, type);
2452   if (!ret)
2453     return FALSE;
2454 
2455   g_array_append_val (array, list_value);
2456 
2457   while (g_ascii_isspace (*s))
2458     s++;
2459 
2460   while (*s != end) {
2461     if (*s != &#39;,&#39;)
2462       return FALSE;
2463     s++;
2464 
2465     while (g_ascii_isspace (*s))
2466       s++;
2467 
2468     memset (&amp;list_value, 0, sizeof (list_value));
2469     ret = _priv_gst_value_parse_value (s, &amp;s, &amp;list_value, type);
2470     if (!ret)
2471       return FALSE;
2472 
2473     g_array_append_val (array, list_value);
2474     while (g_ascii_isspace (*s))
2475       s++;
2476   }
2477 
2478   s++;
2479 
2480   *after = s;
2481   return TRUE;
2482 }
2483 
2484 static gboolean
2485 _priv_gst_value_parse_list (gchar * s, gchar ** after, GValue * value,
2486     GType type)
2487 {
2488   return _priv_gst_value_parse_any_list (s, after, value, type, &#39;{&#39;, &#39;}&#39;);
2489 }
2490 
2491 static gboolean
2492 _priv_gst_value_parse_array (gchar * s, gchar ** after, GValue * value,
2493     GType type)
2494 {
2495   return _priv_gst_value_parse_any_list (s, after, value, type, &#39;&lt;&#39;, &#39;&gt;&#39;);
2496 }
2497 
2498 gboolean
2499 _priv_gst_value_parse_simple_string (gchar * str, gchar ** end)
2500 {
2501   char *s = str;
2502 
2503   while (G_LIKELY (GST_ASCII_IS_STRING (*s))) {
2504     s++;
2505   }
2506 
2507   *end = s;
2508 
2509   return (s != str);
2510 }
2511 
2512 gboolean
2513 _priv_gst_value_parse_value (gchar * str,
2514     gchar ** after, GValue * value, GType default_type)
2515 {
2516   gchar *type_name;
2517   gchar *type_end;
2518   gchar *value_s;
2519   gchar *value_end;
2520   gchar *s;
2521   gchar c;
2522   int ret = 0;
2523   GType type = default_type;
2524 
2525   s = str;
2526   while (g_ascii_isspace (*s))
2527     s++;
2528 
2529   /* check if there&#39;s a (type_name) &#39;cast&#39; */
2530   type_name = NULL;
2531   if (*s == &#39;(&#39;) {
2532     s++;
2533     while (g_ascii_isspace (*s))
2534       s++;
2535     type_name = s;
2536     if (G_UNLIKELY (!_priv_gst_value_parse_simple_string (s, &amp;type_end)))
2537       return FALSE;
2538     s = type_end;
2539     while (g_ascii_isspace (*s))
2540       s++;
2541     if (G_UNLIKELY (*s != &#39;)&#39;))
2542       return FALSE;
2543     s++;
2544     while (g_ascii_isspace (*s))
2545       s++;
2546 
2547     c = *type_end;
2548     *type_end = 0;
2549     type = _priv_gst_value_gtype_from_abbr (type_name);
2550     GST_DEBUG (&quot;trying type name &#39;%s&#39;&quot;, type_name);
2551     *type_end = c;
2552 
2553     if (G_UNLIKELY (type == G_TYPE_INVALID)) {
2554       GST_WARNING (&quot;invalid type&quot;);
2555       return FALSE;
2556     }
2557   }
2558 
2559   while (g_ascii_isspace (*s))
2560     s++;
2561   if (*s == &#39;[&#39;) {
2562     ret = _priv_gst_value_parse_range (s, &amp;s, value, type);
2563   } else if (*s == &#39;{&#39;) {
2564     g_value_init (value, GST_TYPE_LIST);
2565     ret = _priv_gst_value_parse_list (s, &amp;s, value, type);
2566   } else if (*s == &#39;&lt;&#39;) {
2567     g_value_init (value, GST_TYPE_ARRAY);
2568     ret = _priv_gst_value_parse_array (s, &amp;s, value, type);
2569   } else {
2570     value_s = s;
2571 
2572     if (G_UNLIKELY (type == G_TYPE_INVALID)) {
2573       GType try_types[] =
2574           { G_TYPE_INT, G_TYPE_DOUBLE, GST_TYPE_FRACTION, GST_TYPE_FLAG_SET,
2575         G_TYPE_BOOLEAN, G_TYPE_STRING
2576       };
2577       int i;
2578 
2579       if (G_UNLIKELY (!_priv_gst_value_parse_string (s, &amp;value_end, &amp;s, TRUE)))
2580         return FALSE;
2581       /* Set NULL terminator for deserialization */
2582       c = *value_end;
2583       *value_end = &#39;\0&#39;;
2584 
2585       for (i = 0; i &lt; G_N_ELEMENTS (try_types); i++) {
2586         g_value_init (value, try_types[i]);
2587         ret = gst_value_deserialize (value, value_s);
2588         if (ret)
2589           break;
2590         g_value_unset (value);
2591       }
2592     } else {
2593       g_value_init (value, type);
2594 
2595       if (G_UNLIKELY (!_priv_gst_value_parse_string (s, &amp;value_end, &amp;s,
2596                   (type != G_TYPE_STRING))))
2597         return FALSE;
2598       /* Set NULL terminator for deserialization */
2599       c = *value_end;
2600       *value_end = &#39;\0&#39;;
2601 
2602       ret = gst_value_deserialize (value, value_s);
2603       if (G_UNLIKELY (!ret))
2604         g_value_unset (value);
2605     }
2606     *value_end = c;
2607   }
2608 
2609   *after = s;
2610 
2611   return ret;
2612 }
2613 
2614 /**************
2615  * GstSegment *
2616  **************/
2617 
2618 static gchar *
2619 gst_value_serialize_segment_internal (const GValue * value, gboolean escape)
2620 {
2621   GstSegment *seg = g_value_get_boxed (value);
2622   gchar *t, *res;
2623   GstStructure *s;
2624 
2625   s = gst_structure_new (&quot;GstSegment&quot;,
2626       &quot;flags&quot;, GST_TYPE_SEGMENT_FLAGS, seg-&gt;flags,
2627       &quot;rate&quot;, G_TYPE_DOUBLE, seg-&gt;rate,
2628       &quot;applied-rate&quot;, G_TYPE_DOUBLE, seg-&gt;applied_rate,
2629       &quot;format&quot;, GST_TYPE_FORMAT, seg-&gt;format,
2630       &quot;base&quot;, G_TYPE_UINT64, seg-&gt;base,
2631       &quot;offset&quot;, G_TYPE_UINT64, seg-&gt;offset,
2632       &quot;start&quot;, G_TYPE_UINT64, seg-&gt;start,
2633       &quot;stop&quot;, G_TYPE_UINT64, seg-&gt;stop,
2634       &quot;time&quot;, G_TYPE_UINT64, seg-&gt;time,
2635       &quot;position&quot;, G_TYPE_UINT64, seg-&gt;position,
2636       &quot;duration&quot;, G_TYPE_UINT64, seg-&gt;duration, NULL);
2637   t = gst_structure_to_string (s);
2638   if (escape) {
2639     res = g_strdup_printf (&quot;\&quot;%s\&quot;&quot;, t);
2640     g_free (t);
2641   } else {
2642     res = t;
2643   }
2644   gst_structure_free (s);
2645 
2646   return res;
2647 }
2648 
2649 static gchar *
2650 gst_value_serialize_segment (const GValue * value)
2651 {
2652   return gst_value_serialize_segment_internal (value, TRUE);
2653 }
2654 
2655 static gboolean
2656 gst_value_deserialize_segment (GValue * dest, const gchar * s)
2657 {
2658   GstStructure *str;
2659   GstSegment seg;
2660   gboolean res;
2661 
2662   str = gst_structure_from_string (s, NULL);
2663   if (str == NULL)
2664     return FALSE;
2665 
2666   res = gst_structure_get (str,
2667       &quot;flags&quot;, GST_TYPE_SEGMENT_FLAGS, &amp;seg.flags,
2668       &quot;rate&quot;, G_TYPE_DOUBLE, &amp;seg.rate,
2669       &quot;applied-rate&quot;, G_TYPE_DOUBLE, &amp;seg.applied_rate,
2670       &quot;format&quot;, GST_TYPE_FORMAT, &amp;seg.format,
2671       &quot;base&quot;, G_TYPE_UINT64, &amp;seg.base,
2672       &quot;offset&quot;, G_TYPE_UINT64, &amp;seg.offset,
2673       &quot;start&quot;, G_TYPE_UINT64, &amp;seg.start,
2674       &quot;stop&quot;, G_TYPE_UINT64, &amp;seg.stop,
2675       &quot;time&quot;, G_TYPE_UINT64, &amp;seg.time,
2676       &quot;position&quot;, G_TYPE_UINT64, &amp;seg.position,
2677       &quot;duration&quot;, G_TYPE_UINT64, &amp;seg.duration, NULL);
2678   gst_structure_free (str);
2679 
2680   if (res)
2681     g_value_set_boxed (dest, &amp;seg);
2682 
2683   return res;
2684 }
2685 
2686 /****************
2687  * GstStructure *
2688  ****************/
2689 
2690 /**
2691  * gst_value_set_structure:
2692  * @value: a GValue initialized to GST_TYPE_STRUCTURE
2693  * @structure: the structure to set the value to
2694  *
2695  * Sets the contents of @value to @structure.
2696  */
2697 void
2698 gst_value_set_structure (GValue * value, const GstStructure * structure)
2699 {
2700   g_return_if_fail (G_IS_VALUE (value));
2701   g_return_if_fail (G_VALUE_TYPE (value) == GST_TYPE_STRUCTURE);
2702   g_return_if_fail (structure == NULL || GST_IS_STRUCTURE (structure));
2703 
2704   g_value_set_boxed (value, structure);
2705 }
2706 
2707 /**
2708  * gst_value_get_structure:
2709  * @value: a GValue initialized to GST_TYPE_STRUCTURE
2710  *
2711  * Gets the contents of @value.
2712  *
2713  * Returns: (transfer none): the contents of @value
2714  */
2715 const GstStructure *
2716 gst_value_get_structure (const GValue * value)
2717 {
2718   g_return_val_if_fail (G_IS_VALUE (value), NULL);
2719   g_return_val_if_fail (G_VALUE_TYPE (value) == GST_TYPE_STRUCTURE, NULL);
2720 
2721   return (GstStructure *) g_value_get_boxed (value);
2722 }
2723 
2724 static gchar *
2725 gst_value_serialize_structure (const GValue * value)
2726 {
2727   GstStructure *structure = g_value_get_boxed (value);
2728 
2729   return priv_gst_string_take_and_wrap (gst_structure_to_string (structure));
2730 }
2731 
2732 static gboolean
2733 gst_value_deserialize_structure (GValue * dest, const gchar * s)
2734 {
2735   GstStructure *structure;
2736 
2737   if (*s != &#39;&quot;&#39;) {
2738     structure = gst_structure_from_string (s, NULL);
2739   } else {
2740     gchar *str = gst_string_unwrap (s);
2741 
2742     if (G_UNLIKELY (!str))
2743       return FALSE;
2744 
2745     structure = gst_structure_from_string (str, NULL);
2746     g_free (str);
2747   }
2748 
2749   if (G_LIKELY (structure)) {
2750     g_value_take_boxed (dest, structure);
2751     return TRUE;
2752   }
2753   return FALSE;
2754 }
2755 
2756 static gboolean
2757 gst_value_compare_structure (const GValue * value1, const GValue * value2)
2758 {
2759   GstStructure *structure1 = GST_STRUCTURE (g_value_get_boxed (value1));
2760   GstStructure *structure2 = GST_STRUCTURE (g_value_get_boxed (value2));
2761 
2762   if (structure1 == structure2)
2763     return GST_VALUE_EQUAL;
2764 
2765   if (!structure1 || !structure2)
2766     return GST_VALUE_UNORDERED;
2767 
2768   if (gst_structure_is_equal (structure1, structure2))
2769     return GST_VALUE_EQUAL;
2770 
2771   return GST_VALUE_UNORDERED;
2772 }
2773 
2774 /*******************
2775  * GstCapsFeatures *
2776  *******************/
2777 
2778 /**
2779  * gst_value_set_caps_features:
2780  * @value: a GValue initialized to GST_TYPE_CAPS_FEATURES
2781  * @features: the features to set the value to
2782  *
2783  * Sets the contents of @value to @features.
2784  */
2785 void
2786 gst_value_set_caps_features (GValue * value, const GstCapsFeatures * features)
2787 {
2788   g_return_if_fail (G_IS_VALUE (value));
2789   g_return_if_fail (G_VALUE_TYPE (value) == GST_TYPE_CAPS_FEATURES);
2790   g_return_if_fail (features == NULL || GST_IS_CAPS_FEATURES (features));
2791 
2792   g_value_set_boxed (value, features);
2793 }
2794 
2795 /**
2796  * gst_value_get_caps_features:
2797  * @value: a GValue initialized to GST_TYPE_CAPS_FEATURES
2798  *
2799  * Gets the contents of @value.
2800  *
2801  * Returns: (transfer none): the contents of @value
2802  */
2803 const GstCapsFeatures *
2804 gst_value_get_caps_features (const GValue * value)
2805 {
2806   g_return_val_if_fail (G_IS_VALUE (value), NULL);
2807   g_return_val_if_fail (G_VALUE_TYPE (value) == GST_TYPE_CAPS_FEATURES, NULL);
2808 
2809   return (GstCapsFeatures *) g_value_get_boxed (value);
2810 }
2811 
2812 static gchar *
2813 gst_value_serialize_caps_features (const GValue * value)
2814 {
2815   GstCapsFeatures *features = g_value_get_boxed (value);
2816 
2817   return priv_gst_string_take_and_wrap (gst_caps_features_to_string (features));
2818 }
2819 
2820 static gboolean
2821 gst_value_deserialize_caps_features (GValue * dest, const gchar * s)
2822 {
2823   GstCapsFeatures *features;
2824 
2825   if (*s != &#39;&quot;&#39;) {
2826     features = gst_caps_features_from_string (s);
2827   } else {
2828     gchar *str = gst_string_unwrap (s);
2829 
2830     if (G_UNLIKELY (!str))
2831       return FALSE;
2832 
2833     features = gst_caps_features_from_string (str);
2834     g_free (str);
2835   }
2836 
2837   if (G_LIKELY (features)) {
2838     g_value_take_boxed (dest, features);
2839     return TRUE;
2840   }
2841   return FALSE;
2842 }
2843 
2844 /**************
2845  * GstTagList *
2846  **************/
2847 static gint
2848 gst_value_compare_tag_list (const GValue * value1, const GValue * value2)
2849 {
2850   GstTagList *taglist1 = GST_TAG_LIST (g_value_get_boxed (value1));
2851   GstTagList *taglist2 = GST_TAG_LIST (g_value_get_boxed (value2));
2852 
2853   if (gst_tag_list_is_equal (taglist1, taglist2))
2854     return GST_VALUE_EQUAL;
2855   return GST_VALUE_UNORDERED;
2856 }
2857 
2858 static gboolean
2859 gst_value_deserialize_tag_list (GValue * dest, const gchar * s)
2860 {
2861   GstTagList *taglist;
2862 
2863   if (*s != &#39;&quot;&#39;) {
2864     taglist = gst_tag_list_new_from_string (s);
2865   } else {
2866     gchar *str = gst_string_unwrap (s);
2867 
2868     if (G_UNLIKELY (!str))
2869       return FALSE;
2870 
2871     taglist = gst_tag_list_new_from_string (str);
2872     g_free (str);
2873   }
2874 
2875   if (G_LIKELY (taglist != NULL)) {
2876     g_value_take_boxed (dest, taglist);
2877     return TRUE;
2878   }
2879   return FALSE;
2880 }
2881 
2882 static gchar *
2883 gst_value_serialize_tag_list (const GValue * value)
2884 {
2885   GstTagList *taglist = g_value_get_boxed (value);
2886 
2887   return priv_gst_string_take_and_wrap (gst_tag_list_to_string (taglist));
2888 }
2889 
2890 
2891 /*************
2892  * GstBuffer *
2893  *************/
2894 
2895 static gint
2896 compare_buffer (GstBuffer * buf1, GstBuffer * buf2)
2897 {
2898   gsize size1, size2;
2899   GstMapInfo info1, info2;
2900   gint result, mret;
2901 
2902   if (buf1 == buf2)
2903     return GST_VALUE_EQUAL;
2904 
2905   size1 = gst_buffer_get_size (buf1);
2906   size2 = gst_buffer_get_size (buf2);
2907 
2908   if (size1 != size2)
2909     return GST_VALUE_UNORDERED;
2910 
2911   if (size1 == 0)
2912     return GST_VALUE_EQUAL;
2913 
2914   if (!gst_buffer_map (buf1, &amp;info1, GST_MAP_READ))
2915     return GST_VALUE_UNORDERED;
2916 
2917   if (!gst_buffer_map (buf2, &amp;info2, GST_MAP_READ)) {
2918     gst_buffer_unmap (buf1, &amp;info1);
2919     return GST_VALUE_UNORDERED;
2920   }
2921 
2922   mret = memcmp (info1.data, info2.data, info1.size);
2923   if (mret == 0)
2924     result = GST_VALUE_EQUAL;
2925   else if (mret &lt; 0)
2926     result = GST_VALUE_LESS_THAN;
2927   else
2928     result = GST_VALUE_GREATER_THAN;
2929 
2930   gst_buffer_unmap (buf1, &amp;info1);
2931   gst_buffer_unmap (buf2, &amp;info2);
2932 
2933   return result;
2934 }
2935 
2936 static gint
2937 gst_value_compare_buffer (const GValue * value1, const GValue * value2)
2938 {
2939   GstBuffer *buf1 = gst_value_get_buffer (value1);
2940   GstBuffer *buf2 = gst_value_get_buffer (value2);
2941 
2942   return compare_buffer (buf1, buf2);
2943 }
2944 
2945 static gchar *
2946 gst_value_serialize_buffer (const GValue * value)
2947 {
2948   GstMapInfo info;
2949   guint8 *data;
2950   gint i;
2951   gchar *string;
2952   GstBuffer *buffer;
2953 
2954   buffer = gst_value_get_buffer (value);
2955   if (buffer == NULL)
2956     return NULL;
2957 
2958   if (!gst_buffer_map (buffer, &amp;info, GST_MAP_READ))
2959     return NULL;
2960 
2961   data = info.data;
2962 
2963   string = g_malloc (info.size * 2 + 1);
2964   for (i = 0; i &lt; info.size; i++) {
2965     sprintf (string + i * 2, &quot;%02x&quot;, data[i]);
2966   }
2967   string[info.size * 2] = 0;
2968 
2969   gst_buffer_unmap (buffer, &amp;info);
2970 
2971   return string;
2972 }
2973 
2974 static gboolean
2975 gst_value_deserialize_buffer (GValue * dest, const gchar * s)
2976 {
2977   GstBuffer *buffer;
2978   gint len;
2979   gchar ts[3];
2980   GstMapInfo info;
2981   guint8 *data;
2982   gint i;
2983 
2984   len = strlen (s);
2985   if (len &amp; 1)
2986     goto wrong_length;
2987 
2988   buffer = gst_buffer_new_allocate (NULL, len / 2, NULL);
2989   if (!gst_buffer_map (buffer, &amp;info, GST_MAP_WRITE))
2990     goto map_failed;
2991   data = info.data;
2992 
2993   for (i = 0; i &lt; len / 2; i++) {
2994     if (!isxdigit ((int) s[i * 2]) || !isxdigit ((int) s[i * 2 + 1]))
2995       goto wrong_char;
2996 
2997     ts[0] = s[i * 2 + 0];
2998     ts[1] = s[i * 2 + 1];
2999     ts[2] = 0;
3000 
3001     data[i] = (guint8) strtoul (ts, NULL, 16);
3002   }
3003   gst_buffer_unmap (buffer, &amp;info);
3004 
3005   gst_value_take_buffer (dest, buffer);
3006 
3007   return TRUE;
3008 
3009   /* ERRORS */
3010 wrong_length:
3011   {
3012     return FALSE;
3013   }
3014 map_failed:
3015   {
3016     return FALSE;
3017   }
3018 wrong_char:
3019   {
3020     gst_buffer_unref (buffer);
3021     gst_buffer_unmap (buffer, &amp;info);
3022     return FALSE;
3023   }
3024 }
3025 
3026 /*************
3027  * GstSample *
3028  *************/
3029 
3030 /* This function is mostly used for comparing image/buffer tags in taglists */
3031 static gint
3032 gst_value_compare_sample (const GValue * value1, const GValue * value2)
3033 {
3034   GstBuffer *buf1 = gst_sample_get_buffer (gst_value_get_sample (value1));
3035   GstBuffer *buf2 = gst_sample_get_buffer (gst_value_get_sample (value2));
3036 
3037   /* FIXME: should we take into account anything else such as caps? */
3038   return compare_buffer (buf1, buf2);
3039 }
3040 
3041 static gchar *
3042 gst_value_serialize_sample (const GValue * value)
3043 {
3044   const GstStructure *info_structure;
3045   GstSegment *segment;
3046   GstBuffer *buffer;
3047   GstCaps *caps;
3048   GstSample *sample;
3049   GValue val = { 0, };
3050   gchar *info_str, *caps_str, *tmp;
3051   gchar *buf_str, *seg_str, *s;
3052 
3053   sample = g_value_get_boxed (value);
3054 
3055   buffer = gst_sample_get_buffer (sample);
3056   if (buffer) {
3057     g_value_init (&amp;val, GST_TYPE_BUFFER);
3058     g_value_set_boxed (&amp;val, buffer);
3059     buf_str = gst_value_serialize_buffer (&amp;val);
3060     g_value_unset (&amp;val);
3061   } else {
3062     buf_str = g_strdup (&quot;None&quot;);
3063   }
3064 
3065   caps = gst_sample_get_caps (sample);
3066   if (caps) {
3067     tmp = gst_caps_to_string (caps);
3068     caps_str = g_base64_encode ((guchar *) tmp, strlen (tmp) + 1);
3069     g_strdelimit (caps_str, &quot;=&quot;, &#39;_&#39;);
3070     g_free (tmp);
3071   } else {
3072     caps_str = g_strdup (&quot;None&quot;);
3073   }
3074 
3075   segment = gst_sample_get_segment (sample);
3076   if (segment) {
3077     g_value_init (&amp;val, GST_TYPE_SEGMENT);
3078     g_value_set_boxed (&amp;val, segment);
3079     tmp = gst_value_serialize_segment_internal (&amp;val, FALSE);
3080     seg_str = g_base64_encode ((guchar *) tmp, strlen (tmp) + 1);
3081     g_strdelimit (seg_str, &quot;=&quot;, &#39;_&#39;);
3082     g_free (tmp);
3083     g_value_unset (&amp;val);
3084   } else {
3085     seg_str = g_strdup (&quot;None&quot;);
3086   }
3087 
3088   info_structure = gst_sample_get_info (sample);
3089   if (info_structure) {
3090     tmp = gst_structure_to_string (info_structure);
3091     info_str = g_base64_encode ((guchar *) tmp, strlen (tmp) + 1);
3092     g_strdelimit (info_str, &quot;=&quot;, &#39;_&#39;);
3093     g_free (tmp);
3094   } else {
3095     info_str = g_strdup (&quot;None&quot;);
3096   }
3097 
3098   s = g_strconcat (buf_str, &quot;:&quot;, caps_str, &quot;:&quot;, seg_str, &quot;:&quot;, info_str, NULL);
3099   g_free (buf_str);
3100   g_free (caps_str);
3101   g_free (seg_str);
3102   g_free (info_str);
3103 
3104   return s;
3105 }
3106 
3107 static gboolean
3108 gst_value_deserialize_sample (GValue * dest, const gchar * s)
3109 {
3110   GValue bval = G_VALUE_INIT, sval = G_VALUE_INIT;
3111   GstStructure *info;
3112   GstSample *sample;
3113   GstCaps *caps = NULL;
3114   gboolean ret = FALSE;
3115   gchar **fields;
3116   gsize outlen;
3117   gint len;
3118 
3119   GST_TRACE (&quot;deserialize &#39;%s&#39;&quot;, s);
3120 
3121   fields = g_strsplit (s, &quot;:&quot;, -1);
3122   len = g_strv_length (fields);
3123   if (len != 4)
3124     goto wrong_length;
3125 
3126   g_value_init (&amp;bval, GST_TYPE_BUFFER);
3127   g_value_init (&amp;sval, GST_TYPE_SEGMENT);
3128 
3129   if (!gst_value_deserialize_buffer (&amp;bval, fields[0]))
3130     goto fail;
3131 
3132   if (strcmp (fields[1], &quot;None&quot;) != 0) {
3133     g_strdelimit (fields[1], &quot;_&quot;, &#39;=&#39;);
3134     g_base64_decode_inplace (fields[1], &amp;outlen);
3135     GST_TRACE (&quot;caps    : %s&quot;, fields[1]);
3136     caps = gst_caps_from_string (fields[1]);
3137     if (caps == NULL)
3138       goto fail;
3139   }
3140 
3141   if (strcmp (fields[2], &quot;None&quot;) != 0) {
3142     g_strdelimit (fields[2], &quot;_&quot;, &#39;=&#39;);
3143     g_base64_decode_inplace (fields[2], &amp;outlen);
3144     GST_TRACE (&quot;segment : %s&quot;, fields[2]);
3145     if (!gst_value_deserialize_segment (&amp;sval, fields[2]))
3146       goto fail;
3147   }
3148 
3149   if (strcmp (fields[3], &quot;None&quot;) != 0) {
3150     g_strdelimit (fields[3], &quot;_&quot;, &#39;=&#39;);
3151     g_base64_decode_inplace (fields[3], &amp;outlen);
3152     GST_TRACE (&quot;info    : %s&quot;, fields[3]);
3153     info = gst_structure_from_string (fields[3], NULL);
3154     if (info == NULL)
3155       goto fail;
3156   } else {
3157     info = NULL;
3158   }
3159 
3160   sample = gst_sample_new (gst_value_get_buffer (&amp;bval), caps,
3161       g_value_get_boxed (&amp;sval), info);
3162 
3163   g_value_take_boxed (dest, sample);
3164 
3165   ret = TRUE;
3166 
3167 fail:
3168   if (caps)
3169     gst_caps_unref (caps);
3170   g_value_unset (&amp;bval);
3171   g_value_unset (&amp;sval);
3172 
3173 wrong_length:
3174 
3175   g_strfreev (fields);
3176 
3177   return ret;
3178 }
3179 
3180 /***********
3181  * boolean *
3182  ***********/
3183 
3184 static gint
3185 gst_value_compare_boolean (const GValue * value1, const GValue * value2)
3186 {
3187   if ((value1-&gt;data[0].v_int != 0) == (value2-&gt;data[0].v_int != 0))
3188     return GST_VALUE_EQUAL;
3189   return GST_VALUE_UNORDERED;
3190 }
3191 
3192 static gchar *
3193 gst_value_serialize_boolean (const GValue * value)
3194 {
3195   if (value-&gt;data[0].v_int) {
3196     return g_strdup (&quot;true&quot;);
3197   }
3198   return g_strdup (&quot;false&quot;);
3199 }
3200 
3201 static gboolean
3202 gst_value_deserialize_boolean (GValue * dest, const gchar * s)
3203 {
3204   gboolean ret = FALSE;
3205 
3206   if (g_ascii_strcasecmp (s, &quot;true&quot;) == 0 ||
3207       g_ascii_strcasecmp (s, &quot;yes&quot;) == 0 ||
3208       g_ascii_strcasecmp (s, &quot;t&quot;) == 0 || strcmp (s, &quot;1&quot;) == 0) {
3209     g_value_set_boolean (dest, TRUE);
3210     ret = TRUE;
3211   } else if (g_ascii_strcasecmp (s, &quot;false&quot;) == 0 ||
3212       g_ascii_strcasecmp (s, &quot;no&quot;) == 0 ||
3213       g_ascii_strcasecmp (s, &quot;f&quot;) == 0 || strcmp (s, &quot;0&quot;) == 0) {
3214     g_value_set_boolean (dest, FALSE);
3215     ret = TRUE;
3216   }
3217 
3218   return ret;
3219 }
3220 
3221 #define CREATE_SERIALIZATION_START(_type,_macro)                        \
3222 static gint                                                             \
3223 gst_value_compare_ ## _type                                             \
3224 (const GValue * value1, const GValue * value2)                          \
3225 {                                                                       \
3226   g ## _type val1 = g_value_get_ ## _type (value1);                     \
3227   g ## _type val2 = g_value_get_ ## _type (value2);                     \
3228   if (val1 &gt; val2)                                                      \
3229     return GST_VALUE_GREATER_THAN;                                      \
3230   if (val1 &lt; val2)                                                      \
3231     return GST_VALUE_LESS_THAN;                                         \
3232   return GST_VALUE_EQUAL;                                               \
3233 }                                                                       \
3234                                                                         \
3235 static gchar *                                                          \
3236 gst_value_serialize_ ## _type (const GValue * value)                    \
3237 {                                                                       \
3238   GValue val = { 0, };                                                  \
3239   g_value_init (&amp;val, G_TYPE_STRING);                                   \
3240   if (!g_value_transform (value, &amp;val))                                 \
3241     g_assert_not_reached ();                                            \
3242   /* NO_COPY_MADNESS!!! */                                              \
3243   return (char *) g_value_get_string (&amp;val);                            \
3244 }
3245 
3246 /* deserialize the given s into to as a gint64.
3247  * check if the result is actually storeable in the given size number of
3248  * bytes.
3249  */
3250 static gboolean
3251 gst_value_deserialize_int_helper (gint64 * to, const gchar * s,
3252     gint64 min, gint64 max, gint size)
3253 {
3254   gboolean ret = FALSE;
3255   gchar *end;
3256   guint64 mask = ~0;
3257 
3258   errno = 0;
3259   *to = g_ascii_strtoull (s, &amp;end, 0);
3260   /* a range error is a definitive no-no */
3261   if (errno == ERANGE) {
3262     return FALSE;
3263   }
3264 
3265   if (*end == 0) {
3266     ret = TRUE;
3267   } else {
3268     if (g_ascii_strcasecmp (s, &quot;little_endian&quot;) == 0) {
3269       *to = G_LITTLE_ENDIAN;
3270       ret = TRUE;
3271     } else if (g_ascii_strcasecmp (s, &quot;big_endian&quot;) == 0) {
3272       *to = G_BIG_ENDIAN;
3273       ret = TRUE;
3274     } else if (g_ascii_strcasecmp (s, &quot;byte_order&quot;) == 0) {
3275       *to = G_BYTE_ORDER;
3276       ret = TRUE;
3277     } else if (g_ascii_strcasecmp (s, &quot;min&quot;) == 0) {
3278       *to = min;
3279       ret = TRUE;
3280     } else if (g_ascii_strcasecmp (s, &quot;max&quot;) == 0) {
3281       *to = max;
3282       ret = TRUE;
3283     }
3284   }
3285   if (ret) {
3286     /* by definition, a gint64 fits into a gint64; so ignore those */
3287     if (size != sizeof (mask)) {
3288       if (*to &gt;= 0) {
3289         /* for positive numbers, we create a mask of 1&#39;s outside of the range
3290          * and 0&#39;s inside the range.  An and will thus keep only 1 bits
3291          * outside of the range */
3292         mask &lt;&lt;= (size * 8);
3293         if ((mask &amp; *to) != 0) {
3294           ret = FALSE;
3295         }
3296       } else {
3297         /* for negative numbers, we do a 2&#39;s complement version */
3298         mask &lt;&lt;= ((size * 8) - 1);
3299         if ((mask &amp; *to) != mask) {
3300           ret = FALSE;
3301         }
3302       }
3303     }
3304   }
3305   return ret;
3306 }
3307 
3308 #define CREATE_SERIALIZATION(_type,_macro)                              \
3309 CREATE_SERIALIZATION_START(_type,_macro)                                \
3310                                                                         \
3311 static gboolean                                                         \
3312 gst_value_deserialize_ ## _type (GValue * dest, const gchar *s)         \
3313 {                                                                       \
3314   gint64 x;                                                             \
3315                                                                         \
3316   if (gst_value_deserialize_int_helper (&amp;x, s, G_MIN ## _macro,         \
3317       G_MAX ## _macro, sizeof (g ## _type))) {                          \
3318     g_value_set_ ## _type (dest, /*(g ## _type)*/ x);                   \
3319     return TRUE;                                                        \
3320   } else {                                                              \
3321     return FALSE;                                                       \
3322   }                                                                     \
3323 }
3324 
3325 #define CREATE_USERIALIZATION(_type,_macro)                             \
3326 CREATE_SERIALIZATION_START(_type,_macro)                                \
3327                                                                         \
3328 static gboolean                                                         \
3329 gst_value_deserialize_ ## _type (GValue * dest, const gchar *s)         \
3330 {                                                                       \
3331   gint64 x;                                                             \
3332   gchar *end;                                                           \
3333   gboolean ret = FALSE;                                                 \
3334                                                                         \
3335   errno = 0;                                                            \
3336   x = g_ascii_strtoull (s, &amp;end, 0);                                    \
3337   /* a range error is a definitive no-no */                             \
3338   if (errno == ERANGE) {                                                \
3339     return FALSE;                                                       \
3340   }                                                                     \
3341   /* the cast ensures the range check later on makes sense */           \
3342   x = (g ## _type) x;                                                   \
3343   if (*end == 0) {                                                      \
3344     ret = TRUE;                                                         \
3345   } else {                                                              \
3346     if (g_ascii_strcasecmp (s, &quot;little_endian&quot;) == 0) {                 \
3347       x = G_LITTLE_ENDIAN;                                              \
3348       ret = TRUE;                                                       \
3349     } else if (g_ascii_strcasecmp (s, &quot;big_endian&quot;) == 0) {             \
3350       x = G_BIG_ENDIAN;                                                 \
3351       ret = TRUE;                                                       \
3352     } else if (g_ascii_strcasecmp (s, &quot;byte_order&quot;) == 0) {             \
3353       x = G_BYTE_ORDER;                                                 \
3354       ret = TRUE;                                                       \
3355     } else if (g_ascii_strcasecmp (s, &quot;min&quot;) == 0) {                    \
3356       x = 0;                                                            \
3357       ret = TRUE;                                                       \
3358     } else if (g_ascii_strcasecmp (s, &quot;max&quot;) == 0) {                    \
3359       x = G_MAX ## _macro;                                              \
3360       ret = TRUE;                                                       \
3361     }                                                                   \
3362   }                                                                     \
3363   if (ret) {                                                            \
3364     if (x &gt; G_MAX ## _macro) {                                          \
3365       ret = FALSE;                                                      \
3366     } else {                                                            \
3367       g_value_set_ ## _type (dest, x);                                  \
3368     }                                                                   \
3369   }                                                                     \
3370   return ret;                                                           \
3371 }
3372 
3373 CREATE_SERIALIZATION (int, INT);
3374 CREATE_SERIALIZATION (int64, INT64);
3375 CREATE_SERIALIZATION (long, LONG);
3376 
3377 CREATE_USERIALIZATION (uint, UINT);
3378 CREATE_USERIALIZATION (uint64, UINT64);
3379 CREATE_USERIALIZATION (ulong, ULONG);
3380 
3381 /* FIXME 2.0: remove this again, plugins shouldn&#39;t have uchar properties */
3382 #ifndef G_MAXUCHAR
3383 #define G_MAXUCHAR 255
3384 #endif
3385 CREATE_USERIALIZATION (uchar, UCHAR);
3386 
3387 /**********
3388  * double *
3389  **********/
3390 static gint
3391 gst_value_compare_double (const GValue * value1, const GValue * value2)
3392 {
3393   if (value1-&gt;data[0].v_double &gt; value2-&gt;data[0].v_double)
3394     return GST_VALUE_GREATER_THAN;
3395   if (value1-&gt;data[0].v_double &lt; value2-&gt;data[0].v_double)
3396     return GST_VALUE_LESS_THAN;
3397   if (value1-&gt;data[0].v_double == value2-&gt;data[0].v_double)
3398     return GST_VALUE_EQUAL;
3399   return GST_VALUE_UNORDERED;
3400 }
3401 
3402 static gchar *
3403 gst_value_serialize_double (const GValue * value)
3404 {
3405   gchar d[G_ASCII_DTOSTR_BUF_SIZE];
3406 
3407   g_ascii_dtostr (d, G_ASCII_DTOSTR_BUF_SIZE, value-&gt;data[0].v_double);
3408   return g_strdup (d);
3409 }
3410 
3411 static gboolean
3412 gst_value_deserialize_double (GValue * dest, const gchar * s)
3413 {
3414   gdouble x;
3415   gboolean ret = FALSE;
3416   gchar *end;
3417 
3418   x = g_ascii_strtod (s, &amp;end);
3419   if (*end == 0) {
3420     ret = TRUE;
3421   } else {
3422     if (g_ascii_strcasecmp (s, &quot;min&quot;) == 0) {
3423       x = -G_MAXDOUBLE;
3424       ret = TRUE;
3425     } else if (g_ascii_strcasecmp (s, &quot;max&quot;) == 0) {
3426       x = G_MAXDOUBLE;
3427       ret = TRUE;
3428     }
3429   }
3430   if (ret) {
3431     g_value_set_double (dest, x);
3432   }
3433   return ret;
3434 }
3435 
3436 /*********
3437  * float *
3438  *********/
3439 
3440 static gint
3441 gst_value_compare_float (const GValue * value1, const GValue * value2)
3442 {
3443   if (value1-&gt;data[0].v_float &gt; value2-&gt;data[0].v_float)
3444     return GST_VALUE_GREATER_THAN;
3445   if (value1-&gt;data[0].v_float &lt; value2-&gt;data[0].v_float)
3446     return GST_VALUE_LESS_THAN;
3447   if (value1-&gt;data[0].v_float == value2-&gt;data[0].v_float)
3448     return GST_VALUE_EQUAL;
3449   return GST_VALUE_UNORDERED;
3450 }
3451 
3452 static gchar *
3453 gst_value_serialize_float (const GValue * value)
3454 {
3455   gchar d[G_ASCII_DTOSTR_BUF_SIZE];
3456 
3457   g_ascii_dtostr (d, G_ASCII_DTOSTR_BUF_SIZE, value-&gt;data[0].v_float);
3458   return g_strdup (d);
3459 }
3460 
3461 static gboolean
3462 gst_value_deserialize_float (GValue * dest, const gchar * s)
3463 {
3464   gdouble x;
3465   gboolean ret = FALSE;
3466   gchar *end;
3467 
3468   x = g_ascii_strtod (s, &amp;end);
3469   if (*end == 0) {
3470     ret = TRUE;
3471   } else {
3472     if (g_ascii_strcasecmp (s, &quot;min&quot;) == 0) {
3473       x = -G_MAXFLOAT;
3474       ret = TRUE;
3475     } else if (g_ascii_strcasecmp (s, &quot;max&quot;) == 0) {
3476       x = G_MAXFLOAT;
3477       ret = TRUE;
3478     }
3479   }
3480   if (x &gt; G_MAXFLOAT || x &lt; -G_MAXFLOAT)
3481     ret = FALSE;
3482   if (ret) {
3483     g_value_set_float (dest, (float) x);
3484   }
3485   return ret;
3486 }
3487 
3488 /**********
3489  * string *
3490  **********/
3491 
3492 static gint
3493 gst_value_compare_string (const GValue * value1, const GValue * value2)
3494 {
3495   if (G_UNLIKELY (!value1-&gt;data[0].v_pointer || !value2-&gt;data[0].v_pointer)) {
3496     /* if only one is NULL, no match - otherwise both NULL == EQUAL */
3497     if (value1-&gt;data[0].v_pointer != value2-&gt;data[0].v_pointer)
3498       return GST_VALUE_UNORDERED;
3499   } else {
3500     gint x = strcmp (value1-&gt;data[0].v_pointer, value2-&gt;data[0].v_pointer);
3501 
3502     if (x &lt; 0)
3503       return GST_VALUE_LESS_THAN;
3504     if (x &gt; 0)
3505       return GST_VALUE_GREATER_THAN;
3506   }
3507 
3508   return GST_VALUE_EQUAL;
3509 }
3510 
3511 static gint
3512 gst_string_measure_wrapping (const gchar * s)
3513 {
3514   gint len;
3515   gboolean wrap = FALSE;
3516 
3517   if (G_UNLIKELY (s == NULL))
3518     return -1;
3519 
3520   /* Special case: the actual string NULL needs wrapping */
3521   if (G_UNLIKELY (strcmp (s, &quot;NULL&quot;) == 0))
3522     return 4;
3523 
3524   len = 0;
3525   while (*s) {
3526     if (GST_ASCII_IS_STRING (*s)) {
3527       len++;
3528     } else if (*s &lt; 0x20 || *s &gt;= 0x7f) {
3529       wrap = TRUE;
3530       len += 4;
3531     } else {
3532       wrap = TRUE;
3533       len += 2;
3534     }
3535     s++;
3536   }
3537 
3538   /* Wrap the string if we found something that needs
3539    * wrapping, or the empty string (len == 0) */
3540   return (wrap || len == 0) ? len : -1;
3541 }
3542 
3543 static gchar *
3544 gst_string_wrap_inner (const gchar * s, gint len)
3545 {
3546   gchar *d, *e;
3547 
3548   e = d = g_malloc (len + 3);
3549 
3550   *e++ = &#39;\&quot;&#39;;
3551   while (*s) {
3552     if (GST_ASCII_IS_STRING (*s)) {
3553       *e++ = *s++;
3554     } else if (*s &lt; 0x20 || *s &gt;= 0x7f) {
3555       *e++ = &#39;\\&#39;;
3556       *e++ = &#39;0&#39; + ((*(guchar *) s) &gt;&gt; 6);
3557       *e++ = &#39;0&#39; + (((*s) &gt;&gt; 3) &amp; 0x7);
3558       *e++ = &#39;0&#39; + ((*s++) &amp; 0x7);
3559     } else {
3560       *e++ = &#39;\\&#39;;
3561       *e++ = *s++;
3562     }
3563   }
3564   *e++ = &#39;\&quot;&#39;;
3565   *e = 0;
3566 
3567   g_assert (e - d &lt;= len + 3);
3568   return d;
3569 }
3570 
3571 /* Do string wrapping/escaping */
3572 static gchar *
3573 gst_string_wrap (const gchar * s)
3574 {
3575   gint len = gst_string_measure_wrapping (s);
3576 
3577   if (G_LIKELY (len &lt; 0))
3578     return g_strdup (s);
3579 
3580   return gst_string_wrap_inner (s, len);
3581 }
3582 
3583 /* Same as above, but take ownership of the string */
3584 gchar *
3585 priv_gst_string_take_and_wrap (gchar * s)
3586 {
3587   gchar *out;
3588   gint len = gst_string_measure_wrapping (s);
3589 
3590   if (G_LIKELY (len &lt; 0))
3591     return s;
3592 
3593   out = gst_string_wrap_inner (s, len);
3594   g_free (s);
3595 
3596   return out;
3597 }
3598 
3599 /*
3600  * This function takes a string delimited with double quotes (&quot;)
3601  * and unescapes any \xxx octal numbers.
3602  *
3603  * If sequences of \y are found where y is not in the range of
3604  * 0-&gt;3, y is copied unescaped.
3605  *
3606  * If \xyy is found where x is an octal number but y is not, an
3607  * error is encountered and %NULL is returned.
3608  *
3609  * the input string must be \0 terminated.
3610  */
3611 static gchar *
3612 gst_string_unwrap (const gchar * s)
3613 {
3614   gchar *ret;
3615   gchar *read, *write;
3616 
3617   /* NULL string returns NULL */
3618   if (s == NULL)
3619     return NULL;
3620 
3621   /* strings not starting with &quot; are invalid */
3622   if (*s != &#39;&quot;&#39;)
3623     return NULL;
3624 
3625   /* make copy of original string to hold the result. This
3626    * string will always be smaller than the original */
3627   ret = g_strdup (s);
3628   read = ret;
3629   write = ret;
3630 
3631   /* need to move to the next position as we parsed the &quot; */
3632   read++;
3633 
3634   while (*read) {
3635     if (GST_ASCII_IS_STRING (*read)) {
3636       /* normal chars are just copied */
3637       *write++ = *read++;
3638     } else if (*read == &#39;&quot;&#39;) {
3639       /* quote marks end of string */
3640       break;
3641     } else if (*read == &#39;\\&#39;) {
3642       /* got an escape char, move to next position to read a tripplet
3643        * of octal numbers */
3644       read++;
3645       /* is the next char a possible first octal number? */
3646       if (*read &gt;= &#39;0&#39; &amp;&amp; *read &lt;= &#39;3&#39;) {
3647         /* parse other 2 numbers, if one of them is not in the range of
3648          * an octal number, we error. We also catch the case where a zero
3649          * byte is found here. */
3650         if (read[1] &lt; &#39;0&#39; || read[1] &gt; &#39;7&#39; || read[2] &lt; &#39;0&#39; || read[2] &gt; &#39;7&#39;)
3651           goto beach;
3652 
3653         /* now convert the octal number to a byte again. */
3654         *write++ = ((read[0] - &#39;0&#39;) &lt;&lt; 6) +
3655             ((read[1] - &#39;0&#39;) &lt;&lt; 3) + (read[2] - &#39;0&#39;);
3656 
3657         read += 3;
3658       } else {
3659         /* if we run into a \0 here, we definitely won&#39;t get a quote later */
3660         if (*read == 0)
3661           goto beach;
3662 
3663         /* else copy \X sequence */
3664         *write++ = *read++;
3665       }
3666     } else {
3667       /* weird character, error */
3668       goto beach;
3669     }
3670   }
3671   /* if the string is not ending in &quot; and zero terminated, we error */
3672   if (*read != &#39;&quot;&#39; || read[1] != &#39;\0&#39;)
3673     goto beach;
3674 
3675   /* null terminate result string and return */
3676   *write = &#39;\0&#39;;
3677   return ret;
3678 
3679 beach:
3680   g_free (ret);
3681   return NULL;
3682 }
3683 
3684 static gchar *
3685 gst_value_serialize_string (const GValue * value)
3686 {
3687   return gst_string_wrap (value-&gt;data[0].v_pointer);
3688 }
3689 
3690 static gboolean
3691 gst_value_deserialize_string (GValue * dest, const gchar * s)
3692 {
3693   if (G_UNLIKELY (strcmp (s, &quot;NULL&quot;) == 0)) {
3694     g_value_set_string (dest, NULL);
3695     return TRUE;
3696   } else if (G_LIKELY (*s != &#39;&quot;&#39; || s[strlen (s) - 1] != &#39;&quot;&#39;)) {
3697     if (!g_utf8_validate (s, -1, NULL))
3698       return FALSE;
3699     g_value_set_string (dest, s);
3700     return TRUE;
3701   } else {
3702     /* strings delimited with double quotes should be unwrapped */
3703     gchar *str = gst_string_unwrap (s);
3704     if (G_UNLIKELY (!str))
3705       return FALSE;
3706     g_value_take_string (dest, str);
3707   }
3708 
3709   return TRUE;
3710 }
3711 
3712 /********
3713  * enum *
3714  ********/
3715 
3716 static gint
3717 gst_value_compare_enum (const GValue * value1, const GValue * value2)
3718 {
3719   GEnumValue *en1, *en2;
3720   GEnumClass *klass1 = (GEnumClass *) g_type_class_ref (G_VALUE_TYPE (value1));
3721   GEnumClass *klass2 = (GEnumClass *) g_type_class_ref (G_VALUE_TYPE (value2));
3722 
3723   g_return_val_if_fail (klass1, GST_VALUE_UNORDERED);
3724   g_return_val_if_fail (klass2, GST_VALUE_UNORDERED);
3725   en1 = g_enum_get_value (klass1, g_value_get_enum (value1));
3726   en2 = g_enum_get_value (klass2, g_value_get_enum (value2));
3727   g_type_class_unref (klass1);
3728   g_type_class_unref (klass2);
3729   g_return_val_if_fail (en1, GST_VALUE_UNORDERED);
3730   g_return_val_if_fail (en2, GST_VALUE_UNORDERED);
3731   if (en1-&gt;value &lt; en2-&gt;value)
3732     return GST_VALUE_LESS_THAN;
3733   if (en1-&gt;value &gt; en2-&gt;value)
3734     return GST_VALUE_GREATER_THAN;
3735 
3736   return GST_VALUE_EQUAL;
3737 }
3738 
3739 static gchar *
3740 gst_value_serialize_enum (const GValue * value)
3741 {
3742   GEnumValue *en;
3743   GEnumClass *klass = (GEnumClass *) g_type_class_ref (G_VALUE_TYPE (value));
3744 
3745   g_return_val_if_fail (klass, NULL);
3746   en = g_enum_get_value (klass, g_value_get_enum (value));
3747   g_type_class_unref (klass);
3748 
3749   /* might be one of the custom formats registered later */
3750   if (G_UNLIKELY (en == NULL &amp;&amp; G_VALUE_TYPE (value) == GST_TYPE_FORMAT)) {
3751     const GstFormatDefinition *format_def;
3752 
3753     format_def = gst_format_get_details ((GstFormat) g_value_get_enum (value));
3754     g_return_val_if_fail (format_def != NULL, NULL);
3755     return g_strdup (format_def-&gt;description);
3756   }
3757 
3758   g_return_val_if_fail (en, NULL);
3759   return g_strdup (en-&gt;value_name);
3760 }
3761 
3762 static gint
3763 gst_value_deserialize_enum_iter_cmp (const GValue * format_def_value,
3764     const gchar * s)
3765 {
3766   const GstFormatDefinition *format_def =
3767       g_value_get_pointer (format_def_value);
3768 
3769   if (g_ascii_strcasecmp (s, format_def-&gt;nick) == 0)
3770     return 0;
3771 
3772   return g_ascii_strcasecmp (s, format_def-&gt;description);
3773 }
3774 
3775 static gboolean
3776 gst_value_deserialize_enum (GValue * dest, const gchar * s)
3777 {
3778   GEnumValue *en;
3779   gchar *endptr = NULL;
3780   GEnumClass *klass = (GEnumClass *) g_type_class_ref (G_VALUE_TYPE (dest));
3781 
3782   g_return_val_if_fail (klass, FALSE);
3783   if (!(en = g_enum_get_value_by_name (klass, s))) {
3784     if (!(en = g_enum_get_value_by_nick (klass, s))) {
3785       gint i = strtol (s, &amp;endptr, 0);
3786 
3787       if (endptr &amp;&amp; *endptr == &#39;\0&#39;) {
3788         en = g_enum_get_value (klass, i);
3789       }
3790     }
3791   }
3792   g_type_class_unref (klass);
3793 
3794   /* might be one of the custom formats registered later */
3795   if (G_UNLIKELY (en == NULL &amp;&amp; G_VALUE_TYPE (dest) == GST_TYPE_FORMAT)) {
3796     GValue res = { 0, };
3797     const GstFormatDefinition *format_def;
3798     GstIterator *iter;
3799     gboolean found;
3800 
3801     iter = gst_format_iterate_definitions ();
3802 
3803     found = gst_iterator_find_custom (iter,
3804         (GCompareFunc) gst_value_deserialize_enum_iter_cmp, &amp;res, (gpointer) s);
3805 
3806     if (found) {
3807       format_def = g_value_get_pointer (&amp;res);
3808       g_return_val_if_fail (format_def != NULL, FALSE);
3809       g_value_set_enum (dest, (gint) format_def-&gt;value);
3810       g_value_unset (&amp;res);
3811     }
3812     gst_iterator_free (iter);
3813     return found;
3814   }
3815 
3816   /* enum name/nick not found */
3817   if (en == NULL)
3818     return FALSE;
3819 
3820   g_value_set_enum (dest, en-&gt;value);
3821   return TRUE;
3822 }
3823 
3824 /********
3825  * flags *
3826  ********/
3827 
3828 /* we just compare the value here */
3829 static gint
3830 gst_value_compare_gflags (const GValue * value1, const GValue * value2)
3831 {
3832   guint fl1, fl2;
3833   GFlagsClass *klass1 =
3834       (GFlagsClass *) g_type_class_ref (G_VALUE_TYPE (value1));
3835   GFlagsClass *klass2 =
3836       (GFlagsClass *) g_type_class_ref (G_VALUE_TYPE (value2));
3837 
3838   g_return_val_if_fail (klass1, GST_VALUE_UNORDERED);
3839   g_return_val_if_fail (klass2, GST_VALUE_UNORDERED);
3840   fl1 = g_value_get_flags (value1);
3841   fl2 = g_value_get_flags (value2);
3842   g_type_class_unref (klass1);
3843   g_type_class_unref (klass2);
3844   if (fl1 &lt; fl2)
3845     return GST_VALUE_LESS_THAN;
3846   if (fl1 &gt; fl2)
3847     return GST_VALUE_GREATER_THAN;
3848 
3849   return GST_VALUE_EQUAL;
3850 }
3851 
3852 /* the different flags are serialized separated with a + */
3853 static gchar *
3854 gst_value_serialize_gflags (const GValue * value)
3855 {
3856   guint flags;
3857   GFlagsValue *fl;
3858   GFlagsClass *klass = (GFlagsClass *) g_type_class_ref (G_VALUE_TYPE (value));
3859   gchar *result, *tmp;
3860   gboolean first = TRUE;
3861 
3862   g_return_val_if_fail (klass, NULL);
3863 
3864   flags = g_value_get_flags (value);
3865 
3866   /* if no flags are set, try to serialize to the _NONE string */
3867   if (!flags) {
3868     fl = g_flags_get_first_value (klass, flags);
3869     if (fl)
3870       return g_strdup (fl-&gt;value_name);
3871     else
3872       return g_strdup (&quot;0&quot;);
3873   }
3874 
3875   /* some flags are set, so serialize one by one */
3876   result = g_strdup (&quot;&quot;);
3877   while (flags) {
3878     fl = g_flags_get_first_value (klass, flags);
3879     if (fl != NULL) {
3880       tmp = g_strconcat (result, (first ? &quot;&quot; : &quot;+&quot;), fl-&gt;value_name, NULL);
3881       g_free (result);
3882       result = tmp;
3883       first = FALSE;
3884 
3885       /* clear flag */
3886       flags &amp;= ~fl-&gt;value;
3887     }
3888   }
3889   g_type_class_unref (klass);
3890 
3891   return result;
3892 }
3893 
3894 static gboolean
3895 gst_value_gflags_str_to_flags (GFlagsClass * klass, const gchar * s,
3896     guint * out_flags, guint * out_mask)
3897 {
3898   GFlagsValue *fl;
3899   gchar delimiter;
3900   const gchar *pos = NULL;
3901   const gchar *next;
3902   gchar *cur_str, *endptr;
3903   guint flags = 0;
3904   guint mask = 0;
3905   guint val;
3906 
3907   g_return_val_if_fail (klass, FALSE);
3908 
3909   /* split into parts delimited with + or / and
3910    * compose the set of flags and mask. */
3911   pos = s;
3912 
3913   if (*pos == &#39;\0&#39;)
3914     goto done;                  /* Empty string, nothing to do */
3915 
3916   /* As a special case if the first char isn&#39;t a delimiter, assume
3917    * it&#39;s a &#39;+&#39; - for GFlags strings, which don&#39;t start with a
3918    * delimiter, while GFlagSet always will */
3919   if (*pos == &#39;/&#39; || *pos == &#39;+&#39;) {
3920     delimiter = *pos;
3921     pos++;
3922   } else {
3923     delimiter = &#39;+&#39;;
3924   }
3925 
3926   do {
3927     /* Find the next delimiter */
3928     next = pos;
3929     while (*next != &#39;\0&#39; &amp;&amp; *next != &#39;+&#39; &amp;&amp; *next != &#39;/&#39;)
3930       next++;
3931     cur_str = g_strndup (pos, next - pos);
3932 
3933     if ((fl = g_flags_get_value_by_name (klass, cur_str)))
3934       val = fl-&gt;value;
3935     else if ((fl = g_flags_get_value_by_nick (klass, cur_str)))
3936       val = fl-&gt;value;
3937     else {
3938       val = strtoul (cur_str, &amp;endptr, 0);
3939       /* direct numeric value */
3940       if (endptr == NULL || *endptr != &#39;\0&#39;) {
3941         g_free (cur_str);
3942         return FALSE;           /* Invalid numeric or string we can&#39;t convert */
3943       }
3944     }
3945     g_free (cur_str);
3946 
3947     if (val) {
3948       mask |= val;
3949       if (delimiter == &#39;+&#39;)
3950         flags |= val;
3951     }
3952 
3953     /* Advance to the next delimiter */
3954     pos = next;
3955     delimiter = *pos;
3956     pos++;
3957   } while (delimiter != &#39;\0&#39;);
3958 
3959 done:
3960   if (out_flags)
3961     *out_flags = flags;
3962   if (out_mask)
3963     *out_mask = mask;
3964 
3965   return TRUE;
3966 }
3967 
3968 
3969 static gboolean
3970 gst_value_deserialize_gflags (GValue * dest, const gchar * s)
3971 {
3972   GFlagsClass *klass = (GFlagsClass *) g_type_class_ref (G_VALUE_TYPE (dest));
3973   gboolean res = FALSE;
3974   guint flags = 0;
3975 
3976   if (gst_value_gflags_str_to_flags (klass, s, &amp;flags, NULL)) {
3977     g_value_set_flags (dest, flags);
3978     res = TRUE;
3979   }
3980 
3981   g_type_class_unref (klass);
3982 
3983   return res;
3984 }
3985 
3986 /*********
3987  * gtype *
3988  *********/
3989 
3990 static gint
3991 gst_value_compare_gtype (const GValue * value1, const GValue * value2)
3992 {
3993   if (value1-&gt;data[0].v_pointer == value2-&gt;data[0].v_pointer)
3994     return GST_VALUE_EQUAL;
3995   return GST_VALUE_UNORDERED;
3996 }
3997 
3998 static gchar *
3999 gst_value_serialize_gtype (const GValue * value)
4000 {
4001   return g_strdup (g_type_name (g_value_get_gtype (value)));
4002 }
4003 
4004 static gboolean
4005 gst_value_deserialize_gtype (GValue * dest, const gchar * s)
4006 {
4007   GType t = g_type_from_name (s);
4008   gboolean ret = TRUE;
4009 
4010   if (t == G_TYPE_INVALID)
4011     ret = FALSE;
4012   if (ret) {
4013     g_value_set_gtype (dest, t);
4014   }
4015   return ret;
4016 }
4017 
4018 /****************
4019  * subset *
4020  ****************/
4021 
4022 static gboolean
4023 gst_value_is_subset_int_range_int_range (const GValue * value1,
4024     const GValue * value2)
4025 {
4026   gint gcd;
4027 
4028   g_return_val_if_fail (GST_VALUE_HOLDS_INT_RANGE (value1), FALSE);
4029   g_return_val_if_fail (GST_VALUE_HOLDS_INT_RANGE (value2), FALSE);
4030 
4031   if (INT_RANGE_MIN (value1) * INT_RANGE_STEP (value1) &lt;
4032       INT_RANGE_MIN (value2) * INT_RANGE_STEP (value2))
4033     return FALSE;
4034   if (INT_RANGE_MAX (value1) * INT_RANGE_STEP (value1) &gt;
4035       INT_RANGE_MAX (value2) * INT_RANGE_STEP (value2))
4036     return FALSE;
4037 
4038   if (INT_RANGE_MIN (value2) == INT_RANGE_MAX (value2)) {
4039     if ((INT_RANGE_MIN (value2) * INT_RANGE_STEP (value2)) %
4040         INT_RANGE_STEP (value1))
4041       return FALSE;
4042     return TRUE;
4043   }
4044 
4045   gcd =
4046       gst_util_greatest_common_divisor (INT_RANGE_STEP (value1),
4047       INT_RANGE_STEP (value2));
4048   if (gcd != MIN (INT_RANGE_STEP (value1), INT_RANGE_STEP (value2)))
4049     return FALSE;
4050 
4051   return TRUE;
4052 }
4053 
4054 static gboolean
4055 gst_value_is_subset_int64_range_int64_range (const GValue * value1,
4056     const GValue * value2)
4057 {
4058   gint64 gcd;
4059 
4060   g_return_val_if_fail (GST_VALUE_HOLDS_INT64_RANGE (value1), FALSE);
4061   g_return_val_if_fail (GST_VALUE_HOLDS_INT64_RANGE (value2), FALSE);
4062 
4063   if (INT64_RANGE_MIN (value1) &lt; INT64_RANGE_MIN (value2))
4064     return FALSE;
4065   if (INT64_RANGE_MAX (value1) &gt; INT64_RANGE_MAX (value2))
4066     return FALSE;
4067 
4068   if (INT64_RANGE_MIN (value2) == INT64_RANGE_MAX (value2)) {
4069     if ((INT64_RANGE_MIN (value2) * INT64_RANGE_STEP (value2)) %
4070         INT64_RANGE_STEP (value1))
4071       return FALSE;
4072     return TRUE;
4073   }
4074 
4075   gcd =
4076       gst_util_greatest_common_divisor_int64 (INT64_RANGE_STEP (value1),
4077       INT64_RANGE_STEP (value2));
4078   if (gcd != MIN (INT64_RANGE_STEP (value1), INT64_RANGE_STEP (value2)))
4079     return FALSE;
4080 
4081   return TRUE;
4082 }
4083 
4084 /* A flag set is a subset of another if the superset allows the
4085  * flags of the subset */
4086 static gboolean
4087 gst_value_is_subset_flagset_flagset (const GValue * value1,
4088     const GValue * value2)
4089 {
4090   guint f1, f2;
4091   guint m1, m2;
4092 
4093   g_return_val_if_fail (GST_VALUE_HOLDS_FLAG_SET (value1), FALSE);
4094   g_return_val_if_fail (GST_VALUE_HOLDS_FLAG_SET (value2), FALSE);
4095 
4096   f1 = value1-&gt;data[0].v_uint;
4097   f2 = value2-&gt;data[0].v_uint;
4098 
4099   m1 = value1-&gt;data[1].v_uint;
4100   m2 = value2-&gt;data[1].v_uint;
4101 
4102   /* Not a subset if masked bits of superset disagree */
4103   if ((f1 &amp; m1) != (f2 &amp; (m1 &amp; m2)))
4104     return FALSE;
4105 
4106   return TRUE;
4107 }
4108 
4109 static gboolean
4110 gst_value_is_subset_structure_structure (const GValue * value1,
4111     const GValue * value2)
4112 {
4113   const GstStructure *s1, *s2;
4114 
4115   g_return_val_if_fail (GST_VALUE_HOLDS_STRUCTURE (value1), FALSE);
4116   g_return_val_if_fail (GST_VALUE_HOLDS_STRUCTURE (value2), FALSE);
4117 
4118   s1 = gst_value_get_structure (value1);
4119   s2 = gst_value_get_structure (value2);
4120 
4121   return gst_structure_is_subset (s1, s2);
4122 }
4123 
4124 /**
4125  * gst_value_is_subset:
4126  * @value1: a #GValue
4127  * @value2: a #GValue
4128  *
4129  * Check that @value1 is a subset of @value2.
4130  *
4131  * Return: %TRUE is @value1 is a subset of @value2
4132  */
4133 gboolean
4134 gst_value_is_subset (const GValue * value1, const GValue * value2)
4135 {
4136   /* special case for int/int64 ranges, since we cannot compute
4137      the difference for those when they have different steps,
4138      and it&#39;s actually a lot simpler to compute whether a range
4139      is a subset of another. */
4140   if (GST_VALUE_HOLDS_INT_RANGE (value1) &amp;&amp; GST_VALUE_HOLDS_INT_RANGE (value2)) {
4141     return gst_value_is_subset_int_range_int_range (value1, value2);
4142   } else if (GST_VALUE_HOLDS_INT64_RANGE (value1)
4143       &amp;&amp; GST_VALUE_HOLDS_INT64_RANGE (value2)) {
4144     return gst_value_is_subset_int64_range_int64_range (value1, value2);
4145   } else if (GST_VALUE_HOLDS_FLAG_SET (value1) &amp;&amp;
4146       GST_VALUE_HOLDS_FLAG_SET (value2)) {
4147     return gst_value_is_subset_flagset_flagset (value1, value2);
4148   } else if (GST_VALUE_HOLDS_STRUCTURE (value1)
4149       &amp;&amp; GST_VALUE_HOLDS_STRUCTURE (value2)) {
4150     return gst_value_is_subset_structure_structure (value1, value2);
4151   }
4152 
4153   /*
4154    * 1 - [1,2] = empty
4155    * -&gt; !subset
4156    *
4157    * [1,2] - 1 = 2
4158    *  -&gt; 1 - [1,2] = empty
4159    *  -&gt; subset
4160    *
4161    * [1,3] - [1,2] = 3
4162    * -&gt; [1,2] - [1,3] = empty
4163    * -&gt; subset
4164    *
4165    * {1,2} - {1,3} = 2
4166    * -&gt; {1,3} - {1,2} = 3
4167    * -&gt; !subset
4168    *
4169    *  First caps subtraction needs to return a non-empty set, second
4170    *  subtractions needs to give en empty set.
4171    *  Both substractions are switched below, as it&#39;s faster that way.
4172    */
4173   if (!gst_value_subtract (NULL, value1, value2)) {
4174     if (gst_value_subtract (NULL, value2, value1)) {
4175       return TRUE;
4176     }
4177   }
4178   return FALSE;
4179 }
4180 
4181 /*********
4182  * union *
4183  *********/
4184 
4185 static gboolean
4186 gst_value_union_int_int_range (GValue * dest, const GValue * src1,
4187     const GValue * src2)
4188 {
4189   gint v = src1-&gt;data[0].v_int;
4190 
4191   /* check if it&#39;s already in the range */
4192   if (INT_RANGE_MIN (src2) * INT_RANGE_STEP (src2) &lt;= v &amp;&amp;
4193       INT_RANGE_MAX (src2) * INT_RANGE_STEP (src2) &gt;= v &amp;&amp;
4194       v % INT_RANGE_STEP (src2) == 0) {
4195     if (dest)
4196       gst_value_init_and_copy (dest, src2);
4197     return TRUE;
4198   }
4199 
4200   /* check if it extends the range */
4201   if (v == (INT_RANGE_MIN (src2) - 1) * INT_RANGE_STEP (src2)) {
4202     if (dest) {
4203       guint64 new_min = INT_RANGE_MIN (src2) - 1;
4204       guint64 new_max = INT_RANGE_MAX (src2);
4205 
4206       gst_value_init_and_copy (dest, src2);
4207       dest-&gt;data[0].v_uint64 = (new_min &lt;&lt; 32) | (new_max);
4208     }
4209     return TRUE;
4210   }
4211   if (v == (INT_RANGE_MAX (src2) + 1) * INT_RANGE_STEP (src2)) {
4212     if (dest) {
4213       guint64 new_min = INT_RANGE_MIN (src2);
4214       guint64 new_max = INT_RANGE_MAX (src2) + 1;
4215 
4216       gst_value_init_and_copy (dest, src2);
4217       dest-&gt;data[0].v_uint64 = (new_min &lt;&lt; 32) | (new_max);
4218     }
4219     return TRUE;
4220   }
4221 
4222   return FALSE;
4223 }
4224 
4225 static gboolean
4226 gst_value_union_int_range_int_range (GValue * dest, const GValue * src1,
4227     const GValue * src2)
4228 {
4229   /* We can union in several special cases:
4230      1 - one is a subset of another
4231      2 - same step and not disjoint
4232      3 - different step, at least one with one value which matches a &#39;next&#39; or &#39;previous&#39;
4233      - anything else ?
4234    */
4235 
4236   /* 1 - subset */
4237   if (gst_value_is_subset_int_range_int_range (src1, src2)) {
4238     if (dest)
4239       gst_value_init_and_copy (dest, src2);
4240     return TRUE;
4241   }
4242   if (gst_value_is_subset_int_range_int_range (src2, src1)) {
4243     if (dest)
4244       gst_value_init_and_copy (dest, src1);
4245     return TRUE;
4246   }
4247 
4248   /* 2 - same step and not disjoint */
4249   if (INT_RANGE_STEP (src1) == INT_RANGE_STEP (src2)) {
4250     if ((INT_RANGE_MIN (src1) &lt;= INT_RANGE_MAX (src2) + 1 &amp;&amp;
4251             INT_RANGE_MAX (src1) &gt;= INT_RANGE_MIN (src2) - 1) ||
4252         (INT_RANGE_MIN (src2) &lt;= INT_RANGE_MAX (src1) + 1 &amp;&amp;
4253             INT_RANGE_MAX (src2) &gt;= INT_RANGE_MIN (src1) - 1)) {
4254       if (dest) {
4255         gint step = INT_RANGE_STEP (src1);
4256         gint min = step * MIN (INT_RANGE_MIN (src1), INT_RANGE_MIN (src2));
4257         gint max = step * MAX (INT_RANGE_MAX (src1), INT_RANGE_MAX (src2));
4258         g_value_init (dest, GST_TYPE_INT_RANGE);
4259         gst_value_set_int_range_step (dest, min, max, step);
4260       }
4261       return TRUE;
4262     }
4263   }
4264 
4265   /* 3 - single value matches next or previous */
4266   if (INT_RANGE_STEP (src1) != INT_RANGE_STEP (src2)) {
4267     gint n1 = INT_RANGE_MAX (src1) - INT_RANGE_MIN (src1) + 1;
4268     gint n2 = INT_RANGE_MAX (src2) - INT_RANGE_MIN (src2) + 1;
4269     if (n1 == 1 || n2 == 1) {
4270       const GValue *range_value = NULL;
4271       gint scalar = 0;
4272       if (n1 == 1) {
4273         range_value = src2;
4274         scalar = INT_RANGE_MIN (src1) * INT_RANGE_STEP (src1);
4275       } else if (n2 == 1) {
4276         range_value = src1;
4277         scalar = INT_RANGE_MIN (src2) * INT_RANGE_STEP (src2);
4278       }
4279 
4280       if (scalar ==
4281           (INT_RANGE_MIN (range_value) - 1) * INT_RANGE_STEP (range_value)) {
4282         if (dest) {
4283           guint64 new_min = (guint)
4284               ((INT_RANGE_MIN (range_value) -
4285                   1) * INT_RANGE_STEP (range_value));
4286           guint64 new_max = (guint)
4287               (INT_RANGE_MAX (range_value) * INT_RANGE_STEP (range_value));
4288 
4289           gst_value_init_and_copy (dest, range_value);
4290           dest-&gt;data[0].v_uint64 = (new_min &lt;&lt; 32) | (new_max);
4291         }
4292         return TRUE;
4293       } else if (scalar ==
4294           (INT_RANGE_MAX (range_value) + 1) * INT_RANGE_STEP (range_value)) {
4295         if (dest) {
4296           guint64 new_min = (guint)
4297               (INT_RANGE_MIN (range_value) * INT_RANGE_STEP (range_value));
4298           guint64 new_max = (guint)
4299               ((INT_RANGE_MAX (range_value) +
4300                   1) * INT_RANGE_STEP (range_value));
4301           gst_value_init_and_copy (dest, range_value);
4302           dest-&gt;data[0].v_uint64 = (new_min &lt;&lt; 32) | (new_max);
4303         }
4304         return TRUE;
4305       }
4306     }
4307   }
4308 
4309   /* If we get there, we did not find a way to make a union that can be
4310      represented with our simplistic model. */
4311   return FALSE;
4312 }
4313 
4314 static gboolean
4315 gst_value_union_flagset_flagset (GValue * dest, const GValue * src1,
4316     const GValue * src2)
4317 {
4318   /* We can union 2 flag sets where they do not disagree on
4319    * required (masked) flag bits */
4320   guint64 f1, f2;
4321   guint64 m1, m2;
4322 
4323   g_return_val_if_fail (GST_VALUE_HOLDS_FLAG_SET (src1), FALSE);
4324   g_return_val_if_fail (GST_VALUE_HOLDS_FLAG_SET (src2), FALSE);
4325 
4326   f1 = src1-&gt;data[0].v_uint;
4327   f2 = src2-&gt;data[0].v_uint;
4328 
4329   m1 = src1-&gt;data[1].v_uint;
4330   m2 = src2-&gt;data[1].v_uint;
4331 
4332   /* Can&#39;t union if masked bits disagree */
4333   if ((f1 &amp; (m1 &amp; m2)) != (f2 &amp; (m1 &amp; m2)))
4334     return FALSE;
4335 
4336   if (dest) {
4337     g_value_init (dest, GST_TYPE_FLAG_SET);
4338     /* Copy masked bits from src2 to src1 */
4339     f1 &amp;= ~m2;
4340     f1 |= (f2 &amp; m2);
4341     m1 |= m2;
4342     gst_value_set_flagset (dest, f1, m1);
4343   }
4344 
4345   return TRUE;
4346 }
4347 
4348 /* iterating over the result taking the union with the other structure&#39;s value */
4349 static gboolean
4350 structure_field_union_into (GQuark field_id, GValue * val, gpointer user_data)
4351 {
4352   GstStructure *other = user_data;
4353   const GValue *other_value;
4354   GValue res_value = G_VALUE_INIT;
4355 
4356   other_value = gst_structure_id_get_value (other, field_id);
4357   /* no value in the other struct, just keep this value */
4358   if (!other_value)
4359     return TRUE;
4360 
4361   if (!gst_value_union (&amp;res_value, val, other_value))
4362     return FALSE;
4363 
4364   g_value_unset (val);
4365   gst_value_move (val, &amp;res_value);
4366   return TRUE;
4367 }
4368 
4369 /* iterating over the other source structure adding missing values */
4370 static gboolean
4371 structure_field_union_from (GQuark field_id, const GValue * other_val,
4372     gpointer user_data)
4373 {
4374   GstStructure *result = user_data;
4375   const GValue *result_value;
4376 
4377   result_value = gst_structure_id_get_value (result, field_id);
4378   if (!result_value)
4379     gst_structure_id_set_value (result, field_id, other_val);
4380 
4381   return TRUE;
4382 }
4383 
4384 static gboolean
4385 gst_value_union_structure_structure (GValue * dest, const GValue * src1,
4386     const GValue * src2)
4387 {
4388   const GstStructure *s1, *s2;
4389   GstStructure *result;
4390   gboolean ret;
4391 
4392   g_return_val_if_fail (GST_VALUE_HOLDS_STRUCTURE (src1), FALSE);
4393   g_return_val_if_fail (GST_VALUE_HOLDS_STRUCTURE (src2), FALSE);
4394 
4395   s1 = gst_value_get_structure (src1);
4396   s2 = gst_value_get_structure (src2);
4397 
4398   /* Can&#39;t join two structures with different names into a single structure */
4399   if (!gst_structure_has_name (s1, gst_structure_get_name (s2))) {
4400     gst_value_list_concat (dest, src1, src2);
4401     return TRUE;
4402   }
4403 
4404   result = gst_structure_copy (s1);
4405   ret =
4406       gst_structure_map_in_place (result, structure_field_union_into,
4407       (gpointer) s2);
4408   if (!ret)
4409     goto out;
4410   ret =
4411       gst_structure_foreach (s2, structure_field_union_from, (gpointer) result);
4412 
4413   if (ret) {
4414     g_value_init (dest, GST_TYPE_STRUCTURE);
4415     gst_value_set_structure (dest, result);
4416   }
4417 
4418 out:
4419   gst_structure_free (result);
4420   return ret;
4421 }
4422 
4423 /****************
4424  * intersection *
4425  ****************/
4426 
4427 static gboolean
4428 gst_value_intersect_int_int_range (GValue * dest, const GValue * src1,
4429     const GValue * src2)
4430 {
4431   if (INT_RANGE_MIN (src2) * INT_RANGE_STEP (src2) &lt;= src1-&gt;data[0].v_int &amp;&amp;
4432       INT_RANGE_MAX (src2) * INT_RANGE_STEP (src2) &gt;= src1-&gt;data[0].v_int &amp;&amp;
4433       src1-&gt;data[0].v_int % INT_RANGE_STEP (src2) == 0) {
4434     if (dest)
4435       gst_value_init_and_copy (dest, src1);
4436     return TRUE;
4437   }
4438 
4439   return FALSE;
4440 }
4441 
4442 static gboolean
4443 gst_value_intersect_int_range_int_range (GValue * dest, const GValue * src1,
4444     const GValue * src2)
4445 {
4446   gint min;
4447   gint max;
4448   gint step;
4449 
4450   step =
4451       INT_RANGE_STEP (src1) /
4452       gst_util_greatest_common_divisor (INT_RANGE_STEP (src1),
4453       INT_RANGE_STEP (src2));
4454   if (G_MAXINT32 / INT_RANGE_STEP (src2) &lt; step)
4455     return FALSE;
4456   step *= INT_RANGE_STEP (src2);
4457 
4458   min =
4459       MAX (INT_RANGE_MIN (src1) * INT_RANGE_STEP (src1),
4460       INT_RANGE_MIN (src2) * INT_RANGE_STEP (src2));
4461   min = (min + step - 1) / step * step;
4462   max =
4463       MIN (INT_RANGE_MAX (src1) * INT_RANGE_STEP (src1),
4464       INT_RANGE_MAX (src2) * INT_RANGE_STEP (src2));
4465   max = max / step * step;
4466 
4467   if (min &lt; max) {
4468     if (dest) {
4469       g_value_init (dest, GST_TYPE_INT_RANGE);
4470       gst_value_set_int_range_step (dest, min, max, step);
4471     }
4472     return TRUE;
4473   }
4474   if (min == max) {
4475     if (dest) {
4476       g_value_init (dest, G_TYPE_INT);
4477       g_value_set_int (dest, min);
4478     }
4479     return TRUE;
4480   }
4481 
4482   return FALSE;
4483 }
4484 
4485 #define INT64_RANGE_MIN_VAL(v) (INT64_RANGE_MIN (v) * INT64_RANGE_STEP (v))
4486 #define INT64_RANGE_MAX_VAL(v) (INT64_RANGE_MAX (v) * INT64_RANGE_STEP (v))
4487 
4488 static gboolean
4489 gst_value_intersect_int64_int64_range (GValue * dest, const GValue * src1,
4490     const GValue * src2)
4491 {
4492   if (INT64_RANGE_MIN_VAL (src2) &lt;= src1-&gt;data[0].v_int64 &amp;&amp;
4493       INT64_RANGE_MAX_VAL (src2) &gt;= src1-&gt;data[0].v_int64 &amp;&amp;
4494       src1-&gt;data[0].v_int64 % INT64_RANGE_STEP (src2) == 0) {
4495     if (dest)
4496       gst_value_init_and_copy (dest, src1);
4497     return TRUE;
4498   }
4499 
4500   return FALSE;
4501 }
4502 
4503 static gboolean
4504 gst_value_intersect_int64_range_int64_range (GValue * dest, const GValue * src1,
4505     const GValue * src2)
4506 {
4507   gint64 min;
4508   gint64 max;
4509   gint64 step;
4510 
4511   step =
4512       INT64_RANGE_STEP (src1) /
4513       gst_util_greatest_common_divisor_int64 (INT64_RANGE_STEP (src1),
4514       INT64_RANGE_STEP (src2));
4515   if (G_MAXINT64 / INT64_RANGE_STEP (src2) &lt; step)
4516     return FALSE;
4517   step *= INT64_RANGE_STEP (src2);
4518 
4519   min =
4520       MAX (INT64_RANGE_MIN (src1) * INT64_RANGE_STEP (src1),
4521       INT64_RANGE_MIN (src2) * INT64_RANGE_STEP (src2));
4522   min = (min + step - 1) / step * step;
4523   max =
4524       MIN (INT64_RANGE_MAX (src1) * INT64_RANGE_STEP (src1),
4525       INT64_RANGE_MAX (src2) * INT64_RANGE_STEP (src2));
4526   max = max / step * step;
4527 
4528   if (min &lt; max) {
4529     if (dest) {
4530       g_value_init (dest, GST_TYPE_INT64_RANGE);
4531       gst_value_set_int64_range_step (dest, min, max, step);
4532     }
4533     return TRUE;
4534   }
4535   if (min == max) {
4536     if (dest) {
4537       g_value_init (dest, G_TYPE_INT64);
4538       g_value_set_int64 (dest, min);
4539     }
4540     return TRUE;
4541   }
4542 
4543   return FALSE;
4544 }
4545 
4546 static gboolean
4547 gst_value_intersect_double_double_range (GValue * dest, const GValue * src1,
4548     const GValue * src2)
4549 {
4550   if (src2-&gt;data[0].v_double &lt;= src1-&gt;data[0].v_double &amp;&amp;
4551       src2-&gt;data[1].v_double &gt;= src1-&gt;data[0].v_double) {
4552     if (dest)
4553       gst_value_init_and_copy (dest, src1);
4554     return TRUE;
4555   }
4556 
4557   return FALSE;
4558 }
4559 
4560 static gboolean
4561 gst_value_intersect_double_range_double_range (GValue * dest,
4562     const GValue * src1, const GValue * src2)
4563 {
4564   gdouble min;
4565   gdouble max;
4566 
4567   min = MAX (src1-&gt;data[0].v_double, src2-&gt;data[0].v_double);
4568   max = MIN (src1-&gt;data[1].v_double, src2-&gt;data[1].v_double);
4569 
4570   if (min &lt; max) {
4571     if (dest) {
4572       g_value_init (dest, GST_TYPE_DOUBLE_RANGE);
4573       gst_value_set_double_range (dest, min, max);
4574     }
4575     return TRUE;
4576   }
4577   if (min == max) {
4578     if (dest) {
4579       g_value_init (dest, G_TYPE_DOUBLE);
4580       g_value_set_int (dest, (int) min);
4581     }
4582     return TRUE;
4583   }
4584 
4585   return FALSE;
4586 }
4587 
4588 static gboolean
4589 gst_value_intersect_list (GValue * dest, const GValue * value1,
4590     const GValue * value2)
4591 {
4592   guint i, size;
4593   GValue intersection = { 0, };
4594   gboolean ret = FALSE;
4595 
4596   size = VALUE_LIST_SIZE (value1);
4597   for (i = 0; i &lt; size; i++) {
4598     const GValue *cur = VALUE_LIST_GET_VALUE (value1, i);
4599 
4600     /* quicker version when we don&#39;t need the resulting set */
4601     if (!dest) {
4602       if (gst_value_intersect (NULL, cur, value2)) {
4603         ret = TRUE;
4604         break;
4605       }
4606       continue;
4607     }
4608 
4609     if (gst_value_intersect (&amp;intersection, cur, value2)) {
4610       /* append value */
4611       if (!ret) {
4612         gst_value_move (dest, &amp;intersection);
4613         ret = TRUE;
4614       } else if (GST_VALUE_HOLDS_LIST (dest)) {
4615         _gst_value_list_append_and_take_value (dest, &amp;intersection);
4616       } else {
4617         GValue temp;
4618 
4619         gst_value_move (&amp;temp, dest);
4620         gst_value_list_merge (dest, &amp;temp, &amp;intersection);
4621         g_value_unset (&amp;temp);
4622         g_value_unset (&amp;intersection);
4623       }
4624     }
4625   }
4626 
4627   return ret;
4628 }
4629 
4630 static gboolean
4631 gst_value_intersect_array (GValue * dest, const GValue * src1,
4632     const GValue * src2)
4633 {
4634   guint size;
4635   guint n;
4636   GValue val = { 0 };
4637 
4638   /* only works on similar-sized arrays */
4639   size = gst_value_array_get_size (src1);
4640   if (size != gst_value_array_get_size (src2))
4641     return FALSE;
4642 
4643   /* quicker value when we don&#39;t need the resulting set */
4644   if (!dest) {
4645     for (n = 0; n &lt; size; n++) {
4646       if (!gst_value_intersect (NULL, gst_value_array_get_value (src1, n),
4647               gst_value_array_get_value (src2, n))) {
4648         return FALSE;
4649       }
4650     }
4651     return TRUE;
4652   }
4653 
4654   g_value_init (dest, GST_TYPE_ARRAY);
4655 
4656   for (n = 0; n &lt; size; n++) {
4657     if (!gst_value_intersect (&amp;val, gst_value_array_get_value (src1, n),
4658             gst_value_array_get_value (src2, n))) {
4659       g_value_unset (dest);
4660       return FALSE;
4661     }
4662     _gst_value_array_append_and_take_value (dest, &amp;val);
4663   }
4664 
4665   return TRUE;
4666 }
4667 
4668 static gboolean
4669 gst_value_intersect_fraction_fraction_range (GValue * dest, const GValue * src1,
4670     const GValue * src2)
4671 {
4672   gint res1, res2;
4673   GValue *vals;
4674   GstValueCompareFunc compare;
4675 
4676   vals = src2-&gt;data[0].v_pointer;
4677 
4678   if (vals == NULL)
4679     return FALSE;
4680 
4681   if ((compare = gst_value_get_compare_func (src1))) {
4682     res1 = gst_value_compare_with_func (&amp;vals[0], src1, compare);
4683     res2 = gst_value_compare_with_func (&amp;vals[1], src1, compare);
4684 
4685     if ((res1 == GST_VALUE_EQUAL || res1 == GST_VALUE_LESS_THAN) &amp;&amp;
4686         (res2 == GST_VALUE_EQUAL || res2 == GST_VALUE_GREATER_THAN)) {
4687       if (dest)
4688         gst_value_init_and_copy (dest, src1);
4689       return TRUE;
4690     }
4691   }
4692 
4693   return FALSE;
4694 }
4695 
4696 static gboolean
4697 gst_value_intersect_fraction_range_fraction_range (GValue * dest,
4698     const GValue * src1, const GValue * src2)
4699 {
4700   GValue *min;
4701   GValue *max;
4702   gint res;
4703   GValue *vals1, *vals2;
4704   GstValueCompareFunc compare;
4705 
4706   vals1 = src1-&gt;data[0].v_pointer;
4707   vals2 = src2-&gt;data[0].v_pointer;
4708   g_return_val_if_fail (vals1 != NULL &amp;&amp; vals2 != NULL, FALSE);
4709 
4710   if ((compare = gst_value_get_compare_func (&amp;vals1[0]))) {
4711     /* min = MAX (src1.start, src2.start) */
4712     res = gst_value_compare_with_func (&amp;vals1[0], &amp;vals2[0], compare);
4713     g_return_val_if_fail (res != GST_VALUE_UNORDERED, FALSE);
4714     if (res == GST_VALUE_LESS_THAN)
4715       min = &amp;vals2[0];          /* Take the max of the 2 */
4716     else
4717       min = &amp;vals1[0];
4718 
4719     /* max = MIN (src1.end, src2.end) */
4720     res = gst_value_compare_with_func (&amp;vals1[1], &amp;vals2[1], compare);
4721     g_return_val_if_fail (res != GST_VALUE_UNORDERED, FALSE);
4722     if (res == GST_VALUE_GREATER_THAN)
4723       max = &amp;vals2[1];          /* Take the min of the 2 */
4724     else
4725       max = &amp;vals1[1];
4726 
4727     res = gst_value_compare_with_func (min, max, compare);
4728     g_return_val_if_fail (res != GST_VALUE_UNORDERED, FALSE);
4729     if (res == GST_VALUE_LESS_THAN) {
4730       if (dest) {
4731         g_value_init (dest, GST_TYPE_FRACTION_RANGE);
4732         vals1 = dest-&gt;data[0].v_pointer;
4733         g_value_copy (min, &amp;vals1[0]);
4734         g_value_copy (max, &amp;vals1[1]);
4735       }
4736       return TRUE;
4737     }
4738     if (res == GST_VALUE_EQUAL) {
4739       if (dest)
4740         gst_value_init_and_copy (dest, min);
4741       return TRUE;
4742     }
4743   }
4744 
4745   return FALSE;
4746 }
4747 
4748 /* Two flagsets intersect if the masked bits in both
4749  * flagsets are exactly equal */
4750 static gboolean
4751 gst_value_intersect_flagset_flagset (GValue * dest,
4752     const GValue * src1, const GValue * src2)
4753 {
4754   guint f1, f2;
4755   guint m1, m2;
4756   GType type1, type2, flagset_type;
4757 
4758   g_return_val_if_fail (GST_VALUE_HOLDS_FLAG_SET (src1), FALSE);
4759   g_return_val_if_fail (GST_VALUE_HOLDS_FLAG_SET (src2), FALSE);
4760 
4761   f1 = src1-&gt;data[0].v_uint;
4762   f2 = src2-&gt;data[0].v_uint;
4763 
4764   m1 = src1-&gt;data[1].v_uint;
4765   m2 = src2-&gt;data[1].v_uint;
4766 
4767   /* Don&#39;t intersect if masked bits disagree */
4768   if ((f1 &amp; (m1 &amp; m2)) != (f2 &amp; (m1 &amp; m2)))
4769     return FALSE;
4770 
4771   /* Allow intersection with the generic FlagSet type, on one
4772    * side, but not 2 different subtypes - that makes no sense */
4773   type1 = G_VALUE_TYPE (src1);
4774   type2 = G_VALUE_TYPE (src2);
4775   flagset_type = GST_TYPE_FLAG_SET;
4776 
4777   if (type1 != type2 &amp;&amp; type1 != flagset_type &amp;&amp; type2 != flagset_type)
4778     return FALSE;
4779 
4780   if (dest) {
4781     GType dest_type;
4782 
4783     /* Prefer an output type that matches a sub-type,
4784      * rather than the generic type */
4785     if (type1 != flagset_type)
4786       dest_type = type1;
4787     else
4788       dest_type = type2;
4789 
4790     g_value_init (dest, dest_type);
4791 
4792     /* The compatible set is all the bits from src1 that it
4793      * cares about and all the bits from src2 that it cares
4794      * about. */
4795     dest-&gt;data[0].v_uint = (f1 &amp; m1) | (f2 &amp; m2);
4796     dest-&gt;data[1].v_uint = m1 | m2;
4797   }
4798 
4799   return TRUE;
4800 }
4801 
4802 static gboolean
4803 gst_value_intersect_structure_structure (GValue * dest,
4804     const GValue * src1, const GValue * src2)
4805 {
4806   const GstStructure *s1, *s2;
4807   GstStructure *d1;
4808 
4809   s1 = gst_value_get_structure (src1);
4810   s2 = gst_value_get_structure (src2);
4811 
4812   d1 = gst_structure_intersect (s1, s2);
4813   if (!d1)
4814     return FALSE;
4815 
4816   if (dest) {
4817     g_value_init (dest, GST_TYPE_STRUCTURE);
4818     gst_value_set_structure (dest, d1);
4819   }
4820 
4821   gst_structure_free (d1);
4822   return TRUE;
4823 }
4824 
4825 /***************
4826  * subtraction *
4827  ***************/
4828 
4829 static gboolean
4830 gst_value_subtract_int_int_range (GValue * dest, const GValue * minuend,
4831     const GValue * subtrahend)
4832 {
4833   gint min = gst_value_get_int_range_min (subtrahend);
4834   gint max = gst_value_get_int_range_max (subtrahend);
4835   gint step = gst_value_get_int_range_step (subtrahend);
4836   gint val = g_value_get_int (minuend);
4837 
4838   if (step == 0)
4839     return FALSE;
4840 
4841   /* subtracting a range from an int only works if the int is not in the
4842    * range */
4843   if (val &lt; min || val &gt; max || val % step) {
4844     /* and the result is the int */
4845     if (dest)
4846       gst_value_init_and_copy (dest, minuend);
4847     return TRUE;
4848   }
4849   return FALSE;
4850 }
4851 
4852 /* creates a new int range based on input values.
4853  */
4854 static gboolean
4855 gst_value_create_new_range (GValue * dest, gint min1, gint max1, gint min2,
4856     gint max2, gint step)
4857 {
4858   GValue v1 = { 0, };
4859   GValue v2 = { 0, };
4860   GValue *pv1, *pv2;            /* yeah, hungarian! */
4861 
4862   g_return_val_if_fail (step &gt; 0, FALSE);
4863   g_return_val_if_fail (min1 % step == 0, FALSE);
4864   g_return_val_if_fail (max1 % step == 0, FALSE);
4865   g_return_val_if_fail (min2 % step == 0, FALSE);
4866   g_return_val_if_fail (max2 % step == 0, FALSE);
4867 
4868   if (min1 &lt;= max1 &amp;&amp; min2 &lt;= max2) {
4869     pv1 = &amp;v1;
4870     pv2 = &amp;v2;
4871   } else if (min1 &lt;= max1) {
4872     pv1 = dest;
4873     pv2 = NULL;
4874   } else if (min2 &lt;= max2) {
4875     pv1 = NULL;
4876     pv2 = dest;
4877   } else {
4878     return FALSE;
4879   }
4880 
4881   if (!dest)
4882     return TRUE;
4883 
4884   if (min1 &lt; max1) {
4885     g_value_init (pv1, GST_TYPE_INT_RANGE);
4886     gst_value_set_int_range_step (pv1, min1, max1, step);
4887   } else if (min1 == max1) {
4888     g_value_init (pv1, G_TYPE_INT);
4889     g_value_set_int (pv1, min1);
4890   }
4891   if (min2 &lt; max2) {
4892     g_value_init (pv2, GST_TYPE_INT_RANGE);
4893     gst_value_set_int_range_step (pv2, min2, max2, step);
4894   } else if (min2 == max2) {
4895     g_value_init (pv2, G_TYPE_INT);
4896     g_value_set_int (pv2, min2);
4897   }
4898 
4899   if (min1 &lt;= max1 &amp;&amp; min2 &lt;= max2) {
4900     gst_value_list_concat_and_take_values (dest, pv1, pv2);
4901   }
4902   return TRUE;
4903 }
4904 
4905 static gboolean
4906 gst_value_subtract_int_range_int (GValue * dest, const GValue * minuend,
4907     const GValue * subtrahend)
4908 {
4909   gint min = gst_value_get_int_range_min (minuend);
4910   gint max = gst_value_get_int_range_max (minuend);
4911   gint step = gst_value_get_int_range_step (minuend);
4912   gint val = g_value_get_int (subtrahend);
4913 
4914   g_return_val_if_fail (min &lt; max, FALSE);
4915 
4916   if (step == 0)
4917     return FALSE;
4918 
4919   /* value is outside of the range, return range unchanged */
4920   if (val &lt; min || val &gt; max || val % step) {
4921     if (dest)
4922       gst_value_init_and_copy (dest, minuend);
4923     return TRUE;
4924   } else {
4925     /* max must be MAXINT too as val &lt;= max */
4926     if (val &gt;= G_MAXINT - step + 1) {
4927       max -= step;
4928       val -= step;
4929     }
4930     /* min must be MININT too as val &gt;= max */
4931     if (val &lt;= G_MININT + step - 1) {
4932       min += step;
4933       val += step;
4934     }
4935     if (dest)
4936       gst_value_create_new_range (dest, min, val - step, val + step, max, step);
4937   }
4938   return TRUE;
4939 }
4940 
4941 static gboolean
4942 gst_value_subtract_int_range_int_range (GValue * dest, const GValue * minuend,
4943     const GValue * subtrahend)
4944 {
4945   gint min1 = gst_value_get_int_range_min (minuend);
4946   gint max1 = gst_value_get_int_range_max (minuend);
4947   gint step1 = gst_value_get_int_range_step (minuend);
4948   gint min2 = gst_value_get_int_range_min (subtrahend);
4949   gint max2 = gst_value_get_int_range_max (subtrahend);
4950   gint step2 = gst_value_get_int_range_step (subtrahend);
4951   gint step;
4952 
4953   if (step1 != step2) {
4954     /* ENOIMPL */
4955     g_assert (FALSE);
4956     return FALSE;
4957   }
4958   step = step1;
4959 
4960   if (step == 0)
4961     return FALSE;
4962 
4963   if (max2 &gt;= max1 &amp;&amp; min2 &lt;= min1) {
4964     return FALSE;
4965   } else if (max2 &gt;= max1) {
4966     return gst_value_create_new_range (dest, min1, MIN (min2 - step, max1),
4967         step, 0, step);
4968   } else if (min2 &lt;= min1) {
4969     return gst_value_create_new_range (dest, MAX (max2 + step, min1), max1,
4970         step, 0, step);
4971   } else {
4972     return gst_value_create_new_range (dest, min1, MIN (min2 - step, max1),
4973         MAX (max2 + step, min1), max1, step);
4974   }
4975 }
4976 
4977 static gboolean
4978 gst_value_subtract_int64_int64_range (GValue * dest, const GValue * minuend,
4979     const GValue * subtrahend)
4980 {
4981   gint64 min = gst_value_get_int64_range_min (subtrahend);
4982   gint64 max = gst_value_get_int64_range_max (subtrahend);
4983   gint64 step = gst_value_get_int64_range_step (subtrahend);
4984   gint64 val = g_value_get_int64 (minuend);
4985 
4986   if (step == 0)
4987     return FALSE;
4988   /* subtracting a range from an int64 only works if the int64 is not in the
4989    * range */
4990   if (val &lt; min || val &gt; max || val % step) {
4991     /* and the result is the int64 */
4992     if (dest)
4993       gst_value_init_and_copy (dest, minuend);
4994     return TRUE;
4995   }
4996   return FALSE;
4997 }
4998 
4999 /* creates a new int64 range based on input values.
5000  */
5001 static gboolean
5002 gst_value_create_new_int64_range (GValue * dest, gint64 min1, gint64 max1,
5003     gint64 min2, gint64 max2, gint64 step)
5004 {
5005   GValue v1 = { 0, };
5006   GValue v2 = { 0, };
5007   GValue *pv1, *pv2;            /* yeah, hungarian! */
5008 
5009   g_return_val_if_fail (step &gt; 0, FALSE);
5010   g_return_val_if_fail (min1 % step == 0, FALSE);
5011   g_return_val_if_fail (max1 % step == 0, FALSE);
5012   g_return_val_if_fail (min2 % step == 0, FALSE);
5013   g_return_val_if_fail (max2 % step == 0, FALSE);
5014 
5015   if (min1 &lt;= max1 &amp;&amp; min2 &lt;= max2) {
5016     pv1 = &amp;v1;
5017     pv2 = &amp;v2;
5018   } else if (min1 &lt;= max1) {
5019     pv1 = dest;
5020     pv2 = NULL;
5021   } else if (min2 &lt;= max2) {
5022     pv1 = NULL;
5023     pv2 = dest;
5024   } else {
5025     return FALSE;
5026   }
5027 
5028   if (!dest)
5029     return TRUE;
5030 
5031   if (min1 &lt; max1) {
5032     g_value_init (pv1, GST_TYPE_INT64_RANGE);
5033     gst_value_set_int64_range_step (pv1, min1, max1, step);
5034   } else if (min1 == max1) {
5035     g_value_init (pv1, G_TYPE_INT64);
5036     g_value_set_int64 (pv1, min1);
5037   }
5038   if (min2 &lt; max2) {
5039     g_value_init (pv2, GST_TYPE_INT64_RANGE);
5040     gst_value_set_int64_range_step (pv2, min2, max2, step);
5041   } else if (min2 == max2) {
5042     g_value_init (pv2, G_TYPE_INT64);
5043     g_value_set_int64 (pv2, min2);
5044   }
5045 
5046   if (min1 &lt;= max1 &amp;&amp; min2 &lt;= max2) {
5047     gst_value_list_concat_and_take_values (dest, pv1, pv2);
5048   }
5049   return TRUE;
5050 }
5051 
5052 static gboolean
5053 gst_value_subtract_int64_range_int64 (GValue * dest, const GValue * minuend,
5054     const GValue * subtrahend)
5055 {
5056   gint64 min = gst_value_get_int64_range_min (minuend);
5057   gint64 max = gst_value_get_int64_range_max (minuend);
5058   gint64 step = gst_value_get_int64_range_step (minuend);
5059   gint64 val = g_value_get_int64 (subtrahend);
5060 
5061   g_return_val_if_fail (min &lt; max, FALSE);
5062 
5063   if (step == 0)
5064     return FALSE;
5065 
5066   /* value is outside of the range, return range unchanged */
5067   if (val &lt; min || val &gt; max || val % step) {
5068     if (dest)
5069       gst_value_init_and_copy (dest, minuend);
5070     return TRUE;
5071   } else {
5072     /* max must be MAXINT64 too as val &lt;= max */
5073     if (val &gt;= G_MAXINT64 - step + 1) {
5074       max -= step;
5075       val -= step;
5076     }
5077     /* min must be MININT64 too as val &gt;= max */
5078     if (val &lt;= G_MININT64 + step - 1) {
5079       min += step;
5080       val += step;
5081     }
5082     if (dest)
5083       gst_value_create_new_int64_range (dest, min, val - step, val + step, max,
5084           step);
5085   }
5086   return TRUE;
5087 }
5088 
5089 static gboolean
5090 gst_value_subtract_int64_range_int64_range (GValue * dest,
5091     const GValue * minuend, const GValue * subtrahend)
5092 {
5093   gint64 min1 = gst_value_get_int64_range_min (minuend);
5094   gint64 max1 = gst_value_get_int64_range_max (minuend);
5095   gint64 step1 = gst_value_get_int64_range_step (minuend);
5096   gint64 min2 = gst_value_get_int64_range_min (subtrahend);
5097   gint64 max2 = gst_value_get_int64_range_max (subtrahend);
5098   gint64 step2 = gst_value_get_int64_range_step (subtrahend);
5099   gint64 step;
5100 
5101   if (step1 != step2) {
5102     /* ENOIMPL */
5103     g_assert (FALSE);
5104     return FALSE;
5105   }
5106 
5107   if (step1 == 0)
5108     return FALSE;
5109 
5110   step = step1;
5111 
5112   if (max2 &gt;= max1 &amp;&amp; min2 &lt;= min1) {
5113     return FALSE;
5114   } else if (max2 &gt;= max1) {
5115     return gst_value_create_new_int64_range (dest, min1, MIN (min2 - step,
5116             max1), step, 0, step);
5117   } else if (min2 &lt;= min1) {
5118     return gst_value_create_new_int64_range (dest, MAX (max2 + step, min1),
5119         max1, step, 0, step);
5120   } else {
5121     return gst_value_create_new_int64_range (dest, min1, MIN (min2 - step,
5122             max1), MAX (max2 + step, min1), max1, step);
5123   }
5124 }
5125 
5126 static gboolean
5127 gst_value_subtract_double_double_range (GValue * dest, const GValue * minuend,
5128     const GValue * subtrahend)
5129 {
5130   gdouble min = gst_value_get_double_range_min (subtrahend);
5131   gdouble max = gst_value_get_double_range_max (subtrahend);
5132   gdouble val = g_value_get_double (minuend);
5133 
5134   if (val &lt; min || val &gt; max) {
5135     if (dest)
5136       gst_value_init_and_copy (dest, minuend);
5137     return TRUE;
5138   }
5139   return FALSE;
5140 }
5141 
5142 static gboolean
5143 gst_value_subtract_double_range_double (GValue * dest, const GValue * minuend,
5144     const GValue * subtrahend)
5145 {
5146   /* since we don&#39;t have open ranges, we cannot create a hole in
5147    * a double range. We return the original range */
5148   if (dest)
5149     gst_value_init_and_copy (dest, minuend);
5150   return TRUE;
5151 }
5152 
5153 static gboolean
5154 gst_value_subtract_double_range_double_range (GValue * dest,
5155     const GValue * minuend, const GValue * subtrahend)
5156 {
5157   /* since we don&#39;t have open ranges, we have to approximate */
5158   /* done like with ints */
5159   gdouble min1 = gst_value_get_double_range_min (minuend);
5160   gdouble max2 = gst_value_get_double_range_max (minuend);
5161   gdouble max1 = MIN (gst_value_get_double_range_min (subtrahend), max2);
5162   gdouble min2 = MAX (gst_value_get_double_range_max (subtrahend), min1);
5163   GValue v1 = { 0, };
5164   GValue v2 = { 0, };
5165   GValue *pv1, *pv2;            /* yeah, hungarian! */
5166 
5167   if (min1 &lt; max1 &amp;&amp; min2 &lt; max2) {
5168     pv1 = &amp;v1;
5169     pv2 = &amp;v2;
5170   } else if (min1 &lt; max1) {
5171     pv1 = dest;
5172     pv2 = NULL;
5173   } else if (min2 &lt; max2) {
5174     pv1 = NULL;
5175     pv2 = dest;
5176   } else {
5177     return FALSE;
5178   }
5179 
5180   if (!dest)
5181     return TRUE;
5182 
5183   if (min1 &lt; max1) {
5184     g_value_init (pv1, GST_TYPE_DOUBLE_RANGE);
5185     gst_value_set_double_range (pv1, min1, max1);
5186   }
5187   if (min2 &lt; max2) {
5188     g_value_init (pv2, GST_TYPE_DOUBLE_RANGE);
5189     gst_value_set_double_range (pv2, min2, max2);
5190   }
5191 
5192   if (min1 &lt; max1 &amp;&amp; min2 &lt; max2) {
5193     gst_value_list_concat_and_take_values (dest, pv1, pv2);
5194   }
5195   return TRUE;
5196 }
5197 
5198 static gboolean
5199 gst_value_subtract_from_list (GValue * dest, const GValue * minuend,
5200     const GValue * subtrahend)
5201 {
5202   guint i, size;
5203   GValue subtraction = { 0, };
5204   gboolean ret = FALSE;
5205 
5206   size = VALUE_LIST_SIZE (minuend);
5207   for (i = 0; i &lt; size; i++) {
5208     const GValue *cur = VALUE_LIST_GET_VALUE (minuend, i);
5209 
5210     /* quicker version when we can discard the result */
5211     if (!dest) {
5212       if (gst_value_subtract (NULL, cur, subtrahend)) {
5213         ret = TRUE;
5214         break;
5215       }
5216       continue;
5217     }
5218 
5219     if (gst_value_subtract (&amp;subtraction, cur, subtrahend)) {
5220       if (!ret) {
5221         gst_value_move (dest, &amp;subtraction);
5222         ret = TRUE;
5223       } else if (G_VALUE_TYPE (dest) == GST_TYPE_LIST
5224           &amp;&amp; G_VALUE_TYPE (&amp;subtraction) != GST_TYPE_LIST) {
5225         _gst_value_list_append_and_take_value (dest, &amp;subtraction);
5226       } else {
5227         GValue temp;
5228 
5229         gst_value_move (&amp;temp, dest);
5230         gst_value_list_concat_and_take_values (dest, &amp;temp, &amp;subtraction);
5231       }
5232     }
5233   }
5234   return ret;
5235 }
5236 
5237 static gboolean
5238 gst_value_subtract_list (GValue * dest, const GValue * minuend,
5239     const GValue * subtrahend)
5240 {
5241   guint i, size;
5242   GValue data[2] = { {0,}, {0,} };
5243   GValue *subtraction = &amp;data[0], *result = &amp;data[1];
5244 
5245   gst_value_init_and_copy (result, minuend);
5246   size = VALUE_LIST_SIZE (subtrahend);
5247   for (i = 0; i &lt; size; i++) {
5248     const GValue *cur = VALUE_LIST_GET_VALUE (subtrahend, i);
5249 
5250     if (gst_value_subtract (subtraction, result, cur)) {
5251       GValue *temp = result;
5252 
5253       result = subtraction;
5254       subtraction = temp;
5255       g_value_unset (subtraction);
5256     } else {
5257       g_value_unset (result);
5258       return FALSE;
5259     }
5260   }
5261   if (dest) {
5262     gst_value_move (dest, result);
5263   } else {
5264     g_value_unset (result);
5265   }
5266   return TRUE;
5267 }
5268 
5269 static gboolean
5270 gst_value_subtract_fraction_fraction_range (GValue * dest,
5271     const GValue * minuend, const GValue * subtrahend)
5272 {
5273   const GValue *min = gst_value_get_fraction_range_min (subtrahend);
5274   const GValue *max = gst_value_get_fraction_range_max (subtrahend);
5275   GstValueCompareFunc compare;
5276 
5277   if ((compare = gst_value_get_compare_func (minuend))) {
5278     /* subtracting a range from an fraction only works if the fraction
5279      * is not in the range */
5280     if (gst_value_compare_with_func (minuend, min, compare) ==
5281         GST_VALUE_LESS_THAN ||
5282         gst_value_compare_with_func (minuend, max, compare) ==
5283         GST_VALUE_GREATER_THAN) {
5284       /* and the result is the value */
5285       if (dest)
5286         gst_value_init_and_copy (dest, minuend);
5287       return TRUE;
5288     }
5289   }
5290   return FALSE;
5291 }
5292 
5293 static gboolean
5294 gst_value_subtract_fraction_range_fraction (GValue * dest,
5295     const GValue * minuend, const GValue * subtrahend)
5296 {
5297   /* since we don&#39;t have open ranges, we cannot create a hole in
5298    * a range. We return the original range */
5299   if (dest)
5300     gst_value_init_and_copy (dest, minuend);
5301   return TRUE;
5302 }
5303 
5304 static gboolean
5305 gst_value_subtract_fraction_range_fraction_range (GValue * dest,
5306     const GValue * minuend, const GValue * subtrahend)
5307 {
5308   /* since we don&#39;t have open ranges, we have to approximate */
5309   /* done like with ints and doubles. Creates a list of 2 fraction ranges */
5310   const GValue *min1 = gst_value_get_fraction_range_min (minuend);
5311   const GValue *max2 = gst_value_get_fraction_range_max (minuend);
5312   const GValue *max1 = gst_value_get_fraction_range_min (subtrahend);
5313   const GValue *min2 = gst_value_get_fraction_range_max (subtrahend);
5314   gint cmp1, cmp2;
5315   GValue v1 = { 0, };
5316   GValue v2 = { 0, };
5317   GValue *pv1, *pv2;            /* yeah, hungarian! */
5318   GstValueCompareFunc compare;
5319 
5320   g_return_val_if_fail (min1 != NULL &amp;&amp; max1 != NULL, FALSE);
5321   g_return_val_if_fail (min2 != NULL &amp;&amp; max2 != NULL, FALSE);
5322 #ifdef GSTREAMER_LITE
5323   if (min1 == NULL || max1 == NULL || min2 == NULL || max2 == NULL)
5324     return FALSE;
5325 #endif // GSTREAMER_LITE
5326 
5327   compare = gst_value_get_compare_func (min1);
5328   g_return_val_if_fail (compare, FALSE);
5329 
5330   cmp1 = gst_value_compare_with_func (max2, max1, compare);
5331   g_return_val_if_fail (cmp1 != GST_VALUE_UNORDERED, FALSE);
5332   if (cmp1 == GST_VALUE_LESS_THAN)
5333     max1 = max2;
5334   cmp1 = gst_value_compare_with_func (min1, min2, compare);
5335   g_return_val_if_fail (cmp1 != GST_VALUE_UNORDERED, FALSE);
5336   if (cmp1 == GST_VALUE_GREATER_THAN)
5337     min2 = min1;
5338 
5339   cmp1 = gst_value_compare_with_func (min1, max1, compare);
5340   cmp2 = gst_value_compare_with_func (min2, max2, compare);
5341 
5342   if (cmp1 == GST_VALUE_LESS_THAN &amp;&amp; cmp2 == GST_VALUE_LESS_THAN) {
5343     pv1 = &amp;v1;
5344     pv2 = &amp;v2;
5345   } else if (cmp1 == GST_VALUE_LESS_THAN) {
5346     pv1 = dest;
5347     pv2 = NULL;
5348   } else if (cmp2 == GST_VALUE_LESS_THAN) {
5349     pv1 = NULL;
5350     pv2 = dest;
5351   } else {
5352     return FALSE;
5353   }
5354 
5355   if (!dest)
5356     return TRUE;
5357 
5358   if (cmp1 == GST_VALUE_LESS_THAN) {
5359     g_value_init (pv1, GST_TYPE_FRACTION_RANGE);
5360     gst_value_set_fraction_range (pv1, min1, max1);
5361   }
5362   if (cmp2 == GST_VALUE_LESS_THAN) {
5363     g_value_init (pv2, GST_TYPE_FRACTION_RANGE);
5364     gst_value_set_fraction_range (pv2, min2, max2);
5365   }
5366 
5367   if (cmp1 == GST_VALUE_LESS_THAN &amp;&amp; cmp2 == GST_VALUE_LESS_THAN) {
5368     gst_value_list_concat_and_take_values (dest, pv1, pv2);
5369   }
5370   return TRUE;
5371 }
5372 
5373 /**************
5374  * comparison *
5375  **************/
5376 
5377 /*
5378  * gst_value_get_compare_func:
5379  * @value1: a value to get the compare function for
5380  *
5381  * Determines the compare function to be used with values of the same type as
5382  * @value1. The function can be given to gst_value_compare_with_func().
5383  *
5384  * Returns: A #GstValueCompareFunc value
5385  */
5386 static GstValueCompareFunc
5387 gst_value_get_compare_func (const GValue * value1)
5388 {
5389   GstValueTable *table, *best = NULL;
5390   guint i;
5391   GType type1;
5392 
5393   type1 = G_VALUE_TYPE (value1);
5394 
5395   /* this is a fast check */
5396   best = gst_value_hash_lookup_type (type1);
5397 
5398   /* slower checks */
5399   if (G_UNLIKELY (!best || !best-&gt;compare)) {
5400     guint len = gst_value_table-&gt;len;
5401 
5402     best = NULL;
5403     for (i = 0; i &lt; len; i++) {
5404       table = &amp;g_array_index (gst_value_table, GstValueTable, i);
5405       if (table-&gt;compare &amp;&amp; g_type_is_a (type1, table-&gt;type)) {
5406         if (!best || g_type_is_a (table-&gt;type, best-&gt;type))
5407           best = table;
5408       }
5409     }
5410   }
5411   if (G_LIKELY (best))
5412     return best-&gt;compare;
5413 
5414   return NULL;
5415 }
5416 
5417 static inline gboolean
5418 gst_value_can_compare_unchecked (const GValue * value1, const GValue * value2)
5419 {
5420   if (G_VALUE_TYPE (value1) != G_VALUE_TYPE (value2))
5421     return FALSE;
5422 
5423   return gst_value_get_compare_func (value1) != NULL;
5424 }
5425 
5426 /**
5427  * gst_value_can_compare:
5428  * @value1: a value to compare
5429  * @value2: another value to compare
5430  *
5431  * Determines if @value1 and @value2 can be compared.
5432  *
5433  * Returns: %TRUE if the values can be compared
5434  */
5435 gboolean
5436 gst_value_can_compare (const GValue * value1, const GValue * value2)
5437 {
5438   g_return_val_if_fail (G_IS_VALUE (value1), FALSE);
5439   g_return_val_if_fail (G_IS_VALUE (value2), FALSE);
5440 
5441   return gst_value_can_compare_unchecked (value1, value2);
5442 }
5443 
5444 static gboolean
5445 gst_value_list_equals_range (const GValue * list, const GValue * value)
5446 {
5447   const GValue *first;
5448   guint list_size, n;
5449 
5450   g_assert (G_IS_VALUE (list));
5451   g_assert (G_IS_VALUE (value));
5452   g_assert (GST_VALUE_HOLDS_LIST (list));
5453 
5454   /* TODO: compare against an empty list ? No type though... */
5455   list_size = VALUE_LIST_SIZE (list);
5456   if (list_size == 0)
5457     return FALSE;
5458 
5459   /* compare the basic types - they have to match */
5460   first = VALUE_LIST_GET_VALUE (list, 0);
5461 #define CHECK_TYPES(type,prefix) \
5462   (prefix##_VALUE_HOLDS_##type(first) &amp;&amp; GST_VALUE_HOLDS_##type##_RANGE (value))
5463   if (CHECK_TYPES (INT, G)) {
5464     const gint rmin = gst_value_get_int_range_min (value);
5465     const gint rmax = gst_value_get_int_range_max (value);
5466     const gint rstep = gst_value_get_int_range_step (value);
5467     if (rstep == 0)
5468       return FALSE;
5469     /* note: this will overflow for min 0 and max INT_MAX, but this
5470        would only be equal to a list of INT_MAX elements, which seems
5471        very unlikely */
5472     if (list_size != rmax / rstep - rmin / rstep + 1)
5473       return FALSE;
5474     for (n = 0; n &lt; list_size; ++n) {
5475       gint v = g_value_get_int (VALUE_LIST_GET_VALUE (list, n));
5476       if (v &lt; rmin || v &gt; rmax || v % rstep) {
5477         return FALSE;
5478       }
5479     }
5480     return TRUE;
5481   } else if (CHECK_TYPES (INT64, G)) {
5482     const gint64 rmin = gst_value_get_int64_range_min (value);
5483     const gint64 rmax = gst_value_get_int64_range_max (value);
5484     const gint64 rstep = gst_value_get_int64_range_step (value);
5485     GST_DEBUG (&quot;List/range of int64s&quot;);
5486     if (rstep == 0)
5487       return FALSE;
5488     if (list_size != rmax / rstep - rmin / rstep + 1)
5489       return FALSE;
5490     for (n = 0; n &lt; list_size; ++n) {
5491       gint64 v = g_value_get_int64 (VALUE_LIST_GET_VALUE (list, n));
5492       if (v &lt; rmin || v &gt; rmax || v % rstep)
5493         return FALSE;
5494     }
5495     return TRUE;
5496   }
5497 #undef CHECK_TYPES
5498 
5499   /* other combinations don&#39;t make sense for equality */
5500   return FALSE;
5501 }
5502 
5503 /* &quot;Pure&quot; variant of gst_value_compare which is guaranteed to
5504  * not have list arguments and therefore does basic comparisons
5505  */
5506 static inline gint
5507 _gst_value_compare_nolist (const GValue * value1, const GValue * value2)
5508 {
5509   GstValueCompareFunc compare;
5510 
5511   if (G_VALUE_TYPE (value1) != G_VALUE_TYPE (value2))
5512     return GST_VALUE_UNORDERED;
5513 
5514   compare = gst_value_get_compare_func (value1);
5515   if (compare) {
5516     return compare (value1, value2);
5517   }
5518 
5519   g_critical (&quot;unable to compare values of type %s\n&quot;,
5520       g_type_name (G_VALUE_TYPE (value1)));
5521   return GST_VALUE_UNORDERED;
5522 }
5523 
5524 /**
5525  * gst_value_compare:
5526  * @value1: a value to compare
5527  * @value2: another value to compare
5528  *
5529  * Compares @value1 and @value2.  If @value1 and @value2 cannot be
5530  * compared, the function returns GST_VALUE_UNORDERED.  Otherwise,
5531  * if @value1 is greater than @value2, GST_VALUE_GREATER_THAN is returned.
5532  * If @value1 is less than @value2, GST_VALUE_LESS_THAN is returned.
5533  * If the values are equal, GST_VALUE_EQUAL is returned.
5534  *
5535  * Returns: comparison result
5536  */
5537 gint
5538 gst_value_compare (const GValue * value1, const GValue * value2)
5539 {
5540   gboolean value1_is_list;
5541   gboolean value2_is_list;
5542 
5543   g_return_val_if_fail (G_IS_VALUE (value1), GST_VALUE_LESS_THAN);
5544   g_return_val_if_fail (G_IS_VALUE (value2), GST_VALUE_GREATER_THAN);
5545 
5546   value1_is_list = G_VALUE_TYPE (value1) == GST_TYPE_LIST;
5547   value2_is_list = G_VALUE_TYPE (value2) == GST_TYPE_LIST;
5548 
5549   /* Special cases: lists and scalar values (&quot;{ 1 }&quot; and &quot;1&quot; are equal),
5550      as well as lists and ranges (&quot;{ 1, 2 }&quot; and &quot;[ 1, 2 ]&quot; are equal) */
5551   if (value1_is_list &amp;&amp; !value2_is_list) {
5552     gint i, n, ret;
5553 
5554     if (gst_value_list_equals_range (value1, value2)) {
5555       return GST_VALUE_EQUAL;
5556     }
5557 
5558     n = gst_value_list_get_size (value1);
5559     if (n == 0)
5560       return GST_VALUE_UNORDERED;
5561 
5562     for (i = 0; i &lt; n; i++) {
5563       const GValue *elt;
5564 
5565       elt = gst_value_list_get_value (value1, i);
5566       ret = gst_value_compare (elt, value2);
5567       if (ret != GST_VALUE_EQUAL &amp;&amp; n == 1)
5568         return ret;
5569       else if (ret != GST_VALUE_EQUAL)
5570         return GST_VALUE_UNORDERED;
5571     }
5572 
5573     return GST_VALUE_EQUAL;
5574   } else if (value2_is_list &amp;&amp; !value1_is_list) {
5575     gint i, n, ret;
5576 
5577     if (gst_value_list_equals_range (value2, value1)) {
5578       return GST_VALUE_EQUAL;
5579     }
5580 
5581     n = gst_value_list_get_size (value2);
5582     if (n == 0)
5583       return GST_VALUE_UNORDERED;
5584 
5585     for (i = 0; i &lt; n; i++) {
5586       const GValue *elt;
5587 
5588       elt = gst_value_list_get_value (value2, i);
5589       ret = gst_value_compare (elt, value1);
5590       if (ret != GST_VALUE_EQUAL &amp;&amp; n == 1)
5591         return ret;
5592       else if (ret != GST_VALUE_EQUAL)
5593         return GST_VALUE_UNORDERED;
5594     }
5595 
5596     return GST_VALUE_EQUAL;
5597   }
5598 
5599   /* And now handle the generic case */
5600   return _gst_value_compare_nolist (value1, value2);
5601 }
5602 
5603 /*
5604  * gst_value_compare_with_func:
5605  * @value1: a value to compare
5606  * @value2: another value to compare
5607  * @compare: compare function
5608  *
5609  * Compares @value1 and @value2 using the @compare function. Works like
5610  * gst_value_compare() but allows to save time determining the compare function
5611  * a multiple times.
5612  *
5613  * Returns: comparison result
5614  */
5615 static gint
5616 gst_value_compare_with_func (const GValue * value1, const GValue * value2,
5617     GstValueCompareFunc compare)
5618 {
5619   g_assert (compare);
5620 
5621   if (G_VALUE_TYPE (value1) != G_VALUE_TYPE (value2))
5622     return GST_VALUE_UNORDERED;
5623 
5624   return compare (value1, value2);
5625 }
5626 
5627 /* union */
5628 
5629 /**
5630  * gst_value_can_union:
5631  * @value1: a value to union
5632  * @value2: another value to union
5633  *
5634  * Determines if @value1 and @value2 can be non-trivially unioned.
5635  * Any two values can be trivially unioned by adding both of them
5636  * to a GstValueList.  However, certain types have the possibility
5637  * to be unioned in a simpler way.  For example, an integer range
5638  * and an integer can be unioned if the integer is a subset of the
5639  * integer range.  If there is the possibility that two values can
5640  * be unioned, this function returns %TRUE.
5641  *
5642  * Returns: %TRUE if there is a function allowing the two values to
5643  * be unioned.
5644  */
5645 gboolean
5646 gst_value_can_union (const GValue * value1, const GValue * value2)
5647 {
5648   GstValueUnionInfo *union_info;
5649   guint i, len;
5650 
5651   g_return_val_if_fail (G_IS_VALUE (value1), FALSE);
5652   g_return_val_if_fail (G_IS_VALUE (value2), FALSE);
5653 
5654   len = gst_value_union_funcs-&gt;len;
5655 
5656   for (i = 0; i &lt; len; i++) {
5657     union_info = &amp;g_array_index (gst_value_union_funcs, GstValueUnionInfo, i);
5658     if (union_info-&gt;type1 == G_VALUE_TYPE (value1) &amp;&amp;
5659         union_info-&gt;type2 == G_VALUE_TYPE (value2))
5660       return TRUE;
5661     if (union_info-&gt;type1 == G_VALUE_TYPE (value2) &amp;&amp;
5662         union_info-&gt;type2 == G_VALUE_TYPE (value1))
5663       return TRUE;
5664   }
5665 
5666   return FALSE;
5667 }
5668 
5669 /**
5670  * gst_value_union:
5671  * @dest: (out caller-allocates): the destination value
5672  * @value1: a value to union
5673  * @value2: another value to union
5674  *
5675  * Creates a GValue corresponding to the union of @value1 and @value2.
5676  *
5677  * Returns: %TRUE if the union succeeded.
5678  */
5679 gboolean
5680 gst_value_union (GValue * dest, const GValue * value1, const GValue * value2)
5681 {
5682   const GstValueUnionInfo *union_info;
5683   guint i, len;
5684   GType type1, type2;
5685 
5686   g_return_val_if_fail (dest != NULL, FALSE);
5687   g_return_val_if_fail (G_IS_VALUE (value1), FALSE);
5688   g_return_val_if_fail (G_IS_VALUE (value2), FALSE);
5689   g_return_val_if_fail (gst_value_list_or_array_are_compatible (value1, value2),
5690       FALSE);
5691 
5692   len = gst_value_union_funcs-&gt;len;
5693   type1 = G_VALUE_TYPE (value1);
5694   type2 = G_VALUE_TYPE (value2);
5695 
5696   for (i = 0; i &lt; len; i++) {
5697     union_info = &amp;g_array_index (gst_value_union_funcs, GstValueUnionInfo, i);
5698     if (union_info-&gt;type1 == type1 &amp;&amp; union_info-&gt;type2 == type2) {
5699       return union_info-&gt;func (dest, value1, value2);
5700     }
5701     if (union_info-&gt;type1 == type2 &amp;&amp; union_info-&gt;type2 == type1) {
5702       return union_info-&gt;func (dest, value2, value1);
5703     }
5704   }
5705 
5706   gst_value_list_concat (dest, value1, value2);
5707   return TRUE;
5708 }
5709 
5710 /* gst_value_register_union_func: (skip)
5711  * @type1: a type to union
5712  * @type2: another type to union
5713  * @func: a function that implements creating a union between the two types
5714  *
5715  * Registers a union function that can create a union between #GValue items
5716  * of the type @type1 and @type2.
5717  *
5718  * Union functions should be registered at startup before any pipelines are
5719  * started, as gst_value_register_union_func() is not thread-safe and cannot
5720  * be used at the same time as gst_value_union() or gst_value_can_union().
5721  */
5722 static void
5723 gst_value_register_union_func (GType type1, GType type2, GstValueUnionFunc func)
5724 {
5725   GstValueUnionInfo union_info;
5726 
5727   union_info.type1 = type1;
5728   union_info.type2 = type2;
5729   union_info.func = func;
5730 
5731   g_array_append_val (gst_value_union_funcs, union_info);
5732 }
5733 
5734 /* intersection */
5735 
5736 /**
5737  * gst_value_can_intersect:
5738  * @value1: a value to intersect
5739  * @value2: another value to intersect
5740  *
5741  * Determines if intersecting two values will produce a valid result.
5742  * Two values will produce a valid intersection if they have the same
5743  * type.
5744  *
5745  * Returns: %TRUE if the values can intersect
5746  */
5747 gboolean
5748 gst_value_can_intersect (const GValue * value1, const GValue * value2)
5749 {
5750   GstValueIntersectInfo *intersect_info;
5751   guint i, len;
5752   GType type1, type2;
5753 
5754   g_return_val_if_fail (G_IS_VALUE (value1), FALSE);
5755   g_return_val_if_fail (G_IS_VALUE (value2), FALSE);
5756 
5757   type1 = G_VALUE_TYPE (value1);
5758   type2 = G_VALUE_TYPE (value2);
5759 
5760   /* practically all GstValue types have a compare function (_can_compare=TRUE)
5761    * GstStructure and GstCaps have not, but are intersectable */
5762   if (type1 == type2)
5763     return TRUE;
5764 
5765   /* special cases */
5766   if (type1 == GST_TYPE_LIST || type2 == GST_TYPE_LIST)
5767     return TRUE;
5768 
5769   if (G_UNLIKELY (GST_VALUE_HOLDS_FLAG_SET (value1) &amp;&amp;
5770           GST_VALUE_HOLDS_FLAG_SET (value2))) {
5771     GType type1, type2, flagset_type;
5772 
5773     type1 = G_VALUE_TYPE (value1);
5774     type2 = G_VALUE_TYPE (value2);
5775     flagset_type = GST_TYPE_FLAG_SET;
5776 
5777     /* Allow intersection with the generic FlagSet type, on one
5778      * side, but not 2 different subtypes - that makes no sense */
5779     if (type1 == type2 || type1 == flagset_type || type2 == flagset_type)
5780       return TRUE;
5781   }
5782 
5783   /* check registered intersect functions */
5784   len = gst_value_intersect_funcs-&gt;len;
5785   for (i = 0; i &lt; len; i++) {
5786     intersect_info = &amp;g_array_index (gst_value_intersect_funcs,
5787         GstValueIntersectInfo, i);
5788     if ((intersect_info-&gt;type1 == type1 &amp;&amp; intersect_info-&gt;type2 == type2) ||
5789         (intersect_info-&gt;type1 == type2 &amp;&amp; intersect_info-&gt;type2 == type1))
5790       return TRUE;
5791   }
5792 
5793   return gst_value_can_compare_unchecked (value1, value2);
5794 }
5795 
5796 /**
5797  * gst_value_intersect:
5798  * @dest: (out caller-allocates) (transfer full) (allow-none):
5799  *   a uninitialized #GValue that will hold the calculated
5800  *   intersection value. May be %NULL if the resulting set if not
5801  *   needed.
5802  * @value1: a value to intersect
5803  * @value2: another value to intersect
5804  *
5805  * Calculates the intersection of two values.  If the values have
5806  * a non-empty intersection, the value representing the intersection
5807  * is placed in @dest, unless %NULL.  If the intersection is non-empty,
5808  * @dest is not modified.
5809  *
5810  * Returns: %TRUE if the intersection is non-empty
5811  */
5812 gboolean
5813 gst_value_intersect (GValue * dest, const GValue * value1,
5814     const GValue * value2)
5815 {
5816   GstValueIntersectInfo *intersect_info;
5817   guint i, len;
5818   GType type1, type2;
5819 
5820   g_return_val_if_fail (G_IS_VALUE (value1), FALSE);
5821   g_return_val_if_fail (G_IS_VALUE (value2), FALSE);
5822 
5823   type1 = G_VALUE_TYPE (value1);
5824   type2 = G_VALUE_TYPE (value2);
5825 
5826   /* special cases first */
5827   if (type1 == GST_TYPE_LIST)
5828     return gst_value_intersect_list (dest, value1, value2);
5829   if (type2 == GST_TYPE_LIST)
5830     return gst_value_intersect_list (dest, value2, value1);
5831 
5832   if (_gst_value_compare_nolist (value1, value2) == GST_VALUE_EQUAL) {
5833     if (dest)
5834       gst_value_init_and_copy (dest, value1);
5835     return TRUE;
5836   }
5837 
5838   len = gst_value_intersect_funcs-&gt;len;
5839   for (i = 0; i &lt; len; i++) {
5840     intersect_info = &amp;g_array_index (gst_value_intersect_funcs,
5841         GstValueIntersectInfo, i);
5842     if (intersect_info-&gt;type1 == type1 &amp;&amp; intersect_info-&gt;type2 == type2) {
5843       return intersect_info-&gt;func (dest, value1, value2);
5844     }
5845     if (intersect_info-&gt;type1 == type2 &amp;&amp; intersect_info-&gt;type2 == type1) {
5846       return intersect_info-&gt;func (dest, value2, value1);
5847     }
5848   }
5849 
5850   /* Failed to find a direct intersection, check if these are
5851    * GstFlagSet sub-types. */
5852   if (G_UNLIKELY (GST_VALUE_HOLDS_FLAG_SET (value1) &amp;&amp;
5853           GST_VALUE_HOLDS_FLAG_SET (value2))) {
5854     return gst_value_intersect_flagset_flagset (dest, value1, value2);
5855   }
5856 
5857   return FALSE;
5858 }
5859 
5860 
5861 
5862 /* gst_value_register_intersect_func: (skip)
5863  * @type1: the first type to intersect
5864  * @type2: the second type to intersect
5865  * @func: the intersection function
5866  *
5867  * Registers a function that is called to calculate the intersection
5868  * of the values having the types @type1 and @type2.
5869  *
5870  * Intersect functions should be registered at startup before any pipelines are
5871  * started, as gst_value_register_intersect_func() is not thread-safe and
5872  * cannot be used at the same time as gst_value_intersect() or
5873  * gst_value_can_intersect().
5874  */
5875 static void
5876 gst_value_register_intersect_func (GType type1, GType type2,
5877     GstValueIntersectFunc func)
5878 {
5879   GstValueIntersectInfo intersect_info;
5880 
5881   intersect_info.type1 = type1;
5882   intersect_info.type2 = type2;
5883   intersect_info.func = func;
5884 
5885   g_array_append_val (gst_value_intersect_funcs, intersect_info);
5886 }
5887 
5888 
5889 /* subtraction */
5890 
5891 /**
5892  * gst_value_subtract:
5893  * @dest: (out caller-allocates) (allow-none): the destination value
5894  *     for the result if the subtraction is not empty. May be %NULL,
5895  *     in which case the resulting set will not be computed, which can
5896  *     give a fair speedup.
5897  * @minuend: the value to subtract from
5898  * @subtrahend: the value to subtract
5899  *
5900  * Subtracts @subtrahend from @minuend and stores the result in @dest.
5901  * Note that this means subtraction as in sets, not as in mathematics.
5902  *
5903  * Returns: %TRUE if the subtraction is not empty
5904  */
5905 gboolean
5906 gst_value_subtract (GValue * dest, const GValue * minuend,
5907     const GValue * subtrahend)
5908 {
5909   GstValueSubtractInfo *info;
5910   guint i, len;
5911   GType mtype, stype;
5912 
5913   g_return_val_if_fail (G_IS_VALUE (minuend), FALSE);
5914   g_return_val_if_fail (G_IS_VALUE (subtrahend), FALSE);
5915 
5916   mtype = G_VALUE_TYPE (minuend);
5917   stype = G_VALUE_TYPE (subtrahend);
5918 
5919   /* special cases first */
5920   if (mtype == GST_TYPE_LIST)
5921     return gst_value_subtract_from_list (dest, minuend, subtrahend);
5922   if (stype == GST_TYPE_LIST)
5923     return gst_value_subtract_list (dest, minuend, subtrahend);
5924 
5925   len = gst_value_subtract_funcs-&gt;len;
5926   for (i = 0; i &lt; len; i++) {
5927     info = &amp;g_array_index (gst_value_subtract_funcs, GstValueSubtractInfo, i);
5928     if (info-&gt;minuend == mtype &amp;&amp; info-&gt;subtrahend == stype) {
5929       return info-&gt;func (dest, minuend, subtrahend);
5930     }
5931   }
5932 
5933   if (_gst_value_compare_nolist (minuend, subtrahend) != GST_VALUE_EQUAL) {
5934     if (dest)
5935       gst_value_init_and_copy (dest, minuend);
5936     return TRUE;
5937   }
5938 
5939   return FALSE;
5940 }
5941 
5942 #if 0
5943 gboolean
5944 gst_value_subtract (GValue * dest, const GValue * minuend,
5945     const GValue * subtrahend)
5946 {
5947   gboolean ret = gst_value_subtract2 (dest, minuend, subtrahend);
5948 
5949   g_printerr (&quot;\&quot;%s\&quot;  -  \&quot;%s\&quot;  =  \&quot;%s\&quot;\n&quot;, gst_value_serialize (minuend),
5950       gst_value_serialize (subtrahend),
5951       ret ? gst_value_serialize (dest) : &quot;---&quot;);
5952   return ret;
5953 }
5954 #endif
5955 
5956 /**
5957  * gst_value_can_subtract:
5958  * @minuend: the value to subtract from
5959  * @subtrahend: the value to subtract
5960  *
5961  * Checks if it&#39;s possible to subtract @subtrahend from @minuend.
5962  *
5963  * Returns: %TRUE if a subtraction is possible
5964  */
5965 gboolean
5966 gst_value_can_subtract (const GValue * minuend, const GValue * subtrahend)
5967 {
5968   GstValueSubtractInfo *info;
5969   guint i, len;
5970   GType mtype, stype;
5971 
5972   g_return_val_if_fail (G_IS_VALUE (minuend), FALSE);
5973   g_return_val_if_fail (G_IS_VALUE (subtrahend), FALSE);
5974 
5975   mtype = G_VALUE_TYPE (minuend);
5976   stype = G_VALUE_TYPE (subtrahend);
5977 
5978   /* special cases */
5979   if (mtype == GST_TYPE_LIST || stype == GST_TYPE_LIST)
5980     return TRUE;
5981   if (mtype == GST_TYPE_STRUCTURE || stype == GST_TYPE_STRUCTURE)
5982     return FALSE;
5983 
5984   len = gst_value_subtract_funcs-&gt;len;
5985   for (i = 0; i &lt; len; i++) {
5986     info = &amp;g_array_index (gst_value_subtract_funcs, GstValueSubtractInfo, i);
5987     if (info-&gt;minuend == mtype &amp;&amp; info-&gt;subtrahend == stype)
5988       return TRUE;
5989   }
5990 
5991   return gst_value_can_compare_unchecked (minuend, subtrahend);
5992 }
5993 
5994 /* gst_value_register_subtract_func: (skip)
5995  * @minuend_type: type of the minuend
5996  * @subtrahend_type: type of the subtrahend
5997  * @func: function to use
5998  *
5999  * Registers @func as a function capable of subtracting the values of
6000  * @subtrahend_type from values of @minuend_type.
6001  *
6002  * Subtract functions should be registered at startup before any pipelines are
6003  * started, as gst_value_register_subtract_func() is not thread-safe and
6004  * cannot be used at the same time as gst_value_subtract().
6005  */
6006 static void
6007 gst_value_register_subtract_func (GType minuend_type, GType subtrahend_type,
6008     GstValueSubtractFunc func)
6009 {
6010   GstValueSubtractInfo info;
6011 
6012   g_return_if_fail (!gst_type_is_fixed (minuend_type)
6013       || !gst_type_is_fixed (subtrahend_type));
6014 
6015   info.minuend = minuend_type;
6016   info.subtrahend = subtrahend_type;
6017   info.func = func;
6018 
6019   g_array_append_val (gst_value_subtract_funcs, info);
6020 }
6021 
6022 /**
6023  * gst_value_register:
6024  * @table: structure containing functions to register
6025  *
6026  * Registers functions to perform calculations on #GValue items of a given
6027  * type. Each type can only be added once.
6028  */
6029 void
6030 gst_value_register (const GstValueTable * table)
6031 {
6032   GstValueTable *found;
6033 
6034   g_return_if_fail (table != NULL);
6035 
6036   g_array_append_val (gst_value_table, *table);
6037 
6038   found = gst_value_hash_lookup_type (table-&gt;type);
6039   if (found)
6040     g_warning (&quot;adding type %s multiple times&quot;, g_type_name (table-&gt;type));
6041 
6042   /* FIXME: we&#39;re not really doing the const justice, we assume the table is
6043    * static */
6044   gst_value_hash_add_type (table-&gt;type, table);
6045 }
6046 
6047 /**
6048  * gst_value_init_and_copy:
6049  * @dest: (out caller-allocates): the target value
6050  * @src: the source value
6051  *
6052  * Initialises the target value to be of the same type as source and then copies
6053  * the contents from source to target.
6054  */
6055 void
6056 gst_value_init_and_copy (GValue * dest, const GValue * src)
6057 {
6058   g_return_if_fail (G_IS_VALUE (src));
6059   g_return_if_fail (dest != NULL);
6060 #ifdef GSTREAMER_LITE
6061   if (src == NULL || !G_IS_VALUE (src) || dest == NULL)
6062     return;
6063 #endif // GSTREAMER_LITE
6064 
6065   g_value_init (dest, G_VALUE_TYPE (src));
6066   g_value_copy (src, dest);
6067 }
6068 
6069 /* move src into dest and clear src */
6070 static void
6071 gst_value_move (GValue * dest, GValue * src)
6072 {
6073   g_assert (G_IS_VALUE (src));
6074   g_assert (dest != NULL);
6075 
6076   *dest = *src;
6077   memset (src, 0, sizeof (GValue));
6078 }
6079 
6080 /**
6081  * gst_value_serialize:
6082  * @value: a #GValue to serialize
6083  *
6084  * tries to transform the given @value into a string representation that allows
6085  * getting back this string later on using gst_value_deserialize().
6086  *
6087  * Free-function: g_free
6088  *
6089  * Returns: (transfer full) (nullable): the serialization for @value
6090  * or %NULL if none exists
6091  */
6092 gchar *
6093 gst_value_serialize (const GValue * value)
6094 {
6095   guint i, len;
6096   GValue s_val = { 0 };
6097   GstValueTable *table, *best;
6098   gchar *s;
6099   GType type;
6100 
6101   g_return_val_if_fail (G_IS_VALUE (value), NULL);
6102 
6103   type = G_VALUE_TYPE (value);
6104 
6105   best = gst_value_hash_lookup_type (type);
6106 
6107   if (G_UNLIKELY (!best || !best-&gt;serialize)) {
6108     len = gst_value_table-&gt;len;
6109     best = NULL;
6110     for (i = 0; i &lt; len; i++) {
6111       table = &amp;g_array_index (gst_value_table, GstValueTable, i);
6112       if (table-&gt;serialize &amp;&amp; g_type_is_a (type, table-&gt;type)) {
6113         if (!best || g_type_is_a (table-&gt;type, best-&gt;type))
6114           best = table;
6115       }
6116     }
6117   }
6118   if (G_LIKELY (best))
6119     return best-&gt;serialize (value);
6120 
6121   g_value_init (&amp;s_val, G_TYPE_STRING);
6122   if (g_value_transform (value, &amp;s_val)) {
6123     s = gst_string_wrap (g_value_get_string (&amp;s_val));
6124   } else {
6125     s = NULL;
6126   }
6127   g_value_unset (&amp;s_val);
6128 
6129   return s;
6130 }
6131 
6132 /**
6133  * gst_value_deserialize:
6134  * @dest: (out caller-allocates): #GValue to fill with contents of
6135  *     deserialization
6136  * @src: string to deserialize
6137  *
6138  * Tries to deserialize a string into the type specified by the given GValue.
6139  * If the operation succeeds, %TRUE is returned, %FALSE otherwise.
6140  *
6141  * Returns: %TRUE on success
6142  */
6143 gboolean
6144 gst_value_deserialize (GValue * dest, const gchar * src)
6145 {
6146   GstValueTable *table, *best;
6147   guint i, len;
6148   GType type;
6149 
6150   g_return_val_if_fail (src != NULL, FALSE);
6151   g_return_val_if_fail (G_IS_VALUE (dest), FALSE);
6152 
6153   type = G_VALUE_TYPE (dest);
6154 
6155   best = gst_value_hash_lookup_type (type);
6156   if (G_UNLIKELY (!best || !best-&gt;deserialize)) {
6157     len = gst_value_table-&gt;len;
6158     best = NULL;
6159     for (i = 0; i &lt; len; i++) {
6160       table = &amp;g_array_index (gst_value_table, GstValueTable, i);
6161       if (table-&gt;deserialize &amp;&amp; g_type_is_a (type, table-&gt;type)) {
6162         if (!best || g_type_is_a (table-&gt;type, best-&gt;type))
6163           best = table;
6164       }
6165     }
6166   }
6167   if (G_LIKELY (best))
6168     return best-&gt;deserialize (dest, src);
6169 
6170   return FALSE;
6171 }
6172 
6173 static gboolean
6174 structure_field_is_fixed (GQuark field_id, const GValue * val,
6175     gpointer user_data)
6176 {
6177   return gst_value_is_fixed (val);
6178 }
6179 
6180 /**
6181  * gst_value_is_fixed:
6182  * @value: the #GValue to check
6183  *
6184  * Tests if the given GValue, if available in a GstStructure (or any other
6185  * container) contains a &quot;fixed&quot; (which means: one value) or an &quot;unfixed&quot;
6186  * (which means: multiple possible values, such as data lists or data
6187  * ranges) value.
6188  *
6189  * Returns: true if the value is &quot;fixed&quot;.
6190  */
6191 
6192 gboolean
6193 gst_value_is_fixed (const GValue * value)
6194 {
6195   GType type;
6196 
6197   g_return_val_if_fail (G_IS_VALUE (value), FALSE);
6198 
6199   type = G_VALUE_TYPE (value);
6200 
6201   /* the most common types are just basic plain glib types */
6202   if (type &lt;= G_TYPE_MAKE_FUNDAMENTAL (G_TYPE_RESERVED_GLIB_LAST)) {
6203     return TRUE;
6204   }
6205 
6206   if (type == GST_TYPE_ARRAY) {
6207     gint size, n;
6208     const GValue *kid;
6209 
6210     /* check recursively */
6211     size = gst_value_array_get_size (value);
6212     for (n = 0; n &lt; size; n++) {
6213       kid = gst_value_array_get_value (value, n);
6214       if (!gst_value_is_fixed (kid))
6215         return FALSE;
6216     }
6217     return TRUE;
6218   } else if (GST_VALUE_HOLDS_FLAG_SET (value)) {
6219     /* Flagsets are only fixed if there are no &#39;don&#39;t care&#39; bits */
6220     return (gst_value_get_flagset_mask (value) == GST_FLAG_SET_MASK_EXACT);
6221   } else if (GST_VALUE_HOLDS_STRUCTURE (value)) {
6222     return gst_structure_foreach (gst_value_get_structure (value),
6223         structure_field_is_fixed, NULL);
6224   }
6225   return gst_type_is_fixed (type);
6226 }
6227 
6228 /**
6229  * gst_value_fixate:
6230  * @dest: the #GValue destination
6231  * @src: the #GValue to fixate
6232  *
6233  * Fixate @src into a new value @dest.
6234  * For ranges, the first element is taken. For lists and arrays, the
6235  * first item is fixated and returned.
6236  * If @src is already fixed, this function returns %FALSE.
6237  *
6238  * Returns: %TRUE if @dest contains a fixated version of @src.
6239  */
6240 gboolean
6241 gst_value_fixate (GValue * dest, const GValue * src)
6242 {
6243   g_return_val_if_fail (G_IS_VALUE (src), FALSE);
6244   g_return_val_if_fail (dest != NULL, FALSE);
6245 
6246   if (G_VALUE_TYPE (src) == GST_TYPE_INT_RANGE) {
6247     g_value_init (dest, G_TYPE_INT);
6248     g_value_set_int (dest, gst_value_get_int_range_min (src));
6249   } else if (G_VALUE_TYPE (src) == GST_TYPE_DOUBLE_RANGE) {
6250     g_value_init (dest, G_TYPE_DOUBLE);
6251     g_value_set_double (dest, gst_value_get_double_range_min (src));
6252   } else if (G_VALUE_TYPE (src) == GST_TYPE_FRACTION_RANGE) {
6253     gst_value_init_and_copy (dest, gst_value_get_fraction_range_min (src));
6254   } else if (G_VALUE_TYPE (src) == GST_TYPE_LIST) {
6255     GValue temp = { 0 };
6256 
6257     /* list could be empty */
6258     if (gst_value_list_get_size (src) &lt;= 0)
6259       return FALSE;
6260 
6261     gst_value_init_and_copy (&amp;temp, gst_value_list_get_value (src, 0));
6262 
6263     if (!gst_value_fixate (dest, &amp;temp)) {
6264       gst_value_move (dest, &amp;temp);
6265     } else {
6266       g_value_unset (&amp;temp);
6267     }
6268   } else if (G_VALUE_TYPE (src) == GST_TYPE_ARRAY) {
6269     gboolean res = FALSE;
6270     guint n, len;
6271 
6272     len = gst_value_array_get_size (src);
6273     g_value_init (dest, GST_TYPE_ARRAY);
6274     for (n = 0; n &lt; len; n++) {
6275       GValue kid = { 0 };
6276       const GValue *orig_kid = gst_value_array_get_value (src, n);
6277 
6278       if (!gst_value_fixate (&amp;kid, orig_kid))
6279         gst_value_init_and_copy (&amp;kid, orig_kid);
6280       else
6281         res = TRUE;
6282       _gst_value_array_append_and_take_value (dest, &amp;kid);
6283     }
6284 
6285     if (!res)
6286       g_value_unset (dest);
6287 
6288     return res;
6289   } else if (GST_VALUE_HOLDS_FLAG_SET (src)) {
6290     guint flags;
6291 
6292     if (gst_value_get_flagset_mask (src) == GST_FLAG_SET_MASK_EXACT)
6293       return FALSE;             /* Already fixed */
6294 
6295     flags = gst_value_get_flagset_flags (src);
6296     g_value_init (dest, G_VALUE_TYPE (src));
6297     gst_value_set_flagset (dest, flags, GST_FLAG_SET_MASK_EXACT);
6298     return TRUE;
6299   } else if (GST_VALUE_HOLDS_STRUCTURE (src)) {
6300     const GstStructure *str = (GstStructure *) gst_value_get_structure (src);
6301     GstStructure *kid;
6302 
6303     if (!str)
6304       return FALSE;
6305 
6306     kid = gst_structure_copy (str);
6307     gst_structure_fixate (kid);
6308     g_value_init (dest, GST_TYPE_STRUCTURE);
6309     gst_value_set_structure (dest, kid);
6310     gst_structure_free (kid);
6311     return TRUE;
6312   } else {
6313     return FALSE;
6314   }
6315   return TRUE;
6316 }
6317 
6318 
6319 /************
6320  * fraction *
6321  ************/
6322 
6323 /* helper functions */
6324 static void
6325 gst_value_init_fraction (GValue * value)
6326 {
6327   value-&gt;data[0].v_int = 0;
6328   value-&gt;data[1].v_int = 1;
6329 }
6330 
6331 static void
6332 gst_value_copy_fraction (const GValue * src_value, GValue * dest_value)
6333 {
6334   dest_value-&gt;data[0].v_int = src_value-&gt;data[0].v_int;
6335   dest_value-&gt;data[1].v_int = src_value-&gt;data[1].v_int;
6336 }
6337 
6338 static gchar *
6339 gst_value_collect_fraction (GValue * value, guint n_collect_values,
6340     GTypeCValue * collect_values, guint collect_flags)
6341 {
6342   if (n_collect_values != 2)
6343     return g_strdup_printf (&quot;not enough value locations for `%s&#39; passed&quot;,
6344         G_VALUE_TYPE_NAME (value));
6345   if (collect_values[1].v_int == 0)
6346     return g_strdup_printf (&quot;passed &#39;0&#39; as denominator for `%s&#39;&quot;,
6347         G_VALUE_TYPE_NAME (value));
6348   if (collect_values[0].v_int &lt; -G_MAXINT)
6349     return
6350         g_strdup_printf
6351         (&quot;passed value smaller than -G_MAXINT as numerator for `%s&#39;&quot;,
6352         G_VALUE_TYPE_NAME (value));
6353   if (collect_values[1].v_int &lt; -G_MAXINT)
6354     return
6355         g_strdup_printf
6356         (&quot;passed value smaller than -G_MAXINT as denominator for `%s&#39;&quot;,
6357         G_VALUE_TYPE_NAME (value));
6358 
6359   gst_value_set_fraction (value,
6360       collect_values[0].v_int, collect_values[1].v_int);
6361 
6362   return NULL;
6363 }
6364 
6365 static gchar *
6366 gst_value_lcopy_fraction (const GValue * value, guint n_collect_values,
6367     GTypeCValue * collect_values, guint collect_flags)
6368 {
6369   gint *numerator = collect_values[0].v_pointer;
6370   gint *denominator = collect_values[1].v_pointer;
6371 
6372   if (!numerator)
6373     return g_strdup_printf (&quot;numerator for `%s&#39; passed as NULL&quot;,
6374         G_VALUE_TYPE_NAME (value));
6375   if (!denominator)
6376     return g_strdup_printf (&quot;denominator for `%s&#39; passed as NULL&quot;,
6377         G_VALUE_TYPE_NAME (value));
6378 
6379   *numerator = value-&gt;data[0].v_int;
6380   *denominator = value-&gt;data[1].v_int;
6381 
6382   return NULL;
6383 }
6384 
6385 /**
6386  * gst_value_set_fraction:
6387  * @value: a GValue initialized to #GST_TYPE_FRACTION
6388  * @numerator: the numerator of the fraction
6389  * @denominator: the denominator of the fraction
6390  *
6391  * Sets @value to the fraction specified by @numerator over @denominator.
6392  * The fraction gets reduced to the smallest numerator and denominator,
6393  * and if necessary the sign is moved to the numerator.
6394  */
6395 void
6396 gst_value_set_fraction (GValue * value, gint numerator, gint denominator)
6397 {
6398   gint gcd = 0;
6399 
6400   g_return_if_fail (GST_VALUE_HOLDS_FRACTION (value));
6401   g_return_if_fail (denominator != 0);
6402   g_return_if_fail (denominator &gt;= -G_MAXINT);
6403   g_return_if_fail (numerator &gt;= -G_MAXINT);
6404 
6405   /* normalize sign */
6406   if (denominator &lt; 0) {
6407     numerator = -numerator;
6408     denominator = -denominator;
6409   }
6410 
6411   /* check for reduction */
6412   gcd = gst_util_greatest_common_divisor (numerator, denominator);
6413   if (gcd) {
6414     numerator /= gcd;
6415     denominator /= gcd;
6416   }
6417 
6418   g_assert (denominator &gt; 0);
6419 
6420   value-&gt;data[0].v_int = numerator;
6421   value-&gt;data[1].v_int = denominator;
6422 }
6423 
6424 /**
6425  * gst_value_get_fraction_numerator:
6426  * @value: a GValue initialized to #GST_TYPE_FRACTION
6427  *
6428  * Gets the numerator of the fraction specified by @value.
6429  *
6430  * Returns: the numerator of the fraction.
6431  */
6432 gint
6433 gst_value_get_fraction_numerator (const GValue * value)
6434 {
6435   g_return_val_if_fail (GST_VALUE_HOLDS_FRACTION (value), 0);
6436 
6437   return value-&gt;data[0].v_int;
6438 }
6439 
6440 /**
6441  * gst_value_get_fraction_denominator:
6442  * @value: a GValue initialized to #GST_TYPE_FRACTION
6443  *
6444  * Gets the denominator of the fraction specified by @value.
6445  *
6446  * Returns: the denominator of the fraction.
6447  */
6448 gint
6449 gst_value_get_fraction_denominator (const GValue * value)
6450 {
6451   g_return_val_if_fail (GST_VALUE_HOLDS_FRACTION (value), 1);
6452 
6453   return value-&gt;data[1].v_int;
6454 }
6455 
6456 /**
6457  * gst_value_fraction_multiply:
6458  * @product: a GValue initialized to #GST_TYPE_FRACTION
6459  * @factor1: a GValue initialized to #GST_TYPE_FRACTION
6460  * @factor2: a GValue initialized to #GST_TYPE_FRACTION
6461  *
6462  * Multiplies the two #GValue items containing a #GST_TYPE_FRACTION and sets
6463  * @product to the product of the two fractions.
6464  *
6465  * Returns: %FALSE in case of an error (like integer overflow), %TRUE otherwise.
6466  */
6467 gboolean
6468 gst_value_fraction_multiply (GValue * product, const GValue * factor1,
6469     const GValue * factor2)
6470 {
6471   gint n1, n2, d1, d2;
6472   gint res_n, res_d;
6473 
6474   g_return_val_if_fail (product != NULL, FALSE);
6475   g_return_val_if_fail (GST_VALUE_HOLDS_FRACTION (factor1), FALSE);
6476   g_return_val_if_fail (GST_VALUE_HOLDS_FRACTION (factor2), FALSE);
6477 
6478   n1 = factor1-&gt;data[0].v_int;
6479   n2 = factor2-&gt;data[0].v_int;
6480   d1 = factor1-&gt;data[1].v_int;
6481   d2 = factor2-&gt;data[1].v_int;
6482 
6483   if (!gst_util_fraction_multiply (n1, d1, n2, d2, &amp;res_n, &amp;res_d))
6484     return FALSE;
6485 
6486   gst_value_set_fraction (product, res_n, res_d);
6487 
6488   return TRUE;
6489 }
6490 
6491 /**
6492  * gst_value_fraction_subtract:
6493  * @dest: a GValue initialized to #GST_TYPE_FRACTION
6494  * @minuend: a GValue initialized to #GST_TYPE_FRACTION
6495  * @subtrahend: a GValue initialized to #GST_TYPE_FRACTION
6496  *
6497  * Subtracts the @subtrahend from the @minuend and sets @dest to the result.
6498  *
6499  * Returns: %FALSE in case of an error (like integer overflow), %TRUE otherwise.
6500  */
6501 gboolean
6502 gst_value_fraction_subtract (GValue * dest,
6503     const GValue * minuend, const GValue * subtrahend)
6504 {
6505   gint n1, n2, d1, d2;
6506   gint res_n, res_d;
6507 
6508   g_return_val_if_fail (dest != NULL, FALSE);
6509   g_return_val_if_fail (GST_VALUE_HOLDS_FRACTION (minuend), FALSE);
6510   g_return_val_if_fail (GST_VALUE_HOLDS_FRACTION (subtrahend), FALSE);
6511 
6512   n1 = minuend-&gt;data[0].v_int;
6513   n2 = subtrahend-&gt;data[0].v_int;
6514   d1 = minuend-&gt;data[1].v_int;
6515   d2 = subtrahend-&gt;data[1].v_int;
6516 
6517   if (!gst_util_fraction_add (n1, d1, -n2, d2, &amp;res_n, &amp;res_d))
6518     return FALSE;
6519   gst_value_set_fraction (dest, res_n, res_d);
6520 
6521   return TRUE;
6522 }
6523 
6524 static gchar *
6525 gst_value_serialize_fraction (const GValue * value)
6526 {
6527   gint32 numerator = value-&gt;data[0].v_int;
6528   gint32 denominator = value-&gt;data[1].v_int;
6529   gboolean positive = TRUE;
6530 
6531   /* get the sign and make components absolute */
6532   if (numerator &lt; 0) {
6533     numerator = -numerator;
6534     positive = !positive;
6535   }
6536   if (denominator &lt; 0) {
6537     denominator = -denominator;
6538     positive = !positive;
6539   }
6540 
6541   return g_strdup_printf (&quot;%s%d/%d&quot;,
6542       positive ? &quot;&quot; : &quot;-&quot;, numerator, denominator);
6543 }
6544 
6545 static gboolean
6546 gst_value_deserialize_fraction (GValue * dest, const gchar * s)
6547 {
6548   gint num, den;
6549   gint num_chars;
6550 
6551   if (G_UNLIKELY (s == NULL))
6552     return FALSE;
6553 
6554   if (G_UNLIKELY (dest == NULL || !GST_VALUE_HOLDS_FRACTION (dest)))
6555     return FALSE;
6556 
6557   if (sscanf (s, &quot;%d/%d%n&quot;, &amp;num, &amp;den, &amp;num_chars) &gt;= 2) {
6558     if (s[num_chars] != 0)
6559       return FALSE;
6560     if (den == 0)
6561       return FALSE;
6562 
6563     gst_value_set_fraction (dest, num, den);
6564     return TRUE;
6565   } else if (g_ascii_strcasecmp (s, &quot;1/max&quot;) == 0) {
6566     gst_value_set_fraction (dest, 1, G_MAXINT);
6567     return TRUE;
6568   } else if (sscanf (s, &quot;%d%n&quot;, &amp;num, &amp;num_chars) &gt;= 1) {
6569     if (s[num_chars] != 0)
6570       return FALSE;
6571     gst_value_set_fraction (dest, num, 1);
6572     return TRUE;
6573   } else if (g_ascii_strcasecmp (s, &quot;min&quot;) == 0) {
6574     gst_value_set_fraction (dest, -G_MAXINT, 1);
6575     return TRUE;
6576   } else if (g_ascii_strcasecmp (s, &quot;max&quot;) == 0) {
6577     gst_value_set_fraction (dest, G_MAXINT, 1);
6578     return TRUE;
6579   }
6580 
6581   return FALSE;
6582 }
6583 
6584 static void
6585 gst_value_transform_fraction_string (const GValue * src_value,
6586     GValue * dest_value)
6587 {
6588   dest_value-&gt;data[0].v_pointer = gst_value_serialize_fraction (src_value);
6589 }
6590 
6591 static void
6592 gst_value_transform_string_fraction (const GValue * src_value,
6593     GValue * dest_value)
6594 {
6595   if (!gst_value_deserialize_fraction (dest_value,
6596           src_value-&gt;data[0].v_pointer))
6597     /* If the deserialize fails, ensure we leave the fraction in a
6598      * valid, if incorrect, state */
6599     gst_value_set_fraction (dest_value, 0, 1);
6600 }
6601 
6602 static void
6603 gst_value_transform_double_fraction (const GValue * src_value,
6604     GValue * dest_value)
6605 {
6606   gdouble src = g_value_get_double (src_value);
6607   gint n, d;
6608 
6609   gst_util_double_to_fraction (src, &amp;n, &amp;d);
6610   gst_value_set_fraction (dest_value, n, d);
6611 }
6612 
6613 static void
6614 gst_value_transform_float_fraction (const GValue * src_value,
6615     GValue * dest_value)
6616 {
6617   gfloat src = g_value_get_float (src_value);
6618   gint n, d;
6619 
6620   gst_util_double_to_fraction (src, &amp;n, &amp;d);
6621   gst_value_set_fraction (dest_value, n, d);
6622 }
6623 
6624 static void
6625 gst_value_transform_fraction_double (const GValue * src_value,
6626     GValue * dest_value)
6627 {
6628   dest_value-&gt;data[0].v_double = ((double) src_value-&gt;data[0].v_int) /
6629       ((double) src_value-&gt;data[1].v_int);
6630 }
6631 
6632 static void
6633 gst_value_transform_fraction_float (const GValue * src_value,
6634     GValue * dest_value)
6635 {
6636   dest_value-&gt;data[0].v_float = ((float) src_value-&gt;data[0].v_int) /
6637       ((float) src_value-&gt;data[1].v_int);
6638 }
6639 
6640 static gint
6641 gst_value_compare_fraction (const GValue * value1, const GValue * value2)
6642 {
6643   gint n1, n2;
6644   gint d1, d2;
6645   gint ret;
6646 
6647   n1 = value1-&gt;data[0].v_int;
6648   n2 = value2-&gt;data[0].v_int;
6649   d1 = value1-&gt;data[1].v_int;
6650   d2 = value2-&gt;data[1].v_int;
6651 
6652   /* fractions are reduced when set, so we can quickly see if they&#39;re equal */
6653   if (n1 == n2 &amp;&amp; d1 == d2)
6654     return GST_VALUE_EQUAL;
6655 
6656   if (d1 == 0 &amp;&amp; d2 == 0)
6657     return GST_VALUE_UNORDERED;
6658   else if (d1 == 0)
6659     return GST_VALUE_GREATER_THAN;
6660   else if (d2 == 0)
6661     return GST_VALUE_LESS_THAN;
6662 
6663   ret = gst_util_fraction_compare (n1, d1, n2, d2);
6664   if (ret == -1)
6665     return GST_VALUE_LESS_THAN;
6666   else if (ret == 1)
6667     return GST_VALUE_GREATER_THAN;
6668 
6669   /* Equality can&#39;t happen here because we check for that
6670    * first already */
6671   g_return_val_if_reached (GST_VALUE_UNORDERED);
6672 }
6673 
6674 /*********
6675  * GDate *
6676  *********/
6677 
6678 static gint
6679 gst_value_compare_date (const GValue * value1, const GValue * value2)
6680 {
6681   const GDate *date1 = (const GDate *) g_value_get_boxed (value1);
6682   const GDate *date2 = (const GDate *) g_value_get_boxed (value2);
6683   guint32 j1, j2;
6684 
6685   if (date1 == date2)
6686     return GST_VALUE_EQUAL;
6687 
6688   if ((date1 == NULL || !g_date_valid (date1))
6689       &amp;&amp; (date2 != NULL &amp;&amp; g_date_valid (date2))) {
6690     return GST_VALUE_LESS_THAN;
6691   }
6692 
6693   if ((date2 == NULL || !g_date_valid (date2))
6694       &amp;&amp; (date1 != NULL &amp;&amp; g_date_valid (date1))) {
6695     return GST_VALUE_GREATER_THAN;
6696   }
6697 
6698   if (date1 == NULL || date2 == NULL || !g_date_valid (date1)
6699       || !g_date_valid (date2)) {
6700     return GST_VALUE_UNORDERED;
6701   }
6702 
6703   j1 = g_date_get_julian (date1);
6704   j2 = g_date_get_julian (date2);
6705 
6706   if (j1 == j2)
6707     return GST_VALUE_EQUAL;
6708   else if (j1 &lt; j2)
6709     return GST_VALUE_LESS_THAN;
6710   else
6711     return GST_VALUE_GREATER_THAN;
6712 }
6713 
6714 static gchar *
6715 gst_value_serialize_date (const GValue * val)
6716 {
6717   const GDate *date = (const GDate *) g_value_get_boxed (val);
6718 
6719   if (date == NULL || !g_date_valid (date))
6720     return g_strdup (&quot;9999-99-99&quot;);
6721 
6722   return g_strdup_printf (&quot;%04u-%02u-%02u&quot;, g_date_get_year (date),
6723       g_date_get_month (date), g_date_get_day (date));
6724 }
6725 
6726 static gboolean
6727 gst_value_deserialize_date (GValue * dest, const gchar * s)
6728 {
6729   guint year, month, day;
6730 
6731   if (!s || sscanf (s, &quot;%04u-%02u-%02u&quot;, &amp;year, &amp;month, &amp;day) != 3)
6732     return FALSE;
6733 
6734   if (!g_date_valid_dmy (day, month, year))
6735     return FALSE;
6736 
6737   g_value_take_boxed (dest, g_date_new_dmy (day, month, year));
6738   return TRUE;
6739 }
6740 
6741 /*************
6742  * GstDateTime *
6743  *************/
6744 
6745 static gint
6746 gst_value_compare_date_time (const GValue * value1, const GValue * value2)
6747 {
6748   const GstDateTime *date1 = (const GstDateTime *) g_value_get_boxed (value1);
6749   const GstDateTime *date2 = (const GstDateTime *) g_value_get_boxed (value2);
6750 
6751   if (date1 == date2)
6752     return GST_VALUE_EQUAL;
6753 
6754   if ((date1 == NULL) &amp;&amp; (date2 != NULL)) {
6755     return GST_VALUE_LESS_THAN;
6756   }
6757   if ((date2 == NULL) &amp;&amp; (date1 != NULL)) {
6758     return GST_VALUE_LESS_THAN;
6759   }
6760 
6761   /* returns GST_VALUE_* */
6762   return __gst_date_time_compare (date1, date2);
6763 }
6764 
6765 static gchar *
6766 gst_value_serialize_date_time (const GValue * val)
6767 {
6768   GstDateTime *date = (GstDateTime *) g_value_get_boxed (val);
6769 
6770   if (date == NULL)
6771     return g_strdup (&quot;null&quot;);
6772 
6773   return __gst_date_time_serialize (date, TRUE);
6774 }
6775 
6776 static gboolean
6777 gst_value_deserialize_date_time (GValue * dest, const gchar * s)
6778 {
6779   GstDateTime *datetime;
6780 
6781   if (!s || strcmp (s, &quot;null&quot;) == 0) {
6782     return FALSE;
6783   }
6784 
6785   datetime = gst_date_time_new_from_iso8601_string (s);
6786   if (datetime != NULL) {
6787     g_value_take_boxed (dest, datetime);
6788     return TRUE;
6789   }
6790   GST_WARNING (&quot;Failed to deserialize date time string &#39;%s&#39;&quot;, s);
6791   return FALSE;
6792 }
6793 
6794 static void
6795 gst_value_transform_date_string (const GValue * src_value, GValue * dest_value)
6796 {
6797   dest_value-&gt;data[0].v_pointer = gst_value_serialize_date (src_value);
6798 }
6799 
6800 static void
6801 gst_value_transform_string_date (const GValue * src_value, GValue * dest_value)
6802 {
6803   gst_value_deserialize_date (dest_value, src_value-&gt;data[0].v_pointer);
6804 }
6805 
6806 
6807 /************
6808  * bitmask *
6809  ************/
6810 
6811 /* helper functions */
6812 static void
6813 gst_value_init_bitmask (GValue * value)
6814 {
6815   value-&gt;data[0].v_uint64 = 0;
6816 }
6817 
6818 static void
6819 gst_value_copy_bitmask (const GValue * src_value, GValue * dest_value)
6820 {
6821   dest_value-&gt;data[0].v_uint64 = src_value-&gt;data[0].v_uint64;
6822 }
6823 
6824 static gchar *
6825 gst_value_collect_bitmask (GValue * value, guint n_collect_values,
6826     GTypeCValue * collect_values, guint collect_flags)
6827 {
6828   if (n_collect_values != 1)
6829     return g_strdup_printf (&quot;not enough value locations for `%s&#39; passed&quot;,
6830         G_VALUE_TYPE_NAME (value));
6831 
6832   gst_value_set_bitmask (value, (guint64) collect_values[0].v_int64);
6833 
6834   return NULL;
6835 }
6836 
6837 static gchar *
6838 gst_value_lcopy_bitmask (const GValue * value, guint n_collect_values,
6839     GTypeCValue * collect_values, guint collect_flags)
6840 {
6841   guint64 *bitmask = collect_values[0].v_pointer;
6842 
6843   if (!bitmask)
6844     return g_strdup_printf (&quot;value for `%s&#39; passed as NULL&quot;,
6845         G_VALUE_TYPE_NAME (value));
6846 
6847   *bitmask = value-&gt;data[0].v_uint64;
6848 
6849   return NULL;
6850 }
6851 
6852 /**
6853  * gst_value_set_bitmask:
6854  * @value: a GValue initialized to #GST_TYPE_BITMASK
6855  * @bitmask: the bitmask
6856  *
6857  * Sets @value to the bitmask specified by @bitmask.
6858  */
6859 void
6860 gst_value_set_bitmask (GValue * value, guint64 bitmask)
6861 {
6862   g_return_if_fail (GST_VALUE_HOLDS_BITMASK (value));
6863 
6864   value-&gt;data[0].v_uint64 = bitmask;
6865 }
6866 
6867 /**
6868  * gst_value_get_bitmask:
6869  * @value: a GValue initialized to #GST_TYPE_BITMASK
6870  *
6871  * Gets the bitmask specified by @value.
6872  *
6873  * Returns: the bitmask.
6874  */
6875 guint64
6876 gst_value_get_bitmask (const GValue * value)
6877 {
6878   g_return_val_if_fail (GST_VALUE_HOLDS_BITMASK (value), 0);
6879 
6880   return value-&gt;data[0].v_uint64;
6881 }
6882 
6883 static gchar *
6884 gst_value_serialize_bitmask (const GValue * value)
6885 {
6886   guint64 bitmask = value-&gt;data[0].v_uint64;
6887 
6888   return g_strdup_printf (&quot;0x%016&quot; G_GINT64_MODIFIER &quot;x&quot;, bitmask);
6889 }
6890 
6891 static gboolean
6892 gst_value_deserialize_bitmask (GValue * dest, const gchar * s)
6893 {
6894   gchar *endptr = NULL;
6895   guint64 val;
6896 
6897   if (G_UNLIKELY (s == NULL))
6898     return FALSE;
6899 
6900   if (G_UNLIKELY (dest == NULL || !GST_VALUE_HOLDS_BITMASK (dest)))
6901     return FALSE;
6902 
6903   errno = 0;
6904   val = g_ascii_strtoull (s, &amp;endptr, 16);
6905   if (val == G_MAXUINT64 &amp;&amp; (errno == ERANGE || errno == EINVAL))
6906     return FALSE;
6907   if (val == 0 &amp;&amp; endptr == s)
6908     return FALSE;
6909 
6910   gst_value_set_bitmask (dest, val);
6911 
6912   return TRUE;
6913 }
6914 
6915 static void
6916 gst_value_transform_bitmask_string (const GValue * src_value,
6917     GValue * dest_value)
6918 {
6919   dest_value-&gt;data[0].v_pointer = gst_value_serialize_bitmask (src_value);
6920 }
6921 
6922 static void
6923 gst_value_transform_string_bitmask (const GValue * src_value,
6924     GValue * dest_value)
6925 {
6926   if (!gst_value_deserialize_bitmask (dest_value, src_value-&gt;data[0].v_pointer))
6927     gst_value_set_bitmask (dest_value, 0);
6928 }
6929 
6930 static void
6931 gst_value_transform_uint64_bitmask (const GValue * src_value,
6932     GValue * dest_value)
6933 {
6934   dest_value-&gt;data[0].v_uint64 = src_value-&gt;data[0].v_uint64;
6935 }
6936 
6937 static void
6938 gst_value_transform_bitmask_uint64 (const GValue * src_value,
6939     GValue * dest_value)
6940 {
6941   dest_value-&gt;data[0].v_uint64 = src_value-&gt;data[0].v_uint64;
6942 }
6943 
6944 static gint
6945 gst_value_compare_bitmask (const GValue * value1, const GValue * value2)
6946 {
6947   guint64 v1, v2;
6948 
6949   v1 = value1-&gt;data[0].v_uint64;
6950   v2 = value2-&gt;data[0].v_uint64;
6951 
6952   if (v1 == v2)
6953     return GST_VALUE_EQUAL;
6954 
6955   return GST_VALUE_UNORDERED;
6956 }
6957 
6958 /************
6959  * flagset *
6960  ************/
6961 
6962 /* helper functions */
6963 static void
6964 gst_value_init_flagset (GValue * value)
6965 {
6966   value-&gt;data[0].v_uint = 0;
6967   value-&gt;data[1].v_uint = 0;
6968 }
6969 
6970 static void
6971 gst_value_copy_flagset (const GValue * src_value, GValue * dest_value)
6972 {
6973   dest_value-&gt;data[0].v_uint = src_value-&gt;data[0].v_uint;
6974   dest_value-&gt;data[1].v_uint = src_value-&gt;data[1].v_uint;
6975 }
6976 
6977 static gchar *
6978 gst_value_collect_flagset (GValue * value, guint n_collect_values,
6979     GTypeCValue * collect_values, guint collect_flags)
6980 {
6981   if (n_collect_values != 2)
6982     return g_strdup_printf (&quot;not enough value locations for `%s&#39; passed&quot;,
6983         G_VALUE_TYPE_NAME (value));
6984 
6985   gst_value_set_flagset (value,
6986       (guint) collect_values[0].v_int, (guint) collect_values[1].v_int);
6987 
6988   return NULL;
6989 }
6990 
6991 static gchar *
6992 gst_value_lcopy_flagset (const GValue * value, guint n_collect_values,
6993     GTypeCValue * collect_values, guint collect_flags)
6994 {
6995   guint *flags = collect_values[0].v_pointer;
6996   guint *mask = collect_values[1].v_pointer;
6997 
6998   *flags = value-&gt;data[0].v_uint;
6999   *mask = value-&gt;data[1].v_uint;
7000 
7001   return NULL;
7002 }
7003 
7004 /**
7005  * gst_value_set_flagset:
7006  * @value: a GValue initialized to %GST_TYPE_FLAG_SET
7007  * @flags: The value of the flags set or unset
7008  * @mask: The mask indicate which flags bits must match for comparisons
7009  *
7010  * Sets @value to the flags and mask values provided in @flags and @mask.
7011  * The @flags value indicates the values of flags, the @mask represents
7012  * which bits in the flag value have been set, and which are &quot;don&#39;t care&quot;
7013  *
7014  * Since: 1.6
7015  */
7016 void
7017 gst_value_set_flagset (GValue * value, guint flags, guint mask)
7018 {
7019   g_return_if_fail (GST_VALUE_HOLDS_FLAG_SET (value));
7020 
7021   /* Normalise and only keep flags mentioned in the mask */
7022   value-&gt;data[0].v_uint = flags &amp; mask;
7023   value-&gt;data[1].v_uint = mask;
7024 }
7025 
7026 /**
7027  * gst_value_get_flagset_flags:
7028  * @value: a GValue initialized to #GST_TYPE_FLAG_SET
7029  *
7030  * Retrieve the flags field of a GstFlagSet @value.
7031  *
7032  * Returns: the flags field of the flagset instance.
7033  *
7034  * Since: 1.6
7035  */
7036 guint
7037 gst_value_get_flagset_flags (const GValue * value)
7038 {
7039   g_return_val_if_fail (GST_VALUE_HOLDS_FLAG_SET (value), 0);
7040 
7041   return value-&gt;data[0].v_uint;
7042 }
7043 
7044 /**
7045  * gst_value_get_flagset_mask:
7046  * @value: a GValue initialized to #GST_TYPE_FLAG_SET
7047  *
7048  * Retrieve the mask field of a GstFlagSet @value.
7049  *
7050  * Returns: the mask field of the flagset instance.
7051  *
7052  * Since: 1.6
7053  */
7054 guint
7055 gst_value_get_flagset_mask (const GValue * value)
7056 {
7057   g_return_val_if_fail (GST_VALUE_HOLDS_FLAG_SET (value), 1);
7058 
7059   return value-&gt;data[1].v_uint;
7060 }
7061 
7062 static gchar *
7063 gst_value_serialize_flagset (const GValue * value)
7064 {
7065   guint flags = value-&gt;data[0].v_uint;
7066   guint mask = value-&gt;data[1].v_uint;
7067   GstFlagSetClass *set_klass =
7068       (GstFlagSetClass *) g_type_class_ref (G_VALUE_TYPE (value));
7069   gchar *result;
7070 
7071   result = g_strdup_printf (&quot;%x:%x&quot;, flags, mask);
7072 
7073   /* If this flag set class has an associated GFlags GType, and some
7074    * bits in the mask, serialize the bits in human-readable form to
7075    * aid debugging */
7076   if (mask &amp;&amp; set_klass-&gt;flags_type) {
7077     GFlagsClass *flags_klass =
7078         (GFlagsClass *) (g_type_class_ref (set_klass-&gt;flags_type));
7079     GFlagsValue *fl;
7080     gchar *tmp;
7081     gboolean first = TRUE;
7082 
7083     g_return_val_if_fail (flags_klass, NULL);
7084 
7085     /* some bits in the mask are set, so serialize one by one, according
7086      * to whether that bit is set or cleared in the flags value */
7087     while (mask) {
7088       fl = g_flags_get_first_value (flags_klass, mask);
7089       if (fl == NULL) {
7090         /* No more bits match in the flags mask - time to stop */
7091         mask = 0;
7092         break;
7093       }
7094 
7095       tmp = g_strconcat (result,
7096           first ? &quot;:&quot; : &quot;&quot;,
7097           (flags &amp; fl-&gt;value) ? &quot;+&quot; : &quot;/&quot;, fl-&gt;value_nick, NULL);
7098       g_free (result);
7099       result = tmp;
7100       first = FALSE;
7101 
7102       /* clear flag */
7103       mask &amp;= ~fl-&gt;value;
7104     }
7105     g_type_class_unref (flags_klass);
7106 
7107   }
7108   g_type_class_unref (set_klass);
7109 
7110   return result;
7111 }
7112 
<a name="1" id="anc1"></a><span class="line-added">7113 #ifndef GSTREAMER_LITE</span>
7114 static gboolean
7115 is_valid_flags_string (const gchar * s)
7116 {
7117   /* We&#39;re looking to match +this/that+other-thing/not-this-thing type strings */
7118   return g_regex_match_simple (&quot;^([\\+\\/][\\w\\d-]+)+$&quot;, s, G_REGEX_CASELESS,
7119       0);
7120 }
7121 
7122 static gboolean
7123 gst_value_deserialize_flagset (GValue * dest, const gchar * s)
7124 {
7125   gboolean res = FALSE;
7126   guint flags, mask;
7127   gchar *cur, *next;
7128 
7129   if (G_UNLIKELY (s == NULL))
7130     return FALSE;
7131 
7132   if (G_UNLIKELY (dest == NULL || !GST_VALUE_HOLDS_FLAG_SET (dest)))
7133     return FALSE;
7134 
7135   /* Flagset strings look like %x:%x - hex flags : hex bitmask,
7136    * 32-bit each, or like a concatenated list of flag nicks,
7137    * with either &#39;+&#39; or &#39;/&#39; in front. The first form
7138    * may optionally be followed by &#39;:&#39; and a set of text flag descriptions
7139    * for easier debugging */
7140 
7141   /* Try and interpret as hex form first, as it&#39;s the most efficient */
7142   /* Read the flags first */
7143   flags = strtoul (s, &amp;next, 16);
7144   if (G_UNLIKELY ((flags == 0 &amp;&amp; errno == EINVAL) || s == next))
7145     goto try_as_flags_string;
7146   /* Next char should be a colon */
7147   if (next[0] == &#39;:&#39;)
7148     next++;
7149 
7150   /* Read the mask */
7151   cur = next;
7152   mask = strtoul (cur, &amp;next, 16);
7153   if (G_UNLIKELY ((mask == 0 &amp;&amp; errno == EINVAL) || cur == next))
7154     goto try_as_flags_string;
7155 
7156   /* Next char should be NULL terminator, or a &#39;:&#39;. If &#39;:&#39;, we need the flag string after */
7157   if (G_UNLIKELY (next[0] == 0)) {
7158     res = TRUE;
7159     goto done;
7160   }
7161 
7162   if (next[0] != &#39;:&#39;)
7163     return FALSE;
7164 
7165   s = next + 1;
7166 
7167   if (g_str_equal (g_type_name (G_VALUE_TYPE (dest)), &quot;GstFlagSet&quot;)) {
7168     /* If we&#39;re parsing a generic flag set, that can mean we&#39;re guessing
7169      * at the type in deserialising a GstStructure so at least check that
7170      * we have a valid-looking string, so we don&#39;t cause deserialisation of
7171      * other types of strings like 00:01:00:00 - https://bugzilla.gnome.org/show_bug.cgi?id=779755 */
7172     if (is_valid_flags_string (s)) {
7173       res = TRUE;
7174       goto done;
7175     }
7176     return FALSE;
7177   }
7178 
7179   /* Otherwise, we already got a hex string for a valid non-generic flagset type */
7180   res = TRUE;
7181   goto done;
7182 
7183 try_as_flags_string:
7184 
7185   {
7186     const gchar *set_class = g_type_name (G_VALUE_TYPE (dest));
7187     GFlagsClass *flags_klass = NULL;
7188     const gchar *end;
7189 
7190     if (g_str_equal (set_class, &quot;GstFlagSet&quot;)) {
7191       /* There&#39;s no hope to parse the fields of generic flag set if we didn&#39;t already
7192        * catch a hex-string above */
7193       return FALSE;
7194     }
7195 
7196     /* Flags class is the FlagSet class with &#39;Set&#39; removed from the end */
7197     end = g_strrstr (set_class, &quot;Set&quot;);
7198 
7199     if (end != NULL) {
7200       gchar *class_name = g_strndup (set_class, end - set_class);
7201       GType flags_type = g_type_from_name (class_name);
7202       if (flags_type == 0) {
7203         GST_TRACE (&quot;Looking for dynamic type %s&quot;, class_name);
7204         gst_dynamic_type_factory_load (class_name);
7205       }
7206 
7207       if (flags_type != 0) {
7208         flags_klass = g_type_class_ref (flags_type);
7209         GST_TRACE (&quot;Going to parse %s as %s&quot;, s, class_name);
7210       }
7211       g_free (class_name);
7212     }
7213 
7214     if (flags_klass) {
7215       res = gst_value_gflags_str_to_flags (flags_klass, s, &amp;flags, &amp;mask);
7216       g_type_class_unref (flags_klass);
7217     }
7218   }
7219 
7220 done:
7221   if (res)
7222     gst_value_set_flagset (dest, flags, mask);
7223   return res;
7224 
7225 }
7226 
7227 static void
7228 gst_value_transform_flagset_string (const GValue * src_value,
7229     GValue * dest_value)
7230 {
7231   dest_value-&gt;data[0].v_pointer = gst_value_serialize_flagset (src_value);
7232 }
7233 
7234 static void
7235 gst_value_transform_string_flagset (const GValue * src_value,
7236     GValue * dest_value)
7237 {
7238   if (!gst_value_deserialize_flagset (dest_value, src_value-&gt;data[0].v_pointer)) {
7239     /* If the deserialize fails, ensure we leave the flags in a
7240      * valid, if incorrect, state */
7241     gst_value_set_flagset (dest_value, 0, 0);
7242   }
7243 }
<a name="2" id="anc2"></a><span class="line-added">7244 #endif // GSTREAMER_LITE</span>
7245 
7246 static gint
7247 gst_value_compare_flagset (const GValue * value1, const GValue * value2)
7248 {
7249   guint v1, v2;
7250   guint m1, m2;
7251 
7252   v1 = value1-&gt;data[0].v_uint;
7253   v2 = value2-&gt;data[0].v_uint;
7254 
7255   m1 = value1-&gt;data[1].v_uint;
7256   m2 = value2-&gt;data[1].v_uint;
7257 
7258   if (v1 == v2 &amp;&amp; m1 == m2)
7259     return GST_VALUE_EQUAL;
7260 
7261   return GST_VALUE_UNORDERED;
7262 }
7263 
7264 /***********************
7265  * GstAllocationParams *
7266  ***********************/
7267 static gint
7268 gst_value_compare_allocation_params (const GValue * value1,
7269     const GValue * value2)
7270 {
7271   GstAllocationParams *v1, *v2;
7272 
7273   v1 = value1-&gt;data[0].v_pointer;
7274   v2 = value2-&gt;data[0].v_pointer;
7275 
7276   if (v1 == NULL &amp;&amp; v1 == v2)
7277     return GST_VALUE_EQUAL;
7278 
7279   if (v1 == NULL || v2 == NULL)
7280     return GST_VALUE_UNORDERED;
7281 
7282   if (v1-&gt;flags == v2-&gt;flags &amp;&amp; v1-&gt;align == v2-&gt;align &amp;&amp;
7283       v1-&gt;prefix == v2-&gt;prefix &amp;&amp; v1-&gt;padding == v2-&gt;padding)
7284     return GST_VALUE_EQUAL;
7285 
7286   return GST_VALUE_UNORDERED;
7287 }
7288 
7289 
7290 /************
7291  * GObject *
7292  ************/
7293 
7294 static gint
7295 gst_value_compare_object (const GValue * value1, const GValue * value2)
7296 {
7297   gpointer v1, v2;
7298 
7299   v1 = value1-&gt;data[0].v_pointer;
7300   v2 = value2-&gt;data[0].v_pointer;
7301 
7302   if (v1 == v2)
7303     return GST_VALUE_EQUAL;
7304 
7305   return GST_VALUE_UNORDERED;
7306 }
7307 
7308 static void
7309 gst_value_transform_object_string (const GValue * src_value,
7310     GValue * dest_value)
7311 {
7312   GstObject *obj;
7313   gchar *str;
7314 
7315   obj = g_value_get_object (src_value);
7316   if (obj) {
7317     str =
7318         g_strdup_printf (&quot;(%s) %s&quot;, G_OBJECT_TYPE_NAME (obj),
7319         GST_OBJECT_NAME (obj));
7320   } else {
7321     str = g_strdup (&quot;NULL&quot;);
7322   }
7323 
7324   dest_value-&gt;data[0].v_pointer = str;
7325 }
7326 
7327 static GTypeInfo _info = {
7328   0, NULL, NULL, NULL, NULL, NULL, 0, 0, NULL, NULL,
7329 };
7330 
7331 static GTypeFundamentalInfo _finfo = {
7332   0
7333 };
7334 
7335 #define FUNC_VALUE_GET_TYPE_CLASSED(type, name, csize, flags)   \
7336 GType _gst_ ## type ## _type = 0;                               \
7337                                                                 \
7338 GType gst_ ## type ## _get_type (void)                          \
7339 {                                                               \
7340   static volatile GType gst_ ## type ## _type = 0;              \
7341                                                                 \
7342   if (g_once_init_enter (&amp;gst_ ## type ## _type)) {             \
7343     GType _type;                                                \
7344     _info.class_size = csize;                                   \
7345     _finfo.type_flags = flags;                                  \
7346     _info.value_table = &amp; _gst_ ## type ## _value_table;        \
7347     _type = g_type_register_fundamental (                       \
7348         g_type_fundamental_next (),                             \
7349         name, &amp;_info, &amp;_finfo, 0);                              \
7350     _gst_ ## type ## _type = _type;                             \
7351     g_once_init_leave(&amp;gst_ ## type ## _type, _type);           \
7352   }                                                             \
7353                                                                 \
7354   return gst_ ## type ## _type;                                 \
7355 }
7356 
7357 #define FUNC_VALUE_GET_TYPE(type, name) \
7358   FUNC_VALUE_GET_TYPE_CLASSED(type, name, 0, 0)
7359 
7360 static const GTypeValueTable _gst_int_range_value_table = {
7361   gst_value_init_int_range,
7362   NULL,
7363   gst_value_copy_int_range,
7364   NULL,
7365   (char *) &quot;ii&quot;,
7366   gst_value_collect_int_range, (char *) &quot;pp&quot;, gst_value_lcopy_int_range
7367 };
7368 
7369 FUNC_VALUE_GET_TYPE (int_range, &quot;GstIntRange&quot;);
7370 
7371 static const GTypeValueTable _gst_int64_range_value_table = {
7372   gst_value_init_int64_range,
7373   gst_value_free_int64_range,
7374   gst_value_copy_int64_range,
7375   NULL,
7376   (char *) &quot;qq&quot;,
7377   gst_value_collect_int64_range,
7378   (char *) &quot;pp&quot;, gst_value_lcopy_int64_range
7379 };
7380 
7381 FUNC_VALUE_GET_TYPE (int64_range, &quot;GstInt64Range&quot;);
7382 
7383 static const GTypeValueTable _gst_double_range_value_table = {
7384   gst_value_init_double_range,
7385   NULL,
7386   gst_value_copy_double_range,
7387   NULL,
7388   (char *) &quot;dd&quot;,
7389   gst_value_collect_double_range,
7390   (char *) &quot;pp&quot;, gst_value_lcopy_double_range
7391 };
7392 
7393 FUNC_VALUE_GET_TYPE (double_range, &quot;GstDoubleRange&quot;);
7394 
7395 static const GTypeValueTable _gst_fraction_range_value_table = {
7396   gst_value_init_fraction_range,
7397   gst_value_free_fraction_range,
7398   gst_value_copy_fraction_range,
7399   NULL,
7400   (char *) &quot;iiii&quot;,
7401   gst_value_collect_fraction_range,
7402   (char *) &quot;pppp&quot;, gst_value_lcopy_fraction_range
7403 };
7404 
7405 FUNC_VALUE_GET_TYPE (fraction_range, &quot;GstFractionRange&quot;);
7406 
7407 static const GTypeValueTable _gst_value_list_value_table = {
7408   gst_value_init_list_or_array,
7409   gst_value_free_list_or_array,
7410   gst_value_copy_list_or_array,
7411   gst_value_list_or_array_peek_pointer,
7412   (char *) &quot;p&quot;,
7413   gst_value_collect_list_or_array,
7414   (char *) &quot;p&quot;, gst_value_lcopy_list_or_array
7415 };
7416 
7417 FUNC_VALUE_GET_TYPE (value_list, &quot;GstValueList&quot;);
7418 
7419 static const GTypeValueTable _gst_value_array_value_table = {
7420   gst_value_init_list_or_array,
7421   gst_value_free_list_or_array,
7422   gst_value_copy_list_or_array,
7423   gst_value_list_or_array_peek_pointer,
7424   (char *) &quot;p&quot;,
7425   gst_value_collect_list_or_array,
7426   (char *) &quot;p&quot;, gst_value_lcopy_list_or_array
7427 };
7428 
7429 FUNC_VALUE_GET_TYPE (value_array, &quot;GstValueArray&quot;);
7430 
7431 static const GTypeValueTable _gst_fraction_value_table = {
7432   gst_value_init_fraction,
7433   NULL,
7434   gst_value_copy_fraction,
7435   NULL,
7436   (char *) &quot;ii&quot;,
7437   gst_value_collect_fraction, (char *) &quot;pp&quot;, gst_value_lcopy_fraction
7438 };
7439 
7440 FUNC_VALUE_GET_TYPE (fraction, &quot;GstFraction&quot;);
7441 
7442 static const GTypeValueTable _gst_bitmask_value_table = {
7443   gst_value_init_bitmask,
7444   NULL,
7445   gst_value_copy_bitmask,
7446   NULL,
7447   (char *) &quot;q&quot;,
7448   gst_value_collect_bitmask, (char *) &quot;p&quot;, gst_value_lcopy_bitmask
7449 };
7450 
7451 FUNC_VALUE_GET_TYPE (bitmask, &quot;GstBitmask&quot;);
7452 
7453 static const GTypeValueTable _gst_flagset_value_table = {
7454   gst_value_init_flagset,
7455   NULL,
7456   gst_value_copy_flagset,
7457   NULL,
7458   (char *) &quot;ii&quot;,
7459   gst_value_collect_flagset, (char *) &quot;pp&quot;, gst_value_lcopy_flagset
7460 };
7461 
7462 FUNC_VALUE_GET_TYPE_CLASSED (flagset, &quot;GstFlagSet&quot;,
7463     sizeof (GstFlagSetClass), G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_DERIVABLE);
7464 
7465 GType
7466 gst_g_thread_get_type (void)
7467 {
7468   return G_TYPE_THREAD;
7469 }
7470 
7471 #define SERIAL_VTABLE(t,c,s,d) { t, c, s, d }
7472 
7473 #define REGISTER_SERIALIZATION_CONST(_gtype, _type)                     \
7474 G_STMT_START {                                                          \
7475   static const GstValueTable gst_value =                                \
7476     SERIAL_VTABLE (_gtype, gst_value_compare_ ## _type,                 \
7477     gst_value_serialize_ ## _type, gst_value_deserialize_ ## _type);    \
7478   gst_value_register (&amp;gst_value);                                      \
7479 } G_STMT_END
7480 
7481 #define REGISTER_SERIALIZATION(_gtype, _type)                           \
7482 G_STMT_START {                                                          \
7483   static GstValueTable gst_value =                                      \
7484     SERIAL_VTABLE (0, gst_value_compare_ ## _type,                      \
7485     gst_value_serialize_ ## _type, gst_value_deserialize_ ## _type);    \
7486   gst_value.type = _gtype;                                              \
7487   gst_value_register (&amp;gst_value);                                      \
7488 } G_STMT_END
7489 
7490 #define REGISTER_SERIALIZATION_NO_COMPARE(_gtype, _type)                \
7491 G_STMT_START {                                                          \
7492   static GstValueTable gst_value =                                      \
7493     SERIAL_VTABLE (0, NULL,                                             \
7494     gst_value_serialize_ ## _type, gst_value_deserialize_ ## _type);    \
7495   gst_value.type = _gtype;                                              \
7496   gst_value_register (&amp;gst_value);                                      \
7497 } G_STMT_END
7498 
7499 #define REGISTER_SERIALIZATION_COMPARE_ONLY(_gtype, _type)              \
7500 G_STMT_START {                                                          \
7501   static GstValueTable gst_value =                                      \
7502     SERIAL_VTABLE (0, gst_value_compare_ ## _type,                      \
7503         NULL, NULL);                                                    \
7504   gst_value.type = _gtype;                                              \
7505   gst_value_register (&amp;gst_value);                                      \
7506 } G_STMT_END
7507 
7508 /* These initial sizes are used for the tables
7509  * below, and save a couple of reallocs at startup */
7510 
7511 static const gint GST_VALUE_TABLE_DEFAULT_SIZE = 40;
7512 static const gint GST_VALUE_UNION_TABLE_DEFAULT_SIZE = 8;
7513 static const gint GST_VALUE_INTERSECT_TABLE_DEFAULT_SIZE = 16;
7514 static const gint GST_VALUE_SUBTRACT_TABLE_DEFAULT_SIZE = 16;
7515 
7516 void
7517 _priv_gst_value_initialize (void)
7518 {
7519   gst_value_table =
7520       g_array_sized_new (FALSE, FALSE, sizeof (GstValueTable),
7521       GST_VALUE_TABLE_DEFAULT_SIZE);
7522   gst_value_hash = g_hash_table_new (NULL, NULL);
7523   gst_value_union_funcs = g_array_sized_new (FALSE, FALSE,
7524       sizeof (GstValueUnionInfo), GST_VALUE_UNION_TABLE_DEFAULT_SIZE);
7525   gst_value_intersect_funcs = g_array_sized_new (FALSE, FALSE,
7526       sizeof (GstValueIntersectInfo), GST_VALUE_INTERSECT_TABLE_DEFAULT_SIZE);
7527   gst_value_subtract_funcs = g_array_sized_new (FALSE, FALSE,
7528       sizeof (GstValueSubtractInfo), GST_VALUE_SUBTRACT_TABLE_DEFAULT_SIZE);
7529 
7530   REGISTER_SERIALIZATION (gst_int_range_get_type (), int_range);
7531   REGISTER_SERIALIZATION (gst_int64_range_get_type (), int64_range);
7532   REGISTER_SERIALIZATION (gst_double_range_get_type (), double_range);
7533   REGISTER_SERIALIZATION (gst_fraction_range_get_type (), fraction_range);
7534   REGISTER_SERIALIZATION (gst_value_list_get_type (), value_list);
7535   REGISTER_SERIALIZATION (gst_value_array_get_type (), value_array);
7536   REGISTER_SERIALIZATION (g_value_array_get_type (), g_value_array);
7537   REGISTER_SERIALIZATION (gst_buffer_get_type (), buffer);
7538   REGISTER_SERIALIZATION (gst_sample_get_type (), sample);
7539   REGISTER_SERIALIZATION (gst_fraction_get_type (), fraction);
7540   REGISTER_SERIALIZATION (gst_caps_get_type (), caps);
7541   REGISTER_SERIALIZATION (gst_tag_list_get_type (), tag_list);
7542   REGISTER_SERIALIZATION (G_TYPE_DATE, date);
7543   REGISTER_SERIALIZATION (gst_date_time_get_type (), date_time);
7544   REGISTER_SERIALIZATION (gst_bitmask_get_type (), bitmask);
7545   REGISTER_SERIALIZATION (gst_structure_get_type (), structure);
<a name="3" id="anc3"></a><span class="line-added">7546 #ifndef GSTREAMER_LITE</span>
7547   REGISTER_SERIALIZATION (gst_flagset_get_type (), flagset);
<a name="4" id="anc4"></a><span class="line-added">7548 #endif // GSTREAMER_LITE</span>
7549 
7550   REGISTER_SERIALIZATION_NO_COMPARE (gst_segment_get_type (), segment);
7551   REGISTER_SERIALIZATION_NO_COMPARE (gst_caps_features_get_type (),
7552       caps_features);
7553 
7554   REGISTER_SERIALIZATION_COMPARE_ONLY (gst_allocation_params_get_type (),
7555       allocation_params);
7556   REGISTER_SERIALIZATION_COMPARE_ONLY (G_TYPE_OBJECT, object);
7557 
7558   REGISTER_SERIALIZATION_CONST (G_TYPE_DOUBLE, double);
7559   REGISTER_SERIALIZATION_CONST (G_TYPE_FLOAT, float);
7560 
7561   REGISTER_SERIALIZATION_CONST (G_TYPE_STRING, string);
7562   REGISTER_SERIALIZATION_CONST (G_TYPE_BOOLEAN, boolean);
7563   REGISTER_SERIALIZATION_CONST (G_TYPE_ENUM, enum);
7564 
7565   REGISTER_SERIALIZATION_CONST (G_TYPE_FLAGS, gflags);
7566 
7567   REGISTER_SERIALIZATION_CONST (G_TYPE_INT, int);
7568 
7569   REGISTER_SERIALIZATION_CONST (G_TYPE_INT64, int64);
7570   REGISTER_SERIALIZATION_CONST (G_TYPE_LONG, long);
7571 
7572   REGISTER_SERIALIZATION_CONST (G_TYPE_UINT, uint);
7573   REGISTER_SERIALIZATION_CONST (G_TYPE_UINT64, uint64);
7574   REGISTER_SERIALIZATION_CONST (G_TYPE_ULONG, ulong);
7575 
7576   REGISTER_SERIALIZATION_CONST (G_TYPE_UCHAR, uchar);
7577 
7578   REGISTER_SERIALIZATION (G_TYPE_GTYPE, gtype);
7579 
7580   g_value_register_transform_func (GST_TYPE_INT_RANGE, G_TYPE_STRING,
7581       gst_value_transform_int_range_string);
7582   g_value_register_transform_func (GST_TYPE_INT64_RANGE, G_TYPE_STRING,
7583       gst_value_transform_int64_range_string);
7584   g_value_register_transform_func (GST_TYPE_DOUBLE_RANGE, G_TYPE_STRING,
7585       gst_value_transform_double_range_string);
7586   g_value_register_transform_func (GST_TYPE_FRACTION_RANGE, G_TYPE_STRING,
7587       gst_value_transform_fraction_range_string);
7588   g_value_register_transform_func (GST_TYPE_LIST, G_TYPE_STRING,
7589       gst_value_transform_list_string);
7590   g_value_register_transform_func (GST_TYPE_LIST, G_TYPE_VALUE_ARRAY,
7591       gst_value_transform_any_list_g_value_array);
7592   g_value_register_transform_func (GST_TYPE_ARRAY, G_TYPE_STRING,
7593       gst_value_transform_array_string);
7594   g_value_register_transform_func (GST_TYPE_ARRAY, G_TYPE_VALUE_ARRAY,
7595       gst_value_transform_any_list_g_value_array);
7596   g_value_register_transform_func (G_TYPE_VALUE_ARRAY, G_TYPE_STRING,
7597       gst_value_transform_g_value_array_string);
7598   g_value_register_transform_func (G_TYPE_VALUE_ARRAY, GST_TYPE_ARRAY,
7599       gst_value_transform_g_value_array_any_list);
7600   g_value_register_transform_func (G_TYPE_VALUE_ARRAY, GST_TYPE_LIST,
7601       gst_value_transform_g_value_array_any_list);
7602   g_value_register_transform_func (GST_TYPE_FRACTION, G_TYPE_STRING,
7603       gst_value_transform_fraction_string);
7604   g_value_register_transform_func (G_TYPE_STRING, GST_TYPE_FRACTION,
7605       gst_value_transform_string_fraction);
7606   g_value_register_transform_func (GST_TYPE_FRACTION, G_TYPE_DOUBLE,
7607       gst_value_transform_fraction_double);
7608   g_value_register_transform_func (GST_TYPE_FRACTION, G_TYPE_FLOAT,
7609       gst_value_transform_fraction_float);
7610   g_value_register_transform_func (G_TYPE_DOUBLE, GST_TYPE_FRACTION,
7611       gst_value_transform_double_fraction);
7612   g_value_register_transform_func (G_TYPE_FLOAT, GST_TYPE_FRACTION,
7613       gst_value_transform_float_fraction);
7614   g_value_register_transform_func (G_TYPE_DATE, G_TYPE_STRING,
7615       gst_value_transform_date_string);
7616   g_value_register_transform_func (G_TYPE_STRING, G_TYPE_DATE,
7617       gst_value_transform_string_date);
7618   g_value_register_transform_func (GST_TYPE_OBJECT, G_TYPE_STRING,
7619       gst_value_transform_object_string);
7620   g_value_register_transform_func (GST_TYPE_BITMASK, G_TYPE_UINT64,
7621       gst_value_transform_bitmask_uint64);
7622   g_value_register_transform_func (GST_TYPE_BITMASK, G_TYPE_STRING,
7623       gst_value_transform_bitmask_string);
7624   g_value_register_transform_func (G_TYPE_UINT64, GST_TYPE_BITMASK,
7625       gst_value_transform_uint64_bitmask);
7626   g_value_register_transform_func (G_TYPE_STRING, GST_TYPE_BITMASK,
7627       gst_value_transform_string_bitmask);
7628 
<a name="5" id="anc5"></a><span class="line-added">7629 #ifndef GSTREAMER_LITE</span>
7630   g_value_register_transform_func (GST_TYPE_FLAG_SET, G_TYPE_STRING,
7631       gst_value_transform_flagset_string);
7632   g_value_register_transform_func (G_TYPE_STRING, GST_TYPE_FLAG_SET,
7633       gst_value_transform_string_flagset);
<a name="6" id="anc6"></a><span class="line-added">7634 #endif // GSTREAMER_LITE</span>
7635 
7636   gst_value_register_intersect_func (G_TYPE_INT, GST_TYPE_INT_RANGE,
7637       gst_value_intersect_int_int_range);
7638   gst_value_register_intersect_func (GST_TYPE_INT_RANGE, GST_TYPE_INT_RANGE,
7639       gst_value_intersect_int_range_int_range);
7640   gst_value_register_intersect_func (G_TYPE_INT64, GST_TYPE_INT64_RANGE,
7641       gst_value_intersect_int64_int64_range);
7642   gst_value_register_intersect_func (GST_TYPE_INT64_RANGE,
7643       GST_TYPE_INT64_RANGE, gst_value_intersect_int64_range_int64_range);
7644   gst_value_register_intersect_func (G_TYPE_DOUBLE, GST_TYPE_DOUBLE_RANGE,
7645       gst_value_intersect_double_double_range);
7646   gst_value_register_intersect_func (GST_TYPE_DOUBLE_RANGE,
7647       GST_TYPE_DOUBLE_RANGE, gst_value_intersect_double_range_double_range);
7648   gst_value_register_intersect_func (GST_TYPE_ARRAY, GST_TYPE_ARRAY,
7649       gst_value_intersect_array);
7650   gst_value_register_intersect_func (GST_TYPE_FRACTION,
7651       GST_TYPE_FRACTION_RANGE, gst_value_intersect_fraction_fraction_range);
7652   gst_value_register_intersect_func (GST_TYPE_FRACTION_RANGE,
7653       GST_TYPE_FRACTION_RANGE,
7654       gst_value_intersect_fraction_range_fraction_range);
7655   gst_value_register_intersect_func (GST_TYPE_FLAG_SET, GST_TYPE_FLAG_SET,
7656       gst_value_intersect_flagset_flagset);
7657   gst_value_register_intersect_func (GST_TYPE_STRUCTURE, GST_TYPE_STRUCTURE,
7658       gst_value_intersect_structure_structure);
7659 
7660   gst_value_register_subtract_func (G_TYPE_INT, GST_TYPE_INT_RANGE,
7661       gst_value_subtract_int_int_range);
7662   gst_value_register_subtract_func (GST_TYPE_INT_RANGE, G_TYPE_INT,
7663       gst_value_subtract_int_range_int);
7664   gst_value_register_subtract_func (GST_TYPE_INT_RANGE, GST_TYPE_INT_RANGE,
7665       gst_value_subtract_int_range_int_range);
7666   gst_value_register_subtract_func (G_TYPE_INT64, GST_TYPE_INT64_RANGE,
7667       gst_value_subtract_int64_int64_range);
7668   gst_value_register_subtract_func (GST_TYPE_INT64_RANGE, G_TYPE_INT64,
7669       gst_value_subtract_int64_range_int64);
7670   gst_value_register_subtract_func (GST_TYPE_INT64_RANGE,
7671       GST_TYPE_INT64_RANGE, gst_value_subtract_int64_range_int64_range);
7672   gst_value_register_subtract_func (G_TYPE_DOUBLE, GST_TYPE_DOUBLE_RANGE,
7673       gst_value_subtract_double_double_range);
7674   gst_value_register_subtract_func (GST_TYPE_DOUBLE_RANGE, G_TYPE_DOUBLE,
7675       gst_value_subtract_double_range_double);
7676   gst_value_register_subtract_func (GST_TYPE_DOUBLE_RANGE,
7677       GST_TYPE_DOUBLE_RANGE, gst_value_subtract_double_range_double_range);
7678   gst_value_register_subtract_func (GST_TYPE_FRACTION,
7679       GST_TYPE_FRACTION_RANGE, gst_value_subtract_fraction_fraction_range);
7680   gst_value_register_subtract_func (GST_TYPE_FRACTION_RANGE,
7681       GST_TYPE_FRACTION, gst_value_subtract_fraction_range_fraction);
7682   gst_value_register_subtract_func (GST_TYPE_FRACTION_RANGE,
7683       GST_TYPE_FRACTION_RANGE,
7684       gst_value_subtract_fraction_range_fraction_range);
7685 
7686   /* see bug #317246, #64994, #65041 */
7687   {
7688     volatile GType date_type = G_TYPE_DATE;
7689 
7690     g_type_name (date_type);
7691   }
7692 
7693   gst_value_register_union_func (G_TYPE_INT, GST_TYPE_INT_RANGE,
7694       gst_value_union_int_int_range);
7695   gst_value_register_union_func (GST_TYPE_INT_RANGE, GST_TYPE_INT_RANGE,
7696       gst_value_union_int_range_int_range);
7697   gst_value_register_union_func (GST_TYPE_FLAG_SET, GST_TYPE_FLAG_SET,
7698       gst_value_union_flagset_flagset);
7699   gst_value_register_union_func (GST_TYPE_STRUCTURE, GST_TYPE_STRUCTURE,
7700       gst_value_union_structure_structure);
7701 
7702 #if GST_VERSION_NANO == 1
7703   /* If building from git master, check starting array sizes matched actual size
7704    * so we can keep the defines in sync and save a few reallocs on startup */
7705   if (gst_value_table-&gt;len &gt; GST_VALUE_TABLE_DEFAULT_SIZE) {
7706     GST_ERROR (&quot;Wrong initial gst_value_table size. &quot;
7707         &quot;Please set GST_VALUE_TABLE_DEFAULT_SIZE to %u in gstvalue.c&quot;,
7708         gst_value_table-&gt;len);
7709   }
7710   if (gst_value_union_funcs-&gt;len &gt; GST_VALUE_UNION_TABLE_DEFAULT_SIZE) {
7711     GST_ERROR (&quot;Wrong initial gst_value_union_funcs table size. &quot;
7712         &quot;Please set GST_VALUE_UNION_TABLE_DEFAULT_SIZE to %u in gstvalue.c&quot;,
7713         gst_value_union_funcs-&gt;len);
7714   }
7715   if (gst_value_intersect_funcs-&gt;len &gt; GST_VALUE_INTERSECT_TABLE_DEFAULT_SIZE) {
7716     GST_ERROR (&quot;Wrong initial gst_value_intersect_funcs table size. &quot;
7717         &quot;Please set GST_VALUE_INTERSECT_TABLE_DEFAULT_SIZE to %u in gstvalue.c&quot;,
7718         gst_value_intersect_funcs-&gt;len);
7719   }
7720   if (gst_value_subtract_funcs-&gt;len &gt; GST_VALUE_SUBTRACT_TABLE_DEFAULT_SIZE) {
7721     GST_ERROR (&quot;Wrong initial gst_value_subtract_funcs table size. &quot;
7722         &quot;Please set GST_VALUE_SUBTRACT_TABLE_DEFAULT_SIZE to %u in gstvalue.c&quot;,
7723         gst_value_subtract_funcs-&gt;len);
7724   }
7725 #endif
7726 
7727 #if 0
7728   /* Implement these if needed */
7729   gst_value_register_union_func (GST_TYPE_FRACTION, GST_TYPE_FRACTION_RANGE,
7730       gst_value_union_fraction_fraction_range);
7731   gst_value_register_union_func (GST_TYPE_FRACTION_RANGE,
7732       GST_TYPE_FRACTION_RANGE, gst_value_union_fraction_range_fraction_range);
7733 #endif
7734 }
7735 
7736 static void
7737 gst_flagset_class_init (gpointer g_class, gpointer class_data)
7738 {
7739   GstFlagSetClass *f_class = (GstFlagSetClass *) (g_class);
7740   f_class-&gt;flags_type = (GType) GPOINTER_TO_SIZE (class_data);
7741 }
7742 
7743 /**
7744  * gst_flagset_register:
7745  * @flags_type: a #GType of a #G_TYPE_FLAGS type.
7746  *
7747  * Create a new sub-class of #GST_TYPE_FLAG_SET
7748  * which will pretty-print the human-readable flags
7749  * when serializing, for easier debugging.
7750  *
7751  * Since: 1.6
7752  */
7753 GType
7754 gst_flagset_register (GType flags_type)
7755 {
7756   GTypeInfo info = {
7757     sizeof (GstFlagSetClass),
7758     NULL, NULL,
7759     (GClassInitFunc) gst_flagset_class_init,
7760     NULL, GSIZE_TO_POINTER (flags_type), 0, 0, NULL, NULL
7761   };
7762   GType t;
7763   gchar *class_name;
7764 
7765   g_return_val_if_fail (G_TYPE_IS_FLAGS (flags_type), 0);
7766 
7767   class_name = g_strdup_printf (&quot;%sSet&quot;, g_type_name (flags_type));
7768 
7769   t = g_type_register_static (GST_TYPE_FLAG_SET,
7770       g_intern_string (class_name), &amp;info, 0);
7771   g_free (class_name);
7772 
7773   return t;
7774 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/pcre/pcre_xclass.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*************************************************
  2 *      Perl-Compatible Regular Expressions       *
  3 *************************************************/
  4 
  5 /* PCRE is a library of functions to support regular expressions whose syntax
  6 and semantics are as close as possible to those of the Perl 5 language.
  7 
  8                        Written by Philip Hazel
  9            Copyright (c) 1997-2012 University of Cambridge
 10 
 11 -----------------------------------------------------------------------------
 12 Redistribution and use in source and binary forms, with or without
 13 modification, are permitted provided that the following conditions are met:
 14 
 15     * Redistributions of source code must retain the above copyright notice,
 16       this list of conditions and the following disclaimer.
 17 
 18     * Redistributions in binary form must reproduce the above copyright
 19       notice, this list of conditions and the following disclaimer in the
 20       documentation and/or other materials provided with the distribution.
 21 
 22     * Neither the name of the University of Cambridge nor the names of its
 23       contributors may be used to endorse or promote products derived from
 24       this software without specific prior written permission.
 25 
 26 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 27 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 28 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 29 ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 30 LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 31 CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 32 SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 33 INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 34 CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 35 ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 36 POSSIBILITY OF SUCH DAMAGE.
 37 -----------------------------------------------------------------------------
 38 */
 39 
 40 
 41 /* This module contains an internal function that is used to match an extended
 42 class. It is used by both pcre_exec() and pcre_def_exec(). */
 43 
 44 
 45 #include &quot;config.h&quot;
 46 
 47 #include &quot;pcre_internal.h&quot;
 48 
 49 
 50 /*************************************************
 51 *       Match character against an XCLASS        *
 52 *************************************************/
 53 
 54 /* This function is called to match a character against an extended class that
 55 might contain values &gt; 255 and/or Unicode properties.
 56 
 57 Arguments:
 58   c           the character
 59   data        points to the flag byte of the XCLASS data
 60 
 61 Returns:      TRUE if character matches, else FALSE
 62 */
 63 
 64 BOOL
 65 PRIV(xclass)(int c, const pcre_uchar *data, BOOL utf)
 66 {
 67 int t;
 68 BOOL negated = (*data &amp; XCL_NOT) != 0;
 69 
 70 (void)utf;
 71 #ifdef COMPILE_PCRE8
 72 /* In 8 bit mode, this must always be TRUE. Help the compiler to know that. */
 73 utf = TRUE;
 74 #endif
 75 
 76 /* Character values &lt; 256 are matched against a bitmap, if one is present. If
 77 not, we still carry on, because there may be ranges that start below 256 in the
 78 additional data. */
 79 
 80 if (c &lt; 256)
 81   {
 82   if ((*data &amp; XCL_MAP) != 0 &amp;&amp;
 83     (((pcre_uint8 *)(data + 1))[c/8] &amp; (1 &lt;&lt; (c&amp;7))) != 0)
 84     return !negated; /* char found */
 85   }
 86 
 87 /* First skip the bit map if present. Then match against the list of Unicode
 88 properties or large chars or ranges that end with a large char. We won&#39;t ever
 89 encounter XCL_PROP or XCL_NOTPROP when UCP support is not compiled. */
 90 
 91 if ((*data++ &amp; XCL_MAP) != 0) data += 32 / sizeof(pcre_uchar);
 92 
 93 while ((t = *data++) != XCL_END)
 94   {
 95   int x, y;
 96   if (t == XCL_SINGLE)
 97     {
 98 #ifdef SUPPORT_UTF
 99     if (utf)
100       {
101       GETCHARINC(x, data); /* macro generates multiple statements */
102       }
103     else
104 #endif
105       x = *data++;
106     if (c == x) return !negated;
107     }
108   else if (t == XCL_RANGE)
109     {
110 #ifdef SUPPORT_UTF
111     if (utf)
112       {
113       GETCHARINC(x, data); /* macro generates multiple statements */
114       GETCHARINC(y, data); /* macro generates multiple statements */
115       }
116     else
117 #endif
118       {
119       x = *data++;
120       y = *data++;
121       }
122     if (c &gt;= x &amp;&amp; c &lt;= y) return !negated;
123     }
124 
125 #ifdef SUPPORT_UCP
126   else  /* XCL_PROP &amp; XCL_NOTPROP */
127     {
128     const pcre_uint8 chartype = UCD_CHARTYPE(c);
129 
130     switch(*data)
131       {
132       case PT_ANY:
133       if (t == XCL_PROP) return !negated;
134       break;
135 
136       case PT_LAMP:
137       if ((chartype == ucp_Lu || chartype == ucp_Ll ||
138            chartype == ucp_Lt) == (t == XCL_PROP)) return !negated;
139       break;
140 
141       case PT_GC:
142       if ((data[1] == PRIV(ucp_gentype)[chartype]) == (t == XCL_PROP))
143         return !negated;
144       break;
145 
146       case PT_PC:
147       if ((data[1] == chartype) == (t == XCL_PROP)) return !negated;
148       break;
149 
150       case PT_SC:
151       if ((data[1] == UCD_SCRIPT(c)) == (t == XCL_PROP)) return !negated;
152       break;
153 
154       case PT_ALNUM:
155       if ((PRIV(ucp_gentype)[chartype] == ucp_L ||
156            PRIV(ucp_gentype)[chartype] == ucp_N) == (t == XCL_PROP))
157         return !negated;
158       break;
159 
160       case PT_SPACE:    /* Perl space */
161       if ((PRIV(ucp_gentype)[chartype] == ucp_Z ||
162            c == CHAR_HT || c == CHAR_NL || c == CHAR_FF || c == CHAR_CR)
163              == (t == XCL_PROP))
164         return !negated;
165       break;
166 
167       case PT_PXSPACE:  /* POSIX space */
168       if ((PRIV(ucp_gentype)[chartype] == ucp_Z ||
169            c == CHAR_HT || c == CHAR_NL || c == CHAR_VT ||
170            c == CHAR_FF || c == CHAR_CR) == (t == XCL_PROP))
171         return !negated;
172       break;
173 
174       case PT_WORD:
175       if ((PRIV(ucp_gentype)[chartype] == ucp_L ||
176            PRIV(ucp_gentype)[chartype] == ucp_N || c == CHAR_UNDERSCORE)
177              == (t == XCL_PROP))
178         return !negated;
179       break;
180 
181       /* This should never occur, but compilers may mutter if there is no
182       default. */
183 
184       default:
185       return FALSE;
186       }
187 
188     data += 2;
189     }
190 #endif  /* SUPPORT_UCP */
191   }
192 
193 return negated;   /* char did not match */
194 }
195 
196 /* End of pcre_xclass.c */
    </pre>
  </body>
</html>
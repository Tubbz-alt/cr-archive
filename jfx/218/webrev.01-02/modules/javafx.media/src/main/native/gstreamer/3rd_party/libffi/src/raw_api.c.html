<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/libffi/src/raw_api.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /* -----------------------------------------------------------------------
  2    raw_api.c - Copyright (c) 1999, 2008  Red Hat, Inc.
  3 
  4    Author: Kresten Krab Thorup &lt;krab@gnu.org&gt;
  5 
  6    Permission is hereby granted, free of charge, to any person obtaining
  7    a copy of this software and associated documentation files (the
  8    ``Software&#39;&#39;), to deal in the Software without restriction, including
  9    without limitation the rights to use, copy, modify, merge, publish,
 10    distribute, sublicense, and/or sell copies of the Software, and to
 11    permit persons to whom the Software is furnished to do so, subject to
 12    the following conditions:
 13 
 14    The above copyright notice and this permission notice shall be included
 15    in all copies or substantial portions of the Software.
 16 
 17    THE SOFTWARE IS PROVIDED ``AS IS&#39;&#39;, WITHOUT WARRANTY OF ANY KIND,
 18    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 19    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 20    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 21    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 22    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 23    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 24    DEALINGS IN THE SOFTWARE.
 25    ----------------------------------------------------------------------- */
 26 
 27 /* This file defines generic functions for use with the raw api. */
 28 
 29 #include &lt;ffi.h&gt;
 30 #include &lt;ffi_common.h&gt;
 31 
 32 #ifdef GSTREAMER_LITE
 33 #include &lt;string.h&gt;
 34 #endif // GSTREAMER_LITE
 35 
 36 #if !FFI_NO_RAW_API
 37 
 38 size_t
 39 ffi_raw_size (ffi_cif *cif)
 40 {
 41   size_t result = 0;
 42   int i;
 43 
 44   ffi_type **at = cif-&gt;arg_types;
 45 
 46   for (i = cif-&gt;nargs-1; i &gt;= 0; i--, at++)
 47     {
 48 #if !FFI_NO_STRUCTS
 49       if ((*at)-&gt;type == FFI_TYPE_STRUCT)
 50     result += FFI_ALIGN (sizeof (void*), FFI_SIZEOF_ARG);
 51       else
 52 #endif
 53     result += FFI_ALIGN ((*at)-&gt;size, FFI_SIZEOF_ARG);
 54     }
 55 
 56   return result;
 57 }
 58 
 59 
 60 void
 61 ffi_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args)
 62 {
 63   unsigned i;
 64   ffi_type **tp = cif-&gt;arg_types;
 65 
 66 #if WORDS_BIGENDIAN
 67 
 68   for (i = 0; i &lt; cif-&gt;nargs; i++, tp++, args++)
 69     {
 70       switch ((*tp)-&gt;type)
 71     {
 72     case FFI_TYPE_UINT8:
 73     case FFI_TYPE_SINT8:
 74       *args = (void*) ((char*)(raw++) + FFI_SIZEOF_ARG - 1);
 75       break;
 76 
 77     case FFI_TYPE_UINT16:
 78     case FFI_TYPE_SINT16:
 79       *args = (void*) ((char*)(raw++) + FFI_SIZEOF_ARG - 2);
 80       break;
 81 
 82 #if FFI_SIZEOF_ARG &gt;= 4
 83     case FFI_TYPE_UINT32:
 84     case FFI_TYPE_SINT32:
 85       *args = (void*) ((char*)(raw++) + FFI_SIZEOF_ARG - 4);
 86       break;
 87 #endif
 88 
 89 #if !FFI_NO_STRUCTS
 90     case FFI_TYPE_STRUCT:
 91       *args = (raw++)-&gt;ptr;
 92       break;
 93 #endif
 94 
 95     case FFI_TYPE_COMPLEX:
 96       *args = (raw++)-&gt;ptr;
 97       break;
 98 
 99     case FFI_TYPE_POINTER:
100       *args = (void*) &amp;(raw++)-&gt;ptr;
101       break;
102 
103     default:
104       *args = raw;
105       raw += FFI_ALIGN ((*tp)-&gt;size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;
106     }
107     }
108 
109 #else /* WORDS_BIGENDIAN */
110 
111 #if !PDP
112 
113   /* then assume little endian */
114   for (i = 0; i &lt; cif-&gt;nargs; i++, tp++, args++)
115     {
116 #if !FFI_NO_STRUCTS
117       if ((*tp)-&gt;type == FFI_TYPE_STRUCT)
118     {
119       *args = (raw++)-&gt;ptr;
120     }
121       else
122 #endif
123       if ((*tp)-&gt;type == FFI_TYPE_COMPLEX)
124     {
125       *args = (raw++)-&gt;ptr;
126     }
127       else
128     {
129       *args = (void*) raw;
130       raw += FFI_ALIGN ((*tp)-&gt;size, sizeof (void*)) / sizeof (void*);
131     }
132     }
133 
134 #else
135 #error &quot;pdp endian not supported&quot;
136 #endif /* ! PDP */
137 
138 #endif /* WORDS_BIGENDIAN */
139 }
140 
141 void
142 ffi_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw)
143 {
144   unsigned i;
145   ffi_type **tp = cif-&gt;arg_types;
146 
147   for (i = 0; i &lt; cif-&gt;nargs; i++, tp++, args++)
148     {
149       switch ((*tp)-&gt;type)
150     {
151     case FFI_TYPE_UINT8:
152       (raw++)-&gt;uint = *(UINT8*) (*args);
153       break;
154 
155     case FFI_TYPE_SINT8:
156       (raw++)-&gt;sint = *(SINT8*) (*args);
157       break;
158 
159     case FFI_TYPE_UINT16:
160       (raw++)-&gt;uint = *(UINT16*) (*args);
161       break;
162 
163     case FFI_TYPE_SINT16:
164       (raw++)-&gt;sint = *(SINT16*) (*args);
165       break;
166 
167 #if FFI_SIZEOF_ARG &gt;= 4
168     case FFI_TYPE_UINT32:
169       (raw++)-&gt;uint = *(UINT32*) (*args);
170       break;
171 
172     case FFI_TYPE_SINT32:
173       (raw++)-&gt;sint = *(SINT32*) (*args);
174       break;
175 #endif
176 
177 #if !FFI_NO_STRUCTS
178     case FFI_TYPE_STRUCT:
179       (raw++)-&gt;ptr = *args;
180       break;
181 #endif
182 
183     case FFI_TYPE_COMPLEX:
184       (raw++)-&gt;ptr = *args;
185       break;
186 
187     case FFI_TYPE_POINTER:
188       (raw++)-&gt;ptr = **(void***) args;
189       break;
190 
191     default:
192       memcpy ((void*) raw-&gt;data, (void*)*args, (*tp)-&gt;size);
193       raw += FFI_ALIGN ((*tp)-&gt;size, FFI_SIZEOF_ARG) / FFI_SIZEOF_ARG;
194     }
195     }
196 }
197 
198 #if !FFI_NATIVE_RAW_API
199 
200 
201 /* This is a generic definition of ffi_raw_call, to be used if the
202  * native system does not provide a machine-specific implementation.
203  * Having this, allows code to be written for the raw API, without
204  * the need for system-specific code to handle input in that format;
205  * these following couple of functions will handle the translation forth
206  * and back automatically. */
207 
208 void ffi_raw_call (ffi_cif *cif, void (*fn)(void), void *rvalue, ffi_raw *raw)
209 {
210   void **avalue = (void**) alloca (cif-&gt;nargs * sizeof (void*));
211   ffi_raw_to_ptrarray (cif, raw, avalue);
212   ffi_call (cif, fn, rvalue, avalue);
213 }
214 
215 #if FFI_CLOSURES        /* base system provides closures */
216 
217 static void
218 ffi_translate_args (ffi_cif *cif, void *rvalue,
219             void **avalue, void *user_data)
220 {
221   ffi_raw *raw = (ffi_raw*)alloca (ffi_raw_size (cif));
222   ffi_raw_closure *cl = (ffi_raw_closure*)user_data;
223 
224   ffi_ptrarray_to_raw (cif, avalue, raw);
225   (*cl-&gt;fun) (cif, rvalue, raw, cl-&gt;user_data);
226 }
227 
228 ffi_status
229 ffi_prep_raw_closure_loc (ffi_raw_closure* cl,
230               ffi_cif *cif,
231               void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
232               void *user_data,
233               void *codeloc)
234 {
235   ffi_status status;
236 
237   status = ffi_prep_closure_loc ((ffi_closure*) cl,
238                  cif,
239                  &amp;ffi_translate_args,
240                  codeloc,
241                  codeloc);
242   if (status == FFI_OK)
243     {
244       cl-&gt;fun       = fun;
245       cl-&gt;user_data = user_data;
246     }
247 
248   return status;
249 }
250 
251 #endif /* FFI_CLOSURES */
252 #endif /* !FFI_NATIVE_RAW_API */
253 
254 #if FFI_CLOSURES
255 
256 /* Again, here is the generic version of ffi_prep_raw_closure, which
257  * will install an intermediate &quot;hub&quot; for translation of arguments from
258  * the pointer-array format, to the raw format */
259 
260 ffi_status
261 ffi_prep_raw_closure (ffi_raw_closure* cl,
262               ffi_cif *cif,
263               void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
264               void *user_data)
265 {
266   return ffi_prep_raw_closure_loc (cl, cif, fun, user_data, cl);
267 }
268 
269 #endif /* FFI_CLOSURES */
270 
271 #endif /* !FFI_NO_RAW_API */
    </pre>
  </body>
</html>
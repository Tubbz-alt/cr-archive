diff a/modules/javafx.graphics/src/main/native-prism/NativePiscesRasterizer.c b/modules/javafx.graphics/src/main/native-prism/NativePiscesRasterizer.c
--- a/modules/javafx.graphics/src/main/native-prism/NativePiscesRasterizer.c
+++ b/modules/javafx.graphics/src/main/native-prism/NativePiscesRasterizer.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -43,10 +43,11 @@
 #define SEG_CUBICTO  SEG(CUBICTO)
 #define SEG_CLOSE    SEG(CLOSE)
 
 #define NPException    "java/lang/NullPointerException"
 #define AIOOBException "java/lang/ArrayIndexOutOfBoundsException"
+#define OOMError       "java/lang/OutOfMemoryError"
 #define IError         "java/lang/InternalError"
 
 #define CheckNPE(env, a)                                \
     do {                                                \
         if (a == NULL) {                                \
@@ -69,15 +70,29 @@
     if (throw_class != NULL) {
         (*env)->ThrowNew(env, throw_class, detail);
     }
 }
 
+static char * errorToString(jint errorCode) {
+    switch (errorCode) {
+        case ERROR_NONE:
+            return NULL;
+        case ERROR_OOM:
+            return "Out of Memory";
+        case ERROR_AIOOBE:
+            return "[PathConsumer";
+        default:
+            return "Unknown error";
+    }
+}
+
 static char * feedConsumer
     (JNIEnv *env, PathConsumer *consumer,
      jfloatArray coordsArray, jint coordSize,
      jbyteArray commandsArray, jint numCommands)
 {
+    jint status = ERROR_NONE;
     char *failure = NULL;
     jfloat *coords;
 
     coords = (*env)->GetPrimitiveArrayCritical(env, coordsArray, 0);
     if (coords == NULL) {
@@ -92,58 +107,76 @@
                 switch (commands[cmdoff]) {
                     case SEG_MOVETO:
                         if (coordoff + 2 > coordSize) {
                             failure = "[not enough coordinates for moveTo";
                         } else {
-                            consumer->moveTo(consumer,
+                            status = consumer->moveTo(consumer,
                                              coords[coordoff+0], coords[coordoff+1]);
+                            if (status != ERROR_NONE) {
+                                failure = errorToString(status);
+                            }
                             coordoff += 2;
                         }
                         break;
                     case SEG_LINETO:
                         if (coordoff + 2 > coordSize) {
                             failure = "[not enough coordinates for lineTo";
                         } else {
-                            consumer->lineTo(consumer,
+                            status = consumer->lineTo(consumer,
                                              coords[coordoff+0], coords[coordoff+1]);
+                            if (status != ERROR_NONE) {
+                                failure = errorToString(status);
+                            }
                             coordoff += 2;
                         }
                         break;
                     case SEG_QUADTO:
                         if (coordoff + 4 > coordSize) {
                             failure = "[not enough coordinates for quadTo";
                         } else {
-                            consumer->quadTo(consumer,
+                            status = consumer->quadTo(consumer,
                                              coords[coordoff+0], coords[coordoff+1],
                                              coords[coordoff+2], coords[coordoff+3]);
+                            if (status != ERROR_NONE) {
+                                failure = errorToString(status);
+                            }
                             coordoff += 4;
                         }
                         break;
                     case SEG_CUBICTO:
                         if (coordoff + 6 > coordSize) {
                             failure = "[not enough coordinates for curveTo";
                         } else {
-                            consumer->curveTo(consumer,
+                            status = consumer->curveTo(consumer,
                                               coords[coordoff+0], coords[coordoff+1],
                                               coords[coordoff+2], coords[coordoff+3],
                                               coords[coordoff+4], coords[coordoff+5]);
+                            if (status != ERROR_NONE) {
+                                failure = errorToString(status);
+                            }
                             coordoff += 6;
                         }
                         break;
                     case SEG_CLOSE:
-                        consumer->closePath(consumer);
+                        status = consumer->closePath(consumer);
+                        if (status != ERROR_NONE) {
+                            failure = errorToString(status);
+                        }
                         break;
                     default:
                         failure = "unrecognized Path segment";
                         break;
                 }
             }
             (*env)->ReleasePrimitiveArrayCritical(env, commandsArray, commands, JNI_ABORT);
         }
         (*env)->ReleasePrimitiveArrayCritical(env, coordsArray, coords, JNI_ABORT);
         if (failure == NULL) {
-            consumer->pathDone(consumer);
+            status = consumer->pathDone(consumer);
+            if (status != ERROR_NONE) {
+                failure = errorToString(status);
+            }
         }
     }
     return failure;
 }
 
@@ -209,11 +242,18 @@
             if ((*env)->GetArrayLength(env, maskArray) / ac.width < ac.height) {
                 Throw(env, AIOOBException, "maskArray");
             } else {
                 ac.alphas = (*env)->GetPrimitiveArrayCritical(env, maskArray, 0);
                 if (ac.alphas != NULL) {
-                    Renderer_produceAlphas(&renderer, &ac);
+                    jint status;
+                    if ((status = Renderer_produceAlphas(&renderer, &ac)) != ERROR_NONE) {
+                        if (status == ERROR_OOM) {
+                            Throw(env, OOMError, "produceAlphas");
+                        } else {
+                            Throw(env, AIOOBException, "produceAlphas");
+                        }
+                    }
                     (*env)->ReleasePrimitiveArrayCritical(env, maskArray, ac.alphas, 0);
                 }
             }
         }
     } else if (*failure != 0) {
@@ -298,11 +338,18 @@
             if ((*env)->GetArrayLength(env, maskArray) / ac.width < ac.height) {
                 Throw(env, AIOOBException, "Mask");
             } else {
                 ac.alphas = (*env)->GetPrimitiveArrayCritical(env, maskArray, 0);
                 if (ac.alphas != NULL) {
-                    Renderer_produceAlphas(&renderer, &ac);
+                    jint status;
+                    if ((status = Renderer_produceAlphas(&renderer, &ac)) != ERROR_NONE) {
+                        if (status == ERROR_OOM) {
+                            Throw(env, OOMError, "produceAlphas");
+                        } else {
+                            Throw(env, AIOOBException, "produceAlphas");
+                        }
+                    }
                     (*env)->ReleasePrimitiveArrayCritical(env, maskArray, ac.alphas, 0);
                 }
             }
         }
     } else if (*failure != 0) {

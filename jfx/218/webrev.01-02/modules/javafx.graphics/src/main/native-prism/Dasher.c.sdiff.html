<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/native-prism/Dasher.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../native-prism-es2/ios/ios-window-system.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="NativePiscesRasterizer.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/native-prism/Dasher.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2014, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
145                 sidx = (sidx + 1) % ndashes;
146                 this.dashOn = !this.dashOn;
147             }
148         }
149     }
150 
151     this.dash = dash;
152     this.numdashes = ndashes;
153     this.startPhase = this.phase = phase;
154     this.startDashOn = this.dashOn;
155     this.startIdx = sidx;
156     this.starting = JNI_TRUE;
157 }
158 
159 void Dasher_destroy(Dasher *pDasher) {
160     free(pDasher-&gt;firstSegmentsBuffer);
161     pDasher-&gt;firstSegmentsBuffer = NULL;
162     pDasher-&gt;firstSegmentsBufferSIZE = 0;
163 }
164 
<span class="line-modified">165 static void emitSeg(PathConsumer *pDasher, jfloat buf[], jint off, jint type) {</span>
166     switch (type) {
167     case 8:
<span class="line-modified">168         this.out-&gt;curveTo(this.out,</span>
169                           buf[off+0], buf[off+1],
170                           buf[off+2], buf[off+3],
171                           buf[off+4], buf[off+5]);
172         break;
173     case 6:
<span class="line-modified">174         this.out-&gt;quadTo(this.out,</span>
175                          buf[off+0], buf[off+1],
176                          buf[off+2], buf[off+3]);
177         break;
178     case 4:
<span class="line-modified">179         this.out-&gt;lineTo(this.out, buf[off], buf[off+1]);</span>
180     }

181 }
182 
<span class="line-modified">183 static void emitFirstSegments(PathConsumer *pDasher) {</span>
184     jint i;
185     for (i = 0; i &lt; this.firstSegidx; ) {
<span class="line-modified">186         emitSeg(pDasher, this.firstSegmentsBuffer, i+1, (jint) this.firstSegmentsBuffer[i]);</span>




187         i += (((jint) this.firstSegmentsBuffer[i]) - 1);
188     }
189     this.firstSegidx = 0;

190 }
191 
192 // precondition: pts must be in relative coordinates (relative to x0,y0)
193 // fullCurve is true iff the curve in pts has not been split.
<span class="line-modified">194 static void goTo(PathConsumer *pDasher, jfloat pts[], jint off, jint type) {</span>

195     jfloat x = pts[off + type - 4];
196     jfloat y = pts[off + type - 3];
197     if (this.dashOn) {
198         if (this.starting) {
199             if (this.firstSegmentsBufferSIZE &lt; this.firstSegidx + (type-1)) {
200                 jint newSize = (this.firstSegidx + (type-1)) * 2;
201                 jfloat *newSegs = new_float(newSize);



202                 System_arraycopy(this.firstSegmentsBuffer, 0, newSegs, 0, this.firstSegidx);
203                 free(this.firstSegmentsBuffer);
204                 this.firstSegmentsBuffer = newSegs;
205                 this.firstSegmentsBufferSIZE = newSize;
206             }
207             this.firstSegmentsBuffer[this.firstSegidx++] = (jfloat) type;
208             System_arraycopy(pts, off, this.firstSegmentsBuffer, this.firstSegidx, type - 2);
209             this.firstSegidx += type - 2;
210         } else {
211             if (this.needsMoveTo) {
<span class="line-modified">212                 this.out-&gt;moveTo(this.out, this.x0, this.y0);</span>



213                 this.needsMoveTo = JNI_FALSE;
214             }
<span class="line-modified">215             emitSeg(pDasher, pts, off, type);</span>



216         }
217     } else {
218         this.starting = JNI_FALSE;
219         this.needsMoveTo = JNI_TRUE;
220     }
221     this.x0 = x;
222     this.y0 = y;

223 }
224 
<span class="line-modified">225 static void Dasher_MoveTo(PathConsumer *pDasher, jfloat newx0, jfloat newy0) {</span>

226     if (this.firstSegidx &gt; 0) {
<span class="line-modified">227         this.out-&gt;moveTo(this.out, this.sx, this.sy);</span>
<span class="line-modified">228         emitFirstSegments(pDasher);</span>






229     }
230     this.needsMoveTo = JNI_TRUE;
231     this.idx = this.startIdx;
232     this.dashOn = this.startDashOn;
233     this.phase = this.startPhase;
234     this.sx = this.x0 = newx0;
235     this.sy = this.y0 = newy0;
236     this.starting = JNI_TRUE;

237 }
238 
<span class="line-modified">239 static void Dasher_LineTo(PathConsumer *pDasher, jfloat x1, jfloat y1) {</span>

240     jfloat cx, cy;
241     jfloat dx = x1 - this.x0;
242     jfloat dy = y1 - this.y0;
243 
244     jfloat len = (jfloat) sqrt(dx*dx + dy*dy);
245 
246     if (len == 0) {
<span class="line-modified">247         return;</span>
248     }
249 
250     // The scaling factors needed to get the dx and dy of the
251     // transformed dash segments.
252     cx = dx / len;
253     cy = dy / len;
254 
255     while (1) {
256         jfloat dashdx, dashdy;
257         jfloat leftInThisDashSegment = this.dash[this.idx] - this.phase;
258         if (len &lt;= leftInThisDashSegment) {
259             this.curCurvepts[0] = x1;
260             this.curCurvepts[1] = y1;
<span class="line-modified">261             goTo(pDasher, this.curCurvepts, 0, 4);</span>



262             // Advance phase within current dash segment
263             this.phase += len;
264             if (len == leftInThisDashSegment) {
265                 this.phase = 0.0f;
266                 this.idx = (this.idx + 1) % this.numdashes;
267                 this.dashOn = !this.dashOn;
268             }
<span class="line-modified">269             return;</span>
270         }
271 
272         dashdx = this.dash[this.idx] * cx;
273         dashdy = this.dash[this.idx] * cy;
274         if (this.phase == 0) {
275             this.curCurvepts[0] = this.x0 + dashdx;
276             this.curCurvepts[1] = this.y0 + dashdy;
277         } else {
278             jfloat p = leftInThisDashSegment / this.dash[this.idx];
279             this.curCurvepts[0] = this.x0 + p * dashdx;
280             this.curCurvepts[1] = this.y0 + p * dashdy;
281         }
282 
<span class="line-modified">283         goTo(pDasher, this.curCurvepts, 0, 4);</span>



284 
285         len -= leftInThisDashSegment;
286         // Advance to next dash segment
287         this.idx = (this.idx + 1) % this.numdashes;
288         this.dashOn = !this.dashOn;
289         this.phase = 0;
290     }

291 }
292 
293 static jboolean pointCurve(jfloat curve[], jint type) {
294     jint i;
295     for (i = 2; i &lt; type; i++) {
296         if (curve[i] != curve[i-2]) {
297             return JNI_FALSE;
298         }
299     }
300     return JNI_TRUE;
301 }
302 
303 //    private LengthIterator li = null;
304 
305 // preconditions: curCurvepts must be an array of length at least 2 * type,
306 // that contains the curve we want to dash in the first type elements
<span class="line-modified">307 static void somethingTo(PathConsumer *pDasher, jint type) {</span>

308     jint curCurveoff;
309     jfloat lastSplitT;
310     jfloat t;
311     jfloat leftInThisDashSegment;
312 
313     if (pointCurve(this.curCurvepts, type)) {
<span class="line-modified">314         return;</span>
315     }
316     LIinitializeIterationOnCurve(&amp;this.li, this.curCurvepts, type);
317 
318     curCurveoff = 0; // initially the current curve is at curCurvepts[0...type]
319     lastSplitT = 0;
320     t = 0;
321     leftInThisDashSegment = this.dash[this.idx] - this.phase;
322     while ((t = LInext(&amp;this.li, leftInThisDashSegment)) &lt; 1) {
323         if (t != 0) {
324             Helpers_subdivideAt((t - lastSplitT) / (1 - lastSplitT),
325                                 this.curCurvepts, curCurveoff,
326                                 this.curCurvepts, 0,
327                                 this.curCurvepts, type, type);
328             lastSplitT = t;
<span class="line-modified">329             goTo(pDasher, this.curCurvepts, 2, type);</span>



330             curCurveoff = type;
331         }
332         // Advance to next dash segment
333         this.idx = (this.idx + 1) % this.numdashes;
334         this.dashOn = !this.dashOn;
335         this.phase = 0;
336         leftInThisDashSegment = this.dash[this.idx];
337     }
<span class="line-modified">338     goTo(pDasher, this.curCurvepts, curCurveoff+2, type);</span>



339     this.phase += LIlastSegLen(&amp;this.li);
340     if (this.phase &gt;= this.dash[this.idx]) {
341         this.phase = 0.0f;
342         this.idx = (this.idx + 1) % this.numdashes;
343         this.dashOn = !this.dashOn;
344     }

345 }
346 
<span class="line-modified">347 static void Dasher_CurveTo(PathConsumer *pDasher,</span>
348                            jfloat x1, jfloat y1,
349                            jfloat x2, jfloat y2,
350                            jfloat x3, jfloat y3)
351 {
352     this.curCurvepts[0] = this.x0;   this.curCurvepts[1] = this.y0;
353     this.curCurvepts[2] = x1;        this.curCurvepts[3] = y1;
354     this.curCurvepts[4] = x2;        this.curCurvepts[5] = y2;
355     this.curCurvepts[6] = x3;        this.curCurvepts[7] = y3;
<span class="line-modified">356     somethingTo(pDasher, 8);</span>
357 }
358 
<span class="line-modified">359 static void Dasher_QuadTo(PathConsumer *pDasher,</span>
360                           jfloat x1, jfloat y1,
361                           jfloat x2, jfloat y2)
362 {
363     this.curCurvepts[0] = this.x0;   this.curCurvepts[1] = this.y0;
364     this.curCurvepts[2] = x1;        this.curCurvepts[3] = y1;
365     this.curCurvepts[4] = x2;        this.curCurvepts[5] = y2;
<span class="line-modified">366     somethingTo(pDasher, 6);</span>
367 }
368 
<span class="line-modified">369 static void Dasher_ClosePath(PathConsumer *pDasher) {</span>
<span class="line-modified">370     Dasher_LineTo(pDasher, this.sx, this.sy);</span>




371     if (this.firstSegidx &gt; 0) {
372         if (!this.dashOn || this.needsMoveTo) {
<span class="line-modified">373             this.out-&gt;moveTo(this.out, this.sx, this.sy);</span>







374         }
<span class="line-removed">375         emitFirstSegments(pDasher);</span>
376     }
<span class="line-modified">377     Dasher_MoveTo(pDasher, this.sx, this.sy);</span>
378 }
379 
<span class="line-modified">380 static void Dasher_PathDone(PathConsumer *pDasher) {</span>

381     if (this.firstSegidx &gt; 0) {
<span class="line-modified">382         this.out-&gt;moveTo(this.out, this.sx, this.sy);</span>
<span class="line-modified">383         emitFirstSegments(pDasher);</span>






384     }
<span class="line-modified">385     this.out-&gt;pathDone(this.out);</span>
386 }
387 
388 
389 /*
390         public LengthIterator(jint reclimit, float err) {
391             this.limit = reclimit;
392             this.minTincrement = 1f / (1 &lt;&lt; limit);
393             this.ERR = err;
394             this.recCurveStack = new float[reclimit+1][8];
395             this.sides = new Side[reclimit];
396             // if any methods are called without first initializing this object on
397             // a curve, we want it to fail ASAP.
398             this.nextT = Float.MAX_VALUE;
399             this.lenAtNextT = Float.MAX_VALUE;
400             this.lenAtLastSplit = Float.MIN_VALUE;
401             this.recLevel = Integer.MIN_VALUE;
402             this.lastSegLen = Float.MAX_VALUE;
403             this.done = true;
404         }
405  */
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
145                 sidx = (sidx + 1) % ndashes;
146                 this.dashOn = !this.dashOn;
147             }
148         }
149     }
150 
151     this.dash = dash;
152     this.numdashes = ndashes;
153     this.startPhase = this.phase = phase;
154     this.startDashOn = this.dashOn;
155     this.startIdx = sidx;
156     this.starting = JNI_TRUE;
157 }
158 
159 void Dasher_destroy(Dasher *pDasher) {
160     free(pDasher-&gt;firstSegmentsBuffer);
161     pDasher-&gt;firstSegmentsBuffer = NULL;
162     pDasher-&gt;firstSegmentsBufferSIZE = 0;
163 }
164 
<span class="line-modified">165 static jint emitSeg(PathConsumer *pDasher, jfloat buf[], jint off, jint type) {</span>
166     switch (type) {
167     case 8:
<span class="line-modified">168         return this.out-&gt;curveTo(this.out,</span>
169                           buf[off+0], buf[off+1],
170                           buf[off+2], buf[off+3],
171                           buf[off+4], buf[off+5]);
172         break;
173     case 6:
<span class="line-modified">174         return this.out-&gt;quadTo(this.out,</span>
175                          buf[off+0], buf[off+1],
176                          buf[off+2], buf[off+3]);
177         break;
178     case 4:
<span class="line-modified">179         return this.out-&gt;lineTo(this.out, buf[off], buf[off+1]);</span>
180     }
<span class="line-added">181     return ERROR_NONE;</span>
182 }
183 
<span class="line-modified">184 static jint emitFirstSegments(PathConsumer *pDasher) {</span>
185     jint i;
186     for (i = 0; i &lt; this.firstSegidx; ) {
<span class="line-modified">187         jint status;</span>
<span class="line-added">188         status = emitSeg(pDasher, this.firstSegmentsBuffer, i+1, (jint) this.firstSegmentsBuffer[i]);</span>
<span class="line-added">189         if (status != ERROR_NONE) {</span>
<span class="line-added">190             return status;</span>
<span class="line-added">191         }</span>
192         i += (((jint) this.firstSegmentsBuffer[i]) - 1);
193     }
194     this.firstSegidx = 0;
<span class="line-added">195     return ERROR_NONE;</span>
196 }
197 
198 // precondition: pts must be in relative coordinates (relative to x0,y0)
199 // fullCurve is true iff the curve in pts has not been split.
<span class="line-modified">200 static jint goTo(PathConsumer *pDasher, jfloat pts[], jint off, jint type) {</span>
<span class="line-added">201     jint status = ERROR_NONE;</span>
202     jfloat x = pts[off + type - 4];
203     jfloat y = pts[off + type - 3];
204     if (this.dashOn) {
205         if (this.starting) {
206             if (this.firstSegmentsBufferSIZE &lt; this.firstSegidx + (type-1)) {
207                 jint newSize = (this.firstSegidx + (type-1)) * 2;
208                 jfloat *newSegs = new_float(newSize);
<span class="line-added">209                 if (!newSegs) {</span>
<span class="line-added">210                     return ERROR_OOM;</span>
<span class="line-added">211                 }</span>
212                 System_arraycopy(this.firstSegmentsBuffer, 0, newSegs, 0, this.firstSegidx);
213                 free(this.firstSegmentsBuffer);
214                 this.firstSegmentsBuffer = newSegs;
215                 this.firstSegmentsBufferSIZE = newSize;
216             }
217             this.firstSegmentsBuffer[this.firstSegidx++] = (jfloat) type;
218             System_arraycopy(pts, off, this.firstSegmentsBuffer, this.firstSegidx, type - 2);
219             this.firstSegidx += type - 2;
220         } else {
221             if (this.needsMoveTo) {
<span class="line-modified">222                 status = this.out-&gt;moveTo(this.out, this.x0, this.y0);</span>
<span class="line-added">223                 if (status != ERROR_NONE) {</span>
<span class="line-added">224                     return status;</span>
<span class="line-added">225                 }</span>
226                 this.needsMoveTo = JNI_FALSE;
227             }
<span class="line-modified">228             status = emitSeg(pDasher, pts, off, type);</span>
<span class="line-added">229             if (status != ERROR_NONE) {</span>
<span class="line-added">230                 return status;</span>
<span class="line-added">231             }</span>
232         }
233     } else {
234         this.starting = JNI_FALSE;
235         this.needsMoveTo = JNI_TRUE;
236     }
237     this.x0 = x;
238     this.y0 = y;
<span class="line-added">239     return status;</span>
240 }
241 
<span class="line-modified">242 static jint Dasher_MoveTo(PathConsumer *pDasher, jfloat newx0, jfloat newy0) {</span>
<span class="line-added">243     jint status = ERROR_NONE;</span>
244     if (this.firstSegidx &gt; 0) {
<span class="line-modified">245         status = this.out-&gt;moveTo(this.out, this.sx, this.sy);</span>
<span class="line-modified">246         if (status != ERROR_NONE) {</span>
<span class="line-added">247             return status;</span>
<span class="line-added">248         }</span>
<span class="line-added">249         status = emitFirstSegments(pDasher);</span>
<span class="line-added">250         if (status != ERROR_NONE) {</span>
<span class="line-added">251             return status;</span>
<span class="line-added">252         }</span>
253     }
254     this.needsMoveTo = JNI_TRUE;
255     this.idx = this.startIdx;
256     this.dashOn = this.startDashOn;
257     this.phase = this.startPhase;
258     this.sx = this.x0 = newx0;
259     this.sy = this.y0 = newy0;
260     this.starting = JNI_TRUE;
<span class="line-added">261     return status;</span>
262 }
263 
<span class="line-modified">264 static jint Dasher_LineTo(PathConsumer *pDasher, jfloat x1, jfloat y1) {</span>
<span class="line-added">265     jint status = ERROR_NONE;</span>
266     jfloat cx, cy;
267     jfloat dx = x1 - this.x0;
268     jfloat dy = y1 - this.y0;
269 
270     jfloat len = (jfloat) sqrt(dx*dx + dy*dy);
271 
272     if (len == 0) {
<span class="line-modified">273         return status;</span>
274     }
275 
276     // The scaling factors needed to get the dx and dy of the
277     // transformed dash segments.
278     cx = dx / len;
279     cy = dy / len;
280 
281     while (1) {
282         jfloat dashdx, dashdy;
283         jfloat leftInThisDashSegment = this.dash[this.idx] - this.phase;
284         if (len &lt;= leftInThisDashSegment) {
285             this.curCurvepts[0] = x1;
286             this.curCurvepts[1] = y1;
<span class="line-modified">287             status = goTo(pDasher, this.curCurvepts, 0, 4);</span>
<span class="line-added">288             if (status != ERROR_NONE) {</span>
<span class="line-added">289                 return status;</span>
<span class="line-added">290             }</span>
291             // Advance phase within current dash segment
292             this.phase += len;
293             if (len == leftInThisDashSegment) {
294                 this.phase = 0.0f;
295                 this.idx = (this.idx + 1) % this.numdashes;
296                 this.dashOn = !this.dashOn;
297             }
<span class="line-modified">298             return status;</span>
299         }
300 
301         dashdx = this.dash[this.idx] * cx;
302         dashdy = this.dash[this.idx] * cy;
303         if (this.phase == 0) {
304             this.curCurvepts[0] = this.x0 + dashdx;
305             this.curCurvepts[1] = this.y0 + dashdy;
306         } else {
307             jfloat p = leftInThisDashSegment / this.dash[this.idx];
308             this.curCurvepts[0] = this.x0 + p * dashdx;
309             this.curCurvepts[1] = this.y0 + p * dashdy;
310         }
311 
<span class="line-modified">312         status = goTo(pDasher, this.curCurvepts, 0, 4);</span>
<span class="line-added">313         if (status != ERROR_NONE) {</span>
<span class="line-added">314             return status;</span>
<span class="line-added">315         }</span>
316 
317         len -= leftInThisDashSegment;
318         // Advance to next dash segment
319         this.idx = (this.idx + 1) % this.numdashes;
320         this.dashOn = !this.dashOn;
321         this.phase = 0;
322     }
<span class="line-added">323     return status;</span>
324 }
325 
326 static jboolean pointCurve(jfloat curve[], jint type) {
327     jint i;
328     for (i = 2; i &lt; type; i++) {
329         if (curve[i] != curve[i-2]) {
330             return JNI_FALSE;
331         }
332     }
333     return JNI_TRUE;
334 }
335 
336 //    private LengthIterator li = null;
337 
338 // preconditions: curCurvepts must be an array of length at least 2 * type,
339 // that contains the curve we want to dash in the first type elements
<span class="line-modified">340 static jint somethingTo(PathConsumer *pDasher, jint type) {</span>
<span class="line-added">341     jint status = ERROR_NONE;</span>
342     jint curCurveoff;
343     jfloat lastSplitT;
344     jfloat t;
345     jfloat leftInThisDashSegment;
346 
347     if (pointCurve(this.curCurvepts, type)) {
<span class="line-modified">348         return status;</span>
349     }
350     LIinitializeIterationOnCurve(&amp;this.li, this.curCurvepts, type);
351 
352     curCurveoff = 0; // initially the current curve is at curCurvepts[0...type]
353     lastSplitT = 0;
354     t = 0;
355     leftInThisDashSegment = this.dash[this.idx] - this.phase;
356     while ((t = LInext(&amp;this.li, leftInThisDashSegment)) &lt; 1) {
357         if (t != 0) {
358             Helpers_subdivideAt((t - lastSplitT) / (1 - lastSplitT),
359                                 this.curCurvepts, curCurveoff,
360                                 this.curCurvepts, 0,
361                                 this.curCurvepts, type, type);
362             lastSplitT = t;
<span class="line-modified">363             status = goTo(pDasher, this.curCurvepts, 2, type);</span>
<span class="line-added">364             if (status != ERROR_NONE) {</span>
<span class="line-added">365                 return status;</span>
<span class="line-added">366             }</span>
367             curCurveoff = type;
368         }
369         // Advance to next dash segment
370         this.idx = (this.idx + 1) % this.numdashes;
371         this.dashOn = !this.dashOn;
372         this.phase = 0;
373         leftInThisDashSegment = this.dash[this.idx];
374     }
<span class="line-modified">375     status = goTo(pDasher, this.curCurvepts, curCurveoff+2, type);</span>
<span class="line-added">376     if (status != ERROR_NONE) {</span>
<span class="line-added">377         return status;</span>
<span class="line-added">378     }</span>
379     this.phase += LIlastSegLen(&amp;this.li);
380     if (this.phase &gt;= this.dash[this.idx]) {
381         this.phase = 0.0f;
382         this.idx = (this.idx + 1) % this.numdashes;
383         this.dashOn = !this.dashOn;
384     }
<span class="line-added">385     return status;</span>
386 }
387 
<span class="line-modified">388 static jint Dasher_CurveTo(PathConsumer *pDasher,</span>
389                            jfloat x1, jfloat y1,
390                            jfloat x2, jfloat y2,
391                            jfloat x3, jfloat y3)
392 {
393     this.curCurvepts[0] = this.x0;   this.curCurvepts[1] = this.y0;
394     this.curCurvepts[2] = x1;        this.curCurvepts[3] = y1;
395     this.curCurvepts[4] = x2;        this.curCurvepts[5] = y2;
396     this.curCurvepts[6] = x3;        this.curCurvepts[7] = y3;
<span class="line-modified">397     return somethingTo(pDasher, 8);</span>
398 }
399 
<span class="line-modified">400 static jint Dasher_QuadTo(PathConsumer *pDasher,</span>
401                           jfloat x1, jfloat y1,
402                           jfloat x2, jfloat y2)
403 {
404     this.curCurvepts[0] = this.x0;   this.curCurvepts[1] = this.y0;
405     this.curCurvepts[2] = x1;        this.curCurvepts[3] = y1;
406     this.curCurvepts[4] = x2;        this.curCurvepts[5] = y2;
<span class="line-modified">407     return somethingTo(pDasher, 6);</span>
408 }
409 
<span class="line-modified">410 static jint Dasher_ClosePath(PathConsumer *pDasher) {</span>
<span class="line-modified">411     jint status = ERROR_NONE;</span>
<span class="line-added">412     status = Dasher_LineTo(pDasher, this.sx, this.sy);</span>
<span class="line-added">413     if (status != ERROR_NONE) {</span>
<span class="line-added">414         return status;</span>
<span class="line-added">415     }</span>
416     if (this.firstSegidx &gt; 0) {
417         if (!this.dashOn || this.needsMoveTo) {
<span class="line-modified">418             status = this.out-&gt;moveTo(this.out, this.sx, this.sy);</span>
<span class="line-added">419             if (status != ERROR_NONE) {</span>
<span class="line-added">420                 return status;</span>
<span class="line-added">421             }</span>
<span class="line-added">422         }</span>
<span class="line-added">423         status = emitFirstSegments(pDasher);</span>
<span class="line-added">424         if (status != ERROR_NONE) {</span>
<span class="line-added">425             return status;</span>
426         }

427     }
<span class="line-modified">428     return Dasher_MoveTo(pDasher, this.sx, this.sy);</span>
429 }
430 
<span class="line-modified">431 static jint Dasher_PathDone(PathConsumer *pDasher) {</span>
<span class="line-added">432     jint status = ERROR_NONE;</span>
433     if (this.firstSegidx &gt; 0) {
<span class="line-modified">434         status = this.out-&gt;moveTo(this.out, this.sx, this.sy);</span>
<span class="line-modified">435         if (status != ERROR_NONE) {</span>
<span class="line-added">436             return status;</span>
<span class="line-added">437         }</span>
<span class="line-added">438         status = emitFirstSegments(pDasher);</span>
<span class="line-added">439         if (status != ERROR_NONE) {</span>
<span class="line-added">440             return status;</span>
<span class="line-added">441         }</span>
442     }
<span class="line-modified">443     return this.out-&gt;pathDone(this.out);</span>
444 }
445 
446 
447 /*
448         public LengthIterator(jint reclimit, float err) {
449             this.limit = reclimit;
450             this.minTincrement = 1f / (1 &lt;&lt; limit);
451             this.ERR = err;
452             this.recCurveStack = new float[reclimit+1][8];
453             this.sides = new Side[reclimit];
454             // if any methods are called without first initializing this object on
455             // a curve, we want it to fail ASAP.
456             this.nextT = Float.MAX_VALUE;
457             this.lenAtNextT = Float.MAX_VALUE;
458             this.lenAtLastSplit = Float.MIN_VALUE;
459             this.recLevel = Integer.MIN_VALUE;
460             this.lastSegLen = Float.MAX_VALUE;
461             this.done = true;
462         }
463  */
</pre>
</td>
</tr>
</table>
<center><a href="../native-prism-es2/ios/ios-window-system.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="NativePiscesRasterizer.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
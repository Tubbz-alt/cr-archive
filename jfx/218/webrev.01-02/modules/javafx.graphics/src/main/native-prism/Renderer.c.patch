diff a/modules/javafx.graphics/src/main/native-prism/Renderer.c b/modules/javafx.graphics/src/main/native-prism/Renderer.c
--- a/modules/javafx.graphics/src/main/native-prism/Renderer.c
+++ b/modules/javafx.graphics/src/main/native-prism/Renderer.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -68,10 +68,12 @@
     // the y of the first scan line crossing).
     this.nextY = pRenderer->sampleRowMin;
     this.edgeCount = 0;
 }
 
+// Iterate to the next scanline and return the number of crossings.
+// A count of -1 is returned to indicate OOM.
 static jint ScanlineIterator_next(ScanlineIterator *pIterator, Renderer *pRenderer) {
     jint i, ecur;
     jint *xings;
     // NOTE: make function that convert from y value to bucket idx?
     jint cury = this.nextY++;
@@ -93,10 +95,13 @@
         count = newCount;
     }
     if (this.edgePtrsSIZE < count + (bucketcount >> 1)) {
         jint newSize = (count + (bucketcount >> 1)) * 2;
         jint *newPtrs = new_int(newSize);
+        if (!newPtrs) {
+            return -1;
+        }
         System_arraycopy(this.edgePtrs, 0, newPtrs, 0, count);
         free(this.edgePtrs);
         this.edgePtrs = newPtrs;
         this.edgePtrsSIZE = newSize;
     }
@@ -115,10 +120,13 @@
 //    }
     xings = this.crossings;
     if (this.crossingsSIZE < count) {
         free(this.crossings);
         this.crossings = xings = new_int(this.edgePtrsSIZE);
+        if (!xings) {
+            return -1;
+        }
         this.crossingsSIZE = this.edgePtrsSIZE;
     }
     for (i = 0; i < count; i++) {
         jint ecur = ptrs[i];
         jfloat curx = edges[ecur+CURX];
@@ -161,30 +169,35 @@
 // for shifts and just removing certain operations altogether.
 
 
 // each bucket is a linked list. this method adds eptr to the
 // start "bucket"th linked list.
-static void addEdgeToBucket(PathConsumer *pRenderer, const jint eptr, const jint bucket) {
+static jint addEdgeToBucket(PathConsumer *pRenderer, const jint eptr, const jint bucket) {
     // we could implement this in terms of insertEdge, but this is a special
     // case, so we optimize a bit.
+    if (this.edgeBuckets[bucket*2] >= MAX_EDGE_IDX) {
+        return ERROR_AIOOBE;
+    }
     this.edges[eptr+NEXT] = (jfloat) this.edgeBuckets[bucket*2];
     this.edgeBuckets[bucket*2] = eptr + 1;
     this.edgeBuckets[bucket*2 + 1] += 2;
+    return ERROR_NONE;
 }
 
-static void addLine(PathConsumer *pRenderer,
+static jint addLine(PathConsumer *pRenderer,
                     jfloat x1, jfloat y1,
                     jfloat x2, jfloat y2);
 
 // Flattens using adaptive forward differencing. This only carries out
 // one iteration of the AFD loop. All it does is update AFD variables (i.e.
 // X0, Y0, D*[X|Y], COUNT; not variables used for computing scanline crossings).
-static void quadBreakIntoLinesAndAdd(PathConsumer *pRenderer,
+static jint quadBreakIntoLinesAndAdd(PathConsumer *pRenderer,
                                      jfloat x0, jfloat y0,
                                      const Curve c,
                                      const jfloat x2, const jfloat y2)
 {
+    jint status = ERROR_NONE;
     jfloat ddx, ddy, dx, dy;
     const jfloat QUAD_DEC_BND = 32;
     const jint countlg = 4;
     jint count = 1 << countlg;
     jint countsq = count * count;
@@ -203,27 +216,31 @@
     while (count-- > 1) {
         jfloat x1 = x0 + dx;
         jfloat y1 = y0 + dy;
         dx += ddx;
         dy += ddy;
-        addLine(pRenderer, x0, y0, x1, y1);
+        status = addLine(pRenderer, x0, y0, x1, y1);
+        if (status != ERROR_NONE) {
+            return status;
+        }
         x0 = x1;
         y0 = y1;
     }
-    addLine(pRenderer, x0, y0, x2, y2);
+    return addLine(pRenderer, x0, y0, x2, y2);
 }
 
 // x0, y0 and x3,y3 are the endpoints of the curve. We could compute these
 // using c.xat(0),c.yat(0) and c.xat(1),c.yat(1), but this might introduce
 // numerical errors, and our callers already have the exact values.
 // Another alternative would be to pass all the control points, and call c.set
 // here, but then too many numbers are passed around.
-static void curveBreakIntoLinesAndAdd(PathConsumer *pRenderer,
+static jint curveBreakIntoLinesAndAdd(PathConsumer *pRenderer,
                                       jfloat x0, jfloat y0,
                                       const Curve c,
                                       const jfloat x3, const jfloat y3)
 {
+    jint status = ERROR_NONE;
     const jint countlg = 3;
     jint count = 1 << countlg;
     jfloat x1, y1;
 
     // the dx and dy refer to forward differencing variables, not the last
@@ -270,20 +287,25 @@
             ddy += dddy;
         } else {
             x1 = x3;
             y1 = y3;
         }
-        addLine(pRenderer, x0, y0, x1, y1);
+        status = addLine(pRenderer, x0, y0, x1, y1);
+        if (status != ERROR_NONE) {
+            return status;
+        }
         x0 = x1;
         y0 = y1;
     }
+    return status;
 }
 
-static void addLine(PathConsumer *pRenderer,
+static jint addLine(PathConsumer *pRenderer,
                     jfloat x1, jfloat y1,
                     jfloat x2, jfloat y2)
 {
+    jint status = ERROR_NONE;
     jfloat or = 1; // orientation of the line. 1 if y increases, 0 otherwise.
     jint firstCrossing, lastCrossing;
     jfloat slope;
     jint ptr, bucketIdx;
 
@@ -297,11 +319,11 @@
         or = 0;
     }
     firstCrossing = Math_max((jint) ceil(y1 - 0.5f), this.boundsMinY);
     lastCrossing = Math_min((jint) ceil(y2 - 0.5f), this.boundsMaxY);
     if (firstCrossing >= lastCrossing) {
-        return;
+        return status;
     }
     if (firstCrossing < this.sampleRowMin) { this.sampleRowMin = firstCrossing; }
     if (lastCrossing > this.sampleRowMax) { this.sampleRowMax = lastCrossing; }
 
     slope = (x2 - x1) / (y2 - y1);
@@ -312,27 +334,38 @@
     } else {
         if (x2 < this.edgeMinX) { this.edgeMinX = x2; }
         if (x1 > this.edgeMaxX) { this.edgeMaxX = x1; }
     }
 
+    bucketIdx = firstCrossing - this.boundsMinY;
+    if (this.edgeBuckets[bucketIdx*2] >= MAX_EDGE_IDX) {
+        return ERROR_AIOOBE;
+    }
+
     ptr = this.numEdges * SIZEOF_EDGE;
     if (this.edgesSIZE < ptr + SIZEOF_EDGE) {
         jint newSize = (ptr + SIZEOF_EDGE) * 2;
         jfloat *newEdges = new_float(newSize);
+        if (!newEdges) {
+            return ERROR_OOM;
+        }
         System_arraycopy(this.edges, 0, newEdges, 0, ptr);
         free(this.edges);
         this.edges = newEdges;
         this.edgesSIZE = newSize;
     }
     this.numEdges++;
     this.edges[ptr+OR] = or;
     this.edges[ptr+CURX] = x1 + (firstCrossing + 0.5f - y1) * slope;
     this.edges[ptr+SLOPE] = slope;
     this.edges[ptr+YMAX] = (jfloat) lastCrossing;
-    bucketIdx = firstCrossing - this.boundsMinY;
-    addEdgeToBucket(pRenderer, ptr, bucketIdx);
+    status = addEdgeToBucket(pRenderer, ptr, bucketIdx);
+    if (status != ERROR_NONE) {
+        return status;
+    }
     this.edgeBuckets[(lastCrossing - this.boundsMinY)*2 + 1] |= 1;
+    return status;
 }
 
 // END EDGE LIST
 //////////////////////////////////////////////////////////////////////////////
 static MoveToFunc       Renderer_moveTo;
@@ -437,76 +470,94 @@
 }
 static jfloat tosubpixy(jfloat pix_y) {
     return pix_y * SUBPIXEL_POSITIONS_Y;
 }
 
-static void Renderer_moveTo(PathConsumer *pRenderer,
+static jint Renderer_moveTo(PathConsumer *pRenderer,
                             jfloat pix_x0, jfloat pix_y0)
 {
-    Renderer_closePath(pRenderer);
+    jint status = Renderer_closePath(pRenderer);
+    if (status != ERROR_NONE) {
+        return status;
+    }
     this.pix_sx0 = pix_x0;
     this.pix_sy0 = pix_y0;
     this.y0 = tosubpixy(pix_y0);
     this.x0 = tosubpixx(pix_x0);
+    return status;
 }
 
-static void Renderer_lineTo(PathConsumer *pRenderer,
+static jint Renderer_lineTo(PathConsumer *pRenderer,
                             jfloat pix_x1, jfloat pix_y1)
 {
     jfloat x1 = tosubpixx(pix_x1);
     jfloat y1 = tosubpixy(pix_y1);
-    addLine(pRenderer, this.x0, this.y0, x1, y1);
+    jint status = addLine(pRenderer, this.x0, this.y0, x1, y1);
+    if (status != ERROR_NONE) {
+        return status;
+    }
     this.x0 = x1;
     this.y0 = y1;
+    return status;
 }
 
-static void Renderer_curveTo(PathConsumer *pRenderer,
+static jint Renderer_curveTo(PathConsumer *pRenderer,
                              jfloat x1, jfloat y1,
                              jfloat x2, jfloat y2,
                              jfloat x3, jfloat y3)
 {
+    jint status = ERROR_NONE;
     const jfloat xe = tosubpixx(x3);
     const jfloat ye = tosubpixy(y3);
     Curve_setcubic(&this.c,
                    this.x0, this.y0,
                    tosubpixx(x1), tosubpixy(y1),
                    tosubpixx(x2), tosubpixy(y2),
                    xe, ye);
-    curveBreakIntoLinesAndAdd(pRenderer, this.x0, this.y0, this.c, xe, ye);
+    status = curveBreakIntoLinesAndAdd(pRenderer, this.x0, this.y0, this.c, xe, ye);
+    if (status != ERROR_NONE) {
+        return status;
+    }
     this.x0 = xe;
     this.y0 = ye;
+    return status;
 }
 
-void Renderer_quadTo(PathConsumer *pRenderer,
+jint Renderer_quadTo(PathConsumer *pRenderer,
                      jfloat x1, jfloat y1,
                      jfloat x2, jfloat y2)
 {
+    jint status = ERROR_NONE;
     const jfloat xe = tosubpixx(x2);
     const jfloat ye = tosubpixy(y2);
     Curve_setquad(&this.c,
                   this.x0, this.y0,
                   tosubpixx(x1), tosubpixy(y1),
                   xe, ye);
-    quadBreakIntoLinesAndAdd(pRenderer, this.x0, this.y0, this.c, xe, ye);
+    status = quadBreakIntoLinesAndAdd(pRenderer, this.x0, this.y0, this.c, xe, ye);
+    if (status != ERROR_NONE) {
+        return status;
+    }
     this.x0 = xe;
     this.y0 = ye;
+    return status;
 }
 
-static void Renderer_closePath(PathConsumer *pRenderer) {
+static jint Renderer_closePath(PathConsumer *pRenderer) {
     // lineTo expects its input in pixel coordinates.
-    Renderer_lineTo(pRenderer, this.pix_sx0, this.pix_sy0);
+    return Renderer_lineTo(pRenderer, this.pix_sx0, this.pix_sy0);
 }
 
-static void Renderer_pathDone(PathConsumer *pRenderer) {
-    Renderer_closePath(pRenderer);
+static jint Renderer_pathDone(PathConsumer *pRenderer) {
+    return Renderer_closePath(pRenderer);
 }
 
 static void setAndClearRelativeAlphas(AlphaConsumer *pAC,
                                       jint alphaRow[], jint pix_y,
                                       jint pix_from, jint pix_to);
 
-void Renderer_produceAlphas(Renderer *pRenderer, AlphaConsumer *pAC) {
+jint Renderer_produceAlphas(Renderer *pRenderer, AlphaConsumer *pAC) {
 //    ac.setMaxAlpha(MAX_AA_ALPHA);
 
     // Mask to determine the relevant bit of the crossing sum
     // 0x1 if EVEN_ODD, all bits if NON_ZERO
     jint mask = (this.windingRule == WIND_EVEN_ODD) ? 0x1 : ~0x0;
@@ -519,10 +570,13 @@
     jint width = pAC->width;
     jint savedAlpha[1024];
     jint *alpha;
     if (1024 < width+2) {
         alpha = new_int(width+2);
+        if (!alpha) {
+            return ERROR_OOM;
+        }
     } else {
         alpha = savedAlpha;
     }
     Arrays_fill(alpha, 0, width+2, 0);
 
@@ -544,10 +598,16 @@
         jint numCrossings = ScanlineIterator_next(&it, pRenderer);
         jint *crossings = it.crossings;
         jint sum, prev;
         jint i;
 
+        if (numCrossings < 0) {
+            ScanlineIterator_destroy(&it);
+            if (alpha != savedAlpha) free (alpha);
+            return ERROR_OOM;
+        }
+
         y = ScanlineIterator_curY(&it);
 
         if (numCrossings > 0) {
             jint lowx = crossings[0] >> 1;
             jint highx = crossings[numCrossings - 1] >> 1;
@@ -610,10 +670,12 @@
         setAndClearRelativeAlphas(pAC, alpha, y >> SUBPIXEL_LG_POSITIONS_Y,
                                   pix_minX, pix_maxX);
     }
     ScanlineIterator_destroy(&it);
     if (alpha != savedAlpha) free (alpha);
+
+    return ERROR_NONE;
 }
 
 //@Override
 static void setMaxAlpha(jint maxalpha) {
     jint i, altMax;

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/native-prism/Stroker.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &lt;stdlib.h&gt;
  27 #include &lt;string.h&gt;
  28 #include &lt;math.h&gt;
  29 #include &lt;jni.h&gt;
  30 
  31 #include &quot;Helpers.h&quot;
  32 #include &quot;PathConsumer.h&quot;
  33 
  34 #include &quot;Stroker.h&quot;
  35 
  36 // NOTE: some of the arithmetic here is too verbose and prone to hard to
  37 // debug typos. We should consider making a small Point/Vector class that
  38 // has methods like plus(Point), minus(Point), dot(Point), cross(Point)and such
  39 //public final class Stroker implements PathConsumer2D {
  40 
  41 #define MOVE_TO  0
  42 #define DRAWING_OP_TO  1 // ie. curve, line, or quad
  43 #define CLOSE  2
  44 
  45 static MoveToFunc       Stroker_moveTo;
  46 static LineToFunc       Stroker_lineTo;
  47 static QuadToFunc       Stroker_quadTo;
  48 static CurveToFunc      Stroker_curveTo;
  49 static ClosePathFunc    Stroker_closePath;
  50 static PathDoneFunc     Stroker_pathDone;
  51 
  52 #define this (*((Stroker *) pStroker))
  53 
<a name="2" id="anc2"></a><span class="line-modified">  54 static void drawJoin(PathConsumer *pStroker,</span>
  55                      jfloat pdx, jfloat pdy,
  56                      jfloat x0, jfloat y0,
  57                      jfloat dx, jfloat dy,
  58                      jfloat omx, jfloat omy,
  59                      jfloat mx, jfloat my);
  60 
<a name="3" id="anc3"></a><span class="line-modified">  61 static void drawRoundJoin2(PathConsumer *pStroker,</span>
  62                            jfloat cx, jfloat cy,
  63                            jfloat omx, jfloat omy,
  64                            jfloat mx, jfloat my,
  65                            jboolean rev);
  66 
<a name="4" id="anc4"></a><span class="line-modified">  67 static void drawBezApproxForArc(PathConsumer *pStroker,</span>
  68                                 const jfloat cx, const jfloat cy,
  69                                 const jfloat omx, const jfloat omy,
  70                                 const jfloat mx, const jfloat my,
  71                                 jboolean rev);
  72 
<a name="5" id="anc5"></a><span class="line-modified">  73 static void emitMoveTo(PathConsumer *pStroker, const jfloat x0, const jfloat y0);</span>
  74 
<a name="6" id="anc6"></a><span class="line-modified">  75 static void emitLineTo(PathConsumer *pStroker, const jfloat x1, const jfloat y1,</span>
  76                        const jboolean rev);
  77 
<a name="7" id="anc7"></a><span class="line-modified">  78 static void emitCurveTo(PathConsumer *pStroker,</span>
  79                         const jfloat x0, const jfloat y0,
  80                         const jfloat x1, const jfloat y1,
  81                         const jfloat x2, const jfloat y2,
  82                         const jfloat x3, const jfloat y3, const jboolean rev);
  83 
<a name="8" id="anc8"></a><span class="line-modified">  84 static void emitClose(PathConsumer *pStroker);</span>
  85 
<a name="9" id="anc9"></a><span class="line-modified">  86 static void emitReverse(PathConsumer *pStroker);</span>
  87 
<a name="10" id="anc10"></a><span class="line-modified">  88 static void finish(PathConsumer *pStroker);</span>
  89 
  90 extern void PolyStack_init(PolyStack *pStack);
  91 
  92 extern void PolyStack_destroy(PolyStack *pStack);
  93 
  94 extern jboolean PolyStack_isEmpty(PolyStack *pStack);
  95 
<a name="11" id="anc11"></a><span class="line-modified">  96 extern void PolyStack_pushLine(PolyStack *pStack,</span>
  97                                jfloat x, jfloat y);
  98 
<a name="12" id="anc12"></a><span class="line-modified">  99 extern void PolyStack_pushCubic(PolyStack *pStack,</span>
 100                                 jfloat x0, jfloat y0,
 101                                 jfloat x1, jfloat y1,
 102                                 jfloat x2, jfloat y2);
 103 
<a name="13" id="anc13"></a><span class="line-modified"> 104 extern void PolyStack_pushQuad(PolyStack *pStack,</span>
 105                                jfloat x0, jfloat y0,
 106                                jfloat x1, jfloat y1);
 107 
<a name="14" id="anc14"></a><span class="line-modified"> 108 extern void PolyStack_pop(PolyStack *pStack, PathConsumer *io);</span>
 109 
 110     /**
 111      * Constructs a &lt;code&gt;Stroker&lt;/code&gt;.
 112      *
 113      * @param pc2d an output &lt;code&gt;PathConsumer2D&lt;/code&gt;.
 114      * @param lineWidth the desired line width in pixels
 115      * @param capStyle the desired end cap style, one of
 116      * &lt;code&gt;CAP_BUTT&lt;/code&gt;, &lt;code&gt;CAP_ROUND&lt;/code&gt; or
 117      * &lt;code&gt;CAP_SQUARE&lt;/code&gt;.
 118      * @param joinStyle the desired line join style, one of
 119      * &lt;code&gt;JOIN_MITER&lt;/code&gt;, &lt;code&gt;JOIN_ROUND&lt;/code&gt; or
 120      * &lt;code&gt;JOIN_BEVEL&lt;/code&gt;.
 121      * @param miterLimit the desired miter limit
 122     public Stroker(PathConsumer2D pc2d,
 123                    float lineWidth,
 124                    jint capStyle,
 125                    jint joinStyle,
 126                    float miterLimit)
 127     {
 128         this(pc2d);
 129 
 130         reset(lineWidth, capStyle, joinStyle, miterLimit);
 131     }
 132 
 133     public Stroker(PathConsumer2D pc2d) {
 134         setConsumer(pc2d);
 135     }
 136 
 137     public void setConsumer(PathConsumer2D pc2d) {
 138         this.out = pc2d;
 139     }
 140      */
 141 
 142 extern void Stroker_reset(Stroker *pStroker, jfloat lineWidth,
 143                           jint capStyle, jint joinStyle, jfloat miterLimit);
 144 
 145 void Stroker_init(Stroker *pStroker,
 146                   PathConsumer *out,
 147                   jfloat lineWidth,
 148                   jint capStyle,
 149                   jint joinStyle,
 150                   jfloat miterLimit)
 151 {
 152     memset(pStroker, 0, sizeof(Stroker));
 153     PathConsumer_init(&amp;this.consumer,
 154                       Stroker_moveTo,
 155                       Stroker_lineTo,
 156                       Stroker_quadTo,
 157                       Stroker_curveTo,
 158                       Stroker_closePath,
 159                       Stroker_pathDone);
 160 
 161     this.out = out;
 162     Stroker_reset(pStroker, lineWidth, capStyle, joinStyle, miterLimit);
 163     PolyStack_init(&amp;pStroker-&gt;reverse);
 164 }
 165 
 166 void Stroker_reset(Stroker *pStroker, jfloat lineWidth,
 167                    jint capStyle, jint joinStyle, jfloat miterLimit)
 168 {
 169     jfloat limit;
 170 
 171     this.lineWidth2 = lineWidth / 2;
 172     this.capStyle = capStyle;
 173     this.joinStyle = joinStyle;
 174 
 175     limit = miterLimit * this.lineWidth2;
 176     this.miterLimitSq = limit*limit;
 177 
 178     this.prev = CLOSE;
 179 }
 180 
 181 void Stroker_destroy(Stroker *pStroker) {
 182     PolyStack_destroy(&amp;pStroker-&gt;reverse);
 183 }
 184 
 185 void computeOffset(const jfloat lx, const jfloat ly,
 186                    const jfloat w, jfloat m[])
 187 {
 188     const jfloat len = (jfloat) sqrt(lx*lx + ly*ly);
 189     if (len == 0) {
 190         m[0] = m[1] = 0;
 191     } else {
 192         m[0] = (ly * w)/len;
 193         m[1] = -(lx * w)/len;
 194     }
 195 }
 196 
 197 // Returns true if the vectors (dx1, dy1) and (dx2, dy2) are
 198 // clockwise (if dx1,dy1 needs to be rotated clockwise to close
 199 // the smallest angle between it and dx2,dy2).
 200 // This is equivalent to detecting whether a point q is on the right side
 201 // of a line passing through points p1, p2 where p2 = p1+(dx1,dy1) and
 202 // q = p2+(dx2,dy2), which is the same as saying p1, p2, q are in a
 203 // clockwise order.
 204 // NOTE: &quot;clockwise&quot; here assumes coordinates with 0,0 at the bottom left.
 205 static jboolean isCW(const jfloat dx1, const jfloat dy1,
 206                      const jfloat dx2, const jfloat dy2)
 207 {
 208     return dx1 * dy2 &lt;= dy1 * dx2;
 209 }
 210 
 211 // pisces used to use fixed point arithmetic with 16 decimal digits. I
 212 // didn&#39;t want to change the values of the constant below when I converted
 213 // it to floating point, so that&#39;s why the divisions by 2^16 are there.
 214 #define ROUND_JOIN_THRESHOLD   (1000/65536.0f)
 215 
<a name="15" id="anc15"></a><span class="line-modified"> 216 static void drawRoundJoin(PathConsumer *pStroker,</span>
 217                           jfloat x, jfloat y,
 218                           jfloat omx, jfloat omy, jfloat mx, jfloat my,
 219                           jboolean rev,
 220                           jfloat threshold)
 221 {
 222     jfloat domx, domy, len;
 223 
 224     if ((omx == 0 &amp;&amp; omy == 0) || (mx == 0 &amp;&amp; my == 0)) {
<a name="16" id="anc16"></a><span class="line-modified"> 225         return;</span>
 226     }
 227 
 228     domx = omx - mx;
 229     domy = omy - my;
 230     len = domx*domx + domy*domy;
 231     if (len &lt; threshold) {
<a name="17" id="anc17"></a><span class="line-modified"> 232         return;</span>
 233     }
 234 
 235     if (rev) {
 236         omx = -omx;
 237         omy = -omy;
 238         mx = -mx;
 239         my = -my;
 240     }
<a name="18" id="anc18"></a><span class="line-modified"> 241     drawRoundJoin2(pStroker, x, y, omx, omy, mx, my, rev);</span>
 242 }
 243 
<a name="19" id="anc19"></a><span class="line-modified"> 244 static void drawRoundJoin2(PathConsumer *pStroker,</span>
 245                            jfloat cx, jfloat cy,
 246                            jfloat omx, jfloat omy,
 247                            jfloat mx, jfloat my,
 248                            jboolean rev)
 249 {
<a name="20" id="anc20"></a>

 250     // The sign of the dot product of mx,my and omx,omy is equal to the
 251     // the sign of the cosine of ext
 252     // (ext is the angle between omx,omy and mx,my).
 253     jdouble cosext = omx * mx + omy * my;
 254     // If it is &gt;=0, we know that abs(ext) is &lt;= 90 degrees, so we only
 255     // need 1 curve to approximate the circle section that joins omx,omy
 256     // and mx,my.
 257     const jint numCurves = cosext &gt;= 0 ? 1 : 2;
 258 
 259     switch (numCurves) {
 260     case 1:
<a name="21" id="anc21"></a><span class="line-modified"> 261         drawBezApproxForArc(pStroker, cx, cy, omx, omy, mx, my, rev);</span>
 262         break;
 263     case 2:
 264         {
 265             // we need to split the arc into 2 arcs spanning the same angle.
 266             // The point we want will be one of the 2 intersections of the
 267             // perpendicular bisector of the chord (omx,omy)-&gt;(mx,my) and the
 268             // circle. We could find this by scaling the vector
 269             // (omx+mx, omy+my)/2 so that it has length=lineWidth2 (and thus lies
 270             // on the circle), but that can have numerical problems when the angle
 271             // between omx,omy and mx,my is close to 180 degrees. So we compute a
 272             // normal of (omx,omy)-(mx,my). This will be the direction of the
 273             // perpendicular bisector. To get one of the intersections, we just scale
 274             // this vector that its length is lineWidth2 (this works because the
 275             // perpendicular bisector goes through the origin). This scaling doesn&#39;t
 276             // have numerical problems because we know that lineWidth2 divided by
 277             // this normal&#39;s length is at least 0.5 and at most sqrt(2)/2 (because
 278             // we know the angle of the arc is &gt; 90 degrees).
 279             jfloat nx = my - omy, ny = omx - mx;
 280             jfloat nlen = (jfloat) sqrt(nx*nx + ny*ny);
 281             jfloat scale = this.lineWidth2/nlen;
 282             jfloat mmx = nx * scale, mmy = ny * scale;
 283 
 284             // if (isCW(omx, omy, mx, my) != isCW(mmx, mmy, mx, my)) then we&#39;ve
 285             // computed the wrong intersection so we get the other one.
 286             // The test above is equivalent to if (rev).
 287             if (rev) {
 288                 mmx = -mmx;
 289                 mmy = -mmy;
 290             }
<a name="22" id="anc22"></a><span class="line-modified"> 291             drawBezApproxForArc(pStroker, cx, cy, omx, omy, mmx, mmy, rev);</span>
<span class="line-modified"> 292             drawBezApproxForArc(pStroker, cx, cy, mmx, mmy, mx, my, rev);</span>



 293             break;
 294         }
 295     }
<a name="23" id="anc23"></a>
 296 }
 297 
 298 // the input arc defined by omx,omy and mx,my must span &lt;= 90 degrees.
<a name="24" id="anc24"></a><span class="line-modified"> 299 static void drawBezApproxForArc(PathConsumer *pStroker,</span>
 300                                 const jfloat cx, const jfloat cy,
 301                                 const jfloat omx, const jfloat omy,
 302                                 const jfloat mx, const jfloat my,
 303                                 jboolean rev)
 304 {
 305     jfloat cosext2 = (omx * mx + omy * my) / (2 * this.lineWidth2 * this.lineWidth2);
 306     // cv is the length of P1-P0 and P2-P3 divided by the radius of the arc
 307     // (so, cv assumes the arc has radius 1). P0, P1, P2, P3 are the points that
 308     // define the bezier curve we&#39;re computing.
 309     // It is computed using the constraints that P1-P0 and P3-P2 are parallel
 310     // to the arc tangents at the endpoints, and that |P1-P0|=|P3-P2|.
 311     jfloat cv = (jfloat) ((4.0 / 3.0) * sqrt(0.5-cosext2) /
 312                           (1.0 + sqrt(cosext2+0.5)));
 313     jfloat x1, y1, x2, y2, x3, y3, x4, y4;
 314 
 315     // if clockwise, we need to negate cv.
 316     if (rev) { // rev is equivalent to isCW(omx, omy, mx, my)
 317         cv = -cv;
 318     }
 319     x1 = cx + omx;
 320     y1 = cy + omy;
 321     x2 = x1 - cv * omy;
 322     y2 = y1 + cv * omx;
 323 
 324     x4 = cx + mx;
 325     y4 = cy + my;
 326     x3 = x4 + cv * my;
 327     y3 = y4 - cv * mx;
 328 
<a name="25" id="anc25"></a><span class="line-modified"> 329     emitCurveTo(pStroker, x1, y1, x2, y2, x3, y3, x4, y4, rev);</span>
 330 }
 331 
<a name="26" id="anc26"></a><span class="line-modified"> 332 static void drawRoundCap(PathConsumer *pStroker, jfloat cx, jfloat cy, jfloat mx, jfloat my) {</span>

 333     const jfloat C = 0.5522847498307933f;
 334     // the first and second arguments of the following two calls
 335     // are really will be ignored by emitCurveTo (because of the false),
 336     // but we put them in anyway, as opposed to just giving it 4 zeroes,
 337     // because it&#39;s just 4 additions and it&#39;s not good to rely on this
 338     // sort of assumption (right now it&#39;s true, but that may change).
<a name="27" id="anc27"></a><span class="line-modified"> 339     emitCurveTo(pStroker,</span>
 340                 cx+mx,      cy+my,
 341                 cx+mx-C*my, cy+my+C*mx,
 342                 cx-my+C*mx, cy+mx+C*my,
 343                 cx-my,      cy+mx,
 344                 JNI_FALSE);
<a name="28" id="anc28"></a><span class="line-modified"> 345     emitCurveTo(pStroker,</span>



 346                 cx-my,      cy+mx,
 347                 cx-my-C*mx, cy+mx-C*my,
 348                 cx-mx-C*my, cy-my+C*mx,
 349                 cx-mx,      cy-my,
 350                 JNI_FALSE);
<a name="29" id="anc29"></a>
 351 }
 352 
 353 // Return the intersection point of the lines (x0, y0) -&gt; (x1, y1)
 354 // and (x0p, y0p) -&gt; (x1p, y1p) in m[0] and m[1]
 355 static void computeMiter(const jfloat x0, const jfloat y0,
 356                          const jfloat x1, const jfloat y1,
 357                          const jfloat x0p, const jfloat y0p,
 358                          const jfloat x1p, const jfloat y1p,
 359                          jfloat m[], jint off)
 360 {
 361     jfloat x10 = x1 - x0;
 362     jfloat y10 = y1 - y0;
 363     jfloat x10p = x1p - x0p;
 364     jfloat y10p = y1p - y0p;
 365 
 366     // if this is 0, the lines are parallel. If they go in the
 367     // same direction, there is no intersection so m[off] and
 368     // m[off+1] will contain infinity, so no miter will be drawn.
 369     // If they go in the same direction that means that the start of the
 370     // current segment and the end of the previous segment have the same
 371     // tangent, in which case this method won&#39;t even be involved in
 372     // miter drawing because it won&#39;t be called by drawMiter (because
 373     // (mx == omx &amp;&amp; my == omy) will be true, and drawMiter will return
 374     // immediately).
 375     jfloat den = x10*y10p - x10p*y10;
 376     jfloat t = x10p*(y0-y0p) - y10p*(x0-x0p);
 377     t /= den;
 378     m[off++] = x0 + t*x10;
 379     m[off] = y0 + t*y10;
 380 }
 381 
 382 // Return the intersection point of the lines (x0, y0) -&gt; (x1, y1)
 383 // and (x0p, y0p) -&gt; (x1p, y1p) in m[0] and m[1]
 384 static void safecomputeMiter(const jfloat x0, const jfloat y0,
 385                              const jfloat x1, const jfloat y1,
 386                              const jfloat x0p, const jfloat y0p,
 387                              const jfloat x1p, const jfloat y1p,
 388                              jfloat m[], jint off)
 389 {
 390     jfloat x10 = x1 - x0;
 391     jfloat y10 = y1 - y0;
 392     jfloat x10p = x1p - x0p;
 393     jfloat y10p = y1p - y0p;
 394 
 395     // if this is 0, the lines are parallel. If they go in the
 396     // same direction, there is no intersection so m[off] and
 397     // m[off+1] will contain infinity, so no miter will be drawn.
 398     // If they go in the same direction that means that the start of the
 399     // current segment and the end of the previous segment have the same
 400     // tangent, in which case this method won&#39;t even be involved in
 401     // miter drawing because it won&#39;t be called by drawMiter (because
 402     // (mx == omx &amp;&amp; my == omy) will be true, and drawMiter will return
 403     // immediately).
 404     jfloat den = x10*y10p - x10p*y10;
 405     jfloat t;
 406 
 407     if (den == 0) {
 408         m[off++] = (x0 + x0p) / 2.0f;
 409         m[off] = (y0 + y0p) / 2.0f;
 410         return;
 411     }
 412     t = x10p*(y0-y0p) - y10p*(x0-x0p);
 413     t /= den;
 414     m[off++] = x0 + t*x10;
 415     m[off] = y0 + t*y10;
 416 }
 417 
<a name="30" id="anc30"></a><span class="line-modified"> 418 static void drawMiter(PathConsumer *pStroker,</span>
 419                       const jfloat pdx, const jfloat pdy,
 420                       const jfloat x0, const jfloat y0,
 421                       const jfloat dx, const jfloat dy,
 422                       jfloat omx, jfloat omy, jfloat mx, jfloat my,
 423                       jboolean rev)
 424 {
 425     jfloat lenSq;
 426 
 427     if ((mx == omx &amp;&amp; my == omy) ||
 428         (pdx == 0 &amp;&amp; pdy == 0) ||
 429         (dx == 0 &amp;&amp; dy == 0)) {
<a name="31" id="anc31"></a><span class="line-modified"> 430         return;</span>
 431     }
 432 
 433     if (rev) {
 434         omx = -omx;
 435         omy = -omy;
 436         mx = -mx;
 437         my = -my;
 438     }
 439 
 440     computeMiter((x0 - pdx) + omx, (y0 - pdy) + omy, x0 + omx, y0 + omy,
 441                  (dx + x0) + mx, (dy + y0) + my, x0 + mx, y0 + my,
 442                  this.miter, 0);
 443 
 444     lenSq = (this.miter[0]-x0)*(this.miter[0]-x0) + (this.miter[1]-y0)*(this.miter[1]-y0);
 445 
 446     if (lenSq &lt; this.miterLimitSq) {
<a name="32" id="anc32"></a><span class="line-modified"> 447         emitLineTo(pStroker, this.miter[0], this.miter[1], rev);</span>
 448     }
<a name="33" id="anc33"></a>
 449 }
 450 
<a name="34" id="anc34"></a><span class="line-modified"> 451 static void Stroker_moveTo(PathConsumer *pStroker, jfloat x0, jfloat y0) {</span>

 452     if (this.prev == DRAWING_OP_TO) {
<a name="35" id="anc35"></a><span class="line-modified"> 453         finish(pStroker);</span>



 454     }
 455     this.sx0 = this.cx0 = x0;
 456     this.sy0 = this.cy0 = y0;
 457     this.cdx = this.sdx = 1;
 458     this.cdy = this.sdy = 0;
 459     this.prev = MOVE_TO;
<a name="36" id="anc36"></a>
 460 }
 461 
<a name="37" id="anc37"></a><span class="line-modified"> 462 static void Stroker_lineTo(PathConsumer *pStroker, jfloat x1, jfloat y1) {</span>

 463     jfloat dx = x1 - this.cx0;
 464     jfloat dy = y1 - this.cy0;
 465     jfloat mx, my;
 466 
 467     if (dx == 0.0f &amp;&amp; dy == 0.0f) {
 468         dx = 1;
 469     }
 470     computeOffset(dx, dy, this.lineWidth2, this.offset[0]);
 471     mx = this.offset[0][0];
 472     my = this.offset[0][1];
 473 
<a name="38" id="anc38"></a><span class="line-modified"> 474     drawJoin(pStroker,</span>
 475              this.cdx, this.cdy, this.cx0, this.cy0,
 476              dx, dy, this.cmx, this.cmy, mx, my);
<a name="39" id="anc39"></a>


 477 
<a name="40" id="anc40"></a><span class="line-modified"> 478     emitLineTo(pStroker, this.cx0 + mx, this.cy0 + my, JNI_FALSE);</span>
<span class="line-modified"> 479     emitLineTo(pStroker, x1 + mx, y1 + my, JNI_FALSE);</span>






 480 
<a name="41" id="anc41"></a><span class="line-modified"> 481     emitLineTo(pStroker, this.cx0 - mx, this.cy0 - my, JNI_TRUE);</span>
<span class="line-modified"> 482     emitLineTo(pStroker, x1 - mx, y1 - my, JNI_TRUE);</span>






 483 
 484     this.cmx = mx;
 485     this.cmy = my;
 486     this.cdx = dx;
 487     this.cdy = dy;
 488     this.cx0 = x1;
 489     this.cy0 = y1;
 490     this.prev = DRAWING_OP_TO;
<a name="42" id="anc42"></a>
 491 }
 492 
<a name="43" id="anc43"></a><span class="line-modified"> 493 static void Stroker_closePath(PathConsumer *pStroker) {</span>

 494     if (this.prev != DRAWING_OP_TO) {
 495         if (this.prev == CLOSE) {
<a name="44" id="anc44"></a><span class="line-modified"> 496             return;</span>




 497         }
<a name="45" id="anc45"></a><span class="line-removed"> 498         emitMoveTo(pStroker, this.cx0, this.cy0 - this.lineWidth2);</span>
 499         this.cmx = this.smx = 0;
 500         this.cmy = this.smy = -this.lineWidth2;
 501         this.cdx = this.sdx = 1;
 502         this.cdy = this.sdy = 0;
<a name="46" id="anc46"></a><span class="line-modified"> 503         finish(pStroker);</span>
<span class="line-removed"> 504         return;</span>
 505     }
 506 
 507     if (this.cx0 != this.sx0 || this.cy0 != this.sy0) {
<a name="47" id="anc47"></a><span class="line-modified"> 508         Stroker_lineTo(pStroker, this.sx0, this.sy0);</span>



 509     }
 510 
<a name="48" id="anc48"></a><span class="line-modified"> 511     drawJoin(pStroker,</span>
 512              this.cdx, this.cdy, this.cx0, this.cy0,
 513              this.sdx, this.sdy, this.cmx, this.cmy,
 514              this.smx, this.smy);
<a name="49" id="anc49"></a>


 515 
<a name="50" id="anc50"></a><span class="line-modified"> 516     emitLineTo(pStroker, this.sx0 + this.smx, this.sy0 + this.smy, JNI_FALSE);</span>



 517 
<a name="51" id="anc51"></a><span class="line-modified"> 518     emitMoveTo(pStroker, this.sx0 - this.smx, this.sy0 - this.smy);</span>
<span class="line-modified"> 519     emitReverse(pStroker);</span>






 520 
 521     this.prev = CLOSE;
<a name="52" id="anc52"></a><span class="line-modified"> 522     emitClose(pStroker);</span>
 523 }
 524 
<a name="53" id="anc53"></a><span class="line-modified"> 525 static void emitReverse(PathConsumer *pStroker) {</span>

 526     while (!PolyStack_isEmpty(&amp;this.reverse)) {
<a name="54" id="anc54"></a><span class="line-modified"> 527         PolyStack_pop(&amp;this.reverse, this.out);</span>



 528     }
<a name="55" id="anc55"></a>
 529 }
 530 
<a name="56" id="anc56"></a><span class="line-modified"> 531 static void Stroker_pathDone(PathConsumer *pStroker) {</span>

 532     if (this.prev == DRAWING_OP_TO) {
<a name="57" id="anc57"></a><span class="line-modified"> 533         finish(pStroker);</span>



 534     }
 535 
<a name="58" id="anc58"></a><span class="line-modified"> 536     this.out-&gt;pathDone(this.out);</span>



 537     // this shouldn&#39;t matter since this object won&#39;t be used
 538     // after the call to this method.
 539     this.prev = CLOSE;
<a name="59" id="anc59"></a>
 540 }
 541 
<a name="60" id="anc60"></a><span class="line-modified"> 542 static void finish(PathConsumer *pStroker) {</span>

 543     if (this.capStyle == CAP_ROUND) {
<a name="61" id="anc61"></a><span class="line-modified"> 544         drawRoundCap(pStroker, this.cx0, this.cy0, this.cmx, this.cmy);</span>



 545     } else if (this.capStyle == CAP_SQUARE) {
<a name="62" id="anc62"></a><span class="line-modified"> 546         emitLineTo(pStroker, this.cx0 - this.cmy + this.cmx, this.cy0 + this.cmx + this.cmy, JNI_FALSE);</span>
<span class="line-modified"> 547         emitLineTo(pStroker, this.cx0 - this.cmy - this.cmx, this.cy0 + this.cmx - this.cmy, JNI_FALSE);</span>






 548     }
 549 
<a name="63" id="anc63"></a><span class="line-modified"> 550     emitReverse(pStroker);</span>



 551 
 552     if (this.capStyle == CAP_ROUND) {
<a name="64" id="anc64"></a><span class="line-modified"> 553         drawRoundCap(pStroker, this.sx0, this.sy0, -this.smx, -this.smy);</span>



 554     } else if (this.capStyle == CAP_SQUARE) {
<a name="65" id="anc65"></a><span class="line-modified"> 555         emitLineTo(pStroker, this.sx0 + this.smy - this.smx, this.sy0 - this.smx - this.smy, JNI_FALSE);</span>
<span class="line-modified"> 556         emitLineTo(pStroker, this.sx0 + this.smy + this.smx, this.sy0 - this.smx + this.smy, JNI_FALSE);</span>






 557     }
 558 
<a name="66" id="anc66"></a><span class="line-modified"> 559     emitClose(pStroker);</span>
 560 }
 561 
<a name="67" id="anc67"></a><span class="line-modified"> 562 static void emitMoveTo(PathConsumer *pStroker, const jfloat x0, const jfloat y0) {</span>
<span class="line-modified"> 563     this.out-&gt;moveTo(this.out, x0, y0);</span>
 564 }
 565 
<a name="68" id="anc68"></a><span class="line-modified"> 566 static void emitLineTo(PathConsumer *pStroker, const jfloat x1, const jfloat y1,</span>
 567                        const jboolean rev)
 568 {
 569     if (rev) {
<a name="69" id="anc69"></a><span class="line-modified"> 570         PolyStack_pushLine(&amp;this.reverse, x1, y1);</span>
 571     } else {
<a name="70" id="anc70"></a><span class="line-modified"> 572         this.out-&gt;lineTo(this.out, x1, y1);</span>
 573     }
 574 }
 575 
<a name="71" id="anc71"></a><span class="line-modified"> 576 static void emitQuadTo(PathConsumer *pStroker,</span>
 577                        const jfloat x0, const jfloat y0,
 578                        const jfloat x1, const jfloat y1,
 579                        const jfloat x2, const jfloat y2, const jboolean rev)
 580 {
 581     if (rev) {
<a name="72" id="anc72"></a><span class="line-modified"> 582         PolyStack_pushQuad(&amp;this.reverse, x0, y0, x1, y1);</span>
 583     } else {
<a name="73" id="anc73"></a><span class="line-modified"> 584         this.out-&gt;quadTo(this.out, x1, y1, x2, y2);</span>
 585     }
 586 }
 587 
<a name="74" id="anc74"></a><span class="line-modified"> 588 static void emitCurveTo(PathConsumer *pStroker,</span>
 589                         const jfloat x0, const jfloat y0,
 590                         const jfloat x1, const jfloat y1,
 591                         const jfloat x2, const jfloat y2,
 592                         const jfloat x3, const jfloat y3, const jboolean rev)
 593 {
 594     if (rev) {
<a name="75" id="anc75"></a><span class="line-modified"> 595         PolyStack_pushCubic(&amp;this.reverse, x0, y0, x1, y1, x2, y2);</span>
 596     } else {
<a name="76" id="anc76"></a><span class="line-modified"> 597         this.out-&gt;curveTo(this.out, x1, y1, x2, y2, x3, y3);</span>
 598     }
 599 }
 600 
<a name="77" id="anc77"></a><span class="line-modified"> 601 static void emitClose(PathConsumer *pStroker) {</span>
<span class="line-modified"> 602     this.out-&gt;closePath(this.out);</span>
 603 }
 604 
<a name="78" id="anc78"></a><span class="line-modified"> 605 static void drawJoin(PathConsumer *pStroker,</span>
 606                      jfloat pdx, jfloat pdy,
 607                      jfloat x0, jfloat y0,
 608                      jfloat dx, jfloat dy,
 609                      jfloat omx, jfloat omy,
 610                      jfloat mx, jfloat my)
 611 {
<a name="79" id="anc79"></a>
 612     if (this.prev != DRAWING_OP_TO) {
<a name="80" id="anc80"></a><span class="line-modified"> 613         emitMoveTo(pStroker, x0 + mx, y0 + my);</span>



 614         this.sdx = dx;
 615         this.sdy = dy;
 616         this.smx = mx;
 617         this.smy = my;
 618     } else {
 619         jboolean cw = isCW(pdx, pdy, dx, dy);
 620         if (this.joinStyle == JOIN_MITER) {
<a name="81" id="anc81"></a><span class="line-modified"> 621             drawMiter(pStroker, pdx, pdy, x0, y0, dx, dy, omx, omy, mx, my, cw);</span>



 622         } else if (this.joinStyle == JOIN_ROUND) {
<a name="82" id="anc82"></a><span class="line-modified"> 623             drawRoundJoin(pStroker,</span>
 624                           x0, y0,
 625                           omx, omy,
 626                           mx, my, cw,
 627                           ROUND_JOIN_THRESHOLD);
<a name="83" id="anc83"></a>






 628         }
<a name="84" id="anc84"></a><span class="line-removed"> 629         emitLineTo(pStroker, x0, y0, !cw);</span>
 630     }
 631     this.prev = DRAWING_OP_TO;
<a name="85" id="anc85"></a>
 632 }
 633 
 634 static jboolean withinULP(const jfloat x1, const jfloat y1,
 635                           const jfloat x2, const jfloat y2,
 636                           const int maxUlps)
 637 {
 638 //    assert maxUlps is much smaller than 0x7fffffff;
 639     // compare taxicab distance. ERR will always be small, so using
 640     // true distance won&#39;t give much benefit
 641     return (Helpers_withinULP(x1, x2, maxUlps) &amp;&amp;
 642             Helpers_withinULP(y1, y2, maxUlps));
 643 }
 644 
 645 static void getLineOffsets(PathConsumer *pStroker,
 646                            jfloat x1, jfloat y1,
 647                            jfloat x2, jfloat y2,
 648                            jfloat left[], jfloat right[]) {
 649     computeOffset(x2 - x1, y2 - y1, this.lineWidth2, this.offset[0]);
 650     left[0] = x1 + this.offset[0][0];
 651     left[1] = y1 + this.offset[0][1];
 652     left[2] = x2 + this.offset[0][0];
 653     left[3] = y2 + this.offset[0][1];
 654     right[0] = x1 - this.offset[0][0];
 655     right[1] = y1 - this.offset[0][1];
 656     right[2] = x2 - this.offset[0][0];
 657     right[3] = y2 - this.offset[0][1];
 658 }
 659 
 660 static jint computeOffsetCubic(PathConsumer *pStroker,
 661                                jfloat pts[], const jint off,
 662                                jfloat leftOff[], jfloat rightOff[])
 663 {
 664     jfloat dotsq, l1sq, l4sq;
 665     jfloat x, y, dxm, dym;
 666 
 667     // if p1=p2 or p3=p4 it means that the derivative at the endpoint
 668     // vanishes, which creates problems with computeOffset. Usually
 669     // this happens when this stroker object is trying to winden
 670     // a curve with a cusp. What happens is that curveTo splits
 671     // the input curve at the cusp, and passes it to this function.
 672     // because of inaccuracies in the splitting, we consider points
 673     // equal if they&#39;re very close to each other.
 674     const jfloat x1 = pts[off + 0], y1 = pts[off + 1];
 675     const jfloat x2 = pts[off + 2], y2 = pts[off + 3];
 676     const jfloat x3 = pts[off + 4], y3 = pts[off + 5];
 677     const jfloat x4 = pts[off + 6], y4 = pts[off + 7];
 678 
 679     jfloat dx4 = x4 - x3;
 680     jfloat dy4 = y4 - y3;
 681     jfloat dx1 = x2 - x1;
 682     jfloat dy1 = y2 - y1;
 683 
 684     // if p1 == p2 &amp;&amp; p3 == p4: draw line from p1-&gt;p4, unless p1 == p4,
 685     // in which case ignore if p1 == p2
 686     const jboolean p1eqp2 = withinULP(x1,y1,x2,y2, 6);
 687     const jboolean p3eqp4 = withinULP(x3,y3,x4,y4, 6);
 688     if (p1eqp2 &amp;&amp; p3eqp4) {
 689         getLineOffsets(pStroker, x1, y1, x4, y4, leftOff, rightOff);
 690         return 4;
 691     } else if (p1eqp2) {
 692         dx1 = x3 - x1;
 693         dy1 = y3 - y1;
 694     } else if (p3eqp4) {
 695         dx4 = x4 - x2;
 696         dy4 = y4 - y2;
 697     }
 698 
 699     // if p2-p1 and p4-p3 are parallel, that must mean this curve is a line
 700     dotsq = (dx1 * dx4 + dy1 * dy4);
 701     dotsq = dotsq * dotsq;
 702     l1sq = dx1 * dx1 + dy1 * dy1;
 703     l4sq = dx4 * dx4 + dy4 * dy4;
 704     if (Helpers_withinULP(dotsq, l1sq * l4sq, 4)) {
 705         getLineOffsets(pStroker, x1, y1, x4, y4, leftOff, rightOff);
 706         return 4;
 707     }
 708 
 709 //      What we&#39;re trying to do in this function is to approximate an ideal
 710 //      offset curve (call it I) of the input curve B using a bezier curve Bp.
 711 //      The constraints I use to get the equations are:
 712 //
 713 //      1. The computed curve Bp should go through I(0) and I(1). These are
 714 //      x1p, y1p, x4p, y4p, which are p1p and p4p. We still need to find
 715 //      4 variables: the x and y components of p2p and p3p (i.e. x2p, y2p, x3p, y3p).
 716 //
 717 //      2. Bp should have slope equal in absolute value to I at the endpoints. So,
 718 //      (by the way, the operator || in the comments below means &quot;aligned with&quot;.
 719 //      It is defined on vectors, so when we say I&#39;(0) || Bp&#39;(0) we mean that
 720 //      vectors I&#39;(0) and Bp&#39;(0) are aligned, which is the same as saying
 721 //      that the tangent lines of I and Bp at 0 are parallel. Mathematically
 722 //      this means (I&#39;(t) || Bp&#39;(t)) &lt;==&gt; (I&#39;(t) = c * Bp&#39;(t)) where c is some
 723 //      nonzero constant.)
 724 //      I&#39;(0) || Bp&#39;(0) and I&#39;(1) || Bp&#39;(1). Obviously, I&#39;(0) || B&#39;(0) and
 725 //      I&#39;(1) || B&#39;(1); therefore, Bp&#39;(0) || B&#39;(0) and Bp&#39;(1) || B&#39;(1).
 726 //      We know that Bp&#39;(0) || (p2p-p1p) and Bp&#39;(1) || (p4p-p3p) and the same
 727 //      is true for any bezier curve; therefore, we get the equations
 728 //          (1) p2p = c1 * (p2-p1) + p1p
 729 //          (2) p3p = c2 * (p4-p3) + p4p
 730 //      We know p1p, p4p, p2, p1, p3, and p4; therefore, this reduces the number
 731 //      of unknowns from 4 to 2 (i.e. just c1 and c2).
 732 //      To eliminate these 2 unknowns we use the following constraint:
 733 //
 734 //      3. Bp(0.5) == I(0.5). Bp(0.5)=(x,y) and I(0.5)=(xi,yi), and I should note
 735 //      that I(0.5) is *the only* reason for computing dxm,dym. This gives us
 736 //          (3) Bp(0.5) = (p1p + 3 * (p2p + p3p) + p4p)/8, which is equivalent to
 737 //          (4) p2p + p3p = (Bp(0.5)*8 - p1p - p4p) / 3
 738 //      We can substitute (1) and (2) from above into (4) and we get:
 739 //          (5) c1*(p2-p1) + c2*(p4-p3) = (Bp(0.5)*8 - p1p - p4p)/3 - p1p - p4p
 740 //      which is equivalent to
 741 //          (6) c1*(p2-p1) + c2*(p4-p3) = (4/3) * (Bp(0.5) * 2 - p1p - p4p)
 742 //
 743 //      The right side of this is a 2D vector, and we know I(0.5), which gives us
 744 //      Bp(0.5), which gives us the value of the right side.
 745 //      The left side is just a matrix vector multiplication in disguise. It is
 746 //
 747 //      [x2-x1, x4-x3][c1]
 748 //      [y2-y1, y4-y3][c2]
 749 //      which, is equal to
 750 //      [dx1, dx4][c1]
 751 //      [dy1, dy4][c2]
 752 //      At this point we are left with a simple linear system and we solve it by
 753 //      getting the inverse of the matrix above. Then we use [c1,c2] to compute
 754 //      p2p and p3p.
 755 
 756     x = 0.125f * (x1 + 3 * (x2 + x3) + x4);
 757     y = 0.125f * (y1 + 3 * (y2 + y3) + y4);
 758     // (dxm,dym) is some tangent of B at t=0.5. This means it&#39;s equal to
 759     // c*B&#39;(0.5) for some constant c.
 760     dxm = x3 + x4 - x1 - x2;
 761     dym = y3 + y4 - y1 - y2;
 762 
 763     // this computes the offsets at t=0, 0.5, 1, using the property that
 764     // for any bezier curve the vectors p2-p1 and p4-p3 are parallel to
 765     // the (dx/dt, dy/dt) vectors at the endpoints.
 766     computeOffset(dx1, dy1, this.lineWidth2, this.offset[0]);
 767     computeOffset(dxm, dym, this.lineWidth2, this.offset[1]);
 768     computeOffset(dx4, dy4, this.lineWidth2, this.offset[2]);
 769     {
 770         jfloat x1p = x1 + this.offset[0][0]; // start
 771         jfloat y1p = y1 + this.offset[0][1]; // point
 772         jfloat xi  = x  + this.offset[1][0]; // interpolation
 773         jfloat yi  = y  + this.offset[1][1]; // point
 774         jfloat x4p = x4 + this.offset[2][0]; // end
 775         jfloat y4p = y4 + this.offset[2][1]; // point
 776 
 777         jfloat invdet43 = 4.0f / (3.0f * (dx1 * dy4 - dy1 * dx4));
 778 
 779         jfloat two_pi_m_p1_m_p4x = 2*xi - x1p - x4p;
 780         jfloat two_pi_m_p1_m_p4y = 2*yi - y1p - y4p;
 781         jfloat c1 = invdet43 * (dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y);
 782         jfloat c2 = invdet43 * (dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x);
 783 
 784         jfloat x2p, y2p, x3p, y3p;
 785         x2p = x1p + c1*dx1;
 786         y2p = y1p + c1*dy1;
 787         x3p = x4p + c2*dx4;
 788         y3p = y4p + c2*dy4;
 789 
 790         leftOff[0] = x1p; leftOff[1] = y1p;
 791         leftOff[2] = x2p; leftOff[3] = y2p;
 792         leftOff[4] = x3p; leftOff[5] = y3p;
 793         leftOff[6] = x4p; leftOff[7] = y4p;
 794 
 795         x1p = x1 -     this.offset[0][0]; y1p = y1 -     this.offset[0][1];
 796         xi  = xi - 2 * this.offset[1][0]; yi  = yi - 2 * this.offset[1][1];
 797         x4p = x4 -     this.offset[2][0]; y4p = y4 -     this.offset[2][1];
 798 
 799         two_pi_m_p1_m_p4x = 2*xi - x1p - x4p;
 800         two_pi_m_p1_m_p4y = 2*yi - y1p - y4p;
 801         c1 = invdet43 * (dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y);
 802         c2 = invdet43 * (dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x);
 803 
 804         x2p = x1p + c1*dx1;
 805         y2p = y1p + c1*dy1;
 806         x3p = x4p + c2*dx4;
 807         y3p = y4p + c2*dy4;
 808 
 809         rightOff[0] = x1p; rightOff[1] = y1p;
 810         rightOff[2] = x2p; rightOff[3] = y2p;
 811         rightOff[4] = x3p; rightOff[5] = y3p;
 812         rightOff[6] = x4p; rightOff[7] = y4p;
 813     }
 814     return 8;
 815 }
 816 
 817 // compute offset curves using bezier spline through t=0.5 (i.e.
 818 // ComputedCurve(0.5) == IdealParallelCurve(0.5))
 819 // return the kind of curve in the right and left arrays.
 820 static jint computeOffsetQuad(PathConsumer *pStroker,
 821                               jfloat pts[], const jint off,
 822                               jfloat leftOff[], jfloat rightOff[])
 823 {
 824     const jfloat x1 = pts[off + 0], y1 = pts[off + 1];
 825     const jfloat x2 = pts[off + 2], y2 = pts[off + 3];
 826     const jfloat x3 = pts[off + 4], y3 = pts[off + 5];
 827     jfloat dotsq, l1sq, l3sq;
 828 
 829     jfloat dx3 = x3 - x2;
 830     jfloat dy3 = y3 - y2;
 831     jfloat dx1 = x2 - x1;
 832     jfloat dy1 = y2 - y1;
 833 
 834     // if p1=p2 or p3=p4 it means that the derivative at the endpoint
 835     // vanishes, which creates problems with computeOffset. Usually
 836     // this happens when this stroker object is trying to winden
 837     // a curve with a cusp. What happens is that curveTo splits
 838     // the input curve at the cusp, and passes it to this function.
 839     // because of inaccuracies in the splitting, we consider points
 840     // equal if they&#39;re very close to each other.
 841 
 842     // if p1 == p2 &amp;&amp; p3 == p4: draw line from p1-&gt;p4, unless p1 == p4,
 843     // in which case ignore.
 844     const jboolean p1eqp2 = withinULP(x1,y1,x2,y2, 6);
 845     const jboolean p2eqp3 = withinULP(x2,y2,x3,y3, 6);
 846     if (p1eqp2 || p2eqp3) {
 847         getLineOffsets(pStroker, x1, y1, x3, y3, leftOff, rightOff);
 848         return 4;
 849     }
 850 
 851     // if p2-p1 and p4-p3 are parallel, that must mean this curve is a line
 852     dotsq = (dx1 * dx3 + dy1 * dy3);
 853     dotsq = dotsq * dotsq;
 854     l1sq = dx1 * dx1 + dy1 * dy1;
 855     l3sq = dx3 * dx3 + dy3 * dy3;
 856     if (Helpers_withinULP(dotsq, l1sq * l3sq, 4)) {
 857         getLineOffsets(pStroker, x1, y1, x3, y3, leftOff, rightOff);
 858         return 4;
 859     }
 860 
 861     // this computes the offsets at t=0, 0.5, 1, using the property that
 862     // for any bezier curve the vectors p2-p1 and p4-p3 are parallel to
 863     // the (dx/dt, dy/dt) vectors at the endpoints.
 864     computeOffset(dx1, dy1, this.lineWidth2, this.offset[0]);
 865     computeOffset(dx3, dy3, this.lineWidth2, this.offset[1]);
 866     {
 867         jfloat x1p = x1 + this.offset[0][0]; // start
 868         jfloat y1p = y1 + this.offset[0][1]; // point
 869         jfloat x3p = x3 + this.offset[1][0]; // end
 870         jfloat y3p = y3 + this.offset[1][1]; // point
 871 
 872         safecomputeMiter(x1p, y1p, x1p+dx1, y1p+dy1, x3p, y3p, x3p-dx3, y3p-dy3, leftOff, 2);
 873         leftOff[0] = x1p; leftOff[1] = y1p;
 874         leftOff[4] = x3p; leftOff[5] = y3p;
 875         x1p = x1 - this.offset[0][0]; y1p = y1 - this.offset[0][1];
 876         x3p = x3 - this.offset[1][0]; y3p = y3 - this.offset[1][1];
 877         safecomputeMiter(x1p, y1p, x1p+dx1, y1p+dy1, x3p, y3p, x3p-dx3, y3p-dy3, rightOff, 2);
 878         rightOff[0] = x1p; rightOff[1] = y1p;
 879         rightOff[4] = x3p; rightOff[5] = y3p;
 880     }
 881     return 6;
 882 }
 883 
 884 // This is where the curve to be processed is put. We give it
 885 // enough room to store 2 curves: one for the current subdivision, the
 886 // other for the rest of the curve.
 887 #define MAX_N_CURVES   11
 888 
 889 static jfloat middle[MAX_N_CURVES*8];
 890 static jfloat lp[8];
 891 static jfloat rp[8];
 892 static jfloat subdivTs[MAX_N_CURVES - 1];
 893 
 894 // The following variation of somethingTo() caused problems when this was
 895 // Java code as indicated by the following comment.  Now that this code has
 896 // been converted into C, we should look at investigating the potential
 897 // performance benefits of using this version instead of the &quot;safer&quot; version
 898 // that survived in the Java sources and is currently being used below.
 899     // If this class is compiled with ecj, then Hotspot crashes when OSR
 900     // compiling this function. See bugs 7004570 and 6675699
 901     // NOTE: until those are fixed, we should work around that by
 902     // manually inlining this into curveTo and quadTo.
 903 /******************************* WORKAROUND **********************************
 904     private void somethingTo(final int type) {
 905         // need these so we can update the state at the end of this method
 906         final float xf = middle[type-2], yf = middle[type-1];
 907         float dxs = middle[2] - middle[0];
 908         float dys = middle[3] - middle[1];
 909         float dxf = middle[type - 2] - middle[type - 4];
 910         float dyf = middle[type - 1] - middle[type - 3];
 911         switch(type) {
 912         case 6:
 913             if ((dxs == 0f &amp;&amp; dys == 0f) ||
 914                 (dxf == 0f &amp;&amp; dyf == 0f)) {
 915                dxs = dxf = middle[4] - middle[0];
 916                dys = dyf = middle[5] - middle[1];
 917             }
 918             break;
 919         case 8:
 920             boolean p1eqp2 = (dxs == 0f &amp;&amp; dys == 0f);
 921             boolean p3eqp4 = (dxf == 0f &amp;&amp; dyf == 0f);
 922             if (p1eqp2) {
 923                 dxs = middle[4] - middle[0];
 924                 dys = middle[5] - middle[1];
 925                 if (dxs == 0f &amp;&amp; dys == 0f) {
 926                     dxs = middle[6] - middle[0];
 927                     dys = middle[7] - middle[1];
 928                 }
 929             }
 930             if (p3eqp4) {
 931                 dxf = middle[6] - middle[2];
 932                 dyf = middle[7] - middle[3];
 933                 if (dxf == 0f &amp;&amp; dyf == 0f) {
 934                     dxf = middle[6] - middle[0];
 935                     dyf = middle[7] - middle[1];
 936                 }
 937             }
 938         }
 939         if (dxs == 0f &amp;&amp; dys == 0f) {
 940             // this happens iff the &quot;curve&quot; is just a point
 941             lineTo(middle[0], middle[1]);
 942             return;
 943         }
 944         // if these vectors are too small, normalize them, to avoid future
 945         // precision problems.
 946         if (Math.abs(dxs) &lt; 0.1f &amp;&amp; Math.abs(dys) &lt; 0.1f) {
 947             float len = (float)Math.sqrt(dxs*dxs + dys*dys);
 948             dxs /= len;
 949             dys /= len;
 950         }
 951         if (Math.abs(dxf) &lt; 0.1f &amp;&amp; Math.abs(dyf) &lt; 0.1f) {
 952             float len = (float)Math.sqrt(dxf*dxf + dyf*dyf);
 953             dxf /= len;
 954             dyf /= len;
 955         }
 956 
 957         computeOffset(dxs, dys, lineWidth2, offset[0]);
 958         final float mx = offset[0][0];
 959         final float my = offset[0][1];
 960         drawJoin(pStroker, cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, mx, my);
 961 
 962         int nSplits = findSubdivPoints(pStroker, middle, subdivTs, type, lineWidth2);
 963 
 964         int kind = 0;
 965         Iterator&lt;Integer&gt; it = Curve.breakPtsAtTs(middle, type, subdivTs, nSplits);
 966         while(it.hasNext()) {
 967             int curCurveOff = it.next();
 968 
 969             kind = 0;
 970             switch (type) {
 971             case 8:
 972                 kind = computeOffsetCubic(middle, curCurveOff, lp, rp);
 973                 break;
 974             case 6:
 975                 kind = computeOffsetQuad(middle, curCurveOff, lp, rp);
 976                 break;
 977             }
 978             if (kind != 0) {
 979                 emitLineTo(pStroker, lp[0], lp[1], JNI_FALSE);
 980                 switch(kind) {
 981                 case 8:
 982                     emitCurveTo(pStroker, lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], lp[6], lp[7], false);
 983                     emitCurveTo(pStroker, rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], rp[6], rp[7], true);
 984                     break;
 985                 case 6:
 986                     emitQuadTo(pStroker, lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], false);
 987                     emitQuadTo(pStroker, rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], true);
 988                     break;
 989                 case 4:
 990                     emitLineTo(pStroker, lp[2], lp[3], JNI_FALSE);
 991                     emitLineTo(pStroker, rp[0], rp[1], JNI_TRUE);
 992                     break;
 993                 }
 994                 emitLineTo(pStroker, rp[kind - 2], rp[kind - 1], true);
 995             }
 996         }
 997 
 998         this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;
 999         this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;
1000         this.cdx = dxf;
1001         this.cdy = dyf;
1002         this.cx0 = xf;
1003         this.cy0 = yf;
1004         this.prev = DRAWING_OP_TO;
1005     }
1006 ****************************** END WORKAROUND *******************************/
1007 
1008 // finds values of t where the curve in pts should be subdivided in order
1009 // to get good offset curves a distance of w away from the middle curve.
1010 // Stores the points in ts, and returns how many of them there were.
1011 static jint findSubdivPoints(PathConsumer *pStroker,
1012                              jfloat pts[], jfloat ts[],
1013                              const jint type, const jfloat w)
1014 {
1015     jint ret = 0;
1016 
1017     const jfloat x12 = pts[2] - pts[0];
1018     const jfloat y12 = pts[3] - pts[1];
1019     // if the curve is already parallel to either axis we gain nothing
1020     // from rotating it.
1021     if (y12 != 0.0f &amp;&amp; x12 != 0.0f) {
1022         // we rotate it so that the first vector in the control polygon is
1023         // parallel to the x-axis. This will ensure that rotated quarter
1024         // circles won&#39;t be subdivided.
1025         const jfloat hypot = (jfloat) sqrt(x12 * x12 + y12 * y12);
1026         const jfloat cos = x12 / hypot;
1027         const jfloat sin = y12 / hypot;
1028         const jfloat x1 = cos * pts[0] + sin * pts[1];
1029         const jfloat y1 = cos * pts[1] - sin * pts[0];
1030         const jfloat x2 = cos * pts[2] + sin * pts[3];
1031         const jfloat y2 = cos * pts[3] - sin * pts[2];
1032         const jfloat x3 = cos * pts[4] + sin * pts[5];
1033         const jfloat y3 = cos * pts[5] - sin * pts[4];
1034         switch(type) {
1035         case 8:
1036         {
1037             const jfloat x4 = cos * pts[6] + sin * pts[7];
1038             const jfloat y4 = cos * pts[7] - sin * pts[6];
1039             Curve_setcubic(&amp;this.c, x1, y1, x2, y2, x3, y3, x4, y4);
1040             break;
1041         }
1042         case 6:
1043             Curve_setquad(&amp;this.c, x1, y1, x2, y2, x3, y3);
1044             break;
1045         }
1046     } else {
1047         Curve_set(&amp;this.c, pts, type);
1048     }
1049 
1050     // we subdivide at values of t such that the remaining rotated
1051     // curves are monotonic in x and y.
1052     ret += Curve_dxRoots(&amp;this.c, ts, ret);
1053     ret += Curve_dyRoots(&amp;this.c, ts, ret);
1054     // subdivide at inflection points.
1055     if (type == 8) {
1056         // quadratic curves can&#39;t have inflection points
1057         ret += Curve_infPoints(&amp;this.c, ts, ret);
1058     }
1059 
1060     // now we must subdivide at points where one of the offset curves will have
1061     // a cusp. This happens at ts where the radius of curvature is equal to w.
1062     ret += Curve_rootsOfROCMinusW(&amp;this.c, ts, ret, w, 0.0001f);
1063 
1064     ret = Helpers_filterOutNotInAB(ts, 0, ret, 0.0001f, 0.9999f);
1065     Helpers_isort(ts, 0, ret);
1066     return ret;
1067 }
1068 
<a name="86" id="anc86"></a><span class="line-modified">1069 static void Stroker_curveTo(PathConsumer *pStroker,</span>
1070                            jfloat x1, jfloat y1,
1071                            jfloat x2, jfloat y2,
1072                            jfloat x3, jfloat y3)
1073 {
<a name="87" id="anc87"></a>
1074     jfloat xf, yf, dxs, dys, dxf, dyf;
1075     jfloat mx, my;
1076     jint nSplits;
1077     jfloat prevT;
1078     jint i, kind;
1079     jboolean p1eqp2, p3eqp4;
1080 
1081     middle[0] = this.cx0; middle[1] = this.cy0;
1082     middle[2] = x1;  middle[3] = y1;
1083     middle[4] = x2;  middle[5] = y2;
1084     middle[6] = x3;  middle[7] = y3;
1085 
1086     // inlined version of somethingTo(8);
1087     // See the NOTE on somethingTo
1088 
1089     // need these so we can update the state at the end of this method
1090     xf = middle[6], yf = middle[7];
1091     dxs = middle[2] - middle[0];
1092     dys = middle[3] - middle[1];
1093     dxf = middle[6] - middle[4];
1094     dyf = middle[7] - middle[5];
1095 
1096     p1eqp2 = (dxs == 0.0f &amp;&amp; dys == 0.0f);
1097     p3eqp4 = (dxf == 0.0f &amp;&amp; dyf == 0.0f);
1098     if (p1eqp2) {
1099         dxs = middle[4] - middle[0];
1100         dys = middle[5] - middle[1];
1101         if (dxs == 0.0f &amp;&amp; dys == 0.0f) {
1102             dxs = middle[6] - middle[0];
1103             dys = middle[7] - middle[1];
1104         }
1105     }
1106     if (p3eqp4) {
1107         dxf = middle[6] - middle[2];
1108         dyf = middle[7] - middle[3];
1109         if (dxf == 0.0f &amp;&amp; dyf == 0.0f) {
1110             dxf = middle[6] - middle[0];
1111             dyf = middle[7] - middle[1];
1112         }
1113     }
1114     if (dxs == 0.0f &amp;&amp; dys == 0.0f) {
1115         // this happens iff the &quot;curve&quot; is just a point
<a name="88" id="anc88"></a><span class="line-modified">1116         Stroker_lineTo(pStroker, middle[0], middle[1]);</span>
<span class="line-removed">1117         return;</span>
1118     }
1119 
1120     // if these vectors are too small, normalize them, to avoid future
1121     // precision problems.
1122     if (fabs(dxs) &lt; 0.1f &amp;&amp; fabs(dys) &lt; 0.1f) {
1123         jfloat len = (jfloat) sqrt(dxs*dxs + dys*dys);
1124         dxs /= len;
1125         dys /= len;
1126     }
1127     if (fabs(dxf) &lt; 0.1f &amp;&amp; fabs(dyf) &lt; 0.1f) {
1128         jfloat len = (jfloat) sqrt(dxf*dxf + dyf*dyf);
1129         dxf /= len;
1130         dyf /= len;
1131     }
1132 
1133     computeOffset(dxs, dys, this.lineWidth2, this.offset[0]);
1134     mx = this.offset[0][0];
1135     my = this.offset[0][1];
<a name="89" id="anc89"></a><span class="line-modified">1136     drawJoin(pStroker,</span>
1137              this.cdx, this.cdy, this.cx0, this.cy0,
1138              dxs, dys, this.cmx, this.cmy,
1139              mx, my);
<a name="90" id="anc90"></a>


1140 
1141     nSplits = findSubdivPoints(pStroker, middle, subdivTs, 8, this.lineWidth2);
1142     prevT = 0.0f;
1143     for (i = 0; i &lt; nSplits; i++) {
1144         jfloat t = subdivTs[i];
1145         Helpers_subdivideCubicAt((t - prevT) / (1 - prevT),
1146                                  middle, i*6,
1147                                  middle, i*6,
1148                                  middle, i*6+6);
1149         prevT = t;
1150     }
1151 
1152     kind = 0;
1153     for (i = 0; i &lt;= nSplits; i++) {
1154         kind = computeOffsetCubic(pStroker, middle, i*6, lp, rp);
1155         if (kind != 0) {
<a name="91" id="anc91"></a><span class="line-modified">1156             emitLineTo(pStroker, lp[0], lp[1], JNI_FALSE);</span>



1157             switch(kind) {
1158             case 8:
<a name="92" id="anc92"></a><span class="line-modified">1159                 emitCurveTo(pStroker, lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], lp[6], lp[7], JNI_FALSE);</span>
<span class="line-modified">1160                 emitCurveTo(pStroker, rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], rp[6], rp[7], JNI_TRUE);</span>






1161                 break;
1162             case 4:
<a name="93" id="anc93"></a><span class="line-modified">1163                 emitLineTo(pStroker, lp[2], lp[3], JNI_FALSE);</span>
<span class="line-modified">1164                 emitLineTo(pStroker, rp[0], rp[1], JNI_TRUE);</span>






1165                 break;
1166             }
<a name="94" id="anc94"></a><span class="line-modified">1167             emitLineTo(pStroker, rp[kind - 2], rp[kind - 1], JNI_TRUE);</span>



1168         }
1169     }
1170 
1171     this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;
1172     this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;
1173     this.cdx = dxf;
1174     this.cdy = dyf;
1175     this.cx0 = xf;
1176     this.cy0 = yf;
1177     this.prev = DRAWING_OP_TO;
<a name="95" id="anc95"></a>
1178 }
1179 
<a name="96" id="anc96"></a><span class="line-modified">1180 static void Stroker_quadTo(PathConsumer *pStroker,</span>
1181                           jfloat x1, jfloat y1,
1182                           jfloat x2, jfloat y2)
1183 {
<a name="97" id="anc97"></a>
1184     jfloat xf, yf, dxs, dys, dxf, dyf;
1185     jfloat mx, my;
1186     jint nSplits, i, kind;
1187     jfloat prevt;
1188 
1189     middle[0] = this.cx0; middle[1] = this.cy0;
1190     middle[2] = x1;  middle[3] = y1;
1191     middle[4] = x2;  middle[5] = y2;
1192 
1193     // inlined version of somethingTo(8);
1194     // See the NOTE on somethingTo
1195 
1196     // need these so we can update the state at the end of this method
1197     xf = middle[4], yf = middle[5];
1198     dxs = middle[2] - middle[0];
1199     dys = middle[3] - middle[1];
1200     dxf = middle[4] - middle[2];
1201     dyf = middle[5] - middle[3];
1202     if ((dxs == 0.0f &amp;&amp; dys == 0.0f) || (dxf == 0.0f &amp;&amp; dyf == 0.0f)) {
1203         dxs = dxf = middle[4] - middle[0];
1204         dys = dyf = middle[5] - middle[1];
1205     }
1206     if (dxs == 0.0f &amp;&amp; dys == 0.0f) {
1207         // this happens iff the &quot;curve&quot; is just a point
<a name="98" id="anc98"></a><span class="line-modified">1208         Stroker_lineTo(pStroker, middle[0], middle[1]);</span>
<span class="line-removed">1209         return;</span>
1210     }
1211     // if these vectors are too small, normalize them, to avoid future
1212     // precision problems.
1213     if (fabs(dxs) &lt; 0.1f &amp;&amp; fabs(dys) &lt; 0.1f) {
1214         jfloat len = (jfloat) sqrt(dxs*dxs + dys*dys);
1215         dxs /= len;
1216         dys /= len;
1217     }
1218     if (fabs(dxf) &lt; 0.1f &amp;&amp; fabs(dyf) &lt; 0.1f) {
1219         jfloat len = (jfloat) sqrt(dxf*dxf + dyf*dyf);
1220         dxf /= len;
1221         dyf /= len;
1222     }
1223 
1224     computeOffset(dxs, dys, this.lineWidth2, this.offset[0]);
1225     mx = this.offset[0][0];
1226     my = this.offset[0][1];
<a name="99" id="anc99"></a><span class="line-modified">1227     drawJoin(pStroker,</span>
1228              this.cdx, this.cdy, this.cx0, this.cy0,
1229              dxs, dys, this.cmx, this.cmy,
1230              mx, my);
<a name="100" id="anc100"></a>


1231 
1232     nSplits = findSubdivPoints(pStroker, middle, subdivTs, 6, this.lineWidth2);
1233     prevt = 0.0f;
1234     for (i = 0; i &lt; nSplits; i++) {
1235         jfloat t = subdivTs[i];
1236         Helpers_subdivideQuadAt((t - prevt) / (1 - prevt),
1237                                 middle, i*4,
1238                                 middle, i*4,
1239                                 middle, i*4+4);
1240         prevt = t;
1241     }
1242 
1243     kind = 0;
1244     for (i = 0; i &lt;= nSplits; i++) {
1245         kind = computeOffsetQuad(pStroker, middle, i*4, lp, rp);
1246         if (kind != 0) {
<a name="101" id="anc101"></a><span class="line-modified">1247             emitLineTo(pStroker, lp[0], lp[1], JNI_FALSE);</span>



1248             switch(kind) {
1249             case 6:
<a name="102" id="anc102"></a><span class="line-modified">1250                 emitQuadTo(pStroker, lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], JNI_FALSE);</span>
<span class="line-modified">1251                 emitQuadTo(pStroker, rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], JNI_TRUE);</span>






1252                 break;
1253             case 4:
<a name="103" id="anc103"></a><span class="line-modified">1254                 emitLineTo(pStroker, lp[2], lp[3], JNI_FALSE);</span>
<span class="line-modified">1255                 emitLineTo(pStroker, rp[0], rp[1], JNI_TRUE);</span>






1256                 break;
1257             }
<a name="104" id="anc104"></a><span class="line-modified">1258             emitLineTo(pStroker, rp[kind - 2], rp[kind - 1], JNI_TRUE);</span>



1259         }
1260     }
1261 
1262     this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;
1263     this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;
1264     this.cdx = dxf;
1265     this.cdy = dyf;
1266     this.cx0 = xf;
1267     this.cy0 = yf;
1268     this.prev = DRAWING_OP_TO;
<a name="105" id="anc105"></a>
1269 }
1270 
1271 // a stack of polynomial curves where each curve shares endpoints with
1272 // adjacent ones.
1273 /*
1274     private static const class PolyStack {
1275         jfloat[] curves;
1276         int end;
1277         int[] curveTypes;
1278         int numCurves;
1279  */
1280 
1281 #define INIT_SIZE   50
1282 
1283 #undef this
1284 #define this (*((PolyStack *)pStack))
1285 
1286 void PolyStack_init(PolyStack *pStack) {
1287     this.curves = new_float(8 * INIT_SIZE);
1288     this.curvesSIZE = 8 * INIT_SIZE;
1289     this.curveTypes = new_int(INIT_SIZE);
1290     this.curveTypesSIZE = INIT_SIZE;
1291     this.end = 0;
1292     this.numCurves = 0;
1293 }
1294 
1295 void PolyStack_destroy(PolyStack *pStack) {
1296     free(this.curves);
1297     this.curves = NULL;
1298     this.curvesSIZE = 0;
1299     free(this.curveTypes);
1300     this.curveTypes = NULL;
1301     this.curveTypesSIZE = 0;
1302 }
1303 
1304 jboolean PolyStack_isEmpty(PolyStack *pStack) {
1305     return this.numCurves == 0;
1306 }
1307 
<a name="106" id="anc106"></a><span class="line-modified">1308 static void ensureSpace(PolyStack *pStack, jint n) {</span>
1309     if (this.end + n &gt;= this.curvesSIZE) {
1310         jint newSize = (this.end + n) * 2;
1311         jfloat *newCurves = new_float(newSize);
<a name="107" id="anc107"></a>


1312         System_arraycopy(this.curves, 0, newCurves, 0, this.end);
1313         free(this.curves);
1314         this.curves = newCurves;
1315         this.curvesSIZE = newSize;
1316     }
1317     if (this.numCurves &gt;= this.curveTypesSIZE) {
1318         jint newSize = this.numCurves * 2;
1319         jint *newTypes = new_int(newSize);
<a name="108" id="anc108"></a>


1320         System_arraycopy(this.curveTypes, 0, newTypes, 0, this.numCurves);
1321         free(this.curveTypes);
1322         this.curveTypes = newTypes;
1323         this.curveTypesSIZE = newSize;
1324     }
<a name="109" id="anc109"></a>
1325 }
1326 
<a name="110" id="anc110"></a><span class="line-modified">1327 void PolyStack_pushCubic(PolyStack *pStack,</span>
1328                          jfloat x0, jfloat y0,
1329                          jfloat x1, jfloat y1,
1330                          jfloat x2, jfloat y2)
1331 {
<a name="111" id="anc111"></a><span class="line-modified">1332     ensureSpace(pStack, 6);</span>



1333     this.curveTypes[this.numCurves++] = 8;
1334     // assert(x0 == lastX &amp;&amp; y0 == lastY)
1335 
1336     // we reverse the coordinate order to make popping easier
1337     this.curves[this.end++] = x2;    this.curves[this.end++] = y2;
1338     this.curves[this.end++] = x1;    this.curves[this.end++] = y1;
1339     this.curves[this.end++] = x0;    this.curves[this.end++] = y0;
<a name="112" id="anc112"></a>
1340 }
1341 
<a name="113" id="anc113"></a><span class="line-modified">1342 void PolyStack_pushQuad(PolyStack *pStack,</span>
1343                         jfloat x0, jfloat y0,
1344                         jfloat x1, jfloat y1)
1345 {
<a name="114" id="anc114"></a><span class="line-modified">1346     ensureSpace(pStack, 4);</span>



1347     this.curveTypes[this.numCurves++] = 6;
1348     // assert(x0 == lastX &amp;&amp; y0 == lastY)
1349     this.curves[this.end++] = x1;    this.curves[this.end++] = y1;
1350     this.curves[this.end++] = x0;    this.curves[this.end++] = y0;
<a name="115" id="anc115"></a>
1351 }
1352 
<a name="116" id="anc116"></a><span class="line-modified">1353 void PolyStack_pushLine(PolyStack *pStack,</span>
1354                         jfloat x, jfloat y)
1355 {
<a name="117" id="anc117"></a><span class="line-modified">1356     ensureSpace(pStack, 2);</span>



1357     this.curveTypes[this.numCurves++] = 4;
1358     // assert(x0 == lastX &amp;&amp; y0 == lastY)
1359     this.curves[this.end++] = x;    this.curves[this.end++] = y;
<a name="118" id="anc118"></a>
1360 }
1361 
1362 //@SuppressWarnings(&quot;unused&quot;)
1363 /*
1364 jint PolyStack_pop(PolyStack *pStack, jfloat pts[]) {
1365     jint ret = this.curveTypes[this.numCurves - 1];
1366     this.numCurves--;
1367     this.end -= (ret - 2);
1368     System_arraycopy(curves, end, pts, 0, ret - 2);
1369     return ret;
1370 }
1371 */
1372 
<a name="119" id="anc119"></a><span class="line-modified">1373 void PolyStack_pop(PolyStack *pStack, PathConsumer *io) {</span>

1374     jint type;
1375 
1376     this.numCurves--;
1377     type = this.curveTypes[this.numCurves];
1378     this.end -= (type - 2);
1379     switch(type) {
1380     case 8:
<a name="120" id="anc120"></a><span class="line-modified">1381         io-&gt;curveTo(io,</span>
1382                     this.curves[this.end+0], this.curves[this.end+1],
1383                     this.curves[this.end+2], this.curves[this.end+3],
1384                     this.curves[this.end+4], this.curves[this.end+5]);
1385         break;
1386     case 6:
<a name="121" id="anc121"></a><span class="line-modified">1387         io-&gt;quadTo(io,</span>
1388                    this.curves[this.end+0], this.curves[this.end+1],
1389                    this.curves[this.end+2], this.curves[this.end+3]);
<a name="122" id="anc122"></a><span class="line-modified">1390             break;</span>
1391     case 4:
<a name="123" id="anc123"></a><span class="line-modified">1392         io-&gt;lineTo(io, this.curves[this.end], this.curves[this.end+1]);</span>
1393     }
<a name="124" id="anc124"></a>
1394 }
1395 
1396 //@Override
1397 /*
1398 public String toString() {
1399     String ret = &quot;&quot;;
1400     jint nc = numCurves;
1401     jint last = this.end;
1402     while (nc &gt; 0) {
1403         nc--;
1404         jint type = curveTypes[numCurves];
1405         last -= (type - 2);
1406         switch(type) {
1407         case 8:
1408             ret += &quot;cubic: &quot;;
1409             break;
1410         case 6:
1411             ret += &quot;quad: &quot;;
1412             break;
1413         case 4:
1414             ret += &quot;line: &quot;;
1415             break;
1416         }
1417         ret += Arrays.toString(Arrays.copyOfRange(curves, last, last+type-2)) + &quot;\n&quot;;
1418     }
1419     return ret;
1420 }
1421  */
<a name="125" id="anc125"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="125" type="hidden" />
</body>
</html>
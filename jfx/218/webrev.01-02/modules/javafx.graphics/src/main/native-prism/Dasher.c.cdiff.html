<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.graphics/src/main/native-prism/Dasher.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../native-prism-es2/ios/ios-window-system.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="NativePiscesRasterizer.c.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/native-prism/Dasher.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2014, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 160,93 ***</span>
      free(pDasher-&gt;firstSegmentsBuffer);
      pDasher-&gt;firstSegmentsBuffer = NULL;
      pDasher-&gt;firstSegmentsBufferSIZE = 0;
  }
  
<span class="line-modified">! static void emitSeg(PathConsumer *pDasher, jfloat buf[], jint off, jint type) {</span>
      switch (type) {
      case 8:
<span class="line-modified">!         this.out-&gt;curveTo(this.out,</span>
                            buf[off+0], buf[off+1],
                            buf[off+2], buf[off+3],
                            buf[off+4], buf[off+5]);
          break;
      case 6:
<span class="line-modified">!         this.out-&gt;quadTo(this.out,</span>
                           buf[off+0], buf[off+1],
                           buf[off+2], buf[off+3]);
          break;
      case 4:
<span class="line-modified">!         this.out-&gt;lineTo(this.out, buf[off], buf[off+1]);</span>
      }
  }
  
<span class="line-modified">! static void emitFirstSegments(PathConsumer *pDasher) {</span>
      jint i;
      for (i = 0; i &lt; this.firstSegidx; ) {
<span class="line-modified">!         emitSeg(pDasher, this.firstSegmentsBuffer, i+1, (jint) this.firstSegmentsBuffer[i]);</span>
          i += (((jint) this.firstSegmentsBuffer[i]) - 1);
      }
      this.firstSegidx = 0;
  }
  
  // precondition: pts must be in relative coordinates (relative to x0,y0)
  // fullCurve is true iff the curve in pts has not been split.
<span class="line-modified">! static void goTo(PathConsumer *pDasher, jfloat pts[], jint off, jint type) {</span>
      jfloat x = pts[off + type - 4];
      jfloat y = pts[off + type - 3];
      if (this.dashOn) {
          if (this.starting) {
              if (this.firstSegmentsBufferSIZE &lt; this.firstSegidx + (type-1)) {
                  jint newSize = (this.firstSegidx + (type-1)) * 2;
                  jfloat *newSegs = new_float(newSize);
                  System_arraycopy(this.firstSegmentsBuffer, 0, newSegs, 0, this.firstSegidx);
                  free(this.firstSegmentsBuffer);
                  this.firstSegmentsBuffer = newSegs;
                  this.firstSegmentsBufferSIZE = newSize;
              }
              this.firstSegmentsBuffer[this.firstSegidx++] = (jfloat) type;
              System_arraycopy(pts, off, this.firstSegmentsBuffer, this.firstSegidx, type - 2);
              this.firstSegidx += type - 2;
          } else {
              if (this.needsMoveTo) {
<span class="line-modified">!                 this.out-&gt;moveTo(this.out, this.x0, this.y0);</span>
                  this.needsMoveTo = JNI_FALSE;
              }
<span class="line-modified">!             emitSeg(pDasher, pts, off, type);</span>
          }
      } else {
          this.starting = JNI_FALSE;
          this.needsMoveTo = JNI_TRUE;
      }
      this.x0 = x;
      this.y0 = y;
  }
  
<span class="line-modified">! static void Dasher_MoveTo(PathConsumer *pDasher, jfloat newx0, jfloat newy0) {</span>
      if (this.firstSegidx &gt; 0) {
<span class="line-modified">!         this.out-&gt;moveTo(this.out, this.sx, this.sy);</span>
<span class="line-modified">!         emitFirstSegments(pDasher);</span>
      }
      this.needsMoveTo = JNI_TRUE;
      this.idx = this.startIdx;
      this.dashOn = this.startDashOn;
      this.phase = this.startPhase;
      this.sx = this.x0 = newx0;
      this.sy = this.y0 = newy0;
      this.starting = JNI_TRUE;
  }
  
<span class="line-modified">! static void Dasher_LineTo(PathConsumer *pDasher, jfloat x1, jfloat y1) {</span>
      jfloat cx, cy;
      jfloat dx = x1 - this.x0;
      jfloat dy = y1 - this.y0;
  
      jfloat len = (jfloat) sqrt(dx*dx + dy*dy);
  
      if (len == 0) {
<span class="line-modified">!         return;</span>
      }
  
      // The scaling factors needed to get the dx and dy of the
      // transformed dash segments.
      cx = dx / len;
<span class="line-new-header">--- 160,119 ---</span>
      free(pDasher-&gt;firstSegmentsBuffer);
      pDasher-&gt;firstSegmentsBuffer = NULL;
      pDasher-&gt;firstSegmentsBufferSIZE = 0;
  }
  
<span class="line-modified">! static jint emitSeg(PathConsumer *pDasher, jfloat buf[], jint off, jint type) {</span>
      switch (type) {
      case 8:
<span class="line-modified">!         return this.out-&gt;curveTo(this.out,</span>
                            buf[off+0], buf[off+1],
                            buf[off+2], buf[off+3],
                            buf[off+4], buf[off+5]);
          break;
      case 6:
<span class="line-modified">!         return this.out-&gt;quadTo(this.out,</span>
                           buf[off+0], buf[off+1],
                           buf[off+2], buf[off+3]);
          break;
      case 4:
<span class="line-modified">!         return this.out-&gt;lineTo(this.out, buf[off], buf[off+1]);</span>
      }
<span class="line-added">+     return ERROR_NONE;</span>
  }
  
<span class="line-modified">! static jint emitFirstSegments(PathConsumer *pDasher) {</span>
      jint i;
      for (i = 0; i &lt; this.firstSegidx; ) {
<span class="line-modified">!         jint status;</span>
<span class="line-added">+         status = emitSeg(pDasher, this.firstSegmentsBuffer, i+1, (jint) this.firstSegmentsBuffer[i]);</span>
<span class="line-added">+         if (status != ERROR_NONE) {</span>
<span class="line-added">+             return status;</span>
<span class="line-added">+         }</span>
          i += (((jint) this.firstSegmentsBuffer[i]) - 1);
      }
      this.firstSegidx = 0;
<span class="line-added">+     return ERROR_NONE;</span>
  }
  
  // precondition: pts must be in relative coordinates (relative to x0,y0)
  // fullCurve is true iff the curve in pts has not been split.
<span class="line-modified">! static jint goTo(PathConsumer *pDasher, jfloat pts[], jint off, jint type) {</span>
<span class="line-added">+     jint status = ERROR_NONE;</span>
      jfloat x = pts[off + type - 4];
      jfloat y = pts[off + type - 3];
      if (this.dashOn) {
          if (this.starting) {
              if (this.firstSegmentsBufferSIZE &lt; this.firstSegidx + (type-1)) {
                  jint newSize = (this.firstSegidx + (type-1)) * 2;
                  jfloat *newSegs = new_float(newSize);
<span class="line-added">+                 if (!newSegs) {</span>
<span class="line-added">+                     return ERROR_OOM;</span>
<span class="line-added">+                 }</span>
                  System_arraycopy(this.firstSegmentsBuffer, 0, newSegs, 0, this.firstSegidx);
                  free(this.firstSegmentsBuffer);
                  this.firstSegmentsBuffer = newSegs;
                  this.firstSegmentsBufferSIZE = newSize;
              }
              this.firstSegmentsBuffer[this.firstSegidx++] = (jfloat) type;
              System_arraycopy(pts, off, this.firstSegmentsBuffer, this.firstSegidx, type - 2);
              this.firstSegidx += type - 2;
          } else {
              if (this.needsMoveTo) {
<span class="line-modified">!                 status = this.out-&gt;moveTo(this.out, this.x0, this.y0);</span>
<span class="line-added">+                 if (status != ERROR_NONE) {</span>
<span class="line-added">+                     return status;</span>
<span class="line-added">+                 }</span>
                  this.needsMoveTo = JNI_FALSE;
              }
<span class="line-modified">!             status = emitSeg(pDasher, pts, off, type);</span>
<span class="line-added">+             if (status != ERROR_NONE) {</span>
<span class="line-added">+                 return status;</span>
<span class="line-added">+             }</span>
          }
      } else {
          this.starting = JNI_FALSE;
          this.needsMoveTo = JNI_TRUE;
      }
      this.x0 = x;
      this.y0 = y;
<span class="line-added">+     return status;</span>
  }
  
<span class="line-modified">! static jint Dasher_MoveTo(PathConsumer *pDasher, jfloat newx0, jfloat newy0) {</span>
<span class="line-added">+     jint status = ERROR_NONE;</span>
      if (this.firstSegidx &gt; 0) {
<span class="line-modified">!         status = this.out-&gt;moveTo(this.out, this.sx, this.sy);</span>
<span class="line-modified">!         if (status != ERROR_NONE) {</span>
<span class="line-added">+             return status;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         status = emitFirstSegments(pDasher);</span>
<span class="line-added">+         if (status != ERROR_NONE) {</span>
<span class="line-added">+             return status;</span>
<span class="line-added">+         }</span>
      }
      this.needsMoveTo = JNI_TRUE;
      this.idx = this.startIdx;
      this.dashOn = this.startDashOn;
      this.phase = this.startPhase;
      this.sx = this.x0 = newx0;
      this.sy = this.y0 = newy0;
      this.starting = JNI_TRUE;
<span class="line-added">+     return status;</span>
  }
  
<span class="line-modified">! static jint Dasher_LineTo(PathConsumer *pDasher, jfloat x1, jfloat y1) {</span>
<span class="line-added">+     jint status = ERROR_NONE;</span>
      jfloat cx, cy;
      jfloat dx = x1 - this.x0;
      jfloat dy = y1 - this.y0;
  
      jfloat len = (jfloat) sqrt(dx*dx + dy*dy);
  
      if (len == 0) {
<span class="line-modified">!         return status;</span>
      }
  
      // The scaling factors needed to get the dx and dy of the
      // transformed dash segments.
      cx = dx / len;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 256,19 ***</span>
          jfloat dashdx, dashdy;
          jfloat leftInThisDashSegment = this.dash[this.idx] - this.phase;
          if (len &lt;= leftInThisDashSegment) {
              this.curCurvepts[0] = x1;
              this.curCurvepts[1] = y1;
<span class="line-modified">!             goTo(pDasher, this.curCurvepts, 0, 4);</span>
              // Advance phase within current dash segment
              this.phase += len;
              if (len == leftInThisDashSegment) {
                  this.phase = 0.0f;
                  this.idx = (this.idx + 1) % this.numdashes;
                  this.dashOn = !this.dashOn;
              }
<span class="line-modified">!             return;</span>
          }
  
          dashdx = this.dash[this.idx] * cx;
          dashdy = this.dash[this.idx] * cy;
          if (this.phase == 0) {
<span class="line-new-header">--- 282,22 ---</span>
          jfloat dashdx, dashdy;
          jfloat leftInThisDashSegment = this.dash[this.idx] - this.phase;
          if (len &lt;= leftInThisDashSegment) {
              this.curCurvepts[0] = x1;
              this.curCurvepts[1] = y1;
<span class="line-modified">!             status = goTo(pDasher, this.curCurvepts, 0, 4);</span>
<span class="line-added">+             if (status != ERROR_NONE) {</span>
<span class="line-added">+                 return status;</span>
<span class="line-added">+             }</span>
              // Advance phase within current dash segment
              this.phase += len;
              if (len == leftInThisDashSegment) {
                  this.phase = 0.0f;
                  this.idx = (this.idx + 1) % this.numdashes;
                  this.dashOn = !this.dashOn;
              }
<span class="line-modified">!             return status;</span>
          }
  
          dashdx = this.dash[this.idx] * cx;
          dashdy = this.dash[this.idx] * cy;
          if (this.phase == 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 278,18 ***</span>
              jfloat p = leftInThisDashSegment / this.dash[this.idx];
              this.curCurvepts[0] = this.x0 + p * dashdx;
              this.curCurvepts[1] = this.y0 + p * dashdy;
          }
  
<span class="line-modified">!         goTo(pDasher, this.curCurvepts, 0, 4);</span>
  
          len -= leftInThisDashSegment;
          // Advance to next dash segment
          this.idx = (this.idx + 1) % this.numdashes;
          this.dashOn = !this.dashOn;
          this.phase = 0;
      }
  }
  
  static jboolean pointCurve(jfloat curve[], jint type) {
      jint i;
      for (i = 2; i &lt; type; i++) {
<span class="line-new-header">--- 307,22 ---</span>
              jfloat p = leftInThisDashSegment / this.dash[this.idx];
              this.curCurvepts[0] = this.x0 + p * dashdx;
              this.curCurvepts[1] = this.y0 + p * dashdy;
          }
  
<span class="line-modified">!         status = goTo(pDasher, this.curCurvepts, 0, 4);</span>
<span class="line-added">+         if (status != ERROR_NONE) {</span>
<span class="line-added">+             return status;</span>
<span class="line-added">+         }</span>
  
          len -= leftInThisDashSegment;
          // Advance to next dash segment
          this.idx = (this.idx + 1) % this.numdashes;
          this.dashOn = !this.dashOn;
          this.phase = 0;
      }
<span class="line-added">+     return status;</span>
  }
  
  static jboolean pointCurve(jfloat curve[], jint type) {
      jint i;
      for (i = 2; i &lt; type; i++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 302,18 ***</span>
  
  //    private LengthIterator li = null;
  
  // preconditions: curCurvepts must be an array of length at least 2 * type,
  // that contains the curve we want to dash in the first type elements
<span class="line-modified">! static void somethingTo(PathConsumer *pDasher, jint type) {</span>
      jint curCurveoff;
      jfloat lastSplitT;
      jfloat t;
      jfloat leftInThisDashSegment;
  
      if (pointCurve(this.curCurvepts, type)) {
<span class="line-modified">!         return;</span>
      }
      LIinitializeIterationOnCurve(&amp;this.li, this.curCurvepts, type);
  
      curCurveoff = 0; // initially the current curve is at curCurvepts[0...type]
      lastSplitT = 0;
<span class="line-new-header">--- 335,19 ---</span>
  
  //    private LengthIterator li = null;
  
  // preconditions: curCurvepts must be an array of length at least 2 * type,
  // that contains the curve we want to dash in the first type elements
<span class="line-modified">! static jint somethingTo(PathConsumer *pDasher, jint type) {</span>
<span class="line-added">+     jint status = ERROR_NONE;</span>
      jint curCurveoff;
      jfloat lastSplitT;
      jfloat t;
      jfloat leftInThisDashSegment;
  
      if (pointCurve(this.curCurvepts, type)) {
<span class="line-modified">!         return status;</span>
      }
      LIinitializeIterationOnCurve(&amp;this.li, this.curCurvepts, type);
  
      curCurveoff = 0; // initially the current curve is at curCurvepts[0...type]
      lastSplitT = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 324,67 ***</span>
              Helpers_subdivideAt((t - lastSplitT) / (1 - lastSplitT),
                                  this.curCurvepts, curCurveoff,
                                  this.curCurvepts, 0,
                                  this.curCurvepts, type, type);
              lastSplitT = t;
<span class="line-modified">!             goTo(pDasher, this.curCurvepts, 2, type);</span>
              curCurveoff = type;
          }
          // Advance to next dash segment
          this.idx = (this.idx + 1) % this.numdashes;
          this.dashOn = !this.dashOn;
          this.phase = 0;
          leftInThisDashSegment = this.dash[this.idx];
      }
<span class="line-modified">!     goTo(pDasher, this.curCurvepts, curCurveoff+2, type);</span>
      this.phase += LIlastSegLen(&amp;this.li);
      if (this.phase &gt;= this.dash[this.idx]) {
          this.phase = 0.0f;
          this.idx = (this.idx + 1) % this.numdashes;
          this.dashOn = !this.dashOn;
      }
  }
  
<span class="line-modified">! static void Dasher_CurveTo(PathConsumer *pDasher,</span>
                             jfloat x1, jfloat y1,
                             jfloat x2, jfloat y2,
                             jfloat x3, jfloat y3)
  {
      this.curCurvepts[0] = this.x0;   this.curCurvepts[1] = this.y0;
      this.curCurvepts[2] = x1;        this.curCurvepts[3] = y1;
      this.curCurvepts[4] = x2;        this.curCurvepts[5] = y2;
      this.curCurvepts[6] = x3;        this.curCurvepts[7] = y3;
<span class="line-modified">!     somethingTo(pDasher, 8);</span>
  }
  
<span class="line-modified">! static void Dasher_QuadTo(PathConsumer *pDasher,</span>
                            jfloat x1, jfloat y1,
                            jfloat x2, jfloat y2)
  {
      this.curCurvepts[0] = this.x0;   this.curCurvepts[1] = this.y0;
      this.curCurvepts[2] = x1;        this.curCurvepts[3] = y1;
      this.curCurvepts[4] = x2;        this.curCurvepts[5] = y2;
<span class="line-modified">!     somethingTo(pDasher, 6);</span>
  }
  
<span class="line-modified">! static void Dasher_ClosePath(PathConsumer *pDasher) {</span>
<span class="line-modified">!     Dasher_LineTo(pDasher, this.sx, this.sy);</span>
      if (this.firstSegidx &gt; 0) {
          if (!this.dashOn || this.needsMoveTo) {
<span class="line-modified">!             this.out-&gt;moveTo(this.out, this.sx, this.sy);</span>
          }
<span class="line-removed">-         emitFirstSegments(pDasher);</span>
      }
<span class="line-modified">!     Dasher_MoveTo(pDasher, this.sx, this.sy);</span>
  }
  
<span class="line-modified">! static void Dasher_PathDone(PathConsumer *pDasher) {</span>
      if (this.firstSegidx &gt; 0) {
<span class="line-modified">!         this.out-&gt;moveTo(this.out, this.sx, this.sy);</span>
<span class="line-modified">!         emitFirstSegments(pDasher);</span>
      }
<span class="line-modified">!     this.out-&gt;pathDone(this.out);</span>
  }
  
  
  /*
          public LengthIterator(jint reclimit, float err) {
<span class="line-new-header">--- 358,91 ---</span>
              Helpers_subdivideAt((t - lastSplitT) / (1 - lastSplitT),
                                  this.curCurvepts, curCurveoff,
                                  this.curCurvepts, 0,
                                  this.curCurvepts, type, type);
              lastSplitT = t;
<span class="line-modified">!             status = goTo(pDasher, this.curCurvepts, 2, type);</span>
<span class="line-added">+             if (status != ERROR_NONE) {</span>
<span class="line-added">+                 return status;</span>
<span class="line-added">+             }</span>
              curCurveoff = type;
          }
          // Advance to next dash segment
          this.idx = (this.idx + 1) % this.numdashes;
          this.dashOn = !this.dashOn;
          this.phase = 0;
          leftInThisDashSegment = this.dash[this.idx];
      }
<span class="line-modified">!     status = goTo(pDasher, this.curCurvepts, curCurveoff+2, type);</span>
<span class="line-added">+     if (status != ERROR_NONE) {</span>
<span class="line-added">+         return status;</span>
<span class="line-added">+     }</span>
      this.phase += LIlastSegLen(&amp;this.li);
      if (this.phase &gt;= this.dash[this.idx]) {
          this.phase = 0.0f;
          this.idx = (this.idx + 1) % this.numdashes;
          this.dashOn = !this.dashOn;
      }
<span class="line-added">+     return status;</span>
  }
  
<span class="line-modified">! static jint Dasher_CurveTo(PathConsumer *pDasher,</span>
                             jfloat x1, jfloat y1,
                             jfloat x2, jfloat y2,
                             jfloat x3, jfloat y3)
  {
      this.curCurvepts[0] = this.x0;   this.curCurvepts[1] = this.y0;
      this.curCurvepts[2] = x1;        this.curCurvepts[3] = y1;
      this.curCurvepts[4] = x2;        this.curCurvepts[5] = y2;
      this.curCurvepts[6] = x3;        this.curCurvepts[7] = y3;
<span class="line-modified">!     return somethingTo(pDasher, 8);</span>
  }
  
<span class="line-modified">! static jint Dasher_QuadTo(PathConsumer *pDasher,</span>
                            jfloat x1, jfloat y1,
                            jfloat x2, jfloat y2)
  {
      this.curCurvepts[0] = this.x0;   this.curCurvepts[1] = this.y0;
      this.curCurvepts[2] = x1;        this.curCurvepts[3] = y1;
      this.curCurvepts[4] = x2;        this.curCurvepts[5] = y2;
<span class="line-modified">!     return somethingTo(pDasher, 6);</span>
  }
  
<span class="line-modified">! static jint Dasher_ClosePath(PathConsumer *pDasher) {</span>
<span class="line-modified">!     jint status = ERROR_NONE;</span>
<span class="line-added">+     status = Dasher_LineTo(pDasher, this.sx, this.sy);</span>
<span class="line-added">+     if (status != ERROR_NONE) {</span>
<span class="line-added">+         return status;</span>
<span class="line-added">+     }</span>
      if (this.firstSegidx &gt; 0) {
          if (!this.dashOn || this.needsMoveTo) {
<span class="line-modified">!             status = this.out-&gt;moveTo(this.out, this.sx, this.sy);</span>
<span class="line-added">+             if (status != ERROR_NONE) {</span>
<span class="line-added">+                 return status;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         status = emitFirstSegments(pDasher);</span>
<span class="line-added">+         if (status != ERROR_NONE) {</span>
<span class="line-added">+             return status;</span>
          }
      }
<span class="line-modified">!     return Dasher_MoveTo(pDasher, this.sx, this.sy);</span>
  }
  
<span class="line-modified">! static jint Dasher_PathDone(PathConsumer *pDasher) {</span>
<span class="line-added">+     jint status = ERROR_NONE;</span>
      if (this.firstSegidx &gt; 0) {
<span class="line-modified">!         status = this.out-&gt;moveTo(this.out, this.sx, this.sy);</span>
<span class="line-modified">!         if (status != ERROR_NONE) {</span>
<span class="line-added">+             return status;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         status = emitFirstSegments(pDasher);</span>
<span class="line-added">+         if (status != ERROR_NONE) {</span>
<span class="line-added">+             return status;</span>
<span class="line-added">+         }</span>
      }
<span class="line-modified">!     return this.out-&gt;pathDone(this.out);</span>
  }
  
  
  /*
          public LengthIterator(jint reclimit, float err) {
</pre>
<center><a href="../native-prism-es2/ios/ios-window-system.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="NativePiscesRasterizer.c.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
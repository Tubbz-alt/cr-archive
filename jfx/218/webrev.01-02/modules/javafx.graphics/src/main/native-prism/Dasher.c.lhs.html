<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/native-prism/Dasher.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2014, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &lt;math.h&gt;
 27 #include &lt;stdlib.h&gt;
 28 #include &lt;string.h&gt;
 29 
 30 #include &quot;PathConsumer.h&quot;
 31 
 32 #include &quot;Helpers.h&quot;
 33 #include &quot;Dasher.h&quot;
 34 
 35 static void LIinitializeIterationOnCurve(LengthIterator *pLI, jfloat pts[], jint type);
 36 static jfloat LInext(LengthIterator *pLI, const jfloat len);
 37 static jfloat LIlastSegLen(LengthIterator *pLI);
 38 static void LIgoLeft(LengthIterator *pLI);
 39 static void LIgoToNextLeaf(LengthIterator *pLI);
 40 static jfloat LIonLeaf(LengthIterator *pLI);
 41 
 42 /**
 43  * The &lt;code&gt;Dasher&lt;/code&gt; class takes a series of linear commands
 44  * (&lt;code&gt;moveTo&lt;/code&gt;, &lt;code&gt;lineTo&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt; and
 45  * &lt;code&gt;end&lt;/code&gt;) and breaks them into smaller segments according to a
 46  * dash pattern array and a starting dash phase.
 47  *
 48  * &lt;p&gt; Issues: in J2Se, a zero length dash segment as drawn as a very
 49  * short dash, whereas Pisces does not draw anything.  The PostScript
 50  * semantics are unclear.
 51  *
 52  */
 53 
 54 static MoveToFunc       Dasher_MoveTo;
 55 static LineToFunc       Dasher_LineTo;
 56 static QuadToFunc       Dasher_QuadTo;
 57 static CurveToFunc      Dasher_CurveTo;
 58 static ClosePathFunc    Dasher_ClosePath;
 59 static PathDoneFunc     Dasher_PathDone;
 60 
 61 #define this (*(Dasher *)pDasher)
 62 
 63     /**
 64      * Constructs a &lt;code&gt;Dasher&lt;/code&gt;.
 65      *
 66      * @param out an output &lt;code&gt;PathConsumer2D&lt;/code&gt;.
 67      * @param dash an array of &lt;code&gt;float&lt;/code&gt;s containing the dash pattern
 68      * @param phase a &lt;code&gt;float&lt;/code&gt; containing the dash phase
 69     public Dasher(PathConsumer2D out, float[] dash, float phase) {
 70         this(out);
 71         reset(dash, phase);
 72     }
 73 
 74     public Dasher(PathConsumer2D out) {
 75         this.out = out;
 76 
 77         // we need curCurvepts to be able to contain 2 curves because when
 78         // dashing curves, we need to subdivide it
 79         curCurvepts = new float[8 * 2];
 80     }
 81      */
 82 
 83 void Dasher_init(Dasher *pDasher,
 84                  PathConsumer *out,
 85                  jfloat dash[], jint numdashes,
 86                  jfloat phase)
 87 {
 88     memset(pDasher, 0, sizeof(Dasher));
 89     PathConsumer_init(&amp;this.consumer,
 90                       Dasher_MoveTo,
 91                       Dasher_LineTo,
 92                       Dasher_QuadTo,
 93                       Dasher_CurveTo,
 94                       Dasher_ClosePath,
 95                       Dasher_PathDone);
 96 
 97     this.firstSegmentsBufferSIZE = 7;
 98     this.firstSegmentsBuffer = new_float(this.firstSegmentsBufferSIZE);
 99     this.firstSegidx = 0;
100 
101     this.out = out;
102     Dasher_reset(pDasher, dash, numdashes, phase);
103 }
104 
105 #define MAX_CYCLES 16000000.0f
106 void Dasher_reset(Dasher *pDasher, jfloat dash[], jint ndashes, jfloat phase) {
107     jint sidx;
108     jfloat d, sum, cycles;
109     jint i;
110 
111     // Normalize so 0 &lt;= phase &lt; dash[0]
112     sidx = 0;
113     this.dashOn = JNI_TRUE;
114     sum = 0.0f;
115     for (i = 0; i &lt; ndashes; i++) {
116         sum += dash[i];
117     }
118     cycles = phase / sum;
119     if (phase &lt; 0) {
120         if (-cycles &gt;= MAX_CYCLES) {
121             phase = 0;
122         } else {
123             jint fullcycles = (jint) floor(-cycles);
124             if ((fullcycles &amp; ndashes &amp; 1) != 0) {
125                 this.dashOn = !this.dashOn;
126             }
127             phase += fullcycles * sum;
128             while (phase &lt; 0) {
129                 if (--sidx &lt; 0) sidx = ndashes-1;
130                 phase += dash[sidx];
131                 this.dashOn = !this.dashOn;
132             }
133         }
134     } else if (phase &gt; 0) {
135         if (cycles &gt;= MAX_CYCLES) {
136             phase = 0;
137         } else {
138             jint fullcycles = (jint) floor(cycles);
139             if ((fullcycles &amp; ndashes &amp; 1) != 0) {
140                 this.dashOn = !this.dashOn;
141             }
142             phase -= fullcycles * sum;
143             while (phase &gt;= (d = dash[sidx])) {
144                 phase -= d;
145                 sidx = (sidx + 1) % ndashes;
146                 this.dashOn = !this.dashOn;
147             }
148         }
149     }
150 
151     this.dash = dash;
152     this.numdashes = ndashes;
153     this.startPhase = this.phase = phase;
154     this.startDashOn = this.dashOn;
155     this.startIdx = sidx;
156     this.starting = JNI_TRUE;
157 }
158 
159 void Dasher_destroy(Dasher *pDasher) {
160     free(pDasher-&gt;firstSegmentsBuffer);
161     pDasher-&gt;firstSegmentsBuffer = NULL;
162     pDasher-&gt;firstSegmentsBufferSIZE = 0;
163 }
164 
<a name="2" id="anc2"></a><span class="line-modified">165 static void emitSeg(PathConsumer *pDasher, jfloat buf[], jint off, jint type) {</span>
166     switch (type) {
167     case 8:
<a name="3" id="anc3"></a><span class="line-modified">168         this.out-&gt;curveTo(this.out,</span>
169                           buf[off+0], buf[off+1],
170                           buf[off+2], buf[off+3],
171                           buf[off+4], buf[off+5]);
172         break;
173     case 6:
<a name="4" id="anc4"></a><span class="line-modified">174         this.out-&gt;quadTo(this.out,</span>
175                          buf[off+0], buf[off+1],
176                          buf[off+2], buf[off+3]);
177         break;
178     case 4:
<a name="5" id="anc5"></a><span class="line-modified">179         this.out-&gt;lineTo(this.out, buf[off], buf[off+1]);</span>
180     }
<a name="6" id="anc6"></a>
181 }
182 
<a name="7" id="anc7"></a><span class="line-modified">183 static void emitFirstSegments(PathConsumer *pDasher) {</span>
184     jint i;
185     for (i = 0; i &lt; this.firstSegidx; ) {
<a name="8" id="anc8"></a><span class="line-modified">186         emitSeg(pDasher, this.firstSegmentsBuffer, i+1, (jint) this.firstSegmentsBuffer[i]);</span>




187         i += (((jint) this.firstSegmentsBuffer[i]) - 1);
188     }
189     this.firstSegidx = 0;
<a name="9" id="anc9"></a>
190 }
191 
192 // precondition: pts must be in relative coordinates (relative to x0,y0)
193 // fullCurve is true iff the curve in pts has not been split.
<a name="10" id="anc10"></a><span class="line-modified">194 static void goTo(PathConsumer *pDasher, jfloat pts[], jint off, jint type) {</span>

195     jfloat x = pts[off + type - 4];
196     jfloat y = pts[off + type - 3];
197     if (this.dashOn) {
198         if (this.starting) {
199             if (this.firstSegmentsBufferSIZE &lt; this.firstSegidx + (type-1)) {
200                 jint newSize = (this.firstSegidx + (type-1)) * 2;
201                 jfloat *newSegs = new_float(newSize);
<a name="11" id="anc11"></a>


202                 System_arraycopy(this.firstSegmentsBuffer, 0, newSegs, 0, this.firstSegidx);
203                 free(this.firstSegmentsBuffer);
204                 this.firstSegmentsBuffer = newSegs;
205                 this.firstSegmentsBufferSIZE = newSize;
206             }
207             this.firstSegmentsBuffer[this.firstSegidx++] = (jfloat) type;
208             System_arraycopy(pts, off, this.firstSegmentsBuffer, this.firstSegidx, type - 2);
209             this.firstSegidx += type - 2;
210         } else {
211             if (this.needsMoveTo) {
<a name="12" id="anc12"></a><span class="line-modified">212                 this.out-&gt;moveTo(this.out, this.x0, this.y0);</span>



213                 this.needsMoveTo = JNI_FALSE;
214             }
<a name="13" id="anc13"></a><span class="line-modified">215             emitSeg(pDasher, pts, off, type);</span>



216         }
217     } else {
218         this.starting = JNI_FALSE;
219         this.needsMoveTo = JNI_TRUE;
220     }
221     this.x0 = x;
222     this.y0 = y;
<a name="14" id="anc14"></a>
223 }
224 
<a name="15" id="anc15"></a><span class="line-modified">225 static void Dasher_MoveTo(PathConsumer *pDasher, jfloat newx0, jfloat newy0) {</span>

226     if (this.firstSegidx &gt; 0) {
<a name="16" id="anc16"></a><span class="line-modified">227         this.out-&gt;moveTo(this.out, this.sx, this.sy);</span>
<span class="line-modified">228         emitFirstSegments(pDasher);</span>






229     }
230     this.needsMoveTo = JNI_TRUE;
231     this.idx = this.startIdx;
232     this.dashOn = this.startDashOn;
233     this.phase = this.startPhase;
234     this.sx = this.x0 = newx0;
235     this.sy = this.y0 = newy0;
236     this.starting = JNI_TRUE;
<a name="17" id="anc17"></a>
237 }
238 
<a name="18" id="anc18"></a><span class="line-modified">239 static void Dasher_LineTo(PathConsumer *pDasher, jfloat x1, jfloat y1) {</span>

240     jfloat cx, cy;
241     jfloat dx = x1 - this.x0;
242     jfloat dy = y1 - this.y0;
243 
244     jfloat len = (jfloat) sqrt(dx*dx + dy*dy);
245 
246     if (len == 0) {
<a name="19" id="anc19"></a><span class="line-modified">247         return;</span>
248     }
249 
250     // The scaling factors needed to get the dx and dy of the
251     // transformed dash segments.
252     cx = dx / len;
253     cy = dy / len;
254 
255     while (1) {
256         jfloat dashdx, dashdy;
257         jfloat leftInThisDashSegment = this.dash[this.idx] - this.phase;
258         if (len &lt;= leftInThisDashSegment) {
259             this.curCurvepts[0] = x1;
260             this.curCurvepts[1] = y1;
<a name="20" id="anc20"></a><span class="line-modified">261             goTo(pDasher, this.curCurvepts, 0, 4);</span>



262             // Advance phase within current dash segment
263             this.phase += len;
264             if (len == leftInThisDashSegment) {
265                 this.phase = 0.0f;
266                 this.idx = (this.idx + 1) % this.numdashes;
267                 this.dashOn = !this.dashOn;
268             }
<a name="21" id="anc21"></a><span class="line-modified">269             return;</span>
270         }
271 
272         dashdx = this.dash[this.idx] * cx;
273         dashdy = this.dash[this.idx] * cy;
274         if (this.phase == 0) {
275             this.curCurvepts[0] = this.x0 + dashdx;
276             this.curCurvepts[1] = this.y0 + dashdy;
277         } else {
278             jfloat p = leftInThisDashSegment / this.dash[this.idx];
279             this.curCurvepts[0] = this.x0 + p * dashdx;
280             this.curCurvepts[1] = this.y0 + p * dashdy;
281         }
282 
<a name="22" id="anc22"></a><span class="line-modified">283         goTo(pDasher, this.curCurvepts, 0, 4);</span>



284 
285         len -= leftInThisDashSegment;
286         // Advance to next dash segment
287         this.idx = (this.idx + 1) % this.numdashes;
288         this.dashOn = !this.dashOn;
289         this.phase = 0;
290     }
<a name="23" id="anc23"></a>
291 }
292 
293 static jboolean pointCurve(jfloat curve[], jint type) {
294     jint i;
295     for (i = 2; i &lt; type; i++) {
296         if (curve[i] != curve[i-2]) {
297             return JNI_FALSE;
298         }
299     }
300     return JNI_TRUE;
301 }
302 
303 //    private LengthIterator li = null;
304 
305 // preconditions: curCurvepts must be an array of length at least 2 * type,
306 // that contains the curve we want to dash in the first type elements
<a name="24" id="anc24"></a><span class="line-modified">307 static void somethingTo(PathConsumer *pDasher, jint type) {</span>

308     jint curCurveoff;
309     jfloat lastSplitT;
310     jfloat t;
311     jfloat leftInThisDashSegment;
312 
313     if (pointCurve(this.curCurvepts, type)) {
<a name="25" id="anc25"></a><span class="line-modified">314         return;</span>
315     }
316     LIinitializeIterationOnCurve(&amp;this.li, this.curCurvepts, type);
317 
318     curCurveoff = 0; // initially the current curve is at curCurvepts[0...type]
319     lastSplitT = 0;
320     t = 0;
321     leftInThisDashSegment = this.dash[this.idx] - this.phase;
322     while ((t = LInext(&amp;this.li, leftInThisDashSegment)) &lt; 1) {
323         if (t != 0) {
324             Helpers_subdivideAt((t - lastSplitT) / (1 - lastSplitT),
325                                 this.curCurvepts, curCurveoff,
326                                 this.curCurvepts, 0,
327                                 this.curCurvepts, type, type);
328             lastSplitT = t;
<a name="26" id="anc26"></a><span class="line-modified">329             goTo(pDasher, this.curCurvepts, 2, type);</span>



330             curCurveoff = type;
331         }
332         // Advance to next dash segment
333         this.idx = (this.idx + 1) % this.numdashes;
334         this.dashOn = !this.dashOn;
335         this.phase = 0;
336         leftInThisDashSegment = this.dash[this.idx];
337     }
<a name="27" id="anc27"></a><span class="line-modified">338     goTo(pDasher, this.curCurvepts, curCurveoff+2, type);</span>



339     this.phase += LIlastSegLen(&amp;this.li);
340     if (this.phase &gt;= this.dash[this.idx]) {
341         this.phase = 0.0f;
342         this.idx = (this.idx + 1) % this.numdashes;
343         this.dashOn = !this.dashOn;
344     }
<a name="28" id="anc28"></a>
345 }
346 
<a name="29" id="anc29"></a><span class="line-modified">347 static void Dasher_CurveTo(PathConsumer *pDasher,</span>
348                            jfloat x1, jfloat y1,
349                            jfloat x2, jfloat y2,
350                            jfloat x3, jfloat y3)
351 {
352     this.curCurvepts[0] = this.x0;   this.curCurvepts[1] = this.y0;
353     this.curCurvepts[2] = x1;        this.curCurvepts[3] = y1;
354     this.curCurvepts[4] = x2;        this.curCurvepts[5] = y2;
355     this.curCurvepts[6] = x3;        this.curCurvepts[7] = y3;
<a name="30" id="anc30"></a><span class="line-modified">356     somethingTo(pDasher, 8);</span>
357 }
358 
<a name="31" id="anc31"></a><span class="line-modified">359 static void Dasher_QuadTo(PathConsumer *pDasher,</span>
360                           jfloat x1, jfloat y1,
361                           jfloat x2, jfloat y2)
362 {
363     this.curCurvepts[0] = this.x0;   this.curCurvepts[1] = this.y0;
364     this.curCurvepts[2] = x1;        this.curCurvepts[3] = y1;
365     this.curCurvepts[4] = x2;        this.curCurvepts[5] = y2;
<a name="32" id="anc32"></a><span class="line-modified">366     somethingTo(pDasher, 6);</span>
367 }
368 
<a name="33" id="anc33"></a><span class="line-modified">369 static void Dasher_ClosePath(PathConsumer *pDasher) {</span>
<span class="line-modified">370     Dasher_LineTo(pDasher, this.sx, this.sy);</span>




371     if (this.firstSegidx &gt; 0) {
372         if (!this.dashOn || this.needsMoveTo) {
<a name="34" id="anc34"></a><span class="line-modified">373             this.out-&gt;moveTo(this.out, this.sx, this.sy);</span>







374         }
<a name="35" id="anc35"></a><span class="line-removed">375         emitFirstSegments(pDasher);</span>
376     }
<a name="36" id="anc36"></a><span class="line-modified">377     Dasher_MoveTo(pDasher, this.sx, this.sy);</span>
378 }
379 
<a name="37" id="anc37"></a><span class="line-modified">380 static void Dasher_PathDone(PathConsumer *pDasher) {</span>

381     if (this.firstSegidx &gt; 0) {
<a name="38" id="anc38"></a><span class="line-modified">382         this.out-&gt;moveTo(this.out, this.sx, this.sy);</span>
<span class="line-modified">383         emitFirstSegments(pDasher);</span>






384     }
<a name="39" id="anc39"></a><span class="line-modified">385     this.out-&gt;pathDone(this.out);</span>
386 }
387 
388 
389 /*
390         public LengthIterator(jint reclimit, float err) {
391             this.limit = reclimit;
392             this.minTincrement = 1f / (1 &lt;&lt; limit);
393             this.ERR = err;
394             this.recCurveStack = new float[reclimit+1][8];
395             this.sides = new Side[reclimit];
396             // if any methods are called without first initializing this object on
397             // a curve, we want it to fail ASAP.
398             this.nextT = Float.MAX_VALUE;
399             this.lenAtNextT = Float.MAX_VALUE;
400             this.lenAtLastSplit = Float.MIN_VALUE;
401             this.recLevel = Integer.MIN_VALUE;
402             this.lastSegLen = Float.MAX_VALUE;
403             this.done = true;
404         }
405  */
406 
407 #undef this
408 #define this (*((LengthIterator *) pLI))
409 
410 static void LIinitializeIterationOnCurve(LengthIterator *pLI, jfloat pts[], jint type) {
411     System_arraycopy(pts, 0, this.recCurveStack[0], 0, type);
412     this.curveType = type;
413     this.recLevel = 0;
414     this.lastT = 0;
415     this.lenAtLastT = 0;
416     this.nextT = 0;
417     this.lenAtNextT = 0;
418     LIgoLeft(pLI); // initializes nextT and lenAtNextT properly
419     this.lenAtLastSplit = 0;
420     if (this.recLevel &gt; 0) {
421         this.sides[0] = LEFT;
422         this.done = JNI_FALSE;
423     } else {
424         // the root of the tree is a leaf so we&#39;re done.
425         this.sides[0] = RIGHT;
426         this.done = JNI_TRUE;
427     }
428     this.lastSegLen = 0;
429     this.cachedHaveLowAcceleration = -1;
430     /* = {0, 0, -1, 0}*/;
431     this.flatLeafCoefCache[0] = 0;
432     this.flatLeafCoefCache[1] = 0;
433     this.flatLeafCoefCache[2] = -1;
434     this.flatLeafCoefCache[3] = 0;
435 }
436 
437 static jboolean LIhaveLowAcceleration(LengthIterator *pLI, jfloat err) {
438     if (this.cachedHaveLowAcceleration == -1) {
439         const jfloat len1 = this.curLeafCtrlPolyLengths[0];
440         const jfloat len2 = this.curLeafCtrlPolyLengths[1];
441         // the test below is equivalent to !within(len1/len2, 1, err).
442         // It is using a multiplication instead of a division, so it
443         // should be a bit faster.
444         if (!Helpers_within(len1, len2, err*len2)) {
445             this.cachedHaveLowAcceleration = 0;
446             return JNI_FALSE;
447         }
448         if (this.curveType == 8) {
449             const jfloat len3 = this.curLeafCtrlPolyLengths[2];
450             // if len1 is close to 2 and 2 is close to 3, that probably
451             // means 1 is close to 3 so the second part of this test might
452             // not be needed, but it doesn&#39;t hurt to include it.
453             if (!(Helpers_within(len2, len3, err*len3) &amp;&amp;
454                   Helpers_within(len1, len3, err*len3)))
455             {
456                 this.cachedHaveLowAcceleration = 0;
457                 return JNI_FALSE;
458             }
459         }
460         this.cachedHaveLowAcceleration = 1;
461         return JNI_TRUE;
462     }
463 
464     return (this.cachedHaveLowAcceleration == 1);
465 }
466 
467 // returns the t value where the remaining curve should be split in
468 // order for the left subdivided curve to have length len. If len
469 // is &gt;= than the length of the uniterated curve, it returns 1.
470 static jfloat LInext(LengthIterator *pLI, const jfloat len) {
471     const jfloat targetLength = this.lenAtLastSplit + len;
472     jfloat leaflen;
473     jfloat t;
474     while(this.lenAtNextT &lt; targetLength) {
475         if (this.done) {
476             this.lastSegLen = this.lenAtNextT - this.lenAtLastSplit;
477             return 1;
478         }
479         LIgoToNextLeaf(pLI);
480     }
481     this.lenAtLastSplit = targetLength;
482     leaflen = this.lenAtNextT - this.lenAtLastT;
483     t = (targetLength - this.lenAtLastT) / leaflen;
484 
485     // cubicRootsInAB is a fairly expensive call, so we just don&#39;t do it
486     // if the acceleration in this section of the curve is small enough.
487     if (!LIhaveLowAcceleration(pLI, 0.05f)) {
488         jfloat a, b, c, d;
489         jint n;
490         // We flatten the current leaf along the x axis, so that we&#39;re
491         // left with a, b, c which define a 1D Bezier curve. We then
492         // solve this to get the parameter of the original leaf that
493         // gives us the desired length.
494 
495         if (this.flatLeafCoefCache[2] &lt; 0) {
496             jfloat x = 0+this.curLeafCtrlPolyLengths[0],
497                     y = x+this.curLeafCtrlPolyLengths[1];
498             if (this.curveType == 8) {
499                 jfloat z = y + this.curLeafCtrlPolyLengths[2];
500                 this.flatLeafCoefCache[0] = 3*(x - y) + z;
501                 this.flatLeafCoefCache[1] = 3*(y - 2*x);
502                 this.flatLeafCoefCache[2] = 3*x;
503                 this.flatLeafCoefCache[3] = -z;
504             } else if (this.curveType == 6) {
505                 this.flatLeafCoefCache[0] = 0.0f;
506                 this.flatLeafCoefCache[1] = y - 2*x;
507                 this.flatLeafCoefCache[2] = 2*x;
508                 this.flatLeafCoefCache[3] = -y;
509             }
510         }
511         a = this.flatLeafCoefCache[0];
512         b = this.flatLeafCoefCache[1];
513         c = this.flatLeafCoefCache[2];
514         d = t*this.flatLeafCoefCache[3];
515 
516         // we use cubicRootsInAB here, because we want only roots in 0, 1,
517         // and our quadratic root finder doesn&#39;t filter, so it&#39;s just a
518         // matter of convenience.
519         n = Helpers_cubicRootsInAB(a, b, c, d, this.nextRoots, 0, 0, 1);
520         if (n == 1 &amp;&amp; !Math_isnan(this.nextRoots[0])) {
521             t = this.nextRoots[0];
522         }
523     }
524     // t is relative to the current leaf, so we must make it a valid parameter
525     // of the original curve.
526     t = t * (this.nextT - this.lastT) + this.lastT;
527     if (t &gt;= 1) {
528         t = 1;
529         this.done = JNI_TRUE;
530     }
531     // even if done = true, if we&#39;re here, that means targetLength
532     // is equal to, or very, very close to the total length of the
533     // curve, so lastSegLen won&#39;t be too high. In cases where len
534     // overshoots the curve, this method will exit in the while
535     // loop, and lastSegLen will still be set to the right value.
536     this.lastSegLen = len;
537     return t;
538 }
539 
540 static jfloat LIlastSegLen(LengthIterator *pLI) {
541     return this.lastSegLen;
542 }
543 
544 // go to the next leaf (in an inorder traversal) in the recursion tree
545 // preconditions: must be on a leaf, and that leaf must not be the root.
546 static void LIgoToNextLeaf(LengthIterator *pLI) {
547     // We must go to the first ancestor node that has an unvisited
548     // right child.
549     this.recLevel--;
550     while(this.sides[this.recLevel] == RIGHT) {
551         if (this.recLevel == 0) {
552             this.done = JNI_TRUE;
553             return;
554         }
555         this.recLevel--;
556     }
557 
558     this.sides[this.recLevel] = RIGHT;
559     System_arraycopy(this.recCurveStack[this.recLevel], 0,
560                      this.recCurveStack[this.recLevel+1], 0, this.curveType);
561     this.recLevel++;
562     LIgoLeft(pLI);
563 }
564 
565 // go to the leftmost node from the current node. Return its length.
566 static void LIgoLeft(LengthIterator *pLI) {
567     jfloat len = LIonLeaf(pLI);
568     if (len &gt;= 0) {
569         this.lastT = this.nextT;
570         this.lenAtLastT = this.lenAtNextT;
571         this.nextT += (1 &lt;&lt; (REC_LIMIT - this.recLevel)) * MIN_T_INCREMENT;
572         this.lenAtNextT += len;
573         // invalidate caches
574         this.flatLeafCoefCache[2] = -1;
575         this.cachedHaveLowAcceleration = -1;
576     } else {
577         Helpers_subdivide(this.recCurveStack[this.recLevel], 0,
578                           this.recCurveStack[this.recLevel+1], 0,
579                           this.recCurveStack[this.recLevel], 0, this.curveType);
580         this.sides[this.recLevel] = LEFT;
581         this.recLevel++;
582         LIgoLeft(pLI);
583     }
584 }
585 
586 // this is a bit of a hack. It returns -1 if we&#39;re not on a leaf, and
587 // the length of the leaf if we are on a leaf.
588 static jfloat LIonLeaf(LengthIterator *pLI) {
589     jfloat *curve = this.recCurveStack[this.recLevel];
590     jfloat polyLen = 0;
591     jfloat lineLen;
592 
593     jfloat x0 = curve[0], y0 = curve[1];
594     jint i;
595     for (i = 2; i &lt; this.curveType; i += 2) {
596         const jfloat x1 = curve[i], y1 = curve[i+1];
597         const jfloat len = Helpers_linelen(x0, y0, x1, y1);
598         polyLen += len;
599         this.curLeafCtrlPolyLengths[i/2 - 1] = len;
600         x0 = x1;
601         y0 = y1;
602     }
603 
604     lineLen = Helpers_linelen(curve[0], curve[1], curve[this.curveType-2], curve[this.curveType-1]);
605     if (polyLen - lineLen &lt; ERR || this.recLevel == REC_LIMIT) {
606         return (polyLen + lineLen)/2;
607     }
608     return -1;
609 }
<a name="40" id="anc40"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="40" type="hidden" />
</body>
</html>
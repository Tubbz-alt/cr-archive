<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/native-prism/Renderer.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="PathConsumer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="Renderer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/native-prism/Renderer.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 53 
 54 static void ScanlineIterator_destroy(ScanlineIterator *pIterator) {
 55     free(this.crossings);
 56     this.crossings = NULL;
 57     this.crossingsSIZE = 0;
 58     free(this.edgePtrs);
 59     this.edgePtrs = NULL;
 60     this.edgePtrsSIZE = 0;
 61 }
 62 
 63 static void ScanlineIterator_reset(ScanlineIterator *pIterator,
 64                                    Renderer *pRenderer)
 65 {
 66     // We don&#39;t care if we clip some of the line off with ceil, since
 67     // no scan line crossings will be eliminated (in fact, the ceil is
 68     // the y of the first scan line crossing).
 69     this.nextY = pRenderer-&gt;sampleRowMin;
 70     this.edgeCount = 0;
 71 }
 72 


 73 static jint ScanlineIterator_next(ScanlineIterator *pIterator, Renderer *pRenderer) {
 74     jint i, ecur;
 75     jint *xings;
 76     // NOTE: make function that convert from y value to bucket idx?
 77     jint cury = this.nextY++;
 78     jint bucket = cury - pRenderer-&gt;boundsMinY;
 79     jint count = this.edgeCount;
 80     jint *ptrs = this.edgePtrs;
 81     jfloat *edges = pRenderer-&gt;edges;
 82     jint bucketcount = pRenderer-&gt;edgeBuckets[bucket*2 + 1];
 83 
 84     if ((bucketcount &amp; 0x1) != 0) {
 85         jint newCount = 0;
 86         jint i;
 87         for (i = 0; i &lt; count; i++) {
 88             jint ecur = ptrs[i];
 89             if (edges[ecur+YMAX] &gt; cury) {
 90                 ptrs[newCount++] = ecur;
 91             }
 92         }
 93         count = newCount;
 94     }
 95     if (this.edgePtrsSIZE &lt; count + (bucketcount &gt;&gt; 1)) {
 96         jint newSize = (count + (bucketcount &gt;&gt; 1)) * 2;
 97         jint *newPtrs = new_int(newSize);



 98         System_arraycopy(this.edgePtrs, 0, newPtrs, 0, count);
 99         free(this.edgePtrs);
100         this.edgePtrs = newPtrs;
101         this.edgePtrsSIZE = newSize;
102     }
103     ptrs = this.edgePtrs;
104     for (ecur = pRenderer-&gt;edgeBuckets[bucket*2];
105          ecur != 0;
106          ecur = (jint) edges[ecur+NEXT])
107     {
108         ptrs[count++] = --ecur;
109         // REMIND: Adjust start Y if necessary
110     }
111     this.edgePtrs = ptrs;
112     this.edgeCount = count;
113 //    if ((count &amp; 0x1) != 0) {
114 //        System.out.println(&quot;ODD NUMBER OF EDGES!!!!&quot;);
115 //    }
116     xings = this.crossings;
117     if (this.crossingsSIZE &lt; count) {
118         free(this.crossings);
119         this.crossings = xings = new_int(this.edgePtrsSIZE);



120         this.crossingsSIZE = this.edgePtrsSIZE;
121     }
122     for (i = 0; i &lt; count; i++) {
123         jint ecur = ptrs[i];
124         jfloat curx = edges[ecur+CURX];
125         jint cross = ((jint) ceil(curx - 0.5f)) &lt;&lt; 1;
126         jint j;
127         edges[ecur+CURX] = curx + edges[ecur+SLOPE];
128         if (edges[ecur+OR] &gt; 0) {
129             cross |= 1;
130         }
131         j = i;
132         while (--j &gt;= 0) {
133             jint jcross = xings[j];
134             if (jcross &lt;= cross) {
135                 break;
136             }
137             xings[j+1] = jcross;
138             ptrs[j+1] = ptrs[j];
139         }
</pre>
<hr />
<pre>
146 static jboolean ScanlineIterator_hasNext(ScanlineIterator *pIterator, Renderer *pRenderer) {
147     return this.nextY &lt; pRenderer-&gt;sampleRowMax;
148 }
149 
150 static jint ScanlineIterator_curY(ScanlineIterator *pIterator) {
151     return this.nextY - 1;
152 }
153 
154 #undef this
155 #define this (*((Renderer *) pRenderer))
156 
157 //////////////////////////////////////////////////////////////////////////////
158 //  EDGE LIST
159 //////////////////////////////////////////////////////////////////////////////
160 // NOTE(maybe): very tempting to use fixed point here. A lot of opportunities
161 // for shifts and just removing certain operations altogether.
162 
163 
164 // each bucket is a linked list. this method adds eptr to the
165 // start &quot;bucket&quot;th linked list.
<span class="line-modified">166 static void addEdgeToBucket(PathConsumer *pRenderer, const jint eptr, const jint bucket) {</span>
167     // we could implement this in terms of insertEdge, but this is a special
168     // case, so we optimize a bit.



169     this.edges[eptr+NEXT] = (jfloat) this.edgeBuckets[bucket*2];
170     this.edgeBuckets[bucket*2] = eptr + 1;
171     this.edgeBuckets[bucket*2 + 1] += 2;

172 }
173 
<span class="line-modified">174 static void addLine(PathConsumer *pRenderer,</span>
175                     jfloat x1, jfloat y1,
176                     jfloat x2, jfloat y2);
177 
178 // Flattens using adaptive forward differencing. This only carries out
179 // one iteration of the AFD loop. All it does is update AFD variables (i.e.
180 // X0, Y0, D*[X|Y], COUNT; not variables used for computing scanline crossings).
<span class="line-modified">181 static void quadBreakIntoLinesAndAdd(PathConsumer *pRenderer,</span>
182                                      jfloat x0, jfloat y0,
183                                      const Curve c,
184                                      const jfloat x2, const jfloat y2)
185 {

186     jfloat ddx, ddy, dx, dy;
187     const jfloat QUAD_DEC_BND = 32;
188     const jint countlg = 4;
189     jint count = 1 &lt;&lt; countlg;
190     jint countsq = count * count;
191     jfloat maxDD = Math_max(c.dbx / countsq, c.dby / countsq);
192     while (maxDD &gt; QUAD_DEC_BND) {
193         maxDD /= 4;
194         count &lt;&lt;= 1;
195     }
196 
197     countsq = count * count;
198     ddx = c.dbx / countsq;
199     ddy = c.dby / countsq;
200     dx = c.bx / countsq + c.cx / count;
201     dy = c.by / countsq + c.cy / count;
202 
203     while (count-- &gt; 1) {
204         jfloat x1 = x0 + dx;
205         jfloat y1 = y0 + dy;
206         dx += ddx;
207         dy += ddy;
<span class="line-modified">208         addLine(pRenderer, x0, y0, x1, y1);</span>



209         x0 = x1;
210         y0 = y1;
211     }
<span class="line-modified">212     addLine(pRenderer, x0, y0, x2, y2);</span>
213 }
214 
215 // x0, y0 and x3,y3 are the endpoints of the curve. We could compute these
216 // using c.xat(0),c.yat(0) and c.xat(1),c.yat(1), but this might introduce
217 // numerical errors, and our callers already have the exact values.
218 // Another alternative would be to pass all the control points, and call c.set
219 // here, but then too many numbers are passed around.
<span class="line-modified">220 static void curveBreakIntoLinesAndAdd(PathConsumer *pRenderer,</span>
221                                       jfloat x0, jfloat y0,
222                                       const Curve c,
223                                       const jfloat x3, const jfloat y3)
224 {

225     const jint countlg = 3;
226     jint count = 1 &lt;&lt; countlg;
227     jfloat x1, y1;
228 
229     // the dx and dy refer to forward differencing variables, not the last
230     // coefficients of the &quot;points&quot; polynomial
231     jfloat dddx, dddy, ddx, ddy, dx, dy;
232     dddx = 2.0f * c.dax / (1 &lt;&lt; (3 * countlg));
233     dddy = 2.0f * c.day / (1 &lt;&lt; (3 * countlg));
234 
235     ddx = dddx + c.dbx / (1 &lt;&lt; (2 * countlg));
236     ddy = dddy + c.dby / (1 &lt;&lt; (2 * countlg));
237     dx = c.ax / (1 &lt;&lt; (3 * countlg)) + c.bx / (1 &lt;&lt; (2 * countlg)) + c.cx / (1 &lt;&lt; countlg);
238     dy = c.ay / (1 &lt;&lt; (3 * countlg)) + c.by / (1 &lt;&lt; (2 * countlg)) + c.cy / (1 &lt;&lt; countlg);
239 
240     // we use x0, y0 to walk the line
241     x1 = x0;
242     y1 = y0;
243     while (count &gt; 0) {
244         while (fabs(ddx) &gt; DEC_BND || fabs(ddy) &gt; DEC_BND) {
</pre>
<hr />
<pre>
255             dx = 2 * dx + ddx;
256             dy = 2 * dy + ddy;
257             ddx = 4 * (ddx + dddx);
258             ddy = 4 * (ddy + dddy);
259             dddx = 8 * dddx;
260             dddy = 8 * dddy;
261             count &gt;&gt;= 1;
262         }
263         count--;
264         if (count &gt; 0) {
265             x1 += dx;
266             dx += ddx;
267             ddx += dddx;
268             y1 += dy;
269             dy += ddy;
270             ddy += dddy;
271         } else {
272             x1 = x3;
273             y1 = y3;
274         }
<span class="line-modified">275         addLine(pRenderer, x0, y0, x1, y1);</span>



276         x0 = x1;
277         y0 = y1;
278     }

279 }
280 
<span class="line-modified">281 static void addLine(PathConsumer *pRenderer,</span>
282                     jfloat x1, jfloat y1,
283                     jfloat x2, jfloat y2)
284 {

285     jfloat or = 1; // orientation of the line. 1 if y increases, 0 otherwise.
286     jint firstCrossing, lastCrossing;
287     jfloat slope;
288     jint ptr, bucketIdx;
289 
290     if (y2 &lt; y1) {
291         or = y2; // no need to declare a temp variable. We have or.
292         y2 = y1;
293         y1 = or;
294         or = x2;
295         x2 = x1;
296         x1 = or;
297         or = 0;
298     }
299     firstCrossing = Math_max((jint) ceil(y1 - 0.5f), this.boundsMinY);
300     lastCrossing = Math_min((jint) ceil(y2 - 0.5f), this.boundsMaxY);
301     if (firstCrossing &gt;= lastCrossing) {
<span class="line-modified">302         return;</span>
303     }
304     if (firstCrossing &lt; this.sampleRowMin) { this.sampleRowMin = firstCrossing; }
305     if (lastCrossing &gt; this.sampleRowMax) { this.sampleRowMax = lastCrossing; }
306 
307     slope = (x2 - x1) / (y2 - y1);
308 
309     if (slope &gt; 0) { // &lt;==&gt; x1 &lt; x2
310         if (x1 &lt; this.edgeMinX) { this.edgeMinX = x1; }
311         if (x2 &gt; this.edgeMaxX) { this.edgeMaxX = x2; }
312     } else {
313         if (x2 &lt; this.edgeMinX) { this.edgeMinX = x2; }
314         if (x1 &gt; this.edgeMaxX) { this.edgeMaxX = x1; }
315     }
316 





317     ptr = this.numEdges * SIZEOF_EDGE;
318     if (this.edgesSIZE &lt; ptr + SIZEOF_EDGE) {
319         jint newSize = (ptr + SIZEOF_EDGE) * 2;
320         jfloat *newEdges = new_float(newSize);



321         System_arraycopy(this.edges, 0, newEdges, 0, ptr);
322         free(this.edges);
323         this.edges = newEdges;
324         this.edgesSIZE = newSize;
325     }
326     this.numEdges++;
327     this.edges[ptr+OR] = or;
328     this.edges[ptr+CURX] = x1 + (firstCrossing + 0.5f - y1) * slope;
329     this.edges[ptr+SLOPE] = slope;
330     this.edges[ptr+YMAX] = (jfloat) lastCrossing;
<span class="line-modified">331     bucketIdx = firstCrossing - this.boundsMinY;</span>
<span class="line-modified">332     addEdgeToBucket(pRenderer, ptr, bucketIdx);</span>


333     this.edgeBuckets[(lastCrossing - this.boundsMinY)*2 + 1] |= 1;

334 }
335 
336 // END EDGE LIST
337 //////////////////////////////////////////////////////////////////////////////
338 static MoveToFunc       Renderer_moveTo;
339 static LineToFunc       Renderer_lineTo;
340 static QuadToFunc       Renderer_quadTo;
341 static CurveToFunc      Renderer_curveTo;
342 static ClosePathFunc    Renderer_closePath;
343 static PathDoneFunc     Renderer_pathDone;
344 
345 // Antialiasing
346 static jint SUBPIXEL_LG_POSITIONS_X;
347 static jint SUBPIXEL_LG_POSITIONS_Y;
348 static jint SUBPIXEL_POSITIONS_X;
349 static jint SUBPIXEL_POSITIONS_Y;
350 static jint SUBPIXEL_MASK_X;
351 static jint SUBPIXEL_MASK_Y;
352 //static jint MAX_AA_ALPHA;
353 
</pre>
<hr />
<pre>
422     this.numEdges = 0;
423     this.pix_sx0 = this.pix_sy0 = this.x0 = this.y0 = 0.0f;
424 }
425 
426 void Renderer_destroy(Renderer *pRenderer) {
427     free(pRenderer-&gt;edgeBuckets);
428     pRenderer-&gt;edgeBuckets = NULL;
429     pRenderer-&gt;edgeBucketsSIZE = 0;
430     free(pRenderer-&gt;edges);
431     pRenderer-&gt;edges = NULL;
432     pRenderer-&gt;edgesSIZE = 0;
433 }
434 
435 static jfloat tosubpixx(jfloat pix_x) {
436     return pix_x * SUBPIXEL_POSITIONS_X;
437 }
438 static jfloat tosubpixy(jfloat pix_y) {
439     return pix_y * SUBPIXEL_POSITIONS_Y;
440 }
441 
<span class="line-modified">442 static void Renderer_moveTo(PathConsumer *pRenderer,</span>
443                             jfloat pix_x0, jfloat pix_y0)
444 {
<span class="line-modified">445     Renderer_closePath(pRenderer);</span>



446     this.pix_sx0 = pix_x0;
447     this.pix_sy0 = pix_y0;
448     this.y0 = tosubpixy(pix_y0);
449     this.x0 = tosubpixx(pix_x0);

450 }
451 
<span class="line-modified">452 static void Renderer_lineTo(PathConsumer *pRenderer,</span>
453                             jfloat pix_x1, jfloat pix_y1)
454 {
455     jfloat x1 = tosubpixx(pix_x1);
456     jfloat y1 = tosubpixy(pix_y1);
<span class="line-modified">457     addLine(pRenderer, this.x0, this.y0, x1, y1);</span>



458     this.x0 = x1;
459     this.y0 = y1;

460 }
461 
<span class="line-modified">462 static void Renderer_curveTo(PathConsumer *pRenderer,</span>
463                              jfloat x1, jfloat y1,
464                              jfloat x2, jfloat y2,
465                              jfloat x3, jfloat y3)
466 {

467     const jfloat xe = tosubpixx(x3);
468     const jfloat ye = tosubpixy(y3);
469     Curve_setcubic(&amp;this.c,
470                    this.x0, this.y0,
471                    tosubpixx(x1), tosubpixy(y1),
472                    tosubpixx(x2), tosubpixy(y2),
473                    xe, ye);
<span class="line-modified">474     curveBreakIntoLinesAndAdd(pRenderer, this.x0, this.y0, this.c, xe, ye);</span>



475     this.x0 = xe;
476     this.y0 = ye;

477 }
478 
<span class="line-modified">479 void Renderer_quadTo(PathConsumer *pRenderer,</span>
480                      jfloat x1, jfloat y1,
481                      jfloat x2, jfloat y2)
482 {

483     const jfloat xe = tosubpixx(x2);
484     const jfloat ye = tosubpixy(y2);
485     Curve_setquad(&amp;this.c,
486                   this.x0, this.y0,
487                   tosubpixx(x1), tosubpixy(y1),
488                   xe, ye);
<span class="line-modified">489     quadBreakIntoLinesAndAdd(pRenderer, this.x0, this.y0, this.c, xe, ye);</span>



490     this.x0 = xe;
491     this.y0 = ye;

492 }
493 
<span class="line-modified">494 static void Renderer_closePath(PathConsumer *pRenderer) {</span>
495     // lineTo expects its input in pixel coordinates.
<span class="line-modified">496     Renderer_lineTo(pRenderer, this.pix_sx0, this.pix_sy0);</span>
497 }
498 
<span class="line-modified">499 static void Renderer_pathDone(PathConsumer *pRenderer) {</span>
<span class="line-modified">500     Renderer_closePath(pRenderer);</span>
501 }
502 
503 static void setAndClearRelativeAlphas(AlphaConsumer *pAC,
504                                       jint alphaRow[], jint pix_y,
505                                       jint pix_from, jint pix_to);
506 
<span class="line-modified">507 void Renderer_produceAlphas(Renderer *pRenderer, AlphaConsumer *pAC) {</span>
508 //    ac.setMaxAlpha(MAX_AA_ALPHA);
509 
510     // Mask to determine the relevant bit of the crossing sum
511     // 0x1 if EVEN_ODD, all bits if NON_ZERO
512     jint mask = (this.windingRule == WIND_EVEN_ODD) ? 0x1 : ~0x0;
513     jint bboxx0, bboxx1;
514     jint pix_minX, pix_maxX;
515     jint y;
516     ScanlineIterator it;
517 
518     // add 2 to better deal with the last pixel in a pixel row.
519     jint width = pAC-&gt;width;
520     jint savedAlpha[1024];
521     jint *alpha;
522     if (1024 &lt; width+2) {
523         alpha = new_int(width+2);



524     } else {
525         alpha = savedAlpha;
526     }
527     Arrays_fill(alpha, 0, width+2, 0);
528 
529     bboxx0 = pAC-&gt;originX &lt;&lt; SUBPIXEL_LG_POSITIONS_X;
530     bboxx1 = bboxx0 + (width &lt;&lt; SUBPIXEL_LG_POSITIONS_X);
531 
532     // Now we iterate through the scanlines. We must tell emitRow the coord
533     // of the first non-transparent pixel, so we must keep accumulators for
534     // the first and last pixels of the section of the current pixel row
535     // that we will emit.
536     // We also need to accumulate pix_bbox*, but the iterator does it
537     // for us. We will just get the values from it once this loop is done
538     pix_maxX = bboxx1 &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
539     pix_minX = bboxx0 &gt;&gt; SUBPIXEL_LG_POSITIONS_Y;
540 
541     y = this.boundsMinY; // needs to be declared here so we emit the last row properly.
542     ScanlineIterator_init(&amp;it, pRenderer);
543     for ( ; ScanlineIterator_hasNext(&amp;it, pRenderer); ) {
544         jint numCrossings = ScanlineIterator_next(&amp;it, pRenderer);
545         jint *crossings = it.crossings;
546         jint sum, prev;
547         jint i;
548 






549         y = ScanlineIterator_curY(&amp;it);
550 
551         if (numCrossings &gt; 0) {
552             jint lowx = crossings[0] &gt;&gt; 1;
553             jint highx = crossings[numCrossings - 1] &gt;&gt; 1;
554             jint x0 = Math_max(lowx, bboxx0);
555             jint x1 = Math_min(highx, bboxx1);
556 
557             pix_minX = Math_min(pix_minX, x0 &gt;&gt; SUBPIXEL_LG_POSITIONS_X);
558             pix_maxX = Math_max(pix_maxX, x1 &gt;&gt; SUBPIXEL_LG_POSITIONS_X);
559         }
560 
561         sum = 0;
562         prev = bboxx0;
563         for (i = 0; i &lt; numCrossings; i++) {
564             jint curxo = crossings[i];
565             jint curx = curxo &gt;&gt; 1;
566             jint crorientation = ((curxo &amp; 0x1) &lt;&lt; 1) - 1;
567             if ((sum &amp; mask) != 0) {
568                 jint x0 = Math_max(prev, bboxx0);
</pre>
<hr />
<pre>
595 
596         // even if this last row had no crossings, alpha will be zeroed
597         // from the last emitRow call. But this doesn&#39;t matter because
598         // maxX &lt; minX, so no row will be emitted to the cache.
599         if ((y &amp; SUBPIXEL_MASK_Y) == SUBPIXEL_MASK_Y) {
600             setAndClearRelativeAlphas(pAC, alpha, y &gt;&gt; SUBPIXEL_LG_POSITIONS_Y,
601                                       pix_minX, pix_maxX);
602             pix_maxX = bboxx1 &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
603             pix_minX = bboxx0 &gt;&gt; SUBPIXEL_LG_POSITIONS_Y;
604         }
605     }
606 
607     // Emit final row.
608     // Note, if y is on a MASK row then it was already sent above...
609     if ((y &amp; SUBPIXEL_MASK_Y) &lt; SUBPIXEL_MASK_Y) {
610         setAndClearRelativeAlphas(pAC, alpha, y &gt;&gt; SUBPIXEL_LG_POSITIONS_Y,
611                                   pix_minX, pix_maxX);
612     }
613     ScanlineIterator_destroy(&amp;it);
614     if (alpha != savedAlpha) free (alpha);


615 }
616 
617 //@Override
618 static void setMaxAlpha(jint maxalpha) {
619     jint i, altMax;
620     jbyte *altMap;
621 
622     // Attempt to reuse either alphaMap or altAlphaMap.
623     // In practice, we should not get here if alphaMap is the right size
624     // due to checks above in our calling chain, but we check for that
625     // condition for completeness.
626     // Also in practice, we only ever have 2 values for maxalpha, but we
627     // protect against running into a 3rd value for maxalpha just in case.
628     if (alphaMap != NULL) {
629         if (maxalpha == alphaMax) {
630             return;
631         }
632         // We will either free the alt values and calculate a new map,
633         // or we will swap them to the main alpha* variables.  In either
634         // case, the main alpha* variables will become the new alt values.
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 53 
 54 static void ScanlineIterator_destroy(ScanlineIterator *pIterator) {
 55     free(this.crossings);
 56     this.crossings = NULL;
 57     this.crossingsSIZE = 0;
 58     free(this.edgePtrs);
 59     this.edgePtrs = NULL;
 60     this.edgePtrsSIZE = 0;
 61 }
 62 
 63 static void ScanlineIterator_reset(ScanlineIterator *pIterator,
 64                                    Renderer *pRenderer)
 65 {
 66     // We don&#39;t care if we clip some of the line off with ceil, since
 67     // no scan line crossings will be eliminated (in fact, the ceil is
 68     // the y of the first scan line crossing).
 69     this.nextY = pRenderer-&gt;sampleRowMin;
 70     this.edgeCount = 0;
 71 }
 72 
<span class="line-added"> 73 // Iterate to the next scanline and return the number of crossings.</span>
<span class="line-added"> 74 // A count of -1 is returned to indicate OOM.</span>
 75 static jint ScanlineIterator_next(ScanlineIterator *pIterator, Renderer *pRenderer) {
 76     jint i, ecur;
 77     jint *xings;
 78     // NOTE: make function that convert from y value to bucket idx?
 79     jint cury = this.nextY++;
 80     jint bucket = cury - pRenderer-&gt;boundsMinY;
 81     jint count = this.edgeCount;
 82     jint *ptrs = this.edgePtrs;
 83     jfloat *edges = pRenderer-&gt;edges;
 84     jint bucketcount = pRenderer-&gt;edgeBuckets[bucket*2 + 1];
 85 
 86     if ((bucketcount &amp; 0x1) != 0) {
 87         jint newCount = 0;
 88         jint i;
 89         for (i = 0; i &lt; count; i++) {
 90             jint ecur = ptrs[i];
 91             if (edges[ecur+YMAX] &gt; cury) {
 92                 ptrs[newCount++] = ecur;
 93             }
 94         }
 95         count = newCount;
 96     }
 97     if (this.edgePtrsSIZE &lt; count + (bucketcount &gt;&gt; 1)) {
 98         jint newSize = (count + (bucketcount &gt;&gt; 1)) * 2;
 99         jint *newPtrs = new_int(newSize);
<span class="line-added">100         if (!newPtrs) {</span>
<span class="line-added">101             return -1;</span>
<span class="line-added">102         }</span>
103         System_arraycopy(this.edgePtrs, 0, newPtrs, 0, count);
104         free(this.edgePtrs);
105         this.edgePtrs = newPtrs;
106         this.edgePtrsSIZE = newSize;
107     }
108     ptrs = this.edgePtrs;
109     for (ecur = pRenderer-&gt;edgeBuckets[bucket*2];
110          ecur != 0;
111          ecur = (jint) edges[ecur+NEXT])
112     {
113         ptrs[count++] = --ecur;
114         // REMIND: Adjust start Y if necessary
115     }
116     this.edgePtrs = ptrs;
117     this.edgeCount = count;
118 //    if ((count &amp; 0x1) != 0) {
119 //        System.out.println(&quot;ODD NUMBER OF EDGES!!!!&quot;);
120 //    }
121     xings = this.crossings;
122     if (this.crossingsSIZE &lt; count) {
123         free(this.crossings);
124         this.crossings = xings = new_int(this.edgePtrsSIZE);
<span class="line-added">125         if (!xings) {</span>
<span class="line-added">126             return -1;</span>
<span class="line-added">127         }</span>
128         this.crossingsSIZE = this.edgePtrsSIZE;
129     }
130     for (i = 0; i &lt; count; i++) {
131         jint ecur = ptrs[i];
132         jfloat curx = edges[ecur+CURX];
133         jint cross = ((jint) ceil(curx - 0.5f)) &lt;&lt; 1;
134         jint j;
135         edges[ecur+CURX] = curx + edges[ecur+SLOPE];
136         if (edges[ecur+OR] &gt; 0) {
137             cross |= 1;
138         }
139         j = i;
140         while (--j &gt;= 0) {
141             jint jcross = xings[j];
142             if (jcross &lt;= cross) {
143                 break;
144             }
145             xings[j+1] = jcross;
146             ptrs[j+1] = ptrs[j];
147         }
</pre>
<hr />
<pre>
154 static jboolean ScanlineIterator_hasNext(ScanlineIterator *pIterator, Renderer *pRenderer) {
155     return this.nextY &lt; pRenderer-&gt;sampleRowMax;
156 }
157 
158 static jint ScanlineIterator_curY(ScanlineIterator *pIterator) {
159     return this.nextY - 1;
160 }
161 
162 #undef this
163 #define this (*((Renderer *) pRenderer))
164 
165 //////////////////////////////////////////////////////////////////////////////
166 //  EDGE LIST
167 //////////////////////////////////////////////////////////////////////////////
168 // NOTE(maybe): very tempting to use fixed point here. A lot of opportunities
169 // for shifts and just removing certain operations altogether.
170 
171 
172 // each bucket is a linked list. this method adds eptr to the
173 // start &quot;bucket&quot;th linked list.
<span class="line-modified">174 static jint addEdgeToBucket(PathConsumer *pRenderer, const jint eptr, const jint bucket) {</span>
175     // we could implement this in terms of insertEdge, but this is a special
176     // case, so we optimize a bit.
<span class="line-added">177     if (this.edgeBuckets[bucket*2] &gt;= MAX_EDGE_IDX) {</span>
<span class="line-added">178         return ERROR_AIOOBE;</span>
<span class="line-added">179     }</span>
180     this.edges[eptr+NEXT] = (jfloat) this.edgeBuckets[bucket*2];
181     this.edgeBuckets[bucket*2] = eptr + 1;
182     this.edgeBuckets[bucket*2 + 1] += 2;
<span class="line-added">183     return ERROR_NONE;</span>
184 }
185 
<span class="line-modified">186 static jint addLine(PathConsumer *pRenderer,</span>
187                     jfloat x1, jfloat y1,
188                     jfloat x2, jfloat y2);
189 
190 // Flattens using adaptive forward differencing. This only carries out
191 // one iteration of the AFD loop. All it does is update AFD variables (i.e.
192 // X0, Y0, D*[X|Y], COUNT; not variables used for computing scanline crossings).
<span class="line-modified">193 static jint quadBreakIntoLinesAndAdd(PathConsumer *pRenderer,</span>
194                                      jfloat x0, jfloat y0,
195                                      const Curve c,
196                                      const jfloat x2, const jfloat y2)
197 {
<span class="line-added">198     jint status = ERROR_NONE;</span>
199     jfloat ddx, ddy, dx, dy;
200     const jfloat QUAD_DEC_BND = 32;
201     const jint countlg = 4;
202     jint count = 1 &lt;&lt; countlg;
203     jint countsq = count * count;
204     jfloat maxDD = Math_max(c.dbx / countsq, c.dby / countsq);
205     while (maxDD &gt; QUAD_DEC_BND) {
206         maxDD /= 4;
207         count &lt;&lt;= 1;
208     }
209 
210     countsq = count * count;
211     ddx = c.dbx / countsq;
212     ddy = c.dby / countsq;
213     dx = c.bx / countsq + c.cx / count;
214     dy = c.by / countsq + c.cy / count;
215 
216     while (count-- &gt; 1) {
217         jfloat x1 = x0 + dx;
218         jfloat y1 = y0 + dy;
219         dx += ddx;
220         dy += ddy;
<span class="line-modified">221         status = addLine(pRenderer, x0, y0, x1, y1);</span>
<span class="line-added">222         if (status != ERROR_NONE) {</span>
<span class="line-added">223             return status;</span>
<span class="line-added">224         }</span>
225         x0 = x1;
226         y0 = y1;
227     }
<span class="line-modified">228     return addLine(pRenderer, x0, y0, x2, y2);</span>
229 }
230 
231 // x0, y0 and x3,y3 are the endpoints of the curve. We could compute these
232 // using c.xat(0),c.yat(0) and c.xat(1),c.yat(1), but this might introduce
233 // numerical errors, and our callers already have the exact values.
234 // Another alternative would be to pass all the control points, and call c.set
235 // here, but then too many numbers are passed around.
<span class="line-modified">236 static jint curveBreakIntoLinesAndAdd(PathConsumer *pRenderer,</span>
237                                       jfloat x0, jfloat y0,
238                                       const Curve c,
239                                       const jfloat x3, const jfloat y3)
240 {
<span class="line-added">241     jint status = ERROR_NONE;</span>
242     const jint countlg = 3;
243     jint count = 1 &lt;&lt; countlg;
244     jfloat x1, y1;
245 
246     // the dx and dy refer to forward differencing variables, not the last
247     // coefficients of the &quot;points&quot; polynomial
248     jfloat dddx, dddy, ddx, ddy, dx, dy;
249     dddx = 2.0f * c.dax / (1 &lt;&lt; (3 * countlg));
250     dddy = 2.0f * c.day / (1 &lt;&lt; (3 * countlg));
251 
252     ddx = dddx + c.dbx / (1 &lt;&lt; (2 * countlg));
253     ddy = dddy + c.dby / (1 &lt;&lt; (2 * countlg));
254     dx = c.ax / (1 &lt;&lt; (3 * countlg)) + c.bx / (1 &lt;&lt; (2 * countlg)) + c.cx / (1 &lt;&lt; countlg);
255     dy = c.ay / (1 &lt;&lt; (3 * countlg)) + c.by / (1 &lt;&lt; (2 * countlg)) + c.cy / (1 &lt;&lt; countlg);
256 
257     // we use x0, y0 to walk the line
258     x1 = x0;
259     y1 = y0;
260     while (count &gt; 0) {
261         while (fabs(ddx) &gt; DEC_BND || fabs(ddy) &gt; DEC_BND) {
</pre>
<hr />
<pre>
272             dx = 2 * dx + ddx;
273             dy = 2 * dy + ddy;
274             ddx = 4 * (ddx + dddx);
275             ddy = 4 * (ddy + dddy);
276             dddx = 8 * dddx;
277             dddy = 8 * dddy;
278             count &gt;&gt;= 1;
279         }
280         count--;
281         if (count &gt; 0) {
282             x1 += dx;
283             dx += ddx;
284             ddx += dddx;
285             y1 += dy;
286             dy += ddy;
287             ddy += dddy;
288         } else {
289             x1 = x3;
290             y1 = y3;
291         }
<span class="line-modified">292         status = addLine(pRenderer, x0, y0, x1, y1);</span>
<span class="line-added">293         if (status != ERROR_NONE) {</span>
<span class="line-added">294             return status;</span>
<span class="line-added">295         }</span>
296         x0 = x1;
297         y0 = y1;
298     }
<span class="line-added">299     return status;</span>
300 }
301 
<span class="line-modified">302 static jint addLine(PathConsumer *pRenderer,</span>
303                     jfloat x1, jfloat y1,
304                     jfloat x2, jfloat y2)
305 {
<span class="line-added">306     jint status = ERROR_NONE;</span>
307     jfloat or = 1; // orientation of the line. 1 if y increases, 0 otherwise.
308     jint firstCrossing, lastCrossing;
309     jfloat slope;
310     jint ptr, bucketIdx;
311 
312     if (y2 &lt; y1) {
313         or = y2; // no need to declare a temp variable. We have or.
314         y2 = y1;
315         y1 = or;
316         or = x2;
317         x2 = x1;
318         x1 = or;
319         or = 0;
320     }
321     firstCrossing = Math_max((jint) ceil(y1 - 0.5f), this.boundsMinY);
322     lastCrossing = Math_min((jint) ceil(y2 - 0.5f), this.boundsMaxY);
323     if (firstCrossing &gt;= lastCrossing) {
<span class="line-modified">324         return status;</span>
325     }
326     if (firstCrossing &lt; this.sampleRowMin) { this.sampleRowMin = firstCrossing; }
327     if (lastCrossing &gt; this.sampleRowMax) { this.sampleRowMax = lastCrossing; }
328 
329     slope = (x2 - x1) / (y2 - y1);
330 
331     if (slope &gt; 0) { // &lt;==&gt; x1 &lt; x2
332         if (x1 &lt; this.edgeMinX) { this.edgeMinX = x1; }
333         if (x2 &gt; this.edgeMaxX) { this.edgeMaxX = x2; }
334     } else {
335         if (x2 &lt; this.edgeMinX) { this.edgeMinX = x2; }
336         if (x1 &gt; this.edgeMaxX) { this.edgeMaxX = x1; }
337     }
338 
<span class="line-added">339     bucketIdx = firstCrossing - this.boundsMinY;</span>
<span class="line-added">340     if (this.edgeBuckets[bucketIdx*2] &gt;= MAX_EDGE_IDX) {</span>
<span class="line-added">341         return ERROR_AIOOBE;</span>
<span class="line-added">342     }</span>
<span class="line-added">343 </span>
344     ptr = this.numEdges * SIZEOF_EDGE;
345     if (this.edgesSIZE &lt; ptr + SIZEOF_EDGE) {
346         jint newSize = (ptr + SIZEOF_EDGE) * 2;
347         jfloat *newEdges = new_float(newSize);
<span class="line-added">348         if (!newEdges) {</span>
<span class="line-added">349             return ERROR_OOM;</span>
<span class="line-added">350         }</span>
351         System_arraycopy(this.edges, 0, newEdges, 0, ptr);
352         free(this.edges);
353         this.edges = newEdges;
354         this.edgesSIZE = newSize;
355     }
356     this.numEdges++;
357     this.edges[ptr+OR] = or;
358     this.edges[ptr+CURX] = x1 + (firstCrossing + 0.5f - y1) * slope;
359     this.edges[ptr+SLOPE] = slope;
360     this.edges[ptr+YMAX] = (jfloat) lastCrossing;
<span class="line-modified">361     status = addEdgeToBucket(pRenderer, ptr, bucketIdx);</span>
<span class="line-modified">362     if (status != ERROR_NONE) {</span>
<span class="line-added">363         return status;</span>
<span class="line-added">364     }</span>
365     this.edgeBuckets[(lastCrossing - this.boundsMinY)*2 + 1] |= 1;
<span class="line-added">366     return status;</span>
367 }
368 
369 // END EDGE LIST
370 //////////////////////////////////////////////////////////////////////////////
371 static MoveToFunc       Renderer_moveTo;
372 static LineToFunc       Renderer_lineTo;
373 static QuadToFunc       Renderer_quadTo;
374 static CurveToFunc      Renderer_curveTo;
375 static ClosePathFunc    Renderer_closePath;
376 static PathDoneFunc     Renderer_pathDone;
377 
378 // Antialiasing
379 static jint SUBPIXEL_LG_POSITIONS_X;
380 static jint SUBPIXEL_LG_POSITIONS_Y;
381 static jint SUBPIXEL_POSITIONS_X;
382 static jint SUBPIXEL_POSITIONS_Y;
383 static jint SUBPIXEL_MASK_X;
384 static jint SUBPIXEL_MASK_Y;
385 //static jint MAX_AA_ALPHA;
386 
</pre>
<hr />
<pre>
455     this.numEdges = 0;
456     this.pix_sx0 = this.pix_sy0 = this.x0 = this.y0 = 0.0f;
457 }
458 
459 void Renderer_destroy(Renderer *pRenderer) {
460     free(pRenderer-&gt;edgeBuckets);
461     pRenderer-&gt;edgeBuckets = NULL;
462     pRenderer-&gt;edgeBucketsSIZE = 0;
463     free(pRenderer-&gt;edges);
464     pRenderer-&gt;edges = NULL;
465     pRenderer-&gt;edgesSIZE = 0;
466 }
467 
468 static jfloat tosubpixx(jfloat pix_x) {
469     return pix_x * SUBPIXEL_POSITIONS_X;
470 }
471 static jfloat tosubpixy(jfloat pix_y) {
472     return pix_y * SUBPIXEL_POSITIONS_Y;
473 }
474 
<span class="line-modified">475 static jint Renderer_moveTo(PathConsumer *pRenderer,</span>
476                             jfloat pix_x0, jfloat pix_y0)
477 {
<span class="line-modified">478     jint status = Renderer_closePath(pRenderer);</span>
<span class="line-added">479     if (status != ERROR_NONE) {</span>
<span class="line-added">480         return status;</span>
<span class="line-added">481     }</span>
482     this.pix_sx0 = pix_x0;
483     this.pix_sy0 = pix_y0;
484     this.y0 = tosubpixy(pix_y0);
485     this.x0 = tosubpixx(pix_x0);
<span class="line-added">486     return status;</span>
487 }
488 
<span class="line-modified">489 static jint Renderer_lineTo(PathConsumer *pRenderer,</span>
490                             jfloat pix_x1, jfloat pix_y1)
491 {
492     jfloat x1 = tosubpixx(pix_x1);
493     jfloat y1 = tosubpixy(pix_y1);
<span class="line-modified">494     jint status = addLine(pRenderer, this.x0, this.y0, x1, y1);</span>
<span class="line-added">495     if (status != ERROR_NONE) {</span>
<span class="line-added">496         return status;</span>
<span class="line-added">497     }</span>
498     this.x0 = x1;
499     this.y0 = y1;
<span class="line-added">500     return status;</span>
501 }
502 
<span class="line-modified">503 static jint Renderer_curveTo(PathConsumer *pRenderer,</span>
504                              jfloat x1, jfloat y1,
505                              jfloat x2, jfloat y2,
506                              jfloat x3, jfloat y3)
507 {
<span class="line-added">508     jint status = ERROR_NONE;</span>
509     const jfloat xe = tosubpixx(x3);
510     const jfloat ye = tosubpixy(y3);
511     Curve_setcubic(&amp;this.c,
512                    this.x0, this.y0,
513                    tosubpixx(x1), tosubpixy(y1),
514                    tosubpixx(x2), tosubpixy(y2),
515                    xe, ye);
<span class="line-modified">516     status = curveBreakIntoLinesAndAdd(pRenderer, this.x0, this.y0, this.c, xe, ye);</span>
<span class="line-added">517     if (status != ERROR_NONE) {</span>
<span class="line-added">518         return status;</span>
<span class="line-added">519     }</span>
520     this.x0 = xe;
521     this.y0 = ye;
<span class="line-added">522     return status;</span>
523 }
524 
<span class="line-modified">525 jint Renderer_quadTo(PathConsumer *pRenderer,</span>
526                      jfloat x1, jfloat y1,
527                      jfloat x2, jfloat y2)
528 {
<span class="line-added">529     jint status = ERROR_NONE;</span>
530     const jfloat xe = tosubpixx(x2);
531     const jfloat ye = tosubpixy(y2);
532     Curve_setquad(&amp;this.c,
533                   this.x0, this.y0,
534                   tosubpixx(x1), tosubpixy(y1),
535                   xe, ye);
<span class="line-modified">536     status = quadBreakIntoLinesAndAdd(pRenderer, this.x0, this.y0, this.c, xe, ye);</span>
<span class="line-added">537     if (status != ERROR_NONE) {</span>
<span class="line-added">538         return status;</span>
<span class="line-added">539     }</span>
540     this.x0 = xe;
541     this.y0 = ye;
<span class="line-added">542     return status;</span>
543 }
544 
<span class="line-modified">545 static jint Renderer_closePath(PathConsumer *pRenderer) {</span>
546     // lineTo expects its input in pixel coordinates.
<span class="line-modified">547     return Renderer_lineTo(pRenderer, this.pix_sx0, this.pix_sy0);</span>
548 }
549 
<span class="line-modified">550 static jint Renderer_pathDone(PathConsumer *pRenderer) {</span>
<span class="line-modified">551     return Renderer_closePath(pRenderer);</span>
552 }
553 
554 static void setAndClearRelativeAlphas(AlphaConsumer *pAC,
555                                       jint alphaRow[], jint pix_y,
556                                       jint pix_from, jint pix_to);
557 
<span class="line-modified">558 jint Renderer_produceAlphas(Renderer *pRenderer, AlphaConsumer *pAC) {</span>
559 //    ac.setMaxAlpha(MAX_AA_ALPHA);
560 
561     // Mask to determine the relevant bit of the crossing sum
562     // 0x1 if EVEN_ODD, all bits if NON_ZERO
563     jint mask = (this.windingRule == WIND_EVEN_ODD) ? 0x1 : ~0x0;
564     jint bboxx0, bboxx1;
565     jint pix_minX, pix_maxX;
566     jint y;
567     ScanlineIterator it;
568 
569     // add 2 to better deal with the last pixel in a pixel row.
570     jint width = pAC-&gt;width;
571     jint savedAlpha[1024];
572     jint *alpha;
573     if (1024 &lt; width+2) {
574         alpha = new_int(width+2);
<span class="line-added">575         if (!alpha) {</span>
<span class="line-added">576             return ERROR_OOM;</span>
<span class="line-added">577         }</span>
578     } else {
579         alpha = savedAlpha;
580     }
581     Arrays_fill(alpha, 0, width+2, 0);
582 
583     bboxx0 = pAC-&gt;originX &lt;&lt; SUBPIXEL_LG_POSITIONS_X;
584     bboxx1 = bboxx0 + (width &lt;&lt; SUBPIXEL_LG_POSITIONS_X);
585 
586     // Now we iterate through the scanlines. We must tell emitRow the coord
587     // of the first non-transparent pixel, so we must keep accumulators for
588     // the first and last pixels of the section of the current pixel row
589     // that we will emit.
590     // We also need to accumulate pix_bbox*, but the iterator does it
591     // for us. We will just get the values from it once this loop is done
592     pix_maxX = bboxx1 &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
593     pix_minX = bboxx0 &gt;&gt; SUBPIXEL_LG_POSITIONS_Y;
594 
595     y = this.boundsMinY; // needs to be declared here so we emit the last row properly.
596     ScanlineIterator_init(&amp;it, pRenderer);
597     for ( ; ScanlineIterator_hasNext(&amp;it, pRenderer); ) {
598         jint numCrossings = ScanlineIterator_next(&amp;it, pRenderer);
599         jint *crossings = it.crossings;
600         jint sum, prev;
601         jint i;
602 
<span class="line-added">603         if (numCrossings &lt; 0) {</span>
<span class="line-added">604             ScanlineIterator_destroy(&amp;it);</span>
<span class="line-added">605             if (alpha != savedAlpha) free (alpha);</span>
<span class="line-added">606             return ERROR_OOM;</span>
<span class="line-added">607         }</span>
<span class="line-added">608 </span>
609         y = ScanlineIterator_curY(&amp;it);
610 
611         if (numCrossings &gt; 0) {
612             jint lowx = crossings[0] &gt;&gt; 1;
613             jint highx = crossings[numCrossings - 1] &gt;&gt; 1;
614             jint x0 = Math_max(lowx, bboxx0);
615             jint x1 = Math_min(highx, bboxx1);
616 
617             pix_minX = Math_min(pix_minX, x0 &gt;&gt; SUBPIXEL_LG_POSITIONS_X);
618             pix_maxX = Math_max(pix_maxX, x1 &gt;&gt; SUBPIXEL_LG_POSITIONS_X);
619         }
620 
621         sum = 0;
622         prev = bboxx0;
623         for (i = 0; i &lt; numCrossings; i++) {
624             jint curxo = crossings[i];
625             jint curx = curxo &gt;&gt; 1;
626             jint crorientation = ((curxo &amp; 0x1) &lt;&lt; 1) - 1;
627             if ((sum &amp; mask) != 0) {
628                 jint x0 = Math_max(prev, bboxx0);
</pre>
<hr />
<pre>
655 
656         // even if this last row had no crossings, alpha will be zeroed
657         // from the last emitRow call. But this doesn&#39;t matter because
658         // maxX &lt; minX, so no row will be emitted to the cache.
659         if ((y &amp; SUBPIXEL_MASK_Y) == SUBPIXEL_MASK_Y) {
660             setAndClearRelativeAlphas(pAC, alpha, y &gt;&gt; SUBPIXEL_LG_POSITIONS_Y,
661                                       pix_minX, pix_maxX);
662             pix_maxX = bboxx1 &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
663             pix_minX = bboxx0 &gt;&gt; SUBPIXEL_LG_POSITIONS_Y;
664         }
665     }
666 
667     // Emit final row.
668     // Note, if y is on a MASK row then it was already sent above...
669     if ((y &amp; SUBPIXEL_MASK_Y) &lt; SUBPIXEL_MASK_Y) {
670         setAndClearRelativeAlphas(pAC, alpha, y &gt;&gt; SUBPIXEL_LG_POSITIONS_Y,
671                                   pix_minX, pix_maxX);
672     }
673     ScanlineIterator_destroy(&amp;it);
674     if (alpha != savedAlpha) free (alpha);
<span class="line-added">675 </span>
<span class="line-added">676     return ERROR_NONE;</span>
677 }
678 
679 //@Override
680 static void setMaxAlpha(jint maxalpha) {
681     jint i, altMax;
682     jbyte *altMap;
683 
684     // Attempt to reuse either alphaMap or altAlphaMap.
685     // In practice, we should not get here if alphaMap is the right size
686     // due to checks above in our calling chain, but we check for that
687     // condition for completeness.
688     // Also in practice, we only ever have 2 values for maxalpha, but we
689     // protect against running into a 3rd value for maxalpha just in case.
690     if (alphaMap != NULL) {
691         if (maxalpha == alphaMax) {
692             return;
693         }
694         // We will either free the alt values and calculate a new map,
695         // or we will swap them to the main alpha* variables.  In either
696         // case, the main alpha* variables will become the new alt values.
</pre>
</td>
</tr>
</table>
<center><a href="PathConsumer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="Renderer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
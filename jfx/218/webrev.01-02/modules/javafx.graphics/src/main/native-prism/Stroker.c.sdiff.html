<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/native-prism/Stroker.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="Renderer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="Transformer.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/native-prism/Stroker.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  34 #include &quot;Stroker.h&quot;
  35 
  36 // NOTE: some of the arithmetic here is too verbose and prone to hard to
  37 // debug typos. We should consider making a small Point/Vector class that
  38 // has methods like plus(Point), minus(Point), dot(Point), cross(Point)and such
  39 //public final class Stroker implements PathConsumer2D {
  40 
  41 #define MOVE_TO  0
  42 #define DRAWING_OP_TO  1 // ie. curve, line, or quad
  43 #define CLOSE  2
  44 
  45 static MoveToFunc       Stroker_moveTo;
  46 static LineToFunc       Stroker_lineTo;
  47 static QuadToFunc       Stroker_quadTo;
  48 static CurveToFunc      Stroker_curveTo;
  49 static ClosePathFunc    Stroker_closePath;
  50 static PathDoneFunc     Stroker_pathDone;
  51 
  52 #define this (*((Stroker *) pStroker))
  53 
<span class="line-modified">  54 static void drawJoin(PathConsumer *pStroker,</span>
  55                      jfloat pdx, jfloat pdy,
  56                      jfloat x0, jfloat y0,
  57                      jfloat dx, jfloat dy,
  58                      jfloat omx, jfloat omy,
  59                      jfloat mx, jfloat my);
  60 
<span class="line-modified">  61 static void drawRoundJoin2(PathConsumer *pStroker,</span>
  62                            jfloat cx, jfloat cy,
  63                            jfloat omx, jfloat omy,
  64                            jfloat mx, jfloat my,
  65                            jboolean rev);
  66 
<span class="line-modified">  67 static void drawBezApproxForArc(PathConsumer *pStroker,</span>
  68                                 const jfloat cx, const jfloat cy,
  69                                 const jfloat omx, const jfloat omy,
  70                                 const jfloat mx, const jfloat my,
  71                                 jboolean rev);
  72 
<span class="line-modified">  73 static void emitMoveTo(PathConsumer *pStroker, const jfloat x0, const jfloat y0);</span>
  74 
<span class="line-modified">  75 static void emitLineTo(PathConsumer *pStroker, const jfloat x1, const jfloat y1,</span>
  76                        const jboolean rev);
  77 
<span class="line-modified">  78 static void emitCurveTo(PathConsumer *pStroker,</span>
  79                         const jfloat x0, const jfloat y0,
  80                         const jfloat x1, const jfloat y1,
  81                         const jfloat x2, const jfloat y2,
  82                         const jfloat x3, const jfloat y3, const jboolean rev);
  83 
<span class="line-modified">  84 static void emitClose(PathConsumer *pStroker);</span>
  85 
<span class="line-modified">  86 static void emitReverse(PathConsumer *pStroker);</span>
  87 
<span class="line-modified">  88 static void finish(PathConsumer *pStroker);</span>
  89 
  90 extern void PolyStack_init(PolyStack *pStack);
  91 
  92 extern void PolyStack_destroy(PolyStack *pStack);
  93 
  94 extern jboolean PolyStack_isEmpty(PolyStack *pStack);
  95 
<span class="line-modified">  96 extern void PolyStack_pushLine(PolyStack *pStack,</span>
  97                                jfloat x, jfloat y);
  98 
<span class="line-modified">  99 extern void PolyStack_pushCubic(PolyStack *pStack,</span>
 100                                 jfloat x0, jfloat y0,
 101                                 jfloat x1, jfloat y1,
 102                                 jfloat x2, jfloat y2);
 103 
<span class="line-modified"> 104 extern void PolyStack_pushQuad(PolyStack *pStack,</span>
 105                                jfloat x0, jfloat y0,
 106                                jfloat x1, jfloat y1);
 107 
<span class="line-modified"> 108 extern void PolyStack_pop(PolyStack *pStack, PathConsumer *io);</span>
 109 
 110     /**
 111      * Constructs a &lt;code&gt;Stroker&lt;/code&gt;.
 112      *
 113      * @param pc2d an output &lt;code&gt;PathConsumer2D&lt;/code&gt;.
 114      * @param lineWidth the desired line width in pixels
 115      * @param capStyle the desired end cap style, one of
 116      * &lt;code&gt;CAP_BUTT&lt;/code&gt;, &lt;code&gt;CAP_ROUND&lt;/code&gt; or
 117      * &lt;code&gt;CAP_SQUARE&lt;/code&gt;.
 118      * @param joinStyle the desired line join style, one of
 119      * &lt;code&gt;JOIN_MITER&lt;/code&gt;, &lt;code&gt;JOIN_ROUND&lt;/code&gt; or
 120      * &lt;code&gt;JOIN_BEVEL&lt;/code&gt;.
 121      * @param miterLimit the desired miter limit
 122     public Stroker(PathConsumer2D pc2d,
 123                    float lineWidth,
 124                    jint capStyle,
 125                    jint joinStyle,
 126                    float miterLimit)
 127     {
 128         this(pc2d);
</pre>
<hr />
<pre>
 196 
 197 // Returns true if the vectors (dx1, dy1) and (dx2, dy2) are
 198 // clockwise (if dx1,dy1 needs to be rotated clockwise to close
 199 // the smallest angle between it and dx2,dy2).
 200 // This is equivalent to detecting whether a point q is on the right side
 201 // of a line passing through points p1, p2 where p2 = p1+(dx1,dy1) and
 202 // q = p2+(dx2,dy2), which is the same as saying p1, p2, q are in a
 203 // clockwise order.
 204 // NOTE: &quot;clockwise&quot; here assumes coordinates with 0,0 at the bottom left.
 205 static jboolean isCW(const jfloat dx1, const jfloat dy1,
 206                      const jfloat dx2, const jfloat dy2)
 207 {
 208     return dx1 * dy2 &lt;= dy1 * dx2;
 209 }
 210 
 211 // pisces used to use fixed point arithmetic with 16 decimal digits. I
 212 // didn&#39;t want to change the values of the constant below when I converted
 213 // it to floating point, so that&#39;s why the divisions by 2^16 are there.
 214 #define ROUND_JOIN_THRESHOLD   (1000/65536.0f)
 215 
<span class="line-modified"> 216 static void drawRoundJoin(PathConsumer *pStroker,</span>
 217                           jfloat x, jfloat y,
 218                           jfloat omx, jfloat omy, jfloat mx, jfloat my,
 219                           jboolean rev,
 220                           jfloat threshold)
 221 {
 222     jfloat domx, domy, len;
 223 
 224     if ((omx == 0 &amp;&amp; omy == 0) || (mx == 0 &amp;&amp; my == 0)) {
<span class="line-modified"> 225         return;</span>
 226     }
 227 
 228     domx = omx - mx;
 229     domy = omy - my;
 230     len = domx*domx + domy*domy;
 231     if (len &lt; threshold) {
<span class="line-modified"> 232         return;</span>
 233     }
 234 
 235     if (rev) {
 236         omx = -omx;
 237         omy = -omy;
 238         mx = -mx;
 239         my = -my;
 240     }
<span class="line-modified"> 241     drawRoundJoin2(pStroker, x, y, omx, omy, mx, my, rev);</span>
 242 }
 243 
<span class="line-modified"> 244 static void drawRoundJoin2(PathConsumer *pStroker,</span>
 245                            jfloat cx, jfloat cy,
 246                            jfloat omx, jfloat omy,
 247                            jfloat mx, jfloat my,
 248                            jboolean rev)
 249 {


 250     // The sign of the dot product of mx,my and omx,omy is equal to the
 251     // the sign of the cosine of ext
 252     // (ext is the angle between omx,omy and mx,my).
 253     jdouble cosext = omx * mx + omy * my;
 254     // If it is &gt;=0, we know that abs(ext) is &lt;= 90 degrees, so we only
 255     // need 1 curve to approximate the circle section that joins omx,omy
 256     // and mx,my.
 257     const jint numCurves = cosext &gt;= 0 ? 1 : 2;
 258 
 259     switch (numCurves) {
 260     case 1:
<span class="line-modified"> 261         drawBezApproxForArc(pStroker, cx, cy, omx, omy, mx, my, rev);</span>
 262         break;
 263     case 2:
 264         {
 265             // we need to split the arc into 2 arcs spanning the same angle.
 266             // The point we want will be one of the 2 intersections of the
 267             // perpendicular bisector of the chord (omx,omy)-&gt;(mx,my) and the
 268             // circle. We could find this by scaling the vector
 269             // (omx+mx, omy+my)/2 so that it has length=lineWidth2 (and thus lies
 270             // on the circle), but that can have numerical problems when the angle
 271             // between omx,omy and mx,my is close to 180 degrees. So we compute a
 272             // normal of (omx,omy)-(mx,my). This will be the direction of the
 273             // perpendicular bisector. To get one of the intersections, we just scale
 274             // this vector that its length is lineWidth2 (this works because the
 275             // perpendicular bisector goes through the origin). This scaling doesn&#39;t
 276             // have numerical problems because we know that lineWidth2 divided by
 277             // this normal&#39;s length is at least 0.5 and at most sqrt(2)/2 (because
 278             // we know the angle of the arc is &gt; 90 degrees).
 279             jfloat nx = my - omy, ny = omx - mx;
 280             jfloat nlen = (jfloat) sqrt(nx*nx + ny*ny);
 281             jfloat scale = this.lineWidth2/nlen;
 282             jfloat mmx = nx * scale, mmy = ny * scale;
 283 
 284             // if (isCW(omx, omy, mx, my) != isCW(mmx, mmy, mx, my)) then we&#39;ve
 285             // computed the wrong intersection so we get the other one.
 286             // The test above is equivalent to if (rev).
 287             if (rev) {
 288                 mmx = -mmx;
 289                 mmy = -mmy;
 290             }
<span class="line-modified"> 291             drawBezApproxForArc(pStroker, cx, cy, omx, omy, mmx, mmy, rev);</span>
<span class="line-modified"> 292             drawBezApproxForArc(pStroker, cx, cy, mmx, mmy, mx, my, rev);</span>



 293             break;
 294         }
 295     }

 296 }
 297 
 298 // the input arc defined by omx,omy and mx,my must span &lt;= 90 degrees.
<span class="line-modified"> 299 static void drawBezApproxForArc(PathConsumer *pStroker,</span>
 300                                 const jfloat cx, const jfloat cy,
 301                                 const jfloat omx, const jfloat omy,
 302                                 const jfloat mx, const jfloat my,
 303                                 jboolean rev)
 304 {
 305     jfloat cosext2 = (omx * mx + omy * my) / (2 * this.lineWidth2 * this.lineWidth2);
 306     // cv is the length of P1-P0 and P2-P3 divided by the radius of the arc
 307     // (so, cv assumes the arc has radius 1). P0, P1, P2, P3 are the points that
 308     // define the bezier curve we&#39;re computing.
 309     // It is computed using the constraints that P1-P0 and P3-P2 are parallel
 310     // to the arc tangents at the endpoints, and that |P1-P0|=|P3-P2|.
 311     jfloat cv = (jfloat) ((4.0 / 3.0) * sqrt(0.5-cosext2) /
 312                           (1.0 + sqrt(cosext2+0.5)));
 313     jfloat x1, y1, x2, y2, x3, y3, x4, y4;
 314 
 315     // if clockwise, we need to negate cv.
 316     if (rev) { // rev is equivalent to isCW(omx, omy, mx, my)
 317         cv = -cv;
 318     }
 319     x1 = cx + omx;
 320     y1 = cy + omy;
 321     x2 = x1 - cv * omy;
 322     y2 = y1 + cv * omx;
 323 
 324     x4 = cx + mx;
 325     y4 = cy + my;
 326     x3 = x4 + cv * my;
 327     y3 = y4 - cv * mx;
 328 
<span class="line-modified"> 329     emitCurveTo(pStroker, x1, y1, x2, y2, x3, y3, x4, y4, rev);</span>
 330 }
 331 
<span class="line-modified"> 332 static void drawRoundCap(PathConsumer *pStroker, jfloat cx, jfloat cy, jfloat mx, jfloat my) {</span>

 333     const jfloat C = 0.5522847498307933f;
 334     // the first and second arguments of the following two calls
 335     // are really will be ignored by emitCurveTo (because of the false),
 336     // but we put them in anyway, as opposed to just giving it 4 zeroes,
 337     // because it&#39;s just 4 additions and it&#39;s not good to rely on this
 338     // sort of assumption (right now it&#39;s true, but that may change).
<span class="line-modified"> 339     emitCurveTo(pStroker,</span>
 340                 cx+mx,      cy+my,
 341                 cx+mx-C*my, cy+my+C*mx,
 342                 cx-my+C*mx, cy+mx+C*my,
 343                 cx-my,      cy+mx,
 344                 JNI_FALSE);
<span class="line-modified"> 345     emitCurveTo(pStroker,</span>



 346                 cx-my,      cy+mx,
 347                 cx-my-C*mx, cy+mx-C*my,
 348                 cx-mx-C*my, cy-my+C*mx,
 349                 cx-mx,      cy-my,
 350                 JNI_FALSE);

 351 }
 352 
 353 // Return the intersection point of the lines (x0, y0) -&gt; (x1, y1)
 354 // and (x0p, y0p) -&gt; (x1p, y1p) in m[0] and m[1]
 355 static void computeMiter(const jfloat x0, const jfloat y0,
 356                          const jfloat x1, const jfloat y1,
 357                          const jfloat x0p, const jfloat y0p,
 358                          const jfloat x1p, const jfloat y1p,
 359                          jfloat m[], jint off)
 360 {
 361     jfloat x10 = x1 - x0;
 362     jfloat y10 = y1 - y0;
 363     jfloat x10p = x1p - x0p;
 364     jfloat y10p = y1p - y0p;
 365 
 366     // if this is 0, the lines are parallel. If they go in the
 367     // same direction, there is no intersection so m[off] and
 368     // m[off+1] will contain infinity, so no miter will be drawn.
 369     // If they go in the same direction that means that the start of the
 370     // current segment and the end of the previous segment have the same
</pre>
<hr />
<pre>
 398     // If they go in the same direction that means that the start of the
 399     // current segment and the end of the previous segment have the same
 400     // tangent, in which case this method won&#39;t even be involved in
 401     // miter drawing because it won&#39;t be called by drawMiter (because
 402     // (mx == omx &amp;&amp; my == omy) will be true, and drawMiter will return
 403     // immediately).
 404     jfloat den = x10*y10p - x10p*y10;
 405     jfloat t;
 406 
 407     if (den == 0) {
 408         m[off++] = (x0 + x0p) / 2.0f;
 409         m[off] = (y0 + y0p) / 2.0f;
 410         return;
 411     }
 412     t = x10p*(y0-y0p) - y10p*(x0-x0p);
 413     t /= den;
 414     m[off++] = x0 + t*x10;
 415     m[off] = y0 + t*y10;
 416 }
 417 
<span class="line-modified"> 418 static void drawMiter(PathConsumer *pStroker,</span>
 419                       const jfloat pdx, const jfloat pdy,
 420                       const jfloat x0, const jfloat y0,
 421                       const jfloat dx, const jfloat dy,
 422                       jfloat omx, jfloat omy, jfloat mx, jfloat my,
 423                       jboolean rev)
 424 {
 425     jfloat lenSq;
 426 
 427     if ((mx == omx &amp;&amp; my == omy) ||
 428         (pdx == 0 &amp;&amp; pdy == 0) ||
 429         (dx == 0 &amp;&amp; dy == 0)) {
<span class="line-modified"> 430         return;</span>
 431     }
 432 
 433     if (rev) {
 434         omx = -omx;
 435         omy = -omy;
 436         mx = -mx;
 437         my = -my;
 438     }
 439 
 440     computeMiter((x0 - pdx) + omx, (y0 - pdy) + omy, x0 + omx, y0 + omy,
 441                  (dx + x0) + mx, (dy + y0) + my, x0 + mx, y0 + my,
 442                  this.miter, 0);
 443 
 444     lenSq = (this.miter[0]-x0)*(this.miter[0]-x0) + (this.miter[1]-y0)*(this.miter[1]-y0);
 445 
 446     if (lenSq &lt; this.miterLimitSq) {
<span class="line-modified"> 447         emitLineTo(pStroker, this.miter[0], this.miter[1], rev);</span>
 448     }

 449 }
 450 
<span class="line-modified"> 451 static void Stroker_moveTo(PathConsumer *pStroker, jfloat x0, jfloat y0) {</span>

 452     if (this.prev == DRAWING_OP_TO) {
<span class="line-modified"> 453         finish(pStroker);</span>



 454     }
 455     this.sx0 = this.cx0 = x0;
 456     this.sy0 = this.cy0 = y0;
 457     this.cdx = this.sdx = 1;
 458     this.cdy = this.sdy = 0;
 459     this.prev = MOVE_TO;

 460 }
 461 
<span class="line-modified"> 462 static void Stroker_lineTo(PathConsumer *pStroker, jfloat x1, jfloat y1) {</span>

 463     jfloat dx = x1 - this.cx0;
 464     jfloat dy = y1 - this.cy0;
 465     jfloat mx, my;
 466 
 467     if (dx == 0.0f &amp;&amp; dy == 0.0f) {
 468         dx = 1;
 469     }
 470     computeOffset(dx, dy, this.lineWidth2, this.offset[0]);
 471     mx = this.offset[0][0];
 472     my = this.offset[0][1];
 473 
<span class="line-modified"> 474     drawJoin(pStroker,</span>
 475              this.cdx, this.cdy, this.cx0, this.cy0,
 476              dx, dy, this.cmx, this.cmy, mx, my);



 477 
<span class="line-modified"> 478     emitLineTo(pStroker, this.cx0 + mx, this.cy0 + my, JNI_FALSE);</span>
<span class="line-modified"> 479     emitLineTo(pStroker, x1 + mx, y1 + my, JNI_FALSE);</span>






 480 
<span class="line-modified"> 481     emitLineTo(pStroker, this.cx0 - mx, this.cy0 - my, JNI_TRUE);</span>
<span class="line-modified"> 482     emitLineTo(pStroker, x1 - mx, y1 - my, JNI_TRUE);</span>






 483 
 484     this.cmx = mx;
 485     this.cmy = my;
 486     this.cdx = dx;
 487     this.cdy = dy;
 488     this.cx0 = x1;
 489     this.cy0 = y1;
 490     this.prev = DRAWING_OP_TO;

 491 }
 492 
<span class="line-modified"> 493 static void Stroker_closePath(PathConsumer *pStroker) {</span>

 494     if (this.prev != DRAWING_OP_TO) {
 495         if (this.prev == CLOSE) {
<span class="line-modified"> 496             return;</span>




 497         }
<span class="line-removed"> 498         emitMoveTo(pStroker, this.cx0, this.cy0 - this.lineWidth2);</span>
 499         this.cmx = this.smx = 0;
 500         this.cmy = this.smy = -this.lineWidth2;
 501         this.cdx = this.sdx = 1;
 502         this.cdy = this.sdy = 0;
<span class="line-modified"> 503         finish(pStroker);</span>
<span class="line-removed"> 504         return;</span>
 505     }
 506 
 507     if (this.cx0 != this.sx0 || this.cy0 != this.sy0) {
<span class="line-modified"> 508         Stroker_lineTo(pStroker, this.sx0, this.sy0);</span>



 509     }
 510 
<span class="line-modified"> 511     drawJoin(pStroker,</span>
 512              this.cdx, this.cdy, this.cx0, this.cy0,
 513              this.sdx, this.sdy, this.cmx, this.cmy,
 514              this.smx, this.smy);



 515 
<span class="line-modified"> 516     emitLineTo(pStroker, this.sx0 + this.smx, this.sy0 + this.smy, JNI_FALSE);</span>



 517 
<span class="line-modified"> 518     emitMoveTo(pStroker, this.sx0 - this.smx, this.sy0 - this.smy);</span>
<span class="line-modified"> 519     emitReverse(pStroker);</span>






 520 
 521     this.prev = CLOSE;
<span class="line-modified"> 522     emitClose(pStroker);</span>
 523 }
 524 
<span class="line-modified"> 525 static void emitReverse(PathConsumer *pStroker) {</span>

 526     while (!PolyStack_isEmpty(&amp;this.reverse)) {
<span class="line-modified"> 527         PolyStack_pop(&amp;this.reverse, this.out);</span>



 528     }

 529 }
 530 
<span class="line-modified"> 531 static void Stroker_pathDone(PathConsumer *pStroker) {</span>

 532     if (this.prev == DRAWING_OP_TO) {
<span class="line-modified"> 533         finish(pStroker);</span>



 534     }
 535 
<span class="line-modified"> 536     this.out-&gt;pathDone(this.out);</span>



 537     // this shouldn&#39;t matter since this object won&#39;t be used
 538     // after the call to this method.
 539     this.prev = CLOSE;

 540 }
 541 
<span class="line-modified"> 542 static void finish(PathConsumer *pStroker) {</span>

 543     if (this.capStyle == CAP_ROUND) {
<span class="line-modified"> 544         drawRoundCap(pStroker, this.cx0, this.cy0, this.cmx, this.cmy);</span>



 545     } else if (this.capStyle == CAP_SQUARE) {
<span class="line-modified"> 546         emitLineTo(pStroker, this.cx0 - this.cmy + this.cmx, this.cy0 + this.cmx + this.cmy, JNI_FALSE);</span>
<span class="line-modified"> 547         emitLineTo(pStroker, this.cx0 - this.cmy - this.cmx, this.cy0 + this.cmx - this.cmy, JNI_FALSE);</span>






 548     }
 549 
<span class="line-modified"> 550     emitReverse(pStroker);</span>



 551 
 552     if (this.capStyle == CAP_ROUND) {
<span class="line-modified"> 553         drawRoundCap(pStroker, this.sx0, this.sy0, -this.smx, -this.smy);</span>



 554     } else if (this.capStyle == CAP_SQUARE) {
<span class="line-modified"> 555         emitLineTo(pStroker, this.sx0 + this.smy - this.smx, this.sy0 - this.smx - this.smy, JNI_FALSE);</span>
<span class="line-modified"> 556         emitLineTo(pStroker, this.sx0 + this.smy + this.smx, this.sy0 - this.smx + this.smy, JNI_FALSE);</span>






 557     }
 558 
<span class="line-modified"> 559     emitClose(pStroker);</span>
 560 }
 561 
<span class="line-modified"> 562 static void emitMoveTo(PathConsumer *pStroker, const jfloat x0, const jfloat y0) {</span>
<span class="line-modified"> 563     this.out-&gt;moveTo(this.out, x0, y0);</span>
 564 }
 565 
<span class="line-modified"> 566 static void emitLineTo(PathConsumer *pStroker, const jfloat x1, const jfloat y1,</span>
 567                        const jboolean rev)
 568 {
 569     if (rev) {
<span class="line-modified"> 570         PolyStack_pushLine(&amp;this.reverse, x1, y1);</span>
 571     } else {
<span class="line-modified"> 572         this.out-&gt;lineTo(this.out, x1, y1);</span>
 573     }
 574 }
 575 
<span class="line-modified"> 576 static void emitQuadTo(PathConsumer *pStroker,</span>
 577                        const jfloat x0, const jfloat y0,
 578                        const jfloat x1, const jfloat y1,
 579                        const jfloat x2, const jfloat y2, const jboolean rev)
 580 {
 581     if (rev) {
<span class="line-modified"> 582         PolyStack_pushQuad(&amp;this.reverse, x0, y0, x1, y1);</span>
 583     } else {
<span class="line-modified"> 584         this.out-&gt;quadTo(this.out, x1, y1, x2, y2);</span>
 585     }
 586 }
 587 
<span class="line-modified"> 588 static void emitCurveTo(PathConsumer *pStroker,</span>
 589                         const jfloat x0, const jfloat y0,
 590                         const jfloat x1, const jfloat y1,
 591                         const jfloat x2, const jfloat y2,
 592                         const jfloat x3, const jfloat y3, const jboolean rev)
 593 {
 594     if (rev) {
<span class="line-modified"> 595         PolyStack_pushCubic(&amp;this.reverse, x0, y0, x1, y1, x2, y2);</span>
 596     } else {
<span class="line-modified"> 597         this.out-&gt;curveTo(this.out, x1, y1, x2, y2, x3, y3);</span>
 598     }
 599 }
 600 
<span class="line-modified"> 601 static void emitClose(PathConsumer *pStroker) {</span>
<span class="line-modified"> 602     this.out-&gt;closePath(this.out);</span>
 603 }
 604 
<span class="line-modified"> 605 static void drawJoin(PathConsumer *pStroker,</span>
 606                      jfloat pdx, jfloat pdy,
 607                      jfloat x0, jfloat y0,
 608                      jfloat dx, jfloat dy,
 609                      jfloat omx, jfloat omy,
 610                      jfloat mx, jfloat my)
 611 {

 612     if (this.prev != DRAWING_OP_TO) {
<span class="line-modified"> 613         emitMoveTo(pStroker, x0 + mx, y0 + my);</span>



 614         this.sdx = dx;
 615         this.sdy = dy;
 616         this.smx = mx;
 617         this.smy = my;
 618     } else {
 619         jboolean cw = isCW(pdx, pdy, dx, dy);
 620         if (this.joinStyle == JOIN_MITER) {
<span class="line-modified"> 621             drawMiter(pStroker, pdx, pdy, x0, y0, dx, dy, omx, omy, mx, my, cw);</span>



 622         } else if (this.joinStyle == JOIN_ROUND) {
<span class="line-modified"> 623             drawRoundJoin(pStroker,</span>
 624                           x0, y0,
 625                           omx, omy,
 626                           mx, my, cw,
 627                           ROUND_JOIN_THRESHOLD);







 628         }
<span class="line-removed"> 629         emitLineTo(pStroker, x0, y0, !cw);</span>
 630     }
 631     this.prev = DRAWING_OP_TO;

 632 }
 633 
 634 static jboolean withinULP(const jfloat x1, const jfloat y1,
 635                           const jfloat x2, const jfloat y2,
 636                           const int maxUlps)
 637 {
 638 //    assert maxUlps is much smaller than 0x7fffffff;
 639     // compare taxicab distance. ERR will always be small, so using
 640     // true distance won&#39;t give much benefit
 641     return (Helpers_withinULP(x1, x2, maxUlps) &amp;&amp;
 642             Helpers_withinULP(y1, y2, maxUlps));
 643 }
 644 
 645 static void getLineOffsets(PathConsumer *pStroker,
 646                            jfloat x1, jfloat y1,
 647                            jfloat x2, jfloat y2,
 648                            jfloat left[], jfloat right[]) {
 649     computeOffset(x2 - x1, y2 - y1, this.lineWidth2, this.offset[0]);
 650     left[0] = x1 + this.offset[0][0];
 651     left[1] = y1 + this.offset[0][1];
</pre>
<hr />
<pre>
1049 
1050     // we subdivide at values of t such that the remaining rotated
1051     // curves are monotonic in x and y.
1052     ret += Curve_dxRoots(&amp;this.c, ts, ret);
1053     ret += Curve_dyRoots(&amp;this.c, ts, ret);
1054     // subdivide at inflection points.
1055     if (type == 8) {
1056         // quadratic curves can&#39;t have inflection points
1057         ret += Curve_infPoints(&amp;this.c, ts, ret);
1058     }
1059 
1060     // now we must subdivide at points where one of the offset curves will have
1061     // a cusp. This happens at ts where the radius of curvature is equal to w.
1062     ret += Curve_rootsOfROCMinusW(&amp;this.c, ts, ret, w, 0.0001f);
1063 
1064     ret = Helpers_filterOutNotInAB(ts, 0, ret, 0.0001f, 0.9999f);
1065     Helpers_isort(ts, 0, ret);
1066     return ret;
1067 }
1068 
<span class="line-modified">1069 static void Stroker_curveTo(PathConsumer *pStroker,</span>
1070                            jfloat x1, jfloat y1,
1071                            jfloat x2, jfloat y2,
1072                            jfloat x3, jfloat y3)
1073 {

1074     jfloat xf, yf, dxs, dys, dxf, dyf;
1075     jfloat mx, my;
1076     jint nSplits;
1077     jfloat prevT;
1078     jint i, kind;
1079     jboolean p1eqp2, p3eqp4;
1080 
1081     middle[0] = this.cx0; middle[1] = this.cy0;
1082     middle[2] = x1;  middle[3] = y1;
1083     middle[4] = x2;  middle[5] = y2;
1084     middle[6] = x3;  middle[7] = y3;
1085 
1086     // inlined version of somethingTo(8);
1087     // See the NOTE on somethingTo
1088 
1089     // need these so we can update the state at the end of this method
1090     xf = middle[6], yf = middle[7];
1091     dxs = middle[2] - middle[0];
1092     dys = middle[3] - middle[1];
1093     dxf = middle[6] - middle[4];
</pre>
<hr />
<pre>
1096     p1eqp2 = (dxs == 0.0f &amp;&amp; dys == 0.0f);
1097     p3eqp4 = (dxf == 0.0f &amp;&amp; dyf == 0.0f);
1098     if (p1eqp2) {
1099         dxs = middle[4] - middle[0];
1100         dys = middle[5] - middle[1];
1101         if (dxs == 0.0f &amp;&amp; dys == 0.0f) {
1102             dxs = middle[6] - middle[0];
1103             dys = middle[7] - middle[1];
1104         }
1105     }
1106     if (p3eqp4) {
1107         dxf = middle[6] - middle[2];
1108         dyf = middle[7] - middle[3];
1109         if (dxf == 0.0f &amp;&amp; dyf == 0.0f) {
1110             dxf = middle[6] - middle[0];
1111             dyf = middle[7] - middle[1];
1112         }
1113     }
1114     if (dxs == 0.0f &amp;&amp; dys == 0.0f) {
1115         // this happens iff the &quot;curve&quot; is just a point
<span class="line-modified">1116         Stroker_lineTo(pStroker, middle[0], middle[1]);</span>
<span class="line-removed">1117         return;</span>
1118     }
1119 
1120     // if these vectors are too small, normalize them, to avoid future
1121     // precision problems.
1122     if (fabs(dxs) &lt; 0.1f &amp;&amp; fabs(dys) &lt; 0.1f) {
1123         jfloat len = (jfloat) sqrt(dxs*dxs + dys*dys);
1124         dxs /= len;
1125         dys /= len;
1126     }
1127     if (fabs(dxf) &lt; 0.1f &amp;&amp; fabs(dyf) &lt; 0.1f) {
1128         jfloat len = (jfloat) sqrt(dxf*dxf + dyf*dyf);
1129         dxf /= len;
1130         dyf /= len;
1131     }
1132 
1133     computeOffset(dxs, dys, this.lineWidth2, this.offset[0]);
1134     mx = this.offset[0][0];
1135     my = this.offset[0][1];
<span class="line-modified">1136     drawJoin(pStroker,</span>
1137              this.cdx, this.cdy, this.cx0, this.cy0,
1138              dxs, dys, this.cmx, this.cmy,
1139              mx, my);



1140 
1141     nSplits = findSubdivPoints(pStroker, middle, subdivTs, 8, this.lineWidth2);
1142     prevT = 0.0f;
1143     for (i = 0; i &lt; nSplits; i++) {
1144         jfloat t = subdivTs[i];
1145         Helpers_subdivideCubicAt((t - prevT) / (1 - prevT),
1146                                  middle, i*6,
1147                                  middle, i*6,
1148                                  middle, i*6+6);
1149         prevT = t;
1150     }
1151 
1152     kind = 0;
1153     for (i = 0; i &lt;= nSplits; i++) {
1154         kind = computeOffsetCubic(pStroker, middle, i*6, lp, rp);
1155         if (kind != 0) {
<span class="line-modified">1156             emitLineTo(pStroker, lp[0], lp[1], JNI_FALSE);</span>



1157             switch(kind) {
1158             case 8:
<span class="line-modified">1159                 emitCurveTo(pStroker, lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], lp[6], lp[7], JNI_FALSE);</span>
<span class="line-modified">1160                 emitCurveTo(pStroker, rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], rp[6], rp[7], JNI_TRUE);</span>






1161                 break;
1162             case 4:
<span class="line-modified">1163                 emitLineTo(pStroker, lp[2], lp[3], JNI_FALSE);</span>
<span class="line-modified">1164                 emitLineTo(pStroker, rp[0], rp[1], JNI_TRUE);</span>






1165                 break;
1166             }
<span class="line-modified">1167             emitLineTo(pStroker, rp[kind - 2], rp[kind - 1], JNI_TRUE);</span>



1168         }
1169     }
1170 
1171     this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;
1172     this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;
1173     this.cdx = dxf;
1174     this.cdy = dyf;
1175     this.cx0 = xf;
1176     this.cy0 = yf;
1177     this.prev = DRAWING_OP_TO;

1178 }
1179 
<span class="line-modified">1180 static void Stroker_quadTo(PathConsumer *pStroker,</span>
1181                           jfloat x1, jfloat y1,
1182                           jfloat x2, jfloat y2)
1183 {

1184     jfloat xf, yf, dxs, dys, dxf, dyf;
1185     jfloat mx, my;
1186     jint nSplits, i, kind;
1187     jfloat prevt;
1188 
1189     middle[0] = this.cx0; middle[1] = this.cy0;
1190     middle[2] = x1;  middle[3] = y1;
1191     middle[4] = x2;  middle[5] = y2;
1192 
1193     // inlined version of somethingTo(8);
1194     // See the NOTE on somethingTo
1195 
1196     // need these so we can update the state at the end of this method
1197     xf = middle[4], yf = middle[5];
1198     dxs = middle[2] - middle[0];
1199     dys = middle[3] - middle[1];
1200     dxf = middle[4] - middle[2];
1201     dyf = middle[5] - middle[3];
1202     if ((dxs == 0.0f &amp;&amp; dys == 0.0f) || (dxf == 0.0f &amp;&amp; dyf == 0.0f)) {
1203         dxs = dxf = middle[4] - middle[0];
1204         dys = dyf = middle[5] - middle[1];
1205     }
1206     if (dxs == 0.0f &amp;&amp; dys == 0.0f) {
1207         // this happens iff the &quot;curve&quot; is just a point
<span class="line-modified">1208         Stroker_lineTo(pStroker, middle[0], middle[1]);</span>
<span class="line-removed">1209         return;</span>
1210     }
1211     // if these vectors are too small, normalize them, to avoid future
1212     // precision problems.
1213     if (fabs(dxs) &lt; 0.1f &amp;&amp; fabs(dys) &lt; 0.1f) {
1214         jfloat len = (jfloat) sqrt(dxs*dxs + dys*dys);
1215         dxs /= len;
1216         dys /= len;
1217     }
1218     if (fabs(dxf) &lt; 0.1f &amp;&amp; fabs(dyf) &lt; 0.1f) {
1219         jfloat len = (jfloat) sqrt(dxf*dxf + dyf*dyf);
1220         dxf /= len;
1221         dyf /= len;
1222     }
1223 
1224     computeOffset(dxs, dys, this.lineWidth2, this.offset[0]);
1225     mx = this.offset[0][0];
1226     my = this.offset[0][1];
<span class="line-modified">1227     drawJoin(pStroker,</span>
1228              this.cdx, this.cdy, this.cx0, this.cy0,
1229              dxs, dys, this.cmx, this.cmy,
1230              mx, my);



1231 
1232     nSplits = findSubdivPoints(pStroker, middle, subdivTs, 6, this.lineWidth2);
1233     prevt = 0.0f;
1234     for (i = 0; i &lt; nSplits; i++) {
1235         jfloat t = subdivTs[i];
1236         Helpers_subdivideQuadAt((t - prevt) / (1 - prevt),
1237                                 middle, i*4,
1238                                 middle, i*4,
1239                                 middle, i*4+4);
1240         prevt = t;
1241     }
1242 
1243     kind = 0;
1244     for (i = 0; i &lt;= nSplits; i++) {
1245         kind = computeOffsetQuad(pStroker, middle, i*4, lp, rp);
1246         if (kind != 0) {
<span class="line-modified">1247             emitLineTo(pStroker, lp[0], lp[1], JNI_FALSE);</span>



1248             switch(kind) {
1249             case 6:
<span class="line-modified">1250                 emitQuadTo(pStroker, lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], JNI_FALSE);</span>
<span class="line-modified">1251                 emitQuadTo(pStroker, rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], JNI_TRUE);</span>






1252                 break;
1253             case 4:
<span class="line-modified">1254                 emitLineTo(pStroker, lp[2], lp[3], JNI_FALSE);</span>
<span class="line-modified">1255                 emitLineTo(pStroker, rp[0], rp[1], JNI_TRUE);</span>






1256                 break;
1257             }
<span class="line-modified">1258             emitLineTo(pStroker, rp[kind - 2], rp[kind - 1], JNI_TRUE);</span>



1259         }
1260     }
1261 
1262     this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;
1263     this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;
1264     this.cdx = dxf;
1265     this.cdy = dyf;
1266     this.cx0 = xf;
1267     this.cy0 = yf;
1268     this.prev = DRAWING_OP_TO;

1269 }
1270 
1271 // a stack of polynomial curves where each curve shares endpoints with
1272 // adjacent ones.
1273 /*
1274     private static const class PolyStack {
1275         jfloat[] curves;
1276         int end;
1277         int[] curveTypes;
1278         int numCurves;
1279  */
1280 
1281 #define INIT_SIZE   50
1282 
1283 #undef this
1284 #define this (*((PolyStack *)pStack))
1285 
1286 void PolyStack_init(PolyStack *pStack) {
1287     this.curves = new_float(8 * INIT_SIZE);
1288     this.curvesSIZE = 8 * INIT_SIZE;
1289     this.curveTypes = new_int(INIT_SIZE);
1290     this.curveTypesSIZE = INIT_SIZE;
1291     this.end = 0;
1292     this.numCurves = 0;
1293 }
1294 
1295 void PolyStack_destroy(PolyStack *pStack) {
1296     free(this.curves);
1297     this.curves = NULL;
1298     this.curvesSIZE = 0;
1299     free(this.curveTypes);
1300     this.curveTypes = NULL;
1301     this.curveTypesSIZE = 0;
1302 }
1303 
1304 jboolean PolyStack_isEmpty(PolyStack *pStack) {
1305     return this.numCurves == 0;
1306 }
1307 
<span class="line-modified">1308 static void ensureSpace(PolyStack *pStack, jint n) {</span>
1309     if (this.end + n &gt;= this.curvesSIZE) {
1310         jint newSize = (this.end + n) * 2;
1311         jfloat *newCurves = new_float(newSize);



1312         System_arraycopy(this.curves, 0, newCurves, 0, this.end);
1313         free(this.curves);
1314         this.curves = newCurves;
1315         this.curvesSIZE = newSize;
1316     }
1317     if (this.numCurves &gt;= this.curveTypesSIZE) {
1318         jint newSize = this.numCurves * 2;
1319         jint *newTypes = new_int(newSize);



1320         System_arraycopy(this.curveTypes, 0, newTypes, 0, this.numCurves);
1321         free(this.curveTypes);
1322         this.curveTypes = newTypes;
1323         this.curveTypesSIZE = newSize;
1324     }

1325 }
1326 
<span class="line-modified">1327 void PolyStack_pushCubic(PolyStack *pStack,</span>
1328                          jfloat x0, jfloat y0,
1329                          jfloat x1, jfloat y1,
1330                          jfloat x2, jfloat y2)
1331 {
<span class="line-modified">1332     ensureSpace(pStack, 6);</span>



1333     this.curveTypes[this.numCurves++] = 8;
1334     // assert(x0 == lastX &amp;&amp; y0 == lastY)
1335 
1336     // we reverse the coordinate order to make popping easier
1337     this.curves[this.end++] = x2;    this.curves[this.end++] = y2;
1338     this.curves[this.end++] = x1;    this.curves[this.end++] = y1;
1339     this.curves[this.end++] = x0;    this.curves[this.end++] = y0;

1340 }
1341 
<span class="line-modified">1342 void PolyStack_pushQuad(PolyStack *pStack,</span>
1343                         jfloat x0, jfloat y0,
1344                         jfloat x1, jfloat y1)
1345 {
<span class="line-modified">1346     ensureSpace(pStack, 4);</span>



1347     this.curveTypes[this.numCurves++] = 6;
1348     // assert(x0 == lastX &amp;&amp; y0 == lastY)
1349     this.curves[this.end++] = x1;    this.curves[this.end++] = y1;
1350     this.curves[this.end++] = x0;    this.curves[this.end++] = y0;

1351 }
1352 
<span class="line-modified">1353 void PolyStack_pushLine(PolyStack *pStack,</span>
1354                         jfloat x, jfloat y)
1355 {
<span class="line-modified">1356     ensureSpace(pStack, 2);</span>



1357     this.curveTypes[this.numCurves++] = 4;
1358     // assert(x0 == lastX &amp;&amp; y0 == lastY)
1359     this.curves[this.end++] = x;    this.curves[this.end++] = y;

1360 }
1361 
1362 //@SuppressWarnings(&quot;unused&quot;)
1363 /*
1364 jint PolyStack_pop(PolyStack *pStack, jfloat pts[]) {
1365     jint ret = this.curveTypes[this.numCurves - 1];
1366     this.numCurves--;
1367     this.end -= (ret - 2);
1368     System_arraycopy(curves, end, pts, 0, ret - 2);
1369     return ret;
1370 }
1371 */
1372 
<span class="line-modified">1373 void PolyStack_pop(PolyStack *pStack, PathConsumer *io) {</span>

1374     jint type;
1375 
1376     this.numCurves--;
1377     type = this.curveTypes[this.numCurves];
1378     this.end -= (type - 2);
1379     switch(type) {
1380     case 8:
<span class="line-modified">1381         io-&gt;curveTo(io,</span>
1382                     this.curves[this.end+0], this.curves[this.end+1],
1383                     this.curves[this.end+2], this.curves[this.end+3],
1384                     this.curves[this.end+4], this.curves[this.end+5]);
1385         break;
1386     case 6:
<span class="line-modified">1387         io-&gt;quadTo(io,</span>
1388                    this.curves[this.end+0], this.curves[this.end+1],
1389                    this.curves[this.end+2], this.curves[this.end+3]);
<span class="line-modified">1390             break;</span>
1391     case 4:
<span class="line-modified">1392         io-&gt;lineTo(io, this.curves[this.end], this.curves[this.end+1]);</span>
1393     }

1394 }
1395 
1396 //@Override
1397 /*
1398 public String toString() {
1399     String ret = &quot;&quot;;
1400     jint nc = numCurves;
1401     jint last = this.end;
1402     while (nc &gt; 0) {
1403         nc--;
1404         jint type = curveTypes[numCurves];
1405         last -= (type - 2);
1406         switch(type) {
1407         case 8:
1408             ret += &quot;cubic: &quot;;
1409             break;
1410         case 6:
1411             ret += &quot;quad: &quot;;
1412             break;
1413         case 4:
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  34 #include &quot;Stroker.h&quot;
  35 
  36 // NOTE: some of the arithmetic here is too verbose and prone to hard to
  37 // debug typos. We should consider making a small Point/Vector class that
  38 // has methods like plus(Point), minus(Point), dot(Point), cross(Point)and such
  39 //public final class Stroker implements PathConsumer2D {
  40 
  41 #define MOVE_TO  0
  42 #define DRAWING_OP_TO  1 // ie. curve, line, or quad
  43 #define CLOSE  2
  44 
  45 static MoveToFunc       Stroker_moveTo;
  46 static LineToFunc       Stroker_lineTo;
  47 static QuadToFunc       Stroker_quadTo;
  48 static CurveToFunc      Stroker_curveTo;
  49 static ClosePathFunc    Stroker_closePath;
  50 static PathDoneFunc     Stroker_pathDone;
  51 
  52 #define this (*((Stroker *) pStroker))
  53 
<span class="line-modified">  54 static jint drawJoin(PathConsumer *pStroker,</span>
  55                      jfloat pdx, jfloat pdy,
  56                      jfloat x0, jfloat y0,
  57                      jfloat dx, jfloat dy,
  58                      jfloat omx, jfloat omy,
  59                      jfloat mx, jfloat my);
  60 
<span class="line-modified">  61 static jint drawRoundJoin2(PathConsumer *pStroker,</span>
  62                            jfloat cx, jfloat cy,
  63                            jfloat omx, jfloat omy,
  64                            jfloat mx, jfloat my,
  65                            jboolean rev);
  66 
<span class="line-modified">  67 static jint drawBezApproxForArc(PathConsumer *pStroker,</span>
  68                                 const jfloat cx, const jfloat cy,
  69                                 const jfloat omx, const jfloat omy,
  70                                 const jfloat mx, const jfloat my,
  71                                 jboolean rev);
  72 
<span class="line-modified">  73 static jint emitMoveTo(PathConsumer *pStroker, const jfloat x0, const jfloat y0);</span>
  74 
<span class="line-modified">  75 static jint emitLineTo(PathConsumer *pStroker, const jfloat x1, const jfloat y1,</span>
  76                        const jboolean rev);
  77 
<span class="line-modified">  78 static jint emitCurveTo(PathConsumer *pStroker,</span>
  79                         const jfloat x0, const jfloat y0,
  80                         const jfloat x1, const jfloat y1,
  81                         const jfloat x2, const jfloat y2,
  82                         const jfloat x3, const jfloat y3, const jboolean rev);
  83 
<span class="line-modified">  84 static jint emitClose(PathConsumer *pStroker);</span>
  85 
<span class="line-modified">  86 static jint emitReverse(PathConsumer *pStroker);</span>
  87 
<span class="line-modified">  88 static jint finish(PathConsumer *pStroker);</span>
  89 
  90 extern void PolyStack_init(PolyStack *pStack);
  91 
  92 extern void PolyStack_destroy(PolyStack *pStack);
  93 
  94 extern jboolean PolyStack_isEmpty(PolyStack *pStack);
  95 
<span class="line-modified">  96 extern jint PolyStack_pushLine(PolyStack *pStack,</span>
  97                                jfloat x, jfloat y);
  98 
<span class="line-modified">  99 extern jint PolyStack_pushCubic(PolyStack *pStack,</span>
 100                                 jfloat x0, jfloat y0,
 101                                 jfloat x1, jfloat y1,
 102                                 jfloat x2, jfloat y2);
 103 
<span class="line-modified"> 104 extern jint PolyStack_pushQuad(PolyStack *pStack,</span>
 105                                jfloat x0, jfloat y0,
 106                                jfloat x1, jfloat y1);
 107 
<span class="line-modified"> 108 extern jint PolyStack_pop(PolyStack *pStack, PathConsumer *io);</span>
 109 
 110     /**
 111      * Constructs a &lt;code&gt;Stroker&lt;/code&gt;.
 112      *
 113      * @param pc2d an output &lt;code&gt;PathConsumer2D&lt;/code&gt;.
 114      * @param lineWidth the desired line width in pixels
 115      * @param capStyle the desired end cap style, one of
 116      * &lt;code&gt;CAP_BUTT&lt;/code&gt;, &lt;code&gt;CAP_ROUND&lt;/code&gt; or
 117      * &lt;code&gt;CAP_SQUARE&lt;/code&gt;.
 118      * @param joinStyle the desired line join style, one of
 119      * &lt;code&gt;JOIN_MITER&lt;/code&gt;, &lt;code&gt;JOIN_ROUND&lt;/code&gt; or
 120      * &lt;code&gt;JOIN_BEVEL&lt;/code&gt;.
 121      * @param miterLimit the desired miter limit
 122     public Stroker(PathConsumer2D pc2d,
 123                    float lineWidth,
 124                    jint capStyle,
 125                    jint joinStyle,
 126                    float miterLimit)
 127     {
 128         this(pc2d);
</pre>
<hr />
<pre>
 196 
 197 // Returns true if the vectors (dx1, dy1) and (dx2, dy2) are
 198 // clockwise (if dx1,dy1 needs to be rotated clockwise to close
 199 // the smallest angle between it and dx2,dy2).
 200 // This is equivalent to detecting whether a point q is on the right side
 201 // of a line passing through points p1, p2 where p2 = p1+(dx1,dy1) and
 202 // q = p2+(dx2,dy2), which is the same as saying p1, p2, q are in a
 203 // clockwise order.
 204 // NOTE: &quot;clockwise&quot; here assumes coordinates with 0,0 at the bottom left.
 205 static jboolean isCW(const jfloat dx1, const jfloat dy1,
 206                      const jfloat dx2, const jfloat dy2)
 207 {
 208     return dx1 * dy2 &lt;= dy1 * dx2;
 209 }
 210 
 211 // pisces used to use fixed point arithmetic with 16 decimal digits. I
 212 // didn&#39;t want to change the values of the constant below when I converted
 213 // it to floating point, so that&#39;s why the divisions by 2^16 are there.
 214 #define ROUND_JOIN_THRESHOLD   (1000/65536.0f)
 215 
<span class="line-modified"> 216 static jint drawRoundJoin(PathConsumer *pStroker,</span>
 217                           jfloat x, jfloat y,
 218                           jfloat omx, jfloat omy, jfloat mx, jfloat my,
 219                           jboolean rev,
 220                           jfloat threshold)
 221 {
 222     jfloat domx, domy, len;
 223 
 224     if ((omx == 0 &amp;&amp; omy == 0) || (mx == 0 &amp;&amp; my == 0)) {
<span class="line-modified"> 225         return ERROR_NONE;</span>
 226     }
 227 
 228     domx = omx - mx;
 229     domy = omy - my;
 230     len = domx*domx + domy*domy;
 231     if (len &lt; threshold) {
<span class="line-modified"> 232         return ERROR_NONE;</span>
 233     }
 234 
 235     if (rev) {
 236         omx = -omx;
 237         omy = -omy;
 238         mx = -mx;
 239         my = -my;
 240     }
<span class="line-modified"> 241     return drawRoundJoin2(pStroker, x, y, omx, omy, mx, my, rev);</span>
 242 }
 243 
<span class="line-modified"> 244 static jint drawRoundJoin2(PathConsumer *pStroker,</span>
 245                            jfloat cx, jfloat cy,
 246                            jfloat omx, jfloat omy,
 247                            jfloat mx, jfloat my,
 248                            jboolean rev)
 249 {
<span class="line-added"> 250     jint status = ERROR_NONE;</span>
<span class="line-added"> 251 </span>
 252     // The sign of the dot product of mx,my and omx,omy is equal to the
 253     // the sign of the cosine of ext
 254     // (ext is the angle between omx,omy and mx,my).
 255     jdouble cosext = omx * mx + omy * my;
 256     // If it is &gt;=0, we know that abs(ext) is &lt;= 90 degrees, so we only
 257     // need 1 curve to approximate the circle section that joins omx,omy
 258     // and mx,my.
 259     const jint numCurves = cosext &gt;= 0 ? 1 : 2;
 260 
 261     switch (numCurves) {
 262     case 1:
<span class="line-modified"> 263         status = drawBezApproxForArc(pStroker, cx, cy, omx, omy, mx, my, rev);</span>
 264         break;
 265     case 2:
 266         {
 267             // we need to split the arc into 2 arcs spanning the same angle.
 268             // The point we want will be one of the 2 intersections of the
 269             // perpendicular bisector of the chord (omx,omy)-&gt;(mx,my) and the
 270             // circle. We could find this by scaling the vector
 271             // (omx+mx, omy+my)/2 so that it has length=lineWidth2 (and thus lies
 272             // on the circle), but that can have numerical problems when the angle
 273             // between omx,omy and mx,my is close to 180 degrees. So we compute a
 274             // normal of (omx,omy)-(mx,my). This will be the direction of the
 275             // perpendicular bisector. To get one of the intersections, we just scale
 276             // this vector that its length is lineWidth2 (this works because the
 277             // perpendicular bisector goes through the origin). This scaling doesn&#39;t
 278             // have numerical problems because we know that lineWidth2 divided by
 279             // this normal&#39;s length is at least 0.5 and at most sqrt(2)/2 (because
 280             // we know the angle of the arc is &gt; 90 degrees).
 281             jfloat nx = my - omy, ny = omx - mx;
 282             jfloat nlen = (jfloat) sqrt(nx*nx + ny*ny);
 283             jfloat scale = this.lineWidth2/nlen;
 284             jfloat mmx = nx * scale, mmy = ny * scale;
 285 
 286             // if (isCW(omx, omy, mx, my) != isCW(mmx, mmy, mx, my)) then we&#39;ve
 287             // computed the wrong intersection so we get the other one.
 288             // The test above is equivalent to if (rev).
 289             if (rev) {
 290                 mmx = -mmx;
 291                 mmy = -mmy;
 292             }
<span class="line-modified"> 293             status = drawBezApproxForArc(pStroker, cx, cy, omx, omy, mmx, mmy, rev);</span>
<span class="line-modified"> 294             if (status != ERROR_NONE) {</span>
<span class="line-added"> 295                 return status;</span>
<span class="line-added"> 296             }</span>
<span class="line-added"> 297             status = drawBezApproxForArc(pStroker, cx, cy, mmx, mmy, mx, my, rev);</span>
 298             break;
 299         }
 300     }
<span class="line-added"> 301     return status;</span>
 302 }
 303 
 304 // the input arc defined by omx,omy and mx,my must span &lt;= 90 degrees.
<span class="line-modified"> 305 static jint drawBezApproxForArc(PathConsumer *pStroker,</span>
 306                                 const jfloat cx, const jfloat cy,
 307                                 const jfloat omx, const jfloat omy,
 308                                 const jfloat mx, const jfloat my,
 309                                 jboolean rev)
 310 {
 311     jfloat cosext2 = (omx * mx + omy * my) / (2 * this.lineWidth2 * this.lineWidth2);
 312     // cv is the length of P1-P0 and P2-P3 divided by the radius of the arc
 313     // (so, cv assumes the arc has radius 1). P0, P1, P2, P3 are the points that
 314     // define the bezier curve we&#39;re computing.
 315     // It is computed using the constraints that P1-P0 and P3-P2 are parallel
 316     // to the arc tangents at the endpoints, and that |P1-P0|=|P3-P2|.
 317     jfloat cv = (jfloat) ((4.0 / 3.0) * sqrt(0.5-cosext2) /
 318                           (1.0 + sqrt(cosext2+0.5)));
 319     jfloat x1, y1, x2, y2, x3, y3, x4, y4;
 320 
 321     // if clockwise, we need to negate cv.
 322     if (rev) { // rev is equivalent to isCW(omx, omy, mx, my)
 323         cv = -cv;
 324     }
 325     x1 = cx + omx;
 326     y1 = cy + omy;
 327     x2 = x1 - cv * omy;
 328     y2 = y1 + cv * omx;
 329 
 330     x4 = cx + mx;
 331     y4 = cy + my;
 332     x3 = x4 + cv * my;
 333     y3 = y4 - cv * mx;
 334 
<span class="line-modified"> 335     return emitCurveTo(pStroker, x1, y1, x2, y2, x3, y3, x4, y4, rev);</span>
 336 }
 337 
<span class="line-modified"> 338 static jint drawRoundCap(PathConsumer *pStroker, jfloat cx, jfloat cy, jfloat mx, jfloat my) {</span>
<span class="line-added"> 339     jint status = ERROR_NONE;</span>
 340     const jfloat C = 0.5522847498307933f;
 341     // the first and second arguments of the following two calls
 342     // are really will be ignored by emitCurveTo (because of the false),
 343     // but we put them in anyway, as opposed to just giving it 4 zeroes,
 344     // because it&#39;s just 4 additions and it&#39;s not good to rely on this
 345     // sort of assumption (right now it&#39;s true, but that may change).
<span class="line-modified"> 346     status = emitCurveTo(pStroker,</span>
 347                 cx+mx,      cy+my,
 348                 cx+mx-C*my, cy+my+C*mx,
 349                 cx-my+C*mx, cy+mx+C*my,
 350                 cx-my,      cy+mx,
 351                 JNI_FALSE);
<span class="line-modified"> 352     if (status != ERROR_NONE) {</span>
<span class="line-added"> 353         return status;</span>
<span class="line-added"> 354     }</span>
<span class="line-added"> 355     status = emitCurveTo(pStroker,</span>
 356                 cx-my,      cy+mx,
 357                 cx-my-C*mx, cy+mx-C*my,
 358                 cx-mx-C*my, cy-my+C*mx,
 359                 cx-mx,      cy-my,
 360                 JNI_FALSE);
<span class="line-added"> 361     return status;</span>
 362 }
 363 
 364 // Return the intersection point of the lines (x0, y0) -&gt; (x1, y1)
 365 // and (x0p, y0p) -&gt; (x1p, y1p) in m[0] and m[1]
 366 static void computeMiter(const jfloat x0, const jfloat y0,
 367                          const jfloat x1, const jfloat y1,
 368                          const jfloat x0p, const jfloat y0p,
 369                          const jfloat x1p, const jfloat y1p,
 370                          jfloat m[], jint off)
 371 {
 372     jfloat x10 = x1 - x0;
 373     jfloat y10 = y1 - y0;
 374     jfloat x10p = x1p - x0p;
 375     jfloat y10p = y1p - y0p;
 376 
 377     // if this is 0, the lines are parallel. If they go in the
 378     // same direction, there is no intersection so m[off] and
 379     // m[off+1] will contain infinity, so no miter will be drawn.
 380     // If they go in the same direction that means that the start of the
 381     // current segment and the end of the previous segment have the same
</pre>
<hr />
<pre>
 409     // If they go in the same direction that means that the start of the
 410     // current segment and the end of the previous segment have the same
 411     // tangent, in which case this method won&#39;t even be involved in
 412     // miter drawing because it won&#39;t be called by drawMiter (because
 413     // (mx == omx &amp;&amp; my == omy) will be true, and drawMiter will return
 414     // immediately).
 415     jfloat den = x10*y10p - x10p*y10;
 416     jfloat t;
 417 
 418     if (den == 0) {
 419         m[off++] = (x0 + x0p) / 2.0f;
 420         m[off] = (y0 + y0p) / 2.0f;
 421         return;
 422     }
 423     t = x10p*(y0-y0p) - y10p*(x0-x0p);
 424     t /= den;
 425     m[off++] = x0 + t*x10;
 426     m[off] = y0 + t*y10;
 427 }
 428 
<span class="line-modified"> 429 static jint drawMiter(PathConsumer *pStroker,</span>
 430                       const jfloat pdx, const jfloat pdy,
 431                       const jfloat x0, const jfloat y0,
 432                       const jfloat dx, const jfloat dy,
 433                       jfloat omx, jfloat omy, jfloat mx, jfloat my,
 434                       jboolean rev)
 435 {
 436     jfloat lenSq;
 437 
 438     if ((mx == omx &amp;&amp; my == omy) ||
 439         (pdx == 0 &amp;&amp; pdy == 0) ||
 440         (dx == 0 &amp;&amp; dy == 0)) {
<span class="line-modified"> 441         return ERROR_NONE;</span>
 442     }
 443 
 444     if (rev) {
 445         omx = -omx;
 446         omy = -omy;
 447         mx = -mx;
 448         my = -my;
 449     }
 450 
 451     computeMiter((x0 - pdx) + omx, (y0 - pdy) + omy, x0 + omx, y0 + omy,
 452                  (dx + x0) + mx, (dy + y0) + my, x0 + mx, y0 + my,
 453                  this.miter, 0);
 454 
 455     lenSq = (this.miter[0]-x0)*(this.miter[0]-x0) + (this.miter[1]-y0)*(this.miter[1]-y0);
 456 
 457     if (lenSq &lt; this.miterLimitSq) {
<span class="line-modified"> 458         return emitLineTo(pStroker, this.miter[0], this.miter[1], rev);</span>
 459     }
<span class="line-added"> 460     return ERROR_NONE;</span>
 461 }
 462 
<span class="line-modified"> 463 static jint Stroker_moveTo(PathConsumer *pStroker, jfloat x0, jfloat y0) {</span>
<span class="line-added"> 464     jint status = ERROR_NONE;</span>
 465     if (this.prev == DRAWING_OP_TO) {
<span class="line-modified"> 466         status = finish(pStroker);</span>
<span class="line-added"> 467         if (status != ERROR_NONE) {</span>
<span class="line-added"> 468             return status;</span>
<span class="line-added"> 469         }</span>
 470     }
 471     this.sx0 = this.cx0 = x0;
 472     this.sy0 = this.cy0 = y0;
 473     this.cdx = this.sdx = 1;
 474     this.cdy = this.sdy = 0;
 475     this.prev = MOVE_TO;
<span class="line-added"> 476     return status;</span>
 477 }
 478 
<span class="line-modified"> 479 static jint Stroker_lineTo(PathConsumer *pStroker, jfloat x1, jfloat y1) {</span>
<span class="line-added"> 480     jint status = ERROR_NONE;</span>
 481     jfloat dx = x1 - this.cx0;
 482     jfloat dy = y1 - this.cy0;
 483     jfloat mx, my;
 484 
 485     if (dx == 0.0f &amp;&amp; dy == 0.0f) {
 486         dx = 1;
 487     }
 488     computeOffset(dx, dy, this.lineWidth2, this.offset[0]);
 489     mx = this.offset[0][0];
 490     my = this.offset[0][1];
 491 
<span class="line-modified"> 492     status = drawJoin(pStroker,</span>
 493              this.cdx, this.cdy, this.cx0, this.cy0,
 494              dx, dy, this.cmx, this.cmy, mx, my);
<span class="line-added"> 495     if (status != ERROR_NONE) {</span>
<span class="line-added"> 496         return status;</span>
<span class="line-added"> 497     }</span>
 498 
<span class="line-modified"> 499     status = emitLineTo(pStroker, this.cx0 + mx, this.cy0 + my, JNI_FALSE);</span>
<span class="line-modified"> 500     if (status != ERROR_NONE) {</span>
<span class="line-added"> 501         return status;</span>
<span class="line-added"> 502     }</span>
<span class="line-added"> 503     status = emitLineTo(pStroker, x1 + mx, y1 + my, JNI_FALSE);</span>
<span class="line-added"> 504     if (status != ERROR_NONE) {</span>
<span class="line-added"> 505         return status;</span>
<span class="line-added"> 506     }</span>
 507 
<span class="line-modified"> 508     status = emitLineTo(pStroker, this.cx0 - mx, this.cy0 - my, JNI_TRUE);</span>
<span class="line-modified"> 509     if (status != ERROR_NONE) {</span>
<span class="line-added"> 510         return status;</span>
<span class="line-added"> 511     }</span>
<span class="line-added"> 512     status = emitLineTo(pStroker, x1 - mx, y1 - my, JNI_TRUE);</span>
<span class="line-added"> 513     if (status != ERROR_NONE) {</span>
<span class="line-added"> 514         return status;</span>
<span class="line-added"> 515     }</span>
 516 
 517     this.cmx = mx;
 518     this.cmy = my;
 519     this.cdx = dx;
 520     this.cdy = dy;
 521     this.cx0 = x1;
 522     this.cy0 = y1;
 523     this.prev = DRAWING_OP_TO;
<span class="line-added"> 524     return status;</span>
 525 }
 526 
<span class="line-modified"> 527 static jint Stroker_closePath(PathConsumer *pStroker) {</span>
<span class="line-added"> 528     jint status = ERROR_NONE;</span>
 529     if (this.prev != DRAWING_OP_TO) {
 530         if (this.prev == CLOSE) {
<span class="line-modified"> 531             return status;</span>
<span class="line-added"> 532         }</span>
<span class="line-added"> 533         status = emitMoveTo(pStroker, this.cx0, this.cy0 - this.lineWidth2);</span>
<span class="line-added"> 534         if (status != ERROR_NONE) {</span>
<span class="line-added"> 535             return status;</span>
 536         }

 537         this.cmx = this.smx = 0;
 538         this.cmy = this.smy = -this.lineWidth2;
 539         this.cdx = this.sdx = 1;
 540         this.cdy = this.sdy = 0;
<span class="line-modified"> 541         return finish(pStroker);</span>

 542     }
 543 
 544     if (this.cx0 != this.sx0 || this.cy0 != this.sy0) {
<span class="line-modified"> 545         status = Stroker_lineTo(pStroker, this.sx0, this.sy0);</span>
<span class="line-added"> 546         if (status != ERROR_NONE) {</span>
<span class="line-added"> 547             return status;</span>
<span class="line-added"> 548         }</span>
 549     }
 550 
<span class="line-modified"> 551     status = drawJoin(pStroker,</span>
 552              this.cdx, this.cdy, this.cx0, this.cy0,
 553              this.sdx, this.sdy, this.cmx, this.cmy,
 554              this.smx, this.smy);
<span class="line-added"> 555     if (status != ERROR_NONE) {</span>
<span class="line-added"> 556         return status;</span>
<span class="line-added"> 557     }</span>
 558 
<span class="line-modified"> 559     status = emitLineTo(pStroker, this.sx0 + this.smx, this.sy0 + this.smy, JNI_FALSE);</span>
<span class="line-added"> 560     if (status != ERROR_NONE) {</span>
<span class="line-added"> 561         return status;</span>
<span class="line-added"> 562     }</span>
 563 
<span class="line-modified"> 564     status = emitMoveTo(pStroker, this.sx0 - this.smx, this.sy0 - this.smy);</span>
<span class="line-modified"> 565     if (status != ERROR_NONE) {</span>
<span class="line-added"> 566         return status;</span>
<span class="line-added"> 567     }</span>
<span class="line-added"> 568     status = emitReverse(pStroker);</span>
<span class="line-added"> 569     if (status != ERROR_NONE) {</span>
<span class="line-added"> 570         return status;</span>
<span class="line-added"> 571     }</span>
 572 
 573     this.prev = CLOSE;
<span class="line-modified"> 574     return emitClose(pStroker);</span>
 575 }
 576 
<span class="line-modified"> 577 static jint emitReverse(PathConsumer *pStroker) {</span>
<span class="line-added"> 578     jint status = ERROR_NONE;</span>
 579     while (!PolyStack_isEmpty(&amp;this.reverse)) {
<span class="line-modified"> 580         status = PolyStack_pop(&amp;this.reverse, this.out);</span>
<span class="line-added"> 581         if (status != ERROR_NONE) {</span>
<span class="line-added"> 582             return status;</span>
<span class="line-added"> 583         }</span>
 584     }
<span class="line-added"> 585     return status;</span>
 586 }
 587 
<span class="line-modified"> 588 static jint Stroker_pathDone(PathConsumer *pStroker) {</span>
<span class="line-added"> 589     jint status = ERROR_NONE;</span>
 590     if (this.prev == DRAWING_OP_TO) {
<span class="line-modified"> 591         status = finish(pStroker);</span>
<span class="line-added"> 592         if (status != ERROR_NONE) {</span>
<span class="line-added"> 593             return status;</span>
<span class="line-added"> 594         }</span>
 595     }
 596 
<span class="line-modified"> 597     status = this.out-&gt;pathDone(this.out);</span>
<span class="line-added"> 598     if (status != ERROR_NONE) {</span>
<span class="line-added"> 599         return status;</span>
<span class="line-added"> 600     }</span>
 601     // this shouldn&#39;t matter since this object won&#39;t be used
 602     // after the call to this method.
 603     this.prev = CLOSE;
<span class="line-added"> 604     return status;</span>
 605 }
 606 
<span class="line-modified"> 607 static jint finish(PathConsumer *pStroker) {</span>
<span class="line-added"> 608     jint status = ERROR_NONE;</span>
 609     if (this.capStyle == CAP_ROUND) {
<span class="line-modified"> 610         status = drawRoundCap(pStroker, this.cx0, this.cy0, this.cmx, this.cmy);</span>
<span class="line-added"> 611         if (status != ERROR_NONE) {</span>
<span class="line-added"> 612             return status;</span>
<span class="line-added"> 613         }</span>
 614     } else if (this.capStyle == CAP_SQUARE) {
<span class="line-modified"> 615         status = emitLineTo(pStroker, this.cx0 - this.cmy + this.cmx, this.cy0 + this.cmx + this.cmy, JNI_FALSE);</span>
<span class="line-modified"> 616         if (status != ERROR_NONE) {</span>
<span class="line-added"> 617             return status;</span>
<span class="line-added"> 618         }</span>
<span class="line-added"> 619         status = emitLineTo(pStroker, this.cx0 - this.cmy - this.cmx, this.cy0 + this.cmx - this.cmy, JNI_FALSE);</span>
<span class="line-added"> 620         if (status != ERROR_NONE) {</span>
<span class="line-added"> 621             return status;</span>
<span class="line-added"> 622         }</span>
 623     }
 624 
<span class="line-modified"> 625     status = emitReverse(pStroker);</span>
<span class="line-added"> 626     if (status != ERROR_NONE) {</span>
<span class="line-added"> 627         return status;</span>
<span class="line-added"> 628     }</span>
 629 
 630     if (this.capStyle == CAP_ROUND) {
<span class="line-modified"> 631         status = drawRoundCap(pStroker, this.sx0, this.sy0, -this.smx, -this.smy);</span>
<span class="line-added"> 632         if (status != ERROR_NONE) {</span>
<span class="line-added"> 633             return status;</span>
<span class="line-added"> 634         }</span>
 635     } else if (this.capStyle == CAP_SQUARE) {
<span class="line-modified"> 636         status = emitLineTo(pStroker, this.sx0 + this.smy - this.smx, this.sy0 - this.smx - this.smy, JNI_FALSE);</span>
<span class="line-modified"> 637         if (status != ERROR_NONE) {</span>
<span class="line-added"> 638             return status;</span>
<span class="line-added"> 639         }</span>
<span class="line-added"> 640         status = emitLineTo(pStroker, this.sx0 + this.smy + this.smx, this.sy0 - this.smx + this.smy, JNI_FALSE);</span>
<span class="line-added"> 641         if (status != ERROR_NONE) {</span>
<span class="line-added"> 642             return status;</span>
<span class="line-added"> 643         }</span>
 644     }
 645 
<span class="line-modified"> 646     return emitClose(pStroker);</span>
 647 }
 648 
<span class="line-modified"> 649 static jint emitMoveTo(PathConsumer *pStroker, const jfloat x0, const jfloat y0) {</span>
<span class="line-modified"> 650     return this.out-&gt;moveTo(this.out, x0, y0);</span>
 651 }
 652 
<span class="line-modified"> 653 static jint emitLineTo(PathConsumer *pStroker, const jfloat x1, const jfloat y1,</span>
 654                        const jboolean rev)
 655 {
 656     if (rev) {
<span class="line-modified"> 657         return PolyStack_pushLine(&amp;this.reverse, x1, y1);</span>
 658     } else {
<span class="line-modified"> 659         return this.out-&gt;lineTo(this.out, x1, y1);</span>
 660     }
 661 }
 662 
<span class="line-modified"> 663 static jint emitQuadTo(PathConsumer *pStroker,</span>
 664                        const jfloat x0, const jfloat y0,
 665                        const jfloat x1, const jfloat y1,
 666                        const jfloat x2, const jfloat y2, const jboolean rev)
 667 {
 668     if (rev) {
<span class="line-modified"> 669         return PolyStack_pushQuad(&amp;this.reverse, x0, y0, x1, y1);</span>
 670     } else {
<span class="line-modified"> 671         return this.out-&gt;quadTo(this.out, x1, y1, x2, y2);</span>
 672     }
 673 }
 674 
<span class="line-modified"> 675 static jint emitCurveTo(PathConsumer *pStroker,</span>
 676                         const jfloat x0, const jfloat y0,
 677                         const jfloat x1, const jfloat y1,
 678                         const jfloat x2, const jfloat y2,
 679                         const jfloat x3, const jfloat y3, const jboolean rev)
 680 {
 681     if (rev) {
<span class="line-modified"> 682         return PolyStack_pushCubic(&amp;this.reverse, x0, y0, x1, y1, x2, y2);</span>
 683     } else {
<span class="line-modified"> 684         return this.out-&gt;curveTo(this.out, x1, y1, x2, y2, x3, y3);</span>
 685     }
 686 }
 687 
<span class="line-modified"> 688 static jint emitClose(PathConsumer *pStroker) {</span>
<span class="line-modified"> 689     return this.out-&gt;closePath(this.out);</span>
 690 }
 691 
<span class="line-modified"> 692 static jint drawJoin(PathConsumer *pStroker,</span>
 693                      jfloat pdx, jfloat pdy,
 694                      jfloat x0, jfloat y0,
 695                      jfloat dx, jfloat dy,
 696                      jfloat omx, jfloat omy,
 697                      jfloat mx, jfloat my)
 698 {
<span class="line-added"> 699     jint status = ERROR_NONE;</span>
 700     if (this.prev != DRAWING_OP_TO) {
<span class="line-modified"> 701         status = emitMoveTo(pStroker, x0 + mx, y0 + my);</span>
<span class="line-added"> 702         if (status != ERROR_NONE) {</span>
<span class="line-added"> 703             return status;</span>
<span class="line-added"> 704         }</span>
 705         this.sdx = dx;
 706         this.sdy = dy;
 707         this.smx = mx;
 708         this.smy = my;
 709     } else {
 710         jboolean cw = isCW(pdx, pdy, dx, dy);
 711         if (this.joinStyle == JOIN_MITER) {
<span class="line-modified"> 712             status = drawMiter(pStroker, pdx, pdy, x0, y0, dx, dy, omx, omy, mx, my, cw);</span>
<span class="line-added"> 713             if (status != ERROR_NONE) {</span>
<span class="line-added"> 714                 return status;</span>
<span class="line-added"> 715             }</span>
 716         } else if (this.joinStyle == JOIN_ROUND) {
<span class="line-modified"> 717             status = drawRoundJoin(pStroker,</span>
 718                           x0, y0,
 719                           omx, omy,
 720                           mx, my, cw,
 721                           ROUND_JOIN_THRESHOLD);
<span class="line-added"> 722             if (status != ERROR_NONE) {</span>
<span class="line-added"> 723                 return status;</span>
<span class="line-added"> 724             }</span>
<span class="line-added"> 725         }</span>
<span class="line-added"> 726         status = emitLineTo(pStroker, x0, y0, !cw);</span>
<span class="line-added"> 727         if (status != ERROR_NONE) {</span>
<span class="line-added"> 728             return status;</span>
 729         }

 730     }
 731     this.prev = DRAWING_OP_TO;
<span class="line-added"> 732     return status;</span>
 733 }
 734 
 735 static jboolean withinULP(const jfloat x1, const jfloat y1,
 736                           const jfloat x2, const jfloat y2,
 737                           const int maxUlps)
 738 {
 739 //    assert maxUlps is much smaller than 0x7fffffff;
 740     // compare taxicab distance. ERR will always be small, so using
 741     // true distance won&#39;t give much benefit
 742     return (Helpers_withinULP(x1, x2, maxUlps) &amp;&amp;
 743             Helpers_withinULP(y1, y2, maxUlps));
 744 }
 745 
 746 static void getLineOffsets(PathConsumer *pStroker,
 747                            jfloat x1, jfloat y1,
 748                            jfloat x2, jfloat y2,
 749                            jfloat left[], jfloat right[]) {
 750     computeOffset(x2 - x1, y2 - y1, this.lineWidth2, this.offset[0]);
 751     left[0] = x1 + this.offset[0][0];
 752     left[1] = y1 + this.offset[0][1];
</pre>
<hr />
<pre>
1150 
1151     // we subdivide at values of t such that the remaining rotated
1152     // curves are monotonic in x and y.
1153     ret += Curve_dxRoots(&amp;this.c, ts, ret);
1154     ret += Curve_dyRoots(&amp;this.c, ts, ret);
1155     // subdivide at inflection points.
1156     if (type == 8) {
1157         // quadratic curves can&#39;t have inflection points
1158         ret += Curve_infPoints(&amp;this.c, ts, ret);
1159     }
1160 
1161     // now we must subdivide at points where one of the offset curves will have
1162     // a cusp. This happens at ts where the radius of curvature is equal to w.
1163     ret += Curve_rootsOfROCMinusW(&amp;this.c, ts, ret, w, 0.0001f);
1164 
1165     ret = Helpers_filterOutNotInAB(ts, 0, ret, 0.0001f, 0.9999f);
1166     Helpers_isort(ts, 0, ret);
1167     return ret;
1168 }
1169 
<span class="line-modified">1170 static jint Stroker_curveTo(PathConsumer *pStroker,</span>
1171                            jfloat x1, jfloat y1,
1172                            jfloat x2, jfloat y2,
1173                            jfloat x3, jfloat y3)
1174 {
<span class="line-added">1175     jint status = ERROR_NONE;</span>
1176     jfloat xf, yf, dxs, dys, dxf, dyf;
1177     jfloat mx, my;
1178     jint nSplits;
1179     jfloat prevT;
1180     jint i, kind;
1181     jboolean p1eqp2, p3eqp4;
1182 
1183     middle[0] = this.cx0; middle[1] = this.cy0;
1184     middle[2] = x1;  middle[3] = y1;
1185     middle[4] = x2;  middle[5] = y2;
1186     middle[6] = x3;  middle[7] = y3;
1187 
1188     // inlined version of somethingTo(8);
1189     // See the NOTE on somethingTo
1190 
1191     // need these so we can update the state at the end of this method
1192     xf = middle[6], yf = middle[7];
1193     dxs = middle[2] - middle[0];
1194     dys = middle[3] - middle[1];
1195     dxf = middle[6] - middle[4];
</pre>
<hr />
<pre>
1198     p1eqp2 = (dxs == 0.0f &amp;&amp; dys == 0.0f);
1199     p3eqp4 = (dxf == 0.0f &amp;&amp; dyf == 0.0f);
1200     if (p1eqp2) {
1201         dxs = middle[4] - middle[0];
1202         dys = middle[5] - middle[1];
1203         if (dxs == 0.0f &amp;&amp; dys == 0.0f) {
1204             dxs = middle[6] - middle[0];
1205             dys = middle[7] - middle[1];
1206         }
1207     }
1208     if (p3eqp4) {
1209         dxf = middle[6] - middle[2];
1210         dyf = middle[7] - middle[3];
1211         if (dxf == 0.0f &amp;&amp; dyf == 0.0f) {
1212             dxf = middle[6] - middle[0];
1213             dyf = middle[7] - middle[1];
1214         }
1215     }
1216     if (dxs == 0.0f &amp;&amp; dys == 0.0f) {
1217         // this happens iff the &quot;curve&quot; is just a point
<span class="line-modified">1218         return Stroker_lineTo(pStroker, middle[0], middle[1]);</span>

1219     }
1220 
1221     // if these vectors are too small, normalize them, to avoid future
1222     // precision problems.
1223     if (fabs(dxs) &lt; 0.1f &amp;&amp; fabs(dys) &lt; 0.1f) {
1224         jfloat len = (jfloat) sqrt(dxs*dxs + dys*dys);
1225         dxs /= len;
1226         dys /= len;
1227     }
1228     if (fabs(dxf) &lt; 0.1f &amp;&amp; fabs(dyf) &lt; 0.1f) {
1229         jfloat len = (jfloat) sqrt(dxf*dxf + dyf*dyf);
1230         dxf /= len;
1231         dyf /= len;
1232     }
1233 
1234     computeOffset(dxs, dys, this.lineWidth2, this.offset[0]);
1235     mx = this.offset[0][0];
1236     my = this.offset[0][1];
<span class="line-modified">1237     status = drawJoin(pStroker,</span>
1238              this.cdx, this.cdy, this.cx0, this.cy0,
1239              dxs, dys, this.cmx, this.cmy,
1240              mx, my);
<span class="line-added">1241     if (status != ERROR_NONE) {</span>
<span class="line-added">1242         return status;</span>
<span class="line-added">1243     }</span>
1244 
1245     nSplits = findSubdivPoints(pStroker, middle, subdivTs, 8, this.lineWidth2);
1246     prevT = 0.0f;
1247     for (i = 0; i &lt; nSplits; i++) {
1248         jfloat t = subdivTs[i];
1249         Helpers_subdivideCubicAt((t - prevT) / (1 - prevT),
1250                                  middle, i*6,
1251                                  middle, i*6,
1252                                  middle, i*6+6);
1253         prevT = t;
1254     }
1255 
1256     kind = 0;
1257     for (i = 0; i &lt;= nSplits; i++) {
1258         kind = computeOffsetCubic(pStroker, middle, i*6, lp, rp);
1259         if (kind != 0) {
<span class="line-modified">1260             status = emitLineTo(pStroker, lp[0], lp[1], JNI_FALSE);</span>
<span class="line-added">1261             if (status != ERROR_NONE) {</span>
<span class="line-added">1262                 return status;</span>
<span class="line-added">1263             }</span>
1264             switch(kind) {
1265             case 8:
<span class="line-modified">1266                 status = emitCurveTo(pStroker, lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], lp[6], lp[7], JNI_FALSE);</span>
<span class="line-modified">1267                 if (status != ERROR_NONE) {</span>
<span class="line-added">1268                     return status;</span>
<span class="line-added">1269                 }</span>
<span class="line-added">1270                 status = emitCurveTo(pStroker, rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], rp[6], rp[7], JNI_TRUE);</span>
<span class="line-added">1271                 if (status != ERROR_NONE) {</span>
<span class="line-added">1272                     return status;</span>
<span class="line-added">1273                 }</span>
1274                 break;
1275             case 4:
<span class="line-modified">1276                 status = emitLineTo(pStroker, lp[2], lp[3], JNI_FALSE);</span>
<span class="line-modified">1277                 if (status != ERROR_NONE) {</span>
<span class="line-added">1278                     return status;</span>
<span class="line-added">1279                 }</span>
<span class="line-added">1280                 status = emitLineTo(pStroker, rp[0], rp[1], JNI_TRUE);</span>
<span class="line-added">1281                 if (status != ERROR_NONE) {</span>
<span class="line-added">1282                     return status;</span>
<span class="line-added">1283                 }</span>
1284                 break;
1285             }
<span class="line-modified">1286             status = emitLineTo(pStroker, rp[kind - 2], rp[kind - 1], JNI_TRUE);</span>
<span class="line-added">1287             if (status != ERROR_NONE) {</span>
<span class="line-added">1288                 return status;</span>
<span class="line-added">1289             }</span>
1290         }
1291     }
1292 
1293     this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;
1294     this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;
1295     this.cdx = dxf;
1296     this.cdy = dyf;
1297     this.cx0 = xf;
1298     this.cy0 = yf;
1299     this.prev = DRAWING_OP_TO;
<span class="line-added">1300     return status;</span>
1301 }
1302 
<span class="line-modified">1303 static jint Stroker_quadTo(PathConsumer *pStroker,</span>
1304                           jfloat x1, jfloat y1,
1305                           jfloat x2, jfloat y2)
1306 {
<span class="line-added">1307     jint status = ERROR_NONE;</span>
1308     jfloat xf, yf, dxs, dys, dxf, dyf;
1309     jfloat mx, my;
1310     jint nSplits, i, kind;
1311     jfloat prevt;
1312 
1313     middle[0] = this.cx0; middle[1] = this.cy0;
1314     middle[2] = x1;  middle[3] = y1;
1315     middle[4] = x2;  middle[5] = y2;
1316 
1317     // inlined version of somethingTo(8);
1318     // See the NOTE on somethingTo
1319 
1320     // need these so we can update the state at the end of this method
1321     xf = middle[4], yf = middle[5];
1322     dxs = middle[2] - middle[0];
1323     dys = middle[3] - middle[1];
1324     dxf = middle[4] - middle[2];
1325     dyf = middle[5] - middle[3];
1326     if ((dxs == 0.0f &amp;&amp; dys == 0.0f) || (dxf == 0.0f &amp;&amp; dyf == 0.0f)) {
1327         dxs = dxf = middle[4] - middle[0];
1328         dys = dyf = middle[5] - middle[1];
1329     }
1330     if (dxs == 0.0f &amp;&amp; dys == 0.0f) {
1331         // this happens iff the &quot;curve&quot; is just a point
<span class="line-modified">1332         return Stroker_lineTo(pStroker, middle[0], middle[1]);</span>

1333     }
1334     // if these vectors are too small, normalize them, to avoid future
1335     // precision problems.
1336     if (fabs(dxs) &lt; 0.1f &amp;&amp; fabs(dys) &lt; 0.1f) {
1337         jfloat len = (jfloat) sqrt(dxs*dxs + dys*dys);
1338         dxs /= len;
1339         dys /= len;
1340     }
1341     if (fabs(dxf) &lt; 0.1f &amp;&amp; fabs(dyf) &lt; 0.1f) {
1342         jfloat len = (jfloat) sqrt(dxf*dxf + dyf*dyf);
1343         dxf /= len;
1344         dyf /= len;
1345     }
1346 
1347     computeOffset(dxs, dys, this.lineWidth2, this.offset[0]);
1348     mx = this.offset[0][0];
1349     my = this.offset[0][1];
<span class="line-modified">1350     status = drawJoin(pStroker,</span>
1351              this.cdx, this.cdy, this.cx0, this.cy0,
1352              dxs, dys, this.cmx, this.cmy,
1353              mx, my);
<span class="line-added">1354     if (status != ERROR_NONE) {</span>
<span class="line-added">1355         return status;</span>
<span class="line-added">1356     }</span>
1357 
1358     nSplits = findSubdivPoints(pStroker, middle, subdivTs, 6, this.lineWidth2);
1359     prevt = 0.0f;
1360     for (i = 0; i &lt; nSplits; i++) {
1361         jfloat t = subdivTs[i];
1362         Helpers_subdivideQuadAt((t - prevt) / (1 - prevt),
1363                                 middle, i*4,
1364                                 middle, i*4,
1365                                 middle, i*4+4);
1366         prevt = t;
1367     }
1368 
1369     kind = 0;
1370     for (i = 0; i &lt;= nSplits; i++) {
1371         kind = computeOffsetQuad(pStroker, middle, i*4, lp, rp);
1372         if (kind != 0) {
<span class="line-modified">1373             status = emitLineTo(pStroker, lp[0], lp[1], JNI_FALSE);</span>
<span class="line-added">1374             if (status != ERROR_NONE) {</span>
<span class="line-added">1375                 return status;</span>
<span class="line-added">1376             }</span>
1377             switch(kind) {
1378             case 6:
<span class="line-modified">1379                 status = emitQuadTo(pStroker, lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], JNI_FALSE);</span>
<span class="line-modified">1380                 if (status != ERROR_NONE) {</span>
<span class="line-added">1381                     return status;</span>
<span class="line-added">1382                 }</span>
<span class="line-added">1383                 status = emitQuadTo(pStroker, rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], JNI_TRUE);</span>
<span class="line-added">1384                 if (status != ERROR_NONE) {</span>
<span class="line-added">1385                     return status;</span>
<span class="line-added">1386                 }</span>
1387                 break;
1388             case 4:
<span class="line-modified">1389                 status = emitLineTo(pStroker, lp[2], lp[3], JNI_FALSE);</span>
<span class="line-modified">1390                 if (status != ERROR_NONE) {</span>
<span class="line-added">1391                     return status;</span>
<span class="line-added">1392                 }</span>
<span class="line-added">1393                 status = emitLineTo(pStroker, rp[0], rp[1], JNI_TRUE);</span>
<span class="line-added">1394                 if (status != ERROR_NONE) {</span>
<span class="line-added">1395                     return status;</span>
<span class="line-added">1396                 }</span>
1397                 break;
1398             }
<span class="line-modified">1399             status = emitLineTo(pStroker, rp[kind - 2], rp[kind - 1], JNI_TRUE);</span>
<span class="line-added">1400             if (status != ERROR_NONE) {</span>
<span class="line-added">1401                 return status;</span>
<span class="line-added">1402             }</span>
1403         }
1404     }
1405 
1406     this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;
1407     this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;
1408     this.cdx = dxf;
1409     this.cdy = dyf;
1410     this.cx0 = xf;
1411     this.cy0 = yf;
1412     this.prev = DRAWING_OP_TO;
<span class="line-added">1413     return status;</span>
1414 }
1415 
1416 // a stack of polynomial curves where each curve shares endpoints with
1417 // adjacent ones.
1418 /*
1419     private static const class PolyStack {
1420         jfloat[] curves;
1421         int end;
1422         int[] curveTypes;
1423         int numCurves;
1424  */
1425 
1426 #define INIT_SIZE   50
1427 
1428 #undef this
1429 #define this (*((PolyStack *)pStack))
1430 
1431 void PolyStack_init(PolyStack *pStack) {
1432     this.curves = new_float(8 * INIT_SIZE);
1433     this.curvesSIZE = 8 * INIT_SIZE;
1434     this.curveTypes = new_int(INIT_SIZE);
1435     this.curveTypesSIZE = INIT_SIZE;
1436     this.end = 0;
1437     this.numCurves = 0;
1438 }
1439 
1440 void PolyStack_destroy(PolyStack *pStack) {
1441     free(this.curves);
1442     this.curves = NULL;
1443     this.curvesSIZE = 0;
1444     free(this.curveTypes);
1445     this.curveTypes = NULL;
1446     this.curveTypesSIZE = 0;
1447 }
1448 
1449 jboolean PolyStack_isEmpty(PolyStack *pStack) {
1450     return this.numCurves == 0;
1451 }
1452 
<span class="line-modified">1453 static jint ensureSpace(PolyStack *pStack, jint n) {</span>
1454     if (this.end + n &gt;= this.curvesSIZE) {
1455         jint newSize = (this.end + n) * 2;
1456         jfloat *newCurves = new_float(newSize);
<span class="line-added">1457         if (!newCurves) {</span>
<span class="line-added">1458             return ERROR_OOM;</span>
<span class="line-added">1459         }</span>
1460         System_arraycopy(this.curves, 0, newCurves, 0, this.end);
1461         free(this.curves);
1462         this.curves = newCurves;
1463         this.curvesSIZE = newSize;
1464     }
1465     if (this.numCurves &gt;= this.curveTypesSIZE) {
1466         jint newSize = this.numCurves * 2;
1467         jint *newTypes = new_int(newSize);
<span class="line-added">1468         if (!newTypes) {</span>
<span class="line-added">1469             return ERROR_OOM;</span>
<span class="line-added">1470         }</span>
1471         System_arraycopy(this.curveTypes, 0, newTypes, 0, this.numCurves);
1472         free(this.curveTypes);
1473         this.curveTypes = newTypes;
1474         this.curveTypesSIZE = newSize;
1475     }
<span class="line-added">1476     return ERROR_NONE;</span>
1477 }
1478 
<span class="line-modified">1479 jint PolyStack_pushCubic(PolyStack *pStack,</span>
1480                          jfloat x0, jfloat y0,
1481                          jfloat x1, jfloat y1,
1482                          jfloat x2, jfloat y2)
1483 {
<span class="line-modified">1484     jint status = ensureSpace(pStack, 6);</span>
<span class="line-added">1485     if (status != ERROR_NONE) {</span>
<span class="line-added">1486         return status;</span>
<span class="line-added">1487     }</span>
1488     this.curveTypes[this.numCurves++] = 8;
1489     // assert(x0 == lastX &amp;&amp; y0 == lastY)
1490 
1491     // we reverse the coordinate order to make popping easier
1492     this.curves[this.end++] = x2;    this.curves[this.end++] = y2;
1493     this.curves[this.end++] = x1;    this.curves[this.end++] = y1;
1494     this.curves[this.end++] = x0;    this.curves[this.end++] = y0;
<span class="line-added">1495     return status;</span>
1496 }
1497 
<span class="line-modified">1498 jint PolyStack_pushQuad(PolyStack *pStack,</span>
1499                         jfloat x0, jfloat y0,
1500                         jfloat x1, jfloat y1)
1501 {
<span class="line-modified">1502     jint status = ensureSpace(pStack, 4);</span>
<span class="line-added">1503     if (status != ERROR_NONE) {</span>
<span class="line-added">1504         return status;</span>
<span class="line-added">1505     }</span>
1506     this.curveTypes[this.numCurves++] = 6;
1507     // assert(x0 == lastX &amp;&amp; y0 == lastY)
1508     this.curves[this.end++] = x1;    this.curves[this.end++] = y1;
1509     this.curves[this.end++] = x0;    this.curves[this.end++] = y0;
<span class="line-added">1510     return status;</span>
1511 }
1512 
<span class="line-modified">1513 jint PolyStack_pushLine(PolyStack *pStack,</span>
1514                         jfloat x, jfloat y)
1515 {
<span class="line-modified">1516     jint status = ensureSpace(pStack, 2);</span>
<span class="line-added">1517     if (status != ERROR_NONE) {</span>
<span class="line-added">1518         return status;</span>
<span class="line-added">1519     }</span>
1520     this.curveTypes[this.numCurves++] = 4;
1521     // assert(x0 == lastX &amp;&amp; y0 == lastY)
1522     this.curves[this.end++] = x;    this.curves[this.end++] = y;
<span class="line-added">1523     return status;</span>
1524 }
1525 
1526 //@SuppressWarnings(&quot;unused&quot;)
1527 /*
1528 jint PolyStack_pop(PolyStack *pStack, jfloat pts[]) {
1529     jint ret = this.curveTypes[this.numCurves - 1];
1530     this.numCurves--;
1531     this.end -= (ret - 2);
1532     System_arraycopy(curves, end, pts, 0, ret - 2);
1533     return ret;
1534 }
1535 */
1536 
<span class="line-modified">1537 jint PolyStack_pop(PolyStack *pStack, PathConsumer *io) {</span>
<span class="line-added">1538     jint status = ERROR_NONE;</span>
1539     jint type;
1540 
1541     this.numCurves--;
1542     type = this.curveTypes[this.numCurves];
1543     this.end -= (type - 2);
1544     switch(type) {
1545     case 8:
<span class="line-modified">1546         status = io-&gt;curveTo(io,</span>
1547                     this.curves[this.end+0], this.curves[this.end+1],
1548                     this.curves[this.end+2], this.curves[this.end+3],
1549                     this.curves[this.end+4], this.curves[this.end+5]);
1550         break;
1551     case 6:
<span class="line-modified">1552         status = io-&gt;quadTo(io,</span>
1553                    this.curves[this.end+0], this.curves[this.end+1],
1554                    this.curves[this.end+2], this.curves[this.end+3]);
<span class="line-modified">1555         break;</span>
1556     case 4:
<span class="line-modified">1557         status = io-&gt;lineTo(io, this.curves[this.end], this.curves[this.end+1]);</span>
1558     }
<span class="line-added">1559     return status;</span>
1560 }
1561 
1562 //@Override
1563 /*
1564 public String toString() {
1565     String ret = &quot;&quot;;
1566     jint nc = numCurves;
1567     jint last = this.end;
1568     while (nc &gt; 0) {
1569         nc--;
1570         jint type = curveTypes[numCurves];
1571         last -= (type - 2);
1572         switch(type) {
1573         case 8:
1574             ret += &quot;cubic: &quot;;
1575             break;
1576         case 6:
1577             ret += &quot;quad: &quot;;
1578             break;
1579         case 4:
</pre>
</td>
</tr>
</table>
<center><a href="Renderer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="Transformer.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
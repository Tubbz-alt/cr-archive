<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.graphics/src/main/native-prism/Stroker.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &lt;stdlib.h&gt;
  27 #include &lt;string.h&gt;
  28 #include &lt;math.h&gt;
  29 #include &lt;jni.h&gt;
  30 
  31 #include &quot;Helpers.h&quot;
  32 #include &quot;PathConsumer.h&quot;
  33 
  34 #include &quot;Stroker.h&quot;
  35 
  36 // NOTE: some of the arithmetic here is too verbose and prone to hard to
  37 // debug typos. We should consider making a small Point/Vector class that
  38 // has methods like plus(Point), minus(Point), dot(Point), cross(Point)and such
  39 //public final class Stroker implements PathConsumer2D {
  40 
  41 #define MOVE_TO  0
  42 #define DRAWING_OP_TO  1 // ie. curve, line, or quad
  43 #define CLOSE  2
  44 
  45 static MoveToFunc       Stroker_moveTo;
  46 static LineToFunc       Stroker_lineTo;
  47 static QuadToFunc       Stroker_quadTo;
  48 static CurveToFunc      Stroker_curveTo;
  49 static ClosePathFunc    Stroker_closePath;
  50 static PathDoneFunc     Stroker_pathDone;
  51 
  52 #define this (*((Stroker *) pStroker))
  53 
  54 static jint drawJoin(PathConsumer *pStroker,
  55                      jfloat pdx, jfloat pdy,
  56                      jfloat x0, jfloat y0,
  57                      jfloat dx, jfloat dy,
  58                      jfloat omx, jfloat omy,
  59                      jfloat mx, jfloat my);
  60 
  61 static jint drawRoundJoin2(PathConsumer *pStroker,
  62                            jfloat cx, jfloat cy,
  63                            jfloat omx, jfloat omy,
  64                            jfloat mx, jfloat my,
  65                            jboolean rev);
  66 
  67 static jint drawBezApproxForArc(PathConsumer *pStroker,
  68                                 const jfloat cx, const jfloat cy,
  69                                 const jfloat omx, const jfloat omy,
  70                                 const jfloat mx, const jfloat my,
  71                                 jboolean rev);
  72 
  73 static jint emitMoveTo(PathConsumer *pStroker, const jfloat x0, const jfloat y0);
  74 
  75 static jint emitLineTo(PathConsumer *pStroker, const jfloat x1, const jfloat y1,
  76                        const jboolean rev);
  77 
  78 static jint emitCurveTo(PathConsumer *pStroker,
  79                         const jfloat x0, const jfloat y0,
  80                         const jfloat x1, const jfloat y1,
  81                         const jfloat x2, const jfloat y2,
  82                         const jfloat x3, const jfloat y3, const jboolean rev);
  83 
  84 static jint emitClose(PathConsumer *pStroker);
  85 
  86 static jint emitReverse(PathConsumer *pStroker);
  87 
  88 static jint finish(PathConsumer *pStroker);
  89 
  90 extern void PolyStack_init(PolyStack *pStack);
  91 
  92 extern void PolyStack_destroy(PolyStack *pStack);
  93 
  94 extern jboolean PolyStack_isEmpty(PolyStack *pStack);
  95 
  96 extern jint PolyStack_pushLine(PolyStack *pStack,
  97                                jfloat x, jfloat y);
  98 
  99 extern jint PolyStack_pushCubic(PolyStack *pStack,
 100                                 jfloat x0, jfloat y0,
 101                                 jfloat x1, jfloat y1,
 102                                 jfloat x2, jfloat y2);
 103 
 104 extern jint PolyStack_pushQuad(PolyStack *pStack,
 105                                jfloat x0, jfloat y0,
 106                                jfloat x1, jfloat y1);
 107 
 108 extern jint PolyStack_pop(PolyStack *pStack, PathConsumer *io);
 109 
 110     /**
 111      * Constructs a &lt;code&gt;Stroker&lt;/code&gt;.
 112      *
 113      * @param pc2d an output &lt;code&gt;PathConsumer2D&lt;/code&gt;.
 114      * @param lineWidth the desired line width in pixels
 115      * @param capStyle the desired end cap style, one of
 116      * &lt;code&gt;CAP_BUTT&lt;/code&gt;, &lt;code&gt;CAP_ROUND&lt;/code&gt; or
 117      * &lt;code&gt;CAP_SQUARE&lt;/code&gt;.
 118      * @param joinStyle the desired line join style, one of
 119      * &lt;code&gt;JOIN_MITER&lt;/code&gt;, &lt;code&gt;JOIN_ROUND&lt;/code&gt; or
 120      * &lt;code&gt;JOIN_BEVEL&lt;/code&gt;.
 121      * @param miterLimit the desired miter limit
 122     public Stroker(PathConsumer2D pc2d,
 123                    float lineWidth,
 124                    jint capStyle,
 125                    jint joinStyle,
 126                    float miterLimit)
 127     {
 128         this(pc2d);
 129 
 130         reset(lineWidth, capStyle, joinStyle, miterLimit);
 131     }
 132 
 133     public Stroker(PathConsumer2D pc2d) {
 134         setConsumer(pc2d);
 135     }
 136 
 137     public void setConsumer(PathConsumer2D pc2d) {
 138         this.out = pc2d;
 139     }
 140      */
 141 
 142 extern void Stroker_reset(Stroker *pStroker, jfloat lineWidth,
 143                           jint capStyle, jint joinStyle, jfloat miterLimit);
 144 
 145 void Stroker_init(Stroker *pStroker,
 146                   PathConsumer *out,
 147                   jfloat lineWidth,
 148                   jint capStyle,
 149                   jint joinStyle,
 150                   jfloat miterLimit)
 151 {
 152     memset(pStroker, 0, sizeof(Stroker));
 153     PathConsumer_init(&amp;this.consumer,
 154                       Stroker_moveTo,
 155                       Stroker_lineTo,
 156                       Stroker_quadTo,
 157                       Stroker_curveTo,
 158                       Stroker_closePath,
 159                       Stroker_pathDone);
 160 
 161     this.out = out;
 162     Stroker_reset(pStroker, lineWidth, capStyle, joinStyle, miterLimit);
 163     PolyStack_init(&amp;pStroker-&gt;reverse);
 164 }
 165 
 166 void Stroker_reset(Stroker *pStroker, jfloat lineWidth,
 167                    jint capStyle, jint joinStyle, jfloat miterLimit)
 168 {
 169     jfloat limit;
 170 
 171     this.lineWidth2 = lineWidth / 2;
 172     this.capStyle = capStyle;
 173     this.joinStyle = joinStyle;
 174 
 175     limit = miterLimit * this.lineWidth2;
 176     this.miterLimitSq = limit*limit;
 177 
 178     this.prev = CLOSE;
 179 }
 180 
 181 void Stroker_destroy(Stroker *pStroker) {
 182     PolyStack_destroy(&amp;pStroker-&gt;reverse);
 183 }
 184 
 185 void computeOffset(const jfloat lx, const jfloat ly,
 186                    const jfloat w, jfloat m[])
 187 {
 188     const jfloat len = (jfloat) sqrt(lx*lx + ly*ly);
 189     if (len == 0) {
 190         m[0] = m[1] = 0;
 191     } else {
 192         m[0] = (ly * w)/len;
 193         m[1] = -(lx * w)/len;
 194     }
 195 }
 196 
 197 // Returns true if the vectors (dx1, dy1) and (dx2, dy2) are
 198 // clockwise (if dx1,dy1 needs to be rotated clockwise to close
 199 // the smallest angle between it and dx2,dy2).
 200 // This is equivalent to detecting whether a point q is on the right side
 201 // of a line passing through points p1, p2 where p2 = p1+(dx1,dy1) and
 202 // q = p2+(dx2,dy2), which is the same as saying p1, p2, q are in a
 203 // clockwise order.
 204 // NOTE: &quot;clockwise&quot; here assumes coordinates with 0,0 at the bottom left.
 205 static jboolean isCW(const jfloat dx1, const jfloat dy1,
 206                      const jfloat dx2, const jfloat dy2)
 207 {
 208     return dx1 * dy2 &lt;= dy1 * dx2;
 209 }
 210 
 211 // pisces used to use fixed point arithmetic with 16 decimal digits. I
 212 // didn&#39;t want to change the values of the constant below when I converted
 213 // it to floating point, so that&#39;s why the divisions by 2^16 are there.
 214 #define ROUND_JOIN_THRESHOLD   (1000/65536.0f)
 215 
 216 static jint drawRoundJoin(PathConsumer *pStroker,
 217                           jfloat x, jfloat y,
 218                           jfloat omx, jfloat omy, jfloat mx, jfloat my,
 219                           jboolean rev,
 220                           jfloat threshold)
 221 {
 222     jfloat domx, domy, len;
 223 
 224     if ((omx == 0 &amp;&amp; omy == 0) || (mx == 0 &amp;&amp; my == 0)) {
 225         return ERROR_NONE;
 226     }
 227 
 228     domx = omx - mx;
 229     domy = omy - my;
 230     len = domx*domx + domy*domy;
 231     if (len &lt; threshold) {
 232         return ERROR_NONE;
 233     }
 234 
 235     if (rev) {
 236         omx = -omx;
 237         omy = -omy;
 238         mx = -mx;
 239         my = -my;
 240     }
 241     return drawRoundJoin2(pStroker, x, y, omx, omy, mx, my, rev);
 242 }
 243 
 244 static jint drawRoundJoin2(PathConsumer *pStroker,
 245                            jfloat cx, jfloat cy,
 246                            jfloat omx, jfloat omy,
 247                            jfloat mx, jfloat my,
 248                            jboolean rev)
 249 {
 250     jint status = ERROR_NONE;
 251 
 252     // The sign of the dot product of mx,my and omx,omy is equal to the
 253     // the sign of the cosine of ext
 254     // (ext is the angle between omx,omy and mx,my).
 255     jdouble cosext = omx * mx + omy * my;
 256     // If it is &gt;=0, we know that abs(ext) is &lt;= 90 degrees, so we only
 257     // need 1 curve to approximate the circle section that joins omx,omy
 258     // and mx,my.
 259     const jint numCurves = cosext &gt;= 0 ? 1 : 2;
 260 
 261     switch (numCurves) {
 262     case 1:
 263         status = drawBezApproxForArc(pStroker, cx, cy, omx, omy, mx, my, rev);
 264         break;
 265     case 2:
 266         {
 267             // we need to split the arc into 2 arcs spanning the same angle.
 268             // The point we want will be one of the 2 intersections of the
 269             // perpendicular bisector of the chord (omx,omy)-&gt;(mx,my) and the
 270             // circle. We could find this by scaling the vector
 271             // (omx+mx, omy+my)/2 so that it has length=lineWidth2 (and thus lies
 272             // on the circle), but that can have numerical problems when the angle
 273             // between omx,omy and mx,my is close to 180 degrees. So we compute a
 274             // normal of (omx,omy)-(mx,my). This will be the direction of the
 275             // perpendicular bisector. To get one of the intersections, we just scale
 276             // this vector that its length is lineWidth2 (this works because the
 277             // perpendicular bisector goes through the origin). This scaling doesn&#39;t
 278             // have numerical problems because we know that lineWidth2 divided by
 279             // this normal&#39;s length is at least 0.5 and at most sqrt(2)/2 (because
 280             // we know the angle of the arc is &gt; 90 degrees).
 281             jfloat nx = my - omy, ny = omx - mx;
 282             jfloat nlen = (jfloat) sqrt(nx*nx + ny*ny);
 283             jfloat scale = this.lineWidth2/nlen;
 284             jfloat mmx = nx * scale, mmy = ny * scale;
 285 
 286             // if (isCW(omx, omy, mx, my) != isCW(mmx, mmy, mx, my)) then we&#39;ve
 287             // computed the wrong intersection so we get the other one.
 288             // The test above is equivalent to if (rev).
 289             if (rev) {
 290                 mmx = -mmx;
 291                 mmy = -mmy;
 292             }
 293             status = drawBezApproxForArc(pStroker, cx, cy, omx, omy, mmx, mmy, rev);
 294             if (status != ERROR_NONE) {
 295                 return status;
 296             }
 297             status = drawBezApproxForArc(pStroker, cx, cy, mmx, mmy, mx, my, rev);
 298             break;
 299         }
 300     }
 301     return status;
 302 }
 303 
 304 // the input arc defined by omx,omy and mx,my must span &lt;= 90 degrees.
 305 static jint drawBezApproxForArc(PathConsumer *pStroker,
 306                                 const jfloat cx, const jfloat cy,
 307                                 const jfloat omx, const jfloat omy,
 308                                 const jfloat mx, const jfloat my,
 309                                 jboolean rev)
 310 {
 311     jfloat cosext2 = (omx * mx + omy * my) / (2 * this.lineWidth2 * this.lineWidth2);
 312     // cv is the length of P1-P0 and P2-P3 divided by the radius of the arc
 313     // (so, cv assumes the arc has radius 1). P0, P1, P2, P3 are the points that
 314     // define the bezier curve we&#39;re computing.
 315     // It is computed using the constraints that P1-P0 and P3-P2 are parallel
 316     // to the arc tangents at the endpoints, and that |P1-P0|=|P3-P2|.
 317     jfloat cv = (jfloat) ((4.0 / 3.0) * sqrt(0.5-cosext2) /
 318                           (1.0 + sqrt(cosext2+0.5)));
 319     jfloat x1, y1, x2, y2, x3, y3, x4, y4;
 320 
 321     // if clockwise, we need to negate cv.
 322     if (rev) { // rev is equivalent to isCW(omx, omy, mx, my)
 323         cv = -cv;
 324     }
 325     x1 = cx + omx;
 326     y1 = cy + omy;
 327     x2 = x1 - cv * omy;
 328     y2 = y1 + cv * omx;
 329 
 330     x4 = cx + mx;
 331     y4 = cy + my;
 332     x3 = x4 + cv * my;
 333     y3 = y4 - cv * mx;
 334 
 335     return emitCurveTo(pStroker, x1, y1, x2, y2, x3, y3, x4, y4, rev);
 336 }
 337 
 338 static jint drawRoundCap(PathConsumer *pStroker, jfloat cx, jfloat cy, jfloat mx, jfloat my) {
 339     jint status = ERROR_NONE;
 340     const jfloat C = 0.5522847498307933f;
 341     // the first and second arguments of the following two calls
 342     // are really will be ignored by emitCurveTo (because of the false),
 343     // but we put them in anyway, as opposed to just giving it 4 zeroes,
 344     // because it&#39;s just 4 additions and it&#39;s not good to rely on this
 345     // sort of assumption (right now it&#39;s true, but that may change).
 346     status = emitCurveTo(pStroker,
 347                 cx+mx,      cy+my,
 348                 cx+mx-C*my, cy+my+C*mx,
 349                 cx-my+C*mx, cy+mx+C*my,
 350                 cx-my,      cy+mx,
 351                 JNI_FALSE);
 352     if (status != ERROR_NONE) {
 353         return status;
 354     }
 355     status = emitCurveTo(pStroker,
 356                 cx-my,      cy+mx,
 357                 cx-my-C*mx, cy+mx-C*my,
 358                 cx-mx-C*my, cy-my+C*mx,
 359                 cx-mx,      cy-my,
 360                 JNI_FALSE);
 361     return status;
 362 }
 363 
 364 // Return the intersection point of the lines (x0, y0) -&gt; (x1, y1)
 365 // and (x0p, y0p) -&gt; (x1p, y1p) in m[0] and m[1]
 366 static void computeMiter(const jfloat x0, const jfloat y0,
 367                          const jfloat x1, const jfloat y1,
 368                          const jfloat x0p, const jfloat y0p,
 369                          const jfloat x1p, const jfloat y1p,
 370                          jfloat m[], jint off)
 371 {
 372     jfloat x10 = x1 - x0;
 373     jfloat y10 = y1 - y0;
 374     jfloat x10p = x1p - x0p;
 375     jfloat y10p = y1p - y0p;
 376 
 377     // if this is 0, the lines are parallel. If they go in the
 378     // same direction, there is no intersection so m[off] and
 379     // m[off+1] will contain infinity, so no miter will be drawn.
 380     // If they go in the same direction that means that the start of the
 381     // current segment and the end of the previous segment have the same
 382     // tangent, in which case this method won&#39;t even be involved in
 383     // miter drawing because it won&#39;t be called by drawMiter (because
 384     // (mx == omx &amp;&amp; my == omy) will be true, and drawMiter will return
 385     // immediately).
 386     jfloat den = x10*y10p - x10p*y10;
 387     jfloat t = x10p*(y0-y0p) - y10p*(x0-x0p);
 388     t /= den;
 389     m[off++] = x0 + t*x10;
 390     m[off] = y0 + t*y10;
 391 }
 392 
 393 // Return the intersection point of the lines (x0, y0) -&gt; (x1, y1)
 394 // and (x0p, y0p) -&gt; (x1p, y1p) in m[0] and m[1]
 395 static void safecomputeMiter(const jfloat x0, const jfloat y0,
 396                              const jfloat x1, const jfloat y1,
 397                              const jfloat x0p, const jfloat y0p,
 398                              const jfloat x1p, const jfloat y1p,
 399                              jfloat m[], jint off)
 400 {
 401     jfloat x10 = x1 - x0;
 402     jfloat y10 = y1 - y0;
 403     jfloat x10p = x1p - x0p;
 404     jfloat y10p = y1p - y0p;
 405 
 406     // if this is 0, the lines are parallel. If they go in the
 407     // same direction, there is no intersection so m[off] and
 408     // m[off+1] will contain infinity, so no miter will be drawn.
 409     // If they go in the same direction that means that the start of the
 410     // current segment and the end of the previous segment have the same
 411     // tangent, in which case this method won&#39;t even be involved in
 412     // miter drawing because it won&#39;t be called by drawMiter (because
 413     // (mx == omx &amp;&amp; my == omy) will be true, and drawMiter will return
 414     // immediately).
 415     jfloat den = x10*y10p - x10p*y10;
 416     jfloat t;
 417 
 418     if (den == 0) {
 419         m[off++] = (x0 + x0p) / 2.0f;
 420         m[off] = (y0 + y0p) / 2.0f;
 421         return;
 422     }
 423     t = x10p*(y0-y0p) - y10p*(x0-x0p);
 424     t /= den;
 425     m[off++] = x0 + t*x10;
 426     m[off] = y0 + t*y10;
 427 }
 428 
 429 static jint drawMiter(PathConsumer *pStroker,
 430                       const jfloat pdx, const jfloat pdy,
 431                       const jfloat x0, const jfloat y0,
 432                       const jfloat dx, const jfloat dy,
 433                       jfloat omx, jfloat omy, jfloat mx, jfloat my,
 434                       jboolean rev)
 435 {
 436     jfloat lenSq;
 437 
 438     if ((mx == omx &amp;&amp; my == omy) ||
 439         (pdx == 0 &amp;&amp; pdy == 0) ||
 440         (dx == 0 &amp;&amp; dy == 0)) {
 441         return ERROR_NONE;
 442     }
 443 
 444     if (rev) {
 445         omx = -omx;
 446         omy = -omy;
 447         mx = -mx;
 448         my = -my;
 449     }
 450 
 451     computeMiter((x0 - pdx) + omx, (y0 - pdy) + omy, x0 + omx, y0 + omy,
 452                  (dx + x0) + mx, (dy + y0) + my, x0 + mx, y0 + my,
 453                  this.miter, 0);
 454 
 455     lenSq = (this.miter[0]-x0)*(this.miter[0]-x0) + (this.miter[1]-y0)*(this.miter[1]-y0);
 456 
 457     if (lenSq &lt; this.miterLimitSq) {
 458         return emitLineTo(pStroker, this.miter[0], this.miter[1], rev);
 459     }
 460     return ERROR_NONE;
 461 }
 462 
 463 static jint Stroker_moveTo(PathConsumer *pStroker, jfloat x0, jfloat y0) {
 464     jint status = ERROR_NONE;
 465     if (this.prev == DRAWING_OP_TO) {
 466         status = finish(pStroker);
 467         if (status != ERROR_NONE) {
 468             return status;
 469         }
 470     }
 471     this.sx0 = this.cx0 = x0;
 472     this.sy0 = this.cy0 = y0;
 473     this.cdx = this.sdx = 1;
 474     this.cdy = this.sdy = 0;
 475     this.prev = MOVE_TO;
 476     return status;
 477 }
 478 
 479 static jint Stroker_lineTo(PathConsumer *pStroker, jfloat x1, jfloat y1) {
 480     jint status = ERROR_NONE;
 481     jfloat dx = x1 - this.cx0;
 482     jfloat dy = y1 - this.cy0;
 483     jfloat mx, my;
 484 
 485     if (dx == 0.0f &amp;&amp; dy == 0.0f) {
 486         dx = 1;
 487     }
 488     computeOffset(dx, dy, this.lineWidth2, this.offset[0]);
 489     mx = this.offset[0][0];
 490     my = this.offset[0][1];
 491 
 492     status = drawJoin(pStroker,
 493              this.cdx, this.cdy, this.cx0, this.cy0,
 494              dx, dy, this.cmx, this.cmy, mx, my);
 495     if (status != ERROR_NONE) {
 496         return status;
 497     }
 498 
 499     status = emitLineTo(pStroker, this.cx0 + mx, this.cy0 + my, JNI_FALSE);
 500     if (status != ERROR_NONE) {
 501         return status;
 502     }
 503     status = emitLineTo(pStroker, x1 + mx, y1 + my, JNI_FALSE);
 504     if (status != ERROR_NONE) {
 505         return status;
 506     }
 507 
 508     status = emitLineTo(pStroker, this.cx0 - mx, this.cy0 - my, JNI_TRUE);
 509     if (status != ERROR_NONE) {
 510         return status;
 511     }
 512     status = emitLineTo(pStroker, x1 - mx, y1 - my, JNI_TRUE);
 513     if (status != ERROR_NONE) {
 514         return status;
 515     }
 516 
 517     this.cmx = mx;
 518     this.cmy = my;
 519     this.cdx = dx;
 520     this.cdy = dy;
 521     this.cx0 = x1;
 522     this.cy0 = y1;
 523     this.prev = DRAWING_OP_TO;
 524     return status;
 525 }
 526 
 527 static jint Stroker_closePath(PathConsumer *pStroker) {
 528     jint status = ERROR_NONE;
 529     if (this.prev != DRAWING_OP_TO) {
 530         if (this.prev == CLOSE) {
 531             return status;
 532         }
 533         status = emitMoveTo(pStroker, this.cx0, this.cy0 - this.lineWidth2);
 534         if (status != ERROR_NONE) {
 535             return status;
 536         }
 537         this.cmx = this.smx = 0;
 538         this.cmy = this.smy = -this.lineWidth2;
 539         this.cdx = this.sdx = 1;
 540         this.cdy = this.sdy = 0;
 541         return finish(pStroker);
 542     }
 543 
 544     if (this.cx0 != this.sx0 || this.cy0 != this.sy0) {
 545         status = Stroker_lineTo(pStroker, this.sx0, this.sy0);
 546         if (status != ERROR_NONE) {
 547             return status;
 548         }
 549     }
 550 
 551     status = drawJoin(pStroker,
 552              this.cdx, this.cdy, this.cx0, this.cy0,
 553              this.sdx, this.sdy, this.cmx, this.cmy,
 554              this.smx, this.smy);
 555     if (status != ERROR_NONE) {
 556         return status;
 557     }
 558 
 559     status = emitLineTo(pStroker, this.sx0 + this.smx, this.sy0 + this.smy, JNI_FALSE);
 560     if (status != ERROR_NONE) {
 561         return status;
 562     }
 563 
 564     status = emitMoveTo(pStroker, this.sx0 - this.smx, this.sy0 - this.smy);
 565     if (status != ERROR_NONE) {
 566         return status;
 567     }
 568     status = emitReverse(pStroker);
 569     if (status != ERROR_NONE) {
 570         return status;
 571     }
 572 
 573     this.prev = CLOSE;
 574     return emitClose(pStroker);
 575 }
 576 
 577 static jint emitReverse(PathConsumer *pStroker) {
 578     jint status = ERROR_NONE;
 579     while (!PolyStack_isEmpty(&amp;this.reverse)) {
 580         status = PolyStack_pop(&amp;this.reverse, this.out);
 581         if (status != ERROR_NONE) {
 582             return status;
 583         }
 584     }
 585     return status;
 586 }
 587 
 588 static jint Stroker_pathDone(PathConsumer *pStroker) {
 589     jint status = ERROR_NONE;
 590     if (this.prev == DRAWING_OP_TO) {
 591         status = finish(pStroker);
 592         if (status != ERROR_NONE) {
 593             return status;
 594         }
 595     }
 596 
 597     status = this.out-&gt;pathDone(this.out);
 598     if (status != ERROR_NONE) {
 599         return status;
 600     }
 601     // this shouldn&#39;t matter since this object won&#39;t be used
 602     // after the call to this method.
 603     this.prev = CLOSE;
 604     return status;
 605 }
 606 
 607 static jint finish(PathConsumer *pStroker) {
 608     jint status = ERROR_NONE;
 609     if (this.capStyle == CAP_ROUND) {
 610         status = drawRoundCap(pStroker, this.cx0, this.cy0, this.cmx, this.cmy);
 611         if (status != ERROR_NONE) {
 612             return status;
 613         }
 614     } else if (this.capStyle == CAP_SQUARE) {
 615         status = emitLineTo(pStroker, this.cx0 - this.cmy + this.cmx, this.cy0 + this.cmx + this.cmy, JNI_FALSE);
 616         if (status != ERROR_NONE) {
 617             return status;
 618         }
 619         status = emitLineTo(pStroker, this.cx0 - this.cmy - this.cmx, this.cy0 + this.cmx - this.cmy, JNI_FALSE);
 620         if (status != ERROR_NONE) {
 621             return status;
 622         }
 623     }
 624 
 625     status = emitReverse(pStroker);
 626     if (status != ERROR_NONE) {
 627         return status;
 628     }
 629 
 630     if (this.capStyle == CAP_ROUND) {
 631         status = drawRoundCap(pStroker, this.sx0, this.sy0, -this.smx, -this.smy);
 632         if (status != ERROR_NONE) {
 633             return status;
 634         }
 635     } else if (this.capStyle == CAP_SQUARE) {
 636         status = emitLineTo(pStroker, this.sx0 + this.smy - this.smx, this.sy0 - this.smx - this.smy, JNI_FALSE);
 637         if (status != ERROR_NONE) {
 638             return status;
 639         }
 640         status = emitLineTo(pStroker, this.sx0 + this.smy + this.smx, this.sy0 - this.smx + this.smy, JNI_FALSE);
 641         if (status != ERROR_NONE) {
 642             return status;
 643         }
 644     }
 645 
 646     return emitClose(pStroker);
 647 }
 648 
 649 static jint emitMoveTo(PathConsumer *pStroker, const jfloat x0, const jfloat y0) {
 650     return this.out-&gt;moveTo(this.out, x0, y0);
 651 }
 652 
 653 static jint emitLineTo(PathConsumer *pStroker, const jfloat x1, const jfloat y1,
 654                        const jboolean rev)
 655 {
 656     if (rev) {
 657         return PolyStack_pushLine(&amp;this.reverse, x1, y1);
 658     } else {
 659         return this.out-&gt;lineTo(this.out, x1, y1);
 660     }
 661 }
 662 
 663 static jint emitQuadTo(PathConsumer *pStroker,
 664                        const jfloat x0, const jfloat y0,
 665                        const jfloat x1, const jfloat y1,
 666                        const jfloat x2, const jfloat y2, const jboolean rev)
 667 {
 668     if (rev) {
 669         return PolyStack_pushQuad(&amp;this.reverse, x0, y0, x1, y1);
 670     } else {
 671         return this.out-&gt;quadTo(this.out, x1, y1, x2, y2);
 672     }
 673 }
 674 
 675 static jint emitCurveTo(PathConsumer *pStroker,
 676                         const jfloat x0, const jfloat y0,
 677                         const jfloat x1, const jfloat y1,
 678                         const jfloat x2, const jfloat y2,
 679                         const jfloat x3, const jfloat y3, const jboolean rev)
 680 {
 681     if (rev) {
 682         return PolyStack_pushCubic(&amp;this.reverse, x0, y0, x1, y1, x2, y2);
 683     } else {
 684         return this.out-&gt;curveTo(this.out, x1, y1, x2, y2, x3, y3);
 685     }
 686 }
 687 
 688 static jint emitClose(PathConsumer *pStroker) {
 689     return this.out-&gt;closePath(this.out);
 690 }
 691 
 692 static jint drawJoin(PathConsumer *pStroker,
 693                      jfloat pdx, jfloat pdy,
 694                      jfloat x0, jfloat y0,
 695                      jfloat dx, jfloat dy,
 696                      jfloat omx, jfloat omy,
 697                      jfloat mx, jfloat my)
 698 {
 699     jint status = ERROR_NONE;
 700     if (this.prev != DRAWING_OP_TO) {
 701         status = emitMoveTo(pStroker, x0 + mx, y0 + my);
 702         if (status != ERROR_NONE) {
 703             return status;
 704         }
 705         this.sdx = dx;
 706         this.sdy = dy;
 707         this.smx = mx;
 708         this.smy = my;
 709     } else {
 710         jboolean cw = isCW(pdx, pdy, dx, dy);
 711         if (this.joinStyle == JOIN_MITER) {
 712             status = drawMiter(pStroker, pdx, pdy, x0, y0, dx, dy, omx, omy, mx, my, cw);
 713             if (status != ERROR_NONE) {
 714                 return status;
 715             }
 716         } else if (this.joinStyle == JOIN_ROUND) {
 717             status = drawRoundJoin(pStroker,
 718                           x0, y0,
 719                           omx, omy,
 720                           mx, my, cw,
 721                           ROUND_JOIN_THRESHOLD);
 722             if (status != ERROR_NONE) {
 723                 return status;
 724             }
 725         }
 726         status = emitLineTo(pStroker, x0, y0, !cw);
 727         if (status != ERROR_NONE) {
 728             return status;
 729         }
 730     }
 731     this.prev = DRAWING_OP_TO;
 732     return status;
 733 }
 734 
 735 static jboolean withinULP(const jfloat x1, const jfloat y1,
 736                           const jfloat x2, const jfloat y2,
 737                           const int maxUlps)
 738 {
 739 //    assert maxUlps is much smaller than 0x7fffffff;
 740     // compare taxicab distance. ERR will always be small, so using
 741     // true distance won&#39;t give much benefit
 742     return (Helpers_withinULP(x1, x2, maxUlps) &amp;&amp;
 743             Helpers_withinULP(y1, y2, maxUlps));
 744 }
 745 
 746 static void getLineOffsets(PathConsumer *pStroker,
 747                            jfloat x1, jfloat y1,
 748                            jfloat x2, jfloat y2,
 749                            jfloat left[], jfloat right[]) {
 750     computeOffset(x2 - x1, y2 - y1, this.lineWidth2, this.offset[0]);
 751     left[0] = x1 + this.offset[0][0];
 752     left[1] = y1 + this.offset[0][1];
 753     left[2] = x2 + this.offset[0][0];
 754     left[3] = y2 + this.offset[0][1];
 755     right[0] = x1 - this.offset[0][0];
 756     right[1] = y1 - this.offset[0][1];
 757     right[2] = x2 - this.offset[0][0];
 758     right[3] = y2 - this.offset[0][1];
 759 }
 760 
 761 static jint computeOffsetCubic(PathConsumer *pStroker,
 762                                jfloat pts[], const jint off,
 763                                jfloat leftOff[], jfloat rightOff[])
 764 {
 765     jfloat dotsq, l1sq, l4sq;
 766     jfloat x, y, dxm, dym;
 767 
 768     // if p1=p2 or p3=p4 it means that the derivative at the endpoint
 769     // vanishes, which creates problems with computeOffset. Usually
 770     // this happens when this stroker object is trying to winden
 771     // a curve with a cusp. What happens is that curveTo splits
 772     // the input curve at the cusp, and passes it to this function.
 773     // because of inaccuracies in the splitting, we consider points
 774     // equal if they&#39;re very close to each other.
 775     const jfloat x1 = pts[off + 0], y1 = pts[off + 1];
 776     const jfloat x2 = pts[off + 2], y2 = pts[off + 3];
 777     const jfloat x3 = pts[off + 4], y3 = pts[off + 5];
 778     const jfloat x4 = pts[off + 6], y4 = pts[off + 7];
 779 
 780     jfloat dx4 = x4 - x3;
 781     jfloat dy4 = y4 - y3;
 782     jfloat dx1 = x2 - x1;
 783     jfloat dy1 = y2 - y1;
 784 
 785     // if p1 == p2 &amp;&amp; p3 == p4: draw line from p1-&gt;p4, unless p1 == p4,
 786     // in which case ignore if p1 == p2
 787     const jboolean p1eqp2 = withinULP(x1,y1,x2,y2, 6);
 788     const jboolean p3eqp4 = withinULP(x3,y3,x4,y4, 6);
 789     if (p1eqp2 &amp;&amp; p3eqp4) {
 790         getLineOffsets(pStroker, x1, y1, x4, y4, leftOff, rightOff);
 791         return 4;
 792     } else if (p1eqp2) {
 793         dx1 = x3 - x1;
 794         dy1 = y3 - y1;
 795     } else if (p3eqp4) {
 796         dx4 = x4 - x2;
 797         dy4 = y4 - y2;
 798     }
 799 
 800     // if p2-p1 and p4-p3 are parallel, that must mean this curve is a line
 801     dotsq = (dx1 * dx4 + dy1 * dy4);
 802     dotsq = dotsq * dotsq;
 803     l1sq = dx1 * dx1 + dy1 * dy1;
 804     l4sq = dx4 * dx4 + dy4 * dy4;
 805     if (Helpers_withinULP(dotsq, l1sq * l4sq, 4)) {
 806         getLineOffsets(pStroker, x1, y1, x4, y4, leftOff, rightOff);
 807         return 4;
 808     }
 809 
 810 //      What we&#39;re trying to do in this function is to approximate an ideal
 811 //      offset curve (call it I) of the input curve B using a bezier curve Bp.
 812 //      The constraints I use to get the equations are:
 813 //
 814 //      1. The computed curve Bp should go through I(0) and I(1). These are
 815 //      x1p, y1p, x4p, y4p, which are p1p and p4p. We still need to find
 816 //      4 variables: the x and y components of p2p and p3p (i.e. x2p, y2p, x3p, y3p).
 817 //
 818 //      2. Bp should have slope equal in absolute value to I at the endpoints. So,
 819 //      (by the way, the operator || in the comments below means &quot;aligned with&quot;.
 820 //      It is defined on vectors, so when we say I&#39;(0) || Bp&#39;(0) we mean that
 821 //      vectors I&#39;(0) and Bp&#39;(0) are aligned, which is the same as saying
 822 //      that the tangent lines of I and Bp at 0 are parallel. Mathematically
 823 //      this means (I&#39;(t) || Bp&#39;(t)) &lt;==&gt; (I&#39;(t) = c * Bp&#39;(t)) where c is some
 824 //      nonzero constant.)
 825 //      I&#39;(0) || Bp&#39;(0) and I&#39;(1) || Bp&#39;(1). Obviously, I&#39;(0) || B&#39;(0) and
 826 //      I&#39;(1) || B&#39;(1); therefore, Bp&#39;(0) || B&#39;(0) and Bp&#39;(1) || B&#39;(1).
 827 //      We know that Bp&#39;(0) || (p2p-p1p) and Bp&#39;(1) || (p4p-p3p) and the same
 828 //      is true for any bezier curve; therefore, we get the equations
 829 //          (1) p2p = c1 * (p2-p1) + p1p
 830 //          (2) p3p = c2 * (p4-p3) + p4p
 831 //      We know p1p, p4p, p2, p1, p3, and p4; therefore, this reduces the number
 832 //      of unknowns from 4 to 2 (i.e. just c1 and c2).
 833 //      To eliminate these 2 unknowns we use the following constraint:
 834 //
 835 //      3. Bp(0.5) == I(0.5). Bp(0.5)=(x,y) and I(0.5)=(xi,yi), and I should note
 836 //      that I(0.5) is *the only* reason for computing dxm,dym. This gives us
 837 //          (3) Bp(0.5) = (p1p + 3 * (p2p + p3p) + p4p)/8, which is equivalent to
 838 //          (4) p2p + p3p = (Bp(0.5)*8 - p1p - p4p) / 3
 839 //      We can substitute (1) and (2) from above into (4) and we get:
 840 //          (5) c1*(p2-p1) + c2*(p4-p3) = (Bp(0.5)*8 - p1p - p4p)/3 - p1p - p4p
 841 //      which is equivalent to
 842 //          (6) c1*(p2-p1) + c2*(p4-p3) = (4/3) * (Bp(0.5) * 2 - p1p - p4p)
 843 //
 844 //      The right side of this is a 2D vector, and we know I(0.5), which gives us
 845 //      Bp(0.5), which gives us the value of the right side.
 846 //      The left side is just a matrix vector multiplication in disguise. It is
 847 //
 848 //      [x2-x1, x4-x3][c1]
 849 //      [y2-y1, y4-y3][c2]
 850 //      which, is equal to
 851 //      [dx1, dx4][c1]
 852 //      [dy1, dy4][c2]
 853 //      At this point we are left with a simple linear system and we solve it by
 854 //      getting the inverse of the matrix above. Then we use [c1,c2] to compute
 855 //      p2p and p3p.
 856 
 857     x = 0.125f * (x1 + 3 * (x2 + x3) + x4);
 858     y = 0.125f * (y1 + 3 * (y2 + y3) + y4);
 859     // (dxm,dym) is some tangent of B at t=0.5. This means it&#39;s equal to
 860     // c*B&#39;(0.5) for some constant c.
 861     dxm = x3 + x4 - x1 - x2;
 862     dym = y3 + y4 - y1 - y2;
 863 
 864     // this computes the offsets at t=0, 0.5, 1, using the property that
 865     // for any bezier curve the vectors p2-p1 and p4-p3 are parallel to
 866     // the (dx/dt, dy/dt) vectors at the endpoints.
 867     computeOffset(dx1, dy1, this.lineWidth2, this.offset[0]);
 868     computeOffset(dxm, dym, this.lineWidth2, this.offset[1]);
 869     computeOffset(dx4, dy4, this.lineWidth2, this.offset[2]);
 870     {
 871         jfloat x1p = x1 + this.offset[0][0]; // start
 872         jfloat y1p = y1 + this.offset[0][1]; // point
 873         jfloat xi  = x  + this.offset[1][0]; // interpolation
 874         jfloat yi  = y  + this.offset[1][1]; // point
 875         jfloat x4p = x4 + this.offset[2][0]; // end
 876         jfloat y4p = y4 + this.offset[2][1]; // point
 877 
 878         jfloat invdet43 = 4.0f / (3.0f * (dx1 * dy4 - dy1 * dx4));
 879 
 880         jfloat two_pi_m_p1_m_p4x = 2*xi - x1p - x4p;
 881         jfloat two_pi_m_p1_m_p4y = 2*yi - y1p - y4p;
 882         jfloat c1 = invdet43 * (dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y);
 883         jfloat c2 = invdet43 * (dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x);
 884 
 885         jfloat x2p, y2p, x3p, y3p;
 886         x2p = x1p + c1*dx1;
 887         y2p = y1p + c1*dy1;
 888         x3p = x4p + c2*dx4;
 889         y3p = y4p + c2*dy4;
 890 
 891         leftOff[0] = x1p; leftOff[1] = y1p;
 892         leftOff[2] = x2p; leftOff[3] = y2p;
 893         leftOff[4] = x3p; leftOff[5] = y3p;
 894         leftOff[6] = x4p; leftOff[7] = y4p;
 895 
 896         x1p = x1 -     this.offset[0][0]; y1p = y1 -     this.offset[0][1];
 897         xi  = xi - 2 * this.offset[1][0]; yi  = yi - 2 * this.offset[1][1];
 898         x4p = x4 -     this.offset[2][0]; y4p = y4 -     this.offset[2][1];
 899 
 900         two_pi_m_p1_m_p4x = 2*xi - x1p - x4p;
 901         two_pi_m_p1_m_p4y = 2*yi - y1p - y4p;
 902         c1 = invdet43 * (dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y);
 903         c2 = invdet43 * (dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x);
 904 
 905         x2p = x1p + c1*dx1;
 906         y2p = y1p + c1*dy1;
 907         x3p = x4p + c2*dx4;
 908         y3p = y4p + c2*dy4;
 909 
 910         rightOff[0] = x1p; rightOff[1] = y1p;
 911         rightOff[2] = x2p; rightOff[3] = y2p;
 912         rightOff[4] = x3p; rightOff[5] = y3p;
 913         rightOff[6] = x4p; rightOff[7] = y4p;
 914     }
 915     return 8;
 916 }
 917 
 918 // compute offset curves using bezier spline through t=0.5 (i.e.
 919 // ComputedCurve(0.5) == IdealParallelCurve(0.5))
 920 // return the kind of curve in the right and left arrays.
 921 static jint computeOffsetQuad(PathConsumer *pStroker,
 922                               jfloat pts[], const jint off,
 923                               jfloat leftOff[], jfloat rightOff[])
 924 {
 925     const jfloat x1 = pts[off + 0], y1 = pts[off + 1];
 926     const jfloat x2 = pts[off + 2], y2 = pts[off + 3];
 927     const jfloat x3 = pts[off + 4], y3 = pts[off + 5];
 928     jfloat dotsq, l1sq, l3sq;
 929 
 930     jfloat dx3 = x3 - x2;
 931     jfloat dy3 = y3 - y2;
 932     jfloat dx1 = x2 - x1;
 933     jfloat dy1 = y2 - y1;
 934 
 935     // if p1=p2 or p3=p4 it means that the derivative at the endpoint
 936     // vanishes, which creates problems with computeOffset. Usually
 937     // this happens when this stroker object is trying to winden
 938     // a curve with a cusp. What happens is that curveTo splits
 939     // the input curve at the cusp, and passes it to this function.
 940     // because of inaccuracies in the splitting, we consider points
 941     // equal if they&#39;re very close to each other.
 942 
 943     // if p1 == p2 &amp;&amp; p3 == p4: draw line from p1-&gt;p4, unless p1 == p4,
 944     // in which case ignore.
 945     const jboolean p1eqp2 = withinULP(x1,y1,x2,y2, 6);
 946     const jboolean p2eqp3 = withinULP(x2,y2,x3,y3, 6);
 947     if (p1eqp2 || p2eqp3) {
 948         getLineOffsets(pStroker, x1, y1, x3, y3, leftOff, rightOff);
 949         return 4;
 950     }
 951 
 952     // if p2-p1 and p4-p3 are parallel, that must mean this curve is a line
 953     dotsq = (dx1 * dx3 + dy1 * dy3);
 954     dotsq = dotsq * dotsq;
 955     l1sq = dx1 * dx1 + dy1 * dy1;
 956     l3sq = dx3 * dx3 + dy3 * dy3;
 957     if (Helpers_withinULP(dotsq, l1sq * l3sq, 4)) {
 958         getLineOffsets(pStroker, x1, y1, x3, y3, leftOff, rightOff);
 959         return 4;
 960     }
 961 
 962     // this computes the offsets at t=0, 0.5, 1, using the property that
 963     // for any bezier curve the vectors p2-p1 and p4-p3 are parallel to
 964     // the (dx/dt, dy/dt) vectors at the endpoints.
 965     computeOffset(dx1, dy1, this.lineWidth2, this.offset[0]);
 966     computeOffset(dx3, dy3, this.lineWidth2, this.offset[1]);
 967     {
 968         jfloat x1p = x1 + this.offset[0][0]; // start
 969         jfloat y1p = y1 + this.offset[0][1]; // point
 970         jfloat x3p = x3 + this.offset[1][0]; // end
 971         jfloat y3p = y3 + this.offset[1][1]; // point
 972 
 973         safecomputeMiter(x1p, y1p, x1p+dx1, y1p+dy1, x3p, y3p, x3p-dx3, y3p-dy3, leftOff, 2);
 974         leftOff[0] = x1p; leftOff[1] = y1p;
 975         leftOff[4] = x3p; leftOff[5] = y3p;
 976         x1p = x1 - this.offset[0][0]; y1p = y1 - this.offset[0][1];
 977         x3p = x3 - this.offset[1][0]; y3p = y3 - this.offset[1][1];
 978         safecomputeMiter(x1p, y1p, x1p+dx1, y1p+dy1, x3p, y3p, x3p-dx3, y3p-dy3, rightOff, 2);
 979         rightOff[0] = x1p; rightOff[1] = y1p;
 980         rightOff[4] = x3p; rightOff[5] = y3p;
 981     }
 982     return 6;
 983 }
 984 
 985 // This is where the curve to be processed is put. We give it
 986 // enough room to store 2 curves: one for the current subdivision, the
 987 // other for the rest of the curve.
 988 #define MAX_N_CURVES   11
 989 
 990 static jfloat middle[MAX_N_CURVES*8];
 991 static jfloat lp[8];
 992 static jfloat rp[8];
 993 static jfloat subdivTs[MAX_N_CURVES - 1];
 994 
 995 // The following variation of somethingTo() caused problems when this was
 996 // Java code as indicated by the following comment.  Now that this code has
 997 // been converted into C, we should look at investigating the potential
 998 // performance benefits of using this version instead of the &quot;safer&quot; version
 999 // that survived in the Java sources and is currently being used below.
1000     // If this class is compiled with ecj, then Hotspot crashes when OSR
1001     // compiling this function. See bugs 7004570 and 6675699
1002     // NOTE: until those are fixed, we should work around that by
1003     // manually inlining this into curveTo and quadTo.
1004 /******************************* WORKAROUND **********************************
1005     private void somethingTo(final int type) {
1006         // need these so we can update the state at the end of this method
1007         final float xf = middle[type-2], yf = middle[type-1];
1008         float dxs = middle[2] - middle[0];
1009         float dys = middle[3] - middle[1];
1010         float dxf = middle[type - 2] - middle[type - 4];
1011         float dyf = middle[type - 1] - middle[type - 3];
1012         switch(type) {
1013         case 6:
1014             if ((dxs == 0f &amp;&amp; dys == 0f) ||
1015                 (dxf == 0f &amp;&amp; dyf == 0f)) {
1016                dxs = dxf = middle[4] - middle[0];
1017                dys = dyf = middle[5] - middle[1];
1018             }
1019             break;
1020         case 8:
1021             boolean p1eqp2 = (dxs == 0f &amp;&amp; dys == 0f);
1022             boolean p3eqp4 = (dxf == 0f &amp;&amp; dyf == 0f);
1023             if (p1eqp2) {
1024                 dxs = middle[4] - middle[0];
1025                 dys = middle[5] - middle[1];
1026                 if (dxs == 0f &amp;&amp; dys == 0f) {
1027                     dxs = middle[6] - middle[0];
1028                     dys = middle[7] - middle[1];
1029                 }
1030             }
1031             if (p3eqp4) {
1032                 dxf = middle[6] - middle[2];
1033                 dyf = middle[7] - middle[3];
1034                 if (dxf == 0f &amp;&amp; dyf == 0f) {
1035                     dxf = middle[6] - middle[0];
1036                     dyf = middle[7] - middle[1];
1037                 }
1038             }
1039         }
1040         if (dxs == 0f &amp;&amp; dys == 0f) {
1041             // this happens iff the &quot;curve&quot; is just a point
1042             lineTo(middle[0], middle[1]);
1043             return;
1044         }
1045         // if these vectors are too small, normalize them, to avoid future
1046         // precision problems.
1047         if (Math.abs(dxs) &lt; 0.1f &amp;&amp; Math.abs(dys) &lt; 0.1f) {
1048             float len = (float)Math.sqrt(dxs*dxs + dys*dys);
1049             dxs /= len;
1050             dys /= len;
1051         }
1052         if (Math.abs(dxf) &lt; 0.1f &amp;&amp; Math.abs(dyf) &lt; 0.1f) {
1053             float len = (float)Math.sqrt(dxf*dxf + dyf*dyf);
1054             dxf /= len;
1055             dyf /= len;
1056         }
1057 
1058         computeOffset(dxs, dys, lineWidth2, offset[0]);
1059         final float mx = offset[0][0];
1060         final float my = offset[0][1];
1061         drawJoin(pStroker, cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, mx, my);
1062 
1063         int nSplits = findSubdivPoints(pStroker, middle, subdivTs, type, lineWidth2);
1064 
1065         int kind = 0;
1066         Iterator&lt;Integer&gt; it = Curve.breakPtsAtTs(middle, type, subdivTs, nSplits);
1067         while(it.hasNext()) {
1068             int curCurveOff = it.next();
1069 
1070             kind = 0;
1071             switch (type) {
1072             case 8:
1073                 kind = computeOffsetCubic(middle, curCurveOff, lp, rp);
1074                 break;
1075             case 6:
1076                 kind = computeOffsetQuad(middle, curCurveOff, lp, rp);
1077                 break;
1078             }
1079             if (kind != 0) {
1080                 emitLineTo(pStroker, lp[0], lp[1], JNI_FALSE);
1081                 switch(kind) {
1082                 case 8:
1083                     emitCurveTo(pStroker, lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], lp[6], lp[7], false);
1084                     emitCurveTo(pStroker, rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], rp[6], rp[7], true);
1085                     break;
1086                 case 6:
1087                     emitQuadTo(pStroker, lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], false);
1088                     emitQuadTo(pStroker, rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], true);
1089                     break;
1090                 case 4:
1091                     emitLineTo(pStroker, lp[2], lp[3], JNI_FALSE);
1092                     emitLineTo(pStroker, rp[0], rp[1], JNI_TRUE);
1093                     break;
1094                 }
1095                 emitLineTo(pStroker, rp[kind - 2], rp[kind - 1], true);
1096             }
1097         }
1098 
1099         this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;
1100         this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;
1101         this.cdx = dxf;
1102         this.cdy = dyf;
1103         this.cx0 = xf;
1104         this.cy0 = yf;
1105         this.prev = DRAWING_OP_TO;
1106     }
1107 ****************************** END WORKAROUND *******************************/
1108 
1109 // finds values of t where the curve in pts should be subdivided in order
1110 // to get good offset curves a distance of w away from the middle curve.
1111 // Stores the points in ts, and returns how many of them there were.
1112 static jint findSubdivPoints(PathConsumer *pStroker,
1113                              jfloat pts[], jfloat ts[],
1114                              const jint type, const jfloat w)
1115 {
1116     jint ret = 0;
1117 
1118     const jfloat x12 = pts[2] - pts[0];
1119     const jfloat y12 = pts[3] - pts[1];
1120     // if the curve is already parallel to either axis we gain nothing
1121     // from rotating it.
1122     if (y12 != 0.0f &amp;&amp; x12 != 0.0f) {
1123         // we rotate it so that the first vector in the control polygon is
1124         // parallel to the x-axis. This will ensure that rotated quarter
1125         // circles won&#39;t be subdivided.
1126         const jfloat hypot = (jfloat) sqrt(x12 * x12 + y12 * y12);
1127         const jfloat cos = x12 / hypot;
1128         const jfloat sin = y12 / hypot;
1129         const jfloat x1 = cos * pts[0] + sin * pts[1];
1130         const jfloat y1 = cos * pts[1] - sin * pts[0];
1131         const jfloat x2 = cos * pts[2] + sin * pts[3];
1132         const jfloat y2 = cos * pts[3] - sin * pts[2];
1133         const jfloat x3 = cos * pts[4] + sin * pts[5];
1134         const jfloat y3 = cos * pts[5] - sin * pts[4];
1135         switch(type) {
1136         case 8:
1137         {
1138             const jfloat x4 = cos * pts[6] + sin * pts[7];
1139             const jfloat y4 = cos * pts[7] - sin * pts[6];
1140             Curve_setcubic(&amp;this.c, x1, y1, x2, y2, x3, y3, x4, y4);
1141             break;
1142         }
1143         case 6:
1144             Curve_setquad(&amp;this.c, x1, y1, x2, y2, x3, y3);
1145             break;
1146         }
1147     } else {
1148         Curve_set(&amp;this.c, pts, type);
1149     }
1150 
1151     // we subdivide at values of t such that the remaining rotated
1152     // curves are monotonic in x and y.
1153     ret += Curve_dxRoots(&amp;this.c, ts, ret);
1154     ret += Curve_dyRoots(&amp;this.c, ts, ret);
1155     // subdivide at inflection points.
1156     if (type == 8) {
1157         // quadratic curves can&#39;t have inflection points
1158         ret += Curve_infPoints(&amp;this.c, ts, ret);
1159     }
1160 
1161     // now we must subdivide at points where one of the offset curves will have
1162     // a cusp. This happens at ts where the radius of curvature is equal to w.
1163     ret += Curve_rootsOfROCMinusW(&amp;this.c, ts, ret, w, 0.0001f);
1164 
1165     ret = Helpers_filterOutNotInAB(ts, 0, ret, 0.0001f, 0.9999f);
1166     Helpers_isort(ts, 0, ret);
1167     return ret;
1168 }
1169 
1170 static jint Stroker_curveTo(PathConsumer *pStroker,
1171                            jfloat x1, jfloat y1,
1172                            jfloat x2, jfloat y2,
1173                            jfloat x3, jfloat y3)
1174 {
1175     jint status = ERROR_NONE;
1176     jfloat xf, yf, dxs, dys, dxf, dyf;
1177     jfloat mx, my;
1178     jint nSplits;
1179     jfloat prevT;
1180     jint i, kind;
1181     jboolean p1eqp2, p3eqp4;
1182 
1183     middle[0] = this.cx0; middle[1] = this.cy0;
1184     middle[2] = x1;  middle[3] = y1;
1185     middle[4] = x2;  middle[5] = y2;
1186     middle[6] = x3;  middle[7] = y3;
1187 
1188     // inlined version of somethingTo(8);
1189     // See the NOTE on somethingTo
1190 
1191     // need these so we can update the state at the end of this method
1192     xf = middle[6], yf = middle[7];
1193     dxs = middle[2] - middle[0];
1194     dys = middle[3] - middle[1];
1195     dxf = middle[6] - middle[4];
1196     dyf = middle[7] - middle[5];
1197 
1198     p1eqp2 = (dxs == 0.0f &amp;&amp; dys == 0.0f);
1199     p3eqp4 = (dxf == 0.0f &amp;&amp; dyf == 0.0f);
1200     if (p1eqp2) {
1201         dxs = middle[4] - middle[0];
1202         dys = middle[5] - middle[1];
1203         if (dxs == 0.0f &amp;&amp; dys == 0.0f) {
1204             dxs = middle[6] - middle[0];
1205             dys = middle[7] - middle[1];
1206         }
1207     }
1208     if (p3eqp4) {
1209         dxf = middle[6] - middle[2];
1210         dyf = middle[7] - middle[3];
1211         if (dxf == 0.0f &amp;&amp; dyf == 0.0f) {
1212             dxf = middle[6] - middle[0];
1213             dyf = middle[7] - middle[1];
1214         }
1215     }
1216     if (dxs == 0.0f &amp;&amp; dys == 0.0f) {
1217         // this happens iff the &quot;curve&quot; is just a point
1218         return Stroker_lineTo(pStroker, middle[0], middle[1]);
1219     }
1220 
1221     // if these vectors are too small, normalize them, to avoid future
1222     // precision problems.
1223     if (fabs(dxs) &lt; 0.1f &amp;&amp; fabs(dys) &lt; 0.1f) {
1224         jfloat len = (jfloat) sqrt(dxs*dxs + dys*dys);
1225         dxs /= len;
1226         dys /= len;
1227     }
1228     if (fabs(dxf) &lt; 0.1f &amp;&amp; fabs(dyf) &lt; 0.1f) {
1229         jfloat len = (jfloat) sqrt(dxf*dxf + dyf*dyf);
1230         dxf /= len;
1231         dyf /= len;
1232     }
1233 
1234     computeOffset(dxs, dys, this.lineWidth2, this.offset[0]);
1235     mx = this.offset[0][0];
1236     my = this.offset[0][1];
1237     status = drawJoin(pStroker,
1238              this.cdx, this.cdy, this.cx0, this.cy0,
1239              dxs, dys, this.cmx, this.cmy,
1240              mx, my);
1241     if (status != ERROR_NONE) {
1242         return status;
1243     }
1244 
1245     nSplits = findSubdivPoints(pStroker, middle, subdivTs, 8, this.lineWidth2);
1246     prevT = 0.0f;
1247     for (i = 0; i &lt; nSplits; i++) {
1248         jfloat t = subdivTs[i];
1249         Helpers_subdivideCubicAt((t - prevT) / (1 - prevT),
1250                                  middle, i*6,
1251                                  middle, i*6,
1252                                  middle, i*6+6);
1253         prevT = t;
1254     }
1255 
1256     kind = 0;
1257     for (i = 0; i &lt;= nSplits; i++) {
1258         kind = computeOffsetCubic(pStroker, middle, i*6, lp, rp);
1259         if (kind != 0) {
1260             status = emitLineTo(pStroker, lp[0], lp[1], JNI_FALSE);
1261             if (status != ERROR_NONE) {
1262                 return status;
1263             }
1264             switch(kind) {
1265             case 8:
1266                 status = emitCurveTo(pStroker, lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], lp[6], lp[7], JNI_FALSE);
1267                 if (status != ERROR_NONE) {
1268                     return status;
1269                 }
1270                 status = emitCurveTo(pStroker, rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], rp[6], rp[7], JNI_TRUE);
1271                 if (status != ERROR_NONE) {
1272                     return status;
1273                 }
1274                 break;
1275             case 4:
1276                 status = emitLineTo(pStroker, lp[2], lp[3], JNI_FALSE);
1277                 if (status != ERROR_NONE) {
1278                     return status;
1279                 }
1280                 status = emitLineTo(pStroker, rp[0], rp[1], JNI_TRUE);
1281                 if (status != ERROR_NONE) {
1282                     return status;
1283                 }
1284                 break;
1285             }
1286             status = emitLineTo(pStroker, rp[kind - 2], rp[kind - 1], JNI_TRUE);
1287             if (status != ERROR_NONE) {
1288                 return status;
1289             }
1290         }
1291     }
1292 
1293     this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;
1294     this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;
1295     this.cdx = dxf;
1296     this.cdy = dyf;
1297     this.cx0 = xf;
1298     this.cy0 = yf;
1299     this.prev = DRAWING_OP_TO;
1300     return status;
1301 }
1302 
1303 static jint Stroker_quadTo(PathConsumer *pStroker,
1304                           jfloat x1, jfloat y1,
1305                           jfloat x2, jfloat y2)
1306 {
1307     jint status = ERROR_NONE;
1308     jfloat xf, yf, dxs, dys, dxf, dyf;
1309     jfloat mx, my;
1310     jint nSplits, i, kind;
1311     jfloat prevt;
1312 
1313     middle[0] = this.cx0; middle[1] = this.cy0;
1314     middle[2] = x1;  middle[3] = y1;
1315     middle[4] = x2;  middle[5] = y2;
1316 
1317     // inlined version of somethingTo(8);
1318     // See the NOTE on somethingTo
1319 
1320     // need these so we can update the state at the end of this method
1321     xf = middle[4], yf = middle[5];
1322     dxs = middle[2] - middle[0];
1323     dys = middle[3] - middle[1];
1324     dxf = middle[4] - middle[2];
1325     dyf = middle[5] - middle[3];
1326     if ((dxs == 0.0f &amp;&amp; dys == 0.0f) || (dxf == 0.0f &amp;&amp; dyf == 0.0f)) {
1327         dxs = dxf = middle[4] - middle[0];
1328         dys = dyf = middle[5] - middle[1];
1329     }
1330     if (dxs == 0.0f &amp;&amp; dys == 0.0f) {
1331         // this happens iff the &quot;curve&quot; is just a point
1332         return Stroker_lineTo(pStroker, middle[0], middle[1]);
1333     }
1334     // if these vectors are too small, normalize them, to avoid future
1335     // precision problems.
1336     if (fabs(dxs) &lt; 0.1f &amp;&amp; fabs(dys) &lt; 0.1f) {
1337         jfloat len = (jfloat) sqrt(dxs*dxs + dys*dys);
1338         dxs /= len;
1339         dys /= len;
1340     }
1341     if (fabs(dxf) &lt; 0.1f &amp;&amp; fabs(dyf) &lt; 0.1f) {
1342         jfloat len = (jfloat) sqrt(dxf*dxf + dyf*dyf);
1343         dxf /= len;
1344         dyf /= len;
1345     }
1346 
1347     computeOffset(dxs, dys, this.lineWidth2, this.offset[0]);
1348     mx = this.offset[0][0];
1349     my = this.offset[0][1];
1350     status = drawJoin(pStroker,
1351              this.cdx, this.cdy, this.cx0, this.cy0,
1352              dxs, dys, this.cmx, this.cmy,
1353              mx, my);
1354     if (status != ERROR_NONE) {
1355         return status;
1356     }
1357 
1358     nSplits = findSubdivPoints(pStroker, middle, subdivTs, 6, this.lineWidth2);
1359     prevt = 0.0f;
1360     for (i = 0; i &lt; nSplits; i++) {
1361         jfloat t = subdivTs[i];
1362         Helpers_subdivideQuadAt((t - prevt) / (1 - prevt),
1363                                 middle, i*4,
1364                                 middle, i*4,
1365                                 middle, i*4+4);
1366         prevt = t;
1367     }
1368 
1369     kind = 0;
1370     for (i = 0; i &lt;= nSplits; i++) {
1371         kind = computeOffsetQuad(pStroker, middle, i*4, lp, rp);
1372         if (kind != 0) {
1373             status = emitLineTo(pStroker, lp[0], lp[1], JNI_FALSE);
1374             if (status != ERROR_NONE) {
1375                 return status;
1376             }
1377             switch(kind) {
1378             case 6:
1379                 status = emitQuadTo(pStroker, lp[0], lp[1], lp[2], lp[3], lp[4], lp[5], JNI_FALSE);
1380                 if (status != ERROR_NONE) {
1381                     return status;
1382                 }
1383                 status = emitQuadTo(pStroker, rp[0], rp[1], rp[2], rp[3], rp[4], rp[5], JNI_TRUE);
1384                 if (status != ERROR_NONE) {
1385                     return status;
1386                 }
1387                 break;
1388             case 4:
1389                 status = emitLineTo(pStroker, lp[2], lp[3], JNI_FALSE);
1390                 if (status != ERROR_NONE) {
1391                     return status;
1392                 }
1393                 status = emitLineTo(pStroker, rp[0], rp[1], JNI_TRUE);
1394                 if (status != ERROR_NONE) {
1395                     return status;
1396                 }
1397                 break;
1398             }
1399             status = emitLineTo(pStroker, rp[kind - 2], rp[kind - 1], JNI_TRUE);
1400             if (status != ERROR_NONE) {
1401                 return status;
1402             }
1403         }
1404     }
1405 
1406     this.cmx = (lp[kind - 2] - rp[kind - 2]) / 2;
1407     this.cmy = (lp[kind - 1] - rp[kind - 1]) / 2;
1408     this.cdx = dxf;
1409     this.cdy = dyf;
1410     this.cx0 = xf;
1411     this.cy0 = yf;
1412     this.prev = DRAWING_OP_TO;
1413     return status;
1414 }
1415 
1416 // a stack of polynomial curves where each curve shares endpoints with
1417 // adjacent ones.
1418 /*
1419     private static const class PolyStack {
1420         jfloat[] curves;
1421         int end;
1422         int[] curveTypes;
1423         int numCurves;
1424  */
1425 
1426 #define INIT_SIZE   50
1427 
1428 #undef this
1429 #define this (*((PolyStack *)pStack))
1430 
1431 void PolyStack_init(PolyStack *pStack) {
1432     this.curves = new_float(8 * INIT_SIZE);
1433     this.curvesSIZE = 8 * INIT_SIZE;
1434     this.curveTypes = new_int(INIT_SIZE);
1435     this.curveTypesSIZE = INIT_SIZE;
1436     this.end = 0;
1437     this.numCurves = 0;
1438 }
1439 
1440 void PolyStack_destroy(PolyStack *pStack) {
1441     free(this.curves);
1442     this.curves = NULL;
1443     this.curvesSIZE = 0;
1444     free(this.curveTypes);
1445     this.curveTypes = NULL;
1446     this.curveTypesSIZE = 0;
1447 }
1448 
1449 jboolean PolyStack_isEmpty(PolyStack *pStack) {
1450     return this.numCurves == 0;
1451 }
1452 
1453 static jint ensureSpace(PolyStack *pStack, jint n) {
1454     if (this.end + n &gt;= this.curvesSIZE) {
1455         jint newSize = (this.end + n) * 2;
1456         jfloat *newCurves = new_float(newSize);
1457         if (!newCurves) {
1458             return ERROR_OOM;
1459         }
1460         System_arraycopy(this.curves, 0, newCurves, 0, this.end);
1461         free(this.curves);
1462         this.curves = newCurves;
1463         this.curvesSIZE = newSize;
1464     }
1465     if (this.numCurves &gt;= this.curveTypesSIZE) {
1466         jint newSize = this.numCurves * 2;
1467         jint *newTypes = new_int(newSize);
1468         if (!newTypes) {
1469             return ERROR_OOM;
1470         }
1471         System_arraycopy(this.curveTypes, 0, newTypes, 0, this.numCurves);
1472         free(this.curveTypes);
1473         this.curveTypes = newTypes;
1474         this.curveTypesSIZE = newSize;
1475     }
1476     return ERROR_NONE;
1477 }
1478 
1479 jint PolyStack_pushCubic(PolyStack *pStack,
1480                          jfloat x0, jfloat y0,
1481                          jfloat x1, jfloat y1,
1482                          jfloat x2, jfloat y2)
1483 {
1484     jint status = ensureSpace(pStack, 6);
1485     if (status != ERROR_NONE) {
1486         return status;
1487     }
1488     this.curveTypes[this.numCurves++] = 8;
1489     // assert(x0 == lastX &amp;&amp; y0 == lastY)
1490 
1491     // we reverse the coordinate order to make popping easier
1492     this.curves[this.end++] = x2;    this.curves[this.end++] = y2;
1493     this.curves[this.end++] = x1;    this.curves[this.end++] = y1;
1494     this.curves[this.end++] = x0;    this.curves[this.end++] = y0;
1495     return status;
1496 }
1497 
1498 jint PolyStack_pushQuad(PolyStack *pStack,
1499                         jfloat x0, jfloat y0,
1500                         jfloat x1, jfloat y1)
1501 {
1502     jint status = ensureSpace(pStack, 4);
1503     if (status != ERROR_NONE) {
1504         return status;
1505     }
1506     this.curveTypes[this.numCurves++] = 6;
1507     // assert(x0 == lastX &amp;&amp; y0 == lastY)
1508     this.curves[this.end++] = x1;    this.curves[this.end++] = y1;
1509     this.curves[this.end++] = x0;    this.curves[this.end++] = y0;
1510     return status;
1511 }
1512 
1513 jint PolyStack_pushLine(PolyStack *pStack,
1514                         jfloat x, jfloat y)
1515 {
1516     jint status = ensureSpace(pStack, 2);
1517     if (status != ERROR_NONE) {
1518         return status;
1519     }
1520     this.curveTypes[this.numCurves++] = 4;
1521     // assert(x0 == lastX &amp;&amp; y0 == lastY)
1522     this.curves[this.end++] = x;    this.curves[this.end++] = y;
1523     return status;
1524 }
1525 
1526 //@SuppressWarnings(&quot;unused&quot;)
1527 /*
1528 jint PolyStack_pop(PolyStack *pStack, jfloat pts[]) {
1529     jint ret = this.curveTypes[this.numCurves - 1];
1530     this.numCurves--;
1531     this.end -= (ret - 2);
1532     System_arraycopy(curves, end, pts, 0, ret - 2);
1533     return ret;
1534 }
1535 */
1536 
1537 jint PolyStack_pop(PolyStack *pStack, PathConsumer *io) {
1538     jint status = ERROR_NONE;
1539     jint type;
1540 
1541     this.numCurves--;
1542     type = this.curveTypes[this.numCurves];
1543     this.end -= (type - 2);
1544     switch(type) {
1545     case 8:
1546         status = io-&gt;curveTo(io,
1547                     this.curves[this.end+0], this.curves[this.end+1],
1548                     this.curves[this.end+2], this.curves[this.end+3],
1549                     this.curves[this.end+4], this.curves[this.end+5]);
1550         break;
1551     case 6:
1552         status = io-&gt;quadTo(io,
1553                    this.curves[this.end+0], this.curves[this.end+1],
1554                    this.curves[this.end+2], this.curves[this.end+3]);
1555         break;
1556     case 4:
1557         status = io-&gt;lineTo(io, this.curves[this.end], this.curves[this.end+1]);
1558     }
1559     return status;
1560 }
1561 
1562 //@Override
1563 /*
1564 public String toString() {
1565     String ret = &quot;&quot;;
1566     jint nc = numCurves;
1567     jint last = this.end;
1568     while (nc &gt; 0) {
1569         nc--;
1570         jint type = curveTypes[numCurves];
1571         last -= (type - 2);
1572         switch(type) {
1573         case 8:
1574             ret += &quot;cubic: &quot;;
1575             break;
1576         case 6:
1577             ret += &quot;quad: &quot;;
1578             break;
1579         case 4:
1580             ret += &quot;line: &quot;;
1581             break;
1582         }
1583         ret += Arrays.toString(Arrays.copyOfRange(curves, last, last+type-2)) + &quot;\n&quot;;
1584     }
1585     return ret;
1586 }
1587  */
    </pre>
  </body>
</html>
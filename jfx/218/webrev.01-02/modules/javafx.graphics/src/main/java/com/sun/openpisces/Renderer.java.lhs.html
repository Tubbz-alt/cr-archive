<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/java/com/sun/openpisces/Renderer.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2007, 2016, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.openpisces;
 27 
 28 import com.sun.javafx.geom.PathConsumer2D;
 29 import java.util.Arrays;
 30 
 31 /**
 32  */
 33 public final class Renderer implements PathConsumer2D {
 34 
 35     private final class ScanlineIterator {
 36 
 37         private int[] crossings;
 38         private int[] edgePtrs;
 39         private int edgeCount;
 40 
 41         // crossing bounds. The bounds are not necessarily tight (the scan line
 42         // at minY, for example, might have no crossings). The x bounds will
 43         // be accumulated as crossings are computed.
 44         private int nextY;
 45 
 46         private static final int INIT_CROSSINGS_SIZE = 10;
 47 
 48         private ScanlineIterator() {
 49             crossings = new int[INIT_CROSSINGS_SIZE];
 50             edgePtrs = new int[INIT_CROSSINGS_SIZE];
 51             reset();
 52         }
 53 
 54         public void reset() {
 55             // We don&#39;t care if we clip some of the line off with ceil, since
 56             // no scan line crossings will be eliminated (in fact, the ceil is
 57             // the y of the first scan line crossing).
 58             nextY = sampleRowMin;
 59             edgeCount = 0;
 60         }
 61 
 62         private int next() {
 63             // TODO: make function that convert from y value to bucket idx?
 64             // (RT-26922)
 65             int cury = nextY++;
 66             int bucket = cury - boundsMinY;
 67             int count = this.edgeCount;
 68             int ptrs[] = this.edgePtrs;
 69             float edges[] = Renderer.this.edges;
 70             int bucketcount = edgeBuckets[bucket*2 + 1];
 71             if ((bucketcount &amp; 0x1) != 0) {
 72                 int newCount = 0;
 73                 for (int i = 0; i &lt; count; i++) {
 74                     int ecur = ptrs[i];
 75                     if (edges[ecur+YMAX] &gt; cury) {
 76                         ptrs[newCount++] = ecur;
 77                     }
 78                 }
 79                 count = newCount;
 80             }
 81             ptrs = Helpers.widenArray(ptrs, count, bucketcount &gt;&gt; 1);
 82             for (int ecur = edgeBuckets[bucket*2];
 83                  ecur != 0;
 84                  ecur = (int)edges[ecur+NEXT])
 85             {
 86                 ptrs[count++] = --ecur;
 87                 // REMIND: Adjust start Y if necessary
 88             }
 89             this.edgePtrs = ptrs;
 90             this.edgeCount = count;
 91 //            if ((count &amp; 0x1) != 0) {
 92 //                System.out.println(&quot;ODD NUMBER OF EDGES!!!!&quot;);
 93 //            }
 94             int xings[] = this.crossings;
 95             if (xings.length &lt; count) {
 96                 this.crossings = xings = new int[ptrs.length];
 97             }
 98             for (int i = 0; i &lt; count; i++) {
 99                 int ecur = ptrs[i];
100                 float curx = edges[ecur+CURX];
101                 int cross = ((int) Math.ceil(curx - 0.5f)) &lt;&lt; 1;
102                 edges[ecur+CURX] = curx + edges[ecur+SLOPE];
103                 if (edges[ecur+OR] &gt; 0) {
104                     cross |= 1;
105                 }
106                 int j = i;
107                 while (--j &gt;= 0) {
108                     int jcross = xings[j];
109                     if (jcross &lt;= cross) {
110                         break;
111                     }
112                     xings[j+1] = jcross;
113                     ptrs[j+1] = ptrs[j];
114                 }
115                 xings[j+1] = cross;
116                 ptrs[j+1] = ecur;
117             }
118             return count;
119         }
120 
121         private boolean hasNext() {
122             return nextY &lt; sampleRowMax;
123         }
124 
125         private int curY() {
126             return nextY - 1;
127         }
128     }
129 
130 
131 //////////////////////////////////////////////////////////////////////////////
132 //  EDGE LIST
133 //////////////////////////////////////////////////////////////////////////////
134 // TODO(maybe): very tempting to use fixed point here. A lot of opportunities
135 // for shifts and just removing certain operations altogether. (RT-26922)
136 
137     // common to all types of input path segments.
138     private static final int YMAX = 0;
139     private static final int CURX = 1;
140     // NEXT and OR are meant to be indeces into &quot;int&quot; fields, but arrays must
141     // be homogenous, so every field is a float. However floats can represent
<a name="2" id="anc2"></a><span class="line-modified">142     // exactly up to 26 bit ints, so we&#39;re ok.</span>
143     private static final int OR   = 2;
144     private static final int SLOPE = 3;
145     private static final int NEXT = 4;
146     private static final int SIZEOF_EDGE = 5;
147 
<a name="3" id="anc3"></a>

148     private int sampleRowMin;
149     private int sampleRowMax;
150     private float edgeMinX;
151     private float edgeMaxX;
152 
153     private float[] edges;
154     private int[] edgeBuckets;
155     private int numEdges;
156 
157     private static final float DEC_BND = 1.0f;
158     private static final float INC_BND = 0.4f;
159 
160     // each bucket is a linked list. this method adds eptr to the
161     // start &quot;bucket&quot;th linked list.
162     private void addEdgeToBucket(final int eptr, final int bucket) {
163         // we could implement this in terms of insertEdge, but this is a special
164         // case, so we optimize a bit.
<a name="4" id="anc4"></a>


165         edges[eptr+NEXT] = edgeBuckets[bucket*2];
166         edgeBuckets[bucket*2] = eptr + 1;
167         edgeBuckets[bucket*2 + 1] += 2;
168     }
169 
170     // Flattens using adaptive forward differencing. This only carries out
171     // one iteration of the AFD loop. All it does is update AFD variables (i.e.
172     // X0, Y0, D*[X|Y], COUNT; not variables used for computing scanline crossings).
173     private void quadBreakIntoLinesAndAdd(float x0, float y0,
174                                           final Curve c,
175                                           final float x2, final float y2)
176     {
177         final float QUAD_DEC_BND = 32;
178         final int countlg = 4;
179         int count = 1 &lt;&lt; countlg;
180         int countsq = count * count;
181         float maxDD = Math.max(c.dbx / countsq, c.dby / countsq);
182         while (maxDD &gt; QUAD_DEC_BND) {
183             maxDD /= 4;
184             count &lt;&lt;= 1;
185         }
186 
187         countsq = count * count;
188         final float ddx = c.dbx / countsq;
189         final float ddy = c.dby / countsq;
190         float dx = c.bx / countsq + c.cx / count;
191         float dy = c.by / countsq + c.cy / count;
192 
193         while (count-- &gt; 1) {
194             float x1 = x0 + dx;
195             dx += ddx;
196             float y1 = y0 + dy;
197             dy += ddy;
198             addLine(x0, y0, x1, y1);
199             x0 = x1;
200             y0 = y1;
201         }
202         addLine(x0, y0, x2, y2);
203     }
204 
205     // x0, y0 and x3,y3 are the endpoints of the curve. We could compute these
206     // using c.xat(0),c.yat(0) and c.xat(1),c.yat(1), but this might introduce
207     // numerical errors, and our callers already have the exact values.
208     // Another alternative would be to pass all the control points, and call c.set
209     // here, but then too many numbers are passed around.
210     private void curveBreakIntoLinesAndAdd(float x0, float y0,
211                                            final Curve c,
212                                            final float x3, final float y3)
213     {
214         final int countlg = 3;
215         int count = 1 &lt;&lt; countlg;
216 
217         // the dx and dy refer to forward differencing variables, not the last
218         // coefficients of the &quot;points&quot; polynomial
219         float dddx, dddy, ddx, ddy, dx, dy;
220         dddx = 2f * c.dax / (1 &lt;&lt; (3 * countlg));
221         dddy = 2f * c.day / (1 &lt;&lt; (3 * countlg));
222 
223         ddx = dddx + c.dbx / (1 &lt;&lt; (2 * countlg));
224         ddy = dddy + c.dby / (1 &lt;&lt; (2 * countlg));
225         dx = c.ax / (1 &lt;&lt; (3 * countlg)) + c.bx / (1 &lt;&lt; (2 * countlg)) + c.cx / (1 &lt;&lt; countlg);
226         dy = c.ay / (1 &lt;&lt; (3 * countlg)) + c.by / (1 &lt;&lt; (2 * countlg)) + c.cy / (1 &lt;&lt; countlg);
227 
228         // we use x0, y0 to walk the line
229         float x1 = x0, y1 = y0;
230         while (count &gt; 0) {
231             while (Math.abs(ddx) &gt; DEC_BND || Math.abs(ddy) &gt; DEC_BND) {
232                 dddx /= 8;
233                 dddy /= 8;
234                 ddx = ddx/4 - dddx;
235                 ddy = ddy/4 - dddy;
236                 dx = (dx - ddx) / 2;
237                 dy = (dy - ddy) / 2;
238                 count &lt;&lt;= 1;
239             }
240             // can only do this on even &quot;count&quot; values, because we must divide count by 2
241             while (count % 2 == 0 &amp;&amp; Math.abs(dx) &lt;= INC_BND &amp;&amp; Math.abs(dy) &lt;= INC_BND) {
242                 dx = 2 * dx + ddx;
243                 dy = 2 * dy + ddy;
244                 ddx = 4 * (ddx + dddx);
245                 ddy = 4 * (ddy + dddy);
246                 dddx = 8 * dddx;
247                 dddy = 8 * dddy;
248                 count &gt;&gt;= 1;
249             }
250             count--;
251             if (count &gt; 0) {
252                 x1 += dx;
253                 dx += ddx;
254                 ddx += dddx;
255                 y1 += dy;
256                 dy += ddy;
257                 ddy += dddy;
258             } else {
259                 x1 = x3;
260                 y1 = y3;
261             }
262             addLine(x0, y0, x1, y1);
263             x0 = x1;
264             y0 = y1;
265         }
266     }
267 
268     private void addLine(float x1, float y1, float x2, float y2) {
269         float or = 1; // orientation of the line. 1 if y increases, 0 otherwise.
270         if (y2 &lt; y1) {
271             or = y2; // no need to declare a temp variable. We have or.
272             y2 = y1;
273             y1 = or;
274             or = x2;
275             x2 = x1;
276             x1 = or;
277             or = 0;
278         }
279         final int firstCrossing = Math.max((int) Math.ceil(y1 - 0.5f), boundsMinY);
280         final int lastCrossing = Math.min((int) Math.ceil(y2 - 0.5f), boundsMaxY);
281         if (firstCrossing &gt;= lastCrossing) {
282             return;
283         }
284         if (firstCrossing &lt; sampleRowMin) { sampleRowMin = firstCrossing; }
285         if (lastCrossing &gt; sampleRowMax) { sampleRowMax = lastCrossing; }
286 
287         final float slope = (x2 - x1) / (y2 - y1);
288 
289         if (slope &gt; 0) { // &lt;==&gt; x1 &lt; x2
290             if (x1 &lt; edgeMinX) { edgeMinX = x1; }
291             if (x2 &gt; edgeMaxX) { edgeMaxX = x2; }
292         } else {
293             if (x2 &lt; edgeMinX) { edgeMinX = x2; }
294             if (x1 &gt; edgeMaxX) { edgeMaxX = x1; }
295         }
296 
<a name="5" id="anc5"></a>





297         final int ptr = numEdges * SIZEOF_EDGE;
298         edges = Helpers.widenArray(edges, ptr, SIZEOF_EDGE);
299         numEdges++;
300         edges[ptr+OR] = or;
301         edges[ptr+CURX] = x1 + (firstCrossing + 0.5f - y1) * slope;
302         edges[ptr+SLOPE] = slope;
303         edges[ptr+YMAX] = lastCrossing;
<a name="6" id="anc6"></a><span class="line-removed">304         final int bucketIdx = firstCrossing - boundsMinY;</span>
305         addEdgeToBucket(ptr, bucketIdx);
306         edgeBuckets[(lastCrossing - boundsMinY)*2 + 1] |= 1;
307     }
308 
309 // END EDGE LIST
310 //////////////////////////////////////////////////////////////////////////////
311 
312 
313     public static final int WIND_EVEN_ODD = 0;
314     public static final int WIND_NON_ZERO = 1;
315 
316     // Antialiasing
317     final private int SUBPIXEL_LG_POSITIONS_X;
318     final private int SUBPIXEL_LG_POSITIONS_Y;
319     final private int SUBPIXEL_POSITIONS_X;
320     final private int SUBPIXEL_POSITIONS_Y;
321     final private int SUBPIXEL_MASK_X;
322     final private int SUBPIXEL_MASK_Y;
323     final int MAX_AA_ALPHA;
324 
325     // Bounds of the drawing region, at subpixel precision.
326     private int boundsMinX, boundsMinY, boundsMaxX, boundsMaxY;
327 
328     // Current winding rule
329     private int windingRule;
330 
331     // Current drawing position, i.e., final point of last segment
332     private float x0, y0;
333 
334     // Position of most recent &#39;moveTo&#39; command
335     private float pix_sx0, pix_sy0;
336 
337     public Renderer(int subpixelLgPositionsX, int subpixelLgPositionsY)
338     {
339         this.SUBPIXEL_LG_POSITIONS_X = subpixelLgPositionsX;
340         this.SUBPIXEL_LG_POSITIONS_Y = subpixelLgPositionsY;
341         this.SUBPIXEL_POSITIONS_X = 1 &lt;&lt; (SUBPIXEL_LG_POSITIONS_X);
342         this.SUBPIXEL_POSITIONS_Y = 1 &lt;&lt; (SUBPIXEL_LG_POSITIONS_Y);
343         this.SUBPIXEL_MASK_X = SUBPIXEL_POSITIONS_X - 1;
344         this.SUBPIXEL_MASK_Y = SUBPIXEL_POSITIONS_Y - 1;
345         this.MAX_AA_ALPHA = (SUBPIXEL_POSITIONS_X * SUBPIXEL_POSITIONS_Y);
346     }
347 
348     public Renderer(int subpixelLgPositionsX, int subpixelLgPositionsY,
349             int pix_boundsX, int pix_boundsY,
350             int pix_boundsWidth, int pix_boundsHeight,
351             int windingRule)
352     {
353         this(subpixelLgPositionsX, subpixelLgPositionsY);
354         reset(pix_boundsX, pix_boundsY, pix_boundsWidth, pix_boundsHeight,
355               windingRule);
356     }
357 
358     public void reset(int pix_boundsX, int pix_boundsY,
359                       int pix_boundsWidth, int pix_boundsHeight,
360                       int windingRule)
361     {
362         this.windingRule = windingRule;
363 
364         this.boundsMinX = pix_boundsX * SUBPIXEL_POSITIONS_X;
365         this.boundsMinY = pix_boundsY * SUBPIXEL_POSITIONS_Y;
366         this.boundsMaxX = (pix_boundsX + pix_boundsWidth) * SUBPIXEL_POSITIONS_X;
367         this.boundsMaxY = (pix_boundsY + pix_boundsHeight) * SUBPIXEL_POSITIONS_Y;
368 
369         this.edgeMinX = Float.POSITIVE_INFINITY;
370         this.edgeMaxX = Float.NEGATIVE_INFINITY;
371         this.sampleRowMax = boundsMinY;
372         this.sampleRowMin = boundsMaxY;
373 
374         int numBuckets = boundsMaxY - boundsMinY;
375         if (edgeBuckets == null || edgeBuckets.length &lt; numBuckets*2+2) {
376             // The last 2 entries are ignored and only used to store unused
377             // values for segments ending on the last line of the bounds
378             // so we can avoid having to check the bounds on this array.
379             edgeBuckets = new int[numBuckets*2 + 2];
380         } else {
381             // Only need to fill the first numBuckets*2 entries since the
382             // last 2 entries are write-only for overflow avoidance only.
383             Arrays.fill(edgeBuckets, 0, numBuckets*2, 0);
384         }
385         if (edges == null) {
386             edges = new float[SIZEOF_EDGE * 32];
387         }
388         numEdges = 0;
389         pix_sx0 = pix_sy0 = x0 = y0 = 0f;
390     }
391 
392     private float tosubpixx(float pix_x) {
393         return pix_x * SUBPIXEL_POSITIONS_X;
394     }
395     private float tosubpixy(float pix_y) {
396         return pix_y * SUBPIXEL_POSITIONS_Y;
397     }
398 
399     public void moveTo(float pix_x0, float pix_y0) {
400         closePath();
401         this.pix_sx0 = pix_x0;
402         this.pix_sy0 = pix_y0;
403         this.y0 = tosubpixy(pix_y0);
404         this.x0 = tosubpixx(pix_x0);
405     }
406 
407     public void lineTo(float pix_x1, float pix_y1) {
408         float x1 = tosubpixx(pix_x1);
409         float y1 = tosubpixy(pix_y1);
410         addLine(x0, y0, x1, y1);
411         x0 = x1;
412         y0 = y1;
413     }
414 
415     private Curve c = new Curve();
416     @Override public void curveTo(float x1, float y1,
417                                   float x2, float y2,
418                                   float x3, float y3)
419     {
420         final float xe = tosubpixx(x3);
421         final float ye = tosubpixy(y3);
422         c.set(x0, y0, tosubpixx(x1), tosubpixy(y1), tosubpixx(x2), tosubpixy(y2), xe, ye);
423         curveBreakIntoLinesAndAdd(x0, y0, c, xe, ye);
424         x0 = xe;
425         y0 = ye;
426     }
427 
428     @Override public void quadTo(float x1, float y1, float x2, float y2) {
429         final float xe = tosubpixx(x2);
430         final float ye = tosubpixy(y2);
431         c.set(x0, y0, tosubpixx(x1), tosubpixy(y1), xe, ye);
432         quadBreakIntoLinesAndAdd(x0, y0, c, xe, ye);
433         x0 = xe;
434         y0 = ye;
435     }
436 
437     public void closePath() {
438         // lineTo expects its input in pixel coordinates.
439         lineTo(pix_sx0, pix_sy0);
440     }
441 
442     public void pathDone() {
443         closePath();
444     }
445 
446     private int savedAlpha[];
447     private ScanlineIterator savedIterator;
448     public void produceAlphas(AlphaConsumer ac) {
449         ac.setMaxAlpha(MAX_AA_ALPHA);
450 
451         // Mask to determine the relevant bit of the crossing sum
452         // 0x1 if EVEN_ODD, all bits if NON_ZERO
453         int mask = (windingRule == WIND_EVEN_ODD) ? 0x1 : ~0x0;
454 
455         // add 2 to better deal with the last pixel in a pixel row.
456         int width = ac.getWidth();
457         int alpha[] = savedAlpha;
458         if (alpha == null || alpha.length &lt; width+2) {
459             savedAlpha = alpha = new int[width+2];
460         } else {
461             Arrays.fill(alpha, 0, width+2, 0);
462         }
463 
464         int bboxx0 = ac.getOriginX() &lt;&lt; SUBPIXEL_LG_POSITIONS_X;
465         int bboxx1 = bboxx0 + (width &lt;&lt; SUBPIXEL_LG_POSITIONS_X);
466 
467         // Now we iterate through the scanlines. We must tell emitRow the coord
468         // of the first non-transparent pixel, so we must keep accumulators for
469         // the first and last pixels of the section of the current pixel row
470         // that we will emit.
471         // We also need to accumulate pix_bbox*, but the iterator does it
472         // for us. We will just get the values from it once this loop is done
473         int pix_maxX = bboxx1 &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
474         int pix_minX = bboxx0 &gt;&gt; SUBPIXEL_LG_POSITIONS_Y;
475 
476         int y = boundsMinY; // needs to be declared here so we emit the last row properly.
477         ScanlineIterator it = savedIterator;
478         if (it == null) {
479             savedIterator = it = new ScanlineIterator();
480         } else {
481             it.reset();
482         }
483         for ( ; it.hasNext(); ) {
484             int numCrossings = it.next();
485             int[] crossings = it.crossings;
486             y = it.curY();
487 
488             if (numCrossings &gt; 0) {
489                 int lowx = crossings[0] &gt;&gt; 1;
490                 int highx = crossings[numCrossings - 1] &gt;&gt; 1;
491                 int x0 = Math.max(lowx, bboxx0);
492                 int x1 = Math.min(highx, bboxx1);
493 
494                 pix_minX = Math.min(pix_minX, x0 &gt;&gt; SUBPIXEL_LG_POSITIONS_X);
495                 pix_maxX = Math.max(pix_maxX, x1 &gt;&gt; SUBPIXEL_LG_POSITIONS_X);
496             }
497 
498             int sum = 0;
499             int prev = bboxx0;
500             for (int i = 0; i &lt; numCrossings; i++) {
501                 int curxo = crossings[i];
502                 int curx = curxo &gt;&gt; 1;
503                 int crorientation = ((curxo &amp; 0x1) &lt;&lt; 1) - 1;
504                 if ((sum &amp; mask) != 0) {
505                     int x0 = Math.max(prev, bboxx0);
506                     int x1 = Math.min(curx, bboxx1);
507                     if (x0 &lt; x1) {
508                         x0 -= bboxx0; // turn x0, x1 from coords to indices
509                         x1 -= bboxx0; // in the alpha array.
510 
511                         int pix_x = x0 &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
512                         int pix_xmaxm1 = (x1 - 1) &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
513 
514                         if (pix_x == pix_xmaxm1) {
515                             // Start and end in same pixel
516                             alpha[pix_x] += (x1 - x0);
517                             alpha[pix_x+1] -= (x1 - x0);
518                         } else {
519                             int pix_xmax = x1 &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
520                             alpha[pix_x] += SUBPIXEL_POSITIONS_X - (x0 &amp; SUBPIXEL_MASK_X);
521                             alpha[pix_x+1] += (x0 &amp; SUBPIXEL_MASK_X);
522                             alpha[pix_xmax] -= SUBPIXEL_POSITIONS_X - (x1 &amp; SUBPIXEL_MASK_X);
523                             alpha[pix_xmax+1] -= (x1 &amp; SUBPIXEL_MASK_X);
524                         }
525                     }
526                 }
527                 sum += crorientation;
528                 prev = curx;
529             }
530 
531             // even if this last row had no crossings, alpha will be zeroed
532             // from the last emitRow call. But this doesn&#39;t matter because
533             // maxX &lt; minX, so no row will be emitted to the cache.
534             if ((y &amp; SUBPIXEL_MASK_Y) == SUBPIXEL_MASK_Y) {
535                 ac.setAndClearRelativeAlphas(alpha, y &gt;&gt; SUBPIXEL_LG_POSITIONS_Y,
536                                              pix_minX, pix_maxX);
537                 pix_maxX = bboxx1 &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
538                 pix_minX = bboxx0 &gt;&gt; SUBPIXEL_LG_POSITIONS_Y;
539             }
540         }
541 
542         // Emit final row.
543         // Note, if y is on a MASK row then it was already sent above...
544         if ((y &amp; SUBPIXEL_MASK_Y) &lt; SUBPIXEL_MASK_Y) {
545             ac.setAndClearRelativeAlphas(alpha, y &gt;&gt; SUBPIXEL_LG_POSITIONS_Y,
546                                          pix_minX, pix_maxX);
547         }
548     }
549 
550     public int getSubpixMinX() {
551         int sampleColMin = (int) Math.ceil(edgeMinX - 0.5f);
552         if (sampleColMin &lt; boundsMinX) sampleColMin = boundsMinX;
553         return sampleColMin;
554     }
555 
556     public int getSubpixMaxX() {
557         int sampleColMax = (int) Math.ceil(edgeMaxX - 0.5f);
558         if (sampleColMax &gt; boundsMaxX) sampleColMax = boundsMaxX;
559         return sampleColMax;
560     }
561 
562     public int getSubpixMinY() {
563         return sampleRowMin;
564     }
565 
566     public int getSubpixMaxY() {
567         return sampleRowMax;
568     }
569 
570     public int getOutpixMinX() {
571         return (getSubpixMinX() &gt;&gt; SUBPIXEL_LG_POSITIONS_X);
572     }
573 
574     public int getOutpixMaxX() {
575         return (getSubpixMaxX() + SUBPIXEL_MASK_X) &gt;&gt; SUBPIXEL_LG_POSITIONS_X;
576     }
577 
578     public int getOutpixMinY() {
579         return (sampleRowMin &gt;&gt; SUBPIXEL_LG_POSITIONS_Y);
580     }
581 
582     public int getOutpixMaxY() {
583         return (sampleRowMax + SUBPIXEL_MASK_Y) &gt;&gt; SUBPIXEL_LG_POSITIONS_Y;
584     }
585 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.graphics/src/main/java/com/sun/prism/sw/SWContext.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../j2d/print/J2DPrinter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../scenario/animation/shared/ClipEnvelope.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.graphics/src/main/java/com/sun/prism/sw/SWContext.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.prism.sw;
 27 
 28 import com.sun.javafx.geom.Path2D;
 29 import com.sun.javafx.geom.Rectangle;
 30 import com.sun.javafx.geom.Shape;
 31 import com.sun.javafx.geom.transform.BaseTransform;

 32 import com.sun.marlin.DMarlinRenderer;
 33 import com.sun.marlin.DMarlinRenderingEngine;
 34 import com.sun.marlin.DRendererContext;
 35 import com.sun.marlin.IntArrayCache;
 36 import com.sun.marlin.MarlinAlphaConsumer;
 37 import com.sun.marlin.MarlinConst;
 38 import com.sun.marlin.MarlinRenderer;
 39 import com.sun.marlin.MarlinRenderingEngine;
 40 import com.sun.marlin.RendererContext;
 41 import com.sun.openpisces.Renderer;
 42 import com.sun.pisces.PiscesRenderer;
 43 import com.sun.prism.BasicStroke;
 44 import com.sun.prism.PixelFormat;
 45 import com.sun.prism.ResourceFactory;
 46 import com.sun.prism.Texture;
 47 import com.sun.prism.impl.PrismSettings;
 48 import com.sun.prism.impl.shape.DMarlinPrismUtils;
 49 import com.sun.prism.impl.shape.MarlinPrismUtils;
 50 import com.sun.prism.impl.shape.MaskData;
 51 import com.sun.prism.impl.shape.OpenPiscesPrismUtils;
 52 import com.sun.prism.impl.shape.ShapeUtil;
 53 
 54 import java.lang.ref.SoftReference;
 55 
 56 final class SWContext {
 57 
 58     private final ResourceFactory factory;
 59     private final ShapeRenderer shapeRenderer;
 60     private SoftReference&lt;SWRTTexture&gt; readBackBufferRef;
 61     private SoftReference&lt;SWArgbPreTexture&gt; imagePaintTextureRef;
 62 
 63     interface ShapeRenderer {
 64         void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape);
 65         void dispose();
 66     }
 67 
 68     class NativeShapeRenderer implements ShapeRenderer {
 69         private SoftReference&lt;SWMaskTexture&gt; maskTextureRef;
 70 
 71         public void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape) {
<span class="line-modified"> 72             final MaskData mask = ShapeUtil.rasterizeShape(shape, stroke, clip.toRectBounds(), tr, true, antialiasedShape);</span>
<span class="line-modified"> 73             final SWMaskTexture tex = this.validateMaskTexture(mask.getWidth(), mask.getHeight());</span>
<span class="line-modified"> 74             mask.uploadToTexture(tex, 0, 0, false);</span>
<span class="line-modified"> 75             pr.fillAlphaMask(tex.getDataNoClone(), mask.getOriginX(), mask.getOriginY(),</span>
<span class="line-modified"> 76                              mask.getWidth(), mask.getHeight(), 0, tex.getPhysicalWidth());</span>








 77         }
 78 
 79         private SWMaskTexture initMaskTexture(int width, int height) {
 80             final SWMaskTexture tex = (SWMaskTexture)factory.createMaskTexture(width, height, Texture.WrapMode.CLAMP_NOT_NEEDED);
 81             maskTextureRef = new SoftReference&lt;SWMaskTexture&gt;(tex);
 82             return tex;
 83         }
 84 
 85         private void disposeMaskTexture() {
 86             if (maskTextureRef != null){
 87                 maskTextureRef.clear();
 88                 maskTextureRef = null;
 89             }
 90         }
 91 
 92         private SWMaskTexture validateMaskTexture(int width, int height) {
 93             SWMaskTexture tex;
 94             if (maskTextureRef == null) {
 95                 tex = this.initMaskTexture(width, height);
 96             } else {
</pre>
<hr />
<pre>
108 
109         public void dispose() {
110             this.disposeMaskTexture();
111         }
112     }
113 
114     static final class JavaShapeRenderer implements ShapeRenderer {
115         private final DirectRTPiscesAlphaConsumer alphaConsumer = new DirectRTPiscesAlphaConsumer();
116 
117         public void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape) {
118             if (stroke != null &amp;&amp; stroke.getType() != BasicStroke.TYPE_CENTERED) {
119                 // RT-27427
120                 // TODO: Optimize the combinatorial strokes for simple
121                 // shapes and/or teach the rasterizer to be able to
122                 // do a &quot;differential fill&quot; between two shapes.
123                 // Note that most simple shapes will use a more optimized path
124                 // than this method for the INNER/OUTER strokes anyway.
125                 shape = stroke.createStrokedShape(shape);
126                 stroke = null;
127             }
<span class="line-modified">128             final Renderer r = OpenPiscesPrismUtils.setupRenderer(shape, stroke, tr, clip, antialiasedShape);</span>
<span class="line-modified">129             alphaConsumer.initConsumer(r, pr);</span>
<span class="line-modified">130             r.produceAlphas(alphaConsumer);</span>








131         }
132 
133         public void dispose() { }
134     }
135 
136     static final class MarlinShapeRenderer implements ShapeRenderer {
137         private final DirectRTMarlinAlphaConsumer alphaConsumer = new DirectRTMarlinAlphaConsumer();
138 
139         @Override
140         public void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape) {
141             if (stroke != null &amp;&amp; stroke.getType() != BasicStroke.TYPE_CENTERED) {
142                 // RT-27427
143                 // TODO: Optimize the combinatorial strokes for simple
144                 // shapes and/or teach the rasterizer to be able to
145                 // do a &quot;differential fill&quot; between two shapes.
146                 // Note that most simple shapes will use a more optimized path
147                 // than this method for the INNER/OUTER strokes anyway.
148                 shape = stroke.createStrokedShape(shape);
149                 stroke = null;
150             }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.prism.sw;
 27 
 28 import com.sun.javafx.geom.Path2D;
 29 import com.sun.javafx.geom.Rectangle;
 30 import com.sun.javafx.geom.Shape;
 31 import com.sun.javafx.geom.transform.BaseTransform;
<span class="line-added"> 32 import com.sun.javafx.util.Logging;</span>
 33 import com.sun.marlin.DMarlinRenderer;
 34 import com.sun.marlin.DMarlinRenderingEngine;
 35 import com.sun.marlin.DRendererContext;
 36 import com.sun.marlin.IntArrayCache;
 37 import com.sun.marlin.MarlinAlphaConsumer;
 38 import com.sun.marlin.MarlinConst;
 39 import com.sun.marlin.MarlinRenderer;
 40 import com.sun.marlin.MarlinRenderingEngine;
 41 import com.sun.marlin.RendererContext;
 42 import com.sun.openpisces.Renderer;
 43 import com.sun.pisces.PiscesRenderer;
 44 import com.sun.prism.BasicStroke;
 45 import com.sun.prism.PixelFormat;
 46 import com.sun.prism.ResourceFactory;
 47 import com.sun.prism.Texture;
 48 import com.sun.prism.impl.PrismSettings;
 49 import com.sun.prism.impl.shape.DMarlinPrismUtils;
 50 import com.sun.prism.impl.shape.MarlinPrismUtils;
 51 import com.sun.prism.impl.shape.MaskData;
 52 import com.sun.prism.impl.shape.OpenPiscesPrismUtils;
 53 import com.sun.prism.impl.shape.ShapeUtil;
 54 
 55 import java.lang.ref.SoftReference;
 56 
 57 final class SWContext {
 58 
 59     private final ResourceFactory factory;
 60     private final ShapeRenderer shapeRenderer;
 61     private SoftReference&lt;SWRTTexture&gt; readBackBufferRef;
 62     private SoftReference&lt;SWArgbPreTexture&gt; imagePaintTextureRef;
 63 
 64     interface ShapeRenderer {
 65         void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape);
 66         void dispose();
 67     }
 68 
 69     class NativeShapeRenderer implements ShapeRenderer {
 70         private SoftReference&lt;SWMaskTexture&gt; maskTextureRef;
 71 
 72         public void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape) {
<span class="line-modified"> 73             try {</span>
<span class="line-modified"> 74                 final MaskData mask = ShapeUtil.rasterizeShape(shape, stroke, clip.toRectBounds(), tr, true, antialiasedShape);</span>
<span class="line-modified"> 75                 final SWMaskTexture tex = this.validateMaskTexture(mask.getWidth(), mask.getHeight());</span>
<span class="line-modified"> 76                 mask.uploadToTexture(tex, 0, 0, false);</span>
<span class="line-modified"> 77                 pr.fillAlphaMask(tex.getDataNoClone(), mask.getOriginX(), mask.getOriginY(),</span>
<span class="line-added"> 78                                  mask.getWidth(), mask.getHeight(), 0, tex.getPhysicalWidth());</span>
<span class="line-added"> 79             } catch (Throwable ex) {</span>
<span class="line-added"> 80                 if (PrismSettings.verbose) {</span>
<span class="line-added"> 81                     ex.printStackTrace();</span>
<span class="line-added"> 82                 }</span>
<span class="line-added"> 83                 Logging.getJavaFXLogger().warning(&quot;Cannot rasterize Shape: &quot;</span>
<span class="line-added"> 84                         + ex.toString());</span>
<span class="line-added"> 85             }</span>
 86         }
 87 
 88         private SWMaskTexture initMaskTexture(int width, int height) {
 89             final SWMaskTexture tex = (SWMaskTexture)factory.createMaskTexture(width, height, Texture.WrapMode.CLAMP_NOT_NEEDED);
 90             maskTextureRef = new SoftReference&lt;SWMaskTexture&gt;(tex);
 91             return tex;
 92         }
 93 
 94         private void disposeMaskTexture() {
 95             if (maskTextureRef != null){
 96                 maskTextureRef.clear();
 97                 maskTextureRef = null;
 98             }
 99         }
100 
101         private SWMaskTexture validateMaskTexture(int width, int height) {
102             SWMaskTexture tex;
103             if (maskTextureRef == null) {
104                 tex = this.initMaskTexture(width, height);
105             } else {
</pre>
<hr />
<pre>
117 
118         public void dispose() {
119             this.disposeMaskTexture();
120         }
121     }
122 
123     static final class JavaShapeRenderer implements ShapeRenderer {
124         private final DirectRTPiscesAlphaConsumer alphaConsumer = new DirectRTPiscesAlphaConsumer();
125 
126         public void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape) {
127             if (stroke != null &amp;&amp; stroke.getType() != BasicStroke.TYPE_CENTERED) {
128                 // RT-27427
129                 // TODO: Optimize the combinatorial strokes for simple
130                 // shapes and/or teach the rasterizer to be able to
131                 // do a &quot;differential fill&quot; between two shapes.
132                 // Note that most simple shapes will use a more optimized path
133                 // than this method for the INNER/OUTER strokes anyway.
134                 shape = stroke.createStrokedShape(shape);
135                 stroke = null;
136             }
<span class="line-modified">137             try {</span>
<span class="line-modified">138                 final Renderer r = OpenPiscesPrismUtils.setupRenderer(shape, stroke, tr, clip, antialiasedShape);</span>
<span class="line-modified">139                 alphaConsumer.initConsumer(r, pr);</span>
<span class="line-added">140                 r.produceAlphas(alphaConsumer);</span>
<span class="line-added">141             } catch (Throwable ex) {</span>
<span class="line-added">142                 if (PrismSettings.verbose) {</span>
<span class="line-added">143                     ex.printStackTrace();</span>
<span class="line-added">144                 }</span>
<span class="line-added">145                 Logging.getJavaFXLogger().warning(&quot;Cannot rasterize Shape: &quot;</span>
<span class="line-added">146                         + ex.toString());</span>
<span class="line-added">147             }</span>
148         }
149 
150         public void dispose() { }
151     }
152 
153     static final class MarlinShapeRenderer implements ShapeRenderer {
154         private final DirectRTMarlinAlphaConsumer alphaConsumer = new DirectRTMarlinAlphaConsumer();
155 
156         @Override
157         public void renderShape(PiscesRenderer pr, Shape shape, BasicStroke stroke, BaseTransform tr, Rectangle clip, boolean antialiasedShape) {
158             if (stroke != null &amp;&amp; stroke.getType() != BasicStroke.TYPE_CENTERED) {
159                 // RT-27427
160                 // TODO: Optimize the combinatorial strokes for simple
161                 // shapes and/or teach the rasterizer to be able to
162                 // do a &quot;differential fill&quot; between two shapes.
163                 // Note that most simple shapes will use a more optimized path
164                 // than this method for the INNER/OUTER strokes anyway.
165                 shape = stroke.createStrokedShape(shape);
166                 stroke = null;
167             }
</pre>
</td>
</tr>
</table>
<center><a href="../j2d/print/J2DPrinter.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../scenario/animation/shared/ClipEnvelope.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
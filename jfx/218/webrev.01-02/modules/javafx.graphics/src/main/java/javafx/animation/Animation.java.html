<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.graphics/src/main/java/javafx/animation/Animation.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2010, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package javafx.animation;
  27 
  28 import java.util.Objects;
  29 
  30 import com.sun.javafx.tk.Toolkit;
  31 import com.sun.javafx.util.Utils;
  32 
  33 import javafx.beans.property.BooleanProperty;
  34 import javafx.beans.property.BooleanPropertyBase;
  35 import javafx.beans.property.DoubleProperty;
  36 import javafx.beans.property.DoublePropertyBase;
  37 import javafx.beans.property.IntegerProperty;
  38 import javafx.beans.property.IntegerPropertyBase;
  39 import javafx.beans.property.ObjectProperty;
  40 import javafx.beans.property.ObjectPropertyBase;
  41 import javafx.beans.property.ReadOnlyDoubleProperty;
  42 import javafx.beans.property.ReadOnlyDoublePropertyBase;
  43 import javafx.beans.property.ReadOnlyObjectProperty;
  44 import javafx.beans.property.ReadOnlyObjectPropertyBase;
  45 import javafx.collections.FXCollections;
  46 import javafx.collections.ObservableMap;
  47 import javafx.event.ActionEvent;
  48 import javafx.event.EventHandler;
  49 import javafx.util.Duration;
  50 import com.sun.javafx.animation.TickCalculation;
  51 import com.sun.scenario.animation.AbstractMasterTimer;
  52 import com.sun.scenario.animation.shared.ClipEnvelope;
  53 import com.sun.scenario.animation.shared.PulseReceiver;
  54 
  55 import java.security.AccessControlContext;
  56 import java.security.AccessController;
  57 import java.security.PrivilegedAction;
  58 
  59 /**
  60  * The class {@code Animation} provides the core functionality of all animations
  61  * used in the JavaFX runtime.
  62  * &lt;p&gt;
  63  * An animation can run in a loop by setting {@link #cycleCountProperty() cycleCount}.
  64  * To make an animation run back and forth while looping, set the
  65  * {@link #autoReverseProperty() autoReverse} -flag.
  66  * &lt;p&gt;
  67  * Call {@link #play()} or {@link #playFromStart()} to play an {@code Animation}
  68  * . The {@code Animation} progresses in the direction and speed specified by
  69  * {@link #rateProperty() rate}, and stops when its duration is elapsed. An {@code Animation}
  70  * with indefinite duration (a {@link #cycleCountProperty() cycleCount} of {@link #INDEFINITE}) runs
  71  * repeatedly until the {@link #stop()} method is explicitly called, which will
  72  * stop the running {@code Animation} and reset its play head to the initial
  73  * position.
  74  * &lt;p&gt;
  75  * An {@code Animation} can be paused by calling {@link #pause()}, and the next
  76  * {@link #play()} call will resume the {@code Animation} from where it was
  77  * paused.
  78  * &lt;p&gt;
  79  * An {@code Animation}&#39;s play head can be randomly positioned, whether it is
  80  * running or not. If the {@code Animation} is running, the play head jumps to
  81  * the specified position immediately and continues playing from new position.
  82  * If the {@code Animation} is not running, the next {@link #play()} will start
  83  * the {@code Animation} from the specified position.
  84  * &lt;p&gt;
  85  * Inverting the value of {@link #rateProperty() rate} toggles the play direction.
  86  *
  87  * @see Timeline
  88  * @see Transition
  89  *
  90  * @since JavaFX 2.0
  91  */
  92 public abstract class Animation {
  93 
  94     static {
  95         AnimationAccessorImpl.DEFAULT = new AnimationAccessorImpl();
  96     }
  97 
  98     /**
  99      * Used as a  value for {@link #cycleCountProperty() cycleCount} to specify an animation that repeats indefinitely,
 100      * until the {@code stop()} method is called.
 101      */
 102     public static final int INDEFINITE = -1;
 103 
 104     /**
 105      * The possible states for {@link Animation#statusProperty() status}.
 106      * @since JavaFX 2.0
 107      */
 108     public static enum Status {
 109         /**
 110          * The paused state.
 111          */
 112         PAUSED,
 113         /**
 114          * The running state.
 115          */
 116         RUNNING,
 117         /**
 118          * The stopped state.
 119          */
 120         STOPPED
 121     }
 122 
 123     private static final double EPSILON = 1e-12;
 124 
 125     /**
 126      * Checks if the rate is effectively 0.
 127      * @param rate
 128      * @return true i.f.f. abs(rate) &lt; EPSILON
 129      */
 130     static final boolean isNearZero(double rate) {
 131         return Math.abs(rate) &lt; EPSILON;
 132     }
 133 
 134     /**
 135      * Checks if 2 rates are effectively equal.
 136      * @param rateMagnitude
 137      * @return true i.f.f. Math.abs(rate1 - rate2) &lt; EPSILON
 138      */
 139     private static boolean areNearEqual(double rate1, double rate2) {
 140         return isNearZero(rate2 - rate1);
 141     }
 142 
 143     /*
 144         These four fields and associated methods were moved here from AnimationPulseReceiver
 145         when that class was removed. They could probably be integrated much cleaner into Animation,
 146         but to make sure the change was made without introducing regressions, this code was
 147         moved pretty much verbatim.
 148      */
 149     private long startTime;
 150     private long pauseTime;
 151     private boolean paused = false;
 152     private final AbstractMasterTimer timer;
 153 
 154     // Access control context, captured whenever we add this pulse receiver to
 155     // the master timer (which is called when an animation is played or resumed)
 156     private AccessControlContext accessCtrlCtx = null;
 157 
 158     private long now() {
 159         return TickCalculation.fromNano(timer.nanos());
 160     }
 161 
 162     private void addPulseReceiver() {
 163         // Capture the Access Control Context to be used during the animation pulse
 164         accessCtrlCtx = AccessController.getContext();
 165 
 166         timer.addPulseReceiver(pulseReceiver);
 167     }
 168 
 169     void startReceiver(long delay) {
 170         paused = false;
 171         startTime = now() + delay;
 172         addPulseReceiver();
 173     }
 174 
 175     void pauseReceiver() {
 176         if (!paused) {
 177             pauseTime = now();
 178             paused = true;
 179             timer.removePulseReceiver(pulseReceiver);
 180         }
 181     }
 182 
 183     void resumeReceiver() {
 184         if (paused) {
 185             final long deltaTime = now() - pauseTime;
 186             startTime += deltaTime;
 187             paused = false;
 188             addPulseReceiver();
 189         }
 190     }
 191 
 192     // package private only for the sake of testing
 193     final PulseReceiver pulseReceiver = new PulseReceiver() {
 194         @Override public void timePulse(long now) {
 195             final long elapsedTime = now - startTime;
 196             if (elapsedTime &lt; 0) {
 197                 return;
 198             }
 199             if (accessCtrlCtx == null) {
 200                 throw new IllegalStateException(&quot;Error: AccessControlContext not captured&quot;);
 201             }
 202 
 203             AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 204                 doTimePulse(elapsedTime);
 205                 return null;
 206             }, accessCtrlCtx);
 207         }
 208     };
 209 
 210     private class CurrentRateProperty extends ReadOnlyDoublePropertyBase {
 211         private double value;
 212 
 213         @Override
 214         public Object getBean() {
 215             return Animation.this;
 216         }
 217 
 218         @Override
 219         public String getName() {
 220             return &quot;currentRate&quot;;
 221         }
 222 
 223         @Override
 224         public double get() {
 225             return value;
 226         }
 227 
 228         private void set(double value) {
 229             this.value = value;
 230             fireValueChangedEvent();
 231         }
 232     }
 233 
 234     private class AnimationReadOnlyProperty&lt;T&gt; extends ReadOnlyObjectPropertyBase&lt;T&gt; {
 235 
 236         private final String name;
 237         private T value;
 238 
 239         private AnimationReadOnlyProperty(String name, T value) {
 240             this.name = name;
 241             this.value = value;
 242         }
 243 
 244         @Override
 245         public Object getBean() {
 246             return Animation.this;
 247         }
 248 
 249         @Override
 250         public String getName() {
 251             return name;
 252         }
 253 
 254         @Override
 255         public T get() {
 256             return value;
 257         }
 258 
 259         private void set(T value) {
 260             this.value = value;
 261             fireValueChangedEvent();
 262         }
 263     }
 264 
 265     /**
 266      * The parent of this {@code Animation}. If this animation has not been
 267      * added to another animation, such as {@link ParallelTransition} and
 268      * {@link SequentialTransition}, then parent will be null.
 269      *
 270      * @defaultValue null
 271      */
 272     Animation parent = null;
 273 
 274     /**
 275      * The type of ClipEnvelope for the animation is determined by its cycleCount and cycleDuration
 276      * and is updated when these values change.
 277      * &lt;p&gt;
 278      * Package-private for testing purposes
 279     */
 280     ClipEnvelope clipEnvelope;
 281 
 282     private boolean lastPlayedFinished = true;
 283 
 284     private boolean lastPlayedForward = true;
 285     /**
 286      * Defines the direction/speed at which the {@code Animation} is expected to
 287      * be played.
 288      * &lt;p&gt;
 289      * The absolute value of {@code rate} indicates the speed at which the
 290      * {@code Animation} is to be played, while the sign of {@code rate}
 291      * indicates the direction. A positive value of {@code rate} indicates
 292      * forward play, a negative value indicates backward play and {@code 0.0} to
 293      * stop a running {@code Animation}.
 294      * &lt;p&gt;
 295      * Rate {@code 1.0} is normal play, {@code 2.0} is 2 time normal,
 296      * {@code -1.0} is backwards, etc.
 297      *
 298      * &lt;p&gt;
 299      * Inverting the rate of a running {@code Animation} will cause the
 300      * {@code Animation} to reverse direction in place and play back over the
 301      * portion of the {@code Animation} that has already elapsed.
 302      *
 303      * @defaultValue 1.0
 304      */
 305     private DoubleProperty rate;
 306     private static final double DEFAULT_RATE = 1.0;
 307 
 308     public final void setRate(double value) {
 309         if (rate != null || !areNearEqual(value, DEFAULT_RATE)) {
 310             rateProperty().set(value);
 311         }
 312     }
 313 
 314     public final double getRate() {
 315         return (rate == null)? DEFAULT_RATE : rate.get();
 316     }
 317 
 318     public final DoubleProperty rateProperty() {
 319         if (rate == null) {
 320             rate = new DoublePropertyBase(DEFAULT_RATE) {
 321 
 322                 @Override
 323                 public void invalidated() {
 324                     final double newRate = getRate();
 325                     if (isRunningEmbedded()) {
 326                         if (isBound()) {
 327                             unbind();
 328                         }
 329                         set(oldRate);
 330                         throw new IllegalArgumentException(&quot;Cannot set rate of embedded animation while running.&quot;);
 331                     }
 332                     if (isNearZero(newRate)) {
 333                         if (isRunning()) {
 334                             lastPlayedForward = areNearEqual(getCurrentRate(), oldRate);
 335                         }
 336                         doSetCurrentRate(0.0);
 337                         pauseReceiver();
 338                     } else {
 339                         if (isRunning()) {
 340                             final double currentRate = getCurrentRate();
 341                             if (isNearZero(currentRate)) {
 342                                 doSetCurrentRate(lastPlayedForward ? newRate : -newRate);
 343                                 resumeReceiver();
 344                             } else {
 345                                 final boolean playingForward = areNearEqual(currentRate, oldRate);
 346                                 doSetCurrentRate(playingForward ? newRate : -newRate);
 347                             }
 348                         }
 349                         oldRate = newRate;
 350                     }
 351                     clipEnvelope.setRate(newRate);
 352                 }
 353 
 354                 @Override
 355                 public Object getBean() {
 356                     return Animation.this;
 357                 }
 358 
 359                 @Override
 360                 public String getName() {
 361                     return &quot;rate&quot;;
 362                 }
 363             };
 364         }
 365         return rate;
 366     }
 367 
 368     private boolean isRunningEmbedded() {
 369         if (parent == null) {
 370             return false;
 371         }
 372         return !parent.isStopped() || parent.isRunningEmbedded();
 373     }
 374 
 375     private double oldRate = 1.0;
 376     /**
 377      * Read-only variable to indicate current direction/speed at which the
 378      * {@code Animation} is being played.
 379      * &lt;p&gt;
 380      * {@code currentRate} is not necessarily equal to {@code rate}.
 381      * {@code currentRate} is set to {@code 0.0} when animation is paused or
 382      * stopped. {@code currentRate} may also point in the opposite direction of {@code rate} during
 383      * reverse cycles when {@code autoReverse} is {@code true}.
 384      *
 385      * @defaultValue 0.0
 386      */
 387     private ReadOnlyDoubleProperty currentRate;
 388     private static final double DEFAULT_CURRENT_RATE = 0.0;
 389 
 390     public final double getCurrentRate() {
 391         return (currentRate == null) ? DEFAULT_CURRENT_RATE : currentRate.get();
 392     }
 393 
 394     public final ReadOnlyDoubleProperty currentRateProperty() {
 395         if (currentRate == null) {
 396             currentRate = new CurrentRateProperty();
 397         }
 398         return currentRate;
 399     }
 400 
 401     void setCurrentRate(double currentRate) {
 402 //      if (getStatus() == Status.RUNNING) {
 403           doSetCurrentRate(currentRate);
 404 //      }
 405   }
 406 
 407     /**
 408      * The current rate changes in 3 cases:
 409      * &lt;ol&gt;
 410      * &lt;li&gt; When the rate is changed.
 411      * &lt;li&gt; When the status is changed (paused/stopped/resumed/started).
 412      * &lt;li&gt; When switching between a forwards and backwards cycle.
 413      * &lt;/ol&gt;
 414      *
 415      * 1 happens when the user changes the rate of the animation or its root parent.
 416      * 2 happens when the user changes the status or when the animation is finished.
 417      * 3 happens when the clip envelope flips the rate when the cycle is alternated, through the accessor
 418      *
 419      * @param value the value of the new current rate
 420      */
 421     private void doSetCurrentRate(double value) {
 422         if (currentRate != null || !areNearEqual(value, DEFAULT_CURRENT_RATE)) {
 423             ((CurrentRateProperty) currentRateProperty()).set(value);
 424         }
 425     }
 426 
 427     /**
 428      * Read-only variable to indicate the duration of one cycle of this
 429      * {@code Animation}: the time it takes to play from time 0 to the
 430      * end of the Animation (at the default {@code rate} of
 431      * 1.0).
 432      *
 433      * @defaultValue 0ms
 434      */
 435     private ReadOnlyObjectProperty&lt;Duration&gt; cycleDuration;
 436     private static final Duration DEFAULT_CYCLE_DURATION = Duration.ZERO;
 437 
 438     protected final void setCycleDuration(Duration value) {
 439         if (cycleDuration != null || !DEFAULT_CYCLE_DURATION.equals(value)) {
 440             if (value.lessThan(Duration.ZERO)) {
 441                 throw new IllegalArgumentException(&quot;Cycle duration cannot be negative&quot;);
 442             }
 443             ((AnimationReadOnlyProperty&lt;Duration&gt;) cycleDurationProperty()).set(value);
 444             updateTotalDuration();
 445         }
 446     }
 447 
 448     public final Duration getCycleDuration() {
 449         return (cycleDuration == null) ? DEFAULT_CYCLE_DURATION : cycleDuration.get();
 450     }
 451 
 452     public final ReadOnlyObjectProperty&lt;Duration&gt; cycleDurationProperty() {
 453         if (cycleDuration == null) {
 454             cycleDuration = new AnimationReadOnlyProperty&lt;&gt;(&quot;cycleDuration&quot;, DEFAULT_CYCLE_DURATION);
 455         }
 456         return cycleDuration;
 457     }
 458 
 459     /**
 460      * Read-only variable to indicate the total duration of this
 461      * {@code Animation}, including repeats. An {@code Animation} with a {@code cycleCount}
 462      * of {@code Animation.INDEFINITE} will have a {@code totalDuration} of
 463      * {@code Duration.INDEFINITE}.
 464      *
 465      * &lt;p&gt;
 466      * This is set to cycleDuration * cycleCount.
 467      *
 468      * @defaultValue 0ms
 469      */
 470     private ReadOnlyObjectProperty&lt;Duration&gt; totalDuration;
 471     private static final Duration DEFAULT_TOTAL_DURATION = Duration.ZERO;
 472 
 473     public final Duration getTotalDuration() {
 474         return (totalDuration == null) ? DEFAULT_TOTAL_DURATION : totalDuration.get();
 475     }
 476 
 477     public final ReadOnlyObjectProperty&lt;Duration&gt; totalDurationProperty() {
 478         if (totalDuration == null) {
 479             totalDuration = new AnimationReadOnlyProperty&lt;&gt;(&quot;totalDuration&quot;, DEFAULT_TOTAL_DURATION);
 480         }
 481         return totalDuration;
 482     }
 483 
 484     private void updateTotalDuration() {
 485         // Implementing the bind eagerly, because cycleCount and
 486         // cycleDuration should not change that often
 487         final int cycleCount = getCycleCount();
 488         final Duration cycleDuration = getCycleDuration();
 489         final Duration newTotalDuration;
 490         if (Duration.ZERO.equals(cycleDuration)) newTotalDuration = Duration.ZERO;
 491         else if (cycleCount == INDEFINITE) newTotalDuration = Duration.INDEFINITE;
 492         else if (cycleCount &lt;= 1) newTotalDuration = cycleDuration;
 493         else newTotalDuration = cycleDuration.multiply(cycleCount);
 494         if (totalDuration != null || !DEFAULT_TOTAL_DURATION.equals(newTotalDuration)) {
 495             ((AnimationReadOnlyProperty&lt;Duration&gt;) totalDurationProperty()).set(newTotalDuration);
 496         }
 497         if (isStopped()) {
 498             syncClipEnvelope();
 499             if (newTotalDuration.lessThan(getCurrentTime())) {
 500                 clipEnvelope.jumpTo(TickCalculation.fromDuration(newTotalDuration));
 501             }
 502         }
 503     }
 504 
 505     /**
 506      * Defines the {@code Animation}&#39;s play head position.
 507      *
 508      * @defaultValue 0ms
 509      */
 510     private CurrentTimeProperty currentTime;
 511     private long currentTicks;
 512     private class CurrentTimeProperty extends ReadOnlyObjectPropertyBase&lt;Duration&gt; {
 513 
 514         @Override
 515         public Object getBean() {
 516             return Animation.this;
 517         }
 518 
 519         @Override
 520         public String getName() {
 521             return &quot;currentTime&quot;;
 522         }
 523 
 524         @Override
 525         public Duration get() {
 526             return getCurrentTime();
 527         }
 528 
 529         @Override
 530         public void fireValueChangedEvent() {
 531             super.fireValueChangedEvent();
 532         }
 533 
 534     }
 535 
 536     public final Duration getCurrentTime() {
 537         return TickCalculation.toDuration(currentTicks);
 538     }
 539 
 540     public final ReadOnlyObjectProperty&lt;Duration&gt; currentTimeProperty() {
 541         if (currentTime == null) {
 542             currentTime = new CurrentTimeProperty();
 543         }
 544         return currentTime;
 545     }
 546 
 547     /**
 548      * Delays the start of an animation.
 549      *
 550      * Cannot be negative. Setting to a negative number will result in {@link IllegalArgumentException}.
 551      *
 552      * @defaultValue 0ms
 553      */
 554     private ObjectProperty&lt;Duration&gt; delay;
 555     private static final Duration DEFAULT_DELAY = Duration.ZERO;
 556 
 557     public final void setDelay(Duration value) {
 558         if (delay != null || !DEFAULT_DELAY.equals(value)) {
 559             delayProperty().set(value);
 560         }
 561     }
 562 
 563     public final Duration getDelay() {
 564         return (delay == null) ? DEFAULT_DELAY : delay.get();
 565     }
 566 
 567     public final ObjectProperty&lt;Duration&gt; delayProperty() {
 568         if (delay == null) {
 569             delay = new ObjectPropertyBase&lt;&gt;(DEFAULT_DELAY) {
 570 
 571                 @Override
 572                 protected void invalidated() {
 573                     final Duration newDuration = get();
 574                     if (newDuration.lessThan(Duration.ZERO)) {
 575                         if (isBound()) {
 576                             unbind();
 577                         }
 578                         set(Duration.ZERO);
 579                         throw new IllegalArgumentException(&quot;Cannot set delay to negative value. Setting to Duration.ZERO&quot;);
 580                     }
 581                 }
 582 
 583                 @Override
 584                 public Object getBean() {
 585                     return Animation.this;
 586                 }
 587 
 588                 @Override
 589                 public String getName() {
 590                     return &quot;delay&quot;;
 591                 }
 592             };
 593         }
 594         return delay;
 595     }
 596 
 597     /**
 598      * Defines the number of cycles in this animation. The {@code cycleCount}
 599      * may be {@code INDEFINITE} for animations that repeat indefinitely, but
 600      * must otherwise be {@literal &gt;} 0.
 601      * &lt;p&gt;
 602      * It is not possible to change the {@code cycleCount} of a running
 603      * {@code Animation}. If the value of {@code cycleCount} is changed for a
 604      * running {@code Animation}, the animation has to be stopped and started again to pick
 605      * up the new value.
 606      *
 607      * @defaultValue 1
 608      */
 609     private IntegerProperty cycleCount;
 610     private static final int DEFAULT_CYCLE_COUNT = 1;
 611 
 612     public final void setCycleCount(int value) {
 613         if (cycleCount != null || value != DEFAULT_CYCLE_COUNT) {
 614             cycleCountProperty().set(value);
 615         }
 616     }
 617 
 618     public final int getCycleCount() {
 619         return (cycleCount == null) ? DEFAULT_CYCLE_COUNT : cycleCount.get();
 620     }
 621 
 622     public final IntegerProperty cycleCountProperty() {
 623         if (cycleCount == null) {
 624             cycleCount = new IntegerPropertyBase(DEFAULT_CYCLE_COUNT) {
 625 
 626                 @Override
 627                 public void invalidated() {
 628                     updateTotalDuration();
 629                 }
 630 
 631                 @Override
 632                 public Object getBean() {
 633                     return Animation.this;
 634                 }
 635 
 636                 @Override
 637                 public String getName() {
 638                     return &quot;cycleCount&quot;;
 639                 }
 640             };
 641         }
 642         return cycleCount;
 643     }
 644 
 645     /**
 646      * Defines whether this
 647      * {@code Animation} reverses direction on alternating cycles. If
 648      * {@code true}, the
 649      * {@code Animation} will proceed forward on the first cycle,
 650      * then reverses on the second cycle, and so on. Otherwise, animation will
 651      * loop such that each cycle proceeds forward from the start.
 652      *
 653      * It is not possible to change the {@code autoReverse} flag of a running
 654      * {@code Animation}. If the value of {@code autoReverse} is changed for a
 655      * running {@code Animation}, the animation has to be stopped and started again to pick
 656      * up the new value.
 657      *
 658      * @defaultValue false
 659      */
 660     private BooleanProperty autoReverse;
 661     private static final boolean DEFAULT_AUTO_REVERSE = false;
 662 
 663     public final void setAutoReverse(boolean value) {
 664         if (autoReverse != null || value != DEFAULT_AUTO_REVERSE) {
 665             autoReverseProperty().set(value);
 666         }
 667     }
 668 
 669     public final boolean isAutoReverse() {
 670         return (autoReverse == null) ? DEFAULT_AUTO_REVERSE : autoReverse.get();
 671     }
 672 
 673     public final BooleanProperty autoReverseProperty() {
 674         if (autoReverse == null) {
 675             autoReverse = new BooleanPropertyBase(DEFAULT_AUTO_REVERSE) {
 676 
 677                 @Override
 678                 public Object getBean() {
 679                     return Animation.this;
 680                 }
 681 
 682                 @Override
 683                 public String getName() {
 684                     return &quot;autoReverse&quot;;
 685                 }
 686             };
 687         }
 688         return autoReverse;
 689     }
 690 
 691     /**
 692      * The status of the {@code Animation}.
 693      *
 694      * An {@code Animation} can be in one of three states:
 695      * {@link Status#STOPPED}, {@link Status#PAUSED} or {@link Status#RUNNING}.
 696      */
 697     private ReadOnlyObjectProperty&lt;Status&gt; status;
 698     private static final Status DEFAULT_STATUS = Status.STOPPED;
 699 
 700     protected final void setStatus(Status value) {
 701         if (status != null || !DEFAULT_STATUS.equals(value)) {
 702             ((AnimationReadOnlyProperty&lt;Status&gt;) statusProperty()).set(value);
 703         }
 704     }
 705 
 706     public final Status getStatus() {
 707         return (status == null) ? DEFAULT_STATUS : status.get();
 708     }
 709 
 710     public final ReadOnlyObjectProperty&lt;Status&gt; statusProperty() {
 711         if (status == null) {
 712             status = new AnimationReadOnlyProperty&lt;&gt;(&quot;status&quot;, Status.STOPPED);
 713         }
 714         return status;
 715     }
 716 
 717     boolean isStopped() {
 718         return getStatus() == Status.STOPPED;
 719     }
 720 
 721     boolean isPaused() {
 722         return getStatus() == Status.PAUSED;
 723     }
 724 
 725     boolean isRunning() {
 726         return getStatus() == Status.RUNNING;
 727     }
 728 
 729     /**
 730      * The action to be executed at the conclusion of this {@code Animation}.
 731      *
 732      * @defaultValue null
 733      */
 734     private ObjectProperty&lt;EventHandler&lt;ActionEvent&gt;&gt; onFinished;
 735     private static final EventHandler&lt;ActionEvent&gt; DEFAULT_ON_FINISHED = null;
 736 
 737     public final void setOnFinished(EventHandler&lt;ActionEvent&gt; value) {
 738         if (onFinished != null || value != DEFAULT_ON_FINISHED) {
 739             onFinishedProperty().set(value);
 740         }
 741     }
 742 
 743     public final EventHandler&lt;ActionEvent&gt; getOnFinished() {
 744         return (onFinished == null) ? DEFAULT_ON_FINISHED : onFinished.get();
 745     }
 746 
 747     public final ObjectProperty&lt;EventHandler&lt;ActionEvent&gt;&gt; onFinishedProperty() {
 748         if (onFinished == null) {
 749             onFinished = new ObjectPropertyBase&lt;&gt;(DEFAULT_ON_FINISHED) {
 750 
 751                 @Override
 752                 public Object getBean() {
 753                     return Animation.this;
 754                 }
 755 
 756                 @Override
 757                 public String getName() {
 758                     return &quot;onFinished&quot;;
 759                 }
 760             };
 761         }
 762         return onFinished;
 763     }
 764 
 765     private ObservableMap&lt;String, Duration&gt; cuePoints;
 766 
 767     /**
 768      * The cue points can be
 769      * used to mark important positions of the {@code Animation}. Once a cue
 770      * point was defined, it can be used as an argument of
 771      * {@link #jumpTo(String) jumpTo()} and {@link #playFrom(String) playFrom()}
 772      * to move to the associated position quickly.
 773      * &lt;p&gt;
 774      * Every {@code Animation} has two predefined cue points {@code &quot;start&quot;} and
 775      * {@code &quot;end&quot;}, which are set at the start respectively the end of the
 776      * {@code Animation}. The predefined cuepoints do not appear in the map,
 777      * attempts to override them have no effect.
 778      * &lt;p&gt;
 779      * Another option to define a cue point in a {@code Animation} is to set the
 780      * {@link KeyFrame#getName() name} property of a {@link KeyFrame}.
 781      *
 782      * @return {@link javafx.collections.ObservableMap} of cue points
 783      */
 784     public final ObservableMap&lt;String, Duration&gt; getCuePoints() {
 785         if (cuePoints == null) {
 786             cuePoints = FXCollections.observableHashMap();
 787         }
 788         return cuePoints;
 789     }
 790 
 791     /**
 792      * Jumps to a given position in this {@code Animation}.
 793      *
 794      * If the given time is less than {@link Duration#ZERO}, this method will
 795      * jump to the start of the animation. If the given time is larger than the
 796      * duration of this {@code Animation}, this method will jump to the end.
 797      *
 798      * @param time
 799      *            the new position
 800      * @throws NullPointerException
 801      *             if {@code time} is {@code null}
 802      * @throws IllegalArgumentException
 803      *             if {@code time} is {@link Duration#UNKNOWN}
 804      * @throws IllegalStateException
 805      *             if embedded in another animation,
 806      *                such as {@link SequentialTransition} or {@link ParallelTransition}
 807      */
 808     public void jumpTo(Duration time) {
 809         Objects.requireNonNull(time, &quot;Time needs to be specified&quot;);
 810         if (time.isUnknown()) {
 811             throw new IllegalArgumentException(&quot;The time is invalid&quot;);
 812         }
 813         if (parent != null) {
 814             throw new IllegalStateException(&quot;Cannot jump when embedded in another animation&quot;);
 815         }
 816 
 817         lastPlayedFinished = false;
 818 
 819         double millis = time.isIndefinite() ? getCycleDuration().toMillis() :
 820             Utils.clamp(0, time.toMillis(), getTotalDuration().toMillis());
 821         long ticks = TickCalculation.fromMillis(millis);
 822 
 823         if (isStopped()) {
 824             syncClipEnvelope();
 825         }
 826         clipEnvelope.jumpTo(ticks);
 827     }
 828 
 829     /**
 830      * Jumps to a predefined position in this {@code Animation}. This method
 831      * looks for an entry in cue points and jumps to the associated
 832      * position, if it finds one.
 833      * &lt;p&gt;
 834      * If the cue point is behind the end of this {@code Animation}, calling
 835      * {@code jumpTo} will result in a jump to the end. If the cue point has a
 836      * negative {@link javafx.util.Duration} it will result in a jump to the
 837      * beginning. If the cue point has a value of
 838      * {@link javafx.util.Duration#UNKNOWN} calling {@code jumpTo} will have no
 839      * effect for this cue point.
 840      * &lt;p&gt;
 841      * There are two predefined cue points {@code &quot;start&quot;} and {@code &quot;end&quot;}
 842      * which are defined to be at the start respectively the end of this
 843      * {@code Animation}.
 844      *
 845      * @param cuePoint
 846      *            the name of the cue point
 847      * @throws NullPointerException
 848      *             if {@code cuePoint} is {@code null}
 849      * @throws IllegalStateException
 850      *             if embedded in another animation,
 851      *                such as {@link SequentialTransition} or {@link ParallelTransition}
 852      * @see #getCuePoints()
 853      */
 854     public void jumpTo(String cuePoint) {
 855         Objects.requireNonNull(cuePoint, &quot;CuePoint needs to be specified&quot;);
 856         if (&quot;start&quot;.equalsIgnoreCase(cuePoint)) {
 857             jumpTo(Duration.ZERO);
 858         } else if (&quot;end&quot;.equalsIgnoreCase(cuePoint)) {
 859             jumpTo(getTotalDuration());
 860         } else {
 861             final Duration target = getCuePoints().get(cuePoint);
 862             if (target != null) {
 863                 jumpTo(target);
 864             }
 865         }
 866     }
 867 
 868     /**
 869      * A convenience method to play this {@code Animation} from a predefined
 870      * position. The position has to be predefined in cue points.
 871      * Calling this method is equivalent to
 872      *
 873      * &lt;pre&gt;
 874      * &lt;code&gt;
 875      * animation.jumpTo(cuePoint);
 876      * animation.play();
 877      * &lt;/code&gt;
 878      * &lt;/pre&gt;
 879      *
 880      * Note that unlike {@link #playFromStart()} calling this method will not
 881      * change the playing direction of this {@code Animation}.
 882      *
 883      * @param cuePoint
 884      *            name of the cue point
 885      * @throws NullPointerException
 886      *             if {@code cuePoint} is {@code null}
 887      * @throws IllegalStateException
 888      *             if embedded in another animation,
 889      *                such as {@link SequentialTransition} or {@link ParallelTransition}
 890      * @see #getCuePoints()
 891      */
 892     public void playFrom(String cuePoint) {
 893         jumpTo(cuePoint);
 894         play();
 895     }
 896 
 897     /**
 898      * A convenience method to play this {@code Animation} from a specific
 899      * position. Calling this method is equivalent to
 900      *
 901      * &lt;pre&gt;
 902      * &lt;code&gt;
 903      * animation.jumpTo(time);
 904      * animation.play();
 905      * &lt;/code&gt;
 906      * &lt;/pre&gt;
 907      *
 908      * Note that unlike {@link #playFromStart()} calling this method will not
 909      * change the playing direction of this {@code Animation}.
 910      *
 911      * @param time
 912      *            position where to play from
 913      * @throws NullPointerException
 914      *             if {@code time} is {@code null}
 915      * @throws IllegalArgumentException
 916      *             if {@code time} is {@link Duration#UNKNOWN}
 917      * @throws IllegalStateException
 918      *             if embedded in another animation,
 919      *                such as {@link SequentialTransition} or {@link ParallelTransition}
 920      */
 921     public void playFrom(Duration time) {
 922         jumpTo(time);
 923         play();
 924     }
 925 
 926     /**
 927      * Plays an {@code Animation} from initial position in forward direction.
 928      * &lt;p&gt;
 929      * It is equivalent to
 930      * &lt;p&gt;
 931      * &lt;code&gt;
 932      *      animation.stop();&lt;br&gt;
 933      *      animation.setRate = setRate(Math.abs(animation.getRate())); &lt;br&gt;
 934      *      animation.jumpTo(Duration.ZERO);&lt;br&gt;
 935      *      animation.play();&lt;br&gt;
 936      *  &lt;/code&gt;
 937      *
 938      * &lt;p&gt;
 939      * Note: &lt;ul&gt;
 940      * &lt;li&gt;{@code playFromStart()} is an asynchronous call, {@code Animation} may
 941      * not start immediately. &lt;/ul&gt;
 942      *
 943      * @throws IllegalStateException
 944      *             if embedded in another animation,
 945      *                such as {@link SequentialTransition} or {@link ParallelTransition}
 946      */
 947     public void playFromStart() {
 948         stop();
 949         setRate(Math.abs(getRate()));
 950         jumpTo(Duration.ZERO);
 951         play();
 952     }
 953 
 954     /**
 955      * Plays {@code Animation} from current position in the direction indicated
 956      * by {@code rate}. If the {@code Animation} is running, it has no effect.
 957      * &lt;p&gt;
 958      * When {@code rate} {@literal &gt;} 0 (forward play), if an {@code Animation} is already
 959      * positioned at the end, the first cycle will not be played, it is
 960      * considered to have already finished. This also applies to a backward (
 961      * {@code rate} {@literal &lt;} 0) cycle if an {@code Animation} is positioned at the beginning.
 962      * However, if the {@code Animation} has {@code cycleCount} {@literal &gt;} 1, following
 963      * cycle(s) will be played as usual.
 964      * &lt;p&gt;
 965      * When the {@code Animation} reaches the end, the {@code Animation} is stopped and
 966      * the play head remains at the end.
 967      * &lt;p&gt;
 968      * To play an {@code Animation} backwards from the end:&lt;br&gt;
 969      * &lt;code&gt;
 970      *  animation.setRate(negative rate);&lt;br&gt;
 971      *  animation.jumpTo(overall duration of animation);&lt;br&gt;
 972      *  animation.play();&lt;br&gt;
 973      * &lt;/code&gt;
 974      * &lt;p&gt;
 975      * Note: &lt;ul&gt;
 976      * &lt;li&gt;{@code play()} is an asynchronous call, the {@code Animation} may not
 977      * start immediately. &lt;/ul&gt;
 978      *
 979      * @throws IllegalStateException
 980      *             if embedded in another animation,
 981      *                such as {@link SequentialTransition} or {@link ParallelTransition}
 982      */
 983     public void play() {
 984         if (parent != null) {
 985             throw new IllegalStateException(&quot;Cannot start when embedded in another animation&quot;);
 986         }
 987         switch (getStatus()) {
 988             case STOPPED:
 989                 if (startable(true)) {
 990                     final double rate = getRate();
 991                     if (lastPlayedFinished) {
 992                         jumpTo(rate &lt; 0 ? getTotalDuration() : Duration.ZERO);
 993                     }
 994                     doStart(true);
 995                     startReceiver(TickCalculation.fromDuration(getDelay()));
 996                     if (isNearZero(rate)) {
 997                         pauseReceiver();
 998                     } else {
 999 
1000                     }
1001                 } else {
1002                     runHandler(getOnFinished());
1003                 }
1004                 break;
1005             case PAUSED:
1006                 doResume();
1007                 if (!isNearZero(getRate())) {
1008                     resumeReceiver();
1009                 }
1010                 break;
1011             case RUNNING: // no-op
1012         }
1013     }
1014 
1015     void doStart(boolean forceSync) {
1016         sync(forceSync);
1017         setStatus(Status.RUNNING);
1018         clipEnvelope.start();
1019         doSetCurrentRate(clipEnvelope.getCurrentRate());
1020         lastPulse = 0;
1021     }
1022 
1023     void doResume() {
1024         setStatus(Status.RUNNING);
1025         doSetCurrentRate(lastPlayedForward ? getRate() : -getRate());
1026     }
1027 
1028     /**
1029      * Stops the animation and resets the play head to its initial position. If
1030      * the animation is already stopped, this method has no effect.
1031      * &lt;p&gt;
1032      * Note: &lt;ul&gt;
1033      * &lt;li&gt;{@code stop()} is an asynchronous call, the {@code Animation} may not stop
1034      * immediately. &lt;/ul&gt;
1035      * @throws IllegalStateException
1036      *             if embedded in another animation,
1037      *                such as {@link SequentialTransition} or {@link ParallelTransition}
1038      */
1039     public void stop() {
1040         if (parent != null) {
1041             throw new IllegalStateException(&quot;Cannot stop when embedded in another animation&quot;);
1042         }
1043         if (!isStopped()) {
1044             clipEnvelope.abortCurrentPulse();
1045             doStop();
1046             jumpTo(Duration.ZERO);
1047             lastPlayedFinished = true;
1048         }
1049     }
1050 
1051     void doStop() {
1052         if (!paused) {
1053             timer.removePulseReceiver(pulseReceiver);
1054         }
1055         setStatus(Status.STOPPED);
1056         doSetCurrentRate(0.0);
1057     }
1058 
1059     /**
1060      * Pauses the animation. If the animation is not currently running, this
1061      * method has no effect.
1062      * &lt;p&gt;
1063      * Note: &lt;ul&gt;
1064      * &lt;li&gt;{@code pause()} is an asynchronous call, the {@code Animation} may not pause
1065      * immediately. &lt;/ul&gt;
1066      * @throws IllegalStateException
1067      *             if embedded in another animation,
1068      *                such as {@link SequentialTransition} or {@link ParallelTransition}
1069      */
1070     public void pause() {
1071         if (parent != null) {
1072             throw new IllegalStateException(&quot;Cannot pause when embedded in another animation&quot;);
1073         }
1074         if (isRunning()) {
1075             clipEnvelope.abortCurrentPulse();
1076             pauseReceiver();
1077             doPause();
1078         }
1079     }
1080 
1081     void doPause() {
1082         final double currentRate = getCurrentRate();
1083         if (!isNearZero(currentRate)) {
1084             lastPlayedForward = areNearEqual(getCurrentRate(), getRate());
1085         }
1086         doSetCurrentRate(0.0);
1087         setStatus(Status.PAUSED);
1088     }
1089 
1090     final void finished() {
1091         lastPlayedFinished = true;
1092         doStop();
1093         runHandler(getOnFinished());
1094     }
1095 
1096     void runHandler(EventHandler&lt;ActionEvent&gt; handler) {
1097         if (handler != null) {
1098             try {
1099                 handler.handle(new ActionEvent(this, null));
1100             } catch (Exception ex) {
1101                 Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), ex);
1102             }
1103         }
1104     }
1105 
1106     private final double targetFramerate;
1107     private final int resolution;
1108     private long lastPulse;
1109 
1110     /**
1111      * The target framerate is the maximum framerate at which this {@code Animation}
1112      * will run, in frames per second. This can be used, for example, to keep
1113      * particularly complex {@code Animations} from over-consuming system resources.
1114      * By default, an {@code Animation}&#39;s framerate is not explicitly limited, meaning
1115      * the {@code Animation} will run at an optimal framerate for the underlying platform.
1116      *
1117      * @return the target framerate
1118      */
1119     public final double getTargetFramerate() {
1120         return targetFramerate;
1121     }
1122 
1123     /**
1124      * The constructor of {@code Animation}.
1125      *
1126      * This constructor allows to define a target framerate.
1127      *
1128      * @param targetFramerate
1129      *            The custom target frame rate for this {@code Animation}
1130      * @see #getTargetFramerate()
1131      */
1132     protected Animation(double targetFramerate) {
1133         this.targetFramerate = targetFramerate;
1134         this.resolution = (int) Math.max(1, Math.round(TickCalculation.TICKS_PER_SECOND / targetFramerate));
1135         this.clipEnvelope = ClipEnvelope.create(this);
1136         this.timer = Toolkit.getToolkit().getMasterTimer();
1137     }
1138 
1139     /**
1140      * The constructor of {@code Animation}.
1141      */
1142     protected Animation() {
1143         this.resolution = 1;
1144         this.targetFramerate = TickCalculation.TICKS_PER_SECOND / Toolkit.getToolkit().getMasterTimer().getDefaultResolution();
1145         this.clipEnvelope = ClipEnvelope.create(this);
1146         this.timer = Toolkit.getToolkit().getMasterTimer();
1147     }
1148 
1149     // These constructors are only for testing purposes
1150     Animation(AbstractMasterTimer timer) {
1151         this.resolution = 1;
1152         this.targetFramerate = TickCalculation.TICKS_PER_SECOND / timer.getDefaultResolution();
1153         this.clipEnvelope = ClipEnvelope.create(this);
1154         this.timer = timer;
1155     }
1156 
1157     // These constructors are only for testing purposes
1158     Animation(AbstractMasterTimer timer, ClipEnvelope clipEnvelope, int resolution) {
1159         this.resolution = resolution;
1160         this.targetFramerate = TickCalculation.TICKS_PER_SECOND / resolution;
1161         this.clipEnvelope = clipEnvelope;
1162         this.timer = timer;
1163     }
1164 
1165     boolean startable(boolean forceSync) {
1166         return (TickCalculation.fromDuration(getCycleDuration()) &gt; 0L) || (!forceSync &amp;&amp; clipEnvelope.wasSynched());
1167     }
1168 
1169     void sync(boolean forceSync) {
1170         if (forceSync || !clipEnvelope.wasSynched()) {
1171             syncClipEnvelope();
1172         }
1173     }
1174 
1175     private void syncClipEnvelope() {
1176         final int publicCycleCount = getCycleCount();
1177         final int internalCycleCount = (publicCycleCount &lt;= 0)
1178                 &amp;&amp; (publicCycleCount != INDEFINITE) ? 1 : publicCycleCount;
1179         clipEnvelope = clipEnvelope.setCycleCount(internalCycleCount);
1180         clipEnvelope.setCycleDuration(getCycleDuration());
1181         clipEnvelope.setAutoReverse(isAutoReverse());
1182     }
1183 
1184     void doTimePulse(long elapsedTime) {
1185         if (resolution == 1) { // fullspeed
1186             clipEnvelope.timePulse(elapsedTime);
1187         } else if (elapsedTime - lastPulse &gt;= resolution) {
1188             lastPulse = (elapsedTime / resolution) * resolution;
1189             clipEnvelope.timePulse(elapsedTime);
1190         }
1191     }
1192 
1193     abstract void doPlayTo(long currentTicks, long cycleTicks);
1194 
1195     abstract void doJumpTo(long currentTicks, long cycleTicks, boolean forceJump);
1196 
1197     void setCurrentTicks(long ticks) {
1198         currentTicks = ticks;
1199         if (currentTime != null) {
1200             currentTime.fireValueChangedEvent();
1201         }
1202     }
1203 }
    </pre>
  </body>
</html>
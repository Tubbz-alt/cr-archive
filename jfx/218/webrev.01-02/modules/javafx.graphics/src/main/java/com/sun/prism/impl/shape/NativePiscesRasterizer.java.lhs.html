<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/java/com/sun/prism/impl/shape/NativePiscesRasterizer.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2012, 2014, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.prism.impl.shape;
 27 
 28 import com.sun.glass.utils.NativeLibLoader;
 29 import com.sun.javafx.geom.Path2D;
 30 import com.sun.javafx.geom.PathIterator;
 31 import com.sun.javafx.geom.RectBounds;
 32 import com.sun.javafx.geom.Shape;
 33 import com.sun.javafx.geom.transform.BaseTransform;
<a name="2" id="anc2"></a>
 34 import com.sun.prism.BasicStroke;
 35 import com.sun.prism.impl.PrismSettings;
 36 import java.nio.ByteBuffer;
 37 import java.security.AccessController;
 38 import java.security.PrivilegedAction;
 39 
 40 public class NativePiscesRasterizer implements ShapeRasterizer {
 41     private static MaskData emptyData = MaskData.create(new byte[1], 0, 0, 1, 1);
 42 
 43     private static final byte SEG_MOVETO  = PathIterator.SEG_MOVETO;
 44     private static final byte SEG_LINETO  = PathIterator.SEG_LINETO;
 45     private static final byte SEG_QUADTO  = PathIterator.SEG_QUADTO;
 46     private static final byte SEG_CUBICTO = PathIterator.SEG_CUBICTO;
 47     private static final byte SEG_CLOSE   = PathIterator.SEG_CLOSE;
 48 
 49     private byte cachedMask[];
 50     private ByteBuffer cachedBuffer;
 51     private MaskData cachedData;
 52     private int bounds[] = new int[4];
 53     private boolean lastAntialiasedShape;
 54     private boolean firstTimeAASetting = true;
 55 
 56     native static void init(int subpixelLgPositionsX, int subpixelLgPositionsY);
 57 
 58     native static void produceFillAlphas(float coords[], byte commands[], int nsegs, boolean nonzero,
 59                                          double mxx, double mxy, double mxt,
 60                                          double myx, double myy, double myt,
 61                                          int bounds[], byte mask[]);
 62     native static void produceStrokeAlphas(float coords[], byte commands[], int nsegs,
 63                                            float lw, int cap, int join, float mlimit,
 64                                            float dashes[], float dashoff,
 65                                            double mxx, double mxy, double mxt,
 66                                            double myx, double myy, double myt,
 67                                            int bounds[], byte mask[]);
 68 
 69     static {
 70         AccessController.doPrivileged((PrivilegedAction&lt;Void&gt;) () -&gt; {
 71             String libName = &quot;prism_common&quot;;
 72 
 73             if (PrismSettings.verbose) {
 74                 System.out.println(&quot;Loading Prism common native library ...&quot;);
 75             }
 76             NativeLibLoader.loadLibrary(libName);
 77             if (PrismSettings.verbose) {
 78                 System.out.println(&quot;\tsucceeded.&quot;);
 79             }
 80             return null;
 81         });
 82     }
 83 
 84     @Override
 85     public MaskData getMaskData(Shape shape, BasicStroke stroke,
 86                                 RectBounds xformBounds, BaseTransform xform,
 87                                 boolean close, boolean antialiasedShape)
 88     {
 89 
 90         if (firstTimeAASetting || (lastAntialiasedShape != antialiasedShape)) {
 91             int subpixelLgPositions = antialiasedShape ? 3 : 0;
 92             NativePiscesRasterizer.init(subpixelLgPositions, subpixelLgPositions);
 93             firstTimeAASetting = false;
 94             lastAntialiasedShape = antialiasedShape;
 95         }
 96 
 97         if (stroke != null &amp;&amp; stroke.getType() != BasicStroke.TYPE_CENTERED) {
 98             // RT-27427
 99             // TODO: Optimize the combinatorial strokes for simple
100             // shapes and/or teach the rasterizer to be able to
101             // do a &quot;differential fill&quot; between two shapes.
102             // Note that most simple shapes will use a more optimized path
103             // than this method for the INNER/OUTER strokes anyway.
104             shape = stroke.createStrokedShape(shape);
105             stroke = null;
106         }
107         if (xformBounds == null) {
108             if (stroke != null) {
109                 // Note that all places that pass null for xformbounds also
110                 // pass null for stroke so that the following is not typically
111                 // executed, but just here as a safety net.
112                 shape = stroke.createStrokedShape(shape);
113                 stroke = null;
114             }
115 
116             xformBounds = new RectBounds();
117             //TODO: Need to verify that this is a safe cast ... (RT-27427)
118             xformBounds = (RectBounds) xform.transform(shape.getBounds(), xformBounds);
119         }
120         bounds[0] = (int) Math.floor(xformBounds.getMinX());
121         bounds[1] = (int) Math.floor(xformBounds.getMinY());
122         bounds[2] = (int) Math.ceil(xformBounds.getMaxX());
123         bounds[3] = (int) Math.ceil(xformBounds.getMaxY());
124         if (bounds[2] &lt;= bounds[0] || bounds[3] &lt;= bounds[1]) {
125             return emptyData;
126         }
127         Path2D p2d = (shape instanceof Path2D) ? (Path2D) shape : new Path2D(shape);
128         double mxx, mxy, mxt, myx, myy, myt;
129         if (xform == null || xform.isIdentity()) {
130             mxx = myy = 1.0;
131             mxy = myx = 0.0;
132             mxt = myt = 0.0;
133         } else {
134             mxx = xform.getMxx();
135             mxy = xform.getMxy();
136             mxt = xform.getMxt();
137             myx = xform.getMyx();
138             myy = xform.getMyy();
139             myt = xform.getMyt();
140         }
141         int x = bounds[0];
142         int y = bounds[1];
143         int w = bounds[2] - x;
144         int h = bounds[3] - y;
145         if (w &lt;= 0 || h &lt;= 0) {
146             return emptyData;
147         }
148         if (cachedMask == null || w * h &gt; cachedMask.length) {
149             cachedMask = null;
150             cachedBuffer = null;
151             cachedData = new MaskData();
152             int csize = (w * h + 0xfff) &amp; (~0xfff);
153             cachedMask = new byte[csize];
154             cachedBuffer = ByteBuffer.wrap(cachedMask);
155         }
<a name="3" id="anc3"></a><span class="line-modified">156         if (stroke != null) {</span>
<span class="line-modified">157             produceStrokeAlphas(p2d.getFloatCoordsNoClone(),</span>
<span class="line-modified">158                                 p2d.getCommandsNoClone(),</span>
<span class="line-modified">159                                 p2d.getNumCommands(),</span>
<span class="line-modified">160                                 stroke.getLineWidth(), stroke.getEndCap(),</span>
<span class="line-modified">161                                 stroke.getLineJoin(), stroke.getMiterLimit(),</span>
<span class="line-modified">162                                 stroke.getDashArray(), stroke.getDashPhase(),</span>
<span class="line-modified">163                                 mxx, mxy, mxt, myx, myy, myt,</span>
<span class="line-modified">164                                 bounds, cachedMask);</span>
<span class="line-modified">165         } else {</span>
<span class="line-modified">166             produceFillAlphas(p2d.getFloatCoordsNoClone(),</span>
<span class="line-modified">167                               p2d.getCommandsNoClone(),</span>
<span class="line-modified">168                               p2d.getNumCommands(), p2d.getWindingRule() == Path2D.WIND_NON_ZERO,</span>
<span class="line-modified">169                               mxx, mxy, mxt, myx, myy, myt,</span>
<span class="line-modified">170                               bounds, cachedMask);</span>









171         }
172         x = bounds[0];
173         y = bounds[1];
174         w = bounds[2] - x;
175         h = bounds[3] - y;
176         if (w &lt;= 0 || h &lt;= 0) {
177             return emptyData;
178         }
179         cachedData.update(cachedBuffer, x, y, w, h);
180         return cachedData;
181     }
182 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
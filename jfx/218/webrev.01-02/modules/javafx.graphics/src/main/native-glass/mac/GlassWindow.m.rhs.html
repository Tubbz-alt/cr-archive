<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.graphics/src/main/native-glass/mac/GlassWindow.m</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #import &quot;common.h&quot;
  27 #import &quot;com_sun_glass_events_ViewEvent.h&quot;
  28 #import &quot;com_sun_glass_events_WindowEvent.h&quot;
  29 #import &quot;com_sun_glass_ui_Window.h&quot;
  30 #import &quot;com_sun_glass_ui_Window_Level.h&quot;
  31 #import &quot;com_sun_glass_ui_mac_MacWindow.h&quot;
  32 
  33 #import &quot;GlassMacros.h&quot;
  34 #import &quot;GlassWindow.h&quot;
  35 #import &quot;GlassWindow+Java.h&quot;
  36 #import &quot;GlassWindow+Overrides.h&quot;
  37 #import &quot;GlassEmbeddedWindow+Overrides.h&quot;
  38 #import &quot;GlassView.h&quot;
  39 #import &quot;GlassScreen.h&quot;
  40 #import &quot;GlassTouches.h&quot;
  41 #import &quot;GlassApplication.h&quot;
  42 #import &quot;GlassLayer3D.h&quot;
  43 #import &quot;GlassHelper.h&quot;
  44 
  45 //#include &lt;stdio.h&gt;
  46 //#include &lt;stdarg.h&gt;
  47 //
  48 //void glass_logf(char *fmt, ...) {
  49 //    va_list argp;
  50 //    va_start(argp, fmt);
  51 //    FILE *f = fopen(&quot;/tmp/glass.log&quot;, &quot;a&quot;);
  52 //    vfprintf(f, fmt, argp);
  53 //    fclose(f);
  54 //}
  55 //
  56 //void Sys_out_sprintf(JNIEnv *env, char *fmt, ...) {
  57 //    va_list argp;
  58 //    va_start(argp, fmt);
  59 //    char buffer[4096];
  60 //    vsprintf(buffer, fmt, argp);
  61 ////    glass_logf(&quot;str = %s&quot;, buffer);
  62 ////    return;
  63 //    jclass sysClass = (*env)-&gt;FindClass(env, &quot;java/lang/System&quot;);
  64 //    if (!sysClass) { glass_logf(&quot;Null finding System class\n&quot;); return; }
  65 //    jclass psClass = (*env)-&gt;FindClass(env, &quot;java/io/PrintStream&quot;);
  66 //    if (!psClass) { glass_logf(&quot;Null finding PrintStream class\n&quot;); return; }
  67 //    jfieldID outField = (*env)-&gt;GetStaticFieldID(env, sysClass, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);
  68 //    if (!outField) { glass_logf(&quot;Null finding System.out field\n&quot;); return; }
  69 //    jmethodID printMethod = (*env)-&gt;GetMethodID(env, psClass, &quot;print&quot;, &quot;(Ljava/lang/String;)V&quot;);
  70 //    if (!printMethod) { glass_logf(&quot;Null finding print method\n&quot;); return; }
  71 //    jobject outStream = (*env)-&gt;GetStaticObjectField(env, sysClass, outField);
  72 //    if (!outStream) { glass_logf(&quot;Null getting System.out object\n&quot;); return; }
  73 //    jstring theString = (*env)-&gt;NewStringUTF(env, buffer);
  74 //    if (!theString) { glass_logf(&quot;Null creating String object\n&quot;); return; }
  75 //    (*env)-&gt;CallVoidMethod(env, outStream, printMethod, theString);
  76 //    (*env)-&gt;DeleteLocalRef(env, theString);
  77 //}
  78 
  79 //#define VERBOSE
  80 #ifndef VERBOSE
  81     #define LOG(MSG, ...)
  82 #else
  83     #define LOG(MSG, ...) GLASS_LOG(MSG, ## __VA_ARGS__);
  84 #endif
  85 
  86 #define BROWSER_PARENT_ID -1L
  87 
  88 #pragma mark --- Internal utilities
  89 
  90 static inline GlassWindow *getGlassWindow(JNIEnv *env, jlong jPtr)
  91 {
  92     assert(jPtr != 0L);
  93 
  94     NSWindow * nsWindow = (NSWindow*)jlong_to_ptr(jPtr);
  95     return (GlassWindow*)[nsWindow delegate];
  96 }
  97 
  98 static inline NSView&lt;GlassView&gt; *getMacView(JNIEnv *env, jobject jview)
  99 {
 100     if (jview != NULL)
 101     {
 102         jfieldID jfID = (*env)-&gt;GetFieldID(env, jViewClass, &quot;ptr&quot;, &quot;J&quot;);
 103         GLASS_CHECK_EXCEPTION(env);
 104         return (NSView&lt;GlassView&gt;*)jlong_to_ptr((*env)-&gt;GetLongField(env, jview, jfID));
 105     }
 106     else
 107     {
 108         return nil;
 109     }
 110 }
 111 
 112 // --------------------------------------------------------------------------------------
 113 // NSWindow/NSPanel descendants implementation
 114 #define GLASS_NS_WINDOW_IMPLEMENTATION                                                  \
 115 - (id)initWithDelegate:(GlassWindow*)delegate                                           \
 116              frameRect:(NSRect)rect                                                     \
 117              styleMask:(NSUInteger)styleMask                                            \
 118                 screen:(NSScreen*)screen                                                \
 119 {                                                                                       \
 120     self-&gt;gWindow = delegate; /* must be done before calling [super init...] */         \
 121     self = [super initWithContentRect:rect                                              \
 122                             styleMask:styleMask                                         \
 123                               backing:NSBackingStoreBuffered                            \
 124                                 defer:NO                                                \
 125                                screen:screen];                                          \
 126                                                                                         \
 127     if (self == nil) {                                                                  \
 128         return nil;                                                                     \
 129     }                                                                                   \
 130                                                                                         \
 131     [self setDelegate:delegate];                                                        \
 132     [self setAcceptsMouseMovedEvents:NO];                                               \
 133     [self setShowsResizeIndicator:NO];                                                  \
 134     [self setAllowsConcurrentViewDrawing:YES];                                          \
 135                                                                                         \
 136     [self setReleasedWhenClosed:YES];                                                   \
 137                                                                                         \
 138     return self;                                                                        \
 139 }                                                                                       \
 140                                                                                         \
 141 - (void)dealloc                                                                         \
 142 {                                                                                       \
 143     id window = self-&gt;gWindow;                                                          \
 144     LOG(&quot;dealloc window: %p&quot;, window);                                                  \
 145     [super dealloc];                                                                    \
 146     [window release];                                                                   \
 147 }                                                                                       \
 148                                                                                         \
 149 - (void)close                                                                           \
 150 {                                                                                       \
 151     self-&gt;gWindow-&gt;isClosed = YES;                                                      \
 152     [self-&gt;gWindow close];                                                              \
 153     LOG(&quot;gWindow close: %p&quot;, self-&gt;gWindow);                                            \
 154     [super close];                                                                      \
 155     LOG(&quot;super close&quot;);                                                                 \
 156 }                                                                                       \
 157 /* super calls NSWindow on the next run-loop pass when NSWindow could be released */    \
 158 - (BOOL)performKeyEquivalent:(NSEvent *)theEvent                                        \
 159 {                                                                                       \
 160     [self retain];                                                                      \
 161     BOOL result = [super performKeyEquivalent:theEvent];                                \
 162     result = result || self-&gt;gWindow-&gt;isClosed;                                         \
 163     [self release];                                                                     \
 164     return result;                                                                      \
 165 }                                                                                       \
 166 - (BOOL)canBecomeMainWindow                                                             \
 167 {                                                                                       \
 168     return [self-&gt;gWindow canBecomeMainWindow];                                         \
 169 }                                                                                       \
 170 - (BOOL)canBecomeKeyWindow                                                              \
 171 {                                                                                       \
 172     return [self-&gt;gWindow canBecomeKeyWindow];                                          \
 173 }                                                                                       \
 174 - (void)setHidesOnDeactivate:(BOOL)hideOnDeactivate                                     \
 175 {                                                                                       \
 176     [super setHidesOnDeactivate:NO];                                                    \
 177 }                                                                                       \
 178 - (BOOL)hidesOnDeactivate                                                               \
 179 {                                                                                       \
 180     return [self-&gt;gWindow hidesOnDeactivate];                                           \
 181 }                                                                                       \
 182 - (BOOL)worksWhenModal                                                                  \
 183 {                                                                                       \
 184     return [self-&gt;gWindow worksWhenModal];                                              \
 185 }                                                                                       \
 186 - (void)setBackgroundColor:(NSColor *)color                                             \
 187 {                                                                                       \
 188     [super setBackgroundColor:[self-&gt;gWindow setBackgroundColor:color]];                \
 189 }                                                                                       \
 190 - (NSButton *)standardWindowButton:(NSWindowButton)type                                 \
 191 {                                                                                       \
 192     NSButton* button = [super standardWindowButton:type];                               \
 193     switch (type)                                                                       \
 194     {                                                                                   \
 195         case NSWindowDocumentIconButton:                                                \
 196             [button setAcceptsTouchEvents:NO];                                          \
 197             [button setAction:nil];                                                     \
 198             [button setEnabled:NO];                                                     \
 199             break;                                                                      \
 200     }                                                                                   \
 201     return button;                                                                      \
 202 }                                                                                       \
 203 - (void)sendEvent:(NSEvent *)event                                                      \
 204 {                                                                                       \
 205     /* Local copy of the id keeps the retain/release calls balanced. */                 \
 206     id view = [self-&gt;gWindow-&gt;view retain];                                             \
 207     [self-&gt;gWindow sendEvent:event];                                                    \
 208     [super sendEvent:event];                                                            \
 209     [view release];                                                                     \
 210 }
 211 
 212 @implementation GlassWindow_Normal
 213 GLASS_NS_WINDOW_IMPLEMENTATION
 214 @end
 215 
 216 @implementation GlassWindow_Panel
 217 GLASS_NS_WINDOW_IMPLEMENTATION
 218 
 219 - (void)setWorksWhenModal:(BOOL)worksWhenModal
 220 {
 221     [super setWorksWhenModal:NO];
 222 }
 223 
 224 - (BOOL)accessibilityIsIgnored
 225 {
 226     /* In JavaFX NSPanels are used to implement PopupWindows,
 227      * which are used by ContextMenu.  In Accessibility, for a
 228      * menu to work as expected, the window has to be ignored.
 229      * Note that asking the children of the window is
 230      * very important in this context. It ensures that all
 231      * descendants created.  Without it, the menu  will
 232      * not be seen by the assistive technology.
 233      */
 234     __block BOOL ignored = [super accessibilityIsIgnored];
 235     NSArray* children = [self accessibilityAttributeValue: NSAccessibilityChildrenAttribute];
 236     if (children) {
 237         [children enumerateObjectsUsingBlock: ^(id child, NSUInteger index, BOOL *stop) {
 238             NSString* role = [child accessibilityAttributeValue: NSAccessibilityRoleAttribute];
 239             if ([NSAccessibilityMenuRole isEqualToString: role]) {
 240                 ignored = YES;
 241                 *stop = YES;
 242             }
 243             /* Tooltips are exposed by AXHelp attribute and there is no API in Mac
 244              * to represent the tooltip window.
 245              * Nonetheless, the window must be ignored to prevent interfering with
 246              * VoiceOver focus.
 247              */
 248             if ([@&quot;AXJFXTOOLTIP&quot; isEqualToString: role]) {
 249                 ignored = YES;
 250                 *stop = YES;
 251             }
 252         }];
 253     }
 254     return ignored;
 255 }
 256 
 257 - (id)accessibilityAttributeValue:(NSString *)attribute
 258 {
 259     /*
 260     * The default value of AXRoleDescription for a NSPanel is &#39;system dialog&#39;.
 261     * While this is correct for an average cocoa application it is not appropriate
 262     * for JFX, where all NSPanels are decoration-less windows used to implement
 263     * tooltip, context menus, combo boxes, etc.
 264     */
 265     if ([NSAccessibilityRoleDescriptionAttribute isEqualToString: attribute]) {
 266         return @&quot;&quot;;
 267     }
 268     return [super accessibilityAttributeValue: attribute];
 269 }
 270 
 271 @end
 272 // --------------------------------------------------------------------------------------
 273 
 274 
 275 @implementation GlassWindow
 276 
 277 - (void)setFullscreenWindow:(NSWindow*)fsWindow
 278 {
 279     if (self-&gt;fullscreenWindow == fsWindow) {
 280         return;
 281     }
 282 
 283     [self _ungrabFocus];
 284 
 285     NSWindow *from, *to;
 286     from = self-&gt;fullscreenWindow ? self-&gt;fullscreenWindow : self-&gt;nsWindow;
 287     to = fsWindow ? fsWindow : self-&gt;nsWindow;
 288 
 289     NSArray * children = [from childWindows];
 290     for (NSUInteger i=0; i&lt;[children count]; i++)
 291     {
 292         NSWindow *child = (NSWindow*)[children objectAtIndex:i];
 293         if ([[child delegate] isKindOfClass: [GlassWindow class]]) {
 294             [from removeChildWindow: child];
 295             [to addChildWindow:child ordered:NSWindowAbove];
 296         }
 297     }
 298 
 299     self-&gt;fullscreenWindow = fsWindow;
 300 
 301     GET_MAIN_JENV;
 302     (*env)-&gt;CallVoidMethod(env, self-&gt;jWindow, jWindowNotifyDelegatePtr, ptr_to_jlong(fsWindow));
 303     GLASS_CHECK_EXCEPTION(env);
 304 }
 305 
 306 - (void)close
 307 {
 308     [self _ungrabFocus];
 309 }
 310 
 311 - (void)sendEvent:(NSEvent *)event
 312 {
 313     if ([event type] == NSLeftMouseDown || [event type] == NSRightMouseDown || [event type] == NSOtherMouseDown)
 314     {
 315         NSPoint p = [NSEvent mouseLocation];
 316         NSRect frame = [self-&gt;nsWindow frame];
 317         NSRect contentRect = [self-&gt;nsWindow contentRectForFrameRect:frame];
 318 
 319         if (p.y &gt;= (frame.origin.y + contentRect.size.height))
 320         {
 321             // Click to the titlebar
 322             [self _ungrabFocus];
 323         }
 324 
 325         [self _checkUngrab];
 326     }
 327 }
 328 
 329 // Window vs Panel API
 330 - (BOOL)canBecomeMainWindow
 331 {
 332     if (!self-&gt;isEnabled)
 333     {
 334         // We&#39;ll send FOCUS_DISABLED
 335         return YES;
 336     }
 337     return self-&gt;isFocusable;
 338 }
 339 
 340 // Window vs Panel API
 341 - (BOOL)hidesOnDeactivate
 342 {
 343     return NO;
 344 }
 345 
 346 // Window vs Panel API
 347 - (BOOL)worksWhenModal
 348 {
 349     return NO;
 350 }
 351 
 352 - (BOOL)canBecomeKeyWindow
 353 {
 354     if (!self-&gt;isEnabled)
 355     {
 356         // We&#39;ll send FOCUS_DISABLED
 357         return YES;
 358     }
 359     return self-&gt;isFocusable;
 360 }
 361 
 362 - (NSColor*)setBackgroundColor:(NSColor *)color
 363 {
 364     if (self-&gt;isTransparent == NO)
 365     {
 366         // allow color if we&#39;re opaque
 367         return color;
 368     }
 369     else
 370     {
 371         // for transparent window, ignore and set to clear color
 372         // FIXME: do we want to store the background color in case we switch to non-transparent mode?
 373         return [NSColor clearColor];
 374     }
 375 }
 376 
 377 
 378 @end
 379 
 380 #pragma mark --- GlassEmbeddedWindow
 381 
 382 static NSMutableArray * embeddedWindowsList = nil;
 383 
 384 @implementation GlassEmbeddedWindow
 385 
 386 - (id)initWithDelegate:(GlassWindow*)delegate
 387              frameRect:(NSRect)rect
 388              styleMask:(NSUInteger)styleMask
 389                 screen:(NSScreen*)screen
 390 {
 391     self = [super initWithDelegate:delegate frameRect:rect styleMask:styleMask screen:screen];
 392     if (self == nil) {
 393         return nil;
 394     }
 395 
 396     if (embeddedWindowsList == nil) {
 397         embeddedWindowsList = [[NSMutableArray alloc] initWithCapacity: 4];
 398     }
 399     [embeddedWindowsList addObject:self]; // retains &#39;self&#39;
 400 
 401     return self;
 402 }
 403 
 404 - (void)close
 405 {
 406     if (embeddedWindowsList) {
 407         [embeddedWindowsList removeObject:self]; // releases &#39;self&#39;
 408         if ([embeddedWindowsList count] == 0) {
 409             [embeddedWindowsList release];
 410             embeddedWindowsList = nil;
 411         }
 412     }
 413     [super close];
 414 }
 415 
 416 + (BOOL)exists:(GlassEmbeddedWindow*)window
 417 {
 418     if (embeddedWindowsList &amp;&amp; window) {
 419         return [embeddedWindowsList indexOfObjectIdenticalTo:window] != NSNotFound;
 420     }
 421     return NO;
 422 }
 423 
 424 - (void)setFullscreenWindow:(NSWindow*)fsWindow
 425 {
 426     if (self-&gt;parent != nil)
 427     {
 428         BOOL fullscreen = (fsWindow != nil);
 429 
 430         CALayer *layer = [self-&gt;gWindow-&gt;view layer];
 431         if ([layer isKindOfClass:[GlassLayer3D class]] == YES)
 432         {
 433             [((CAOpenGLLayer*)layer) setAsynchronous:fullscreen];
 434 
 435             layer = [self-&gt;parent-&gt;gWindow-&gt;view layer];
 436             if ([layer isKindOfClass:[GlassLayer3D class]] == YES)
 437             {
 438                 [((CAOpenGLLayer*)layer) setAsynchronous:!fullscreen];
 439             }
 440         }
 441 
 442         self-&gt;fullscreenWindow = fsWindow;
 443     }
 444 }
 445 
 446 - (void)sendEvent:(NSEvent *)theEvent
 447 {
 448     BOOL fullscreen = (self-&gt;fullscreenWindow != nil);
 449     if (fullscreen == NO)
 450     {
 451         [super sendEvent:theEvent];
 452     }
 453     else
 454     {
 455         [self-&gt;fullscreenWindow sendEvent:theEvent];
 456     }
 457 }
 458 
 459 
 460 @end
 461 
 462 #pragma mark --- Dispatcher
 463 
 464 // TODO: re-implement using Obj-C blocks ?
 465 static jlong _createWindowCommonDo(JNIEnv *env, jobject jWindow, jlong jOwnerPtr, jlong jScreenPtr, jint jStyleMask, jboolean jIsChild)
 466 {
 467     GlassWindow *window = nil;
 468 
 469     NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
 470     {
 471         NSUInteger styleMask = NSBorderlessWindowMask;
 472         // only titled windows get title
 473         if ((jStyleMask&amp;com_sun_glass_ui_Window_TITLED) != 0)
 474         {
 475             styleMask = styleMask|NSTitledWindowMask;
 476         }
 477 
 478         bool isUtility = (jStyleMask &amp; com_sun_glass_ui_Window_UTILITY) != 0;
 479         bool isPopup = (jStyleMask &amp; com_sun_glass_ui_Window_POPUP) != 0;
 480 
 481         // only nontransparent windows get decorations
 482         if ((jStyleMask&amp;com_sun_glass_ui_Window_TRANSPARENT) == 0)
 483         {
 484             if ((jStyleMask&amp;com_sun_glass_ui_Window_CLOSABLE) != 0)
 485             {
 486                 styleMask = styleMask|NSClosableWindowMask;
 487             }
 488 
 489             if (((jStyleMask&amp;com_sun_glass_ui_Window_MINIMIZABLE) != 0) ||
 490                 ((jStyleMask&amp;com_sun_glass_ui_Window_MAXIMIZABLE) != 0))
 491             {
 492                 // on Mac OS X there is one set for min/max buttons,
 493                 // so if clients requests either one, we turn them both on
 494                 styleMask = styleMask|NSMiniaturizableWindowMask;
 495             }
 496 
 497             if ((jStyleMask&amp;com_sun_glass_ui_Window_UNIFIED) != 0) {
 498                 styleMask = styleMask|NSTexturedBackgroundWindowMask;
 499             }
 500 
 501             if (isUtility)
 502             {
 503                 styleMask = styleMask | NSUtilityWindowMask | NSNonactivatingPanelMask;
 504             }
 505         }
 506 
 507         if (isPopup)
 508         {
 509             // can receive keyboard input without activating the owning application
 510             styleMask = styleMask|NSNonactivatingPanelMask;
 511         }
 512 
 513         // initial size must be 0x0 otherwise we don&#39;t get resize update if the initial size happens to be the exact same size as the later programatical one!
 514         CGFloat x = 0.0f;
 515         CGFloat y = 0.0f;
 516         CGFloat w = 0.0f;
 517         CGFloat h = 0.0f;
 518 
 519         NSScreen *screen = (NSScreen*)jlong_to_ptr(jScreenPtr);
 520         window = [[GlassWindow alloc] _initWithContentRect:NSMakeRect(x, y, w, h) styleMask:styleMask screen:screen jwindow:jWindow jIsChild:jIsChild];
 521 
 522         if ((jStyleMask &amp; com_sun_glass_ui_Window_UNIFIED) != 0) {
 523             //Prevent the textured effect from disappearing on border thickness recalculation
 524             [window-&gt;nsWindow setAutorecalculatesContentBorderThickness:NO forEdge:NSMaxYEdge];
 525         }
 526 
 527         if ((jStyleMask &amp; com_sun_glass_ui_Window_UTILITY) != 0) {
 528             [[window-&gt;nsWindow standardWindowButton:NSWindowMiniaturizeButton] setHidden:YES];
 529             [[window-&gt;nsWindow standardWindowButton:NSWindowZoomButton] setHidden:YES];
 530             if (!jOwnerPtr) {
 531                 [window-&gt;nsWindow setLevel:NSNormalWindowLevel];
 532             }
 533         }
 534 
 535         if (jIsChild == JNI_FALSE)
 536         {
 537             if (jOwnerPtr != 0L)
 538             {
 539                 window-&gt;owner = getGlassWindow(env, jOwnerPtr)-&gt;nsWindow; // not retained (use weak reference?)
 540             }
 541         }
 542         else
 543         {
 544             if ((jOwnerPtr != 0L) &amp;&amp; (jOwnerPtr != BROWSER_PARENT_ID))
 545             {
 546                 GlassEmbeddedWindow *parent = getGlassEmbeddedWindow(env, jOwnerPtr);
 547                 GlassEmbeddedWindow *ewindow = (GlassEmbeddedWindow*)window-&gt;nsWindow;
 548                 parent-&gt;child = ewindow; // not retained (use weak reference?)
 549 
 550                 ewindow-&gt;parent = parent; // not retained (use weak reference?)
 551             }
 552         }
 553         window-&gt;isResizable = NO;
 554         window-&gt;isDecorated = (jStyleMask&amp;com_sun_glass_ui_Window_TITLED) != 0;
 555         /* 10.7 full screen window support */
 556         if ([NSWindow instancesRespondToSelector:@selector(toggleFullScreen:)]) {
 557             NSWindowCollectionBehavior behavior = [window-&gt;nsWindow collectionBehavior];
 558             if (!isPopup &amp;&amp; !isUtility &amp;&amp; !window-&gt;owner)
 559             {
 560                 // Only ownerless windows should have the Full Screen Toggle control
 561                 behavior |= (1 &lt;&lt; 7) /* NSWindowCollectionBehaviorFullScreenPrimary */;
 562             }
 563             else
 564             {
 565                 // Other windows are only allowed to be shown together with a primary
 566                 // full screen window
 567                 behavior |= (1 &lt;&lt; 8) /* NSWindowCollectionBehaviorFullScreenAuxiliary */;
 568             }
 569             [window-&gt;nsWindow setCollectionBehavior: behavior];
 570         }
 571 
 572         window-&gt;isTransparent = (jStyleMask &amp; com_sun_glass_ui_Window_TRANSPARENT) != 0;
 573         if (window-&gt;isTransparent == YES)
 574         {
 575             [window-&gt;nsWindow setBackgroundColor:[NSColor clearColor]];
 576             [window-&gt;nsWindow setHasShadow:NO];
 577             [window-&gt;nsWindow setOpaque:NO];
 578         }
 579         else
 580         {
 581             [window-&gt;nsWindow setHasShadow:YES];
 582             [window-&gt;nsWindow setOpaque:YES];
 583         }
 584 
 585         window-&gt;fullscreenWindow = nil;
 586 
 587         window-&gt;isSizeAssigned = NO;
 588         window-&gt;isLocationAssigned = NO;
 589 
 590         if (jIsChild == JNI_TRUE &amp;&amp; jOwnerPtr != 0L &amp;&amp; jOwnerPtr != BROWSER_PARENT_ID
 591             &amp;&amp; [window-&gt;nsWindow isKindOfClass:[GlassEmbeddedWindow class]])
 592         {
 593             GlassEmbeddedWindow* parent = ((GlassEmbeddedWindow*)window-&gt;nsWindow)-&gt;parent;
 594             if ([GlassEmbeddedWindow exists:parent])
 595             {
 596                 window-&gt;isLocationAssigned = YES;
 597                 NSScreen *pscreen = [[NSScreen screens] objectAtIndex:0];
 598                 NSRect screenFrame = pscreen.frame;
 599                 NSRect frameRect = parent.frame;
 600                 int invy = (int)round(screenFrame.size.height - frameRect.size.height - frameRect.origin.y);
 601                 [window _setBounds:(int)round(frameRect.origin.x)
 602                                  y:invy
 603                               xSet:YES ySet:YES w:0 h:0 cw:0 ch:0];
 604             }
 605         }
 606     }
 607     [pool drain];
 608 
 609     GLASS_CHECK_EXCEPTION(env);
 610 
 611     return ptr_to_jlong(window-&gt;nsWindow);
 612 }
 613 
 614 static jlong _createWindowCommon
 615 (JNIEnv *env, jobject jWindow, jlong jOwnerPtr, jlong jScreenPtr, jint jStyleMask, jboolean jIsChild)
 616 {
 617     LOG(&quot;_createWindowCommon&quot;);
 618 
 619     jlong value = 0L;
 620 
 621     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
 622     GLASS_POOL_ENTER;
 623     {
 624         jobject jWindowRef = (*env)-&gt;NewGlobalRef(env, jWindow);
 625         value = _createWindowCommonDo(env, jWindowRef, jOwnerPtr, jScreenPtr, jStyleMask, jIsChild);
 626     }
 627     GLASS_POOL_EXIT;
 628     GLASS_CHECK_EXCEPTION(env);
 629 
 630     LOG(&quot;   window: %p&quot;, value);
 631     return value;
 632 }
 633 
 634 #pragma mark --- JNI
 635 
 636 /*
 637  * Class:     com_sun_glass_ui_mac_MacWindow
 638  * Method:    _initIDs
 639  * Signature: ()V
 640  */
 641 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacWindow__1initIDs
 642 (JNIEnv *env, jclass jClass)
 643 {
 644     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1initIDs&quot;);
 645 
 646     if (jWindowClass == NULL)
 647     {
 648         jWindowClass = (*env)-&gt;NewGlobalRef(env, jClass);
 649     }
 650 
 651     if (jMenuBarDelegateClass == NULL)
 652     {
 653         jclass cls = [GlassHelper ClassForName:&quot;com.sun.glass.ui.mac.MacMenuBarDelegate&quot; withEnv:env];
 654         if (!cls) {
 655             return;
 656         }
 657         jMenuBarDelegateClass = (*env)-&gt;NewGlobalRef(env, cls);
 658     }
 659 
 660     if (jViewClass == NULL)
 661     {
 662         jclass cls = [GlassHelper ClassForName:&quot;com.sun.glass.ui.View&quot; withEnv:env];
 663         if (!cls) {
 664             return;
 665         }
 666         jViewClass = (*env)-&gt;NewGlobalRef(env, cls);
 667     }
 668 
 669     if (jScreenClass == NULL)
 670     {
 671         jclass cls = [GlassHelper ClassForName:&quot;com.sun.glass.ui.Screen&quot; withEnv:env];
 672         if (!cls) {
 673             return;
 674         }
 675         jScreenClass = (*env)-&gt;NewGlobalRef(env, cls);
 676     }
 677 
 678     if (jWindowNotifyMove == NULL)
 679     {
 680         jWindowNotifyMove = (*env)-&gt;GetMethodID(env, jWindowClass, &quot;notifyMove&quot;, &quot;(IIZ)V&quot;);
 681         if ((*env)-&gt;ExceptionCheck(env)) return;
 682     }
 683 
 684     if (jWindowNotifyResize == NULL)
 685     {
 686         jWindowNotifyResize = (*env)-&gt;GetMethodID(env, jWindowClass, &quot;notifyResize&quot;, &quot;(III)V&quot;);
 687         if ((*env)-&gt;ExceptionCheck(env)) return;
 688     }
 689 
 690     if (jWindowNotifyMoveToAnotherScreen == NULL)
 691     {
 692         jWindowNotifyMoveToAnotherScreen = (*env)-&gt;GetMethodID(env, jWindowClass, &quot;notifyMoveToAnotherScreen&quot;, &quot;(Lcom/sun/glass/ui/Screen;)V&quot;);
 693         if ((*env)-&gt;ExceptionCheck(env)) return;
 694     }
 695 
 696     if (jWindowNotifyScaleChanged == NULL)
 697     {
 698         jWindowNotifyScaleChanged = (*env)-&gt;GetMethodID(env, jWindowClass, &quot;notifyScaleChanged&quot;, &quot;(FFFF)V&quot;);
 699         if ((*env)-&gt;ExceptionCheck(env)) return;
 700     }
 701 
 702     if (jWindowNotifyClose == NULL)
 703     {
 704         jWindowNotifyClose = (*env)-&gt;GetMethodID(env, jWindowClass, &quot;notifyClose&quot;, &quot;()V&quot;);
 705         if ((*env)-&gt;ExceptionCheck(env)) return;
 706     }
 707 
 708     if (jWindowNotifyFocus == NULL)
 709     {
 710         jWindowNotifyFocus = (*env)-&gt;GetMethodID(env, jWindowClass, &quot;notifyFocus&quot;, &quot;(I)V&quot;);
 711         if ((*env)-&gt;ExceptionCheck(env)) return;
 712     }
 713 
 714     if (jWindowNotifyFocusUngrab == NULL)
 715     {
 716         jWindowNotifyFocusUngrab = (*env)-&gt;GetMethodID(env, jWindowClass, &quot;notifyFocusUngrab&quot;, &quot;()V&quot;);
 717         if ((*env)-&gt;ExceptionCheck(env)) return;
 718     }
 719 
 720     if (jWindowNotifyFocusDisabled == NULL)
 721     {
 722         jWindowNotifyFocusDisabled = (*env)-&gt;GetMethodID(env, jWindowClass, &quot;notifyFocusDisabled&quot;, &quot;()V&quot;);
 723         if ((*env)-&gt;ExceptionCheck(env)) return;
 724     }
 725 
 726     if (jWindowNotifyDestroy == NULL)
 727     {
 728         jWindowNotifyDestroy = (*env)-&gt;GetMethodID(env, jWindowClass, &quot;notifyDestroy&quot;, &quot;()V&quot;);
 729         if ((*env)-&gt;ExceptionCheck(env)) return;
 730     }
 731 
 732     if (jWindowNotifyDelegatePtr == NULL)
 733     {
 734         jWindowNotifyDelegatePtr = (*env)-&gt;GetMethodID(env, jWindowClass, &quot;notifyDelegatePtr&quot;, &quot;(J)V&quot;);
 735     }
 736 }
 737 
 738 /*
 739  * Class:     com_sun_glass_ui_mac_MacWindow
 740  * Method:    _createWindow
 741  * Signature: (JJI)J
 742  */
 743 JNIEXPORT jlong JNICALL Java_com_sun_glass_ui_mac_MacWindow__1createWindow
 744 (JNIEnv *env, jobject jWindow, jlong jOwnerPtr, jlong jScreenPtr, jint jStyleMask)
 745 {
 746     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1createWindow&quot;);
 747 
 748     return _createWindowCommon(env, jWindow, jOwnerPtr, jScreenPtr, jStyleMask, JNI_FALSE);
 749 }
 750 
 751 /*
 752  * Class:     com_sun_glass_ui_mac_MacWindow
 753  * Method:    _createChildWindow
 754  * Signature: (J)J
 755  */
 756 JNIEXPORT jlong JNICALL Java_com_sun_glass_ui_mac_MacWindow__1createChildWindow
 757 (JNIEnv *env, jobject jWindow, jlong jOwnerPtr)
 758 {
 759     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1createChildWindow&quot;);
 760     LOG(&quot;   owner: %p&quot;, jOwnerPtr);
 761 
 762     jlong jScreenPtr = 0L;
 763     jint jStyleMask = NSBorderlessWindowMask;
 764     if (jOwnerPtr == BROWSER_PARENT_ID)
 765     {
 766         LOG(&quot;       case PARENT (PLUGIN)&quot;);
 767         // special case: embedded window for plugin (the container which will hold the child window)
 768     }
 769     else
 770     {
 771         LOG(&quot;       case CHILD (EMBEDDED)&quot;);
 772         // special case: embedded window for plugin (the actual plugin window with remote layer)
 773         // jOwnerPtr must be a valid GlassEmbeddedWindow instance
 774         if (![GlassEmbeddedWindow exists:(GlassEmbeddedWindow*)jlong_to_ptr(jOwnerPtr)]) {
 775             return (jlong)0;
 776         }
 777     }
 778 
 779     return _createWindowCommon(env, jWindow, jOwnerPtr, jScreenPtr, jStyleMask, JNI_TRUE);
 780 }
 781 
 782 /*
 783  * Class:     com_sun_glass_ui_mac_MacWindow
 784  * Method:    _setLevel
 785  * Signature: (JI)V
 786  */
 787 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacWindow__1setLevel
 788 (JNIEnv *env, jobject jWindow, jlong jPtr, jint jLevel)
 789 {
 790     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1setLevel&quot;);
 791     if (!jPtr) return;
 792 
 793     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
 794     GLASS_POOL_ENTER;
 795     {
 796         GlassWindow *window = getGlassWindow(env, jPtr);
 797         NSInteger level = NSNormalWindowLevel;
 798         switch (jLevel)
 799         {
 800             case com_sun_glass_ui_Window_Level_FLOATING:
 801                 level = NSFloatingWindowLevel;
 802                 break;
 803             case com_sun_glass_ui_Window_Level_TOPMOST:
 804                 level = NSScreenSaverWindowLevel;
 805                 break;
 806         }
 807         [window-&gt;nsWindow setLevel:level];
 808     }
 809     GLASS_POOL_EXIT;
 810     GLASS_CHECK_EXCEPTION(env);
 811 }
 812 
 813 /*
 814  * Class:     com_sun_glass_ui_mac_MacWindow
 815  * Method:    _setFocusable
 816  * Signature: (Z)V
 817  */
 818 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacWindow__1setFocusable
 819 (JNIEnv *env, jobject jWindow, jlong jPtr, jboolean isFocusable)
 820 {
 821     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1setCanBecomeActive&quot;);
 822     if (!jPtr) return;
 823 
 824     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
 825     GLASS_POOL_ENTER;
 826     {
 827         GlassWindow *window = getGlassWindow(env, jPtr);
 828         window-&gt;isFocusable = (isFocusable==JNI_TRUE);
 829     }
 830     GLASS_POOL_EXIT;
 831     GLASS_CHECK_EXCEPTION(env);
 832 }
 833 
 834 /*
 835  * Class:     com_sun_glass_ui_mac_MacWindow
 836  * Method:    _setEnabled
 837  * Signature: (JZ)V
 838  */
 839 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacWindow__1setEnabled
 840 (JNIEnv *env, jobject jwindow, jlong jPtr, jboolean isEnabled)
 841 {
 842     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1setEnabled&quot;);
 843     if (!jPtr) return;
 844 
 845     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
 846     GLASS_POOL_ENTER;
 847     {
 848         GlassWindow *window = getGlassWindow(env, jPtr);
 849         window-&gt;isEnabled = (BOOL)isEnabled;
 850         NSButton *zoomButton = [window-&gt;nsWindow standardWindowButton:NSWindowZoomButton];
 851         if ((window-&gt;isEnabled) &amp;&amp; (window-&gt;isResizable)){
 852             [window-&gt;nsWindow setStyleMask: window-&gt;enabledStyleMask];
 853             if (window-&gt;enabledStyleMask &amp; NSResizableWindowMask) {
 854                 [zoomButton setEnabled:YES];
 855             }
 856         }
 857         else if((window-&gt;isEnabled) &amp;&amp; (!window-&gt;isResizable)){
 858             [window-&gt;nsWindow setStyleMask:
 859                 (window-&gt;enabledStyleMask &amp; ~(NSUInteger) NSResizableWindowMask)];
 860             [zoomButton setEnabled:NO];
 861         }
 862         else{
 863             window-&gt;enabledStyleMask = [window-&gt;nsWindow styleMask];
 864             [window-&gt;nsWindow setStyleMask:
 865                 (window-&gt;enabledStyleMask &amp; ~(NSUInteger)(NSMiniaturizableWindowMask | NSResizableWindowMask))];
 866             [zoomButton setEnabled:NO];
 867         }
 868     }
 869     GLASS_POOL_EXIT;
 870     GLASS_CHECK_EXCEPTION(env);
 871 }
 872 
 873 /*
 874  * Class:     com_sun_glass_ui_mac_MacWindow
 875  * Method:    _setAlpha
 876  * Signature: (F)V
 877  */
 878 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacWindow__1setAlpha
 879 (JNIEnv *env, jobject jWindow, jlong jPtr, jfloat jAlpha)
 880 {
 881     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1setAlpha&quot;);
 882     if (!jPtr) return;
 883 
 884     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
 885     GLASS_POOL_ENTER;
 886     {
 887         GlassWindow *window = getGlassWindow(env, jPtr);
 888         [window-&gt;nsWindow setAlphaValue:jAlpha];
 889     }
 890     GLASS_POOL_EXIT;
 891     GLASS_CHECK_EXCEPTION(env);
 892 }
 893 
 894 /*
 895  * Class:     com_sun_glass_ui_mac_MacWindow
 896  * Method:    _setBackground
 897  * Signature: (JFFF)Z
 898  */
 899 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_mac_MacWindow__1setBackground
 900 (JNIEnv *env, jobject jWindow, jlong jPtr, jfloat r, jfloat g, jfloat b)
 901 {
 902     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1setBackground&quot;);
 903     if (!jPtr) return JNI_FALSE;
 904 
 905     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
 906     GLASS_POOL_ENTER;
 907     {
 908         GlassWindow *window = getGlassWindow(env, jPtr);
 909         [window-&gt;nsWindow setBackgroundColor:[NSColor colorWithCalibratedRed:r green:g blue:b alpha:1.0f]];
 910     }
 911     GLASS_POOL_EXIT;
 912     GLASS_CHECK_EXCEPTION(env);
 913 
 914     return JNI_TRUE; // gznote: remove this return value if unused
 915 }
 916 
 917 /*
 918  * Class:     com_sun_glass_ui_mac_MacWindow
 919  * Method:    _setView
 920  * Signature: (J)Z
 921  */
 922 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_mac_MacWindow__1setView
 923 (JNIEnv *env, jobject jWindow, jlong jPtr, jobject jview)
 924 {
 925     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1setView&quot;);
 926     LOG(&quot;   window: %p&quot;, jPtr);
 927     LOG(&quot;   view: %p&quot;, getMacView(env, jview));
 928     if (!jPtr) return JNI_FALSE;
 929 
 930     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
 931     GLASS_POOL_ENTER;
 932     {
 933         GlassWindow *window = getGlassWindow(env, jPtr);
 934 
 935         // We don&#39;t support changing views in the FS mode because
 936         // by Glass design the FS functionality belongs to the View.
 937         // Also, this leads to a crash on the Mac
 938         if ([window-&gt;nsWindow styleMask] &amp; (1 &lt;&lt; 14)/*NSFullScreenWindowMask*/) {
 939             [window-&gt;nsWindow performSelector:@selector(toggleFullScreen:) withObject:nil];
 940 
 941             // Wait until the FS mode has really exited
 942             [GlassApplication enterFullScreenExitingLoop];
 943         }
 944 
 945         NSView&lt;GlassView&gt; *oldView = window-&gt;view;
 946         window-&gt;view = getMacView(env, jview);
 947         //NSLog(@&quot;        window: %@&quot;, window);
 948         //NSLog(@&quot;                frame: %.2f,%.2f %.2fx%.2f&quot;, [window frame].origin.x, [window frame].origin.y, [window frame].size.width, [window frame].size.height);
 949         //NSLog(@&quot;        view: %@&quot;, window-&gt;view);
 950         //NSLog(@&quot;                frame: %.2f,%.2f %.2fx%.2f&quot;, [window-&gt;view frame].origin.x, [window-&gt;view frame].origin.y, [window-&gt;view frame].size.width, [window-&gt;view frame].size.height);
 951 
 952         // Make sure we synchronize scale factors to the new view as any
 953         // dynamic updates might have happened when we had the old view
 954         // and/or we may have been set visible before we had a view and
 955         // missed the initial notification.
 956         if ([window-&gt;nsWindow screen]) {
 957             [window-&gt;view notifyScaleFactorChanged:GetScreenScaleFactor([window-&gt;nsWindow screen])];
 958         }
 959 
 960         if (oldView &amp;&amp; oldView != window-&gt;view) {
 961             [[oldView delegate] resetMouseTracking];
 962         }
 963 
 964         if (window-&gt;view != nil)
 965         {
 966             CALayer *layer = [window-&gt;view layer];
 967             if (([layer isKindOfClass:[CAOpenGLLayer class]] == YES) &amp;&amp;
 968                 (([window-&gt;nsWindow styleMask] &amp; NSTexturedBackgroundWindowMask) == NO))
 969             {
 970                 [((CAOpenGLLayer*)layer) setOpaque:[window-&gt;nsWindow isOpaque]];
 971             }
 972 
 973             window-&gt;suppressWindowMoveEvent = YES; // RT-11215
 974             {
 975                 NSRect viewFrame = [window-&gt;view frame];
 976                 if ((viewFrame.size.width != 0.0f) &amp;&amp; (viewFrame.size.height != 0.0f))
 977                 {
 978                     NSRect windowFrame = [window-&gt;nsWindow frameRectForContentRect:viewFrame];
 979                     windowFrame.origin.x = [window-&gt;nsWindow frame].origin.x;
 980                     windowFrame.origin.y = [window-&gt;nsWindow frame].origin.y;
 981                     [window _setWindowFrameWithRect:NSMakeRect(windowFrame.origin.x, windowFrame.origin.y, windowFrame.size.width, windowFrame.size.height) withDisplay:JNI_TRUE withAnimate:JNI_FALSE];
 982                 }
 983 
 984                 [window-&gt;nsWindow setContentView:[window-&gt;view superview]]; // use our superview not ourselves!
 985                 [window-&gt;nsWindow setInitialFirstResponder:window-&gt;view];
 986                 [window-&gt;nsWindow makeFirstResponder:window-&gt;view];
 987             }
 988             window-&gt;suppressWindowMoveEvent = NO;
 989         }
 990         else
 991         {
 992             [window-&gt;nsWindow performSelectorOnMainThread:@selector(setContentView:) withObject:nil waitUntilDone:YES];
 993         }
 994     }
 995     GLASS_POOL_EXIT;
 996     GLASS_CHECK_EXCEPTION(env);
 997 
 998     return JNI_TRUE; // gznote: remove this return value if unused
 999 }
1000 
1001 /*
1002  * Class:     com_sun_glass_ui_mac_MacWindow
1003  * Method:    _setMenubar
1004  * Signature: (Lcom/sun/glass/ui/mac/MacMenubarDelegate;)V
1005  */
1006 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_mac_MacWindow__1setMenubar
1007 (JNIEnv *env, jobject jWindow, jlong jPtr, jlong jMenubarPtr)
1008 {
1009     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1setMenubar&quot;);
1010     if (!jPtr) return JNI_FALSE;
1011 
1012     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1013     GLASS_POOL_ENTER;
1014     {
1015         GlassWindow *window = getGlassWindow(env, jPtr);
1016         window-&gt;menubar = (GlassMenubar*)jlong_to_ptr(jMenubarPtr);
1017         [NSApp setMainMenu:window-&gt;menubar-&gt;menu];
1018         [[NSApp mainMenu] update];
1019     }
1020     GLASS_POOL_EXIT;
1021     GLASS_CHECK_EXCEPTION(env);
1022 
1023     return JNI_TRUE; // gznote: remove this return value if unused
1024 }
1025 
1026 /*
1027  * Class:     com_sun_glass_ui_mac_MacWindow
1028  * Method:    _close
1029  * Signature: ()V
1030  */
1031 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_mac_MacWindow__1close
1032 (JNIEnv *env, jclass cls, jlong jPtr)
1033 {
1034     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1close&quot;);
1035     if (!jPtr) return JNI_FALSE;
1036 
1037     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1038     GLASS_POOL_ENTER;
1039     {
1040         GlassWindow *window = getGlassWindow(env, jPtr);
1041         // this call will always close the window
1042         // without calling the windowShouldClose
1043 
1044         // RT-39813 When closing a window as the result of a global right-click
1045         //          mouse event outside the bounds of the window, using an immediate
1046         //          [window-&gt;nsWindow close] crashes the JDK as the AppKit at this
1047         //          point still has another [NSWindow _resignKeyFocus] from the
1048         //          right-click handling in [NSApplication sendEvent].  This defers
1049         //          the close until the [NSWindow _resignKeyFocus] can be performed.
1050 
1051         [window-&gt;nsWindow performSelectorOnMainThread:@selector(close) withObject:nil waitUntilDone:NO];
1052 
1053         // The NSWindow will be automatically released after closing
1054         // The GlassWindow is released in the [NSWindow dealloc] override
1055     }
1056     GLASS_POOL_EXIT;
1057     GLASS_CHECK_EXCEPTION(env);
1058 
1059     return JNI_TRUE; // gznote: remove this return value if unused
1060 }
1061 
1062 /*
1063  * Class:     com_sun_glass_ui_mac_MacWindow
1064  * Method:    _requestFocus
1065  * Signature: (J)Z
1066  */
1067 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_mac_MacWindow__1requestFocus
1068 (JNIEnv *env, jobject jWindow, jlong jPtr)
1069 {
1070     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1requestFocus&quot;);
1071     if (!jPtr) return JNI_FALSE;
1072 
1073     jboolean focused = JNI_FALSE;
1074 
1075     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1076     GLASS_POOL_ENTER;
1077     {
1078         GlassWindow *window = getGlassWindow(env, jPtr);
1079 
1080         if ([window-&gt;nsWindow isVisible])
1081         {
1082             [window-&gt;nsWindow makeMainWindow];
1083             [window-&gt;nsWindow makeKeyAndOrderFront:window-&gt;nsWindow];
1084             [window-&gt;nsWindow orderFrontRegardless];
1085         }
1086 
1087         focused = [window-&gt;nsWindow isKeyWindow] ? JNI_TRUE : JNI_FALSE;
1088     }
1089     GLASS_POOL_EXIT;
1090     GLASS_CHECK_EXCEPTION(env);
1091 
1092     return focused;
1093 }
1094 
1095 /*
1096  * Class:     com_sun_glass_ui_mac_MacWindow
1097  * Method:    _grabFocus
1098  * Signature: (J)Z
1099  */
1100 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_mac_MacWindow__1grabFocus
1101 (JNIEnv *env, jobject jThis, jlong jPtr)
1102 {
1103     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1grabFocus&quot;);
1104     if (!jPtr) return JNI_FALSE;
1105 
1106     jboolean ret = JNI_FALSE;
1107 
1108     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1109     GLASS_POOL_ENTER;
1110     {
1111         GlassWindow * window = getGlassWindow(env, jPtr);
1112         //TODO: full screen
1113         [window _grabFocus];
1114         ret = JNI_TRUE;
1115     }
1116     GLASS_POOL_EXIT;
1117     GLASS_CHECK_EXCEPTION(env);
1118 
1119     return ret;
1120 }
1121 
1122 /*
1123  * Class:     com_sun_glass_ui_mac_MacWindow
1124  * Method:    _ungrabFocus
1125  * Signature: (J)V
1126  */
1127 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacWindow__1ungrabFocus
1128 (JNIEnv *env, jobject jThis, jlong jPtr)
1129 {
1130     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1ungrabFocus&quot;);
1131     if (!jPtr) return;
1132 
1133     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1134     GLASS_POOL_ENTER;
1135     {
1136         GlassWindow * window = getGlassWindow(env, jPtr);
1137         //TODO; full screen
1138         [window _ungrabFocus];
1139     }
1140     GLASS_POOL_EXIT;
1141     GLASS_CHECK_EXCEPTION(env);
1142 }
1143 
1144 /*
1145  * Class:     com_sun_glass_ui_mac_MacWindow
1146  * Method:    _maximize
1147  * Signature: (JZZ)V
1148  */
1149 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_mac_MacWindow__1maximize
1150 (JNIEnv *env, jobject jWindow, jlong jPtr, jboolean maximize, jboolean isZoomed)
1151 {
1152     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1maximize&quot;);
1153     if (!jPtr) return JNI_FALSE;
1154 
1155     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1156     GLASS_POOL_ENTER;
1157     {
1158         GlassWindow *window = getGlassWindow(env, jPtr);
1159         window-&gt;suppressWindowResizeEvent = YES;
1160 
1161         if ((maximize == JNI_TRUE) &amp;&amp; (isZoomed == JNI_FALSE))
1162         {
1163             window-&gt;preZoomedRect = [window-&gt;nsWindow frame];
1164 
1165             if ([window-&gt;nsWindow styleMask] != NSBorderlessWindowMask)
1166             {
1167                 [window-&gt;nsWindow zoom:nil];
1168                 // windowShouldZoom will be called automatically in this case
1169             }
1170             else
1171             {
1172                 NSRect visibleRect = [[window _getScreen] visibleFrame];
1173                 [window _setWindowFrameWithRect:NSMakeRect(visibleRect.origin.x, visibleRect.origin.y, visibleRect.size.width, visibleRect.size.height) withDisplay:JNI_TRUE withAnimate:JNI_TRUE];
1174 
1175                 // calling windowShouldZoom will send Java maximize event
1176                 [window windowShouldZoom:window-&gt;nsWindow toFrame:[window-&gt;nsWindow frame]];
1177             }
1178         }
1179         else if ((maximize == JNI_FALSE) &amp;&amp; (isZoomed == JNI_TRUE))
1180         {
1181             [window _restorePreZoomedRect];
1182         }
1183 
1184         window-&gt;suppressWindowResizeEvent = NO;
1185     }
1186     GLASS_POOL_EXIT;
1187     GLASS_CHECK_EXCEPTION(env);
1188 
1189     return JNI_TRUE; // gznote: remove this return value if unused
1190 }
1191 
1192 /*
1193  * Class:     com_sun_glass_ui_mac_MacWindow
1194  * Method:    _setBounds
1195  * Signature: (JIIZZIIIIFF)V
1196  */
1197 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacWindow__1setBounds2
1198 (JNIEnv *env, jobject jWindow, jlong jPtr,
1199  jint x, jint y, jboolean xSet, jboolean ySet,
1200  jint w, jint h, jint cw, jint ch, jfloat xGravity, jfloat yGravity)
1201 {
1202     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1setBounds&quot;);
1203     LOG(&quot;   x,y: %d,%d&quot;, x, y);
1204     LOG(&quot;   xSet,ySet: %d,%d&quot;, xSet, ySet);
1205     LOG(&quot;   xGravity,yGravity: %.2f,%.2f&quot;, xGravity, yGravity);
1206     LOG(&quot;   w x h: %dx%d&quot;, w, h);
1207     LOG(&quot;   cw x ch: %dx%d&quot;, cw, ch);
1208     if (!jPtr) return;
1209 
1210     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1211     GLASS_POOL_ENTER;
1212     {
1213         GlassWindow *window = getGlassWindow(env, jPtr);
1214         if (xSet || ySet) window-&gt;isLocationAssigned = YES;
1215         if (w &gt; 0 || h &gt; 0 || cw &gt; 0 || ch &gt; 0) window-&gt;isSizeAssigned = YES;
1216         [window _setBounds:x y:y xSet:xSet ySet:ySet w:w h:h cw:cw ch:ch];
1217     }
1218     GLASS_POOL_EXIT;
1219     GLASS_CHECK_EXCEPTION(env);
1220 }
1221 
1222 /*
1223  * Class:     com_sun_glass_ui_mac_MacWindow
1224  * Method:    _setMinimumSize
1225  * Signature: (JII)Z
1226  */
1227 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_mac_MacWindow__1setMinimumSize
1228 (JNIEnv *env, jobject jWindow, jlong jPtr, jint jW, jint jH)
1229 {
1230     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1setMinimumSize&quot;);
1231     if (!jPtr) return JNI_FALSE;
1232 
1233     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1234     GLASS_POOL_ENTER;
1235     {
1236         GlassWindow *window = getGlassWindow(env, jPtr);
1237         [window-&gt;nsWindow setMinSize:NSMakeSize(jW, jH)];
1238     }
1239     GLASS_POOL_EXIT;
1240     GLASS_CHECK_EXCEPTION(env);
1241 
1242     return JNI_TRUE; // gznote: remove this return value if unused
1243 }
1244 
1245 /*
1246  * Class:     com_sun_glass_ui_mac_MacWindow
1247  * Method:    _setMaximumSize
1248  * Signature: (JII)Z
1249  */
1250 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_mac_MacWindow__1setMaximumSize
1251 (JNIEnv *env, jobject jWindow, jlong jPtr, jint jW, jint jH)
1252 {
1253     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1setMaximumSize&quot;);
1254     if (!jPtr) return JNI_FALSE;
1255 
1256     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1257     GLASS_POOL_ENTER;
1258     {
1259         GlassWindow *window = getGlassWindow(env, jPtr);
1260         [window-&gt;nsWindow setMaxSize:NSMakeSize(jW == -1 ? FLT_MAX : (CGFloat)jW,
1261                                                 jH == -1 ? FLT_MAX : (CGFloat)jH)];
1262     }
1263     GLASS_POOL_EXIT;
1264     GLASS_CHECK_EXCEPTION(env);
1265 
1266     return JNI_TRUE; // gznote: remove this return value if unused
1267 }
1268 
1269 /*
1270  * Class:     com_sun_glass_ui_mac_MacWindow
1271  * Method:    _setResizable
1272  * Signature: (Z)Z
1273  */
1274 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_mac_MacWindow__1setResizable
1275 (JNIEnv *env, jobject jWindow, jlong jPtr, jboolean jResizable)
1276 {
1277     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1setResizable&quot;);
1278     if (!jPtr) return JNI_FALSE;
1279 
1280     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1281     GLASS_POOL_ENTER;
1282     {
1283         GlassWindow *window = getGlassWindow(env, jPtr);
1284         if (window-&gt;isResizable != jResizable)
1285         {
1286             [window performSelectorOnMainThread:@selector(_setResizable) withObject:nil waitUntilDone:YES];
1287         }
1288     }
1289     GLASS_POOL_EXIT;
1290     GLASS_CHECK_EXCEPTION(env);
1291 
1292     return JNI_TRUE;
1293 }
1294 
1295 /*
1296  * Class:     com_sun_glass_ui_mac_MacWindow
1297  * Method:    _setVisible
1298  * Signature: (Z)Z
1299  */
1300 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_mac_MacWindow__1setVisible
1301 (JNIEnv *env, jobject jWindow, jlong jPtr, jboolean jVisible)
1302 {
1303     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1setVisible: %d&quot;, jVisible);
1304     LOG(&quot;   window: %p&quot;, jPtr);
1305     if (!jPtr) return JNI_FALSE;
1306 
1307     jboolean now = JNI_FALSE;
1308 
1309     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1310     GLASS_POOL_ENTER;
1311     {
1312         GlassWindow *window = getGlassWindow(env, jPtr);
1313         if (jVisible == JNI_TRUE)
1314         {
1315             if (!window-&gt;isLocationAssigned) {
1316                 [window _setBounds:0 y:0 xSet:JNI_TRUE ySet:JNI_TRUE w:-1 h:-1 cw:-1 ch:-1];
1317             }
1318             if (!window-&gt;isSizeAssigned) {
1319                 [window _setBounds:0 y:0 xSet:JNI_FALSE ySet:JNI_FALSE w:320 h:200 cw:-1 ch:-1];
1320             }
1321             [window _setVisible];
1322         }
1323         else
1324         {
1325             [window _ungrabFocus];
1326             if (window-&gt;owner != nil)
1327             {
1328                 LOG(&quot;   removeChildWindow: %p&quot;, window);
1329                 [window-&gt;owner removeChildWindow:window-&gt;nsWindow];
1330             }
1331             [window-&gt;nsWindow orderOut:window-&gt;nsWindow];
1332         }
1333         now = [window-&gt;nsWindow isVisible] ? JNI_TRUE : JNI_FALSE;
1334 
1335         // RT-22502 temp workaround: bring plugin window in front of a browser
1336         if (now == YES)
1337         {
1338             static BOOL isBackgroundOnlyAppChecked = NO;
1339             static BOOL isBackgroundOnlyApp = NO;
1340             if (isBackgroundOnlyAppChecked == NO)
1341             {
1342                 isBackgroundOnlyAppChecked = YES;
1343 
1344                 ProcessSerialNumber psn;
1345                 if (GetCurrentProcess(&amp;psn) == noErr)
1346                 {
1347                     ProcessInfoRec info;
1348                     memset(&amp;info, 0x00, sizeof(ProcessInfoRec));
1349                     GetProcessInformation(&amp;psn, &amp;info);
1350                     isBackgroundOnlyApp = ((modeOnlyBackground&amp;info.processMode) == modeOnlyBackground);
1351                 }
1352             }
1353             if (isBackgroundOnlyApp == YES)
1354             {
1355                 [window-&gt;nsWindow performSelectorOnMainThread:@selector(orderFrontRegardless) withObject:nil waitUntilDone:YES];
1356             }
1357         }
1358     }
1359     GLASS_POOL_EXIT;
1360     GLASS_CHECK_EXCEPTION(env);
1361 
1362     return now;
1363 }
1364 
1365 /*
1366  * Class:     com_sun_glass_ui_mac_MacWindow
1367  * Method:    _setTitle
1368  * Signature: (Ljava/lang/String;)Z
1369  */
1370 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_mac_MacWindow__1setTitle
1371 (JNIEnv *env, jobject jWindow, jlong jPtr, jstring jTitle)
1372 {
1373     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1setTitle&quot;);
1374     LOG(&quot;   window: %p&quot;, jPtr);
1375     if (!jPtr) return JNI_FALSE;
1376 
1377     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1378     GLASS_POOL_ENTER;
1379     {
1380         GlassWindow *window = getGlassWindow(env, jPtr);
1381 
1382         NSString *title = [GlassHelper nsStringWithJavaString:jTitle withEnv:env];
1383         LOG(&quot;   title: %s&quot;, [title UTF8String]);
1384         [window-&gt;nsWindow setTitle:title];
1385     }
1386     GLASS_POOL_EXIT;
1387     GLASS_CHECK_EXCEPTION(env);
1388 
1389     return JNI_TRUE; // gnote: remove this return value if unused
1390 }
1391 
1392 /*
1393  * Class:     com_sun_glass_ui_mac_MacWindow
1394  * Method:    _minimize
1395  * Signature: (Z)V
1396  */
1397 JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_mac_MacWindow__1minimize
1398 (JNIEnv *env, jobject jWindow, jlong jPtr, jboolean jMiniaturize)
1399 {
1400     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1minimize&quot;);
1401     if (!jPtr) return JNI_FALSE;
1402 
1403     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1404     GLASS_POOL_ENTER;
1405     {
1406         GlassWindow *window = getGlassWindow(env, jPtr);
1407 
<a name="2" id="anc2"></a><span class="line-added">1408         NSUInteger styleMask = [window-&gt;nsWindow styleMask];</span>
<span class="line-added">1409         BOOL isMiniaturizable = (styleMask &amp; NSMiniaturizableWindowMask) != 0;</span>
<span class="line-added">1410 </span>
<span class="line-added">1411         // if the window does not have NSMiniaturizableWindowMask set</span>
<span class="line-added">1412         // we need to temporarily set it to allow the window to</span>
<span class="line-added">1413         // be programmatically minimized or restored.</span>
<span class="line-added">1414         if (!isMiniaturizable) {</span>
<span class="line-added">1415             [window-&gt;nsWindow setStyleMask: styleMask | NSMiniaturizableWindowMask];</span>
<span class="line-added">1416         }</span>
<span class="line-added">1417 </span>
1418         if (jMiniaturize == JNI_TRUE)
1419         {
1420             [window-&gt;nsWindow miniaturize:nil];
1421         }
1422         else
1423         {
1424             [window-&gt;nsWindow deminiaturize:nil];
1425         }
<a name="3" id="anc3"></a><span class="line-added">1426 </span>
<span class="line-added">1427         // Restore the state of NSMiniaturizableWindowMask</span>
<span class="line-added">1428         if (!isMiniaturizable) {</span>
<span class="line-added">1429             [window-&gt;nsWindow setStyleMask: styleMask];</span>
<span class="line-added">1430         }</span>
<span class="line-added">1431 </span>
1432     }
1433     GLASS_POOL_EXIT;
1434     GLASS_CHECK_EXCEPTION(env);
1435 
1436     return JNI_TRUE; // gnote: remove this return value if unused
1437 }
1438 
1439 /*
1440  * Class:     com_sun_glass_ui_mac_MacWindow
1441  * Method:    _setIcon
1442  * Signature: (JLjava/nio/ByteBuffer;II)V
1443  */
1444 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacWindow__1setIcon
1445 (JNIEnv *env, jobject jWindow, jlong jPtr, jobject iconBuffer, jint jWidth, jint jHeight)
1446 {
1447     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1setIcon&quot;);
1448     if (!jPtr) return;
1449 
1450     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1451     GLASS_POOL_ENTER;
1452     {
1453         GlassWindow *window = getGlassWindow(env, jPtr);
1454 
1455         if (iconBuffer)
1456         {
1457             NSImage *image = nil;
1458 
1459             image = getImage(
1460                         (*env)-&gt;GetDirectBufferAddress(env, iconBuffer),
1461                         jHeight, jWidth, 0);
1462 
1463             if (image != nil) {
1464                 // need an explicit window title for the rest of the code to work
1465                 if ([window-&gt;nsWindow title] == nil)
1466                 {
1467                     [window-&gt;nsWindow setTitle:@&quot;Untitled&quot;];
1468                 }
1469 
1470                 // http://www.cocoabuilder.com/archive/cocoa/199554-nswindow-title-bar-icon-without-representedurl.html
1471                 [window-&gt;nsWindow setRepresentedURL:[NSURL fileURLWithPath:[window-&gt;nsWindow title]]];
1472                 [[window-&gt;nsWindow standardWindowButton:NSWindowDocumentIconButton] setImage:image];
1473                 [image release];
1474             } else {
1475                 [[window-&gt;nsWindow standardWindowButton:NSWindowDocumentIconButton] setImage:nil];
1476             }
1477         } else {
1478             [[window-&gt;nsWindow standardWindowButton:NSWindowDocumentIconButton] setImage:nil];
1479         }
1480     }
1481     GLASS_POOL_EXIT;
1482     GLASS_CHECK_EXCEPTION(env);
1483 }
1484 
1485 /*
1486  * Class:     com_sun_glass_ui_mac_MacWindow
1487  * Method:    _toFront
1488  * Signature: (J)V
1489  */
1490 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacWindow__1toFront
1491 (JNIEnv *env, jobject jWindow, jlong jPtr)
1492 {
1493     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1toFront&quot;);
1494     LOG(&quot;   window: %p&quot;, jPtr);
1495     if (!jPtr) return;
1496 
1497     GLASS_POOL_ENTER;
1498     {
1499         GlassWindow *window = getGlassWindow(env, jPtr);
1500         [window-&gt;nsWindow orderFrontRegardless];
1501     }
1502     GLASS_POOL_EXIT;
1503     GLASS_CHECK_EXCEPTION(env);
1504 }
1505 
1506 /*
1507  * Class:     com_sun_glass_ui_mac_MacWindow
1508  * Method:    _toBack
1509  * Signature: (J)V
1510  */
1511 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacWindow__1toBack
1512 (JNIEnv *env, jobject jWindow, jlong jPtr)
1513 {
1514     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1toBack&quot;);
1515     if (!jPtr) return;
1516 
1517     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1518     GLASS_POOL_ENTER;
1519     {
1520         GlassWindow *window = getGlassWindow(env, jPtr);
1521         [window-&gt;nsWindow orderBack:nil];
1522     }
1523     GLASS_POOL_EXIT;
1524     GLASS_CHECK_EXCEPTION(env);
1525 }
1526 
1527 
1528 /*
1529  * Class:     com_sun_glass_ui_mac_MacWindow
1530  * Method:    _enterModal
1531  * Signature: (J)V
1532  */
1533 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacWindow__1enterModal
1534 (JNIEnv *env, jobject jWindow, jlong jPtr)
1535 {
1536     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1enterModal&quot;);
1537     if (!jPtr) return;
1538 
1539     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1540     GLASS_POOL_ENTER;
1541     {
1542         GlassWindow *window = getGlassWindow(env, jPtr);
1543         [NSApp runModalForWindow:window-&gt;nsWindow];
1544     }
1545     GLASS_POOL_EXIT;
1546     GLASS_CHECK_EXCEPTION(env);
1547 }
1548 
1549 /*
1550  * Class:     com_sun_glass_ui_mac_MacWindow
1551  * Method:    _enterModalWithWindow
1552  * Signature: (JJ)V
1553  */
1554 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacWindow__1enterModalWithWindow
1555 (JNIEnv *env, jobject jWindow, jlong jDialogPtr, jlong jWindowPtr)
1556 {
1557     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1enterModalWithWindow&quot;);
1558 
1559     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1560     GLASS_POOL_ENTER;
1561     {
1562         //GlassWindow *window = getGlassWindow(env, jDialogPtr);
1563         // TODO: implement _enterModalWithWindow
1564     }
1565     GLASS_POOL_EXIT;
1566     GLASS_CHECK_EXCEPTION(env);
1567 }
1568 
1569 /*
1570  * Class:     com_sun_glass_ui_mac_MacWindow
1571  * Method:    _exitModal
1572  * Signature: (J)V
1573  */
1574 JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacWindow__1exitModal
1575 (JNIEnv *env, jobject jWindow, jlong jPtr)
1576 {
1577     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1exitModal&quot;);
1578     if (!jPtr) return;
1579 
1580     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1581     GLASS_POOL_ENTER;
1582     {
1583         GlassWindow *window = getGlassWindow(env, jPtr);
1584         [NSApp stop:window-&gt;nsWindow];
1585     }
1586     GLASS_POOL_EXIT;
1587     GLASS_CHECK_EXCEPTION(env);
1588 }
1589 
1590 /*
1591  * Class:     com_sun_glass_ui_mac_MacWindow
1592  * Method:    _getEmbeddedX
1593  * Signature: (J)I
1594  */
1595 JNIEXPORT jint JNICALL Java_com_sun_glass_ui_mac_MacWindow__1getEmbeddedX
1596 (JNIEnv *env, jobject jWindow, jlong jPtr)
1597 {
1598     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1getEmbeddedX&quot;);
1599     if (!jPtr) return 0;
1600 
1601     jint x = 0;
1602 
1603     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1604     GLASS_POOL_ENTER;
1605     {
1606         GlassEmbeddedWindow *window = getGlassEmbeddedWindow(env, jPtr);
1607         x = (int)round([window frame].origin.x);
1608     }
1609     GLASS_POOL_EXIT;
1610     GLASS_CHECK_EXCEPTION(env);
1611 
1612     return x;
1613 }
1614 
1615 /*
1616  * Class:     com_sun_glass_ui_mac_MacWindow
1617  * Method:    _getEmbeddedY
1618  * Signature: (J)I
1619  */
1620 JNIEXPORT jint JNICALL Java_com_sun_glass_ui_mac_MacWindow__1getEmbeddedY
1621 (JNIEnv *env, jobject jWindow, jlong jPtr)
1622 {
1623     LOG(&quot;Java_com_sun_glass_ui_mac_MacWindow__1getEmbeddedY&quot;);
1624     if (!jPtr) return 0;
1625 
1626     jint y = 0;
1627 
1628     GLASS_ASSERT_MAIN_JAVA_THREAD(env);
1629     GLASS_POOL_ENTER;
1630     {
1631         GlassEmbeddedWindow *window = getGlassEmbeddedWindow(env, jPtr);
1632         NSRect frameRect = [window frame];
1633 
1634         // flip y coordinate
1635         NSScreen *screen = [[NSScreen screens] objectAtIndex:0];
1636         NSRect screenFrame = screen.frame;
1637         y = (int)round(screenFrame.size.height - frameRect.size.height - frameRect.origin.y);
1638     }
1639     GLASS_POOL_EXIT;
1640     GLASS_CHECK_EXCEPTION(env);
1641 
1642     return y;
1643 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
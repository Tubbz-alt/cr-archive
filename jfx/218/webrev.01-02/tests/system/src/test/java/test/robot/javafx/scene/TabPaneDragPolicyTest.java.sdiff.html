<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff tests/system/src/test/java/test/robot/javafx/scene/TabPaneDragPolicyTest.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../launchertest/ModuleLauncherTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../sandbox/Constants.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>tests/system/src/test/java/test/robot/javafx/scene/TabPaneDragPolicyTest.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package test.robot.javafx.scene;
 26 


 27 import javafx.application.Application;
 28 import javafx.application.Platform;
 29 import javafx.collections.ListChangeListener;
 30 import javafx.scene.Scene;
 31 import javafx.scene.control.Tab;
 32 import javafx.scene.control.TabPane;
 33 import javafx.scene.input.MouseButton;
 34 import javafx.scene.robot.Robot;
 35 import javafx.stage.Stage;
 36 import javafx.stage.StageStyle;
 37 import javafx.stage.WindowEvent;
 38 import javafx.geometry.Side;
 39 
 40 import java.util.concurrent.CountDownLatch;
 41 import java.util.concurrent.TimeUnit;
 42 
 43 import org.junit.After;
 44 import org.junit.AfterClass;
 45 import org.junit.Assert;
 46 import org.junit.Before;
 47 import org.junit.BeforeClass;
 48 import org.junit.Test;
 49 import static org.junit.Assert.fail;

 50 
 51 import test.util.Util;
 52 
 53 /*
 54  * Unit test for verifying DragPolicies.
 55  *
 56  * There are 8 tests in this file.
 57  * Steps of 4 tests for DragPolicy.REORDER
 58  * 1. Create TabPane with 4 tabs.
 59  * 2. Drag tab0 to last after tab3.
 60  * 3. Verify that tab1 is the first tab after reorder.
 61  * 4. Verify that a correct permutation change event is received.
 62  * 5. Verify that getTabs() is also reordered correctly.
 63  * Repeat the test for four Sides.
 64  *
 65  * Steps of 4 tests for DragPolicy.FIXED
 66  * 1. Create TabPane with 4 tabs.
 67  * 2. Drag tab0 to last after tab3, the tab0 should not get dragged.
 68  * 3. Verify that tab0 is still the first tab.
 69  * 4. Verify that permutation change event is not received.
</pre>
<hr />
<pre>
121 
122     public static void main(String[] args) {
123         initFX();
124         TabPaneDragPolicyTest test = new TabPaneDragPolicyTest();
125 
126         test.testReorderTop();
127         test.testReorderBottom();
128         test.testReorderLeft();
129         test.testReorderRight();
130 
131         test.testFixedTop();
132         test.testFixedBottom();
133         test.testFixedLeft();
134         test.testFixedRight();
135 
136         exit();
137     }
138 
139     @Test
140     public void testReorderTop() {


141         expectedTab = tabs[1];
142         setDragPolicyAndSide(TabPane.TabDragPolicy.REORDER, Side.TOP);
143         tabPane.getTabs().addListener(reorderListener);
144         testReorder(DX, DY, 1, 0, false);
145         tabPane.getTabs().removeListener(reorderListener);
146         selectedTab = (Tab)tabPane.getSelectionModel().getSelectedItem();
147         Assert.assertEquals(&quot;Expected &quot; + expectedTab.getText() + &quot; to be &quot;
148             + &quot;first tab after reordering.&quot;, expectedTab.getText(), selectedTab.getText());
149         Assert.assertTrue(&quot;Incorrect permutation change received&quot;, listenerTestResult);
150     }
151 
152     @Test
153     public void testReorderBottom() {


154         expectedTab = tabs[1];
155         setDragPolicyAndSide(TabPane.TabDragPolicy.REORDER, Side.BOTTOM);
156         tabPane.getTabs().addListener(reorderListener);
157         testReorder(DX, SCENE_HEIGHT - DY, 1, 0, false);
158         tabPane.getTabs().removeListener(reorderListener);
159         selectedTab = (Tab)tabPane.getSelectionModel().getSelectedItem();
160         Assert.assertEquals(&quot;Expected &quot; + expectedTab.getText() + &quot; to be &quot;
161             + &quot;first tab after reordering.&quot;, expectedTab.getText(), selectedTab.getText());
162         Assert.assertTrue(&quot;Incorrect permutation change received&quot;, listenerTestResult);
163     }
164 
165     @Test
166     public void testReorderLeft() {


167         expectedTab = tabs[1];
168         setDragPolicyAndSide(TabPane.TabDragPolicy.REORDER, Side.LEFT);
169         tabPane.getTabs().addListener(reorderListener);
170         testReorder(DX, DY, 0, 1, false);
171         tabPane.getTabs().removeListener(reorderListener);
172         selectedTab = (Tab)tabPane.getSelectionModel().getSelectedItem();
173         Assert.assertEquals(&quot;Expected &quot; + expectedTab.getText() + &quot; to be &quot;
174             + &quot;first tab after reordering.&quot;, expectedTab.getText(), selectedTab.getText());
175         Assert.assertTrue(&quot;Incorrect permutation change received&quot;, listenerTestResult);
176     }
177 
178     @Test
179     public void testReorderRight() {


180         expectedTab = tabs[1];
181         setDragPolicyAndSide(TabPane.TabDragPolicy.REORDER, Side.RIGHT);
182         tabPane.getTabs().addListener(reorderListener);
183         testReorder(SCENE_WIDTH - DX, DY, 0, 1, false);
184         tabPane.getTabs().removeListener(reorderListener);
185         selectedTab = (Tab)tabPane.getSelectionModel().getSelectedItem();
186         Assert.assertEquals(&quot;Expected &quot; + expectedTab.getText() + &quot; to be &quot;
187             + &quot;first tab after reordering.&quot;, expectedTab.getText(), selectedTab.getText());
188         Assert.assertTrue(&quot;Incorrect permutation change received&quot;, listenerTestResult);
189     }
190 
191     @Test
192     public void testFixedTop() {
193         expectedTab = tabs[0];
194         listenerTestResult = true;
195         setDragPolicyAndSide(TabPane.TabDragPolicy.FIXED, Side.TOP);
196         tabPane.getTabs().addListener(fixedListener);
197         testReorder(DX, DY, 1, 0, true);
198         tabPane.getTabs().removeListener(fixedListener);
199         selectedTab = (Tab)tabPane.getSelectionModel().getSelectedItem();
</pre>
<hr />
<pre>
273                     robot.mouseMove((int)(scene.getWindow().getX() + scene.getX() + dX) + c,
274                         (int)(scene.getWindow().getY() + scene.getY() + dY));
275                 } else {
276                     // Left &amp; Right
277                     robot.mouseMove((int)(scene.getWindow().getX() + scene.getX() + dX),
278                         (int)(scene.getWindow().getY() + scene.getY() + dY) + c);
279                 }
280                 moveLatch.countDown();
281             });
282             waitForLatch(moveLatch, 5, &quot;Timeout waiting for robot.mouseMove(023).&quot;);
283         }
284 
285         CountDownLatch releaseLatch = new CountDownLatch(1);
286         Platform.runLater(() -&gt; {
287             robot.mouseRelease(MouseButton.PRIMARY);
288             releaseLatch.countDown();
289         });
290         waitForLatch(releaseLatch, 5, &quot;Timeout waiting for robot.mouseRelease(Robot.MOUSE_LEFT_BTN).&quot;);
291 
292         if (isFixed) {
<span class="line-modified">293             tabPane.getSelectionModel().select(tabs[2]);</span>
294             waitForLatch(latches[2], 5, &quot;Timeout waiting tabs[2] to get selected.&quot;);
295             latches[0] = new CountDownLatch(1);
296         }
297 
298         Platform.runLater(() -&gt; {
299             robot.mouseMove((int)(scene.getWindow().getX() + scene.getX() + dX),
300                 (int)(scene.getWindow().getY() + scene.getY() + dY));
301             robot.mousePress(MouseButton.PRIMARY);
302             robot.mouseRelease(MouseButton.PRIMARY);
303         });
304 
305         if (isFixed) {
306             // For FIXED drag policy, tabs[0] should remain the first tab.
307             try {
308                 Thread.sleep(500); // Wait for ChangeListener to get called.
309             } catch (Exception ex) {
310                 fail(&quot;Thread was interrupted.&quot; + ex);
311             }
312             waitForLatch(latches[0], 5, &quot;Timeout waiting tabs[0] to get selected.&quot;);
313         } else {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package test.robot.javafx.scene;
 26 
<span class="line-added"> 27 import com.sun.javafx.PlatformUtil;</span>
<span class="line-added"> 28 </span>
 29 import javafx.application.Application;
 30 import javafx.application.Platform;
 31 import javafx.collections.ListChangeListener;
 32 import javafx.scene.Scene;
 33 import javafx.scene.control.Tab;
 34 import javafx.scene.control.TabPane;
 35 import javafx.scene.input.MouseButton;
 36 import javafx.scene.robot.Robot;
 37 import javafx.stage.Stage;
 38 import javafx.stage.StageStyle;
 39 import javafx.stage.WindowEvent;
 40 import javafx.geometry.Side;
 41 
 42 import java.util.concurrent.CountDownLatch;
 43 import java.util.concurrent.TimeUnit;
 44 
 45 import org.junit.After;
 46 import org.junit.AfterClass;
 47 import org.junit.Assert;
 48 import org.junit.Before;
 49 import org.junit.BeforeClass;
 50 import org.junit.Test;
 51 import static org.junit.Assert.fail;
<span class="line-added"> 52 import static org.junit.Assume.assumeTrue;</span>
 53 
 54 import test.util.Util;
 55 
 56 /*
 57  * Unit test for verifying DragPolicies.
 58  *
 59  * There are 8 tests in this file.
 60  * Steps of 4 tests for DragPolicy.REORDER
 61  * 1. Create TabPane with 4 tabs.
 62  * 2. Drag tab0 to last after tab3.
 63  * 3. Verify that tab1 is the first tab after reorder.
 64  * 4. Verify that a correct permutation change event is received.
 65  * 5. Verify that getTabs() is also reordered correctly.
 66  * Repeat the test for four Sides.
 67  *
 68  * Steps of 4 tests for DragPolicy.FIXED
 69  * 1. Create TabPane with 4 tabs.
 70  * 2. Drag tab0 to last after tab3, the tab0 should not get dragged.
 71  * 3. Verify that tab0 is still the first tab.
 72  * 4. Verify that permutation change event is not received.
</pre>
<hr />
<pre>
124 
125     public static void main(String[] args) {
126         initFX();
127         TabPaneDragPolicyTest test = new TabPaneDragPolicyTest();
128 
129         test.testReorderTop();
130         test.testReorderBottom();
131         test.testReorderLeft();
132         test.testReorderRight();
133 
134         test.testFixedTop();
135         test.testFixedBottom();
136         test.testFixedLeft();
137         test.testFixedRight();
138 
139         exit();
140     }
141 
142     @Test
143     public void testReorderTop() {
<span class="line-added">144         // Disable on Mac until JDK-8213136 is fixed</span>
<span class="line-added">145         assumeTrue(!PlatformUtil.isMac());</span>
146         expectedTab = tabs[1];
147         setDragPolicyAndSide(TabPane.TabDragPolicy.REORDER, Side.TOP);
148         tabPane.getTabs().addListener(reorderListener);
149         testReorder(DX, DY, 1, 0, false);
150         tabPane.getTabs().removeListener(reorderListener);
151         selectedTab = (Tab)tabPane.getSelectionModel().getSelectedItem();
152         Assert.assertEquals(&quot;Expected &quot; + expectedTab.getText() + &quot; to be &quot;
153             + &quot;first tab after reordering.&quot;, expectedTab.getText(), selectedTab.getText());
154         Assert.assertTrue(&quot;Incorrect permutation change received&quot;, listenerTestResult);
155     }
156 
157     @Test
158     public void testReorderBottom() {
<span class="line-added">159         // Disable on Mac until JDK-8213136 is fixed</span>
<span class="line-added">160         assumeTrue(!PlatformUtil.isMac());</span>
161         expectedTab = tabs[1];
162         setDragPolicyAndSide(TabPane.TabDragPolicy.REORDER, Side.BOTTOM);
163         tabPane.getTabs().addListener(reorderListener);
164         testReorder(DX, SCENE_HEIGHT - DY, 1, 0, false);
165         tabPane.getTabs().removeListener(reorderListener);
166         selectedTab = (Tab)tabPane.getSelectionModel().getSelectedItem();
167         Assert.assertEquals(&quot;Expected &quot; + expectedTab.getText() + &quot; to be &quot;
168             + &quot;first tab after reordering.&quot;, expectedTab.getText(), selectedTab.getText());
169         Assert.assertTrue(&quot;Incorrect permutation change received&quot;, listenerTestResult);
170     }
171 
172     @Test
173     public void testReorderLeft() {
<span class="line-added">174         // Disable on Mac until JDK-8213136 is fixed</span>
<span class="line-added">175         assumeTrue(!PlatformUtil.isMac());</span>
176         expectedTab = tabs[1];
177         setDragPolicyAndSide(TabPane.TabDragPolicy.REORDER, Side.LEFT);
178         tabPane.getTabs().addListener(reorderListener);
179         testReorder(DX, DY, 0, 1, false);
180         tabPane.getTabs().removeListener(reorderListener);
181         selectedTab = (Tab)tabPane.getSelectionModel().getSelectedItem();
182         Assert.assertEquals(&quot;Expected &quot; + expectedTab.getText() + &quot; to be &quot;
183             + &quot;first tab after reordering.&quot;, expectedTab.getText(), selectedTab.getText());
184         Assert.assertTrue(&quot;Incorrect permutation change received&quot;, listenerTestResult);
185     }
186 
187     @Test
188     public void testReorderRight() {
<span class="line-added">189         // Disable on Mac until JDK-8213136 is fixed</span>
<span class="line-added">190         assumeTrue(!PlatformUtil.isMac());</span>
191         expectedTab = tabs[1];
192         setDragPolicyAndSide(TabPane.TabDragPolicy.REORDER, Side.RIGHT);
193         tabPane.getTabs().addListener(reorderListener);
194         testReorder(SCENE_WIDTH - DX, DY, 0, 1, false);
195         tabPane.getTabs().removeListener(reorderListener);
196         selectedTab = (Tab)tabPane.getSelectionModel().getSelectedItem();
197         Assert.assertEquals(&quot;Expected &quot; + expectedTab.getText() + &quot; to be &quot;
198             + &quot;first tab after reordering.&quot;, expectedTab.getText(), selectedTab.getText());
199         Assert.assertTrue(&quot;Incorrect permutation change received&quot;, listenerTestResult);
200     }
201 
202     @Test
203     public void testFixedTop() {
204         expectedTab = tabs[0];
205         listenerTestResult = true;
206         setDragPolicyAndSide(TabPane.TabDragPolicy.FIXED, Side.TOP);
207         tabPane.getTabs().addListener(fixedListener);
208         testReorder(DX, DY, 1, 0, true);
209         tabPane.getTabs().removeListener(fixedListener);
210         selectedTab = (Tab)tabPane.getSelectionModel().getSelectedItem();
</pre>
<hr />
<pre>
284                     robot.mouseMove((int)(scene.getWindow().getX() + scene.getX() + dX) + c,
285                         (int)(scene.getWindow().getY() + scene.getY() + dY));
286                 } else {
287                     // Left &amp; Right
288                     robot.mouseMove((int)(scene.getWindow().getX() + scene.getX() + dX),
289                         (int)(scene.getWindow().getY() + scene.getY() + dY) + c);
290                 }
291                 moveLatch.countDown();
292             });
293             waitForLatch(moveLatch, 5, &quot;Timeout waiting for robot.mouseMove(023).&quot;);
294         }
295 
296         CountDownLatch releaseLatch = new CountDownLatch(1);
297         Platform.runLater(() -&gt; {
298             robot.mouseRelease(MouseButton.PRIMARY);
299             releaseLatch.countDown();
300         });
301         waitForLatch(releaseLatch, 5, &quot;Timeout waiting for robot.mouseRelease(Robot.MOUSE_LEFT_BTN).&quot;);
302 
303         if (isFixed) {
<span class="line-modified">304             Util.runAndWait(() -&gt; tabPane.getSelectionModel().select(tabs[2]));</span>
305             waitForLatch(latches[2], 5, &quot;Timeout waiting tabs[2] to get selected.&quot;);
306             latches[0] = new CountDownLatch(1);
307         }
308 
309         Platform.runLater(() -&gt; {
310             robot.mouseMove((int)(scene.getWindow().getX() + scene.getX() + dX),
311                 (int)(scene.getWindow().getY() + scene.getY() + dY));
312             robot.mousePress(MouseButton.PRIMARY);
313             robot.mouseRelease(MouseButton.PRIMARY);
314         });
315 
316         if (isFixed) {
317             // For FIXED drag policy, tabs[0] should remain the first tab.
318             try {
319                 Thread.sleep(500); // Wait for ChangeListener to get called.
320             } catch (Exception ex) {
321                 fail(&quot;Thread was interrupted.&quot; + ex);
322             }
323             waitForLatch(latches[0], 5, &quot;Timeout waiting tabs[0] to get selected.&quot;);
324         } else {
</pre>
</td>
</tr>
</table>
<center><a href="../../../launchertest/ModuleLauncherTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../../../sandbox/Constants.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
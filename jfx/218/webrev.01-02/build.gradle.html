<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New build.gradle</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /**
  27  * The main build script for JavaFX.
  28  *
  29  * MUST FIX tasks to complete:
  30  *  - build check -- making sure the final artifact has the right bits
  31  *      - some things worth automatically sanity checking:
  32  *          - are there images in the javadocs?
  33  *          - are all of the expected dylibs etc there?
  34  *  - Perform sanity checking to make sure a JDK exists with javac, etc
  35  *  - Support building with no known JDK location, as long as javac, etc are on the path
  36  *  - Check all of the native flags. We&#39;re adding weight to some libs that don&#39;t need it, and so forth.
  37  *
  38  * Additional projects to work on as we go:
  39  *  - Add &quot;developer debug&quot;. This is where the natives do not have debug symbols, but the Java code does
  40  *  - The genVSproperties.bat doesn&#39;t find the directory where RC.exe lives. So it is hard coded. Might be a problem.
  41  *  - special tasks for common needs, such as:
  42  *      - updating copyright headers
  43  *      - stripping trailing whitespace (?)
  44  *  - checkstyle
  45  *  - findbugs
  46  *  - re needs?
  47  *  - sqe testing
  48  *  - API change check
  49  *  - Pushing results to a repo?
  50  *  - ServiceWithSecurityManagerTest fails to complete when run from gradle.
  51  *  - Integrate Parfait reports for C code
  52  *  - FXML Project tests are not running
  53  */
  54 defaultTasks = [&quot;sdk&quot;]
  55 
  56 import java.util.concurrent.CountDownLatch
  57 import java.util.concurrent.ExecutorService
  58 import java.util.concurrent.Executors
  59 import java.util.concurrent.Future
  60 
  61 /******************************************************************************
  62  *                              Utility methods                               *
  63  *****************************************************************************/
  64 
  65 /**
  66  * If the given named property is not defined, then this method will define
  67  * it with the given defaultValue. Any properties defined by this method can
  68  * be substituted on the command line by using -P, or by specifying a
  69  * gradle.properties file in the user home dir
  70  *
  71  * @param name The name of the property to define
  72  * @param defaultValue The default value to assign the property
  73  */
  74 void defineProperty(String name, String defaultValue) {
  75     if (!project.hasProperty(name)) {
  76         project.ext.set(name, defaultValue);
  77     }
  78 }
  79 
  80 /**
  81  * If the given named property is not defined, then this method will attempt to
  82  * look up the property in the props map, and use the defaultValue if it cannot be found.
  83  *
  84  * @param name The name of the property to look up and/or define
  85  * @param props The properties to look for the named property in, if it has not already been defined
  86  * @param defaultValue The default value if the property has not been defined and the
  87  *                     props map does not contain the named property
  88  */
  89 void defineProperty(String name, Properties props, String defaultValue) {
  90     if (!project.hasProperty(name)) {
  91         project.ext.set(name, props.getProperty(name, defaultValue));
  92     }
  93 }
  94 
  95 /**
  96  * Converts cygwin style paths to windows style paths, but with a forward slash.
  97  * This method is safe to call from any platform, and will only do work if
  98  * called on Windows (in all other cases it simply returns the supplied path.
  99  *
 100  * @param path the path to convert
 101  * @return the path converted to windows style, if on windows, otherwise it
 102  *         is the supplied path.
 103  */
 104 String cygpath(String path) {
 105     if (!IS_WINDOWS) return path;
 106     if (path == null || &quot;&quot;.equals(path)) return path;
 107     String ret = path.replaceAll(&#39;\\\\&#39;, &#39;/&#39;)
 108     logger.info(&quot;Converting path &#39;$path&#39; via cygpath to &quot;+ret)
 109     return ret
 110 }
 111 
 112 /**
 113  * Converts cygwin file paths for java executables to windows style
 114  * executable paths by changing forward slashes to back slashes and
 115  * adding the &#39;.exe&#39; extension.
 116  * This method is safe to call from any platform, and will only do work if
 117  * called on Windows (in all other cases it simply returns the supplied path).
 118  *
 119  * @param path the path to convert
 120  * @return the path converted to windows style, if on windows, otherwise it
 121  *         is the supplied path.
 122  */
 123 String cygpathExe(String path) {
 124     if (!IS_WINDOWS) return path;
 125     if (path == null || &quot;&quot;.equals(path)) return path;
 126     String ret = path.replaceAll(&#39;/&#39;, &#39;\\\\&#39;)
 127     logger.info(&quot;Converting path &#39;$path&#39; via cygpath to &quot;+ret)
 128     return ret + &quot;.exe&quot;
 129 }
 130 
 131 void loadProperties(String sourceFileName) {
 132     def config = new Properties()
 133     def propFile = new File(sourceFileName)
 134     if (propFile.canRead()) {
 135         config.load(new FileInputStream(propFile))
 136         for (java.util.Map.Entry property in config) {
 137             def keySplit = property.key.split(&quot;\\.&quot;);
 138             def key = keySplit[0];
 139             for (int i = 1; i &lt; keySplit.length; i++) {
 140                 key = key + keySplit[i].capitalize();
 141             }
 142             ext[key] = property.value;
 143         }
 144     }
 145 }
 146 
 147 /**
 148  * Struct used to contain some information passed to the closure
 149  * passed to compileTargets.
 150  */
 151 class CompileTarget {
 152     String name;
 153     String upper;
 154     String capital;
 155 }
 156 
 157 /**
 158  * Iterates over each of the compile targets, passing the given closure
 159  * a CompileTarget instance.
 160  *
 161  * @param c The closure to call
 162  */
 163 void compileTargets(Closure c) {
 164     if (COMPILE_TARGETS == &quot;&quot;) {
 165         return
 166     }
 167     COMPILE_TARGETS.split(&quot;,&quot;).each { target -&gt;
 168         CompileTarget ct = new CompileTarget();
 169         ct.name = target;
 170         ct.upper = target.trim().toUpperCase(Locale.ROOT)
 171         ct.capital = target.trim().capitalize()
 172         c(ct)
 173     }
 174 }
 175 
 176 /**
 177  * Manages the execution of some closure which is responsible for producing
 178  * content for a properties file built at build time and stored in the
 179  * root project&#39;s $buildDir, and then loading that properties file and
 180  * passing it to the processor closure.
 181  *
 182  * This is used on windows to produce a properties file containing all the
 183  * windows visual studio paths and environment variables, and on Linux
 184  * for storing the results of pkg-config calls.
 185  *
 186  * @param name the name of the file to produce
 187  * @param loader a closure which is invoked, given the properties file. This
 188  *        closure is invoked only if the properties file needs to be created
 189  *        and is responsible for populating the properties file.
 190  * @param processor a closure which is invoked every time this method is
 191  *        called and which will be given a Properties object, fully populated.
 192  *        The processor is then responsible for doing whatever it is that it
 193  *        must do with those properties (such as setting up environment
 194  *        variables used in subsequent native builds, or whatnot).
 195  */
 196 void setupTools(String name, Closure loader, Closure processor) {
 197     // Check to see whether $buildDir/$name.properties file exists. If not,
 198     // then generate it. Once generated, we need to read the properties file to
 199     // help us define the defaults for this block of properties
 200     File propFile = file(&quot;$buildDir/${name}.properties&quot;);
 201     if (!propFile.exists()) {
 202         // Create the properties file
 203         propFile.getParentFile().mkdirs();
 204         propFile.createNewFile();
 205         loader(propFile);
 206     }
 207 
 208     // Try reading the properties in order to define the properties. If the property file cannot
 209     // be located, then we will throw an exception because we cannot guess these values
 210     InputStream propStream = null;
 211     try {
 212         Properties properties = new Properties();
 213         propStream = new FileInputStream(propFile);
 214         properties.load(propStream);
 215         processor(properties);
 216     } finally {
 217         try { propStream.close() } catch (Exception e) { }
 218     }
 219 }
 220 
 221 String[] parseJavaVersion(String jRuntimeVersion) {
 222     def jVersion = jRuntimeVersion.split(&quot;[-\\+]&quot;)[0]
 223     def tmpBuildNumber = &quot;0&quot;
 224     if (jVersion.startsWith(&quot;1.&quot;)) {
 225         // This is a pre-JEP-223 version string
 226         def dashbIdx = jRuntimeVersion.lastIndexOf(&quot;-b&quot;)
 227         if (dashbIdx != -1) {
 228             tmpBuildNumber = jRuntimeVersion.substring(dashbIdx + 2)
 229         }
 230     } else {
 231         // This is a post-JEP-223 version string
 232         def plusIdx = jRuntimeVersion.indexOf(&quot;+&quot;)
 233         if (plusIdx != -1) {
 234             tmpBuildNumber = jRuntimeVersion.substring(plusIdx + 1)
 235         }
 236     }
 237     def jBuildNumber = tmpBuildNumber.split(&quot;[-\\+]&quot;)[0]
 238     def versionInfo = new String[2];
 239     versionInfo[0] = jVersion
 240     versionInfo[1] = jBuildNumber
 241     return versionInfo
 242 }
 243 
 244 /**
 245  * Fails the build with the specified error message
 246  *
 247  * @param msg the reason for the failure
 248  */
 249 void fail(String msg) {
 250     throw new GradleException(&quot;FAIL: &quot; + msg);
 251 }
 252 
 253 /******************************************************************************
 254  *                                                                            *
 255  *                   Definition of project properties                         *
 256  *                                                                            *
 257  *  All properties defined using ext. are immediately available throughout    *
 258  *  the script as variables that can be used. These variables are attached    *
 259  *  to the root project (whereas if they were defined as def variables then   *
 260  *  they would only be available within the root project scope).              *
 261  *                                                                            *
 262  *  All properties defined using the &quot;defineProperty&quot; method can be replaced  *
 263  *  on the command line by using the -P flag. For example, to override the    *
 264  *  location of the binary plug, you would specify -PBINARY_PLUG=some/where   *
 265  *                                                                            *
 266  *****************************************************************************/
 267 
 268 // If the ../rt-closed directory exists, then we are doing a closed build.
 269 // In this case, build and property files will be read from
 270 // ../rt-closed/closed-build.gradle and ../rt-closed/closed-properties.gradle
 271 // respectively
 272 
 273 def closedDir = file(&quot;../rt-closed&quot;)
 274 def buildClosed = closedDir.isDirectory()
 275 ext.BUILD_CLOSED = buildClosed
 276 
 277 ext.RUNARGSFILE = &quot;run.args&quot;
 278 ext.COMPILEARGSFILE = &quot;compile.args&quot;
 279 ext.RUNJAVAPOLICYFILE = &#39;run.java.policy&#39;
 280 
 281 ext.TESTCOMPILEARGSFILE = &quot;testcompile.args&quot;
 282 ext.TESTRUNARGSFILE = &quot;testrun.args&quot;
 283 ext.TESTJAVAPOLICYFILE = &#39;test.java.policy&#39;
 284 
 285 // the file containing &quot;extra&quot; --add-exports
 286 ext.EXTRAADDEXPORTS = &#39;buildSrc/addExports&#39;
 287 
 288 ext.MODULESOURCEPATH = &quot;modulesourcepath.args&quot;
 289 
 290 // These variables indicate what platform is running the build. Is
 291 // this build running on a Mac, Windows, or Linux machine? 32 or 64 bit?
 292 ext.OS_NAME = System.getProperty(&quot;os.name&quot;).toLowerCase()
 293 ext.OS_ARCH = System.getProperty(&quot;os.arch&quot;)
 294 ext.IS_64 = OS_ARCH.toLowerCase().contains(&quot;64&quot;)
 295 ext.IS_MAC = OS_NAME.contains(&quot;mac&quot;) || OS_NAME.contains(&quot;darwin&quot;)
 296 ext.IS_WINDOWS = OS_NAME.contains(&quot;windows&quot;)
 297 ext.IS_LINUX = OS_NAME.contains(&quot;linux&quot;)
 298 
 299 ext.MAVEN_GROUP_ID = &quot;org.openjfx&quot;
 300 
 301 // Verify that the architecture &amp; OS are supported configurations. Note that
 302 // at present building on PI is not supported, but we would only need to make
 303 // some changes on assumptions on what should be built (like SWT / Swing) and
 304 // such and we could probably make it work.
 305 if (!IS_MAC &amp;&amp; !IS_WINDOWS &amp;&amp; !IS_LINUX) fail(&quot;Unsupported build OS ${OS_NAME}&quot;)
 306 if (IS_WINDOWS &amp;&amp; OS_ARCH != &quot;x86&quot; &amp;&amp; OS_ARCH != &quot;amd64&quot;) {
 307     fail(&quot;Unknown and unsupported build architecture: $OS_ARCH&quot;)
 308 } else if (IS_MAC &amp;&amp; OS_ARCH != &quot;x86_64&quot;) {
 309     fail(&quot;Unknown and unsupported build architecture: $OS_ARCH&quot;)
 310 } else if (IS_LINUX &amp;&amp; OS_ARCH != &quot;i386&quot; &amp;&amp; OS_ARCH != &quot;amd64&quot;) {
 311     fail(&quot;Unknown and unsupported build architecture: $OS_ARCH&quot;)
 312 }
 313 
 314 
 315 // Get the JDK_HOME automatically based on the version of Java used to execute gradle. Or, if specified,
 316 // use a user supplied JDK_HOME, STUB_RUNTIME, JAVAC, all of which may be specified
 317 // independently (or we&#39;ll try to get the right one based on other supplied info). Sometimes the
 318 // JRE might be the thing that is being used instead of the JRE embedded in the JDK, such as:
 319 //    c:\Program Files (x86)\Java\jdk1.8.0\jre
 320 //    c:\Program Files (x86)\Java\jre8\
 321 // Because of this, you may sometimes get the jdk&#39;s JRE (in which case the logic we used to have here
 322 // was correct and consistent with all other platforms), or it might be the standalone JRE (for the love!).
 323 def envJavaHome = cygpath(System.getenv(&quot;JDK_HOME&quot;))
 324 if (envJavaHome == null || envJavaHome.equals(&quot;&quot;)) envJavaHome = cygpath(System.getenv(&quot;JAVA_HOME&quot;))
 325 def javaHome = envJavaHome == null || envJavaHome.equals(&quot;&quot;) ? System.getProperty(&quot;java.home&quot;) : envJavaHome
 326 def javaHomeFile = file(javaHome)
 327 defineProperty(&quot;JDK_HOME&quot;,
 328         javaHomeFile.name == &quot;jre&quot; ?
 329         javaHomeFile.getParent().toString() :
 330         javaHomeFile.name.startsWith(&quot;jre&quot;) ?
 331         new File(javaHomeFile.getParent(), &quot;jdk1.${javaHomeFile.name.substring(3)}.0&quot;).toString() :
 332         javaHome) // we have to bail and set it to something and this is as good as any!
 333 ext.JAVA_HOME = JDK_HOME
 334 
 335 defineProperty(&quot;JAVA&quot;, cygpathExe(&quot;$JDK_HOME/bin/java&quot;))
 336 defineProperty(&quot;JAVAC&quot;, cygpathExe(&quot;$JDK_HOME/bin/javac&quot;))
 337 defineProperty(&quot;JAVADOC&quot;, cygpathExe(&quot;$JDK_HOME/bin/javadoc&quot;))
 338 defineProperty(&quot;JMOD&quot;, cygpathExe(&quot;$JDK_HOME/bin/jmod&quot;))
 339 defineProperty(&quot;JDK_DOCS&quot;, &quot;https://docs.oracle.com/en/java/javase/12/docs/api/&quot;)
 340 defineProperty(&quot;JDK_JMODS&quot;, cygpath(System.getenv(&quot;JDK_JMODS&quot;)) ?: cygpath(System.getenv(&quot;JDK_HOME&quot;) + &quot;/jmods&quot;))
 341 
 342 defineProperty(&quot;javaRuntimeVersion&quot;, System.getProperty(&quot;java.runtime.version&quot;))
 343 def javaVersionInfo = parseJavaVersion(javaRuntimeVersion)
 344 defineProperty(&quot;javaVersion&quot;, javaVersionInfo[0])
 345 defineProperty(&quot;javaBuildNumber&quot;, javaVersionInfo[1])
 346 
 347 defineProperty(&quot;libAVRepositoryURL&quot;, &quot;https://libav.org/releases/&quot;)
 348 defineProperty(&quot;FFmpegRepositoryURL&quot;, &quot;https://www.ffmpeg.org/releases/&quot;)
 349 
 350 loadProperties(&quot;$projectDir/build.properties&quot;)
 351 
 352 def supplementalPreBuildFile = file(&quot;$closedDir/closed-pre-build.gradle&quot;);
 353 def supplementalBuildFile = file(&quot;$closedDir/closed-build.gradle&quot;);
 354 
 355 if (BUILD_CLOSED) {
 356     apply from: supplementalPreBuildFile
 357 }
 358 
 359 // GRADLE_VERSION_CHECK specifies whether to fail the build if the
 360 // gradle version check fails
 361 defineProperty(&quot;GRADLE_VERSION_CHECK&quot;, &quot;true&quot;)
 362 ext.IS_GRADLE_VERSION_CHECK = Boolean.parseBoolean(GRADLE_VERSION_CHECK)
 363 
 364 // JFX_DEPS_URL specifies the optional location of an alternate local repository
 365 defineProperty(&quot;JFX_DEPS_URL&quot;, &quot;&quot;)
 366 
 367 // JDK_DOCS_LINK specifies the optional URL for offline javadoc linking
 368 defineProperty(&quot;JDK_DOCS_LINK&quot;, &quot;&quot;)
 369 
 370 // COMPILE_WEBKIT specifies whether to build all of webkit.
 371 defineProperty(&quot;COMPILE_WEBKIT&quot;, &quot;false&quot;)
 372 ext.IS_COMPILE_WEBKIT = Boolean.parseBoolean(COMPILE_WEBKIT)
 373 
 374 // COMPILE_MEDIA specifies whether to build all of media.
 375 defineProperty(&quot;COMPILE_MEDIA&quot;, &quot;false&quot;)
 376 ext.IS_COMPILE_MEDIA = Boolean.parseBoolean(COMPILE_MEDIA)
 377 
 378 // BUILD_LIBAV_STUBS specifies whether to download and build libav/ffmpeg libraries
 379 defineProperty(&quot;BUILD_LIBAV_STUBS&quot;, &quot;false&quot;)
 380 ext.IS_BUILD_LIBAV_STUBS = IS_LINUX ? Boolean.parseBoolean(BUILD_LIBAV_STUBS) : false
 381 
 382 // BUILD_WORKING_LIBAV specifies whether to build libav/ffmpeg libraries with
 383 // decoder, demuxer, etc. required to run media. Valid only if BUILD_LIBAV_STUBS is true.
 384 defineProperty(&quot;BUILD_WORKING_LIBAV&quot;, &quot;false&quot;)
 385 ext.IS_BUILD_WORKING_LIBAV = IS_LINUX ? Boolean.parseBoolean(BUILD_WORKING_LIBAV) : false
 386 
 387 // COMPILE_PANGO specifies whether to build javafx_font_pango.
 388 defineProperty(&quot;COMPILE_PANGO&quot;, &quot;${IS_LINUX}&quot;)
 389 ext.IS_COMPILE_PANGO = Boolean.parseBoolean(COMPILE_PANGO)
 390 
 391 // COMPILE_HARFBUZZ specifies whether to use Harfbuzz.
 392 defineProperty(&quot;COMPILE_HARFBUZZ&quot;, &quot;false&quot;)
 393 ext.IS_COMPILE_HARFBUZZ = Boolean.parseBoolean(COMPILE_HARFBUZZ)
 394 
 395 // COMPILE_PARFAIT specifies whether to build parfait
 396 defineProperty(&quot;COMPILE_PARFAIT&quot;, &quot;false&quot;)
 397 ext.IS_COMPILE_PARFAIT = Boolean.parseBoolean(COMPILE_PARFAIT)
 398 
 399 defineProperty(&quot;STATIC_BUILD&quot;, &quot;false&quot;)
 400 ext.IS_STATIC_BUILD = Boolean.parseBoolean(STATIC_BUILD)
 401 
 402 if (IS_STATIC_BUILD &amp;&amp; IS_COMPILE_MEDIA) {
 403     throw new GradleException(&quot;Can not have COMPILE_MEDIA when STATIC_BUILD is enabled&quot;);
 404 }
 405 
 406 // BUILD_TOOLS_DOWNLOAD_SCRIPT specifies a path of a gradle script which downloads
 407 // required build tools.
 408 defineProperty(&quot;BUILD_TOOLS_DOWNLOAD_SCRIPT&quot;, &quot;&quot;)
 409 
 410 // Define the SWT.jar that we are going to have to download during the build process based
 411 // on what platform we are compiling from (not based on our target).
 412 ext.SWT_FILE_NAME = IS_MAC ? &quot;org.eclipse.swt.cocoa.macosx.x86_64_3.105.3.v20170228-0512&quot; :
 413     IS_WINDOWS &amp;&amp; IS_64 ? &quot;org.eclipse.swt.win32.win32.x86_64_3.105.3.v20170228-0512&quot; :
 414     IS_WINDOWS &amp;&amp; !IS_64 ? &quot;org.eclipse.swt.win32.win32.x86_3.105.3.v20170228-0512&quot; :
 415     IS_LINUX &amp;&amp; IS_64 ? &quot;org.eclipse.swt.gtk.linux.x86_64_3.105.3.v20170228-0512&quot; :
 416     IS_LINUX &amp;&amp; !IS_64 ? &quot;org.eclipse.swt.gtk.linux.x86_3.105.3.v20170228-0512&quot; : &quot;&quot;
 417 
 418 // Specifies whether to run full tests (true) or smoke tests (false)
 419 defineProperty(&quot;FULL_TEST&quot;, &quot;false&quot;)
 420 ext.IS_FULL_TEST = Boolean.parseBoolean(FULL_TEST);
 421 
 422 defineProperty(&quot;FORCE_TESTS&quot;, &quot;false&quot;)
 423 ext.IS_FORCE_TESTS = Boolean.parseBoolean(FORCE_TESTS);
 424 
 425 // Specifies whether to run robot-based visual tests (only used when FULL_TEST is also enabled)
 426 defineProperty(&quot;USE_ROBOT&quot;, &quot;false&quot;)
 427 ext.IS_USE_ROBOT = Boolean.parseBoolean(USE_ROBOT);
 428 
 429 // Specified whether to run tests in headless mode
 430 defineProperty(&quot;HEADLESS_TEST&quot;, &quot;false&quot;)
 431 ext.IS_HEADLESS_TEST = Boolean.parseBoolean(HEADLESS_TEST);
 432 
 433 // Specifies whether to run system tests that depend on AWT (only used when FULL_TEST is also enabled)
 434 defineProperty(&quot;AWT_TEST&quot;, &quot;true&quot;)
 435 ext.IS_AWT_TEST = Boolean.parseBoolean(AWT_TEST);
 436 
 437 // Specifies whether to run system tests that depend on SWT (only used when FULL_TEST is also enabled)
 438 defineProperty(&quot;SWT_TEST&quot;, &quot;true&quot;)
 439 ext.IS_SWT_TEST = Boolean.parseBoolean(SWT_TEST);
 440 
 441 // Specifies whether to run unstable tests (true) - tests that don&#39;t run well with Hudson builds
 442 // These tests should be protected with :
 443 //    assumeTrue(Boolean.getBoolean(&quot;unstable.test&quot;));
 444 defineProperty(&quot;UNSTABLE_TEST&quot;, &quot;false&quot;)
 445 ext.IS_UNSTABLE_TEST = Boolean.parseBoolean(UNSTABLE_TEST);
 446 
 447 // Toggle diagnostic output from the Gradle workaround and the Sandbox test apps.
 448 defineProperty(&quot;WORKER_DEBUG&quot;, &quot;false&quot;)
 449 ext.IS_WORKER_DEBUG = Boolean.parseBoolean(WORKER_DEBUG);
 450 
 451 // Specify the build configuration (Release, Debug, or DebugNative)
 452 defineProperty(&quot;CONF&quot;, &quot;Debug&quot;)
 453 ext.IS_DEBUG_JAVA = CONF == &quot;Debug&quot; || CONF == &quot;DebugNative&quot;
 454 ext.IS_DEBUG_NATIVE = CONF == &quot;DebugNative&quot;
 455 
 456 // Defines the compiler warning levels to use. If empty, then no warnings are generated. If
 457 // not empty, then the expected syntax is as a space or comma separated list of names, such
 458 // as defined in the javac documentation.
 459 defineProperty(&quot;LINT&quot;, &quot;none&quot;)
 460 ext.IS_LINT = LINT != &quot;none&quot;
 461 
 462 defineProperty(&quot;DOC_LINT&quot;, &quot;all&quot;)
 463 ext.IS_DOC_LINT = DOC_LINT != &quot;&quot;
 464 
 465 // Specifies whether to use the &quot;useDepend&quot; option when compiling Java sources
 466 defineProperty(&quot;USE_DEPEND&quot;, &quot;true&quot;)
 467 ext.IS_USE_DEPEND = Boolean.parseBoolean(USE_DEPEND)
 468 
 469 // Specifies whether to use the &quot;incremental&quot; option when compiling Java sources
 470 defineProperty(&quot;INCREMENTAL&quot;, &quot;false&quot;)
 471 ext.IS_INCREMENTAL = Boolean.parseBoolean(INCREMENTAL)
 472 
 473 // Specifies whether to include the Null3D pipeline (for perf debugging)
 474 defineProperty(&quot;INCLUDE_NULL3D&quot;, &quot;false&quot;)
 475 ext.IS_INCLUDE_NULL3D = Boolean.parseBoolean(INCLUDE_NULL3D)
 476 
 477 // Specifies whether to include the ES2 pipeline if available
 478 defineProperty(&quot;INCLUDE_ES2&quot;, IS_WINDOWS ? &quot;false&quot; : &quot;true&quot;)
 479 ext.IS_INCLUDE_ES2 = Boolean.parseBoolean(INCLUDE_ES2)
 480 
 481 // Specifies whether to generate code coverage statistics when running tests
 482 defineProperty(&quot;JCOV&quot;, &quot;false&quot;)
 483 ext.DO_JCOV = Boolean.parseBoolean(JCOV)
 484 
 485 // Specifies whether to use Cygwin when building OpenJFX. This should only ever
 486 // be set to false for development builds (that skip building media and webkit).
 487 defineProperty(&quot;USE_CYGWIN&quot;, &quot;true&quot;)
 488 ext.IS_USE_CYGWIN = Boolean.parseBoolean(USE_CYGWIN)
 489 
 490 // Define the number of threads to use when compiling (specifically for native compilation)
 491 // On Mac we limit it to 1 by default due to problems running gcc in parallel
 492 if (IS_MAC) {
 493     defineProperty(&quot;NUM_COMPILE_THREADS&quot;, &quot;1&quot;)
 494 } else {
 495     defineProperty(&quot;NUM_COMPILE_THREADS&quot;, &quot;${Runtime.runtime.availableProcessors()}&quot;)
 496 }
 497 
 498 //
 499 // The next three sections of properties are used to generate the
 500 // VersionInfo class, and the Windows DLL manifest.
 501 //
 502 
 503 // The following properties should be left alone by developers and set only from Hudson.
 504 defineProperty(&quot;HUDSON_JOB_NAME&quot;, &quot;not_hudson&quot;)
 505 defineProperty(&quot;HUDSON_BUILD_NUMBER&quot;,&quot;0000&quot;)
 506 defineProperty(&quot;PROMOTED_BUILD_NUMBER&quot;, &quot;0&quot;)
 507 defineProperty(&quot;MILESTONE_FCS&quot;, &quot;false&quot;)
 508 ext.IS_MILESTONE_FCS = Boolean.parseBoolean(MILESTONE_FCS)
 509 
 510 // The following properties define the product name for Oracle JDK and OpenJDK
 511 // for VersionInfo and the DLL manifest.
 512 if (BUILD_CLOSED) {
 513     defineProperty(&quot;PRODUCT_NAME&quot;, &quot;Java(TM)&quot;)
 514     defineProperty(&quot;COMPANY_NAME&quot;, &quot;Oracle Corporation&quot;)
 515     defineProperty(&quot;PLATFORM_NAME&quot;, &quot;Platform SE&quot;)
 516 } else {
 517     defineProperty(&quot;PRODUCT_NAME&quot;, &quot;OpenJFX&quot;)
 518     defineProperty(&quot;COMPANY_NAME&quot;, &quot;N/A&quot;)
 519     defineProperty(&quot;PLATFORM_NAME&quot;, &quot;Platform&quot;)
 520 }
 521 
 522 // The following properties are set based on properties defined in
 523 // build.properties. The release version and suffix should be updated
 524 // in that file.
 525 def relVer = 0
 526 if (jfxReleasePatchVersion == &quot;0&quot;) {
 527     if (jfxReleaseSecurityVersion == &quot;0&quot;) {
 528         if (jfxReleaseMinorVersion == &quot;0&quot;) {
 529             relVer = &quot;${jfxReleaseMajorVersion}&quot;
 530         } else {
 531             relVer = &quot;${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}&quot;
 532         }
 533     } else {
 534         relVer = &quot;${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}.${jfxReleaseSecurityVersion}&quot;
 535     }
 536 } else {
 537     relVer = &quot;${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}.${jfxReleaseSecurityVersion}.${jfxReleasePatchVersion}&quot;
 538 }
 539 defineProperty(&quot;RELEASE_VERSION&quot;, relVer)
 540 defineProperty(&quot;RELEASE_VERSION_PADDED&quot;, &quot;${jfxReleaseMajorVersion}.${jfxReleaseMinorVersion}.${jfxReleaseSecurityVersion}.${jfxReleasePatchVersion}&quot;)
 541 
 542 def buildDate = new java.util.Date()
 543 def buildTimestamp = new java.text.SimpleDateFormat(&quot;yyyy-MM-dd-HHmmss&quot;).format(buildDate)
 544 defineProperty(&quot;BUILD_TIMESTAMP&quot;, buildTimestamp)
 545 def relSuffix = &quot;&quot;
 546 def relOpt = &quot;&quot;
 547 if (HUDSON_JOB_NAME == &quot;not_hudson&quot;) {
 548     relSuffix = &quot;-internal&quot;
 549     relOpt = &quot;-${buildTimestamp}&quot;
 550 } else {
 551     relSuffix = IS_MILESTONE_FCS ? &quot;&quot; : jfxReleaseSuffix
 552 }
 553 defineProperty(&quot;RELEASE_SUFFIX&quot;, relSuffix)
 554 defineProperty(&quot;RELEASE_VERSION_SHORT&quot;, &quot;${RELEASE_VERSION}${RELEASE_SUFFIX}&quot;)
 555 defineProperty(&quot;RELEASE_VERSION_LONG&quot;, &quot;${RELEASE_VERSION_SHORT}+${PROMOTED_BUILD_NUMBER}${relOpt}&quot;)
 556 defineProperty(&quot;MAVEN_VERSION&quot;, IS_MILESTONE_FCS ? &quot;${RELEASE_VERSION_SHORT}&quot; : &quot;${RELEASE_VERSION_LONG}&quot;)
 557 
 558 // Check whether the COMPILE_TARGETS property has been specified (if so, it was done by
 559 // the user and not by this script). If it has not been defined then default
 560 // to building the normal desktop build for this machine
 561 project.ext.set(&quot;defaultHostTarget&quot;, IS_MAC ? &quot;mac&quot; : IS_WINDOWS ? &quot;win&quot; : IS_LINUX ? &quot;linux&quot; : &quot;&quot;);
 562 defineProperty(&quot;COMPILE_TARGETS&quot;, &quot;$defaultHostTarget&quot;)
 563 
 564 // Flag indicating whether to import cross compile tools
 565 def importCrossTools = false
 566 if (hasProperty(&quot;IMPORT_CROSS_TOOLS&quot;)) {
 567     importCrossTools = Boolean.parseBoolean(IMPORT_CROSS_TOOLS);
 568 }
 569 ext.IS_IMPORT_CROSS_TOOLS = importCrossTools
 570 
 571 // Location of the cross compile tools
 572 def crossToolsDir = &quot;../crosslibs&quot;
 573 if (hasProperty(&quot;CROSS_TOOLS_DIR&quot;)) {
 574     crossToolsDir = CROSS_TOOLS_DIR
 575 }
 576 ext.CROSS_TOOLS_DIR = file(crossToolsDir)
 577 
 578 // Specifies whether to run tests with the existing javafx.* modules instead of compiling a new one
 579 defineProperty(&quot;BUILD_SDK_FOR_TEST&quot;, &quot;true&quot;)
 580 ext.DO_BUILD_SDK_FOR_TEST = Boolean.parseBoolean(BUILD_SDK_FOR_TEST)
 581 
 582 // All &quot;classes&quot; and &quot;jar&quot; tasks and their dependencies would be disabled
 583 // when running with DO_BUILD_SDK_FOR_TEST=false as they&#39;re unneeded for running tests
 584 if (!DO_BUILD_SDK_FOR_TEST) {
 585     gradle.taskGraph.useFilter({ task -&gt; !task.name.equals(&quot;classes&quot;) &amp;&amp; !task.name.equals(&quot;jar&quot;) })
 586 }
 587 
 588 // Make sure JDK_HOME/bin/java exists
 589 if (!file(JAVA).exists()) throw new Exception(&quot;Missing or incorrect path to &#39;java&#39;: &#39;$JAVA&#39;. Perhaps bad JDK_HOME? $JDK_HOME&quot;)
 590 if (!file(JAVAC).exists()) throw new Exception(&quot;Missing or incorrect path to &#39;javac&#39;: &#39;$JAVAC&#39;. Perhaps bad JDK_HOME? $JDK_HOME&quot;)
 591 if (!file(JAVADOC).exists()) throw new Exception(&quot;Missing or incorrect path to &#39;javadoc&#39;: &#39;$JAVADOC&#39;. Perhaps bad JDK_HOME? $JDK_HOME&quot;)
 592 
 593 // Determine the verion of Java in JDK_HOME. It looks like this:
 594 //
 595 // $ java -version
 596 // java version &quot;1.7.0_45&quot;
 597 // Java(TM) SE Runtime Environment (build 1.7.0_45-b18)
 598 // Java HotSpot(TM) 64-Bit Server VM (build 24.45-b08, mixed mode)
 599 //
 600 // We need to parse the second line
 601 def inStream = new java.io.BufferedReader(new java.io.InputStreamReader(new java.lang.ProcessBuilder(JAVA, &quot;-fullversion&quot;).start().getErrorStream()));
 602 try {
 603     String v = inStream.readLine().trim();
 604     if (v != null) {
 605         int ib = v.indexOf(&quot;full version \&quot;&quot;);
 606         if (ib != -1) {
 607             String str = v.substring(ib);
 608             String ver = str.substring(str.indexOf(&quot;\&quot;&quot;) + 1, str.size() - 1);
 609 
 610             defineProperty(&quot;jdkRuntimeVersion&quot;, ver)
 611             def jdkVersionInfo = parseJavaVersion(ver)
 612             defineProperty(&quot;jdkVersion&quot;, jdkVersionInfo[0])
 613             defineProperty(&quot;jdkBuildNumber&quot;, jdkVersionInfo[1])
 614         }
 615     }
 616 } finally {
 617     inStream.close();
 618 }
 619 if (!project.hasProperty(&quot;jdkRuntimeVersion&quot;)) throw new Exception(&quot;Unable to determine the version of Java in JDK_HOME at $JDK_HOME&quot;);
 620 
 621 
 622 // Determine whether the javafx.* modules are present in the JDK. To do this,
 623 // we will execute &quot;java --list-modules&quot; and search for javafx.base.
 624 ext.HAS_JAVAFX_MODULES = false;
 625 def inStream2 = new java.io.BufferedReader(new java.io.InputStreamReader(new java.lang.ProcessBuilder(JAVA, &quot;--list-modules&quot;).start().getInputStream()));
 626 try {
 627     String v;
 628     while ((v = inStream2.readLine()) != null) {
 629         v = v.trim();
 630         if (v.startsWith(&quot;javafx.base&quot;)) ext.HAS_JAVAFX_MODULES = true;
 631     }
 632 } finally {
 633     inStream2.close();
 634 }
 635 
 636 // The HAS_JAVAFX_MODULES flag will be used to determine the mode for building
 637 // and running the applications and tests.
 638 // If HAS_JAVAFX_MODULES is true, then we will build / test javafx modules
 639 // for exporting to a JDK build. If HAS_JAVAFX_MODULES is false, then we will
 640 // build / test a standalone sdk for running with a JDK that does not include
 641 // the javafx modules.
 642 
 643 
 644 /**
 645  * Fetch/Check that external tools are present for the build. This method
 646  * will conditionally download the packages from project defined ivy repositories
 647  * and unpack them into the specified destdir
 648  *
 649  * @param configName A unique name to distinguish the configuration (ie &quot;ARMSFV6&quot;)
 650  * @param packages A list of required packages (with extensions .tgz, .zip)
 651  * @param destdir where the packages should be unpacked
 652  * @param doFetch if true, the named packages will be download
 653  */
 654 void fetchExternalTools(String configName, List packages, File destdir, boolean doFetch) {
 655     if (doFetch) {
 656         // create a unique configuration for this fetch
 657         def String fetchToolsConfig = &quot;fetchTools$configName&quot;
 658         rootProject.configurations.create(fetchToolsConfig)
 659 
 660         def List&lt;String&gt; fetchedPackages = []
 661         def int fetchCount = 0
 662 
 663         packages.each { pkgname-&gt;
 664             def int dotdex = pkgname.lastIndexOf(&#39;.&#39;)
 665             def int dashdex = pkgname.lastIndexOf(&#39;-&#39;)
 666             def String basename = pkgname.substring(0,dashdex)
 667             def String ver = pkgname.substring(dashdex+1,dotdex)
 668             def String ext = pkgname.substring(dotdex+1)
 669             def File pkgdir = file(&quot;$destdir/$basename-$ver&quot;)
 670 
 671             if (!pkgdir.isDirectory()) {
 672                 rootProject.dependencies.add(fetchToolsConfig, &quot;javafx:$basename:$ver&quot;, {
 673                     artifact {
 674                         name = basename
 675                         type = ext
 676                     }
 677                 })
 678                 println &quot;adding $pkgname as a downloadable item did not find $pkgdir&quot;
 679                 fetchedPackages.add(pkgname)
 680                 fetchCount++
 681             }
 682         }
 683 
 684         //fetch all the missing packages
 685         if (fetchedPackages.size &gt; 0) {
 686             destdir.mkdirs()
 687 
 688             logger.quiet &quot;fetching missing packages $fetchedPackages&quot;
 689             copy {
 690                 from rootProject.configurations[fetchToolsConfig]
 691                 into destdir
 692             }
 693 
 694             // unpack the fetched packages
 695             fetchedPackages.each { pkgname-&gt;
 696                 logger.quiet &quot;expanding the package $pkgname&quot;
 697                 def srcball = file(&quot;${destdir}/${pkgname}&quot;)
 698 
 699                 if (!srcball.exists()) {
 700                     throw new GradleException(&quot;Failed to fetch $pkgname&quot;);
 701                 }
 702 
 703                 def String basename = pkgname.substring(0,pkgname.lastIndexOf(&quot;.&quot;))
 704                 def File pkgdir = file(&quot;$destdir/$basename&quot;)
 705 
 706                 if (pkgname.endsWith(&quot;.tgz&quot;) || pkgname.endsWith(&quot;tar.gz&quot;)) {
 707                     if (IS_LINUX || IS_MAC) {
 708                         // use native tar to support symlinks
 709                         pkgdir.mkdirs()
 710                         exec {
 711                             workingDir pkgdir
 712                             commandLine &quot;tar&quot;, &quot;zxf&quot;, &quot;${srcball}&quot;
 713                          }
 714                     } else {
 715                         copy {
 716                             from tarTree(resources.gzip(&quot;${srcball}&quot;))
 717                             into pkgdir
 718                         }
 719                     }
 720                 } else if (pkgname.endsWith(&quot;.zip&quot;)) {
 721                      copy {
 722                          from zipTree(&quot;${srcball}&quot;)
 723                          into pkgdir
 724                      }
 725                 } else {
 726                     throw new GradleException(&quot;Unhandled package type for compile package ${pkgname}&quot;)
 727                 }
 728                 srcball.delete();
 729             }
 730         } else {
 731             logger.quiet &quot;all tool packages are present $packages&quot;
 732         }
 733     } else { // !doFetch - so just check they are present
 734         // check that all the dirs are really there
 735         def List&lt;String&gt; errors = []
 736         packages.each { pkgname-&gt;
 737             def String basename = pkgname.substring(0,pkgname.lastIndexOf(&quot;.&quot;))
 738             def File pkgdir = file(&quot;$destdir/$basename&quot;)
 739 
 740             if (!pkgdir.isDirectory()) {
 741                 errors.add(pkgname)
 742             }
 743         }
 744         if (errors.size &gt; 0) {
 745             throw new GradleException(&quot;Error: missing tool packages: $errors&quot;)
 746         } else {
 747             logger.quiet &quot;all tool packages are present $packages&quot;
 748         }
 749     }
 750 }
 751 
 752 // Make a forked ANT call.
 753 // This needs to be forked so that ant can be used with the right JDK and updated modules
 754 // for testing obscure things like packaging of apps
 755 void ant(String conf,   // platform configuration
 756          String dir,    // directory to run from
 757          String target, // ant target
 758          List&lt;String&gt;  params // parameters (usually -Dxxx=yyy)
 759          ) {
 760     // Try to use ANT_HOME
 761     String antHomeEnv = System.getenv(&quot;ANT_HOME&quot;)
 762     String antHome = antHomeEnv != null ? cygpath(antHomeEnv) : null;
 763     String ant = (antHome != null &amp;&amp; !antHome.equals(&quot;&quot;)) ? &quot;$antHome/bin/ant&quot; : &quot;ant&quot;;
 764 
 765     exec {
 766         workingDir = dir
 767         environment(&quot;JDK_HOME&quot;, JDK_HOME)
 768         environment(&quot;JAVA_HOME&quot;, JDK_HOME)
 769         if (IS_WINDOWS) {
 770             environment([
 771                     &quot;VCINSTALLDIR&quot;         : WINDOWS_VS_VCINSTALLDIR,
 772                     &quot;VSINSTALLDIR&quot;         : WINDOWS_VS_VSINSTALLDIR,
 773                     &quot;DEVENVDIR&quot;            : WINDOWS_VS_DEVENVDIR,
 774                     &quot;MSVCDIR&quot;              : WINDOWS_VS_MSVCDIR,
 775                     &quot;INCLUDE&quot;              : WINDOWS_VS_INCLUDE,
 776                     &quot;LIB&quot;                  : WINDOWS_VS_LIB,
 777                     &quot;LIBPATH&quot;              : WINDOWS_VS_LIBPATH,
 778                     &quot;DXSDK_DIR&quot;            : WINDOWS_DXSDK_DIR,
 779                     &quot;PATH&quot;                 : WINDOWS_VS_PATH
 780             ]);
 781             commandLine &quot;cmd&quot;, &quot;/c&quot;, ant, &quot;-Dbuild.compiler=javac1.7&quot;
 782         } else {
 783             commandLine ant, &quot;-Dbuild.compiler=javac1.7&quot;
 784         }
 785         if ((conf != null) &amp;&amp; !rootProject.defaultHostTarget.equals(conf)) {
 786             def targetProperties = rootProject.ext[conf.trim().toUpperCase()]
 787             args(&quot;-Dcross.platform=$conf&quot;)
 788             if (targetProperties.containsKey(&#39;arch&#39;)) {
 789                 args(&quot;-Dcross.platform.arch=${targetProperties.arch}&quot;)
 790             }
 791         }
 792         if (params != null) {
 793             params.each() { s-&gt;
 794                 args(s)
 795             }
 796         }
 797         if (IS_MILESTONE_FCS) {
 798             args(&#39;-Djfx.release.suffix=&quot;&quot;&#39;)
 799         }
 800         args(target);
 801     }
 802 }
 803 
 804 List&lt;String&gt; computeLibraryPath(boolean working) {
 805     List&lt;String&gt; lp = []
 806 
 807     if (HAS_JAVAFX_MODULES) {
 808         List&lt;String&gt; modsWithNative = [ &#39;graphics&#39;, &#39;media&#39;, &#39;web&#39; ]
 809 
 810         // the build/modular-sdk area
 811         def platformPrefix = &quot;&quot;
 812         def bundledSdkDirName = &quot;${platformPrefix}modular-sdk&quot;
 813         def bundledSdkDir = &quot;${rootProject.buildDir}/${bundledSdkDirName}&quot;
 814         def modulesLibsDir = &quot;${bundledSdkDir}/modules_libs&quot;
 815 
 816         modsWithNative.each() { m -&gt;
 817             lp &lt;&lt; cygpath(&quot;${modulesLibsDir}/javafx.${m}&quot;)
 818         }
 819     } else {
 820         def platformPrefix = &quot;&quot;
 821         def standaloneSdkDirName = &quot;${platformPrefix}sdk&quot;
 822         def standaloneSdkDir = &quot;${rootProject.buildDir}/${standaloneSdkDirName}&quot;
 823         def modulesLibName = IS_WINDOWS ? &quot;bin&quot; : &quot;lib&quot;
 824         def modulesLibsDir = &quot;${standaloneSdkDir}/${modulesLibName}&quot;
 825         lp &lt;&lt; cygpath(&quot;${modulesLibsDir}&quot;)
 826     }
 827 
 828     return lp
 829 }
 830 
 831 // Return list with the arguments needed for --patch-module or --module-path
 832 // for the provided projects. Used with Java executables ie. tests
 833 List&lt;String&gt; computePatchModuleArgs(List&lt;String&gt; deps, boolean test, boolean includeJLP) {
 834     List&lt;String&gt; pma = []
 835 
 836     if (HAS_JAVAFX_MODULES) {
 837         deps.each { String projname -&gt;
 838             def proj = project(projname)
 839             if (proj.hasProperty(&quot;moduleName&quot;)) {
 840                 File dir;
 841                 if (test &amp;&amp; proj.sourceSets.hasProperty(&#39;shims&#39;)) {
 842                     dir = file(&quot;${rootProject.buildDir}/shims&quot;)
 843                 } else {
 844                     dir = file(&quot;${rootProject.buildDir}/modular-sdk/modules&quot;)
 845                 }
 846                 String moduleName = proj.ext.moduleName
 847                 String dirpath = cygpath(&quot;${dir}/${moduleName}&quot;)
 848                 pma += &quot;--patch-module=${moduleName}=${dirpath}&quot;
 849             }
 850         }
 851     } else {
 852         String mp = null
 853         deps.each { String projname -&gt;
 854             def proj = project(projname)
 855             if (proj.hasProperty(&quot;moduleName&quot;)) {
 856                 String moduleName = proj.ext.moduleName
 857                 File dir;
 858                 if (test &amp;&amp; proj.sourceSets.hasProperty(&#39;shims&#39;)) {
 859                     dir = file(&quot;${rootProject.buildDir}/shims/${moduleName}&quot;)
 860                 } else {
 861                     dir = file(&quot;${rootProject.buildDir}/sdk/lib/${moduleName}.jar&quot;)
 862                 }
 863                 if (mp == null) {
 864                     mp = dir.path
 865                 } else {
 866                     mp = mp + File.pathSeparator + dir.path
 867                 }
 868             }
 869         }
 870 
 871         // in some cases like base we could end up with an empty
 872         // path... make sure we don&#39;t pass one back
 873         if (mp == null) {
 874             return null
 875         }
 876 
 877         pma += &#39;--module-path&#39;
 878         pma += mp
 879 
 880         String addm = null
 881         deps.each {String projname -&gt;
 882             def proj = project(projname)
 883             if (proj.hasProperty(&quot;moduleName&quot;) &amp;&amp; proj.buildModule) {
 884                 if (addm == null) {
 885                     addm = proj.moduleName
 886                 } else {
 887                     addm = addm + &quot;,&quot; + proj.moduleName
 888                 }
 889             }
 890         }
 891         if (addm != null) {
 892             pma += &quot;--add-modules=${addm}&quot;
 893         }
 894     }
 895 
 896     if (includeJLP) {
 897         pma += &quot;-Djava.library.path=&quot; + computeLibraryPath(true).join(File.pathSeparator)
 898     }
 899 
 900     return pma
 901 }
 902 
 903 // Return a list containing the --upgrade-module-path or --module-path
 904 // used with Javac
 905 List&lt;String&gt; computeModulePathArgs(String  pname, List&lt;String&gt; deps, boolean test) {
 906     List&lt;String&gt; mpa = HAS_JAVAFX_MODULES ? [ &#39;--upgrade-module-path&#39; ] : [ &#39;--module-path&#39; ]
 907     String mp = null
 908     deps.each { String projname -&gt;
 909         def proj = project(projname)
 910         // for a non test set of args, we don&#39;t want the current module in the list
 911         // for a test test, we do need it to update what we built
 912 
 913         if (proj.hasProperty(&quot;moduleName&quot;) &amp;&amp;
 914                 proj.buildModule &amp;&amp;
 915                 !(!test &amp;&amp; proj.name.equals(pname))) {
 916 
 917             File dir;
 918             if (test &amp;&amp; proj.sourceSets.hasProperty(&#39;shims&#39;)) {
 919                 dir = new File(proj.sourceSets.shims.java.outputDir, proj.ext.moduleName);
 920             } else {
 921                 dir = new File(proj.sourceSets.main.java.outputDir, proj.ext.moduleName);
 922             }
 923             if (mp == null) {
 924                 mp = dir.path
 925             } else {
 926                 mp = mp + File.pathSeparator + dir.path
 927             }
 928         }
 929     }
 930 
 931     // in some cases like base we could end up with an empty
 932     // path... make sure we don&#39;t pass one back
 933     if (mp == null) {
 934         return null
 935     }
 936 
 937     mpa += mp
 938 
 939     if (!HAS_JAVAFX_MODULES) {
 940         String addm = null
 941         deps.each {String projname -&gt;
 942             def proj = project(projname)
 943             // for a non test set of args, we don&#39;t want the current module in the list
 944             // for a test test, we do need it to update what we built
 945 
 946             if (proj.hasProperty(&quot;moduleName&quot;) &amp;&amp;
 947                     proj.buildModule &amp;&amp;
 948                     !(!test &amp;&amp; proj.name.equals(pname))) {
 949 
 950                 if (addm == null) {
 951                     addm = proj.moduleName
 952                 } else {
 953                     addm = addm + &quot;,&quot; + proj.moduleName
 954                 }
 955             }
 956         }
 957         if (addm != null) {
 958             mpa += &quot;--add-modules=${addm}&quot;
 959         }
 960     }
 961 
 962     return mpa
 963 }
 964 
 965 
 966 void writeRunArgsFile(File dest, List&lt;String&gt; libpath, List&lt;String&gt; modpath, List&lt;String&gt; modules) {
 967 
 968     dest.delete()
 969 
 970     logger.info(&quot;Creating file ${dest.path}&quot;)
 971 
 972     if (libpath != null) {
 973         dest &lt;&lt;  &quot;-Djava.library.path=\&quot;\\\n&quot;
 974         libpath.each() { e-&gt;
 975             dest &lt;&lt; &quot;  &quot;
 976             dest &lt;&lt; e
 977             dest &lt;&lt; File.pathSeparator
 978             dest &lt;&lt; &quot;\\\n&quot;
 979         }
 980         dest &lt;&lt;  &quot;  \&quot;\n&quot;
 981     }
 982 
 983     if (HAS_JAVAFX_MODULES) {
 984         modpath.each { e -&gt;
 985             dest &lt;&lt;  &quot;--patch-module=\&quot;&quot;
 986             dest &lt;&lt; e
 987             dest &lt;&lt; &quot;\&quot;\n&quot;
 988         }
 989     } else {
 990         if (modpath.size() == 1) {
 991             dest &lt;&lt;  &quot;--module-path=\&quot;&quot;
 992             dest &lt;&lt; modpath[0]
 993             dest &lt;&lt; &quot;\&quot;\n&quot;
 994         } else {
 995             dest &lt;&lt;  &quot;--module-path=\&quot;\\\n&quot;
 996             modpath.each() { e-&gt;
 997                 dest &lt;&lt; &quot;  &quot;
 998                 dest &lt;&lt; e
 999                 dest &lt;&lt; File.pathSeparator
1000                 dest &lt;&lt; &quot;\\\n&quot;
1001             }
1002             dest &lt;&lt;  &quot;  \&quot;\n&quot;
1003         }
1004     }
1005 
1006     if (modules != null) {
1007         dest &lt;&lt;  &quot;--add-modules=&quot;
1008         dest &lt;&lt; modules.join(&quot;,&quot;)
1009         dest &lt;&lt; &quot;\n&quot;
1010     }
1011 }
1012 
1013 // perform common project manipulation for modules
1014 void commonModuleSetup(Project p, List&lt;String&gt; moduleChain) {
1015 
1016     p.ext.moduleChain = moduleChain
1017 
1018     if (p.hasProperty(&quot;moduleName&quot;)) {
1019         p.ext.moduleDir = new File (p.sourceSets.main.java.outputDir, &quot;${p.moduleName}&quot;)
1020         if (p.sourceSets.hasProperty(&#39;shims&#39;)) {
1021             p.ext.moduleShimsDir = new File (p.sourceSets.shims.java.outputDir, &quot;${p.moduleName}&quot;)
1022         }
1023     }
1024 
1025     def mpa = computeModulePathArgs(p.name, moduleChain, false)
1026     if (mpa != null) {
1027         p.ext.modulePathArgs = mpa
1028     }
1029 
1030     p.ext.testModulePathArgs = computePatchModuleArgs(moduleChain, true, false)
1031     p.ext.patchModuleArgs = computePatchModuleArgs(moduleChain ,false, true)
1032     p.ext.testPatchModuleArgs = computePatchModuleArgs(moduleChain, true, true)
1033 
1034     moduleChain.each() {e -&gt;
1035         if (!e.equals(p.name)) {
1036             p.compileJava.dependsOn(project(e).classes)
1037             p.compileTestJava.dependsOn(project(e).testClasses)
1038         }
1039     }
1040 
1041     // read in any addExports file
1042     File addExportsFile = new File(p.projectDir,&quot;src/test/addExports&quot;)
1043     if (addExportsFile.exists()) {
1044         List&lt;String&gt; ae = []
1045         addExportsFile.eachLine { line -&gt;
1046             line = line.trim()
1047             if (!(line.startsWith(&quot;#&quot;) || line.equals(&quot;&quot;))) {
1048                 ae += line.split(&#39; &#39;)
1049             }
1050         }
1051         p.ext.testAddExports  = ae.flatten()
1052     }
1053 
1054     // read in the temporary addExports file EXTRAADDEXPORTS)
1055     //
1056     // These extra --add-exports will be used in two places and so we
1057     // create/modify two items:
1058     // p.testAddExports - add the extra items so they are included in test builds
1059     //
1060     // p.extraAddExports - for use in any other place where we don&#39;t automatically update
1061     //    for example any non modular, non &#39;test&#39; compile, any compile that does not
1062     //    use a module-source-path that includes the dependent modules
1063     //
1064     // Note that we don&#39;t modify the modular build (main, shims) because they use
1065     // module-info directly, and we don&#39;t want to cover up any missing items there.
1066     //
1067     if (!rootProject.hasProperty(&quot;EXTRA_ADDEXPORTS_ARGS&quot;)) {
1068         List&lt;String&gt; extraAddExportsList = []
1069         String fullae = &quot;&quot;
1070         File tmpaddExportsFile = new File(rootProject.projectDir, EXTRAADDEXPORTS)
1071         if (tmpaddExportsFile.exists()) {
1072             String nl = System.getProperty(&quot;line.separator&quot;)
1073             tmpaddExportsFile.eachLine { line -&gt;
1074                 line = line.trim()
1075                 fullae += line + nl
1076                 if (!(line.startsWith(&quot;#&quot;) || line.equals(&quot;&quot;))) {
1077                     extraAddExportsList += line.split(&#39; &#39;)
1078                 }
1079             }
1080         }
1081         // This string is used in the creation of the build/*.args files
1082         // so we preserve comments
1083         if (!extraAddExportsList.isEmpty()) {
1084             rootProject.ext.EXTRA_ADDEXPORTS_STRING = fullae
1085         }
1086         rootProject.ext.EXTRA_ADDEXPORTS_ARGS = extraAddExportsList
1087     }
1088 
1089     if (HAS_JAVAFX_MODULES) {
1090         // use this variable, because it shows we have a non empty addition
1091         if (rootProject.hasProperty(&quot;EXTRA_ADDEXPORTS_STRING&quot;)) {
1092             p.ext.extraAddExports = EXTRA_ADDEXPORTS_ARGS.flatten()
1093             if (p.hasProperty(&quot;testAddExports&quot;)) {
1094                 p.testAddExports += EXTRA_ADDEXPORTS_ARGS.flatten()
1095             }
1096         }
1097     }
1098 }
1099 
1100 if (BUILD_TOOLS_DOWNLOAD_SCRIPT != &quot;&quot;) {
1101     println &quot;Include build tools download script:${BUILD_TOOLS_DOWNLOAD_SCRIPT}&quot;
1102     apply from: BUILD_TOOLS_DOWNLOAD_SCRIPT
1103 }
1104 
1105 // Now we need to define the native compilation tasks. The set of parameters to
1106 // native compilation depends on the target platform (and also to some extent what platform
1107 // you are compiling on). These settings are contained in various gradle files
1108 // such as mac.gradle and linux.gradle and armhf.gradle. Additionally, the developer
1109 // can specify COMPILE_FLAGS_FILE to be a URL or path to a different gradle file
1110 // that will contain the appropriate flags.
1111 defineProperty(&quot;COMPILE_FLAGS_FILES&quot;, COMPILE_TARGETS.split(&quot;,&quot;).collect {&quot;buildSrc/${it.trim()}.gradle&quot;}.join(&quot;,&quot;))
1112 if (COMPILE_TARGETS == &quot;all&quot;) {
1113     def tmp = []
1114     File buildSrcDir = file(&quot;buildSrc&quot;)
1115     buildSrcDir.listFiles().each { File f -&gt;
1116         if (f.isFile() &amp;&amp; f.name.endsWith(&quot;.gradle&quot;) &amp;&amp; !f.name.equals(&quot;build.gradle&quot;)) {
1117             def target = f.name.substring(0, f.name.lastIndexOf(&#39;.gradle&#39;)).toUpperCase(Locale.ROOT)
1118             apply from: f
1119             if (project.ext[&quot;${target}&quot;].canBuild) {
1120                 tmp.add(target)
1121             }
1122         }
1123     }
1124     COMPILE_FLAGS_FILES = tmp.collect { &quot;buildSrc/${it}.gradle&quot;}.join(&quot;,&quot;)
1125     COMPILE_TARGETS = tmp.collect { &quot;${it.toLowerCase()}&quot;}.join(&quot;,&quot;)
1126 } else {
1127     COMPILE_FLAGS_FILES.split(&quot;,&quot;).each {
1128         logger.info(&quot;Applying COMPILE_FLAGS_FILE &#39;$it&#39;&quot;)
1129         apply from: it
1130     }
1131 }
1132 
1133 if (COMPILE_TARGETS != &quot;&quot;) {
1134     def tmp = []
1135     COMPILE_TARGETS.split(&quot;,&quot;).each {target -&gt;
1136         if (project.ext[&quot;${target.toUpperCase(Locale.ROOT)}&quot;].canBuild) {
1137             tmp.add(target)
1138         }
1139     }
1140     COMPILE_TARGETS = tmp.collect { &quot;${it.toLowerCase()}&quot;}.join(&quot;,&quot;)
1141 }
1142 
1143 // Sanity check the expected properties all exist
1144 compileTargets { t -&gt;
1145     // Every platform must define these variables
1146     if (!project.hasProperty(t.upper)) throw new Exception(&quot;ERROR: Incorrectly configured compile flags file, missing ${t.name} property&quot;)
1147     def props = project.ext[t.upper];
1148     // TODO: we could remove libDest in favor of modLibDest
1149     [&quot;compileSwing&quot;, &quot;compileSWT&quot;, &quot;libDest&quot;].each { prop -&gt;
1150         if (!props.containsKey(prop)) throw new Exception(&quot;ERROR: Incorrectly configured compile flags file, missing ${prop} property on ${t.name}&quot;)
1151     }
1152 }
1153 
1154 // Various build flags may be set by the different target files, such as
1155 // whether to build Swing, SWT, etc. We iterate over all
1156 // compile targets and look for these settings in our properties. Note that
1157 // these properties cannot be set from the command line, but are set by
1158 // the target build files such as armv6hf.gradle or mac.gradle.
1159 ext.COMPILE_SWING = false;
1160 ext.COMPILE_SWT = false;
1161 compileTargets { t -&gt;
1162     def targetProperties = project.rootProject.ext[t.upper]
1163 
1164     if (targetProperties.compileSwing) COMPILE_SWING = true
1165     if (targetProperties.compileSWT) COMPILE_SWT = true
1166 
1167     if (!targetProperties.containsKey(&#39;compileWebnodeNative&#39;)) {
1168         // unless specified otherwise, we will compile native Webnode if IS_COMPILE_WEBKIT
1169         targetProperties.compileWebnodeNative = true
1170     }
1171 
1172     if (!targetProperties.containsKey(&#39;compileMediaNative&#39;)) {
1173         // unless specified otherwise, we will compile native Media if IS_COMPILE_MEDIA
1174         targetProperties.compileMediaNative = true
1175     }
1176 
1177     if (!targetProperties.containsKey(&#39;includeSWT&#39;)) targetProperties.includeSWT = true
1178     if (!targetProperties.containsKey(&#39;includeSwing&#39;)) targetProperties.includeSwing = true
1179     if (!targetProperties.containsKey(&#39;includeNull3d&#39;)) targetProperties.includeNull3d = true
1180     if (!targetProperties.containsKey(&#39;includeMonocle&#39;)) targetProperties.includeMonocle = false
1181     if (!targetProperties.containsKey(&#39;includeEGL&#39;)) targetProperties.includeEGL = false
1182 
1183     if (!targetProperties.containsKey(&#39;includeGTK&#39;)) targetProperties.includeGTK = IS_LINUX
1184 
1185     if (!targetProperties.containsKey(&#39;modLibDest&#39;)) targetProperties.modLibDest = targetProperties.libDest
1186 
1187     // This value is used as a prefix for various directories under ./build,
1188     // such as sdk, to allow for a common name for the hosted build
1189     // (for use when building apps) and a unique name for cross builds.
1190     if (rootProject.defaultHostTarget.equals(t.name)) {
1191         // use a simple common default for the &quot;host&quot; build
1192         targetProperties.platformPrefix=&quot;&quot;
1193     } else {
1194         // and a more complex one for cross builds
1195         targetProperties.platformPrefix=&quot;${t.name}-&quot;
1196     }
1197 }
1198 
1199 /******************************************************************************
1200  *                                                                            *
1201  *                         Build Setup Sanity Checks                          *
1202  *                                                                            *
1203  *  Here we do a variety of checks so that if the version of Java you are     *
1204  *  building with is misconfigured, or you are using the wrong version of     *
1205  *  gradle, etc you will get some kind of helpful error / warning message     *
1206  *                                                                            *
1207  *****************************************************************************/
1208 
1209 // Sanity check that we actually have a list of compile targets to execute
1210 if (COMPILE_TARGETS == null || COMPILE_TARGETS == &quot;&quot;) {
1211     throw new Exception(&quot;Unable to determine compilation platform, must specify valid COMPILE_TARGETS!&quot;)
1212 }
1213 
1214 // Verify that CONF is something useful
1215 if (CONF != &quot;Release&quot; &amp;&amp; CONF != &quot;Debug&quot; &amp;&amp; CONF != &quot;DebugNative&quot;) {
1216     logger.warn(&quot;Unknown configuration CONF=&#39;$CONF&#39;. Treating as &#39;Release&#39;&quot;)
1217 }
1218 
1219 // If the number of compile threads is less than 1 then we have a problem!
1220 if (Integer.parseInt(NUM_COMPILE_THREADS.toString()) &lt; 1) {
1221     logger.warn(&quot;NUM_COMPILE_THREADS was specified as &#39;$NUM_COMPILE_THREADS&#39; which is less than the minimum value of 1. &quot; +
1222             &quot;Building with a value of 1 instead.&quot;)
1223     NUM_COMPILE_THREADS = 1
1224 }
1225 
1226 // Check gradle version
1227 if (gradle.gradleVersion != jfxGradleVersion) {
1228     def ver = gradle.gradleVersion.split(&quot;[\\.]&quot;);
1229     def verMin = jfxGradleVersionMin.split(&quot;[\\.]&quot;);
1230     def gradleMajor = Integer.parseInt(ver[0]);
1231     def gradleMinor = Integer.parseInt(ver[1].split(&quot;[^0-9]&quot;)[0]);
1232     def gradleMajorMin = Integer.parseInt(verMin[0]);
1233     def gradleMinorMin = Integer.parseInt(verMin[1].split(&quot;[^0-9]&quot;)[0]);
1234     def err = &quot;&quot;;
1235     if (gradleMajor &lt; gradleMajorMin || (gradleMajor == gradleMajorMin &amp;&amp; gradleMinor &lt; gradleMinorMin)) {
1236         err = &quot;Gradle version too old: ${gradle.gradleVersion}; must be at least ${jfxGradleVersionMin}&quot;
1237     }
1238 
1239     if (IS_GRADLE_VERSION_CHECK &amp;&amp; err != &quot;&quot;) {
1240         fail(err);
1241     }
1242 
1243     logger.warn(&quot;*****************************************************************&quot;);
1244     logger.warn(&quot;Unsupported gradle version $gradle.gradleVersion in use.&quot;);
1245     logger.warn(&quot;Only version $jfxGradleVersion is supported. Use this version at your own risk&quot;);
1246     if ( err != &quot;&quot;) logger.warn(err);
1247     logger.warn(&quot;*****************************************************************&quot;);
1248 }
1249 
1250 // Look for stub runtime in bundled sdk, standalone sdk, or boot JDK
1251 
1252 // Allows automatic provisioning of webkit+media shared libraries
1253 // from official OpenJFX releases, downloaded from MavenCentral
1254 defineProperty(&quot;STUB_RUNTIME_OPENJFX&quot;, &quot;&quot;)
1255 ext.IS_STUB_RUNTIME_OPENJFX = !STUB_RUNTIME_OPENJFX.isBlank()
1256 
1257 def String cachedBundledRuntime = cygpath(&quot;$projectDir&quot;) + &quot;/../caches/modular-sdk&quot;
1258 def String cachedStandaloneRuntime = cygpath(&quot;$projectDir&quot;) + &quot;/../caches/sdk&quot;
1259 def String jdkStubRuntime = cygpath(&quot;$JDK_HOME&quot;)
1260 def String openjfxStubRuntime = cygpath(&quot;$projectDir&quot;) + &quot;/buildSrc/build/openjfxStub&quot;
1261 
1262 def defaultStubRuntime = &quot;&quot;
1263 if (file(cachedBundledRuntime).exists()) {
1264     defaultStubRuntime = cachedBundledRuntime
1265 } else if (file(cachedStandaloneRuntime).exists()) {
1266     defaultStubRuntime = cachedStandaloneRuntime
1267 } else if (BUILD_CLOSED) {
1268     defaultStubRuntime = cachedBundledRuntime
1269 } else if (IS_STUB_RUNTIME_OPENJFX) {
1270     defaultStubRuntime = openjfxStubRuntime
1271 } else {
1272     defaultStubRuntime = jdkStubRuntime
1273 }
1274 
1275 defineProperty(&quot;STUB_RUNTIME&quot;, defaultStubRuntime)
1276 
1277 if (STUB_RUNTIME.endsWith(&quot;/modular-sdk&quot;)) {
1278     def stubModulesLib = &quot;$STUB_RUNTIME/modules_libs&quot;
1279     defineProperty(&quot;MEDIA_STUB&quot;, &quot;$stubModulesLib/javafx.media&quot;)
1280     defineProperty(&quot;WEB_STUB&quot;, &quot;$stubModulesLib/javafx.web&quot;)
1281 } else {
1282     def libraryStub = IS_WINDOWS ? &quot;$STUB_RUNTIME/bin&quot; : &quot;$STUB_RUNTIME/lib&quot;
1283 
1284     defineProperty(&quot;MEDIA_STUB&quot;, libraryStub)
1285     defineProperty(&quot;WEB_STUB&quot;, libraryStub)
1286 }
1287 
1288 ext.UPDATE_STUB_CACHE = (BUILD_CLOSED &amp;&amp; STUB_RUNTIME != &quot;&quot; &amp;&amp; !file(STUB_RUNTIME).isDirectory())
1289 
1290 
1291 /******************************************************************************
1292  *                                                                            *
1293  *                      Logging of Properties and Settings                    *
1294  *                                                                            *
1295  *  Log some of the settings we&#39;ve determined. We could log more here, it     *
1296  *  doesn&#39;t really hurt.                                                      *
1297  *                                                                            *
1298  *****************************************************************************/
1299 
1300 logger.quiet(&quot;gradle.gradleVersion: $gradle.gradleVersion&quot;)
1301 logger.quiet(&quot;OS_NAME: $OS_NAME&quot;)
1302 logger.quiet(&quot;OS_ARCH: $OS_ARCH&quot;)
1303 logger.quiet(&quot;JAVA_HOME: $JAVA_HOME&quot;)
1304 logger.quiet(&quot;JDK_HOME: $JDK_HOME&quot;)
1305 logger.quiet(&quot;java.runtime.version: ${javaRuntimeVersion}&quot;)
1306 logger.quiet(&quot;java version: ${javaVersion}&quot;)
1307 logger.quiet(&quot;java build number: ${javaBuildNumber}&quot;)
1308 logger.quiet(&quot;jdk.runtime.version: ${jdkRuntimeVersion}&quot;)
1309 logger.quiet(&quot;jdk version: ${jdkVersion}&quot;)
1310 logger.quiet(&quot;jdk build number: ${jdkBuildNumber}&quot;)
1311 logger.quiet(&quot;minimum jdk version: ${jfxBuildJdkVersionMin}&quot;)
1312 logger.quiet(&quot;minimum jdk build number: ${jfxBuildJdkBuildnumMin}&quot;)
1313 
1314 if (IS_LINUX) {
1315     logger.quiet(&quot;GCC version: ${jfxBuildLinuxGccVersion}&quot;)
1316 } else if (IS_WINDOWS) {
1317     logger.quiet(&quot;MSVC version: ${jfxBuildWindowsMsvcVersion}&quot;)
1318 } else if (IS_MAC) {
1319     logger.quiet(&quot;XCODE version: ${jfxBuildMacosxXcodeVersion}&quot;)
1320 }
1321 logger.quiet(&quot;cmake version: ${jfxBuildCmakeVersion}&quot;)
1322 logger.quiet(&quot;ninja version: ${jfxBuildNinjaVersion}&quot;)
1323 logger.quiet(&quot;ant version: ${jfxBuildAntVersion}&quot;)
1324 
1325 logger.quiet(&quot;HAS_JAVAFX_MODULES: $HAS_JAVAFX_MODULES&quot;)
1326 logger.quiet(&quot;STUB_RUNTIME: $STUB_RUNTIME&quot;)
1327 logger.quiet(&quot;CONF: $CONF&quot;)
1328 logger.quiet(&quot;NUM_COMPILE_THREADS: $NUM_COMPILE_THREADS&quot;)
1329 logger.quiet(&quot;COMPILE_TARGETS: $COMPILE_TARGETS&quot;)
1330 logger.quiet(&quot;COMPILE_FLAGS_FILES: $COMPILE_FLAGS_FILES&quot;)
1331 logger.quiet(&quot;HUDSON_JOB_NAME: $HUDSON_JOB_NAME&quot;)
1332 logger.quiet(&quot;HUDSON_BUILD_NUMBER: $HUDSON_BUILD_NUMBER&quot;)
1333 logger.quiet(&quot;PROMOTED_BUILD_NUMBER: $PROMOTED_BUILD_NUMBER&quot;)
1334 logger.quiet(&quot;PRODUCT_NAME: $PRODUCT_NAME&quot;)
1335 logger.quiet(&quot;RELEASE_VERSION: $RELEASE_VERSION&quot;)
1336 logger.quiet(&quot;RELEASE_SUFFIX: $RELEASE_SUFFIX&quot;)
1337 logger.quiet(&quot;RELEASE_VERSION_SHORT: $RELEASE_VERSION_SHORT&quot;)
1338 logger.quiet(&quot;RELEASE_VERSION_LONG: $RELEASE_VERSION_LONG&quot;)
1339 logger.quiet(&quot;RELEASE_VERSION_PADDED: $RELEASE_VERSION_PADDED&quot;)
1340 logger.quiet(&quot;MAVEN_VERSION: $MAVEN_VERSION&quot;)
1341 logger.quiet(&quot;UPDATE_STUB_CACHE: $UPDATE_STUB_CACHE&quot;)
1342 
1343 /******************************************************************************
1344  *                                                                            *
1345  *                Definition of Native Code Compilation Tasks                 *
1346  *                                                                            *
1347  *    - CCTask compiles native code. Specifically it will compile .m, .c,     *
1348  *      .cpp, or .cc files. It uses the headers provided by running           *
1349  *      &#39;javac -h&#39; plus additional platform specific headers. It will         *
1350  *      compile into .obj files.                                              *
1351  *    - LinkTask will perform native linking and create the .dll / .so /      *
1352  *      .dylib as necessary.                                                  *
1353  *                                                                            *
1354  *****************************************************************************/
1355 
1356 // Save a reference to the buildSrc.jar file because we need it for actually
1357 // compiling things, not just for the sake of this build script
1358 // (such as generating the JSL files, etc)
1359 ext.BUILD_SRC = rootProject.files(&quot;buildSrc/build/libs/buildSrc.jar&quot;)
1360 
1361 /**
1362  * Convenience method for creating cc, link, and &quot;native&quot; tasks in the given project. These
1363  * tasks are parameterized by name, so that we can produce, for example, ccGlass, etc
1364  * named tasks.
1365  *
1366  * @param project The project to add tasks to
1367  * @param name The name of the project, such as &quot;prism-common&quot;. This name is used
1368  *        in the name of the generated task, such as ccPrismCommon, and also
1369  *        in the name of the final library, such as libprism-common.dylib.
1370  */
1371 void addNative(Project project, String name) {
1372     // TODO if we want to handle 32/64 bit windows in the same build,
1373     // Then we will need to modify the win compile target to be win32 or win64
1374     def capitalName = name.split(&quot;-&quot;).collect{it.capitalize()}.join()
1375     def nativeTask = project.task(&quot;native$capitalName&quot;, group: &quot;Build&quot;) {
1376         description = &quot;Generates JNI headers, compiles, and builds native dynamic library for $name for all compile targets&quot;
1377     }
1378     def cleanTask = project.task(&quot;cleanNative$capitalName&quot;, type: Delete, group: &quot;Build&quot;) {
1379         description = &quot;Clean native objects for $name&quot;
1380     }
1381     if (project.hasProperty(&quot;nativeAllTask&quot;)) project.nativeAllTask.dependsOn nativeTask
1382     project.assemble.dependsOn(nativeTask)
1383     if (project.hasProperty(&quot;cleanNativeAllTask&quot;)) project.cleanNativeAllTask.dependsOn cleanTask
1384 
1385     // Each of the different compile targets will be placed in a sub directory
1386     // of these root dirs, with the name of the dir being the name of the target
1387     def nativeRootDir = project.file(&quot;$project.buildDir/native/$name&quot;)
1388     def libRootDir = project.file(&quot;$project.buildDir/libs/$name&quot;)
1389     // For each compile target, create a cc / link pair
1390     compileTargets { t -&gt;
1391         def targetProperties = project.rootProject.ext[t.upper]
1392         def library = targetProperties.library
1393         def properties = targetProperties.get(name)
1394         def nativeDir = file(&quot;$nativeRootDir/${t.name}&quot;)
1395         def headerDir = file(&quot;${project.buildDir}/gensrc/headers/${project.moduleName}&quot;)
1396 
1397         // If there is not a library clause in the properties, assume it is not wanted
1398         if (!targetProperties.containsKey(name)) {
1399             println(&quot;Ignoring native library ${name}. Not defined in ${t.name} project properties&quot;);
1400             return
1401         }
1402 
1403         // check for the property disable${name} = true
1404         def String disableKey = &quot;disable${name}&quot;
1405         def boolean disabled = targetProperties.containsKey(disableKey) ? targetProperties.get(disableKey) : false
1406         if (disabled) {
1407             println(&quot;Native library ${name} disabled in ${t.name} project properties&quot;);
1408             return
1409         }
1410 
1411         def variants = properties.containsKey(&quot;variants&quot;) ? properties.variants : [&quot;&quot;];
1412         variants.each { variant -&gt;
1413             def variantProperties = variant == &quot;&quot; ? properties : properties.get(variant)
1414             def capitalVariant = variant.capitalize()
1415             def ccOutput = variant == &quot;&quot; ? nativeDir : file(&quot;$nativeDir/$variant&quot;)
1416             def ccTask = project.task(&quot;cc${t.capital}$capitalName$capitalVariant&quot;, type: CCTask, group: &quot;Build&quot;) {
1417                 description = &quot;Compiles native sources for ${name} for ${t.name}${capitalVariant != &#39;&#39; ? &#39; for variant &#39; + capitalVariant : &#39;&#39;}&quot;
1418                 matches = &quot;.*\\.c|.*\\.cpp|.*\\.m|.*\\.cc&quot;
1419                 headers = headerDir
1420                 output(ccOutput)
1421                 params.addAll(variantProperties.ccFlags)
1422                 compiler = variantProperties.compiler
1423                 source(variantProperties.nativeSource)
1424                 cleanTask.delete ccOutput
1425             }
1426             def linkTask = project.task(&quot;link${t.capital}$capitalName$capitalVariant&quot;, type: LinkTask, dependsOn: ccTask, group: &quot;Build&quot;) {
1427                 description = &quot;Creates native dynamic library for $name for ${t.name}${capitalVariant != &#39;&#39; ? &#39; for variant &#39; + capitalVariant : &#39;&#39;}&quot;
1428                 objectDir = ccOutput
1429                 linkParams.addAll(variantProperties.linkFlags)
1430                 lib = file(&quot;$libRootDir/${t.name}/${variant == &#39;&#39; ? library(properties.lib) : library(variantProperties.lib)}&quot;)
1431                 linker = variantProperties.linker
1432                 cleanTask.delete &quot;$libRootDir/${t.name}&quot;
1433             }
1434             nativeTask.dependsOn(linkTask)
1435             if (IS_WINDOWS &amp;&amp; t.name == &quot;win&quot; &amp;&amp; (!IS_STATIC_BUILD || name == &quot;glass&quot;)) {
1436                 def rcTask = project.task(&quot;rc$capitalName$capitalVariant&quot;, type: CompileResourceTask, group: &quot;Build&quot;) {
1437                     description = &quot;Compiles native sources for $name&quot;
1438                     matches = &quot;.*\\.rc&quot;
1439                     compiler = variantProperties.rcCompiler
1440                     source(variantProperties.rcSource)
1441                     if (variantProperties.rcFlags) {
1442                         rcParams.addAll(variantProperties.rcFlags)
1443                     }
1444                     output(ccOutput)
1445                 }
1446                 linkTask.dependsOn rcTask;
1447             }
1448         }
1449 
1450         def useLipo = targetProperties.containsKey(&#39;useLipo&#39;) ? targetProperties.useLipo : false
1451         if (useLipo) {
1452             def lipoTask = project.task(&quot;lipo${t.capital}$capitalName&quot;, type: LipoTask, group: &quot;Build&quot;) {
1453                 description = &quot;Creates native fat library for $name for ${t.name}&quot;
1454                 libDir = file(&quot;$libRootDir/${t.name}&quot;)
1455                 lib = file(&quot;$libRootDir/${t.name}/${library(properties.lib)}&quot;)
1456             }
1457             nativeTask.dependsOn(lipoTask)
1458         }
1459     }
1460 }
1461 
1462 void addJSL(Project project, String name, String pkg, List&lt;String&gt; addExports, Closure compile) {
1463     def lowerName = name.toLowerCase()
1464 
1465     def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
1466     modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.base/build/classes/java/main&quot;
1467     def compileCompilers = project.task(&quot;compile${name}Compilers&quot;,
1468             type: JavaCompile,
1469             dependsOn: project.compileJava) {
1470         description = &quot;Compile the $name JSL Compilers&quot;
1471 
1472         classpath =
1473                project.files(project.sourceSets.jslc.java.outputDir) +
1474                project.configurations.antlr
1475         source = [project.file(&quot;src/main/jsl-$lowerName&quot;)]
1476         destinationDir = project.file(&quot;$project.buildDir/classes/jsl-compilers/$lowerName&quot;)
1477 
1478         options.compilerArgs.addAll([
1479             &quot;-implicit:none&quot;,
1480             &quot;--module-path&quot;, modulePath,
1481             &quot;--add-modules=javafx.graphics&quot;
1482             ])
1483         if (addExports != null) {
1484             options.compilerArgs.addAll(addExports)
1485         }
1486     }
1487 
1488     def generateShaders = project.task(&quot;generate${name}Shaders&quot;,
1489             dependsOn: compileCompilers) {
1490         description = &quot;Generate $name shaders from JSL&quot;
1491         def sourceDir = project.file(&quot;src/main/jsl-$lowerName&quot;)
1492         def destinationDir = project.file(&quot;$project.buildDir/gensrc/jsl-$lowerName&quot;)
1493         inputs.dir sourceDir
1494         outputs.dir destinationDir
1495         doLast {
1496             compile(sourceDir, destinationDir)
1497         }
1498     }
1499 
1500     def compileHLSLShaders = project.task(&quot;compile${name}HLSLShaders&quot;,
1501             dependsOn: generateShaders,
1502             type: CompileHLSLTask) {
1503         enabled = IS_WINDOWS
1504         description = &quot;Compile $name HLSL files into .obj files&quot;
1505         matches = &quot;.*\\.hlsl&quot;
1506         output project.file(&quot;$project.buildDir/hlsl/$name/$pkg&quot;)
1507         source project.file(&quot;$project.buildDir/gensrc/jsl-$lowerName/$pkg&quot;)
1508     }
1509 
1510     def processShaders = project.task(&quot;process${name}Shaders&quot;,
1511             dependsOn: [generateShaders, compileHLSLShaders],
1512             type: Copy,
1513             description: &quot;Copy hlsl / frag shaders to build/resources/jsl-$lowerName&quot;) {
1514         from(&quot;$project.buildDir/hlsl/$name&quot;) {
1515             include &quot;**/*.obj&quot;
1516         }
1517         from(&quot;$project.buildDir/gensrc/jsl-$lowerName&quot;) {
1518             include(&quot;**/*.frag&quot;)
1519         }
1520         into project.moduleDir
1521     }
1522 
1523     project.processShaders.dependsOn(processShaders)
1524     project.sourceSets.shaders.output.dir(&quot;$project.buildDir/gensrc/jsl-$lowerName&quot;, builtBy: processShaders )
1525 
1526     def processShimsShaders = project.task(&quot;process${name}ShimsShaders&quot;,
1527             dependsOn: [generateShaders, compileHLSLShaders],
1528             type: Copy,
1529             description: &quot;Copy hlsl / frag shaders to shims&quot;) {
1530         from(&quot;$project.buildDir/hlsl/$name&quot;) {
1531             include &quot;**/*.obj&quot;
1532         }
1533         from(&quot;$project.buildDir/gensrc/jsl-$lowerName&quot;) {
1534             include(&quot;**/*.frag&quot;)
1535         }
1536         into project.moduleShimsDir
1537     }
1538 
1539     project.processShimsShaders.dependsOn(processShimsShaders)
1540 
1541 }
1542 
1543 void addMavenPublication(Project project, List&lt;String&gt; projectDependencies) {
1544     project.apply plugin: &#39;maven-publish&#39;
1545 
1546     project.group = MAVEN_GROUP_ID
1547     project.version = MAVEN_VERSION
1548 
1549     if (project.name == &#39;base&#39;) {
1550         project.publishing {
1551             publications {
1552                 javafx(MavenPublication) {
1553                     artifactId = &#39;javafx&#39;
1554                     artifacts = []
1555                 }
1556             }
1557         }
1558     }
1559 
1560     gradle.taskGraph.whenReady { g -&gt;
1561         project.tasks.findAll { it.name == &#39;generatePomFileForJavafxPublication&#39;}.each { it -&gt;
1562             it.doLast {
1563                 copy {
1564                     into project.file(&quot;${project.buildDir}/publications/javafx&quot;)
1565                     from file(&quot;${rootProject.projectDir}/javafx.pom&quot;)
1566                     rename &quot;javafx.pom&quot;, &quot;pom-default.xml&quot;
1567                     filter { line -&gt;
1568                         line.replaceAll(&quot;@VERSION@&quot;, MAVEN_VERSION)
1569                     }
1570                 }
1571             }
1572         }
1573     }
1574 
1575     project.publishing {
1576         repositories {
1577             maven {
1578                 def repositoryUrl = project.hasProperty(&#39;repositoryUrl&#39;) ? project.getProperty(&#39;repositoryUrl&#39;) : &quot;&quot;
1579                 def repositoryUsername = project.hasProperty(&#39;repositoryUsername&#39;) ? project.getProperty(&#39;repositoryUsername&#39;) : &quot;&quot;
1580                 def repositoryPassword = project.hasProperty(&#39;repositoryPassword&#39;) ? project.getProperty(&#39;repositoryPassword&#39;) : &quot;&quot;
1581                 url repositoryUrl
1582                 credentials {
1583                    username repositoryUsername
1584                    password repositoryPassword
1585                 }
1586             }
1587         }
1588     }
1589 
1590     compileTargets { t -&gt;
1591         project.publishing {
1592             publications {
1593                 maven(MavenPublication) {
1594                     artifactId = &quot;javafx-${project.name}&quot;
1595 
1596                     afterEvaluate {
1597                         artifact project.tasks.&quot;moduleEmptyPublicationJar$t.capital&quot;
1598                         artifact project.tasks.&quot;modularPublicationJar$t.capital&quot; {
1599                             classifier &quot;$t.name&quot;
1600                         }
1601                     }
1602 
1603                     pom.withXml {
1604                         Node parent = asNode().appendNode(&quot;parent&quot;)
1605                         parent.appendNode(&quot;groupId&quot;, MAVEN_GROUP_ID)
1606                         parent.appendNode(&quot;artifactId&quot;, &quot;javafx&quot;)
1607                         parent.appendNode(&quot;version&quot;, MAVEN_VERSION)
1608 
1609                         Node dependencies = asNode().appendNode(&quot;dependencies&quot;)
1610 
1611                         Node projectDependencyPlatform = dependencies.appendNode(&quot;dependency&quot;)
1612                         projectDependencyPlatform.appendNode(&quot;groupId&quot;, MAVEN_GROUP_ID)
1613                         projectDependencyPlatform.appendNode(&quot;artifactId&quot;, &quot;javafx-${project.name}&quot;)
1614                         projectDependencyPlatform.appendNode(&quot;version&quot;, MAVEN_VERSION)
1615                         projectDependencyPlatform.appendNode(&quot;classifier&quot;, &quot;\${javafx.platform}&quot;)
1616 
1617                         if (!projectDependencies.empty) {
1618                             projectDependencies.each { dep -&gt;
1619                                 Node projectDependency = dependencies.appendNode(&quot;dependency&quot;)
1620                                 projectDependency.appendNode(&quot;groupId&quot;, MAVEN_GROUP_ID)
1621                                 projectDependency.appendNode(&quot;artifactId&quot;, &quot;javafx-$dep&quot;)
1622                                 projectDependency.appendNode(&quot;version&quot;, MAVEN_VERSION)
1623                            }
1624                         }
1625                     }
1626                 }
1627             }
1628 
1629         }
1630     }
1631 }
1632 
1633 /**
1634  * Verifies that all of the *.java files in a source tree have the
1635  * correct package name. If not, fail the build.
1636  *
1637  * @param sourceRoot the root of the source tree to check
1638  * @param hasModuleName true if the sources under sourceRoot are being
1639  * compiled as modules, with the immediate child directories being the
1640  * root(s) of the named modules being compiled. In this case the package
1641  * root is one directory below the sourceRoot.
1642  */
1643 void validatePackages(File sourceRoot, boolean hasModuleName) {
1644     if (!sourceRoot.isDirectory()) {
1645         return;
1646     }
1647     def err = false;
1648     String sourceString = sourceRoot.toString().replace(&quot;\\&quot;, &quot;/&quot;)
1649     def startPos = sourceString.length() + 1
1650     logger.info(&quot;validating packages for ${sourceRoot}&quot;)
1651     def inputFiles = fileTree(dir: sourceRoot, include: &quot;**/*.java&quot;)
1652     inputFiles.each { file -&gt;
1653         def packageRoot = file.toString().replace(&quot;\\&quot;, &quot;/&quot;).substring(startPos)
1654         if (hasModuleName) {
1655             packageRoot = packageRoot.substring(packageRoot.indexOf(&quot;/&quot;) + 1)
1656         }
1657         def endPos = packageRoot.lastIndexOf(&quot;/&quot;)
1658         def pkgEx = endPos &gt; -1 ?  packageRoot.substring(0, endPos).replace(&quot;/&quot;, &quot;.&quot;) : &quot;&quot;
1659         def pkg = &quot;&quot;
1660         file.withReader { reader -&gt;
1661             def line
1662             while ((line = reader.readLine()) != null) {
1663                 def words = line.trim().split(&quot;[ ;]+&quot;)
1664                 if (words.length &gt; 1 &amp;&amp; words[0] == &quot;package&quot;) {
1665                     pkg = words[1]
1666                     break;
1667                 }
1668             }
1669         }
1670         if (pkg != pkgEx) {
1671             err = true
1672             println &quot;*** ERROR: File location &lt;${file}&gt; does not match package name &lt;${pkg}&gt;&quot;
1673         }
1674     }
1675     if (err) {
1676         fail(&quot;Package validation failed&quot;)
1677     }
1678 }
1679 
1680 /**
1681  * Add a task to the given project to validate that the package names
1682  * of all java files in the given source sets have the correct package
1683  * name. If not, fail the build.
1684  */
1685 void addValidateSourceSets(Project project,
1686                            Collection&lt;SourceSet&gt; sourceSets,
1687                            Collection&lt;SourceSet&gt; modSourceSets) {
1688     def validateSourceSetsTask = project.task(&quot;validateSourceSets&quot;) {
1689         doLast {
1690             // Accumulate the root directories from all sourceSets.
1691             // We use a Set to elide duplicates (the shims sourceset
1692             // will include the dirs from the main sourceset)
1693             Set&lt;File&gt; sourceRoots = []
1694             sourceSets.each { srcSet -&gt;
1695                 srcSet.java.srcDirs.each { rootDir -&gt;
1696                     sourceRoots += rootDir
1697                 }
1698             }
1699             sourceRoots.each { rootDir -&gt;
1700                 validatePackages(rootDir, false)
1701             }
1702 
1703             Set&lt;File&gt; modSourceRoots = []
1704             modSourceSets.each { srcSet -&gt;
1705                 srcSet.java.srcDirs.each { rootDir -&gt;
1706                     modSourceRoots += rootDir
1707                 }
1708             }
1709             modSourceRoots.each { rootDir -&gt;
1710                 validatePackages(rootDir, true)
1711             }
1712         }
1713     }
1714 
1715     // Run this for all projects when compiling the test sources
1716     // (i.e., when running &quot;gradle test&quot;)
1717     project.compileTestJava.dependsOn(validateSourceSetsTask)
1718 }
1719 
1720 void addValidateSourceSets(Project project, Collection&lt;SourceSet&gt; sourceSets) {
1721     addValidateSourceSets(project, sourceSets, []);
1722 }
1723 
1724 
1725 /**
1726  * Parses a JDK version string. The string must be in one of the following
1727  * two formats:
1728  *
1729  *     major.minor.subminor
1730  * or
1731  *     major.minor.subminor_update
1732  *
1733  * In both cases a list of 4 integers is returned, with element 3 set to
1734  * 0 in the former case.
1735  */
1736 List parseJdkVersion(String version) {
1737     def arr = version.split(&quot;[_\\.]&quot;);
1738     def intArr = [];
1739     arr.each { s -&gt; intArr += Integer.parseInt(s); }
1740     while (intArr.size() &lt; 4) intArr += 0;
1741     return intArr;
1742 }
1743 
1744 /**
1745  * Returns -1, 0, or 1 depending on whether JDK version &quot;a&quot; is less than,
1746  * equal to, or grater than version &quot;b&quot;.
1747  */
1748 int compareJdkVersion(String a, String b) {
1749     def aIntArr = parseJdkVersion(a);
1750     def bIntArr = parseJdkVersion(b);
1751 
1752     for (int i = 0; i &lt; 4; i++) {
1753         if (aIntArr[i] &lt; bIntArr[i]) return -1;
1754         if (aIntArr[i] &gt; bIntArr[i]) return  1;
1755     }
1756     return 0;
1757 }
1758 
1759 // Task to verify the minimum level of Java needed to build JavaFX
1760 task verifyJava() {
1761     doLast {
1762         def status = compareJdkVersion(jdkVersion, jfxBuildJdkVersionMin);
1763         if (status &lt; 0) {
1764             fail(&quot;java version mismatch: JDK version (${jdkVersion}) &lt; minimum version (${jfxBuildJdkVersionMin})&quot;)
1765         } else if (status == 0) {
1766             def buildNum = Integer.parseInt(jdkBuildNumber)
1767             def minBuildNum = Integer.parseInt(jfxBuildJdkBuildnumMin)
1768             if (buildNum != 0 &amp;&amp; buildNum &lt; minBuildNum) {
1769                 fail(&quot;JDK build number ($buildNum) &lt; minimum build number ($minBuildNum)&quot;)
1770             }
1771         }
1772     }
1773 }
1774 
1775 task updateCacheIfNeeded() {
1776     // an empty task we can add to as needed for UPDATE_STUB_CACHE
1777 }
1778 
1779 task createTestArgfiles {
1780     // an empty task we can add to as needed
1781 }
1782 
1783 
1784 /*****************************************************************************
1785 *        Project definitions (dependencies, etc)                             *
1786 *****************************************************************************/
1787 
1788 void addJCov(p, test) {
1789     test.doFirst {
1790         def jcovJVMArgument =
1791                 &quot;include=javafx,&quot; +
1792                 &quot;include=com.sun.javafx,&quot; +
1793                 &quot;include=com.sun.glass,&quot; +
1794                 &quot;include=com.sun.openpisces,&quot; +
1795                 &quot;include=com.sun.pisces,&quot; +
1796                 &quot;include=com.sun.prism,&quot; +
1797                 &quot;include=com.sun.scenario,&quot; +
1798                 &quot;include=com.sun.webkit,&quot; +
1799                 &quot;exclude=com,&quot; +
1800                 &quot;exclude=java,&quot; +
1801                 &quot;exclude=javax,&quot; +
1802                 &quot;exclude=\&quot;**.test\&quot;,&quot; +
1803                 &quot;exclude=\&quot;**.*Test\&quot;,&quot; +
1804                 &quot;file=build/reports/jcov/report.xml,&quot; +
1805                 &quot;merge=merge&quot;;
1806         test.jvmArgs(&quot;-javaagent:${p.configurations.testCompile.files.find { it.name.startsWith(&#39;jcov&#39;) }}=$jcovJVMArgument&quot;);
1807         p.mkdir p.file(&quot;build/reports/jcov&quot;)
1808     }
1809     test.doLast {
1810         def reportFile = p.file(&quot;build/reports/jcov/report.xml&quot;)
1811         if (reportFile.exists()) {
1812             p.javaexec {
1813                 workingDir = p.file(&quot;build/reports/jcov&quot;)
1814                 classpath = p.files(p.configurations.testCompile.files.find { it.name.startsWith(&#39;jcov&#39;) })
1815                 main = &quot;com.sun.tdk.jcov.Helper&quot;
1816                 args = [
1817                         &quot;RepGen&quot;,
1818                         &quot;-exclude&quot;, &quot;\&quot;**.test\&quot;&quot;,
1819                         &quot;-exclude&quot;, &quot;\&quot;**.*Test\&quot;&quot;,
1820                         &quot;-output&quot;, &quot;.&quot;,
1821                         &quot;-source&quot;, p.sourceSets.main.java.srcDirs.collect{p.file(it)}.join(&quot;:&quot;),
1822                         &quot;report.xml&quot;
1823                 ]
1824             }
1825         }
1826     }
1827 }
1828 
1829 allprojects {
1830 
1831     // Setup the repositories that we&#39;ll download libraries from.
1832     // By default we use Maven Central for most things. The custom &quot;ivy&quot;
1833     // repo is for downloading SWT. The way it works is to setup the
1834     // download URL such that it will resolve to the actual jar file to
1835     // download. See SWT_FILE_NAME for the name of the jar that will be
1836     // used as the &quot;artifact&quot; in the pattern below.
1837     // If JFX_DEPS_URL is set, then that overrides the default
1838     // repositories. This allows the dependencies to be cached locally.
1839 
1840     if (JFX_DEPS_URL != &quot;&quot;) {
1841         repositories {
1842             ivy {
1843                 url JFX_DEPS_URL
1844                 metadataSources {
1845                     artifact()
1846                 }
1847                 patternLayout {
1848                     artifact &quot;[artifact]-[revision](-[classifier]).[ext]&quot;
1849                     artifact &quot;[artifact].[ext]&quot;
1850                 }
1851             }
1852         }
1853     }
1854 
1855     if (JFX_DEPS_URL == &quot;&quot;) {
1856         repositories {
1857             mavenCentral()
1858             ivy {
1859                 url &quot;https://download.eclipse.org/eclipse/updates/4.6/R-4.6.3-201703010400/plugins/&quot;
1860                 metadataSources {
1861                     artifact()
1862                 }
1863                 patternLayout {
1864                     artifact &quot;[artifact].[ext]&quot;
1865                 }
1866             }
1867         }
1868     }
1869 
1870     if (JFX_DEPS_URL == &quot;&quot; &amp;&amp; IS_BUILD_LIBAV_STUBS) {
1871         repositories {
1872             ivy {
1873                 url libAVRepositoryURL
1874                 metadataSources {
1875                     artifact()
1876                 }
1877                 patternLayout {
1878                     artifact &quot;[artifact].[ext]&quot;
1879                 }
1880             }
1881             ivy {
1882                 url FFmpegRepositoryURL
1883                 metadataSources {
1884                     artifact()
1885                 }
1886                 patternLayout {
1887                     artifact &quot;[artifact].[ext]&quot;
1888                 }
1889             }
1890         }
1891     }
1892 
1893     // We want to configure all projects as java projects and use the same compile settings
1894     // etc, except for the root project which we just want to ignore (and for now media)
1895     if (project == rootProject) {
1896        return
1897     }
1898     if (project.path.startsWith(&quot;:apps&quot;)) {
1899         // Lets handle the apps tree differently, as it is a collection of ant builds,
1900         // and the ant importer collides with the &#39;apply plugin:java&#39;
1901         return
1902     }
1903 
1904     // All of our projects are java projects
1905 
1906     apply plugin: &quot;java&quot;
1907     sourceCompatibility = 11
1908 
1909     // By default all of our projects require junit for testing so we can just
1910     // setup this dependency here.
1911     dependencies {
1912         testCompile group: &quot;junit&quot;, name: &quot;junit&quot;, version: &quot;4.8.2&quot;
1913         if (BUILD_CLOSED &amp;&amp; DO_JCOV)  {
1914             testCompile name: &quot;jcov&quot;
1915         }
1916     }
1917 
1918     compileJava.dependsOn verifyJava
1919 
1920     // At the moment the ASM library shipped with Gradle that is used to
1921     // discover the different test classes fails on Java 8, so in order
1922     // to have sourceCompatibility set to 1.8 I have to also turn scanForClasses off
1923     // and manually specify the includes / excludes. At the moment we use
1924     // Java 7 but when we switch to 8 this will be needed, and probably again when
1925     // we start building with Java 9.
1926     test {
1927         executable = JAVA;
1928         enableAssertions = true;
1929         testLogging.exceptionFormat = &quot;full&quot;;
1930         scanForTestClasses = false;
1931         include(&quot;**/*Test.*&quot;);
1932         if (BUILD_CLOSED &amp;&amp; DO_JCOV) {
1933             addJCov(project, test)
1934         }
1935 
1936         if (IS_HEADLESS_TEST) {
1937             systemProperty &#39;glass.platform&#39;, &#39;Monocle&#39;
1938             systemProperty &#39;monocle.platform&#39;, &#39;Headless&#39;
1939             systemProperty &#39;prism.order&#39;, &#39;sw&#39;
1940             systemProperty &#39;com.sun.javafx.gestures.zoom&#39;, &#39;true&#39;
1941             systemProperty &#39;com.sun.javafx.gestures.rotate&#39;, &#39;true&#39;
1942             systemProperty &#39;com.sun.javafx.gestures.scroll&#39;, &#39;true&#39;
1943         }
1944 
1945         systemProperty &#39;unstable.test&#39;, IS_UNSTABLE_TEST
1946     }
1947 
1948     compileTestJava {
1949     }
1950 }
1951 
1952 // These strings define the module-source-path to be used in compilation.
1953 // They need to contain the full paths to the sources and the * will be
1954 // used to infer the module name that is used.
1955 project.ext.defaultModuleSourcePath =
1956     cygpath(rootProject.projectDir.path + &#39;/modules/*/src/main/java&#39;) +
1957         File.pathSeparator  +
1958     cygpath(rootProject.projectDir.path + &#39;/modules/*/build/gensrc/{java,jsl-decora,jsl-prism}&#39;)
1959 
1960 // graphics pass one
1961 project.ext.defaultModuleSourcePath_GraphicsOne =
1962     cygpath(rootProject.projectDir.path + &#39;/modules/*/src/main/java&#39;) +
1963         File.pathSeparator  +
1964     cygpath(rootProject.projectDir.path + &#39;/modules/*/build/gensrc/{java,jsl-decora,jsl-prism}&#39;)
1965 
1966 // web pass one
1967 project.ext.defaultModuleSourcePath_WebOne =
1968     cygpath(rootProject.projectDir.path + &#39;/modules/*/src/main/java&#39;)
1969 
1970 // Compiling the test shim files too.
1971 project.ext.defaultModuleSourcePathShim =
1972     cygpath(rootProject.projectDir.path + &#39;/modules/*/src/{main,shims}/java&#39;) +
1973         File.pathSeparator  +
1974     cygpath(rootProject.projectDir.path + &#39;/modules/*/build/gensrc/{java,jsl-decora,jsl-prism}&#39;)
1975 
1976 // The &quot;base&quot; project is our first module and the most basic one required for
1977 // all other modules. It is useful even for non-GUI applications.
1978 project(&quot;:base&quot;) {
1979     project.ext.buildModule = true
1980     project.ext.includeSources = true
1981     project.ext.moduleRuntime = true
1982     project.ext.moduleName = &quot;javafx.base&quot;
1983 
1984     sourceSets {
1985         main
1986         shims {
1987             java {
1988                 compileClasspath += sourceSets.main.output
1989                 runtimeClasspath += sourceSets.main.output
1990             }
1991         }
1992         test {
1993             java {
1994                 compileClasspath += sourceSets.shims.output
1995                 runtimeClasspath += sourceSets.shims.output
1996             }
1997         }
1998     }
1999 
2000     dependencies {
2001         testCompile group: &quot;junit&quot;, name: &quot;junit&quot;, version: &quot;4.8.2&quot;
2002         testCompile sourceSets.main.output
2003         testCompile sourceSets.shims.output
2004     }
2005 
2006     commonModuleSetup(project, [ &#39;base&#39; ])
2007 
2008     project.ext.moduleSourcePath = defaultModuleSourcePath
2009     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2010 
2011     // We need to take the VersionInfo.java file and replace the various
2012     // properties within it
2013     def replacements = [
2014         &quot;BUILD_TIMESTAMP&quot;: BUILD_TIMESTAMP,
2015         &quot;HUDSON_JOB_NAME&quot;: HUDSON_JOB_NAME,
2016         &quot;HUDSON_BUILD_NUMBER&quot;: HUDSON_BUILD_NUMBER,
2017         &quot;PROMOTED_BUILD_NUMBER&quot;: PROMOTED_BUILD_NUMBER,
2018         &quot;PRODUCT_NAME&quot;: PRODUCT_NAME,
2019         &quot;RELEASE_VERSION&quot;: RELEASE_VERSION,
2020         &quot;RELEASE_SUFFIX&quot;: RELEASE_SUFFIX];
2021     task processVersionInfo(type: Copy, description: &quot;Replace params in VersionInfo and copy file to destination&quot;) {
2022         doFirst { mkdir &quot;$buildDir/gensrc/java&quot; }
2023         from &quot;src/main/version-info&quot;
2024         into &quot;$buildDir/gensrc/java/com/sun/javafx/runtime&quot;
2025         filter {line-&gt;
2026             replacements.each() {k, v -&gt;
2027                 line = line.replace(&quot;@$k@&quot;, v.toString());
2028             }
2029             line
2030         }
2031     }
2032 
2033     // Make sure to include $buildDir/gensrc/java that we previously created.
2034     // We DO NOT want to include src/main/version-info
2035 
2036     sourceSets.main.java.srcDirs += &quot;$buildDir/gensrc/java&quot;
2037 
2038     compileJava.dependsOn processVersionInfo
2039     addMavenPublication(project, [])
2040 
2041     addValidateSourceSets(project, sourceSets)
2042 }
2043 
2044 // The graphics module is needed for any graphical JavaFX application. It requires
2045 // the base module and includes the scene graph, layout, css, prism, windowing, etc.
2046 // This is a fairly complicated module. There are many different types of native components
2047 // that all need to be compiled.
2048 project(&quot;:graphics&quot;) {
2049 
2050     project.ext.buildModule = true
2051     project.ext.includeSources = true
2052     project.ext.moduleRuntime = true
2053     project.ext.moduleName = &quot;javafx.graphics&quot;
2054     project.ext.mavenPublish = true
2055 
2056     getConfigurations().create(&quot;antlr&quot;);
2057 
2058     sourceSets {
2059         jslc   // JSLC gramar subset
2060         main
2061         shims {
2062             java {
2063                 compileClasspath += sourceSets.main.output
2064                 runtimeClasspath += sourceSets.main.output
2065             }
2066         }
2067         shaders // generated shaders (prism &amp; decora)
2068         test {
2069             java {
2070                 compileClasspath += sourceSets.shims.output
2071                 runtimeClasspath += sourceSets.shims.output
2072             }
2073         }
2074         stub
2075     }
2076 
2077     dependencies {
2078         stubCompile group: &quot;junit&quot;, name: &quot;junit&quot;, version: &quot;4.8.2&quot;
2079 
2080         antlr group: &quot;org.antlr&quot;, name: &quot;antlr4&quot;, version: &quot;4.7.2&quot;, classifier: &quot;complete&quot;
2081         compile project(&#39;:base&#39;)
2082     }
2083 
2084     project.ext.moduleSourcePath = defaultModuleSourcePath_GraphicsOne
2085     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2086 
2087     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39; ])
2088 
2089     List&lt;String&gt; decoraAddExports = [
2090             &#39;--add-exports=javafx.graphics/com.sun.scenario.effect=ALL-UNNAMED&#39;,
2091             &#39;--add-exports=javafx.graphics/com.sun.scenario.effect.light=ALL-UNNAMED&#39;,
2092             &#39;--add-exports=javafx.graphics/com.sun.scenario.effect.impl.state=ALL-UNNAMED&#39;
2093             ]
2094     /*
2095     Graphics compilation is &quot;complicated&quot; by the generated shaders.
2096 
2097     We have two shader groups - Decora and Prism.
2098 
2099     The shader groups each will generate a custom compiler that
2100     then genarates the shader code. These compilers rely on the JSLC
2101     gramar parser which is antlr generated and compile separately.
2102 
2103     The decora compiler relies on compileJava - which is sourceSet.main.java
2104     It also accesses module private packages, so will need add-exports
2105 
2106     Once the shader java code is generated, we can compileFullJava
2107 
2108     After that, we can generate the required native header and then build the native code
2109     */
2110 
2111     project.task(&quot;processShaders&quot;) {
2112         // an empty task to hang the prism and decora shaders on
2113     }
2114 
2115     project.task(&quot;processShimsShaders&quot;) {
2116         // an empty task to hang the prism and decora shaders on
2117     }
2118 
2119     compileShimsJava.dependsOn(&quot;processShimsShaders&quot;)
2120 
2121     // Generate the JSLC support grammar
2122     project.task(&quot;generateGrammarSource&quot;, type: JavaExec) {
2123         // use antlr to generate our grammar.
2124         // note: the antlr plugin creates some issues with the other compiles
2125         // so we will do this by hand
2126 
2127         File wd = file(project.projectDir.path + &quot;/src/jslc/antlr&quot;)
2128         File outDir = file(&quot;$buildDir/gensrc/antlr&quot;)
2129         def inJSL = &quot;com/sun/scenario/effect/compiler/JSL.g4&quot;
2130         if (IS_WINDOWS) {
2131             // antlr needs backslashes on Windows
2132             inJSL = inJSL.replace(&quot;/&quot;, &quot;\\&quot;)
2133         }
2134 
2135         executable = JAVA
2136         classpath = project.configurations.antlr
2137         workingDir = wd
2138         main = &quot;org.antlr.v4.Tool&quot;
2139 
2140         args = [
2141             &quot;-o&quot;,
2142             outDir.toString(),
2143             &quot;-package&quot;,
2144             &quot;com.sun.scenario.effect.compiler&quot;,
2145             &quot;-visitor&quot;,
2146             inJSL ]
2147 
2148         inputs.dir wd
2149         outputs.dir outDir
2150     }
2151     sourceSets.jslc.java.srcDirs += &quot;$buildDir/gensrc/antlr&quot;
2152 
2153     // and compile the JSLC support classes
2154     compileJslcJava.dependsOn(generateGrammarSource)
2155     compileJslcJava.classpath = project.configurations.antlr
2156 
2157     compileJava.dependsOn(compileJslcJava)
2158 
2159     // this task is the &quot;second pass&quot; compile of all of the module classes
2160     project.task(&quot;compileFullJava&quot;, type: JavaCompile, dependsOn: processShaders) {
2161         description = &quot;Compile all of the graphics java classes - main and shaders&quot;
2162 
2163         classpath = configurations.compile
2164 
2165         source = project.sourceSets.main.java.srcDirs
2166         source += &quot;$buildDir/gensrc/java&quot;
2167         source += project.sourceSets.shaders.output
2168 
2169         destinationDir = project.sourceSets.main.java.outputDir
2170         options.compilerArgs.addAll([
2171             &#39;-h&#39;, &quot;$buildDir/gensrc/headers/&quot;,  // Note: this creates the native headers
2172             &#39;-implicit:none&#39;,
2173             &#39;--module-source-path&#39;, defaultModuleSourcePath
2174             ] )
2175     }
2176     classes.dependsOn(compileFullJava)
2177 
2178     project.sourceSets.shims.java.srcDirs += project.sourceSets.shaders.output
2179     project.sourceSets.shims.java.srcDirs += &quot;$buildDir/gensrc/jsl-prism&quot;
2180     project.sourceSets.shims.java.srcDirs += &quot;$buildDir/gensrc/jsl-decora&quot;
2181 
2182     compileShimsJava.dependsOn(compileFullJava)
2183 
2184     // Create a single &quot;native&quot; task which will depend on all the individual native tasks for graphics
2185     project.ext.nativeAllTask = task(&quot;native&quot;, group: &quot;Build&quot;, description: &quot;Compiles and Builds all native libraries for Graphics&quot;);
2186     project.ext.cleanNativeAllTask = task(&quot;cleanNative&quot;, group: &quot;Build&quot;, description: &quot;Clean all native libraries and objects for Graphics&quot;);
2187 
2188     // Add tasks for native compilation
2189     addNative(project, &quot;glass&quot;);
2190     addNative(project, &quot;prism&quot;)
2191     addNative(project, &quot;prismSW&quot;)
2192     addNative(project, &quot;font&quot;)
2193     addNative(project, &quot;iio&quot;)
2194     addNative(project, &quot;prismES2&quot;)
2195 
2196     if (IS_COMPILE_PANGO) {
2197         addNative(project, &quot;fontFreetype&quot;)
2198         addNative(project, &quot;fontPango&quot;)
2199     }
2200 
2201     if (IS_WINDOWS) {
2202         addNative(project, &quot;prismD3D&quot;)
2203         // TODO need to hook this up to be executed only if PassThroughVS.h is missing or PassThroughVS.hlsl is changed
2204         task generateD3DHeaders(group: &quot;Build&quot;) {
2205             enabled = IS_WINDOWS
2206             inputs.file &quot;src/main/native-prism-d3d/hlsl/Mtl1PS.hlsl&quot;
2207             inputs.file &quot;src/main/native-prism-d3d/hlsl/Mtl1VS.hlsl&quot;
2208             inputs.file &quot;src/main/native-prism-d3d/PassThroughVS.hlsl&quot;
2209             outputs.dir &quot;$buildDir/headers/PrismD3D/&quot;
2210             outputs.dir &quot;$buildDir/headers/PrismD3D/hlsl/&quot;
2211             description = &quot;Generate headers by compiling hlsl files&quot;
2212             doLast {
2213                 mkdir file(&quot;$buildDir/headers/PrismD3D/hlsl&quot;)
2214                 def PS_3D_SRC = file(&quot;src/main/native-prism-d3d/hlsl/Mtl1PS.hlsl&quot;)
2215                 def VS_3D_SRC = file(&quot;src/main/native-prism-d3d/hlsl/Mtl1VS.hlsl&quot;)
2216                 def PASSTHROUGH_VS_SRC = file(&quot;src/main/native-prism-d3d/PassThroughVS.hlsl&quot;)
2217                 def jobs = [
2218                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;vs_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/PassThroughVS.h&quot;, &quot;/E&quot;, &quot;passThrough&quot;, &quot;$PASSTHROUGH_VS_SRC&quot;],
2219                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS.h&quot;, &quot;/DSpec=0&quot;, &quot;/DSType=0&quot;, &quot;$PS_3D_SRC&quot;],
2220                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_i.h&quot;, &quot;/DSpec=0&quot;, &quot;/DSType=0&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2221                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1n.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=0&quot;, &quot;$PS_3D_SRC&quot;],
2222                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2n.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=0&quot;, &quot;$PS_3D_SRC&quot;],
2223                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3n.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=0&quot;, &quot;$PS_3D_SRC&quot;],
2224                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1t.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=1&quot;, &quot;$PS_3D_SRC&quot;],
2225                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2t.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=1&quot;, &quot;$PS_3D_SRC&quot;],
2226                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3t.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=1&quot;, &quot;$PS_3D_SRC&quot;],
2227                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1c.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=2&quot;, &quot;$PS_3D_SRC&quot;],
2228                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2c.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=2&quot;, &quot;$PS_3D_SRC&quot;],
2229                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3c.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=2&quot;, &quot;$PS_3D_SRC&quot;],
2230                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1m.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=3&quot;, &quot;$PS_3D_SRC&quot;],
2231                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2m.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=3&quot;, &quot;$PS_3D_SRC&quot;],
2232                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3m.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=3&quot;, &quot;$PS_3D_SRC&quot;],
2233                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1n.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2234                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2n.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2235                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3n.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2236                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1t.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2237                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2t.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2238                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3t.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2239                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1c.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2240                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2c.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2241                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3c.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2242                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1m.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2243                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2m.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2244                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3m.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;$PS_3D_SRC&quot;],
2245                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1ni.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=0&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2246                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2ni.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=0&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2247                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3ni.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=0&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2248                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1ti.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2249                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2ti.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2250                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3ti.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2251                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1ci.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=2&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2252                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2ci.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=2&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2253                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3ci.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=2&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2254                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s1mi.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=3&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2255                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s2mi.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=3&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2256                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_s3mi.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=3&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2257                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1ni.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2258                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2ni.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2259                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3ni.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=0&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2260                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1ti.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2261                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2ti.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2262                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3ti.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=1&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2263                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1ci.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2264                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2ci.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2265                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3ci.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=2&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2266                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b1mi.h&quot;, &quot;/DSpec=1&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2267                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b2mi.h&quot;, &quot;/DSpec=2&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2268                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;ps_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1PS_b3mi.h&quot;, &quot;/DSpec=3&quot;, &quot;/DSType=3&quot;, &quot;/DBump=1&quot;, &quot;/DIllumMap=1&quot;, &quot;$PS_3D_SRC&quot;],
2269                         [&quot;$FXC&quot;, &quot;/nologo&quot;, &quot;/T&quot;, &quot;vs_3_0&quot;, &quot;/Fh&quot;, &quot;$buildDir/headers/PrismD3D/hlsl/Mtl1VS_Obj.h&quot;, &quot;/DVertexType=ObjVertex&quot;, &quot;$VS_3D_SRC&quot;]
2270                 ]
2271                 final ExecutorService executor = Executors.newFixedThreadPool(Integer.parseInt(project.NUM_COMPILE_THREADS.toString()));
2272                 final CountDownLatch latch = new CountDownLatch(jobs.size());
2273                 List futures = new ArrayList&lt;Future&gt;();
2274                 jobs.each { cmd -&gt;
2275                     futures.add(executor.submit(new Runnable() {
2276                         @Override public void run() {
2277                             try {
2278                                 exec {
2279                                     commandLine cmd
2280                                 }
2281                             } finally {
2282                                 latch.countDown();
2283                             }
2284                         }
2285                     }));
2286                 }
2287                 latch.await();
2288                 // Looking for whether an exception occurred while executing any of the futures.
2289                 // By calling &quot;get()&quot; on each future an exception will be thrown if one had occurred
2290                 // on the background thread.
2291                 futures.each {it.get();}
2292             }
2293         }
2294 
2295         ccWinPrismD3D.dependsOn generateD3DHeaders
2296     }
2297 
2298     // The Decora and Prism JSL files have to be generated in a very specific set of steps.
2299     //      1) Compile the *Compile.java classes. These live in src/main/jsl-* and will be
2300     //         output to $buildDir/classes/jsl-compilers/* (where * == decora or prism).
2301     //      2) Generate source files from the JSL files contained in src/main/jsl-*. These
2302     //         will be output to $buildDir/gensrc/jsl-*
2303     //      3) Compile the JSL Java sources in $buildDir/gensrc/jsl-* and put the output
2304     //         into classes/jsl-*
2305     //      4) Compile the native JSL sources in $buildDir/gensrc/jsl-* and put the obj
2306     //         files into native/jsl-* and the resulting library into libs/jsl-*.dll|so|dylib
2307     //      5) Modify the jar step to include classes/jsl-*
2308     // The native library must be copied over during SDK creation time in the &quot;sdk&quot; task. In
2309     // addition to these steps, the clean task is created. Note that I didn&#39;t bother to create
2310     // a new task for each of the decora files, preferring instead just to create a rule?? Also
2311     // need &quot;clean&quot; tasks for each compile task.
2312 
2313     def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
2314     modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.base/build/classes/java/main&quot;
2315     addJSL(project, &quot;Decora&quot;, &quot;com/sun/scenario/effect/impl/hw/d3d/hlsl&quot;, decoraAddExports) { sourceDir, destinationDir -&gt;
2316         [[fileName: &quot;ColorAdjust&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2317          [fileName: &quot;Brightpass&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2318          [fileName: &quot;SepiaTone&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2319          [fileName: &quot;PerspectiveTransform&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2320          [fileName: &quot;DisplacementMap&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2321          [fileName: &quot;InvertMask&quot;, generator: &quot;CompileJSL&quot;, outputs: &quot;-all&quot;],
2322          [fileName: &quot;Blend&quot;, generator: &quot;CompileBlend&quot;, outputs: &quot;-all&quot;],
2323          [fileName: &quot;PhongLighting&quot;, generator: &quot;CompilePhong&quot;, outputs: &quot;-all&quot;],
2324          [fileName: &quot;LinearConvolve&quot;, generator: &quot;CompileLinearConvolve&quot;, outputs: &quot;-hw&quot;],
2325          [fileName: &quot;LinearConvolveShadow&quot;, generator: &quot;CompileLinearConvolve&quot;, outputs: &quot;-hw&quot;]].each { settings -&gt;
2326             javaexec {
2327                 executable = JAVA
2328                 workingDir = project.projectDir
2329                 main = settings.generator
2330                 classpath = configurations.compile + configurations.antlr
2331                 classpath += files(project.sourceSets.jslc.java.outputDir)
2332 
2333                 classpath += files(&quot;${project.projectDir}/src/jslc/resources&quot;)
2334 
2335                 classpath += files(&quot;$buildDir/classes/jsl-compilers/decora&quot;)
2336                 jvmArgs += &quot;--module-path=$modulePath&quot;
2337                 jvmArgs += &quot;--add-modules=javafx.graphics&quot;
2338                 jvmArgs += decoraAddExports
2339                 args += [&quot;-i&quot;, sourceDir, &quot;-o&quot;, destinationDir, &quot;-t&quot;, &quot;-pkg&quot;, &quot;com/sun/scenario/effect&quot;, &quot;$settings.outputs&quot;, &quot;$settings.fileName&quot;]
2340             }
2341         }
2342     }
2343 
2344 
2345     task nativeDecora(dependsOn: compileDecoraHLSLShaders, group: &quot;Build&quot;) {
2346         description = &quot;Generates JNI headers, compiles, and builds native dynamic library for Decora&quot;
2347     }
2348     task cleanNativeDecora(type: Delete, group: &quot;Build&quot;) {
2349         description = &quot;Clean native objects for Decora&quot;
2350     }
2351 
2352     def headerDir = file(&quot;$buildDir/gensrc/headers/javafx.graphics&quot;)
2353     def nativeRootDir = project.file(&quot;$project.buildDir/native/jsl-decora&quot;)
2354     def libRootDir = project.file(&quot;$project.buildDir/libs/jsl-decora&quot;)
2355     // For each compile target, create cc and link tasks
2356     compileTargets { t -&gt;
2357         def target = t.name
2358         def upperTarget = t.upper
2359         def capitalTarget = t.capital
2360         def targetProperties = rootProject.ext[upperTarget];
2361         def library = targetProperties.library
2362         def properties = targetProperties.get(&#39;decora&#39;)
2363         def nativeDir = file(&quot;$nativeRootDir/$target&quot;);
2364 
2365         def variants = properties.containsKey(&quot;variants&quot;) ? properties.variants : [&quot;&quot;];
2366         variants.each { variant -&gt;
2367             def variantProperties = variant == &quot;&quot; ? properties : properties.get(variant)
2368             def capitalVariant = variant.capitalize()
2369             def ccOutput = variant == &quot;&quot; ? nativeDir : file(&quot;$nativeDir/$variant&quot;)
2370 
2371             def ccTask = task(&quot;compileDecoraNativeShaders$capitalTarget$capitalVariant&quot;, type: CCTask ) {
2372                 description = &quot;Compiles Decora SSE natives for ${t.name}${capitalVariant != &#39;&#39; ? &#39; for variant &#39; + capitalVariant : &#39;&#39;}&quot;
2373                 matches = &quot;.*\\.cc&quot;
2374                 source file(&quot;$buildDir/gensrc/jsl-decora&quot;)
2375                 source file(project.projectDir.path + &quot;/src/main/native-decora&quot;)
2376                 headers = headerDir
2377                 params.addAll(variantProperties.ccFlags)
2378                 output(ccOutput)
2379                 compiler = variantProperties.compiler
2380                 cleanNativeDecora.delete ccOutput
2381             }
2382 
2383             def linkTask = task(&quot;linkDecoraNativeShaders$capitalTarget$capitalVariant&quot;, type: LinkTask, dependsOn: ccTask) {
2384                 description = &quot;Creates native dynamic library for Decora SSE ${t.name}${capitalVariant != &#39;&#39; ? &#39; for variant &#39; + capitalVariant : &#39;&#39;}&quot;
2385                 objectDir = ccOutput
2386                 linkParams.addAll(variantProperties.linkFlags)
2387                 lib = file(&quot;$libRootDir/$t.name/${library(variantProperties.lib)}&quot;)
2388                 linker = variantProperties.linker
2389                 cleanNativeDecora.delete &quot;$libRootDir/$t.name/&quot;
2390             }
2391 
2392             if (IS_WINDOWS &amp;&amp; target == &quot;win&quot;) {
2393                 def rcTask = project.task(&quot;rcDecoraNativeShaders$capitalTarget$capitalVariant&quot;, type: CompileResourceTask) {
2394                     description = &quot;Compiles native sources for Decora SSE&quot;
2395                     matches = &quot;.*\\.rc&quot;
2396                     compiler = variantProperties.rcCompiler
2397                     source(variantProperties.rcSource)
2398                     if (variantProperties.rcFlags) {
2399                         rcParams.addAll(variantProperties.rcFlags)
2400                     }
2401                     output(ccOutput)
2402                 }
2403                 linkTask.dependsOn rcTask;
2404             }
2405 
2406             nativeDecora.dependsOn(linkTask)
2407         }
2408     }
2409 
2410     // Prism JSL
2411     addJSL(project, &quot;Prism&quot;, &quot;com/sun/prism/d3d/hlsl&quot;, null) { sourceDir, destinationDir -&gt;
2412         def inputFiles = fileTree(dir: sourceDir)
2413         inputFiles.include &quot;**/*.jsl&quot;
2414         inputFiles.each { file -&gt;
2415             javaexec {
2416                 executable = JAVA
2417                 workingDir = project.projectDir
2418                 main = &quot;CompileJSL&quot;
2419                 classpath = configurations.compile + configurations.antlr
2420                 classpath += files(project.sourceSets.jslc.java.outputDir)
2421                 classpath += files(project.sourceSets.jslc.resources)
2422                 classpath += files(&quot;$buildDir/classes/jsl-compilers/prism&quot;,
2423                     project.projectDir.path + &quot;/src/main/jsl-prism&quot;) // for the .stg
2424                 args = [&quot;-i&quot;, sourceDir, &quot;-o&quot;, destinationDir, &quot;-t&quot;, &quot;-pkg&quot;, &quot;com/sun/prism&quot;, &quot;-d3d&quot;, &quot;-es2&quot;, &quot;-name&quot;, &quot;$file&quot;]
2425             }
2426         }
2427     }
2428 
2429     nativePrism.dependsOn compilePrismHLSLShaders;
2430 
2431     project.nativeAllTask.dependsOn nativeDecora
2432     project.cleanNativeAllTask.dependsOn cleanNativeDecora
2433     assemble.dependsOn nativeDecora
2434     processResources.dependsOn processDecoraShaders, processPrismShaders
2435 
2436     test {
2437         def cssDir = file(&quot;$buildDir/classes/java/main/${moduleName}/javafx&quot;)
2438         jvmArgs &quot;-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit&quot;,
2439             &quot;-DCSS_META_DATA_TEST_DIR=$cssDir&quot;
2440         enableAssertions = true
2441         testLogging.exceptionFormat = &quot;full&quot;
2442         scanForTestClasses = false
2443         include &quot;**/*Test.*&quot;
2444         if (BUILD_CLOSED &amp;&amp; DO_JCOV) {
2445             addJCov(project, test)
2446         }
2447     }
2448 
2449     // To enable the IDEs to all be happy (no red squiggles) we need to have the libraries
2450     // available in some known location. Maybe in the future the Gradle plugins to each
2451     // of the IDEs will be good enough that we won&#39;t need this hack anymore.
2452     classes {
2453         doLast {
2454             // Copy all of the download libraries to the libs directory for the sake of the IDEs
2455             File libsDir = rootProject.file(&quot;build/libs&quot;);
2456 
2457             // In some IDEs (Eclipse for example), touching these libraries
2458             // cauese a full build within the IDE. When gradle is used
2459             // outside of the IDE, for example to build the native code,
2460             // a full rebuild is caused within the IDE. The fix is to check
2461             // for the presence of the target files in the lib directory
2462             // and not copy the files if all are present.
2463 
2464             libsDir.mkdirs();
2465 
2466             def allLibsPresent = true
2467             def libNames = [ &quot;antlr4-4.7.2-complete.jar&quot; ]
2468             libNames.each { name -&gt;
2469                 File f = new File(libsDir, name)
2470                 if (!f.exists()) allLibsPresent = false
2471             }
2472             if (allLibsPresent) return;
2473 
2474             for (File f : [configurations.compile.files, configurations.antlr.files].flatten()) {
2475                 copy {
2476                     into libsDir
2477                     from f.getParentFile()
2478                     include &quot;**/antlr4-4.7.2-complete.jar&quot;
2479                     includeEmptyDirs = false
2480                 }
2481             }
2482         }
2483     }
2484 
2485     addMavenPublication(project, [ &#39;base&#39; ])
2486 
2487     addValidateSourceSets(project, sourceSets)
2488 }
2489 
2490 project(&quot;:controls&quot;) {
2491     project.ext.buildModule = true
2492     project.ext.includeSources = true
2493     project.ext.moduleRuntime = true
2494     project.ext.moduleName = &quot;javafx.controls&quot;
2495 
2496     sourceSets {
2497         main
2498         shims {
2499             java {
2500                 compileClasspath += sourceSets.main.output
2501                 runtimeClasspath += sourceSets.main.output
2502             }
2503         }
2504         test {
2505             java {
2506                 compileClasspath += sourceSets.shims.output
2507                 runtimeClasspath += sourceSets.shims.output
2508             }
2509         }
2510     }
2511 
2512     project.ext.moduleSourcePath = defaultModuleSourcePath
2513     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2514 
2515     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;controls&#39; ])
2516 
2517     dependencies {
2518         testCompile project(&quot;:graphics&quot;).sourceSets.test.output
2519         testCompile project(&quot;:base&quot;).sourceSets.test.output
2520         compile project(&#39;:base&#39;)
2521         compile project(&#39;:graphics&#39;)
2522     }
2523 
2524     test {
2525         def cssDir = file(&quot;$buildDir/classes/java/main/${moduleName}/javafx&quot;)
2526         jvmArgs &quot;-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit&quot;,
2527             &quot;-DCSS_META_DATA_TEST_DIR=$cssDir&quot;
2528     }
2529 
2530     def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
2531     modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.graphics/build/classes/java/main&quot;
2532     modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.base/build/classes/java/main&quot;
2533     processResources {
2534       doLast {
2535         def cssFiles = fileTree(dir: &quot;$moduleDir/com/sun/javafx/scene/control/skin&quot;)
2536         cssFiles.include &quot;**/*.css&quot;
2537         cssFiles.each { css -&gt;
2538             logger.info(&quot;converting CSS to BSS ${css}&quot;);
2539 
2540             javaexec {
2541                 executable = JAVA
2542                 workingDir = project.projectDir
2543                 jvmArgs += patchModuleArgs
2544                 jvmArgs += &quot;--module-path=$modulePath&quot;
2545                 jvmArgs += &quot;--add-modules=javafx.graphics&quot;
2546                 main = &quot;com.sun.javafx.css.parser.Css2Bin&quot;
2547                 args css
2548             }
2549         }
2550       }
2551     }
2552 
2553     processShimsResources.dependsOn(project.task(&quot;copyShimBss&quot;, type: Copy) {
2554         from project.moduleDir
2555         into project.moduleShimsDir
2556         include &quot;**/*.bss&quot;
2557     })
2558 
2559     addMavenPublication(project, [ &#39;graphics&#39; ])
2560 
2561     addValidateSourceSets(project, sourceSets)
2562 }
2563 
2564 project(&quot;:swing&quot;) {
2565 
2566     tasks.all {
2567         if (!COMPILE_SWING) it.enabled = false
2568     }
2569 
2570     project.ext.buildModule = COMPILE_SWING
2571     project.ext.includeSources = true
2572     project.ext.moduleRuntime = true
2573     project.ext.moduleName = &quot;javafx.swing&quot;
2574 
2575     sourceSets {
2576         main
2577         shims {
2578             java {
2579                 compileClasspath += sourceSets.main.output
2580                 runtimeClasspath += sourceSets.main.output
2581             }
2582         }
2583         test {
2584             java {
2585                 compileClasspath += sourceSets.shims.output
2586                 runtimeClasspath += sourceSets.shims.output
2587             }
2588         }
2589     }
2590 
2591     project.ext.moduleSourcePath = defaultModuleSourcePath
2592     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2593 
2594     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;swing&#39; ])
2595 
2596     dependencies {
2597         compile project(&quot;:base&quot;)
2598         compile project(&quot;:graphics&quot;)
2599     }
2600 
2601     test {
2602         enabled = IS_FULL_TEST &amp;&amp; IS_AWT_TEST
2603     }
2604 
2605     if (COMPILE_SWING) {
2606         addMavenPublication(project, [ &#39;graphics&#39; ])
2607     }
2608 
2609     addValidateSourceSets(project, sourceSets)
2610 }
2611 
2612 project(&quot;:swt&quot;) {
2613     tasks.all {
2614         if (!COMPILE_SWT) it.enabled = false
2615     }
2616 
2617     // javafx.swt is an automatic module
2618     project.ext.buildModule = false
2619 
2620     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39; ])
2621 
2622     dependencies {
2623         compile name: SWT_FILE_NAME
2624     }
2625 
2626     classes {
2627         doLast {
2628             // Copy all of the download libraries to libs directory for the sake of the IDEs
2629             File libsDir = rootProject.file(&quot;build/libs&quot;);
2630             File swtLib = new File(libsDir, &quot;swt-debug.jar&quot;)
2631             libsDir.mkdirs();
2632 
2633             // Skip copy if file is present.
2634             if (swtLib.exists()) return;
2635 
2636             for (File f : configurations.compile.files) {
2637                 // Have to rename the swt jar because it is some platform specific name but
2638                 // for the sake of the IDEs we need to have a single stable name that works
2639                 // on every platform
2640                 copy {
2641                     into libsDir
2642                     from f.getParentFile()
2643                     include &quot;**/*swt*.jar&quot;
2644                     includeEmptyDirs = false
2645                     rename &quot;.*swt.*jar&quot;, &quot;swt-debug\\.jar&quot;
2646                 }
2647             }
2648         }
2649     }
2650 
2651     compileJava.options.compilerArgs.addAll([
2652             &quot;--add-exports=javafx.graphics/com.sun.glass.ui=ALL-UNNAMED&quot;,
2653             &quot;--add-exports=javafx.graphics/com.sun.javafx.cursor=ALL-UNNAMED&quot;,
2654             &quot;--add-exports=javafx.graphics/com.sun.javafx.embed=ALL-UNNAMED&quot;,
2655             &quot;--add-exports=javafx.graphics/com.sun.javafx.stage=ALL-UNNAMED&quot;,
2656             &quot;--add-exports=javafx.graphics/com.sun.javafx.tk=ALL-UNNAMED&quot;,
2657             ])
2658 
2659     test {
2660         //enabled = IS_FULL_TEST &amp;&amp; IS_SWT_TEST
2661         enabled = false // FIXME: JIGSAW -- support this with modules
2662         logger.info(&quot;JIGSAW Testing disabled for swt&quot;)
2663 
2664         if (IS_MAC) {
2665             enabled = false
2666             logger.info(&quot;SWT tests are disabled on MAC, because Gradle test runner does not handle -XstartOnFirstThread properly (https://issues.gradle.org/browse/GRADLE-3290).&quot;)
2667         }
2668     }
2669 
2670     addValidateSourceSets(project, sourceSets)
2671 }
2672 
2673 project(&quot;:fxml&quot;) {
2674     project.ext.buildModule = true
2675     project.ext.includeSources = true
2676     project.ext.moduleRuntime = true
2677     project.ext.moduleName = &quot;javafx.fxml&quot;
2678 
2679     sourceSets {
2680         main
2681         shims {
2682             java {
2683                 compileClasspath += sourceSets.main.output
2684                 runtimeClasspath += sourceSets.main.output
2685             }
2686         }
2687         test {
2688             java {
2689                 compileClasspath += sourceSets.shims.output
2690                 runtimeClasspath += sourceSets.shims.output
2691             }
2692         }
2693     }
2694 
2695     project.ext.moduleSourcePath = defaultModuleSourcePath
2696     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2697 
2698     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;controls&#39;, &#39;fxml&#39; ])
2699 
2700 
2701     dependencies {
2702         testCompile project(&quot;:graphics&quot;).sourceSets.test.output
2703         testCompile project(&quot;:base&quot;).sourceSets.test.output
2704         compile project(&quot;:base&quot;)
2705         compile project(&quot;:graphics&quot;)
2706     }
2707 
2708     test {
2709         // StubToolkit is not *really* needed here, but because some code inadvertently invokes performance
2710         // tracker and this attempts to fire up the toolkit and this looks for native libraries and fails,
2711         // we have to use the stub toolkit for now.
2712         jvmArgs &quot;-Djavafx.toolkit=test.com.sun.javafx.pgstub.StubToolkit&quot;
2713         // FIXME: change this to also allow JDK 9 boot jdk
2714         classpath += files(&quot;$JDK_HOME/jre/lib/ext/nashorn.jar&quot;)
2715     }
2716 
2717     addMavenPublication(project, [ &#39;controls&#39; ])
2718 
2719     addValidateSourceSets(project, sourceSets)
2720 }
2721 
2722 project(&quot;:media&quot;) {
2723     configurations {
2724         media
2725     }
2726 
2727     project.ext.buildModule = true
2728     project.ext.includeSources = true
2729     project.ext.moduleRuntime = true
2730     project.ext.moduleName = &quot;javafx.media&quot;
2731 
2732     sourceSets {
2733         main
2734         //shims // no test shims needed
2735         test
2736         tools {
2737             java.srcDir &quot;src/tools/java&quot;
2738         }
2739     }
2740 
2741     project.ext.moduleSourcePath = defaultModuleSourcePath
2742     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
2743 
2744     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;media&#39; ])
2745 
2746     dependencies {
2747         if (IS_BUILD_LIBAV_STUBS) {
2748             media name: &quot;libav-9.14&quot;, ext: &quot;tar.gz&quot;
2749             media name: &quot;libav-11.4&quot;, ext: &quot;tar.gz&quot;
2750             media name: &quot;libav-12.1&quot;, ext: &quot;tar.gz&quot;
2751             media name: &quot;ffmpeg-3.3.3&quot;, ext: &quot;tar.gz&quot;
2752             media name: &quot;ffmpeg-4.0.2&quot;, ext: &quot;tar.gz&quot;
2753         }
2754         compile project(&quot;:base&quot;)
2755         compile project(&quot;:graphics&quot;)
2756     }
2757 
2758     compileJava.dependsOn updateCacheIfNeeded
2759 
2760     compileJava {
2761         // generate the native headers during compile
2762         options.compilerArgs.addAll([
2763             &#39;-h&#39;, &quot;${project.buildDir}/gensrc/headers&quot;
2764             ])
2765     }
2766 
2767     compileToolsJava {
2768         enabled = IS_COMPILE_MEDIA
2769         def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
2770         options.compilerArgs.addAll([
2771             &quot;--module-path=$modulePath&quot;,
2772             &quot;--add-modules=javafx.media&quot;,
2773             &#39;--add-exports&#39;, &#39;javafx.media/com.sun.media.jfxmedia=ALL-UNNAMED&#39;,
2774             ])
2775     }
2776 
2777     project.ext.makeJobsFlag = IS_WINDOWS &amp;&amp; IS_DEBUG_NATIVE ? &quot;-j1&quot; : &quot;-j5&quot;;
2778     project.ext.buildType = IS_DEBUG_NATIVE ? &quot;Debug&quot; : &quot;Release&quot;;
2779 
2780     def nativeSrcDir = file(&quot;${projectDir}/src/main/native&quot;)
2781     def generatedHeadersDir = file(&quot;${buildDir}/gensrc/headers/${project.moduleName}&quot;)
2782 
2783     task generateMediaErrorHeader(dependsOn: [compileJava, compileToolsJava]) {
2784         enabled = IS_COMPILE_MEDIA
2785         def headerpath = file(&quot;$generatedHeadersDir/jfxmedia_errors.h&quot;);
2786         doLast {
2787             def classpath = files(sourceSets.tools.output);
2788             def sourcepath = sourceSets.main.java.srcDirs;
2789             def srcRoot = (sourcepath.toArray())[0];
2790 
2791             mkdir generatedHeadersDir;
2792 
2793             def modulePath = &quot;${project.sourceSets.main.java.outputDir}&quot;
2794             modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.graphics/build/classes/java/main&quot;
2795             modulePath += File.pathSeparator + &quot;${rootProject.projectDir}/modules/javafx.base/build/classes/java/main&quot;
2796 
2797             exec {
2798                 commandLine(&quot;$JAVA&quot;);
2799                 args += patchModuleArgs
2800                 args += [ &quot;--module-path=$modulePath&quot; ]
2801                 args += [ &quot;--add-modules=javafx.media&quot; ]
2802                 args +=  [ &#39;--add-exports=javafx.media/com.sun.media.jfxmedia=ALL-UNNAMED&#39; ]
2803                 args +=  [ &#39;-classpath&#39;, &quot;${classpath.asPath}&quot; ]
2804                 args += [ &quot;headergen.HeaderGen&quot;, &quot;$headerpath&quot;, &quot;$srcRoot&quot; ]
2805             }
2806         }
2807         outputs.file(project.file(&quot;$headerpath&quot;))
2808     }
2809 
2810     task buildNativeTargets {
2811         enabled = IS_COMPILE_MEDIA
2812     }
2813 
2814     compileTargets { t-&gt;
2815         def targetProperties = project.rootProject.ext[t.upper]
2816         def nativeOutputDir = file(&quot;${buildDir}/native/${t.name}&quot;)
2817         def projectDir = t.name.startsWith(&quot;arm&quot;) ? &quot;linux&quot; : t.name
2818         def mediaProperties = targetProperties.media
2819         // Makefile for OSX needs to know if we&#39;re building for parfait
2820         def compileParfait = IS_COMPILE_PARFAIT ? &quot;true&quot; : &quot;false&quot;
2821 
2822         def buildNative = task(&quot;build${t.capital}Native&quot;, dependsOn: [generateMediaErrorHeader]) {
2823             enabled = targetProperties.compileMediaNative
2824             if (!targetProperties.compileMediaNative) {
2825                 println(&quot;Not compiling native Media for ${t.name} per configuration request&quot;);
2826             }
2827 
2828             doLast {
2829                 exec {
2830                     commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/jfxmedia/projects/${projectDir}&quot;)
2831                     args(&quot;JAVA_HOME=${JDK_HOME}&quot;, &quot;GENERATED_HEADERS_DIR=${generatedHeadersDir}&quot;,
2832                          &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=jfxmedia&quot;,
2833                          &quot;COMPILE_PARFAIT=${compileParfait}&quot;,
2834                          IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;,
2835                         &quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
2836 
2837                     if (t.name == &quot;win&quot;) {
2838                         environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
2839                         args( &quot;RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.jfxmediaRcFile}&quot;)
2840                     } else {
2841                         if (t.name.startsWith(&quot;arm&quot;)) {
2842                             args(&quot;EXTRA_CFLAGS=${mediaProperties.extra_cflags}&quot;, &quot;EXTRA_LDFLAGS=${mediaProperties.extra_ldflags}&quot;)
2843                         } else {
2844                             args(&quot;HOST_COMPILE=1&quot;)
2845                         }
2846                     }
2847                 }
2848             }
2849         }
2850 
2851         // check for the property disable${name} = true
2852         def boolean disabled = targetProperties.containsKey(&#39;disableMedia&#39;) ? targetProperties.get(&#39;disableMedia&#39;) : false
2853         if (!disabled) {
2854             // Building GStreamer
2855             def buildGStreamer = task(&quot;build${t.capital}GStreamer&quot;) {
2856                 enabled = IS_COMPILE_MEDIA
2857                 doLast {
2858                     exec {
2859                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/gstreamer-lite&quot;)
2860                         args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=gstreamer-lite&quot;,
2861                              IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;, &quot;CC=${mediaProperties.compiler}&quot;,
2862                              &quot;AR=${mediaProperties.ar}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
2863 
2864                         if (t.name == &quot;win&quot;) {
2865                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
2866                             args(&quot;RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.gstreamerRcFile}&quot;)
2867                         }
2868                     }
2869                 }
2870             }
2871 
2872             def buildPlugins = task(&quot;build${t.capital}Plugins&quot;, dependsOn: buildGStreamer) {
2873                 enabled = IS_COMPILE_MEDIA
2874 
2875                 doLast {
2876                     exec {
2877                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/fxplugins&quot;)
2878                         args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=fxplugins&quot;,
2879                              IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;,
2880                              &quot;CC=${mediaProperties.compiler}&quot;, &quot;AR=${mediaProperties.ar}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
2881 
2882                         if (t.name == &quot;win&quot;) {
2883                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
2884                             args(&quot;RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.fxpluginsRcFile}&quot;)
2885                         }
2886                     }
2887                 }
2888             }
2889 
2890             buildNative.dependsOn buildPlugins
2891 
2892             if (t.name == &quot;linux&quot;) {
2893                 // Pre-defined command line arguments
2894                 def cfgCMDArgs = [&quot;sh&quot;, &quot;configure&quot;]
2895                 def commonCfgArgs = [&quot;--enable-shared&quot;, &quot;--disable-debug&quot;, &quot;--disable-static&quot;, &quot;--disable-yasm&quot;, &quot;--disable-doc&quot;, &quot;--disable-programs&quot;, &quot;--disable-everything&quot;]
2896                 def codecsCfgArgs = [&quot;--enable-decoder=aac,mp3,mp3float,h264&quot;, &quot;--enable-parser=aac,h264&quot;, &quot;--enable-demuxer=aac,h264,mpegts,mpegtsraw&quot;]
2897 
2898                 def copyLibAVStubs = {String fromDir, String toDir -&gt;
2899                     FileCollection config = files(&quot;config.h&quot;)
2900                     FileCollection libavcodec = files(&quot;avcodec.h&quot;, &quot;avfft.h&quot;, &quot;dxva2.h&quot;, &quot;vaapi.h&quot;, &quot;vda.h&quot;,
2901                                                       &quot;vdpau.h&quot;, &quot;version.h&quot;, &quot;xvmc.h&quot;, &quot;old_codec_ids.h&quot;)
2902                     FileCollection libavdevice = files(&quot;avdevice.h&quot;, &quot;version.h&quot;)
2903                     FileCollection libavfilter = files(&quot;avfiltergraph.h&quot;, &quot;avfilter.h&quot;, &quot;buffersink.h&quot;, &quot;buffersrc.h&quot;, &quot;version.h&quot;);
2904                     FileCollection libavformat = files(&quot;avformat.h&quot;, &quot;avio.h&quot;, &quot;version.h&quot;)
2905                     FileCollection libavresample = files(&quot;avresample.h&quot;, &quot;version.h&quot;)
2906                     FileCollection libavutil = files(&quot;adler32.h&quot;, &quot;blowfish.h&quot;, &quot;error.h&quot;, &quot;log.h&quot;, &quot;pixfmt.h&quot;,
2907                                                      &quot;aes.h&quot;, &quot;bswap.h&quot;, &quot;eval.h&quot;, &quot;lzo.h&quot;, &quot;random_seed.h&quot;,
2908                                                      &quot;attributes.h&quot;, &quot;buffer.h&quot;, &quot;fifo.h&quot;, &quot;macros.h&quot;, &quot;rational.h&quot;,
2909                                                      &quot;audio_fifo.h&quot;, &quot;channel_layout.h&quot;, &quot;file.h&quot;, &quot;mathematics.h&quot;, &quot;samplefmt.h&quot;,
2910                                                      &quot;avassert.h&quot;, &quot;common.h&quot;, &quot;frame.h&quot;, &quot;md5.h&quot;, &quot;sha.h&quot;,
2911                                                      &quot;avconfig.h&quot;, &quot;imgutils.h&quot;, &quot;mem.h&quot;, &quot;time.h&quot;, &quot;avstring.h&quot;,
2912                                                      &quot;cpu_internal.h&quot;, &quot;intfloat.h&quot;, &quot;opt.h&quot;, &quot;version.h&quot;, &quot;avutil.h&quot;,
2913                                                      &quot;crc.h&quot;, &quot;intreadwrite.h&quot;, &quot;parseutils.h&quot;, &quot;xtea.h&quot;, &quot;base64.h&quot;,
2914                                                      &quot;dict.h&quot;, &quot;lfg.h&quot;, &quot;pixdesc.h&quot;, &quot;intfloat_readwrite.h&quot;, &quot;old_pix_fmts.h&quot;, &quot;audioconvert.h&quot;,
2915                                                      &quot;cpu.h&quot;, &quot;hwcontext.h&quot;)
2916                     FileCollection libavutil_x86 = files(&quot;cpu.h&quot;) // Use cpu.h from x86 instead of libavutil root if exist
2917                     FileCollection libswscale = files(&quot;swscale.h&quot;, &quot;version.h&quot;)
2918 
2919                     def copyLibAVFiles = {FileCollection files, String fDir, String tDir -&gt;
2920                         File dir = file(tDir)
2921                         dir.mkdirs()
2922 
2923                         files.each { File file -&gt;
2924                             copy {
2925                                 from fDir
2926                                 into tDir
2927                                 include file.name
2928                             }
2929                         }
2930                     }
2931 
2932                     copyLibAVFiles(config, fromDir, &quot;${toDir}/include&quot;)
2933                     copyLibAVFiles(libavcodec, &quot;${fromDir}/libavcodec&quot;, &quot;${toDir}/include/libavcodec&quot;)
2934                     copyLibAVFiles(libavdevice, &quot;${fromDir}/libavdevice&quot;, &quot;${toDir}/include/libavdevice&quot;)
2935                     copyLibAVFiles(libavfilter, &quot;${fromDir}/libavfilter&quot;, &quot;${toDir}/include/libavfilter&quot;)
2936                     copyLibAVFiles(libavformat, &quot;${fromDir}/libavformat&quot;, &quot;${toDir}/include/libavformat&quot;)
2937                     copyLibAVFiles(libavresample, &quot;${fromDir}/libavresample&quot;, &quot;${toDir}/include/libavresample&quot;)
2938                     copyLibAVFiles(libavutil, &quot;${fromDir}/libavutil&quot;, &quot;${toDir}/include/libavutil&quot;)
2939                     copyLibAVFiles(libavutil_x86, &quot;${fromDir}/libavutil/x86&quot;, &quot;${toDir}/include/libavutil&quot;)
2940                     copyLibAVFiles(libswscale, &quot;${fromDir}/libswscale&quot;, &quot;${toDir}/include/libswscale&quot;)
2941 
2942                     // Copy libs
2943                     FileTree libs = fileTree(dir: &quot;${fromDir}&quot;, include: &quot;**/*.so*&quot;)
2944                     libs.each {File file -&gt;
2945                         copy {
2946                             from file
2947                             into &quot;${toDir}/lib&quot;
2948                         }
2949                     }
2950                 }
2951 
2952                 def buildLibAVStubs = task(&quot;buildLibAVStubs&quot;, dependsOn: []) {
2953                     enabled = IS_BUILD_LIBAV_STUBS
2954 
2955                     doLast {
2956                         project.ext.libav = [:]
2957                         project.ext.libav.basedir = &quot;${buildDir}/native/linux/libav&quot;
2958                         project.ext.libav.versions = [ &quot;9.14&quot;, &quot;11.4&quot;, &quot;12.1&quot; ]
2959                         project.ext.libav.versionmap = [ &quot;9.14&quot; : &quot;54&quot;, &quot;11.4&quot; : &quot;56&quot;, &quot;12.1&quot; : &quot;57&quot; ]
2960 
2961                         libav.versions.each { version -&gt;
2962                             def libavDir = &quot;${libav.basedir}/libav-${version}&quot;
2963                             for (File f : configurations.media.files) {
2964                                 if (f.name.startsWith(&quot;libav-${version}&quot;)) {
2965                                     File dir = file(libavDir)
2966                                     dir.mkdirs()
2967                                     def libavTar = &quot;${libav.basedir}/libav-${version}.tar&quot;
2968                                     ant.gunzip(src: f, dest: libavTar)
2969                                     ant.untar(src: libavTar, dest: libav.basedir)
2970                                 }
2971                             }
2972                         }
2973 
2974                         libav.versions.each { version -&gt;
2975                             def libavDir = &quot;${libav.basedir}/libav-${version}&quot;
2976                             File dir = file(libavDir)
2977                             if (dir.exists()) {
2978                                 def configFile = &quot;${libav.basedir}/libav-${version}/config.h&quot;
2979                                 File cfgFile = file(configFile)
2980                                 if (!cfgFile.exists()) {
2981                                     // Add execute permissions to version.sh, otherwise build fails
2982                                     exec {
2983                                         workingDir(&quot;$libavDir&quot;)
2984                                         commandLine(&quot;chmod&quot;, &quot;+x&quot;, &quot;version.sh&quot;)
2985                                     }
2986                                     exec {
2987                                         workingDir(&quot;$libavDir&quot;)
2988                                         if (IS_BUILD_WORKING_LIBAV) {
2989                                             commandLine(cfgCMDArgs + commonCfgArgs + codecsCfgArgs)
2990                                         } else {
2991                                             commandLine(cfgCMDArgs + commonCfgArgs)
2992                                         }
2993                                     }
2994                                 }
2995                                 exec {
2996                                     workingDir(&quot;$libavDir&quot;)
2997                                     commandLine(&quot;make&quot;)
2998                                 }
2999                             }
3000                         }
3001 
3002                         libav.versions.each { version -&gt;
3003                             def fromDir = &quot;${libav.basedir}/libav-${version}&quot;
3004                             def majorVersion = libav.versionmap[version]
3005                             def toDir = &quot;${libav.basedir}/libav-${majorVersion}&quot;
3006                             copyLibAVStubs(fromDir, toDir)
3007                         }
3008                     }
3009                 }
3010 
3011                 def buildLibAVFFmpegStubs = task(&quot;buildLibAVFFmpegStubs&quot;, dependsOn: []) {
3012                     enabled = IS_BUILD_LIBAV_STUBS
3013 
3014                     def extraCfgArgs = [&quot;--build-suffix=-ffmpeg&quot;]
3015 
3016                     doLast {
3017                         project.ext.libav = [:]
3018                         project.ext.libav.basedir = &quot;${buildDir}/native/linux/libavffmpeg&quot;
3019                         project.ext.libav.versions = [ &quot;11.4&quot; ]
3020                         project.ext.libav.versionmap = [ &quot;11.4&quot; : &quot;56&quot; ]
3021 
3022                         libav.versions.each { version -&gt;
3023                             def libavDir = &quot;${libav.basedir}/libav-${version}&quot;
3024                             for (File f : configurations.media.files) {
3025                                 if (f.name.startsWith(&quot;libav-${version}&quot;)) {
3026                                     File dir = file(libavDir)
3027                                     dir.mkdirs()
3028                                     def libavTar = &quot;${libav.basedir}/libav-${version}.tar&quot;
3029                                     ant.gunzip(src: f, dest: libavTar)
3030                                     ant.untar(src: libavTar, dest: libav.basedir)
3031                                 }
3032                             }
3033                         }
3034 
3035                         libav.versions.each { version -&gt;
3036                             def libavDir = &quot;${libav.basedir}/libav-${version}&quot;
3037                             File dir = file(libavDir)
3038                             if (dir.exists()) {
3039                                 def configFile = &quot;${libav.basedir}/libav-${version}/config.h&quot;
3040                                 File cfgFile = file(configFile)
3041                                 if (!cfgFile.exists()) {
3042                                     // Patch *.v files, so we have *_FFMPEG_$MAJOR instead of *_$MAJOR, otherwise library will not be loaded
3043                                     FileTree vfiles = fileTree(dir: &quot;${libavDir}&quot;, include: &quot;**/*.v&quot;)
3044                                     vfiles.each {File file -&gt;
3045                                         String data = file.getText(&quot;UTF-8&quot;)
3046                                         data = data.replace(&quot;_\$MAJOR&quot;, &quot;_FFMPEG_\$MAJOR&quot;)
3047                                         file.write(data, &quot;UTF-8&quot;)
3048                                     }
3049                                     // Add execute permissions to version.sh, otherwise build fails
3050                                     exec {
3051                                         workingDir(&quot;$libavDir&quot;)
3052                                         commandLine(&quot;chmod&quot;, &quot;+x&quot;, &quot;version.sh&quot;)
3053                                     }
3054                                     exec {
3055                                         workingDir(&quot;$libavDir&quot;)
3056                                         if (IS_BUILD_WORKING_LIBAV) {
3057                                             commandLine(cfgCMDArgs + commonCfgArgs + codecsCfgArgs + extraCfgArgs)
3058                                         } else {
3059                                             commandLine(cfgCMDArgs + commonCfgArgs + extraCfgArgs)
3060                                         }
3061                                     }
3062                                 }
3063                                 exec {
3064                                     workingDir(&quot;$libavDir&quot;)
3065                                     commandLine(&quot;make&quot;)
3066                                 }
3067                             }
3068                         }
3069 
3070                         libav.versions.each { version -&gt;
3071                             def fromDir = &quot;${libav.basedir}/libav-${version}&quot;
3072                             def majorVersion = libav.versionmap[version]
3073                             def toDir = &quot;${libav.basedir}/libav-${majorVersion}&quot;
3074                             copyLibAVStubs(fromDir, toDir)
3075 
3076                             // Special case to copy *-ffmpeg.so to *.so
3077                             FileTree libs = fileTree(dir: &quot;${fromDir}&quot;, include: &quot;**/*-ffmpeg.so&quot;)
3078                             libs.each {File file -&gt;
3079                                 copy {
3080                                     from file
3081                                     into &quot;${toDir}/lib&quot;
3082                                     rename { String fileName -&gt;
3083                                         fileName.replace(&quot;-ffmpeg&quot;, &quot;&quot;)
3084                                     }
3085                                 }
3086                             }
3087                         }
3088                     }
3089                 }
3090 
3091                 def buildFFmpegStubs = task(&quot;buildFFmpegStubs&quot;, dependsOn: []) {
3092                     enabled = IS_BUILD_LIBAV_STUBS
3093 
3094                     doLast {
3095                         project.ext.libav = [:]
3096                         project.ext.libav.basedir = &quot;${buildDir}/native/linux/ffmpeg&quot;
3097                         project.ext.libav.versions = [ &quot;3.3.3&quot;, &quot;4.0.2&quot; ]
3098                         project.ext.libav.versionmap = [ &quot;3.3.3&quot; : &quot;57&quot;, &quot;4.0.2&quot; : &quot;58&quot; ]
3099 
3100                         libav.versions.each { version -&gt;
3101                             def libavDir = &quot;${libav.basedir}/ffmpeg-${version}&quot;
3102                             for (File f : configurations.media.files) {
3103                                 if (f.name.startsWith(&quot;ffmpeg-${version}&quot;)) {
3104                                     File dir = file(libavDir)
3105                                     dir.mkdirs()
3106                                     def libavTar = &quot;${libav.basedir}/ffmpeg-${version}.tar&quot;
3107                                     ant.gunzip(src: f, dest: libavTar)
3108                                     ant.untar(src: libavTar, dest: libav.basedir)
3109                                 }
3110                             }
3111                         }
3112 
3113                         libav.versions.each { version -&gt;
3114                             def libavDir = &quot;${libav.basedir}/ffmpeg-${version}&quot;
3115                             File dir = file(libavDir)
3116                             if (dir.exists()) {
3117                                 def configFile = &quot;${libavDir}/config.h&quot;
3118                                 File cfgFile = file(configFile)
3119                                 if (!cfgFile.exists()) {
3120                                     // Add execute permissions to version.sh, otherwise build fails
3121                                     def versionFile = &quot;${libavDir}/version.sh&quot;
3122                                     File verFile = file(versionFile)
3123                                     if (verFile.exists()) {
3124                                         exec {
3125                                             workingDir(&quot;$libavDir&quot;)
3126                                             commandLine(&quot;chmod&quot;, &quot;+x&quot;, &quot;version.sh&quot;)
3127                                         }
3128                                     } else {
3129                                         versionFile = &quot;${libavDir}/ffbuild/version.sh&quot;
3130                                         verFile = file(versionFile)
3131                                         if (verFile.exists()) {
3132                                             exec {
3133                                                 workingDir(&quot;${libavDir}/ffbuild&quot;)
3134                                                 commandLine(&quot;chmod&quot;)
3135                                                 args += &quot;+x&quot;
3136                                                 args += [&quot;version.sh&quot;, &quot;libversion.sh&quot;, &quot;pkgconfig_generate.sh&quot;]
3137                                             }
3138                                         }
3139                                     }
3140                                     exec {
3141                                         workingDir(&quot;$libavDir&quot;)
3142                                         if (IS_BUILD_WORKING_LIBAV) {
3143                                             commandLine(cfgCMDArgs + commonCfgArgs + codecsCfgArgs)
3144                                         } else {
3145                                             commandLine(cfgCMDArgs + commonCfgArgs)
3146                                         }
3147                                     }
3148                                 }
3149                                 exec {
3150                                     workingDir(&quot;$libavDir&quot;)
3151                                     commandLine(&quot;make&quot;)
3152                                 }
3153                             }
3154                         }
3155 
3156                         libav.versions.each { version -&gt;
3157                             def fromDir = &quot;${libav.basedir}/ffmpeg-${version}&quot;
3158                             def majorVersion = libav.versionmap[version]
3159                             def toDir = &quot;${libav.basedir}/ffmpeg-${majorVersion}&quot;
3160                             copyLibAVStubs(fromDir, toDir)
3161                         }
3162                     }
3163                 }
3164 
3165                 def buildAVPlugin = task( &quot;buildAVPlugin&quot;, dependsOn: [buildPlugins, buildLibAVStubs, buildLibAVFFmpegStubs, buildFFmpegStubs]) {
3166                     enabled = IS_COMPILE_MEDIA
3167 
3168                     doLast {
3169                         if (IS_BUILD_LIBAV_STUBS) {
3170                             project.ext.libav = [:]
3171                             project.ext.libav.basedir = &quot;${buildDir}/native/linux/libav/libav&quot;
3172                             project.ext.libav.versions = [ &quot;53&quot;, &quot;54&quot;, &quot;55&quot;, &quot;56&quot;, &quot;57&quot; ]
3173                             project.ext.libav.libavffmpeg = [:]
3174                             project.ext.libav.libavffmpeg.basedir = &quot;${buildDir}/native/linux/libavffmpeg/libav&quot;
3175                             project.ext.libav.libavffmpeg.versions = [ &quot;56&quot; ]
3176                             project.ext.libav.ffmpeg = [:]
3177                             project.ext.libav.ffmpeg.basedir = &quot;${buildDir}/native/linux/ffmpeg/ffmpeg&quot;
3178                             project.ext.libav.ffmpeg.versions = [ &quot;57&quot;, &quot;58&quot; ]
3179 
3180                             project.ext.libav.versions.each { version -&gt;
3181                                 def libavDir = &quot;${project.ext.libav.basedir}-${version}&quot;
3182                                 File dir = file(libavDir)
3183                                 if (dir.exists()) {
3184                                     exec {
3185                                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/linux/avplugin&quot;)
3186                                         args(&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;,
3187                                              &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;,
3188                                              &quot;BASE_NAME=avplugin&quot;, &quot;VERSION=${version}&quot;, &quot;LIBAV_DIR=${libavDir}&quot;,
3189                                              &quot;SUFFIX=&quot;, IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;)
3190                                     }
3191                                 }
3192                             }
3193 
3194                             project.ext.libav.libavffmpeg.versions.each { version -&gt;
3195                                 def libavDir = &quot;${project.ext.libav.libavffmpeg.basedir}-${version}&quot;
3196                                 File dir = file(libavDir)
3197                                 if (dir.exists()) {
3198                                     exec {
3199                                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/linux/avplugin&quot;)
3200                                         args(&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;,
3201                                              &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;,
3202                                              &quot;BASE_NAME=avplugin&quot;, &quot;VERSION=${version}&quot;, &quot;LIBAV_DIR=${libavDir}&quot;,
3203                                              &quot;SUFFIX=-ffmpeg&quot;, IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;)
3204                                     }
3205                                 }
3206                             }
3207 
3208                             project.ext.libav.ffmpeg.versions.each { version -&gt;
3209                                 def libavDir = &quot;${project.ext.libav.ffmpeg.basedir}-${version}&quot;
3210                                 File dir = file(libavDir)
3211                                 if (dir.exists()) {
3212                                     exec {
3213                                         commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/linux/avplugin&quot;)
3214                                         args(&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;,
3215                                              &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;,
3216                                              &quot;BASE_NAME=avplugin&quot;, &quot;VERSION=${version}&quot;, &quot;LIBAV_DIR=${libavDir}&quot;,
3217                                              &quot;SUFFIX=-ffmpeg&quot;, IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;)
3218                                     }
3219                                 }
3220                             }
3221                         } else {
3222                             // Building fxavcodec plugin (libav plugin)
3223                             exec {
3224                                 commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/linux/avplugin&quot;)
3225                                 args(&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;,
3226                                      &quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;,
3227                                      &quot;BASE_NAME=avplugin&quot;, IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;)
3228                             }
3229                         }
3230                     }
3231                 }
3232                 buildNative.dependsOn buildAVPlugin
3233             }
3234 
3235             if (t.name == &quot;win&quot;) {
3236                 def buildResources = task(&quot;buildResources&quot;) {
3237                     doLast {
3238                         def rcOutputDir = &quot;${nativeOutputDir}/${buildType}&quot;
3239                         mkdir rcOutputDir
3240                         exec {
3241                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3242                             commandLine (WIN.media.rcCompiler)
3243                             args(WIN.media.glibRcFlags)
3244                             args(&quot;/Fo${rcOutputDir}/${WIN.media.glibRcFile}&quot;, WIN.media.rcSource)
3245                         }
3246 
3247                         exec {
3248                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3249                             commandLine (WIN.media.rcCompiler)
3250                             args(WIN.media.gstreamerRcFlags)
3251                             args(&quot;/Fo${rcOutputDir}/${WIN.media.gstreamerRcFile}&quot;, WIN.media.rcSource)
3252                         }
3253 
3254                         exec {
3255                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3256                             commandLine (WIN.media.rcCompiler)
3257                             args(WIN.media.fxpluginsRcFlags)
3258                             args(&quot;/Fo${rcOutputDir}/${WIN.media.fxpluginsRcFile}&quot;, WIN.media.rcSource)
3259                         }
3260 
3261                         exec {
3262                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3263                             commandLine (WIN.media.rcCompiler)
3264                             args(WIN.media.jfxmediaRcFlags)
3265                             args(&quot;/Fo${rcOutputDir}/${WIN.media.jfxmediaRcFile}&quot;, WIN.media.rcSource)
3266                         }
3267                     }
3268                 }
3269 
3270                 def buildGlib = task(&quot;build${t.capital}Glib&quot;, dependsOn: [buildResources]) {
3271                     enabled = IS_COMPILE_MEDIA
3272                     doLast {
3273                         exec {
3274                             environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3275                             commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/glib-lite&quot;)
3276                             args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=glib-lite&quot;,
3277                                  IS_64 ? &quot;ARCH=x64&quot; : &quot;ARCH=x32&quot;, &quot;RESOURCE=${nativeOutputDir}/${buildType}/${WIN.media.glibRcFile}&quot;,
3278                                  &quot;CC=${mediaProperties.compiler}&quot;, &quot;AR=${mediaProperties.ar}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
3279                         }
3280                     }
3281                 }
3282                 buildGStreamer.dependsOn buildGlib
3283 
3284             } else if (t.name == &quot;mac&quot;) {
3285                 def buildGlib = task(&quot;build${t.capital}Glib&quot;) {
3286                     enabled = IS_COMPILE_MEDIA
3287                     doLast {
3288                         exec {
3289                             commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/libffi&quot;)
3290                             args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=ffi&quot;)
3291                             args (&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;, &quot;AR=${mediaProperties.ar}&quot;)
3292                         }
3293 
3294                         exec {
3295                             commandLine (&quot;make&quot;, &quot;${makeJobsFlag}&quot;, &quot;-C&quot;, &quot;${nativeSrcDir}/gstreamer/projects/${projectDir}/glib-lite&quot;)
3296                             args(&quot;OUTPUT_DIR=${nativeOutputDir}&quot;, &quot;BUILD_TYPE=${buildType}&quot;, &quot;BASE_NAME=glib-lite&quot;)
3297                             args (&quot;CC=${mediaProperties.compiler}&quot;, &quot;LINKER=${mediaProperties.linker}&quot;)
3298                         }
3299                     }
3300                 }
3301                 buildGStreamer.dependsOn buildGlib
3302             }
3303         }
3304 
3305         buildNativeTargets.dependsOn buildNative
3306     }
3307 
3308     jar {
3309         exclude(&quot;headergen/**&quot;)
3310 
3311         dependsOn compileJava
3312         if (IS_COMPILE_MEDIA) {
3313             dependsOn buildNativeTargets
3314         }
3315     }
3316 
3317     addMavenPublication(project, [ &#39;graphics&#39; ])
3318 
3319     addValidateSourceSets(project, sourceSets)
3320 }
3321 
3322 project(&quot;:web&quot;) {
3323     configurations {
3324         webkit
3325     }
3326     project.ext.buildModule = true
3327     project.ext.includeSources = true
3328     project.ext.moduleRuntime = true
3329     project.ext.moduleName = &quot;javafx.web&quot;
3330 
3331     sourceSets {
3332         main
3333         shims {
3334             java {
3335                 compileClasspath += sourceSets.main.output
3336                 runtimeClasspath += sourceSets.main.output
3337             }
3338         }
3339         test {
3340             java {
3341                 compileClasspath += sourceSets.shims.output
3342                 runtimeClasspath += sourceSets.shims.output
3343             }
3344         }
3345     }
3346 
3347     project.ext.moduleSourcePath = defaultModuleSourcePath
3348     project.ext.moduleSourcePathShim = defaultModuleSourcePathShim
3349 
3350     commonModuleSetup(project, [ &#39;base&#39;, &#39;graphics&#39;, &#39;controls&#39;, &#39;media&#39;, &#39;web&#39; ])
3351 
3352     dependencies {
3353         compile project(&quot;:base&quot;)
3354         compile project(&quot;:graphics&quot;)
3355         compile project(&quot;:controls&quot;)
3356         compile project(&quot;:media&quot;)
3357     }
3358 
3359     compileJava.dependsOn updateCacheIfNeeded
3360 
3361     task webArchiveJar(type: Jar) {
3362         from (project.file(&quot;$projectDir/src/test/resources/test/html&quot;)) {
3363             include &quot;**/archive-*.*&quot;
3364         }
3365         archiveName = &quot;webArchiveJar.jar&quot;
3366         destinationDir = file(&quot;$buildDir/testing/resources&quot;)
3367     }
3368 
3369     def gensrcDir = &quot;${buildDir}/gensrc/java&quot;
3370 
3371     // add in the wrappers to the compile
3372     sourceSets.main.java.srcDirs += &quot;${gensrcDir}&quot;
3373 
3374     if (IS_COMPILE_WEBKIT) {
3375         compileJava {
3376             // generate the native headers during compile
3377             // only needed if we are doing the native compile
3378             options.compilerArgs.addAll([
3379                 &#39;-h&#39;, &quot;${project.buildDir}/gensrc/headers&quot;
3380                 ])
3381         }
3382     }
3383 
3384     // Copy these to a common location in the moduleSourcePath
3385     def copyWrappers = project.task(&quot;copyPreGeneratedWrappers&quot;, type: Copy) {
3386         from &quot;src/main/native/Source/WebCore/bindings/java/dom3/java&quot;
3387         into &quot;${gensrcDir}&quot;
3388     }
3389 
3390     compileJava.dependsOn(copyWrappers);
3391 
3392     test {
3393         doFirst {
3394             if (IS_STUB_RUNTIME_OPENJFX) {
3395                 println &quot;********************************************************&quot;
3396                 println &quot;WARNING: running web tests with officially built webkit.&quot;
3397                 println &quot;The webkit native library may not be compatible with the&quot;
3398                 println &quot;source tree you are using.&quot;
3399                 println &quot;If tests fail, try compiling webkit instead.&quot;
3400                 println &quot;See WEBKIT-MEDIA-STUBS.md&quot;
3401                 println &quot;********************************************************&quot;
3402             } else if (!IS_COMPILE_WEBKIT) {
3403                 println &quot;******************************************************&quot;
3404                 println &quot;WARNING: running web tests without building webkit.&quot;
3405                 println &quot;The webkit native library will be copied from the JDK,&quot;
3406                 println &quot;which might lead to failures in some web tests.&quot;
3407                 println &quot;See WEBKIT-MEDIA-STUBS.md&quot;
3408                 println &quot;******************************************************&quot;
3409             }
3410         }
3411         // Run web tests in headless mode
3412         systemProperty &#39;glass.platform&#39;, &#39;Monocle&#39;
3413         systemProperty &#39;monocle.platform&#39;, &#39;Headless&#39;
3414         systemProperty &#39;prism.order&#39;, &#39;sw&#39;
3415         dependsOn webArchiveJar
3416         def testResourceDir = file(&quot;$buildDir/testing/resources&quot;)
3417         jvmArgs &quot;-DWEB_ARCHIVE_JAR_TEST_DIR=$testResourceDir&quot;
3418     }
3419 
3420     task compileJavaDOMBinding()
3421 
3422     compileTargets { t -&gt;
3423         def targetProperties = project.rootProject.ext[t.upper]
3424         def webkitProperties = targetProperties.webkit
3425         def classifier = (t.name != &quot;linux&quot; &amp;&amp; t.name != &quot;win&quot;) ? t.name :
3426                           IS_64 ? &quot;${t.name}-amd64&quot; : &quot;${t.name}-i586&quot;
3427 
3428         def webkitOutputDir = cygpath(&quot;$buildDir/${t.name}&quot;)
3429         def webkitConfig = IS_DEBUG_NATIVE ? &quot;Debug&quot; : &quot;Release&quot;
3430 
3431         File nativeBuildDir = new File(&quot;${webkitOutputDir}&quot;)
3432         nativeBuildDir.mkdirs()
3433 
3434         def compileNativeTask = task(&quot;compileNative${t.capital}&quot;, dependsOn: [compileJava]) {
3435             println &quot;Building Webkit configuration /$webkitConfig/ into $webkitOutputDir&quot;
3436             enabled =  (IS_COMPILE_WEBKIT)
3437 
3438             doLast {
3439                 exec {
3440                     workingDir(&quot;$webkitOutputDir&quot;)
3441                     commandLine(&quot;perl&quot;, &quot;$projectDir/src/main/native/Tools/Scripts/set-webkit-configuration&quot;, &quot;--$webkitConfig&quot;)
3442                     environment([&quot;WEBKIT_OUTPUTDIR&quot; : webkitOutputDir])
3443                 }
3444 
3445                 exec {
3446                     workingDir(&quot;$webkitOutputDir&quot;)
3447                     def cmakeArgs = &quot;-DENABLE_TOOLS=1&quot;
3448                     if (IS_STATIC_BUILD) {
3449                         cmakeArgs = &quot; $cmakeArgs -DSTATIC_BUILD=1 -DUSE_THIN_ARCHIVES=OFF&quot;;
3450                     }
3451                     cmakeArgs = &quot; $cmakeArgs -DCMAKE_C_COMPILER=&#39;${webkitProperties.compiler}&#39;&quot;
3452                     if (t.name == &quot;win&quot;) {
3453                         // To enable ninja build on Windows
3454                         environment(WINDOWS_NATIVE_COMPILE_ENVIRONMENT)
3455                     } else if (t.name == &quot;mac&quot;) {
3456                         cmakeArgs = &quot; $cmakeArgs -DCMAKE_OSX_DEPLOYMENT_TARGET=$MACOSX_MIN_VERSION -DCMAKE_OSX_SYSROOT=$MACOSX_SDK_PATH&quot;
3457                     } else if (t.name == &quot;linux&quot;) {
3458                         cmakeArgs = &quot; $cmakeArgs -DCMAKE_SYSTEM_NAME=Linux&quot;
3459                         if (IS_64) {
3460                             cmakeArgs = &quot;$cmakeArgs -DCMAKE_SYSTEM_PROCESSOR=x86_64&quot;
3461                         } else {
3462                             cmakeArgs = &quot;$cmakeArgs -DCMAKE_SYSTEM_PROCESSOR=i586&quot;
3463                         }
3464                         // TODO: Use cflags and ldflags from all platforms
3465                         def cFlags = webkitProperties.ccFlags?.join(&#39; &#39;) ?: &#39;&#39;
3466                         def lFlags = webkitProperties.linkFlags?.join(&#39; &#39;) ?: &#39;&#39;
3467                         if (IS_STATIC_BUILD) {
3468                             cFlags = &quot; $cFlags -DSTATIC_BUILD=1&quot;;
3469                         }
3470                         // -shared flag should be omitted while creating executable.
3471                         def exeFlags = webkitProperties.linkFlags?.join(&#39; &#39;)?.replace(&#39;-shared&#39;, &#39;&#39;) ?: &#39;&#39;
3472                         cmakeArgs = &quot;$cmakeArgs -DCMAKE_C_FLAGS=&#39;${cFlags}&#39; -DCMAKE_CXX_FLAGS=&#39;${cFlags}&#39;&quot;
3473                         cmakeArgs = &quot;$cmakeArgs -DCMAKE_SHARED_LINKER_FLAGS=&#39;${lFlags}&#39; -DCMAKE_EXE_LINKER_FLAGS=&#39;${exeFlags}&#39;&quot;
3474                     } else if (t.name.startsWith(&quot;arm&quot;)) {
3475                         fail(&quot;ARM target is not supported as of now.&quot;)
3476                     }
3477 
3478                     if (IS_COMPILE_PARFAIT) {
3479                         environment([
3480                             &quot;COMPILE_PARFAIT&quot; : &quot;true&quot;
3481                         ])
3482                         environment &quot;PATH&quot;, System.env.PARFAIT_PATH + File.pathSeparator + environment.PATH
3483                         cmakeArgs = &quot;-DCMAKE_C_COMPILER=parfait-gcc -DCMAKE_CXX_COMPILER=parfait-g++&quot;
3484                     }
3485 
3486                     if (project.hasProperty(&#39;toolsPath&#39;)) {
3487                         environment &quot;PATH&quot;, toolsPath + File.pathSeparator + environment.PATH
3488                     }
3489 
3490                     environment([
3491                         &quot;JAVA_HOME&quot;       : JDK_HOME,
3492                         &quot;WEBKIT_OUTPUTDIR&quot; : webkitOutputDir,
3493                         &quot;PYTHONDONTWRITEBYTECODE&quot; : &quot;1&quot;,
3494                     ])
3495 
3496                     def targetCpuBitDepthSwitch = &quot;&quot;
3497                     if (IS_64) {
3498                         targetCpuBitDepthSwitch = &quot;--64-bit&quot;
3499                     } else {
3500                         targetCpuBitDepthSwitch = &quot;--32-bit&quot;
3501                     }
3502                     cmakeArgs += &quot; -DJAVAFX_RELEASE_VERSION=${jfxReleaseMajorVersion}&quot;
3503                     commandLine(&quot;perl&quot;, &quot;$projectDir/src/main/native/Tools/Scripts/build-webkit&quot;,
3504                         &quot;--java&quot;, &quot;--icu-unicode&quot;, targetCpuBitDepthSwitch,
3505                         &quot;--no-experimental-features&quot;, &quot;--cmakeargs=${cmakeArgs}&quot;)
3506                 }
3507             }
3508         }
3509 
3510         // Cmake places Windows DLL in bin directory
3511         def dllDir = IS_WINDOWS ? &quot;bin&quot; : &quot;lib&quot;
3512         def copyDumpTreeNativeTask = task(&quot;copyDumpTreeNative${t.capital}&quot;, type: Copy,
3513                 dependsOn: [ compileNativeTask]) {
3514             def library = rootProject.ext[t.upper].library
3515             from &quot;$webkitOutputDir/$webkitConfig/$dllDir/${library(&#39;DumpRenderTreeJava&#39;)}&quot;
3516             into &quot;$buildDir/test/${t.name}&quot;
3517         }
3518 
3519         def copyNativeTask = task(&quot;copyNative${t.capital}&quot;, type: Copy,
3520                 dependsOn: [compileNativeTask, copyDumpTreeNativeTask]) {
3521             enabled =  (IS_COMPILE_WEBKIT)
3522             def library = rootProject.ext[t.upper].library
3523             from &quot;$webkitOutputDir/$webkitConfig/$dllDir/${library(&#39;jfxwebkit&#39;)}&quot;
3524             into &quot;$buildDir/libs/${t.name}&quot;
3525         }
3526 
3527         if (IS_WINDOWS &amp;&amp; t.name == &quot;win&quot;) {
3528             def rcTask = project.task(&quot;rc${t.capital}&quot;, type: CompileResourceTask) {
3529                 compiler = webkitProperties.rcCompiler
3530                 source(webkitProperties.rcSource)
3531                 if (webkitProperties.rcFlags) {
3532                     rcParams.addAll(webkitProperties.rcFlags)
3533                 }
3534                 output(file(&quot;$webkitOutputDir/$webkitConfig/WebCore/obj&quot;))
3535             }
3536             compileNativeTask.dependsOn rcTask
3537         }
3538 
3539         def compileJavaDOMBindingTask = task(&quot;compileJavaDOMBinding${t.capital}&quot;, type: JavaCompile,
3540                 dependsOn: [compileJava, compileNativeTask, copyNativeTask]) {
3541             destinationDir = file(&quot;$buildDir/classes/java/main&quot;)
3542             classpath = configurations.compile
3543             source = project.sourceSets.main.java.srcDirs
3544             options.compilerArgs.addAll([
3545                 &#39;-implicit:none&#39;,
3546                 &#39;--module-source-path&#39;, defaultModuleSourcePath
3547                 ])
3548         }
3549 
3550         compileJavaDOMBinding.dependsOn compileJavaDOMBindingTask
3551 
3552         if (!targetProperties.compileWebnodeNative) {
3553             println(&quot;Not compiling native Webkit for ${t.name} per configuration request&quot;);
3554             compileNativeTask.enabled = false
3555         }
3556     }
3557 
3558     def drtClasses = &quot;**/com/sun/javafx/webkit/drt/**&quot;
3559     task drtJar(type: Jar, dependsOn: compileJava) {
3560         archiveName = &quot;drt.jar&quot;
3561         destinationDir = file(&quot;$buildDir/test&quot;)
3562         from &quot;$buildDir/classes/java/main/javafx.web/&quot;
3563         include drtClasses
3564         includeEmptyDirs = false
3565     }
3566 
3567     if (IS_COMPILE_WEBKIT) {
3568         assemble.dependsOn compileJavaDOMBinding, drtJar
3569     }
3570 
3571     addMavenPublication(project, [ &#39;controls&#39;, &#39;media&#39; ])
3572 
3573     addValidateSourceSets(project, sourceSets)
3574 }
3575 
3576 // This project is for system tests that need to run with a full SDK.
3577 // Most of them display a stage or do other things that preclude running
3578 // them in a shared JVM or as part of the &quot;smoke test&quot; run (which must
3579 // not pop up any windows or use audio). As such, they are only enabled
3580 // when FULL_TEST is specified, and each test runs in its own JVM
3581 project(&quot;:systemTests&quot;) {
3582 
3583     sourceSets {
3584         test
3585 
3586         // Source sets for standalone test apps (used for launcher tests)
3587         testapp1
3588 
3589         // Modular applications
3590         testapp2
3591         testapp3
3592         testapp4
3593         testapp5
3594         testapp6
3595         testscriptapp1
3596         testscriptapp2
3597     }
3598 
3599     def nonModSrcSets = [
3600         sourceSets.test,
3601         sourceSets.testapp1
3602     ]
3603 
3604     def modSrcSets = [
3605         sourceSets.testapp2,
3606         sourceSets.testapp3,
3607         sourceSets.testapp4,
3608         sourceSets.testapp5,
3609         sourceSets.testapp6,
3610         sourceSets.testscriptapp1,
3611         sourceSets.testscriptapp2
3612     ]
3613 
3614     project.ext.buildModule = false
3615     project.ext.moduleRuntime = false
3616     project.ext.moduleName = &quot;systemTests&quot;
3617 
3618     dependencies {
3619         testCompile project(&quot;:graphics&quot;).sourceSets.test.output
3620         testCompile project(&quot;:base&quot;).sourceSets.test.output
3621         testCompile project(&quot;:controls&quot;).sourceSets.test.output
3622         testCompile project(&quot;:swing&quot;).sourceSets.test.output
3623     }
3624 
3625     def dependentProjects = [ &#39;base&#39;, &#39;graphics&#39;, &#39;controls&#39;, &#39;media&#39;, &#39;web&#39;, &#39;swing&#39;, &#39;fxml&#39; ]
3626     commonModuleSetup(project, dependentProjects)
3627 
3628     File testJavaPolicyFile = new File(rootProject.buildDir, TESTJAVAPOLICYFILE);
3629     File testRunArgsFile = new File(rootProject.buildDir,TESTRUNARGSFILE);
3630 
3631     File stRunArgsFile = new File(project.buildDir,&quot;st.run.args&quot;);
3632 
3633     def sts = task(&quot;systemTestSetup&quot;) {
3634         outputs.file(stRunArgsFile)
3635 
3636         doLast() {
3637             stRunArgsFile.delete()
3638 
3639             logger.info(&quot;Creating patchmodule.args file ${stRunArgsFile}&quot;)
3640 
3641             // Create an argfile with the information needed to launch
3642             // the stand alone system unit tests.
3643 
3644             //First add in all of the patch-module args we use for the
3645             //normal unit tests, copied from test.run.args
3646             testRunArgsFile.eachLine { str -&gt;
3647                 stRunArgsFile &lt;&lt;  &quot;${str}\n&quot;
3648             }
3649 
3650             // Now add in the working classpath elements (junit, test classes...)
3651             stRunArgsFile &lt;&lt;  &quot;-cp \&quot;\\\n&quot;
3652             test.classpath.each() { elem -&gt;
3653                 def e = cygpath(&quot;${elem}&quot;)
3654                 stRunArgsFile &lt;&lt;  &quot;  ${e}${File.pathSeparator}\\\n&quot;
3655             }
3656             stRunArgsFile &lt;&lt;  &quot;\&quot;\n&quot;
3657         }
3658     }
3659 
3660     test.dependsOn(sts)
3661     test.dependsOn(createTestArgfiles);
3662 
3663     // Tasks to create standalone test applications for the launcher tests
3664 
3665     if (project.hasProperty(&#39;testModulePathArgs&#39;)) {
3666         compileTestapp1Java.options.compilerArgs.addAll(testModulePathArgs)
3667     }
3668     dependentProjects.each { e -&gt;
3669         compileTestapp1Java.dependsOn(rootProject.project(e).testClasses)
3670     }
3671 
3672     def testapp1JarName = &quot;testapp1.jar&quot;
3673     task createTestapp1Jar1(type: Jar) {
3674         dependsOn compileTestapp1Java
3675         enabled = IS_FULL_TEST
3676 
3677         destinationDir = file(&quot;$buildDir/testapp1&quot;)
3678         archiveName = testapp1JarName
3679         includeEmptyDirs = false
3680         from project.sourceSets.testapp1.java.outputDir
3681         include(&quot;testapp/**&quot;)
3682         include(&quot;com/javafx/main/**&quot;)
3683 
3684         manifest {
3685             attributes(
3686                 &quot;Main-Class&quot; : &quot;com.javafx.main.Main&quot;,
3687                 &quot;JavaFX-Version&quot; : &quot;2.2&quot;,
3688                 &quot;JavaFX-Application-Class&quot; : &quot;testapp.HelloWorld&quot;,
3689                 &quot;JavaFX-Class-Path&quot; : &quot;jar2.jar&quot;
3690             )
3691         }
3692     }
3693 
3694     task createTestapp1Jar2(type: Jar) {
3695         dependsOn compileTestapp1Java
3696         enabled = IS_FULL_TEST
3697 
3698         destinationDir = file(&quot;$buildDir/testapp1&quot;)
3699         archiveName = &quot;jar2.jar&quot;;
3700         includeEmptyDirs = false
3701         from project.sourceSets.testapp1.java.outputDir
3702         include(&quot;pkg2/**&quot;)
3703     }
3704 
3705     task createTestApps() {
3706         dependsOn(createTestapp1Jar1)
3707         dependsOn(createTestapp1Jar2)
3708     }
3709     test.dependsOn(createTestApps);
3710 
3711     def modtestapps = [ &quot;testapp2&quot;, &quot;testapp3&quot;, &quot;testapp4&quot;, &quot;testapp5&quot;, &quot;testapp6&quot;, &quot;testscriptapp1&quot;, &quot;testscriptapp2&quot; ]
3712     modtestapps.each { testapp -&gt;
3713         def testappCapital = testapp.capitalize()
3714         def copyTestAppTask = task(&quot;copy${testappCapital}&quot;, type: Copy) {
3715             from project.sourceSets.&quot;${testapp}&quot;.java.outputDir
3716             from project.sourceSets.&quot;${testapp}&quot;.output.resourcesDir
3717             into &quot;${project.buildDir}/modules/${testapp}&quot;
3718         }
3719 
3720         def List&lt;String&gt; testAppSourceDirs = []
3721         project.sourceSets.&quot;${testapp}&quot;.java.srcDirs.each { dir -&gt;
3722             testAppSourceDirs += dir
3723         }
3724         def testappCompileTasks = project.getTasksByName(&quot;compile${testappCapital}Java&quot;, true);
3725         def testappResourceTasks = project.getTasksByName(&quot;process${testappCapital}Resources&quot;, true);
3726         testappCompileTasks.each { appCompileTask -&gt;
3727             appCompileTask.options.compilerArgs.addAll([
3728                 &#39;-implicit:none&#39;,
3729                 &#39;--module-source-path&#39;, testAppSourceDirs.join(File.pathSeparator),
3730                 ] )
3731             if (project.hasProperty(&#39;testModulePathArgs&#39;)) {
3732                 appCompileTask.options.compilerArgs.addAll(testModulePathArgs)
3733             }
3734 
3735             dependentProjects.each { e -&gt;
3736                 appCompileTask.dependsOn(rootProject.project(e).testClasses)
3737             }
3738 
3739             copyTestAppTask.dependsOn(appCompileTask)
3740         }
3741         testappResourceTasks.each { appResourceTask -&gt;
3742             copyTestAppTask.dependsOn(appResourceTask)
3743         }
3744 
3745         createTestApps.dependsOn(copyTestAppTask)
3746     }
3747 
3748     test {
3749         enabled = IS_FULL_TEST
3750 
3751         // Parse testPatchModuleArgs looking for &quot;--module-path&quot;.
3752         // Save path if found so we can pass it to the module launcher tests
3753         def pendingModulePath = false
3754         testPatchModuleArgs.each { str -&gt;
3755             if (pendingModulePath) {
3756                 project.ext.launcherModulePath = str;
3757                 pendingModulePath = false
3758             } else if (str == &quot;--module-path&quot;) {
3759                 pendingModulePath = true
3760             }
3761         }
3762 
3763         // Properties passed to launcher tests
3764         systemProperty &quot;launchertest.testapp1.jar&quot;, &quot;build/testapp1/$testapp1JarName&quot;
3765         modtestapps.each { testapp -&gt;
3766             systemProperty &quot;launchertest.${testapp}.module.path&quot;,
3767                     &quot;${project.buildDir}/modules/${testapp}&quot;
3768         }
3769 
3770         // Properties passed to test.util.Util
3771         systemProperties &#39;worker.debug&#39;: IS_WORKER_DEBUG
3772         systemProperties &#39;worker.patchmodule.file&#39;: cygpath(stRunArgsFile.path)
3773         if (project.hasProperty(&quot;launcherModulePath&quot;)) {
3774             systemProperties &#39;worker.module.path&#39;: launcherModulePath
3775         }
3776         systemProperties &#39;worker.patch.policy&#39;: cygpath(testJavaPolicyFile.path)
3777         systemProperties &#39;worker.java.cmd&#39;: JAVA
3778 
3779         if (rootProject.hasProperty(&quot;ClipShapeTest.numTests&quot;)) {
3780             systemProperty &quot;ClipShapeTest.numTests&quot;, rootProject.getProperty(&quot;ClipShapeTest.numTests&quot;)
3781         }
3782 
3783         if (!IS_USE_ROBOT) {
3784             // Disable all robot-based visual tests
3785             exclude(&quot;test/robot/**&quot;);
3786         }
3787         if (!IS_UNSTABLE_TEST) {
3788             // JDK-8196607 Don&#39;t run monocle test cases 
3789             exclude(&quot;test/robot/com/sun/glass/ui/monocle/**&quot;);
3790         }
3791         if (!IS_AWT_TEST) {
3792             // Disable all AWT-based tests
3793             exclude(&quot;**/javafx/embed/swing/*.*&quot;);
3794             exclude(&quot;**/com/sun/javafx/application/Swing*.*&quot;);
3795         }
3796 
3797         forkEvery = 1
3798     }
3799 
3800     addValidateSourceSets(project, nonModSrcSets, modSrcSets)
3801 }
3802 
3803 allprojects {
3804     // The following block is a workaround for the fact that presently Gradle
3805     // can&#39;t set the -XDignore.symbol.file flag, because it appears that the
3806     // javac API is lacking support for it. So what we&#39;ll do is find any Compile
3807     // task and manually provide the options necessary to fire up the
3808     // compiler with the right settings.
3809     tasks.withType(JavaCompile) { compile -&gt;
3810         if (compile.options.hasProperty(&quot;useAnt&quot;)) {
3811             compile.options.useAnt = true
3812             compile.options.useDepend = IS_USE_DEPEND
3813         } else if (compile.options.hasProperty(&quot;incremental&quot;)) {
3814             compile.options.incremental = IS_INCREMENTAL
3815         }
3816         compile.options.debug = true // we always generate debugging info in the class files
3817         compile.options.debugOptions.debugLevel = IS_DEBUG_JAVA ? &quot;source,lines,vars&quot; : &quot;source,lines&quot;
3818         compile.options.fork = true
3819 
3820         compile.options.forkOptions.executable = JAVAC
3821 
3822         compile.options.warnings = IS_LINT
3823 
3824         compile.options.compilerArgs += [&quot;-XDignore.symbol.file&quot;, &quot;-encoding&quot;, &quot;UTF-8&quot;]
3825 
3826         // we use a custom javadoc command
3827         project.javadoc.enabled = false
3828 
3829         // Add in the -Xlint options
3830         if (IS_LINT) {
3831             LINT.split(&quot;[, ]&quot;).each { s -&gt;
3832                 compile.options.compilerArgs += &quot;-Xlint:$s&quot;
3833             }
3834         }
3835     } // tasks with javaCompile
3836 
3837     // If I am a module....
3838     if (project.hasProperty(&#39;moduleSourcePath&#39;) &amp;&amp;
3839             (project.hasProperty(&#39;buildModule&#39;) &amp;&amp; project.buildModule)) {
3840         project.compileJava {
3841             options.compilerArgs.addAll([
3842                 &#39;-implicit:none&#39;,
3843                 &#39;--module-source-path&#39;, project.moduleSourcePath
3844                 ])
3845         }
3846         // no jars needed for modules
3847         project.jar.enabled = false
3848 
3849         // and redirect the resources into the module
3850         project.sourceSets.main.output.resourcesDir = project.moduleDir
3851         project.processResources.destinationDir = project.moduleDir
3852     }
3853 
3854     if (project.hasProperty(&#39;moduleSourcePathShim&#39;) &amp;&amp;
3855             project.sourceSets.hasProperty(&#39;shims&#39;)) {
3856 
3857         // sync up the obvious source directories with the shims
3858         // others (like the shaders in graphics) should be added in there
3859         project.sourceSets.shims.java.srcDirs += project.sourceSets.main.java.srcDirs
3860         project.sourceSets.shims.java.srcDirs += &quot;$buildDir/gensrc/java&quot;
3861 
3862         project.compileShimsJava {
3863             options.compilerArgs.addAll([
3864                 &#39;-implicit:none&#39;,
3865                 &#39;--module-source-path&#39;, project.moduleSourcePathShim
3866                 ])
3867         }
3868         project.compileShimsJava.dependsOn(project.compileJava)
3869 
3870         def copyGeneratedShimsTask = task(&quot;copyGeneratedShims&quot;, type: Copy, dependsOn: [compileShimsJava, processShimsResources]) {
3871             from project.sourceSets.shims.java.outputDir
3872             into &quot;${rootProject.buildDir}/shims&quot;
3873             if (HAS_JAVAFX_MODULES) {
3874                 exclude(&quot;*/module-info.class&quot;)
3875             }
3876         }
3877 
3878         project.processShimsResources.dependsOn(project.processResources)
3879 
3880         // shims resources should have the main resouces as a base
3881         project.sourceSets.shims.resources.srcDirs += project.sourceSets.main.resources.srcDirs
3882 
3883         // and redirect the resources into the module
3884         project.sourceSets.shims.output.resourcesDir = project.moduleShimsDir
3885         project.processShimsResources.destinationDir = project.moduleShimsDir
3886 
3887        compileTestJava.dependsOn(copyGeneratedShimsTask)
3888     }
3889 
3890     if (project.hasProperty(&#39;modulePathArgs&#39;)) {
3891         project.compileJava.options.compilerArgs.addAll(modulePathArgs)
3892     }
3893 
3894     if (project.hasProperty(&#39;testModulePathArgs&#39;)) {
3895         project.compileTestJava.options.compilerArgs.addAll(testModulePathArgs)
3896     }
3897 
3898     if (project.hasProperty(&#39;testPatchModuleArgs&#39;)) {
3899         project.test.jvmArgs += testPatchModuleArgs
3900     }
3901 
3902     /* Note: we should not have to add extraAddExports to the normal
3903      * modular compile, as it contains all of the module-info files.
3904      * In fact doing so might cover up a module-info issue.
3905      * so we don&#39;t do it, and I will leave this commented out
3906      * block as a reminder of this fact.
3907     if (project.hasProperty(&#39;extraAddExports&#39;)) {
3908         project.compileJava.options.compilerArgs.addAll(extraAddExports);
3909     }
3910     */
3911 
3912     if (project.hasProperty(&#39;testAddExports&#39;)) {
3913         project.compileTestJava.options.compilerArgs.addAll(testAddExports);
3914         project.test.jvmArgs += testAddExports
3915     }
3916 
3917     if (rootProject.hasProperty(&quot;EXTRA_TEST_ARGS&quot;) &amp;&amp; project.hasProperty(&#39;test&#39;)) {
3918         EXTRA_TEST_ARGS.split(&#39; &#39;).each() { e -&gt;
3919             project.test.jvmArgs += e
3920         }
3921     }
3922 
3923     if (rootProject.hasProperty(&quot;EXTRA_COMPILE_ARGS&quot;) &amp;&amp; project.hasProperty(&#39;compileJava&#39;)) {
3924         project.compileJava.options.compilerArgs.addAll(EXTRA_COMPILE_ARGS.split(&#39; &#39;))
3925     }
3926 
3927     if (rootProject.hasProperty(&quot;EXTRA_COMPILE_ARGS&quot;) &amp;&amp; project.hasProperty(&#39;compileTestJava&#39;)) {
3928         project.compileTestJava.options.compilerArgs.addAll(EXTRA_COMPILE_ARGS.split(&#39; &#39;))
3929     }
3930 }
3931 
3932 /******************************************************************************
3933  *                                                                            *
3934  *                             Top Level Tasks                                *
3935  *                                                                            *
3936  *  These are the tasks which are defined only for the top level project and  *
3937  *  not for any sub projects. These are generally the entry point that is     *
3938  *  used by Hudson and by the continuous build system.                        *
3939  *                                                                            *
3940  *****************************************************************************/
3941 
3942 task clean() {
3943     group = &quot;Basic&quot;
3944     description = &quot;Deletes the build directory and the build directory of all sub projects&quot;
3945     getSubprojects().each { subProject -&gt;
3946         dependsOn(subProject.getTasksByName(&quot;clean&quot;, true));
3947     }
3948     doLast {
3949         delete(buildDir);
3950     }
3951 }
3952 
3953 task cleanAll() {
3954     group = &quot;Basic&quot;
3955     description = &quot;Scrubs the repo of build artifacts&quot;
3956     dependsOn(clean)
3957     doLast {
3958         //delete(&quot;.gradle&quot;); This causes problems on windows.
3959         delete(&quot;buildSrc/build&quot;);
3960     }
3961 }
3962 
3963 task createMSPfile() {
3964     group = &quot;Build&quot;
3965     File mspFile = new File(rootProject.buildDir,MODULESOURCEPATH)
3966     outputs.file(mspFile)
3967 
3968     doLast {
3969         mspFile.delete()
3970         mspFile &lt;&lt; &quot;--module-source-path\n&quot;
3971         mspFile &lt;&lt; defaultModuleSourcePath
3972         mspFile &lt;&lt; &quot;\n&quot;
3973     }
3974 }
3975 
3976 task javadoc(type: Javadoc, dependsOn: createMSPfile) {
3977     group = &quot;Basic&quot;
3978     description = &quot;Generates the JavaDoc for all the public API&quot;
3979     executable = JAVADOC
3980     def projectsToDocument = [
3981             project(&quot;:base&quot;), project(&quot;:graphics&quot;), project(&quot;:controls&quot;), project(&quot;:media&quot;),
3982             project(&quot;:swing&quot;), /*project(&quot;:swt&quot;),*/ project(&quot;:fxml&quot;), project(&quot;:web&quot;)]
3983     source(projectsToDocument.collect({
3984         [it.sourceSets.main.java]
3985     }));
3986     setDestinationDir(new File(buildDir, &#39;javadoc&#39;));
3987 
3988     exclude(&quot;com/**/*&quot;, &quot;Compile*&quot;, &quot;javafx/builder/**/*&quot;, &quot;javafx/scene/accessibility/**/*&quot;);
3989 
3990     options.tags(&quot;apiNote:a:API Note:&quot;)
3991     options.tags(&quot;implSpec:a:Implementation Requirements:&quot;)
3992     options.tags(&quot;implNote:a:Implementation Note:&quot;)
3993     options.tags(&quot;param&quot;)
3994     options.tags(&quot;return&quot;)
3995     options.tags(&quot;throws&quot;)
3996     options.tags(&quot;moduleGraph:X&quot;)
3997     options.tags(&quot;since&quot;)
3998     options.tags(&quot;version&quot;)
3999     options.tags(&quot;serialData&quot;)
4000     options.tags(&quot;factory&quot;)
4001     options.tags(&quot;see&quot;)
4002 
4003     options.windowTitle(&quot;${javadocTitle}&quot;)
4004     options.header(&quot;${javadocHeader}&quot;)
4005     options.bottom(&quot;${javadocBottom}&quot;)
4006     options.locale(&quot;en&quot;);
4007     if (JDK_DOCS_LINK != &quot;&quot;) {
4008         options.linksOffline(JDK_DOCS, JDK_DOCS_LINK);
4009     } else {
4010         options.links(JDK_DOCS);
4011     }
4012     options.addBooleanOption(&quot;XDignore.symbol.file&quot;).setValue(true);
4013     options.addBooleanOption(&quot;Xdoclint:${DOC_LINT}&quot;).setValue(IS_DOC_LINT);
4014     options.addBooleanOption(&quot;html5&quot;).setValue(true);
4015     options.addBooleanOption(&quot;javafx&quot;).setValue(true);
4016     options.addBooleanOption(&quot;use&quot;).setValue(true);
4017 
4018     options.setOptionFiles([
4019         new File(rootProject.buildDir,MODULESOURCEPATH)
4020         ]);
4021 
4022     doLast {
4023         projectsToDocument.each { p -&gt;
4024             def destDir = &quot;$buildDir/javadoc/${p.ext.moduleName}&quot;
4025             copy {
4026                 from(&quot;$p.projectDir/src/main/docs&quot;) {
4027                     include &quot;**/*.html&quot;
4028                     filter { line-&gt;
4029                         line = line.replace(&quot;@FXVERSION@&quot;, RELEASE_VERSION)
4030                     }
4031                 }
4032                 from(&quot;$p.projectDir/src/main/docs&quot;) {
4033                     exclude &quot;**/*.html&quot;
4034                 }
4035 
4036                 into destDir
4037             }
4038         }
4039     }
4040 
4041     dependsOn(projectsToDocument.collect { project -&gt; project.getTasksByName(&quot;classes&quot;, true)});
4042 }
4043 
4044 task sdk() {
4045     if (DO_BUILD_SDK_FOR_TEST) {
4046         rootProject.getTasksByName(&quot;test&quot;, true).each { t -&gt;
4047             if (t.enabled) t.dependsOn(sdk)
4048         }
4049     }
4050 }
4051 
4052 task jmods() {
4053     dependsOn(sdk)
4054     // real work items added later.
4055 }
4056 
4057 task appsjar() {
4058     dependsOn(sdk)
4059     // Note: the jar dependencies get added elsewhere see project(&quot;:apps&quot;)
4060 }
4061 
4062 // these are empty tasks, allowing us to depend on the task, which may have other
4063 // real work items added later.
4064 task copyAppsArtifacts() {
4065     dependsOn(appsjar)
4066 }
4067 
4068 task apps() {
4069     dependsOn(sdk)
4070     dependsOn(appsjar)
4071     dependsOn(copyAppsArtifacts)
4072 }
4073 
4074 task findbugs() {
4075     dependsOn(sdk)
4076 
4077     doLast {
4078         if (!BUILD_CLOSED) {
4079             println &quot;findbugs task is only run for a closed build&quot;
4080         }
4081     }
4082 }
4083 
4084 // create the zip file of modules for a JDK build
4085 task jdkZip {
4086     dependsOn(sdk)
4087 }
4088 
4089 // The following tasks are for the closed build only. They are a no-op for the open build
4090 
4091 task checkCache() {
4092     dependsOn(updateCacheIfNeeded)
4093 }
4094 
4095 task publicExports() {
4096     dependsOn(sdk, jmods, apps, javadoc, jdkZip)
4097     // note the real work is below in the compileTargets
4098 }
4099 
4100 task perf() {
4101     dependsOn(sdk, apps)
4102     doLast {
4103         if (!BUILD_CLOSED) {
4104             println &quot;perf task is only run for a closed build&quot;
4105         }
4106     }
4107 }
4108 
4109 task zips() {
4110     dependsOn(sdk, jmods, javadoc, apps, jdkZip, publicExports, perf)
4111     // note the real work is below in the compileTargets
4112 }
4113 
4114 task all() {
4115     dependsOn(sdk,publicExports,apps,perf,zips)
4116 }
4117 
4118 
4119 // Construct list of subprojects that are modules
4120 ext.moduleProjList = []
4121 subprojects {
4122     if (project.hasProperty(&quot;buildModule&quot;) &amp;&amp; project.ext.buildModule) {
4123         rootProject.ext.moduleProjList += project
4124         println &quot;module: $project (buildModule=YES)&quot;
4125     } else {
4126         println &quot;module: $project (buildModule=NO)&quot;
4127     }
4128 }
4129 
4130 
4131 // Define the sdk task, which also produces the javafx.swt modular jar
4132 
4133 compileTargets { t -&gt;
4134 
4135     def javafxSwtTask = task(&quot;javafxSwt$t.capital&quot;, type: Jar) {
4136         enabled = COMPILE_SWT
4137         group = &quot;Basic&quot;
4138         description = &quot;Creates the javafx-swt.jar for the $t.name target&quot;
4139         destinationDir = file(&quot;${project(&quot;:swt&quot;).buildDir}/libs&quot;)
4140         archiveName = &quot;javafx-swt.jar&quot;
4141         includeEmptyDirs = false
4142         from(&quot;${project(&quot;:swt&quot;).buildDir}/classes/java/main&quot;);
4143         include(&quot;**/javafx/embed/swt/**&quot;)
4144 
4145         dependsOn(
4146             project(&quot;:swt&quot;).compileJava,
4147             project(&quot;:swt&quot;).processResources,
4148             // note: assemble and classes are not enough for DidWork
4149             project(&quot;:swt&quot;).classes,
4150             // classes is needed for a jar copy
4151             )
4152     }
4153 
4154     // FIXME: do we really need the index task for this modular jar?
4155     def javafxSwtIndexTask = task(&quot;javafxSwtIndex$t.capital&quot;) {
4156         //the following is a workaround for the lack of indexing in gradle 1.4 through 1.7
4157         dependsOn(javafxSwtTask)
4158 
4159         doLast() {
4160             ant.jar (update: true, index: true, destfile: &quot;${javafxSwtTask.destinationDir}/${javafxSwtTask.archiveName}&quot;)
4161         }
4162     }
4163 
4164     def sdkTask = task(&quot;sdk$t.capital&quot;) {
4165         group = &quot;Basic&quot;
4166         dependsOn(javafxSwtIndexTask)
4167     }
4168 
4169     sdk.dependsOn(sdkTask)
4170 }
4171 
4172 project(&quot;:apps&quot;) {
4173     // The apps build is Ant based, we will exec ant from gradle.
4174 
4175     // Download the Lucene libraries needed for the Ensemble8 app
4176     def luceneVersion = &quot;7.7.2&quot;
4177     getConfigurations().create(&quot;lucene&quot;);
4178     dependencies {
4179         lucene group: &quot;org.apache.lucene&quot;, name: &quot;lucene-core&quot;, version: luceneVersion
4180         lucene group: &quot;org.apache.lucene&quot;, name: &quot;lucene-grouping&quot;, version: luceneVersion
4181         lucene group: &quot;org.apache.lucene&quot;, name: &quot;lucene-queryparser&quot;, version: luceneVersion
4182     }
4183 
4184     // Copy Lucene libraries into the Ensemble8/lib directory
4185     File ensembleLibDir = rootProject.file(&quot;apps/samples/Ensemble8/lib&quot;);
4186     def libNames = [ &quot;lucene-core-${luceneVersion}.jar&quot;,
4187                      &quot;lucene-grouping-${luceneVersion}.jar&quot;,
4188                      &quot;lucene-queryparser-${luceneVersion}.jar&quot; ]
4189 
4190 
4191     task getLucene(type: Copy) {
4192         doFirst {
4193             ensembleLibDir.mkdirs();
4194         }
4195         into ensembleLibDir
4196         includeEmptyDirs = false
4197         configurations.lucene.files.each { f -&gt;
4198             libNames.each { name -&gt;
4199                 if (name == f.getName()) {
4200                     from f.getPath()
4201                 }
4202             }
4203         }
4204     }
4205 
4206     compileTargets { t -&gt;
4207         List&lt;String&gt; params = []
4208 
4209         params &lt;&lt; &quot;-DtargetBld=$t.name&quot;
4210 
4211         if (!rootProject.ext[t.upper].compileSwing) {
4212             params &lt;&lt; &quot;-DJFX_CORE_ONLY=true&quot;
4213         }
4214         params &lt;&lt; &quot;-Dplatforms.JDK_1.9.home=${rootProject.ext.JDK_HOME}&quot;
4215         params &lt;&lt; &quot;-Dcompile.patch=@${rootProject.buildDir}/${COMPILEARGSFILE}&quot;
4216         params &lt;&lt; &quot;-Drun.patch=@${rootProject.buildDir}/${RUNARGSFILE}&quot;
4217 
4218         def appsJar = project.task(&quot;appsJar${t.capital}&quot;) {
4219             dependsOn(sdk, getLucene)
4220             doLast() {
4221                 ant(t.name,
4222                       projectDir.path,
4223                       &quot;appsJar&quot;,
4224                       params);
4225             }
4226         }
4227         rootProject.appsjar.dependsOn(appsJar)
4228 
4229         def appsClean = project.task(&quot;clean${t.capital}&quot;) {
4230             doLast() {
4231                 ant(t.name,
4232                       project.projectDir.path,
4233                       &quot;clean&quot;,
4234                       params);
4235                 delete(ensembleLibDir);
4236             }
4237         }
4238         rootProject.clean.dependsOn(appsClean)
4239     }
4240 }
4241 
4242 // Tasks to create the disk layout for the sdk, jmods, and docs
4243 // in the artifacts directory (publicExports), and zip them up in
4244 // artifacts/bundles (zips)
4245 // These tasks are only used for the standalone SDK.
4246 compileTargets { t -&gt;
4247     if (!HAS_JAVAFX_MODULES) {
4248         def targetProperties = rootProject.ext[t.upper]
4249         def platformPrefix = targetProperties.platformPrefix
4250 
4251         def artifactsDir = &quot;${rootProject.buildDir}/artifacts&quot;
4252         def bundlesDir = &quot;${artifactsDir}/bundles&quot;
4253 
4254         def sdkDirName = &quot;${platformPrefix}sdk&quot;
4255         def sdkDir = &quot;${rootProject.buildDir}/${sdkDirName}&quot;
4256         def sdkBundleName = &quot;javafx-sdk-${RELEASE_VERSION}&quot;
4257         def sdkArtifactsDir = &quot;${artifactsDir}/${sdkBundleName}&quot;
4258 
4259         def docsDirName = &quot;javadoc&quot;
4260         def docsDir = &quot;${rootProject.buildDir}/${docsDirName}&quot;
4261         def docsBundleName = &quot;javafx-docs-${RELEASE_VERSION}&quot;
4262         def docsArtifactsDir = &quot;${artifactsDir}/${docsBundleName}&quot;
4263 
4264         def jmodsDirName = &quot;jmods&quot;
4265         def jmodsDir = &quot;${rootProject.buildDir}/${jmodsDirName}&quot;
4266         def jmodsBundleName = &quot;javafx-jmods-${RELEASE_VERSION}&quot;
4267         def jmodsArtifactsDir = &quot;${artifactsDir}/${jmodsBundleName}&quot;
4268 
4269         def publicExportsTask = task (&quot;publicExportsStandalone${t.capital}&quot;) {
4270             group = &quot;Basic&quot;
4271             description = &quot;Creates the disk layout for sdk, jmods, and docs&quot;
4272         }
4273         publicExports.dependsOn(publicExportsTask)
4274 
4275         def copyArtifactsSdkTask = task(&quot;copyArtifactsSdk$t.capital&quot;, type: Copy, dependsOn: [sdk,jmods,apps,javadoc]) {
4276             from sdkDir
4277             into sdkArtifactsDir
4278         }
4279         publicExportsTask.dependsOn(copyArtifactsSdkTask)
4280 
4281         // Need to modify file permissions Windows to make sure that the
4282         // execute bit is set, and that the files are world readable
4283         def chmodArtifactsSdkTask = task(&quot;chmodArtifactsSdk$t.capital&quot;, dependsOn: copyArtifactsSdkTask) {
4284             if (IS_WINDOWS &amp;&amp; IS_USE_CYGWIN) {
4285                 doLast {
4286                     exec {
4287                         workingDir(sdkArtifactsDir)
4288                         commandLine(&quot;chmod&quot;, &quot;-R&quot;, &quot;755&quot;, &quot;.&quot;)
4289                     }
4290                 }
4291             }
4292         }
4293         publicExportsTask.dependsOn(chmodArtifactsSdkTask)
4294 
4295         def copyArtifactsDocsTask = task(&quot;copyArtifactsDocs$t.capital&quot;, type: Copy, dependsOn: chmodArtifactsSdkTask) {
4296             from docsDir
4297             into &quot;${docsArtifactsDir}/api&quot;
4298         }
4299         publicExportsTask.dependsOn(copyArtifactsDocsTask)
4300 
4301         def copyArtifactsJmodsTask = task(&quot;copyArtifactsJmods$t.capital&quot;, type: Copy, dependsOn: copyArtifactsDocsTask) {
4302             from jmodsDir
4303             into &quot;${jmodsArtifactsDir}&quot;
4304         }
4305         publicExportsTask.dependsOn(copyArtifactsJmodsTask)
4306 
4307         def zipsTask = task (&quot;zipsStandalone${t.capital}&quot;) {
4308             group = &quot;Basic&quot;
4309             description = &quot;Creates the public zip bundles&quot;
4310         }
4311         zips.dependsOn(zipsTask)
4312 
4313         // Use native zip tool so that file permissions are preserved on Windows
4314         def zipSdkTask = task(&quot;zipSdk$t.capital&quot;, dependsOn: publicExportsTask) {
4315             doLast {
4316                 def outZipFile = &quot;${bundlesDir}/${sdkBundleName}.zip&quot;
4317                 mkdir bundlesDir
4318                 exec {
4319                     workingDir(artifactsDir)
4320                     commandLine(&quot;zip&quot;, &quot;-q&quot;, &quot;-r&quot;, outZipFile, sdkBundleName)
4321                 }
4322             }
4323         }
4324         zipsTask.dependsOn(zipSdkTask)
4325 
4326         def zipDocsTask = task(&quot;zipDocs$t.capital&quot;, type: Zip, dependsOn: zipSdkTask) {
4327             destinationDir = file(&quot;${bundlesDir}&quot;)
4328             archiveName = &quot;${docsBundleName}.zip&quot;
4329             includeEmptyDirs = false
4330             from docsArtifactsDir
4331             into &quot;${docsBundleName}&quot;
4332         }
4333         zipsTask.dependsOn(zipDocsTask)
4334 
4335         def zipJmodsTask = task(&quot;zipJmods$t.capital&quot;, type: Zip, dependsOn: zipDocsTask) {
4336             destinationDir = file(&quot;${bundlesDir}&quot;)
4337             archiveName = &quot;${jmodsBundleName}.zip&quot;
4338             includeEmptyDirs = false
4339             from jmodsArtifactsDir
4340             into &quot;${jmodsBundleName}&quot;
4341         }
4342         zipsTask.dependsOn(zipJmodsTask)
4343     }
4344 }
4345 
4346 
4347 /******************************************************************************
4348  *                                                                            *
4349  *                             OpenJFX Stubs                                  *
4350  *                                                                            *
4351  *****************************************************************************/
4352 
4353 configurations {
4354     openjfxStubs
4355 }
4356 
4357 if (IS_STUB_RUNTIME_OPENJFX) {
4358     def String platform = IS_MAC ? &quot;mac&quot; : IS_WINDOWS ? &quot;win&quot; : IS_LINUX ? &quot;linux&quot; : &quot;&quot;
4359     dependencies {
4360         openjfxStubs &quot;org.openjfx:javafx-media:$STUB_RUNTIME_OPENJFX:$platform@jar&quot;
4361         openjfxStubs &quot;org.openjfx:javafx-web:$STUB_RUNTIME_OPENJFX:$platform@jar&quot;
4362     }
4363 }
4364 
4365 // Extract binary libraries from OpenJFX artifacts for use as stubs
4366 task prepOpenJfxStubs(type: Copy) {
4367     enabled = IS_STUB_RUNTIME_OPENJFX
4368 
4369     from configurations.openjfxStubs.files.collect { zipTree(it) }
4370     include(&quot;*.dll&quot;)
4371     include(&quot;*.dylib&quot;)
4372     include(&quot;*.so&quot;)
4373     into IS_WINDOWS ? file(&quot;$openjfxStubRuntime/bin&quot;) : file(&quot;$openjfxStubRuntime/lib&quot;)
4374 }
4375 
4376 
4377 /******************************************************************************
4378  *                                                                            *
4379  *                               Modules                                      *
4380  *                                                                            *
4381  *****************************************************************************/
4382 
4383 ext.moduleDependencies = [file(&quot;dependencies&quot;)]
4384 
4385 task buildModules {
4386 }
4387 
4388 // Combine the classes, lib, and bin for each module
4389 compileTargets { t -&gt;
4390     def targetProperties = project.ext[t.upper]
4391 
4392     def platformPrefix = targetProperties.platformPrefix
4393     def bundledSdkDirName = &quot;${platformPrefix}modular-sdk&quot;
4394     def bundledSdkDir = &quot;${rootProject.buildDir}/${bundledSdkDirName}&quot;
4395     def modulesDir = &quot;${bundledSdkDir}/modules&quot;
4396     def modulesCmdsDir = &quot;${bundledSdkDir}/modules_cmds&quot;
4397     def modulesLibsDir = &quot;${bundledSdkDir}/modules_libs&quot;
4398     def modulesSrcDir = &quot;${bundledSdkDir}/modules_src&quot;
4399     def modulesConfDir = &quot;${bundledSdkDir}/modules_conf&quot;
4400     def modulesLegalDir = &quot;${bundledSdkDir}/modules_legal&quot;
4401     def modulesMakeDir = &quot;${bundledSdkDir}/make&quot;
4402 
4403     final File runArgsFile = file(&quot;${rootProject.buildDir}/${RUNARGSFILE}&quot;)
4404     final File compileArgsFile = file(&quot;${rootProject.buildDir}/${COMPILEARGSFILE}&quot;)
4405 
4406     project.files(runArgsFile);
4407 
4408     def buildModulesTask = task(&quot;buildModules$t.capital&quot;, group: &quot;Build&quot;) {
4409         // BUNDLED SDK
4410 
4411         // Copy dependencies/*/module-info.java.extra
4412         // merging as needed, removing duplicates
4413         // only lines with &#39;exports&#39; will be copied
4414         def dependencyRoots = moduleDependencies
4415         if (rootProject.hasProperty(&quot;closedModuleDepedencies&quot;)) {
4416             dependencyRoots = [dependencyRoots, closedModuleDepedencies].flatten()
4417         }
4418 
4419         // Create the inputs/outputs list first to support UP-TO-DATE
4420         ArrayList outputNames = new ArrayList()
4421         dependencyRoots.each { root -&gt;
4422             FileTree ft = fileTree(root).include(&#39;**/*.extra&#39;)
4423             ft.each() { e-&gt;
4424                 inputs.file(e)
4425 
4426                 String usename = e.path
4427                 String filePath = e.getAbsolutePath()
4428                 String folderPath = root.getAbsolutePath()
4429                 if (filePath.startsWith(folderPath)) {
4430                     usename = filePath.substring(folderPath.length() + 1);
4431                 }
4432                 if (! outputNames.contains(usename) ) {
4433                     outputNames.add(usename)
4434                 }
4435             }
4436         }
4437 
4438         outputNames.each() { e-&gt;
4439                 File f = new File(modulesSrcDir, e)
4440                 outputs.file(f)
4441         }
4442 
4443         def outputPolicyDir = &quot;${modulesConfDir}/java.base/security&quot;
4444         def outputPolicyFile = file(&quot;${outputPolicyDir}/java.policy.extra&quot;)
4445 
4446         outputs.file(outputPolicyFile)
4447         moduleProjList.each { project -&gt;
4448             def policyDir = &quot;${project.projectDir}/src/main/conf/security&quot;
4449             def policyFile = file(&quot;${policyDir}/java.policy&quot;)
4450             if (policyFile.exists()) {
4451                 inputs.file(policyFile)
4452             }
4453         }
4454 
4455         doLast {
4456             Map extras = [:]
4457 
4458             dependencyRoots.each { root -&gt;
4459                 FileTree ft = fileTree(root).include(&#39;**/*.extra&#39;)
4460                 ft.each() { e-&gt;
4461                     String usename = e.path
4462                     String filePath = e.getAbsolutePath()
4463                     String folderPath = root.getAbsolutePath()
4464                     if (filePath.startsWith(folderPath)) {
4465                         usename = filePath.substring(folderPath.length() + 1);
4466                     }
4467                     if (extras.containsKey(usename)) {
4468                         List&lt;String&gt; lines = extras.get(usename)
4469                         e.eachLine { line -&gt;
4470                             line = line.trim()
4471                             if (line.length() &gt; 1 &amp;&amp; Character.isLetter(line.charAt(0))) {
4472                                 lines &lt;&lt; line
4473                             }
4474                         }
4475 
4476                     } else {
4477                         List&lt;String&gt; lines = []
4478                         e.eachLine { line -&gt;
4479                             line = line.trim()
4480                             if (line.length() &gt; 1 &amp;&amp; Character.isLetter(line.charAt(0))) {
4481                                 lines &lt;&lt; line
4482                             }
4483                         }
4484                         extras.put(usename,lines)
4485                     }
4486                 }
4487             }
4488             extras.keySet().each() { e-&gt;
4489                 File f = new File(modulesSrcDir, e)
4490                 f.getParentFile().mkdirs()
4491                 f.delete()
4492 
4493                 extras.get(e).unique().each() { l-&gt;
4494                     f &lt;&lt; l
4495                     f &lt;&lt; &quot;\n&quot;
4496                 }
4497             }
4498 
4499             // concatecate java.policy files into a single file
4500             //
4501             mkdir outputPolicyDir
4502             outputPolicyFile.delete()
4503             moduleProjList.each { project -&gt;
4504                 def policyDir = &quot;${project.projectDir}/src/main/conf/security&quot;
4505                 def policyFile = file(&quot;${policyDir}/java.policy&quot;)
4506                 if (policyFile.exists()) outputPolicyFile &lt;&lt; policyFile.text
4507             }
4508         }
4509     }
4510     buildModules.dependsOn(buildModulesTask)
4511 
4512     // BUNDLED SDK
4513     moduleProjList.each { project -&gt;
4514         // Copy classes, bin, and lib directories
4515 
4516         def moduleName = project.ext.moduleName
4517         def buildDir = project.buildDir
4518 
4519         def srcClassesDir = &quot;${buildDir}/${platformPrefix}module-classes&quot;
4520         def dstClassesDir = &quot;${modulesDir}/${moduleName}&quot;
4521         def copyClassFilesTask = project.task(&quot;copyClassFiles$t.capital&quot;, type: Copy, dependsOn: project.assemble) {
4522             from srcClassesDir
4523             into dstClassesDir
4524             exclude(&quot;module-info.class&quot;)
4525         }
4526 
4527         def srcCmdsDir = &quot;${buildDir}/${platformPrefix}module-bin&quot;
4528         def dstCmdsDir = &quot;${modulesCmdsDir}/${moduleName}&quot;
4529         def copyBinFilesTask = project.task(&quot;copyBinFiles$t.capital&quot;, type: Copy, dependsOn: copyClassFilesTask) {
4530             from srcCmdsDir
4531             into dstCmdsDir
4532         }
4533 
4534         def srcLibsDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
4535         def dstLibsDir = &quot;${modulesLibsDir}/${moduleName}&quot;
4536         def copyLibFilesTask = project.task(&quot;copyLibFiles$t.capital&quot;, type: Copy, dependsOn: copyBinFilesTask) {
4537             from srcLibsDir
4538             into dstLibsDir
4539         }
4540 
4541         // Copy module sources
4542         // FIXME: javafx.swt sources?
4543         def copySources = project.hasProperty(&quot;includeSources&quot;) &amp;&amp; project.includeSources
4544         def copySourceFilesTask = project.task(&quot;copySourceFiles$t.capital&quot;, type: Copy, dependsOn: copyLibFilesTask) {
4545             if (copySources) {
4546                 from &quot;${project.projectDir}/src/main/java&quot;
4547                 if (project.name.equals(&quot;base&quot;)) {
4548                     from &quot;${project.projectDir}/build/gensrc/java&quot;
4549                 }
4550                 if (project.name.equals(&quot;web&quot;)) {
4551                     from &quot;${project.projectDir}/src/main/native/Source/WebCore/bindings/java/dom3/java&quot;
4552                 }
4553             } else {
4554                 from &quot;${project.projectDir}/src/main/java/module-info.java&quot;
4555             }
4556             into &quot;${modulesSrcDir}/${moduleName}&quot;
4557             include &quot;**/*.java&quot;
4558 
4559             if (project.hasProperty(&quot;sourceFilter&quot;)) {
4560                 filter(project.sourceFilter)
4561             }
4562         }
4563 
4564         // Copy .html and other files needed for doc bundles
4565         def copyDocFiles = project.task(&quot;copyDocFiles$t.capital&quot;, type: Copy, dependsOn: copySourceFilesTask) {
4566             if (copySources) {
4567                 from(&quot;${project.projectDir}/src/main/docs&quot;) {
4568                     include &quot;**/*.html&quot;
4569                     filter { line-&gt;
4570                         line = line.replace(&quot;@FXVERSION@&quot;, RELEASE_VERSION)
4571                     }
4572                 }
4573                 from(&quot;${project.projectDir}/src/main/docs&quot;) {
4574                     exclude &quot;**/*.html&quot;
4575                 }
4576                 from(&quot;${project.projectDir}/src/main/java&quot;) {
4577                     exclude &quot;**/*.java&quot;
4578                 }
4579 
4580                 into &quot;${modulesSrcDir}/${moduleName}&quot;
4581             }
4582         }
4583 
4584         // Copy make/build.properties
4585         def srcMakeDir = &quot;${project.projectDir}/make&quot;
4586         def dstMakeDir = &quot;${modulesMakeDir}/${moduleName}&quot;
4587         def copyBuildPropertiesTask = project.task(&quot;copyBuildProperties$t.capital&quot;, type: Copy, dependsOn: copyDocFiles) {
4588             from srcMakeDir
4589             into dstMakeDir
4590         }
4591 
4592         // Copy legal files
4593         def srcLegalDir = &quot;${project.projectDir}/src/main/legal&quot;
4594         def dstLegalDir = &quot;${modulesLegalDir}/${moduleName}&quot;
4595         def copyLegalTask = project.task(&quot;copyLegal$t.capital&quot;, type: Copy, dependsOn: copyBuildPropertiesTask) {
4596             from srcLegalDir
4597             into dstLegalDir
4598 
4599             // Exclude ANGLE since we (currently) do not use it
4600             exclude(&quot;angle.md&quot;)
4601         }
4602 
4603         buildModulesTask.dependsOn(
4604             copyClassFilesTask,
4605             copyLibFilesTask,
4606             copySourceFilesTask,
4607             copyDocFiles,
4608             copyBuildPropertiesTask,
4609             copyLegalTask)
4610     }
4611 
4612     // ============================================================
4613 
4614     def standaloneSdkDirName = &quot;${platformPrefix}sdk&quot;
4615     def standaloneSdkDir = &quot;${rootProject.buildDir}/${standaloneSdkDirName}&quot;
4616     def standaloneLibDir = &quot;${standaloneSdkDir}/lib&quot;
4617     def libDest=targetProperties.libDest
4618     def standaloneNativeDir = &quot;${standaloneSdkDir}/${libDest}&quot;
4619     def standaloneLegalDir = &quot;${standaloneSdkDir}/legal&quot;
4620     def standaloneSrcZipName = &quot;src.zip&quot;
4621 
4622     // STANDALONE SDK
4623     moduleProjList.each { project -&gt;
4624         // Copy classes, bin, and lib directories
4625 
4626         def moduleName = project.ext.moduleName
4627         def buildDir = project.buildDir
4628 
4629         // Create modular jars
4630         def srcClassesDir = &quot;${buildDir}/${platformPrefix}module-classes&quot;
4631         def srcLibsDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
4632         def dstModularJarDir = &quot;${standaloneLibDir}&quot;
4633         def modularJarName = &quot;${moduleName}.jar&quot;
4634         def modularJarTask = project.task(&quot;modularJarStandalone$t.capital&quot;, type: Jar, dependsOn: project.assemble) {
4635             destinationDir = file(&quot;${dstModularJarDir}&quot;)
4636             archiveName = modularJarName
4637             includeEmptyDirs = false
4638             from srcClassesDir
4639         }
4640 
4641         // Copy native libraries
4642         def srcNativeDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
4643         def dstNativeDir = &quot;${standaloneNativeDir}&quot;
4644         def copyNativeFilesTask = project.task(&quot;copyNativeFilesStandalone$t.capital&quot;, type: Copy, dependsOn: modularJarTask) {
4645             from srcNativeDir
4646             into dstNativeDir
4647             include(&quot;*.dll&quot;)
4648         }
4649 
4650         // Copy other lib files
4651         def dstLibsDir = &quot;${standaloneLibDir}&quot;
4652         def copyLibFilesTask = project.task(&quot;copyLibFilesStandalone$t.capital&quot;, type: Copy, dependsOn: copyNativeFilesTask) {
4653             from srcLibsDir
4654             into dstLibsDir
4655             exclude(&quot;*.dll&quot;)
4656         }
4657 
4658         // Copy legal files
4659         def licenseFiles = [ &quot;ADDITIONAL_LICENSE_INFO&quot;, &quot;ASSEMBLY_EXCEPTION&quot;, &quot;LICENSE&quot; ]
4660         def srcLegalDir = &quot;${project.projectDir}/src/main/legal&quot;
4661         def dstLegalDir = &quot;${standaloneLegalDir}/${moduleName}&quot;
4662         def copyLegalTask = project.task(&quot;copyLegalStandalone$t.capital&quot;, type: Copy, dependsOn: copyLibFilesTask) {
4663 
4664             def rtDir = rootProject.file(&#39;.&#39;)
4665             licenseFiles.each { lFile -&gt;
4666                 from &quot;${rtDir}/${lFile}&quot;
4667             }
4668 
4669             from srcLegalDir
4670 
4671             into dstLegalDir
4672 
4673             // Exclude ANGLE since we (currently) do not use it
4674             exclude(&quot;angle.md&quot;)
4675         }
4676 
4677         buildModulesTask.dependsOn(
4678             modularJarTask,
4679             copyNativeFilesTask,
4680             copyLibFilesTask,
4681             copyLegalTask)
4682     }
4683 
4684     // Zip module sources for standalone SDK
4685     //
4686     // NOTE: the input is taken from the modular-sdk/modules_src dir
4687     // so that we don&#39;t have to duplicate the logic and create another
4688     // temporary directory. This is somewhat inelegant, since the bundled sdk
4689     // and the standalone sdk should be independent of one another, but seems
4690     // better than the alternatives.
4691     def zipSourceFilesTask = project.task(&quot;zipSourceFilesStandalone$t.capital&quot;, type: Zip, dependsOn: buildModulesTask) {
4692         destinationDir = file(&quot;${standaloneLibDir}&quot;)
4693         archiveName = standaloneSrcZipName
4694         includeEmptyDirs = false
4695         from modulesSrcDir
4696         include &quot;**/*.java&quot;
4697     }
4698     buildModules.dependsOn(zipSourceFilesTask)
4699 
4700     // ============================================================
4701 
4702     // Maven Publications
4703     def publicationDirName = &quot;${platformPrefix}publications&quot;
4704     def publicationDir = &quot;${rootProject.buildDir}/${publicationDirName}&quot;
4705 
4706     moduleProjList.each { project -&gt; 
4707         // Create publications to be uploaded 
4708 
4709         def moduleName = project.ext.moduleName
4710         def buildDir = project.buildDir
4711 
4712         def dstModularJarDir=&quot;${publicationDir}&quot;
4713         def srcClassesDir = &quot;${buildDir}/${platformPrefix}module-classes&quot;
4714         def srcLibsDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
4715 
4716         def modularEmptyPublicationJarName = &quot;${moduleName}.jar&quot;
4717         def modularEmptyPublicationJarTask = project.task(&quot;moduleEmptyPublicationJar${t.capital}&quot;, type: Jar) {
4718             destinationDir = file(&quot;${dstModularJarDir}&quot;)
4719             archiveName = modularEmptyPublicationJarName
4720             manifest {
4721                 attributes(
4722                     &#39;Automatic-Module-Name&#39;:&quot;${moduleName}Empty&quot;
4723                 )
4724             }
4725         }
4726 
4727         def modularPublicationJarName = &quot;${moduleName}-${t.name}.jar&quot;
4728         def modularPublicationJarTask = project.task(&quot;modularPublicationJar${t.capital}&quot;, type: Jar, dependsOn: modularEmptyPublicationJarTask) {
4729             destinationDir = file(&quot;${dstModularJarDir}&quot;)
4730             archiveName = modularPublicationJarName
4731             from srcLibsDir
4732             from srcClassesDir
4733         }
4734 
4735         buildModulesTask.dependsOn(modularPublicationJarTask)
4736 
4737     }
4738     // ============================================================
4739 
4740     def buildRunArgsTask = task(&quot;buildRunArgs$t.capital&quot;,
4741             group: &quot;Build&quot;, dependsOn: buildModulesTask) {
4742         outputs.file(runArgsFile);
4743         inputs.file(EXTRAADDEXPORTS);
4744         doLast() {
4745             List&lt;String&gt;modpath = []
4746             List&lt;String&gt;modnames = []
4747 
4748             moduleProjList.each { project -&gt;
4749                 def moduleName = project.ext.moduleName
4750                 def dstModuleDir = cygpath(&quot;${modulesDir}/${moduleName}&quot;)
4751                 if (HAS_JAVAFX_MODULES) {
4752                     modpath &lt;&lt;  &quot;${moduleName}=${dstModuleDir}&quot;
4753                 } else {
4754                     modnames &lt;&lt; moduleName
4755                 }
4756             }
4757 
4758             if (HAS_JAVAFX_MODULES) {
4759                 writeRunArgsFile(runArgsFile, computeLibraryPath(true), modpath, null)
4760                 writeRunArgsFile(compileArgsFile, null, modpath, null)
4761 
4762                 if (rootProject.hasProperty(&quot;EXTRA_ADDEXPORTS_STRING&quot;)) {
4763                     runArgsFile &lt;&lt; EXTRA_ADDEXPORTS_STRING
4764                     compileArgsFile &lt;&lt; EXTRA_ADDEXPORTS_STRING
4765                 }
4766             } else {
4767                 modpath = [ cygpath(&quot;${standaloneLibDir}&quot;) ]
4768                 writeRunArgsFile(runArgsFile, null, modpath, modnames)
4769                 writeRunArgsFile(compileArgsFile, null, modpath, modnames)
4770             }
4771         }
4772     }
4773     buildModules.dependsOn(buildRunArgsTask)
4774 
4775     def isWindows = IS_WINDOWS &amp;&amp; t.name == &quot;win&quot;;
4776     def isMac = IS_MAC &amp;&amp; t.name == &quot;mac&quot;;
4777 
4778     // Create layout for modular classes
4779     moduleProjList.each { project -&gt;
4780         def buildModuleClassesTask = project.task(&quot;buildModule$t.capital&quot;, group: &quot;Build&quot;, type: Copy) {
4781             dependsOn(project.assemble)
4782             def buildDir = project.buildDir
4783             def sourceBuildDirs = [
4784                 &quot;${buildDir}/classes/java/main/${project.moduleName}&quot;,
4785             ]
4786 
4787             def moduleClassesDir = &quot;$buildDir/${platformPrefix}module-classes&quot;
4788                 includeEmptyDirs = false
4789                 sourceBuildDirs.each { d -&gt;
4790                     from d
4791                 }
4792                 into moduleClassesDir
4793 
4794                 // Exclude obsolete, experimental, or non-shipping code
4795                 exclude(&quot;version.rc&quot;)
4796                 exclude(&quot;com/sun/glass/ui/swt&quot;)
4797                 exclude(&quot;com/sun/javafx/tools/ant&quot;)
4798                 exclude(&quot;com/javafx/main&quot;)
4799                 exclude(&quot;com/sun/javafx/webkit/drt&quot;)
4800                 if (!IS_INCLUDE_NULL3D) {
4801                     exclude (&quot;com/sun/prism/null3d&quot;)
4802                 }
4803                 if (!IS_INCLUDE_ES2) {
4804                        exclude(&quot;com/sun/prism/es2&quot;,
4805                                &quot;com/sun/scenario/effect/impl/es2&quot;)
4806                 }
4807 
4808                 // Exclude platform-specific classes for other platforms
4809 
4810                 if (!isMac) {
4811                     exclude (&quot;com/sun/media/jfxmediaimpl/platform/osx&quot;,
4812                              &quot;com/sun/prism/es2/MacGL*&quot;,
4813                              &quot;com/sun/glass/events/mac&quot;,
4814                              &quot;com/sun/glass/ui/mac&quot;,
4815                              )
4816                 }
4817 
4818                 if (!isWindows) {
4819                     exclude (&quot;**/*.hlsl&quot;,
4820                              &quot;com/sun/glass/ui/win&quot;,
4821                              &quot;com/sun/prism/d3d&quot;,
4822                              &quot;com/sun/prism/es2/WinGL*&quot;,
4823                              &quot;com/sun/scenario/effect/impl/hw/d3d&quot;
4824                              )
4825                 }
4826 
4827                 if (!targetProperties.includeGTK) { //usually IS_LINUX
4828                     exclude (
4829                              &quot;com/sun/glass/ui/gtk&quot;,
4830                              &quot;com/sun/prism/es2/EGL*&quot;,
4831                              &quot;com/sun/prism/es2/X11GL*&quot;
4832                              )
4833                 }
4834 
4835                 if (!targetProperties.includeEGL) {
4836                     exclude (&quot;com/sun/prism/es2/EGL*&quot;)
4837                 }
4838 
4839                 if (!targetProperties.includeMonocle) {
4840                     exclude (&quot;com/sun/glass/ui/monocle&quot;)
4841                     exclude(&quot;com/sun/prism/es2/Monocle*&quot;)
4842                 }
4843 
4844                 if (t.name != &#39;ios&#39;) {
4845                     exclude (&quot;com/sun/media/jfxmediaimpl/platform/ios&quot;,
4846                              &quot;com/sun/glass/ui/ios&quot;,
4847                              &quot;com/sun/prism/es2/IOS*&quot;
4848                              )
4849                 }
4850 
4851                 if (t.name != &#39;android&#39; &amp;&amp; t.name != &#39;dalvik&#39;) {
4852                     exclude (&quot;com/sun/glass/ui/android&quot;)
4853                 }
4854 
4855                 // Filter out other platform-specific classes
4856                 if (targetProperties.containsKey(&#39;jfxrtJarExcludes&#39;)) {
4857                     exclude(targetProperties.jfxrtJarExcludes)
4858                 }
4859 
4860                 /* FIXME: JIGSAW -- handle this in the module itself
4861                 String webbld = project(&quot;:web&quot;).buildDir.path
4862                 String ctrlbld = project(&quot;:controls&quot;).buildDir.path
4863                 if (t.name == &#39;android&#39;) {
4864                     from (&quot;${webbld}/classes/android&quot;,
4865                           &quot;${webbld}/resources/android&quot;,
4866                           &quot;${ctrlbld}/classes/android&quot;,
4867                           &quot;${ctrlbld}/resources/android&quot;)
4868                 } else if (t.name == &#39;ios&#39;) {
4869                     from (&quot;${webbld}/classes/ios&quot;,
4870                           &quot;${webbld}/resources/ios&quot;)
4871                 } else {
4872                     from (&quot;${webbld}/classes/java/main&quot;)
4873                 }
4874                 */
4875         }
4876         buildModulesTask.dependsOn(buildModuleClassesTask)
4877     }
4878 
4879     def buildModuleLibsTask = task(&quot;buildModuleLibs$t.capital&quot;) {
4880         group = &quot;Basic&quot;
4881 
4882         def baseProject = project(&quot;:base&quot;);
4883 
4884         def graphicsProject = project(&quot;:graphics&quot;);
4885 
4886         def mediaProject = project(&quot;:media&quot;);
4887 
4888         def webProject = project(&quot;:web&quot;);
4889         dependsOn(webProject.assemble)
4890 
4891         def swtProject = project(&quot;:swt&quot;);
4892 
4893         def library = targetProperties.library
4894 
4895         def useLipo = targetProperties.containsKey(&#39;useLipo&#39;) ? targetProperties.useLipo : false
4896         def modLibDest = targetProperties.modLibDest
4897         def moduleNativeDirName = &quot;${platformPrefix}module-$modLibDest&quot;
4898 
4899         def buildModuleBaseTask = task(&quot;buildModuleBase$t.capital&quot;, dependsOn: baseProject.assemble) {
4900             group = &quot;Basic&quot;
4901             description = &quot;creates javafx.base property files&quot;
4902 
4903             def moduleLibDir = &quot;${baseProject.buildDir}/${platformPrefix}module-lib&quot;
4904             final File javafxProperties = file(&quot;${moduleLibDir}/javafx.properties&quot;)
4905             outputs.file(javafxProperties)
4906 
4907             if (targetProperties.containsKey(&quot;javafxPlatformProperties&quot;)) {
4908                 final File javafxPlatformProperties = file(&quot;${moduleLibDir}/javafx.platform.properties&quot;)
4909                 outputs.file(javafxPlatformProperties)
4910             }
4911 
4912             doLast {
4913                 mkdir moduleLibDir
4914 
4915                 javafxProperties.delete()
4916                 javafxProperties &lt;&lt; &quot;javafx.version=$RELEASE_VERSION_SHORT&quot;;
4917                 javafxProperties &lt;&lt; &quot;\n&quot;
4918                 javafxProperties &lt;&lt; &quot;javafx.runtime.version=$RELEASE_VERSION_LONG&quot;;
4919                 javafxProperties &lt;&lt; &quot;\n&quot;
4920                 javafxProperties &lt;&lt; &quot;javafx.runtime.build=$PROMOTED_BUILD_NUMBER&quot;;
4921                 javafxProperties &lt;&lt; &quot;\n&quot;
4922                 // Include any properties that have been defined (most likely in
4923                 // one of the various platform gradle files)
4924                 if (targetProperties.containsKey(&quot;javafxProperties&quot;)) {
4925                     javafxProperties &lt;&lt; targetProperties.javafxProperties
4926                     javafxProperties &lt;&lt; &quot;\n&quot;
4927                 }
4928 
4929                 // Embedded builds define this file as well
4930                 if (targetProperties.containsKey(&quot;javafxPlatformProperties&quot;)) {
4931                     final File javafxPlatformProperties = file(&quot;${moduleLibDir}/javafx.platform.properties&quot;)
4932                     javafxPlatformProperties.delete()
4933                     javafxPlatformProperties &lt;&lt; targetProperties.javafxPlatformProperties
4934                     javafxPlatformProperties &lt;&lt; &quot;\n&quot;
4935                 }
4936             }
4937         }
4938 
4939         def buildModuleGraphicsTask = task(&quot;buildModuleGraphics$t.capital&quot;, type: Copy, dependsOn: graphicsProject.assemble) {
4940             group = &quot;Basic&quot;
4941             description = &quot;copies javafx.graphics native libraries&quot;
4942 
4943             into &quot;${graphicsProject.buildDir}/${moduleNativeDirName}&quot;
4944 
4945             from(&quot;${graphicsProject.buildDir}/libs/jsl-decora/${t.name}/${library(targetProperties.decora.lib)}&quot;)
4946             def libs = [&#39;font&#39;, &#39;prism&#39;, &#39;prismSW&#39;, &#39;glass&#39;, &#39;iio&#39;]
4947             if (IS_INCLUDE_ES2) {
4948                 libs += [&#39;prismES2&#39;];
4949             }
4950             if (IS_COMPILE_PANGO) {
4951                 libs += [&#39;fontFreetype&#39;, &#39;fontPango&#39;];
4952             }
4953             libs.each { lib -&gt;
4954                 def variants = targetProperties[lib].containsKey(&#39;variants&#39;) &amp;&amp; !useLipo ? targetProperties[lib].variants : [null]
4955                 variants.each { variant -&gt;
4956                     def variantProperties = variant ? targetProperties[lib][variant] : targetProperties[lib]
4957                     from (&quot;${graphicsProject.buildDir}/libs/$lib/$t.name/${library(variantProperties.lib)}&quot;)
4958                 }
4959             }
4960             if (IS_WINDOWS) {
4961                 from (&quot;${graphicsProject.buildDir}/libs/prismD3D/${t.name}/${library(targetProperties.prismD3D.lib)}&quot;);
4962                 targetProperties.VS2017DLLs.each { vslib -&gt;
4963                     from (&quot;$vslib&quot;);
4964                 }
4965                 targetProperties.WinSDKDLLs.each { winsdklib -&gt;
4966                     from (&quot;$winsdklib&quot;);
4967                 }
4968             }
4969         }
4970 
4971         def buildModuleMediaTask = task(&quot;buildModuleMedia$t.capital&quot;, type: Copy, dependsOn: [mediaProject.assemble, prepOpenJfxStubs]) {
4972             group = &quot;Basic&quot;
4973             description = &quot;copies javafx.media native libraries&quot;
4974 
4975             into &quot;${mediaProject.buildDir}/${moduleNativeDirName}&quot;
4976 
4977             def mediaBuildType = project(&quot;:media&quot;).ext.buildType
4978             if (IS_COMPILE_MEDIA) {
4979                 [ &quot;fxplugins&quot;, &quot;gstreamer-lite&quot;, &quot;jfxmedia&quot; ].each { name -&gt;
4980                     from (&quot;${mediaProject.buildDir}/native/${t.name}/${mediaBuildType}/${library(name)}&quot;) }
4981 
4982                 if (t.name == &quot;mac&quot;) {
4983                     // OSX media natives
4984                     [ &quot;jfxmedia_qtkit&quot;, &quot;jfxmedia_avf&quot;, &quot;glib-lite&quot; ].each { name -&gt;
4985                         from (&quot;${mediaProject.buildDir}/native/${t.name}/${mediaBuildType}/${library(name)}&quot;) }
4986                 } else if (t.name == &quot;linux&quot;) {
4987                     from(&quot;${mediaProject.buildDir}/native/${t.name}/${mediaBuildType}&quot;) { include &quot;libavplugin*.so&quot; }
4988                 } else from (&quot;${mediaProject.buildDir}/native/${t.name}/${mediaBuildType}/${library(&quot;glib-lite&quot;)}&quot;)
4989             } else {
4990                 if (t.name != &quot;android&quot;  &amp;&amp; t.name != &quot;dalvik&quot; ) {
4991                     [ &quot;fxplugins&quot;, &quot;gstreamer-lite&quot;, &quot;jfxmedia&quot; ].each { name -&gt;
4992                         from (&quot;$MEDIA_STUB/${library(name)}&quot;) }
4993                 }
4994 
4995                 if (t.name == &quot;mac&quot;) {
4996                     // copy libjfxmedia_{avf,qtkit}.dylib if they exist
4997                     [ &quot;jfxmedia_qtkit&quot;, &quot;jfxmedia_avf&quot;, &quot;glib-lite&quot; ].each { name -&gt;
4998                         from (&quot;$MEDIA_STUB/${library(name)}&quot;) }
4999                 } else if (t.name == &quot;linux&quot;) {
5000                     from(MEDIA_STUB) { include &quot;libavplugin*.so&quot; }
5001                 }
5002                 else if (t.name != &quot;android&quot;  &amp;&amp; t.name != &quot;dalvik&quot; ) {
5003                     from (&quot;$MEDIA_STUB/${library(&quot;glib-lite&quot;)}&quot;)
5004                 }
5005             }
5006         }
5007 
5008         def buildModuleWeb = task(&quot;buildModuleWeb$t.capital&quot;, type: Copy, dependsOn: [webProject.assemble, prepOpenJfxStubs]) {
5009             group = &quot;Basic&quot;
5010             description = &quot;copies javafx.web native libraries&quot;
5011 
5012             into &quot;${webProject.buildDir}/${moduleNativeDirName}&quot;
5013 
5014             if (IS_COMPILE_WEBKIT) {
5015                 from (&quot;${webProject.buildDir}/libs/${t.name}/${library(&#39;jfxwebkit&#39;)}&quot;)
5016             } else {
5017                 if (t.name != &quot;android&quot; &amp;&amp; t.name != &quot;ios&quot; &amp;&amp; t.name != &quot;dalvik&quot;) {
5018                     from (&quot;$WEB_STUB/${library(&#39;jfxwebkit&#39;)}&quot;)
5019                 }
5020             }
5021         }
5022 
5023         def buildModuleSWT = task(&quot;buildModuleSWT$t.capital&quot;, type: Copy) {
5024             group = &quot;Basic&quot;
5025             description = &quot;copies SWT JAR&quot;
5026 
5027             // FIXME: the following is a hack to workaround the fact that there
5028             // is no way to deliver javafx-swt.jar other than in one of the
5029             // existing runtime modules.
5030 
5031             dependsOn(buildModuleGraphicsTask) // we copy to the graphics module
5032 
5033             if (COMPILE_SWT) {
5034                 def javafxSwtIndexTask = tasks.getByName(&quot;javafxSwtIndex${t.capital}&quot;);
5035                 dependsOn(javafxSwtIndexTask)
5036                 //enabled = COMPILE_SWT
5037             }
5038 
5039             // Copy javafx-swt.jar to the javafx-graphics module lib dir
5040             from &quot;${swtProject.buildDir}/libs/javafx-swt.jar&quot;
5041             into &quot;${graphicsProject.buildDir}/${platformPrefix}module-lib&quot;
5042         }
5043 
5044         dependsOn(
5045             buildModuleBaseTask,
5046             buildModuleGraphicsTask,
5047             buildModuleMediaTask,
5048             buildModuleWeb,
5049             buildModuleSWT,
5050             )
5051     }
5052     buildModulesTask.dependsOn(buildModuleLibsTask)
5053 
5054     def zipTask = project.task(&quot;buildModuleZip$t.capital&quot;, type: Zip, group: &quot;Build&quot;,
5055             dependsOn: buildModulesTask ) {
5056 
5057         // FIXME: JIGSAW -- this should be moved to a sub-directory so we can keep the same name
5058         def jfxBundle = &quot;${platformPrefix}javafx-exports.zip&quot;
5059 
5060         doFirst() {
5061             file(&quot;${rootProject.buildDir}/${jfxBundle}&quot;).delete()
5062         }
5063 
5064         archiveName = jfxBundle
5065         destinationDir = file(&quot;${rootProject.buildDir}&quot;)
5066         includeEmptyDirs = false
5067         from &quot;${bundledSdkDir}&quot;
5068     }
5069     jdkZip.dependsOn(zipTask)
5070 
5071     Task testArgFiles = task(&quot;createTestArgfiles${t.capital}&quot;) {
5072 
5073         File testRunArgsFile = new File(rootProject.buildDir, TESTRUNARGSFILE)
5074         //test (shimed) version
5075         File testCompileArgsFile = new File(rootProject.buildDir, TESTCOMPILEARGSFILE)
5076         // And a test java.policy file
5077         File testJavaPolicyFile = new File(rootProject.buildDir, TESTJAVAPOLICYFILE)
5078         // and the non-test version to go with run.args
5079         File runJavaPolicyFile = new File(rootProject.buildDir, RUNJAVAPOLICYFILE);
5080 
5081         outputs.file(testRunArgsFile)
5082         outputs.file(testCompileArgsFile)
5083         outputs.file(testJavaPolicyFile)
5084         outputs.file(runJavaPolicyFile)
5085         inputs.file(EXTRAADDEXPORTS);
5086 
5087         doLast() {
5088             rootProject.buildDir.mkdir()
5089 
5090             List&lt;String&gt; projNames = []
5091             moduleProjList.each { project -&gt;
5092                 projNames &lt;&lt; project.name
5093             }
5094 
5095             // And the test (shimed) variation...
5096 
5097             testRunArgsFile.delete()
5098             testCompileArgsFile.delete()
5099 
5100             testJavaPolicyFile.delete()
5101             runJavaPolicyFile.delete()
5102 
5103             List&lt;String&gt; modpath = []
5104 
5105             if (HAS_JAVAFX_MODULES) {
5106                 moduleProjList.each { project -&gt;
5107                     if (project.hasProperty(&quot;moduleName&quot;) &amp;&amp; project.buildModule) {
5108                         File dir;
5109                         if (project.sourceSets.hasProperty(&#39;shims&#39;)) {
5110                            dir = new File(rootProject.buildDir, &quot;shims/${project.ext.moduleName}&quot;)
5111                         } else {
5112                            dir = new File(rootProject.buildDir, &quot;modular-sdk/modules/${project.ext.moduleName}&quot;)
5113                         }
5114 
5115                         def dstModuleDir = cygpath(dir.path)
5116                         modpath &lt;&lt; &quot;${project.ext.moduleName}=${dstModuleDir}&quot;
5117 
5118                         String themod = dir.toURI()
5119                         testJavaPolicyFile &lt;&lt;  &quot;grant codeBase \&quot;${themod}\&quot; {\n&quot; +
5120                         &quot;    permission java.security.AllPermission;\n&quot; +
5121                         &quot;};\n&quot;
5122 
5123                         dir = new File(rootProject.buildDir, &quot;modular-sdk/modules/${project.ext.moduleName}&quot;)
5124                         themod = dir.toURI()
5125                         runJavaPolicyFile &lt;&lt;  &quot;grant codeBase \&quot;${themod}\&quot; {\n&quot; +
5126                         &quot;    permission java.security.AllPermission;\n&quot; +
5127                         &quot;};\n&quot;
5128                     }
5129                 }
5130 
5131                 writeRunArgsFile(testCompileArgsFile, null, modpath, null)
5132                 writeRunArgsFile(testRunArgsFile, computeLibraryPath(true), modpath, null)
5133 
5134                 if (rootProject.hasProperty(&quot;EXTRA_ADDEXPORTS_STRING&quot;)) {
5135                     testCompileArgsFile &lt;&lt; EXTRA_ADDEXPORTS_STRING
5136                     testRunArgsFile &lt;&lt; EXTRA_ADDEXPORTS_STRING
5137                 }
5138             } else  {
5139                 def modnames = []
5140                 moduleProjList.each { project -&gt;
5141                     if (project.hasProperty(&quot;moduleName&quot;) &amp;&amp; project.buildModule) {
5142                         modnames &lt;&lt; project.ext.moduleName
5143                         File dir;
5144                         if (project.sourceSets.hasProperty(&#39;shims&#39;)) {
5145                            dir = new File(rootProject.buildDir, &quot;shims/${project.ext.moduleName}&quot;)
5146                         } else {
5147                            dir = new File(rootProject.buildDir, &quot;sdk/lib/${project.ext.moduleName}.jar&quot;)
5148                         }
5149 
5150                         def dstModuleDir = cygpath(dir.path)
5151                         modpath &lt;&lt; &quot;${dstModuleDir}&quot;
5152 
5153                         String themod = dir.toURI()
5154                         testJavaPolicyFile &lt;&lt;  &quot;grant codeBase \&quot;${themod}\&quot; {\n&quot; +
5155                         &quot;    permission java.security.AllPermission;\n&quot; +
5156                         &quot;};\n&quot;
5157 
5158                         dir = new File(rootProject.buildDir, &quot;sdk/lib/${project.ext.moduleName}.jar&quot;)
5159                         themod = dir.toURI()
5160                         runJavaPolicyFile &lt;&lt;  &quot;grant codeBase \&quot;${themod}\&quot; {\n&quot; +
5161                         &quot;    permission java.security.AllPermission;\n&quot; +
5162                         &quot;};\n&quot;
5163                     }
5164                 }
5165 
5166                 writeRunArgsFile(testCompileArgsFile, null, modpath, modnames)
5167                 writeRunArgsFile(testRunArgsFile, computeLibraryPath(true), modpath, modnames)
5168 
5169             }
5170         }
5171     }
5172     sdk.dependsOn(testArgFiles)
5173     createTestArgfiles.dependsOn(testArgFiles)
5174 
5175     def sdkTask = tasks.getByName(&quot;sdk${t.capital}&quot;);
5176     sdkTask.dependsOn(buildModulesTask)
5177 }
5178 sdk.dependsOn(buildModules)
5179 
5180 // Build the jmod for each module for the standalone SDK only.
5181 compileTargets { t -&gt;
5182     if (!HAS_JAVAFX_MODULES) {
5183         def targetProperties = project.ext[t.upper]
5184 
5185         def platformPrefix = targetProperties.platformPrefix
5186         def jmodsDirName = &quot;${platformPrefix}jmods&quot;
5187         def jmodsDir = &quot;${rootProject.buildDir}/${jmodsDirName}&quot;
5188         def standaloneSdkDirName = &quot;${platformPrefix}sdk&quot;
5189         def standaloneSdkDir = &quot;${rootProject.buildDir}/${standaloneSdkDirName}&quot;
5190         def standaloneLegalDir = &quot;${standaloneSdkDir}/legal&quot;
5191 
5192         def excludeNativeLibs = []
5193         if (IS_WINDOWS) {
5194             // List of duplicate Microsoft DLLs to exclude
5195             excludeNativeLibs += targetProperties.VS2017DLLNames
5196             excludeNativeLibs += targetProperties.WinSDKDLLNames
5197         }
5198 
5199         moduleProjList.each { project -&gt;
5200             def moduleName = project.ext.moduleName
5201             def buildDir = project.buildDir
5202 
5203             def srcClassesDir = &quot;${buildDir}/${platformPrefix}module-classes&quot;
5204             def srcLibDir = &quot;${buildDir}/${platformPrefix}module-lib&quot;
5205             def srcLegalDir = &quot;${standaloneLegalDir}/${moduleName}&quot;
5206 
5207             def jmodName = &quot;${moduleName}.jmod&quot;
5208             def jmodFile = &quot;${jmodsDir}/${jmodName}&quot;
5209             def jmodTask = project.task(&quot;jmod$t.capital&quot;, group: &quot;Build&quot;, dependsOn: sdk) {
5210                 doLast {
5211                     mkdir jmodsDir
5212                     delete(jmodFile);
5213                     exec {
5214                         commandLine(JMOD)
5215                         args(&quot;create&quot;)
5216                         args(&quot;--class-path&quot;)
5217                         args(srcClassesDir)
5218                         // Not all modules have a &quot;lib&quot; dir
5219                         if (file(srcLibDir).isDirectory()) {
5220                             args(&quot;--libs&quot;)
5221                             args(srcLibDir)
5222                         }
5223                         // Exclude duplicate native libs from javafx.graphics.jmod
5224                         if (moduleName == &quot;javafx.graphics&quot;) {
5225                             excludeNativeLibs.each { name -&gt;
5226                                 args(&quot;--exclude&quot;)
5227                                 args(name)
5228                             }
5229                         }
5230                         args(&quot;--legal-notices&quot;)
5231                         args(srcLegalDir)
5232                         args(jmodFile)
5233                     }
5234                 }
5235             }
5236 
5237             jmods.dependsOn(jmodTask)
5238         }
5239     }
5240 }
5241 
5242 /******************************************************************************
5243  *                                                                            *
5244  *                              BUILD_CLOSED                                  *
5245  *                                                                            *
5246  * This next section should remain at the end of the build script. It allows  *
5247  * for a &quot;supplemental&quot; gradle file to be used to extend the normal build     *
5248  * structure. For example, this is used for passing a supplemental gradle     *
5249  * file for producing official JavaFX builds.                                 *
5250  *                                                                            *
5251  *****************************************************************************/
5252 
5253 if (BUILD_CLOSED) {
5254     apply from: supplementalBuildFile
5255 }
5256 
5257 task showFlags {
5258 }
5259 
5260 compileTargets { t -&gt;
5261     // Every platform must define these variables
5262     def props = project.ext[t.upper];
5263     showFlags.dependsOn(
5264         project.task(&quot;showFlags$t.upper&quot;) {
5265             doLast() {
5266                 println &quot;Properties set for $t.upper&quot;
5267                 props.each { println it }
5268             }
5269         }
5270     )
5271 
5272 }
    </pre>
  </body>
</html>
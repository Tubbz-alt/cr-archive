diff a/src/org/openjdk/asmtools/jasm/Parser.java b/src/org/openjdk/asmtools/jasm/Parser.java
--- a/src/org/openjdk/asmtools/jasm/Parser.java
+++ b/src/org/openjdk/asmtools/jasm/Parser.java
@@ -330,11 +330,11 @@
 
             case ARRAY_TYPEPATH:
             case INNER_TYPE_TYPEPATH:
             case WILDCARD_TYPEPATH:
             case TYPE_ARGUMENT_TYPEPATH:
-            case PERMITTEDSUBTYPES:
+            case PERMITTEDSUBCLASSES:
             case INF:
             case NAN:
             case COMPONENT:
 
             case SYNTHETIC:
@@ -365,22 +365,22 @@
     ConstCell parseMethodHandle(SubTag subtag) throws Scanner.SyntaxError, IOException {
         ConstCell refCell;
         switch (subtag) {
             // If the value of the reference_kind item is
             // 1 (REF_getField), 2 (REF_getStatic), 3 (REF_putField)  or 4 (REF_putStatic),
-            // then the constant_pool entry at that index must be a CONSTANT_Fieldref_info structure (ยง4.4.2)
+            // then the constant_pool entry at that index must be a CONSTANT_Fieldref_info structure (4.4.2)
             // representing a field for which a method handle is to be created. jvms-4.4.8-200-C-A
             case REF_GETFIELD:
             case REF_GETSTATIC:
             case REF_PUTFIELD:
             case REF_PUTSTATIC:
                 refCell = pool.FindCell(cpParser.parseConstValue(ConstType.CONSTANT_FIELD));
                 break;
             //  If the value of the reference_kind item is
             //  5 (REF_invokeVirtual) or 8 (REF_newInvokeSpecial),
-            //  then the constant_pool entry at that index must be a CONSTANT_Methodref_info structure (ยง4.4.2)
-            //  representing a class's method or constructor (ยง2.9.1) for which a method handle is to be created.
+            //  then the constant_pool entry at that index must be a CONSTANT_Methodref_info structure (4.4.2)
+            //  representing a class's method or constructor (2.9.1) for which a method handle is to be created.
             //  jvms-4.4.8-200-C-B
             case REF_INVOKEVIRTUAL:
             case REF_NEWINVOKESPECIAL:
                 refCell = pool.FindCell(cpParser.parseConstValue(ConstType.CONSTANT_METHOD));
                 break;
@@ -393,11 +393,11 @@
                 // The constant_pool entry at that index must be as follows:
                 // If the value of the reference_kind item is 6 (REF_invokeStatic) or 7 (REF_invokeSpecial),
                 // then if the class file version number is less than 52.0, the constant_pool entry at that index must be
                 // a CONSTANT_Methodref_info structure representing a class's method for which a method handle is to be created;
                 // if the class file version number is 52.0 or above, the constant_pool entry at that index must be
-                // either a CONSTANT_Methodref_info structure or a CONSTANT_InterfaceMethodref_info structure (ยง4.4.2)
+                // either a CONSTANT_Methodref_info structure or a CONSTANT_InterfaceMethodref_info structure (4.4.2)
                 // representing a class's or interface's method for which a method handle is to be created.
                 ConstType ctype01 = ConstType.CONSTANT_METHOD;
                 ConstType ctype02 = ConstType.CONSTANT_INTERFACEMETHOD;
                 if (this.cd.cfv.major_version() >= 52 && Modifiers.isInterface(this.cd.access)) {
                     ctype01 = ConstType.CONSTANT_INTERFACEMETHOD;
@@ -464,11 +464,11 @@
 
             case ARRAY_TYPEPATH:
             case INNER_TYPE_TYPEPATH:
             case WILDCARD_TYPEPATH:
             case TYPE_ARGUMENT_TYPEPATH:
-            case PERMITTEDSUBTYPES:
+            case PERMITTEDSUBCLASSES:
             case INF:
             case NAN:
             case COMPONENT:
 
             case SYNTHETIC:
@@ -963,17 +963,17 @@
         scanner.expect(SEMICOLON);
         cd.addNestHost(hostClass);
     }
 
     /**
-     * Parse a list of classes belonging to the [NestMembers | PermittedSubtypes]  entry
+     * Parse a list of classes belonging to the [NestMembers | PermittedSubclasses]  entry
      */
     private void parseClasses(Consumer<ArrayList<ConstCell>> classesConsumer)
             throws Scanner.SyntaxError, IOException {
         ArrayList<ConstCell> classes = new ArrayList<>();
         // Parses in the form:
-        // (NESTMEMBERS|PERMITTEDSUBTYPES)? IDENT(, IDENT)*;
+        // (NESTMEMBERS|PERMITTEDSUBCLASSES)? IDENT(, IDENT)*;
         debugStr("  [Parser.parseClasses]: <<<Begin>>>");
         while (true) {
             String className = prependPackage(parseIdent(), true);
             classes.add(pool.FindCellClassByName(className));
             debugScan("  [Parser.parseClasses]: class " + className);
@@ -1755,17 +1755,17 @@
                         throw new Scanner.SyntaxError();
                     }
                     scanner.scan();
                     parseClasses(list -> cd.addNestMembers(list));
                     break;
-                case PERMITTEDSUBTYPES:         // JEP 360
+                case PERMITTEDSUBCLASSES:         // JEP 360
                     if (cd.nestMembersAttributesExist()) {
-                        env.error(scanner.pos, "extra.permittedsubtypes.attribute");
+                        env.error(scanner.pos, "extra.permittedsubclasses.attribute");
                         throw new Scanner.SyntaxError();
                     }
                     scanner.scan();
-                    parseClasses(list -> cd.addPermittedSubtypes(list));
+                    parseClasses(list -> cd.addPermittedSubclasses(list));
                     break;
                 case RECORD:                    // JEP 359
                     if (cd.recordAttributeExists()) {
                         env.error(scanner.pos, "extra.record.attribute");
                         throw new Scanner.SyntaxError();

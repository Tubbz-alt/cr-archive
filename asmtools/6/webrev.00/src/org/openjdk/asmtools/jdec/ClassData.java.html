<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/org/openjdk/asmtools/jdec/ClassData.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 package org.openjdk.asmtools.jdec;
  24 
  25 import org.openjdk.asmtools.common.Module;
  26 import org.openjdk.asmtools.asmutils.StringUtils;
  27 import org.openjdk.asmtools.jasm.Modifiers;
  28 import org.openjdk.asmtools.jcoder.JcodTokens;
  29 import org.openjdk.asmtools.util.I18NResourceBundle;
  30 
  31 import java.awt.event.KeyEvent;
  32 import java.io.DataInputStream;
  33 import java.io.EOFException;
  34 import java.io.IOException;
  35 import java.io.PrintWriter;
  36 
  37 import static java.lang.String.format;
  38 import static org.openjdk.asmtools.jasm.Tables.*;
  39 import static org.openjdk.asmtools.jasm.Tables.AnnotElemType.AE_UNKNOWN;
  40 import static org.openjdk.asmtools.jasm.TypeAnnotationTypes.*;
  41 
  42 /**
  43  * Class data of the Java Decoder
  44  */
  45 class ClassData {
  46 
  47     private byte[] types;
  48     private Object[] cpool;
  49     private int CPlen;
  50     private NestedByteArrayInputStream countedin;
  51     private DataInputStream in;
  52     private PrintWriter out;
  53     private int[] cpe_pos;
  54     private boolean printDetails;
  55     private String entityType = &quot;&quot;;
  56     private String entityName = &quot;&quot;;
  57 
  58     public static I18NResourceBundle i18n
  59             = I18NResourceBundle.getBundleForClass(Main.class);
  60 
  61     ClassData(DataInputStream dis, int printFlags, PrintWriter out) throws IOException {
  62         byte[] buf = new byte[dis.available()];
  63         try {
  64             if (dis.read(buf) &lt;= 0)
  65                 throw new IOException(&quot;The file is empty&quot;);
  66         } finally {
  67             dis.close();
  68         }
  69         countedin = new NestedByteArrayInputStream(buf);
  70         in = new DataInputStream(countedin);
  71         this.out = out;
  72         printDetails = ((printFlags &amp; 1) == 1);
  73     }
  74 
  75     /*========================================================*/
  76     private static final char[] hexTable = {
  77             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;,
  78             &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;
  79     };
  80 
  81     private String toHex(long val, int width) {
  82         StringBuilder s = new StringBuilder();
  83         for (int i = width * 2 - 1; i &gt;= 0; i--) {
  84             s.append(hexTable[((int) (val &gt;&gt; (4 * i))) &amp; 0xF]);
  85         }
  86         return &quot;0x&quot; + s.toString();
  87     }
  88 
  89     private String toHex(long val) {
  90         int width;
  91         for (width = 8; width &gt; 0; width--) {
  92             if ((val &gt;&gt; (width - 1) * 8) != 0) {
  93                 break;
  94             }
  95         }
  96         return toHex(val, width);
  97     }
  98 
  99     private void printByteHex(PrintWriter out, int b) {
 100         out.print(hexTable[(b &gt;&gt; 4) &amp; 0xF]);
 101         out.print(hexTable[b &amp; 0xF]);
 102     }
 103 
 104     private void printBytes(PrintWriter out, DataInputStream in, int len)
 105             throws IOException {
 106         try {
 107             for (int i = 0; i &lt; len; i++) {
 108                 if (i % 8 == 0) {
 109                     out_print(&quot;0x&quot;);
 110                 }
 111                 printByteHex(out, in.readByte());
 112                 if (i % 8 == 7) {
 113                     out.println(&quot;;&quot;);
 114                 }
 115             }
 116         } finally {
 117             if (len % 8 != 0) {
 118                 out.println(&quot;;&quot;);
 119             }
 120         }
 121     }
 122 
 123     private void printRestOfBytes() {
 124         for (int i = 0; ; i++) {
 125             try {
 126                 byte b = in.readByte();
 127                 if (i % 8 == 0) {
 128                     out_print(&quot;0x&quot;);
 129                 }
 130                 printByteHex(out, b);
 131                 if (i % 8 == 7) {
 132                     out.print(&quot;;\n&quot;);
 133                 }
 134             } catch (IOException e) {
 135                 return;
 136             }
 137         }
 138     }
 139 
 140     private void printUtf8InfoIndex(int index, String indexName) {
 141         String name = (String) cpool[index];
 142         out_print(&quot;#&quot; + index + &quot;; // &quot;);
 143         if (printDetails) {
 144             out.println(String.format(&quot;%-16s&quot;,indexName) + &quot; : &quot; + name);
 145         } else {
 146             out.println(indexName);
 147         }
 148     }
 149 
 150     /*========================================================*/
 151     private int shift = 0;
 152 
 153     private void out_begin(String s) {
 154         for (int i = 0; i &lt; shift; i++) {
 155             out.print(&quot;  &quot;);
 156         }
 157         out.println(s);
 158         shift++;
 159     }
 160 
 161     private void out_print(String s) {
 162         for (int i = 0; i &lt; shift; i++) {
 163             out.print(&quot;  &quot;);
 164         }
 165         out.print(s);
 166     }
 167 
 168     private void out_println(String s) {
 169         for (int i = 0; i &lt; shift; i++) {
 170             out.print(&quot;  &quot;);
 171         }
 172         out.println(s);
 173     }
 174 
 175     private void out_end(String s) {
 176         shift--;
 177         for (int i = 0; i &lt; shift; i++) {
 178             out.print(&quot;  &quot;);
 179         }
 180         out.println(s);
 181     }
 182 
 183     private String startArray(int length) {
 184         return &quot;[&quot; + (printDetails ? Integer.toString(length) : &quot;&quot;) + &quot;]&quot;;
 185     }
 186 
 187     private void startArrayCmt(int length, String comment) {
 188         out_begin(startArray(length) + format(&quot; {%s&quot;, comment == null ? &quot;&quot; : &quot; // &quot; + comment));
 189     }
 190 
 191     private void startArrayCmtB(int length, String comment) {
 192         out_begin(startArray(length) + format(&quot;b {%s&quot;, comment == null ? &quot;&quot; : &quot; // &quot; + comment));
 193     }
 194 
 195     /*========================================================*/
 196     private void readCP(DataInputStream in) throws IOException {
 197         int length = in.readUnsignedShort();
 198         CPlen = length;
 199         traceln(i18n.getString(&quot;jdec.trace.CP_len&quot;, length));
 200         types = new byte[length];
 201         cpool = new Object[length];
 202         cpe_pos = new int[length];
 203         for (int i = 1; i &lt; length; i++) {
 204             byte btag;
 205             int v1;
 206             long lv;
 207             cpe_pos[i] = countedin.getPos();
 208             btag = in.readByte();
 209             traceln(i18n.getString(&quot;jdec.trace.CP_entry&quot;, i, btag));
 210             types[i] = btag;
 211             ConstType tg = tag(btag);
 212             switch (tg) {
 213                 case CONSTANT_UTF8:
 214                     cpool[i] = in.readUTF();
 215                     break;
 216                 case CONSTANT_INTEGER:
 217                     v1 = in.readInt();
 218                     cpool[i] = v1;
 219                     break;
 220                 case CONSTANT_FLOAT:
 221                     v1 = Float.floatToIntBits(in.readFloat());
 222                     cpool[i] = v1;
 223                     break;
 224                 case CONSTANT_LONG:
 225                     lv = in.readLong();
 226                     cpool[i] = lv;
 227                     i++;
 228                     break;
 229                 case CONSTANT_DOUBLE:
 230                     lv = Double.doubleToLongBits(in.readDouble());
 231                     cpool[i] = lv;
 232                     i++;
 233                     break;
 234                 case CONSTANT_CLASS:
 235                 case CONSTANT_STRING:
 236                 case CONSTANT_MODULE:
 237                 case CONSTANT_PACKAGE:
 238                     v1 = in.readUnsignedShort();
 239                     cpool[i] = v1;
 240                     break;
 241                 case CONSTANT_INTERFACEMETHOD:
 242                 case CONSTANT_FIELD:
 243                 case CONSTANT_METHOD:
 244                 case CONSTANT_NAMEANDTYPE:
 245                     cpool[i] = &quot;#&quot; + in.readUnsignedShort() + &quot; #&quot; + in.readUnsignedShort();
 246                     break;
 247                 case CONSTANT_DYNAMIC:
 248                 case CONSTANT_INVOKEDYNAMIC:
 249                     cpool[i] = in.readUnsignedShort() + &quot;s #&quot; + in.readUnsignedShort();
 250                     break;
 251                 case CONSTANT_METHODHANDLE:
 252                     cpool[i] = in.readUnsignedByte() + &quot;b #&quot; + in.readUnsignedShort();
 253                     break;
 254                 case CONSTANT_METHODTYPE:
 255                     cpool[i] = &quot;#&quot; + in.readUnsignedShort();
 256                     break;
 257                 default:
 258                     CPlen = i;
 259                     printCP(out);
 260                     out_println(toHex(btag, 1) + &quot;; // invalid constant type: &quot; + (int) btag + &quot; for element &quot; + i);
 261                     throw new ClassFormatError();
 262             }
 263         }
 264     }
 265 
 266     private void printCP(PrintWriter out) {
 267         int length = CPlen;
 268         startArrayCmt(length, &quot;Constant Pool&quot;);
 269         out_println(&quot;; // first element is empty&quot;);
 270         try {
 271             int size;
 272             for (int i = 1; i &lt; length; i = i + size) {
 273                 size = 1;
 274                 byte btag = types[i];
 275                 ConstType tg = tag(btag);
 276                 int pos = cpe_pos[i];
 277                 String tagstr;
 278                 String valstr;
 279                 int v1;
 280                 long lv;
 281                 if (tg != null) {
 282                     tagstr = tg.parseKey();
 283                 } else {
 284                     throw new Error(&quot;Can&#39;t get a tg representing the type of Constant in the Constant Pool at: &quot; + i);
 285                 }
 286                 switch (tg) {
 287                     case CONSTANT_UTF8: {
 288                         tagstr = &quot;Utf8&quot;;
 289                         valstr = StringUtils.Utf8ToString((String) cpool[i]);
 290                     }
 291                     break;
 292                     case CONSTANT_FLOAT:
 293                     case CONSTANT_INTEGER:
 294                         v1 = (Integer) cpool[i];
 295                         valstr = toHex(v1, 4);
 296                         break;
 297                     case CONSTANT_DOUBLE:
 298                     case CONSTANT_LONG:
 299                         lv = (Long) cpool[i];
 300                         valstr = toHex(lv, 8) + &quot;;&quot;;
 301                         size = 2;
 302                         break;
 303                     case CONSTANT_CLASS:
 304                     case CONSTANT_MODULE:
 305                     case CONSTANT_PACKAGE:
 306                     case CONSTANT_STRING:
 307                         v1 = (Integer) cpool[i];
 308                         valstr = &quot;#&quot; + v1;
 309                         break;
 310                     case CONSTANT_INTERFACEMETHOD:
 311                     case CONSTANT_FIELD:
 312                     case CONSTANT_METHOD:
 313                     case CONSTANT_NAMEANDTYPE:
 314                     case CONSTANT_METHODHANDLE:
 315                     case CONSTANT_METHODTYPE:
 316                     case CONSTANT_DYNAMIC:
 317                     case CONSTANT_INVOKEDYNAMIC:
 318                         valstr = (String) cpool[i];
 319                         break;
 320                     default:
 321                         throw new Error(&quot;invalid constant type: &quot; + (int) btag);
 322                 }
 323                 out_print(tagstr + &quot; &quot; + valstr + &quot;; // #&quot; + i);
 324                 if (printDetails) {
 325                     out_println(&quot; at &quot; + toHex(pos));
 326                 } else {
 327                     out.println();
 328                 }
 329             }
 330         } finally {
 331             out_end(&quot;} // Constant Pool&quot;);
 332             out.println();
 333         }
 334     }
 335 
 336     private String getStringPos() {
 337         return &quot; at &quot; + toHex(countedin.getPos());
 338     }
 339 
 340     private String getCommentPosCond() {
 341         if (printDetails) {
 342             return &quot; // &quot; + getStringPos();
 343         } else {
 344             return &quot;&quot;;
 345         }
 346     }
 347 
 348     private void decodeCPXAttr(DataInputStream in, int len, String attrname, PrintWriter out) throws IOException {
 349         decodeCPXAttrM(in, len, attrname, out, 1);
 350     }
 351 
 352     private void decodeCPXAttrM(DataInputStream in, int len, String attrname, PrintWriter out, int expectedIndices) throws IOException {
 353         if (len != expectedIndices * 2) {
 354             out_println(&quot;// invalid length of &quot; + attrname + &quot; attr: &quot; + len + &quot; (should be &quot; + (expectedIndices * 2) + &quot;) &gt; &quot;);
 355             printBytes(out, in, len);
 356         } else {
 357             StringBuilder outputString = new StringBuilder();
 358             for (int k = 1; k &lt;= expectedIndices; k++) {
 359                 outputString.append(&quot;#&quot;).append(in.readUnsignedShort()).append(&quot;; &quot;);
 360                 if (k % 16 == 0) {
 361                     out_println(outputString.toString().replaceAll(&quot;\\s+$&quot;,&quot;&quot;));
 362                     outputString = new StringBuilder();
 363                 }
 364             }
 365             if (outputString.length() &gt; 0) {
 366                 out_println(outputString.toString().replaceAll(&quot;\\s+$&quot;,&quot;&quot;));
 367             }
 368         }
 369     }
 370 
 371     private void printStackMap(DataInputStream in, int elementsNum) throws IOException {
 372         int num;
 373         if (elementsNum &gt; 0) {
 374             num = elementsNum;
 375         } else {
 376             num = in.readUnsignedShort();
 377         }
 378         out.print(startArray(num) + (elementsNum &gt; 0 ? &quot;z&quot; : &quot;&quot;) + &quot;{&quot;);
 379         try {
 380             for (int k = 0; k &lt; num; k++) {
 381                 int maptype = in.readUnsignedByte();
 382                 StackMapType mptyp = stackMapType(maptype, out);
 383                 String maptypeImg;
 384                 if (printDetails) {
 385                     maptypeImg = maptype + &quot;b&quot;;
 386                 } else {
 387                     try {
 388                         maptypeImg = mptyp.parsekey();
 389                     } catch (ArrayIndexOutOfBoundsException e) {
 390                         maptypeImg = &quot;/* BAD TYPE: */ &quot; + maptype + &quot;b&quot;;
 391                     }
 392                 }
 393                 switch (mptyp) {
 394                     case ITEM_Object:
 395                     case ITEM_NewObject:
 396                         maptypeImg = maptypeImg + &quot;,&quot; + in.readUnsignedShort();
 397                         break;
 398                     case ITEM_UNKNOWN:
 399                         maptypeImg = maptype + &quot;b&quot;;
 400                         break;
 401                     default:
 402                 }
 403                 out.print(maptypeImg);
 404                 if (k &lt; num - 1) {
 405                     out.print(&quot;; &quot;);
 406                 }
 407             }
 408         } finally {
 409             out.print(&quot;}&quot;);
 410         }
 411     }
 412 
 413     /**
 414      * Processes 4.7.20 The RuntimeVisibleTypeAnnotations Attribute, 4.7.21 The RuntimeInvisibleTypeAnnotations Attribute
 415      * &lt;code&gt;type_annotation&lt;/code&gt; structure.
 416      */
 417     private void decodeTargetTypeAndRefInfo(DataInputStream in) throws IOException {
 418         int tt = in.readUnsignedByte(); // [4.7.20] annotations[], type_annotation { u1 target_type; ...}
 419         ETargetType targetType = ETargetType.getTargetType(tt);
 420         if( targetType == null ) {
 421             throw new Error(&quot;Type annotation: invalid target_type(u1) &quot; + tt);
 422         }
 423         ETargetInfo targetInfo = targetType.targetInfo();
 424         out_println(toHex(tt, 1) + &quot;;  //  target_type: &quot; + targetType.parseKey());
 425         switch (targetInfo) {
 426             case TYPEPARAM:          //[3.3.1] meth_type_param, class_type_param:
 427                 out_println(toHex(in.readUnsignedByte(), 1) + &quot;;  //  param_index&quot;);
 428                 break;
 429             case SUPERTYPE:         //[3.3.2]  class_exts_impls
 430                 out_println(toHex(in.readUnsignedShort(), 2) + &quot;;  //  type_index&quot;);
 431                 break;
 432             case TYPEPARAM_BOUND:   //[3.3.3]  class_type_param_bnds, meth_type_param_bnds
 433                 out_println(toHex(in.readUnsignedByte(), 1) + &quot;;  //  param_index&quot;);
 434                 out_println(toHex(in.readUnsignedByte(), 1) + &quot;;  //  bound_index&quot;);
 435                 break;
 436             case EMPTY:             //[3.3.4]  meth_receiver, meth_ret_type, field
 437                 // NOTE: reference_info is empty for this annotation&#39;s target
 438                 break;
 439             case METHODPARAM:       //[3.3.5]  meth_formal_param:
 440                 out_println(toHex(in.readUnsignedByte(), 1) + &quot;;  //  parameter_index&quot;);
 441                 break;
 442             case EXCEPTION:         //[3.3.61]  throws_type
 443                 //KTL:  Updated index to UShort for JSR308 change
 444                 out_println(in.readUnsignedShort() + &quot;;  //  type_index&quot;);
 445                 break;
 446             case LOCALVAR: //[3.3.7]  local_var, resource_var
 447             {
 448                 int lv_num = in.readUnsignedShort();
 449                 startArrayCmt(lv_num, &quot;local_variables&quot;);
 450                 try {
 451                     for (int i = 0; i &lt; lv_num; i++) {
 452                         out_println(in.readUnsignedShort() + &quot; &quot; + in.readUnsignedShort()
 453                                 + &quot; &quot; + in.readUnsignedShort() + &quot;;&quot; + getCommentPosCond());
 454                     }
 455                 } finally {
 456                     out_end(&quot;}&quot;);
 457                 }
 458             }
 459             break;
 460             case CATCH:             //[3.3.8]  exception_param
 461                 out_println(in.readUnsignedShort() + &quot;;  //  exception_table_index&quot;);
 462                 break;
 463             case OFFSET:            //[3.3.9]  type_test (instanceof), obj_creat (new)
 464                 // constr_ref_receiver, meth_ref_receiver
 465                 out_println(in.readUnsignedShort() + &quot;;  //  offset&quot;);
 466                 break;
 467             case TYPEARG:           //[3.3.10]  cast, constr_ref_typearg, meth_invoc_typearg
 468                 // constr_invoc_typearg, meth_ref_typearg
 469                 out_println(in.readUnsignedShort() + &quot;;  //  offset&quot;);
 470                 out_println(toHex(in.readUnsignedByte(), 1) + &quot;;  //  type_index&quot;);
 471                 break;
 472             default:                // should never happen
 473                 out_println(toHex(tt, 1) + &quot;; // invalid target_info: &quot; + tt);
 474                 throw new ClassFormatError();
 475         }
 476         // [4.7.20.2]
 477         int path_length = in.readUnsignedByte();  // type_path { u1 path_length; ...}
 478         startArrayCmtB(path_length, &quot;type_paths&quot;);
 479         try {
 480             for (int i = 0; i &lt; path_length; i++) {
 481                 // print the type_path elements
 482                 out_println(&quot;{ &quot; + toHex(in.readUnsignedByte(), 1)  // { u1 type_path_kind;
 483                         + &quot;; &quot; + toHex(in.readUnsignedByte(), 1)    //   u1 type_argument_index; }
 484                         + &quot;; } // type_path[&quot; + i + &quot;]&quot;);           // path[i]
 485             }
 486         } finally {
 487             out_end(&quot;}&quot;);
 488         }
 489     }
 490 
 491     private void decodeElementValue(DataInputStream in, PrintWriter out) throws IOException {
 492         out_begin(&quot;{  //  element_value&quot;);
 493         try {
 494             char tg = (char) in.readByte();
 495             AnnotElemType tag = annotElemType(tg);
 496             if (tag != AE_UNKNOWN) {
 497                 out_println(&quot;&#39;&quot; + tg + &quot;&#39;;&quot;);
 498             }
 499             switch (tag) {
 500                 case AE_BYTE:
 501                 case AE_CHAR:
 502                 case AE_DOUBLE:
 503                 case AE_FLOAT:
 504                 case AE_INT:
 505                 case AE_LONG:
 506                 case AE_SHORT:
 507                 case AE_BOOLEAN:
 508                 case AE_STRING:
 509                     decodeCPXAttr(in, 2, &quot;const_value_index&quot;, out);
 510                     break;
 511                 case AE_ENUM:
 512                     out_begin(&quot;{  //  enum_const_value&quot;);
 513                     decodeCPXAttr(in, 2, &quot;type_name_index&quot;, out);
 514                     decodeCPXAttr(in, 2, &quot;const_name_index&quot;, out);
 515                     out_end(&quot;}  //  enum_const_value&quot;);
 516                     break;
 517                 case AE_CLASS:
 518                     decodeCPXAttr(in, 2, &quot;class_info_index&quot;, out);
 519                     break;
 520                 case AE_ANNOTATION:
 521                     decodeAnnotation(in, out);
 522                     break;
 523                 case AE_ARRAY:
 524                     int ev_num = in.readUnsignedShort();
 525                     startArrayCmt(ev_num, &quot;array_value&quot;);
 526                     try {
 527                         for (int i = 0; i &lt; ev_num; i++) {
 528                             decodeElementValue(in, out);
 529                             if (i &lt; ev_num - 1) {
 530                                 out_println(&quot;;&quot;);
 531                             }
 532                         }
 533                     } finally {
 534                         out_end(&quot;}  //  array_value&quot;);
 535                     }
 536                     break;
 537                 case AE_UNKNOWN:
 538                 default:
 539                     String msg = &quot;invalid element_value&quot; + (isPrintableChar(tg) ? &quot; tag type : &quot; + tg : &quot;&quot;);
 540                     out_println(toHex(tg, 1) + &quot;; // &quot; + msg);
 541                     throw new ClassFormatError(msg);
 542             }
 543         } finally {
 544             out_end(&quot;}  //  element_value&quot;);
 545         }
 546     }
 547 
 548     public boolean isPrintableChar(char c) {
 549         Character.UnicodeBlock block = Character.UnicodeBlock.of(c);
 550         return (!Character.isISOControl(c)) &amp;&amp;
 551                 c != KeyEvent.CHAR_UNDEFINED &amp;&amp;
 552                 block != null &amp;&amp;
 553                 block != Character.UnicodeBlock.SPECIALS;
 554     }
 555 
 556     private void decodeAnnotation(DataInputStream in, PrintWriter out) throws IOException {
 557         out_begin(&quot;{  //  annotation&quot;);
 558         try {
 559             decodeCPXAttr(in, 2, &quot;field descriptor&quot;, out);
 560             int evp_num = in.readUnsignedShort();
 561             decodeElementValuePairs(evp_num, in, out);
 562         } finally {
 563             out_end(&quot;}  //  annotation&quot;);
 564         }
 565     }
 566 
 567     private void decodeElementValuePairs(int count, DataInputStream in, PrintWriter out) throws IOException {
 568         startArrayCmt(count, &quot;element_value_pairs&quot;);
 569         try {
 570             for (int i = 0; i &lt; count; i++) {
 571                 out_begin(&quot;{  //  element value pair&quot;);
 572                 try {
 573                     decodeCPXAttr(in, 2, &quot;name of the annotation type element&quot;, out);
 574                     decodeElementValue(in, out);
 575                 } finally {
 576                     out_end(&quot;}  //  element value pair&quot;);
 577                     if (i &lt; count - 1) {
 578                         out_println(&quot;;&quot;);
 579                     }
 580                 }
 581             }
 582         } finally {
 583             out_end(&quot;}  //  element_value_pairs&quot;);
 584         }
 585     }
 586 
 587     /**
 588      * component_info {     JEP 359 Record(Preview): class file 58.65535
 589      *     u2               name_index;
 590      *     u2               descriptor_index;
 591      *     u2               attributes_count;
 592      *     attribute_info attributes[attributes_count];
 593      * }
 594      *
 595      * or
 596      * field_info {
 597      *     u2             access_flags;
 598      *     u2             name_index;
 599      *     u2             descriptor_index;
 600      *     u2             attributes_count;
 601      *     attribute_info attributes[attributes_count];
 602      * }
 603      * or
 604      * method_info {
 605      *     u2             access_flags;
 606      *     u2             name_index;
 607      *     u2             descriptor_index;
 608      *     u2             attributes_count;
 609      *     attribute_info attributes[attributes_count];
 610      * }
 611      *
 612      */
 613     private void decodeInfo(DataInputStream in, PrintWriter out, String elementName, boolean hasAccessFlag) throws IOException {
 614         out_begin(&quot;{  // &quot; + elementName + (printDetails ? getStringPos() : &quot;&quot;));
 615         try {
 616             if(hasAccessFlag) {
 617                 //  u2 access_flags;
 618                 out_println(toHex(in.readShort(), 2) + &quot;; // access&quot;);
 619             }
 620             // u2 name_index
 621             printUtf8InfoIndex(in.readUnsignedShort(), &quot;name_index&quot;);
 622             // u2 descriptor_index
 623             printUtf8InfoIndex(in.readUnsignedShort(), &quot;descriptor_index&quot;);
 624             // u2 attributes_count;
 625             // attribute_info attributes[attributes_count]
 626             decodeAttrs(in, out);
 627         } finally {
 628             out_end(&quot;}&quot;);
 629         }
 630     }
 631 
 632     private void decodeTypeAnnotation(DataInputStream in, PrintWriter out) throws IOException {
 633         out_begin(&quot;{  //  type_annotation&quot;);
 634         try {
 635             decodeTargetTypeAndRefInfo(in);
 636             decodeCPXAttr(in, 2, &quot;field descriptor&quot;, out);
 637             int evp_num = in.readUnsignedShort();
 638             decodeElementValuePairs(evp_num, in, out);
 639         } finally {
 640             out_end(&quot;}  //  type_annotation&quot;);
 641         }
 642     }
 643 
 644     private void decodeBootstrapMethod(DataInputStream in) throws IOException {
 645         out_begin(&quot;{  //  bootstrap_method&quot;);
 646         try {
 647             out_println(&quot;#&quot; + in.readUnsignedShort() + &quot;; // bootstrap_method_ref&quot;);
 648             int bm_args_cnt = in.readUnsignedShort();
 649             startArrayCmt(bm_args_cnt, &quot;bootstrap_arguments&quot;);
 650             try {
 651                 for (int i = 0; i &lt; bm_args_cnt; i++) {
 652                     out_println(&quot;#&quot; + in.readUnsignedShort() + &quot;;&quot; + getCommentPosCond());
 653                 }
 654             } finally {
 655                 out_end(&quot;}  //  bootstrap_arguments&quot;);
 656             }
 657         } finally {
 658             out_end(&quot;}  //  bootstrap_method&quot;);
 659         }
 660     }
 661 
 662     private void decodeAttr(DataInputStream in, PrintWriter out) throws IOException {
 663         // Read one attribute
 664         String posComment = getStringPos();
 665         int name_cpx = in.readUnsignedShort(), btag, len;
 666 
 667         String AttrName = &quot;&quot;;
 668         try {
 669             btag = types[name_cpx];
 670             ConstType tag = tag(btag);
 671 
 672             if (tag == ConstType.CONSTANT_UTF8) {
 673                 AttrName = (String) cpool[name_cpx];
 674             }
 675         } catch (ArrayIndexOutOfBoundsException ignored) {
 676         }
 677         AttrTag tg = attrtag(AttrName);
 678         String endingComment = AttrName;
 679         len = in.readInt();
 680         countedin.enter(len);
 681         try {
 682             if (printDetails) {
 683                 out_begin(&quot;Attr(#&quot; + name_cpx + &quot;, &quot; + len + &quot;) { // &quot; + AttrName + posComment);
 684             } else {
 685                 out_begin(&quot;Attr(#&quot; + name_cpx + &quot;) { // &quot; + AttrName);
 686             }
 687 
 688             switch (tg) {
 689                 case ATT_Code:
 690                     out_println(in.readUnsignedShort() + &quot;; // max_stack&quot;);
 691                     out_println(in.readUnsignedShort() + &quot;; // max_locals&quot;);
 692                     int code_len = in.readInt();
 693                     out_begin(&quot;Bytes&quot; + startArray(code_len) + &quot;{&quot;);
 694                     try {
 695                         printBytes(out, in, code_len);
 696                     } finally {
 697                         out_end(&quot;}&quot;);
 698                     }
 699                     int trap_num = in.readUnsignedShort();
 700                     startArrayCmt(trap_num, &quot;Traps&quot;);
 701                     try {
 702                         for (int i = 0; i &lt; trap_num; i++) {
 703                             out_println(in.readUnsignedShort() + &quot; &quot; +
 704                                     in.readUnsignedShort() + &quot; &quot; +
 705                                     in.readUnsignedShort() + &quot; &quot; +
 706                                     in.readUnsignedShort() + &quot;;&quot; +
 707                                     getCommentPosCond());
 708                         }
 709                     } finally {
 710                         out_end(&quot;} // end Traps&quot;);
 711                     }
 712                     // Read the attributes
 713                     decodeAttrs(in, out);
 714                     break;
 715 
 716                 case ATT_Exceptions:
 717                     int count = in.readUnsignedShort();
 718                     startArrayCmt(count, AttrName);
 719                     try {
 720                         for (int i = 0; i &lt; count; i++) {
 721                             out_println(&quot;#&quot; + in.readUnsignedShort() + &quot;;&quot; +
 722                                     getCommentPosCond());
 723                         }
 724                     } finally {
 725                         out_end(&quot;}&quot;);
 726                     }
 727                     break;
 728                 case ATT_LineNumberTable:
 729                     int ll_num = in.readUnsignedShort();
 730                     startArrayCmt(ll_num, &quot;line_number_table&quot;);
 731                     try {
 732                         for (int i = 0; i &lt; ll_num; i++) {
 733                             out_println(in.readUnsignedShort() + &quot;  &quot; +
 734                                     in.readUnsignedShort() + &quot;;&quot; +
 735                                     getCommentPosCond());
 736                         }
 737                     } finally {
 738                         out_end(&quot;}&quot;);
 739                     }
 740                     break;
 741                 case ATT_LocalVariableTable:
 742                 case ATT_LocalVariableTypeTable:
 743                     int lvt_num = in.readUnsignedShort();
 744                     startArrayCmt(lvt_num, AttrName);
 745                     try {
 746                         for (int i = 0; i &lt; lvt_num; i++) {
 747                             out_println(in.readUnsignedShort() + &quot; &quot; +
 748                                     in.readUnsignedShort() + &quot; &quot; +
 749                                     in.readUnsignedShort() + &quot; &quot; +
 750                                     in.readUnsignedShort() + &quot; &quot; +
 751                                     in.readUnsignedShort() + &quot;;&quot; +
 752                                     getCommentPosCond());
 753                         }
 754                     } finally {
 755                         out_end(&quot;}&quot;);
 756                     }
 757                     break;
 758                 case ATT_InnerClasses:
 759                     int ic_num = in.readUnsignedShort();
 760                     startArrayCmt(ic_num, &quot;classes&quot;);
 761                     try {
 762                         for (int i = 0; i &lt; ic_num; i++) {
 763                             out_println(&quot;#&quot; + in.readUnsignedShort() + &quot; #&quot; +
 764                                     in.readUnsignedShort() + &quot; #&quot; +
 765                                     in.readUnsignedShort() + &quot; &quot; +
 766                                     in.readUnsignedShort() + &quot;;&quot; + getCommentPosCond());
 767                         }
 768                     } finally {
 769                         out_end(&quot;}&quot;);
 770                     }
 771                     break;
 772                 case ATT_StackMap:
 773                     int e_num = in.readUnsignedShort();
 774                     startArrayCmt(e_num, &quot;&quot;);
 775                     try {
 776                         for (int k = 0; k &lt; e_num; k++) {
 777                             int start_pc = in.readUnsignedShort();
 778                             out_print(&quot;&quot; + start_pc + &quot;, &quot;);
 779                             printStackMap(in, 0);
 780                             out.print(&quot;, &quot;);
 781                             printStackMap(in, 0);
 782                             out.println(&quot;;&quot;);
 783                         }
 784                     } finally {
 785                         out_end(&quot;}&quot;);
 786                     }
 787                     break;
 788                 case ATT_StackMapTable:
 789                     int et_num = in.readUnsignedShort();
 790                     startArrayCmt(et_num, &quot;&quot;);
 791                     try {
 792                         for (int k = 0; k &lt; et_num; k++) {
 793                             int frame_type = in.readUnsignedByte();
 794                             StackMapFrameType ftype = stackMapFrameType(frame_type);
 795                             switch (ftype) {
 796                                 case SAME_FRAME:
 797                                     // type is same_frame;
 798                                     out_print(&quot;&quot; + frame_type + &quot;b&quot;);
 799                                     out.println(&quot;; // same_frame&quot;);
 800                                     break;
 801                                 case SAME_LOCALS_1_STACK_ITEM_FRAME:
 802                                     // type is same_locals_1_stack_item_frame
 803                                     out_print(&quot;&quot; + frame_type + &quot;b, &quot;);
 804                                     // read additional single stack element
 805                                     printStackMap(in, 1);
 806                                     out.println(&quot;; // same_locals_1_stack_item_frame&quot;);
 807                                     break;
 808                                 case SAME_LOCALS_1_STACK_ITEM_EXTENDED_FRAME:
 809                                     // type is same_locals_1_stack_item_frame_extended
 810                                     int noffset = in.readUnsignedShort();
 811                                     out_print(&quot;&quot; + frame_type + &quot;b, &quot; + noffset + &quot;, &quot;);
 812                                     // read additional single stack element
 813                                     printStackMap(in, 1);
 814                                     out.println(&quot;; // same_locals_1_stack_item_frame_extended&quot;);
 815                                     break;
 816                                 case CHOP_1_FRAME:
 817                                 case CHOP_2_FRAME:
 818                                 case CHOP_3_FRAME:
 819                                     // type is chop_frame
 820                                     int coffset = in.readUnsignedShort();
 821                                     out_print(&quot;&quot; + frame_type + &quot;b, &quot; + coffset);
 822                                     out.println(&quot;; // chop_frame &quot; + (251 - frame_type));
 823                                     break;
 824                                 case SAME_FRAME_EX:
 825                                     // type is same_frame_extended;
 826                                     int xoffset = in.readUnsignedShort();
 827                                     out_print(&quot;&quot; + frame_type + &quot;b, &quot; + xoffset);
 828                                     out.println(&quot;; // same_frame_extended&quot;);
 829                                     break;
 830                                 case APPEND_FRAME:
 831                                     // type is append_frame
 832                                     int aoffset = in.readUnsignedShort();
 833                                     out_print(&quot;&quot; + frame_type + &quot;b, &quot; + aoffset + &quot;, &quot;);
 834                                     // read additional locals
 835                                     printStackMap(in, frame_type - 251);
 836                                     out.println(&quot;; // append_frame &quot; + (frame_type - 251));
 837                                     break;
 838                                 case FULL_FRAME:
 839                                     // type is full_frame
 840                                     int foffset = in.readUnsignedShort();
 841                                     out_print(&quot;&quot; + frame_type + &quot;b, &quot; + foffset + &quot;, &quot;);
 842                                     printStackMap(in, 0);
 843                                     out.print(&quot;, &quot;);
 844                                     printStackMap(in, 0);
 845                                     out.println(&quot;; // full_frame&quot;);
 846                                     break;
 847                             }
 848                         }
 849                     } finally {
 850                         out_end(&quot;}&quot;);
 851                     }
 852                     break;
 853                 case ATT_EnclosingMethod:
 854                     decodeCPXAttrM(in, len, AttrName, out, 2);
 855                     break;
 856                 case ATT_AnnotationDefault:
 857                     decodeElementValue(in, out);
 858                     break;
 859                 case ATT_RuntimeInvisibleAnnotations:
 860                 case ATT_RuntimeVisibleAnnotations:
 861                     int an_num = in.readUnsignedShort();
 862                     startArrayCmt(an_num, &quot;annotations&quot;);
 863                     try {
 864                         for (int i = 0; i &lt; an_num; i++) {
 865                             decodeAnnotation(in, out);
 866                             if (i &lt; an_num - 1) {
 867                                 out_println(&quot;;&quot;);
 868                             }
 869                         }
 870                     } finally {
 871                         out_end(&quot;}&quot;);
 872                     }
 873                     break;
 874                 // 4.7.20 The RuntimeVisibleTypeAnnotations Attribute
 875                 // 4.7.21 The RuntimeInvisibleTypeAnnotations Attribute
 876                 case ATT_RuntimeInvisibleTypeAnnotations:
 877                 case ATT_RuntimeVisibleTypeAnnotations:
 878                     int ant_num = in.readUnsignedShort();
 879                     startArrayCmt(ant_num, &quot;annotations&quot;);
 880                     try {
 881                         for (int i = 0; i &lt; ant_num; i++) {
 882                             decodeTypeAnnotation(in, out);
 883                             if (i &lt; ant_num - 1) {
 884                                 out_println(&quot;;&quot;);
 885                             }
 886                         }
 887                     } finally {
 888                         out_end(&quot;}&quot;);
 889                     }
 890                     break;
 891                 case ATT_RuntimeInvisibleParameterAnnotations:
 892                 case ATT_RuntimeVisibleParameterAnnotations:
 893                     int pm_num = in.readUnsignedByte();
 894                     startArrayCmtB(pm_num, &quot;parameters&quot;);
 895                     try {
 896                         for (int k = 0; k &lt; pm_num; k++) {
 897                             int anp_num = in.readUnsignedShort();
 898                             startArrayCmt(anp_num, &quot;annotations&quot;);
 899                             try {
 900                                 for (int i = 0; i &lt; anp_num; i++) {
 901                                     decodeAnnotation(in, out);
 902                                     if (k &lt; anp_num - 1) {
 903                                         out_println(&quot;;&quot;);
 904                                     }
 905                                 }
 906                             } finally {
 907                                 out_end(&quot;}&quot;);
 908                             }
 909                             if (k &lt; pm_num - 1) {
 910                                 out_println(&quot;;&quot;);
 911                             }
 912                         }
 913                     } finally {
 914                         out_end(&quot;}&quot;);
 915                     }
 916                     break;
 917                 case ATT_BootstrapMethods:
 918                     int bm_num = in.readUnsignedShort();
 919                     startArrayCmt(bm_num, &quot;bootstrap_methods&quot;);
 920                     try {
 921                         for (int i = 0; i &lt; bm_num; i++) {
 922                             decodeBootstrapMethod(in);
 923                             if (i &lt; bm_num - 1) {
 924                                 out_println(&quot;;&quot;);
 925                             }
 926                         }
 927                     } finally {
 928                         out_end(&quot;}&quot;);
 929                     }
 930                     break;
 931                 case ATT_Module:
 932                     decodeModule(in);
 933                     break;
 934                 case ATT_TargetPlatform:
 935                     decodeCPXAttrM(in, len, AttrName, out, 3);
 936                     break;
 937                 case ATT_ModulePackages:
 938                     int p_num = in.readUnsignedShort();
 939                     startArrayCmt(p_num, null);
 940                     try {
 941                         decodeCPXAttrM(in, len - 2, AttrName, out, p_num);
 942                     } finally {
 943                         out_end(&quot;}&quot;);
 944                     }
 945                     break;
 946                 //  MethodParameters_attribute {
 947                 //    u2 attribute_name_index;
 948                 //    u4 attribute_length;
 949                 //    u1 parameters_count;
 950                 //    {   u2 name_index;
 951                 //        u2 access_flags;
 952                 //    } parameters[parameters_count];
 953                 //  }
 954                 case ATT_MethodParameters:
 955                     int pcount = in.readUnsignedByte();
 956                     startArrayCmtB(pcount, AttrName);
 957                     try {
 958                         for (int i = 0; i &lt; pcount; i++) {
 959                             out_println(&quot;#&quot; + in.readUnsignedShort() + &quot;  &quot; +
 960                                     toHex(in.readUnsignedShort(), 2) + &quot;;&quot; +
 961                                     getCommentPosCond());
 962                         }
 963                     } finally {
 964                         out_end(&quot;}&quot;);
 965                     }
 966                     break;
 967                 //  JEP 359 Record(Preview): class file 58.65535
 968                 //  Record_attribute {
 969                 //      u2 attribute_name_index;
 970                 //      u4 attribute_length;
 971                 //      u2 components_count;
 972                 //      component_info components[components_count];
 973                 //  }
 974                 case ATT_Record:
 975                     int ncomps = in.readUnsignedShort();
 976                     startArrayCmt(ncomps, &quot;components&quot;);
 977                     try {
 978                         for (int i = 0; i &lt; ncomps; i++) {
 979                             decodeInfo(in,out,&quot;component&quot;,false);
 980                             if (i &lt; ncomps - 1) {
 981                                 out_println(&quot;;&quot;);
 982                             }
 983                         }
 984                     } finally {
 985                         out_end(&quot;}&quot;);
 986                     }
 987                     break;
 988                 case ATT_ConstantValue:
 989                 case ATT_Signature:
 990                 case ATT_SourceFile:
 991                     decodeCPXAttr(in, len, AttrName, out);
 992                     break;
 993                     //  JEP 181 (Nest-based Access Control): class file 55.0
 994                     //  NestHost_attribute {
 995                     //    u2 attribute_name_index;
 996                     //    u4 attribute_length;
 997                     //    u2 host_class_index;
 998                     //  }
 999                 case ATT_NestHost:
1000                     decodeTypes(in, out, 1);
1001                     break;
1002                     //  JEP 181 (Nest-based Access Control): class file 55.0
1003                     //  NestMembers_attribute {
1004                     //    u2 attribute_name_index;
1005                     //    u4 attribute_length;
1006                     //    u2 number_of_classes;
1007                     //    u2 classes[number_of_classes];
1008                     //  }
1009                 case ATT_NestMembers:
1010                     //  JEP 360 (Sealed types): class file 59.65535
1011                     //  PermittedSubclasses_attribute {
1012                     //    u2 attribute_name_index;
1013                     //    u4 attribute_length;
1014                     //    u2 number_of_classes;
1015                     //    u2 classes[number_of_classes];
1016                     //  }
1017                 case ATT_PermittedSubclasses:
1018                     int nsubtypes = in.readUnsignedShort();
1019                     startArrayCmt(nsubtypes, &quot;classes&quot;);
1020                     try {
1021                         decodeTypes(in, out, nsubtypes);
1022                     } finally {
1023                         out_end(&quot;}&quot;);
1024                     }
1025                     break;
1026                 default:
1027                     printBytes(out, in, len);
1028                     if (AttrName == null) {
1029                         endingComment = &quot;Attr(#&quot; + name_cpx + &quot;)&quot;;
1030                     }
1031             }
1032 
1033         } catch (EOFException e) {
1034             out.println(&quot;// ======== unexpected end of attribute array&quot;);
1035         } finally {
1036             int rest = countedin.available();
1037             if (rest &gt; 0) {
1038                 out.println(&quot;// ======== attribute array started &quot; + posComment + &quot; has &quot; + rest + &quot; bytes more:&quot;);
1039                 printBytes(out, in, rest);
1040             }
1041             out_end(&quot;} // end &quot; + endingComment);
1042             countedin.leave();
1043         }
1044     }
1045 
1046     private void decodeModuleStatement(String statementName, DataInputStream in) throws IOException {
1047         // u2 {exports|opens}_count
1048         int count = in.readUnsignedShort();
1049         startArrayCmt(count, statementName);
1050         try {
1051             for (int i = 0; i &lt; count; i++) {
1052                 // u2 {exports|opens}_index; u2 {exports|opens}_flags
1053                 int index = in.readUnsignedShort();
1054                 int nFlags = in.readUnsignedShort();
1055                 String sFlags = printDetails ? Module.Modifier.getStatementFlags(nFlags) : &quot;&quot;;
1056                 out_println(&quot;#&quot; + index + &quot; &quot; + toHex(nFlags, 2) + (sFlags.isEmpty() ? &quot;&quot; : &quot; // [ &quot; + sFlags + &quot; ]&quot;));
1057                 int exports_to_count = in.readUnsignedShort();
1058                 startArrayCmt(exports_to_count, null);
1059                 try {
1060                     for (int j = 0; j &lt; exports_to_count; j++) {
1061                         out_println(&quot;#&quot; + in.readUnsignedShort() + &quot;;&quot;);
1062                     }
1063                 } finally {
1064                     out_end(&quot;};&quot;);
1065                 }
1066             }
1067         } finally {
1068             out_end(&quot;} // &quot; + statementName + &quot;\n&quot;);
1069         }
1070     }
1071 
1072     private void decodeModule(DataInputStream in) throws IOException {
1073         //u2 module_name_index
1074         int index = in.readUnsignedShort();
1075         entityName = (String) cpool[(Integer) cpool[index]];
1076         out_print(&quot;#&quot; + index + &quot;; // &quot;);
1077         if (printDetails) {
1078             out.println(String.format(&quot;%-16s&quot;,&quot;name_index&quot;) + &quot; : &quot; + entityName);
1079         } else {
1080             out.println(&quot;name_index&quot;);
1081         }
1082 
1083         // u2 module_flags
1084         int moduleFlags = in.readUnsignedShort();
1085         out_print(toHex(moduleFlags, 2) + &quot;; // flags&quot;);
1086         if (printDetails) {
1087             out_print(&quot; &quot; + Module.Modifier.getModuleFlags(moduleFlags));
1088         }
1089         out.println();
1090 
1091         //u2 module_version
1092         int versionIndex = in.readUnsignedShort();
1093         out_println(&quot;#&quot; + versionIndex + &quot;; // version&quot;);
1094 
1095         // u2 requires_count
1096         int count = in.readUnsignedShort();
1097         startArrayCmt(count, &quot;requires&quot;);
1098         try {
1099             for (int i = 0; i &lt; count; i++) {
1100                 // u2 requires_index; u2 requires_flags; u2 requires_version_index
1101                 index = in.readUnsignedShort();
1102                 int nFlags = in.readUnsignedShort();
1103                 versionIndex = in.readUnsignedShort();
1104                 String sFlags = printDetails ? Module.Modifier.getStatementFlags(nFlags) : &quot;&quot;;
1105                 out_println(&quot;#&quot; + index + &quot; &quot; + toHex(nFlags, 2) + &quot; #&quot; + versionIndex + &quot;;&quot; + (sFlags.isEmpty() ? &quot;&quot; : &quot; // &quot; + sFlags));
1106             }
1107         } finally {
1108             out_end(&quot;} // requires\n&quot;);
1109         }
1110 
1111         decodeModuleStatement(&quot;exports&quot;, in);
1112 
1113         decodeModuleStatement(&quot;opens&quot;, in);
1114         // u2 uses_count
1115         count = in.readUnsignedShort();
1116         startArrayCmt(count, &quot;uses&quot;);
1117         try {
1118             for (int i = 0; i &lt; count; i++) {
1119                 // u2 uses_index
1120                 out_println(&quot;#&quot; + in.readUnsignedShort() + &quot;;&quot;);
1121             }
1122         } finally {
1123             out_end(&quot;} // uses\n&quot;);
1124         }
1125         count = in.readUnsignedShort(); // u2 provides_count
1126         startArrayCmt(count, &quot;provides&quot;);
1127         try {
1128             for (int i = 0; i &lt; count; i++) {
1129                 // u2 provides_index
1130                 out_println(&quot;#&quot; + in.readUnsignedShort());
1131                 int provides_with_count = in.readUnsignedShort();
1132                 // u2 provides_with_count
1133                 startArrayCmt(provides_with_count, null);
1134                 try {
1135                     for (int j = 0; j &lt; provides_with_count; j++) {
1136                         // u2 provides_with_index;
1137                         out_println(&quot;#&quot; + in.readUnsignedShort() + &quot;;&quot;);
1138                     }
1139                 } finally {
1140                     out_end(&quot;};&quot;);
1141                 }
1142             }
1143         } finally {
1144             out_end(&quot;} // provides\n&quot;);
1145         }
1146     }
1147 
1148     private void decodeAttrs(DataInputStream in, PrintWriter out) throws IOException {
1149         // Read the attributes
1150         int attr_num = in.readUnsignedShort();
1151         startArrayCmt(attr_num, &quot;Attributes&quot;);
1152         try {
1153             for (int i = 0; i &lt; attr_num; i++) {
1154                 decodeAttr(in, out);
1155                 if (i + 1 &lt; attr_num) {
1156                     out_println(&quot;;&quot;);
1157                 }
1158             }
1159         } finally {
1160             out_end(&quot;} // Attributes&quot;);
1161         }
1162     }
1163 
1164     private void decodeMembers(DataInputStream in, PrintWriter out, String groupName, String elementName) throws IOException {
1165         int count = in.readUnsignedShort();
1166         traceln(groupName + &quot;=&quot; + count);
1167         startArrayCmt(count, groupName);
1168         try {
1169             for (int i = 0; i &lt; count; i++) {
1170                 decodeInfo(in,out,elementName,true);
1171                 if (i + 1 &lt; count) {
1172                     out_println(&quot;;&quot;);
1173                 }
1174             }
1175         } finally {
1176             out_end(&quot;} // &quot; + groupName);
1177             out.println();
1178         }
1179     }
1180 
1181     void decodeClass(String fileName) throws IOException {
1182         // Read the header
1183         try {
1184             int magic = in.readInt();
1185             int min_version = in.readUnsignedShort();
1186             int version = in.readUnsignedShort();
1187 
1188             // Read the constant pool
1189             readCP(in);
1190             short access = in.readShort(); // don&#39;t care about sign
1191             int this_cpx = in.readUnsignedShort();
1192 
1193             try {
1194                 entityName = (String) cpool[(Integer) cpool[this_cpx]];
1195                 if (entityName.equals(&quot;module-info&quot;)) {
1196                     entityType = &quot;module&quot;;
1197                     entityName = &quot;&quot;;
1198                 } else {
1199                     entityType = &quot;class&quot;;
1200                 }
1201                 if (!entityName.isEmpty() &amp;&amp; (JcodTokens.keyword_token_ident(entityName) != JcodTokens.Token.IDENT || JcodTokens.constValue(entityName) != -1)) {
1202                     // JCod can&#39;t parse a entityName matching a keyword or a constant value,
1203                     // then use the filename instead:
1204                     out_begin(String.format(&quot;file \&quot;%s.class\&quot; {&quot;, entityName));
1205                 } else {
1206                     out_begin(format(&quot;%s %s {&quot;, entityType, entityName));
1207                 }
1208             } catch (Exception e) {
1209                 entityName = fileName;
1210                 out.println(&quot;// &quot; + e.getMessage() + &quot; while accessing entityName&quot;);
1211                 out_begin(format(&quot;%s %s { // source file name&quot;, entityType, entityName));
1212             }
1213 
1214             out_print(toHex(magic, 4) + &quot;;&quot;);
1215             if (magic != JAVA_MAGIC) {
1216                 out.print(&quot; // wrong magic: 0x&quot; + Integer.toString(JAVA_MAGIC, 16) + &quot; expected&quot;);
1217             }
1218             out.println();
1219             out_println(min_version + &quot;; // minor version&quot;);
1220             out_println(version + &quot;; // version&quot;);
1221 
1222             // Print the constant pool
1223             printCP(out);
1224             out_println(toHex(access, 2) + &quot;; // access&quot; +
1225                     (printDetails ? &quot; [&quot; + (&quot; &quot; + Modifiers.accessString(access, CF_Context.CTX_CLASS).toUpperCase()).replaceAll(&quot; (\\S)&quot;, &quot; ACC_$1&quot;) + &quot;]&quot; : &quot;&quot;));
1226             out_println(&quot;#&quot; + this_cpx + &quot;;// this_cpx&quot;);
1227             int super_cpx = in.readUnsignedShort();
1228             out_println(&quot;#&quot; + super_cpx + &quot;;// super_cpx&quot;);
1229             traceln(i18n.getString(&quot;jdec.trace.access_thisCpx_superCpx&quot;, access, this_cpx, super_cpx));
1230             out.println();
1231 
1232             // Read the interfaces
1233             int numinterfaces = in.readUnsignedShort();
1234             traceln(i18n.getString(&quot;jdec.trace.numinterfaces&quot;, numinterfaces));
1235             startArrayCmt(numinterfaces, &quot;Interfaces&quot;);
1236             try {
1237                 decodeTypes(in, out, numinterfaces);
1238             } finally {
1239                 out_end(&quot;} // Interfaces\n&quot;);
1240             }
1241             // Read the fields
1242             decodeMembers(in, out, &quot;Fields&quot;, &quot;field&quot;);
1243 
1244             // Read the methods
1245             decodeMembers(in, out, &quot;Methods&quot;, &quot;method&quot;);
1246 
1247             // Read the attributes
1248             decodeAttrs(in, out);
1249         } catch (EOFException ignored) {
1250         } catch (ClassFormatError err) {
1251             String msg = err.getMessage();
1252             out.println(&quot;//------- ClassFormatError&quot; +
1253                     (msg == null || msg.isEmpty() ? &quot;&quot; : &quot;: &quot; + msg));
1254             printRestOfBytes();
1255         } finally {
1256             out_end(format(&quot;} // end %s %s&quot;, entityType, entityName));
1257         }
1258     } // end decodeClass()
1259 
1260     private void decodeTypes(DataInputStream in, PrintWriter out, int count) throws IOException {
1261         for (int i = 0; i &lt; count; i++) {
1262             int type_cpx = in.readUnsignedShort();
1263             traceln(i18n.getString(&quot;jdec.trace.type&quot;, i, type_cpx));
1264             out_print(&quot;#&quot; + type_cpx + &quot;;&quot;);
1265             if (printDetails) {
1266                 String name = (String) cpool[(int)cpool[type_cpx]];
1267                 out.println(&quot; // &quot; + name + getStringPos());
1268             } else {
1269                 out.println();
1270             }
1271         }
1272     }
1273 
1274     /* ====================================================== */
1275     boolean DebugFlag = false;
1276 
1277     public void trace(String s) {
1278         if (!DebugFlag) {
1279             return;
1280         }
1281         System.out.print(s);
1282     }
1283 
1284     public void traceln(String s) {
1285         if (!DebugFlag) {
1286             return;
1287         }
1288         System.out.println(s);
1289     }
1290 }// end class ClassData
1291 
    </pre>
  </body>
</html>
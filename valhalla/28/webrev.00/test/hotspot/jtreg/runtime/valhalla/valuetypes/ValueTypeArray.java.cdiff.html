<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeArray.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="UninitializedValueFieldsTest.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ValueTypeCreation.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>test/hotspot/jtreg/runtime/valhalla/valuetypes/ValueTypeArray.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 221,27 ***</span>
          assertEquals(array3[0].length, 2, &quot;Incorrect length&quot;);
          assertTrue(array3[0][0] == null, &quot;Expected NULL&quot;);
  
          // Now create ObjArrays of ValueArray...
          cls = (Class&lt;?&gt;) Point.class.asIndirectType();
<span class="line-modified">!         Point?[][] barray = (Point?[][]) Array.newInstance(cls, 1, 2);</span>
          assertEquals(barray.length, 1, &quot;Incorrect length&quot;);
          assertEquals(barray[0].length, 2, &quot;Incorrect length&quot;);
          barray[0][1] = Point.createPoint(1, 2);
<span class="line-modified">!         Point? pb = barray[0][1];</span>
          int x = pb.getX();
          assertEquals(x, 1, &quot;Bad Point Value&quot;);
      }
  
<span class="line-modified">!     static final inline class MyInt implements Comparable&lt;MyInt?&gt; {</span>
          final int value;
  
          private MyInt() { this(0); }
          private MyInt(int v) { value = v; }
          public int getValue() { return value; }
          public String toString() { return &quot;MyInt: &quot; + getValue(); }
<span class="line-modified">!         public int compareTo(MyInt? that) { return Integer.compare(this.getValue(), that.getValue()); }</span>
          public boolean equals(Object o) {
              if (o instanceof MyInt) {
                  return this.getValue() == ((MyInt) o).getValue();
              }
              return false;
<span class="line-new-header">--- 221,27 ---</span>
          assertEquals(array3[0].length, 2, &quot;Incorrect length&quot;);
          assertTrue(array3[0][0] == null, &quot;Expected NULL&quot;);
  
          // Now create ObjArrays of ValueArray...
          cls = (Class&lt;?&gt;) Point.class.asIndirectType();
<span class="line-modified">!         Point.ref[][] barray = (Point.ref[][]) Array.newInstance(cls, 1, 2);</span>
          assertEquals(barray.length, 1, &quot;Incorrect length&quot;);
          assertEquals(barray[0].length, 2, &quot;Incorrect length&quot;);
          barray[0][1] = Point.createPoint(1, 2);
<span class="line-modified">!         Point.ref pb = barray[0][1];</span>
          int x = pb.getX();
          assertEquals(x, 1, &quot;Bad Point Value&quot;);
      }
  
<span class="line-modified">!     static final inline class MyInt implements Comparable&lt;MyInt.ref&gt; {</span>
          final int value;
  
          private MyInt() { this(0); }
          private MyInt(int v) { value = v; }
          public int getValue() { return value; }
          public String toString() { return &quot;MyInt: &quot; + getValue(); }
<span class="line-modified">!         public int compareTo(MyInt.ref that) { return Integer.compare(this.getValue(), that.getValue()); }</span>
          public boolean equals(Object o) {
              if (o instanceof MyInt) {
                  return this.getValue() == ((MyInt) o).getValue();
              }
              return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 250,13 ***</span>
          public static MyInt create(int v) {
              return new MyInt(v);
          }
  
          // Null-able fields here are a temp hack to avoid ClassCircularityError
<span class="line-modified">!         public static final MyInt? MIN = MyInt.create(Integer.MIN_VALUE);</span>
<span class="line-modified">!         public static final MyInt? ZERO = MyInt.create(0);</span>
<span class="line-modified">!         public static final MyInt? MAX = MyInt.create(Integer.MAX_VALUE);</span>
      }
  
      static MyInt staticMyInt = MyInt.create(-1);
      static MyInt[] staticMyIntArray = new MyInt[] { staticMyInt };
      static MyInt[][] staticMyIntArrayArray = new MyInt[][] { staticMyIntArray, staticMyIntArray };
<span class="line-new-header">--- 250,13 ---</span>
          public static MyInt create(int v) {
              return new MyInt(v);
          }
  
          // Null-able fields here are a temp hack to avoid ClassCircularityError
<span class="line-modified">!         public static final MyInt.ref MIN = MyInt.create(Integer.MIN_VALUE);</span>
<span class="line-modified">!         public static final MyInt.ref ZERO = MyInt.create(0);</span>
<span class="line-modified">!         public static final MyInt.ref MAX = MyInt.create(Integer.MAX_VALUE);</span>
      }
  
      static MyInt staticMyInt = MyInt.create(-1);
      static MyInt[] staticMyIntArray = new MyInt[] { staticMyInt };
      static MyInt[][] staticMyIntArrayArray = new MyInt[][] { staticMyIntArray, staticMyIntArray };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 272,11 ***</span>
  
      void testSanityCheckcasts() {
          MyInt[] myInts = new MyInt[1];
          assertTrue(myInts instanceof Object[]);
          assertTrue(myInts instanceof Comparable[]);
<span class="line-modified">!         assertTrue(myInts instanceof MyInt?[]);</span>
  
          Class&lt;?&gt; cls = MyInt.class;
          assertTrue(cls.isInlineClass());
          Object arrObj = Array.newInstance(cls, 1);
          assertTrue(arrObj instanceof Object[], &quot;Not Object array&quot;);
<span class="line-new-header">--- 272,11 ---</span>
  
      void testSanityCheckcasts() {
          MyInt[] myInts = new MyInt[1];
          assertTrue(myInts instanceof Object[]);
          assertTrue(myInts instanceof Comparable[]);
<span class="line-modified">!         assertTrue(myInts instanceof MyInt.ref[]);</span>
  
          Class&lt;?&gt; cls = MyInt.class;
          assertTrue(cls.isInlineClass());
          Object arrObj = Array.newInstance(cls, 1);
          assertTrue(arrObj instanceof Object[], &quot;Not Object array&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 291,41 ***</span>
  
          // multi-dim, check secondary array types are setup...
          MyOtherInt[][] matrix = new MyOtherInt[1][1];
          assertTrue(matrix[0] instanceof MyOtherInt[]);
          assertTrue(matrix[0] instanceof SomeSecondaryType[]);
<span class="line-modified">!         assertTrue(matrix[0] instanceof MyOtherInt?[]);</span>
  
          // Box types vs Inline...
<span class="line-modified">!         MyInt?[] myValueRefs = new MyInt?[1];</span>
<span class="line-modified">!         assertTrue(myValueRefs instanceof MyInt?[]);</span>
          assertTrue(myValueRefs instanceof Object[]);
          assertTrue(myValueRefs instanceof Comparable[]);
          assertFalse(myValueRefs instanceof MyInt[]);
  
<span class="line-modified">!         MyInt?[][] myMdValueRefs = new MyInt?[1][1];</span>
<span class="line-modified">!         assertTrue(myMdValueRefs[0] instanceof MyInt?[]);</span>
          assertTrue(myMdValueRefs[0] instanceof Object[]);
          assertTrue(myMdValueRefs[0] instanceof Comparable[]);
          assertFalse(myMdValueRefs[0] instanceof MyInt[]);
  
          // Did we break checkcast...
<span class="line-modified">!         MyInt?[]     va1 = (MyInt?[])null;</span>
<span class="line-modified">!         MyInt?[]     va2 = null;</span>
<span class="line-modified">!         MyInt?[][]   va3 = (MyInt?[][])null;</span>
<span class="line-modified">!         MyInt?[][][] va4 = (MyInt?[][][])null;</span>
          MyInt[]      va5 = null;
          MyInt[]      va6 = (MyInt[])null;
          MyInt[][]    va7 = (MyInt[][])null;
          MyInt[][][]  va8 = (MyInt[][][])null;
      }
  
  
      void testUtilArrays() {
          // Sanity check j.u.Arrays
  
<span class="line-modified">!         // cast to q-type temp effect of avoiding circularity error (decl static MyInt?)</span>
          MyInt[] myInts = new MyInt[] { (MyInt) MyInt.MAX, (MyInt) MyInt.MIN };
          // Sanity sort another copy
          MyInt[] copyMyInts = Arrays.copyOf(myInts, myInts.length + 1);
          checkArrayElementsEqual(copyMyInts, new MyInt[] { myInts[0], myInts[1], (MyInt) MyInt.ZERO});
  
<span class="line-new-header">--- 291,41 ---</span>
  
          // multi-dim, check secondary array types are setup...
          MyOtherInt[][] matrix = new MyOtherInt[1][1];
          assertTrue(matrix[0] instanceof MyOtherInt[]);
          assertTrue(matrix[0] instanceof SomeSecondaryType[]);
<span class="line-modified">!         assertTrue(matrix[0] instanceof MyOtherInt.ref[]);</span>
  
          // Box types vs Inline...
<span class="line-modified">!         MyInt.ref[] myValueRefs = new MyInt.ref[1];</span>
<span class="line-modified">!         assertTrue(myValueRefs instanceof MyInt.ref[]);</span>
          assertTrue(myValueRefs instanceof Object[]);
          assertTrue(myValueRefs instanceof Comparable[]);
          assertFalse(myValueRefs instanceof MyInt[]);
  
<span class="line-modified">!         MyInt.ref[][] myMdValueRefs = new MyInt.ref[1][1];</span>
<span class="line-modified">!         assertTrue(myMdValueRefs[0] instanceof MyInt.ref[]);</span>
          assertTrue(myMdValueRefs[0] instanceof Object[]);
          assertTrue(myMdValueRefs[0] instanceof Comparable[]);
          assertFalse(myMdValueRefs[0] instanceof MyInt[]);
  
          // Did we break checkcast...
<span class="line-modified">!         MyInt.ref[]     va1 = (MyInt.ref[])null;</span>
<span class="line-modified">!         MyInt.ref[]     va2 = null;</span>
<span class="line-modified">!         MyInt.ref[][]   va3 = (MyInt.ref[][])null;</span>
<span class="line-modified">!         MyInt.ref[][][] va4 = (MyInt.ref[][][])null;</span>
          MyInt[]      va5 = null;
          MyInt[]      va6 = (MyInt[])null;
          MyInt[][]    va7 = (MyInt[][])null;
          MyInt[][][]  va8 = (MyInt[][][])null;
      }
  
  
      void testUtilArrays() {
          // Sanity check j.u.Arrays
  
<span class="line-modified">!         // cast to q-type temp effect of avoiding circularity error (decl static MyInt.ref)</span>
          MyInt[] myInts = new MyInt[] { (MyInt) MyInt.MAX, (MyInt) MyInt.MIN };
          // Sanity sort another copy
          MyInt[] copyMyInts = Arrays.copyOf(myInts, myInts.length + 1);
          checkArrayElementsEqual(copyMyInts, new MyInt[] { myInts[0], myInts[1], (MyInt) MyInt.ZERO});
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 383,16 ***</span>
  
          comparables[0] = null;
          comparables[1] = null;
          assertTrue(comparables[0] == null &amp;&amp; comparables[1] == null, &quot;Not null ?&quot;);
  
<span class="line-modified">!         MyInt?[] myIntRefArray = new MyInt?[1];</span>
          assertTrue(myIntRefArray[0] == null, &quot;Got: &quot; + myIntRefArray[0]);
          myIntRefArray[0] = null;
  
<span class="line-modified">!         MyInt?[] srcNulls = new MyInt?[2];</span>
<span class="line-modified">!         MyInt?[] dstNulls = new MyInt?[2];</span>
          System.arraycopy(srcNulls, 0, dstNulls, 0, 2);
          checkArrayElementsEqual(srcNulls, dstNulls);
          srcNulls[1] = MyInt.create(1);
          System.arraycopy(srcNulls, 0, dstNulls, 0, 2);
          checkArrayElementsEqual(srcNulls, dstNulls);
<span class="line-new-header">--- 383,16 ---</span>
  
          comparables[0] = null;
          comparables[1] = null;
          assertTrue(comparables[0] == null &amp;&amp; comparables[1] == null, &quot;Not null ?&quot;);
  
<span class="line-modified">!         MyInt.ref[] myIntRefArray = new MyInt.ref[1];</span>
          assertTrue(myIntRefArray[0] == null, &quot;Got: &quot; + myIntRefArray[0]);
          myIntRefArray[0] = null;
  
<span class="line-modified">!         MyInt.ref[] srcNulls = new MyInt.ref[2];</span>
<span class="line-modified">!         MyInt.ref[] dstNulls = new MyInt.ref[2];</span>
          System.arraycopy(srcNulls, 0, dstNulls, 0, 2);
          checkArrayElementsEqual(srcNulls, dstNulls);
          srcNulls[1] = MyInt.create(1);
          System.arraycopy(srcNulls, 0, dstNulls, 0, 2);
          checkArrayElementsEqual(srcNulls, dstNulls);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 430,11 ***</span>
          try {
              System.arraycopy(objArray, 0, valArray, 0, 3);
              throw new RuntimeException(&quot;Expected ArrayStoreException&quot;);
          } catch (ArrayStoreException ase) {}
  
<span class="line-modified">!         MyInt?[] myIntRefArray = new MyInt?[3];</span>
          System.arraycopy(valArray, 0, myIntRefArray, 0, 3);
          checkArrayElementsEqual(valArray, myIntRefArray);
  
          myIntRefArray[0] = null;
          try {
<span class="line-new-header">--- 430,11 ---</span>
          try {
              System.arraycopy(objArray, 0, valArray, 0, 3);
              throw new RuntimeException(&quot;Expected ArrayStoreException&quot;);
          } catch (ArrayStoreException ase) {}
  
<span class="line-modified">!         MyInt.ref[] myIntRefArray = new MyInt.ref[3];</span>
          System.arraycopy(valArray, 0, myIntRefArray, 0, 3);
          checkArrayElementsEqual(valArray, myIntRefArray);
  
          myIntRefArray[0] = null;
          try {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 463,11 ***</span>
              return new MyPoint(x, x);
          }
          static MyPoint create(int x, int y) {
              return new MyPoint(x, y);
          }
<span class="line-modified">!         static final MyPoint? ORIGIN = create(0);</span>
      }
  
      void testComposition() {
          // Test array operations with compostion of inline types, check element payload is correct...
          MyPoint a = MyPoint.create(1, 2);
<span class="line-new-header">--- 463,11 ---</span>
              return new MyPoint(x, x);
          }
          static MyPoint create(int x, int y) {
              return new MyPoint(x, y);
          }
<span class="line-modified">!         static final MyPoint.ref ORIGIN = create(0);</span>
      }
  
      void testComposition() {
          // Test array operations with compostion of inline types, check element payload is correct...
          MyPoint a = MyPoint.create(1, 2);
</pre>
<center><a href="UninitializedValueFieldsTest.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ValueTypeCreation.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
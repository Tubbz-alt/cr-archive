<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Utils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.toolkit.util;
  27 
  28 import java.lang.annotation.Documented;
  29 import java.lang.ref.SoftReference;
  30 import java.net.URI;
  31 import java.text.CollationKey;
  32 import java.text.Collator;
  33 import java.text.ParseException;
  34 import java.text.RuleBasedCollator;
  35 import java.util.ArrayDeque;
  36 import java.util.ArrayList;
  37 import java.util.Arrays;
  38 import java.util.Collection;
  39 import java.util.Collections;
  40 import java.util.Deque;
  41 import java.util.EnumSet;
  42 import java.util.HashMap;
  43 import java.util.HashSet;
  44 import java.util.Iterator;
  45 import java.util.LinkedHashMap;
  46 import java.util.LinkedHashSet;
  47 import java.util.List;
  48 import java.util.Locale;
  49 import java.util.Map;
  50 import java.util.Map.Entry;
  51 import java.util.Objects;
  52 import java.util.Set;
  53 import java.util.SortedSet;
  54 import java.util.TreeMap;
  55 import java.util.TreeSet;
  56 import java.util.function.Predicate;
  57 import java.util.stream.Collectors;
  58 
  59 import javax.lang.model.SourceVersion;
  60 import javax.lang.model.element.AnnotationMirror;
  61 import javax.lang.model.element.AnnotationValue;
  62 import javax.lang.model.element.Element;
  63 import javax.lang.model.element.ElementKind;
  64 import javax.lang.model.element.ExecutableElement;
  65 import javax.lang.model.element.Modifier;
  66 import javax.lang.model.element.ModuleElement;
  67 import javax.lang.model.element.ModuleElement.RequiresDirective;
  68 import javax.lang.model.element.PackageElement;
  69 import javax.lang.model.element.RecordComponentElement;
  70 import javax.lang.model.element.TypeElement;
  71 import javax.lang.model.element.TypeParameterElement;
  72 import javax.lang.model.element.VariableElement;
  73 import javax.lang.model.type.ArrayType;
  74 import javax.lang.model.type.DeclaredType;
  75 import javax.lang.model.type.ErrorType;
  76 import javax.lang.model.type.ExecutableType;
  77 import javax.lang.model.type.NoType;
  78 import javax.lang.model.type.PrimitiveType;
  79 import javax.lang.model.type.TypeMirror;
  80 import javax.lang.model.type.TypeVariable;
  81 import javax.lang.model.type.WildcardType;
  82 import javax.lang.model.util.ElementFilter;
  83 import javax.lang.model.util.ElementKindVisitor14;
  84 import javax.lang.model.util.Elements;
  85 import javax.lang.model.util.SimpleElementVisitor14;
  86 import javax.lang.model.util.SimpleTypeVisitor9;
  87 import javax.lang.model.util.TypeKindVisitor9;
  88 import javax.lang.model.util.Types;
  89 import javax.tools.FileObject;
  90 import javax.tools.JavaFileManager;
  91 import javax.tools.JavaFileManager.Location;
  92 import javax.tools.StandardLocation;
  93 
  94 import com.sun.source.doctree.DocCommentTree;
  95 import com.sun.source.doctree.DocTree;
  96 import com.sun.source.doctree.DocTree.Kind;
  97 import com.sun.source.doctree.EndElementTree;
  98 import com.sun.source.doctree.ParamTree;
  99 import com.sun.source.doctree.StartElementTree;
 100 import com.sun.source.doctree.TextTree;
 101 import com.sun.source.doctree.UnknownBlockTagTree;
 102 import com.sun.source.tree.CompilationUnitTree;
 103 import com.sun.source.tree.LineMap;
 104 import com.sun.source.util.DocSourcePositions;
 105 import com.sun.source.util.DocTrees;
 106 import com.sun.source.util.TreePath;
 107 import com.sun.tools.javac.model.JavacTypes;
 108 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
 109 import jdk.javadoc.internal.doclets.toolkit.BaseOptions;
 110 import jdk.javadoc.internal.doclets.toolkit.CommentUtils.DocCommentInfo;
 111 import jdk.javadoc.internal.doclets.toolkit.Resources;
 112 import jdk.javadoc.internal.doclets.toolkit.WorkArounds;
 113 import jdk.javadoc.internal.doclets.toolkit.taglets.BaseTaglet;
 114 import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet;
 115 import jdk.javadoc.internal.tool.DocEnvImpl;
 116 
 117 import static javax.lang.model.element.ElementKind.*;
 118 import static javax.lang.model.element.Modifier.*;
 119 import static javax.lang.model.type.TypeKind.*;
 120 
 121 import static com.sun.source.doctree.DocTree.Kind.*;
 122 import static jdk.javadoc.internal.doclets.toolkit.builders.ConstantsSummaryBuilder.MAX_CONSTANT_VALUE_INDEX_LENGTH;
 123 
 124 /**
 125  * Utilities Class for Doclets.
 126  *
 127  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 128  *  If you write code that depends on this, you do so at your own risk.
 129  *  This code and its internal interfaces are subject to change or
 130  *  deletion without notice.&lt;/b&gt;
 131  */
 132 public class Utils {
 133     public final BaseConfiguration configuration;
 134     private final BaseOptions options;
 135     private final Resources resources;
 136     public final DocTrees docTrees;
 137     public final Elements elementUtils;
 138     public final Types typeUtils;
 139     public final Comparators comparators;
 140     private final JavaScriptScanner javaScriptScanner;
 141 
 142     public Utils(BaseConfiguration c) {
 143         configuration = c;
 144         options = configuration.getOptions();
 145         resources = configuration.getDocResources();
 146         elementUtils = c.docEnv.getElementUtils();
 147         typeUtils = c.docEnv.getTypeUtils();
 148         docTrees = c.docEnv.getDocTrees();
 149         javaScriptScanner = c.isAllowScriptInComments() ? null : new JavaScriptScanner();
 150         comparators = new Comparators(this);
 151     }
 152 
 153     // our own little symbol table
 154     private HashMap&lt;String, TypeMirror&gt; symtab = new HashMap&lt;&gt;();
 155 
 156     public TypeMirror getSymbol(String signature) {
 157         TypeMirror type = symtab.get(signature);
 158         if (type == null) {
 159             TypeElement typeElement = elementUtils.getTypeElement(signature);
 160             if (typeElement == null)
 161                 return null;
 162             type = typeElement.asType();
 163             if (type == null)
 164                 return null;
 165             symtab.put(signature, type);
 166         }
 167         return type;
 168     }
 169 
 170     public TypeMirror getObjectType() {
 171         return getSymbol(&quot;java.lang.Object&quot;);
 172     }
 173 
 174     public TypeMirror getExceptionType() {
 175         return getSymbol(&quot;java.lang.Exception&quot;);
 176     }
 177 
 178     public TypeMirror getErrorType() {
 179         return getSymbol(&quot;java.lang.Error&quot;);
 180     }
 181 
 182     public TypeMirror getSerializableType() {
 183         return getSymbol(&quot;java.io.Serializable&quot;);
 184     }
 185 
 186     public TypeMirror getExternalizableType() {
 187         return getSymbol(&quot;java.io.Externalizable&quot;);
 188     }
 189 
 190     public TypeMirror getIllegalArgumentExceptionType() {
 191         return getSymbol(&quot;java.lang.IllegalArgumentException&quot;);
 192     }
 193 
 194     public TypeMirror getNullPointerExceptionType() {
 195         return getSymbol(&quot;java.lang.NullPointerException&quot;);
 196     }
 197 
 198     public TypeMirror getDeprecatedType() {
 199         return getSymbol(&quot;java.lang.Deprecated&quot;);
 200     }
 201 
 202     public TypeMirror getFunctionalInterface() {
 203         return getSymbol(&quot;java.lang.FunctionalInterface&quot;);
 204     }
 205 
 206     /**
 207      * Return array of class members whose documentation is to be generated.
 208      * If the member is deprecated do not include such a member in the
 209      * returned array.
 210      *
 211      * @param  members    Array of members to choose from.
 212      * @return List       List of eligible members for whom
 213      *                    documentation is getting generated.
 214      */
 215     public List&lt;Element&gt; excludeDeprecatedMembers(List&lt;? extends Element&gt; members) {
 216         return members.stream()
 217                       .filter(member -&gt; !isDeprecated(member))
 218                       .sorted(comparators.makeGeneralPurposeComparator())
 219                       .collect(Collectors.toCollection(ArrayList::new));
 220     }
 221 
 222     /**
 223      * Search for the given method in the given class.
 224      *
 225      * @param  te        Class to search into.
 226      * @param  method    Method to be searched.
 227      * @return ExecutableElement Method found, null otherwise.
 228      */
 229     public ExecutableElement findMethod(TypeElement te, ExecutableElement method) {
 230         for (Element m : getMethods(te)) {
 231             if (executableMembersEqual(method, (ExecutableElement) m)) {
 232                 return (ExecutableElement) m;
 233             }
 234         }
 235         return null;
 236     }
 237 
 238     /**
 239      * Test whether a class is a subclass of another class.
 240      *
 241      * @param t1 the candidate superclass.
 242      * @param t2 the target
 243      * @return true if t1 is a superclass of t2.
 244      */
 245     public boolean isSubclassOf(TypeElement t1, TypeElement t2) {
 246         return typeUtils.isSubtype(typeUtils.erasure(t1.asType()), typeUtils.erasure(t2.asType()));
 247     }
 248 
 249     /**
 250      * @param e1 the first method to compare.
 251      * @param e2 the second method to compare.
 252      * @return true if member1 overrides/hides or is overridden/hidden by member2.
 253      */
 254     public boolean executableMembersEqual(ExecutableElement e1, ExecutableElement e2) {
 255         // TODO: investigate if Elements.hides(..) will work here.
 256         if (isStatic(e1) &amp;&amp; isStatic(e2)) {
 257             List&lt;? extends VariableElement&gt; parameters1 = e1.getParameters();
 258             List&lt;? extends VariableElement&gt; parameters2 = e2.getParameters();
 259             if (e1.getSimpleName().equals(e2.getSimpleName()) &amp;&amp;
 260                     parameters1.size() == parameters2.size()) {
 261                 int j;
 262                 for (j = 0 ; j &lt; parameters1.size(); j++) {
 263                     VariableElement v1 = parameters1.get(j);
 264                     VariableElement v2 = parameters2.get(j);
 265                     String t1 = getTypeName(v1.asType(), true);
 266                     String t2 = getTypeName(v2.asType(), true);
 267                     if (!(t1.equals(t2) ||
 268                             isTypeVariable(v1.asType()) || isTypeVariable(v2.asType()))) {
 269                         break;
 270                     }
 271                 }
 272                 if (j == parameters1.size()) {
 273                     return true;
 274                 }
 275             }
 276             return false;
 277         } else {
 278             return elementUtils.overrides(e1, e2, getEnclosingTypeElement(e1)) ||
 279                     elementUtils.overrides(e2, e1, getEnclosingTypeElement(e2)) ||
 280                     e1.equals(e2);
 281         }
 282     }
 283 
 284     /**
 285      * According to
 286      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
 287      * all the outer classes and static inner classes are core classes.
 288      */
 289     public boolean isCoreClass(TypeElement e) {
 290         return getEnclosingTypeElement(e) == null || isStatic(e);
 291     }
 292 
 293     public Location getLocationForPackage(PackageElement pd) {
 294         ModuleElement mdle = configuration.docEnv.getElementUtils().getModuleOf(pd);
 295 
 296         if (mdle == null)
 297             return defaultLocation();
 298 
 299         return getLocationForModule(mdle);
 300     }
 301 
 302     public Location getLocationForModule(ModuleElement mdle) {
 303         Location loc = configuration.workArounds.getLocationForModule(mdle);
 304         if (loc != null)
 305             return loc;
 306 
 307         return defaultLocation();
 308     }
 309 
 310     private Location defaultLocation() {
 311         JavaFileManager fm = configuration.docEnv.getJavaFileManager();
 312         return fm.hasLocation(StandardLocation.SOURCE_PATH)
 313                 ? StandardLocation.SOURCE_PATH
 314                 : StandardLocation.CLASS_PATH;
 315     }
 316 
 317     public boolean isAnnotated(TypeMirror e) {
 318         return !e.getAnnotationMirrors().isEmpty();
 319     }
 320 
 321     public boolean isAnnotated(Element e) {
 322         return !e.getAnnotationMirrors().isEmpty();
 323     }
 324 
 325     @SuppressWarnings(&quot;preview&quot;)
 326     public boolean isAnnotationType(Element e) {
 327         return new SimpleElementVisitor14&lt;Boolean, Void&gt;() {
 328             @Override
 329             public Boolean visitExecutable(ExecutableElement e, Void p) {
 330                 return visit(e.getEnclosingElement());
 331             }
 332 
 333             @Override
 334             public Boolean visitUnknown(Element e, Void p) {
 335                 return false;
 336             }
 337 
 338             @Override
 339             protected Boolean defaultAction(Element e, Void p) {
 340                 return e.getKind() == ANNOTATION_TYPE;
 341             }
 342         }.visit(e);
 343     }
 344 
 345     /**
 346      * An Enum implementation is almost identical, thus this method returns if
 347      * this element represents a CLASS or an ENUM
 348      * @param e element
 349      * @return true if class or enum
 350      */
 351     public boolean isClass(Element e) {
 352         return e.getKind().isClass();
 353     }
 354 
 355     public boolean isConstructor(Element e) {
 356          return e.getKind() == CONSTRUCTOR;
 357     }
 358 
 359     public boolean isEnum(Element e) {
 360         return e.getKind() == ENUM;
 361     }
 362 
 363     boolean isEnumConstant(Element e) {
 364         return e.getKind() == ENUM_CONSTANT;
 365     }
 366 
 367     public boolean isField(Element e) {
 368         return e.getKind() == FIELD;
 369     }
 370 
 371     public boolean isInterface(Element e) {
 372         return e.getKind() == INTERFACE;
 373     }
 374 
 375     public boolean isMethod(Element e) {
 376         return e.getKind() == METHOD;
 377     }
 378 
 379     public boolean isModule(Element e) {
 380         return e.getKind() == ElementKind.MODULE;
 381     }
 382 
 383     public boolean isPackage(Element e) {
 384         return e.getKind() == ElementKind.PACKAGE;
 385     }
 386 
 387     public boolean isAbstract(Element e) {
 388         return e.getModifiers().contains(Modifier.ABSTRACT);
 389     }
 390 
 391     public boolean isDefault(Element e) {
 392         return e.getModifiers().contains(Modifier.DEFAULT);
 393     }
 394 
 395     public boolean isPackagePrivate(Element e) {
 396         return !(isPublic(e) || isPrivate(e) || isProtected(e));
 397     }
 398 
 399     public boolean isPrivate(Element e) {
 400         return e.getModifiers().contains(Modifier.PRIVATE);
 401     }
 402 
 403     public boolean isProtected(Element e) {
 404         return e.getModifiers().contains(Modifier.PROTECTED);
 405     }
 406 
 407     public boolean isPublic(Element e) {
 408         return e.getModifiers().contains(Modifier.PUBLIC);
 409     }
 410 
 411     public boolean isProperty(String name) {
 412         return options.javafx() &amp;&amp; name.endsWith(&quot;Property&quot;);
 413     }
 414 
 415     public String getPropertyName(String name) {
 416         return isProperty(name)
 417                 ? name.substring(0, name.length() - &quot;Property&quot;.length())
 418                 : name;
 419     }
 420 
 421     public String getPropertyLabel(String name) {
 422         return name.substring(0, name.lastIndexOf(&quot;Property&quot;));
 423     }
 424 
 425     public boolean isOverviewElement(Element e) {
 426         return e.getKind() == ElementKind.OTHER;
 427     }
 428 
 429     public boolean isStatic(Element e) {
 430         return e.getModifiers().contains(Modifier.STATIC);
 431     }
 432 
 433     public boolean isSerializable(TypeElement e) {
 434         return typeUtils.isSubtype(e.asType(), getSerializableType());
 435     }
 436 
 437     public boolean isExternalizable(TypeElement e) {
 438         return typeUtils.isSubtype(e.asType(), getExternalizableType());
 439     }
 440 
 441     @SuppressWarnings(&quot;preview&quot;)
 442     public boolean isRecord(TypeElement e) {
 443         return e.getKind() == ElementKind.RECORD;
 444     }
 445 
 446     @SuppressWarnings(&quot;preview&quot;)
 447     public boolean isCanonicalRecordConstructor(ExecutableElement ee) {
 448         TypeElement te = (TypeElement) ee.getEnclosingElement();
 449         List&lt;? extends RecordComponentElement&gt; stateComps = te.getRecordComponents();
 450         List&lt;? extends VariableElement&gt; params = ee.getParameters();
 451         if (stateComps.size() != params.size()) {
 452             return false;
 453         }
 454 
 455         Iterator&lt;? extends RecordComponentElement&gt; stateIter = stateComps.iterator();
 456         Iterator&lt;? extends VariableElement&gt; paramIter = params.iterator();
 457         while (paramIter.hasNext() &amp;&amp; stateIter.hasNext()) {
 458             VariableElement param = paramIter.next();
 459             RecordComponentElement comp = stateIter.next();
 460             if (!Objects.equals(param.getSimpleName(), comp.getSimpleName())
 461                     || !typeUtils.isSameType(param.asType(), comp.asType())) {
 462                 return false;
 463             }
 464         }
 465 
 466         return true;
 467     }
 468 
 469     public SortedSet&lt;VariableElement&gt; serializableFields(TypeElement aclass) {
 470         return configuration.workArounds.getSerializableFields(aclass);
 471     }
 472 
 473     public SortedSet&lt;ExecutableElement&gt; serializationMethods(TypeElement aclass) {
 474         return configuration.workArounds.getSerializationMethods(aclass);
 475     }
 476 
 477     public boolean definesSerializableFields(TypeElement aclass) {
 478         return configuration.workArounds.definesSerializableFields( aclass);
 479     }
 480 
 481     @SuppressWarnings(&quot;preview&quot;)
 482     public String modifiersToString(Element e, boolean trailingSpace) {
 483         SortedSet&lt;Modifier&gt; modifiers = new TreeSet&lt;&gt;(e.getModifiers());
 484         modifiers.remove(NATIVE);
 485         modifiers.remove(STRICTFP);
 486         modifiers.remove(SYNCHRONIZED);
 487 
 488         return new ElementKindVisitor14&lt;String, SortedSet&lt;Modifier&gt;&gt;() {
 489             final StringBuilder sb = new StringBuilder();
 490 
 491             void addVisibilityModifier(Set&lt;Modifier&gt; modifiers) {
 492                 if (modifiers.contains(PUBLIC)) {
 493                     append(&quot;public&quot;);
 494                 } else if (modifiers.contains(PROTECTED)) {
 495                     append(&quot;protected&quot;);
 496                 } else if (modifiers.contains(PRIVATE)) {
 497                     append(&quot;private&quot;);
 498                 }
 499             }
 500 
 501             void addStatic(Set&lt;Modifier&gt; modifiers) {
 502                 if (modifiers.contains(STATIC)) {
 503                     append(&quot;static&quot;);
 504                 }
 505             }
 506 
 507             void addSealed(TypeElement e) {
 508                 if (e.getModifiers().contains(Modifier.SEALED)) {
 509                     append(&quot;sealed&quot;);
 510                 } else if (e.getModifiers().contains(Modifier.NON_SEALED)) {
 511                     append(&quot;non-sealed&quot;);
 512                 }
 513             }
 514 
 515             void addModifiers(Set&lt;Modifier&gt; modifiers) {
 516                 modifiers.stream()
 517                         .map(Modifier::toString)
 518                         .forEachOrdered(this::append);
 519             }
 520 
 521             void append(String s) {
 522                 if (sb.length() &gt; 0) {
 523                     sb.append(&quot; &quot;);
 524                 }
 525                 sb.append(s);
 526             }
 527 
 528             String finalString(String s) {
 529                 append(s);
 530                 if (trailingSpace) {
 531                     sb.append(&quot; &quot;);
 532                 }
 533                 return sb.toString();
 534             }
 535 
 536             @Override
 537             public String visitTypeAsInterface(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 538                 addVisibilityModifier(mods);
 539                 addStatic(mods);
 540                 addSealed(e);
 541                 return finalString(&quot;interface&quot;);
 542             }
 543 
 544             @Override
 545             public String visitTypeAsEnum(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 546                 addVisibilityModifier(mods);
 547                 addStatic(mods);
 548                 return finalString(&quot;enum&quot;);
 549             }
 550 
 551             @Override
 552             public String visitTypeAsAnnotationType(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 553                 addVisibilityModifier(mods);
 554                 addStatic(mods);
 555                 return finalString(&quot;@interface&quot;);
 556             }
 557 
 558             @Override
 559             public String visitTypeAsRecord(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 560                 mods.remove(FINAL); // suppress the implicit `final`
 561                 return visitTypeAsClass(e, mods);
 562             }
 563 
 564             @Override
 565             @SuppressWarnings(&quot;preview&quot;)
 566             public String visitTypeAsClass(TypeElement e, SortedSet&lt;Modifier&gt; mods) {
 567                 addModifiers(mods);
 568                 String keyword = e.getKind() == ElementKind.RECORD ? &quot;record&quot; : &quot;class&quot;;
 569                 return finalString(keyword);
 570             }
 571 
 572             @Override
 573             protected String defaultAction(Element e, SortedSet&lt;Modifier&gt; mods) {
 574                 addModifiers(mods);
 575                 return sb.toString().trim();
 576             }
 577 
 578         }.visit(e, modifiers);
 579     }
 580 
 581     public boolean isFunctionalInterface(AnnotationMirror amirror) {
 582         return amirror.getAnnotationType().equals(getFunctionalInterface()) &amp;&amp;
 583                 configuration.docEnv.getSourceVersion()
 584                         .compareTo(SourceVersion.RELEASE_8) &gt;= 0;
 585     }
 586 
 587     public boolean isNoType(TypeMirror t) {
 588         return t.getKind() == NONE;
 589     }
 590 
 591     public boolean isOrdinaryClass(TypeElement te) {
 592         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
 593             return false;
 594         }
 595         if (isError(te) || isException(te)) {
 596             return false;
 597         }
 598         return true;
 599     }
 600 
 601     public boolean isUndocumentedEnclosure(TypeElement enclosingTypeElement) {
 602         return (isPackagePrivate(enclosingTypeElement) || isPrivate(enclosingTypeElement))
 603                 &amp;&amp; !isLinkable(enclosingTypeElement);
 604     }
 605 
 606     public boolean isError(TypeElement te) {
 607         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
 608             return false;
 609         }
 610         return typeUtils.isSubtype(te.asType(), getErrorType());
 611     }
 612 
 613     public boolean isException(TypeElement te) {
 614         if (isEnum(te) || isInterface(te) || isAnnotationType(te)) {
 615             return false;
 616         }
 617         return typeUtils.isSubtype(te.asType(), getExceptionType());
 618     }
 619 
 620     public boolean isPrimitive(TypeMirror t) {
 621         return new SimpleTypeVisitor9&lt;Boolean, Void&gt;() {
 622 
 623             @Override
 624             public Boolean visitNoType(NoType t, Void p) {
 625                 return t.getKind() == VOID;
 626             }
 627             @Override
 628             public Boolean visitPrimitive(PrimitiveType t, Void p) {
 629                 return true;
 630             }
 631             @Override
 632             public Boolean visitArray(ArrayType t, Void p) {
 633                 return visit(t.getComponentType());
 634             }
 635             @Override
 636             protected Boolean defaultAction(TypeMirror e, Void p) {
 637                 return false;
 638             }
 639         }.visit(t);
 640     }
 641 
 642     public boolean isExecutableElement(Element e) {
 643         ElementKind kind = e.getKind();
 644         switch (kind) {
 645             case CONSTRUCTOR: case METHOD: case INSTANCE_INIT:
 646                 return true;
 647             default:
 648                 return false;
 649         }
 650     }
 651 
 652     public boolean isVariableElement(Element e) {
 653         ElementKind kind = e.getKind();
 654         switch(kind) {
 655               case ENUM_CONSTANT: case EXCEPTION_PARAMETER: case FIELD:
 656               case LOCAL_VARIABLE: case PARAMETER:
 657               case RESOURCE_VARIABLE:
 658                   return true;
 659               default:
 660                   return false;
 661         }
 662     }
 663 
 664     public boolean isTypeElement(Element e) {
 665         switch (e.getKind()) {
 666             case CLASS: case ENUM: case INTERFACE: case ANNOTATION_TYPE: case RECORD:
 667                 return true;
 668             default:
 669                 return false;
 670         }
 671     }
 672 
 673     /**
 674      * Get the signature of an executable element with qualified parameter types
 675      * in the context of type element {@code site}.
 676      * For instance, for a method {@code mymethod(String x, int y)},
 677      * it will return {@code (java.lang.String,int)}.
 678      *
 679      * @param e the executable element
 680      * @param site the contextual site
 681      * @return String signature with qualified parameter types
 682      */
 683     public String signature(ExecutableElement e, TypeElement site) {
 684         return makeSignature(e, site, true);
 685     }
 686 
 687     /**
 688      * Get the flat signature of an executable element with simple (unqualified)
 689      * parameter types in the context of type element {@code site}.
 690      * For instance, for a method {@code mymethod(String x, int y)},
 691      * it will return {@code (String, int)}.
 692      *
 693      * @param e the executable element
 694      * @param site the contextual site
 695      * @return String signature with simple (unqualified) parameter types
 696      */
 697     public String flatSignature(ExecutableElement e, TypeElement site) {
 698         return makeSignature(e, site, false);
 699     }
 700 
 701     public String makeSignature(ExecutableElement e, TypeElement site, boolean full) {
 702         return makeSignature(e, site, full, false);
 703     }
 704 
 705     public String makeSignature(ExecutableElement e, TypeElement site, boolean full, boolean ignoreTypeParameters) {
 706         StringBuilder result = new StringBuilder();
 707         result.append(&quot;(&quot;);
 708         ExecutableType executableType = asInstantiatedMethodType(site, e);
 709         Iterator&lt;? extends TypeMirror&gt; iterator = executableType.getParameterTypes().iterator();
 710         while (iterator.hasNext()) {
 711             TypeMirror type = iterator.next();
 712             result.append(getTypeSignature(type, full, ignoreTypeParameters));
 713             if (iterator.hasNext()) {
 714                 result.append(&quot;, &quot;);
 715             }
 716         }
 717         if (e.isVarArgs()) {
 718             int len = result.length();
 719             result.replace(len - 2, len, &quot;...&quot;);
 720         }
 721         result.append(&quot;)&quot;);
 722         return result.toString();
 723     }
 724 
 725     public String getTypeSignature(TypeMirror t, boolean qualifiedName, boolean noTypeParameters) {
 726         return new SimpleTypeVisitor9&lt;StringBuilder, Void&gt;() {
 727             final StringBuilder sb = new StringBuilder();
 728 
 729             @Override
 730             public StringBuilder visitArray(ArrayType t, Void p) {
 731                 TypeMirror componentType = t.getComponentType();
 732                 visit(componentType);
 733                 sb.append(&quot;[]&quot;);
 734                 return sb;
 735             }
 736 
 737             @Override
 738             public StringBuilder visitDeclared(DeclaredType t, Void p) {
 739                 Element e = t.asElement();
 740                 sb.append(qualifiedName ? getFullyQualifiedName(e) : getSimpleName(e));
 741                 List&lt;? extends TypeMirror&gt; typeArguments = t.getTypeArguments();
 742                 if (typeArguments.isEmpty() || noTypeParameters) {
 743                     return sb;
 744                 }
 745                 sb.append(&quot;&lt;&quot;);
 746                 Iterator&lt;? extends TypeMirror&gt; iterator = typeArguments.iterator();
 747                 while (iterator.hasNext()) {
 748                     TypeMirror ta = iterator.next();
 749                     visit(ta);
 750                     if (iterator.hasNext()) {
 751                         sb.append(&quot;, &quot;);
 752                     }
 753                 }
 754                 sb.append(&quot;&gt;&quot;);
 755                 return sb;
 756             }
 757 
 758             @Override
 759             public StringBuilder visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {
 760                 Element e = t.asElement();
 761                 sb.append(qualifiedName ? getFullyQualifiedName(e, false) : getSimpleName(e));
 762                 return sb;
 763             }
 764 
 765             @Override
 766             public StringBuilder visitWildcard(javax.lang.model.type.WildcardType t, Void p) {
 767                 sb.append(&quot;?&quot;);
 768                 TypeMirror upperBound = t.getExtendsBound();
 769                 if (upperBound != null) {
 770                     sb.append(&quot; extends &quot;);
 771                     visit(upperBound);
 772                 }
 773                 TypeMirror superBound = t.getSuperBound();
 774                 if (superBound != null) {
 775                     sb.append(&quot; super &quot;);
 776                     visit(superBound);
 777                 }
 778                 return sb;
 779             }
 780 
 781             @Override
 782             protected StringBuilder defaultAction(TypeMirror e, Void p) {
 783                 return sb.append(e);
 784             }
 785         }.visit(t).toString();
 786     }
 787 
 788     public boolean isArrayType(TypeMirror t) {
 789         return t.getKind() == ARRAY;
 790     }
 791 
 792     public boolean isDeclaredType(TypeMirror t) {
 793         return t.getKind() == DECLARED;
 794     }
 795 
 796     public boolean isErrorType(TypeMirror t) {
 797         return t.getKind() == ERROR;
 798     }
 799 
 800     public boolean isIntersectionType(TypeMirror t) {
 801         return t.getKind() == INTERSECTION;
 802     }
 803 
 804     public boolean isTypeParameterElement(Element e) {
 805         return e.getKind() == TYPE_PARAMETER;
 806     }
 807 
 808     public boolean isTypeVariable(TypeMirror t) {
 809         return t.getKind() == TYPEVAR;
 810     }
 811 
 812     public boolean isVoid(TypeMirror t) {
 813         return t.getKind() == VOID;
 814     }
 815 
 816     public boolean isWildCard(TypeMirror t) {
 817         return t.getKind() == WILDCARD;
 818     }
 819 
 820     public boolean ignoreBounds(TypeMirror bound) {
 821         return bound.equals(getObjectType()) &amp;&amp; !isAnnotated(bound);
 822     }
 823 
 824     /*
 825      * a direct port of TypeVariable.getBounds
 826      */
 827     public List&lt;? extends TypeMirror&gt; getBounds(TypeParameterElement tpe) {
 828         List&lt;? extends TypeMirror&gt; bounds = tpe.getBounds();
 829         if (!bounds.isEmpty()) {
 830             TypeMirror upperBound = bounds.get(bounds.size() - 1);
 831             if (ignoreBounds(upperBound)) {
 832                 return Collections.emptyList();
 833             }
 834         }
 835         return bounds;
 836     }
 837 
 838     /**
 839      * Returns the TypeMirror of the ExecutableElement if it is a method, or null
 840      * if it is a constructor.
 841      * @param site the contextual type
 842      * @param ee the ExecutableElement
 843      * @return the return type
 844      */
 845     public TypeMirror getReturnType(TypeElement site, ExecutableElement ee) {
 846         return ee.getKind() == CONSTRUCTOR ? null : asInstantiatedMethodType(site, ee).getReturnType();
 847     }
 848 
 849     /**
 850      * Returns the ExecutableType corresponding to the type of the method declaration seen as a
 851      * member of a given declared type. This might cause type-variable substitution to kick in.
 852      * @param site the contextual type.
 853      * @param ee the method declaration.
 854      * @return the instantiated method type.
 855      */
 856     public ExecutableType asInstantiatedMethodType(TypeElement site, ExecutableElement ee) {
 857         return shouldInstantiate(site, ee) ?
 858                 (ExecutableType)typeUtils.asMemberOf((DeclaredType)site.asType(), ee) :
 859                 (ExecutableType)ee.asType();
 860     }
 861 
 862     /**
 863      * Returns the TypeMirror corresponding to the type of the field declaration seen as a
 864      * member of a given declared type. This might cause type-variable substitution to kick in.
 865      * @param site the contextual type.
 866      * @param ve the field declaration.
 867      * @return the instantiated field type.
 868      */
 869     public TypeMirror asInstantiatedFieldType(TypeElement site, VariableElement ve) {
 870         return shouldInstantiate(site, ve) ?
 871                 typeUtils.asMemberOf((DeclaredType)site.asType(), ve) :
 872                 ve.asType();
 873     }
 874 
 875     /*
 876      * We should not instantiate if (i) there&#39;s no contextual type declaration, (ii) the declaration
 877      * to which the member belongs to is the same as the one under consideration, (iii) if the
 878      * delcaration to which the member belongs to is not generic.
 879      */
 880     private boolean shouldInstantiate(TypeElement site, Element e) {
 881         return site != null &amp;&amp;
 882                 site != e.getEnclosingElement() &amp;&amp;
 883                !((DeclaredType)e.getEnclosingElement().asType()).getTypeArguments().isEmpty();
 884     }
 885 
 886     /**
 887      * Return the type containing the method that this method overrides.
 888      * It may be a {@code TypeElement} or a {@code TypeParameterElement}.
 889      */
 890     public TypeMirror overriddenType(ExecutableElement method) {
 891         return configuration.workArounds.overriddenType(method);
 892     }
 893 
 894     private  TypeMirror getType(TypeMirror t) {
 895         return (isNoType(t)) ? getObjectType() : t;
 896     }
 897 
 898     public TypeMirror getSuperType(TypeElement te) {
 899         TypeMirror t = te.getSuperclass();
 900         return getType(t);
 901     }
 902 
 903     /**
 904      * Return the class that originally defined the method that
 905      * is overridden by the current definition, or null if no
 906      * such class exists.
 907      *
 908      * @return a TypeElement representing the superclass that
 909      * originally defined this method, null if this method does
 910      * not override a definition in a superclass.
 911      */
 912     public TypeElement overriddenClass(ExecutableElement ee) {
 913         TypeMirror type = overriddenType(ee);
 914         return (type != null) ? asTypeElement(type) : null;
 915     }
 916 
 917     public ExecutableElement overriddenMethod(ExecutableElement method) {
 918         if (isStatic(method)) {
 919             return null;
 920         }
 921         final TypeElement origin = getEnclosingTypeElement(method);
 922         for (TypeMirror t = getSuperType(origin);
 923                 t.getKind() == DECLARED;
 924                 t = getSuperType(asTypeElement(t))) {
 925             TypeElement te = asTypeElement(t);
 926             if (te == null) {
 927                 return null;
 928             }
 929             VisibleMemberTable vmt = configuration.getVisibleMemberTable(te);
 930             for (Element e : vmt.getMembers(VisibleMemberTable.Kind.METHODS)) {
 931                 ExecutableElement ee = (ExecutableElement)e;
 932                 if (configuration.workArounds.overrides(method, ee, origin) &amp;&amp;
 933                         !isSimpleOverride(ee)) {
 934                     return ee;
 935                 }
 936             }
 937             if (t.equals(getObjectType()))
 938                 return null;
 939         }
 940         return null;
 941     }
 942 
 943     public SortedSet&lt;TypeElement&gt; getTypeElementsAsSortedSet(Iterable&lt;TypeElement&gt; typeElements) {
 944         SortedSet&lt;TypeElement&gt; set = new TreeSet&lt;&gt;(comparators.makeGeneralPurposeComparator());
 945         typeElements.forEach(set::add);
 946         return set;
 947     }
 948 
 949     public List&lt;? extends DocTree&gt; getSerialDataTrees(ExecutableElement member) {
 950         return getBlockTags(member, SERIAL_DATA);
 951     }
 952 
 953     public FileObject getFileObject(TypeElement te) {
 954         return docTrees.getPath(te).getCompilationUnit().getSourceFile();
 955     }
 956 
 957     public TypeMirror getDeclaredType(TypeElement enclosing, TypeMirror target) {
 958         return getDeclaredType(Collections.emptyList(), enclosing, target);
 959     }
 960 
 961     /**
 962      * Finds the declaration of the enclosing&#39;s type parameter.
 963      *
 964      * @param values
 965      * @param enclosing a TypeElement whose type arguments  we desire
 966      * @param target the TypeMirror of the type as described by the enclosing
 967      * @return
 968      */
 969     public TypeMirror getDeclaredType(Collection&lt;TypeMirror&gt; values,
 970                                       TypeElement enclosing, TypeMirror target) {
 971         TypeElement targetElement = asTypeElement(target);
 972         List&lt;? extends TypeParameterElement&gt; targetTypeArgs = targetElement.getTypeParameters();
 973         if (targetTypeArgs.isEmpty()) {
 974             return target;
 975         }
 976 
 977         List&lt;? extends TypeParameterElement&gt; enclosingTypeArgs = enclosing.getTypeParameters();
 978         List&lt;TypeMirror&gt; targetTypeArgTypes = new ArrayList&lt;&gt;(targetTypeArgs.size());
 979 
 980         if (enclosingTypeArgs.isEmpty()) {
 981             for (TypeMirror te : values) {
 982                 List&lt;? extends TypeMirror&gt; typeArguments = ((DeclaredType)te).getTypeArguments();
 983                 if (typeArguments.size() &gt;= targetTypeArgs.size()) {
 984                     for (int i = 0 ; i &lt; targetTypeArgs.size(); i++) {
 985                         targetTypeArgTypes.add(typeArguments.get(i));
 986                     }
 987                     break;
 988                 }
 989             }
 990             // we found no matches in the hierarchy
 991             if (targetTypeArgTypes.isEmpty()) {
 992                 return target;
 993             }
 994         } else {
 995             if (targetTypeArgs.size() &gt; enclosingTypeArgs.size()) {
 996                 return target;
 997             }
 998             for (int i = 0; i &lt; targetTypeArgs.size(); i++) {
 999                 TypeParameterElement tpe = enclosingTypeArgs.get(i);
1000                 targetTypeArgTypes.add(tpe.asType());
1001             }
1002         }
1003         TypeMirror dt = typeUtils.getDeclaredType(targetElement,
1004                 targetTypeArgTypes.toArray(new TypeMirror[targetTypeArgTypes.size()]));
1005         return dt;
1006     }
1007 
1008     /**
1009      * Returns all the implemented super-interfaces of a given type,
1010      * in the case of classes, include all the super-interfaces of
1011      * the supertype. The super-interfaces are collected before the
1012      * super-interfaces of the supertype.
1013      *
1014      * @param  te the type element to get the super-interfaces for.
1015      * @return the list of super-interfaces.
1016      */
1017     public Set&lt;TypeMirror&gt; getAllInterfaces(TypeElement te) {
1018         Set&lt;TypeMirror&gt; results = new LinkedHashSet&lt;&gt;();
1019         getAllInterfaces(te.asType(), results);
1020         return results;
1021     }
1022 
1023     private void getAllInterfaces(TypeMirror type, Set&lt;TypeMirror&gt; results) {
1024         List&lt;? extends TypeMirror&gt; intfacs = typeUtils.directSupertypes(type);
1025         TypeMirror superType = null;
1026         for (TypeMirror intfac : intfacs) {
1027             if (intfac == getObjectType())
1028                 continue;
1029             TypeElement e = asTypeElement(intfac);
1030             if (isInterface(e)) {
1031                 if (isPublic(e) || isLinkable(e))
1032                     results.add(intfac);
1033 
1034                 getAllInterfaces(intfac, results);
1035             } else {
1036                 // Save the supertype for later.
1037                 superType = intfac;
1038             }
1039         }
1040         // Collect the super-interfaces of the supertype.
1041         if (superType != null)
1042             getAllInterfaces(superType, results);
1043     }
1044 
1045     /**
1046      * Lookup for a class within this package.
1047      *
1048      * @return TypeElement of found class, or null if not found.
1049      */
1050     public TypeElement findClassInPackageElement(PackageElement pkg, String className) {
1051         for (TypeElement c : getAllClasses(pkg)) {
1052             if (getSimpleName(c).equals(className)) {
1053                 return c;
1054             }
1055         }
1056         return null;
1057     }
1058 
1059     /**
1060      * TODO: FIXME: port to javax.lang.model
1061      * Find a class within the context of this class. Search order: qualified name, in this class
1062      * (inner), in this package, in the class imports, in the package imports. Return the
1063      * TypeElement if found, null if not found.
1064      */
1065     //### The specified search order is not the normal rule the
1066     //### compiler would use.  Leave as specified or change it?
1067     public TypeElement findClass(Element element, String className) {
1068         TypeElement encl = getEnclosingTypeElement(element);
1069         TypeElement searchResult = configuration.workArounds.searchClass(encl, className);
1070         if (searchResult == null) {
1071             encl = getEnclosingTypeElement(encl);
1072             //Expand search space to include enclosing class.
1073             while (encl != null &amp;&amp; getEnclosingTypeElement(encl) != null) {
1074                 encl = getEnclosingTypeElement(encl);
1075             }
1076             searchResult = encl == null
1077                     ? null
1078                     : configuration.workArounds.searchClass(encl, className);
1079         }
1080         return searchResult;
1081     }
1082 
1083     /**
1084      * Enclose in quotes, used for paths and filenames that contains spaces
1085      */
1086     public String quote(String filepath) {
1087         return (&quot;\&quot;&quot; + filepath + &quot;\&quot;&quot;);
1088     }
1089 
1090     /**
1091      * Parse the package name.  We only want to display package name up to
1092      * 2 levels.
1093      */
1094     public String parsePackageName(PackageElement p) {
1095         String pkgname = p.isUnnamed() ? &quot;&quot; : getPackageName(p);
1096         int index = -1;
1097         for (int j = 0; j &lt; MAX_CONSTANT_VALUE_INDEX_LENGTH; j++) {
1098             index = pkgname.indexOf(&quot;.&quot;, index + 1);
1099         }
1100         if (index != -1) {
1101             pkgname = pkgname.substring(0, index);
1102         }
1103         return pkgname;
1104     }
1105 
1106     /**
1107      * Given a string, replace all occurrences of &#39;newStr&#39; with &#39;oldStr&#39;.
1108      * @param originalStr the string to modify.
1109      * @param oldStr the string to replace.
1110      * @param newStr the string to insert in place of the old string.
1111      */
1112     public String replaceText(String originalStr, String oldStr,
1113             String newStr) {
1114         if (oldStr == null || newStr == null || oldStr.equals(newStr)) {
1115             return originalStr;
1116         }
1117         return originalStr.replace(oldStr, newStr);
1118     }
1119 
1120     /**
1121      * Given an annotation, return true if it should be documented and false
1122      * otherwise.
1123      *
1124      * @param annotation the annotation to check.
1125      *
1126      * @return true return true if it should be documented and false otherwise.
1127      */
1128     public boolean isDocumentedAnnotation(TypeElement annotation) {
1129         for (AnnotationMirror anno : annotation.getAnnotationMirrors()) {
1130             if (getFullyQualifiedName(anno.getAnnotationType().asElement()).equals(
1131                     Documented.class.getName())) {
1132                 return true;
1133             }
1134         }
1135         return false;
1136     }
1137 
1138     /**
1139      * Returns true if this class is linkable and false if we can&#39;t link to it.
1140      *
1141      * &lt;p&gt;
1142      * &lt;b&gt;NOTE:&lt;/b&gt;  You can only link to external classes if they are public or
1143      * protected.
1144      *
1145      * @return true if this class is linkable and false if we can&#39;t link to the
1146      * desired class.
1147      */
1148     public boolean isLinkable(TypeElement typeElem) {
1149         return
1150             (typeElem != null &amp;&amp;
1151                 (isIncluded(typeElem) &amp;&amp; configuration.isGeneratedDoc(typeElem))) ||
1152             (configuration.extern.isExternal(typeElem) &amp;&amp;
1153                 (isPublic(typeElem) || isProtected(typeElem)));
1154     }
1155 
1156     /**
1157      * Returns true if an element is linkable in the context of a given type element.
1158      *
1159      * If the element is a type element, it delegates to {@link #isLinkable(TypeElement)}.
1160      * Otherwise, the element is linkable if any of the following are true:
1161      * &lt;ul&gt;
1162      * &lt;li&gt;it is &quot;included&quot; (see {@link jdk.javadoc.doclet})
1163      * &lt;li&gt;it is inherited from an undocumented supertype
1164      * &lt;li&gt;it is a public or protected member of an external API
1165      * &lt;/ul&gt;
1166      *
1167      * @param typeElem the type element
1168      * @param elem the element
1169      * @return whether or not the element is linkable
1170      */
1171     public boolean isLinkable(TypeElement typeElem, Element elem) {
1172         if (isTypeElement(elem)) {
1173             return isLinkable((TypeElement) elem); // defer to existing behavior
1174         }
1175 
1176         if (isIncluded(elem)) {
1177             return true;
1178         }
1179 
1180         // Allow for the behavior that members of undocumented supertypes
1181         // may be included in documented types
1182         if (isUndocumentedEnclosure(getEnclosingTypeElement(elem))) {
1183             return true;
1184         }
1185 
1186         // Allow for external members
1187         return isLinkable(typeElem)
1188                     &amp;&amp; configuration.extern.isExternal(typeElem)
1189                     &amp;&amp; (isPublic(elem) || isProtected(elem));
1190     }
1191 
1192     /**
1193      * Return this type as a {@code TypeElement} if it represents a class
1194      * interface or annotation.  Array dimensions are ignored.
1195      * If this type {@code ParameterizedType} or {@code WildcardType}, return
1196      * the {@code TypeElement} of the type&#39;s erasure.  If this is an
1197      * annotation, return this as a {@code TypeElement}.
1198      * If this is a primitive type, return null.
1199      *
1200      * @return the {@code TypeElement} of this type,
1201      *         or null if it is a primitive type.
1202      */
1203     public TypeElement asTypeElement(TypeMirror t) {
1204         return new SimpleTypeVisitor9&lt;TypeElement, Void&gt;() {
1205 
1206             @Override
1207             public TypeElement visitDeclared(DeclaredType t, Void p) {
1208                 return (TypeElement) t.asElement();
1209             }
1210 
1211             @Override
1212             public TypeElement visitArray(ArrayType t, Void p) {
1213                 return visit(t.getComponentType());
1214             }
1215 
1216             @Override
1217             public TypeElement visitTypeVariable(TypeVariable t, Void p) {
1218                /* TODO, this may not be an optimal fix.
1219                 * if we have an annotated type @DA T, then erasure returns a
1220                 * none, in this case we use asElement instead.
1221                 */
1222                 if (isAnnotated(t)) {
1223                     return visit(typeUtils.asElement(t).asType());
1224                 }
1225                 return visit(typeUtils.erasure(t));
1226             }
1227 
1228             @Override
1229             public TypeElement visitWildcard(WildcardType t, Void p) {
1230                 return visit(typeUtils.erasure(t));
1231             }
1232 
1233             @Override
1234             public TypeElement visitError(ErrorType t, Void p) {
1235                 return (TypeElement)t.asElement();
1236             }
1237 
1238             @Override
1239             protected TypeElement defaultAction(TypeMirror e, Void p) {
1240                 return super.defaultAction(e, p);
1241             }
1242         }.visit(t);
1243     }
1244 
1245     public TypeMirror getComponentType(TypeMirror t) {
1246         while (isArrayType(t)) {
1247             t = ((ArrayType) t).getComponentType();
1248         }
1249         return t;
1250     }
1251 
1252     /**
1253      * Return the type&#39;s dimension information, as a string.
1254      * &lt;p&gt;
1255      * For example, a two dimensional array of String returns &quot;{@code [][]}&quot;.
1256      *
1257      * @return the type&#39;s dimension information as a string.
1258      */
1259     public String getDimension(TypeMirror t) {
1260         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
1261             StringBuilder dimension = new StringBuilder();
1262             @Override
1263             public String visitArray(ArrayType t, Void p) {
1264                 dimension.append(&quot;[]&quot;);
1265                 return visit(t.getComponentType());
1266             }
1267 
1268             @Override
1269             protected String defaultAction(TypeMirror e, Void p) {
1270                 return dimension.toString();
1271             }
1272 
1273         }.visit(t);
1274     }
1275 
1276     public TypeElement getSuperClass(TypeElement te) {
1277         if (isInterface(te) || isAnnotationType(te) ||
1278                 te.asType().equals(getObjectType())) {
1279             return null;
1280         }
1281         TypeMirror superclass = te.getSuperclass();
1282         if (isNoType(superclass) &amp;&amp; isClass(te)) {
1283             superclass = getObjectType();
1284         }
1285         return asTypeElement(superclass);
1286     }
1287 
1288     public TypeElement getFirstVisibleSuperClassAsTypeElement(TypeElement te) {
1289         if (isAnnotationType(te) || isInterface(te) ||
1290                 te.asType().equals(getObjectType())) {
1291             return null;
1292         }
1293         TypeMirror firstVisibleSuperClass = getFirstVisibleSuperClass(te);
1294         return firstVisibleSuperClass == null ? null : asTypeElement(firstVisibleSuperClass);
1295     }
1296 
1297     /**
1298      * Given a class, return the closest visible super class.
1299      * @param type the TypeMirror to be interrogated
1300      * @return  the closest visible super class.  Return null if it cannot
1301      *          be found.
1302      */
1303 
1304     public TypeMirror getFirstVisibleSuperClass(TypeMirror type) {
1305         return getFirstVisibleSuperClass(asTypeElement(type));
1306     }
1307 
1308 
1309     /**
1310      * Given a class, return the closest visible super class.
1311      *
1312      * @param te the TypeElement to be interrogated
1313      * @return the closest visible super class.  Return null if it cannot
1314      *         be found..
1315      */
1316     public TypeMirror getFirstVisibleSuperClass(TypeElement te) {
1317         TypeMirror superType = te.getSuperclass();
1318         if (isNoType(superType)) {
1319             superType = getObjectType();
1320         }
1321         TypeElement superClass = asTypeElement(superType);
1322         // skip &quot;hidden&quot; classes
1323         while ((superClass != null &amp;&amp; hasHiddenTag(superClass))
1324                 || (superClass != null &amp;&amp;  !isPublic(superClass) &amp;&amp; !isLinkable(superClass))) {
1325             TypeMirror supersuperType = superClass.getSuperclass();
1326             TypeElement supersuperClass = asTypeElement(supersuperType);
1327             if (supersuperClass == null
1328                     || supersuperClass.getQualifiedName().equals(superClass.getQualifiedName())) {
1329                 break;
1330             }
1331             superType = supersuperType;
1332             superClass = supersuperClass;
1333         }
1334         if (te.asType().equals(superType)) {
1335             return null;
1336         }
1337         return superType;
1338     }
1339 
1340     /**
1341      * Given a TypeElement, return the name of its type (Class, Interface, etc.).
1342      *
1343      * @param te the TypeElement to check.
1344      * @param lowerCaseOnly true if you want the name returned in lower case.
1345      *                      If false, the first letter of the name is capitalized.
1346      * @return
1347      */
1348     public String getTypeElementName(TypeElement te, boolean lowerCaseOnly) {
1349         String typeName = &quot;&quot;;
1350         if (isInterface(te)) {
1351             typeName = &quot;doclet.Interface&quot;;
1352         } else if (isException(te)) {
1353             typeName = &quot;doclet.Exception&quot;;
1354         } else if (isError(te)) {
1355             typeName = &quot;doclet.Error&quot;;
1356         } else if (isAnnotationType(te)) {
1357             typeName = &quot;doclet.AnnotationType&quot;;
1358         } else if (isEnum(te)) {
1359             typeName = &quot;doclet.Enum&quot;;
1360         } else if (isOrdinaryClass(te)) {
1361             typeName = &quot;doclet.Class&quot;;
1362         }
1363         typeName = lowerCaseOnly ? toLowerCase(typeName) : typeName;
1364         return typeNameMap.computeIfAbsent(typeName, resources::getText);
1365     }
1366 
1367     private final Map&lt;String, String&gt; typeNameMap = new HashMap&lt;&gt;();
1368 
1369     public String getTypeName(TypeMirror t, boolean fullyQualified) {
1370         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
1371 
1372             @Override
1373             public String visitArray(ArrayType t, Void p) {
1374                 return visit(t.getComponentType());
1375             }
1376 
1377             @Override
1378             public String visitDeclared(DeclaredType t, Void p) {
1379                 TypeElement te = asTypeElement(t);
1380                 return fullyQualified
1381                         ? te.getQualifiedName().toString()
1382                         : getSimpleName(te);
1383             }
1384 
1385             @Override
1386             public String visitExecutable(ExecutableType t, Void p) {
1387                 return t.toString();
1388             }
1389 
1390             @Override
1391             public String visitPrimitive(PrimitiveType t, Void p) {
1392                 return t.toString();
1393             }
1394 
1395             @Override
1396             public String visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {
1397                 return getSimpleName(t.asElement());
1398             }
1399 
1400             @Override
1401             public String visitWildcard(javax.lang.model.type.WildcardType t, Void p) {
1402                 return t.toString();
1403             }
1404 
1405             @Override
1406             protected String defaultAction(TypeMirror e, Void p) {
1407                 return e.toString();
1408             }
1409         }.visit(t);
1410     }
1411 
1412     /**
1413      * Replace all tabs in a string with the appropriate number of spaces.
1414      * The string may be a multi-line string.
1415      * @param text the text for which the tabs should be expanded
1416      * @return the text with all tabs expanded
1417      */
1418     public String replaceTabs(String text) {
1419         if (!text.contains(&quot;\t&quot;))
1420             return text;
1421 
1422         final int tabLength = options.sourceTabSize();
1423         final String whitespace = &quot; &quot;.repeat(tabLength);
1424         final int textLength = text.length();
1425         StringBuilder result = new StringBuilder(textLength);
1426         int pos = 0;
1427         int lineLength = 0;
1428         for (int i = 0; i &lt; textLength; i++) {
1429             char ch = text.charAt(i);
1430             switch (ch) {
1431                 case &#39;\n&#39;: case &#39;\r&#39;:
1432                     lineLength = 0;
1433                     break;
1434                 case &#39;\t&#39;:
1435                     result.append(text, pos, i);
1436                     int spaceCount = tabLength - lineLength % tabLength;
1437                     result.append(whitespace, 0, spaceCount);
1438                     lineLength += spaceCount;
1439                     pos = i + 1;
1440                     break;
1441                 default:
1442                     lineLength++;
1443             }
1444         }
1445         result.append(text, pos, textLength);
1446         return result.toString();
1447     }
1448 
1449     public CharSequence normalizeNewlines(CharSequence text) {
1450         StringBuilder sb = new StringBuilder();
1451         final int textLength = text.length();
1452         final String NL = DocletConstants.NL;
1453         int pos = 0;
1454         for (int i = 0; i &lt; textLength; i++) {
1455             char ch = text.charAt(i);
1456             switch (ch) {
1457                 case &#39;\n&#39;:
1458                     sb.append(text, pos, i);
1459                     sb.append(NL);
1460                     pos = i + 1;
1461                     break;
1462                 case &#39;\r&#39;:
1463                     sb.append(text, pos, i);
1464                     sb.append(NL);
1465                     if (i + 1 &lt; textLength &amp;&amp; text.charAt(i + 1) == &#39;\n&#39;)
1466                         i++;
1467                     pos = i + 1;
1468                     break;
1469             }
1470         }
1471         sb.append(text, pos, textLength);
1472         return sb;
1473     }
1474 
1475     /**
1476      * Returns a locale independent lower cased String. That is, it
1477      * always uses US locale, this is a clone of the one in StringUtils.
1478      * @param s to convert
1479      * @return converted String
1480      */
1481     public static String toLowerCase(String s) {
1482         return s.toLowerCase(Locale.US);
1483     }
1484 
1485     /**
1486      * Return true if the given Element is deprecated.
1487      *
1488      * @param e the Element to check.
1489      * @return true if the given Element is deprecated.
1490      */
1491     public boolean isDeprecated(Element e) {
1492         if (isPackage(e)) {
1493             return configuration.workArounds.isDeprecated0(e);
1494         }
1495         return elementUtils.isDeprecated(e);
1496     }
1497 
1498     /**
1499      * Return true if the given Element is deprecated for removal.
1500      *
1501      * @param e the Element to check.
1502      * @return true if the given Element is deprecated for removal.
1503      */
1504     public boolean isDeprecatedForRemoval(Element e) {
1505         List&lt;? extends AnnotationMirror&gt; annotationList = e.getAnnotationMirrors();
1506         JavacTypes jctypes = ((DocEnvImpl) configuration.docEnv).toolEnv.typeutils;
1507         for (AnnotationMirror anno : annotationList) {
1508             if (jctypes.isSameType(anno.getAnnotationType().asElement().asType(), getDeprecatedType())) {
1509                 Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs = anno.getElementValues();
1510                 if (!pairs.isEmpty()) {
1511                     for (ExecutableElement element : pairs.keySet()) {
1512                         if (element.getSimpleName().contentEquals(&quot;forRemoval&quot;)) {
1513                             return Boolean.parseBoolean((pairs.get(element)).toString());
1514                         }
1515                     }
1516                 }
1517             }
1518         }
1519         return false;
1520     }
1521 
1522     /**
1523      * A convenience method to get property name from the name of the
1524      * getter or setter method.
1525      * @param e the input method.
1526      * @return the name of the property of the given setter of getter.
1527      */
1528     public String propertyName(ExecutableElement e) {
1529         String name = getSimpleName(e);
1530         String propertyName = null;
1531         if (name.startsWith(&quot;get&quot;) || name.startsWith(&quot;set&quot;)) {
1532             propertyName = name.substring(3);
1533         } else if (name.startsWith(&quot;is&quot;)) {
1534             propertyName = name.substring(2);
1535         }
1536         if ((propertyName == null) || propertyName.isEmpty()){
1537             return &quot;&quot;;
1538         }
1539         return propertyName.substring(0, 1).toLowerCase(configuration.getLocale())
1540                 + propertyName.substring(1);
1541     }
1542 
1543     /**
1544      * Returns true if the element is included, contains &amp;#64;hidden tag,
1545      * or if javafx flag is present and element contains &amp;#64;treatAsPrivate
1546      * tag.
1547      * @param e the queried element
1548      * @return true if it exists, false otherwise
1549      */
1550     public boolean hasHiddenTag(Element e) {
1551         // prevent needless tests on elements which are not included
1552         if (!isIncluded(e)) {
1553             return false;
1554         }
1555         if (options.javafx() &amp;&amp;
1556                 hasBlockTag(e, DocTree.Kind.UNKNOWN_BLOCK_TAG, &quot;treatAsPrivate&quot;)) {
1557             return true;
1558         }
1559         return hasBlockTag(e, DocTree.Kind.HIDDEN);
1560     }
1561 
1562     /**
1563      * Returns true if the method has no comments, or a lone &amp;commat;inheritDoc.
1564      * @param m a method
1565      * @return true if there are no comments, false otherwise
1566      */
1567     public boolean isSimpleOverride(ExecutableElement m) {
1568         if (!options.summarizeOverriddenMethods() || !isIncluded(m)) {
1569             return false;
1570         }
1571 
1572         if (!getBlockTags(m).isEmpty() || isDeprecated(m))
1573             return false;
1574 
1575         List&lt;? extends DocTree&gt; fullBody = getFullBody(m);
1576         return fullBody.isEmpty() ||
1577                 (fullBody.size() == 1 &amp;&amp; fullBody.get(0).getKind().equals(Kind.INHERIT_DOC));
1578     }
1579 
1580     /**
1581      * In case of JavaFX mode on, filters out classes that are private,
1582      * package private, these are not documented in JavaFX mode, also
1583      * remove those classes that have &amp;#64;hidden or &amp;#64;treatAsPrivate comment tag.
1584      *
1585      * @param classlist a collection of TypeElements
1586      * @param javafx set to true if in JavaFX mode.
1587      * @return list of filtered classes.
1588      */
1589     public SortedSet&lt;TypeElement&gt; filterOutPrivateClasses(Iterable&lt;TypeElement&gt; classlist,
1590             boolean javafx) {
1591         SortedSet&lt;TypeElement&gt; filteredOutClasses =
1592                 new TreeSet&lt;&gt;(comparators.makeGeneralPurposeComparator());
1593         if (!javafx) {
1594             for (Element te : classlist) {
1595                 if (!hasHiddenTag(te)) {
1596                     filteredOutClasses.add((TypeElement)te);
1597                 }
1598             }
1599             return filteredOutClasses;
1600         }
1601         for (Element e : classlist) {
1602             if (isPrivate(e) || isPackagePrivate(e) || hasHiddenTag(e)) {
1603                 continue;
1604             }
1605             filteredOutClasses.add((TypeElement)e);
1606         }
1607         return filteredOutClasses;
1608     }
1609 
1610     /**
1611      * Compares two elements.
1612      * @param e1 first Element
1613      * @param e2 second Element
1614      * @return a true if they are the same, false otherwise.
1615      */
1616     public boolean elementsEqual(Element e1, Element e2) {
1617         if (e1.getKind() != e2.getKind()) {
1618             return false;
1619         }
1620         String s1 = getSimpleName(e1);
1621         String s2 = getSimpleName(e2);
1622         if (compareStrings(s1, s2) == 0) {
1623             String f1 = getFullyQualifiedName(e1, true);
1624             String f2 = getFullyQualifiedName(e2, true);
1625             return compareStrings(f1, f2) == 0;
1626         }
1627         return false;
1628     }
1629 
1630     /**
1631      * A general purpose case insensitive String comparator, which compares
1632      * two Strings using a Collator strength of &quot;TERTIARY&quot;.
1633      *
1634      * @param s1 first String to compare.
1635      * @param s2 second String to compare.
1636      * @return a negative integer, zero, or a positive integer as the first
1637      *         argument is less than, equal to, or greater than the second.
1638      */
1639     public int compareStrings(String s1, String s2) {
1640         return compareStrings(true, s1, s2);
1641     }
1642 
1643     /**
1644      * A general purpose case sensitive String comparator, which
1645      * compares two Strings using a Collator strength of &quot;SECONDARY&quot;.
1646      *
1647      * @param s1 first String to compare.
1648      * @param s2 second String to compare.
1649      * @return a negative integer, zero, or a positive integer as the first
1650      *         argument is less than, equal to, or greater than the second.
1651      */
1652     public int compareCaseCompare(String s1, String s2) {
1653         return compareStrings(false, s1, s2);
1654     }
1655 
1656     private DocCollator tertiaryCollator = null;
1657     private DocCollator secondaryCollator = null;
1658 
1659     int compareStrings(boolean caseSensitive, String s1, String s2) {
1660         if (caseSensitive) {
1661             if (tertiaryCollator == null) {
1662                 tertiaryCollator = new DocCollator(configuration.locale, Collator.TERTIARY);
1663             }
1664             return tertiaryCollator.compare(s1, s2);
1665         }
1666         if (secondaryCollator == null) {
1667             secondaryCollator = new DocCollator(configuration.locale, Collator.SECONDARY);
1668         }
1669         return secondaryCollator.compare(s1, s2);
1670     }
1671 
1672     public String getHTMLTitle(Element element) {
1673         List&lt;? extends DocTree&gt; preamble = getPreamble(element);
1674         StringBuilder sb = new StringBuilder();
1675         boolean titleFound = false;
1676         loop:
1677         for (DocTree dt : preamble) {
1678             switch (dt.getKind()) {
1679                 case START_ELEMENT:
1680                     StartElementTree nodeStart = (StartElementTree)dt;
1681                     if (Utils.toLowerCase(nodeStart.getName().toString()).equals(&quot;title&quot;)) {
1682                         titleFound = true;
1683                     }
1684                     break;
1685 
1686                 case END_ELEMENT:
1687                     EndElementTree nodeEnd = (EndElementTree)dt;
1688                     if (Utils.toLowerCase(nodeEnd.getName().toString()).equals(&quot;title&quot;)) {
1689                         break loop;
1690                     }
1691                     break;
1692 
1693                 case TEXT:
1694                     TextTree nodeText = (TextTree)dt;
1695                     if (titleFound)
1696                         sb.append(nodeText.getBody());
1697                     break;
1698 
1699                 default:
1700                     // do nothing
1701             }
1702         }
1703         return sb.toString().trim();
1704     }
1705 
1706     private static class DocCollator {
1707         private final Map&lt;String, CollationKey&gt; keys;
1708         private final Collator instance;
1709         private final int MAX_SIZE = 1000;
1710         private DocCollator(Locale locale, int strength) {
1711             instance = createCollator(locale);
1712             instance.setStrength(strength);
1713 
1714             keys = new LinkedHashMap&lt;String, CollationKey&gt;(MAX_SIZE + 1, 0.75f, true) {
1715                 private static final long serialVersionUID = 1L;
1716                 @Override
1717                 protected boolean removeEldestEntry(Entry&lt;String, CollationKey&gt; eldest) {
1718                     return size() &gt; MAX_SIZE;
1719                 }
1720             };
1721         }
1722 
1723         CollationKey getKey(String s) {
1724             return keys.computeIfAbsent(s, instance :: getCollationKey);
1725         }
1726 
1727         public int compare(String s1, String s2) {
1728             return getKey(s1).compareTo(getKey(s2));
1729         }
1730 
1731         private Collator createCollator(Locale locale) {
1732             Collator baseCollator = Collator.getInstance(locale);
1733             if (baseCollator instanceof RuleBasedCollator) {
1734                 // Extend collator to sort signatures with additional args and var-args in a well-defined order:
1735                 // () &lt; (int) &lt; (int, int) &lt; (int...)
1736                 try {
1737                     return new RuleBasedCollator(((RuleBasedCollator) baseCollator).getRules()
1738                             + &quot;&amp; &#39;)&#39; &lt; &#39;,&#39; &lt; &#39;.&#39;,&#39;[&#39;&quot;);
1739                 } catch (ParseException e) {
1740                     throw new RuntimeException(e);
1741                 }
1742             }
1743             return baseCollator;
1744         }
1745     }
1746 
1747     /**
1748      * Get the qualified type name of a TypeMirror compatible with the Element&#39;s
1749      * getQualified name, returns  the qualified name of the Reference type
1750      * otherwise the primitive name.
1751      * @param t the type whose name is to be obtained.
1752      * @return the fully qualified name of Reference type or the primitive name
1753      */
1754     public String getQualifiedTypeName(TypeMirror t) {
1755         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
1756             @Override
1757             public String visitDeclared(DeclaredType t, Void p) {
1758                 return getFullyQualifiedName(t.asElement());
1759             }
1760 
1761             @Override
1762             public String visitArray(ArrayType t, Void p) {
1763                return visit(t.getComponentType());
1764             }
1765 
1766             @Override
1767             public String visitTypeVariable(javax.lang.model.type.TypeVariable t, Void p) {
1768                 // The knee jerk reaction is to do this but don&#39;t!, as we would like
1769                 // it to be compatible with the old world, now if we decide to do so
1770                 // care must be taken to avoid collisions.
1771                 // return getFullyQualifiedName(t.asElement());
1772                 return t.toString();
1773             }
1774 
1775             @Override
1776             protected String defaultAction(TypeMirror t, Void p) {
1777                 return t.toString();
1778             }
1779 
1780         }.visit(t);
1781     }
1782 
1783     /**
1784      * A generic utility which returns the fully qualified names of an entity,
1785      * if the entity is not qualifiable then its enclosing entity, it is upto
1786      * the caller to add the elements name as required.
1787      * @param e the element to get FQN for.
1788      * @return the name
1789      */
1790     public String getFullyQualifiedName(Element e) {
1791         return getFullyQualifiedName(e, true);
1792     }
1793 
1794     @SuppressWarnings(&quot;preview&quot;)
1795     public String getFullyQualifiedName(Element e, final boolean outer) {
1796         return new SimpleElementVisitor14&lt;String, Void&gt;() {
1797             @Override
1798             public String visitModule(ModuleElement e, Void p) {
1799                 return e.getQualifiedName().toString();
1800             }
1801 
1802             @Override
1803             public String visitPackage(PackageElement e, Void p) {
1804                 return e.getQualifiedName().toString();
1805             }
1806 
1807             @Override
1808             public String visitType(TypeElement e, Void p) {
1809                 return e.getQualifiedName().toString();
1810             }
1811 
1812             @Override
1813             protected String defaultAction(Element e, Void p) {
1814                 return outer ? visit(e.getEnclosingElement()) : e.getSimpleName().toString();
1815             }
1816         }.visit(e);
1817     }
1818 
1819 
1820     public Iterable&lt;TypeElement&gt; getEnclosedTypeElements(PackageElement pkg) {
1821         List&lt;TypeElement&gt; out = getInterfaces(pkg);
1822         out.addAll(getClasses(pkg));
1823         out.addAll(getEnums(pkg));
1824         out.addAll(getAnnotationTypes(pkg));
1825         out.addAll(getRecords(pkg));
1826         return out;
1827     }
1828 
1829     // Element related methods
1830     public List&lt;Element&gt; getAnnotationMembers(TypeElement aClass) {
1831         List&lt;Element&gt; members = getAnnotationFields(aClass);
1832         members.addAll(getAnnotationMethods(aClass));
1833         return members;
1834     }
1835 
1836     public List&lt;Element&gt; getAnnotationFields(TypeElement aClass) {
1837         return getItems0(aClass, true, FIELD);
1838     }
1839 
1840     List&lt;Element&gt; getAnnotationFieldsUnfiltered(TypeElement aClass) {
1841         return getItems0(aClass, true, FIELD);
1842     }
1843 
1844     public List&lt;Element&gt; getAnnotationMethods(TypeElement aClass) {
1845         return getItems0(aClass, true, METHOD);
1846     }
1847 
1848     public List&lt;TypeElement&gt; getAnnotationTypes(Element e) {
1849         return convertToTypeElement(getItems(e, true, ANNOTATION_TYPE));
1850     }
1851 
1852     public List&lt;TypeElement&gt; getAnnotationTypesUnfiltered(Element e) {
1853         return convertToTypeElement(getItems(e, false, ANNOTATION_TYPE));
1854     }
1855 
1856     @SuppressWarnings(&quot;preview&quot;)
1857     public List&lt;TypeElement&gt; getRecords(Element e) {
1858         return convertToTypeElement(getItems(e, true, RECORD));
1859     }
1860 
1861     @SuppressWarnings(&quot;preview&quot;)
1862     public List&lt;TypeElement&gt; getRecordsUnfiltered(Element e) {
1863         return convertToTypeElement(getItems(e, false, RECORD));
1864     }
1865 
1866     public List&lt;VariableElement&gt; getFields(Element e) {
1867         return convertToVariableElement(getItems(e, true, FIELD));
1868     }
1869 
1870     public List&lt;VariableElement&gt; getFieldsUnfiltered(Element e) {
1871         return convertToVariableElement(getItems(e, false, FIELD));
1872     }
1873 
1874     public List&lt;TypeElement&gt; getClasses(Element e) {
1875        return convertToTypeElement(getItems(e, true, CLASS));
1876     }
1877 
1878     public List&lt;TypeElement&gt; getClassesUnfiltered(Element e) {
1879        return convertToTypeElement(getItems(e, false, CLASS));
1880     }
1881 
1882     public List&lt;ExecutableElement&gt; getConstructors(Element e) {
1883         return convertToExecutableElement(getItems(e, true, CONSTRUCTOR));
1884     }
1885 
1886     public List&lt;ExecutableElement&gt; getMethods(Element e) {
1887         return convertToExecutableElement(getItems(e, true, METHOD));
1888     }
1889 
1890     List&lt;ExecutableElement&gt; getMethodsUnfiltered(Element e) {
1891         return convertToExecutableElement(getItems(e, false, METHOD));
1892     }
1893 
1894     public int getOrdinalValue(VariableElement member) {
1895         if (member == null || member.getKind() != ENUM_CONSTANT) {
1896             throw new IllegalArgumentException(&quot;must be an enum constant: &quot; + member);
1897         }
1898         return member.getEnclosingElement().getEnclosedElements().indexOf(member);
1899     }
1900 
1901     private Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; modulePackageMap = null;
1902     public Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; getModulePackageMap() {
1903         if (modulePackageMap == null) {
1904             modulePackageMap = new HashMap&lt;&gt;();
1905             Set&lt;PackageElement&gt; pkgs = configuration.getIncludedPackageElements();
1906             pkgs.forEach(pkg -&gt; {
1907                 ModuleElement mod = elementUtils.getModuleOf(pkg);
1908                 modulePackageMap.computeIfAbsent(mod, m -&gt; new HashSet&lt;&gt;()).add(pkg);
1909             });
1910         }
1911         return modulePackageMap;
1912     }
1913 
1914     public Map&lt;ModuleElement, String&gt; getDependentModules(ModuleElement mdle) {
1915         Map&lt;ModuleElement, String&gt; result = new TreeMap&lt;&gt;(comparators.makeModuleComparator());
1916         Deque&lt;ModuleElement&gt; queue = new ArrayDeque&lt;&gt;();
1917         // get all the requires for the element in question
1918         for (RequiresDirective rd : ElementFilter.requiresIn(mdle.getDirectives())) {
1919             ModuleElement dep = rd.getDependency();
1920             // add the dependency to work queue
1921             if (!result.containsKey(dep)) {
1922                 if (rd.isTransitive()) {
1923                     queue.addLast(dep);
1924                 }
1925             }
1926             // add all exports for the primary module
1927             result.put(rd.getDependency(), getModifiers(rd));
1928         }
1929 
1930         // add only requires public for subsequent module dependencies
1931         for (ModuleElement m = queue.poll(); m != null; m = queue.poll()) {
1932             for (RequiresDirective rd : ElementFilter.requiresIn(m.getDirectives())) {
1933                 ModuleElement dep = rd.getDependency();
1934                 if (!result.containsKey(dep)) {
1935                     if (rd.isTransitive()) {
1936                         result.put(dep, getModifiers(rd));
1937                         queue.addLast(dep);
1938                     }
1939                 }
1940             }
1941         }
1942         return result;
1943     }
1944 
1945     public String getModifiers(RequiresDirective rd) {
1946         StringBuilder modifiers = new StringBuilder();
1947         String sep = &quot;&quot;;
1948         if (rd.isTransitive()) {
1949             modifiers.append(&quot;transitive&quot;);
1950             sep = &quot; &quot;;
1951         }
1952         if (rd.isStatic()) {
1953             modifiers.append(sep);
1954             modifiers.append(&quot;static&quot;);
1955         }
1956         return (modifiers.length() == 0) ? &quot; &quot; : modifiers.toString();
1957     }
1958 
1959     public long getLineNumber(Element e) {
1960         TreePath path = getTreePath(e);
1961         if (path == null) { // maybe null if synthesized
1962             TypeElement encl = getEnclosingTypeElement(e);
1963             path = getTreePath(encl);
1964         }
1965         CompilationUnitTree cu = path.getCompilationUnit();
1966         LineMap lineMap = cu.getLineMap();
1967         DocSourcePositions spos = docTrees.getSourcePositions();
1968         long pos = spos.getStartPosition(cu, path.getLeaf());
1969         return lineMap.getLineNumber(pos);
1970     }
1971 
1972     public List&lt;ExecutableElement&gt; convertToExecutableElement(List&lt;Element&gt; list) {
1973         List&lt;ExecutableElement&gt; out = new ArrayList&lt;&gt;(list.size());
1974         for (Element e : list) {
1975             out.add((ExecutableElement)e);
1976         }
1977         return out;
1978     }
1979 
1980     public List&lt;TypeElement&gt; convertToTypeElement(List&lt;Element&gt; list) {
1981         List&lt;TypeElement&gt; out = new ArrayList&lt;&gt;(list.size());
1982         for (Element e : list) {
1983             out.add((TypeElement)e);
1984         }
1985         return out;
1986     }
1987 
1988     public List&lt;VariableElement&gt; convertToVariableElement(List&lt;Element&gt; list) {
1989         List&lt;VariableElement&gt; out = new ArrayList&lt;&gt;(list.size());
1990         for (Element e : list) {
1991             out.add((VariableElement) e);
1992         }
1993         return out;
1994     }
1995 
1996     public List&lt;TypeElement&gt; getInterfaces(Element e)  {
1997         return convertToTypeElement(getItems(e, true, INTERFACE));
1998     }
1999 
2000     public List&lt;TypeElement&gt; getInterfacesUnfiltered(Element e)  {
2001         return convertToTypeElement(getItems(e, false, INTERFACE));
2002     }
2003 
2004     public List&lt;Element&gt; getEnumConstants(Element e) {
2005         return getItems(e, true, ENUM_CONSTANT);
2006     }
2007 
2008     public List&lt;TypeElement&gt; getEnums(Element e) {
2009         return convertToTypeElement(getItems(e, true, ENUM));
2010     }
2011 
2012     public List&lt;TypeElement&gt; getEnumsUnfiltered(Element e) {
2013         return convertToTypeElement(getItems(e, false, ENUM));
2014     }
2015 
2016     public SortedSet&lt;TypeElement&gt; getAllClassesUnfiltered(Element e) {
2017         List&lt;TypeElement&gt; clist = getClassesUnfiltered(e);
2018         clist.addAll(getInterfacesUnfiltered(e));
2019         clist.addAll(getAnnotationTypesUnfiltered(e));
2020         clist.addAll(getRecordsUnfiltered(e));
2021         SortedSet&lt;TypeElement&gt; oset = new TreeSet&lt;&gt;(comparators.makeGeneralPurposeComparator());
2022         oset.addAll(clist);
2023         return oset;
2024     }
2025 
2026     private final HashMap&lt;Element, SortedSet&lt;TypeElement&gt;&gt; cachedClasses = new HashMap&lt;&gt;();
2027     /**
2028      * Returns a list containing classes and interfaces,
2029      * including annotation types.
2030      * @param e Element
2031      * @return List
2032      */
2033     public SortedSet&lt;TypeElement&gt; getAllClasses(Element e) {
2034         SortedSet&lt;TypeElement&gt; oset = cachedClasses.get(e);
2035         if (oset != null)
2036             return oset;
2037         List&lt;TypeElement&gt; clist = getClasses(e);
2038         clist.addAll(getInterfaces(e));
2039         clist.addAll(getAnnotationTypes(e));
2040         clist.addAll(getEnums(e));
2041         clist.addAll(getRecords(e));
2042         oset = new TreeSet&lt;&gt;(comparators.makeGeneralPurposeComparator());
2043         oset.addAll(clist);
2044         cachedClasses.put(e, oset);
2045         return oset;
2046     }
2047 
2048     /*
2049      * Get all the elements unfiltered and filter them finally based
2050      * on its visibility, this works differently from the other getters.
2051      */
2052     private List&lt;TypeElement&gt; getInnerClasses(Element e, boolean filter) {
2053         List&lt;TypeElement&gt; olist = new ArrayList&lt;&gt;();
2054         for (TypeElement te : getClassesUnfiltered(e)) {
2055             if (!filter || configuration.docEnv.isSelected(te)) {
2056                 olist.add(te);
2057             }
2058         }
2059         for (TypeElement te : getInterfacesUnfiltered(e)) {
2060             if (!filter || configuration.docEnv.isSelected(te)) {
2061                 olist.add(te);
2062             }
2063         }
2064         for (TypeElement te : getAnnotationTypesUnfiltered(e)) {
2065             if (!filter || configuration.docEnv.isSelected(te)) {
2066                 olist.add(te);
2067             }
2068         }
2069         for (TypeElement te : getEnumsUnfiltered(e)) {
2070             if (!filter || configuration.docEnv.isSelected(te)) {
2071                 olist.add(te);
2072             }
2073         }
2074         return olist;
2075     }
2076 
2077     public List&lt;TypeElement&gt; getInnerClasses(Element e) {
2078         return getInnerClasses(e, true);
2079     }
2080 
2081     public List&lt;TypeElement&gt; getInnerClassesUnfiltered(Element e) {
2082         return getInnerClasses(e, false);
2083     }
2084 
2085     /**
2086      * Returns a list of classes that are not errors or exceptions
2087      * @param e Element
2088      * @return List
2089      */
2090     public List&lt;TypeElement&gt; getOrdinaryClasses(Element e) {
2091         return getClasses(e).stream()
2092                 .filter(te -&gt; (!isException(te) &amp;&amp; !isError(te)))
2093                 .collect(Collectors.toList());
2094     }
2095 
2096     public List&lt;TypeElement&gt; getErrors(Element e) {
2097         return getClasses(e)
2098                 .stream()
2099                 .filter(this::isError)
2100                 .collect(Collectors.toList());
2101     }
2102 
2103     public List&lt;TypeElement&gt; getExceptions(Element e) {
2104         return getClasses(e)
2105                 .stream()
2106                 .filter(this::isException)
2107                 .collect(Collectors.toList());
2108     }
2109 
2110     @SuppressWarnings(&quot;preview&quot;)
2111     List&lt;Element&gt; getItems(Element e, boolean filter, ElementKind select) {
2112         List&lt;Element&gt; elements = new ArrayList&lt;&gt;();
2113         return new SimpleElementVisitor14&lt;List&lt;Element&gt;, Void&gt;() {
2114 
2115             @Override
2116             public List&lt;Element&gt; visitPackage(PackageElement e, Void p) {
2117                 recursiveGetItems(elements, e, filter, select);
2118                 return elements;
2119             }
2120 
2121             @Override
2122             protected List&lt;Element&gt; defaultAction(Element e0, Void p) {
2123                 return getItems0(e0, filter, select);
2124             }
2125 
2126         }.visit(e);
2127     }
2128 
2129     Set&lt;ElementKind&gt; nestedKinds = EnumSet.of(ANNOTATION_TYPE, CLASS, ENUM, INTERFACE);
2130     void recursiveGetItems(Collection&lt;Element&gt; list, Element e, boolean filter, ElementKind... select) {
2131         list.addAll(getItems0(e, filter, select));
2132         List&lt;Element&gt; classes = getItems0(e, filter, nestedKinds);
2133         for (Element c : classes) {
2134             list.addAll(getItems0(c, filter, select));
2135             if (isTypeElement(c)) {
2136                 recursiveGetItems(list, c, filter, select);
2137             }
2138         }
2139     }
2140 
2141     private List&lt;Element&gt; getItems0(Element te, boolean filter, ElementKind... select) {
2142         Set&lt;ElementKind&gt; kinds = EnumSet.copyOf(Arrays.asList(select));
2143         return getItems0(te, filter, kinds);
2144     }
2145 
2146     private List&lt;Element&gt; getItems0(Element te, boolean filter, Set&lt;ElementKind&gt; kinds) {
2147         List&lt;Element&gt; elements = new ArrayList&lt;&gt;();
2148         for (Element e : te.getEnclosedElements()) {
2149             if (kinds.contains(e.getKind())) {
2150                 if (!filter || shouldDocument(e)) {
2151                     elements.add(e);
2152                 }
2153             }
2154         }
2155         return elements;
2156     }
2157 
2158     @SuppressWarnings(&quot;preview&quot;)
2159     private SimpleElementVisitor14&lt;Boolean, Void&gt; shouldDocumentVisitor = null;
2160 
2161     @SuppressWarnings(&quot;preview&quot;)
2162     public boolean shouldDocument(Element e) {
2163         if (shouldDocumentVisitor == null) {
2164             shouldDocumentVisitor = new SimpleElementVisitor14&lt;Boolean, Void&gt;() {
2165                 private boolean hasSource(TypeElement e) {
2166                     return configuration.docEnv.getFileKind(e) ==
2167                             javax.tools.JavaFileObject.Kind.SOURCE;
2168                 }
2169 
2170                 // handle types
2171                 @Override
2172                 public Boolean visitType(TypeElement e, Void p) {
2173                     // treat inner classes etc as members
2174                     if (e.getNestingKind().isNested()) {
2175                         return defaultAction(e, p);
2176                     }
2177                     return configuration.docEnv.isSelected(e) &amp;&amp; hasSource(e);
2178                 }
2179 
2180                 // handle everything else
2181                 @Override
2182                 protected Boolean defaultAction(Element e, Void p) {
2183                     return configuration.docEnv.isSelected(e);
2184                 }
2185 
2186                 @Override
2187                 public Boolean visitUnknown(Element e, Void p) {
2188                     throw new AssertionError(&quot;unknown element: &quot; + e);
2189                 }
2190             };
2191         }
2192         return shouldDocumentVisitor.visit(e);
2193     }
2194 
2195     /*
2196      * nameCache is maintained for improving the comparator
2197      * performance, noting that the Collator used by the comparators
2198      * use Strings, as of this writing.
2199      * TODO: when those APIs handle charSequences, the use of
2200      * this nameCache must be re-investigated and removed.
2201      */
2202     private final Map&lt;Element, String&gt; nameCache = new LinkedHashMap&lt;&gt;();
2203 
2204     /**
2205      * Returns the name of the element after the last dot of the package name.
2206      * This emulates the behavior of the old doclet.
2207      * @param e an element whose name is required
2208      * @return the name
2209      */
2210     public String getSimpleName(Element e) {
2211         return nameCache.computeIfAbsent(e, this::getSimpleName0);
2212     }
2213 
2214     @SuppressWarnings(&quot;preview&quot;)
2215     private SimpleElementVisitor14&lt;String, Void&gt; snvisitor = null;
2216 
2217     @SuppressWarnings(&quot;preview&quot;)
2218     private String getSimpleName0(Element e) {
2219         if (snvisitor == null) {
2220             snvisitor = new SimpleElementVisitor14&lt;String, Void&gt;() {
2221                 @Override
2222                 public String visitModule(ModuleElement e, Void p) {
2223                     return e.getQualifiedName().toString();  // temp fix for 8182736
2224                 }
2225 
2226                 @Override
2227                 public String visitType(TypeElement e, Void p) {
2228                     StringBuilder sb = new StringBuilder(e.getSimpleName());
2229                     Element enclosed = e.getEnclosingElement();
2230                     while (enclosed != null
2231                             &amp;&amp; (enclosed.getKind().isClass() || enclosed.getKind().isInterface())) {
2232                         sb.insert(0, enclosed.getSimpleName() + &quot;.&quot;);
2233                         enclosed = enclosed.getEnclosingElement();
2234                     }
2235                     return sb.toString();
2236                 }
2237 
2238                 @Override
2239                 public String visitExecutable(ExecutableElement e, Void p) {
2240                     if (e.getKind() == CONSTRUCTOR || e.getKind() == STATIC_INIT) {
2241                         return e.getEnclosingElement().getSimpleName().toString();
2242                     }
2243                     return e.getSimpleName().toString();
2244                 }
2245 
2246                 @Override
2247                 protected String defaultAction(Element e, Void p) {
2248                     return e.getSimpleName().toString();
2249                 }
2250             };
2251         }
2252         return snvisitor.visit(e);
2253     }
2254 
2255     public TypeElement getEnclosingTypeElement(Element e) {
2256         if (e.getKind() == ElementKind.PACKAGE)
2257             return null;
2258         Element encl = e.getEnclosingElement();
2259         ElementKind kind = encl.getKind();
2260         if (kind == ElementKind.PACKAGE)
2261             return null;
2262         while (!(kind.isClass() || kind.isInterface())) {
2263             encl = encl.getEnclosingElement();
2264             kind = encl.getKind();
2265         }
2266         return (TypeElement)encl;
2267     }
2268 
2269     private ConstantValueExpression cve = null;
2270 
2271     public String constantValueExpresion(VariableElement ve) {
2272         if (cve == null)
2273             cve = new ConstantValueExpression();
2274         return cve.constantValueExpression(configuration.workArounds, ve);
2275     }
2276 
2277     private static class ConstantValueExpression {
2278         public String constantValueExpression(WorkArounds workArounds, VariableElement ve) {
2279             return new TypeKindVisitor9&lt;String, Object&gt;() {
2280                 /* TODO: we need to fix this correctly.
2281                  * we have a discrepancy here, note the use of getConstValue
2282                  * vs. getConstantValue, at some point we need to use
2283                  * getConstantValue.
2284                  * In the legacy world byte and char primitives appear as Integer values,
2285                  * thus a byte value of 127 will appear as 127, but in the new world,
2286                  * a byte value appears as Byte thus 0x7f will be printed, similarly
2287                  * chars will be  translated to \n, \r etc. however, in the new world,
2288                  * they will be printed as decimal values. The new world is correct,
2289                  * and we should fix this by using getConstantValue and the visitor to
2290                  * address this in the future.
2291                  */
2292                 @Override
2293                 public String visitPrimitiveAsBoolean(PrimitiveType t, Object val) {
2294                     return (int)val == 0 ? &quot;false&quot; : &quot;true&quot;;
2295                 }
2296 
2297                 @Override
2298                 public String visitPrimitiveAsDouble(PrimitiveType t, Object val) {
2299                     return sourceForm(((Double)val), &#39;d&#39;);
2300                 }
2301 
2302                 @Override
2303                 public String visitPrimitiveAsFloat(PrimitiveType t, Object val) {
2304                     return sourceForm(((Float)val).doubleValue(), &#39;f&#39;);
2305                 }
2306 
2307                 @Override
2308                 public String visitPrimitiveAsLong(PrimitiveType t, Object val) {
2309                     return val + &quot;L&quot;;
2310                 }
2311 
2312                 @Override
2313                 protected String defaultAction(TypeMirror e, Object val) {
2314                     if (val == null)
2315                         return null;
2316                     else if (val instanceof Character)
2317                         return sourceForm(((Character)val));
2318                     else if (val instanceof Byte)
2319                         return sourceForm(((Byte)val));
2320                     else if (val instanceof String)
2321                         return sourceForm((String)val);
2322                     return val.toString(); // covers int, short
2323                 }
2324             }.visit(ve.asType(), workArounds.getConstValue(ve));
2325         }
2326 
2327         // where
2328         private String sourceForm(double v, char suffix) {
2329             if (Double.isNaN(v))
2330                 return &quot;0&quot; + suffix + &quot;/0&quot; + suffix;
2331             if (v == Double.POSITIVE_INFINITY)
2332                 return &quot;1&quot; + suffix + &quot;/0&quot; + suffix;
2333             if (v == Double.NEGATIVE_INFINITY)
2334                 return &quot;-1&quot; + suffix + &quot;/0&quot; + suffix;
2335             return v + (suffix == &#39;f&#39; || suffix == &#39;F&#39; ? &quot;&quot; + suffix : &quot;&quot;);
2336         }
2337 
2338         private  String sourceForm(char c) {
2339             StringBuilder buf = new StringBuilder(8);
2340             buf.append(&#39;\&#39;&#39;);
2341             sourceChar(c, buf);
2342             buf.append(&#39;\&#39;&#39;);
2343             return buf.toString();
2344         }
2345 
2346         private String sourceForm(byte c) {
2347             return &quot;0x&quot; + Integer.toString(c &amp; 0xff, 16);
2348         }
2349 
2350         private String sourceForm(String s) {
2351             StringBuilder buf = new StringBuilder(s.length() + 5);
2352             buf.append(&#39;\&quot;&#39;);
2353             for (int i=0; i&lt;s.length(); i++) {
2354                 char c = s.charAt(i);
2355                 sourceChar(c, buf);
2356             }
2357             buf.append(&#39;\&quot;&#39;);
2358             return buf.toString();
2359         }
2360 
2361         private void sourceChar(char c, StringBuilder buf) {
2362             switch (c) {
2363             case &#39;\b&#39;: buf.append(&quot;\\b&quot;); return;
2364             case &#39;\t&#39;: buf.append(&quot;\\t&quot;); return;
2365             case &#39;\n&#39;: buf.append(&quot;\\n&quot;); return;
2366             case &#39;\f&#39;: buf.append(&quot;\\f&quot;); return;
2367             case &#39;\r&#39;: buf.append(&quot;\\r&quot;); return;
2368             case &#39;\&quot;&#39;: buf.append(&quot;\\\&quot;&quot;); return;
2369             case &#39;\&#39;&#39;: buf.append(&quot;\\\&#39;&quot;); return;
2370             case &#39;\\&#39;: buf.append(&quot;\\\\&quot;); return;
2371             default:
2372                 if (isPrintableAscii(c)) {
2373                     buf.append(c); return;
2374                 }
2375                 unicodeEscape(c, buf);
2376                 return;
2377             }
2378         }
2379 
2380         private void unicodeEscape(char c, StringBuilder buf) {
2381             final String chars = &quot;0123456789abcdef&quot;;
2382             buf.append(&quot;\\u&quot;);
2383             buf.append(chars.charAt(15 &amp; (c&gt;&gt;12)));
2384             buf.append(chars.charAt(15 &amp; (c&gt;&gt;8)));
2385             buf.append(chars.charAt(15 &amp; (c&gt;&gt;4)));
2386             buf.append(chars.charAt(15 &amp; (c&gt;&gt;0)));
2387         }
2388         private boolean isPrintableAscii(char c) {
2389             return c &gt;= &#39; &#39; &amp;&amp; c &lt;= &#39;~&#39;;
2390         }
2391     }
2392 
2393     public boolean isEnclosingPackageIncluded(TypeElement te) {
2394         return isIncluded(containingPackage(te));
2395     }
2396 
2397     public boolean isIncluded(Element e) {
2398         return configuration.docEnv.isIncluded(e);
2399     }
2400 
2401     @SuppressWarnings(&quot;preview&quot;)
2402     private SimpleElementVisitor14&lt;Boolean, Void&gt; specifiedVisitor = null;
2403     @SuppressWarnings(&quot;preview&quot;)
2404     public boolean isSpecified(Element e) {
2405         if (specifiedVisitor == null) {
2406             specifiedVisitor = new SimpleElementVisitor14&lt;Boolean, Void&gt;() {
2407                 @Override
2408                 public Boolean visitModule(ModuleElement e, Void p) {
2409                     return configuration.getSpecifiedModuleElements().contains(e);
2410                 }
2411 
2412                 @Override
2413                 public Boolean visitPackage(PackageElement e, Void p) {
2414                     return configuration.getSpecifiedPackageElements().contains(e);
2415                 }
2416 
2417                 @Override
2418                 public Boolean visitType(TypeElement e, Void p) {
2419                     return configuration.getSpecifiedTypeElements().contains(e);
2420                 }
2421 
2422                 @Override
2423                 protected Boolean defaultAction(Element e, Void p) {
2424                     return false;
2425                 }
2426             };
2427         }
2428         return specifiedVisitor.visit(e);
2429     }
2430 
2431     /**
2432      * Get the package name for a given package element. An unnamed package is returned as &amp;lt;Unnamed&amp;gt;
2433      *
2434      * @param pkg
2435      * @return
2436      */
2437     public String getPackageName(PackageElement pkg) {
2438         if (pkg == null || pkg.isUnnamed()) {
2439             return DocletConstants.DEFAULT_PACKAGE_NAME;
2440         }
2441         return pkg.getQualifiedName().toString();
2442     }
2443 
2444     /**
2445      * Get the module name for a given module element. An unnamed module is returned as &amp;lt;Unnamed&amp;gt;
2446      *
2447      * @param mdle a ModuleElement
2448      * @return
2449      */
2450     public String getModuleName(ModuleElement mdle) {
2451         if (mdle == null || mdle.isUnnamed()) {
2452             return DocletConstants.DEFAULT_ELEMENT_NAME;
2453         }
2454         return mdle.getQualifiedName().toString();
2455     }
2456 
2457     public boolean isAttribute(DocTree doctree) {
2458         return isKind(doctree, ATTRIBUTE);
2459     }
2460 
2461     public boolean isAuthor(DocTree doctree) {
2462         return isKind(doctree, AUTHOR);
2463     }
2464 
2465     public boolean isComment(DocTree doctree) {
2466         return isKind(doctree, COMMENT);
2467     }
2468 
2469     public boolean isDeprecated(DocTree doctree) {
2470         return isKind(doctree, DEPRECATED);
2471     }
2472 
2473     public boolean isDocComment(DocTree doctree) {
2474         return isKind(doctree, DOC_COMMENT);
2475     }
2476 
2477     public boolean isDocRoot(DocTree doctree) {
2478         return isKind(doctree, DOC_ROOT);
2479     }
2480 
2481     public boolean isEndElement(DocTree doctree) {
2482         return isKind(doctree, END_ELEMENT);
2483     }
2484 
2485     public boolean isEntity(DocTree doctree) {
2486         return isKind(doctree, ENTITY);
2487     }
2488 
2489     public boolean isErroneous(DocTree doctree) {
2490         return isKind(doctree, ERRONEOUS);
2491     }
2492 
2493     public boolean isException(DocTree doctree) {
2494         return isKind(doctree, EXCEPTION);
2495     }
2496 
2497     public boolean isIdentifier(DocTree doctree) {
2498         return isKind(doctree, IDENTIFIER);
2499     }
2500 
2501     public boolean isInheritDoc(DocTree doctree) {
2502         return isKind(doctree, INHERIT_DOC);
2503     }
2504 
2505     public boolean isLink(DocTree doctree) {
2506         return isKind(doctree, LINK);
2507     }
2508 
2509     public boolean isLinkPlain(DocTree doctree) {
2510         return isKind(doctree, LINK_PLAIN);
2511     }
2512 
2513     public boolean isLiteral(DocTree doctree) {
2514         return isKind(doctree, LITERAL);
2515     }
2516 
2517     public boolean isOther(DocTree doctree) {
2518         return doctree.getKind() == DocTree.Kind.OTHER;
2519     }
2520 
2521     public boolean isParam(DocTree doctree) {
2522         return isKind(doctree, PARAM);
2523     }
2524 
2525     public boolean isReference(DocTree doctree) {
2526         return isKind(doctree, REFERENCE);
2527     }
2528 
2529     public boolean isReturn(DocTree doctree) {
2530         return isKind(doctree, RETURN);
2531     }
2532 
2533     public boolean isSee(DocTree doctree) {
2534         return isKind(doctree, SEE);
2535     }
2536 
2537     public boolean isSerial(DocTree doctree) {
2538         return isKind(doctree, SERIAL);
2539     }
2540 
2541     public boolean isSerialData(DocTree doctree) {
2542         return isKind(doctree, SERIAL_DATA);
2543     }
2544 
2545     public boolean isSerialField(DocTree doctree) {
2546         return isKind(doctree, SERIAL_FIELD);
2547     }
2548 
2549     public boolean isSince(DocTree doctree) {
2550         return isKind(doctree, SINCE);
2551     }
2552 
2553     public boolean isStartElement(DocTree doctree) {
2554         return isKind(doctree, START_ELEMENT);
2555     }
2556 
2557     public boolean isText(DocTree doctree) {
2558         return isKind(doctree, TEXT);
2559     }
2560 
2561     public boolean isThrows(DocTree doctree) {
2562         return isKind(doctree, THROWS);
2563     }
2564 
2565     public boolean isUnknownBlockTag(DocTree doctree) {
2566         return isKind(doctree, UNKNOWN_BLOCK_TAG);
2567     }
2568 
2569     public boolean isUnknownInlineTag(DocTree doctree) {
2570         return isKind(doctree, UNKNOWN_INLINE_TAG);
2571     }
2572 
2573     public boolean isValue(DocTree doctree) {
<a name="1" id="anc1"></a><span class="line-modified">2574         return isKind(doctree, Kind.VALUE);</span>
2575     }
2576 
2577     public boolean isVersion(DocTree doctree) {
2578         return isKind(doctree, VERSION);
2579     }
2580 
2581     private boolean isKind(DocTree doctree, DocTree.Kind match) {
2582         return  doctree.getKind() == match;
2583     }
2584 
2585     private final CommentHelperCache commentHelperCache = new CommentHelperCache(this);
2586 
2587     public CommentHelper getCommentHelper(Element element) {
2588         return commentHelperCache.computeIfAbsent(element);
2589     }
2590 
2591     public void removeCommentHelper(Element element) {
2592         commentHelperCache.remove(element);
2593     }
2594 
2595     public List&lt;? extends DocTree&gt; getBlockTags(Element element) {
2596         DocCommentTree dcTree = getDocCommentTree(element);
2597         return dcTree == null ? Collections.emptyList() : dcTree.getBlockTags();
2598     }
2599 
2600     public List&lt;? extends DocTree&gt; getBlockTags(Element element, Predicate&lt;DocTree&gt; filter) {
2601         return getBlockTags(element).stream()
2602                 .filter(t -&gt; t.getKind() != ERRONEOUS)
2603                 .filter(filter)
2604                 .collect(Collectors.toList());
2605     }
2606 
2607     public List&lt;? extends DocTree&gt; getBlockTags(Element element, DocTree.Kind kind) {
2608         return getBlockTags(element, t -&gt; t.getKind() == kind);
2609     }
2610 
2611     public List&lt;? extends DocTree&gt; getBlockTags(Element element, DocTree.Kind kind, DocTree.Kind altKind) {
2612         return getBlockTags(element, t -&gt; t.getKind() == kind || t.getKind() == altKind);
2613     }
2614 
2615     public List&lt;? extends DocTree&gt; getBlockTags(Element element, Taglet taglet) {
2616         return getBlockTags(element, t -&gt; {
2617             if (taglet instanceof BaseTaglet) {
2618                 return ((BaseTaglet) taglet).accepts(t);
2619             } else if (t instanceof UnknownBlockTagTree) {
2620                 return ((UnknownBlockTagTree) t).getTagName().equals(taglet.getName());
2621             } else {
2622                 return false;
2623             }
2624         });
2625     }
2626 
2627     public boolean hasBlockTag(Element element, DocTree.Kind kind) {
2628         return hasBlockTag(element, kind, null);
2629     }
2630 
2631     public boolean hasBlockTag(Element element, DocTree.Kind kind, final String tagName) {
2632         CommentHelper ch = getCommentHelper(element);
2633         String tname = tagName != null &amp;&amp; tagName.startsWith(&quot;@&quot;)
2634                 ? tagName.substring(1)
2635                 : tagName;
2636         for (DocTree dt : getBlockTags(element, kind)) {
2637             if (dt.getKind() == kind) {
2638                 if (tname == null || ch.getTagName(dt).equals(tname)) {
2639                     return true;
2640                 }
2641             }
2642         }
2643         return false;
2644     }
2645 
2646     /**
2647      * Gets a TreePath for an Element. Note this method is called very
2648      * frequently, care must be taken to ensure this method is lithe
2649      * and efficient.
2650      * @param e an Element
2651      * @return TreePath
2652      */
2653     public TreePath getTreePath(Element e) {
2654         DocCommentInfo info = dcTreeCache.get(e);
2655         if (info != null &amp;&amp; info.treePath != null) {
2656             return info.treePath;
2657         }
2658         info = configuration.cmtUtils.getSyntheticCommentInfo(e);
2659         if (info != null &amp;&amp; info.treePath != null) {
2660             return info.treePath;
2661         }
2662         Map&lt;Element, TreePath&gt; elementToTreePath = configuration.workArounds.getElementToTreePath();
2663         TreePath path = elementToTreePath.get(e);
2664         if (path != null || elementToTreePath.containsKey(e)) {
2665             // expedite the path and one that is a null
2666             return path;
2667         }
2668         return elementToTreePath.computeIfAbsent(e, docTrees::getPath);
2669     }
2670 
2671     /**
2672      * A cache of doc comment info objects for elements.
2673      * The entries may come from the AST and DocCommentParser, or may be autromatically
2674      * generated comments for mandated elements and JavaFX properties.
2675      *
2676      * @see CommentUtils.dcInfoMap
2677      */
2678     private final Map&lt;Element, DocCommentInfo&gt; dcTreeCache = new LinkedHashMap&lt;&gt;();
2679 
2680     /**
2681      * Retrieves the doc comments for a given element.
2682      * @param element
2683      * @return DocCommentTree for the Element
2684      */
2685     public DocCommentTree getDocCommentTree0(Element element) {
2686 
2687         DocCommentInfo info = null;
2688 
2689         ElementKind kind = element.getKind();
2690         if (kind == ElementKind.PACKAGE || kind == ElementKind.OTHER) {
2691             info = dcTreeCache.get(element); // local cache
2692             if (info == null &amp;&amp; kind == ElementKind.PACKAGE) {
2693                 // package-info.java
2694                 info = getDocCommentInfo(element);
2695             }
2696             if (info == null) {
2697                 // package.html or overview.html
2698                 info = configuration.cmtUtils.getHtmlCommentInfo(element); // html source
2699             }
2700         } else {
2701             info = configuration.cmtUtils.getSyntheticCommentInfo(element);
2702             if (info == null) {
2703                 info = dcTreeCache.get(element); // local cache
2704             }
2705             if (info == null) {
2706                 info = getDocCommentInfo(element); // get the real mccoy
2707             }
2708         }
2709 
2710         DocCommentTree docCommentTree = info == null ? null : info.dcTree;
2711         if (!dcTreeCache.containsKey(element)) {
2712             TreePath path = info == null ? null : info.treePath;
2713             if (path != null) {
2714                 if (docCommentTree != null &amp;&amp; !configuration.isAllowScriptInComments()) {
2715                     try {
2716                         javaScriptScanner.scan(docCommentTree, path, p -&gt; {
2717                             throw new JavaScriptScanner.Fault();
2718                         });
2719                     } catch (JavaScriptScanner.Fault jsf) {
2720                         String text = resources.getText(&quot;doclet.JavaScript_in_comment&quot;);
2721                         throw new UncheckedDocletException(new SimpleDocletException(text, jsf));
2722                     }
2723                 }
2724                 // run doclint even if docCommentTree is null, to trigger checks for missing comments
2725                 configuration.workArounds.runDocLint(path);
2726             }
2727             dcTreeCache.put(element, info);
2728         }
2729         return docCommentTree;
2730     }
2731 
2732     private DocCommentInfo getDocCommentInfo(Element element) {
2733         // prevent nasty things downstream with overview element
2734         if (element.getKind() != ElementKind.OTHER) {
2735             TreePath path = getTreePath(element);
2736             if (path != null) {
2737                 DocCommentTree docCommentTree = docTrees.getDocCommentTree(path);
2738                 return new DocCommentInfo(path, docCommentTree);
2739             }
2740         }
2741         return null;
2742     }
2743 
2744     public void checkJavaScriptInOption(String name, String value) {
2745         if (!configuration.isAllowScriptInComments()) {
2746             DocCommentTree dct = configuration.cmtUtils.parse(
2747                     URI.create(&quot;option://&quot; + name.replace(&quot;-&quot;, &quot;&quot;)), &quot;&lt;body&gt;&quot; + value + &quot;&lt;/body&gt;&quot;);
2748 
2749             if (dct == null)
2750                 return;
2751 
2752             try {
2753                 javaScriptScanner.scan(dct, null, p -&gt; {
2754                     throw new JavaScriptScanner.Fault();
2755                 });
2756             } catch (JavaScriptScanner.Fault jsf) {
2757                 String text = resources.getText(&quot;doclet.JavaScript_in_option&quot;, name);
2758                 throw new UncheckedDocletException(new SimpleDocletException(text, jsf));
2759             }
2760         }
2761     }
2762 
2763     public DocCommentTree getDocCommentTree(Element element) {
2764         CommentHelper ch = commentHelperCache.get(element);
2765         if (ch != null) {
2766             return ch.dcTree;
2767         }
2768         DocCommentTree dcTree = getDocCommentTree0(element);
2769         if (dcTree != null) {
2770             commentHelperCache.put(element, new CommentHelper(configuration, element, getTreePath(element), dcTree));
2771         }
2772         return dcTree;
2773     }
2774 
2775     public List&lt;? extends DocTree&gt; getPreamble(Element element) {
2776         DocCommentTree docCommentTree = getDocCommentTree(element);
2777         return docCommentTree == null
2778                 ? Collections.emptyList()
2779                 : docCommentTree.getPreamble();
2780     }
2781 
2782     public List&lt;? extends DocTree&gt; getFullBody(Element element) {
2783         DocCommentTree docCommentTree = getDocCommentTree(element);
2784             return (docCommentTree == null)
2785                     ? Collections.emptyList()
2786                     : docCommentTree.getFullBody();
2787     }
2788 
2789     public List&lt;? extends DocTree&gt; getBody(Element element) {
2790         DocCommentTree docCommentTree = getDocCommentTree(element);
2791         return (docCommentTree == null)
2792                 ? Collections.emptyList()
2793                 : docCommentTree.getFullBody();
2794     }
2795 
2796     public List&lt;? extends DocTree&gt; getDeprecatedTrees(Element element) {
2797         return getBlockTags(element, DEPRECATED);
2798     }
2799 
2800     public List&lt;? extends DocTree&gt; getProvidesTrees(Element element) {
2801         return getBlockTags(element, PROVIDES);
2802     }
2803 
2804     public List&lt;? extends DocTree&gt; getSeeTrees(Element element) {
2805         return getBlockTags(element, SEE);
2806     }
2807 
2808     public List&lt;? extends DocTree&gt; getSerialTrees(Element element) {
2809         return getBlockTags(element, SERIAL);
2810     }
2811 
2812     public List&lt;? extends DocTree&gt; getSerialFieldTrees(VariableElement field) {
2813         return getBlockTags(field, DocTree.Kind.SERIAL_FIELD);
2814     }
2815 
2816     public List&lt;? extends DocTree&gt; getThrowsTrees(Element element) {
2817         return getBlockTags(element, DocTree.Kind.EXCEPTION, DocTree.Kind.THROWS);
2818     }
2819 
2820     public List&lt;? extends ParamTree&gt; getTypeParamTrees(Element element) {
2821         return getParamTrees(element, true);
2822     }
2823 
2824     public List&lt;? extends ParamTree&gt; getParamTrees(Element element) {
2825         return getParamTrees(element, false);
2826     }
2827 
2828     private  List&lt;? extends ParamTree&gt; getParamTrees(Element element, boolean isTypeParameters) {
2829         List&lt;ParamTree&gt; out = new ArrayList&lt;&gt;();
2830         for (DocTree dt : getBlockTags(element, PARAM)) {
2831             ParamTree pt = (ParamTree) dt;
2832             if (pt.isTypeParameter() == isTypeParameters) {
2833                 out.add(pt);
2834             }
2835         }
2836         return out;
2837     }
2838 
2839     public  List&lt;? extends DocTree&gt; getReturnTrees(Element element) {
2840         return new ArrayList&lt;&gt;(getBlockTags(element, RETURN));
2841     }
2842 
2843     public List&lt;? extends DocTree&gt; getUsesTrees(Element element) {
2844         return getBlockTags(element, USES);
2845     }
2846 
2847     public List&lt;? extends DocTree&gt; getFirstSentenceTrees(Element element) {
2848         DocCommentTree dcTree = getDocCommentTree(element);
2849         if (dcTree == null) {
2850             return Collections.emptyList();
2851         }
2852         return new ArrayList&lt;&gt;(dcTree.getFirstSentence());
2853     }
2854 
2855     public ModuleElement containingModule(Element e) {
2856         return elementUtils.getModuleOf(e);
2857     }
2858 
2859     public PackageElement containingPackage(Element e) {
2860         return elementUtils.getPackageOf(e);
2861     }
2862 
2863     public TypeElement getTopMostContainingTypeElement(Element e) {
2864         if (isPackage(e)) {
2865             return null;
2866         }
2867         TypeElement outer = getEnclosingTypeElement(e);
2868         if (outer == null)
2869             return (TypeElement)e;
2870         while (outer != null &amp;&amp; outer.getNestingKind().isNested()) {
2871             outer = getEnclosingTypeElement(outer);
2872         }
2873         return outer;
2874     }
2875 
2876     /**
2877      * A memory-sensitive cache for {@link CommentHelper} objects,
2878      * which are expensive to compute.
2879      */
2880     private static class CommentHelperCache {
2881 
2882         private final Map&lt;Element, SoftReference&lt;CommentHelper&gt;&gt; map;
2883         private final Utils utils;
2884 
2885         public CommentHelperCache(Utils utils) {
2886             map = new HashMap&lt;&gt;();
2887             this.utils = utils;
2888         }
2889 
2890         public CommentHelper remove(Element key) {
2891             SoftReference&lt;CommentHelper&gt; value = map.remove(key);
2892             return value == null ? null : value.get();
2893         }
2894 
2895         public CommentHelper put(Element key, CommentHelper value) {
2896             SoftReference&lt;CommentHelper&gt; prev = map.put(key, new SoftReference&lt;&gt;(value));
2897             return prev == null ? null : prev.get();
2898         }
2899 
2900         public CommentHelper get(Object key) {
2901             SoftReference&lt;CommentHelper&gt; value = map.get(key);
2902             return value == null ? null : value.get();
2903         }
2904 
2905         public CommentHelper computeIfAbsent(Element key) {
2906             SoftReference&lt;CommentHelper&gt; refValue = map.get(key);
2907             if (refValue != null) {
2908                 CommentHelper value = refValue.get();
2909                 if (value != null) {
2910                     return value;
2911                 }
2912             }
2913             CommentHelper newValue = new CommentHelper(utils.configuration, key, utils.getTreePath(key),
2914                     utils.getDocCommentTree(key));
2915             map.put(key, new SoftReference&lt;&gt;(newValue));
2916             return newValue;
2917         }
2918     }
2919 
2920     /**
2921      * A container holding a pair of values (tuple).
2922      *
2923      * @param &lt;K&gt; the type of the first value
2924      * @param &lt;L&gt; the type of the second value
2925      */
2926     public static class Pair&lt;K, L&gt; {
2927         public final K first;
2928         public final L second;
2929 
2930         public Pair(K first, L second) {
2931             this.first = first;
2932             this.second = second;
2933         }
2934 
2935         @Override
2936         public String toString() {
2937             return first + &quot;:&quot; + second;
2938         }
2939     }
2940 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
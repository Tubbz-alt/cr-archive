<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.code;
  27 
  28 import java.lang.ref.SoftReference;
  29 import java.util.HashSet;
  30 import java.util.HashMap;
  31 import java.util.Locale;
  32 import java.util.Map;
  33 import java.util.Optional;
  34 import java.util.Set;
  35 import java.util.WeakHashMap;
  36 import java.util.function.BiPredicate;
  37 import java.util.function.Function;
  38 import java.util.stream.Collector;
  39 
  40 import javax.tools.JavaFileObject;
  41 
  42 import com.sun.tools.javac.code.Attribute.RetentionPolicy;
  43 import com.sun.tools.javac.code.Lint.LintCategory;
  44 import com.sun.tools.javac.code.Source.Feature;
  45 import com.sun.tools.javac.code.Type.UndetVar.InferenceBound;
  46 import com.sun.tools.javac.code.TypeMetadata.Entry.Kind;
  47 import com.sun.tools.javac.comp.AttrContext;
  48 import com.sun.tools.javac.comp.Check;
  49 import com.sun.tools.javac.comp.Enter;
  50 import com.sun.tools.javac.comp.Env;
  51 import com.sun.tools.javac.comp.LambdaToMethod;
  52 import com.sun.tools.javac.jvm.ClassFile;
  53 import com.sun.tools.javac.util.*;
  54 
  55 import static com.sun.tools.javac.code.BoundKind.*;
  56 import static com.sun.tools.javac.code.Flags.*;
  57 import static com.sun.tools.javac.code.Kinds.Kind.*;
  58 import static com.sun.tools.javac.code.Scope.*;
  59 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  60 import static com.sun.tools.javac.code.Symbol.*;
  61 import static com.sun.tools.javac.code.Type.*;
  62 import static com.sun.tools.javac.code.TypeTag.*;
  63 import static com.sun.tools.javac.jvm.ClassFile.externalize;
  64 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  65 
  66 /**
  67  * Utility class containing various operations on types.
  68  *
  69  * &lt;p&gt;Unless other names are more illustrative, the following naming
  70  * conventions should be observed in this file:
  71  *
  72  * &lt;dl&gt;
  73  * &lt;dt&gt;t&lt;/dt&gt;
  74  * &lt;dd&gt;If the first argument to an operation is a type, it should be named t.&lt;/dd&gt;
  75  * &lt;dt&gt;s&lt;/dt&gt;
  76  * &lt;dd&gt;Similarly, if the second argument to an operation is a type, it should be named s.&lt;/dd&gt;
  77  * &lt;dt&gt;ts&lt;/dt&gt;
  78  * &lt;dd&gt;If an operations takes a list of types, the first should be named ts.&lt;/dd&gt;
  79  * &lt;dt&gt;ss&lt;/dt&gt;
  80  * &lt;dd&gt;A second list of types should be named ss.&lt;/dd&gt;
  81  * &lt;/dl&gt;
  82  *
  83  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  84  * If you write code that depends on this, you do so at your own risk.
  85  * This code and its internal interfaces are subject to change or
  86  * deletion without notice.&lt;/b&gt;
  87  */
  88 public class Types {
  89     protected static final Context.Key&lt;Types&gt; typesKey = new Context.Key&lt;&gt;();
  90 
  91     final Symtab syms;
  92     final JavacMessages messages;
  93     final Names names;
  94     final boolean allowDefaultMethods;
  95     final boolean mapCapturesToBounds;
  96     final Check chk;
  97     final Enter enter;
  98     JCDiagnostic.Factory diags;
  99     List&lt;Warner&gt; warnStack = List.nil();
 100     final Name capturedName;
 101 
 102     public final Warner noWarnings;
 103 
 104     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Instantiating&quot;&gt;
 105     public static Types instance(Context context) {
 106         Types instance = context.get(typesKey);
 107         if (instance == null)
 108             instance = new Types(context);
 109         return instance;
 110     }
 111 
 112     protected Types(Context context) {
 113         context.put(typesKey, this);
 114         syms = Symtab.instance(context);
 115         names = Names.instance(context);
 116         Source source = Source.instance(context);
 117         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 118         mapCapturesToBounds = Feature.MAP_CAPTURES_TO_BOUNDS.allowedInSource(source);
 119         chk = Check.instance(context);
 120         enter = Enter.instance(context);
 121         capturedName = names.fromString(&quot;&lt;captured wildcard&gt;&quot;);
 122         messages = JavacMessages.instance(context);
 123         diags = JCDiagnostic.Factory.instance(context);
 124         noWarnings = new Warner(null);
 125     }
 126     // &lt;/editor-fold&gt;
 127 
 128     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;bounds&quot;&gt;
 129     /**
 130      * Get a wildcard&#39;s upper bound, returning non-wildcards unchanged.
 131      * @param t a type argument, either a wildcard or a type
 132      */
 133     public Type wildUpperBound(Type t) {
 134         if (t.hasTag(WILDCARD)) {
 135             WildcardType w = (WildcardType) t;
 136             if (w.isSuperBound())
 137                 return w.bound == null ? syms.objectType : w.bound.getUpperBound();
 138             else
 139                 return wildUpperBound(w.type);
 140         }
 141         else return t;
 142     }
 143 
 144     /**
 145      * Get a capture variable&#39;s upper bound, returning other types unchanged.
 146      * @param t a type
 147      */
 148     public Type cvarUpperBound(Type t) {
 149         if (t.hasTag(TYPEVAR)) {
 150             TypeVar v = (TypeVar) t;
 151             return v.isCaptured() ? cvarUpperBound(v.getUpperBound()) : v;
 152         }
 153         else return t;
 154     }
 155 
 156     /**
 157      * Get a wildcard&#39;s lower bound, returning non-wildcards unchanged.
 158      * @param t a type argument, either a wildcard or a type
 159      */
 160     public Type wildLowerBound(Type t) {
 161         if (t.hasTag(WILDCARD)) {
 162             WildcardType w = (WildcardType) t;
 163             return w.isExtendsBound() ? syms.botType : wildLowerBound(w.type);
 164         }
 165         else return t;
 166     }
 167 
 168     /**
 169      * Get a capture variable&#39;s lower bound, returning other types unchanged.
 170      * @param t a type
 171      */
 172     public Type cvarLowerBound(Type t) {
 173         if (t.hasTag(TYPEVAR) &amp;&amp; ((TypeVar) t).isCaptured()) {
 174             return cvarLowerBound(t.getLowerBound());
 175         }
 176         else return t;
 177     }
 178 
 179     /**
 180      * Recursively skip type-variables until a class/array type is found; capture conversion is then
 181      * (optionally) applied to the resulting type. This is useful for i.e. computing a site that is
 182      * suitable for a method lookup.
 183      */
 184     public Type skipTypeVars(Type site, boolean capture) {
 185         while (site.hasTag(TYPEVAR)) {
 186             site = site.getUpperBound();
 187         }
 188         return capture ? capture(site) : site;
 189     }
 190     // &lt;/editor-fold&gt;
 191 
 192     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;projections&quot;&gt;
 193 
 194     /**
 195      * A projection kind. See {@link TypeProjection}
 196      */
 197     enum ProjectionKind {
 198         UPWARDS() {
 199             @Override
 200             ProjectionKind complement() {
 201                 return DOWNWARDS;
 202             }
 203         },
 204         DOWNWARDS() {
 205             @Override
 206             ProjectionKind complement() {
 207                 return UPWARDS;
 208             }
 209         };
 210 
 211         abstract ProjectionKind complement();
 212     }
 213 
 214     /**
 215      * This visitor performs upwards and downwards projections on types.
 216      *
 217      * A projection is defined as a function that takes a type T, a set of type variables V and that
 218      * produces another type S.
 219      *
 220      * An upwards projection maps a type T into a type S such that (i) T has no variables in V,
 221      * and (ii) S is an upper bound of T.
 222      *
 223      * A downwards projection maps a type T into a type S such that (i) T has no variables in V,
 224      * and (ii) S is a lower bound of T.
 225      *
 226      * Note that projections are only allowed to touch variables in V. Therefore, it is possible for
 227      * a projection to leave its input type unchanged if it does not contain any variables in V.
 228      *
 229      * Moreover, note that while an upwards projection is always defined (every type as an upper bound),
 230      * a downwards projection is not always defined.
 231      *
 232      * Examples:
 233      *
 234      * {@code upwards(List&lt;#CAP1&gt;, [#CAP1]) = List&lt;? extends String&gt;, where #CAP1 &lt;: String }
 235      * {@code downwards(List&lt;#CAP2&gt;, [#CAP2]) = List&lt;? super String&gt;, where #CAP2 :&gt; String }
 236      * {@code upwards(List&lt;#CAP1&gt;, [#CAP2]) = List&lt;#CAP1&gt; }
 237      * {@code downwards(List&lt;#CAP1&gt;, [#CAP1]) = not defined }
 238      */
 239     class TypeProjection extends TypeMapping&lt;ProjectionKind&gt; {
 240 
 241         List&lt;Type&gt; vars;
 242         Set&lt;Type&gt; seen = new HashSet&lt;&gt;();
 243 
 244         public TypeProjection(List&lt;Type&gt; vars) {
 245             this.vars = vars;
 246         }
 247 
 248         @Override
 249         public Type visitClassType(ClassType t, ProjectionKind pkind) {
 250             if (t.isCompound()) {
 251                 List&lt;Type&gt; components = directSupertypes(t);
 252                 List&lt;Type&gt; components1 = components.map(c -&gt; c.map(this, pkind));
 253                 if (components == components1) return t;
 254                 else return makeIntersectionType(components1);
 255             } else {
 256                 Type outer = t.getEnclosingType();
 257                 Type outer1 = visit(outer, pkind);
 258                 List&lt;Type&gt; typarams = t.getTypeArguments();
 259                 List&lt;Type&gt; formals = t.tsym.type.getTypeArguments();
 260                 ListBuffer&lt;Type&gt; typarams1 = new ListBuffer&lt;&gt;();
 261                 boolean changed = false;
 262                 for (Type actual : typarams) {
 263                     Type t2 = mapTypeArgument(t, formals.head.getUpperBound(), actual, pkind);
 264                     if (t2.hasTag(BOT)) {
 265                         //not defined
 266                         return syms.botType;
 267                     }
 268                     typarams1.add(t2);
 269                     changed |= actual != t2;
 270                     formals = formals.tail;
 271                 }
 272                 if (outer1 == outer &amp;&amp; !changed) return t;
 273                 else return new ClassType(outer1, typarams1.toList(), t.tsym, t.getMetadata()) {
 274                     @Override
 275                     protected boolean needsStripping() {
 276                         return true;
 277                     }
 278                 };
 279             }
 280         }
 281 
 282         @Override
 283         public Type visitArrayType(ArrayType t, ProjectionKind s) {
 284             Type elemtype = t.elemtype;
 285             Type elemtype1 = visit(elemtype, s);
 286             if (elemtype1 == elemtype) {
 287                 return t;
 288             } else if (elemtype1.hasTag(BOT)) {
 289                 //undefined
 290                 return syms.botType;
 291             } else {
 292                 return new ArrayType(elemtype1, t.tsym, t.metadata) {
 293                     @Override
 294                     protected boolean needsStripping() {
 295                         return true;
 296                     }
 297                 };
 298             }
 299         }
 300 
 301         @Override
 302         public Type visitTypeVar(TypeVar t, ProjectionKind pkind) {
 303             if (vars.contains(t)) {
 304                 if (seen.add(t)) {
 305                     try {
 306                         final Type bound;
 307                         switch (pkind) {
 308                             case UPWARDS:
 309                                 bound = t.getUpperBound();
 310                                 break;
 311                             case DOWNWARDS:
 312                                 bound = (t.getLowerBound() == null) ?
 313                                         syms.botType :
 314                                         t.getLowerBound();
 315                                 break;
 316                             default:
 317                                 Assert.error();
 318                                 return null;
 319                         }
 320                         return bound.map(this, pkind);
 321                     } finally {
 322                         seen.remove(t);
 323                     }
 324                 } else {
 325                     //cycle
 326                     return pkind == ProjectionKind.UPWARDS ?
 327                             syms.objectType : syms.botType;
 328                 }
 329             } else {
 330                 return t;
 331             }
 332         }
 333 
 334         private Type mapTypeArgument(Type site, Type declaredBound, Type t, ProjectionKind pkind) {
 335             return t.containsAny(vars) ?
 336                     t.map(new TypeArgumentProjection(site, declaredBound), pkind) :
 337                     t;
 338         }
 339 
 340         class TypeArgumentProjection extends TypeMapping&lt;ProjectionKind&gt; {
 341 
 342             Type site;
 343             Type declaredBound;
 344 
 345             TypeArgumentProjection(Type site, Type declaredBound) {
 346                 this.site = site;
 347                 this.declaredBound = declaredBound;
 348             }
 349 
 350             @Override
 351             public Type visitType(Type t, ProjectionKind pkind) {
 352                 //type argument is some type containing restricted vars
 353                 if (pkind == ProjectionKind.DOWNWARDS) {
 354                     //not defined
 355                     return syms.botType;
 356                 }
 357                 Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS);
 358                 Type lower = t.map(TypeProjection.this, ProjectionKind.DOWNWARDS);
 359                 List&lt;Type&gt; formals = site.tsym.type.getTypeArguments();
 360                 BoundKind bk;
 361                 Type bound;
 362                 if (!isSameType(upper, syms.objectType) &amp;&amp;
 363                         (declaredBound.containsAny(formals) ||
 364                          !isSubtype(declaredBound, upper))) {
 365                     bound = upper;
 366                     bk = EXTENDS;
 367                 } else if (!lower.hasTag(BOT)) {
 368                     bound = lower;
 369                     bk = SUPER;
 370                 } else {
 371                     bound = syms.objectType;
 372                     bk = UNBOUND;
 373                 }
 374                 return makeWildcard(bound, bk);
 375             }
 376 
 377             @Override
 378             public Type visitWildcardType(WildcardType wt, ProjectionKind pkind) {
 379                 //type argument is some wildcard whose bound contains restricted vars
 380                 Type bound = syms.botType;
 381                 BoundKind bk = wt.kind;
 382                 switch (wt.kind) {
 383                     case EXTENDS:
 384                         bound = wt.type.map(TypeProjection.this, pkind);
 385                         if (bound.hasTag(BOT)) {
 386                             return syms.botType;
 387                         }
 388                         break;
 389                     case SUPER:
 390                         bound = wt.type.map(TypeProjection.this, pkind.complement());
 391                         if (bound.hasTag(BOT)) {
 392                             bound = syms.objectType;
 393                             bk = UNBOUND;
 394                         }
 395                         break;
 396                 }
 397                 return makeWildcard(bound, bk);
 398             }
 399 
 400             private Type makeWildcard(Type bound, BoundKind bk) {
 401                 return new WildcardType(bound, bk, syms.boundClass) {
 402                     @Override
 403                     protected boolean needsStripping() {
 404                         return true;
 405                     }
 406                 };
 407             }
 408         }
 409     }
 410 
 411     /**
 412      * Computes an upward projection of given type, and vars. See {@link TypeProjection}.
 413      *
 414      * @param t the type to be projected
 415      * @param vars the set of type variables to be mapped
 416      * @return the type obtained as result of the projection
 417      */
 418     public Type upward(Type t, List&lt;Type&gt; vars) {
 419         return t.map(new TypeProjection(vars), ProjectionKind.UPWARDS);
 420     }
 421 
 422     /**
 423      * Computes the set of captured variables mentioned in a given type. See {@link CaptureScanner}.
 424      * This routine is typically used to computed the input set of variables to be used during
 425      * an upwards projection (see {@link Types#upward(Type, List)}).
 426      *
 427      * @param t the type where occurrences of captured variables have to be found
 428      * @return the set of captured variables found in t
 429      */
 430     public List&lt;Type&gt; captures(Type t) {
 431         CaptureScanner cs = new CaptureScanner();
 432         Set&lt;Type&gt; captures = new HashSet&lt;&gt;();
 433         cs.visit(t, captures);
 434         return List.from(captures);
 435     }
 436 
 437     /**
 438      * This visitor scans a type recursively looking for occurrences of captured type variables.
 439      */
 440     class CaptureScanner extends SimpleVisitor&lt;Void, Set&lt;Type&gt;&gt; {
 441 
 442         @Override
 443         public Void visitType(Type t, Set&lt;Type&gt; types) {
 444             return null;
 445         }
 446 
 447         @Override
 448         public Void visitClassType(ClassType t, Set&lt;Type&gt; seen) {
 449             if (t.isCompound()) {
 450                 directSupertypes(t).forEach(s -&gt; visit(s, seen));
 451             } else {
 452                 t.allparams().forEach(ta -&gt; visit(ta, seen));
 453             }
 454             return null;
 455         }
 456 
 457         @Override
 458         public Void visitArrayType(ArrayType t, Set&lt;Type&gt; seen) {
 459             return visit(t.elemtype, seen);
 460         }
 461 
 462         @Override
 463         public Void visitWildcardType(WildcardType t, Set&lt;Type&gt; seen) {
 464             visit(t.type, seen);
 465             return null;
 466         }
 467 
 468         @Override
 469         public Void visitTypeVar(TypeVar t, Set&lt;Type&gt; seen) {
 470             if ((t.tsym.flags() &amp; Flags.SYNTHETIC) != 0 &amp;&amp; seen.add(t)) {
 471                 visit(t.getUpperBound(), seen);
 472             }
 473             return null;
 474         }
 475 
 476         @Override
 477         public Void visitCapturedType(CapturedType t, Set&lt;Type&gt; seen) {
 478             if (seen.add(t)) {
 479                 visit(t.getUpperBound(), seen);
 480                 visit(t.getLowerBound(), seen);
 481             }
 482             return null;
 483         }
 484     }
 485 
 486     // &lt;/editor-fold&gt;
 487 
 488     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isUnbounded&quot;&gt;
 489     /**
 490      * Checks that all the arguments to a class are unbounded
 491      * wildcards or something else that doesn&#39;t make any restrictions
 492      * on the arguments. If a class isUnbounded, a raw super- or
 493      * subclass can be cast to it without a warning.
 494      * @param t a type
 495      * @return true iff the given type is unbounded or raw
 496      */
 497     public boolean isUnbounded(Type t) {
 498         return isUnbounded.visit(t);
 499     }
 500     // where
 501         private final UnaryVisitor&lt;Boolean&gt; isUnbounded = new UnaryVisitor&lt;Boolean&gt;() {
 502 
 503             public Boolean visitType(Type t, Void ignored) {
 504                 return true;
 505             }
 506 
 507             @Override
 508             public Boolean visitClassType(ClassType t, Void ignored) {
 509                 List&lt;Type&gt; parms = t.tsym.type.allparams();
 510                 List&lt;Type&gt; args = t.allparams();
 511                 while (parms.nonEmpty()) {
 512                     WildcardType unb = new WildcardType(syms.objectType,
 513                                                         BoundKind.UNBOUND,
 514                                                         syms.boundClass,
 515                                                         (TypeVar)parms.head);
 516                     if (!containsType(args.head, unb))
 517                         return false;
 518                     parms = parms.tail;
 519                     args = args.tail;
 520                 }
 521                 return true;
 522             }
 523         };
 524     // &lt;/editor-fold&gt;
 525 
 526     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;asSub&quot;&gt;
 527     /**
 528      * Return the least specific subtype of t that starts with symbol
 529      * sym.  If none exists, return null.  The least specific subtype
 530      * is determined as follows:
 531      *
 532      * &lt;p&gt;If there is exactly one parameterized instance of sym that is a
 533      * subtype of t, that parameterized instance is returned.&lt;br&gt;
 534      * Otherwise, if the plain type or raw type `sym&#39; is a subtype of
 535      * type t, the type `sym&#39; itself is returned.  Otherwise, null is
 536      * returned.
 537      */
 538     public Type asSub(Type t, Symbol sym) {
 539         return asSub.visit(t, sym);
 540     }
 541     // where
 542         private final SimpleVisitor&lt;Type,Symbol&gt; asSub = new SimpleVisitor&lt;Type,Symbol&gt;() {
 543 
 544             public Type visitType(Type t, Symbol sym) {
 545                 return null;
 546             }
 547 
 548             @Override
 549             public Type visitClassType(ClassType t, Symbol sym) {
 550                 if (t.tsym == sym)
 551                     return t;
 552                 Type base = asSuper(sym.type, t.tsym);
 553                 if (base == null)
 554                     return null;
 555                 ListBuffer&lt;Type&gt; from = new ListBuffer&lt;&gt;();
 556                 ListBuffer&lt;Type&gt; to = new ListBuffer&lt;&gt;();
 557                 try {
 558                     adapt(base, t, from, to);
 559                 } catch (AdaptFailure ex) {
 560                     return null;
 561                 }
 562                 Type res = subst(sym.type, from.toList(), to.toList());
 563                 if (!isSubtype(res, t))
 564                     return null;
 565                 ListBuffer&lt;Type&gt; openVars = new ListBuffer&lt;&gt;();
 566                 for (List&lt;Type&gt; l = sym.type.allparams();
 567                      l.nonEmpty(); l = l.tail)
 568                     if (res.contains(l.head) &amp;&amp; !t.contains(l.head))
 569                         openVars.append(l.head);
 570                 if (openVars.nonEmpty()) {
 571                     if (t.isRaw()) {
 572                         // The subtype of a raw type is raw
 573                         res = erasure(res);
 574                     } else {
 575                         // Unbound type arguments default to ?
 576                         List&lt;Type&gt; opens = openVars.toList();
 577                         ListBuffer&lt;Type&gt; qs = new ListBuffer&lt;&gt;();
 578                         for (List&lt;Type&gt; iter = opens; iter.nonEmpty(); iter = iter.tail) {
 579                             qs.append(new WildcardType(syms.objectType, BoundKind.UNBOUND,
 580                                                        syms.boundClass, (TypeVar) iter.head));
 581                         }
 582                         res = subst(res, opens, qs.toList());
 583                     }
 584                 }
 585                 return res;
 586             }
 587 
 588             @Override
 589             public Type visitErrorType(ErrorType t, Symbol sym) {
 590                 return t;
 591             }
 592         };
 593     // &lt;/editor-fold&gt;
 594 
 595     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isConvertible&quot;&gt;
 596     /**
 597      * Is t a subtype of or convertible via boxing/unboxing
 598      * conversion to s?
 599      */
 600     public boolean isConvertible(Type t, Type s, Warner warn) {
 601         if (t.hasTag(ERROR)) {
 602             return true;
 603         }
 604         boolean tPrimitive = t.isPrimitive();
 605         boolean sPrimitive = s.isPrimitive();
 606         if (tPrimitive == sPrimitive) {
 607             return isSubtypeUnchecked(t, s, warn);
 608         }
 609         boolean tUndet = t.hasTag(UNDETVAR);
 610         boolean sUndet = s.hasTag(UNDETVAR);
 611 
 612         if (tUndet || sUndet) {
 613             return tUndet ?
 614                     isSubtype(t, boxedTypeOrType(s)) :
 615                     isSubtype(boxedTypeOrType(t), s);
 616         }
 617 
 618         return tPrimitive
 619             ? isSubtype(boxedClass(t).type, s)
 620             : isSubtype(unboxedType(t), s);
 621     }
 622 
 623     /**
 624      * Is t a subtype of or convertible via boxing/unboxing
 625      * conversions to s?
 626      */
 627     public boolean isConvertible(Type t, Type s) {
 628         return isConvertible(t, s, noWarnings);
 629     }
 630     // &lt;/editor-fold&gt;
 631 
 632     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;findSam&quot;&gt;
 633 
 634     /**
 635      * Exception used to report a function descriptor lookup failure. The exception
 636      * wraps a diagnostic that can be used to generate more details error
 637      * messages.
 638      */
 639     public static class FunctionDescriptorLookupError extends RuntimeException {
 640         private static final long serialVersionUID = 0;
 641 
 642         transient JCDiagnostic diagnostic;
 643 
 644         FunctionDescriptorLookupError() {
 645             this.diagnostic = null;
 646         }
 647 
 648         FunctionDescriptorLookupError setMessage(JCDiagnostic diag) {
 649             this.diagnostic = diag;
 650             return this;
 651         }
 652 
 653         public JCDiagnostic getDiagnostic() {
 654             return diagnostic;
 655         }
 656     }
 657 
 658     /**
 659      * A cache that keeps track of function descriptors associated with given
 660      * functional interfaces.
 661      */
 662     class DescriptorCache {
 663 
 664         private WeakHashMap&lt;TypeSymbol, Entry&gt; _map = new WeakHashMap&lt;&gt;();
 665 
 666         class FunctionDescriptor {
 667             Symbol descSym;
 668 
 669             FunctionDescriptor(Symbol descSym) {
 670                 this.descSym = descSym;
 671             }
 672 
 673             public Symbol getSymbol() {
 674                 return descSym;
 675             }
 676 
 677             public Type getType(Type site) {
 678                 site = removeWildcards(site);
 679                 if (site.isIntersection()) {
 680                     IntersectionClassType ict = (IntersectionClassType)site;
 681                     for (Type component : ict.getExplicitComponents()) {
 682                         if (!chk.checkValidGenericType(component)) {
 683                             //if the inferred functional interface type is not well-formed,
 684                             //or if it&#39;s not a subtype of the original target, issue an error
 685                             throw failure(diags.fragment(Fragments.NoSuitableFunctionalIntfInst(site)));
 686                         }
 687                     }
 688                 } else {
 689                     if (!chk.checkValidGenericType(site)) {
 690                         //if the inferred functional interface type is not well-formed,
 691                         //or if it&#39;s not a subtype of the original target, issue an error
 692                         throw failure(diags.fragment(Fragments.NoSuitableFunctionalIntfInst(site)));
 693                     }
 694                 }
 695                 return memberType(site, descSym);
 696             }
 697         }
 698 
 699         class Entry {
 700             final FunctionDescriptor cachedDescRes;
 701             final int prevMark;
 702 
 703             public Entry(FunctionDescriptor cachedDescRes,
 704                     int prevMark) {
 705                 this.cachedDescRes = cachedDescRes;
 706                 this.prevMark = prevMark;
 707             }
 708 
 709             boolean matches(int mark) {
 710                 return  this.prevMark == mark;
 711             }
 712         }
 713 
 714         FunctionDescriptor get(TypeSymbol origin) throws FunctionDescriptorLookupError {
 715             Entry e = _map.get(origin);
 716             CompoundScope members = membersClosure(origin.type, false);
 717             if (e == null ||
 718                     !e.matches(members.getMark())) {
 719                 FunctionDescriptor descRes = findDescriptorInternal(origin, members);
 720                 _map.put(origin, new Entry(descRes, members.getMark()));
 721                 return descRes;
 722             }
 723             else {
 724                 return e.cachedDescRes;
 725             }
 726         }
 727 
 728         /**
 729          * Compute the function descriptor associated with a given functional interface
 730          */
 731         public FunctionDescriptor findDescriptorInternal(TypeSymbol origin,
 732                 CompoundScope membersCache) throws FunctionDescriptorLookupError {
 733             if (!origin.isInterface() || (origin.flags() &amp; ANNOTATION) != 0 || origin.isSealed()) {
 734                 //t must be an interface
 735                 throw failure(&quot;not.a.functional.intf&quot;, origin);
 736             }
 737 
 738             final ListBuffer&lt;Symbol&gt; abstracts = new ListBuffer&lt;&gt;();
 739             for (Symbol sym : membersCache.getSymbols(new DescriptorFilter(origin))) {
 740                 Type mtype = memberType(origin.type, sym);
 741                 if (abstracts.isEmpty()) {
 742                     abstracts.append(sym);
 743                 } else if ((sym.name == abstracts.first().name &amp;&amp;
 744                         overrideEquivalent(mtype, memberType(origin.type, abstracts.first())))) {
 745                     if (!abstracts.stream().filter(msym -&gt; msym.owner.isSubClass(sym.enclClass(), Types.this))
 746                             .map(msym -&gt; memberType(origin.type, msym))
 747                             .anyMatch(abstractMType -&gt; isSubSignature(abstractMType, mtype))) {
 748                         abstracts.append(sym);
 749                     }
 750                 } else {
 751                     //the target method(s) should be the only abstract members of t
 752                     throw failure(&quot;not.a.functional.intf.1&quot;,  origin,
 753                             diags.fragment(Fragments.IncompatibleAbstracts(Kinds.kindName(origin), origin)));
 754                 }
 755             }
 756             if (abstracts.isEmpty()) {
 757                 //t must define a suitable non-generic method
 758                 throw failure(&quot;not.a.functional.intf.1&quot;, origin,
 759                             diags.fragment(Fragments.NoAbstracts(Kinds.kindName(origin), origin)));
 760             } else if (abstracts.size() == 1) {
 761                 return new FunctionDescriptor(abstracts.first());
 762             } else { // size &gt; 1
 763                 FunctionDescriptor descRes = mergeDescriptors(origin, abstracts.toList());
 764                 if (descRes == null) {
 765                     //we can get here if the functional interface is ill-formed
 766                     ListBuffer&lt;JCDiagnostic&gt; descriptors = new ListBuffer&lt;&gt;();
 767                     for (Symbol desc : abstracts) {
 768                         String key = desc.type.getThrownTypes().nonEmpty() ?
 769                                 &quot;descriptor.throws&quot; : &quot;descriptor&quot;;
 770                         descriptors.append(diags.fragment(key, desc.name,
 771                                 desc.type.getParameterTypes(),
 772                                 desc.type.getReturnType(),
 773                                 desc.type.getThrownTypes()));
 774                     }
 775                     JCDiagnostic msg =
 776                             diags.fragment(Fragments.IncompatibleDescsInFunctionalIntf(Kinds.kindName(origin),
 777                                                                                        origin));
 778                     JCDiagnostic.MultilineDiagnostic incompatibleDescriptors =
 779                             new JCDiagnostic.MultilineDiagnostic(msg, descriptors.toList());
 780                     throw failure(incompatibleDescriptors);
 781                 }
 782                 return descRes;
 783             }
 784         }
 785 
 786         /**
 787          * Compute a synthetic type for the target descriptor given a list
 788          * of override-equivalent methods in the functional interface type.
 789          * The resulting method type is a method type that is override-equivalent
 790          * and return-type substitutable with each method in the original list.
 791          */
 792         private FunctionDescriptor mergeDescriptors(TypeSymbol origin, List&lt;Symbol&gt; methodSyms) {
 793             return mergeAbstracts(methodSyms, origin.type, false)
 794                     .map(bestSoFar -&gt; new FunctionDescriptor(bestSoFar.baseSymbol()) {
 795                         @Override
 796                         public Type getType(Type origin) {
 797                             Type mt = memberType(origin, getSymbol());
 798                             return createMethodTypeWithThrown(mt, bestSoFar.type.getThrownTypes());
 799                         }
 800                     }).orElse(null);
 801         }
 802 
 803         FunctionDescriptorLookupError failure(String msg, Object... args) {
 804             return failure(diags.fragment(msg, args));
 805         }
 806 
 807         FunctionDescriptorLookupError failure(JCDiagnostic diag) {
 808             return new FunctionDescriptorLookupError().setMessage(diag);
 809         }
 810     }
 811 
 812     private DescriptorCache descCache = new DescriptorCache();
 813 
 814     /**
 815      * Find the method descriptor associated to this class symbol - if the
 816      * symbol &#39;origin&#39; is not a functional interface, an exception is thrown.
 817      */
 818     public Symbol findDescriptorSymbol(TypeSymbol origin) throws FunctionDescriptorLookupError {
 819         return descCache.get(origin).getSymbol();
 820     }
 821 
 822     /**
 823      * Find the type of the method descriptor associated to this class symbol -
 824      * if the symbol &#39;origin&#39; is not a functional interface, an exception is thrown.
 825      */
 826     public Type findDescriptorType(Type origin) throws FunctionDescriptorLookupError {
 827         return descCache.get(origin.tsym).getType(origin);
 828     }
 829 
 830     /**
 831      * Is given type a functional interface?
 832      */
 833     public boolean isFunctionalInterface(TypeSymbol tsym) {
 834         try {
 835             findDescriptorSymbol(tsym);
 836             return true;
 837         } catch (FunctionDescriptorLookupError ex) {
 838             return false;
 839         }
 840     }
 841 
 842     public boolean isFunctionalInterface(Type site) {
 843         try {
 844             findDescriptorType(site);
 845             return true;
 846         } catch (FunctionDescriptorLookupError ex) {
 847             return false;
 848         }
 849     }
 850 
 851     public Type removeWildcards(Type site) {
 852         if (site.getTypeArguments().stream().anyMatch(t -&gt; t.hasTag(WILDCARD))) {
 853             //compute non-wildcard parameterization - JLS 9.9
 854             List&lt;Type&gt; actuals = site.getTypeArguments();
 855             List&lt;Type&gt; formals = site.tsym.type.getTypeArguments();
 856             ListBuffer&lt;Type&gt; targs = new ListBuffer&lt;&gt;();
 857             for (Type formal : formals) {
 858                 Type actual = actuals.head;
 859                 Type bound = formal.getUpperBound();
 860                 if (actuals.head.hasTag(WILDCARD)) {
 861                     WildcardType wt = (WildcardType)actual;
 862                     //check that bound does not contain other formals
 863                     if (bound.containsAny(formals)) {
 864                         targs.add(wt.type);
 865                     } else {
 866                         //compute new type-argument based on declared bound and wildcard bound
 867                         switch (wt.kind) {
 868                             case UNBOUND:
 869                                 targs.add(bound);
 870                                 break;
 871                             case EXTENDS:
 872                                 targs.add(glb(bound, wt.type));
 873                                 break;
 874                             case SUPER:
 875                                 targs.add(wt.type);
 876                                 break;
 877                             default:
 878                                 Assert.error(&quot;Cannot get here!&quot;);
 879                         }
 880                     }
 881                 } else {
 882                     //not a wildcard - the new type argument remains unchanged
 883                     targs.add(actual);
 884                 }
 885                 actuals = actuals.tail;
 886             }
 887             return subst(site.tsym.type, formals, targs.toList());
 888         } else {
 889             return site;
 890         }
 891     }
 892 
 893     /**
 894      * Create a symbol for a class that implements a given functional interface
 895      * and overrides its functional descriptor. This routine is used for two
 896      * main purposes: (i) checking well-formedness of a functional interface;
 897      * (ii) perform functional interface bridge calculation.
 898      */
 899     public ClassSymbol makeFunctionalInterfaceClass(Env&lt;AttrContext&gt; env, Name name, Type target, long cflags) {
 900         if (target == null || target == syms.unknownType) {
 901             return null;
 902         }
 903         Symbol descSym = findDescriptorSymbol(target.tsym);
 904         Type descType = findDescriptorType(target);
 905         ClassSymbol csym = new ClassSymbol(cflags, name, env.enclClass.sym.outermostClass());
 906         csym.completer = Completer.NULL_COMPLETER;
 907         csym.members_field = WriteableScope.create(csym);
 908         MethodSymbol instDescSym = new MethodSymbol(descSym.flags(), descSym.name, descType, csym);
 909         csym.members_field.enter(instDescSym);
 910         Type.ClassType ctype = new Type.ClassType(Type.noType, List.nil(), csym);
 911         ctype.supertype_field = syms.objectType;
 912         ctype.interfaces_field = target.isIntersection() ?
 913                 directSupertypes(target) :
 914                 List.of(target);
 915         csym.type = ctype;
 916         csym.sourcefile = ((ClassSymbol)csym.owner).sourcefile;
 917         return csym;
 918     }
 919 
 920     /**
 921      * Find the minimal set of methods that are overridden by the functional
 922      * descriptor in &#39;origin&#39;. All returned methods are assumed to have different
 923      * erased signatures.
 924      */
 925     public List&lt;Symbol&gt; functionalInterfaceBridges(TypeSymbol origin) {
 926         Assert.check(isFunctionalInterface(origin));
 927         Symbol descSym = findDescriptorSymbol(origin);
 928         CompoundScope members = membersClosure(origin.type, false);
 929         ListBuffer&lt;Symbol&gt; overridden = new ListBuffer&lt;&gt;();
 930         outer: for (Symbol m2 : members.getSymbolsByName(descSym.name, bridgeFilter)) {
 931             if (m2 == descSym) continue;
 932             else if (descSym.overrides(m2, origin, Types.this, false)) {
 933                 for (Symbol m3 : overridden) {
 934                     if (isSameType(m3.erasure(Types.this), m2.erasure(Types.this)) ||
 935                             (m3.overrides(m2, origin, Types.this, false) &amp;&amp;
 936                             (pendingBridges((ClassSymbol)origin, m3.enclClass()) ||
 937                             (((MethodSymbol)m2).binaryImplementation((ClassSymbol)m3.owner, Types.this) != null)))) {
 938                         continue outer;
 939                     }
 940                 }
 941                 overridden.add(m2);
 942             }
 943         }
 944         return overridden.toList();
 945     }
 946     //where
 947         private Filter&lt;Symbol&gt; bridgeFilter = new Filter&lt;Symbol&gt;() {
 948             public boolean accepts(Symbol t) {
 949                 return t.kind == MTH &amp;&amp;
 950                         t.name != names.init &amp;&amp;
 951                         t.name != names.clinit &amp;&amp;
 952                         (t.flags() &amp; SYNTHETIC) == 0;
 953             }
 954         };
 955         private boolean pendingBridges(ClassSymbol origin, TypeSymbol s) {
 956             //a symbol will be completed from a classfile if (a) symbol has
 957             //an associated file object with CLASS kind and (b) the symbol has
 958             //not been entered
 959             if (origin.classfile != null &amp;&amp;
 960                     origin.classfile.getKind() == JavaFileObject.Kind.CLASS &amp;&amp;
 961                     enter.getEnv(origin) == null) {
 962                 return false;
 963             }
 964             if (origin == s) {
 965                 return true;
 966             }
 967             for (Type t : interfaces(origin.type)) {
 968                 if (pendingBridges((ClassSymbol)t.tsym, s)) {
 969                     return true;
 970                 }
 971             }
 972             return false;
 973         }
 974     // &lt;/editor-fold&gt;
 975 
 976    /**
 977     * Scope filter used to skip methods that should be ignored (such as methods
 978     * overridden by j.l.Object) during function interface conversion interface check
 979     */
 980     class DescriptorFilter implements Filter&lt;Symbol&gt; {
 981 
 982        TypeSymbol origin;
 983 
 984        DescriptorFilter(TypeSymbol origin) {
 985            this.origin = origin;
 986        }
 987 
 988        @Override
 989        public boolean accepts(Symbol sym) {
 990            return sym.kind == MTH &amp;&amp;
 991                    (sym.flags() &amp; (ABSTRACT | DEFAULT)) == ABSTRACT &amp;&amp;
 992                    !overridesObjectMethod(origin, sym) &amp;&amp;
 993                    (interfaceCandidates(origin.type, (MethodSymbol)sym).head.flags() &amp; DEFAULT) == 0;
 994        }
 995     }
 996 
 997     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isSubtype&quot;&gt;
 998     /**
 999      * Is t an unchecked subtype of s?
1000      */
1001     public boolean isSubtypeUnchecked(Type t, Type s) {
1002         return isSubtypeUnchecked(t, s, noWarnings);
1003     }
1004     /**
1005      * Is t an unchecked subtype of s?
1006      */
1007     public boolean isSubtypeUnchecked(Type t, Type s, Warner warn) {
1008         boolean result = isSubtypeUncheckedInternal(t, s, true, warn);
1009         if (result) {
1010             checkUnsafeVarargsConversion(t, s, warn);
1011         }
1012         return result;
1013     }
1014     //where
1015         private boolean isSubtypeUncheckedInternal(Type t, Type s, boolean capture, Warner warn) {
1016             if (t.hasTag(ARRAY) &amp;&amp; s.hasTag(ARRAY)) {
1017                 if (((ArrayType)t).elemtype.isPrimitive()) {
1018                     return isSameType(elemtype(t), elemtype(s));
1019                 } else {
1020                     return isSubtypeUncheckedInternal(elemtype(t), elemtype(s), false, warn);
1021                 }
1022             } else if (isSubtype(t, s, capture)) {
1023                 return true;
1024             } else if (t.hasTag(TYPEVAR)) {
1025                 return isSubtypeUncheckedInternal(t.getUpperBound(), s, false, warn);
1026             } else if (!s.isRaw()) {
1027                 Type t2 = asSuper(t, s.tsym);
1028                 if (t2 != null &amp;&amp; t2.isRaw()) {
1029                     if (isReifiable(s)) {
1030                         warn.silentWarn(LintCategory.UNCHECKED);
1031                     } else {
1032                         warn.warn(LintCategory.UNCHECKED);
1033                     }
1034                     return true;
1035                 }
1036             }
1037             return false;
1038         }
1039 
1040         private void checkUnsafeVarargsConversion(Type t, Type s, Warner warn) {
1041             if (!t.hasTag(ARRAY) || isReifiable(t)) {
1042                 return;
1043             }
1044             ArrayType from = (ArrayType)t;
1045             boolean shouldWarn = false;
1046             switch (s.getTag()) {
1047                 case ARRAY:
1048                     ArrayType to = (ArrayType)s;
1049                     shouldWarn = from.isVarargs() &amp;&amp;
1050                             !to.isVarargs() &amp;&amp;
1051                             !isReifiable(from);
1052                     break;
1053                 case CLASS:
1054                     shouldWarn = from.isVarargs();
1055                     break;
1056             }
1057             if (shouldWarn) {
1058                 warn.warn(LintCategory.VARARGS);
1059             }
1060         }
1061 
1062     /**
1063      * Is t a subtype of s?&lt;br&gt;
1064      * (not defined for Method and ForAll types)
1065      */
1066     final public boolean isSubtype(Type t, Type s) {
1067         return isSubtype(t, s, true);
1068     }
1069     final public boolean isSubtypeNoCapture(Type t, Type s) {
1070         return isSubtype(t, s, false);
1071     }
1072     public boolean isSubtype(Type t, Type s, boolean capture) {
1073         if (t.equalsIgnoreMetadata(s))
1074             return true;
1075         if (s.isPartial())
1076             return isSuperType(s, t);
1077 
1078         if (s.isCompound()) {
1079             for (Type s2 : interfaces(s).prepend(supertype(s))) {
1080                 if (!isSubtype(t, s2, capture))
1081                     return false;
1082             }
1083             return true;
1084         }
1085 
1086         // Generally, if &#39;s&#39; is a lower-bounded type variable, recur on lower bound; but
1087         // for inference variables and intersections, we need to keep &#39;s&#39;
1088         // (see JLS 4.10.2 for intersections and 18.2.3 for inference vars)
1089         if (!t.hasTag(UNDETVAR) &amp;&amp; !t.isCompound()) {
1090             // TODO: JDK-8039198, bounds checking sometimes passes in a wildcard as s
1091             Type lower = cvarLowerBound(wildLowerBound(s));
1092             if (s != lower &amp;&amp; !lower.hasTag(BOT))
1093                 return isSubtype(capture ? capture(t) : t, lower, false);
1094         }
1095 
1096         return isSubtype.visit(capture ? capture(t) : t, s);
1097     }
1098     // where
1099         private TypeRelation isSubtype = new TypeRelation()
1100         {
1101             @Override
1102             public Boolean visitType(Type t, Type s) {
1103                 switch (t.getTag()) {
1104                  case BYTE:
1105                      return (!s.hasTag(CHAR) &amp;&amp; t.getTag().isSubRangeOf(s.getTag()));
1106                  case CHAR:
1107                      return (!s.hasTag(SHORT) &amp;&amp; t.getTag().isSubRangeOf(s.getTag()));
1108                  case SHORT: case INT: case LONG:
1109                  case FLOAT: case DOUBLE:
1110                      return t.getTag().isSubRangeOf(s.getTag());
1111                  case BOOLEAN: case VOID:
1112                      return t.hasTag(s.getTag());
1113                  case TYPEVAR:
1114                      return isSubtypeNoCapture(t.getUpperBound(), s);
1115                  case BOT:
1116                      return
1117                          s.hasTag(BOT) || s.hasTag(CLASS) ||
1118                          s.hasTag(ARRAY) || s.hasTag(TYPEVAR);
1119                  case WILDCARD: //we shouldn&#39;t be here - avoids crash (see 7034495)
1120                  case NONE:
1121                      return false;
1122                  default:
1123                      throw new AssertionError(&quot;isSubtype &quot; + t.getTag());
1124                  }
1125             }
1126 
1127             private Set&lt;TypePair&gt; cache = new HashSet&lt;&gt;();
1128 
1129             private boolean containsTypeRecursive(Type t, Type s) {
1130                 TypePair pair = new TypePair(t, s);
1131                 if (cache.add(pair)) {
1132                     try {
1133                         return containsType(t.getTypeArguments(),
1134                                             s.getTypeArguments());
1135                     } finally {
1136                         cache.remove(pair);
1137                     }
1138                 } else {
1139                     return containsType(t.getTypeArguments(),
1140                                         rewriteSupers(s).getTypeArguments());
1141                 }
1142             }
1143 
1144             private Type rewriteSupers(Type t) {
1145                 if (!t.isParameterized())
1146                     return t;
1147                 ListBuffer&lt;Type&gt; from = new ListBuffer&lt;&gt;();
1148                 ListBuffer&lt;Type&gt; to = new ListBuffer&lt;&gt;();
1149                 adaptSelf(t, from, to);
1150                 if (from.isEmpty())
1151                     return t;
1152                 ListBuffer&lt;Type&gt; rewrite = new ListBuffer&lt;&gt;();
1153                 boolean changed = false;
1154                 for (Type orig : to.toList()) {
1155                     Type s = rewriteSupers(orig);
1156                     if (s.isSuperBound() &amp;&amp; !s.isExtendsBound()) {
1157                         s = new WildcardType(syms.objectType,
1158                                              BoundKind.UNBOUND,
1159                                              syms.boundClass,
1160                                              s.getMetadata());
1161                         changed = true;
1162                     } else if (s != orig) {
1163                         s = new WildcardType(wildUpperBound(s),
1164                                              BoundKind.EXTENDS,
1165                                              syms.boundClass,
1166                                              s.getMetadata());
1167                         changed = true;
1168                     }
1169                     rewrite.append(s);
1170                 }
1171                 if (changed)
1172                     return subst(t.tsym.type, from.toList(), rewrite.toList());
1173                 else
1174                     return t;
1175             }
1176 
1177             @Override
1178             public Boolean visitClassType(ClassType t, Type s) {
1179                 Type sup = asSuper(t, s.tsym);
1180                 if (sup == null) return false;
1181                 // If t is an intersection, sup might not be a class type
1182                 if (!sup.hasTag(CLASS)) return isSubtypeNoCapture(sup, s);
1183                 return sup.tsym == s.tsym
1184                      // Check type variable containment
1185                     &amp;&amp; (!s.isParameterized() || containsTypeRecursive(s, sup))
1186                     &amp;&amp; isSubtypeNoCapture(sup.getEnclosingType(),
1187                                           s.getEnclosingType());
1188             }
1189 
1190             @Override
1191             public Boolean visitArrayType(ArrayType t, Type s) {
1192                 if (s.hasTag(ARRAY)) {
1193                     if (t.elemtype.isPrimitive())
1194                         return isSameType(t.elemtype, elemtype(s));
1195                     else
1196                         return isSubtypeNoCapture(t.elemtype, elemtype(s));
1197                 }
1198 
1199                 if (s.hasTag(CLASS)) {
1200                     Name sname = s.tsym.getQualifiedName();
1201                     return sname == names.java_lang_Object
1202                         || sname == names.java_lang_Cloneable
1203                         || sname == names.java_io_Serializable;
1204                 }
1205 
1206                 return false;
1207             }
1208 
1209             @Override
1210             public Boolean visitUndetVar(UndetVar t, Type s) {
1211                 //todo: test against origin needed? or replace with substitution?
1212                 if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {
1213                     return true;
1214                 } else if (s.hasTag(BOT)) {
1215                     //if &#39;s&#39; is &#39;null&#39; there&#39;s no instantiated type U for which
1216                     //U &lt;: s (but &#39;null&#39; itself, which is not a valid type)
1217                     return false;
1218                 }
1219 
1220                 t.addBound(InferenceBound.UPPER, s, Types.this);
1221                 return true;
1222             }
1223 
1224             @Override
1225             public Boolean visitErrorType(ErrorType t, Type s) {
1226                 return true;
1227             }
1228         };
1229 
1230     /**
1231      * Is t a subtype of every type in given list `ts&#39;?&lt;br&gt;
1232      * (not defined for Method and ForAll types)&lt;br&gt;
1233      * Allows unchecked conversions.
1234      */
1235     public boolean isSubtypeUnchecked(Type t, List&lt;Type&gt; ts, Warner warn) {
1236         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
1237             if (!isSubtypeUnchecked(t, l.head, warn))
1238                 return false;
1239         return true;
1240     }
1241 
1242     /**
1243      * Are corresponding elements of ts subtypes of ss?  If lists are
1244      * of different length, return false.
1245      */
1246     public boolean isSubtypes(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1247         while (ts.tail != null &amp;&amp; ss.tail != null
1248                /*inlined: ts.nonEmpty() &amp;&amp; ss.nonEmpty()*/ &amp;&amp;
1249                isSubtype(ts.head, ss.head)) {
1250             ts = ts.tail;
1251             ss = ss.tail;
1252         }
1253         return ts.tail == null &amp;&amp; ss.tail == null;
1254         /*inlined: ts.isEmpty() &amp;&amp; ss.isEmpty();*/
1255     }
1256 
1257     /**
1258      * Are corresponding elements of ts subtypes of ss, allowing
1259      * unchecked conversions?  If lists are of different length,
1260      * return false.
1261      **/
1262     public boolean isSubtypesUnchecked(List&lt;Type&gt; ts, List&lt;Type&gt; ss, Warner warn) {
1263         while (ts.tail != null &amp;&amp; ss.tail != null
1264                /*inlined: ts.nonEmpty() &amp;&amp; ss.nonEmpty()*/ &amp;&amp;
1265                isSubtypeUnchecked(ts.head, ss.head, warn)) {
1266             ts = ts.tail;
1267             ss = ss.tail;
1268         }
1269         return ts.tail == null &amp;&amp; ss.tail == null;
1270         /*inlined: ts.isEmpty() &amp;&amp; ss.isEmpty();*/
1271     }
1272     // &lt;/editor-fold&gt;
1273 
1274     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isSuperType&quot;&gt;
1275     /**
1276      * Is t a supertype of s?
1277      */
1278     public boolean isSuperType(Type t, Type s) {
1279         switch (t.getTag()) {
1280         case ERROR:
1281             return true;
1282         case UNDETVAR: {
1283             UndetVar undet = (UndetVar)t;
1284             if (t == s ||
1285                 undet.qtype == s ||
1286                 s.hasTag(ERROR) ||
1287                 s.hasTag(BOT)) {
1288                 return true;
1289             }
1290             undet.addBound(InferenceBound.LOWER, s, this);
1291             return true;
1292         }
1293         default:
1294             return isSubtype(s, t);
1295         }
1296     }
1297     // &lt;/editor-fold&gt;
1298 
1299     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isSameType&quot;&gt;
1300     /**
1301      * Are corresponding elements of the lists the same type?  If
1302      * lists are of different length, return false.
1303      */
1304     public boolean isSameTypes(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1305         while (ts.tail != null &amp;&amp; ss.tail != null
1306                /*inlined: ts.nonEmpty() &amp;&amp; ss.nonEmpty()*/ &amp;&amp;
1307                isSameType(ts.head, ss.head)) {
1308             ts = ts.tail;
1309             ss = ss.tail;
1310         }
1311         return ts.tail == null &amp;&amp; ss.tail == null;
1312         /*inlined: ts.isEmpty() &amp;&amp; ss.isEmpty();*/
1313     }
1314 
1315     /**
1316      * A polymorphic signature method (JLS 15.12.3) is a method that
1317      *   (i) is declared in the java.lang.invoke.MethodHandle/VarHandle classes;
1318      *  (ii) takes a single variable arity parameter;
1319      * (iii) whose declared type is Object[];
1320      *  (iv) has any return type, Object signifying a polymorphic return type; and
1321      *   (v) is native.
1322     */
1323    public boolean isSignaturePolymorphic(MethodSymbol msym) {
1324        List&lt;Type&gt; argtypes = msym.type.getParameterTypes();
1325        return (msym.flags_field &amp; NATIVE) != 0 &amp;&amp;
1326               (msym.owner == syms.methodHandleType.tsym || msym.owner == syms.varHandleType.tsym) &amp;&amp;
1327                argtypes.length() == 1 &amp;&amp;
1328                argtypes.head.hasTag(TypeTag.ARRAY) &amp;&amp;
1329                ((ArrayType)argtypes.head).elemtype.tsym == syms.objectType.tsym;
1330    }
1331 
1332     /**
1333      * Is t the same type as s?
1334      */
1335     public boolean isSameType(Type t, Type s) {
1336         return isSameTypeVisitor.visit(t, s);
1337     }
1338     // where
1339 
1340         /**
1341          * Type-equality relation - type variables are considered
1342          * equals if they share the same object identity.
1343          */
1344         TypeRelation isSameTypeVisitor = new TypeRelation() {
1345 
1346             public Boolean visitType(Type t, Type s) {
1347                 if (t.equalsIgnoreMetadata(s))
1348                     return true;
1349 
1350                 if (s.isPartial())
1351                     return visit(s, t);
1352 
1353                 switch (t.getTag()) {
1354                 case BYTE: case CHAR: case SHORT: case INT: case LONG: case FLOAT:
1355                 case DOUBLE: case BOOLEAN: case VOID: case BOT: case NONE:
1356                     return t.hasTag(s.getTag());
1357                 case TYPEVAR: {
1358                     if (s.hasTag(TYPEVAR)) {
1359                         //type-substitution does not preserve type-var types
1360                         //check that type var symbols and bounds are indeed the same
1361                         return t == s;
1362                     }
1363                     else {
1364                         //special case for s == ? super X, where upper(s) = u
1365                         //check that u == t, where u has been set by Type.withTypeVar
1366                         return s.isSuperBound() &amp;&amp;
1367                                 !s.isExtendsBound() &amp;&amp;
1368                                 visit(t, wildUpperBound(s));
1369                     }
1370                 }
1371                 default:
1372                     throw new AssertionError(&quot;isSameType &quot; + t.getTag());
1373                 }
1374             }
1375 
1376             @Override
1377             public Boolean visitWildcardType(WildcardType t, Type s) {
1378                 if (!s.hasTag(WILDCARD)) {
1379                     return false;
1380                 } else {
1381                     WildcardType t2 = (WildcardType)s;
1382                     return (t.kind == t2.kind || (t.isExtendsBound() &amp;&amp; s.isExtendsBound())) &amp;&amp;
1383                             isSameType(t.type, t2.type);
1384                 }
1385             }
1386 
1387             @Override
1388             public Boolean visitClassType(ClassType t, Type s) {
1389                 if (t == s)
1390                     return true;
1391 
1392                 if (s.isPartial())
1393                     return visit(s, t);
1394 
1395                 if (s.isSuperBound() &amp;&amp; !s.isExtendsBound())
1396                     return visit(t, wildUpperBound(s)) &amp;&amp; visit(t, wildLowerBound(s));
1397 
1398                 if (t.isCompound() &amp;&amp; s.isCompound()) {
1399                     if (!visit(supertype(t), supertype(s)))
1400                         return false;
1401 
1402                     Map&lt;Symbol,Type&gt; tMap = new HashMap&lt;&gt;();
1403                     for (Type ti : interfaces(t)) {
1404                         if (tMap.containsKey(ti)) {
1405                             throw new AssertionError(&quot;Malformed intersection&quot;);
1406                         }
1407                         tMap.put(ti.tsym, ti);
1408                     }
1409                     for (Type si : interfaces(s)) {
1410                         if (!tMap.containsKey(si.tsym))
1411                             return false;
1412                         Type ti = tMap.remove(si.tsym);
1413                         if (!visit(ti, si))
1414                             return false;
1415                     }
1416                     return tMap.isEmpty();
1417                 }
1418                 return t.tsym == s.tsym
1419                     &amp;&amp; visit(t.getEnclosingType(), s.getEnclosingType())
1420                     &amp;&amp; containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());
1421             }
1422 
1423             @Override
1424             public Boolean visitArrayType(ArrayType t, Type s) {
1425                 if (t == s)
1426                     return true;
1427 
1428                 if (s.isPartial())
1429                     return visit(s, t);
1430 
1431                 return s.hasTag(ARRAY)
1432                     &amp;&amp; containsTypeEquivalent(t.elemtype, elemtype(s));
1433             }
1434 
1435             @Override
1436             public Boolean visitMethodType(MethodType t, Type s) {
1437                 // isSameType for methods does not take thrown
1438                 // exceptions into account!
1439                 return hasSameArgs(t, s) &amp;&amp; visit(t.getReturnType(), s.getReturnType());
1440             }
1441 
1442             @Override
1443             public Boolean visitPackageType(PackageType t, Type s) {
1444                 return t == s;
1445             }
1446 
1447             @Override
1448             public Boolean visitForAll(ForAll t, Type s) {
1449                 if (!s.hasTag(FORALL)) {
1450                     return false;
1451                 }
1452 
1453                 ForAll forAll = (ForAll)s;
1454                 return hasSameBounds(t, forAll)
1455                     &amp;&amp; visit(t.qtype, subst(forAll.qtype, forAll.tvars, t.tvars));
1456             }
1457 
1458             @Override
1459             public Boolean visitUndetVar(UndetVar t, Type s) {
1460                 if (s.hasTag(WILDCARD)) {
1461                     // FIXME, this might be leftovers from before capture conversion
1462                     return false;
1463                 }
1464 
1465                 if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {
1466                     return true;
1467                 }
1468 
1469                 t.addBound(InferenceBound.EQ, s, Types.this);
1470 
1471                 return true;
1472             }
1473 
1474             @Override
1475             public Boolean visitErrorType(ErrorType t, Type s) {
1476                 return true;
1477             }
1478         };
1479 
1480     // &lt;/editor-fold&gt;
1481 
1482     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Contains Type&quot;&gt;
1483     public boolean containedBy(Type t, Type s) {
1484         switch (t.getTag()) {
1485         case UNDETVAR:
1486             if (s.hasTag(WILDCARD)) {
1487                 UndetVar undetvar = (UndetVar)t;
1488                 WildcardType wt = (WildcardType)s;
1489                 switch(wt.kind) {
1490                     case UNBOUND:
1491                         break;
1492                     case EXTENDS: {
1493                         Type bound = wildUpperBound(s);
1494                         undetvar.addBound(InferenceBound.UPPER, bound, this);
1495                         break;
1496                     }
1497                     case SUPER: {
1498                         Type bound = wildLowerBound(s);
1499                         undetvar.addBound(InferenceBound.LOWER, bound, this);
1500                         break;
1501                     }
1502                 }
1503                 return true;
1504             } else {
1505                 return isSameType(t, s);
1506             }
1507         case ERROR:
1508             return true;
1509         default:
1510             return containsType(s, t);
1511         }
1512     }
1513 
1514     boolean containsType(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1515         while (ts.nonEmpty() &amp;&amp; ss.nonEmpty()
1516                &amp;&amp; containsType(ts.head, ss.head)) {
1517             ts = ts.tail;
1518             ss = ss.tail;
1519         }
1520         return ts.isEmpty() &amp;&amp; ss.isEmpty();
1521     }
1522 
1523     /**
1524      * Check if t contains s.
1525      *
1526      * &lt;p&gt;T contains S if:
1527      *
1528      * &lt;p&gt;{@code L(T) &lt;: L(S) &amp;&amp; U(S) &lt;: U(T)}
1529      *
1530      * &lt;p&gt;This relation is only used by ClassType.isSubtype(), that
1531      * is,
1532      *
1533      * &lt;p&gt;{@code C&lt;S&gt; &lt;: C&lt;T&gt; if T contains S.}
1534      *
1535      * &lt;p&gt;Because of F-bounds, this relation can lead to infinite
1536      * recursion.  Thus we must somehow break that recursion.  Notice
1537      * that containsType() is only called from ClassType.isSubtype().
1538      * Since the arguments have already been checked against their
1539      * bounds, we know:
1540      *
1541      * &lt;p&gt;{@code U(S) &lt;: U(T) if T is &quot;super&quot; bound (U(T) *is* the bound)}
1542      *
1543      * &lt;p&gt;{@code L(T) &lt;: L(S) if T is &quot;extends&quot; bound (L(T) is bottom)}
1544      *
1545      * @param t a type
1546      * @param s a type
1547      */
1548     public boolean containsType(Type t, Type s) {
1549         return containsType.visit(t, s);
1550     }
1551     // where
1552         private TypeRelation containsType = new TypeRelation() {
1553 
1554             public Boolean visitType(Type t, Type s) {
1555                 if (s.isPartial())
1556                     return containedBy(s, t);
1557                 else
1558                     return isSameType(t, s);
1559             }
1560 
1561 //            void debugContainsType(WildcardType t, Type s) {
1562 //                System.err.println();
1563 //                System.err.format(&quot; does %s contain %s?%n&quot;, t, s);
1564 //                System.err.format(&quot; %s U(%s) &lt;: U(%s) %s = %s%n&quot;,
1565 //                                  wildUpperBound(s), s, t, wildUpperBound(t),
1566 //                                  t.isSuperBound()
1567 //                                  || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t)));
1568 //                System.err.format(&quot; %s L(%s) &lt;: L(%s) %s = %s%n&quot;,
1569 //                                  wildLowerBound(t), t, s, wildLowerBound(s),
1570 //                                  t.isExtendsBound()
1571 //                                  || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s)));
1572 //                System.err.println();
1573 //            }
1574 
1575             @Override
1576             public Boolean visitWildcardType(WildcardType t, Type s) {
1577                 if (s.isPartial())
1578                     return containedBy(s, t);
1579                 else {
1580 //                    debugContainsType(t, s);
1581                     return isSameWildcard(t, s)
1582                         || isCaptureOf(s, t)
1583                         || ((t.isExtendsBound() || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s))) &amp;&amp;
1584                             (t.isSuperBound() || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t))));
1585                 }
1586             }
1587 
1588             @Override
1589             public Boolean visitUndetVar(UndetVar t, Type s) {
1590                 if (!s.hasTag(WILDCARD)) {
1591                     return isSameType(t, s);
1592                 } else {
1593                     return false;
1594                 }
1595             }
1596 
1597             @Override
1598             public Boolean visitErrorType(ErrorType t, Type s) {
1599                 return true;
1600             }
1601         };
1602 
1603     public boolean isCaptureOf(Type s, WildcardType t) {
1604         if (!s.hasTag(TYPEVAR) || !((TypeVar)s).isCaptured())
1605             return false;
1606         return isSameWildcard(t, ((CapturedType)s).wildcard);
1607     }
1608 
1609     public boolean isSameWildcard(WildcardType t, Type s) {
1610         if (!s.hasTag(WILDCARD))
1611             return false;
1612         WildcardType w = (WildcardType)s;
1613         return w.kind == t.kind &amp;&amp; w.type == t.type;
1614     }
1615 
1616     public boolean containsTypeEquivalent(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1617         while (ts.nonEmpty() &amp;&amp; ss.nonEmpty()
1618                &amp;&amp; containsTypeEquivalent(ts.head, ss.head)) {
1619             ts = ts.tail;
1620             ss = ss.tail;
1621         }
1622         return ts.isEmpty() &amp;&amp; ss.isEmpty();
1623     }
1624     // &lt;/editor-fold&gt;
1625 
1626     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isCastable&quot;&gt;
1627     public boolean isCastable(Type t, Type s) {
1628         return isCastable(t, s, noWarnings);
1629     }
1630 
1631     /**
1632      * Is t is castable to s?&lt;br&gt;
1633      * s is assumed to be an erased type.&lt;br&gt;
1634      * (not defined for Method and ForAll types).
1635      */
1636     public boolean isCastable(Type t, Type s, Warner warn) {
1637         if (t == s)
1638             return true;
1639         if (t.isPrimitive() != s.isPrimitive()) {
1640             t = skipTypeVars(t, false);
1641             return (isConvertible(t, s, warn)
1642                     || (s.isPrimitive() &amp;&amp;
1643                         isSubtype(boxedClass(s).type, t)));
1644         }
1645         if (warn != warnStack.head) {
1646             try {
1647                 warnStack = warnStack.prepend(warn);
1648                 checkUnsafeVarargsConversion(t, s, warn);
1649                 return isCastable.visit(t,s);
1650             } finally {
1651                 warnStack = warnStack.tail;
1652             }
1653         } else {
1654             return isCastable.visit(t,s);
1655         }
1656     }
1657     // where
1658         private TypeRelation isCastable = new TypeRelation() {
1659 
1660             public Boolean visitType(Type t, Type s) {
1661                 if (s.hasTag(ERROR) || t.hasTag(NONE))
1662                     return true;
1663 
1664                 switch (t.getTag()) {
1665                 case BYTE: case CHAR: case SHORT: case INT: case LONG: case FLOAT:
1666                 case DOUBLE:
1667                     return s.isNumeric();
1668                 case BOOLEAN:
1669                     return s.hasTag(BOOLEAN);
1670                 case VOID:
1671                     return false;
1672                 case BOT:
1673                     return isSubtype(t, s);
1674                 default:
1675                     throw new AssertionError();
1676                 }
1677             }
1678 
1679             @Override
1680             public Boolean visitWildcardType(WildcardType t, Type s) {
1681                 return isCastable(wildUpperBound(t), s, warnStack.head);
1682             }
1683 
1684             @Override
1685             public Boolean visitClassType(ClassType t, Type s) {
1686                 if (s.hasTag(ERROR) || s.hasTag(BOT))
1687                     return true;
1688 
1689                 if (s.hasTag(TYPEVAR)) {
1690                     if (isCastable(t, s.getUpperBound(), noWarnings)) {
1691                         warnStack.head.warn(LintCategory.UNCHECKED);
1692                         return true;
1693                     } else {
1694                         return false;
1695                     }
1696                 }
1697 
1698                 if (t.isCompound() || s.isCompound()) {
1699                     return !t.isCompound() ?
1700                             visitCompoundType((ClassType)s, t, true) :
1701                             visitCompoundType(t, s, false);
1702                 }
1703 
1704                 if (s.hasTag(CLASS) || s.hasTag(ARRAY)) {
1705                     boolean upcast;
1706                     if ((upcast = isSubtype(erasure(t), erasure(s)))
1707                         || isSubtype(erasure(s), erasure(t))) {
1708                         if (!upcast &amp;&amp; s.hasTag(ARRAY)) {
1709                             if (!isReifiable(s))
1710                                 warnStack.head.warn(LintCategory.UNCHECKED);
1711                             return true;
1712                         } else if (s.isRaw()) {
1713                             return true;
1714                         } else if (t.isRaw()) {
1715                             if (!isUnbounded(s))
1716                                 warnStack.head.warn(LintCategory.UNCHECKED);
1717                             return true;
1718                         }
1719                         // Assume |a| &lt;: |b|
1720                         final Type a = upcast ? t : s;
1721                         final Type b = upcast ? s : t;
1722                         final boolean HIGH = true;
1723                         final boolean LOW = false;
1724                         final boolean DONT_REWRITE_TYPEVARS = false;
1725                         Type aHigh = rewriteQuantifiers(a, HIGH, DONT_REWRITE_TYPEVARS);
1726                         Type aLow  = rewriteQuantifiers(a, LOW,  DONT_REWRITE_TYPEVARS);
1727                         Type bHigh = rewriteQuantifiers(b, HIGH, DONT_REWRITE_TYPEVARS);
1728                         Type bLow  = rewriteQuantifiers(b, LOW,  DONT_REWRITE_TYPEVARS);
1729                         Type lowSub = asSub(bLow, aLow.tsym);
1730                         Type highSub = (lowSub == null) ? null : asSub(bHigh, aHigh.tsym);
1731                         if (highSub == null) {
1732                             final boolean REWRITE_TYPEVARS = true;
1733                             aHigh = rewriteQuantifiers(a, HIGH, REWRITE_TYPEVARS);
1734                             aLow  = rewriteQuantifiers(a, LOW,  REWRITE_TYPEVARS);
1735                             bHigh = rewriteQuantifiers(b, HIGH, REWRITE_TYPEVARS);
1736                             bLow  = rewriteQuantifiers(b, LOW,  REWRITE_TYPEVARS);
1737                             lowSub = asSub(bLow, aLow.tsym);
1738                             highSub = (lowSub == null) ? null : asSub(bHigh, aHigh.tsym);
1739                         }
1740                         if (highSub != null) {
1741                             if (!(a.tsym == highSub.tsym &amp;&amp; a.tsym == lowSub.tsym)) {
1742                                 Assert.error(a.tsym + &quot; != &quot; + highSub.tsym + &quot; != &quot; + lowSub.tsym);
1743                             }
1744                             if (!disjointTypes(aHigh.allparams(), highSub.allparams())
1745                                 &amp;&amp; !disjointTypes(aHigh.allparams(), lowSub.allparams())
1746                                 &amp;&amp; !disjointTypes(aLow.allparams(), highSub.allparams())
1747                                 &amp;&amp; !disjointTypes(aLow.allparams(), lowSub.allparams())) {
1748                                 if (upcast ? giveWarning(a, b) :
1749                                     giveWarning(b, a))
1750                                     warnStack.head.warn(LintCategory.UNCHECKED);
1751                                 return true;
1752                             }
1753                         }
1754                         if (isReifiable(s))
1755                             return isSubtypeUnchecked(a, b);
1756                         else
1757                             return isSubtypeUnchecked(a, b, warnStack.head);
1758                     }
1759 
1760                     // Sidecast
1761                     if (s.hasTag(CLASS)) {
1762                         if ((s.tsym.flags() &amp; INTERFACE) != 0) {
1763                             return ((t.tsym.flags() &amp; FINAL) == 0)
1764                                 ? sideCast(t, s, warnStack.head)
1765                                 : sideCastFinal(t, s, warnStack.head);
1766                         } else if ((t.tsym.flags() &amp; INTERFACE) != 0) {
1767                             return ((s.tsym.flags() &amp; FINAL) == 0)
1768                                 ? sideCast(t, s, warnStack.head)
1769                                 : sideCastFinal(t, s, warnStack.head);
1770                         } else {
1771                             // unrelated class types
1772                             return false;
1773                         }
1774                     }
1775                 }
1776                 return false;
1777             }
1778 
1779             boolean visitCompoundType(ClassType ct, Type s, boolean reverse) {
1780                 Warner warn = noWarnings;
1781                 for (Type c : directSupertypes(ct)) {
1782                     warn.clear();
1783                     if (reverse ? !isCastable(s, c, warn) : !isCastable(c, s, warn))
1784                         return false;
1785                 }
1786                 if (warn.hasLint(LintCategory.UNCHECKED))
1787                     warnStack.head.warn(LintCategory.UNCHECKED);
1788                 return true;
1789             }
1790 
1791             @Override
1792             public Boolean visitArrayType(ArrayType t, Type s) {
1793                 switch (s.getTag()) {
1794                 case ERROR:
1795                 case BOT:
1796                     return true;
1797                 case TYPEVAR:
1798                     if (isCastable(s, t, noWarnings)) {
1799                         warnStack.head.warn(LintCategory.UNCHECKED);
1800                         return true;
1801                     } else {
1802                         return false;
1803                     }
1804                 case CLASS:
1805                     return isSubtype(t, s);
1806                 case ARRAY:
1807                     if (elemtype(t).isPrimitive() || elemtype(s).isPrimitive()) {
1808                         return elemtype(t).hasTag(elemtype(s).getTag());
1809                     } else {
1810                         return visit(elemtype(t), elemtype(s));
1811                     }
1812                 default:
1813                     return false;
1814                 }
1815             }
1816 
1817             @Override
1818             public Boolean visitTypeVar(TypeVar t, Type s) {
1819                 switch (s.getTag()) {
1820                 case ERROR:
1821                 case BOT:
1822                     return true;
1823                 case TYPEVAR:
1824                     if (isSubtype(t, s)) {
1825                         return true;
1826                     } else if (isCastable(t.getUpperBound(), s, noWarnings)) {
1827                         warnStack.head.warn(LintCategory.UNCHECKED);
1828                         return true;
1829                     } else {
1830                         return false;
1831                     }
1832                 default:
1833                     return isCastable(t.getUpperBound(), s, warnStack.head);
1834                 }
1835             }
1836 
1837             @Override
1838             public Boolean visitErrorType(ErrorType t, Type s) {
1839                 return true;
1840             }
1841         };
1842     // &lt;/editor-fold&gt;
1843 
1844     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;disjointTypes&quot;&gt;
1845     public boolean disjointTypes(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1846         while (ts.tail != null &amp;&amp; ss.tail != null) {
1847             if (disjointType(ts.head, ss.head)) return true;
1848             ts = ts.tail;
1849             ss = ss.tail;
1850         }
1851         return false;
1852     }
1853 
1854     /**
1855      * Two types or wildcards are considered disjoint if it can be
1856      * proven that no type can be contained in both. It is
1857      * conservative in that it is allowed to say that two types are
1858      * not disjoint, even though they actually are.
1859      *
1860      * The type {@code C&lt;X&gt;} is castable to {@code C&lt;Y&gt;} exactly if
1861      * {@code X} and {@code Y} are not disjoint.
1862      */
1863     public boolean disjointType(Type t, Type s) {
1864         return disjointType.visit(t, s);
1865     }
1866     // where
1867         private TypeRelation disjointType = new TypeRelation() {
1868 
1869             private Set&lt;TypePair&gt; cache = new HashSet&lt;&gt;();
1870 
1871             @Override
1872             public Boolean visitType(Type t, Type s) {
1873                 if (s.hasTag(WILDCARD))
1874                     return visit(s, t);
1875                 else
1876                     return notSoftSubtypeRecursive(t, s) || notSoftSubtypeRecursive(s, t);
1877             }
1878 
1879             private boolean isCastableRecursive(Type t, Type s) {
1880                 TypePair pair = new TypePair(t, s);
1881                 if (cache.add(pair)) {
1882                     try {
1883                         return Types.this.isCastable(t, s);
1884                     } finally {
1885                         cache.remove(pair);
1886                     }
1887                 } else {
1888                     return true;
1889                 }
1890             }
1891 
1892             private boolean notSoftSubtypeRecursive(Type t, Type s) {
1893                 TypePair pair = new TypePair(t, s);
1894                 if (cache.add(pair)) {
1895                     try {
1896                         return Types.this.notSoftSubtype(t, s);
1897                     } finally {
1898                         cache.remove(pair);
1899                     }
1900                 } else {
1901                     return false;
1902                 }
1903             }
1904 
1905             @Override
1906             public Boolean visitWildcardType(WildcardType t, Type s) {
1907                 if (t.isUnbound())
1908                     return false;
1909 
1910                 if (!s.hasTag(WILDCARD)) {
1911                     if (t.isExtendsBound())
1912                         return notSoftSubtypeRecursive(s, t.type);
1913                     else
1914                         return notSoftSubtypeRecursive(t.type, s);
1915                 }
1916 
1917                 if (s.isUnbound())
1918                     return false;
1919 
1920                 if (t.isExtendsBound()) {
1921                     if (s.isExtendsBound())
1922                         return !isCastableRecursive(t.type, wildUpperBound(s));
1923                     else if (s.isSuperBound())
1924                         return notSoftSubtypeRecursive(wildLowerBound(s), t.type);
1925                 } else if (t.isSuperBound()) {
1926                     if (s.isExtendsBound())
1927                         return notSoftSubtypeRecursive(t.type, wildUpperBound(s));
1928                 }
1929                 return false;
1930             }
1931         };
1932     // &lt;/editor-fold&gt;
1933 
1934     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;cvarLowerBounds&quot;&gt;
1935     public List&lt;Type&gt; cvarLowerBounds(List&lt;Type&gt; ts) {
1936         return ts.map(cvarLowerBoundMapping);
1937     }
1938         private final TypeMapping&lt;Void&gt; cvarLowerBoundMapping = new TypeMapping&lt;Void&gt;() {
1939             @Override
1940             public Type visitCapturedType(CapturedType t, Void _unused) {
1941                 return cvarLowerBound(t);
1942             }
1943         };
1944     // &lt;/editor-fold&gt;
1945 
1946     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;notSoftSubtype&quot;&gt;
1947     /**
1948      * This relation answers the question: is impossible that
1949      * something of type `t&#39; can be a subtype of `s&#39;? This is
1950      * different from the question &quot;is `t&#39; not a subtype of `s&#39;?&quot;
1951      * when type variables are involved: Integer is not a subtype of T
1952      * where {@code &lt;T extends Number&gt;} but it is not true that Integer cannot
1953      * possibly be a subtype of T.
1954      */
1955     public boolean notSoftSubtype(Type t, Type s) {
1956         if (t == s) return false;
1957         if (t.hasTag(TYPEVAR)) {
1958             TypeVar tv = (TypeVar) t;
1959             return !isCastable(tv.getUpperBound(),
1960                                relaxBound(s),
1961                                noWarnings);
1962         }
1963         if (!s.hasTag(WILDCARD))
1964             s = cvarUpperBound(s);
1965 
1966         return !isSubtype(t, relaxBound(s));
1967     }
1968 
1969     private Type relaxBound(Type t) {
1970         return (t.hasTag(TYPEVAR)) ?
1971                 rewriteQuantifiers(skipTypeVars(t, false), true, true) :
1972                 t;
1973     }
1974     // &lt;/editor-fold&gt;
1975 
1976     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isReifiable&quot;&gt;
1977     public boolean isReifiable(Type t) {
1978         return isReifiable.visit(t);
1979     }
1980     // where
1981         private UnaryVisitor&lt;Boolean&gt; isReifiable = new UnaryVisitor&lt;Boolean&gt;() {
1982 
1983             public Boolean visitType(Type t, Void ignored) {
1984                 return true;
1985             }
1986 
1987             @Override
1988             public Boolean visitClassType(ClassType t, Void ignored) {
1989                 if (t.isCompound())
1990                     return false;
1991                 else {
1992                     if (!t.isParameterized())
1993                         return true;
1994 
1995                     for (Type param : t.allparams()) {
1996                         if (!param.isUnbound())
1997                             return false;
1998                     }
1999                     return true;
2000                 }
2001             }
2002 
2003             @Override
2004             public Boolean visitArrayType(ArrayType t, Void ignored) {
2005                 return visit(t.elemtype);
2006             }
2007 
2008             @Override
2009             public Boolean visitTypeVar(TypeVar t, Void ignored) {
2010                 return false;
2011             }
2012         };
2013     // &lt;/editor-fold&gt;
2014 
2015     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Array Utils&quot;&gt;
2016     public boolean isArray(Type t) {
2017         while (t.hasTag(WILDCARD))
2018             t = wildUpperBound(t);
2019         return t.hasTag(ARRAY);
2020     }
2021 
2022     /**
2023      * The element type of an array.
2024      */
2025     public Type elemtype(Type t) {
2026         switch (t.getTag()) {
2027         case WILDCARD:
2028             return elemtype(wildUpperBound(t));
2029         case ARRAY:
2030             return ((ArrayType)t).elemtype;
2031         case FORALL:
2032             return elemtype(((ForAll)t).qtype);
2033         case ERROR:
2034             return t;
2035         default:
2036             return null;
2037         }
2038     }
2039 
2040     public Type elemtypeOrType(Type t) {
2041         Type elemtype = elemtype(t);
2042         return elemtype != null ?
2043             elemtype :
2044             t;
2045     }
2046 
2047     /**
2048      * Mapping to take element type of an arraytype
2049      */
2050     private TypeMapping&lt;Void&gt; elemTypeFun = new TypeMapping&lt;Void&gt;() {
2051         @Override
2052         public Type visitArrayType(ArrayType t, Void _unused) {
2053             return t.elemtype;
2054         }
2055 
2056         @Override
2057         public Type visitTypeVar(TypeVar t, Void _unused) {
2058             return visit(skipTypeVars(t, false));
2059         }
2060     };
2061 
2062     /**
2063      * The number of dimensions of an array type.
2064      */
2065     public int dimensions(Type t) {
2066         int result = 0;
2067         while (t.hasTag(ARRAY)) {
2068             result++;
2069             t = elemtype(t);
2070         }
2071         return result;
2072     }
2073 
2074     /**
2075      * Returns an ArrayType with the component type t
2076      *
2077      * @param t The component type of the ArrayType
2078      * @return the ArrayType for the given component
2079      */
2080     public ArrayType makeArrayType(Type t) {
2081         if (t.hasTag(VOID) || t.hasTag(PACKAGE)) {
2082             Assert.error(&quot;Type t must not be a VOID or PACKAGE type, &quot; + t.toString());
2083         }
2084         return new ArrayType(t, syms.arrayClass);
2085     }
2086     // &lt;/editor-fold&gt;
2087 
2088     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;asSuper&quot;&gt;
2089     /**
2090      * Return the (most specific) base type of t that starts with the
2091      * given symbol.  If none exists, return null.
2092      *
2093      * Caveat Emptor: Since javac represents the class of all arrays with a singleton
2094      * symbol Symtab.arrayClass, which by being a singleton cannot hold any discriminant,
2095      * this method could yield surprising answers when invoked on arrays. For example when
2096      * invoked with t being byte [] and sym being t.sym itself, asSuper would answer null.
2097      *
2098      * @param t a type
2099      * @param sym a symbol
2100      */
2101     public Type asSuper(Type t, Symbol sym) {
2102         /* Some examples:
2103          *
2104          * (Enum&lt;E&gt;, Comparable) =&gt; Comparable&lt;E&gt;
2105          * (c.s.s.d.AttributeTree.ValueKind, Enum) =&gt; Enum&lt;c.s.s.d.AttributeTree.ValueKind&gt;
2106          * (c.s.s.t.ExpressionTree, c.s.s.t.Tree) =&gt; c.s.s.t.Tree
2107          * (j.u.List&lt;capture#160 of ? extends c.s.s.d.DocTree&gt;, Iterable) =&gt;
2108          *     Iterable&lt;capture#160 of ? extends c.s.s.d.DocTree&gt;
2109          */
2110         if (sym.type == syms.objectType) { //optimization
2111             return syms.objectType;
2112         }
2113         return asSuper.visit(t, sym);
2114     }
2115     // where
2116         private SimpleVisitor&lt;Type,Symbol&gt; asSuper = new SimpleVisitor&lt;Type,Symbol&gt;() {
2117 
2118             public Type visitType(Type t, Symbol sym) {
2119                 return null;
2120             }
2121 
2122             @Override
2123             public Type visitClassType(ClassType t, Symbol sym) {
2124                 if (t.tsym == sym)
2125                     return t;
2126 
2127                 Symbol c = t.tsym;
2128                 if ((c.flags_field &amp; LOCKED) != 0) {
2129                     return null;
2130                 }
2131                 try {
2132                     c.flags_field |= LOCKED;
2133                     Type st = supertype(t);
2134                     if (st.hasTag(CLASS) || st.hasTag(TYPEVAR)) {
2135                         Type x = asSuper(st, sym);
2136                         if (x != null)
2137                             return x;
2138                     }
2139                     if ((sym.flags() &amp; INTERFACE) != 0) {
2140                         for (List&lt;Type&gt; l = interfaces(t); l.nonEmpty(); l = l.tail) {
2141                             if (!l.head.hasTag(ERROR)) {
2142                                 Type x = asSuper(l.head, sym);
2143                                 if (x != null)
2144                                     return x;
2145                             }
2146                         }
2147                     }
2148                     return null;
2149                 } finally {
2150                     c.flags_field &amp;= ~LOCKED;
2151                 }
2152             }
2153 
2154             @Override
2155             public Type visitArrayType(ArrayType t, Symbol sym) {
2156                 return isSubtype(t, sym.type) ? sym.type : null;
2157             }
2158 
2159             @Override
2160             public Type visitTypeVar(TypeVar t, Symbol sym) {
2161                 if (t.tsym == sym)
2162                     return t;
2163                 else
2164                     return asSuper(t.getUpperBound(), sym);
2165             }
2166 
2167             @Override
2168             public Type visitErrorType(ErrorType t, Symbol sym) {
2169                 return t;
2170             }
2171         };
2172 
2173     /**
2174      * Return the base type of t or any of its outer types that starts
2175      * with the given symbol.  If none exists, return null.
2176      *
2177      * @param t a type
2178      * @param sym a symbol
2179      */
2180     public Type asOuterSuper(Type t, Symbol sym) {
2181         switch (t.getTag()) {
2182         case CLASS:
2183             do {
2184                 Type s = asSuper(t, sym);
2185                 if (s != null) return s;
2186                 t = t.getEnclosingType();
2187             } while (t.hasTag(CLASS));
2188             return null;
2189         case ARRAY:
2190             return isSubtype(t, sym.type) ? sym.type : null;
2191         case TYPEVAR:
2192             return asSuper(t, sym);
2193         case ERROR:
2194             return t;
2195         default:
2196             return null;
2197         }
2198     }
2199 
2200     /**
2201      * Return the base type of t or any of its enclosing types that
2202      * starts with the given symbol.  If none exists, return null.
2203      *
2204      * @param t a type
2205      * @param sym a symbol
2206      */
2207     public Type asEnclosingSuper(Type t, Symbol sym) {
2208         switch (t.getTag()) {
2209         case CLASS:
2210             do {
2211                 Type s = asSuper(t, sym);
2212                 if (s != null) return s;
2213                 Type outer = t.getEnclosingType();
2214                 t = (outer.hasTag(CLASS)) ? outer :
2215                     (t.tsym.owner.enclClass() != null) ? t.tsym.owner.enclClass().type :
2216                     Type.noType;
2217             } while (t.hasTag(CLASS));
2218             return null;
2219         case ARRAY:
2220             return isSubtype(t, sym.type) ? sym.type : null;
2221         case TYPEVAR:
2222             return asSuper(t, sym);
2223         case ERROR:
2224             return t;
2225         default:
2226             return null;
2227         }
2228     }
2229     // &lt;/editor-fold&gt;
2230 
2231     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;memberType&quot;&gt;
2232     /**
2233      * The type of given symbol, seen as a member of t.
2234      *
2235      * @param t a type
2236      * @param sym a symbol
2237      */
2238     public Type memberType(Type t, Symbol sym) {
2239         return (sym.flags() &amp; STATIC) != 0
2240             ? sym.type
2241             : memberType.visit(t, sym);
2242         }
2243     // where
2244         private SimpleVisitor&lt;Type,Symbol&gt; memberType = new SimpleVisitor&lt;Type,Symbol&gt;() {
2245 
2246             public Type visitType(Type t, Symbol sym) {
2247                 return sym.type;
2248             }
2249 
2250             @Override
2251             public Type visitWildcardType(WildcardType t, Symbol sym) {
2252                 return memberType(wildUpperBound(t), sym);
2253             }
2254 
2255             @Override
2256             public Type visitClassType(ClassType t, Symbol sym) {
2257                 Symbol owner = sym.owner;
2258                 long flags = sym.flags();
2259                 if (((flags &amp; STATIC) == 0) &amp;&amp; owner.type.isParameterized()) {
2260                     Type base = asOuterSuper(t, owner);
2261                     //if t is an intersection type T = CT &amp; I1 &amp; I2 ... &amp; In
2262                     //its supertypes CT, I1, ... In might contain wildcards
2263                     //so we need to go through capture conversion
2264                     base = t.isCompound() ? capture(base) : base;
2265                     if (base != null) {
2266                         List&lt;Type&gt; ownerParams = owner.type.allparams();
2267                         List&lt;Type&gt; baseParams = base.allparams();
2268                         if (ownerParams.nonEmpty()) {
2269                             if (baseParams.isEmpty()) {
2270                                 // then base is a raw type
2271                                 return erasure(sym.type);
2272                             } else {
2273                                 return subst(sym.type, ownerParams, baseParams);
2274                             }
2275                         }
2276                     }
2277                 }
2278                 return sym.type;
2279             }
2280 
2281             @Override
2282             public Type visitTypeVar(TypeVar t, Symbol sym) {
2283                 return memberType(t.getUpperBound(), sym);
2284             }
2285 
2286             @Override
2287             public Type visitErrorType(ErrorType t, Symbol sym) {
2288                 return t;
2289             }
2290         };
2291     // &lt;/editor-fold&gt;
2292 
2293     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isAssignable&quot;&gt;
2294     public boolean isAssignable(Type t, Type s) {
2295         return isAssignable(t, s, noWarnings);
2296     }
2297 
2298     /**
2299      * Is t assignable to s?&lt;br&gt;
2300      * Equivalent to subtype except for constant values and raw
2301      * types.&lt;br&gt;
2302      * (not defined for Method and ForAll types)
2303      */
2304     public boolean isAssignable(Type t, Type s, Warner warn) {
2305         if (t.hasTag(ERROR))
2306             return true;
2307         if (t.getTag().isSubRangeOf(INT) &amp;&amp; t.constValue() != null) {
2308             int value = ((Number)t.constValue()).intValue();
2309             switch (s.getTag()) {
2310             case BYTE:
2311             case CHAR:
2312             case SHORT:
2313             case INT:
2314                 if (s.getTag().checkRange(value))
2315                     return true;
2316                 break;
2317             case CLASS:
2318                 switch (unboxedType(s).getTag()) {
2319                 case BYTE:
2320                 case CHAR:
2321                 case SHORT:
2322                     return isAssignable(t, unboxedType(s), warn);
2323                 }
2324                 break;
2325             }
2326         }
2327         return isConvertible(t, s, warn);
2328     }
2329     // &lt;/editor-fold&gt;
2330 
2331     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;erasure&quot;&gt;
2332     /**
2333      * The erasure of t {@code |t|} -- the type that results when all
2334      * type parameters in t are deleted.
2335      */
2336     public Type erasure(Type t) {
2337         return eraseNotNeeded(t) ? t : erasure(t, false);
2338     }
2339     //where
2340     private boolean eraseNotNeeded(Type t) {
2341         // We don&#39;t want to erase primitive types and String type as that
2342         // operation is idempotent. Also, erasing these could result in loss
2343         // of information such as constant values attached to such types.
2344         return (t.isPrimitive()) || (syms.stringType.tsym == t.tsym);
2345     }
2346 
2347     private Type erasure(Type t, boolean recurse) {
2348         if (t.isPrimitive()) {
2349             return t; /* fast special case */
2350         } else {
2351             Type out = erasure.visit(t, recurse);
2352             return out;
2353         }
2354     }
2355     // where
2356         private TypeMapping&lt;Boolean&gt; erasure = new StructuralTypeMapping&lt;Boolean&gt;() {
2357             private Type combineMetadata(final Type s,
2358                                          final Type t) {
2359                 if (t.getMetadata() != TypeMetadata.EMPTY) {
2360                     switch (s.getKind()) {
2361                         case OTHER:
2362                         case UNION:
2363                         case INTERSECTION:
2364                         case PACKAGE:
2365                         case EXECUTABLE:
2366                         case NONE:
2367                         case VOID:
2368                         case ERROR:
2369                             return s;
2370                         default: return s.cloneWithMetadata(s.getMetadata().without(Kind.ANNOTATIONS));
2371                     }
2372                 } else {
2373                     return s;
2374                 }
2375             }
2376 
2377             public Type visitType(Type t, Boolean recurse) {
2378                 if (t.isPrimitive())
2379                     return t; /*fast special case*/
2380                 else {
2381                     //other cases already handled
2382                     return combineMetadata(t, t);
2383                 }
2384             }
2385 
2386             @Override
2387             public Type visitWildcardType(WildcardType t, Boolean recurse) {
2388                 Type erased = erasure(wildUpperBound(t), recurse);
2389                 return combineMetadata(erased, t);
2390             }
2391 
2392             @Override
2393             public Type visitClassType(ClassType t, Boolean recurse) {
2394                 Type erased = t.tsym.erasure(Types.this);
2395                 if (recurse) {
2396                     erased = new ErasedClassType(erased.getEnclosingType(),erased.tsym,
2397                             t.getMetadata().without(Kind.ANNOTATIONS));
2398                     return erased;
2399                 } else {
2400                     return combineMetadata(erased, t);
2401                 }
2402             }
2403 
2404             @Override
2405             public Type visitTypeVar(TypeVar t, Boolean recurse) {
2406                 Type erased = erasure(t.getUpperBound(), recurse);
2407                 return combineMetadata(erased, t);
2408             }
2409         };
2410 
2411     public List&lt;Type&gt; erasure(List&lt;Type&gt; ts) {
2412         return erasure.visit(ts, false);
2413     }
2414 
2415     public Type erasureRecursive(Type t) {
2416         return erasure(t, true);
2417     }
2418 
2419     public List&lt;Type&gt; erasureRecursive(List&lt;Type&gt; ts) {
2420         return erasure.visit(ts, true);
2421     }
2422     // &lt;/editor-fold&gt;
2423 
2424     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;makeIntersectionType&quot;&gt;
2425     /**
2426      * Make an intersection type from non-empty list of types.  The list should be ordered according to
2427      * {@link TypeSymbol#precedes(TypeSymbol, Types)}. Note that this might cause a symbol completion.
2428      * Hence, this version of makeIntersectionType may not be called during a classfile read.
2429      *
2430      * @param bounds    the types from which the intersection type is formed
2431      */
2432     public IntersectionClassType makeIntersectionType(List&lt;Type&gt; bounds) {
2433         return makeIntersectionType(bounds, bounds.head.tsym.isInterface());
2434     }
2435 
2436     /**
2437      * Make an intersection type from non-empty list of types.  The list should be ordered according to
2438      * {@link TypeSymbol#precedes(TypeSymbol, Types)}. This does not cause symbol completion as
2439      * an extra parameter indicates as to whether all bounds are interfaces - in which case the
2440      * supertype is implicitly assumed to be &#39;Object&#39;.
2441      *
2442      * @param bounds        the types from which the intersection type is formed
2443      * @param allInterfaces are all bounds interface types?
2444      */
2445     public IntersectionClassType makeIntersectionType(List&lt;Type&gt; bounds, boolean allInterfaces) {
2446         Assert.check(bounds.nonEmpty());
2447         Type firstExplicitBound = bounds.head;
2448         if (allInterfaces) {
2449             bounds = bounds.prepend(syms.objectType);
2450         }
2451         ClassSymbol bc =
2452             new ClassSymbol(ABSTRACT|PUBLIC|SYNTHETIC|COMPOUND|ACYCLIC,
2453                             Type.moreInfo
2454                                 ? names.fromString(bounds.toString())
2455                                 : names.empty,
2456                             null,
2457                             syms.noSymbol);
2458         IntersectionClassType intersectionType = new IntersectionClassType(bounds, bc, allInterfaces);
2459         bc.type = intersectionType;
2460         bc.erasure_field = (bounds.head.hasTag(TYPEVAR)) ?
2461                 syms.objectType : // error condition, recover
2462                 erasure(firstExplicitBound);
2463         bc.members_field = WriteableScope.create(bc);
2464         return intersectionType;
2465     }
2466     // &lt;/editor-fold&gt;
2467 
2468     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;supertype&quot;&gt;
2469     public Type supertype(Type t) {
2470         return supertype.visit(t);
2471     }
2472     // where
2473         private UnaryVisitor&lt;Type&gt; supertype = new UnaryVisitor&lt;Type&gt;() {
2474 
2475             public Type visitType(Type t, Void ignored) {
2476                 // A note on wildcards: there is no good way to
2477                 // determine a supertype for a super bounded wildcard.
2478                 return Type.noType;
2479             }
2480 
2481             @Override
2482             public Type visitClassType(ClassType t, Void ignored) {
2483                 if (t.supertype_field == null) {
2484                     Type supertype = ((ClassSymbol)t.tsym).getSuperclass();
2485                     // An interface has no superclass; its supertype is Object.
2486                     if (t.isInterface())
2487                         supertype = ((ClassType)t.tsym.type).supertype_field;
2488                     if (t.supertype_field == null) {
2489                         List&lt;Type&gt; actuals = classBound(t).allparams();
2490                         List&lt;Type&gt; formals = t.tsym.type.allparams();
2491                         if (t.hasErasedSupertypes()) {
2492                             t.supertype_field = erasureRecursive(supertype);
2493                         } else if (formals.nonEmpty()) {
2494                             t.supertype_field = subst(supertype, formals, actuals);
2495                         }
2496                         else {
2497                             t.supertype_field = supertype;
2498                         }
2499                     }
2500                 }
2501                 return t.supertype_field;
2502             }
2503 
2504             /**
2505              * The supertype is always a class type. If the type
2506              * variable&#39;s bounds start with a class type, this is also
2507              * the supertype.  Otherwise, the supertype is
2508              * java.lang.Object.
2509              */
2510             @Override
2511             public Type visitTypeVar(TypeVar t, Void ignored) {
2512                 if (t.getUpperBound().hasTag(TYPEVAR) ||
2513                     (!t.getUpperBound().isCompound() &amp;&amp; !t.getUpperBound().isInterface())) {
2514                     return t.getUpperBound();
2515                 } else {
2516                     return supertype(t.getUpperBound());
2517                 }
2518             }
2519 
2520             @Override
2521             public Type visitArrayType(ArrayType t, Void ignored) {
2522                 if (t.elemtype.isPrimitive() || isSameType(t.elemtype, syms.objectType))
2523                     return arraySuperType();
2524                 else
2525                     return new ArrayType(supertype(t.elemtype), t.tsym);
2526             }
2527 
2528             @Override
2529             public Type visitErrorType(ErrorType t, Void ignored) {
2530                 return Type.noType;
2531             }
2532         };
2533     // &lt;/editor-fold&gt;
2534 
2535     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;interfaces&quot;&gt;
2536     /**
2537      * Return the interfaces implemented by this class.
2538      */
2539     public List&lt;Type&gt; interfaces(Type t) {
2540         return interfaces.visit(t);
2541     }
2542     // where
2543         private UnaryVisitor&lt;List&lt;Type&gt;&gt; interfaces = new UnaryVisitor&lt;List&lt;Type&gt;&gt;() {
2544 
2545             public List&lt;Type&gt; visitType(Type t, Void ignored) {
2546                 return List.nil();
2547             }
2548 
2549             @Override
2550             public List&lt;Type&gt; visitClassType(ClassType t, Void ignored) {
2551                 if (t.interfaces_field == null) {
2552                     List&lt;Type&gt; interfaces = ((ClassSymbol)t.tsym).getInterfaces();
2553                     if (t.interfaces_field == null) {
2554                         // If t.interfaces_field is null, then t must
2555                         // be a parameterized type (not to be confused
2556                         // with a generic type declaration).
2557                         // Terminology:
2558                         //    Parameterized type: List&lt;String&gt;
2559                         //    Generic type declaration: class List&lt;E&gt; { ... }
2560                         // So t corresponds to List&lt;String&gt; and
2561                         // t.tsym.type corresponds to List&lt;E&gt;.
2562                         // The reason t must be parameterized type is
2563                         // that completion will happen as a side
2564                         // effect of calling
2565                         // ClassSymbol.getInterfaces.  Since
2566                         // t.interfaces_field is null after
2567                         // completion, we can assume that t is not the
2568                         // type of a class/interface declaration.
2569                         Assert.check(t != t.tsym.type, t);
2570                         List&lt;Type&gt; actuals = t.allparams();
2571                         List&lt;Type&gt; formals = t.tsym.type.allparams();
2572                         if (t.hasErasedSupertypes()) {
2573                             t.interfaces_field = erasureRecursive(interfaces);
2574                         } else if (formals.nonEmpty()) {
2575                             t.interfaces_field = subst(interfaces, formals, actuals);
2576                         }
2577                         else {
2578                             t.interfaces_field = interfaces;
2579                         }
2580                     }
2581                 }
2582                 return t.interfaces_field;
2583             }
2584 
2585             @Override
2586             public List&lt;Type&gt; visitTypeVar(TypeVar t, Void ignored) {
2587                 if (t.getUpperBound().isCompound())
2588                     return interfaces(t.getUpperBound());
2589 
2590                 if (t.getUpperBound().isInterface())
2591                     return List.of(t.getUpperBound());
2592 
2593                 return List.nil();
2594             }
2595         };
2596 
2597     public List&lt;Type&gt; directSupertypes(Type t) {
2598         return directSupertypes.visit(t);
2599     }
2600     // where
2601         private final UnaryVisitor&lt;List&lt;Type&gt;&gt; directSupertypes = new UnaryVisitor&lt;List&lt;Type&gt;&gt;() {
2602 
2603             public List&lt;Type&gt; visitType(final Type type, final Void ignored) {
2604                 if (!type.isIntersection()) {
2605                     final Type sup = supertype(type);
2606                     return (sup == Type.noType || sup == type || sup == null)
2607                         ? interfaces(type)
2608                         : interfaces(type).prepend(sup);
2609                 } else {
2610                     return ((IntersectionClassType)type).getExplicitComponents();
2611                 }
2612             }
2613         };
2614 
2615     public boolean isDirectSuperInterface(TypeSymbol isym, TypeSymbol origin) {
2616         for (Type i2 : interfaces(origin.type)) {
2617             if (isym == i2.tsym) return true;
2618         }
2619         return false;
2620     }
2621     // &lt;/editor-fold&gt;
2622 
2623     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isDerivedRaw&quot;&gt;
2624     Map&lt;Type,Boolean&gt; isDerivedRawCache = new HashMap&lt;&gt;();
2625 
2626     public boolean isDerivedRaw(Type t) {
2627         Boolean result = isDerivedRawCache.get(t);
2628         if (result == null) {
2629             result = isDerivedRawInternal(t);
2630             isDerivedRawCache.put(t, result);
2631         }
2632         return result;
2633     }
2634 
2635     public boolean isDerivedRawInternal(Type t) {
2636         if (t.isErroneous())
2637             return false;
2638         return
2639             t.isRaw() ||
2640             supertype(t) != Type.noType &amp;&amp; isDerivedRaw(supertype(t)) ||
2641             isDerivedRaw(interfaces(t));
2642     }
2643 
2644     public boolean isDerivedRaw(List&lt;Type&gt; ts) {
2645         List&lt;Type&gt; l = ts;
2646         while (l.nonEmpty() &amp;&amp; !isDerivedRaw(l.head)) l = l.tail;
2647         return l.nonEmpty();
2648     }
2649     // &lt;/editor-fold&gt;
2650 
2651     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;setBounds&quot;&gt;
2652     /**
2653      * Same as {@link Types#setBounds(TypeVar, List, boolean)}, except that third parameter is computed directly,
2654      * as follows: if all all bounds are interface types, the computed supertype is Object,otherwise
2655      * the supertype is simply left null (in this case, the supertype is assumed to be the head of
2656      * the bound list passed as second argument). Note that this check might cause a symbol completion.
2657      * Hence, this version of setBounds may not be called during a classfile read.
2658      *
2659      * @param t         a type variable
2660      * @param bounds    the bounds, must be nonempty
2661      */
2662     public void setBounds(TypeVar t, List&lt;Type&gt; bounds) {
2663         setBounds(t, bounds, bounds.head.tsym.isInterface());
2664     }
2665 
2666     /**
2667      * Set the bounds field of the given type variable to reflect a (possibly multiple) list of bounds.
2668      * This does not cause symbol completion as an extra parameter indicates as to whether all bounds
2669      * are interfaces - in which case the supertype is implicitly assumed to be &#39;Object&#39;.
2670      *
2671      * @param t             a type variable
2672      * @param bounds        the bounds, must be nonempty
2673      * @param allInterfaces are all bounds interface types?
2674      */
2675     public void setBounds(TypeVar t, List&lt;Type&gt; bounds, boolean allInterfaces) {
2676         t.setUpperBound( bounds.tail.isEmpty() ?
2677                 bounds.head :
2678                 makeIntersectionType(bounds, allInterfaces) );
2679         t.rank_field = -1;
2680     }
2681     // &lt;/editor-fold&gt;
2682 
2683     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;getBounds&quot;&gt;
2684     /**
2685      * Return list of bounds of the given type variable.
2686      */
2687     public List&lt;Type&gt; getBounds(TypeVar t) {
2688         if (t.getUpperBound().hasTag(NONE))
2689             return List.nil();
2690         else if (t.getUpperBound().isErroneous() || !t.getUpperBound().isCompound())
2691             return List.of(t.getUpperBound());
2692         else if ((erasure(t).tsym.flags() &amp; INTERFACE) == 0)
2693             return interfaces(t).prepend(supertype(t));
2694         else
2695             // No superclass was given in bounds.
2696             // In this case, supertype is Object, erasure is first interface.
2697             return interfaces(t);
2698     }
2699     // &lt;/editor-fold&gt;
2700 
2701     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;classBound&quot;&gt;
2702     /**
2703      * If the given type is a (possibly selected) type variable,
2704      * return the bounding class of this type, otherwise return the
2705      * type itself.
2706      */
2707     public Type classBound(Type t) {
2708         return classBound.visit(t);
2709     }
2710     // where
2711         private UnaryVisitor&lt;Type&gt; classBound = new UnaryVisitor&lt;Type&gt;() {
2712 
2713             public Type visitType(Type t, Void ignored) {
2714                 return t;
2715             }
2716 
2717             @Override
2718             public Type visitClassType(ClassType t, Void ignored) {
2719                 Type outer1 = classBound(t.getEnclosingType());
2720                 if (outer1 != t.getEnclosingType())
2721                     return new ClassType(outer1, t.getTypeArguments(), t.tsym,
2722                                          t.getMetadata());
2723                 else
2724                     return t;
2725             }
2726 
2727             @Override
2728             public Type visitTypeVar(TypeVar t, Void ignored) {
2729                 return classBound(supertype(t));
2730             }
2731 
2732             @Override
2733             public Type visitErrorType(ErrorType t, Void ignored) {
2734                 return t;
2735             }
2736         };
2737     // &lt;/editor-fold&gt;
2738 
2739     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;sub signature / override equivalence&quot;&gt;
2740     /**
2741      * Returns true iff the first signature is a &lt;em&gt;sub
2742      * signature&lt;/em&gt; of the other.  This is &lt;b&gt;not&lt;/b&gt; an equivalence
2743      * relation.
2744      *
2745      * @jls 8.4.2 Method Signature
2746      * @see #overrideEquivalent(Type t, Type s)
2747      * @param t first signature (possibly raw).
2748      * @param s second signature (could be subjected to erasure).
2749      * @return true if t is a sub signature of s.
2750      */
2751     public boolean isSubSignature(Type t, Type s) {
2752         return isSubSignature(t, s, true);
2753     }
2754 
2755     public boolean isSubSignature(Type t, Type s, boolean strict) {
2756         return hasSameArgs(t, s, strict) || hasSameArgs(t, erasure(s), strict);
2757     }
2758 
2759     /**
2760      * Returns true iff these signatures are related by &lt;em&gt;override
2761      * equivalence&lt;/em&gt;.  This is the natural extension of
2762      * isSubSignature to an equivalence relation.
2763      *
2764      * @jls 8.4.2 Method Signature
2765      * @see #isSubSignature(Type t, Type s)
2766      * @param t a signature (possible raw, could be subjected to
2767      * erasure).
2768      * @param s a signature (possible raw, could be subjected to
2769      * erasure).
2770      * @return true if either argument is a sub signature of the other.
2771      */
2772     public boolean overrideEquivalent(Type t, Type s) {
2773         return hasSameArgs(t, s) ||
2774             hasSameArgs(t, erasure(s)) || hasSameArgs(erasure(t), s);
2775     }
2776 
2777     public boolean overridesObjectMethod(TypeSymbol origin, Symbol msym) {
2778         for (Symbol sym : syms.objectType.tsym.members().getSymbolsByName(msym.name)) {
2779             if (msym.overrides(sym, origin, Types.this, true)) {
2780                 return true;
2781             }
2782         }
2783         return false;
2784     }
2785 
2786     /**
2787      * This enum defines the strategy for implementing most specific return type check
2788      * during the most specific and functional interface checks.
2789      */
2790     public enum MostSpecificReturnCheck {
2791         /**
2792          * Return r1 is more specific than r2 if {@code r1 &lt;: r2}. Extra care required for (i) handling
2793          * method type variables (if either method is generic) and (ii) subtyping should be replaced
2794          * by type-equivalence for primitives. This is essentially an inlined version of
2795          * {@link Types#resultSubtype(Type, Type, Warner)}, where the assignability check has been
2796          * replaced with a strict subtyping check.
2797          */
2798         BASIC() {
2799             @Override
2800             public boolean test(Type mt1, Type mt2, Types types) {
2801                 List&lt;Type&gt; tvars = mt1.getTypeArguments();
2802                 List&lt;Type&gt; svars = mt2.getTypeArguments();
2803                 Type t = mt1.getReturnType();
2804                 Type s = types.subst(mt2.getReturnType(), svars, tvars);
2805                 return types.isSameType(t, s) ||
2806                     !t.isPrimitive() &amp;&amp;
2807                     !s.isPrimitive() &amp;&amp;
2808                     types.isSubtype(t, s);
2809             }
2810         },
2811         /**
2812          * Return r1 is more specific than r2 if r1 is return-type-substitutable for r2.
2813          */
2814         RTS() {
2815             @Override
2816             public boolean test(Type mt1, Type mt2, Types types) {
2817                 return types.returnTypeSubstitutable(mt1, mt2);
2818             }
2819         };
2820 
2821         public abstract boolean test(Type mt1, Type mt2, Types types);
2822     }
2823 
2824     /**
2825      * Merge multiple abstract methods. The preferred method is a method that is a subsignature
2826      * of all the other signatures and whose return type is more specific {@see MostSpecificReturnCheck}.
2827      * The resulting preferred method has a thrown clause that is the intersection of the merged
2828      * methods&#39; clauses.
2829      */
2830     public Optional&lt;Symbol&gt; mergeAbstracts(List&lt;Symbol&gt; ambiguousInOrder, Type site, boolean sigCheck) {
2831         //first check for preconditions
2832         boolean shouldErase = false;
2833         List&lt;Type&gt; erasedParams = ambiguousInOrder.head.erasure(this).getParameterTypes();
2834         for (Symbol s : ambiguousInOrder) {
2835             if ((s.flags() &amp; ABSTRACT) == 0 ||
2836                     (sigCheck &amp;&amp; !isSameTypes(erasedParams, s.erasure(this).getParameterTypes()))) {
2837                 return Optional.empty();
2838             } else if (s.type.hasTag(FORALL)) {
2839                 shouldErase = true;
2840             }
2841         }
2842         //then merge abstracts
2843         for (MostSpecificReturnCheck mostSpecificReturnCheck : MostSpecificReturnCheck.values()) {
2844             outer: for (Symbol s : ambiguousInOrder) {
2845                 Type mt = memberType(site, s);
2846                 List&lt;Type&gt; allThrown = mt.getThrownTypes();
2847                 for (Symbol s2 : ambiguousInOrder) {
2848                     if (s != s2) {
2849                         Type mt2 = memberType(site, s2);
2850                         if (!isSubSignature(mt, mt2) ||
2851                                 !mostSpecificReturnCheck.test(mt, mt2, this)) {
2852                             //ambiguity cannot be resolved
2853                             continue outer;
2854                         } else {
2855                             List&lt;Type&gt; thrownTypes2 = mt2.getThrownTypes();
2856                             if (!mt.hasTag(FORALL) &amp;&amp; shouldErase) {
2857                                 thrownTypes2 = erasure(thrownTypes2);
2858                             } else if (mt.hasTag(FORALL)) {
2859                                 //subsignature implies that if most specific is generic, then all other
2860                                 //methods are too
2861                                 Assert.check(mt2.hasTag(FORALL));
2862                                 // if both are generic methods, adjust thrown types ahead of intersection computation
2863                                 thrownTypes2 = subst(thrownTypes2, mt2.getTypeArguments(), mt.getTypeArguments());
2864                             }
2865                             allThrown = chk.intersect(allThrown, thrownTypes2);
2866                         }
2867                     }
2868                 }
2869                 return (allThrown == mt.getThrownTypes()) ?
2870                         Optional.of(s) :
2871                         Optional.of(new MethodSymbol(
2872                                 s.flags(),
2873                                 s.name,
2874                                 createMethodTypeWithThrown(s.type, allThrown),
2875                                 s.owner) {
2876                             @Override
2877                             public Symbol baseSymbol() {
2878                                 return s;
2879                             }
2880                         });
2881             }
2882         }
2883         return Optional.empty();
2884     }
2885 
2886     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Determining method implementation in given site&quot;&gt;
2887     class ImplementationCache {
2888 
2889         private WeakHashMap&lt;MethodSymbol, SoftReference&lt;Map&lt;TypeSymbol, Entry&gt;&gt;&gt; _map = new WeakHashMap&lt;&gt;();
2890 
2891         class Entry {
2892             final MethodSymbol cachedImpl;
2893             final Filter&lt;Symbol&gt; implFilter;
2894             final boolean checkResult;
2895             final int prevMark;
2896 
2897             public Entry(MethodSymbol cachedImpl,
2898                     Filter&lt;Symbol&gt; scopeFilter,
2899                     boolean checkResult,
2900                     int prevMark) {
2901                 this.cachedImpl = cachedImpl;
2902                 this.implFilter = scopeFilter;
2903                 this.checkResult = checkResult;
2904                 this.prevMark = prevMark;
2905             }
2906 
2907             boolean matches(Filter&lt;Symbol&gt; scopeFilter, boolean checkResult, int mark) {
2908                 return this.implFilter == scopeFilter &amp;&amp;
2909                         this.checkResult == checkResult &amp;&amp;
2910                         this.prevMark == mark;
2911             }
2912         }
2913 
2914         MethodSymbol get(MethodSymbol ms, TypeSymbol origin, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
2915             SoftReference&lt;Map&lt;TypeSymbol, Entry&gt;&gt; ref_cache = _map.get(ms);
2916             Map&lt;TypeSymbol, Entry&gt; cache = ref_cache != null ? ref_cache.get() : null;
2917             if (cache == null) {
2918                 cache = new HashMap&lt;&gt;();
2919                 _map.put(ms, new SoftReference&lt;&gt;(cache));
2920             }
2921             Entry e = cache.get(origin);
2922             CompoundScope members = membersClosure(origin.type, true);
2923             if (e == null ||
2924                     !e.matches(implFilter, checkResult, members.getMark())) {
2925                 MethodSymbol impl = implementationInternal(ms, origin, checkResult, implFilter);
2926                 cache.put(origin, new Entry(impl, implFilter, checkResult, members.getMark()));
2927                 return impl;
2928             }
2929             else {
2930                 return e.cachedImpl;
2931             }
2932         }
2933 
2934         private MethodSymbol implementationInternal(MethodSymbol ms, TypeSymbol origin, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
2935             for (Type t = origin.type; t.hasTag(CLASS) || t.hasTag(TYPEVAR); t = supertype(t)) {
2936                 t = skipTypeVars(t, false);
2937                 TypeSymbol c = t.tsym;
2938                 Symbol bestSoFar = null;
2939                 for (Symbol sym : c.members().getSymbolsByName(ms.name, implFilter)) {
2940                     if (sym != null &amp;&amp; sym.overrides(ms, origin, Types.this, checkResult)) {
2941                         bestSoFar = sym;
2942                         if ((sym.flags() &amp; ABSTRACT) == 0) {
2943                             //if concrete impl is found, exit immediately
2944                             break;
2945                         }
2946                     }
2947                 }
2948                 if (bestSoFar != null) {
2949                     //return either the (only) concrete implementation or the first abstract one
2950                     return (MethodSymbol)bestSoFar;
2951                 }
2952             }
2953             return null;
2954         }
2955     }
2956 
2957     private ImplementationCache implCache = new ImplementationCache();
2958 
2959     public MethodSymbol implementation(MethodSymbol ms, TypeSymbol origin, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
2960         return implCache.get(ms, origin, checkResult, implFilter);
2961     }
2962     // &lt;/editor-fold&gt;
2963 
2964     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;compute transitive closure of all members in given site&quot;&gt;
2965     class MembersClosureCache extends SimpleVisitor&lt;Scope.CompoundScope, Void&gt; {
2966 
2967         private Map&lt;TypeSymbol, CompoundScope&gt; _map = new HashMap&lt;&gt;();
2968 
2969         Set&lt;TypeSymbol&gt; seenTypes = new HashSet&lt;&gt;();
2970 
2971         class MembersScope extends CompoundScope {
2972 
2973             CompoundScope scope;
2974 
2975             public MembersScope(CompoundScope scope) {
2976                 super(scope.owner);
2977                 this.scope = scope;
2978             }
2979 
2980             Filter&lt;Symbol&gt; combine(Filter&lt;Symbol&gt; sf) {
2981                 return s -&gt; !s.owner.isInterface() &amp;&amp; (sf == null || sf.accepts(s));
2982             }
2983 
2984             @Override
2985             public Iterable&lt;Symbol&gt; getSymbols(Filter&lt;Symbol&gt; sf, LookupKind lookupKind) {
2986                 return scope.getSymbols(combine(sf), lookupKind);
2987             }
2988 
2989             @Override
2990             public Iterable&lt;Symbol&gt; getSymbolsByName(Name name, Filter&lt;Symbol&gt; sf, LookupKind lookupKind) {
2991                 return scope.getSymbolsByName(name, combine(sf), lookupKind);
2992             }
2993 
2994             @Override
2995             public int getMark() {
2996                 return scope.getMark();
2997             }
2998         }
2999 
3000         CompoundScope nilScope;
3001 
3002         /** members closure visitor methods **/
3003 
3004         public CompoundScope visitType(Type t, Void _unused) {
3005             if (nilScope == null) {
3006                 nilScope = new CompoundScope(syms.noSymbol);
3007             }
3008             return nilScope;
3009         }
3010 
3011         @Override
3012         public CompoundScope visitClassType(ClassType t, Void _unused) {
3013             if (!seenTypes.add(t.tsym)) {
3014                 //this is possible when an interface is implemented in multiple
3015                 //superclasses, or when a class hierarchy is circular - in such
3016                 //cases we don&#39;t need to recurse (empty scope is returned)
3017                 return new CompoundScope(t.tsym);
3018             }
3019             try {
3020                 seenTypes.add(t.tsym);
3021                 ClassSymbol csym = (ClassSymbol)t.tsym;
3022                 CompoundScope membersClosure = _map.get(csym);
3023                 if (membersClosure == null) {
3024                     membersClosure = new CompoundScope(csym);
3025                     for (Type i : interfaces(t)) {
3026                         membersClosure.prependSubScope(visit(i, null));
3027                     }
3028                     membersClosure.prependSubScope(visit(supertype(t), null));
3029                     membersClosure.prependSubScope(csym.members());
3030                     _map.put(csym, membersClosure);
3031                 }
3032                 return membersClosure;
3033             }
3034             finally {
3035                 seenTypes.remove(t.tsym);
3036             }
3037         }
3038 
3039         @Override
3040         public CompoundScope visitTypeVar(TypeVar t, Void _unused) {
3041             return visit(t.getUpperBound(), null);
3042         }
3043     }
3044 
3045     private MembersClosureCache membersCache = new MembersClosureCache();
3046 
3047     public CompoundScope membersClosure(Type site, boolean skipInterface) {
3048         CompoundScope cs = membersCache.visit(site, null);
3049         Assert.checkNonNull(cs, () -&gt; &quot;type &quot; + site);
3050         return skipInterface ? membersCache.new MembersScope(cs) : cs;
3051     }
3052     // &lt;/editor-fold&gt;
3053 
3054 
3055     /** Return first abstract member of class `sym&#39;.
3056      */
3057     public MethodSymbol firstUnimplementedAbstract(ClassSymbol sym) {
3058         try {
3059             return firstUnimplementedAbstractImpl(sym, sym);
3060         } catch (CompletionFailure ex) {
3061             chk.completionError(enter.getEnv(sym).tree.pos(), ex);
3062             return null;
3063         }
3064     }
3065         //where:
3066         private MethodSymbol firstUnimplementedAbstractImpl(ClassSymbol impl, ClassSymbol c) {
3067             MethodSymbol undef = null;
3068             // Do not bother to search in classes that are not abstract,
3069             // since they cannot have abstract members.
3070             if (c == impl || (c.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
3071                 Scope s = c.members();
3072                 for (Symbol sym : s.getSymbols(NON_RECURSIVE)) {
3073                     if (sym.kind == MTH &amp;&amp;
3074                         (sym.flags() &amp; (ABSTRACT|DEFAULT|PRIVATE)) == ABSTRACT) {
3075                         MethodSymbol absmeth = (MethodSymbol)sym;
3076                         MethodSymbol implmeth = absmeth.implementation(impl, this, true);
3077                         if (implmeth == null || implmeth == absmeth) {
3078                             //look for default implementations
3079                             if (allowDefaultMethods) {
3080                                 MethodSymbol prov = interfaceCandidates(impl.type, absmeth).head;
3081                                 if (prov != null &amp;&amp; prov.overrides(absmeth, impl, this, true)) {
3082                                     implmeth = prov;
3083                                 }
3084                             }
3085                         }
3086                         if (implmeth == null || implmeth == absmeth) {
3087                             undef = absmeth;
3088                             break;
3089                         }
3090                     }
3091                 }
3092                 if (undef == null) {
3093                     Type st = supertype(c.type);
3094                     if (st.hasTag(CLASS))
3095                         undef = firstUnimplementedAbstractImpl(impl, (ClassSymbol)st.tsym);
3096                 }
3097                 for (List&lt;Type&gt; l = interfaces(c.type);
3098                      undef == null &amp;&amp; l.nonEmpty();
3099                      l = l.tail) {
3100                     undef = firstUnimplementedAbstractImpl(impl, (ClassSymbol)l.head.tsym);
3101                 }
3102             }
3103             return undef;
3104         }
3105 
3106     public class CandidatesCache {
3107         public Map&lt;Entry, List&lt;MethodSymbol&gt;&gt; cache = new WeakHashMap&lt;&gt;();
3108 
3109         class Entry {
3110             Type site;
3111             MethodSymbol msym;
3112 
3113             Entry(Type site, MethodSymbol msym) {
3114                 this.site = site;
3115                 this.msym = msym;
3116             }
3117 
3118             @Override
3119             public boolean equals(Object obj) {
3120                 if (obj instanceof Entry) {
3121                     Entry e = (Entry)obj;
3122                     return e.msym == msym &amp;&amp; isSameType(site, e.site);
3123                 } else {
3124                     return false;
3125                 }
3126             }
3127 
3128             @Override
3129             public int hashCode() {
3130                 return Types.this.hashCode(site) &amp; ~msym.hashCode();
3131             }
3132         }
3133 
3134         public List&lt;MethodSymbol&gt; get(Entry e) {
3135             return cache.get(e);
3136         }
3137 
3138         public void put(Entry e, List&lt;MethodSymbol&gt; msymbols) {
3139             cache.put(e, msymbols);
3140         }
3141     }
3142 
3143     public CandidatesCache candidatesCache = new CandidatesCache();
3144 
3145     //where
3146     public List&lt;MethodSymbol&gt; interfaceCandidates(Type site, MethodSymbol ms) {
3147         CandidatesCache.Entry e = candidatesCache.new Entry(site, ms);
3148         List&lt;MethodSymbol&gt; candidates = candidatesCache.get(e);
3149         if (candidates == null) {
3150             Filter&lt;Symbol&gt; filter = new MethodFilter(ms, site);
3151             List&lt;MethodSymbol&gt; candidates2 = List.nil();
3152             for (Symbol s : membersClosure(site, false).getSymbols(filter)) {
3153                 if (!site.tsym.isInterface() &amp;&amp; !s.owner.isInterface()) {
3154                     return List.of((MethodSymbol)s);
3155                 } else if (!candidates2.contains(s)) {
3156                     candidates2 = candidates2.prepend((MethodSymbol)s);
3157                 }
3158             }
3159             candidates = prune(candidates2);
3160             candidatesCache.put(e, candidates);
3161         }
3162         return candidates;
3163     }
3164 
3165     public List&lt;MethodSymbol&gt; prune(List&lt;MethodSymbol&gt; methods) {
3166         ListBuffer&lt;MethodSymbol&gt; methodsMin = new ListBuffer&lt;&gt;();
3167         for (MethodSymbol m1 : methods) {
3168             boolean isMin_m1 = true;
3169             for (MethodSymbol m2 : methods) {
3170                 if (m1 == m2) continue;
3171                 if (m2.owner != m1.owner &amp;&amp;
3172                         asSuper(m2.owner.type, m1.owner) != null) {
3173                     isMin_m1 = false;
3174                     break;
3175                 }
3176             }
3177             if (isMin_m1)
3178                 methodsMin.append(m1);
3179         }
3180         return methodsMin.toList();
3181     }
3182     // where
3183             private class MethodFilter implements Filter&lt;Symbol&gt; {
3184 
3185                 Symbol msym;
3186                 Type site;
3187 
3188                 MethodFilter(Symbol msym, Type site) {
3189                     this.msym = msym;
3190                     this.site = site;
3191                 }
3192 
3193                 public boolean accepts(Symbol s) {
3194                     return s.kind == MTH &amp;&amp;
3195                             s.name == msym.name &amp;&amp;
3196                             (s.flags() &amp; SYNTHETIC) == 0 &amp;&amp;
3197                             s.isInheritedIn(site.tsym, Types.this) &amp;&amp;
3198                             overrideEquivalent(memberType(site, s), memberType(site, msym));
3199                 }
3200             }
3201     // &lt;/editor-fold&gt;
3202 
3203     /**
3204      * Does t have the same arguments as s?  It is assumed that both
3205      * types are (possibly polymorphic) method types.  Monomorphic
3206      * method types &quot;have the same arguments&quot;, if their argument lists
3207      * are equal.  Polymorphic method types &quot;have the same arguments&quot;,
3208      * if they have the same arguments after renaming all type
3209      * variables of one to corresponding type variables in the other,
3210      * where correspondence is by position in the type parameter list.
3211      */
3212     public boolean hasSameArgs(Type t, Type s) {
3213         return hasSameArgs(t, s, true);
3214     }
3215 
3216     public boolean hasSameArgs(Type t, Type s, boolean strict) {
3217         return hasSameArgs(t, s, strict ? hasSameArgs_strict : hasSameArgs_nonstrict);
3218     }
3219 
3220     private boolean hasSameArgs(Type t, Type s, TypeRelation hasSameArgs) {
3221         return hasSameArgs.visit(t, s);
3222     }
3223     // where
3224         private class HasSameArgs extends TypeRelation {
3225 
3226             boolean strict;
3227 
3228             public HasSameArgs(boolean strict) {
3229                 this.strict = strict;
3230             }
3231 
3232             public Boolean visitType(Type t, Type s) {
3233                 throw new AssertionError();
3234             }
3235 
3236             @Override
3237             public Boolean visitMethodType(MethodType t, Type s) {
3238                 return s.hasTag(METHOD)
3239                     &amp;&amp; containsTypeEquivalent(t.argtypes, s.getParameterTypes());
3240             }
3241 
3242             @Override
3243             public Boolean visitForAll(ForAll t, Type s) {
3244                 if (!s.hasTag(FORALL))
3245                     return strict ? false : visitMethodType(t.asMethodType(), s);
3246 
3247                 ForAll forAll = (ForAll)s;
3248                 return hasSameBounds(t, forAll)
3249                     &amp;&amp; visit(t.qtype, subst(forAll.qtype, forAll.tvars, t.tvars));
3250             }
3251 
3252             @Override
3253             public Boolean visitErrorType(ErrorType t, Type s) {
3254                 return false;
3255             }
3256         }
3257 
3258     TypeRelation hasSameArgs_strict = new HasSameArgs(true);
3259         TypeRelation hasSameArgs_nonstrict = new HasSameArgs(false);
3260 
3261     // &lt;/editor-fold&gt;
3262 
3263     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;subst&quot;&gt;
3264     public List&lt;Type&gt; subst(List&lt;Type&gt; ts,
3265                             List&lt;Type&gt; from,
3266                             List&lt;Type&gt; to) {
3267         return ts.map(new Subst(from, to));
3268     }
3269 
3270     /**
3271      * Substitute all occurrences of a type in `from&#39; with the
3272      * corresponding type in `to&#39; in &#39;t&#39;. Match lists `from&#39; and `to&#39;
3273      * from the right: If lists have different length, discard leading
3274      * elements of the longer list.
3275      */
3276     public Type subst(Type t, List&lt;Type&gt; from, List&lt;Type&gt; to) {
3277         return t.map(new Subst(from, to));
3278     }
3279 
3280     private class Subst extends StructuralTypeMapping&lt;Void&gt; {
3281         List&lt;Type&gt; from;
3282         List&lt;Type&gt; to;
3283 
3284         public Subst(List&lt;Type&gt; from, List&lt;Type&gt; to) {
3285             int fromLength = from.length();
3286             int toLength = to.length();
3287             while (fromLength &gt; toLength) {
3288                 fromLength--;
3289                 from = from.tail;
3290             }
3291             while (fromLength &lt; toLength) {
3292                 toLength--;
3293                 to = to.tail;
3294             }
3295             this.from = from;
3296             this.to = to;
3297         }
3298 
3299         @Override
3300         public Type visitTypeVar(TypeVar t, Void ignored) {
3301             for (List&lt;Type&gt; from = this.from, to = this.to;
3302                  from.nonEmpty();
3303                  from = from.tail, to = to.tail) {
3304                 if (t.equalsIgnoreMetadata(from.head)) {
3305                     return to.head.withTypeVar(t);
3306                 }
3307             }
3308             return t;
3309         }
3310 
3311         @Override
3312         public Type visitClassType(ClassType t, Void ignored) {
3313             if (!t.isCompound()) {
3314                 return super.visitClassType(t, ignored);
3315             } else {
3316                 Type st = visit(supertype(t));
3317                 List&lt;Type&gt; is = visit(interfaces(t), ignored);
3318                 if (st == supertype(t) &amp;&amp; is == interfaces(t))
3319                     return t;
3320                 else
3321                     return makeIntersectionType(is.prepend(st));
3322             }
3323         }
3324 
3325         @Override
3326         public Type visitWildcardType(WildcardType t, Void ignored) {
3327             WildcardType t2 = (WildcardType)super.visitWildcardType(t, ignored);
3328             if (t2 != t &amp;&amp; t.isExtendsBound() &amp;&amp; t2.type.isExtendsBound()) {
3329                 t2.type = wildUpperBound(t2.type);
3330             }
3331             return t2;
3332         }
3333 
3334         @Override
3335         public Type visitForAll(ForAll t, Void ignored) {
3336             if (Type.containsAny(to, t.tvars)) {
3337                 //perform alpha-renaming of free-variables in &#39;t&#39;
3338                 //if &#39;to&#39; types contain variables that are free in &#39;t&#39;
3339                 List&lt;Type&gt; freevars = newInstances(t.tvars);
3340                 t = new ForAll(freevars,
3341                                Types.this.subst(t.qtype, t.tvars, freevars));
3342             }
3343             List&lt;Type&gt; tvars1 = substBounds(t.tvars, from, to);
3344             Type qtype1 = visit(t.qtype);
3345             if (tvars1 == t.tvars &amp;&amp; qtype1 == t.qtype) {
3346                 return t;
3347             } else if (tvars1 == t.tvars) {
3348                 return new ForAll(tvars1, qtype1) {
3349                     @Override
3350                     public boolean needsStripping() {
3351                         return true;
3352                     }
3353                 };
3354             } else {
3355                 return new ForAll(tvars1, Types.this.subst(qtype1, t.tvars, tvars1)) {
3356                     @Override
3357                     public boolean needsStripping() {
3358                         return true;
3359                     }
3360                 };
3361             }
3362         }
3363     }
3364 
3365     public List&lt;Type&gt; substBounds(List&lt;Type&gt; tvars,
3366                                   List&lt;Type&gt; from,
3367                                   List&lt;Type&gt; to) {
3368         if (tvars.isEmpty())
3369             return tvars;
3370         ListBuffer&lt;Type&gt; newBoundsBuf = new ListBuffer&lt;&gt;();
3371         boolean changed = false;
3372         // calculate new bounds
3373         for (Type t : tvars) {
3374             TypeVar tv = (TypeVar) t;
3375             Type bound = subst(tv.getUpperBound(), from, to);
3376             if (bound != tv.getUpperBound())
3377                 changed = true;
3378             newBoundsBuf.append(bound);
3379         }
3380         if (!changed)
3381             return tvars;
3382         ListBuffer&lt;Type&gt; newTvars = new ListBuffer&lt;&gt;();
3383         // create new type variables without bounds
3384         for (Type t : tvars) {
3385             newTvars.append(new TypeVar(t.tsym, null, syms.botType,
3386                                         t.getMetadata()));
3387         }
3388         // the new bounds should use the new type variables in place
3389         // of the old
3390         List&lt;Type&gt; newBounds = newBoundsBuf.toList();
3391         from = tvars;
3392         to = newTvars.toList();
3393         for (; !newBounds.isEmpty(); newBounds = newBounds.tail) {
3394             newBounds.head = subst(newBounds.head, from, to);
3395         }
3396         newBounds = newBoundsBuf.toList();
3397         // set the bounds of new type variables to the new bounds
3398         for (Type t : newTvars.toList()) {
3399             TypeVar tv = (TypeVar) t;
3400             tv.setUpperBound( newBounds.head );
3401             newBounds = newBounds.tail;
3402         }
3403         return newTvars.toList();
3404     }
3405 
3406     public TypeVar substBound(TypeVar t, List&lt;Type&gt; from, List&lt;Type&gt; to) {
3407         Type bound1 = subst(t.getUpperBound(), from, to);
3408         if (bound1 == t.getUpperBound())
3409             return t;
3410         else {
3411             // create new type variable without bounds
3412             TypeVar tv = new TypeVar(t.tsym, null, syms.botType,
3413                                      t.getMetadata());
3414             // the new bound should use the new type variable in place
3415             // of the old
3416             tv.setUpperBound( subst(bound1, List.of(t), List.of(tv)) );
3417             return tv;
3418         }
3419     }
3420     // &lt;/editor-fold&gt;
3421 
3422     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;hasSameBounds&quot;&gt;
3423     /**
3424      * Does t have the same bounds for quantified variables as s?
3425      */
3426     public boolean hasSameBounds(ForAll t, ForAll s) {
3427         List&lt;Type&gt; l1 = t.tvars;
3428         List&lt;Type&gt; l2 = s.tvars;
3429         while (l1.nonEmpty() &amp;&amp; l2.nonEmpty() &amp;&amp;
3430                isSameType(l1.head.getUpperBound(),
3431                           subst(l2.head.getUpperBound(),
3432                                 s.tvars,
3433                                 t.tvars))) {
3434             l1 = l1.tail;
3435             l2 = l2.tail;
3436         }
3437         return l1.isEmpty() &amp;&amp; l2.isEmpty();
3438     }
3439     // &lt;/editor-fold&gt;
3440 
3441     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;newInstances&quot;&gt;
3442     /** Create new vector of type variables from list of variables
3443      *  changing all recursive bounds from old to new list.
3444      */
3445     public List&lt;Type&gt; newInstances(List&lt;Type&gt; tvars) {
3446         List&lt;Type&gt; tvars1 = tvars.map(newInstanceFun);
3447         for (List&lt;Type&gt; l = tvars1; l.nonEmpty(); l = l.tail) {
3448             TypeVar tv = (TypeVar) l.head;
3449             tv.setUpperBound( subst(tv.getUpperBound(), tvars, tvars1) );
3450         }
3451         return tvars1;
3452     }
3453         private static final TypeMapping&lt;Void&gt; newInstanceFun = new TypeMapping&lt;Void&gt;() {
3454             @Override
3455             public TypeVar visitTypeVar(TypeVar t, Void _unused) {
3456                 return new TypeVar(t.tsym, t.getUpperBound(), t.getLowerBound(), t.getMetadata());
3457             }
3458         };
3459     // &lt;/editor-fold&gt;
3460 
3461     public Type createMethodTypeWithParameters(Type original, List&lt;Type&gt; newParams) {
3462         return original.accept(methodWithParameters, newParams);
3463     }
3464     // where
3465         private final MapVisitor&lt;List&lt;Type&gt;&gt; methodWithParameters = new MapVisitor&lt;List&lt;Type&gt;&gt;() {
3466             public Type visitType(Type t, List&lt;Type&gt; newParams) {
3467                 throw new IllegalArgumentException(&quot;Not a method type: &quot; + t);
3468             }
3469             public Type visitMethodType(MethodType t, List&lt;Type&gt; newParams) {
3470                 return new MethodType(newParams, t.restype, t.thrown, t.tsym);
3471             }
3472             public Type visitForAll(ForAll t, List&lt;Type&gt; newParams) {
3473                 return new ForAll(t.tvars, t.qtype.accept(this, newParams));
3474             }
3475         };
3476 
3477     public Type createMethodTypeWithThrown(Type original, List&lt;Type&gt; newThrown) {
3478         return original.accept(methodWithThrown, newThrown);
3479     }
3480     // where
3481         private final MapVisitor&lt;List&lt;Type&gt;&gt; methodWithThrown = new MapVisitor&lt;List&lt;Type&gt;&gt;() {
3482             public Type visitType(Type t, List&lt;Type&gt; newThrown) {
3483                 throw new IllegalArgumentException(&quot;Not a method type: &quot; + t);
3484             }
3485             public Type visitMethodType(MethodType t, List&lt;Type&gt; newThrown) {
3486                 return new MethodType(t.argtypes, t.restype, newThrown, t.tsym);
3487             }
3488             public Type visitForAll(ForAll t, List&lt;Type&gt; newThrown) {
3489                 return new ForAll(t.tvars, t.qtype.accept(this, newThrown));
3490             }
3491         };
3492 
3493     public Type createMethodTypeWithReturn(Type original, Type newReturn) {
3494         return original.accept(methodWithReturn, newReturn);
3495     }
3496     // where
3497         private final MapVisitor&lt;Type&gt; methodWithReturn = new MapVisitor&lt;Type&gt;() {
3498             public Type visitType(Type t, Type newReturn) {
3499                 throw new IllegalArgumentException(&quot;Not a method type: &quot; + t);
3500             }
3501             public Type visitMethodType(MethodType t, Type newReturn) {
3502                 return new MethodType(t.argtypes, newReturn, t.thrown, t.tsym) {
3503                     @Override
3504                     public Type baseType() {
3505                         return t;
3506                     }
3507                 };
3508             }
3509             public Type visitForAll(ForAll t, Type newReturn) {
3510                 return new ForAll(t.tvars, t.qtype.accept(this, newReturn)) {
3511                     @Override
3512                     public Type baseType() {
3513                         return t;
3514                     }
3515                 };
3516             }
3517         };
3518 
3519     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;createErrorType&quot;&gt;
3520     public Type createErrorType(Type originalType) {
3521         return new ErrorType(originalType, syms.errSymbol);
3522     }
3523 
3524     public Type createErrorType(ClassSymbol c, Type originalType) {
3525         return new ErrorType(c, originalType);
3526     }
3527 
3528     public Type createErrorType(Name name, TypeSymbol container, Type originalType) {
3529         return new ErrorType(name, container, originalType);
3530     }
3531     // &lt;/editor-fold&gt;
3532 
3533     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;rank&quot;&gt;
3534     /**
3535      * The rank of a class is the length of the longest path between
3536      * the class and java.lang.Object in the class inheritance
3537      * graph. Undefined for all but reference types.
3538      */
3539     public int rank(Type t) {
3540         switch(t.getTag()) {
3541         case CLASS: {
3542             ClassType cls = (ClassType)t;
3543             if (cls.rank_field &lt; 0) {
3544                 Name fullname = cls.tsym.getQualifiedName();
3545                 if (fullname == names.java_lang_Object)
3546                     cls.rank_field = 0;
3547                 else {
3548                     int r = rank(supertype(cls));
3549                     for (List&lt;Type&gt; l = interfaces(cls);
3550                          l.nonEmpty();
3551                          l = l.tail) {
3552                         if (rank(l.head) &gt; r)
3553                             r = rank(l.head);
3554                     }
3555                     cls.rank_field = r + 1;
3556                 }
3557             }
3558             return cls.rank_field;
3559         }
3560         case TYPEVAR: {
3561             TypeVar tvar = (TypeVar)t;
3562             if (tvar.rank_field &lt; 0) {
3563                 int r = rank(supertype(tvar));
3564                 for (List&lt;Type&gt; l = interfaces(tvar);
3565                      l.nonEmpty();
3566                      l = l.tail) {
3567                     if (rank(l.head) &gt; r) r = rank(l.head);
3568                 }
3569                 tvar.rank_field = r + 1;
3570             }
3571             return tvar.rank_field;
3572         }
3573         case ERROR:
3574         case NONE:
3575             return 0;
3576         default:
3577             throw new AssertionError();
3578         }
3579     }
3580     // &lt;/editor-fold&gt;
3581 
3582     /**
3583      * Helper method for generating a string representation of a given type
3584      * accordingly to a given locale
3585      */
3586     public String toString(Type t, Locale locale) {
3587         return Printer.createStandardPrinter(messages).visit(t, locale);
3588     }
3589 
3590     /**
3591      * Helper method for generating a string representation of a given type
3592      * accordingly to a given locale
3593      */
3594     public String toString(Symbol t, Locale locale) {
3595         return Printer.createStandardPrinter(messages).visit(t, locale);
3596     }
3597 
3598     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;toString&quot;&gt;
3599     /**
3600      * This toString is slightly more descriptive than the one on Type.
3601      *
3602      * @deprecated Types.toString(Type t, Locale l) provides better support
3603      * for localization
3604      */
3605     @Deprecated
3606     public String toString(Type t) {
3607         if (t.hasTag(FORALL)) {
3608             ForAll forAll = (ForAll)t;
3609             return typaramsString(forAll.tvars) + forAll.qtype;
3610         }
3611         return &quot;&quot; + t;
3612     }
3613     // where
3614         private String typaramsString(List&lt;Type&gt; tvars) {
3615             StringBuilder s = new StringBuilder();
3616             s.append(&#39;&lt;&#39;);
3617             boolean first = true;
3618             for (Type t : tvars) {
3619                 if (!first) s.append(&quot;, &quot;);
3620                 first = false;
3621                 appendTyparamString(((TypeVar)t), s);
3622             }
3623             s.append(&#39;&gt;&#39;);
3624             return s.toString();
3625         }
3626         private void appendTyparamString(TypeVar t, StringBuilder buf) {
3627             buf.append(t);
3628             if (t.getUpperBound() == null ||
3629                 t.getUpperBound().tsym.getQualifiedName() == names.java_lang_Object)
3630                 return;
3631             buf.append(&quot; extends &quot;); // Java syntax; no need for i18n
3632             Type bound = t.getUpperBound();
3633             if (!bound.isCompound()) {
3634                 buf.append(bound);
3635             } else if ((erasure(t).tsym.flags() &amp; INTERFACE) == 0) {
3636                 buf.append(supertype(t));
3637                 for (Type intf : interfaces(t)) {
3638                     buf.append(&#39;&amp;&#39;);
3639                     buf.append(intf);
3640                 }
3641             } else {
3642                 // No superclass was given in bounds.
3643                 // In this case, supertype is Object, erasure is first interface.
3644                 boolean first = true;
3645                 for (Type intf : interfaces(t)) {
3646                     if (!first) buf.append(&#39;&amp;&#39;);
3647                     first = false;
3648                     buf.append(intf);
3649                 }
3650             }
3651         }
3652     // &lt;/editor-fold&gt;
3653 
3654     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Determining least upper bounds of types&quot;&gt;
3655     /**
3656      * A cache for closures.
3657      *
3658      * &lt;p&gt;A closure is a list of all the supertypes and interfaces of
3659      * a class or interface type, ordered by ClassSymbol.precedes
3660      * (that is, subclasses come first, arbitrary but fixed
3661      * otherwise).
3662      */
3663     private Map&lt;Type,List&lt;Type&gt;&gt; closureCache = new HashMap&lt;&gt;();
3664 
3665     /**
3666      * Returns the closure of a class or interface type.
3667      */
3668     public List&lt;Type&gt; closure(Type t) {
3669         List&lt;Type&gt; cl = closureCache.get(t);
3670         if (cl == null) {
3671             Type st = supertype(t);
3672             if (!t.isCompound()) {
3673                 if (st.hasTag(CLASS)) {
3674                     cl = insert(closure(st), t);
3675                 } else if (st.hasTag(TYPEVAR)) {
3676                     cl = closure(st).prepend(t);
3677                 } else {
3678                     cl = List.of(t);
3679                 }
3680             } else {
3681                 cl = closure(supertype(t));
3682             }
3683             for (List&lt;Type&gt; l = interfaces(t); l.nonEmpty(); l = l.tail)
3684                 cl = union(cl, closure(l.head));
3685             closureCache.put(t, cl);
3686         }
3687         return cl;
3688     }
3689 
3690     /**
3691      * Collect types into a new closure (using a @code{ClosureHolder})
3692      */
3693     public Collector&lt;Type, ClosureHolder, List&lt;Type&gt;&gt; closureCollector(boolean minClosure, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3694         return Collector.of(() -&gt; new ClosureHolder(minClosure, shouldSkip),
3695                 ClosureHolder::add,
3696                 ClosureHolder::merge,
3697                 ClosureHolder::closure);
3698     }
3699     //where
3700         class ClosureHolder {
3701             List&lt;Type&gt; closure;
3702             final boolean minClosure;
3703             final BiPredicate&lt;Type, Type&gt; shouldSkip;
3704 
3705             ClosureHolder(boolean minClosure, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3706                 this.closure = List.nil();
3707                 this.minClosure = minClosure;
3708                 this.shouldSkip = shouldSkip;
3709             }
3710 
3711             void add(Type type) {
3712                 closure = insert(closure, type, shouldSkip);
3713             }
3714 
3715             ClosureHolder merge(ClosureHolder other) {
3716                 closure = union(closure, other.closure, shouldSkip);
3717                 return this;
3718             }
3719 
3720             List&lt;Type&gt; closure() {
3721                 return minClosure ? closureMin(closure) : closure;
3722             }
3723         }
3724 
3725     BiPredicate&lt;Type, Type&gt; basicClosureSkip = (t1, t2) -&gt; t1.tsym == t2.tsym;
3726 
3727     /**
3728      * Insert a type in a closure
3729      */
3730     public List&lt;Type&gt; insert(List&lt;Type&gt; cl, Type t, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3731         if (cl.isEmpty()) {
3732             return cl.prepend(t);
3733         } else if (shouldSkip.test(t, cl.head)) {
3734             return cl;
3735         } else if (t.tsym.precedes(cl.head.tsym, this)) {
3736             return cl.prepend(t);
3737         } else {
3738             // t comes after head, or the two are unrelated
3739             return insert(cl.tail, t, shouldSkip).prepend(cl.head);
3740         }
3741     }
3742 
3743     public List&lt;Type&gt; insert(List&lt;Type&gt; cl, Type t) {
3744         return insert(cl, t, basicClosureSkip);
3745     }
3746 
3747     /**
3748      * Form the union of two closures
3749      */
3750     public List&lt;Type&gt; union(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3751         if (cl1.isEmpty()) {
3752             return cl2;
3753         } else if (cl2.isEmpty()) {
3754             return cl1;
3755         } else if (shouldSkip.test(cl1.head, cl2.head)) {
3756             return union(cl1.tail, cl2.tail, shouldSkip).prepend(cl1.head);
3757         } else if (cl2.head.tsym.precedes(cl1.head.tsym, this)) {
3758             return union(cl1, cl2.tail, shouldSkip).prepend(cl2.head);
3759         } else {
3760             return union(cl1.tail, cl2, shouldSkip).prepend(cl1.head);
3761         }
3762     }
3763 
3764     public List&lt;Type&gt; union(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2) {
3765         return union(cl1, cl2, basicClosureSkip);
3766     }
3767 
3768     /**
3769      * Intersect two closures
3770      */
3771     public List&lt;Type&gt; intersect(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2) {
3772         if (cl1 == cl2)
3773             return cl1;
3774         if (cl1.isEmpty() || cl2.isEmpty())
3775             return List.nil();
3776         if (cl1.head.tsym.precedes(cl2.head.tsym, this))
3777             return intersect(cl1.tail, cl2);
3778         if (cl2.head.tsym.precedes(cl1.head.tsym, this))
3779             return intersect(cl1, cl2.tail);
3780         if (isSameType(cl1.head, cl2.head))
3781             return intersect(cl1.tail, cl2.tail).prepend(cl1.head);
3782         if (cl1.head.tsym == cl2.head.tsym &amp;&amp;
3783             cl1.head.hasTag(CLASS) &amp;&amp; cl2.head.hasTag(CLASS)) {
3784             if (cl1.head.isParameterized() &amp;&amp; cl2.head.isParameterized()) {
3785                 Type merge = merge(cl1.head,cl2.head);
3786                 return intersect(cl1.tail, cl2.tail).prepend(merge);
3787             }
3788             if (cl1.head.isRaw() || cl2.head.isRaw())
3789                 return intersect(cl1.tail, cl2.tail).prepend(erasure(cl1.head));
3790         }
3791         return intersect(cl1.tail, cl2.tail);
3792     }
3793     // where
3794         class TypePair {
3795             final Type t1;
3796             final Type t2;;
3797 
3798             TypePair(Type t1, Type t2) {
3799                 this.t1 = t1;
3800                 this.t2 = t2;
3801             }
3802             @Override
3803             public int hashCode() {
3804                 return 127 * Types.this.hashCode(t1) + Types.this.hashCode(t2);
3805             }
3806             @Override
3807             public boolean equals(Object obj) {
3808                 if (!(obj instanceof TypePair))
3809                     return false;
3810                 TypePair typePair = (TypePair)obj;
3811                 return isSameType(t1, typePair.t1)
3812                     &amp;&amp; isSameType(t2, typePair.t2);
3813             }
3814         }
3815         Set&lt;TypePair&gt; mergeCache = new HashSet&lt;&gt;();
3816         private Type merge(Type c1, Type c2) {
3817             ClassType class1 = (ClassType) c1;
3818             List&lt;Type&gt; act1 = class1.getTypeArguments();
3819             ClassType class2 = (ClassType) c2;
3820             List&lt;Type&gt; act2 = class2.getTypeArguments();
3821             ListBuffer&lt;Type&gt; merged = new ListBuffer&lt;&gt;();
3822             List&lt;Type&gt; typarams = class1.tsym.type.getTypeArguments();
3823 
3824             while (act1.nonEmpty() &amp;&amp; act2.nonEmpty() &amp;&amp; typarams.nonEmpty()) {
3825                 if (containsType(act1.head, act2.head)) {
3826                     merged.append(act1.head);
3827                 } else if (containsType(act2.head, act1.head)) {
3828                     merged.append(act2.head);
3829                 } else {
3830                     TypePair pair = new TypePair(c1, c2);
3831                     Type m;
3832                     if (mergeCache.add(pair)) {
3833                         m = new WildcardType(lub(wildUpperBound(act1.head),
3834                                                  wildUpperBound(act2.head)),
3835                                              BoundKind.EXTENDS,
3836                                              syms.boundClass);
3837                         mergeCache.remove(pair);
3838                     } else {
3839                         m = new WildcardType(syms.objectType,
3840                                              BoundKind.UNBOUND,
3841                                              syms.boundClass);
3842                     }
3843                     merged.append(m.withTypeVar(typarams.head));
3844                 }
3845                 act1 = act1.tail;
3846                 act2 = act2.tail;
3847                 typarams = typarams.tail;
3848             }
3849             Assert.check(act1.isEmpty() &amp;&amp; act2.isEmpty() &amp;&amp; typarams.isEmpty());
3850             // There is no spec detailing how type annotations are to
3851             // be inherited.  So set it to noAnnotations for now
3852             return new ClassType(class1.getEnclosingType(), merged.toList(),
3853                                  class1.tsym);
3854         }
3855 
3856     /**
3857      * Return the minimum type of a closure, a compound type if no
3858      * unique minimum exists.
3859      */
3860     private Type compoundMin(List&lt;Type&gt; cl) {
3861         if (cl.isEmpty()) return syms.objectType;
3862         List&lt;Type&gt; compound = closureMin(cl);
3863         if (compound.isEmpty())
3864             return null;
3865         else if (compound.tail.isEmpty())
3866             return compound.head;
3867         else
3868             return makeIntersectionType(compound);
3869     }
3870 
3871     /**
3872      * Return the minimum types of a closure, suitable for computing
3873      * compoundMin or glb.
3874      */
3875     private List&lt;Type&gt; closureMin(List&lt;Type&gt; cl) {
3876         ListBuffer&lt;Type&gt; classes = new ListBuffer&lt;&gt;();
3877         ListBuffer&lt;Type&gt; interfaces = new ListBuffer&lt;&gt;();
3878         Set&lt;Type&gt; toSkip = new HashSet&lt;&gt;();
3879         while (!cl.isEmpty()) {
3880             Type current = cl.head;
3881             boolean keep = !toSkip.contains(current);
3882             if (keep &amp;&amp; current.hasTag(TYPEVAR)) {
3883                 // skip lower-bounded variables with a subtype in cl.tail
3884                 for (Type t : cl.tail) {
3885                     if (isSubtypeNoCapture(t, current)) {
3886                         keep = false;
3887                         break;
3888                     }
3889                 }
3890             }
3891             if (keep) {
3892                 if (current.isInterface())
3893                     interfaces.append(current);
3894                 else
3895                     classes.append(current);
3896                 for (Type t : cl.tail) {
3897                     // skip supertypes of &#39;current&#39; in cl.tail
3898                     if (isSubtypeNoCapture(current, t))
3899                         toSkip.add(t);
3900                 }
3901             }
3902             cl = cl.tail;
3903         }
3904         return classes.appendList(interfaces).toList();
3905     }
3906 
3907     /**
3908      * Return the least upper bound of list of types.  if the lub does
3909      * not exist return null.
3910      */
3911     public Type lub(List&lt;Type&gt; ts) {
3912         return lub(ts.toArray(new Type[ts.length()]));
3913     }
3914 
3915     /**
3916      * Return the least upper bound (lub) of set of types.  If the lub
3917      * does not exist return the type of null (bottom).
3918      */
3919     public Type lub(Type... ts) {
3920         final int UNKNOWN_BOUND = 0;
3921         final int ARRAY_BOUND = 1;
3922         final int CLASS_BOUND = 2;
3923 
3924         int[] kinds = new int[ts.length];
3925 
3926         int boundkind = UNKNOWN_BOUND;
3927         for (int i = 0 ; i &lt; ts.length ; i++) {
3928             Type t = ts[i];
3929             switch (t.getTag()) {
3930             case CLASS:
3931                 boundkind |= kinds[i] = CLASS_BOUND;
3932                 break;
3933             case ARRAY:
3934                 boundkind |= kinds[i] = ARRAY_BOUND;
3935                 break;
3936             case  TYPEVAR:
3937                 do {
3938                     t = t.getUpperBound();
3939                 } while (t.hasTag(TYPEVAR));
3940                 if (t.hasTag(ARRAY)) {
3941                     boundkind |= kinds[i] = ARRAY_BOUND;
3942                 } else {
3943                     boundkind |= kinds[i] = CLASS_BOUND;
3944                 }
3945                 break;
3946             default:
3947                 kinds[i] = UNKNOWN_BOUND;
3948                 if (t.isPrimitive())
3949                     return syms.errType;
3950             }
3951         }
3952         switch (boundkind) {
3953         case 0:
3954             return syms.botType;
3955 
3956         case ARRAY_BOUND:
3957             // calculate lub(A[], B[])
3958             Type[] elements = new Type[ts.length];
3959             for (int i = 0 ; i &lt; ts.length ; i++) {
3960                 Type elem = elements[i] = elemTypeFun.apply(ts[i]);
3961                 if (elem.isPrimitive()) {
3962                     // if a primitive type is found, then return
3963                     // arraySuperType unless all the types are the
3964                     // same
3965                     Type first = ts[0];
3966                     for (int j = 1 ; j &lt; ts.length ; j++) {
3967                         if (!isSameType(first, ts[j])) {
3968                              // lub(int[], B[]) is Cloneable &amp; Serializable
3969                             return arraySuperType();
3970                         }
3971                     }
3972                     // all the array types are the same, return one
3973                     // lub(int[], int[]) is int[]
3974                     return first;
3975                 }
3976             }
3977             // lub(A[], B[]) is lub(A, B)[]
3978             return new ArrayType(lub(elements), syms.arrayClass);
3979 
3980         case CLASS_BOUND:
3981             // calculate lub(A, B)
3982             int startIdx = 0;
3983             for (int i = 0; i &lt; ts.length ; i++) {
3984                 Type t = ts[i];
3985                 if (t.hasTag(CLASS) || t.hasTag(TYPEVAR)) {
3986                     break;
3987                 } else {
3988                     startIdx++;
3989                 }
3990             }
3991             Assert.check(startIdx &lt; ts.length);
3992             //step 1 - compute erased candidate set (EC)
3993             List&lt;Type&gt; cl = erasedSupertypes(ts[startIdx]);
3994             for (int i = startIdx + 1 ; i &lt; ts.length ; i++) {
3995                 Type t = ts[i];
3996                 if (t.hasTag(CLASS) || t.hasTag(TYPEVAR))
3997                     cl = intersect(cl, erasedSupertypes(t));
3998             }
3999             //step 2 - compute minimal erased candidate set (MEC)
4000             List&lt;Type&gt; mec = closureMin(cl);
4001             //step 3 - for each element G in MEC, compute lci(Inv(G))
4002             List&lt;Type&gt; candidates = List.nil();
4003             for (Type erasedSupertype : mec) {
4004                 List&lt;Type&gt; lci = List.of(asSuper(ts[startIdx], erasedSupertype.tsym));
4005                 for (int i = startIdx + 1 ; i &lt; ts.length ; i++) {
4006                     Type superType = asSuper(ts[i], erasedSupertype.tsym);
4007                     lci = intersect(lci, superType != null ? List.of(superType) : List.nil());
4008                 }
4009                 candidates = candidates.appendList(lci);
4010             }
4011             //step 4 - let MEC be { G1, G2 ... Gn }, then we have that
4012             //lub = lci(Inv(G1)) &amp; lci(Inv(G2)) &amp; ... &amp; lci(Inv(Gn))
4013             return compoundMin(candidates);
4014 
4015         default:
4016             // calculate lub(A, B[])
4017             List&lt;Type&gt; classes = List.of(arraySuperType());
4018             for (int i = 0 ; i &lt; ts.length ; i++) {
4019                 if (kinds[i] != ARRAY_BOUND) // Filter out any arrays
4020                     classes = classes.prepend(ts[i]);
4021             }
4022             // lub(A, B[]) is lub(A, arraySuperType)
4023             return lub(classes);
4024         }
4025     }
4026     // where
4027         List&lt;Type&gt; erasedSupertypes(Type t) {
4028             ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
4029             for (Type sup : closure(t)) {
4030                 if (sup.hasTag(TYPEVAR)) {
4031                     buf.append(sup);
4032                 } else {
4033                     buf.append(erasure(sup));
4034                 }
4035             }
4036             return buf.toList();
4037         }
4038 
4039         private Type arraySuperType = null;
4040         private Type arraySuperType() {
4041             // initialized lazily to avoid problems during compiler startup
4042             if (arraySuperType == null) {
4043                 synchronized (this) {
4044                     if (arraySuperType == null) {
4045                         // JLS 10.8: all arrays implement Cloneable and Serializable.
4046                         arraySuperType = makeIntersectionType(List.of(syms.serializableType,
4047                                 syms.cloneableType), true);
4048                     }
4049                 }
4050             }
4051             return arraySuperType;
4052         }
4053     // &lt;/editor-fold&gt;
4054 
4055     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Greatest lower bound&quot;&gt;
4056     public Type glb(List&lt;Type&gt; ts) {
4057         Type t1 = ts.head;
4058         for (Type t2 : ts.tail) {
4059             if (t1.isErroneous())
4060                 return t1;
4061             t1 = glb(t1, t2);
4062         }
4063         return t1;
4064     }
4065     //where
4066     public Type glb(Type t, Type s) {
4067         if (s == null)
4068             return t;
4069         else if (t.isPrimitive() || s.isPrimitive())
4070             return syms.errType;
4071         else if (isSubtypeNoCapture(t, s))
4072             return t;
4073         else if (isSubtypeNoCapture(s, t))
4074             return s;
4075 
4076         List&lt;Type&gt; closure = union(closure(t), closure(s));
4077         return glbFlattened(closure, t);
4078     }
4079     //where
4080     /**
4081      * Perform glb for a list of non-primitive, non-error, non-compound types;
4082      * redundant elements are removed.  Bounds should be ordered according to
4083      * {@link Symbol#precedes(TypeSymbol,Types)}.
4084      *
4085      * @param flatBounds List of type to glb
4086      * @param errT Original type to use if the result is an error type
4087      */
4088     private Type glbFlattened(List&lt;Type&gt; flatBounds, Type errT) {
4089         List&lt;Type&gt; bounds = closureMin(flatBounds);
4090 
4091         if (bounds.isEmpty()) {             // length == 0
4092             return syms.objectType;
4093         } else if (bounds.tail.isEmpty()) { // length == 1
4094             return bounds.head;
4095         } else {                            // length &gt; 1
4096             int classCount = 0;
4097             List&lt;Type&gt; cvars = List.nil();
4098             List&lt;Type&gt; lowers = List.nil();
4099             for (Type bound : bounds) {
4100                 if (!bound.isInterface()) {
4101                     classCount++;
4102                     Type lower = cvarLowerBound(bound);
4103                     if (bound != lower &amp;&amp; !lower.hasTag(BOT)) {
4104                         cvars = cvars.append(bound);
4105                         lowers = lowers.append(lower);
4106                     }
4107                 }
4108             }
4109             if (classCount &gt; 1) {
4110                 if (lowers.isEmpty()) {
4111                     return createErrorType(errT);
4112                 } else {
4113                     // try again with lower bounds included instead of capture variables
4114                     List&lt;Type&gt; newBounds = bounds.diff(cvars).appendList(lowers);
4115                     return glb(newBounds);
4116                 }
4117             }
4118         }
4119         return makeIntersectionType(bounds);
4120     }
4121     // &lt;/editor-fold&gt;
4122 
4123     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;hashCode&quot;&gt;
4124     /**
4125      * Compute a hash code on a type.
4126      */
4127     public int hashCode(Type t) {
4128         return hashCode(t, false);
4129     }
4130 
4131     public int hashCode(Type t, boolean strict) {
4132         return strict ?
4133                 hashCodeStrictVisitor.visit(t) :
4134                 hashCodeVisitor.visit(t);
4135     }
4136     // where
4137         private static final HashCodeVisitor hashCodeVisitor = new HashCodeVisitor();
4138         private static final HashCodeVisitor hashCodeStrictVisitor = new HashCodeVisitor() {
4139             @Override
4140             public Integer visitTypeVar(TypeVar t, Void ignored) {
4141                 return System.identityHashCode(t);
4142             }
4143         };
4144 
4145         private static class HashCodeVisitor extends UnaryVisitor&lt;Integer&gt; {
4146             public Integer visitType(Type t, Void ignored) {
4147                 return t.getTag().ordinal();
4148             }
4149 
4150             @Override
4151             public Integer visitClassType(ClassType t, Void ignored) {
4152                 int result = visit(t.getEnclosingType());
4153                 result *= 127;
4154                 result += t.tsym.flatName().hashCode();
4155                 for (Type s : t.getTypeArguments()) {
4156                     result *= 127;
4157                     result += visit(s);
4158                 }
4159                 return result;
4160             }
4161 
4162             @Override
4163             public Integer visitMethodType(MethodType t, Void ignored) {
4164                 int h = METHOD.ordinal();
4165                 for (List&lt;Type&gt; thisargs = t.argtypes;
4166                      thisargs.tail != null;
4167                      thisargs = thisargs.tail)
4168                     h = (h &lt;&lt; 5) + visit(thisargs.head);
4169                 return (h &lt;&lt; 5) + visit(t.restype);
4170             }
4171 
4172             @Override
4173             public Integer visitWildcardType(WildcardType t, Void ignored) {
4174                 int result = t.kind.hashCode();
4175                 if (t.type != null) {
4176                     result *= 127;
4177                     result += visit(t.type);
4178                 }
4179                 return result;
4180             }
4181 
4182             @Override
4183             public Integer visitArrayType(ArrayType t, Void ignored) {
4184                 return visit(t.elemtype) + 12;
4185             }
4186 
4187             @Override
4188             public Integer visitTypeVar(TypeVar t, Void ignored) {
4189                 return System.identityHashCode(t);
4190             }
4191 
4192             @Override
4193             public Integer visitUndetVar(UndetVar t, Void ignored) {
4194                 return System.identityHashCode(t);
4195             }
4196 
4197             @Override
4198             public Integer visitErrorType(ErrorType t, Void ignored) {
4199                 return 0;
4200             }
4201         }
4202     // &lt;/editor-fold&gt;
4203 
4204     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Return-Type-Substitutable&quot;&gt;
4205     /**
4206      * Does t have a result that is a subtype of the result type of s,
4207      * suitable for covariant returns?  It is assumed that both types
4208      * are (possibly polymorphic) method types.  Monomorphic method
4209      * types are handled in the obvious way.  Polymorphic method types
4210      * require renaming all type variables of one to corresponding
4211      * type variables in the other, where correspondence is by
4212      * position in the type parameter list. */
4213     public boolean resultSubtype(Type t, Type s, Warner warner) {
4214         List&lt;Type&gt; tvars = t.getTypeArguments();
4215         List&lt;Type&gt; svars = s.getTypeArguments();
4216         Type tres = t.getReturnType();
4217         Type sres = subst(s.getReturnType(), svars, tvars);
4218         return covariantReturnType(tres, sres, warner);
4219     }
4220 
4221     /**
4222      * Return-Type-Substitutable.
4223      * @jls 8.4.5 Method Result
4224      */
4225     public boolean returnTypeSubstitutable(Type r1, Type r2) {
4226         if (hasSameArgs(r1, r2))
4227             return resultSubtype(r1, r2, noWarnings);
4228         else
4229             return covariantReturnType(r1.getReturnType(),
4230                                        erasure(r2.getReturnType()),
4231                                        noWarnings);
4232     }
4233 
4234     public boolean returnTypeSubstitutable(Type r1,
4235                                            Type r2, Type r2res,
4236                                            Warner warner) {
4237         if (isSameType(r1.getReturnType(), r2res))
4238             return true;
4239         if (r1.getReturnType().isPrimitive() || r2res.isPrimitive())
4240             return false;
4241 
4242         if (hasSameArgs(r1, r2))
4243             return covariantReturnType(r1.getReturnType(), r2res, warner);
4244         if (isSubtypeUnchecked(r1.getReturnType(), r2res, warner))
4245             return true;
4246         if (!isSubtype(r1.getReturnType(), erasure(r2res)))
4247             return false;
4248         warner.warn(LintCategory.UNCHECKED);
4249         return true;
4250     }
4251 
4252     /**
4253      * Is t an appropriate return type in an overrider for a
4254      * method that returns s?
4255      */
4256     public boolean covariantReturnType(Type t, Type s, Warner warner) {
4257         return
4258             isSameType(t, s) ||
4259             !t.isPrimitive() &amp;&amp;
4260             !s.isPrimitive() &amp;&amp;
4261             isAssignable(t, s, warner);
4262     }
4263     // &lt;/editor-fold&gt;
4264 
4265     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Box/unbox support&quot;&gt;
4266     /**
4267      * Return the class that boxes the given primitive.
4268      */
4269     public ClassSymbol boxedClass(Type t) {
4270         return syms.enterClass(syms.java_base, syms.boxedName[t.getTag().ordinal()]);
4271     }
4272 
4273     /**
4274      * Return the boxed type if &#39;t&#39; is primitive, otherwise return &#39;t&#39; itself.
4275      */
4276     public Type boxedTypeOrType(Type t) {
4277         return t.isPrimitive() ?
4278             boxedClass(t).type :
4279             t;
4280     }
4281 
4282     /**
4283      * Return the primitive type corresponding to a boxed type.
4284      */
4285     public Type unboxedType(Type t) {
4286         for (int i=0; i&lt;syms.boxedName.length; i++) {
4287             Name box = syms.boxedName[i];
4288             if (box != null &amp;&amp;
4289                 asSuper(t, syms.enterClass(syms.java_base, box)) != null)
4290                 return syms.typeOfTag[i];
4291         }
4292         return Type.noType;
4293     }
4294 
4295     /**
4296      * Return the unboxed type if &#39;t&#39; is a boxed class, otherwise return &#39;t&#39; itself.
4297      */
4298     public Type unboxedTypeOrType(Type t) {
4299         Type unboxedType = unboxedType(t);
4300         return unboxedType.hasTag(NONE) ? t : unboxedType;
4301     }
4302     // &lt;/editor-fold&gt;
4303 
4304     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Capture conversion&quot;&gt;
4305     /*
4306      * JLS 5.1.10 Capture Conversion:
4307      *
4308      * Let G name a generic type declaration with n formal type
4309      * parameters A1 ... An with corresponding bounds U1 ... Un. There
4310      * exists a capture conversion from G&lt;T1 ... Tn&gt; to G&lt;S1 ... Sn&gt;,
4311      * where, for 1 &lt;= i &lt;= n:
4312      *
4313      * + If Ti is a wildcard type argument (4.5.1) of the form ? then
4314      *   Si is a fresh type variable whose upper bound is
4315      *   Ui[A1 := S1, ..., An := Sn] and whose lower bound is the null
4316      *   type.
4317      *
4318      * + If Ti is a wildcard type argument of the form ? extends Bi,
4319      *   then Si is a fresh type variable whose upper bound is
4320      *   glb(Bi, Ui[A1 := S1, ..., An := Sn]) and whose lower bound is
4321      *   the null type, where glb(V1,... ,Vm) is V1 &amp; ... &amp; Vm. It is
4322      *   a compile-time error if for any two classes (not interfaces)
4323      *   Vi and Vj,Vi is not a subclass of Vj or vice versa.
4324      *
4325      * + If Ti is a wildcard type argument of the form ? super Bi,
4326      *   then Si is a fresh type variable whose upper bound is
4327      *   Ui[A1 := S1, ..., An := Sn] and whose lower bound is Bi.
4328      *
4329      * + Otherwise, Si = Ti.
4330      *
4331      * Capture conversion on any type other than a parameterized type
4332      * (4.5) acts as an identity conversion (5.1.1). Capture
4333      * conversions never require a special action at run time and
4334      * therefore never throw an exception at run time.
4335      *
4336      * Capture conversion is not applied recursively.
4337      */
4338     /**
4339      * Capture conversion as specified by the JLS.
4340      */
4341 
4342     public List&lt;Type&gt; capture(List&lt;Type&gt; ts) {
4343         List&lt;Type&gt; buf = List.nil();
4344         for (Type t : ts) {
4345             buf = buf.prepend(capture(t));
4346         }
4347         return buf.reverse();
4348     }
4349 
4350     public Type capture(Type t) {
4351         if (!t.hasTag(CLASS)) {
4352             return t;
4353         }
4354         if (t.getEnclosingType() != Type.noType) {
4355             Type capturedEncl = capture(t.getEnclosingType());
4356             if (capturedEncl != t.getEnclosingType()) {
4357                 Type type1 = memberType(capturedEncl, t.tsym);
4358                 t = subst(type1, t.tsym.type.getTypeArguments(), t.getTypeArguments());
4359             }
4360         }
4361         ClassType cls = (ClassType)t;
4362         if (cls.isRaw() || !cls.isParameterized())
4363             return cls;
4364 
4365         ClassType G = (ClassType)cls.asElement().asType();
4366         List&lt;Type&gt; A = G.getTypeArguments();
4367         List&lt;Type&gt; T = cls.getTypeArguments();
4368         List&lt;Type&gt; S = freshTypeVariables(T);
4369 
4370         List&lt;Type&gt; currentA = A;
4371         List&lt;Type&gt; currentT = T;
4372         List&lt;Type&gt; currentS = S;
4373         boolean captured = false;
4374         while (!currentA.isEmpty() &amp;&amp;
4375                !currentT.isEmpty() &amp;&amp;
4376                !currentS.isEmpty()) {
4377             if (currentS.head != currentT.head) {
4378                 captured = true;
4379                 WildcardType Ti = (WildcardType)currentT.head;
4380                 Type Ui = currentA.head.getUpperBound();
4381                 CapturedType Si = (CapturedType)currentS.head;
4382                 if (Ui == null)
4383                     Ui = syms.objectType;
4384                 switch (Ti.kind) {
4385                 case UNBOUND:
4386                     Si.setUpperBound( subst(Ui, A, S) );
4387                     Si.lower = syms.botType;
4388                     break;
4389                 case EXTENDS:
4390                     Si.setUpperBound( glb(Ti.getExtendsBound(), subst(Ui, A, S)) );
4391                     Si.lower = syms.botType;
4392                     break;
4393                 case SUPER:
4394                     Si.setUpperBound( subst(Ui, A, S) );
4395                     Si.lower = Ti.getSuperBound();
4396                     break;
4397                 }
4398                 Type tmpBound = Si.getUpperBound().hasTag(UNDETVAR) ? ((UndetVar)Si.getUpperBound()).qtype : Si.getUpperBound();
4399                 Type tmpLower = Si.lower.hasTag(UNDETVAR) ? ((UndetVar)Si.lower).qtype : Si.lower;
4400                 if (!Si.getUpperBound().hasTag(ERROR) &amp;&amp;
4401                     !Si.lower.hasTag(ERROR) &amp;&amp;
4402                     isSameType(tmpBound, tmpLower)) {
4403                     currentS.head = Si.getUpperBound();
4404                 }
4405             }
4406             currentA = currentA.tail;
4407             currentT = currentT.tail;
4408             currentS = currentS.tail;
4409         }
4410         if (!currentA.isEmpty() || !currentT.isEmpty() || !currentS.isEmpty())
4411             return erasure(t); // some &quot;rare&quot; type involved
4412 
4413         if (captured)
4414             return new ClassType(cls.getEnclosingType(), S, cls.tsym,
4415                                  cls.getMetadata());
4416         else
4417             return t;
4418     }
4419     // where
4420         public List&lt;Type&gt; freshTypeVariables(List&lt;Type&gt; types) {
4421             ListBuffer&lt;Type&gt; result = new ListBuffer&lt;&gt;();
4422             for (Type t : types) {
4423                 if (t.hasTag(WILDCARD)) {
4424                     Type bound = ((WildcardType)t).getExtendsBound();
4425                     if (bound == null)
4426                         bound = syms.objectType;
4427                     result.append(new CapturedType(capturedName,
4428                                                    syms.noSymbol,
4429                                                    bound,
4430                                                    syms.botType,
4431                                                    (WildcardType)t));
4432                 } else {
4433                     result.append(t);
4434                 }
4435             }
4436             return result.toList();
4437         }
4438     // &lt;/editor-fold&gt;
4439 
4440     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Internal utility methods&quot;&gt;
4441     private boolean sideCast(Type from, Type to, Warner warn) {
4442         // We are casting from type $from$ to type $to$, which are
4443         // non-final unrelated types.  This method
4444         // tries to reject a cast by transferring type parameters
4445         // from $to$ to $from$ by common superinterfaces.
4446         boolean reverse = false;
4447         Type target = to;
4448         if ((to.tsym.flags() &amp; INTERFACE) == 0) {
4449             Assert.check((from.tsym.flags() &amp; INTERFACE) != 0);
4450             reverse = true;
4451             to = from;
4452             from = target;
4453         }
4454         List&lt;Type&gt; commonSupers = superClosure(to, erasure(from));
4455         boolean giveWarning = commonSupers.isEmpty();
4456         // The arguments to the supers could be unified here to
4457         // get a more accurate analysis
4458         while (commonSupers.nonEmpty()) {
4459             Type t1 = asSuper(from, commonSupers.head.tsym);
4460             Type t2 = commonSupers.head; // same as asSuper(to, commonSupers.head.tsym);
4461             if (disjointTypes(t1.getTypeArguments(), t2.getTypeArguments()))
4462                 return false;
4463             giveWarning = giveWarning || (reverse ? giveWarning(t2, t1) : giveWarning(t1, t2));
4464             commonSupers = commonSupers.tail;
4465         }
4466         if (giveWarning &amp;&amp; !isReifiable(reverse ? from : to))
4467             warn.warn(LintCategory.UNCHECKED);
4468         return true;
4469     }
4470 
4471     private boolean sideCastFinal(Type from, Type to, Warner warn) {
4472         // We are casting from type $from$ to type $to$, which are
4473         // unrelated types one of which is final and the other of
4474         // which is an interface.  This method
4475         // tries to reject a cast by transferring type parameters
4476         // from the final class to the interface.
4477         boolean reverse = false;
4478         Type target = to;
4479         if ((to.tsym.flags() &amp; INTERFACE) == 0) {
4480             Assert.check((from.tsym.flags() &amp; INTERFACE) != 0);
4481             reverse = true;
4482             to = from;
4483             from = target;
4484         }
4485         Assert.check((from.tsym.flags() &amp; FINAL) != 0);
4486         Type t1 = asSuper(from, to.tsym);
4487         if (t1 == null) return false;
4488         Type t2 = to;
4489         if (disjointTypes(t1.getTypeArguments(), t2.getTypeArguments()))
4490             return false;
4491         if (!isReifiable(target) &amp;&amp;
4492             (reverse ? giveWarning(t2, t1) : giveWarning(t1, t2)))
4493             warn.warn(LintCategory.UNCHECKED);
4494         return true;
4495     }
4496 
4497     private boolean giveWarning(Type from, Type to) {
4498         List&lt;Type&gt; bounds = to.isCompound() ?
4499                 directSupertypes(to) : List.of(to);
4500         for (Type b : bounds) {
4501             Type subFrom = asSub(from, b.tsym);
4502             if (b.isParameterized() &amp;&amp;
4503                     (!(isUnbounded(b) ||
4504                     isSubtype(from, b) ||
4505                     ((subFrom != null) &amp;&amp; containsType(b.allparams(), subFrom.allparams()))))) {
4506                 return true;
4507             }
4508         }
4509         return false;
4510     }
4511 
4512     private List&lt;Type&gt; superClosure(Type t, Type s) {
4513         List&lt;Type&gt; cl = List.nil();
4514         for (List&lt;Type&gt; l = interfaces(t); l.nonEmpty(); l = l.tail) {
4515             if (isSubtype(s, erasure(l.head))) {
4516                 cl = insert(cl, l.head);
4517             } else {
4518                 cl = union(cl, superClosure(l.head, s));
4519             }
4520         }
4521         return cl;
4522     }
4523 
4524     private boolean containsTypeEquivalent(Type t, Type s) {
4525         return isSameType(t, s) || // shortcut
4526             containsType(t, s) &amp;&amp; containsType(s, t);
4527     }
4528 
4529     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;adapt&quot;&gt;
4530     /**
4531      * Adapt a type by computing a substitution which maps a source
4532      * type to a target type.
4533      *
4534      * @param source    the source type
4535      * @param target    the target type
4536      * @param from      the type variables of the computed substitution
4537      * @param to        the types of the computed substitution.
4538      */
4539     public void adapt(Type source,
4540                        Type target,
4541                        ListBuffer&lt;Type&gt; from,
4542                        ListBuffer&lt;Type&gt; to) throws AdaptFailure {
4543         new Adapter(from, to).adapt(source, target);
4544     }
4545 
4546     class Adapter extends SimpleVisitor&lt;Void, Type&gt; {
4547 
4548         ListBuffer&lt;Type&gt; from;
4549         ListBuffer&lt;Type&gt; to;
4550         Map&lt;Symbol,Type&gt; mapping;
4551 
4552         Adapter(ListBuffer&lt;Type&gt; from, ListBuffer&lt;Type&gt; to) {
4553             this.from = from;
4554             this.to = to;
4555             mapping = new HashMap&lt;&gt;();
4556         }
4557 
4558         public void adapt(Type source, Type target) throws AdaptFailure {
4559             visit(source, target);
4560             List&lt;Type&gt; fromList = from.toList();
4561             List&lt;Type&gt; toList = to.toList();
4562             while (!fromList.isEmpty()) {
4563                 Type val = mapping.get(fromList.head.tsym);
4564                 if (toList.head != val)
4565                     toList.head = val;
4566                 fromList = fromList.tail;
4567                 toList = toList.tail;
4568             }
4569         }
4570 
4571         @Override
4572         public Void visitClassType(ClassType source, Type target) throws AdaptFailure {
4573             if (target.hasTag(CLASS))
4574                 adaptRecursive(source.allparams(), target.allparams());
4575             return null;
4576         }
4577 
4578         @Override
4579         public Void visitArrayType(ArrayType source, Type target) throws AdaptFailure {
4580             if (target.hasTag(ARRAY))
4581                 adaptRecursive(elemtype(source), elemtype(target));
4582             return null;
4583         }
4584 
4585         @Override
4586         public Void visitWildcardType(WildcardType source, Type target) throws AdaptFailure {
4587             if (source.isExtendsBound())
4588                 adaptRecursive(wildUpperBound(source), wildUpperBound(target));
4589             else if (source.isSuperBound())
4590                 adaptRecursive(wildLowerBound(source), wildLowerBound(target));
4591             return null;
4592         }
4593 
4594         @Override
4595         public Void visitTypeVar(TypeVar source, Type target) throws AdaptFailure {
4596             // Check to see if there is
4597             // already a mapping for $source$, in which case
4598             // the old mapping will be merged with the new
4599             Type val = mapping.get(source.tsym);
4600             if (val != null) {
4601                 if (val.isSuperBound() &amp;&amp; target.isSuperBound()) {
4602                     val = isSubtype(wildLowerBound(val), wildLowerBound(target))
4603                         ? target : val;
4604                 } else if (val.isExtendsBound() &amp;&amp; target.isExtendsBound()) {
4605                     val = isSubtype(wildUpperBound(val), wildUpperBound(target))
4606                         ? val : target;
4607                 } else if (!isSameType(val, target)) {
4608                     throw new AdaptFailure();
4609                 }
4610             } else {
4611                 val = target;
4612                 from.append(source);
4613                 to.append(target);
4614             }
4615             mapping.put(source.tsym, val);
4616             return null;
4617         }
4618 
4619         @Override
4620         public Void visitType(Type source, Type target) {
4621             return null;
4622         }
4623 
4624         private Set&lt;TypePair&gt; cache = new HashSet&lt;&gt;();
4625 
4626         private void adaptRecursive(Type source, Type target) {
4627             TypePair pair = new TypePair(source, target);
4628             if (cache.add(pair)) {
4629                 try {
4630                     visit(source, target);
4631                 } finally {
4632                     cache.remove(pair);
4633                 }
4634             }
4635         }
4636 
4637         private void adaptRecursive(List&lt;Type&gt; source, List&lt;Type&gt; target) {
4638             if (source.length() == target.length()) {
4639                 while (source.nonEmpty()) {
4640                     adaptRecursive(source.head, target.head);
4641                     source = source.tail;
4642                     target = target.tail;
4643                 }
4644             }
4645         }
4646     }
4647 
4648     public static class AdaptFailure extends RuntimeException {
4649         static final long serialVersionUID = -7490231548272701566L;
4650     }
4651 
4652     private void adaptSelf(Type t,
4653                            ListBuffer&lt;Type&gt; from,
4654                            ListBuffer&lt;Type&gt; to) {
4655         try {
4656             //if (t.tsym.type != t)
4657                 adapt(t.tsym.type, t, from, to);
4658         } catch (AdaptFailure ex) {
4659             // Adapt should never fail calculating a mapping from
4660             // t.tsym.type to t as there can be no merge problem.
4661             throw new AssertionError(ex);
4662         }
4663     }
4664     // &lt;/editor-fold&gt;
4665 
4666     /**
4667      * Rewrite all type variables (universal quantifiers) in the given
4668      * type to wildcards (existential quantifiers).  This is used to
4669      * determine if a cast is allowed.  For example, if high is true
4670      * and {@code T &lt;: Number}, then {@code List&lt;T&gt;} is rewritten to
4671      * {@code List&lt;?  extends Number&gt;}.  Since {@code List&lt;Integer&gt; &lt;:
4672      * List&lt;? extends Number&gt;} a {@code List&lt;T&gt;} can be cast to {@code
4673      * List&lt;Integer&gt;} with a warning.
4674      * @param t a type
4675      * @param high if true return an upper bound; otherwise a lower
4676      * bound
4677      * @param rewriteTypeVars only rewrite captured wildcards if false;
4678      * otherwise rewrite all type variables
4679      * @return the type rewritten with wildcards (existential
4680      * quantifiers) only
4681      */
4682     private Type rewriteQuantifiers(Type t, boolean high, boolean rewriteTypeVars) {
4683         return new Rewriter(high, rewriteTypeVars).visit(t);
4684     }
4685 
4686     class Rewriter extends UnaryVisitor&lt;Type&gt; {
4687 
4688         boolean high;
4689         boolean rewriteTypeVars;
4690 
4691         Rewriter(boolean high, boolean rewriteTypeVars) {
4692             this.high = high;
4693             this.rewriteTypeVars = rewriteTypeVars;
4694         }
4695 
4696         @Override
4697         public Type visitClassType(ClassType t, Void s) {
4698             ListBuffer&lt;Type&gt; rewritten = new ListBuffer&lt;&gt;();
4699             boolean changed = false;
4700             for (Type arg : t.allparams()) {
4701                 Type bound = visit(arg);
4702                 if (arg != bound) {
4703                     changed = true;
4704                 }
4705                 rewritten.append(bound);
4706             }
4707             if (changed)
4708                 return subst(t.tsym.type,
4709                         t.tsym.type.allparams(),
4710                         rewritten.toList());
4711             else
4712                 return t;
4713         }
4714 
4715         public Type visitType(Type t, Void s) {
4716             return t;
4717         }
4718 
4719         @Override
4720         public Type visitCapturedType(CapturedType t, Void s) {
4721             Type w_bound = t.wildcard.type;
4722             Type bound = w_bound.contains(t) ?
4723                         erasure(w_bound) :
4724                         visit(w_bound);
4725             return rewriteAsWildcardType(visit(bound), t.wildcard.bound, t.wildcard.kind);
4726         }
4727 
4728         @Override
4729         public Type visitTypeVar(TypeVar t, Void s) {
4730             if (rewriteTypeVars) {
4731                 Type bound = t.getUpperBound().contains(t) ?
4732                         erasure(t.getUpperBound()) :
4733                         visit(t.getUpperBound());
4734                 return rewriteAsWildcardType(bound, t, EXTENDS);
4735             } else {
4736                 return t;
4737             }
4738         }
4739 
4740         @Override
4741         public Type visitWildcardType(WildcardType t, Void s) {
4742             Type bound2 = visit(t.type);
4743             return t.type == bound2 ? t : rewriteAsWildcardType(bound2, t.bound, t.kind);
4744         }
4745 
4746         private Type rewriteAsWildcardType(Type bound, TypeVar formal, BoundKind bk) {
4747             switch (bk) {
4748                case EXTENDS: return high ?
4749                        makeExtendsWildcard(B(bound), formal) :
4750                        makeExtendsWildcard(syms.objectType, formal);
4751                case SUPER: return high ?
4752                        makeSuperWildcard(syms.botType, formal) :
4753                        makeSuperWildcard(B(bound), formal);
4754                case UNBOUND: return makeExtendsWildcard(syms.objectType, formal);
4755                default:
4756                    Assert.error(&quot;Invalid bound kind &quot; + bk);
4757                    return null;
4758             }
4759         }
4760 
4761         Type B(Type t) {
4762             while (t.hasTag(WILDCARD)) {
4763                 WildcardType w = (WildcardType)t;
4764                 t = high ?
4765                     w.getExtendsBound() :
4766                     w.getSuperBound();
4767                 if (t == null) {
4768                     t = high ? syms.objectType : syms.botType;
4769                 }
4770             }
4771             return t;
4772         }
4773     }
4774 
4775 
4776     /**
4777      * Create a wildcard with the given upper (extends) bound; create
4778      * an unbounded wildcard if bound is Object.
4779      *
4780      * @param bound the upper bound
4781      * @param formal the formal type parameter that will be
4782      * substituted by the wildcard
4783      */
4784     private WildcardType makeExtendsWildcard(Type bound, TypeVar formal) {
4785         if (bound == syms.objectType) {
4786             return new WildcardType(syms.objectType,
4787                                     BoundKind.UNBOUND,
4788                                     syms.boundClass,
4789                                     formal);
4790         } else {
4791             return new WildcardType(bound,
4792                                     BoundKind.EXTENDS,
4793                                     syms.boundClass,
4794                                     formal);
4795         }
4796     }
4797 
4798     /**
4799      * Create a wildcard with the given lower (super) bound; create an
4800      * unbounded wildcard if bound is bottom (type of {@code null}).
4801      *
4802      * @param bound the lower bound
4803      * @param formal the formal type parameter that will be
4804      * substituted by the wildcard
4805      */
4806     private WildcardType makeSuperWildcard(Type bound, TypeVar formal) {
4807         if (bound.hasTag(BOT)) {
4808             return new WildcardType(syms.objectType,
4809                                     BoundKind.UNBOUND,
4810                                     syms.boundClass,
4811                                     formal);
4812         } else {
4813             return new WildcardType(bound,
4814                                     BoundKind.SUPER,
4815                                     syms.boundClass,
4816                                     formal);
4817         }
4818     }
4819 
4820     /**
4821      * A wrapper for a type that allows use in sets.
4822      */
4823     public static class UniqueType {
4824         public final Type type;
4825         final Types types;
4826 
4827         public UniqueType(Type type, Types types) {
4828             this.type = type;
4829             this.types = types;
4830         }
4831 
4832         public int hashCode() {
4833             return types.hashCode(type);
4834         }
4835 
4836         public boolean equals(Object obj) {
4837             return (obj instanceof UniqueType) &amp;&amp;
4838                 types.isSameType(type, ((UniqueType)obj).type);
4839         }
4840 
4841         public String toString() {
4842             return type.toString();
4843         }
4844 
4845     }
4846     // &lt;/editor-fold&gt;
4847 
4848     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Visitors&quot;&gt;
4849     /**
4850      * A default visitor for types.  All visitor methods except
4851      * visitType are implemented by delegating to visitType.  Concrete
4852      * subclasses must provide an implementation of visitType and can
4853      * override other methods as needed.
4854      *
4855      * @param &lt;R&gt; the return type of the operation implemented by this
4856      * visitor; use Void if no return type is needed.
4857      * @param &lt;S&gt; the type of the second argument (the first being the
4858      * type itself) of the operation implemented by this visitor; use
4859      * Void if a second argument is not needed.
4860      */
4861     public static abstract class DefaultTypeVisitor&lt;R,S&gt; implements Type.Visitor&lt;R,S&gt; {
4862         final public R visit(Type t, S s)               { return t.accept(this, s); }
4863         public R visitClassType(ClassType t, S s)       { return visitType(t, s); }
4864         public R visitWildcardType(WildcardType t, S s) { return visitType(t, s); }
4865         public R visitArrayType(ArrayType t, S s)       { return visitType(t, s); }
4866         public R visitMethodType(MethodType t, S s)     { return visitType(t, s); }
4867         public R visitPackageType(PackageType t, S s)   { return visitType(t, s); }
4868         public R visitModuleType(ModuleType t, S s)     { return visitType(t, s); }
4869         public R visitTypeVar(TypeVar t, S s)           { return visitType(t, s); }
4870         public R visitCapturedType(CapturedType t, S s) { return visitType(t, s); }
4871         public R visitForAll(ForAll t, S s)             { return visitType(t, s); }
4872         public R visitUndetVar(UndetVar t, S s)         { return visitType(t, s); }
4873         public R visitErrorType(ErrorType t, S s)       { return visitType(t, s); }
4874     }
4875 
4876     /**
4877      * A default visitor for symbols.  All visitor methods except
4878      * visitSymbol are implemented by delegating to visitSymbol.  Concrete
4879      * subclasses must provide an implementation of visitSymbol and can
4880      * override other methods as needed.
4881      *
4882      * @param &lt;R&gt; the return type of the operation implemented by this
4883      * visitor; use Void if no return type is needed.
4884      * @param &lt;S&gt; the type of the second argument (the first being the
4885      * symbol itself) of the operation implemented by this visitor; use
4886      * Void if a second argument is not needed.
4887      */
4888     public static abstract class DefaultSymbolVisitor&lt;R,S&gt; implements Symbol.Visitor&lt;R,S&gt; {
4889         final public R visit(Symbol s, S arg)                   { return s.accept(this, arg); }
4890         public R visitClassSymbol(ClassSymbol s, S arg)         { return visitSymbol(s, arg); }
4891         public R visitMethodSymbol(MethodSymbol s, S arg)       { return visitSymbol(s, arg); }
4892         public R visitOperatorSymbol(OperatorSymbol s, S arg)   { return visitSymbol(s, arg); }
4893         public R visitPackageSymbol(PackageSymbol s, S arg)     { return visitSymbol(s, arg); }
4894         public R visitTypeSymbol(TypeSymbol s, S arg)           { return visitSymbol(s, arg); }
4895         public R visitVarSymbol(VarSymbol s, S arg)             { return visitSymbol(s, arg); }
4896     }
4897 
4898     /**
4899      * A &lt;em&gt;simple&lt;/em&gt; visitor for types.  This visitor is simple as
4900      * captured wildcards, for-all types (generic methods), and
4901      * undetermined type variables (part of inference) are hidden.
4902      * Captured wildcards are hidden by treating them as type
4903      * variables and the rest are hidden by visiting their qtypes.
4904      *
4905      * @param &lt;R&gt; the return type of the operation implemented by this
4906      * visitor; use Void if no return type is needed.
4907      * @param &lt;S&gt; the type of the second argument (the first being the
4908      * type itself) of the operation implemented by this visitor; use
4909      * Void if a second argument is not needed.
4910      */
4911     public static abstract class SimpleVisitor&lt;R,S&gt; extends DefaultTypeVisitor&lt;R,S&gt; {
4912         @Override
4913         public R visitCapturedType(CapturedType t, S s) {
4914             return visitTypeVar(t, s);
4915         }
4916         @Override
4917         public R visitForAll(ForAll t, S s) {
4918             return visit(t.qtype, s);
4919         }
4920         @Override
4921         public R visitUndetVar(UndetVar t, S s) {
4922             return visit(t.qtype, s);
4923         }
4924     }
4925 
4926     /**
4927      * A plain relation on types.  That is a 2-ary function on the
4928      * form Type&amp;nbsp;&amp;times;&amp;nbsp;Type&amp;nbsp;&amp;rarr;&amp;nbsp;Boolean.
4929      * &lt;!-- In plain text: Type x Type -&gt; Boolean --&gt;
4930      */
4931     public static abstract class TypeRelation extends SimpleVisitor&lt;Boolean,Type&gt; {}
4932 
4933     /**
4934      * A convenience visitor for implementing operations that only
4935      * require one argument (the type itself), that is, unary
4936      * operations.
4937      *
4938      * @param &lt;R&gt; the return type of the operation implemented by this
4939      * visitor; use Void if no return type is needed.
4940      */
4941     public static abstract class UnaryVisitor&lt;R&gt; extends SimpleVisitor&lt;R,Void&gt; {
4942         final public R visit(Type t) { return t.accept(this, null); }
4943     }
4944 
4945     /**
4946      * A visitor for implementing a mapping from types to types.  The
4947      * default behavior of this class is to implement the identity
4948      * mapping (mapping a type to itself).  This can be overridden in
4949      * subclasses.
4950      *
4951      * @param &lt;S&gt; the type of the second argument (the first being the
4952      * type itself) of this mapping; use Void if a second argument is
4953      * not needed.
4954      */
4955     public static class MapVisitor&lt;S&gt; extends DefaultTypeVisitor&lt;Type,S&gt; {
4956         final public Type visit(Type t) { return t.accept(this, null); }
4957         public Type visitType(Type t, S s) { return t; }
4958     }
4959 
4960     /**
4961      * An abstract class for mappings from types to types (see {@link Type#map(TypeMapping)}.
4962      * This class implements the functional interface {@code Function}, that allows it to be used
4963      * fluently in stream-like processing.
4964      */
4965     public static class TypeMapping&lt;S&gt; extends MapVisitor&lt;S&gt; implements Function&lt;Type, Type&gt; {
4966         @Override
4967         public Type apply(Type type) { return visit(type); }
4968 
4969         List&lt;Type&gt; visit(List&lt;Type&gt; ts, S s) {
4970             return ts.map(t -&gt; visit(t, s));
4971         }
4972 
4973         @Override
4974         public Type visitCapturedType(CapturedType t, S s) {
4975             return visitTypeVar(t, s);
4976         }
4977     }
4978     // &lt;/editor-fold&gt;
4979 
4980 
4981     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Annotation support&quot;&gt;
4982 
4983     public RetentionPolicy getRetention(Attribute.Compound a) {
4984         return getRetention(a.type.tsym);
4985     }
4986 
4987     public RetentionPolicy getRetention(TypeSymbol sym) {
4988         RetentionPolicy vis = RetentionPolicy.CLASS; // the default
4989         Attribute.Compound c = sym.attribute(syms.retentionType.tsym);
4990         if (c != null) {
4991             Attribute value = c.member(names.value);
4992             if (value != null &amp;&amp; value instanceof Attribute.Enum) {
4993                 Name levelName = ((Attribute.Enum)value).value.name;
4994                 if (levelName == names.SOURCE) vis = RetentionPolicy.SOURCE;
4995                 else if (levelName == names.CLASS) vis = RetentionPolicy.CLASS;
4996                 else if (levelName == names.RUNTIME) vis = RetentionPolicy.RUNTIME;
4997                 else ;// /* fail soft */ throw new AssertionError(levelName);
4998             }
4999         }
5000         return vis;
5001     }
5002     // &lt;/editor-fold&gt;
5003 
5004     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Signature Generation&quot;&gt;
5005 
5006     public static abstract class SignatureGenerator {
5007 
5008         public static class InvalidSignatureException extends RuntimeException {
5009             private static final long serialVersionUID = 0;
5010 
5011             private final transient Type type;
5012 
5013             InvalidSignatureException(Type type) {
5014                 this.type = type;
5015             }
5016 
5017             public Type type() {
5018                 return type;
5019             }
5020         }
5021 
5022         private final Types types;
5023 
5024         protected abstract void append(char ch);
5025         protected abstract void append(byte[] ba);
5026         protected abstract void append(Name name);
5027         protected void classReference(ClassSymbol c) { /* by default: no-op */ }
5028 
5029         protected SignatureGenerator(Types types) {
5030             this.types = types;
5031         }
5032 
5033         protected void reportIllegalSignature(Type t) {
5034             throw new InvalidSignatureException(t);
5035         }
5036 
5037         /**
5038          * Assemble signature of given type in string buffer.
5039          */
5040         public void assembleSig(Type type) {
5041             switch (type.getTag()) {
5042                 case BYTE:
5043                     append(&#39;B&#39;);
5044                     break;
5045                 case SHORT:
5046                     append(&#39;S&#39;);
5047                     break;
5048                 case CHAR:
5049                     append(&#39;C&#39;);
5050                     break;
5051                 case INT:
5052                     append(&#39;I&#39;);
5053                     break;
5054                 case LONG:
5055                     append(&#39;J&#39;);
5056                     break;
5057                 case FLOAT:
5058                     append(&#39;F&#39;);
5059                     break;
5060                 case DOUBLE:
5061                     append(&#39;D&#39;);
5062                     break;
5063                 case BOOLEAN:
5064                     append(&#39;Z&#39;);
5065                     break;
5066                 case VOID:
5067                     append(&#39;V&#39;);
5068                     break;
5069                 case CLASS:
5070                     if (type.isCompound()) {
5071                         reportIllegalSignature(type);
5072                     }
5073                     append(&#39;L&#39;);
5074                     assembleClassSig(type);
5075                     append(&#39;;&#39;);
5076                     break;
5077                 case ARRAY:
5078                     ArrayType at = (ArrayType) type;
5079                     append(&#39;[&#39;);
5080                     assembleSig(at.elemtype);
5081                     break;
5082                 case METHOD:
5083                     MethodType mt = (MethodType) type;
5084                     append(&#39;(&#39;);
5085                     assembleSig(mt.argtypes);
5086                     append(&#39;)&#39;);
5087                     assembleSig(mt.restype);
5088                     if (hasTypeVar(mt.thrown)) {
5089                         for (List&lt;Type&gt; l = mt.thrown; l.nonEmpty(); l = l.tail) {
5090                             append(&#39;^&#39;);
5091                             assembleSig(l.head);
5092                         }
5093                     }
5094                     break;
5095                 case WILDCARD: {
5096                     Type.WildcardType ta = (Type.WildcardType) type;
5097                     switch (ta.kind) {
5098                         case SUPER:
5099                             append(&#39;-&#39;);
5100                             assembleSig(ta.type);
5101                             break;
5102                         case EXTENDS:
5103                             append(&#39;+&#39;);
5104                             assembleSig(ta.type);
5105                             break;
5106                         case UNBOUND:
5107                             append(&#39;*&#39;);
5108                             break;
5109                         default:
5110                             throw new AssertionError(ta.kind);
5111                     }
5112                     break;
5113                 }
5114                 case TYPEVAR:
5115                     if (((TypeVar)type).isCaptured()) {
5116                         reportIllegalSignature(type);
5117                     }
5118                     append(&#39;T&#39;);
5119                     append(type.tsym.name);
5120                     append(&#39;;&#39;);
5121                     break;
5122                 case FORALL:
5123                     Type.ForAll ft = (Type.ForAll) type;
5124                     assembleParamsSig(ft.tvars);
5125                     assembleSig(ft.qtype);
5126                     break;
5127                 default:
5128                     throw new AssertionError(&quot;typeSig &quot; + type.getTag());
5129             }
5130         }
5131 
5132         public boolean hasTypeVar(List&lt;Type&gt; l) {
5133             while (l.nonEmpty()) {
5134                 if (l.head.hasTag(TypeTag.TYPEVAR)) {
5135                     return true;
5136                 }
5137                 l = l.tail;
5138             }
5139             return false;
5140         }
5141 
5142         public void assembleClassSig(Type type) {
5143             ClassType ct = (ClassType) type;
5144             ClassSymbol c = (ClassSymbol) ct.tsym;
5145             classReference(c);
5146             Type outer = ct.getEnclosingType();
5147             if (outer.allparams().nonEmpty()) {
5148                 boolean rawOuter =
5149                         c.owner.kind == MTH || // either a local class
5150                         c.name == types.names.empty; // or anonymous
5151                 assembleClassSig(rawOuter
5152                         ? types.erasure(outer)
5153                         : outer);
5154                 append(rawOuter ? &#39;$&#39; : &#39;.&#39;);
5155                 Assert.check(c.flatname.startsWith(c.owner.enclClass().flatname));
5156                 append(rawOuter
5157                         ? c.flatname.subName(c.owner.enclClass().flatname.getByteLength() + 1, c.flatname.getByteLength())
5158                         : c.name);
5159             } else {
5160                 append(externalize(c.flatname));
5161             }
5162             if (ct.getTypeArguments().nonEmpty()) {
5163                 append(&#39;&lt;&#39;);
5164                 assembleSig(ct.getTypeArguments());
5165                 append(&#39;&gt;&#39;);
5166             }
5167         }
5168 
5169         public void assembleParamsSig(List&lt;Type&gt; typarams) {
5170             append(&#39;&lt;&#39;);
5171             for (List&lt;Type&gt; ts = typarams; ts.nonEmpty(); ts = ts.tail) {
5172                 Type.TypeVar tvar = (Type.TypeVar) ts.head;
5173                 append(tvar.tsym.name);
5174                 List&lt;Type&gt; bounds = types.getBounds(tvar);
5175                 if ((bounds.head.tsym.flags() &amp; INTERFACE) != 0) {
5176                     append(&#39;:&#39;);
5177                 }
5178                 for (List&lt;Type&gt; l = bounds; l.nonEmpty(); l = l.tail) {
5179                     append(&#39;:&#39;);
5180                     assembleSig(l.head);
5181                 }
5182             }
5183             append(&#39;&gt;&#39;);
5184         }
5185 
5186         public void assembleSig(List&lt;Type&gt; types) {
5187             for (List&lt;Type&gt; ts = types; ts.nonEmpty(); ts = ts.tail) {
5188                 assembleSig(ts.head);
5189             }
5190         }
5191     }
5192 
5193     public Type constantType(LoadableConstant c) {
5194         switch (c.poolTag()) {
5195             case ClassFile.CONSTANT_Class:
5196                 return syms.classType;
5197             case ClassFile.CONSTANT_String:
5198                 return syms.stringType;
5199             case ClassFile.CONSTANT_Integer:
5200                 return syms.intType;
5201             case ClassFile.CONSTANT_Float:
5202                 return syms.floatType;
5203             case ClassFile.CONSTANT_Long:
5204                 return syms.longType;
5205             case ClassFile.CONSTANT_Double:
5206                 return syms.doubleType;
5207             case ClassFile.CONSTANT_MethodHandle:
5208                 return syms.methodHandleType;
5209             case ClassFile.CONSTANT_MethodType:
5210                 return syms.methodTypeType;
5211             case ClassFile.CONSTANT_Dynamic:
5212                 return ((DynamicVarSymbol)c).type;
5213             default:
5214                 throw new AssertionError(&quot;Not a loadable constant: &quot; + c.poolTag());
5215         }
5216     }
5217     // &lt;/editor-fold&gt;
5218 
5219     public void newRound() {
5220         descCache._map.clear();
5221         isDerivedRawCache.clear();
5222         implCache._map.clear();
5223         membersCache._map.clear();
5224         closureCache.clear();
5225     }
5226 }
    </pre>
  </body>
</html>
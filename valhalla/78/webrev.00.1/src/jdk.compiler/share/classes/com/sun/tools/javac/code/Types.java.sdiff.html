<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../doclint/Checker.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../comp/Attr.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  33 import java.util.Optional;
  34 import java.util.Set;
  35 import java.util.WeakHashMap;
  36 import java.util.function.BiPredicate;
  37 import java.util.function.Function;
  38 import java.util.stream.Collector;
  39 
  40 import javax.tools.JavaFileObject;
  41 
  42 import com.sun.tools.javac.code.Attribute.RetentionPolicy;
  43 import com.sun.tools.javac.code.Lint.LintCategory;
  44 import com.sun.tools.javac.code.Source.Feature;
  45 import com.sun.tools.javac.code.Type.UndetVar.InferenceBound;
  46 import com.sun.tools.javac.code.TypeMetadata.Entry.Kind;
  47 import com.sun.tools.javac.comp.AttrContext;
  48 import com.sun.tools.javac.comp.Check;
  49 import com.sun.tools.javac.comp.Enter;
  50 import com.sun.tools.javac.comp.Env;
  51 import com.sun.tools.javac.comp.LambdaToMethod;
  52 import com.sun.tools.javac.jvm.ClassFile;

  53 import com.sun.tools.javac.util.*;
  54 
  55 import static com.sun.tools.javac.code.BoundKind.*;
  56 import static com.sun.tools.javac.code.Flags.*;
  57 import static com.sun.tools.javac.code.Kinds.Kind.*;
  58 import static com.sun.tools.javac.code.Scope.*;
  59 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  60 import static com.sun.tools.javac.code.Symbol.*;
  61 import static com.sun.tools.javac.code.Type.*;
  62 import static com.sun.tools.javac.code.TypeTag.*;
  63 import static com.sun.tools.javac.jvm.ClassFile.externalize;
  64 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  65 
  66 /**
  67  * Utility class containing various operations on types.
  68  *
  69  * &lt;p&gt;Unless other names are more illustrative, the following naming
  70  * conventions should be observed in this file:
  71  *
  72  * &lt;dl&gt;
</pre>
<hr />
<pre>
  76  * &lt;dd&gt;Similarly, if the second argument to an operation is a type, it should be named s.&lt;/dd&gt;
  77  * &lt;dt&gt;ts&lt;/dt&gt;
  78  * &lt;dd&gt;If an operations takes a list of types, the first should be named ts.&lt;/dd&gt;
  79  * &lt;dt&gt;ss&lt;/dt&gt;
  80  * &lt;dd&gt;A second list of types should be named ss.&lt;/dd&gt;
  81  * &lt;/dl&gt;
  82  *
  83  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  84  * If you write code that depends on this, you do so at your own risk.
  85  * This code and its internal interfaces are subject to change or
  86  * deletion without notice.&lt;/b&gt;
  87  */
  88 public class Types {
  89     protected static final Context.Key&lt;Types&gt; typesKey = new Context.Key&lt;&gt;();
  90 
  91     final Symtab syms;
  92     final JavacMessages messages;
  93     final Names names;
  94     final boolean allowDefaultMethods;
  95     final boolean mapCapturesToBounds;

  96     final Check chk;
  97     final Enter enter;
  98     JCDiagnostic.Factory diags;
  99     List&lt;Warner&gt; warnStack = List.nil();
 100     final Name capturedName;
 101 
 102     public final Warner noWarnings;
 103 
 104     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Instantiating&quot;&gt;
 105     public static Types instance(Context context) {
 106         Types instance = context.get(typesKey);
 107         if (instance == null)
 108             instance = new Types(context);
 109         return instance;
 110     }
 111 
 112     protected Types(Context context) {
 113         context.put(typesKey, this);
 114         syms = Symtab.instance(context);
 115         names = Names.instance(context);
 116         Source source = Source.instance(context);
 117         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 118         mapCapturesToBounds = Feature.MAP_CAPTURES_TO_BOUNDS.allowedInSource(source);
 119         chk = Check.instance(context);
 120         enter = Enter.instance(context);
 121         capturedName = names.fromString(&quot;&lt;captured wildcard&gt;&quot;);
 122         messages = JavacMessages.instance(context);
 123         diags = JCDiagnostic.Factory.instance(context);
 124         noWarnings = new Warner(null);


 125     }
 126     // &lt;/editor-fold&gt;
 127 
 128     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;bounds&quot;&gt;
 129     /**
 130      * Get a wildcard&#39;s upper bound, returning non-wildcards unchanged.
 131      * @param t a type argument, either a wildcard or a type
 132      */
 133     public Type wildUpperBound(Type t) {
 134         if (t.hasTag(WILDCARD)) {
 135             WildcardType w = (WildcardType) t;
 136             if (w.isSuperBound())
 137                 return w.bound == null ? syms.objectType : w.bound.getUpperBound();
 138             else
 139                 return wildUpperBound(w.type);
 140         }
 141         else return t;
 142     }
 143 
 144     /**
</pre>
<hr />
<pre>
 584                 }
 585                 return res;
 586             }
 587 
 588             @Override
 589             public Type visitErrorType(ErrorType t, Symbol sym) {
 590                 return t;
 591             }
 592         };
 593     // &lt;/editor-fold&gt;
 594 
 595     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isConvertible&quot;&gt;
 596     /**
 597      * Is t a subtype of or convertible via boxing/unboxing
 598      * conversion to s?
 599      */
 600     public boolean isConvertible(Type t, Type s, Warner warn) {
 601         if (t.hasTag(ERROR)) {
 602             return true;
 603         }









 604         boolean tPrimitive = t.isPrimitive();
 605         boolean sPrimitive = s.isPrimitive();
 606         if (tPrimitive == sPrimitive) {
 607             return isSubtypeUnchecked(t, s, warn);
 608         }
 609         boolean tUndet = t.hasTag(UNDETVAR);
 610         boolean sUndet = s.hasTag(UNDETVAR);
 611 
 612         if (tUndet || sUndet) {
 613             return tUndet ?
 614                     isSubtype(t, boxedTypeOrType(s)) :
 615                     isSubtype(boxedTypeOrType(t), s);
 616         }
 617 
 618         return tPrimitive
 619             ? isSubtype(boxedClass(t).type, s)
 620             : isSubtype(unboxedType(t), s);
 621     }
 622 
 623     /**
</pre>
<hr />
<pre>
 977     * Scope filter used to skip methods that should be ignored (such as methods
 978     * overridden by j.l.Object) during function interface conversion interface check
 979     */
 980     class DescriptorFilter implements Filter&lt;Symbol&gt; {
 981 
 982        TypeSymbol origin;
 983 
 984        DescriptorFilter(TypeSymbol origin) {
 985            this.origin = origin;
 986        }
 987 
 988        @Override
 989        public boolean accepts(Symbol sym) {
 990            return sym.kind == MTH &amp;&amp;
 991                    (sym.flags() &amp; (ABSTRACT | DEFAULT)) == ABSTRACT &amp;&amp;
 992                    !overridesObjectMethod(origin, sym) &amp;&amp;
 993                    (interfaceCandidates(origin.type, (MethodSymbol)sym).head.flags() &amp; DEFAULT) == 0;
 994        }
 995     }
 996 








 997     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isSubtype&quot;&gt;
 998     /**
 999      * Is t an unchecked subtype of s?
1000      */
1001     public boolean isSubtypeUnchecked(Type t, Type s) {
1002         return isSubtypeUnchecked(t, s, noWarnings);
1003     }
1004     /**
1005      * Is t an unchecked subtype of s?
1006      */
1007     public boolean isSubtypeUnchecked(Type t, Type s, Warner warn) {
1008         boolean result = isSubtypeUncheckedInternal(t, s, true, warn);
1009         if (result) {
1010             checkUnsafeVarargsConversion(t, s, warn);
1011         }
1012         return result;
1013     }
1014     //where
1015         private boolean isSubtypeUncheckedInternal(Type t, Type s, boolean capture, Warner warn) {
1016             if (t.hasTag(ARRAY) &amp;&amp; s.hasTag(ARRAY)) {
1017                 if (((ArrayType)t).elemtype.isPrimitive()) {
1018                     return isSameType(elemtype(t), elemtype(s));
1019                 } else {
<span class="line-modified">1020                     return isSubtypeUncheckedInternal(elemtype(t), elemtype(s), false, warn);</span>










1021                 }
1022             } else if (isSubtype(t, s, capture)) {
1023                 return true;
1024             } else if (t.hasTag(TYPEVAR)) {
1025                 return isSubtypeUncheckedInternal(t.getUpperBound(), s, false, warn);
1026             } else if (!s.isRaw()) {
1027                 Type t2 = asSuper(t, s.tsym);
1028                 if (t2 != null &amp;&amp; t2.isRaw()) {
1029                     if (isReifiable(s)) {
1030                         warn.silentWarn(LintCategory.UNCHECKED);
1031                     } else {
1032                         warn.warn(LintCategory.UNCHECKED);
1033                     }
1034                     return true;
1035                 }
1036             }
1037             return false;
1038         }
1039 
1040         private void checkUnsafeVarargsConversion(Type t, Type s, Warner warn) {
</pre>
<hr />
<pre>
1097     }
1098     // where
1099         private TypeRelation isSubtype = new TypeRelation()
1100         {
1101             @Override
1102             public Boolean visitType(Type t, Type s) {
1103                 switch (t.getTag()) {
1104                  case BYTE:
1105                      return (!s.hasTag(CHAR) &amp;&amp; t.getTag().isSubRangeOf(s.getTag()));
1106                  case CHAR:
1107                      return (!s.hasTag(SHORT) &amp;&amp; t.getTag().isSubRangeOf(s.getTag()));
1108                  case SHORT: case INT: case LONG:
1109                  case FLOAT: case DOUBLE:
1110                      return t.getTag().isSubRangeOf(s.getTag());
1111                  case BOOLEAN: case VOID:
1112                      return t.hasTag(s.getTag());
1113                  case TYPEVAR:
1114                      return isSubtypeNoCapture(t.getUpperBound(), s);
1115                  case BOT:
1116                      return
<span class="line-modified">1117                          s.hasTag(BOT) || s.hasTag(CLASS) ||</span>
1118                          s.hasTag(ARRAY) || s.hasTag(TYPEVAR);
1119                  case WILDCARD: //we shouldn&#39;t be here - avoids crash (see 7034495)
1120                  case NONE:
1121                      return false;
1122                  default:
1123                      throw new AssertionError(&quot;isSubtype &quot; + t.getTag());
1124                  }
1125             }
1126 
1127             private Set&lt;TypePair&gt; cache = new HashSet&lt;&gt;();
1128 
1129             private boolean containsTypeRecursive(Type t, Type s) {
1130                 TypePair pair = new TypePair(t, s);
1131                 if (cache.add(pair)) {
1132                     try {
1133                         return containsType(t.getTypeArguments(),
1134                                             s.getTypeArguments());
1135                     } finally {
1136                         cache.remove(pair);
1137                     }
</pre>
<hr />
<pre>
1175             }
1176 
1177             @Override
1178             public Boolean visitClassType(ClassType t, Type s) {
1179                 Type sup = asSuper(t, s.tsym);
1180                 if (sup == null) return false;
1181                 // If t is an intersection, sup might not be a class type
1182                 if (!sup.hasTag(CLASS)) return isSubtypeNoCapture(sup, s);
1183                 return sup.tsym == s.tsym
1184                      // Check type variable containment
1185                     &amp;&amp; (!s.isParameterized() || containsTypeRecursive(s, sup))
1186                     &amp;&amp; isSubtypeNoCapture(sup.getEnclosingType(),
1187                                           s.getEnclosingType());
1188             }
1189 
1190             @Override
1191             public Boolean visitArrayType(ArrayType t, Type s) {
1192                 if (s.hasTag(ARRAY)) {
1193                     if (t.elemtype.isPrimitive())
1194                         return isSameType(t.elemtype, elemtype(s));
<span class="line-modified">1195                     else</span>
<span class="line-modified">1196                         return isSubtypeNoCapture(t.elemtype, elemtype(s));</span>









1197                 }
1198 
1199                 if (s.hasTag(CLASS)) {
1200                     Name sname = s.tsym.getQualifiedName();
1201                     return sname == names.java_lang_Object
1202                         || sname == names.java_lang_Cloneable
<span class="line-modified">1203                         || sname == names.java_io_Serializable;</span>

1204                 }
1205 
1206                 return false;
1207             }
1208 
1209             @Override
1210             public Boolean visitUndetVar(UndetVar t, Type s) {
1211                 //todo: test against origin needed? or replace with substitution?
1212                 if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {
1213                     return true;
1214                 } else if (s.hasTag(BOT)) {
1215                     //if &#39;s&#39; is &#39;null&#39; there&#39;s no instantiated type U for which
1216                     //U &lt;: s (but &#39;null&#39; itself, which is not a valid type)
1217                     return false;
1218                 }
1219 
1220                 t.addBound(InferenceBound.UPPER, s, Types.this);
1221                 return true;
1222             }
1223 
</pre>
<hr />
<pre>
1561 //            void debugContainsType(WildcardType t, Type s) {
1562 //                System.err.println();
1563 //                System.err.format(&quot; does %s contain %s?%n&quot;, t, s);
1564 //                System.err.format(&quot; %s U(%s) &lt;: U(%s) %s = %s%n&quot;,
1565 //                                  wildUpperBound(s), s, t, wildUpperBound(t),
1566 //                                  t.isSuperBound()
1567 //                                  || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t)));
1568 //                System.err.format(&quot; %s L(%s) &lt;: L(%s) %s = %s%n&quot;,
1569 //                                  wildLowerBound(t), t, s, wildLowerBound(s),
1570 //                                  t.isExtendsBound()
1571 //                                  || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s)));
1572 //                System.err.println();
1573 //            }
1574 
1575             @Override
1576             public Boolean visitWildcardType(WildcardType t, Type s) {
1577                 if (s.isPartial())
1578                     return containedBy(s, t);
1579                 else {
1580 //                    debugContainsType(t, s);









1581                     return isSameWildcard(t, s)
1582                         || isCaptureOf(s, t)
1583                         || ((t.isExtendsBound() || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s))) &amp;&amp;
1584                             (t.isSuperBound() || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t))));
1585                 }
1586             }
1587 
1588             @Override
1589             public Boolean visitUndetVar(UndetVar t, Type s) {
1590                 if (!s.hasTag(WILDCARD)) {
1591                     return isSameType(t, s);
1592                 } else {
1593                     return false;
1594                 }
1595             }
1596 
1597             @Override
1598             public Boolean visitErrorType(ErrorType t, Type s) {
1599                 return true;
1600             }
</pre>
<hr />
<pre>
1666                 case DOUBLE:
1667                     return s.isNumeric();
1668                 case BOOLEAN:
1669                     return s.hasTag(BOOLEAN);
1670                 case VOID:
1671                     return false;
1672                 case BOT:
1673                     return isSubtype(t, s);
1674                 default:
1675                     throw new AssertionError();
1676                 }
1677             }
1678 
1679             @Override
1680             public Boolean visitWildcardType(WildcardType t, Type s) {
1681                 return isCastable(wildUpperBound(t), s, warnStack.head);
1682             }
1683 
1684             @Override
1685             public Boolean visitClassType(ClassType t, Type s) {
<span class="line-modified">1686                 if (s.hasTag(ERROR) || s.hasTag(BOT))</span>
1687                     return true;
1688 
1689                 if (s.hasTag(TYPEVAR)) {
1690                     if (isCastable(t, s.getUpperBound(), noWarnings)) {
1691                         warnStack.head.warn(LintCategory.UNCHECKED);
1692                         return true;
1693                     } else {
1694                         return false;
1695                     }
1696                 }
1697 
1698                 if (t.isCompound() || s.isCompound()) {
1699                     return !t.isCompound() ?
1700                             visitCompoundType((ClassType)s, t, true) :
1701                             visitCompoundType(t, s, false);
1702                 }
1703 
1704                 if (s.hasTag(CLASS) || s.hasTag(ARRAY)) {








1705                     boolean upcast;
1706                     if ((upcast = isSubtype(erasure(t), erasure(s)))
1707                         || isSubtype(erasure(s), erasure(t))) {
1708                         if (!upcast &amp;&amp; s.hasTag(ARRAY)) {
1709                             if (!isReifiable(s))
1710                                 warnStack.head.warn(LintCategory.UNCHECKED);
1711                             return true;
1712                         } else if (s.isRaw()) {
1713                             return true;
1714                         } else if (t.isRaw()) {
1715                             if (!isUnbounded(s))
1716                                 warnStack.head.warn(LintCategory.UNCHECKED);
1717                             return true;
1718                         }
1719                         // Assume |a| &lt;: |b|
1720                         final Type a = upcast ? t : s;
1721                         final Type b = upcast ? s : t;
1722                         final boolean HIGH = true;
1723                         final boolean LOW = false;
1724                         final boolean DONT_REWRITE_TYPEVARS = false;
</pre>
<hr />
<pre>
1790 
1791             @Override
1792             public Boolean visitArrayType(ArrayType t, Type s) {
1793                 switch (s.getTag()) {
1794                 case ERROR:
1795                 case BOT:
1796                     return true;
1797                 case TYPEVAR:
1798                     if (isCastable(s, t, noWarnings)) {
1799                         warnStack.head.warn(LintCategory.UNCHECKED);
1800                         return true;
1801                     } else {
1802                         return false;
1803                     }
1804                 case CLASS:
1805                     return isSubtype(t, s);
1806                 case ARRAY:
1807                     if (elemtype(t).isPrimitive() || elemtype(s).isPrimitive()) {
1808                         return elemtype(t).hasTag(elemtype(s).getTag());
1809                     } else {
<span class="line-modified">1810                         return visit(elemtype(t), elemtype(s));</span>




1811                     }
1812                 default:
1813                     return false;
1814                 }
1815             }
1816 
1817             @Override
1818             public Boolean visitTypeVar(TypeVar t, Type s) {
1819                 switch (s.getTag()) {
1820                 case ERROR:
1821                 case BOT:
1822                     return true;
1823                 case TYPEVAR:
1824                     if (isSubtype(t, s)) {
1825                         return true;
1826                     } else if (isCastable(t.getUpperBound(), s, noWarnings)) {
1827                         warnStack.head.warn(LintCategory.UNCHECKED);
1828                         return true;
1829                     } else {
1830                         return false;
</pre>
<hr />
<pre>
2082             Assert.error(&quot;Type t must not be a VOID or PACKAGE type, &quot; + t.toString());
2083         }
2084         return new ArrayType(t, syms.arrayClass);
2085     }
2086     // &lt;/editor-fold&gt;
2087 
2088     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;asSuper&quot;&gt;
2089     /**
2090      * Return the (most specific) base type of t that starts with the
2091      * given symbol.  If none exists, return null.
2092      *
2093      * Caveat Emptor: Since javac represents the class of all arrays with a singleton
2094      * symbol Symtab.arrayClass, which by being a singleton cannot hold any discriminant,
2095      * this method could yield surprising answers when invoked on arrays. For example when
2096      * invoked with t being byte [] and sym being t.sym itself, asSuper would answer null.
2097      *
2098      * @param t a type
2099      * @param sym a symbol
2100      */
2101     public Type asSuper(Type t, Symbol sym) {

















2102         /* Some examples:
2103          *
2104          * (Enum&lt;E&gt;, Comparable) =&gt; Comparable&lt;E&gt;
2105          * (c.s.s.d.AttributeTree.ValueKind, Enum) =&gt; Enum&lt;c.s.s.d.AttributeTree.ValueKind&gt;
2106          * (c.s.s.t.ExpressionTree, c.s.s.t.Tree) =&gt; c.s.s.t.Tree
2107          * (j.u.List&lt;capture#160 of ? extends c.s.s.d.DocTree&gt;, Iterable) =&gt;
2108          *     Iterable&lt;capture#160 of ? extends c.s.s.d.DocTree&gt;
2109          */








2110         if (sym.type == syms.objectType) { //optimization
<span class="line-modified">2111             return syms.objectType;</span>











2112         }
2113         return asSuper.visit(t, sym);
2114     }
2115     // where
2116         private SimpleVisitor&lt;Type,Symbol&gt; asSuper = new SimpleVisitor&lt;Type,Symbol&gt;() {
2117 
2118             public Type visitType(Type t, Symbol sym) {
2119                 return null;
2120             }
2121 
2122             @Override
2123             public Type visitClassType(ClassType t, Symbol sym) {
2124                 if (t.tsym == sym)
2125                     return t;
2126 




2127                 Symbol c = t.tsym;
2128                 if ((c.flags_field &amp; LOCKED) != 0) {
2129                     return null;
2130                 }
2131                 try {
2132                     c.flags_field |= LOCKED;
2133                     Type st = supertype(t);
2134                     if (st.hasTag(CLASS) || st.hasTag(TYPEVAR)) {
2135                         Type x = asSuper(st, sym);
2136                         if (x != null)
2137                             return x;
2138                     }
2139                     if ((sym.flags() &amp; INTERFACE) != 0) {
2140                         for (List&lt;Type&gt; l = interfaces(t); l.nonEmpty(); l = l.tail) {
2141                             if (!l.head.hasTag(ERROR)) {
2142                                 Type x = asSuper(l.head, sym);
2143                                 if (x != null)
2144                                     return x;
2145                             }
2146                         }
</pre>
<hr />
<pre>
2219         case ARRAY:
2220             return isSubtype(t, sym.type) ? sym.type : null;
2221         case TYPEVAR:
2222             return asSuper(t, sym);
2223         case ERROR:
2224             return t;
2225         default:
2226             return null;
2227         }
2228     }
2229     // &lt;/editor-fold&gt;
2230 
2231     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;memberType&quot;&gt;
2232     /**
2233      * The type of given symbol, seen as a member of t.
2234      *
2235      * @param t a type
2236      * @param sym a symbol
2237      */
2238     public Type memberType(Type t, Symbol sym) {
<span class="line-modified">2239         return (sym.flags() &amp; STATIC) != 0</span>
<span class="line-modified">2240             ? sym.type</span>
<span class="line-modified">2241             : memberType.visit(t, sym);</span>












2242         }
2243     // where
2244         private SimpleVisitor&lt;Type,Symbol&gt; memberType = new SimpleVisitor&lt;Type,Symbol&gt;() {
2245 
2246             public Type visitType(Type t, Symbol sym) {
2247                 return sym.type;
2248             }
2249 
2250             @Override
2251             public Type visitWildcardType(WildcardType t, Symbol sym) {
2252                 return memberType(wildUpperBound(t), sym);
2253             }
2254 
2255             @Override
2256             public Type visitClassType(ClassType t, Symbol sym) {
2257                 Symbol owner = sym.owner;
2258                 long flags = sym.flags();
2259                 if (((flags &amp; STATIC) == 0) &amp;&amp; owner.type.isParameterized()) {
2260                     Type base = asOuterSuper(t, owner);
2261                     //if t is an intersection type T = CT &amp; I1 &amp; I2 ... &amp; In
</pre>
<hr />
<pre>
2431      */
2432     public IntersectionClassType makeIntersectionType(List&lt;Type&gt; bounds) {
2433         return makeIntersectionType(bounds, bounds.head.tsym.isInterface());
2434     }
2435 
2436     /**
2437      * Make an intersection type from non-empty list of types.  The list should be ordered according to
2438      * {@link TypeSymbol#precedes(TypeSymbol, Types)}. This does not cause symbol completion as
2439      * an extra parameter indicates as to whether all bounds are interfaces - in which case the
2440      * supertype is implicitly assumed to be &#39;Object&#39;.
2441      *
2442      * @param bounds        the types from which the intersection type is formed
2443      * @param allInterfaces are all bounds interface types?
2444      */
2445     public IntersectionClassType makeIntersectionType(List&lt;Type&gt; bounds, boolean allInterfaces) {
2446         Assert.check(bounds.nonEmpty());
2447         Type firstExplicitBound = bounds.head;
2448         if (allInterfaces) {
2449             bounds = bounds.prepend(syms.objectType);
2450         }



2451         ClassSymbol bc =
<span class="line-modified">2452             new ClassSymbol(ABSTRACT|PUBLIC|SYNTHETIC|COMPOUND|ACYCLIC,</span>
2453                             Type.moreInfo
2454                                 ? names.fromString(bounds.toString())
2455                                 : names.empty,
2456                             null,
2457                             syms.noSymbol);
2458         IntersectionClassType intersectionType = new IntersectionClassType(bounds, bc, allInterfaces);
2459         bc.type = intersectionType;
2460         bc.erasure_field = (bounds.head.hasTag(TYPEVAR)) ?
2461                 syms.objectType : // error condition, recover
2462                 erasure(firstExplicitBound);
2463         bc.members_field = WriteableScope.create(bc);
2464         return intersectionType;
2465     }
2466     // &lt;/editor-fold&gt;
2467 
2468     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;supertype&quot;&gt;
2469     public Type supertype(Type t) {
2470         return supertype.visit(t);
2471     }
2472     // where
</pre>
<hr />
<pre>
3906 
3907     /**
3908      * Return the least upper bound of list of types.  if the lub does
3909      * not exist return null.
3910      */
3911     public Type lub(List&lt;Type&gt; ts) {
3912         return lub(ts.toArray(new Type[ts.length()]));
3913     }
3914 
3915     /**
3916      * Return the least upper bound (lub) of set of types.  If the lub
3917      * does not exist return the type of null (bottom).
3918      */
3919     public Type lub(Type... ts) {
3920         final int UNKNOWN_BOUND = 0;
3921         final int ARRAY_BOUND = 1;
3922         final int CLASS_BOUND = 2;
3923 
3924         int[] kinds = new int[ts.length];
3925 
















3926         int boundkind = UNKNOWN_BOUND;
3927         for (int i = 0 ; i &lt; ts.length ; i++) {
3928             Type t = ts[i];
3929             switch (t.getTag()) {
3930             case CLASS:
3931                 boundkind |= kinds[i] = CLASS_BOUND;
3932                 break;
3933             case ARRAY:
3934                 boundkind |= kinds[i] = ARRAY_BOUND;
3935                 break;
3936             case  TYPEVAR:
3937                 do {
3938                     t = t.getUpperBound();
3939                 } while (t.hasTag(TYPEVAR));
3940                 if (t.hasTag(ARRAY)) {
3941                     boundkind |= kinds[i] = ARRAY_BOUND;
3942                 } else {
3943                     boundkind |= kinds[i] = CLASS_BOUND;
3944                 }
3945                 break;
</pre>
<hr />
<pre>
4026     // where
4027         List&lt;Type&gt; erasedSupertypes(Type t) {
4028             ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
4029             for (Type sup : closure(t)) {
4030                 if (sup.hasTag(TYPEVAR)) {
4031                     buf.append(sup);
4032                 } else {
4033                     buf.append(erasure(sup));
4034                 }
4035             }
4036             return buf.toList();
4037         }
4038 
4039         private Type arraySuperType = null;
4040         private Type arraySuperType() {
4041             // initialized lazily to avoid problems during compiler startup
4042             if (arraySuperType == null) {
4043                 synchronized (this) {
4044                     if (arraySuperType == null) {
4045                         // JLS 10.8: all arrays implement Cloneable and Serializable.
<span class="line-modified">4046                         arraySuperType = makeIntersectionType(List.of(syms.serializableType,</span>
<span class="line-modified">4047                                 syms.cloneableType), true);</span>

4048                     }
4049                 }
4050             }
4051             return arraySuperType;
4052         }
4053     // &lt;/editor-fold&gt;
4054 
4055     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Greatest lower bound&quot;&gt;
4056     public Type glb(List&lt;Type&gt; ts) {
4057         Type t1 = ts.head;
4058         for (Type t2 : ts.tail) {
4059             if (t1.isErroneous())
4060                 return t1;
4061             t1 = glb(t1, t2);
4062         }
4063         return t1;
4064     }
4065     //where
4066     public Type glb(Type t, Type s) {
4067         if (s == null)
</pre>
<hr />
<pre>
4806     private WildcardType makeSuperWildcard(Type bound, TypeVar formal) {
4807         if (bound.hasTag(BOT)) {
4808             return new WildcardType(syms.objectType,
4809                                     BoundKind.UNBOUND,
4810                                     syms.boundClass,
4811                                     formal);
4812         } else {
4813             return new WildcardType(bound,
4814                                     BoundKind.SUPER,
4815                                     syms.boundClass,
4816                                     formal);
4817         }
4818     }
4819 
4820     /**
4821      * A wrapper for a type that allows use in sets.
4822      */
4823     public static class UniqueType {
4824         public final Type type;
4825         final Types types;

4826 
<span class="line-modified">4827         public UniqueType(Type type, Types types) {</span>
4828             this.type = type;
4829             this.types = types;





4830         }
4831 
4832         public int hashCode() {
4833             return types.hashCode(type);
4834         }
4835 
4836         public boolean equals(Object obj) {
4837             return (obj instanceof UniqueType) &amp;&amp;
4838                 types.isSameType(type, ((UniqueType)obj).type);
4839         }
4840 




4841         public String toString() {
4842             return type.toString();
4843         }
4844 
4845     }
4846     // &lt;/editor-fold&gt;
4847 
4848     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Visitors&quot;&gt;
4849     /**
4850      * A default visitor for types.  All visitor methods except
4851      * visitType are implemented by delegating to visitType.  Concrete
4852      * subclasses must provide an implementation of visitType and can
4853      * override other methods as needed.
4854      *
4855      * @param &lt;R&gt; the return type of the operation implemented by this
4856      * visitor; use Void if no return type is needed.
4857      * @param &lt;S&gt; the type of the second argument (the first being the
4858      * type itself) of the operation implemented by this visitor; use
4859      * Void if a second argument is not needed.
4860      */
</pre>
<hr />
<pre>
5053                     break;
5054                 case LONG:
5055                     append(&#39;J&#39;);
5056                     break;
5057                 case FLOAT:
5058                     append(&#39;F&#39;);
5059                     break;
5060                 case DOUBLE:
5061                     append(&#39;D&#39;);
5062                     break;
5063                 case BOOLEAN:
5064                     append(&#39;Z&#39;);
5065                     break;
5066                 case VOID:
5067                     append(&#39;V&#39;);
5068                     break;
5069                 case CLASS:
5070                     if (type.isCompound()) {
5071                         reportIllegalSignature(type);
5072                     }
<span class="line-modified">5073                     append(&#39;L&#39;);</span>



5074                     assembleClassSig(type);
5075                     append(&#39;;&#39;);
5076                     break;
5077                 case ARRAY:
5078                     ArrayType at = (ArrayType) type;
5079                     append(&#39;[&#39;);
5080                     assembleSig(at.elemtype);
5081                     break;
5082                 case METHOD:
5083                     MethodType mt = (MethodType) type;
5084                     append(&#39;(&#39;);
5085                     assembleSig(mt.argtypes);
5086                     append(&#39;)&#39;);
5087                     assembleSig(mt.restype);
5088                     if (hasTypeVar(mt.thrown)) {
5089                         for (List&lt;Type&gt; l = mt.thrown; l.nonEmpty(); l = l.tail) {
5090                             append(&#39;^&#39;);
5091                             assembleSig(l.head);
5092                         }
5093                     }
</pre>
</td>
<td>
<hr />
<pre>
  33 import java.util.Optional;
  34 import java.util.Set;
  35 import java.util.WeakHashMap;
  36 import java.util.function.BiPredicate;
  37 import java.util.function.Function;
  38 import java.util.stream.Collector;
  39 
  40 import javax.tools.JavaFileObject;
  41 
  42 import com.sun.tools.javac.code.Attribute.RetentionPolicy;
  43 import com.sun.tools.javac.code.Lint.LintCategory;
  44 import com.sun.tools.javac.code.Source.Feature;
  45 import com.sun.tools.javac.code.Type.UndetVar.InferenceBound;
  46 import com.sun.tools.javac.code.TypeMetadata.Entry.Kind;
  47 import com.sun.tools.javac.comp.AttrContext;
  48 import com.sun.tools.javac.comp.Check;
  49 import com.sun.tools.javac.comp.Enter;
  50 import com.sun.tools.javac.comp.Env;
  51 import com.sun.tools.javac.comp.LambdaToMethod;
  52 import com.sun.tools.javac.jvm.ClassFile;
<span class="line-added">  53 import com.sun.tools.javac.jvm.Target;</span>
  54 import com.sun.tools.javac.util.*;
  55 
  56 import static com.sun.tools.javac.code.BoundKind.*;
  57 import static com.sun.tools.javac.code.Flags.*;
  58 import static com.sun.tools.javac.code.Kinds.Kind.*;
  59 import static com.sun.tools.javac.code.Scope.*;
  60 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  61 import static com.sun.tools.javac.code.Symbol.*;
  62 import static com.sun.tools.javac.code.Type.*;
  63 import static com.sun.tools.javac.code.TypeTag.*;
  64 import static com.sun.tools.javac.jvm.ClassFile.externalize;
  65 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  66 
  67 /**
  68  * Utility class containing various operations on types.
  69  *
  70  * &lt;p&gt;Unless other names are more illustrative, the following naming
  71  * conventions should be observed in this file:
  72  *
  73  * &lt;dl&gt;
</pre>
<hr />
<pre>
  77  * &lt;dd&gt;Similarly, if the second argument to an operation is a type, it should be named s.&lt;/dd&gt;
  78  * &lt;dt&gt;ts&lt;/dt&gt;
  79  * &lt;dd&gt;If an operations takes a list of types, the first should be named ts.&lt;/dd&gt;
  80  * &lt;dt&gt;ss&lt;/dt&gt;
  81  * &lt;dd&gt;A second list of types should be named ss.&lt;/dd&gt;
  82  * &lt;/dl&gt;
  83  *
  84  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  85  * If you write code that depends on this, you do so at your own risk.
  86  * This code and its internal interfaces are subject to change or
  87  * deletion without notice.&lt;/b&gt;
  88  */
  89 public class Types {
  90     protected static final Context.Key&lt;Types&gt; typesKey = new Context.Key&lt;&gt;();
  91 
  92     final Symtab syms;
  93     final JavacMessages messages;
  94     final Names names;
  95     final boolean allowDefaultMethods;
  96     final boolean mapCapturesToBounds;
<span class="line-added">  97     final boolean allowValueBasedClasses;</span>
  98     final Check chk;
  99     final Enter enter;
 100     JCDiagnostic.Factory diags;
 101     List&lt;Warner&gt; warnStack = List.nil();
 102     final Name capturedName;
 103 
 104     public final Warner noWarnings;
 105 
 106     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Instantiating&quot;&gt;
 107     public static Types instance(Context context) {
 108         Types instance = context.get(typesKey);
 109         if (instance == null)
 110             instance = new Types(context);
 111         return instance;
 112     }
 113 
 114     protected Types(Context context) {
 115         context.put(typesKey, this);
 116         syms = Symtab.instance(context);
 117         names = Names.instance(context);
 118         Source source = Source.instance(context);
 119         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 120         mapCapturesToBounds = Feature.MAP_CAPTURES_TO_BOUNDS.allowedInSource(source);
 121         chk = Check.instance(context);
 122         enter = Enter.instance(context);
 123         capturedName = names.fromString(&quot;&lt;captured wildcard&gt;&quot;);
 124         messages = JavacMessages.instance(context);
 125         diags = JCDiagnostic.Factory.instance(context);
 126         noWarnings = new Warner(null);
<span class="line-added"> 127         Options options = Options.instance(context);</span>
<span class="line-added"> 128         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);</span>
 129     }
 130     // &lt;/editor-fold&gt;
 131 
 132     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;bounds&quot;&gt;
 133     /**
 134      * Get a wildcard&#39;s upper bound, returning non-wildcards unchanged.
 135      * @param t a type argument, either a wildcard or a type
 136      */
 137     public Type wildUpperBound(Type t) {
 138         if (t.hasTag(WILDCARD)) {
 139             WildcardType w = (WildcardType) t;
 140             if (w.isSuperBound())
 141                 return w.bound == null ? syms.objectType : w.bound.getUpperBound();
 142             else
 143                 return wildUpperBound(w.type);
 144         }
 145         else return t;
 146     }
 147 
 148     /**
</pre>
<hr />
<pre>
 588                 }
 589                 return res;
 590             }
 591 
 592             @Override
 593             public Type visitErrorType(ErrorType t, Symbol sym) {
 594                 return t;
 595             }
 596         };
 597     // &lt;/editor-fold&gt;
 598 
 599     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isConvertible&quot;&gt;
 600     /**
 601      * Is t a subtype of or convertible via boxing/unboxing
 602      * conversion to s?
 603      */
 604     public boolean isConvertible(Type t, Type s, Warner warn) {
 605         if (t.hasTag(ERROR)) {
 606             return true;
 607         }
<span class="line-added"> 608 </span>
<span class="line-added"> 609         boolean tValue = t.isValue();</span>
<span class="line-added"> 610         boolean sValue = s.isValue();</span>
<span class="line-added"> 611         if (tValue != sValue) {</span>
<span class="line-added"> 612             return tValue ?</span>
<span class="line-added"> 613                     isSubtype(t.referenceProjection(), s) :</span>
<span class="line-added"> 614                     (!t.hasTag(BOT) || isValueBased(s)) &amp;&amp; isSubtype(t, s.referenceProjection());</span>
<span class="line-added"> 615         }</span>
<span class="line-added"> 616 </span>
 617         boolean tPrimitive = t.isPrimitive();
 618         boolean sPrimitive = s.isPrimitive();
 619         if (tPrimitive == sPrimitive) {
 620             return isSubtypeUnchecked(t, s, warn);
 621         }
 622         boolean tUndet = t.hasTag(UNDETVAR);
 623         boolean sUndet = s.hasTag(UNDETVAR);
 624 
 625         if (tUndet || sUndet) {
 626             return tUndet ?
 627                     isSubtype(t, boxedTypeOrType(s)) :
 628                     isSubtype(boxedTypeOrType(t), s);
 629         }
 630 
 631         return tPrimitive
 632             ? isSubtype(boxedClass(t).type, s)
 633             : isSubtype(unboxedType(t), s);
 634     }
 635 
 636     /**
</pre>
<hr />
<pre>
 990     * Scope filter used to skip methods that should be ignored (such as methods
 991     * overridden by j.l.Object) during function interface conversion interface check
 992     */
 993     class DescriptorFilter implements Filter&lt;Symbol&gt; {
 994 
 995        TypeSymbol origin;
 996 
 997        DescriptorFilter(TypeSymbol origin) {
 998            this.origin = origin;
 999        }
1000 
1001        @Override
1002        public boolean accepts(Symbol sym) {
1003            return sym.kind == MTH &amp;&amp;
1004                    (sym.flags() &amp; (ABSTRACT | DEFAULT)) == ABSTRACT &amp;&amp;
1005                    !overridesObjectMethod(origin, sym) &amp;&amp;
1006                    (interfaceCandidates(origin.type, (MethodSymbol)sym).head.flags() &amp; DEFAULT) == 0;
1007        }
1008     }
1009 
<span class="line-added">1010     public boolean isValue(Type t) {</span>
<span class="line-added">1011         return t != null &amp;&amp; t.tsym != null &amp;&amp; (t.tsym.flags_field &amp; Flags.VALUE) != 0;</span>
<span class="line-added">1012     }</span>
<span class="line-added">1013 </span>
<span class="line-added">1014     public boolean isValueBased(Type t) {</span>
<span class="line-added">1015         return allowValueBasedClasses &amp;&amp; t != null &amp;&amp; t.tsym != null &amp;&amp; (t.tsym.flags() &amp; Flags.VALUEBASED) != 0;</span>
<span class="line-added">1016     }</span>
<span class="line-added">1017 </span>
1018     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isSubtype&quot;&gt;
1019     /**
1020      * Is t an unchecked subtype of s?
1021      */
1022     public boolean isSubtypeUnchecked(Type t, Type s) {
1023         return isSubtypeUnchecked(t, s, noWarnings);
1024     }
1025     /**
1026      * Is t an unchecked subtype of s?
1027      */
1028     public boolean isSubtypeUnchecked(Type t, Type s, Warner warn) {
1029         boolean result = isSubtypeUncheckedInternal(t, s, true, warn);
1030         if (result) {
1031             checkUnsafeVarargsConversion(t, s, warn);
1032         }
1033         return result;
1034     }
1035     //where
1036         private boolean isSubtypeUncheckedInternal(Type t, Type s, boolean capture, Warner warn) {
1037             if (t.hasTag(ARRAY) &amp;&amp; s.hasTag(ARRAY)) {
1038                 if (((ArrayType)t).elemtype.isPrimitive()) {
1039                     return isSameType(elemtype(t), elemtype(s));
1040                 } else {
<span class="line-modified">1041                     // if T.ref &lt;: S, then T[] &lt;: S[]</span>
<span class="line-added">1042                     Type es = elemtype(s);</span>
<span class="line-added">1043                     Type et = elemtype(t);</span>
<span class="line-added">1044                     if (isValue(et)) {</span>
<span class="line-added">1045                         et = et.referenceProjection();</span>
<span class="line-added">1046                         if (isValue(es))</span>
<span class="line-added">1047                             es = es.referenceProjection();  // V &lt;: V, surely</span>
<span class="line-added">1048                     }</span>
<span class="line-added">1049                     if (!isSubtypeUncheckedInternal(et, es, false, warn))</span>
<span class="line-added">1050                         return false;</span>
<span class="line-added">1051                     return true;</span>
1052                 }
1053             } else if (isSubtype(t, s, capture)) {
1054                 return true;
1055             } else if (t.hasTag(TYPEVAR)) {
1056                 return isSubtypeUncheckedInternal(t.getUpperBound(), s, false, warn);
1057             } else if (!s.isRaw()) {
1058                 Type t2 = asSuper(t, s.tsym);
1059                 if (t2 != null &amp;&amp; t2.isRaw()) {
1060                     if (isReifiable(s)) {
1061                         warn.silentWarn(LintCategory.UNCHECKED);
1062                     } else {
1063                         warn.warn(LintCategory.UNCHECKED);
1064                     }
1065                     return true;
1066                 }
1067             }
1068             return false;
1069         }
1070 
1071         private void checkUnsafeVarargsConversion(Type t, Type s, Warner warn) {
</pre>
<hr />
<pre>
1128     }
1129     // where
1130         private TypeRelation isSubtype = new TypeRelation()
1131         {
1132             @Override
1133             public Boolean visitType(Type t, Type s) {
1134                 switch (t.getTag()) {
1135                  case BYTE:
1136                      return (!s.hasTag(CHAR) &amp;&amp; t.getTag().isSubRangeOf(s.getTag()));
1137                  case CHAR:
1138                      return (!s.hasTag(SHORT) &amp;&amp; t.getTag().isSubRangeOf(s.getTag()));
1139                  case SHORT: case INT: case LONG:
1140                  case FLOAT: case DOUBLE:
1141                      return t.getTag().isSubRangeOf(s.getTag());
1142                  case BOOLEAN: case VOID:
1143                      return t.hasTag(s.getTag());
1144                  case TYPEVAR:
1145                      return isSubtypeNoCapture(t.getUpperBound(), s);
1146                  case BOT:
1147                      return
<span class="line-modified">1148                          s.hasTag(BOT) || (s.hasTag(CLASS) &amp;&amp; (!isValue(s) || isValueBased(s))) ||</span>
1149                          s.hasTag(ARRAY) || s.hasTag(TYPEVAR);
1150                  case WILDCARD: //we shouldn&#39;t be here - avoids crash (see 7034495)
1151                  case NONE:
1152                      return false;
1153                  default:
1154                      throw new AssertionError(&quot;isSubtype &quot; + t.getTag());
1155                  }
1156             }
1157 
1158             private Set&lt;TypePair&gt; cache = new HashSet&lt;&gt;();
1159 
1160             private boolean containsTypeRecursive(Type t, Type s) {
1161                 TypePair pair = new TypePair(t, s);
1162                 if (cache.add(pair)) {
1163                     try {
1164                         return containsType(t.getTypeArguments(),
1165                                             s.getTypeArguments());
1166                     } finally {
1167                         cache.remove(pair);
1168                     }
</pre>
<hr />
<pre>
1206             }
1207 
1208             @Override
1209             public Boolean visitClassType(ClassType t, Type s) {
1210                 Type sup = asSuper(t, s.tsym);
1211                 if (sup == null) return false;
1212                 // If t is an intersection, sup might not be a class type
1213                 if (!sup.hasTag(CLASS)) return isSubtypeNoCapture(sup, s);
1214                 return sup.tsym == s.tsym
1215                      // Check type variable containment
1216                     &amp;&amp; (!s.isParameterized() || containsTypeRecursive(s, sup))
1217                     &amp;&amp; isSubtypeNoCapture(sup.getEnclosingType(),
1218                                           s.getEnclosingType());
1219             }
1220 
1221             @Override
1222             public Boolean visitArrayType(ArrayType t, Type s) {
1223                 if (s.hasTag(ARRAY)) {
1224                     if (t.elemtype.isPrimitive())
1225                         return isSameType(t.elemtype, elemtype(s));
<span class="line-modified">1226                     else {</span>
<span class="line-modified">1227                         // if T.ref &lt;: S, then T[] &lt;: S[]</span>
<span class="line-added">1228                         Type es = elemtype(s);</span>
<span class="line-added">1229                         Type et = elemtype(t);</span>
<span class="line-added">1230                         if (isValue(et)) {</span>
<span class="line-added">1231                             et = et.referenceProjection();</span>
<span class="line-added">1232                             if (isValue(es))</span>
<span class="line-added">1233                                 es = es.referenceProjection();  // V &lt;: V, surely</span>
<span class="line-added">1234                         }</span>
<span class="line-added">1235                         return isSubtypeNoCapture(et, es);</span>
<span class="line-added">1236                     }</span>
1237                 }
1238 
1239                 if (s.hasTag(CLASS)) {
1240                     Name sname = s.tsym.getQualifiedName();
1241                     return sname == names.java_lang_Object
1242                         || sname == names.java_lang_Cloneable
<span class="line-modified">1243                         || sname == names.java_io_Serializable</span>
<span class="line-added">1244                         || sname == names.java_lang_IdentityObject;</span>
1245                 }
1246 
1247                 return false;
1248             }
1249 
1250             @Override
1251             public Boolean visitUndetVar(UndetVar t, Type s) {
1252                 //todo: test against origin needed? or replace with substitution?
1253                 if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {
1254                     return true;
1255                 } else if (s.hasTag(BOT)) {
1256                     //if &#39;s&#39; is &#39;null&#39; there&#39;s no instantiated type U for which
1257                     //U &lt;: s (but &#39;null&#39; itself, which is not a valid type)
1258                     return false;
1259                 }
1260 
1261                 t.addBound(InferenceBound.UPPER, s, Types.this);
1262                 return true;
1263             }
1264 
</pre>
<hr />
<pre>
1602 //            void debugContainsType(WildcardType t, Type s) {
1603 //                System.err.println();
1604 //                System.err.format(&quot; does %s contain %s?%n&quot;, t, s);
1605 //                System.err.format(&quot; %s U(%s) &lt;: U(%s) %s = %s%n&quot;,
1606 //                                  wildUpperBound(s), s, t, wildUpperBound(t),
1607 //                                  t.isSuperBound()
1608 //                                  || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t)));
1609 //                System.err.format(&quot; %s L(%s) &lt;: L(%s) %s = %s%n&quot;,
1610 //                                  wildLowerBound(t), t, s, wildLowerBound(s),
1611 //                                  t.isExtendsBound()
1612 //                                  || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s)));
1613 //                System.err.println();
1614 //            }
1615 
1616             @Override
1617             public Boolean visitWildcardType(WildcardType t, Type s) {
1618                 if (s.isPartial())
1619                     return containedBy(s, t);
1620                 else {
1621 //                    debugContainsType(t, s);
<span class="line-added">1622 </span>
<span class="line-added">1623                     // -----------------------------------  Unspecified behavior ----------------</span>
<span class="line-added">1624 </span>
<span class="line-added">1625                     /* If a value class V implements an interface I, then does &quot;? extends I&quot; contain V?</span>
<span class="line-added">1626                        It seems widening must be applied here to answer yes to compile some common code</span>
<span class="line-added">1627                        patterns.</span>
<span class="line-added">1628                     */</span>
<span class="line-added">1629 </span>
<span class="line-added">1630                     // ---------------------------------------------------------------------------</span>
1631                     return isSameWildcard(t, s)
1632                         || isCaptureOf(s, t)
1633                         || ((t.isExtendsBound() || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s))) &amp;&amp;
1634                             (t.isSuperBound() || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t))));
1635                 }
1636             }
1637 
1638             @Override
1639             public Boolean visitUndetVar(UndetVar t, Type s) {
1640                 if (!s.hasTag(WILDCARD)) {
1641                     return isSameType(t, s);
1642                 } else {
1643                     return false;
1644                 }
1645             }
1646 
1647             @Override
1648             public Boolean visitErrorType(ErrorType t, Type s) {
1649                 return true;
1650             }
</pre>
<hr />
<pre>
1716                 case DOUBLE:
1717                     return s.isNumeric();
1718                 case BOOLEAN:
1719                     return s.hasTag(BOOLEAN);
1720                 case VOID:
1721                     return false;
1722                 case BOT:
1723                     return isSubtype(t, s);
1724                 default:
1725                     throw new AssertionError();
1726                 }
1727             }
1728 
1729             @Override
1730             public Boolean visitWildcardType(WildcardType t, Type s) {
1731                 return isCastable(wildUpperBound(t), s, warnStack.head);
1732             }
1733 
1734             @Override
1735             public Boolean visitClassType(ClassType t, Type s) {
<span class="line-modified">1736                 if (s.hasTag(ERROR) || (s.hasTag(BOT) &amp;&amp; !isValue(t)))</span>
1737                     return true;
1738 
1739                 if (s.hasTag(TYPEVAR)) {
1740                     if (isCastable(t, s.getUpperBound(), noWarnings)) {
1741                         warnStack.head.warn(LintCategory.UNCHECKED);
1742                         return true;
1743                     } else {
1744                         return false;
1745                     }
1746                 }
1747 
1748                 if (t.isCompound() || s.isCompound()) {
1749                     return !t.isCompound() ?
1750                             visitCompoundType((ClassType)s, t, true) :
1751                             visitCompoundType(t, s, false);
1752                 }
1753 
1754                 if (s.hasTag(CLASS) || s.hasTag(ARRAY)) {
<span class="line-added">1755                     if (isValue(t)) {</span>
<span class="line-added">1756                         // (s) Value ? == (s) Value.ref</span>
<span class="line-added">1757                         t = t.referenceProjection();</span>
<span class="line-added">1758                     }</span>
<span class="line-added">1759                     if (isValue(s)) {</span>
<span class="line-added">1760                         // (Value) t ? == (Value.ref) t</span>
<span class="line-added">1761                         s = s.referenceProjection();</span>
<span class="line-added">1762                     }</span>
1763                     boolean upcast;
1764                     if ((upcast = isSubtype(erasure(t), erasure(s)))
1765                         || isSubtype(erasure(s), erasure(t))) {
1766                         if (!upcast &amp;&amp; s.hasTag(ARRAY)) {
1767                             if (!isReifiable(s))
1768                                 warnStack.head.warn(LintCategory.UNCHECKED);
1769                             return true;
1770                         } else if (s.isRaw()) {
1771                             return true;
1772                         } else if (t.isRaw()) {
1773                             if (!isUnbounded(s))
1774                                 warnStack.head.warn(LintCategory.UNCHECKED);
1775                             return true;
1776                         }
1777                         // Assume |a| &lt;: |b|
1778                         final Type a = upcast ? t : s;
1779                         final Type b = upcast ? s : t;
1780                         final boolean HIGH = true;
1781                         final boolean LOW = false;
1782                         final boolean DONT_REWRITE_TYPEVARS = false;
</pre>
<hr />
<pre>
1848 
1849             @Override
1850             public Boolean visitArrayType(ArrayType t, Type s) {
1851                 switch (s.getTag()) {
1852                 case ERROR:
1853                 case BOT:
1854                     return true;
1855                 case TYPEVAR:
1856                     if (isCastable(s, t, noWarnings)) {
1857                         warnStack.head.warn(LintCategory.UNCHECKED);
1858                         return true;
1859                     } else {
1860                         return false;
1861                     }
1862                 case CLASS:
1863                     return isSubtype(t, s);
1864                 case ARRAY:
1865                     if (elemtype(t).isPrimitive() || elemtype(s).isPrimitive()) {
1866                         return elemtype(t).hasTag(elemtype(s).getTag());
1867                     } else {
<span class="line-modified">1868                         Type et = elemtype(t);</span>
<span class="line-added">1869                         Type es = elemtype(s);</span>
<span class="line-added">1870                         if (!visit(et, es))</span>
<span class="line-added">1871                             return false;</span>
<span class="line-added">1872                         return true;</span>
1873                     }
1874                 default:
1875                     return false;
1876                 }
1877             }
1878 
1879             @Override
1880             public Boolean visitTypeVar(TypeVar t, Type s) {
1881                 switch (s.getTag()) {
1882                 case ERROR:
1883                 case BOT:
1884                     return true;
1885                 case TYPEVAR:
1886                     if (isSubtype(t, s)) {
1887                         return true;
1888                     } else if (isCastable(t.getUpperBound(), s, noWarnings)) {
1889                         warnStack.head.warn(LintCategory.UNCHECKED);
1890                         return true;
1891                     } else {
1892                         return false;
</pre>
<hr />
<pre>
2144             Assert.error(&quot;Type t must not be a VOID or PACKAGE type, &quot; + t.toString());
2145         }
2146         return new ArrayType(t, syms.arrayClass);
2147     }
2148     // &lt;/editor-fold&gt;
2149 
2150     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;asSuper&quot;&gt;
2151     /**
2152      * Return the (most specific) base type of t that starts with the
2153      * given symbol.  If none exists, return null.
2154      *
2155      * Caveat Emptor: Since javac represents the class of all arrays with a singleton
2156      * symbol Symtab.arrayClass, which by being a singleton cannot hold any discriminant,
2157      * this method could yield surprising answers when invoked on arrays. For example when
2158      * invoked with t being byte [] and sym being t.sym itself, asSuper would answer null.
2159      *
2160      * @param t a type
2161      * @param sym a symbol
2162      */
2163     public Type asSuper(Type t, Symbol sym) {
<span class="line-added">2164         return asSuper(t, sym, false);</span>
<span class="line-added">2165     }</span>
<span class="line-added">2166 </span>
<span class="line-added">2167     /**</span>
<span class="line-added">2168      * Return the (most specific) base type of t that starts with the</span>
<span class="line-added">2169      * given symbol.  If none exists, return null.</span>
<span class="line-added">2170      *</span>
<span class="line-added">2171      * Caveat Emptor: Since javac represents the class of all arrays with a singleton</span>
<span class="line-added">2172      * symbol Symtab.arrayClass, which by being a singleton cannot hold any discriminant,</span>
<span class="line-added">2173      * this method could yield surprising answers when invoked on arrays. For example when</span>
<span class="line-added">2174      * invoked with t being byte [] and sym being t.sym itself, asSuper would answer null.</span>
<span class="line-added">2175      *</span>
<span class="line-added">2176      * @param t a type</span>
<span class="line-added">2177      * @param sym a symbol</span>
<span class="line-added">2178      * @param checkReferenceProjection if true, first compute reference projection of t</span>
<span class="line-added">2179      */</span>
<span class="line-added">2180     public Type asSuper(Type t, Symbol sym, boolean checkReferenceProjection) {</span>
2181         /* Some examples:
2182          *
2183          * (Enum&lt;E&gt;, Comparable) =&gt; Comparable&lt;E&gt;
2184          * (c.s.s.d.AttributeTree.ValueKind, Enum) =&gt; Enum&lt;c.s.s.d.AttributeTree.ValueKind&gt;
2185          * (c.s.s.t.ExpressionTree, c.s.s.t.Tree) =&gt; c.s.s.t.Tree
2186          * (j.u.List&lt;capture#160 of ? extends c.s.s.d.DocTree&gt;, Iterable) =&gt;
2187          *     Iterable&lt;capture#160 of ? extends c.s.s.d.DocTree&gt;
2188          */
<span class="line-added">2189 </span>
<span class="line-added">2190         /* For a (value or identity) class V, whether it implements an interface I, boils down to whether</span>
<span class="line-added">2191            V.ref is a subtype of I. OIOW, whether asSuper(V.ref, sym) != null. (Likewise for an abstract</span>
<span class="line-added">2192            superclass)</span>
<span class="line-added">2193         */</span>
<span class="line-added">2194         if (checkReferenceProjection)</span>
<span class="line-added">2195             t = t.isValue() ? t.referenceProjection() : t;</span>
<span class="line-added">2196 </span>
2197         if (sym.type == syms.objectType) { //optimization
<span class="line-modified">2198             if (!isValue(t))</span>
<span class="line-added">2199                 return syms.objectType;</span>
<span class="line-added">2200         }</span>
<span class="line-added">2201         if (sym.type == syms.identityObjectType) {</span>
<span class="line-added">2202             // IdentityObject is super interface of every concrete identity class other than jlO</span>
<span class="line-added">2203             if (t.isValue() || t.tsym == syms.objectType.tsym)</span>
<span class="line-added">2204                 return null;</span>
<span class="line-added">2205             if (t.hasTag(ARRAY))</span>
<span class="line-added">2206                 return syms.identityObjectType;</span>
<span class="line-added">2207             if (t.hasTag(CLASS) &amp;&amp; !t.isReferenceProjection() &amp;&amp; !t.tsym.isInterface() &amp;&amp; !t.tsym.isAbstract()) {</span>
<span class="line-added">2208                 return syms.identityObjectType;</span>
<span class="line-added">2209             } // else fall through and look for explicit coded super interface</span>
2210         }
2211         return asSuper.visit(t, sym);
2212     }
2213     // where
2214         private SimpleVisitor&lt;Type,Symbol&gt; asSuper = new SimpleVisitor&lt;Type,Symbol&gt;() {
2215 
2216             public Type visitType(Type t, Symbol sym) {
2217                 return null;
2218             }
2219 
2220             @Override
2221             public Type visitClassType(ClassType t, Symbol sym) {
2222                 if (t.tsym == sym)
2223                     return t;
2224 
<span class="line-added">2225                 // No man may be an island, but the bell tolls for a value.</span>
<span class="line-added">2226                 if (isValue(t))</span>
<span class="line-added">2227                     return null;</span>
<span class="line-added">2228 </span>
2229                 Symbol c = t.tsym;
2230                 if ((c.flags_field &amp; LOCKED) != 0) {
2231                     return null;
2232                 }
2233                 try {
2234                     c.flags_field |= LOCKED;
2235                     Type st = supertype(t);
2236                     if (st.hasTag(CLASS) || st.hasTag(TYPEVAR)) {
2237                         Type x = asSuper(st, sym);
2238                         if (x != null)
2239                             return x;
2240                     }
2241                     if ((sym.flags() &amp; INTERFACE) != 0) {
2242                         for (List&lt;Type&gt; l = interfaces(t); l.nonEmpty(); l = l.tail) {
2243                             if (!l.head.hasTag(ERROR)) {
2244                                 Type x = asSuper(l.head, sym);
2245                                 if (x != null)
2246                                     return x;
2247                             }
2248                         }
</pre>
<hr />
<pre>
2321         case ARRAY:
2322             return isSubtype(t, sym.type) ? sym.type : null;
2323         case TYPEVAR:
2324             return asSuper(t, sym);
2325         case ERROR:
2326             return t;
2327         default:
2328             return null;
2329         }
2330     }
2331     // &lt;/editor-fold&gt;
2332 
2333     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;memberType&quot;&gt;
2334     /**
2335      * The type of given symbol, seen as a member of t.
2336      *
2337      * @param t a type
2338      * @param sym a symbol
2339      */
2340     public Type memberType(Type t, Symbol sym) {
<span class="line-modified">2341 </span>
<span class="line-modified">2342         if ((sym.flags() &amp; STATIC) != 0)</span>
<span class="line-modified">2343             return sym.type;</span>
<span class="line-added">2344 </span>
<span class="line-added">2345         /* If any inline types are involved, switch over to the reference universe,</span>
<span class="line-added">2346            where the hierarchy is navigable. V and V.ref have identical membership</span>
<span class="line-added">2347            with no bridging needs.</span>
<span class="line-added">2348         */</span>
<span class="line-added">2349         if (t.isValue())</span>
<span class="line-added">2350             t = t.referenceProjection();</span>
<span class="line-added">2351 </span>
<span class="line-added">2352         if (sym.owner.isValue())</span>
<span class="line-added">2353             sym = sym.referenceProjection();</span>
<span class="line-added">2354 </span>
<span class="line-added">2355         return memberType.visit(t, sym);</span>
2356         }
2357     // where
2358         private SimpleVisitor&lt;Type,Symbol&gt; memberType = new SimpleVisitor&lt;Type,Symbol&gt;() {
2359 
2360             public Type visitType(Type t, Symbol sym) {
2361                 return sym.type;
2362             }
2363 
2364             @Override
2365             public Type visitWildcardType(WildcardType t, Symbol sym) {
2366                 return memberType(wildUpperBound(t), sym);
2367             }
2368 
2369             @Override
2370             public Type visitClassType(ClassType t, Symbol sym) {
2371                 Symbol owner = sym.owner;
2372                 long flags = sym.flags();
2373                 if (((flags &amp; STATIC) == 0) &amp;&amp; owner.type.isParameterized()) {
2374                     Type base = asOuterSuper(t, owner);
2375                     //if t is an intersection type T = CT &amp; I1 &amp; I2 ... &amp; In
</pre>
<hr />
<pre>
2545      */
2546     public IntersectionClassType makeIntersectionType(List&lt;Type&gt; bounds) {
2547         return makeIntersectionType(bounds, bounds.head.tsym.isInterface());
2548     }
2549 
2550     /**
2551      * Make an intersection type from non-empty list of types.  The list should be ordered according to
2552      * {@link TypeSymbol#precedes(TypeSymbol, Types)}. This does not cause symbol completion as
2553      * an extra parameter indicates as to whether all bounds are interfaces - in which case the
2554      * supertype is implicitly assumed to be &#39;Object&#39;.
2555      *
2556      * @param bounds        the types from which the intersection type is formed
2557      * @param allInterfaces are all bounds interface types?
2558      */
2559     public IntersectionClassType makeIntersectionType(List&lt;Type&gt; bounds, boolean allInterfaces) {
2560         Assert.check(bounds.nonEmpty());
2561         Type firstExplicitBound = bounds.head;
2562         if (allInterfaces) {
2563             bounds = bounds.prepend(syms.objectType);
2564         }
<span class="line-added">2565         long flags = ABSTRACT | PUBLIC | SYNTHETIC | COMPOUND | ACYCLIC;</span>
<span class="line-added">2566         if (isValue(bounds.head))</span>
<span class="line-added">2567             flags |= VALUE;</span>
2568         ClassSymbol bc =
<span class="line-modified">2569             new ClassSymbol(flags,</span>
2570                             Type.moreInfo
2571                                 ? names.fromString(bounds.toString())
2572                                 : names.empty,
2573                             null,
2574                             syms.noSymbol);
2575         IntersectionClassType intersectionType = new IntersectionClassType(bounds, bc, allInterfaces);
2576         bc.type = intersectionType;
2577         bc.erasure_field = (bounds.head.hasTag(TYPEVAR)) ?
2578                 syms.objectType : // error condition, recover
2579                 erasure(firstExplicitBound);
2580         bc.members_field = WriteableScope.create(bc);
2581         return intersectionType;
2582     }
2583     // &lt;/editor-fold&gt;
2584 
2585     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;supertype&quot;&gt;
2586     public Type supertype(Type t) {
2587         return supertype.visit(t);
2588     }
2589     // where
</pre>
<hr />
<pre>
4023 
4024     /**
4025      * Return the least upper bound of list of types.  if the lub does
4026      * not exist return null.
4027      */
4028     public Type lub(List&lt;Type&gt; ts) {
4029         return lub(ts.toArray(new Type[ts.length()]));
4030     }
4031 
4032     /**
4033      * Return the least upper bound (lub) of set of types.  If the lub
4034      * does not exist return the type of null (bottom).
4035      */
4036     public Type lub(Type... ts) {
4037         final int UNKNOWN_BOUND = 0;
4038         final int ARRAY_BOUND = 1;
4039         final int CLASS_BOUND = 2;
4040 
4041         int[] kinds = new int[ts.length];
4042 
<span class="line-added">4043         boolean haveValues = false;</span>
<span class="line-added">4044         boolean haveRefs = false;</span>
<span class="line-added">4045         for (int i = 0 ; i &lt; ts.length ; i++) {</span>
<span class="line-added">4046             if (ts[i].isValue())</span>
<span class="line-added">4047                 haveValues = true;</span>
<span class="line-added">4048             else</span>
<span class="line-added">4049                 haveRefs = true;</span>
<span class="line-added">4050         }</span>
<span class="line-added">4051         if (haveRefs &amp;&amp; haveValues) {</span>
<span class="line-added">4052             System.arraycopy(ts, 0, ts = new Type[ts.length], 0, ts.length);</span>
<span class="line-added">4053             for (int i = 0; i &lt; ts.length; i++) {</span>
<span class="line-added">4054                 if (ts[i].isValue())</span>
<span class="line-added">4055                     ts[i] = ts[i].referenceProjection();</span>
<span class="line-added">4056             }</span>
<span class="line-added">4057         }</span>
<span class="line-added">4058 </span>
4059         int boundkind = UNKNOWN_BOUND;
4060         for (int i = 0 ; i &lt; ts.length ; i++) {
4061             Type t = ts[i];
4062             switch (t.getTag()) {
4063             case CLASS:
4064                 boundkind |= kinds[i] = CLASS_BOUND;
4065                 break;
4066             case ARRAY:
4067                 boundkind |= kinds[i] = ARRAY_BOUND;
4068                 break;
4069             case  TYPEVAR:
4070                 do {
4071                     t = t.getUpperBound();
4072                 } while (t.hasTag(TYPEVAR));
4073                 if (t.hasTag(ARRAY)) {
4074                     boundkind |= kinds[i] = ARRAY_BOUND;
4075                 } else {
4076                     boundkind |= kinds[i] = CLASS_BOUND;
4077                 }
4078                 break;
</pre>
<hr />
<pre>
4159     // where
4160         List&lt;Type&gt; erasedSupertypes(Type t) {
4161             ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
4162             for (Type sup : closure(t)) {
4163                 if (sup.hasTag(TYPEVAR)) {
4164                     buf.append(sup);
4165                 } else {
4166                     buf.append(erasure(sup));
4167                 }
4168             }
4169             return buf.toList();
4170         }
4171 
4172         private Type arraySuperType = null;
4173         private Type arraySuperType() {
4174             // initialized lazily to avoid problems during compiler startup
4175             if (arraySuperType == null) {
4176                 synchronized (this) {
4177                     if (arraySuperType == null) {
4178                         // JLS 10.8: all arrays implement Cloneable and Serializable.
<span class="line-modified">4179                         List&lt;Type&gt; ifaces =</span>
<span class="line-modified">4180                                 List.of(syms.serializableType, syms.cloneableType, syms.identityObjectType);</span>
<span class="line-added">4181                         arraySuperType = makeIntersectionType(ifaces, true);</span>
4182                     }
4183                 }
4184             }
4185             return arraySuperType;
4186         }
4187     // &lt;/editor-fold&gt;
4188 
4189     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Greatest lower bound&quot;&gt;
4190     public Type glb(List&lt;Type&gt; ts) {
4191         Type t1 = ts.head;
4192         for (Type t2 : ts.tail) {
4193             if (t1.isErroneous())
4194                 return t1;
4195             t1 = glb(t1, t2);
4196         }
4197         return t1;
4198     }
4199     //where
4200     public Type glb(Type t, Type s) {
4201         if (s == null)
</pre>
<hr />
<pre>
4940     private WildcardType makeSuperWildcard(Type bound, TypeVar formal) {
4941         if (bound.hasTag(BOT)) {
4942             return new WildcardType(syms.objectType,
4943                                     BoundKind.UNBOUND,
4944                                     syms.boundClass,
4945                                     formal);
4946         } else {
4947             return new WildcardType(bound,
4948                                     BoundKind.SUPER,
4949                                     syms.boundClass,
4950                                     formal);
4951         }
4952     }
4953 
4954     /**
4955      * A wrapper for a type that allows use in sets.
4956      */
4957     public static class UniqueType {
4958         public final Type type;
4959         final Types types;
<span class="line-added">4960         private boolean encodeTypeSig;</span>
4961 
<span class="line-modified">4962         public UniqueType(Type type, Types types, boolean encodeTypeSig) {</span>
4963             this.type = type;
4964             this.types = types;
<span class="line-added">4965             this.encodeTypeSig = encodeTypeSig;</span>
<span class="line-added">4966         }</span>
<span class="line-added">4967 </span>
<span class="line-added">4968         public UniqueType(Type type, Types types) {</span>
<span class="line-added">4969             this(type, types, true);</span>
4970         }
4971 
4972         public int hashCode() {
4973             return types.hashCode(type);
4974         }
4975 
4976         public boolean equals(Object obj) {
4977             return (obj instanceof UniqueType) &amp;&amp;
4978                 types.isSameType(type, ((UniqueType)obj).type);
4979         }
4980 
<span class="line-added">4981         public boolean encodeTypeSig() {</span>
<span class="line-added">4982             return encodeTypeSig;</span>
<span class="line-added">4983         }</span>
<span class="line-added">4984 </span>
4985         public String toString() {
4986             return type.toString();
4987         }
4988 
4989     }
4990     // &lt;/editor-fold&gt;
4991 
4992     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Visitors&quot;&gt;
4993     /**
4994      * A default visitor for types.  All visitor methods except
4995      * visitType are implemented by delegating to visitType.  Concrete
4996      * subclasses must provide an implementation of visitType and can
4997      * override other methods as needed.
4998      *
4999      * @param &lt;R&gt; the return type of the operation implemented by this
5000      * visitor; use Void if no return type is needed.
5001      * @param &lt;S&gt; the type of the second argument (the first being the
5002      * type itself) of the operation implemented by this visitor; use
5003      * Void if a second argument is not needed.
5004      */
</pre>
<hr />
<pre>
5197                     break;
5198                 case LONG:
5199                     append(&#39;J&#39;);
5200                     break;
5201                 case FLOAT:
5202                     append(&#39;F&#39;);
5203                     break;
5204                 case DOUBLE:
5205                     append(&#39;D&#39;);
5206                     break;
5207                 case BOOLEAN:
5208                     append(&#39;Z&#39;);
5209                     break;
5210                 case VOID:
5211                     append(&#39;V&#39;);
5212                     break;
5213                 case CLASS:
5214                     if (type.isCompound()) {
5215                         reportIllegalSignature(type);
5216                     }
<span class="line-modified">5217                     if (types.isValue(type))</span>
<span class="line-added">5218                         append(&#39;Q&#39;);</span>
<span class="line-added">5219                     else</span>
<span class="line-added">5220                         append(&#39;L&#39;);</span>
5221                     assembleClassSig(type);
5222                     append(&#39;;&#39;);
5223                     break;
5224                 case ARRAY:
5225                     ArrayType at = (ArrayType) type;
5226                     append(&#39;[&#39;);
5227                     assembleSig(at.elemtype);
5228                     break;
5229                 case METHOD:
5230                     MethodType mt = (MethodType) type;
5231                     append(&#39;(&#39;);
5232                     assembleSig(mt.argtypes);
5233                     append(&#39;)&#39;);
5234                     assembleSig(mt.restype);
5235                     if (hasTypeVar(mt.thrown)) {
5236                         for (List&lt;Type&gt; l = mt.thrown; l.nonEmpty(); l = l.tail) {
5237                             append(&#39;^&#39;);
5238                             assembleSig(l.head);
5239                         }
5240                     }
</pre>
</td>
</tr>
</table>
<center><a href="../../doclint/Checker.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../comp/Attr.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.ArrayList;
  29 import java.util.HashSet;
  30 import java.util.Set;
  31 import java.util.function.BiConsumer;
  32 import java.util.stream.Collectors;
  33 
  34 import javax.tools.JavaFileObject;
  35 
  36 import com.sun.tools.javac.code.*;
  37 import com.sun.tools.javac.code.Lint.LintCategory;
  38 import com.sun.tools.javac.code.Scope.ImportFilter;
  39 import com.sun.tools.javac.code.Scope.NamedImportScope;
  40 import com.sun.tools.javac.code.Scope.StarImportScope;
  41 import com.sun.tools.javac.code.Scope.WriteableScope;
  42 import com.sun.tools.javac.code.Source.Feature;
  43 import com.sun.tools.javac.comp.Annotate.AnnotationTypeMetadata;
<a name="1" id="anc1"></a>
  44 import com.sun.tools.javac.tree.*;
  45 import com.sun.tools.javac.util.*;
  46 import com.sun.tools.javac.util.DefinedBy.Api;
  47 
  48 import com.sun.tools.javac.code.Symbol.*;
  49 import com.sun.tools.javac.code.Type.*;
  50 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  51 import com.sun.tools.javac.tree.JCTree.*;
  52 
  53 import static com.sun.tools.javac.code.Flags.*;
  54 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  55 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  56 import static com.sun.tools.javac.code.Kinds.Kind.*;
  57 import static com.sun.tools.javac.code.TypeTag.CLASS;
  58 import static com.sun.tools.javac.code.TypeTag.ERROR;
  59 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  60 
  61 import static com.sun.tools.javac.code.TypeTag.*;
  62 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  63 
  64 import com.sun.tools.javac.util.Dependencies.CompletionCause;
  65 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  66 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  67 
  68 /** This is the second phase of Enter, in which classes are completed
  69  *  by resolving their headers and entering their members in the into
  70  *  the class scope. See Enter for an overall overview.
  71  *
  72  *  This class uses internal phases to process the classes. When a phase
  73  *  processes classes, the lower phases are not invoked until all classes
  74  *  pass through the current phase. Note that it is possible that upper phases
  75  *  are run due to recursive completion. The internal phases are:
  76  *  - ImportPhase: shallow pass through imports, adds information about imports
  77  *                 the NamedImportScope and StarImportScope, but avoids queries
  78  *                 about class hierarchy.
  79  *  - HierarchyPhase: resolves the supertypes of the given class. Does not handle
  80  *                    type parameters of the class or type argument of the supertypes.
  81  *  - HeaderPhase: finishes analysis of the header of the given class by resolving
  82  *                 type parameters, attributing supertypes including type arguments
  83  *                 and scheduling full annotation attribution. This phase also adds
  84  *                 a synthetic default constructor if needed and synthetic &quot;this&quot; field.
  85  *  - MembersPhase: resolves headers for fields, methods and constructors in the given class.
  86  *                  Also generates synthetic enum members.
  87  *
  88  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  89  *  If you write code that depends on this, you do so at your own risk.
  90  *  This code and its internal interfaces are subject to change or
  91  *  deletion without notice.&lt;/b&gt;
  92  */
  93 public class TypeEnter implements Completer {
  94     protected static final Context.Key&lt;TypeEnter&gt; typeEnterKey = new Context.Key&lt;&gt;();
  95 
  96     /** A switch to determine whether we check for package/class conflicts
  97      */
  98     final static boolean checkClash = true;
  99 
 100     private final Names names;
 101     private final Enter enter;
 102     private final MemberEnter memberEnter;
 103     private final Log log;
 104     private final Check chk;
 105     private final Attr attr;
 106     private final Symtab syms;
 107     private final TreeMaker make;
 108     private final Todo todo;
 109     private final Annotate annotate;
 110     private final TypeAnnotations typeAnnotations;
 111     private final Types types;
 112     private final JCDiagnostic.Factory diags;
 113     private final DeferredLintHandler deferredLintHandler;
 114     private final Lint lint;
 115     private final TypeEnvs typeEnvs;
 116     private final Dependencies dependencies;
 117 
 118     public static TypeEnter instance(Context context) {
 119         TypeEnter instance = context.get(typeEnterKey);
 120         if (instance == null)
 121             instance = new TypeEnter(context);
 122         return instance;
 123     }
 124 
 125     protected TypeEnter(Context context) {
 126         context.put(typeEnterKey, this);
 127         names = Names.instance(context);
 128         enter = Enter.instance(context);
 129         memberEnter = MemberEnter.instance(context);
 130         log = Log.instance(context);
 131         chk = Check.instance(context);
 132         attr = Attr.instance(context);
 133         syms = Symtab.instance(context);
 134         make = TreeMaker.instance(context);
 135         todo = Todo.instance(context);
 136         annotate = Annotate.instance(context);
 137         typeAnnotations = TypeAnnotations.instance(context);
 138         types = Types.instance(context);
 139         diags = JCDiagnostic.Factory.instance(context);
 140         deferredLintHandler = DeferredLintHandler.instance(context);
 141         lint = Lint.instance(context);
 142         typeEnvs = TypeEnvs.instance(context);
 143         dependencies = Dependencies.instance(context);
 144         Source source = Source.instance(context);
 145         allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
 146         allowDeprecationOnImport = Feature.DEPRECATION_ON_IMPORT.allowedInSource(source);
 147     }
 148 
 149     /** Switch: support type annotations.
 150      */
 151     boolean allowTypeAnnos;
 152 
 153     /**
 154      * Switch: should deprecation warnings be issued on import
 155      */
 156     boolean allowDeprecationOnImport;
 157 
 158     /** A flag to disable completion from time to time during member
 159      *  enter, as we only need to look up types.  This avoids
 160      *  unnecessarily deep recursion.
 161      */
 162     boolean completionEnabled = true;
 163 
 164     /* Verify Imports:
 165      */
 166     protected void ensureImportsChecked(List&lt;JCCompilationUnit&gt; trees) {
 167         // if there remain any unimported toplevels (these must have
 168         // no classes at all), process their import statements as well.
 169         for (JCCompilationUnit tree : trees) {
 170             if (!tree.starImportScope.isFilled()) {
 171                 Env&lt;AttrContext&gt; topEnv = enter.topLevelEnv(tree);
 172                 finishImports(tree, () -&gt; { completeClass.resolveImports(tree, topEnv); });
 173             }
 174         }
 175     }
 176 
 177 /* ********************************************************************
 178  * Source completer
 179  *********************************************************************/
 180 
 181     /** Complete entering a class.
 182      *  @param sym         The symbol of the class to be completed.
 183      */
 184     @Override
 185     public void complete(Symbol sym) throws CompletionFailure {
 186         // Suppress some (recursive) MemberEnter invocations
 187         if (!completionEnabled) {
 188             // Re-install same completer for next time around and return.
 189             Assert.check((sym.flags() &amp; Flags.COMPOUND) == 0);
 190             sym.completer = this;
 191             return;
 192         }
 193 
 194         try {
 195             annotate.blockAnnotations();
 196             sym.flags_field |= UNATTRIBUTED;
 197 
 198             List&lt;Env&lt;AttrContext&gt;&gt; queue;
 199 
 200             dependencies.push((ClassSymbol) sym, CompletionCause.MEMBER_ENTER);
 201             try {
 202                 queue = completeClass.completeEnvs(List.of(typeEnvs.get((ClassSymbol) sym)));
 203             } finally {
 204                 dependencies.pop();
 205             }
 206 
 207             if (!queue.isEmpty()) {
 208                 Set&lt;JCCompilationUnit&gt; seen = new HashSet&lt;&gt;();
 209 
 210                 for (Env&lt;AttrContext&gt; env : queue) {
 211                     if (env.toplevel.defs.contains(env.enclClass) &amp;&amp; seen.add(env.toplevel)) {
 212                         finishImports(env.toplevel, () -&gt; {});
 213                     }
 214                 }
 215             }
 216         } finally {
 217             annotate.unblockAnnotations();
 218         }
 219     }
 220 
 221     void finishImports(JCCompilationUnit toplevel, Runnable resolve) {
 222         JavaFileObject prev = log.useSource(toplevel.sourcefile);
 223         try {
 224             resolve.run();
 225             chk.checkImportsUnique(toplevel);
 226             chk.checkImportsResolvable(toplevel);
 227             chk.checkImportedPackagesObservable(toplevel);
 228             toplevel.namedImportScope.finalizeScope();
 229             toplevel.starImportScope.finalizeScope();
 230         } catch (CompletionFailure cf) {
 231             chk.completionError(toplevel.pos(), cf);
 232         } finally {
 233             log.useSource(prev);
 234         }
 235     }
 236 
 237     abstract class Phase {
 238         private final ListBuffer&lt;Env&lt;AttrContext&gt;&gt; queue = new ListBuffer&lt;&gt;();
 239         private final Phase next;
 240         private final CompletionCause phaseName;
 241 
 242         Phase(CompletionCause phaseName, Phase next) {
 243             this.phaseName = phaseName;
 244             this.next = next;
 245         }
 246 
 247         public final List&lt;Env&lt;AttrContext&gt;&gt; completeEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 248             boolean firstToComplete = queue.isEmpty();
 249 
 250             Phase prevTopLevelPhase = topLevelPhase;
 251             boolean success = false;
 252 
 253             try {
 254                 topLevelPhase = this;
 255                 doCompleteEnvs(envs);
 256                 success = true;
 257             } finally {
 258                 topLevelPhase = prevTopLevelPhase;
 259                 if (!success &amp;&amp; firstToComplete) {
 260                     //an exception was thrown, e.g. BreakAttr:
 261                     //the queue would become stale, clear it:
 262                     queue.clear();
 263                 }
 264             }
 265 
 266             if (firstToComplete) {
 267                 List&lt;Env&lt;AttrContext&gt;&gt; out = queue.toList();
 268 
 269                 queue.clear();
 270                 return next != null ? next.completeEnvs(out) : out;
 271             } else {
 272                 return List.nil();
 273             }
 274         }
 275 
 276         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 277             for (Env&lt;AttrContext&gt; env : envs) {
 278                 JCClassDecl tree = (JCClassDecl)env.tree;
 279 
 280                 queue.add(env);
 281 
 282                 JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
 283                 DiagnosticPosition prevLintPos = deferredLintHandler.setPos(tree.pos());
 284                 try {
 285                     dependencies.push(env.enclClass.sym, phaseName);
 286                     runPhase(env);
 287                 } catch (CompletionFailure ex) {
 288                     chk.completionError(tree.pos(), ex);
 289                 } finally {
 290                     dependencies.pop();
 291                     deferredLintHandler.setPos(prevLintPos);
 292                     log.useSource(prev);
 293                 }
 294             }
 295         }
 296 
 297         protected abstract void runPhase(Env&lt;AttrContext&gt; env);
 298     }
 299 
 300     private final ImportsPhase completeClass = new ImportsPhase();
 301     private Phase topLevelPhase;
 302 
 303     /**Analyze import clauses.
 304      */
 305     private final class ImportsPhase extends Phase {
 306 
 307         public ImportsPhase() {
 308             super(CompletionCause.IMPORTS_PHASE, new HierarchyPhase());
 309         }
 310 
 311         Env&lt;AttrContext&gt; env;
 312         ImportFilter staticImportFilter;
 313         ImportFilter typeImportFilter;
 314         BiConsumer&lt;JCImport, CompletionFailure&gt; cfHandler =
 315                 (imp, cf) -&gt; chk.completionError(imp.pos(), cf);
 316 
 317         @Override
 318         protected void runPhase(Env&lt;AttrContext&gt; env) {
 319             JCClassDecl tree = env.enclClass;
 320             ClassSymbol sym = tree.sym;
 321 
 322             // If sym is a toplevel-class, make sure any import
 323             // clauses in its source file have been seen.
 324             if (sym.owner.kind == PCK) {
 325                 resolveImports(env.toplevel, env.enclosing(TOPLEVEL));
 326                 todo.append(env);
 327             }
 328 
 329             if (sym.owner.kind == TYP)
 330                 sym.owner.complete();
 331         }
 332 
 333         private void resolveImports(JCCompilationUnit tree, Env&lt;AttrContext&gt; env) {
 334             if (tree.starImportScope.isFilled()) {
 335                 // we must have already processed this toplevel
 336                 return;
 337             }
 338 
 339             ImportFilter prevStaticImportFilter = staticImportFilter;
 340             ImportFilter prevTypeImportFilter = typeImportFilter;
 341             DiagnosticPosition prevLintPos = deferredLintHandler.immediate();
 342             Lint prevLint = chk.setLint(lint);
 343             Env&lt;AttrContext&gt; prevEnv = this.env;
 344             try {
 345                 this.env = env;
 346                 final PackageSymbol packge = env.toplevel.packge;
 347                 this.staticImportFilter =
 348                         (origin, sym) -&gt; sym.isStatic() &amp;&amp;
 349                                          chk.importAccessible(sym, packge) &amp;&amp;
 350                                          sym.isMemberOf((TypeSymbol) origin.owner, types);
 351                 this.typeImportFilter =
 352                         (origin, sym) -&gt; sym.kind == TYP &amp;&amp;
 353                                          chk.importAccessible(sym, packge);
 354 
 355                 // Import-on-demand java.lang.
 356                 PackageSymbol javaLang = syms.enterPackage(syms.java_base, names.java_lang);
 357                 if (javaLang.members().isEmpty() &amp;&amp; !javaLang.exists())
 358                     throw new FatalError(diags.fragment(Fragments.FatalErrNoJavaLang));
 359                 importAll(make.at(tree.pos()).Import(make.QualIdent(javaLang), false), javaLang, env);
 360 
 361                 JCModuleDecl decl = tree.getModuleDecl();
 362 
 363                 // Process the package def and all import clauses.
 364                 if (tree.getPackage() != null &amp;&amp; decl == null)
 365                     checkClassPackageClash(tree.getPackage());
 366 
 367                 for (JCImport imp : tree.getImports()) {
 368                     doImport(imp);
 369                 }
 370 
 371                 if (decl != null) {
 372                     //check @Deprecated:
 373                     markDeprecated(decl.sym, decl.mods.annotations, env);
 374                     // process module annotations
 375                     annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle, null);
 376                 }
 377             } finally {
 378                 this.env = prevEnv;
 379                 chk.setLint(prevLint);
 380                 deferredLintHandler.setPos(prevLintPos);
 381                 this.staticImportFilter = prevStaticImportFilter;
 382                 this.typeImportFilter = prevTypeImportFilter;
 383             }
 384         }
 385 
 386         private void checkClassPackageClash(JCPackageDecl tree) {
 387             // check that no class exists with same fully qualified name as
 388             // toplevel package
 389             if (checkClash &amp;&amp; tree.pid != null) {
 390                 Symbol p = env.toplevel.packge;
 391                 while (p.owner != syms.rootPackage) {
 392                     p.owner.complete(); // enter all class members of p
 393                     //need to lookup the owning module/package:
 394                     PackageSymbol pack = syms.lookupPackage(env.toplevel.modle, p.owner.getQualifiedName());
 395                     if (syms.getClass(pack.modle, p.getQualifiedName()) != null) {
 396                         log.error(tree.pos,
 397                                   Errors.PkgClashesWithClassOfSameName(p));
 398                     }
 399                     p = p.owner;
 400                 }
 401             }
 402             // process package annotations
 403             annotate.annotateLater(tree.annotations, env, env.toplevel.packge, null);
 404         }
 405 
 406         private void doImport(JCImport tree) {
 407             JCFieldAccess imp = (JCFieldAccess)tree.qualid;
 408             Name name = TreeInfo.name(imp);
 409 
 410             // Create a local environment pointing to this tree to disable
 411             // effects of other imports in Resolve.findGlobalType
 412             Env&lt;AttrContext&gt; localEnv = env.dup(tree);
 413 
 414             TypeSymbol p = attr.attribImportQualifier(tree, localEnv).tsym;
 415             if (name == names.asterisk) {
 416                 // Import on demand.
 417                 chk.checkCanonical(imp.selected);
 418                 if (tree.staticImport)
 419                     importStaticAll(tree, p, env);
 420                 else
 421                     importAll(tree, p, env);
 422             } else {
 423                 // Named type import.
 424                 if (tree.staticImport) {
 425                     importNamedStatic(tree, p, name, localEnv);
 426                     chk.checkCanonical(imp.selected);
 427                 } else {
 428                     Type importedType = attribImportType(imp, localEnv);
 429                     Type originalType = importedType.getOriginalType();
 430                     TypeSymbol c = originalType.hasTag(CLASS) ? originalType.tsym : importedType.tsym;
 431                     chk.checkCanonical(imp);
 432                     importNamed(tree.pos(), c, env, tree);
 433                 }
 434             }
 435         }
 436 
 437         Type attribImportType(JCTree tree, Env&lt;AttrContext&gt; env) {
 438             Assert.check(completionEnabled);
 439             Lint prevLint = chk.setLint(allowDeprecationOnImport ?
 440                     lint : lint.suppress(LintCategory.DEPRECATION, LintCategory.REMOVAL, LintCategory.PREVIEW));
 441             try {
 442                 // To prevent deep recursion, suppress completion of some
 443                 // types.
 444                 completionEnabled = false;
 445                 return attr.attribType(tree, env);
 446             } finally {
 447                 completionEnabled = true;
 448                 chk.setLint(prevLint);
 449             }
 450         }
 451 
 452         /** Import all classes of a class or package on demand.
 453          *  @param imp           The import that is being handled.
 454          *  @param tsym          The class or package the members of which are imported.
 455          *  @param env           The env in which the imported classes will be entered.
 456          */
 457         private void importAll(JCImport imp,
 458                                final TypeSymbol tsym,
 459                                Env&lt;AttrContext&gt; env) {
 460             env.toplevel.starImportScope.importAll(types, tsym.members(), typeImportFilter, imp, cfHandler);
 461         }
 462 
 463         /** Import all static members of a class or package on demand.
 464          *  @param imp           The import that is being handled.
 465          *  @param tsym          The class or package the members of which are imported.
 466          *  @param env           The env in which the imported classes will be entered.
 467          */
 468         private void importStaticAll(JCImport imp,
 469                                      final TypeSymbol tsym,
 470                                      Env&lt;AttrContext&gt; env) {
 471             final StarImportScope toScope = env.toplevel.starImportScope;
 472             final TypeSymbol origin = tsym;
 473 
 474             toScope.importAll(types, origin.members(), staticImportFilter, imp, cfHandler);
 475         }
 476 
 477         /** Import statics types of a given name.  Non-types are handled in Attr.
 478          *  @param imp           The import that is being handled.
 479          *  @param tsym          The class from which the name is imported.
 480          *  @param name          The (simple) name being imported.
 481          *  @param env           The environment containing the named import
 482          *                  scope to add to.
 483          */
 484         private void importNamedStatic(final JCImport imp,
 485                                        final TypeSymbol tsym,
 486                                        final Name name,
 487                                        final Env&lt;AttrContext&gt; env) {
 488             if (tsym.kind != TYP) {
 489                 log.error(DiagnosticFlag.RECOVERABLE, imp.pos(), Errors.StaticImpOnlyClassesAndInterfaces);
 490                 return;
 491             }
 492 
 493             final NamedImportScope toScope = env.toplevel.namedImportScope;
 494             final Scope originMembers = tsym.members();
 495 
 496             imp.importScope = toScope.importByName(types, originMembers, name, staticImportFilter, imp, cfHandler);
 497         }
 498 
 499         /** Import given class.
 500          *  @param pos           Position to be used for error reporting.
 501          *  @param tsym          The class to be imported.
 502          *  @param env           The environment containing the named import
 503          *                  scope to add to.
 504          */
 505         private void importNamed(DiagnosticPosition pos, final Symbol tsym, Env&lt;AttrContext&gt; env, JCImport imp) {
 506             if (tsym.kind == TYP)
 507                 imp.importScope = env.toplevel.namedImportScope.importType(tsym.owner.members(), tsym.owner.members(), tsym);
 508         }
 509 
 510     }
 511 
 512     /**Defines common utility methods used by the HierarchyPhase and HeaderPhase.
 513      */
 514     private abstract class AbstractHeaderPhase extends Phase {
 515 
 516         public AbstractHeaderPhase(CompletionCause phaseName, Phase next) {
 517             super(phaseName, next);
 518         }
 519 
 520         protected Env&lt;AttrContext&gt; baseEnv(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
 521             WriteableScope baseScope = WriteableScope.create(tree.sym);
 522             //import already entered local classes into base scope
 523             for (Symbol sym : env.outer.info.scope.getSymbols(NON_RECURSIVE)) {
 524                 if (sym.isLocal()) {
 525                     baseScope.enter(sym);
 526                 }
 527             }
 528             //import current type-parameters into base scope
 529             if (tree.typarams != null)
 530                 for (List&lt;JCTypeParameter&gt; typarams = tree.typarams;
 531                      typarams.nonEmpty();
 532                      typarams = typarams.tail)
 533                     baseScope.enter(typarams.head.type.tsym);
 534             Env&lt;AttrContext&gt; outer = env.outer; // the base clause can&#39;t see members of this class
 535             Env&lt;AttrContext&gt; localEnv = outer.dup(tree, outer.info.dup(baseScope));
 536             localEnv.baseClause = true;
 537             localEnv.outer = outer;
 538             localEnv.info.isSelfCall = false;
 539             return localEnv;
 540         }
 541 
 542         /** Generate a base clause for an enum type.
 543          *  @param pos              The position for trees and diagnostics, if any
 544          *  @param c                The class symbol of the enum
 545          */
 546         protected  JCExpression enumBase(int pos, ClassSymbol c) {
 547             JCExpression result = make.at(pos).
 548                 TypeApply(make.QualIdent(syms.enumSym),
 549                           List.of(make.Type(c.type)));
 550             return result;
 551         }
 552 
 553         protected Type modelMissingTypes(Env&lt;AttrContext&gt; env, Type t, final JCExpression tree, final boolean interfaceExpected) {
 554             if (!t.hasTag(ERROR))
 555                 return t;
 556 
 557             return new ErrorType(t.getOriginalType(), t.tsym) {
 558                 private Type modelType;
 559 
 560                 @Override
 561                 public Type getModelType() {
 562                     if (modelType == null)
 563                         modelType = new Synthesizer(env.toplevel.modle, getOriginalType(), interfaceExpected).visit(tree);
 564                     return modelType;
 565                 }
 566             };
 567         }
 568             // where:
 569             private class Synthesizer extends JCTree.Visitor {
 570                 ModuleSymbol msym;
 571                 Type originalType;
 572                 boolean interfaceExpected;
 573                 List&lt;ClassSymbol&gt; synthesizedSymbols = List.nil();
 574                 Type result;
 575 
 576                 Synthesizer(ModuleSymbol msym, Type originalType, boolean interfaceExpected) {
 577                     this.msym = msym;
 578                     this.originalType = originalType;
 579                     this.interfaceExpected = interfaceExpected;
 580                 }
 581 
 582                 Type visit(JCTree tree) {
 583                     tree.accept(this);
 584                     return result;
 585                 }
 586 
 587                 List&lt;Type&gt; visit(List&lt;? extends JCTree&gt; trees) {
 588                     ListBuffer&lt;Type&gt; lb = new ListBuffer&lt;&gt;();
 589                     for (JCTree t: trees)
 590                         lb.append(visit(t));
 591                     return lb.toList();
 592                 }
 593 
 594                 @Override
 595                 public void visitTree(JCTree tree) {
 596                     result = syms.errType;
 597                 }
 598 
 599                 @Override
 600                 public void visitIdent(JCIdent tree) {
 601                     if (!tree.type.hasTag(ERROR)) {
 602                         result = tree.type;
 603                     } else {
 604                         result = synthesizeClass(tree.name, msym.unnamedPackage).type;
 605                     }
 606                 }
 607 
 608                 @Override
 609                 public void visitSelect(JCFieldAccess tree) {
 610                     if (!tree.type.hasTag(ERROR)) {
 611                         result = tree.type;
 612                     } else {
 613                         Type selectedType;
 614                         boolean prev = interfaceExpected;
 615                         try {
 616                             interfaceExpected = false;
 617                             selectedType = visit(tree.selected);
 618                         } finally {
 619                             interfaceExpected = prev;
 620                         }
 621                         ClassSymbol c = synthesizeClass(tree.name, selectedType.tsym);
 622                         result = c.type;
 623                     }
 624                 }
 625 
 626                 @Override
 627                 public void visitTypeApply(JCTypeApply tree) {
 628                     if (!tree.type.hasTag(ERROR)) {
 629                         result = tree.type;
 630                     } else {
 631                         ClassType clazzType = (ClassType) visit(tree.clazz);
 632                         if (synthesizedSymbols.contains(clazzType.tsym))
 633                             synthesizeTyparams((ClassSymbol) clazzType.tsym, tree.arguments.size());
 634                         final List&lt;Type&gt; actuals = visit(tree.arguments);
 635                         result = new ErrorType(tree.type, clazzType.tsym) {
 636                             @Override @DefinedBy(Api.LANGUAGE_MODEL)
 637                             public List&lt;Type&gt; getTypeArguments() {
 638                                 return actuals;
 639                             }
 640                         };
 641                     }
 642                 }
 643 
 644                 ClassSymbol synthesizeClass(Name name, Symbol owner) {
 645                     int flags = interfaceExpected ? INTERFACE : 0;
 646                     ClassSymbol c = new ClassSymbol(flags, name, owner);
 647                     c.members_field = new Scope.ErrorScope(c);
 648                     c.type = new ErrorType(originalType, c) {
 649                         @Override @DefinedBy(Api.LANGUAGE_MODEL)
 650                         public List&lt;Type&gt; getTypeArguments() {
 651                             return typarams_field;
 652                         }
 653                     };
 654                     synthesizedSymbols = synthesizedSymbols.prepend(c);
 655                     return c;
 656                 }
 657 
 658                 void synthesizeTyparams(ClassSymbol sym, int n) {
 659                     ClassType ct = (ClassType) sym.type;
 660                     Assert.check(ct.typarams_field.isEmpty());
 661                     if (n == 1) {
 662                         TypeVar v = new TypeVar(names.fromString(&quot;T&quot;), sym, syms.botType);
 663                         ct.typarams_field = ct.typarams_field.prepend(v);
 664                     } else {
 665                         for (int i = n; i &gt; 0; i--) {
 666                             TypeVar v = new TypeVar(names.fromString(&quot;T&quot; + i), sym,
 667                                                     syms.botType);
 668                             ct.typarams_field = ct.typarams_field.prepend(v);
 669                         }
 670                     }
 671                 }
 672             }
 673 
 674         protected void attribSuperTypes(Env&lt;AttrContext&gt; env, Env&lt;AttrContext&gt; baseEnv) {
 675             JCClassDecl tree = env.enclClass;
 676             ClassSymbol sym = tree.sym;
 677             ClassType ct = (ClassType)sym.type;
 678             // Determine supertype.
 679             Type supertype;
 680             JCExpression extending;
<a name="2" id="anc2"></a>
 681 
 682             if (tree.extending != null) {
 683                 extending = clearTypeParams(tree.extending);
 684                 supertype = attr.attribBase(extending, baseEnv, true, false, true);
 685                 if (supertype == syms.recordType) {
 686                     log.error(tree, Errors.InvalidSupertypeRecord(supertype.tsym));
 687                 }
 688             } else {
 689                 extending = null;
 690                 supertype = ((tree.mods.flags &amp; Flags.ENUM) != 0)
 691                 ? attr.attribBase(enumBase(tree.pos, sym), baseEnv,
 692                                   true, false, false)
 693                 : (sym.fullname == names.java_lang_Object)
 694                 ? Type.noType
 695                 : sym.isRecord() ? syms.recordType : syms.objectType;
 696             }
 697             ct.supertype_field = modelMissingTypes(baseEnv, supertype, extending, false);
 698 
 699             // Determine interfaces.
 700             ListBuffer&lt;Type&gt; interfaces = new ListBuffer&lt;&gt;();
 701             ListBuffer&lt;Type&gt; all_interfaces = null; // lazy init
 702             List&lt;JCExpression&gt; interfaceTrees = tree.implementing;
 703             for (JCExpression iface : interfaceTrees) {
 704                 iface = clearTypeParams(iface);
 705                 Type it = attr.attribBase(iface, baseEnv, false, true, true);
 706                 if (it.hasTag(CLASS)) {
 707                     interfaces.append(it);
 708                     if (all_interfaces != null) all_interfaces.append(it);
 709                 } else {
 710                     if (all_interfaces == null)
 711                         all_interfaces = new ListBuffer&lt;Type&gt;().appendList(interfaces);
 712                     all_interfaces.append(modelMissingTypes(baseEnv, it, iface, true));
 713                 }
 714             }
 715 
 716             // Determine permits.
 717             ListBuffer&lt;Symbol&gt; permittedSubtypeSymbols = new ListBuffer&lt;&gt;();
 718             List&lt;JCExpression&gt; permittedTrees = tree.permitting;
 719             for (JCExpression permitted : permittedTrees) {
 720                 Type pt = attr.attribBase(permitted, baseEnv, false, false, false);
 721                 permittedSubtypeSymbols.append(pt.tsym);
 722             }
 723 
 724             if ((sym.flags_field &amp; ANNOTATION) != 0) {
 725                 ct.interfaces_field = List.of(syms.annotationType);
 726                 ct.all_interfaces_field = ct.interfaces_field;
 727             }  else {
 728                 ct.interfaces_field = interfaces.toList();
 729                 ct.all_interfaces_field = (all_interfaces == null)
 730                         ? ct.interfaces_field : all_interfaces.toList();
 731             }
<a name="3" id="anc3"></a>








 732 
 733             /* it could be that there are already some symbols in the permitted list, for the case
 734              * where there are subtypes in the same compilation unit but the permits list is empty
 735              * so don&#39;t overwrite the permitted list if it is not empty
 736              */
 737             if (!permittedSubtypeSymbols.isEmpty()) {
 738                 sym.permitted = permittedSubtypeSymbols.toList();
 739             }
 740             sym.isPermittedExplicit = !permittedSubtypeSymbols.isEmpty();
 741         }
 742             //where:
 743             protected JCExpression clearTypeParams(JCExpression superType) {
 744                 return superType;
 745             }
 746     }
 747 
 748     private final class HierarchyPhase extends AbstractHeaderPhase implements Completer {
 749 
 750         public HierarchyPhase() {
 751             super(CompletionCause.HIERARCHY_PHASE, new PermitsPhase());
 752         }
 753 
 754         @Override
 755         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 756             //The ClassSymbols in the envs list may not be in the dependency order.
 757             //To get proper results, for every class or interface C, the supertypes of
 758             //C must be processed by the HierarchyPhase phase before C.
 759             //To achieve that, the HierarchyPhase is registered as the Completer for
 760             //all the classes first, and then all the classes are completed.
 761             for (Env&lt;AttrContext&gt; env : envs) {
 762                 env.enclClass.sym.completer = this;
 763             }
 764             for (Env&lt;AttrContext&gt; env : envs) {
 765                 env.enclClass.sym.complete();
 766             }
 767         }
 768 
 769         @Override
 770         protected void runPhase(Env&lt;AttrContext&gt; env) {
 771             JCClassDecl tree = env.enclClass;
 772             ClassSymbol sym = tree.sym;
 773             ClassType ct = (ClassType)sym.type;
 774 
 775             Env&lt;AttrContext&gt; baseEnv = baseEnv(tree, env);
 776 
 777             attribSuperTypes(env, baseEnv);
 778 
 779             if (sym.fullname == names.java_lang_Object) {
 780                 if (tree.extending != null) {
 781                     chk.checkNonCyclic(tree.extending.pos(),
 782                                        ct.supertype_field);
 783                     ct.supertype_field = Type.noType;
 784                 }
 785                 else if (tree.implementing.nonEmpty()) {
 786                     chk.checkNonCyclic(tree.implementing.head.pos(),
 787                                        ct.interfaces_field.head);
 788                     ct.interfaces_field = List.nil();
 789                 }
 790             }
 791 
 792             markDeprecated(sym, tree.mods.annotations, baseEnv);
 793 
 794             chk.checkNonCyclicDecl(tree);
 795         }
 796             //where:
 797             @Override
 798             protected JCExpression clearTypeParams(JCExpression superType) {
 799                 switch (superType.getTag()) {
 800                     case TYPEAPPLY:
 801                         return ((JCTypeApply) superType).clazz;
 802                 }
 803 
 804                 return superType;
 805             }
 806 
 807         @Override
 808         public void complete(Symbol sym) throws CompletionFailure {
 809             Assert.check((topLevelPhase instanceof ImportsPhase) ||
 810                          (topLevelPhase == this));
 811 
 812             if (topLevelPhase != this) {
 813                 //only do the processing based on dependencies in the HierarchyPhase:
 814                 sym.completer = this;
 815                 return ;
 816             }
 817 
 818             Env&lt;AttrContext&gt; env = typeEnvs.get((ClassSymbol) sym);
 819 
 820             super.doCompleteEnvs(List.of(env));
 821         }
 822 
 823     }
 824 
 825     private final class PermitsPhase extends AbstractHeaderPhase {
 826 
 827         public PermitsPhase() {
 828             super(CompletionCause.HIERARCHY_PHASE, new HeaderPhase());
 829         }
 830 
 831         @Override
 832         protected void runPhase(Env&lt;AttrContext&gt; env) {
 833             JCClassDecl tree = env.enclClass;
 834             if (!tree.sym.isAnonymous() || tree.sym.isEnum()) {
 835                 for (Type supertype : types.directSupertypes(tree.sym.type)) {
 836                     if (supertype.tsym.kind == TYP) {
 837                         ClassSymbol supClass = (ClassSymbol) supertype.tsym;
 838                         Env&lt;AttrContext&gt; supClassEnv = enter.getEnv(supClass);
 839                         if (supClass.isSealed() &amp;&amp;
 840                             !supClass.isPermittedExplicit &amp;&amp;
 841                             supClassEnv != null &amp;&amp;
 842                             supClassEnv.toplevel == env.toplevel) {
 843                             supClass.permitted = supClass.permitted.append(tree.sym);
 844                         }
 845                     }
 846                 }
 847             }
 848         }
 849 
 850     }
 851 
 852     private final class HeaderPhase extends AbstractHeaderPhase {
 853 
 854         public HeaderPhase() {
 855             super(CompletionCause.HEADER_PHASE, new RecordPhase());
 856         }
 857 
 858         @Override
 859         protected void runPhase(Env&lt;AttrContext&gt; env) {
 860             JCClassDecl tree = env.enclClass;
 861             ClassSymbol sym = tree.sym;
 862             ClassType ct = (ClassType)sym.type;
 863 
 864             // create an environment for evaluating the base clauses
 865             Env&lt;AttrContext&gt; baseEnv = baseEnv(tree, env);
 866 
 867             if (tree.extending != null)
 868                 annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym, tree.pos());
 869             for (JCExpression impl : tree.implementing)
 870                 annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym, tree.pos());
 871             annotate.flush();
 872 
 873             attribSuperTypes(env, baseEnv);
 874 
 875             Set&lt;Type&gt; interfaceSet = new HashSet&lt;&gt;();
 876 
 877             for (JCExpression iface : tree.implementing) {
 878                 Type it = iface.type;
 879                 if (it.hasTag(CLASS))
 880                     chk.checkNotRepeated(iface.pos(), types.erasure(it), interfaceSet);
 881             }
 882 
 883             annotate.annotateLater(tree.mods.annotations, baseEnv,
 884                         sym, tree.pos());
 885             attr.attribTypeVariables(tree.typarams, baseEnv, false);
 886 
 887             for (JCTypeParameter tp : tree.typarams)
 888                 annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym, tree.pos());
 889 
 890             // check that no package exists with same fully qualified name,
 891             // but admit classes in the unnamed package which have the same
 892             // name as a top-level package.
 893             if (checkClash &amp;&amp;
 894                 sym.owner.kind == PCK &amp;&amp; sym.owner != env.toplevel.modle.unnamedPackage &amp;&amp;
 895                 syms.packageExists(env.toplevel.modle, sym.fullname)) {
 896                 log.error(tree.pos, Errors.ClashWithPkgOfSameName(Kinds.kindName(sym),sym));
 897             }
 898             if (sym.owner.kind == PCK &amp;&amp; (sym.flags_field &amp; PUBLIC) == 0 &amp;&amp;
 899                 !env.toplevel.sourcefile.isNameCompatible(sym.name.toString(),JavaFileObject.Kind.SOURCE)) {
 900                 sym.flags_field |= AUXILIARY;
 901             }
 902         }
 903     }
 904 
 905     private abstract class AbstractMembersPhase extends Phase {
 906 
 907         public AbstractMembersPhase(CompletionCause completionCause, Phase next) {
 908             super(completionCause, next);
 909         }
 910 
 911         private boolean completing;
 912         private List&lt;Env&lt;AttrContext&gt;&gt; todo = List.nil();
 913 
 914         @Override
 915         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 916             todo = todo.prependList(envs);
 917             if (completing) {
 918                 return ; //the top-level invocation will handle all envs
 919             }
 920             boolean prevCompleting = completing;
 921             completing = true;
 922             try {
 923                 while (todo.nonEmpty()) {
 924                     Env&lt;AttrContext&gt; head = todo.head;
 925                     todo = todo.tail;
 926                     super.doCompleteEnvs(List.of(head));
 927                 }
 928             } finally {
 929                 completing = prevCompleting;
 930             }
 931         }
 932 
 933         void enterThisAndSuper(ClassSymbol sym, Env&lt;AttrContext&gt; env) {
 934             ClassType ct = (ClassType)sym.type;
 935             // enter symbols for &#39;this&#39; into current scope.
 936             VarSymbol thisSym =
 937                     new VarSymbol(FINAL | HASINIT, names._this, sym.type, sym);
 938             thisSym.pos = Position.FIRSTPOS;
 939             env.info.scope.enter(thisSym);
 940             // if this is a class, enter symbol for &#39;super&#39; into current scope.
 941             if ((sym.flags_field &amp; INTERFACE) == 0 &amp;&amp;
 942                     ct.supertype_field.hasTag(CLASS)) {
 943                 VarSymbol superSym =
 944                         new VarSymbol(FINAL | HASINIT, names._super,
 945                                 ct.supertype_field, sym);
 946                 superSym.pos = Position.FIRSTPOS;
 947                 env.info.scope.enter(superSym);
 948             }
 949         }
 950     }
 951 
 952     private final class RecordPhase extends AbstractMembersPhase {
 953 
 954         public RecordPhase() {
 955             super(CompletionCause.RECORD_PHASE, new MembersPhase());
 956         }
 957 
 958         @Override
 959         protected void runPhase(Env&lt;AttrContext&gt; env) {
 960             JCClassDecl tree = env.enclClass;
 961             ClassSymbol sym = tree.sym;
 962             if ((sym.flags_field &amp; RECORD) != 0) {
 963                 List&lt;JCVariableDecl&gt; fields = TreeInfo.recordFields(tree);
 964                 memberEnter.memberEnter(fields, env);
 965                 for (JCVariableDecl field : fields) {
 966                     sym.getRecordComponent(field, true,
 967                             field.mods.annotations.isEmpty() ?
 968                                     List.nil() :
 969                                     new TreeCopier&lt;JCTree&gt;(make.at(field.pos)).copy(field.mods.annotations));
 970                 }
 971 
 972                 enterThisAndSuper(sym, env);
 973 
 974                 // lets enter all constructors
 975                 for (JCTree def : tree.defs) {
 976                     if (TreeInfo.isConstructor(def)) {
 977                         memberEnter.memberEnter(def, env);
 978                     }
 979                 }
 980             }
 981         }
 982     }
 983 
 984     /** Enter member fields and methods of a class
 985      */
 986     private final class MembersPhase extends AbstractMembersPhase {
 987 
 988         public MembersPhase() {
 989             super(CompletionCause.MEMBERS_PHASE, null);
 990         }
 991 
 992         @Override
 993         protected void runPhase(Env&lt;AttrContext&gt; env) {
 994             JCClassDecl tree = env.enclClass;
 995             ClassSymbol sym = tree.sym;
 996             ClassType ct = (ClassType)sym.type;
 997 
 998             // Add default constructor if needed.
 999             DefaultConstructorHelper helper = getDefaultConstructorHelper(env);
1000             if (helper != null) {
1001                 JCTree constrDef = defaultConstructor(make.at(tree.pos), helper);
1002                 tree.defs = tree.defs.prepend(constrDef);
1003             }
1004             if (!sym.isRecord()) {
1005                 enterThisAndSuper(sym, env);
1006             }
1007 
1008             if (!tree.typarams.isEmpty()) {
1009                 for (JCTypeParameter tvar : tree.typarams) {
1010                     chk.checkNonCyclic(tvar, (TypeVar)tvar.type);
1011                 }
1012             }
1013 
1014             finishClass(tree, env);
1015 
1016             if (allowTypeAnnos) {
1017                 typeAnnotations.organizeTypeAnnotationsSignatures(env, (JCClassDecl)env.tree);
1018                 typeAnnotations.validateTypeAnnotationsSignatures(env, (JCClassDecl)env.tree);
1019             }
1020         }
1021 
1022         DefaultConstructorHelper getDefaultConstructorHelper(Env&lt;AttrContext&gt; env) {
1023             JCClassDecl tree = env.enclClass;
1024             ClassSymbol sym = tree.sym;
1025             DefaultConstructorHelper helper = null;
1026             boolean isClassWithoutInit = (sym.flags() &amp; INTERFACE) == 0 &amp;&amp; !TreeInfo.hasConstructors(tree.defs);
1027             boolean isRecord = sym.isRecord();
1028             if (isClassWithoutInit &amp;&amp; !isRecord) {
1029                 helper = new BasicConstructorHelper(sym);
1030                 if (sym.name.isEmpty()) {
1031                     JCNewClass nc = (JCNewClass)env.next.tree;
1032                     if (nc.constructor != null) {
1033                         if (nc.constructor.kind != ERR) {
1034                             helper = new AnonClassConstructorHelper(sym, (MethodSymbol)nc.constructor, nc.encl);
1035                         } else {
1036                             helper = null;
1037                         }
1038                     }
1039                 }
1040             }
1041             if (isRecord) {
1042                 JCMethodDecl canonicalInit = null;
1043                 if (isClassWithoutInit || (canonicalInit = getCanonicalConstructorDecl(env.enclClass)) == null) {
1044                     helper = new RecordConstructorHelper(sym, TreeInfo.recordFields(tree));
1045                 }
1046                 if (canonicalInit != null) {
1047                     canonicalInit.sym.flags_field |= Flags.RECORD;
1048                 }
1049             }
1050             return helper;
1051         }
1052 
1053         /** Enter members for a class.
1054          */
1055         void finishClass(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
1056             if ((tree.mods.flags &amp; Flags.ENUM) != 0 &amp;&amp;
1057                 !tree.sym.type.hasTag(ERROR) &amp;&amp;
1058                 (types.supertype(tree.sym.type).tsym.flags() &amp; Flags.ENUM) == 0) {
1059                 addEnumMembers(tree, env);
1060             }
1061             boolean isRecord = (tree.sym.flags_field &amp; RECORD) != 0;
1062             List&lt;JCTree&gt; alreadyEntered = null;
1063             if (isRecord) {
1064                 alreadyEntered = List.convert(JCTree.class, TreeInfo.recordFields(tree));
1065                 alreadyEntered = alreadyEntered.prependList(tree.defs.stream()
1066                         .filter(t -&gt; TreeInfo.isConstructor(t) &amp;&amp;
1067                                 ((JCMethodDecl)t).sym != null &amp;&amp;
1068                                 (((JCMethodDecl)t).sym.flags_field &amp; Flags.GENERATEDCONSTR) == 0).collect(List.collector()));
1069             }
1070             List&lt;JCTree&gt; defsToEnter = isRecord ?
1071                     tree.defs.diff(alreadyEntered) : tree.defs;
1072             memberEnter.memberEnter(defsToEnter, env);
1073             if (isRecord) {
1074                 addRecordMembersIfNeeded(tree, env);
1075             }
<a name="4" id="anc4"></a>


1076             if (tree.sym.isAnnotationType()) {
1077                 Assert.check(tree.sym.isCompleted());
1078                 tree.sym.setAnnotationTypeMetadata(new AnnotationTypeMetadata(tree.sym, annotate.annotationTypeSourceCompleter()));
1079             }
1080         }
1081 
1082         private void addAccessor(JCVariableDecl tree, Env&lt;AttrContext&gt; env) {
1083             MethodSymbol implSym = lookupMethod(env.enclClass.sym, tree.sym.name, List.nil());
1084             RecordComponent rec = ((ClassSymbol) tree.sym.owner).getRecordComponent(tree.sym);
1085             if (implSym == null || (implSym.flags_field &amp; GENERATED_MEMBER) != 0) {
1086                 /* here we are pushing the annotations present in the corresponding field down to the accessor
1087                  * it could be that some of those annotations are not applicable to the accessor, they will be striped
1088                  * away later at Check::validateAnnotation
1089                  */
1090                 List&lt;JCAnnotation&gt; originalAnnos = rec.getOriginalAnnos().isEmpty() ?
1091                         rec.getOriginalAnnos() :
1092                         new TreeCopier&lt;JCTree&gt;(make.at(tree.pos)).copy(rec.getOriginalAnnos());
1093                 JCMethodDecl getter = make.at(tree.pos).
1094                         MethodDef(
1095                                 make.Modifiers(PUBLIC | Flags.GENERATED_MEMBER, originalAnnos),
1096                           tree.sym.name,
1097                           /* we need to special case for the case when the user declared the type as an ident
1098                            * if we don&#39;t do that then we can have issues if type annotations are applied to the
1099                            * return type: javac issues an error if a type annotation is applied to java.lang.String
1100                            * but applying a type annotation to String is kosher
1101                            */
1102                           tree.vartype.hasTag(IDENT) ? make.Ident(tree.vartype.type.tsym) : make.Type(tree.sym.type),
1103                           List.nil(),
1104                           List.nil(),
1105                           List.nil(), // thrown
1106                           null,
1107                           null);
1108                 memberEnter.memberEnter(getter, env);
1109                 rec.accessor = getter.sym;
1110                 rec.accessorMeth = getter;
1111             } else if (implSym != null) {
1112                 rec.accessor = implSym;
1113             }
1114         }
1115 
1116         /** Add the implicit members for an enum type
1117          *  to the symbol table.
1118          */
1119         private void addEnumMembers(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
1120             JCExpression valuesType = make.Type(new ArrayType(tree.sym.type, syms.arrayClass));
1121 
1122             JCMethodDecl values = make.
1123                 MethodDef(make.Modifiers(Flags.PUBLIC|Flags.STATIC),
1124                           names.values,
1125                           valuesType,
1126                           List.nil(),
1127                           List.nil(),
1128                           List.nil(),
1129                           null,
1130                           null);
1131             memberEnter.memberEnter(values, env);
1132 
1133             JCMethodDecl valueOf = make.
1134                 MethodDef(make.Modifiers(Flags.PUBLIC|Flags.STATIC),
1135                           names.valueOf,
1136                           make.Type(tree.sym.type),
1137                           List.nil(),
1138                           List.of(make.VarDef(make.Modifiers(Flags.PARAMETER |
1139                                                              Flags.MANDATED),
1140                                                 names.fromString(&quot;name&quot;),
1141                                                 make.Type(syms.stringType), null)),
1142                           List.nil(),
1143                           null,
1144                           null);
1145             memberEnter.memberEnter(valueOf, env);
1146         }
1147 
<a name="5" id="anc5"></a>























































































1148         JCMethodDecl getCanonicalConstructorDecl(JCClassDecl tree) {
1149             // let&#39;s check if there is a constructor with exactly the same arguments as the record components
1150             List&lt;Type&gt; recordComponentErasedTypes = types.erasure(TreeInfo.recordFields(tree).map(vd -&gt; vd.sym.type));
1151             JCMethodDecl canonicalDecl = null;
1152             for (JCTree def : tree.defs) {
1153                 if (TreeInfo.isConstructor(def)) {
1154                     JCMethodDecl mdecl = (JCMethodDecl)def;
1155                     if (types.isSameTypes(types.erasure(mdecl.params.stream().map(v -&gt; v.sym.type).collect(List.collector())), recordComponentErasedTypes)) {
1156                         canonicalDecl = mdecl;
1157                         break;
1158                     }
1159                 }
1160             }
1161             return canonicalDecl;
1162         }
1163 
1164         /** Add the implicit members for a record
1165          *  to the symbol table.
1166          */
1167         private void addRecordMembersIfNeeded(JCClassDecl tree, Env&lt;AttrContext&gt; env) {
1168             if (lookupMethod(tree.sym, names.toString, List.nil()) == null) {
1169                 JCMethodDecl toString = make.
1170                     MethodDef(make.Modifiers(Flags.PUBLIC | Flags.RECORD | Flags.FINAL | Flags.GENERATED_MEMBER),
1171                               names.toString,
1172                               make.Type(syms.stringType),
1173                               List.nil(),
1174                               List.nil(),
1175                               List.nil(),
1176                               null,
1177                               null);
1178                 memberEnter.memberEnter(toString, env);
1179             }
1180 
1181             if (lookupMethod(tree.sym, names.hashCode, List.nil()) == null) {
1182                 JCMethodDecl hashCode = make.
1183                     MethodDef(make.Modifiers(Flags.PUBLIC | Flags.RECORD | Flags.FINAL | Flags.GENERATED_MEMBER),
1184                               names.hashCode,
1185                               make.Type(syms.intType),
1186                               List.nil(),
1187                               List.nil(),
1188                               List.nil(),
1189                               null,
1190                               null);
1191                 memberEnter.memberEnter(hashCode, env);
1192             }
1193 
1194             if (lookupMethod(tree.sym, names.equals, List.of(syms.objectType)) == null) {
1195                 JCMethodDecl equals = make.
1196                     MethodDef(make.Modifiers(Flags.PUBLIC | Flags.RECORD | Flags.FINAL | Flags.GENERATED_MEMBER),
1197                               names.equals,
1198                               make.Type(syms.booleanType),
1199                               List.nil(),
1200                               List.of(make.VarDef(make.Modifiers(Flags.PARAMETER),
1201                                                 names.fromString(&quot;o&quot;),
1202                                                 make.Type(syms.objectType), null)),
1203                               List.nil(),
1204                               null,
1205                               null);
1206                 memberEnter.memberEnter(equals, env);
1207             }
1208 
1209             // fields can&#39;t be varargs, lets remove the flag
1210             List&lt;JCVariableDecl&gt; recordFields = TreeInfo.recordFields(tree);
1211             for (JCVariableDecl field: recordFields) {
1212                 field.mods.flags &amp;= ~Flags.VARARGS;
1213                 field.sym.flags_field &amp;= ~Flags.VARARGS;
1214             }
1215             // now lets add the accessors
1216             recordFields.stream()
1217                     .filter(vd -&gt; (lookupMethod(syms.objectType.tsym, vd.name, List.nil()) == null))
1218                     .forEach(vd -&gt; addAccessor(vd, env));
1219         }
1220     }
1221 
1222     private MethodSymbol lookupMethod(TypeSymbol tsym, Name name, List&lt;Type&gt; argtypes) {
1223         for (Symbol s : tsym.members().getSymbolsByName(name, s -&gt; s.kind == MTH)) {
1224             if (types.isSameTypes(s.type.getParameterTypes(), argtypes)) {
1225                 return (MethodSymbol) s;
1226             }
1227         }
1228         return null;
1229     }
1230 
1231 /* ***************************************************************************
1232  * tree building
1233  ****************************************************************************/
1234 
1235     interface DefaultConstructorHelper {
1236        Type constructorType();
1237        MethodSymbol constructorSymbol();
1238        Type enclosingType();
1239        TypeSymbol owner();
1240        List&lt;Name&gt; superArgs();
1241        default JCMethodDecl finalAdjustment(JCMethodDecl md) { return md; }
1242     }
1243 
1244     class BasicConstructorHelper implements DefaultConstructorHelper {
1245 
1246         TypeSymbol owner;
1247         Type constructorType;
1248         MethodSymbol constructorSymbol;
1249 
1250         BasicConstructorHelper(TypeSymbol owner) {
1251             this.owner = owner;
1252         }
1253 
1254         @Override
1255         public Type constructorType() {
1256             if (constructorType == null) {
1257                 constructorType = new MethodType(List.nil(), syms.voidType, List.nil(), syms.methodClass);
1258             }
1259             return constructorType;
1260         }
1261 
1262         @Override
1263         public MethodSymbol constructorSymbol() {
1264             if (constructorSymbol == null) {
1265                 long flags;
1266                 if ((owner().flags() &amp; ENUM) != 0 &amp;&amp;
1267                     (types.supertype(owner().type).tsym == syms.enumSym)) {
1268                     // constructors of true enums are private
1269                     flags = PRIVATE | GENERATEDCONSTR;
1270                 } else {
1271                     flags = (owner().flags() &amp; AccessFlags) | GENERATEDCONSTR;
1272                 }
1273                 constructorSymbol = new MethodSymbol(flags, names.init,
1274                     constructorType(), owner());
1275             }
1276             return constructorSymbol;
1277         }
1278 
1279         @Override
1280         public Type enclosingType() {
1281             return Type.noType;
1282     }
1283 
1284         @Override
1285         public TypeSymbol owner() {
1286             return owner;
1287         }
1288 
1289         @Override
1290         public List&lt;Name&gt; superArgs() {
1291             return List.nil();
1292             }
1293     }
1294 
1295     class AnonClassConstructorHelper extends BasicConstructorHelper {
1296 
1297         MethodSymbol constr;
1298         Type encl;
1299         boolean based = false;
1300 
1301         AnonClassConstructorHelper(TypeSymbol owner, MethodSymbol constr, JCExpression encl) {
1302             super(owner);
1303             this.constr = constr;
1304             this.encl = encl != null ? encl.type : Type.noType;
1305         }
1306 
1307         @Override
1308         public Type constructorType() {
1309             if (constructorType == null) {
1310                 Type ctype = types.memberType(owner.type, constr);
1311                 if (!enclosingType().hasTag(NONE)) {
1312                     ctype = types.createMethodTypeWithParameters(ctype, ctype.getParameterTypes().prepend(enclosingType()));
1313                     based = true;
1314                 }
1315                 constructorType = ctype;
1316             }
1317             return constructorType;
1318         }
1319 
1320         @Override
1321         public MethodSymbol constructorSymbol() {
1322             MethodSymbol csym = super.constructorSymbol();
1323             csym.flags_field |= ANONCONSTR | (constr.flags() &amp; VARARGS);
1324             csym.flags_field |= based ? ANONCONSTR_BASED : 0;
1325             ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
1326             List&lt;Type&gt; argtypes = constructorType().getParameterTypes();
1327             if (!enclosingType().hasTag(NONE)) {
1328                 argtypes = argtypes.tail;
1329                 params = params.prepend(new VarSymbol(PARAMETER, make.paramName(0), enclosingType(), csym));
1330             }
1331             if (constr.params != null) {
1332                 for (VarSymbol p : constr.params) {
1333                     params.add(new VarSymbol(PARAMETER | p.flags(), p.name, argtypes.head, csym));
1334                     argtypes = argtypes.tail;
1335                 }
1336             }
1337             csym.params = params.toList();
1338             return csym;
1339         }
1340 
1341         @Override
1342         public Type enclosingType() {
1343             return encl;
1344         }
1345 
1346         @Override
1347         public List&lt;Name&gt; superArgs() {
1348             List&lt;JCVariableDecl&gt; params = make.Params(constructorType().getParameterTypes(), constructorSymbol());
1349             if (!enclosingType().hasTag(NONE)) {
1350                 params = params.tail;
1351             }
1352             return params.map(vd -&gt; vd.name);
1353         }
1354     }
1355 
1356     class RecordConstructorHelper extends BasicConstructorHelper {
1357         boolean lastIsVarargs;
1358         List&lt;JCVariableDecl&gt; recordFieldDecls;
1359 
1360         RecordConstructorHelper(ClassSymbol owner, List&lt;JCVariableDecl&gt; recordFieldDecls) {
1361             super(owner);
1362             this.recordFieldDecls = recordFieldDecls;
1363             this.lastIsVarargs = owner.getRecordComponents().stream().anyMatch(rc -&gt; rc.isVarargs());
1364         }
1365 
1366         @Override
1367         public Type constructorType() {
1368             if (constructorType == null) {
1369                 ListBuffer&lt;Type&gt; argtypes = new ListBuffer&lt;&gt;();
1370                 JCVariableDecl lastField = recordFieldDecls.last();
1371                 for (JCVariableDecl field : recordFieldDecls) {
1372                     argtypes.add(field == lastField &amp;&amp; lastIsVarargs ? types.elemtype(field.sym.type) : field.sym.type);
1373                 }
1374 
1375                 constructorType = new MethodType(argtypes.toList(), syms.voidType, List.nil(), syms.methodClass);
1376             }
1377             return constructorType;
1378         }
1379 
1380         @Override
1381         public MethodSymbol constructorSymbol() {
1382             MethodSymbol csym = super.constructorSymbol();
1383             /* if we have to generate a default constructor for records we will treat it as the compact one
1384              * to trigger field initialization later on
1385              */
1386             csym.flags_field |= Flags.COMPACT_RECORD_CONSTRUCTOR | GENERATEDCONSTR;
1387             ListBuffer&lt;VarSymbol&gt; params = new ListBuffer&lt;&gt;();
1388             JCVariableDecl lastField = recordFieldDecls.last();
1389             for (JCVariableDecl field : recordFieldDecls) {
1390                 params.add(new VarSymbol(
1391                         GENERATED_MEMBER | PARAMETER | RECORD | (field == lastField &amp;&amp; lastIsVarargs ? Flags.VARARGS : 0),
1392                         field.name, field.sym.type, csym));
1393             }
1394             csym.params = params.toList();
1395             csym.flags_field |= RECORD;
1396             return csym;
1397         }
1398 
1399         @Override
1400         public JCMethodDecl finalAdjustment(JCMethodDecl md) {
1401             List&lt;JCVariableDecl&gt; tmpRecordFieldDecls = recordFieldDecls;
1402             for (JCVariableDecl arg : md.params) {
1403                 /* at this point we are passing all the annotations in the field to the corresponding
1404                  * parameter in the constructor.
1405                  */
1406                 RecordComponent rc = ((ClassSymbol) owner).getRecordComponent(arg.sym);
1407                 arg.mods.annotations = rc.getOriginalAnnos().isEmpty() ?
1408                         List.nil() :
1409                         new TreeCopier&lt;JCTree&gt;(make.at(arg.pos)).copy(rc.getOriginalAnnos());
1410                 arg.vartype = tmpRecordFieldDecls.head.vartype;
1411                 tmpRecordFieldDecls = tmpRecordFieldDecls.tail;
1412             }
1413             return md;
1414         }
1415     }
1416 
1417     JCTree defaultConstructor(TreeMaker make, DefaultConstructorHelper helper) {
1418         Type initType = helper.constructorType();
1419         MethodSymbol initSym = helper.constructorSymbol();
1420         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
1421         if (helper.owner().type != syms.objectType) {
1422             JCExpression meth;
1423             if (!helper.enclosingType().hasTag(NONE)) {
1424                 meth = make.Select(make.Ident(initSym.params.head), names._super);
1425             } else {
1426                 meth = make.Ident(names._super);
1427             }
1428             List&lt;JCExpression&gt; typeargs = initType.getTypeArguments().nonEmpty() ?
1429                     make.Types(initType.getTypeArguments()) : null;
1430             JCStatement superCall = make.Exec(make.Apply(typeargs, meth, helper.superArgs().map(make::Ident)));
1431             stats.add(superCall);
1432         }
1433         JCMethodDecl result = make.MethodDef(initSym, make.Block(0, stats.toList()));
1434         return helper.finalAdjustment(result);
1435     }
1436 
1437     /**
1438      * Mark sym deprecated if annotations contain @Deprecated annotation.
1439      */
1440     public void markDeprecated(Symbol sym, List&lt;JCAnnotation&gt; annotations, Env&lt;AttrContext&gt; env) {
1441         // In general, we cannot fully process annotations yet,  but we
1442         // can attribute the annotation types and then check to see if the
1443         // @Deprecated annotation is present.
1444         attr.attribAnnotationTypes(annotations, env);
1445         handleDeprecatedAnnotations(annotations, sym);
1446     }
1447 
1448     /**
1449      * If a list of annotations contains a reference to java.lang.Deprecated,
1450      * set the DEPRECATED flag.
1451      * If the annotation is marked forRemoval=true, also set DEPRECATED_REMOVAL.
1452      **/
1453     private void handleDeprecatedAnnotations(List&lt;JCAnnotation&gt; annotations, Symbol sym) {
1454         for (List&lt;JCAnnotation&gt; al = annotations; !al.isEmpty(); al = al.tail) {
1455             JCAnnotation a = al.head;
1456             if (a.annotationType.type == syms.deprecatedType) {
1457                 sym.flags_field |= (Flags.DEPRECATED | Flags.DEPRECATED_ANNOTATION);
1458                 setFlagIfAttributeTrue(a, sym, names.forRemoval, DEPRECATED_REMOVAL);
1459             } else if (a.annotationType.type == syms.previewFeatureType) {
1460                 sym.flags_field |= Flags.PREVIEW_API;
1461                 setFlagIfAttributeTrue(a, sym, names.essentialAPI, PREVIEW_ESSENTIAL_API);
1462             }
1463         }
1464     }
1465     //where:
1466         private void setFlagIfAttributeTrue(JCAnnotation a, Symbol sym, Name attribute, long flag) {
1467             a.args.stream()
1468                     .filter(e -&gt; e.hasTag(ASSIGN))
1469                     .map(e -&gt; (JCAssign) e)
1470                     .filter(assign -&gt; TreeInfo.name(assign.lhs) == attribute)
1471                     .findFirst()
1472                     .ifPresent(assign -&gt; {
1473                         JCExpression rhs = TreeInfo.skipParens(assign.rhs);
1474                         if (rhs.hasTag(LITERAL)
1475                                 &amp;&amp; Boolean.TRUE.equals(((JCLiteral) rhs).getValue())) {
1476                             sym.flags_field |= flag;
1477                         }
1478                     });
1479         }
1480 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
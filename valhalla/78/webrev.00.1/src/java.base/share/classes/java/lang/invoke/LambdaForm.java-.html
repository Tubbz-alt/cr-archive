<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/lang/invoke/LambdaForm.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.perf.PerfCounter;
  29 import jdk.internal.vm.annotation.DontInline;
  30 import jdk.internal.vm.annotation.Hidden;
  31 import jdk.internal.vm.annotation.Stable;
  32 import sun.invoke.util.Wrapper;
  33 
  34 import java.lang.annotation.ElementType;
  35 import java.lang.annotation.Retention;
  36 import java.lang.annotation.RetentionPolicy;
  37 import java.lang.annotation.Target;
  38 import java.lang.reflect.Method;
  39 import java.util.Arrays;
  40 import java.util.HashMap;
  41 
  42 import static java.lang.invoke.LambdaForm.BasicType.*;
  43 import static java.lang.invoke.MethodHandleNatives.Constants.REF_invokeStatic;
  44 import static java.lang.invoke.MethodHandleStatics.*;
  45 
  46 /**
  47  * The symbolic, non-executable form of a method handle&#39;s invocation semantics.
  48  * It consists of a series of names.
  49  * The first N (N=arity) names are parameters,
  50  * while any remaining names are temporary values.
  51  * Each temporary specifies the application of a function to some arguments.
  52  * The functions are method handles, while the arguments are mixes of
  53  * constant values and local names.
  54  * The result of the lambda is defined as one of the names, often the last one.
  55  * &lt;p&gt;
  56  * Here is an approximate grammar:
  57  * &lt;blockquote&gt;&lt;pre&gt;{@code
  58  * LambdaForm = &quot;(&quot; ArgName* &quot;)=&gt;{&quot; TempName* Result &quot;}&quot;
  59  * ArgName = &quot;a&quot; N &quot;:&quot; T
  60  * TempName = &quot;t&quot; N &quot;:&quot; T &quot;=&quot; Function &quot;(&quot; Argument* &quot;);&quot;
  61  * Function = ConstantValue
  62  * Argument = NameRef | ConstantValue
  63  * Result = NameRef | &quot;void&quot;
  64  * NameRef = &quot;a&quot; N | &quot;t&quot; N
  65  * N = (any whole number)
  66  * T = &quot;L&quot; | &quot;I&quot; | &quot;J&quot; | &quot;F&quot; | &quot;D&quot; | &quot;V&quot;
  67  * }&lt;/pre&gt;&lt;/blockquote&gt;
  68  * Names are numbered consecutively from left to right starting at zero.
  69  * (The letters are merely a taste of syntax sugar.)
  70  * Thus, the first temporary (if any) is always numbered N (where N=arity).
  71  * Every occurrence of a name reference in an argument list must refer to
  72  * a name previously defined within the same lambda.
  73  * A lambda has a void result if and only if its result index is -1.
  74  * If a temporary has the type &quot;V&quot;, it cannot be the subject of a NameRef,
  75  * even though possesses a number.
  76  * Note that all reference types are erased to &quot;L&quot;, which stands for {@code Object}.
  77  * All subword types (boolean, byte, short, char) are erased to &quot;I&quot; which is {@code int}.
  78  * The other types stand for the usual primitive types.
  79  * &lt;p&gt;
  80  * Function invocation closely follows the static rules of the Java verifier.
  81  * Arguments and return values must exactly match when their &quot;Name&quot; types are
  82  * considered.
  83  * Conversions are allowed only if they do not change the erased type.
  84  * &lt;ul&gt;
  85  * &lt;li&gt;L = Object: casts are used freely to convert into and out of reference types
  86  * &lt;li&gt;I = int: subword types are forcibly narrowed when passed as arguments (see {@code explicitCastArguments})
  87  * &lt;li&gt;J = long: no implicit conversions
  88  * &lt;li&gt;F = float: no implicit conversions
  89  * &lt;li&gt;D = double: no implicit conversions
  90  * &lt;li&gt;V = void: a function result may be void if and only if its Name is of type &quot;V&quot;
  91  * &lt;/ul&gt;
  92  * Although implicit conversions are not allowed, explicit ones can easily be
  93  * encoded by using temporary expressions which call type-transformed identity functions.
  94  * &lt;p&gt;
  95  * Examples:
  96  * &lt;blockquote&gt;&lt;pre&gt;{@code
  97  * (a0:J)=&gt;{ a0 }
  98  *     == identity(long)
  99  * (a0:I)=&gt;{ t1:V = System.out#println(a0); void }
 100  *     == System.out#println(int)
 101  * (a0:L)=&gt;{ t1:V = System.out#println(a0); a0 }
 102  *     == identity, with printing side-effect
 103  * (a0:L, a1:L)=&gt;{ t2:L = BoundMethodHandle#argument(a0);
 104  *                 t3:L = BoundMethodHandle#target(a0);
 105  *                 t4:L = MethodHandle#invoke(t3, t2, a1); t4 }
 106  *     == general invoker for unary insertArgument combination
 107  * (a0:L, a1:L)=&gt;{ t2:L = FilterMethodHandle#filter(a0);
 108  *                 t3:L = MethodHandle#invoke(t2, a1);
 109  *                 t4:L = FilterMethodHandle#target(a0);
 110  *                 t5:L = MethodHandle#invoke(t4, t3); t5 }
 111  *     == general invoker for unary filterArgument combination
 112  * (a0:L, a1:L)=&gt;{ ...(same as previous example)...
 113  *                 t5:L = MethodHandle#invoke(t4, t3, a1); t5 }
 114  *     == general invoker for unary/unary foldArgument combination
 115  * (a0:L, a1:I)=&gt;{ t2:I = identity(long).asType((int)-&gt;long)(a1); t2 }
 116  *     == invoker for identity method handle which performs i2l
 117  * (a0:L, a1:L)=&gt;{ t2:L = BoundMethodHandle#argument(a0);
 118  *                 t3:L = Class#cast(t2,a1); t3 }
 119  *     == invoker for identity method handle which performs cast
 120  * }&lt;/pre&gt;&lt;/blockquote&gt;
 121  * &lt;p&gt;
 122  * @author John Rose, JSR 292 EG
 123  */
 124 class LambdaForm {
 125     final int arity;
 126     final int result;
 127     final boolean forceInline;
 128     final MethodHandle customized;
 129     @Stable final Name[] names;
 130     final Kind kind;
 131     MemberName vmentry;   // low-level behavior, or null if not yet prepared
 132     private boolean isCompiled;
 133 
 134     // Either a LambdaForm cache (managed by LambdaFormEditor) or a link to uncustomized version (for customized LF)
 135     volatile Object transformCache;
 136 
 137     public static final int VOID_RESULT = -1, LAST_RESULT = -2;
 138 
 139     enum BasicType {
 140         L_TYPE(&#39;L&#39;, Object.class, Wrapper.OBJECT),  // all reference types
 141         I_TYPE(&#39;I&#39;, int.class,    Wrapper.INT),
 142         J_TYPE(&#39;J&#39;, long.class,   Wrapper.LONG),
 143         F_TYPE(&#39;F&#39;, float.class,  Wrapper.FLOAT),
 144         D_TYPE(&#39;D&#39;, double.class, Wrapper.DOUBLE),  // all primitive types
 145         V_TYPE(&#39;V&#39;, void.class,   Wrapper.VOID);    // not valid in all contexts
 146 
 147         static final @Stable BasicType[] ALL_TYPES = BasicType.values();
 148         static final @Stable BasicType[] ARG_TYPES = Arrays.copyOf(ALL_TYPES, ALL_TYPES.length-1);
 149 
 150         static final int ARG_TYPE_LIMIT = ARG_TYPES.length;
 151         static final int TYPE_LIMIT = ALL_TYPES.length;
 152 
 153         // Derived int constants, which (unlike the enums) can be constant folded.
 154         // We can remove them when JDK-8161245 is fixed.
 155         static final byte
 156                 L_TYPE_NUM = (byte) L_TYPE.ordinal(),
 157                 I_TYPE_NUM = (byte) I_TYPE.ordinal(),
 158                 J_TYPE_NUM = (byte) J_TYPE.ordinal(),
 159                 F_TYPE_NUM = (byte) F_TYPE.ordinal(),
 160                 D_TYPE_NUM = (byte) D_TYPE.ordinal(),
 161                 V_TYPE_NUM = (byte) V_TYPE.ordinal();
 162 
 163         final char btChar;
 164         final Class&lt;?&gt; btClass;
 165         final Wrapper btWrapper;
 166 
 167         private BasicType(char btChar, Class&lt;?&gt; btClass, Wrapper wrapper) {
 168             this.btChar = btChar;
 169             this.btClass = btClass;
 170             this.btWrapper = wrapper;
 171         }
 172 
 173         char basicTypeChar() {
 174             return btChar;
 175         }
 176         Class&lt;?&gt; basicTypeClass() {
 177             return btClass;
 178         }
 179         Wrapper basicTypeWrapper() {
 180             return btWrapper;
 181         }
 182         int basicTypeSlots() {
 183             return btWrapper.stackSlots();
 184         }
 185 
 186         static BasicType basicType(byte type) {
 187             return ALL_TYPES[type];
 188         }
 189         static BasicType basicType(char type) {
 190             switch (type) {
 191                 case &#39;L&#39;: return L_TYPE;
 192                 case &#39;I&#39;: return I_TYPE;
 193                 case &#39;J&#39;: return J_TYPE;
 194                 case &#39;F&#39;: return F_TYPE;
 195                 case &#39;D&#39;: return D_TYPE;
 196                 case &#39;V&#39;: return V_TYPE;
 197                 // all subword types are represented as ints
 198                 case &#39;Z&#39;:
 199                 case &#39;B&#39;:
 200                 case &#39;S&#39;:
 201                 case &#39;C&#39;:
 202                     return I_TYPE;
 203                 default:
 204                     throw newInternalError(&quot;Unknown type char: &#39;&quot;+type+&quot;&#39;&quot;);
 205             }
 206         }
 207         static BasicType basicType(Wrapper type) {
 208             char c = type.basicTypeChar();
 209             return basicType(c);
 210         }
 211         static BasicType basicType(Class&lt;?&gt; type) {
 212             if (!type.isPrimitive())  return L_TYPE;
 213             return basicType(Wrapper.forPrimitiveType(type));
 214         }
 215         static BasicType[] basicTypes(String types) {
 216             BasicType[] btypes = new BasicType[types.length()];
 217             for (int i = 0; i &lt; btypes.length; i++) {
 218                 btypes[i] = basicType(types.charAt(i));
 219             }
 220             return btypes;
 221         }
 222         static String basicTypeDesc(BasicType[] types) {
 223             if (types == null) {
 224                 return null;
 225             }
 226             if (types.length == 0) {
 227                 return &quot;&quot;;
 228             }
 229             StringBuilder sb = new StringBuilder();
 230             for (BasicType bt : types) {
 231                 sb.append(bt.basicTypeChar());
 232             }
 233             return sb.toString();
 234         }
 235         static int[] basicTypeOrds(BasicType[] types) {
 236             if (types == null) {
 237                 return null;
 238             }
 239             int[] a = new int[types.length];
 240             for(int i = 0; i &lt; types.length; ++i) {
 241                 a[i] = types[i].ordinal();
 242             }
 243             return a;
 244         }
 245 
 246         static char basicTypeChar(Class&lt;?&gt; type) {
 247             return basicType(type).btChar;
 248         }
 249 
 250         static byte[] basicTypesOrd(Class&lt;?&gt;[] types) {
 251             byte[] ords = new byte[types.length];
 252             for (int i = 0; i &lt; ords.length; i++) {
 253                 ords[i] = (byte)basicType(types[i]).ordinal();
 254             }
 255             return ords;
 256         }
 257 
 258         static boolean isBasicTypeChar(char c) {
 259             return &quot;LIJFDV&quot;.indexOf(c) &gt;= 0;
 260         }
 261         static boolean isArgBasicTypeChar(char c) {
 262             return &quot;LIJFD&quot;.indexOf(c) &gt;= 0;
 263         }
 264 
 265         static { assert(checkBasicType()); }
 266         private static boolean checkBasicType() {
 267             for (int i = 0; i &lt; ARG_TYPE_LIMIT; i++) {
 268                 assert ARG_TYPES[i].ordinal() == i;
 269                 assert ARG_TYPES[i] == ALL_TYPES[i];
 270             }
 271             for (int i = 0; i &lt; TYPE_LIMIT; i++) {
 272                 assert ALL_TYPES[i].ordinal() == i;
 273             }
 274             assert ALL_TYPES[TYPE_LIMIT - 1] == V_TYPE;
 275             assert !Arrays.asList(ARG_TYPES).contains(V_TYPE);
 276             return true;
 277         }
 278     }
 279 
 280     enum Kind {
 281         GENERIC(&quot;invoke&quot;),
 282         ZERO(&quot;zero&quot;),
 283         IDENTITY(&quot;identity&quot;),
 284         BOUND_REINVOKER(&quot;BMH.reinvoke&quot;, &quot;reinvoke&quot;),
 285         REINVOKER(&quot;MH.reinvoke&quot;, &quot;reinvoke&quot;),
 286         DELEGATE(&quot;MH.delegate&quot;, &quot;delegate&quot;),
 287         EXACT_LINKER(&quot;MH.invokeExact_MT&quot;, &quot;invokeExact_MT&quot;),
 288         EXACT_INVOKER(&quot;MH.exactInvoker&quot;, &quot;exactInvoker&quot;),
 289         GENERIC_LINKER(&quot;MH.invoke_MT&quot;, &quot;invoke_MT&quot;),
 290         GENERIC_INVOKER(&quot;MH.invoker&quot;, &quot;invoker&quot;),
 291         LINK_TO_TARGET_METHOD(&quot;linkToTargetMethod&quot;),
 292         LINK_TO_CALL_SITE(&quot;linkToCallSite&quot;),
 293         DIRECT_INVOKE_VIRTUAL(&quot;DMH.invokeVirtual&quot;, &quot;invokeVirtual&quot;),
 294         DIRECT_INVOKE_SPECIAL(&quot;DMH.invokeSpecial&quot;, &quot;invokeSpecial&quot;),
 295         DIRECT_INVOKE_SPECIAL_IFC(&quot;DMH.invokeSpecialIFC&quot;, &quot;invokeSpecialIFC&quot;),
 296         DIRECT_INVOKE_STATIC(&quot;DMH.invokeStatic&quot;, &quot;invokeStatic&quot;),
 297         DIRECT_NEW_INVOKE_SPECIAL(&quot;DMH.newInvokeSpecial&quot;, &quot;newInvokeSpecial&quot;),
 298         DIRECT_INVOKE_INTERFACE(&quot;DMH.invokeInterface&quot;, &quot;invokeInterface&quot;),
 299         DIRECT_INVOKE_STATIC_INIT(&quot;DMH.invokeStaticInit&quot;, &quot;invokeStaticInit&quot;),
 300         GET_REFERENCE(&quot;getReference&quot;),
 301         PUT_REFERENCE(&quot;putReference&quot;),
 302         GET_REFERENCE_VOLATILE(&quot;getReferenceVolatile&quot;),
 303         PUT_REFERENCE_VOLATILE(&quot;putReferenceVolatile&quot;),
 304         GET_INT(&quot;getInt&quot;),
 305         PUT_INT(&quot;putInt&quot;),
 306         GET_INT_VOLATILE(&quot;getIntVolatile&quot;),
 307         PUT_INT_VOLATILE(&quot;putIntVolatile&quot;),
 308         GET_BOOLEAN(&quot;getBoolean&quot;),
 309         PUT_BOOLEAN(&quot;putBoolean&quot;),
 310         GET_BOOLEAN_VOLATILE(&quot;getBooleanVolatile&quot;),
 311         PUT_BOOLEAN_VOLATILE(&quot;putBooleanVolatile&quot;),
 312         GET_BYTE(&quot;getByte&quot;),
 313         PUT_BYTE(&quot;putByte&quot;),
 314         GET_BYTE_VOLATILE(&quot;getByteVolatile&quot;),
 315         PUT_BYTE_VOLATILE(&quot;putByteVolatile&quot;),
 316         GET_CHAR(&quot;getChar&quot;),
 317         PUT_CHAR(&quot;putChar&quot;),
 318         GET_CHAR_VOLATILE(&quot;getCharVolatile&quot;),
 319         PUT_CHAR_VOLATILE(&quot;putCharVolatile&quot;),
 320         GET_SHORT(&quot;getShort&quot;),
 321         PUT_SHORT(&quot;putShort&quot;),
 322         GET_SHORT_VOLATILE(&quot;getShortVolatile&quot;),
 323         PUT_SHORT_VOLATILE(&quot;putShortVolatile&quot;),
 324         GET_LONG(&quot;getLong&quot;),
 325         PUT_LONG(&quot;putLong&quot;),
 326         GET_LONG_VOLATILE(&quot;getLongVolatile&quot;),
 327         PUT_LONG_VOLATILE(&quot;putLongVolatile&quot;),
 328         GET_FLOAT(&quot;getFloat&quot;),
 329         PUT_FLOAT(&quot;putFloat&quot;),
 330         GET_FLOAT_VOLATILE(&quot;getFloatVolatile&quot;),
 331         PUT_FLOAT_VOLATILE(&quot;putFloatVolatile&quot;),
 332         GET_DOUBLE(&quot;getDouble&quot;),
 333         PUT_DOUBLE(&quot;putDouble&quot;),
 334         GET_DOUBLE_VOLATILE(&quot;getDoubleVolatile&quot;),
 335         PUT_DOUBLE_VOLATILE(&quot;putDoubleVolatile&quot;),
 336         TRY_FINALLY(&quot;tryFinally&quot;),
 337         COLLECT(&quot;collect&quot;),
 338         CONVERT(&quot;convert&quot;),
 339         SPREAD(&quot;spread&quot;),
 340         LOOP(&quot;loop&quot;),
 341         FIELD(&quot;field&quot;),
 342         GUARD(&quot;guard&quot;),
 343         GUARD_WITH_CATCH(&quot;guardWithCatch&quot;),
 344         VARHANDLE_EXACT_INVOKER(&quot;VH.exactInvoker&quot;),
 345         VARHANDLE_INVOKER(&quot;VH.invoker&quot;, &quot;invoker&quot;),
 346         VARHANDLE_LINKER(&quot;VH.invoke_MT&quot;, &quot;invoke_MT&quot;);
 347 
 348         final String defaultLambdaName;
 349         final String methodName;
 350 
 351         private Kind(String defaultLambdaName) {
 352             this(defaultLambdaName, defaultLambdaName);
 353         }
 354 
 355         private Kind(String defaultLambdaName, String methodName) {
 356             this.defaultLambdaName = defaultLambdaName;
 357             this.methodName = methodName;
 358         }
 359     }
 360 
 361     LambdaForm(int arity, Name[] names, int result) {
 362         this(arity, names, result, /*forceInline=*/true, /*customized=*/null, Kind.GENERIC);
 363     }
 364     LambdaForm(int arity, Name[] names, int result, Kind kind) {
 365         this(arity, names, result, /*forceInline=*/true, /*customized=*/null, kind);
 366     }
 367     LambdaForm(int arity, Name[] names, int result, boolean forceInline, MethodHandle customized) {
 368         this(arity, names, result, forceInline, customized, Kind.GENERIC);
 369     }
 370     LambdaForm(int arity, Name[] names, int result, boolean forceInline, MethodHandle customized, Kind kind) {
 371         assert(namesOK(arity, names));
 372         this.arity = arity;
 373         this.result = fixResult(result, names);
 374         this.names = names.clone();
 375         this.forceInline = forceInline;
 376         this.customized = customized;
 377         this.kind = kind;
 378         int maxOutArity = normalize();
 379         if (maxOutArity &gt; MethodType.MAX_MH_INVOKER_ARITY) {
 380             // Cannot use LF interpreter on very high arity expressions.
 381             assert(maxOutArity &lt;= MethodType.MAX_JVM_ARITY);
 382             compileToBytecode();
 383         }
 384     }
 385     LambdaForm(int arity, Name[] names) {
 386         this(arity, names, LAST_RESULT, /*forceInline=*/true, /*customized=*/null, Kind.GENERIC);
 387     }
 388     LambdaForm(int arity, Name[] names, Kind kind) {
 389         this(arity, names, LAST_RESULT, /*forceInline=*/true, /*customized=*/null, kind);
 390     }
 391     LambdaForm(int arity, Name[] names, boolean forceInline) {
 392         this(arity, names, LAST_RESULT, forceInline, /*customized=*/null, Kind.GENERIC);
 393     }
 394     LambdaForm(int arity, Name[] names, boolean forceInline, Kind kind) {
 395         this(arity, names, LAST_RESULT, forceInline, /*customized=*/null, kind);
 396     }
 397     LambdaForm(Name[] formals, Name[] temps, Name result) {
 398         this(formals.length, buildNames(formals, temps, result), LAST_RESULT, /*forceInline=*/true, /*customized=*/null);
 399     }
 400     LambdaForm(Name[] formals, Name[] temps, Name result, boolean forceInline) {
 401         this(formals.length, buildNames(formals, temps, result), LAST_RESULT, forceInline, /*customized=*/null);
 402     }
 403 
 404     private static Name[] buildNames(Name[] formals, Name[] temps, Name result) {
 405         int arity = formals.length;
 406         int length = arity + temps.length + (result == null ? 0 : 1);
 407         Name[] names = Arrays.copyOf(formals, length);
 408         System.arraycopy(temps, 0, names, arity, temps.length);
 409         if (result != null)
 410             names[length - 1] = result;
 411         return names;
 412     }
 413 
 414     private LambdaForm(MethodType mt) {
 415         // Make a blank lambda form, which returns a constant zero or null.
 416         // It is used as a template for managing the invocation of similar forms that are non-empty.
 417         // Called only from getPreparedForm.
 418         this.arity = mt.parameterCount();
 419         this.result = (mt.returnType() == void.class || mt.returnType() == Void.class) ? -1 : arity;
 420         this.names = buildEmptyNames(arity, mt, result == -1);
 421         this.forceInline = true;
 422         this.customized = null;
 423         this.kind = Kind.ZERO;
 424         assert(nameRefsAreLegal());
 425         assert(isEmpty());
 426         String sig = null;
 427         assert(isValidSignature(sig = basicTypeSignature()));
 428         assert(sig.equals(basicTypeSignature())) : sig + &quot; != &quot; + basicTypeSignature();
 429     }
 430 
 431     private static Name[] buildEmptyNames(int arity, MethodType mt, boolean isVoid) {
 432         Name[] names = arguments(isVoid ? 0 : 1, mt);
 433         if (!isVoid) {
 434             Name zero = new Name(constantZero(basicType(mt.returnType())));
 435             names[arity] = zero.newIndex(arity);
 436         }
 437         return names;
 438     }
 439 
 440     private static int fixResult(int result, Name[] names) {
 441         if (result == LAST_RESULT)
 442             result = names.length - 1;  // might still be void
 443         if (result &gt;= 0 &amp;&amp; names[result].type == V_TYPE)
 444             result = VOID_RESULT;
 445         return result;
 446     }
 447 
 448     static boolean debugNames() {
 449         return DEBUG_NAME_COUNTERS != null;
 450     }
 451 
 452     static void associateWithDebugName(LambdaForm form, String name) {
 453         assert (debugNames());
 454         synchronized (DEBUG_NAMES) {
 455             DEBUG_NAMES.put(form, name);
 456         }
 457     }
 458 
 459     String lambdaName() {
 460         if (DEBUG_NAMES != null) {
 461             synchronized (DEBUG_NAMES) {
 462                 String name = DEBUG_NAMES.get(this);
 463                 if (name == null) {
 464                     name = generateDebugName();
 465                 }
 466                 return name;
 467             }
 468         }
 469         return kind.defaultLambdaName;
 470     }
 471 
 472     private String generateDebugName() {
 473         assert (debugNames());
 474         String debugNameStem = kind.defaultLambdaName;
 475         Integer ctr = DEBUG_NAME_COUNTERS.getOrDefault(debugNameStem, 0);
 476         DEBUG_NAME_COUNTERS.put(debugNameStem, ctr + 1);
 477         StringBuilder buf = new StringBuilder(debugNameStem);
 478         int leadingZero = buf.length();
 479         buf.append((int) ctr);
 480         for (int i = buf.length() - leadingZero; i &lt; 3; i++) {
 481             buf.insert(leadingZero, &#39;0&#39;);
 482         }
 483         buf.append(&#39;_&#39;);
 484         buf.append(basicTypeSignature());
 485         String name = buf.toString();
 486         associateWithDebugName(this, name);
 487         return name;
 488     }
 489 
 490     private static boolean namesOK(int arity, Name[] names) {
 491         for (int i = 0; i &lt; names.length; i++) {
 492             Name n = names[i];
 493             assert(n != null) : &quot;n is null&quot;;
 494             if (i &lt; arity)
 495                 assert( n.isParam()) : n + &quot; is not param at &quot; + i;
 496             else
 497                 assert(!n.isParam()) : n + &quot; is param at &quot; + i;
 498         }
 499         return true;
 500     }
 501 
 502     /** Customize LambdaForm for a particular MethodHandle */
 503     LambdaForm customize(MethodHandle mh) {
 504         LambdaForm customForm = new LambdaForm(arity, names, result, forceInline, mh, kind);
 505         if (COMPILE_THRESHOLD &gt;= 0 &amp;&amp; isCompiled) {
 506             // If shared LambdaForm has been compiled, compile customized version as well.
 507             customForm.compileToBytecode();
 508         }
 509         customForm.transformCache = this; // LambdaFormEditor should always use uncustomized form.
 510         return customForm;
 511     }
 512 
 513     /** Get uncustomized flavor of the LambdaForm */
 514     LambdaForm uncustomize() {
 515         if (customized == null) {
 516             return this;
 517         }
 518         assert(transformCache != null); // Customized LambdaForm should always has a link to uncustomized version.
 519         LambdaForm uncustomizedForm = (LambdaForm)transformCache;
 520         if (COMPILE_THRESHOLD &gt;= 0 &amp;&amp; isCompiled) {
 521             // If customized LambdaForm has been compiled, compile uncustomized version as well.
 522             uncustomizedForm.compileToBytecode();
 523         }
 524         return uncustomizedForm;
 525     }
 526 
 527     /** Renumber and/or replace params so that they are interned and canonically numbered.
 528      *  @return maximum argument list length among the names (since we have to pass over them anyway)
 529      */
 530     private int normalize() {
 531         Name[] oldNames = null;
 532         int maxOutArity = 0;
 533         int changesStart = 0;
 534         for (int i = 0; i &lt; names.length; i++) {
 535             Name n = names[i];
 536             if (!n.initIndex(i)) {
 537                 if (oldNames == null) {
 538                     oldNames = names.clone();
 539                     changesStart = i;
 540                 }
 541                 names[i] = n.cloneWithIndex(i);
 542             }
 543             if (n.arguments != null &amp;&amp; maxOutArity &lt; n.arguments.length)
 544                 maxOutArity = n.arguments.length;
 545         }
 546         if (oldNames != null) {
 547             int startFixing = arity;
 548             if (startFixing &lt;= changesStart)
 549                 startFixing = changesStart+1;
 550             for (int i = startFixing; i &lt; names.length; i++) {
 551                 Name fixed = names[i].replaceNames(oldNames, names, changesStart, i);
 552                 names[i] = fixed.newIndex(i);
 553             }
 554         }
 555         assert(nameRefsAreLegal());
 556         int maxInterned = Math.min(arity, INTERNED_ARGUMENT_LIMIT);
 557         boolean needIntern = false;
 558         for (int i = 0; i &lt; maxInterned; i++) {
 559             Name n = names[i], n2 = internArgument(n);
 560             if (n != n2) {
 561                 names[i] = n2;
 562                 needIntern = true;
 563             }
 564         }
 565         if (needIntern) {
 566             for (int i = arity; i &lt; names.length; i++) {
 567                 names[i].internArguments();
 568             }
 569         }
 570         assert(nameRefsAreLegal());
 571         return maxOutArity;
 572     }
 573 
 574     /**
 575      * Check that all embedded Name references are localizable to this lambda,
 576      * and are properly ordered after their corresponding definitions.
 577      * &lt;p&gt;
 578      * Note that a Name can be local to multiple lambdas, as long as
 579      * it possesses the same index in each use site.
 580      * This allows Name references to be freely reused to construct
 581      * fresh lambdas, without confusion.
 582      */
 583     boolean nameRefsAreLegal() {
 584         assert(arity &gt;= 0 &amp;&amp; arity &lt;= names.length);
 585         assert(result &gt;= -1 &amp;&amp; result &lt; names.length);
 586         // Do all names possess an index consistent with their local definition order?
 587         for (int i = 0; i &lt; arity; i++) {
 588             Name n = names[i];
 589             assert(n.index() == i) : Arrays.asList(n.index(), i);
 590             assert(n.isParam());
 591         }
 592         // Also, do all local name references
 593         for (int i = arity; i &lt; names.length; i++) {
 594             Name n = names[i];
 595             assert(n.index() == i);
 596             for (Object arg : n.arguments) {
 597                 if (arg instanceof Name) {
 598                     Name n2 = (Name) arg;
 599                     int i2 = n2.index;
 600                     assert(0 &lt;= i2 &amp;&amp; i2 &lt; names.length) : n.debugString() + &quot;: 0 &lt;= i2 &amp;&amp; i2 &lt; names.length: 0 &lt;= &quot; + i2 + &quot; &lt; &quot; + names.length;
 601                     assert(names[i2] == n2) : Arrays.asList(&quot;-1-&quot;, i, &quot;-2-&quot;, n.debugString(), &quot;-3-&quot;, i2, &quot;-4-&quot;, n2.debugString(), &quot;-5-&quot;, names[i2].debugString(), &quot;-6-&quot;, this);
 602                     assert(i2 &lt; i);  // ref must come after def!
 603                 }
 604             }
 605         }
 606         return true;
 607     }
 608 
 609     /** Invoke this form on the given arguments. */
 610     // final Object invoke(Object... args) throws Throwable {
 611     //     // NYI: fit this into the fast path?
 612     //     return interpretWithArguments(args);
 613     // }
 614 
 615     /** Report the return type. */
 616     BasicType returnType() {
 617         if (result &lt; 0)  return V_TYPE;
 618         Name n = names[result];
 619         return n.type;
 620     }
 621 
 622     /** Report the N-th argument type. */
 623     BasicType parameterType(int n) {
 624         return parameter(n).type;
 625     }
 626 
 627     /** Report the N-th argument name. */
 628     Name parameter(int n) {
 629         assert(n &lt; arity);
 630         Name param = names[n];
 631         assert(param.isParam());
 632         return param;
 633     }
 634 
 635     /** Report the N-th argument type constraint. */
 636     Object parameterConstraint(int n) {
 637         return parameter(n).constraint;
 638     }
 639 
 640     /** Report the arity. */
 641     int arity() {
 642         return arity;
 643     }
 644 
 645     /** Report the number of expressions (non-parameter names). */
 646     int expressionCount() {
 647         return names.length - arity;
 648     }
 649 
 650     /** Return the method type corresponding to my basic type signature. */
 651     MethodType methodType() {
 652         Class&lt;?&gt;[] ptypes = new Class&lt;?&gt;[arity];
 653         for (int i = 0; i &lt; arity; ++i) {
 654             ptypes[i] = parameterType(i).btClass;
 655         }
 656         return MethodType.makeImpl(returnType().btClass, ptypes, true);
 657     }
 658 
 659     /** Return ABC_Z, where the ABC are parameter type characters, and Z is the return type character. */
 660     final String basicTypeSignature() {
 661         StringBuilder buf = new StringBuilder(arity() + 3);
 662         for (int i = 0, a = arity(); i &lt; a; i++)
 663             buf.append(parameterType(i).basicTypeChar());
 664         return buf.append(&#39;_&#39;).append(returnType().basicTypeChar()).toString();
 665     }
 666     static int signatureArity(String sig) {
 667         assert(isValidSignature(sig));
 668         return sig.indexOf(&#39;_&#39;);
 669     }
 670     static BasicType signatureReturn(String sig) {
 671         return basicType(sig.charAt(signatureArity(sig) + 1));
 672     }
 673     static boolean isValidSignature(String sig) {
 674         int arity = sig.indexOf(&#39;_&#39;);
 675         if (arity &lt; 0)  return false;  // must be of the form *_*
 676         int siglen = sig.length();
 677         if (siglen != arity + 2)  return false;  // *_X
 678         for (int i = 0; i &lt; siglen; i++) {
 679             if (i == arity)  continue;  // skip &#39;_&#39;
 680             char c = sig.charAt(i);
 681             if (c == &#39;V&#39;)
 682                 return (i == siglen - 1 &amp;&amp; arity == siglen - 2);
 683             if (!isArgBasicTypeChar(c))  return false; // must be [LIJFD]
 684         }
 685         return true;  // [LIJFD]*_[LIJFDV]
 686     }
 687     static MethodType signatureType(String sig) {
 688         Class&lt;?&gt;[] ptypes = new Class&lt;?&gt;[signatureArity(sig)];
 689         for (int i = 0; i &lt; ptypes.length; i++)
 690             ptypes[i] = basicType(sig.charAt(i)).btClass;
 691         Class&lt;?&gt; rtype = signatureReturn(sig).btClass;
 692         return MethodType.makeImpl(rtype, ptypes, true);
 693     }
 694     static MethodType basicMethodType(MethodType mt) {
 695         return signatureType(basicTypeSignature(mt));
 696     }
 697 
 698     /**
 699      * Check if i-th name is a call to MethodHandleImpl.selectAlternative.
 700      */
 701     boolean isSelectAlternative(int pos) {
 702         // selectAlternative idiom:
 703         //   t_{n}:L=MethodHandleImpl.selectAlternative(...)
 704         //   t_{n+1}:?=MethodHandle.invokeBasic(t_{n}, ...)
 705         if (pos+1 &gt;= names.length)  return false;
 706         Name name0 = names[pos];
 707         Name name1 = names[pos+1];
 708         return name0.refersTo(MethodHandleImpl.class, &quot;selectAlternative&quot;) &amp;&amp;
 709                 name1.isInvokeBasic() &amp;&amp;
 710                 name1.lastUseIndex(name0) == 0 &amp;&amp; // t_{n+1}:?=MethodHandle.invokeBasic(t_{n}, ...)
 711                 lastUseIndex(name0) == pos+1;     // t_{n} is local: used only in t_{n+1}
 712     }
 713 
 714     private boolean isMatchingIdiom(int pos, String idiomName, int nArgs) {
 715         if (pos+2 &gt;= names.length)  return false;
 716         Name name0 = names[pos];
 717         Name name1 = names[pos+1];
 718         Name name2 = names[pos+2];
 719         return name1.refersTo(MethodHandleImpl.class, idiomName) &amp;&amp;
 720                 name0.isInvokeBasic() &amp;&amp;
 721                 name2.isInvokeBasic() &amp;&amp;
 722                 name1.lastUseIndex(name0) == nArgs &amp;&amp; // t_{n+1}:L=MethodHandleImpl.&lt;invoker&gt;(&lt;args&gt;, t_{n});
 723                 lastUseIndex(name0) == pos+1 &amp;&amp;       // t_{n} is local: used only in t_{n+1}
 724                 name2.lastUseIndex(name1) == 1 &amp;&amp;     // t_{n+2}:?=MethodHandle.invokeBasic(*, t_{n+1})
 725                 lastUseIndex(name1) == pos+2;         // t_{n+1} is local: used only in t_{n+2}
 726     }
 727 
 728     /**
 729      * Check if i-th name is a start of GuardWithCatch idiom.
 730      */
 731     boolean isGuardWithCatch(int pos) {
 732         // GuardWithCatch idiom:
 733         //   t_{n}:L=MethodHandle.invokeBasic(...)
 734         //   t_{n+1}:L=MethodHandleImpl.guardWithCatch(*, *, *, t_{n});
 735         //   t_{n+2}:?=MethodHandle.invokeBasic(*, t_{n+1})
 736         return isMatchingIdiom(pos, &quot;guardWithCatch&quot;, 3);
 737     }
 738 
 739     /**
 740      * Check if i-th name is a start of the tryFinally idiom.
 741      */
 742     boolean isTryFinally(int pos) {
 743         // tryFinally idiom:
 744         //   t_{n}:L=MethodHandle.invokeBasic(...)
 745         //   t_{n+1}:L=MethodHandleImpl.tryFinally(*, *, t_{n})
 746         //   t_{n+2}:?=MethodHandle.invokeBasic(*, t_{n+1})
 747         return isMatchingIdiom(pos, &quot;tryFinally&quot;, 2);
 748     }
 749 
 750     /**
 751      * Check if i-th name is a start of the loop idiom.
 752      */
 753     boolean isLoop(int pos) {
 754         // loop idiom:
 755         //   t_{n}:L=MethodHandle.invokeBasic(...)
 756         //   t_{n+1}:L=MethodHandleImpl.loop(types, *, t_{n})
 757         //   t_{n+2}:?=MethodHandle.invokeBasic(*, t_{n+1})
 758         return isMatchingIdiom(pos, &quot;loop&quot;, 2);
 759     }
 760 
 761     /*
 762      * Code generation issues:
 763      *
 764      * Compiled LFs should be reusable in general.
 765      * The biggest issue is how to decide when to pull a name into
 766      * the bytecode, versus loading a reified form from the MH data.
 767      *
 768      * For example, an asType wrapper may require execution of a cast
 769      * after a call to a MH.  The target type of the cast can be placed
 770      * as a constant in the LF itself.  This will force the cast type
 771      * to be compiled into the bytecodes and native code for the MH.
 772      * Or, the target type of the cast can be erased in the LF, and
 773      * loaded from the MH data.  (Later on, if the MH as a whole is
 774      * inlined, the data will flow into the inlined instance of the LF,
 775      * as a constant, and the end result will be an optimal cast.)
 776      *
 777      * This erasure of cast types can be done with any use of
 778      * reference types.  It can also be done with whole method
 779      * handles.  Erasing a method handle might leave behind
 780      * LF code that executes correctly for any MH of a given
 781      * type, and load the required MH from the enclosing MH&#39;s data.
 782      * Or, the erasure might even erase the expected MT.
 783      *
 784      * Also, for direct MHs, the MemberName of the target
 785      * could be erased, and loaded from the containing direct MH.
 786      * As a simple case, a LF for all int-valued non-static
 787      * field getters would perform a cast on its input argument
 788      * (to non-constant base type derived from the MemberName)
 789      * and load an integer value from the input object
 790      * (at a non-constant offset also derived from the MemberName).
 791      * Such MN-erased LFs would be inlinable back to optimized
 792      * code, whenever a constant enclosing DMH is available
 793      * to supply a constant MN from its data.
 794      *
 795      * The main problem here is to keep LFs reasonably generic,
 796      * while ensuring that hot spots will inline good instances.
 797      * &quot;Reasonably generic&quot; means that we don&#39;t end up with
 798      * repeated versions of bytecode or machine code that do
 799      * not differ in their optimized form.  Repeated versions
 800      * of machine would have the undesirable overheads of
 801      * (a) redundant compilation work and (b) extra I$ pressure.
 802      * To control repeated versions, we need to be ready to
 803      * erase details from LFs and move them into MH data,
 804      * whenever those details are not relevant to significant
 805      * optimization.  &quot;Significant&quot; means optimization of
 806      * code that is actually hot.
 807      *
 808      * Achieving this may require dynamic splitting of MHs, by replacing
 809      * a generic LF with a more specialized one, on the same MH,
 810      * if (a) the MH is frequently executed and (b) the MH cannot
 811      * be inlined into a containing caller, such as an invokedynamic.
 812      *
 813      * Compiled LFs that are no longer used should be GC-able.
 814      * If they contain non-BCP references, they should be properly
 815      * interlinked with the class loader(s) that their embedded types
 816      * depend on.  This probably means that reusable compiled LFs
 817      * will be tabulated (indexed) on relevant class loaders,
 818      * or else that the tables that cache them will have weak links.
 819      */
 820 
 821     /**
 822      * Make this LF directly executable, as part of a MethodHandle.
 823      * Invariant:  Every MH which is invoked must prepare its LF
 824      * before invocation.
 825      * (In principle, the JVM could do this very lazily,
 826      * as a sort of pre-invocation linkage step.)
 827      */
 828     public void prepare() {
 829         if (COMPILE_THRESHOLD == 0 &amp;&amp; !forceInterpretation() &amp;&amp; !isCompiled) {
 830             compileToBytecode();
 831         }
 832         if (this.vmentry != null) {
 833             // already prepared (e.g., a primitive DMH invoker form)
 834             return;
 835         }
 836         MethodType mtype = methodType();
 837         LambdaForm prep = mtype.form().cachedLambdaForm(MethodTypeForm.LF_INTERPRET);
 838         if (prep == null) {
 839             assert (isValidSignature(basicTypeSignature()));
 840             prep = new LambdaForm(mtype);
 841             prep.vmentry = InvokerBytecodeGenerator.generateLambdaFormInterpreterEntryPoint(mtype);
 842             prep = mtype.form().setCachedLambdaForm(MethodTypeForm.LF_INTERPRET, prep);
 843         }
 844         this.vmentry = prep.vmentry;
 845         // TO DO: Maybe add invokeGeneric, invokeWithArguments
 846     }
 847 
 848     private static @Stable PerfCounter LF_FAILED;
 849 
 850     private static PerfCounter failedCompilationCounter() {
 851         if (LF_FAILED == null) {
 852             LF_FAILED = PerfCounter.newPerfCounter(&quot;java.lang.invoke.failedLambdaFormCompilations&quot;);
 853         }
 854         return LF_FAILED;
 855     }
 856 
 857     /** Generate optimizable bytecode for this form. */
 858     void compileToBytecode() {
 859         if (forceInterpretation()) {
 860             return; // this should not be compiled
 861         }
 862         if (vmentry != null &amp;&amp; isCompiled) {
 863             return;  // already compiled somehow
 864         }
 865 
 866         // Obtain the invoker MethodType outside of the following try block.
 867         // This ensures that an IllegalArgumentException is directly thrown if the
 868         // type would have 256 or more parameters
 869         MethodType invokerType = methodType();
 870         assert(vmentry == null || vmentry.getMethodType().basicType().equals(invokerType));
 871         try {
 872             vmentry = InvokerBytecodeGenerator.generateCustomizedCode(this, invokerType);
 873             if (TRACE_INTERPRETER)
 874                 traceInterpreter(&quot;compileToBytecode&quot;, this);
 875             isCompiled = true;
 876         } catch (InvokerBytecodeGenerator.BytecodeGenerationException bge) {
 877             // bytecode generation failed - mark this LambdaForm as to be run in interpretation mode only
 878             invocationCounter = -1;
 879             failedCompilationCounter().increment();
 880             if (LOG_LF_COMPILATION_FAILURE) {
 881                 System.out.println(&quot;LambdaForm compilation failed: &quot; + this);
 882                 bge.printStackTrace(System.out);
 883             }
 884         } catch (Error e) {
 885             // Pass through any error
 886             throw e;
 887         } catch (Exception e) {
 888             // Wrap any exception
 889             throw newInternalError(this.toString(), e);
 890         }
 891     }
 892 
 893     // The next few routines are called only from assert expressions
 894     // They verify that the built-in invokers process the correct raw data types.
 895     private static boolean argumentTypesMatch(String sig, Object[] av) {
 896         int arity = signatureArity(sig);
 897         assert(av.length == arity) : &quot;av.length == arity: av.length=&quot; + av.length + &quot;, arity=&quot; + arity;
 898         assert(av[0] instanceof MethodHandle) : &quot;av[0] not instance of MethodHandle: &quot; + av[0];
 899         MethodHandle mh = (MethodHandle) av[0];
 900         MethodType mt = mh.type();
 901         assert(mt.parameterCount() == arity-1);
 902         for (int i = 0; i &lt; av.length; i++) {
 903             Class&lt;?&gt; pt = (i == 0 ? MethodHandle.class : mt.parameterType(i-1));
 904             assert(valueMatches(basicType(sig.charAt(i)), pt, av[i]));
 905         }
 906         return true;
 907     }
 908     private static boolean valueMatches(BasicType tc, Class&lt;?&gt; type, Object x) {
 909         // The following line is needed because (...)void method handles can use non-void invokers
 910         if (type == void.class)  tc = V_TYPE;   // can drop any kind of value
 911         assert tc == basicType(type) : tc + &quot; == basicType(&quot; + type + &quot;)=&quot; + basicType(type);
 912         switch (tc) {
 913         case I_TYPE: assert checkInt(type, x)   : &quot;checkInt(&quot; + type + &quot;,&quot; + x +&quot;)&quot;;   break;
 914         case J_TYPE: assert x instanceof Long   : &quot;instanceof Long: &quot; + x;             break;
 915         case F_TYPE: assert x instanceof Float  : &quot;instanceof Float: &quot; + x;            break;
 916         case D_TYPE: assert x instanceof Double : &quot;instanceof Double: &quot; + x;           break;
 917         case L_TYPE: assert checkRef(type, x)   : &quot;checkRef(&quot; + type + &quot;,&quot; + x + &quot;)&quot;;  break;
 918         case V_TYPE: break;  // allow anything here; will be dropped
 919         default:  assert(false);
 920         }
 921         return true;
 922     }
 923     private static boolean checkInt(Class&lt;?&gt; type, Object x) {
 924         assert(x instanceof Integer);
 925         if (type == int.class)  return true;
 926         Wrapper w = Wrapper.forBasicType(type);
 927         assert(w.isSubwordOrInt());
 928         Object x1 = Wrapper.INT.wrap(w.wrap(x));
 929         return x.equals(x1);
 930     }
 931     private static boolean checkRef(Class&lt;?&gt; type, Object x) {
 932         assert(!type.isPrimitive());
 933         if (x == null)  return true;
 934         if (type.isInterface())  return true;
 935         return type.isInstance(x);
 936     }
 937 
 938     /** If the invocation count hits the threshold we spin bytecodes and call that subsequently. */
 939     private static final int COMPILE_THRESHOLD;
 940     static {
 941         COMPILE_THRESHOLD = Math.max(-1, MethodHandleStatics.COMPILE_THRESHOLD);
 942     }
 943     private int invocationCounter = 0; // a value of -1 indicates LambdaForm interpretation mode forever
 944 
 945     private boolean forceInterpretation() {
 946         return invocationCounter == -1;
 947     }
 948 
 949     @Hidden
 950     @DontInline
 951     /** Interpretively invoke this form on the given arguments. */
 952     Object interpretWithArguments(Object... argumentValues) throws Throwable {
 953         if (TRACE_INTERPRETER)
 954             return interpretWithArgumentsTracing(argumentValues);
 955         checkInvocationCounter();
 956         assert(arityCheck(argumentValues));
 957         Object[] values = Arrays.copyOf(argumentValues, names.length);
 958         for (int i = argumentValues.length; i &lt; values.length; i++) {
 959             values[i] = interpretName(names[i], values);
 960         }
 961         Object rv = (result &lt; 0) ? null : values[result];
 962         assert(resultCheck(argumentValues, rv));
 963         return rv;
 964     }
 965 
 966     @Hidden
 967     @DontInline
 968     /** Evaluate a single Name within this form, applying its function to its arguments. */
 969     Object interpretName(Name name, Object[] values) throws Throwable {
 970         if (TRACE_INTERPRETER)
 971             traceInterpreter(&quot;| interpretName&quot;, name.debugString(), (Object[]) null);
 972         Object[] arguments = Arrays.copyOf(name.arguments, name.arguments.length, Object[].class);
 973         for (int i = 0; i &lt; arguments.length; i++) {
 974             Object a = arguments[i];
 975             if (a instanceof Name) {
 976                 int i2 = ((Name)a).index();
 977                 assert(names[i2] == a);
 978                 a = values[i2];
 979                 arguments[i] = a;
 980             }
 981         }
 982         return name.function.invokeWithArguments(arguments);
 983     }
 984 
 985     private void checkInvocationCounter() {
 986         if (COMPILE_THRESHOLD != 0 &amp;&amp;
 987             !forceInterpretation() &amp;&amp; invocationCounter &lt; COMPILE_THRESHOLD) {
 988             invocationCounter++;  // benign race
 989             if (invocationCounter &gt;= COMPILE_THRESHOLD) {
 990                 // Replace vmentry with a bytecode version of this LF.
 991                 compileToBytecode();
 992             }
 993         }
 994     }
 995     Object interpretWithArgumentsTracing(Object... argumentValues) throws Throwable {
 996         traceInterpreter(&quot;[ interpretWithArguments&quot;, this, argumentValues);
 997         if (!forceInterpretation() &amp;&amp; invocationCounter &lt; COMPILE_THRESHOLD) {
 998             int ctr = invocationCounter++;  // benign race
 999             traceInterpreter(&quot;| invocationCounter&quot;, ctr);
1000             if (invocationCounter &gt;= COMPILE_THRESHOLD) {
1001                 compileToBytecode();
1002             }
1003         }
1004         Object rval;
1005         try {
1006             assert(arityCheck(argumentValues));
1007             Object[] values = Arrays.copyOf(argumentValues, names.length);
1008             for (int i = argumentValues.length; i &lt; values.length; i++) {
1009                 values[i] = interpretName(names[i], values);
1010             }
1011             rval = (result &lt; 0) ? null : values[result];
1012         } catch (Throwable ex) {
1013             traceInterpreter(&quot;] throw =&gt;&quot;, ex);
1014             throw ex;
1015         }
1016         traceInterpreter(&quot;] return =&gt;&quot;, rval);
1017         return rval;
1018     }
1019 
1020     static void traceInterpreter(String event, Object obj, Object... args) {
1021         if (TRACE_INTERPRETER) {
1022             System.out.println(&quot;LFI: &quot;+event+&quot; &quot;+(obj != null ? obj : &quot;&quot;)+(args != null &amp;&amp; args.length != 0 ? Arrays.asList(args) : &quot;&quot;));
1023         }
1024     }
1025     static void traceInterpreter(String event, Object obj) {
1026         traceInterpreter(event, obj, (Object[])null);
1027     }
1028     private boolean arityCheck(Object[] argumentValues) {
1029         assert(argumentValues.length == arity) : arity+&quot;!=&quot;+Arrays.asList(argumentValues)+&quot;.length&quot;;
1030         // also check that the leading (receiver) argument is somehow bound to this LF:
1031         assert(argumentValues[0] instanceof MethodHandle) : &quot;not MH: &quot; + argumentValues[0];
1032         MethodHandle mh = (MethodHandle) argumentValues[0];
1033         assert(mh.internalForm() == this);
1034         // note:  argument #0 could also be an interface wrapper, in the future
1035         argumentTypesMatch(basicTypeSignature(), argumentValues);
1036         return true;
1037     }
1038     private boolean resultCheck(Object[] argumentValues, Object result) {
1039         MethodHandle mh = (MethodHandle) argumentValues[0];
1040         MethodType mt = mh.type();
1041         assert(valueMatches(returnType(), mt.returnType(), result));
1042         return true;
1043     }
1044 
1045     private boolean isEmpty() {
1046         if (result &lt; 0)
1047             return (names.length == arity);
1048         else if (result == arity &amp;&amp; names.length == arity + 1)
1049             return names[arity].isConstantZero();
1050         else
1051             return false;
1052     }
1053 
1054     public String toString() {
1055         String lambdaName = lambdaName();
1056         StringBuilder buf = new StringBuilder(lambdaName + &quot;=Lambda(&quot;);
1057         for (int i = 0; i &lt; names.length; i++) {
1058             if (i == arity)  buf.append(&quot;)=&gt;{&quot;);
1059             Name n = names[i];
1060             if (i &gt;= arity)  buf.append(&quot;\n    &quot;);
1061             buf.append(n.paramString());
1062             if (i &lt; arity) {
1063                 if (i+1 &lt; arity)  buf.append(&quot;,&quot;);
1064                 continue;
1065             }
1066             buf.append(&quot;=&quot;).append(n.exprString());
1067             buf.append(&quot;;&quot;);
1068         }
1069         if (arity == names.length)  buf.append(&quot;)=&gt;{&quot;);
1070         buf.append(result &lt; 0 ? &quot;void&quot; : names[result]).append(&quot;}&quot;);
1071         if (TRACE_INTERPRETER) {
1072             // Extra verbosity:
1073             buf.append(&quot;:&quot;).append(basicTypeSignature());
1074             buf.append(&quot;/&quot;).append(vmentry);
1075         }
1076         return buf.toString();
1077     }
1078 
1079     @Override
1080     public boolean equals(Object obj) {
1081         return obj instanceof LambdaForm &amp;&amp; equals((LambdaForm)obj);
1082     }
1083     public boolean equals(LambdaForm that) {
1084         if (this.result != that.result)  return false;
1085         return Arrays.equals(this.names, that.names);
1086     }
1087     public int hashCode() {
1088         return result + 31 * Arrays.hashCode(names);
1089     }
1090     LambdaFormEditor editor() {
1091         return LambdaFormEditor.lambdaFormEditor(this);
1092     }
1093 
1094     boolean contains(Name name) {
1095         int pos = name.index();
1096         if (pos &gt;= 0) {
1097             return pos &lt; names.length &amp;&amp; name.equals(names[pos]);
1098         }
1099         for (int i = arity; i &lt; names.length; i++) {
1100             if (name.equals(names[i]))
1101                 return true;
1102         }
1103         return false;
1104     }
1105 
1106     static class NamedFunction {
1107         final MemberName member;
1108         private @Stable MethodHandle resolvedHandle;
1109         @Stable MethodHandle invoker;
1110         private final MethodHandleImpl.Intrinsic intrinsicName;
1111 
1112         NamedFunction(MethodHandle resolvedHandle) {
1113             this(resolvedHandle.internalMemberName(), resolvedHandle, MethodHandleImpl.Intrinsic.NONE);
1114         }
1115         NamedFunction(MethodHandle resolvedHandle, MethodHandleImpl.Intrinsic intrinsic) {
1116             this(resolvedHandle.internalMemberName(), resolvedHandle, intrinsic);
1117         }
1118         NamedFunction(MemberName member, MethodHandle resolvedHandle) {
1119             this(member, resolvedHandle, MethodHandleImpl.Intrinsic.NONE);
1120         }
1121         NamedFunction(MemberName member, MethodHandle resolvedHandle, MethodHandleImpl.Intrinsic intrinsic) {
1122             this.member = member;
1123             this.resolvedHandle = resolvedHandle;
1124             this.intrinsicName = intrinsic;
1125             assert(resolvedHandle == null ||
1126                    resolvedHandle.intrinsicName() == MethodHandleImpl.Intrinsic.NONE ||
1127                    resolvedHandle.intrinsicName() == intrinsic) : resolvedHandle.intrinsicName() + &quot; != &quot; + intrinsic;
1128              // The following assert is almost always correct, but will fail for corner cases, such as PrivateInvokeTest.
1129              //assert(!isInvokeBasic(member));
1130         }
1131         NamedFunction(MethodType basicInvokerType) {
1132             assert(basicInvokerType == basicInvokerType.basicType()) : basicInvokerType;
1133             if (basicInvokerType.parameterSlotCount() &lt; MethodType.MAX_MH_INVOKER_ARITY) {
1134                 this.resolvedHandle = basicInvokerType.invokers().basicInvoker();
1135                 this.member = resolvedHandle.internalMemberName();
1136             } else {
1137                 // necessary to pass BigArityTest
1138                 this.member = Invokers.invokeBasicMethod(basicInvokerType);
1139             }
1140             this.intrinsicName = MethodHandleImpl.Intrinsic.NONE;
1141             assert(isInvokeBasic(member));
1142         }
1143 
1144         private static boolean isInvokeBasic(MemberName member) {
1145             return member != null &amp;&amp;
1146                    member.getDeclaringClass() == MethodHandle.class &amp;&amp;
1147                   &quot;invokeBasic&quot;.equals(member.getName());
1148         }
1149 
1150         // The next 2 constructors are used to break circular dependencies on MH.invokeStatic, etc.
1151         // Any LambdaForm containing such a member is not interpretable.
1152         // This is OK, since all such LFs are prepared with special primitive vmentry points.
1153         // And even without the resolvedHandle, the name can still be compiled and optimized.
1154         NamedFunction(Method method) {
1155             this(new MemberName(method));
1156         }
1157         NamedFunction(MemberName member) {
1158             this(member, null);
1159         }
1160 
1161         MethodHandle resolvedHandle() {
1162             if (resolvedHandle == null)  resolve();
1163             return resolvedHandle;
1164         }
1165 
1166         synchronized void resolve() {
1167             if (resolvedHandle == null) {
1168                 resolvedHandle = DirectMethodHandle.make(member);
1169             }
1170         }
1171 
1172         @Override
1173         public boolean equals(Object other) {
1174             if (this == other) return true;
1175             if (other == null) return false;
1176             if (!(other instanceof NamedFunction)) return false;
1177             NamedFunction that = (NamedFunction) other;
1178             return this.member != null &amp;&amp; this.member.equals(that.member);
1179         }
1180 
1181         @Override
1182         public int hashCode() {
1183             if (member != null)
1184                 return member.hashCode();
1185             return super.hashCode();
1186         }
1187 
1188         static final MethodType INVOKER_METHOD_TYPE =
1189             MethodType.methodType(Object.class, MethodHandle.class, Object[].class);
1190 
1191         private static MethodHandle computeInvoker(MethodTypeForm typeForm) {
1192             typeForm = typeForm.basicType().form();  // normalize to basic type
1193             MethodHandle mh = typeForm.cachedMethodHandle(MethodTypeForm.MH_NF_INV);
1194             if (mh != null)  return mh;
1195             MemberName invoker = InvokerBytecodeGenerator.generateNamedFunctionInvoker(typeForm);  // this could take a while
1196             mh = DirectMethodHandle.make(invoker);
1197             MethodHandle mh2 = typeForm.cachedMethodHandle(MethodTypeForm.MH_NF_INV);
1198             if (mh2 != null)  return mh2;  // benign race
1199             if (!mh.type().equals(INVOKER_METHOD_TYPE))
1200                 throw newInternalError(mh.debugString());
1201             return typeForm.setCachedMethodHandle(MethodTypeForm.MH_NF_INV, mh);
1202         }
1203 
1204         @Hidden
1205         Object invokeWithArguments(Object... arguments) throws Throwable {
1206             // If we have a cached invoker, call it right away.
1207             // NOTE: The invoker always returns a reference value.
1208             if (TRACE_INTERPRETER)  return invokeWithArgumentsTracing(arguments);
1209             return invoker().invokeBasic(resolvedHandle(), arguments);
1210         }
1211 
1212         @Hidden
1213         Object invokeWithArgumentsTracing(Object[] arguments) throws Throwable {
1214             Object rval;
1215             try {
1216                 traceInterpreter(&quot;[ call&quot;, this, arguments);
1217                 if (invoker == null) {
1218                     traceInterpreter(&quot;| getInvoker&quot;, this);
1219                     invoker();
1220                 }
1221                 // resolvedHandle might be uninitialized, ok for tracing
1222                 if (resolvedHandle == null) {
1223                     traceInterpreter(&quot;| resolve&quot;, this);
1224                     resolvedHandle();
1225                 }
1226                 rval = invoker().invokeBasic(resolvedHandle(), arguments);
1227             } catch (Throwable ex) {
1228                 traceInterpreter(&quot;] throw =&gt;&quot;, ex);
1229                 throw ex;
1230             }
1231             traceInterpreter(&quot;] return =&gt;&quot;, rval);
1232             return rval;
1233         }
1234 
1235         private MethodHandle invoker() {
1236             if (invoker != null)  return invoker;
1237             // Get an invoker and cache it.
1238             return invoker = computeInvoker(methodType().form());
1239         }
1240 
1241         MethodType methodType() {
1242             if (resolvedHandle != null)
1243                 return resolvedHandle.type();
1244             else
1245                 // only for certain internal LFs during bootstrapping
1246                 return member.getInvocationType();
1247         }
1248 
1249         MemberName member() {
1250             assert(assertMemberIsConsistent());
1251             return member;
1252         }
1253 
1254         // Called only from assert.
1255         private boolean assertMemberIsConsistent() {
1256             if (resolvedHandle instanceof DirectMethodHandle) {
1257                 MemberName m = resolvedHandle.internalMemberName();
1258                 assert(m.equals(member));
1259             }
1260             return true;
1261         }
1262 
1263         Class&lt;?&gt; memberDeclaringClassOrNull() {
1264             return (member == null) ? null : member.getDeclaringClass();
1265         }
1266 
1267         BasicType returnType() {
1268             return basicType(methodType().returnType());
1269         }
1270 
1271         BasicType parameterType(int n) {
1272             return basicType(methodType().parameterType(n));
1273         }
1274 
1275         int arity() {
1276             return methodType().parameterCount();
1277         }
1278 
1279         public String toString() {
1280             if (member == null)  return String.valueOf(resolvedHandle);
1281             return member.getDeclaringClass().getSimpleName()+&quot;.&quot;+member.getName();
1282         }
1283 
1284         public boolean isIdentity() {
1285             return this.equals(identity(returnType()));
1286         }
1287 
1288         public boolean isConstantZero() {
1289             return this.equals(constantZero(returnType()));
1290         }
1291 
1292         public MethodHandleImpl.Intrinsic intrinsicName() {
1293             return intrinsicName;
1294         }
1295     }
1296 
1297     public static String basicTypeSignature(MethodType type) {
1298         int params = type.parameterCount();
1299         char[] sig = new char[params + 2];
1300         int sigp = 0;
1301         while (sigp &lt; params) {
1302             sig[sigp] = basicTypeChar(type.parameterType(sigp++));
1303         }
1304         sig[sigp++] = &#39;_&#39;;
1305         sig[sigp++] = basicTypeChar(type.returnType());
1306         assert(sigp == sig.length);
1307         return String.valueOf(sig);
1308     }
1309 
1310     /** Hack to make signatures more readable when they show up in method names.
1311      * Signature should start with a sequence of uppercase ASCII letters.
1312      * Runs of three or more are replaced by a single letter plus a decimal repeat count.
1313      * A tail of anything other than uppercase ASCII is passed through unchanged.
1314      * @param signature sequence of uppercase ASCII letters with possible repetitions
1315      * @return same sequence, with repetitions counted by decimal numerals
1316      */
1317     public static String shortenSignature(String signature) {
1318         final int NO_CHAR = -1, MIN_RUN = 3;
1319         int c0, c1 = NO_CHAR, c1reps = 0;
1320         StringBuilder buf = null;
1321         int len = signature.length();
1322         if (len &lt; MIN_RUN)  return signature;
1323         for (int i = 0; i &lt;= len; i++) {
1324             if (c1 != NO_CHAR &amp;&amp; !(&#39;A&#39; &lt;= c1 &amp;&amp; c1 &lt;= &#39;Z&#39;)) {
1325                 // wrong kind of char; bail out here
1326                 if (buf != null) {
1327                     buf.append(signature.substring(i - c1reps, len));
1328                 }
1329                 break;
1330             }
1331             // shift in the next char:
1332             c0 = c1; c1 = (i == len ? NO_CHAR : signature.charAt(i));
1333             if (c1 == c0) { ++c1reps; continue; }
1334             // shift in the next count:
1335             int c0reps = c1reps; c1reps = 1;
1336             // end of a  character run
1337             if (c0reps &lt; MIN_RUN) {
1338                 if (buf != null) {
1339                     while (--c0reps &gt;= 0)
1340                         buf.append((char)c0);
1341                 }
1342                 continue;
1343             }
1344             // found three or more in a row
1345             if (buf == null)
1346                 buf = new StringBuilder().append(signature, 0, i - c0reps);
1347             buf.append((char)c0).append(c0reps);
1348         }
1349         return (buf == null) ? signature : buf.toString();
1350     }
1351 
1352     static final class Name {
1353         final BasicType type;
1354         @Stable short index;
1355         final NamedFunction function;
1356         final Object constraint;  // additional type information, if not null
1357         @Stable final Object[] arguments;
1358 
1359         private Name(int index, BasicType type, NamedFunction function, Object[] arguments) {
1360             this.index = (short)index;
1361             this.type = type;
1362             this.function = function;
1363             this.arguments = arguments;
1364             this.constraint = null;
1365             assert(this.index == index);
1366         }
1367         private Name(Name that, Object constraint) {
1368             this.index = that.index;
1369             this.type = that.type;
1370             this.function = that.function;
1371             this.arguments = that.arguments;
1372             this.constraint = constraint;
1373             assert(constraint == null || isParam());  // only params have constraints
1374             assert(constraint == null || constraint instanceof ClassSpecializer.SpeciesData || constraint instanceof Class);
1375         }
1376         Name(MethodHandle function, Object... arguments) {
1377             this(new NamedFunction(function), arguments);
1378         }
1379         Name(MethodType functionType, Object... arguments) {
1380             this(new NamedFunction(functionType), arguments);
1381             assert(arguments[0] instanceof Name &amp;&amp; ((Name)arguments[0]).type == L_TYPE);
1382         }
1383         Name(MemberName function, Object... arguments) {
1384             this(new NamedFunction(function), arguments);
1385         }
1386         Name(NamedFunction function, Object... arguments) {
1387             this(-1, function.returnType(), function, arguments = Arrays.copyOf(arguments, arguments.length, Object[].class));
1388             assert(typesMatch(function, arguments));
1389         }
1390         /** Create a raw parameter of the given type, with an expected index. */
1391         Name(int index, BasicType type) {
1392             this(index, type, null, null);
1393         }
1394         /** Create a raw parameter of the given type. */
1395         Name(BasicType type) { this(-1, type); }
1396 
1397         BasicType type() { return type; }
1398         int index() { return index; }
1399         boolean initIndex(int i) {
1400             if (index != i) {
1401                 if (index != -1)  return false;
1402                 index = (short)i;
1403             }
1404             return true;
1405         }
1406         char typeChar() {
1407             return type.btChar;
1408         }
1409 
1410         void resolve() {
1411             if (function != null)
1412                 function.resolve();
1413         }
1414 
1415         Name newIndex(int i) {
1416             if (initIndex(i))  return this;
1417             return cloneWithIndex(i);
1418         }
1419         Name cloneWithIndex(int i) {
1420             Object[] newArguments = (arguments == null) ? null : arguments.clone();
1421             return new Name(i, type, function, newArguments).withConstraint(constraint);
1422         }
1423         Name withConstraint(Object constraint) {
1424             if (constraint == this.constraint)  return this;
1425             return new Name(this, constraint);
1426         }
1427         Name replaceName(Name oldName, Name newName) {  // FIXME: use replaceNames uniformly
1428             if (oldName == newName)  return this;
1429             @SuppressWarnings(&quot;LocalVariableHidesMemberVariable&quot;)
1430             Object[] arguments = this.arguments;
1431             if (arguments == null)  return this;
1432             boolean replaced = false;
1433             for (int j = 0; j &lt; arguments.length; j++) {
1434                 if (arguments[j] == oldName) {
1435                     if (!replaced) {
1436                         replaced = true;
1437                         arguments = arguments.clone();
1438                     }
1439                     arguments[j] = newName;
1440                 }
1441             }
1442             if (!replaced)  return this;
1443             return new Name(function, arguments);
1444         }
1445         /** In the arguments of this Name, replace oldNames[i] pairwise by newNames[i].
1446          *  Limit such replacements to {@code start&lt;=i&lt;end}.  Return possibly changed self.
1447          */
1448         Name replaceNames(Name[] oldNames, Name[] newNames, int start, int end) {
1449             if (start &gt;= end)  return this;
1450             @SuppressWarnings(&quot;LocalVariableHidesMemberVariable&quot;)
1451             Object[] arguments = this.arguments;
1452             boolean replaced = false;
1453         eachArg:
1454             for (int j = 0; j &lt; arguments.length; j++) {
1455                 if (arguments[j] instanceof Name) {
1456                     Name n = (Name) arguments[j];
1457                     int check = n.index;
1458                     // harmless check to see if the thing is already in newNames:
1459                     if (check &gt;= 0 &amp;&amp; check &lt; newNames.length &amp;&amp; n == newNames[check])
1460                         continue eachArg;
1461                     // n might not have the correct index: n != oldNames[n.index].
1462                     for (int i = start; i &lt; end; i++) {
1463                         if (n == oldNames[i]) {
1464                             if (n == newNames[i])
1465                                 continue eachArg;
1466                             if (!replaced) {
1467                                 replaced = true;
1468                                 arguments = arguments.clone();
1469                             }
1470                             arguments[j] = newNames[i];
1471                             continue eachArg;
1472                         }
1473                     }
1474                 }
1475             }
1476             if (!replaced)  return this;
1477             return new Name(function, arguments);
1478         }
1479         void internArguments() {
1480             @SuppressWarnings(&quot;LocalVariableHidesMemberVariable&quot;)
1481             Object[] arguments = this.arguments;
1482             for (int j = 0; j &lt; arguments.length; j++) {
1483                 if (arguments[j] instanceof Name) {
1484                     Name n = (Name) arguments[j];
1485                     if (n.isParam() &amp;&amp; n.index &lt; INTERNED_ARGUMENT_LIMIT)
1486                         arguments[j] = internArgument(n);
1487                 }
1488             }
1489         }
1490         boolean isParam() {
1491             return function == null;
1492         }
1493         boolean isConstantZero() {
1494             return !isParam() &amp;&amp; arguments.length == 0 &amp;&amp; function.isConstantZero();
1495         }
1496 
1497         boolean refersTo(Class&lt;?&gt; declaringClass, String methodName) {
1498             return function != null &amp;&amp;
1499                     function.member() != null &amp;&amp; function.member().refersTo(declaringClass, methodName);
1500         }
1501 
1502         /**
1503          * Check if MemberName is a call to MethodHandle.invokeBasic.
1504          */
1505         boolean isInvokeBasic() {
1506             if (function == null)
1507                 return false;
1508             if (arguments.length &lt; 1)
1509                 return false;  // must have MH argument
1510             MemberName member = function.member();
1511             return member != null &amp;&amp; member.refersTo(MethodHandle.class, &quot;invokeBasic&quot;) &amp;&amp;
1512                     !member.isPublic() &amp;&amp; !member.isStatic();
1513         }
1514 
1515         /**
1516          * Check if MemberName is a call to MethodHandle.linkToStatic, etc.
1517          */
1518         boolean isLinkerMethodInvoke() {
1519             if (function == null)
1520                 return false;
1521             if (arguments.length &lt; 1)
1522                 return false;  // must have MH argument
1523             MemberName member = function.member();
1524             return member != null &amp;&amp;
1525                     member.getDeclaringClass() == MethodHandle.class &amp;&amp;
1526                     !member.isPublic() &amp;&amp; member.isStatic() &amp;&amp;
1527                     member.getName().startsWith(&quot;linkTo&quot;);
1528         }
1529 
1530         public String toString() {
1531             return (isParam()?&quot;a&quot;:&quot;t&quot;)+(index &gt;= 0 ? index : System.identityHashCode(this))+&quot;:&quot;+typeChar();
1532         }
1533         public String debugString() {
1534             String s = paramString();
1535             return (function == null) ? s : s + &quot;=&quot; + exprString();
1536         }
1537         public String paramString() {
1538             String s = toString();
1539             Object c = constraint;
1540             if (c == null)
1541                 return s;
1542             if (c instanceof Class)  c = ((Class&lt;?&gt;)c).getSimpleName();
1543             return s + &quot;/&quot; + c;
1544         }
1545         public String exprString() {
1546             if (function == null)  return toString();
1547             StringBuilder buf = new StringBuilder(function.toString());
1548             buf.append(&quot;(&quot;);
1549             String cma = &quot;&quot;;
1550             for (Object a : arguments) {
1551                 buf.append(cma); cma = &quot;,&quot;;
1552                 if (a instanceof Name || a instanceof Integer)
1553                     buf.append(a);
1554                 else
1555                     buf.append(&quot;(&quot;).append(a).append(&quot;)&quot;);
1556             }
1557             buf.append(&quot;)&quot;);
1558             return buf.toString();
1559         }
1560 
1561         private boolean typesMatch(NamedFunction function, Object ... arguments) {
1562             assert(arguments.length == function.arity()) : &quot;arity mismatch: arguments.length=&quot; + arguments.length + &quot; == function.arity()=&quot; + function.arity() + &quot; in &quot; + debugString();
1563             for (int i = 0; i &lt; arguments.length; i++) {
1564                 assert (typesMatch(function.parameterType(i), arguments[i])) : &quot;types don&#39;t match: function.parameterType(&quot; + i + &quot;)=&quot; + function.parameterType(i) + &quot;, arguments[&quot; + i + &quot;]=&quot; + arguments[i] + &quot; in &quot; + debugString();
1565             }
1566             return true;
1567         }
1568 
1569         private static boolean typesMatch(BasicType parameterType, Object object) {
1570             if (object instanceof Name) {
1571                 return ((Name)object).type == parameterType;
1572             }
1573             switch (parameterType) {
1574                 case I_TYPE:  return object instanceof Integer;
1575                 case J_TYPE:  return object instanceof Long;
1576                 case F_TYPE:  return object instanceof Float;
1577                 case D_TYPE:  return object instanceof Double;
1578             }
1579             assert(parameterType == L_TYPE);
1580             return true;
1581         }
1582 
1583         /** Return the index of the last occurrence of n in the argument array.
1584          *  Return -1 if the name is not used.
1585          */
1586         int lastUseIndex(Name n) {
1587             if (arguments == null)  return -1;
1588             for (int i = arguments.length; --i &gt;= 0; ) {
1589                 if (arguments[i] == n)  return i;
1590             }
1591             return -1;
1592         }
1593 
1594         /** Return the number of occurrences of n in the argument array.
1595          *  Return 0 if the name is not used.
1596          */
1597         int useCount(Name n) {
1598             if (arguments == null)  return 0;
1599             int count = 0;
1600             for (int i = arguments.length; --i &gt;= 0; ) {
1601                 if (arguments[i] == n)  ++count;
1602             }
1603             return count;
1604         }
1605 
1606         boolean contains(Name n) {
1607             return this == n || lastUseIndex(n) &gt;= 0;
1608         }
1609 
1610         public boolean equals(Name that) {
1611             if (this == that)  return true;
1612             if (isParam())
1613                 // each parameter is a unique atom
1614                 return false;  // this != that
1615             return
1616                 //this.index == that.index &amp;&amp;
1617                 this.type == that.type &amp;&amp;
1618                 this.function.equals(that.function) &amp;&amp;
1619                 Arrays.equals(this.arguments, that.arguments);
1620         }
1621         @Override
1622         public boolean equals(Object x) {
1623             return x instanceof Name &amp;&amp; equals((Name)x);
1624         }
1625         @Override
1626         public int hashCode() {
1627             if (isParam())
1628                 return index | (type.ordinal() &lt;&lt; 8);
1629             return function.hashCode() ^ Arrays.hashCode(arguments);
1630         }
1631     }
1632 
1633     /** Return the index of the last name which contains n as an argument.
1634      *  Return -1 if the name is not used.  Return names.length if it is the return value.
1635      */
1636     int lastUseIndex(Name n) {
1637         int ni = n.index, nmax = names.length;
1638         assert(names[ni] == n);
1639         if (result == ni)  return nmax;  // live all the way beyond the end
1640         for (int i = nmax; --i &gt; ni; ) {
1641             if (names[i].lastUseIndex(n) &gt;= 0)
1642                 return i;
1643         }
1644         return -1;
1645     }
1646 
1647     /** Return the number of times n is used as an argument or return value. */
1648     int useCount(Name n) {
1649         int nmax = names.length;
1650         int end = lastUseIndex(n);
1651         if (end &lt; 0)  return 0;
1652         int count = 0;
1653         if (end == nmax) { count++; end--; }
1654         int beg = n.index() + 1;
1655         if (beg &lt; arity)  beg = arity;
1656         for (int i = beg; i &lt;= end; i++) {
1657             count += names[i].useCount(n);
1658         }
1659         return count;
1660     }
1661 
1662     static Name argument(int which, BasicType type) {
1663         if (which &gt;= INTERNED_ARGUMENT_LIMIT)
1664             return new Name(which, type);
1665         return INTERNED_ARGUMENTS[type.ordinal()][which];
1666     }
1667     static Name internArgument(Name n) {
1668         assert(n.isParam()) : &quot;not param: &quot; + n;
1669         assert(n.index &lt; INTERNED_ARGUMENT_LIMIT);
1670         if (n.constraint != null)  return n;
1671         return argument(n.index, n.type);
1672     }
1673     static Name[] arguments(int extra, MethodType types) {
1674         int length = types.parameterCount();
1675         Name[] names = new Name[length + extra];
1676         for (int i = 0; i &lt; length; i++)
1677             names[i] = argument(i, basicType(types.parameterType(i)));
1678         return names;
1679     }
1680     static final int INTERNED_ARGUMENT_LIMIT = 10;
1681     private static final Name[][] INTERNED_ARGUMENTS
1682             = new Name[ARG_TYPE_LIMIT][INTERNED_ARGUMENT_LIMIT];
1683     static {
1684         for (BasicType type : BasicType.ARG_TYPES) {
1685             int ord = type.ordinal();
1686             for (int i = 0; i &lt; INTERNED_ARGUMENTS[ord].length; i++) {
1687                 INTERNED_ARGUMENTS[ord][i] = new Name(i, type);
1688             }
1689         }
1690     }
1691 
1692     private static final MemberName.Factory IMPL_NAMES = MemberName.getFactory();
1693 
1694     static LambdaForm identityForm(BasicType type) {
1695         int ord = type.ordinal();
1696         LambdaForm form = LF_identity[ord];
1697         if (form != null) {
1698             return form;
1699         }
1700         createFormsFor(type);
1701         return LF_identity[ord];
1702     }
1703 
1704     static LambdaForm zeroForm(BasicType type) {
1705         int ord = type.ordinal();
1706         LambdaForm form = LF_zero[ord];
1707         if (form != null) {
1708             return form;
1709         }
1710         createFormsFor(type);
1711         return LF_zero[ord];
1712     }
1713 
1714     static NamedFunction identity(BasicType type) {
1715         int ord = type.ordinal();
1716         NamedFunction function = NF_identity[ord];
1717         if (function != null) {
1718             return function;
1719         }
1720         createFormsFor(type);
1721         return NF_identity[ord];
1722     }
1723 
1724     static NamedFunction constantZero(BasicType type) {
1725         int ord = type.ordinal();
1726         NamedFunction function = NF_zero[ord];
1727         if (function != null) {
1728             return function;
1729         }
1730         createFormsFor(type);
1731         return NF_zero[ord];
1732     }
1733 
1734     private static final @Stable LambdaForm[] LF_identity = new LambdaForm[TYPE_LIMIT];
1735     private static final @Stable LambdaForm[] LF_zero = new LambdaForm[TYPE_LIMIT];
1736     private static final @Stable NamedFunction[] NF_identity = new NamedFunction[TYPE_LIMIT];
1737     private static final @Stable NamedFunction[] NF_zero = new NamedFunction[TYPE_LIMIT];
1738 
1739     private static final Object createFormsLock = new Object();
1740     private static void createFormsFor(BasicType type) {
1741         // Avoid racy initialization during bootstrap
1742         UNSAFE.ensureClassInitialized(BoundMethodHandle.class);
1743         synchronized (createFormsLock) {
1744             final int ord = type.ordinal();
1745             LambdaForm idForm = LF_identity[ord];
1746             if (idForm != null) {
1747                 return;
1748             }
1749             char btChar = type.basicTypeChar();
1750             boolean isVoid = (type == V_TYPE);
1751             Class&lt;?&gt; btClass = type.btClass;
1752             MethodType zeType = MethodType.methodType(btClass);
1753             MethodType idType = (isVoid) ? zeType : MethodType.methodType(btClass, btClass);
1754 
1755             // Look up symbolic names.  It might not be necessary to have these,
1756             // but if we need to emit direct references to bytecodes, it helps.
1757             // Zero is built from a call to an identity function with a constant zero input.
1758             MemberName idMem = new MemberName(LambdaForm.class, &quot;identity_&quot;+btChar, idType, REF_invokeStatic);
1759             MemberName zeMem = null;
1760             try {
1761                 idMem = IMPL_NAMES.resolveOrFail(REF_invokeStatic, idMem, null, NoSuchMethodException.class);
1762                 if (!isVoid) {
1763                     zeMem = new MemberName(LambdaForm.class, &quot;zero_&quot;+btChar, zeType, REF_invokeStatic);
1764                     zeMem = IMPL_NAMES.resolveOrFail(REF_invokeStatic, zeMem, null, NoSuchMethodException.class);
1765                 }
1766             } catch (IllegalAccessException|NoSuchMethodException ex) {
1767                 throw newInternalError(ex);
1768             }
1769 
1770             NamedFunction idFun;
1771             LambdaForm zeForm;
1772             NamedFunction zeFun;
1773 
1774             // Create the LFs and NamedFunctions. Precompiling LFs to byte code is needed to break circular
1775             // bootstrap dependency on this method in case we&#39;re interpreting LFs
1776             if (isVoid) {
1777                 Name[] idNames = new Name[] { argument(0, L_TYPE) };
1778                 idForm = new LambdaForm(1, idNames, VOID_RESULT, Kind.IDENTITY);
1779                 idForm.compileToBytecode();
1780                 idFun = new NamedFunction(idMem, SimpleMethodHandle.make(idMem.getInvocationType(), idForm));
1781 
1782                 zeForm = idForm;
1783                 zeFun = idFun;
1784             } else {
1785                 Name[] idNames = new Name[] { argument(0, L_TYPE), argument(1, type) };
1786                 idForm = new LambdaForm(2, idNames, 1, Kind.IDENTITY);
1787                 idForm.compileToBytecode();
1788                 idFun = new NamedFunction(idMem, SimpleMethodHandle.make(idMem.getInvocationType(), idForm),
1789                             MethodHandleImpl.Intrinsic.IDENTITY);
1790 
1791                 Object zeValue = Wrapper.forBasicType(btChar).zero();
1792                 Name[] zeNames = new Name[] { argument(0, L_TYPE), new Name(idFun, zeValue) };
1793                 zeForm = new LambdaForm(1, zeNames, 1, Kind.ZERO);
1794                 zeForm.compileToBytecode();
1795                 zeFun = new NamedFunction(zeMem, SimpleMethodHandle.make(zeMem.getInvocationType(), zeForm),
1796                         MethodHandleImpl.Intrinsic.ZERO);
1797             }
1798 
1799             LF_zero[ord] = zeForm;
1800             NF_zero[ord] = zeFun;
1801             LF_identity[ord] = idForm;
1802             NF_identity[ord] = idFun;
1803 
1804             assert(idFun.isIdentity());
1805             assert(zeFun.isConstantZero());
1806             assert(new Name(zeFun).isConstantZero());
1807         }
1808     }
1809 
1810     // Avoid appealing to ValueConversions at bootstrap time:
1811     private static int identity_I(int x) { return x; }
1812     private static long identity_J(long x) { return x; }
1813     private static float identity_F(float x) { return x; }
1814     private static double identity_D(double x) { return x; }
1815     private static Object identity_L(Object x) { return x; }
1816     private static void identity_V() { return; }
1817     private static int zero_I() { return 0; }
1818     private static long zero_J() { return 0; }
1819     private static float zero_F() { return 0; }
1820     private static double zero_D() { return 0; }
1821     private static Object zero_L() { return null; }
1822 
1823     /**
1824      * Internal marker for byte-compiled LambdaForms.
1825      */
1826     /*non-public*/
1827     @Target(ElementType.METHOD)
1828     @Retention(RetentionPolicy.RUNTIME)
1829     @interface Compiled {
1830     }
1831 
1832     private static final HashMap&lt;String,Integer&gt; DEBUG_NAME_COUNTERS;
1833     private static final HashMap&lt;LambdaForm,String&gt; DEBUG_NAMES;
1834     static {
1835         if (debugEnabled()) {
1836             DEBUG_NAME_COUNTERS = new HashMap&lt;&gt;();
1837             DEBUG_NAMES = new HashMap&lt;&gt;();
1838         } else {
1839             DEBUG_NAME_COUNTERS = null;
1840             DEBUG_NAMES = null;
1841         }
1842     }
1843 
1844     static {
1845         // The Holder class will contain pre-generated forms resolved
1846         // using MemberName.getFactory(). However, that doesn&#39;t initialize the
1847         // class, which subtly breaks inlining etc. By forcing
1848         // initialization of the Holder class we avoid these issues.
1849         UNSAFE.ensureClassInitialized(Holder.class);
1850     }
1851 
1852     /* Placeholder class for zero and identity forms generated ahead of time */
1853     final class Holder {}
1854 
1855     // The following hack is necessary in order to suppress TRACE_INTERPRETER
1856     // during execution of the static initializes of this class.
1857     // Turning on TRACE_INTERPRETER too early will cause
1858     // stack overflows and other misbehavior during attempts to trace events
1859     // that occur during LambdaForm.&lt;clinit&gt;.
1860     // Therefore, do not move this line higher in this file, and do not remove.
1861     private static final boolean TRACE_INTERPRETER = MethodHandleStatics.TRACE_INTERPRETER;
1862 }
    </pre>
  </body>
</html>
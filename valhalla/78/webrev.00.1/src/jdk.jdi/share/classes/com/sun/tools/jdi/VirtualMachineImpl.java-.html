<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jdi/share/classes/com/sun/tools/jdi/VirtualMachineImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.jdi;
  27 
  28 import java.lang.ref.Reference;
  29 import java.lang.ref.ReferenceQueue;
  30 import java.lang.ref.SoftReference;
  31 import java.text.MessageFormat;
  32 import java.util.ArrayList;
  33 import java.util.Arrays;
  34 import java.util.Collections;
  35 import java.util.HashMap;
  36 import java.util.HashSet;
  37 import java.util.Iterator;
  38 import java.util.List;
  39 import java.util.Map;
  40 import java.util.Set;
  41 import java.util.function.Consumer;
  42 
  43 import com.sun.jdi.BooleanType;
  44 import com.sun.jdi.BooleanValue;
  45 import com.sun.jdi.ByteType;
  46 import com.sun.jdi.ByteValue;
  47 import com.sun.jdi.CharType;
  48 import com.sun.jdi.CharValue;
  49 import com.sun.jdi.ClassLoaderReference;
  50 import com.sun.jdi.ClassNotLoadedException;
  51 import com.sun.jdi.DoubleType;
  52 import com.sun.jdi.DoubleValue;
  53 import com.sun.jdi.FloatType;
  54 import com.sun.jdi.FloatValue;
  55 import com.sun.jdi.IntegerType;
  56 import com.sun.jdi.IntegerValue;
  57 import com.sun.jdi.InternalException;
  58 import com.sun.jdi.LongType;
  59 import com.sun.jdi.LongValue;
  60 import com.sun.jdi.ModuleReference;
  61 import com.sun.jdi.ObjectCollectedException;
  62 import com.sun.jdi.PathSearchingVirtualMachine;
  63 import com.sun.jdi.PrimitiveType;
  64 import com.sun.jdi.ReferenceType;
  65 import com.sun.jdi.ShortType;
  66 import com.sun.jdi.ShortValue;
  67 import com.sun.jdi.StringReference;
  68 import com.sun.jdi.ThreadGroupReference;
  69 import com.sun.jdi.ThreadReference;
  70 import com.sun.jdi.Type;
  71 import com.sun.jdi.VMDisconnectedException;
  72 import com.sun.jdi.VirtualMachine;
  73 import com.sun.jdi.VirtualMachineManager;
  74 import com.sun.jdi.VoidType;
  75 import com.sun.jdi.VoidValue;
  76 import com.sun.jdi.connect.spi.Connection;
  77 import com.sun.jdi.event.EventQueue;
  78 import com.sun.jdi.request.BreakpointRequest;
  79 import com.sun.jdi.request.EventRequest;
  80 import com.sun.jdi.request.EventRequestManager;
  81 
  82 class VirtualMachineImpl extends MirrorImpl
  83              implements PathSearchingVirtualMachine, ThreadListener {
  84     // VM Level exported variables, these
  85     // are unique to a given vm
  86     public final int sizeofFieldRef;
  87     public final int sizeofMethodRef;
  88     public final int sizeofObjectRef;
  89     public final int sizeofClassRef;
  90     public final int sizeofFrameRef;
  91     public final int sizeofModuleRef;
  92 
  93     final int sequenceNumber;
  94 
  95     private final TargetVM target;
  96     private final EventQueueImpl eventQueue;
  97     private final EventRequestManagerImpl internalEventRequestManager;
  98     private final EventRequestManagerImpl eventRequestManager;
  99     final VirtualMachineManagerImpl vmManager;
 100     private final ThreadGroup threadGroupForJDI;
 101 
 102     // Allow direct access to this field so that that tracing code slows down
 103     // JDI as little as possible when not enabled.
 104     int traceFlags = TRACE_NONE;
 105 
 106     static int TRACE_RAW_SENDS     = 0x01000000;
 107     static int TRACE_RAW_RECEIVES  = 0x02000000;
 108 
 109     boolean traceReceives = false;   // pre-compute because of frequency
 110 
 111     // ReferenceType access - updated with class prepare and unload events
 112     // Protected by &quot;synchronized(this)&quot;. &quot;retrievedAllTypes&quot; may be
 113     // tested unsynchronized (since once true, it stays true), but must
 114     // be set synchronously
 115     private Map&lt;Long, ReferenceType&gt; typesByID;
 116     private Set&lt;ReferenceType&gt; typesBySignature;
 117     private boolean retrievedAllTypes = false;
 118 
 119     private Map&lt;Long, ModuleReference&gt; modulesByID;
 120 
 121     // For other languages support
 122     private String defaultStratum = null;
 123 
 124     // ObjectReference cache
 125     // &quot;objectsByID&quot; protected by &quot;synchronized(this)&quot;.
 126     private final Map&lt;Long, SoftObjectReference&gt; objectsByID = new HashMap&lt;&gt;();
 127     private final ReferenceQueue&lt;ObjectReferenceImpl&gt; referenceQueue = new ReferenceQueue&lt;&gt;();
 128     static private final int DISPOSE_THRESHOLD = 50;
 129     private final List&lt;SoftObjectReference&gt; batchedDisposeRequests =
 130             Collections.synchronizedList(new ArrayList&lt;&gt;(DISPOSE_THRESHOLD + 10));
 131 
 132     // These are cached once for the life of the VM
 133     private JDWP.VirtualMachine.Version versionInfo;
 134     private JDWP.VirtualMachine.ClassPaths pathInfo;
 135     private JDWP.VirtualMachine.Capabilities capabilities = null;
 136     private JDWP.VirtualMachine.CapabilitiesNew capabilitiesNew = null;
 137 
 138     // Per-vm singletons for primitive types and for void.
 139     // singleton-ness protected by &quot;synchronized(this)&quot;.
 140     private BooleanType theBooleanType;
 141     private ByteType    theByteType;
 142     private CharType    theCharType;
 143     private ShortType   theShortType;
 144     private IntegerType theIntegerType;
 145     private LongType    theLongType;
 146     private FloatType   theFloatType;
 147     private DoubleType  theDoubleType;
 148 
 149     private VoidType    theVoidType;
 150 
 151     private VoidValue voidVal;
 152 
 153     // Launched debuggee process
 154     private Process process;
 155 
 156     // coordinates state changes and corresponding listener notifications
 157     private VMState state = new VMState(this);
 158 
 159     private Object initMonitor = new Object();
 160     private boolean initComplete = false;
 161     private boolean shutdown = false;
 162 
 163     private void notifyInitCompletion() {
 164         synchronized(initMonitor) {
 165             initComplete = true;
 166             initMonitor.notifyAll();
 167         }
 168     }
 169 
 170     void waitInitCompletion() {
 171         synchronized(initMonitor) {
 172             while (!initComplete) {
 173                 try {
 174                     initMonitor.wait();
 175                 } catch (InterruptedException e) {
 176                     // ignore
 177                 }
 178             }
 179         }
 180     }
 181 
 182     VMState state() {
 183         return state;
 184     }
 185 
 186     /*
 187      * ThreadListener implementation
 188      */
 189     public boolean threadResumable(ThreadAction action) {
 190         /*
 191          * If any thread is resumed, the VM is considered not suspended.
 192          * Just one thread is being resumed so pass it to thaw.
 193          */
 194         state.thaw(action.thread());
 195         return true;
 196     }
 197 
 198     VirtualMachineImpl(VirtualMachineManager manager,
 199                        Connection connection, Process process,
 200                        int sequenceNumber) {
 201         super(null);  // Can&#39;t use super(this)
 202         vm = this;
 203 
 204         this.vmManager = (VirtualMachineManagerImpl)manager;
 205         this.process = process;
 206         this.sequenceNumber = sequenceNumber;
 207 
 208         /* Create ThreadGroup to be used by all threads servicing
 209          * this VM.
 210          */
 211         threadGroupForJDI = new ThreadGroup(vmManager.mainGroupForJDI(),
 212                                             &quot;JDI [&quot; +
 213                                             this.hashCode() + &quot;]&quot;);
 214 
 215         /*
 216          * Set up a thread to communicate with the target VM over
 217          * the specified transport.
 218          */
 219         target = new TargetVM(this, connection);
 220 
 221         /*
 222          * Set up a thread to handle events processed internally
 223          * the JDI implementation.
 224          */
 225         EventQueueImpl internalEventQueue = new EventQueueImpl(this, target);
 226         new InternalEventHandler(this, internalEventQueue);
 227         /*
 228          * Initialize client access to event setting and handling
 229          */
 230         eventQueue = new EventQueueImpl(this, target);
 231         eventRequestManager = new EventRequestManagerImpl(this);
 232 
 233         target.start();
 234 
 235         /*
 236          * Many ids are variably sized, depending on target VM.
 237          * Find out the sizes right away.
 238          */
 239         JDWP.VirtualMachine.IDSizes idSizes;
 240         try {
 241             idSizes = JDWP.VirtualMachine.IDSizes.process(vm);
 242         } catch (JDWPException exc) {
 243             throw exc.toJDIException();
 244         }
 245         sizeofFieldRef  = idSizes.fieldIDSize;
 246         sizeofMethodRef = idSizes.methodIDSize;
 247         sizeofObjectRef = idSizes.objectIDSize;
 248         sizeofClassRef = idSizes.referenceTypeIDSize;
 249         sizeofFrameRef  = idSizes.frameIDSize;
 250         sizeofModuleRef = idSizes.objectIDSize;
 251 
 252         /**
 253          * Set up requests needed by internal event handler.
 254          * Make sure they are distinguished by creating them with
 255          * an internal event request manager.
 256          *
 257          * Warning: create events only with SUSPEND_NONE policy.
 258          * In the current implementation other policies will not
 259          * be handled correctly when the event comes in. (notfiySuspend()
 260          * will not be properly called, and if the event is combined
 261          * with external events in the same set, suspend policy is not
 262          * correctly determined for the internal vs. external event sets)
 263          */
 264         internalEventRequestManager = new EventRequestManagerImpl(this);
 265         EventRequest er = internalEventRequestManager.createClassPrepareRequest();
 266         er.setSuspendPolicy(EventRequest.SUSPEND_NONE);
 267         er.enable();
 268         er = internalEventRequestManager.createClassUnloadRequest();
 269         er.setSuspendPolicy(EventRequest.SUSPEND_NONE);
 270         er.enable();
 271 
 272         /*
 273          * Tell other threads, notably TargetVM, that initialization
 274          * is complete.
 275          */
 276         notifyInitCompletion();
 277     }
 278 
 279     EventRequestManagerImpl getInternalEventRequestManager() {
 280         return internalEventRequestManager;
 281     }
 282 
 283     void validateVM() {
 284         /*
 285          * We no longer need to do this.  The spec now says
 286          * that a VMDisconnected _may_ be thrown in these
 287          * cases, not that it _will_ be thrown.
 288          * So, to simplify things we will just let the
 289          * caller&#39;s of this method proceed with their business.
 290          * If the debuggee is disconnected, either because it
 291          * crashed or finished or something, or because the
 292          * debugger called exit() or dispose(), then if
 293          * we end up trying to communicate with the debuggee,
 294          * code in TargetVM will throw a VMDisconnectedException.
 295          * This means that if we can satisfy a request without
 296          * talking to the debuggee, (eg, with cached data) then
 297          * VMDisconnectedException will _not_ be thrown.
 298          * if (shutdown) {
 299          *    throw new VMDisconnectedException();
 300          * }
 301          */
 302     }
 303 
 304     public boolean equals(Object obj) {
 305         return this == obj;
 306     }
 307 
 308     public int hashCode() {
 309         return System.identityHashCode(this);
 310     }
 311 
 312     public List&lt;ModuleReference&gt; allModules() {
 313         validateVM();
 314         List&lt;ModuleReference&gt; modules = retrieveAllModules();
 315         return Collections.unmodifiableList(modules);
 316     }
 317 
 318     public List&lt;ReferenceType&gt; classesByName(String className) {
 319         validateVM();
 320         return classesBySignature(JNITypeParser.typeNameToSignature(className));
 321     }
 322 
 323     List&lt;ReferenceType&gt; classesBySignature(String signature) {
 324         validateVM();
 325         List&lt;ReferenceType&gt; list;
 326         if (retrievedAllTypes) {
 327             list = findReferenceTypes(signature);
 328         } else {
 329             list = retrieveClassesBySignature(signature);
 330         }
 331         return Collections.unmodifiableList(list);
 332     }
 333 
 334     public List&lt;ReferenceType&gt; allClasses() {
 335         validateVM();
 336 
 337         if (!retrievedAllTypes) {
 338             retrieveAllClasses();
 339         }
 340         ArrayList&lt;ReferenceType&gt; a;
 341         synchronized (this) {
 342             a = new ArrayList&lt;&gt;(typesBySignature);
 343         }
 344         return Collections.unmodifiableList(a);
 345     }
 346 
 347     /**
 348      * Performs an action for each loaded type.
 349      */
 350     public void forEachClass(Consumer&lt;ReferenceType&gt; action) {
 351         for (ReferenceType type : allClasses()) {
 352             try {
 353                 action.accept(type);
 354             } catch (ObjectCollectedException ex) {
 355                 // Some classes might be unloaded and garbage collected since
 356                 // we retrieved the copy of all loaded classes and started
 357                 // iterating over them. In this case calling methods on such types
 358                 // might result in com.sun.jdi.ObjectCollectedException
 359                 // being thrown. We ignore such classes and keep iterating.
 360                 if ((vm.traceFlags &amp; VirtualMachine.TRACE_OBJREFS) != 0) {
 361                     vm.printTrace(&quot;ObjectCollectedException was thrown while &quot; +
 362                             &quot;accessing unloaded class &quot; + type.name());
 363                 }
 364             }
 365         }
 366     }
 367 
 368     public void
 369         redefineClasses(Map&lt;? extends ReferenceType, byte[]&gt; classToBytes)
 370     {
 371         int cnt = classToBytes.size();
 372         JDWP.VirtualMachine.RedefineClasses.ClassDef[] defs =
 373             new JDWP.VirtualMachine.RedefineClasses.ClassDef[cnt];
 374         validateVM();
 375         if (!canRedefineClasses()) {
 376             throw new UnsupportedOperationException();
 377         }
 378         Iterator&lt;?&gt; it = classToBytes.entrySet().iterator();
 379         for (int i = 0; it.hasNext(); i++) {
 380             @SuppressWarnings(&quot;rawtypes&quot;)
 381             Map.Entry&lt;?, ?&gt; entry = (Map.Entry)it.next();
 382             ReferenceTypeImpl refType = (ReferenceTypeImpl)entry.getKey();
 383             validateMirror(refType);
 384             defs[i] = new JDWP.VirtualMachine.RedefineClasses
 385                        .ClassDef(refType, (byte[])entry.getValue());
 386         }
 387 
 388         // flush caches and disable caching until the next suspend
 389         vm.state().thaw();
 390 
 391         try {
 392             JDWP.VirtualMachine.RedefineClasses.
 393                 process(vm, defs);
 394         } catch (JDWPException exc) {
 395             switch (exc.errorCode()) {
 396             case JDWP.Error.INVALID_CLASS_FORMAT :
 397                 throw new ClassFormatError(
 398                     &quot;class not in class file format&quot;);
 399             case JDWP.Error.CIRCULAR_CLASS_DEFINITION :
 400                 throw new ClassCircularityError(
 401                     &quot;circularity has been detected while initializing a class&quot;);
 402             case JDWP.Error.FAILS_VERIFICATION :
 403                 throw new VerifyError(
 404                     &quot;verifier detected internal inconsistency or security problem&quot;);
 405             case JDWP.Error.UNSUPPORTED_VERSION :
 406                 throw new UnsupportedClassVersionError(
 407                     &quot;version numbers of class are not supported&quot;);
 408             case JDWP.Error.ADD_METHOD_NOT_IMPLEMENTED:
 409                 throw new UnsupportedOperationException(
 410                     &quot;add method not implemented&quot;);
 411             case JDWP.Error.SCHEMA_CHANGE_NOT_IMPLEMENTED :
 412                 throw new UnsupportedOperationException(
 413                     &quot;schema change not implemented&quot;);
 414             case JDWP.Error.HIERARCHY_CHANGE_NOT_IMPLEMENTED:
 415                 throw new UnsupportedOperationException(
 416                     &quot;hierarchy change not implemented&quot;);
 417             case JDWP.Error.DELETE_METHOD_NOT_IMPLEMENTED :
 418                 throw new UnsupportedOperationException(
 419                     &quot;delete method not implemented&quot;);
 420             case JDWP.Error.CLASS_MODIFIERS_CHANGE_NOT_IMPLEMENTED:
 421                 throw new UnsupportedOperationException(
 422                     &quot;changes to class modifiers not implemented&quot;);
 423             case JDWP.Error.METHOD_MODIFIERS_CHANGE_NOT_IMPLEMENTED :
 424                 throw new UnsupportedOperationException(
 425                     &quot;changes to method modifiers not implemented&quot;);
 426             case JDWP.Error.CLASS_ATTRIBUTE_CHANGE_NOT_IMPLEMENTED :
 427                 throw new UnsupportedOperationException(
 428                     &quot;changes to class attribute not implemented&quot;);
 429             case JDWP.Error.NAMES_DONT_MATCH :
 430                 throw new NoClassDefFoundError(
 431                     &quot;class names do not match&quot;);
 432             default:
 433                 throw exc.toJDIException();
 434             }
 435         }
 436 
 437         // Delete any record of the breakpoints
 438         List&lt;BreakpointRequest&gt; toDelete = new ArrayList&lt;&gt;();
 439         EventRequestManager erm = eventRequestManager();
 440         it = erm.breakpointRequests().iterator();
 441         while (it.hasNext()) {
 442             BreakpointRequest req = (BreakpointRequest)it.next();
 443             if (classToBytes.containsKey(req.location().declaringType())) {
 444                 toDelete.add(req);
 445             }
 446         }
 447         erm.deleteEventRequests(toDelete);
 448 
 449         // Invalidate any information cached for the classes just redefined.
 450         it = classToBytes.keySet().iterator();
 451         while (it.hasNext()) {
 452             ReferenceTypeImpl rti = (ReferenceTypeImpl)it.next();
 453             rti.noticeRedefineClass();
 454         }
 455     }
 456 
 457     public List&lt;ThreadReference&gt; allThreads() {
 458         validateVM();
 459         return state.allThreads();
 460     }
 461 
 462     public List&lt;ThreadGroupReference&gt; topLevelThreadGroups() {
 463         validateVM();
 464         return state.topLevelThreadGroups();
 465     }
 466 
 467     /*
 468      * Sends a command to the back end which is defined to do an
 469      * implicit vm-wide resume. The VM can no longer be considered
 470      * suspended, so certain cached data must be invalidated.
 471      */
 472     PacketStream sendResumingCommand(CommandSender sender) {
 473         return state.thawCommand(sender);
 474     }
 475 
 476     /*
 477      * The VM has been suspended. Additional caching can be done
 478      * as long as there are no pending resumes.
 479      */
 480     void notifySuspend() {
 481         state.freeze();
 482     }
 483 
 484     public void suspend() {
 485         validateVM();
 486         try {
 487             JDWP.VirtualMachine.Suspend.process(vm);
 488         } catch (JDWPException exc) {
 489             throw exc.toJDIException();
 490         }
 491         notifySuspend();
 492     }
 493 
 494     public void resume() {
 495         validateVM();
 496         CommandSender sender =
 497             new CommandSender() {
 498                 public PacketStream send() {
 499                     return JDWP.VirtualMachine.Resume.enqueueCommand(vm);
 500                 }
 501         };
 502         try {
 503             PacketStream stream = state.thawCommand(sender);
 504             JDWP.VirtualMachine.Resume.waitForReply(vm, stream);
 505         } catch (VMDisconnectedException exc) {
 506             /*
 507              * If the debugger makes a VMDeathRequest with SUSPEND_ALL,
 508              * then when it does an EventSet.resume after getting the
 509              * VMDeathEvent, the normal flow of events is that the
 510              * BE shuts down, but the waitForReply comes back ok.  In this
 511              * case, the run loop in TargetVM that is waiting for a packet
 512              * gets an EOF because the socket closes. It generates a
 513              * VMDisconnectedEvent and everyone is happy.
 514              * However, sometimes, the BE gets shutdown before this
 515              * waitForReply completes.  In this case, TargetVM.waitForReply
 516              * gets awakened with no reply and so gens a VMDisconnectedException
 517              * which is not what we want.  It might be possible to fix this
 518              * in the BE, but it is ok to just ignore the VMDisconnectedException
 519              * here.  This will allow the VMDisconnectedEvent to be generated
 520              * correctly.  And, if the debugger should happen to make another
 521              * request, it will get a VMDisconnectedException at that time.
 522              */
 523         } catch (JDWPException exc) {
 524             switch (exc.errorCode()) {
 525                 case JDWP.Error.VM_DEAD:
 526                     return;
 527                 default:
 528                     throw exc.toJDIException();
 529             }
 530         }
 531     }
 532 
 533     public EventQueue eventQueue() {
 534         /*
 535          * No VM validation here. We allow access to the event queue
 536          * after disconnection, so that there is access to the terminating
 537          * events.
 538          */
 539         return eventQueue;
 540     }
 541 
 542     public EventRequestManager eventRequestManager() {
 543         validateVM();
 544         return eventRequestManager;
 545     }
 546 
 547     EventRequestManagerImpl eventRequestManagerImpl() {
 548         return eventRequestManager;
 549     }
 550 
 551     public BooleanValue mirrorOf(boolean value) {
 552         validateVM();
 553         return new BooleanValueImpl(this,value);
 554     }
 555 
 556     public ByteValue mirrorOf(byte value) {
 557         validateVM();
 558         return new ByteValueImpl(this,value);
 559     }
 560 
 561     public CharValue mirrorOf(char value) {
 562         validateVM();
 563         return new CharValueImpl(this,value);
 564     }
 565 
 566     public ShortValue mirrorOf(short value) {
 567         validateVM();
 568         return new ShortValueImpl(this,value);
 569     }
 570 
 571     public IntegerValue mirrorOf(int value) {
 572         validateVM();
 573         return new IntegerValueImpl(this,value);
 574     }
 575 
 576     public LongValue mirrorOf(long value) {
 577         validateVM();
 578         return new LongValueImpl(this,value);
 579     }
 580 
 581     public FloatValue mirrorOf(float value) {
 582         validateVM();
 583         return new FloatValueImpl(this,value);
 584     }
 585 
 586     public DoubleValue mirrorOf(double value) {
 587         validateVM();
 588         return new DoubleValueImpl(this,value);
 589     }
 590 
 591     public StringReference mirrorOf(String value) {
 592         validateVM();
 593         try {
 594             return JDWP.VirtualMachine.CreateString.
 595                 process(vm, value).stringObject;
 596         } catch (JDWPException exc) {
 597             throw exc.toJDIException();
 598         }
 599     }
 600 
 601     public VoidValue mirrorOfVoid() {
 602         if (voidVal == null) {
 603             voidVal = new VoidValueImpl(this);
 604         }
 605         return voidVal;
 606     }
 607 
 608     public long[] instanceCounts(List&lt;? extends ReferenceType&gt; classes) {
 609         if (!canGetInstanceInfo()) {
 610             throw new UnsupportedOperationException(
 611                 &quot;target does not support getting instances&quot;);
 612         }
 613         long[] retValue ;
 614         ReferenceTypeImpl[] rtArray = new ReferenceTypeImpl[classes.size()];
 615         int ii = 0;
 616         for (ReferenceType rti: classes) {
 617             validateMirror(rti);
 618             rtArray[ii++] = (ReferenceTypeImpl)rti;
 619         }
 620         try {
 621             retValue = JDWP.VirtualMachine.InstanceCounts.
 622                                 process(vm, rtArray).counts;
 623         } catch (JDWPException exc) {
 624             throw exc.toJDIException();
 625         }
 626 
 627         return retValue;
 628     }
 629 
 630     public void dispose() {
 631         validateVM();
 632         shutdown = true;
 633         try {
 634             JDWP.VirtualMachine.Dispose.process(vm);
 635         } catch (JDWPException exc) {
 636             throw exc.toJDIException();
 637         }
 638         target.stopListening();
 639     }
 640 
 641     public void exit(int exitCode) {
 642         validateVM();
 643         shutdown = true;
 644         try {
 645             JDWP.VirtualMachine.Exit.process(vm, exitCode);
 646         } catch (JDWPException exc) {
 647             throw exc.toJDIException();
 648         }
 649         target.stopListening();
 650     }
 651 
 652     public Process process() {
 653         validateVM();
 654         return process;
 655     }
 656 
 657     private JDWP.VirtualMachine.Version versionInfo() {
 658        try {
 659            if (versionInfo == null) {
 660                // Need not be synchronized since it is static information
 661                versionInfo = JDWP.VirtualMachine.Version.process(vm);
 662            }
 663            return versionInfo;
 664        } catch (JDWPException exc) {
 665            throw exc.toJDIException();
 666        }
 667     }
 668 
 669     public String description() {
 670         validateVM();
 671 
 672         return MessageFormat.format(vmManager.getString(&quot;version_format&quot;),
 673                                     &quot;&quot; + vmManager.majorInterfaceVersion(),
 674                                     &quot;&quot; + vmManager.minorInterfaceVersion(),
 675                                      versionInfo().description);
 676     }
 677 
 678     public String version() {
 679         validateVM();
 680         return versionInfo().vmVersion;
 681     }
 682 
 683     public String name() {
 684         validateVM();
 685         return versionInfo().vmName;
 686     }
 687 
 688     public boolean canWatchFieldModification() {
 689         validateVM();
 690         return capabilities().canWatchFieldModification;
 691     }
 692 
 693     public boolean canWatchFieldAccess() {
 694         validateVM();
 695         return capabilities().canWatchFieldAccess;
 696     }
 697 
 698     public boolean canGetBytecodes() {
 699         validateVM();
 700         return capabilities().canGetBytecodes;
 701     }
 702 
 703     public boolean canGetSyntheticAttribute() {
 704         validateVM();
 705         return capabilities().canGetSyntheticAttribute;
 706     }
 707 
 708     public boolean canGetOwnedMonitorInfo() {
 709         validateVM();
 710         return capabilities().canGetOwnedMonitorInfo;
 711     }
 712 
 713     public boolean canGetCurrentContendedMonitor() {
 714         validateVM();
 715         return capabilities().canGetCurrentContendedMonitor;
 716     }
 717 
 718     public boolean canGetMonitorInfo() {
 719         validateVM();
 720         return capabilities().canGetMonitorInfo;
 721     }
 722 
 723     private boolean hasNewCapabilities() {
 724         return versionInfo().jdwpMajor &gt; 1 ||
 725             versionInfo().jdwpMinor &gt;= 4;
 726     }
 727 
 728     boolean canGet1_5LanguageFeatures() {
 729         return versionInfo().jdwpMajor &gt; 1 ||
 730             versionInfo().jdwpMinor &gt;= 5;
 731     }
 732 
 733     public boolean canUseInstanceFilters() {
 734         validateVM();
 735         return hasNewCapabilities() &amp;&amp;
 736             capabilitiesNew().canUseInstanceFilters;
 737     }
 738 
 739     public boolean canRedefineClasses() {
 740         validateVM();
 741         return hasNewCapabilities() &amp;&amp;
 742             capabilitiesNew().canRedefineClasses;
 743     }
 744 
 745     @Deprecated(since=&quot;15&quot;)
 746     public boolean canAddMethod() {
 747         validateVM();
 748         return hasNewCapabilities() &amp;&amp;
 749             capabilitiesNew().canAddMethod;
 750     }
 751 
 752     @Deprecated(since=&quot;15&quot;)
 753     public boolean canUnrestrictedlyRedefineClasses() {
 754         validateVM();
 755         return hasNewCapabilities() &amp;&amp;
 756             capabilitiesNew().canUnrestrictedlyRedefineClasses;
 757     }
 758 
 759     public boolean canPopFrames() {
 760         validateVM();
 761         return hasNewCapabilities() &amp;&amp;
 762             capabilitiesNew().canPopFrames;
 763     }
 764 
 765     public boolean canGetMethodReturnValues() {
 766         return versionInfo().jdwpMajor &gt; 1 ||
 767             versionInfo().jdwpMinor &gt;= 6;
 768     }
 769 
 770     public boolean canGetInstanceInfo() {
 771         if (versionInfo().jdwpMajor &gt; 1 ||
 772             versionInfo().jdwpMinor &gt;= 6) {
 773             validateVM();
 774             return hasNewCapabilities() &amp;&amp;
 775                 capabilitiesNew().canGetInstanceInfo;
 776         } else {
 777             return false;
 778         }
 779     }
 780 
 781     public boolean canUseSourceNameFilters() {
 782         return versionInfo().jdwpMajor &gt; 1 ||
 783             versionInfo().jdwpMinor &gt;= 6;
 784     }
 785 
 786     public boolean canForceEarlyReturn() {
 787         validateVM();
 788         return hasNewCapabilities() &amp;&amp;
 789             capabilitiesNew().canForceEarlyReturn;
 790     }
 791 
 792     public boolean canBeModified() {
 793         return true;
 794     }
 795 
 796     public boolean canGetSourceDebugExtension() {
 797         validateVM();
 798         return hasNewCapabilities() &amp;&amp;
 799             capabilitiesNew().canGetSourceDebugExtension;
 800     }
 801 
 802     public boolean canGetClassFileVersion() {
 803         return versionInfo().jdwpMajor &gt; 1 ||
 804             versionInfo().jdwpMinor &gt;= 6;
 805     }
 806 
 807     public boolean canGetConstantPool() {
 808         validateVM();
 809         return hasNewCapabilities() &amp;&amp;
 810             capabilitiesNew().canGetConstantPool;
 811     }
 812 
 813     public boolean canRequestVMDeathEvent() {
 814         validateVM();
 815         return hasNewCapabilities() &amp;&amp;
 816             capabilitiesNew().canRequestVMDeathEvent;
 817     }
 818 
 819     public boolean canRequestMonitorEvents() {
 820         validateVM();
 821         return hasNewCapabilities() &amp;&amp;
 822             capabilitiesNew().canRequestMonitorEvents;
 823     }
 824 
 825     public boolean canGetMonitorFrameInfo() {
 826         validateVM();
 827         return hasNewCapabilities() &amp;&amp;
 828             capabilitiesNew().canGetMonitorFrameInfo;
 829     }
 830 
 831     public boolean canGetModuleInfo() {
 832         validateVM();
 833         return versionInfo().jdwpMajor &gt;= 9;
 834     }
 835 
 836     public void setDebugTraceMode(int traceFlags) {
 837         validateVM();
 838         this.traceFlags = traceFlags;
 839         this.traceReceives = (traceFlags &amp; TRACE_RECEIVES) != 0;
 840     }
 841 
 842     void printTrace(String string) {
 843         System.err.println(&quot;[JDI: &quot; + string + &quot;]&quot;);
 844     }
 845 
 846     void printReceiveTrace(int depth, String string) {
 847         StringBuilder sb = new StringBuilder(&quot;Receiving:&quot;);
 848         for (int i = depth; i &gt; 0; --i) {
 849             sb.append(&quot;    &quot;);
 850         }
 851         sb.append(string);
 852         printTrace(sb.toString());
 853     }
 854 
 855     private synchronized ReferenceTypeImpl addReferenceType(long id,
 856                                                             int tag,
 857                                                             String signature) {
 858         if (typesByID == null) {
 859             initReferenceTypes();
 860         }
 861         ReferenceTypeImpl type = null;
 862         switch(tag) {
 863             case JDWP.TypeTag.CLASS:
 864                 type = new ClassTypeImpl(vm, id);
 865                 break;
 866             case JDWP.TypeTag.INTERFACE:
 867                 type = new InterfaceTypeImpl(vm, id);
 868                 break;
 869             case JDWP.TypeTag.ARRAY:
 870                 type = new ArrayTypeImpl(vm, id);
 871                 break;
 872             default:
 873                 throw new InternalException(&quot;Invalid reference type tag&quot;);
 874         }
 875 
 876         if (signature == null &amp;&amp; retrievedAllTypes) {
 877             // do not cache if signature is not provided
 878             return type;
 879         }
 880 
 881         typesByID.put(id, type);
 882         typesBySignature.add(type);
 883 
 884         if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
 885            vm.printTrace(&quot;Caching new ReferenceType, sig=&quot; + signature +
 886                          &quot;, id=&quot; + id);
 887         }
 888 
 889         return type;
 890     }
 891 
 892     synchronized void removeReferenceType(String signature) {
 893         if (typesByID == null) {
 894             return;
 895         }
 896         /*
 897          * There can be multiple classes with the same name. Since
 898          * we can&#39;t differentiate here, we first remove all
 899          * matching classes from our cache...
 900          */
 901         Iterator&lt;ReferenceType&gt; iter = typesBySignature.iterator();
 902         int matches = 0;
 903         while (iter.hasNext()) {
 904             ReferenceTypeImpl type = (ReferenceTypeImpl)iter.next();
 905             int comp = signature.compareTo(type.signature());
 906             if (comp == 0) {
 907                 matches++;
 908                 iter.remove();
 909                 typesByID.remove(type.ref());
 910                 if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
 911                    vm.printTrace(&quot;Uncaching ReferenceType, sig=&quot; + signature +
 912                                  &quot;, id=&quot; + type.ref());
 913                 }
 914                 // fix for 4359077, don&#39;t break out. list is no longer sorted
 915                 // in the order we think
 916             }
 917         }
 918 
 919         /*
 920          * ...and if there was more than one, re-retrieve the classes
 921          * with that name
 922          */
 923         if (matches &gt; 1) {
 924             retrieveClassesBySignature(signature);
 925         }
 926     }
 927 
 928     private synchronized List&lt;ReferenceType&gt; findReferenceTypes(String signature) {
 929         if (typesByID == null) {
 930             return new ArrayList&lt;&gt;(0);
 931         }
 932         Iterator&lt;ReferenceType&gt; iter = typesBySignature.iterator();
 933         List&lt;ReferenceType&gt; list = new ArrayList&lt;&gt;();
 934         while (iter.hasNext()) {
 935             ReferenceTypeImpl type = (ReferenceTypeImpl)iter.next();
 936             int comp = signature.compareTo(type.signature());
 937             if (comp == 0) {
 938                 list.add(type);
 939                 // fix for 4359077, don&#39;t break out. list is no longer sorted
 940                 // in the order we think
 941             }
 942         }
 943         return list;
 944     }
 945 
 946     private void initReferenceTypes() {
 947         typesByID = new HashMap&lt;&gt;(300);
 948         typesBySignature = new HashSet&lt;&gt;();
 949     }
 950 
 951     ReferenceTypeImpl referenceType(long ref, byte tag) {
 952         return referenceType(ref, tag, null);
 953     }
 954 
 955     ClassTypeImpl classType(long ref) {
 956         return (ClassTypeImpl)referenceType(ref, JDWP.TypeTag.CLASS, null);
 957     }
 958 
 959     InterfaceTypeImpl interfaceType(long ref) {
 960         return (InterfaceTypeImpl)referenceType(ref, JDWP.TypeTag.INTERFACE, null);
 961     }
 962 
 963     ArrayTypeImpl arrayType(long ref) {
 964         return (ArrayTypeImpl)referenceType(ref, JDWP.TypeTag.ARRAY, null);
 965     }
 966 
 967     ReferenceTypeImpl referenceType(long id, int tag, String signature) {
 968         if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
 969             StringBuilder sb = new StringBuilder();
 970             sb.append(&quot;Looking up &quot;);
 971             if (tag == JDWP.TypeTag.CLASS) {
 972                 sb.append(&quot;Class&quot;);
 973             } else if (tag == JDWP.TypeTag.INTERFACE) {
 974                 sb.append(&quot;Interface&quot;);
 975             } else if (tag == JDWP.TypeTag.ARRAY) {
 976                 sb.append(&quot;ArrayType&quot;);
 977             } else {
 978                 sb.append(&quot;UNKNOWN TAG: &quot;).append(tag);
 979             }
 980             if (signature != null) {
 981                 sb.append(&quot;, signature=&#39;&quot;).append(signature).append(&#39;\&#39;&#39;);
 982             }
 983             sb.append(&quot;, id=&quot;).append(id);
 984             vm.printTrace(sb.toString());
 985         }
 986         if (id == 0) {
 987             return null;
 988         } else {
 989             ReferenceTypeImpl retType = null;
 990             synchronized (this) {
 991                 if (typesByID != null) {
 992                     retType = (ReferenceTypeImpl)typesByID.get(id);
 993                 }
 994                 if (retType == null) {
 995                     retType = addReferenceType(id, tag, signature);
 996                 }
 997                 if (signature != null) {
 998                     retType.setSignature(signature);
 999                 }
1000             }
1001             return retType;
1002         }
1003     }
1004 
1005     private JDWP.VirtualMachine.Capabilities capabilities() {
1006         if (capabilities == null) {
1007             try {
1008                 capabilities = JDWP.VirtualMachine
1009                                  .Capabilities.process(vm);
1010             } catch (JDWPException exc) {
1011                 throw exc.toJDIException();
1012             }
1013         }
1014         return capabilities;
1015     }
1016 
1017     private JDWP.VirtualMachine.CapabilitiesNew capabilitiesNew() {
1018         if (capabilitiesNew == null) {
1019             try {
1020                 capabilitiesNew = JDWP.VirtualMachine
1021                                  .CapabilitiesNew.process(vm);
1022             } catch (JDWPException exc) {
1023                 throw exc.toJDIException();
1024             }
1025         }
1026         return capabilitiesNew;
1027     }
1028 
1029     private synchronized ModuleReference addModule(long id) {
1030         if (modulesByID == null) {
1031             modulesByID = new HashMap&lt;&gt;(77);
1032         }
1033         ModuleReference module = new ModuleReferenceImpl(vm, id);
1034         modulesByID.put(id, module);
1035         return module;
1036     }
1037 
1038     ModuleReference getModule(long id) {
1039         if (id == 0) {
1040             return null;
1041         } else {
1042             ModuleReference module = null;
1043             synchronized (this) {
1044                 if (modulesByID != null) {
1045                     module = modulesByID.get(id);
1046                 }
1047                 if (module == null) {
1048                     module = addModule(id);
1049                 }
1050             }
1051             return module;
1052         }
1053     }
1054 
1055     private synchronized List&lt;ModuleReference&gt; retrieveAllModules() {
1056         ModuleReferenceImpl[] reqModules;
1057         try {
1058             reqModules = JDWP.VirtualMachine.AllModules.process(vm).modules;
1059         } catch (JDWPException exc) {
1060             throw exc.toJDIException();
1061         }
1062         ArrayList&lt;ModuleReference&gt; modules = new ArrayList&lt;&gt;();
1063         for (int i = 0; i &lt; reqModules.length; i++) {
1064             long moduleRef = reqModules[i].ref();
1065             ModuleReference module = getModule(moduleRef);
1066             modules.add(module);
1067         }
1068         return modules;
1069     }
1070 
1071     private List&lt;ReferenceType&gt; retrieveClassesBySignature(String signature) {
1072         if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
1073             vm.printTrace(&quot;Retrieving matching ReferenceTypes, sig=&quot; + signature);
1074         }
1075         JDWP.VirtualMachine.ClassesBySignature.ClassInfo[] cinfos;
1076         try {
1077             cinfos = JDWP.VirtualMachine.ClassesBySignature.
1078                                       process(vm, signature).classes;
1079         } catch (JDWPException exc) {
1080             throw exc.toJDIException();
1081         }
1082 
1083         int count = cinfos.length;
1084         List&lt;ReferenceType&gt; list = new ArrayList&lt;&gt;(count);
1085 
1086         // Hold lock during processing to improve performance
1087         synchronized (this) {
1088             for (int i = 0; i &lt; count; i++) {
1089                 JDWP.VirtualMachine.ClassesBySignature.ClassInfo ci =
1090                                                                cinfos[i];
1091                 ReferenceTypeImpl type = referenceType(ci.typeID,
1092                                                        ci.refTypeTag,
1093                                                        signature);
1094                 type.setStatus(ci.status);
1095                 list.add(type);
1096             }
1097         }
1098         return list;
1099     }
1100 
1101     private void retrieveAllClasses1_4() {
1102         JDWP.VirtualMachine.AllClasses.ClassInfo[] cinfos;
1103         try {
1104             cinfos = JDWP.VirtualMachine.AllClasses.process(vm).classes;
1105         } catch (JDWPException exc) {
1106             throw exc.toJDIException();
1107         }
1108 
1109         // Hold lock during processing to improve performance
1110         // and to have safe check/set of retrievedAllTypes
1111         synchronized (this) {
1112             if (!retrievedAllTypes) {
1113                 // Number of classes
1114                 int count = cinfos.length;
1115                 for (int i = 0; i &lt; count; i++) {
1116                     JDWP.VirtualMachine.AllClasses.ClassInfo ci = cinfos[i];
1117                     ReferenceTypeImpl type = referenceType(ci.typeID,
1118                                                            ci.refTypeTag,
1119                                                            ci.signature);
1120                     type.setStatus(ci.status);
1121                 }
1122                 retrievedAllTypes = true;
1123             }
1124         }
1125     }
1126 
1127     private void retrieveAllClasses() {
1128         if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
1129             vm.printTrace(&quot;Retrieving all ReferenceTypes&quot;);
1130         }
1131 
1132         if (!vm.canGet1_5LanguageFeatures()) {
1133             retrieveAllClasses1_4();
1134             return;
1135         }
1136 
1137         /*
1138          * To save time (assuming the caller will be
1139          * using then) we will get the generic sigs too.
1140          */
1141         JDWP.VirtualMachine.AllClassesWithGeneric.ClassInfo[] cinfos;
1142         try {
1143             cinfos = JDWP.VirtualMachine.AllClassesWithGeneric.process(vm).classes;
1144         } catch (JDWPException exc) {
1145             throw exc.toJDIException();
1146         }
1147 
1148         // Hold lock during processing to improve performance
1149         // and to have safe check/set of retrievedAllTypes
1150         synchronized (this) {
1151             if (!retrievedAllTypes) {
1152                 // Number of classes
1153                 int count = cinfos.length;
1154                 for (int i = 0; i &lt; count; i++) {
1155                     JDWP.VirtualMachine.AllClassesWithGeneric.ClassInfo ci =
1156                                                                cinfos[i];
1157                     ReferenceTypeImpl type = referenceType(ci.typeID,
1158                                                            ci.refTypeTag,
1159                                                            ci.signature);
1160                     type.setGenericSignature(ci.genericSignature);
1161                     type.setStatus(ci.status);
1162                 }
1163                 retrievedAllTypes = true;
1164             }
1165         }
1166     }
1167 
1168     void sendToTarget(Packet packet) {
1169         target.send(packet);
1170     }
1171 
1172     void waitForTargetReply(Packet packet) {
1173         target.waitForReply(packet);
1174         /*
1175          * If any object disposes have been batched up, send them now.
1176          */
1177         processBatchedDisposes();
1178     }
1179 
1180     Type findBootType(String signature) throws ClassNotLoadedException {
1181         List&lt;ReferenceType&gt; types = retrieveClassesBySignature(signature);
1182         Iterator&lt;ReferenceType&gt; iter = types.iterator();
1183         while (iter.hasNext()) {
1184             ReferenceType type = iter.next();
1185             if (type.classLoader() == null) {
1186                 return type;
1187             }
1188         }
1189         JNITypeParser parser = new JNITypeParser(signature);
1190         throw new ClassNotLoadedException(parser.typeName(),
1191                                          &quot;Type &quot; + parser.typeName() + &quot; not loaded&quot;);
1192     }
1193 
1194     BooleanType theBooleanType() {
1195         if (theBooleanType == null) {
1196             synchronized(this) {
1197                 if (theBooleanType == null) {
1198                     theBooleanType = new BooleanTypeImpl(this);
1199                 }
1200             }
1201         }
1202         return theBooleanType;
1203     }
1204 
1205     ByteType theByteType() {
1206         if (theByteType == null) {
1207             synchronized(this) {
1208                 if (theByteType == null) {
1209                     theByteType = new ByteTypeImpl(this);
1210                 }
1211             }
1212         }
1213         return theByteType;
1214     }
1215 
1216     CharType theCharType() {
1217         if (theCharType == null) {
1218             synchronized(this) {
1219                 if (theCharType == null) {
1220                     theCharType = new CharTypeImpl(this);
1221                 }
1222             }
1223         }
1224         return theCharType;
1225     }
1226 
1227     ShortType theShortType() {
1228         if (theShortType == null) {
1229             synchronized(this) {
1230                 if (theShortType == null) {
1231                     theShortType = new ShortTypeImpl(this);
1232                 }
1233             }
1234         }
1235         return theShortType;
1236     }
1237 
1238     IntegerType theIntegerType() {
1239         if (theIntegerType == null) {
1240             synchronized(this) {
1241                 if (theIntegerType == null) {
1242                     theIntegerType = new IntegerTypeImpl(this);
1243                 }
1244             }
1245         }
1246         return theIntegerType;
1247     }
1248 
1249     LongType theLongType() {
1250         if (theLongType == null) {
1251             synchronized(this) {
1252                 if (theLongType == null) {
1253                     theLongType = new LongTypeImpl(this);
1254                 }
1255             }
1256         }
1257         return theLongType;
1258     }
1259 
1260     FloatType theFloatType() {
1261         if (theFloatType == null) {
1262             synchronized(this) {
1263                 if (theFloatType == null) {
1264                     theFloatType = new FloatTypeImpl(this);
1265                 }
1266             }
1267         }
1268         return theFloatType;
1269     }
1270 
1271     DoubleType theDoubleType() {
1272         if (theDoubleType == null) {
1273             synchronized(this) {
1274                 if (theDoubleType == null) {
1275                     theDoubleType = new DoubleTypeImpl(this);
1276                 }
1277             }
1278         }
1279         return theDoubleType;
1280     }
1281 
1282     VoidType theVoidType() {
1283         if (theVoidType == null) {
1284             synchronized(this) {
1285                 if (theVoidType == null) {
1286                     theVoidType = new VoidTypeImpl(this);
1287                 }
1288             }
1289         }
1290         return theVoidType;
1291     }
1292 
1293     PrimitiveType primitiveTypeMirror(byte tag) {
1294         switch (tag) {
1295             case JDWP.Tag.BOOLEAN:
1296                 return theBooleanType();
1297             case JDWP.Tag.BYTE:
1298                 return theByteType();
1299             case JDWP.Tag.CHAR:
1300                 return theCharType();
1301             case JDWP.Tag.SHORT:
1302                 return theShortType();
1303             case JDWP.Tag.INT:
1304                 return theIntegerType();
1305             case JDWP.Tag.LONG:
1306                 return theLongType();
1307             case JDWP.Tag.FLOAT:
1308                 return theFloatType();
1309             case JDWP.Tag.DOUBLE:
1310                 return theDoubleType();
1311             default:
1312                 throw new IllegalArgumentException(&quot;Unrecognized primitive tag &quot; + tag);
1313         }
1314     }
1315 
1316     private void processBatchedDisposes() {
1317         if (shutdown) {
1318             return;
1319         }
1320 
1321         JDWP.VirtualMachine.DisposeObjects.Request[] requests = null;
1322         synchronized(batchedDisposeRequests) {
1323             int size = batchedDisposeRequests.size();
1324             if (size &gt;= DISPOSE_THRESHOLD) {
1325                 if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1326                     printTrace(&quot;Dispose threashold reached. Will dispose &quot;
1327                                + size + &quot; object references...&quot;);
1328                 }
1329                 requests = new JDWP.VirtualMachine.DisposeObjects.Request[size];
1330                 for (int i = 0; i &lt; requests.length; i++) {
1331                     SoftObjectReference ref = batchedDisposeRequests.get(i);
1332                     if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1333                         printTrace(&quot;Disposing object &quot; + ref.key().longValue() +
1334                                    &quot; (ref count = &quot; + ref.count() + &quot;)&quot;);
1335                     }
1336 
1337                     // This is kludgy. We temporarily re-create an object
1338                     // reference so that we can correctly pass its id to the
1339                     // JDWP command.
1340                     requests[i] =
1341                         new JDWP.VirtualMachine.DisposeObjects.Request(
1342                             new ObjectReferenceImpl(this, ref.key().longValue()),
1343                             ref.count());
1344                 }
1345                 batchedDisposeRequests.clear();
1346             }
1347         }
1348         if (requests != null) {
1349             try {
1350                 JDWP.VirtualMachine.DisposeObjects.process(vm, requests);
1351             } catch (JDWPException exc) {
1352                 throw exc.toJDIException();
1353             }
1354         }
1355     }
1356 
1357     private void batchForDispose(SoftObjectReference ref) {
1358         if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1359             printTrace(&quot;Batching object &quot; + ref.key().longValue() +
1360                        &quot; for dispose (ref count = &quot; + ref.count() + &quot;)&quot;);
1361         }
1362         batchedDisposeRequests.add(ref);
1363     }
1364 
1365     private void processQueue() {
1366         Reference&lt;?&gt; ref;
1367         //if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1368         //    printTrace(&quot;Checking for softly reachable objects&quot;);
1369         //}
1370         while ((ref = referenceQueue.poll()) != null) {
1371             SoftObjectReference softRef = (SoftObjectReference)ref;
1372             removeObjectMirror(softRef);
1373             batchForDispose(softRef);
1374         }
1375     }
1376 
1377     synchronized ObjectReferenceImpl objectMirror(long id, int tag) {
1378 
1379         // Handle any queue elements that are not strongly reachable
1380         processQueue();
1381 
1382         if (id == 0) {
1383             return null;
1384         }
1385         ObjectReferenceImpl object = null;
1386         Long key = id;
1387 
1388         /*
1389          * Attempt to retrieve an existing object reference
1390          */
1391         SoftObjectReference ref = objectsByID.get(key);
1392         if (ref != null) {
1393             object = ref.object();
1394         }
1395 
1396         /*
1397          * If the object wasn&#39;t in the table, or it&#39;s soft reference was
1398          * cleared, create a new instance.
1399          */
1400         if (object == null) {
1401             switch (tag) {
1402                 case JDWP.Tag.OBJECT:
1403                     object = new ObjectReferenceImpl(vm, id);
1404                     break;
1405                 case JDWP.Tag.STRING:
1406                     object = new StringReferenceImpl(vm, id);
1407                     break;
1408                 case JDWP.Tag.ARRAY:
1409                     object = new ArrayReferenceImpl(vm, id);
1410                     break;
1411                 case JDWP.Tag.THREAD:
1412                     ThreadReferenceImpl thread =
1413                         new ThreadReferenceImpl(vm, id);
1414                     thread.addListener(this);
1415                     object = thread;
1416                     break;
1417                 case JDWP.Tag.THREAD_GROUP:
1418                     object = new ThreadGroupReferenceImpl(vm, id);
1419                     break;
1420                 case JDWP.Tag.CLASS_LOADER:
1421                     object = new ClassLoaderReferenceImpl(vm, id);
1422                     break;
1423                 case JDWP.Tag.CLASS_OBJECT:
1424                     object = new ClassObjectReferenceImpl(vm, id);
1425                     break;
1426                 default:
1427                     throw new IllegalArgumentException(&quot;Invalid object tag: &quot; + tag);
1428             }
1429             ref = new SoftObjectReference(key, object, referenceQueue);
1430 
1431             /*
1432              * If there was no previous entry in the table, we add one here
1433              * If the previous entry was cleared, we replace it here.
1434              */
1435             objectsByID.put(key, ref);
1436             if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1437                 printTrace(&quot;Creating new &quot; +
1438                            object.getClass().getName() + &quot; (id = &quot; + id + &quot;)&quot;);
1439             }
1440         } else {
1441             ref.incrementCount();
1442         }
1443 
1444         return object;
1445     }
1446 
1447     synchronized void removeObjectMirror(ObjectReferenceImpl object) {
1448         // Handle any queue elements that are not strongly reachable
1449         processQueue();
1450 
1451         SoftObjectReference ref = objectsByID.remove(object.ref());
1452         if (ref != null) {
1453             batchForDispose(ref);
1454         } else {
1455             /*
1456              * If there&#39;s a live ObjectReference about, it better be part
1457              * of the cache.
1458              */
1459             throw new InternalException(&quot;ObjectReference &quot; + object.ref() +
1460                                         &quot; not found in object cache&quot;);
1461         }
1462     }
1463 
1464     synchronized void removeObjectMirror(SoftObjectReference ref) {
1465         /*
1466          * This will remove the soft reference if it has not been
1467          * replaced in the cache.
1468          */
1469         objectsByID.remove(ref.key());
1470     }
1471 
1472     ObjectReferenceImpl objectMirror(long id) {
1473         return objectMirror(id, JDWP.Tag.OBJECT);
1474     }
1475 
1476     StringReferenceImpl stringMirror(long id) {
1477         return (StringReferenceImpl)objectMirror(id, JDWP.Tag.STRING);
1478     }
1479 
1480     ArrayReferenceImpl arrayMirror(long id) {
1481        return (ArrayReferenceImpl)objectMirror(id, JDWP.Tag.ARRAY);
1482     }
1483 
1484     ThreadReferenceImpl threadMirror(long id) {
1485         return (ThreadReferenceImpl)objectMirror(id, JDWP.Tag.THREAD);
1486     }
1487 
1488     ThreadGroupReferenceImpl threadGroupMirror(long id) {
1489         return (ThreadGroupReferenceImpl)objectMirror(id,
1490                                                       JDWP.Tag.THREAD_GROUP);
1491     }
1492 
1493     ClassLoaderReferenceImpl classLoaderMirror(long id) {
1494         return (ClassLoaderReferenceImpl)objectMirror(id,
1495                                                       JDWP.Tag.CLASS_LOADER);
1496     }
1497 
1498     ClassObjectReferenceImpl classObjectMirror(long id) {
1499         return (ClassObjectReferenceImpl)objectMirror(id,
1500                                                       JDWP.Tag.CLASS_OBJECT);
1501     }
1502 
1503     ModuleReferenceImpl moduleMirror(long id) {
1504         return (ModuleReferenceImpl)getModule(id);
1505     }
1506 
1507     /*
1508      * Implementation of PathSearchingVirtualMachine
1509      */
1510     private JDWP.VirtualMachine.ClassPaths getClasspath() {
1511         if (pathInfo == null) {
1512             try {
1513                 pathInfo = JDWP.VirtualMachine.ClassPaths.process(vm);
1514             } catch (JDWPException exc) {
1515                 throw exc.toJDIException();
1516             }
1517         }
1518         return pathInfo;
1519     }
1520 
1521    public List&lt;String&gt; classPath() {
1522        return Arrays.asList(getClasspath().classpaths);
1523    }
1524 
1525    public List&lt;String&gt; bootClassPath() {
1526        return Collections.emptyList();
1527    }
1528 
1529    public String baseDirectory() {
1530        return getClasspath().baseDir;
1531    }
1532 
1533     public void setDefaultStratum(String stratum) {
1534         defaultStratum = stratum;
1535         if (stratum == null) {
1536             stratum = &quot;&quot;;
1537         }
1538         try {
1539             JDWP.VirtualMachine.SetDefaultStratum.process(vm,
1540                                                           stratum);
1541         } catch (JDWPException exc) {
1542             throw exc.toJDIException();
1543         }
1544     }
1545 
1546     public String getDefaultStratum() {
1547         return defaultStratum;
1548     }
1549 
1550     ThreadGroup threadGroupForJDI() {
1551         return threadGroupForJDI;
1552     }
1553 
1554    static private class SoftObjectReference extends SoftReference&lt;ObjectReferenceImpl&gt; {
1555        int count;
1556        Long key;
1557 
1558        SoftObjectReference(Long key, ObjectReferenceImpl mirror,
1559                            ReferenceQueue&lt;ObjectReferenceImpl&gt; queue) {
1560            super(mirror, queue);
1561            this.count = 1;
1562            this.key = key;
1563        }
1564 
1565        int count() {
1566            return count;
1567        }
1568 
1569        void incrementCount() {
1570            count++;
1571        }
1572 
1573        Long key() {
1574            return key;
1575        }
1576 
1577        ObjectReferenceImpl object() {
1578            return get();
1579        }
1580    }
1581 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/x86/macroAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;asm/assembler.hpp&quot;
  28 #include &quot;asm/assembler.inline.hpp&quot;
  29 #include &quot;compiler/disassembler.hpp&quot;
  30 #include &quot;gc/shared/barrierSet.hpp&quot;
  31 #include &quot;gc/shared/barrierSetAssembler.hpp&quot;
  32 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  33 #include &quot;interpreter/interpreter.hpp&quot;
  34 #include &quot;memory/resourceArea.hpp&quot;
  35 #include &quot;memory/universe.hpp&quot;
  36 #include &quot;oops/accessDecorators.hpp&quot;
  37 #include &quot;oops/compressedOops.inline.hpp&quot;
  38 #include &quot;oops/klass.inline.hpp&quot;
  39 #include &quot;prims/methodHandles.hpp&quot;
  40 #include &quot;runtime/biasedLocking.hpp&quot;
  41 #include &quot;runtime/flags/flagSetting.hpp&quot;
  42 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  43 #include &quot;runtime/objectMonitor.hpp&quot;
  44 #include &quot;runtime/os.hpp&quot;
  45 #include &quot;runtime/safepoint.hpp&quot;
  46 #include &quot;runtime/safepointMechanism.hpp&quot;
  47 #include &quot;runtime/sharedRuntime.hpp&quot;
<a name="1" id="anc1"></a><span class="line-added">  48 #include &quot;runtime/signature_cc.hpp&quot;</span>
  49 #include &quot;runtime/stubRoutines.hpp&quot;
  50 #include &quot;runtime/thread.hpp&quot;
  51 #include &quot;utilities/macros.hpp&quot;
<a name="2" id="anc2"></a><span class="line-added">  52 #include &quot;vmreg_x86.inline.hpp&quot;</span>
  53 #include &quot;crc32c.h&quot;
<a name="3" id="anc3"></a><span class="line-added">  54 #ifdef COMPILER2</span>
<span class="line-added">  55 #include &quot;opto/output.hpp&quot;</span>
<span class="line-added">  56 #endif</span>
  57 
  58 #ifdef PRODUCT
  59 #define BLOCK_COMMENT(str) /* nothing */
  60 #define STOP(error) stop(error)
  61 #else
  62 #define BLOCK_COMMENT(str) block_comment(str)
  63 #define STOP(error) block_comment(error); stop(error)
  64 #endif
  65 
  66 #define BIND(label) bind(label); BLOCK_COMMENT(#label &quot;:&quot;)
  67 
  68 #ifdef ASSERT
  69 bool AbstractAssembler::pd_check_instruction_mark() { return true; }
  70 #endif
  71 
  72 static Assembler::Condition reverse[] = {
  73     Assembler::noOverflow     /* overflow      = 0x0 */ ,
  74     Assembler::overflow       /* noOverflow    = 0x1 */ ,
  75     Assembler::aboveEqual     /* carrySet      = 0x2, below         = 0x2 */ ,
  76     Assembler::below          /* aboveEqual    = 0x3, carryClear    = 0x3 */ ,
  77     Assembler::notZero        /* zero          = 0x4, equal         = 0x4 */ ,
  78     Assembler::zero           /* notZero       = 0x5, notEqual      = 0x5 */ ,
  79     Assembler::above          /* belowEqual    = 0x6 */ ,
  80     Assembler::belowEqual     /* above         = 0x7 */ ,
  81     Assembler::positive       /* negative      = 0x8 */ ,
  82     Assembler::negative       /* positive      = 0x9 */ ,
  83     Assembler::noParity       /* parity        = 0xa */ ,
  84     Assembler::parity         /* noParity      = 0xb */ ,
  85     Assembler::greaterEqual   /* less          = 0xc */ ,
  86     Assembler::less           /* greaterEqual  = 0xd */ ,
  87     Assembler::greater        /* lessEqual     = 0xe */ ,
  88     Assembler::lessEqual      /* greater       = 0xf, */
  89 
  90 };
  91 
  92 
  93 // Implementation of MacroAssembler
  94 
  95 // First all the versions that have distinct versions depending on 32/64 bit
  96 // Unless the difference is trivial (1 line or so).
  97 
  98 #ifndef _LP64
  99 
 100 // 32bit versions
 101 
 102 Address MacroAssembler::as_Address(AddressLiteral adr) {
 103   return Address(adr.target(), adr.rspec());
 104 }
 105 
 106 Address MacroAssembler::as_Address(ArrayAddress adr) {
 107   return Address::make_array(adr);
 108 }
 109 
 110 void MacroAssembler::call_VM_leaf_base(address entry_point,
 111                                        int number_of_arguments) {
 112   call(RuntimeAddress(entry_point));
 113   increment(rsp, number_of_arguments * wordSize);
 114 }
 115 
 116 void MacroAssembler::cmpklass(Address src1, Metadata* obj) {
 117   cmp_literal32(src1, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 118 }
 119 
 120 void MacroAssembler::cmpklass(Register src1, Metadata* obj) {
 121   cmp_literal32(src1, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 122 }
 123 
 124 void MacroAssembler::cmpoop_raw(Address src1, jobject obj) {
 125   cmp_literal32(src1, (int32_t)obj, oop_Relocation::spec_for_immediate());
 126 }
 127 
 128 void MacroAssembler::cmpoop_raw(Register src1, jobject obj) {
 129   cmp_literal32(src1, (int32_t)obj, oop_Relocation::spec_for_immediate());
 130 }
 131 
 132 void MacroAssembler::cmpoop(Address src1, jobject obj) {
 133   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 134   bs-&gt;obj_equals(this, src1, obj);
 135 }
 136 
 137 void MacroAssembler::cmpoop(Register src1, jobject obj) {
 138   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
 139   bs-&gt;obj_equals(this, src1, obj);
 140 }
 141 
 142 void MacroAssembler::extend_sign(Register hi, Register lo) {
 143   // According to Intel Doc. AP-526, &quot;Integer Divide&quot;, p.18.
 144   if (VM_Version::is_P6() &amp;&amp; hi == rdx &amp;&amp; lo == rax) {
 145     cdql();
 146   } else {
 147     movl(hi, lo);
 148     sarl(hi, 31);
 149   }
 150 }
 151 
 152 void MacroAssembler::jC2(Register tmp, Label&amp; L) {
 153   // set parity bit if FPU flag C2 is set (via rax)
 154   save_rax(tmp);
 155   fwait(); fnstsw_ax();
 156   sahf();
 157   restore_rax(tmp);
 158   // branch
 159   jcc(Assembler::parity, L);
 160 }
 161 
 162 void MacroAssembler::jnC2(Register tmp, Label&amp; L) {
 163   // set parity bit if FPU flag C2 is set (via rax)
 164   save_rax(tmp);
 165   fwait(); fnstsw_ax();
 166   sahf();
 167   restore_rax(tmp);
 168   // branch
 169   jcc(Assembler::noParity, L);
 170 }
 171 
 172 // 32bit can do a case table jump in one instruction but we no longer allow the base
 173 // to be installed in the Address class
 174 void MacroAssembler::jump(ArrayAddress entry) {
 175   jmp(as_Address(entry));
 176 }
 177 
 178 // Note: y_lo will be destroyed
 179 void MacroAssembler::lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo) {
 180   // Long compare for Java (semantics as described in JVM spec.)
 181   Label high, low, done;
 182 
 183   cmpl(x_hi, y_hi);
 184   jcc(Assembler::less, low);
 185   jcc(Assembler::greater, high);
 186   // x_hi is the return register
 187   xorl(x_hi, x_hi);
 188   cmpl(x_lo, y_lo);
 189   jcc(Assembler::below, low);
 190   jcc(Assembler::equal, done);
 191 
 192   bind(high);
 193   xorl(x_hi, x_hi);
 194   increment(x_hi);
 195   jmp(done);
 196 
 197   bind(low);
 198   xorl(x_hi, x_hi);
 199   decrementl(x_hi);
 200 
 201   bind(done);
 202 }
 203 
 204 void MacroAssembler::lea(Register dst, AddressLiteral src) {
 205     mov_literal32(dst, (int32_t)src.target(), src.rspec());
 206 }
 207 
 208 void MacroAssembler::lea(Address dst, AddressLiteral adr) {
 209   // leal(dst, as_Address(adr));
 210   // see note in movl as to why we must use a move
 211   mov_literal32(dst, (int32_t) adr.target(), adr.rspec());
 212 }
 213 
 214 void MacroAssembler::leave() {
 215   mov(rsp, rbp);
 216   pop(rbp);
 217 }
 218 
 219 void MacroAssembler::lmul(int x_rsp_offset, int y_rsp_offset) {
 220   // Multiplication of two Java long values stored on the stack
 221   // as illustrated below. Result is in rdx:rax.
 222   //
 223   // rsp ---&gt; [  ??  ] \               \
 224   //            ....    | y_rsp_offset  |
 225   //          [ y_lo ] /  (in bytes)    | x_rsp_offset
 226   //          [ y_hi ]                  | (in bytes)
 227   //            ....                    |
 228   //          [ x_lo ]                 /
 229   //          [ x_hi ]
 230   //            ....
 231   //
 232   // Basic idea: lo(result) = lo(x_lo * y_lo)
 233   //             hi(result) = hi(x_lo * y_lo) + lo(x_hi * y_lo) + lo(x_lo * y_hi)
 234   Address x_hi(rsp, x_rsp_offset + wordSize); Address x_lo(rsp, x_rsp_offset);
 235   Address y_hi(rsp, y_rsp_offset + wordSize); Address y_lo(rsp, y_rsp_offset);
 236   Label quick;
 237   // load x_hi, y_hi and check if quick
 238   // multiplication is possible
 239   movl(rbx, x_hi);
 240   movl(rcx, y_hi);
 241   movl(rax, rbx);
 242   orl(rbx, rcx);                                 // rbx, = 0 &lt;=&gt; x_hi = 0 and y_hi = 0
 243   jcc(Assembler::zero, quick);                   // if rbx, = 0 do quick multiply
 244   // do full multiplication
 245   // 1st step
 246   mull(y_lo);                                    // x_hi * y_lo
 247   movl(rbx, rax);                                // save lo(x_hi * y_lo) in rbx,
 248   // 2nd step
 249   movl(rax, x_lo);
 250   mull(rcx);                                     // x_lo * y_hi
 251   addl(rbx, rax);                                // add lo(x_lo * y_hi) to rbx,
 252   // 3rd step
 253   bind(quick);                                   // note: rbx, = 0 if quick multiply!
 254   movl(rax, x_lo);
 255   mull(y_lo);                                    // x_lo * y_lo
 256   addl(rdx, rbx);                                // correct hi(x_lo * y_lo)
 257 }
 258 
 259 void MacroAssembler::lneg(Register hi, Register lo) {
 260   negl(lo);
 261   adcl(hi, 0);
 262   negl(hi);
 263 }
 264 
 265 void MacroAssembler::lshl(Register hi, Register lo) {
 266   // Java shift left long support (semantics as described in JVM spec., p.305)
 267   // (basic idea for shift counts s &gt;= n: x &lt;&lt; s == (x &lt;&lt; n) &lt;&lt; (s - n))
 268   // shift value is in rcx !
 269   assert(hi != rcx, &quot;must not use rcx&quot;);
 270   assert(lo != rcx, &quot;must not use rcx&quot;);
 271   const Register s = rcx;                        // shift count
 272   const int      n = BitsPerWord;
 273   Label L;
 274   andl(s, 0x3f);                                 // s := s &amp; 0x3f (s &lt; 0x40)
 275   cmpl(s, n);                                    // if (s &lt; n)
 276   jcc(Assembler::less, L);                       // else (s &gt;= n)
 277   movl(hi, lo);                                  // x := x &lt;&lt; n
 278   xorl(lo, lo);
 279   // Note: subl(s, n) is not needed since the Intel shift instructions work rcx mod n!
 280   bind(L);                                       // s (mod n) &lt; n
 281   shldl(hi, lo);                                 // x := x &lt;&lt; s
 282   shll(lo);
 283 }
 284 
 285 
 286 void MacroAssembler::lshr(Register hi, Register lo, bool sign_extension) {
 287   // Java shift right long support (semantics as described in JVM spec., p.306 &amp; p.310)
 288   // (basic idea for shift counts s &gt;= n: x &gt;&gt; s == (x &gt;&gt; n) &gt;&gt; (s - n))
 289   assert(hi != rcx, &quot;must not use rcx&quot;);
 290   assert(lo != rcx, &quot;must not use rcx&quot;);
 291   const Register s = rcx;                        // shift count
 292   const int      n = BitsPerWord;
 293   Label L;
 294   andl(s, 0x3f);                                 // s := s &amp; 0x3f (s &lt; 0x40)
 295   cmpl(s, n);                                    // if (s &lt; n)
 296   jcc(Assembler::less, L);                       // else (s &gt;= n)
 297   movl(lo, hi);                                  // x := x &gt;&gt; n
 298   if (sign_extension) sarl(hi, 31);
 299   else                xorl(hi, hi);
 300   // Note: subl(s, n) is not needed since the Intel shift instructions work rcx mod n!
 301   bind(L);                                       // s (mod n) &lt; n
 302   shrdl(lo, hi);                                 // x := x &gt;&gt; s
 303   if (sign_extension) sarl(hi);
 304   else                shrl(hi);
 305 }
 306 
 307 void MacroAssembler::movoop(Register dst, jobject obj) {
 308   mov_literal32(dst, (int32_t)obj, oop_Relocation::spec_for_immediate());
 309 }
 310 
 311 void MacroAssembler::movoop(Address dst, jobject obj) {
 312   mov_literal32(dst, (int32_t)obj, oop_Relocation::spec_for_immediate());
 313 }
 314 
 315 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
 316   mov_literal32(dst, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 317 }
 318 
 319 void MacroAssembler::mov_metadata(Address dst, Metadata* obj) {
 320   mov_literal32(dst, (int32_t)obj, metadata_Relocation::spec_for_immediate());
 321 }
 322 
 323 void MacroAssembler::movptr(Register dst, AddressLiteral src, Register scratch) {
 324   // scratch register is not used,
 325   // it is defined to match parameters of 64-bit version of this method.
 326   if (src.is_lval()) {
 327     mov_literal32(dst, (intptr_t)src.target(), src.rspec());
 328   } else {
 329     movl(dst, as_Address(src));
 330   }
 331 }
 332 
 333 void MacroAssembler::movptr(ArrayAddress dst, Register src) {
 334   movl(as_Address(dst), src);
 335 }
 336 
 337 void MacroAssembler::movptr(Register dst, ArrayAddress src) {
 338   movl(dst, as_Address(src));
 339 }
 340 
 341 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
 342 void MacroAssembler::movptr(Address dst, intptr_t src) {
 343   movl(dst, src);
 344 }
 345 
 346 
 347 void MacroAssembler::pop_callee_saved_registers() {
 348   pop(rcx);
 349   pop(rdx);
 350   pop(rdi);
 351   pop(rsi);
 352 }
 353 
 354 void MacroAssembler::push_callee_saved_registers() {
 355   push(rsi);
 356   push(rdi);
 357   push(rdx);
 358   push(rcx);
 359 }
 360 
 361 void MacroAssembler::pushoop(jobject obj) {
 362   push_literal32((int32_t)obj, oop_Relocation::spec_for_immediate());
 363 }
 364 
 365 void MacroAssembler::pushklass(Metadata* obj) {
 366   push_literal32((int32_t)obj, metadata_Relocation::spec_for_immediate());
 367 }
 368 
 369 void MacroAssembler::pushptr(AddressLiteral src) {
 370   if (src.is_lval()) {
 371     push_literal32((int32_t)src.target(), src.rspec());
 372   } else {
 373     pushl(as_Address(src));
 374   }
 375 }
 376 
 377 void MacroAssembler::set_word_if_not_zero(Register dst) {
 378   xorl(dst, dst);
 379   set_byte_if_not_zero(dst);
 380 }
 381 
 382 static void pass_arg0(MacroAssembler* masm, Register arg) {
 383   masm-&gt;push(arg);
 384 }
 385 
 386 static void pass_arg1(MacroAssembler* masm, Register arg) {
 387   masm-&gt;push(arg);
 388 }
 389 
 390 static void pass_arg2(MacroAssembler* masm, Register arg) {
 391   masm-&gt;push(arg);
 392 }
 393 
 394 static void pass_arg3(MacroAssembler* masm, Register arg) {
 395   masm-&gt;push(arg);
 396 }
 397 
 398 #ifndef PRODUCT
 399 extern &quot;C&quot; void findpc(intptr_t x);
 400 #endif
 401 
 402 void MacroAssembler::debug32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip, char* msg) {
 403   // In order to get locks to work, we need to fake a in_VM state
 404   JavaThread* thread = JavaThread::current();
 405   JavaThreadState saved_state = thread-&gt;thread_state();
 406   thread-&gt;set_thread_state(_thread_in_vm);
 407   if (ShowMessageBoxOnError) {
 408     JavaThread* thread = JavaThread::current();
 409     JavaThreadState saved_state = thread-&gt;thread_state();
 410     thread-&gt;set_thread_state(_thread_in_vm);
 411     if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
 412       ttyLocker ttyl;
 413       BytecodeCounter::print();
 414     }
 415     // To see where a verify_oop failed, get $ebx+40/X for this frame.
 416     // This is the value of eip which points to where verify_oop will return.
 417     if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;)) {
 418       print_state32(rdi, rsi, rbp, rsp, rbx, rdx, rcx, rax, eip);
 419       BREAKPOINT;
 420     }
 421   }
 422   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
 423 }
 424 
 425 void MacroAssembler::print_state32(int rdi, int rsi, int rbp, int rsp, int rbx, int rdx, int rcx, int rax, int eip) {
 426   ttyLocker ttyl;
 427   FlagSetting fs(Debugging, true);
 428   tty-&gt;print_cr(&quot;eip = 0x%08x&quot;, eip);
 429 #ifndef PRODUCT
 430   if ((WizardMode || Verbose) &amp;&amp; PrintMiscellaneous) {
 431     tty-&gt;cr();
 432     findpc(eip);
 433     tty-&gt;cr();
 434   }
 435 #endif
 436 #define PRINT_REG(rax) \
 437   { tty-&gt;print(&quot;%s = &quot;, #rax); os::print_location(tty, rax); }
 438   PRINT_REG(rax);
 439   PRINT_REG(rbx);
 440   PRINT_REG(rcx);
 441   PRINT_REG(rdx);
 442   PRINT_REG(rdi);
 443   PRINT_REG(rsi);
 444   PRINT_REG(rbp);
 445   PRINT_REG(rsp);
 446 #undef PRINT_REG
 447   // Print some words near top of staack.
 448   int* dump_sp = (int*) rsp;
 449   for (int col1 = 0; col1 &lt; 8; col1++) {
 450     tty-&gt;print(&quot;(rsp+0x%03x) 0x%08x: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 451     os::print_location(tty, *dump_sp++);
 452   }
 453   for (int row = 0; row &lt; 16; row++) {
 454     tty-&gt;print(&quot;(rsp+0x%03x) 0x%08x: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 455     for (int col = 0; col &lt; 8; col++) {
 456       tty-&gt;print(&quot; 0x%08x&quot;, *dump_sp++);
 457     }
 458     tty-&gt;cr();
 459   }
 460   // Print some instructions around pc:
 461   Disassembler::decode((address)eip-64, (address)eip);
 462   tty-&gt;print_cr(&quot;--------&quot;);
 463   Disassembler::decode((address)eip, (address)eip+32);
 464 }
 465 
 466 void MacroAssembler::stop(const char* msg) {
 467   ExternalAddress message((address)msg);
 468   // push address of message
 469   pushptr(message.addr());
 470   { Label L; call(L, relocInfo::none); bind(L); }     // push eip
 471   pusha();                                            // push registers
 472   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::debug32)));
 473   hlt();
 474 }
 475 
 476 void MacroAssembler::warn(const char* msg) {
 477   push_CPU_state();
 478 
 479   ExternalAddress message((address) msg);
 480   // push address of message
 481   pushptr(message.addr());
 482 
 483   call(RuntimeAddress(CAST_FROM_FN_PTR(address, warning)));
 484   addl(rsp, wordSize);       // discard argument
 485   pop_CPU_state();
 486 }
 487 
 488 void MacroAssembler::print_state() {
 489   { Label L; call(L, relocInfo::none); bind(L); }     // push eip
 490   pusha();                                            // push registers
 491 
 492   push_CPU_state();
 493   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::print_state32)));
 494   pop_CPU_state();
 495 
 496   popa();
 497   addl(rsp, wordSize);
 498 }
 499 
 500 #else // _LP64
 501 
 502 // 64 bit versions
 503 
 504 Address MacroAssembler::as_Address(AddressLiteral adr) {
 505   // amd64 always does this as a pc-rel
 506   // we can be absolute or disp based on the instruction type
 507   // jmp/call are displacements others are absolute
 508   assert(!adr.is_lval(), &quot;must be rval&quot;);
 509   assert(reachable(adr), &quot;must be&quot;);
 510   return Address((int32_t)(intptr_t)(adr.target() - pc()), adr.target(), adr.reloc());
 511 
 512 }
 513 
 514 Address MacroAssembler::as_Address(ArrayAddress adr) {
 515   AddressLiteral base = adr.base();
 516   lea(rscratch1, base);
 517   Address index = adr.index();
 518   assert(index._disp == 0, &quot;must not have disp&quot;); // maybe it can?
 519   Address array(rscratch1, index._index, index._scale, index._disp);
 520   return array;
 521 }
 522 
 523 void MacroAssembler::call_VM_leaf_base(address entry_point, int num_args) {
 524   Label L, E;
 525 
 526 #ifdef _WIN64
 527   // Windows always allocates space for it&#39;s register args
 528   assert(num_args &lt;= 4, &quot;only register arguments supported&quot;);
 529   subq(rsp,  frame::arg_reg_save_area_bytes);
 530 #endif
 531 
 532   // Align stack if necessary
 533   testl(rsp, 15);
 534   jcc(Assembler::zero, L);
 535 
 536   subq(rsp, 8);
 537   {
 538     call(RuntimeAddress(entry_point));
 539   }
 540   addq(rsp, 8);
 541   jmp(E);
 542 
 543   bind(L);
 544   {
 545     call(RuntimeAddress(entry_point));
 546   }
 547 
 548   bind(E);
 549 
 550 #ifdef _WIN64
 551   // restore stack pointer
 552   addq(rsp, frame::arg_reg_save_area_bytes);
 553 #endif
 554 
 555 }
 556 
 557 void MacroAssembler::cmp64(Register src1, AddressLiteral src2) {
 558   assert(!src2.is_lval(), &quot;should use cmpptr&quot;);
 559 
 560   if (reachable(src2)) {
 561     cmpq(src1, as_Address(src2));
 562   } else {
 563     lea(rscratch1, src2);
 564     Assembler::cmpq(src1, Address(rscratch1, 0));
 565   }
 566 }
 567 
 568 int MacroAssembler::corrected_idivq(Register reg) {
 569   // Full implementation of Java ldiv and lrem; checks for special
 570   // case as described in JVM spec., p.243 &amp; p.271.  The function
 571   // returns the (pc) offset of the idivl instruction - may be needed
 572   // for implicit exceptions.
 573   //
 574   //         normal case                           special case
 575   //
 576   // input : rax: dividend                         min_long
 577   //         reg: divisor   (may not be eax/edx)   -1
 578   //
 579   // output: rax: quotient  (= rax idiv reg)       min_long
 580   //         rdx: remainder (= rax irem reg)       0
 581   assert(reg != rax &amp;&amp; reg != rdx, &quot;reg cannot be rax or rdx register&quot;);
 582   static const int64_t min_long = 0x8000000000000000;
 583   Label normal_case, special_case;
 584 
 585   // check for special case
 586   cmp64(rax, ExternalAddress((address) &amp;min_long));
 587   jcc(Assembler::notEqual, normal_case);
 588   xorl(rdx, rdx); // prepare rdx for possible special case (where
 589                   // remainder = 0)
 590   cmpq(reg, -1);
 591   jcc(Assembler::equal, special_case);
 592 
 593   // handle normal case
 594   bind(normal_case);
 595   cdqq();
 596   int idivq_offset = offset();
 597   idivq(reg);
 598 
 599   // normal and special case exit
 600   bind(special_case);
 601 
 602   return idivq_offset;
 603 }
 604 
 605 void MacroAssembler::decrementq(Register reg, int value) {
 606   if (value == min_jint) { subq(reg, value); return; }
 607   if (value &lt;  0) { incrementq(reg, -value); return; }
 608   if (value == 0) {                        ; return; }
 609   if (value == 1 &amp;&amp; UseIncDec) { decq(reg) ; return; }
 610   /* else */      { subq(reg, value)       ; return; }
 611 }
 612 
 613 void MacroAssembler::decrementq(Address dst, int value) {
 614   if (value == min_jint) { subq(dst, value); return; }
 615   if (value &lt;  0) { incrementq(dst, -value); return; }
 616   if (value == 0) {                        ; return; }
 617   if (value == 1 &amp;&amp; UseIncDec) { decq(dst) ; return; }
 618   /* else */      { subq(dst, value)       ; return; }
 619 }
 620 
 621 void MacroAssembler::incrementq(AddressLiteral dst) {
 622   if (reachable(dst)) {
 623     incrementq(as_Address(dst));
 624   } else {
 625     lea(rscratch1, dst);
 626     incrementq(Address(rscratch1, 0));
 627   }
 628 }
 629 
 630 void MacroAssembler::incrementq(Register reg, int value) {
 631   if (value == min_jint) { addq(reg, value); return; }
 632   if (value &lt;  0) { decrementq(reg, -value); return; }
 633   if (value == 0) {                        ; return; }
 634   if (value == 1 &amp;&amp; UseIncDec) { incq(reg) ; return; }
 635   /* else */      { addq(reg, value)       ; return; }
 636 }
 637 
 638 void MacroAssembler::incrementq(Address dst, int value) {
 639   if (value == min_jint) { addq(dst, value); return; }
 640   if (value &lt;  0) { decrementq(dst, -value); return; }
 641   if (value == 0) {                        ; return; }
 642   if (value == 1 &amp;&amp; UseIncDec) { incq(dst) ; return; }
 643   /* else */      { addq(dst, value)       ; return; }
 644 }
 645 
 646 // 32bit can do a case table jump in one instruction but we no longer allow the base
 647 // to be installed in the Address class
 648 void MacroAssembler::jump(ArrayAddress entry) {
 649   lea(rscratch1, entry.base());
 650   Address dispatch = entry.index();
 651   assert(dispatch._base == noreg, &quot;must be&quot;);
 652   dispatch._base = rscratch1;
 653   jmp(dispatch);
 654 }
 655 
 656 void MacroAssembler::lcmp2int(Register x_hi, Register x_lo, Register y_hi, Register y_lo) {
 657   ShouldNotReachHere(); // 64bit doesn&#39;t use two regs
 658   cmpq(x_lo, y_lo);
 659 }
 660 
 661 void MacroAssembler::lea(Register dst, AddressLiteral src) {
 662     mov_literal64(dst, (intptr_t)src.target(), src.rspec());
 663 }
 664 
 665 void MacroAssembler::lea(Address dst, AddressLiteral adr) {
 666   mov_literal64(rscratch1, (intptr_t)adr.target(), adr.rspec());
 667   movptr(dst, rscratch1);
 668 }
 669 
 670 void MacroAssembler::leave() {
 671   // %%% is this really better? Why not on 32bit too?
 672   emit_int8((unsigned char)0xC9); // LEAVE
 673 }
 674 
 675 void MacroAssembler::lneg(Register hi, Register lo) {
 676   ShouldNotReachHere(); // 64bit doesn&#39;t use two regs
 677   negq(lo);
 678 }
 679 
 680 void MacroAssembler::movoop(Register dst, jobject obj) {
 681   mov_literal64(dst, (intptr_t)obj, oop_Relocation::spec_for_immediate());
 682 }
 683 
 684 void MacroAssembler::movoop(Address dst, jobject obj) {
 685   mov_literal64(rscratch1, (intptr_t)obj, oop_Relocation::spec_for_immediate());
 686   movq(dst, rscratch1);
 687 }
 688 
 689 void MacroAssembler::mov_metadata(Register dst, Metadata* obj) {
 690   mov_literal64(dst, (intptr_t)obj, metadata_Relocation::spec_for_immediate());
 691 }
 692 
 693 void MacroAssembler::mov_metadata(Address dst, Metadata* obj) {
 694   mov_literal64(rscratch1, (intptr_t)obj, metadata_Relocation::spec_for_immediate());
 695   movq(dst, rscratch1);
 696 }
 697 
 698 void MacroAssembler::movptr(Register dst, AddressLiteral src, Register scratch) {
 699   if (src.is_lval()) {
 700     mov_literal64(dst, (intptr_t)src.target(), src.rspec());
 701   } else {
 702     if (reachable(src)) {
 703       movq(dst, as_Address(src));
 704     } else {
 705       lea(scratch, src);
 706       movq(dst, Address(scratch, 0));
 707     }
 708   }
 709 }
 710 
 711 void MacroAssembler::movptr(ArrayAddress dst, Register src) {
 712   movq(as_Address(dst), src);
 713 }
 714 
 715 void MacroAssembler::movptr(Register dst, ArrayAddress src) {
 716   movq(dst, as_Address(src));
 717 }
 718 
 719 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
 720 void MacroAssembler::movptr(Address dst, intptr_t src) {
 721   mov64(rscratch1, src);
 722   movq(dst, rscratch1);
 723 }
 724 
 725 // These are mostly for initializing NULL
 726 void MacroAssembler::movptr(Address dst, int32_t src) {
 727   movslq(dst, src);
 728 }
 729 
 730 void MacroAssembler::movptr(Register dst, int32_t src) {
 731   mov64(dst, (intptr_t)src);
 732 }
 733 
 734 void MacroAssembler::pushoop(jobject obj) {
 735   movoop(rscratch1, obj);
 736   push(rscratch1);
 737 }
 738 
 739 void MacroAssembler::pushklass(Metadata* obj) {
 740   mov_metadata(rscratch1, obj);
 741   push(rscratch1);
 742 }
 743 
 744 void MacroAssembler::pushptr(AddressLiteral src) {
 745   lea(rscratch1, src);
 746   if (src.is_lval()) {
 747     push(rscratch1);
 748   } else {
 749     pushq(Address(rscratch1, 0));
 750   }
 751 }
 752 
 753 void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
 754   // we must set sp to zero to clear frame
 755   movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);
 756   // must clear fp, so that compiled frames are not confused; it is
 757   // possible that we need it only for debugging
 758   if (clear_fp) {
 759     movptr(Address(r15_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);
 760   }
 761 
 762   // Always clear the pc because it could have been set by make_walkable()
 763   movptr(Address(r15_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);
 764   vzeroupper();
 765 }
 766 
 767 void MacroAssembler::set_last_Java_frame(Register last_java_sp,
 768                                          Register last_java_fp,
 769                                          address  last_java_pc) {
 770   vzeroupper();
 771   // determine last_java_sp register
 772   if (!last_java_sp-&gt;is_valid()) {
 773     last_java_sp = rsp;
 774   }
 775 
 776   // last_java_fp is optional
 777   if (last_java_fp-&gt;is_valid()) {
 778     movptr(Address(r15_thread, JavaThread::last_Java_fp_offset()),
 779            last_java_fp);
 780   }
 781 
 782   // last_java_pc is optional
 783   if (last_java_pc != NULL) {
 784     Address java_pc(r15_thread,
 785                     JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset());
 786     lea(rscratch1, InternalAddress(last_java_pc));
 787     movptr(java_pc, rscratch1);
 788   }
 789 
 790   movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), last_java_sp);
 791 }
 792 
 793 static void pass_arg0(MacroAssembler* masm, Register arg) {
 794   if (c_rarg0 != arg ) {
 795     masm-&gt;mov(c_rarg0, arg);
 796   }
 797 }
 798 
 799 static void pass_arg1(MacroAssembler* masm, Register arg) {
 800   if (c_rarg1 != arg ) {
 801     masm-&gt;mov(c_rarg1, arg);
 802   }
 803 }
 804 
 805 static void pass_arg2(MacroAssembler* masm, Register arg) {
 806   if (c_rarg2 != arg ) {
 807     masm-&gt;mov(c_rarg2, arg);
 808   }
 809 }
 810 
 811 static void pass_arg3(MacroAssembler* masm, Register arg) {
 812   if (c_rarg3 != arg ) {
 813     masm-&gt;mov(c_rarg3, arg);
 814   }
 815 }
 816 
 817 void MacroAssembler::stop(const char* msg) {
 818   if (ShowMessageBoxOnError) {
 819     address rip = pc();
 820     pusha(); // get regs on stack
 821     lea(c_rarg1, InternalAddress(rip));
 822     movq(c_rarg2, rsp); // pass pointer to regs array
 823   }
 824   lea(c_rarg0, ExternalAddress((address) msg));
 825   andq(rsp, -16); // align stack as required by ABI
 826   call(RuntimeAddress(CAST_FROM_FN_PTR(address, MacroAssembler::debug64)));
 827   hlt();
 828 }
 829 
 830 void MacroAssembler::warn(const char* msg) {
 831   push(rbp);
 832   movq(rbp, rsp);
 833   andq(rsp, -16);     // align stack as required by push_CPU_state and call
 834   push_CPU_state();   // keeps alignment at 16 bytes
 835   lea(c_rarg0, ExternalAddress((address) msg));
 836   lea(rax, ExternalAddress(CAST_FROM_FN_PTR(address, warning)));
 837   call(rax);
 838   pop_CPU_state();
 839   mov(rsp, rbp);
 840   pop(rbp);
 841 }
 842 
 843 void MacroAssembler::print_state() {
 844   address rip = pc();
 845   pusha();            // get regs on stack
 846   push(rbp);
 847   movq(rbp, rsp);
 848   andq(rsp, -16);     // align stack as required by push_CPU_state and call
 849   push_CPU_state();   // keeps alignment at 16 bytes
 850 
 851   lea(c_rarg0, InternalAddress(rip));
 852   lea(c_rarg1, Address(rbp, wordSize)); // pass pointer to regs array
 853   call_VM_leaf(CAST_FROM_FN_PTR(address, MacroAssembler::print_state64), c_rarg0, c_rarg1);
 854 
 855   pop_CPU_state();
 856   mov(rsp, rbp);
 857   pop(rbp);
 858   popa();
 859 }
 860 
 861 #ifndef PRODUCT
 862 extern &quot;C&quot; void findpc(intptr_t x);
 863 #endif
 864 
 865 void MacroAssembler::debug64(char* msg, int64_t pc, int64_t regs[]) {
 866   // In order to get locks to work, we need to fake a in_VM state
 867   if (ShowMessageBoxOnError) {
 868     JavaThread* thread = JavaThread::current();
 869     JavaThreadState saved_state = thread-&gt;thread_state();
 870     thread-&gt;set_thread_state(_thread_in_vm);
 871 #ifndef PRODUCT
 872     if (CountBytecodes || TraceBytecodes || StopInterpreterAt) {
 873       ttyLocker ttyl;
 874       BytecodeCounter::print();
 875     }
 876 #endif
 877     // To see where a verify_oop failed, get $ebx+40/X for this frame.
 878     // XXX correct this offset for amd64
 879     // This is the value of eip which points to where verify_oop will return.
 880     if (os::message_box(msg, &quot;Execution stopped, print registers?&quot;)) {
 881       print_state64(pc, regs);
 882       BREAKPOINT;
 883     }
 884   }
 885   fatal(&quot;DEBUG MESSAGE: %s&quot;, msg);
 886 }
 887 
 888 void MacroAssembler::print_state64(int64_t pc, int64_t regs[]) {
 889   ttyLocker ttyl;
 890   FlagSetting fs(Debugging, true);
 891   tty-&gt;print_cr(&quot;rip = 0x%016lx&quot;, (intptr_t)pc);
 892 #ifndef PRODUCT
 893   tty-&gt;cr();
 894   findpc(pc);
 895   tty-&gt;cr();
 896 #endif
 897 #define PRINT_REG(rax, value) \
 898   { tty-&gt;print(&quot;%s = &quot;, #rax); os::print_location(tty, value); }
 899   PRINT_REG(rax, regs[15]);
 900   PRINT_REG(rbx, regs[12]);
 901   PRINT_REG(rcx, regs[14]);
 902   PRINT_REG(rdx, regs[13]);
 903   PRINT_REG(rdi, regs[8]);
 904   PRINT_REG(rsi, regs[9]);
 905   PRINT_REG(rbp, regs[10]);
 906   // rsp is actually not stored by pusha(), compute the old rsp from regs (rsp after pusha): regs + 16 = old rsp
 907   PRINT_REG(rsp, (intptr_t)(&amp;regs[16]));
 908   PRINT_REG(r8 , regs[7]);
 909   PRINT_REG(r9 , regs[6]);
 910   PRINT_REG(r10, regs[5]);
 911   PRINT_REG(r11, regs[4]);
 912   PRINT_REG(r12, regs[3]);
 913   PRINT_REG(r13, regs[2]);
 914   PRINT_REG(r14, regs[1]);
 915   PRINT_REG(r15, regs[0]);
 916 #undef PRINT_REG
 917   // Print some words near the top of the stack.
 918   int64_t* rsp = &amp;regs[16];
 919   int64_t* dump_sp = rsp;
 920   for (int col1 = 0; col1 &lt; 8; col1++) {
 921     tty-&gt;print(&quot;(rsp+0x%03x) 0x%016lx: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 922     os::print_location(tty, *dump_sp++);
 923   }
 924   for (int row = 0; row &lt; 25; row++) {
 925     tty-&gt;print(&quot;(rsp+0x%03x) 0x%016lx: &quot;, (int)((intptr_t)dump_sp - (intptr_t)rsp), (intptr_t)dump_sp);
 926     for (int col = 0; col &lt; 4; col++) {
 927       tty-&gt;print(&quot; 0x%016lx&quot;, (intptr_t)*dump_sp++);
 928     }
 929     tty-&gt;cr();
 930   }
 931   // Print some instructions around pc:
 932   Disassembler::decode((address)pc-64, (address)pc);
 933   tty-&gt;print_cr(&quot;--------&quot;);
 934   Disassembler::decode((address)pc, (address)pc+32);
 935 }
 936 
 937 #endif // _LP64
 938 
 939 // Now versions that are common to 32/64 bit
 940 
 941 void MacroAssembler::addptr(Register dst, int32_t imm32) {
 942   LP64_ONLY(addq(dst, imm32)) NOT_LP64(addl(dst, imm32));
 943 }
 944 
 945 void MacroAssembler::addptr(Register dst, Register src) {
 946   LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src));
 947 }
 948 
 949 void MacroAssembler::addptr(Address dst, Register src) {
 950   LP64_ONLY(addq(dst, src)) NOT_LP64(addl(dst, src));
 951 }
 952 
 953 void MacroAssembler::addsd(XMMRegister dst, AddressLiteral src) {
 954   if (reachable(src)) {
 955     Assembler::addsd(dst, as_Address(src));
 956   } else {
 957     lea(rscratch1, src);
 958     Assembler::addsd(dst, Address(rscratch1, 0));
 959   }
 960 }
 961 
 962 void MacroAssembler::addss(XMMRegister dst, AddressLiteral src) {
 963   if (reachable(src)) {
 964     addss(dst, as_Address(src));
 965   } else {
 966     lea(rscratch1, src);
 967     addss(dst, Address(rscratch1, 0));
 968   }
 969 }
 970 
 971 void MacroAssembler::addpd(XMMRegister dst, AddressLiteral src) {
 972   if (reachable(src)) {
 973     Assembler::addpd(dst, as_Address(src));
 974   } else {
 975     lea(rscratch1, src);
 976     Assembler::addpd(dst, Address(rscratch1, 0));
 977   }
 978 }
 979 
 980 void MacroAssembler::align(int modulus) {
 981   align(modulus, offset());
 982 }
 983 
 984 void MacroAssembler::align(int modulus, int target) {
 985   if (target % modulus != 0) {
 986     nop(modulus - (target % modulus));
 987   }
 988 }
 989 
 990 void MacroAssembler::andpd(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
 991   // Used in sign-masking with aligned address.
 992   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
 993   if (reachable(src)) {
 994     Assembler::andpd(dst, as_Address(src));
 995   } else {
 996     lea(scratch_reg, src);
 997     Assembler::andpd(dst, Address(scratch_reg, 0));
 998   }
 999 }
1000 
1001 void MacroAssembler::andps(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
1002   // Used in sign-masking with aligned address.
1003   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
1004   if (reachable(src)) {
1005     Assembler::andps(dst, as_Address(src));
1006   } else {
1007     lea(scratch_reg, src);
1008     Assembler::andps(dst, Address(scratch_reg, 0));
1009   }
1010 }
1011 
1012 void MacroAssembler::andptr(Register dst, int32_t imm32) {
1013   LP64_ONLY(andq(dst, imm32)) NOT_LP64(andl(dst, imm32));
1014 }
1015 
1016 void MacroAssembler::atomic_incl(Address counter_addr) {
1017   lock();
1018   incrementl(counter_addr);
1019 }
1020 
1021 void MacroAssembler::atomic_incl(AddressLiteral counter_addr, Register scr) {
1022   if (reachable(counter_addr)) {
1023     atomic_incl(as_Address(counter_addr));
1024   } else {
1025     lea(scr, counter_addr);
1026     atomic_incl(Address(scr, 0));
1027   }
1028 }
1029 
1030 #ifdef _LP64
1031 void MacroAssembler::atomic_incq(Address counter_addr) {
1032   lock();
1033   incrementq(counter_addr);
1034 }
1035 
1036 void MacroAssembler::atomic_incq(AddressLiteral counter_addr, Register scr) {
1037   if (reachable(counter_addr)) {
1038     atomic_incq(as_Address(counter_addr));
1039   } else {
1040     lea(scr, counter_addr);
1041     atomic_incq(Address(scr, 0));
1042   }
1043 }
1044 #endif
1045 
1046 // Writes to stack successive pages until offset reached to check for
1047 // stack overflow + shadow pages.  This clobbers tmp.
1048 void MacroAssembler::bang_stack_size(Register size, Register tmp) {
1049   movptr(tmp, rsp);
1050   // Bang stack for total size given plus shadow page size.
1051   // Bang one page at a time because large size can bang beyond yellow and
1052   // red zones.
1053   Label loop;
1054   bind(loop);
1055   movl(Address(tmp, (-os::vm_page_size())), size );
1056   subptr(tmp, os::vm_page_size());
1057   subl(size, os::vm_page_size());
1058   jcc(Assembler::greater, loop);
1059 
1060   // Bang down shadow pages too.
1061   // At this point, (tmp-0) is the last address touched, so don&#39;t
1062   // touch it again.  (It was touched as (tmp-pagesize) but then tmp
1063   // was post-decremented.)  Skip this address by starting at i=1, and
1064   // touch a few more pages below.  N.B.  It is important to touch all
1065   // the way down including all pages in the shadow zone.
1066   for (int i = 1; i &lt; ((int)JavaThread::stack_shadow_zone_size() / os::vm_page_size()); i++) {
1067     // this could be any sized move but this is can be a debugging crumb
1068     // so the bigger the better.
1069     movptr(Address(tmp, (-i*os::vm_page_size())), size );
1070   }
1071 }
1072 
1073 void MacroAssembler::reserved_stack_check() {
1074     // testing if reserved zone needs to be enabled
1075     Label no_reserved_zone_enabling;
1076     Register thread = NOT_LP64(rsi) LP64_ONLY(r15_thread);
1077     NOT_LP64(get_thread(rsi);)
1078 
1079     cmpptr(rsp, Address(thread, JavaThread::reserved_stack_activation_offset()));
1080     jcc(Assembler::below, no_reserved_zone_enabling);
1081 
1082     call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone), thread);
1083     jump(RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));
1084     should_not_reach_here();
1085 
1086     bind(no_reserved_zone_enabling);
1087 }
1088 
1089 int MacroAssembler::biased_locking_enter(Register lock_reg,
1090                                          Register obj_reg,
1091                                          Register swap_reg,
1092                                          Register tmp_reg,
1093                                          Register tmp_reg2,
1094                                          bool swap_reg_contains_mark,
1095                                          Label&amp; done,
1096                                          Label* slow_case,
1097                                          BiasedLockingCounters* counters) {
1098   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
1099   assert(swap_reg == rax, &quot;swap_reg must be rax for cmpxchgq&quot;);
1100   assert(tmp_reg != noreg, &quot;tmp_reg must be supplied&quot;);
1101   assert_different_registers(lock_reg, obj_reg, swap_reg, tmp_reg);
1102   assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, &quot;biased locking makes assumptions about bit layout&quot;);
1103   Address mark_addr      (obj_reg, oopDesc::mark_offset_in_bytes());
1104   NOT_LP64( Address saved_mark_addr(lock_reg, 0); )
1105 
1106   if (PrintBiasedLockingStatistics &amp;&amp; counters == NULL) {
1107     counters = BiasedLocking::counters();
1108   }
1109   // Biased locking
1110   // See whether the lock is currently biased toward our thread and
1111   // whether the epoch is still valid
1112   // Note that the runtime guarantees sufficient alignment of JavaThread
1113   // pointers to allow age to be placed into low bits
1114   // First check to see whether biasing is even enabled for this object
1115   Label cas_label;
1116   int null_check_offset = -1;
1117   if (!swap_reg_contains_mark) {
1118     null_check_offset = offset();
1119     movptr(swap_reg, mark_addr);
1120   }
1121   movptr(tmp_reg, swap_reg);
1122   andptr(tmp_reg, markWord::biased_lock_mask_in_place);
1123   cmpptr(tmp_reg, markWord::biased_lock_pattern);
1124   jcc(Assembler::notEqual, cas_label);
1125   // The bias pattern is present in the object&#39;s header. Need to check
1126   // whether the bias owner and the epoch are both still current.
1127 #ifndef _LP64
1128   // Note that because there is no current thread register on x86_32 we
1129   // need to store off the mark word we read out of the object to
1130   // avoid reloading it and needing to recheck invariants below. This
1131   // store is unfortunate but it makes the overall code shorter and
1132   // simpler.
1133   movptr(saved_mark_addr, swap_reg);
1134 #endif
1135   if (swap_reg_contains_mark) {
1136     null_check_offset = offset();
1137   }
1138   load_prototype_header(tmp_reg, obj_reg, tmp_reg2);
1139 #ifdef _LP64
1140   orptr(tmp_reg, r15_thread);
1141   xorptr(tmp_reg, swap_reg);
1142   Register header_reg = tmp_reg;
1143 #else
1144   xorptr(tmp_reg, swap_reg);
1145   get_thread(swap_reg);
1146   xorptr(swap_reg, tmp_reg);
1147   Register header_reg = swap_reg;
1148 #endif
1149   andptr(header_reg, ~((int) markWord::age_mask_in_place));
1150   if (counters != NULL) {
1151     cond_inc32(Assembler::zero,
1152                ExternalAddress((address) counters-&gt;biased_lock_entry_count_addr()));
1153   }
1154   jcc(Assembler::equal, done);
1155 
1156   Label try_revoke_bias;
1157   Label try_rebias;
1158 
1159   // At this point we know that the header has the bias pattern and
1160   // that we are not the bias owner in the current epoch. We need to
1161   // figure out more details about the state of the header in order to
1162   // know what operations can be legally performed on the object&#39;s
1163   // header.
1164 
1165   // If the low three bits in the xor result aren&#39;t clear, that means
1166   // the prototype header is no longer biased and we have to revoke
1167   // the bias on this object.
1168   testptr(header_reg, markWord::biased_lock_mask_in_place);
1169   jccb(Assembler::notZero, try_revoke_bias);
1170 
1171   // Biasing is still enabled for this data type. See whether the
1172   // epoch of the current bias is still valid, meaning that the epoch
1173   // bits of the mark word are equal to the epoch bits of the
1174   // prototype header. (Note that the prototype header&#39;s epoch bits
1175   // only change at a safepoint.) If not, attempt to rebias the object
1176   // toward the current thread. Note that we must be absolutely sure
1177   // that the current epoch is invalid in order to do this because
1178   // otherwise the manipulations it performs on the mark word are
1179   // illegal.
1180   testptr(header_reg, markWord::epoch_mask_in_place);
1181   jccb(Assembler::notZero, try_rebias);
1182 
1183   // The epoch of the current bias is still valid but we know nothing
1184   // about the owner; it might be set or it might be clear. Try to
1185   // acquire the bias of the object using an atomic operation. If this
1186   // fails we will go in to the runtime to revoke the object&#39;s bias.
1187   // Note that we first construct the presumed unbiased header so we
1188   // don&#39;t accidentally blow away another thread&#39;s valid bias.
1189   NOT_LP64( movptr(swap_reg, saved_mark_addr); )
1190   andptr(swap_reg,
1191          markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);
1192 #ifdef _LP64
1193   movptr(tmp_reg, swap_reg);
1194   orptr(tmp_reg, r15_thread);
1195 #else
1196   get_thread(tmp_reg);
1197   orptr(tmp_reg, swap_reg);
1198 #endif
1199   lock();
1200   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
1201   // If the biasing toward our thread failed, this means that
1202   // another thread succeeded in biasing it toward itself and we
1203   // need to revoke that bias. The revocation will occur in the
1204   // interpreter runtime in the slow case.
1205   if (counters != NULL) {
1206     cond_inc32(Assembler::zero,
1207                ExternalAddress((address) counters-&gt;anonymously_biased_lock_entry_count_addr()));
1208   }
1209   if (slow_case != NULL) {
1210     jcc(Assembler::notZero, *slow_case);
1211   }
1212   jmp(done);
1213 
1214   bind(try_rebias);
1215   // At this point we know the epoch has expired, meaning that the
1216   // current &quot;bias owner&quot;, if any, is actually invalid. Under these
1217   // circumstances _only_, we are allowed to use the current header&#39;s
1218   // value as the comparison value when doing the cas to acquire the
1219   // bias in the current epoch. In other words, we allow transfer of
1220   // the bias from one thread to another directly in this situation.
1221   //
1222   // FIXME: due to a lack of registers we currently blow away the age
1223   // bits in this situation. Should attempt to preserve them.
1224   load_prototype_header(tmp_reg, obj_reg, tmp_reg2);
1225 #ifdef _LP64
1226   orptr(tmp_reg, r15_thread);
1227 #else
1228   get_thread(swap_reg);
1229   orptr(tmp_reg, swap_reg);
1230   movptr(swap_reg, saved_mark_addr);
1231 #endif
1232   lock();
1233   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
1234   // If the biasing toward our thread failed, then another thread
1235   // succeeded in biasing it toward itself and we need to revoke that
1236   // bias. The revocation will occur in the runtime in the slow case.
1237   if (counters != NULL) {
1238     cond_inc32(Assembler::zero,
1239                ExternalAddress((address) counters-&gt;rebiased_lock_entry_count_addr()));
1240   }
1241   if (slow_case != NULL) {
1242     jcc(Assembler::notZero, *slow_case);
1243   }
1244   jmp(done);
1245 
1246   bind(try_revoke_bias);
1247   // The prototype mark in the klass doesn&#39;t have the bias bit set any
1248   // more, indicating that objects of this data type are not supposed
1249   // to be biased any more. We are going to try to reset the mark of
1250   // this object to the prototype value and fall through to the
1251   // CAS-based locking scheme. Note that if our CAS fails, it means
1252   // that another thread raced us for the privilege of revoking the
1253   // bias of this particular object, so it&#39;s okay to continue in the
1254   // normal locking code.
1255   //
1256   // FIXME: due to a lack of registers we currently blow away the age
1257   // bits in this situation. Should attempt to preserve them.
1258   NOT_LP64( movptr(swap_reg, saved_mark_addr); )
1259   load_prototype_header(tmp_reg, obj_reg, tmp_reg2);
1260   lock();
1261   cmpxchgptr(tmp_reg, mark_addr); // compare tmp_reg and swap_reg
1262   // Fall through to the normal CAS-based lock, because no matter what
1263   // the result of the above CAS, some thread must have succeeded in
1264   // removing the bias bit from the object&#39;s header.
1265   if (counters != NULL) {
1266     cond_inc32(Assembler::zero,
1267                ExternalAddress((address) counters-&gt;revoked_lock_entry_count_addr()));
1268   }
1269 
1270   bind(cas_label);
1271 
1272   return null_check_offset;
1273 }
1274 
1275 void MacroAssembler::biased_locking_exit(Register obj_reg, Register temp_reg, Label&amp; done) {
1276   assert(UseBiasedLocking, &quot;why call this otherwise?&quot;);
1277 
1278   // Check for biased locking unlock case, which is a no-op
1279   // Note: we do not have to check the thread ID for two reasons.
1280   // First, the interpreter checks for IllegalMonitorStateException at
1281   // a higher level. Second, if the bias was revoked while we held the
1282   // lock, the object could not be rebiased toward another thread, so
1283   // the bias bit would be clear.
1284   movptr(temp_reg, Address(obj_reg, oopDesc::mark_offset_in_bytes()));
1285   andptr(temp_reg, markWord::biased_lock_mask_in_place);
1286   cmpptr(temp_reg, markWord::biased_lock_pattern);
1287   jcc(Assembler::equal, done);
1288 }
1289 
1290 void MacroAssembler::c2bool(Register x) {
1291   // implements x == 0 ? 0 : 1
1292   // note: must only look at least-significant byte of x
1293   //       since C-style booleans are stored in one byte
1294   //       only! (was bug)
1295   andl(x, 0xFF);
1296   setb(Assembler::notZero, x);
1297 }
1298 
1299 // Wouldn&#39;t need if AddressLiteral version had new name
1300 void MacroAssembler::call(Label&amp; L, relocInfo::relocType rtype) {
1301   Assembler::call(L, rtype);
1302 }
1303 
1304 void MacroAssembler::call(Register entry) {
1305   Assembler::call(entry);
1306 }
1307 
1308 void MacroAssembler::call(AddressLiteral entry) {
1309   if (reachable(entry)) {
1310     Assembler::call_literal(entry.target(), entry.rspec());
1311   } else {
1312     lea(rscratch1, entry);
1313     Assembler::call(rscratch1);
1314   }
1315 }
1316 
1317 void MacroAssembler::ic_call(address entry, jint method_index) {
1318   RelocationHolder rh = virtual_call_Relocation::spec(pc(), method_index);
1319   movptr(rax, (intptr_t)Universe::non_oop_word());
1320   call(AddressLiteral(entry, rh));
1321 }
1322 
1323 // Implementation of call_VM versions
1324 
1325 void MacroAssembler::call_VM(Register oop_result,
1326                              address entry_point,
1327                              bool check_exceptions) {
1328   Label C, E;
1329   call(C, relocInfo::none);
1330   jmp(E);
1331 
1332   bind(C);
1333   call_VM_helper(oop_result, entry_point, 0, check_exceptions);
1334   ret(0);
1335 
1336   bind(E);
1337 }
1338 
1339 void MacroAssembler::call_VM(Register oop_result,
1340                              address entry_point,
1341                              Register arg_1,
1342                              bool check_exceptions) {
1343   Label C, E;
1344   call(C, relocInfo::none);
1345   jmp(E);
1346 
1347   bind(C);
1348   pass_arg1(this, arg_1);
1349   call_VM_helper(oop_result, entry_point, 1, check_exceptions);
1350   ret(0);
1351 
1352   bind(E);
1353 }
1354 
1355 void MacroAssembler::call_VM(Register oop_result,
1356                              address entry_point,
1357                              Register arg_1,
1358                              Register arg_2,
1359                              bool check_exceptions) {
1360   Label C, E;
1361   call(C, relocInfo::none);
1362   jmp(E);
1363 
1364   bind(C);
1365 
1366   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1367 
1368   pass_arg2(this, arg_2);
1369   pass_arg1(this, arg_1);
1370   call_VM_helper(oop_result, entry_point, 2, check_exceptions);
1371   ret(0);
1372 
1373   bind(E);
1374 }
1375 
1376 void MacroAssembler::call_VM(Register oop_result,
1377                              address entry_point,
1378                              Register arg_1,
1379                              Register arg_2,
1380                              Register arg_3,
1381                              bool check_exceptions) {
1382   Label C, E;
1383   call(C, relocInfo::none);
1384   jmp(E);
1385 
1386   bind(C);
1387 
1388   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1389   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1390   pass_arg3(this, arg_3);
1391 
1392   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1393   pass_arg2(this, arg_2);
1394 
1395   pass_arg1(this, arg_1);
1396   call_VM_helper(oop_result, entry_point, 3, check_exceptions);
1397   ret(0);
1398 
1399   bind(E);
1400 }
1401 
1402 void MacroAssembler::call_VM(Register oop_result,
1403                              Register last_java_sp,
1404                              address entry_point,
1405                              int number_of_arguments,
1406                              bool check_exceptions) {
1407   Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);
1408   call_VM_base(oop_result, thread, last_java_sp, entry_point, number_of_arguments, check_exceptions);
1409 }
1410 
1411 void MacroAssembler::call_VM(Register oop_result,
1412                              Register last_java_sp,
1413                              address entry_point,
1414                              Register arg_1,
1415                              bool check_exceptions) {
1416   pass_arg1(this, arg_1);
1417   call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
1418 }
1419 
1420 void MacroAssembler::call_VM(Register oop_result,
1421                              Register last_java_sp,
1422                              address entry_point,
1423                              Register arg_1,
1424                              Register arg_2,
1425                              bool check_exceptions) {
1426 
1427   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1428   pass_arg2(this, arg_2);
1429   pass_arg1(this, arg_1);
1430   call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
1431 }
1432 
1433 void MacroAssembler::call_VM(Register oop_result,
1434                              Register last_java_sp,
1435                              address entry_point,
1436                              Register arg_1,
1437                              Register arg_2,
1438                              Register arg_3,
1439                              bool check_exceptions) {
1440   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1441   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1442   pass_arg3(this, arg_3);
1443   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1444   pass_arg2(this, arg_2);
1445   pass_arg1(this, arg_1);
1446   call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
1447 }
1448 
1449 void MacroAssembler::super_call_VM(Register oop_result,
1450                                    Register last_java_sp,
1451                                    address entry_point,
1452                                    int number_of_arguments,
1453                                    bool check_exceptions) {
1454   Register thread = LP64_ONLY(r15_thread) NOT_LP64(noreg);
1455   MacroAssembler::call_VM_base(oop_result, thread, last_java_sp, entry_point, number_of_arguments, check_exceptions);
1456 }
1457 
1458 void MacroAssembler::super_call_VM(Register oop_result,
1459                                    Register last_java_sp,
1460                                    address entry_point,
1461                                    Register arg_1,
1462                                    bool check_exceptions) {
1463   pass_arg1(this, arg_1);
1464   super_call_VM(oop_result, last_java_sp, entry_point, 1, check_exceptions);
1465 }
1466 
1467 void MacroAssembler::super_call_VM(Register oop_result,
1468                                    Register last_java_sp,
1469                                    address entry_point,
1470                                    Register arg_1,
1471                                    Register arg_2,
1472                                    bool check_exceptions) {
1473 
1474   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1475   pass_arg2(this, arg_2);
1476   pass_arg1(this, arg_1);
1477   super_call_VM(oop_result, last_java_sp, entry_point, 2, check_exceptions);
1478 }
1479 
1480 void MacroAssembler::super_call_VM(Register oop_result,
1481                                    Register last_java_sp,
1482                                    address entry_point,
1483                                    Register arg_1,
1484                                    Register arg_2,
1485                                    Register arg_3,
1486                                    bool check_exceptions) {
1487   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1488   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1489   pass_arg3(this, arg_3);
1490   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1491   pass_arg2(this, arg_2);
1492   pass_arg1(this, arg_1);
1493   super_call_VM(oop_result, last_java_sp, entry_point, 3, check_exceptions);
1494 }
1495 
1496 void MacroAssembler::call_VM_base(Register oop_result,
1497                                   Register java_thread,
1498                                   Register last_java_sp,
1499                                   address  entry_point,
1500                                   int      number_of_arguments,
1501                                   bool     check_exceptions) {
1502   // determine java_thread register
1503   if (!java_thread-&gt;is_valid()) {
1504 #ifdef _LP64
1505     java_thread = r15_thread;
1506 #else
1507     java_thread = rdi;
1508     get_thread(java_thread);
1509 #endif // LP64
1510   }
1511   // determine last_java_sp register
1512   if (!last_java_sp-&gt;is_valid()) {
1513     last_java_sp = rsp;
1514   }
1515   // debugging support
1516   assert(number_of_arguments &gt;= 0   , &quot;cannot have negative number of arguments&quot;);
1517   LP64_ONLY(assert(java_thread == r15_thread, &quot;unexpected register&quot;));
1518 #ifdef ASSERT
1519   // TraceBytecodes does not use r12 but saves it over the call, so don&#39;t verify
1520   // r12 is the heapbase.
1521   LP64_ONLY(if (UseCompressedOops &amp;&amp; !TraceBytecodes) verify_heapbase(&quot;call_VM_base: heap base corrupted?&quot;);)
1522 #endif // ASSERT
1523 
1524   assert(java_thread != oop_result  , &quot;cannot use the same register for java_thread &amp; oop_result&quot;);
1525   assert(java_thread != last_java_sp, &quot;cannot use the same register for java_thread &amp; last_java_sp&quot;);
1526 
1527   // push java thread (becomes first argument of C function)
1528 
1529   NOT_LP64(push(java_thread); number_of_arguments++);
1530   LP64_ONLY(mov(c_rarg0, r15_thread));
1531 
1532   // set last Java frame before call
1533   assert(last_java_sp != rbp, &quot;can&#39;t use ebp/rbp&quot;);
1534 
1535   // Only interpreter should have to set fp
1536   set_last_Java_frame(java_thread, last_java_sp, rbp, NULL);
1537 
1538   // do the call, remove parameters
1539   MacroAssembler::call_VM_leaf_base(entry_point, number_of_arguments);
1540 
1541   // restore the thread (cannot use the pushed argument since arguments
1542   // may be overwritten by C code generated by an optimizing compiler);
1543   // however can use the register value directly if it is callee saved.
1544   if (LP64_ONLY(true ||) java_thread == rdi || java_thread == rsi) {
1545     // rdi &amp; rsi (also r15) are callee saved -&gt; nothing to do
1546 #ifdef ASSERT
1547     guarantee(java_thread != rax, &quot;change this code&quot;);
1548     push(rax);
1549     { Label L;
1550       get_thread(rax);
1551       cmpptr(java_thread, rax);
1552       jcc(Assembler::equal, L);
1553       STOP(&quot;MacroAssembler::call_VM_base: rdi not callee saved?&quot;);
1554       bind(L);
1555     }
1556     pop(rax);
1557 #endif
1558   } else {
1559     get_thread(java_thread);
1560   }
1561   // reset last Java frame
1562   // Only interpreter should have to clear fp
1563   reset_last_Java_frame(java_thread, true);
1564 
1565    // C++ interp handles this in the interpreter
1566   check_and_handle_popframe(java_thread);
1567   check_and_handle_earlyret(java_thread);
1568 
1569   if (check_exceptions) {
1570     // check for pending exceptions (java_thread is set upon return)
1571     cmpptr(Address(java_thread, Thread::pending_exception_offset()), (int32_t) NULL_WORD);
1572 #ifndef _LP64
1573     jump_cc(Assembler::notEqual,
1574             RuntimeAddress(StubRoutines::forward_exception_entry()));
1575 #else
1576     // This used to conditionally jump to forward_exception however it is
1577     // possible if we relocate that the branch will not reach. So we must jump
1578     // around so we can always reach
1579 
1580     Label ok;
1581     jcc(Assembler::equal, ok);
1582     jump(RuntimeAddress(StubRoutines::forward_exception_entry()));
1583     bind(ok);
1584 #endif // LP64
1585   }
1586 
1587   // get oop result if there is one and reset the value in the thread
1588   if (oop_result-&gt;is_valid()) {
1589     get_vm_result(oop_result, java_thread);
1590   }
1591 }
1592 
1593 void MacroAssembler::call_VM_helper(Register oop_result, address entry_point, int number_of_arguments, bool check_exceptions) {
1594 
1595   // Calculate the value for last_Java_sp
1596   // somewhat subtle. call_VM does an intermediate call
1597   // which places a return address on the stack just under the
1598   // stack pointer as the user finsihed with it. This allows
1599   // use to retrieve last_Java_pc from last_Java_sp[-1].
1600   // On 32bit we then have to push additional args on the stack to accomplish
1601   // the actual requested call. On 64bit call_VM only can use register args
1602   // so the only extra space is the return address that call_VM created.
1603   // This hopefully explains the calculations here.
1604 
1605 #ifdef _LP64
1606   // We&#39;ve pushed one address, correct last_Java_sp
1607   lea(rax, Address(rsp, wordSize));
1608 #else
1609   lea(rax, Address(rsp, (1 + number_of_arguments) * wordSize));
1610 #endif // LP64
1611 
1612   call_VM_base(oop_result, noreg, rax, entry_point, number_of_arguments, check_exceptions);
1613 
1614 }
1615 
1616 // Use this method when MacroAssembler version of call_VM_leaf_base() should be called from Interpreter.
1617 void MacroAssembler::call_VM_leaf0(address entry_point) {
1618   MacroAssembler::call_VM_leaf_base(entry_point, 0);
1619 }
1620 
1621 void MacroAssembler::call_VM_leaf(address entry_point, int number_of_arguments) {
1622   call_VM_leaf_base(entry_point, number_of_arguments);
1623 }
1624 
1625 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0) {
1626   pass_arg0(this, arg_0);
1627   call_VM_leaf(entry_point, 1);
1628 }
1629 
1630 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
1631 
1632   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1633   pass_arg1(this, arg_1);
1634   pass_arg0(this, arg_0);
1635   call_VM_leaf(entry_point, 2);
1636 }
1637 
1638 void MacroAssembler::call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) {
1639   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
1640   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1641   pass_arg2(this, arg_2);
1642   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1643   pass_arg1(this, arg_1);
1644   pass_arg0(this, arg_0);
1645   call_VM_leaf(entry_point, 3);
1646 }
1647 
<a name="4" id="anc4"></a><span class="line-added">1648 void MacroAssembler::super_call_VM_leaf(address entry_point) {</span>
<span class="line-added">1649   MacroAssembler::call_VM_leaf_base(entry_point, 1);</span>
<span class="line-added">1650 }</span>
<span class="line-added">1651 </span>
1652 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0) {
1653   pass_arg0(this, arg_0);
1654   MacroAssembler::call_VM_leaf_base(entry_point, 1);
1655 }
1656 
1657 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1) {
1658 
1659   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1660   pass_arg1(this, arg_1);
1661   pass_arg0(this, arg_0);
1662   MacroAssembler::call_VM_leaf_base(entry_point, 2);
1663 }
1664 
1665 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2) {
1666   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
1667   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1668   pass_arg2(this, arg_2);
1669   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1670   pass_arg1(this, arg_1);
1671   pass_arg0(this, arg_0);
1672   MacroAssembler::call_VM_leaf_base(entry_point, 3);
1673 }
1674 
1675 void MacroAssembler::super_call_VM_leaf(address entry_point, Register arg_0, Register arg_1, Register arg_2, Register arg_3) {
1676   LP64_ONLY(assert(arg_0 != c_rarg3, &quot;smashed arg&quot;));
1677   LP64_ONLY(assert(arg_1 != c_rarg3, &quot;smashed arg&quot;));
1678   LP64_ONLY(assert(arg_2 != c_rarg3, &quot;smashed arg&quot;));
1679   pass_arg3(this, arg_3);
1680   LP64_ONLY(assert(arg_0 != c_rarg2, &quot;smashed arg&quot;));
1681   LP64_ONLY(assert(arg_1 != c_rarg2, &quot;smashed arg&quot;));
1682   pass_arg2(this, arg_2);
1683   LP64_ONLY(assert(arg_0 != c_rarg1, &quot;smashed arg&quot;));
1684   pass_arg1(this, arg_1);
1685   pass_arg0(this, arg_0);
1686   MacroAssembler::call_VM_leaf_base(entry_point, 4);
1687 }
1688 
1689 void MacroAssembler::get_vm_result(Register oop_result, Register java_thread) {
1690   movptr(oop_result, Address(java_thread, JavaThread::vm_result_offset()));
1691   movptr(Address(java_thread, JavaThread::vm_result_offset()), NULL_WORD);
1692   verify_oop_msg(oop_result, &quot;broken oop in call_VM_base&quot;);
1693 }
1694 
1695 void MacroAssembler::get_vm_result_2(Register metadata_result, Register java_thread) {
1696   movptr(metadata_result, Address(java_thread, JavaThread::vm_result_2_offset()));
1697   movptr(Address(java_thread, JavaThread::vm_result_2_offset()), NULL_WORD);
1698 }
1699 
1700 void MacroAssembler::check_and_handle_earlyret(Register java_thread) {
1701 }
1702 
1703 void MacroAssembler::check_and_handle_popframe(Register java_thread) {
1704 }
1705 
1706 void MacroAssembler::cmp32(AddressLiteral src1, int32_t imm) {
1707   if (reachable(src1)) {
1708     cmpl(as_Address(src1), imm);
1709   } else {
1710     lea(rscratch1, src1);
1711     cmpl(Address(rscratch1, 0), imm);
1712   }
1713 }
1714 
1715 void MacroAssembler::cmp32(Register src1, AddressLiteral src2) {
1716   assert(!src2.is_lval(), &quot;use cmpptr&quot;);
1717   if (reachable(src2)) {
1718     cmpl(src1, as_Address(src2));
1719   } else {
1720     lea(rscratch1, src2);
1721     cmpl(src1, Address(rscratch1, 0));
1722   }
1723 }
1724 
1725 void MacroAssembler::cmp32(Register src1, int32_t imm) {
1726   Assembler::cmpl(src1, imm);
1727 }
1728 
1729 void MacroAssembler::cmp32(Register src1, Address src2) {
1730   Assembler::cmpl(src1, src2);
1731 }
1732 
1733 void MacroAssembler::cmpsd2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less) {
1734   ucomisd(opr1, opr2);
1735 
1736   Label L;
1737   if (unordered_is_less) {
1738     movl(dst, -1);
1739     jcc(Assembler::parity, L);
1740     jcc(Assembler::below , L);
1741     movl(dst, 0);
1742     jcc(Assembler::equal , L);
1743     increment(dst);
1744   } else { // unordered is greater
1745     movl(dst, 1);
1746     jcc(Assembler::parity, L);
1747     jcc(Assembler::above , L);
1748     movl(dst, 0);
1749     jcc(Assembler::equal , L);
1750     decrementl(dst);
1751   }
1752   bind(L);
1753 }
1754 
1755 void MacroAssembler::cmpss2int(XMMRegister opr1, XMMRegister opr2, Register dst, bool unordered_is_less) {
1756   ucomiss(opr1, opr2);
1757 
1758   Label L;
1759   if (unordered_is_less) {
1760     movl(dst, -1);
1761     jcc(Assembler::parity, L);
1762     jcc(Assembler::below , L);
1763     movl(dst, 0);
1764     jcc(Assembler::equal , L);
1765     increment(dst);
1766   } else { // unordered is greater
1767     movl(dst, 1);
1768     jcc(Assembler::parity, L);
1769     jcc(Assembler::above , L);
1770     movl(dst, 0);
1771     jcc(Assembler::equal , L);
1772     decrementl(dst);
1773   }
1774   bind(L);
1775 }
1776 
1777 
1778 void MacroAssembler::cmp8(AddressLiteral src1, int imm) {
1779   if (reachable(src1)) {
1780     cmpb(as_Address(src1), imm);
1781   } else {
1782     lea(rscratch1, src1);
1783     cmpb(Address(rscratch1, 0), imm);
1784   }
1785 }
1786 
1787 void MacroAssembler::cmpptr(Register src1, AddressLiteral src2) {
1788 #ifdef _LP64
1789   if (src2.is_lval()) {
1790     movptr(rscratch1, src2);
1791     Assembler::cmpq(src1, rscratch1);
1792   } else if (reachable(src2)) {
1793     cmpq(src1, as_Address(src2));
1794   } else {
1795     lea(rscratch1, src2);
1796     Assembler::cmpq(src1, Address(rscratch1, 0));
1797   }
1798 #else
1799   if (src2.is_lval()) {
1800     cmp_literal32(src1, (int32_t) src2.target(), src2.rspec());
1801   } else {
1802     cmpl(src1, as_Address(src2));
1803   }
1804 #endif // _LP64
1805 }
1806 
1807 void MacroAssembler::cmpptr(Address src1, AddressLiteral src2) {
1808   assert(src2.is_lval(), &quot;not a mem-mem compare&quot;);
1809 #ifdef _LP64
1810   // moves src2&#39;s literal address
1811   movptr(rscratch1, src2);
1812   Assembler::cmpq(src1, rscratch1);
1813 #else
1814   cmp_literal32(src1, (int32_t) src2.target(), src2.rspec());
1815 #endif // _LP64
1816 }
1817 
1818 void MacroAssembler::cmpoop(Register src1, Register src2) {
1819   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1820   bs-&gt;obj_equals(this, src1, src2);
1821 }
1822 
1823 void MacroAssembler::cmpoop(Register src1, Address src2) {
1824   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1825   bs-&gt;obj_equals(this, src1, src2);
1826 }
1827 
1828 #ifdef _LP64
1829 void MacroAssembler::cmpoop(Register src1, jobject src2) {
1830   movoop(rscratch1, src2);
1831   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1832   bs-&gt;obj_equals(this, src1, rscratch1);
1833 }
1834 #endif
1835 
1836 void MacroAssembler::locked_cmpxchgptr(Register reg, AddressLiteral adr) {
1837   if (reachable(adr)) {
1838     lock();
1839     cmpxchgptr(reg, as_Address(adr));
1840   } else {
1841     lea(rscratch1, adr);
1842     lock();
1843     cmpxchgptr(reg, Address(rscratch1, 0));
1844   }
1845 }
1846 
1847 void MacroAssembler::cmpxchgptr(Register reg, Address adr) {
1848   LP64_ONLY(cmpxchgq(reg, adr)) NOT_LP64(cmpxchgl(reg, adr));
1849 }
1850 
1851 void MacroAssembler::comisd(XMMRegister dst, AddressLiteral src) {
1852   if (reachable(src)) {
1853     Assembler::comisd(dst, as_Address(src));
1854   } else {
1855     lea(rscratch1, src);
1856     Assembler::comisd(dst, Address(rscratch1, 0));
1857   }
1858 }
1859 
1860 void MacroAssembler::comiss(XMMRegister dst, AddressLiteral src) {
1861   if (reachable(src)) {
1862     Assembler::comiss(dst, as_Address(src));
1863   } else {
1864     lea(rscratch1, src);
1865     Assembler::comiss(dst, Address(rscratch1, 0));
1866   }
1867 }
1868 
1869 
1870 void MacroAssembler::cond_inc32(Condition cond, AddressLiteral counter_addr) {
1871   Condition negated_cond = negate_condition(cond);
1872   Label L;
1873   jcc(negated_cond, L);
1874   pushf(); // Preserve flags
1875   atomic_incl(counter_addr);
1876   popf();
1877   bind(L);
1878 }
1879 
1880 int MacroAssembler::corrected_idivl(Register reg) {
1881   // Full implementation of Java idiv and irem; checks for
1882   // special case as described in JVM spec., p.243 &amp; p.271.
1883   // The function returns the (pc) offset of the idivl
1884   // instruction - may be needed for implicit exceptions.
1885   //
1886   //         normal case                           special case
1887   //
1888   // input : rax,: dividend                         min_int
1889   //         reg: divisor   (may not be rax,/rdx)   -1
1890   //
1891   // output: rax,: quotient  (= rax, idiv reg)       min_int
1892   //         rdx: remainder (= rax, irem reg)       0
1893   assert(reg != rax &amp;&amp; reg != rdx, &quot;reg cannot be rax, or rdx register&quot;);
1894   const int min_int = 0x80000000;
1895   Label normal_case, special_case;
1896 
1897   // check for special case
1898   cmpl(rax, min_int);
1899   jcc(Assembler::notEqual, normal_case);
1900   xorl(rdx, rdx); // prepare rdx for possible special case (where remainder = 0)
1901   cmpl(reg, -1);
1902   jcc(Assembler::equal, special_case);
1903 
1904   // handle normal case
1905   bind(normal_case);
1906   cdql();
1907   int idivl_offset = offset();
1908   idivl(reg);
1909 
1910   // normal and special case exit
1911   bind(special_case);
1912 
1913   return idivl_offset;
1914 }
1915 
1916 
1917 
1918 void MacroAssembler::decrementl(Register reg, int value) {
1919   if (value == min_jint) {subl(reg, value) ; return; }
1920   if (value &lt;  0) { incrementl(reg, -value); return; }
1921   if (value == 0) {                        ; return; }
1922   if (value == 1 &amp;&amp; UseIncDec) { decl(reg) ; return; }
1923   /* else */      { subl(reg, value)       ; return; }
1924 }
1925 
1926 void MacroAssembler::decrementl(Address dst, int value) {
1927   if (value == min_jint) {subl(dst, value) ; return; }
1928   if (value &lt;  0) { incrementl(dst, -value); return; }
1929   if (value == 0) {                        ; return; }
1930   if (value == 1 &amp;&amp; UseIncDec) { decl(dst) ; return; }
1931   /* else */      { subl(dst, value)       ; return; }
1932 }
1933 
1934 void MacroAssembler::division_with_shift (Register reg, int shift_value) {
1935   assert (shift_value &gt; 0, &quot;illegal shift value&quot;);
1936   Label _is_positive;
1937   testl (reg, reg);
1938   jcc (Assembler::positive, _is_positive);
1939   int offset = (1 &lt;&lt; shift_value) - 1 ;
1940 
1941   if (offset == 1) {
1942     incrementl(reg);
1943   } else {
1944     addl(reg, offset);
1945   }
1946 
1947   bind (_is_positive);
1948   sarl(reg, shift_value);
1949 }
1950 
1951 void MacroAssembler::divsd(XMMRegister dst, AddressLiteral src) {
1952   if (reachable(src)) {
1953     Assembler::divsd(dst, as_Address(src));
1954   } else {
1955     lea(rscratch1, src);
1956     Assembler::divsd(dst, Address(rscratch1, 0));
1957   }
1958 }
1959 
1960 void MacroAssembler::divss(XMMRegister dst, AddressLiteral src) {
1961   if (reachable(src)) {
1962     Assembler::divss(dst, as_Address(src));
1963   } else {
1964     lea(rscratch1, src);
1965     Assembler::divss(dst, Address(rscratch1, 0));
1966   }
1967 }
1968 
1969 void MacroAssembler::enter() {
1970   push(rbp);
1971   mov(rbp, rsp);
1972 }
1973 
1974 // A 5 byte nop that is safe for patching (see patch_verified_entry)
1975 void MacroAssembler::fat_nop() {
1976   if (UseAddressNop) {
1977     addr_nop_5();
1978   } else {
1979     emit_int8(0x26); // es:
1980     emit_int8(0x2e); // cs:
1981     emit_int8(0x64); // fs:
1982     emit_int8(0x65); // gs:
1983     emit_int8((unsigned char)0x90);
1984   }
1985 }
1986 
1987 #ifndef _LP64
1988 void MacroAssembler::fcmp(Register tmp) {
1989   fcmp(tmp, 1, true, true);
1990 }
1991 
1992 void MacroAssembler::fcmp(Register tmp, int index, bool pop_left, bool pop_right) {
1993   assert(!pop_right || pop_left, &quot;usage error&quot;);
1994   if (VM_Version::supports_cmov()) {
1995     assert(tmp == noreg, &quot;unneeded temp&quot;);
1996     if (pop_left) {
1997       fucomip(index);
1998     } else {
1999       fucomi(index);
2000     }
2001     if (pop_right) {
2002       fpop();
2003     }
2004   } else {
2005     assert(tmp != noreg, &quot;need temp&quot;);
2006     if (pop_left) {
2007       if (pop_right) {
2008         fcompp();
2009       } else {
2010         fcomp(index);
2011       }
2012     } else {
2013       fcom(index);
2014     }
2015     // convert FPU condition into eflags condition via rax,
2016     save_rax(tmp);
2017     fwait(); fnstsw_ax();
2018     sahf();
2019     restore_rax(tmp);
2020   }
2021   // condition codes set as follows:
2022   //
2023   // CF (corresponds to C0) if x &lt; y
2024   // PF (corresponds to C2) if unordered
2025   // ZF (corresponds to C3) if x = y
2026 }
2027 
2028 void MacroAssembler::fcmp2int(Register dst, bool unordered_is_less) {
2029   fcmp2int(dst, unordered_is_less, 1, true, true);
2030 }
2031 
2032 void MacroAssembler::fcmp2int(Register dst, bool unordered_is_less, int index, bool pop_left, bool pop_right) {
2033   fcmp(VM_Version::supports_cmov() ? noreg : dst, index, pop_left, pop_right);
2034   Label L;
2035   if (unordered_is_less) {
2036     movl(dst, -1);
2037     jcc(Assembler::parity, L);
2038     jcc(Assembler::below , L);
2039     movl(dst, 0);
2040     jcc(Assembler::equal , L);
2041     increment(dst);
2042   } else { // unordered is greater
2043     movl(dst, 1);
2044     jcc(Assembler::parity, L);
2045     jcc(Assembler::above , L);
2046     movl(dst, 0);
2047     jcc(Assembler::equal , L);
2048     decrementl(dst);
2049   }
2050   bind(L);
2051 }
2052 
2053 void MacroAssembler::fld_d(AddressLiteral src) {
2054   fld_d(as_Address(src));
2055 }
2056 
2057 void MacroAssembler::fld_s(AddressLiteral src) {
2058   fld_s(as_Address(src));
2059 }
2060 
2061 void MacroAssembler::fld_x(AddressLiteral src) {
2062   Assembler::fld_x(as_Address(src));
2063 }
2064 
2065 void MacroAssembler::fldcw(AddressLiteral src) {
2066   Assembler::fldcw(as_Address(src));
2067 }
2068 
2069 void MacroAssembler::fpop() {
2070   ffree();
2071   fincstp();
2072 }
2073 
2074 void MacroAssembler::fremr(Register tmp) {
2075   save_rax(tmp);
2076   { Label L;
2077     bind(L);
2078     fprem();
2079     fwait(); fnstsw_ax();
2080     sahf();
2081     jcc(Assembler::parity, L);
2082   }
2083   restore_rax(tmp);
2084   // Result is in ST0.
2085   // Note: fxch &amp; fpop to get rid of ST1
2086   // (otherwise FPU stack could overflow eventually)
2087   fxch(1);
2088   fpop();
2089 }
2090 
2091 void MacroAssembler::empty_FPU_stack() {
2092   if (VM_Version::supports_mmx()) {
2093     emms();
2094   } else {
2095     for (int i = 8; i-- &gt; 0; ) ffree(i);
2096   }
2097 }
2098 #endif // !LP64
2099 
2100 void MacroAssembler::mulpd(XMMRegister dst, AddressLiteral src) {
2101   if (reachable(src)) {
2102     Assembler::mulpd(dst, as_Address(src));
2103   } else {
2104     lea(rscratch1, src);
2105     Assembler::mulpd(dst, Address(rscratch1, 0));
2106   }
2107 }
2108 
2109 void MacroAssembler::load_float(Address src) {
2110 #ifdef _LP64
2111   movflt(xmm0, src);
2112 #else
2113   if (UseSSE &gt;= 1) {
2114     movflt(xmm0, src);
2115   } else {
2116     fld_s(src);
2117   }
2118 #endif // LP64
2119 }
2120 
2121 void MacroAssembler::store_float(Address dst) {
2122 #ifdef _LP64
2123   movflt(dst, xmm0);
2124 #else
2125   if (UseSSE &gt;= 1) {
2126     movflt(dst, xmm0);
2127   } else {
2128     fstp_s(dst);
2129   }
2130 #endif // LP64
2131 }
2132 
2133 void MacroAssembler::load_double(Address src) {
2134 #ifdef _LP64
2135   movdbl(xmm0, src);
2136 #else
2137   if (UseSSE &gt;= 2) {
2138     movdbl(xmm0, src);
2139   } else {
2140     fld_d(src);
2141   }
2142 #endif // LP64
2143 }
2144 
2145 void MacroAssembler::store_double(Address dst) {
2146 #ifdef _LP64
2147   movdbl(dst, xmm0);
2148 #else
2149   if (UseSSE &gt;= 2) {
2150     movdbl(dst, xmm0);
2151   } else {
2152     fstp_d(dst);
2153   }
2154 #endif // LP64
2155 }
2156 
2157 // dst = c = a * b + c
2158 void MacroAssembler::fmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
2159   Assembler::vfmadd231sd(c, a, b);
2160   if (dst != c) {
2161     movdbl(dst, c);
2162   }
2163 }
2164 
2165 // dst = c = a * b + c
2166 void MacroAssembler::fmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c) {
2167   Assembler::vfmadd231ss(c, a, b);
2168   if (dst != c) {
2169     movflt(dst, c);
2170   }
2171 }
2172 
2173 // dst = c = a * b + c
2174 void MacroAssembler::vfmad(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {
2175   Assembler::vfmadd231pd(c, a, b, vector_len);
2176   if (dst != c) {
2177     vmovdqu(dst, c);
2178   }
2179 }
2180 
2181 // dst = c = a * b + c
2182 void MacroAssembler::vfmaf(XMMRegister dst, XMMRegister a, XMMRegister b, XMMRegister c, int vector_len) {
2183   Assembler::vfmadd231ps(c, a, b, vector_len);
2184   if (dst != c) {
2185     vmovdqu(dst, c);
2186   }
2187 }
2188 
2189 // dst = c = a * b + c
2190 void MacroAssembler::vfmad(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len) {
2191   Assembler::vfmadd231pd(c, a, b, vector_len);
2192   if (dst != c) {
2193     vmovdqu(dst, c);
2194   }
2195 }
2196 
2197 // dst = c = a * b + c
2198 void MacroAssembler::vfmaf(XMMRegister dst, XMMRegister a, Address b, XMMRegister c, int vector_len) {
2199   Assembler::vfmadd231ps(c, a, b, vector_len);
2200   if (dst != c) {
2201     vmovdqu(dst, c);
2202   }
2203 }
2204 
2205 void MacroAssembler::incrementl(AddressLiteral dst) {
2206   if (reachable(dst)) {
2207     incrementl(as_Address(dst));
2208   } else {
2209     lea(rscratch1, dst);
2210     incrementl(Address(rscratch1, 0));
2211   }
2212 }
2213 
2214 void MacroAssembler::incrementl(ArrayAddress dst) {
2215   incrementl(as_Address(dst));
2216 }
2217 
2218 void MacroAssembler::incrementl(Register reg, int value) {
2219   if (value == min_jint) {addl(reg, value) ; return; }
2220   if (value &lt;  0) { decrementl(reg, -value); return; }
2221   if (value == 0) {                        ; return; }
2222   if (value == 1 &amp;&amp; UseIncDec) { incl(reg) ; return; }
2223   /* else */      { addl(reg, value)       ; return; }
2224 }
2225 
2226 void MacroAssembler::incrementl(Address dst, int value) {
2227   if (value == min_jint) {addl(dst, value) ; return; }
2228   if (value &lt;  0) { decrementl(dst, -value); return; }
2229   if (value == 0) {                        ; return; }
2230   if (value == 1 &amp;&amp; UseIncDec) { incl(dst) ; return; }
2231   /* else */      { addl(dst, value)       ; return; }
2232 }
2233 
2234 void MacroAssembler::jump(AddressLiteral dst) {
2235   if (reachable(dst)) {
2236     jmp_literal(dst.target(), dst.rspec());
2237   } else {
2238     lea(rscratch1, dst);
2239     jmp(rscratch1);
2240   }
2241 }
2242 
2243 void MacroAssembler::jump_cc(Condition cc, AddressLiteral dst) {
2244   if (reachable(dst)) {
2245     InstructionMark im(this);
2246     relocate(dst.reloc());
2247     const int short_size = 2;
2248     const int long_size = 6;
2249     int offs = (intptr_t)dst.target() - ((intptr_t)pc());
2250     if (dst.reloc() == relocInfo::none &amp;&amp; is8bit(offs - short_size)) {
2251       // 0111 tttn #8-bit disp
2252       emit_int8(0x70 | cc);
2253       emit_int8((offs - short_size) &amp; 0xFF);
2254     } else {
2255       // 0000 1111 1000 tttn #32-bit disp
2256       emit_int8(0x0F);
2257       emit_int8((unsigned char)(0x80 | cc));
2258       emit_int32(offs - long_size);
2259     }
2260   } else {
2261 #ifdef ASSERT
2262     warning(&quot;reversing conditional branch&quot;);
2263 #endif /* ASSERT */
2264     Label skip;
2265     jccb(reverse[cc], skip);
2266     lea(rscratch1, dst);
2267     Assembler::jmp(rscratch1);
2268     bind(skip);
2269   }
2270 }
2271 
2272 void MacroAssembler::ldmxcsr(AddressLiteral src) {
2273   if (reachable(src)) {
2274     Assembler::ldmxcsr(as_Address(src));
2275   } else {
2276     lea(rscratch1, src);
2277     Assembler::ldmxcsr(Address(rscratch1, 0));
2278   }
2279 }
2280 
2281 int MacroAssembler::load_signed_byte(Register dst, Address src) {
2282   int off;
2283   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2284     off = offset();
2285     movsbl(dst, src); // movsxb
2286   } else {
2287     off = load_unsigned_byte(dst, src);
2288     shll(dst, 24);
2289     sarl(dst, 24);
2290   }
2291   return off;
2292 }
2293 
2294 // Note: load_signed_short used to be called load_signed_word.
2295 // Although the &#39;w&#39; in x86 opcodes refers to the term &quot;word&quot; in the assembler
2296 // manual, which means 16 bits, that usage is found nowhere in HotSpot code.
2297 // The term &quot;word&quot; in HotSpot means a 32- or 64-bit machine word.
2298 int MacroAssembler::load_signed_short(Register dst, Address src) {
2299   int off;
2300   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2301     // This is dubious to me since it seems safe to do a signed 16 =&gt; 64 bit
2302     // version but this is what 64bit has always done. This seems to imply
2303     // that users are only using 32bits worth.
2304     off = offset();
2305     movswl(dst, src); // movsxw
2306   } else {
2307     off = load_unsigned_short(dst, src);
2308     shll(dst, 16);
2309     sarl(dst, 16);
2310   }
2311   return off;
2312 }
2313 
2314 int MacroAssembler::load_unsigned_byte(Register dst, Address src) {
2315   // According to Intel Doc. AP-526, &quot;Zero-Extension of Short&quot;, p.16,
2316   // and &quot;3.9 Partial Register Penalties&quot;, p. 22).
2317   int off;
2318   if (LP64_ONLY(true || ) VM_Version::is_P6() || src.uses(dst)) {
2319     off = offset();
2320     movzbl(dst, src); // movzxb
2321   } else {
2322     xorl(dst, dst);
2323     off = offset();
2324     movb(dst, src);
2325   }
2326   return off;
2327 }
2328 
2329 // Note: load_unsigned_short used to be called load_unsigned_word.
2330 int MacroAssembler::load_unsigned_short(Register dst, Address src) {
2331   // According to Intel Doc. AP-526, &quot;Zero-Extension of Short&quot;, p.16,
2332   // and &quot;3.9 Partial Register Penalties&quot;, p. 22).
2333   int off;
2334   if (LP64_ONLY(true ||) VM_Version::is_P6() || src.uses(dst)) {
2335     off = offset();
2336     movzwl(dst, src); // movzxw
2337   } else {
2338     xorl(dst, dst);
2339     off = offset();
2340     movw(dst, src);
2341   }
2342   return off;
2343 }
2344 
2345 void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2) {
2346   switch (size_in_bytes) {
2347 #ifndef _LP64
2348   case  8:
2349     assert(dst2 != noreg, &quot;second dest register required&quot;);
2350     movl(dst,  src);
2351     movl(dst2, src.plus_disp(BytesPerInt));
2352     break;
2353 #else
2354   case  8:  movq(dst, src); break;
2355 #endif
2356   case  4:  movl(dst, src); break;
2357   case  2:  is_signed ? load_signed_short(dst, src) : load_unsigned_short(dst, src); break;
2358   case  1:  is_signed ? load_signed_byte( dst, src) : load_unsigned_byte( dst, src); break;
2359   default:  ShouldNotReachHere();
2360   }
2361 }
2362 
2363 void MacroAssembler::store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2) {
2364   switch (size_in_bytes) {
2365 #ifndef _LP64
2366   case  8:
2367     assert(src2 != noreg, &quot;second source register required&quot;);
2368     movl(dst,                        src);
2369     movl(dst.plus_disp(BytesPerInt), src2);
2370     break;
2371 #else
2372   case  8:  movq(dst, src); break;
2373 #endif
2374   case  4:  movl(dst, src); break;
2375   case  2:  movw(dst, src); break;
2376   case  1:  movb(dst, src); break;
2377   default:  ShouldNotReachHere();
2378   }
2379 }
2380 
2381 void MacroAssembler::mov32(AddressLiteral dst, Register src) {
2382   if (reachable(dst)) {
2383     movl(as_Address(dst), src);
2384   } else {
2385     lea(rscratch1, dst);
2386     movl(Address(rscratch1, 0), src);
2387   }
2388 }
2389 
2390 void MacroAssembler::mov32(Register dst, AddressLiteral src) {
2391   if (reachable(src)) {
2392     movl(dst, as_Address(src));
2393   } else {
2394     lea(rscratch1, src);
2395     movl(dst, Address(rscratch1, 0));
2396   }
2397 }
2398 
2399 // C++ bool manipulation
2400 
2401 void MacroAssembler::movbool(Register dst, Address src) {
2402   if(sizeof(bool) == 1)
2403     movb(dst, src);
2404   else if(sizeof(bool) == 2)
2405     movw(dst, src);
2406   else if(sizeof(bool) == 4)
2407     movl(dst, src);
2408   else
2409     // unsupported
2410     ShouldNotReachHere();
2411 }
2412 
2413 void MacroAssembler::movbool(Address dst, bool boolconst) {
2414   if(sizeof(bool) == 1)
2415     movb(dst, (int) boolconst);
2416   else if(sizeof(bool) == 2)
2417     movw(dst, (int) boolconst);
2418   else if(sizeof(bool) == 4)
2419     movl(dst, (int) boolconst);
2420   else
2421     // unsupported
2422     ShouldNotReachHere();
2423 }
2424 
2425 void MacroAssembler::movbool(Address dst, Register src) {
2426   if(sizeof(bool) == 1)
2427     movb(dst, src);
2428   else if(sizeof(bool) == 2)
2429     movw(dst, src);
2430   else if(sizeof(bool) == 4)
2431     movl(dst, src);
2432   else
2433     // unsupported
2434     ShouldNotReachHere();
2435 }
2436 
2437 void MacroAssembler::movbyte(ArrayAddress dst, int src) {
2438   movb(as_Address(dst), src);
2439 }
2440 
2441 void MacroAssembler::movdl(XMMRegister dst, AddressLiteral src) {
2442   if (reachable(src)) {
2443     movdl(dst, as_Address(src));
2444   } else {
2445     lea(rscratch1, src);
2446     movdl(dst, Address(rscratch1, 0));
2447   }
2448 }
2449 
2450 void MacroAssembler::movq(XMMRegister dst, AddressLiteral src) {
2451   if (reachable(src)) {
2452     movq(dst, as_Address(src));
2453   } else {
2454     lea(rscratch1, src);
2455     movq(dst, Address(rscratch1, 0));
2456   }
2457 }
2458 
2459 void MacroAssembler::movdbl(XMMRegister dst, AddressLiteral src) {
2460   if (reachable(src)) {
2461     if (UseXmmLoadAndClearUpper) {
2462       movsd (dst, as_Address(src));
2463     } else {
2464       movlpd(dst, as_Address(src));
2465     }
2466   } else {
2467     lea(rscratch1, src);
2468     if (UseXmmLoadAndClearUpper) {
2469       movsd (dst, Address(rscratch1, 0));
2470     } else {
2471       movlpd(dst, Address(rscratch1, 0));
2472     }
2473   }
2474 }
2475 
2476 void MacroAssembler::movflt(XMMRegister dst, AddressLiteral src) {
2477   if (reachable(src)) {
2478     movss(dst, as_Address(src));
2479   } else {
2480     lea(rscratch1, src);
2481     movss(dst, Address(rscratch1, 0));
2482   }
2483 }
2484 
2485 void MacroAssembler::movptr(Register dst, Register src) {
2486   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2487 }
2488 
2489 void MacroAssembler::movptr(Register dst, Address src) {
2490   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2491 }
2492 
2493 // src should NEVER be a real pointer. Use AddressLiteral for true pointers
2494 void MacroAssembler::movptr(Register dst, intptr_t src) {
2495   LP64_ONLY(mov64(dst, src)) NOT_LP64(movl(dst, src));
2496 }
2497 
2498 void MacroAssembler::movptr(Address dst, Register src) {
2499   LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
2500 }
2501 
2502 void MacroAssembler::movdqu(Address dst, XMMRegister src) {
2503     assert(((src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2504     Assembler::movdqu(dst, src);
2505 }
2506 
2507 void MacroAssembler::movdqu(XMMRegister dst, Address src) {
2508     assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2509     Assembler::movdqu(dst, src);
2510 }
2511 
2512 void MacroAssembler::movdqu(XMMRegister dst, XMMRegister src) {
2513     assert(((dst-&gt;encoding() &lt; 16  &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2514     Assembler::movdqu(dst, src);
2515 }
2516 
2517 void MacroAssembler::movdqu(XMMRegister dst, AddressLiteral src, Register scratchReg) {
2518   if (reachable(src)) {
2519     movdqu(dst, as_Address(src));
2520   } else {
2521     lea(scratchReg, src);
2522     movdqu(dst, Address(scratchReg, 0));
2523   }
2524 }
2525 
2526 void MacroAssembler::vmovdqu(Address dst, XMMRegister src) {
2527     assert(((src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2528     Assembler::vmovdqu(dst, src);
2529 }
2530 
2531 void MacroAssembler::vmovdqu(XMMRegister dst, Address src) {
2532     assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2533     Assembler::vmovdqu(dst, src);
2534 }
2535 
2536 void MacroAssembler::vmovdqu(XMMRegister dst, XMMRegister src) {
2537     assert(((dst-&gt;encoding() &lt; 16  &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
2538     Assembler::vmovdqu(dst, src);
2539 }
2540 
2541 void MacroAssembler::vmovdqu(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
2542   if (reachable(src)) {
2543     vmovdqu(dst, as_Address(src));
2544   }
2545   else {
2546     lea(scratch_reg, src);
2547     vmovdqu(dst, Address(scratch_reg, 0));
2548   }
2549 }
2550 
2551 void MacroAssembler::evmovdquq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch) {
2552   if (reachable(src)) {
2553     Assembler::evmovdquq(dst, as_Address(src), vector_len);
2554   } else {
2555     lea(rscratch, src);
2556     Assembler::evmovdquq(dst, Address(rscratch, 0), vector_len);
2557   }
2558 }
2559 
2560 void MacroAssembler::movdqa(XMMRegister dst, AddressLiteral src) {
2561   if (reachable(src)) {
2562     Assembler::movdqa(dst, as_Address(src));
2563   } else {
2564     lea(rscratch1, src);
2565     Assembler::movdqa(dst, Address(rscratch1, 0));
2566   }
2567 }
2568 
2569 void MacroAssembler::movsd(XMMRegister dst, AddressLiteral src) {
2570   if (reachable(src)) {
2571     Assembler::movsd(dst, as_Address(src));
2572   } else {
2573     lea(rscratch1, src);
2574     Assembler::movsd(dst, Address(rscratch1, 0));
2575   }
2576 }
2577 
2578 void MacroAssembler::movss(XMMRegister dst, AddressLiteral src) {
2579   if (reachable(src)) {
2580     Assembler::movss(dst, as_Address(src));
2581   } else {
2582     lea(rscratch1, src);
2583     Assembler::movss(dst, Address(rscratch1, 0));
2584   }
2585 }
2586 
2587 void MacroAssembler::mulsd(XMMRegister dst, AddressLiteral src) {
2588   if (reachable(src)) {
2589     Assembler::mulsd(dst, as_Address(src));
2590   } else {
2591     lea(rscratch1, src);
2592     Assembler::mulsd(dst, Address(rscratch1, 0));
2593   }
2594 }
2595 
2596 void MacroAssembler::mulss(XMMRegister dst, AddressLiteral src) {
2597   if (reachable(src)) {
2598     Assembler::mulss(dst, as_Address(src));
2599   } else {
2600     lea(rscratch1, src);
2601     Assembler::mulss(dst, Address(rscratch1, 0));
2602   }
2603 }
2604 
2605 void MacroAssembler::null_check(Register reg, int offset) {
2606   if (needs_explicit_null_check(offset)) {
2607     // provoke OS NULL exception if reg = NULL by
2608     // accessing M[reg] w/o changing any (non-CC) registers
2609     // NOTE: cmpl is plenty here to provoke a segv
2610     cmpptr(rax, Address(reg, 0));
2611     // Note: should probably use testl(rax, Address(reg, 0));
2612     //       may be shorter code (however, this version of
2613     //       testl needs to be implemented first)
2614   } else {
2615     // nothing to do, (later) access of M[reg + offset]
2616     // will provoke OS NULL exception if reg = NULL
2617   }
2618 }
2619 
<a name="5" id="anc5"></a><span class="line-added">2620 void MacroAssembler::test_klass_is_value(Register klass, Register temp_reg, Label&amp; is_value) {</span>
<span class="line-added">2621   movl(temp_reg, Address(klass, Klass::access_flags_offset()));</span>
<span class="line-added">2622   testl(temp_reg, JVM_ACC_VALUE);</span>
<span class="line-added">2623   jcc(Assembler::notZero, is_value);</span>
<span class="line-added">2624 }</span>
<span class="line-added">2625 </span>
<span class="line-added">2626 void MacroAssembler::test_klass_is_empty_value(Register klass, Register temp_reg, Label&amp; is_empty_value) {</span>
<span class="line-added">2627 #ifdef ASSERT</span>
<span class="line-added">2628   {</span>
<span class="line-added">2629     Label done_check;</span>
<span class="line-added">2630     test_klass_is_value(klass, temp_reg, done_check);</span>
<span class="line-added">2631     stop(&quot;test_klass_is_empty_value with non value klass&quot;);</span>
<span class="line-added">2632     bind(done_check);</span>
<span class="line-added">2633   }</span>
<span class="line-added">2634 #endif</span>
<span class="line-added">2635   movl(temp_reg, Address(klass, InstanceKlass::misc_flags_offset()));</span>
<span class="line-added">2636   testl(temp_reg, InstanceKlass::misc_flags_is_empty_inline_type());</span>
<span class="line-added">2637   jcc(Assembler::notZero, is_empty_value);</span>
<span class="line-added">2638 }</span>
<span class="line-added">2639 </span>
<span class="line-added">2640 void MacroAssembler::test_field_is_flattenable(Register flags, Register temp_reg, Label&amp; is_flattenable) {</span>
<span class="line-added">2641   movl(temp_reg, flags);</span>
<span class="line-added">2642   shrl(temp_reg, ConstantPoolCacheEntry::is_flattenable_field_shift);</span>
<span class="line-added">2643   andl(temp_reg, 0x1);</span>
<span class="line-added">2644   testl(temp_reg, temp_reg);</span>
<span class="line-added">2645   jcc(Assembler::notZero, is_flattenable);</span>
<span class="line-added">2646 }</span>
<span class="line-added">2647 </span>
<span class="line-added">2648 void MacroAssembler::test_field_is_not_flattenable(Register flags, Register temp_reg, Label&amp; notFlattenable) {</span>
<span class="line-added">2649   movl(temp_reg, flags);</span>
<span class="line-added">2650   shrl(temp_reg, ConstantPoolCacheEntry::is_flattenable_field_shift);</span>
<span class="line-added">2651   andl(temp_reg, 0x1);</span>
<span class="line-added">2652   testl(temp_reg, temp_reg);</span>
<span class="line-added">2653   jcc(Assembler::zero, notFlattenable);</span>
<span class="line-added">2654 }</span>
<span class="line-added">2655 </span>
<span class="line-added">2656 void MacroAssembler::test_field_is_flattened(Register flags, Register temp_reg, Label&amp; is_flattened) {</span>
<span class="line-added">2657   movl(temp_reg, flags);</span>
<span class="line-added">2658   shrl(temp_reg, ConstantPoolCacheEntry::is_flattened_field_shift);</span>
<span class="line-added">2659   andl(temp_reg, 0x1);</span>
<span class="line-added">2660   testl(temp_reg, temp_reg);</span>
<span class="line-added">2661   jcc(Assembler::notZero, is_flattened);</span>
<span class="line-added">2662 }</span>
<span class="line-added">2663 </span>
<span class="line-added">2664 void MacroAssembler::test_flattened_array_oop(Register oop, Register temp_reg,</span>
<span class="line-added">2665                                               Label&amp;is_flattened_array) {</span>
<span class="line-added">2666   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">2667   load_klass(temp_reg, oop, tmp_load_klass);</span>
<span class="line-added">2668   movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));</span>
<span class="line-added">2669   test_flattened_array_layout(temp_reg, is_flattened_array);</span>
<span class="line-added">2670 }</span>
<span class="line-added">2671 </span>
<span class="line-added">2672 void MacroAssembler::test_non_flattened_array_oop(Register oop, Register temp_reg,</span>
<span class="line-added">2673                                                   Label&amp;is_non_flattened_array) {</span>
<span class="line-added">2674   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">2675   load_klass(temp_reg, oop, tmp_load_klass);</span>
<span class="line-added">2676   movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));</span>
<span class="line-added">2677   test_non_flattened_array_layout(temp_reg, is_non_flattened_array);</span>
<span class="line-added">2678 }</span>
<span class="line-added">2679 </span>
<span class="line-added">2680 void MacroAssembler::test_null_free_array_oop(Register oop, Register temp_reg, Label&amp;is_null_free_array) {</span>
<span class="line-added">2681   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">2682   load_klass(temp_reg, oop, tmp_load_klass);</span>
<span class="line-added">2683   movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));</span>
<span class="line-added">2684   test_null_free_array_layout(temp_reg, is_null_free_array);</span>
<span class="line-added">2685 }</span>
<span class="line-added">2686 </span>
<span class="line-added">2687 void MacroAssembler::test_non_null_free_array_oop(Register oop, Register temp_reg, Label&amp;is_non_null_free_array) {</span>
<span class="line-added">2688   Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">2689   load_klass(temp_reg, oop, tmp_load_klass);</span>
<span class="line-added">2690   movl(temp_reg, Address(temp_reg, Klass::layout_helper_offset()));</span>
<span class="line-added">2691   test_non_null_free_array_layout(temp_reg, is_non_null_free_array);</span>
<span class="line-added">2692 }</span>
<span class="line-added">2693 </span>
<span class="line-added">2694 void MacroAssembler::test_flattened_array_layout(Register lh, Label&amp; is_flattened_array) {</span>
<span class="line-added">2695   testl(lh, Klass::_lh_array_tag_vt_value_bit_inplace);</span>
<span class="line-added">2696   jcc(Assembler::notZero, is_flattened_array);</span>
<span class="line-added">2697 }</span>
<span class="line-added">2698 void MacroAssembler::test_non_flattened_array_layout(Register lh, Label&amp; is_non_flattened_array) {</span>
<span class="line-added">2699   testl(lh, Klass::_lh_array_tag_vt_value_bit_inplace);</span>
<span class="line-added">2700   jcc(Assembler::zero, is_non_flattened_array);</span>
<span class="line-added">2701 }</span>
<span class="line-added">2702 </span>
<span class="line-added">2703 void MacroAssembler::test_null_free_array_layout(Register lh, Label&amp; is_null_free_array) {</span>
<span class="line-added">2704   testl(lh, Klass::_lh_null_free_bit_inplace);</span>
<span class="line-added">2705   jcc(Assembler::notZero, is_null_free_array);</span>
<span class="line-added">2706 }</span>
<span class="line-added">2707 </span>
<span class="line-added">2708 void MacroAssembler::test_non_null_free_array_layout(Register lh, Label&amp; is_non_null_free_array) {</span>
<span class="line-added">2709   testl(lh, Klass::_lh_null_free_bit_inplace);</span>
<span class="line-added">2710   jcc(Assembler::zero, is_non_null_free_array);</span>
<span class="line-added">2711 }</span>
<span class="line-added">2712 </span>
<span class="line-added">2713 </span>
2714 void MacroAssembler::os_breakpoint() {
2715   // instead of directly emitting a breakpoint, call os:breakpoint for better debugability
2716   // (e.g., MSVC can&#39;t call ps() otherwise)
2717   call(RuntimeAddress(CAST_FROM_FN_PTR(address, os::breakpoint)));
2718 }
2719 
2720 void MacroAssembler::unimplemented(const char* what) {
2721   const char* buf = NULL;
2722   {
2723     ResourceMark rm;
2724     stringStream ss;
2725     ss.print(&quot;unimplemented: %s&quot;, what);
2726     buf = code_string(ss.as_string());
2727   }
2728   stop(buf);
2729 }
2730 
2731 #ifdef _LP64
2732 #define XSTATE_BV 0x200
2733 #endif
2734 
2735 void MacroAssembler::pop_CPU_state() {
2736   pop_FPU_state();
2737   pop_IU_state();
2738 }
2739 
2740 void MacroAssembler::pop_FPU_state() {
2741 #ifndef _LP64
2742   frstor(Address(rsp, 0));
2743 #else
2744   fxrstor(Address(rsp, 0));
2745 #endif
2746   addptr(rsp, FPUStateSizeInWords * wordSize);
2747 }
2748 
2749 void MacroAssembler::pop_IU_state() {
2750   popa();
2751   LP64_ONLY(addq(rsp, 8));
2752   popf();
2753 }
2754 
2755 // Save Integer and Float state
2756 // Warning: Stack must be 16 byte aligned (64bit)
2757 void MacroAssembler::push_CPU_state() {
2758   push_IU_state();
2759   push_FPU_state();
2760 }
2761 
2762 void MacroAssembler::push_FPU_state() {
2763   subptr(rsp, FPUStateSizeInWords * wordSize);
2764 #ifndef _LP64
2765   fnsave(Address(rsp, 0));
2766   fwait();
2767 #else
2768   fxsave(Address(rsp, 0));
2769 #endif // LP64
2770 }
2771 
2772 void MacroAssembler::push_IU_state() {
2773   // Push flags first because pusha kills them
2774   pushf();
2775   // Make sure rsp stays 16-byte aligned
2776   LP64_ONLY(subq(rsp, 8));
2777   pusha();
2778 }
2779 
2780 void MacroAssembler::reset_last_Java_frame(Register java_thread, bool clear_fp) { // determine java_thread register
2781   if (!java_thread-&gt;is_valid()) {
2782     java_thread = rdi;
2783     get_thread(java_thread);
2784   }
2785   // we must set sp to zero to clear frame
2786   movptr(Address(java_thread, JavaThread::last_Java_sp_offset()), NULL_WORD);
2787   if (clear_fp) {
2788     movptr(Address(java_thread, JavaThread::last_Java_fp_offset()), NULL_WORD);
2789   }
2790 
2791   // Always clear the pc because it could have been set by make_walkable()
2792   movptr(Address(java_thread, JavaThread::last_Java_pc_offset()), NULL_WORD);
2793 
2794   vzeroupper();
2795 }
2796 
2797 void MacroAssembler::restore_rax(Register tmp) {
2798   if (tmp == noreg) pop(rax);
2799   else if (tmp != rax) mov(rax, tmp);
2800 }
2801 
2802 void MacroAssembler::round_to(Register reg, int modulus) {
2803   addptr(reg, modulus - 1);
2804   andptr(reg, -modulus);
2805 }
2806 
2807 void MacroAssembler::save_rax(Register tmp) {
2808   if (tmp == noreg) push(rax);
2809   else if (tmp != rax) mov(tmp, rax);
2810 }
2811 
2812 void MacroAssembler::safepoint_poll(Label&amp; slow_path, Register thread_reg, Register temp_reg) {
2813 #ifdef _LP64
2814   assert(thread_reg == r15_thread, &quot;should be&quot;);
2815 #else
2816   if (thread_reg == noreg) {
2817     thread_reg = temp_reg;
2818     get_thread(thread_reg);
2819   }
2820 #endif
2821   testb(Address(thread_reg, Thread::polling_page_offset()), SafepointMechanism::poll_bit());
2822   jcc(Assembler::notZero, slow_path); // handshake bit set implies poll
2823 }
2824 
2825 // Calls to C land
2826 //
2827 // When entering C land, the rbp, &amp; rsp of the last Java frame have to be recorded
2828 // in the (thread-local) JavaThread object. When leaving C land, the last Java fp
2829 // has to be reset to 0. This is required to allow proper stack traversal.
2830 void MacroAssembler::set_last_Java_frame(Register java_thread,
2831                                          Register last_java_sp,
2832                                          Register last_java_fp,
2833                                          address  last_java_pc) {
2834   vzeroupper();
2835   // determine java_thread register
2836   if (!java_thread-&gt;is_valid()) {
2837     java_thread = rdi;
2838     get_thread(java_thread);
2839   }
2840   // determine last_java_sp register
2841   if (!last_java_sp-&gt;is_valid()) {
2842     last_java_sp = rsp;
2843   }
2844 
2845   // last_java_fp is optional
2846 
2847   if (last_java_fp-&gt;is_valid()) {
2848     movptr(Address(java_thread, JavaThread::last_Java_fp_offset()), last_java_fp);
2849   }
2850 
2851   // last_java_pc is optional
2852 
2853   if (last_java_pc != NULL) {
2854     lea(Address(java_thread,
2855                  JavaThread::frame_anchor_offset() + JavaFrameAnchor::last_Java_pc_offset()),
2856         InternalAddress(last_java_pc));
2857 
2858   }
2859   movptr(Address(java_thread, JavaThread::last_Java_sp_offset()), last_java_sp);
2860 }
2861 
2862 void MacroAssembler::shlptr(Register dst, int imm8) {
2863   LP64_ONLY(shlq(dst, imm8)) NOT_LP64(shll(dst, imm8));
2864 }
2865 
2866 void MacroAssembler::shrptr(Register dst, int imm8) {
2867   LP64_ONLY(shrq(dst, imm8)) NOT_LP64(shrl(dst, imm8));
2868 }
2869 
2870 void MacroAssembler::sign_extend_byte(Register reg) {
2871   if (LP64_ONLY(true ||) (VM_Version::is_P6() &amp;&amp; reg-&gt;has_byte_register())) {
2872     movsbl(reg, reg); // movsxb
2873   } else {
2874     shll(reg, 24);
2875     sarl(reg, 24);
2876   }
2877 }
2878 
2879 void MacroAssembler::sign_extend_short(Register reg) {
2880   if (LP64_ONLY(true ||) VM_Version::is_P6()) {
2881     movswl(reg, reg); // movsxw
2882   } else {
2883     shll(reg, 16);
2884     sarl(reg, 16);
2885   }
2886 }
2887 
2888 void MacroAssembler::testl(Register dst, AddressLiteral src) {
2889   assert(reachable(src), &quot;Address should be reachable&quot;);
2890   testl(dst, as_Address(src));
2891 }
2892 
2893 void MacroAssembler::pcmpeqb(XMMRegister dst, XMMRegister src) {
2894   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2895   Assembler::pcmpeqb(dst, src);
2896 }
2897 
2898 void MacroAssembler::pcmpeqw(XMMRegister dst, XMMRegister src) {
2899   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2900   Assembler::pcmpeqw(dst, src);
2901 }
2902 
2903 void MacroAssembler::pcmpestri(XMMRegister dst, Address src, int imm8) {
2904   assert((dst-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2905   Assembler::pcmpestri(dst, src, imm8);
2906 }
2907 
2908 void MacroAssembler::pcmpestri(XMMRegister dst, XMMRegister src, int imm8) {
2909   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2910   Assembler::pcmpestri(dst, src, imm8);
2911 }
2912 
2913 void MacroAssembler::pmovzxbw(XMMRegister dst, XMMRegister src) {
2914   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2915   Assembler::pmovzxbw(dst, src);
2916 }
2917 
2918 void MacroAssembler::pmovzxbw(XMMRegister dst, Address src) {
2919   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
2920   Assembler::pmovzxbw(dst, src);
2921 }
2922 
2923 void MacroAssembler::pmovmskb(Register dst, XMMRegister src) {
2924   assert((src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2925   Assembler::pmovmskb(dst, src);
2926 }
2927 
2928 void MacroAssembler::ptest(XMMRegister dst, XMMRegister src) {
2929   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
2930   Assembler::ptest(dst, src);
2931 }
2932 
2933 void MacroAssembler::sqrtsd(XMMRegister dst, AddressLiteral src) {
2934   if (reachable(src)) {
2935     Assembler::sqrtsd(dst, as_Address(src));
2936   } else {
2937     lea(rscratch1, src);
2938     Assembler::sqrtsd(dst, Address(rscratch1, 0));
2939   }
2940 }
2941 
2942 void MacroAssembler::sqrtss(XMMRegister dst, AddressLiteral src) {
2943   if (reachable(src)) {
2944     Assembler::sqrtss(dst, as_Address(src));
2945   } else {
2946     lea(rscratch1, src);
2947     Assembler::sqrtss(dst, Address(rscratch1, 0));
2948   }
2949 }
2950 
2951 void MacroAssembler::subsd(XMMRegister dst, AddressLiteral src) {
2952   if (reachable(src)) {
2953     Assembler::subsd(dst, as_Address(src));
2954   } else {
2955     lea(rscratch1, src);
2956     Assembler::subsd(dst, Address(rscratch1, 0));
2957   }
2958 }
2959 
2960 void MacroAssembler::roundsd(XMMRegister dst, AddressLiteral src, int32_t rmode, Register scratch_reg) {
2961   if (reachable(src)) {
2962     Assembler::roundsd(dst, as_Address(src), rmode);
2963   } else {
2964     lea(scratch_reg, src);
2965     Assembler::roundsd(dst, Address(scratch_reg, 0), rmode);
2966   }
2967 }
2968 
2969 void MacroAssembler::subss(XMMRegister dst, AddressLiteral src) {
2970   if (reachable(src)) {
2971     Assembler::subss(dst, as_Address(src));
2972   } else {
2973     lea(rscratch1, src);
2974     Assembler::subss(dst, Address(rscratch1, 0));
2975   }
2976 }
2977 
2978 void MacroAssembler::ucomisd(XMMRegister dst, AddressLiteral src) {
2979   if (reachable(src)) {
2980     Assembler::ucomisd(dst, as_Address(src));
2981   } else {
2982     lea(rscratch1, src);
2983     Assembler::ucomisd(dst, Address(rscratch1, 0));
2984   }
2985 }
2986 
2987 void MacroAssembler::ucomiss(XMMRegister dst, AddressLiteral src) {
2988   if (reachable(src)) {
2989     Assembler::ucomiss(dst, as_Address(src));
2990   } else {
2991     lea(rscratch1, src);
2992     Assembler::ucomiss(dst, Address(rscratch1, 0));
2993   }
2994 }
2995 
2996 void MacroAssembler::xorpd(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
2997   // Used in sign-bit flipping with aligned address.
2998   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
2999   if (reachable(src)) {
3000     Assembler::xorpd(dst, as_Address(src));
3001   } else {
3002     lea(scratch_reg, src);
3003     Assembler::xorpd(dst, Address(scratch_reg, 0));
3004   }
3005 }
3006 
3007 void MacroAssembler::xorpd(XMMRegister dst, XMMRegister src) {
3008   if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512dq() &amp;&amp; (dst-&gt;encoding() == src-&gt;encoding())) {
3009     Assembler::vpxor(dst, dst, src, Assembler::AVX_512bit);
3010   }
3011   else {
3012     Assembler::xorpd(dst, src);
3013   }
3014 }
3015 
3016 void MacroAssembler::xorps(XMMRegister dst, XMMRegister src) {
3017   if (UseAVX &gt; 2 &amp;&amp; !VM_Version::supports_avx512dq() &amp;&amp; (dst-&gt;encoding() == src-&gt;encoding())) {
3018     Assembler::vpxor(dst, dst, src, Assembler::AVX_512bit);
3019   } else {
3020     Assembler::xorps(dst, src);
3021   }
3022 }
3023 
3024 void MacroAssembler::xorps(XMMRegister dst, AddressLiteral src, Register scratch_reg) {
3025   // Used in sign-bit flipping with aligned address.
3026   assert((UseAVX &gt; 0) || (((intptr_t)src.target() &amp; 15) == 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
3027   if (reachable(src)) {
3028     Assembler::xorps(dst, as_Address(src));
3029   } else {
3030     lea(scratch_reg, src);
3031     Assembler::xorps(dst, Address(scratch_reg, 0));
3032   }
3033 }
3034 
3035 void MacroAssembler::pshufb(XMMRegister dst, AddressLiteral src) {
3036   // Used in sign-bit flipping with aligned address.
3037   bool aligned_adr = (((intptr_t)src.target() &amp; 15) == 0);
3038   assert((UseAVX &gt; 0) || aligned_adr, &quot;SSE mode requires address alignment 16 bytes&quot;);
3039   if (reachable(src)) {
3040     Assembler::pshufb(dst, as_Address(src));
3041   } else {
3042     lea(rscratch1, src);
3043     Assembler::pshufb(dst, Address(rscratch1, 0));
3044   }
3045 }
3046 
3047 // AVX 3-operands instructions
3048 
3049 void MacroAssembler::vaddsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3050   if (reachable(src)) {
3051     vaddsd(dst, nds, as_Address(src));
3052   } else {
3053     lea(rscratch1, src);
3054     vaddsd(dst, nds, Address(rscratch1, 0));
3055   }
3056 }
3057 
3058 void MacroAssembler::vaddss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3059   if (reachable(src)) {
3060     vaddss(dst, nds, as_Address(src));
3061   } else {
3062     lea(rscratch1, src);
3063     vaddss(dst, nds, Address(rscratch1, 0));
3064   }
3065 }
3066 
3067 void MacroAssembler::vpaddd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {
3068   assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
3069   if (reachable(src)) {
3070     Assembler::vpaddd(dst, nds, as_Address(src), vector_len);
3071   } else {
3072     lea(rscratch, src);
3073     Assembler::vpaddd(dst, nds, Address(rscratch, 0), vector_len);
3074   }
3075 }
3076 
3077 void MacroAssembler::vabsss(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len) {
3078   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
3079   vandps(dst, nds, negate_field, vector_len);
3080 }
3081 
3082 void MacroAssembler::vabssd(XMMRegister dst, XMMRegister nds, XMMRegister src, AddressLiteral negate_field, int vector_len) {
3083   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
3084   vandpd(dst, nds, negate_field, vector_len);
3085 }
3086 
3087 void MacroAssembler::vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3088   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3089   Assembler::vpaddb(dst, nds, src, vector_len);
3090 }
3091 
3092 void MacroAssembler::vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3093   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3094   Assembler::vpaddb(dst, nds, src, vector_len);
3095 }
3096 
3097 void MacroAssembler::vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3098   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3099   Assembler::vpaddw(dst, nds, src, vector_len);
3100 }
3101 
3102 void MacroAssembler::vpaddw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3103   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3104   Assembler::vpaddw(dst, nds, src, vector_len);
3105 }
3106 
3107 void MacroAssembler::vpand(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3108   if (reachable(src)) {
3109     Assembler::vpand(dst, nds, as_Address(src), vector_len);
3110   } else {
3111     lea(scratch_reg, src);
3112     Assembler::vpand(dst, nds, Address(scratch_reg, 0), vector_len);
3113   }
3114 }
3115 
3116 void MacroAssembler::vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len) {
3117   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3118   Assembler::vpbroadcastw(dst, src, vector_len);
3119 }
3120 
3121 void MacroAssembler::vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3122   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3123   Assembler::vpcmpeqb(dst, nds, src, vector_len);
3124 }
3125 
3126 void MacroAssembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3127   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3128   Assembler::vpcmpeqw(dst, nds, src, vector_len);
3129 }
3130 
3131 void MacroAssembler::vpmovzxbw(XMMRegister dst, Address src, int vector_len) {
3132   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3133   Assembler::vpmovzxbw(dst, src, vector_len);
3134 }
3135 
3136 void MacroAssembler::vpmovmskb(Register dst, XMMRegister src) {
3137   assert((src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
3138   Assembler::vpmovmskb(dst, src);
3139 }
3140 
3141 void MacroAssembler::vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3142   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3143   Assembler::vpmullw(dst, nds, src, vector_len);
3144 }
3145 
3146 void MacroAssembler::vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3147   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3148   Assembler::vpmullw(dst, nds, src, vector_len);
3149 }
3150 
3151 void MacroAssembler::vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3152   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3153   Assembler::vpsubb(dst, nds, src, vector_len);
3154 }
3155 
3156 void MacroAssembler::vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3157   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3158   Assembler::vpsubb(dst, nds, src, vector_len);
3159 }
3160 
3161 void MacroAssembler::vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
3162   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3163   Assembler::vpsubw(dst, nds, src, vector_len);
3164 }
3165 
3166 void MacroAssembler::vpsubw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
3167   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3168   Assembler::vpsubw(dst, nds, src, vector_len);
3169 }
3170 
3171 void MacroAssembler::vpsraw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3172   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3173   Assembler::vpsraw(dst, nds, shift, vector_len);
3174 }
3175 
3176 void MacroAssembler::vpsraw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3177   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3178   Assembler::vpsraw(dst, nds, shift, vector_len);
3179 }
3180 
3181 void MacroAssembler::evpsraq(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3182   assert(UseAVX &gt; 2,&quot;&quot;);
3183   if (!VM_Version::supports_avx512vl() &amp;&amp; vector_len &lt; 2) {
3184      vector_len = 2;
3185   }
3186   Assembler::evpsraq(dst, nds, shift, vector_len);
3187 }
3188 
3189 void MacroAssembler::evpsraq(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3190   assert(UseAVX &gt; 2,&quot;&quot;);
3191   if (!VM_Version::supports_avx512vl() &amp;&amp; vector_len &lt; 2) {
3192      vector_len = 2;
3193   }
3194   Assembler::evpsraq(dst, nds, shift, vector_len);
3195 }
3196 
3197 void MacroAssembler::vpsrlw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3198   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3199   Assembler::vpsrlw(dst, nds, shift, vector_len);
3200 }
3201 
3202 void MacroAssembler::vpsrlw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3203   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3204   Assembler::vpsrlw(dst, nds, shift, vector_len);
3205 }
3206 
3207 void MacroAssembler::vpsllw(XMMRegister dst, XMMRegister nds, XMMRegister shift, int vector_len) {
3208   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; shift-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3209   Assembler::vpsllw(dst, nds, shift, vector_len);
3210 }
3211 
3212 void MacroAssembler::vpsllw(XMMRegister dst, XMMRegister nds, int shift, int vector_len) {
3213   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3214   Assembler::vpsllw(dst, nds, shift, vector_len);
3215 }
3216 
3217 void MacroAssembler::vptest(XMMRegister dst, XMMRegister src) {
3218   assert((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16),&quot;XMM register should be 0-15&quot;);
3219   Assembler::vptest(dst, src);
3220 }
3221 
3222 void MacroAssembler::punpcklbw(XMMRegister dst, XMMRegister src) {
3223   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3224   Assembler::punpcklbw(dst, src);
3225 }
3226 
3227 void MacroAssembler::pshufd(XMMRegister dst, Address src, int mode) {
3228   assert(((dst-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vl()),&quot;XMM register should be 0-15&quot;);
3229   Assembler::pshufd(dst, src, mode);
3230 }
3231 
3232 void MacroAssembler::pshuflw(XMMRegister dst, XMMRegister src, int mode) {
3233   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; src-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vlbw()),&quot;XMM register should be 0-15&quot;);
3234   Assembler::pshuflw(dst, src, mode);
3235 }
3236 
3237 void MacroAssembler::vandpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3238   if (reachable(src)) {
3239     vandpd(dst, nds, as_Address(src), vector_len);
3240   } else {
3241     lea(scratch_reg, src);
3242     vandpd(dst, nds, Address(scratch_reg, 0), vector_len);
3243   }
3244 }
3245 
3246 void MacroAssembler::vandps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3247   if (reachable(src)) {
3248     vandps(dst, nds, as_Address(src), vector_len);
3249   } else {
3250     lea(scratch_reg, src);
3251     vandps(dst, nds, Address(scratch_reg, 0), vector_len);
3252   }
3253 }
3254 
3255 void MacroAssembler::vdivsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3256   if (reachable(src)) {
3257     vdivsd(dst, nds, as_Address(src));
3258   } else {
3259     lea(rscratch1, src);
3260     vdivsd(dst, nds, Address(rscratch1, 0));
3261   }
3262 }
3263 
3264 void MacroAssembler::vdivss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3265   if (reachable(src)) {
3266     vdivss(dst, nds, as_Address(src));
3267   } else {
3268     lea(rscratch1, src);
3269     vdivss(dst, nds, Address(rscratch1, 0));
3270   }
3271 }
3272 
3273 void MacroAssembler::vmulsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3274   if (reachable(src)) {
3275     vmulsd(dst, nds, as_Address(src));
3276   } else {
3277     lea(rscratch1, src);
3278     vmulsd(dst, nds, Address(rscratch1, 0));
3279   }
3280 }
3281 
3282 void MacroAssembler::vmulss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3283   if (reachable(src)) {
3284     vmulss(dst, nds, as_Address(src));
3285   } else {
3286     lea(rscratch1, src);
3287     vmulss(dst, nds, Address(rscratch1, 0));
3288   }
3289 }
3290 
3291 void MacroAssembler::vsubsd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3292   if (reachable(src)) {
3293     vsubsd(dst, nds, as_Address(src));
3294   } else {
3295     lea(rscratch1, src);
3296     vsubsd(dst, nds, Address(rscratch1, 0));
3297   }
3298 }
3299 
3300 void MacroAssembler::vsubss(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3301   if (reachable(src)) {
3302     vsubss(dst, nds, as_Address(src));
3303   } else {
3304     lea(rscratch1, src);
3305     vsubss(dst, nds, Address(rscratch1, 0));
3306   }
3307 }
3308 
3309 void MacroAssembler::vnegatess(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3310   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
3311   vxorps(dst, nds, src, Assembler::AVX_128bit);
3312 }
3313 
3314 void MacroAssembler::vnegatesd(XMMRegister dst, XMMRegister nds, AddressLiteral src) {
3315   assert(((dst-&gt;encoding() &lt; 16 &amp;&amp; nds-&gt;encoding() &lt; 16) || VM_Version::supports_avx512vldq()),&quot;XMM register should be 0-15&quot;);
3316   vxorpd(dst, nds, src, Assembler::AVX_128bit);
3317 }
3318 
3319 void MacroAssembler::vxorpd(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3320   if (reachable(src)) {
3321     vxorpd(dst, nds, as_Address(src), vector_len);
3322   } else {
3323     lea(scratch_reg, src);
3324     vxorpd(dst, nds, Address(scratch_reg, 0), vector_len);
3325   }
3326 }
3327 
3328 void MacroAssembler::vxorps(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3329   if (reachable(src)) {
3330     vxorps(dst, nds, as_Address(src), vector_len);
3331   } else {
3332     lea(scratch_reg, src);
3333     vxorps(dst, nds, Address(scratch_reg, 0), vector_len);
3334   }
3335 }
3336 
3337 void MacroAssembler::vpxor(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register scratch_reg) {
3338   if (UseAVX &gt; 1 || (vector_len &lt; 1)) {
3339     if (reachable(src)) {
3340       Assembler::vpxor(dst, nds, as_Address(src), vector_len);
3341     } else {
3342       lea(scratch_reg, src);
3343       Assembler::vpxor(dst, nds, Address(scratch_reg, 0), vector_len);
3344     }
3345   }
3346   else {
3347     MacroAssembler::vxorpd(dst, nds, src, vector_len, scratch_reg);
3348   }
3349 }
3350 
3351 //-------------------------------------------------------------------------------------------
3352 
3353 void MacroAssembler::clear_jweak_tag(Register possibly_jweak) {
3354   const int32_t inverted_jweak_mask = ~static_cast&lt;int32_t&gt;(JNIHandles::weak_tag_mask);
3355   STATIC_ASSERT(inverted_jweak_mask == -2); // otherwise check this code
3356   // The inverted mask is sign-extended
3357   andptr(possibly_jweak, inverted_jweak_mask);
3358 }
3359 
3360 void MacroAssembler::resolve_jobject(Register value,
3361                                      Register thread,
3362                                      Register tmp) {
3363   assert_different_registers(value, thread, tmp);
3364   Label done, not_weak;
3365   testptr(value, value);
3366   jcc(Assembler::zero, done);                // Use NULL as-is.
3367   testptr(value, JNIHandles::weak_tag_mask); // Test for jweak tag.
3368   jcc(Assembler::zero, not_weak);
3369   // Resolve jweak.
3370   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
3371                  value, Address(value, -JNIHandles::weak_tag_value), tmp, thread);
3372   verify_oop(value);
3373   jmp(done);
3374   bind(not_weak);
3375   // Resolve (untagged) jobject.
3376   access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp, thread);
3377   verify_oop(value);
3378   bind(done);
3379 }
3380 
3381 void MacroAssembler::subptr(Register dst, int32_t imm32) {
3382   LP64_ONLY(subq(dst, imm32)) NOT_LP64(subl(dst, imm32));
3383 }
3384 
3385 // Force generation of a 4 byte immediate value even if it fits into 8bit
3386 void MacroAssembler::subptr_imm32(Register dst, int32_t imm32) {
3387   LP64_ONLY(subq_imm32(dst, imm32)) NOT_LP64(subl_imm32(dst, imm32));
3388 }
3389 
3390 void MacroAssembler::subptr(Register dst, Register src) {
3391   LP64_ONLY(subq(dst, src)) NOT_LP64(subl(dst, src));
3392 }
3393 
3394 // C++ bool manipulation
3395 void MacroAssembler::testbool(Register dst) {
3396   if(sizeof(bool) == 1)
3397     testb(dst, 0xff);
3398   else if(sizeof(bool) == 2) {
3399     // testw implementation needed for two byte bools
3400     ShouldNotReachHere();
3401   } else if(sizeof(bool) == 4)
3402     testl(dst, dst);
3403   else
3404     // unsupported
3405     ShouldNotReachHere();
3406 }
3407 
3408 void MacroAssembler::testptr(Register dst, Register src) {
3409   LP64_ONLY(testq(dst, src)) NOT_LP64(testl(dst, src));
3410 }
3411 
<a name="6" id="anc6"></a><span class="line-added">3412 // Object / value buffer allocation...</span>
<span class="line-added">3413 //</span>
<span class="line-added">3414 // Kills klass and rsi on LP64</span>
<span class="line-added">3415 void MacroAssembler::allocate_instance(Register klass, Register new_obj,</span>
<span class="line-added">3416                                        Register t1, Register t2,</span>
<span class="line-added">3417                                        bool clear_fields, Label&amp; alloc_failed)</span>
<span class="line-added">3418 {</span>
<span class="line-added">3419   Label done, initialize_header, initialize_object, slow_case, slow_case_no_pop;</span>
<span class="line-added">3420   Register layout_size = t1;</span>
<span class="line-added">3421   assert(new_obj == rax, &quot;needs to be rax, according to barrier asm eden_allocate&quot;);</span>
<span class="line-added">3422   assert_different_registers(klass, new_obj, t1, t2);</span>
<span class="line-added">3423 </span>
<span class="line-added">3424 #ifdef ASSERT</span>
<span class="line-added">3425   {</span>
<span class="line-added">3426     Label L;</span>
<span class="line-added">3427     cmpb(Address(klass, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);</span>
<span class="line-added">3428     jcc(Assembler::equal, L);</span>
<span class="line-added">3429     stop(&quot;klass not initialized&quot;);</span>
<span class="line-added">3430     bind(L);</span>
<span class="line-added">3431   }</span>
<span class="line-added">3432 #endif</span>
<span class="line-added">3433 </span>
<span class="line-added">3434   // get instance_size in InstanceKlass (scaled to a count of bytes)</span>
<span class="line-added">3435   movl(layout_size, Address(klass, Klass::layout_helper_offset()));</span>
<span class="line-added">3436   // test to see if it has a finalizer or is malformed in some way</span>
<span class="line-added">3437   testl(layout_size, Klass::_lh_instance_slow_path_bit);</span>
<span class="line-added">3438   jcc(Assembler::notZero, slow_case_no_pop);</span>
<span class="line-added">3439 </span>
<span class="line-added">3440   // Allocate the instance:</span>
<span class="line-added">3441   //  If TLAB is enabled:</span>
<span class="line-added">3442   //    Try to allocate in the TLAB.</span>
<span class="line-added">3443   //    If fails, go to the slow path.</span>
<span class="line-added">3444   //  Else If inline contiguous allocations are enabled:</span>
<span class="line-added">3445   //    Try to allocate in eden.</span>
<span class="line-added">3446   //    If fails due to heap end, go to slow path.</span>
<span class="line-added">3447   //</span>
<span class="line-added">3448   //  If TLAB is enabled OR inline contiguous is enabled:</span>
<span class="line-added">3449   //    Initialize the allocation.</span>
<span class="line-added">3450   //    Exit.</span>
<span class="line-added">3451   //</span>
<span class="line-added">3452   //  Go to slow path.</span>
<span class="line-added">3453   const bool allow_shared_alloc =</span>
<span class="line-added">3454     Universe::heap()-&gt;supports_inline_contig_alloc();</span>
<span class="line-added">3455 </span>
<span class="line-added">3456   push(klass);</span>
<span class="line-added">3457   const Register thread = LP64_ONLY(r15_thread) NOT_LP64(klass);</span>
<span class="line-added">3458 #ifndef _LP64</span>
<span class="line-added">3459   if (UseTLAB || allow_shared_alloc) {</span>
<span class="line-added">3460     get_thread(thread);</span>
<span class="line-added">3461   }</span>
<span class="line-added">3462 #endif // _LP64</span>
<span class="line-added">3463 </span>
<span class="line-added">3464   if (UseTLAB) {</span>
<span class="line-added">3465     tlab_allocate(thread, new_obj, layout_size, 0, klass, t2, slow_case);</span>
<span class="line-added">3466     if (ZeroTLAB || (!clear_fields)) {</span>
<span class="line-added">3467       // the fields have been already cleared</span>
<span class="line-added">3468       jmp(initialize_header);</span>
<span class="line-added">3469     } else {</span>
<span class="line-added">3470       // initialize both the header and fields</span>
<span class="line-added">3471       jmp(initialize_object);</span>
<span class="line-added">3472     }</span>
<span class="line-added">3473   } else {</span>
<span class="line-added">3474     // Allocation in the shared Eden, if allowed.</span>
<span class="line-added">3475     //</span>
<span class="line-added">3476     eden_allocate(thread, new_obj, layout_size, 0, t2, slow_case);</span>
<span class="line-added">3477   }</span>
<span class="line-added">3478 </span>
<span class="line-added">3479   // If UseTLAB or allow_shared_alloc are true, the object is created above and</span>
<span class="line-added">3480   // there is an initialize need. Otherwise, skip and go to the slow path.</span>
<span class="line-added">3481   if (UseTLAB || allow_shared_alloc) {</span>
<span class="line-added">3482     if (clear_fields) {</span>
<span class="line-added">3483       // The object is initialized before the header.  If the object size is</span>
<span class="line-added">3484       // zero, go directly to the header initialization.</span>
<span class="line-added">3485       bind(initialize_object);</span>
<span class="line-added">3486       decrement(layout_size, sizeof(oopDesc));</span>
<span class="line-added">3487       jcc(Assembler::zero, initialize_header);</span>
<span class="line-added">3488 </span>
<span class="line-added">3489       // Initialize topmost object field, divide size by 8, check if odd and</span>
<span class="line-added">3490       // test if zero.</span>
<span class="line-added">3491       Register zero = klass;</span>
<span class="line-added">3492       xorl(zero, zero);    // use zero reg to clear memory (shorter code)</span>
<span class="line-added">3493       shrl(layout_size, LogBytesPerLong); // divide by 2*oopSize and set carry flag if odd</span>
<span class="line-added">3494 </span>
<span class="line-added">3495   #ifdef ASSERT</span>
<span class="line-added">3496       // make sure instance_size was multiple of 8</span>
<span class="line-added">3497       Label L;</span>
<span class="line-added">3498       // Ignore partial flag stall after shrl() since it is debug VM</span>
<span class="line-added">3499       jcc(Assembler::carryClear, L);</span>
<span class="line-added">3500       stop(&quot;object size is not multiple of 2 - adjust this code&quot;);</span>
<span class="line-added">3501       bind(L);</span>
<span class="line-added">3502       // must be &gt; 0, no extra check needed here</span>
<span class="line-added">3503   #endif</span>
<span class="line-added">3504 </span>
<span class="line-added">3505       // initialize remaining object fields: instance_size was a multiple of 8</span>
<span class="line-added">3506       {</span>
<span class="line-added">3507         Label loop;</span>
<span class="line-added">3508         bind(loop);</span>
<span class="line-added">3509         movptr(Address(new_obj, layout_size, Address::times_8, sizeof(oopDesc) - 1*oopSize), zero);</span>
<span class="line-added">3510         NOT_LP64(movptr(Address(new_obj, layout_size, Address::times_8, sizeof(oopDesc) - 2*oopSize), zero));</span>
<span class="line-added">3511         decrement(layout_size);</span>
<span class="line-added">3512         jcc(Assembler::notZero, loop);</span>
<span class="line-added">3513       }</span>
<span class="line-added">3514     } // clear_fields</span>
<span class="line-added">3515 </span>
<span class="line-added">3516     // initialize object header only.</span>
<span class="line-added">3517     bind(initialize_header);</span>
<span class="line-added">3518     pop(klass);</span>
<span class="line-added">3519     Register mark_word = t2;</span>
<span class="line-added">3520     movptr(mark_word, Address(klass, Klass::prototype_header_offset()));</span>
<span class="line-added">3521     movptr(Address(new_obj, oopDesc::mark_offset_in_bytes ()), mark_word);</span>
<span class="line-added">3522 #ifdef _LP64</span>
<span class="line-added">3523     xorl(rsi, rsi);                 // use zero reg to clear memory (shorter code)</span>
<span class="line-added">3524     store_klass_gap(new_obj, rsi);  // zero klass gap for compressed oops</span>
<span class="line-added">3525 #endif</span>
<span class="line-added">3526     movptr(t2, klass);         // preserve klass</span>
<span class="line-added">3527     Register tmp_store_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">3528     store_klass(new_obj, t2, tmp_store_klass);  // src klass reg is potentially compressed</span>
<span class="line-added">3529 </span>
<span class="line-added">3530     jmp(done);</span>
<span class="line-added">3531   }</span>
<span class="line-added">3532 </span>
<span class="line-added">3533   bind(slow_case);</span>
<span class="line-added">3534   pop(klass);</span>
<span class="line-added">3535   bind(slow_case_no_pop);</span>
<span class="line-added">3536   jmp(alloc_failed);</span>
<span class="line-added">3537 </span>
<span class="line-added">3538   bind(done);</span>
<span class="line-added">3539 }</span>
<span class="line-added">3540 </span>
3541 // Defines obj, preserves var_size_in_bytes, okay for t2 == var_size_in_bytes.
3542 void MacroAssembler::tlab_allocate(Register thread, Register obj,
3543                                    Register var_size_in_bytes,
3544                                    int con_size_in_bytes,
3545                                    Register t1,
3546                                    Register t2,
3547                                    Label&amp; slow_case) {
3548   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3549   bs-&gt;tlab_allocate(this, thread, obj, var_size_in_bytes, con_size_in_bytes, t1, t2, slow_case);
3550 }
3551 
3552 // Defines obj, preserves var_size_in_bytes
3553 void MacroAssembler::eden_allocate(Register thread, Register obj,
3554                                    Register var_size_in_bytes,
3555                                    int con_size_in_bytes,
3556                                    Register t1,
3557                                    Label&amp; slow_case) {
3558   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
3559   bs-&gt;eden_allocate(this, thread, obj, var_size_in_bytes, con_size_in_bytes, t1, slow_case);
3560 }
3561 
3562 // Preserves the contents of address, destroys the contents length_in_bytes and temp.
3563 void MacroAssembler::zero_memory(Register address, Register length_in_bytes, int offset_in_bytes, Register temp) {
3564   assert(address != length_in_bytes &amp;&amp; address != temp &amp;&amp; temp != length_in_bytes, &quot;registers must be different&quot;);
3565   assert((offset_in_bytes &amp; (BytesPerWord - 1)) == 0, &quot;offset must be a multiple of BytesPerWord&quot;);
3566   Label done;
3567 
3568   testptr(length_in_bytes, length_in_bytes);
3569   jcc(Assembler::zero, done);
3570 
3571   // initialize topmost word, divide index by 2, check if odd and test if zero
3572   // note: for the remaining code to work, index must be a multiple of BytesPerWord
3573 #ifdef ASSERT
3574   {
3575     Label L;
3576     testptr(length_in_bytes, BytesPerWord - 1);
3577     jcc(Assembler::zero, L);
3578     stop(&quot;length must be a multiple of BytesPerWord&quot;);
3579     bind(L);
3580   }
3581 #endif
3582   Register index = length_in_bytes;
3583   xorptr(temp, temp);    // use _zero reg to clear memory (shorter code)
3584   if (UseIncDec) {
3585     shrptr(index, 3);  // divide by 8/16 and set carry flag if bit 2 was set
3586   } else {
3587     shrptr(index, 2);  // use 2 instructions to avoid partial flag stall
3588     shrptr(index, 1);
3589   }
3590 #ifndef _LP64
3591   // index could have not been a multiple of 8 (i.e., bit 2 was set)
3592   {
3593     Label even;
3594     // note: if index was a multiple of 8, then it cannot
3595     //       be 0 now otherwise it must have been 0 before
3596     //       =&gt; if it is even, we don&#39;t need to check for 0 again
3597     jcc(Assembler::carryClear, even);
3598     // clear topmost word (no jump would be needed if conditional assignment worked here)
3599     movptr(Address(address, index, Address::times_8, offset_in_bytes - 0*BytesPerWord), temp);
3600     // index could be 0 now, must check again
3601     jcc(Assembler::zero, done);
3602     bind(even);
3603   }
3604 #endif // !_LP64
3605   // initialize remaining object fields: index is a multiple of 2 now
3606   {
3607     Label loop;
3608     bind(loop);
3609     movptr(Address(address, index, Address::times_8, offset_in_bytes - 1*BytesPerWord), temp);
3610     NOT_LP64(movptr(Address(address, index, Address::times_8, offset_in_bytes - 2*BytesPerWord), temp);)
3611     decrement(index);
3612     jcc(Assembler::notZero, loop);
3613   }
3614 
3615   bind(done);
3616 }
3617 
<a name="7" id="anc7"></a><span class="line-added">3618 void MacroAssembler::get_value_field_klass(Register klass, Register index, Register value_klass) {</span>
<span class="line-added">3619   movptr(value_klass, Address(klass, InstanceKlass::value_field_klasses_offset()));</span>
<span class="line-added">3620 #ifdef ASSERT</span>
<span class="line-added">3621   {</span>
<span class="line-added">3622     Label done;</span>
<span class="line-added">3623     cmpptr(value_klass, 0);</span>
<span class="line-added">3624     jcc(Assembler::notEqual, done);</span>
<span class="line-added">3625     stop(&quot;get_value_field_klass contains no inline klasses&quot;);</span>
<span class="line-added">3626     bind(done);</span>
<span class="line-added">3627   }</span>
<span class="line-added">3628 #endif</span>
<span class="line-added">3629   movptr(value_klass, Address(value_klass, index, Address::times_ptr));</span>
<span class="line-added">3630 }</span>
<span class="line-added">3631 </span>
<span class="line-added">3632 void MacroAssembler::get_default_value_oop(Register value_klass, Register temp_reg, Register obj) {</span>
<span class="line-added">3633 #ifdef ASSERT</span>
<span class="line-added">3634   {</span>
<span class="line-added">3635     Label done_check;</span>
<span class="line-added">3636     test_klass_is_value(value_klass, temp_reg, done_check);</span>
<span class="line-added">3637     stop(&quot;get_default_value_oop from non-value klass&quot;);</span>
<span class="line-added">3638     bind(done_check);</span>
<span class="line-added">3639   }</span>
<span class="line-added">3640 #endif</span>
<span class="line-added">3641   Register offset = temp_reg;</span>
<span class="line-added">3642   // Getting the offset of the pre-allocated default value</span>
<span class="line-added">3643   movptr(offset, Address(value_klass, in_bytes(InstanceKlass::adr_valueklass_fixed_block_offset())));</span>
<span class="line-added">3644   movl(offset, Address(offset, in_bytes(ValueKlass::default_value_offset_offset())));</span>
<span class="line-added">3645 </span>
<span class="line-added">3646   // Getting the mirror</span>
<span class="line-added">3647   movptr(obj, Address(value_klass, in_bytes(Klass::java_mirror_offset())));</span>
<span class="line-added">3648   resolve_oop_handle(obj, value_klass);</span>
<span class="line-added">3649 </span>
<span class="line-added">3650   // Getting the pre-allocated default value from the mirror</span>
<span class="line-added">3651   Address field(obj, offset, Address::times_1);</span>
<span class="line-added">3652   load_heap_oop(obj, field);</span>
<span class="line-added">3653 }</span>
<span class="line-added">3654 </span>
<span class="line-added">3655 void MacroAssembler::get_empty_value_oop(Register value_klass, Register temp_reg, Register obj) {</span>
<span class="line-added">3656 #ifdef ASSERT</span>
<span class="line-added">3657   {</span>
<span class="line-added">3658     Label done_check;</span>
<span class="line-added">3659     test_klass_is_empty_value(value_klass, temp_reg, done_check);</span>
<span class="line-added">3660     stop(&quot;get_empty_value from non-empty value klass&quot;);</span>
<span class="line-added">3661     bind(done_check);</span>
<span class="line-added">3662   }</span>
<span class="line-added">3663 #endif</span>
<span class="line-added">3664   get_default_value_oop(value_klass, temp_reg, obj);</span>
<span class="line-added">3665 }</span>
<span class="line-added">3666 </span>
<span class="line-added">3667 </span>
3668 // Look up the method for a megamorphic invokeinterface call.
3669 // The target method is determined by &lt;intf_klass, itable_index&gt;.
3670 // The receiver klass is in recv_klass.
3671 // On success, the result will be in method_result, and execution falls through.
3672 // On failure, execution transfers to the given label.
3673 void MacroAssembler::lookup_interface_method(Register recv_klass,
3674                                              Register intf_klass,
3675                                              RegisterOrConstant itable_index,
3676                                              Register method_result,
3677                                              Register scan_temp,
3678                                              Label&amp; L_no_such_interface,
3679                                              bool return_method) {
3680   assert_different_registers(recv_klass, intf_klass, scan_temp);
3681   assert_different_registers(method_result, intf_klass, scan_temp);
3682   assert(recv_klass != method_result || !return_method,
3683          &quot;recv_klass can be destroyed when method isn&#39;t needed&quot;);
3684 
3685   assert(itable_index.is_constant() || itable_index.as_register() == method_result,
3686          &quot;caller must use same register for non-constant itable index as for method&quot;);
3687 
3688   // Compute start of first itableOffsetEntry (which is at the end of the vtable)
3689   int vtable_base = in_bytes(Klass::vtable_start_offset());
3690   int itentry_off = itableMethodEntry::method_offset_in_bytes();
3691   int scan_step   = itableOffsetEntry::size() * wordSize;
3692   int vte_size    = vtableEntry::size_in_bytes();
3693   Address::ScaleFactor times_vte_scale = Address::times_ptr;
3694   assert(vte_size == wordSize, &quot;else adjust times_vte_scale&quot;);
3695 
3696   movl(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));
3697 
3698   // %%% Could store the aligned, prescaled offset in the klassoop.
3699   lea(scan_temp, Address(recv_klass, scan_temp, times_vte_scale, vtable_base));
3700 
3701   if (return_method) {
3702     // Adjust recv_klass by scaled itable_index, so we can free itable_index.
3703     assert(itableMethodEntry::size() * wordSize == wordSize, &quot;adjust the scaling in the code below&quot;);
3704     lea(recv_klass, Address(recv_klass, itable_index, Address::times_ptr, itentry_off));
3705   }
3706 
3707   // for (scan = klass-&gt;itable(); scan-&gt;interface() != NULL; scan += scan_step) {
3708   //   if (scan-&gt;interface() == intf) {
3709   //     result = (klass + scan-&gt;offset() + itable_index);
3710   //   }
3711   // }
3712   Label search, found_method;
3713 
3714   for (int peel = 1; peel &gt;= 0; peel--) {
3715     movptr(method_result, Address(scan_temp, itableOffsetEntry::interface_offset_in_bytes()));
3716     cmpptr(intf_klass, method_result);
3717 
3718     if (peel) {
3719       jccb(Assembler::equal, found_method);
3720     } else {
3721       jccb(Assembler::notEqual, search);
3722       // (invert the test to fall through to found_method...)
3723     }
3724 
3725     if (!peel)  break;
3726 
3727     bind(search);
3728 
3729     // Check that the previous entry is non-null.  A null entry means that
3730     // the receiver class doesn&#39;t implement the interface, and wasn&#39;t the
3731     // same as when the caller was compiled.
3732     testptr(method_result, method_result);
3733     jcc(Assembler::zero, L_no_such_interface);
3734     addptr(scan_temp, scan_step);
3735   }
3736 
3737   bind(found_method);
3738 
3739   if (return_method) {
3740     // Got a hit.
3741     movl(scan_temp, Address(scan_temp, itableOffsetEntry::offset_offset_in_bytes()));
3742     movptr(method_result, Address(recv_klass, scan_temp, Address::times_1));
3743   }
3744 }
3745 
3746 
3747 // virtual method calling
3748 void MacroAssembler::lookup_virtual_method(Register recv_klass,
3749                                            RegisterOrConstant vtable_index,
3750                                            Register method_result) {
3751   const int base = in_bytes(Klass::vtable_start_offset());
3752   assert(vtableEntry::size() * wordSize == wordSize, &quot;else adjust the scaling in the code below&quot;);
3753   Address vtable_entry_addr(recv_klass,
3754                             vtable_index, Address::times_ptr,
3755                             base + vtableEntry::method_offset_in_bytes());
3756   movptr(method_result, vtable_entry_addr);
3757 }
3758 
3759 
3760 void MacroAssembler::check_klass_subtype(Register sub_klass,
3761                            Register super_klass,
3762                            Register temp_reg,
3763                            Label&amp; L_success) {
3764   Label L_failure;
3765   check_klass_subtype_fast_path(sub_klass, super_klass, temp_reg,        &amp;L_success, &amp;L_failure, NULL);
3766   check_klass_subtype_slow_path(sub_klass, super_klass, temp_reg, noreg, &amp;L_success, NULL);
3767   bind(L_failure);
3768 }
3769 
3770 
3771 void MacroAssembler::check_klass_subtype_fast_path(Register sub_klass,
3772                                                    Register super_klass,
3773                                                    Register temp_reg,
3774                                                    Label* L_success,
3775                                                    Label* L_failure,
3776                                                    Label* L_slow_path,
3777                                         RegisterOrConstant super_check_offset) {
3778   assert_different_registers(sub_klass, super_klass, temp_reg);
3779   bool must_load_sco = (super_check_offset.constant_or_zero() == -1);
3780   if (super_check_offset.is_register()) {
3781     assert_different_registers(sub_klass, super_klass,
3782                                super_check_offset.as_register());
3783   } else if (must_load_sco) {
3784     assert(temp_reg != noreg, &quot;supply either a temp or a register offset&quot;);
3785   }
3786 
3787   Label L_fallthrough;
3788   int label_nulls = 0;
3789   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
3790   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
3791   if (L_slow_path == NULL) { L_slow_path = &amp;L_fallthrough; label_nulls++; }
3792   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
3793 
3794   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
3795   int sco_offset = in_bytes(Klass::super_check_offset_offset());
3796   Address super_check_offset_addr(super_klass, sco_offset);
3797 
3798   // Hacked jcc, which &quot;knows&quot; that L_fallthrough, at least, is in
3799   // range of a jccb.  If this routine grows larger, reconsider at
3800   // least some of these.
3801 #define local_jcc(assembler_cond, label)                                \
3802   if (&amp;(label) == &amp;L_fallthrough)  jccb(assembler_cond, label);         \
3803   else                             jcc( assembler_cond, label) /*omit semi*/
3804 
3805   // Hacked jmp, which may only be used just before L_fallthrough.
3806 #define final_jmp(label)                                                \
3807   if (&amp;(label) == &amp;L_fallthrough) { /*do nothing*/ }                    \
3808   else                            jmp(label)                /*omit semi*/
3809 
3810   // If the pointers are equal, we are done (e.g., String[] elements).
3811   // This self-check enables sharing of secondary supertype arrays among
3812   // non-primary types such as array-of-interface.  Otherwise, each such
3813   // type would need its own customized SSA.
3814   // We move this check to the front of the fast path because many
3815   // type checks are in fact trivially successful in this manner,
3816   // so we get a nicely predicted branch right at the start of the check.
3817   cmpptr(sub_klass, super_klass);
3818   local_jcc(Assembler::equal, *L_success);
3819 
3820   // Check the supertype display:
3821   if (must_load_sco) {
3822     // Positive movl does right thing on LP64.
3823     movl(temp_reg, super_check_offset_addr);
3824     super_check_offset = RegisterOrConstant(temp_reg);
3825   }
3826   Address super_check_addr(sub_klass, super_check_offset, Address::times_1, 0);
3827   cmpptr(super_klass, super_check_addr); // load displayed supertype
3828 
3829   // This check has worked decisively for primary supers.
3830   // Secondary supers are sought in the super_cache (&#39;super_cache_addr&#39;).
3831   // (Secondary supers are interfaces and very deeply nested subtypes.)
3832   // This works in the same check above because of a tricky aliasing
3833   // between the super_cache and the primary super display elements.
3834   // (The &#39;super_check_addr&#39; can address either, as the case requires.)
3835   // Note that the cache is updated below if it does not help us find
3836   // what we need immediately.
3837   // So if it was a primary super, we can just fail immediately.
3838   // Otherwise, it&#39;s the slow path for us (no success at this point).
3839 
3840   if (super_check_offset.is_register()) {
3841     local_jcc(Assembler::equal, *L_success);
3842     cmpl(super_check_offset.as_register(), sc_offset);
3843     if (L_failure == &amp;L_fallthrough) {
3844       local_jcc(Assembler::equal, *L_slow_path);
3845     } else {
3846       local_jcc(Assembler::notEqual, *L_failure);
3847       final_jmp(*L_slow_path);
3848     }
3849   } else if (super_check_offset.as_constant() == sc_offset) {
3850     // Need a slow path; fast failure is impossible.
3851     if (L_slow_path == &amp;L_fallthrough) {
3852       local_jcc(Assembler::equal, *L_success);
3853     } else {
3854       local_jcc(Assembler::notEqual, *L_slow_path);
3855       final_jmp(*L_success);
3856     }
3857   } else {
3858     // No slow path; it&#39;s a fast decision.
3859     if (L_failure == &amp;L_fallthrough) {
3860       local_jcc(Assembler::equal, *L_success);
3861     } else {
3862       local_jcc(Assembler::notEqual, *L_failure);
3863       final_jmp(*L_success);
3864     }
3865   }
3866 
3867   bind(L_fallthrough);
3868 
3869 #undef local_jcc
3870 #undef final_jmp
3871 }
3872 
3873 
3874 void MacroAssembler::check_klass_subtype_slow_path(Register sub_klass,
3875                                                    Register super_klass,
3876                                                    Register temp_reg,
3877                                                    Register temp2_reg,
3878                                                    Label* L_success,
3879                                                    Label* L_failure,
3880                                                    bool set_cond_codes) {
3881   assert_different_registers(sub_klass, super_klass, temp_reg);
3882   if (temp2_reg != noreg)
3883     assert_different_registers(sub_klass, super_klass, temp_reg, temp2_reg);
3884 #define IS_A_TEMP(reg) ((reg) == temp_reg || (reg) == temp2_reg)
3885 
3886   Label L_fallthrough;
3887   int label_nulls = 0;
3888   if (L_success == NULL)   { L_success   = &amp;L_fallthrough; label_nulls++; }
3889   if (L_failure == NULL)   { L_failure   = &amp;L_fallthrough; label_nulls++; }
3890   assert(label_nulls &lt;= 1, &quot;at most one NULL in the batch&quot;);
3891 
3892   // a couple of useful fields in sub_klass:
3893   int ss_offset = in_bytes(Klass::secondary_supers_offset());
3894   int sc_offset = in_bytes(Klass::secondary_super_cache_offset());
3895   Address secondary_supers_addr(sub_klass, ss_offset);
3896   Address super_cache_addr(     sub_klass, sc_offset);
3897 
3898   // Do a linear scan of the secondary super-klass chain.
3899   // This code is rarely used, so simplicity is a virtue here.
3900   // The repne_scan instruction uses fixed registers, which we must spill.
3901   // Don&#39;t worry too much about pre-existing connections with the input regs.
3902 
3903   assert(sub_klass != rax, &quot;killed reg&quot;); // killed by mov(rax, super)
3904   assert(sub_klass != rcx, &quot;killed reg&quot;); // killed by lea(rcx, &amp;pst_counter)
3905 
3906   // Get super_klass value into rax (even if it was in rdi or rcx).
3907   bool pushed_rax = false, pushed_rcx = false, pushed_rdi = false;
3908   if (super_klass != rax || UseCompressedOops) {
3909     if (!IS_A_TEMP(rax)) { push(rax); pushed_rax = true; }
3910     mov(rax, super_klass);
3911   }
3912   if (!IS_A_TEMP(rcx)) { push(rcx); pushed_rcx = true; }
3913   if (!IS_A_TEMP(rdi)) { push(rdi); pushed_rdi = true; }
3914 
3915 #ifndef PRODUCT
3916   int* pst_counter = &amp;SharedRuntime::_partial_subtype_ctr;
3917   ExternalAddress pst_counter_addr((address) pst_counter);
3918   NOT_LP64(  incrementl(pst_counter_addr) );
3919   LP64_ONLY( lea(rcx, pst_counter_addr) );
3920   LP64_ONLY( incrementl(Address(rcx, 0)) );
3921 #endif //PRODUCT
3922 
3923   // We will consult the secondary-super array.
3924   movptr(rdi, secondary_supers_addr);
3925   // Load the array length.  (Positive movl does right thing on LP64.)
3926   movl(rcx, Address(rdi, Array&lt;Klass*&gt;::length_offset_in_bytes()));
3927   // Skip to start of data.
3928   addptr(rdi, Array&lt;Klass*&gt;::base_offset_in_bytes());
3929 
3930   // Scan RCX words at [RDI] for an occurrence of RAX.
3931   // Set NZ/Z based on last compare.
3932   // Z flag value will not be set by &#39;repne&#39; if RCX == 0 since &#39;repne&#39; does
3933   // not change flags (only scas instruction which is repeated sets flags).
3934   // Set Z = 0 (not equal) before &#39;repne&#39; to indicate that class was not found.
3935 
3936     testptr(rax,rax); // Set Z = 0
3937     repne_scan();
3938 
3939   // Unspill the temp. registers:
3940   if (pushed_rdi)  pop(rdi);
3941   if (pushed_rcx)  pop(rcx);
3942   if (pushed_rax)  pop(rax);
3943 
3944   if (set_cond_codes) {
3945     // Special hack for the AD files:  rdi is guaranteed non-zero.
3946     assert(!pushed_rdi, &quot;rdi must be left non-NULL&quot;);
3947     // Also, the condition codes are properly set Z/NZ on succeed/failure.
3948   }
3949 
3950   if (L_failure == &amp;L_fallthrough)
3951         jccb(Assembler::notEqual, *L_failure);
3952   else  jcc(Assembler::notEqual, *L_failure);
3953 
3954   // Success.  Cache the super we found and proceed in triumph.
3955   movptr(super_cache_addr, super_klass);
3956 
3957   if (L_success != &amp;L_fallthrough) {
3958     jmp(*L_success);
3959   }
3960 
3961 #undef IS_A_TEMP
3962 
3963   bind(L_fallthrough);
3964 }
3965 
3966 void MacroAssembler::clinit_barrier(Register klass, Register thread, Label* L_fast_path, Label* L_slow_path) {
3967   assert(L_fast_path != NULL || L_slow_path != NULL, &quot;at least one is required&quot;);
3968 
3969   Label L_fallthrough;
3970   if (L_fast_path == NULL) {
3971     L_fast_path = &amp;L_fallthrough;
3972   } else if (L_slow_path == NULL) {
3973     L_slow_path = &amp;L_fallthrough;
3974   }
3975 
3976   // Fast path check: class is fully initialized
3977   cmpb(Address(klass, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);
3978   jcc(Assembler::equal, *L_fast_path);
3979 
3980   // Fast path check: current thread is initializer thread
3981   cmpptr(thread, Address(klass, InstanceKlass::init_thread_offset()));
3982   if (L_slow_path == &amp;L_fallthrough) {
3983     jcc(Assembler::equal, *L_fast_path);
3984     bind(*L_slow_path);
3985   } else if (L_fast_path == &amp;L_fallthrough) {
3986     jcc(Assembler::notEqual, *L_slow_path);
3987     bind(*L_fast_path);
3988   } else {
3989     Unimplemented();
3990   }
3991 }
3992 
3993 void MacroAssembler::cmov32(Condition cc, Register dst, Address src) {
3994   if (VM_Version::supports_cmov()) {
3995     cmovl(cc, dst, src);
3996   } else {
3997     Label L;
3998     jccb(negate_condition(cc), L);
3999     movl(dst, src);
4000     bind(L);
4001   }
4002 }
4003 
4004 void MacroAssembler::cmov32(Condition cc, Register dst, Register src) {
4005   if (VM_Version::supports_cmov()) {
4006     cmovl(cc, dst, src);
4007   } else {
4008     Label L;
4009     jccb(negate_condition(cc), L);
4010     movl(dst, src);
4011     bind(L);
4012   }
4013 }
4014 
4015 void MacroAssembler::_verify_oop(Register reg, const char* s, const char* file, int line) {
<a name="8" id="anc8"></a><span class="line-modified">4016   if (!VerifyOops || VerifyAdapterSharing) {</span>
<span class="line-added">4017     // Below address of the code string confuses VerifyAdapterSharing</span>
<span class="line-added">4018     // because it may differ between otherwise equivalent adapters.</span>
<span class="line-added">4019     return;</span>
<span class="line-added">4020   }</span>
4021 
4022   // Pass register number to verify_oop_subroutine
4023   const char* b = NULL;
4024   {
4025     ResourceMark rm;
4026     stringStream ss;
4027     ss.print(&quot;verify_oop: %s: %s (%s:%d)&quot;, reg-&gt;name(), s, file, line);
4028     b = code_string(ss.as_string());
4029   }
4030   BLOCK_COMMENT(&quot;verify_oop {&quot;);
4031 #ifdef _LP64
4032   push(rscratch1);                    // save r10, trashed by movptr()
4033 #endif
4034   push(rax);                          // save rax,
4035   push(reg);                          // pass register argument
4036   ExternalAddress buffer((address) b);
4037   // avoid using pushptr, as it modifies scratch registers
4038   // and our contract is not to modify anything
4039   movptr(rax, buffer.addr());
4040   push(rax);
4041   // call indirectly to solve generation ordering problem
4042   movptr(rax, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
4043   call(rax);
4044   // Caller pops the arguments (oop, message) and restores rax, r10
4045   BLOCK_COMMENT(&quot;} verify_oop&quot;);
4046 }
4047 
4048 void MacroAssembler::vallones(XMMRegister dst, int vector_len) {
4049   if (UseAVX &gt; 2 &amp;&amp; (vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl())) {
4050     vpternlogd(dst, 0xFF, dst, dst, vector_len);
4051   } else {
4052     assert(UseAVX &gt; 0, &quot;&quot;);
4053     vpcmpeqb(dst, dst, dst, vector_len);
4054   }
4055 }
4056 
4057 RegisterOrConstant MacroAssembler::delayed_value_impl(intptr_t* delayed_value_addr,
4058                                                       Register tmp,
4059                                                       int offset) {
4060   intptr_t value = *delayed_value_addr;
4061   if (value != 0)
4062     return RegisterOrConstant(value + offset);
4063 
4064   // load indirectly to solve generation ordering problem
4065   movptr(tmp, ExternalAddress((address) delayed_value_addr));
4066 
4067 #ifdef ASSERT
4068   { Label L;
4069     testptr(tmp, tmp);
4070     if (WizardMode) {
4071       const char* buf = NULL;
4072       {
4073         ResourceMark rm;
4074         stringStream ss;
4075         ss.print(&quot;DelayedValue=&quot; INTPTR_FORMAT, delayed_value_addr[1]);
4076         buf = code_string(ss.as_string());
4077       }
4078       jcc(Assembler::notZero, L);
4079       STOP(buf);
4080     } else {
4081       jccb(Assembler::notZero, L);
4082       hlt();
4083     }
4084     bind(L);
4085   }
4086 #endif
4087 
4088   if (offset != 0)
4089     addptr(tmp, offset);
4090 
4091   return RegisterOrConstant(tmp);
4092 }
4093 
4094 
4095 Address MacroAssembler::argument_address(RegisterOrConstant arg_slot,
4096                                          int extra_slot_offset) {
4097   // cf. TemplateTable::prepare_invoke(), if (load_receiver).
4098   int stackElementSize = Interpreter::stackElementSize;
4099   int offset = Interpreter::expr_offset_in_bytes(extra_slot_offset+0);
4100 #ifdef ASSERT
4101   int offset1 = Interpreter::expr_offset_in_bytes(extra_slot_offset+1);
4102   assert(offset1 - offset == stackElementSize, &quot;correct arithmetic&quot;);
4103 #endif
4104   Register             scale_reg    = noreg;
4105   Address::ScaleFactor scale_factor = Address::no_scale;
4106   if (arg_slot.is_constant()) {
4107     offset += arg_slot.as_constant() * stackElementSize;
4108   } else {
4109     scale_reg    = arg_slot.as_register();
4110     scale_factor = Address::times(stackElementSize);
4111   }
4112   offset += wordSize;           // return PC is on stack
4113   return Address(rsp, scale_reg, scale_factor, offset);
4114 }
4115 
4116 
4117 void MacroAssembler::_verify_oop_addr(Address addr, const char* s, const char* file, int line) {
<a name="9" id="anc9"></a><span class="line-modified">4118   if (!VerifyOops || VerifyAdapterSharing) {</span>
<span class="line-added">4119     // Below address of the code string confuses VerifyAdapterSharing</span>
<span class="line-added">4120     // because it may differ between otherwise equivalent adapters.</span>
<span class="line-added">4121     return;</span>
<span class="line-added">4122   }</span>
4123 
4124   // Address adjust(addr.base(), addr.index(), addr.scale(), addr.disp() + BytesPerWord);
4125   // Pass register number to verify_oop_subroutine
4126   const char* b = NULL;
4127   {
4128     ResourceMark rm;
4129     stringStream ss;
4130     ss.print(&quot;verify_oop_addr: %s (%s:%d)&quot;, s, file, line);
4131     b = code_string(ss.as_string());
4132   }
4133 #ifdef _LP64
4134   push(rscratch1);                    // save r10, trashed by movptr()
4135 #endif
4136   push(rax);                          // save rax,
4137   // addr may contain rsp so we will have to adjust it based on the push
4138   // we just did (and on 64 bit we do two pushes)
4139   // NOTE: 64bit seemed to have had a bug in that it did movq(addr, rax); which
4140   // stores rax into addr which is backwards of what was intended.
4141   if (addr.uses(rsp)) {
4142     lea(rax, addr);
4143     pushptr(Address(rax, LP64_ONLY(2 *) BytesPerWord));
4144   } else {
4145     pushptr(addr);
4146   }
4147 
4148   ExternalAddress buffer((address) b);
4149   // pass msg argument
4150   // avoid using pushptr, as it modifies scratch registers
4151   // and our contract is not to modify anything
4152   movptr(rax, buffer.addr());
4153   push(rax);
4154 
4155   // call indirectly to solve generation ordering problem
4156   movptr(rax, ExternalAddress(StubRoutines::verify_oop_subroutine_entry_address()));
4157   call(rax);
4158   // Caller pops the arguments (addr, message) and restores rax, r10.
4159 }
4160 
4161 void MacroAssembler::verify_tlab() {
4162 #ifdef ASSERT
4163   if (UseTLAB &amp;&amp; VerifyOops) {
4164     Label next, ok;
4165     Register t1 = rsi;
4166     Register thread_reg = NOT_LP64(rbx) LP64_ONLY(r15_thread);
4167 
4168     push(t1);
4169     NOT_LP64(push(thread_reg));
4170     NOT_LP64(get_thread(thread_reg));
4171 
4172     movptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_top_offset())));
4173     cmpptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_start_offset())));
4174     jcc(Assembler::aboveEqual, next);
4175     STOP(&quot;assert(top &gt;= start)&quot;);
4176     should_not_reach_here();
4177 
4178     bind(next);
4179     movptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_end_offset())));
4180     cmpptr(t1, Address(thread_reg, in_bytes(JavaThread::tlab_top_offset())));
4181     jcc(Assembler::aboveEqual, ok);
4182     STOP(&quot;assert(top &lt;= end)&quot;);
4183     should_not_reach_here();
4184 
4185     bind(ok);
4186     NOT_LP64(pop(thread_reg));
4187     pop(t1);
4188   }
4189 #endif
4190 }
4191 
4192 class ControlWord {
4193  public:
4194   int32_t _value;
4195 
4196   int  rounding_control() const        { return  (_value &gt;&gt; 10) &amp; 3      ; }
4197   int  precision_control() const       { return  (_value &gt;&gt;  8) &amp; 3      ; }
4198   bool precision() const               { return ((_value &gt;&gt;  5) &amp; 1) != 0; }
4199   bool underflow() const               { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
4200   bool overflow() const                { return ((_value &gt;&gt;  3) &amp; 1) != 0; }
4201   bool zero_divide() const             { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
4202   bool denormalized() const            { return ((_value &gt;&gt;  1) &amp; 1) != 0; }
4203   bool invalid() const                 { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
4204 
4205   void print() const {
4206     // rounding control
4207     const char* rc;
4208     switch (rounding_control()) {
4209       case 0: rc = &quot;round near&quot;; break;
4210       case 1: rc = &quot;round down&quot;; break;
4211       case 2: rc = &quot;round up  &quot;; break;
4212       case 3: rc = &quot;chop      &quot;; break;
4213     };
4214     // precision control
4215     const char* pc;
4216     switch (precision_control()) {
4217       case 0: pc = &quot;24 bits &quot;; break;
4218       case 1: pc = &quot;reserved&quot;; break;
4219       case 2: pc = &quot;53 bits &quot;; break;
4220       case 3: pc = &quot;64 bits &quot;; break;
4221     };
4222     // flags
4223     char f[9];
4224     f[0] = &#39; &#39;;
4225     f[1] = &#39; &#39;;
4226     f[2] = (precision   ()) ? &#39;P&#39; : &#39;p&#39;;
4227     f[3] = (underflow   ()) ? &#39;U&#39; : &#39;u&#39;;
4228     f[4] = (overflow    ()) ? &#39;O&#39; : &#39;o&#39;;
4229     f[5] = (zero_divide ()) ? &#39;Z&#39; : &#39;z&#39;;
4230     f[6] = (denormalized()) ? &#39;D&#39; : &#39;d&#39;;
4231     f[7] = (invalid     ()) ? &#39;I&#39; : &#39;i&#39;;
4232     f[8] = &#39;\x0&#39;;
4233     // output
4234     printf(&quot;%04x  masks = %s, %s, %s&quot;, _value &amp; 0xFFFF, f, rc, pc);
4235   }
4236 
4237 };
4238 
4239 class StatusWord {
4240  public:
4241   int32_t _value;
4242 
4243   bool busy() const                    { return ((_value &gt;&gt; 15) &amp; 1) != 0; }
4244   bool C3() const                      { return ((_value &gt;&gt; 14) &amp; 1) != 0; }
4245   bool C2() const                      { return ((_value &gt;&gt; 10) &amp; 1) != 0; }
4246   bool C1() const                      { return ((_value &gt;&gt;  9) &amp; 1) != 0; }
4247   bool C0() const                      { return ((_value &gt;&gt;  8) &amp; 1) != 0; }
4248   int  top() const                     { return  (_value &gt;&gt; 11) &amp; 7      ; }
4249   bool error_status() const            { return ((_value &gt;&gt;  7) &amp; 1) != 0; }
4250   bool stack_fault() const             { return ((_value &gt;&gt;  6) &amp; 1) != 0; }
4251   bool precision() const               { return ((_value &gt;&gt;  5) &amp; 1) != 0; }
4252   bool underflow() const               { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
4253   bool overflow() const                { return ((_value &gt;&gt;  3) &amp; 1) != 0; }
4254   bool zero_divide() const             { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
4255   bool denormalized() const            { return ((_value &gt;&gt;  1) &amp; 1) != 0; }
4256   bool invalid() const                 { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
4257 
4258   void print() const {
4259     // condition codes
4260     char c[5];
4261     c[0] = (C3()) ? &#39;3&#39; : &#39;-&#39;;
4262     c[1] = (C2()) ? &#39;2&#39; : &#39;-&#39;;
4263     c[2] = (C1()) ? &#39;1&#39; : &#39;-&#39;;
4264     c[3] = (C0()) ? &#39;0&#39; : &#39;-&#39;;
4265     c[4] = &#39;\x0&#39;;
4266     // flags
4267     char f[9];
4268     f[0] = (error_status()) ? &#39;E&#39; : &#39;-&#39;;
4269     f[1] = (stack_fault ()) ? &#39;S&#39; : &#39;-&#39;;
4270     f[2] = (precision   ()) ? &#39;P&#39; : &#39;-&#39;;
4271     f[3] = (underflow   ()) ? &#39;U&#39; : &#39;-&#39;;
4272     f[4] = (overflow    ()) ? &#39;O&#39; : &#39;-&#39;;
4273     f[5] = (zero_divide ()) ? &#39;Z&#39; : &#39;-&#39;;
4274     f[6] = (denormalized()) ? &#39;D&#39; : &#39;-&#39;;
4275     f[7] = (invalid     ()) ? &#39;I&#39; : &#39;-&#39;;
4276     f[8] = &#39;\x0&#39;;
4277     // output
4278     printf(&quot;%04x  flags = %s, cc =  %s, top = %d&quot;, _value &amp; 0xFFFF, f, c, top());
4279   }
4280 
4281 };
4282 
4283 class TagWord {
4284  public:
4285   int32_t _value;
4286 
4287   int tag_at(int i) const              { return (_value &gt;&gt; (i*2)) &amp; 3; }
4288 
4289   void print() const {
4290     printf(&quot;%04x&quot;, _value &amp; 0xFFFF);
4291   }
4292 
4293 };
4294 
4295 class FPU_Register {
4296  public:
4297   int32_t _m0;
4298   int32_t _m1;
4299   int16_t _ex;
4300 
4301   bool is_indefinite() const           {
4302     return _ex == -1 &amp;&amp; _m1 == (int32_t)0xC0000000 &amp;&amp; _m0 == 0;
4303   }
4304 
4305   void print() const {
4306     char  sign = (_ex &lt; 0) ? &#39;-&#39; : &#39;+&#39;;
4307     const char* kind = (_ex == 0x7FFF || _ex == (int16_t)-1) ? &quot;NaN&quot; : &quot;   &quot;;
4308     printf(&quot;%c%04hx.%08x%08x  %s&quot;, sign, _ex, _m1, _m0, kind);
4309   };
4310 
4311 };
4312 
4313 class FPU_State {
4314  public:
4315   enum {
4316     register_size       = 10,
4317     number_of_registers =  8,
4318     register_mask       =  7
4319   };
4320 
4321   ControlWord  _control_word;
4322   StatusWord   _status_word;
4323   TagWord      _tag_word;
4324   int32_t      _error_offset;
4325   int32_t      _error_selector;
4326   int32_t      _data_offset;
4327   int32_t      _data_selector;
4328   int8_t       _register[register_size * number_of_registers];
4329 
4330   int tag_for_st(int i) const          { return _tag_word.tag_at((_status_word.top() + i) &amp; register_mask); }
4331   FPU_Register* st(int i) const        { return (FPU_Register*)&amp;_register[register_size * i]; }
4332 
4333   const char* tag_as_string(int tag) const {
4334     switch (tag) {
4335       case 0: return &quot;valid&quot;;
4336       case 1: return &quot;zero&quot;;
4337       case 2: return &quot;special&quot;;
4338       case 3: return &quot;empty&quot;;
4339     }
4340     ShouldNotReachHere();
4341     return NULL;
4342   }
4343 
4344   void print() const {
4345     // print computation registers
4346     { int t = _status_word.top();
4347       for (int i = 0; i &lt; number_of_registers; i++) {
4348         int j = (i - t) &amp; register_mask;
4349         printf(&quot;%c r%d = ST%d = &quot;, (j == 0 ? &#39;*&#39; : &#39; &#39;), i, j);
4350         st(j)-&gt;print();
4351         printf(&quot; %s\n&quot;, tag_as_string(_tag_word.tag_at(i)));
4352       }
4353     }
4354     printf(&quot;\n&quot;);
4355     // print control registers
4356     printf(&quot;ctrl = &quot;); _control_word.print(); printf(&quot;\n&quot;);
4357     printf(&quot;stat = &quot;); _status_word .print(); printf(&quot;\n&quot;);
4358     printf(&quot;tags = &quot;); _tag_word    .print(); printf(&quot;\n&quot;);
4359   }
4360 
4361 };
4362 
4363 class Flag_Register {
4364  public:
4365   int32_t _value;
4366 
4367   bool overflow() const                { return ((_value &gt;&gt; 11) &amp; 1) != 0; }
4368   bool direction() const               { return ((_value &gt;&gt; 10) &amp; 1) != 0; }
4369   bool sign() const                    { return ((_value &gt;&gt;  7) &amp; 1) != 0; }
4370   bool zero() const                    { return ((_value &gt;&gt;  6) &amp; 1) != 0; }
4371   bool auxiliary_carry() const         { return ((_value &gt;&gt;  4) &amp; 1) != 0; }
4372   bool parity() const                  { return ((_value &gt;&gt;  2) &amp; 1) != 0; }
4373   bool carry() const                   { return ((_value &gt;&gt;  0) &amp; 1) != 0; }
4374 
4375   void print() const {
4376     // flags
4377     char f[8];
4378     f[0] = (overflow       ()) ? &#39;O&#39; : &#39;-&#39;;
4379     f[1] = (direction      ()) ? &#39;D&#39; : &#39;-&#39;;
4380     f[2] = (sign           ()) ? &#39;S&#39; : &#39;-&#39;;
4381     f[3] = (zero           ()) ? &#39;Z&#39; : &#39;-&#39;;
4382     f[4] = (auxiliary_carry()) ? &#39;A&#39; : &#39;-&#39;;
4383     f[5] = (parity         ()) ? &#39;P&#39; : &#39;-&#39;;
4384     f[6] = (carry          ()) ? &#39;C&#39; : &#39;-&#39;;
4385     f[7] = &#39;\x0&#39;;
4386     // output
4387     printf(&quot;%08x  flags = %s&quot;, _value, f);
4388   }
4389 
4390 };
4391 
4392 class IU_Register {
4393  public:
4394   int32_t _value;
4395 
4396   void print() const {
4397     printf(&quot;%08x  %11d&quot;, _value, _value);
4398   }
4399 
4400 };
4401 
4402 class IU_State {
4403  public:
4404   Flag_Register _eflags;
4405   IU_Register   _rdi;
4406   IU_Register   _rsi;
4407   IU_Register   _rbp;
4408   IU_Register   _rsp;
4409   IU_Register   _rbx;
4410   IU_Register   _rdx;
4411   IU_Register   _rcx;
4412   IU_Register   _rax;
4413 
4414   void print() const {
4415     // computation registers
4416     printf(&quot;rax,  = &quot;); _rax.print(); printf(&quot;\n&quot;);
4417     printf(&quot;rbx,  = &quot;); _rbx.print(); printf(&quot;\n&quot;);
4418     printf(&quot;rcx  = &quot;); _rcx.print(); printf(&quot;\n&quot;);
4419     printf(&quot;rdx  = &quot;); _rdx.print(); printf(&quot;\n&quot;);
4420     printf(&quot;rdi  = &quot;); _rdi.print(); printf(&quot;\n&quot;);
4421     printf(&quot;rsi  = &quot;); _rsi.print(); printf(&quot;\n&quot;);
4422     printf(&quot;rbp,  = &quot;); _rbp.print(); printf(&quot;\n&quot;);
4423     printf(&quot;rsp  = &quot;); _rsp.print(); printf(&quot;\n&quot;);
4424     printf(&quot;\n&quot;);
4425     // control registers
4426     printf(&quot;flgs = &quot;); _eflags.print(); printf(&quot;\n&quot;);
4427   }
4428 };
4429 
4430 
4431 class CPU_State {
4432  public:
4433   FPU_State _fpu_state;
4434   IU_State  _iu_state;
4435 
4436   void print() const {
4437     printf(&quot;--------------------------------------------------\n&quot;);
4438     _iu_state .print();
4439     printf(&quot;\n&quot;);
4440     _fpu_state.print();
4441     printf(&quot;--------------------------------------------------\n&quot;);
4442   }
4443 
4444 };
4445 
4446 
4447 static void _print_CPU_state(CPU_State* state) {
4448   state-&gt;print();
4449 };
4450 
4451 
4452 void MacroAssembler::print_CPU_state() {
4453   push_CPU_state();
4454   push(rsp);                // pass CPU state
4455   call(RuntimeAddress(CAST_FROM_FN_PTR(address, _print_CPU_state)));
4456   addptr(rsp, wordSize);       // discard argument
4457   pop_CPU_state();
4458 }
4459 
4460 
4461 #ifndef _LP64
4462 static bool _verify_FPU(int stack_depth, char* s, CPU_State* state) {
4463   static int counter = 0;
4464   FPU_State* fs = &amp;state-&gt;_fpu_state;
4465   counter++;
4466   // For leaf calls, only verify that the top few elements remain empty.
4467   // We only need 1 empty at the top for C2 code.
4468   if( stack_depth &lt; 0 ) {
4469     if( fs-&gt;tag_for_st(7) != 3 ) {
4470       printf(&quot;FPR7 not empty\n&quot;);
4471       state-&gt;print();
4472       assert(false, &quot;error&quot;);
4473       return false;
4474     }
4475     return true;                // All other stack states do not matter
4476   }
4477 
4478   assert((fs-&gt;_control_word._value &amp; 0xffff) == StubRoutines::_fpu_cntrl_wrd_std,
4479          &quot;bad FPU control word&quot;);
4480 
4481   // compute stack depth
4482   int i = 0;
4483   while (i &lt; FPU_State::number_of_registers &amp;&amp; fs-&gt;tag_for_st(i)  &lt; 3) i++;
4484   int d = i;
4485   while (i &lt; FPU_State::number_of_registers &amp;&amp; fs-&gt;tag_for_st(i) == 3) i++;
4486   // verify findings
4487   if (i != FPU_State::number_of_registers) {
4488     // stack not contiguous
4489     printf(&quot;%s: stack not contiguous at ST%d\n&quot;, s, i);
4490     state-&gt;print();
4491     assert(false, &quot;error&quot;);
4492     return false;
4493   }
4494   // check if computed stack depth corresponds to expected stack depth
4495   if (stack_depth &lt; 0) {
4496     // expected stack depth is -stack_depth or less
4497     if (d &gt; -stack_depth) {
4498       // too many elements on the stack
4499       printf(&quot;%s: &lt;= %d stack elements expected but found %d\n&quot;, s, -stack_depth, d);
4500       state-&gt;print();
4501       assert(false, &quot;error&quot;);
4502       return false;
4503     }
4504   } else {
4505     // expected stack depth is stack_depth
4506     if (d != stack_depth) {
4507       // wrong stack depth
4508       printf(&quot;%s: %d stack elements expected but found %d\n&quot;, s, stack_depth, d);
4509       state-&gt;print();
4510       assert(false, &quot;error&quot;);
4511       return false;
4512     }
4513   }
4514   // everything is cool
4515   return true;
4516 }
4517 
4518 void MacroAssembler::verify_FPU(int stack_depth, const char* s) {
4519   if (!VerifyFPU) return;
4520   push_CPU_state();
4521   push(rsp);                // pass CPU state
4522   ExternalAddress msg((address) s);
4523   // pass message string s
4524   pushptr(msg.addr());
4525   push(stack_depth);        // pass stack depth
4526   call(RuntimeAddress(CAST_FROM_FN_PTR(address, _verify_FPU)));
4527   addptr(rsp, 3 * wordSize);   // discard arguments
4528   // check for error
4529   { Label L;
4530     testl(rax, rax);
4531     jcc(Assembler::notZero, L);
4532     int3();                  // break if error condition
4533     bind(L);
4534   }
4535   pop_CPU_state();
4536 }
4537 #endif // _LP64
4538 
4539 void MacroAssembler::restore_cpu_control_state_after_jni() {
4540   // Either restore the MXCSR register after returning from the JNI Call
4541   // or verify that it wasn&#39;t changed (with -Xcheck:jni flag).
4542   if (VM_Version::supports_sse()) {
4543     if (RestoreMXCSROnJNICalls) {
4544       ldmxcsr(ExternalAddress(StubRoutines::addr_mxcsr_std()));
4545     } else if (CheckJNICalls) {
4546       call(RuntimeAddress(StubRoutines::x86::verify_mxcsr_entry()));
4547     }
4548   }
4549   // Clear upper bits of YMM registers to avoid SSE &lt;-&gt; AVX transition penalty.
4550   vzeroupper();
4551   // Reset k1 to 0xffff.
4552 
4553 #ifdef COMPILER2
4554   if (PostLoopMultiversioning &amp;&amp; VM_Version::supports_evex()) {
4555     push(rcx);
4556     movl(rcx, 0xffff);
4557     kmovwl(k1, rcx);
4558     pop(rcx);
4559   }
4560 #endif // COMPILER2
4561 
4562 #ifndef _LP64
4563   // Either restore the x87 floating pointer control word after returning
4564   // from the JNI call or verify that it wasn&#39;t changed.
4565   if (CheckJNICalls) {
4566     call(RuntimeAddress(StubRoutines::x86::verify_fpu_cntrl_wrd_entry()));
4567   }
4568 #endif // _LP64
4569 }
4570 
4571 // ((OopHandle)result).resolve();
4572 void MacroAssembler::resolve_oop_handle(Register result, Register tmp) {
4573   assert_different_registers(result, tmp);
4574 
4575   // Only 64 bit platforms support GCs that require a tmp register
4576   // Only IN_HEAP loads require a thread_tmp register
4577   // OopHandle::resolve is an indirection like jobject.
4578   access_load_at(T_OBJECT, IN_NATIVE,
4579                  result, Address(result, 0), tmp, /*tmp_thread*/noreg);
4580 }
4581 
4582 // ((WeakHandle)result).resolve();
4583 void MacroAssembler::resolve_weak_handle(Register rresult, Register rtmp) {
4584   assert_different_registers(rresult, rtmp);
4585   Label resolved;
4586 
4587   // A null weak handle resolves to null.
4588   cmpptr(rresult, 0);
4589   jcc(Assembler::equal, resolved);
4590 
4591   // Only 64 bit platforms support GCs that require a tmp register
4592   // Only IN_HEAP loads require a thread_tmp register
4593   // WeakHandle::resolve is an indirection like jweak.
4594   access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,
4595                  rresult, Address(rresult, 0), rtmp, /*tmp_thread*/noreg);
4596   bind(resolved);
4597 }
4598 
4599 void MacroAssembler::load_mirror(Register mirror, Register method, Register tmp) {
4600   // get mirror
4601   const int mirror_offset = in_bytes(Klass::java_mirror_offset());
4602   load_method_holder(mirror, method);
4603   movptr(mirror, Address(mirror, mirror_offset));
4604   resolve_oop_handle(mirror, tmp);
4605 }
4606 
4607 void MacroAssembler::load_method_holder_cld(Register rresult, Register rmethod) {
4608   load_method_holder(rresult, rmethod);
4609   movptr(rresult, Address(rresult, InstanceKlass::class_loader_data_offset()));
4610 }
4611 
4612 void MacroAssembler::load_method_holder(Register holder, Register method) {
4613   movptr(holder, Address(method, Method::const_offset()));                      // ConstMethod*
4614   movptr(holder, Address(holder, ConstMethod::constants_offset()));             // ConstantPool*
4615   movptr(holder, Address(holder, ConstantPool::pool_holder_offset_in_bytes())); // InstanceKlass*
4616 }
4617 
<a name="10" id="anc10"></a><span class="line-added">4618 void MacroAssembler::load_metadata(Register dst, Register src) {</span>
<span class="line-added">4619   if (UseCompressedClassPointers) {</span>
<span class="line-added">4620     movl(dst, Address(src, oopDesc::klass_offset_in_bytes()));</span>
<span class="line-added">4621   } else {</span>
<span class="line-added">4622     movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));</span>
<span class="line-added">4623   }</span>
<span class="line-added">4624 }</span>
<span class="line-added">4625 </span>
4626 void MacroAssembler::load_klass(Register dst, Register src, Register tmp) {
4627   assert_different_registers(src, tmp);
4628   assert_different_registers(dst, tmp);
4629 #ifdef _LP64
4630   if (UseCompressedClassPointers) {
4631     movl(dst, Address(src, oopDesc::klass_offset_in_bytes()));
4632     decode_klass_not_null(dst, tmp);
4633   } else
4634 #endif
<a name="11" id="anc11"></a><span class="line-modified">4635   movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));</span>
4636 }
4637 
4638 void MacroAssembler::load_prototype_header(Register dst, Register src, Register tmp) {
4639   load_klass(dst, src, tmp);
4640   movptr(dst, Address(dst, Klass::prototype_header_offset()));
4641 }
4642 
4643 void MacroAssembler::store_klass(Register dst, Register src, Register tmp) {
4644   assert_different_registers(src, tmp);
4645   assert_different_registers(dst, tmp);
4646 #ifdef _LP64
4647   if (UseCompressedClassPointers) {
4648     encode_klass_not_null(src, tmp);
4649     movl(Address(dst, oopDesc::klass_offset_in_bytes()), src);
4650   } else
4651 #endif
4652     movptr(Address(dst, oopDesc::klass_offset_in_bytes()), src);
4653 }
4654 
4655 void MacroAssembler::access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
4656                                     Register tmp1, Register thread_tmp) {
4657   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4658   decorators = AccessInternal::decorator_fixup(decorators);
4659   bool as_raw = (decorators &amp; AS_RAW) != 0;
4660   if (as_raw) {
4661     bs-&gt;BarrierSetAssembler::load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4662   } else {
4663     bs-&gt;load_at(this, decorators, type, dst, src, tmp1, thread_tmp);
4664   }
4665 }
4666 
4667 void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
<a name="12" id="anc12"></a><span class="line-modified">4668                                      Register tmp1, Register tmp2, Register tmp3) {</span>
4669   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4670   decorators = AccessInternal::decorator_fixup(decorators);
4671   bool as_raw = (decorators &amp; AS_RAW) != 0;
4672   if (as_raw) {
<a name="13" id="anc13"></a><span class="line-modified">4673     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);</span>
<span class="line-added">4674   } else {</span>
<span class="line-added">4675     bs-&gt;store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);</span>
<span class="line-added">4676   }</span>
<span class="line-added">4677 }</span>
<span class="line-added">4678 </span>
<span class="line-added">4679 void MacroAssembler::access_value_copy(DecoratorSet decorators, Register src, Register dst,</span>
<span class="line-added">4680                                        Register value_klass) {</span>
<span class="line-added">4681   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();</span>
<span class="line-added">4682   bs-&gt;value_copy(this, decorators, src, dst, value_klass);</span>
<span class="line-added">4683 }</span>
<span class="line-added">4684 </span>
<span class="line-added">4685 void MacroAssembler::first_field_offset(Register value_klass, Register offset) {</span>
<span class="line-added">4686   movptr(offset, Address(value_klass, InstanceKlass::adr_valueklass_fixed_block_offset()));</span>
<span class="line-added">4687   movl(offset, Address(offset, ValueKlass::first_field_offset_offset()));</span>
<span class="line-added">4688 }</span>
<span class="line-added">4689 </span>
<span class="line-added">4690 void MacroAssembler::data_for_oop(Register oop, Register data, Register value_klass) {</span>
<span class="line-added">4691   // ((address) (void*) o) + vk-&gt;first_field_offset();</span>
<span class="line-added">4692   Register offset = (data == oop) ? rscratch1 : data;</span>
<span class="line-added">4693   first_field_offset(value_klass, offset);</span>
<span class="line-added">4694   if (data == oop) {</span>
<span class="line-added">4695     addptr(data, offset);</span>
4696   } else {
<a name="14" id="anc14"></a><span class="line-modified">4697     lea(data, Address(oop, offset));</span>
4698   }
4699 }
4700 
<a name="15" id="anc15"></a><span class="line-added">4701 void MacroAssembler::data_for_value_array_index(Register array, Register array_klass,</span>
<span class="line-added">4702                                                 Register index, Register data) {</span>
<span class="line-added">4703   assert(index != rcx, &quot;index needs to shift by rcx&quot;);</span>
<span class="line-added">4704   assert_different_registers(array, array_klass, index);</span>
<span class="line-added">4705   assert_different_registers(rcx, array, index);</span>
<span class="line-added">4706 </span>
<span class="line-added">4707   // array-&gt;base() + (index &lt;&lt; Klass::layout_helper_log2_element_size(lh));</span>
<span class="line-added">4708   movl(rcx, Address(array_klass, Klass::layout_helper_offset()));</span>
<span class="line-added">4709 </span>
<span class="line-added">4710   // Klass::layout_helper_log2_element_size(lh)</span>
<span class="line-added">4711   // (lh &gt;&gt; _lh_log2_element_size_shift) &amp; _lh_log2_element_size_mask;</span>
<span class="line-added">4712   shrl(rcx, Klass::_lh_log2_element_size_shift);</span>
<span class="line-added">4713   andl(rcx, Klass::_lh_log2_element_size_mask);</span>
<span class="line-added">4714   shlptr(index); // index &lt;&lt; rcx</span>
<span class="line-added">4715 </span>
<span class="line-added">4716   lea(data, Address(array, index, Address::times_1, arrayOopDesc::base_offset_in_bytes(T_VALUETYPE)));</span>
<span class="line-added">4717 }</span>
<span class="line-added">4718 </span>
4719 void MacroAssembler::resolve(DecoratorSet decorators, Register obj) {
4720   // Use stronger ACCESS_WRITE|ACCESS_READ by default.
4721   if ((decorators &amp; (ACCESS_READ | ACCESS_WRITE)) == 0) {
4722     decorators |= ACCESS_READ | ACCESS_WRITE;
4723   }
4724   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
4725   return bs-&gt;resolve(this, decorators, obj);
4726 }
4727 
4728 void MacroAssembler::load_heap_oop(Register dst, Address src, Register tmp1,
4729                                    Register thread_tmp, DecoratorSet decorators) {
4730   access_load_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp);
4731 }
4732 
4733 // Doesn&#39;t do verfication, generates fixed size code
4734 void MacroAssembler::load_heap_oop_not_null(Register dst, Address src, Register tmp1,
4735                                             Register thread_tmp, DecoratorSet decorators) {
4736   access_load_at(T_OBJECT, IN_HEAP | IS_NOT_NULL | decorators, dst, src, tmp1, thread_tmp);
4737 }
4738 
4739 void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,
<a name="16" id="anc16"></a><span class="line-modified">4740                                     Register tmp2, Register tmp3, DecoratorSet decorators) {</span>
<span class="line-modified">4741   access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, tmp2, tmp3);</span>
4742 }
4743 
4744 // Used for storing NULLs.
4745 void MacroAssembler::store_heap_oop_null(Address dst) {
<a name="17" id="anc17"></a><span class="line-modified">4746   access_store_at(T_OBJECT, IN_HEAP, dst, noreg, noreg, noreg, noreg);</span>
4747 }
4748 
4749 #ifdef _LP64
4750 void MacroAssembler::store_klass_gap(Register dst, Register src) {
4751   if (UseCompressedClassPointers) {
4752     // Store to klass gap in destination
4753     movl(Address(dst, oopDesc::klass_gap_offset_in_bytes()), src);
4754   }
4755 }
4756 
4757 #ifdef ASSERT
4758 void MacroAssembler::verify_heapbase(const char* msg) {
4759   assert (UseCompressedOops, &quot;should be compressed&quot;);
4760   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4761   if (CheckCompressedOops) {
4762     Label ok;
4763     push(rscratch1); // cmpptr trashes rscratch1
4764     cmpptr(r12_heapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
4765     jcc(Assembler::equal, ok);
4766     STOP(msg);
4767     bind(ok);
4768     pop(rscratch1);
4769   }
4770 }
4771 #endif
4772 
4773 // Algorithm must match oop.inline.hpp encode_heap_oop.
4774 void MacroAssembler::encode_heap_oop(Register r) {
4775 #ifdef ASSERT
4776   verify_heapbase(&quot;MacroAssembler::encode_heap_oop: heap base corrupted?&quot;);
4777 #endif
4778   verify_oop_msg(r, &quot;broken oop in encode_heap_oop&quot;);
4779   if (CompressedOops::base() == NULL) {
4780     if (CompressedOops::shift() != 0) {
4781       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4782       shrq(r, LogMinObjAlignmentInBytes);
4783     }
4784     return;
4785   }
4786   testq(r, r);
4787   cmovq(Assembler::equal, r, r12_heapbase);
4788   subq(r, r12_heapbase);
4789   shrq(r, LogMinObjAlignmentInBytes);
4790 }
4791 
4792 void MacroAssembler::encode_heap_oop_not_null(Register r) {
4793 #ifdef ASSERT
4794   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null: heap base corrupted?&quot;);
4795   if (CheckCompressedOops) {
4796     Label ok;
4797     testq(r, r);
4798     jcc(Assembler::notEqual, ok);
4799     STOP(&quot;null oop passed to encode_heap_oop_not_null&quot;);
4800     bind(ok);
4801   }
4802 #endif
4803   verify_oop_msg(r, &quot;broken oop in encode_heap_oop_not_null&quot;);
4804   if (CompressedOops::base() != NULL) {
4805     subq(r, r12_heapbase);
4806   }
4807   if (CompressedOops::shift() != 0) {
4808     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4809     shrq(r, LogMinObjAlignmentInBytes);
4810   }
4811 }
4812 
4813 void MacroAssembler::encode_heap_oop_not_null(Register dst, Register src) {
4814 #ifdef ASSERT
4815   verify_heapbase(&quot;MacroAssembler::encode_heap_oop_not_null2: heap base corrupted?&quot;);
4816   if (CheckCompressedOops) {
4817     Label ok;
4818     testq(src, src);
4819     jcc(Assembler::notEqual, ok);
4820     STOP(&quot;null oop passed to encode_heap_oop_not_null2&quot;);
4821     bind(ok);
4822   }
4823 #endif
4824   verify_oop_msg(src, &quot;broken oop in encode_heap_oop_not_null2&quot;);
4825   if (dst != src) {
4826     movq(dst, src);
4827   }
4828   if (CompressedOops::base() != NULL) {
4829     subq(dst, r12_heapbase);
4830   }
4831   if (CompressedOops::shift() != 0) {
4832     assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4833     shrq(dst, LogMinObjAlignmentInBytes);
4834   }
4835 }
4836 
4837 void  MacroAssembler::decode_heap_oop(Register r) {
4838 #ifdef ASSERT
4839   verify_heapbase(&quot;MacroAssembler::decode_heap_oop: heap base corrupted?&quot;);
4840 #endif
4841   if (CompressedOops::base() == NULL) {
4842     if (CompressedOops::shift() != 0) {
4843       assert (LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4844       shlq(r, LogMinObjAlignmentInBytes);
4845     }
4846   } else {
4847     Label done;
4848     shlq(r, LogMinObjAlignmentInBytes);
4849     jccb(Assembler::equal, done);
4850     addq(r, r12_heapbase);
4851     bind(done);
4852   }
4853   verify_oop_msg(r, &quot;broken oop in decode_heap_oop&quot;);
4854 }
4855 
4856 void  MacroAssembler::decode_heap_oop_not_null(Register r) {
4857   // Note: it will change flags
4858   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4859   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4860   // Cannot assert, unverified entry point counts instructions (see .ad file)
4861   // vtableStubs also counts instructions in pd_code_size_limit.
4862   // Also do not verify_oop as this is called by verify_oop.
4863   if (CompressedOops::shift() != 0) {
4864     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4865     shlq(r, LogMinObjAlignmentInBytes);
4866     if (CompressedOops::base() != NULL) {
4867       addq(r, r12_heapbase);
4868     }
4869   } else {
4870     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
4871   }
4872 }
4873 
4874 void  MacroAssembler::decode_heap_oop_not_null(Register dst, Register src) {
4875   // Note: it will change flags
4876   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4877   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4878   // Cannot assert, unverified entry point counts instructions (see .ad file)
4879   // vtableStubs also counts instructions in pd_code_size_limit.
4880   // Also do not verify_oop as this is called by verify_oop.
4881   if (CompressedOops::shift() != 0) {
4882     assert(LogMinObjAlignmentInBytes == CompressedOops::shift(), &quot;decode alg wrong&quot;);
4883     if (LogMinObjAlignmentInBytes == Address::times_8) {
4884       leaq(dst, Address(r12_heapbase, src, Address::times_8, 0));
4885     } else {
4886       if (dst != src) {
4887         movq(dst, src);
4888       }
4889       shlq(dst, LogMinObjAlignmentInBytes);
4890       if (CompressedOops::base() != NULL) {
4891         addq(dst, r12_heapbase);
4892       }
4893     }
4894   } else {
4895     assert (CompressedOops::base() == NULL, &quot;sanity&quot;);
4896     if (dst != src) {
4897       movq(dst, src);
4898     }
4899   }
4900 }
4901 
4902 void MacroAssembler::encode_klass_not_null(Register r, Register tmp) {
4903   assert_different_registers(r, tmp);
4904   if (CompressedKlassPointers::base() != NULL) {
4905     mov64(tmp, (int64_t)CompressedKlassPointers::base());
4906     subq(r, tmp);
4907   }
4908   if (CompressedKlassPointers::shift() != 0) {
4909     assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4910     shrq(r, LogKlassAlignmentInBytes);
4911   }
4912 }
4913 
4914 void MacroAssembler::encode_and_move_klass_not_null(Register dst, Register src) {
4915   assert_different_registers(src, dst);
4916   if (CompressedKlassPointers::base() != NULL) {
4917     mov64(dst, -(int64_t)CompressedKlassPointers::base());
4918     addq(dst, src);
4919   } else {
4920     movptr(dst, src);
4921   }
4922   if (CompressedKlassPointers::shift() != 0) {
4923     assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4924     shrq(dst, LogKlassAlignmentInBytes);
4925   }
4926 }
4927 
4928 // !!! If the instructions that get generated here change then function
4929 // instr_size_for_decode_klass_not_null() needs to get updated.
4930 void  MacroAssembler::decode_klass_not_null(Register r, Register tmp) {
4931   assert_different_registers(r, tmp);
4932   // Note: it will change flags
4933   assert(UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4934   // Cannot assert, unverified entry point counts instructions (see .ad file)
4935   // vtableStubs also counts instructions in pd_code_size_limit.
4936   // Also do not verify_oop as this is called by verify_oop.
4937   if (CompressedKlassPointers::shift() != 0) {
4938     assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4939     shlq(r, LogKlassAlignmentInBytes);
4940   }
4941   if (CompressedKlassPointers::base() != NULL) {
4942     mov64(tmp, (int64_t)CompressedKlassPointers::base());
4943     addq(r, tmp);
4944   }
4945 }
4946 
4947 void  MacroAssembler::decode_and_move_klass_not_null(Register dst, Register src) {
4948   assert_different_registers(src, dst);
4949   // Note: it will change flags
4950   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4951   // Cannot assert, unverified entry point counts instructions (see .ad file)
4952   // vtableStubs also counts instructions in pd_code_size_limit.
4953   // Also do not verify_oop as this is called by verify_oop.
4954 
4955   if (CompressedKlassPointers::base() == NULL &amp;&amp;
4956       CompressedKlassPointers::shift() == 0) {
4957     // The best case scenario is that there is no base or shift. Then it is already
4958     // a pointer that needs nothing but a register rename.
4959     movl(dst, src);
4960   } else {
4961     if (CompressedKlassPointers::base() != NULL) {
4962       mov64(dst, (int64_t)CompressedKlassPointers::base());
4963     } else {
4964       xorq(dst, dst);
4965     }
4966     if (CompressedKlassPointers::shift() != 0) {
4967       assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), &quot;decode alg wrong&quot;);
4968       assert(LogKlassAlignmentInBytes == Address::times_8, &quot;klass not aligned on 64bits?&quot;);
4969       leaq(dst, Address(dst, src, Address::times_8, 0));
4970     } else {
4971       addq(dst, src);
4972     }
4973   }
4974 }
4975 
4976 void  MacroAssembler::set_narrow_oop(Register dst, jobject obj) {
4977   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4978   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4979   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4980   int oop_index = oop_recorder()-&gt;find_index(obj);
4981   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4982   mov_narrow_oop(dst, oop_index, rspec);
4983 }
4984 
4985 void  MacroAssembler::set_narrow_oop(Address dst, jobject obj) {
4986   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
4987   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
4988   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4989   int oop_index = oop_recorder()-&gt;find_index(obj);
4990   RelocationHolder rspec = oop_Relocation::spec(oop_index);
4991   mov_narrow_oop(dst, oop_index, rspec);
4992 }
4993 
4994 void  MacroAssembler::set_narrow_klass(Register dst, Klass* k) {
4995   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
4996   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
4997   int klass_index = oop_recorder()-&gt;find_index(k);
4998   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
4999   mov_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
5000 }
5001 
5002 void  MacroAssembler::set_narrow_klass(Address dst, Klass* k) {
5003   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
5004   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
5005   int klass_index = oop_recorder()-&gt;find_index(k);
5006   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
5007   mov_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
5008 }
5009 
5010 void  MacroAssembler::cmp_narrow_oop(Register dst, jobject obj) {
5011   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
5012   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
5013   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
5014   int oop_index = oop_recorder()-&gt;find_index(obj);
5015   RelocationHolder rspec = oop_Relocation::spec(oop_index);
5016   Assembler::cmp_narrow_oop(dst, oop_index, rspec);
5017 }
5018 
5019 void  MacroAssembler::cmp_narrow_oop(Address dst, jobject obj) {
5020   assert (UseCompressedOops, &quot;should only be used for compressed headers&quot;);
5021   assert (Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
5022   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
5023   int oop_index = oop_recorder()-&gt;find_index(obj);
5024   RelocationHolder rspec = oop_Relocation::spec(oop_index);
5025   Assembler::cmp_narrow_oop(dst, oop_index, rspec);
5026 }
5027 
5028 void  MacroAssembler::cmp_narrow_klass(Register dst, Klass* k) {
5029   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
5030   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
5031   int klass_index = oop_recorder()-&gt;find_index(k);
5032   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
5033   Assembler::cmp_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
5034 }
5035 
5036 void  MacroAssembler::cmp_narrow_klass(Address dst, Klass* k) {
5037   assert (UseCompressedClassPointers, &quot;should only be used for compressed headers&quot;);
5038   assert (oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
5039   int klass_index = oop_recorder()-&gt;find_index(k);
5040   RelocationHolder rspec = metadata_Relocation::spec(klass_index);
5041   Assembler::cmp_narrow_oop(dst, CompressedKlassPointers::encode(k), rspec);
5042 }
5043 
5044 void MacroAssembler::reinit_heapbase() {
5045   if (UseCompressedOops) {
5046     if (Universe::heap() != NULL) {
5047       if (CompressedOops::base() == NULL) {
5048         MacroAssembler::xorptr(r12_heapbase, r12_heapbase);
5049       } else {
5050         mov64(r12_heapbase, (int64_t)CompressedOops::ptrs_base());
5051       }
5052     } else {
5053       movptr(r12_heapbase, ExternalAddress((address)CompressedOops::ptrs_base_addr()));
5054     }
5055   }
5056 }
5057 
5058 #endif // _LP64
5059 
5060 // C2 compiled method&#39;s prolog code.
<a name="18" id="anc18"></a><span class="line-modified">5061 void MacroAssembler::verified_entry(Compile* C, int sp_inc) {</span>
<span class="line-added">5062   int framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-added">5063   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
<span class="line-added">5064   bool fp_mode_24b = false;</span>
<span class="line-added">5065   int stack_bang_size = C-&gt;output()-&gt;need_stack_bang(bangsize) ? bangsize : 0;</span>
5066 
5067   // WARNING: Initial instruction MUST be 5 bytes or longer so that
5068   // NativeJump::patch_verified_entry will be able to patch out the entry
5069   // code safely. The push to verify stack depth is ok at 5 bytes,
5070   // the frame allocation can be either 3 or 6 bytes. So if we don&#39;t do
5071   // stack bang then we must use the 6 byte frame allocation even if
5072   // we have no frame. :-(
5073   assert(stack_bang_size &gt;= framesize || stack_bang_size &lt;= 0, &quot;stack bang size incorrect&quot;);
5074 
5075   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
5076   // Remove word for return addr
5077   framesize -= wordSize;
5078   stack_bang_size -= wordSize;
5079 
5080   // Calls to C2R adapters often do not accept exceptional returns.
5081   // We require that their callers must bang for them.  But be careful, because
5082   // some VM calls (such as call site linkage) can use several kilobytes of
5083   // stack.  But the stack safety zone should account for that.
5084   // See bugs 4446381, 4468289, 4497237.
5085   if (stack_bang_size &gt; 0) {
5086     generate_stack_overflow_check(stack_bang_size);
5087 
5088     // We always push rbp, so that on return to interpreter rbp, will be
5089     // restored correctly and we can correct the stack.
5090     push(rbp);
5091     // Save caller&#39;s stack pointer into RBP if the frame pointer is preserved.
5092     if (PreserveFramePointer) {
5093       mov(rbp, rsp);
5094     }
5095     // Remove word for ebp
5096     framesize -= wordSize;
5097 
5098     // Create frame
5099     if (framesize) {
5100       subptr(rsp, framesize);
5101     }
5102   } else {
5103     // Create frame (force generation of a 4 byte immediate value)
5104     subptr_imm32(rsp, framesize);
5105 
5106     // Save RBP register now.
5107     framesize -= wordSize;
5108     movptr(Address(rsp, framesize), rbp);
5109     // Save caller&#39;s stack pointer into RBP if the frame pointer is preserved.
5110     if (PreserveFramePointer) {
5111       movptr(rbp, rsp);
5112       if (framesize &gt; 0) {
5113         addptr(rbp, framesize);
5114       }
5115     }
5116   }
5117 
<a name="19" id="anc19"></a><span class="line-added">5118   if (C-&gt;needs_stack_repair()) {</span>
<span class="line-added">5119     // Save stack increment (also account for fixed framesize and rbp)</span>
<span class="line-added">5120     assert((sp_inc &amp; (StackAlignmentInBytes-1)) == 0, &quot;stack increment not aligned&quot;);</span>
<span class="line-added">5121     movptr(Address(rsp, C-&gt;output()-&gt;sp_inc_offset()), sp_inc + framesize + wordSize);</span>
<span class="line-added">5122   }</span>
<span class="line-added">5123 </span>
5124   if (VerifyStackAtCalls) { // Majik cookie to verify stack depth
5125     framesize -= wordSize;
5126     movptr(Address(rsp, framesize), (int32_t)0xbadb100d);
5127   }
5128 
5129 #ifndef _LP64
5130   // If method sets FPU control word do it now
5131   if (fp_mode_24b) {
5132     fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_24()));
5133   }
5134   if (UseSSE &gt;= 2 &amp;&amp; VerifyFPU) {
5135     verify_FPU(0, &quot;FPU stack must be clean on entry&quot;);
5136   }
5137 #endif
5138 
5139 #ifdef ASSERT
5140   if (VerifyStackAtCalls) {
5141     Label L;
5142     push(rax);
5143     mov(rax, rsp);
5144     andptr(rax, StackAlignmentInBytes-1);
5145     cmpptr(rax, StackAlignmentInBytes-wordSize);
5146     pop(rax);
5147     jcc(Assembler::equal, L);
5148     STOP(&quot;Stack is not properly aligned!&quot;);
5149     bind(L);
5150   }
5151 #endif
<a name="20" id="anc20"></a>




5152 }
5153 
5154 // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39; using XMM/YMM registers
<a name="21" id="anc21"></a><span class="line-modified">5155 void MacroAssembler::xmm_clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp) {</span>
5156   // cnt - number of qwords (8-byte words).
5157   // base - start address, qword aligned.
5158   Label L_zero_64_bytes, L_loop, L_sloop, L_tail, L_end;
<a name="22" id="anc22"></a><span class="line-added">5159   movdq(xtmp, val);</span>
5160   if (UseAVX &gt;= 2) {
<a name="23" id="anc23"></a><span class="line-modified">5161     punpcklqdq(xtmp, xtmp);</span>
<span class="line-added">5162     vinserti128_high(xtmp, xtmp);</span>
5163   } else {
<a name="24" id="anc24"></a><span class="line-modified">5164     punpcklqdq(xtmp, xtmp);</span>
5165   }
5166   jmp(L_zero_64_bytes);
5167 
5168   BIND(L_loop);
5169   if (UseAVX &gt;= 2) {
5170     vmovdqu(Address(base,  0), xtmp);
5171     vmovdqu(Address(base, 32), xtmp);
5172   } else {
5173     movdqu(Address(base,  0), xtmp);
5174     movdqu(Address(base, 16), xtmp);
5175     movdqu(Address(base, 32), xtmp);
5176     movdqu(Address(base, 48), xtmp);
5177   }
5178   addptr(base, 64);
5179 
5180   BIND(L_zero_64_bytes);
5181   subptr(cnt, 8);
5182   jccb(Assembler::greaterEqual, L_loop);
5183   addptr(cnt, 4);
5184   jccb(Assembler::less, L_tail);
5185   // Copy trailing 32 bytes
5186   if (UseAVX &gt;= 2) {
5187     vmovdqu(Address(base, 0), xtmp);
5188   } else {
5189     movdqu(Address(base,  0), xtmp);
5190     movdqu(Address(base, 16), xtmp);
5191   }
5192   addptr(base, 32);
5193   subptr(cnt, 4);
5194 
5195   BIND(L_tail);
5196   addptr(cnt, 4);
5197   jccb(Assembler::lessEqual, L_end);
5198   decrement(cnt);
5199 
5200   BIND(L_sloop);
5201   movq(Address(base, 0), xtmp);
5202   addptr(base, 8);
5203   decrement(cnt);
5204   jccb(Assembler::greaterEqual, L_sloop);
5205   BIND(L_end);
5206 }
5207 
<a name="25" id="anc25"></a><span class="line-modified">5208 int MacroAssembler::store_value_type_fields_to_buf(ciValueKlass* vk, bool from_interpreter) {</span>
<span class="line-added">5209   // A value type might be returned. If fields are in registers we</span>
<span class="line-added">5210   // need to allocate a value type instance and initialize it with</span>
<span class="line-added">5211   // the value of the fields.</span>
<span class="line-added">5212   Label skip;</span>
<span class="line-added">5213   // We only need a new buffered value if a new one is not returned</span>
<span class="line-added">5214   testptr(rax, 1);</span>
<span class="line-added">5215   jcc(Assembler::zero, skip);</span>
<span class="line-added">5216   int call_offset = -1;</span>
<span class="line-added">5217 </span>
<span class="line-added">5218 #ifdef _LP64</span>
<span class="line-added">5219   Label slow_case;</span>
<span class="line-added">5220 </span>
<span class="line-added">5221   // Try to allocate a new buffered value (from the heap)</span>
<span class="line-added">5222   if (UseTLAB) {</span>
<span class="line-added">5223     // FIXME -- for smaller code, the inline allocation (and the slow case) should be moved inside the pack handler.</span>
<span class="line-added">5224     if (vk != NULL) {</span>
<span class="line-added">5225       // Called from C1, where the return type is statically known.</span>
<span class="line-added">5226       movptr(rbx, (intptr_t)vk-&gt;get_ValueKlass());</span>
<span class="line-added">5227       jint lh = vk-&gt;layout_helper();</span>
<span class="line-added">5228       assert(lh != Klass::_lh_neutral_value, &quot;inline class in return type must have been resolved&quot;);</span>
<span class="line-added">5229       movl(r14, lh);</span>
<span class="line-added">5230     } else {</span>
<span class="line-added">5231       // Call from interpreter. RAX contains ((the ValueKlass* of the return type) | 0x01)</span>
<span class="line-added">5232       mov(rbx, rax);</span>
<span class="line-added">5233       andptr(rbx, -2);</span>
<span class="line-added">5234       movl(r14, Address(rbx, Klass::layout_helper_offset()));</span>
<span class="line-added">5235     }</span>
<span class="line-added">5236 </span>
<span class="line-added">5237     movptr(r13, Address(r15_thread, in_bytes(JavaThread::tlab_top_offset())));</span>
<span class="line-added">5238     lea(r14, Address(r13, r14, Address::times_1));</span>
<span class="line-added">5239     cmpptr(r14, Address(r15_thread, in_bytes(JavaThread::tlab_end_offset())));</span>
<span class="line-added">5240     jcc(Assembler::above, slow_case);</span>
<span class="line-added">5241     movptr(Address(r15_thread, in_bytes(JavaThread::tlab_top_offset())), r14);</span>
<span class="line-added">5242     movptr(Address(r13, oopDesc::mark_offset_in_bytes()), (intptr_t)markWord::always_locked_prototype().value());</span>
<span class="line-added">5243 </span>
<span class="line-added">5244     xorl(rax, rax); // use zero reg to clear memory (shorter code)</span>
<span class="line-added">5245     store_klass_gap(r13, rax);  // zero klass gap for compressed oops</span>
<span class="line-added">5246 </span>
<span class="line-added">5247     if (vk == NULL) {</span>
<span class="line-added">5248       // store_klass corrupts rbx, so save it in rax for later use (interpreter case only).</span>
<span class="line-added">5249       mov(rax, rbx);</span>
<span class="line-added">5250     }</span>
<span class="line-added">5251     Register tmp_store_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);</span>
<span class="line-added">5252     store_klass(r13, rbx, tmp_store_klass);  // klass</span>
<span class="line-added">5253 </span>
<span class="line-added">5254     // We have our new buffered value, initialize its fields with a</span>
<span class="line-added">5255     // value class specific handler</span>
<span class="line-added">5256     if (vk != NULL) {</span>
<span class="line-added">5257       // FIXME -- do the packing in-line to avoid the runtime call</span>
<span class="line-added">5258       mov(rax, r13);</span>
<span class="line-added">5259       call(RuntimeAddress(vk-&gt;pack_handler())); // no need for call info as this will not safepoint.</span>
<span class="line-added">5260     } else {</span>
<span class="line-added">5261       movptr(rbx, Address(rax, InstanceKlass::adr_valueklass_fixed_block_offset()));</span>
<span class="line-added">5262       movptr(rbx, Address(rbx, ValueKlass::pack_handler_offset()));</span>
<span class="line-added">5263       mov(rax, r13);</span>
<span class="line-added">5264       call(rbx);</span>
<span class="line-added">5265     }</span>
<span class="line-added">5266     jmp(skip);</span>
<span class="line-added">5267   }</span>
<span class="line-added">5268 </span>
<span class="line-added">5269   bind(slow_case);</span>
<span class="line-added">5270   // We failed to allocate a new value, fall back to a runtime</span>
<span class="line-added">5271   // call. Some oop field may be live in some registers but we can&#39;t</span>
<span class="line-added">5272   // tell. That runtime call will take care of preserving them</span>
<span class="line-added">5273   // across a GC if there&#39;s one.</span>
<span class="line-added">5274 #endif</span>
<span class="line-added">5275 </span>
<span class="line-added">5276   if (from_interpreter) {</span>
<span class="line-added">5277     super_call_VM_leaf(StubRoutines::store_value_type_fields_to_buf());</span>
<span class="line-added">5278   } else {</span>
<span class="line-added">5279     call(RuntimeAddress(StubRoutines::store_value_type_fields_to_buf()));</span>
<span class="line-added">5280     call_offset = offset();</span>
<span class="line-added">5281   }</span>
<span class="line-added">5282 </span>
<span class="line-added">5283   bind(skip);</span>
<span class="line-added">5284   return call_offset;</span>
<span class="line-added">5285 }</span>
<span class="line-added">5286 </span>
<span class="line-added">5287 </span>
<span class="line-added">5288 // Move a value between registers/stack slots and update the reg_state</span>
<span class="line-added">5289 bool MacroAssembler::move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[], int ret_off, int extra_stack_offset) {</span>
<span class="line-added">5290   if (reg_state[to-&gt;value()] == reg_written) {</span>
<span class="line-added">5291     return true; // Already written</span>
<span class="line-added">5292   }</span>
<span class="line-added">5293   if (from != to &amp;&amp; bt != T_VOID) {</span>
<span class="line-added">5294     if (reg_state[to-&gt;value()] == reg_readonly) {</span>
<span class="line-added">5295       return false; // Not yet writable</span>
<span class="line-added">5296     }</span>
<span class="line-added">5297     if (from-&gt;is_reg()) {</span>
<span class="line-added">5298       if (to-&gt;is_reg()) {</span>
<span class="line-added">5299         if (from-&gt;is_XMMRegister()) {</span>
<span class="line-added">5300           if (bt == T_DOUBLE) {</span>
<span class="line-added">5301             movdbl(to-&gt;as_XMMRegister(), from-&gt;as_XMMRegister());</span>
<span class="line-added">5302           } else {</span>
<span class="line-added">5303             assert(bt == T_FLOAT, &quot;must be float&quot;);</span>
<span class="line-added">5304             movflt(to-&gt;as_XMMRegister(), from-&gt;as_XMMRegister());</span>
<span class="line-added">5305           }</span>
<span class="line-added">5306         } else {</span>
<span class="line-added">5307           movq(to-&gt;as_Register(), from-&gt;as_Register());</span>
<span class="line-added">5308         }</span>
<span class="line-added">5309       } else {</span>
<span class="line-added">5310         int st_off = to-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;</span>
<span class="line-added">5311         assert(st_off != ret_off, &quot;overwriting return address at %d&quot;, st_off);</span>
<span class="line-added">5312         Address to_addr = Address(rsp, st_off);</span>
<span class="line-added">5313         if (from-&gt;is_XMMRegister()) {</span>
<span class="line-added">5314           if (bt == T_DOUBLE) {</span>
<span class="line-added">5315             movdbl(to_addr, from-&gt;as_XMMRegister());</span>
<span class="line-added">5316           } else {</span>
<span class="line-added">5317             assert(bt == T_FLOAT, &quot;must be float&quot;);</span>
<span class="line-added">5318             movflt(to_addr, from-&gt;as_XMMRegister());</span>
<span class="line-added">5319           }</span>
<span class="line-added">5320         } else {</span>
<span class="line-added">5321           movq(to_addr, from-&gt;as_Register());</span>
<span class="line-added">5322         }</span>
<span class="line-added">5323       }</span>
<span class="line-added">5324     } else {</span>
<span class="line-added">5325       Address from_addr = Address(rsp, from-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset);</span>
<span class="line-added">5326       if (to-&gt;is_reg()) {</span>
<span class="line-added">5327         if (to-&gt;is_XMMRegister()) {</span>
<span class="line-added">5328           if (bt == T_DOUBLE) {</span>
<span class="line-added">5329             movdbl(to-&gt;as_XMMRegister(), from_addr);</span>
<span class="line-added">5330           } else {</span>
<span class="line-added">5331             assert(bt == T_FLOAT, &quot;must be float&quot;);</span>
<span class="line-added">5332             movflt(to-&gt;as_XMMRegister(), from_addr);</span>
<span class="line-added">5333           }</span>
<span class="line-added">5334         } else {</span>
<span class="line-added">5335           movq(to-&gt;as_Register(), from_addr);</span>
<span class="line-added">5336         }</span>
<span class="line-added">5337       } else {</span>
<span class="line-added">5338         int st_off = to-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;</span>
<span class="line-added">5339         assert(st_off != ret_off, &quot;overwriting return address at %d&quot;, st_off);</span>
<span class="line-added">5340         movq(r13, from_addr);</span>
<span class="line-added">5341         movq(Address(rsp, st_off), r13);</span>
<span class="line-added">5342       }</span>
<span class="line-added">5343     }</span>
<span class="line-added">5344   }</span>
<span class="line-added">5345   // Update register states</span>
<span class="line-added">5346   reg_state[from-&gt;value()] = reg_writable;</span>
<span class="line-added">5347   reg_state[to-&gt;value()] = reg_written;</span>
<span class="line-added">5348   return true;</span>
<span class="line-added">5349 }</span>
<span class="line-added">5350 </span>
<span class="line-added">5351 // Read all fields from a value type oop and store the values in registers/stack slots</span>
<span class="line-added">5352 bool MacroAssembler::unpack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, VMReg from, VMRegPair* regs_to,</span>
<span class="line-added">5353                                          int&amp; to_index, RegState reg_state[], int ret_off, int extra_stack_offset) {</span>
<span class="line-added">5354   Register fromReg = from-&gt;is_reg() ? from-&gt;as_Register() : noreg;</span>
<span class="line-added">5355   assert(sig-&gt;at(sig_index)._bt == T_VOID, &quot;should be at end delimiter&quot;);</span>
<span class="line-added">5356 </span>
<span class="line-added">5357   int vt = 1;</span>
<span class="line-added">5358   bool done = true;</span>
<span class="line-added">5359   bool mark_done = true;</span>
<span class="line-added">5360   do {</span>
<span class="line-added">5361     sig_index--;</span>
<span class="line-added">5362     BasicType bt = sig-&gt;at(sig_index)._bt;</span>
<span class="line-added">5363     if (bt == T_VALUETYPE) {</span>
<span class="line-added">5364       vt--;</span>
<span class="line-added">5365     } else if (bt == T_VOID &amp;&amp;</span>
<span class="line-added">5366                sig-&gt;at(sig_index-1)._bt != T_LONG &amp;&amp;</span>
<span class="line-added">5367                sig-&gt;at(sig_index-1)._bt != T_DOUBLE) {</span>
<span class="line-added">5368       vt++;</span>
<span class="line-added">5369     } else if (SigEntry::is_reserved_entry(sig, sig_index)) {</span>
<span class="line-added">5370       to_index--; // Ignore this</span>
<span class="line-added">5371     } else {</span>
<span class="line-added">5372       assert(to_index &gt;= 0, &quot;invalid to_index&quot;);</span>
<span class="line-added">5373       VMRegPair pair_to = regs_to[to_index--];</span>
<span class="line-added">5374       VMReg to = pair_to.first();</span>
<span class="line-added">5375 </span>
<span class="line-added">5376       if (bt == T_VOID) continue;</span>
<span class="line-added">5377 </span>
<span class="line-added">5378       int idx = (int)to-&gt;value();</span>
<span class="line-added">5379       if (reg_state[idx] == reg_readonly) {</span>
<span class="line-added">5380          if (idx != from-&gt;value()) {</span>
<span class="line-added">5381            mark_done = false;</span>
<span class="line-added">5382          }</span>
<span class="line-added">5383          done = false;</span>
<span class="line-added">5384          continue;</span>
<span class="line-added">5385       } else if (reg_state[idx] == reg_written) {</span>
<span class="line-added">5386         continue;</span>
<span class="line-added">5387       } else {</span>
<span class="line-added">5388         assert(reg_state[idx] == reg_writable, &quot;must be writable&quot;);</span>
<span class="line-added">5389         reg_state[idx] = reg_written;</span>
<span class="line-added">5390        }</span>
<span class="line-added">5391 </span>
<span class="line-added">5392       if (fromReg == noreg) {</span>
<span class="line-added">5393         int st_off = from-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;</span>
<span class="line-added">5394         movq(r10, Address(rsp, st_off));</span>
<span class="line-added">5395         fromReg = r10;</span>
<span class="line-added">5396       }</span>
<span class="line-added">5397 </span>
<span class="line-added">5398       int off = sig-&gt;at(sig_index)._offset;</span>
<span class="line-added">5399       assert(off &gt; 0, &quot;offset in object should be positive&quot;);</span>
<span class="line-added">5400       bool is_oop = (bt == T_OBJECT || bt == T_ARRAY);</span>
<span class="line-added">5401 </span>
<span class="line-added">5402       Address fromAddr = Address(fromReg, off);</span>
<span class="line-added">5403       bool is_signed = (bt != T_CHAR) &amp;&amp; (bt != T_BOOLEAN);</span>
<span class="line-added">5404       if (!to-&gt;is_XMMRegister()) {</span>
<span class="line-added">5405         Register dst = to-&gt;is_stack() ? r13 : to-&gt;as_Register();</span>
<span class="line-added">5406         if (is_oop) {</span>
<span class="line-added">5407           load_heap_oop(dst, fromAddr);</span>
<span class="line-added">5408         } else {</span>
<span class="line-added">5409           load_sized_value(dst, fromAddr, type2aelembytes(bt), is_signed);</span>
<span class="line-added">5410         }</span>
<span class="line-added">5411         if (to-&gt;is_stack()) {</span>
<span class="line-added">5412           int st_off = to-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;</span>
<span class="line-added">5413           assert(st_off != ret_off, &quot;overwriting return address at %d&quot;, st_off);</span>
<span class="line-added">5414           movq(Address(rsp, st_off), dst);</span>
<span class="line-added">5415         }</span>
<span class="line-added">5416       } else {</span>
<span class="line-added">5417         if (bt == T_DOUBLE) {</span>
<span class="line-added">5418           movdbl(to-&gt;as_XMMRegister(), fromAddr);</span>
<span class="line-added">5419         } else {</span>
<span class="line-added">5420           assert(bt == T_FLOAT, &quot;must be float&quot;);</span>
<span class="line-added">5421           movflt(to-&gt;as_XMMRegister(), fromAddr);</span>
<span class="line-added">5422         }</span>
<span class="line-added">5423       }</span>
<span class="line-added">5424     }</span>
<span class="line-added">5425   } while (vt != 0);</span>
<span class="line-added">5426   if (mark_done &amp;&amp; reg_state[from-&gt;value()] != reg_written) {</span>
<span class="line-added">5427     // This is okay because no one else will write to that slot</span>
<span class="line-added">5428     reg_state[from-&gt;value()] = reg_writable;</span>
<span class="line-added">5429   }</span>
<span class="line-added">5430   return done;</span>
<span class="line-added">5431 }</span>
<span class="line-added">5432 </span>
<span class="line-added">5433 // Pack fields back into a value type oop</span>
<span class="line-added">5434 bool MacroAssembler::pack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, int vtarg_index,</span>
<span class="line-added">5435                                        VMReg to, VMRegPair* regs_from, int regs_from_count, int&amp; from_index, RegState reg_state[],</span>
<span class="line-added">5436                                        int ret_off, int extra_stack_offset) {</span>
<span class="line-added">5437   assert(sig-&gt;at(sig_index)._bt == T_VALUETYPE, &quot;should be at end delimiter&quot;);</span>
<span class="line-added">5438   assert(to-&gt;is_valid(), &quot;must be&quot;);</span>
<span class="line-added">5439 </span>
<span class="line-added">5440   if (reg_state[to-&gt;value()] == reg_written) {</span>
<span class="line-added">5441     skip_unpacked_fields(sig, sig_index, regs_from, regs_from_count, from_index);</span>
<span class="line-added">5442     return true; // Already written</span>
<span class="line-added">5443   }</span>
<span class="line-added">5444 </span>
<span class="line-added">5445   Register val_array = rax;</span>
<span class="line-added">5446   Register val_obj_tmp = r11;</span>
<span class="line-added">5447   Register from_reg_tmp = r14; // Be careful with r14 because it&#39;s used for spilling</span>
<span class="line-added">5448   Register tmp1 = r10;</span>
<span class="line-added">5449   Register tmp2 = r13;</span>
<span class="line-added">5450   Register tmp3 = rbx;</span>
<span class="line-added">5451   Register val_obj = to-&gt;is_stack() ? val_obj_tmp : to-&gt;as_Register();</span>
<span class="line-added">5452 </span>
<span class="line-added">5453   if (reg_state[to-&gt;value()] == reg_readonly) {</span>
<span class="line-added">5454     if (!is_reg_in_unpacked_fields(sig, sig_index, to, regs_from, regs_from_count, from_index)) {</span>
<span class="line-added">5455       skip_unpacked_fields(sig, sig_index, regs_from, regs_from_count, from_index);</span>
<span class="line-added">5456       return false; // Not yet writable</span>
<span class="line-added">5457     }</span>
<span class="line-added">5458     val_obj = val_obj_tmp;</span>
<span class="line-added">5459   }</span>
<span class="line-added">5460 </span>
<span class="line-added">5461   int index = arrayOopDesc::base_offset_in_bytes(T_OBJECT) + vtarg_index * type2aelembytes(T_VALUETYPE);</span>
<span class="line-added">5462   load_heap_oop(val_obj, Address(val_array, index));</span>
<span class="line-added">5463 </span>
<span class="line-added">5464   ScalarizedValueArgsStream stream(sig, sig_index, regs_from, regs_from_count, from_index);</span>
<span class="line-added">5465   VMRegPair from_pair;</span>
<span class="line-added">5466   BasicType bt;</span>
<span class="line-added">5467   while (stream.next(from_pair, bt)) {</span>
<span class="line-added">5468     int off = sig-&gt;at(stream.sig_cc_index())._offset;</span>
<span class="line-added">5469     assert(off &gt; 0, &quot;offset in object should be positive&quot;);</span>
<span class="line-added">5470     bool is_oop = (bt == T_OBJECT || bt == T_ARRAY);</span>
<span class="line-added">5471     size_t size_in_bytes = is_java_primitive(bt) ? type2aelembytes(bt) : wordSize;</span>
<span class="line-added">5472 </span>
<span class="line-added">5473     VMReg from_r1 = from_pair.first();</span>
<span class="line-added">5474     VMReg from_r2 = from_pair.second();</span>
<span class="line-added">5475 </span>
<span class="line-added">5476     // Pack the scalarized field into the value object.</span>
<span class="line-added">5477     Address dst(val_obj, off);</span>
<span class="line-added">5478     if (!from_r1-&gt;is_XMMRegister()) {</span>
<span class="line-added">5479       Register from_reg;</span>
<span class="line-added">5480       if (from_r1-&gt;is_stack()) {</span>
<span class="line-added">5481         from_reg = from_reg_tmp;</span>
<span class="line-added">5482         int ld_off = from_r1-&gt;reg2stack() * VMRegImpl::stack_slot_size + extra_stack_offset;</span>
<span class="line-added">5483         load_sized_value(from_reg, Address(rsp, ld_off), size_in_bytes, /* is_signed */ false);</span>
<span class="line-added">5484       } else {</span>
<span class="line-added">5485         from_reg = from_r1-&gt;as_Register();</span>
<span class="line-added">5486       }</span>
<span class="line-added">5487       assert_different_registers(dst.base(), from_reg, tmp1, tmp2, tmp3, val_array);</span>
<span class="line-added">5488       if (is_oop) {</span>
<span class="line-added">5489         store_heap_oop(dst, from_reg, tmp1, tmp2, tmp3, IN_HEAP | ACCESS_WRITE | IS_DEST_UNINITIALIZED);</span>
<span class="line-added">5490       } else {</span>
<span class="line-added">5491         store_sized_value(dst, from_reg, size_in_bytes);</span>
<span class="line-added">5492       }</span>
<span class="line-added">5493     } else {</span>
<span class="line-added">5494       if (from_r2-&gt;is_valid()) {</span>
<span class="line-added">5495         movdbl(dst, from_r1-&gt;as_XMMRegister());</span>
<span class="line-added">5496       } else {</span>
<span class="line-added">5497         movflt(dst, from_r1-&gt;as_XMMRegister());</span>
<span class="line-added">5498       }</span>
<span class="line-added">5499     }</span>
<span class="line-added">5500     reg_state[from_r1-&gt;value()] = reg_writable;</span>
<span class="line-added">5501   }</span>
<span class="line-added">5502   sig_index = stream.sig_cc_index();</span>
<span class="line-added">5503   from_index = stream.regs_cc_index();</span>
<span class="line-added">5504 </span>
<span class="line-added">5505   assert(reg_state[to-&gt;value()] == reg_writable, &quot;must have already been read&quot;);</span>
<span class="line-added">5506   bool success = move_helper(val_obj-&gt;as_VMReg(), to, T_OBJECT, reg_state, ret_off, extra_stack_offset);</span>
<span class="line-added">5507   assert(success, &quot;to register must be writeable&quot;);</span>
<span class="line-added">5508 </span>
<span class="line-added">5509   return true;</span>
<span class="line-added">5510 }</span>
<span class="line-added">5511 </span>
<span class="line-added">5512 // Unpack all value type arguments passed as oops</span>
<span class="line-added">5513 void MacroAssembler::unpack_value_args(Compile* C, bool receiver_only) {</span>
<span class="line-added">5514   int sp_inc = unpack_value_args_common(C, receiver_only);</span>
<span class="line-added">5515   // Emit code for verified entry and save increment for stack repair on return</span>
<span class="line-added">5516   verified_entry(C, sp_inc);</span>
<span class="line-added">5517 }</span>
<span class="line-added">5518 </span>
<span class="line-added">5519 void MacroAssembler::shuffle_value_args(bool is_packing, bool receiver_only, int extra_stack_offset,</span>
<span class="line-added">5520                                         BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,</span>
<span class="line-added">5521                                         int args_passed, int args_on_stack, VMRegPair* regs,</span>
<span class="line-added">5522                                         int args_passed_to, int args_on_stack_to, VMRegPair* regs_to, int sp_inc) {</span>
<span class="line-added">5523   // Check if we need to extend the stack for packing/unpacking</span>
<span class="line-added">5524   if (sp_inc &gt; 0 &amp;&amp; !is_packing) {</span>
<span class="line-added">5525     // Save the return address, adjust the stack (make sure it is properly</span>
<span class="line-added">5526     // 16-byte aligned) and copy the return address to the new top of the stack.</span>
<span class="line-added">5527     // (Note: C1 does this in C1_MacroAssembler::scalarized_entry).</span>
<span class="line-added">5528     pop(r13);</span>
<span class="line-added">5529     subptr(rsp, sp_inc);</span>
<span class="line-added">5530     push(r13);</span>
<span class="line-added">5531   }</span>
<span class="line-added">5532 </span>
<span class="line-added">5533   int ret_off; // make sure we don&#39;t overwrite the return address</span>
<span class="line-added">5534   if (is_packing) {</span>
<span class="line-added">5535     // For C1 code, the VVEP doesn&#39;t have reserved slots, so we store the returned address at</span>
<span class="line-added">5536     // rsp[0] during shuffling.</span>
<span class="line-added">5537     ret_off = 0;</span>
<span class="line-added">5538   } else {</span>
<span class="line-added">5539     // C2 code ensures that sp_inc is a reserved slot.</span>
<span class="line-added">5540     ret_off = sp_inc;</span>
<span class="line-added">5541   }</span>
<span class="line-added">5542 </span>
<span class="line-added">5543   shuffle_value_args_common(is_packing, receiver_only, extra_stack_offset,</span>
<span class="line-added">5544                             sig_bt, sig_cc,</span>
<span class="line-added">5545                             args_passed, args_on_stack, regs,</span>
<span class="line-added">5546                             args_passed_to, args_on_stack_to, regs_to,</span>
<span class="line-added">5547                             sp_inc, ret_off);</span>
<span class="line-added">5548 }</span>
<span class="line-added">5549 </span>
<span class="line-added">5550 VMReg MacroAssembler::spill_reg_for(VMReg reg) {</span>
<span class="line-added">5551   return reg-&gt;is_XMMRegister() ? xmm8-&gt;as_VMReg() : r14-&gt;as_VMReg();</span>
<span class="line-added">5552 }</span>
<span class="line-added">5553 </span>
<span class="line-added">5554 void MacroAssembler::remove_frame(int initial_framesize, bool needs_stack_repair, int sp_inc_offset) {</span>
<span class="line-added">5555   assert((initial_framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);</span>
<span class="line-added">5556   if (needs_stack_repair) {</span>
<span class="line-added">5557     movq(rbp, Address(rsp, initial_framesize));</span>
<span class="line-added">5558     addq(rsp, Address(rsp, sp_inc_offset));</span>
<span class="line-added">5559   } else {</span>
<span class="line-added">5560     if (initial_framesize &gt; 0) {</span>
<span class="line-added">5561       addq(rsp, initial_framesize);</span>
<span class="line-added">5562     }</span>
<span class="line-added">5563     pop(rbp);</span>
<span class="line-added">5564   }</span>
<span class="line-added">5565 }</span>
<span class="line-added">5566 </span>
<span class="line-added">5567 void MacroAssembler::clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp, bool is_large, bool word_copy_only) {</span>
5568   // cnt - number of qwords (8-byte words).
5569   // base - start address, qword aligned.
5570   // is_large - if optimizers know cnt is larger than InitArrayShortSize
5571   assert(base==rdi, &quot;base register must be edi for rep stos&quot;);
<a name="26" id="anc26"></a><span class="line-modified">5572   assert(val==rax,   &quot;tmp register must be eax for rep stos&quot;);</span>
5573   assert(cnt==rcx,   &quot;cnt register must be ecx for rep stos&quot;);
5574   assert(InitArrayShortSize % BytesPerLong == 0,
5575     &quot;InitArrayShortSize should be the multiple of BytesPerLong&quot;);
5576 
5577   Label DONE;
5578 
<a name="27" id="anc27"></a>



5579   if (!is_large) {
5580     Label LOOP, LONG;
5581     cmpptr(cnt, InitArrayShortSize/BytesPerLong);
5582     jccb(Assembler::greater, LONG);
5583 
5584     NOT_LP64(shlptr(cnt, 1);) // convert to number of 32-bit words for 32-bit VM
5585 
5586     decrement(cnt);
5587     jccb(Assembler::negative, DONE); // Zero length
5588 
5589     // Use individual pointer-sized stores for small counts:
5590     BIND(LOOP);
<a name="28" id="anc28"></a><span class="line-modified">5591     movptr(Address(base, cnt, Address::times_ptr), val);</span>
5592     decrement(cnt);
5593     jccb(Assembler::greaterEqual, LOOP);
5594     jmpb(DONE);
5595 
5596     BIND(LONG);
5597   }
5598 
5599   // Use longer rep-prefixed ops for non-small counts:
<a name="29" id="anc29"></a><span class="line-modified">5600   if (UseFastStosb &amp;&amp; !word_copy_only) {</span>
5601     shlptr(cnt, 3); // convert to number of bytes
5602     rep_stosb();
5603   } else if (UseXMMForObjInit) {
<a name="30" id="anc30"></a><span class="line-modified">5604     xmm_clear_mem(base, cnt, val, xtmp);</span>

5605   } else {
5606     NOT_LP64(shlptr(cnt, 1);) // convert to number of 32-bit words for 32-bit VM
5607     rep_stos();
5608   }
5609 
5610   BIND(DONE);
5611 }
5612 
5613 void MacroAssembler::generate_fill(BasicType t, bool aligned,
5614                                    Register to, Register value, Register count,
5615                                    Register rtmp, XMMRegister xtmp) {
5616   ShortBranchVerifier sbv(this);
5617   assert_different_registers(to, value, count, rtmp);
5618   Label L_exit;
5619   Label L_fill_2_bytes, L_fill_4_bytes;
5620 
5621   int shift = -1;
5622   switch (t) {
5623     case T_BYTE:
5624       shift = 2;
5625       break;
5626     case T_SHORT:
5627       shift = 1;
5628       break;
5629     case T_INT:
5630       shift = 0;
5631       break;
5632     default: ShouldNotReachHere();
5633   }
5634 
5635   if (t == T_BYTE) {
5636     andl(value, 0xff);
5637     movl(rtmp, value);
5638     shll(rtmp, 8);
5639     orl(value, rtmp);
5640   }
5641   if (t == T_SHORT) {
5642     andl(value, 0xffff);
5643   }
5644   if (t == T_BYTE || t == T_SHORT) {
5645     movl(rtmp, value);
5646     shll(rtmp, 16);
5647     orl(value, rtmp);
5648   }
5649 
5650   cmpl(count, 2&lt;&lt;shift); // Short arrays (&lt; 8 bytes) fill by element
5651   jcc(Assembler::below, L_fill_4_bytes); // use unsigned cmp
5652   if (!UseUnalignedLoadStores &amp;&amp; !aligned &amp;&amp; (t == T_BYTE || t == T_SHORT)) {
5653     Label L_skip_align2;
5654     // align source address at 4 bytes address boundary
5655     if (t == T_BYTE) {
5656       Label L_skip_align1;
5657       // One byte misalignment happens only for byte arrays
5658       testptr(to, 1);
5659       jccb(Assembler::zero, L_skip_align1);
5660       movb(Address(to, 0), value);
5661       increment(to);
5662       decrement(count);
5663       BIND(L_skip_align1);
5664     }
5665     // Two bytes misalignment happens only for byte and short (char) arrays
5666     testptr(to, 2);
5667     jccb(Assembler::zero, L_skip_align2);
5668     movw(Address(to, 0), value);
5669     addptr(to, 2);
5670     subl(count, 1&lt;&lt;(shift-1));
5671     BIND(L_skip_align2);
5672   }
5673   if (UseSSE &lt; 2) {
5674     Label L_fill_32_bytes_loop, L_check_fill_8_bytes, L_fill_8_bytes_loop, L_fill_8_bytes;
5675     // Fill 32-byte chunks
5676     subl(count, 8 &lt;&lt; shift);
5677     jcc(Assembler::less, L_check_fill_8_bytes);
5678     align(16);
5679 
5680     BIND(L_fill_32_bytes_loop);
5681 
5682     for (int i = 0; i &lt; 32; i += 4) {
5683       movl(Address(to, i), value);
5684     }
5685 
5686     addptr(to, 32);
5687     subl(count, 8 &lt;&lt; shift);
5688     jcc(Assembler::greaterEqual, L_fill_32_bytes_loop);
5689     BIND(L_check_fill_8_bytes);
5690     addl(count, 8 &lt;&lt; shift);
5691     jccb(Assembler::zero, L_exit);
5692     jmpb(L_fill_8_bytes);
5693 
5694     //
5695     // length is too short, just fill qwords
5696     //
5697     BIND(L_fill_8_bytes_loop);
5698     movl(Address(to, 0), value);
5699     movl(Address(to, 4), value);
5700     addptr(to, 8);
5701     BIND(L_fill_8_bytes);
5702     subl(count, 1 &lt;&lt; (shift + 1));
5703     jcc(Assembler::greaterEqual, L_fill_8_bytes_loop);
5704     // fall through to fill 4 bytes
5705   } else {
5706     Label L_fill_32_bytes;
5707     if (!UseUnalignedLoadStores) {
5708       // align to 8 bytes, we know we are 4 byte aligned to start
5709       testptr(to, 4);
5710       jccb(Assembler::zero, L_fill_32_bytes);
5711       movl(Address(to, 0), value);
5712       addptr(to, 4);
5713       subl(count, 1&lt;&lt;shift);
5714     }
5715     BIND(L_fill_32_bytes);
5716     {
5717       assert( UseSSE &gt;= 2, &quot;supported cpu only&quot; );
5718       Label L_fill_32_bytes_loop, L_check_fill_8_bytes, L_fill_8_bytes_loop, L_fill_8_bytes;
5719       movdl(xtmp, value);
5720       if (UseAVX &gt;= 2 &amp;&amp; UseUnalignedLoadStores) {
5721         Label L_check_fill_32_bytes;
5722         if (UseAVX &gt; 2) {
5723           // Fill 64-byte chunks
5724           Label L_fill_64_bytes_loop_avx3, L_check_fill_64_bytes_avx2;
5725 
5726           // If number of bytes to fill &lt; AVX3Threshold, perform fill using AVX2
5727           cmpl(count, AVX3Threshold);
5728           jccb(Assembler::below, L_check_fill_64_bytes_avx2);
5729 
5730           vpbroadcastd(xtmp, xtmp, Assembler::AVX_512bit);
5731 
5732           subl(count, 16 &lt;&lt; shift);
5733           jccb(Assembler::less, L_check_fill_32_bytes);
5734           align(16);
5735 
5736           BIND(L_fill_64_bytes_loop_avx3);
5737           evmovdqul(Address(to, 0), xtmp, Assembler::AVX_512bit);
5738           addptr(to, 64);
5739           subl(count, 16 &lt;&lt; shift);
5740           jcc(Assembler::greaterEqual, L_fill_64_bytes_loop_avx3);
5741           jmpb(L_check_fill_32_bytes);
5742 
5743           BIND(L_check_fill_64_bytes_avx2);
5744         }
5745         // Fill 64-byte chunks
5746         Label L_fill_64_bytes_loop;
5747         vpbroadcastd(xtmp, xtmp, Assembler::AVX_256bit);
5748 
5749         subl(count, 16 &lt;&lt; shift);
5750         jcc(Assembler::less, L_check_fill_32_bytes);
5751         align(16);
5752 
5753         BIND(L_fill_64_bytes_loop);
5754         vmovdqu(Address(to, 0), xtmp);
5755         vmovdqu(Address(to, 32), xtmp);
5756         addptr(to, 64);
5757         subl(count, 16 &lt;&lt; shift);
5758         jcc(Assembler::greaterEqual, L_fill_64_bytes_loop);
5759 
5760         BIND(L_check_fill_32_bytes);
5761         addl(count, 8 &lt;&lt; shift);
5762         jccb(Assembler::less, L_check_fill_8_bytes);
5763         vmovdqu(Address(to, 0), xtmp);
5764         addptr(to, 32);
5765         subl(count, 8 &lt;&lt; shift);
5766 
5767         BIND(L_check_fill_8_bytes);
5768         // clean upper bits of YMM registers
5769         movdl(xtmp, value);
5770         pshufd(xtmp, xtmp, 0);
5771       } else {
5772         // Fill 32-byte chunks
5773         pshufd(xtmp, xtmp, 0);
5774 
5775         subl(count, 8 &lt;&lt; shift);
5776         jcc(Assembler::less, L_check_fill_8_bytes);
5777         align(16);
5778 
5779         BIND(L_fill_32_bytes_loop);
5780 
5781         if (UseUnalignedLoadStores) {
5782           movdqu(Address(to, 0), xtmp);
5783           movdqu(Address(to, 16), xtmp);
5784         } else {
5785           movq(Address(to, 0), xtmp);
5786           movq(Address(to, 8), xtmp);
5787           movq(Address(to, 16), xtmp);
5788           movq(Address(to, 24), xtmp);
5789         }
5790 
5791         addptr(to, 32);
5792         subl(count, 8 &lt;&lt; shift);
5793         jcc(Assembler::greaterEqual, L_fill_32_bytes_loop);
5794 
5795         BIND(L_check_fill_8_bytes);
5796       }
5797       addl(count, 8 &lt;&lt; shift);
5798       jccb(Assembler::zero, L_exit);
5799       jmpb(L_fill_8_bytes);
5800 
5801       //
5802       // length is too short, just fill qwords
5803       //
5804       BIND(L_fill_8_bytes_loop);
5805       movq(Address(to, 0), xtmp);
5806       addptr(to, 8);
5807       BIND(L_fill_8_bytes);
5808       subl(count, 1 &lt;&lt; (shift + 1));
5809       jcc(Assembler::greaterEqual, L_fill_8_bytes_loop);
5810     }
5811   }
5812   // fill trailing 4 bytes
5813   BIND(L_fill_4_bytes);
5814   testl(count, 1&lt;&lt;shift);
5815   jccb(Assembler::zero, L_fill_2_bytes);
5816   movl(Address(to, 0), value);
5817   if (t == T_BYTE || t == T_SHORT) {
5818     Label L_fill_byte;
5819     addptr(to, 4);
5820     BIND(L_fill_2_bytes);
5821     // fill trailing 2 bytes
5822     testl(count, 1&lt;&lt;(shift-1));
5823     jccb(Assembler::zero, L_fill_byte);
5824     movw(Address(to, 0), value);
5825     if (t == T_BYTE) {
5826       addptr(to, 2);
5827       BIND(L_fill_byte);
5828       // fill trailing byte
5829       testl(count, 1);
5830       jccb(Assembler::zero, L_exit);
5831       movb(Address(to, 0), value);
5832     } else {
5833       BIND(L_fill_byte);
5834     }
5835   } else {
5836     BIND(L_fill_2_bytes);
5837   }
5838   BIND(L_exit);
5839 }
5840 
5841 // encode char[] to byte[] in ISO_8859_1
5842    //@HotSpotIntrinsicCandidate
5843    //private static int implEncodeISOArray(byte[] sa, int sp,
5844    //byte[] da, int dp, int len) {
5845    //  int i = 0;
5846    //  for (; i &lt; len; i++) {
5847    //    char c = StringUTF16.getChar(sa, sp++);
5848    //    if (c &gt; &#39;\u00FF&#39;)
5849    //      break;
5850    //    da[dp++] = (byte)c;
5851    //  }
5852    //  return i;
5853    //}
5854 void MacroAssembler::encode_iso_array(Register src, Register dst, Register len,
5855   XMMRegister tmp1Reg, XMMRegister tmp2Reg,
5856   XMMRegister tmp3Reg, XMMRegister tmp4Reg,
5857   Register tmp5, Register result) {
5858 
5859   // rsi: src
5860   // rdi: dst
5861   // rdx: len
5862   // rcx: tmp5
5863   // rax: result
5864   ShortBranchVerifier sbv(this);
5865   assert_different_registers(src, dst, len, tmp5, result);
5866   Label L_done, L_copy_1_char, L_copy_1_char_exit;
5867 
5868   // set result
5869   xorl(result, result);
5870   // check for zero length
5871   testl(len, len);
5872   jcc(Assembler::zero, L_done);
5873 
5874   movl(result, len);
5875 
5876   // Setup pointers
5877   lea(src, Address(src, len, Address::times_2)); // char[]
5878   lea(dst, Address(dst, len, Address::times_1)); // byte[]
5879   negptr(len);
5880 
5881   if (UseSSE42Intrinsics || UseAVX &gt;= 2) {
5882     Label L_copy_8_chars, L_copy_8_chars_exit;
5883     Label L_chars_16_check, L_copy_16_chars, L_copy_16_chars_exit;
5884 
5885     if (UseAVX &gt;= 2) {
5886       Label L_chars_32_check, L_copy_32_chars, L_copy_32_chars_exit;
5887       movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vector
5888       movdl(tmp1Reg, tmp5);
5889       vpbroadcastd(tmp1Reg, tmp1Reg, Assembler::AVX_256bit);
5890       jmp(L_chars_32_check);
5891 
5892       bind(L_copy_32_chars);
5893       vmovdqu(tmp3Reg, Address(src, len, Address::times_2, -64));
5894       vmovdqu(tmp4Reg, Address(src, len, Address::times_2, -32));
5895       vpor(tmp2Reg, tmp3Reg, tmp4Reg, /* vector_len */ 1);
5896       vptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in  vector
5897       jccb(Assembler::notZero, L_copy_32_chars_exit);
5898       vpackuswb(tmp3Reg, tmp3Reg, tmp4Reg, /* vector_len */ 1);
5899       vpermq(tmp4Reg, tmp3Reg, 0xD8, /* vector_len */ 1);
5900       vmovdqu(Address(dst, len, Address::times_1, -32), tmp4Reg);
5901 
5902       bind(L_chars_32_check);
5903       addptr(len, 32);
5904       jcc(Assembler::lessEqual, L_copy_32_chars);
5905 
5906       bind(L_copy_32_chars_exit);
5907       subptr(len, 16);
5908       jccb(Assembler::greater, L_copy_16_chars_exit);
5909 
5910     } else if (UseSSE42Intrinsics) {
5911       movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vector
5912       movdl(tmp1Reg, tmp5);
5913       pshufd(tmp1Reg, tmp1Reg, 0);
5914       jmpb(L_chars_16_check);
5915     }
5916 
5917     bind(L_copy_16_chars);
5918     if (UseAVX &gt;= 2) {
5919       vmovdqu(tmp2Reg, Address(src, len, Address::times_2, -32));
5920       vptest(tmp2Reg, tmp1Reg);
5921       jcc(Assembler::notZero, L_copy_16_chars_exit);
5922       vpackuswb(tmp2Reg, tmp2Reg, tmp1Reg, /* vector_len */ 1);
5923       vpermq(tmp3Reg, tmp2Reg, 0xD8, /* vector_len */ 1);
5924     } else {
5925       if (UseAVX &gt; 0) {
5926         movdqu(tmp3Reg, Address(src, len, Address::times_2, -32));
5927         movdqu(tmp4Reg, Address(src, len, Address::times_2, -16));
5928         vpor(tmp2Reg, tmp3Reg, tmp4Reg, /* vector_len */ 0);
5929       } else {
5930         movdqu(tmp3Reg, Address(src, len, Address::times_2, -32));
5931         por(tmp2Reg, tmp3Reg);
5932         movdqu(tmp4Reg, Address(src, len, Address::times_2, -16));
5933         por(tmp2Reg, tmp4Reg);
5934       }
5935       ptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in  vector
5936       jccb(Assembler::notZero, L_copy_16_chars_exit);
5937       packuswb(tmp3Reg, tmp4Reg);
5938     }
5939     movdqu(Address(dst, len, Address::times_1, -16), tmp3Reg);
5940 
5941     bind(L_chars_16_check);
5942     addptr(len, 16);
5943     jcc(Assembler::lessEqual, L_copy_16_chars);
5944 
5945     bind(L_copy_16_chars_exit);
5946     if (UseAVX &gt;= 2) {
5947       // clean upper bits of YMM registers
5948       vpxor(tmp2Reg, tmp2Reg);
5949       vpxor(tmp3Reg, tmp3Reg);
5950       vpxor(tmp4Reg, tmp4Reg);
5951       movdl(tmp1Reg, tmp5);
5952       pshufd(tmp1Reg, tmp1Reg, 0);
5953     }
5954     subptr(len, 8);
5955     jccb(Assembler::greater, L_copy_8_chars_exit);
5956 
5957     bind(L_copy_8_chars);
5958     movdqu(tmp3Reg, Address(src, len, Address::times_2, -16));
5959     ptest(tmp3Reg, tmp1Reg);
5960     jccb(Assembler::notZero, L_copy_8_chars_exit);
5961     packuswb(tmp3Reg, tmp1Reg);
5962     movq(Address(dst, len, Address::times_1, -8), tmp3Reg);
5963     addptr(len, 8);
5964     jccb(Assembler::lessEqual, L_copy_8_chars);
5965 
5966     bind(L_copy_8_chars_exit);
5967     subptr(len, 8);
5968     jccb(Assembler::zero, L_done);
5969   }
5970 
5971   bind(L_copy_1_char);
5972   load_unsigned_short(tmp5, Address(src, len, Address::times_2, 0));
5973   testl(tmp5, 0xff00);      // check if Unicode char
5974   jccb(Assembler::notZero, L_copy_1_char_exit);
5975   movb(Address(dst, len, Address::times_1, 0), tmp5);
5976   addptr(len, 1);
5977   jccb(Assembler::less, L_copy_1_char);
5978 
5979   bind(L_copy_1_char_exit);
5980   addptr(result, len); // len is negative count of not processed elements
5981 
5982   bind(L_done);
5983 }
5984 
5985 #ifdef _LP64
5986 /**
5987  * Helper for multiply_to_len().
5988  */
5989 void MacroAssembler::add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2) {
5990   addq(dest_lo, src1);
5991   adcq(dest_hi, 0);
5992   addq(dest_lo, src2);
5993   adcq(dest_hi, 0);
5994 }
5995 
5996 /**
5997  * Multiply 64 bit by 64 bit first loop.
5998  */
5999 void MacroAssembler::multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
6000                                            Register y, Register y_idx, Register z,
6001                                            Register carry, Register product,
6002                                            Register idx, Register kdx) {
6003   //
6004   //  jlong carry, x[], y[], z[];
6005   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
6006   //    huge_128 product = y[idx] * x[xstart] + carry;
6007   //    z[kdx] = (jlong)product;
6008   //    carry  = (jlong)(product &gt;&gt;&gt; 64);
6009   //  }
6010   //  z[xstart] = carry;
6011   //
6012 
6013   Label L_first_loop, L_first_loop_exit;
6014   Label L_one_x, L_one_y, L_multiply;
6015 
6016   decrementl(xstart);
6017   jcc(Assembler::negative, L_one_x);
6018 
6019   movq(x_xstart, Address(x, xstart, Address::times_4,  0));
6020   rorq(x_xstart, 32); // convert big-endian to little-endian
6021 
6022   bind(L_first_loop);
6023   decrementl(idx);
6024   jcc(Assembler::negative, L_first_loop_exit);
6025   decrementl(idx);
6026   jcc(Assembler::negative, L_one_y);
6027   movq(y_idx, Address(y, idx, Address::times_4,  0));
6028   rorq(y_idx, 32); // convert big-endian to little-endian
6029   bind(L_multiply);
6030   movq(product, x_xstart);
6031   mulq(y_idx); // product(rax) * y_idx -&gt; rdx:rax
6032   addq(product, carry);
6033   adcq(rdx, 0);
6034   subl(kdx, 2);
6035   movl(Address(z, kdx, Address::times_4,  4), product);
6036   shrq(product, 32);
6037   movl(Address(z, kdx, Address::times_4,  0), product);
6038   movq(carry, rdx);
6039   jmp(L_first_loop);
6040 
6041   bind(L_one_y);
6042   movl(y_idx, Address(y,  0));
6043   jmp(L_multiply);
6044 
6045   bind(L_one_x);
6046   movl(x_xstart, Address(x,  0));
6047   jmp(L_first_loop);
6048 
6049   bind(L_first_loop_exit);
6050 }
6051 
6052 /**
6053  * Multiply 64 bit by 64 bit and add 128 bit.
6054  */
6055 void MacroAssembler::multiply_add_128_x_128(Register x_xstart, Register y, Register z,
6056                                             Register yz_idx, Register idx,
6057                                             Register carry, Register product, int offset) {
6058   //     huge_128 product = (y[idx] * x_xstart) + z[kdx] + carry;
6059   //     z[kdx] = (jlong)product;
6060 
6061   movq(yz_idx, Address(y, idx, Address::times_4,  offset));
6062   rorq(yz_idx, 32); // convert big-endian to little-endian
6063   movq(product, x_xstart);
6064   mulq(yz_idx);     // product(rax) * yz_idx -&gt; rdx:product(rax)
6065   movq(yz_idx, Address(z, idx, Address::times_4,  offset));
6066   rorq(yz_idx, 32); // convert big-endian to little-endian
6067 
6068   add2_with_carry(rdx, product, carry, yz_idx);
6069 
6070   movl(Address(z, idx, Address::times_4,  offset+4), product);
6071   shrq(product, 32);
6072   movl(Address(z, idx, Address::times_4,  offset), product);
6073 
6074 }
6075 
6076 /**
6077  * Multiply 128 bit by 128 bit. Unrolled inner loop.
6078  */
6079 void MacroAssembler::multiply_128_x_128_loop(Register x_xstart, Register y, Register z,
6080                                              Register yz_idx, Register idx, Register jdx,
6081                                              Register carry, Register product,
6082                                              Register carry2) {
6083   //   jlong carry, x[], y[], z[];
6084   //   int kdx = ystart+1;
6085   //   for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
6086   //     huge_128 product = (y[idx+1] * x_xstart) + z[kdx+idx+1] + carry;
6087   //     z[kdx+idx+1] = (jlong)product;
6088   //     jlong carry2  = (jlong)(product &gt;&gt;&gt; 64);
6089   //     product = (y[idx] * x_xstart) + z[kdx+idx] + carry2;
6090   //     z[kdx+idx] = (jlong)product;
6091   //     carry  = (jlong)(product &gt;&gt;&gt; 64);
6092   //   }
6093   //   idx += 2;
6094   //   if (idx &gt; 0) {
6095   //     product = (y[idx] * x_xstart) + z[kdx+idx] + carry;
6096   //     z[kdx+idx] = (jlong)product;
6097   //     carry  = (jlong)(product &gt;&gt;&gt; 64);
6098   //   }
6099   //
6100 
6101   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
6102 
6103   movl(jdx, idx);
6104   andl(jdx, 0xFFFFFFFC);
6105   shrl(jdx, 2);
6106 
6107   bind(L_third_loop);
6108   subl(jdx, 1);
6109   jcc(Assembler::negative, L_third_loop_exit);
6110   subl(idx, 4);
6111 
6112   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 8);
6113   movq(carry2, rdx);
6114 
6115   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry2, product, 0);
6116   movq(carry, rdx);
6117   jmp(L_third_loop);
6118 
6119   bind (L_third_loop_exit);
6120 
6121   andl (idx, 0x3);
6122   jcc(Assembler::zero, L_post_third_loop_done);
6123 
6124   Label L_check_1;
6125   subl(idx, 2);
6126   jcc(Assembler::negative, L_check_1);
6127 
6128   multiply_add_128_x_128(x_xstart, y, z, yz_idx, idx, carry, product, 0);
6129   movq(carry, rdx);
6130 
6131   bind (L_check_1);
6132   addl (idx, 0x2);
6133   andl (idx, 0x1);
6134   subl(idx, 1);
6135   jcc(Assembler::negative, L_post_third_loop_done);
6136 
6137   movl(yz_idx, Address(y, idx, Address::times_4,  0));
6138   movq(product, x_xstart);
6139   mulq(yz_idx); // product(rax) * yz_idx -&gt; rdx:product(rax)
6140   movl(yz_idx, Address(z, idx, Address::times_4,  0));
6141 
6142   add2_with_carry(rdx, product, yz_idx, carry);
6143 
6144   movl(Address(z, idx, Address::times_4,  0), product);
6145   shrq(product, 32);
6146 
6147   shlq(rdx, 32);
6148   orq(product, rdx);
6149   movq(carry, product);
6150 
6151   bind(L_post_third_loop_done);
6152 }
6153 
6154 /**
6155  * Multiply 128 bit by 128 bit using BMI2. Unrolled inner loop.
6156  *
6157  */
6158 void MacroAssembler::multiply_128_x_128_bmi2_loop(Register y, Register z,
6159                                                   Register carry, Register carry2,
6160                                                   Register idx, Register jdx,
6161                                                   Register yz_idx1, Register yz_idx2,
6162                                                   Register tmp, Register tmp3, Register tmp4) {
6163   assert(UseBMI2Instructions, &quot;should be used only when BMI2 is available&quot;);
6164 
6165   //   jlong carry, x[], y[], z[];
6166   //   int kdx = ystart+1;
6167   //   for (int idx=ystart-2; idx &gt;= 0; idx -= 2) { // Third loop
6168   //     huge_128 tmp3 = (y[idx+1] * rdx) + z[kdx+idx+1] + carry;
6169   //     jlong carry2  = (jlong)(tmp3 &gt;&gt;&gt; 64);
6170   //     huge_128 tmp4 = (y[idx]   * rdx) + z[kdx+idx] + carry2;
6171   //     carry  = (jlong)(tmp4 &gt;&gt;&gt; 64);
6172   //     z[kdx+idx+1] = (jlong)tmp3;
6173   //     z[kdx+idx] = (jlong)tmp4;
6174   //   }
6175   //   idx += 2;
6176   //   if (idx &gt; 0) {
6177   //     yz_idx1 = (y[idx] * rdx) + z[kdx+idx] + carry;
6178   //     z[kdx+idx] = (jlong)yz_idx1;
6179   //     carry  = (jlong)(yz_idx1 &gt;&gt;&gt; 64);
6180   //   }
6181   //
6182 
6183   Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;
6184 
6185   movl(jdx, idx);
6186   andl(jdx, 0xFFFFFFFC);
6187   shrl(jdx, 2);
6188 
6189   bind(L_third_loop);
6190   subl(jdx, 1);
6191   jcc(Assembler::negative, L_third_loop_exit);
6192   subl(idx, 4);
6193 
6194   movq(yz_idx1,  Address(y, idx, Address::times_4,  8));
6195   rorxq(yz_idx1, yz_idx1, 32); // convert big-endian to little-endian
6196   movq(yz_idx2, Address(y, idx, Address::times_4,  0));
6197   rorxq(yz_idx2, yz_idx2, 32);
6198 
6199   mulxq(tmp4, tmp3, yz_idx1);  //  yz_idx1 * rdx -&gt; tmp4:tmp3
6200   mulxq(carry2, tmp, yz_idx2); //  yz_idx2 * rdx -&gt; carry2:tmp
6201 
6202   movq(yz_idx1,  Address(z, idx, Address::times_4,  8));
6203   rorxq(yz_idx1, yz_idx1, 32);
6204   movq(yz_idx2, Address(z, idx, Address::times_4,  0));
6205   rorxq(yz_idx2, yz_idx2, 32);
6206 
6207   if (VM_Version::supports_adx()) {
6208     adcxq(tmp3, carry);
6209     adoxq(tmp3, yz_idx1);
6210 
6211     adcxq(tmp4, tmp);
6212     adoxq(tmp4, yz_idx2);
6213 
6214     movl(carry, 0); // does not affect flags
6215     adcxq(carry2, carry);
6216     adoxq(carry2, carry);
6217   } else {
6218     add2_with_carry(tmp4, tmp3, carry, yz_idx1);
6219     add2_with_carry(carry2, tmp4, tmp, yz_idx2);
6220   }
6221   movq(carry, carry2);
6222 
6223   movl(Address(z, idx, Address::times_4, 12), tmp3);
6224   shrq(tmp3, 32);
6225   movl(Address(z, idx, Address::times_4,  8), tmp3);
6226 
6227   movl(Address(z, idx, Address::times_4,  4), tmp4);
6228   shrq(tmp4, 32);
6229   movl(Address(z, idx, Address::times_4,  0), tmp4);
6230 
6231   jmp(L_third_loop);
6232 
6233   bind (L_third_loop_exit);
6234 
6235   andl (idx, 0x3);
6236   jcc(Assembler::zero, L_post_third_loop_done);
6237 
6238   Label L_check_1;
6239   subl(idx, 2);
6240   jcc(Assembler::negative, L_check_1);
6241 
6242   movq(yz_idx1, Address(y, idx, Address::times_4,  0));
6243   rorxq(yz_idx1, yz_idx1, 32);
6244   mulxq(tmp4, tmp3, yz_idx1); //  yz_idx1 * rdx -&gt; tmp4:tmp3
6245   movq(yz_idx2, Address(z, idx, Address::times_4,  0));
6246   rorxq(yz_idx2, yz_idx2, 32);
6247 
6248   add2_with_carry(tmp4, tmp3, carry, yz_idx2);
6249 
6250   movl(Address(z, idx, Address::times_4,  4), tmp3);
6251   shrq(tmp3, 32);
6252   movl(Address(z, idx, Address::times_4,  0), tmp3);
6253   movq(carry, tmp4);
6254 
6255   bind (L_check_1);
6256   addl (idx, 0x2);
6257   andl (idx, 0x1);
6258   subl(idx, 1);
6259   jcc(Assembler::negative, L_post_third_loop_done);
6260   movl(tmp4, Address(y, idx, Address::times_4,  0));
6261   mulxq(carry2, tmp3, tmp4);  //  tmp4 * rdx -&gt; carry2:tmp3
6262   movl(tmp4, Address(z, idx, Address::times_4,  0));
6263 
6264   add2_with_carry(carry2, tmp3, tmp4, carry);
6265 
6266   movl(Address(z, idx, Address::times_4,  0), tmp3);
6267   shrq(tmp3, 32);
6268 
6269   shlq(carry2, 32);
6270   orq(tmp3, carry2);
6271   movq(carry, tmp3);
6272 
6273   bind(L_post_third_loop_done);
6274 }
6275 
6276 /**
6277  * Code for BigInteger::multiplyToLen() instrinsic.
6278  *
6279  * rdi: x
6280  * rax: xlen
6281  * rsi: y
6282  * rcx: ylen
6283  * r8:  z
6284  * r11: zlen
6285  * r12: tmp1
6286  * r13: tmp2
6287  * r14: tmp3
6288  * r15: tmp4
6289  * rbx: tmp5
6290  *
6291  */
6292 void MacroAssembler::multiply_to_len(Register x, Register xlen, Register y, Register ylen, Register z, Register zlen,
6293                                      Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5) {
6294   ShortBranchVerifier sbv(this);
6295   assert_different_registers(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, rdx);
6296 
6297   push(tmp1);
6298   push(tmp2);
6299   push(tmp3);
6300   push(tmp4);
6301   push(tmp5);
6302 
6303   push(xlen);
6304   push(zlen);
6305 
6306   const Register idx = tmp1;
6307   const Register kdx = tmp2;
6308   const Register xstart = tmp3;
6309 
6310   const Register y_idx = tmp4;
6311   const Register carry = tmp5;
6312   const Register product  = xlen;
6313   const Register x_xstart = zlen;  // reuse register
6314 
6315   // First Loop.
6316   //
6317   //  final static long LONG_MASK = 0xffffffffL;
6318   //  int xstart = xlen - 1;
6319   //  int ystart = ylen - 1;
6320   //  long carry = 0;
6321   //  for (int idx=ystart, kdx=ystart+1+xstart; idx &gt;= 0; idx-, kdx--) {
6322   //    long product = (y[idx] &amp; LONG_MASK) * (x[xstart] &amp; LONG_MASK) + carry;
6323   //    z[kdx] = (int)product;
6324   //    carry = product &gt;&gt;&gt; 32;
6325   //  }
6326   //  z[xstart] = (int)carry;
6327   //
6328 
6329   movl(idx, ylen);      // idx = ylen;
6330   movl(kdx, zlen);      // kdx = xlen+ylen;
6331   xorq(carry, carry);   // carry = 0;
6332 
6333   Label L_done;
6334 
6335   movl(xstart, xlen);
6336   decrementl(xstart);
6337   jcc(Assembler::negative, L_done);
6338 
6339   multiply_64_x_64_loop(x, xstart, x_xstart, y, y_idx, z, carry, product, idx, kdx);
6340 
6341   Label L_second_loop;
6342   testl(kdx, kdx);
6343   jcc(Assembler::zero, L_second_loop);
6344 
6345   Label L_carry;
6346   subl(kdx, 1);
6347   jcc(Assembler::zero, L_carry);
6348 
6349   movl(Address(z, kdx, Address::times_4,  0), carry);
6350   shrq(carry, 32);
6351   subl(kdx, 1);
6352 
6353   bind(L_carry);
6354   movl(Address(z, kdx, Address::times_4,  0), carry);
6355 
6356   // Second and third (nested) loops.
6357   //
6358   // for (int i = xstart-1; i &gt;= 0; i--) { // Second loop
6359   //   carry = 0;
6360   //   for (int jdx=ystart, k=ystart+1+i; jdx &gt;= 0; jdx--, k--) { // Third loop
6361   //     long product = (y[jdx] &amp; LONG_MASK) * (x[i] &amp; LONG_MASK) +
6362   //                    (z[k] &amp; LONG_MASK) + carry;
6363   //     z[k] = (int)product;
6364   //     carry = product &gt;&gt;&gt; 32;
6365   //   }
6366   //   z[i] = (int)carry;
6367   // }
6368   //
6369   // i = xlen, j = tmp1, k = tmp2, carry = tmp5, x[i] = rdx
6370 
6371   const Register jdx = tmp1;
6372 
6373   bind(L_second_loop);
6374   xorl(carry, carry);    // carry = 0;
6375   movl(jdx, ylen);       // j = ystart+1
6376 
6377   subl(xstart, 1);       // i = xstart-1;
6378   jcc(Assembler::negative, L_done);
6379 
6380   push (z);
6381 
6382   Label L_last_x;
6383   lea(z, Address(z, xstart, Address::times_4, 4)); // z = z + k - j
6384   subl(xstart, 1);       // i = xstart-1;
6385   jcc(Assembler::negative, L_last_x);
6386 
6387   if (UseBMI2Instructions) {
6388     movq(rdx,  Address(x, xstart, Address::times_4,  0));
6389     rorxq(rdx, rdx, 32); // convert big-endian to little-endian
6390   } else {
6391     movq(x_xstart, Address(x, xstart, Address::times_4,  0));
6392     rorq(x_xstart, 32);  // convert big-endian to little-endian
6393   }
6394 
6395   Label L_third_loop_prologue;
6396   bind(L_third_loop_prologue);
6397 
6398   push (x);
6399   push (xstart);
6400   push (ylen);
6401 
6402 
6403   if (UseBMI2Instructions) {
6404     multiply_128_x_128_bmi2_loop(y, z, carry, x, jdx, ylen, product, tmp2, x_xstart, tmp3, tmp4);
6405   } else { // !UseBMI2Instructions
6406     multiply_128_x_128_loop(x_xstart, y, z, y_idx, jdx, ylen, carry, product, x);
6407   }
6408 
6409   pop(ylen);
6410   pop(xlen);
6411   pop(x);
6412   pop(z);
6413 
6414   movl(tmp3, xlen);
6415   addl(tmp3, 1);
6416   movl(Address(z, tmp3, Address::times_4,  0), carry);
6417   subl(tmp3, 1);
6418   jccb(Assembler::negative, L_done);
6419 
6420   shrq(carry, 32);
6421   movl(Address(z, tmp3, Address::times_4,  0), carry);
6422   jmp(L_second_loop);
6423 
6424   // Next infrequent code is moved outside loops.
6425   bind(L_last_x);
6426   if (UseBMI2Instructions) {
6427     movl(rdx, Address(x,  0));
6428   } else {
6429     movl(x_xstart, Address(x,  0));
6430   }
6431   jmp(L_third_loop_prologue);
6432 
6433   bind(L_done);
6434 
6435   pop(zlen);
6436   pop(xlen);
6437 
6438   pop(tmp5);
6439   pop(tmp4);
6440   pop(tmp3);
6441   pop(tmp2);
6442   pop(tmp1);
6443 }
6444 
6445 void MacroAssembler::vectorized_mismatch(Register obja, Register objb, Register length, Register log2_array_indxscale,
6446   Register result, Register tmp1, Register tmp2, XMMRegister rymm0, XMMRegister rymm1, XMMRegister rymm2){
6447   assert(UseSSE42Intrinsics, &quot;SSE4.2 must be enabled.&quot;);
6448   Label VECTOR16_LOOP, VECTOR8_LOOP, VECTOR4_LOOP;
6449   Label VECTOR8_TAIL, VECTOR4_TAIL;
6450   Label VECTOR32_NOT_EQUAL, VECTOR16_NOT_EQUAL, VECTOR8_NOT_EQUAL, VECTOR4_NOT_EQUAL;
6451   Label SAME_TILL_END, DONE;
6452   Label BYTES_LOOP, BYTES_TAIL, BYTES_NOT_EQUAL;
6453 
6454   //scale is in rcx in both Win64 and Unix
6455   ShortBranchVerifier sbv(this);
6456 
6457   shlq(length);
6458   xorq(result, result);
6459 
6460   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp;
6461       VM_Version::supports_avx512vlbw()) {
6462     Label VECTOR64_LOOP, VECTOR64_NOT_EQUAL, VECTOR32_TAIL;
6463 
6464     cmpq(length, 64);
6465     jcc(Assembler::less, VECTOR32_TAIL);
6466 
6467     movq(tmp1, length);
6468     andq(tmp1, 0x3F);      // tail count
6469     andq(length, ~(0x3F)); //vector count
6470 
6471     bind(VECTOR64_LOOP);
6472     // AVX512 code to compare 64 byte vectors.
6473     evmovdqub(rymm0, Address(obja, result), Assembler::AVX_512bit);
6474     evpcmpeqb(k7, rymm0, Address(objb, result), Assembler::AVX_512bit);
6475     kortestql(k7, k7);
6476     jcc(Assembler::aboveEqual, VECTOR64_NOT_EQUAL);     // mismatch
6477     addq(result, 64);
6478     subq(length, 64);
6479     jccb(Assembler::notZero, VECTOR64_LOOP);
6480 
6481     //bind(VECTOR64_TAIL);
6482     testq(tmp1, tmp1);
6483     jcc(Assembler::zero, SAME_TILL_END);
6484 
6485     //bind(VECTOR64_TAIL);
6486     // AVX512 code to compare upto 63 byte vectors.
6487     mov64(tmp2, 0xFFFFFFFFFFFFFFFF);
6488     shlxq(tmp2, tmp2, tmp1);
6489     notq(tmp2);
6490     kmovql(k3, tmp2);
6491 
6492     evmovdqub(rymm0, k3, Address(obja, result), Assembler::AVX_512bit);
6493     evpcmpeqb(k7, k3, rymm0, Address(objb, result), Assembler::AVX_512bit);
6494 
6495     ktestql(k7, k3);
6496     jcc(Assembler::below, SAME_TILL_END);     // not mismatch
6497 
6498     bind(VECTOR64_NOT_EQUAL);
6499     kmovql(tmp1, k7);
6500     notq(tmp1);
6501     tzcntq(tmp1, tmp1);
6502     addq(result, tmp1);
6503     shrq(result);
6504     jmp(DONE);
6505     bind(VECTOR32_TAIL);
6506   }
6507 
6508   cmpq(length, 8);
6509   jcc(Assembler::equal, VECTOR8_LOOP);
6510   jcc(Assembler::less, VECTOR4_TAIL);
6511 
6512   if (UseAVX &gt;= 2) {
6513     Label VECTOR16_TAIL, VECTOR32_LOOP;
6514 
6515     cmpq(length, 16);
6516     jcc(Assembler::equal, VECTOR16_LOOP);
6517     jcc(Assembler::less, VECTOR8_LOOP);
6518 
6519     cmpq(length, 32);
6520     jccb(Assembler::less, VECTOR16_TAIL);
6521 
6522     subq(length, 32);
6523     bind(VECTOR32_LOOP);
6524     vmovdqu(rymm0, Address(obja, result));
6525     vmovdqu(rymm1, Address(objb, result));
6526     vpxor(rymm2, rymm0, rymm1, Assembler::AVX_256bit);
6527     vptest(rymm2, rymm2);
6528     jcc(Assembler::notZero, VECTOR32_NOT_EQUAL);//mismatch found
6529     addq(result, 32);
6530     subq(length, 32);
6531     jcc(Assembler::greaterEqual, VECTOR32_LOOP);
6532     addq(length, 32);
6533     jcc(Assembler::equal, SAME_TILL_END);
6534     //falling through if less than 32 bytes left //close the branch here.
6535 
6536     bind(VECTOR16_TAIL);
6537     cmpq(length, 16);
6538     jccb(Assembler::less, VECTOR8_TAIL);
6539     bind(VECTOR16_LOOP);
6540     movdqu(rymm0, Address(obja, result));
6541     movdqu(rymm1, Address(objb, result));
6542     vpxor(rymm2, rymm0, rymm1, Assembler::AVX_128bit);
6543     ptest(rymm2, rymm2);
6544     jcc(Assembler::notZero, VECTOR16_NOT_EQUAL);//mismatch found
6545     addq(result, 16);
6546     subq(length, 16);
6547     jcc(Assembler::equal, SAME_TILL_END);
6548     //falling through if less than 16 bytes left
6549   } else {//regular intrinsics
6550 
6551     cmpq(length, 16);
6552     jccb(Assembler::less, VECTOR8_TAIL);
6553 
6554     subq(length, 16);
6555     bind(VECTOR16_LOOP);
6556     movdqu(rymm0, Address(obja, result));
6557     movdqu(rymm1, Address(objb, result));
6558     pxor(rymm0, rymm1);
6559     ptest(rymm0, rymm0);
6560     jcc(Assembler::notZero, VECTOR16_NOT_EQUAL);//mismatch found
6561     addq(result, 16);
6562     subq(length, 16);
6563     jccb(Assembler::greaterEqual, VECTOR16_LOOP);
6564     addq(length, 16);
6565     jcc(Assembler::equal, SAME_TILL_END);
6566     //falling through if less than 16 bytes left
6567   }
6568 
6569   bind(VECTOR8_TAIL);
6570   cmpq(length, 8);
6571   jccb(Assembler::less, VECTOR4_TAIL);
6572   bind(VECTOR8_LOOP);
6573   movq(tmp1, Address(obja, result));
6574   movq(tmp2, Address(objb, result));
6575   xorq(tmp1, tmp2);
6576   testq(tmp1, tmp1);
6577   jcc(Assembler::notZero, VECTOR8_NOT_EQUAL);//mismatch found
6578   addq(result, 8);
6579   subq(length, 8);
6580   jcc(Assembler::equal, SAME_TILL_END);
6581   //falling through if less than 8 bytes left
6582 
6583   bind(VECTOR4_TAIL);
6584   cmpq(length, 4);
6585   jccb(Assembler::less, BYTES_TAIL);
6586   bind(VECTOR4_LOOP);
6587   movl(tmp1, Address(obja, result));
6588   xorl(tmp1, Address(objb, result));
6589   testl(tmp1, tmp1);
6590   jcc(Assembler::notZero, VECTOR4_NOT_EQUAL);//mismatch found
6591   addq(result, 4);
6592   subq(length, 4);
6593   jcc(Assembler::equal, SAME_TILL_END);
6594   //falling through if less than 4 bytes left
6595 
6596   bind(BYTES_TAIL);
6597   bind(BYTES_LOOP);
6598   load_unsigned_byte(tmp1, Address(obja, result));
6599   load_unsigned_byte(tmp2, Address(objb, result));
6600   xorl(tmp1, tmp2);
6601   testl(tmp1, tmp1);
6602   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
6603   decq(length);
6604   jcc(Assembler::zero, SAME_TILL_END);
6605   incq(result);
6606   load_unsigned_byte(tmp1, Address(obja, result));
6607   load_unsigned_byte(tmp2, Address(objb, result));
6608   xorl(tmp1, tmp2);
6609   testl(tmp1, tmp1);
6610   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
6611   decq(length);
6612   jcc(Assembler::zero, SAME_TILL_END);
6613   incq(result);
6614   load_unsigned_byte(tmp1, Address(obja, result));
6615   load_unsigned_byte(tmp2, Address(objb, result));
6616   xorl(tmp1, tmp2);
6617   testl(tmp1, tmp1);
6618   jcc(Assembler::notZero, BYTES_NOT_EQUAL);//mismatch found
6619   jmp(SAME_TILL_END);
6620 
6621   if (UseAVX &gt;= 2) {
6622     bind(VECTOR32_NOT_EQUAL);
6623     vpcmpeqb(rymm2, rymm2, rymm2, Assembler::AVX_256bit);
6624     vpcmpeqb(rymm0, rymm0, rymm1, Assembler::AVX_256bit);
6625     vpxor(rymm0, rymm0, rymm2, Assembler::AVX_256bit);
6626     vpmovmskb(tmp1, rymm0);
6627     bsfq(tmp1, tmp1);
6628     addq(result, tmp1);
6629     shrq(result);
6630     jmp(DONE);
6631   }
6632 
6633   bind(VECTOR16_NOT_EQUAL);
6634   if (UseAVX &gt;= 2) {
6635     vpcmpeqb(rymm2, rymm2, rymm2, Assembler::AVX_128bit);
6636     vpcmpeqb(rymm0, rymm0, rymm1, Assembler::AVX_128bit);
6637     pxor(rymm0, rymm2);
6638   } else {
6639     pcmpeqb(rymm2, rymm2);
6640     pxor(rymm0, rymm1);
6641     pcmpeqb(rymm0, rymm1);
6642     pxor(rymm0, rymm2);
6643   }
6644   pmovmskb(tmp1, rymm0);
6645   bsfq(tmp1, tmp1);
6646   addq(result, tmp1);
6647   shrq(result);
6648   jmpb(DONE);
6649 
6650   bind(VECTOR8_NOT_EQUAL);
6651   bind(VECTOR4_NOT_EQUAL);
6652   bsfq(tmp1, tmp1);
6653   shrq(tmp1, 3);
6654   addq(result, tmp1);
6655   bind(BYTES_NOT_EQUAL);
6656   shrq(result);
6657   jmpb(DONE);
6658 
6659   bind(SAME_TILL_END);
6660   mov64(result, -1);
6661 
6662   bind(DONE);
6663 }
6664 
6665 //Helper functions for square_to_len()
6666 
6667 /**
6668  * Store the squares of x[], right shifted one bit (divided by 2) into z[]
6669  * Preserves x and z and modifies rest of the registers.
6670  */
6671 void MacroAssembler::square_rshift(Register x, Register xlen, Register z, Register tmp1, Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
6672   // Perform square and right shift by 1
6673   // Handle odd xlen case first, then for even xlen do the following
6674   // jlong carry = 0;
6675   // for (int j=0, i=0; j &lt; xlen; j+=2, i+=4) {
6676   //     huge_128 product = x[j:j+1] * x[j:j+1];
6677   //     z[i:i+1] = (carry &lt;&lt; 63) | (jlong)(product &gt;&gt;&gt; 65);
6678   //     z[i+2:i+3] = (jlong)(product &gt;&gt;&gt; 1);
6679   //     carry = (jlong)product;
6680   // }
6681 
6682   xorq(tmp5, tmp5);     // carry
6683   xorq(rdxReg, rdxReg);
6684   xorl(tmp1, tmp1);     // index for x
6685   xorl(tmp4, tmp4);     // index for z
6686 
6687   Label L_first_loop, L_first_loop_exit;
6688 
6689   testl(xlen, 1);
6690   jccb(Assembler::zero, L_first_loop); //jump if xlen is even
6691 
6692   // Square and right shift by 1 the odd element using 32 bit multiply
6693   movl(raxReg, Address(x, tmp1, Address::times_4, 0));
6694   imulq(raxReg, raxReg);
6695   shrq(raxReg, 1);
6696   adcq(tmp5, 0);
6697   movq(Address(z, tmp4, Address::times_4, 0), raxReg);
6698   incrementl(tmp1);
6699   addl(tmp4, 2);
6700 
6701   // Square and  right shift by 1 the rest using 64 bit multiply
6702   bind(L_first_loop);
6703   cmpptr(tmp1, xlen);
6704   jccb(Assembler::equal, L_first_loop_exit);
6705 
6706   // Square
6707   movq(raxReg, Address(x, tmp1, Address::times_4,  0));
6708   rorq(raxReg, 32);    // convert big-endian to little-endian
6709   mulq(raxReg);        // 64-bit multiply rax * rax -&gt; rdx:rax
6710 
6711   // Right shift by 1 and save carry
6712   shrq(tmp5, 1);       // rdx:rax:tmp5 = (tmp5:rdx:rax) &gt;&gt;&gt; 1
6713   rcrq(rdxReg, 1);
6714   rcrq(raxReg, 1);
6715   adcq(tmp5, 0);
6716 
6717   // Store result in z
6718   movq(Address(z, tmp4, Address::times_4, 0), rdxReg);
6719   movq(Address(z, tmp4, Address::times_4, 8), raxReg);
6720 
6721   // Update indices for x and z
6722   addl(tmp1, 2);
6723   addl(tmp4, 4);
6724   jmp(L_first_loop);
6725 
6726   bind(L_first_loop_exit);
6727 }
6728 
6729 
6730 /**
6731  * Perform the following multiply add operation using BMI2 instructions
6732  * carry:sum = sum + op1*op2 + carry
6733  * op2 should be in rdx
6734  * op2 is preserved, all other registers are modified
6735  */
6736 void MacroAssembler::multiply_add_64_bmi2(Register sum, Register op1, Register op2, Register carry, Register tmp2) {
6737   // assert op2 is rdx
6738   mulxq(tmp2, op1, op1);  //  op1 * op2 -&gt; tmp2:op1
6739   addq(sum, carry);
6740   adcq(tmp2, 0);
6741   addq(sum, op1);
6742   adcq(tmp2, 0);
6743   movq(carry, tmp2);
6744 }
6745 
6746 /**
6747  * Perform the following multiply add operation:
6748  * carry:sum = sum + op1*op2 + carry
6749  * Preserves op1, op2 and modifies rest of registers
6750  */
6751 void MacroAssembler::multiply_add_64(Register sum, Register op1, Register op2, Register carry, Register rdxReg, Register raxReg) {
6752   // rdx:rax = op1 * op2
6753   movq(raxReg, op2);
6754   mulq(op1);
6755 
6756   //  rdx:rax = sum + carry + rdx:rax
6757   addq(sum, carry);
6758   adcq(rdxReg, 0);
6759   addq(sum, raxReg);
6760   adcq(rdxReg, 0);
6761 
6762   // carry:sum = rdx:sum
6763   movq(carry, rdxReg);
6764 }
6765 
6766 /**
6767  * Add 64 bit long carry into z[] with carry propogation.
6768  * Preserves z and carry register values and modifies rest of registers.
6769  *
6770  */
6771 void MacroAssembler::add_one_64(Register z, Register zlen, Register carry, Register tmp1) {
6772   Label L_fourth_loop, L_fourth_loop_exit;
6773 
6774   movl(tmp1, 1);
6775   subl(zlen, 2);
6776   addq(Address(z, zlen, Address::times_4, 0), carry);
6777 
6778   bind(L_fourth_loop);
6779   jccb(Assembler::carryClear, L_fourth_loop_exit);
6780   subl(zlen, 2);
6781   jccb(Assembler::negative, L_fourth_loop_exit);
6782   addq(Address(z, zlen, Address::times_4, 0), tmp1);
6783   jmp(L_fourth_loop);
6784   bind(L_fourth_loop_exit);
6785 }
6786 
6787 /**
6788  * Shift z[] left by 1 bit.
6789  * Preserves x, len, z and zlen registers and modifies rest of the registers.
6790  *
6791  */
6792 void MacroAssembler::lshift_by_1(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2, Register tmp3, Register tmp4) {
6793 
6794   Label L_fifth_loop, L_fifth_loop_exit;
6795 
6796   // Fifth loop
6797   // Perform primitiveLeftShift(z, zlen, 1)
6798 
6799   const Register prev_carry = tmp1;
6800   const Register new_carry = tmp4;
6801   const Register value = tmp2;
6802   const Register zidx = tmp3;
6803 
6804   // int zidx, carry;
6805   // long value;
6806   // carry = 0;
6807   // for (zidx = zlen-2; zidx &gt;=0; zidx -= 2) {
6808   //    (carry:value)  = (z[i] &lt;&lt; 1) | carry ;
6809   //    z[i] = value;
6810   // }
6811 
6812   movl(zidx, zlen);
6813   xorl(prev_carry, prev_carry); // clear carry flag and prev_carry register
6814 
6815   bind(L_fifth_loop);
6816   decl(zidx);  // Use decl to preserve carry flag
6817   decl(zidx);
6818   jccb(Assembler::negative, L_fifth_loop_exit);
6819 
6820   if (UseBMI2Instructions) {
6821      movq(value, Address(z, zidx, Address::times_4, 0));
6822      rclq(value, 1);
6823      rorxq(value, value, 32);
6824      movq(Address(z, zidx, Address::times_4,  0), value);  // Store back in big endian form
6825   }
6826   else {
6827     // clear new_carry
6828     xorl(new_carry, new_carry);
6829 
6830     // Shift z[i] by 1, or in previous carry and save new carry
6831     movq(value, Address(z, zidx, Address::times_4, 0));
6832     shlq(value, 1);
6833     adcl(new_carry, 0);
6834 
6835     orq(value, prev_carry);
6836     rorq(value, 0x20);
6837     movq(Address(z, zidx, Address::times_4,  0), value);  // Store back in big endian form
6838 
6839     // Set previous carry = new carry
6840     movl(prev_carry, new_carry);
6841   }
6842   jmp(L_fifth_loop);
6843 
6844   bind(L_fifth_loop_exit);
6845 }
6846 
6847 
6848 /**
6849  * Code for BigInteger::squareToLen() intrinsic
6850  *
6851  * rdi: x
6852  * rsi: len
6853  * r8:  z
6854  * rcx: zlen
6855  * r12: tmp1
6856  * r13: tmp2
6857  * r14: tmp3
6858  * r15: tmp4
6859  * rbx: tmp5
6860  *
6861  */
6862 void MacroAssembler::square_to_len(Register x, Register len, Register z, Register zlen, Register tmp1, Register tmp2, Register tmp3, Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
6863 
6864   Label L_second_loop, L_second_loop_exit, L_third_loop, L_third_loop_exit, L_last_x, L_multiply;
6865   push(tmp1);
6866   push(tmp2);
6867   push(tmp3);
6868   push(tmp4);
6869   push(tmp5);
6870 
6871   // First loop
6872   // Store the squares, right shifted one bit (i.e., divided by 2).
6873   square_rshift(x, len, z, tmp1, tmp3, tmp4, tmp5, rdxReg, raxReg);
6874 
6875   // Add in off-diagonal sums.
6876   //
6877   // Second, third (nested) and fourth loops.
6878   // zlen +=2;
6879   // for (int xidx=len-2,zidx=zlen-4; xidx &gt; 0; xidx-=2,zidx-=4) {
6880   //    carry = 0;
6881   //    long op2 = x[xidx:xidx+1];
6882   //    for (int j=xidx-2,k=zidx; j &gt;= 0; j-=2) {
6883   //       k -= 2;
6884   //       long op1 = x[j:j+1];
6885   //       long sum = z[k:k+1];
6886   //       carry:sum = multiply_add_64(sum, op1, op2, carry, tmp_regs);
6887   //       z[k:k+1] = sum;
6888   //    }
6889   //    add_one_64(z, k, carry, tmp_regs);
6890   // }
6891 
6892   const Register carry = tmp5;
6893   const Register sum = tmp3;
6894   const Register op1 = tmp4;
6895   Register op2 = tmp2;
6896 
6897   push(zlen);
6898   push(len);
6899   addl(zlen,2);
6900   bind(L_second_loop);
6901   xorq(carry, carry);
6902   subl(zlen, 4);
6903   subl(len, 2);
6904   push(zlen);
6905   push(len);
6906   cmpl(len, 0);
6907   jccb(Assembler::lessEqual, L_second_loop_exit);
6908 
6909   // Multiply an array by one 64 bit long.
6910   if (UseBMI2Instructions) {
6911     op2 = rdxReg;
6912     movq(op2, Address(x, len, Address::times_4,  0));
6913     rorxq(op2, op2, 32);
6914   }
6915   else {
6916     movq(op2, Address(x, len, Address::times_4,  0));
6917     rorq(op2, 32);
6918   }
6919 
6920   bind(L_third_loop);
6921   decrementl(len);
6922   jccb(Assembler::negative, L_third_loop_exit);
6923   decrementl(len);
6924   jccb(Assembler::negative, L_last_x);
6925 
6926   movq(op1, Address(x, len, Address::times_4,  0));
6927   rorq(op1, 32);
6928 
6929   bind(L_multiply);
6930   subl(zlen, 2);
6931   movq(sum, Address(z, zlen, Address::times_4,  0));
6932 
6933   // Multiply 64 bit by 64 bit and add 64 bits lower half and upper 64 bits as carry.
6934   if (UseBMI2Instructions) {
6935     multiply_add_64_bmi2(sum, op1, op2, carry, tmp2);
6936   }
6937   else {
6938     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
6939   }
6940 
6941   movq(Address(z, zlen, Address::times_4, 0), sum);
6942 
6943   jmp(L_third_loop);
6944   bind(L_third_loop_exit);
6945 
6946   // Fourth loop
6947   // Add 64 bit long carry into z with carry propogation.
6948   // Uses offsetted zlen.
6949   add_one_64(z, zlen, carry, tmp1);
6950 
6951   pop(len);
6952   pop(zlen);
6953   jmp(L_second_loop);
6954 
6955   // Next infrequent code is moved outside loops.
6956   bind(L_last_x);
6957   movl(op1, Address(x, 0));
6958   jmp(L_multiply);
6959 
6960   bind(L_second_loop_exit);
6961   pop(len);
6962   pop(zlen);
6963   pop(len);
6964   pop(zlen);
6965 
6966   // Fifth loop
6967   // Shift z left 1 bit.
6968   lshift_by_1(x, len, z, zlen, tmp1, tmp2, tmp3, tmp4);
6969 
6970   // z[zlen-1] |= x[len-1] &amp; 1;
6971   movl(tmp3, Address(x, len, Address::times_4, -4));
6972   andl(tmp3, 1);
6973   orl(Address(z, zlen, Address::times_4,  -4), tmp3);
6974 
6975   pop(tmp5);
6976   pop(tmp4);
6977   pop(tmp3);
6978   pop(tmp2);
6979   pop(tmp1);
6980 }
6981 
6982 /**
6983  * Helper function for mul_add()
6984  * Multiply the in[] by int k and add to out[] starting at offset offs using
6985  * 128 bit by 32 bit multiply and return the carry in tmp5.
6986  * Only quad int aligned length of in[] is operated on in this function.
6987  * k is in rdxReg for BMI2Instructions, for others it is in tmp2.
6988  * This function preserves out, in and k registers.
6989  * len and offset point to the appropriate index in &quot;in&quot; &amp; &quot;out&quot; correspondingly
6990  * tmp5 has the carry.
6991  * other registers are temporary and are modified.
6992  *
6993  */
6994 void MacroAssembler::mul_add_128_x_32_loop(Register out, Register in,
6995   Register offset, Register len, Register tmp1, Register tmp2, Register tmp3,
6996   Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
6997 
6998   Label L_first_loop, L_first_loop_exit;
6999 
7000   movl(tmp1, len);
7001   shrl(tmp1, 2);
7002 
7003   bind(L_first_loop);
7004   subl(tmp1, 1);
7005   jccb(Assembler::negative, L_first_loop_exit);
7006 
7007   subl(len, 4);
7008   subl(offset, 4);
7009 
7010   Register op2 = tmp2;
7011   const Register sum = tmp3;
7012   const Register op1 = tmp4;
7013   const Register carry = tmp5;
7014 
7015   if (UseBMI2Instructions) {
7016     op2 = rdxReg;
7017   }
7018 
7019   movq(op1, Address(in, len, Address::times_4,  8));
7020   rorq(op1, 32);
7021   movq(sum, Address(out, offset, Address::times_4,  8));
7022   rorq(sum, 32);
7023   if (UseBMI2Instructions) {
7024     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
7025   }
7026   else {
7027     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
7028   }
7029   // Store back in big endian from little endian
7030   rorq(sum, 0x20);
7031   movq(Address(out, offset, Address::times_4,  8), sum);
7032 
7033   movq(op1, Address(in, len, Address::times_4,  0));
7034   rorq(op1, 32);
7035   movq(sum, Address(out, offset, Address::times_4,  0));
7036   rorq(sum, 32);
7037   if (UseBMI2Instructions) {
7038     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
7039   }
7040   else {
7041     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
7042   }
7043   // Store back in big endian from little endian
7044   rorq(sum, 0x20);
7045   movq(Address(out, offset, Address::times_4,  0), sum);
7046 
7047   jmp(L_first_loop);
7048   bind(L_first_loop_exit);
7049 }
7050 
7051 /**
7052  * Code for BigInteger::mulAdd() intrinsic
7053  *
7054  * rdi: out
7055  * rsi: in
7056  * r11: offs (out.length - offset)
7057  * rcx: len
7058  * r8:  k
7059  * r12: tmp1
7060  * r13: tmp2
7061  * r14: tmp3
7062  * r15: tmp4
7063  * rbx: tmp5
7064  * Multiply the in[] by word k and add to out[], return the carry in rax
7065  */
7066 void MacroAssembler::mul_add(Register out, Register in, Register offs,
7067    Register len, Register k, Register tmp1, Register tmp2, Register tmp3,
7068    Register tmp4, Register tmp5, Register rdxReg, Register raxReg) {
7069 
7070   Label L_carry, L_last_in, L_done;
7071 
7072 // carry = 0;
7073 // for (int j=len-1; j &gt;= 0; j--) {
7074 //    long product = (in[j] &amp; LONG_MASK) * kLong +
7075 //                   (out[offs] &amp; LONG_MASK) + carry;
7076 //    out[offs--] = (int)product;
7077 //    carry = product &gt;&gt;&gt; 32;
7078 // }
7079 //
7080   push(tmp1);
7081   push(tmp2);
7082   push(tmp3);
7083   push(tmp4);
7084   push(tmp5);
7085 
7086   Register op2 = tmp2;
7087   const Register sum = tmp3;
7088   const Register op1 = tmp4;
7089   const Register carry =  tmp5;
7090 
7091   if (UseBMI2Instructions) {
7092     op2 = rdxReg;
7093     movl(op2, k);
7094   }
7095   else {
7096     movl(op2, k);
7097   }
7098 
7099   xorq(carry, carry);
7100 
7101   //First loop
7102 
7103   //Multiply in[] by k in a 4 way unrolled loop using 128 bit by 32 bit multiply
7104   //The carry is in tmp5
7105   mul_add_128_x_32_loop(out, in, offs, len, tmp1, tmp2, tmp3, tmp4, tmp5, rdxReg, raxReg);
7106 
7107   //Multiply the trailing in[] entry using 64 bit by 32 bit, if any
7108   decrementl(len);
7109   jccb(Assembler::negative, L_carry);
7110   decrementl(len);
7111   jccb(Assembler::negative, L_last_in);
7112 
7113   movq(op1, Address(in, len, Address::times_4,  0));
7114   rorq(op1, 32);
7115 
7116   subl(offs, 2);
7117   movq(sum, Address(out, offs, Address::times_4,  0));
7118   rorq(sum, 32);
7119 
7120   if (UseBMI2Instructions) {
7121     multiply_add_64_bmi2(sum, op1, op2, carry, raxReg);
7122   }
7123   else {
7124     multiply_add_64(sum, op1, op2, carry, rdxReg, raxReg);
7125   }
7126 
7127   // Store back in big endian from little endian
7128   rorq(sum, 0x20);
7129   movq(Address(out, offs, Address::times_4,  0), sum);
7130 
7131   testl(len, len);
7132   jccb(Assembler::zero, L_carry);
7133 
7134   //Multiply the last in[] entry, if any
7135   bind(L_last_in);
7136   movl(op1, Address(in, 0));
7137   movl(sum, Address(out, offs, Address::times_4,  -4));
7138 
7139   movl(raxReg, k);
7140   mull(op1); //tmp4 * eax -&gt; edx:eax
7141   addl(sum, carry);
7142   adcl(rdxReg, 0);
7143   addl(sum, raxReg);
7144   adcl(rdxReg, 0);
7145   movl(carry, rdxReg);
7146 
7147   movl(Address(out, offs, Address::times_4,  -4), sum);
7148 
7149   bind(L_carry);
7150   //return tmp5/carry as carry in rax
7151   movl(rax, carry);
7152 
7153   bind(L_done);
7154   pop(tmp5);
7155   pop(tmp4);
7156   pop(tmp3);
7157   pop(tmp2);
7158   pop(tmp1);
7159 }
7160 #endif
7161 
7162 /**
7163  * Emits code to update CRC-32 with a byte value according to constants in table
7164  *
7165  * @param [in,out]crc   Register containing the crc.
7166  * @param [in]val       Register containing the byte to fold into the CRC.
7167  * @param [in]table     Register containing the table of crc constants.
7168  *
7169  * uint32_t crc;
7170  * val = crc_table[(val ^ crc) &amp; 0xFF];
7171  * crc = val ^ (crc &gt;&gt; 8);
7172  *
7173  */
7174 void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {
7175   xorl(val, crc);
7176   andl(val, 0xFF);
7177   shrl(crc, 8); // unsigned shift
7178   xorl(crc, Address(table, val, Address::times_4, 0));
7179 }
7180 
7181 /**
7182  * Fold 128-bit data chunk
7183  */
7184 void MacroAssembler::fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset) {
7185   if (UseAVX &gt; 0) {
7186     vpclmulhdq(xtmp, xK, xcrc); // [123:64]
7187     vpclmulldq(xcrc, xK, xcrc); // [63:0]
7188     vpxor(xcrc, xcrc, Address(buf, offset), 0 /* vector_len */);
7189     pxor(xcrc, xtmp);
7190   } else {
7191     movdqa(xtmp, xcrc);
7192     pclmulhdq(xtmp, xK);   // [123:64]
7193     pclmulldq(xcrc, xK);   // [63:0]
7194     pxor(xcrc, xtmp);
7195     movdqu(xtmp, Address(buf, offset));
7196     pxor(xcrc, xtmp);
7197   }
7198 }
7199 
7200 void MacroAssembler::fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, XMMRegister xbuf) {
7201   if (UseAVX &gt; 0) {
7202     vpclmulhdq(xtmp, xK, xcrc);
7203     vpclmulldq(xcrc, xK, xcrc);
7204     pxor(xcrc, xbuf);
7205     pxor(xcrc, xtmp);
7206   } else {
7207     movdqa(xtmp, xcrc);
7208     pclmulhdq(xtmp, xK);
7209     pclmulldq(xcrc, xK);
7210     pxor(xcrc, xbuf);
7211     pxor(xcrc, xtmp);
7212   }
7213 }
7214 
7215 /**
7216  * 8-bit folds to compute 32-bit CRC
7217  *
7218  * uint64_t xcrc;
7219  * timesXtoThe32[xcrc &amp; 0xFF] ^ (xcrc &gt;&gt; 8);
7220  */
7221 void MacroAssembler::fold_8bit_crc32(XMMRegister xcrc, Register table, XMMRegister xtmp, Register tmp) {
7222   movdl(tmp, xcrc);
7223   andl(tmp, 0xFF);
7224   movdl(xtmp, Address(table, tmp, Address::times_4, 0));
7225   psrldq(xcrc, 1); // unsigned shift one byte
7226   pxor(xcrc, xtmp);
7227 }
7228 
7229 /**
7230  * uint32_t crc;
7231  * timesXtoThe32[crc &amp; 0xFF] ^ (crc &gt;&gt; 8);
7232  */
7233 void MacroAssembler::fold_8bit_crc32(Register crc, Register table, Register tmp) {
7234   movl(tmp, crc);
7235   andl(tmp, 0xFF);
7236   shrl(crc, 8);
7237   xorl(crc, Address(table, tmp, Address::times_4, 0));
7238 }
7239 
7240 /**
7241  * @param crc   register containing existing CRC (32-bit)
7242  * @param buf   register pointing to input byte buffer (byte*)
7243  * @param len   register containing number of bytes
7244  * @param table register that will contain address of CRC table
7245  * @param tmp   scratch register
7246  */
7247 void MacroAssembler::kernel_crc32(Register crc, Register buf, Register len, Register table, Register tmp) {
7248   assert_different_registers(crc, buf, len, table, tmp, rax);
7249 
7250   Label L_tail, L_tail_restore, L_tail_loop, L_exit, L_align_loop, L_aligned;
7251   Label L_fold_tail, L_fold_128b, L_fold_512b, L_fold_512b_loop, L_fold_tail_loop;
7252 
7253   // For EVEX with VL and BW, provide a standard mask, VL = 128 will guide the merge
7254   // context for the registers used, where all instructions below are using 128-bit mode
7255   // On EVEX without VL and BW, these instructions will all be AVX.
7256   lea(table, ExternalAddress(StubRoutines::crc_table_addr()));
7257   notl(crc); // ~crc
7258   cmpl(len, 16);
7259   jcc(Assembler::less, L_tail);
7260 
7261   // Align buffer to 16 bytes
7262   movl(tmp, buf);
7263   andl(tmp, 0xF);
7264   jccb(Assembler::zero, L_aligned);
7265   subl(tmp,  16);
7266   addl(len, tmp);
7267 
7268   align(4);
7269   BIND(L_align_loop);
7270   movsbl(rax, Address(buf, 0)); // load byte with sign extension
7271   update_byte_crc32(crc, rax, table);
7272   increment(buf);
7273   incrementl(tmp);
7274   jccb(Assembler::less, L_align_loop);
7275 
7276   BIND(L_aligned);
7277   movl(tmp, len); // save
7278   shrl(len, 4);
7279   jcc(Assembler::zero, L_tail_restore);
7280 
7281   // Fold crc into first bytes of vector
7282   movdqa(xmm1, Address(buf, 0));
7283   movdl(rax, xmm1);
7284   xorl(crc, rax);
7285   if (VM_Version::supports_sse4_1()) {
7286     pinsrd(xmm1, crc, 0);
7287   } else {
7288     pinsrw(xmm1, crc, 0);
7289     shrl(crc, 16);
7290     pinsrw(xmm1, crc, 1);
7291   }
7292   addptr(buf, 16);
7293   subl(len, 4); // len &gt; 0
7294   jcc(Assembler::less, L_fold_tail);
7295 
7296   movdqa(xmm2, Address(buf,  0));
7297   movdqa(xmm3, Address(buf, 16));
7298   movdqa(xmm4, Address(buf, 32));
7299   addptr(buf, 48);
7300   subl(len, 3);
7301   jcc(Assembler::lessEqual, L_fold_512b);
7302 
7303   // Fold total 512 bits of polynomial on each iteration,
7304   // 128 bits per each of 4 parallel streams.
7305   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 32));
7306 
7307   align(32);
7308   BIND(L_fold_512b_loop);
7309   fold_128bit_crc32(xmm1, xmm0, xmm5, buf,  0);
7310   fold_128bit_crc32(xmm2, xmm0, xmm5, buf, 16);
7311   fold_128bit_crc32(xmm3, xmm0, xmm5, buf, 32);
7312   fold_128bit_crc32(xmm4, xmm0, xmm5, buf, 48);
7313   addptr(buf, 64);
7314   subl(len, 4);
7315   jcc(Assembler::greater, L_fold_512b_loop);
7316 
7317   // Fold 512 bits to 128 bits.
7318   BIND(L_fold_512b);
7319   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 16));
7320   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm2);
7321   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm3);
7322   fold_128bit_crc32(xmm1, xmm0, xmm5, xmm4);
7323 
7324   // Fold the rest of 128 bits data chunks
7325   BIND(L_fold_tail);
7326   addl(len, 3);
7327   jccb(Assembler::lessEqual, L_fold_128b);
7328   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr() + 16));
7329 
7330   BIND(L_fold_tail_loop);
7331   fold_128bit_crc32(xmm1, xmm0, xmm5, buf,  0);
7332   addptr(buf, 16);
7333   decrementl(len);
7334   jccb(Assembler::greater, L_fold_tail_loop);
7335 
7336   // Fold 128 bits in xmm1 down into 32 bits in crc register.
7337   BIND(L_fold_128b);
7338   movdqu(xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_addr()));
7339   if (UseAVX &gt; 0) {
7340     vpclmulqdq(xmm2, xmm0, xmm1, 0x1);
7341     vpand(xmm3, xmm0, xmm2, 0 /* vector_len */);
7342     vpclmulqdq(xmm0, xmm0, xmm3, 0x1);
7343   } else {
7344     movdqa(xmm2, xmm0);
7345     pclmulqdq(xmm2, xmm1, 0x1);
7346     movdqa(xmm3, xmm0);
7347     pand(xmm3, xmm2);
7348     pclmulqdq(xmm0, xmm3, 0x1);
7349   }
7350   psrldq(xmm1, 8);
7351   psrldq(xmm2, 4);
7352   pxor(xmm0, xmm1);
7353   pxor(xmm0, xmm2);
7354 
7355   // 8 8-bit folds to compute 32-bit CRC.
7356   for (int j = 0; j &lt; 4; j++) {
7357     fold_8bit_crc32(xmm0, table, xmm1, rax);
7358   }
7359   movdl(crc, xmm0); // mov 32 bits to general register
7360   for (int j = 0; j &lt; 4; j++) {
7361     fold_8bit_crc32(crc, table, rax);
7362   }
7363 
7364   BIND(L_tail_restore);
7365   movl(len, tmp); // restore
7366   BIND(L_tail);
7367   andl(len, 0xf);
7368   jccb(Assembler::zero, L_exit);
7369 
7370   // Fold the rest of bytes
7371   align(4);
7372   BIND(L_tail_loop);
7373   movsbl(rax, Address(buf, 0)); // load byte with sign extension
7374   update_byte_crc32(crc, rax, table);
7375   increment(buf);
7376   decrementl(len);
7377   jccb(Assembler::greater, L_tail_loop);
7378 
7379   BIND(L_exit);
7380   notl(crc); // ~c
7381 }
7382 
7383 #ifdef _LP64
7384 // Helper function for AVX 512 CRC32
7385 // Fold 512-bit data chunks
7386 void MacroAssembler::fold512bit_crc32_avx512(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf,
7387                                              Register pos, int offset) {
7388   evmovdquq(xmm3, Address(buf, pos, Address::times_1, offset), Assembler::AVX_512bit);
7389   evpclmulqdq(xtmp, xcrc, xK, 0x10, Assembler::AVX_512bit); // [123:64]
7390   evpclmulqdq(xmm2, xcrc, xK, 0x01, Assembler::AVX_512bit); // [63:0]
7391   evpxorq(xcrc, xtmp, xmm2, Assembler::AVX_512bit /* vector_len */);
7392   evpxorq(xcrc, xcrc, xmm3, Assembler::AVX_512bit /* vector_len */);
7393 }
7394 
7395 // Helper function for AVX 512 CRC32
7396 // Compute CRC32 for &lt; 256B buffers
7397 void MacroAssembler::kernel_crc32_avx512_256B(Register crc, Register buf, Register len, Register key, Register pos,
7398                                               Register tmp1, Register tmp2, Label&amp; L_barrett, Label&amp; L_16B_reduction_loop,
7399                                               Label&amp; L_get_last_two_xmms, Label&amp; L_128_done, Label&amp; L_cleanup) {
7400 
7401   Label L_less_than_32, L_exact_16_left, L_less_than_16_left;
7402   Label L_less_than_8_left, L_less_than_4_left, L_less_than_2_left, L_zero_left;
7403   Label L_only_less_than_4, L_only_less_than_3, L_only_less_than_2;
7404 
7405   // check if there is enough buffer to be able to fold 16B at a time
7406   cmpl(len, 32);
7407   jcc(Assembler::less, L_less_than_32);
7408 
7409   // if there is, load the constants
7410   movdqu(xmm10, Address(key, 1 * 16));    //rk1 and rk2 in xmm10
7411   movdl(xmm0, crc);                        // get the initial crc value
7412   movdqu(xmm7, Address(buf, pos, Address::times_1, 0 * 16)); //load the plaintext
7413   pxor(xmm7, xmm0);
7414 
7415   // update the buffer pointer
7416   addl(pos, 16);
7417   //update the counter.subtract 32 instead of 16 to save one instruction from the loop
7418   subl(len, 32);
7419   jmp(L_16B_reduction_loop);
7420 
7421   bind(L_less_than_32);
7422   //mov initial crc to the return value. this is necessary for zero - length buffers.
7423   movl(rax, crc);
7424   testl(len, len);
7425   jcc(Assembler::equal, L_cleanup);
7426 
7427   movdl(xmm0, crc);                        //get the initial crc value
7428 
7429   cmpl(len, 16);
7430   jcc(Assembler::equal, L_exact_16_left);
7431   jcc(Assembler::less, L_less_than_16_left);
7432 
7433   movdqu(xmm7, Address(buf, pos, Address::times_1, 0 * 16)); //load the plaintext
7434   pxor(xmm7, xmm0);                       //xor the initial crc value
7435   addl(pos, 16);
7436   subl(len, 16);
7437   movdqu(xmm10, Address(key, 1 * 16));    // rk1 and rk2 in xmm10
7438   jmp(L_get_last_two_xmms);
7439 
7440   bind(L_less_than_16_left);
7441   //use stack space to load data less than 16 bytes, zero - out the 16B in memory first.
7442   pxor(xmm1, xmm1);
7443   movptr(tmp1, rsp);
7444   movdqu(Address(tmp1, 0 * 16), xmm1);
7445 
7446   cmpl(len, 4);
7447   jcc(Assembler::less, L_only_less_than_4);
7448 
7449   //backup the counter value
7450   movl(tmp2, len);
7451   cmpl(len, 8);
7452   jcc(Assembler::less, L_less_than_8_left);
7453 
7454   //load 8 Bytes
7455   movq(rax, Address(buf, pos, Address::times_1, 0 * 16));
7456   movq(Address(tmp1, 0 * 16), rax);
7457   addptr(tmp1, 8);
7458   subl(len, 8);
7459   addl(pos, 8);
7460 
7461   bind(L_less_than_8_left);
7462   cmpl(len, 4);
7463   jcc(Assembler::less, L_less_than_4_left);
7464 
7465   //load 4 Bytes
7466   movl(rax, Address(buf, pos, Address::times_1, 0));
7467   movl(Address(tmp1, 0 * 16), rax);
7468   addptr(tmp1, 4);
7469   subl(len, 4);
7470   addl(pos, 4);
7471 
7472   bind(L_less_than_4_left);
7473   cmpl(len, 2);
7474   jcc(Assembler::less, L_less_than_2_left);
7475 
7476   // load 2 Bytes
7477   movw(rax, Address(buf, pos, Address::times_1, 0));
7478   movl(Address(tmp1, 0 * 16), rax);
7479   addptr(tmp1, 2);
7480   subl(len, 2);
7481   addl(pos, 2);
7482 
7483   bind(L_less_than_2_left);
7484   cmpl(len, 1);
7485   jcc(Assembler::less, L_zero_left);
7486 
7487   // load 1 Byte
7488   movb(rax, Address(buf, pos, Address::times_1, 0));
7489   movb(Address(tmp1, 0 * 16), rax);
7490 
7491   bind(L_zero_left);
7492   movdqu(xmm7, Address(rsp, 0));
7493   pxor(xmm7, xmm0);                       //xor the initial crc value
7494 
7495   lea(rax, ExternalAddress(StubRoutines::x86::shuf_table_crc32_avx512_addr()));
7496   movdqu(xmm0, Address(rax, tmp2));
7497   pshufb(xmm7, xmm0);
7498   jmp(L_128_done);
7499 
7500   bind(L_exact_16_left);
7501   movdqu(xmm7, Address(buf, pos, Address::times_1, 0));
7502   pxor(xmm7, xmm0);                       //xor the initial crc value
7503   jmp(L_128_done);
7504 
7505   bind(L_only_less_than_4);
7506   cmpl(len, 3);
7507   jcc(Assembler::less, L_only_less_than_3);
7508 
7509   // load 3 Bytes
7510   movb(rax, Address(buf, pos, Address::times_1, 0));
7511   movb(Address(tmp1, 0), rax);
7512 
7513   movb(rax, Address(buf, pos, Address::times_1, 1));
7514   movb(Address(tmp1, 1), rax);
7515 
7516   movb(rax, Address(buf, pos, Address::times_1, 2));
7517   movb(Address(tmp1, 2), rax);
7518 
7519   movdqu(xmm7, Address(rsp, 0));
7520   pxor(xmm7, xmm0);                     //xor the initial crc value
7521 
7522   pslldq(xmm7, 0x5);
7523   jmp(L_barrett);
7524   bind(L_only_less_than_3);
7525   cmpl(len, 2);
7526   jcc(Assembler::less, L_only_less_than_2);
7527 
7528   // load 2 Bytes
7529   movb(rax, Address(buf, pos, Address::times_1, 0));
7530   movb(Address(tmp1, 0), rax);
7531 
7532   movb(rax, Address(buf, pos, Address::times_1, 1));
7533   movb(Address(tmp1, 1), rax);
7534 
7535   movdqu(xmm7, Address(rsp, 0));
7536   pxor(xmm7, xmm0);                     //xor the initial crc value
7537 
7538   pslldq(xmm7, 0x6);
7539   jmp(L_barrett);
7540 
7541   bind(L_only_less_than_2);
7542   //load 1 Byte
7543   movb(rax, Address(buf, pos, Address::times_1, 0));
7544   movb(Address(tmp1, 0), rax);
7545 
7546   movdqu(xmm7, Address(rsp, 0));
7547   pxor(xmm7, xmm0);                     //xor the initial crc value
7548 
7549   pslldq(xmm7, 0x7);
7550 }
7551 
7552 /**
7553 * Compute CRC32 using AVX512 instructions
7554 * param crc   register containing existing CRC (32-bit)
7555 * param buf   register pointing to input byte buffer (byte*)
7556 * param len   register containing number of bytes
7557 * param tmp1  scratch register
7558 * param tmp2  scratch register
7559 * return rax  result register
7560 */
7561 void MacroAssembler::kernel_crc32_avx512(Register crc, Register buf, Register len, Register key, Register tmp1, Register tmp2) {
7562   assert_different_registers(crc, buf, len, key, tmp1, tmp2, rax);
7563 
7564   Label L_tail, L_tail_restore, L_tail_loop, L_exit, L_align_loop, L_aligned;
7565   Label L_fold_tail, L_fold_128b, L_fold_512b, L_fold_512b_loop, L_fold_tail_loop;
7566   Label L_less_than_256, L_fold_128_B_loop, L_fold_256_B_loop;
7567   Label L_fold_128_B_register, L_final_reduction_for_128, L_16B_reduction_loop;
7568   Label L_128_done, L_get_last_two_xmms, L_barrett, L_cleanup;
7569 
7570   const Register pos = r12;
7571   push(r12);
7572   subptr(rsp, 16 * 2 + 8);
7573 
7574   // For EVEX with VL and BW, provide a standard mask, VL = 128 will guide the merge
7575   // context for the registers used, where all instructions below are using 128-bit mode
7576   // On EVEX without VL and BW, these instructions will all be AVX.
7577   lea(key, ExternalAddress(StubRoutines::x86::crc_table_avx512_addr()));
7578   notl(crc);
7579   movl(pos, 0);
7580 
7581   // check if smaller than 256B
7582   cmpl(len, 256);
7583   jcc(Assembler::less, L_less_than_256);
7584 
7585   // load the initial crc value
7586   movdl(xmm10, crc);
7587 
7588   // receive the initial 64B data, xor the initial crc value
7589   evmovdquq(xmm0, Address(buf, pos, Address::times_1, 0 * 64), Assembler::AVX_512bit);
7590   evmovdquq(xmm4, Address(buf, pos, Address::times_1, 1 * 64), Assembler::AVX_512bit);
7591   evpxorq(xmm0, xmm0, xmm10, Assembler::AVX_512bit);
7592   evbroadcasti32x4(xmm10, Address(key, 2 * 16), Assembler::AVX_512bit); //zmm10 has rk3 and rk4
7593 
7594   subl(len, 256);
7595   cmpl(len, 256);
7596   jcc(Assembler::less, L_fold_128_B_loop);
7597 
7598   evmovdquq(xmm7, Address(buf, pos, Address::times_1, 2 * 64), Assembler::AVX_512bit);
7599   evmovdquq(xmm8, Address(buf, pos, Address::times_1, 3 * 64), Assembler::AVX_512bit);
7600   evbroadcasti32x4(xmm16, Address(key, 0 * 16), Assembler::AVX_512bit); //zmm16 has rk-1 and rk-2
7601   subl(len, 256);
7602 
7603   bind(L_fold_256_B_loop);
7604   addl(pos, 256);
7605   fold512bit_crc32_avx512(xmm0, xmm16, xmm1, buf, pos, 0 * 64);
7606   fold512bit_crc32_avx512(xmm4, xmm16, xmm1, buf, pos, 1 * 64);
7607   fold512bit_crc32_avx512(xmm7, xmm16, xmm1, buf, pos, 2 * 64);
7608   fold512bit_crc32_avx512(xmm8, xmm16, xmm1, buf, pos, 3 * 64);
7609 
7610   subl(len, 256);
7611   jcc(Assembler::greaterEqual, L_fold_256_B_loop);
7612 
7613   // Fold 256 into 128
7614   addl(pos, 256);
7615   evpclmulqdq(xmm1, xmm0, xmm10, 0x01, Assembler::AVX_512bit);
7616   evpclmulqdq(xmm2, xmm0, xmm10, 0x10, Assembler::AVX_512bit);
7617   vpternlogq(xmm7, 0x96, xmm1, xmm2, Assembler::AVX_512bit); // xor ABC
7618 
7619   evpclmulqdq(xmm5, xmm4, xmm10, 0x01, Assembler::AVX_512bit);
7620   evpclmulqdq(xmm6, xmm4, xmm10, 0x10, Assembler::AVX_512bit);
7621   vpternlogq(xmm8, 0x96, xmm5, xmm6, Assembler::AVX_512bit); // xor ABC
7622 
7623   evmovdquq(xmm0, xmm7, Assembler::AVX_512bit);
7624   evmovdquq(xmm4, xmm8, Assembler::AVX_512bit);
7625 
7626   addl(len, 128);
7627   jmp(L_fold_128_B_register);
7628 
7629   // at this section of the code, there is 128 * x + y(0 &lt;= y&lt;128) bytes of buffer.The fold_128_B_loop
7630   // loop will fold 128B at a time until we have 128 + y Bytes of buffer
7631 
7632   // fold 128B at a time.This section of the code folds 8 xmm registers in parallel
7633   bind(L_fold_128_B_loop);
7634   addl(pos, 128);
7635   fold512bit_crc32_avx512(xmm0, xmm10, xmm1, buf, pos, 0 * 64);
7636   fold512bit_crc32_avx512(xmm4, xmm10, xmm1, buf, pos, 1 * 64);
7637 
7638   subl(len, 128);
7639   jcc(Assembler::greaterEqual, L_fold_128_B_loop);
7640 
7641   addl(pos, 128);
7642 
7643   // at this point, the buffer pointer is pointing at the last y Bytes of the buffer, where 0 &lt;= y &lt; 128
7644   // the 128B of folded data is in 8 of the xmm registers : xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7
7645   bind(L_fold_128_B_register);
7646   evmovdquq(xmm16, Address(key, 5 * 16), Assembler::AVX_512bit); // multiply by rk9-rk16
7647   evmovdquq(xmm11, Address(key, 9 * 16), Assembler::AVX_512bit); // multiply by rk17-rk20, rk1,rk2, 0,0
7648   evpclmulqdq(xmm1, xmm0, xmm16, 0x01, Assembler::AVX_512bit);
7649   evpclmulqdq(xmm2, xmm0, xmm16, 0x10, Assembler::AVX_512bit);
7650   // save last that has no multiplicand
7651   vextracti64x2(xmm7, xmm4, 3);
7652 
7653   evpclmulqdq(xmm5, xmm4, xmm11, 0x01, Assembler::AVX_512bit);
7654   evpclmulqdq(xmm6, xmm4, xmm11, 0x10, Assembler::AVX_512bit);
7655   // Needed later in reduction loop
7656   movdqu(xmm10, Address(key, 1 * 16));
7657   vpternlogq(xmm1, 0x96, xmm2, xmm5, Assembler::AVX_512bit); // xor ABC
7658   vpternlogq(xmm1, 0x96, xmm6, xmm7, Assembler::AVX_512bit); // xor ABC
7659 
7660   // Swap 1,0,3,2 - 01 00 11 10
7661   evshufi64x2(xmm8, xmm1, xmm1, 0x4e, Assembler::AVX_512bit);
7662   evpxorq(xmm8, xmm8, xmm1, Assembler::AVX_256bit);
7663   vextracti128(xmm5, xmm8, 1);
7664   evpxorq(xmm7, xmm5, xmm8, Assembler::AVX_128bit);
7665 
7666   // instead of 128, we add 128 - 16 to the loop counter to save 1 instruction from the loop
7667   // instead of a cmp instruction, we use the negative flag with the jl instruction
7668   addl(len, 128 - 16);
7669   jcc(Assembler::less, L_final_reduction_for_128);
7670 
7671   bind(L_16B_reduction_loop);
7672   vpclmulqdq(xmm8, xmm7, xmm10, 0x1);
7673   vpclmulqdq(xmm7, xmm7, xmm10, 0x10);
7674   vpxor(xmm7, xmm7, xmm8, Assembler::AVX_128bit);
7675   movdqu(xmm0, Address(buf, pos, Address::times_1, 0 * 16));
7676   vpxor(xmm7, xmm7, xmm0, Assembler::AVX_128bit);
7677   addl(pos, 16);
7678   subl(len, 16);
7679   jcc(Assembler::greaterEqual, L_16B_reduction_loop);
7680 
7681   bind(L_final_reduction_for_128);
7682   addl(len, 16);
7683   jcc(Assembler::equal, L_128_done);
7684 
7685   bind(L_get_last_two_xmms);
7686   movdqu(xmm2, xmm7);
7687   addl(pos, len);
7688   movdqu(xmm1, Address(buf, pos, Address::times_1, -16));
7689   subl(pos, len);
7690 
7691   // get rid of the extra data that was loaded before
7692   // load the shift constant
7693   lea(rax, ExternalAddress(StubRoutines::x86::shuf_table_crc32_avx512_addr()));
7694   movdqu(xmm0, Address(rax, len));
7695   addl(rax, len);
7696 
7697   vpshufb(xmm7, xmm7, xmm0, Assembler::AVX_128bit);
7698   //Change mask to 512
7699   vpxor(xmm0, xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_avx512_addr() + 2 * 16), Assembler::AVX_128bit, tmp2);
7700   vpshufb(xmm2, xmm2, xmm0, Assembler::AVX_128bit);
7701 
7702   blendvpb(xmm2, xmm2, xmm1, xmm0, Assembler::AVX_128bit);
7703   vpclmulqdq(xmm8, xmm7, xmm10, 0x1);
7704   vpclmulqdq(xmm7, xmm7, xmm10, 0x10);
7705   vpxor(xmm7, xmm7, xmm8, Assembler::AVX_128bit);
7706   vpxor(xmm7, xmm7, xmm2, Assembler::AVX_128bit);
7707 
7708   bind(L_128_done);
7709   // compute crc of a 128-bit value
7710   movdqu(xmm10, Address(key, 3 * 16));
7711   movdqu(xmm0, xmm7);
7712 
7713   // 64b fold
7714   vpclmulqdq(xmm7, xmm7, xmm10, 0x0);
7715   vpsrldq(xmm0, xmm0, 0x8, Assembler::AVX_128bit);
7716   vpxor(xmm7, xmm7, xmm0, Assembler::AVX_128bit);
7717 
7718   // 32b fold
7719   movdqu(xmm0, xmm7);
7720   vpslldq(xmm7, xmm7, 0x4, Assembler::AVX_128bit);
7721   vpclmulqdq(xmm7, xmm7, xmm10, 0x10);
7722   vpxor(xmm7, xmm7, xmm0, Assembler::AVX_128bit);
7723   jmp(L_barrett);
7724 
7725   bind(L_less_than_256);
7726   kernel_crc32_avx512_256B(crc, buf, len, key, pos, tmp1, tmp2, L_barrett, L_16B_reduction_loop, L_get_last_two_xmms, L_128_done, L_cleanup);
7727 
7728   //barrett reduction
7729   bind(L_barrett);
7730   vpand(xmm7, xmm7, ExternalAddress(StubRoutines::x86::crc_by128_masks_avx512_addr() + 1 * 16), Assembler::AVX_128bit, tmp2);
7731   movdqu(xmm1, xmm7);
7732   movdqu(xmm2, xmm7);
7733   movdqu(xmm10, Address(key, 4 * 16));
7734 
7735   pclmulqdq(xmm7, xmm10, 0x0);
7736   pxor(xmm7, xmm2);
7737   vpand(xmm7, xmm7, ExternalAddress(StubRoutines::x86::crc_by128_masks_avx512_addr()), Assembler::AVX_128bit, tmp2);
7738   movdqu(xmm2, xmm7);
7739   pclmulqdq(xmm7, xmm10, 0x10);
7740   pxor(xmm7, xmm2);
7741   pxor(xmm7, xmm1);
7742   pextrd(crc, xmm7, 2);
7743 
7744   bind(L_cleanup);
7745   notl(crc); // ~c
7746   addptr(rsp, 16 * 2 + 8);
7747   pop(r12);
7748 }
7749 
7750 // S. Gueron / Information Processing Letters 112 (2012) 184
7751 // Algorithm 4: Computing carry-less multiplication using a precomputed lookup table.
7752 // Input: A 32 bit value B = [byte3, byte2, byte1, byte0].
7753 // Output: the 64-bit carry-less product of B * CONST
7754 void MacroAssembler::crc32c_ipl_alg4(Register in, uint32_t n,
7755                                      Register tmp1, Register tmp2, Register tmp3) {
7756   lea(tmp3, ExternalAddress(StubRoutines::crc32c_table_addr()));
7757   if (n &gt; 0) {
7758     addq(tmp3, n * 256 * 8);
7759   }
7760   //    Q1 = TABLEExt[n][B &amp; 0xFF];
7761   movl(tmp1, in);
7762   andl(tmp1, 0x000000FF);
7763   shll(tmp1, 3);
7764   addq(tmp1, tmp3);
7765   movq(tmp1, Address(tmp1, 0));
7766 
7767   //    Q2 = TABLEExt[n][B &gt;&gt; 8 &amp; 0xFF];
7768   movl(tmp2, in);
7769   shrl(tmp2, 8);
7770   andl(tmp2, 0x000000FF);
7771   shll(tmp2, 3);
7772   addq(tmp2, tmp3);
7773   movq(tmp2, Address(tmp2, 0));
7774 
7775   shlq(tmp2, 8);
7776   xorq(tmp1, tmp2);
7777 
7778   //    Q3 = TABLEExt[n][B &gt;&gt; 16 &amp; 0xFF];
7779   movl(tmp2, in);
7780   shrl(tmp2, 16);
7781   andl(tmp2, 0x000000FF);
7782   shll(tmp2, 3);
7783   addq(tmp2, tmp3);
7784   movq(tmp2, Address(tmp2, 0));
7785 
7786   shlq(tmp2, 16);
7787   xorq(tmp1, tmp2);
7788 
7789   //    Q4 = TABLEExt[n][B &gt;&gt; 24 &amp; 0xFF];
7790   shrl(in, 24);
7791   andl(in, 0x000000FF);
7792   shll(in, 3);
7793   addq(in, tmp3);
7794   movq(in, Address(in, 0));
7795 
7796   shlq(in, 24);
7797   xorq(in, tmp1);
7798   //    return Q1 ^ Q2 &lt;&lt; 8 ^ Q3 &lt;&lt; 16 ^ Q4 &lt;&lt; 24;
7799 }
7800 
7801 void MacroAssembler::crc32c_pclmulqdq(XMMRegister w_xtmp1,
7802                                       Register in_out,
7803                                       uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
7804                                       XMMRegister w_xtmp2,
7805                                       Register tmp1,
7806                                       Register n_tmp2, Register n_tmp3) {
7807   if (is_pclmulqdq_supported) {
7808     movdl(w_xtmp1, in_out); // modified blindly
7809 
7810     movl(tmp1, const_or_pre_comp_const_index);
7811     movdl(w_xtmp2, tmp1);
7812     pclmulqdq(w_xtmp1, w_xtmp2, 0);
7813 
7814     movdq(in_out, w_xtmp1);
7815   } else {
7816     crc32c_ipl_alg4(in_out, const_or_pre_comp_const_index, tmp1, n_tmp2, n_tmp3);
7817   }
7818 }
7819 
7820 // Recombination Alternative 2: No bit-reflections
7821 // T1 = (CRC_A * U1) &lt;&lt; 1
7822 // T2 = (CRC_B * U2) &lt;&lt; 1
7823 // C1 = T1 &gt;&gt; 32
7824 // C2 = T2 &gt;&gt; 32
7825 // T1 = T1 &amp; 0xFFFFFFFF
7826 // T2 = T2 &amp; 0xFFFFFFFF
7827 // T1 = CRC32(0, T1)
7828 // T2 = CRC32(0, T2)
7829 // C1 = C1 ^ T1
7830 // C2 = C2 ^ T2
7831 // CRC = C1 ^ C2 ^ CRC_C
7832 void MacroAssembler::crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
7833                                      XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7834                                      Register tmp1, Register tmp2,
7835                                      Register n_tmp3) {
7836   crc32c_pclmulqdq(w_xtmp1, in_out, const_or_pre_comp_const_index_u1, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
7837   crc32c_pclmulqdq(w_xtmp2, in1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
7838   shlq(in_out, 1);
7839   movl(tmp1, in_out);
7840   shrq(in_out, 32);
7841   xorl(tmp2, tmp2);
7842   crc32(tmp2, tmp1, 4);
7843   xorl(in_out, tmp2); // we don&#39;t care about upper 32 bit contents here
7844   shlq(in1, 1);
7845   movl(tmp1, in1);
7846   shrq(in1, 32);
7847   xorl(tmp2, tmp2);
7848   crc32(tmp2, tmp1, 4);
7849   xorl(in1, tmp2);
7850   xorl(in_out, in1);
7851   xorl(in_out, in2);
7852 }
7853 
7854 // Set N to predefined value
7855 // Subtract from a lenght of a buffer
7856 // execute in a loop:
7857 // CRC_A = 0xFFFFFFFF, CRC_B = 0, CRC_C = 0
7858 // for i = 1 to N do
7859 //  CRC_A = CRC32(CRC_A, A[i])
7860 //  CRC_B = CRC32(CRC_B, B[i])
7861 //  CRC_C = CRC32(CRC_C, C[i])
7862 // end for
7863 // Recombine
7864 void MacroAssembler::crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
7865                                        Register in_out1, Register in_out2, Register in_out3,
7866                                        Register tmp1, Register tmp2, Register tmp3,
7867                                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7868                                        Register tmp4, Register tmp5,
7869                                        Register n_tmp6) {
7870   Label L_processPartitions;
7871   Label L_processPartition;
7872   Label L_exit;
7873 
7874   bind(L_processPartitions);
7875   cmpl(in_out1, 3 * size);
7876   jcc(Assembler::less, L_exit);
7877     xorl(tmp1, tmp1);
7878     xorl(tmp2, tmp2);
7879     movq(tmp3, in_out2);
7880     addq(tmp3, size);
7881 
7882     bind(L_processPartition);
7883       crc32(in_out3, Address(in_out2, 0), 8);
7884       crc32(tmp1, Address(in_out2, size), 8);
7885       crc32(tmp2, Address(in_out2, size * 2), 8);
7886       addq(in_out2, 8);
7887       cmpq(in_out2, tmp3);
7888       jcc(Assembler::less, L_processPartition);
7889     crc32c_rec_alt2(const_or_pre_comp_const_index_u1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, in_out3, tmp1, tmp2,
7890             w_xtmp1, w_xtmp2, w_xtmp3,
7891             tmp4, tmp5,
7892             n_tmp6);
7893     addq(in_out2, 2 * size);
7894     subl(in_out1, 3 * size);
7895     jmp(L_processPartitions);
7896 
7897   bind(L_exit);
7898 }
7899 #else
7900 void MacroAssembler::crc32c_ipl_alg4(Register in_out, uint32_t n,
7901                                      Register tmp1, Register tmp2, Register tmp3,
7902                                      XMMRegister xtmp1, XMMRegister xtmp2) {
7903   lea(tmp3, ExternalAddress(StubRoutines::crc32c_table_addr()));
7904   if (n &gt; 0) {
7905     addl(tmp3, n * 256 * 8);
7906   }
7907   //    Q1 = TABLEExt[n][B &amp; 0xFF];
7908   movl(tmp1, in_out);
7909   andl(tmp1, 0x000000FF);
7910   shll(tmp1, 3);
7911   addl(tmp1, tmp3);
7912   movq(xtmp1, Address(tmp1, 0));
7913 
7914   //    Q2 = TABLEExt[n][B &gt;&gt; 8 &amp; 0xFF];
7915   movl(tmp2, in_out);
7916   shrl(tmp2, 8);
7917   andl(tmp2, 0x000000FF);
7918   shll(tmp2, 3);
7919   addl(tmp2, tmp3);
7920   movq(xtmp2, Address(tmp2, 0));
7921 
7922   psllq(xtmp2, 8);
7923   pxor(xtmp1, xtmp2);
7924 
7925   //    Q3 = TABLEExt[n][B &gt;&gt; 16 &amp; 0xFF];
7926   movl(tmp2, in_out);
7927   shrl(tmp2, 16);
7928   andl(tmp2, 0x000000FF);
7929   shll(tmp2, 3);
7930   addl(tmp2, tmp3);
7931   movq(xtmp2, Address(tmp2, 0));
7932 
7933   psllq(xtmp2, 16);
7934   pxor(xtmp1, xtmp2);
7935 
7936   //    Q4 = TABLEExt[n][B &gt;&gt; 24 &amp; 0xFF];
7937   shrl(in_out, 24);
7938   andl(in_out, 0x000000FF);
7939   shll(in_out, 3);
7940   addl(in_out, tmp3);
7941   movq(xtmp2, Address(in_out, 0));
7942 
7943   psllq(xtmp2, 24);
7944   pxor(xtmp1, xtmp2); // Result in CXMM
7945   //    return Q1 ^ Q2 &lt;&lt; 8 ^ Q3 &lt;&lt; 16 ^ Q4 &lt;&lt; 24;
7946 }
7947 
7948 void MacroAssembler::crc32c_pclmulqdq(XMMRegister w_xtmp1,
7949                                       Register in_out,
7950                                       uint32_t const_or_pre_comp_const_index, bool is_pclmulqdq_supported,
7951                                       XMMRegister w_xtmp2,
7952                                       Register tmp1,
7953                                       Register n_tmp2, Register n_tmp3) {
7954   if (is_pclmulqdq_supported) {
7955     movdl(w_xtmp1, in_out);
7956 
7957     movl(tmp1, const_or_pre_comp_const_index);
7958     movdl(w_xtmp2, tmp1);
7959     pclmulqdq(w_xtmp1, w_xtmp2, 0);
7960     // Keep result in XMM since GPR is 32 bit in length
7961   } else {
7962     crc32c_ipl_alg4(in_out, const_or_pre_comp_const_index, tmp1, n_tmp2, n_tmp3, w_xtmp1, w_xtmp2);
7963   }
7964 }
7965 
7966 void MacroAssembler::crc32c_rec_alt2(uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported, Register in_out, Register in1, Register in2,
7967                                      XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7968                                      Register tmp1, Register tmp2,
7969                                      Register n_tmp3) {
7970   crc32c_pclmulqdq(w_xtmp1, in_out, const_or_pre_comp_const_index_u1, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
7971   crc32c_pclmulqdq(w_xtmp2, in1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, w_xtmp3, tmp1, tmp2, n_tmp3);
7972 
7973   psllq(w_xtmp1, 1);
7974   movdl(tmp1, w_xtmp1);
7975   psrlq(w_xtmp1, 32);
7976   movdl(in_out, w_xtmp1);
7977 
7978   xorl(tmp2, tmp2);
7979   crc32(tmp2, tmp1, 4);
7980   xorl(in_out, tmp2);
7981 
7982   psllq(w_xtmp2, 1);
7983   movdl(tmp1, w_xtmp2);
7984   psrlq(w_xtmp2, 32);
7985   movdl(in1, w_xtmp2);
7986 
7987   xorl(tmp2, tmp2);
7988   crc32(tmp2, tmp1, 4);
7989   xorl(in1, tmp2);
7990   xorl(in_out, in1);
7991   xorl(in_out, in2);
7992 }
7993 
7994 void MacroAssembler::crc32c_proc_chunk(uint32_t size, uint32_t const_or_pre_comp_const_index_u1, uint32_t const_or_pre_comp_const_index_u2, bool is_pclmulqdq_supported,
7995                                        Register in_out1, Register in_out2, Register in_out3,
7996                                        Register tmp1, Register tmp2, Register tmp3,
7997                                        XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
7998                                        Register tmp4, Register tmp5,
7999                                        Register n_tmp6) {
8000   Label L_processPartitions;
8001   Label L_processPartition;
8002   Label L_exit;
8003 
8004   bind(L_processPartitions);
8005   cmpl(in_out1, 3 * size);
8006   jcc(Assembler::less, L_exit);
8007     xorl(tmp1, tmp1);
8008     xorl(tmp2, tmp2);
8009     movl(tmp3, in_out2);
8010     addl(tmp3, size);
8011 
8012     bind(L_processPartition);
8013       crc32(in_out3, Address(in_out2, 0), 4);
8014       crc32(tmp1, Address(in_out2, size), 4);
8015       crc32(tmp2, Address(in_out2, size*2), 4);
8016       crc32(in_out3, Address(in_out2, 0+4), 4);
8017       crc32(tmp1, Address(in_out2, size+4), 4);
8018       crc32(tmp2, Address(in_out2, size*2+4), 4);
8019       addl(in_out2, 8);
8020       cmpl(in_out2, tmp3);
8021       jcc(Assembler::less, L_processPartition);
8022 
8023         push(tmp3);
8024         push(in_out1);
8025         push(in_out2);
8026         tmp4 = tmp3;
8027         tmp5 = in_out1;
8028         n_tmp6 = in_out2;
8029 
8030       crc32c_rec_alt2(const_or_pre_comp_const_index_u1, const_or_pre_comp_const_index_u2, is_pclmulqdq_supported, in_out3, tmp1, tmp2,
8031             w_xtmp1, w_xtmp2, w_xtmp3,
8032             tmp4, tmp5,
8033             n_tmp6);
8034 
8035         pop(in_out2);
8036         pop(in_out1);
8037         pop(tmp3);
8038 
8039     addl(in_out2, 2 * size);
8040     subl(in_out1, 3 * size);
8041     jmp(L_processPartitions);
8042 
8043   bind(L_exit);
8044 }
8045 #endif //LP64
8046 
8047 #ifdef _LP64
8048 // Algorithm 2: Pipelined usage of the CRC32 instruction.
8049 // Input: A buffer I of L bytes.
8050 // Output: the CRC32C value of the buffer.
8051 // Notations:
8052 // Write L = 24N + r, with N = floor (L/24).
8053 // r = L mod 24 (0 &lt;= r &lt; 24).
8054 // Consider I as the concatenation of A|B|C|R, where A, B, C, each,
8055 // N quadwords, and R consists of r bytes.
8056 // A[j] = I [8j+7:8j], j= 0, 1, ..., N-1
8057 // B[j] = I [N + 8j+7:N + 8j], j= 0, 1, ..., N-1
8058 // C[j] = I [2N + 8j+7:2N + 8j], j= 0, 1, ..., N-1
8059 // if r &gt; 0 R[j] = I [3N +j], j= 0, 1, ...,r-1
8060 void MacroAssembler::crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
8061                                           Register tmp1, Register tmp2, Register tmp3,
8062                                           Register tmp4, Register tmp5, Register tmp6,
8063                                           XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
8064                                           bool is_pclmulqdq_supported) {
8065   uint32_t const_or_pre_comp_const_index[CRC32C_NUM_PRECOMPUTED_CONSTANTS];
8066   Label L_wordByWord;
8067   Label L_byteByByteProlog;
8068   Label L_byteByByte;
8069   Label L_exit;
8070 
8071   if (is_pclmulqdq_supported ) {
8072     const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::_crc32c_table_addr;
8073     const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::_crc32c_table_addr+1);
8074 
8075     const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 2);
8076     const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 3);
8077 
8078     const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 4);
8079     const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 5);
8080     assert((CRC32C_NUM_PRECOMPUTED_CONSTANTS - 1 ) == 5, &quot;Checking whether you declared all of the constants based on the number of \&quot;chunks\&quot;&quot;);
8081   } else {
8082     const_or_pre_comp_const_index[0] = 1;
8083     const_or_pre_comp_const_index[1] = 0;
8084 
8085     const_or_pre_comp_const_index[2] = 3;
8086     const_or_pre_comp_const_index[3] = 2;
8087 
8088     const_or_pre_comp_const_index[4] = 5;
8089     const_or_pre_comp_const_index[5] = 4;
8090    }
8091   crc32c_proc_chunk(CRC32C_HIGH, const_or_pre_comp_const_index[0], const_or_pre_comp_const_index[1], is_pclmulqdq_supported,
8092                     in2, in1, in_out,
8093                     tmp1, tmp2, tmp3,
8094                     w_xtmp1, w_xtmp2, w_xtmp3,
8095                     tmp4, tmp5,
8096                     tmp6);
8097   crc32c_proc_chunk(CRC32C_MIDDLE, const_or_pre_comp_const_index[2], const_or_pre_comp_const_index[3], is_pclmulqdq_supported,
8098                     in2, in1, in_out,
8099                     tmp1, tmp2, tmp3,
8100                     w_xtmp1, w_xtmp2, w_xtmp3,
8101                     tmp4, tmp5,
8102                     tmp6);
8103   crc32c_proc_chunk(CRC32C_LOW, const_or_pre_comp_const_index[4], const_or_pre_comp_const_index[5], is_pclmulqdq_supported,
8104                     in2, in1, in_out,
8105                     tmp1, tmp2, tmp3,
8106                     w_xtmp1, w_xtmp2, w_xtmp3,
8107                     tmp4, tmp5,
8108                     tmp6);
8109   movl(tmp1, in2);
8110   andl(tmp1, 0x00000007);
8111   negl(tmp1);
8112   addl(tmp1, in2);
8113   addq(tmp1, in1);
8114 
8115   BIND(L_wordByWord);
8116   cmpq(in1, tmp1);
8117   jcc(Assembler::greaterEqual, L_byteByByteProlog);
8118     crc32(in_out, Address(in1, 0), 4);
8119     addq(in1, 4);
8120     jmp(L_wordByWord);
8121 
8122   BIND(L_byteByByteProlog);
8123   andl(in2, 0x00000007);
8124   movl(tmp2, 1);
8125 
8126   BIND(L_byteByByte);
8127   cmpl(tmp2, in2);
8128   jccb(Assembler::greater, L_exit);
8129     crc32(in_out, Address(in1, 0), 1);
8130     incq(in1);
8131     incl(tmp2);
8132     jmp(L_byteByByte);
8133 
8134   BIND(L_exit);
8135 }
8136 #else
8137 void MacroAssembler::crc32c_ipl_alg2_alt2(Register in_out, Register in1, Register in2,
8138                                           Register tmp1, Register  tmp2, Register tmp3,
8139                                           Register tmp4, Register  tmp5, Register tmp6,
8140                                           XMMRegister w_xtmp1, XMMRegister w_xtmp2, XMMRegister w_xtmp3,
8141                                           bool is_pclmulqdq_supported) {
8142   uint32_t const_or_pre_comp_const_index[CRC32C_NUM_PRECOMPUTED_CONSTANTS];
8143   Label L_wordByWord;
8144   Label L_byteByByteProlog;
8145   Label L_byteByByte;
8146   Label L_exit;
8147 
8148   if (is_pclmulqdq_supported) {
8149     const_or_pre_comp_const_index[1] = *(uint32_t *)StubRoutines::_crc32c_table_addr;
8150     const_or_pre_comp_const_index[0] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 1);
8151 
8152     const_or_pre_comp_const_index[3] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 2);
8153     const_or_pre_comp_const_index[2] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 3);
8154 
8155     const_or_pre_comp_const_index[5] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 4);
8156     const_or_pre_comp_const_index[4] = *((uint32_t *)StubRoutines::_crc32c_table_addr + 5);
8157   } else {
8158     const_or_pre_comp_const_index[0] = 1;
8159     const_or_pre_comp_const_index[1] = 0;
8160 
8161     const_or_pre_comp_const_index[2] = 3;
8162     const_or_pre_comp_const_index[3] = 2;
8163 
8164     const_or_pre_comp_const_index[4] = 5;
8165     const_or_pre_comp_const_index[5] = 4;
8166   }
8167   crc32c_proc_chunk(CRC32C_HIGH, const_or_pre_comp_const_index[0], const_or_pre_comp_const_index[1], is_pclmulqdq_supported,
8168                     in2, in1, in_out,
8169                     tmp1, tmp2, tmp3,
8170                     w_xtmp1, w_xtmp2, w_xtmp3,
8171                     tmp4, tmp5,
8172                     tmp6);
8173   crc32c_proc_chunk(CRC32C_MIDDLE, const_or_pre_comp_const_index[2], const_or_pre_comp_const_index[3], is_pclmulqdq_supported,
8174                     in2, in1, in_out,
8175                     tmp1, tmp2, tmp3,
8176                     w_xtmp1, w_xtmp2, w_xtmp3,
8177                     tmp4, tmp5,
8178                     tmp6);
8179   crc32c_proc_chunk(CRC32C_LOW, const_or_pre_comp_const_index[4], const_or_pre_comp_const_index[5], is_pclmulqdq_supported,
8180                     in2, in1, in_out,
8181                     tmp1, tmp2, tmp3,
8182                     w_xtmp1, w_xtmp2, w_xtmp3,
8183                     tmp4, tmp5,
8184                     tmp6);
8185   movl(tmp1, in2);
8186   andl(tmp1, 0x00000007);
8187   negl(tmp1);
8188   addl(tmp1, in2);
8189   addl(tmp1, in1);
8190 
8191   BIND(L_wordByWord);
8192   cmpl(in1, tmp1);
8193   jcc(Assembler::greaterEqual, L_byteByByteProlog);
8194     crc32(in_out, Address(in1,0), 4);
8195     addl(in1, 4);
8196     jmp(L_wordByWord);
8197 
8198   BIND(L_byteByByteProlog);
8199   andl(in2, 0x00000007);
8200   movl(tmp2, 1);
8201 
8202   BIND(L_byteByByte);
8203   cmpl(tmp2, in2);
8204   jccb(Assembler::greater, L_exit);
8205     movb(tmp1, Address(in1, 0));
8206     crc32(in_out, tmp1, 1);
8207     incl(in1);
8208     incl(tmp2);
8209     jmp(L_byteByByte);
8210 
8211   BIND(L_exit);
8212 }
8213 #endif // LP64
8214 #undef BIND
8215 #undef BLOCK_COMMENT
8216 
8217 // Compress char[] array to byte[].
8218 //   ..\jdk\src\java.base\share\classes\java\lang\StringUTF16.java
8219 //   @HotSpotIntrinsicCandidate
8220 //   private static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {
8221 //     for (int i = 0; i &lt; len; i++) {
8222 //       int c = src[srcOff++];
8223 //       if (c &gt;&gt;&gt; 8 != 0) {
8224 //         return 0;
8225 //       }
8226 //       dst[dstOff++] = (byte)c;
8227 //     }
8228 //     return len;
8229 //   }
8230 void MacroAssembler::char_array_compress(Register src, Register dst, Register len,
8231   XMMRegister tmp1Reg, XMMRegister tmp2Reg,
8232   XMMRegister tmp3Reg, XMMRegister tmp4Reg,
8233   Register tmp5, Register result) {
8234   Label copy_chars_loop, return_length, return_zero, done;
8235 
8236   // rsi: src
8237   // rdi: dst
8238   // rdx: len
8239   // rcx: tmp5
8240   // rax: result
8241 
8242   // rsi holds start addr of source char[] to be compressed
8243   // rdi holds start addr of destination byte[]
8244   // rdx holds length
8245 
8246   assert(len != result, &quot;&quot;);
8247 
8248   // save length for return
8249   push(len);
8250 
8251   if ((AVX3Threshold == 0) &amp;&amp; (UseAVX &gt; 2) &amp;&amp; // AVX512
8252     VM_Version::supports_avx512vlbw() &amp;&amp;
8253     VM_Version::supports_bmi2()) {
8254 
8255     Label copy_32_loop, copy_loop_tail, below_threshold;
8256 
8257     // alignment
8258     Label post_alignment;
8259 
8260     // if length of the string is less than 16, handle it in an old fashioned way
8261     testl(len, -32);
8262     jcc(Assembler::zero, below_threshold);
8263 
8264     // First check whether a character is compressable ( &lt;= 0xFF).
8265     // Create mask to test for Unicode chars inside zmm vector
8266     movl(result, 0x00FF);
8267     evpbroadcastw(tmp2Reg, result, Assembler::AVX_512bit);
8268 
8269     testl(len, -64);
8270     jcc(Assembler::zero, post_alignment);
8271 
8272     movl(tmp5, dst);
8273     andl(tmp5, (32 - 1));
8274     negl(tmp5);
8275     andl(tmp5, (32 - 1));
8276 
8277     // bail out when there is nothing to be done
8278     testl(tmp5, 0xFFFFFFFF);
8279     jcc(Assembler::zero, post_alignment);
8280 
8281     // ~(~0 &lt;&lt; len), where len is the # of remaining elements to process
8282     movl(result, 0xFFFFFFFF);
8283     shlxl(result, result, tmp5);
8284     notl(result);
8285     kmovdl(k3, result);
8286 
8287     evmovdquw(tmp1Reg, k3, Address(src, 0), Assembler::AVX_512bit);
8288     evpcmpuw(k2, k3, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
8289     ktestd(k2, k3);
8290     jcc(Assembler::carryClear, return_zero);
8291 
8292     evpmovwb(Address(dst, 0), k3, tmp1Reg, Assembler::AVX_512bit);
8293 
8294     addptr(src, tmp5);
8295     addptr(src, tmp5);
8296     addptr(dst, tmp5);
8297     subl(len, tmp5);
8298 
8299     bind(post_alignment);
8300     // end of alignment
8301 
8302     movl(tmp5, len);
8303     andl(tmp5, (32 - 1));    // tail count (in chars)
8304     andl(len, ~(32 - 1));    // vector count (in chars)
8305     jcc(Assembler::zero, copy_loop_tail);
8306 
8307     lea(src, Address(src, len, Address::times_2));
8308     lea(dst, Address(dst, len, Address::times_1));
8309     negptr(len);
8310 
8311     bind(copy_32_loop);
8312     evmovdquw(tmp1Reg, Address(src, len, Address::times_2), Assembler::AVX_512bit);
8313     evpcmpuw(k2, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
8314     kortestdl(k2, k2);
8315     jcc(Assembler::carryClear, return_zero);
8316 
8317     // All elements in current processed chunk are valid candidates for
8318     // compression. Write a truncated byte elements to the memory.
8319     evpmovwb(Address(dst, len, Address::times_1), tmp1Reg, Assembler::AVX_512bit);
8320     addptr(len, 32);
8321     jcc(Assembler::notZero, copy_32_loop);
8322 
8323     bind(copy_loop_tail);
8324     // bail out when there is nothing to be done
8325     testl(tmp5, 0xFFFFFFFF);
8326     jcc(Assembler::zero, return_length);
8327 
8328     movl(len, tmp5);
8329 
8330     // ~(~0 &lt;&lt; len), where len is the # of remaining elements to process
8331     movl(result, 0xFFFFFFFF);
8332     shlxl(result, result, len);
8333     notl(result);
8334 
8335     kmovdl(k3, result);
8336 
8337     evmovdquw(tmp1Reg, k3, Address(src, 0), Assembler::AVX_512bit);
8338     evpcmpuw(k2, k3, tmp1Reg, tmp2Reg, Assembler::le, Assembler::AVX_512bit);
8339     ktestd(k2, k3);
8340     jcc(Assembler::carryClear, return_zero);
8341 
8342     evpmovwb(Address(dst, 0), k3, tmp1Reg, Assembler::AVX_512bit);
8343     jmp(return_length);
8344 
8345     bind(below_threshold);
8346   }
8347 
8348   if (UseSSE42Intrinsics) {
8349     Label copy_32_loop, copy_16, copy_tail;
8350 
8351     movl(result, len);
8352 
8353     movl(tmp5, 0xff00ff00);   // create mask to test for Unicode chars in vectors
8354 
8355     // vectored compression
8356     andl(len, 0xfffffff0);    // vector count (in chars)
8357     andl(result, 0x0000000f);    // tail count (in chars)
8358     testl(len, len);
8359     jcc(Assembler::zero, copy_16);
8360 
8361     // compress 16 chars per iter
8362     movdl(tmp1Reg, tmp5);
8363     pshufd(tmp1Reg, tmp1Reg, 0);   // store Unicode mask in tmp1Reg
8364     pxor(tmp4Reg, tmp4Reg);
8365 
8366     lea(src, Address(src, len, Address::times_2));
8367     lea(dst, Address(dst, len, Address::times_1));
8368     negptr(len);
8369 
8370     bind(copy_32_loop);
8371     movdqu(tmp2Reg, Address(src, len, Address::times_2));     // load 1st 8 characters
8372     por(tmp4Reg, tmp2Reg);
8373     movdqu(tmp3Reg, Address(src, len, Address::times_2, 16)); // load next 8 characters
8374     por(tmp4Reg, tmp3Reg);
8375     ptest(tmp4Reg, tmp1Reg);       // check for Unicode chars in next vector
8376     jcc(Assembler::notZero, return_zero);
8377     packuswb(tmp2Reg, tmp3Reg);    // only ASCII chars; compress each to 1 byte
8378     movdqu(Address(dst, len, Address::times_1), tmp2Reg);
8379     addptr(len, 16);
8380     jcc(Assembler::notZero, copy_32_loop);
8381 
8382     // compress next vector of 8 chars (if any)
8383     bind(copy_16);
8384     movl(len, result);
8385     andl(len, 0xfffffff8);    // vector count (in chars)
8386     andl(result, 0x00000007);    // tail count (in chars)
8387     testl(len, len);
8388     jccb(Assembler::zero, copy_tail);
8389 
8390     movdl(tmp1Reg, tmp5);
8391     pshufd(tmp1Reg, tmp1Reg, 0);   // store Unicode mask in tmp1Reg
8392     pxor(tmp3Reg, tmp3Reg);
8393 
8394     movdqu(tmp2Reg, Address(src, 0));
8395     ptest(tmp2Reg, tmp1Reg);       // check for Unicode chars in vector
8396     jccb(Assembler::notZero, return_zero);
8397     packuswb(tmp2Reg, tmp3Reg);    // only LATIN1 chars; compress each to 1 byte
8398     movq(Address(dst, 0), tmp2Reg);
8399     addptr(src, 16);
8400     addptr(dst, 8);
8401 
8402     bind(copy_tail);
8403     movl(len, result);
8404   }
8405   // compress 1 char per iter
8406   testl(len, len);
8407   jccb(Assembler::zero, return_length);
8408   lea(src, Address(src, len, Address::times_2));
8409   lea(dst, Address(dst, len, Address::times_1));
8410   negptr(len);
8411 
8412   bind(copy_chars_loop);
8413   load_unsigned_short(result, Address(src, len, Address::times_2));
8414   testl(result, 0xff00);      // check if Unicode char
8415   jccb(Assembler::notZero, return_zero);
8416   movb(Address(dst, len, Address::times_1), result);  // ASCII char; compress to 1 byte
8417   increment(len);
8418   jcc(Assembler::notZero, copy_chars_loop);
8419 
8420   // if compression succeeded, return length
8421   bind(return_length);
8422   pop(result);
8423   jmpb(done);
8424 
8425   // if compression failed, return 0
8426   bind(return_zero);
8427   xorl(result, result);
8428   addptr(rsp, wordSize);
8429 
8430   bind(done);
8431 }
8432 
8433 // Inflate byte[] array to char[].
8434 //   ..\jdk\src\java.base\share\classes\java\lang\StringLatin1.java
8435 //   @HotSpotIntrinsicCandidate
8436 //   private static void inflate(byte[] src, int srcOff, char[] dst, int dstOff, int len) {
8437 //     for (int i = 0; i &lt; len; i++) {
8438 //       dst[dstOff++] = (char)(src[srcOff++] &amp; 0xff);
8439 //     }
8440 //   }
8441 void MacroAssembler::byte_array_inflate(Register src, Register dst, Register len,
8442   XMMRegister tmp1, Register tmp2) {
8443   Label copy_chars_loop, done, below_threshold, avx3_threshold;
8444   // rsi: src
8445   // rdi: dst
8446   // rdx: len
8447   // rcx: tmp2
8448 
8449   // rsi holds start addr of source byte[] to be inflated
8450   // rdi holds start addr of destination char[]
8451   // rdx holds length
8452   assert_different_registers(src, dst, len, tmp2);
8453   movl(tmp2, len);
8454   if ((UseAVX &gt; 2) &amp;&amp; // AVX512
8455     VM_Version::supports_avx512vlbw() &amp;&amp;
8456     VM_Version::supports_bmi2()) {
8457 
8458     Label copy_32_loop, copy_tail;
8459     Register tmp3_aliased = len;
8460 
8461     // if length of the string is less than 16, handle it in an old fashioned way
8462     testl(len, -16);
8463     jcc(Assembler::zero, below_threshold);
8464 
8465     testl(len, -1 * AVX3Threshold);
8466     jcc(Assembler::zero, avx3_threshold);
8467 
8468     // In order to use only one arithmetic operation for the main loop we use
8469     // this pre-calculation
8470     andl(tmp2, (32 - 1)); // tail count (in chars), 32 element wide loop
8471     andl(len, -32);     // vector count
8472     jccb(Assembler::zero, copy_tail);
8473 
8474     lea(src, Address(src, len, Address::times_1));
8475     lea(dst, Address(dst, len, Address::times_2));
8476     negptr(len);
8477 
8478 
8479     // inflate 32 chars per iter
8480     bind(copy_32_loop);
8481     vpmovzxbw(tmp1, Address(src, len, Address::times_1), Assembler::AVX_512bit);
8482     evmovdquw(Address(dst, len, Address::times_2), tmp1, Assembler::AVX_512bit);
8483     addptr(len, 32);
8484     jcc(Assembler::notZero, copy_32_loop);
8485 
8486     bind(copy_tail);
8487     // bail out when there is nothing to be done
8488     testl(tmp2, -1); // we don&#39;t destroy the contents of tmp2 here
8489     jcc(Assembler::zero, done);
8490 
8491     // ~(~0 &lt;&lt; length), where length is the # of remaining elements to process
8492     movl(tmp3_aliased, -1);
8493     shlxl(tmp3_aliased, tmp3_aliased, tmp2);
8494     notl(tmp3_aliased);
8495     kmovdl(k2, tmp3_aliased);
8496     evpmovzxbw(tmp1, k2, Address(src, 0), Assembler::AVX_512bit);
8497     evmovdquw(Address(dst, 0), k2, tmp1, Assembler::AVX_512bit);
8498 
8499     jmp(done);
8500     bind(avx3_threshold);
8501   }
8502   if (UseSSE42Intrinsics) {
8503     Label copy_16_loop, copy_8_loop, copy_bytes, copy_new_tail, copy_tail;
8504 
8505     if (UseAVX &gt; 1) {
8506       andl(tmp2, (16 - 1));
8507       andl(len, -16);
8508       jccb(Assembler::zero, copy_new_tail);
8509     } else {
8510       andl(tmp2, 0x00000007);   // tail count (in chars)
8511       andl(len, 0xfffffff8);    // vector count (in chars)
8512       jccb(Assembler::zero, copy_tail);
8513     }
8514 
8515     // vectored inflation
8516     lea(src, Address(src, len, Address::times_1));
8517     lea(dst, Address(dst, len, Address::times_2));
8518     negptr(len);
8519 
8520     if (UseAVX &gt; 1) {
8521       bind(copy_16_loop);
8522       vpmovzxbw(tmp1, Address(src, len, Address::times_1), Assembler::AVX_256bit);
8523       vmovdqu(Address(dst, len, Address::times_2), tmp1);
8524       addptr(len, 16);
8525       jcc(Assembler::notZero, copy_16_loop);
8526 
8527       bind(below_threshold);
8528       bind(copy_new_tail);
8529       movl(len, tmp2);
8530       andl(tmp2, 0x00000007);
8531       andl(len, 0xFFFFFFF8);
8532       jccb(Assembler::zero, copy_tail);
8533 
8534       pmovzxbw(tmp1, Address(src, 0));
8535       movdqu(Address(dst, 0), tmp1);
8536       addptr(src, 8);
8537       addptr(dst, 2 * 8);
8538 
8539       jmp(copy_tail, true);
8540     }
8541 
8542     // inflate 8 chars per iter
8543     bind(copy_8_loop);
8544     pmovzxbw(tmp1, Address(src, len, Address::times_1));  // unpack to 8 words
8545     movdqu(Address(dst, len, Address::times_2), tmp1);
8546     addptr(len, 8);
8547     jcc(Assembler::notZero, copy_8_loop);
8548 
8549     bind(copy_tail);
8550     movl(len, tmp2);
8551 
8552     cmpl(len, 4);
8553     jccb(Assembler::less, copy_bytes);
8554 
8555     movdl(tmp1, Address(src, 0));  // load 4 byte chars
8556     pmovzxbw(tmp1, tmp1);
8557     movq(Address(dst, 0), tmp1);
8558     subptr(len, 4);
8559     addptr(src, 4);
8560     addptr(dst, 8);
8561 
8562     bind(copy_bytes);
8563   } else {
8564     bind(below_threshold);
8565   }
8566 
8567   testl(len, len);
8568   jccb(Assembler::zero, done);
8569   lea(src, Address(src, len, Address::times_1));
8570   lea(dst, Address(dst, len, Address::times_2));
8571   negptr(len);
8572 
8573   // inflate 1 char per iter
8574   bind(copy_chars_loop);
8575   load_unsigned_byte(tmp2, Address(src, len, Address::times_1));  // load byte char
8576   movw(Address(dst, len, Address::times_2), tmp2);  // inflate byte char to word
8577   increment(len);
8578   jcc(Assembler::notZero, copy_chars_loop);
8579 
8580   bind(done);
8581 }
8582 
8583 #ifdef _LP64
8584 void MacroAssembler::convert_f2i(Register dst, XMMRegister src) {
8585   Label done;
8586   cvttss2sil(dst, src);
8587   // Conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
8588   cmpl(dst, 0x80000000); // float_sign_flip
8589   jccb(Assembler::notEqual, done);
8590   subptr(rsp, 8);
8591   movflt(Address(rsp, 0), src);
8592   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2i_fixup())));
8593   pop(dst);
8594   bind(done);
8595 }
8596 
8597 void MacroAssembler::convert_d2i(Register dst, XMMRegister src) {
8598   Label done;
8599   cvttsd2sil(dst, src);
8600   // Conversion instructions do not match JLS for overflow, underflow and NaN -&gt; fixup in stub
8601   cmpl(dst, 0x80000000); // float_sign_flip
8602   jccb(Assembler::notEqual, done);
8603   subptr(rsp, 8);
8604   movdbl(Address(rsp, 0), src);
8605   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2i_fixup())));
8606   pop(dst);
8607   bind(done);
8608 }
8609 
8610 void MacroAssembler::convert_f2l(Register dst, XMMRegister src) {
8611   Label done;
8612   cvttss2siq(dst, src);
8613   cmp64(dst, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
8614   jccb(Assembler::notEqual, done);
8615   subptr(rsp, 8);
8616   movflt(Address(rsp, 0), src);
8617   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2l_fixup())));
8618   pop(dst);
8619   bind(done);
8620 }
8621 
8622 void MacroAssembler::convert_d2l(Register dst, XMMRegister src) {
8623   Label done;
8624   cvttsd2siq(dst, src);
8625   cmp64(dst, ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
8626   jccb(Assembler::notEqual, done);
8627   subptr(rsp, 8);
8628   movdbl(Address(rsp, 0), src);
8629   call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_fixup())));
8630   pop(dst);
8631   bind(done);
8632 }
8633 
8634 void MacroAssembler::cache_wb(Address line)
8635 {
8636   // 64 bit cpus always support clflush
8637   assert(VM_Version::supports_clflush(), &quot;clflush should be available&quot;);
8638   bool optimized = VM_Version::supports_clflushopt();
8639   bool no_evict = VM_Version::supports_clwb();
8640 
8641   // prefer clwb (writeback without evict) otherwise
8642   // prefer clflushopt (potentially parallel writeback with evict)
8643   // otherwise fallback on clflush (serial writeback with evict)
8644 
8645   if (optimized) {
8646     if (no_evict) {
8647       clwb(line);
8648     } else {
8649       clflushopt(line);
8650     }
8651   } else {
8652     // no need for fence when using CLFLUSH
8653     clflush(line);
8654   }
8655 }
8656 
8657 void MacroAssembler::cache_wbsync(bool is_pre)
8658 {
8659   assert(VM_Version::supports_clflush(), &quot;clflush should be available&quot;);
8660   bool optimized = VM_Version::supports_clflushopt();
8661   bool no_evict = VM_Version::supports_clwb();
8662 
8663   // pick the correct implementation
8664 
8665   if (!is_pre &amp;&amp; (optimized || no_evict)) {
8666     // need an sfence for post flush when using clflushopt or clwb
8667     // otherwise no no need for any synchroniaztion
8668 
8669     sfence();
8670   }
8671 }
8672 #endif // _LP64
8673 
8674 Assembler::Condition MacroAssembler::negate_condition(Assembler::Condition cond) {
8675   switch (cond) {
8676     // Note some conditions are synonyms for others
8677     case Assembler::zero:         return Assembler::notZero;
8678     case Assembler::notZero:      return Assembler::zero;
8679     case Assembler::less:         return Assembler::greaterEqual;
8680     case Assembler::lessEqual:    return Assembler::greater;
8681     case Assembler::greater:      return Assembler::lessEqual;
8682     case Assembler::greaterEqual: return Assembler::less;
8683     case Assembler::below:        return Assembler::aboveEqual;
8684     case Assembler::belowEqual:   return Assembler::above;
8685     case Assembler::above:        return Assembler::belowEqual;
8686     case Assembler::aboveEqual:   return Assembler::below;
8687     case Assembler::overflow:     return Assembler::noOverflow;
8688     case Assembler::noOverflow:   return Assembler::overflow;
8689     case Assembler::negative:     return Assembler::positive;
8690     case Assembler::positive:     return Assembler::negative;
8691     case Assembler::parity:       return Assembler::noParity;
8692     case Assembler::noParity:     return Assembler::parity;
8693   }
8694   ShouldNotReachHere(); return Assembler::overflow;
8695 }
8696 
8697 SkipIfEqual::SkipIfEqual(
8698     MacroAssembler* masm, const bool* flag_addr, bool value) {
8699   _masm = masm;
8700   _masm-&gt;cmp8(ExternalAddress((address)flag_addr), value);
8701   _masm-&gt;jcc(Assembler::equal, _label);
8702 }
8703 
8704 SkipIfEqual::~SkipIfEqual() {
8705   _masm-&gt;bind(_label);
8706 }
8707 
8708 // 32-bit Windows has its own fast-path implementation
8709 // of get_thread
8710 #if !defined(WIN32) || defined(_LP64)
8711 
8712 // This is simply a call to Thread::current()
8713 void MacroAssembler::get_thread(Register thread) {
8714   if (thread != rax) {
8715     push(rax);
8716   }
8717   LP64_ONLY(push(rdi);)
8718   LP64_ONLY(push(rsi);)
8719   push(rdx);
8720   push(rcx);
8721 #ifdef _LP64
8722   push(r8);
8723   push(r9);
8724   push(r10);
8725   push(r11);
8726 #endif
8727 
8728   MacroAssembler::call_VM_leaf_base(CAST_FROM_FN_PTR(address, Thread::current), 0);
8729 
8730 #ifdef _LP64
8731   pop(r11);
8732   pop(r10);
8733   pop(r9);
8734   pop(r8);
8735 #endif
8736   pop(rcx);
8737   pop(rdx);
8738   LP64_ONLY(pop(rsi);)
8739   LP64_ONLY(pop(rdi);)
8740   if (thread != rax) {
8741     mov(thread, rax);
8742     pop(rax);
8743   }
8744 }
8745 
8746 #endif // !WIN32 || _LP64
<a name="31" id="anc31"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="31" type="hidden" />
</body>
</html>
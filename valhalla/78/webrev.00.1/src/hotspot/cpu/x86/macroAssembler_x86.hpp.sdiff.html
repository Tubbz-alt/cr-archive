<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/macroAssembler_x86.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_x86_64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/macroAssembler_x86.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef CPU_X86_MACROASSEMBLER_X86_HPP
  26 #define CPU_X86_MACROASSEMBLER_X86_HPP
  27 
  28 #include &quot;asm/assembler.hpp&quot;
  29 #include &quot;utilities/macros.hpp&quot;
  30 #include &quot;runtime/rtmLocking.hpp&quot;



  31 
  32 // MacroAssembler extends Assembler by frequently used macros.
  33 //
  34 // Instructions for which a &#39;better&#39; code sequence exists depending
  35 // on arguments should also go in here.
  36 
  37 class MacroAssembler: public Assembler {
  38   friend class LIR_Assembler;
  39   friend class Runtime1;      // as_Address()
  40 
  41  public:
  42   // Support for VM calls
  43   //
  44   // This is the base routine called by the different versions of call_VM_leaf. The interpreter
  45   // may customize this version by overriding it for its purposes (e.g., to save/restore
  46   // additional registers when doing a VM call).
  47 
  48   virtual void call_VM_leaf_base(
  49     address entry_point,               // the entry point
  50     int     number_of_arguments        // the number of arguments to pop after the call
</pre>
<hr />
<pre>
  81  // These routines should emit JVMTI PopFrame and ForceEarlyReturn handling code.
  82  // The implementation is only non-empty for the InterpreterMacroAssembler,
  83  // as only the interpreter handles PopFrame and ForceEarlyReturn requests.
  84  virtual void check_and_handle_popframe(Register java_thread);
  85  virtual void check_and_handle_earlyret(Register java_thread);
  86 
  87   Address as_Address(AddressLiteral adr);
  88   Address as_Address(ArrayAddress adr);
  89 
  90   // Support for NULL-checks
  91   //
  92   // Generates code that causes a NULL OS exception if the content of reg is NULL.
  93   // If the accessed location is M[reg + offset] and the offset is known, provide the
  94   // offset. No explicit code generation is needed if the offset is within a certain
  95   // range (0 &lt;= offset &lt;= page_size).
  96 
  97   void null_check(Register reg, int offset = -1);
  98   static bool needs_explicit_null_check(intptr_t offset);
  99   static bool uses_implicit_null_check(void* address);
 100 


























 101   // Required platform-specific helpers for Label::patch_instructions.
 102   // They _shadow_ the declarations in AbstractAssembler, which are undefined.
 103   void pd_patch_instruction(address branch, address target, const char* file, int line) {
 104     unsigned char op = branch[0];
 105     assert(op == 0xE8 /* call */ ||
 106         op == 0xE9 /* jmp */ ||
 107         op == 0xEB /* short jmp */ ||
 108         (op &amp; 0xF0) == 0x70 /* short jcc */ ||
 109         op == 0x0F &amp;&amp; (branch[1] &amp; 0xF0) == 0x80 /* jcc */ ||
 110         op == 0xC7 &amp;&amp; branch[1] == 0xF8 /* xbegin */,
 111         &quot;Invalid opcode at patch point&quot;);
 112 
 113     if (op == 0xEB || (op &amp; 0xF0) == 0x70) {
 114       // short offset operators (jmp and jcc)
 115       char* disp = (char*) &amp;branch[1];
 116       int imm8 = target - (address) &amp;disp[1];
 117       guarantee(this-&gt;is8bit(imm8), &quot;Short forward jump exceeds 8-bit offset at %s:%d&quot;,
 118                 file == NULL ? &quot;&lt;NULL&gt;&quot; : file, line);
 119       *disp = imm8;
 120     } else {
</pre>
<hr />
<pre>
 298   void resolve_jobject(Register value, Register thread, Register tmp);
 299 
 300   // C &#39;boolean&#39; to Java boolean: x == 0 ? 0 : 1
 301   void c2bool(Register x);
 302 
 303   // C++ bool manipulation
 304 
 305   void movbool(Register dst, Address src);
 306   void movbool(Address dst, bool boolconst);
 307   void movbool(Address dst, Register src);
 308   void testbool(Register dst);
 309 
 310   void resolve_oop_handle(Register result, Register tmp = rscratch2);
 311   void resolve_weak_handle(Register result, Register tmp);
 312   void load_mirror(Register mirror, Register method, Register tmp = rscratch2);
 313   void load_method_holder_cld(Register rresult, Register rmethod);
 314 
 315   void load_method_holder(Register holder, Register method);
 316 
 317   // oop manipulations

 318   void load_klass(Register dst, Register src, Register tmp);
 319   void store_klass(Register dst, Register src, Register tmp);
 320 
 321   void access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
 322                       Register tmp1, Register thread_tmp);
 323   void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
<span class="line-modified"> 324                        Register tmp1, Register tmp2);</span>










 325 
 326   // Resolves obj access. Result is placed in the same register.
 327   // All other registers are preserved.
 328   void resolve(DecoratorSet decorators, Register obj);
 329 
 330   void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,
 331                      Register thread_tmp = noreg, DecoratorSet decorators = 0);
 332   void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,
 333                               Register thread_tmp = noreg, DecoratorSet decorators = 0);
 334   void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,
<span class="line-modified"> 335                       Register tmp2 = noreg, DecoratorSet decorators = 0);</span>
 336 
 337   // Used for storing NULL. All other oop constants should be
 338   // stored using routines that take a jobject.
 339   void store_heap_oop_null(Address dst);
 340 
 341   void load_prototype_header(Register dst, Register src, Register tmp);
 342 
 343 #ifdef _LP64
 344   void store_klass_gap(Register dst, Register src);
 345 
 346   // This dummy is to prevent a call to store_heap_oop from
 347   // converting a zero (like NULL) into a Register by giving
 348   // the compiler two choices it can&#39;t resolve
 349 
 350   void store_heap_oop(Address dst, void* dummy);
 351 
 352   void encode_heap_oop(Register r);
 353   void decode_heap_oop(Register r);
 354   void encode_heap_oop_not_null(Register r);
 355   void decode_heap_oop_not_null(Register r);
</pre>
<hr />
<pre>
 491   void empty_FPU_stack();
 492 #endif // !_LP64
 493 
 494   void push_IU_state();
 495   void pop_IU_state();
 496 
 497   void push_FPU_state();
 498   void pop_FPU_state();
 499 
 500   void push_CPU_state();
 501   void pop_CPU_state();
 502 
 503   // Round up to a power of two
 504   void round_to(Register reg, int modulus);
 505 
 506   // Callee saved registers handling
 507   void push_callee_saved_registers();
 508   void pop_callee_saved_registers();
 509 
 510   // allocation









 511   void eden_allocate(
 512     Register thread,                   // Current thread
 513     Register obj,                      // result: pointer to object after successful allocation
 514     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 515     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 516     Register t1,                       // temp register
 517     Label&amp;   slow_case                 // continuation point if fast allocation fails
 518   );
 519   void tlab_allocate(
 520     Register thread,                   // Current thread
 521     Register obj,                      // result: pointer to object after successful allocation
 522     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 523     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 524     Register t1,                       // temp register
 525     Register t2,                       // temp register
 526     Label&amp;   slow_case                 // continuation point if fast allocation fails
 527   );
 528   void zero_memory(Register address, Register length_in_bytes, int offset_in_bytes, Register temp);
 529 



 530   // interface method calling
 531   void lookup_interface_method(Register recv_klass,
 532                                Register intf_klass,
 533                                RegisterOrConstant itable_index,
 534                                Register method_result,
 535                                Register scan_temp,
 536                                Label&amp; no_such_interface,
 537                                bool return_method = true);
 538 
 539   // virtual method calling
 540   void lookup_virtual_method(Register recv_klass,
 541                              RegisterOrConstant vtable_index,
 542                              Register method_result);
 543 
 544   // Test sub_klass against super_klass, with fast and slow paths.
 545 
 546   // The fast path produces a tri-state answer: yes / no / maybe-slow.
 547   // One of the three labels can be NULL, meaning take the fall-through.
 548   // If super_check_offset is -1, the value is loaded up from super_klass.
 549   // No registers are killed, except temp_reg.
</pre>
<hr />
<pre>
1577   using Assembler::movq;
1578   void movdl(XMMRegister dst, AddressLiteral src);
1579   void movq(XMMRegister dst, AddressLiteral src);
1580 
1581   // Can push value or effective address
1582   void pushptr(AddressLiteral src);
1583 
1584   void pushptr(Address src) { LP64_ONLY(pushq(src)) NOT_LP64(pushl(src)); }
1585   void popptr(Address src) { LP64_ONLY(popq(src)) NOT_LP64(popl(src)); }
1586 
1587   void pushoop(jobject obj);
1588   void pushklass(Metadata* obj);
1589 
1590   // sign extend as need a l to ptr sized element
1591   void movl2ptr(Register dst, Address src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(movl(dst, src)); }
1592   void movl2ptr(Register dst, Register src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(if (dst != src) movl(dst, src)); }
1593 
1594 
1595  public:
1596   // C2 compiled method&#39;s prolog code.
<span class="line-modified">1597   void verified_entry(int framesize, int stack_bang_size, bool fp_mode_24b, bool is_stub);</span>



























1598 
1599   // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39;;
1600   // if &#39;is_large&#39; is set, do not try to produce short loop
<span class="line-modified">1601   void clear_mem(Register base, Register cnt, Register rtmp, XMMRegister xtmp, bool is_large);</span>
1602 
1603   // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39; using XMM/YMM registers
<span class="line-modified">1604   void xmm_clear_mem(Register base, Register cnt, XMMRegister xtmp);</span>
1605 
1606   // Fill primitive arrays
1607   void generate_fill(BasicType t, bool aligned,
1608                      Register to, Register value, Register count,
1609                      Register rtmp, XMMRegister xtmp);
1610 
1611   void encode_iso_array(Register src, Register dst, Register len,
1612                         XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3,
1613                         XMMRegister tmp4, Register tmp5, Register result);
1614 
1615 #ifdef _LP64
1616   void add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2);
1617   void multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
1618                              Register y, Register y_idx, Register z,
1619                              Register carry, Register product,
1620                              Register idx, Register kdx);
1621   void multiply_add_128_x_128(Register x_xstart, Register y, Register z,
1622                               Register yz_idx, Register idx,
1623                               Register carry, Register product, int offset);
1624   void multiply_128_x_128_bmi2_loop(Register y, Register z,
</pre>
<hr />
<pre>
1714   // Compress char[] array to byte[].
1715   void char_array_compress(Register src, Register dst, Register len,
1716                            XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3,
1717                            XMMRegister tmp4, Register tmp5, Register result);
1718 
1719   // Inflate byte[] array to char[].
1720   void byte_array_inflate(Register src, Register dst, Register len,
1721                           XMMRegister tmp1, Register tmp2);
1722 
1723 #ifdef _LP64
1724   void convert_f2i(Register dst, XMMRegister src);
1725   void convert_d2i(Register dst, XMMRegister src);
1726   void convert_f2l(Register dst, XMMRegister src);
1727   void convert_d2l(Register dst, XMMRegister src);
1728 
1729   void cache_wb(Address line);
1730   void cache_wbsync(bool is_pre);
1731 #endif // _LP64
1732 
1733   void vallones(XMMRegister dst, int vector_len);


1734 };
1735 
1736 /**
1737  * class SkipIfEqual:
1738  *
1739  * Instantiating this class will result in assembly code being output that will
1740  * jump around any code emitted between the creation of the instance and it&#39;s
1741  * automatic destruction at the end of a scope block, depending on the value of
1742  * the flag passed to the constructor, which will be checked at run-time.
1743  */
1744 class SkipIfEqual {
1745  private:
1746   MacroAssembler* _masm;
1747   Label _label;
1748 
1749  public:
1750    SkipIfEqual(MacroAssembler*, const bool* flag_addr, bool value);
1751    ~SkipIfEqual();
1752 };
1753 
</pre>
</td>
<td>
<hr />
<pre>
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef CPU_X86_MACROASSEMBLER_X86_HPP
  26 #define CPU_X86_MACROASSEMBLER_X86_HPP
  27 
  28 #include &quot;asm/assembler.hpp&quot;
  29 #include &quot;utilities/macros.hpp&quot;
  30 #include &quot;runtime/rtmLocking.hpp&quot;
<span class="line-added">  31 #include &quot;runtime/signature.hpp&quot;</span>
<span class="line-added">  32 </span>
<span class="line-added">  33 class ciValueKlass;</span>
  34 
  35 // MacroAssembler extends Assembler by frequently used macros.
  36 //
  37 // Instructions for which a &#39;better&#39; code sequence exists depending
  38 // on arguments should also go in here.
  39 
  40 class MacroAssembler: public Assembler {
  41   friend class LIR_Assembler;
  42   friend class Runtime1;      // as_Address()
  43 
  44  public:
  45   // Support for VM calls
  46   //
  47   // This is the base routine called by the different versions of call_VM_leaf. The interpreter
  48   // may customize this version by overriding it for its purposes (e.g., to save/restore
  49   // additional registers when doing a VM call).
  50 
  51   virtual void call_VM_leaf_base(
  52     address entry_point,               // the entry point
  53     int     number_of_arguments        // the number of arguments to pop after the call
</pre>
<hr />
<pre>
  84  // These routines should emit JVMTI PopFrame and ForceEarlyReturn handling code.
  85  // The implementation is only non-empty for the InterpreterMacroAssembler,
  86  // as only the interpreter handles PopFrame and ForceEarlyReturn requests.
  87  virtual void check_and_handle_popframe(Register java_thread);
  88  virtual void check_and_handle_earlyret(Register java_thread);
  89 
  90   Address as_Address(AddressLiteral adr);
  91   Address as_Address(ArrayAddress adr);
  92 
  93   // Support for NULL-checks
  94   //
  95   // Generates code that causes a NULL OS exception if the content of reg is NULL.
  96   // If the accessed location is M[reg + offset] and the offset is known, provide the
  97   // offset. No explicit code generation is needed if the offset is within a certain
  98   // range (0 &lt;= offset &lt;= page_size).
  99 
 100   void null_check(Register reg, int offset = -1);
 101   static bool needs_explicit_null_check(intptr_t offset);
 102   static bool uses_implicit_null_check(void* address);
 103 
<span class="line-added"> 104   // valueKlass queries, kills temp_reg</span>
<span class="line-added"> 105   void test_klass_is_value(Register klass, Register temp_reg, Label&amp; is_value);</span>
<span class="line-added"> 106   void test_klass_is_empty_value(Register klass, Register temp_reg, Label&amp; is_empty_value);</span>
<span class="line-added"> 107 </span>
<span class="line-added"> 108   // Get the default value oop for the given ValueKlass</span>
<span class="line-added"> 109   void get_default_value_oop(Register value_klass, Register temp_reg, Register obj);</span>
<span class="line-added"> 110   // The empty value oop, for the given ValueKlass (&quot;empty&quot; as in no instance fields)</span>
<span class="line-added"> 111   // get_default_value_oop with extra assertion for empty value klass</span>
<span class="line-added"> 112   void get_empty_value_oop(Register value_klass, Register temp_reg, Register obj);</span>
<span class="line-added"> 113 </span>
<span class="line-added"> 114   void test_field_is_flattenable(Register flags, Register temp_reg, Label&amp; is_flattenable);</span>
<span class="line-added"> 115   void test_field_is_not_flattenable(Register flags, Register temp_reg, Label&amp; notFlattenable);</span>
<span class="line-added"> 116   void test_field_is_flattened(Register flags, Register temp_reg, Label&amp; is_flattened);</span>
<span class="line-added"> 117 </span>
<span class="line-added"> 118   // Check oops array storage properties, i.e. flattened and/or null-free</span>
<span class="line-added"> 119   void test_flattened_array_oop(Register oop, Register temp_reg, Label&amp;is_flattened_array);</span>
<span class="line-added"> 120   void test_non_flattened_array_oop(Register oop, Register temp_reg, Label&amp;is_non_flattened_array);</span>
<span class="line-added"> 121   void test_null_free_array_oop(Register oop, Register temp_reg, Label&amp;is_null_free_array);</span>
<span class="line-added"> 122   void test_non_null_free_array_oop(Register oop, Register temp_reg, Label&amp;is_non_null_free_array);</span>
<span class="line-added"> 123 </span>
<span class="line-added"> 124   // Check array klass layout helper for flatten or null-free arrays...</span>
<span class="line-added"> 125   void test_flattened_array_layout(Register lh, Label&amp; is_flattened_array);</span>
<span class="line-added"> 126   void test_non_flattened_array_layout(Register lh, Label&amp; is_non_flattened_array);</span>
<span class="line-added"> 127   void test_null_free_array_layout(Register lh, Label&amp; is_null_free_array);</span>
<span class="line-added"> 128   void test_non_null_free_array_layout(Register lh, Label&amp; is_non_null_free_array);</span>
<span class="line-added"> 129 </span>
 130   // Required platform-specific helpers for Label::patch_instructions.
 131   // They _shadow_ the declarations in AbstractAssembler, which are undefined.
 132   void pd_patch_instruction(address branch, address target, const char* file, int line) {
 133     unsigned char op = branch[0];
 134     assert(op == 0xE8 /* call */ ||
 135         op == 0xE9 /* jmp */ ||
 136         op == 0xEB /* short jmp */ ||
 137         (op &amp; 0xF0) == 0x70 /* short jcc */ ||
 138         op == 0x0F &amp;&amp; (branch[1] &amp; 0xF0) == 0x80 /* jcc */ ||
 139         op == 0xC7 &amp;&amp; branch[1] == 0xF8 /* xbegin */,
 140         &quot;Invalid opcode at patch point&quot;);
 141 
 142     if (op == 0xEB || (op &amp; 0xF0) == 0x70) {
 143       // short offset operators (jmp and jcc)
 144       char* disp = (char*) &amp;branch[1];
 145       int imm8 = target - (address) &amp;disp[1];
 146       guarantee(this-&gt;is8bit(imm8), &quot;Short forward jump exceeds 8-bit offset at %s:%d&quot;,
 147                 file == NULL ? &quot;&lt;NULL&gt;&quot; : file, line);
 148       *disp = imm8;
 149     } else {
</pre>
<hr />
<pre>
 327   void resolve_jobject(Register value, Register thread, Register tmp);
 328 
 329   // C &#39;boolean&#39; to Java boolean: x == 0 ? 0 : 1
 330   void c2bool(Register x);
 331 
 332   // C++ bool manipulation
 333 
 334   void movbool(Register dst, Address src);
 335   void movbool(Address dst, bool boolconst);
 336   void movbool(Address dst, Register src);
 337   void testbool(Register dst);
 338 
 339   void resolve_oop_handle(Register result, Register tmp = rscratch2);
 340   void resolve_weak_handle(Register result, Register tmp);
 341   void load_mirror(Register mirror, Register method, Register tmp = rscratch2);
 342   void load_method_holder_cld(Register rresult, Register rmethod);
 343 
 344   void load_method_holder(Register holder, Register method);
 345 
 346   // oop manipulations
<span class="line-added"> 347   void load_metadata(Register dst, Register src);</span>
 348   void load_klass(Register dst, Register src, Register tmp);
 349   void store_klass(Register dst, Register src, Register tmp);
 350 
 351   void access_load_at(BasicType type, DecoratorSet decorators, Register dst, Address src,
 352                       Register tmp1, Register thread_tmp);
 353   void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,
<span class="line-modified"> 354                        Register tmp1, Register tmp2, Register tmp3 = noreg);</span>
<span class="line-added"> 355 </span>
<span class="line-added"> 356   void access_value_copy(DecoratorSet decorators, Register src, Register dst, Register value_klass);</span>
<span class="line-added"> 357 </span>
<span class="line-added"> 358   // value type data payload offsets...</span>
<span class="line-added"> 359   void first_field_offset(Register value_klass, Register offset);</span>
<span class="line-added"> 360   void data_for_oop(Register oop, Register data, Register value_klass);</span>
<span class="line-added"> 361   // get data payload ptr a flat value array at index, kills rcx and index</span>
<span class="line-added"> 362   void data_for_value_array_index(Register array, Register array_klass,</span>
<span class="line-added"> 363                                   Register index, Register data);</span>
<span class="line-added"> 364 </span>
 365 
 366   // Resolves obj access. Result is placed in the same register.
 367   // All other registers are preserved.
 368   void resolve(DecoratorSet decorators, Register obj);
 369 
 370   void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,
 371                      Register thread_tmp = noreg, DecoratorSet decorators = 0);
 372   void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,
 373                               Register thread_tmp = noreg, DecoratorSet decorators = 0);
 374   void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,
<span class="line-modified"> 375                       Register tmp2 = noreg, Register tmp3 = noreg, DecoratorSet decorators = 0);</span>
 376 
 377   // Used for storing NULL. All other oop constants should be
 378   // stored using routines that take a jobject.
 379   void store_heap_oop_null(Address dst);
 380 
 381   void load_prototype_header(Register dst, Register src, Register tmp);
 382 
 383 #ifdef _LP64
 384   void store_klass_gap(Register dst, Register src);
 385 
 386   // This dummy is to prevent a call to store_heap_oop from
 387   // converting a zero (like NULL) into a Register by giving
 388   // the compiler two choices it can&#39;t resolve
 389 
 390   void store_heap_oop(Address dst, void* dummy);
 391 
 392   void encode_heap_oop(Register r);
 393   void decode_heap_oop(Register r);
 394   void encode_heap_oop_not_null(Register r);
 395   void decode_heap_oop_not_null(Register r);
</pre>
<hr />
<pre>
 531   void empty_FPU_stack();
 532 #endif // !_LP64
 533 
 534   void push_IU_state();
 535   void pop_IU_state();
 536 
 537   void push_FPU_state();
 538   void pop_FPU_state();
 539 
 540   void push_CPU_state();
 541   void pop_CPU_state();
 542 
 543   // Round up to a power of two
 544   void round_to(Register reg, int modulus);
 545 
 546   // Callee saved registers handling
 547   void push_callee_saved_registers();
 548   void pop_callee_saved_registers();
 549 
 550   // allocation
<span class="line-added"> 551 </span>
<span class="line-added"> 552   // Object / value buffer allocation...</span>
<span class="line-added"> 553   // Allocate instance of klass, assumes klass initialized by caller</span>
<span class="line-added"> 554   // new_obj prefers to be rax</span>
<span class="line-added"> 555   // Kills t1 and t2, perserves klass, return allocation in new_obj (rsi on LP64)</span>
<span class="line-added"> 556   void allocate_instance(Register klass, Register new_obj,</span>
<span class="line-added"> 557                          Register t1, Register t2,</span>
<span class="line-added"> 558                          bool clear_fields, Label&amp; alloc_failed);</span>
<span class="line-added"> 559 </span>
 560   void eden_allocate(
 561     Register thread,                   // Current thread
 562     Register obj,                      // result: pointer to object after successful allocation
 563     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 564     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 565     Register t1,                       // temp register
 566     Label&amp;   slow_case                 // continuation point if fast allocation fails
 567   );
 568   void tlab_allocate(
 569     Register thread,                   // Current thread
 570     Register obj,                      // result: pointer to object after successful allocation
 571     Register var_size_in_bytes,        // object size in bytes if unknown at compile time; invalid otherwise
 572     int      con_size_in_bytes,        // object size in bytes if   known at compile time
 573     Register t1,                       // temp register
 574     Register t2,                       // temp register
 575     Label&amp;   slow_case                 // continuation point if fast allocation fails
 576   );
 577   void zero_memory(Register address, Register length_in_bytes, int offset_in_bytes, Register temp);
 578 
<span class="line-added"> 579   // For field &quot;index&quot; within &quot;klass&quot;, return value_klass ...</span>
<span class="line-added"> 580   void get_value_field_klass(Register klass, Register index, Register value_klass);</span>
<span class="line-added"> 581 </span>
 582   // interface method calling
 583   void lookup_interface_method(Register recv_klass,
 584                                Register intf_klass,
 585                                RegisterOrConstant itable_index,
 586                                Register method_result,
 587                                Register scan_temp,
 588                                Label&amp; no_such_interface,
 589                                bool return_method = true);
 590 
 591   // virtual method calling
 592   void lookup_virtual_method(Register recv_klass,
 593                              RegisterOrConstant vtable_index,
 594                              Register method_result);
 595 
 596   // Test sub_klass against super_klass, with fast and slow paths.
 597 
 598   // The fast path produces a tri-state answer: yes / no / maybe-slow.
 599   // One of the three labels can be NULL, meaning take the fall-through.
 600   // If super_check_offset is -1, the value is loaded up from super_klass.
 601   // No registers are killed, except temp_reg.
</pre>
<hr />
<pre>
1629   using Assembler::movq;
1630   void movdl(XMMRegister dst, AddressLiteral src);
1631   void movq(XMMRegister dst, AddressLiteral src);
1632 
1633   // Can push value or effective address
1634   void pushptr(AddressLiteral src);
1635 
1636   void pushptr(Address src) { LP64_ONLY(pushq(src)) NOT_LP64(pushl(src)); }
1637   void popptr(Address src) { LP64_ONLY(popq(src)) NOT_LP64(popl(src)); }
1638 
1639   void pushoop(jobject obj);
1640   void pushklass(Metadata* obj);
1641 
1642   // sign extend as need a l to ptr sized element
1643   void movl2ptr(Register dst, Address src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(movl(dst, src)); }
1644   void movl2ptr(Register dst, Register src) { LP64_ONLY(movslq(dst, src)) NOT_LP64(if (dst != src) movl(dst, src)); }
1645 
1646 
1647  public:
1648   // C2 compiled method&#39;s prolog code.
<span class="line-modified">1649   void verified_entry(Compile* C, int sp_inc = 0);</span>
<span class="line-added">1650 </span>
<span class="line-added">1651   enum RegState {</span>
<span class="line-added">1652     reg_readonly,</span>
<span class="line-added">1653     reg_writable,</span>
<span class="line-added">1654     reg_written</span>
<span class="line-added">1655   };</span>
<span class="line-added">1656 </span>
<span class="line-added">1657   int store_value_type_fields_to_buf(ciValueKlass* vk, bool from_interpreter = true);</span>
<span class="line-added">1658 </span>
<span class="line-added">1659   // Unpack all value type arguments passed as oops</span>
<span class="line-added">1660   void unpack_value_args(Compile* C, bool receiver_only);</span>
<span class="line-added">1661   bool move_helper(VMReg from, VMReg to, BasicType bt, RegState reg_state[], int ret_off, int extra_stack_offset);</span>
<span class="line-added">1662   bool unpack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, VMReg from, VMRegPair* regs_to, int&amp; to_index,</span>
<span class="line-added">1663                            RegState reg_state[], int ret_off, int extra_stack_offset);</span>
<span class="line-added">1664   bool pack_value_helper(const GrowableArray&lt;SigEntry&gt;* sig, int&amp; sig_index, int vtarg_index,</span>
<span class="line-added">1665                          VMReg to, VMRegPair* regs_from, int regs_from_count, int&amp; from_index, RegState reg_state[],</span>
<span class="line-added">1666                          int ret_off, int extra_stack_offset);</span>
<span class="line-added">1667   void remove_frame(int initial_framesize, bool needs_stack_repair, int sp_inc_offset);</span>
<span class="line-added">1668 </span>
<span class="line-added">1669   void shuffle_value_args(bool is_packing, bool receiver_only, int extra_stack_offset,</span>
<span class="line-added">1670                           BasicType* sig_bt, const GrowableArray&lt;SigEntry&gt;* sig_cc,</span>
<span class="line-added">1671                           int args_passed, int args_on_stack, VMRegPair* regs,</span>
<span class="line-added">1672                           int args_passed_to, int args_on_stack_to, VMRegPair* regs_to, int sp_inc);</span>
<span class="line-added">1673   bool shuffle_value_args_spill(bool is_packing,  const GrowableArray&lt;SigEntry&gt;* sig_cc, int sig_cc_index,</span>
<span class="line-added">1674                                 VMRegPair* regs_from, int from_index, int regs_from_count,</span>
<span class="line-added">1675                                 RegState* reg_state, int sp_inc, int extra_stack_offset);</span>
<span class="line-added">1676   VMReg spill_reg_for(VMReg reg);</span>
1677 
1678   // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39;;
1679   // if &#39;is_large&#39; is set, do not try to produce short loop
<span class="line-modified">1680   void clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp, bool is_large, bool word_copy_only);</span>
1681 
1682   // clear memory of size &#39;cnt&#39; qwords, starting at &#39;base&#39; using XMM/YMM registers
<span class="line-modified">1683   void xmm_clear_mem(Register base, Register cnt, Register val, XMMRegister xtmp);</span>
1684 
1685   // Fill primitive arrays
1686   void generate_fill(BasicType t, bool aligned,
1687                      Register to, Register value, Register count,
1688                      Register rtmp, XMMRegister xtmp);
1689 
1690   void encode_iso_array(Register src, Register dst, Register len,
1691                         XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3,
1692                         XMMRegister tmp4, Register tmp5, Register result);
1693 
1694 #ifdef _LP64
1695   void add2_with_carry(Register dest_hi, Register dest_lo, Register src1, Register src2);
1696   void multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,
1697                              Register y, Register y_idx, Register z,
1698                              Register carry, Register product,
1699                              Register idx, Register kdx);
1700   void multiply_add_128_x_128(Register x_xstart, Register y, Register z,
1701                               Register yz_idx, Register idx,
1702                               Register carry, Register product, int offset);
1703   void multiply_128_x_128_bmi2_loop(Register y, Register z,
</pre>
<hr />
<pre>
1793   // Compress char[] array to byte[].
1794   void char_array_compress(Register src, Register dst, Register len,
1795                            XMMRegister tmp1, XMMRegister tmp2, XMMRegister tmp3,
1796                            XMMRegister tmp4, Register tmp5, Register result);
1797 
1798   // Inflate byte[] array to char[].
1799   void byte_array_inflate(Register src, Register dst, Register len,
1800                           XMMRegister tmp1, Register tmp2);
1801 
1802 #ifdef _LP64
1803   void convert_f2i(Register dst, XMMRegister src);
1804   void convert_d2i(Register dst, XMMRegister src);
1805   void convert_f2l(Register dst, XMMRegister src);
1806   void convert_d2l(Register dst, XMMRegister src);
1807 
1808   void cache_wb(Address line);
1809   void cache_wbsync(bool is_pre);
1810 #endif // _LP64
1811 
1812   void vallones(XMMRegister dst, int vector_len);
<span class="line-added">1813 </span>
<span class="line-added">1814   #include &quot;asm/macroAssembler_common.hpp&quot;</span>
1815 };
1816 
1817 /**
1818  * class SkipIfEqual:
1819  *
1820  * Instantiating this class will result in assembly code being output that will
1821  * jump around any code emitted between the creation of the instance and it&#39;s
1822  * automatic destruction at the end of a scope block, depending on the value of
1823  * the flag passed to the constructor, which will be checked at run-time.
1824  */
1825 class SkipIfEqual {
1826  private:
1827   MacroAssembler* _masm;
1828   Label _label;
1829 
1830  public:
1831    SkipIfEqual(MacroAssembler*, const bool* flag_addr, bool value);
1832    ~SkipIfEqual();
1833 };
1834 
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="stubGenerator_x86_64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
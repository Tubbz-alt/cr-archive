<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/parse1.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="library_call.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../prims/jvm.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/parse1.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 35,10 ***</span>
<span class="line-new-header">--- 35,11 ---</span>
  #include &quot;opto/memnode.hpp&quot;
  #include &quot;opto/opaquenode.hpp&quot;
  #include &quot;opto/parse.hpp&quot;
  #include &quot;opto/rootnode.hpp&quot;
  #include &quot;opto/runtime.hpp&quot;
<span class="line-added">+ #include &quot;opto/valuetypenode.hpp&quot;</span>
  #include &quot;runtime/arguments.hpp&quot;
  #include &quot;runtime/handles.inline.hpp&quot;
  #include &quot;runtime/safepointMechanism.hpp&quot;
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;utilities/bitMap.inline.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 100,14 ***</span>
  
  //------------------------------ON STACK REPLACEMENT---------------------------
  
  // Construct a node which can be used to get incoming state for
  // on stack replacement.
<span class="line-modified">! Node *Parse::fetch_interpreter_state(int index,</span>
<span class="line-modified">!                                      BasicType bt,</span>
<span class="line-modified">!                                      Node *local_addrs,</span>
<span class="line-modified">!                                      Node *local_addrs_base) {</span>
    Node *mem = memory(Compile::AliasIdxRaw);
    Node *adr = basic_plus_adr( local_addrs_base, local_addrs, -index*wordSize );
    Node *ctl = control();
  
    // Very similar to LoadNode::make, except we handle un-aligned longs and
<span class="line-new-header">--- 101,20 ---</span>
  
  //------------------------------ON STACK REPLACEMENT---------------------------
  
  // Construct a node which can be used to get incoming state for
  // on stack replacement.
<span class="line-modified">! Node* Parse::fetch_interpreter_state(int index,</span>
<span class="line-modified">!                                      const Type* type,</span>
<span class="line-modified">!                                      Node* local_addrs,</span>
<span class="line-modified">!                                      Node* local_addrs_base) {</span>
<span class="line-added">+   BasicType bt = type-&gt;basic_type();</span>
<span class="line-added">+   if (type == TypePtr::NULL_PTR) {</span>
<span class="line-added">+     // Ptr types are mixed together with T_ADDRESS but NULL is</span>
<span class="line-added">+     // really for T_OBJECT types so correct it.</span>
<span class="line-added">+     bt = T_OBJECT;</span>
<span class="line-added">+   }</span>
    Node *mem = memory(Compile::AliasIdxRaw);
    Node *adr = basic_plus_adr( local_addrs_base, local_addrs, -index*wordSize );
    Node *ctl = control();
  
    // Very similar to LoadNode::make, except we handle un-aligned longs and
</pre>
<hr />
<pre>
<span class="line-old-header">*** 115,10 ***</span>
<span class="line-new-header">--- 122,11 ---</span>
    Node *l = NULL;
    switch (bt) {                // Signature is flattened
    case T_INT:     l = new LoadINode(ctl, mem, adr, TypeRawPtr::BOTTOM, TypeInt::INT,        MemNode::unordered); break;
    case T_FLOAT:   l = new LoadFNode(ctl, mem, adr, TypeRawPtr::BOTTOM, Type::FLOAT,         MemNode::unordered); break;
    case T_ADDRESS: l = new LoadPNode(ctl, mem, adr, TypeRawPtr::BOTTOM, TypeRawPtr::BOTTOM,  MemNode::unordered); break;
<span class="line-added">+   case T_VALUETYPE:</span>
    case T_OBJECT:  l = new LoadPNode(ctl, mem, adr, TypeRawPtr::BOTTOM, TypeInstPtr::BOTTOM, MemNode::unordered); break;
    case T_LONG:
    case T_DOUBLE: {
      // Since arguments are in reverse order, the argument address &#39;adr&#39;
      // refers to the back half of the long/double.  Recompute adr.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 145,11 ***</span>
  // The type is the type predicted by ciTypeFlow.  Note that it is
  // not a general type, but can only come from Type::get_typeflow_type.
  // The safepoint is a map which will feed an uncommon trap.
  Node* Parse::check_interpreter_type(Node* l, const Type* type,
                                      SafePointNode* &amp;bad_type_exit) {
<span class="line-modified">! </span>
    }
  
    // TypeFlow may assert null-ness if a type appears unloaded.
    if (type == TypePtr::NULL_PTR ||
        (tp != NULL &amp;&amp; !tp-&gt;klass()-&gt;is_loaded())) {
<span class="line-new-header">--- 153,15 ---</span>
  // The type is the type predicted by ciTypeFlow.  Note that it is
  // not a general type, but can only come from Type::get_typeflow_type.
  // The safepoint is a map which will feed an uncommon trap.
  Node* Parse::check_interpreter_type(Node* l, const Type* type,
                                      SafePointNode* &amp;bad_type_exit) {
<span class="line-modified">!   const TypeOopPtr* tp = type-&gt;isa_oopptr();</span>
<span class="line-added">+   if (type-&gt;isa_valuetype() != NULL) {</span>
<span class="line-added">+     // The interpreter passes value types as oops</span>
<span class="line-added">+     tp = TypeOopPtr::make_from_klass(type-&gt;value_klass());</span>
<span class="line-added">+     tp = tp-&gt;join_speculative(TypePtr::NOTNULL)-&gt;is_oopptr();</span>
    }
  
    // TypeFlow may assert null-ness if a type appears unloaded.
    if (type == TypePtr::NULL_PTR ||
        (tp != NULL &amp;&amp; !tp-&gt;klass()-&gt;is_loaded())) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 169,16 ***</span>
    // toward more specific classes.  Make sure these specific classes
    // are still in effect.
    if (tp != NULL &amp;&amp; tp-&gt;klass() != C-&gt;env()-&gt;Object_klass()) {
      // TypeFlow asserted a specific object type.  Value must have that type.
      Node* bad_type_ctrl = NULL;
      l = gen_checkcast(l, makecon(TypeKlassPtr::make(tp-&gt;klass())), &amp;bad_type_ctrl);
      bad_type_exit-&gt;control()-&gt;add_req(bad_type_ctrl);
    }
<span class="line-removed">- </span>
<span class="line-removed">-   BasicType bt_l = _gvn.type(l)-&gt;basic_type();</span>
<span class="line-removed">-   BasicType bt_t = type-&gt;basic_type();</span>
    assert(_gvn.type(l)-&gt;higher_equal(type), &quot;must constrain OSR typestate&quot;);
    return l;
  }
  
  // Helper routine which sets up elements of the initial parser map when
<span class="line-new-header">--- 181,19 ---</span>
    // toward more specific classes.  Make sure these specific classes
    // are still in effect.
    if (tp != NULL &amp;&amp; tp-&gt;klass() != C-&gt;env()-&gt;Object_klass()) {
      // TypeFlow asserted a specific object type.  Value must have that type.
      Node* bad_type_ctrl = NULL;
<span class="line-added">+     if (tp-&gt;is_valuetypeptr() &amp;&amp; !tp-&gt;maybe_null()) {</span>
<span class="line-added">+       // Check value types for null here to prevent checkcast from adding an</span>
<span class="line-added">+       // exception state before the bytecode entry (use &#39;bad_type_ctrl&#39; instead).</span>
<span class="line-added">+       l = null_check_oop(l, &amp;bad_type_ctrl);</span>
<span class="line-added">+       bad_type_exit-&gt;control()-&gt;add_req(bad_type_ctrl);</span>
<span class="line-added">+     }</span>
      l = gen_checkcast(l, makecon(TypeKlassPtr::make(tp-&gt;klass())), &amp;bad_type_ctrl);
      bad_type_exit-&gt;control()-&gt;add_req(bad_type_ctrl);
    }
    assert(_gvn.type(l)-&gt;higher_equal(type), &quot;must constrain OSR typestate&quot;);
    return l;
  }
  
  // Helper routine which sets up elements of the initial parser map when
</pre>
<hr />
<pre>
<span class="line-old-header">*** 187,11 ***</span>
  void Parse::load_interpreter_state(Node* osr_buf) {
    int index;
    int max_locals = jvms()-&gt;loc_size();
    int max_stack  = jvms()-&gt;stk_size();
  
<span class="line-removed">- </span>
    // Mismatch between method and jvms can occur since map briefly held
    // an OSR entry state (which takes up one RawPtr word).
    assert(max_locals == method()-&gt;max_locals(), &quot;sanity&quot;);
    assert(max_stack  &gt;= method()-&gt;max_stack(),  &quot;sanity&quot;);
    assert((int)jvms()-&gt;endoff() == TypeFunc::Parms + max_locals + max_stack, &quot;sanity&quot;);
<span class="line-new-header">--- 202,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 225,18 ***</span>
    Node *monitors_addr = basic_plus_adr(osr_buf, osr_buf, (max_locals+mcnt*2-1)*wordSize);
    for (index = 0; index &lt; mcnt; index++) {
      // Make a BoxLockNode for the monitor.
      Node *box = _gvn.transform(new BoxLockNode(next_monitor()));
  
<span class="line-removed">- </span>
      // Displaced headers and locked objects are interleaved in the
      // temp OSR buffer.  We only copy the locked objects out here.
      // Fetch the locked object from the OSR temp buffer and copy to our fastlock node.
<span class="line-modified">!     Node *lock_object = fetch_interpreter_state(index*2, T_OBJECT, monitors_addr, osr_buf);</span>
      // Try and copy the displaced header to the BoxNode
<span class="line-modified">!     Node *displaced_hdr = fetch_interpreter_state((index*2) + 1, T_ADDRESS, monitors_addr, osr_buf);</span>
<span class="line-removed">- </span>
  
      store_to_memory(control(), box, displaced_hdr, T_ADDRESS, Compile::AliasIdxRaw, MemNode::unordered);
  
      // Build a bogus FastLockNode (no code will be generated) and push the
      // monitor into our debug info.
<span class="line-new-header">--- 239,16 ---</span>
    Node *monitors_addr = basic_plus_adr(osr_buf, osr_buf, (max_locals+mcnt*2-1)*wordSize);
    for (index = 0; index &lt; mcnt; index++) {
      // Make a BoxLockNode for the monitor.
      Node *box = _gvn.transform(new BoxLockNode(next_monitor()));
  
      // Displaced headers and locked objects are interleaved in the
      // temp OSR buffer.  We only copy the locked objects out here.
      // Fetch the locked object from the OSR temp buffer and copy to our fastlock node.
<span class="line-modified">!     Node* lock_object = fetch_interpreter_state(index*2, Type::get_const_basic_type(T_OBJECT), monitors_addr, osr_buf);</span>
      // Try and copy the displaced header to the BoxNode
<span class="line-modified">!     Node* displaced_hdr = fetch_interpreter_state((index*2) + 1, Type::get_const_basic_type(T_ADDRESS), monitors_addr, osr_buf);</span>
  
      store_to_memory(control(), box, displaced_hdr, T_ADDRESS, Compile::AliasIdxRaw, MemNode::unordered);
  
      // Build a bogus FastLockNode (no code will be generated) and push the
      // monitor into our debug info.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 299,17 ***</span>
      // makes it go dead.
      if (type == Type::BOTTOM) {
        continue;
      }
      // Construct code to access the appropriate local.
<span class="line-modified">!     BasicType bt = type-&gt;basic_type();</span>
<span class="line-removed">-     if (type == TypePtr::NULL_PTR) {</span>
<span class="line-removed">-       // Ptr types are mixed together with T_ADDRESS but NULL is</span>
<span class="line-removed">-       // really for T_OBJECT types so correct it.</span>
<span class="line-removed">-       bt = T_OBJECT;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     Node *value = fetch_interpreter_state(index, bt, locals_addr, osr_buf);</span>
      set_local(index, value);
    }
  
    // Extract the needed stack entries from the interpreter frame.
    for (index = 0; index &lt; sp(); index++) {
<span class="line-new-header">--- 311,11 ---</span>
      // makes it go dead.
      if (type == Type::BOTTOM) {
        continue;
      }
      // Construct code to access the appropriate local.
<span class="line-modified">!     Node* value = fetch_interpreter_state(index, type, locals_addr, osr_buf);</span>
      set_local(index, value);
    }
  
    // Extract the needed stack entries from the interpreter frame.
    for (index = 0; index &lt; sp(); index++) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 595,10 ***</span>
<span class="line-new-header">--- 601,31 ---</span>
      if (log)  log-&gt;done(&quot;parse&quot;);
      C-&gt;set_default_node_notes(caller_nn);
      return;
    }
  
<span class="line-added">+   // Handle value type arguments</span>
<span class="line-added">+   int arg_size_sig = tf()-&gt;domain_sig()-&gt;cnt();</span>
<span class="line-added">+   for (uint i = 0; i &lt; (uint)arg_size_sig; i++) {</span>
<span class="line-added">+     Node* parm = map()-&gt;in(i);</span>
<span class="line-added">+     const Type* t = _gvn.type(parm);</span>
<span class="line-added">+     if (t-&gt;is_valuetypeptr() &amp;&amp; t-&gt;value_klass()-&gt;is_scalarizable() &amp;&amp; !t-&gt;maybe_null()) {</span>
<span class="line-added">+       // Create ValueTypeNode from the oop and replace the parameter</span>
<span class="line-added">+       Node* vt = ValueTypeNode::make_from_oop(this, parm, t-&gt;value_klass());</span>
<span class="line-added">+       map()-&gt;replace_edge(parm, vt);</span>
<span class="line-added">+     } else if (UseTypeSpeculation &amp;&amp; (i == (uint)(arg_size_sig - 1)) &amp;&amp; !is_osr_parse() &amp;&amp;</span>
<span class="line-added">+                method()-&gt;has_vararg() &amp;&amp; t-&gt;isa_aryptr() != NULL &amp;&amp; !t-&gt;is_aryptr()-&gt;is_not_null_free()) {</span>
<span class="line-added">+       // Speculate on varargs Object array being not null-free (and therefore also not flattened)</span>
<span class="line-added">+       const TypePtr* spec_type = t-&gt;speculative();</span>
<span class="line-added">+       spec_type = (spec_type != NULL &amp;&amp; spec_type-&gt;isa_aryptr() != NULL) ? spec_type : t-&gt;is_aryptr();</span>
<span class="line-added">+       spec_type = spec_type-&gt;remove_speculative()-&gt;is_aryptr()-&gt;cast_to_not_null_free();</span>
<span class="line-added">+       spec_type = TypeOopPtr::make(TypePtr::BotPTR, Type::Offset::bottom, TypeOopPtr::InstanceBot, spec_type);</span>
<span class="line-added">+       Node* cast = _gvn.transform(new CheckCastPPNode(control(), parm, t-&gt;join_speculative(spec_type)));</span>
<span class="line-added">+       replace_in_map(parm, cast);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    entry_map = map();  // capture any changes performed by method setup code
    assert(jvms()-&gt;endoff() == map()-&gt;req(), &quot;map matches JVMS layout&quot;);
  
    // We begin parsing as if we have just encountered a jump to the
    // method entry.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 777,12 ***</span>
    gvn().set_type_bottom(memphi);
    _exits.set_i_o(iophi);
    _exits.set_all_memory(memphi);
  
    // Add a return value to the exit state.  (Do not push it yet.)
<span class="line-modified">!   if (tf()-&gt;range()-&gt;cnt() &gt; TypeFunc::Parms) {</span>
<span class="line-modified">!     const Type* ret_type = tf()-&gt;range()-&gt;field_at(TypeFunc::Parms);</span>
      if (ret_type-&gt;isa_int()) {
        BasicType ret_bt = method()-&gt;return_type()-&gt;basic_type();
        if (ret_bt == T_BOOLEAN ||
            ret_bt == T_CHAR ||
            ret_bt == T_BYTE ||
<span class="line-new-header">--- 804,12 ---</span>
    gvn().set_type_bottom(memphi);
    _exits.set_i_o(iophi);
    _exits.set_all_memory(memphi);
  
    // Add a return value to the exit state.  (Do not push it yet.)
<span class="line-modified">!   if (tf()-&gt;range_sig()-&gt;cnt() &gt; TypeFunc::Parms) {</span>
<span class="line-modified">!     const Type* ret_type = tf()-&gt;range_sig()-&gt;field_at(TypeFunc::Parms);</span>
      if (ret_type-&gt;isa_int()) {
        BasicType ret_bt = method()-&gt;return_type()-&gt;basic_type();
        if (ret_bt == T_BOOLEAN ||
            ret_bt == T_CHAR ||
            ret_bt == T_BYTE ||
</pre>
<hr />
<pre>
<span class="line-old-header">*** 796,30 ***</span>
      // types will not join when we transform and push in do_exits().
      const TypeOopPtr* ret_oop_type = ret_type-&gt;isa_oopptr();
      if (ret_oop_type &amp;&amp; !ret_oop_type-&gt;klass()-&gt;is_loaded()) {
        ret_type = TypeOopPtr::BOTTOM;
      }
      int         ret_size = type2size[ret_type-&gt;basic_type()];
      Node*       ret_phi  = new PhiNode(region, ret_type);
      gvn().set_type_bottom(ret_phi);
      _exits.ensure_stack(ret_size);
<span class="line-modified">!     assert((int)(tf()-&gt;range()-&gt;cnt() - TypeFunc::Parms) == ret_size, &quot;good tf range&quot;);</span>
      assert(method()-&gt;return_type()-&gt;size() == ret_size, &quot;tf agrees w/ method&quot;);
      _exits.set_argument(0, ret_phi);  // here is where the parser finds it
      // Note:  ret_phi is not yet pushed, until do_exits.
    }
  }
  
<span class="line-removed">- </span>
  //----------------------------build_start_state-------------------------------
  // Construct a state which contains only the incoming arguments from an
  // unknown caller.  The method &amp; bci will be NULL &amp; InvocationEntryBci.
  JVMState* Compile::build_start_state(StartNode* start, const TypeFunc* tf) {
<span class="line-modified">!   int        arg_size = tf-&gt;domain()-&gt;cnt();</span>
<span class="line-modified">!   int        max_size = MAX2(arg_size, (int)tf-&gt;range()-&gt;cnt());</span>
    JVMState*  jvms     = new (this) JVMState(max_size - TypeFunc::Parms);
    SafePointNode* map  = new SafePointNode(max_size, NULL);
    record_for_igvn(map);
    assert(arg_size == TypeFunc::Parms + (is_osr_compilation() ? 1 : method()-&gt;arg_size()), &quot;correct arg_size&quot;);
    Node_Notes* old_nn = default_node_notes();
    if (old_nn != NULL &amp;&amp; has_method()) {
      Node_Notes* entry_nn = old_nn-&gt;clone(this);
<span class="line-new-header">--- 823,36 ---</span>
      // types will not join when we transform and push in do_exits().
      const TypeOopPtr* ret_oop_type = ret_type-&gt;isa_oopptr();
      if (ret_oop_type &amp;&amp; !ret_oop_type-&gt;klass()-&gt;is_loaded()) {
        ret_type = TypeOopPtr::BOTTOM;
      }
<span class="line-added">+     if ((_caller-&gt;has_method() || tf()-&gt;returns_value_type_as_fields()) &amp;&amp;</span>
<span class="line-added">+         ret_type-&gt;is_valuetypeptr() &amp;&amp; ret_type-&gt;value_klass()-&gt;is_scalarizable() &amp;&amp; !ret_type-&gt;maybe_null()) {</span>
<span class="line-added">+       // Scalarize value type return when inlining or with multiple return values</span>
<span class="line-added">+       ret_type = TypeValueType::make(ret_type-&gt;value_klass());</span>
<span class="line-added">+     }</span>
      int         ret_size = type2size[ret_type-&gt;basic_type()];
      Node*       ret_phi  = new PhiNode(region, ret_type);
      gvn().set_type_bottom(ret_phi);
      _exits.ensure_stack(ret_size);
<span class="line-modified">!     assert((int)(tf()-&gt;range_sig()-&gt;cnt() - TypeFunc::Parms) == ret_size, &quot;good tf range&quot;);</span>
      assert(method()-&gt;return_type()-&gt;size() == ret_size, &quot;tf agrees w/ method&quot;);
      _exits.set_argument(0, ret_phi);  // here is where the parser finds it
      // Note:  ret_phi is not yet pushed, until do_exits.
    }
  }
  
  //----------------------------build_start_state-------------------------------
  // Construct a state which contains only the incoming arguments from an
  // unknown caller.  The method &amp; bci will be NULL &amp; InvocationEntryBci.
  JVMState* Compile::build_start_state(StartNode* start, const TypeFunc* tf) {
<span class="line-modified">!   int        arg_size = tf-&gt;domain_sig()-&gt;cnt();</span>
<span class="line-modified">!   int        max_size = MAX2(arg_size, (int)tf-&gt;range_cc()-&gt;cnt());</span>
    JVMState*  jvms     = new (this) JVMState(max_size - TypeFunc::Parms);
    SafePointNode* map  = new SafePointNode(max_size, NULL);
<span class="line-added">+   map-&gt;set_jvms(jvms);</span>
<span class="line-added">+   jvms-&gt;set_map(map);</span>
    record_for_igvn(map);
    assert(arg_size == TypeFunc::Parms + (is_osr_compilation() ? 1 : method()-&gt;arg_size()), &quot;correct arg_size&quot;);
    Node_Notes* old_nn = default_node_notes();
    if (old_nn != NULL &amp;&amp; has_method()) {
      Node_Notes* entry_nn = old_nn-&gt;clone(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 827,24 ***</span>
      entry_jvms-&gt;set_offsets(0);
      entry_jvms-&gt;set_bci(entry_bci());
      entry_nn-&gt;set_jvms(entry_jvms);
      set_default_node_notes(entry_nn);
    }
<span class="line-modified">!   uint i;</span>
<span class="line-modified">!   for (i = 0; i &lt; (uint)arg_size; i++) {</span>
<span class="line-modified">!     Node* parm = initial_gvn()-&gt;transform(new ParmNode(start, i));</span>
      map-&gt;init_req(i, parm);
      // Record all these guys for later GVN.
      record_for_igvn(parm);
    }
<span class="line-modified">!   for (; i &lt; map-&gt;req(); i++) {</span>
<span class="line-modified">!     map-&gt;init_req(i, top());</span>
    }
    assert(jvms-&gt;argoff() == TypeFunc::Parms, &quot;parser gets arguments here&quot;);
    set_default_node_notes(old_nn);
<span class="line-removed">-   map-&gt;set_jvms(jvms);</span>
<span class="line-removed">-   jvms-&gt;set_map(map);</span>
    return jvms;
  }
  
  //-----------------------------make_node_notes---------------------------------
  Node_Notes* Parse::make_node_notes(Node_Notes* caller_nn) {
<span class="line-new-header">--- 860,44 ---</span>
      entry_jvms-&gt;set_offsets(0);
      entry_jvms-&gt;set_bci(entry_bci());
      entry_nn-&gt;set_jvms(entry_jvms);
      set_default_node_notes(entry_nn);
    }
<span class="line-modified">!   PhaseGVN&amp; gvn = *initial_gvn();</span>
<span class="line-modified">!   uint j = 0;</span>
<span class="line-modified">!   ExtendedSignature sig_cc = ExtendedSignature(method()-&gt;get_sig_cc(), SigEntryFilter());</span>
<span class="line-added">+   for (uint i = 0; i &lt; (uint)arg_size; i++) {</span>
<span class="line-added">+     const Type* t = tf-&gt;domain_sig()-&gt;field_at(i);</span>
<span class="line-added">+     Node* parm = NULL;</span>
<span class="line-added">+     if (has_scalarized_args() &amp;&amp; t-&gt;is_valuetypeptr() &amp;&amp; !t-&gt;maybe_null()) {</span>
<span class="line-added">+       // Value type arguments are not passed by reference: we get an argument per</span>
<span class="line-added">+       // field of the value type. Build ValueTypeNodes from the value type arguments.</span>
<span class="line-added">+       GraphKit kit(jvms, &amp;gvn);</span>
<span class="line-added">+       kit.set_control(map-&gt;control());</span>
<span class="line-added">+       Node* old_mem = map-&gt;memory();</span>
<span class="line-added">+       // Use immutable memory for value type loads and restore it below</span>
<span class="line-added">+       // TODO make sure value types are always loaded from immutable memory</span>
<span class="line-added">+       kit.set_all_memory(C-&gt;immutable_memory());</span>
<span class="line-added">+       parm = ValueTypeNode::make_from_multi(&amp;kit, start, sig_cc, t-&gt;value_klass(), j, true);</span>
<span class="line-added">+       map-&gt;set_control(kit.control());</span>
<span class="line-added">+       map-&gt;set_memory(old_mem);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       parm = gvn.transform(new ParmNode(start, j++));</span>
<span class="line-added">+       BasicType bt = t-&gt;basic_type();</span>
<span class="line-added">+       while (i &gt;= TypeFunc::Parms &amp;&amp; !is_osr_compilation() &amp;&amp; SigEntry::next_is_reserved(sig_cc, bt, true)) {</span>
<span class="line-added">+         j += type2size[bt]; // Skip reserved arguments</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
      map-&gt;init_req(i, parm);
      // Record all these guys for later GVN.
      record_for_igvn(parm);
    }
<span class="line-modified">!   for (; j &lt; map-&gt;req(); j++) {</span>
<span class="line-modified">!     map-&gt;init_req(j, top());</span>
    }
    assert(jvms-&gt;argoff() == TypeFunc::Parms, &quot;parser gets arguments here&quot;);
    set_default_node_notes(old_nn);
    return jvms;
  }
  
  //-----------------------------make_node_notes---------------------------------
  Node_Notes* Parse::make_node_notes(Node_Notes* caller_nn) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 867,16 ***</span>
                               kit.i_o(),
                               kit.reset_memory(),
                               kit.frameptr(),
                               kit.returnadr());
    // Add zero or 1 return values
<span class="line-modified">!   int ret_size = tf()-&gt;range()-&gt;cnt() - TypeFunc::Parms;</span>
    if (ret_size &gt; 0) {
      kit.inc_sp(-ret_size);  // pop the return value(s)
      kit.sync_jvms();
<span class="line-modified">!     ret-&gt;add_req(kit.argument(0));</span>
<span class="line-modified">!     // Note:  The second dummy edge is not needed by a ReturnNode.</span>
    }
    // bind it to root
    root()-&gt;add_req(ret);
    record_for_igvn(ret);
    initial_gvn()-&gt;transform_no_reclaim(ret);
<span class="line-new-header">--- 920,36 ---</span>
                               kit.i_o(),
                               kit.reset_memory(),
                               kit.frameptr(),
                               kit.returnadr());
    // Add zero or 1 return values
<span class="line-modified">!   int ret_size = tf()-&gt;range_sig()-&gt;cnt() - TypeFunc::Parms;</span>
    if (ret_size &gt; 0) {
      kit.inc_sp(-ret_size);  // pop the return value(s)
      kit.sync_jvms();
<span class="line-modified">!     Node* res = kit.argument(0);</span>
<span class="line-modified">!     if (tf()-&gt;returns_value_type_as_fields()) {</span>
<span class="line-added">+       // Multiple return values (value type fields): add as many edges</span>
<span class="line-added">+       // to the Return node as returned values.</span>
<span class="line-added">+       assert(res-&gt;is_ValueType(), &quot;what else supports multi value return?&quot;);</span>
<span class="line-added">+       ValueTypeNode* vt = res-&gt;as_ValueType();</span>
<span class="line-added">+       ret-&gt;add_req_batch(NULL, tf()-&gt;range_cc()-&gt;cnt() - TypeFunc::Parms);</span>
<span class="line-added">+       if (vt-&gt;is_allocated(&amp;kit.gvn()) &amp;&amp; !StressInlineTypeReturnedAsFields) {</span>
<span class="line-added">+         ret-&gt;init_req(TypeFunc::Parms, vt-&gt;get_oop());</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         ret-&gt;init_req(TypeFunc::Parms, vt-&gt;tagged_klass(kit.gvn()));</span>
<span class="line-added">+       }</span>
<span class="line-added">+       const Array&lt;SigEntry&gt;* sig_array = vt-&gt;type()-&gt;value_klass()-&gt;extended_sig();</span>
<span class="line-added">+       GrowableArray&lt;SigEntry&gt; sig = GrowableArray&lt;SigEntry&gt;(sig_array-&gt;length());</span>
<span class="line-added">+       sig.appendAll(sig_array);</span>
<span class="line-added">+       ExtendedSignature sig_cc = ExtendedSignature(&amp;sig, SigEntryFilter());</span>
<span class="line-added">+       uint idx = TypeFunc::Parms+1;</span>
<span class="line-added">+       vt-&gt;pass_fields(&amp;kit, ret, sig_cc, idx);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       ret-&gt;add_req(res);</span>
<span class="line-added">+       // Note:  The second dummy edge is not needed by a ReturnNode.</span>
<span class="line-added">+     }</span>
    }
    // bind it to root
    root()-&gt;add_req(ret);
    record_for_igvn(ret);
    initial_gvn()-&gt;transform_no_reclaim(ret);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 996,11 ***</span>
    // &quot;All bets are off&quot; unless the first publication occurs after a
    // normal return from the constructor.  We do not attempt to detect
    // such unusual early publications.  But no barrier is needed on
    // exceptional returns, since they cannot publish normally.
    //
<span class="line-modified">!   if (method()-&gt;is_initializer() &amp;&amp;</span>
         (wrote_final() ||
           (AlwaysSafeConstructors &amp;&amp; wrote_fields()) ||
           (support_IRIW_for_not_multiple_copy_atomic_cpu &amp;&amp; wrote_volatile()))) {
      _exits.insert_mem_bar(Op_MemBarRelease, alloc_with_final());
  
<span class="line-new-header">--- 1069,11 ---</span>
    // &quot;All bets are off&quot; unless the first publication occurs after a
    // normal return from the constructor.  We do not attempt to detect
    // such unusual early publications.  But no barrier is needed on
    // exceptional returns, since they cannot publish normally.
    //
<span class="line-modified">!   if (method()-&gt;is_object_constructor_or_class_initializer() &amp;&amp;</span>
         (wrote_final() ||
           (AlwaysSafeConstructors &amp;&amp; wrote_fields()) ||
           (support_IRIW_for_not_multiple_copy_atomic_cpu &amp;&amp; wrote_volatile()))) {
      _exits.insert_mem_bar(Op_MemBarRelease, alloc_with_final());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1034,12 ***</span>
      mms.set_memory(_gvn.transform(mms.memory()));
    }
    // Clean up input MergeMems created by transforming the slices
    _gvn.transform(_exits.merged_memory());
  
<span class="line-modified">!   if (tf()-&gt;range()-&gt;cnt() &gt; TypeFunc::Parms) {</span>
<span class="line-modified">!     const Type* ret_type = tf()-&gt;range()-&gt;field_at(TypeFunc::Parms);</span>
      Node*       ret_phi  = _gvn.transform( _exits.argument(0) );
      if (!_exits.control()-&gt;is_top() &amp;&amp; _gvn.type(ret_phi)-&gt;empty()) {
        // If the type we set for the ret_phi in build_exits() is too optimistic and
        // the ret_phi is top now, there&#39;s an extremely small chance that it may be due to class
        // loading.  It could also be due to an error, so mark this method as not compilable because
<span class="line-new-header">--- 1107,12 ---</span>
      mms.set_memory(_gvn.transform(mms.memory()));
    }
    // Clean up input MergeMems created by transforming the slices
    _gvn.transform(_exits.merged_memory());
  
<span class="line-modified">!   if (tf()-&gt;range_sig()-&gt;cnt() &gt; TypeFunc::Parms) {</span>
<span class="line-modified">!     const Type* ret_type = tf()-&gt;range_sig()-&gt;field_at(TypeFunc::Parms);</span>
      Node*       ret_phi  = _gvn.transform( _exits.argument(0) );
      if (!_exits.control()-&gt;is_top() &amp;&amp; _gvn.type(ret_phi)-&gt;empty()) {
        // If the type we set for the ret_phi in build_exits() is too optimistic and
        // the ret_phi is top now, there&#39;s an extremely small chance that it may be due to class
        // loading.  It could also be due to an error, so mark this method as not compilable because
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1130,11 ***</span>
    _caller-&gt;map()-&gt;delete_replaced_nodes();
  
    // If this is an inlined method, we may have to do a receiver null check.
    if (_caller-&gt;has_method() &amp;&amp; is_normal_parse() &amp;&amp; !method()-&gt;is_static()) {
      GraphKit kit(_caller);
<span class="line-modified">!     kit.null_check_receiver_before_call(method());</span>
      _caller = kit.transfer_exceptions_into_jvms();
      if (kit.stopped()) {
        _exits.add_exception_states_from(_caller);
        _exits.set_jvms(_caller);
        return NULL;
<span class="line-new-header">--- 1203,11 ---</span>
    _caller-&gt;map()-&gt;delete_replaced_nodes();
  
    // If this is an inlined method, we may have to do a receiver null check.
    if (_caller-&gt;has_method() &amp;&amp; is_normal_parse() &amp;&amp; !method()-&gt;is_static()) {
      GraphKit kit(_caller);
<span class="line-modified">!     kit.null_check_receiver_before_call(method(), false);</span>
      _caller = kit.transfer_exceptions_into_jvms();
      if (kit.stopped()) {
        _exits.add_exception_states_from(_caller);
        _exits.set_jvms(_caller);
        return NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1168,11 ***</span>
      set_all_memory(reset_memory());
    }
    assert(merged_memory(), &quot;&quot;);
  
    // Now add the locals which are initially bound to arguments:
<span class="line-modified">!   uint arg_size = tf()-&gt;domain()-&gt;cnt();</span>
    ensure_stack(arg_size - TypeFunc::Parms);  // OSR methods have funny args
    for (i = TypeFunc::Parms; i &lt; arg_size; i++) {
      map()-&gt;init_req(i, inmap-&gt;argument(_caller, i - TypeFunc::Parms));
    }
  
<span class="line-new-header">--- 1241,11 ---</span>
      set_all_memory(reset_memory());
    }
    assert(merged_memory(), &quot;&quot;);
  
    // Now add the locals which are initially bound to arguments:
<span class="line-modified">!   uint arg_size = tf()-&gt;domain_sig()-&gt;cnt();</span>
    ensure_stack(arg_size - TypeFunc::Parms);  // OSR methods have funny args
    for (i = TypeFunc::Parms; i &lt; arg_size; i++) {
      map()-&gt;init_req(i, inmap-&gt;argument(_caller, i - TypeFunc::Parms));
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1215,10 ***</span>
<span class="line-new-header">--- 1288,11 ---</span>
        ciInstance* mirror = _method-&gt;holder()-&gt;java_mirror();
        const TypeInstPtr *t_lock = TypeInstPtr::make(mirror);
        lock_obj = makecon(t_lock);
      } else {                  // Else pass the &quot;this&quot; pointer,
        lock_obj = local(0);    // which is Parm0 from StartNode
<span class="line-added">+       assert(!_gvn.type(lock_obj)-&gt;make_oopptr()-&gt;can_be_value_type(), &quot;can&#39;t be an inline type&quot;);</span>
      }
      // Clear out dead values from the debug info.
      kill_dead_locals();
      // Build the FastLockNode
      _synch_lock = shared_lock(lock_obj);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1625,10 ***</span>
<span class="line-new-header">--- 1699,43 ---</span>
  
    // Zap extra stack slots to top
    assert(sp() == target-&gt;start_sp(), &quot;&quot;);
    clean_stack(sp());
  
<span class="line-added">+   // Check for merge conflicts involving value types</span>
<span class="line-added">+   JVMState* old_jvms = map()-&gt;jvms();</span>
<span class="line-added">+   int old_bci = bci();</span>
<span class="line-added">+   JVMState* tmp_jvms = old_jvms-&gt;clone_shallow(C);</span>
<span class="line-added">+   tmp_jvms-&gt;set_should_reexecute(true);</span>
<span class="line-added">+   map()-&gt;set_jvms(tmp_jvms);</span>
<span class="line-added">+   // Execution needs to restart a the next bytecode (entry of next</span>
<span class="line-added">+   // block)</span>
<span class="line-added">+   if (target-&gt;is_merged() ||</span>
<span class="line-added">+       pnum &gt; PhiNode::Input ||</span>
<span class="line-added">+       target-&gt;is_handler() ||</span>
<span class="line-added">+       target-&gt;is_loop_head()) {</span>
<span class="line-added">+     set_parse_bci(target-&gt;start());</span>
<span class="line-added">+     for (uint j = TypeFunc::Parms; j &lt; map()-&gt;req(); j++) {</span>
<span class="line-added">+       Node* n = map()-&gt;in(j);                 // Incoming change to target state.</span>
<span class="line-added">+       const Type* t = NULL;</span>
<span class="line-added">+       if (tmp_jvms-&gt;is_loc(j)) {</span>
<span class="line-added">+         t = target-&gt;local_type_at(j - tmp_jvms-&gt;locoff());</span>
<span class="line-added">+       } else if (tmp_jvms-&gt;is_stk(j) &amp;&amp; j &lt; (uint)sp() + tmp_jvms-&gt;stkoff()) {</span>
<span class="line-added">+         t = target-&gt;stack_type_at(j - tmp_jvms-&gt;stkoff());</span>
<span class="line-added">+       }</span>
<span class="line-added">+       if (t != NULL &amp;&amp; t != Type::BOTTOM) {</span>
<span class="line-added">+         if (n-&gt;is_ValueType() &amp;&amp; !t-&gt;isa_valuetype()) {</span>
<span class="line-added">+           // Allocate value type in src block to be able to merge it with oop in target block</span>
<span class="line-added">+           map()-&gt;set_req(j, ValueTypePtrNode::make_from_value_type(this, n-&gt;as_ValueType()));</span>
<span class="line-added">+         }</span>
<span class="line-added">+         assert(!t-&gt;isa_valuetype() || n-&gt;is_ValueType(), &quot;inconsistent typeflow info&quot;);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   map()-&gt;set_jvms(old_jvms);</span>
<span class="line-added">+   set_parse_bci(old_bci);</span>
<span class="line-added">+ </span>
    if (!target-&gt;is_merged()) {   // No prior mapping at this bci
      if (TraceOptoParse) { tty-&gt;print(&quot; with empty state&quot;);  }
  
      // If this path is dead, do not bother capturing it as a merge.
      // It is &quot;as if&quot; we had 1 fewer predecessors from the beginning.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1678,10 ***</span>
<span class="line-new-header">--- 1785,11 ---</span>
  #ifdef ASSERT
      if (target-&gt;is_SEL_head()) {
        target-&gt;mark_merged_backedge(block());
      }
  #endif
<span class="line-added">+ </span>
      // We must not manufacture more phis if the target is already parsed.
      bool nophi = target-&gt;is_parsed();
  
      SafePointNode* newin = map();// Hang on to incoming mapping
      Block* save_block = block(); // Hang on to incoming block;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1713,18 ***</span>
      }
  
      // Update all the non-control inputs to map:
      assert(TypeFunc::Parms == newin-&gt;jvms()-&gt;locoff(), &quot;parser map should contain only youngest jvms&quot;);
      bool check_elide_phi = target-&gt;is_SEL_backedge(save_block);
      for (uint j = 1; j &lt; newin-&gt;req(); j++) {
        Node* m = map()-&gt;in(j);   // Current state of target.
        Node* n = newin-&gt;in(j);   // Incoming change to target state.
        PhiNode* phi;
<span class="line-modified">!       if (m-&gt;is_Phi() &amp;&amp; m-&gt;as_Phi()-&gt;region() == r)</span>
          phi = m-&gt;as_Phi();
<span class="line-modified">!       else</span>
          phi = NULL;
        if (m != n) {             // Different; must merge
          switch (j) {
          // Frame pointer and Return Address never changes
          case TypeFunc::FramePtr:// Drop m, use the original value
          case TypeFunc::ReturnAdr:
<span class="line-new-header">--- 1821,22 ---</span>
      }
  
      // Update all the non-control inputs to map:
      assert(TypeFunc::Parms == newin-&gt;jvms()-&gt;locoff(), &quot;parser map should contain only youngest jvms&quot;);
      bool check_elide_phi = target-&gt;is_SEL_backedge(save_block);
<span class="line-added">+     bool last_merge = (pnum == PhiNode::Input);</span>
      for (uint j = 1; j &lt; newin-&gt;req(); j++) {
        Node* m = map()-&gt;in(j);   // Current state of target.
        Node* n = newin-&gt;in(j);   // Incoming change to target state.
        PhiNode* phi;
<span class="line-modified">!       if (m-&gt;is_Phi() &amp;&amp; m-&gt;as_Phi()-&gt;region() == r) {</span>
          phi = m-&gt;as_Phi();
<span class="line-modified">!       } else if (m-&gt;is_ValueType() &amp;&amp; m-&gt;as_ValueType()-&gt;has_phi_inputs(r)){</span>
<span class="line-added">+         phi = m-&gt;as_ValueType()-&gt;get_oop()-&gt;as_Phi();</span>
<span class="line-added">+       } else {</span>
          phi = NULL;
<span class="line-added">+       }</span>
        if (m != n) {             // Different; must merge
          switch (j) {
          // Frame pointer and Return Address never changes
          case TypeFunc::FramePtr:// Drop m, use the original value
          case TypeFunc::ReturnAdr:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1754,15 ***</span>
        // At this point, n might be top if:
        //  - there is no phi (because TypeFlow detected a conflict), or
        //  - the corresponding control edges is top (a dead incoming path)
        // It is a bug if we create a phi which sees a garbage value on a live path.
  
<span class="line-modified">!       if (phi != NULL) {</span>
          assert(n != top() || r-&gt;in(pnum) == top(), &quot;live value must not be garbage&quot;);
          assert(phi-&gt;region() == r, &quot;&quot;);
          phi-&gt;set_req(pnum, n);  // Then add &#39;n&#39; to the merge
<span class="line-modified">!         if (pnum == PhiNode::Input) {</span>
            // Last merge for this Phi.
            // So far, Phis have had a reasonable type from ciTypeFlow.
            // Now _gvn will join that with the meet of current inputs.
            // BOTTOM is never permissible here, &#39;cause pessimistically
            // Phis of pointers cannot lose the basic pointer type.
<span class="line-new-header">--- 1866,38 ---</span>
        // At this point, n might be top if:
        //  - there is no phi (because TypeFlow detected a conflict), or
        //  - the corresponding control edges is top (a dead incoming path)
        // It is a bug if we create a phi which sees a garbage value on a live path.
  
<span class="line-modified">!       // Merging two value types?</span>
<span class="line-added">+       if (phi != NULL &amp;&amp; n-&gt;is_ValueType()) {</span>
<span class="line-added">+         // Reload current state because it may have been updated by ensure_phi</span>
<span class="line-added">+         m = map()-&gt;in(j);</span>
<span class="line-added">+         ValueTypeNode* vtm = m-&gt;as_ValueType(); // Current value type</span>
<span class="line-added">+         ValueTypeNode* vtn = n-&gt;as_ValueType(); // Incoming value type</span>
<span class="line-added">+         assert(vtm-&gt;get_oop() == phi, &quot;Value type should have Phi input&quot;);</span>
<span class="line-added">+         if (TraceOptoParse) {</span>
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+           tty-&gt;print_cr(&quot;\nMerging value types&quot;);</span>
<span class="line-added">+           tty-&gt;print_cr(&quot;Current:&quot;);</span>
<span class="line-added">+           vtm-&gt;dump(2);</span>
<span class="line-added">+           tty-&gt;print_cr(&quot;Incoming:&quot;);</span>
<span class="line-added">+           vtn-&gt;dump(2);</span>
<span class="line-added">+           tty-&gt;cr();</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+         }</span>
<span class="line-added">+         // Do the merge</span>
<span class="line-added">+         vtm-&gt;merge_with(&amp;_gvn, vtn, pnum, last_merge);</span>
<span class="line-added">+         if (last_merge) {</span>
<span class="line-added">+           map()-&gt;set_req(j, _gvn.transform_no_reclaim(vtm));</span>
<span class="line-added">+           record_for_igvn(vtm);</span>
<span class="line-added">+         }</span>
<span class="line-added">+       } else if (phi != NULL) {</span>
          assert(n != top() || r-&gt;in(pnum) == top(), &quot;live value must not be garbage&quot;);
          assert(phi-&gt;region() == r, &quot;&quot;);
          phi-&gt;set_req(pnum, n);  // Then add &#39;n&#39; to the merge
<span class="line-modified">!         if (last_merge) {</span>
            // Last merge for this Phi.
            // So far, Phis have had a reasonable type from ciTypeFlow.
            // Now _gvn will join that with the meet of current inputs.
            // BOTTOM is never permissible here, &#39;cause pessimistically
            // Phis of pointers cannot lose the basic pointer type.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1774,12 ***</span>
            record_for_igvn(phi);
          }
        }
      } // End of for all values to be merged
  
<span class="line-modified">!     if (pnum == PhiNode::Input &amp;&amp;</span>
<span class="line-removed">-         !r-&gt;in(0)) {         // The occasional useless Region</span>
        assert(control() == r, &quot;&quot;);
        set_control(r-&gt;nonnull_req());
      }
  
      map()-&gt;merge_replaced_nodes_with(newin);
<span class="line-new-header">--- 1909,11 ---</span>
            record_for_igvn(phi);
          }
        }
      } // End of for all values to be merged
  
<span class="line-modified">!     if (last_merge &amp;&amp; !r-&gt;in(0)) {         // The occasional useless Region</span>
        assert(control() == r, &quot;&quot;);
        set_control(r-&gt;nonnull_req());
      }
  
      map()-&gt;merge_replaced_nodes_with(newin);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1927,10 ***</span>
<span class="line-new-header">--- 2061,12 ---</span>
        }
      } else {
        if (n-&gt;is_Phi() &amp;&amp; n-&gt;as_Phi()-&gt;region() == r) {
          assert(n-&gt;req() == pnum, &quot;must be same size as region&quot;);
          n-&gt;add_req(NULL);
<span class="line-added">+       } else if (n-&gt;is_ValueType() &amp;&amp; n-&gt;as_ValueType()-&gt;has_phi_inputs(r)) {</span>
<span class="line-added">+         n-&gt;as_ValueType()-&gt;add_new_path(r);</span>
        }
      }
    }
  
    return pnum;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1949,10 ***</span>
<span class="line-new-header">--- 2085,14 ---</span>
    if (o == top())  return NULL; // TOP always merges into TOP
  
    if (o-&gt;is_Phi() &amp;&amp; o-&gt;as_Phi()-&gt;region() == region) {
      return o-&gt;as_Phi();
    }
<span class="line-added">+   ValueTypeBaseNode* vt = o-&gt;isa_ValueType();</span>
<span class="line-added">+   if (vt != NULL &amp;&amp; vt-&gt;has_phi_inputs(region)) {</span>
<span class="line-added">+     return vt-&gt;get_oop()-&gt;as_Phi();</span>
<span class="line-added">+   }</span>
  
    // Now use a Phi here for merging
    assert(!nocreate, &quot;Cannot build a phi for a block already parsed.&quot;);
    const JVMState* jvms = map-&gt;jvms();
    const Type* t = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1968,12 ***</span>
    } else {
      assert(false, &quot;no type information for this phi&quot;);
    }
  
    // If the type falls to bottom, then this must be a local that
<span class="line-modified">!   // is mixing ints and oops or some such.  Forcing it to top</span>
<span class="line-modified">!   // makes it go dead.</span>
    if (t == Type::BOTTOM) {
      map-&gt;set_req(idx, top());
      return NULL;
    }
  
<span class="line-new-header">--- 2108,12 ---</span>
    } else {
      assert(false, &quot;no type information for this phi&quot;);
    }
  
    // If the type falls to bottom, then this must be a local that
<span class="line-modified">!   // is already dead or is mixing ints and oops or some such.</span>
<span class="line-modified">!   // Forcing it to top makes it go dead.</span>
    if (t == Type::BOTTOM) {
      map-&gt;set_req(idx, top());
      return NULL;
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1982,15 ***</span>
    if (t == Type::TOP || t == Type::HALF) {
      map-&gt;set_req(idx, top());
      return NULL;
    }
  
<span class="line-modified">!   PhiNode* phi = PhiNode::make(region, o, t);</span>
<span class="line-modified">!   gvn().set_type(phi, t);</span>
<span class="line-modified">!   if (C-&gt;do_escape_analysis()) record_for_igvn(phi);</span>
<span class="line-modified">!   map-&gt;set_req(idx, phi);</span>
<span class="line-modified">!   return phi;</span>
  }
  
  //--------------------------ensure_memory_phi----------------------------------
  // Turn the idx&#39;th slice of the current memory into a Phi
  PhiNode *Parse::ensure_memory_phi(int idx, bool nocreate) {
<span class="line-new-header">--- 2122,24 ---</span>
    if (t == Type::TOP || t == Type::HALF) {
      map-&gt;set_req(idx, top());
      return NULL;
    }
  
<span class="line-modified">!   if (vt != NULL) {</span>
<span class="line-modified">!     // Value types are merged by merging their field values.</span>
<span class="line-modified">!     // Create a cloned ValueTypeNode with phi inputs that</span>
<span class="line-modified">!     // represents the merged value type and update the map.</span>
<span class="line-modified">!     vt = vt-&gt;clone_with_phis(&amp;_gvn, region);</span>
<span class="line-added">+     map-&gt;set_req(idx, vt);</span>
<span class="line-added">+     return vt-&gt;get_oop()-&gt;as_Phi();</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     PhiNode* phi = PhiNode::make(region, o, t);</span>
<span class="line-added">+     gvn().set_type(phi, t);</span>
<span class="line-added">+     if (C-&gt;do_escape_analysis()) record_for_igvn(phi);</span>
<span class="line-added">+     map-&gt;set_req(idx, phi);</span>
<span class="line-added">+     return phi;</span>
<span class="line-added">+   }</span>
  }
  
  //--------------------------ensure_memory_phi----------------------------------
  // Turn the idx&#39;th slice of the current memory into a Phi
  PhiNode *Parse::ensure_memory_phi(int idx, bool nocreate) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2179,64 ***</span>
        method()-&gt;intrinsic_id() == vmIntrinsics::_Object_init) {
      call_register_finalizer();
    }
  
    // Do not set_parse_bci, so that return goo is credited to the return insn.
<span class="line-modified">!   set_bci(InvocationEntryBci);</span>
    if (method()-&gt;is_synchronized() &amp;&amp; GenerateSynchronizationCode) {
      shared_unlock(_synch_lock-&gt;box_node(), _synch_lock-&gt;obj_node());
    }
    if (C-&gt;env()-&gt;dtrace_method_probes()) {
      make_dtrace_method_exit(method());
    }
<span class="line-removed">-   SafePointNode* exit_return = _exits.map();</span>
<span class="line-removed">-   exit_return-&gt;in( TypeFunc::Control  )-&gt;add_req( control() );</span>
<span class="line-removed">-   exit_return-&gt;in( TypeFunc::I_O      )-&gt;add_req( i_o    () );</span>
<span class="line-removed">-   Node *mem = exit_return-&gt;in( TypeFunc::Memory   );</span>
<span class="line-removed">-   for (MergeMemStream mms(mem-&gt;as_MergeMem(), merged_memory()); mms.next_non_empty2(); ) {</span>
<span class="line-removed">-     if (mms.is_empty()) {</span>
<span class="line-removed">-       // get a copy of the base memory, and patch just this one input</span>
<span class="line-removed">-       const TypePtr* adr_type = mms.adr_type(C);</span>
<span class="line-removed">-       Node* phi = mms.force_memory()-&gt;as_Phi()-&gt;slice_memory(adr_type);</span>
<span class="line-removed">-       assert(phi-&gt;as_Phi()-&gt;region() == mms.base_memory()-&gt;in(0), &quot;&quot;);</span>
<span class="line-removed">-       gvn().set_type_bottom(phi);</span>
<span class="line-removed">-       phi-&gt;del_req(phi-&gt;req()-1);  // prepare to re-patch</span>
<span class="line-removed">-       mms.set_memory(phi);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     mms.memory()-&gt;add_req(mms.memory2());</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    // frame pointer is always same, already captured
    if (value != NULL) {
<span class="line-modified">!     // If returning oops to an interface-return, there is a silent free</span>
<span class="line-modified">!     // cast from oop to interface allowed by the Verifier.  Make it explicit</span>
<span class="line-modified">!     // here.</span>
<span class="line-modified">!     Node* phi = _exits.argument(0);</span>
<span class="line-modified">!     const TypeInstPtr *tr = phi-&gt;bottom_type()-&gt;isa_instptr();</span>
<span class="line-modified">!     if (tr &amp;&amp; tr-&gt;klass()-&gt;is_loaded() &amp;&amp;</span>
<span class="line-modified">!         tr-&gt;klass()-&gt;is_interface()) {</span>
<span class="line-modified">!       const TypeInstPtr *tp = value-&gt;bottom_type()-&gt;isa_instptr();</span>
<span class="line-modified">!       if (tp &amp;&amp; tp-&gt;klass()-&gt;is_loaded() &amp;&amp;</span>
        if (tp &amp;&amp; tp-&gt;klass()-&gt;is_loaded() &amp;&amp; !tp-&gt;klass()-&gt;is_interface()) {
          // sharpen the type eagerly; this eases certain assert checking
<span class="line-modified">!         if (tp-&gt;higher_equal(TypeInstPtr::NOTNULL))</span>
            tr = tr-&gt;join_speculative(TypeInstPtr::NOTNULL)-&gt;is_instptr();
          value = _gvn.transform(new CheckCastPPNode(0, value, tr));
        }
      } else {
<span class="line-modified">!       // Also handle returns of oop-arrays to an arrays-of-interface return</span>
        const TypeInstPtr* phi_tip;
        const TypeInstPtr* val_tip;
<span class="line-modified">!       Type::get_arrays_base_elements(phi-&gt;bottom_type(), value-&gt;bottom_type(), &amp;phi_tip, &amp;val_tip);</span>
        if (phi_tip != NULL &amp;&amp; phi_tip-&gt;is_loaded() &amp;&amp; phi_tip-&gt;klass()-&gt;is_interface() &amp;&amp;
            val_tip != NULL &amp;&amp; val_tip-&gt;is_loaded() &amp;&amp; !val_tip-&gt;klass()-&gt;is_interface()) {
<span class="line-modified">!         value = _gvn.transform(new CheckCastPPNode(0, value, phi-&gt;bottom_type()));</span>
        }
      }
      phi-&gt;add_req(value);
    }
  
    if (_first_return) {
      _exits.map()-&gt;transfer_replaced_nodes_from(map(), _new_idx);
      _first_return = false;
    } else {
      _exits.map()-&gt;merge_replaced_nodes_with(map());
<span class="line-new-header">--- 2328,90 ---</span>
        method()-&gt;intrinsic_id() == vmIntrinsics::_Object_init) {
      call_register_finalizer();
    }
  
    // Do not set_parse_bci, so that return goo is credited to the return insn.
<span class="line-modified">!   // vreturn can trigger an allocation so vreturn can throw. Setting</span>
<span class="line-added">+   // the bci here breaks exception handling. Commenting this out</span>
<span class="line-added">+   // doesn&#39;t seem to break anything.</span>
<span class="line-added">+   //  set_bci(InvocationEntryBci);</span>
    if (method()-&gt;is_synchronized() &amp;&amp; GenerateSynchronizationCode) {
      shared_unlock(_synch_lock-&gt;box_node(), _synch_lock-&gt;obj_node());
    }
    if (C-&gt;env()-&gt;dtrace_method_probes()) {
      make_dtrace_method_exit(method());
    }
    // frame pointer is always same, already captured
    if (value != NULL) {
<span class="line-modified">!     Node* phi = _exits.argument(0);</span>
<span class="line-modified">!     const Type* return_type = phi-&gt;bottom_type();</span>
<span class="line-modified">!     const TypeOopPtr* tr = return_type-&gt;isa_oopptr();</span>
<span class="line-modified">!     if (return_type-&gt;isa_valuetype() &amp;&amp; !Compile::current()-&gt;inlining_incrementally()) {</span>
<span class="line-modified">!       // Value type is returned as fields, make sure it is scalarized</span>
<span class="line-modified">!       if (!value-&gt;is_ValueType()) {</span>
<span class="line-modified">!         value = ValueTypeNode::make_from_oop(this, value, return_type-&gt;value_klass());</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!       if (!_caller-&gt;has_method()) {</span>
<span class="line-added">+         // Value type is returned as fields from root method, make sure all non-flattened</span>
<span class="line-added">+         // fields are buffered and re-execute if allocation triggers deoptimization.</span>
<span class="line-added">+         PreserveReexecuteState preexecs(this);</span>
<span class="line-added">+         assert(tf()-&gt;returns_value_type_as_fields(), &quot;must be returned as fields&quot;);</span>
<span class="line-added">+         jvms()-&gt;set_should_reexecute(true);</span>
<span class="line-added">+         inc_sp(1);</span>
<span class="line-added">+         value = value-&gt;as_ValueType()-&gt;allocate_fields(this);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     } else if (value-&gt;is_ValueType()) {</span>
<span class="line-added">+       // Value type is returned as oop, make sure it is buffered and re-execute</span>
<span class="line-added">+       // if allocation triggers deoptimization.</span>
<span class="line-added">+       PreserveReexecuteState preexecs(this);</span>
<span class="line-added">+       jvms()-&gt;set_should_reexecute(true);</span>
<span class="line-added">+       inc_sp(1);</span>
<span class="line-added">+       value = ValueTypePtrNode::make_from_value_type(this, value-&gt;as_ValueType());</span>
<span class="line-added">+       if (Compile::current()-&gt;inlining_incrementally()) {</span>
<span class="line-added">+         value = value-&gt;as_ValueTypeBase()-&gt;allocate_fields(this);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     } else if (tr &amp;&amp; tr-&gt;isa_instptr() &amp;&amp; tr-&gt;klass()-&gt;is_loaded() &amp;&amp; tr-&gt;klass()-&gt;is_interface()) {</span>
<span class="line-added">+       // If returning oops to an interface-return, there is a silent free</span>
<span class="line-added">+       // cast from oop to interface allowed by the Verifier. Make it explicit here.</span>
<span class="line-added">+       const TypeInstPtr* tp = value-&gt;bottom_type()-&gt;isa_instptr();</span>
        if (tp &amp;&amp; tp-&gt;klass()-&gt;is_loaded() &amp;&amp; !tp-&gt;klass()-&gt;is_interface()) {
          // sharpen the type eagerly; this eases certain assert checking
<span class="line-modified">!         if (tp-&gt;higher_equal(TypeInstPtr::NOTNULL)) {</span>
            tr = tr-&gt;join_speculative(TypeInstPtr::NOTNULL)-&gt;is_instptr();
<span class="line-added">+         }</span>
          value = _gvn.transform(new CheckCastPPNode(0, value, tr));
        }
      } else {
<span class="line-modified">!       // Handle returns of oop-arrays to an arrays-of-interface return</span>
        const TypeInstPtr* phi_tip;
        const TypeInstPtr* val_tip;
<span class="line-modified">!       Type::get_arrays_base_elements(return_type, value-&gt;bottom_type(), &amp;phi_tip, &amp;val_tip);</span>
        if (phi_tip != NULL &amp;&amp; phi_tip-&gt;is_loaded() &amp;&amp; phi_tip-&gt;klass()-&gt;is_interface() &amp;&amp;
            val_tip != NULL &amp;&amp; val_tip-&gt;is_loaded() &amp;&amp; !val_tip-&gt;klass()-&gt;is_interface()) {
<span class="line-modified">!         value = _gvn.transform(new CheckCastPPNode(0, value, return_type));</span>
        }
      }
      phi-&gt;add_req(value);
    }
  
<span class="line-added">+   SafePointNode* exit_return = _exits.map();</span>
<span class="line-added">+   exit_return-&gt;in( TypeFunc::Control  )-&gt;add_req( control() );</span>
<span class="line-added">+   exit_return-&gt;in( TypeFunc::I_O      )-&gt;add_req( i_o    () );</span>
<span class="line-added">+   Node *mem = exit_return-&gt;in( TypeFunc::Memory   );</span>
<span class="line-added">+   for (MergeMemStream mms(mem-&gt;as_MergeMem(), merged_memory()); mms.next_non_empty2(); ) {</span>
<span class="line-added">+     if (mms.is_empty()) {</span>
<span class="line-added">+       // get a copy of the base memory, and patch just this one input</span>
<span class="line-added">+       const TypePtr* adr_type = mms.adr_type(C);</span>
<span class="line-added">+       Node* phi = mms.force_memory()-&gt;as_Phi()-&gt;slice_memory(adr_type);</span>
<span class="line-added">+       assert(phi-&gt;as_Phi()-&gt;region() == mms.base_memory()-&gt;in(0), &quot;&quot;);</span>
<span class="line-added">+       gvn().set_type_bottom(phi);</span>
<span class="line-added">+       phi-&gt;del_req(phi-&gt;req()-1);  // prepare to re-patch</span>
<span class="line-added">+       mms.set_memory(phi);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     mms.memory()-&gt;add_req(mms.memory2());</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    if (_first_return) {
      _exits.map()-&gt;transfer_replaced_nodes_from(map(), _new_idx);
      _first_return = false;
    } else {
      _exits.map()-&gt;merge_replaced_nodes_with(map());
</pre>
<center><a href="library_call.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../prims/jvm.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
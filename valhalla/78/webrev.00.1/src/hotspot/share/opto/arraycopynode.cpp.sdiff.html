<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/arraycopynode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../oops/klass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="arraycopynode.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/arraycopynode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/barrierSet.hpp&quot;
 27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
 28 #include &quot;gc/shared/c2/cardTableBarrierSetC2.hpp&quot;
 29 #include &quot;opto/arraycopynode.hpp&quot;
 30 #include &quot;opto/graphKit.hpp&quot;

 31 #include &quot;runtime/sharedRuntime.hpp&quot;
 32 #include &quot;utilities/macros.hpp&quot;
 33 #include &quot;utilities/powerOfTwo.hpp&quot;
 34 
 35 ArrayCopyNode::ArrayCopyNode(Compile* C, bool alloc_tightly_coupled, bool has_negative_length_guard)
 36   : CallNode(arraycopy_type(), NULL, TypePtr::BOTTOM),
 37     _kind(None),
 38     _alloc_tightly_coupled(alloc_tightly_coupled),
 39     _has_negative_length_guard(has_negative_length_guard),
 40     _arguments_validated(false),
 41     _src_type(TypeOopPtr::BOTTOM),
 42     _dest_type(TypeOopPtr::BOTTOM) {
 43   init_class_id(Class_ArrayCopy);
 44   init_flags(Flag_is_macro);
 45   C-&gt;add_macro_node(this);
 46 }
 47 
 48 uint ArrayCopyNode::size_of() const { return sizeof(*this); }
 49 
 50 ArrayCopyNode* ArrayCopyNode::make(GraphKit* kit, bool may_throw,
</pre>
<hr />
<pre>
 96 void ArrayCopyNode::dump_compact_spec(outputStream* st) const {
 97   st-&gt;print(&quot;%s%s&quot;, _kind_names[_kind], _alloc_tightly_coupled ? &quot;,tight&quot; : &quot;&quot;);
 98 }
 99 #endif
100 
101 intptr_t ArrayCopyNode::get_length_if_constant(PhaseGVN *phase) const {
102   // check that length is constant
103   Node* length = in(ArrayCopyNode::Length);
104   const Type* length_type = phase-&gt;type(length);
105 
106   if (length_type == Type::TOP) {
107     return -1;
108   }
109 
110   assert(is_clonebasic() || is_arraycopy() || is_copyof() || is_copyofrange(), &quot;unexpected array copy type&quot;);
111 
112   return is_clonebasic() ? length-&gt;find_intptr_t_con(-1) : length-&gt;find_int_con(-1);
113 }
114 
115 int ArrayCopyNode::get_count(PhaseGVN *phase) const {
<span class="line-modified">116   Node* src = in(ArrayCopyNode::Src);</span>
<span class="line-modified">117   const Type* src_type = phase-&gt;type(src);</span>
<span class="line-modified">118 </span>




119   if (is_clonebasic()) {
120     if (src_type-&gt;isa_instptr()) {
121       const TypeInstPtr* inst_src = src_type-&gt;is_instptr();
122       ciInstanceKlass* ik = inst_src-&gt;klass()-&gt;as_instance_klass();
123       // ciInstanceKlass::nof_nonstatic_fields() doesn&#39;t take injected
124       // fields into account. They are rare anyway so easier to simply
125       // skip instances with injected fields.
126       if ((!inst_src-&gt;klass_is_exact() &amp;&amp; (ik-&gt;is_interface() || ik-&gt;has_subklass())) || ik-&gt;has_injected_fields()) {
127         return -1;
128       }
129       int nb_fields = ik-&gt;nof_nonstatic_fields();
130       return nb_fields;
131     } else {
132       const TypeAryPtr* ary_src = src_type-&gt;isa_aryptr();
133       assert (ary_src != NULL, &quot;not an array or instance?&quot;);
134       // clone passes a length as a rounded number of longs. If we&#39;re
135       // cloning an array we&#39;ll do it element by element. If the
136       // length input to ArrayCopyNode is constant, length of input
137       // array must be too.
138 
139       assert((get_length_if_constant(phase) == -1) == !ary_src-&gt;size()-&gt;is_con() ||
<span class="line-modified">140              phase-&gt;is_IterGVN() || StressReflectiveCode, &quot;inconsistent&quot;);</span>
<span class="line-modified">141 </span>
142       if (ary_src-&gt;size()-&gt;is_con()) {
143         return ary_src-&gt;size()-&gt;get_con();
144       }
145       return -1;
146     }
147   }
148 
149   return get_length_if_constant(phase);
150 }
151 
152 Node* ArrayCopyNode::load(BarrierSetC2* bs, PhaseGVN *phase, Node*&amp; ctl, MergeMemNode* mem, Node* adr, const TypePtr* adr_type, const Type *type, BasicType bt) {
153   DecoratorSet decorators = C2_READ_ACCESS | C2_CONTROL_DEPENDENT_LOAD | IN_HEAP | C2_ARRAY_COPY;
154   C2AccessValuePtr addr(adr, adr_type);
155   C2OptAccess access(*phase, ctl, mem, decorators, bt, adr-&gt;in(AddPNode::Base), addr);
156   Node* res = bs-&gt;load_at(access, type);
157   ctl = access.ctl();
158   return res;
159 }
160 
161 void ArrayCopyNode::store(BarrierSetC2* bs, PhaseGVN *phase, Node*&amp; ctl, MergeMemNode* mem, Node* adr, const TypePtr* adr_type, Node* val, const Type *type, BasicType bt) {
</pre>
<hr />
<pre>
247   const TypeAryPtr* ary_src = src_type-&gt;isa_aryptr();
248 
249   Node* src_offset = in(ArrayCopyNode::SrcPos);
250   Node* dest_offset = in(ArrayCopyNode::DestPos);
251 
252   if (is_arraycopy() || is_copyofrange() || is_copyof()) {
253     const Type* dest_type = phase-&gt;type(base_dest);
254     const TypeAryPtr* ary_dest = dest_type-&gt;isa_aryptr();
255 
256     // newly allocated object is guaranteed to not overlap with source object
257     disjoint_bases = is_alloc_tightly_coupled();
258 
259     if (ary_src  == NULL || ary_src-&gt;klass()  == NULL ||
260         ary_dest == NULL || ary_dest-&gt;klass() == NULL) {
261       // We don&#39;t know if arguments are arrays
262       return false;
263     }
264 
265     BasicType src_elem  = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
266     BasicType dest_elem = ary_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
<span class="line-modified">267     if (is_reference_type(src_elem))   src_elem  = T_OBJECT;</span>
<span class="line-modified">268     if (is_reference_type(dest_elem))  dest_elem = T_OBJECT;</span>






269 
270     if (src_elem != dest_elem || dest_elem == T_VOID) {
271       // We don&#39;t know if arguments are arrays of the same type
272       return false;
273     }
274 
275     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
<span class="line-modified">276     if (bs-&gt;array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), dest_elem, false, BarrierSetC2::Optimization)) {</span>
<span class="line-modified">277       // It&#39;s an object array copy but we can&#39;t emit the card marking</span>
<span class="line-modified">278       // that is needed</span>

279       return false;
280     }
281 
282     value_type = ary_src-&gt;elem();
283 
284     uint shift  = exact_log2(type2aelembytes(dest_elem));




285     uint header = arrayOopDesc::base_offset_in_bytes(dest_elem);
286 
287     src_offset = Compile::conv_I2X_index(phase, src_offset, ary_src-&gt;size());
288     dest_offset = Compile::conv_I2X_index(phase, dest_offset, ary_dest-&gt;size());
289     if (src_offset-&gt;is_top() || dest_offset-&gt;is_top()) {
290       // Offset is out of bounds (the ArrayCopyNode will be removed)
291       return false;
292     }
293 
294     Node* src_scale  = phase-&gt;transform(new LShiftXNode(src_offset, phase-&gt;intcon(shift)));
295     Node* dest_scale = phase-&gt;transform(new LShiftXNode(dest_offset, phase-&gt;intcon(shift)));
296 
297     adr_src          = phase-&gt;transform(new AddPNode(base_src, base_src, src_scale));
298     adr_dest         = phase-&gt;transform(new AddPNode(base_dest, base_dest, dest_scale));
299 
300     adr_src          = phase-&gt;transform(new AddPNode(base_src, adr_src, phase-&gt;MakeConX(header)));
301     adr_dest         = phase-&gt;transform(new AddPNode(base_dest, adr_dest, phase-&gt;MakeConX(header)));
302 
303     copy_type = dest_elem;
304   } else {
305     assert(ary_src != NULL, &quot;should be a clone&quot;);
306     assert(is_clonebasic(), &quot;should be&quot;);
307 
308     disjoint_bases = true;
309 





310     adr_src  = phase-&gt;transform(new AddPNode(base_src, base_src, src_offset));
311     adr_dest = phase-&gt;transform(new AddPNode(base_dest, base_dest, dest_offset));
312 
313     BasicType elem = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
<span class="line-modified">314     if (is_reference_type(elem)) {</span>

315       elem = T_OBJECT;
316     }
317 
318     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
<span class="line-modified">319     if (bs-&gt;array_copy_requires_gc_barriers(true, elem, true, BarrierSetC2::Optimization)) {</span>


320       return false;
321     }
322 
323     // The address is offseted to an aligned address where a raw copy would start.
324     // If the clone copy is decomposed into load-stores - the address is adjusted to
325     // point at where the array starts.
326     const Type* toff = phase-&gt;type(src_offset);
327     int offset = toff-&gt;isa_long() ? (int) toff-&gt;is_long()-&gt;get_con() : (int) toff-&gt;is_int()-&gt;get_con();
328     int diff = arrayOopDesc::base_offset_in_bytes(elem) - offset;
329     assert(diff &gt;= 0, &quot;clone should not start after 1st array element&quot;);
330     if (diff &gt; 0) {
331       adr_src = phase-&gt;transform(new AddPNode(base_src, adr_src, phase-&gt;MakeConX(diff)));
332       adr_dest = phase-&gt;transform(new AddPNode(base_dest, adr_dest, phase-&gt;MakeConX(diff)));
333     }
334     copy_type = elem;
335     value_type = ary_src-&gt;elem();
336   }
337   return true;
338 }
339 
<span class="line-modified">340 const TypePtr* ArrayCopyNode::get_address_type(PhaseGVN* phase, const TypePtr* atp, Node* n) {</span>
341   if (atp == TypeOopPtr::BOTTOM) {
342     atp = phase-&gt;type(n)-&gt;isa_ptr();
343   }
344   // adjust atp to be the correct array element address type
<span class="line-modified">345   return atp-&gt;add_offset(Type::OffsetBot);</span>
346 }
347 
<span class="line-modified">348 void ArrayCopyNode::array_copy_test_overlap(PhaseGVN *phase, bool can_reshape, bool disjoint_bases, int count, Node*&amp; forward_ctl, Node*&amp; backward_ctl) {</span>
<span class="line-modified">349   Node* ctl = in(TypeFunc::Control);</span>
350   if (!disjoint_bases &amp;&amp; count &gt; 1) {

351     Node* src_offset = in(ArrayCopyNode::SrcPos);
352     Node* dest_offset = in(ArrayCopyNode::DestPos);
353     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;should be&quot;);
<span class="line-modified">354     Node* cmp = phase-&gt;transform(new CmpINode(src_offset, dest_offset));</span>
<span class="line-modified">355     Node *bol = phase-&gt;transform(new BoolNode(cmp, BoolTest::lt));</span>
356     IfNode *iff = new IfNode(ctl, bol, PROB_FAIR, COUNT_UNKNOWN);
357 
<span class="line-modified">358     phase-&gt;transform(iff);</span>





359 
<span class="line-modified">360     forward_ctl = phase-&gt;transform(new IfFalseNode(iff));</span>
<span class="line-modified">361     backward_ctl = phase-&gt;transform(new IfTrueNode(iff));</span>































362   } else {
<span class="line-modified">363     forward_ctl = ctl;</span>




364   }

365 }
366 
<span class="line-modified">367 Node* ArrayCopyNode::array_copy_forward(PhaseGVN *phase,</span>
<span class="line-modified">368                                         bool can_reshape,</span>
<span class="line-modified">369                                         Node*&amp; forward_ctl,</span>
<span class="line-modified">370                                         MergeMemNode* mm,</span>
<span class="line-modified">371                                         const TypePtr* atp_src,</span>
<span class="line-modified">372                                         const TypePtr* atp_dest,</span>
<span class="line-modified">373                                         Node* adr_src,</span>
<span class="line-modified">374                                         Node* base_src,</span>
<span class="line-modified">375                                         Node* adr_dest,</span>
<span class="line-modified">376                                         Node* base_dest,</span>
<span class="line-modified">377                                         BasicType copy_type,</span>
<span class="line-modified">378                                         const Type* value_type,</span>
<span class="line-modified">379                                         int count) {</span>
<span class="line-removed">380   if (!forward_ctl-&gt;is_top()) {</span>
<span class="line-removed">381     // copy forward</span>
<span class="line-removed">382     mm = mm-&gt;clone()-&gt;as_MergeMem();</span>
383 
384     if (count &gt; 0) {
<span class="line-modified">385       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-modified">386       Node* v = load(bs, phase, forward_ctl, mm, adr_src, atp_src, value_type, copy_type);</span>
<span class="line-removed">387       store(bs, phase, forward_ctl, mm, adr_dest, atp_dest, v, value_type, copy_type);</span>
<span class="line-removed">388       for (int i = 1; i &lt; count; i++) {</span>
<span class="line-removed">389         Node* off  = phase-&gt;MakeConX(type2aelembytes(copy_type) * i);</span>
<span class="line-removed">390         Node* next_src = phase-&gt;transform(new AddPNode(base_src,adr_src,off));</span>
<span class="line-removed">391         Node* next_dest = phase-&gt;transform(new AddPNode(base_dest,adr_dest,off));</span>
<span class="line-removed">392         v = load(bs, phase, forward_ctl, mm, next_src, atp_src, value_type, copy_type);</span>
<span class="line-removed">393         store(bs, phase, forward_ctl, mm, next_dest, atp_dest, v, value_type, copy_type);</span>
394       }
395     } else if(can_reshape) {
<span class="line-modified">396       PhaseIterGVN* igvn = phase-&gt;is_IterGVN();</span>
<span class="line-modified">397       igvn-&gt;_worklist.push(adr_src);</span>
<span class="line-modified">398       igvn-&gt;_worklist.push(adr_dest);</span>

399     }
<span class="line-removed">400     return mm;</span>
<span class="line-removed">401   }</span>
402   return phase-&gt;C-&gt;top();
403 }
404 
<span class="line-modified">405 Node* ArrayCopyNode::array_copy_backward(PhaseGVN *phase,</span>
<span class="line-modified">406                                          bool can_reshape,</span>
<span class="line-modified">407                                          Node*&amp; backward_ctl,</span>
<span class="line-modified">408                                          MergeMemNode* mm,</span>
<span class="line-modified">409                                          const TypePtr* atp_src,</span>
<span class="line-modified">410                                          const TypePtr* atp_dest,</span>
<span class="line-modified">411                                          Node* adr_src,</span>
<span class="line-modified">412                                          Node* base_src,</span>
<span class="line-modified">413                                          Node* adr_dest,</span>
<span class="line-modified">414                                          Node* base_dest,</span>
<span class="line-modified">415                                          BasicType copy_type,</span>
<span class="line-modified">416                                          const Type* value_type,</span>
<span class="line-removed">417                                          int count) {</span>
<span class="line-removed">418   if (!backward_ctl-&gt;is_top()) {</span>
419     // copy backward
<span class="line-modified">420     mm = mm-&gt;clone()-&gt;as_MergeMem();</span>
<span class="line-removed">421 </span>
<span class="line-removed">422     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-removed">423     assert(copy_type != T_OBJECT || !bs-&gt;array_copy_requires_gc_barriers(false, T_OBJECT, false, BarrierSetC2::Optimization), &quot;only tightly coupled allocations for object arrays&quot;);</span>
424 
425     if (count &gt; 0) {
<span class="line-modified">426       for (int i = count-1; i &gt;= 1; i--) {</span>
<span class="line-modified">427         Node* off  = phase-&gt;MakeConX(type2aelembytes(copy_type) * i);</span>
<span class="line-removed">428         Node* next_src = phase-&gt;transform(new AddPNode(base_src,adr_src,off));</span>
<span class="line-removed">429         Node* next_dest = phase-&gt;transform(new AddPNode(base_dest,adr_dest,off));</span>
<span class="line-removed">430         Node* v = load(bs, phase, backward_ctl, mm, next_src, atp_src, value_type, copy_type);</span>
<span class="line-removed">431         store(bs, phase, backward_ctl, mm, next_dest, atp_dest, v, value_type, copy_type);</span>
432       }
<span class="line-modified">433       Node* v = load(bs, phase, backward_ctl, mm, adr_src, atp_src, value_type, copy_type);</span>
<span class="line-modified">434       store(bs, phase, backward_ctl, mm, adr_dest, atp_dest, v, value_type, copy_type);</span>
<span class="line-modified">435     } else if(can_reshape) {</span>
<span class="line-modified">436       PhaseIterGVN* igvn = phase-&gt;is_IterGVN();</span>
<span class="line-removed">437       igvn-&gt;_worklist.push(adr_src);</span>
438       igvn-&gt;_worklist.push(adr_dest);
439     }
<span class="line-removed">440     return phase-&gt;transform(mm);</span>
<span class="line-removed">441   }</span>
442   return phase-&gt;C-&gt;top();
443 }
444 
445 bool ArrayCopyNode::finish_transform(PhaseGVN *phase, bool can_reshape,
446                                      Node* ctl, Node *mem) {
447   if (can_reshape) {
448     PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
449     igvn-&gt;set_delay_transform(false);
450     if (is_clonebasic()) {
451       Node* out_mem = proj_out(TypeFunc::Memory);
452 
453       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
454       if (out_mem-&gt;outcnt() != 1 || !out_mem-&gt;raw_out(0)-&gt;is_MergeMem() ||
455           out_mem-&gt;raw_out(0)-&gt;outcnt() != 1 || !out_mem-&gt;raw_out(0)-&gt;raw_out(0)-&gt;is_MemBar()) {
456         assert(bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Optimization), &quot;can only happen with card marking&quot;);
457         return false;
458       }
459 
460       igvn-&gt;replace_node(out_mem-&gt;raw_out(0), mem);
461 
462       Node* out_ctl = proj_out(TypeFunc::Control);
463       igvn-&gt;replace_node(out_ctl, ctl);
464     } else {
465       // replace fallthrough projections of the ArrayCopyNode by the
466       // new memory, control and the input IO.
<span class="line-modified">467       CallProjections callprojs;</span>
<span class="line-removed">468       extract_projections(&amp;callprojs, true, false);</span>
469 
<span class="line-modified">470       if (callprojs.fallthrough_ioproj != NULL) {</span>
<span class="line-modified">471         igvn-&gt;replace_node(callprojs.fallthrough_ioproj, in(TypeFunc::I_O));</span>
472       }
<span class="line-modified">473       if (callprojs.fallthrough_memproj != NULL) {</span>
<span class="line-modified">474         igvn-&gt;replace_node(callprojs.fallthrough_memproj, mem);</span>
475       }
<span class="line-modified">476       if (callprojs.fallthrough_catchproj != NULL) {</span>
<span class="line-modified">477         igvn-&gt;replace_node(callprojs.fallthrough_catchproj, ctl);</span>
478       }
479 
480       // The ArrayCopyNode is not disconnected. It still has the
481       // projections for the exception case. Replace current
482       // ArrayCopyNode with a dummy new one with a top() control so
483       // that this part of the graph stays consistent but is
484       // eventually removed.
485 
486       set_req(0, phase-&gt;C-&gt;top());
487       remove_dead_region(phase, can_reshape);
488     }
489   } else {
490     if (in(TypeFunc::Control) != ctl) {
491       // we can&#39;t return new memory and control from Ideal at parse time









492       assert(!is_clonebasic() || UseShenandoahGC, &quot;added control for clone?&quot;);
493       phase-&gt;record_for_igvn(this);
494       return false;
495     }
496   }
497   return true;
498 }
499 
500 
501 Node *ArrayCopyNode::Ideal(PhaseGVN *phase, bool can_reshape) {
<span class="line-modified">502   if (remove_dead_region(phase, can_reshape))  return this;</span>




503 
504   if (StressArrayCopyMacroNode &amp;&amp; !can_reshape) {
505     phase-&gt;record_for_igvn(this);
506     return NULL;
507   }
508 
509   // See if it&#39;s a small array copy and we can inline it as
510   // loads/stores
511   // Here we can only do:
512   // - arraycopy if all arguments were validated before and we don&#39;t
513   // need card marking
514   // - clone for which we don&#39;t need to do card marking
515 
516   if (!is_clonebasic() &amp;&amp; !is_arraycopy_validated() &amp;&amp;
517       !is_copyofrange_validated() &amp;&amp; !is_copyof_validated()) {
518     return NULL;
519   }
520 
521   assert(in(TypeFunc::Control) != NULL &amp;&amp;
522          in(TypeFunc::Memory) != NULL &amp;&amp;
</pre>
<hr />
<pre>
524          in(ArrayCopyNode::Dest) != NULL &amp;&amp;
525          in(ArrayCopyNode::Length) != NULL &amp;&amp;
526          in(ArrayCopyNode::SrcPos) != NULL &amp;&amp;
527          in(ArrayCopyNode::DestPos) != NULL, &quot;broken inputs&quot;);
528 
529   if (in(TypeFunc::Control)-&gt;is_top() ||
530       in(TypeFunc::Memory)-&gt;is_top() ||
531       phase-&gt;type(in(ArrayCopyNode::Src)) == Type::TOP ||
532       phase-&gt;type(in(ArrayCopyNode::Dest)) == Type::TOP ||
533       (in(ArrayCopyNode::SrcPos) != NULL &amp;&amp; in(ArrayCopyNode::SrcPos)-&gt;is_top()) ||
534       (in(ArrayCopyNode::DestPos) != NULL &amp;&amp; in(ArrayCopyNode::DestPos)-&gt;is_top())) {
535     return NULL;
536   }
537 
538   int count = get_count(phase);
539 
540   if (count &lt; 0 || count &gt; ArrayCopyLoadStoreMaxElem) {
541     return NULL;
542   }
543 











544   Node* mem = try_clone_instance(phase, can_reshape, count);
545   if (mem != NULL) {
546     return (mem == NodeSentinel) ? NULL : mem;
547   }
548 
549   Node* adr_src = NULL;
550   Node* base_src = NULL;
551   Node* adr_dest = NULL;
552   Node* base_dest = NULL;
553   BasicType copy_type = T_ILLEGAL;
554   const Type* value_type = NULL;
555   bool disjoint_bases = false;
556 
557   if (!prepare_array_copy(phase, can_reshape,
558                           adr_src, base_src, adr_dest, base_dest,
559                           copy_type, value_type, disjoint_bases)) {
560     return NULL;
561   }
562 
<span class="line-modified">563   Node* src = in(ArrayCopyNode::Src);</span>
<span class="line-modified">564   Node* dest = in(ArrayCopyNode::Dest);</span>
<span class="line-modified">565   const TypePtr* atp_src = get_address_type(phase, _src_type, src);</span>
<span class="line-modified">566   const TypePtr* atp_dest = get_address_type(phase, _dest_type, dest);</span>
<span class="line-modified">567 </span>
<span class="line-modified">568   Node *in_mem = in(TypeFunc::Memory);</span>
<span class="line-modified">569   if (!in_mem-&gt;is_MergeMem()) {</span>
<span class="line-modified">570     in_mem = MergeMemNode::make(in_mem);</span>





571   }







572 
573   if (can_reshape) {
574     assert(!phase-&gt;is_IterGVN()-&gt;delay_transform(), &quot;cannot delay transforms&quot;);
575     phase-&gt;is_IterGVN()-&gt;set_delay_transform(true);
576   }
577 




578   Node* backward_ctl = phase-&gt;C-&gt;top();
<span class="line-modified">579   Node* forward_ctl = phase-&gt;C-&gt;top();</span>
<span class="line-modified">580   array_copy_test_overlap(phase, can_reshape, disjoint_bases, count, forward_ctl, backward_ctl);</span>
<span class="line-modified">581 </span>
<span class="line-modified">582   Node* forward_mem = array_copy_forward(phase, can_reshape, forward_ctl,</span>
<span class="line-modified">583                                          in_mem-&gt;as_MergeMem(),</span>
<span class="line-modified">584                                          atp_src, atp_dest,</span>
<span class="line-modified">585                                          adr_src, base_src, adr_dest, base_dest,</span>
<span class="line-modified">586                                          copy_type, value_type, count);</span>
<span class="line-modified">587 </span>
<span class="line-modified">588   Node* backward_mem = array_copy_backward(phase, can_reshape, backward_ctl,</span>
<span class="line-modified">589                                            in_mem-&gt;as_MergeMem(),</span>
<span class="line-modified">590                                            atp_src, atp_dest,</span>
<span class="line-modified">591                                            adr_src, base_src, adr_dest, base_dest,</span>
<span class="line-modified">592                                            copy_type, value_type, count);</span>
<span class="line-modified">593 </span>
<span class="line-modified">594   Node* ctl = NULL;</span>
<span class="line-modified">595   if (!forward_ctl-&gt;is_top() &amp;&amp; !backward_ctl-&gt;is_top()) {</span>
<span class="line-modified">596     ctl = new RegionNode(3);</span>
<span class="line-modified">597     ctl-&gt;init_req(1, forward_ctl);</span>
<span class="line-modified">598     ctl-&gt;init_req(2, backward_ctl);</span>
<span class="line-modified">599     ctl = phase-&gt;transform(ctl);</span>
<span class="line-modified">600     MergeMemNode* forward_mm = forward_mem-&gt;as_MergeMem();</span>
<span class="line-modified">601     MergeMemNode* backward_mm = backward_mem-&gt;as_MergeMem();</span>
<span class="line-modified">602     for (MergeMemStream mms(forward_mm, backward_mm); mms.next_non_empty2(); ) {</span>
<span class="line-modified">603       if (mms.memory() != mms.memory2()) {</span>
<span class="line-modified">604         Node* phi = new PhiNode(ctl, Type::MEMORY, phase-&gt;C-&gt;get_adr_type(mms.alias_idx()));</span>
<span class="line-modified">605         phi-&gt;init_req(1, mms.memory());</span>
<span class="line-modified">606         phi-&gt;init_req(2, mms.memory2());</span>
<span class="line-modified">607         phi = phase-&gt;transform(phi);</span>
<span class="line-modified">608         mms.set_memory(phi);</span>
<span class="line-modified">609       }</span>
<span class="line-modified">610     }</span>
<span class="line-modified">611     mem = forward_mem;</span>
<span class="line-modified">612   } else if (!forward_ctl-&gt;is_top()) {</span>
<span class="line-modified">613     ctl = forward_ctl;</span>
<span class="line-modified">614     mem = forward_mem;</span>
615   } else {
<span class="line-modified">616     assert(!backward_ctl-&gt;is_top(), &quot;no copy?&quot;);</span>
<span class="line-modified">617     ctl = backward_ctl;</span>
<span class="line-removed">618     mem = backward_mem;</span>
619   }
620 
621   if (can_reshape) {
622     assert(phase-&gt;is_IterGVN()-&gt;delay_transform(), &quot;should be delaying transforms&quot;);
623     phase-&gt;is_IterGVN()-&gt;set_delay_transform(false);
624   }
625 
<span class="line-modified">626   if (!finish_transform(phase, can_reshape, ctl, mem)) {</span>




627     return NULL;
628   }
629 
630   return mem;
631 }
632 
633 bool ArrayCopyNode::may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase) {
634   Node* dest = in(ArrayCopyNode::Dest);
635   if (dest-&gt;is_top()) {
636     return false;
637   }
638   const TypeOopPtr* dest_t = phase-&gt;type(dest)-&gt;is_oopptr();
639   assert(!dest_t-&gt;is_known_instance() || _dest_type-&gt;is_known_instance(), &quot;result of EA not recorded&quot;);
640   assert(in(ArrayCopyNode::Src)-&gt;is_top() || !phase-&gt;type(in(ArrayCopyNode::Src))-&gt;is_oopptr()-&gt;is_known_instance() ||
641          _src_type-&gt;is_known_instance(), &quot;result of EA not recorded&quot;);
642 
643   if (_dest_type != TypeOopPtr::BOTTOM || t_oop-&gt;is_known_instance()) {
644     assert(_dest_type == TypeOopPtr::BOTTOM || _dest_type-&gt;is_known_instance(), &quot;result of EA is known instance&quot;);
645     return t_oop-&gt;instance_id() == _dest_type-&gt;instance_id();
646   }
</pre>
<hr />
<pre>
697 // in the destination array
698 // if must_modify is false, return true if the copy could write
699 // between offset_lo and offset_hi
700 // if must_modify is true, return true if the copy is guaranteed to
701 // write between offset_lo and offset_hi
702 bool ArrayCopyNode::modifies(intptr_t offset_lo, intptr_t offset_hi, PhaseTransform* phase, bool must_modify) const {
703   assert(_kind == ArrayCopy || _kind == CopyOf || _kind == CopyOfRange, &quot;only for real array copies&quot;);
704 
705   Node* dest = in(Dest);
706   Node* dest_pos = in(DestPos);
707   Node* len = in(Length);
708 
709   const TypeInt *dest_pos_t = phase-&gt;type(dest_pos)-&gt;isa_int();
710   const TypeInt *len_t = phase-&gt;type(len)-&gt;isa_int();
711   const TypeAryPtr* ary_t = phase-&gt;type(dest)-&gt;isa_aryptr();
712 
713   if (dest_pos_t == NULL || len_t == NULL || ary_t == NULL) {
714     return !must_modify;
715   }
716 
<span class="line-modified">717   BasicType ary_elem = ary_t-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();</span>

718   uint header = arrayOopDesc::base_offset_in_bytes(ary_elem);
719   uint elemsize = type2aelembytes(ary_elem);



720 
721   jlong dest_pos_plus_len_lo = (((jlong)dest_pos_t-&gt;_lo) + len_t-&gt;_lo) * elemsize + header;
722   jlong dest_pos_plus_len_hi = (((jlong)dest_pos_t-&gt;_hi) + len_t-&gt;_hi) * elemsize + header;
723   jlong dest_pos_lo = ((jlong)dest_pos_t-&gt;_lo) * elemsize + header;
724   jlong dest_pos_hi = ((jlong)dest_pos_t-&gt;_hi) * elemsize + header;
725 
726   if (must_modify) {
727     if (offset_lo &gt;= dest_pos_hi &amp;&amp; offset_hi &lt; dest_pos_plus_len_lo) {
728       return true;
729     }
730   } else {
731     if (offset_hi &gt;= dest_pos_lo &amp;&amp; offset_lo &lt; dest_pos_plus_len_hi) {
732       return true;
733     }
734   }
735   return false;
736 }
</pre>
</td>
<td>
<hr />
<pre>
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shared/barrierSet.hpp&quot;
 27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
 28 #include &quot;gc/shared/c2/cardTableBarrierSetC2.hpp&quot;
 29 #include &quot;opto/arraycopynode.hpp&quot;
 30 #include &quot;opto/graphKit.hpp&quot;
<span class="line-added"> 31 #include &quot;opto/valuetypenode.hpp&quot;</span>
 32 #include &quot;runtime/sharedRuntime.hpp&quot;
 33 #include &quot;utilities/macros.hpp&quot;
 34 #include &quot;utilities/powerOfTwo.hpp&quot;
 35 
 36 ArrayCopyNode::ArrayCopyNode(Compile* C, bool alloc_tightly_coupled, bool has_negative_length_guard)
 37   : CallNode(arraycopy_type(), NULL, TypePtr::BOTTOM),
 38     _kind(None),
 39     _alloc_tightly_coupled(alloc_tightly_coupled),
 40     _has_negative_length_guard(has_negative_length_guard),
 41     _arguments_validated(false),
 42     _src_type(TypeOopPtr::BOTTOM),
 43     _dest_type(TypeOopPtr::BOTTOM) {
 44   init_class_id(Class_ArrayCopy);
 45   init_flags(Flag_is_macro);
 46   C-&gt;add_macro_node(this);
 47 }
 48 
 49 uint ArrayCopyNode::size_of() const { return sizeof(*this); }
 50 
 51 ArrayCopyNode* ArrayCopyNode::make(GraphKit* kit, bool may_throw,
</pre>
<hr />
<pre>
 97 void ArrayCopyNode::dump_compact_spec(outputStream* st) const {
 98   st-&gt;print(&quot;%s%s&quot;, _kind_names[_kind], _alloc_tightly_coupled ? &quot;,tight&quot; : &quot;&quot;);
 99 }
100 #endif
101 
102 intptr_t ArrayCopyNode::get_length_if_constant(PhaseGVN *phase) const {
103   // check that length is constant
104   Node* length = in(ArrayCopyNode::Length);
105   const Type* length_type = phase-&gt;type(length);
106 
107   if (length_type == Type::TOP) {
108     return -1;
109   }
110 
111   assert(is_clonebasic() || is_arraycopy() || is_copyof() || is_copyofrange(), &quot;unexpected array copy type&quot;);
112 
113   return is_clonebasic() ? length-&gt;find_intptr_t_con(-1) : length-&gt;find_int_con(-1);
114 }
115 
116 int ArrayCopyNode::get_count(PhaseGVN *phase) const {
<span class="line-modified">117   if (is_clonebasic()) {</span>
<span class="line-modified">118     Node* src = in(ArrayCopyNode::Src);</span>
<span class="line-modified">119     const Type* src_type = phase-&gt;type(src);</span>
<span class="line-added">120 </span>
<span class="line-added">121     if (src_type == Type::TOP) {</span>
<span class="line-added">122       return -1;</span>
<span class="line-added">123     }</span>
124 
125     if (src_type-&gt;isa_instptr()) {
126       const TypeInstPtr* inst_src = src_type-&gt;is_instptr();
127       ciInstanceKlass* ik = inst_src-&gt;klass()-&gt;as_instance_klass();
128       // ciInstanceKlass::nof_nonstatic_fields() doesn&#39;t take injected
129       // fields into account. They are rare anyway so easier to simply
130       // skip instances with injected fields.
131       if ((!inst_src-&gt;klass_is_exact() &amp;&amp; (ik-&gt;is_interface() || ik-&gt;has_subklass())) || ik-&gt;has_injected_fields()) {
132         return -1;
133       }
134       int nb_fields = ik-&gt;nof_nonstatic_fields();
135       return nb_fields;
136     } else {
137       const TypeAryPtr* ary_src = src_type-&gt;isa_aryptr();
138       assert (ary_src != NULL, &quot;not an array or instance?&quot;);
139       // clone passes a length as a rounded number of longs. If we&#39;re
140       // cloning an array we&#39;ll do it element by element. If the
141       // length input to ArrayCopyNode is constant, length of input
142       // array must be too.
143 
144       assert((get_length_if_constant(phase) == -1) == !ary_src-&gt;size()-&gt;is_con() ||
<span class="line-modified">145              (ValueArrayFlatten &amp;&amp; ary_src-&gt;elem()-&gt;make_oopptr() != NULL &amp;&amp; ary_src-&gt;elem()-&gt;make_oopptr()-&gt;can_be_value_type()) ||</span>
<span class="line-modified">146              phase-&gt;is_IterGVN() || phase-&gt;C-&gt;inlining_incrementally() || StressReflectiveCode, &quot;inconsistent&quot;);</span>
147       if (ary_src-&gt;size()-&gt;is_con()) {
148         return ary_src-&gt;size()-&gt;get_con();
149       }
150       return -1;
151     }
152   }
153 
154   return get_length_if_constant(phase);
155 }
156 
157 Node* ArrayCopyNode::load(BarrierSetC2* bs, PhaseGVN *phase, Node*&amp; ctl, MergeMemNode* mem, Node* adr, const TypePtr* adr_type, const Type *type, BasicType bt) {
158   DecoratorSet decorators = C2_READ_ACCESS | C2_CONTROL_DEPENDENT_LOAD | IN_HEAP | C2_ARRAY_COPY;
159   C2AccessValuePtr addr(adr, adr_type);
160   C2OptAccess access(*phase, ctl, mem, decorators, bt, adr-&gt;in(AddPNode::Base), addr);
161   Node* res = bs-&gt;load_at(access, type);
162   ctl = access.ctl();
163   return res;
164 }
165 
166 void ArrayCopyNode::store(BarrierSetC2* bs, PhaseGVN *phase, Node*&amp; ctl, MergeMemNode* mem, Node* adr, const TypePtr* adr_type, Node* val, const Type *type, BasicType bt) {
</pre>
<hr />
<pre>
252   const TypeAryPtr* ary_src = src_type-&gt;isa_aryptr();
253 
254   Node* src_offset = in(ArrayCopyNode::SrcPos);
255   Node* dest_offset = in(ArrayCopyNode::DestPos);
256 
257   if (is_arraycopy() || is_copyofrange() || is_copyof()) {
258     const Type* dest_type = phase-&gt;type(base_dest);
259     const TypeAryPtr* ary_dest = dest_type-&gt;isa_aryptr();
260 
261     // newly allocated object is guaranteed to not overlap with source object
262     disjoint_bases = is_alloc_tightly_coupled();
263 
264     if (ary_src  == NULL || ary_src-&gt;klass()  == NULL ||
265         ary_dest == NULL || ary_dest-&gt;klass() == NULL) {
266       // We don&#39;t know if arguments are arrays
267       return false;
268     }
269 
270     BasicType src_elem  = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
271     BasicType dest_elem = ary_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
<span class="line-modified">272     if (src_elem  == T_ARRAY ||</span>
<span class="line-modified">273         (src_elem == T_VALUETYPE &amp;&amp; ary_src-&gt;klass()-&gt;is_obj_array_klass())) {</span>
<span class="line-added">274       src_elem  = T_OBJECT;</span>
<span class="line-added">275     }</span>
<span class="line-added">276     if (dest_elem == T_ARRAY ||</span>
<span class="line-added">277         (dest_elem == T_VALUETYPE &amp;&amp; ary_dest-&gt;klass()-&gt;is_obj_array_klass())) {</span>
<span class="line-added">278       dest_elem = T_OBJECT;</span>
<span class="line-added">279     }</span>
280 
281     if (src_elem != dest_elem || dest_elem == T_VOID) {
282       // We don&#39;t know if arguments are arrays of the same type
283       return false;
284     }
285 
286     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
<span class="line-modified">287     if (bs-&gt;array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), dest_elem, false, BarrierSetC2::Optimization) ||</span>
<span class="line-modified">288         (src_elem == T_VALUETYPE &amp;&amp; ary_src-&gt;elem()-&gt;value_klass()-&gt;contains_oops() &amp;&amp;</span>
<span class="line-modified">289          bs-&gt;array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), T_OBJECT, false, BarrierSetC2::Optimization))) {</span>
<span class="line-added">290       // It&#39;s an object array copy but we can&#39;t emit the card marking that is needed</span>
291       return false;
292     }
293 
294     value_type = ary_src-&gt;elem();
295 
296     uint shift  = exact_log2(type2aelembytes(dest_elem));
<span class="line-added">297     if (dest_elem == T_VALUETYPE) {</span>
<span class="line-added">298       ciValueArrayKlass* vak = ary_src-&gt;klass()-&gt;as_value_array_klass();</span>
<span class="line-added">299       shift = vak-&gt;log2_element_size();</span>
<span class="line-added">300     }</span>
301     uint header = arrayOopDesc::base_offset_in_bytes(dest_elem);
302 
303     src_offset = Compile::conv_I2X_index(phase, src_offset, ary_src-&gt;size());
304     dest_offset = Compile::conv_I2X_index(phase, dest_offset, ary_dest-&gt;size());
305     if (src_offset-&gt;is_top() || dest_offset-&gt;is_top()) {
306       // Offset is out of bounds (the ArrayCopyNode will be removed)
307       return false;
308     }
309 
310     Node* src_scale  = phase-&gt;transform(new LShiftXNode(src_offset, phase-&gt;intcon(shift)));
311     Node* dest_scale = phase-&gt;transform(new LShiftXNode(dest_offset, phase-&gt;intcon(shift)));
312 
313     adr_src          = phase-&gt;transform(new AddPNode(base_src, base_src, src_scale));
314     adr_dest         = phase-&gt;transform(new AddPNode(base_dest, base_dest, dest_scale));
315 
316     adr_src          = phase-&gt;transform(new AddPNode(base_src, adr_src, phase-&gt;MakeConX(header)));
317     adr_dest         = phase-&gt;transform(new AddPNode(base_dest, adr_dest, phase-&gt;MakeConX(header)));
318 
319     copy_type = dest_elem;
320   } else {
321     assert(ary_src != NULL, &quot;should be a clone&quot;);
322     assert(is_clonebasic(), &quot;should be&quot;);
323 
324     disjoint_bases = true;
325 
<span class="line-added">326     if (ary_src-&gt;elem()-&gt;make_oopptr() != NULL &amp;&amp;</span>
<span class="line-added">327         ary_src-&gt;elem()-&gt;make_oopptr()-&gt;can_be_value_type()) {</span>
<span class="line-added">328       return false;</span>
<span class="line-added">329     }</span>
<span class="line-added">330 </span>
331     adr_src  = phase-&gt;transform(new AddPNode(base_src, base_src, src_offset));
332     adr_dest = phase-&gt;transform(new AddPNode(base_dest, base_dest, dest_offset));
333 
334     BasicType elem = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
<span class="line-modified">335     if (elem == T_ARRAY ||</span>
<span class="line-added">336         (elem == T_VALUETYPE &amp;&amp; ary_src-&gt;klass()-&gt;is_obj_array_klass())) {</span>
337       elem = T_OBJECT;
338     }
339 
340     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
<span class="line-modified">341     if (bs-&gt;array_copy_requires_gc_barriers(true, elem, true, BarrierSetC2::Optimization) ||</span>
<span class="line-added">342         (elem == T_VALUETYPE &amp;&amp; ary_src-&gt;elem()-&gt;value_klass()-&gt;contains_oops() &amp;&amp;</span>
<span class="line-added">343          bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Optimization))) {</span>
344       return false;
345     }
346 
347     // The address is offseted to an aligned address where a raw copy would start.
348     // If the clone copy is decomposed into load-stores - the address is adjusted to
349     // point at where the array starts.
350     const Type* toff = phase-&gt;type(src_offset);
351     int offset = toff-&gt;isa_long() ? (int) toff-&gt;is_long()-&gt;get_con() : (int) toff-&gt;is_int()-&gt;get_con();
352     int diff = arrayOopDesc::base_offset_in_bytes(elem) - offset;
353     assert(diff &gt;= 0, &quot;clone should not start after 1st array element&quot;);
354     if (diff &gt; 0) {
355       adr_src = phase-&gt;transform(new AddPNode(base_src, adr_src, phase-&gt;MakeConX(diff)));
356       adr_dest = phase-&gt;transform(new AddPNode(base_dest, adr_dest, phase-&gt;MakeConX(diff)));
357     }
358     copy_type = elem;
359     value_type = ary_src-&gt;elem();
360   }
361   return true;
362 }
363 
<span class="line-modified">364 const TypeAryPtr* ArrayCopyNode::get_address_type(PhaseGVN* phase, const TypePtr* atp, Node* n) {</span>
365   if (atp == TypeOopPtr::BOTTOM) {
366     atp = phase-&gt;type(n)-&gt;isa_ptr();
367   }
368   // adjust atp to be the correct array element address type
<span class="line-modified">369   return atp-&gt;add_offset(Type::OffsetBot)-&gt;is_aryptr();</span>
370 }
371 
<span class="line-modified">372 void ArrayCopyNode::array_copy_test_overlap(GraphKit&amp; kit, bool disjoint_bases, int count, Node*&amp; backward_ctl) {</span>
<span class="line-modified">373   Node* ctl = kit.control();</span>
374   if (!disjoint_bases &amp;&amp; count &gt; 1) {
<span class="line-added">375     PhaseGVN&amp; gvn = kit.gvn();</span>
376     Node* src_offset = in(ArrayCopyNode::SrcPos);
377     Node* dest_offset = in(ArrayCopyNode::DestPos);
378     assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;should be&quot;);
<span class="line-modified">379     Node* cmp = gvn.transform(new CmpINode(src_offset, dest_offset));</span>
<span class="line-modified">380     Node *bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));</span>
381     IfNode *iff = new IfNode(ctl, bol, PROB_FAIR, COUNT_UNKNOWN);
382 
<span class="line-modified">383     gvn.transform(iff);</span>
<span class="line-added">384 </span>
<span class="line-added">385     kit.set_control(gvn.transform(new IfFalseNode(iff)));</span>
<span class="line-added">386     backward_ctl = gvn.transform(new IfTrueNode(iff));</span>
<span class="line-added">387   }</span>
<span class="line-added">388 }</span>
389 
<span class="line-modified">390 void ArrayCopyNode::copy(GraphKit&amp; kit,</span>
<span class="line-modified">391                          const TypeAryPtr* atp_src,</span>
<span class="line-added">392                          const TypeAryPtr* atp_dest,</span>
<span class="line-added">393                          int i,</span>
<span class="line-added">394                          Node* base_src,</span>
<span class="line-added">395                          Node* base_dest,</span>
<span class="line-added">396                          Node* adr_src,</span>
<span class="line-added">397                          Node* adr_dest,</span>
<span class="line-added">398                          BasicType copy_type,</span>
<span class="line-added">399                          const Type* value_type) {</span>
<span class="line-added">400   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-added">401   Node* ctl = kit.control();</span>
<span class="line-added">402   if (copy_type == T_VALUETYPE) {</span>
<span class="line-added">403     ciValueArrayKlass* vak = atp_src-&gt;klass()-&gt;as_value_array_klass();</span>
<span class="line-added">404     ciValueKlass* vk = vak-&gt;element_klass()-&gt;as_value_klass();</span>
<span class="line-added">405     for (int j = 0; j &lt; vk-&gt;nof_nonstatic_fields(); j++) {</span>
<span class="line-added">406       ciField* field = vk-&gt;nonstatic_field_at(j);</span>
<span class="line-added">407       int off_in_vt = field-&gt;offset() - vk-&gt;first_field_offset();</span>
<span class="line-added">408       Node* off  = kit.MakeConX(off_in_vt + i * vak-&gt;element_byte_size());</span>
<span class="line-added">409       ciType* ft = field-&gt;type();</span>
<span class="line-added">410       BasicType bt = type2field[ft-&gt;basic_type()];</span>
<span class="line-added">411       assert(!field-&gt;is_flattened(), &quot;flattened field encountered&quot;);</span>
<span class="line-added">412       if (bt == T_VALUETYPE) {</span>
<span class="line-added">413         bt = T_OBJECT;</span>
<span class="line-added">414       }</span>
<span class="line-added">415       const Type* rt = Type::get_const_type(ft);</span>
<span class="line-added">416       const TypePtr* adr_type = atp_src-&gt;with_field_offset(off_in_vt)-&gt;add_offset(Type::OffsetBot);</span>
<span class="line-added">417       assert(!bs-&gt;array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), bt, false, BarrierSetC2::Optimization), &quot;GC barriers required&quot;);</span>
<span class="line-added">418       Node* next_src = kit.gvn().transform(new AddPNode(base_src, adr_src, off));</span>
<span class="line-added">419       Node* next_dest = kit.gvn().transform(new AddPNode(base_dest, adr_dest, off));</span>
<span class="line-added">420       Node* v = load(bs, &amp;kit.gvn(), ctl, kit.merged_memory(), next_src, adr_type, rt, bt);</span>
<span class="line-added">421       store(bs, &amp;kit.gvn(), ctl, kit.merged_memory(), next_dest, adr_type, v, rt, bt);</span>
<span class="line-added">422     }</span>
423   } else {
<span class="line-modified">424     Node* off = kit.MakeConX(type2aelembytes(copy_type) * i);</span>
<span class="line-added">425     Node* next_src = kit.gvn().transform(new AddPNode(base_src, adr_src, off));</span>
<span class="line-added">426     Node* next_dest = kit.gvn().transform(new AddPNode(base_dest, adr_dest, off));</span>
<span class="line-added">427     Node* v = load(bs, &amp;kit.gvn(), ctl, kit.merged_memory(), next_src, atp_src, value_type, copy_type);</span>
<span class="line-added">428     store(bs, &amp;kit.gvn(), ctl, kit.merged_memory(), next_dest, atp_dest, v, value_type, copy_type);</span>
429   }
<span class="line-added">430   kit.set_control(ctl);</span>
431 }
432 
<span class="line-modified">433 </span>
<span class="line-modified">434 void ArrayCopyNode::array_copy_forward(GraphKit&amp; kit,</span>
<span class="line-modified">435                                        bool can_reshape,</span>
<span class="line-modified">436                                        const TypeAryPtr* atp_src,</span>
<span class="line-modified">437                                        const TypeAryPtr* atp_dest,</span>
<span class="line-modified">438                                        Node* adr_src,</span>
<span class="line-modified">439                                        Node* base_src,</span>
<span class="line-modified">440                                        Node* adr_dest,</span>
<span class="line-modified">441                                        Node* base_dest,</span>
<span class="line-modified">442                                        BasicType copy_type,</span>
<span class="line-modified">443                                        const Type* value_type,</span>
<span class="line-modified">444                                        int count) {</span>
<span class="line-modified">445   if (!kit.stopped()) {</span>



446     // copy forward
447     if (count &gt; 0) {
<span class="line-modified">448       for (int i = 0; i &lt; count; i++) {</span>
<span class="line-modified">449         copy(kit, atp_src, atp_dest, i, base_src, base_dest, adr_src, adr_dest, copy_type, value_type);</span>







450       }
451     } else if(can_reshape) {
<span class="line-modified">452       PhaseGVN&amp; gvn = kit.gvn();</span>
<span class="line-modified">453       assert(gvn.is_IterGVN(), &quot;&quot;);</span>
<span class="line-modified">454       gvn.record_for_igvn(adr_src);</span>
<span class="line-added">455       gvn.record_for_igvn(adr_dest);</span>
456     }


457   }
458 }
459 
<span class="line-modified">460 void ArrayCopyNode::array_copy_backward(GraphKit&amp; kit,</span>
<span class="line-modified">461                                         bool can_reshape,</span>
<span class="line-modified">462                                         const TypeAryPtr* atp_src,</span>
<span class="line-modified">463                                         const TypeAryPtr* atp_dest,</span>
<span class="line-modified">464                                         Node* adr_src,</span>
<span class="line-modified">465                                         Node* base_src,</span>
<span class="line-modified">466                                         Node* adr_dest,</span>
<span class="line-modified">467                                         Node* base_dest,</span>
<span class="line-modified">468                                         BasicType copy_type,</span>
<span class="line-modified">469                                         const Type* value_type,</span>
<span class="line-modified">470                                         int count) {</span>
<span class="line-modified">471   if (!kit.stopped()) {</span>


472     // copy backward
<span class="line-modified">473     PhaseGVN&amp; gvn = kit.gvn();</span>



474 
475     if (count &gt; 0) {
<span class="line-modified">476       for (int i = count-1; i &gt;= 0; i--) {</span>
<span class="line-modified">477         copy(kit, atp_src, atp_dest, i, base_src, base_dest, adr_src, adr_dest, copy_type, value_type);</span>




478       }
<span class="line-modified">479     } else if(can_reshape) {</span>
<span class="line-modified">480       PhaseGVN&amp; gvn = kit.gvn();</span>
<span class="line-modified">481       assert(gvn.is_IterGVN(), &quot;&quot;);</span>
<span class="line-modified">482       gvn.record_for_igvn(adr_src);</span>

483       gvn.record_for_igvn(adr_dest);
484     }


485   }
486 }
487 
488 bool ArrayCopyNode::finish_transform(PhaseGVN *phase, bool can_reshape,
489                                      Node* ctl, Node *mem) {
490   if (can_reshape) {
491     PhaseIterGVN* igvn = phase-&gt;is_IterGVN();
492     igvn-&gt;set_delay_transform(false);
493     if (is_clonebasic()) {
494       Node* out_mem = proj_out(TypeFunc::Memory);
495 
496       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
497       if (out_mem-&gt;outcnt() != 1 || !out_mem-&gt;raw_out(0)-&gt;is_MergeMem() ||
498           out_mem-&gt;raw_out(0)-&gt;outcnt() != 1 || !out_mem-&gt;raw_out(0)-&gt;raw_out(0)-&gt;is_MemBar()) {
499         assert(bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Optimization), &quot;can only happen with card marking&quot;);
500         return false;
501       }
502 
503       igvn-&gt;replace_node(out_mem-&gt;raw_out(0), mem);
504 
505       Node* out_ctl = proj_out(TypeFunc::Control);
506       igvn-&gt;replace_node(out_ctl, ctl);
507     } else {
508       // replace fallthrough projections of the ArrayCopyNode by the
509       // new memory, control and the input IO.
<span class="line-modified">510       CallProjections* callprojs = extract_projections(true, false);</span>

511 
<span class="line-modified">512       if (callprojs-&gt;fallthrough_ioproj != NULL) {</span>
<span class="line-modified">513         igvn-&gt;replace_node(callprojs-&gt;fallthrough_ioproj, in(TypeFunc::I_O));</span>
514       }
<span class="line-modified">515       if (callprojs-&gt;fallthrough_memproj != NULL) {</span>
<span class="line-modified">516         igvn-&gt;replace_node(callprojs-&gt;fallthrough_memproj, mem);</span>
517       }
<span class="line-modified">518       if (callprojs-&gt;fallthrough_catchproj != NULL) {</span>
<span class="line-modified">519         igvn-&gt;replace_node(callprojs-&gt;fallthrough_catchproj, ctl);</span>
520       }
521 
522       // The ArrayCopyNode is not disconnected. It still has the
523       // projections for the exception case. Replace current
524       // ArrayCopyNode with a dummy new one with a top() control so
525       // that this part of the graph stays consistent but is
526       // eventually removed.
527 
528       set_req(0, phase-&gt;C-&gt;top());
529       remove_dead_region(phase, can_reshape);
530     }
531   } else {
532     if (in(TypeFunc::Control) != ctl) {
533       // we can&#39;t return new memory and control from Ideal at parse time
<span class="line-added">534 #ifdef ASSERT</span>
<span class="line-added">535       Node* src = in(ArrayCopyNode::Src);</span>
<span class="line-added">536       const Type* src_type = phase-&gt;type(src);</span>
<span class="line-added">537       const TypeAryPtr* ary_src = src_type-&gt;isa_aryptr();</span>
<span class="line-added">538       BasicType elem = ary_src != NULL ? ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type() : T_CONFLICT;</span>
<span class="line-added">539       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-added">540       assert(!is_clonebasic() || bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Optimization) ||</span>
<span class="line-added">541              (ary_src != NULL &amp;&amp; elem == T_VALUETYPE &amp;&amp; ary_src-&gt;klass()-&gt;is_obj_array_klass()), &quot;added control for clone?&quot;);</span>
<span class="line-added">542 #endif</span>
543       assert(!is_clonebasic() || UseShenandoahGC, &quot;added control for clone?&quot;);
544       phase-&gt;record_for_igvn(this);
545       return false;
546     }
547   }
548   return true;
549 }
550 
551 
552 Node *ArrayCopyNode::Ideal(PhaseGVN *phase, bool can_reshape) {
<span class="line-modified">553   // Perform any generic optimizations first</span>
<span class="line-added">554   Node* result = SafePointNode::Ideal(phase, can_reshape);</span>
<span class="line-added">555   if (result != NULL) {</span>
<span class="line-added">556     return result;</span>
<span class="line-added">557   }</span>
558 
559   if (StressArrayCopyMacroNode &amp;&amp; !can_reshape) {
560     phase-&gt;record_for_igvn(this);
561     return NULL;
562   }
563 
564   // See if it&#39;s a small array copy and we can inline it as
565   // loads/stores
566   // Here we can only do:
567   // - arraycopy if all arguments were validated before and we don&#39;t
568   // need card marking
569   // - clone for which we don&#39;t need to do card marking
570 
571   if (!is_clonebasic() &amp;&amp; !is_arraycopy_validated() &amp;&amp;
572       !is_copyofrange_validated() &amp;&amp; !is_copyof_validated()) {
573     return NULL;
574   }
575 
576   assert(in(TypeFunc::Control) != NULL &amp;&amp;
577          in(TypeFunc::Memory) != NULL &amp;&amp;
</pre>
<hr />
<pre>
579          in(ArrayCopyNode::Dest) != NULL &amp;&amp;
580          in(ArrayCopyNode::Length) != NULL &amp;&amp;
581          in(ArrayCopyNode::SrcPos) != NULL &amp;&amp;
582          in(ArrayCopyNode::DestPos) != NULL, &quot;broken inputs&quot;);
583 
584   if (in(TypeFunc::Control)-&gt;is_top() ||
585       in(TypeFunc::Memory)-&gt;is_top() ||
586       phase-&gt;type(in(ArrayCopyNode::Src)) == Type::TOP ||
587       phase-&gt;type(in(ArrayCopyNode::Dest)) == Type::TOP ||
588       (in(ArrayCopyNode::SrcPos) != NULL &amp;&amp; in(ArrayCopyNode::SrcPos)-&gt;is_top()) ||
589       (in(ArrayCopyNode::DestPos) != NULL &amp;&amp; in(ArrayCopyNode::DestPos)-&gt;is_top())) {
590     return NULL;
591   }
592 
593   int count = get_count(phase);
594 
595   if (count &lt; 0 || count &gt; ArrayCopyLoadStoreMaxElem) {
596     return NULL;
597   }
598 
<span class="line-added">599   Node* src = in(ArrayCopyNode::Src);</span>
<span class="line-added">600   Node* dest = in(ArrayCopyNode::Dest);</span>
<span class="line-added">601   const Type* src_type = phase-&gt;type(src);</span>
<span class="line-added">602   const Type* dest_type = phase-&gt;type(dest);</span>
<span class="line-added">603 </span>
<span class="line-added">604   if (src_type-&gt;isa_aryptr() &amp;&amp; dest_type-&gt;isa_instptr()) {</span>
<span class="line-added">605     // clone used for load of unknown value type can&#39;t be optimized at</span>
<span class="line-added">606     // this point</span>
<span class="line-added">607     return NULL;</span>
<span class="line-added">608   }</span>
<span class="line-added">609 </span>
610   Node* mem = try_clone_instance(phase, can_reshape, count);
611   if (mem != NULL) {
612     return (mem == NodeSentinel) ? NULL : mem;
613   }
614 
615   Node* adr_src = NULL;
616   Node* base_src = NULL;
617   Node* adr_dest = NULL;
618   Node* base_dest = NULL;
619   BasicType copy_type = T_ILLEGAL;
620   const Type* value_type = NULL;
621   bool disjoint_bases = false;
622 
623   if (!prepare_array_copy(phase, can_reshape,
624                           adr_src, base_src, adr_dest, base_dest,
625                           copy_type, value_type, disjoint_bases)) {
626     return NULL;
627   }
628 
<span class="line-modified">629   JVMState* new_jvms = NULL;</span>
<span class="line-modified">630   SafePointNode* new_map = NULL;</span>
<span class="line-modified">631   if (!is_clonebasic()) {</span>
<span class="line-modified">632     new_jvms = jvms()-&gt;clone_shallow(phase-&gt;C);</span>
<span class="line-modified">633     new_map = new SafePointNode(req(), new_jvms);</span>
<span class="line-modified">634     for (uint i = TypeFunc::FramePtr; i &lt; req(); i++) {</span>
<span class="line-modified">635       new_map-&gt;init_req(i, in(i));</span>
<span class="line-modified">636     }</span>
<span class="line-added">637     new_jvms-&gt;set_map(new_map);</span>
<span class="line-added">638   } else {</span>
<span class="line-added">639     new_jvms = new (phase-&gt;C) JVMState(0);</span>
<span class="line-added">640     new_map = new SafePointNode(TypeFunc::Parms, new_jvms);</span>
<span class="line-added">641     new_jvms-&gt;set_map(new_map);</span>
642   }
<span class="line-added">643   new_map-&gt;set_control(in(TypeFunc::Control));</span>
<span class="line-added">644   new_map-&gt;set_memory(MergeMemNode::make(in(TypeFunc::Memory)));</span>
<span class="line-added">645   new_map-&gt;set_i_o(in(TypeFunc::I_O));</span>
<span class="line-added">646   phase-&gt;record_for_igvn(new_map);</span>
<span class="line-added">647 </span>
<span class="line-added">648   const TypeAryPtr* atp_src = get_address_type(phase, _src_type, src);</span>
<span class="line-added">649   const TypeAryPtr* atp_dest = get_address_type(phase, _dest_type, dest);</span>
650 
651   if (can_reshape) {
652     assert(!phase-&gt;is_IterGVN()-&gt;delay_transform(), &quot;cannot delay transforms&quot;);
653     phase-&gt;is_IterGVN()-&gt;set_delay_transform(true);
654   }
655 
<span class="line-added">656   GraphKit kit(new_jvms, phase);</span>
<span class="line-added">657 </span>
<span class="line-added">658   SafePointNode* backward_map = NULL;</span>
<span class="line-added">659   SafePointNode* forward_map = NULL;</span>
660   Node* backward_ctl = phase-&gt;C-&gt;top();
<span class="line-modified">661 </span>
<span class="line-modified">662   array_copy_test_overlap(kit, disjoint_bases, count, backward_ctl);</span>
<span class="line-modified">663 </span>
<span class="line-modified">664   {</span>
<span class="line-modified">665     PreserveJVMState pjvms(&amp;kit);</span>
<span class="line-modified">666 </span>
<span class="line-modified">667     array_copy_forward(kit, can_reshape,</span>
<span class="line-modified">668                        atp_src, atp_dest,</span>
<span class="line-modified">669                        adr_src, base_src, adr_dest, base_dest,</span>
<span class="line-modified">670                        copy_type, value_type, count);</span>
<span class="line-modified">671 </span>
<span class="line-modified">672     forward_map = kit.stop();</span>
<span class="line-modified">673   }</span>
<span class="line-modified">674 </span>
<span class="line-modified">675   kit.set_control(backward_ctl);</span>
<span class="line-modified">676   array_copy_backward(kit, can_reshape,</span>
<span class="line-modified">677                       atp_src, atp_dest,</span>
<span class="line-modified">678                       adr_src, base_src, adr_dest, base_dest,</span>
<span class="line-modified">679                       copy_type, value_type, count);</span>
<span class="line-modified">680 </span>
<span class="line-modified">681   backward_map = kit.stop();</span>
<span class="line-modified">682 </span>
<span class="line-modified">683   if (!forward_map-&gt;control()-&gt;is_top() &amp;&amp; !backward_map-&gt;control()-&gt;is_top()) {</span>
<span class="line-modified">684     assert(forward_map-&gt;i_o() == backward_map-&gt;i_o(), &quot;need a phi on IO?&quot;);</span>
<span class="line-modified">685     Node* ctl = new RegionNode(3);</span>
<span class="line-modified">686     Node* mem = new PhiNode(ctl, Type::MEMORY, TypePtr::BOTTOM);</span>
<span class="line-modified">687     kit.set_map(forward_map);</span>
<span class="line-modified">688     ctl-&gt;init_req(1, kit.control());</span>
<span class="line-modified">689     mem-&gt;init_req(1, kit.reset_memory());</span>
<span class="line-modified">690     kit.set_map(backward_map);</span>
<span class="line-modified">691     ctl-&gt;init_req(2, kit.control());</span>
<span class="line-modified">692     mem-&gt;init_req(2, kit.reset_memory());</span>
<span class="line-modified">693     kit.set_control(phase-&gt;transform(ctl));</span>
<span class="line-modified">694     kit.set_all_memory(phase-&gt;transform(mem));</span>
<span class="line-modified">695   } else if (!forward_map-&gt;control()-&gt;is_top()) {</span>
<span class="line-modified">696     kit.set_map(forward_map);</span>
697   } else {
<span class="line-modified">698     assert(!backward_map-&gt;control()-&gt;is_top(), &quot;no copy?&quot;);</span>
<span class="line-modified">699     kit.set_map(backward_map);</span>

700   }
701 
702   if (can_reshape) {
703     assert(phase-&gt;is_IterGVN()-&gt;delay_transform(), &quot;should be delaying transforms&quot;);
704     phase-&gt;is_IterGVN()-&gt;set_delay_transform(false);
705   }
706 
<span class="line-modified">707   mem = kit.map()-&gt;memory();</span>
<span class="line-added">708   if (!finish_transform(phase, can_reshape, kit.control(), mem)) {</span>
<span class="line-added">709     if (!can_reshape) {</span>
<span class="line-added">710       phase-&gt;record_for_igvn(this);</span>
<span class="line-added">711     }</span>
712     return NULL;
713   }
714 
715   return mem;
716 }
717 
718 bool ArrayCopyNode::may_modify(const TypeOopPtr *t_oop, PhaseTransform *phase) {
719   Node* dest = in(ArrayCopyNode::Dest);
720   if (dest-&gt;is_top()) {
721     return false;
722   }
723   const TypeOopPtr* dest_t = phase-&gt;type(dest)-&gt;is_oopptr();
724   assert(!dest_t-&gt;is_known_instance() || _dest_type-&gt;is_known_instance(), &quot;result of EA not recorded&quot;);
725   assert(in(ArrayCopyNode::Src)-&gt;is_top() || !phase-&gt;type(in(ArrayCopyNode::Src))-&gt;is_oopptr()-&gt;is_known_instance() ||
726          _src_type-&gt;is_known_instance(), &quot;result of EA not recorded&quot;);
727 
728   if (_dest_type != TypeOopPtr::BOTTOM || t_oop-&gt;is_known_instance()) {
729     assert(_dest_type == TypeOopPtr::BOTTOM || _dest_type-&gt;is_known_instance(), &quot;result of EA is known instance&quot;);
730     return t_oop-&gt;instance_id() == _dest_type-&gt;instance_id();
731   }
</pre>
<hr />
<pre>
782 // in the destination array
783 // if must_modify is false, return true if the copy could write
784 // between offset_lo and offset_hi
785 // if must_modify is true, return true if the copy is guaranteed to
786 // write between offset_lo and offset_hi
787 bool ArrayCopyNode::modifies(intptr_t offset_lo, intptr_t offset_hi, PhaseTransform* phase, bool must_modify) const {
788   assert(_kind == ArrayCopy || _kind == CopyOf || _kind == CopyOfRange, &quot;only for real array copies&quot;);
789 
790   Node* dest = in(Dest);
791   Node* dest_pos = in(DestPos);
792   Node* len = in(Length);
793 
794   const TypeInt *dest_pos_t = phase-&gt;type(dest_pos)-&gt;isa_int();
795   const TypeInt *len_t = phase-&gt;type(len)-&gt;isa_int();
796   const TypeAryPtr* ary_t = phase-&gt;type(dest)-&gt;isa_aryptr();
797 
798   if (dest_pos_t == NULL || len_t == NULL || ary_t == NULL) {
799     return !must_modify;
800   }
801 
<span class="line-modified">802   ciArrayKlass* klass = ary_t-&gt;klass()-&gt;as_array_klass();</span>
<span class="line-added">803   BasicType ary_elem = klass-&gt;element_type()-&gt;basic_type();</span>
804   uint header = arrayOopDesc::base_offset_in_bytes(ary_elem);
805   uint elemsize = type2aelembytes(ary_elem);
<span class="line-added">806   if (klass-&gt;is_value_array_klass()) {</span>
<span class="line-added">807     elemsize = klass-&gt;as_value_array_klass()-&gt;element_byte_size();</span>
<span class="line-added">808   }</span>
809 
810   jlong dest_pos_plus_len_lo = (((jlong)dest_pos_t-&gt;_lo) + len_t-&gt;_lo) * elemsize + header;
811   jlong dest_pos_plus_len_hi = (((jlong)dest_pos_t-&gt;_hi) + len_t-&gt;_hi) * elemsize + header;
812   jlong dest_pos_lo = ((jlong)dest_pos_t-&gt;_lo) * elemsize + header;
813   jlong dest_pos_hi = ((jlong)dest_pos_t-&gt;_hi) * elemsize + header;
814 
815   if (must_modify) {
816     if (offset_lo &gt;= dest_pos_hi &amp;&amp; offset_hi &lt; dest_pos_plus_len_lo) {
817       return true;
818     }
819   } else {
820     if (offset_hi &gt;= dest_pos_lo &amp;&amp; offset_lo &lt; dest_pos_plus_len_hi) {
821       return true;
822     }
823   }
824   return false;
825 }
</pre>
</td>
</tr>
</table>
<center><a href="../oops/klass.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="arraycopynode.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
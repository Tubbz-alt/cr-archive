<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/share/opto/arraycopynode.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../oops/klass.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="arraycopynode.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/arraycopynode.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,10 ***</span>
<span class="line-new-header">--- 26,11 ---</span>
  #include &quot;gc/shared/barrierSet.hpp&quot;
  #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  #include &quot;gc/shared/c2/cardTableBarrierSetC2.hpp&quot;
  #include &quot;opto/arraycopynode.hpp&quot;
  #include &quot;opto/graphKit.hpp&quot;
<span class="line-added">+ #include &quot;opto/valuetypenode.hpp&quot;</span>
  #include &quot;runtime/sharedRuntime.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  #include &quot;utilities/powerOfTwo.hpp&quot;
  
  ArrayCopyNode::ArrayCopyNode(Compile* C, bool alloc_tightly_coupled, bool has_negative_length_guard)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 111,13 ***</span>
  
    return is_clonebasic() ? length-&gt;find_intptr_t_con(-1) : length-&gt;find_int_con(-1);
  }
  
  int ArrayCopyNode::get_count(PhaseGVN *phase) const {
<span class="line-modified">!   Node* src = in(ArrayCopyNode::Src);</span>
<span class="line-modified">!   const Type* src_type = phase-&gt;type(src);</span>
<span class="line-modified">! </span>
  
      if (src_type-&gt;isa_instptr()) {
        const TypeInstPtr* inst_src = src_type-&gt;is_instptr();
        ciInstanceKlass* ik = inst_src-&gt;klass()-&gt;as_instance_klass();
        // ciInstanceKlass::nof_nonstatic_fields() doesn&#39;t take injected
<span class="line-new-header">--- 112,17 ---</span>
  
    return is_clonebasic() ? length-&gt;find_intptr_t_con(-1) : length-&gt;find_int_con(-1);
  }
  
  int ArrayCopyNode::get_count(PhaseGVN *phase) const {
<span class="line-modified">!   if (is_clonebasic()) {</span>
<span class="line-modified">!     Node* src = in(ArrayCopyNode::Src);</span>
<span class="line-modified">!     const Type* src_type = phase-&gt;type(src);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (src_type == Type::TOP) {</span>
<span class="line-added">+       return -1;</span>
<span class="line-added">+     }</span>
  
      if (src_type-&gt;isa_instptr()) {
        const TypeInstPtr* inst_src = src_type-&gt;is_instptr();
        ciInstanceKlass* ik = inst_src-&gt;klass()-&gt;as_instance_klass();
        // ciInstanceKlass::nof_nonstatic_fields() doesn&#39;t take injected
</pre>
<hr />
<pre>
<span class="line-old-header">*** 135,12 ***</span>
        // cloning an array we&#39;ll do it element by element. If the
        // length input to ArrayCopyNode is constant, length of input
        // array must be too.
  
        assert((get_length_if_constant(phase) == -1) == !ary_src-&gt;size()-&gt;is_con() ||
<span class="line-modified">!              phase-&gt;is_IterGVN() || StressReflectiveCode, &quot;inconsistent&quot;);</span>
<span class="line-modified">! </span>
        if (ary_src-&gt;size()-&gt;is_con()) {
          return ary_src-&gt;size()-&gt;get_con();
        }
        return -1;
      }
<span class="line-new-header">--- 140,12 ---</span>
        // cloning an array we&#39;ll do it element by element. If the
        // length input to ArrayCopyNode is constant, length of input
        // array must be too.
  
        assert((get_length_if_constant(phase) == -1) == !ary_src-&gt;size()-&gt;is_con() ||
<span class="line-modified">!              (ValueArrayFlatten &amp;&amp; ary_src-&gt;elem()-&gt;make_oopptr() != NULL &amp;&amp; ary_src-&gt;elem()-&gt;make_oopptr()-&gt;can_be_value_type()) ||</span>
<span class="line-modified">!              phase-&gt;is_IterGVN() || phase-&gt;C-&gt;inlining_incrementally() || StressReflectiveCode, &quot;inconsistent&quot;);</span>
        if (ary_src-&gt;size()-&gt;is_con()) {
          return ary_src-&gt;size()-&gt;get_con();
        }
        return -1;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 262,28 ***</span>
        return false;
      }
  
      BasicType src_elem  = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
      BasicType dest_elem = ary_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
<span class="line-modified">!     if (is_reference_type(src_elem))   src_elem  = T_OBJECT;</span>
<span class="line-modified">!     if (is_reference_type(dest_elem))  dest_elem = T_OBJECT;</span>
  
      if (src_elem != dest_elem || dest_elem == T_VOID) {
        // We don&#39;t know if arguments are arrays of the same type
        return false;
      }
  
      BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
<span class="line-modified">!     if (bs-&gt;array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), dest_elem, false, BarrierSetC2::Optimization)) {</span>
<span class="line-modified">!       // It&#39;s an object array copy but we can&#39;t emit the card marking</span>
<span class="line-modified">!       // that is needed</span>
        return false;
      }
  
      value_type = ary_src-&gt;elem();
  
      uint shift  = exact_log2(type2aelembytes(dest_elem));
      uint header = arrayOopDesc::base_offset_in_bytes(dest_elem);
  
      src_offset = Compile::conv_I2X_index(phase, src_offset, ary_src-&gt;size());
      dest_offset = Compile::conv_I2X_index(phase, dest_offset, ary_dest-&gt;size());
      if (src_offset-&gt;is_top() || dest_offset-&gt;is_top()) {
<span class="line-new-header">--- 267,39 ---</span>
        return false;
      }
  
      BasicType src_elem  = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
      BasicType dest_elem = ary_dest-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
<span class="line-modified">!     if (src_elem  == T_ARRAY ||</span>
<span class="line-modified">!         (src_elem == T_VALUETYPE &amp;&amp; ary_src-&gt;klass()-&gt;is_obj_array_klass())) {</span>
<span class="line-added">+       src_elem  = T_OBJECT;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (dest_elem == T_ARRAY ||</span>
<span class="line-added">+         (dest_elem == T_VALUETYPE &amp;&amp; ary_dest-&gt;klass()-&gt;is_obj_array_klass())) {</span>
<span class="line-added">+       dest_elem = T_OBJECT;</span>
<span class="line-added">+     }</span>
  
      if (src_elem != dest_elem || dest_elem == T_VOID) {
        // We don&#39;t know if arguments are arrays of the same type
        return false;
      }
  
      BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
<span class="line-modified">!     if (bs-&gt;array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), dest_elem, false, BarrierSetC2::Optimization) ||</span>
<span class="line-modified">!         (src_elem == T_VALUETYPE &amp;&amp; ary_src-&gt;elem()-&gt;value_klass()-&gt;contains_oops() &amp;&amp;</span>
<span class="line-modified">!          bs-&gt;array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), T_OBJECT, false, BarrierSetC2::Optimization))) {</span>
<span class="line-added">+       // It&#39;s an object array copy but we can&#39;t emit the card marking that is needed</span>
        return false;
      }
  
      value_type = ary_src-&gt;elem();
  
      uint shift  = exact_log2(type2aelembytes(dest_elem));
<span class="line-added">+     if (dest_elem == T_VALUETYPE) {</span>
<span class="line-added">+       ciValueArrayKlass* vak = ary_src-&gt;klass()-&gt;as_value_array_klass();</span>
<span class="line-added">+       shift = vak-&gt;log2_element_size();</span>
<span class="line-added">+     }</span>
      uint header = arrayOopDesc::base_offset_in_bytes(dest_elem);
  
      src_offset = Compile::conv_I2X_index(phase, src_offset, ary_src-&gt;size());
      dest_offset = Compile::conv_I2X_index(phase, dest_offset, ary_dest-&gt;size());
      if (src_offset-&gt;is_top() || dest_offset-&gt;is_top()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 305,20 ***</span>
      assert(ary_src != NULL, &quot;should be a clone&quot;);
      assert(is_clonebasic(), &quot;should be&quot;);
  
      disjoint_bases = true;
  
      adr_src  = phase-&gt;transform(new AddPNode(base_src, base_src, src_offset));
      adr_dest = phase-&gt;transform(new AddPNode(base_dest, base_dest, dest_offset));
  
      BasicType elem = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
<span class="line-modified">!     if (is_reference_type(elem)) {</span>
        elem = T_OBJECT;
      }
  
      BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
<span class="line-modified">!     if (bs-&gt;array_copy_requires_gc_barriers(true, elem, true, BarrierSetC2::Optimization)) {</span>
        return false;
      }
  
      // The address is offseted to an aligned address where a raw copy would start.
      // If the clone copy is decomposed into load-stores - the address is adjusted to
<span class="line-new-header">--- 321,28 ---</span>
      assert(ary_src != NULL, &quot;should be a clone&quot;);
      assert(is_clonebasic(), &quot;should be&quot;);
  
      disjoint_bases = true;
  
<span class="line-added">+     if (ary_src-&gt;elem()-&gt;make_oopptr() != NULL &amp;&amp;</span>
<span class="line-added">+         ary_src-&gt;elem()-&gt;make_oopptr()-&gt;can_be_value_type()) {</span>
<span class="line-added">+       return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      adr_src  = phase-&gt;transform(new AddPNode(base_src, base_src, src_offset));
      adr_dest = phase-&gt;transform(new AddPNode(base_dest, base_dest, dest_offset));
  
      BasicType elem = ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();
<span class="line-modified">!     if (elem == T_ARRAY ||</span>
<span class="line-added">+         (elem == T_VALUETYPE &amp;&amp; ary_src-&gt;klass()-&gt;is_obj_array_klass())) {</span>
        elem = T_OBJECT;
      }
  
      BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
<span class="line-modified">!     if (bs-&gt;array_copy_requires_gc_barriers(true, elem, true, BarrierSetC2::Optimization) ||</span>
<span class="line-added">+         (elem == T_VALUETYPE &amp;&amp; ary_src-&gt;elem()-&gt;value_klass()-&gt;contains_oops() &amp;&amp;</span>
<span class="line-added">+          bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Optimization))) {</span>
        return false;
      }
  
      // The address is offseted to an aligned address where a raw copy would start.
      // If the clone copy is decomposed into load-stores - the address is adjusted to
</pre>
<hr />
<pre>
<span class="line-old-header">*** 335,112 ***</span>
      value_type = ary_src-&gt;elem();
    }
    return true;
  }
  
<span class="line-modified">! const TypePtr* ArrayCopyNode::get_address_type(PhaseGVN* phase, const TypePtr* atp, Node* n) {</span>
    if (atp == TypeOopPtr::BOTTOM) {
      atp = phase-&gt;type(n)-&gt;isa_ptr();
    }
    // adjust atp to be the correct array element address type
<span class="line-modified">!   return atp-&gt;add_offset(Type::OffsetBot);</span>
  }
  
<span class="line-modified">! void ArrayCopyNode::array_copy_test_overlap(PhaseGVN *phase, bool can_reshape, bool disjoint_bases, int count, Node*&amp; forward_ctl, Node*&amp; backward_ctl) {</span>
<span class="line-modified">!   Node* ctl = in(TypeFunc::Control);</span>
    if (!disjoint_bases &amp;&amp; count &gt; 1) {
      Node* src_offset = in(ArrayCopyNode::SrcPos);
      Node* dest_offset = in(ArrayCopyNode::DestPos);
      assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;should be&quot;);
<span class="line-modified">!     Node* cmp = phase-&gt;transform(new CmpINode(src_offset, dest_offset));</span>
<span class="line-modified">!     Node *bol = phase-&gt;transform(new BoolNode(cmp, BoolTest::lt));</span>
      IfNode *iff = new IfNode(ctl, bol, PROB_FAIR, COUNT_UNKNOWN);
  
<span class="line-modified">!     phase-&gt;transform(iff);</span>
  
<span class="line-modified">!     forward_ctl = phase-&gt;transform(new IfFalseNode(iff));</span>
<span class="line-modified">!     backward_ctl = phase-&gt;transform(new IfTrueNode(iff));</span>
    } else {
<span class="line-modified">!     forward_ctl = ctl;</span>
    }
  }
  
<span class="line-modified">! Node* ArrayCopyNode::array_copy_forward(PhaseGVN *phase,</span>
<span class="line-modified">!                                         bool can_reshape,</span>
<span class="line-modified">!                                         Node*&amp; forward_ctl,</span>
<span class="line-modified">!                                         MergeMemNode* mm,</span>
<span class="line-modified">!                                         const TypePtr* atp_src,</span>
<span class="line-modified">!                                         const TypePtr* atp_dest,</span>
<span class="line-modified">!                                         Node* adr_src,</span>
<span class="line-modified">!                                         Node* base_src,</span>
<span class="line-modified">!                                         Node* adr_dest,</span>
<span class="line-modified">!                                         Node* base_dest,</span>
<span class="line-modified">!                                         BasicType copy_type,</span>
<span class="line-modified">!                                         const Type* value_type,</span>
<span class="line-modified">!                                         int count) {</span>
<span class="line-removed">-   if (!forward_ctl-&gt;is_top()) {</span>
<span class="line-removed">-     // copy forward</span>
<span class="line-removed">-     mm = mm-&gt;clone()-&gt;as_MergeMem();</span>
      // copy forward
      if (count &gt; 0) {
<span class="line-modified">!       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-modified">!       Node* v = load(bs, phase, forward_ctl, mm, adr_src, atp_src, value_type, copy_type);</span>
<span class="line-removed">-       store(bs, phase, forward_ctl, mm, adr_dest, atp_dest, v, value_type, copy_type);</span>
<span class="line-removed">-       for (int i = 1; i &lt; count; i++) {</span>
<span class="line-removed">-         Node* off  = phase-&gt;MakeConX(type2aelembytes(copy_type) * i);</span>
<span class="line-removed">-         Node* next_src = phase-&gt;transform(new AddPNode(base_src,adr_src,off));</span>
<span class="line-removed">-         Node* next_dest = phase-&gt;transform(new AddPNode(base_dest,adr_dest,off));</span>
<span class="line-removed">-         v = load(bs, phase, forward_ctl, mm, next_src, atp_src, value_type, copy_type);</span>
<span class="line-removed">-         store(bs, phase, forward_ctl, mm, next_dest, atp_dest, v, value_type, copy_type);</span>
        }
      } else if(can_reshape) {
<span class="line-modified">!       PhaseIterGVN* igvn = phase-&gt;is_IterGVN();</span>
<span class="line-modified">!       igvn-&gt;_worklist.push(adr_src);</span>
<span class="line-modified">!       igvn-&gt;_worklist.push(adr_dest);</span>
      }
<span class="line-removed">-     return mm;</span>
<span class="line-removed">-   }</span>
    }
  }
  
<span class="line-modified">! Node* ArrayCopyNode::array_copy_backward(PhaseGVN *phase,</span>
<span class="line-modified">!                                          bool can_reshape,</span>
<span class="line-modified">!                                          Node*&amp; backward_ctl,</span>
<span class="line-modified">!                                          MergeMemNode* mm,</span>
<span class="line-modified">!                                          const TypePtr* atp_src,</span>
<span class="line-modified">!                                          const TypePtr* atp_dest,</span>
<span class="line-modified">!                                          Node* adr_src,</span>
<span class="line-modified">!                                          Node* base_src,</span>
<span class="line-modified">!                                          Node* adr_dest,</span>
<span class="line-modified">!                                          Node* base_dest,</span>
<span class="line-modified">!                                          BasicType copy_type,</span>
<span class="line-modified">!                                          const Type* value_type,</span>
<span class="line-removed">-                                          int count) {</span>
<span class="line-removed">-   if (!backward_ctl-&gt;is_top()) {</span>
      // copy backward
<span class="line-modified">!     mm = mm-&gt;clone()-&gt;as_MergeMem();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-removed">-     assert(copy_type != T_OBJECT || !bs-&gt;array_copy_requires_gc_barriers(false, T_OBJECT, false, BarrierSetC2::Optimization), &quot;only tightly coupled allocations for object arrays&quot;);</span>
  
      if (count &gt; 0) {
<span class="line-modified">!       for (int i = count-1; i &gt;= 1; i--) {</span>
<span class="line-modified">!         Node* off  = phase-&gt;MakeConX(type2aelembytes(copy_type) * i);</span>
<span class="line-removed">-         Node* next_src = phase-&gt;transform(new AddPNode(base_src,adr_src,off));</span>
<span class="line-removed">-         Node* next_dest = phase-&gt;transform(new AddPNode(base_dest,adr_dest,off));</span>
<span class="line-removed">-         Node* v = load(bs, phase, backward_ctl, mm, next_src, atp_src, value_type, copy_type);</span>
<span class="line-removed">-         store(bs, phase, backward_ctl, mm, next_dest, atp_dest, v, value_type, copy_type);</span>
        }
<span class="line-modified">!       Node* v = load(bs, phase, backward_ctl, mm, adr_src, atp_src, value_type, copy_type);</span>
<span class="line-modified">!       store(bs, phase, backward_ctl, mm, adr_dest, atp_dest, v, value_type, copy_type);</span>
<span class="line-modified">!     } else if(can_reshape) {</span>
<span class="line-modified">!       PhaseIterGVN* igvn = phase-&gt;is_IterGVN();</span>
<span class="line-removed">-       igvn-&gt;_worklist.push(adr_src);</span>
        gvn.record_for_igvn(adr_dest);
      }
<span class="line-removed">-     return phase-&gt;transform(mm);</span>
<span class="line-removed">-   }</span>
    }
  }
  
  bool ArrayCopyNode::finish_transform(PhaseGVN *phase, bool can_reshape,
                                       Node* ctl, Node *mem) {
<span class="line-new-header">--- 359,131 ---</span>
      value_type = ary_src-&gt;elem();
    }
    return true;
  }
  
<span class="line-modified">! const TypeAryPtr* ArrayCopyNode::get_address_type(PhaseGVN* phase, const TypePtr* atp, Node* n) {</span>
    if (atp == TypeOopPtr::BOTTOM) {
      atp = phase-&gt;type(n)-&gt;isa_ptr();
    }
    // adjust atp to be the correct array element address type
<span class="line-modified">!   return atp-&gt;add_offset(Type::OffsetBot)-&gt;is_aryptr();</span>
  }
  
<span class="line-modified">! void ArrayCopyNode::array_copy_test_overlap(GraphKit&amp; kit, bool disjoint_bases, int count, Node*&amp; backward_ctl) {</span>
<span class="line-modified">!   Node* ctl = kit.control();</span>
    if (!disjoint_bases &amp;&amp; count &gt; 1) {
<span class="line-added">+     PhaseGVN&amp; gvn = kit.gvn();</span>
      Node* src_offset = in(ArrayCopyNode::SrcPos);
      Node* dest_offset = in(ArrayCopyNode::DestPos);
      assert(src_offset != NULL &amp;&amp; dest_offset != NULL, &quot;should be&quot;);
<span class="line-modified">!     Node* cmp = gvn.transform(new CmpINode(src_offset, dest_offset));</span>
<span class="line-modified">!     Node *bol = gvn.transform(new BoolNode(cmp, BoolTest::lt));</span>
      IfNode *iff = new IfNode(ctl, bol, PROB_FAIR, COUNT_UNKNOWN);
  
<span class="line-modified">!     gvn.transform(iff);</span>
<span class="line-added">+ </span>
<span class="line-added">+     kit.set_control(gvn.transform(new IfFalseNode(iff)));</span>
<span class="line-added">+     backward_ctl = gvn.transform(new IfTrueNode(iff));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void ArrayCopyNode::copy(GraphKit&amp; kit,</span>
<span class="line-modified">!                          const TypeAryPtr* atp_src,</span>
<span class="line-added">+                          const TypeAryPtr* atp_dest,</span>
<span class="line-added">+                          int i,</span>
<span class="line-added">+                          Node* base_src,</span>
<span class="line-added">+                          Node* base_dest,</span>
<span class="line-added">+                          Node* adr_src,</span>
<span class="line-added">+                          Node* adr_dest,</span>
<span class="line-added">+                          BasicType copy_type,</span>
<span class="line-added">+                          const Type* value_type) {</span>
<span class="line-added">+   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-added">+   Node* ctl = kit.control();</span>
<span class="line-added">+   if (copy_type == T_VALUETYPE) {</span>
<span class="line-added">+     ciValueArrayKlass* vak = atp_src-&gt;klass()-&gt;as_value_array_klass();</span>
<span class="line-added">+     ciValueKlass* vk = vak-&gt;element_klass()-&gt;as_value_klass();</span>
<span class="line-added">+     for (int j = 0; j &lt; vk-&gt;nof_nonstatic_fields(); j++) {</span>
<span class="line-added">+       ciField* field = vk-&gt;nonstatic_field_at(j);</span>
<span class="line-added">+       int off_in_vt = field-&gt;offset() - vk-&gt;first_field_offset();</span>
<span class="line-added">+       Node* off  = kit.MakeConX(off_in_vt + i * vak-&gt;element_byte_size());</span>
<span class="line-added">+       ciType* ft = field-&gt;type();</span>
<span class="line-added">+       BasicType bt = type2field[ft-&gt;basic_type()];</span>
<span class="line-added">+       assert(!field-&gt;is_flattened(), &quot;flattened field encountered&quot;);</span>
<span class="line-added">+       if (bt == T_VALUETYPE) {</span>
<span class="line-added">+         bt = T_OBJECT;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       const Type* rt = Type::get_const_type(ft);</span>
<span class="line-added">+       const TypePtr* adr_type = atp_src-&gt;with_field_offset(off_in_vt)-&gt;add_offset(Type::OffsetBot);</span>
<span class="line-added">+       assert(!bs-&gt;array_copy_requires_gc_barriers(is_alloc_tightly_coupled(), bt, false, BarrierSetC2::Optimization), &quot;GC barriers required&quot;);</span>
<span class="line-added">+       Node* next_src = kit.gvn().transform(new AddPNode(base_src, adr_src, off));</span>
<span class="line-added">+       Node* next_dest = kit.gvn().transform(new AddPNode(base_dest, adr_dest, off));</span>
<span class="line-added">+       Node* v = load(bs, &amp;kit.gvn(), ctl, kit.merged_memory(), next_src, adr_type, rt, bt);</span>
<span class="line-added">+       store(bs, &amp;kit.gvn(), ctl, kit.merged_memory(), next_dest, adr_type, v, rt, bt);</span>
<span class="line-added">+     }</span>
    } else {
<span class="line-modified">!     Node* off = kit.MakeConX(type2aelembytes(copy_type) * i);</span>
<span class="line-added">+     Node* next_src = kit.gvn().transform(new AddPNode(base_src, adr_src, off));</span>
<span class="line-added">+     Node* next_dest = kit.gvn().transform(new AddPNode(base_dest, adr_dest, off));</span>
<span class="line-added">+     Node* v = load(bs, &amp;kit.gvn(), ctl, kit.merged_memory(), next_src, atp_src, value_type, copy_type);</span>
<span class="line-added">+     store(bs, &amp;kit.gvn(), ctl, kit.merged_memory(), next_dest, atp_dest, v, value_type, copy_type);</span>
    }
<span class="line-added">+   kit.set_control(ctl);</span>
  }
  
<span class="line-modified">! </span>
<span class="line-modified">! void ArrayCopyNode::array_copy_forward(GraphKit&amp; kit,</span>
<span class="line-modified">!                                        bool can_reshape,</span>
<span class="line-modified">!                                        const TypeAryPtr* atp_src,</span>
<span class="line-modified">!                                        const TypeAryPtr* atp_dest,</span>
<span class="line-modified">!                                        Node* adr_src,</span>
<span class="line-modified">!                                        Node* base_src,</span>
<span class="line-modified">!                                        Node* adr_dest,</span>
<span class="line-modified">!                                        Node* base_dest,</span>
<span class="line-modified">!                                        BasicType copy_type,</span>
<span class="line-modified">!                                        const Type* value_type,</span>
<span class="line-modified">!                                        int count) {</span>
<span class="line-modified">!   if (!kit.stopped()) {</span>
      // copy forward
      if (count &gt; 0) {
<span class="line-modified">!       for (int i = 0; i &lt; count; i++) {</span>
<span class="line-modified">!         copy(kit, atp_src, atp_dest, i, base_src, base_dest, adr_src, adr_dest, copy_type, value_type);</span>
        }
      } else if(can_reshape) {
<span class="line-modified">!       PhaseGVN&amp; gvn = kit.gvn();</span>
<span class="line-modified">!       assert(gvn.is_IterGVN(), &quot;&quot;);</span>
<span class="line-modified">!       gvn.record_for_igvn(adr_src);</span>
<span class="line-added">+       gvn.record_for_igvn(adr_dest);</span>
      }
    }
  }
  
<span class="line-modified">! void ArrayCopyNode::array_copy_backward(GraphKit&amp; kit,</span>
<span class="line-modified">!                                         bool can_reshape,</span>
<span class="line-modified">!                                         const TypeAryPtr* atp_src,</span>
<span class="line-modified">!                                         const TypeAryPtr* atp_dest,</span>
<span class="line-modified">!                                         Node* adr_src,</span>
<span class="line-modified">!                                         Node* base_src,</span>
<span class="line-modified">!                                         Node* adr_dest,</span>
<span class="line-modified">!                                         Node* base_dest,</span>
<span class="line-modified">!                                         BasicType copy_type,</span>
<span class="line-modified">!                                         const Type* value_type,</span>
<span class="line-modified">!                                         int count) {</span>
<span class="line-modified">!   if (!kit.stopped()) {</span>
      // copy backward
<span class="line-modified">!     PhaseGVN&amp; gvn = kit.gvn();</span>
  
      if (count &gt; 0) {
<span class="line-modified">!       for (int i = count-1; i &gt;= 0; i--) {</span>
<span class="line-modified">!         copy(kit, atp_src, atp_dest, i, base_src, base_dest, adr_src, adr_dest, copy_type, value_type);</span>
        }
<span class="line-modified">!     } else if(can_reshape) {</span>
<span class="line-modified">!       PhaseGVN&amp; gvn = kit.gvn();</span>
<span class="line-modified">!       assert(gvn.is_IterGVN(), &quot;&quot;);</span>
<span class="line-modified">!       gvn.record_for_igvn(adr_src);</span>
        gvn.record_for_igvn(adr_dest);
      }
    }
  }
  
  bool ArrayCopyNode::finish_transform(PhaseGVN *phase, bool can_reshape,
                                       Node* ctl, Node *mem) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 462,21 ***</span>
        Node* out_ctl = proj_out(TypeFunc::Control);
        igvn-&gt;replace_node(out_ctl, ctl);
      } else {
        // replace fallthrough projections of the ArrayCopyNode by the
        // new memory, control and the input IO.
<span class="line-modified">!       CallProjections callprojs;</span>
<span class="line-removed">-       extract_projections(&amp;callprojs, true, false);</span>
  
<span class="line-modified">!       if (callprojs.fallthrough_ioproj != NULL) {</span>
<span class="line-modified">!         igvn-&gt;replace_node(callprojs.fallthrough_ioproj, in(TypeFunc::I_O));</span>
        }
<span class="line-modified">!       if (callprojs.fallthrough_memproj != NULL) {</span>
<span class="line-modified">!         igvn-&gt;replace_node(callprojs.fallthrough_memproj, mem);</span>
        }
<span class="line-modified">!       if (callprojs.fallthrough_catchproj != NULL) {</span>
<span class="line-modified">!         igvn-&gt;replace_node(callprojs.fallthrough_catchproj, ctl);</span>
        }
  
        // The ArrayCopyNode is not disconnected. It still has the
        // projections for the exception case. Replace current
        // ArrayCopyNode with a dummy new one with a top() control so
<span class="line-new-header">--- 505,20 ---</span>
        Node* out_ctl = proj_out(TypeFunc::Control);
        igvn-&gt;replace_node(out_ctl, ctl);
      } else {
        // replace fallthrough projections of the ArrayCopyNode by the
        // new memory, control and the input IO.
<span class="line-modified">!       CallProjections* callprojs = extract_projections(true, false);</span>
  
<span class="line-modified">!       if (callprojs-&gt;fallthrough_ioproj != NULL) {</span>
<span class="line-modified">!         igvn-&gt;replace_node(callprojs-&gt;fallthrough_ioproj, in(TypeFunc::I_O));</span>
        }
<span class="line-modified">!       if (callprojs-&gt;fallthrough_memproj != NULL) {</span>
<span class="line-modified">!         igvn-&gt;replace_node(callprojs-&gt;fallthrough_memproj, mem);</span>
        }
<span class="line-modified">!       if (callprojs-&gt;fallthrough_catchproj != NULL) {</span>
<span class="line-modified">!         igvn-&gt;replace_node(callprojs-&gt;fallthrough_catchproj, ctl);</span>
        }
  
        // The ArrayCopyNode is not disconnected. It still has the
        // projections for the exception case. Replace current
        // ArrayCopyNode with a dummy new one with a top() control so
</pre>
<hr />
<pre>
<span class="line-old-header">*** 487,21 ***</span>
        remove_dead_region(phase, can_reshape);
      }
    } else {
      if (in(TypeFunc::Control) != ctl) {
        // we can&#39;t return new memory and control from Ideal at parse time
        assert(!is_clonebasic() || UseShenandoahGC, &quot;added control for clone?&quot;);
        phase-&gt;record_for_igvn(this);
        return false;
      }
    }
    return true;
  }
  
  
  Node *ArrayCopyNode::Ideal(PhaseGVN *phase, bool can_reshape) {
<span class="line-modified">!   if (remove_dead_region(phase, can_reshape))  return this;</span>
  
    if (StressArrayCopyMacroNode &amp;&amp; !can_reshape) {
      phase-&gt;record_for_igvn(this);
      return NULL;
    }
<span class="line-new-header">--- 529,34 ---</span>
        remove_dead_region(phase, can_reshape);
      }
    } else {
      if (in(TypeFunc::Control) != ctl) {
        // we can&#39;t return new memory and control from Ideal at parse time
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+       Node* src = in(ArrayCopyNode::Src);</span>
<span class="line-added">+       const Type* src_type = phase-&gt;type(src);</span>
<span class="line-added">+       const TypeAryPtr* ary_src = src_type-&gt;isa_aryptr();</span>
<span class="line-added">+       BasicType elem = ary_src != NULL ? ary_src-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type() : T_CONFLICT;</span>
<span class="line-added">+       BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-added">+       assert(!is_clonebasic() || bs-&gt;array_copy_requires_gc_barriers(true, T_OBJECT, true, BarrierSetC2::Optimization) ||</span>
<span class="line-added">+              (ary_src != NULL &amp;&amp; elem == T_VALUETYPE &amp;&amp; ary_src-&gt;klass()-&gt;is_obj_array_klass()), &quot;added control for clone?&quot;);</span>
<span class="line-added">+ #endif</span>
        assert(!is_clonebasic() || UseShenandoahGC, &quot;added control for clone?&quot;);
        phase-&gt;record_for_igvn(this);
        return false;
      }
    }
    return true;
  }
  
  
  Node *ArrayCopyNode::Ideal(PhaseGVN *phase, bool can_reshape) {
<span class="line-modified">!   // Perform any generic optimizations first</span>
<span class="line-added">+   Node* result = SafePointNode::Ideal(phase, can_reshape);</span>
<span class="line-added">+   if (result != NULL) {</span>
<span class="line-added">+     return result;</span>
<span class="line-added">+   }</span>
  
    if (StressArrayCopyMacroNode &amp;&amp; !can_reshape) {
      phase-&gt;record_for_igvn(this);
      return NULL;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 539,10 ***</span>
<span class="line-new-header">--- 594,21 ---</span>
  
    if (count &lt; 0 || count &gt; ArrayCopyLoadStoreMaxElem) {
      return NULL;
    }
  
<span class="line-added">+   Node* src = in(ArrayCopyNode::Src);</span>
<span class="line-added">+   Node* dest = in(ArrayCopyNode::Dest);</span>
<span class="line-added">+   const Type* src_type = phase-&gt;type(src);</span>
<span class="line-added">+   const Type* dest_type = phase-&gt;type(dest);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (src_type-&gt;isa_aryptr() &amp;&amp; dest_type-&gt;isa_instptr()) {</span>
<span class="line-added">+     // clone used for load of unknown value type can&#39;t be optimized at</span>
<span class="line-added">+     // this point</span>
<span class="line-added">+     return NULL;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    Node* mem = try_clone_instance(phase, can_reshape, count);
    if (mem != NULL) {
      return (mem == NodeSentinel) ? NULL : mem;
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 558,74 ***</span>
                            adr_src, base_src, adr_dest, base_dest,
                            copy_type, value_type, disjoint_bases)) {
      return NULL;
    }
  
<span class="line-modified">!   Node* src = in(ArrayCopyNode::Src);</span>
<span class="line-modified">!   Node* dest = in(ArrayCopyNode::Dest);</span>
<span class="line-modified">!   const TypePtr* atp_src = get_address_type(phase, _src_type, src);</span>
<span class="line-modified">!   const TypePtr* atp_dest = get_address_type(phase, _dest_type, dest);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   Node *in_mem = in(TypeFunc::Memory);</span>
<span class="line-modified">!   if (!in_mem-&gt;is_MergeMem()) {</span>
<span class="line-modified">!     in_mem = MergeMemNode::make(in_mem);</span>
    }
  
    if (can_reshape) {
      assert(!phase-&gt;is_IterGVN()-&gt;delay_transform(), &quot;cannot delay transforms&quot;);
      phase-&gt;is_IterGVN()-&gt;set_delay_transform(true);
    }
  
    Node* backward_ctl = phase-&gt;C-&gt;top();
<span class="line-modified">!   Node* forward_ctl = phase-&gt;C-&gt;top();</span>
<span class="line-modified">!   array_copy_test_overlap(phase, can_reshape, disjoint_bases, count, forward_ctl, backward_ctl);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   Node* forward_mem = array_copy_forward(phase, can_reshape, forward_ctl,</span>
<span class="line-modified">!                                          in_mem-&gt;as_MergeMem(),</span>
<span class="line-modified">!                                          atp_src, atp_dest,</span>
<span class="line-modified">!                                          adr_src, base_src, adr_dest, base_dest,</span>
<span class="line-modified">!                                          copy_type, value_type, count);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   Node* backward_mem = array_copy_backward(phase, can_reshape, backward_ctl,</span>
<span class="line-modified">!                                            in_mem-&gt;as_MergeMem(),</span>
<span class="line-modified">!                                            atp_src, atp_dest,</span>
<span class="line-modified">!                                            adr_src, base_src, adr_dest, base_dest,</span>
<span class="line-modified">!                                            copy_type, value_type, count);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   Node* ctl = NULL;</span>
<span class="line-modified">!   if (!forward_ctl-&gt;is_top() &amp;&amp; !backward_ctl-&gt;is_top()) {</span>
<span class="line-modified">!     ctl = new RegionNode(3);</span>
<span class="line-modified">!     ctl-&gt;init_req(1, forward_ctl);</span>
<span class="line-modified">!     ctl-&gt;init_req(2, backward_ctl);</span>
<span class="line-modified">!     ctl = phase-&gt;transform(ctl);</span>
<span class="line-modified">!     MergeMemNode* forward_mm = forward_mem-&gt;as_MergeMem();</span>
<span class="line-modified">!     MergeMemNode* backward_mm = backward_mem-&gt;as_MergeMem();</span>
<span class="line-modified">!     for (MergeMemStream mms(forward_mm, backward_mm); mms.next_non_empty2(); ) {</span>
<span class="line-modified">!       if (mms.memory() != mms.memory2()) {</span>
<span class="line-modified">!         Node* phi = new PhiNode(ctl, Type::MEMORY, phase-&gt;C-&gt;get_adr_type(mms.alias_idx()));</span>
<span class="line-modified">!         phi-&gt;init_req(1, mms.memory());</span>
<span class="line-modified">!         phi-&gt;init_req(2, mms.memory2());</span>
<span class="line-modified">!         phi = phase-&gt;transform(phi);</span>
<span class="line-modified">!         mms.set_memory(phi);</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     mem = forward_mem;</span>
<span class="line-modified">!   } else if (!forward_ctl-&gt;is_top()) {</span>
<span class="line-modified">!     ctl = forward_ctl;</span>
<span class="line-modified">!     mem = forward_mem;</span>
    } else {
<span class="line-modified">!     assert(!backward_ctl-&gt;is_top(), &quot;no copy?&quot;);</span>
<span class="line-modified">!     ctl = backward_ctl;</span>
<span class="line-removed">-     mem = backward_mem;</span>
    }
  
    if (can_reshape) {
      assert(phase-&gt;is_IterGVN()-&gt;delay_transform(), &quot;should be delaying transforms&quot;);
      phase-&gt;is_IterGVN()-&gt;set_delay_transform(false);
    }
  
<span class="line-modified">!   if (!finish_transform(phase, can_reshape, ctl, mem)) {</span>
      return NULL;
    }
  
    return mem;
  }
<span class="line-new-header">--- 624,93 ---</span>
                            adr_src, base_src, adr_dest, base_dest,
                            copy_type, value_type, disjoint_bases)) {
      return NULL;
    }
  
<span class="line-modified">!   JVMState* new_jvms = NULL;</span>
<span class="line-modified">!   SafePointNode* new_map = NULL;</span>
<span class="line-modified">!   if (!is_clonebasic()) {</span>
<span class="line-modified">!     new_jvms = jvms()-&gt;clone_shallow(phase-&gt;C);</span>
<span class="line-modified">!     new_map = new SafePointNode(req(), new_jvms);</span>
<span class="line-modified">!     for (uint i = TypeFunc::FramePtr; i &lt; req(); i++) {</span>
<span class="line-modified">!       new_map-&gt;init_req(i, in(i));</span>
<span class="line-modified">!     }</span>
<span class="line-added">+     new_jvms-&gt;set_map(new_map);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     new_jvms = new (phase-&gt;C) JVMState(0);</span>
<span class="line-added">+     new_map = new SafePointNode(TypeFunc::Parms, new_jvms);</span>
<span class="line-added">+     new_jvms-&gt;set_map(new_map);</span>
    }
<span class="line-added">+   new_map-&gt;set_control(in(TypeFunc::Control));</span>
<span class="line-added">+   new_map-&gt;set_memory(MergeMemNode::make(in(TypeFunc::Memory)));</span>
<span class="line-added">+   new_map-&gt;set_i_o(in(TypeFunc::I_O));</span>
<span class="line-added">+   phase-&gt;record_for_igvn(new_map);</span>
<span class="line-added">+ </span>
<span class="line-added">+   const TypeAryPtr* atp_src = get_address_type(phase, _src_type, src);</span>
<span class="line-added">+   const TypeAryPtr* atp_dest = get_address_type(phase, _dest_type, dest);</span>
  
    if (can_reshape) {
      assert(!phase-&gt;is_IterGVN()-&gt;delay_transform(), &quot;cannot delay transforms&quot;);
      phase-&gt;is_IterGVN()-&gt;set_delay_transform(true);
    }
  
<span class="line-added">+   GraphKit kit(new_jvms, phase);</span>
<span class="line-added">+ </span>
<span class="line-added">+   SafePointNode* backward_map = NULL;</span>
<span class="line-added">+   SafePointNode* forward_map = NULL;</span>
    Node* backward_ctl = phase-&gt;C-&gt;top();
<span class="line-modified">! </span>
<span class="line-modified">!   array_copy_test_overlap(kit, disjoint_bases, count, backward_ctl);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     PreserveJVMState pjvms(&amp;kit);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     array_copy_forward(kit, can_reshape,</span>
<span class="line-modified">!                        atp_src, atp_dest,</span>
<span class="line-modified">!                        adr_src, base_src, adr_dest, base_dest,</span>
<span class="line-modified">!                        copy_type, value_type, count);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     forward_map = kit.stop();</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   kit.set_control(backward_ctl);</span>
<span class="line-modified">!   array_copy_backward(kit, can_reshape,</span>
<span class="line-modified">!                       atp_src, atp_dest,</span>
<span class="line-modified">!                       adr_src, base_src, adr_dest, base_dest,</span>
<span class="line-modified">!                       copy_type, value_type, count);</span>
<span class="line-modified">! </span>
<span class="line-modified">!   backward_map = kit.stop();</span>
<span class="line-modified">! </span>
<span class="line-modified">!   if (!forward_map-&gt;control()-&gt;is_top() &amp;&amp; !backward_map-&gt;control()-&gt;is_top()) {</span>
<span class="line-modified">!     assert(forward_map-&gt;i_o() == backward_map-&gt;i_o(), &quot;need a phi on IO?&quot;);</span>
<span class="line-modified">!     Node* ctl = new RegionNode(3);</span>
<span class="line-modified">!     Node* mem = new PhiNode(ctl, Type::MEMORY, TypePtr::BOTTOM);</span>
<span class="line-modified">!     kit.set_map(forward_map);</span>
<span class="line-modified">!     ctl-&gt;init_req(1, kit.control());</span>
<span class="line-modified">!     mem-&gt;init_req(1, kit.reset_memory());</span>
<span class="line-modified">!     kit.set_map(backward_map);</span>
<span class="line-modified">!     ctl-&gt;init_req(2, kit.control());</span>
<span class="line-modified">!     mem-&gt;init_req(2, kit.reset_memory());</span>
<span class="line-modified">!     kit.set_control(phase-&gt;transform(ctl));</span>
<span class="line-modified">!     kit.set_all_memory(phase-&gt;transform(mem));</span>
<span class="line-modified">!   } else if (!forward_map-&gt;control()-&gt;is_top()) {</span>
<span class="line-modified">!     kit.set_map(forward_map);</span>
    } else {
<span class="line-modified">!     assert(!backward_map-&gt;control()-&gt;is_top(), &quot;no copy?&quot;);</span>
<span class="line-modified">!     kit.set_map(backward_map);</span>
    }
  
    if (can_reshape) {
      assert(phase-&gt;is_IterGVN()-&gt;delay_transform(), &quot;should be delaying transforms&quot;);
      phase-&gt;is_IterGVN()-&gt;set_delay_transform(false);
    }
  
<span class="line-modified">!   mem = kit.map()-&gt;memory();</span>
<span class="line-added">+   if (!finish_transform(phase, can_reshape, kit.control(), mem)) {</span>
<span class="line-added">+     if (!can_reshape) {</span>
<span class="line-added">+       phase-&gt;record_for_igvn(this);</span>
<span class="line-added">+     }</span>
      return NULL;
    }
  
    return mem;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 712,13 ***</span>
  
    if (dest_pos_t == NULL || len_t == NULL || ary_t == NULL) {
      return !must_modify;
    }
  
<span class="line-modified">!   BasicType ary_elem = ary_t-&gt;klass()-&gt;as_array_klass()-&gt;element_type()-&gt;basic_type();</span>
    uint header = arrayOopDesc::base_offset_in_bytes(ary_elem);
    uint elemsize = type2aelembytes(ary_elem);
  
    jlong dest_pos_plus_len_lo = (((jlong)dest_pos_t-&gt;_lo) + len_t-&gt;_lo) * elemsize + header;
    jlong dest_pos_plus_len_hi = (((jlong)dest_pos_t-&gt;_hi) + len_t-&gt;_hi) * elemsize + header;
    jlong dest_pos_lo = ((jlong)dest_pos_t-&gt;_lo) * elemsize + header;
    jlong dest_pos_hi = ((jlong)dest_pos_t-&gt;_hi) * elemsize + header;
<span class="line-new-header">--- 797,17 ---</span>
  
    if (dest_pos_t == NULL || len_t == NULL || ary_t == NULL) {
      return !must_modify;
    }
  
<span class="line-modified">!   ciArrayKlass* klass = ary_t-&gt;klass()-&gt;as_array_klass();</span>
<span class="line-added">+   BasicType ary_elem = klass-&gt;element_type()-&gt;basic_type();</span>
    uint header = arrayOopDesc::base_offset_in_bytes(ary_elem);
    uint elemsize = type2aelembytes(ary_elem);
<span class="line-added">+   if (klass-&gt;is_value_array_klass()) {</span>
<span class="line-added">+     elemsize = klass-&gt;as_value_array_klass()-&gt;element_byte_size();</span>
<span class="line-added">+   }</span>
  
    jlong dest_pos_plus_len_lo = (((jlong)dest_pos_t-&gt;_lo) + len_t-&gt;_lo) * elemsize + header;
    jlong dest_pos_plus_len_hi = (((jlong)dest_pos_t-&gt;_hi) + len_t-&gt;_hi) * elemsize + header;
    jlong dest_pos_lo = ((jlong)dest_pos_t-&gt;_lo) * elemsize + header;
    jlong dest_pos_hi = ((jlong)dest_pos_t-&gt;_hi) * elemsize + header;
</pre>
<center><a href="../oops/klass.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="arraycopynode.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
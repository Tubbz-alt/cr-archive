<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
<a name="1" id="anc1"></a>
  24 #include &quot;precompiled.hpp&quot;
  25 #include &quot;jvm.h&quot;
  26 #include &quot;aot/aotLoader.hpp&quot;
  27 #include &quot;classfile/classFileParser.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/classLoader.hpp&quot;
  30 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  31 #include &quot;classfile/defaultMethods.hpp&quot;
  32 #include &quot;classfile/dictionary.hpp&quot;
  33 #include &quot;classfile/fieldLayoutBuilder.hpp&quot;
  34 #include &quot;classfile/javaClasses.inline.hpp&quot;
  35 #include &quot;classfile/moduleEntry.hpp&quot;
  36 #include &quot;classfile/packageEntry.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/verificationType.hpp&quot;
  40 #include &quot;classfile/verifier.hpp&quot;
  41 #include &quot;classfile/vmSymbols.hpp&quot;
  42 #include &quot;logging/log.hpp&quot;
  43 #include &quot;logging/logStream.hpp&quot;
  44 #include &quot;memory/allocation.hpp&quot;
  45 #include &quot;memory/metadataFactory.hpp&quot;
  46 #include &quot;memory/oopFactory.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/annotations.hpp&quot;
  50 #include &quot;oops/constantPool.inline.hpp&quot;
  51 #include &quot;oops/fieldStreams.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  54 #include &quot;oops/klass.inline.hpp&quot;
  55 #include &quot;oops/klassVtable.hpp&quot;
  56 #include &quot;oops/metadata.hpp&quot;
  57 #include &quot;oops/method.inline.hpp&quot;
  58 #include &quot;oops/oop.inline.hpp&quot;
  59 #include &quot;oops/recordComponent.hpp&quot;
  60 #include &quot;oops/symbol.hpp&quot;
<a name="2" id="anc2"></a>
  61 #include &quot;prims/jvmtiExport.hpp&quot;
  62 #include &quot;prims/jvmtiThreadState.hpp&quot;
  63 #include &quot;runtime/arguments.hpp&quot;
  64 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  65 #include &quot;runtime/handles.inline.hpp&quot;
  66 #include &quot;runtime/javaCalls.hpp&quot;
  67 #include &quot;runtime/os.hpp&quot;
  68 #include &quot;runtime/perfData.hpp&quot;
  69 #include &quot;runtime/reflection.hpp&quot;
  70 #include &quot;runtime/safepointVerifiers.hpp&quot;
  71 #include &quot;runtime/signature.hpp&quot;
  72 #include &quot;runtime/timer.hpp&quot;
  73 #include &quot;services/classLoadingService.hpp&quot;
  74 #include &quot;services/threadService.hpp&quot;
  75 #include &quot;utilities/align.hpp&quot;
  76 #include &quot;utilities/bitMap.inline.hpp&quot;
  77 #include &quot;utilities/copy.hpp&quot;
  78 #include &quot;utilities/exceptions.hpp&quot;
  79 #include &quot;utilities/globalDefinitions.hpp&quot;
  80 #include &quot;utilities/growableArray.hpp&quot;
  81 #include &quot;utilities/macros.hpp&quot;
  82 #include &quot;utilities/ostream.hpp&quot;
  83 #include &quot;utilities/resourceHash.hpp&quot;
<a name="3" id="anc3"></a>
  84 #include &quot;utilities/utf8.hpp&quot;
  85 
  86 #if INCLUDE_CDS
  87 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  88 #endif
  89 #if INCLUDE_JFR
  90 #include &quot;jfr/support/jfrTraceIdExtension.hpp&quot;
  91 #endif
  92 
  93 // We generally try to create the oops directly when parsing, rather than
  94 // allocating temporary data structures and copying the bytes twice. A
  95 // temporary area is only needed when parsing utf8 entries in the constant
  96 // pool and when parsing line number tables.
  97 
  98 // We add assert in debug mode when class format is not checked.
  99 
 100 #define JAVA_CLASSFILE_MAGIC              0xCAFEBABE
 101 #define JAVA_MIN_SUPPORTED_VERSION        45
 102 #define JAVA_PREVIEW_MINOR_VERSION        65535
 103 
 104 // Used for two backward compatibility reasons:
 105 // - to check for new additions to the class file format in JDK1.5
 106 // - to check for bug fixes in the format checker in JDK1.5
 107 #define JAVA_1_5_VERSION                  49
 108 
 109 // Used for backward compatibility reasons:
 110 // - to check for javac bug fixes that happened after 1.5
 111 // - also used as the max version when running in jdk6
 112 #define JAVA_6_VERSION                    50
 113 
 114 // Used for backward compatibility reasons:
 115 // - to disallow argument and require ACC_STATIC for &lt;clinit&gt; methods
 116 #define JAVA_7_VERSION                    51
 117 
 118 // Extension method support.
 119 #define JAVA_8_VERSION                    52
 120 
 121 #define JAVA_9_VERSION                    53
 122 
 123 #define JAVA_10_VERSION                   54
 124 
 125 #define JAVA_11_VERSION                   55
 126 
 127 #define JAVA_12_VERSION                   56
 128 
 129 #define JAVA_13_VERSION                   57
 130 
 131 #define JAVA_14_VERSION                   58
 132 
 133 #define JAVA_15_VERSION                   59
 134 
<a name="4" id="anc4"></a>

 135 void ClassFileParser::set_class_bad_constant_seen(short bad_constant) {
 136   assert((bad_constant == JVM_CONSTANT_Module ||
 137           bad_constant == JVM_CONSTANT_Package) &amp;&amp; _major_version &gt;= JAVA_9_VERSION,
 138          &quot;Unexpected bad constant pool entry&quot;);
 139   if (_bad_constant_seen == 0) _bad_constant_seen = bad_constant;
 140 }
 141 
 142 void ClassFileParser::parse_constant_pool_entries(const ClassFileStream* const stream,
 143                                                   ConstantPool* cp,
 144                                                   const int length,
 145                                                   TRAPS) {
 146   assert(stream != NULL, &quot;invariant&quot;);
 147   assert(cp != NULL, &quot;invariant&quot;);
 148 
 149   // Use a local copy of ClassFileStream. It helps the C++ compiler to optimize
 150   // this function (_current can be allocated in a register, with scalar
 151   // replacement of aggregates). The _current pointer is copied back to
 152   // stream() when this function returns. DON&#39;T call another method within
 153   // this method that uses stream().
 154   const ClassFileStream cfs1 = *stream;
 155   const ClassFileStream* const cfs = &amp;cfs1;
 156 
 157   assert(cfs-&gt;allocated_on_stack(), &quot;should be local&quot;);
 158   debug_only(const u1* const old_current = stream-&gt;current();)
 159 
 160   // Used for batching symbol allocations.
 161   const char* names[SymbolTable::symbol_alloc_batch_size];
 162   int lengths[SymbolTable::symbol_alloc_batch_size];
 163   int indices[SymbolTable::symbol_alloc_batch_size];
 164   unsigned int hashValues[SymbolTable::symbol_alloc_batch_size];
 165   int names_count = 0;
 166 
 167   // parsing  Index 0 is unused
 168   for (int index = 1; index &lt; length; index++) {
 169     // Each of the following case guarantees one more byte in the stream
 170     // for the following tag or the access_flags following constant pool,
 171     // so we don&#39;t need bounds-check for reading tag.
 172     const u1 tag = cfs-&gt;get_u1_fast();
 173     switch (tag) {
<a name="5" id="anc5"></a><span class="line-modified"> 174       case JVM_CONSTANT_Class : {</span>
 175         cfs-&gt;guarantee_more(3, CHECK);  // name_index, tag/access_flags
 176         const u2 name_index = cfs-&gt;get_u2_fast();
 177         cp-&gt;klass_index_at_put(index, name_index);
 178         break;
 179       }
 180       case JVM_CONSTANT_Fieldref: {
 181         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 182         const u2 class_index = cfs-&gt;get_u2_fast();
 183         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 184         cp-&gt;field_at_put(index, class_index, name_and_type_index);
 185         break;
 186       }
 187       case JVM_CONSTANT_Methodref: {
 188         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 189         const u2 class_index = cfs-&gt;get_u2_fast();
 190         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 191         cp-&gt;method_at_put(index, class_index, name_and_type_index);
 192         break;
 193       }
 194       case JVM_CONSTANT_InterfaceMethodref: {
 195         cfs-&gt;guarantee_more(5, CHECK);  // class_index, name_and_type_index, tag/access_flags
 196         const u2 class_index = cfs-&gt;get_u2_fast();
 197         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 198         cp-&gt;interface_method_at_put(index, class_index, name_and_type_index);
 199         break;
 200       }
 201       case JVM_CONSTANT_String : {
 202         cfs-&gt;guarantee_more(3, CHECK);  // string_index, tag/access_flags
 203         const u2 string_index = cfs-&gt;get_u2_fast();
 204         cp-&gt;string_index_at_put(index, string_index);
 205         break;
 206       }
 207       case JVM_CONSTANT_MethodHandle :
 208       case JVM_CONSTANT_MethodType: {
 209         if (_major_version &lt; Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
 210           classfile_parse_error(
 211             &quot;Class file version does not support constant tag %u in class file %s&quot;,
 212             tag, CHECK);
 213         }
 214         if (tag == JVM_CONSTANT_MethodHandle) {
 215           cfs-&gt;guarantee_more(4, CHECK);  // ref_kind, method_index, tag/access_flags
 216           const u1 ref_kind = cfs-&gt;get_u1_fast();
 217           const u2 method_index = cfs-&gt;get_u2_fast();
 218           cp-&gt;method_handle_index_at_put(index, ref_kind, method_index);
 219         }
 220         else if (tag == JVM_CONSTANT_MethodType) {
 221           cfs-&gt;guarantee_more(3, CHECK);  // signature_index, tag/access_flags
 222           const u2 signature_index = cfs-&gt;get_u2_fast();
 223           cp-&gt;method_type_index_at_put(index, signature_index);
 224         }
 225         else {
 226           ShouldNotReachHere();
 227         }
 228         break;
 229       }
 230       case JVM_CONSTANT_Dynamic : {
 231         if (_major_version &lt; Verifier::DYNAMICCONSTANT_MAJOR_VERSION) {
 232           classfile_parse_error(
 233               &quot;Class file version does not support constant tag %u in class file %s&quot;,
 234               tag, CHECK);
 235         }
 236         cfs-&gt;guarantee_more(5, CHECK);  // bsm_index, nt, tag/access_flags
 237         const u2 bootstrap_specifier_index = cfs-&gt;get_u2_fast();
 238         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 239         if (_max_bootstrap_specifier_index &lt; (int) bootstrap_specifier_index) {
 240           _max_bootstrap_specifier_index = (int) bootstrap_specifier_index;  // collect for later
 241         }
 242         cp-&gt;dynamic_constant_at_put(index, bootstrap_specifier_index, name_and_type_index);
 243         break;
 244       }
 245       case JVM_CONSTANT_InvokeDynamic : {
 246         if (_major_version &lt; Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
 247           classfile_parse_error(
 248               &quot;Class file version does not support constant tag %u in class file %s&quot;,
 249               tag, CHECK);
 250         }
 251         cfs-&gt;guarantee_more(5, CHECK);  // bsm_index, nt, tag/access_flags
 252         const u2 bootstrap_specifier_index = cfs-&gt;get_u2_fast();
 253         const u2 name_and_type_index = cfs-&gt;get_u2_fast();
 254         if (_max_bootstrap_specifier_index &lt; (int) bootstrap_specifier_index) {
 255           _max_bootstrap_specifier_index = (int) bootstrap_specifier_index;  // collect for later
 256         }
 257         cp-&gt;invoke_dynamic_at_put(index, bootstrap_specifier_index, name_and_type_index);
 258         break;
 259       }
 260       case JVM_CONSTANT_Integer: {
 261         cfs-&gt;guarantee_more(5, CHECK);  // bytes, tag/access_flags
 262         const u4 bytes = cfs-&gt;get_u4_fast();
 263         cp-&gt;int_at_put(index, (jint)bytes);
 264         break;
 265       }
 266       case JVM_CONSTANT_Float: {
 267         cfs-&gt;guarantee_more(5, CHECK);  // bytes, tag/access_flags
 268         const u4 bytes = cfs-&gt;get_u4_fast();
 269         cp-&gt;float_at_put(index, *(jfloat*)&amp;bytes);
 270         break;
 271       }
 272       case JVM_CONSTANT_Long: {
 273         // A mangled type might cause you to overrun allocated memory
 274         guarantee_property(index + 1 &lt; length,
 275                            &quot;Invalid constant pool entry %u in class file %s&quot;,
 276                            index,
 277                            CHECK);
 278         cfs-&gt;guarantee_more(9, CHECK);  // bytes, tag/access_flags
 279         const u8 bytes = cfs-&gt;get_u8_fast();
 280         cp-&gt;long_at_put(index, bytes);
 281         index++;   // Skip entry following eigth-byte constant, see JVM book p. 98
 282         break;
 283       }
 284       case JVM_CONSTANT_Double: {
 285         // A mangled type might cause you to overrun allocated memory
 286         guarantee_property(index+1 &lt; length,
 287                            &quot;Invalid constant pool entry %u in class file %s&quot;,
 288                            index,
 289                            CHECK);
 290         cfs-&gt;guarantee_more(9, CHECK);  // bytes, tag/access_flags
 291         const u8 bytes = cfs-&gt;get_u8_fast();
 292         cp-&gt;double_at_put(index, *(jdouble*)&amp;bytes);
 293         index++;   // Skip entry following eigth-byte constant, see JVM book p. 98
 294         break;
 295       }
 296       case JVM_CONSTANT_NameAndType: {
 297         cfs-&gt;guarantee_more(5, CHECK);  // name_index, signature_index, tag/access_flags
 298         const u2 name_index = cfs-&gt;get_u2_fast();
 299         const u2 signature_index = cfs-&gt;get_u2_fast();
 300         cp-&gt;name_and_type_at_put(index, name_index, signature_index);
 301         break;
 302       }
 303       case JVM_CONSTANT_Utf8 : {
 304         cfs-&gt;guarantee_more(2, CHECK);  // utf8_length
 305         u2  utf8_length = cfs-&gt;get_u2_fast();
 306         const u1* utf8_buffer = cfs-&gt;current();
 307         assert(utf8_buffer != NULL, &quot;null utf8 buffer&quot;);
 308         // Got utf8 string, guarantee utf8_length+1 bytes, set stream position forward.
 309         cfs-&gt;guarantee_more(utf8_length+1, CHECK);  // utf8 string, tag/access_flags
 310         cfs-&gt;skip_u1_fast(utf8_length);
 311 
 312         // Before storing the symbol, make sure it&#39;s legal
 313         if (_need_verify) {
 314           verify_legal_utf8(utf8_buffer, utf8_length, CHECK);
 315         }
 316 
 317         if (has_cp_patch_at(index)) {
 318           Handle patch = clear_cp_patch_at(index);
 319           guarantee_property(java_lang_String::is_instance(patch()),
 320                              &quot;Illegal utf8 patch at %d in class file %s&quot;,
 321                              index,
 322                              CHECK);
 323           const char* const str = java_lang_String::as_utf8_string(patch());
 324           // (could use java_lang_String::as_symbol instead, but might as well batch them)
 325           utf8_buffer = (const u1*) str;
 326           utf8_length = (u2) strlen(str);
 327         }
 328 
 329         unsigned int hash;
 330         Symbol* const result = SymbolTable::lookup_only((const char*)utf8_buffer,
 331                                                         utf8_length,
 332                                                         hash);
 333         if (result == NULL) {
 334           names[names_count] = (const char*)utf8_buffer;
 335           lengths[names_count] = utf8_length;
 336           indices[names_count] = index;
 337           hashValues[names_count++] = hash;
 338           if (names_count == SymbolTable::symbol_alloc_batch_size) {
 339             SymbolTable::new_symbols(_loader_data,
 340                                      constantPoolHandle(THREAD, cp),
 341                                      names_count,
 342                                      names,
 343                                      lengths,
 344                                      indices,
 345                                      hashValues);
 346             names_count = 0;
 347           }
 348         } else {
 349           cp-&gt;symbol_at_put(index, result);
 350         }
 351         break;
 352       }
 353       case JVM_CONSTANT_Module:
 354       case JVM_CONSTANT_Package: {
 355         // Record that an error occurred in these two cases but keep parsing so
 356         // that ACC_Module can be checked for in the access_flags.  Need to
 357         // throw NoClassDefFoundError in that case.
 358         if (_major_version &gt;= JAVA_9_VERSION) {
 359           cfs-&gt;guarantee_more(3, CHECK);
 360           cfs-&gt;get_u2_fast();
 361           set_class_bad_constant_seen(tag);
 362           break;
 363         }
 364       }
 365       default: {
 366         classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;,
 367                               tag,
 368                               CHECK);
 369         break;
 370       }
 371     } // end of switch(tag)
 372   } // end of for
 373 
 374   // Allocate the remaining symbols
 375   if (names_count &gt; 0) {
 376     SymbolTable::new_symbols(_loader_data,
 377                              constantPoolHandle(THREAD, cp),
 378                              names_count,
 379                              names,
 380                              lengths,
 381                              indices,
 382                              hashValues);
 383   }
 384 
 385   // Copy _current pointer of local copy back to stream.
 386   assert(stream-&gt;current() == old_current, &quot;non-exclusive use of stream&quot;);
 387   stream-&gt;set_current(cfs1.current());
 388 
 389 }
 390 
 391 static inline bool valid_cp_range(int index, int length) {
 392   return (index &gt; 0 &amp;&amp; index &lt; length);
 393 }
 394 
 395 static inline Symbol* check_symbol_at(const ConstantPool* cp, int index) {
 396   assert(cp != NULL, &quot;invariant&quot;);
 397   if (valid_cp_range(index, cp-&gt;length()) &amp;&amp; cp-&gt;tag_at(index).is_utf8()) {
 398     return cp-&gt;symbol_at(index);
 399   }
 400   return NULL;
 401 }
 402 
 403 #ifdef ASSERT
 404 PRAGMA_DIAG_PUSH
 405 PRAGMA_FORMAT_NONLITERAL_IGNORED
 406 void ClassFileParser::report_assert_property_failure(const char* msg, TRAPS) const {
 407   ResourceMark rm(THREAD);
 408   fatal(msg, _class_name-&gt;as_C_string());
 409 }
 410 
 411 void ClassFileParser::report_assert_property_failure(const char* msg,
 412                                                      int index,
 413                                                      TRAPS) const {
 414   ResourceMark rm(THREAD);
 415   fatal(msg, index, _class_name-&gt;as_C_string());
 416 }
 417 PRAGMA_DIAG_POP
 418 #endif
 419 
 420 void ClassFileParser::parse_constant_pool(const ClassFileStream* const stream,
 421                                          ConstantPool* const cp,
 422                                          const int length,
 423                                          TRAPS) {
 424   assert(cp != NULL, &quot;invariant&quot;);
 425   assert(stream != NULL, &quot;invariant&quot;);
 426 
 427   // parsing constant pool entries
 428   parse_constant_pool_entries(stream, cp, length, CHECK);
 429   if (class_bad_constant_seen() != 0) {
 430     // a bad CP entry has been detected previously so stop parsing and just return.
 431     return;
 432   }
 433 
 434   int index = 1;  // declared outside of loops for portability
 435   int num_klasses = 0;
 436 
 437   // first verification pass - validate cross references
 438   // and fixup class and string constants
 439   for (index = 1; index &lt; length; index++) {          // Index 0 is unused
 440     const jbyte tag = cp-&gt;tag_at(index).value();
 441     switch (tag) {
 442       case JVM_CONSTANT_Class: {
 443         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 444         break;
 445       }
 446       case JVM_CONSTANT_Fieldref:
 447         // fall through
 448       case JVM_CONSTANT_Methodref:
 449         // fall through
 450       case JVM_CONSTANT_InterfaceMethodref: {
 451         if (!_need_verify) break;
 452         const int klass_ref_index = cp-&gt;klass_ref_index_at(index);
 453         const int name_and_type_ref_index = cp-&gt;name_and_type_ref_index_at(index);
 454         check_property(valid_klass_reference_at(klass_ref_index),
 455                        &quot;Invalid constant pool index %u in class file %s&quot;,
 456                        klass_ref_index, CHECK);
 457         check_property(valid_cp_range(name_and_type_ref_index, length) &amp;&amp;
 458           cp-&gt;tag_at(name_and_type_ref_index).is_name_and_type(),
 459           &quot;Invalid constant pool index %u in class file %s&quot;,
 460           name_and_type_ref_index, CHECK);
 461         break;
 462       }
 463       case JVM_CONSTANT_String: {
 464         ShouldNotReachHere();     // Only JVM_CONSTANT_StringIndex should be present
 465         break;
 466       }
 467       case JVM_CONSTANT_Integer:
 468         break;
 469       case JVM_CONSTANT_Float:
 470         break;
 471       case JVM_CONSTANT_Long:
 472       case JVM_CONSTANT_Double: {
 473         index++;
 474         check_property(
 475           (index &lt; length &amp;&amp; cp-&gt;tag_at(index).is_invalid()),
 476           &quot;Improper constant pool long/double index %u in class file %s&quot;,
 477           index, CHECK);
 478         break;
 479       }
 480       case JVM_CONSTANT_NameAndType: {
 481         if (!_need_verify) break;
 482         const int name_ref_index = cp-&gt;name_ref_index_at(index);
 483         const int signature_ref_index = cp-&gt;signature_ref_index_at(index);
 484         check_property(valid_symbol_at(name_ref_index),
 485           &quot;Invalid constant pool index %u in class file %s&quot;,
 486           name_ref_index, CHECK);
 487         check_property(valid_symbol_at(signature_ref_index),
 488           &quot;Invalid constant pool index %u in class file %s&quot;,
 489           signature_ref_index, CHECK);
 490         break;
 491       }
 492       case JVM_CONSTANT_Utf8:
 493         break;
 494       case JVM_CONSTANT_UnresolvedClass:         // fall-through
 495       case JVM_CONSTANT_UnresolvedClassInError: {
 496         ShouldNotReachHere();     // Only JVM_CONSTANT_ClassIndex should be present
 497         break;
 498       }
 499       case JVM_CONSTANT_ClassIndex: {
 500         const int class_index = cp-&gt;klass_index_at(index);
 501         check_property(valid_symbol_at(class_index),
 502           &quot;Invalid constant pool index %u in class file %s&quot;,
 503           class_index, CHECK);
<a name="6" id="anc6"></a><span class="line-modified"> 504         cp-&gt;unresolved_klass_at_put(index, class_index, num_klasses++);</span>







 505         break;
 506       }
 507       case JVM_CONSTANT_StringIndex: {
 508         const int string_index = cp-&gt;string_index_at(index);
 509         check_property(valid_symbol_at(string_index),
 510           &quot;Invalid constant pool index %u in class file %s&quot;,
 511           string_index, CHECK);
 512         Symbol* const sym = cp-&gt;symbol_at(string_index);
 513         cp-&gt;unresolved_string_at_put(index, sym);
 514         break;
 515       }
 516       case JVM_CONSTANT_MethodHandle: {
 517         const int ref_index = cp-&gt;method_handle_index_at(index);
 518         check_property(valid_cp_range(ref_index, length),
 519           &quot;Invalid constant pool index %u in class file %s&quot;,
 520           ref_index, CHECK);
 521         const constantTag tag = cp-&gt;tag_at(ref_index);
 522         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 523 
 524         switch (ref_kind) {
 525           case JVM_REF_getField:
 526           case JVM_REF_getStatic:
 527           case JVM_REF_putField:
 528           case JVM_REF_putStatic: {
 529             check_property(
 530               tag.is_field(),
 531               &quot;Invalid constant pool index %u in class file %s (not a field)&quot;,
 532               ref_index, CHECK);
 533             break;
 534           }
 535           case JVM_REF_invokeVirtual:
 536           case JVM_REF_newInvokeSpecial: {
 537             check_property(
 538               tag.is_method(),
 539               &quot;Invalid constant pool index %u in class file %s (not a method)&quot;,
 540               ref_index, CHECK);
 541             break;
 542           }
 543           case JVM_REF_invokeStatic:
 544           case JVM_REF_invokeSpecial: {
 545             check_property(
 546               tag.is_method() ||
 547               ((_major_version &gt;= JAVA_8_VERSION) &amp;&amp; tag.is_interface_method()),
 548               &quot;Invalid constant pool index %u in class file %s (not a method)&quot;,
 549               ref_index, CHECK);
 550             break;
 551           }
 552           case JVM_REF_invokeInterface: {
 553             check_property(
 554               tag.is_interface_method(),
 555               &quot;Invalid constant pool index %u in class file %s (not an interface method)&quot;,
 556               ref_index, CHECK);
 557             break;
 558           }
 559           default: {
 560             classfile_parse_error(
 561               &quot;Bad method handle kind at constant pool index %u in class file %s&quot;,
 562               index, CHECK);
 563           }
 564         } // switch(refkind)
 565         // Keep the ref_index unchanged.  It will be indirected at link-time.
 566         break;
 567       } // case MethodHandle
 568       case JVM_CONSTANT_MethodType: {
 569         const int ref_index = cp-&gt;method_type_index_at(index);
 570         check_property(valid_symbol_at(ref_index),
 571           &quot;Invalid constant pool index %u in class file %s&quot;,
 572           ref_index, CHECK);
 573         break;
 574       }
 575       case JVM_CONSTANT_Dynamic: {
 576         const int name_and_type_ref_index =
 577           cp-&gt;bootstrap_name_and_type_ref_index_at(index);
 578 
 579         check_property(valid_cp_range(name_and_type_ref_index, length) &amp;&amp;
 580           cp-&gt;tag_at(name_and_type_ref_index).is_name_and_type(),
 581           &quot;Invalid constant pool index %u in class file %s&quot;,
 582           name_and_type_ref_index, CHECK);
 583         // bootstrap specifier index must be checked later,
 584         // when BootstrapMethods attr is available
 585 
 586         // Mark the constant pool as having a CONSTANT_Dynamic_info structure
 587         cp-&gt;set_has_dynamic_constant();
 588         break;
 589       }
 590       case JVM_CONSTANT_InvokeDynamic: {
 591         const int name_and_type_ref_index =
 592           cp-&gt;bootstrap_name_and_type_ref_index_at(index);
 593 
 594         check_property(valid_cp_range(name_and_type_ref_index, length) &amp;&amp;
 595           cp-&gt;tag_at(name_and_type_ref_index).is_name_and_type(),
 596           &quot;Invalid constant pool index %u in class file %s&quot;,
 597           name_and_type_ref_index, CHECK);
 598         // bootstrap specifier index must be checked later,
 599         // when BootstrapMethods attr is available
 600         break;
 601       }
 602       default: {
 603         fatal(&quot;bad constant pool tag value %u&quot;, cp-&gt;tag_at(index).value());
 604         ShouldNotReachHere();
 605         break;
 606       }
 607     } // switch(tag)
 608   } // end of for
 609 
 610   _first_patched_klass_resolved_index = num_klasses;
 611   cp-&gt;allocate_resolved_klasses(_loader_data, num_klasses + _max_num_patched_klasses, CHECK);
 612 
 613   if (_cp_patches != NULL) {
 614     // need to treat this_class specially...
 615 
 616     // Add dummy utf8 entries in the space reserved for names of patched classes. We&#39;ll use &quot;*&quot;
 617     // for now. These will be replaced with actual names of the patched classes in patch_class().
 618     Symbol* s = vmSymbols::star_name();
 619     for (int n=_orig_cp_size; n&lt;cp-&gt;length(); n++) {
 620       cp-&gt;symbol_at_put(n, s);
 621     }
 622 
 623     int this_class_index;
 624     {
 625       stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
 626       const u1* const mark = stream-&gt;current();
 627       stream-&gt;skip_u2_fast(1); // skip flags
 628       this_class_index = stream-&gt;get_u2_fast();
 629       stream-&gt;set_current(mark);  // revert to mark
 630     }
 631 
 632     for (index = 1; index &lt; length; index++) {          // Index 0 is unused
 633       if (has_cp_patch_at(index)) {
 634         guarantee_property(index != this_class_index,
 635           &quot;Illegal constant pool patch to self at %d in class file %s&quot;,
 636           index, CHECK);
 637         patch_constant_pool(cp, index, cp_patch_at(index), CHECK);
 638       }
 639     }
 640   }
 641 
 642   if (!_need_verify) {
 643     return;
 644   }
 645 
 646   // second verification pass - checks the strings are of the right format.
 647   // but not yet to the other entries
 648   for (index = 1; index &lt; length; index++) {
 649     const jbyte tag = cp-&gt;tag_at(index).value();
 650     switch (tag) {
 651       case JVM_CONSTANT_UnresolvedClass: {
 652         const Symbol* const class_name = cp-&gt;klass_name_at(index);
 653         // check the name, even if _cp_patches will overwrite it
 654         verify_legal_class_name(class_name, CHECK);
 655         break;
 656       }
 657       case JVM_CONSTANT_NameAndType: {
 658         if (_need_verify) {
 659           const int sig_index = cp-&gt;signature_ref_index_at(index);
 660           const int name_index = cp-&gt;name_ref_index_at(index);
 661           const Symbol* const name = cp-&gt;symbol_at(name_index);
 662           const Symbol* const sig = cp-&gt;symbol_at(sig_index);
 663           guarantee_property(sig-&gt;utf8_length() != 0,
 664             &quot;Illegal zero length constant pool entry at %d in class %s&quot;,
 665             sig_index, CHECK);
 666           guarantee_property(name-&gt;utf8_length() != 0,
 667             &quot;Illegal zero length constant pool entry at %d in class %s&quot;,
 668             name_index, CHECK);
 669 
 670           if (Signature::is_method(sig)) {
 671             // Format check method name and signature
 672             verify_legal_method_name(name, CHECK);
 673             verify_legal_method_signature(name, sig, CHECK);
 674           } else {
 675             // Format check field name and signature
 676             verify_legal_field_name(name, CHECK);
 677             verify_legal_field_signature(name, sig, CHECK);
 678           }
 679         }
 680         break;
 681       }
 682       case JVM_CONSTANT_Dynamic: {
 683         const int name_and_type_ref_index =
 684           cp-&gt;name_and_type_ref_index_at(index);
 685         // already verified to be utf8
 686         const int name_ref_index =
 687           cp-&gt;name_ref_index_at(name_and_type_ref_index);
 688         // already verified to be utf8
 689         const int signature_ref_index =
 690           cp-&gt;signature_ref_index_at(name_and_type_ref_index);
 691         const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
 692         const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
 693         if (_need_verify) {
 694           // CONSTANT_Dynamic&#39;s name and signature are verified above, when iterating NameAndType_info.
 695           // Need only to be sure signature is the right type.
 696           if (Signature::is_method(signature)) {
 697             throwIllegalSignature(&quot;CONSTANT_Dynamic&quot;, name, signature, CHECK);
 698           }
 699         }
 700         break;
 701       }
 702       case JVM_CONSTANT_InvokeDynamic:
 703       case JVM_CONSTANT_Fieldref:
 704       case JVM_CONSTANT_Methodref:
 705       case JVM_CONSTANT_InterfaceMethodref: {
 706         const int name_and_type_ref_index =
 707           cp-&gt;name_and_type_ref_index_at(index);
 708         // already verified to be utf8
 709         const int name_ref_index =
 710           cp-&gt;name_ref_index_at(name_and_type_ref_index);
 711         // already verified to be utf8
 712         const int signature_ref_index =
 713           cp-&gt;signature_ref_index_at(name_and_type_ref_index);
 714         const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
 715         const Symbol* const signature = cp-&gt;symbol_at(signature_ref_index);
 716         if (tag == JVM_CONSTANT_Fieldref) {
 717           if (_need_verify) {
 718             // Field name and signature are verified above, when iterating NameAndType_info.
 719             // Need only to be sure signature is non-zero length and the right type.
 720             if (Signature::is_method(signature)) {
 721               throwIllegalSignature(&quot;Field&quot;, name, signature, CHECK);
 722             }
 723           }
 724         } else {
 725           if (_need_verify) {
 726             // Method name and signature are verified above, when iterating NameAndType_info.
 727             // Need only to be sure signature is non-zero length and the right type.
 728             if (!Signature::is_method(signature)) {
 729               throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK);
 730             }
 731           }
 732           // 4509014: If a class method name begins with &#39;&lt;&#39;, it must be &quot;&lt;init&gt;&quot;
 733           const unsigned int name_len = name-&gt;utf8_length();
 734           if (tag == JVM_CONSTANT_Methodref &amp;&amp;
 735               name_len != 0 &amp;&amp;
 736               name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL &amp;&amp;
 737               name != vmSymbols::object_initializer_name()) {
 738             classfile_parse_error(
 739               &quot;Bad method name at constant pool index %u in class file %s&quot;,
 740               name_ref_index, CHECK);
 741           }
 742         }
 743         break;
 744       }
 745       case JVM_CONSTANT_MethodHandle: {
 746         const int ref_index = cp-&gt;method_handle_index_at(index);
 747         const int ref_kind = cp-&gt;method_handle_ref_kind_at(index);
 748         switch (ref_kind) {
 749           case JVM_REF_invokeVirtual:
 750           case JVM_REF_invokeStatic:
 751           case JVM_REF_invokeSpecial:
 752           case JVM_REF_newInvokeSpecial: {
 753             const int name_and_type_ref_index =
 754               cp-&gt;name_and_type_ref_index_at(ref_index);
 755             const int name_ref_index =
 756               cp-&gt;name_ref_index_at(name_and_type_ref_index);
 757             const Symbol* const name = cp-&gt;symbol_at(name_ref_index);
<a name="7" id="anc7"></a><span class="line-modified"> 758             if (ref_kind == JVM_REF_newInvokeSpecial) {</span>
<span class="line-modified"> 759               if (name != vmSymbols::object_initializer_name()) {</span>
 760                 classfile_parse_error(
 761                   &quot;Bad constructor name at constant pool index %u in class file %s&quot;,
 762                     name_ref_index, CHECK);
 763               }
 764             } else {
<a name="8" id="anc8"></a><span class="line-modified"> 765               if (name == vmSymbols::object_initializer_name()) {</span>











 766                 classfile_parse_error(
 767                   &quot;Bad method name at constant pool index %u in class file %s&quot;,
 768                   name_ref_index, CHECK);
 769               }
 770             }
 771             break;
 772           }
 773           // Other ref_kinds are already fully checked in previous pass.
 774         } // switch(ref_kind)
 775         break;
 776       }
 777       case JVM_CONSTANT_MethodType: {
 778         const Symbol* const no_name = vmSymbols::type_name(); // place holder
 779         const Symbol* const signature = cp-&gt;method_type_signature_at(index);
 780         verify_legal_method_signature(no_name, signature, CHECK);
 781         break;
 782       }
 783       case JVM_CONSTANT_Utf8: {
 784         assert(cp-&gt;symbol_at(index)-&gt;refcount() != 0, &quot;count corrupted&quot;);
 785       }
 786     }  // switch(tag)
 787   }  // end of for
 788 }
 789 
 790 Handle ClassFileParser::clear_cp_patch_at(int index) {
 791   Handle patch = cp_patch_at(index);
 792   _cp_patches-&gt;at_put(index, Handle());
 793   assert(!has_cp_patch_at(index), &quot;&quot;);
 794   return patch;
 795 }
 796 
 797 void ClassFileParser::patch_class(ConstantPool* cp, int class_index, Klass* k, Symbol* name) {
 798   int name_index = _orig_cp_size + _num_patched_klasses;
 799   int resolved_klass_index = _first_patched_klass_resolved_index + _num_patched_klasses;
 800 
 801   cp-&gt;klass_at_put(class_index, name_index, resolved_klass_index, k, name);
 802   _num_patched_klasses ++;
 803 }
 804 
 805 void ClassFileParser::patch_constant_pool(ConstantPool* cp,
 806                                           int index,
 807                                           Handle patch,
 808                                           TRAPS) {
 809   assert(cp != NULL, &quot;invariant&quot;);
 810 
 811   BasicType patch_type = T_VOID;
 812 
 813   switch (cp-&gt;tag_at(index).value()) {
 814 
 815     case JVM_CONSTANT_UnresolvedClass: {
 816       // Patching a class means pre-resolving it.
 817       // The name in the constant pool is ignored.
 818       if (java_lang_Class::is_instance(patch())) {
 819         guarantee_property(!java_lang_Class::is_primitive(patch()),
 820                            &quot;Illegal class patch at %d in class file %s&quot;,
 821                            index, CHECK);
 822         Klass* k = java_lang_Class::as_Klass(patch());
 823         patch_class(cp, index, k, k-&gt;name());
 824       } else {
 825         guarantee_property(java_lang_String::is_instance(patch()),
 826                            &quot;Illegal class patch at %d in class file %s&quot;,
 827                            index, CHECK);
 828         Symbol* const name = java_lang_String::as_symbol(patch());
 829         patch_class(cp, index, NULL, name);
 830       }
 831       break;
 832     }
 833 
 834     case JVM_CONSTANT_String: {
 835       // skip this patch and don&#39;t clear it.  Needs the oop array for resolved
 836       // references to be created first.
 837       return;
 838     }
 839     case JVM_CONSTANT_Integer: patch_type = T_INT;    goto patch_prim;
 840     case JVM_CONSTANT_Float:   patch_type = T_FLOAT;  goto patch_prim;
 841     case JVM_CONSTANT_Long:    patch_type = T_LONG;   goto patch_prim;
 842     case JVM_CONSTANT_Double:  patch_type = T_DOUBLE; goto patch_prim;
 843     patch_prim:
 844     {
 845       jvalue value;
 846       BasicType value_type = java_lang_boxing_object::get_value(patch(), &amp;value);
 847       guarantee_property(value_type == patch_type,
 848                          &quot;Illegal primitive patch at %d in class file %s&quot;,
 849                          index, CHECK);
 850       switch (value_type) {
 851         case T_INT:    cp-&gt;int_at_put(index,   value.i); break;
 852         case T_FLOAT:  cp-&gt;float_at_put(index, value.f); break;
 853         case T_LONG:   cp-&gt;long_at_put(index,  value.j); break;
 854         case T_DOUBLE: cp-&gt;double_at_put(index, value.d); break;
 855         default:       assert(false, &quot;&quot;);
 856       }
 857     } // end patch_prim label
 858     break;
 859 
 860     default: {
 861       // %%% TODO: put method handles into CONSTANT_InterfaceMethodref, etc.
 862       guarantee_property(!has_cp_patch_at(index),
 863                          &quot;Illegal unexpected patch at %d in class file %s&quot;,
 864                          index, CHECK);
 865       return;
 866     }
 867   } // end of switch(tag)
 868 
 869   // On fall-through, mark the patch as used.
 870   clear_cp_patch_at(index);
 871 }
 872 class NameSigHash: public ResourceObj {
 873  public:
 874   const Symbol*       _name;       // name
 875   const Symbol*       _sig;        // signature
 876   NameSigHash*  _next;             // Next entry in hash table
 877 };
 878 
 879 static const int HASH_ROW_SIZE = 256;
 880 
 881 static unsigned int hash(const Symbol* name, const Symbol* sig) {
 882   unsigned int raw_hash = 0;
 883   raw_hash += ((unsigned int)(uintptr_t)name) &gt;&gt; (LogHeapWordSize + 2);
 884   raw_hash += ((unsigned int)(uintptr_t)sig) &gt;&gt; LogHeapWordSize;
 885 
 886   return (raw_hash + (unsigned int)(uintptr_t)name) % HASH_ROW_SIZE;
 887 }
 888 
 889 
 890 static void initialize_hashtable(NameSigHash** table) {
 891   memset((void*)table, 0, sizeof(NameSigHash*) * HASH_ROW_SIZE);
 892 }
 893 // Return false if the name/sig combination is found in table.
 894 // Return true if no duplicate is found. And name/sig is added as a new entry in table.
 895 // The old format checker uses heap sort to find duplicates.
 896 // NOTE: caller should guarantee that GC doesn&#39;t happen during the life cycle
 897 // of table since we don&#39;t expect Symbol*&#39;s to move.
 898 static bool put_after_lookup(const Symbol* name, const Symbol* sig, NameSigHash** table) {
 899   assert(name != NULL, &quot;name in constant pool is NULL&quot;);
 900 
 901   // First lookup for duplicates
 902   int index = hash(name, sig);
 903   NameSigHash* entry = table[index];
 904   while (entry != NULL) {
 905     if (entry-&gt;_name == name &amp;&amp; entry-&gt;_sig == sig) {
 906       return false;
 907     }
 908     entry = entry-&gt;_next;
 909   }
 910 
 911   // No duplicate is found, allocate a new entry and fill it.
 912   entry = new NameSigHash();
 913   entry-&gt;_name = name;
 914   entry-&gt;_sig = sig;
 915 
 916   // Insert into hash table
 917   entry-&gt;_next = table[index];
 918   table[index] = entry;
 919 
 920   return true;
 921 }
 922 
 923 // Side-effects: populates the _local_interfaces field
<a name="9" id="anc9"></a><span class="line-modified"> 924 void ClassFileParser::parse_interfaces(const ClassFileStream* const stream,</span>
<span class="line-modified"> 925                                        const int itfs_len,</span>
<span class="line-modified"> 926                                        ConstantPool* const cp,</span>

 927                                        bool* const has_nonstatic_concrete_methods,
<a name="10" id="anc10"></a>






 928                                        TRAPS) {
 929   assert(stream != NULL, &quot;invariant&quot;);
 930   assert(cp != NULL, &quot;invariant&quot;);
 931   assert(has_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
 932 
 933   if (itfs_len == 0) {
<a name="11" id="anc11"></a><span class="line-modified"> 934     _local_interfaces = Universe::the_empty_instance_klass_array();</span>
 935   } else {
 936     assert(itfs_len &gt; 0, &quot;only called for len&gt;0&quot;);
<a name="12" id="anc12"></a><span class="line-modified"> 937     _local_interfaces = MetadataFactory::new_array&lt;InstanceKlass*&gt;(_loader_data, itfs_len, NULL, CHECK);</span>
<span class="line-modified"> 938 </span>
<span class="line-removed"> 939     int index;</span>
 940     for (index = 0; index &lt; itfs_len; index++) {
 941       const u2 interface_index = stream-&gt;get_u2(CHECK);
 942       Klass* interf;
 943       check_property(
 944         valid_klass_reference_at(interface_index),
 945         &quot;Interface name has bad constant pool index %u in class file %s&quot;,
 946         interface_index, CHECK);
 947       if (cp-&gt;tag_at(interface_index).is_klass()) {
 948         interf = cp-&gt;resolved_klass_at(interface_index);
 949       } else {
 950         Symbol* const unresolved_klass  = cp-&gt;klass_name_at(interface_index);
 951 
 952         // Don&#39;t need to check legal name because it&#39;s checked when parsing constant pool.
 953         // But need to make sure it&#39;s not an array type.
 954         guarantee_property(unresolved_klass-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
 955                            &quot;Bad interface name in class file %s&quot;, CHECK);
 956 
<a name="13" id="anc13"></a><span class="line-modified"> 957         // Call resolve_super so classcircularity is checked</span>
 958         interf = SystemDictionary::resolve_super_or_fail(
 959                                                   _class_name,
 960                                                   unresolved_klass,
 961                                                   Handle(THREAD, _loader_data-&gt;class_loader()),
 962                                                   _protection_domain,
 963                                                   false,
 964                                                   CHECK);
 965       }
 966 
 967       if (!interf-&gt;is_interface()) {
 968         THROW_MSG(vmSymbols::java_lang_IncompatibleClassChangeError(),
 969                   err_msg(&quot;class %s can not implement %s, because it is not an interface (%s)&quot;,
 970                           _class_name-&gt;as_klass_external_name(),
 971                           interf-&gt;external_name(),
 972                           interf-&gt;class_in_module_of_loader()));
 973       }
 974 
<a name="14" id="anc14"></a><span class="line-modified"> 975       if (InstanceKlass::cast(interf)-&gt;has_nonstatic_concrete_methods()) {</span>













 976         *has_nonstatic_concrete_methods = true;
 977       }
<a name="15" id="anc15"></a><span class="line-modified"> 978       _local_interfaces-&gt;at_put(index, InstanceKlass::cast(interf));</span>






 979     }
 980 
 981     if (!_need_verify || itfs_len &lt;= 1) {
 982       return;
 983     }
 984 
 985     // Check if there&#39;s any duplicates in interfaces
 986     ResourceMark rm(THREAD);
 987     NameSigHash** interface_names = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
 988                                                                  NameSigHash*,
 989                                                                  HASH_ROW_SIZE);
 990     initialize_hashtable(interface_names);
 991     bool dup = false;
 992     const Symbol* name = NULL;
 993     {
 994       debug_only(NoSafepointVerifier nsv;)
 995       for (index = 0; index &lt; itfs_len; index++) {
<a name="16" id="anc16"></a><span class="line-modified"> 996         const InstanceKlass* const k = _local_interfaces-&gt;at(index);</span>
 997         name = k-&gt;name();
 998         // If no duplicates, add (name, NULL) in hashtable interface_names.
 999         if (!put_after_lookup(name, NULL, interface_names)) {
1000           dup = true;
1001           break;
1002         }
1003       }
1004     }
1005     if (dup) {
1006       classfile_parse_error(&quot;Duplicate interface name \&quot;%s\&quot; in class file %s&quot;,
1007                              name-&gt;as_C_string(), CHECK);
1008     }
1009   }
1010 }
1011 
1012 void ClassFileParser::verify_constantvalue(const ConstantPool* const cp,
1013                                            int constantvalue_index,
1014                                            int signature_index,
1015                                            TRAPS) const {
1016   // Make sure the constant pool entry is of a type appropriate to this field
1017   guarantee_property(
1018     (constantvalue_index &gt; 0 &amp;&amp;
1019       constantvalue_index &lt; cp-&gt;length()),
1020     &quot;Bad initial value index %u in ConstantValue attribute in class file %s&quot;,
1021     constantvalue_index, CHECK);
1022 
1023   const constantTag value_type = cp-&gt;tag_at(constantvalue_index);
1024   switch(cp-&gt;basic_type_for_signature_at(signature_index)) {
1025     case T_LONG: {
1026       guarantee_property(value_type.is_long(),
1027                          &quot;Inconsistent constant value type in class file %s&quot;,
1028                          CHECK);
1029       break;
1030     }
1031     case T_FLOAT: {
1032       guarantee_property(value_type.is_float(),
1033                          &quot;Inconsistent constant value type in class file %s&quot;,
1034                          CHECK);
1035       break;
1036     }
1037     case T_DOUBLE: {
1038       guarantee_property(value_type.is_double(),
1039                          &quot;Inconsistent constant value type in class file %s&quot;,
1040                          CHECK);
1041       break;
1042     }
1043     case T_BYTE:
1044     case T_CHAR:
1045     case T_SHORT:
1046     case T_BOOLEAN:
1047     case T_INT: {
1048       guarantee_property(value_type.is_int(),
1049                          &quot;Inconsistent constant value type in class file %s&quot;,
1050                          CHECK);
1051       break;
1052     }
1053     case T_OBJECT: {
1054       guarantee_property((cp-&gt;symbol_at(signature_index)-&gt;equals(&quot;Ljava/lang/String;&quot;)
1055                          &amp;&amp; value_type.is_string()),
1056                          &quot;Bad string initial value in class file %s&quot;,
1057                          CHECK);
1058       break;
1059     }
1060     default: {
1061       classfile_parse_error(&quot;Unable to set initial value %u in class file %s&quot;,
1062                              constantvalue_index,
1063                              CHECK);
1064     }
1065   }
1066 }
1067 
1068 class AnnotationCollector : public ResourceObj{
1069 public:
1070   enum Location { _in_field, _in_method, _in_class };
1071   enum ID {
1072     _unknown = 0,
1073     _method_CallerSensitive,
1074     _method_ForceInline,
1075     _method_DontInline,
1076     _method_InjectedProfile,
1077     _method_LambdaForm_Compiled,
1078     _method_Hidden,
1079     _method_HotSpotIntrinsicCandidate,
1080     _jdk_internal_vm_annotation_Contended,
1081     _field_Stable,
1082     _jdk_internal_vm_annotation_ReservedStackAccess,
1083     _annotation_LIMIT
1084   };
1085   const Location _location;
1086   int _annotations_present;
1087   u2 _contended_group;
1088 
1089   AnnotationCollector(Location location)
1090     : _location(location), _annotations_present(0)
1091   {
1092     assert((int)_annotation_LIMIT &lt;= (int)sizeof(_annotations_present) * BitsPerByte, &quot;&quot;);
1093   }
1094   // If this annotation name has an ID, report it (or _none).
1095   ID annotation_index(const ClassLoaderData* loader_data, const Symbol* name, bool can_access_vm_annotations);
1096   // Set the annotation name:
1097   void set_annotation(ID id) {
1098     assert((int)id &gt;= 0 &amp;&amp; (int)id &lt; (int)_annotation_LIMIT, &quot;oob&quot;);
1099     _annotations_present |= nth_bit((int)id);
1100   }
1101 
1102   void remove_annotation(ID id) {
1103     assert((int)id &gt;= 0 &amp;&amp; (int)id &lt; (int)_annotation_LIMIT, &quot;oob&quot;);
1104     _annotations_present &amp;= ~nth_bit((int)id);
1105   }
1106 
1107   // Report if the annotation is present.
1108   bool has_any_annotations() const { return _annotations_present != 0; }
1109   bool has_annotation(ID id) const { return (nth_bit((int)id) &amp; _annotations_present) != 0; }
1110 
1111   void set_contended_group(u2 group) { _contended_group = group; }
1112   u2 contended_group() const { return _contended_group; }
1113 
1114   bool is_contended() const { return has_annotation(_jdk_internal_vm_annotation_Contended); }
1115 
1116   void set_stable(bool stable) { set_annotation(_field_Stable); }
1117   bool is_stable() const { return has_annotation(_field_Stable); }
1118 };
1119 
1120 // This class also doubles as a holder for metadata cleanup.
1121 class ClassFileParser::FieldAnnotationCollector : public AnnotationCollector {
1122 private:
1123   ClassLoaderData* _loader_data;
1124   AnnotationArray* _field_annotations;
1125   AnnotationArray* _field_type_annotations;
1126 public:
1127   FieldAnnotationCollector(ClassLoaderData* loader_data) :
1128     AnnotationCollector(_in_field),
1129     _loader_data(loader_data),
1130     _field_annotations(NULL),
1131     _field_type_annotations(NULL) {}
1132   ~FieldAnnotationCollector();
1133   void apply_to(FieldInfo* f);
1134   AnnotationArray* field_annotations()      { return _field_annotations; }
1135   AnnotationArray* field_type_annotations() { return _field_type_annotations; }
1136 
1137   void set_field_annotations(AnnotationArray* a)      { _field_annotations = a; }
1138   void set_field_type_annotations(AnnotationArray* a) { _field_type_annotations = a; }
1139 };
1140 
1141 class MethodAnnotationCollector : public AnnotationCollector{
1142 public:
1143   MethodAnnotationCollector() : AnnotationCollector(_in_method) { }
1144   void apply_to(const methodHandle&amp; m);
1145 };
1146 
1147 class ClassFileParser::ClassAnnotationCollector : public AnnotationCollector{
1148 public:
1149   ClassAnnotationCollector() : AnnotationCollector(_in_class) { }
1150   void apply_to(InstanceKlass* ik);
1151 };
1152 
1153 
1154 static int skip_annotation_value(const u1*, int, int); // fwd decl
1155 
1156 // Safely increment index by val if does not pass limit
1157 #define SAFE_ADD(index, limit, val) \
1158 if (index &gt;= limit - val) return limit; \
1159 index += val;
1160 
1161 // Skip an annotation.  Return &gt;=limit if there is any problem.
1162 static int skip_annotation(const u1* buffer, int limit, int index) {
1163   assert(buffer != NULL, &quot;invariant&quot;);
1164   // annotation := atype:u2 do(nmem:u2) {member:u2 value}
1165   // value := switch (tag:u1) { ... }
1166   SAFE_ADD(index, limit, 4); // skip atype and read nmem
1167   int nmem = Bytes::get_Java_u2((address)buffer + index - 2);
1168   while (--nmem &gt;= 0 &amp;&amp; index &lt; limit) {
1169     SAFE_ADD(index, limit, 2); // skip member
1170     index = skip_annotation_value(buffer, limit, index);
1171   }
1172   return index;
1173 }
1174 
1175 // Skip an annotation value.  Return &gt;=limit if there is any problem.
1176 static int skip_annotation_value(const u1* buffer, int limit, int index) {
1177   assert(buffer != NULL, &quot;invariant&quot;);
1178 
1179   // value := switch (tag:u1) {
1180   //   case B, C, I, S, Z, D, F, J, c: con:u2;
1181   //   case e: e_class:u2 e_name:u2;
1182   //   case s: s_con:u2;
1183   //   case [: do(nval:u2) {value};
1184   //   case @: annotation;
1185   //   case s: s_con:u2;
1186   // }
1187   SAFE_ADD(index, limit, 1); // read tag
1188   const u1 tag = buffer[index - 1];
1189   switch (tag) {
1190     case &#39;B&#39;:
1191     case &#39;C&#39;:
1192     case &#39;I&#39;:
1193     case &#39;S&#39;:
1194     case &#39;Z&#39;:
1195     case &#39;D&#39;:
1196     case &#39;F&#39;:
1197     case &#39;J&#39;:
1198     case &#39;c&#39;:
1199     case &#39;s&#39;:
1200       SAFE_ADD(index, limit, 2);  // skip con or s_con
1201       break;
1202     case &#39;e&#39;:
1203       SAFE_ADD(index, limit, 4);  // skip e_class, e_name
1204       break;
1205     case &#39;[&#39;:
1206     {
1207       SAFE_ADD(index, limit, 2); // read nval
1208       int nval = Bytes::get_Java_u2((address)buffer + index - 2);
1209       while (--nval &gt;= 0 &amp;&amp; index &lt; limit) {
1210         index = skip_annotation_value(buffer, limit, index);
1211       }
1212     }
1213     break;
1214     case &#39;@&#39;:
1215       index = skip_annotation(buffer, limit, index);
1216       break;
1217     default:
1218       return limit;  //  bad tag byte
1219   }
1220   return index;
1221 }
1222 
1223 // Sift through annotations, looking for those significant to the VM:
1224 static void parse_annotations(const ConstantPool* const cp,
1225                               const u1* buffer, int limit,
1226                               AnnotationCollector* coll,
1227                               ClassLoaderData* loader_data,
1228                               const bool can_access_vm_annotations,
1229                               TRAPS) {
1230 
1231   assert(cp != NULL, &quot;invariant&quot;);
1232   assert(buffer != NULL, &quot;invariant&quot;);
1233   assert(coll != NULL, &quot;invariant&quot;);
1234   assert(loader_data != NULL, &quot;invariant&quot;);
1235 
1236   // annotations := do(nann:u2) {annotation}
1237   int index = 2; // read nann
1238   if (index &gt;= limit)  return;
1239   int nann = Bytes::get_Java_u2((address)buffer + index - 2);
1240   enum {  // initial annotation layout
1241     atype_off = 0,      // utf8 such as &#39;Ljava/lang/annotation/Retention;&#39;
1242     count_off = 2,      // u2   such as 1 (one value)
1243     member_off = 4,     // utf8 such as &#39;value&#39;
1244     tag_off = 6,        // u1   such as &#39;c&#39; (type) or &#39;e&#39; (enum)
1245     e_tag_val = &#39;e&#39;,
1246     e_type_off = 7,   // utf8 such as &#39;Ljava/lang/annotation/RetentionPolicy;&#39;
1247     e_con_off = 9,    // utf8 payload, such as &#39;SOURCE&#39;, &#39;CLASS&#39;, &#39;RUNTIME&#39;
1248     e_size = 11,     // end of &#39;e&#39; annotation
1249     c_tag_val = &#39;c&#39;,    // payload is type
1250     c_con_off = 7,    // utf8 payload, such as &#39;I&#39;
1251     c_size = 9,       // end of &#39;c&#39; annotation
1252     s_tag_val = &#39;s&#39;,    // payload is String
1253     s_con_off = 7,    // utf8 payload, such as &#39;Ljava/lang/String;&#39;
1254     s_size = 9,
1255     min_size = 6        // smallest possible size (zero members)
1256   };
1257   // Cannot add min_size to index in case of overflow MAX_INT
1258   while ((--nann) &gt;= 0 &amp;&amp; (index - 2 &lt;= limit - min_size)) {
1259     int index0 = index;
1260     index = skip_annotation(buffer, limit, index);
1261     const u1* const abase = buffer + index0;
1262     const int atype = Bytes::get_Java_u2((address)abase + atype_off);
1263     const int count = Bytes::get_Java_u2((address)abase + count_off);
1264     const Symbol* const aname = check_symbol_at(cp, atype);
1265     if (aname == NULL)  break;  // invalid annotation name
1266     const Symbol* member = NULL;
1267     if (count &gt;= 1) {
1268       const int member_index = Bytes::get_Java_u2((address)abase + member_off);
1269       member = check_symbol_at(cp, member_index);
1270       if (member == NULL)  break;  // invalid member name
1271     }
1272 
1273     // Here is where parsing particular annotations will take place.
1274     AnnotationCollector::ID id = coll-&gt;annotation_index(loader_data, aname, can_access_vm_annotations);
1275     if (AnnotationCollector::_unknown == id)  continue;
1276     coll-&gt;set_annotation(id);
1277 
1278     if (AnnotationCollector::_jdk_internal_vm_annotation_Contended == id) {
1279       // @Contended can optionally specify the contention group.
1280       //
1281       // Contended group defines the equivalence class over the fields:
1282       // the fields within the same contended group are not treated distinct.
1283       // The only exception is default group, which does not incur the
1284       // equivalence. Naturally, contention group for classes is meaningless.
1285       //
1286       // While the contention group is specified as String, annotation
1287       // values are already interned, and we might as well use the constant
1288       // pool index as the group tag.
1289       //
1290       u2 group_index = 0; // default contended group
1291       if (count == 1
1292         &amp;&amp; s_size == (index - index0)  // match size
1293         &amp;&amp; s_tag_val == *(abase + tag_off)
1294         &amp;&amp; member == vmSymbols::value_name()) {
1295         group_index = Bytes::get_Java_u2((address)abase + s_con_off);
1296         if (cp-&gt;symbol_at(group_index)-&gt;utf8_length() == 0) {
1297           group_index = 0; // default contended group
1298         }
1299       }
1300       coll-&gt;set_contended_group(group_index);
1301     }
1302   }
1303 }
1304 
1305 
1306 // Parse attributes for a field.
1307 void ClassFileParser::parse_field_attributes(const ClassFileStream* const cfs,
1308                                              u2 attributes_count,
1309                                              bool is_static, u2 signature_index,
1310                                              u2* const constantvalue_index_addr,
1311                                              bool* const is_synthetic_addr,
1312                                              u2* const generic_signature_index_addr,
1313                                              ClassFileParser::FieldAnnotationCollector* parsed_annotations,
1314                                              TRAPS) {
1315   assert(cfs != NULL, &quot;invariant&quot;);
1316   assert(constantvalue_index_addr != NULL, &quot;invariant&quot;);
1317   assert(is_synthetic_addr != NULL, &quot;invariant&quot;);
1318   assert(generic_signature_index_addr != NULL, &quot;invariant&quot;);
1319   assert(parsed_annotations != NULL, &quot;invariant&quot;);
1320   assert(attributes_count &gt; 0, &quot;attributes_count should be greater than 0&quot;);
1321 
1322   u2 constantvalue_index = 0;
1323   u2 generic_signature_index = 0;
1324   bool is_synthetic = false;
1325   const u1* runtime_visible_annotations = NULL;
1326   int runtime_visible_annotations_length = 0;
1327   const u1* runtime_invisible_annotations = NULL;
1328   int runtime_invisible_annotations_length = 0;
1329   const u1* runtime_visible_type_annotations = NULL;
1330   int runtime_visible_type_annotations_length = 0;
1331   const u1* runtime_invisible_type_annotations = NULL;
1332   int runtime_invisible_type_annotations_length = 0;
1333   bool runtime_invisible_annotations_exists = false;
1334   bool runtime_invisible_type_annotations_exists = false;
1335   const ConstantPool* const cp = _cp;
1336 
1337   while (attributes_count--) {
1338     cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
1339     const u2 attribute_name_index = cfs-&gt;get_u2_fast();
1340     const u4 attribute_length = cfs-&gt;get_u4_fast();
1341     check_property(valid_symbol_at(attribute_name_index),
1342                    &quot;Invalid field attribute index %u in class file %s&quot;,
1343                    attribute_name_index,
1344                    CHECK);
1345 
1346     const Symbol* const attribute_name = cp-&gt;symbol_at(attribute_name_index);
1347     if (is_static &amp;&amp; attribute_name == vmSymbols::tag_constant_value()) {
1348       // ignore if non-static
1349       if (constantvalue_index != 0) {
1350         classfile_parse_error(&quot;Duplicate ConstantValue attribute in class file %s&quot;, CHECK);
1351       }
1352       check_property(
1353         attribute_length == 2,
1354         &quot;Invalid ConstantValue field attribute length %u in class file %s&quot;,
1355         attribute_length, CHECK);
1356 
1357       constantvalue_index = cfs-&gt;get_u2(CHECK);
1358       if (_need_verify) {
1359         verify_constantvalue(cp, constantvalue_index, signature_index, CHECK);
1360       }
1361     } else if (attribute_name == vmSymbols::tag_synthetic()) {
1362       if (attribute_length != 0) {
1363         classfile_parse_error(
1364           &quot;Invalid Synthetic field attribute length %u in class file %s&quot;,
1365           attribute_length, CHECK);
1366       }
1367       is_synthetic = true;
1368     } else if (attribute_name == vmSymbols::tag_deprecated()) { // 4276120
1369       if (attribute_length != 0) {
1370         classfile_parse_error(
1371           &quot;Invalid Deprecated field attribute length %u in class file %s&quot;,
1372           attribute_length, CHECK);
1373       }
1374     } else if (_major_version &gt;= JAVA_1_5_VERSION) {
1375       if (attribute_name == vmSymbols::tag_signature()) {
1376         if (generic_signature_index != 0) {
1377           classfile_parse_error(
1378             &quot;Multiple Signature attributes for field in class file %s&quot;, CHECK);
1379         }
1380         if (attribute_length != 2) {
1381           classfile_parse_error(
1382             &quot;Wrong size %u for field&#39;s Signature attribute in class file %s&quot;,
1383             attribute_length, CHECK);
1384         }
1385         generic_signature_index = parse_generic_signature_attribute(cfs, CHECK);
1386       } else if (attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
1387         if (runtime_visible_annotations != NULL) {
1388           classfile_parse_error(
1389             &quot;Multiple RuntimeVisibleAnnotations attributes for field in class file %s&quot;, CHECK);
1390         }
1391         runtime_visible_annotations_length = attribute_length;
1392         runtime_visible_annotations = cfs-&gt;current();
1393         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
1394         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK);
1395         parse_annotations(cp,
1396                           runtime_visible_annotations,
1397                           runtime_visible_annotations_length,
1398                           parsed_annotations,
1399                           _loader_data,
1400                           _can_access_vm_annotations,
1401                           CHECK);
1402         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
1403       } else if (attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
1404         if (runtime_invisible_annotations_exists) {
1405           classfile_parse_error(
1406             &quot;Multiple RuntimeInvisibleAnnotations attributes for field in class file %s&quot;, CHECK);
1407         }
1408         runtime_invisible_annotations_exists = true;
1409         if (PreserveAllAnnotations) {
1410           runtime_invisible_annotations_length = attribute_length;
1411           runtime_invisible_annotations = cfs-&gt;current();
1412           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
1413         }
1414         cfs-&gt;skip_u1(attribute_length, CHECK);
1415       } else if (attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {
1416         if (runtime_visible_type_annotations != NULL) {
1417           classfile_parse_error(
1418             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for field in class file %s&quot;, CHECK);
1419         }
1420         runtime_visible_type_annotations_length = attribute_length;
1421         runtime_visible_type_annotations = cfs-&gt;current();
1422         assert(runtime_visible_type_annotations != NULL, &quot;null visible type annotations&quot;);
1423         cfs-&gt;skip_u1(runtime_visible_type_annotations_length, CHECK);
1424       } else if (attribute_name == vmSymbols::tag_runtime_invisible_type_annotations()) {
1425         if (runtime_invisible_type_annotations_exists) {
1426           classfile_parse_error(
1427             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes for field in class file %s&quot;, CHECK);
1428         } else {
1429           runtime_invisible_type_annotations_exists = true;
1430         }
1431         if (PreserveAllAnnotations) {
1432           runtime_invisible_type_annotations_length = attribute_length;
1433           runtime_invisible_type_annotations = cfs-&gt;current();
1434           assert(runtime_invisible_type_annotations != NULL, &quot;null invisible type annotations&quot;);
1435         }
1436         cfs-&gt;skip_u1(attribute_length, CHECK);
1437       } else {
1438         cfs-&gt;skip_u1(attribute_length, CHECK);  // Skip unknown attributes
1439       }
1440     } else {
1441       cfs-&gt;skip_u1(attribute_length, CHECK);  // Skip unknown attributes
1442     }
1443   }
1444 
1445   *constantvalue_index_addr = constantvalue_index;
1446   *is_synthetic_addr = is_synthetic;
1447   *generic_signature_index_addr = generic_signature_index;
1448   AnnotationArray* a = assemble_annotations(runtime_visible_annotations,
1449                                             runtime_visible_annotations_length,
1450                                             runtime_invisible_annotations,
1451                                             runtime_invisible_annotations_length,
1452                                             CHECK);
1453   parsed_annotations-&gt;set_field_annotations(a);
1454   a = assemble_annotations(runtime_visible_type_annotations,
1455                            runtime_visible_type_annotations_length,
1456                            runtime_invisible_type_annotations,
1457                            runtime_invisible_type_annotations_length,
1458                            CHECK);
1459   parsed_annotations-&gt;set_field_type_annotations(a);
1460   return;
1461 }
1462 
1463 
1464 // Field allocation types. Used for computing field offsets.
1465 
1466 enum FieldAllocationType {
1467   STATIC_OOP,           // Oops
1468   STATIC_BYTE,          // Boolean, Byte, char
1469   STATIC_SHORT,         // shorts
1470   STATIC_WORD,          // ints
1471   STATIC_DOUBLE,        // aligned long or double
<a name="17" id="anc17"></a>
1472   NONSTATIC_OOP,
1473   NONSTATIC_BYTE,
1474   NONSTATIC_SHORT,
1475   NONSTATIC_WORD,
1476   NONSTATIC_DOUBLE,
<a name="18" id="anc18"></a>
1477   MAX_FIELD_ALLOCATION_TYPE,
1478   BAD_ALLOCATION_TYPE = -1
1479 };
1480 
1481 static FieldAllocationType _basic_type_to_atype[2 * (T_CONFLICT + 1)] = {
1482   BAD_ALLOCATION_TYPE, // 0
1483   BAD_ALLOCATION_TYPE, // 1
1484   BAD_ALLOCATION_TYPE, // 2
1485   BAD_ALLOCATION_TYPE, // 3
1486   NONSTATIC_BYTE ,     // T_BOOLEAN     =  4,
1487   NONSTATIC_SHORT,     // T_CHAR        =  5,
1488   NONSTATIC_WORD,      // T_FLOAT       =  6,
1489   NONSTATIC_DOUBLE,    // T_DOUBLE      =  7,
1490   NONSTATIC_BYTE,      // T_BYTE        =  8,
1491   NONSTATIC_SHORT,     // T_SHORT       =  9,
1492   NONSTATIC_WORD,      // T_INT         = 10,
1493   NONSTATIC_DOUBLE,    // T_LONG        = 11,
1494   NONSTATIC_OOP,       // T_OBJECT      = 12,
1495   NONSTATIC_OOP,       // T_ARRAY       = 13,
<a name="19" id="anc19"></a><span class="line-modified">1496   BAD_ALLOCATION_TYPE, // T_VOID        = 14,</span>
<span class="line-modified">1497   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 15,</span>
<span class="line-modified">1498   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 16,</span>
<span class="line-modified">1499   BAD_ALLOCATION_TYPE, // T_METADATA    = 17,</span>
<span class="line-modified">1500   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 18,</span>
<span class="line-modified">1501   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 19,</span>

1502   BAD_ALLOCATION_TYPE, // 0
1503   BAD_ALLOCATION_TYPE, // 1
1504   BAD_ALLOCATION_TYPE, // 2
1505   BAD_ALLOCATION_TYPE, // 3
1506   STATIC_BYTE ,        // T_BOOLEAN     =  4,
1507   STATIC_SHORT,        // T_CHAR        =  5,
1508   STATIC_WORD,         // T_FLOAT       =  6,
1509   STATIC_DOUBLE,       // T_DOUBLE      =  7,
1510   STATIC_BYTE,         // T_BYTE        =  8,
1511   STATIC_SHORT,        // T_SHORT       =  9,
1512   STATIC_WORD,         // T_INT         = 10,
1513   STATIC_DOUBLE,       // T_LONG        = 11,
1514   STATIC_OOP,          // T_OBJECT      = 12,
1515   STATIC_OOP,          // T_ARRAY       = 13,
<a name="20" id="anc20"></a><span class="line-modified">1516   BAD_ALLOCATION_TYPE, // T_VOID        = 14,</span>
<span class="line-modified">1517   BAD_ALLOCATION_TYPE, // T_ADDRESS     = 15,</span>
<span class="line-modified">1518   BAD_ALLOCATION_TYPE, // T_NARROWOOP   = 16,</span>
<span class="line-modified">1519   BAD_ALLOCATION_TYPE, // T_METADATA    = 17,</span>
<span class="line-modified">1520   BAD_ALLOCATION_TYPE, // T_NARROWKLASS = 18,</span>
<span class="line-modified">1521   BAD_ALLOCATION_TYPE, // T_CONFLICT    = 19,</span>

1522 };
1523 
<a name="21" id="anc21"></a><span class="line-modified">1524 static FieldAllocationType basic_type_to_atype(bool is_static, BasicType type) {</span>
1525   assert(type &gt;= T_BOOLEAN &amp;&amp; type &lt; T_VOID, &quot;only allowable values&quot;);
1526   FieldAllocationType result = _basic_type_to_atype[type + (is_static ? (T_CONFLICT + 1) : 0)];
1527   assert(result != BAD_ALLOCATION_TYPE, &quot;bad type&quot;);
<a name="22" id="anc22"></a>


1528   return result;
1529 }
1530 
1531 class ClassFileParser::FieldAllocationCount : public ResourceObj {
1532  public:
1533   u2 count[MAX_FIELD_ALLOCATION_TYPE];
1534 
1535   FieldAllocationCount() {
1536     for (int i = 0; i &lt; MAX_FIELD_ALLOCATION_TYPE; i++) {
1537       count[i] = 0;
1538     }
1539   }
1540 
<a name="23" id="anc23"></a><span class="line-modified">1541   FieldAllocationType update(bool is_static, BasicType type) {</span>
<span class="line-modified">1542     FieldAllocationType atype = basic_type_to_atype(is_static, type);</span>
1543     if (atype != BAD_ALLOCATION_TYPE) {
1544       // Make sure there is no overflow with injected fields.
1545       assert(count[atype] &lt; 0xFFFF, &quot;More than 65535 fields&quot;);
1546       count[atype]++;
1547     }
1548     return atype;
1549   }
1550 };
1551 
1552 // Side-effects: populates the _fields, _fields_annotations,
1553 // _fields_type_annotations fields
1554 void ClassFileParser::parse_fields(const ClassFileStream* const cfs,
1555                                    bool is_interface,
<a name="24" id="anc24"></a>
1556                                    FieldAllocationCount* const fac,
1557                                    ConstantPool* cp,
1558                                    const int cp_size,
1559                                    u2* const java_fields_count_ptr,
1560                                    TRAPS) {
1561 
1562   assert(cfs != NULL, &quot;invariant&quot;);
1563   assert(fac != NULL, &quot;invariant&quot;);
1564   assert(cp != NULL, &quot;invariant&quot;);
1565   assert(java_fields_count_ptr != NULL, &quot;invariant&quot;);
1566 
1567   assert(NULL == _fields, &quot;invariant&quot;);
1568   assert(NULL == _fields_annotations, &quot;invariant&quot;);
1569   assert(NULL == _fields_type_annotations, &quot;invariant&quot;);
1570 
1571   cfs-&gt;guarantee_more(2, CHECK);  // length
1572   const u2 length = cfs-&gt;get_u2_fast();
1573   *java_fields_count_ptr = length;
1574 
1575   int num_injected = 0;
1576   const InjectedField* const injected = JavaClasses::get_injected(_class_name,
1577                                                                   &amp;num_injected);
<a name="25" id="anc25"></a><span class="line-modified">1578   const int total_fields = length + num_injected;</span>




1579 
1580   // The field array starts with tuples of shorts
1581   // [access, name index, sig index, initial value index, byte offset].
1582   // A generic signature slot only exists for field with generic
1583   // signature attribute. And the access flag is set with
1584   // JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE for that field. The generic
1585   // signature slots are at the end of the field array and after all
1586   // other fields data.
1587   //
1588   //   f1: [access, name index, sig index, initial value index, low_offset, high_offset]
1589   //   f2: [access, name index, sig index, initial value index, low_offset, high_offset]
1590   //       ...
1591   //   fn: [access, name index, sig index, initial value index, low_offset, high_offset]
1592   //       [generic signature index]
1593   //       [generic signature index]
1594   //       ...
1595   //
1596   // Allocate a temporary resource array for field data. For each field,
1597   // a slot is reserved in the temporary array for the generic signature
1598   // index. After parsing all fields, the data are copied to a permanent
1599   // array and any unused slots will be discarded.
1600   ResourceMark rm(THREAD);
1601   u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,
1602                                               u2,
1603                                               total_fields * (FieldInfo::field_slots + 1));
1604 
1605   // The generic signature slots start after all other fields&#39; data.
1606   int generic_signature_slot = total_fields * FieldInfo::field_slots;
1607   int num_generic_signature = 0;
<a name="26" id="anc26"></a>
1608   for (int n = 0; n &lt; length; n++) {
1609     // access_flags, name_index, descriptor_index, attributes_count
1610     cfs-&gt;guarantee_more(8, CHECK);
1611 
<a name="27" id="anc27"></a>



1612     AccessFlags access_flags;
<a name="28" id="anc28"></a><span class="line-removed">1613     const jint flags = cfs-&gt;get_u2_fast() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;</span>
<span class="line-removed">1614     verify_legal_field_modifiers(flags, is_interface, CHECK);</span>
1615     access_flags.set_flags(flags);
1616 
1617     const u2 name_index = cfs-&gt;get_u2_fast();
1618     check_property(valid_symbol_at(name_index),
1619       &quot;Invalid constant pool index %u for field name in class file %s&quot;,
1620       name_index, CHECK);
1621     const Symbol* const name = cp-&gt;symbol_at(name_index);
1622     verify_legal_field_name(name, CHECK);
1623 
1624     const u2 signature_index = cfs-&gt;get_u2_fast();
1625     check_property(valid_symbol_at(signature_index),
1626       &quot;Invalid constant pool index %u for field signature in class file %s&quot;,
1627       signature_index, CHECK);
1628     const Symbol* const sig = cp-&gt;symbol_at(signature_index);
1629     verify_legal_field_signature(name, sig, CHECK);
<a name="29" id="anc29"></a>
















1630 
1631     u2 constantvalue_index = 0;
1632     bool is_synthetic = false;
1633     u2 generic_signature_index = 0;
1634     const bool is_static = access_flags.is_static();
1635     FieldAnnotationCollector parsed_annotations(_loader_data);
1636 
1637     const u2 attributes_count = cfs-&gt;get_u2_fast();
1638     if (attributes_count &gt; 0) {
1639       parse_field_attributes(cfs,
1640                              attributes_count,
1641                              is_static,
1642                              signature_index,
1643                              &amp;constantvalue_index,
1644                              &amp;is_synthetic,
1645                              &amp;generic_signature_index,
1646                              &amp;parsed_annotations,
1647                              CHECK);
1648 
1649       if (parsed_annotations.field_annotations() != NULL) {
1650         if (_fields_annotations == NULL) {
1651           _fields_annotations = MetadataFactory::new_array&lt;AnnotationArray*&gt;(
1652                                              _loader_data, length, NULL,
1653                                              CHECK);
1654         }
1655         _fields_annotations-&gt;at_put(n, parsed_annotations.field_annotations());
1656         parsed_annotations.set_field_annotations(NULL);
1657       }
1658       if (parsed_annotations.field_type_annotations() != NULL) {
1659         if (_fields_type_annotations == NULL) {
1660           _fields_type_annotations =
1661             MetadataFactory::new_array&lt;AnnotationArray*&gt;(_loader_data,
1662                                                          length,
1663                                                          NULL,
1664                                                          CHECK);
1665         }
1666         _fields_type_annotations-&gt;at_put(n, parsed_annotations.field_type_annotations());
1667         parsed_annotations.set_field_type_annotations(NULL);
1668       }
1669 
1670       if (is_synthetic) {
1671         access_flags.set_is_synthetic();
1672       }
1673       if (generic_signature_index != 0) {
1674         access_flags.set_field_has_generic_signature();
1675         fa[generic_signature_slot] = generic_signature_index;
1676         generic_signature_slot ++;
1677         num_generic_signature ++;
1678       }
1679     }
1680 
1681     FieldInfo* const field = FieldInfo::from_field_array(fa, n);
1682     field-&gt;initialize(access_flags.as_short(),
1683                       name_index,
1684                       signature_index,
1685                       constantvalue_index);
1686     const BasicType type = cp-&gt;basic_type_for_signature_at(signature_index);
1687 
1688     // Remember how many oops we encountered and compute allocation type
<a name="30" id="anc30"></a><span class="line-modified">1689     const FieldAllocationType atype = fac-&gt;update(is_static, type);</span>
1690     field-&gt;set_allocation_type(atype);
1691 
1692     // After field is initialized with type, we can augment it with aux info
1693     if (parsed_annotations.has_any_annotations()) {
1694       parsed_annotations.apply_to(field);
1695       if (field-&gt;is_contended()) {
1696         _has_contended_fields = true;
1697       }
1698     }
1699   }
1700 
1701   int index = length;
1702   if (num_injected != 0) {
1703     for (int n = 0; n &lt; num_injected; n++) {
1704       // Check for duplicates
1705       if (injected[n].may_be_java) {
1706         const Symbol* const name      = injected[n].name();
1707         const Symbol* const signature = injected[n].signature();
1708         bool duplicate = false;
1709         for (int i = 0; i &lt; length; i++) {
1710           const FieldInfo* const f = FieldInfo::from_field_array(fa, i);
1711           if (name      == cp-&gt;symbol_at(f-&gt;name_index()) &amp;&amp;
1712               signature == cp-&gt;symbol_at(f-&gt;signature_index())) {
1713             // Symbol is desclared in Java so skip this one
1714             duplicate = true;
1715             break;
1716           }
1717         }
1718         if (duplicate) {
1719           // These will be removed from the field array at the end
1720           continue;
1721         }
1722       }
1723 
1724       // Injected field
1725       FieldInfo* const field = FieldInfo::from_field_array(fa, index);
1726       field-&gt;initialize(JVM_ACC_FIELD_INTERNAL,
1727                         injected[n].name_index,
1728                         injected[n].signature_index,
1729                         0);
1730 
1731       const BasicType type = Signature::basic_type(injected[n].signature());
1732 
1733       // Remember how many oops we encountered and compute allocation type
<a name="31" id="anc31"></a><span class="line-modified">1734       const FieldAllocationType atype = fac-&gt;update(false, type);</span>
1735       field-&gt;set_allocation_type(atype);
1736       index++;
1737     }
1738   }
1739 
<a name="32" id="anc32"></a>




























1740   assert(NULL == _fields, &quot;invariant&quot;);
1741 
1742   _fields =
1743     MetadataFactory::new_array&lt;u2&gt;(_loader_data,
1744                                    index * FieldInfo::field_slots + num_generic_signature,
1745                                    CHECK);
1746   // Sometimes injected fields already exist in the Java source so
1747   // the fields array could be too long.  In that case the
1748   // fields array is trimed. Also unused slots that were reserved
1749   // for generic signature indexes are discarded.
1750   {
1751     int i = 0;
1752     for (; i &lt; index * FieldInfo::field_slots; i++) {
1753       _fields-&gt;at_put(i, fa[i]);
1754     }
1755     for (int j = total_fields * FieldInfo::field_slots;
1756          j &lt; generic_signature_slot; j++) {
1757       _fields-&gt;at_put(i++, fa[j]);
1758     }
1759     assert(_fields-&gt;length() == i, &quot;&quot;);
1760   }
1761 
1762   if (_need_verify &amp;&amp; length &gt; 1) {
1763     // Check duplicated fields
1764     ResourceMark rm(THREAD);
1765     NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
1766       THREAD, NameSigHash*, HASH_ROW_SIZE);
1767     initialize_hashtable(names_and_sigs);
1768     bool dup = false;
1769     const Symbol* name = NULL;
1770     const Symbol* sig = NULL;
1771     {
1772       debug_only(NoSafepointVerifier nsv;)
1773       for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
1774         name = fs.name();
1775         sig = fs.signature();
1776         // If no duplicates, add name/signature in hashtable names_and_sigs.
1777         if (!put_after_lookup(name, sig, names_and_sigs)) {
1778           dup = true;
1779           break;
1780         }
1781       }
1782     }
1783     if (dup) {
1784       classfile_parse_error(&quot;Duplicate field name \&quot;%s\&quot; with signature \&quot;%s\&quot; in class file %s&quot;,
1785                              name-&gt;as_C_string(), sig-&gt;as_klass_external_name(), CHECK);
1786     }
1787   }
1788 }
1789 
1790 
1791 const ClassFileParser::unsafe_u2* ClassFileParser::parse_exception_table(const ClassFileStream* const cfs,
1792                                                                          u4 code_length,
1793                                                                          u4 exception_table_length,
1794                                                                          TRAPS) {
1795   assert(cfs != NULL, &quot;invariant&quot;);
1796 
1797   const unsafe_u2* const exception_table_start = cfs-&gt;current();
1798   assert(exception_table_start != NULL, &quot;null exception table&quot;);
1799 
1800   cfs-&gt;guarantee_more(8 * exception_table_length, CHECK_NULL); // start_pc,
1801                                                                // end_pc,
1802                                                                // handler_pc,
1803                                                                // catch_type_index
1804 
1805   // Will check legal target after parsing code array in verifier.
1806   if (_need_verify) {
1807     for (unsigned int i = 0; i &lt; exception_table_length; i++) {
1808       const u2 start_pc = cfs-&gt;get_u2_fast();
1809       const u2 end_pc = cfs-&gt;get_u2_fast();
1810       const u2 handler_pc = cfs-&gt;get_u2_fast();
1811       const u2 catch_type_index = cfs-&gt;get_u2_fast();
1812       guarantee_property((start_pc &lt; end_pc) &amp;&amp; (end_pc &lt;= code_length),
1813                          &quot;Illegal exception table range in class file %s&quot;,
1814                          CHECK_NULL);
1815       guarantee_property(handler_pc &lt; code_length,
1816                          &quot;Illegal exception table handler in class file %s&quot;,
1817                          CHECK_NULL);
1818       if (catch_type_index != 0) {
1819         guarantee_property(valid_klass_reference_at(catch_type_index),
1820                            &quot;Catch type in exception table has bad constant type in class file %s&quot;, CHECK_NULL);
1821       }
1822     }
1823   } else {
1824     cfs-&gt;skip_u2_fast(exception_table_length * 4);
1825   }
1826   return exception_table_start;
1827 }
1828 
1829 void ClassFileParser::parse_linenumber_table(u4 code_attribute_length,
1830                                              u4 code_length,
1831                                              CompressedLineNumberWriteStream**const write_stream,
1832                                              TRAPS) {
1833 
1834   const ClassFileStream* const cfs = _stream;
1835   unsigned int num_entries = cfs-&gt;get_u2(CHECK);
1836 
1837   // Each entry is a u2 start_pc, and a u2 line_number
1838   const unsigned int length_in_bytes = num_entries * (sizeof(u2) * 2);
1839 
1840   // Verify line number attribute and table length
1841   check_property(
1842     code_attribute_length == sizeof(u2) + length_in_bytes,
1843     &quot;LineNumberTable attribute has wrong length in class file %s&quot;, CHECK);
1844 
1845   cfs-&gt;guarantee_more(length_in_bytes, CHECK);
1846 
1847   if ((*write_stream) == NULL) {
1848     if (length_in_bytes &gt; fixed_buffer_size) {
1849       (*write_stream) = new CompressedLineNumberWriteStream(length_in_bytes);
1850     } else {
1851       (*write_stream) = new CompressedLineNumberWriteStream(
1852         _linenumbertable_buffer, fixed_buffer_size);
1853     }
1854   }
1855 
1856   while (num_entries-- &gt; 0) {
1857     const u2 bci  = cfs-&gt;get_u2_fast(); // start_pc
1858     const u2 line = cfs-&gt;get_u2_fast(); // line_number
1859     guarantee_property(bci &lt; code_length,
1860         &quot;Invalid pc in LineNumberTable in class file %s&quot;, CHECK);
1861     (*write_stream)-&gt;write_pair(bci, line);
1862   }
1863 }
1864 
1865 
1866 class LVT_Hash : public AllStatic {
1867  public:
1868 
1869   static bool equals(LocalVariableTableElement const&amp; e0, LocalVariableTableElement const&amp; e1) {
1870   /*
1871    * 3-tuple start_bci/length/slot has to be unique key,
1872    * so the following comparison seems to be redundant:
1873    *       &amp;&amp; elem-&gt;name_cp_index == entry-&gt;_elem-&gt;name_cp_index
1874    */
1875     return (e0.start_bci     == e1.start_bci &amp;&amp;
1876             e0.length        == e1.length &amp;&amp;
1877             e0.name_cp_index == e1.name_cp_index &amp;&amp;
1878             e0.slot          == e1.slot);
1879   }
1880 
1881   static unsigned int hash(LocalVariableTableElement const&amp; e0) {
1882     unsigned int raw_hash = e0.start_bci;
1883 
1884     raw_hash = e0.length        + raw_hash * 37;
1885     raw_hash = e0.name_cp_index + raw_hash * 37;
1886     raw_hash = e0.slot          + raw_hash * 37;
1887 
1888     return raw_hash;
1889   }
1890 };
1891 
1892 
1893 // Class file LocalVariableTable elements.
1894 class Classfile_LVT_Element {
1895  public:
1896   u2 start_bci;
1897   u2 length;
1898   u2 name_cp_index;
1899   u2 descriptor_cp_index;
1900   u2 slot;
1901 };
1902 
1903 static void copy_lvt_element(const Classfile_LVT_Element* const src,
1904                              LocalVariableTableElement* const lvt) {
1905   lvt-&gt;start_bci           = Bytes::get_Java_u2((u1*) &amp;src-&gt;start_bci);
1906   lvt-&gt;length              = Bytes::get_Java_u2((u1*) &amp;src-&gt;length);
1907   lvt-&gt;name_cp_index       = Bytes::get_Java_u2((u1*) &amp;src-&gt;name_cp_index);
1908   lvt-&gt;descriptor_cp_index = Bytes::get_Java_u2((u1*) &amp;src-&gt;descriptor_cp_index);
1909   lvt-&gt;signature_cp_index  = 0;
1910   lvt-&gt;slot                = Bytes::get_Java_u2((u1*) &amp;src-&gt;slot);
1911 }
1912 
1913 // Function is used to parse both attributes:
1914 // LocalVariableTable (LVT) and LocalVariableTypeTable (LVTT)
1915 const ClassFileParser::unsafe_u2* ClassFileParser::parse_localvariable_table(const ClassFileStream* cfs,
1916                                                                              u4 code_length,
1917                                                                              u2 max_locals,
1918                                                                              u4 code_attribute_length,
1919                                                                              u2* const localvariable_table_length,
1920                                                                              bool isLVTT,
1921                                                                              TRAPS) {
1922   const char* const tbl_name = (isLVTT) ? &quot;LocalVariableTypeTable&quot; : &quot;LocalVariableTable&quot;;
1923   *localvariable_table_length = cfs-&gt;get_u2(CHECK_NULL);
1924   const unsigned int size =
1925     (*localvariable_table_length) * sizeof(Classfile_LVT_Element) / sizeof(u2);
1926 
1927   const ConstantPool* const cp = _cp;
1928 
1929   // Verify local variable table attribute has right length
1930   if (_need_verify) {
1931     guarantee_property(code_attribute_length == (sizeof(*localvariable_table_length) + size * sizeof(u2)),
1932                        &quot;%s has wrong length in class file %s&quot;, tbl_name, CHECK_NULL);
1933   }
1934 
1935   const unsafe_u2* const localvariable_table_start = cfs-&gt;current();
1936   assert(localvariable_table_start != NULL, &quot;null local variable table&quot;);
1937   if (!_need_verify) {
1938     cfs-&gt;skip_u2_fast(size);
1939   } else {
1940     cfs-&gt;guarantee_more(size * 2, CHECK_NULL);
1941     for(int i = 0; i &lt; (*localvariable_table_length); i++) {
1942       const u2 start_pc = cfs-&gt;get_u2_fast();
1943       const u2 length = cfs-&gt;get_u2_fast();
1944       const u2 name_index = cfs-&gt;get_u2_fast();
1945       const u2 descriptor_index = cfs-&gt;get_u2_fast();
1946       const u2 index = cfs-&gt;get_u2_fast();
1947       // Assign to a u4 to avoid overflow
1948       const u4 end_pc = (u4)start_pc + (u4)length;
1949 
1950       if (start_pc &gt;= code_length) {
1951         classfile_parse_error(
1952           &quot;Invalid start_pc %u in %s in class file %s&quot;,
1953           start_pc, tbl_name, CHECK_NULL);
1954       }
1955       if (end_pc &gt; code_length) {
1956         classfile_parse_error(
1957           &quot;Invalid length %u in %s in class file %s&quot;,
1958           length, tbl_name, CHECK_NULL);
1959       }
1960       const int cp_size = cp-&gt;length();
1961       guarantee_property(valid_symbol_at(name_index),
1962         &quot;Name index %u in %s has bad constant type in class file %s&quot;,
1963         name_index, tbl_name, CHECK_NULL);
1964       guarantee_property(valid_symbol_at(descriptor_index),
1965         &quot;Signature index %u in %s has bad constant type in class file %s&quot;,
1966         descriptor_index, tbl_name, CHECK_NULL);
1967 
1968       const Symbol* const name = cp-&gt;symbol_at(name_index);
1969       const Symbol* const sig = cp-&gt;symbol_at(descriptor_index);
1970       verify_legal_field_name(name, CHECK_NULL);
1971       u2 extra_slot = 0;
1972       if (!isLVTT) {
1973         verify_legal_field_signature(name, sig, CHECK_NULL);
1974 
1975         // 4894874: check special cases for double and long local variables
1976         if (sig == vmSymbols::type_signature(T_DOUBLE) ||
1977             sig == vmSymbols::type_signature(T_LONG)) {
1978           extra_slot = 1;
1979         }
1980       }
1981       guarantee_property((index + extra_slot) &lt; max_locals,
1982                           &quot;Invalid index %u in %s in class file %s&quot;,
1983                           index, tbl_name, CHECK_NULL);
1984     }
1985   }
1986   return localvariable_table_start;
1987 }
1988 
1989 static const u1* parse_stackmap_table(const ClassFileStream* const cfs,
1990                                       u4 code_attribute_length,
1991                                       bool need_verify,
1992                                       TRAPS) {
1993   assert(cfs != NULL, &quot;invariant&quot;);
1994 
1995   if (0 == code_attribute_length) {
1996     return NULL;
1997   }
1998 
1999   const u1* const stackmap_table_start = cfs-&gt;current();
2000   assert(stackmap_table_start != NULL, &quot;null stackmap table&quot;);
2001 
2002   // check code_attribute_length first
2003   cfs-&gt;skip_u1(code_attribute_length, CHECK_NULL);
2004 
2005   if (!need_verify &amp;&amp; !DumpSharedSpaces) {
2006     return NULL;
2007   }
2008   return stackmap_table_start;
2009 }
2010 
2011 const ClassFileParser::unsafe_u2* ClassFileParser::parse_checked_exceptions(const ClassFileStream* const cfs,
2012                                                                             u2* const checked_exceptions_length,
2013                                                                             u4 method_attribute_length,
2014                                                                             TRAPS) {
2015   assert(cfs != NULL, &quot;invariant&quot;);
2016   assert(checked_exceptions_length != NULL, &quot;invariant&quot;);
2017 
2018   cfs-&gt;guarantee_more(2, CHECK_NULL);  // checked_exceptions_length
2019   *checked_exceptions_length = cfs-&gt;get_u2_fast();
2020   const unsigned int size =
2021     (*checked_exceptions_length) * sizeof(CheckedExceptionElement) / sizeof(u2);
2022   const unsafe_u2* const checked_exceptions_start = cfs-&gt;current();
2023   assert(checked_exceptions_start != NULL, &quot;null checked exceptions&quot;);
2024   if (!_need_verify) {
2025     cfs-&gt;skip_u2_fast(size);
2026   } else {
2027     // Verify each value in the checked exception table
2028     u2 checked_exception;
2029     const u2 len = *checked_exceptions_length;
2030     cfs-&gt;guarantee_more(2 * len, CHECK_NULL);
2031     for (int i = 0; i &lt; len; i++) {
2032       checked_exception = cfs-&gt;get_u2_fast();
2033       check_property(
2034         valid_klass_reference_at(checked_exception),
2035         &quot;Exception name has bad type at constant pool %u in class file %s&quot;,
2036         checked_exception, CHECK_NULL);
2037     }
2038   }
2039   // check exceptions attribute length
2040   if (_need_verify) {
2041     guarantee_property(method_attribute_length == (sizeof(*checked_exceptions_length) +
2042                                                    sizeof(u2) * size),
2043                       &quot;Exceptions attribute has wrong length in class file %s&quot;, CHECK_NULL);
2044   }
2045   return checked_exceptions_start;
2046 }
2047 
2048 void ClassFileParser::throwIllegalSignature(const char* type,
2049                                             const Symbol* name,
2050                                             const Symbol* sig,
2051                                             TRAPS) const {
2052   assert(name != NULL, &quot;invariant&quot;);
2053   assert(sig != NULL, &quot;invariant&quot;);
2054 
<a name="33" id="anc33"></a>




2055   ResourceMark rm(THREAD);
2056   Exceptions::fthrow(THREAD_AND_LOCATION,
2057       vmSymbols::java_lang_ClassFormatError(),
<a name="34" id="anc34"></a><span class="line-modified">2058       &quot;%s \&quot;%s\&quot; in class %s has illegal signature \&quot;%s\&quot;&quot;, type,</span>
<span class="line-modified">2059       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), sig-&gt;as_C_string());</span>
2060 }
2061 
2062 AnnotationCollector::ID
2063 AnnotationCollector::annotation_index(const ClassLoaderData* loader_data,
2064                                       const Symbol* name,
2065                                       const bool can_access_vm_annotations) {
2066   const vmSymbols::SID sid = vmSymbols::find_sid(name);
2067   // Privileged code can use all annotations.  Other code silently drops some.
2068   const bool privileged = loader_data-&gt;is_boot_class_loader_data() ||
2069                           loader_data-&gt;is_platform_class_loader_data() ||
2070                           can_access_vm_annotations;
2071   switch (sid) {
2072     case vmSymbols::VM_SYMBOL_ENUM_NAME(reflect_CallerSensitive_signature): {
2073       if (_location != _in_method)  break;  // only allow for methods
2074       if (!privileged)              break;  // only allow in privileged code
2075       return _method_CallerSensitive;
2076     }
2077     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ForceInline_signature): {
2078       if (_location != _in_method)  break;  // only allow for methods
2079       if (!privileged)              break;  // only allow in privileged code
2080       return _method_ForceInline;
2081     }
2082     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_DontInline_signature): {
2083       if (_location != _in_method)  break;  // only allow for methods
2084       if (!privileged)              break;  // only allow in privileged code
2085       return _method_DontInline;
2086     }
2087     case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_InjectedProfile_signature): {
2088       if (_location != _in_method)  break;  // only allow for methods
2089       if (!privileged)              break;  // only allow in privileged code
2090       return _method_InjectedProfile;
2091     }
2092     case vmSymbols::VM_SYMBOL_ENUM_NAME(java_lang_invoke_LambdaForm_Compiled_signature): {
2093       if (_location != _in_method)  break;  // only allow for methods
2094       if (!privileged)              break;  // only allow in privileged code
2095       return _method_LambdaForm_Compiled;
2096     }
2097     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Hidden_signature): {
2098       if (_location != _in_method)  break;  // only allow for methods
2099       if (!privileged)              break;  // only allow in privileged code
2100       return _method_Hidden;
2101     }
2102     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_HotSpotIntrinsicCandidate_signature): {
2103       if (_location != _in_method)  break;  // only allow for methods
2104       if (!privileged)              break;  // only allow in privileged code
2105       return _method_HotSpotIntrinsicCandidate;
2106     }
2107     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Stable_signature): {
2108       if (_location != _in_field)   break;  // only allow for fields
2109       if (!privileged)              break;  // only allow in privileged code
2110       return _field_Stable;
2111     }
2112     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_Contended_signature): {
2113       if (_location != _in_field &amp;&amp; _location != _in_class) {
2114         break;  // only allow for fields and classes
2115       }
2116       if (!EnableContended || (RestrictContended &amp;&amp; !privileged)) {
2117         break;  // honor privileges
2118       }
2119       return _jdk_internal_vm_annotation_Contended;
2120     }
2121     case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_vm_annotation_ReservedStackAccess_signature): {
2122       if (_location != _in_method)  break;  // only allow for methods
2123       if (RestrictReservedStack &amp;&amp; !privileged) break; // honor privileges
2124       return _jdk_internal_vm_annotation_ReservedStackAccess;
2125     }
2126     default: {
2127       break;
2128     }
2129   }
2130   return AnnotationCollector::_unknown;
2131 }
2132 
2133 void ClassFileParser::FieldAnnotationCollector::apply_to(FieldInfo* f) {
2134   if (is_contended())
2135     f-&gt;set_contended_group(contended_group());
2136   if (is_stable())
2137     f-&gt;set_stable(true);
2138 }
2139 
2140 ClassFileParser::FieldAnnotationCollector::~FieldAnnotationCollector() {
2141   // If there&#39;s an error deallocate metadata for field annotations
2142   MetadataFactory::free_array&lt;u1&gt;(_loader_data, _field_annotations);
2143   MetadataFactory::free_array&lt;u1&gt;(_loader_data, _field_type_annotations);
2144 }
2145 
2146 void MethodAnnotationCollector::apply_to(const methodHandle&amp; m) {
2147   if (has_annotation(_method_CallerSensitive))
2148     m-&gt;set_caller_sensitive(true);
2149   if (has_annotation(_method_ForceInline))
2150     m-&gt;set_force_inline(true);
2151   if (has_annotation(_method_DontInline))
2152     m-&gt;set_dont_inline(true);
2153   if (has_annotation(_method_InjectedProfile))
2154     m-&gt;set_has_injected_profile(true);
2155   if (has_annotation(_method_LambdaForm_Compiled) &amp;&amp; m-&gt;intrinsic_id() == vmIntrinsics::_none)
2156     m-&gt;set_intrinsic_id(vmIntrinsics::_compiledLambdaForm);
2157   if (has_annotation(_method_Hidden))
2158     m-&gt;set_hidden(true);
2159   if (has_annotation(_method_HotSpotIntrinsicCandidate) &amp;&amp; !m-&gt;is_synthetic())
2160     m-&gt;set_intrinsic_candidate(true);
2161   if (has_annotation(_jdk_internal_vm_annotation_ReservedStackAccess))
2162     m-&gt;set_has_reserved_stack_access(true);
2163 }
2164 
2165 void ClassFileParser::ClassAnnotationCollector::apply_to(InstanceKlass* ik) {
2166   assert(ik != NULL, &quot;invariant&quot;);
2167   ik-&gt;set_is_contended(is_contended());
2168 }
2169 
2170 #define MAX_ARGS_SIZE 255
2171 #define MAX_CODE_SIZE 65535
2172 #define INITIAL_MAX_LVT_NUMBER 256
2173 
2174 /* Copy class file LVT&#39;s/LVTT&#39;s into the HotSpot internal LVT.
2175  *
2176  * Rules for LVT&#39;s and LVTT&#39;s are:
2177  *   - There can be any number of LVT&#39;s and LVTT&#39;s.
2178  *   - If there are n LVT&#39;s, it is the same as if there was just
2179  *     one LVT containing all the entries from the n LVT&#39;s.
2180  *   - There may be no more than one LVT entry per local variable.
2181  *     Two LVT entries are &#39;equal&#39; if these fields are the same:
2182  *        start_pc, length, name, slot
2183  *   - There may be no more than one LVTT entry per each LVT entry.
2184  *     Each LVTT entry has to match some LVT entry.
2185  *   - HotSpot internal LVT keeps natural ordering of class file LVT entries.
2186  */
2187 void ClassFileParser::copy_localvariable_table(const ConstMethod* cm,
2188                                                int lvt_cnt,
2189                                                u2* const localvariable_table_length,
2190                                                const unsafe_u2** const localvariable_table_start,
2191                                                int lvtt_cnt,
2192                                                u2* const localvariable_type_table_length,
2193                                                const unsafe_u2** const localvariable_type_table_start,
2194                                                TRAPS) {
2195 
2196   ResourceMark rm(THREAD);
2197 
2198   typedef ResourceHashtable&lt;LocalVariableTableElement, LocalVariableTableElement*,
2199                             &amp;LVT_Hash::hash, &amp;LVT_Hash::equals&gt; LVT_HashTable;
2200 
2201   LVT_HashTable* const table = new LVT_HashTable();
2202 
2203   // To fill LocalVariableTable in
2204   const Classfile_LVT_Element* cf_lvt;
2205   LocalVariableTableElement* lvt = cm-&gt;localvariable_table_start();
2206 
2207   for (int tbl_no = 0; tbl_no &lt; lvt_cnt; tbl_no++) {
2208     cf_lvt = (Classfile_LVT_Element *) localvariable_table_start[tbl_no];
2209     for (int idx = 0; idx &lt; localvariable_table_length[tbl_no]; idx++, lvt++) {
2210       copy_lvt_element(&amp;cf_lvt[idx], lvt);
2211       // If no duplicates, add LVT elem in hashtable.
2212       if (table-&gt;put(*lvt, lvt) == false
2213           &amp;&amp; _need_verify
2214           &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
2215         classfile_parse_error(&quot;Duplicated LocalVariableTable attribute &quot;
2216                               &quot;entry for &#39;%s&#39; in class file %s&quot;,
2217                                _cp-&gt;symbol_at(lvt-&gt;name_cp_index)-&gt;as_utf8(),
2218                                CHECK);
2219       }
2220     }
2221   }
2222 
2223   // To merge LocalVariableTable and LocalVariableTypeTable
2224   const Classfile_LVT_Element* cf_lvtt;
2225   LocalVariableTableElement lvtt_elem;
2226 
2227   for (int tbl_no = 0; tbl_no &lt; lvtt_cnt; tbl_no++) {
2228     cf_lvtt = (Classfile_LVT_Element *) localvariable_type_table_start[tbl_no];
2229     for (int idx = 0; idx &lt; localvariable_type_table_length[tbl_no]; idx++) {
2230       copy_lvt_element(&amp;cf_lvtt[idx], &amp;lvtt_elem);
2231       LocalVariableTableElement** entry = table-&gt;get(lvtt_elem);
2232       if (entry == NULL) {
2233         if (_need_verify) {
2234           classfile_parse_error(&quot;LVTT entry for &#39;%s&#39; in class file %s &quot;
2235                                 &quot;does not match any LVT entry&quot;,
2236                                  _cp-&gt;symbol_at(lvtt_elem.name_cp_index)-&gt;as_utf8(),
2237                                  CHECK);
2238         }
2239       } else if ((*entry)-&gt;signature_cp_index != 0 &amp;&amp; _need_verify) {
2240         classfile_parse_error(&quot;Duplicated LocalVariableTypeTable attribute &quot;
2241                               &quot;entry for &#39;%s&#39; in class file %s&quot;,
2242                                _cp-&gt;symbol_at(lvtt_elem.name_cp_index)-&gt;as_utf8(),
2243                                CHECK);
2244       } else {
2245         // to add generic signatures into LocalVariableTable
2246         (*entry)-&gt;signature_cp_index = lvtt_elem.descriptor_cp_index;
2247       }
2248     }
2249   }
2250 }
2251 
2252 
2253 void ClassFileParser::copy_method_annotations(ConstMethod* cm,
2254                                        const u1* runtime_visible_annotations,
2255                                        int runtime_visible_annotations_length,
2256                                        const u1* runtime_invisible_annotations,
2257                                        int runtime_invisible_annotations_length,
2258                                        const u1* runtime_visible_parameter_annotations,
2259                                        int runtime_visible_parameter_annotations_length,
2260                                        const u1* runtime_invisible_parameter_annotations,
2261                                        int runtime_invisible_parameter_annotations_length,
2262                                        const u1* runtime_visible_type_annotations,
2263                                        int runtime_visible_type_annotations_length,
2264                                        const u1* runtime_invisible_type_annotations,
2265                                        int runtime_invisible_type_annotations_length,
2266                                        const u1* annotation_default,
2267                                        int annotation_default_length,
2268                                        TRAPS) {
2269 
2270   AnnotationArray* a;
2271 
2272   if (runtime_visible_annotations_length +
2273       runtime_invisible_annotations_length &gt; 0) {
2274      a = assemble_annotations(runtime_visible_annotations,
2275                               runtime_visible_annotations_length,
2276                               runtime_invisible_annotations,
2277                               runtime_invisible_annotations_length,
2278                               CHECK);
2279      cm-&gt;set_method_annotations(a);
2280   }
2281 
2282   if (runtime_visible_parameter_annotations_length +
2283       runtime_invisible_parameter_annotations_length &gt; 0) {
2284     a = assemble_annotations(runtime_visible_parameter_annotations,
2285                              runtime_visible_parameter_annotations_length,
2286                              runtime_invisible_parameter_annotations,
2287                              runtime_invisible_parameter_annotations_length,
2288                              CHECK);
2289     cm-&gt;set_parameter_annotations(a);
2290   }
2291 
2292   if (annotation_default_length &gt; 0) {
2293     a = assemble_annotations(annotation_default,
2294                              annotation_default_length,
2295                              NULL,
2296                              0,
2297                              CHECK);
2298     cm-&gt;set_default_annotations(a);
2299   }
2300 
2301   if (runtime_visible_type_annotations_length +
2302       runtime_invisible_type_annotations_length &gt; 0) {
2303     a = assemble_annotations(runtime_visible_type_annotations,
2304                              runtime_visible_type_annotations_length,
2305                              runtime_invisible_type_annotations,
2306                              runtime_invisible_type_annotations_length,
2307                              CHECK);
2308     cm-&gt;set_type_annotations(a);
2309   }
2310 }
2311 
2312 
2313 // Note: the parse_method below is big and clunky because all parsing of the code and exceptions
2314 // attribute is inlined. This is cumbersome to avoid since we inline most of the parts in the
2315 // Method* to save footprint, so we only know the size of the resulting Method* when the
2316 // entire method attribute is parsed.
2317 //
2318 // The promoted_flags parameter is used to pass relevant access_flags
2319 // from the method back up to the containing klass. These flag values
2320 // are added to klass&#39;s access_flags.
2321 
2322 Method* ClassFileParser::parse_method(const ClassFileStream* const cfs,
2323                                       bool is_interface,
<a name="35" id="anc35"></a>
2324                                       const ConstantPool* cp,
2325                                       AccessFlags* const promoted_flags,
2326                                       TRAPS) {
2327   assert(cfs != NULL, &quot;invariant&quot;);
2328   assert(cp != NULL, &quot;invariant&quot;);
2329   assert(promoted_flags != NULL, &quot;invariant&quot;);
2330 
2331   ResourceMark rm(THREAD);
2332   // Parse fixed parts:
2333   // access_flags, name_index, descriptor_index, attributes_count
2334   cfs-&gt;guarantee_more(8, CHECK_NULL);
2335 
2336   int flags = cfs-&gt;get_u2_fast();
2337   const u2 name_index = cfs-&gt;get_u2_fast();
2338   const int cp_size = cp-&gt;length();
2339   check_property(
2340     valid_symbol_at(name_index),
2341     &quot;Illegal constant pool index %u for method name in class file %s&quot;,
2342     name_index, CHECK_NULL);
2343   const Symbol* const name = cp-&gt;symbol_at(name_index);
2344   verify_legal_method_name(name, CHECK_NULL);
2345 
2346   const u2 signature_index = cfs-&gt;get_u2_fast();
2347   guarantee_property(
2348     valid_symbol_at(signature_index),
2349     &quot;Illegal constant pool index %u for method signature in class file %s&quot;,
2350     signature_index, CHECK_NULL);
2351   const Symbol* const signature = cp-&gt;symbol_at(signature_index);
2352 
2353   if (name == vmSymbols::class_initializer_name()) {
2354     // We ignore the other access flags for a valid class initializer.
2355     // (JVM Spec 2nd ed., chapter 4.6)
2356     if (_major_version &lt; 51) { // backward compatibility
2357       flags = JVM_ACC_STATIC;
2358     } else if ((flags &amp; JVM_ACC_STATIC) == JVM_ACC_STATIC) {
2359       flags &amp;= JVM_ACC_STATIC | JVM_ACC_STRICT;
2360     } else {
2361       classfile_parse_error(&quot;Method &lt;clinit&gt; is not static in class file %s&quot;, CHECK_NULL);
2362     }
2363   } else {
<a name="36" id="anc36"></a><span class="line-modified">2364     verify_legal_method_modifiers(flags, is_interface, name, CHECK_NULL);</span>
<span class="line-modified">2365   }</span>
<span class="line-modified">2366 </span>
<span class="line-modified">2367   if (name == vmSymbols::object_initializer_name() &amp;&amp; is_interface) {</span>
<span class="line-modified">2368     classfile_parse_error(&quot;Interface cannot have a method named &lt;init&gt;, class file %s&quot;, CHECK_NULL);</span>










































2369   }
2370 
2371   int args_size = -1;  // only used when _need_verify is true
2372   if (_need_verify) {
2373     args_size = ((flags &amp; JVM_ACC_STATIC) ? 0 : 1) +
2374                  verify_legal_method_signature(name, signature, CHECK_NULL);
2375     if (args_size &gt; MAX_ARGS_SIZE) {
2376       classfile_parse_error(&quot;Too many arguments in method signature in class file %s&quot;, CHECK_NULL);
2377     }
2378   }
2379 
2380   AccessFlags access_flags(flags &amp; JVM_RECOGNIZED_METHOD_MODIFIERS);
2381 
2382   // Default values for code and exceptions attribute elements
2383   u2 max_stack = 0;
2384   u2 max_locals = 0;
2385   u4 code_length = 0;
2386   const u1* code_start = 0;
2387   u2 exception_table_length = 0;
2388   const unsafe_u2* exception_table_start = NULL; // (potentially unaligned) pointer to array of u2 elements
2389   Array&lt;int&gt;* exception_handlers = Universe::the_empty_int_array();
2390   u2 checked_exceptions_length = 0;
2391   const unsafe_u2* checked_exceptions_start = NULL; // (potentially unaligned) pointer to array of u2 elements
2392   CompressedLineNumberWriteStream* linenumber_table = NULL;
2393   int linenumber_table_length = 0;
2394   int total_lvt_length = 0;
2395   u2 lvt_cnt = 0;
2396   u2 lvtt_cnt = 0;
2397   bool lvt_allocated = false;
2398   u2 max_lvt_cnt = INITIAL_MAX_LVT_NUMBER;
2399   u2 max_lvtt_cnt = INITIAL_MAX_LVT_NUMBER;
2400   u2* localvariable_table_length = NULL;
2401   const unsafe_u2** localvariable_table_start = NULL; // (potentially unaligned) pointer to array of LVT attributes
2402   u2* localvariable_type_table_length = NULL;
2403   const unsafe_u2** localvariable_type_table_start = NULL; // (potentially unaligned) pointer to LVTT attributes
2404   int method_parameters_length = -1;
2405   const u1* method_parameters_data = NULL;
2406   bool method_parameters_seen = false;
2407   bool parsed_code_attribute = false;
2408   bool parsed_checked_exceptions_attribute = false;
2409   bool parsed_stackmap_attribute = false;
2410   // stackmap attribute - JDK1.5
2411   const u1* stackmap_data = NULL;
2412   int stackmap_data_length = 0;
2413   u2 generic_signature_index = 0;
2414   MethodAnnotationCollector parsed_annotations;
2415   const u1* runtime_visible_annotations = NULL;
2416   int runtime_visible_annotations_length = 0;
2417   const u1* runtime_invisible_annotations = NULL;
2418   int runtime_invisible_annotations_length = 0;
2419   const u1* runtime_visible_parameter_annotations = NULL;
2420   int runtime_visible_parameter_annotations_length = 0;
2421   const u1* runtime_invisible_parameter_annotations = NULL;
2422   int runtime_invisible_parameter_annotations_length = 0;
2423   const u1* runtime_visible_type_annotations = NULL;
2424   int runtime_visible_type_annotations_length = 0;
2425   const u1* runtime_invisible_type_annotations = NULL;
2426   int runtime_invisible_type_annotations_length = 0;
2427   bool runtime_invisible_annotations_exists = false;
2428   bool runtime_invisible_type_annotations_exists = false;
2429   bool runtime_invisible_parameter_annotations_exists = false;
2430   const u1* annotation_default = NULL;
2431   int annotation_default_length = 0;
2432 
2433   // Parse code and exceptions attribute
2434   u2 method_attributes_count = cfs-&gt;get_u2_fast();
2435   while (method_attributes_count--) {
2436     cfs-&gt;guarantee_more(6, CHECK_NULL);  // method_attribute_name_index, method_attribute_length
2437     const u2 method_attribute_name_index = cfs-&gt;get_u2_fast();
2438     const u4 method_attribute_length = cfs-&gt;get_u4_fast();
2439     check_property(
2440       valid_symbol_at(method_attribute_name_index),
2441       &quot;Invalid method attribute name index %u in class file %s&quot;,
2442       method_attribute_name_index, CHECK_NULL);
2443 
2444     const Symbol* const method_attribute_name = cp-&gt;symbol_at(method_attribute_name_index);
2445     if (method_attribute_name == vmSymbols::tag_code()) {
2446       // Parse Code attribute
2447       if (_need_verify) {
2448         guarantee_property(
2449             !access_flags.is_native() &amp;&amp; !access_flags.is_abstract(),
2450                         &quot;Code attribute in native or abstract methods in class file %s&quot;,
2451                          CHECK_NULL);
2452       }
2453       if (parsed_code_attribute) {
2454         classfile_parse_error(&quot;Multiple Code attributes in class file %s&quot;,
2455                               CHECK_NULL);
2456       }
2457       parsed_code_attribute = true;
2458 
2459       // Stack size, locals size, and code size
2460       cfs-&gt;guarantee_more(8, CHECK_NULL);
2461       max_stack = cfs-&gt;get_u2_fast();
2462       max_locals = cfs-&gt;get_u2_fast();
2463       code_length = cfs-&gt;get_u4_fast();
2464       if (_need_verify) {
2465         guarantee_property(args_size &lt;= max_locals,
2466                            &quot;Arguments can&#39;t fit into locals in class file %s&quot;,
2467                            CHECK_NULL);
2468         guarantee_property(code_length &gt; 0 &amp;&amp; code_length &lt;= MAX_CODE_SIZE,
2469                            &quot;Invalid method Code length %u in class file %s&quot;,
2470                            code_length, CHECK_NULL);
2471       }
2472       // Code pointer
2473       code_start = cfs-&gt;current();
2474       assert(code_start != NULL, &quot;null code start&quot;);
2475       cfs-&gt;guarantee_more(code_length, CHECK_NULL);
2476       cfs-&gt;skip_u1_fast(code_length);
2477 
2478       // Exception handler table
2479       cfs-&gt;guarantee_more(2, CHECK_NULL);  // exception_table_length
2480       exception_table_length = cfs-&gt;get_u2_fast();
2481       if (exception_table_length &gt; 0) {
2482         exception_table_start = parse_exception_table(cfs,
2483                                                       code_length,
2484                                                       exception_table_length,
2485                                                       CHECK_NULL);
2486       }
2487 
2488       // Parse additional attributes in code attribute
2489       cfs-&gt;guarantee_more(2, CHECK_NULL);  // code_attributes_count
2490       u2 code_attributes_count = cfs-&gt;get_u2_fast();
2491 
2492       unsigned int calculated_attribute_length = 0;
2493 
2494       calculated_attribute_length =
2495           sizeof(max_stack) + sizeof(max_locals) + sizeof(code_length);
2496       calculated_attribute_length +=
2497         code_length +
2498         sizeof(exception_table_length) +
2499         sizeof(code_attributes_count) +
2500         exception_table_length *
2501             ( sizeof(u2) +   // start_pc
2502               sizeof(u2) +   // end_pc
2503               sizeof(u2) +   // handler_pc
2504               sizeof(u2) );  // catch_type_index
2505 
2506       while (code_attributes_count--) {
2507         cfs-&gt;guarantee_more(6, CHECK_NULL);  // code_attribute_name_index, code_attribute_length
2508         const u2 code_attribute_name_index = cfs-&gt;get_u2_fast();
2509         const u4 code_attribute_length = cfs-&gt;get_u4_fast();
2510         calculated_attribute_length += code_attribute_length +
2511                                        sizeof(code_attribute_name_index) +
2512                                        sizeof(code_attribute_length);
2513         check_property(valid_symbol_at(code_attribute_name_index),
2514                        &quot;Invalid code attribute name index %u in class file %s&quot;,
2515                        code_attribute_name_index,
2516                        CHECK_NULL);
2517         if (LoadLineNumberTables &amp;&amp;
2518             cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_line_number_table()) {
2519           // Parse and compress line number table
2520           parse_linenumber_table(code_attribute_length,
2521                                  code_length,
2522                                  &amp;linenumber_table,
2523                                  CHECK_NULL);
2524 
2525         } else if (LoadLocalVariableTables &amp;&amp;
2526                    cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_local_variable_table()) {
2527           // Parse local variable table
2528           if (!lvt_allocated) {
2529             localvariable_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2530               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2531             localvariable_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2532               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2533             localvariable_type_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2534               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2535             localvariable_type_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2536               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2537             lvt_allocated = true;
2538           }
2539           if (lvt_cnt == max_lvt_cnt) {
2540             max_lvt_cnt &lt;&lt;= 1;
2541             localvariable_table_length = REALLOC_RESOURCE_ARRAY(u2, localvariable_table_length, lvt_cnt, max_lvt_cnt);
2542             localvariable_table_start  = REALLOC_RESOURCE_ARRAY(const unsafe_u2*, localvariable_table_start, lvt_cnt, max_lvt_cnt);
2543           }
2544           localvariable_table_start[lvt_cnt] =
2545             parse_localvariable_table(cfs,
2546                                       code_length,
2547                                       max_locals,
2548                                       code_attribute_length,
2549                                       &amp;localvariable_table_length[lvt_cnt],
2550                                       false,    // is not LVTT
2551                                       CHECK_NULL);
2552           total_lvt_length += localvariable_table_length[lvt_cnt];
2553           lvt_cnt++;
2554         } else if (LoadLocalVariableTypeTables &amp;&amp;
2555                    _major_version &gt;= JAVA_1_5_VERSION &amp;&amp;
2556                    cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_local_variable_type_table()) {
2557           if (!lvt_allocated) {
2558             localvariable_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2559               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2560             localvariable_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2561               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2562             localvariable_type_table_length = NEW_RESOURCE_ARRAY_IN_THREAD(
2563               THREAD, u2,  INITIAL_MAX_LVT_NUMBER);
2564             localvariable_type_table_start = NEW_RESOURCE_ARRAY_IN_THREAD(
2565               THREAD, const unsafe_u2*, INITIAL_MAX_LVT_NUMBER);
2566             lvt_allocated = true;
2567           }
2568           // Parse local variable type table
2569           if (lvtt_cnt == max_lvtt_cnt) {
2570             max_lvtt_cnt &lt;&lt;= 1;
2571             localvariable_type_table_length = REALLOC_RESOURCE_ARRAY(u2, localvariable_type_table_length, lvtt_cnt, max_lvtt_cnt);
2572             localvariable_type_table_start  = REALLOC_RESOURCE_ARRAY(const unsafe_u2*, localvariable_type_table_start, lvtt_cnt, max_lvtt_cnt);
2573           }
2574           localvariable_type_table_start[lvtt_cnt] =
2575             parse_localvariable_table(cfs,
2576                                       code_length,
2577                                       max_locals,
2578                                       code_attribute_length,
2579                                       &amp;localvariable_type_table_length[lvtt_cnt],
2580                                       true,     // is LVTT
2581                                       CHECK_NULL);
2582           lvtt_cnt++;
2583         } else if (_major_version &gt;= Verifier::STACKMAP_ATTRIBUTE_MAJOR_VERSION &amp;&amp;
2584                    cp-&gt;symbol_at(code_attribute_name_index) == vmSymbols::tag_stack_map_table()) {
2585           // Stack map is only needed by the new verifier in JDK1.5.
2586           if (parsed_stackmap_attribute) {
2587             classfile_parse_error(&quot;Multiple StackMapTable attributes in class file %s&quot;, CHECK_NULL);
2588           }
2589           stackmap_data = parse_stackmap_table(cfs, code_attribute_length, _need_verify, CHECK_NULL);
2590           stackmap_data_length = code_attribute_length;
2591           parsed_stackmap_attribute = true;
2592         } else {
2593           // Skip unknown attributes
2594           cfs-&gt;skip_u1(code_attribute_length, CHECK_NULL);
2595         }
2596       }
2597       // check method attribute length
2598       if (_need_verify) {
2599         guarantee_property(method_attribute_length == calculated_attribute_length,
2600                            &quot;Code segment has wrong length in class file %s&quot;,
2601                            CHECK_NULL);
2602       }
2603     } else if (method_attribute_name == vmSymbols::tag_exceptions()) {
2604       // Parse Exceptions attribute
2605       if (parsed_checked_exceptions_attribute) {
2606         classfile_parse_error(&quot;Multiple Exceptions attributes in class file %s&quot;,
2607                               CHECK_NULL);
2608       }
2609       parsed_checked_exceptions_attribute = true;
2610       checked_exceptions_start =
2611             parse_checked_exceptions(cfs,
2612                                      &amp;checked_exceptions_length,
2613                                      method_attribute_length,
2614                                      CHECK_NULL);
2615     } else if (method_attribute_name == vmSymbols::tag_method_parameters()) {
2616       // reject multiple method parameters
2617       if (method_parameters_seen) {
2618         classfile_parse_error(&quot;Multiple MethodParameters attributes in class file %s&quot;,
2619                               CHECK_NULL);
2620       }
2621       method_parameters_seen = true;
2622       method_parameters_length = cfs-&gt;get_u1_fast();
2623       const u2 real_length = (method_parameters_length * 4u) + 1u;
2624       if (method_attribute_length != real_length) {
2625         classfile_parse_error(
2626           &quot;Invalid MethodParameters method attribute length %u in class file&quot;,
2627           method_attribute_length, CHECK_NULL);
2628       }
2629       method_parameters_data = cfs-&gt;current();
2630       cfs-&gt;skip_u2_fast(method_parameters_length);
2631       cfs-&gt;skip_u2_fast(method_parameters_length);
2632       // ignore this attribute if it cannot be reflected
2633       if (!SystemDictionary::Parameter_klass_loaded())
2634         method_parameters_length = -1;
2635     } else if (method_attribute_name == vmSymbols::tag_synthetic()) {
2636       if (method_attribute_length != 0) {
2637         classfile_parse_error(
2638           &quot;Invalid Synthetic method attribute length %u in class file %s&quot;,
2639           method_attribute_length, CHECK_NULL);
2640       }
2641       // Should we check that there hasn&#39;t already been a synthetic attribute?
2642       access_flags.set_is_synthetic();
2643     } else if (method_attribute_name == vmSymbols::tag_deprecated()) { // 4276120
2644       if (method_attribute_length != 0) {
2645         classfile_parse_error(
2646           &quot;Invalid Deprecated method attribute length %u in class file %s&quot;,
2647           method_attribute_length, CHECK_NULL);
2648       }
2649     } else if (_major_version &gt;= JAVA_1_5_VERSION) {
2650       if (method_attribute_name == vmSymbols::tag_signature()) {
2651         if (generic_signature_index != 0) {
2652           classfile_parse_error(
2653             &quot;Multiple Signature attributes for method in class file %s&quot;,
2654             CHECK_NULL);
2655         }
2656         if (method_attribute_length != 2) {
2657           classfile_parse_error(
2658             &quot;Invalid Signature attribute length %u in class file %s&quot;,
2659             method_attribute_length, CHECK_NULL);
2660         }
2661         generic_signature_index = parse_generic_signature_attribute(cfs, CHECK_NULL);
2662       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
2663         if (runtime_visible_annotations != NULL) {
2664           classfile_parse_error(
2665             &quot;Multiple RuntimeVisibleAnnotations attributes for method in class file %s&quot;,
2666             CHECK_NULL);
2667         }
2668         runtime_visible_annotations_length = method_attribute_length;
2669         runtime_visible_annotations = cfs-&gt;current();
2670         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
2671         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK_NULL);
2672         parse_annotations(cp,
2673                           runtime_visible_annotations,
2674                           runtime_visible_annotations_length,
2675                           &amp;parsed_annotations,
2676                           _loader_data,
2677                           _can_access_vm_annotations,
2678                           CHECK_NULL);
2679         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
2680       } else if (method_attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
2681         if (runtime_invisible_annotations_exists) {
2682           classfile_parse_error(
2683             &quot;Multiple RuntimeInvisibleAnnotations attributes for method in class file %s&quot;,
2684             CHECK_NULL);
2685         }
2686         runtime_invisible_annotations_exists = true;
2687         if (PreserveAllAnnotations) {
2688           runtime_invisible_annotations_length = method_attribute_length;
2689           runtime_invisible_annotations = cfs-&gt;current();
2690           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
2691         }
2692         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2693       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_parameter_annotations()) {
2694         if (runtime_visible_parameter_annotations != NULL) {
2695           classfile_parse_error(
2696             &quot;Multiple RuntimeVisibleParameterAnnotations attributes for method in class file %s&quot;,
2697             CHECK_NULL);
2698         }
2699         runtime_visible_parameter_annotations_length = method_attribute_length;
2700         runtime_visible_parameter_annotations = cfs-&gt;current();
2701         assert(runtime_visible_parameter_annotations != NULL, &quot;null visible parameter annotations&quot;);
2702         cfs-&gt;skip_u1(runtime_visible_parameter_annotations_length, CHECK_NULL);
2703       } else if (method_attribute_name == vmSymbols::tag_runtime_invisible_parameter_annotations()) {
2704         if (runtime_invisible_parameter_annotations_exists) {
2705           classfile_parse_error(
2706             &quot;Multiple RuntimeInvisibleParameterAnnotations attributes for method in class file %s&quot;,
2707             CHECK_NULL);
2708         }
2709         runtime_invisible_parameter_annotations_exists = true;
2710         if (PreserveAllAnnotations) {
2711           runtime_invisible_parameter_annotations_length = method_attribute_length;
2712           runtime_invisible_parameter_annotations = cfs-&gt;current();
2713           assert(runtime_invisible_parameter_annotations != NULL,
2714             &quot;null invisible parameter annotations&quot;);
2715         }
2716         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2717       } else if (method_attribute_name == vmSymbols::tag_annotation_default()) {
2718         if (annotation_default != NULL) {
2719           classfile_parse_error(
2720             &quot;Multiple AnnotationDefault attributes for method in class file %s&quot;,
2721             CHECK_NULL);
2722         }
2723         annotation_default_length = method_attribute_length;
2724         annotation_default = cfs-&gt;current();
2725         assert(annotation_default != NULL, &quot;null annotation default&quot;);
2726         cfs-&gt;skip_u1(annotation_default_length, CHECK_NULL);
2727       } else if (method_attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {
2728         if (runtime_visible_type_annotations != NULL) {
2729           classfile_parse_error(
2730             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for method in class file %s&quot;,
2731             CHECK_NULL);
2732         }
2733         runtime_visible_type_annotations_length = method_attribute_length;
2734         runtime_visible_type_annotations = cfs-&gt;current();
2735         assert(runtime_visible_type_annotations != NULL, &quot;null visible type annotations&quot;);
2736         // No need for the VM to parse Type annotations
2737         cfs-&gt;skip_u1(runtime_visible_type_annotations_length, CHECK_NULL);
2738       } else if (method_attribute_name == vmSymbols::tag_runtime_invisible_type_annotations()) {
2739         if (runtime_invisible_type_annotations_exists) {
2740           classfile_parse_error(
2741             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes for method in class file %s&quot;,
2742             CHECK_NULL);
2743         } else {
2744           runtime_invisible_type_annotations_exists = true;
2745         }
2746         if (PreserveAllAnnotations) {
2747           runtime_invisible_type_annotations_length = method_attribute_length;
2748           runtime_invisible_type_annotations = cfs-&gt;current();
2749           assert(runtime_invisible_type_annotations != NULL, &quot;null invisible type annotations&quot;);
2750         }
2751         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2752       } else {
2753         // Skip unknown attributes
2754         cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2755       }
2756     } else {
2757       // Skip unknown attributes
2758       cfs-&gt;skip_u1(method_attribute_length, CHECK_NULL);
2759     }
2760   }
2761 
2762   if (linenumber_table != NULL) {
2763     linenumber_table-&gt;write_terminator();
2764     linenumber_table_length = linenumber_table-&gt;position();
2765   }
2766 
2767   // Make sure there&#39;s at least one Code attribute in non-native/non-abstract method
2768   if (_need_verify) {
2769     guarantee_property(access_flags.is_native() ||
2770                        access_flags.is_abstract() ||
2771                        parsed_code_attribute,
2772                        &quot;Absent Code attribute in method that is not native or abstract in class file %s&quot;,
2773                        CHECK_NULL);
2774   }
2775 
2776   // All sizing information for a Method* is finally available, now create it
2777   InlineTableSizes sizes(
2778       total_lvt_length,
2779       linenumber_table_length,
2780       exception_table_length,
2781       checked_exceptions_length,
2782       method_parameters_length,
2783       generic_signature_index,
2784       runtime_visible_annotations_length +
2785            runtime_invisible_annotations_length,
2786       runtime_visible_parameter_annotations_length +
2787            runtime_invisible_parameter_annotations_length,
2788       runtime_visible_type_annotations_length +
2789            runtime_invisible_type_annotations_length,
2790       annotation_default_length,
2791       0);
2792 
2793   Method* const m = Method::allocate(_loader_data,
2794                                      code_length,
2795                                      access_flags,
2796                                      &amp;sizes,
2797                                      ConstMethod::NORMAL,
2798                                      CHECK_NULL);
2799 
2800   ClassLoadingService::add_class_method_size(m-&gt;size()*wordSize);
2801 
2802   // Fill in information from fixed part (access_flags already set)
2803   m-&gt;set_constants(_cp);
2804   m-&gt;set_name_index(name_index);
2805   m-&gt;set_signature_index(signature_index);
2806   m-&gt;compute_from_signature(cp-&gt;symbol_at(signature_index));
2807   assert(args_size &lt; 0 || args_size == m-&gt;size_of_parameters(), &quot;&quot;);
2808 
2809   // Fill in code attribute information
2810   m-&gt;set_max_stack(max_stack);
2811   m-&gt;set_max_locals(max_locals);
2812   if (stackmap_data != NULL) {
2813     m-&gt;constMethod()-&gt;copy_stackmap_data(_loader_data,
2814                                          (u1*)stackmap_data,
2815                                          stackmap_data_length,
2816                                          CHECK_NULL);
2817   }
2818 
2819   // Copy byte codes
2820   m-&gt;set_code((u1*)code_start);
2821 
2822   // Copy line number table
2823   if (linenumber_table != NULL) {
2824     memcpy(m-&gt;compressed_linenumber_table(),
2825            linenumber_table-&gt;buffer(),
2826            linenumber_table_length);
2827   }
2828 
2829   // Copy exception table
2830   if (exception_table_length &gt; 0) {
2831     Copy::conjoint_swap_if_needed&lt;Endian::JAVA&gt;(exception_table_start,
2832                                                 m-&gt;exception_table_start(),
2833                                                 exception_table_length * sizeof(ExceptionTableElement),
2834                                                 sizeof(u2));
2835   }
2836 
2837   // Copy method parameters
2838   if (method_parameters_length &gt; 0) {
2839     MethodParametersElement* elem = m-&gt;constMethod()-&gt;method_parameters_start();
2840     for (int i = 0; i &lt; method_parameters_length; i++) {
2841       elem[i].name_cp_index = Bytes::get_Java_u2((address)method_parameters_data);
2842       method_parameters_data += 2;
2843       elem[i].flags = Bytes::get_Java_u2((address)method_parameters_data);
2844       method_parameters_data += 2;
2845     }
2846   }
2847 
2848   // Copy checked exceptions
2849   if (checked_exceptions_length &gt; 0) {
2850     Copy::conjoint_swap_if_needed&lt;Endian::JAVA&gt;(checked_exceptions_start,
2851                                                 m-&gt;checked_exceptions_start(),
2852                                                 checked_exceptions_length * sizeof(CheckedExceptionElement),
2853                                                 sizeof(u2));
2854   }
2855 
2856   // Copy class file LVT&#39;s/LVTT&#39;s into the HotSpot internal LVT.
2857   if (total_lvt_length &gt; 0) {
2858     promoted_flags-&gt;set_has_localvariable_table();
2859     copy_localvariable_table(m-&gt;constMethod(),
2860                              lvt_cnt,
2861                              localvariable_table_length,
2862                              localvariable_table_start,
2863                              lvtt_cnt,
2864                              localvariable_type_table_length,
2865                              localvariable_type_table_start,
2866                              CHECK_NULL);
2867   }
2868 
2869   if (parsed_annotations.has_any_annotations())
2870     parsed_annotations.apply_to(methodHandle(THREAD, m));
2871 
2872   if (is_hidden()) { // Mark methods in hidden classes as &#39;hidden&#39;.
2873     m-&gt;set_hidden(true);
2874   }
2875 
2876   // Copy annotations
2877   copy_method_annotations(m-&gt;constMethod(),
2878                           runtime_visible_annotations,
2879                           runtime_visible_annotations_length,
2880                           runtime_invisible_annotations,
2881                           runtime_invisible_annotations_length,
2882                           runtime_visible_parameter_annotations,
2883                           runtime_visible_parameter_annotations_length,
2884                           runtime_invisible_parameter_annotations,
2885                           runtime_invisible_parameter_annotations_length,
2886                           runtime_visible_type_annotations,
2887                           runtime_visible_type_annotations_length,
2888                           runtime_invisible_type_annotations,
2889                           runtime_invisible_type_annotations_length,
2890                           annotation_default,
2891                           annotation_default_length,
2892                           CHECK_NULL);
2893 
2894   if (name == vmSymbols::finalize_method_name() &amp;&amp;
2895       signature == vmSymbols::void_method_signature()) {
2896     if (m-&gt;is_empty_method()) {
2897       _has_empty_finalizer = true;
2898     } else {
2899       _has_finalizer = true;
2900     }
2901   }
2902   if (name == vmSymbols::object_initializer_name() &amp;&amp;
2903       signature == vmSymbols::void_method_signature() &amp;&amp;
2904       m-&gt;is_vanilla_constructor()) {
2905     _has_vanilla_constructor = true;
2906   }
2907 
2908   NOT_PRODUCT(m-&gt;verify());
2909   return m;
2910 }
2911 
2912 
2913 // The promoted_flags parameter is used to pass relevant access_flags
2914 // from the methods back up to the containing klass. These flag values
2915 // are added to klass&#39;s access_flags.
2916 // Side-effects: populates the _methods field in the parser
2917 void ClassFileParser::parse_methods(const ClassFileStream* const cfs,
2918                                     bool is_interface,
<a name="37" id="anc37"></a>
2919                                     AccessFlags* promoted_flags,
2920                                     bool* has_final_method,
2921                                     bool* declares_nonstatic_concrete_methods,
2922                                     TRAPS) {
2923   assert(cfs != NULL, &quot;invariant&quot;);
2924   assert(promoted_flags != NULL, &quot;invariant&quot;);
2925   assert(has_final_method != NULL, &quot;invariant&quot;);
2926   assert(declares_nonstatic_concrete_methods != NULL, &quot;invariant&quot;);
2927 
2928   assert(NULL == _methods, &quot;invariant&quot;);
2929 
2930   cfs-&gt;guarantee_more(2, CHECK);  // length
2931   const u2 length = cfs-&gt;get_u2_fast();
2932   if (length == 0) {
2933     _methods = Universe::the_empty_method_array();
2934   } else {
2935     _methods = MetadataFactory::new_array&lt;Method*&gt;(_loader_data,
2936                                                    length,
2937                                                    NULL,
2938                                                    CHECK);
2939 
2940     for (int index = 0; index &lt; length; index++) {
2941       Method* method = parse_method(cfs,
2942                                     is_interface,
<a name="38" id="anc38"></a>
2943                                     _cp,
2944                                     promoted_flags,
2945                                     CHECK);
2946 
2947       if (method-&gt;is_final()) {
2948         *has_final_method = true;
2949       }
2950       // declares_nonstatic_concrete_methods: declares concrete instance methods, any access flags
2951       // used for interface initialization, and default method inheritance analysis
2952       if (is_interface &amp;&amp; !(*declares_nonstatic_concrete_methods)
2953         &amp;&amp; !method-&gt;is_abstract() &amp;&amp; !method-&gt;is_static()) {
2954         *declares_nonstatic_concrete_methods = true;
2955       }
2956       _methods-&gt;at_put(index, method);
2957     }
2958 
2959     if (_need_verify &amp;&amp; length &gt; 1) {
2960       // Check duplicated methods
2961       ResourceMark rm(THREAD);
2962       NameSigHash** names_and_sigs = NEW_RESOURCE_ARRAY_IN_THREAD(
2963         THREAD, NameSigHash*, HASH_ROW_SIZE);
2964       initialize_hashtable(names_and_sigs);
2965       bool dup = false;
2966       const Symbol* name = NULL;
2967       const Symbol* sig = NULL;
2968       {
2969         debug_only(NoSafepointVerifier nsv;)
2970         for (int i = 0; i &lt; length; i++) {
2971           const Method* const m = _methods-&gt;at(i);
2972           name = m-&gt;name();
2973           sig = m-&gt;signature();
2974           // If no duplicates, add name/signature in hashtable names_and_sigs.
2975           if (!put_after_lookup(name, sig, names_and_sigs)) {
2976             dup = true;
2977             break;
2978           }
2979         }
2980       }
2981       if (dup) {
2982         classfile_parse_error(&quot;Duplicate method name \&quot;%s\&quot; with signature \&quot;%s\&quot; in class file %s&quot;,
2983                                name-&gt;as_C_string(), sig-&gt;as_klass_external_name(), CHECK);
2984       }
2985     }
2986   }
2987 }
2988 
2989 static const intArray* sort_methods(Array&lt;Method*&gt;* methods) {
2990   const int length = methods-&gt;length();
2991   // If JVMTI original method ordering or sharing is enabled we have to
2992   // remember the original class file ordering.
2993   // We temporarily use the vtable_index field in the Method* to store the
2994   // class file index, so we can read in after calling qsort.
2995   // Put the method ordering in the shared archive.
2996   if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {
2997     for (int index = 0; index &lt; length; index++) {
2998       Method* const m = methods-&gt;at(index);
2999       assert(!m-&gt;valid_vtable_index(), &quot;vtable index should not be set&quot;);
3000       m-&gt;set_vtable_index(index);
3001     }
3002   }
3003   // Sort method array by ascending method name (for faster lookups &amp; vtable construction)
3004   // Note that the ordering is not alphabetical, see Symbol::fast_compare
3005   Method::sort_methods(methods);
3006 
3007   intArray* method_ordering = NULL;
3008   // If JVMTI original method ordering or sharing is enabled construct int
3009   // array remembering the original ordering
3010   if (JvmtiExport::can_maintain_original_method_order() || Arguments::is_dumping_archive()) {
3011     method_ordering = new intArray(length, length, -1);
3012     for (int index = 0; index &lt; length; index++) {
3013       Method* const m = methods-&gt;at(index);
3014       const int old_index = m-&gt;vtable_index();
3015       assert(old_index &gt;= 0 &amp;&amp; old_index &lt; length, &quot;invalid method index&quot;);
3016       method_ordering-&gt;at_put(index, old_index);
3017       m-&gt;set_vtable_index(Method::invalid_vtable_index);
3018     }
3019   }
3020   return method_ordering;
3021 }
3022 
3023 // Parse generic_signature attribute for methods and fields
3024 u2 ClassFileParser::parse_generic_signature_attribute(const ClassFileStream* const cfs,
3025                                                       TRAPS) {
3026   assert(cfs != NULL, &quot;invariant&quot;);
3027 
3028   cfs-&gt;guarantee_more(2, CHECK_0);  // generic_signature_index
3029   const u2 generic_signature_index = cfs-&gt;get_u2_fast();
3030   check_property(
3031     valid_symbol_at(generic_signature_index),
3032     &quot;Invalid Signature attribute at constant pool index %u in class file %s&quot;,
3033     generic_signature_index, CHECK_0);
3034   return generic_signature_index;
3035 }
3036 
3037 void ClassFileParser::parse_classfile_sourcefile_attribute(const ClassFileStream* const cfs,
3038                                                            TRAPS) {
3039 
3040   assert(cfs != NULL, &quot;invariant&quot;);
3041 
3042   cfs-&gt;guarantee_more(2, CHECK);  // sourcefile_index
3043   const u2 sourcefile_index = cfs-&gt;get_u2_fast();
3044   check_property(
3045     valid_symbol_at(sourcefile_index),
3046     &quot;Invalid SourceFile attribute at constant pool index %u in class file %s&quot;,
3047     sourcefile_index, CHECK);
3048   set_class_sourcefile_index(sourcefile_index);
3049 }
3050 
3051 void ClassFileParser::parse_classfile_source_debug_extension_attribute(const ClassFileStream* const cfs,
3052                                                                        int length,
3053                                                                        TRAPS) {
3054   assert(cfs != NULL, &quot;invariant&quot;);
3055 
3056   const u1* const sde_buffer = cfs-&gt;current();
3057   assert(sde_buffer != NULL, &quot;null sde buffer&quot;);
3058 
3059   // Don&#39;t bother storing it if there is no way to retrieve it
3060   if (JvmtiExport::can_get_source_debug_extension()) {
3061     assert((length+1) &gt; length, &quot;Overflow checking&quot;);
3062     u1* const sde = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, u1, length+1);
3063     for (int i = 0; i &lt; length; i++) {
3064       sde[i] = sde_buffer[i];
3065     }
3066     sde[length] = &#39;\0&#39;;
3067     set_class_sde_buffer((const char*)sde, length);
3068   }
3069   // Got utf8 string, set stream position forward
3070   cfs-&gt;skip_u1(length, CHECK);
3071 }
3072 
3073 
3074 // Inner classes can be static, private or protected (classic VM does this)
3075 #define RECOGNIZED_INNER_CLASS_MODIFIERS ( JVM_RECOGNIZED_CLASS_MODIFIERS | \
3076                                            JVM_ACC_PRIVATE |                \
3077                                            JVM_ACC_PROTECTED |              \
3078                                            JVM_ACC_STATIC                   \
3079                                          )
3080 
3081 // Return number of classes in the inner classes attribute table
3082 u2 ClassFileParser::parse_classfile_inner_classes_attribute(const ClassFileStream* const cfs,
3083                                                             const u1* const inner_classes_attribute_start,
3084                                                             bool parsed_enclosingmethod_attribute,
3085                                                             u2 enclosing_method_class_index,
3086                                                             u2 enclosing_method_method_index,
3087                                                             TRAPS) {
3088   const u1* const current_mark = cfs-&gt;current();
3089   u2 length = 0;
3090   if (inner_classes_attribute_start != NULL) {
3091     cfs-&gt;set_current(inner_classes_attribute_start);
3092     cfs-&gt;guarantee_more(2, CHECK_0);  // length
3093     length = cfs-&gt;get_u2_fast();
3094   }
3095 
3096   // 4-tuples of shorts of inner classes data and 2 shorts of enclosing
3097   // method data:
3098   //   [inner_class_info_index,
3099   //    outer_class_info_index,
3100   //    inner_name_index,
3101   //    inner_class_access_flags,
3102   //    ...
3103   //    enclosing_method_class_index,
3104   //    enclosing_method_method_index]
3105   const int size = length * 4 + (parsed_enclosingmethod_attribute ? 2 : 0);
3106   Array&lt;u2&gt;* const inner_classes = MetadataFactory::new_array&lt;u2&gt;(_loader_data, size, CHECK_0);
3107   _inner_classes = inner_classes;
3108 
3109   int index = 0;
3110   cfs-&gt;guarantee_more(8 * length, CHECK_0);  // 4-tuples of u2
3111   for (int n = 0; n &lt; length; n++) {
3112     // Inner class index
3113     const u2 inner_class_info_index = cfs-&gt;get_u2_fast();
3114     check_property(
3115       valid_klass_reference_at(inner_class_info_index),
3116       &quot;inner_class_info_index %u has bad constant type in class file %s&quot;,
3117       inner_class_info_index, CHECK_0);
3118     // Outer class index
3119     const u2 outer_class_info_index = cfs-&gt;get_u2_fast();
3120     check_property(
3121       outer_class_info_index == 0 ||
3122         valid_klass_reference_at(outer_class_info_index),
3123       &quot;outer_class_info_index %u has bad constant type in class file %s&quot;,
3124       outer_class_info_index, CHECK_0);
3125     // Inner class name
3126     const u2 inner_name_index = cfs-&gt;get_u2_fast();
3127     check_property(
3128       inner_name_index == 0 || valid_symbol_at(inner_name_index),
3129       &quot;inner_name_index %u has bad constant type in class file %s&quot;,
3130       inner_name_index, CHECK_0);
3131     if (_need_verify) {
3132       guarantee_property(inner_class_info_index != outer_class_info_index,
3133                          &quot;Class is both outer and inner class in class file %s&quot;, CHECK_0);
3134     }
<a name="39" id="anc39"></a><span class="line-modified">3135     // Access flags</span>
<span class="line-modified">3136     jint flags;</span>
3137     // JVM_ACC_MODULE is defined in JDK-9 and later.
3138     if (_major_version &gt;= JAVA_9_VERSION) {
<a name="40" id="anc40"></a><span class="line-modified">3139       flags = cfs-&gt;get_u2_fast() &amp; (RECOGNIZED_INNER_CLASS_MODIFIERS | JVM_ACC_MODULE);</span>
<span class="line-modified">3140     } else {</span>
<span class="line-modified">3141       flags = cfs-&gt;get_u2_fast() &amp; RECOGNIZED_INNER_CLASS_MODIFIERS;</span>


3142     }
<a name="41" id="anc41"></a>



3143     if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
3144       // Set abstract bit for old class files for backward compatibility
3145       flags |= JVM_ACC_ABSTRACT;
3146     }
3147     verify_legal_class_modifiers(flags, CHECK_0);
3148     AccessFlags inner_access_flags(flags);
3149 
3150     inner_classes-&gt;at_put(index++, inner_class_info_index);
3151     inner_classes-&gt;at_put(index++, outer_class_info_index);
3152     inner_classes-&gt;at_put(index++, inner_name_index);
3153     inner_classes-&gt;at_put(index++, inner_access_flags.as_short());
3154   }
3155 
3156   // 4347400: make sure there&#39;s no duplicate entry in the classes array
3157   if (_need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3158     for(int i = 0; i &lt; length * 4; i += 4) {
3159       for(int j = i + 4; j &lt; length * 4; j += 4) {
3160         guarantee_property((inner_classes-&gt;at(i)   != inner_classes-&gt;at(j) ||
3161                             inner_classes-&gt;at(i+1) != inner_classes-&gt;at(j+1) ||
3162                             inner_classes-&gt;at(i+2) != inner_classes-&gt;at(j+2) ||
3163                             inner_classes-&gt;at(i+3) != inner_classes-&gt;at(j+3)),
3164                             &quot;Duplicate entry in InnerClasses in class file %s&quot;,
3165                             CHECK_0);
3166       }
3167     }
3168   }
3169 
3170   // Set EnclosingMethod class and method indexes.
3171   if (parsed_enclosingmethod_attribute) {
3172     inner_classes-&gt;at_put(index++, enclosing_method_class_index);
3173     inner_classes-&gt;at_put(index++, enclosing_method_method_index);
3174   }
3175   assert(index == size, &quot;wrong size&quot;);
3176 
3177   // Restore buffer&#39;s current position.
3178   cfs-&gt;set_current(current_mark);
3179 
3180   return length;
3181 }
3182 
3183 u2 ClassFileParser::parse_classfile_nest_members_attribute(const ClassFileStream* const cfs,
3184                                                            const u1* const nest_members_attribute_start,
3185                                                            TRAPS) {
3186   const u1* const current_mark = cfs-&gt;current();
3187   u2 length = 0;
3188   if (nest_members_attribute_start != NULL) {
3189     cfs-&gt;set_current(nest_members_attribute_start);
3190     cfs-&gt;guarantee_more(2, CHECK_0);  // length
3191     length = cfs-&gt;get_u2_fast();
3192   }
3193   const int size = length;
3194   Array&lt;u2&gt;* const nest_members = MetadataFactory::new_array&lt;u2&gt;(_loader_data, size, CHECK_0);
3195   _nest_members = nest_members;
3196 
3197   int index = 0;
3198   cfs-&gt;guarantee_more(2 * length, CHECK_0);
3199   for (int n = 0; n &lt; length; n++) {
3200     const u2 class_info_index = cfs-&gt;get_u2_fast();
3201     check_property(
3202       valid_klass_reference_at(class_info_index),
3203       &quot;Nest member class_info_index %u has bad constant type in class file %s&quot;,
3204       class_info_index, CHECK_0);
3205     nest_members-&gt;at_put(index++, class_info_index);
3206   }
3207   assert(index == size, &quot;wrong size&quot;);
3208 
3209   // Restore buffer&#39;s current position.
3210   cfs-&gt;set_current(current_mark);
3211 
3212   return length;
3213 }
3214 
3215 u2 ClassFileParser::parse_classfile_permitted_subclasses_attribute(const ClassFileStream* const cfs,
3216                                                                    const u1* const permitted_subclasses_attribute_start,
3217                                                                    TRAPS) {
3218   const u1* const current_mark = cfs-&gt;current();
3219   u2 length = 0;
3220   if (permitted_subclasses_attribute_start != NULL) {
3221     cfs-&gt;set_current(permitted_subclasses_attribute_start);
3222     cfs-&gt;guarantee_more(2, CHECK_0);  // length
3223     length = cfs-&gt;get_u2_fast();
3224   }
3225   if (length &lt; 1) {
3226     classfile_parse_error(&quot;PermittedSubclasses attribute is empty in class file %s&quot;, CHECK_0);
3227   }
3228   const int size = length;
3229   Array&lt;u2&gt;* const permitted_subclasses = MetadataFactory::new_array&lt;u2&gt;(_loader_data, size, CHECK_0);
3230   _permitted_subclasses = permitted_subclasses;
3231 
3232   int index = 0;
3233   cfs-&gt;guarantee_more(2 * length, CHECK_0);
3234   for (int n = 0; n &lt; length; n++) {
3235     const u2 class_info_index = cfs-&gt;get_u2_fast();
3236     check_property(
3237       valid_klass_reference_at(class_info_index),
3238       &quot;Permitted subclass class_info_index %u has bad constant type in class file %s&quot;,
3239       class_info_index, CHECK_0);
3240     permitted_subclasses-&gt;at_put(index++, class_info_index);
3241   }
3242   assert(index == size, &quot;wrong size&quot;);
3243 
3244   // Restore buffer&#39;s current position.
3245   cfs-&gt;set_current(current_mark);
3246 
3247   return length;
3248 }
3249 
3250 //  Record {
3251 //    u2 attribute_name_index;
3252 //    u4 attribute_length;
3253 //    u2 components_count;
3254 //    component_info components[components_count];
3255 //  }
3256 //  component_info {
3257 //    u2 name_index;
3258 //    u2 descriptor_index
3259 //    u2 attributes_count;
3260 //    attribute_info_attributes[attributes_count];
3261 //  }
3262 u2 ClassFileParser::parse_classfile_record_attribute(const ClassFileStream* const cfs,
3263                                                      const ConstantPool* cp,
3264                                                      const u1* const record_attribute_start,
3265                                                      TRAPS) {
3266   const u1* const current_mark = cfs-&gt;current();
3267   int components_count = 0;
3268   unsigned int calculate_attr_size = 0;
3269   if (record_attribute_start != NULL) {
3270     cfs-&gt;set_current(record_attribute_start);
3271     cfs-&gt;guarantee_more(2, CHECK_0);  // num of components
3272     components_count = (int)cfs-&gt;get_u2_fast();
3273     calculate_attr_size = 2;
3274   }
3275 
3276   Array&lt;RecordComponent*&gt;* const record_components =
3277     MetadataFactory::new_array&lt;RecordComponent*&gt;(_loader_data, components_count, NULL, CHECK_0);
3278   _record_components = record_components;
3279 
3280   for (int x = 0; x &lt; components_count; x++) {
3281     cfs-&gt;guarantee_more(6, CHECK_0); // name_index, descriptor_index, attributes_count
3282 
3283     const u2 name_index = cfs-&gt;get_u2_fast();
3284     check_property(valid_symbol_at(name_index),
3285       &quot;Invalid constant pool index %u for name in Record attribute in class file %s&quot;,
3286       name_index, CHECK_0);
3287     const Symbol* const name = cp-&gt;symbol_at(name_index);
3288     verify_legal_field_name(name, CHECK_0);
3289 
3290     const u2 descriptor_index = cfs-&gt;get_u2_fast();
3291     check_property(valid_symbol_at(descriptor_index),
3292       &quot;Invalid constant pool index %u for descriptor in Record attribute in class file %s&quot;,
3293       descriptor_index, CHECK_0);
3294     const Symbol* const descr = cp-&gt;symbol_at(descriptor_index);
3295     verify_legal_field_signature(name, descr, CHECK_0);
3296 
3297     const u2 attributes_count = cfs-&gt;get_u2_fast();
3298     calculate_attr_size += 6;
3299     u2 generic_sig_index = 0;
3300     const u1* runtime_visible_annotations = NULL;
3301     int runtime_visible_annotations_length = 0;
3302     const u1* runtime_invisible_annotations = NULL;
3303     int runtime_invisible_annotations_length = 0;
3304     bool runtime_invisible_annotations_exists = false;
3305     const u1* runtime_visible_type_annotations = NULL;
3306     int runtime_visible_type_annotations_length = 0;
3307     const u1* runtime_invisible_type_annotations = NULL;
3308     int runtime_invisible_type_annotations_length = 0;
3309     bool runtime_invisible_type_annotations_exists = false;
3310 
3311     // Expected attributes for record components are Signature, Runtime(In)VisibleAnnotations,
3312     // and Runtime(In)VisibleTypeAnnotations.  Other attributes are ignored.
3313     for (int y = 0; y &lt; attributes_count; y++) {
3314       cfs-&gt;guarantee_more(6, CHECK_0);  // attribute_name_index, attribute_length
3315       const u2 attribute_name_index = cfs-&gt;get_u2_fast();
3316       const u4 attribute_length = cfs-&gt;get_u4_fast();
3317       calculate_attr_size += 6;
3318       check_property(
3319         valid_symbol_at(attribute_name_index),
3320         &quot;Invalid Record attribute name index %u in class file %s&quot;,
3321         attribute_name_index, CHECK_0);
3322 
3323       const Symbol* const attribute_name = cp-&gt;symbol_at(attribute_name_index);
3324       if (attribute_name == vmSymbols::tag_signature()) {
3325         if (generic_sig_index != 0) {
3326           classfile_parse_error(
3327             &quot;Multiple Signature attributes for Record component in class file %s&quot;,
3328             CHECK_0);
3329         }
3330         if (attribute_length != 2) {
3331           classfile_parse_error(
3332             &quot;Invalid Signature attribute length %u in Record component in class file %s&quot;,
3333             attribute_length, CHECK_0);
3334         }
3335         generic_sig_index = parse_generic_signature_attribute(cfs, CHECK_0);
3336 
3337       } else if (attribute_name == vmSymbols::tag_runtime_visible_annotations()) {
3338         if (runtime_visible_annotations != NULL) {
3339           classfile_parse_error(
3340             &quot;Multiple RuntimeVisibleAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3341         }
3342         runtime_visible_annotations_length = attribute_length;
3343         runtime_visible_annotations = cfs-&gt;current();
3344 
3345         assert(runtime_visible_annotations != NULL, &quot;null record component visible annotation&quot;);
3346         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK_0);
3347         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
3348 
3349       } else if (attribute_name == vmSymbols::tag_runtime_invisible_annotations()) {
3350         if (runtime_invisible_annotations_exists) {
3351           classfile_parse_error(
3352             &quot;Multiple RuntimeInvisibleAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3353         }
3354         runtime_invisible_annotations_exists = true;
3355         if (PreserveAllAnnotations) {
3356           runtime_invisible_annotations_length = attribute_length;
3357           runtime_invisible_annotations = cfs-&gt;current();
3358           assert(runtime_invisible_annotations != NULL, &quot;null record component invisible annotation&quot;);
3359         }
3360         cfs-&gt;skip_u1(attribute_length, CHECK_0);
3361 
3362       } else if (attribute_name == vmSymbols::tag_runtime_visible_type_annotations()) {
3363         if (runtime_visible_type_annotations != NULL) {
3364           classfile_parse_error(
3365             &quot;Multiple RuntimeVisibleTypeAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3366         }
3367         runtime_visible_type_annotations_length = attribute_length;
3368         runtime_visible_type_annotations = cfs-&gt;current();
3369 
3370         assert(runtime_visible_type_annotations != NULL, &quot;null record component visible type annotation&quot;);
3371         cfs-&gt;guarantee_more(runtime_visible_type_annotations_length, CHECK_0);
3372         cfs-&gt;skip_u1_fast(runtime_visible_type_annotations_length);
3373 
3374       } else if (attribute_name == vmSymbols::tag_runtime_invisible_type_annotations()) {
3375         if (runtime_invisible_type_annotations_exists) {
3376           classfile_parse_error(
3377             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes for Record component in class file %s&quot;, CHECK_0);
3378         }
3379         runtime_invisible_type_annotations_exists = true;
3380         if (PreserveAllAnnotations) {
3381           runtime_invisible_type_annotations_length = attribute_length;
3382           runtime_invisible_type_annotations = cfs-&gt;current();
3383           assert(runtime_invisible_type_annotations != NULL, &quot;null record component invisible type annotation&quot;);
3384         }
3385         cfs-&gt;skip_u1(attribute_length, CHECK_0);
3386 
3387       } else {
3388         // Skip unknown attributes
3389         cfs-&gt;skip_u1(attribute_length, CHECK_0);
3390       }
3391       calculate_attr_size += attribute_length;
3392     } // End of attributes For loop
3393 
3394     AnnotationArray* annotations = assemble_annotations(runtime_visible_annotations,
3395                                                         runtime_visible_annotations_length,
3396                                                         runtime_invisible_annotations,
3397                                                         runtime_invisible_annotations_length,
3398                                                         CHECK_0);
3399     AnnotationArray* type_annotations = assemble_annotations(runtime_visible_type_annotations,
3400                                                              runtime_visible_type_annotations_length,
3401                                                              runtime_invisible_type_annotations,
3402                                                              runtime_invisible_type_annotations_length,
3403                                                              CHECK_0);
3404 
3405     RecordComponent* record_component =
3406       RecordComponent::allocate(_loader_data, name_index, descriptor_index,
3407                                 attributes_count, generic_sig_index,
3408                                 annotations, type_annotations, CHECK_0);
3409     record_components-&gt;at_put(x, record_component);
3410   }  // End of component processing loop
3411 
3412   // Restore buffer&#39;s current position.
3413   cfs-&gt;set_current(current_mark);
3414   return calculate_attr_size;
3415 }
3416 
3417 void ClassFileParser::parse_classfile_synthetic_attribute(TRAPS) {
3418   set_class_synthetic_flag(true);
3419 }
3420 
3421 void ClassFileParser::parse_classfile_signature_attribute(const ClassFileStream* const cfs, TRAPS) {
3422   assert(cfs != NULL, &quot;invariant&quot;);
3423 
3424   const u2 signature_index = cfs-&gt;get_u2(CHECK);
3425   check_property(
3426     valid_symbol_at(signature_index),
3427     &quot;Invalid constant pool index %u in Signature attribute in class file %s&quot;,
3428     signature_index, CHECK);
3429   set_class_generic_signature_index(signature_index);
3430 }
3431 
3432 void ClassFileParser::parse_classfile_bootstrap_methods_attribute(const ClassFileStream* const cfs,
3433                                                                   ConstantPool* cp,
3434                                                                   u4 attribute_byte_length,
3435                                                                   TRAPS) {
3436   assert(cfs != NULL, &quot;invariant&quot;);
3437   assert(cp != NULL, &quot;invariant&quot;);
3438 
3439   const u1* const current_start = cfs-&gt;current();
3440 
3441   guarantee_property(attribute_byte_length &gt;= sizeof(u2),
3442                      &quot;Invalid BootstrapMethods attribute length %u in class file %s&quot;,
3443                      attribute_byte_length,
3444                      CHECK);
3445 
3446   cfs-&gt;guarantee_more(attribute_byte_length, CHECK);
3447 
3448   const int attribute_array_length = cfs-&gt;get_u2_fast();
3449 
3450   guarantee_property(_max_bootstrap_specifier_index &lt; attribute_array_length,
3451                      &quot;Short length on BootstrapMethods in class file %s&quot;,
3452                      CHECK);
3453 
3454 
3455   // The attribute contains a counted array of counted tuples of shorts,
3456   // represending bootstrap specifiers:
3457   //    length*{bootstrap_method_index, argument_count*{argument_index}}
3458   const int operand_count = (attribute_byte_length - sizeof(u2)) / sizeof(u2);
3459   // operand_count = number of shorts in attr, except for leading length
3460 
3461   // The attribute is copied into a short[] array.
3462   // The array begins with a series of short[2] pairs, one for each tuple.
3463   const int index_size = (attribute_array_length * 2);
3464 
3465   Array&lt;u2&gt;* const operands =
3466     MetadataFactory::new_array&lt;u2&gt;(_loader_data, index_size + operand_count, CHECK);
3467 
3468   // Eagerly assign operands so they will be deallocated with the constant
3469   // pool if there is an error.
3470   cp-&gt;set_operands(operands);
3471 
3472   int operand_fill_index = index_size;
3473   const int cp_size = cp-&gt;length();
3474 
3475   for (int n = 0; n &lt; attribute_array_length; n++) {
3476     // Store a 32-bit offset into the header of the operand array.
3477     ConstantPool::operand_offset_at_put(operands, n, operand_fill_index);
3478 
3479     // Read a bootstrap specifier.
3480     cfs-&gt;guarantee_more(sizeof(u2) * 2, CHECK);  // bsm, argc
3481     const u2 bootstrap_method_index = cfs-&gt;get_u2_fast();
3482     const u2 argument_count = cfs-&gt;get_u2_fast();
3483     check_property(
3484       valid_cp_range(bootstrap_method_index, cp_size) &amp;&amp;
3485       cp-&gt;tag_at(bootstrap_method_index).is_method_handle(),
3486       &quot;bootstrap_method_index %u has bad constant type in class file %s&quot;,
3487       bootstrap_method_index,
3488       CHECK);
3489 
3490     guarantee_property((operand_fill_index + 1 + argument_count) &lt; operands-&gt;length(),
3491       &quot;Invalid BootstrapMethods num_bootstrap_methods or num_bootstrap_arguments value in class file %s&quot;,
3492       CHECK);
3493 
3494     operands-&gt;at_put(operand_fill_index++, bootstrap_method_index);
3495     operands-&gt;at_put(operand_fill_index++, argument_count);
3496 
3497     cfs-&gt;guarantee_more(sizeof(u2) * argument_count, CHECK);  // argv[argc]
3498     for (int j = 0; j &lt; argument_count; j++) {
3499       const u2 argument_index = cfs-&gt;get_u2_fast();
3500       check_property(
3501         valid_cp_range(argument_index, cp_size) &amp;&amp;
3502         cp-&gt;tag_at(argument_index).is_loadable_constant(),
3503         &quot;argument_index %u has bad constant type in class file %s&quot;,
3504         argument_index,
3505         CHECK);
3506       operands-&gt;at_put(operand_fill_index++, argument_index);
3507     }
3508   }
3509   guarantee_property(current_start + attribute_byte_length == cfs-&gt;current(),
3510                      &quot;Bad length on BootstrapMethods in class file %s&quot;,
3511                      CHECK);
3512 }
3513 
3514 bool ClassFileParser::supports_sealed_types() {
3515   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
3516          _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
3517          Arguments::enable_preview();
3518 }
3519 
3520 bool ClassFileParser::supports_records() {
3521   return _major_version == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
3522          _minor_version == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
3523          Arguments::enable_preview();
3524 }
3525 
3526 void ClassFileParser::parse_classfile_attributes(const ClassFileStream* const cfs,
3527                                                  ConstantPool* cp,
3528                  ClassFileParser::ClassAnnotationCollector* parsed_annotations,
3529                                                  TRAPS) {
3530   assert(cfs != NULL, &quot;invariant&quot;);
3531   assert(cp != NULL, &quot;invariant&quot;);
3532   assert(parsed_annotations != NULL, &quot;invariant&quot;);
3533 
3534   // Set inner classes attribute to default sentinel
3535   _inner_classes = Universe::the_empty_short_array();
3536   // Set nest members attribute to default sentinel
3537   _nest_members = Universe::the_empty_short_array();
3538   // Set _permitted_subclasses attribute to default sentinel
3539   _permitted_subclasses = Universe::the_empty_short_array();
3540   cfs-&gt;guarantee_more(2, CHECK);  // attributes_count
3541   u2 attributes_count = cfs-&gt;get_u2_fast();
3542   bool parsed_sourcefile_attribute = false;
3543   bool parsed_innerclasses_attribute = false;
3544   bool parsed_nest_members_attribute = false;
3545   bool parsed_permitted_subclasses_attribute = false;
3546   bool parsed_nest_host_attribute = false;
3547   bool parsed_record_attribute = false;
3548   bool parsed_enclosingmethod_attribute = false;
3549   bool parsed_bootstrap_methods_attribute = false;
3550   const u1* runtime_visible_annotations = NULL;
3551   int runtime_visible_annotations_length = 0;
3552   const u1* runtime_invisible_annotations = NULL;
3553   int runtime_invisible_annotations_length = 0;
3554   const u1* runtime_visible_type_annotations = NULL;
3555   int runtime_visible_type_annotations_length = 0;
3556   const u1* runtime_invisible_type_annotations = NULL;
3557   int runtime_invisible_type_annotations_length = 0;
3558   bool runtime_invisible_type_annotations_exists = false;
3559   bool runtime_invisible_annotations_exists = false;
3560   bool parsed_source_debug_ext_annotations_exist = false;
3561   const u1* inner_classes_attribute_start = NULL;
3562   u4  inner_classes_attribute_length = 0;
3563   u2  enclosing_method_class_index = 0;
3564   u2  enclosing_method_method_index = 0;
3565   const u1* nest_members_attribute_start = NULL;
3566   u4  nest_members_attribute_length = 0;
3567   const u1* record_attribute_start = NULL;
3568   u4  record_attribute_length = 0;
3569   const u1* permitted_subclasses_attribute_start = NULL;
3570   u4  permitted_subclasses_attribute_length = 0;
3571 
3572   // Iterate over attributes
3573   while (attributes_count--) {
3574     cfs-&gt;guarantee_more(6, CHECK);  // attribute_name_index, attribute_length
3575     const u2 attribute_name_index = cfs-&gt;get_u2_fast();
3576     const u4 attribute_length = cfs-&gt;get_u4_fast();
3577     check_property(
3578       valid_symbol_at(attribute_name_index),
3579       &quot;Attribute name has bad constant pool index %u in class file %s&quot;,
3580       attribute_name_index, CHECK);
3581     const Symbol* const tag = cp-&gt;symbol_at(attribute_name_index);
3582     if (tag == vmSymbols::tag_source_file()) {
3583       // Check for SourceFile tag
3584       if (_need_verify) {
3585         guarantee_property(attribute_length == 2, &quot;Wrong SourceFile attribute length in class file %s&quot;, CHECK);
3586       }
3587       if (parsed_sourcefile_attribute) {
3588         classfile_parse_error(&quot;Multiple SourceFile attributes in class file %s&quot;, CHECK);
3589       } else {
3590         parsed_sourcefile_attribute = true;
3591       }
3592       parse_classfile_sourcefile_attribute(cfs, CHECK);
3593     } else if (tag == vmSymbols::tag_source_debug_extension()) {
3594       // Check for SourceDebugExtension tag
3595       if (parsed_source_debug_ext_annotations_exist) {
3596           classfile_parse_error(
3597             &quot;Multiple SourceDebugExtension attributes in class file %s&quot;, CHECK);
3598       }
3599       parsed_source_debug_ext_annotations_exist = true;
3600       parse_classfile_source_debug_extension_attribute(cfs, (int)attribute_length, CHECK);
3601     } else if (tag == vmSymbols::tag_inner_classes()) {
3602       // Check for InnerClasses tag
3603       if (parsed_innerclasses_attribute) {
3604         classfile_parse_error(&quot;Multiple InnerClasses attributes in class file %s&quot;, CHECK);
3605       } else {
3606         parsed_innerclasses_attribute = true;
3607       }
3608       inner_classes_attribute_start = cfs-&gt;current();
3609       inner_classes_attribute_length = attribute_length;
3610       cfs-&gt;skip_u1(inner_classes_attribute_length, CHECK);
3611     } else if (tag == vmSymbols::tag_synthetic()) {
3612       // Check for Synthetic tag
3613       // Shouldn&#39;t we check that the synthetic flags wasn&#39;t already set? - not required in spec
3614       if (attribute_length != 0) {
3615         classfile_parse_error(
3616           &quot;Invalid Synthetic classfile attribute length %u in class file %s&quot;,
3617           attribute_length, CHECK);
3618       }
3619       parse_classfile_synthetic_attribute(CHECK);
3620     } else if (tag == vmSymbols::tag_deprecated()) {
3621       // Check for Deprecatd tag - 4276120
3622       if (attribute_length != 0) {
3623         classfile_parse_error(
3624           &quot;Invalid Deprecated classfile attribute length %u in class file %s&quot;,
3625           attribute_length, CHECK);
3626       }
3627     } else if (_major_version &gt;= JAVA_1_5_VERSION) {
3628       if (tag == vmSymbols::tag_signature()) {
3629         if (_generic_signature_index != 0) {
3630           classfile_parse_error(
3631             &quot;Multiple Signature attributes in class file %s&quot;, CHECK);
3632         }
3633         if (attribute_length != 2) {
3634           classfile_parse_error(
3635             &quot;Wrong Signature attribute length %u in class file %s&quot;,
3636             attribute_length, CHECK);
3637         }
3638         parse_classfile_signature_attribute(cfs, CHECK);
3639       } else if (tag == vmSymbols::tag_runtime_visible_annotations()) {
3640         if (runtime_visible_annotations != NULL) {
3641           classfile_parse_error(
3642             &quot;Multiple RuntimeVisibleAnnotations attributes in class file %s&quot;, CHECK);
3643         }
3644         runtime_visible_annotations_length = attribute_length;
3645         runtime_visible_annotations = cfs-&gt;current();
3646         assert(runtime_visible_annotations != NULL, &quot;null visible annotations&quot;);
3647         cfs-&gt;guarantee_more(runtime_visible_annotations_length, CHECK);
3648         parse_annotations(cp,
3649                           runtime_visible_annotations,
3650                           runtime_visible_annotations_length,
3651                           parsed_annotations,
3652                           _loader_data,
3653                           _can_access_vm_annotations,
3654                           CHECK);
3655         cfs-&gt;skip_u1_fast(runtime_visible_annotations_length);
3656       } else if (tag == vmSymbols::tag_runtime_invisible_annotations()) {
3657         if (runtime_invisible_annotations_exists) {
3658           classfile_parse_error(
3659             &quot;Multiple RuntimeInvisibleAnnotations attributes in class file %s&quot;, CHECK);
3660         }
3661         runtime_invisible_annotations_exists = true;
3662         if (PreserveAllAnnotations) {
3663           runtime_invisible_annotations_length = attribute_length;
3664           runtime_invisible_annotations = cfs-&gt;current();
3665           assert(runtime_invisible_annotations != NULL, &quot;null invisible annotations&quot;);
3666         }
3667         cfs-&gt;skip_u1(attribute_length, CHECK);
3668       } else if (tag == vmSymbols::tag_enclosing_method()) {
3669         if (parsed_enclosingmethod_attribute) {
3670           classfile_parse_error(&quot;Multiple EnclosingMethod attributes in class file %s&quot;, CHECK);
3671         } else {
3672           parsed_enclosingmethod_attribute = true;
3673         }
3674         guarantee_property(attribute_length == 4,
3675           &quot;Wrong EnclosingMethod attribute length %u in class file %s&quot;,
3676           attribute_length, CHECK);
3677         cfs-&gt;guarantee_more(4, CHECK);  // class_index, method_index
3678         enclosing_method_class_index  = cfs-&gt;get_u2_fast();
3679         enclosing_method_method_index = cfs-&gt;get_u2_fast();
3680         if (enclosing_method_class_index == 0) {
3681           classfile_parse_error(&quot;Invalid class index in EnclosingMethod attribute in class file %s&quot;, CHECK);
3682         }
3683         // Validate the constant pool indices and types
3684         check_property(valid_klass_reference_at(enclosing_method_class_index),
3685           &quot;Invalid or out-of-bounds class index in EnclosingMethod attribute in class file %s&quot;, CHECK);
3686         if (enclosing_method_method_index != 0 &amp;&amp;
3687             (!cp-&gt;is_within_bounds(enclosing_method_method_index) ||
3688              !cp-&gt;tag_at(enclosing_method_method_index).is_name_and_type())) {
3689           classfile_parse_error(&quot;Invalid or out-of-bounds method index in EnclosingMethod attribute in class file %s&quot;, CHECK);
3690         }
3691       } else if (tag == vmSymbols::tag_bootstrap_methods() &amp;&amp;
3692                  _major_version &gt;= Verifier::INVOKEDYNAMIC_MAJOR_VERSION) {
3693         if (parsed_bootstrap_methods_attribute) {
3694           classfile_parse_error(&quot;Multiple BootstrapMethods attributes in class file %s&quot;, CHECK);
3695         }
3696         parsed_bootstrap_methods_attribute = true;
3697         parse_classfile_bootstrap_methods_attribute(cfs, cp, attribute_length, CHECK);
3698       } else if (tag == vmSymbols::tag_runtime_visible_type_annotations()) {
3699         if (runtime_visible_type_annotations != NULL) {
3700           classfile_parse_error(
3701             &quot;Multiple RuntimeVisibleTypeAnnotations attributes in class file %s&quot;, CHECK);
3702         }
3703         runtime_visible_type_annotations_length = attribute_length;
3704         runtime_visible_type_annotations = cfs-&gt;current();
3705         assert(runtime_visible_type_annotations != NULL, &quot;null visible type annotations&quot;);
3706         // No need for the VM to parse Type annotations
3707         cfs-&gt;skip_u1(runtime_visible_type_annotations_length, CHECK);
3708       } else if (tag == vmSymbols::tag_runtime_invisible_type_annotations()) {
3709         if (runtime_invisible_type_annotations_exists) {
3710           classfile_parse_error(
3711             &quot;Multiple RuntimeInvisibleTypeAnnotations attributes in class file %s&quot;, CHECK);
3712         } else {
3713           runtime_invisible_type_annotations_exists = true;
3714         }
3715         if (PreserveAllAnnotations) {
3716           runtime_invisible_type_annotations_length = attribute_length;
3717           runtime_invisible_type_annotations = cfs-&gt;current();
3718           assert(runtime_invisible_type_annotations != NULL, &quot;null invisible type annotations&quot;);
3719         }
3720         cfs-&gt;skip_u1(attribute_length, CHECK);
3721       } else if (_major_version &gt;= JAVA_11_VERSION) {
3722         if (tag == vmSymbols::tag_nest_members()) {
3723           // Check for NestMembers tag
3724           if (parsed_nest_members_attribute) {
3725             classfile_parse_error(&quot;Multiple NestMembers attributes in class file %s&quot;, CHECK);
3726           } else {
3727             parsed_nest_members_attribute = true;
3728           }
3729           if (parsed_nest_host_attribute) {
3730             classfile_parse_error(&quot;Conflicting NestHost and NestMembers attributes in class file %s&quot;, CHECK);
3731           }
3732           nest_members_attribute_start = cfs-&gt;current();
3733           nest_members_attribute_length = attribute_length;
3734           cfs-&gt;skip_u1(nest_members_attribute_length, CHECK);
3735         } else if (tag == vmSymbols::tag_nest_host()) {
3736           if (parsed_nest_host_attribute) {
3737             classfile_parse_error(&quot;Multiple NestHost attributes in class file %s&quot;, CHECK);
3738           } else {
3739             parsed_nest_host_attribute = true;
3740           }
3741           if (parsed_nest_members_attribute) {
3742             classfile_parse_error(&quot;Conflicting NestMembers and NestHost attributes in class file %s&quot;, CHECK);
3743           }
3744           if (_need_verify) {
3745             guarantee_property(attribute_length == 2, &quot;Wrong NestHost attribute length in class file %s&quot;, CHECK);
3746           }
3747           cfs-&gt;guarantee_more(2, CHECK);
3748           u2 class_info_index = cfs-&gt;get_u2_fast();
3749           check_property(
3750                          valid_klass_reference_at(class_info_index),
3751                          &quot;Nest-host class_info_index %u has bad constant type in class file %s&quot;,
3752                          class_info_index, CHECK);
3753           _nest_host = class_info_index;
3754         } else if (_major_version &gt;= JAVA_14_VERSION) {
3755           if (tag == vmSymbols::tag_record()) {
3756             // Skip over Record attribute if not supported or if super class is
3757             // not java.lang.Record.
3758             if (supports_records() &amp;&amp;
3759                 cp-&gt;klass_name_at(_super_class_index) == vmSymbols::java_lang_Record()) {
3760               if (parsed_record_attribute) {
3761                 classfile_parse_error(&quot;Multiple Record attributes in class file %s&quot;, CHECK);
3762               }
3763               // Check that class is final and not abstract.
3764               if (!_access_flags.is_final() || _access_flags.is_abstract()) {
3765                 classfile_parse_error(&quot;Record attribute in non-final or abstract class file %s&quot;, CHECK);
3766               }
3767               parsed_record_attribute = true;
3768               record_attribute_start = cfs-&gt;current();
3769               record_attribute_length = attribute_length;
3770             } else if (log_is_enabled(Info, class, record)) {
3771               // Log why the Record attribute was ignored.  Note that if the
3772               // class file version is JVM_CLASSFILE_MAJOR_VERSION.65535 and
3773               // --enable-preview wasn&#39;t specified then a java.lang.UnsupportedClassVersionError
3774               // exception would have been thrown.
3775               ResourceMark rm(THREAD);
3776               if (supports_records()) {
3777                 log_info(class, record)(
3778                   &quot;Ignoring Record attribute in class %s because super type is not java.lang.Record&quot;,
3779                   _class_name-&gt;as_C_string());
3780               } else {
3781                 log_info(class, record)(
3782                   &quot;Ignoring Record attribute in class %s because class file version is not %d.65535&quot;,
3783                    _class_name-&gt;as_C_string(), JVM_CLASSFILE_MAJOR_VERSION);
3784               }
3785             }
3786             cfs-&gt;skip_u1(attribute_length, CHECK);
3787           } else if (_major_version &gt;= JAVA_15_VERSION) {
3788             // Check for PermittedSubclasses tag
3789             if (tag == vmSymbols::tag_permitted_subclasses()) {
3790               if (supports_sealed_types()) {
3791                 if (parsed_permitted_subclasses_attribute) {
3792                   classfile_parse_error(&quot;Multiple PermittedSubclasses attributes in class file %s&quot;, CHECK);
3793                 }
3794                 // Classes marked ACC_FINAL cannot have a PermittedSubclasses attribute.
3795                 if (_access_flags.is_final()) {
3796                   classfile_parse_error(&quot;PermittedSubclasses attribute in final class file %s&quot;, CHECK);
3797                 }
3798                 parsed_permitted_subclasses_attribute = true;
3799                 permitted_subclasses_attribute_start = cfs-&gt;current();
3800                 permitted_subclasses_attribute_length = attribute_length;
3801               }
3802               cfs-&gt;skip_u1(attribute_length, CHECK);
3803             } else {
3804               // Unknown attribute
3805               cfs-&gt;skip_u1(attribute_length, CHECK);
3806             }
3807           } else {
3808             // Unknown attribute
3809             cfs-&gt;skip_u1(attribute_length, CHECK);
3810           }
3811         } else {
3812           // Unknown attribute
3813           cfs-&gt;skip_u1(attribute_length, CHECK);
3814         }
3815       } else {
3816         // Unknown attribute
3817         cfs-&gt;skip_u1(attribute_length, CHECK);
3818       }
3819     } else {
3820       // Unknown attribute
3821       cfs-&gt;skip_u1(attribute_length, CHECK);
3822     }
3823   }
3824   _class_annotations = assemble_annotations(runtime_visible_annotations,
3825                                             runtime_visible_annotations_length,
3826                                             runtime_invisible_annotations,
3827                                             runtime_invisible_annotations_length,
3828                                             CHECK);
3829   _class_type_annotations = assemble_annotations(runtime_visible_type_annotations,
3830                                                  runtime_visible_type_annotations_length,
3831                                                  runtime_invisible_type_annotations,
3832                                                  runtime_invisible_type_annotations_length,
3833                                                  CHECK);
3834 
3835   if (parsed_innerclasses_attribute || parsed_enclosingmethod_attribute) {
3836     const u2 num_of_classes = parse_classfile_inner_classes_attribute(
3837                             cfs,
3838                             inner_classes_attribute_start,
3839                             parsed_innerclasses_attribute,
3840                             enclosing_method_class_index,
3841                             enclosing_method_method_index,
3842                             CHECK);
3843     if (parsed_innerclasses_attribute &amp;&amp; _need_verify &amp;&amp; _major_version &gt;= JAVA_1_5_VERSION) {
3844       guarantee_property(
3845         inner_classes_attribute_length == sizeof(num_of_classes) + 4 * sizeof(u2) * num_of_classes,
3846         &quot;Wrong InnerClasses attribute length in class file %s&quot;, CHECK);
3847     }
3848   }
3849 
3850   if (parsed_nest_members_attribute) {
3851     const u2 num_of_classes = parse_classfile_nest_members_attribute(
3852                             cfs,
3853                             nest_members_attribute_start,
3854                             CHECK);
3855     if (_need_verify) {
3856       guarantee_property(
3857         nest_members_attribute_length == sizeof(num_of_classes) + sizeof(u2) * num_of_classes,
3858         &quot;Wrong NestMembers attribute length in class file %s&quot;, CHECK);
3859     }
3860   }
3861 
3862   if (parsed_record_attribute) {
3863     const unsigned int calculated_attr_length = parse_classfile_record_attribute(
3864                             cfs,
3865                             cp,
3866                             record_attribute_start,
3867                             CHECK);
3868     if (_need_verify) {
3869       guarantee_property(record_attribute_length == calculated_attr_length,
3870                          &quot;Record attribute has wrong length in class file %s&quot;,
3871                          CHECK);
3872     }
3873   }
3874 
3875   if (parsed_permitted_subclasses_attribute) {
3876     const u2 num_subclasses = parse_classfile_permitted_subclasses_attribute(
3877                             cfs,
3878                             permitted_subclasses_attribute_start,
3879                             CHECK);
3880     if (_need_verify) {
3881       guarantee_property(
3882         permitted_subclasses_attribute_length == sizeof(num_subclasses) + sizeof(u2) * num_subclasses,
3883         &quot;Wrong PermittedSubclasses attribute length in class file %s&quot;, CHECK);
3884     }
3885   }
3886 
3887   if (_max_bootstrap_specifier_index &gt;= 0) {
3888     guarantee_property(parsed_bootstrap_methods_attribute,
3889                        &quot;Missing BootstrapMethods attribute in class file %s&quot;, CHECK);
3890   }
3891 }
3892 
3893 void ClassFileParser::apply_parsed_class_attributes(InstanceKlass* k) {
3894   assert(k != NULL, &quot;invariant&quot;);
3895 
3896   if (_synthetic_flag)
3897     k-&gt;set_is_synthetic();
3898   if (_sourcefile_index != 0) {
3899     k-&gt;set_source_file_name_index(_sourcefile_index);
3900   }
3901   if (_generic_signature_index != 0) {
3902     k-&gt;set_generic_signature_index(_generic_signature_index);
3903   }
3904   if (_sde_buffer != NULL) {
3905     k-&gt;set_source_debug_extension(_sde_buffer, _sde_length);
3906   }
3907 }
3908 
3909 // Create the Annotations object that will
3910 // hold the annotations array for the Klass.
3911 void ClassFileParser::create_combined_annotations(TRAPS) {
3912     if (_class_annotations == NULL &amp;&amp;
3913         _class_type_annotations == NULL &amp;&amp;
3914         _fields_annotations == NULL &amp;&amp;
3915         _fields_type_annotations == NULL) {
3916       // Don&#39;t create the Annotations object unnecessarily.
3917       return;
3918     }
3919 
3920     Annotations* const annotations = Annotations::allocate(_loader_data, CHECK);
3921     annotations-&gt;set_class_annotations(_class_annotations);
3922     annotations-&gt;set_class_type_annotations(_class_type_annotations);
3923     annotations-&gt;set_fields_annotations(_fields_annotations);
3924     annotations-&gt;set_fields_type_annotations(_fields_type_annotations);
3925 
3926     // This is the Annotations object that will be
3927     // assigned to InstanceKlass being constructed.
3928     _combined_annotations = annotations;
3929 
3930     // The annotations arrays below has been transfered the
3931     // _combined_annotations so these fields can now be cleared.
3932     _class_annotations       = NULL;
3933     _class_type_annotations  = NULL;
3934     _fields_annotations      = NULL;
3935     _fields_type_annotations = NULL;
3936 }
3937 
3938 // Transfer ownership of metadata allocated to the InstanceKlass.
3939 void ClassFileParser::apply_parsed_class_metadata(
3940                                             InstanceKlass* this_klass,
3941                                             int java_fields_count,
3942                                             TRAPS) {
3943   assert(this_klass != NULL, &quot;invariant&quot;);
3944 
3945   _cp-&gt;set_pool_holder(this_klass);
3946   this_klass-&gt;set_constants(_cp);
3947   this_klass-&gt;set_fields(_fields, java_fields_count);
3948   this_klass-&gt;set_methods(_methods);
3949   this_klass-&gt;set_inner_classes(_inner_classes);
3950   this_klass-&gt;set_nest_members(_nest_members);
3951   this_klass-&gt;set_nest_host_index(_nest_host);
3952   this_klass-&gt;set_annotations(_combined_annotations);
3953   this_klass-&gt;set_permitted_subclasses(_permitted_subclasses);
3954   this_klass-&gt;set_record_components(_record_components);
3955   // Delay the setting of _local_interfaces and _transitive_interfaces until after
3956   // initialize_supers() in fill_instance_klass(). It is because the _local_interfaces could
3957   // be shared with _transitive_interfaces and _transitive_interfaces may be shared with
3958   // its _super. If an OOM occurs while loading the current klass, its _super field
3959   // may not have been set. When GC tries to free the klass, the _transitive_interfaces
3960   // may be deallocated mistakenly in InstanceKlass::deallocate_interfaces(). Subsequent
3961   // dereferences to the deallocated _transitive_interfaces will result in a crash.
3962 
3963   // Clear out these fields so they don&#39;t get deallocated by the destructor
3964   clear_class_metadata();
3965 }
3966 
3967 AnnotationArray* ClassFileParser::assemble_annotations(const u1* const runtime_visible_annotations,
3968                                                        int runtime_visible_annotations_length,
3969                                                        const u1* const runtime_invisible_annotations,
3970                                                        int runtime_invisible_annotations_length,
3971                                                        TRAPS) {
3972   AnnotationArray* annotations = NULL;
3973   if (runtime_visible_annotations != NULL ||
3974       runtime_invisible_annotations != NULL) {
3975     annotations = MetadataFactory::new_array&lt;u1&gt;(_loader_data,
3976                                           runtime_visible_annotations_length +
3977                                           runtime_invisible_annotations_length,
3978                                           CHECK_(annotations));
3979     if (runtime_visible_annotations != NULL) {
3980       for (int i = 0; i &lt; runtime_visible_annotations_length; i++) {
3981         annotations-&gt;at_put(i, runtime_visible_annotations[i]);
3982       }
3983     }
3984     if (runtime_invisible_annotations != NULL) {
3985       for (int i = 0; i &lt; runtime_invisible_annotations_length; i++) {
3986         int append = runtime_visible_annotations_length+i;
3987         annotations-&gt;at_put(append, runtime_invisible_annotations[i]);
3988       }
3989     }
3990   }
3991   return annotations;
3992 }
3993 
3994 const InstanceKlass* ClassFileParser::parse_super_class(ConstantPool* const cp,
3995                                                         const int super_class_index,
3996                                                         const bool need_verify,
3997                                                         TRAPS) {
3998   assert(cp != NULL, &quot;invariant&quot;);
3999   const InstanceKlass* super_klass = NULL;
4000 
4001   if (super_class_index == 0) {
<a name="42" id="anc42"></a><span class="line-modified">4002     check_property(_class_name == vmSymbols::java_lang_Object(),</span>

4003                    &quot;Invalid superclass index %u in class file %s&quot;,
4004                    super_class_index,
4005                    CHECK_NULL);
4006   } else {
4007     check_property(valid_klass_reference_at(super_class_index),
4008                    &quot;Invalid superclass index %u in class file %s&quot;,
4009                    super_class_index,
4010                    CHECK_NULL);
4011     // The class name should be legal because it is checked when parsing constant pool.
4012     // However, make sure it is not an array type.
4013     bool is_array = false;
4014     if (cp-&gt;tag_at(super_class_index).is_klass()) {
4015       super_klass = InstanceKlass::cast(cp-&gt;resolved_klass_at(super_class_index));
4016       if (need_verify)
4017         is_array = super_klass-&gt;is_array_klass();
4018     } else if (need_verify) {
4019       is_array = (cp-&gt;klass_name_at(super_class_index)-&gt;char_at(0) == JVM_SIGNATURE_ARRAY);
4020     }
4021     if (need_verify) {
4022       guarantee_property(!is_array,
4023                         &quot;Bad superclass name in class file %s&quot;, CHECK_NULL);
4024     }
4025   }
4026   return super_klass;
4027 }
4028 
4029 #ifndef PRODUCT
4030 static void print_field_layout(const Symbol* name,
4031                                Array&lt;u2&gt;* fields,
4032                                ConstantPool* cp,
4033                                int instance_size,
4034                                int instance_fields_start,
4035                                int instance_fields_end,
4036                                int static_fields_end) {
4037 
4038   assert(name != NULL, &quot;invariant&quot;);
4039 
4040   tty-&gt;print(&quot;%s: field layout\n&quot;, name-&gt;as_klass_external_name());
4041   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_fields_start, &quot;--- instance fields start ---&quot;);
4042   for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {
4043     if (!fs.access_flags().is_static()) {
4044       tty-&gt;print(&quot;  @%3d \&quot;%s\&quot; %s\n&quot;,
4045         fs.offset(),
4046         fs.name()-&gt;as_klass_external_name(),
4047         fs.signature()-&gt;as_klass_external_name());
4048     }
4049   }
4050   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_fields_end, &quot;--- instance fields end ---&quot;);
4051   tty-&gt;print(&quot;  @%3d %s\n&quot;, instance_size * wordSize, &quot;--- instance ends ---&quot;);
4052   tty-&gt;print(&quot;  @%3d %s\n&quot;, InstanceMirrorKlass::offset_of_static_fields(), &quot;--- static fields start ---&quot;);
4053   for (AllFieldStream fs(fields, cp); !fs.done(); fs.next()) {
4054     if (fs.access_flags().is_static()) {
4055       tty-&gt;print(&quot;  @%3d \&quot;%s\&quot; %s\n&quot;,
4056         fs.offset(),
4057         fs.name()-&gt;as_klass_external_name(),
4058         fs.signature()-&gt;as_klass_external_name());
4059     }
4060   }
4061   tty-&gt;print(&quot;  @%3d %s\n&quot;, static_fields_end, &quot;--- static fields end ---&quot;);
4062   tty-&gt;print(&quot;\n&quot;);
4063 }
4064 #endif
4065 
4066 OopMapBlocksBuilder::OopMapBlocksBuilder(unsigned int max_blocks) {
4067   _max_nonstatic_oop_maps = max_blocks;
4068   _nonstatic_oop_map_count = 0;
4069   if (max_blocks == 0) {
4070     _nonstatic_oop_maps = NULL;
4071   } else {
4072     _nonstatic_oop_maps =
4073         NEW_RESOURCE_ARRAY(OopMapBlock, _max_nonstatic_oop_maps);
4074     memset(_nonstatic_oop_maps, 0, sizeof(OopMapBlock) * max_blocks);
4075   }
4076 }
4077 
4078 OopMapBlock* OopMapBlocksBuilder::last_oop_map() const {
4079   assert(_nonstatic_oop_map_count &gt; 0, &quot;Has no oop maps&quot;);
4080   return _nonstatic_oop_maps + (_nonstatic_oop_map_count - 1);
4081 }
4082 
4083 // addition of super oop maps
4084 void OopMapBlocksBuilder::initialize_inherited_blocks(OopMapBlock* blocks, unsigned int nof_blocks) {
4085   assert(nof_blocks &amp;&amp; _nonstatic_oop_map_count == 0 &amp;&amp;
4086          nof_blocks &lt;= _max_nonstatic_oop_maps, &quot;invariant&quot;);
4087 
4088   memcpy(_nonstatic_oop_maps, blocks, sizeof(OopMapBlock) * nof_blocks);
4089   _nonstatic_oop_map_count += nof_blocks;
4090 }
4091 
4092 // collection of oops
4093 void OopMapBlocksBuilder::add(int offset, int count) {
4094   if (_nonstatic_oop_map_count == 0) {
4095     _nonstatic_oop_map_count++;
4096   }
4097   OopMapBlock* nonstatic_oop_map = last_oop_map();
4098   if (nonstatic_oop_map-&gt;count() == 0) {  // Unused map, set it up
4099     nonstatic_oop_map-&gt;set_offset(offset);
4100     nonstatic_oop_map-&gt;set_count(count);
4101   } else if (nonstatic_oop_map-&gt;is_contiguous(offset)) { // contiguous, add
4102     nonstatic_oop_map-&gt;increment_count(count);
4103   } else { // Need a new one...
4104     _nonstatic_oop_map_count++;
4105     assert(_nonstatic_oop_map_count &lt;= _max_nonstatic_oop_maps, &quot;range check&quot;);
4106     nonstatic_oop_map = last_oop_map();
4107     nonstatic_oop_map-&gt;set_offset(offset);
4108     nonstatic_oop_map-&gt;set_count(count);
4109   }
4110 }
4111 
4112 // general purpose copy, e.g. into allocated instanceKlass
4113 void OopMapBlocksBuilder::copy(OopMapBlock* dst) {
4114   if (_nonstatic_oop_map_count != 0) {
4115     memcpy(dst, _nonstatic_oop_maps, sizeof(OopMapBlock) * _nonstatic_oop_map_count);
4116   }
4117 }
4118 
4119 // Sort and compact adjacent blocks
4120 void OopMapBlocksBuilder::compact() {
4121   if (_nonstatic_oop_map_count &lt;= 1) {
4122     return;
4123   }
4124   /*
4125    * Since field layout sneeks in oops before values, we will be able to condense
4126    * blocks. There is potential to compact between super, own refs and values
4127    * containing refs.
4128    *
4129    * Currently compaction is slightly limited due to values being 8 byte aligned.
4130    * This may well change: FixMe if it doesn&#39;t, the code below is fairly general purpose
4131    * and maybe it doesn&#39;t need to be.
4132    */
4133   qsort(_nonstatic_oop_maps, _nonstatic_oop_map_count, sizeof(OopMapBlock),
4134         (_sort_Fn)OopMapBlock::compare_offset);
4135   if (_nonstatic_oop_map_count &lt; 2) {
4136     return;
4137   }
4138 
4139   // Make a temp copy, and iterate through and copy back into the original
4140   ResourceMark rm;
4141   OopMapBlock* oop_maps_copy =
4142       NEW_RESOURCE_ARRAY(OopMapBlock, _nonstatic_oop_map_count);
4143   OopMapBlock* oop_maps_copy_end = oop_maps_copy + _nonstatic_oop_map_count;
4144   copy(oop_maps_copy);
4145   OopMapBlock* nonstatic_oop_map = _nonstatic_oop_maps;
4146   unsigned int new_count = 1;
4147   oop_maps_copy++;
4148   while(oop_maps_copy &lt; oop_maps_copy_end) {
4149     assert(nonstatic_oop_map-&gt;offset() &lt; oop_maps_copy-&gt;offset(), &quot;invariant&quot;);
4150     if (nonstatic_oop_map-&gt;is_contiguous(oop_maps_copy-&gt;offset())) {
4151       nonstatic_oop_map-&gt;increment_count(oop_maps_copy-&gt;count());
4152     } else {
4153       nonstatic_oop_map++;
4154       new_count++;
4155       nonstatic_oop_map-&gt;set_offset(oop_maps_copy-&gt;offset());
4156       nonstatic_oop_map-&gt;set_count(oop_maps_copy-&gt;count());
4157     }
4158     oop_maps_copy++;
4159   }
4160   assert(new_count &lt;= _nonstatic_oop_map_count, &quot;end up with more maps after compact() ?&quot;);
4161   _nonstatic_oop_map_count = new_count;
4162 }
4163 
4164 void OopMapBlocksBuilder::print_on(outputStream* st) const {
4165   st-&gt;print_cr(&quot;  OopMapBlocks: %3d  /%3d&quot;, _nonstatic_oop_map_count, _max_nonstatic_oop_maps);
4166   if (_nonstatic_oop_map_count &gt; 0) {
4167     OopMapBlock* map = _nonstatic_oop_maps;
4168     OopMapBlock* last_map = last_oop_map();
4169     assert(map &lt;= last_map, &quot;Last less than first&quot;);
4170     while (map &lt;= last_map) {
4171       st-&gt;print_cr(&quot;    Offset: %3d  -%3d Count: %3d&quot;, map-&gt;offset(),
4172                    map-&gt;offset() + map-&gt;offset_span() - heapOopSize, map-&gt;count());
4173       map++;
4174     }
4175   }
4176 }
4177 
4178 void OopMapBlocksBuilder::print_value_on(outputStream* st) const {
4179   print_on(st);
4180 }
4181 
<a name="43" id="anc43"></a>


















4182 // Layout fields and fill in FieldLayoutInfo.  Could use more refactoring!
4183 void ClassFileParser::layout_fields(ConstantPool* cp,
4184                                     const FieldAllocationCount* fac,
4185                                     const ClassAnnotationCollector* parsed_annotations,
4186                                     FieldLayoutInfo* info,
4187                                     TRAPS) {
4188 
4189   assert(cp != NULL, &quot;invariant&quot;);
4190 
4191   // Field size and offset computation
4192   int nonstatic_field_size = _super_klass == NULL ? 0 :
4193                                _super_klass-&gt;nonstatic_field_size();
<a name="44" id="anc44"></a>





4194 
4195   // Count the contended fields by type.
4196   //
4197   // We ignore static fields, because @Contended is not supported for them.
4198   // The layout code below will also ignore the static fields.
4199   int nonstatic_contended_count = 0;
4200   FieldAllocationCount fac_contended;
4201   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4202     FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4203     if (fs.is_contended()) {
4204       fac_contended.count[atype]++;
4205       if (!fs.access_flags().is_static()) {
4206         nonstatic_contended_count++;
4207       }
4208     }
4209   }
4210 
4211 
4212   // Calculate the starting byte offsets
4213   int next_static_oop_offset    = InstanceMirrorKlass::offset_of_static_fields();
<a name="45" id="anc45"></a>
4214   int next_static_double_offset = next_static_oop_offset +
<a name="46" id="anc46"></a><span class="line-modified">4215                                       ((fac-&gt;count[STATIC_OOP]) * heapOopSize);</span>
4216   if (fac-&gt;count[STATIC_DOUBLE]) {
4217     next_static_double_offset = align_up(next_static_double_offset, BytesPerLong);
4218   }
4219 
4220   int next_static_word_offset   = next_static_double_offset +
4221                                     ((fac-&gt;count[STATIC_DOUBLE]) * BytesPerLong);
4222   int next_static_short_offset  = next_static_word_offset +
4223                                     ((fac-&gt;count[STATIC_WORD]) * BytesPerInt);
4224   int next_static_byte_offset   = next_static_short_offset +
4225                                   ((fac-&gt;count[STATIC_SHORT]) * BytesPerShort);
4226 
4227   int nonstatic_fields_start  = instanceOopDesc::base_offset_in_bytes() +
4228                                 nonstatic_field_size * heapOopSize;
4229 
<a name="47" id="anc47"></a>









4230   int next_nonstatic_field_offset = nonstatic_fields_start;
4231 
4232   const bool is_contended_class     = parsed_annotations-&gt;is_contended();
4233 
4234   // Class is contended, pad before all the fields
4235   if (is_contended_class) {
4236     next_nonstatic_field_offset += ContendedPaddingWidth;
4237   }
4238 
<a name="48" id="anc48"></a>







4239   // Compute the non-contended fields count.
4240   // The packing code below relies on these counts to determine if some field
4241   // can be squeezed into the alignment gap. Contended fields are obviously
4242   // exempt from that.
4243   unsigned int nonstatic_double_count = fac-&gt;count[NONSTATIC_DOUBLE] - fac_contended.count[NONSTATIC_DOUBLE];
4244   unsigned int nonstatic_word_count   = fac-&gt;count[NONSTATIC_WORD]   - fac_contended.count[NONSTATIC_WORD];
4245   unsigned int nonstatic_short_count  = fac-&gt;count[NONSTATIC_SHORT]  - fac_contended.count[NONSTATIC_SHORT];
4246   unsigned int nonstatic_byte_count   = fac-&gt;count[NONSTATIC_BYTE]   - fac_contended.count[NONSTATIC_BYTE];
4247   unsigned int nonstatic_oop_count    = fac-&gt;count[NONSTATIC_OOP]    - fac_contended.count[NONSTATIC_OOP];
4248 
<a name="49" id="anc49"></a>








































































4249   // Total non-static fields count, including every contended field
4250   unsigned int nonstatic_fields_count = fac-&gt;count[NONSTATIC_DOUBLE] + fac-&gt;count[NONSTATIC_WORD] +
4251                                         fac-&gt;count[NONSTATIC_SHORT] + fac-&gt;count[NONSTATIC_BYTE] +
<a name="50" id="anc50"></a><span class="line-modified">4252                                         fac-&gt;count[NONSTATIC_OOP];</span>
4253 
4254   const bool super_has_nonstatic_fields =
4255           (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_nonstatic_fields());
4256   const bool has_nonstatic_fields =
4257     super_has_nonstatic_fields || (nonstatic_fields_count != 0);
<a name="51" id="anc51"></a>
4258 
<a name="52" id="anc52"></a>




4259 
4260   // Prepare list of oops for oop map generation.
4261   //
4262   // &quot;offset&quot; and &quot;count&quot; lists are describing the set of contiguous oop
4263   // regions. offset[i] is the start of the i-th region, which then has
4264   // count[i] oops following. Before we know how many regions are required,
4265   // we pessimistically allocate the maps to fit all the oops into the
4266   // distinct regions.
<a name="53" id="anc53"></a><span class="line-modified">4267 </span>
4268   int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass-&gt;nonstatic_oop_map_count();
<a name="54" id="anc54"></a><span class="line-modified">4269   int max_oop_map_count = super_oop_map_count + fac-&gt;count[NONSTATIC_OOP];</span>




4270 
4271   OopMapBlocksBuilder* nonstatic_oop_maps = new OopMapBlocksBuilder(max_oop_map_count);
4272   if (super_oop_map_count &gt; 0) {
4273     nonstatic_oop_maps-&gt;initialize_inherited_blocks(_super_klass-&gt;start_of_nonstatic_oop_maps(),
4274                                                     _super_klass-&gt;nonstatic_oop_map_count());
4275   }
4276 
4277   int first_nonstatic_oop_offset = 0; // will be set for first oop field
4278 
4279   bool compact_fields  = true;
4280   bool allocate_oops_first = false;
4281 
4282   int next_nonstatic_oop_offset = 0;
4283   int next_nonstatic_double_offset = 0;
4284 
4285   // Rearrange fields for a given allocation style
4286   if (allocate_oops_first) {
4287     // Fields order: oops, longs/doubles, ints, shorts/chars, bytes, padded fields
4288     next_nonstatic_oop_offset    = next_nonstatic_field_offset;
4289     next_nonstatic_double_offset = next_nonstatic_oop_offset +
4290                                     (nonstatic_oop_count * heapOopSize);
4291   } else {
4292     // Fields order: longs/doubles, ints, shorts/chars, bytes, oops, padded fields
4293     next_nonstatic_double_offset = next_nonstatic_field_offset;
4294   }
4295 
4296   int nonstatic_oop_space_count   = 0;
4297   int nonstatic_word_space_count  = 0;
4298   int nonstatic_short_space_count = 0;
4299   int nonstatic_byte_space_count  = 0;
4300   int nonstatic_oop_space_offset = 0;
4301   int nonstatic_word_space_offset = 0;
4302   int nonstatic_short_space_offset = 0;
4303   int nonstatic_byte_space_offset = 0;
4304 
4305   // Try to squeeze some of the fields into the gaps due to
4306   // long/double alignment.
4307   if (nonstatic_double_count &gt; 0) {
4308     int offset = next_nonstatic_double_offset;
4309     next_nonstatic_double_offset = align_up(offset, BytesPerLong);
4310     if (compact_fields &amp;&amp; offset != next_nonstatic_double_offset) {
4311       // Allocate available fields into the gap before double field.
4312       int length = next_nonstatic_double_offset - offset;
4313       assert(length == BytesPerInt, &quot;&quot;);
4314       nonstatic_word_space_offset = offset;
4315       if (nonstatic_word_count &gt; 0) {
4316         nonstatic_word_count      -= 1;
4317         nonstatic_word_space_count = 1; // Only one will fit
4318         length -= BytesPerInt;
4319         offset += BytesPerInt;
4320       }
4321       nonstatic_short_space_offset = offset;
4322       while (length &gt;= BytesPerShort &amp;&amp; nonstatic_short_count &gt; 0) {
4323         nonstatic_short_count       -= 1;
4324         nonstatic_short_space_count += 1;
4325         length -= BytesPerShort;
4326         offset += BytesPerShort;
4327       }
4328       nonstatic_byte_space_offset = offset;
4329       while (length &gt; 0 &amp;&amp; nonstatic_byte_count &gt; 0) {
4330         nonstatic_byte_count       -= 1;
4331         nonstatic_byte_space_count += 1;
4332         length -= 1;
4333       }
4334       // Allocate oop field in the gap if there are no other fields for that.
4335       nonstatic_oop_space_offset = offset;
4336       if (length &gt;= heapOopSize &amp;&amp; nonstatic_oop_count &gt; 0 &amp;&amp;
4337           !allocate_oops_first) { // when oop fields not first
4338         nonstatic_oop_count      -= 1;
4339         nonstatic_oop_space_count = 1; // Only one will fit
4340         length -= heapOopSize;
4341         offset += heapOopSize;
4342       }
4343     }
4344   }
4345 
4346   int next_nonstatic_word_offset = next_nonstatic_double_offset +
4347                                      (nonstatic_double_count * BytesPerLong);
4348   int next_nonstatic_short_offset = next_nonstatic_word_offset +
4349                                       (nonstatic_word_count * BytesPerInt);
4350   int next_nonstatic_byte_offset = next_nonstatic_short_offset +
4351                                      (nonstatic_short_count * BytesPerShort);
4352   int next_nonstatic_padded_offset = next_nonstatic_byte_offset +
4353                                        nonstatic_byte_count;
4354 
4355   // let oops jump before padding with this allocation style
4356   if (!allocate_oops_first) {
4357     next_nonstatic_oop_offset = next_nonstatic_padded_offset;
4358     if( nonstatic_oop_count &gt; 0 ) {
4359       next_nonstatic_oop_offset = align_up(next_nonstatic_oop_offset, heapOopSize);
4360     }
4361     next_nonstatic_padded_offset = next_nonstatic_oop_offset + (nonstatic_oop_count * heapOopSize);
4362   }
4363 
<a name="55" id="anc55"></a>









4364   // Iterate over fields again and compute correct offsets.
4365   // The field allocation type was temporarily stored in the offset slot.
4366   // oop fields are located before non-oop fields (static and non-static).
4367   for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4368 
4369     // skip already laid out fields
4370     if (fs.is_offset_set()) continue;
4371 
4372     // contended instance fields are handled below
4373     if (fs.is_contended() &amp;&amp; !fs.access_flags().is_static()) continue;
4374 
4375     int real_offset = 0;
4376     const FieldAllocationType atype = (const FieldAllocationType) fs.allocation_type();
4377 
4378     // pack the rest of the fields
4379     switch (atype) {
<a name="56" id="anc56"></a>

4380       case STATIC_OOP:
4381         real_offset = next_static_oop_offset;
4382         next_static_oop_offset += heapOopSize;
4383         break;
4384       case STATIC_BYTE:
4385         real_offset = next_static_byte_offset;
4386         next_static_byte_offset += 1;
4387         break;
4388       case STATIC_SHORT:
4389         real_offset = next_static_short_offset;
4390         next_static_short_offset += BytesPerShort;
4391         break;
4392       case STATIC_WORD:
4393         real_offset = next_static_word_offset;
4394         next_static_word_offset += BytesPerInt;
4395         break;
4396       case STATIC_DOUBLE:
4397         real_offset = next_static_double_offset;
4398         next_static_double_offset += BytesPerLong;
4399         break;
<a name="57" id="anc57"></a>
























4400       case NONSTATIC_OOP:
4401         if( nonstatic_oop_space_count &gt; 0 ) {
4402           real_offset = nonstatic_oop_space_offset;
4403           nonstatic_oop_space_offset += heapOopSize;
4404           nonstatic_oop_space_count  -= 1;
4405         } else {
4406           real_offset = next_nonstatic_oop_offset;
4407           next_nonstatic_oop_offset += heapOopSize;
4408         }
4409         nonstatic_oop_maps-&gt;add(real_offset, 1);
4410         break;
4411       case NONSTATIC_BYTE:
4412         if( nonstatic_byte_space_count &gt; 0 ) {
4413           real_offset = nonstatic_byte_space_offset;
4414           nonstatic_byte_space_offset += 1;
4415           nonstatic_byte_space_count  -= 1;
4416         } else {
4417           real_offset = next_nonstatic_byte_offset;
4418           next_nonstatic_byte_offset += 1;
4419         }
4420         break;
4421       case NONSTATIC_SHORT:
4422         if( nonstatic_short_space_count &gt; 0 ) {
4423           real_offset = nonstatic_short_space_offset;
4424           nonstatic_short_space_offset += BytesPerShort;
4425           nonstatic_short_space_count  -= 1;
4426         } else {
4427           real_offset = next_nonstatic_short_offset;
4428           next_nonstatic_short_offset += BytesPerShort;
4429         }
4430         break;
4431       case NONSTATIC_WORD:
4432         if( nonstatic_word_space_count &gt; 0 ) {
4433           real_offset = nonstatic_word_space_offset;
4434           nonstatic_word_space_offset += BytesPerInt;
4435           nonstatic_word_space_count  -= 1;
4436         } else {
4437           real_offset = next_nonstatic_word_offset;
4438           next_nonstatic_word_offset += BytesPerInt;
4439         }
4440         break;
4441       case NONSTATIC_DOUBLE:
4442         real_offset = next_nonstatic_double_offset;
4443         next_nonstatic_double_offset += BytesPerLong;
4444         break;
4445       default:
4446         ShouldNotReachHere();
4447     }
4448     fs.set_offset(real_offset);
4449   }
4450 
4451 
4452   // Handle the contended cases.
4453   //
4454   // Each contended field should not intersect the cache line with another contended field.
4455   // In the absence of alignment information, we end up with pessimistically separating
4456   // the fields with full-width padding.
4457   //
4458   // Additionally, this should not break alignment for the fields, so we round the alignment up
4459   // for each field.
4460   if (nonstatic_contended_count &gt; 0) {
4461 
4462     // if there is at least one contended field, we need to have pre-padding for them
4463     next_nonstatic_padded_offset += ContendedPaddingWidth;
4464 
4465     // collect all contended groups
4466     ResourceBitMap bm(cp-&gt;size());
4467     for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4468       // skip already laid out fields
4469       if (fs.is_offset_set()) continue;
4470 
4471       if (fs.is_contended()) {
4472         bm.set_bit(fs.contended_group());
4473       }
4474     }
4475 
4476     int current_group = -1;
4477     while ((current_group = (int)bm.get_next_one_offset(current_group + 1)) != (int)bm.size()) {
4478 
4479       for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {
4480 
4481         // skip already laid out fields
4482         if (fs.is_offset_set()) continue;
4483 
4484         // skip non-contended fields and fields from different group
4485         if (!fs.is_contended() || (fs.contended_group() != current_group)) continue;
4486 
4487         // handle statics below
4488         if (fs.access_flags().is_static()) continue;
4489 
4490         int real_offset = 0;
4491         FieldAllocationType atype = (FieldAllocationType) fs.allocation_type();
4492 
4493         switch (atype) {
4494           case NONSTATIC_BYTE:
4495             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, 1);
4496             real_offset = next_nonstatic_padded_offset;
4497             next_nonstatic_padded_offset += 1;
4498             break;
4499 
4500           case NONSTATIC_SHORT:
4501             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerShort);
4502             real_offset = next_nonstatic_padded_offset;
4503             next_nonstatic_padded_offset += BytesPerShort;
4504             break;
4505 
4506           case NONSTATIC_WORD:
4507             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerInt);
4508             real_offset = next_nonstatic_padded_offset;
4509             next_nonstatic_padded_offset += BytesPerInt;
4510             break;
4511 
4512           case NONSTATIC_DOUBLE:
4513             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, BytesPerLong);
4514             real_offset = next_nonstatic_padded_offset;
4515             next_nonstatic_padded_offset += BytesPerLong;
4516             break;
4517 
<a name="58" id="anc58"></a>





4518           case NONSTATIC_OOP:
4519             next_nonstatic_padded_offset = align_up(next_nonstatic_padded_offset, heapOopSize);
4520             real_offset = next_nonstatic_padded_offset;
4521             next_nonstatic_padded_offset += heapOopSize;
4522             nonstatic_oop_maps-&gt;add(real_offset, 1);
4523             break;
4524 
4525           default:
4526             ShouldNotReachHere();
4527         }
4528 
4529         if (fs.contended_group() == 0) {
4530           // Contended group defines the equivalence class over the fields:
4531           // the fields within the same contended group are not inter-padded.
4532           // The only exception is default group, which does not incur the
4533           // equivalence, and so requires intra-padding.
4534           next_nonstatic_padded_offset += ContendedPaddingWidth;
4535         }
4536 
4537         fs.set_offset(real_offset);
4538       } // for
4539 
4540       // Start laying out the next group.
4541       // Note that this will effectively pad the last group in the back;
4542       // this is expected to alleviate memory contention effects for
4543       // subclass fields and/or adjacent object.
4544       // If this was the default group, the padding is already in place.
4545       if (current_group != 0) {
4546         next_nonstatic_padded_offset += ContendedPaddingWidth;
4547       }
4548     }
4549 
4550     // handle static fields
4551   }
4552 
4553   // Entire class is contended, pad in the back.
4554   // This helps to alleviate memory contention effects for subclass fields
4555   // and/or adjacent object.
4556   if (is_contended_class) {
<a name="59" id="anc59"></a>
4557     next_nonstatic_padded_offset += ContendedPaddingWidth;
4558   }
4559 
<a name="60" id="anc60"></a><span class="line-modified">4560   int notaligned_nonstatic_fields_end = next_nonstatic_padded_offset;</span>





4561 
<a name="61" id="anc61"></a><span class="line-modified">4562   int nonstatic_fields_end      = align_up(notaligned_nonstatic_fields_end, heapOopSize);</span>






4563   int instance_end              = align_up(notaligned_nonstatic_fields_end, wordSize);
4564   int static_fields_end         = align_up(next_static_byte_offset, wordSize);
4565 
4566   int static_field_size         = (static_fields_end -
4567                                    InstanceMirrorKlass::offset_of_static_fields()) / wordSize;
4568   nonstatic_field_size          = nonstatic_field_size +
4569                                   (nonstatic_fields_end - nonstatic_fields_start) / heapOopSize;
4570 
4571   int instance_size             = align_object_size(instance_end / wordSize);
4572 
4573   assert(instance_size == align_object_size(align_up(
<a name="62" id="anc62"></a><span class="line-modified">4574          (instanceOopDesc::base_offset_in_bytes() + nonstatic_field_size*heapOopSize),</span>
<span class="line-modified">4575           wordSize) / wordSize), &quot;consistent layout helper value&quot;);</span>

4576 
4577   // Invariant: nonstatic_field end/start should only change if there are
4578   // nonstatic fields in the class, or if the class is contended. We compare
4579   // against the non-aligned value, so that end alignment will not fail the
4580   // assert without actually having the fields.
4581   assert((notaligned_nonstatic_fields_end == nonstatic_fields_start) ||
4582          is_contended_class ||
4583          (nonstatic_fields_count &gt; 0), &quot;double-check nonstatic start/end&quot;);
4584 
4585   // Number of non-static oop map blocks allocated at end of klass.
4586   nonstatic_oop_maps-&gt;compact();
4587 
4588 #ifndef PRODUCT
<a name="63" id="anc63"></a><span class="line-modified">4589   if (PrintFieldLayout) {</span>

4590     print_field_layout(_class_name,
4591           _fields,
4592           cp,
4593           instance_size,
4594           nonstatic_fields_start,
4595           nonstatic_fields_end,
4596           static_fields_end);
<a name="64" id="anc64"></a>






4597   }
4598 
4599 #endif
4600   // Pass back information needed for InstanceKlass creation
4601   info-&gt;oop_map_blocks = nonstatic_oop_maps;
4602   info-&gt;_instance_size = instance_size;
4603   info-&gt;_static_field_size = static_field_size;
4604   info-&gt;_nonstatic_field_size = nonstatic_field_size;
4605   info-&gt;_has_nonstatic_fields = has_nonstatic_fields;
<a name="65" id="anc65"></a>












4606 }
4607 
4608 void ClassFileParser::set_precomputed_flags(InstanceKlass* ik) {
4609   assert(ik != NULL, &quot;invariant&quot;);
4610 
4611   const Klass* const super = ik-&gt;super();
4612 
4613   // Check if this klass has an empty finalize method (i.e. one with return bytecode only),
4614   // in which case we don&#39;t have to register objects as finalizable
4615   if (!_has_empty_finalizer) {
4616     if (_has_finalizer ||
4617         (super != NULL &amp;&amp; super-&gt;has_finalizer())) {
4618       ik-&gt;set_has_finalizer();
4619     }
4620   }
4621 
4622 #ifdef ASSERT
4623   bool f = false;
4624   const Method* const m = ik-&gt;lookup_method(vmSymbols::finalize_method_name(),
4625                                            vmSymbols::void_method_signature());
4626   if (m != NULL &amp;&amp; !m-&gt;is_empty_method()) {
4627       f = true;
4628   }
4629 
4630   // Spec doesn&#39;t prevent agent from redefinition of empty finalizer.
4631   // Despite the fact that it&#39;s generally bad idea and redefined finalizer
4632   // will not work as expected we shouldn&#39;t abort vm in this case
4633   if (!ik-&gt;has_redefined_this_or_super()) {
4634     assert(ik-&gt;has_finalizer() == f, &quot;inconsistent has_finalizer&quot;);
4635   }
4636 #endif
4637 
4638   // Check if this klass supports the java.lang.Cloneable interface
4639   if (SystemDictionary::Cloneable_klass_loaded()) {
4640     if (ik-&gt;is_subtype_of(SystemDictionary::Cloneable_klass())) {
<a name="66" id="anc66"></a>




4641       ik-&gt;set_is_cloneable();
4642     }
4643   }
4644 
4645   // Check if this klass has a vanilla default constructor
4646   if (super == NULL) {
4647     // java.lang.Object has empty default constructor
4648     ik-&gt;set_has_vanilla_constructor();
4649   } else {
4650     if (super-&gt;has_vanilla_constructor() &amp;&amp;
4651         _has_vanilla_constructor) {
4652       ik-&gt;set_has_vanilla_constructor();
4653     }
4654 #ifdef ASSERT
4655     bool v = false;
4656     if (super-&gt;has_vanilla_constructor()) {
4657       const Method* const constructor =
4658         ik-&gt;find_method(vmSymbols::object_initializer_name(),
4659                        vmSymbols::void_method_signature());
4660       if (constructor != NULL &amp;&amp; constructor-&gt;is_vanilla_constructor()) {
4661         v = true;
4662       }
4663     }
4664     assert(v == ik-&gt;has_vanilla_constructor(), &quot;inconsistent has_vanilla_constructor&quot;);
4665 #endif
4666   }
4667 
4668   // If it cannot be fast-path allocated, set a bit in the layout helper.
4669   // See documentation of InstanceKlass::can_be_fastpath_allocated().
4670   assert(ik-&gt;size_helper() &gt; 0, &quot;layout_helper is initialized&quot;);
4671   if ((!RegisterFinalizersAtInit &amp;&amp; ik-&gt;has_finalizer())
4672       || ik-&gt;is_abstract() || ik-&gt;is_interface()
4673       || (ik-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp; ik-&gt;class_loader() == NULL)
4674       || ik-&gt;size_helper() &gt;= FastAllocateSizeLimit) {
4675     // Forbid fast-path allocation.
4676     const jint lh = Klass::instance_layout_helper(ik-&gt;size_helper(), true);
4677     ik-&gt;set_layout_helper(lh);
4678   }
4679 }
4680 
<a name="67" id="anc67"></a>




4681 // utility methods for appending an array with check for duplicates
4682 
4683 static void append_interfaces(GrowableArray&lt;InstanceKlass*&gt;* result,
4684                               const Array&lt;InstanceKlass*&gt;* const ifs) {
4685   // iterate over new interfaces
4686   for (int i = 0; i &lt; ifs-&gt;length(); i++) {
4687     InstanceKlass* const e = ifs-&gt;at(i);
4688     assert(e-&gt;is_klass() &amp;&amp; e-&gt;is_interface(), &quot;just checking&quot;);
4689     // add new interface
4690     result-&gt;append_if_missing(e);
4691   }
4692 }
4693 
4694 static Array&lt;InstanceKlass*&gt;* compute_transitive_interfaces(const InstanceKlass* super,
4695                                                             Array&lt;InstanceKlass*&gt;* local_ifs,
4696                                                             ClassLoaderData* loader_data,
4697                                                             TRAPS) {
4698   assert(local_ifs != NULL, &quot;invariant&quot;);
4699   assert(loader_data != NULL, &quot;invariant&quot;);
4700 
4701   // Compute maximum size for transitive interfaces
4702   int max_transitive_size = 0;
4703   int super_size = 0;
4704   // Add superclass transitive interfaces size
4705   if (super != NULL) {
4706     super_size = super-&gt;transitive_interfaces()-&gt;length();
4707     max_transitive_size += super_size;
4708   }
4709   // Add local interfaces&#39; super interfaces
4710   const int local_size = local_ifs-&gt;length();
4711   for (int i = 0; i &lt; local_size; i++) {
4712     InstanceKlass* const l = local_ifs-&gt;at(i);
4713     max_transitive_size += l-&gt;transitive_interfaces()-&gt;length();
4714   }
4715   // Finally add local interfaces
4716   max_transitive_size += local_size;
4717   // Construct array
4718   if (max_transitive_size == 0) {
4719     // no interfaces, use canonicalized array
4720     return Universe::the_empty_instance_klass_array();
4721   } else if (max_transitive_size == super_size) {
4722     // no new local interfaces added, share superklass&#39; transitive interface array
4723     return super-&gt;transitive_interfaces();
<a name="68" id="anc68"></a><span class="line-modified">4724   } else if (max_transitive_size == local_size) {</span>
<span class="line-modified">4725     // only local interfaces added, share local interface array</span>
<span class="line-modified">4726     return local_ifs;</span>

4727   } else {
4728     ResourceMark rm;
4729     GrowableArray&lt;InstanceKlass*&gt;* const result = new GrowableArray&lt;InstanceKlass*&gt;(max_transitive_size);
4730 
4731     // Copy down from superclass
4732     if (super != NULL) {
4733       append_interfaces(result, super-&gt;transitive_interfaces());
4734     }
4735 
4736     // Copy down from local interfaces&#39; superinterfaces
4737     for (int i = 0; i &lt; local_size; i++) {
4738       InstanceKlass* const l = local_ifs-&gt;at(i);
4739       append_interfaces(result, l-&gt;transitive_interfaces());
4740     }
4741     // Finally add local interfaces
4742     append_interfaces(result, local_ifs);
4743 
4744     // length will be less than the max_transitive_size if duplicates were removed
4745     const int length = result-&gt;length();
4746     assert(length &lt;= max_transitive_size, &quot;just checking&quot;);
<a name="69" id="anc69"></a>




4747     Array&lt;InstanceKlass*&gt;* const new_result =
4748       MetadataFactory::new_array&lt;InstanceKlass*&gt;(loader_data, length, CHECK_NULL);
4749     for (int i = 0; i &lt; length; i++) {
4750       InstanceKlass* const e = result-&gt;at(i);
4751       assert(e != NULL, &quot;just checking&quot;);
4752       new_result-&gt;at_put(i, e);
4753     }
4754     return new_result;
4755   }
4756 }
4757 
4758 static void check_super_class_access(const InstanceKlass* this_klass, TRAPS) {
4759   assert(this_klass != NULL, &quot;invariant&quot;);
4760   const Klass* const super = this_klass-&gt;super();
4761 
4762   if (super != NULL) {
4763     const InstanceKlass* super_ik = InstanceKlass::cast(super);
4764 
4765     if (super-&gt;is_final()) {
4766       ResourceMark rm(THREAD);
4767       Exceptions::fthrow(
4768         THREAD_AND_LOCATION,
4769         vmSymbols::java_lang_VerifyError(),
4770         &quot;class %s cannot inherit from final class %s&quot;,
4771         this_klass-&gt;external_name(),
4772         super_ik-&gt;external_name());
4773       return;
4774     }
4775 
4776     if (super_ik-&gt;is_sealed() &amp;&amp; !super_ik-&gt;has_as_permitted_subclass(this_klass)) {
4777       ResourceMark rm(THREAD);
4778       Exceptions::fthrow(
4779         THREAD_AND_LOCATION,
4780         vmSymbols::java_lang_IncompatibleClassChangeError(),
4781         &quot;class %s cannot inherit from sealed class %s&quot;,
4782         this_klass-&gt;external_name(),
4783         super_ik-&gt;external_name());
4784       return;
4785     }
4786 
4787     // If the loader is not the boot loader then throw an exception if its
4788     // superclass is in package jdk.internal.reflect and its loader is not a
4789     // special reflection class loader
4790     if (!this_klass-&gt;class_loader_data()-&gt;is_the_null_class_loader_data()) {
4791       PackageEntry* super_package = super-&gt;package();
4792       if (super_package != NULL &amp;&amp;
4793           super_package-&gt;name()-&gt;fast_compare(vmSymbols::jdk_internal_reflect()) == 0 &amp;&amp;
4794           !java_lang_ClassLoader::is_reflection_class_loader(this_klass-&gt;class_loader())) {
4795         ResourceMark rm(THREAD);
4796         Exceptions::fthrow(
4797           THREAD_AND_LOCATION,
4798           vmSymbols::java_lang_IllegalAccessError(),
4799           &quot;class %s loaded by %s cannot access jdk/internal/reflect superclass %s&quot;,
4800           this_klass-&gt;external_name(),
4801           this_klass-&gt;class_loader_data()-&gt;loader_name_and_id(),
4802           super-&gt;external_name());
4803         return;
4804       }
4805     }
4806 
4807     Reflection::VerifyClassAccessResults vca_result =
4808       Reflection::verify_class_access(this_klass, InstanceKlass::cast(super), false);
4809     if (vca_result != Reflection::ACCESS_OK) {
4810       ResourceMark rm(THREAD);
4811       char* msg = Reflection::verify_class_access_msg(this_klass,
4812                                                       InstanceKlass::cast(super),
4813                                                       vca_result);
4814       if (msg == NULL) {
4815         bool same_module = (this_klass-&gt;module() == super-&gt;module());
4816         Exceptions::fthrow(
4817           THREAD_AND_LOCATION,
4818           vmSymbols::java_lang_IllegalAccessError(),
4819           &quot;class %s cannot access its %ssuperclass %s (%s%s%s)&quot;,
4820           this_klass-&gt;external_name(),
4821           super-&gt;is_abstract() ? &quot;abstract &quot; : &quot;&quot;,
4822           super-&gt;external_name(),
4823           (same_module) ? this_klass-&gt;joint_in_module_of_loader(super) : this_klass-&gt;class_in_module_of_loader(),
4824           (same_module) ? &quot;&quot; : &quot;; &quot;,
4825           (same_module) ? &quot;&quot; : super-&gt;class_in_module_of_loader());
4826       } else {
4827         // Add additional message content.
4828         Exceptions::fthrow(
4829           THREAD_AND_LOCATION,
4830           vmSymbols::java_lang_IllegalAccessError(),
4831           &quot;superclass access check failed: %s&quot;,
4832           msg);
4833       }
4834     }
4835   }
4836 }
4837 
4838 
4839 static void check_super_interface_access(const InstanceKlass* this_klass, TRAPS) {
4840   assert(this_klass != NULL, &quot;invariant&quot;);
4841   const Array&lt;InstanceKlass*&gt;* const local_interfaces = this_klass-&gt;local_interfaces();
4842   const int lng = local_interfaces-&gt;length();
4843   for (int i = lng - 1; i &gt;= 0; i--) {
4844     InstanceKlass* const k = local_interfaces-&gt;at(i);
4845     assert (k != NULL &amp;&amp; k-&gt;is_interface(), &quot;invalid interface&quot;);
4846 
4847     if (k-&gt;is_sealed() &amp;&amp; !k-&gt;has_as_permitted_subclass(this_klass)) {
4848       ResourceMark rm(THREAD);
4849       Exceptions::fthrow(
4850         THREAD_AND_LOCATION,
4851         vmSymbols::java_lang_IncompatibleClassChangeError(),
4852         &quot;class %s cannot %s sealed interface %s&quot;,
4853         this_klass-&gt;external_name(),
4854         this_klass-&gt;is_interface() ? &quot;extend&quot; : &quot;implement&quot;,
4855         k-&gt;external_name());
4856       return;
4857     }
4858 
4859     Reflection::VerifyClassAccessResults vca_result =
4860       Reflection::verify_class_access(this_klass, k, false);
4861     if (vca_result != Reflection::ACCESS_OK) {
4862       ResourceMark rm(THREAD);
4863       char* msg = Reflection::verify_class_access_msg(this_klass,
4864                                                       k,
4865                                                       vca_result);
4866       if (msg == NULL) {
4867         bool same_module = (this_klass-&gt;module() == k-&gt;module());
4868         Exceptions::fthrow(
4869           THREAD_AND_LOCATION,
4870           vmSymbols::java_lang_IllegalAccessError(),
4871           &quot;class %s cannot access its superinterface %s (%s%s%s)&quot;,
4872           this_klass-&gt;external_name(),
4873           k-&gt;external_name(),
4874           (same_module) ? this_klass-&gt;joint_in_module_of_loader(k) : this_klass-&gt;class_in_module_of_loader(),
4875           (same_module) ? &quot;&quot; : &quot;; &quot;,
4876           (same_module) ? &quot;&quot; : k-&gt;class_in_module_of_loader());
4877       } else {
4878         // Add additional message content.
4879         Exceptions::fthrow(
4880           THREAD_AND_LOCATION,
4881           vmSymbols::java_lang_IllegalAccessError(),
4882           &quot;superinterface check failed: %s&quot;,
4883           msg);
4884       }
4885     }
4886   }
4887 }
4888 
4889 
4890 static void check_final_method_override(const InstanceKlass* this_klass, TRAPS) {
4891   assert(this_klass != NULL, &quot;invariant&quot;);
4892   const Array&lt;Method*&gt;* const methods = this_klass-&gt;methods();
4893   const int num_methods = methods-&gt;length();
4894 
4895   // go thru each method and check if it overrides a final method
4896   for (int index = 0; index &lt; num_methods; index++) {
4897     const Method* const m = methods-&gt;at(index);
4898 
4899     // skip private, static, and &lt;init&gt; methods
4900     if ((!m-&gt;is_private() &amp;&amp; !m-&gt;is_static()) &amp;&amp;
4901         (m-&gt;name() != vmSymbols::object_initializer_name())) {
4902 
4903       const Symbol* const name = m-&gt;name();
4904       const Symbol* const signature = m-&gt;signature();
4905       const Klass* k = this_klass-&gt;super();
4906       const Method* super_m = NULL;
4907       while (k != NULL) {
4908         // skip supers that don&#39;t have final methods.
4909         if (k-&gt;has_final_method()) {
4910           // lookup a matching method in the super class hierarchy
4911           super_m = InstanceKlass::cast(k)-&gt;lookup_method(name, signature);
4912           if (super_m == NULL) {
4913             break; // didn&#39;t find any match; get out
4914           }
4915 
4916           if (super_m-&gt;is_final() &amp;&amp; !super_m-&gt;is_static() &amp;&amp;
4917               !super_m-&gt;access_flags().is_private()) {
4918             // matching method in super is final, and not static or private
4919             bool can_access = Reflection::verify_member_access(this_klass,
4920                                                                super_m-&gt;method_holder(),
4921                                                                super_m-&gt;method_holder(),
4922                                                                super_m-&gt;access_flags(),
4923                                                               false, false, CHECK);
4924             if (can_access) {
4925               // this class can access super final method and therefore override
4926               ResourceMark rm(THREAD);
4927               Exceptions::fthrow(THREAD_AND_LOCATION,
4928                                  vmSymbols::java_lang_VerifyError(),
4929                                  &quot;class %s overrides final method %s.%s%s&quot;,
4930                                  this_klass-&gt;external_name(),
4931                                  super_m-&gt;method_holder()-&gt;external_name(),
4932                                  name-&gt;as_C_string(),
4933                                  signature-&gt;as_C_string()
4934                                  );
4935               return;
4936             }
4937           }
4938 
4939           // continue to look from super_m&#39;s holder&#39;s super.
4940           k = super_m-&gt;method_holder()-&gt;super();
4941           continue;
4942         }
4943 
4944         k = k-&gt;super();
4945       }
4946     }
4947   }
4948 }
4949 
4950 
4951 // assumes that this_klass is an interface
4952 static void check_illegal_static_method(const InstanceKlass* this_klass, TRAPS) {
4953   assert(this_klass != NULL, &quot;invariant&quot;);
4954   assert(this_klass-&gt;is_interface(), &quot;not an interface&quot;);
4955   const Array&lt;Method*&gt;* methods = this_klass-&gt;methods();
4956   const int num_methods = methods-&gt;length();
4957 
4958   for (int index = 0; index &lt; num_methods; index++) {
4959     const Method* const m = methods-&gt;at(index);
4960     // if m is static and not the init method, throw a verify error
4961     if ((m-&gt;is_static()) &amp;&amp; (m-&gt;name() != vmSymbols::class_initializer_name())) {
4962       ResourceMark rm(THREAD);
4963       Exceptions::fthrow(
4964         THREAD_AND_LOCATION,
4965         vmSymbols::java_lang_VerifyError(),
4966         &quot;Illegal static method %s in interface %s&quot;,
4967         m-&gt;name()-&gt;as_C_string(),
4968         this_klass-&gt;external_name()
4969       );
4970       return;
4971     }
4972   }
4973 }
4974 
4975 // utility methods for format checking
4976 
4977 void ClassFileParser::verify_legal_class_modifiers(jint flags, TRAPS) const {
4978   const bool is_module = (flags &amp; JVM_ACC_MODULE) != 0;
<a name="70" id="anc70"></a>
4979   assert(_major_version &gt;= JAVA_9_VERSION || !is_module, &quot;JVM_ACC_MODULE should not be set&quot;);
<a name="71" id="anc71"></a>
4980   if (is_module) {
4981     ResourceMark rm(THREAD);
4982     Exceptions::fthrow(
4983       THREAD_AND_LOCATION,
4984       vmSymbols::java_lang_NoClassDefFoundError(),
4985       &quot;%s is not a class because access_flag ACC_MODULE is set&quot;,
4986       _class_name-&gt;as_C_string());
4987     return;
4988   }
4989 
<a name="72" id="anc72"></a>









4990   if (!_need_verify) { return; }
4991 
4992   const bool is_interface  = (flags &amp; JVM_ACC_INTERFACE)  != 0;
4993   const bool is_abstract   = (flags &amp; JVM_ACC_ABSTRACT)   != 0;
4994   const bool is_final      = (flags &amp; JVM_ACC_FINAL)      != 0;
4995   const bool is_super      = (flags &amp; JVM_ACC_SUPER)      != 0;
4996   const bool is_enum       = (flags &amp; JVM_ACC_ENUM)       != 0;
4997   const bool is_annotation = (flags &amp; JVM_ACC_ANNOTATION) != 0;
4998   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
4999   const bool major_gte_14  = _major_version &gt;= JAVA_14_VERSION;
5000 
5001   if ((is_abstract &amp;&amp; is_final) ||
5002       (is_interface &amp;&amp; !is_abstract) ||
5003       (is_interface &amp;&amp; major_gte_1_5 &amp;&amp; (is_super || is_enum)) ||
<a name="73" id="anc73"></a><span class="line-modified">5004       (!is_interface &amp;&amp; major_gte_1_5 &amp;&amp; is_annotation)) {</span>

5005     ResourceMark rm(THREAD);
<a name="74" id="anc74"></a>

5006     Exceptions::fthrow(
5007       THREAD_AND_LOCATION,
5008       vmSymbols::java_lang_ClassFormatError(),
<a name="75" id="anc75"></a><span class="line-modified">5009       &quot;Illegal class modifiers in class %s: 0x%X&quot;,</span>
<span class="line-modified">5010       _class_name-&gt;as_C_string(), flags</span>
5011     );
5012     return;
5013   }
5014 }
5015 
5016 static bool has_illegal_visibility(jint flags) {
5017   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5018   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5019   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5020 
5021   return ((is_public &amp;&amp; is_protected) ||
5022           (is_public &amp;&amp; is_private) ||
5023           (is_protected &amp;&amp; is_private));
5024 }
5025 
5026 // A legal major_version.minor_version must be one of the following:
5027 //
5028 //  Major_version &gt;= 45 and major_version &lt; 56, any minor_version.
5029 //  Major_version &gt;= 56 and major_version &lt;= JVM_CLASSFILE_MAJOR_VERSION and minor_version = 0.
5030 //  Major_version = JVM_CLASSFILE_MAJOR_VERSION and minor_version = 65535 and --enable-preview is present.
5031 //
5032 static void verify_class_version(u2 major, u2 minor, Symbol* class_name, TRAPS){
5033   ResourceMark rm(THREAD);
5034   const u2 max_version = JVM_CLASSFILE_MAJOR_VERSION;
5035   if (major &lt; JAVA_MIN_SUPPORTED_VERSION) {
5036     Exceptions::fthrow(
5037       THREAD_AND_LOCATION,
5038       vmSymbols::java_lang_UnsupportedClassVersionError(),
5039       &quot;%s (class file version %u.%u) was compiled with an invalid major version&quot;,
5040       class_name-&gt;as_C_string(), major, minor);
5041     return;
5042   }
5043 
5044   if (major &gt; max_version) {
5045     Exceptions::fthrow(
5046       THREAD_AND_LOCATION,
5047       vmSymbols::java_lang_UnsupportedClassVersionError(),
5048       &quot;%s has been compiled by a more recent version of the Java Runtime (class file version %u.%u), &quot;
5049       &quot;this version of the Java Runtime only recognizes class file versions up to %u.0&quot;,
5050       class_name-&gt;as_C_string(), major, minor, JVM_CLASSFILE_MAJOR_VERSION);
5051     return;
5052   }
5053 
5054   if (major &lt; JAVA_12_VERSION || minor == 0) {
5055     return;
5056   }
5057 
5058   if (minor == JAVA_PREVIEW_MINOR_VERSION) {
5059     if (major != max_version) {
5060       Exceptions::fthrow(
5061         THREAD_AND_LOCATION,
5062         vmSymbols::java_lang_UnsupportedClassVersionError(),
5063         &quot;%s (class file version %u.%u) was compiled with preview features that are unsupported. &quot;
5064         &quot;This version of the Java Runtime only recognizes preview features for class file version %u.%u&quot;,
5065         class_name-&gt;as_C_string(), major, minor, JVM_CLASSFILE_MAJOR_VERSION, JAVA_PREVIEW_MINOR_VERSION);
5066       return;
5067     }
5068 
5069     if (!Arguments::enable_preview()) {
5070       Exceptions::fthrow(
5071         THREAD_AND_LOCATION,
5072         vmSymbols::java_lang_UnsupportedClassVersionError(),
5073         &quot;Preview features are not enabled for %s (class file version %u.%u). Try running with &#39;--enable-preview&#39;&quot;,
5074         class_name-&gt;as_C_string(), major, minor);
5075       return;
5076     }
5077 
5078   } else { // minor != JAVA_PREVIEW_MINOR_VERSION
5079     Exceptions::fthrow(
5080         THREAD_AND_LOCATION,
5081         vmSymbols::java_lang_UnsupportedClassVersionError(),
5082         &quot;%s (class file version %u.%u) was compiled with an invalid non-zero minor version&quot;,
5083         class_name-&gt;as_C_string(), major, minor);
5084   }
5085 }
5086 
5087 void ClassFileParser::verify_legal_field_modifiers(jint flags,
5088                                                    bool is_interface,
<a name="76" id="anc76"></a>
5089                                                    TRAPS) const {
5090   if (!_need_verify) { return; }
5091 
5092   const bool is_public    = (flags &amp; JVM_ACC_PUBLIC)    != 0;
5093   const bool is_protected = (flags &amp; JVM_ACC_PROTECTED) != 0;
5094   const bool is_private   = (flags &amp; JVM_ACC_PRIVATE)   != 0;
5095   const bool is_static    = (flags &amp; JVM_ACC_STATIC)    != 0;
5096   const bool is_final     = (flags &amp; JVM_ACC_FINAL)     != 0;
5097   const bool is_volatile  = (flags &amp; JVM_ACC_VOLATILE)  != 0;
5098   const bool is_transient = (flags &amp; JVM_ACC_TRANSIENT) != 0;
5099   const bool is_enum      = (flags &amp; JVM_ACC_ENUM)      != 0;
5100   const bool major_gte_1_5 = _major_version &gt;= JAVA_1_5_VERSION;
5101 
5102   bool is_illegal = false;
5103 
5104   if (is_interface) {
5105     if (!is_public || !is_static || !is_final || is_private ||
5106         is_protected || is_volatile || is_transient ||
5107         (major_gte_1_5 &amp;&amp; is_enum)) {
5108       is_illegal = true;
5109     }
5110   } else { // not interface
5111     if (has_illegal_visibility(flags) || (is_final &amp;&amp; is_volatile)) {
5112       is_illegal = true;
<a name="77" id="anc77"></a>



5113     }
5114   }
5115 
5116   if (is_illegal) {
5117     ResourceMark rm(THREAD);
5118     Exceptions::fthrow(
5119       THREAD_AND_LOCATION,
5120       vmSymbols::java_lang_ClassFormatError(),
5121       &quot;Illegal field modifiers in class %s: 0x%X&quot;,
5122       _class_name-&gt;as_C_string(), flags);
5123     return;
5124   }
5125 }
5126 
5127 void ClassFileParser::verify_legal_method_modifiers(jint flags,
5128                                                     bool is_interface,
<a name="78" id="anc78"></a>
5129                                                     const Symbol* name,
5130                                                     TRAPS) const {
5131   if (!_need_verify) { return; }
5132 
5133   const bool is_public       = (flags &amp; JVM_ACC_PUBLIC)       != 0;
5134   const bool is_private      = (flags &amp; JVM_ACC_PRIVATE)      != 0;
5135   const bool is_static       = (flags &amp; JVM_ACC_STATIC)       != 0;
5136   const bool is_final        = (flags &amp; JVM_ACC_FINAL)        != 0;
5137   const bool is_native       = (flags &amp; JVM_ACC_NATIVE)       != 0;
5138   const bool is_abstract     = (flags &amp; JVM_ACC_ABSTRACT)     != 0;
5139   const bool is_bridge       = (flags &amp; JVM_ACC_BRIDGE)       != 0;
5140   const bool is_strict       = (flags &amp; JVM_ACC_STRICT)       != 0;
5141   const bool is_synchronized = (flags &amp; JVM_ACC_SYNCHRONIZED) != 0;
5142   const bool is_protected    = (flags &amp; JVM_ACC_PROTECTED)    != 0;
5143   const bool major_gte_1_5   = _major_version &gt;= JAVA_1_5_VERSION;
5144   const bool major_gte_8     = _major_version &gt;= JAVA_8_VERSION;
5145   const bool is_initializer  = (name == vmSymbols::object_initializer_name());
5146 
5147   bool is_illegal = false;
5148 
<a name="79" id="anc79"></a>

5149   if (is_interface) {
5150     if (major_gte_8) {
5151       // Class file version is JAVA_8_VERSION or later Methods of
5152       // interfaces may set any of the flags except ACC_PROTECTED,
5153       // ACC_FINAL, ACC_NATIVE, and ACC_SYNCHRONIZED; they must
5154       // have exactly one of the ACC_PUBLIC or ACC_PRIVATE flags set.
5155       if ((is_public == is_private) || /* Only one of private and public should be true - XNOR */
5156           (is_native || is_protected || is_final || is_synchronized) ||
5157           // If a specific method of a class or interface has its
5158           // ACC_ABSTRACT flag set, it must not have any of its
5159           // ACC_FINAL, ACC_NATIVE, ACC_PRIVATE, ACC_STATIC,
5160           // ACC_STRICT, or ACC_SYNCHRONIZED flags set.  No need to
5161           // check for ACC_FINAL, ACC_NATIVE or ACC_SYNCHRONIZED as
5162           // those flags are illegal irrespective of ACC_ABSTRACT being set or not.
5163           (is_abstract &amp;&amp; (is_private || is_static || is_strict))) {
5164         is_illegal = true;
5165       }
5166     } else if (major_gte_1_5) {
5167       // Class file version in the interval [JAVA_1_5_VERSION, JAVA_8_VERSION)
5168       if (!is_public || is_private || is_protected || is_static || is_final ||
5169           is_synchronized || is_native || !is_abstract || is_strict) {
5170         is_illegal = true;
5171       }
5172     } else {
5173       // Class file version is pre-JAVA_1_5_VERSION
5174       if (!is_public || is_static || is_final || is_native || !is_abstract) {
5175         is_illegal = true;
5176       }
5177     }
5178   } else { // not interface
5179     if (has_illegal_visibility(flags)) {
5180       is_illegal = true;
5181     } else {
5182       if (is_initializer) {
<a name="80" id="anc80"></a><span class="line-modified">5183         if (is_static || is_final || is_synchronized || is_native ||</span>
5184             is_abstract || (major_gte_1_5 &amp;&amp; is_bridge)) {
5185           is_illegal = true;
5186         }
<a name="81" id="anc81"></a>








5187       } else { // not initializer
<a name="82" id="anc82"></a><span class="line-modified">5188         if (is_abstract) {</span>
<span class="line-modified">5189           if ((is_final || is_native || is_private || is_static ||</span>
<span class="line-modified">5190               (major_gte_1_5 &amp;&amp; (is_synchronized || is_strict)))) {</span>
<span class="line-modified">5191             is_illegal = true;</span>





5192           }
5193         }
5194       }
5195     }
5196   }
5197 
5198   if (is_illegal) {
5199     ResourceMark rm(THREAD);
5200     Exceptions::fthrow(
5201       THREAD_AND_LOCATION,
5202       vmSymbols::java_lang_ClassFormatError(),
<a name="83" id="anc83"></a><span class="line-modified">5203       &quot;Method %s in class %s has illegal modifiers: 0x%X&quot;,</span>
<span class="line-modified">5204       name-&gt;as_C_string(), _class_name-&gt;as_C_string(), flags);</span>
5205     return;
5206   }
5207 }
5208 
5209 void ClassFileParser::verify_legal_utf8(const unsigned char* buffer,
5210                                         int length,
5211                                         TRAPS) const {
5212   assert(_need_verify, &quot;only called when _need_verify is true&quot;);
5213   if (!UTF8::is_legal_utf8(buffer, length, _major_version &lt;= 47)) {
5214     classfile_parse_error(&quot;Illegal UTF8 string in constant pool in class file %s&quot;, CHECK);
5215   }
5216 }
5217 
5218 // Unqualified names may not contain the characters &#39;.&#39;, &#39;;&#39;, &#39;[&#39;, or &#39;/&#39;.
5219 // In class names, &#39;/&#39; separates unqualified names.  This is verified in this function also.
5220 // Method names also may not contain the characters &#39;&lt;&#39; or &#39;&gt;&#39;, unless &lt;init&gt;
5221 // or &lt;clinit&gt;.  Note that method names may not be &lt;init&gt; or &lt;clinit&gt; in this
5222 // method.  Because these names have been checked as special cases before
5223 // calling this method in verify_legal_method_name.
5224 //
5225 // This method is also called from the modular system APIs in modules.cpp
5226 // to verify the validity of module and package names.
5227 bool ClassFileParser::verify_unqualified_name(const char* name,
5228                                               unsigned int length,
5229                                               int type) {
5230   if (length == 0) return false;  // Must have at least one char.
5231   for (const char* p = name; p != name + length; p++) {
5232     switch(*p) {
5233       case JVM_SIGNATURE_DOT:
5234       case JVM_SIGNATURE_ENDCLASS:
5235       case JVM_SIGNATURE_ARRAY:
5236         // do not permit &#39;.&#39;, &#39;;&#39;, or &#39;[&#39;
5237         return false;
5238       case JVM_SIGNATURE_SLASH:
5239         // check for &#39;//&#39; or leading or trailing &#39;/&#39; which are not legal
5240         // unqualified name must not be empty
5241         if (type == ClassFileParser::LegalClass) {
5242           if (p == name || p+1 &gt;= name+length ||
5243               *(p+1) == JVM_SIGNATURE_SLASH) {
5244             return false;
5245           }
5246         } else {
5247           return false;   // do not permit &#39;/&#39; unless it&#39;s class name
5248         }
5249         break;
5250       case JVM_SIGNATURE_SPECIAL:
5251       case JVM_SIGNATURE_ENDSPECIAL:
5252         // do not permit &#39;&lt;&#39; or &#39;&gt;&#39; in method names
5253         if (type == ClassFileParser::LegalMethod) {
5254           return false;
5255         }
5256     }
5257   }
5258   return true;
5259 }
5260 
5261 // Take pointer to a UTF8 byte string (not NUL-terminated).
5262 // Skip over the longest part of the string that could
5263 // be taken as a fieldname. Allow &#39;/&#39; if slash_ok is true.
5264 // Return a pointer to just past the fieldname.
5265 // Return NULL if no fieldname at all was found, or in the case of slash_ok
5266 // being true, we saw consecutive slashes (meaning we were looking for a
5267 // qualified path but found something that was badly-formed).
5268 static const char* skip_over_field_name(const char* const name,
5269                                         bool slash_ok,
5270                                         unsigned int length) {
5271   const char* p;
5272   jboolean last_is_slash = false;
5273   jboolean not_first_ch = false;
5274 
5275   for (p = name; p != name + length; not_first_ch = true) {
5276     const char* old_p = p;
5277     jchar ch = *p;
5278     if (ch &lt; 128) {
5279       p++;
5280       // quick check for ascii
5281       if ((ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;) ||
5282         (ch &gt;= &#39;A&#39; &amp;&amp; ch &lt;= &#39;Z&#39;) ||
5283         (ch == &#39;_&#39; || ch == &#39;$&#39;) ||
5284         (not_first_ch &amp;&amp; ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)) {
5285         last_is_slash = false;
5286         continue;
5287       }
5288       if (slash_ok &amp;&amp; ch == JVM_SIGNATURE_SLASH) {
5289         if (last_is_slash) {
5290           return NULL;  // Don&#39;t permit consecutive slashes
5291         }
5292         last_is_slash = true;
5293         continue;
5294       }
5295     }
5296     else {
5297       jint unicode_ch;
5298       char* tmp_p = UTF8::next_character(p, &amp;unicode_ch);
5299       p = tmp_p;
5300       last_is_slash = false;
5301       // Check if ch is Java identifier start or is Java identifier part
5302       // 4672820: call java.lang.Character methods directly without generating separate tables.
5303       EXCEPTION_MARK;
5304       // return value
5305       JavaValue result(T_BOOLEAN);
5306       // Set up the arguments to isJavaIdentifierStart or isJavaIdentifierPart
5307       JavaCallArguments args;
5308       args.push_int(unicode_ch);
5309 
5310       if (not_first_ch) {
5311         // public static boolean isJavaIdentifierPart(char ch);
5312         JavaCalls::call_static(&amp;result,
5313           SystemDictionary::Character_klass(),
5314           vmSymbols::isJavaIdentifierPart_name(),
5315           vmSymbols::int_bool_signature(),
5316           &amp;args,
5317           THREAD);
5318       } else {
5319         // public static boolean isJavaIdentifierStart(char ch);
5320         JavaCalls::call_static(&amp;result,
5321           SystemDictionary::Character_klass(),
5322           vmSymbols::isJavaIdentifierStart_name(),
5323           vmSymbols::int_bool_signature(),
5324           &amp;args,
5325           THREAD);
5326       }
5327       if (HAS_PENDING_EXCEPTION) {
5328         CLEAR_PENDING_EXCEPTION;
5329         return NULL;
5330       }
5331       if(result.get_jboolean()) {
5332         continue;
5333       }
5334     }
5335     return (not_first_ch) ? old_p : NULL;
5336   }
5337   return (not_first_ch) ? p : NULL;
5338 }
5339 
5340 // Take pointer to a UTF8 byte string (not NUL-terminated).
5341 // Skip over the longest part of the string that could
5342 // be taken as a field signature. Allow &quot;void&quot; if void_ok.
5343 // Return a pointer to just past the signature.
5344 // Return NULL if no legal signature is found.
5345 const char* ClassFileParser::skip_over_field_signature(const char* signature,
5346                                                        bool void_ok,
5347                                                        unsigned int length,
5348                                                        TRAPS) const {
5349   unsigned int array_dim = 0;
5350   while (length &gt; 0) {
5351     switch (signature[0]) {
5352     case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }
5353     case JVM_SIGNATURE_BOOLEAN:
5354     case JVM_SIGNATURE_BYTE:
5355     case JVM_SIGNATURE_CHAR:
5356     case JVM_SIGNATURE_SHORT:
5357     case JVM_SIGNATURE_INT:
5358     case JVM_SIGNATURE_FLOAT:
5359     case JVM_SIGNATURE_LONG:
5360     case JVM_SIGNATURE_DOUBLE:
5361       return signature + 1;
<a name="84" id="anc84"></a><span class="line-modified">5362     case JVM_SIGNATURE_CLASS: {</span>









5363       if (_major_version &lt; JAVA_1_5_VERSION) {
5364         // Skip over the class name if one is there
5365         const char* const p = skip_over_field_name(signature + 1, true, --length);
5366 
5367         // The next character better be a semicolon
5368         if (p &amp;&amp; (p - signature) &gt; 1 &amp;&amp; p[0] == JVM_SIGNATURE_ENDCLASS) {
5369           return p + 1;
5370         }
5371       }
5372       else {
<a name="85" id="anc85"></a><span class="line-modified">5373         // Skip leading &#39;L&#39; and ignore first appearance of &#39;;&#39;</span>
5374         signature++;
5375         const char* c = (const char*) memchr(signature, JVM_SIGNATURE_ENDCLASS, length - 1);
5376         // Format check signature
5377         if (c != NULL) {
5378           int newlen = c - (char*) signature;
5379           bool legal = verify_unqualified_name(signature, newlen, LegalClass);
5380           if (!legal) {
5381             classfile_parse_error(&quot;Class name is empty or contains illegal character &quot;
5382                                   &quot;in descriptor in class file %s&quot;,
5383                                   CHECK_NULL);
5384             return NULL;
5385           }
5386           return signature + newlen + 1;
5387         }
5388       }
5389       return NULL;
5390     }
5391     case JVM_SIGNATURE_ARRAY:
5392       array_dim++;
5393       if (array_dim &gt; 255) {
5394         // 4277370: array descriptor is valid only if it represents 255 or fewer dimensions.
5395         classfile_parse_error(&quot;Array type descriptor has more than 255 dimensions in class file %s&quot;, CHECK_NULL);
5396       }
5397       // The rest of what&#39;s there better be a legal signature
5398       signature++;
5399       length--;
5400       void_ok = false;
5401       break;
5402     default:
5403       return NULL;
5404     }
5405   }
5406   return NULL;
5407 }
5408 
5409 // Checks if name is a legal class name.
5410 void ClassFileParser::verify_legal_class_name(const Symbol* name, TRAPS) const {
5411   if (!_need_verify || _relax_verify) { return; }
5412 
5413   assert(name-&gt;refcount() &gt; 0, &quot;symbol must be kept alive&quot;);
5414   char* bytes = (char*)name-&gt;bytes();
5415   unsigned int length = name-&gt;utf8_length();
5416   bool legal = false;
5417 
5418   if (length &gt; 0) {
5419     const char* p;
5420     if (bytes[0] == JVM_SIGNATURE_ARRAY) {
5421       p = skip_over_field_signature(bytes, false, length, CHECK);
5422       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5423     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5424       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5425         p = skip_over_field_name(bytes, true, length);
5426         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5427       }
<a name="86" id="anc86"></a>


5428     } else {
5429       // 4900761: relax the constraints based on JSR202 spec
5430       // Class names may be drawn from the entire Unicode character set.
5431       // Identifiers between &#39;/&#39; must be unqualified names.
5432       // The utf8 string has been verified when parsing cpool entries.
5433       legal = verify_unqualified_name(bytes, length, LegalClass);
5434     }
5435   }
5436   if (!legal) {
5437     ResourceMark rm(THREAD);
5438     assert(_class_name != NULL, &quot;invariant&quot;);
5439     Exceptions::fthrow(
5440       THREAD_AND_LOCATION,
5441       vmSymbols::java_lang_ClassFormatError(),
5442       &quot;Illegal class name \&quot;%.*s\&quot; in class file %s&quot;, length, bytes,
5443       _class_name-&gt;as_C_string()
5444     );
5445     return;
5446   }
5447 }
5448 
5449 // Checks if name is a legal field name.
5450 void ClassFileParser::verify_legal_field_name(const Symbol* name, TRAPS) const {
5451   if (!_need_verify || _relax_verify) { return; }
5452 
5453   char* bytes = (char*)name-&gt;bytes();
5454   unsigned int length = name-&gt;utf8_length();
5455   bool legal = false;
5456 
5457   if (length &gt; 0) {
5458     if (_major_version &lt; JAVA_1_5_VERSION) {
5459       if (bytes[0] != JVM_SIGNATURE_SPECIAL) {
5460         const char* p = skip_over_field_name(bytes, false, length);
5461         legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5462       }
5463     } else {
5464       // 4881221: relax the constraints based on JSR202 spec
5465       legal = verify_unqualified_name(bytes, length, LegalField);
5466     }
5467   }
5468 
5469   if (!legal) {
5470     ResourceMark rm(THREAD);
5471     assert(_class_name != NULL, &quot;invariant&quot;);
5472     Exceptions::fthrow(
5473       THREAD_AND_LOCATION,
5474       vmSymbols::java_lang_ClassFormatError(),
5475       &quot;Illegal field name \&quot;%.*s\&quot; in class %s&quot;, length, bytes,
5476       _class_name-&gt;as_C_string()
5477     );
5478     return;
5479   }
5480 }
5481 
5482 // Checks if name is a legal method name.
5483 void ClassFileParser::verify_legal_method_name(const Symbol* name, TRAPS) const {
5484   if (!_need_verify || _relax_verify) { return; }
5485 
5486   assert(name != NULL, &quot;method name is null&quot;);
5487   char* bytes = (char*)name-&gt;bytes();
5488   unsigned int length = name-&gt;utf8_length();
5489   bool legal = false;
5490 
5491   if (length &gt; 0) {
5492     if (bytes[0] == JVM_SIGNATURE_SPECIAL) {
5493       if (name == vmSymbols::object_initializer_name() || name == vmSymbols::class_initializer_name()) {
5494         legal = true;
5495       }
5496     } else if (_major_version &lt; JAVA_1_5_VERSION) {
5497       const char* p;
5498       p = skip_over_field_name(bytes, false, length);
5499       legal = (p != NULL) &amp;&amp; ((p - bytes) == (int)length);
5500     } else {
5501       // 4881221: relax the constraints based on JSR202 spec
5502       legal = verify_unqualified_name(bytes, length, LegalMethod);
5503     }
5504   }
5505 
5506   if (!legal) {
5507     ResourceMark rm(THREAD);
5508     assert(_class_name != NULL, &quot;invariant&quot;);
5509     Exceptions::fthrow(
5510       THREAD_AND_LOCATION,
5511       vmSymbols::java_lang_ClassFormatError(),
5512       &quot;Illegal method name \&quot;%.*s\&quot; in class %s&quot;, length, bytes,
5513       _class_name-&gt;as_C_string()
5514     );
5515     return;
5516   }
5517 }
5518 
5519 
5520 // Checks if signature is a legal field signature.
5521 void ClassFileParser::verify_legal_field_signature(const Symbol* name,
5522                                                    const Symbol* signature,
5523                                                    TRAPS) const {
5524   if (!_need_verify) { return; }
5525 
5526   const char* const bytes = (const char* const)signature-&gt;bytes();
5527   const unsigned int length = signature-&gt;utf8_length();
5528   const char* const p = skip_over_field_signature(bytes, false, length, CHECK);
5529 
5530   if (p == NULL || (p - bytes) != (int)length) {
5531     throwIllegalSignature(&quot;Field&quot;, name, signature, CHECK);
5532   }
5533 }
5534 
5535 // Checks if signature is a legal method signature.
5536 // Returns number of parameters
5537 int ClassFileParser::verify_legal_method_signature(const Symbol* name,
5538                                                    const Symbol* signature,
5539                                                    TRAPS) const {
5540   if (!_need_verify) {
5541     // make sure caller&#39;s args_size will be less than 0 even for non-static
5542     // method so it will be recomputed in compute_size_of_parameters().
5543     return -2;
5544   }
5545 
5546   // Class initializers cannot have args for class format version &gt;= 51.
5547   if (name == vmSymbols::class_initializer_name() &amp;&amp;
5548       signature != vmSymbols::void_method_signature() &amp;&amp;
5549       _major_version &gt;= JAVA_7_VERSION) {
5550     throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
5551     return 0;
5552   }
5553 
5554   unsigned int args_size = 0;
5555   const char* p = (const char*)signature-&gt;bytes();
5556   unsigned int length = signature-&gt;utf8_length();
5557   const char* nextp;
5558 
5559   // The first character must be a &#39;(&#39;
5560   if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_FUNC)) {
5561     length--;
5562     // Skip over legal field signatures
5563     nextp = skip_over_field_signature(p, false, length, CHECK_0);
5564     while ((length &gt; 0) &amp;&amp; (nextp != NULL)) {
5565       args_size++;
5566       if (p[0] == &#39;J&#39; || p[0] == &#39;D&#39;) {
5567         args_size++;
5568       }
5569       length -= nextp - p;
5570       p = nextp;
5571       nextp = skip_over_field_signature(p, false, length, CHECK_0);
5572     }
5573     // The first non-signature thing better be a &#39;)&#39;
5574     if ((length &gt; 0) &amp;&amp; (*p++ == JVM_SIGNATURE_ENDFUNC)) {
5575       length--;
5576       if (name-&gt;utf8_length() &gt; 0 &amp;&amp; name-&gt;char_at(0) == JVM_SIGNATURE_SPECIAL) {
<a name="87" id="anc87"></a><span class="line-modified">5577         // All internal methods must return void</span>
5578         if ((length == 1) &amp;&amp; (p[0] == JVM_SIGNATURE_VOID)) {
5579           return args_size;
5580         }
<a name="88" id="anc88"></a>















5581       } else {
5582         // Now we better just have a return value
5583         nextp = skip_over_field_signature(p, true, length, CHECK_0);
5584         if (nextp &amp;&amp; ((int)length == (nextp - p))) {
5585           return args_size;
5586         }
5587       }
5588     }
5589   }
5590   // Report error
5591   throwIllegalSignature(&quot;Method&quot;, name, signature, CHECK_0);
5592   return 0;
5593 }
5594 
5595 int ClassFileParser::static_field_size() const {
5596   assert(_field_info != NULL, &quot;invariant&quot;);
5597   return _field_info-&gt;_static_field_size;
5598 }
5599 
5600 int ClassFileParser::total_oop_map_count() const {
5601   assert(_field_info != NULL, &quot;invariant&quot;);
5602   return _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count;
5603 }
5604 
5605 jint ClassFileParser::layout_size() const {
5606   assert(_field_info != NULL, &quot;invariant&quot;);
5607   return _field_info-&gt;_instance_size;
5608 }
5609 
5610 static void check_methods_for_intrinsics(const InstanceKlass* ik,
5611                                          const Array&lt;Method*&gt;* methods) {
5612   assert(ik != NULL, &quot;invariant&quot;);
5613   assert(methods != NULL, &quot;invariant&quot;);
5614 
5615   // Set up Method*::intrinsic_id as soon as we know the names of methods.
5616   // (We used to do this lazily, but now we query it in Rewriter,
5617   // which is eagerly done for every method, so we might as well do it now,
5618   // when everything is fresh in memory.)
5619   const vmSymbols::SID klass_id = Method::klass_id_for_intrinsics(ik);
5620 
5621   if (klass_id != vmSymbols::NO_SID) {
5622     for (int j = 0; j &lt; methods-&gt;length(); ++j) {
5623       Method* method = methods-&gt;at(j);
5624       method-&gt;init_intrinsic_id();
5625 
5626       if (CheckIntrinsics) {
5627         // Check if an intrinsic is defined for method &#39;method&#39;,
5628         // but the method is not annotated with @HotSpotIntrinsicCandidate.
5629         if (method-&gt;intrinsic_id() != vmIntrinsics::_none &amp;&amp;
5630             !method-&gt;intrinsic_candidate()) {
5631               tty-&gt;print(&quot;Compiler intrinsic is defined for method [%s], &quot;
5632               &quot;but the method is not annotated with @HotSpotIntrinsicCandidate.%s&quot;,
5633               method-&gt;name_and_sig_as_C_string(),
5634               NOT_DEBUG(&quot; Method will not be inlined.&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
5635             );
5636           tty-&gt;cr();
5637           DEBUG_ONLY(vm_exit(1));
5638         }
5639         // Check is the method &#39;method&#39; is annotated with @HotSpotIntrinsicCandidate,
5640         // but there is no intrinsic available for it.
5641         if (method-&gt;intrinsic_candidate() &amp;&amp;
5642           method-&gt;intrinsic_id() == vmIntrinsics::_none) {
5643             tty-&gt;print(&quot;Method [%s] is annotated with @HotSpotIntrinsicCandidate, &quot;
5644               &quot;but no compiler intrinsic is defined for the method.%s&quot;,
5645               method-&gt;name_and_sig_as_C_string(),
5646               NOT_DEBUG(&quot;&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
5647             );
5648           tty-&gt;cr();
5649           DEBUG_ONLY(vm_exit(1));
5650         }
5651       }
5652     } // end for
5653 
5654 #ifdef ASSERT
5655     if (CheckIntrinsics) {
5656       // Check for orphan methods in the current class. A method m
5657       // of a class C is orphan if an intrinsic is defined for method m,
5658       // but class C does not declare m.
5659       // The check is potentially expensive, therefore it is available
5660       // only in debug builds.
5661 
5662       for (int id = vmIntrinsics::FIRST_ID; id &lt; (int)vmIntrinsics::ID_LIMIT; ++id) {
5663         if (vmIntrinsics::_compiledLambdaForm == id) {
5664           // The _compiledLamdbdaForm intrinsic is a special marker for bytecode
5665           // generated for the JVM from a LambdaForm and therefore no method
5666           // is defined for it.
5667           continue;
5668         }
5669 
5670         if (vmIntrinsics::class_for(vmIntrinsics::ID_from(id)) == klass_id) {
5671           // Check if the current class contains a method with the same
5672           // name, flags, signature.
5673           bool match = false;
5674           for (int j = 0; j &lt; methods-&gt;length(); ++j) {
5675             const Method* method = methods-&gt;at(j);
5676             if (method-&gt;intrinsic_id() == id) {
5677               match = true;
5678               break;
5679             }
5680           }
5681 
5682           if (!match) {
5683             char buf[1000];
5684             tty-&gt;print(&quot;Compiler intrinsic is defined for method [%s], &quot;
5685                        &quot;but the method is not available in class [%s].%s&quot;,
5686                         vmIntrinsics::short_name_as_C_string(vmIntrinsics::ID_from(id),
5687                                                              buf, sizeof(buf)),
5688                         ik-&gt;name()-&gt;as_C_string(),
5689                         NOT_DEBUG(&quot;&quot;) DEBUG_ONLY(&quot; Exiting.&quot;)
5690             );
5691             tty-&gt;cr();
5692             DEBUG_ONLY(vm_exit(1));
5693           }
5694         }
5695       } // end for
5696     } // CheckIntrinsics
5697 #endif // ASSERT
5698   }
5699 }
5700 
5701 InstanceKlass* ClassFileParser::create_instance_klass(bool changed_by_loadhook,
5702                                                       const ClassInstanceInfo&amp; cl_inst_info,
5703                                                       TRAPS) {
5704   if (_klass != NULL) {
5705     return _klass;
5706   }
5707 
5708   InstanceKlass* const ik =
5709     InstanceKlass::allocate_instance_klass(*this, CHECK_NULL);
5710 
5711   if (is_hidden()) {
5712     mangle_hidden_class_name(ik);
5713   }
5714 
5715   fill_instance_klass(ik, changed_by_loadhook, cl_inst_info, CHECK_NULL);
5716 
5717   assert(_klass == ik, &quot;invariant&quot;);
5718 
5719 
5720   if (ik-&gt;should_store_fingerprint()) {
5721     ik-&gt;store_fingerprint(_stream-&gt;compute_fingerprint());
5722   }
5723 
5724   ik-&gt;set_has_passed_fingerprint_check(false);
5725   if (UseAOT &amp;&amp; ik-&gt;supers_have_passed_fingerprint_checks()) {
5726     uint64_t aot_fp = AOTLoader::get_saved_fingerprint(ik);
5727     uint64_t fp = ik-&gt;has_stored_fingerprint() ? ik-&gt;get_stored_fingerprint() : _stream-&gt;compute_fingerprint();
5728     if (aot_fp != 0 &amp;&amp; aot_fp == fp) {
5729       // This class matches with a class saved in an AOT library
5730       ik-&gt;set_has_passed_fingerprint_check(true);
5731     } else {
5732       ResourceMark rm;
5733       log_info(class, fingerprint)(&quot;%s :  expected = &quot; PTR64_FORMAT &quot; actual = &quot; PTR64_FORMAT,
5734                                  ik-&gt;external_name(), aot_fp, _stream-&gt;compute_fingerprint());
5735     }
5736   }
5737 
<a name="89" id="anc89"></a>





5738   return ik;
5739 }
5740 
<a name="90" id="anc90"></a>

































5741 void ClassFileParser::fill_instance_klass(InstanceKlass* ik,
5742                                           bool changed_by_loadhook,
5743                                           const ClassInstanceInfo&amp; cl_inst_info,
5744                                           TRAPS) {
5745   assert(ik != NULL, &quot;invariant&quot;);
5746 
5747   // Set name and CLD before adding to CLD
5748   ik-&gt;set_class_loader_data(_loader_data);
5749   ik-&gt;set_name(_class_name);
5750 
5751   // Add all classes to our internal class loader list here,
5752   // including classes in the bootstrap (NULL) class loader.
5753   const bool publicize = !is_internal();
5754 
5755   _loader_data-&gt;add_class(ik, publicize);
5756 
5757   set_klass_to_deallocate(ik);
5758 
5759   assert(_field_info != NULL, &quot;invariant&quot;);
5760   assert(ik-&gt;static_field_size() == _field_info-&gt;_static_field_size, &quot;sanity&quot;);
5761   assert(ik-&gt;nonstatic_oop_map_count() == _field_info-&gt;oop_map_blocks-&gt;_nonstatic_oop_map_count,
5762          &quot;sanity&quot;);
5763 
5764   assert(ik-&gt;is_instance_klass(), &quot;sanity&quot;);
5765   assert(ik-&gt;size_helper() == _field_info-&gt;_instance_size, &quot;sanity&quot;);
5766 
5767   // Fill in information already parsed
5768   ik-&gt;set_should_verify_class(_need_verify);
5769 
5770   // Not yet: supers are done below to support the new subtype-checking fields
5771   ik-&gt;set_nonstatic_field_size(_field_info-&gt;_nonstatic_field_size);
5772   ik-&gt;set_has_nonstatic_fields(_field_info-&gt;_has_nonstatic_fields);
<a name="91" id="anc91"></a>














5773   assert(_fac != NULL, &quot;invariant&quot;);
<a name="92" id="anc92"></a><span class="line-modified">5774   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP]);</span>
5775 
5776   // this transfers ownership of a lot of arrays from
5777   // the parser onto the InstanceKlass*
5778   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
5779 
5780   // can only set dynamic nest-host after static nest information is set
5781   if (cl_inst_info.dynamic_nest_host() != NULL) {
5782     ik-&gt;set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);
5783   }
5784 
5785   // note that is not safe to use the fields in the parser from this point on
5786   assert(NULL == _cp, &quot;invariant&quot;);
5787   assert(NULL == _fields, &quot;invariant&quot;);
5788   assert(NULL == _methods, &quot;invariant&quot;);
5789   assert(NULL == _inner_classes, &quot;invariant&quot;);
5790   assert(NULL == _nest_members, &quot;invariant&quot;);
5791   assert(NULL == _combined_annotations, &quot;invariant&quot;);
5792   assert(NULL == _record_components, &quot;invariant&quot;);
5793   assert(NULL == _permitted_subclasses, &quot;invariant&quot;);
5794 
5795   if (_has_final_method) {
5796     ik-&gt;set_has_final_method();
5797   }
5798 
5799   ik-&gt;copy_method_ordering(_method_ordering, CHECK);
5800   // The InstanceKlass::_methods_jmethod_ids cache
5801   // is managed on the assumption that the initial cache
5802   // size is equal to the number of methods in the class. If
5803   // that changes, then InstanceKlass::idnum_can_increment()
5804   // has to be changed accordingly.
5805   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
5806 
5807   ik-&gt;set_this_class_index(_this_class_index);
5808 
5809   if (_is_hidden || is_unsafe_anonymous()) {
5810     // _this_class_index is a CONSTANT_Class entry that refers to this
5811     // hidden or anonymous class itself. If this class needs to refer to its own
5812     // methods or fields, it would use a CONSTANT_MethodRef, etc, which would reference
5813     // _this_class_index. However, because this class is hidden or anonymous (it&#39;s
5814     // not stored in SystemDictionary), _this_class_index cannot be resolved
5815     // with ConstantPool::klass_at_impl, which does a SystemDictionary lookup.
5816     // Therefore, we must eagerly resolve _this_class_index now.
5817     ik-&gt;constants()-&gt;klass_at_put(_this_class_index, ik);
5818   }
5819 
5820   ik-&gt;set_minor_version(_minor_version);
5821   ik-&gt;set_major_version(_major_version);
5822   ik-&gt;set_has_nonstatic_concrete_methods(_has_nonstatic_concrete_methods);
5823   ik-&gt;set_declares_nonstatic_concrete_methods(_declares_nonstatic_concrete_methods);
<a name="93" id="anc93"></a>


5824 
5825   if (_unsafe_anonymous_host != NULL) {
5826     assert (ik-&gt;is_unsafe_anonymous(), &quot;should be the same&quot;);
5827     ik-&gt;set_unsafe_anonymous_host(_unsafe_anonymous_host);
5828   }
5829   if (_is_hidden) {
5830     ik-&gt;set_is_hidden();
5831   }
5832 
5833   // Set PackageEntry for this_klass
5834   oop cl = ik-&gt;class_loader();
5835   Handle clh = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(cl));
5836   ClassLoaderData* cld = ClassLoaderData::class_loader_data_or_null(clh());
5837   ik-&gt;set_package(cld, NULL, CHECK);
5838 
5839   const Array&lt;Method*&gt;* const methods = ik-&gt;methods();
5840   assert(methods != NULL, &quot;invariant&quot;);
5841   const int methods_len = methods-&gt;length();
5842 
5843   check_methods_for_intrinsics(ik, methods);
5844 
5845   // Fill in field values obtained by parse_classfile_attributes
5846   if (_parsed_annotations-&gt;has_any_annotations()) {
5847     _parsed_annotations-&gt;apply_to(ik);
5848   }
5849 
5850   apply_parsed_class_attributes(ik);
5851 
5852   // Miranda methods
5853   if ((_num_miranda_methods &gt; 0) ||
5854       // if this class introduced new miranda methods or
5855       (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_miranda_methods())
5856         // super class exists and this class inherited miranda methods
5857      ) {
5858        ik-&gt;set_has_miranda_methods(); // then set a flag
5859   }
5860 
5861   // Fill in information needed to compute superclasses.
5862   ik-&gt;initialize_supers(const_cast&lt;InstanceKlass*&gt;(_super_klass), _transitive_interfaces, CHECK);
5863   ik-&gt;set_transitive_interfaces(_transitive_interfaces);
5864   ik-&gt;set_local_interfaces(_local_interfaces);
5865   _transitive_interfaces = NULL;
5866   _local_interfaces = NULL;
5867 
5868   // Initialize itable offset tables
5869   klassItable::setup_itable_offset_table(ik);
5870 
5871   // Compute transitive closure of interfaces this class implements
5872   // Do final class setup
5873   OopMapBlocksBuilder* oop_map_blocks = _field_info-&gt;oop_map_blocks;
5874   if (oop_map_blocks-&gt;_nonstatic_oop_map_count &gt; 0) {
5875     oop_map_blocks-&gt;copy(ik-&gt;start_of_nonstatic_oop_maps());
5876   }
5877 
5878   if (_has_contended_fields || _parsed_annotations-&gt;is_contended() ||
5879       ( _super_klass != NULL &amp;&amp; _super_klass-&gt;has_contended_annotations())) {
5880     ik-&gt;set_has_contended_annotations(true);
5881   }
5882 
5883   // Fill in has_finalizer, has_vanilla_constructor, and layout_helper
5884   set_precomputed_flags(ik);
5885 
5886   // check if this class can access its super class
5887   check_super_class_access(ik, CHECK);
5888 
5889   // check if this class can access its superinterfaces
5890   check_super_interface_access(ik, CHECK);
5891 
5892   // check if this class overrides any final method
5893   check_final_method_override(ik, CHECK);
5894 
5895   // reject static interface methods prior to Java 8
5896   if (ik-&gt;is_interface() &amp;&amp; _major_version &lt; JAVA_8_VERSION) {
5897     check_illegal_static_method(ik, CHECK);
5898   }
5899 
5900   // Obtain this_klass&#39; module entry
5901   ModuleEntry* module_entry = ik-&gt;module();
5902   assert(module_entry != NULL, &quot;module_entry should always be set&quot;);
5903 
5904   // Obtain java.lang.Module
5905   Handle module_handle(THREAD, module_entry-&gt;module());
5906 
5907   // Allocate mirror and initialize static fields
5908   // The create_mirror() call will also call compute_modifiers()
5909   java_lang_Class::create_mirror(ik,
5910                                  Handle(THREAD, _loader_data-&gt;class_loader()),
5911                                  module_handle,
5912                                  _protection_domain,
5913                                  cl_inst_info.class_data(),
5914                                  CHECK);
5915 
5916   assert(_all_mirandas != NULL, &quot;invariant&quot;);
5917 
5918   // Generate any default methods - default methods are public interface methods
5919   // that have a default implementation.  This is new with Java 8.
5920   if (_has_nonstatic_concrete_methods) {
5921     DefaultMethods::generate_default_methods(ik,
5922                                              _all_mirandas,
5923                                              CHECK);
5924   }
5925 
5926   // Add read edges to the unnamed modules of the bootstrap and app class loaders.
5927   if (changed_by_loadhook &amp;&amp; !module_handle.is_null() &amp;&amp; module_entry-&gt;is_named() &amp;&amp;
5928       !module_entry-&gt;has_default_read_edges()) {
5929     if (!module_entry-&gt;set_has_default_read_edges()) {
5930       // We won a potential race
5931       JvmtiExport::add_default_read_edges(module_handle, THREAD);
5932     }
5933   }
5934 
<a name="94" id="anc94"></a>

































5935   ClassLoadingService::notify_class_loaded(ik, false /* not shared class */);
5936 
5937   if (!is_internal()) {
5938     if (log_is_enabled(Info, class, load)) {
5939       ResourceMark rm;
5940       const char* module_name = (module_entry-&gt;name() == NULL) ? UNNAMED_MODULE : module_entry-&gt;name()-&gt;as_C_string();
5941       ik-&gt;print_class_load_logging(_loader_data, module_name, _stream);
5942     }
5943 
5944     if (ik-&gt;minor_version() == JAVA_PREVIEW_MINOR_VERSION &amp;&amp;
5945         ik-&gt;major_version() == JVM_CLASSFILE_MAJOR_VERSION &amp;&amp;
5946         log_is_enabled(Info, class, preview)) {
5947       ResourceMark rm;
5948       log_info(class, preview)(&quot;Loading class %s that depends on preview features (class file version %d.65535)&quot;,
5949                                ik-&gt;external_name(), JVM_CLASSFILE_MAJOR_VERSION);
5950     }
5951 
5952     if (log_is_enabled(Debug, class, resolve))  {
5953       ResourceMark rm;
5954       // print out the superclass.
5955       const char * from = ik-&gt;external_name();
5956       if (ik-&gt;java_super() != NULL) {
5957         log_debug(class, resolve)(&quot;%s %s (super)&quot;,
5958                    from,
5959                    ik-&gt;java_super()-&gt;external_name());
5960       }
5961       // print out each of the interface classes referred to by this class.
5962       const Array&lt;InstanceKlass*&gt;* const local_interfaces = ik-&gt;local_interfaces();
5963       if (local_interfaces != NULL) {
5964         const int length = local_interfaces-&gt;length();
5965         for (int i = 0; i &lt; length; i++) {
5966           const InstanceKlass* const k = local_interfaces-&gt;at(i);
5967           const char * to = k-&gt;external_name();
5968           log_debug(class, resolve)(&quot;%s %s (interface)&quot;, from, to);
5969         }
5970       }
5971     }
5972   }
5973 
5974   JFR_ONLY(INIT_ID(ik);)
5975 
5976   // If we reach here, all is well.
5977   // Now remove the InstanceKlass* from the _klass_to_deallocate field
5978   // in order for it to not be destroyed in the ClassFileParser destructor.
5979   set_klass_to_deallocate(NULL);
5980 
5981   // it&#39;s official
5982   set_klass(ik);
5983 
<a name="95" id="anc95"></a>



5984   debug_only(ik-&gt;verify();)
5985 }
5986 
5987 void ClassFileParser::update_class_name(Symbol* new_class_name) {
5988   // Decrement the refcount in the old name, since we&#39;re clobbering it.
5989   _class_name-&gt;decrement_refcount();
5990 
5991   _class_name = new_class_name;
5992   // Increment the refcount of the new name.
5993   // Now the ClassFileParser owns this name and will decrement in
5994   // the destructor.
5995   _class_name-&gt;increment_refcount();
5996 }
5997 
5998 // For an unsafe anonymous class that is in the unnamed package, move it to its host class&#39;s
5999 // package by prepending its host class&#39;s package name to its class name and setting
6000 // its _class_name field.
6001 void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {
6002   ResourceMark rm(THREAD);
6003   assert(strrchr(_class_name-&gt;as_C_string(), JVM_SIGNATURE_SLASH) == NULL,
6004          &quot;Unsafe anonymous class should not be in a package&quot;);
6005   TempNewSymbol host_pkg_name =
6006     ClassLoader::package_from_class_name(unsafe_anonymous_host-&gt;name());
6007 
6008   if (host_pkg_name != NULL) {
6009     int host_pkg_len = host_pkg_name-&gt;utf8_length();
6010     int class_name_len = _class_name-&gt;utf8_length();
6011     int symbol_len = host_pkg_len + 1 + class_name_len;
6012     char* new_anon_name = NEW_RESOURCE_ARRAY(char, symbol_len + 1);
6013     int n = os::snprintf(new_anon_name, symbol_len + 1, &quot;%.*s/%.*s&quot;,
6014                          host_pkg_len, host_pkg_name-&gt;base(), class_name_len, _class_name-&gt;base());
6015     assert(n == symbol_len, &quot;Unexpected number of characters in string&quot;);
6016 
6017     // Decrement old _class_name to avoid leaking.
6018     _class_name-&gt;decrement_refcount();
6019 
6020     // Create a symbol and update the anonymous class name.
6021     // The new class name is created with a refcount of one. When installed into the InstanceKlass,
6022     // it&#39;ll be two and when the ClassFileParser destructor runs, it&#39;ll go back to one and get deleted
6023     // when the class is unloaded.
6024     _class_name = SymbolTable::new_symbol(new_anon_name, symbol_len);
6025   }
6026 }
6027 
6028 // If the host class and the anonymous class are in the same package then do
6029 // nothing.  If the anonymous class is in the unnamed package then move it to its
6030 // host&#39;s package.  If the classes are in different packages then throw an IAE
6031 // exception.
6032 void ClassFileParser::fix_unsafe_anonymous_class_name(TRAPS) {
6033   assert(_unsafe_anonymous_host != NULL, &quot;Expected an unsafe anonymous class&quot;);
6034 
6035   const jbyte* anon_last_slash = UTF8::strrchr((const jbyte*)_class_name-&gt;base(),
6036                                                _class_name-&gt;utf8_length(), JVM_SIGNATURE_SLASH);
6037   if (anon_last_slash == NULL) {  // Unnamed package
6038     prepend_host_package_name(_unsafe_anonymous_host, CHECK);
6039   } else {
6040     if (!_unsafe_anonymous_host-&gt;is_same_class_package(_unsafe_anonymous_host-&gt;class_loader(), _class_name)) {
6041       ResourceMark rm(THREAD);
6042       THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
6043         err_msg(&quot;Host class %s and anonymous class %s are in different packages&quot;,
6044         _unsafe_anonymous_host-&gt;name()-&gt;as_C_string(), _class_name-&gt;as_C_string()));
6045     }
6046   }
6047 }
6048 
6049 static bool relax_format_check_for(ClassLoaderData* loader_data) {
6050   bool trusted = loader_data-&gt;is_boot_class_loader_data() ||
6051                  loader_data-&gt;is_platform_class_loader_data();
6052   bool need_verify =
6053     // verifyAll
6054     (BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote) ||
6055     // verifyRemote
6056     (!BytecodeVerificationLocal &amp;&amp; BytecodeVerificationRemote &amp;&amp; !trusted);
6057   return !need_verify;
6058 }
6059 
6060 ClassFileParser::ClassFileParser(ClassFileStream* stream,
6061                                  Symbol* name,
6062                                  ClassLoaderData* loader_data,
6063                                  const ClassLoadInfo* cl_info,
6064                                  Publicity pub_level,
6065                                  TRAPS) :
6066   _stream(stream),
6067   _class_name(NULL),
6068   _loader_data(loader_data),
6069   _unsafe_anonymous_host(cl_info-&gt;unsafe_anonymous_host()),
6070   _cp_patches(cl_info-&gt;cp_patches()),
6071   _is_hidden(cl_info-&gt;is_hidden()),
6072   _can_access_vm_annotations(cl_info-&gt;can_access_vm_annotations()),
6073   _num_patched_klasses(0),
6074   _max_num_patched_klasses(0),
6075   _orig_cp_size(0),
6076   _first_patched_klass_resolved_index(0),
6077   _super_klass(),
6078   _cp(NULL),
6079   _fields(NULL),
6080   _methods(NULL),
6081   _inner_classes(NULL),
6082   _nest_members(NULL),
6083   _nest_host(0),
6084   _permitted_subclasses(NULL),
6085   _record_components(NULL),
<a name="96" id="anc96"></a>
6086   _local_interfaces(NULL),
6087   _transitive_interfaces(NULL),
6088   _combined_annotations(NULL),
6089   _class_annotations(NULL),
6090   _class_type_annotations(NULL),
6091   _fields_annotations(NULL),
6092   _fields_type_annotations(NULL),
6093   _klass(NULL),
6094   _klass_to_deallocate(NULL),
6095   _parsed_annotations(NULL),
6096   _fac(NULL),
6097   _field_info(NULL),
6098   _method_ordering(NULL),
6099   _all_mirandas(NULL),
6100   _vtable_size(0),
6101   _itable_size(0),
6102   _num_miranda_methods(0),
6103   _rt(REF_NONE),
6104   _protection_domain(cl_info-&gt;protection_domain()),
6105   _access_flags(),
6106   _pub_level(pub_level),
6107   _bad_constant_seen(0),
6108   _synthetic_flag(false),
6109   _sde_length(false),
6110   _sde_buffer(NULL),
6111   _sourcefile_index(0),
6112   _generic_signature_index(0),
6113   _major_version(0),
6114   _minor_version(0),
6115   _this_class_index(0),
6116   _super_class_index(0),
6117   _itfs_len(0),
6118   _java_fields_count(0),
6119   _need_verify(false),
6120   _relax_verify(false),
6121   _has_nonstatic_concrete_methods(false),
6122   _declares_nonstatic_concrete_methods(false),
6123   _has_final_method(false),
6124   _has_contended_fields(false),
<a name="97" id="anc97"></a>








6125   _has_finalizer(false),
6126   _has_empty_finalizer(false),
6127   _has_vanilla_constructor(false),
6128   _max_bootstrap_specifier_index(-1) {
6129 
6130   _class_name = name != NULL ? name : vmSymbols::unknown_class_name();
6131   _class_name-&gt;increment_refcount();
6132 
6133   assert(THREAD-&gt;is_Java_thread(), &quot;invariant&quot;);
6134   assert(_loader_data != NULL, &quot;invariant&quot;);
6135   assert(stream != NULL, &quot;invariant&quot;);
6136   assert(_stream != NULL, &quot;invariant&quot;);
6137   assert(_stream-&gt;buffer() == _stream-&gt;current(), &quot;invariant&quot;);
6138   assert(_class_name != NULL, &quot;invariant&quot;);
6139   assert(0 == _access_flags.as_int(), &quot;invariant&quot;);
6140 
6141   // Figure out whether we can skip format checking (matching classic VM behavior)
6142   if (DumpSharedSpaces) {
6143     // verify == true means it&#39;s a &#39;remote&#39; class (i.e., non-boot class)
6144     // Verification decision is based on BytecodeVerificationRemote flag
6145     // for those classes.
6146     _need_verify = (stream-&gt;need_verify()) ? BytecodeVerificationRemote :
6147                                               BytecodeVerificationLocal;
6148   }
6149   else {
6150     _need_verify = Verifier::should_verify_for(_loader_data-&gt;class_loader(),
6151                                                stream-&gt;need_verify());
6152   }
6153   if (_cp_patches != NULL) {
6154     int len = _cp_patches-&gt;length();
6155     for (int i=0; i&lt;len; i++) {
6156       if (has_cp_patch_at(i)) {
6157         Handle patch = cp_patch_at(i);
6158         if (java_lang_String::is_instance(patch()) || java_lang_Class::is_instance(patch())) {
6159           // We need to append the names of the patched classes to the end of the constant pool,
6160           // because a patched class may have a Utf8 name that&#39;s not already included in the
6161           // original constant pool. These class names are used when patch_constant_pool()
6162           // calls patch_class().
6163           //
6164           // Note that a String in cp_patch_at(i) may be used to patch a Utf8, a String, or a Class.
6165           // At this point, we don&#39;t know the tag for index i yet, because we haven&#39;t parsed the
6166           // constant pool. So we can only assume the worst -- every String is used to patch a Class.
6167           _max_num_patched_klasses++;
6168         }
6169       }
6170     }
6171   }
6172 
6173   // synch back verification state to stream
6174   stream-&gt;set_verify(_need_verify);
6175 
6176   // Check if verification needs to be relaxed for this class file
6177   // Do not restrict it to jdk1.0 or jdk1.1 to maintain backward compatibility (4982376)
6178   _relax_verify = relax_format_check_for(_loader_data);
6179 
6180   parse_stream(stream, CHECK);
6181 
6182   post_process_parsed_stream(stream, _cp, CHECK);
6183 }
6184 
6185 void ClassFileParser::clear_class_metadata() {
6186   // metadata created before the instance klass is created.  Must be
6187   // deallocated if classfile parsing returns an error.
6188   _cp = NULL;
6189   _fields = NULL;
6190   _methods = NULL;
6191   _inner_classes = NULL;
6192   _nest_members = NULL;
6193   _permitted_subclasses = NULL;
6194   _combined_annotations = NULL;
6195   _class_annotations = _class_type_annotations = NULL;
6196   _fields_annotations = _fields_type_annotations = NULL;
6197   _record_components = NULL;
6198 }
6199 
6200 // Destructor to clean up
6201 ClassFileParser::~ClassFileParser() {
6202   _class_name-&gt;decrement_refcount();
6203 
6204   if (_cp != NULL) {
6205     MetadataFactory::free_metadata(_loader_data, _cp);
6206   }
6207   if (_fields != NULL) {
6208     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _fields);
6209   }
6210 
6211   if (_methods != NULL) {
6212     // Free methods
6213     InstanceKlass::deallocate_methods(_loader_data, _methods);
6214   }
6215 
6216   // beware of the Universe::empty_blah_array!!
6217   if (_inner_classes != NULL &amp;&amp; _inner_classes != Universe::the_empty_short_array()) {
6218     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _inner_classes);
6219   }
6220 
6221   if (_nest_members != NULL &amp;&amp; _nest_members != Universe::the_empty_short_array()) {
6222     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _nest_members);
6223   }
6224 
6225   if (_record_components != NULL) {
6226     InstanceKlass::deallocate_record_components(_loader_data, _record_components);
6227   }
6228 
6229   if (_permitted_subclasses != NULL &amp;&amp; _permitted_subclasses != Universe::the_empty_short_array()) {
6230     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _permitted_subclasses);
6231   }
6232 
6233   // Free interfaces
6234   InstanceKlass::deallocate_interfaces(_loader_data, _super_klass,
6235                                        _local_interfaces, _transitive_interfaces);
6236 
6237   if (_combined_annotations != NULL) {
6238     // After all annotations arrays have been created, they are installed into the
6239     // Annotations object that will be assigned to the InstanceKlass being created.
6240 
6241     // Deallocate the Annotations object and the installed annotations arrays.
6242     _combined_annotations-&gt;deallocate_contents(_loader_data);
6243 
6244     // If the _combined_annotations pointer is non-NULL,
6245     // then the other annotations fields should have been cleared.
6246     assert(_class_annotations       == NULL, &quot;Should have been cleared&quot;);
6247     assert(_class_type_annotations  == NULL, &quot;Should have been cleared&quot;);
6248     assert(_fields_annotations      == NULL, &quot;Should have been cleared&quot;);
6249     assert(_fields_type_annotations == NULL, &quot;Should have been cleared&quot;);
6250   } else {
6251     // If the annotations arrays were not installed into the Annotations object,
6252     // then they have to be deallocated explicitly.
6253     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _class_annotations);
6254     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _class_type_annotations);
6255     Annotations::free_contents(_loader_data, _fields_annotations);
6256     Annotations::free_contents(_loader_data, _fields_type_annotations);
6257   }
6258 
6259   clear_class_metadata();
6260   _transitive_interfaces = NULL;
6261   _local_interfaces = NULL;
6262 
6263   // deallocate the klass if already created.  Don&#39;t directly deallocate, but add
6264   // to the deallocate list so that the klass is removed from the CLD::_klasses list
6265   // at a safepoint.
6266   if (_klass_to_deallocate != NULL) {
6267     _loader_data-&gt;add_to_deallocate_list(_klass_to_deallocate);
6268   }
6269 }
6270 
6271 void ClassFileParser::parse_stream(const ClassFileStream* const stream,
6272                                    TRAPS) {
6273 
6274   assert(stream != NULL, &quot;invariant&quot;);
6275   assert(_class_name != NULL, &quot;invariant&quot;);
6276 
6277   // BEGIN STREAM PARSING
6278   stream-&gt;guarantee_more(8, CHECK);  // magic, major, minor
6279   // Magic value
6280   const u4 magic = stream-&gt;get_u4_fast();
6281   guarantee_property(magic == JAVA_CLASSFILE_MAGIC,
6282                      &quot;Incompatible magic value %u in class file %s&quot;,
6283                      magic, CHECK);
6284 
6285   // Version numbers
6286   _minor_version = stream-&gt;get_u2_fast();
6287   _major_version = stream-&gt;get_u2_fast();
6288 
6289   if (DumpSharedSpaces &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6290     ResourceMark rm;
6291     warning(&quot;Pre JDK 6 class not supported by CDS: %u.%u %s&quot;,
6292             _major_version,  _minor_version, _class_name-&gt;as_C_string());
6293     Exceptions::fthrow(
6294       THREAD_AND_LOCATION,
6295       vmSymbols::java_lang_UnsupportedClassVersionError(),
6296       &quot;Unsupported major.minor version for dump time %u.%u&quot;,
6297       _major_version,
6298       _minor_version);
6299   }
6300 
6301   // Check version numbers - we check this even with verifier off
6302   verify_class_version(_major_version, _minor_version, _class_name, CHECK);
6303 
6304   stream-&gt;guarantee_more(3, CHECK); // length, first cp tag
6305   u2 cp_size = stream-&gt;get_u2_fast();
6306 
6307   guarantee_property(
6308     cp_size &gt;= 1, &quot;Illegal constant pool size %u in class file %s&quot;,
6309     cp_size, CHECK);
6310 
6311   _orig_cp_size = cp_size;
6312   if (is_hidden()) { // Add a slot for hidden class name.
6313     assert(_max_num_patched_klasses == 0, &quot;Sanity check&quot;);
6314     cp_size++;
6315   } else {
6316     if (int(cp_size) + _max_num_patched_klasses &gt; 0xffff) {
6317       THROW_MSG(vmSymbols::java_lang_InternalError(), &quot;not enough space for patched classes&quot;);
6318     }
6319     cp_size += _max_num_patched_klasses;
6320   }
6321 
6322   _cp = ConstantPool::allocate(_loader_data,
6323                                cp_size,
6324                                CHECK);
6325 
6326   ConstantPool* const cp = _cp;
6327 
6328   parse_constant_pool(stream, cp, _orig_cp_size, CHECK);
6329 
6330   assert(cp_size == (const u2)cp-&gt;length(), &quot;invariant&quot;);
6331 
6332   // ACCESS FLAGS
6333   stream-&gt;guarantee_more(8, CHECK);  // flags, this_class, super_class, infs_len
6334 
<a name="98" id="anc98"></a><span class="line-modified">6335   // Access flags</span>
<span class="line-removed">6336   jint flags;</span>
6337   // JVM_ACC_MODULE is defined in JDK-9 and later.
6338   if (_major_version &gt;= JAVA_9_VERSION) {
<a name="99" id="anc99"></a><span class="line-modified">6339     flags = stream-&gt;get_u2_fast() &amp; (JVM_RECOGNIZED_CLASS_MODIFIERS | JVM_ACC_MODULE);</span>
<span class="line-modified">6340   } else {</span>
<span class="line-modified">6341     flags = stream-&gt;get_u2_fast() &amp; JVM_RECOGNIZED_CLASS_MODIFIERS;</span>


6342   }
6343 
<a name="100" id="anc100"></a>


6344   if ((flags &amp; JVM_ACC_INTERFACE) &amp;&amp; _major_version &lt; JAVA_6_VERSION) {
6345     // Set abstract bit for old class files for backward compatibility
6346     flags |= JVM_ACC_ABSTRACT;
6347   }
6348 
6349   verify_legal_class_modifiers(flags, CHECK);
6350 
6351   short bad_constant = class_bad_constant_seen();
6352   if (bad_constant != 0) {
6353     // Do not throw CFE until after the access_flags are checked because if
6354     // ACC_MODULE is set in the access flags, then NCDFE must be thrown, not CFE.
6355     classfile_parse_error(&quot;Unknown constant tag %u in class file %s&quot;, bad_constant, CHECK);
6356   }
6357 
6358   _access_flags.set_flags(flags);
6359 
6360   // This class and superclass
6361   _this_class_index = stream-&gt;get_u2_fast();
6362   check_property(
6363     valid_cp_range(_this_class_index, cp_size) &amp;&amp;
6364       cp-&gt;tag_at(_this_class_index).is_unresolved_klass(),
6365     &quot;Invalid this class index %u in constant pool in class file %s&quot;,
6366     _this_class_index, CHECK);
6367 
6368   Symbol* const class_name_in_cp = cp-&gt;klass_name_at(_this_class_index);
6369   assert(class_name_in_cp != NULL, &quot;class_name can&#39;t be null&quot;);
6370 
6371   // Don&#39;t need to check whether this class name is legal or not.
6372   // It has been checked when constant pool is parsed.
6373   // However, make sure it is not an array type.
6374   if (_need_verify) {
6375     guarantee_property(class_name_in_cp-&gt;char_at(0) != JVM_SIGNATURE_ARRAY,
6376                        &quot;Bad class name in class file %s&quot;,
6377                        CHECK);
6378   }
6379 
6380 #ifdef ASSERT
6381   // Basic sanity checks
6382   assert(!(_is_hidden &amp;&amp; (_unsafe_anonymous_host != NULL)), &quot;mutually exclusive variants&quot;);
6383 
6384   if (_unsafe_anonymous_host != NULL) {
6385     assert(_class_name == vmSymbols::unknown_class_name(), &quot;A named anonymous class???&quot;);
6386   }
6387   if (_is_hidden) {
6388     assert(_class_name != vmSymbols::unknown_class_name(), &quot;hidden classes should have a special name&quot;);
6389   }
6390 #endif
6391 
6392   // Update the _class_name as needed depending on whether this is a named,
6393   // un-named, hidden or unsafe-anonymous class.
6394 
6395   if (_is_hidden) {
6396     assert(_class_name != NULL, &quot;Unexpected null _class_name&quot;);
6397 #ifdef ASSERT
6398     if (_need_verify) {
6399       verify_legal_class_name(_class_name, CHECK);
6400     }
6401 #endif
6402 
6403   // NOTE: !_is_hidden does not imply &quot;findable&quot; as it could be an old-style
6404   //       &quot;hidden&quot; unsafe-anonymous class
6405 
6406   // If this is an anonymous class fix up its name if it is in the unnamed
6407   // package.  Otherwise, throw IAE if it is in a different package than
6408   // its host class.
6409   } else if (_unsafe_anonymous_host != NULL) {
6410     update_class_name(class_name_in_cp);
6411     fix_unsafe_anonymous_class_name(CHECK);
6412 
6413   } else {
6414     // Check if name in class file matches given name
6415     if (_class_name != class_name_in_cp) {
6416       if (_class_name != vmSymbols::unknown_class_name()) {
6417         ResourceMark rm(THREAD);
6418         Exceptions::fthrow(THREAD_AND_LOCATION,
6419                            vmSymbols::java_lang_NoClassDefFoundError(),
6420                            &quot;%s (wrong name: %s)&quot;,
6421                            class_name_in_cp-&gt;as_C_string(),
6422                            _class_name-&gt;as_C_string()
6423                            );
6424         return;
6425       } else {
6426         // The class name was not known by the caller so we set it from
6427         // the value in the CP.
6428         update_class_name(class_name_in_cp);
6429       }
6430       // else nothing to do: the expected class name matches what is in the CP
6431     }
6432   }
6433 
6434   // Verification prevents us from creating names with dots in them, this
6435   // asserts that that&#39;s the case.
6436   assert(is_internal_format(_class_name), &quot;external class name format used internally&quot;);
6437 
6438   if (!is_internal()) {
6439     LogTarget(Debug, class, preorder) lt;
6440     if (lt.is_enabled()){
6441       ResourceMark rm(THREAD);
6442       LogStream ls(lt);
6443       ls.print(&quot;%s&quot;, _class_name-&gt;as_klass_external_name());
6444       if (stream-&gt;source() != NULL) {
6445         ls.print(&quot; source: %s&quot;, stream-&gt;source());
6446       }
6447       ls.cr();
6448     }
6449 
6450 #if INCLUDE_CDS
6451     if (DumpLoadedClassList != NULL &amp;&amp; stream-&gt;source() != NULL &amp;&amp; classlist_file-&gt;is_open()) {
6452       if (!ClassLoader::has_jrt_entry()) {
6453         warning(&quot;DumpLoadedClassList and CDS are not supported in exploded build&quot;);
6454         DumpLoadedClassList = NULL;
6455       } else if (SystemDictionaryShared::is_sharing_possible(_loader_data) &amp;&amp;
6456                  !_is_hidden &amp;&amp;
6457                  _unsafe_anonymous_host == NULL) {
6458         // Only dump the classes that can be stored into CDS archive.
6459         // Hidden and unsafe anonymous classes such as generated LambdaForm classes are also not included.
6460         oop class_loader = _loader_data-&gt;class_loader();
6461         ResourceMark rm(THREAD);
6462         bool skip = false;
6463         if (class_loader == NULL || SystemDictionary::is_platform_class_loader(class_loader)) {
6464           // For the boot and platform class loaders, skip classes that are not found in the
6465           // java runtime image, such as those found in the --patch-module entries.
6466           // These classes can&#39;t be loaded from the archive during runtime.
6467           if (!stream-&gt;from_boot_loader_modules_image() &amp;&amp; strncmp(stream-&gt;source(), &quot;jrt:&quot;, 4) != 0) {
6468             skip = true;
6469           }
6470 
6471           if (class_loader == NULL &amp;&amp; ClassLoader::contains_append_entry(stream-&gt;source())) {
6472             // .. but don&#39;t skip the boot classes that are loaded from -Xbootclasspath/a
6473             // as they can be loaded from the archive during runtime.
6474             skip = false;
6475           }
6476         }
6477         if (skip) {
6478           tty-&gt;print_cr(&quot;skip writing class %s from source %s to classlist file&quot;,
6479             _class_name-&gt;as_C_string(), stream-&gt;source());
6480         } else {
6481           classlist_file-&gt;print_cr(&quot;%s&quot;, _class_name-&gt;as_C_string());
6482           classlist_file-&gt;flush();
6483         }
6484       }
6485     }
6486 #endif
6487   }
6488 
6489   // SUPERKLASS
6490   _super_class_index = stream-&gt;get_u2_fast();
6491   _super_klass = parse_super_class(cp,
6492                                    _super_class_index,
6493                                    _need_verify,
6494                                    CHECK);
6495 
6496   // Interfaces
6497   _itfs_len = stream-&gt;get_u2_fast();
6498   parse_interfaces(stream,
6499                    _itfs_len,
6500                    cp,
<a name="101" id="anc101"></a>
6501                    &amp;_has_nonstatic_concrete_methods,
<a name="102" id="anc102"></a>
6502                    CHECK);
6503 
<a name="103" id="anc103"></a><span class="line-modified">6504   assert(_local_interfaces != NULL, &quot;invariant&quot;);</span>
6505 
6506   // Fields (offsets are filled in later)
6507   _fac = new FieldAllocationCount();
6508   parse_fields(stream,
<a name="104" id="anc104"></a><span class="line-modified">6509                _access_flags.is_interface(),</span>

6510                _fac,
6511                cp,
6512                cp_size,
6513                &amp;_java_fields_count,
6514                CHECK);
6515 
6516   assert(_fields != NULL, &quot;invariant&quot;);
6517 
6518   // Methods
6519   AccessFlags promoted_flags;
6520   parse_methods(stream,
<a name="105" id="anc105"></a><span class="line-modified">6521                 _access_flags.is_interface(),</span>

6522                 &amp;promoted_flags,
6523                 &amp;_has_final_method,
6524                 &amp;_declares_nonstatic_concrete_methods,
6525                 CHECK);
6526 
6527   assert(_methods != NULL, &quot;invariant&quot;);
6528 
6529   // promote flags from parse_methods() to the klass&#39; flags
6530   _access_flags.add_promoted_flags(promoted_flags.as_int());
6531 
6532   if (_declares_nonstatic_concrete_methods) {
6533     _has_nonstatic_concrete_methods = true;
6534   }
6535 
6536   // Additional attributes/annotations
6537   _parsed_annotations = new ClassAnnotationCollector();
6538   parse_classfile_attributes(stream, cp, _parsed_annotations, CHECK);
6539 
6540   assert(_inner_classes != NULL, &quot;invariant&quot;);
6541 
6542   // Finalize the Annotations metadata object,
6543   // now that all annotation arrays have been created.
6544   create_combined_annotations(CHECK);
6545 
6546   // Make sure this is the end of class file stream
6547   guarantee_property(stream-&gt;at_eos(),
6548                      &quot;Extra bytes at the end of class file %s&quot;,
6549                      CHECK);
6550 
6551   // all bytes in stream read and parsed
6552 }
6553 
6554 void ClassFileParser::mangle_hidden_class_name(InstanceKlass* const ik) {
6555   ResourceMark rm;
6556   // Construct hidden name from _class_name, &quot;+&quot;, and &amp;ik. Note that we can&#39;t
6557   // use a &#39;/&#39; because that confuses finding the class&#39;s package.  Also, can&#39;t
6558   // use an illegal char such as &#39;;&#39; because that causes serialization issues
6559   // and issues with hidden classes that create their own hidden classes.
6560   char addr_buf[20];
6561   jio_snprintf(addr_buf, 20, INTPTR_FORMAT, p2i(ik));
6562   size_t new_name_len = _class_name-&gt;utf8_length() + 2 + strlen(addr_buf);
6563   char* new_name = NEW_RESOURCE_ARRAY(char, new_name_len);
6564   jio_snprintf(new_name, new_name_len, &quot;%s+%s&quot;,
6565                _class_name-&gt;as_C_string(), addr_buf);
6566   update_class_name(SymbolTable::new_symbol(new_name));
6567 
6568   // Add a Utf8 entry containing the hidden name.
6569   assert(_class_name != NULL, &quot;Unexpected null _class_name&quot;);
6570   int hidden_index = _orig_cp_size; // this is an extra slot we added
6571   _cp-&gt;symbol_at_put(hidden_index, _class_name);
6572 
6573   // Update this_class_index&#39;s slot in the constant pool with the new Utf8 entry.
6574   // We have to update the resolved_klass_index and the name_index together
6575   // so extract the existing resolved_klass_index first.
6576   CPKlassSlot cp_klass_slot = _cp-&gt;klass_slot_at(_this_class_index);
6577   int resolved_klass_index = cp_klass_slot.resolved_klass_index();
6578   _cp-&gt;unresolved_klass_at_put(_this_class_index, hidden_index, resolved_klass_index);
6579   assert(_cp-&gt;klass_slot_at(_this_class_index).name_index() == _orig_cp_size,
6580          &quot;Bad name_index&quot;);
6581 }
6582 
6583 void ClassFileParser::post_process_parsed_stream(const ClassFileStream* const stream,
6584                                                  ConstantPool* cp,
6585                                                  TRAPS) {
6586   assert(stream != NULL, &quot;invariant&quot;);
6587   assert(stream-&gt;at_eos(), &quot;invariant&quot;);
6588   assert(cp != NULL, &quot;invariant&quot;);
6589   assert(_loader_data != NULL, &quot;invariant&quot;);
6590 
6591   if (_class_name == vmSymbols::java_lang_Object()) {
<a name="106" id="anc106"></a><span class="line-modified">6592     check_property(_local_interfaces == Universe::the_empty_instance_klass_array(),</span>
<span class="line-modified">6593                    &quot;java.lang.Object cannot implement an interface in class file %s&quot;,</span>
<span class="line-modified">6594                    CHECK);</span>
6595   }
6596   // We check super class after class file is parsed and format is checked
6597   if (_super_class_index &gt; 0 &amp;&amp; NULL ==_super_klass) {
6598     Symbol* const super_class_name = cp-&gt;klass_name_at(_super_class_index);
<a name="107" id="anc107"></a><span class="line-modified">6599     if (_access_flags.is_interface()) {</span>
6600       // Before attempting to resolve the superclass, check for class format
6601       // errors not checked yet.
6602       guarantee_property(super_class_name == vmSymbols::java_lang_Object(),
6603         &quot;Interfaces must have java.lang.Object as superclass in class file %s&quot;,
6604         CHECK);
6605     }
6606     Handle loader(THREAD, _loader_data-&gt;class_loader());
6607     _super_klass = (const InstanceKlass*)
6608                        SystemDictionary::resolve_super_or_fail(_class_name,
6609                                                                super_class_name,
6610                                                                loader,
6611                                                                _protection_domain,
6612                                                                true,
6613                                                                CHECK);
6614   }
6615 
6616   if (_super_klass != NULL) {
6617     if (_super_klass-&gt;has_nonstatic_concrete_methods()) {
6618       _has_nonstatic_concrete_methods = true;
6619     }
<a name="108" id="anc108"></a>


6620 
6621     if (_super_klass-&gt;is_interface()) {
6622       ResourceMark rm(THREAD);
6623       Exceptions::fthrow(
6624         THREAD_AND_LOCATION,
6625         vmSymbols::java_lang_IncompatibleClassChangeError(),
6626         &quot;class %s has interface %s as super class&quot;,
6627         _class_name-&gt;as_klass_external_name(),
6628         _super_klass-&gt;external_name()
6629       );
6630       return;
6631     }
<a name="109" id="anc109"></a>




































6632   }
6633 
<a name="110" id="anc110"></a>


















6634   // Compute the transitive list of all unique interfaces implemented by this class
6635   _transitive_interfaces =
6636     compute_transitive_interfaces(_super_klass,
6637                                   _local_interfaces,
6638                                   _loader_data,
6639                                   CHECK);
6640 
6641   assert(_transitive_interfaces != NULL, &quot;invariant&quot;);
6642 
6643   // sort methods
6644   _method_ordering = sort_methods(_methods);
6645 
6646   _all_mirandas = new GrowableArray&lt;Method*&gt;(20);
6647 
6648   Handle loader(THREAD, _loader_data-&gt;class_loader());
6649   klassVtable::compute_vtable_size_and_num_mirandas(&amp;_vtable_size,
6650                                                     &amp;_num_miranda_methods,
6651                                                     _all_mirandas,
6652                                                     _super_klass,
6653                                                     _methods,
6654                                                     _access_flags,
6655                                                     _major_version,
6656                                                     loader,
6657                                                     _class_name,
6658                                                     _local_interfaces,
6659                                                     CHECK);
6660 
6661   // Size of Java itable (in words)
<a name="111" id="anc111"></a><span class="line-modified">6662   _itable_size = _access_flags.is_interface() ? 0 :</span>
6663     klassItable::compute_itable_size(_transitive_interfaces);
6664 
6665   assert(_fac != NULL, &quot;invariant&quot;);
6666   assert(_parsed_annotations != NULL, &quot;invariant&quot;);
6667 
<a name="112" id="anc112"></a>












6668   _field_info = new FieldLayoutInfo();
6669   if (UseNewFieldLayout) {
6670     FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,
<a name="113" id="anc113"></a><span class="line-modified">6671                           _parsed_annotations-&gt;is_contended(), _field_info);</span>
<span class="line-modified">6672     lb.build_layout();</span>






6673   } else {
6674     layout_fields(cp, _fac, _parsed_annotations, _field_info, CHECK);
6675   }
6676 
<a name="114" id="anc114"></a><span class="line-modified">6677   // Compute reference typ</span>
6678   _rt = (NULL ==_super_klass) ? REF_NONE : _super_klass-&gt;reference_type();
<a name="115" id="anc115"></a><span class="line-removed">6679 </span>
6680 }
6681 
6682 void ClassFileParser::set_klass(InstanceKlass* klass) {
6683 
6684 #ifdef ASSERT
6685   if (klass != NULL) {
6686     assert(NULL == _klass, &quot;leaking?&quot;);
6687   }
6688 #endif
6689 
6690   _klass = klass;
6691 }
6692 
6693 void ClassFileParser::set_klass_to_deallocate(InstanceKlass* klass) {
6694 
6695 #ifdef ASSERT
6696   if (klass != NULL) {
6697     assert(NULL == _klass_to_deallocate, &quot;leaking?&quot;);
6698   }
6699 #endif
6700 
6701   _klass_to_deallocate = klass;
6702 }
6703 
6704 // Caller responsible for ResourceMark
6705 // clone stream with rewound position
6706 const ClassFileStream* ClassFileParser::clone_stream() const {
6707   assert(_stream != NULL, &quot;invariant&quot;);
6708 
6709   return _stream-&gt;clone();
6710 }
<a name="116" id="anc116"></a>
6711 // ----------------------------------------------------------------------------
6712 // debugging
6713 
6714 #ifdef ASSERT
6715 
6716 // return true if class_name contains no &#39;.&#39; (internal format is &#39;/&#39;)
6717 bool ClassFileParser::is_internal_format(Symbol* class_name) {
6718   if (class_name != NULL) {
6719     ResourceMark rm;
6720     char* name = class_name-&gt;as_C_string();
6721     return strchr(name, JVM_SIGNATURE_DOT) == NULL;
6722   } else {
6723     return true;
6724   }
6725 }
6726 
6727 #endif
<a name="117" id="anc117"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="117" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="javaClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionary.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  41 #include &quot;classfile/resolutionErrors.hpp&quot;
  42 #include &quot;classfile/stringTable.hpp&quot;
  43 #include &quot;classfile/symbolTable.hpp&quot;
  44 #include &quot;classfile/systemDictionary.hpp&quot;
  45 #include &quot;classfile/vmSymbols.hpp&quot;
  46 #include &quot;code/codeCache.hpp&quot;
  47 #include &quot;compiler/compileBroker.hpp&quot;
  48 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  49 #include &quot;interpreter/bytecodeStream.hpp&quot;
  50 #include &quot;interpreter/interpreter.hpp&quot;
  51 #include &quot;jfr/jfrEvents.hpp&quot;
  52 #include &quot;logging/log.hpp&quot;
  53 #include &quot;logging/logStream.hpp&quot;
  54 #include &quot;memory/filemap.hpp&quot;
  55 #include &quot;memory/heapShared.hpp&quot;
  56 #include &quot;memory/metaspaceClosure.hpp&quot;
  57 #include &quot;memory/oopFactory.hpp&quot;
  58 #include &quot;memory/resourceArea.hpp&quot;
  59 #include &quot;memory/universe.hpp&quot;
  60 #include &quot;oops/access.inline.hpp&quot;

  61 #include &quot;oops/instanceKlass.hpp&quot;
  62 #include &quot;oops/instanceRefKlass.hpp&quot;
  63 #include &quot;oops/klass.inline.hpp&quot;
  64 #include &quot;oops/method.inline.hpp&quot;
  65 #include &quot;oops/methodData.hpp&quot;
  66 #include &quot;oops/objArrayKlass.hpp&quot;
  67 #include &quot;oops/objArrayOop.inline.hpp&quot;
  68 #include &quot;oops/oop.inline.hpp&quot;
  69 #include &quot;oops/oopHandle.inline.hpp&quot;
  70 #include &quot;oops/symbol.hpp&quot;
  71 #include &quot;oops/typeArrayKlass.hpp&quot;

  72 #include &quot;prims/jvmtiExport.hpp&quot;
  73 #include &quot;prims/methodHandles.hpp&quot;
  74 #include &quot;runtime/arguments.hpp&quot;
  75 #include &quot;runtime/biasedLocking.hpp&quot;
  76 #include &quot;runtime/handles.inline.hpp&quot;
  77 #include &quot;runtime/java.hpp&quot;
  78 #include &quot;runtime/javaCalls.hpp&quot;
  79 #include &quot;runtime/mutexLocker.hpp&quot;

  80 #include &quot;runtime/sharedRuntime.hpp&quot;
  81 #include &quot;runtime/signature.hpp&quot;
  82 #include &quot;services/classLoadingService.hpp&quot;
  83 #include &quot;services/diagnosticCommand.hpp&quot;
  84 #include &quot;services/threadService.hpp&quot;
  85 #include &quot;utilities/macros.hpp&quot;
  86 #include &quot;utilities/utf8.hpp&quot;
  87 #if INCLUDE_CDS
  88 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  89 #endif
  90 #if INCLUDE_JFR
  91 #include &quot;jfr/jfr.hpp&quot;
  92 #endif
  93 
  94 PlaceholderTable*      SystemDictionary::_placeholders        = NULL;
  95 LoaderConstraintTable* SystemDictionary::_loader_constraints  = NULL;
  96 ResolutionErrorTable*  SystemDictionary::_resolution_errors   = NULL;
  97 SymbolPropertyTable*   SystemDictionary::_invoke_method_table = NULL;
  98 ProtectionDomainCacheTable*   SystemDictionary::_pd_cache_table = NULL;
  99 
</pre>
<hr />
<pre>
 307 
 308 
 309 // Forwards to resolve_array_class_or_null or resolve_instance_class_or_null
 310 
 311 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) {
 312   if (Signature::is_array(class_name)) {
 313     return resolve_array_class_or_null(class_name, class_loader, protection_domain, THREAD);
 314   } else {
 315     return resolve_instance_class_or_null_helper(class_name, class_loader, protection_domain, THREAD);
 316   }
 317 }
 318 
 319 // name may be in the form of &quot;java/lang/Object&quot; or &quot;Ljava/lang/Object;&quot;
 320 InstanceKlass* SystemDictionary::resolve_instance_class_or_null_helper(Symbol* class_name,
 321                                                                        Handle class_loader,
 322                                                                        Handle protection_domain,
 323                                                                        TRAPS) {
 324   assert(class_name != NULL &amp;&amp; !Signature::is_array(class_name), &quot;must be&quot;);
 325   if (Signature::has_envelope(class_name)) {
 326     ResourceMark rm(THREAD);
<span class="line-modified"> 327     // Ignore wrapping L and ;.</span>
 328     TempNewSymbol name = SymbolTable::new_symbol(class_name-&gt;as_C_string() + 1,
 329                                                  class_name-&gt;utf8_length() - 2);
 330     return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD);
 331   } else {
 332     return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD);
 333   }
 334 }
 335 
 336 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, TRAPS) {
 337   return resolve_or_null(class_name, Handle(), Handle(), THREAD);
 338 }
 339 
 340 // Forwards to resolve_instance_class_or_null
 341 
 342 Klass* SystemDictionary::resolve_array_class_or_null(Symbol* class_name,
 343                                                      Handle class_loader,
 344                                                      Handle protection_domain,
 345                                                      TRAPS) {
 346   assert(Signature::is_array(class_name), &quot;must be array&quot;);
 347   ResourceMark rm(THREAD);
 348   SignatureStream ss(class_name, false);
 349   int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
 350   Klass* k = NULL;
 351   BasicType t = ss.type();
 352   if (ss.has_envelope()) {
 353     Symbol* obj_class = ss.as_symbol();
 354     k = SystemDictionary::resolve_instance_class_or_null(obj_class,
 355                                                          class_loader,
 356                                                          protection_domain,
 357                                                          CHECK_NULL);
 358     if (k != NULL) {
 359       k = k-&gt;array_klass(ndims, CHECK_NULL);
 360     }
 361   } else {
 362     k = Universe::typeArrayKlassObj(t);
 363     k = TypeArrayKlass::cast(k)-&gt;array_klass(ndims, CHECK_NULL);
 364   }
 365   return k;
 366 }
 367 
<span class="line-removed"> 368 </span>
 369 // Must be called for any super-class or super-interface resolution
 370 // during class definition to allow class circularity checking
 371 // super-interface callers:
 372 //    parse_interfaces - for defineClass &amp; jvmtiRedefineClasses
 373 // super-class callers:
 374 //   ClassFileParser - for defineClass &amp; jvmtiRedefineClasses
 375 //   load_shared_class - while loading a class from shared archive
 376 //   resolve_instance_class_or_null:
 377 //     via: handle_parallel_super_load
 378 //      when resolving a class that has an existing placeholder with
 379 //      a saved superclass [i.e. a defineClass is currently in progress]
 380 //      if another thread is trying to resolve the class, it must do
 381 //      super-class checks on its own thread to catch class circularity
 382 // This last call is critical in class circularity checking for cases
 383 // where classloading is delegated to different threads and the
 384 // classloader lock is released.
 385 // Take the case: Base-&gt;Super-&gt;Base
 386 //   1. If thread T1 tries to do a defineClass of class Base
 387 //    resolve_super_or_fail creates placeholder: T1, Base (super Super)
 388 //   2. resolve_instance_class_or_null does not find SD or placeholder for Super
</pre>
<hr />
<pre>
 492   // The instanceKlass is kept alive because the class loader is on the stack,
 493   // which keeps the loader_data alive, as well as all instanceKlasses in
 494   // the loader_data. parseClassFile adds the instanceKlass to loader_data.
 495   {
 496     MutexLocker mu(THREAD, SystemDictionary_lock);
 497     placeholders()-&gt;find_and_remove(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);
 498     SystemDictionary_lock-&gt;notify_all();
 499   }
 500   if (HAS_PENDING_EXCEPTION || superk == NULL) {
 501     // can null superk
 502     Klass* k = handle_resolution_exception(super_name, true, superk, THREAD);
 503     assert(k == NULL || k == superk, &quot;must be&quot;);
 504     if (k == NULL) {
 505       superk = NULL;
 506     }
 507   }
 508 
 509   return superk;
 510 }
 511 













































 512 void SystemDictionary::validate_protection_domain(InstanceKlass* klass,
 513                                                   Handle class_loader,
 514                                                   Handle protection_domain,
 515                                                   TRAPS) {
 516   // Now we have to call back to java to check if the initating class has access
 517   JavaValue result(T_VOID);
 518   LogTarget(Debug, protectiondomain) lt;
 519   if (lt.is_enabled()) {
 520     ResourceMark rm(THREAD);
 521     // Print out trace information
 522     LogStream ls(lt);
 523     ls.print_cr(&quot;Checking package access&quot;);
 524     if (class_loader() != NULL) {
 525       ls.print(&quot;class loader: &quot;);
 526       class_loader()-&gt;print_value_on(&amp;ls);
 527     } else {
 528       ls.print_cr(&quot;class loader: NULL&quot;);
 529     }
 530     if (protection_domain() != NULL) {
 531       ls.print(&quot; protection domain: &quot;);
</pre>
<hr />
<pre>
1020                           protection_domain);
1021 }
1022 
1023 
1024 // Look for a loaded instance or array klass by name.  Do not do any loading.
1025 // return NULL in case of error.
1026 Klass* SystemDictionary::find_instance_or_array_klass(Symbol* class_name,
1027                                                       Handle class_loader,
1028                                                       Handle protection_domain,
1029                                                       TRAPS) {
1030   Klass* k = NULL;
1031   assert(class_name != NULL, &quot;class name must be non NULL&quot;);
1032 
1033   if (Signature::is_array(class_name)) {
1034     // The name refers to an array.  Parse the name.
1035     // dimension and object_key in FieldArrayInfo are assigned as a
1036     // side-effect of this call
1037     SignatureStream ss(class_name, false);
1038     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
1039     BasicType t = ss.type();
<span class="line-modified">1040     if (t != T_OBJECT) {</span>
1041       k = Universe::typeArrayKlassObj(t);
1042     } else {
1043       k = SystemDictionary::find(ss.as_symbol(), class_loader, protection_domain, THREAD);
1044     }
1045     if (k != NULL) {
1046       k = k-&gt;array_klass_or_null(ndims);
1047     }
1048   } else {
1049     k = find(class_name, class_loader, protection_domain, THREAD);
1050   }
1051   return k;
1052 }
1053 
1054 // Note: this method is much like resolve_from_stream, but
1055 // does not publish the classes via the SystemDictionary.
1056 // Handles Lookup.defineClass hidden, unsafe_DefineAnonymousClass
1057 // and redefineclasses. RedefinedClasses do not add to the class hierarchy.
1058 InstanceKlass* SystemDictionary::parse_stream(Symbol* class_name,
1059                                               Handle class_loader,
1060                                               ClassFileStream* st,
</pre>
<hr />
<pre>
2315 Klass* SystemDictionary::find_constrained_instance_or_array_klass(
2316                     Symbol* class_name, Handle class_loader, TRAPS) {
2317 
2318   // First see if it has been loaded directly.
2319   // Force the protection domain to be null.  (This removes protection checks.)
2320   Handle no_protection_domain;
2321   Klass* klass = find_instance_or_array_klass(class_name, class_loader,
2322                                               no_protection_domain, CHECK_NULL);
2323   if (klass != NULL)
2324     return klass;
2325 
2326   // Now look to see if it has been loaded elsewhere, and is subject to
2327   // a loader constraint that would require this loader to return the
2328   // klass that is already loaded.
2329   if (Signature::is_array(class_name)) {
2330     // For array classes, their Klass*s are not kept in the
2331     // constraint table. The element Klass*s are.
2332     SignatureStream ss(class_name, false);
2333     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
2334     BasicType t = ss.type();
<span class="line-modified">2335     if (t != T_OBJECT) {</span>
2336       klass = Universe::typeArrayKlassObj(t);
2337     } else {
2338       MutexLocker mu(THREAD, SystemDictionary_lock);
2339       klass = constraints()-&gt;find_constrained_klass(ss.as_symbol(), class_loader);
2340     }
2341     // If element class already loaded, allocate array klass
2342     if (klass != NULL) {
2343       klass = klass-&gt;array_klass_or_null(ndims);
2344     }
2345   } else {
2346     MutexLocker mu(THREAD, SystemDictionary_lock);
2347     // Non-array classes are easy: simply check the constraint table.
2348     klass = constraints()-&gt;find_constrained_klass(class_name, class_loader);
2349   }
2350 
2351   return klass;
2352 }
2353 
2354 bool SystemDictionary::add_loader_constraint(Symbol* class_name,
2355                                              Klass* klass_being_linked,
</pre>
</td>
<td>
<hr />
<pre>
  41 #include &quot;classfile/resolutionErrors.hpp&quot;
  42 #include &quot;classfile/stringTable.hpp&quot;
  43 #include &quot;classfile/symbolTable.hpp&quot;
  44 #include &quot;classfile/systemDictionary.hpp&quot;
  45 #include &quot;classfile/vmSymbols.hpp&quot;
  46 #include &quot;code/codeCache.hpp&quot;
  47 #include &quot;compiler/compileBroker.hpp&quot;
  48 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  49 #include &quot;interpreter/bytecodeStream.hpp&quot;
  50 #include &quot;interpreter/interpreter.hpp&quot;
  51 #include &quot;jfr/jfrEvents.hpp&quot;
  52 #include &quot;logging/log.hpp&quot;
  53 #include &quot;logging/logStream.hpp&quot;
  54 #include &quot;memory/filemap.hpp&quot;
  55 #include &quot;memory/heapShared.hpp&quot;
  56 #include &quot;memory/metaspaceClosure.hpp&quot;
  57 #include &quot;memory/oopFactory.hpp&quot;
  58 #include &quot;memory/resourceArea.hpp&quot;
  59 #include &quot;memory/universe.hpp&quot;
  60 #include &quot;oops/access.inline.hpp&quot;
<span class="line-added">  61 #include &quot;oops/fieldStreams.inline.hpp&quot;</span>
  62 #include &quot;oops/instanceKlass.hpp&quot;
  63 #include &quot;oops/instanceRefKlass.hpp&quot;
  64 #include &quot;oops/klass.inline.hpp&quot;
  65 #include &quot;oops/method.inline.hpp&quot;
  66 #include &quot;oops/methodData.hpp&quot;
  67 #include &quot;oops/objArrayKlass.hpp&quot;
  68 #include &quot;oops/objArrayOop.inline.hpp&quot;
  69 #include &quot;oops/oop.inline.hpp&quot;
  70 #include &quot;oops/oopHandle.inline.hpp&quot;
  71 #include &quot;oops/symbol.hpp&quot;
  72 #include &quot;oops/typeArrayKlass.hpp&quot;
<span class="line-added">  73 #include &quot;oops/valueKlass.hpp&quot;</span>
  74 #include &quot;prims/jvmtiExport.hpp&quot;
  75 #include &quot;prims/methodHandles.hpp&quot;
  76 #include &quot;runtime/arguments.hpp&quot;
  77 #include &quot;runtime/biasedLocking.hpp&quot;
  78 #include &quot;runtime/handles.inline.hpp&quot;
  79 #include &quot;runtime/java.hpp&quot;
  80 #include &quot;runtime/javaCalls.hpp&quot;
  81 #include &quot;runtime/mutexLocker.hpp&quot;
<span class="line-added">  82 #include &quot;runtime/os.hpp&quot;</span>
  83 #include &quot;runtime/sharedRuntime.hpp&quot;
  84 #include &quot;runtime/signature.hpp&quot;
  85 #include &quot;services/classLoadingService.hpp&quot;
  86 #include &quot;services/diagnosticCommand.hpp&quot;
  87 #include &quot;services/threadService.hpp&quot;
  88 #include &quot;utilities/macros.hpp&quot;
  89 #include &quot;utilities/utf8.hpp&quot;
  90 #if INCLUDE_CDS
  91 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  92 #endif
  93 #if INCLUDE_JFR
  94 #include &quot;jfr/jfr.hpp&quot;
  95 #endif
  96 
  97 PlaceholderTable*      SystemDictionary::_placeholders        = NULL;
  98 LoaderConstraintTable* SystemDictionary::_loader_constraints  = NULL;
  99 ResolutionErrorTable*  SystemDictionary::_resolution_errors   = NULL;
 100 SymbolPropertyTable*   SystemDictionary::_invoke_method_table = NULL;
 101 ProtectionDomainCacheTable*   SystemDictionary::_pd_cache_table = NULL;
 102 
</pre>
<hr />
<pre>
 310 
 311 
 312 // Forwards to resolve_array_class_or_null or resolve_instance_class_or_null
 313 
 314 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS) {
 315   if (Signature::is_array(class_name)) {
 316     return resolve_array_class_or_null(class_name, class_loader, protection_domain, THREAD);
 317   } else {
 318     return resolve_instance_class_or_null_helper(class_name, class_loader, protection_domain, THREAD);
 319   }
 320 }
 321 
 322 // name may be in the form of &quot;java/lang/Object&quot; or &quot;Ljava/lang/Object;&quot;
 323 InstanceKlass* SystemDictionary::resolve_instance_class_or_null_helper(Symbol* class_name,
 324                                                                        Handle class_loader,
 325                                                                        Handle protection_domain,
 326                                                                        TRAPS) {
 327   assert(class_name != NULL &amp;&amp; !Signature::is_array(class_name), &quot;must be&quot;);
 328   if (Signature::has_envelope(class_name)) {
 329     ResourceMark rm(THREAD);
<span class="line-modified"> 330     // Ignore wrapping L and ;. (and Q and ; for value types);</span>
 331     TempNewSymbol name = SymbolTable::new_symbol(class_name-&gt;as_C_string() + 1,
 332                                                  class_name-&gt;utf8_length() - 2);
 333     return resolve_instance_class_or_null(name, class_loader, protection_domain, THREAD);
 334   } else {
 335     return resolve_instance_class_or_null(class_name, class_loader, protection_domain, THREAD);
 336   }
 337 }
 338 
 339 Klass* SystemDictionary::resolve_or_null(Symbol* class_name, TRAPS) {
 340   return resolve_or_null(class_name, Handle(), Handle(), THREAD);
 341 }
 342 
 343 // Forwards to resolve_instance_class_or_null
 344 
 345 Klass* SystemDictionary::resolve_array_class_or_null(Symbol* class_name,
 346                                                      Handle class_loader,
 347                                                      Handle protection_domain,
 348                                                      TRAPS) {
 349   assert(Signature::is_array(class_name), &quot;must be array&quot;);
 350   ResourceMark rm(THREAD);
 351   SignatureStream ss(class_name, false);
 352   int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
 353   Klass* k = NULL;
 354   BasicType t = ss.type();
 355   if (ss.has_envelope()) {
 356     Symbol* obj_class = ss.as_symbol();
 357     k = SystemDictionary::resolve_instance_class_or_null(obj_class,
 358                                                          class_loader,
 359                                                          protection_domain,
 360                                                          CHECK_NULL);
 361     if (k != NULL) {
 362       k = k-&gt;array_klass(ndims, CHECK_NULL);
 363     }
 364   } else {
 365     k = Universe::typeArrayKlassObj(t);
 366     k = TypeArrayKlass::cast(k)-&gt;array_klass(ndims, CHECK_NULL);
 367   }
 368   return k;
 369 }
 370 

 371 // Must be called for any super-class or super-interface resolution
 372 // during class definition to allow class circularity checking
 373 // super-interface callers:
 374 //    parse_interfaces - for defineClass &amp; jvmtiRedefineClasses
 375 // super-class callers:
 376 //   ClassFileParser - for defineClass &amp; jvmtiRedefineClasses
 377 //   load_shared_class - while loading a class from shared archive
 378 //   resolve_instance_class_or_null:
 379 //     via: handle_parallel_super_load
 380 //      when resolving a class that has an existing placeholder with
 381 //      a saved superclass [i.e. a defineClass is currently in progress]
 382 //      if another thread is trying to resolve the class, it must do
 383 //      super-class checks on its own thread to catch class circularity
 384 // This last call is critical in class circularity checking for cases
 385 // where classloading is delegated to different threads and the
 386 // classloader lock is released.
 387 // Take the case: Base-&gt;Super-&gt;Base
 388 //   1. If thread T1 tries to do a defineClass of class Base
 389 //    resolve_super_or_fail creates placeholder: T1, Base (super Super)
 390 //   2. resolve_instance_class_or_null does not find SD or placeholder for Super
</pre>
<hr />
<pre>
 494   // The instanceKlass is kept alive because the class loader is on the stack,
 495   // which keeps the loader_data alive, as well as all instanceKlasses in
 496   // the loader_data. parseClassFile adds the instanceKlass to loader_data.
 497   {
 498     MutexLocker mu(THREAD, SystemDictionary_lock);
 499     placeholders()-&gt;find_and_remove(p_index, p_hash, child_name, loader_data, PlaceholderTable::LOAD_SUPER, THREAD);
 500     SystemDictionary_lock-&gt;notify_all();
 501   }
 502   if (HAS_PENDING_EXCEPTION || superk == NULL) {
 503     // can null superk
 504     Klass* k = handle_resolution_exception(super_name, true, superk, THREAD);
 505     assert(k == NULL || k == superk, &quot;must be&quot;);
 506     if (k == NULL) {
 507       superk = NULL;
 508     }
 509   }
 510 
 511   return superk;
 512 }
 513 
<span class="line-added"> 514 Klass* SystemDictionary::resolve_flattenable_field_or_fail(AllFieldStream* fs,</span>
<span class="line-added"> 515                                                            Handle class_loader,</span>
<span class="line-added"> 516                                                            Handle protection_domain,</span>
<span class="line-added"> 517                                                            bool throw_error,</span>
<span class="line-added"> 518                                                            TRAPS) {</span>
<span class="line-added"> 519   Symbol* class_name = fs-&gt;signature()-&gt;fundamental_name(THREAD);</span>
<span class="line-added"> 520   class_loader = Handle(THREAD, java_lang_ClassLoader::non_reflection_class_loader(class_loader()));</span>
<span class="line-added"> 521   ClassLoaderData* loader_data = class_loader_data(class_loader);</span>
<span class="line-added"> 522   unsigned int p_hash = placeholders()-&gt;compute_hash(class_name);</span>
<span class="line-added"> 523   int p_index = placeholders()-&gt;hash_to_index(p_hash);</span>
<span class="line-added"> 524   bool throw_circularity_error = false;</span>
<span class="line-added"> 525   PlaceholderEntry* oldprobe;</span>
<span class="line-added"> 526 </span>
<span class="line-added"> 527   {</span>
<span class="line-added"> 528     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
<span class="line-added"> 529     oldprobe = placeholders()-&gt;get_entry(p_index, p_hash, class_name, loader_data);</span>
<span class="line-added"> 530     if (oldprobe != NULL &amp;&amp;</span>
<span class="line-added"> 531       oldprobe-&gt;check_seen_thread(THREAD, PlaceholderTable::FLATTENABLE_FIELD)) {</span>
<span class="line-added"> 532       throw_circularity_error = true;</span>
<span class="line-added"> 533 </span>
<span class="line-added"> 534     } else {</span>
<span class="line-added"> 535       placeholders()-&gt;find_and_add(p_index, p_hash, class_name, loader_data,</span>
<span class="line-added"> 536                                    PlaceholderTable::FLATTENABLE_FIELD, NULL, THREAD);</span>
<span class="line-added"> 537     }</span>
<span class="line-added"> 538   }</span>
<span class="line-added"> 539 </span>
<span class="line-added"> 540   Klass* klass = NULL;</span>
<span class="line-added"> 541   if (!throw_circularity_error) {</span>
<span class="line-added"> 542     klass = SystemDictionary::resolve_or_fail(class_name, class_loader,</span>
<span class="line-added"> 543                                                protection_domain, true, THREAD);</span>
<span class="line-added"> 544   } else {</span>
<span class="line-added"> 545     ResourceMark rm(THREAD);</span>
<span class="line-added"> 546     THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), class_name-&gt;as_C_string());</span>
<span class="line-added"> 547   }</span>
<span class="line-added"> 548 </span>
<span class="line-added"> 549   {</span>
<span class="line-added"> 550     MutexLocker mu(THREAD, SystemDictionary_lock);</span>
<span class="line-added"> 551     placeholders()-&gt;find_and_remove(p_index, p_hash, class_name, loader_data,</span>
<span class="line-added"> 552                                     PlaceholderTable::FLATTENABLE_FIELD, THREAD);</span>
<span class="line-added"> 553   }</span>
<span class="line-added"> 554 </span>
<span class="line-added"> 555   class_name-&gt;decrement_refcount();</span>
<span class="line-added"> 556   return klass;</span>
<span class="line-added"> 557 }</span>
<span class="line-added"> 558 </span>
 559 void SystemDictionary::validate_protection_domain(InstanceKlass* klass,
 560                                                   Handle class_loader,
 561                                                   Handle protection_domain,
 562                                                   TRAPS) {
 563   // Now we have to call back to java to check if the initating class has access
 564   JavaValue result(T_VOID);
 565   LogTarget(Debug, protectiondomain) lt;
 566   if (lt.is_enabled()) {
 567     ResourceMark rm(THREAD);
 568     // Print out trace information
 569     LogStream ls(lt);
 570     ls.print_cr(&quot;Checking package access&quot;);
 571     if (class_loader() != NULL) {
 572       ls.print(&quot;class loader: &quot;);
 573       class_loader()-&gt;print_value_on(&amp;ls);
 574     } else {
 575       ls.print_cr(&quot;class loader: NULL&quot;);
 576     }
 577     if (protection_domain() != NULL) {
 578       ls.print(&quot; protection domain: &quot;);
</pre>
<hr />
<pre>
1067                           protection_domain);
1068 }
1069 
1070 
1071 // Look for a loaded instance or array klass by name.  Do not do any loading.
1072 // return NULL in case of error.
1073 Klass* SystemDictionary::find_instance_or_array_klass(Symbol* class_name,
1074                                                       Handle class_loader,
1075                                                       Handle protection_domain,
1076                                                       TRAPS) {
1077   Klass* k = NULL;
1078   assert(class_name != NULL, &quot;class name must be non NULL&quot;);
1079 
1080   if (Signature::is_array(class_name)) {
1081     // The name refers to an array.  Parse the name.
1082     // dimension and object_key in FieldArrayInfo are assigned as a
1083     // side-effect of this call
1084     SignatureStream ss(class_name, false);
1085     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
1086     BasicType t = ss.type();
<span class="line-modified">1087     if (t != T_OBJECT &amp;&amp; t != T_VALUETYPE) {</span>
1088       k = Universe::typeArrayKlassObj(t);
1089     } else {
1090       k = SystemDictionary::find(ss.as_symbol(), class_loader, protection_domain, THREAD);
1091     }
1092     if (k != NULL) {
1093       k = k-&gt;array_klass_or_null(ndims);
1094     }
1095   } else {
1096     k = find(class_name, class_loader, protection_domain, THREAD);
1097   }
1098   return k;
1099 }
1100 
1101 // Note: this method is much like resolve_from_stream, but
1102 // does not publish the classes via the SystemDictionary.
1103 // Handles Lookup.defineClass hidden, unsafe_DefineAnonymousClass
1104 // and redefineclasses. RedefinedClasses do not add to the class hierarchy.
1105 InstanceKlass* SystemDictionary::parse_stream(Symbol* class_name,
1106                                               Handle class_loader,
1107                                               ClassFileStream* st,
</pre>
<hr />
<pre>
2362 Klass* SystemDictionary::find_constrained_instance_or_array_klass(
2363                     Symbol* class_name, Handle class_loader, TRAPS) {
2364 
2365   // First see if it has been loaded directly.
2366   // Force the protection domain to be null.  (This removes protection checks.)
2367   Handle no_protection_domain;
2368   Klass* klass = find_instance_or_array_klass(class_name, class_loader,
2369                                               no_protection_domain, CHECK_NULL);
2370   if (klass != NULL)
2371     return klass;
2372 
2373   // Now look to see if it has been loaded elsewhere, and is subject to
2374   // a loader constraint that would require this loader to return the
2375   // klass that is already loaded.
2376   if (Signature::is_array(class_name)) {
2377     // For array classes, their Klass*s are not kept in the
2378     // constraint table. The element Klass*s are.
2379     SignatureStream ss(class_name, false);
2380     int ndims = ss.skip_array_prefix();  // skip all &#39;[&#39;s
2381     BasicType t = ss.type();
<span class="line-modified">2382     if (t != T_OBJECT &amp;&amp; t != T_VALUETYPE) {</span>
2383       klass = Universe::typeArrayKlassObj(t);
2384     } else {
2385       MutexLocker mu(THREAD, SystemDictionary_lock);
2386       klass = constraints()-&gt;find_constrained_klass(ss.as_symbol(), class_loader);
2387     }
2388     // If element class already loaded, allocate array klass
2389     if (klass != NULL) {
2390       klass = klass-&gt;array_klass_or_null(ndims);
2391     }
2392   } else {
2393     MutexLocker mu(THREAD, SystemDictionary_lock);
2394     // Non-array classes are easy: simply check the constraint table.
2395     klass = constraints()-&gt;find_constrained_klass(class_name, class_loader);
2396   }
2397 
2398   return klass;
2399 }
2400 
2401 bool SystemDictionary::add_loader_constraint(Symbol* class_name,
2402                                              Klass* klass_being_linked,
</pre>
</td>
</tr>
</table>
<center><a href="javaClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/nmethod.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../classfile/systemDictionary.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../compiler/compileBroker.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/nmethod.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 616     _consts_offset           = data_offset();
 617     _stub_offset             = data_offset();
 618     _oops_offset             = data_offset();
 619     _metadata_offset         = _oops_offset         + align_up(code_buffer-&gt;total_oop_size(), oopSize);
 620     scopes_data_offset       = _metadata_offset     + align_up(code_buffer-&gt;total_metadata_size(), wordSize);
 621     _scopes_pcs_offset       = scopes_data_offset;
 622     _dependencies_offset     = _scopes_pcs_offset;
 623     _handler_table_offset    = _dependencies_offset;
 624     _nul_chk_table_offset    = _handler_table_offset;
 625 #if INCLUDE_JVMCI
 626     _speculations_offset     = _nul_chk_table_offset;
 627     _jvmci_data_offset       = _speculations_offset;
 628     _nmethod_end_offset      = _jvmci_data_offset;
 629 #else
 630     _nmethod_end_offset      = _nul_chk_table_offset;
 631 #endif
 632     _compile_id              = compile_id;
 633     _comp_level              = CompLevel_none;
 634     _entry_point             = code_begin()          + offsets-&gt;value(CodeOffsets::Entry);
 635     _verified_entry_point    = code_begin()          + offsets-&gt;value(CodeOffsets::Verified_Entry);






 636     _osr_entry_point         = NULL;
 637     _exception_cache         = NULL;
 638     _pc_desc_container.reset_to(NULL);
 639     _hotness_counter         = NMethodSweeper::hotness_counter_reset_val();
 640 
 641     _scopes_data_begin = (address) this + scopes_data_offset;
 642     _deopt_handler_begin = (address) this + deoptimize_offset;
 643     _deopt_mh_handler_begin = (address) this + deoptimize_mh_offset;
 644 
 645     code_buffer-&gt;copy_code_and_locs_to(this);
 646     code_buffer-&gt;copy_values_to(this);
 647 
 648     clear_unloading_state();
 649 
 650     Universe::heap()-&gt;register_nmethod(this);
 651     debug_only(Universe::heap()-&gt;verify_nmethod(this));
 652 
 653     CodeCache::commit(this);
 654   }
 655 
</pre>
<hr />
<pre>
 787       _unwind_handler_offset = -1;
 788     }
 789 
 790     _oops_offset             = data_offset();
 791     _metadata_offset         = _oops_offset          + align_up(code_buffer-&gt;total_oop_size(), oopSize);
 792     int scopes_data_offset   = _metadata_offset      + align_up(code_buffer-&gt;total_metadata_size(), wordSize);
 793 
 794     _scopes_pcs_offset       = scopes_data_offset    + align_up(debug_info-&gt;data_size       (), oopSize);
 795     _dependencies_offset     = _scopes_pcs_offset    + adjust_pcs_size(debug_info-&gt;pcs_size());
 796     _handler_table_offset    = _dependencies_offset  + align_up((int)dependencies-&gt;size_in_bytes (), oopSize);
 797     _nul_chk_table_offset    = _handler_table_offset + align_up(handler_table-&gt;size_in_bytes(), oopSize);
 798 #if INCLUDE_JVMCI
 799     _speculations_offset     = _nul_chk_table_offset + align_up(nul_chk_table-&gt;size_in_bytes(), oopSize);
 800     _jvmci_data_offset       = _speculations_offset  + align_up(speculations_len, oopSize);
 801     _nmethod_end_offset      = _jvmci_data_offset    + align_up(jvmci_data_size, oopSize);
 802 #else
 803     _nmethod_end_offset      = _nul_chk_table_offset + align_up(nul_chk_table-&gt;size_in_bytes(), oopSize);
 804 #endif
 805     _entry_point             = code_begin()          + offsets-&gt;value(CodeOffsets::Entry);
 806     _verified_entry_point    = code_begin()          + offsets-&gt;value(CodeOffsets::Verified_Entry);



 807     _osr_entry_point         = code_begin()          + offsets-&gt;value(CodeOffsets::OSR_Entry);
 808     _exception_cache         = NULL;
 809     _scopes_data_begin       = (address) this + scopes_data_offset;
 810 
 811     _pc_desc_container.reset_to(scopes_pcs_begin());
 812 
 813     code_buffer-&gt;copy_code_and_locs_to(this);
 814     // Copy contents of ScopeDescRecorder to nmethod
 815     code_buffer-&gt;copy_values_to(this);
 816     debug_info-&gt;copy_to(this);
 817     dependencies-&gt;copy_to(this);
 818     clear_unloading_state();
 819 
 820     Universe::heap()-&gt;register_nmethod(this);
 821     debug_only(Universe::heap()-&gt;verify_nmethod(this));
 822 
 823     CodeCache::commit(this);
 824 
 825     // Copy contents of ExceptionHandlerTable to nmethod
 826     handler_table-&gt;copy_to(this);
</pre>
<hr />
<pre>
 903 // Print out more verbose output usually for a newly created nmethod.
 904 void nmethod::print_on(outputStream* st, const char* msg) const {
 905   if (st != NULL) {
 906     ttyLocker ttyl;
 907     if (WizardMode) {
 908       CompileTask::print(st, this, msg, /*short_form:*/ true);
 909       st-&gt;print_cr(&quot; (&quot; INTPTR_FORMAT &quot;)&quot;, p2i(this));
 910     } else {
 911       CompileTask::print(st, this, msg, /*short_form:*/ false);
 912     }
 913   }
 914 }
 915 
 916 void nmethod::maybe_print_nmethod(DirectiveSet* directive) {
 917   bool printnmethods = directive-&gt;PrintAssemblyOption || directive-&gt;PrintNMethodsOption;
 918   if (printnmethods || PrintDebugInfo || PrintRelocations || PrintDependencies || PrintExceptionHandlers) {
 919     print_nmethod(printnmethods);
 920   }
 921 }
 922 



 923 void nmethod::print_nmethod(bool printmethod) {






 924   ttyLocker ttyl;  // keep the following output all in one block



 925   if (xtty != NULL) {
 926     xtty-&gt;begin_head(&quot;print_nmethod&quot;);
 927     log_identity(xtty);
 928     xtty-&gt;stamp();
 929     xtty-&gt;end_head();
 930   }
 931   // Print the header part, then print the requested information.
 932   // This is both handled in decode2().
 933   if (printmethod) {
 934     HandleMark hm;
 935     ResourceMark m;
 936     if (is_compiled_by_c1()) {
 937       tty-&gt;cr();
 938       tty-&gt;print_cr(&quot;============================= C1-compiled nmethod ==============================&quot;);
 939     }
 940     if (is_compiled_by_jvmci()) {
 941       tty-&gt;cr();
 942       tty-&gt;print_cr(&quot;=========================== JVMCI-compiled nmethod =============================&quot;);
 943     }
 944     tty-&gt;print_cr(&quot;----------------------------------- Assembly -----------------------------------&quot;);
</pre>
<hr />
<pre>
 981     }
 982     if (printmethod || PrintExceptionHandlers) {
 983       print_handler_table();
 984       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
 985       print_nul_chk_table();
 986       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
 987     }
 988 
 989     if (printmethod) {
 990       print_recorded_oops();
 991       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
 992       print_recorded_metadata();
 993       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
 994     }
 995   }
 996 #endif
 997 
 998   if (xtty != NULL) {
 999     xtty-&gt;tail(&quot;print_nmethod&quot;);
1000   }



1001 }
1002 
1003 
1004 // Promote one word from an assembly-time handle to a live embedded oop.
1005 inline void nmethod::initialize_immediate_oop(oop* dest, jobject handle) {
1006   if (handle == NULL ||
1007       // As a special case, IC oops are initialized to 1 or -1.
1008       handle == (jobject) Universe::non_oop_word()) {
1009     (*dest) = (oop) handle;
1010   } else {
1011     (*dest) = JNIHandles::resolve_non_null(handle);
1012   }
1013 }
1014 
1015 
1016 // Have to have the same name because it&#39;s called by a template
1017 void nmethod::copy_values(GrowableArray&lt;jobject&gt;* array) {
1018   int length = array-&gt;length();
1019   assert((address)(oops_begin() + length) &lt;= (address)oops_end(), &quot;oops big enough&quot;);
1020   oop* dest = oops_begin();
</pre>
<hr />
<pre>
2402   VerifyMetadataClosure vmc;
2403   metadata_do(&amp;vmc);
2404 }
2405 
2406 
2407 void nmethod::verify_interrupt_point(address call_site) {
2408   // Verify IC only when nmethod installation is finished.
2409   if (!is_not_installed()) {
2410     if (CompiledICLocker::is_safe(this)) {
2411       CompiledIC_at(this, call_site);
2412     } else {
2413       CompiledICLocker ml_verify(this);
2414       CompiledIC_at(this, call_site);
2415     }
2416   }
2417 
2418   PcDesc* pd = pc_desc_at(nativeCall_at(call_site)-&gt;return_address());
2419   assert(pd != NULL, &quot;PcDesc must exist&quot;);
2420   for (ScopeDesc* sd = new ScopeDesc(this, pd-&gt;scope_decode_offset(),
2421                                      pd-&gt;obj_decode_offset(), pd-&gt;should_reexecute(), pd-&gt;rethrow_exception(),
<span class="line-modified">2422                                      pd-&gt;return_oop());</span>
2423        !sd-&gt;is_top(); sd = sd-&gt;sender()) {
2424     sd-&gt;verify();
2425   }
2426 }
2427 
2428 void nmethod::verify_scopes() {
2429   if( !method() ) return;       // Runtime stubs have no scope
2430   if (method()-&gt;is_native()) return; // Ignore stub methods.
2431   // iterate through all interrupt point
2432   // and verify the debug information is valid.
2433   RelocIterator iter((nmethod*)this);
2434   while (iter.next()) {
2435     address stub = NULL;
2436     switch (iter.type()) {
2437       case relocInfo::virtual_call_type:
2438         verify_interrupt_point(iter.addr());
2439         break;
2440       case relocInfo::opt_virtual_call_type:
2441         stub = iter.opt_virtual_call_reloc()-&gt;static_stub(false);
2442         verify_interrupt_point(iter.addr());
</pre>
<hr />
<pre>
3042         case relocInfo::internal_word_type:    return &quot;internal_word&quot;;
3043         case relocInfo::section_word_type:     return &quot;section_word&quot;;
3044         case relocInfo::poll_type:             return &quot;poll&quot;;
3045         case relocInfo::poll_return_type:      return &quot;poll_return&quot;;
3046         case relocInfo::trampoline_stub_type:  return &quot;trampoline_stub&quot;;
3047         case relocInfo::type_mask:             return &quot;type_bit_mask&quot;;
3048 
3049         default:
3050           break;
3051     }
3052   }
3053   return have_one ? &quot;other&quot; : NULL;
3054 }
3055 
3056 // Return a the last scope in (begin..end]
3057 ScopeDesc* nmethod::scope_desc_in(address begin, address end) {
3058   PcDesc* p = pc_desc_near(begin+1);
3059   if (p != NULL &amp;&amp; p-&gt;real_pc(this) &lt;= end) {
3060     return new ScopeDesc(this, p-&gt;scope_decode_offset(),
3061                          p-&gt;obj_decode_offset(), p-&gt;should_reexecute(), p-&gt;rethrow_exception(),
<span class="line-modified">3062                          p-&gt;return_oop());</span>
3063   }
3064   return NULL;
3065 }
3066 
3067 const char* nmethod::nmethod_section_label(address pos) const {
3068   const char* label = NULL;
3069   if (pos == code_begin())                                              label = &quot;[Instructions begin]&quot;;
3070   if (pos == entry_point())                                             label = &quot;[Entry Point]&quot;;

3071   if (pos == verified_entry_point())                                    label = &quot;[Verified Entry Point]&quot;;


3072   if (has_method_handle_invokes() &amp;&amp; (pos == deopt_mh_handler_begin())) label = &quot;[Deopt MH Handler Code]&quot;;
3073   if (pos == consts_begin() &amp;&amp; pos != insts_begin())                    label = &quot;[Constants]&quot;;
3074   // Check stub_code before checking exception_handler or deopt_handler.
3075   if (pos == this-&gt;stub_begin())                                        label = &quot;[Stub Code]&quot;;
3076   if (JVMCI_ONLY(_exception_offset &gt;= 0 &amp;&amp;) pos == exception_begin())           label = &quot;[Exception Handler]&quot;;
3077   if (JVMCI_ONLY(_deopt_handler_begin != NULL &amp;&amp;) pos == deopt_handler_begin()) label = &quot;[Deopt Handler Code]&quot;;
3078   return label;
3079 }
3080 










3081 void nmethod::print_nmethod_labels(outputStream* stream, address block_begin, bool print_section_labels) const {
3082   if (print_section_labels) {
<span class="line-modified">3083     const char* label = nmethod_section_label(block_begin);</span>
<span class="line-modified">3084     if (label != NULL) {</span>
<span class="line-modified">3085       stream-&gt;bol();</span>
<span class="line-modified">3086       stream-&gt;print_cr(&quot;%s&quot;, label);</span>









3087     }
3088   }
3089 
<span class="line-modified">3090   if (block_begin == entry_point()) {</span>
<span class="line-modified">3091     Method* m = method();</span>
<span class="line-modified">3092     if (m != NULL) {</span>
<span class="line-modified">3093       stream-&gt;print(&quot;  # &quot;);</span>
<span class="line-modified">3094       m-&gt;print_value_on(stream);</span>
<span class="line-modified">3095       stream-&gt;cr();</span>




























3096     }
<span class="line-modified">3097     if (m != NULL &amp;&amp; !is_osr_method()) {</span>
<span class="line-modified">3098       ResourceMark rm;</span>
<span class="line-modified">3099       int sizeargs = m-&gt;size_of_parameters();</span>
<span class="line-modified">3100       BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, sizeargs);</span>
<span class="line-modified">3101       VMRegPair* regs   = NEW_RESOURCE_ARRAY(VMRegPair, sizeargs);</span>
<span class="line-modified">3102       {</span>
<span class="line-modified">3103         int sig_index = 0;</span>
<span class="line-modified">3104         if (!m-&gt;is_static())</span>
<span class="line-modified">3105           sig_bt[sig_index++] = T_OBJECT; // &#39;this&#39;</span>
<span class="line-modified">3106         for (SignatureStream ss(m-&gt;signature()); !ss.at_return_type(); ss.next()) {</span>
<span class="line-modified">3107           BasicType t = ss.type();</span>
<span class="line-modified">3108           sig_bt[sig_index++] = t;</span>
<span class="line-modified">3109           if (type2size[t] == 2) {</span>
<span class="line-modified">3110             sig_bt[sig_index++] = T_VOID;</span>
<span class="line-modified">3111           } else {</span>
<span class="line-modified">3112             assert(type2size[t] == 1, &quot;size is 1 or 2&quot;);</span>
<span class="line-modified">3113           }</span>



























3114         }
<span class="line-modified">3115         assert(sig_index == sizeargs, &quot;&quot;);</span>





3116       }
<span class="line-modified">3117       const char* spname = &quot;sp&quot;; // make arch-specific?</span>
<span class="line-modified">3118       intptr_t out_preserve = SharedRuntime::java_calling_convention(sig_bt, regs, sizeargs, false);</span>
<span class="line-modified">3119       int stack_slot_offset = this-&gt;frame_size() * wordSize;</span>
<span class="line-modified">3120       int tab1 = 14, tab2 = 24;</span>
<span class="line-modified">3121       int sig_index = 0;</span>
<span class="line-modified">3122       int arg_index = (m-&gt;is_static() ? 0 : -1);</span>
<span class="line-modified">3123       bool did_old_sp = false;</span>
<span class="line-modified">3124       for (SignatureStream ss(m-&gt;signature()); !ss.at_return_type(); ) {</span>
<span class="line-modified">3125         bool at_this = (arg_index == -1);</span>
<span class="line-modified">3126         bool at_old_sp = false;</span>
<span class="line-modified">3127         BasicType t = (at_this ? T_OBJECT : ss.type());</span>
<span class="line-removed">3128         assert(t == sig_bt[sig_index], &quot;sigs in sync&quot;);</span>
<span class="line-removed">3129         if (at_this)</span>
<span class="line-removed">3130           stream-&gt;print(&quot;  # this: &quot;);</span>
<span class="line-removed">3131         else</span>
<span class="line-removed">3132           stream-&gt;print(&quot;  # parm%d: &quot;, arg_index);</span>
<span class="line-removed">3133         stream-&gt;move_to(tab1);</span>
<span class="line-removed">3134         VMReg fst = regs[sig_index].first();</span>
<span class="line-removed">3135         VMReg snd = regs[sig_index].second();</span>
<span class="line-removed">3136         if (fst-&gt;is_reg()) {</span>
<span class="line-removed">3137           stream-&gt;print(&quot;%s&quot;, fst-&gt;name());</span>
<span class="line-removed">3138           if (snd-&gt;is_valid())  {</span>
<span class="line-removed">3139             stream-&gt;print(&quot;:%s&quot;, snd-&gt;name());</span>
<span class="line-removed">3140           }</span>
<span class="line-removed">3141         } else if (fst-&gt;is_stack()) {</span>
<span class="line-removed">3142           int offset = fst-&gt;reg2stack() * VMRegImpl::stack_slot_size + stack_slot_offset;</span>
<span class="line-removed">3143           if (offset == stack_slot_offset)  at_old_sp = true;</span>
<span class="line-removed">3144           stream-&gt;print(&quot;[%s+0x%x]&quot;, spname, offset);</span>
<span class="line-removed">3145         } else {</span>
<span class="line-removed">3146           stream-&gt;print(&quot;reg%d:%d??&quot;, (int)(intptr_t)fst, (int)(intptr_t)snd);</span>
3147         }
<span class="line-modified">3148         stream-&gt;print(&quot; &quot;);</span>
<span class="line-modified">3149         stream-&gt;move_to(tab2);</span>
<span class="line-modified">3150         stream-&gt;print(&quot;= &quot;);</span>
<span class="line-modified">3151         if (at_this) {</span>
<span class="line-modified">3152           m-&gt;method_holder()-&gt;print_value_on(stream);</span>
<span class="line-modified">3153         } else {</span>
<span class="line-removed">3154           bool did_name = false;</span>
<span class="line-removed">3155           if (!at_this &amp;&amp; ss.is_reference()) {</span>
<span class="line-removed">3156             Symbol* name = ss.as_symbol();</span>
<span class="line-removed">3157             name-&gt;print_value_on(stream);</span>
<span class="line-removed">3158             did_name = true;</span>
<span class="line-removed">3159           }</span>
<span class="line-removed">3160           if (!did_name)</span>
<span class="line-removed">3161             stream-&gt;print(&quot;%s&quot;, type2name(t));</span>
3162         }
<span class="line-modified">3163         if (at_old_sp) {</span>
<span class="line-modified">3164           stream-&gt;print(&quot;  (%s of caller)&quot;, spname);</span>
<span class="line-removed">3165           did_old_sp = true;</span>
3166         }
<span class="line-modified">3167         stream-&gt;cr();</span>
<span class="line-removed">3168         sig_index += type2size[t];</span>
<span class="line-removed">3169         arg_index += 1;</span>
<span class="line-removed">3170         if (!at_this)  ss.next();</span>
3171       }
<span class="line-modified">3172       if (!did_old_sp) {</span>
<span class="line-removed">3173         stream-&gt;print(&quot;  # &quot;);</span>
<span class="line-removed">3174         stream-&gt;move_to(tab1);</span>
<span class="line-removed">3175         stream-&gt;print(&quot;[%s+0x%x]&quot;, spname, stack_slot_offset);</span>
3176         stream-&gt;print(&quot;  (%s of caller)&quot;, spname);
<span class="line-modified">3177         stream-&gt;cr();</span>
3178       }











3179     }
3180   }
3181 }
3182 
3183 // Returns whether this nmethod has code comments.
3184 bool nmethod::has_code_comment(address begin, address end) {
3185   // scopes?
3186   ScopeDesc* sd  = scope_desc_in(begin, end);
3187   if (sd != NULL) return true;
3188 
3189   // relocations?
3190   const char* str = reloc_string_for(begin, end);
3191   if (str != NULL) return true;
3192 
3193   // implicit exceptions?
3194   int cont_offset = ImplicitExceptionTable(this).continuation_offset(begin - code_begin());
3195   if (cont_offset != 0) return true;
3196 
3197   return false;
3198 }
</pre>
<hr />
<pre>
3283             else
3284               st-&gt;print(&quot;&lt;UNKNOWN&gt;&quot;);
3285             break;
3286           }
3287         case Bytecodes::_getfield:
3288         case Bytecodes::_putfield:
3289         case Bytecodes::_getstatic:
3290         case Bytecodes::_putstatic:
3291           {
3292             Bytecode_field field(methodHandle(thread, sd-&gt;method()), sd-&gt;bci());
3293             st-&gt;print(&quot; &quot;);
3294             if (field.name() != NULL)
3295               field.name()-&gt;print_symbol_on(st);
3296             else
3297               st-&gt;print(&quot;&lt;UNKNOWN&gt;&quot;);
3298           }
3299         default:
3300           break;
3301         }
3302       }
<span class="line-modified">3303       st-&gt;print(&quot; {reexecute=%d rethrow=%d return_oop=%d}&quot;, sd-&gt;should_reexecute(), sd-&gt;rethrow_exception(), sd-&gt;return_oop());</span>
3304     }
3305 
3306     // Print all scopes
3307     for (;sd != NULL; sd = sd-&gt;sender()) {
3308       st-&gt;move_to(column, 6, 0);
3309       st-&gt;print(&quot;; -&quot;);
3310       if (sd-&gt;should_reexecute()) {
3311         st-&gt;print(&quot; (reexecute)&quot;);
3312       }
3313       if (sd-&gt;method() == NULL) {
3314         st-&gt;print(&quot;method is NULL&quot;);
3315       } else {
3316         sd-&gt;method()-&gt;print_short_name(st);
3317       }
3318       int lineno = sd-&gt;method()-&gt;line_number_from_bci(sd-&gt;bci());
3319       if (lineno != -1) {
3320         st-&gt;print(&quot;@%d (line %d)&quot;, sd-&gt;bci(), lineno);
3321       } else {
3322         st-&gt;print(&quot;@%d&quot;, sd-&gt;bci());
3323       }
</pre>
</td>
<td>
<hr />
<pre>
 616     _consts_offset           = data_offset();
 617     _stub_offset             = data_offset();
 618     _oops_offset             = data_offset();
 619     _metadata_offset         = _oops_offset         + align_up(code_buffer-&gt;total_oop_size(), oopSize);
 620     scopes_data_offset       = _metadata_offset     + align_up(code_buffer-&gt;total_metadata_size(), wordSize);
 621     _scopes_pcs_offset       = scopes_data_offset;
 622     _dependencies_offset     = _scopes_pcs_offset;
 623     _handler_table_offset    = _dependencies_offset;
 624     _nul_chk_table_offset    = _handler_table_offset;
 625 #if INCLUDE_JVMCI
 626     _speculations_offset     = _nul_chk_table_offset;
 627     _jvmci_data_offset       = _speculations_offset;
 628     _nmethod_end_offset      = _jvmci_data_offset;
 629 #else
 630     _nmethod_end_offset      = _nul_chk_table_offset;
 631 #endif
 632     _compile_id              = compile_id;
 633     _comp_level              = CompLevel_none;
 634     _entry_point             = code_begin()          + offsets-&gt;value(CodeOffsets::Entry);
 635     _verified_entry_point    = code_begin()          + offsets-&gt;value(CodeOffsets::Verified_Entry);
<span class="line-added"> 636 </span>
<span class="line-added"> 637     assert(!method-&gt;has_scalarized_args(), &quot;scalarized native wrappers not supported yet&quot;); // for the next 3 fields</span>
<span class="line-added"> 638     _value_entry_point       = _entry_point;</span>
<span class="line-added"> 639     _verified_value_entry_point = _verified_entry_point;</span>
<span class="line-added"> 640     _verified_value_ro_entry_point = _verified_entry_point;</span>
<span class="line-added"> 641 </span>
 642     _osr_entry_point         = NULL;
 643     _exception_cache         = NULL;
 644     _pc_desc_container.reset_to(NULL);
 645     _hotness_counter         = NMethodSweeper::hotness_counter_reset_val();
 646 
 647     _scopes_data_begin = (address) this + scopes_data_offset;
 648     _deopt_handler_begin = (address) this + deoptimize_offset;
 649     _deopt_mh_handler_begin = (address) this + deoptimize_mh_offset;
 650 
 651     code_buffer-&gt;copy_code_and_locs_to(this);
 652     code_buffer-&gt;copy_values_to(this);
 653 
 654     clear_unloading_state();
 655 
 656     Universe::heap()-&gt;register_nmethod(this);
 657     debug_only(Universe::heap()-&gt;verify_nmethod(this));
 658 
 659     CodeCache::commit(this);
 660   }
 661 
</pre>
<hr />
<pre>
 793       _unwind_handler_offset = -1;
 794     }
 795 
 796     _oops_offset             = data_offset();
 797     _metadata_offset         = _oops_offset          + align_up(code_buffer-&gt;total_oop_size(), oopSize);
 798     int scopes_data_offset   = _metadata_offset      + align_up(code_buffer-&gt;total_metadata_size(), wordSize);
 799 
 800     _scopes_pcs_offset       = scopes_data_offset    + align_up(debug_info-&gt;data_size       (), oopSize);
 801     _dependencies_offset     = _scopes_pcs_offset    + adjust_pcs_size(debug_info-&gt;pcs_size());
 802     _handler_table_offset    = _dependencies_offset  + align_up((int)dependencies-&gt;size_in_bytes (), oopSize);
 803     _nul_chk_table_offset    = _handler_table_offset + align_up(handler_table-&gt;size_in_bytes(), oopSize);
 804 #if INCLUDE_JVMCI
 805     _speculations_offset     = _nul_chk_table_offset + align_up(nul_chk_table-&gt;size_in_bytes(), oopSize);
 806     _jvmci_data_offset       = _speculations_offset  + align_up(speculations_len, oopSize);
 807     _nmethod_end_offset      = _jvmci_data_offset    + align_up(jvmci_data_size, oopSize);
 808 #else
 809     _nmethod_end_offset      = _nul_chk_table_offset + align_up(nul_chk_table-&gt;size_in_bytes(), oopSize);
 810 #endif
 811     _entry_point             = code_begin()          + offsets-&gt;value(CodeOffsets::Entry);
 812     _verified_entry_point    = code_begin()          + offsets-&gt;value(CodeOffsets::Verified_Entry);
<span class="line-added"> 813     _value_entry_point       = code_begin()          + offsets-&gt;value(CodeOffsets::Value_Entry);</span>
<span class="line-added"> 814     _verified_value_entry_point = code_begin()       + offsets-&gt;value(CodeOffsets::Verified_Value_Entry);</span>
<span class="line-added"> 815     _verified_value_ro_entry_point = code_begin()    + offsets-&gt;value(CodeOffsets::Verified_Value_Entry_RO);</span>
 816     _osr_entry_point         = code_begin()          + offsets-&gt;value(CodeOffsets::OSR_Entry);
 817     _exception_cache         = NULL;
 818     _scopes_data_begin       = (address) this + scopes_data_offset;
 819 
 820     _pc_desc_container.reset_to(scopes_pcs_begin());
 821 
 822     code_buffer-&gt;copy_code_and_locs_to(this);
 823     // Copy contents of ScopeDescRecorder to nmethod
 824     code_buffer-&gt;copy_values_to(this);
 825     debug_info-&gt;copy_to(this);
 826     dependencies-&gt;copy_to(this);
 827     clear_unloading_state();
 828 
 829     Universe::heap()-&gt;register_nmethod(this);
 830     debug_only(Universe::heap()-&gt;verify_nmethod(this));
 831 
 832     CodeCache::commit(this);
 833 
 834     // Copy contents of ExceptionHandlerTable to nmethod
 835     handler_table-&gt;copy_to(this);
</pre>
<hr />
<pre>
 912 // Print out more verbose output usually for a newly created nmethod.
 913 void nmethod::print_on(outputStream* st, const char* msg) const {
 914   if (st != NULL) {
 915     ttyLocker ttyl;
 916     if (WizardMode) {
 917       CompileTask::print(st, this, msg, /*short_form:*/ true);
 918       st-&gt;print_cr(&quot; (&quot; INTPTR_FORMAT &quot;)&quot;, p2i(this));
 919     } else {
 920       CompileTask::print(st, this, msg, /*short_form:*/ false);
 921     }
 922   }
 923 }
 924 
 925 void nmethod::maybe_print_nmethod(DirectiveSet* directive) {
 926   bool printnmethods = directive-&gt;PrintAssemblyOption || directive-&gt;PrintNMethodsOption;
 927   if (printnmethods || PrintDebugInfo || PrintRelocations || PrintDependencies || PrintExceptionHandlers) {
 928     print_nmethod(printnmethods);
 929   }
 930 }
 931 
<span class="line-added"> 932 static nmethod* _nmethod_to_print = NULL;</span>
<span class="line-added"> 933 static const CompiledEntrySignature* _nmethod_to_print_ces = NULL;</span>
<span class="line-added"> 934 </span>
 935 void nmethod::print_nmethod(bool printmethod) {
<span class="line-added"> 936   ResourceMark rm;</span>
<span class="line-added"> 937   CompiledEntrySignature ces(method());</span>
<span class="line-added"> 938   ces.compute_calling_conventions();</span>
<span class="line-added"> 939   // ces.compute_calling_conventions() needs to grab the ProtectionDomainSet_lock, so we</span>
<span class="line-added"> 940   // can&#39;t do that (inside nmethod::print_entry_parameters) while holding the ttyLocker.</span>
<span class="line-added"> 941   // Hence we have do compute it here and pass via a global. Yuck.</span>
 942   ttyLocker ttyl;  // keep the following output all in one block
<span class="line-added"> 943   assert(_nmethod_to_print == NULL &amp;&amp; _nmethod_to_print_ces == NULL, &quot;no nesting&quot;);</span>
<span class="line-added"> 944   _nmethod_to_print = this;</span>
<span class="line-added"> 945   _nmethod_to_print_ces = &amp;ces;</span>
 946   if (xtty != NULL) {
 947     xtty-&gt;begin_head(&quot;print_nmethod&quot;);
 948     log_identity(xtty);
 949     xtty-&gt;stamp();
 950     xtty-&gt;end_head();
 951   }
 952   // Print the header part, then print the requested information.
 953   // This is both handled in decode2().
 954   if (printmethod) {
 955     HandleMark hm;
 956     ResourceMark m;
 957     if (is_compiled_by_c1()) {
 958       tty-&gt;cr();
 959       tty-&gt;print_cr(&quot;============================= C1-compiled nmethod ==============================&quot;);
 960     }
 961     if (is_compiled_by_jvmci()) {
 962       tty-&gt;cr();
 963       tty-&gt;print_cr(&quot;=========================== JVMCI-compiled nmethod =============================&quot;);
 964     }
 965     tty-&gt;print_cr(&quot;----------------------------------- Assembly -----------------------------------&quot;);
</pre>
<hr />
<pre>
1002     }
1003     if (printmethod || PrintExceptionHandlers) {
1004       print_handler_table();
1005       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
1006       print_nul_chk_table();
1007       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
1008     }
1009 
1010     if (printmethod) {
1011       print_recorded_oops();
1012       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
1013       print_recorded_metadata();
1014       tty-&gt;print_cr(&quot;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &quot;);
1015     }
1016   }
1017 #endif
1018 
1019   if (xtty != NULL) {
1020     xtty-&gt;tail(&quot;print_nmethod&quot;);
1021   }
<span class="line-added">1022 </span>
<span class="line-added">1023   _nmethod_to_print = NULL;</span>
<span class="line-added">1024   _nmethod_to_print_ces = NULL;</span>
1025 }
1026 
1027 
1028 // Promote one word from an assembly-time handle to a live embedded oop.
1029 inline void nmethod::initialize_immediate_oop(oop* dest, jobject handle) {
1030   if (handle == NULL ||
1031       // As a special case, IC oops are initialized to 1 or -1.
1032       handle == (jobject) Universe::non_oop_word()) {
1033     (*dest) = (oop) handle;
1034   } else {
1035     (*dest) = JNIHandles::resolve_non_null(handle);
1036   }
1037 }
1038 
1039 
1040 // Have to have the same name because it&#39;s called by a template
1041 void nmethod::copy_values(GrowableArray&lt;jobject&gt;* array) {
1042   int length = array-&gt;length();
1043   assert((address)(oops_begin() + length) &lt;= (address)oops_end(), &quot;oops big enough&quot;);
1044   oop* dest = oops_begin();
</pre>
<hr />
<pre>
2426   VerifyMetadataClosure vmc;
2427   metadata_do(&amp;vmc);
2428 }
2429 
2430 
2431 void nmethod::verify_interrupt_point(address call_site) {
2432   // Verify IC only when nmethod installation is finished.
2433   if (!is_not_installed()) {
2434     if (CompiledICLocker::is_safe(this)) {
2435       CompiledIC_at(this, call_site);
2436     } else {
2437       CompiledICLocker ml_verify(this);
2438       CompiledIC_at(this, call_site);
2439     }
2440   }
2441 
2442   PcDesc* pd = pc_desc_at(nativeCall_at(call_site)-&gt;return_address());
2443   assert(pd != NULL, &quot;PcDesc must exist&quot;);
2444   for (ScopeDesc* sd = new ScopeDesc(this, pd-&gt;scope_decode_offset(),
2445                                      pd-&gt;obj_decode_offset(), pd-&gt;should_reexecute(), pd-&gt;rethrow_exception(),
<span class="line-modified">2446                                      pd-&gt;return_oop(), pd-&gt;return_vt());</span>
2447        !sd-&gt;is_top(); sd = sd-&gt;sender()) {
2448     sd-&gt;verify();
2449   }
2450 }
2451 
2452 void nmethod::verify_scopes() {
2453   if( !method() ) return;       // Runtime stubs have no scope
2454   if (method()-&gt;is_native()) return; // Ignore stub methods.
2455   // iterate through all interrupt point
2456   // and verify the debug information is valid.
2457   RelocIterator iter((nmethod*)this);
2458   while (iter.next()) {
2459     address stub = NULL;
2460     switch (iter.type()) {
2461       case relocInfo::virtual_call_type:
2462         verify_interrupt_point(iter.addr());
2463         break;
2464       case relocInfo::opt_virtual_call_type:
2465         stub = iter.opt_virtual_call_reloc()-&gt;static_stub(false);
2466         verify_interrupt_point(iter.addr());
</pre>
<hr />
<pre>
3066         case relocInfo::internal_word_type:    return &quot;internal_word&quot;;
3067         case relocInfo::section_word_type:     return &quot;section_word&quot;;
3068         case relocInfo::poll_type:             return &quot;poll&quot;;
3069         case relocInfo::poll_return_type:      return &quot;poll_return&quot;;
3070         case relocInfo::trampoline_stub_type:  return &quot;trampoline_stub&quot;;
3071         case relocInfo::type_mask:             return &quot;type_bit_mask&quot;;
3072 
3073         default:
3074           break;
3075     }
3076   }
3077   return have_one ? &quot;other&quot; : NULL;
3078 }
3079 
3080 // Return a the last scope in (begin..end]
3081 ScopeDesc* nmethod::scope_desc_in(address begin, address end) {
3082   PcDesc* p = pc_desc_near(begin+1);
3083   if (p != NULL &amp;&amp; p-&gt;real_pc(this) &lt;= end) {
3084     return new ScopeDesc(this, p-&gt;scope_decode_offset(),
3085                          p-&gt;obj_decode_offset(), p-&gt;should_reexecute(), p-&gt;rethrow_exception(),
<span class="line-modified">3086                          p-&gt;return_oop(), p-&gt;return_vt());</span>
3087   }
3088   return NULL;
3089 }
3090 
3091 const char* nmethod::nmethod_section_label(address pos) const {
3092   const char* label = NULL;
3093   if (pos == code_begin())                                              label = &quot;[Instructions begin]&quot;;
3094   if (pos == entry_point())                                             label = &quot;[Entry Point]&quot;;
<span class="line-added">3095   if (pos == value_entry_point())                                       label = &quot;[Value Entry Point]&quot;;</span>
3096   if (pos == verified_entry_point())                                    label = &quot;[Verified Entry Point]&quot;;
<span class="line-added">3097   if (pos == verified_value_entry_point())                              label = &quot;[Verified Value Entry Point]&quot;;</span>
<span class="line-added">3098   if (pos == verified_value_ro_entry_point())                           label = &quot;[Verified Value Entry Point (RO)]&quot;;</span>
3099   if (has_method_handle_invokes() &amp;&amp; (pos == deopt_mh_handler_begin())) label = &quot;[Deopt MH Handler Code]&quot;;
3100   if (pos == consts_begin() &amp;&amp; pos != insts_begin())                    label = &quot;[Constants]&quot;;
3101   // Check stub_code before checking exception_handler or deopt_handler.
3102   if (pos == this-&gt;stub_begin())                                        label = &quot;[Stub Code]&quot;;
3103   if (JVMCI_ONLY(_exception_offset &gt;= 0 &amp;&amp;) pos == exception_begin())           label = &quot;[Exception Handler]&quot;;
3104   if (JVMCI_ONLY(_deopt_handler_begin != NULL &amp;&amp;) pos == deopt_handler_begin()) label = &quot;[Deopt Handler Code]&quot;;
3105   return label;
3106 }
3107 
<span class="line-added">3108 static int maybe_print_entry_label(outputStream* stream, address pos, address entry, const char* label) {</span>
<span class="line-added">3109   if (pos == entry) {</span>
<span class="line-added">3110     stream-&gt;bol();</span>
<span class="line-added">3111     stream-&gt;print_cr(&quot;%s&quot;, label);</span>
<span class="line-added">3112     return 1;</span>
<span class="line-added">3113   } else {</span>
<span class="line-added">3114     return 0;</span>
<span class="line-added">3115   }</span>
<span class="line-added">3116 }</span>
<span class="line-added">3117 </span>
3118 void nmethod::print_nmethod_labels(outputStream* stream, address block_begin, bool print_section_labels) const {
3119   if (print_section_labels) {
<span class="line-modified">3120     int n = 0;</span>
<span class="line-modified">3121     // Multiple entry points may be at the same position. Print them all.</span>
<span class="line-modified">3122     n += maybe_print_entry_label(stream, block_begin, entry_point(),                   &quot;[Entry Point]&quot;);</span>
<span class="line-modified">3123     n += maybe_print_entry_label(stream, block_begin, value_entry_point(),             &quot;[Value Entry Point]&quot;);</span>
<span class="line-added">3124     n += maybe_print_entry_label(stream, block_begin, verified_entry_point(),          &quot;[Verified Entry Point]&quot;);</span>
<span class="line-added">3125     n += maybe_print_entry_label(stream, block_begin, verified_value_entry_point(),    &quot;[Verified Value Entry Point]&quot;);</span>
<span class="line-added">3126     n += maybe_print_entry_label(stream, block_begin, verified_value_ro_entry_point(), &quot;[Verified Value Entry Point (RO)]&quot;);</span>
<span class="line-added">3127     if (n == 0) {</span>
<span class="line-added">3128       const char* label = nmethod_section_label(block_begin);</span>
<span class="line-added">3129       if (label != NULL) {</span>
<span class="line-added">3130         stream-&gt;bol();</span>
<span class="line-added">3131         stream-&gt;print_cr(&quot;%s&quot;, label);</span>
<span class="line-added">3132       }</span>
3133     }
3134   }
3135 
<span class="line-modified">3136   if (_nmethod_to_print != this) {</span>
<span class="line-modified">3137     return;</span>
<span class="line-modified">3138   }</span>
<span class="line-modified">3139   Method* m = method();</span>
<span class="line-modified">3140   if (m == NULL || is_osr_method()) {</span>
<span class="line-modified">3141     return;</span>
<span class="line-added">3142   }</span>
<span class="line-added">3143 </span>
<span class="line-added">3144   // Print the name of the method (only once)</span>
<span class="line-added">3145   address low = MIN4(entry_point(), verified_entry_point(), verified_value_entry_point(), verified_value_ro_entry_point());</span>
<span class="line-added">3146   low = MIN2(low, value_entry_point());</span>
<span class="line-added">3147   assert(low != 0, &quot;sanity&quot;);</span>
<span class="line-added">3148   if (block_begin == low) {</span>
<span class="line-added">3149     stream-&gt;print(&quot;  # &quot;);</span>
<span class="line-added">3150     m-&gt;print_value_on(stream);</span>
<span class="line-added">3151     stream-&gt;cr();</span>
<span class="line-added">3152   }</span>
<span class="line-added">3153 </span>
<span class="line-added">3154   // Print the arguments for the 3 types of verified entry points</span>
<span class="line-added">3155   {</span>
<span class="line-added">3156     const CompiledEntrySignature* ces = _nmethod_to_print_ces;</span>
<span class="line-added">3157     const GrowableArray&lt;SigEntry&gt;* sig_cc;</span>
<span class="line-added">3158     const VMRegPair* regs;</span>
<span class="line-added">3159     if (block_begin == verified_entry_point()) {</span>
<span class="line-added">3160       sig_cc = &amp;ces-&gt;sig_cc();</span>
<span class="line-added">3161       regs = ces-&gt;regs_cc();</span>
<span class="line-added">3162     } else if (block_begin == verified_value_entry_point()) {</span>
<span class="line-added">3163       sig_cc = &amp;ces-&gt;sig();</span>
<span class="line-added">3164       regs = ces-&gt;regs();</span>
<span class="line-added">3165     } else if (block_begin == verified_value_ro_entry_point()) {</span>
<span class="line-added">3166       sig_cc = &amp;ces-&gt;sig_cc_ro();</span>
<span class="line-added">3167       regs = ces-&gt;regs_cc_ro();</span>
<span class="line-added">3168     } else {</span>
<span class="line-added">3169       return;</span>
3170     }
<span class="line-modified">3171 </span>
<span class="line-modified">3172     ResourceMark rm;</span>
<span class="line-modified">3173     int sizeargs = 0;</span>
<span class="line-modified">3174     BasicType* sig_bt = NEW_RESOURCE_ARRAY(BasicType, 256);</span>
<span class="line-modified">3175     bool has_scalarized_args = ces-&gt;has_scalarized_args();</span>
<span class="line-modified">3176     TempNewSymbol sig = SigEntry::create_symbol(sig_cc);</span>
<span class="line-modified">3177     for (SignatureStream ss(sig); !ss.at_return_type(); ss.next()) {</span>
<span class="line-modified">3178       BasicType t = ss.type();</span>
<span class="line-modified">3179       sig_bt[sizeargs++] = t;</span>
<span class="line-modified">3180       if (type2size[t] == 2) {</span>
<span class="line-modified">3181         sig_bt[sizeargs++] = T_VOID;</span>
<span class="line-modified">3182       } else {</span>
<span class="line-modified">3183         assert(type2size[t] == 1, &quot;size is 1 or 2&quot;);</span>
<span class="line-modified">3184       }</span>
<span class="line-modified">3185     }</span>
<span class="line-modified">3186     bool has_this = !m-&gt;is_static();</span>
<span class="line-modified">3187     if (ces-&gt;has_value_recv() &amp;&amp; block_begin == verified_entry_point()) {</span>
<span class="line-added">3188       // &lt;this&gt; argument is scalarized for verified_entry_point()</span>
<span class="line-added">3189       has_this = false;</span>
<span class="line-added">3190     }</span>
<span class="line-added">3191     const char* spname = &quot;sp&quot;; // make arch-specific?</span>
<span class="line-added">3192     int stack_slot_offset = this-&gt;frame_size() * wordSize;</span>
<span class="line-added">3193     int tab1 = 14, tab2 = 24;</span>
<span class="line-added">3194     int sig_index = 0;</span>
<span class="line-added">3195     int sig_index_cc = 0;</span>
<span class="line-added">3196     int arg_index = has_this ? -1 : 0;</span>
<span class="line-added">3197     bool did_old_sp = false;</span>
<span class="line-added">3198     for (SignatureStream ss(sig); !ss.at_return_type(); ) {</span>
<span class="line-added">3199       bool at_this = (arg_index == -1);</span>
<span class="line-added">3200       bool at_old_sp = false;</span>
<span class="line-added">3201       BasicType t = ss.type();</span>
<span class="line-added">3202       assert(t == sig_bt[sig_index], &quot;sigs in sync&quot;);</span>
<span class="line-added">3203       if (at_this) {</span>
<span class="line-added">3204         stream-&gt;print(&quot;  # this: &quot;);</span>
<span class="line-added">3205       } else {</span>
<span class="line-added">3206         stream-&gt;print(&quot;  # parm%d: &quot;, arg_index);</span>
<span class="line-added">3207       }</span>
<span class="line-added">3208       stream-&gt;move_to(tab1);</span>
<span class="line-added">3209       VMReg fst = regs[sig_index].first();</span>
<span class="line-added">3210       VMReg snd = regs[sig_index].second();</span>
<span class="line-added">3211       if (fst-&gt;is_reg()) {</span>
<span class="line-added">3212         stream-&gt;print(&quot;%s&quot;, fst-&gt;name());</span>
<span class="line-added">3213         if (snd-&gt;is_valid())  {</span>
<span class="line-added">3214           stream-&gt;print(&quot;:%s&quot;, snd-&gt;name());</span>
3215         }
<span class="line-modified">3216       } else if (fst-&gt;is_stack()) {</span>
<span class="line-added">3217         int offset = fst-&gt;reg2stack() * VMRegImpl::stack_slot_size + stack_slot_offset;</span>
<span class="line-added">3218         if (offset == stack_slot_offset)  at_old_sp = true;</span>
<span class="line-added">3219         stream-&gt;print(&quot;[%s+0x%x]&quot;, spname, offset);</span>
<span class="line-added">3220       } else {</span>
<span class="line-added">3221         stream-&gt;print(&quot;reg%d:%d??&quot;, (int)(intptr_t)fst, (int)(intptr_t)snd);</span>
3222       }
<span class="line-modified">3223       stream-&gt;print(&quot; &quot;);</span>
<span class="line-modified">3224       stream-&gt;move_to(tab2);</span>
<span class="line-modified">3225       stream-&gt;print(&quot;= &quot;);</span>
<span class="line-modified">3226       if (at_this) {</span>
<span class="line-modified">3227         m-&gt;method_holder()-&gt;print_value_on(stream);</span>
<span class="line-modified">3228       } else {</span>
<span class="line-modified">3229         bool did_name = false;</span>
<span class="line-modified">3230         if (ss.is_reference()) {</span>
<span class="line-modified">3231           Symbol* name = ss.as_symbol();</span>
<span class="line-modified">3232           name-&gt;print_value_on(stream);</span>
<span class="line-modified">3233           did_name = true;</span>



















3234         }
<span class="line-modified">3235         if (!did_name)</span>
<span class="line-modified">3236           stream-&gt;print(&quot;%s&quot;, type2name(t));</span>
<span class="line-modified">3237       }</span>
<span class="line-modified">3238       if (has_scalarized_args) {</span>
<span class="line-modified">3239         while (!SigEntry::skip_value_delimiters(sig_cc, sig_index_cc)) {</span>
<span class="line-modified">3240           sig_index_cc++;</span>








3241         }
<span class="line-modified">3242         if (SigEntry::is_reserved_entry(sig_cc, sig_index_cc)) {</span>
<span class="line-modified">3243           stream-&gt;print(&quot; [RESERVED]&quot;);</span>

3244         }
<span class="line-modified">3245         sig_index_cc += type2size[t];</span>



3246       }
<span class="line-modified">3247       if (at_old_sp) {</span>



3248         stream-&gt;print(&quot;  (%s of caller)&quot;, spname);
<span class="line-modified">3249         did_old_sp = true;</span>
3250       }
<span class="line-added">3251       stream-&gt;cr();</span>
<span class="line-added">3252       sig_index += type2size[t];</span>
<span class="line-added">3253       arg_index += 1;</span>
<span class="line-added">3254       ss.next();</span>
<span class="line-added">3255     }</span>
<span class="line-added">3256     if (!did_old_sp) {</span>
<span class="line-added">3257       stream-&gt;print(&quot;  # &quot;);</span>
<span class="line-added">3258       stream-&gt;move_to(tab1);</span>
<span class="line-added">3259       stream-&gt;print(&quot;[%s+0x%x]&quot;, spname, stack_slot_offset);</span>
<span class="line-added">3260       stream-&gt;print(&quot;  (%s of caller)&quot;, spname);</span>
<span class="line-added">3261       stream-&gt;cr();</span>
3262     }
3263   }
3264 }
3265 
3266 // Returns whether this nmethod has code comments.
3267 bool nmethod::has_code_comment(address begin, address end) {
3268   // scopes?
3269   ScopeDesc* sd  = scope_desc_in(begin, end);
3270   if (sd != NULL) return true;
3271 
3272   // relocations?
3273   const char* str = reloc_string_for(begin, end);
3274   if (str != NULL) return true;
3275 
3276   // implicit exceptions?
3277   int cont_offset = ImplicitExceptionTable(this).continuation_offset(begin - code_begin());
3278   if (cont_offset != 0) return true;
3279 
3280   return false;
3281 }
</pre>
<hr />
<pre>
3366             else
3367               st-&gt;print(&quot;&lt;UNKNOWN&gt;&quot;);
3368             break;
3369           }
3370         case Bytecodes::_getfield:
3371         case Bytecodes::_putfield:
3372         case Bytecodes::_getstatic:
3373         case Bytecodes::_putstatic:
3374           {
3375             Bytecode_field field(methodHandle(thread, sd-&gt;method()), sd-&gt;bci());
3376             st-&gt;print(&quot; &quot;);
3377             if (field.name() != NULL)
3378               field.name()-&gt;print_symbol_on(st);
3379             else
3380               st-&gt;print(&quot;&lt;UNKNOWN&gt;&quot;);
3381           }
3382         default:
3383           break;
3384         }
3385       }
<span class="line-modified">3386       st-&gt;print(&quot; {reexecute=%d rethrow=%d return_oop=%d return_vt=%d}&quot;, sd-&gt;should_reexecute(), sd-&gt;rethrow_exception(), sd-&gt;return_oop(), sd-&gt;return_vt());</span>
3387     }
3388 
3389     // Print all scopes
3390     for (;sd != NULL; sd = sd-&gt;sender()) {
3391       st-&gt;move_to(column, 6, 0);
3392       st-&gt;print(&quot;; -&quot;);
3393       if (sd-&gt;should_reexecute()) {
3394         st-&gt;print(&quot; (reexecute)&quot;);
3395       }
3396       if (sd-&gt;method() == NULL) {
3397         st-&gt;print(&quot;method is NULL&quot;);
3398       } else {
3399         sd-&gt;method()-&gt;print_short_name(st);
3400       }
3401       int lineno = sd-&gt;method()-&gt;line_number_from_bci(sd-&gt;bci());
3402       if (lineno != -1) {
3403         st-&gt;print(&quot;@%d (line %d)&quot;, sd-&gt;bci(), lineno);
3404       } else {
3405         st-&gt;print(&quot;@%d&quot;, sd-&gt;bci());
3406       }
</pre>
</td>
</tr>
</table>
<center><a href="../classfile/systemDictionary.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../compiler/compileBroker.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/constantPool.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../memory/universe.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cpCache.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/constantPool.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  33 #include &quot;interpreter/bootstrapInfo.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;logging/logStream.hpp&quot;
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/heapShared.hpp&quot;
  39 #include &quot;memory/metadataFactory.hpp&quot;
  40 #include &quot;memory/metaspaceClosure.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/array.hpp&quot;
  46 #include &quot;oops/constantPool.inline.hpp&quot;
  47 #include &quot;oops/cpCache.inline.hpp&quot;
  48 #include &quot;oops/instanceKlass.hpp&quot;
  49 #include &quot;oops/objArrayKlass.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/typeArrayOop.inline.hpp&quot;

  53 #include &quot;runtime/atomic.hpp&quot;
  54 #include &quot;runtime/handles.inline.hpp&quot;
  55 #include &quot;runtime/init.hpp&quot;
  56 #include &quot;runtime/javaCalls.hpp&quot;
  57 #include &quot;runtime/signature.hpp&quot;
  58 #include &quot;runtime/thread.inline.hpp&quot;
  59 #include &quot;runtime/vframe.inline.hpp&quot;
  60 #include &quot;utilities/copy.hpp&quot;
  61 
  62 ConstantPool* ConstantPool::allocate(ClassLoaderData* loader_data, int length, TRAPS) {
  63   Array&lt;u1&gt;* tags = MetadataFactory::new_array&lt;u1&gt;(loader_data, length, 0, CHECK_NULL);
  64   int size = ConstantPool::size(length);
  65   return new (loader_data, size, MetaspaceObj::ConstantPoolType, THREAD) ConstantPool(tags);
  66 }
  67 
  68 void ConstantPool::copy_fields(const ConstantPool* orig) {
  69   // Preserve dynamic constant information from the original pool
  70   if (orig-&gt;has_dynamic_constant()) {
  71     set_has_dynamic_constant();
  72   }
</pre>
<hr />
<pre>
 210   assert(resolved_klasses() == NULL, &quot;sanity&quot;);
 211   Array&lt;Klass*&gt;* rk = MetadataFactory::new_array&lt;Klass*&gt;(loader_data, num_klasses, CHECK);
 212   set_resolved_klasses(rk);
 213 }
 214 
 215 void ConstantPool::initialize_unresolved_klasses(ClassLoaderData* loader_data, TRAPS) {
 216   int len = length();
 217   int num_klasses = 0;
 218   for (int i = 1; i &lt;len; i++) {
 219     switch (tag_at(i).value()) {
 220     case JVM_CONSTANT_ClassIndex:
 221       {
 222         const int class_index = klass_index_at(i);
 223         unresolved_klass_at_put(i, class_index, num_klasses++);
 224       }
 225       break;
 226 #ifndef PRODUCT
 227     case JVM_CONSTANT_Class:
 228     case JVM_CONSTANT_UnresolvedClass:
 229     case JVM_CONSTANT_UnresolvedClassInError:
<span class="line-modified"> 230       // All of these should have been reverted back to ClassIndex before calling</span>
 231       // this function.
 232       ShouldNotReachHere();
 233 #endif
 234     }
 235   }
 236   allocate_resolved_klasses(loader_data, num_klasses, THREAD);
 237 }
 238 
 239 // Unsafe anonymous class support:
 240 void ConstantPool::klass_at_put(int class_index, int name_index, int resolved_klass_index, Klass* k, Symbol* name) {
 241   assert(is_within_bounds(class_index), &quot;index out of bounds&quot;);
 242   assert(is_within_bounds(name_index), &quot;index out of bounds&quot;);
 243   assert((resolved_klass_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 244   *int_at_addr(class_index) =
 245     build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);
 246 
 247   symbol_at_put(name_index, name);
 248   name-&gt;increment_refcount();
 249   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
 250   Atomic::release_store(adr, k);
 251 
 252   // The interpreter assumes when the tag is stored, the klass is resolved
 253   // and the Klass* non-NULL, so we need hardware store ordering here.

 254   if (k != NULL) {
<span class="line-modified"> 255     release_tag_at_put(class_index, JVM_CONSTANT_Class);</span>
 256   } else {
<span class="line-modified"> 257     release_tag_at_put(class_index, JVM_CONSTANT_UnresolvedClass);</span>
 258   }
 259 }
 260 
 261 // Unsafe anonymous class support:
 262 void ConstantPool::klass_at_put(int class_index, Klass* k) {
 263   assert(k != NULL, &quot;must be valid klass&quot;);
 264   CPKlassSlot kslot = klass_slot_at(class_index);
 265   int resolved_klass_index = kslot.resolved_klass_index();
 266   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
 267   Atomic::release_store(adr, k);
 268 
 269   // The interpreter assumes when the tag is stored, the klass is resolved
 270   // and the Klass* non-NULL, so we need hardware store ordering here.

 271   release_tag_at_put(class_index, JVM_CONSTANT_Class);
 272 }
 273 
 274 #if INCLUDE_CDS_JAVA_HEAP
 275 // Archive the resolved references
 276 void ConstantPool::archive_resolved_references(Thread* THREAD) {
 277   if (_cache == NULL) {
 278     return; // nothing to do
 279   }
 280 
 281   InstanceKlass *ik = pool_holder();
 282   if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
 283         ik-&gt;is_shared_app_class())) {
 284     // Archiving resolved references for classes from non-builtin loaders
 285     // is not yet supported.
 286     set_resolved_references(OopHandle());
 287     return;
 288   }
 289 
 290   objArrayOop rr = resolved_references();
</pre>
<hr />
<pre>
 459       Symbol* s = vfst.method()-&gt;method_holder()-&gt;source_file_name();
 460       if (s != NULL) {
 461         source_file = s-&gt;as_C_string();
 462       }
 463     }
 464   }
 465   if (k != this_cp-&gt;pool_holder()) {
 466     // only print something if the classes are different
 467     if (source_file != NULL) {
 468       log_debug(class, resolve)(&quot;%s %s %s:%d&quot;,
 469                  this_cp-&gt;pool_holder()-&gt;external_name(),
 470                  k-&gt;external_name(), source_file, line_number);
 471     } else {
 472       log_debug(class, resolve)(&quot;%s %s&quot;,
 473                  this_cp-&gt;pool_holder()-&gt;external_name(),
 474                  k-&gt;external_name());
 475     }
 476   }
 477 }
 478 






 479 Klass* ConstantPool::klass_at_impl(const constantPoolHandle&amp; this_cp, int which,
 480                                    bool save_resolution_error, TRAPS) {
 481   assert(THREAD-&gt;is_Java_thread(), &quot;must be a Java thread&quot;);
 482   JavaThread* javaThread = (JavaThread*)THREAD;
 483 
 484   // A resolved constantPool entry will contain a Klass*, otherwise a Symbol*.
 485   // It is not safe to rely on the tag bit&#39;s here, since we don&#39;t have a lock, and
 486   // the entry and tag is not updated atomicly.
 487   CPKlassSlot kslot = this_cp-&gt;klass_slot_at(which);
 488   int resolved_klass_index = kslot.resolved_klass_index();
 489   int name_index = kslot.name_index();
 490   assert(this_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 491 
 492   Klass* klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 493   if (klass != NULL) {
 494     return klass;
 495   }
 496 
 497   // This tag doesn&#39;t change back to unresolved class unless at a safepoint.
 498   if (this_cp-&gt;tag_at(which).is_unresolved_klass_in_error()) {
 499     // The original attempt to resolve this constant pool entry failed so find the
 500     // class of the original error and throw another error of the same class
 501     // (JVMS 5.4.3).
 502     // If there is a detail message, pass that detail message to the error.
 503     // The JVMS does not strictly require us to duplicate the same detail message,
 504     // or any internal exception fields such as cause or stacktrace.  But since the
 505     // detail message is often a class name or other literal string, we will repeat it
 506     // if we can find it in the symbol table.
 507     throw_resolution_error(this_cp, which, CHECK_NULL);
 508     ShouldNotReachHere();
 509   }
 510 
 511   Handle mirror_handle;
 512   Symbol* name = this_cp-&gt;symbol_at(name_index);





 513   Handle loader (THREAD, this_cp-&gt;pool_holder()-&gt;class_loader());
 514   Handle protection_domain (THREAD, this_cp-&gt;pool_holder()-&gt;protection_domain());
 515 
 516   Klass* k;
 517   {
 518     // Turn off the single stepping while doing class resolution
 519     JvmtiHideSingleStepping jhss(javaThread);
 520     k = SystemDictionary::resolve_or_fail(name, loader, protection_domain, true, THREAD);
 521   } //  JvmtiHideSingleStepping jhss(javaThread);



 522 
 523   if (!HAS_PENDING_EXCEPTION) {
 524     // preserve the resolved klass from unloading
 525     mirror_handle = Handle(THREAD, k-&gt;java_mirror());
 526     // Do access check for klasses
 527     verify_constant_pool_resolve(this_cp, k, THREAD);
 528   }
 529 
















 530   // Failed to resolve class. We must record the errors so that subsequent attempts
 531   // to resolve this constant pool entry fail with the same error (JVMS 5.4.3).
 532   if (HAS_PENDING_EXCEPTION) {
 533     if (save_resolution_error) {
 534       save_and_throw_exception(this_cp, which, constantTag(JVM_CONSTANT_UnresolvedClass), CHECK_NULL);
 535       // If CHECK_NULL above doesn&#39;t return the exception, that means that
 536       // some other thread has beaten us and has resolved the class.
 537       // To preserve old behavior, we return the resolved class.
 538       klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 539       assert(klass != NULL, &quot;must be resolved if exception was cleared&quot;);
 540       return klass;
 541     } else {
 542       return NULL;  // return the pending exception
 543     }
 544   }
 545 
 546   // logging for class+resolve.
 547   if (log_is_enabled(Debug, class, resolve)){
 548     trace_class_resolution(this_cp, k);
 549   }
 550   Klass** adr = this_cp-&gt;resolved_klasses()-&gt;adr_at(resolved_klass_index);
 551   Atomic::release_store(adr, k);
 552   // The interpreter assumes when the tag is stored, the klass is resolved
 553   // and the Klass* stored in _resolved_klasses is non-NULL, so we need
 554   // hardware store ordering here.
<span class="line-modified"> 555   this_cp-&gt;release_tag_at_put(which, JVM_CONSTANT_Class);</span>




 556   return k;
 557 }
 558 
 559 
 560 // Does not update ConstantPool* - to avoid any exception throwing. Used
 561 // by compiler and exception handling.  Also used to avoid classloads for
 562 // instanceof operations. Returns NULL if the class has not been loaded or
 563 // if the verification of constant pool failed
 564 Klass* ConstantPool::klass_at_if_loaded(const constantPoolHandle&amp; this_cp, int which) {
 565   CPKlassSlot kslot = this_cp-&gt;klass_slot_at(which);
 566   int resolved_klass_index = kslot.resolved_klass_index();
 567   int name_index = kslot.name_index();
 568   assert(this_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 569 
 570   Klass* k = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 571   if (k != NULL) {
 572     return k;
 573   } else {
 574     Thread *thread = Thread::current();
 575     Symbol* name = this_cp-&gt;symbol_at(name_index);
</pre>
<hr />
<pre>
1859       case JVM_CONSTANT_Long: {
1860         u8 val = Bytes::get_Java_u8(bytes);
1861         printf(&quot;long         &quot; INT64_FORMAT, (int64_t) *(jlong *) &amp;val);
1862         ent_size = 8;
1863         idx++; // Long takes two cpool slots
1864         break;
1865       }
1866       case JVM_CONSTANT_Double: {
1867         u8 val = Bytes::get_Java_u8(bytes);
1868         printf(&quot;double       %5.3fd&quot;, *(jdouble *)&amp;val);
1869         ent_size = 8;
1870         idx++; // Double takes two cpool slots
1871         break;
1872       }
1873       case JVM_CONSTANT_Class: {
1874         idx1 = Bytes::get_Java_u2(bytes);
1875         printf(&quot;class        #%03d&quot;, idx1);
1876         ent_size = 2;
1877         break;
1878       }






1879       case JVM_CONSTANT_String: {
1880         idx1 = Bytes::get_Java_u2(bytes);
1881         printf(&quot;String       #%03d&quot;, idx1);
1882         ent_size = 2;
1883         break;
1884       }
1885       case JVM_CONSTANT_Fieldref: {
1886         idx1 = Bytes::get_Java_u2(bytes);
1887         idx2 = Bytes::get_Java_u2(bytes+2);
1888         printf(&quot;Field        #%03d, #%03d&quot;, (int) idx1, (int) idx2);
1889         ent_size = 4;
1890         break;
1891       }
1892       case JVM_CONSTANT_Methodref: {
1893         idx1 = Bytes::get_Java_u2(bytes);
1894         idx2 = Bytes::get_Java_u2(bytes+2);
1895         printf(&quot;Method       #%03d, #%03d&quot;, idx1, idx2);
1896         ent_size = 4;
1897         break;
1898       }
</pre>
<hr />
<pre>
1901         idx2 = Bytes::get_Java_u2(bytes+2);
1902         printf(&quot;InterfMethod #%03d, #%03d&quot;, idx1, idx2);
1903         ent_size = 4;
1904         break;
1905       }
1906       case JVM_CONSTANT_NameAndType: {
1907         idx1 = Bytes::get_Java_u2(bytes);
1908         idx2 = Bytes::get_Java_u2(bytes+2);
1909         printf(&quot;NameAndType  #%03d, #%03d&quot;, idx1, idx2);
1910         ent_size = 4;
1911         break;
1912       }
1913       case JVM_CONSTANT_ClassIndex: {
1914         printf(&quot;ClassIndex  %s&quot;, WARN_MSG);
1915         break;
1916       }
1917       case JVM_CONSTANT_UnresolvedClass: {
1918         printf(&quot;UnresolvedClass: %s&quot;, WARN_MSG);
1919         break;
1920       }




1921       case JVM_CONSTANT_UnresolvedClassInError: {
1922         printf(&quot;UnresolvedClassInErr: %s&quot;, WARN_MSG);
1923         break;
1924       }
1925       case JVM_CONSTANT_StringIndex: {
1926         printf(&quot;StringIndex: %s&quot;, WARN_MSG);
1927         break;
1928       }
1929     }
1930     printf(&quot;;\n&quot;);
1931     bytes += ent_size;
1932     size  += ent_size;
1933   }
1934   printf(&quot;Cpool size: %d\n&quot;, size);
1935   fflush(0);
1936   return;
1937 } /* end print_cpool_bytes */
1938 
1939 
1940 // Returns size of constant pool entry.
</pre>
<hr />
<pre>
2072       case JVM_CONSTANT_Float: {
2073         jfloat val = float_at(idx);
2074         Bytes::put_Java_u4((address) (bytes+1), *(u4*)&amp;val);
2075         break;
2076       }
2077       case JVM_CONSTANT_Long: {
2078         jlong val = long_at(idx);
2079         Bytes::put_Java_u8((address) (bytes+1), *(u8*)&amp;val);
2080         idx++;             // Long takes two cpool slots
2081         break;
2082       }
2083       case JVM_CONSTANT_Double: {
2084         jdouble val = double_at(idx);
2085         Bytes::put_Java_u8((address) (bytes+1), *(u8*)&amp;val);
2086         idx++;             // Double takes two cpool slots
2087         break;
2088       }
2089       case JVM_CONSTANT_Class:
2090       case JVM_CONSTANT_UnresolvedClass:
2091       case JVM_CONSTANT_UnresolvedClassInError: {

2092         *bytes = JVM_CONSTANT_Class;
2093         Symbol* sym = klass_name_at(idx);
2094         idx1 = tbl-&gt;symbol_to_value(sym);
2095         assert(idx1 != 0, &quot;Have not found a hashtable entry&quot;);
2096         Bytes::put_Java_u2((address) (bytes+1), idx1);
2097         DBG(printf(&quot;JVM_CONSTANT_Class: idx=#%03hd, %s&quot;, idx1, sym-&gt;as_utf8()));
2098         break;
2099       }
2100       case JVM_CONSTANT_String: {
2101         *bytes = JVM_CONSTANT_String;
2102         Symbol* sym = unresolved_string_at(idx);
2103         idx1 = tbl-&gt;symbol_to_value(sym);
2104         assert(idx1 != 0, &quot;Have not found a hashtable entry&quot;);
2105         Bytes::put_Java_u2((address) (bytes+1), idx1);
2106         DBG(printf(&quot;JVM_CONSTANT_String: idx=#%03hd, %s&quot;, idx1, sym-&gt;as_utf8()));
2107         break;
2108       }
2109       case JVM_CONSTANT_Fieldref:
2110       case JVM_CONSTANT_Methodref:
2111       case JVM_CONSTANT_InterfaceMethodref: {
</pre>
</td>
<td>
<hr />
<pre>
  33 #include &quot;interpreter/bootstrapInfo.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;logging/logStream.hpp&quot;
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/heapShared.hpp&quot;
  39 #include &quot;memory/metadataFactory.hpp&quot;
  40 #include &quot;memory/metaspaceClosure.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/array.hpp&quot;
  46 #include &quot;oops/constantPool.inline.hpp&quot;
  47 #include &quot;oops/cpCache.inline.hpp&quot;
  48 #include &quot;oops/instanceKlass.hpp&quot;
  49 #include &quot;oops/objArrayKlass.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/typeArrayOop.inline.hpp&quot;
<span class="line-added">  53 #include &quot;oops/valueArrayKlass.hpp&quot;</span>
  54 #include &quot;runtime/atomic.hpp&quot;
  55 #include &quot;runtime/handles.inline.hpp&quot;
  56 #include &quot;runtime/init.hpp&quot;
  57 #include &quot;runtime/javaCalls.hpp&quot;
  58 #include &quot;runtime/signature.hpp&quot;
  59 #include &quot;runtime/thread.inline.hpp&quot;
  60 #include &quot;runtime/vframe.inline.hpp&quot;
  61 #include &quot;utilities/copy.hpp&quot;
  62 
  63 ConstantPool* ConstantPool::allocate(ClassLoaderData* loader_data, int length, TRAPS) {
  64   Array&lt;u1&gt;* tags = MetadataFactory::new_array&lt;u1&gt;(loader_data, length, 0, CHECK_NULL);
  65   int size = ConstantPool::size(length);
  66   return new (loader_data, size, MetaspaceObj::ConstantPoolType, THREAD) ConstantPool(tags);
  67 }
  68 
  69 void ConstantPool::copy_fields(const ConstantPool* orig) {
  70   // Preserve dynamic constant information from the original pool
  71   if (orig-&gt;has_dynamic_constant()) {
  72     set_has_dynamic_constant();
  73   }
</pre>
<hr />
<pre>
 211   assert(resolved_klasses() == NULL, &quot;sanity&quot;);
 212   Array&lt;Klass*&gt;* rk = MetadataFactory::new_array&lt;Klass*&gt;(loader_data, num_klasses, CHECK);
 213   set_resolved_klasses(rk);
 214 }
 215 
 216 void ConstantPool::initialize_unresolved_klasses(ClassLoaderData* loader_data, TRAPS) {
 217   int len = length();
 218   int num_klasses = 0;
 219   for (int i = 1; i &lt;len; i++) {
 220     switch (tag_at(i).value()) {
 221     case JVM_CONSTANT_ClassIndex:
 222       {
 223         const int class_index = klass_index_at(i);
 224         unresolved_klass_at_put(i, class_index, num_klasses++);
 225       }
 226       break;
 227 #ifndef PRODUCT
 228     case JVM_CONSTANT_Class:
 229     case JVM_CONSTANT_UnresolvedClass:
 230     case JVM_CONSTANT_UnresolvedClassInError:
<span class="line-modified"> 231       // All of these should have been reverted back to Unresolved before calling</span>
 232       // this function.
 233       ShouldNotReachHere();
 234 #endif
 235     }
 236   }
 237   allocate_resolved_klasses(loader_data, num_klasses, THREAD);
 238 }
 239 
 240 // Unsafe anonymous class support:
 241 void ConstantPool::klass_at_put(int class_index, int name_index, int resolved_klass_index, Klass* k, Symbol* name) {
 242   assert(is_within_bounds(class_index), &quot;index out of bounds&quot;);
 243   assert(is_within_bounds(name_index), &quot;index out of bounds&quot;);
 244   assert((resolved_klass_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 245   *int_at_addr(class_index) =
 246     build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);
 247 
 248   symbol_at_put(name_index, name);
 249   name-&gt;increment_refcount();
 250   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
 251   Atomic::release_store(adr, k);
 252 
 253   // The interpreter assumes when the tag is stored, the klass is resolved
 254   // and the Klass* non-NULL, so we need hardware store ordering here.
<span class="line-added"> 255   jbyte qdesc_bit = (name-&gt;is_Q_signature()) ? (jbyte) JVM_CONSTANT_QDescBit : 0;</span>
 256   if (k != NULL) {
<span class="line-modified"> 257     release_tag_at_put(class_index, JVM_CONSTANT_Class | qdesc_bit);</span>
 258   } else {
<span class="line-modified"> 259     release_tag_at_put(class_index, JVM_CONSTANT_UnresolvedClass | qdesc_bit);</span>
 260   }
 261 }
 262 
 263 // Unsafe anonymous class support:
 264 void ConstantPool::klass_at_put(int class_index, Klass* k) {
 265   assert(k != NULL, &quot;must be valid klass&quot;);
 266   CPKlassSlot kslot = klass_slot_at(class_index);
 267   int resolved_klass_index = kslot.resolved_klass_index();
 268   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
 269   Atomic::release_store(adr, k);
 270 
 271   // The interpreter assumes when the tag is stored, the klass is resolved
 272   // and the Klass* non-NULL, so we need hardware store ordering here.
<span class="line-added"> 273   assert(!k-&gt;name()-&gt;is_Q_signature(), &quot;Q-type without JVM_CONSTANT_QDescBit&quot;);</span>
 274   release_tag_at_put(class_index, JVM_CONSTANT_Class);
 275 }
 276 
 277 #if INCLUDE_CDS_JAVA_HEAP
 278 // Archive the resolved references
 279 void ConstantPool::archive_resolved_references(Thread* THREAD) {
 280   if (_cache == NULL) {
 281     return; // nothing to do
 282   }
 283 
 284   InstanceKlass *ik = pool_holder();
 285   if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
 286         ik-&gt;is_shared_app_class())) {
 287     // Archiving resolved references for classes from non-builtin loaders
 288     // is not yet supported.
 289     set_resolved_references(OopHandle());
 290     return;
 291   }
 292 
 293   objArrayOop rr = resolved_references();
</pre>
<hr />
<pre>
 462       Symbol* s = vfst.method()-&gt;method_holder()-&gt;source_file_name();
 463       if (s != NULL) {
 464         source_file = s-&gt;as_C_string();
 465       }
 466     }
 467   }
 468   if (k != this_cp-&gt;pool_holder()) {
 469     // only print something if the classes are different
 470     if (source_file != NULL) {
 471       log_debug(class, resolve)(&quot;%s %s %s:%d&quot;,
 472                  this_cp-&gt;pool_holder()-&gt;external_name(),
 473                  k-&gt;external_name(), source_file, line_number);
 474     } else {
 475       log_debug(class, resolve)(&quot;%s %s&quot;,
 476                  this_cp-&gt;pool_holder()-&gt;external_name(),
 477                  k-&gt;external_name());
 478     }
 479   }
 480 }
 481 
<span class="line-added"> 482 void check_is_inline_type(Klass* k, TRAPS) {</span>
<span class="line-added"> 483   if (!k-&gt;is_value()) {</span>
<span class="line-added"> 484     THROW(vmSymbols::java_lang_IncompatibleClassChangeError());</span>
<span class="line-added"> 485   }</span>
<span class="line-added"> 486 }</span>
<span class="line-added"> 487 </span>
 488 Klass* ConstantPool::klass_at_impl(const constantPoolHandle&amp; this_cp, int which,
 489                                    bool save_resolution_error, TRAPS) {
 490   assert(THREAD-&gt;is_Java_thread(), &quot;must be a Java thread&quot;);
 491   JavaThread* javaThread = (JavaThread*)THREAD;
 492 
 493   // A resolved constantPool entry will contain a Klass*, otherwise a Symbol*.
 494   // It is not safe to rely on the tag bit&#39;s here, since we don&#39;t have a lock, and
 495   // the entry and tag is not updated atomicly.
 496   CPKlassSlot kslot = this_cp-&gt;klass_slot_at(which);
 497   int resolved_klass_index = kslot.resolved_klass_index();
 498   int name_index = kslot.name_index();
 499   assert(this_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 500 
 501   Klass* klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 502   if (klass != NULL) {
 503     return klass;
 504   }
 505 
 506   // This tag doesn&#39;t change back to unresolved class unless at a safepoint.
 507   if (this_cp-&gt;tag_at(which).is_unresolved_klass_in_error()) {
 508     // The original attempt to resolve this constant pool entry failed so find the
 509     // class of the original error and throw another error of the same class
 510     // (JVMS 5.4.3).
 511     // If there is a detail message, pass that detail message to the error.
 512     // The JVMS does not strictly require us to duplicate the same detail message,
 513     // or any internal exception fields such as cause or stacktrace.  But since the
 514     // detail message is often a class name or other literal string, we will repeat it
 515     // if we can find it in the symbol table.
 516     throw_resolution_error(this_cp, which, CHECK_NULL);
 517     ShouldNotReachHere();
 518   }
 519 
 520   Handle mirror_handle;
 521   Symbol* name = this_cp-&gt;symbol_at(name_index);
<span class="line-added"> 522   bool inline_type_signature = false;</span>
<span class="line-added"> 523   if (name-&gt;is_Q_signature()) {</span>
<span class="line-added"> 524     name = name-&gt;fundamental_name(THREAD);</span>
<span class="line-added"> 525     inline_type_signature = true;</span>
<span class="line-added"> 526   }</span>
 527   Handle loader (THREAD, this_cp-&gt;pool_holder()-&gt;class_loader());
 528   Handle protection_domain (THREAD, this_cp-&gt;pool_holder()-&gt;protection_domain());
 529 
 530   Klass* k;
 531   {
 532     // Turn off the single stepping while doing class resolution
 533     JvmtiHideSingleStepping jhss(javaThread);
 534     k = SystemDictionary::resolve_or_fail(name, loader, protection_domain, true, THREAD);
 535   } //  JvmtiHideSingleStepping jhss(javaThread);
<span class="line-added"> 536   if (inline_type_signature) {</span>
<span class="line-added"> 537     name-&gt;decrement_refcount();</span>
<span class="line-added"> 538   }</span>
 539 
 540   if (!HAS_PENDING_EXCEPTION) {
 541     // preserve the resolved klass from unloading
 542     mirror_handle = Handle(THREAD, k-&gt;java_mirror());
 543     // Do access check for klasses
 544     verify_constant_pool_resolve(this_cp, k, THREAD);
 545   }
 546 
<span class="line-added"> 547   if (!HAS_PENDING_EXCEPTION &amp;&amp; inline_type_signature) {</span>
<span class="line-added"> 548     check_is_inline_type(k, THREAD);</span>
<span class="line-added"> 549   }</span>
<span class="line-added"> 550 </span>
<span class="line-added"> 551   if (!HAS_PENDING_EXCEPTION) {</span>
<span class="line-added"> 552     Klass* bottom_klass = NULL;</span>
<span class="line-added"> 553     if (k-&gt;is_objArray_klass()) {</span>
<span class="line-added"> 554       bottom_klass = ObjArrayKlass::cast(k)-&gt;bottom_klass();</span>
<span class="line-added"> 555       assert(bottom_klass != NULL, &quot;Should be set&quot;);</span>
<span class="line-added"> 556       assert(bottom_klass-&gt;is_instance_klass() || bottom_klass-&gt;is_typeArray_klass(), &quot;Sanity check&quot;);</span>
<span class="line-added"> 557     } else if (k-&gt;is_valueArray_klass()) {</span>
<span class="line-added"> 558       bottom_klass = ValueArrayKlass::cast(k)-&gt;element_klass();</span>
<span class="line-added"> 559       assert(bottom_klass != NULL, &quot;Should be set&quot;);</span>
<span class="line-added"> 560     }</span>
<span class="line-added"> 561   }</span>
<span class="line-added"> 562 </span>
 563   // Failed to resolve class. We must record the errors so that subsequent attempts
 564   // to resolve this constant pool entry fail with the same error (JVMS 5.4.3).
 565   if (HAS_PENDING_EXCEPTION) {
 566     if (save_resolution_error) {
 567       save_and_throw_exception(this_cp, which, constantTag(JVM_CONSTANT_UnresolvedClass), CHECK_NULL);
 568       // If CHECK_NULL above doesn&#39;t return the exception, that means that
 569       // some other thread has beaten us and has resolved the class.
 570       // To preserve old behavior, we return the resolved class.
 571       klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 572       assert(klass != NULL, &quot;must be resolved if exception was cleared&quot;);
 573       return klass;
 574     } else {
 575       return NULL;  // return the pending exception
 576     }
 577   }
 578 
 579   // logging for class+resolve.
 580   if (log_is_enabled(Debug, class, resolve)){
 581     trace_class_resolution(this_cp, k);
 582   }
 583   Klass** adr = this_cp-&gt;resolved_klasses()-&gt;adr_at(resolved_klass_index);
 584   Atomic::release_store(adr, k);
 585   // The interpreter assumes when the tag is stored, the klass is resolved
 586   // and the Klass* stored in _resolved_klasses is non-NULL, so we need
 587   // hardware store ordering here.
<span class="line-modified"> 588   jbyte tag = JVM_CONSTANT_Class;</span>
<span class="line-added"> 589   if (this_cp-&gt;tag_at(which).is_Qdescriptor_klass()) {</span>
<span class="line-added"> 590     tag |= JVM_CONSTANT_QDescBit;</span>
<span class="line-added"> 591   }</span>
<span class="line-added"> 592   this_cp-&gt;release_tag_at_put(which, tag);</span>
 593   return k;
 594 }
 595 
 596 
 597 // Does not update ConstantPool* - to avoid any exception throwing. Used
 598 // by compiler and exception handling.  Also used to avoid classloads for
 599 // instanceof operations. Returns NULL if the class has not been loaded or
 600 // if the verification of constant pool failed
 601 Klass* ConstantPool::klass_at_if_loaded(const constantPoolHandle&amp; this_cp, int which) {
 602   CPKlassSlot kslot = this_cp-&gt;klass_slot_at(which);
 603   int resolved_klass_index = kslot.resolved_klass_index();
 604   int name_index = kslot.name_index();
 605   assert(this_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 606 
 607   Klass* k = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 608   if (k != NULL) {
 609     return k;
 610   } else {
 611     Thread *thread = Thread::current();
 612     Symbol* name = this_cp-&gt;symbol_at(name_index);
</pre>
<hr />
<pre>
1896       case JVM_CONSTANT_Long: {
1897         u8 val = Bytes::get_Java_u8(bytes);
1898         printf(&quot;long         &quot; INT64_FORMAT, (int64_t) *(jlong *) &amp;val);
1899         ent_size = 8;
1900         idx++; // Long takes two cpool slots
1901         break;
1902       }
1903       case JVM_CONSTANT_Double: {
1904         u8 val = Bytes::get_Java_u8(bytes);
1905         printf(&quot;double       %5.3fd&quot;, *(jdouble *)&amp;val);
1906         ent_size = 8;
1907         idx++; // Double takes two cpool slots
1908         break;
1909       }
1910       case JVM_CONSTANT_Class: {
1911         idx1 = Bytes::get_Java_u2(bytes);
1912         printf(&quot;class        #%03d&quot;, idx1);
1913         ent_size = 2;
1914         break;
1915       }
<span class="line-added">1916       case (JVM_CONSTANT_Class | JVM_CONSTANT_QDescBit): {</span>
<span class="line-added">1917         idx1 = Bytes::get_Java_u2(bytes);</span>
<span class="line-added">1918         printf(&quot;qclass        #%03d&quot;, idx1);</span>
<span class="line-added">1919         ent_size = 2;</span>
<span class="line-added">1920         break;</span>
<span class="line-added">1921       }</span>
1922       case JVM_CONSTANT_String: {
1923         idx1 = Bytes::get_Java_u2(bytes);
1924         printf(&quot;String       #%03d&quot;, idx1);
1925         ent_size = 2;
1926         break;
1927       }
1928       case JVM_CONSTANT_Fieldref: {
1929         idx1 = Bytes::get_Java_u2(bytes);
1930         idx2 = Bytes::get_Java_u2(bytes+2);
1931         printf(&quot;Field        #%03d, #%03d&quot;, (int) idx1, (int) idx2);
1932         ent_size = 4;
1933         break;
1934       }
1935       case JVM_CONSTANT_Methodref: {
1936         idx1 = Bytes::get_Java_u2(bytes);
1937         idx2 = Bytes::get_Java_u2(bytes+2);
1938         printf(&quot;Method       #%03d, #%03d&quot;, idx1, idx2);
1939         ent_size = 4;
1940         break;
1941       }
</pre>
<hr />
<pre>
1944         idx2 = Bytes::get_Java_u2(bytes+2);
1945         printf(&quot;InterfMethod #%03d, #%03d&quot;, idx1, idx2);
1946         ent_size = 4;
1947         break;
1948       }
1949       case JVM_CONSTANT_NameAndType: {
1950         idx1 = Bytes::get_Java_u2(bytes);
1951         idx2 = Bytes::get_Java_u2(bytes+2);
1952         printf(&quot;NameAndType  #%03d, #%03d&quot;, idx1, idx2);
1953         ent_size = 4;
1954         break;
1955       }
1956       case JVM_CONSTANT_ClassIndex: {
1957         printf(&quot;ClassIndex  %s&quot;, WARN_MSG);
1958         break;
1959       }
1960       case JVM_CONSTANT_UnresolvedClass: {
1961         printf(&quot;UnresolvedClass: %s&quot;, WARN_MSG);
1962         break;
1963       }
<span class="line-added">1964       case (JVM_CONSTANT_UnresolvedClass | JVM_CONSTANT_QDescBit): {</span>
<span class="line-added">1965         printf(&quot;UnresolvedQClass: %s&quot;, WARN_MSG);</span>
<span class="line-added">1966         break;</span>
<span class="line-added">1967       }</span>
1968       case JVM_CONSTANT_UnresolvedClassInError: {
1969         printf(&quot;UnresolvedClassInErr: %s&quot;, WARN_MSG);
1970         break;
1971       }
1972       case JVM_CONSTANT_StringIndex: {
1973         printf(&quot;StringIndex: %s&quot;, WARN_MSG);
1974         break;
1975       }
1976     }
1977     printf(&quot;;\n&quot;);
1978     bytes += ent_size;
1979     size  += ent_size;
1980   }
1981   printf(&quot;Cpool size: %d\n&quot;, size);
1982   fflush(0);
1983   return;
1984 } /* end print_cpool_bytes */
1985 
1986 
1987 // Returns size of constant pool entry.
</pre>
<hr />
<pre>
2119       case JVM_CONSTANT_Float: {
2120         jfloat val = float_at(idx);
2121         Bytes::put_Java_u4((address) (bytes+1), *(u4*)&amp;val);
2122         break;
2123       }
2124       case JVM_CONSTANT_Long: {
2125         jlong val = long_at(idx);
2126         Bytes::put_Java_u8((address) (bytes+1), *(u8*)&amp;val);
2127         idx++;             // Long takes two cpool slots
2128         break;
2129       }
2130       case JVM_CONSTANT_Double: {
2131         jdouble val = double_at(idx);
2132         Bytes::put_Java_u8((address) (bytes+1), *(u8*)&amp;val);
2133         idx++;             // Double takes two cpool slots
2134         break;
2135       }
2136       case JVM_CONSTANT_Class:
2137       case JVM_CONSTANT_UnresolvedClass:
2138       case JVM_CONSTANT_UnresolvedClassInError: {
<span class="line-added">2139         assert(!tag_at(idx).is_Qdescriptor_klass(), &quot;Failed to encode QDesc&quot;);</span>
2140         *bytes = JVM_CONSTANT_Class;
2141         Symbol* sym = klass_name_at(idx);
2142         idx1 = tbl-&gt;symbol_to_value(sym);
2143         assert(idx1 != 0, &quot;Have not found a hashtable entry&quot;);
2144         Bytes::put_Java_u2((address) (bytes+1), idx1);
2145         DBG(printf(&quot;JVM_CONSTANT_Class: idx=#%03hd, %s&quot;, idx1, sym-&gt;as_utf8()));
2146         break;
2147       }
2148       case JVM_CONSTANT_String: {
2149         *bytes = JVM_CONSTANT_String;
2150         Symbol* sym = unresolved_string_at(idx);
2151         idx1 = tbl-&gt;symbol_to_value(sym);
2152         assert(idx1 != 0, &quot;Have not found a hashtable entry&quot;);
2153         Bytes::put_Java_u2((address) (bytes+1), idx1);
2154         DBG(printf(&quot;JVM_CONSTANT_String: idx=#%03hd, %s&quot;, idx1, sym-&gt;as_utf8()));
2155         break;
2156       }
2157       case JVM_CONSTANT_Fieldref:
2158       case JVM_CONSTANT_Methodref:
2159       case JVM_CONSTANT_InterfaceMethodref: {
</pre>
</td>
</tr>
</table>
<center><a href="../memory/universe.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="cpCache.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
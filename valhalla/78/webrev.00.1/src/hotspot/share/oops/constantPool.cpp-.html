<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/oops/constantPool.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderData.hpp&quot;
  28 #include &quot;classfile/javaClasses.inline.hpp&quot;
  29 #include &quot;classfile/metadataOnStackMark.hpp&quot;
  30 #include &quot;classfile/stringTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;interpreter/bootstrapInfo.hpp&quot;
  34 #include &quot;interpreter/linkResolver.hpp&quot;
  35 #include &quot;logging/log.hpp&quot;
  36 #include &quot;logging/logStream.hpp&quot;
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/heapShared.hpp&quot;
  39 #include &quot;memory/metadataFactory.hpp&quot;
  40 #include &quot;memory/metaspaceClosure.hpp&quot;
  41 #include &quot;memory/metaspaceShared.hpp&quot;
  42 #include &quot;memory/oopFactory.hpp&quot;
  43 #include &quot;memory/resourceArea.hpp&quot;
  44 #include &quot;memory/universe.hpp&quot;
  45 #include &quot;oops/array.hpp&quot;
  46 #include &quot;oops/constantPool.inline.hpp&quot;
  47 #include &quot;oops/cpCache.inline.hpp&quot;
  48 #include &quot;oops/instanceKlass.hpp&quot;
  49 #include &quot;oops/objArrayKlass.hpp&quot;
  50 #include &quot;oops/objArrayOop.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  53 #include &quot;runtime/atomic.hpp&quot;
  54 #include &quot;runtime/handles.inline.hpp&quot;
  55 #include &quot;runtime/init.hpp&quot;
  56 #include &quot;runtime/javaCalls.hpp&quot;
  57 #include &quot;runtime/signature.hpp&quot;
  58 #include &quot;runtime/thread.inline.hpp&quot;
  59 #include &quot;runtime/vframe.inline.hpp&quot;
  60 #include &quot;utilities/copy.hpp&quot;
  61 
  62 ConstantPool* ConstantPool::allocate(ClassLoaderData* loader_data, int length, TRAPS) {
  63   Array&lt;u1&gt;* tags = MetadataFactory::new_array&lt;u1&gt;(loader_data, length, 0, CHECK_NULL);
  64   int size = ConstantPool::size(length);
  65   return new (loader_data, size, MetaspaceObj::ConstantPoolType, THREAD) ConstantPool(tags);
  66 }
  67 
  68 void ConstantPool::copy_fields(const ConstantPool* orig) {
  69   // Preserve dynamic constant information from the original pool
  70   if (orig-&gt;has_dynamic_constant()) {
  71     set_has_dynamic_constant();
  72   }
  73 
  74   // Copy class version
  75   set_major_version(orig-&gt;major_version());
  76   set_minor_version(orig-&gt;minor_version());
  77 
  78   set_source_file_name_index(orig-&gt;source_file_name_index());
  79   set_generic_signature_index(orig-&gt;generic_signature_index());
  80 }
  81 
  82 #ifdef ASSERT
  83 
  84 // MetaspaceObj allocation invariant is calloc equivalent memory
  85 // simple verification of this here (JVM_CONSTANT_Invalid == 0 )
  86 static bool tag_array_is_zero_initialized(Array&lt;u1&gt;* tags) {
  87   assert(tags != NULL, &quot;invariant&quot;);
  88   const int length = tags-&gt;length();
  89   for (int index = 0; index &lt; length; ++index) {
  90     if (JVM_CONSTANT_Invalid != tags-&gt;at(index)) {
  91       return false;
  92     }
  93   }
  94   return true;
  95 }
  96 
  97 #endif
  98 
  99 ConstantPool::ConstantPool(Array&lt;u1&gt;* tags) :
 100   _tags(tags),
 101   _length(tags-&gt;length()) {
 102 
 103     assert(_tags != NULL, &quot;invariant&quot;);
 104     assert(tags-&gt;length() == _length, &quot;invariant&quot;);
 105     assert(tag_array_is_zero_initialized(tags), &quot;invariant&quot;);
 106     assert(0 == flags(), &quot;invariant&quot;);
 107     assert(0 == version(), &quot;invariant&quot;);
 108     assert(NULL == _pool_holder, &quot;invariant&quot;);
 109 }
 110 
 111 void ConstantPool::deallocate_contents(ClassLoaderData* loader_data) {
 112   if (cache() != NULL) {
 113     MetadataFactory::free_metadata(loader_data, cache());
 114     set_cache(NULL);
 115   }
 116 
 117   MetadataFactory::free_array&lt;Klass*&gt;(loader_data, resolved_klasses());
 118   set_resolved_klasses(NULL);
 119 
 120   MetadataFactory::free_array&lt;jushort&gt;(loader_data, operands());
 121   set_operands(NULL);
 122 
 123   release_C_heap_structures();
 124 
 125   // free tag array
 126   MetadataFactory::free_array&lt;u1&gt;(loader_data, tags());
 127   set_tags(NULL);
 128 }
 129 
 130 void ConstantPool::release_C_heap_structures() {
 131   // walk constant pool and decrement symbol reference counts
 132   unreference_symbols();
 133 }
 134 
 135 void ConstantPool::metaspace_pointers_do(MetaspaceClosure* it) {
 136   log_trace(cds)(&quot;Iter(ConstantPool): %p&quot;, this);
 137 
 138   it-&gt;push(&amp;_tags, MetaspaceClosure::_writable);
 139   it-&gt;push(&amp;_cache);
 140   it-&gt;push(&amp;_pool_holder);
 141   it-&gt;push(&amp;_operands);
 142   it-&gt;push(&amp;_resolved_klasses, MetaspaceClosure::_writable);
 143 
 144   for (int i = 0; i &lt; length(); i++) {
 145     // The only MSO&#39;s embedded in the CP entries are Symbols:
 146     //   JVM_CONSTANT_String (normal and pseudo)
 147     //   JVM_CONSTANT_Utf8
 148     constantTag ctag = tag_at(i);
 149     if (ctag.is_string() || ctag.is_utf8()) {
 150       it-&gt;push(symbol_at_addr(i));
 151     }
 152   }
 153 }
 154 
 155 objArrayOop ConstantPool::resolved_references() const {
 156   return (objArrayOop)_cache-&gt;resolved_references();
 157 }
 158 
 159 // Called from outside constant pool resolution where a resolved_reference array
 160 // may not be present.
 161 objArrayOop ConstantPool::resolved_references_or_null() const {
 162   if (_cache == NULL) {
 163     return NULL;
 164   } else {
 165     return (objArrayOop)_cache-&gt;resolved_references();
 166   }
 167 }
 168 
 169 // Create resolved_references array and mapping array for original cp indexes
 170 // The ldc bytecode was rewritten to have the resolved reference array index so need a way
 171 // to map it back for resolving and some unlikely miscellaneous uses.
 172 // The objects created by invokedynamic are appended to this list.
 173 void ConstantPool::initialize_resolved_references(ClassLoaderData* loader_data,
 174                                                   const intStack&amp; reference_map,
 175                                                   int constant_pool_map_length,
 176                                                   TRAPS) {
 177   // Initialized the resolved object cache.
 178   int map_length = reference_map.length();
 179   if (map_length &gt; 0) {
 180     // Only need mapping back to constant pool entries.  The map isn&#39;t used for
 181     // invokedynamic resolved_reference entries.  For invokedynamic entries,
 182     // the constant pool cache index has the mapping back to both the constant
 183     // pool and to the resolved reference index.
 184     if (constant_pool_map_length &gt; 0) {
 185       Array&lt;u2&gt;* om = MetadataFactory::new_array&lt;u2&gt;(loader_data, constant_pool_map_length, CHECK);
 186 
 187       for (int i = 0; i &lt; constant_pool_map_length; i++) {
 188         int x = reference_map.at(i);
 189         assert(x == (int)(jushort) x, &quot;klass index is too big&quot;);
 190         om-&gt;at_put(i, (jushort)x);
 191       }
 192       set_reference_map(om);
 193     }
 194 
 195     // Create Java array for holding resolved strings, methodHandles,
 196     // methodTypes, invokedynamic and invokehandle appendix objects, etc.
 197     objArrayOop stom = oopFactory::new_objArray(SystemDictionary::Object_klass(), map_length, CHECK);
 198     Handle refs_handle (THREAD, (oop)stom);  // must handleize.
 199     set_resolved_references(loader_data-&gt;add_handle(refs_handle));
 200   }
 201 }
 202 
 203 void ConstantPool::allocate_resolved_klasses(ClassLoaderData* loader_data, int num_klasses, TRAPS) {
 204   // A ConstantPool can&#39;t possibly have 0xffff valid class entries,
 205   // because entry #0 must be CONSTANT_Invalid, and each class entry must refer to a UTF8
 206   // entry for the class&#39;s name. So at most we will have 0xfffe class entries.
 207   // This allows us to use 0xffff (ConstantPool::_temp_resolved_klass_index) to indicate
 208   // UnresolvedKlass entries that are temporarily created during class redefinition.
 209   assert(num_klasses &lt; CPKlassSlot::_temp_resolved_klass_index, &quot;sanity&quot;);
 210   assert(resolved_klasses() == NULL, &quot;sanity&quot;);
 211   Array&lt;Klass*&gt;* rk = MetadataFactory::new_array&lt;Klass*&gt;(loader_data, num_klasses, CHECK);
 212   set_resolved_klasses(rk);
 213 }
 214 
 215 void ConstantPool::initialize_unresolved_klasses(ClassLoaderData* loader_data, TRAPS) {
 216   int len = length();
 217   int num_klasses = 0;
 218   for (int i = 1; i &lt;len; i++) {
 219     switch (tag_at(i).value()) {
 220     case JVM_CONSTANT_ClassIndex:
 221       {
 222         const int class_index = klass_index_at(i);
 223         unresolved_klass_at_put(i, class_index, num_klasses++);
 224       }
 225       break;
 226 #ifndef PRODUCT
 227     case JVM_CONSTANT_Class:
 228     case JVM_CONSTANT_UnresolvedClass:
 229     case JVM_CONSTANT_UnresolvedClassInError:
 230       // All of these should have been reverted back to ClassIndex before calling
 231       // this function.
 232       ShouldNotReachHere();
 233 #endif
 234     }
 235   }
 236   allocate_resolved_klasses(loader_data, num_klasses, THREAD);
 237 }
 238 
 239 // Unsafe anonymous class support:
 240 void ConstantPool::klass_at_put(int class_index, int name_index, int resolved_klass_index, Klass* k, Symbol* name) {
 241   assert(is_within_bounds(class_index), &quot;index out of bounds&quot;);
 242   assert(is_within_bounds(name_index), &quot;index out of bounds&quot;);
 243   assert((resolved_klass_index &amp; 0xffff0000) == 0, &quot;must be&quot;);
 244   *int_at_addr(class_index) =
 245     build_int_from_shorts((jushort)resolved_klass_index, (jushort)name_index);
 246 
 247   symbol_at_put(name_index, name);
 248   name-&gt;increment_refcount();
 249   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
 250   Atomic::release_store(adr, k);
 251 
 252   // The interpreter assumes when the tag is stored, the klass is resolved
 253   // and the Klass* non-NULL, so we need hardware store ordering here.
 254   if (k != NULL) {
 255     release_tag_at_put(class_index, JVM_CONSTANT_Class);
 256   } else {
 257     release_tag_at_put(class_index, JVM_CONSTANT_UnresolvedClass);
 258   }
 259 }
 260 
 261 // Unsafe anonymous class support:
 262 void ConstantPool::klass_at_put(int class_index, Klass* k) {
 263   assert(k != NULL, &quot;must be valid klass&quot;);
 264   CPKlassSlot kslot = klass_slot_at(class_index);
 265   int resolved_klass_index = kslot.resolved_klass_index();
 266   Klass** adr = resolved_klasses()-&gt;adr_at(resolved_klass_index);
 267   Atomic::release_store(adr, k);
 268 
 269   // The interpreter assumes when the tag is stored, the klass is resolved
 270   // and the Klass* non-NULL, so we need hardware store ordering here.
 271   release_tag_at_put(class_index, JVM_CONSTANT_Class);
 272 }
 273 
 274 #if INCLUDE_CDS_JAVA_HEAP
 275 // Archive the resolved references
 276 void ConstantPool::archive_resolved_references(Thread* THREAD) {
 277   if (_cache == NULL) {
 278     return; // nothing to do
 279   }
 280 
 281   InstanceKlass *ik = pool_holder();
 282   if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
 283         ik-&gt;is_shared_app_class())) {
 284     // Archiving resolved references for classes from non-builtin loaders
 285     // is not yet supported.
 286     set_resolved_references(OopHandle());
 287     return;
 288   }
 289 
 290   objArrayOop rr = resolved_references();
 291   Array&lt;u2&gt;* ref_map = reference_map();
 292   if (rr != NULL) {
 293     int ref_map_len = ref_map == NULL ? 0 : ref_map-&gt;length();
 294     int rr_len = rr-&gt;length();
 295     for (int i = 0; i &lt; rr_len; i++) {
 296       oop p = rr-&gt;obj_at(i);
 297       rr-&gt;obj_at_put(i, NULL);
 298       if (p != NULL &amp;&amp; i &lt; ref_map_len) {
 299         int index = object_to_cp_index(i);
 300         if (tag_at(index).is_string()) {
 301           oop op = StringTable::create_archived_string(p, THREAD);
 302           // If the String object is not archived (possibly too large),
 303           // NULL is returned. Also set it in the array, so we won&#39;t
 304           // have a &#39;bad&#39; reference in the archived resolved_reference
 305           // array.
 306           rr-&gt;obj_at_put(i, op);
 307         }
 308       }
 309     }
 310 
 311     oop archived = HeapShared::archive_heap_object(rr, THREAD);
 312     // If the resolved references array is not archived (too large),
 313     // the &#39;archived&#39; object is NULL. No need to explicitly check
 314     // the return value of archive_heap_object here. At runtime, the
 315     // resolved references will be created using the normal process
 316     // when there is no archived value.
 317     _cache-&gt;set_archived_references(archived);
 318     set_resolved_references(OopHandle());
 319   }
 320 }
 321 
 322 void ConstantPool::resolve_class_constants(TRAPS) {
 323   assert(DumpSharedSpaces, &quot;used during dump time only&quot;);
 324   // The _cache may be NULL if the _pool_holder klass fails verification
 325   // at dump time due to missing dependencies.
 326   if (cache() == NULL || reference_map() == NULL) {
 327     return; // nothing to do
 328   }
 329 
 330   constantPoolHandle cp(THREAD, this);
 331   for (int index = 1; index &lt; length(); index++) { // Index 0 is unused
 332     if (tag_at(index).is_string() &amp;&amp; !cp-&gt;is_pseudo_string_at(index)) {
 333       int cache_index = cp-&gt;cp_to_object_index(index);
 334       string_at_impl(cp, index, cache_index, CHECK);
 335     }
 336   }
 337 }
 338 #endif
 339 
 340 // CDS support. Create a new resolved_references array.
 341 void ConstantPool::restore_unshareable_info(TRAPS) {
 342   assert(is_constantPool(), &quot;ensure C++ vtable is restored&quot;);
 343   assert(on_stack(), &quot;should always be set for shared constant pools&quot;);
 344   assert(is_shared(), &quot;should always be set for shared constant pools&quot;);
 345   assert(_cache != NULL, &quot;constant pool _cache should not be NULL&quot;);
 346 
 347   // Only create the new resolved references array if it hasn&#39;t been attempted before
 348   if (resolved_references() != NULL) return;
 349 
 350   // restore the C++ vtable from the shared archive
 351   restore_vtable();
 352 
 353   if (SystemDictionary::Object_klass_loaded()) {
 354     ClassLoaderData* loader_data = pool_holder()-&gt;class_loader_data();
 355 #if INCLUDE_CDS_JAVA_HEAP
 356     if (HeapShared::open_archive_heap_region_mapped() &amp;&amp;
 357         _cache-&gt;archived_references() != NULL) {
 358       oop archived = _cache-&gt;archived_references();
 359       // Create handle for the archived resolved reference array object
 360       Handle refs_handle(THREAD, archived);
 361       set_resolved_references(loader_data-&gt;add_handle(refs_handle));
 362     } else
 363 #endif
 364     {
 365       // No mapped archived resolved reference array
 366       // Recreate the object array and add to ClassLoaderData.
 367       int map_length = resolved_reference_length();
 368       if (map_length &gt; 0) {
 369         objArrayOop stom = oopFactory::new_objArray(SystemDictionary::Object_klass(), map_length, CHECK);
 370         Handle refs_handle(THREAD, (oop)stom);  // must handleize.
 371         set_resolved_references(loader_data-&gt;add_handle(refs_handle));
 372       }
 373     }
 374   }
 375 }
 376 
 377 void ConstantPool::remove_unshareable_info() {
 378   // Resolved references are not in the shared archive.
 379   // Save the length for restoration.  It is not necessarily the same length
 380   // as reference_map.length() if invokedynamic is saved. It is needed when
 381   // re-creating the resolved reference array if archived heap data cannot be map
 382   // at runtime.
 383   set_resolved_reference_length(
 384     resolved_references() != NULL ? resolved_references()-&gt;length() : 0);
 385 
 386   // If archiving heap objects is not allowed, clear the resolved references.
 387   // Otherwise, it is cleared after the resolved references array is cached
 388   // (see archive_resolved_references()).
 389   // If DynamicDumpSharedSpaces is enabled, clear the resolved references also
 390   // as java objects are not archived in the top layer.
 391   if (!HeapShared::is_heap_object_archiving_allowed() || DynamicDumpSharedSpaces) {
 392     set_resolved_references(OopHandle());
 393   }
 394 
 395   // Shared ConstantPools are in the RO region, so the _flags cannot be modified.
 396   // The _on_stack flag is used to prevent ConstantPools from deallocation during
 397   // class redefinition. Since shared ConstantPools cannot be deallocated anyway,
 398   // we always set _on_stack to true to avoid having to change _flags during runtime.
 399   _flags |= (_on_stack | _is_shared);
 400   int num_klasses = 0;
 401   for (int index = 1; index &lt; length(); index++) { // Index 0 is unused
 402     if (!DynamicDumpSharedSpaces) {
 403       assert(!tag_at(index).is_unresolved_klass_in_error(), &quot;This must not happen during static dump time&quot;);
 404     } else {
 405       if (tag_at(index).is_unresolved_klass_in_error() ||
 406           tag_at(index).is_method_handle_in_error()    ||
 407           tag_at(index).is_method_type_in_error()      ||
 408           tag_at(index).is_dynamic_constant_in_error()) {
 409         tag_at_put(index, JVM_CONSTANT_UnresolvedClass);
 410       }
 411     }
 412     if (tag_at(index).is_klass()) {
 413       // This class was resolved as a side effect of executing Java code
 414       // during dump time. We need to restore it back to an UnresolvedClass,
 415       // so that the proper class loading and initialization can happen
 416       // at runtime.
 417       bool clear_it = true;
 418       if (pool_holder()-&gt;is_hidden() &amp;&amp; index == pool_holder()-&gt;this_class_index()) {
 419         // All references to a hidden class&#39;s own field/methods are through this
 420         // index. We cannot clear it. See comments in ClassFileParser::fill_instance_klass.
 421         clear_it = false;
 422       }
 423       if (clear_it) {
 424         CPKlassSlot kslot = klass_slot_at(index);
 425         int resolved_klass_index = kslot.resolved_klass_index();
 426         int name_index = kslot.name_index();
 427         assert(tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 428         resolved_klasses()-&gt;at_put(resolved_klass_index, NULL);
 429         tag_at_put(index, JVM_CONSTANT_UnresolvedClass);
 430         assert(klass_name_at(index) == symbol_at(name_index), &quot;sanity&quot;);
 431       }
 432     }
 433   }
 434   if (cache() != NULL) {
 435     cache()-&gt;remove_unshareable_info();
 436   }
 437 }
 438 
 439 int ConstantPool::cp_to_object_index(int cp_index) {
 440   // this is harder don&#39;t do this so much.
 441   int i = reference_map()-&gt;find(cp_index);
 442   // We might not find the index for jsr292 call.
 443   return (i &lt; 0) ? _no_index_sentinel : i;
 444 }
 445 
 446 void ConstantPool::string_at_put(int which, int obj_index, oop str) {
 447   resolved_references()-&gt;obj_at_put(obj_index, str);
 448 }
 449 
 450 void ConstantPool::trace_class_resolution(const constantPoolHandle&amp; this_cp, Klass* k) {
 451   ResourceMark rm;
 452   int line_number = -1;
 453   const char * source_file = NULL;
 454   if (JavaThread::current()-&gt;has_last_Java_frame()) {
 455     // try to identify the method which called this function.
 456     vframeStream vfst(JavaThread::current());
 457     if (!vfst.at_end()) {
 458       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
 459       Symbol* s = vfst.method()-&gt;method_holder()-&gt;source_file_name();
 460       if (s != NULL) {
 461         source_file = s-&gt;as_C_string();
 462       }
 463     }
 464   }
 465   if (k != this_cp-&gt;pool_holder()) {
 466     // only print something if the classes are different
 467     if (source_file != NULL) {
 468       log_debug(class, resolve)(&quot;%s %s %s:%d&quot;,
 469                  this_cp-&gt;pool_holder()-&gt;external_name(),
 470                  k-&gt;external_name(), source_file, line_number);
 471     } else {
 472       log_debug(class, resolve)(&quot;%s %s&quot;,
 473                  this_cp-&gt;pool_holder()-&gt;external_name(),
 474                  k-&gt;external_name());
 475     }
 476   }
 477 }
 478 
 479 Klass* ConstantPool::klass_at_impl(const constantPoolHandle&amp; this_cp, int which,
 480                                    bool save_resolution_error, TRAPS) {
 481   assert(THREAD-&gt;is_Java_thread(), &quot;must be a Java thread&quot;);
 482   JavaThread* javaThread = (JavaThread*)THREAD;
 483 
 484   // A resolved constantPool entry will contain a Klass*, otherwise a Symbol*.
 485   // It is not safe to rely on the tag bit&#39;s here, since we don&#39;t have a lock, and
 486   // the entry and tag is not updated atomicly.
 487   CPKlassSlot kslot = this_cp-&gt;klass_slot_at(which);
 488   int resolved_klass_index = kslot.resolved_klass_index();
 489   int name_index = kslot.name_index();
 490   assert(this_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 491 
 492   Klass* klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 493   if (klass != NULL) {
 494     return klass;
 495   }
 496 
 497   // This tag doesn&#39;t change back to unresolved class unless at a safepoint.
 498   if (this_cp-&gt;tag_at(which).is_unresolved_klass_in_error()) {
 499     // The original attempt to resolve this constant pool entry failed so find the
 500     // class of the original error and throw another error of the same class
 501     // (JVMS 5.4.3).
 502     // If there is a detail message, pass that detail message to the error.
 503     // The JVMS does not strictly require us to duplicate the same detail message,
 504     // or any internal exception fields such as cause or stacktrace.  But since the
 505     // detail message is often a class name or other literal string, we will repeat it
 506     // if we can find it in the symbol table.
 507     throw_resolution_error(this_cp, which, CHECK_NULL);
 508     ShouldNotReachHere();
 509   }
 510 
 511   Handle mirror_handle;
 512   Symbol* name = this_cp-&gt;symbol_at(name_index);
 513   Handle loader (THREAD, this_cp-&gt;pool_holder()-&gt;class_loader());
 514   Handle protection_domain (THREAD, this_cp-&gt;pool_holder()-&gt;protection_domain());
 515 
 516   Klass* k;
 517   {
 518     // Turn off the single stepping while doing class resolution
 519     JvmtiHideSingleStepping jhss(javaThread);
 520     k = SystemDictionary::resolve_or_fail(name, loader, protection_domain, true, THREAD);
 521   } //  JvmtiHideSingleStepping jhss(javaThread);
 522 
 523   if (!HAS_PENDING_EXCEPTION) {
 524     // preserve the resolved klass from unloading
 525     mirror_handle = Handle(THREAD, k-&gt;java_mirror());
 526     // Do access check for klasses
 527     verify_constant_pool_resolve(this_cp, k, THREAD);
 528   }
 529 
 530   // Failed to resolve class. We must record the errors so that subsequent attempts
 531   // to resolve this constant pool entry fail with the same error (JVMS 5.4.3).
 532   if (HAS_PENDING_EXCEPTION) {
 533     if (save_resolution_error) {
 534       save_and_throw_exception(this_cp, which, constantTag(JVM_CONSTANT_UnresolvedClass), CHECK_NULL);
 535       // If CHECK_NULL above doesn&#39;t return the exception, that means that
 536       // some other thread has beaten us and has resolved the class.
 537       // To preserve old behavior, we return the resolved class.
 538       klass = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 539       assert(klass != NULL, &quot;must be resolved if exception was cleared&quot;);
 540       return klass;
 541     } else {
 542       return NULL;  // return the pending exception
 543     }
 544   }
 545 
 546   // logging for class+resolve.
 547   if (log_is_enabled(Debug, class, resolve)){
 548     trace_class_resolution(this_cp, k);
 549   }
 550   Klass** adr = this_cp-&gt;resolved_klasses()-&gt;adr_at(resolved_klass_index);
 551   Atomic::release_store(adr, k);
 552   // The interpreter assumes when the tag is stored, the klass is resolved
 553   // and the Klass* stored in _resolved_klasses is non-NULL, so we need
 554   // hardware store ordering here.
 555   this_cp-&gt;release_tag_at_put(which, JVM_CONSTANT_Class);
 556   return k;
 557 }
 558 
 559 
 560 // Does not update ConstantPool* - to avoid any exception throwing. Used
 561 // by compiler and exception handling.  Also used to avoid classloads for
 562 // instanceof operations. Returns NULL if the class has not been loaded or
 563 // if the verification of constant pool failed
 564 Klass* ConstantPool::klass_at_if_loaded(const constantPoolHandle&amp; this_cp, int which) {
 565   CPKlassSlot kslot = this_cp-&gt;klass_slot_at(which);
 566   int resolved_klass_index = kslot.resolved_klass_index();
 567   int name_index = kslot.name_index();
 568   assert(this_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
 569 
 570   Klass* k = this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index);
 571   if (k != NULL) {
 572     return k;
 573   } else {
 574     Thread *thread = Thread::current();
 575     Symbol* name = this_cp-&gt;symbol_at(name_index);
 576     oop loader = this_cp-&gt;pool_holder()-&gt;class_loader();
 577     oop protection_domain = this_cp-&gt;pool_holder()-&gt;protection_domain();
 578     Handle h_prot (thread, protection_domain);
 579     Handle h_loader (thread, loader);
 580     Klass* k = SystemDictionary::find(name, h_loader, h_prot, thread);
 581 
 582     // Avoid constant pool verification at a safepoint, which takes the Module_lock.
 583     if (k != NULL &amp;&amp; !SafepointSynchronize::is_at_safepoint()) {
 584       // Make sure that resolving is legal
 585       EXCEPTION_MARK;
 586       // return NULL if verification fails
 587       verify_constant_pool_resolve(this_cp, k, THREAD);
 588       if (HAS_PENDING_EXCEPTION) {
 589         CLEAR_PENDING_EXCEPTION;
 590         return NULL;
 591       }
 592       return k;
 593     } else {
 594       return k;
 595     }
 596   }
 597 }
 598 
 599 Method* ConstantPool::method_at_if_loaded(const constantPoolHandle&amp; cpool,
 600                                                    int which) {
 601   if (cpool-&gt;cache() == NULL)  return NULL;  // nothing to load yet
 602   int cache_index = decode_cpcache_index(which, true);
 603   if (!(cache_index &gt;= 0 &amp;&amp; cache_index &lt; cpool-&gt;cache()-&gt;length())) {
 604     // FIXME: should be an assert
 605     log_debug(class, resolve)(&quot;bad operand %d in:&quot;, which); cpool-&gt;print();
 606     return NULL;
 607   }
 608   ConstantPoolCacheEntry* e = cpool-&gt;cache()-&gt;entry_at(cache_index);
 609   return e-&gt;method_if_resolved(cpool);
 610 }
 611 
 612 
 613 bool ConstantPool::has_appendix_at_if_loaded(const constantPoolHandle&amp; cpool, int which) {
 614   if (cpool-&gt;cache() == NULL)  return false;  // nothing to load yet
 615   int cache_index = decode_cpcache_index(which, true);
 616   ConstantPoolCacheEntry* e = cpool-&gt;cache()-&gt;entry_at(cache_index);
 617   return e-&gt;has_appendix();
 618 }
 619 
 620 oop ConstantPool::appendix_at_if_loaded(const constantPoolHandle&amp; cpool, int which) {
 621   if (cpool-&gt;cache() == NULL)  return NULL;  // nothing to load yet
 622   int cache_index = decode_cpcache_index(which, true);
 623   ConstantPoolCacheEntry* e = cpool-&gt;cache()-&gt;entry_at(cache_index);
 624   return e-&gt;appendix_if_resolved(cpool);
 625 }
 626 
 627 
 628 bool ConstantPool::has_local_signature_at_if_loaded(const constantPoolHandle&amp; cpool, int which) {
 629   if (cpool-&gt;cache() == NULL)  return false;  // nothing to load yet
 630   int cache_index = decode_cpcache_index(which, true);
 631   ConstantPoolCacheEntry* e = cpool-&gt;cache()-&gt;entry_at(cache_index);
 632   return e-&gt;has_local_signature();
 633 }
 634 
 635 Symbol* ConstantPool::impl_name_ref_at(int which, bool uncached) {
 636   int name_index = name_ref_index_at(impl_name_and_type_ref_index_at(which, uncached));
 637   return symbol_at(name_index);
 638 }
 639 
 640 
 641 Symbol* ConstantPool::impl_signature_ref_at(int which, bool uncached) {
 642   int signature_index = signature_ref_index_at(impl_name_and_type_ref_index_at(which, uncached));
 643   return symbol_at(signature_index);
 644 }
 645 
 646 int ConstantPool::impl_name_and_type_ref_index_at(int which, bool uncached) {
 647   int i = which;
 648   if (!uncached &amp;&amp; cache() != NULL) {
 649     if (ConstantPool::is_invokedynamic_index(which)) {
 650       // Invokedynamic index is index into the constant pool cache
 651       int pool_index = invokedynamic_bootstrap_ref_index_at(which);
 652       pool_index = bootstrap_name_and_type_ref_index_at(pool_index);
 653       assert(tag_at(pool_index).is_name_and_type(), &quot;&quot;);
 654       return pool_index;
 655     }
 656     // change byte-ordering and go via cache
 657     i = remap_instruction_operand_from_cache(which);
 658   } else {
 659     if (tag_at(which).has_bootstrap()) {
 660       int pool_index = bootstrap_name_and_type_ref_index_at(which);
 661       assert(tag_at(pool_index).is_name_and_type(), &quot;&quot;);
 662       return pool_index;
 663     }
 664   }
 665   assert(tag_at(i).is_field_or_method(), &quot;Corrupted constant pool&quot;);
 666   assert(!tag_at(i).has_bootstrap(), &quot;Must be handled above&quot;);
 667   jint ref_index = *int_at_addr(i);
 668   return extract_high_short_from_int(ref_index);
 669 }
 670 
 671 constantTag ConstantPool::impl_tag_ref_at(int which, bool uncached) {
 672   int pool_index = which;
 673   if (!uncached &amp;&amp; cache() != NULL) {
 674     if (ConstantPool::is_invokedynamic_index(which)) {
 675       // Invokedynamic index is index into resolved_references
 676       pool_index = invokedynamic_bootstrap_ref_index_at(which);
 677     } else {
 678       // change byte-ordering and go via cache
 679       pool_index = remap_instruction_operand_from_cache(which);
 680     }
 681   }
 682   return tag_at(pool_index);
 683 }
 684 
 685 int ConstantPool::impl_klass_ref_index_at(int which, bool uncached) {
 686   guarantee(!ConstantPool::is_invokedynamic_index(which),
 687             &quot;an invokedynamic instruction does not have a klass&quot;);
 688   int i = which;
 689   if (!uncached &amp;&amp; cache() != NULL) {
 690     // change byte-ordering and go via cache
 691     i = remap_instruction_operand_from_cache(which);
 692   }
 693   assert(tag_at(i).is_field_or_method(), &quot;Corrupted constant pool&quot;);
 694   jint ref_index = *int_at_addr(i);
 695   return extract_low_short_from_int(ref_index);
 696 }
 697 
 698 
 699 
 700 int ConstantPool::remap_instruction_operand_from_cache(int operand) {
 701   int cpc_index = operand;
 702   DEBUG_ONLY(cpc_index -= CPCACHE_INDEX_TAG);
 703   assert((int)(u2)cpc_index == cpc_index, &quot;clean u2&quot;);
 704   int member_index = cache()-&gt;entry_at(cpc_index)-&gt;constant_pool_index();
 705   return member_index;
 706 }
 707 
 708 
 709 void ConstantPool::verify_constant_pool_resolve(const constantPoolHandle&amp; this_cp, Klass* k, TRAPS) {
 710   if (!(k-&gt;is_instance_klass() || k-&gt;is_objArray_klass())) {
 711     return;  // short cut, typeArray klass is always accessible
 712   }
 713   Klass* holder = this_cp-&gt;pool_holder();
 714   LinkResolver::check_klass_accessibility(holder, k, CHECK);
 715 }
 716 
 717 
 718 int ConstantPool::name_ref_index_at(int which_nt) {
 719   jint ref_index = name_and_type_at(which_nt);
 720   return extract_low_short_from_int(ref_index);
 721 }
 722 
 723 
 724 int ConstantPool::signature_ref_index_at(int which_nt) {
 725   jint ref_index = name_and_type_at(which_nt);
 726   return extract_high_short_from_int(ref_index);
 727 }
 728 
 729 
 730 Klass* ConstantPool::klass_ref_at(int which, TRAPS) {
 731   return klass_at(klass_ref_index_at(which), THREAD);
 732 }
 733 
 734 Symbol* ConstantPool::klass_name_at(int which) const {
 735   return symbol_at(klass_slot_at(which).name_index());
 736 }
 737 
 738 Symbol* ConstantPool::klass_ref_at_noresolve(int which) {
 739   jint ref_index = klass_ref_index_at(which);
 740   return klass_at_noresolve(ref_index);
 741 }
 742 
 743 Symbol* ConstantPool::uncached_klass_ref_at_noresolve(int which) {
 744   jint ref_index = uncached_klass_ref_index_at(which);
 745   return klass_at_noresolve(ref_index);
 746 }
 747 
 748 char* ConstantPool::string_at_noresolve(int which) {
 749   return unresolved_string_at(which)-&gt;as_C_string();
 750 }
 751 
 752 BasicType ConstantPool::basic_type_for_signature_at(int which) const {
 753   return Signature::basic_type(symbol_at(which));
 754 }
 755 
 756 
 757 void ConstantPool::resolve_string_constants_impl(const constantPoolHandle&amp; this_cp, TRAPS) {
 758   for (int index = 1; index &lt; this_cp-&gt;length(); index++) { // Index 0 is unused
 759     if (this_cp-&gt;tag_at(index).is_string()) {
 760       this_cp-&gt;string_at(index, CHECK);
 761     }
 762   }
 763 }
 764 
 765 Symbol* ConstantPool::exception_message(const constantPoolHandle&amp; this_cp, int which, constantTag tag, oop pending_exception) {
 766   // Dig out the detailed message to reuse if possible
 767   Symbol* message = java_lang_Throwable::detail_message(pending_exception);
 768   if (message != NULL) {
 769     return message;
 770   }
 771 
 772   // Return specific message for the tag
 773   switch (tag.value()) {
 774   case JVM_CONSTANT_UnresolvedClass:
 775     // return the class name in the error message
 776     message = this_cp-&gt;klass_name_at(which);
 777     break;
 778   case JVM_CONSTANT_MethodHandle:
 779     // return the method handle name in the error message
 780     message = this_cp-&gt;method_handle_name_ref_at(which);
 781     break;
 782   case JVM_CONSTANT_MethodType:
 783     // return the method type signature in the error message
 784     message = this_cp-&gt;method_type_signature_at(which);
 785     break;
 786   case JVM_CONSTANT_Dynamic:
 787     // return the name of the condy in the error message
 788     message = this_cp-&gt;uncached_name_ref_at(which);
 789     break;
 790   default:
 791     ShouldNotReachHere();
 792   }
 793 
 794   return message;
 795 }
 796 
 797 void ConstantPool::throw_resolution_error(const constantPoolHandle&amp; this_cp, int which, TRAPS) {
 798   Symbol* message = NULL;
 799   Symbol* error = SystemDictionary::find_resolution_error(this_cp, which, &amp;message);
 800   assert(error != NULL, &quot;checking&quot;);
 801   CLEAR_PENDING_EXCEPTION;
 802   if (message != NULL) {
 803     ResourceMark rm;
 804     THROW_MSG(error, message-&gt;as_C_string());
 805   } else {
 806     THROW(error);
 807   }
 808 }
 809 
 810 // If resolution for Class, Dynamic constant, MethodHandle or MethodType fails, save the
 811 // exception in the resolution error table, so that the same exception is thrown again.
 812 void ConstantPool::save_and_throw_exception(const constantPoolHandle&amp; this_cp, int which,
 813                                             constantTag tag, TRAPS) {
 814   Symbol* error = PENDING_EXCEPTION-&gt;klass()-&gt;name();
 815 
 816   int error_tag = tag.error_value();
 817 
 818   if (!PENDING_EXCEPTION-&gt;
 819     is_a(SystemDictionary::LinkageError_klass())) {
 820     // Just throw the exception and don&#39;t prevent these classes from
 821     // being loaded due to virtual machine errors like StackOverflow
 822     // and OutOfMemoryError, etc, or if the thread was hit by stop()
 823     // Needs clarification to section 5.4.3 of the VM spec (see 6308271)
 824   } else if (this_cp-&gt;tag_at(which).value() != error_tag) {
 825     Symbol* message = exception_message(this_cp, which, tag, PENDING_EXCEPTION);
 826     SystemDictionary::add_resolution_error(this_cp, which, error, message);
 827     // CAS in the tag.  If a thread beat us to registering this error that&#39;s fine.
 828     // If another thread resolved the reference, this is a race condition. This
 829     // thread may have had a security manager or something temporary.
 830     // This doesn&#39;t deterministically get an error.   So why do we save this?
 831     // We save this because jvmti can add classes to the bootclass path after
 832     // this error, so it needs to get the same error if the error is first.
 833     jbyte old_tag = Atomic::cmpxchg((jbyte*)this_cp-&gt;tag_addr_at(which),
 834                                     (jbyte)tag.value(),
 835                                     (jbyte)error_tag);
 836     if (old_tag != error_tag &amp;&amp; old_tag != tag.value()) {
 837       // MethodHandles and MethodType doesn&#39;t change to resolved version.
 838       assert(this_cp-&gt;tag_at(which).is_klass(), &quot;Wrong tag value&quot;);
 839       // Forget the exception and use the resolved class.
 840       CLEAR_PENDING_EXCEPTION;
 841     }
 842   } else {
 843     // some other thread put this in error state
 844     throw_resolution_error(this_cp, which, CHECK);
 845   }
 846 }
 847 
 848 constantTag ConstantPool::constant_tag_at(int which) {
 849   constantTag tag = tag_at(which);
 850   if (tag.is_dynamic_constant() ||
 851       tag.is_dynamic_constant_in_error()) {
 852     BasicType bt = basic_type_for_constant_at(which);
 853     // dynamic constant could return an array, treat as object
 854     return constantTag::ofBasicType(is_reference_type(bt) ? T_OBJECT : bt);
 855   }
 856   return tag;
 857 }
 858 
 859 BasicType ConstantPool::basic_type_for_constant_at(int which) {
 860   constantTag tag = tag_at(which);
 861   if (tag.is_dynamic_constant() ||
 862       tag.is_dynamic_constant_in_error()) {
 863     // have to look at the signature for this one
 864     Symbol* constant_type = uncached_signature_ref_at(which);
 865     return Signature::basic_type(constant_type);
 866   }
 867   return tag.basic_type();
 868 }
 869 
 870 // Called to resolve constants in the constant pool and return an oop.
 871 // Some constant pool entries cache their resolved oop. This is also
 872 // called to create oops from constants to use in arguments for invokedynamic
 873 oop ConstantPool::resolve_constant_at_impl(const constantPoolHandle&amp; this_cp,
 874                                            int index, int cache_index,
 875                                            bool* status_return, TRAPS) {
 876   oop result_oop = NULL;
 877   Handle throw_exception;
 878 
 879   if (cache_index == _possible_index_sentinel) {
 880     // It is possible that this constant is one which is cached in the objects.
 881     // We&#39;ll do a linear search.  This should be OK because this usage is rare.
 882     // FIXME: If bootstrap specifiers stress this code, consider putting in
 883     // a reverse index.  Binary search over a short array should do it.
 884     assert(index &gt; 0, &quot;valid index&quot;);
 885     cache_index = this_cp-&gt;cp_to_object_index(index);
 886   }
 887   assert(cache_index == _no_index_sentinel || cache_index &gt;= 0, &quot;&quot;);
 888   assert(index == _no_index_sentinel || index &gt;= 0, &quot;&quot;);
 889 
 890   if (cache_index &gt;= 0) {
 891     result_oop = this_cp-&gt;resolved_references()-&gt;obj_at(cache_index);
 892     if (result_oop != NULL) {
 893       if (result_oop == Universe::the_null_sentinel()) {
 894         DEBUG_ONLY(int temp_index = (index &gt;= 0 ? index : this_cp-&gt;object_to_cp_index(cache_index)));
 895         assert(this_cp-&gt;tag_at(temp_index).is_dynamic_constant(), &quot;only condy uses the null sentinel&quot;);
 896         result_oop = NULL;
 897       }
 898       if (status_return != NULL)  (*status_return) = true;
 899       return result_oop;
 900       // That was easy...
 901     }
 902     index = this_cp-&gt;object_to_cp_index(cache_index);
 903   }
 904 
 905   jvalue prim_value;  // temp used only in a few cases below
 906 
 907   constantTag tag = this_cp-&gt;tag_at(index);
 908 
 909   if (status_return != NULL) {
 910     // don&#39;t trigger resolution if the constant might need it
 911     switch (tag.value()) {
 912     case JVM_CONSTANT_Class:
 913     {
 914       CPKlassSlot kslot = this_cp-&gt;klass_slot_at(index);
 915       int resolved_klass_index = kslot.resolved_klass_index();
 916       if (this_cp-&gt;resolved_klasses()-&gt;at(resolved_klass_index) == NULL) {
 917         (*status_return) = false;
 918         return NULL;
 919       }
 920       // the klass is waiting in the CP; go get it
 921       break;
 922     }
 923     case JVM_CONSTANT_String:
 924     case JVM_CONSTANT_Integer:
 925     case JVM_CONSTANT_Float:
 926     case JVM_CONSTANT_Long:
 927     case JVM_CONSTANT_Double:
 928       // these guys trigger OOM at worst
 929       break;
 930     default:
 931       (*status_return) = false;
 932       return NULL;
 933     }
 934     // from now on there is either success or an OOME
 935     (*status_return) = true;
 936   }
 937 
 938   switch (tag.value()) {
 939 
 940   case JVM_CONSTANT_UnresolvedClass:
 941   case JVM_CONSTANT_UnresolvedClassInError:
 942   case JVM_CONSTANT_Class:
 943     {
 944       assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
 945       Klass* resolved = klass_at_impl(this_cp, index, true, CHECK_NULL);
 946       // ldc wants the java mirror.
 947       result_oop = resolved-&gt;java_mirror();
 948       break;
 949     }
 950 
 951   case JVM_CONSTANT_Dynamic:
 952     {
 953       // Resolve the Dynamically-Computed constant to invoke the BSM in order to obtain the resulting oop.
 954       BootstrapInfo bootstrap_specifier(this_cp, index);
 955 
 956       // The initial step in resolving an unresolved symbolic reference to a
 957       // dynamically-computed constant is to resolve the symbolic reference to a
 958       // method handle which will be the bootstrap method for the dynamically-computed
 959       // constant. If resolution of the java.lang.invoke.MethodHandle for the bootstrap
 960       // method fails, then a MethodHandleInError is stored at the corresponding
 961       // bootstrap method&#39;s CP index for the CONSTANT_MethodHandle_info. No need to
 962       // set a DynamicConstantInError here since any subsequent use of this
 963       // bootstrap method will encounter the resolution of MethodHandleInError.
 964       // Both the first, (resolution of the BSM and its static arguments), and the second tasks,
 965       // (invocation of the BSM), of JVMS Section 5.4.3.6 occur within invoke_bootstrap_method()
 966       // for the bootstrap_specifier created above.
 967       SystemDictionary::invoke_bootstrap_method(bootstrap_specifier, THREAD);
 968       Exceptions::wrap_dynamic_exception(/* is_indy */ false, THREAD);
 969       if (HAS_PENDING_EXCEPTION) {
 970         // Resolution failure of the dynamically-computed constant, save_and_throw_exception
 971         // will check for a LinkageError and store a DynamicConstantInError.
 972         save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
 973       }
 974       result_oop = bootstrap_specifier.resolved_value()();
 975       BasicType type = Signature::basic_type(bootstrap_specifier.signature());
 976       if (!is_reference_type(type)) {
 977         // Make sure the primitive value is properly boxed.
 978         // This is a JDK responsibility.
 979         const char* fail = NULL;
 980         if (result_oop == NULL) {
 981           fail = &quot;null result instead of box&quot;;
 982         } else if (!is_java_primitive(type)) {
 983           // FIXME: support value types via unboxing
 984           fail = &quot;can only handle references and primitives&quot;;
 985         } else if (!java_lang_boxing_object::is_instance(result_oop, type)) {
 986           fail = &quot;primitive is not properly boxed&quot;;
 987         }
 988         if (fail != NULL) {
 989           // Since this exception is not a LinkageError, throw exception
 990           // but do not save a DynamicInError resolution result.
 991           // See section 5.4.3 of the VM spec.
 992           THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), fail);
 993         }
 994       }
 995 
 996       LogTarget(Debug, methodhandles, condy) lt_condy;
 997       if (lt_condy.is_enabled()) {
 998         LogStream ls(lt_condy);
 999         bootstrap_specifier.print_msg_on(&amp;ls, &quot;resolve_constant_at_impl&quot;);
1000       }
1001       break;
1002     }
1003 
1004   case JVM_CONSTANT_String:
1005     assert(cache_index != _no_index_sentinel, &quot;should have been set&quot;);
1006     if (this_cp-&gt;is_pseudo_string_at(index)) {
1007       result_oop = this_cp-&gt;pseudo_string_at(index, cache_index);
1008       break;
1009     }
1010     result_oop = string_at_impl(this_cp, index, cache_index, CHECK_NULL);
1011     break;
1012 
1013   case JVM_CONSTANT_DynamicInError:
1014   case JVM_CONSTANT_MethodHandleInError:
1015   case JVM_CONSTANT_MethodTypeInError:
1016     {
1017       throw_resolution_error(this_cp, index, CHECK_NULL);
1018       break;
1019     }
1020 
1021   case JVM_CONSTANT_MethodHandle:
1022     {
1023       int ref_kind                 = this_cp-&gt;method_handle_ref_kind_at(index);
1024       int callee_index             = this_cp-&gt;method_handle_klass_index_at(index);
1025       Symbol*  name =      this_cp-&gt;method_handle_name_ref_at(index);
1026       Symbol*  signature = this_cp-&gt;method_handle_signature_ref_at(index);
1027       constantTag m_tag  = this_cp-&gt;tag_at(this_cp-&gt;method_handle_index_at(index));
1028       { ResourceMark rm(THREAD);
1029         log_debug(class, resolve)(&quot;resolve JVM_CONSTANT_MethodHandle:%d [%d/%d/%d] %s.%s&quot;,
1030                               ref_kind, index, this_cp-&gt;method_handle_index_at(index),
1031                               callee_index, name-&gt;as_C_string(), signature-&gt;as_C_string());
1032       }
1033 
1034       Klass* callee = klass_at_impl(this_cp, callee_index, true, CHECK_NULL);
1035 
1036       // Check constant pool method consistency
1037       if ((callee-&gt;is_interface() &amp;&amp; m_tag.is_method()) ||
1038           ((!callee-&gt;is_interface() &amp;&amp; m_tag.is_interface_method()))) {
1039         ResourceMark rm(THREAD);
1040         stringStream ss;
1041         ss.print(&quot;Inconsistent constant pool data in classfile for class %s. &quot;
1042                  &quot;Method &#39;&quot;, callee-&gt;name()-&gt;as_C_string());
1043         signature-&gt;print_as_signature_external_return_type(&amp;ss);
1044         ss.print(&quot; %s(&quot;, name-&gt;as_C_string());
1045         signature-&gt;print_as_signature_external_parameters(&amp;ss);
1046         ss.print(&quot;)&#39; at index %d is %s and should be %s&quot;,
1047                  index,
1048                  callee-&gt;is_interface() ? &quot;CONSTANT_MethodRef&quot; : &quot;CONSTANT_InterfaceMethodRef&quot;,
1049                  callee-&gt;is_interface() ? &quot;CONSTANT_InterfaceMethodRef&quot; : &quot;CONSTANT_MethodRef&quot;);
1050         THROW_MSG_NULL(vmSymbols::java_lang_IncompatibleClassChangeError(), ss.as_string());
1051       }
1052 
1053       Klass* klass = this_cp-&gt;pool_holder();
1054       Handle value = SystemDictionary::link_method_handle_constant(klass, ref_kind,
1055                                                                    callee, name, signature,
1056                                                                    THREAD);
1057       result_oop = value();
1058       if (HAS_PENDING_EXCEPTION) {
1059         save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
1060       }
1061       break;
1062     }
1063 
1064   case JVM_CONSTANT_MethodType:
1065     {
1066       Symbol*  signature = this_cp-&gt;method_type_signature_at(index);
1067       { ResourceMark rm(THREAD);
1068         log_debug(class, resolve)(&quot;resolve JVM_CONSTANT_MethodType [%d/%d] %s&quot;,
1069                               index, this_cp-&gt;method_type_index_at(index),
1070                               signature-&gt;as_C_string());
1071       }
1072       Klass* klass = this_cp-&gt;pool_holder();
1073       Handle value = SystemDictionary::find_method_handle_type(signature, klass, THREAD);
1074       result_oop = value();
1075       if (HAS_PENDING_EXCEPTION) {
1076         save_and_throw_exception(this_cp, index, tag, CHECK_NULL);
1077       }
1078       break;
1079     }
1080 
1081   case JVM_CONSTANT_Integer:
1082     assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
1083     prim_value.i = this_cp-&gt;int_at(index);
1084     result_oop = java_lang_boxing_object::create(T_INT, &amp;prim_value, CHECK_NULL);
1085     break;
1086 
1087   case JVM_CONSTANT_Float:
1088     assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
1089     prim_value.f = this_cp-&gt;float_at(index);
1090     result_oop = java_lang_boxing_object::create(T_FLOAT, &amp;prim_value, CHECK_NULL);
1091     break;
1092 
1093   case JVM_CONSTANT_Long:
1094     assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
1095     prim_value.j = this_cp-&gt;long_at(index);
1096     result_oop = java_lang_boxing_object::create(T_LONG, &amp;prim_value, CHECK_NULL);
1097     break;
1098 
1099   case JVM_CONSTANT_Double:
1100     assert(cache_index == _no_index_sentinel, &quot;should not have been set&quot;);
1101     prim_value.d = this_cp-&gt;double_at(index);
1102     result_oop = java_lang_boxing_object::create(T_DOUBLE, &amp;prim_value, CHECK_NULL);
1103     break;
1104 
1105   default:
1106     DEBUG_ONLY( tty-&gt;print_cr(&quot;*** %p: tag at CP[%d/%d] = %d&quot;,
1107                               this_cp(), index, cache_index, tag.value()));
1108     assert(false, &quot;unexpected constant tag&quot;);
1109     break;
1110   }
1111 
1112   if (cache_index &gt;= 0) {
1113     // Benign race condition:  resolved_references may already be filled in.
1114     // The important thing here is that all threads pick up the same result.
1115     // It doesn&#39;t matter which racing thread wins, as long as only one
1116     // result is used by all threads, and all future queries.
1117     oop new_result = (result_oop == NULL ? Universe::the_null_sentinel() : result_oop);
1118     oop old_result = this_cp-&gt;resolved_references()
1119       -&gt;atomic_compare_exchange_oop(cache_index, new_result, NULL);
1120     if (old_result == NULL) {
1121       return result_oop;  // was installed
1122     } else {
1123       // Return the winning thread&#39;s result.  This can be different than
1124       // the result here for MethodHandles.
1125       if (old_result == Universe::the_null_sentinel())
1126         old_result = NULL;
1127       return old_result;
1128     }
1129   } else {
1130     assert(result_oop != Universe::the_null_sentinel(), &quot;&quot;);
1131     return result_oop;
1132   }
1133 }
1134 
1135 oop ConstantPool::uncached_string_at(int which, TRAPS) {
1136   Symbol* sym = unresolved_string_at(which);
1137   oop str = StringTable::intern(sym, CHECK_(NULL));
1138   assert(java_lang_String::is_instance(str), &quot;must be string&quot;);
1139   return str;
1140 }
1141 
1142 void ConstantPool::copy_bootstrap_arguments_at_impl(const constantPoolHandle&amp; this_cp, int index,
1143                                                     int start_arg, int end_arg,
1144                                                     objArrayHandle info, int pos,
1145                                                     bool must_resolve, Handle if_not_available,
1146                                                     TRAPS) {
1147   int argc;
1148   int limit = pos + end_arg - start_arg;
1149   // checks: index in range [0..this_cp-&gt;length),
1150   // tag at index, start..end in range [0..argc],
1151   // info array non-null, pos..limit in [0..info.length]
1152   if ((0 &gt;= index    || index &gt;= this_cp-&gt;length())  ||
1153       !(this_cp-&gt;tag_at(index).is_invoke_dynamic()    ||
1154         this_cp-&gt;tag_at(index).is_dynamic_constant()) ||
1155       (0 &gt; start_arg || start_arg &gt; end_arg) ||
1156       (end_arg &gt; (argc = this_cp-&gt;bootstrap_argument_count_at(index))) ||
1157       (0 &gt; pos       || pos &gt; limit)         ||
1158       (info.is_null() || limit &gt; info-&gt;length())) {
1159     // An index or something else went wrong; throw an error.
1160     // Since this is an internal API, we don&#39;t expect this,
1161     // so we don&#39;t bother to craft a nice message.
1162     THROW_MSG(vmSymbols::java_lang_LinkageError(), &quot;bad BSM argument access&quot;);
1163   }
1164   // now we can loop safely
1165   int info_i = pos;
1166   for (int i = start_arg; i &lt; end_arg; i++) {
1167     int arg_index = this_cp-&gt;bootstrap_argument_index_at(index, i);
1168     oop arg_oop;
1169     if (must_resolve) {
1170       arg_oop = this_cp-&gt;resolve_possibly_cached_constant_at(arg_index, CHECK);
1171     } else {
1172       bool found_it = false;
1173       arg_oop = this_cp-&gt;find_cached_constant_at(arg_index, found_it, CHECK);
1174       if (!found_it)  arg_oop = if_not_available();
1175     }
1176     info-&gt;obj_at_put(info_i++, arg_oop);
1177   }
1178 }
1179 
1180 oop ConstantPool::string_at_impl(const constantPoolHandle&amp; this_cp, int which, int obj_index, TRAPS) {
1181   // If the string has already been interned, this entry will be non-null
1182   oop str = this_cp-&gt;resolved_references()-&gt;obj_at(obj_index);
1183   assert(str != Universe::the_null_sentinel(), &quot;&quot;);
1184   if (str != NULL) return str;
1185   Symbol* sym = this_cp-&gt;unresolved_string_at(which);
1186   str = StringTable::intern(sym, CHECK_(NULL));
1187   this_cp-&gt;string_at_put(which, obj_index, str);
1188   assert(java_lang_String::is_instance(str), &quot;must be string&quot;);
1189   return str;
1190 }
1191 
1192 
1193 bool ConstantPool::klass_name_at_matches(const InstanceKlass* k, int which) {
1194   // Names are interned, so we can compare Symbol*s directly
1195   Symbol* cp_name = klass_name_at(which);
1196   return (cp_name == k-&gt;name());
1197 }
1198 
1199 
1200 // Iterate over symbols and decrement ones which are Symbol*s
1201 // This is done during GC.
1202 // Only decrement the UTF8 symbols. Strings point to
1203 // these symbols but didn&#39;t increment the reference count.
1204 void ConstantPool::unreference_symbols() {
1205   for (int index = 1; index &lt; length(); index++) { // Index 0 is unused
1206     constantTag tag = tag_at(index);
1207     if (tag.is_symbol()) {
1208       symbol_at(index)-&gt;decrement_refcount();
1209     }
1210   }
1211 }
1212 
1213 
1214 // Compare this constant pool&#39;s entry at index1 to the constant pool
1215 // cp2&#39;s entry at index2.
1216 bool ConstantPool::compare_entry_to(int index1, const constantPoolHandle&amp; cp2,
1217        int index2, TRAPS) {
1218 
1219   // The error tags are equivalent to non-error tags when comparing
1220   jbyte t1 = tag_at(index1).non_error_value();
1221   jbyte t2 = cp2-&gt;tag_at(index2).non_error_value();
1222 
1223   if (t1 != t2) {
1224     // Not the same entry type so there is nothing else to check. Note
1225     // that this style of checking will consider resolved/unresolved
1226     // class pairs as different.
1227     // From the ConstantPool* API point of view, this is correct
1228     // behavior. See VM_RedefineClasses::merge_constant_pools() to see how this
1229     // plays out in the context of ConstantPool* merging.
1230     return false;
1231   }
1232 
1233   switch (t1) {
1234   case JVM_CONSTANT_Class:
1235   {
1236     Klass* k1 = klass_at(index1, CHECK_false);
1237     Klass* k2 = cp2-&gt;klass_at(index2, CHECK_false);
1238     if (k1 == k2) {
1239       return true;
1240     }
1241   } break;
1242 
1243   case JVM_CONSTANT_ClassIndex:
1244   {
1245     int recur1 = klass_index_at(index1);
1246     int recur2 = cp2-&gt;klass_index_at(index2);
1247     bool match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1248     if (match) {
1249       return true;
1250     }
1251   } break;
1252 
1253   case JVM_CONSTANT_Double:
1254   {
1255     jdouble d1 = double_at(index1);
1256     jdouble d2 = cp2-&gt;double_at(index2);
1257     if (d1 == d2) {
1258       return true;
1259     }
1260   } break;
1261 
1262   case JVM_CONSTANT_Fieldref:
1263   case JVM_CONSTANT_InterfaceMethodref:
1264   case JVM_CONSTANT_Methodref:
1265   {
1266     int recur1 = uncached_klass_ref_index_at(index1);
1267     int recur2 = cp2-&gt;uncached_klass_ref_index_at(index2);
1268     bool match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1269     if (match) {
1270       recur1 = uncached_name_and_type_ref_index_at(index1);
1271       recur2 = cp2-&gt;uncached_name_and_type_ref_index_at(index2);
1272       match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1273       if (match) {
1274         return true;
1275       }
1276     }
1277   } break;
1278 
1279   case JVM_CONSTANT_Float:
1280   {
1281     jfloat f1 = float_at(index1);
1282     jfloat f2 = cp2-&gt;float_at(index2);
1283     if (f1 == f2) {
1284       return true;
1285     }
1286   } break;
1287 
1288   case JVM_CONSTANT_Integer:
1289   {
1290     jint i1 = int_at(index1);
1291     jint i2 = cp2-&gt;int_at(index2);
1292     if (i1 == i2) {
1293       return true;
1294     }
1295   } break;
1296 
1297   case JVM_CONSTANT_Long:
1298   {
1299     jlong l1 = long_at(index1);
1300     jlong l2 = cp2-&gt;long_at(index2);
1301     if (l1 == l2) {
1302       return true;
1303     }
1304   } break;
1305 
1306   case JVM_CONSTANT_NameAndType:
1307   {
1308     int recur1 = name_ref_index_at(index1);
1309     int recur2 = cp2-&gt;name_ref_index_at(index2);
1310     bool match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1311     if (match) {
1312       recur1 = signature_ref_index_at(index1);
1313       recur2 = cp2-&gt;signature_ref_index_at(index2);
1314       match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1315       if (match) {
1316         return true;
1317       }
1318     }
1319   } break;
1320 
1321   case JVM_CONSTANT_StringIndex:
1322   {
1323     int recur1 = string_index_at(index1);
1324     int recur2 = cp2-&gt;string_index_at(index2);
1325     bool match = compare_entry_to(recur1, cp2, recur2, CHECK_false);
1326     if (match) {
1327       return true;
1328     }
1329   } break;
1330 
1331   case JVM_CONSTANT_UnresolvedClass:
1332   {
1333     Symbol* k1 = klass_name_at(index1);
1334     Symbol* k2 = cp2-&gt;klass_name_at(index2);
1335     if (k1 == k2) {
1336       return true;
1337     }
1338   } break;
1339 
1340   case JVM_CONSTANT_MethodType:
1341   {
1342     int k1 = method_type_index_at(index1);
1343     int k2 = cp2-&gt;method_type_index_at(index2);
1344     bool match = compare_entry_to(k1, cp2, k2, CHECK_false);
1345     if (match) {
1346       return true;
1347     }
1348   } break;
1349 
1350   case JVM_CONSTANT_MethodHandle:
1351   {
1352     int k1 = method_handle_ref_kind_at(index1);
1353     int k2 = cp2-&gt;method_handle_ref_kind_at(index2);
1354     if (k1 == k2) {
1355       int i1 = method_handle_index_at(index1);
1356       int i2 = cp2-&gt;method_handle_index_at(index2);
1357       bool match = compare_entry_to(i1, cp2, i2, CHECK_false);
1358       if (match) {
1359         return true;
1360       }
1361     }
1362   } break;
1363 
1364   case JVM_CONSTANT_Dynamic:
1365   {
1366     int k1 = bootstrap_name_and_type_ref_index_at(index1);
1367     int k2 = cp2-&gt;bootstrap_name_and_type_ref_index_at(index2);
1368     int i1 = bootstrap_methods_attribute_index(index1);
1369     int i2 = cp2-&gt;bootstrap_methods_attribute_index(index2);
1370     // separate statements and variables because CHECK_false is used
1371     bool match_entry = compare_entry_to(k1, cp2, k2, CHECK_false);
1372     bool match_operand = compare_operand_to(i1, cp2, i2, CHECK_false);
1373     return (match_entry &amp;&amp; match_operand);
1374   } break;
1375 
1376   case JVM_CONSTANT_InvokeDynamic:
1377   {
1378     int k1 = bootstrap_name_and_type_ref_index_at(index1);
1379     int k2 = cp2-&gt;bootstrap_name_and_type_ref_index_at(index2);
1380     int i1 = bootstrap_methods_attribute_index(index1);
1381     int i2 = cp2-&gt;bootstrap_methods_attribute_index(index2);
1382     // separate statements and variables because CHECK_false is used
1383     bool match_entry = compare_entry_to(k1, cp2, k2, CHECK_false);
1384     bool match_operand = compare_operand_to(i1, cp2, i2, CHECK_false);
1385     return (match_entry &amp;&amp; match_operand);
1386   } break;
1387 
1388   case JVM_CONSTANT_String:
1389   {
1390     Symbol* s1 = unresolved_string_at(index1);
1391     Symbol* s2 = cp2-&gt;unresolved_string_at(index2);
1392     if (s1 == s2) {
1393       return true;
1394     }
1395   } break;
1396 
1397   case JVM_CONSTANT_Utf8:
1398   {
1399     Symbol* s1 = symbol_at(index1);
1400     Symbol* s2 = cp2-&gt;symbol_at(index2);
1401     if (s1 == s2) {
1402       return true;
1403     }
1404   } break;
1405 
1406   // Invalid is used as the tag for the second constant pool entry
1407   // occupied by JVM_CONSTANT_Double or JVM_CONSTANT_Long. It should
1408   // not be seen by itself.
1409   case JVM_CONSTANT_Invalid: // fall through
1410 
1411   default:
1412     ShouldNotReachHere();
1413     break;
1414   }
1415 
1416   return false;
1417 } // end compare_entry_to()
1418 
1419 
1420 // Resize the operands array with delta_len and delta_size.
1421 // Used in RedefineClasses for CP merge.
1422 void ConstantPool::resize_operands(int delta_len, int delta_size, TRAPS) {
1423   int old_len  = operand_array_length(operands());
1424   int new_len  = old_len + delta_len;
1425   int min_len  = (delta_len &gt; 0) ? old_len : new_len;
1426 
1427   int old_size = operands()-&gt;length();
1428   int new_size = old_size + delta_size;
1429   int min_size = (delta_size &gt; 0) ? old_size : new_size;
1430 
1431   ClassLoaderData* loader_data = pool_holder()-&gt;class_loader_data();
1432   Array&lt;u2&gt;* new_ops = MetadataFactory::new_array&lt;u2&gt;(loader_data, new_size, CHECK);
1433 
1434   // Set index in the resized array for existing elements only
1435   for (int idx = 0; idx &lt; min_len; idx++) {
1436     int offset = operand_offset_at(idx);                       // offset in original array
1437     operand_offset_at_put(new_ops, idx, offset + 2*delta_len); // offset in resized array
1438   }
1439   // Copy the bootstrap specifiers only
1440   Copy::conjoint_memory_atomic(operands()-&gt;adr_at(2*old_len),
1441                                new_ops-&gt;adr_at(2*new_len),
1442                                (min_size - 2*min_len) * sizeof(u2));
1443   // Explicitly deallocate old operands array.
1444   // Note, it is not needed for 7u backport.
1445   if ( operands() != NULL) { // the safety check
1446     MetadataFactory::free_array&lt;u2&gt;(loader_data, operands());
1447   }
1448   set_operands(new_ops);
1449 } // end resize_operands()
1450 
1451 
1452 // Extend the operands array with the length and size of the ext_cp operands.
1453 // Used in RedefineClasses for CP merge.
1454 void ConstantPool::extend_operands(const constantPoolHandle&amp; ext_cp, TRAPS) {
1455   int delta_len = operand_array_length(ext_cp-&gt;operands());
1456   if (delta_len == 0) {
1457     return; // nothing to do
1458   }
1459   int delta_size = ext_cp-&gt;operands()-&gt;length();
1460 
1461   assert(delta_len  &gt; 0 &amp;&amp; delta_size &gt; 0, &quot;extended operands array must be bigger&quot;);
1462 
1463   if (operand_array_length(operands()) == 0) {
1464     ClassLoaderData* loader_data = pool_holder()-&gt;class_loader_data();
1465     Array&lt;u2&gt;* new_ops = MetadataFactory::new_array&lt;u2&gt;(loader_data, delta_size, CHECK);
1466     // The first element index defines the offset of second part
1467     operand_offset_at_put(new_ops, 0, 2*delta_len); // offset in new array
1468     set_operands(new_ops);
1469   } else {
1470     resize_operands(delta_len, delta_size, CHECK);
1471   }
1472 
1473 } // end extend_operands()
1474 
1475 
1476 // Shrink the operands array to a smaller array with new_len length.
1477 // Used in RedefineClasses for CP merge.
1478 void ConstantPool::shrink_operands(int new_len, TRAPS) {
1479   int old_len = operand_array_length(operands());
1480   if (new_len == old_len) {
1481     return; // nothing to do
1482   }
1483   assert(new_len &lt; old_len, &quot;shrunken operands array must be smaller&quot;);
1484 
1485   int free_base  = operand_next_offset_at(new_len - 1);
1486   int delta_len  = new_len - old_len;
1487   int delta_size = 2*delta_len + free_base - operands()-&gt;length();
1488 
1489   resize_operands(delta_len, delta_size, CHECK);
1490 
1491 } // end shrink_operands()
1492 
1493 
1494 void ConstantPool::copy_operands(const constantPoolHandle&amp; from_cp,
1495                                  const constantPoolHandle&amp; to_cp,
1496                                  TRAPS) {
1497 
1498   int from_oplen = operand_array_length(from_cp-&gt;operands());
1499   int old_oplen  = operand_array_length(to_cp-&gt;operands());
1500   if (from_oplen != 0) {
1501     ClassLoaderData* loader_data = to_cp-&gt;pool_holder()-&gt;class_loader_data();
1502     // append my operands to the target&#39;s operands array
1503     if (old_oplen == 0) {
1504       // Can&#39;t just reuse from_cp&#39;s operand list because of deallocation issues
1505       int len = from_cp-&gt;operands()-&gt;length();
1506       Array&lt;u2&gt;* new_ops = MetadataFactory::new_array&lt;u2&gt;(loader_data, len, CHECK);
1507       Copy::conjoint_memory_atomic(
1508           from_cp-&gt;operands()-&gt;adr_at(0), new_ops-&gt;adr_at(0), len * sizeof(u2));
1509       to_cp-&gt;set_operands(new_ops);
1510     } else {
1511       int old_len  = to_cp-&gt;operands()-&gt;length();
1512       int from_len = from_cp-&gt;operands()-&gt;length();
1513       int old_off  = old_oplen * sizeof(u2);
1514       int from_off = from_oplen * sizeof(u2);
1515       // Use the metaspace for the destination constant pool
1516       Array&lt;u2&gt;* new_operands = MetadataFactory::new_array&lt;u2&gt;(loader_data, old_len + from_len, CHECK);
1517       int fillp = 0, len = 0;
1518       // first part of dest
1519       Copy::conjoint_memory_atomic(to_cp-&gt;operands()-&gt;adr_at(0),
1520                                    new_operands-&gt;adr_at(fillp),
1521                                    (len = old_off) * sizeof(u2));
1522       fillp += len;
1523       // first part of src
1524       Copy::conjoint_memory_atomic(from_cp-&gt;operands()-&gt;adr_at(0),
1525                                    new_operands-&gt;adr_at(fillp),
1526                                    (len = from_off) * sizeof(u2));
1527       fillp += len;
1528       // second part of dest
1529       Copy::conjoint_memory_atomic(to_cp-&gt;operands()-&gt;adr_at(old_off),
1530                                    new_operands-&gt;adr_at(fillp),
1531                                    (len = old_len - old_off) * sizeof(u2));
1532       fillp += len;
1533       // second part of src
1534       Copy::conjoint_memory_atomic(from_cp-&gt;operands()-&gt;adr_at(from_off),
1535                                    new_operands-&gt;adr_at(fillp),
1536                                    (len = from_len - from_off) * sizeof(u2));
1537       fillp += len;
1538       assert(fillp == new_operands-&gt;length(), &quot;&quot;);
1539 
1540       // Adjust indexes in the first part of the copied operands array.
1541       for (int j = 0; j &lt; from_oplen; j++) {
1542         int offset = operand_offset_at(new_operands, old_oplen + j);
1543         assert(offset == operand_offset_at(from_cp-&gt;operands(), j), &quot;correct copy&quot;);
1544         offset += old_len;  // every new tuple is preceded by old_len extra u2&#39;s
1545         operand_offset_at_put(new_operands, old_oplen + j, offset);
1546       }
1547 
1548       // replace target operands array with combined array
1549       to_cp-&gt;set_operands(new_operands);
1550     }
1551   }
1552 } // end copy_operands()
1553 
1554 
1555 // Copy this constant pool&#39;s entries at start_i to end_i (inclusive)
1556 // to the constant pool to_cp&#39;s entries starting at to_i. A total of
1557 // (end_i - start_i) + 1 entries are copied.
1558 void ConstantPool::copy_cp_to_impl(const constantPoolHandle&amp; from_cp, int start_i, int end_i,
1559        const constantPoolHandle&amp; to_cp, int to_i, TRAPS) {
1560 
1561 
1562   int dest_i = to_i;  // leave original alone for debug purposes
1563 
1564   for (int src_i = start_i; src_i &lt;= end_i; /* see loop bottom */ ) {
1565     copy_entry_to(from_cp, src_i, to_cp, dest_i, CHECK);
1566 
1567     switch (from_cp-&gt;tag_at(src_i).value()) {
1568     case JVM_CONSTANT_Double:
1569     case JVM_CONSTANT_Long:
1570       // double and long take two constant pool entries
1571       src_i += 2;
1572       dest_i += 2;
1573       break;
1574 
1575     default:
1576       // all others take one constant pool entry
1577       src_i++;
1578       dest_i++;
1579       break;
1580     }
1581   }
1582   copy_operands(from_cp, to_cp, CHECK);
1583 
1584 } // end copy_cp_to_impl()
1585 
1586 
1587 // Copy this constant pool&#39;s entry at from_i to the constant pool
1588 // to_cp&#39;s entry at to_i.
1589 void ConstantPool::copy_entry_to(const constantPoolHandle&amp; from_cp, int from_i,
1590                                         const constantPoolHandle&amp; to_cp, int to_i,
1591                                         TRAPS) {
1592 
1593   int tag = from_cp-&gt;tag_at(from_i).value();
1594   switch (tag) {
1595   case JVM_CONSTANT_ClassIndex:
1596   {
1597     jint ki = from_cp-&gt;klass_index_at(from_i);
1598     to_cp-&gt;klass_index_at_put(to_i, ki);
1599   } break;
1600 
1601   case JVM_CONSTANT_Double:
1602   {
1603     jdouble d = from_cp-&gt;double_at(from_i);
1604     to_cp-&gt;double_at_put(to_i, d);
1605     // double takes two constant pool entries so init second entry&#39;s tag
1606     to_cp-&gt;tag_at_put(to_i + 1, JVM_CONSTANT_Invalid);
1607   } break;
1608 
1609   case JVM_CONSTANT_Fieldref:
1610   {
1611     int class_index = from_cp-&gt;uncached_klass_ref_index_at(from_i);
1612     int name_and_type_index = from_cp-&gt;uncached_name_and_type_ref_index_at(from_i);
1613     to_cp-&gt;field_at_put(to_i, class_index, name_and_type_index);
1614   } break;
1615 
1616   case JVM_CONSTANT_Float:
1617   {
1618     jfloat f = from_cp-&gt;float_at(from_i);
1619     to_cp-&gt;float_at_put(to_i, f);
1620   } break;
1621 
1622   case JVM_CONSTANT_Integer:
1623   {
1624     jint i = from_cp-&gt;int_at(from_i);
1625     to_cp-&gt;int_at_put(to_i, i);
1626   } break;
1627 
1628   case JVM_CONSTANT_InterfaceMethodref:
1629   {
1630     int class_index = from_cp-&gt;uncached_klass_ref_index_at(from_i);
1631     int name_and_type_index = from_cp-&gt;uncached_name_and_type_ref_index_at(from_i);
1632     to_cp-&gt;interface_method_at_put(to_i, class_index, name_and_type_index);
1633   } break;
1634 
1635   case JVM_CONSTANT_Long:
1636   {
1637     jlong l = from_cp-&gt;long_at(from_i);
1638     to_cp-&gt;long_at_put(to_i, l);
1639     // long takes two constant pool entries so init second entry&#39;s tag
1640     to_cp-&gt;tag_at_put(to_i + 1, JVM_CONSTANT_Invalid);
1641   } break;
1642 
1643   case JVM_CONSTANT_Methodref:
1644   {
1645     int class_index = from_cp-&gt;uncached_klass_ref_index_at(from_i);
1646     int name_and_type_index = from_cp-&gt;uncached_name_and_type_ref_index_at(from_i);
1647     to_cp-&gt;method_at_put(to_i, class_index, name_and_type_index);
1648   } break;
1649 
1650   case JVM_CONSTANT_NameAndType:
1651   {
1652     int name_ref_index = from_cp-&gt;name_ref_index_at(from_i);
1653     int signature_ref_index = from_cp-&gt;signature_ref_index_at(from_i);
1654     to_cp-&gt;name_and_type_at_put(to_i, name_ref_index, signature_ref_index);
1655   } break;
1656 
1657   case JVM_CONSTANT_StringIndex:
1658   {
1659     jint si = from_cp-&gt;string_index_at(from_i);
1660     to_cp-&gt;string_index_at_put(to_i, si);
1661   } break;
1662 
1663   case JVM_CONSTANT_Class:
1664   case JVM_CONSTANT_UnresolvedClass:
1665   case JVM_CONSTANT_UnresolvedClassInError:
1666   {
1667     // Revert to JVM_CONSTANT_ClassIndex
1668     int name_index = from_cp-&gt;klass_slot_at(from_i).name_index();
1669     assert(from_cp-&gt;tag_at(name_index).is_symbol(), &quot;sanity&quot;);
1670     to_cp-&gt;klass_index_at_put(to_i, name_index);
1671   } break;
1672 
1673   case JVM_CONSTANT_String:
1674   {
1675     Symbol* s = from_cp-&gt;unresolved_string_at(from_i);
1676     to_cp-&gt;unresolved_string_at_put(to_i, s);
1677   } break;
1678 
1679   case JVM_CONSTANT_Utf8:
1680   {
1681     Symbol* s = from_cp-&gt;symbol_at(from_i);
1682     // Need to increase refcount, the old one will be thrown away and deferenced
1683     s-&gt;increment_refcount();
1684     to_cp-&gt;symbol_at_put(to_i, s);
1685   } break;
1686 
1687   case JVM_CONSTANT_MethodType:
1688   case JVM_CONSTANT_MethodTypeInError:
1689   {
1690     jint k = from_cp-&gt;method_type_index_at(from_i);
1691     to_cp-&gt;method_type_index_at_put(to_i, k);
1692   } break;
1693 
1694   case JVM_CONSTANT_MethodHandle:
1695   case JVM_CONSTANT_MethodHandleInError:
1696   {
1697     int k1 = from_cp-&gt;method_handle_ref_kind_at(from_i);
1698     int k2 = from_cp-&gt;method_handle_index_at(from_i);
1699     to_cp-&gt;method_handle_index_at_put(to_i, k1, k2);
1700   } break;
1701 
1702   case JVM_CONSTANT_Dynamic:
1703   case JVM_CONSTANT_DynamicInError:
1704   {
1705     int k1 = from_cp-&gt;bootstrap_methods_attribute_index(from_i);
1706     int k2 = from_cp-&gt;bootstrap_name_and_type_ref_index_at(from_i);
1707     k1 += operand_array_length(to_cp-&gt;operands());  // to_cp might already have operands
1708     to_cp-&gt;dynamic_constant_at_put(to_i, k1, k2);
1709   } break;
1710 
1711   case JVM_CONSTANT_InvokeDynamic:
1712   {
1713     int k1 = from_cp-&gt;bootstrap_methods_attribute_index(from_i);
1714     int k2 = from_cp-&gt;bootstrap_name_and_type_ref_index_at(from_i);
1715     k1 += operand_array_length(to_cp-&gt;operands());  // to_cp might already have operands
1716     to_cp-&gt;invoke_dynamic_at_put(to_i, k1, k2);
1717   } break;
1718 
1719   // Invalid is used as the tag for the second constant pool entry
1720   // occupied by JVM_CONSTANT_Double or JVM_CONSTANT_Long. It should
1721   // not be seen by itself.
1722   case JVM_CONSTANT_Invalid: // fall through
1723 
1724   default:
1725   {
1726     ShouldNotReachHere();
1727   } break;
1728   }
1729 } // end copy_entry_to()
1730 
1731 // Search constant pool search_cp for an entry that matches this
1732 // constant pool&#39;s entry at pattern_i. Returns the index of a
1733 // matching entry or zero (0) if there is no matching entry.
1734 int ConstantPool::find_matching_entry(int pattern_i,
1735       const constantPoolHandle&amp; search_cp, TRAPS) {
1736 
1737   // index zero (0) is not used
1738   for (int i = 1; i &lt; search_cp-&gt;length(); i++) {
1739     bool found = compare_entry_to(pattern_i, search_cp, i, CHECK_0);
1740     if (found) {
1741       return i;
1742     }
1743   }
1744 
1745   return 0;  // entry not found; return unused index zero (0)
1746 } // end find_matching_entry()
1747 
1748 
1749 // Compare this constant pool&#39;s bootstrap specifier at idx1 to the constant pool
1750 // cp2&#39;s bootstrap specifier at idx2.
1751 bool ConstantPool::compare_operand_to(int idx1, const constantPoolHandle&amp; cp2, int idx2, TRAPS) {
1752   int k1 = operand_bootstrap_method_ref_index_at(idx1);
1753   int k2 = cp2-&gt;operand_bootstrap_method_ref_index_at(idx2);
1754   bool match = compare_entry_to(k1, cp2, k2, CHECK_false);
1755 
1756   if (!match) {
1757     return false;
1758   }
1759   int argc = operand_argument_count_at(idx1);
1760   if (argc == cp2-&gt;operand_argument_count_at(idx2)) {
1761     for (int j = 0; j &lt; argc; j++) {
1762       k1 = operand_argument_index_at(idx1, j);
1763       k2 = cp2-&gt;operand_argument_index_at(idx2, j);
1764       match = compare_entry_to(k1, cp2, k2, CHECK_false);
1765       if (!match) {
1766         return false;
1767       }
1768     }
1769     return true;           // got through loop; all elements equal
1770   }
1771   return false;
1772 } // end compare_operand_to()
1773 
1774 // Search constant pool search_cp for a bootstrap specifier that matches
1775 // this constant pool&#39;s bootstrap specifier data at pattern_i index.
1776 // Return the index of a matching bootstrap attribute record or (-1) if there is no match.
1777 int ConstantPool::find_matching_operand(int pattern_i,
1778                     const constantPoolHandle&amp; search_cp, int search_len, TRAPS) {
1779   for (int i = 0; i &lt; search_len; i++) {
1780     bool found = compare_operand_to(pattern_i, search_cp, i, CHECK_(-1));
1781     if (found) {
1782       return i;
1783     }
1784   }
1785   return -1;  // bootstrap specifier data not found; return unused index (-1)
1786 } // end find_matching_operand()
1787 
1788 
1789 #ifndef PRODUCT
1790 
1791 const char* ConstantPool::printable_name_at(int which) {
1792 
1793   constantTag tag = tag_at(which);
1794 
1795   if (tag.is_string()) {
1796     return string_at_noresolve(which);
1797   } else if (tag.is_klass() || tag.is_unresolved_klass()) {
1798     return klass_name_at(which)-&gt;as_C_string();
1799   } else if (tag.is_symbol()) {
1800     return symbol_at(which)-&gt;as_C_string();
1801   }
1802   return &quot;&quot;;
1803 }
1804 
1805 #endif // PRODUCT
1806 
1807 
1808 // JVMTI GetConstantPool support
1809 
1810 // For debugging of constant pool
1811 const bool debug_cpool = false;
1812 
1813 #define DBG(code) do { if (debug_cpool) { (code); } } while(0)
1814 
1815 static void print_cpool_bytes(jint cnt, u1 *bytes) {
1816   const char* WARN_MSG = &quot;Must not be such entry!&quot;;
1817   jint size = 0;
1818   u2   idx1, idx2;
1819 
1820   for (jint idx = 1; idx &lt; cnt; idx++) {
1821     jint ent_size = 0;
1822     u1   tag  = *bytes++;
1823     size++;                       // count tag
1824 
1825     printf(&quot;const #%03d, tag: %02d &quot;, idx, tag);
1826     switch(tag) {
1827       case JVM_CONSTANT_Invalid: {
1828         printf(&quot;Invalid&quot;);
1829         break;
1830       }
1831       case JVM_CONSTANT_Unicode: {
1832         printf(&quot;Unicode      %s&quot;, WARN_MSG);
1833         break;
1834       }
1835       case JVM_CONSTANT_Utf8: {
1836         u2 len = Bytes::get_Java_u2(bytes);
1837         char str[128];
1838         if (len &gt; 127) {
1839            len = 127;
1840         }
1841         strncpy(str, (char *) (bytes+2), len);
1842         str[len] = &#39;\0&#39;;
1843         printf(&quot;Utf8          \&quot;%s\&quot;&quot;, str);
1844         ent_size = 2 + len;
1845         break;
1846       }
1847       case JVM_CONSTANT_Integer: {
1848         u4 val = Bytes::get_Java_u4(bytes);
1849         printf(&quot;int          %d&quot;, *(int *) &amp;val);
1850         ent_size = 4;
1851         break;
1852       }
1853       case JVM_CONSTANT_Float: {
1854         u4 val = Bytes::get_Java_u4(bytes);
1855         printf(&quot;float        %5.3ff&quot;, *(float *) &amp;val);
1856         ent_size = 4;
1857         break;
1858       }
1859       case JVM_CONSTANT_Long: {
1860         u8 val = Bytes::get_Java_u8(bytes);
1861         printf(&quot;long         &quot; INT64_FORMAT, (int64_t) *(jlong *) &amp;val);
1862         ent_size = 8;
1863         idx++; // Long takes two cpool slots
1864         break;
1865       }
1866       case JVM_CONSTANT_Double: {
1867         u8 val = Bytes::get_Java_u8(bytes);
1868         printf(&quot;double       %5.3fd&quot;, *(jdouble *)&amp;val);
1869         ent_size = 8;
1870         idx++; // Double takes two cpool slots
1871         break;
1872       }
1873       case JVM_CONSTANT_Class: {
1874         idx1 = Bytes::get_Java_u2(bytes);
1875         printf(&quot;class        #%03d&quot;, idx1);
1876         ent_size = 2;
1877         break;
1878       }
1879       case JVM_CONSTANT_String: {
1880         idx1 = Bytes::get_Java_u2(bytes);
1881         printf(&quot;String       #%03d&quot;, idx1);
1882         ent_size = 2;
1883         break;
1884       }
1885       case JVM_CONSTANT_Fieldref: {
1886         idx1 = Bytes::get_Java_u2(bytes);
1887         idx2 = Bytes::get_Java_u2(bytes+2);
1888         printf(&quot;Field        #%03d, #%03d&quot;, (int) idx1, (int) idx2);
1889         ent_size = 4;
1890         break;
1891       }
1892       case JVM_CONSTANT_Methodref: {
1893         idx1 = Bytes::get_Java_u2(bytes);
1894         idx2 = Bytes::get_Java_u2(bytes+2);
1895         printf(&quot;Method       #%03d, #%03d&quot;, idx1, idx2);
1896         ent_size = 4;
1897         break;
1898       }
1899       case JVM_CONSTANT_InterfaceMethodref: {
1900         idx1 = Bytes::get_Java_u2(bytes);
1901         idx2 = Bytes::get_Java_u2(bytes+2);
1902         printf(&quot;InterfMethod #%03d, #%03d&quot;, idx1, idx2);
1903         ent_size = 4;
1904         break;
1905       }
1906       case JVM_CONSTANT_NameAndType: {
1907         idx1 = Bytes::get_Java_u2(bytes);
1908         idx2 = Bytes::get_Java_u2(bytes+2);
1909         printf(&quot;NameAndType  #%03d, #%03d&quot;, idx1, idx2);
1910         ent_size = 4;
1911         break;
1912       }
1913       case JVM_CONSTANT_ClassIndex: {
1914         printf(&quot;ClassIndex  %s&quot;, WARN_MSG);
1915         break;
1916       }
1917       case JVM_CONSTANT_UnresolvedClass: {
1918         printf(&quot;UnresolvedClass: %s&quot;, WARN_MSG);
1919         break;
1920       }
1921       case JVM_CONSTANT_UnresolvedClassInError: {
1922         printf(&quot;UnresolvedClassInErr: %s&quot;, WARN_MSG);
1923         break;
1924       }
1925       case JVM_CONSTANT_StringIndex: {
1926         printf(&quot;StringIndex: %s&quot;, WARN_MSG);
1927         break;
1928       }
1929     }
1930     printf(&quot;;\n&quot;);
1931     bytes += ent_size;
1932     size  += ent_size;
1933   }
1934   printf(&quot;Cpool size: %d\n&quot;, size);
1935   fflush(0);
1936   return;
1937 } /* end print_cpool_bytes */
1938 
1939 
1940 // Returns size of constant pool entry.
1941 jint ConstantPool::cpool_entry_size(jint idx) {
1942   switch(tag_at(idx).value()) {
1943     case JVM_CONSTANT_Invalid:
1944     case JVM_CONSTANT_Unicode:
1945       return 1;
1946 
1947     case JVM_CONSTANT_Utf8:
1948       return 3 + symbol_at(idx)-&gt;utf8_length();
1949 
1950     case JVM_CONSTANT_Class:
1951     case JVM_CONSTANT_String:
1952     case JVM_CONSTANT_ClassIndex:
1953     case JVM_CONSTANT_UnresolvedClass:
1954     case JVM_CONSTANT_UnresolvedClassInError:
1955     case JVM_CONSTANT_StringIndex:
1956     case JVM_CONSTANT_MethodType:
1957     case JVM_CONSTANT_MethodTypeInError:
1958       return 3;
1959 
1960     case JVM_CONSTANT_MethodHandle:
1961     case JVM_CONSTANT_MethodHandleInError:
1962       return 4; //tag, ref_kind, ref_index
1963 
1964     case JVM_CONSTANT_Integer:
1965     case JVM_CONSTANT_Float:
1966     case JVM_CONSTANT_Fieldref:
1967     case JVM_CONSTANT_Methodref:
1968     case JVM_CONSTANT_InterfaceMethodref:
1969     case JVM_CONSTANT_NameAndType:
1970       return 5;
1971 
1972     case JVM_CONSTANT_Dynamic:
1973     case JVM_CONSTANT_DynamicInError:
1974     case JVM_CONSTANT_InvokeDynamic:
1975       // u1 tag, u2 bsm, u2 nt
1976       return 5;
1977 
1978     case JVM_CONSTANT_Long:
1979     case JVM_CONSTANT_Double:
1980       return 9;
1981   }
1982   assert(false, &quot;cpool_entry_size: Invalid constant pool entry tag&quot;);
1983   return 1;
1984 } /* end cpool_entry_size */
1985 
1986 
1987 // SymbolHashMap is used to find a constant pool index from a string.
1988 // This function fills in SymbolHashMaps, one for utf8s and one for
1989 // class names, returns size of the cpool raw bytes.
1990 jint ConstantPool::hash_entries_to(SymbolHashMap *symmap,
1991                                           SymbolHashMap *classmap) {
1992   jint size = 0;
1993 
1994   for (u2 idx = 1; idx &lt; length(); idx++) {
1995     u2 tag = tag_at(idx).value();
1996     size += cpool_entry_size(idx);
1997 
1998     switch(tag) {
1999       case JVM_CONSTANT_Utf8: {
2000         Symbol* sym = symbol_at(idx);
2001         symmap-&gt;add_entry(sym, idx);
2002         DBG(printf(&quot;adding symbol entry %s = %d\n&quot;, sym-&gt;as_utf8(), idx));
2003         break;
2004       }
2005       case JVM_CONSTANT_Class:
2006       case JVM_CONSTANT_UnresolvedClass:
2007       case JVM_CONSTANT_UnresolvedClassInError: {
2008         Symbol* sym = klass_name_at(idx);
2009         classmap-&gt;add_entry(sym, idx);
2010         DBG(printf(&quot;adding class entry %s = %d\n&quot;, sym-&gt;as_utf8(), idx));
2011         break;
2012       }
2013       case JVM_CONSTANT_Long:
2014       case JVM_CONSTANT_Double: {
2015         idx++; // Both Long and Double take two cpool slots
2016         break;
2017       }
2018     }
2019   }
2020   return size;
2021 } /* end hash_utf8_entries_to */
2022 
2023 
2024 // Copy cpool bytes.
2025 // Returns:
2026 //    0, in case of OutOfMemoryError
2027 //   -1, in case of internal error
2028 //  &gt; 0, count of the raw cpool bytes that have been copied
2029 int ConstantPool::copy_cpool_bytes(int cpool_size,
2030                                           SymbolHashMap* tbl,
2031                                           unsigned char *bytes) {
2032   u2   idx1, idx2;
2033   jint size  = 0;
2034   jint cnt   = length();
2035   unsigned char *start_bytes = bytes;
2036 
2037   for (jint idx = 1; idx &lt; cnt; idx++) {
2038     u1   tag      = tag_at(idx).value();
2039     jint ent_size = cpool_entry_size(idx);
2040 
2041     assert(size + ent_size &lt;= cpool_size, &quot;Size mismatch&quot;);
2042 
2043     *bytes = tag;
2044     DBG(printf(&quot;#%03hd tag=%03hd, &quot;, (short)idx, (short)tag));
2045     switch(tag) {
2046       case JVM_CONSTANT_Invalid: {
2047         DBG(printf(&quot;JVM_CONSTANT_Invalid&quot;));
2048         break;
2049       }
2050       case JVM_CONSTANT_Unicode: {
2051         assert(false, &quot;Wrong constant pool tag: JVM_CONSTANT_Unicode&quot;);
2052         DBG(printf(&quot;JVM_CONSTANT_Unicode&quot;));
2053         break;
2054       }
2055       case JVM_CONSTANT_Utf8: {
2056         Symbol* sym = symbol_at(idx);
2057         char*     str = sym-&gt;as_utf8();
2058         // Warning! It&#39;s crashing on x86 with len = sym-&gt;utf8_length()
2059         int       len = (int) strlen(str);
2060         Bytes::put_Java_u2((address) (bytes+1), (u2) len);
2061         for (int i = 0; i &lt; len; i++) {
2062             bytes[3+i] = (u1) str[i];
2063         }
2064         DBG(printf(&quot;JVM_CONSTANT_Utf8: %s &quot;, str));
2065         break;
2066       }
2067       case JVM_CONSTANT_Integer: {
2068         jint val = int_at(idx);
2069         Bytes::put_Java_u4((address) (bytes+1), *(u4*)&amp;val);
2070         break;
2071       }
2072       case JVM_CONSTANT_Float: {
2073         jfloat val = float_at(idx);
2074         Bytes::put_Java_u4((address) (bytes+1), *(u4*)&amp;val);
2075         break;
2076       }
2077       case JVM_CONSTANT_Long: {
2078         jlong val = long_at(idx);
2079         Bytes::put_Java_u8((address) (bytes+1), *(u8*)&amp;val);
2080         idx++;             // Long takes two cpool slots
2081         break;
2082       }
2083       case JVM_CONSTANT_Double: {
2084         jdouble val = double_at(idx);
2085         Bytes::put_Java_u8((address) (bytes+1), *(u8*)&amp;val);
2086         idx++;             // Double takes two cpool slots
2087         break;
2088       }
2089       case JVM_CONSTANT_Class:
2090       case JVM_CONSTANT_UnresolvedClass:
2091       case JVM_CONSTANT_UnresolvedClassInError: {
2092         *bytes = JVM_CONSTANT_Class;
2093         Symbol* sym = klass_name_at(idx);
2094         idx1 = tbl-&gt;symbol_to_value(sym);
2095         assert(idx1 != 0, &quot;Have not found a hashtable entry&quot;);
2096         Bytes::put_Java_u2((address) (bytes+1), idx1);
2097         DBG(printf(&quot;JVM_CONSTANT_Class: idx=#%03hd, %s&quot;, idx1, sym-&gt;as_utf8()));
2098         break;
2099       }
2100       case JVM_CONSTANT_String: {
2101         *bytes = JVM_CONSTANT_String;
2102         Symbol* sym = unresolved_string_at(idx);
2103         idx1 = tbl-&gt;symbol_to_value(sym);
2104         assert(idx1 != 0, &quot;Have not found a hashtable entry&quot;);
2105         Bytes::put_Java_u2((address) (bytes+1), idx1);
2106         DBG(printf(&quot;JVM_CONSTANT_String: idx=#%03hd, %s&quot;, idx1, sym-&gt;as_utf8()));
2107         break;
2108       }
2109       case JVM_CONSTANT_Fieldref:
2110       case JVM_CONSTANT_Methodref:
2111       case JVM_CONSTANT_InterfaceMethodref: {
2112         idx1 = uncached_klass_ref_index_at(idx);
2113         idx2 = uncached_name_and_type_ref_index_at(idx);
2114         Bytes::put_Java_u2((address) (bytes+1), idx1);
2115         Bytes::put_Java_u2((address) (bytes+3), idx2);
2116         DBG(printf(&quot;JVM_CONSTANT_Methodref: %hd %hd&quot;, idx1, idx2));
2117         break;
2118       }
2119       case JVM_CONSTANT_NameAndType: {
2120         idx1 = name_ref_index_at(idx);
2121         idx2 = signature_ref_index_at(idx);
2122         Bytes::put_Java_u2((address) (bytes+1), idx1);
2123         Bytes::put_Java_u2((address) (bytes+3), idx2);
2124         DBG(printf(&quot;JVM_CONSTANT_NameAndType: %hd %hd&quot;, idx1, idx2));
2125         break;
2126       }
2127       case JVM_CONSTANT_ClassIndex: {
2128         *bytes = JVM_CONSTANT_Class;
2129         idx1 = klass_index_at(idx);
2130         Bytes::put_Java_u2((address) (bytes+1), idx1);
2131         DBG(printf(&quot;JVM_CONSTANT_ClassIndex: %hd&quot;, idx1));
2132         break;
2133       }
2134       case JVM_CONSTANT_StringIndex: {
2135         *bytes = JVM_CONSTANT_String;
2136         idx1 = string_index_at(idx);
2137         Bytes::put_Java_u2((address) (bytes+1), idx1);
2138         DBG(printf(&quot;JVM_CONSTANT_StringIndex: %hd&quot;, idx1));
2139         break;
2140       }
2141       case JVM_CONSTANT_MethodHandle:
2142       case JVM_CONSTANT_MethodHandleInError: {
2143         *bytes = JVM_CONSTANT_MethodHandle;
2144         int kind = method_handle_ref_kind_at(idx);
2145         idx1 = method_handle_index_at(idx);
2146         *(bytes+1) = (unsigned char) kind;
2147         Bytes::put_Java_u2((address) (bytes+2), idx1);
2148         DBG(printf(&quot;JVM_CONSTANT_MethodHandle: %d %hd&quot;, kind, idx1));
2149         break;
2150       }
2151       case JVM_CONSTANT_MethodType:
2152       case JVM_CONSTANT_MethodTypeInError: {
2153         *bytes = JVM_CONSTANT_MethodType;
2154         idx1 = method_type_index_at(idx);
2155         Bytes::put_Java_u2((address) (bytes+1), idx1);
2156         DBG(printf(&quot;JVM_CONSTANT_MethodType: %hd&quot;, idx1));
2157         break;
2158       }
2159       case JVM_CONSTANT_Dynamic:
2160       case JVM_CONSTANT_DynamicInError: {
2161         *bytes = tag;
2162         idx1 = extract_low_short_from_int(*int_at_addr(idx));
2163         idx2 = extract_high_short_from_int(*int_at_addr(idx));
2164         assert(idx2 == bootstrap_name_and_type_ref_index_at(idx), &quot;correct half of u4&quot;);
2165         Bytes::put_Java_u2((address) (bytes+1), idx1);
2166         Bytes::put_Java_u2((address) (bytes+3), idx2);
2167         DBG(printf(&quot;JVM_CONSTANT_Dynamic: %hd %hd&quot;, idx1, idx2));
2168         break;
2169       }
2170       case JVM_CONSTANT_InvokeDynamic: {
2171         *bytes = tag;
2172         idx1 = extract_low_short_from_int(*int_at_addr(idx));
2173         idx2 = extract_high_short_from_int(*int_at_addr(idx));
2174         assert(idx2 == bootstrap_name_and_type_ref_index_at(idx), &quot;correct half of u4&quot;);
2175         Bytes::put_Java_u2((address) (bytes+1), idx1);
2176         Bytes::put_Java_u2((address) (bytes+3), idx2);
2177         DBG(printf(&quot;JVM_CONSTANT_InvokeDynamic: %hd %hd&quot;, idx1, idx2));
2178         break;
2179       }
2180     }
2181     DBG(printf(&quot;\n&quot;));
2182     bytes += ent_size;
2183     size  += ent_size;
2184   }
2185   assert(size == cpool_size, &quot;Size mismatch&quot;);
2186 
2187   // Keep temorarily for debugging until it&#39;s stable.
2188   DBG(print_cpool_bytes(cnt, start_bytes));
2189   return (int)(bytes - start_bytes);
2190 } /* end copy_cpool_bytes */
2191 
2192 #undef DBG
2193 
2194 
2195 void ConstantPool::set_on_stack(const bool value) {
2196   if (value) {
2197     // Only record if it&#39;s not already set.
2198     if (!on_stack()) {
2199       assert(!is_shared(), &quot;should always be set for shared constant pools&quot;);
2200       _flags |= _on_stack;
2201       MetadataOnStackMark::record(this);
2202     }
2203   } else {
2204     // Clearing is done single-threadedly.
2205     if (!is_shared()) {
2206       _flags &amp;= ~_on_stack;
2207     }
2208   }
2209 }
2210 
2211 // JSR 292 support for patching constant pool oops after the class is linked and
2212 // the oop array for resolved references are created.
2213 // We can&#39;t do this during classfile parsing, which is how the other indexes are
2214 // patched.  The other patches are applied early for some error checking
2215 // so only defer the pseudo_strings.
2216 void ConstantPool::patch_resolved_references(GrowableArray&lt;Handle&gt;* cp_patches) {
2217   for (int index = 1; index &lt; cp_patches-&gt;length(); index++) { // Index 0 is unused
2218     Handle patch = cp_patches-&gt;at(index);
2219     if (patch.not_null()) {
2220       assert (tag_at(index).is_string(), &quot;should only be string left&quot;);
2221       // Patching a string means pre-resolving it.
2222       // The spelling in the constant pool is ignored.
2223       // The constant reference may be any object whatever.
2224       // If it is not a real interned string, the constant is referred
2225       // to as a &quot;pseudo-string&quot;, and must be presented to the CP
2226       // explicitly, because it may require scavenging.
2227       int obj_index = cp_to_object_index(index);
2228       pseudo_string_at_put(index, obj_index, patch());
2229      DEBUG_ONLY(cp_patches-&gt;at_put(index, Handle());)
2230     }
2231   }
2232 #ifdef ASSERT
2233   // Ensure that all the patches have been used.
2234   for (int index = 0; index &lt; cp_patches-&gt;length(); index++) {
2235     assert(cp_patches-&gt;at(index).is_null(),
2236            &quot;Unused constant pool patch at %d in class file %s&quot;,
2237            index,
2238            pool_holder()-&gt;external_name());
2239   }
2240 #endif // ASSERT
2241 }
2242 
2243 // Printing
2244 
2245 void ConstantPool::print_on(outputStream* st) const {
2246   assert(is_constantPool(), &quot;must be constantPool&quot;);
2247   st-&gt;print_cr(&quot;%s&quot;, internal_name());
2248   if (flags() != 0) {
2249     st-&gt;print(&quot; - flags: 0x%x&quot;, flags());
2250     if (has_preresolution()) st-&gt;print(&quot; has_preresolution&quot;);
2251     if (on_stack()) st-&gt;print(&quot; on_stack&quot;);
2252     st-&gt;cr();
2253   }
2254   if (pool_holder() != NULL) {
2255     st-&gt;print_cr(&quot; - holder: &quot; INTPTR_FORMAT, p2i(pool_holder()));
2256   }
2257   st-&gt;print_cr(&quot; - cache: &quot; INTPTR_FORMAT, p2i(cache()));
2258   st-&gt;print_cr(&quot; - resolved_references: &quot; INTPTR_FORMAT, p2i(resolved_references()));
2259   st-&gt;print_cr(&quot; - reference_map: &quot; INTPTR_FORMAT, p2i(reference_map()));
2260   st-&gt;print_cr(&quot; - resolved_klasses: &quot; INTPTR_FORMAT, p2i(resolved_klasses()));
2261 
2262   for (int index = 1; index &lt; length(); index++) {      // Index 0 is unused
2263     ((ConstantPool*)this)-&gt;print_entry_on(index, st);
2264     switch (tag_at(index).value()) {
2265       case JVM_CONSTANT_Long :
2266       case JVM_CONSTANT_Double :
2267         index++;   // Skip entry following eigth-byte constant
2268     }
2269 
2270   }
2271   st-&gt;cr();
2272 }
2273 
2274 // Print one constant pool entry
2275 void ConstantPool::print_entry_on(const int index, outputStream* st) {
2276   EXCEPTION_MARK;
2277   st-&gt;print(&quot; - %3d : &quot;, index);
2278   tag_at(index).print_on(st);
2279   st-&gt;print(&quot; : &quot;);
2280   switch (tag_at(index).value()) {
2281     case JVM_CONSTANT_Class :
2282       { Klass* k = klass_at(index, CATCH);
2283         guarantee(k != NULL, &quot;need klass&quot;);
2284         k-&gt;print_value_on(st);
2285         st-&gt;print(&quot; {&quot; PTR_FORMAT &quot;}&quot;, p2i(k));
2286       }
2287       break;
2288     case JVM_CONSTANT_Fieldref :
2289     case JVM_CONSTANT_Methodref :
2290     case JVM_CONSTANT_InterfaceMethodref :
2291       st-&gt;print(&quot;klass_index=%d&quot;, uncached_klass_ref_index_at(index));
2292       st-&gt;print(&quot; name_and_type_index=%d&quot;, uncached_name_and_type_ref_index_at(index));
2293       break;
2294     case JVM_CONSTANT_String :
2295       if (is_pseudo_string_at(index)) {
2296         oop anObj = pseudo_string_at(index);
2297         anObj-&gt;print_value_on(st);
2298         st-&gt;print(&quot; {&quot; PTR_FORMAT &quot;}&quot;, p2i(anObj));
2299       } else {
2300         unresolved_string_at(index)-&gt;print_value_on(st);
2301       }
2302       break;
2303     case JVM_CONSTANT_Integer :
2304       st-&gt;print(&quot;%d&quot;, int_at(index));
2305       break;
2306     case JVM_CONSTANT_Float :
2307       st-&gt;print(&quot;%f&quot;, float_at(index));
2308       break;
2309     case JVM_CONSTANT_Long :
2310       st-&gt;print_jlong(long_at(index));
2311       break;
2312     case JVM_CONSTANT_Double :
2313       st-&gt;print(&quot;%lf&quot;, double_at(index));
2314       break;
2315     case JVM_CONSTANT_NameAndType :
2316       st-&gt;print(&quot;name_index=%d&quot;, name_ref_index_at(index));
2317       st-&gt;print(&quot; signature_index=%d&quot;, signature_ref_index_at(index));
2318       break;
2319     case JVM_CONSTANT_Utf8 :
2320       symbol_at(index)-&gt;print_value_on(st);
2321       break;
2322     case JVM_CONSTANT_ClassIndex: {
2323         int name_index = *int_at_addr(index);
2324         st-&gt;print(&quot;klass_index=%d &quot;, name_index);
2325         symbol_at(name_index)-&gt;print_value_on(st);
2326       }
2327       break;
2328     case JVM_CONSTANT_UnresolvedClass :               // fall-through
2329     case JVM_CONSTANT_UnresolvedClassInError: {
2330         CPKlassSlot kslot = klass_slot_at(index);
2331         int resolved_klass_index = kslot.resolved_klass_index();
2332         int name_index = kslot.name_index();
2333         assert(tag_at(name_index).is_symbol(), &quot;sanity&quot;);
2334 
2335         Klass* klass = resolved_klasses()-&gt;at(resolved_klass_index);
2336         if (klass != NULL) {
2337           klass-&gt;print_value_on(st);
2338         } else {
2339           symbol_at(name_index)-&gt;print_value_on(st);
2340         }
2341       }
2342       break;
2343     case JVM_CONSTANT_MethodHandle :
2344     case JVM_CONSTANT_MethodHandleInError :
2345       st-&gt;print(&quot;ref_kind=%d&quot;, method_handle_ref_kind_at(index));
2346       st-&gt;print(&quot; ref_index=%d&quot;, method_handle_index_at(index));
2347       break;
2348     case JVM_CONSTANT_MethodType :
2349     case JVM_CONSTANT_MethodTypeInError :
2350       st-&gt;print(&quot;signature_index=%d&quot;, method_type_index_at(index));
2351       break;
2352     case JVM_CONSTANT_Dynamic :
2353     case JVM_CONSTANT_DynamicInError :
2354       {
2355         st-&gt;print(&quot;bootstrap_method_index=%d&quot;, bootstrap_method_ref_index_at(index));
2356         st-&gt;print(&quot; type_index=%d&quot;, bootstrap_name_and_type_ref_index_at(index));
2357         int argc = bootstrap_argument_count_at(index);
2358         if (argc &gt; 0) {
2359           for (int arg_i = 0; arg_i &lt; argc; arg_i++) {
2360             int arg = bootstrap_argument_index_at(index, arg_i);
2361             st-&gt;print((arg_i == 0 ? &quot; arguments={%d&quot; : &quot;, %d&quot;), arg);
2362           }
2363           st-&gt;print(&quot;}&quot;);
2364         }
2365       }
2366       break;
2367     case JVM_CONSTANT_InvokeDynamic :
2368       {
2369         st-&gt;print(&quot;bootstrap_method_index=%d&quot;, bootstrap_method_ref_index_at(index));
2370         st-&gt;print(&quot; name_and_type_index=%d&quot;, bootstrap_name_and_type_ref_index_at(index));
2371         int argc = bootstrap_argument_count_at(index);
2372         if (argc &gt; 0) {
2373           for (int arg_i = 0; arg_i &lt; argc; arg_i++) {
2374             int arg = bootstrap_argument_index_at(index, arg_i);
2375             st-&gt;print((arg_i == 0 ? &quot; arguments={%d&quot; : &quot;, %d&quot;), arg);
2376           }
2377           st-&gt;print(&quot;}&quot;);
2378         }
2379       }
2380       break;
2381     default:
2382       ShouldNotReachHere();
2383       break;
2384   }
2385   st-&gt;cr();
2386 }
2387 
2388 void ConstantPool::print_value_on(outputStream* st) const {
2389   assert(is_constantPool(), &quot;must be constantPool&quot;);
2390   st-&gt;print(&quot;constant pool [%d]&quot;, length());
2391   if (has_preresolution()) st-&gt;print(&quot;/preresolution&quot;);
2392   if (operands() != NULL)  st-&gt;print(&quot;/operands[%d]&quot;, operands()-&gt;length());
2393   print_address_on(st);
2394   if (pool_holder() != NULL) {
2395     st-&gt;print(&quot; for &quot;);
2396     pool_holder()-&gt;print_value_on(st);
2397     bool extra = (pool_holder()-&gt;constants() != this);
2398     if (extra)  st-&gt;print(&quot; (extra)&quot;);
2399   }
2400   if (cache() != NULL) {
2401     st-&gt;print(&quot; cache=&quot; PTR_FORMAT, p2i(cache()));
2402   }
2403 }
2404 
2405 // Verification
2406 
2407 void ConstantPool::verify_on(outputStream* st) {
2408   guarantee(is_constantPool(), &quot;object must be constant pool&quot;);
2409   for (int i = 0; i&lt; length();  i++) {
2410     constantTag tag = tag_at(i);
2411     if (tag.is_klass() || tag.is_unresolved_klass()) {
2412       guarantee(klass_name_at(i)-&gt;refcount() != 0, &quot;should have nonzero reference count&quot;);
2413     } else if (tag.is_symbol()) {
2414       CPSlot entry = slot_at(i);
2415       guarantee(entry.get_symbol()-&gt;refcount() != 0, &quot;should have nonzero reference count&quot;);
2416     } else if (tag.is_string()) {
2417       CPSlot entry = slot_at(i);
2418       guarantee(entry.get_symbol()-&gt;refcount() != 0, &quot;should have nonzero reference count&quot;);
2419     }
2420   }
2421   if (pool_holder() != NULL) {
2422     // Note: pool_holder() can be NULL in temporary constant pools
2423     // used during constant pool merging
2424     guarantee(pool_holder()-&gt;is_klass(),    &quot;should be klass&quot;);
2425   }
2426 }
2427 
2428 
2429 SymbolHashMap::~SymbolHashMap() {
2430   SymbolHashMapEntry* next;
2431   for (int i = 0; i &lt; _table_size; i++) {
2432     for (SymbolHashMapEntry* cur = bucket(i); cur != NULL; cur = next) {
2433       next = cur-&gt;next();
2434       delete(cur);
2435     }
2436   }
2437   FREE_C_HEAP_ARRAY(SymbolHashMapBucket, _buckets);
2438 }
2439 
2440 void SymbolHashMap::add_entry(Symbol* sym, u2 value) {
2441   char *str = sym-&gt;as_utf8();
2442   unsigned int hash = compute_hash(str, sym-&gt;utf8_length());
2443   unsigned int index = hash % table_size();
2444 
2445   // check if already in map
2446   // we prefer the first entry since it is more likely to be what was used in
2447   // the class file
2448   for (SymbolHashMapEntry *en = bucket(index); en != NULL; en = en-&gt;next()) {
2449     assert(en-&gt;symbol() != NULL, &quot;SymbolHashMapEntry symbol is NULL&quot;);
2450     if (en-&gt;hash() == hash &amp;&amp; en-&gt;symbol() == sym) {
2451         return;  // already there
2452     }
2453   }
2454 
2455   SymbolHashMapEntry* entry = new SymbolHashMapEntry(hash, sym, value);
2456   entry-&gt;set_next(bucket(index));
2457   _buckets[index].set_entry(entry);
2458   assert(entry-&gt;symbol() != NULL, &quot;SymbolHashMapEntry symbol is NULL&quot;);
2459 }
2460 
2461 SymbolHashMapEntry* SymbolHashMap::find_entry(Symbol* sym) {
2462   assert(sym != NULL, &quot;SymbolHashMap::find_entry - symbol is NULL&quot;);
2463   char *str = sym-&gt;as_utf8();
2464   int   len = sym-&gt;utf8_length();
2465   unsigned int hash = SymbolHashMap::compute_hash(str, len);
2466   unsigned int index = hash % table_size();
2467   for (SymbolHashMapEntry *en = bucket(index); en != NULL; en = en-&gt;next()) {
2468     assert(en-&gt;symbol() != NULL, &quot;SymbolHashMapEntry symbol is NULL&quot;);
2469     if (en-&gt;hash() == hash &amp;&amp; en-&gt;symbol() == sym) {
2470       return en;
2471     }
2472   }
2473   return NULL;
2474 }
2475 
2476 void SymbolHashMap::initialize_table(int table_size) {
2477   _table_size = table_size;
2478   _buckets = NEW_C_HEAP_ARRAY(SymbolHashMapBucket, table_size, mtSymbol);
2479   for (int index = 0; index &lt; table_size; index++) {
2480     _buckets[index].clear();
2481   }
2482 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/instanceKlass.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="cpCache.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/instanceKlass.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  48 #include &quot;logging/logStream.hpp&quot;
  49 #include &quot;memory/allocation.inline.hpp&quot;
  50 #include &quot;memory/iterator.inline.hpp&quot;
  51 #include &quot;memory/metadataFactory.hpp&quot;
  52 #include &quot;memory/metaspaceClosure.hpp&quot;
  53 #include &quot;memory/metaspaceShared.hpp&quot;
  54 #include &quot;memory/oopFactory.hpp&quot;
  55 #include &quot;memory/resourceArea.hpp&quot;
  56 #include &quot;memory/universe.hpp&quot;
  57 #include &quot;oops/fieldStreams.inline.hpp&quot;
  58 #include &quot;oops/constantPool.hpp&quot;
  59 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  60 #include &quot;oops/instanceKlass.inline.hpp&quot;
  61 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  62 #include &quot;oops/instanceOop.hpp&quot;
  63 #include &quot;oops/klass.inline.hpp&quot;
  64 #include &quot;oops/method.hpp&quot;
  65 #include &quot;oops/oop.inline.hpp&quot;
  66 #include &quot;oops/recordComponent.hpp&quot;
  67 #include &quot;oops/symbol.hpp&quot;

  68 #include &quot;prims/jvmtiExport.hpp&quot;
  69 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  70 #include &quot;prims/jvmtiThreadState.hpp&quot;
  71 #include &quot;prims/methodComparator.hpp&quot;
  72 #include &quot;runtime/atomic.hpp&quot;
  73 #include &quot;runtime/biasedLocking.hpp&quot;
  74 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  75 #include &quot;runtime/handles.inline.hpp&quot;
  76 #include &quot;runtime/javaCalls.hpp&quot;
  77 #include &quot;runtime/mutexLocker.hpp&quot;
  78 #include &quot;runtime/orderAccess.hpp&quot;
  79 #include &quot;runtime/thread.inline.hpp&quot;
  80 #include &quot;services/classLoadingService.hpp&quot;
  81 #include &quot;services/threadService.hpp&quot;
  82 #include &quot;utilities/dtrace.hpp&quot;
  83 #include &quot;utilities/events.hpp&quot;
  84 #include &quot;utilities/macros.hpp&quot;
  85 #include &quot;utilities/stringUtils.hpp&quot;
  86 #ifdef COMPILER1
  87 #include &quot;c1/c1_Compiler.hpp&quot;
</pre>
<hr />
<pre>
 456                               k-&gt;external_name());
 457   return access;
 458 }
 459 
 460 const char* InstanceKlass::nest_host_error(TRAPS) {
 461   if (_nest_host_index == 0) {
 462     return NULL;
 463   } else {
 464     constantPoolHandle cph(THREAD, constants());
 465     return SystemDictionary::find_nest_host_error(cph, (int)_nest_host_index);
 466   }
 467 }
 468 
 469 InstanceKlass* InstanceKlass::allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS) {
 470   bool is_hidden_or_anonymous = parser.is_hidden() || parser.is_unsafe_anonymous();
 471   const int size = InstanceKlass::size(parser.vtable_size(),
 472                                        parser.itable_size(),
 473                                        nonstatic_oop_map_size(parser.total_oop_map_count()),
 474                                        parser.is_interface(),
 475                                        parser.is_unsafe_anonymous(),
<span class="line-modified"> 476                                        should_store_fingerprint(is_hidden_or_anonymous));</span>


 477 
 478   const Symbol* const class_name = parser.class_name();
 479   assert(class_name != NULL, &quot;invariant&quot;);
 480   ClassLoaderData* loader_data = parser.loader_data();
 481   assert(loader_data != NULL, &quot;invariant&quot;);
 482 
 483   InstanceKlass* ik;
 484 
 485   // Allocation
 486   if (REF_NONE == parser.reference_type()) {
 487     if (class_name == vmSymbols::java_lang_Class()) {
 488       // mirror
 489       ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser);
<span class="line-modified"> 490     }</span>
<span class="line-removed"> 491     else if (is_class_loader(class_name, parser)) {</span>
 492       // class loader
 493       ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser);



 494     } else {
 495       // normal
 496       ik = new (loader_data, size, THREAD) InstanceKlass(parser, InstanceKlass::_kind_other);
 497     }
 498   } else {
 499     // reference
 500     ik = new (loader_data, size, THREAD) InstanceRefKlass(parser);
 501   }
 502 
 503   // Check for pending exception before adding to the loader data and incrementing
 504   // class count.  Can get OOM here.
 505   if (HAS_PENDING_EXCEPTION) {
 506     return NULL;
 507   }
 508 







 509   return ik;
 510 }
 511 























 512 
 513 // copy method ordering from resource area to Metaspace
 514 void InstanceKlass::copy_method_ordering(const intArray* m, TRAPS) {
 515   if (m != NULL) {
 516     // allocate a new array and copy contents (memcpy?)
 517     _method_ordering = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), m-&gt;length(), CHECK);
 518     for (int i = 0; i &lt; m-&gt;length(); i++) {
 519       _method_ordering-&gt;at_put(i, m-&gt;at(i));
 520     }
 521   } else {
 522     _method_ordering = Universe::the_empty_int_array();
 523   }
 524 }
 525 
 526 // create a new array of vtable_indices for default methods
 527 Array&lt;int&gt;* InstanceKlass::create_new_default_vtable_indices(int len, TRAPS) {
 528   Array&lt;int&gt;* vtable_indices = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), len, CHECK_NULL);
 529   assert(default_vtable_indices() == NULL, &quot;only create once&quot;);
 530   set_default_vtable_indices(vtable_indices);
 531   return vtable_indices;
 532 }
 533 
 534 InstanceKlass::InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id) :
 535   Klass(id),
 536   _nest_members(NULL),
 537   _nest_host(NULL),
 538   _permitted_subclasses(NULL),
 539   _record_components(NULL),
 540   _static_field_size(parser.static_field_size()),
 541   _nonstatic_oop_map_size(nonstatic_oop_map_size(parser.total_oop_map_count())),
 542   _itable_len(parser.itable_size()),
 543   _nest_host_index(0),
 544   _init_state(allocated),
 545   _reference_type(parser.reference_type()),
<span class="line-modified"> 546   _init_thread(NULL)</span>


 547 {
 548   set_vtable_length(parser.vtable_size());
 549   set_kind(kind);
 550   set_access_flags(parser.access_flags());
 551   if (parser.is_hidden()) set_is_hidden();
 552   set_is_unsafe_anonymous(parser.is_unsafe_anonymous());
 553   set_layout_helper(Klass::instance_layout_helper(parser.layout_size(),
 554                                                     false));




 555 
<span class="line-modified"> 556   assert(NULL == _methods, &quot;underlying memory not zeroed?&quot;);</span>
<span class="line-modified"> 557   assert(is_instance_klass(), &quot;is layout incorrect?&quot;);</span>
<span class="line-modified"> 558   assert(size_helper() == parser.layout_size(), &quot;incorrect size_helper?&quot;);</span>
 559 
 560   // Set biased locking bit for all instances of this class; it will be
 561   // cleared if revocation occurs too often for this type
 562   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {
 563     set_prototype_header(markWord::biased_locking_prototype());
 564   }



 565 }
 566 
 567 void InstanceKlass::deallocate_methods(ClassLoaderData* loader_data,
 568                                        Array&lt;Method*&gt;* methods) {
 569   if (methods != NULL &amp;&amp; methods != Universe::the_empty_method_array() &amp;&amp;
 570       !methods-&gt;is_shared()) {
 571     for (int i = 0; i &lt; methods-&gt;length(); i++) {
 572       Method* method = methods-&gt;at(i);
 573       if (method == NULL) continue;  // maybe null if error processing
 574       // Only want to delete methods that are not executing for RedefineClasses.
 575       // The previous version will point to them so they&#39;re not totally dangling
 576       assert (!method-&gt;on_stack(), &quot;shouldn&#39;t be called with methods on stack&quot;);
 577       MetadataFactory::free_metadata(loader_data, method);
 578     }
 579     MetadataFactory::free_array&lt;Method*&gt;(loader_data, methods);
 580   }
 581 }
 582 
 583 void InstanceKlass::deallocate_interfaces(ClassLoaderData* loader_data,
 584                                           const Klass* super_klass,
 585                                           Array&lt;InstanceKlass*&gt;* local_interfaces,
 586                                           Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
 587   // Only deallocate transitive interfaces if not empty, same as super class
 588   // or same as local interfaces.  See code in parseClassFile.
 589   Array&lt;InstanceKlass*&gt;* ti = transitive_interfaces;
 590   if (ti != Universe::the_empty_instance_klass_array() &amp;&amp; ti != local_interfaces) {
 591     // check that the interfaces don&#39;t come from super class
 592     Array&lt;InstanceKlass*&gt;* sti = (super_klass == NULL) ? NULL :
 593                     InstanceKlass::cast(super_klass)-&gt;transitive_interfaces();
<span class="line-modified"> 594     if (ti != sti &amp;&amp; ti != NULL &amp;&amp; !ti-&gt;is_shared()) {</span>

 595       MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, ti);
 596     }
 597   }
 598 
 599   // local interfaces can be empty
 600   if (local_interfaces != Universe::the_empty_instance_klass_array() &amp;&amp;
<span class="line-modified"> 601       local_interfaces != NULL &amp;&amp; !local_interfaces-&gt;is_shared()) {</span>

 602     MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, local_interfaces);
 603   }
 604 }
 605 
 606 void InstanceKlass::deallocate_record_components(ClassLoaderData* loader_data,
 607                                                  Array&lt;RecordComponent*&gt;* record_components) {
 608   if (record_components != NULL &amp;&amp; !record_components-&gt;is_shared()) {
 609     for (int i = 0; i &lt; record_components-&gt;length(); i++) {
 610       RecordComponent* record_component = record_components-&gt;at(i);
 611       MetadataFactory::free_metadata(loader_data, record_component);
 612     }
 613     MetadataFactory::free_array&lt;RecordComponent*&gt;(loader_data, record_components);
 614   }
 615 }
 616 
 617 // This function deallocates the metadata and C heap pointers that the
 618 // InstanceKlass points to.
 619 void InstanceKlass::deallocate_contents(ClassLoaderData* loader_data) {
 620 
 621   // Orphan the mirror first, CMS thinks it&#39;s still live.
</pre>
<hr />
<pre>
 909         vmSymbols::java_lang_IncompatibleClassChangeError(),
 910         &quot;class %s has interface %s as super class&quot;,
 911         external_name(),
 912         super_klass-&gt;external_name()
 913       );
 914       return false;
 915     }
 916 
 917     InstanceKlass* ik_super = InstanceKlass::cast(super_klass);
 918     ik_super-&gt;link_class_impl(CHECK_false);
 919   }
 920 
 921   // link all interfaces implemented by this class before linking this class
 922   Array&lt;InstanceKlass*&gt;* interfaces = local_interfaces();
 923   int num_interfaces = interfaces-&gt;length();
 924   for (int index = 0; index &lt; num_interfaces; index++) {
 925     InstanceKlass* interk = interfaces-&gt;at(index);
 926     interk-&gt;link_class_impl(CHECK_false);
 927   }
 928 
























































 929   // in case the class is linked in the process of linking its superclasses
 930   if (is_linked()) {
 931     return true;
 932   }
 933 
 934   // trace only the link time for this klass that includes
 935   // the verification time
 936   PerfClassTraceTime vmtimer(ClassLoader::perf_class_link_time(),
 937                              ClassLoader::perf_class_link_selftime(),
 938                              ClassLoader::perf_classes_linked(),
 939                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
 940                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
 941                              PerfClassTraceTime::CLASS_LINK);
 942 
 943   // verification &amp; rewriting
 944   {
 945     HandleMark hm(THREAD);
 946     Handle h_init_lock(THREAD, init_lock());
 947     ObjectLocker ol(h_init_lock, THREAD, h_init_lock() != NULL);
 948     // rewritten will have been set if loader constraint error found
</pre>
<hr />
<pre>
 980       // fabricate new Method*s.
 981       // also does loader constraint checking
 982       //
 983       // initialize_vtable and initialize_itable need to be rerun
 984       // for a shared class if
 985       // 1) the class is loaded by custom class loader or
 986       // 2) the class is loaded by built-in class loader but failed to add archived loader constraints
 987       bool need_init_table = true;
 988       if (is_shared() &amp;&amp; SystemDictionaryShared::check_linking_constraints(this, THREAD)) {
 989         need_init_table = false;
 990       }
 991       if (need_init_table) {
 992         vtable().initialize_vtable(true, CHECK_false);
 993         itable().initialize_itable(true, CHECK_false);
 994       }
 995 #ifdef ASSERT
 996       vtable().verify(tty, true);
 997       // In case itable verification is ever added.
 998       // itable().verify(tty, true);
 999 #endif

1000       set_init_state(linked);
1001       if (JvmtiExport::should_post_class_prepare()) {
1002         Thread *thread = THREAD;
1003         assert(thread-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1004         JvmtiExport::post_class_prepare((JavaThread *) thread, this);
1005       }
1006     }
1007   }
1008   return true;
1009 }
1010 
1011 // Rewrite the byte codes of all of the methods of a class.
1012 // The rewriter must be called exactly once. Rewriting must happen after
1013 // verification but before the first method of the class is executed.
1014 void InstanceKlass::rewrite_class(TRAPS) {
1015   assert(is_loaded(), &quot;must be loaded&quot;);
1016   if (is_rewritten()) {
1017     assert(is_shared(), &quot;rewriting an unshared class?&quot;);
1018     return;
1019   }
</pre>
<hr />
<pre>
1133     // having a superinterface that declares, non-static, concrete methods
1134     if (!HAS_PENDING_EXCEPTION &amp;&amp; has_nonstatic_concrete_methods()) {
1135       initialize_super_interfaces(THREAD);
1136     }
1137 
1138     // If any exceptions, complete abruptly, throwing the same exception as above.
1139     if (HAS_PENDING_EXCEPTION) {
1140       Handle e(THREAD, PENDING_EXCEPTION);
1141       CLEAR_PENDING_EXCEPTION;
1142       {
1143         EXCEPTION_MARK;
1144         // Locks object, set state, and notify all waiting threads
1145         set_initialization_state_and_notify(initialization_error, THREAD);
1146         CLEAR_PENDING_EXCEPTION;
1147       }
1148       DTRACE_CLASSINIT_PROBE_WAIT(super__failed, -1, wait);
1149       THROW_OOP(e());
1150     }
1151   }
1152 































1153 
1154   // Look for aot compiled methods for this klass, including class initializer.
1155   AOTLoader::load_for_klass(this, THREAD);
1156 
<span class="line-modified">1157   // Step 8</span>
1158   {
1159     DTRACE_CLASSINIT_PROBE_WAIT(clinit, -1, wait);
1160     // Timer includes any side effects of class initialization (resolution,
1161     // etc), but not recursive entry into call_class_initializer().
1162     PerfClassTraceTime timer(ClassLoader::perf_class_init_time(),
1163                              ClassLoader::perf_class_init_selftime(),
1164                              ClassLoader::perf_classes_inited(),
1165                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
1166                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
1167                              PerfClassTraceTime::CLASS_CLINIT);
1168     call_class_initializer(THREAD);
1169   }
1170 
<span class="line-modified">1171   // Step 9</span>
1172   if (!HAS_PENDING_EXCEPTION) {
1173     set_initialization_state_and_notify(fully_initialized, CHECK);
1174     {
1175       debug_only(vtable().verify(tty, true);)
1176     }
1177   }
1178   else {
<span class="line-modified">1179     // Step 10 and 11</span>
1180     Handle e(THREAD, PENDING_EXCEPTION);
1181     CLEAR_PENDING_EXCEPTION;
1182     // JVMTI has already reported the pending exception
1183     // JVMTI internal flag reset is needed in order to report ExceptionInInitializerError
1184     JvmtiExport::clear_detected_exception(jt);
1185     {
1186       EXCEPTION_MARK;
1187       set_initialization_state_and_notify(initialization_error, THREAD);
1188       CLEAR_PENDING_EXCEPTION;   // ignore any exception thrown, class initialization error is thrown below
1189       // JVMTI has already reported the pending exception
1190       // JVMTI internal flag reset is needed in order to report ExceptionInInitializerError
1191       JvmtiExport::clear_detected_exception(jt);
1192     }
1193     DTRACE_CLASSINIT_PROBE_WAIT(error, -1, wait);
1194     if (e-&gt;is_a(SystemDictionary::Error_klass())) {
1195       THROW_OOP(e());
1196     } else {
1197       JavaCallArguments args(e);
1198       THROW_ARG(vmSymbols::java_lang_ExceptionInInitializerError(),
1199                 vmSymbols::throwable_void_signature(),
</pre>
<hr />
<pre>
1447       }
1448     }
1449   }
1450   // _this will always be set at this point
1451   ObjArrayKlass* oak = array_klasses();
1452   if (or_null) {
1453     return oak-&gt;array_klass_or_null(n);
1454   }
1455   return oak-&gt;array_klass(n, THREAD);
1456 }
1457 
1458 Klass* InstanceKlass::array_klass_impl(bool or_null, TRAPS) {
1459   return array_klass_impl(or_null, 1, THREAD);
1460 }
1461 
1462 static int call_class_initializer_counter = 0;   // for debugging
1463 
1464 Method* InstanceKlass::class_initializer() const {
1465   Method* clinit = find_method(
1466       vmSymbols::class_initializer_name(), vmSymbols::void_method_signature());
<span class="line-modified">1467   if (clinit != NULL &amp;&amp; clinit-&gt;has_valid_initializer_flags()) {</span>
1468     return clinit;
1469   }
1470   return NULL;
1471 }
1472 
1473 void InstanceKlass::call_class_initializer(TRAPS) {
1474   if (ReplayCompiles &amp;&amp;
1475       (ReplaySuppressInitializers == 1 ||
1476        (ReplaySuppressInitializers &gt;= 2 &amp;&amp; class_loader() != NULL))) {
1477     // Hide the existence of the initializer for the purpose of replaying the compile
1478     return;
1479   }
1480 
1481   methodHandle h_method(THREAD, class_initializer());
1482   assert(!is_initialized(), &quot;we cannot initialize twice&quot;);
1483   LogTarget(Info, class, init) lt;
1484   if (lt.is_enabled()) {
1485     ResourceMark rm(THREAD);
1486     LogStream ls(lt);
1487     ls.print(&quot;%d Initializing &quot;, call_class_initializer_counter++);
1488     name()-&gt;print_value_on(&amp;ls);
1489     ls.print_cr(&quot;%s (&quot; INTPTR_FORMAT &quot;)&quot;, h_method() == NULL ? &quot;(no method)&quot; : &quot;&quot;, p2i(this));
1490   }
1491   if (h_method() != NULL) {
1492     JavaCallArguments args; // No arguments
1493     JavaValue result(T_VOID);
1494     JavaCalls::call(&amp;result, h_method, &amp;args, CHECK); // Static call (no args)
1495   }
1496 }
1497 
1498 
1499 void InstanceKlass::mask_for(const methodHandle&amp; method, int bci,
1500   InterpreterOopMap* entry_for) {
1501   // Lazily create the _oop_map_cache at first request
1502   // Lock-free access requires load_acquire.
1503   OopMapCache* oop_map_cache = Atomic::load_acquire(&amp;_oop_map_cache);
1504   if (oop_map_cache == NULL) {
<span class="line-modified">1505     MutexLocker x(OopMapCacheAlloc_lock);</span>
1506     // Check if _oop_map_cache was allocated while we were waiting for this lock
1507     if ((oop_map_cache = _oop_map_cache) == NULL) {
1508       oop_map_cache = new OopMapCache();
1509       // Ensure _oop_map_cache is stable, since it is examined without a lock
1510       Atomic::release_store(&amp;_oop_map_cache, oop_map_cache);
1511     }
1512   }
1513   // _oop_map_cache is constant after init; lookup below does its own locking.
1514   oop_map_cache-&gt;lookup(method, bci, entry_for);
1515 }
1516 
<span class="line-removed">1517 bool InstanceKlass::contains_field_offset(int offset) {</span>
<span class="line-removed">1518   fieldDescriptor fd;</span>
<span class="line-removed">1519   return find_field_from_offset(offset, false, &amp;fd);</span>
<span class="line-removed">1520 }</span>
<span class="line-removed">1521 </span>
1522 bool InstanceKlass::find_local_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
1523   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
1524     Symbol* f_name = fs.name();
1525     Symbol* f_sig  = fs.signature();
1526     if (f_name == name &amp;&amp; f_sig == sig) {
1527       fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
1528       return true;
1529     }
1530   }
1531   return false;
1532 }
1533 
1534 
1535 Klass* InstanceKlass::find_interface_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
1536   const int n = local_interfaces()-&gt;length();
1537   for (int i = 0; i &lt; n; i++) {
1538     Klass* intf1 = local_interfaces()-&gt;at(i);
1539     assert(intf1-&gt;is_interface(), &quot;just checking type&quot;);
1540     // search for field in current interface
1541     if (InstanceKlass::cast(intf1)-&gt;find_local_field(name, sig, fd)) {
</pre>
<hr />
<pre>
1572 
1573 Klass* InstanceKlass::find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const {
1574   // search order according to newest JVM spec (5.4.3.2, p.167).
1575   // 1) search for field in current klass
1576   if (find_local_field(name, sig, fd)) {
1577     if (fd-&gt;is_static() == is_static) return const_cast&lt;InstanceKlass*&gt;(this);
1578   }
1579   // 2) search for field recursively in direct superinterfaces
1580   if (is_static) {
1581     Klass* intf = find_interface_field(name, sig, fd);
1582     if (intf != NULL) return intf;
1583   }
1584   // 3) apply field lookup recursively if superclass exists
1585   { Klass* supr = super();
1586     if (supr != NULL) return InstanceKlass::cast(supr)-&gt;find_field(name, sig, is_static, fd);
1587   }
1588   // 4) otherwise field lookup fails
1589   return NULL;
1590 }
1591 









1592 
1593 bool InstanceKlass::find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
1594   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
1595     if (fs.offset() == offset) {
1596       fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
1597       if (fd-&gt;is_static() == is_static) return true;
1598     }
1599   }
1600   return false;
1601 }
1602 
1603 
1604 bool InstanceKlass::find_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
1605   Klass* klass = const_cast&lt;InstanceKlass*&gt;(this);
1606   while (klass != NULL) {
1607     if (InstanceKlass::cast(klass)-&gt;find_local_field_from_offset(offset, is_static, fd)) {
1608       return true;
1609     }
1610     klass = klass-&gt;super();
1611   }
</pre>
<hr />
<pre>
1956 }
1957 
1958 // uncached_lookup_method searches both the local class methods array and all
1959 // superclasses methods arrays, skipping any overpass methods in superclasses,
1960 // and possibly skipping private methods.
1961 Method* InstanceKlass::uncached_lookup_method(const Symbol* name,
1962                                               const Symbol* signature,
1963                                               OverpassLookupMode overpass_mode,
1964                                               PrivateLookupMode private_mode) const {
1965   OverpassLookupMode overpass_local_mode = overpass_mode;
1966   const Klass* klass = this;
1967   while (klass != NULL) {
1968     Method* const method = InstanceKlass::cast(klass)-&gt;find_method_impl(name,
1969                                                                         signature,
1970                                                                         overpass_local_mode,
1971                                                                         find_static,
1972                                                                         private_mode);
1973     if (method != NULL) {
1974       return method;
1975     }



1976     klass = klass-&gt;super();
1977     overpass_local_mode = skip_overpass;   // Always ignore overpass methods in superclasses
1978   }
1979   return NULL;
1980 }
1981 
1982 #ifdef ASSERT
1983 // search through class hierarchy and return true if this class or
1984 // one of the superclasses was redefined
1985 bool InstanceKlass::has_redefined_this_or_super() const {
1986   const Klass* klass = this;
1987   while (klass != NULL) {
1988     if (InstanceKlass::cast(klass)-&gt;has_been_redefined()) {
1989       return true;
1990     }
1991     klass = klass-&gt;super();
1992   }
1993   return false;
1994 }
1995 #endif
</pre>
<hr />
<pre>
2538 }
2539 
2540 void InstanceKlass::remove_java_mirror() {
2541   Klass::remove_java_mirror();
2542 
2543   // do array classes also.
2544   if (array_klasses() != NULL) {
2545     array_klasses()-&gt;remove_java_mirror();
2546   }
2547 }
2548 
2549 void InstanceKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain,
2550                                              PackageEntry* pkg_entry, TRAPS) {
2551   // SystemDictionary::add_to_hierarchy() sets the init_state to loaded
2552   // before the InstanceKlass is added to the SystemDictionary. Make
2553   // sure the current state is &lt;loaded.
2554   assert(!is_loaded(), &quot;invalid init state&quot;);
2555   set_package(loader_data, pkg_entry, CHECK);
2556   Klass::restore_unshareable_info(loader_data, protection_domain, CHECK);
2557 




2558   Array&lt;Method*&gt;* methods = this-&gt;methods();
2559   int num_methods = methods-&gt;length();
2560   for (int index = 0; index &lt; num_methods; ++index) {
2561     methods-&gt;at(index)-&gt;restore_unshareable_info(CHECK);
2562   }
2563   if (JvmtiExport::has_redefined_a_class()) {
2564     // Reinitialize vtable because RedefineClasses may have changed some
2565     // entries in this vtable for super classes so the CDS vtable might
2566     // point to old or obsolete entries.  RedefineClasses doesn&#39;t fix up
2567     // vtables in the shared system dictionary, only the main one.
2568     // It also redefines the itable too so fix that too.
2569     vtable().initialize_vtable(false, CHECK);
2570     itable().initialize_itable(false, CHECK);
2571   }
2572 
2573   // restore constant pool resolved references
2574   constants()-&gt;restore_unshareable_info(CHECK);
2575 
2576   if (array_klasses() != NULL) {
2577     // Array classes have null protection domain.
2578     // --&gt; see ArrayKlass::complete_create_array_klass()
2579     array_klasses()-&gt;restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);
2580   }
2581 
2582   // Initialize current biased locking state.
<span class="line-modified">2583   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {</span>
2584     set_prototype_header(markWord::biased_locking_prototype());
2585   }
2586 }
2587 
2588 void InstanceKlass::set_shared_class_loader_type(s2 loader_type) {
2589   switch (loader_type) {
2590   case ClassLoader::BOOT_LOADER:
2591     _misc_flags |= _misc_is_shared_boot_class;
2592     break;
2593   case ClassLoader::PLATFORM_LOADER:
2594     _misc_flags |= _misc_is_shared_platform_class;
2595     break;
2596   case ClassLoader::APP_LOADER:
2597     _misc_flags |= _misc_is_shared_app_class;
2598     break;
2599   default:
2600     ShouldNotReachHere();
2601     break;
2602   }
2603 }
</pre>
<hr />
<pre>
2728   }
2729 }
2730 
2731 const char* InstanceKlass::signature_name() const {
2732   int hash_len = 0;
2733   char hash_buf[40];
2734 
2735   // If this is an unsafe anonymous class, append a hash to make the name unique
2736   if (is_unsafe_anonymous()) {
2737     intptr_t hash = (java_mirror() != NULL) ? java_mirror()-&gt;identity_hash() : 0;
2738     jio_snprintf(hash_buf, sizeof(hash_buf), &quot;/&quot; UINTX_FORMAT, (uintx)hash);
2739     hash_len = (int)strlen(hash_buf);
2740   }
2741 
2742   // Get the internal name as a c string
2743   const char* src = (const char*) (name()-&gt;as_C_string());
2744   const int src_length = (int)strlen(src);
2745 
2746   char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);
2747 
<span class="line-modified">2748   // Add L as type indicator</span>
2749   int dest_index = 0;
<span class="line-modified">2750   dest[dest_index++] = JVM_SIGNATURE_CLASS;</span>
2751 
2752   // Add the actual class name
2753   for (int src_index = 0; src_index &lt; src_length; ) {
2754     dest[dest_index++] = src[src_index++];
2755   }
2756 
2757   if (is_hidden()) { // Replace the last &#39;+&#39; with a &#39;.&#39;.
2758     for (int index = (int)src_length; index &gt; 0; index--) {
2759       if (dest[index] == &#39;+&#39;) {
2760         dest[index] = JVM_SIGNATURE_DOT;
2761         break;
2762       }
2763     }
2764   }
2765 
2766   // If we have a hash, append it
2767   for (int hash_index = 0; hash_index &lt; hash_len; ) {
2768     dest[dest_index++] = hash_buf[hash_index++];
2769   }
2770 
</pre>
<hr />
<pre>
3290   }
3291 
3292   assert(match_level == false || best == NULL, &quot;shouldn&#39;t pick up anything if match_level is set&quot;);
3293   if (best != NULL &amp;&amp; best-&gt;comp_level() &gt;= comp_level) {
3294     return best;
3295   }
3296   return NULL;
3297 }
3298 
3299 // -----------------------------------------------------------------------------------------------------
3300 // Printing
3301 
3302 #ifndef PRODUCT
3303 
3304 #define BULLET  &quot; - &quot;
3305 
3306 static const char* state_names[] = {
3307   &quot;allocated&quot;, &quot;loaded&quot;, &quot;linked&quot;, &quot;being_initialized&quot;, &quot;fully_initialized&quot;, &quot;initialization_error&quot;
3308 };
3309 
<span class="line-modified">3310 static void print_vtable(intptr_t* start, int len, outputStream* st) {</span>



3311   for (int i = 0; i &lt; len; i++) {
3312     intptr_t e = start[i];
3313     st-&gt;print(&quot;%d : &quot; INTPTR_FORMAT, i, e);





3314     if (MetaspaceObj::is_valid((Metadata*)e)) {
3315       st-&gt;print(&quot; &quot;);
3316       ((Metadata*)e)-&gt;print_value_on(st);






3317     }
3318     st-&gt;cr();
3319   }
3320 }
3321 
3322 static void print_vtable(vtableEntry* start, int len, outputStream* st) {
<span class="line-modified">3323   return print_vtable(reinterpret_cast&lt;intptr_t*&gt;(start), len, st);</span>





















3324 }
3325 
3326 void InstanceKlass::print_on(outputStream* st) const {
3327   assert(is_klass(), &quot;must be klass&quot;);
3328   Klass::print_on(st);
3329 
3330   st-&gt;print(BULLET&quot;instance size:     %d&quot;, size_helper());                        st-&gt;cr();
3331   st-&gt;print(BULLET&quot;klass size:        %d&quot;, size());                               st-&gt;cr();
3332   st-&gt;print(BULLET&quot;access:            &quot;); access_flags().print_on(st);            st-&gt;cr();

3333   st-&gt;print(BULLET&quot;state:             &quot;); st-&gt;print_cr(&quot;%s&quot;, state_names[_init_state]);
3334   st-&gt;print(BULLET&quot;name:              &quot;); name()-&gt;print_value_on(st);             st-&gt;cr();
3335   st-&gt;print(BULLET&quot;super:             &quot;); Metadata::print_value_on_maybe_null(st, super()); st-&gt;cr();
3336   st-&gt;print(BULLET&quot;sub:               &quot;);
3337   Klass* sub = subklass();
3338   int n;
3339   for (n = 0; sub != NULL; n++, sub = sub-&gt;next_sibling()) {
3340     if (n &lt; MaxSubklassPrintSize) {
3341       sub-&gt;print_value_on(st);
3342       st-&gt;print(&quot;   &quot;);
3343     }
3344   }
3345   if (n &gt;= MaxSubklassPrintSize) st-&gt;print(&quot;(&quot; INTX_FORMAT &quot; more klasses...)&quot;, n - MaxSubklassPrintSize);
3346   st-&gt;cr();
3347 
3348   if (is_interface()) {
3349     st-&gt;print_cr(BULLET&quot;nof implementors:  %d&quot;, nof_implementors());
3350     if (nof_implementors() == 1) {
3351       st-&gt;print_cr(BULLET&quot;implementor:    &quot;);
3352       st-&gt;print(&quot;   &quot;);
3353       implementor()-&gt;print_value_on(st);
3354       st-&gt;cr();
3355     }
3356   }
3357 
3358   st-&gt;print(BULLET&quot;arrays:            &quot;); Metadata::print_value_on_maybe_null(st, array_klasses()); st-&gt;cr();
<span class="line-modified">3359   st-&gt;print(BULLET&quot;methods:           &quot;); methods()-&gt;print_value_on(st);                  st-&gt;cr();</span>
<span class="line-modified">3360   if (Verbose || WizardMode) {</span>
<span class="line-modified">3361     Array&lt;Method*&gt;* method_array = methods();</span>
<span class="line-removed">3362     for (int i = 0; i &lt; method_array-&gt;length(); i++) {</span>
<span class="line-removed">3363       st-&gt;print(&quot;%d : &quot;, i); method_array-&gt;at(i)-&gt;print_value(); st-&gt;cr();</span>
<span class="line-removed">3364     }</span>
<span class="line-removed">3365   }</span>
<span class="line-removed">3366   st-&gt;print(BULLET&quot;method ordering:   &quot;); method_ordering()-&gt;print_value_on(st);      st-&gt;cr();</span>
<span class="line-removed">3367   st-&gt;print(BULLET&quot;default_methods:   &quot;); default_methods()-&gt;print_value_on(st);      st-&gt;cr();</span>
<span class="line-removed">3368   if (Verbose &amp;&amp; default_methods() != NULL) {</span>
<span class="line-removed">3369     Array&lt;Method*&gt;* method_array = default_methods();</span>
<span class="line-removed">3370     for (int i = 0; i &lt; method_array-&gt;length(); i++) {</span>
<span class="line-removed">3371       st-&gt;print(&quot;%d : &quot;, i); method_array-&gt;at(i)-&gt;print_value(); st-&gt;cr();</span>
<span class="line-removed">3372     }</span>
<span class="line-removed">3373   }</span>
3374   if (default_vtable_indices() != NULL) {
<span class="line-modified">3375     st-&gt;print(BULLET&quot;default vtable indices:   &quot;); default_vtable_indices()-&gt;print_value_on(st);       st-&gt;cr();</span>
3376   }
<span class="line-modified">3377   st-&gt;print(BULLET&quot;local interfaces:  &quot;); local_interfaces()-&gt;print_value_on(st);      st-&gt;cr();</span>
<span class="line-modified">3378   st-&gt;print(BULLET&quot;trans. interfaces: &quot;); transitive_interfaces()-&gt;print_value_on(st); st-&gt;cr();</span>
3379   st-&gt;print(BULLET&quot;constants:         &quot;); constants()-&gt;print_value_on(st);         st-&gt;cr();
3380   if (class_loader_data() != NULL) {
3381     st-&gt;print(BULLET&quot;class loader data:  &quot;);
3382     class_loader_data()-&gt;print_value_on(st);
3383     st-&gt;cr();
3384   }
3385   st-&gt;print(BULLET&quot;unsafe anonymous host class:        &quot;); Metadata::print_value_on_maybe_null(st, unsafe_anonymous_host()); st-&gt;cr();
3386   if (source_file_name() != NULL) {
3387     st-&gt;print(BULLET&quot;source file:       &quot;);
3388     source_file_name()-&gt;print_value_on(st);
3389     st-&gt;cr();
3390   }
3391   if (source_debug_extension() != NULL) {
3392     st-&gt;print(BULLET&quot;source debug extension:       &quot;);
3393     st-&gt;print(&quot;%s&quot;, source_debug_extension());
3394     st-&gt;cr();
3395   }
3396   st-&gt;print(BULLET&quot;class annotations:       &quot;); class_annotations()-&gt;print_value_on(st); st-&gt;cr();
3397   st-&gt;print(BULLET&quot;class type annotations:  &quot;); class_type_annotations()-&gt;print_value_on(st); st-&gt;cr();
3398   st-&gt;print(BULLET&quot;field annotations:       &quot;); fields_annotations()-&gt;print_value_on(st); st-&gt;cr();
</pre>
<hr />
<pre>
3415     st-&gt;print(BULLET&quot;generic signature: &quot;);
3416     generic_signature()-&gt;print_value_on(st);
3417     st-&gt;cr();
3418   }
3419   st-&gt;print(BULLET&quot;inner classes:     &quot;); inner_classes()-&gt;print_value_on(st);     st-&gt;cr();
3420   st-&gt;print(BULLET&quot;nest members:     &quot;); nest_members()-&gt;print_value_on(st);     st-&gt;cr();
3421   if (record_components() != NULL) {
3422     st-&gt;print(BULLET&quot;record components:     &quot;); record_components()-&gt;print_value_on(st);     st-&gt;cr();
3423   }
3424   st-&gt;print(BULLET&quot;permitted subclasses:     &quot;); permitted_subclasses()-&gt;print_value_on(st);     st-&gt;cr();
3425   if (java_mirror() != NULL) {
3426     st-&gt;print(BULLET&quot;java mirror:       &quot;);
3427     java_mirror()-&gt;print_value_on(st);
3428     st-&gt;cr();
3429   } else {
3430     st-&gt;print_cr(BULLET&quot;java mirror:       NULL&quot;);
3431   }
3432   st-&gt;print(BULLET&quot;vtable length      %d  (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, vtable_length(), p2i(start_of_vtable())); st-&gt;cr();
3433   if (vtable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(start_of_vtable(), vtable_length(), st);
3434   st-&gt;print(BULLET&quot;itable length      %d (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, itable_length(), p2i(start_of_itable())); st-&gt;cr();
<span class="line-modified">3435   if (itable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(start_of_itable(), itable_length(), st);</span>
3436   st-&gt;print_cr(BULLET&quot;---- static fields (%d words):&quot;, static_field_size());
3437   FieldPrinter print_static_field(st);
3438   ((InstanceKlass*)this)-&gt;do_local_static_fields(&amp;print_static_field);
3439   st-&gt;print_cr(BULLET&quot;---- non-static fields (%d words):&quot;, nonstatic_field_size());
3440   FieldPrinter print_nonstatic_field(st);
3441   InstanceKlass* ik = const_cast&lt;InstanceKlass*&gt;(this);
3442   ik-&gt;do_nonstatic_fields(&amp;print_nonstatic_field);
3443 
3444   st-&gt;print(BULLET&quot;non-static oop maps: &quot;);
3445   OopMapBlock* map     = start_of_nonstatic_oop_maps();
3446   OopMapBlock* end_map = map + nonstatic_oop_map_count();
3447   while (map &lt; end_map) {
3448     st-&gt;print(&quot;%d-%d &quot;, map-&gt;offset(), map-&gt;offset() + heapOopSize*(map-&gt;count() - 1));
3449     map++;
3450   }
3451   st-&gt;cr();
3452 }
3453 
3454 #endif //PRODUCT
3455 
</pre>
<hr />
<pre>
4151   if (holder == NULL) {
4152     return NULL; // The version of klass is gone, no method is found
4153   }
4154   Method* method = holder-&gt;method_with_orig_idnum(idnum);
4155   return method;
4156 }
4157 
4158 #if INCLUDE_JVMTI
4159 JvmtiCachedClassFileData* InstanceKlass::get_cached_class_file() {
4160   return _cached_class_file;
4161 }
4162 
4163 jint InstanceKlass::get_cached_class_file_len() {
4164   return VM_RedefineClasses::get_cached_class_file_len(_cached_class_file);
4165 }
4166 
4167 unsigned char * InstanceKlass::get_cached_class_file_bytes() {
4168   return VM_RedefineClasses::get_cached_class_file_bytes(_cached_class_file);
4169 }
4170 #endif





</pre>
</td>
<td>
<hr />
<pre>
  48 #include &quot;logging/logStream.hpp&quot;
  49 #include &quot;memory/allocation.inline.hpp&quot;
  50 #include &quot;memory/iterator.inline.hpp&quot;
  51 #include &quot;memory/metadataFactory.hpp&quot;
  52 #include &quot;memory/metaspaceClosure.hpp&quot;
  53 #include &quot;memory/metaspaceShared.hpp&quot;
  54 #include &quot;memory/oopFactory.hpp&quot;
  55 #include &quot;memory/resourceArea.hpp&quot;
  56 #include &quot;memory/universe.hpp&quot;
  57 #include &quot;oops/fieldStreams.inline.hpp&quot;
  58 #include &quot;oops/constantPool.hpp&quot;
  59 #include &quot;oops/instanceClassLoaderKlass.hpp&quot;
  60 #include &quot;oops/instanceKlass.inline.hpp&quot;
  61 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  62 #include &quot;oops/instanceOop.hpp&quot;
  63 #include &quot;oops/klass.inline.hpp&quot;
  64 #include &quot;oops/method.hpp&quot;
  65 #include &quot;oops/oop.inline.hpp&quot;
  66 #include &quot;oops/recordComponent.hpp&quot;
  67 #include &quot;oops/symbol.hpp&quot;
<span class="line-added">  68 #include &quot;oops/valueKlass.hpp&quot;</span>
  69 #include &quot;prims/jvmtiExport.hpp&quot;
  70 #include &quot;prims/jvmtiRedefineClasses.hpp&quot;
  71 #include &quot;prims/jvmtiThreadState.hpp&quot;
  72 #include &quot;prims/methodComparator.hpp&quot;
  73 #include &quot;runtime/atomic.hpp&quot;
  74 #include &quot;runtime/biasedLocking.hpp&quot;
  75 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  76 #include &quot;runtime/handles.inline.hpp&quot;
  77 #include &quot;runtime/javaCalls.hpp&quot;
  78 #include &quot;runtime/mutexLocker.hpp&quot;
  79 #include &quot;runtime/orderAccess.hpp&quot;
  80 #include &quot;runtime/thread.inline.hpp&quot;
  81 #include &quot;services/classLoadingService.hpp&quot;
  82 #include &quot;services/threadService.hpp&quot;
  83 #include &quot;utilities/dtrace.hpp&quot;
  84 #include &quot;utilities/events.hpp&quot;
  85 #include &quot;utilities/macros.hpp&quot;
  86 #include &quot;utilities/stringUtils.hpp&quot;
  87 #ifdef COMPILER1
  88 #include &quot;c1/c1_Compiler.hpp&quot;
</pre>
<hr />
<pre>
 457                               k-&gt;external_name());
 458   return access;
 459 }
 460 
 461 const char* InstanceKlass::nest_host_error(TRAPS) {
 462   if (_nest_host_index == 0) {
 463     return NULL;
 464   } else {
 465     constantPoolHandle cph(THREAD, constants());
 466     return SystemDictionary::find_nest_host_error(cph, (int)_nest_host_index);
 467   }
 468 }
 469 
 470 InstanceKlass* InstanceKlass::allocate_instance_klass(const ClassFileParser&amp; parser, TRAPS) {
 471   bool is_hidden_or_anonymous = parser.is_hidden() || parser.is_unsafe_anonymous();
 472   const int size = InstanceKlass::size(parser.vtable_size(),
 473                                        parser.itable_size(),
 474                                        nonstatic_oop_map_size(parser.total_oop_map_count()),
 475                                        parser.is_interface(),
 476                                        parser.is_unsafe_anonymous(),
<span class="line-modified"> 477                                        should_store_fingerprint(is_hidden_or_anonymous),</span>
<span class="line-added"> 478                                        parser.has_flattenable_fields() ? parser.java_fields_count() : 0,</span>
<span class="line-added"> 479                                        parser.is_inline_type());</span>
 480 
 481   const Symbol* const class_name = parser.class_name();
 482   assert(class_name != NULL, &quot;invariant&quot;);
 483   ClassLoaderData* loader_data = parser.loader_data();
 484   assert(loader_data != NULL, &quot;invariant&quot;);
 485 
 486   InstanceKlass* ik;
 487 
 488   // Allocation
 489   if (REF_NONE == parser.reference_type()) {
 490     if (class_name == vmSymbols::java_lang_Class()) {
 491       // mirror
 492       ik = new (loader_data, size, THREAD) InstanceMirrorKlass(parser);
<span class="line-modified"> 493     } else if (is_class_loader(class_name, parser)) {</span>

 494       // class loader
 495       ik = new (loader_data, size, THREAD) InstanceClassLoaderKlass(parser);
<span class="line-added"> 496     } else if (parser.is_inline_type()) {</span>
<span class="line-added"> 497       // inline type</span>
<span class="line-added"> 498       ik = new (loader_data, size, THREAD) ValueKlass(parser);</span>
 499     } else {
 500       // normal
 501       ik = new (loader_data, size, THREAD) InstanceKlass(parser, InstanceKlass::_kind_other);
 502     }
 503   } else {
 504     // reference
 505     ik = new (loader_data, size, THREAD) InstanceRefKlass(parser);
 506   }
 507 
 508   // Check for pending exception before adding to the loader data and incrementing
 509   // class count.  Can get OOM here.
 510   if (HAS_PENDING_EXCEPTION) {
 511     return NULL;
 512   }
 513 
<span class="line-added"> 514 #ifdef ASSERT</span>
<span class="line-added"> 515   assert(ik-&gt;size() == size, &quot;&quot;);</span>
<span class="line-added"> 516   ik-&gt;bounds_check((address) ik-&gt;start_of_vtable(), false, size);</span>
<span class="line-added"> 517   ik-&gt;bounds_check((address) ik-&gt;start_of_itable(), false, size);</span>
<span class="line-added"> 518   ik-&gt;bounds_check((address) ik-&gt;end_of_itable(), true, size);</span>
<span class="line-added"> 519   ik-&gt;bounds_check((address) ik-&gt;end_of_nonstatic_oop_maps(), true, size);</span>
<span class="line-added"> 520 #endif //ASSERT</span>
 521   return ik;
 522 }
 523 
<span class="line-added"> 524 #ifndef PRODUCT</span>
<span class="line-added"> 525 bool InstanceKlass::bounds_check(address addr, bool edge_ok, intptr_t size_in_bytes) const {</span>
<span class="line-added"> 526   const char* bad = NULL;</span>
<span class="line-added"> 527   address end = NULL;</span>
<span class="line-added"> 528   if (addr &lt; (address)this) {</span>
<span class="line-added"> 529     bad = &quot;before&quot;;</span>
<span class="line-added"> 530   } else if (addr == (address)this) {</span>
<span class="line-added"> 531     if (edge_ok)  return true;</span>
<span class="line-added"> 532     bad = &quot;just before&quot;;</span>
<span class="line-added"> 533   } else if (addr == (end = (address)this + sizeof(intptr_t) * (size_in_bytes &lt; 0 ? size() : size_in_bytes))) {</span>
<span class="line-added"> 534     if (edge_ok)  return true;</span>
<span class="line-added"> 535     bad = &quot;just after&quot;;</span>
<span class="line-added"> 536   } else if (addr &gt; end) {</span>
<span class="line-added"> 537     bad = &quot;after&quot;;</span>
<span class="line-added"> 538   } else {</span>
<span class="line-added"> 539     return true;</span>
<span class="line-added"> 540   }</span>
<span class="line-added"> 541   tty-&gt;print_cr(&quot;%s object bounds: &quot; INTPTR_FORMAT &quot; [&quot; INTPTR_FORMAT &quot;..&quot; INTPTR_FORMAT &quot;]&quot;,</span>
<span class="line-added"> 542       bad, (intptr_t)addr, (intptr_t)this, (intptr_t)end);</span>
<span class="line-added"> 543   Verbose = WizardMode = true; this-&gt;print(); //@@</span>
<span class="line-added"> 544   return false;</span>
<span class="line-added"> 545 }</span>
<span class="line-added"> 546 #endif //PRODUCT</span>
 547 
 548 // copy method ordering from resource area to Metaspace
 549 void InstanceKlass::copy_method_ordering(const intArray* m, TRAPS) {
 550   if (m != NULL) {
 551     // allocate a new array and copy contents (memcpy?)
 552     _method_ordering = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), m-&gt;length(), CHECK);
 553     for (int i = 0; i &lt; m-&gt;length(); i++) {
 554       _method_ordering-&gt;at_put(i, m-&gt;at(i));
 555     }
 556   } else {
 557     _method_ordering = Universe::the_empty_int_array();
 558   }
 559 }
 560 
 561 // create a new array of vtable_indices for default methods
 562 Array&lt;int&gt;* InstanceKlass::create_new_default_vtable_indices(int len, TRAPS) {
 563   Array&lt;int&gt;* vtable_indices = MetadataFactory::new_array&lt;int&gt;(class_loader_data(), len, CHECK_NULL);
 564   assert(default_vtable_indices() == NULL, &quot;only create once&quot;);
 565   set_default_vtable_indices(vtable_indices);
 566   return vtable_indices;
 567 }
 568 
 569 InstanceKlass::InstanceKlass(const ClassFileParser&amp; parser, unsigned kind, KlassID id) :
 570   Klass(id),
 571   _nest_members(NULL),
 572   _nest_host(NULL),
 573   _permitted_subclasses(NULL),
 574   _record_components(NULL),
 575   _static_field_size(parser.static_field_size()),
 576   _nonstatic_oop_map_size(nonstatic_oop_map_size(parser.total_oop_map_count())),
 577   _itable_len(parser.itable_size()),
 578   _nest_host_index(0),
 579   _init_state(allocated),
 580   _reference_type(parser.reference_type()),
<span class="line-modified"> 581   _init_thread(NULL),</span>
<span class="line-added"> 582   _value_field_klasses(NULL),</span>
<span class="line-added"> 583   _adr_valueklass_fixed_block(NULL)</span>
 584 {
 585   set_vtable_length(parser.vtable_size());
 586   set_kind(kind);
 587   set_access_flags(parser.access_flags());
 588   if (parser.is_hidden()) set_is_hidden();
 589   set_is_unsafe_anonymous(parser.is_unsafe_anonymous());
 590   set_layout_helper(Klass::instance_layout_helper(parser.layout_size(),
 591                                                     false));
<span class="line-added"> 592     if (parser.has_flattenable_fields()) {</span>
<span class="line-added"> 593       set_has_inline_fields();</span>
<span class="line-added"> 594     }</span>
<span class="line-added"> 595     _java_fields_count = parser.java_fields_count();</span>
 596 
<span class="line-modified"> 597     assert(NULL == _methods, &quot;underlying memory not zeroed?&quot;);</span>
<span class="line-modified"> 598     assert(is_instance_klass(), &quot;is layout incorrect?&quot;);</span>
<span class="line-modified"> 599     assert(size_helper() == parser.layout_size(), &quot;incorrect size_helper?&quot;);</span>
 600 
 601   // Set biased locking bit for all instances of this class; it will be
 602   // cleared if revocation occurs too often for this type
 603   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled()) {
 604     set_prototype_header(markWord::biased_locking_prototype());
 605   }
<span class="line-added"> 606   if (has_inline_fields()) {</span>
<span class="line-added"> 607     _value_field_klasses = (const Klass**) adr_value_fields_klasses();</span>
<span class="line-added"> 608   }</span>
 609 }
 610 
 611 void InstanceKlass::deallocate_methods(ClassLoaderData* loader_data,
 612                                        Array&lt;Method*&gt;* methods) {
 613   if (methods != NULL &amp;&amp; methods != Universe::the_empty_method_array() &amp;&amp;
 614       !methods-&gt;is_shared()) {
 615     for (int i = 0; i &lt; methods-&gt;length(); i++) {
 616       Method* method = methods-&gt;at(i);
 617       if (method == NULL) continue;  // maybe null if error processing
 618       // Only want to delete methods that are not executing for RedefineClasses.
 619       // The previous version will point to them so they&#39;re not totally dangling
 620       assert (!method-&gt;on_stack(), &quot;shouldn&#39;t be called with methods on stack&quot;);
 621       MetadataFactory::free_metadata(loader_data, method);
 622     }
 623     MetadataFactory::free_array&lt;Method*&gt;(loader_data, methods);
 624   }
 625 }
 626 
 627 void InstanceKlass::deallocate_interfaces(ClassLoaderData* loader_data,
 628                                           const Klass* super_klass,
 629                                           Array&lt;InstanceKlass*&gt;* local_interfaces,
 630                                           Array&lt;InstanceKlass*&gt;* transitive_interfaces) {
 631   // Only deallocate transitive interfaces if not empty, same as super class
 632   // or same as local interfaces.  See code in parseClassFile.
 633   Array&lt;InstanceKlass*&gt;* ti = transitive_interfaces;
 634   if (ti != Universe::the_empty_instance_klass_array() &amp;&amp; ti != local_interfaces) {
 635     // check that the interfaces don&#39;t come from super class
 636     Array&lt;InstanceKlass*&gt;* sti = (super_klass == NULL) ? NULL :
 637                     InstanceKlass::cast(super_klass)-&gt;transitive_interfaces();
<span class="line-modified"> 638     if (ti != sti &amp;&amp; ti != NULL &amp;&amp; !ti-&gt;is_shared() &amp;&amp;</span>
<span class="line-added"> 639         ti != Universe::the_single_IdentityObject_klass_array()) {</span>
 640       MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, ti);
 641     }
 642   }
 643 
 644   // local interfaces can be empty
 645   if (local_interfaces != Universe::the_empty_instance_klass_array() &amp;&amp;
<span class="line-modified"> 646       local_interfaces != NULL &amp;&amp; !local_interfaces-&gt;is_shared() &amp;&amp;</span>
<span class="line-added"> 647       local_interfaces != Universe::the_single_IdentityObject_klass_array()) {</span>
 648     MetadataFactory::free_array&lt;InstanceKlass*&gt;(loader_data, local_interfaces);
 649   }
 650 }
 651 
 652 void InstanceKlass::deallocate_record_components(ClassLoaderData* loader_data,
 653                                                  Array&lt;RecordComponent*&gt;* record_components) {
 654   if (record_components != NULL &amp;&amp; !record_components-&gt;is_shared()) {
 655     for (int i = 0; i &lt; record_components-&gt;length(); i++) {
 656       RecordComponent* record_component = record_components-&gt;at(i);
 657       MetadataFactory::free_metadata(loader_data, record_component);
 658     }
 659     MetadataFactory::free_array&lt;RecordComponent*&gt;(loader_data, record_components);
 660   }
 661 }
 662 
 663 // This function deallocates the metadata and C heap pointers that the
 664 // InstanceKlass points to.
 665 void InstanceKlass::deallocate_contents(ClassLoaderData* loader_data) {
 666 
 667   // Orphan the mirror first, CMS thinks it&#39;s still live.
</pre>
<hr />
<pre>
 955         vmSymbols::java_lang_IncompatibleClassChangeError(),
 956         &quot;class %s has interface %s as super class&quot;,
 957         external_name(),
 958         super_klass-&gt;external_name()
 959       );
 960       return false;
 961     }
 962 
 963     InstanceKlass* ik_super = InstanceKlass::cast(super_klass);
 964     ik_super-&gt;link_class_impl(CHECK_false);
 965   }
 966 
 967   // link all interfaces implemented by this class before linking this class
 968   Array&lt;InstanceKlass*&gt;* interfaces = local_interfaces();
 969   int num_interfaces = interfaces-&gt;length();
 970   for (int index = 0; index &lt; num_interfaces; index++) {
 971     InstanceKlass* interk = interfaces-&gt;at(index);
 972     interk-&gt;link_class_impl(CHECK_false);
 973   }
 974 
<span class="line-added"> 975 </span>
<span class="line-added"> 976   // If a class declares a method that uses an inline class as an argument</span>
<span class="line-added"> 977   // type or return inline type, this inline class must be loaded during the</span>
<span class="line-added"> 978   // linking of this class because size and properties of the inline class</span>
<span class="line-added"> 979   // must be known in order to be able to perform inline type optimizations.</span>
<span class="line-added"> 980   // The implementation below is an approximation of this rule, the code</span>
<span class="line-added"> 981   // iterates over all methods of the current class (including overridden</span>
<span class="line-added"> 982   // methods), not only the methods declared by this class. This</span>
<span class="line-added"> 983   // approximation makes the code simpler, and doesn&#39;t change the semantic</span>
<span class="line-added"> 984   // because classes declaring methods overridden by the current class are</span>
<span class="line-added"> 985   // linked (and have performed their own pre-loading) before the linking</span>
<span class="line-added"> 986   // of the current class.</span>
<span class="line-added"> 987 </span>
<span class="line-added"> 988 </span>
<span class="line-added"> 989   // Note:</span>
<span class="line-added"> 990   // Inline class types used for flattenable fields are loaded during</span>
<span class="line-added"> 991   // the loading phase (see ClassFileParser::post_process_parsed_stream()).</span>
<span class="line-added"> 992   // Inline class types used as element types for array creation</span>
<span class="line-added"> 993   // are not pre-loaded. Their loading is triggered by either anewarray</span>
<span class="line-added"> 994   // or multianewarray bytecodes.</span>
<span class="line-added"> 995 </span>
<span class="line-added"> 996   // Could it be possible to do the following processing only if the</span>
<span class="line-added"> 997   // class uses inline types?</span>
<span class="line-added"> 998   {</span>
<span class="line-added"> 999     ResourceMark rm(THREAD);</span>
<span class="line-added">1000     for (int i = 0; i &lt; methods()-&gt;length(); i++) {</span>
<span class="line-added">1001       Method* m = methods()-&gt;at(i);</span>
<span class="line-added">1002       for (SignatureStream ss(m-&gt;signature()); !ss.is_done(); ss.next()) {</span>
<span class="line-added">1003         if (ss.is_reference()) {</span>
<span class="line-added">1004           if (ss.is_array()) {</span>
<span class="line-added">1005             ss.skip_array_prefix();</span>
<span class="line-added">1006           }</span>
<span class="line-added">1007           if (ss.type() == T_VALUETYPE) {</span>
<span class="line-added">1008             Symbol* symb = ss.as_symbol();</span>
<span class="line-added">1009 </span>
<span class="line-added">1010             oop loader = class_loader();</span>
<span class="line-added">1011             oop protection_domain = this-&gt;protection_domain();</span>
<span class="line-added">1012             Klass* klass = SystemDictionary::resolve_or_fail(symb,</span>
<span class="line-added">1013                                                              Handle(THREAD, loader), Handle(THREAD, protection_domain), true,</span>
<span class="line-added">1014                                                              CHECK_false);</span>
<span class="line-added">1015             if (klass == NULL) {</span>
<span class="line-added">1016               THROW_(vmSymbols::java_lang_LinkageError(), false);</span>
<span class="line-added">1017             }</span>
<span class="line-added">1018             if (!klass-&gt;is_value()) {</span>
<span class="line-added">1019               Exceptions::fthrow(</span>
<span class="line-added">1020                 THREAD_AND_LOCATION,</span>
<span class="line-added">1021                 vmSymbols::java_lang_IncompatibleClassChangeError(),</span>
<span class="line-added">1022                 &quot;class %s is not an inline type&quot;,</span>
<span class="line-added">1023                 klass-&gt;external_name());</span>
<span class="line-added">1024             }</span>
<span class="line-added">1025           }</span>
<span class="line-added">1026         }</span>
<span class="line-added">1027       }</span>
<span class="line-added">1028     }</span>
<span class="line-added">1029   }</span>
<span class="line-added">1030 </span>
1031   // in case the class is linked in the process of linking its superclasses
1032   if (is_linked()) {
1033     return true;
1034   }
1035 
1036   // trace only the link time for this klass that includes
1037   // the verification time
1038   PerfClassTraceTime vmtimer(ClassLoader::perf_class_link_time(),
1039                              ClassLoader::perf_class_link_selftime(),
1040                              ClassLoader::perf_classes_linked(),
1041                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
1042                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
1043                              PerfClassTraceTime::CLASS_LINK);
1044 
1045   // verification &amp; rewriting
1046   {
1047     HandleMark hm(THREAD);
1048     Handle h_init_lock(THREAD, init_lock());
1049     ObjectLocker ol(h_init_lock, THREAD, h_init_lock() != NULL);
1050     // rewritten will have been set if loader constraint error found
</pre>
<hr />
<pre>
1082       // fabricate new Method*s.
1083       // also does loader constraint checking
1084       //
1085       // initialize_vtable and initialize_itable need to be rerun
1086       // for a shared class if
1087       // 1) the class is loaded by custom class loader or
1088       // 2) the class is loaded by built-in class loader but failed to add archived loader constraints
1089       bool need_init_table = true;
1090       if (is_shared() &amp;&amp; SystemDictionaryShared::check_linking_constraints(this, THREAD)) {
1091         need_init_table = false;
1092       }
1093       if (need_init_table) {
1094         vtable().initialize_vtable(true, CHECK_false);
1095         itable().initialize_itable(true, CHECK_false);
1096       }
1097 #ifdef ASSERT
1098       vtable().verify(tty, true);
1099       // In case itable verification is ever added.
1100       // itable().verify(tty, true);
1101 #endif
<span class="line-added">1102 </span>
1103       set_init_state(linked);
1104       if (JvmtiExport::should_post_class_prepare()) {
1105         Thread *thread = THREAD;
1106         assert(thread-&gt;is_Java_thread(), &quot;thread-&gt;is_Java_thread()&quot;);
1107         JvmtiExport::post_class_prepare((JavaThread *) thread, this);
1108       }
1109     }
1110   }
1111   return true;
1112 }
1113 
1114 // Rewrite the byte codes of all of the methods of a class.
1115 // The rewriter must be called exactly once. Rewriting must happen after
1116 // verification but before the first method of the class is executed.
1117 void InstanceKlass::rewrite_class(TRAPS) {
1118   assert(is_loaded(), &quot;must be loaded&quot;);
1119   if (is_rewritten()) {
1120     assert(is_shared(), &quot;rewriting an unshared class?&quot;);
1121     return;
1122   }
</pre>
<hr />
<pre>
1236     // having a superinterface that declares, non-static, concrete methods
1237     if (!HAS_PENDING_EXCEPTION &amp;&amp; has_nonstatic_concrete_methods()) {
1238       initialize_super_interfaces(THREAD);
1239     }
1240 
1241     // If any exceptions, complete abruptly, throwing the same exception as above.
1242     if (HAS_PENDING_EXCEPTION) {
1243       Handle e(THREAD, PENDING_EXCEPTION);
1244       CLEAR_PENDING_EXCEPTION;
1245       {
1246         EXCEPTION_MARK;
1247         // Locks object, set state, and notify all waiting threads
1248         set_initialization_state_and_notify(initialization_error, THREAD);
1249         CLEAR_PENDING_EXCEPTION;
1250       }
1251       DTRACE_CLASSINIT_PROBE_WAIT(super__failed, -1, wait);
1252       THROW_OOP(e());
1253     }
1254   }
1255 
<span class="line-added">1256   // Step 8</span>
<span class="line-added">1257   // Initialize classes of flattenable fields</span>
<span class="line-added">1258   {</span>
<span class="line-added">1259     for (AllFieldStream fs(this); !fs.done(); fs.next()) {</span>
<span class="line-added">1260       if (fs.is_flattenable()) {</span>
<span class="line-added">1261         Klass* klass = this-&gt;get_value_field_klass_or_null(fs.index());</span>
<span class="line-added">1262         if (klass == NULL) {</span>
<span class="line-added">1263           assert(fs.access_flags().is_static() &amp;&amp; fs.access_flags().is_flattenable(),</span>
<span class="line-added">1264               &quot;Otherwise should have been pre-loaded&quot;);</span>
<span class="line-added">1265           klass = SystemDictionary::resolve_or_fail(field_signature(fs.index())-&gt;fundamental_name(THREAD),</span>
<span class="line-added">1266               Handle(THREAD, class_loader()),</span>
<span class="line-added">1267               Handle(THREAD, protection_domain()),</span>
<span class="line-added">1268               true, CHECK);</span>
<span class="line-added">1269           if (klass == NULL) {</span>
<span class="line-added">1270             THROW(vmSymbols::java_lang_NoClassDefFoundError());</span>
<span class="line-added">1271           }</span>
<span class="line-added">1272           if (!klass-&gt;is_value()) {</span>
<span class="line-added">1273             THROW(vmSymbols::java_lang_IncompatibleClassChangeError());</span>
<span class="line-added">1274           }</span>
<span class="line-added">1275           this-&gt;set_value_field_klass(fs.index(), klass);</span>
<span class="line-added">1276         }</span>
<span class="line-added">1277         InstanceKlass::cast(klass)-&gt;initialize(CHECK);</span>
<span class="line-added">1278         if (fs.access_flags().is_static()) {</span>
<span class="line-added">1279           if (java_mirror()-&gt;obj_field(fs.offset()) == NULL) {</span>
<span class="line-added">1280             java_mirror()-&gt;obj_field_put(fs.offset(), ValueKlass::cast(klass)-&gt;default_value());</span>
<span class="line-added">1281           }</span>
<span class="line-added">1282         }</span>
<span class="line-added">1283       }</span>
<span class="line-added">1284     }</span>
<span class="line-added">1285   }</span>
<span class="line-added">1286 </span>
1287 
1288   // Look for aot compiled methods for this klass, including class initializer.
1289   AOTLoader::load_for_klass(this, THREAD);
1290 
<span class="line-modified">1291   // Step 9</span>
1292   {
1293     DTRACE_CLASSINIT_PROBE_WAIT(clinit, -1, wait);
1294     // Timer includes any side effects of class initialization (resolution,
1295     // etc), but not recursive entry into call_class_initializer().
1296     PerfClassTraceTime timer(ClassLoader::perf_class_init_time(),
1297                              ClassLoader::perf_class_init_selftime(),
1298                              ClassLoader::perf_classes_inited(),
1299                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
1300                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
1301                              PerfClassTraceTime::CLASS_CLINIT);
1302     call_class_initializer(THREAD);
1303   }
1304 
<span class="line-modified">1305   // Step 10</span>
1306   if (!HAS_PENDING_EXCEPTION) {
1307     set_initialization_state_and_notify(fully_initialized, CHECK);
1308     {
1309       debug_only(vtable().verify(tty, true);)
1310     }
1311   }
1312   else {
<span class="line-modified">1313     // Step 11 and 12</span>
1314     Handle e(THREAD, PENDING_EXCEPTION);
1315     CLEAR_PENDING_EXCEPTION;
1316     // JVMTI has already reported the pending exception
1317     // JVMTI internal flag reset is needed in order to report ExceptionInInitializerError
1318     JvmtiExport::clear_detected_exception(jt);
1319     {
1320       EXCEPTION_MARK;
1321       set_initialization_state_and_notify(initialization_error, THREAD);
1322       CLEAR_PENDING_EXCEPTION;   // ignore any exception thrown, class initialization error is thrown below
1323       // JVMTI has already reported the pending exception
1324       // JVMTI internal flag reset is needed in order to report ExceptionInInitializerError
1325       JvmtiExport::clear_detected_exception(jt);
1326     }
1327     DTRACE_CLASSINIT_PROBE_WAIT(error, -1, wait);
1328     if (e-&gt;is_a(SystemDictionary::Error_klass())) {
1329       THROW_OOP(e());
1330     } else {
1331       JavaCallArguments args(e);
1332       THROW_ARG(vmSymbols::java_lang_ExceptionInInitializerError(),
1333                 vmSymbols::throwable_void_signature(),
</pre>
<hr />
<pre>
1581       }
1582     }
1583   }
1584   // _this will always be set at this point
1585   ObjArrayKlass* oak = array_klasses();
1586   if (or_null) {
1587     return oak-&gt;array_klass_or_null(n);
1588   }
1589   return oak-&gt;array_klass(n, THREAD);
1590 }
1591 
1592 Klass* InstanceKlass::array_klass_impl(bool or_null, TRAPS) {
1593   return array_klass_impl(or_null, 1, THREAD);
1594 }
1595 
1596 static int call_class_initializer_counter = 0;   // for debugging
1597 
1598 Method* InstanceKlass::class_initializer() const {
1599   Method* clinit = find_method(
1600       vmSymbols::class_initializer_name(), vmSymbols::void_method_signature());
<span class="line-modified">1601   if (clinit != NULL &amp;&amp; clinit-&gt;is_class_initializer()) {</span>
1602     return clinit;
1603   }
1604   return NULL;
1605 }
1606 
1607 void InstanceKlass::call_class_initializer(TRAPS) {
1608   if (ReplayCompiles &amp;&amp;
1609       (ReplaySuppressInitializers == 1 ||
1610        (ReplaySuppressInitializers &gt;= 2 &amp;&amp; class_loader() != NULL))) {
1611     // Hide the existence of the initializer for the purpose of replaying the compile
1612     return;
1613   }
1614 
1615   methodHandle h_method(THREAD, class_initializer());
1616   assert(!is_initialized(), &quot;we cannot initialize twice&quot;);
1617   LogTarget(Info, class, init) lt;
1618   if (lt.is_enabled()) {
1619     ResourceMark rm(THREAD);
1620     LogStream ls(lt);
1621     ls.print(&quot;%d Initializing &quot;, call_class_initializer_counter++);
1622     name()-&gt;print_value_on(&amp;ls);
1623     ls.print_cr(&quot;%s (&quot; INTPTR_FORMAT &quot;)&quot;, h_method() == NULL ? &quot;(no method)&quot; : &quot;&quot;, p2i(this));
1624   }
1625   if (h_method() != NULL) {
1626     JavaCallArguments args; // No arguments
1627     JavaValue result(T_VOID);
1628     JavaCalls::call(&amp;result, h_method, &amp;args, CHECK); // Static call (no args)
1629   }
1630 }
1631 
1632 
1633 void InstanceKlass::mask_for(const methodHandle&amp; method, int bci,
1634   InterpreterOopMap* entry_for) {
1635   // Lazily create the _oop_map_cache at first request
1636   // Lock-free access requires load_acquire.
1637   OopMapCache* oop_map_cache = Atomic::load_acquire(&amp;_oop_map_cache);
1638   if (oop_map_cache == NULL) {
<span class="line-modified">1639     MutexLocker x(OopMapCacheAlloc_lock,  Mutex::_no_safepoint_check_flag);</span>
1640     // Check if _oop_map_cache was allocated while we were waiting for this lock
1641     if ((oop_map_cache = _oop_map_cache) == NULL) {
1642       oop_map_cache = new OopMapCache();
1643       // Ensure _oop_map_cache is stable, since it is examined without a lock
1644       Atomic::release_store(&amp;_oop_map_cache, oop_map_cache);
1645     }
1646   }
1647   // _oop_map_cache is constant after init; lookup below does its own locking.
1648   oop_map_cache-&gt;lookup(method, bci, entry_for);
1649 }
1650 





1651 bool InstanceKlass::find_local_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
1652   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
1653     Symbol* f_name = fs.name();
1654     Symbol* f_sig  = fs.signature();
1655     if (f_name == name &amp;&amp; f_sig == sig) {
1656       fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
1657       return true;
1658     }
1659   }
1660   return false;
1661 }
1662 
1663 
1664 Klass* InstanceKlass::find_interface_field(Symbol* name, Symbol* sig, fieldDescriptor* fd) const {
1665   const int n = local_interfaces()-&gt;length();
1666   for (int i = 0; i &lt; n; i++) {
1667     Klass* intf1 = local_interfaces()-&gt;at(i);
1668     assert(intf1-&gt;is_interface(), &quot;just checking type&quot;);
1669     // search for field in current interface
1670     if (InstanceKlass::cast(intf1)-&gt;find_local_field(name, sig, fd)) {
</pre>
<hr />
<pre>
1701 
1702 Klass* InstanceKlass::find_field(Symbol* name, Symbol* sig, bool is_static, fieldDescriptor* fd) const {
1703   // search order according to newest JVM spec (5.4.3.2, p.167).
1704   // 1) search for field in current klass
1705   if (find_local_field(name, sig, fd)) {
1706     if (fd-&gt;is_static() == is_static) return const_cast&lt;InstanceKlass*&gt;(this);
1707   }
1708   // 2) search for field recursively in direct superinterfaces
1709   if (is_static) {
1710     Klass* intf = find_interface_field(name, sig, fd);
1711     if (intf != NULL) return intf;
1712   }
1713   // 3) apply field lookup recursively if superclass exists
1714   { Klass* supr = super();
1715     if (supr != NULL) return InstanceKlass::cast(supr)-&gt;find_field(name, sig, is_static, fd);
1716   }
1717   // 4) otherwise field lookup fails
1718   return NULL;
1719 }
1720 
<span class="line-added">1721 bool InstanceKlass::contains_field_offset(int offset) {</span>
<span class="line-added">1722   if (this-&gt;is_value()) {</span>
<span class="line-added">1723     ValueKlass* vk = ValueKlass::cast(this);</span>
<span class="line-added">1724     return offset &gt;= vk-&gt;first_field_offset() &amp;&amp; offset &lt; (vk-&gt;first_field_offset() + vk-&gt;get_exact_size_in_bytes());</span>
<span class="line-added">1725   } else {</span>
<span class="line-added">1726     fieldDescriptor fd;</span>
<span class="line-added">1727     return find_field_from_offset(offset, false, &amp;fd);</span>
<span class="line-added">1728   }</span>
<span class="line-added">1729 }</span>
1730 
1731 bool InstanceKlass::find_local_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
1732   for (JavaFieldStream fs(this); !fs.done(); fs.next()) {
1733     if (fs.offset() == offset) {
1734       fd-&gt;reinitialize(const_cast&lt;InstanceKlass*&gt;(this), fs.index());
1735       if (fd-&gt;is_static() == is_static) return true;
1736     }
1737   }
1738   return false;
1739 }
1740 
1741 
1742 bool InstanceKlass::find_field_from_offset(int offset, bool is_static, fieldDescriptor* fd) const {
1743   Klass* klass = const_cast&lt;InstanceKlass*&gt;(this);
1744   while (klass != NULL) {
1745     if (InstanceKlass::cast(klass)-&gt;find_local_field_from_offset(offset, is_static, fd)) {
1746       return true;
1747     }
1748     klass = klass-&gt;super();
1749   }
</pre>
<hr />
<pre>
2094 }
2095 
2096 // uncached_lookup_method searches both the local class methods array and all
2097 // superclasses methods arrays, skipping any overpass methods in superclasses,
2098 // and possibly skipping private methods.
2099 Method* InstanceKlass::uncached_lookup_method(const Symbol* name,
2100                                               const Symbol* signature,
2101                                               OverpassLookupMode overpass_mode,
2102                                               PrivateLookupMode private_mode) const {
2103   OverpassLookupMode overpass_local_mode = overpass_mode;
2104   const Klass* klass = this;
2105   while (klass != NULL) {
2106     Method* const method = InstanceKlass::cast(klass)-&gt;find_method_impl(name,
2107                                                                         signature,
2108                                                                         overpass_local_mode,
2109                                                                         find_static,
2110                                                                         private_mode);
2111     if (method != NULL) {
2112       return method;
2113     }
<span class="line-added">2114     if (name == vmSymbols::object_initializer_name()) {</span>
<span class="line-added">2115       break;  // &lt;init&gt; is never inherited, not even as a static factory</span>
<span class="line-added">2116     }</span>
2117     klass = klass-&gt;super();
2118     overpass_local_mode = skip_overpass;   // Always ignore overpass methods in superclasses
2119   }
2120   return NULL;
2121 }
2122 
2123 #ifdef ASSERT
2124 // search through class hierarchy and return true if this class or
2125 // one of the superclasses was redefined
2126 bool InstanceKlass::has_redefined_this_or_super() const {
2127   const Klass* klass = this;
2128   while (klass != NULL) {
2129     if (InstanceKlass::cast(klass)-&gt;has_been_redefined()) {
2130       return true;
2131     }
2132     klass = klass-&gt;super();
2133   }
2134   return false;
2135 }
2136 #endif
</pre>
<hr />
<pre>
2679 }
2680 
2681 void InstanceKlass::remove_java_mirror() {
2682   Klass::remove_java_mirror();
2683 
2684   // do array classes also.
2685   if (array_klasses() != NULL) {
2686     array_klasses()-&gt;remove_java_mirror();
2687   }
2688 }
2689 
2690 void InstanceKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain,
2691                                              PackageEntry* pkg_entry, TRAPS) {
2692   // SystemDictionary::add_to_hierarchy() sets the init_state to loaded
2693   // before the InstanceKlass is added to the SystemDictionary. Make
2694   // sure the current state is &lt;loaded.
2695   assert(!is_loaded(), &quot;invalid init state&quot;);
2696   set_package(loader_data, pkg_entry, CHECK);
2697   Klass::restore_unshareable_info(loader_data, protection_domain, CHECK);
2698 
<span class="line-added">2699   if (is_value()) {</span>
<span class="line-added">2700     ValueKlass::cast(this)-&gt;initialize_calling_convention(CHECK);</span>
<span class="line-added">2701   }</span>
<span class="line-added">2702 </span>
2703   Array&lt;Method*&gt;* methods = this-&gt;methods();
2704   int num_methods = methods-&gt;length();
2705   for (int index = 0; index &lt; num_methods; ++index) {
2706     methods-&gt;at(index)-&gt;restore_unshareable_info(CHECK);
2707   }
2708   if (JvmtiExport::has_redefined_a_class()) {
2709     // Reinitialize vtable because RedefineClasses may have changed some
2710     // entries in this vtable for super classes so the CDS vtable might
2711     // point to old or obsolete entries.  RedefineClasses doesn&#39;t fix up
2712     // vtables in the shared system dictionary, only the main one.
2713     // It also redefines the itable too so fix that too.
2714     vtable().initialize_vtable(false, CHECK);
2715     itable().initialize_itable(false, CHECK);
2716   }
2717 
2718   // restore constant pool resolved references
2719   constants()-&gt;restore_unshareable_info(CHECK);
2720 
2721   if (array_klasses() != NULL) {
2722     // Array classes have null protection domain.
2723     // --&gt; see ArrayKlass::complete_create_array_klass()
2724     array_klasses()-&gt;restore_unshareable_info(ClassLoaderData::the_null_class_loader_data(), Handle(), CHECK);
2725   }
2726 
2727   // Initialize current biased locking state.
<span class="line-modified">2728   if (UseBiasedLocking &amp;&amp; BiasedLocking::enabled() &amp;&amp; !is_value()) {</span>
2729     set_prototype_header(markWord::biased_locking_prototype());
2730   }
2731 }
2732 
2733 void InstanceKlass::set_shared_class_loader_type(s2 loader_type) {
2734   switch (loader_type) {
2735   case ClassLoader::BOOT_LOADER:
2736     _misc_flags |= _misc_is_shared_boot_class;
2737     break;
2738   case ClassLoader::PLATFORM_LOADER:
2739     _misc_flags |= _misc_is_shared_platform_class;
2740     break;
2741   case ClassLoader::APP_LOADER:
2742     _misc_flags |= _misc_is_shared_app_class;
2743     break;
2744   default:
2745     ShouldNotReachHere();
2746     break;
2747   }
2748 }
</pre>
<hr />
<pre>
2873   }
2874 }
2875 
2876 const char* InstanceKlass::signature_name() const {
2877   int hash_len = 0;
2878   char hash_buf[40];
2879 
2880   // If this is an unsafe anonymous class, append a hash to make the name unique
2881   if (is_unsafe_anonymous()) {
2882     intptr_t hash = (java_mirror() != NULL) ? java_mirror()-&gt;identity_hash() : 0;
2883     jio_snprintf(hash_buf, sizeof(hash_buf), &quot;/&quot; UINTX_FORMAT, (uintx)hash);
2884     hash_len = (int)strlen(hash_buf);
2885   }
2886 
2887   // Get the internal name as a c string
2888   const char* src = (const char*) (name()-&gt;as_C_string());
2889   const int src_length = (int)strlen(src);
2890 
2891   char* dest = NEW_RESOURCE_ARRAY(char, src_length + hash_len + 3);
2892 
<span class="line-modified">2893   // Add L or Q as type indicator</span>
2894   int dest_index = 0;
<span class="line-modified">2895   dest[dest_index++] = is_value() ? JVM_SIGNATURE_VALUETYPE : JVM_SIGNATURE_CLASS;</span>
2896 
2897   // Add the actual class name
2898   for (int src_index = 0; src_index &lt; src_length; ) {
2899     dest[dest_index++] = src[src_index++];
2900   }
2901 
2902   if (is_hidden()) { // Replace the last &#39;+&#39; with a &#39;.&#39;.
2903     for (int index = (int)src_length; index &gt; 0; index--) {
2904       if (dest[index] == &#39;+&#39;) {
2905         dest[index] = JVM_SIGNATURE_DOT;
2906         break;
2907       }
2908     }
2909   }
2910 
2911   // If we have a hash, append it
2912   for (int hash_index = 0; hash_index &lt; hash_len; ) {
2913     dest[dest_index++] = hash_buf[hash_index++];
2914   }
2915 
</pre>
<hr />
<pre>
3435   }
3436 
3437   assert(match_level == false || best == NULL, &quot;shouldn&#39;t pick up anything if match_level is set&quot;);
3438   if (best != NULL &amp;&amp; best-&gt;comp_level() &gt;= comp_level) {
3439     return best;
3440   }
3441   return NULL;
3442 }
3443 
3444 // -----------------------------------------------------------------------------------------------------
3445 // Printing
3446 
3447 #ifndef PRODUCT
3448 
3449 #define BULLET  &quot; - &quot;
3450 
3451 static const char* state_names[] = {
3452   &quot;allocated&quot;, &quot;loaded&quot;, &quot;linked&quot;, &quot;being_initialized&quot;, &quot;fully_initialized&quot;, &quot;initialization_error&quot;
3453 };
3454 
<span class="line-modified">3455 static void print_vtable(address self, intptr_t* start, int len, outputStream* st) {</span>
<span class="line-added">3456   ResourceMark rm;</span>
<span class="line-added">3457   int* forward_refs = NEW_RESOURCE_ARRAY(int, len);</span>
<span class="line-added">3458   for (int i = 0; i &lt; len; i++)  forward_refs[i] = 0;</span>
3459   for (int i = 0; i &lt; len; i++) {
3460     intptr_t e = start[i];
3461     st-&gt;print(&quot;%d : &quot; INTPTR_FORMAT, i, e);
<span class="line-added">3462     if (forward_refs[i] != 0) {</span>
<span class="line-added">3463       int from = forward_refs[i];</span>
<span class="line-added">3464       int off = (int) start[from];</span>
<span class="line-added">3465       st-&gt;print(&quot; (offset %d &lt;= [%d])&quot;, off, from);</span>
<span class="line-added">3466     }</span>
3467     if (MetaspaceObj::is_valid((Metadata*)e)) {
3468       st-&gt;print(&quot; &quot;);
3469       ((Metadata*)e)-&gt;print_value_on(st);
<span class="line-added">3470     } else if (self != NULL &amp;&amp; e &gt; 0 &amp;&amp; e &lt; 0x10000) {</span>
<span class="line-added">3471       address location = self + e;</span>
<span class="line-added">3472       int index = (int)((intptr_t*)location - start);</span>
<span class="line-added">3473       st-&gt;print(&quot; (offset %d =&gt; [%d])&quot;, (int)e, index);</span>
<span class="line-added">3474       if (index &gt;= 0 &amp;&amp; index &lt; len)</span>
<span class="line-added">3475         forward_refs[index] = i;</span>
3476     }
3477     st-&gt;cr();
3478   }
3479 }
3480 
3481 static void print_vtable(vtableEntry* start, int len, outputStream* st) {
<span class="line-modified">3482   return print_vtable(NULL, reinterpret_cast&lt;intptr_t*&gt;(start), len, st);</span>
<span class="line-added">3483 }</span>
<span class="line-added">3484 </span>
<span class="line-added">3485 template&lt;typename T&gt;</span>
<span class="line-added">3486  static void print_array_on(outputStream* st, Array&lt;T&gt;* array) {</span>
<span class="line-added">3487    if (array == NULL) { st-&gt;print_cr(&quot;NULL&quot;); return; }</span>
<span class="line-added">3488    array-&gt;print_value_on(st); st-&gt;cr();</span>
<span class="line-added">3489    if (Verbose || WizardMode) {</span>
<span class="line-added">3490      for (int i = 0; i &lt; array-&gt;length(); i++) {</span>
<span class="line-added">3491        st-&gt;print(&quot;%d : &quot;, i); array-&gt;at(i)-&gt;print_value_on(st); st-&gt;cr();</span>
<span class="line-added">3492      }</span>
<span class="line-added">3493    }</span>
<span class="line-added">3494  }</span>
<span class="line-added">3495 </span>
<span class="line-added">3496 static void print_array_on(outputStream* st, Array&lt;int&gt;* array) {</span>
<span class="line-added">3497   if (array == NULL) { st-&gt;print_cr(&quot;NULL&quot;); return; }</span>
<span class="line-added">3498   array-&gt;print_value_on(st); st-&gt;cr();</span>
<span class="line-added">3499   if (Verbose || WizardMode) {</span>
<span class="line-added">3500     for (int i = 0; i &lt; array-&gt;length(); i++) {</span>
<span class="line-added">3501       st-&gt;print(&quot;%d : %d&quot;, i, array-&gt;at(i)); st-&gt;cr();</span>
<span class="line-added">3502     }</span>
<span class="line-added">3503   }</span>
3504 }
3505 
3506 void InstanceKlass::print_on(outputStream* st) const {
3507   assert(is_klass(), &quot;must be klass&quot;);
3508   Klass::print_on(st);
3509 
3510   st-&gt;print(BULLET&quot;instance size:     %d&quot;, size_helper());                        st-&gt;cr();
3511   st-&gt;print(BULLET&quot;klass size:        %d&quot;, size());                               st-&gt;cr();
3512   st-&gt;print(BULLET&quot;access:            &quot;); access_flags().print_on(st);            st-&gt;cr();
<span class="line-added">3513   st-&gt;print(BULLET&quot;misc flags:        0x%x&quot;, _misc_flags);                        st-&gt;cr();</span>
3514   st-&gt;print(BULLET&quot;state:             &quot;); st-&gt;print_cr(&quot;%s&quot;, state_names[_init_state]);
3515   st-&gt;print(BULLET&quot;name:              &quot;); name()-&gt;print_value_on(st);             st-&gt;cr();
3516   st-&gt;print(BULLET&quot;super:             &quot;); Metadata::print_value_on_maybe_null(st, super()); st-&gt;cr();
3517   st-&gt;print(BULLET&quot;sub:               &quot;);
3518   Klass* sub = subklass();
3519   int n;
3520   for (n = 0; sub != NULL; n++, sub = sub-&gt;next_sibling()) {
3521     if (n &lt; MaxSubklassPrintSize) {
3522       sub-&gt;print_value_on(st);
3523       st-&gt;print(&quot;   &quot;);
3524     }
3525   }
3526   if (n &gt;= MaxSubklassPrintSize) st-&gt;print(&quot;(&quot; INTX_FORMAT &quot; more klasses...)&quot;, n - MaxSubklassPrintSize);
3527   st-&gt;cr();
3528 
3529   if (is_interface()) {
3530     st-&gt;print_cr(BULLET&quot;nof implementors:  %d&quot;, nof_implementors());
3531     if (nof_implementors() == 1) {
3532       st-&gt;print_cr(BULLET&quot;implementor:    &quot;);
3533       st-&gt;print(&quot;   &quot;);
3534       implementor()-&gt;print_value_on(st);
3535       st-&gt;cr();
3536     }
3537   }
3538 
3539   st-&gt;print(BULLET&quot;arrays:            &quot;); Metadata::print_value_on_maybe_null(st, array_klasses()); st-&gt;cr();
<span class="line-modified">3540   st-&gt;print(BULLET&quot;methods:           &quot;); print_array_on(st, methods());</span>
<span class="line-modified">3541   st-&gt;print(BULLET&quot;method ordering:   &quot;); print_array_on(st, method_ordering());</span>
<span class="line-modified">3542   st-&gt;print(BULLET&quot;default_methods:   &quot;); print_array_on(st, default_methods());</span>












3543   if (default_vtable_indices() != NULL) {
<span class="line-modified">3544     st-&gt;print(BULLET&quot;default vtable indices:   &quot;); print_array_on(st, default_vtable_indices());</span>
3545   }
<span class="line-modified">3546   st-&gt;print(BULLET&quot;local interfaces:  &quot;); print_array_on(st, local_interfaces());</span>
<span class="line-modified">3547   st-&gt;print(BULLET&quot;trans. interfaces: &quot;); print_array_on(st, transitive_interfaces());</span>
3548   st-&gt;print(BULLET&quot;constants:         &quot;); constants()-&gt;print_value_on(st);         st-&gt;cr();
3549   if (class_loader_data() != NULL) {
3550     st-&gt;print(BULLET&quot;class loader data:  &quot;);
3551     class_loader_data()-&gt;print_value_on(st);
3552     st-&gt;cr();
3553   }
3554   st-&gt;print(BULLET&quot;unsafe anonymous host class:        &quot;); Metadata::print_value_on_maybe_null(st, unsafe_anonymous_host()); st-&gt;cr();
3555   if (source_file_name() != NULL) {
3556     st-&gt;print(BULLET&quot;source file:       &quot;);
3557     source_file_name()-&gt;print_value_on(st);
3558     st-&gt;cr();
3559   }
3560   if (source_debug_extension() != NULL) {
3561     st-&gt;print(BULLET&quot;source debug extension:       &quot;);
3562     st-&gt;print(&quot;%s&quot;, source_debug_extension());
3563     st-&gt;cr();
3564   }
3565   st-&gt;print(BULLET&quot;class annotations:       &quot;); class_annotations()-&gt;print_value_on(st); st-&gt;cr();
3566   st-&gt;print(BULLET&quot;class type annotations:  &quot;); class_type_annotations()-&gt;print_value_on(st); st-&gt;cr();
3567   st-&gt;print(BULLET&quot;field annotations:       &quot;); fields_annotations()-&gt;print_value_on(st); st-&gt;cr();
</pre>
<hr />
<pre>
3584     st-&gt;print(BULLET&quot;generic signature: &quot;);
3585     generic_signature()-&gt;print_value_on(st);
3586     st-&gt;cr();
3587   }
3588   st-&gt;print(BULLET&quot;inner classes:     &quot;); inner_classes()-&gt;print_value_on(st);     st-&gt;cr();
3589   st-&gt;print(BULLET&quot;nest members:     &quot;); nest_members()-&gt;print_value_on(st);     st-&gt;cr();
3590   if (record_components() != NULL) {
3591     st-&gt;print(BULLET&quot;record components:     &quot;); record_components()-&gt;print_value_on(st);     st-&gt;cr();
3592   }
3593   st-&gt;print(BULLET&quot;permitted subclasses:     &quot;); permitted_subclasses()-&gt;print_value_on(st);     st-&gt;cr();
3594   if (java_mirror() != NULL) {
3595     st-&gt;print(BULLET&quot;java mirror:       &quot;);
3596     java_mirror()-&gt;print_value_on(st);
3597     st-&gt;cr();
3598   } else {
3599     st-&gt;print_cr(BULLET&quot;java mirror:       NULL&quot;);
3600   }
3601   st-&gt;print(BULLET&quot;vtable length      %d  (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, vtable_length(), p2i(start_of_vtable())); st-&gt;cr();
3602   if (vtable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(start_of_vtable(), vtable_length(), st);
3603   st-&gt;print(BULLET&quot;itable length      %d (start addr: &quot; INTPTR_FORMAT &quot;)&quot;, itable_length(), p2i(start_of_itable())); st-&gt;cr();
<span class="line-modified">3604   if (itable_length() &gt; 0 &amp;&amp; (Verbose || WizardMode))  print_vtable(NULL, start_of_itable(), itable_length(), st);</span>
3605   st-&gt;print_cr(BULLET&quot;---- static fields (%d words):&quot;, static_field_size());
3606   FieldPrinter print_static_field(st);
3607   ((InstanceKlass*)this)-&gt;do_local_static_fields(&amp;print_static_field);
3608   st-&gt;print_cr(BULLET&quot;---- non-static fields (%d words):&quot;, nonstatic_field_size());
3609   FieldPrinter print_nonstatic_field(st);
3610   InstanceKlass* ik = const_cast&lt;InstanceKlass*&gt;(this);
3611   ik-&gt;do_nonstatic_fields(&amp;print_nonstatic_field);
3612 
3613   st-&gt;print(BULLET&quot;non-static oop maps: &quot;);
3614   OopMapBlock* map     = start_of_nonstatic_oop_maps();
3615   OopMapBlock* end_map = map + nonstatic_oop_map_count();
3616   while (map &lt; end_map) {
3617     st-&gt;print(&quot;%d-%d &quot;, map-&gt;offset(), map-&gt;offset() + heapOopSize*(map-&gt;count() - 1));
3618     map++;
3619   }
3620   st-&gt;cr();
3621 }
3622 
3623 #endif //PRODUCT
3624 
</pre>
<hr />
<pre>
4320   if (holder == NULL) {
4321     return NULL; // The version of klass is gone, no method is found
4322   }
4323   Method* method = holder-&gt;method_with_orig_idnum(idnum);
4324   return method;
4325 }
4326 
4327 #if INCLUDE_JVMTI
4328 JvmtiCachedClassFileData* InstanceKlass::get_cached_class_file() {
4329   return _cached_class_file;
4330 }
4331 
4332 jint InstanceKlass::get_cached_class_file_len() {
4333   return VM_RedefineClasses::get_cached_class_file_len(_cached_class_file);
4334 }
4335 
4336 unsigned char * InstanceKlass::get_cached_class_file_bytes() {
4337   return VM_RedefineClasses::get_cached_class_file_bytes(_cached_class_file);
4338 }
4339 #endif
<span class="line-added">4340 </span>
<span class="line-added">4341 #define THROW_DVT_ERROR(s) \</span>
<span class="line-added">4342   Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_IncompatibleClassChangeError(), \</span>
<span class="line-added">4343       &quot;ValueCapableClass class &#39;%s&#39; %s&quot;, external_name(),(s)); \</span>
<span class="line-added">4344       return</span>
</pre>
</td>
</tr>
</table>
<center><a href="cpCache.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="instanceKlass.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
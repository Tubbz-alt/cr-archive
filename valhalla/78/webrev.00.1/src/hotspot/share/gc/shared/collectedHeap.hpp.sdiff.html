<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shared/collectedHeap.hpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../parallel/psParallelCompact.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../memory/dynamicArchive.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shared/collectedHeap.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
227   // Returns &quot;TRUE&quot; iff &quot;p&quot; points into the committed areas of the heap.
228   // This method can be expensive so avoid using it in performance critical
229   // code.
230   virtual bool is_in(const void* p) const = 0;
231 
232   DEBUG_ONLY(bool is_in_or_null(const void* p) const { return p == NULL || is_in(p); })
233 
234   virtual uint32_t hash_oop(oop obj) const;
235 
236   void set_gc_cause(GCCause::Cause v) {
237      if (UsePerfData) {
238        _gc_lastcause = _gc_cause;
239        _perf_gc_lastcause-&gt;set_value(GCCause::to_string(_gc_lastcause));
240        _perf_gc_cause-&gt;set_value(GCCause::to_string(v));
241      }
242     _gc_cause = v;
243   }
244   GCCause::Cause gc_cause() { return _gc_cause; }
245 
246   oop obj_allocate(Klass* klass, int size, TRAPS);

247   virtual oop array_allocate(Klass* klass, int size, int length, bool do_zero, TRAPS);
248   oop class_allocate(Klass* klass, int size, TRAPS);
249 
250   // Utilities for turning raw memory into filler objects.
251   //
252   // min_fill_size() is the smallest region that can be filled.
253   // fill_with_objects() can fill arbitrary-sized regions of the heap using
254   // multiple objects.  fill_with_object() is for regions known to be smaller
255   // than the largest array of integers; it uses a single object to fill the
256   // region and has slightly less overhead.
257   static size_t min_fill_size() {
258     return size_t(align_object_size(oopDesc::header_size()));
259   }
260 
261   static void fill_with_objects(HeapWord* start, size_t words, bool zap = true);
262 
263   static void fill_with_object(HeapWord* start, size_t words, bool zap = true);
264   static void fill_with_object(MemRegion region, bool zap = true) {
265     fill_with_object(region.start(), region.word_size(), zap);
266   }
</pre>
</td>
<td>
<hr />
<pre>
227   // Returns &quot;TRUE&quot; iff &quot;p&quot; points into the committed areas of the heap.
228   // This method can be expensive so avoid using it in performance critical
229   // code.
230   virtual bool is_in(const void* p) const = 0;
231 
232   DEBUG_ONLY(bool is_in_or_null(const void* p) const { return p == NULL || is_in(p); })
233 
234   virtual uint32_t hash_oop(oop obj) const;
235 
236   void set_gc_cause(GCCause::Cause v) {
237      if (UsePerfData) {
238        _gc_lastcause = _gc_cause;
239        _perf_gc_lastcause-&gt;set_value(GCCause::to_string(_gc_lastcause));
240        _perf_gc_cause-&gt;set_value(GCCause::to_string(v));
241      }
242     _gc_cause = v;
243   }
244   GCCause::Cause gc_cause() { return _gc_cause; }
245 
246   oop obj_allocate(Klass* klass, int size, TRAPS);
<span class="line-added">247   oop obj_buffer_allocate(Klass* klass, int size, TRAPS); // doesn&#39;t clear memory</span>
248   virtual oop array_allocate(Klass* klass, int size, int length, bool do_zero, TRAPS);
249   oop class_allocate(Klass* klass, int size, TRAPS);
250 
251   // Utilities for turning raw memory into filler objects.
252   //
253   // min_fill_size() is the smallest region that can be filled.
254   // fill_with_objects() can fill arbitrary-sized regions of the heap using
255   // multiple objects.  fill_with_object() is for regions known to be smaller
256   // than the largest array of integers; it uses a single object to fill the
257   // region and has slightly less overhead.
258   static size_t min_fill_size() {
259     return size_t(align_object_size(oopDesc::header_size()));
260   }
261 
262   static void fill_with_objects(HeapWord* start, size_t words, bool zap = true);
263 
264   static void fill_with_object(HeapWord* start, size_t words, bool zap = true);
265   static void fill_with_object(MemRegion region, bool zap = true) {
266     fill_with_object(region.start(), region.word_size(), zap);
267   }
</pre>
</td>
</tr>
</table>
<center><a href="../parallel/psParallelCompact.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../memory/dynamicArchive.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
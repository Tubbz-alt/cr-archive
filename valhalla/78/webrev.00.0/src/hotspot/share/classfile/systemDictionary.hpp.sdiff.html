<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionary.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="systemDictionary.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../code/nmethod.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionary.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_SYSTEMDICTIONARY_HPP
 26 #define SHARE_CLASSFILE_SYSTEMDICTIONARY_HPP
 27 
 28 #include &quot;classfile/classLoaderData.hpp&quot;
 29 #include &quot;oops/objArrayOop.hpp&quot;

 30 #include &quot;oops/symbol.hpp&quot;
 31 #include &quot;runtime/java.hpp&quot;
 32 #include &quot;runtime/mutexLocker.hpp&quot;
 33 #include &quot;runtime/reflectionUtils.hpp&quot;
 34 #include &quot;runtime/signature.hpp&quot;
 35 #include &quot;utilities/hashtable.hpp&quot;
 36 
 37 class ClassInstanceInfo : public StackObj {
 38  private:
 39   InstanceKlass* _dynamic_nest_host;
 40   Handle _class_data;
 41 
 42  public:
 43   ClassInstanceInfo() {
 44     _dynamic_nest_host = NULL;
 45     _class_data = Handle();
 46   }
 47   ClassInstanceInfo(InstanceKlass* dynamic_nest_host, Handle class_data) {
 48     _dynamic_nest_host = dynamic_nest_host;
 49     _class_data = class_data;
</pre>
<hr />
<pre>
115 //    - entries must be fully formed before they are available to concurrent
116 //         readers (we must ensure write ordering)
117 //
118 // Note that placeholders are deleted at any time, as they are removed
119 // when a class is completely loaded. Therefore, readers as well as writers
120 // of placeholders must hold the SystemDictionary_lock.
121 //
122 
123 class BootstrapInfo;
124 class ClassFileStream;
125 class Dictionary;
126 class AllFieldStream;
127 class PlaceholderTable;
128 class LoaderConstraintTable;
129 template &lt;MEMFLAGS F&gt; class HashtableBucket;
130 class ResolutionErrorTable;
131 class SymbolPropertyTable;
132 class ProtectionDomainCacheTable;
133 class ProtectionDomainCacheEntry;
134 class GCTimer;

135 
136 #define WK_KLASS_ENUM_NAME(kname)    kname##_knum
137 
138 // Certain classes, such as java.lang.Object and java.lang.String,
139 // are &quot;well-known&quot;, in the sense that no class loader is allowed
140 // to provide a different definition.
141 //
142 // Each well-known class has a short klass name (like object_klass),
143 // and a vmSymbol name (like java_lang_Object).
144 //
145 // The order of these definitions is significant: the classes are
146 // resolved during early VM start-up by resolve_well_known_classes
147 // in this order. Changing the order may require careful restructuring
148 // of the VM start-up sequence.
149 //
150 #define WK_KLASSES_DO(do_klass)                                                                                 \
151   /* well-known classes */                                                                                      \
152   do_klass(Object_klass,                                java_lang_Object                                      ) \
153   do_klass(IdentityObject_klass,                        java_lang_IdentityObject                              ) \
154   do_klass(String_klass,                                java_lang_String                                      ) \
</pre>
<hr />
<pre>
374   //   4. Loading was attempted, but there was a linkage error of some sort.
375   // In all of these cases, the loader constraints on this type are
376   // satisfied, and it is safe for classes in the given class loader
377   // to manipulate strongly-typed values of the found class, subject
378   // to local linkage and access checks.
379   static Klass* find_constrained_instance_or_array_klass(Symbol* class_name,
380                                                            Handle class_loader,
381                                                            TRAPS);
382 
383   static void classes_do(MetaspaceClosure* it);
384   // Iterate over all methods in all klasses
385 
386   static void methods_do(void f(Method*));
387 
388   // Garbage collection support
389 
390   // Unload (that is, break root links to) all unmarked classes and
391   // loaders.  Returns &quot;true&quot; iff something was unloaded.
392   static bool do_unloading(GCTimer* gc_timer);
393 
<span class="line-modified">394   // Applies &quot;f-&gt;do_oop&quot; to all root oops in the system dictionary.</span>
<span class="line-removed">395   // If include_handles is true (the default), then the handles in the</span>
<span class="line-removed">396   // vm_global OopStorage object are included.</span>
<span class="line-removed">397   static void oops_do(OopClosure* f, bool include_handles = true);</span>
<span class="line-removed">398 </span>
<span class="line-removed">399   // System loader lock</span>
400   static oop system_loader_lock()           { return _system_loader_lock_obj; }
401 
402   // Protection Domain Table
403   static ProtectionDomainCacheTable* pd_cache_table() { return _pd_cache_table; }
404 
405 public:
406   // Printing
407   static void print();
408   static void print_on(outputStream* st);
409   static void dump(outputStream* st, bool verbose);
410 
411   // Verification
412   static void verify();
413 
414   // Initialization
415   static void initialize(TRAPS);
416 
417   // Checked fast access to the well-known classes -- so that you don&#39;t try to use them
418   // before they are resolved.
419   static InstanceKlass* check_klass(InstanceKlass* k) {
</pre>
<hr />
<pre>
579   static const char* find_nest_host_error(const constantPoolHandle&amp; pool, int which);
580 
581   static ProtectionDomainCacheEntry* cache_get(Handle protection_domain);
582 
583  protected:
584 
585   enum Constants {
586     _loader_constraint_size = 107,                     // number of entries in constraint table
587     _resolution_error_size  = 107,                     // number of entries in resolution error table
588     _invoke_method_size     = 139,                     // number of entries in invoke method table
589     _placeholder_table_size = 1009                     // number of entries in hash table for placeholders
590   };
591 
592 
593   // Static tables owned by the SystemDictionary
594 
595   // Hashtable holding placeholders for classes being loaded.
596   static PlaceholderTable*       _placeholders;
597 
598   // Lock object for system class loader
<span class="line-modified">599   static oop                     _system_loader_lock_obj;</span>
600 
601   // Constraints on class loaders
602   static LoaderConstraintTable*  _loader_constraints;
603 
604   // Resolution errors
605   static ResolutionErrorTable*   _resolution_errors;
606 
607   // Invoke methods (JSR 292)
608   static SymbolPropertyTable*    _invoke_method_table;
609 
610   // ProtectionDomain cache
611   static ProtectionDomainCacheTable*   _pd_cache_table;
612 
613 protected:
614   static void validate_protection_domain(InstanceKlass* klass,
615                                          Handle class_loader,
616                                          Handle protection_domain, TRAPS);
617 
618   friend class VM_PopulateDumpSharedSpace;
619   friend class TraversePlaceholdersClosure;
620   static PlaceholderTable*   placeholders() { return _placeholders; }
621   static LoaderConstraintTable* constraints() { return _loader_constraints; }
622   static ResolutionErrorTable* resolution_errors() { return _resolution_errors; }
623   static SymbolPropertyTable* invoke_method_table() { return _invoke_method_table; }

624 
625   // Basic loading operations
626   static InstanceKlass* resolve_instance_class_or_null_helper(Symbol* name,
627                                                               Handle class_loader,
628                                                               Handle protection_domain,
629                                                               TRAPS);
630   static InstanceKlass* resolve_instance_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
631   static Klass* resolve_array_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
632   static InstanceKlass* handle_parallel_super_load(Symbol* class_name, Symbol* supername, Handle class_loader, Handle protection_domain, Handle lockObject, TRAPS);
633   // Wait on SystemDictionary_lock; unlocks lockObject before
634   // waiting; relocks lockObject with correct recursion count
635   // after waiting, but before reentering SystemDictionary_lock
636   // to preserve lock order semantics.
637   static void double_lock_wait(Handle lockObject, TRAPS);
638   static void define_instance_class(InstanceKlass* k, TRAPS);
639   static InstanceKlass* find_or_define_instance_class(Symbol* class_name,
640                                                 Handle class_loader,
641                                                 InstanceKlass* k, TRAPS);
642   static bool is_shared_class_visible(Symbol* class_name, InstanceKlass* ik,
643                                       PackageEntry* pkg_entry,
644                                       Handle class_loader, TRAPS);
645   static bool check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super,
646                                             Handle class_loader,  Handle protection_domain,
647                                             bool is_superclass, TRAPS);
648   static bool check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,
649                                                Handle protection_domain, TRAPS);





650   static InstanceKlass* load_shared_class(InstanceKlass* ik,
651                                           Handle class_loader,
652                                           Handle protection_domain,
653                                           const ClassFileStream *cfs,
654                                           PackageEntry* pkg_entry,
655                                           TRAPS);
656   // Second part of load_shared_class
657   static void load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) NOT_CDS_RETURN;
658   static InstanceKlass* load_shared_boot_class(Symbol* class_name,
659                                                PackageEntry* pkg_entry,
660                                                TRAPS);
661   static InstanceKlass* load_instance_class(Symbol* class_name, Handle class_loader, TRAPS);
662   static Handle compute_loader_lock_object(Handle class_loader, TRAPS);
663   static void check_loader_lock_contention(Handle loader_lock, TRAPS);
664   static bool is_parallelCapable(Handle class_loader);
665   static bool is_parallelDefine(Handle class_loader);
666 
667 public:
668   static bool is_system_class_loader(oop class_loader);
669   static bool is_platform_class_loader(oop class_loader);
</pre>
<hr />
<pre>
697   // Resolve well-known classes so they can be used like SystemDictionary::String_klass()
698   static void resolve_well_known_classes(TRAPS);
699   // quick resolve using CDS for well-known classes only.
700   static void quick_resolve(InstanceKlass* klass, ClassLoaderData* loader_data, Handle domain, TRAPS) NOT_CDS_RETURN;
701 
702   // Class loader constraints
703   static void check_constraints(unsigned int hash,
704                                 InstanceKlass* k, Handle loader,
705                                 bool defining, TRAPS);
706   static void update_dictionary(unsigned int d_hash,
707                                 int p_index, unsigned int p_hash,
708                                 InstanceKlass* k, Handle loader,
709                                 TRAPS);
710 
711   static InstanceKlass* _well_known_klasses[];
712 
713   // table of box klasses (int_klass, etc.)
714   static InstanceKlass* _box_klasses[T_VOID+1];
715 
716 private:
<span class="line-modified">717   static oop  _java_system_loader;</span>
<span class="line-modified">718   static oop  _java_platform_loader;</span>
719 
720 public:
721   static TableStatistics placeholders_statistics();
722   static TableStatistics loader_constraints_statistics();
723   static TableStatistics protection_domain_cache_statistics();
724 };
725 
726 #endif // SHARE_CLASSFILE_SYSTEMDICTIONARY_HPP
</pre>
</td>
<td>
<hr />
<pre>
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #ifndef SHARE_CLASSFILE_SYSTEMDICTIONARY_HPP
 26 #define SHARE_CLASSFILE_SYSTEMDICTIONARY_HPP
 27 
 28 #include &quot;classfile/classLoaderData.hpp&quot;
 29 #include &quot;oops/objArrayOop.hpp&quot;
<span class="line-added"> 30 #include &quot;oops/oopHandle.hpp&quot;</span>
 31 #include &quot;oops/symbol.hpp&quot;
 32 #include &quot;runtime/java.hpp&quot;
 33 #include &quot;runtime/mutexLocker.hpp&quot;
 34 #include &quot;runtime/reflectionUtils.hpp&quot;
 35 #include &quot;runtime/signature.hpp&quot;
 36 #include &quot;utilities/hashtable.hpp&quot;
 37 
 38 class ClassInstanceInfo : public StackObj {
 39  private:
 40   InstanceKlass* _dynamic_nest_host;
 41   Handle _class_data;
 42 
 43  public:
 44   ClassInstanceInfo() {
 45     _dynamic_nest_host = NULL;
 46     _class_data = Handle();
 47   }
 48   ClassInstanceInfo(InstanceKlass* dynamic_nest_host, Handle class_data) {
 49     _dynamic_nest_host = dynamic_nest_host;
 50     _class_data = class_data;
</pre>
<hr />
<pre>
116 //    - entries must be fully formed before they are available to concurrent
117 //         readers (we must ensure write ordering)
118 //
119 // Note that placeholders are deleted at any time, as they are removed
120 // when a class is completely loaded. Therefore, readers as well as writers
121 // of placeholders must hold the SystemDictionary_lock.
122 //
123 
124 class BootstrapInfo;
125 class ClassFileStream;
126 class Dictionary;
127 class AllFieldStream;
128 class PlaceholderTable;
129 class LoaderConstraintTable;
130 template &lt;MEMFLAGS F&gt; class HashtableBucket;
131 class ResolutionErrorTable;
132 class SymbolPropertyTable;
133 class ProtectionDomainCacheTable;
134 class ProtectionDomainCacheEntry;
135 class GCTimer;
<span class="line-added">136 class EventClassLoad;</span>
137 
138 #define WK_KLASS_ENUM_NAME(kname)    kname##_knum
139 
140 // Certain classes, such as java.lang.Object and java.lang.String,
141 // are &quot;well-known&quot;, in the sense that no class loader is allowed
142 // to provide a different definition.
143 //
144 // Each well-known class has a short klass name (like object_klass),
145 // and a vmSymbol name (like java_lang_Object).
146 //
147 // The order of these definitions is significant: the classes are
148 // resolved during early VM start-up by resolve_well_known_classes
149 // in this order. Changing the order may require careful restructuring
150 // of the VM start-up sequence.
151 //
152 #define WK_KLASSES_DO(do_klass)                                                                                 \
153   /* well-known classes */                                                                                      \
154   do_klass(Object_klass,                                java_lang_Object                                      ) \
155   do_klass(IdentityObject_klass,                        java_lang_IdentityObject                              ) \
156   do_klass(String_klass,                                java_lang_String                                      ) \
</pre>
<hr />
<pre>
376   //   4. Loading was attempted, but there was a linkage error of some sort.
377   // In all of these cases, the loader constraints on this type are
378   // satisfied, and it is safe for classes in the given class loader
379   // to manipulate strongly-typed values of the found class, subject
380   // to local linkage and access checks.
381   static Klass* find_constrained_instance_or_array_klass(Symbol* class_name,
382                                                            Handle class_loader,
383                                                            TRAPS);
384 
385   static void classes_do(MetaspaceClosure* it);
386   // Iterate over all methods in all klasses
387 
388   static void methods_do(void f(Method*));
389 
390   // Garbage collection support
391 
392   // Unload (that is, break root links to) all unmarked classes and
393   // loaders.  Returns &quot;true&quot; iff something was unloaded.
394   static bool do_unloading(GCTimer* gc_timer);
395 
<span class="line-modified">396   // System loader lock</span>





397   static oop system_loader_lock();
398 
399   // Protection Domain Table
400   static ProtectionDomainCacheTable* pd_cache_table() { return _pd_cache_table; }
401 
402 public:
403   // Printing
404   static void print();
405   static void print_on(outputStream* st);
406   static void dump(outputStream* st, bool verbose);
407 
408   // Verification
409   static void verify();
410 
411   // Initialization
412   static void initialize(TRAPS);
413 
414   // Checked fast access to the well-known classes -- so that you don&#39;t try to use them
415   // before they are resolved.
416   static InstanceKlass* check_klass(InstanceKlass* k) {
</pre>
<hr />
<pre>
576   static const char* find_nest_host_error(const constantPoolHandle&amp; pool, int which);
577 
578   static ProtectionDomainCacheEntry* cache_get(Handle protection_domain);
579 
580  protected:
581 
582   enum Constants {
583     _loader_constraint_size = 107,                     // number of entries in constraint table
584     _resolution_error_size  = 107,                     // number of entries in resolution error table
585     _invoke_method_size     = 139,                     // number of entries in invoke method table
586     _placeholder_table_size = 1009                     // number of entries in hash table for placeholders
587   };
588 
589 
590   // Static tables owned by the SystemDictionary
591 
592   // Hashtable holding placeholders for classes being loaded.
593   static PlaceholderTable*       _placeholders;
594 
595   // Lock object for system class loader
<span class="line-modified">596   static OopHandle               _system_loader_lock_obj;</span>
597 
598   // Constraints on class loaders
599   static LoaderConstraintTable*  _loader_constraints;
600 
601   // Resolution errors
602   static ResolutionErrorTable*   _resolution_errors;
603 
604   // Invoke methods (JSR 292)
605   static SymbolPropertyTable*    _invoke_method_table;
606 
607   // ProtectionDomain cache
608   static ProtectionDomainCacheTable*   _pd_cache_table;
609 
610 protected:
611   static void validate_protection_domain(InstanceKlass* klass,
612                                          Handle class_loader,
613                                          Handle protection_domain, TRAPS);
614 
615   friend class VM_PopulateDumpSharedSpace;
616   friend class TraversePlaceholdersClosure;
617   static PlaceholderTable*   placeholders() { return _placeholders; }
618   static LoaderConstraintTable* constraints() { return _loader_constraints; }
619   static ResolutionErrorTable* resolution_errors() { return _resolution_errors; }
620   static SymbolPropertyTable* invoke_method_table() { return _invoke_method_table; }
<span class="line-added">621   static void post_class_load_event(EventClassLoad* event, const InstanceKlass* k, const ClassLoaderData* init_cld);</span>
622 
623   // Basic loading operations
624   static InstanceKlass* resolve_instance_class_or_null_helper(Symbol* name,
625                                                               Handle class_loader,
626                                                               Handle protection_domain,
627                                                               TRAPS);
628   static InstanceKlass* resolve_instance_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
629   static Klass* resolve_array_class_or_null(Symbol* class_name, Handle class_loader, Handle protection_domain, TRAPS);
630   static InstanceKlass* handle_parallel_super_load(Symbol* class_name, Symbol* supername, Handle class_loader, Handle protection_domain, Handle lockObject, TRAPS);
631   // Wait on SystemDictionary_lock; unlocks lockObject before
632   // waiting; relocks lockObject with correct recursion count
633   // after waiting, but before reentering SystemDictionary_lock
634   // to preserve lock order semantics.
635   static void double_lock_wait(Handle lockObject, TRAPS);
636   static void define_instance_class(InstanceKlass* k, TRAPS);
637   static InstanceKlass* find_or_define_instance_class(Symbol* class_name,
638                                                 Handle class_loader,
639                                                 InstanceKlass* k, TRAPS);
640   static bool is_shared_class_visible(Symbol* class_name, InstanceKlass* ik,
641                                       PackageEntry* pkg_entry,
642                                       Handle class_loader, TRAPS);
643   static bool check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super,
644                                             Handle class_loader,  Handle protection_domain,
645                                             bool is_superclass, TRAPS);
646   static bool check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,
647                                                Handle protection_domain, TRAPS);
<span class="line-added">648   static InstanceKlass* load_shared_lambda_proxy_class(InstanceKlass* ik,</span>
<span class="line-added">649                                                        Handle class_loader,</span>
<span class="line-added">650                                                        Handle protection_domain,</span>
<span class="line-added">651                                                        PackageEntry* pkg_entry,</span>
<span class="line-added">652                                                        TRAPS);</span>
653   static InstanceKlass* load_shared_class(InstanceKlass* ik,
654                                           Handle class_loader,
655                                           Handle protection_domain,
656                                           const ClassFileStream *cfs,
657                                           PackageEntry* pkg_entry,
658                                           TRAPS);
659   // Second part of load_shared_class
660   static void load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) NOT_CDS_RETURN;
661   static InstanceKlass* load_shared_boot_class(Symbol* class_name,
662                                                PackageEntry* pkg_entry,
663                                                TRAPS);
664   static InstanceKlass* load_instance_class(Symbol* class_name, Handle class_loader, TRAPS);
665   static Handle compute_loader_lock_object(Handle class_loader, TRAPS);
666   static void check_loader_lock_contention(Handle loader_lock, TRAPS);
667   static bool is_parallelCapable(Handle class_loader);
668   static bool is_parallelDefine(Handle class_loader);
669 
670 public:
671   static bool is_system_class_loader(oop class_loader);
672   static bool is_platform_class_loader(oop class_loader);
</pre>
<hr />
<pre>
700   // Resolve well-known classes so they can be used like SystemDictionary::String_klass()
701   static void resolve_well_known_classes(TRAPS);
702   // quick resolve using CDS for well-known classes only.
703   static void quick_resolve(InstanceKlass* klass, ClassLoaderData* loader_data, Handle domain, TRAPS) NOT_CDS_RETURN;
704 
705   // Class loader constraints
706   static void check_constraints(unsigned int hash,
707                                 InstanceKlass* k, Handle loader,
708                                 bool defining, TRAPS);
709   static void update_dictionary(unsigned int d_hash,
710                                 int p_index, unsigned int p_hash,
711                                 InstanceKlass* k, Handle loader,
712                                 TRAPS);
713 
714   static InstanceKlass* _well_known_klasses[];
715 
716   // table of box klasses (int_klass, etc.)
717   static InstanceKlass* _box_klasses[T_VOID+1];
718 
719 private:
<span class="line-modified">720   static OopHandle  _java_system_loader;</span>
<span class="line-modified">721   static OopHandle  _java_platform_loader;</span>
722 
723 public:
724   static TableStatistics placeholders_statistics();
725   static TableStatistics loader_constraints_statistics();
726   static TableStatistics protection_domain_cache_statistics();
727 };
728 
729 #endif // SHARE_CLASSFILE_SYSTEMDICTIONARY_HPP
</pre>
</td>
</tr>
</table>
<center><a href="systemDictionary.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../code/nmethod.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/classFileParser.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../../cpu/x86/stubGenerator_x86_64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderData.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/classFileParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
4098     _class_annotations       = NULL;
4099     _class_type_annotations  = NULL;
4100     _fields_annotations      = NULL;
4101     _fields_type_annotations = NULL;
4102 }
4103 
4104 // Transfer ownership of metadata allocated to the InstanceKlass.
4105 void ClassFileParser::apply_parsed_class_metadata(
4106                                             InstanceKlass* this_klass,
4107                                             int java_fields_count,
4108                                             TRAPS) {
4109   assert(this_klass != NULL, &quot;invariant&quot;);
4110 
4111   _cp-&gt;set_pool_holder(this_klass);
4112   this_klass-&gt;set_constants(_cp);
4113   this_klass-&gt;set_fields(_fields, java_fields_count);
4114   this_klass-&gt;set_methods(_methods);
4115   this_klass-&gt;set_inner_classes(_inner_classes);
4116   this_klass-&gt;set_nest_members(_nest_members);
4117   this_klass-&gt;set_nest_host_index(_nest_host);
<span class="line-removed">4118   this_klass-&gt;set_local_interfaces(_local_interfaces);</span>
4119   this_klass-&gt;set_annotations(_combined_annotations);
4120   this_klass-&gt;set_permitted_subclasses(_permitted_subclasses);
4121   this_klass-&gt;set_record_components(_record_components);
<span class="line-modified">4122   // Delay the setting of _transitive_interfaces until after initialize_supers() in</span>
<span class="line-modified">4123   // fill_instance_klass(). It is because the _transitive_interfaces may be shared with</span>

4124   // its _super. If an OOM occurs while loading the current klass, its _super field
4125   // may not have been set. When GC tries to free the klass, the _transitive_interfaces
4126   // may be deallocated mistakenly in InstanceKlass::deallocate_interfaces(). Subsequent
4127   // dereferences to the deallocated _transitive_interfaces will result in a crash.
4128 
4129   // Clear out these fields so they don&#39;t get deallocated by the destructor
4130   clear_class_metadata();
4131 }
4132 
4133 AnnotationArray* ClassFileParser::assemble_annotations(const u1* const runtime_visible_annotations,
4134                                                        int runtime_visible_annotations_length,
4135                                                        const u1* const runtime_invisible_annotations,
4136                                                        int runtime_invisible_annotations_length,
4137                                                        TRAPS) {
4138   AnnotationArray* annotations = NULL;
4139   if (runtime_visible_annotations != NULL ||
4140       runtime_invisible_annotations != NULL) {
4141     annotations = MetadataFactory::new_array&lt;u1&gt;(_loader_data,
4142                                           runtime_visible_annotations_length +
4143                                           runtime_invisible_annotations_length,
</pre>
<hr />
<pre>
6278   }
6279 
6280   assert(_fac != NULL, &quot;invariant&quot;);
6281   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_FLATTENABLE]);
6282 
6283   // this transfers ownership of a lot of arrays from
6284   // the parser onto the InstanceKlass*
6285   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
6286 
6287   // can only set dynamic nest-host after static nest information is set
6288   if (cl_inst_info.dynamic_nest_host() != NULL) {
6289     ik-&gt;set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);
6290   }
6291 
6292   // note that is not safe to use the fields in the parser from this point on
6293   assert(NULL == _cp, &quot;invariant&quot;);
6294   assert(NULL == _fields, &quot;invariant&quot;);
6295   assert(NULL == _methods, &quot;invariant&quot;);
6296   assert(NULL == _inner_classes, &quot;invariant&quot;);
6297   assert(NULL == _nest_members, &quot;invariant&quot;);
<span class="line-removed">6298   assert(NULL == _local_interfaces, &quot;invariant&quot;);</span>
6299   assert(NULL == _combined_annotations, &quot;invariant&quot;);
6300   assert(NULL == _record_components, &quot;invariant&quot;);
6301   assert(NULL == _permitted_subclasses, &quot;invariant&quot;);
6302 
6303   if (_has_final_method) {
6304     ik-&gt;set_has_final_method();
6305   }
6306 
6307   ik-&gt;copy_method_ordering(_method_ordering, CHECK);
6308   // The InstanceKlass::_methods_jmethod_ids cache
6309   // is managed on the assumption that the initial cache
6310   // size is equal to the number of methods in the class. If
6311   // that changes, then InstanceKlass::idnum_can_increment()
6312   // has to be changed accordingly.
6313   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
6314 
6315   ik-&gt;set_this_class_index(_this_class_index);
6316 
6317   if (_is_hidden || is_unsafe_anonymous()) {
6318     // _this_class_index is a CONSTANT_Class entry that refers to this
</pre>
<hr />
<pre>
6355 
6356   // Fill in field values obtained by parse_classfile_attributes
6357   if (_parsed_annotations-&gt;has_any_annotations()) {
6358     _parsed_annotations-&gt;apply_to(ik);
6359   }
6360 
6361   apply_parsed_class_attributes(ik);
6362 
6363   // Miranda methods
6364   if ((_num_miranda_methods &gt; 0) ||
6365       // if this class introduced new miranda methods or
6366       (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_miranda_methods())
6367         // super class exists and this class inherited miranda methods
6368      ) {
6369        ik-&gt;set_has_miranda_methods(); // then set a flag
6370   }
6371 
6372   // Fill in information needed to compute superclasses.
6373   ik-&gt;initialize_supers(const_cast&lt;InstanceKlass*&gt;(_super_klass), _transitive_interfaces, CHECK);
6374   ik-&gt;set_transitive_interfaces(_transitive_interfaces);

6375   _transitive_interfaces = NULL;

6376 
6377   // Initialize itable offset tables
6378   klassItable::setup_itable_offset_table(ik);
6379 
6380   // Compute transitive closure of interfaces this class implements
6381   // Do final class setup
6382   OopMapBlocksBuilder* oop_map_blocks = _field_info-&gt;oop_map_blocks;
6383   if (oop_map_blocks-&gt;_nonstatic_oop_map_count &gt; 0) {
6384     oop_map_blocks-&gt;copy(ik-&gt;start_of_nonstatic_oop_maps());
6385   }
6386 
6387   if (_has_contended_fields || _parsed_annotations-&gt;is_contended() ||
6388       ( _super_klass != NULL &amp;&amp; _super_klass-&gt;has_contended_annotations())) {
6389     ik-&gt;set_has_contended_annotations(true);
6390   }
6391 
6392   // Fill in has_finalizer, has_vanilla_constructor, and layout_helper
6393   set_precomputed_flags(ik);
6394 
6395   // check if this class can access its super class
</pre>
<hr />
<pre>
6731   stream-&gt;set_verify(_need_verify);
6732 
6733   // Check if verification needs to be relaxed for this class file
6734   // Do not restrict it to jdk1.0 or jdk1.1 to maintain backward compatibility (4982376)
6735   _relax_verify = relax_format_check_for(_loader_data);
6736 
6737   parse_stream(stream, CHECK);
6738 
6739   post_process_parsed_stream(stream, _cp, CHECK);
6740 }
6741 
6742 void ClassFileParser::clear_class_metadata() {
6743   // metadata created before the instance klass is created.  Must be
6744   // deallocated if classfile parsing returns an error.
6745   _cp = NULL;
6746   _fields = NULL;
6747   _methods = NULL;
6748   _inner_classes = NULL;
6749   _nest_members = NULL;
6750   _permitted_subclasses = NULL;
<span class="line-removed">6751   _local_interfaces = NULL;</span>
6752   _combined_annotations = NULL;
6753   _class_annotations = _class_type_annotations = NULL;
6754   _fields_annotations = _fields_type_annotations = NULL;
6755   _record_components = NULL;
6756 }
6757 
6758 // Destructor to clean up
6759 ClassFileParser::~ClassFileParser() {
6760   _class_name-&gt;decrement_refcount();
6761 
6762   if (_cp != NULL) {
6763     MetadataFactory::free_metadata(_loader_data, _cp);
6764   }
6765   if (_fields != NULL) {
6766     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _fields);
6767   }
6768 
6769   if (_methods != NULL) {
6770     // Free methods
6771     InstanceKlass::deallocate_methods(_loader_data, _methods);
</pre>
<hr />
<pre>
6799     // Deallocate the Annotations object and the installed annotations arrays.
6800     _combined_annotations-&gt;deallocate_contents(_loader_data);
6801 
6802     // If the _combined_annotations pointer is non-NULL,
6803     // then the other annotations fields should have been cleared.
6804     assert(_class_annotations       == NULL, &quot;Should have been cleared&quot;);
6805     assert(_class_type_annotations  == NULL, &quot;Should have been cleared&quot;);
6806     assert(_fields_annotations      == NULL, &quot;Should have been cleared&quot;);
6807     assert(_fields_type_annotations == NULL, &quot;Should have been cleared&quot;);
6808   } else {
6809     // If the annotations arrays were not installed into the Annotations object,
6810     // then they have to be deallocated explicitly.
6811     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _class_annotations);
6812     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _class_type_annotations);
6813     Annotations::free_contents(_loader_data, _fields_annotations);
6814     Annotations::free_contents(_loader_data, _fields_type_annotations);
6815   }
6816 
6817   clear_class_metadata();
6818   _transitive_interfaces = NULL;

6819 
6820   // deallocate the klass if already created.  Don&#39;t directly deallocate, but add
6821   // to the deallocate list so that the klass is removed from the CLD::_klasses list
6822   // at a safepoint.
6823   if (_klass_to_deallocate != NULL) {
6824     _loader_data-&gt;add_to_deallocate_list(_klass_to_deallocate);
6825   }
6826 }
6827 
6828 void ClassFileParser::parse_stream(const ClassFileStream* const stream,
6829                                    TRAPS) {
6830 
6831   assert(stream != NULL, &quot;invariant&quot;);
6832   assert(_class_name != NULL, &quot;invariant&quot;);
6833 
6834   // BEGIN STREAM PARSING
6835   stream-&gt;guarantee_more(8, CHECK);  // magic, major, minor
6836   // Magic value
6837   const u4 magic = stream-&gt;get_u4_fast();
6838   guarantee_property(magic == JAVA_CLASSFILE_MAGIC,
</pre>
</td>
<td>
<hr />
<pre>
4098     _class_annotations       = NULL;
4099     _class_type_annotations  = NULL;
4100     _fields_annotations      = NULL;
4101     _fields_type_annotations = NULL;
4102 }
4103 
4104 // Transfer ownership of metadata allocated to the InstanceKlass.
4105 void ClassFileParser::apply_parsed_class_metadata(
4106                                             InstanceKlass* this_klass,
4107                                             int java_fields_count,
4108                                             TRAPS) {
4109   assert(this_klass != NULL, &quot;invariant&quot;);
4110 
4111   _cp-&gt;set_pool_holder(this_klass);
4112   this_klass-&gt;set_constants(_cp);
4113   this_klass-&gt;set_fields(_fields, java_fields_count);
4114   this_klass-&gt;set_methods(_methods);
4115   this_klass-&gt;set_inner_classes(_inner_classes);
4116   this_klass-&gt;set_nest_members(_nest_members);
4117   this_klass-&gt;set_nest_host_index(_nest_host);

4118   this_klass-&gt;set_annotations(_combined_annotations);
4119   this_klass-&gt;set_permitted_subclasses(_permitted_subclasses);
4120   this_klass-&gt;set_record_components(_record_components);
<span class="line-modified">4121   // Delay the setting of _local_interfaces and _transitive_interfaces until after</span>
<span class="line-modified">4122   // initialize_supers() in fill_instance_klass(). It is because the _local_interfaces could</span>
<span class="line-added">4123   // be shared with _transitive_interfaces and _transitive_interfaces may be shared with</span>
4124   // its _super. If an OOM occurs while loading the current klass, its _super field
4125   // may not have been set. When GC tries to free the klass, the _transitive_interfaces
4126   // may be deallocated mistakenly in InstanceKlass::deallocate_interfaces(). Subsequent
4127   // dereferences to the deallocated _transitive_interfaces will result in a crash.
4128 
4129   // Clear out these fields so they don&#39;t get deallocated by the destructor
4130   clear_class_metadata();
4131 }
4132 
4133 AnnotationArray* ClassFileParser::assemble_annotations(const u1* const runtime_visible_annotations,
4134                                                        int runtime_visible_annotations_length,
4135                                                        const u1* const runtime_invisible_annotations,
4136                                                        int runtime_invisible_annotations_length,
4137                                                        TRAPS) {
4138   AnnotationArray* annotations = NULL;
4139   if (runtime_visible_annotations != NULL ||
4140       runtime_invisible_annotations != NULL) {
4141     annotations = MetadataFactory::new_array&lt;u1&gt;(_loader_data,
4142                                           runtime_visible_annotations_length +
4143                                           runtime_invisible_annotations_length,
</pre>
<hr />
<pre>
6278   }
6279 
6280   assert(_fac != NULL, &quot;invariant&quot;);
6281   ik-&gt;set_static_oop_field_count(_fac-&gt;count[STATIC_OOP] + _fac-&gt;count[STATIC_FLATTENABLE]);
6282 
6283   // this transfers ownership of a lot of arrays from
6284   // the parser onto the InstanceKlass*
6285   apply_parsed_class_metadata(ik, _java_fields_count, CHECK);
6286 
6287   // can only set dynamic nest-host after static nest information is set
6288   if (cl_inst_info.dynamic_nest_host() != NULL) {
6289     ik-&gt;set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);
6290   }
6291 
6292   // note that is not safe to use the fields in the parser from this point on
6293   assert(NULL == _cp, &quot;invariant&quot;);
6294   assert(NULL == _fields, &quot;invariant&quot;);
6295   assert(NULL == _methods, &quot;invariant&quot;);
6296   assert(NULL == _inner_classes, &quot;invariant&quot;);
6297   assert(NULL == _nest_members, &quot;invariant&quot;);

6298   assert(NULL == _combined_annotations, &quot;invariant&quot;);
6299   assert(NULL == _record_components, &quot;invariant&quot;);
6300   assert(NULL == _permitted_subclasses, &quot;invariant&quot;);
6301 
6302   if (_has_final_method) {
6303     ik-&gt;set_has_final_method();
6304   }
6305 
6306   ik-&gt;copy_method_ordering(_method_ordering, CHECK);
6307   // The InstanceKlass::_methods_jmethod_ids cache
6308   // is managed on the assumption that the initial cache
6309   // size is equal to the number of methods in the class. If
6310   // that changes, then InstanceKlass::idnum_can_increment()
6311   // has to be changed accordingly.
6312   ik-&gt;set_initial_method_idnum(ik-&gt;methods()-&gt;length());
6313 
6314   ik-&gt;set_this_class_index(_this_class_index);
6315 
6316   if (_is_hidden || is_unsafe_anonymous()) {
6317     // _this_class_index is a CONSTANT_Class entry that refers to this
</pre>
<hr />
<pre>
6354 
6355   // Fill in field values obtained by parse_classfile_attributes
6356   if (_parsed_annotations-&gt;has_any_annotations()) {
6357     _parsed_annotations-&gt;apply_to(ik);
6358   }
6359 
6360   apply_parsed_class_attributes(ik);
6361 
6362   // Miranda methods
6363   if ((_num_miranda_methods &gt; 0) ||
6364       // if this class introduced new miranda methods or
6365       (_super_klass != NULL &amp;&amp; _super_klass-&gt;has_miranda_methods())
6366         // super class exists and this class inherited miranda methods
6367      ) {
6368        ik-&gt;set_has_miranda_methods(); // then set a flag
6369   }
6370 
6371   // Fill in information needed to compute superclasses.
6372   ik-&gt;initialize_supers(const_cast&lt;InstanceKlass*&gt;(_super_klass), _transitive_interfaces, CHECK);
6373   ik-&gt;set_transitive_interfaces(_transitive_interfaces);
<span class="line-added">6374   ik-&gt;set_local_interfaces(_local_interfaces);</span>
6375   _transitive_interfaces = NULL;
<span class="line-added">6376   _local_interfaces = NULL;</span>
6377 
6378   // Initialize itable offset tables
6379   klassItable::setup_itable_offset_table(ik);
6380 
6381   // Compute transitive closure of interfaces this class implements
6382   // Do final class setup
6383   OopMapBlocksBuilder* oop_map_blocks = _field_info-&gt;oop_map_blocks;
6384   if (oop_map_blocks-&gt;_nonstatic_oop_map_count &gt; 0) {
6385     oop_map_blocks-&gt;copy(ik-&gt;start_of_nonstatic_oop_maps());
6386   }
6387 
6388   if (_has_contended_fields || _parsed_annotations-&gt;is_contended() ||
6389       ( _super_klass != NULL &amp;&amp; _super_klass-&gt;has_contended_annotations())) {
6390     ik-&gt;set_has_contended_annotations(true);
6391   }
6392 
6393   // Fill in has_finalizer, has_vanilla_constructor, and layout_helper
6394   set_precomputed_flags(ik);
6395 
6396   // check if this class can access its super class
</pre>
<hr />
<pre>
6732   stream-&gt;set_verify(_need_verify);
6733 
6734   // Check if verification needs to be relaxed for this class file
6735   // Do not restrict it to jdk1.0 or jdk1.1 to maintain backward compatibility (4982376)
6736   _relax_verify = relax_format_check_for(_loader_data);
6737 
6738   parse_stream(stream, CHECK);
6739 
6740   post_process_parsed_stream(stream, _cp, CHECK);
6741 }
6742 
6743 void ClassFileParser::clear_class_metadata() {
6744   // metadata created before the instance klass is created.  Must be
6745   // deallocated if classfile parsing returns an error.
6746   _cp = NULL;
6747   _fields = NULL;
6748   _methods = NULL;
6749   _inner_classes = NULL;
6750   _nest_members = NULL;
6751   _permitted_subclasses = NULL;

6752   _combined_annotations = NULL;
6753   _class_annotations = _class_type_annotations = NULL;
6754   _fields_annotations = _fields_type_annotations = NULL;
6755   _record_components = NULL;
6756 }
6757 
6758 // Destructor to clean up
6759 ClassFileParser::~ClassFileParser() {
6760   _class_name-&gt;decrement_refcount();
6761 
6762   if (_cp != NULL) {
6763     MetadataFactory::free_metadata(_loader_data, _cp);
6764   }
6765   if (_fields != NULL) {
6766     MetadataFactory::free_array&lt;u2&gt;(_loader_data, _fields);
6767   }
6768 
6769   if (_methods != NULL) {
6770     // Free methods
6771     InstanceKlass::deallocate_methods(_loader_data, _methods);
</pre>
<hr />
<pre>
6799     // Deallocate the Annotations object and the installed annotations arrays.
6800     _combined_annotations-&gt;deallocate_contents(_loader_data);
6801 
6802     // If the _combined_annotations pointer is non-NULL,
6803     // then the other annotations fields should have been cleared.
6804     assert(_class_annotations       == NULL, &quot;Should have been cleared&quot;);
6805     assert(_class_type_annotations  == NULL, &quot;Should have been cleared&quot;);
6806     assert(_fields_annotations      == NULL, &quot;Should have been cleared&quot;);
6807     assert(_fields_type_annotations == NULL, &quot;Should have been cleared&quot;);
6808   } else {
6809     // If the annotations arrays were not installed into the Annotations object,
6810     // then they have to be deallocated explicitly.
6811     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _class_annotations);
6812     MetadataFactory::free_array&lt;u1&gt;(_loader_data, _class_type_annotations);
6813     Annotations::free_contents(_loader_data, _fields_annotations);
6814     Annotations::free_contents(_loader_data, _fields_type_annotations);
6815   }
6816 
6817   clear_class_metadata();
6818   _transitive_interfaces = NULL;
<span class="line-added">6819   _local_interfaces = NULL;</span>
6820 
6821   // deallocate the klass if already created.  Don&#39;t directly deallocate, but add
6822   // to the deallocate list so that the klass is removed from the CLD::_klasses list
6823   // at a safepoint.
6824   if (_klass_to_deallocate != NULL) {
6825     _loader_data-&gt;add_to_deallocate_list(_klass_to_deallocate);
6826   }
6827 }
6828 
6829 void ClassFileParser::parse_stream(const ClassFileStream* const stream,
6830                                    TRAPS) {
6831 
6832   assert(stream != NULL, &quot;invariant&quot;);
6833   assert(_class_name != NULL, &quot;invariant&quot;);
6834 
6835   // BEGIN STREAM PARSING
6836   stream-&gt;guarantee_more(8, CHECK);  // magic, major, minor
6837   // Magic value
6838   const u4 magic = stream-&gt;get_u4_fast();
6839   guarantee_property(magic == JAVA_CLASSFILE_MAGIC,
</pre>
</td>
</tr>
</table>
<center><a href="../../cpu/x86/stubGenerator_x86_64.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="classLoaderData.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
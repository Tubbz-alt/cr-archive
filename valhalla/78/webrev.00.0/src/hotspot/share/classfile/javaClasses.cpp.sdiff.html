<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/javaClasses.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classLoaderData.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/javaClasses.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 882   if (!k-&gt;is_shared()) {
 883     if (k-&gt;is_instance_klass()) {
 884       // During bootstrap, java.lang.Class wasn&#39;t loaded so static field
 885       // offsets were computed without the size added it.  Go back and
 886       // update all the static field offsets to included the size.
 887       for (JavaFieldStream fs(InstanceKlass::cast(k)); !fs.done(); fs.next()) {
 888         if (fs.access_flags().is_static()) {
 889           int real_offset = fs.offset() + InstanceMirrorKlass::offset_of_static_fields();
 890           fs.set_offset(real_offset);
 891         }
 892       }
 893     }
 894   }
 895 
 896   if (k-&gt;is_shared() &amp;&amp; k-&gt;has_raw_archived_mirror()) {
 897     if (HeapShared::open_archive_heap_region_mapped()) {
 898       bool present = restore_archived_mirror(k, Handle(), Handle(), Handle(), CHECK);
 899       assert(present, &quot;Missing archived mirror for %s&quot;, k-&gt;external_name());
 900       return;
 901     } else {
<span class="line-modified"> 902       k-&gt;set_java_mirror_handle(NULL);</span>
 903       k-&gt;clear_has_raw_archived_mirror();
 904     }
 905   }
 906   create_mirror(k, Handle(), Handle(), Handle(), Handle(), CHECK);
 907 }
 908 
 909 void java_lang_Class::initialize_mirror_fields(Klass* k,
 910                                                Handle mirror,
 911                                                Handle protection_domain,
 912                                                Handle classData,
 913                                                TRAPS) {
 914   // Allocate a simple java object for a lock.
 915   // This needs to be a java object because during class initialization
 916   // it can be held across a java call.
 917   typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK);
 918   set_init_lock(mirror(), r);
 919 
 920   // Set protection domain also
 921   set_protection_domain(mirror(), protection_domain());
 922 
</pre>
<hr />
<pre>
1210   // Mirror is already archived
1211   if (k-&gt;has_raw_archived_mirror()) {
1212     assert(k-&gt;archived_java_mirror_raw() != NULL, &quot;no archived mirror&quot;);
1213     return k-&gt;archived_java_mirror_raw();
1214   }
1215 
1216   // No mirror
1217   oop mirror = k-&gt;java_mirror();
1218   if (mirror == NULL) {
1219     return NULL;
1220   }
1221 
1222   if (k-&gt;is_instance_klass()) {
1223     InstanceKlass *ik = InstanceKlass::cast(k);
1224     assert(ik-&gt;signers() == NULL, &quot;class with signer should have been excluded&quot;);
1225 
1226     if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
1227           ik-&gt;is_shared_app_class())) {
1228       // Archiving mirror for classes from non-builtin loaders is not
1229       // supported. Clear the _java_mirror within the archived class.
<span class="line-modified">1230       k-&gt;set_java_mirror_handle(NULL);</span>
1231       return NULL;
1232     }
1233   }
1234 
1235   if (k-&gt;is_value()) {
1236     // Values have a val type mirror and a ref type mirror. Don&#39;t handle this for now. TODO:CDS
<span class="line-modified">1237     k-&gt;set_java_mirror_handle(NULL);</span>
1238     return NULL;
1239   }
1240 
1241   // Now start archiving the mirror object
1242   oop archived_mirror = HeapShared::archive_heap_object(mirror, THREAD);
1243   if (archived_mirror == NULL) {
1244     return NULL;
1245   }
1246 
1247   archived_mirror = process_archived_mirror(k, mirror, archived_mirror, THREAD);
1248   if (archived_mirror == NULL) {
1249     return NULL;
1250   }
1251 
1252   k-&gt;set_archived_java_mirror_raw(archived_mirror);
1253 
1254   k-&gt;set_has_raw_archived_mirror();
1255 
1256   ResourceMark rm;
1257   log_trace(cds, heap, mirror)(
</pre>
</td>
<td>
<hr />
<pre>
 882   if (!k-&gt;is_shared()) {
 883     if (k-&gt;is_instance_klass()) {
 884       // During bootstrap, java.lang.Class wasn&#39;t loaded so static field
 885       // offsets were computed without the size added it.  Go back and
 886       // update all the static field offsets to included the size.
 887       for (JavaFieldStream fs(InstanceKlass::cast(k)); !fs.done(); fs.next()) {
 888         if (fs.access_flags().is_static()) {
 889           int real_offset = fs.offset() + InstanceMirrorKlass::offset_of_static_fields();
 890           fs.set_offset(real_offset);
 891         }
 892       }
 893     }
 894   }
 895 
 896   if (k-&gt;is_shared() &amp;&amp; k-&gt;has_raw_archived_mirror()) {
 897     if (HeapShared::open_archive_heap_region_mapped()) {
 898       bool present = restore_archived_mirror(k, Handle(), Handle(), Handle(), CHECK);
 899       assert(present, &quot;Missing archived mirror for %s&quot;, k-&gt;external_name());
 900       return;
 901     } else {
<span class="line-modified"> 902       k-&gt;set_java_mirror_handle(OopHandle());</span>
 903       k-&gt;clear_has_raw_archived_mirror();
 904     }
 905   }
 906   create_mirror(k, Handle(), Handle(), Handle(), Handle(), CHECK);
 907 }
 908 
 909 void java_lang_Class::initialize_mirror_fields(Klass* k,
 910                                                Handle mirror,
 911                                                Handle protection_domain,
 912                                                Handle classData,
 913                                                TRAPS) {
 914   // Allocate a simple java object for a lock.
 915   // This needs to be a java object because during class initialization
 916   // it can be held across a java call.
 917   typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK);
 918   set_init_lock(mirror(), r);
 919 
 920   // Set protection domain also
 921   set_protection_domain(mirror(), protection_domain());
 922 
</pre>
<hr />
<pre>
1210   // Mirror is already archived
1211   if (k-&gt;has_raw_archived_mirror()) {
1212     assert(k-&gt;archived_java_mirror_raw() != NULL, &quot;no archived mirror&quot;);
1213     return k-&gt;archived_java_mirror_raw();
1214   }
1215 
1216   // No mirror
1217   oop mirror = k-&gt;java_mirror();
1218   if (mirror == NULL) {
1219     return NULL;
1220   }
1221 
1222   if (k-&gt;is_instance_klass()) {
1223     InstanceKlass *ik = InstanceKlass::cast(k);
1224     assert(ik-&gt;signers() == NULL, &quot;class with signer should have been excluded&quot;);
1225 
1226     if (!(ik-&gt;is_shared_boot_class() || ik-&gt;is_shared_platform_class() ||
1227           ik-&gt;is_shared_app_class())) {
1228       // Archiving mirror for classes from non-builtin loaders is not
1229       // supported. Clear the _java_mirror within the archived class.
<span class="line-modified">1230       k-&gt;set_java_mirror_handle(OopHandle());</span>
1231       return NULL;
1232     }
1233   }
1234 
1235   if (k-&gt;is_value()) {
1236     // Values have a val type mirror and a ref type mirror. Don&#39;t handle this for now. TODO:CDS
<span class="line-modified">1237     k-&gt;set_java_mirror_handle(OopHandle());</span>
1238     return NULL;
1239   }
1240 
1241   // Now start archiving the mirror object
1242   oop archived_mirror = HeapShared::archive_heap_object(mirror, THREAD);
1243   if (archived_mirror == NULL) {
1244     return NULL;
1245   }
1246 
1247   archived_mirror = process_archived_mirror(k, mirror, archived_mirror, THREAD);
1248   if (archived_mirror == NULL) {
1249     return NULL;
1250   }
1251 
1252   k-&gt;set_archived_java_mirror_raw(archived_mirror);
1253 
1254   k-&gt;set_has_raw_archived_mirror();
1255 
1256   ResourceMark rm;
1257   log_trace(cds, heap, mirror)(
</pre>
</td>
</tr>
</table>
<center><a href="classLoaderData.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
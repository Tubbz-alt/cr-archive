<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/classfile/systemDictionary.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="javaClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/classfile/systemDictionary.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  29 #include &quot;classfile/classFileStream.hpp&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  32 #include &quot;classfile/classLoaderDataGraph.inline.hpp&quot;
  33 #include &quot;classfile/classLoaderExt.hpp&quot;
  34 #include &quot;classfile/dictionary.hpp&quot;
  35 #include &quot;classfile/javaClasses.inline.hpp&quot;
  36 #include &quot;classfile/klassFactory.hpp&quot;
  37 #include &quot;classfile/loaderConstraints.hpp&quot;
  38 #include &quot;classfile/packageEntry.hpp&quot;
  39 #include &quot;classfile/placeholders.hpp&quot;
  40 #include &quot;classfile/protectionDomainCache.hpp&quot;
  41 #include &quot;classfile/resolutionErrors.hpp&quot;
  42 #include &quot;classfile/stringTable.hpp&quot;
  43 #include &quot;classfile/symbolTable.hpp&quot;
  44 #include &quot;classfile/systemDictionary.hpp&quot;
  45 #include &quot;classfile/vmSymbols.hpp&quot;
  46 #include &quot;code/codeCache.hpp&quot;
  47 #include &quot;compiler/compileBroker.hpp&quot;
  48 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
<span class="line-removed">  49 #include &quot;gc/shared/oopStorage.inline.hpp&quot;</span>
<span class="line-removed">  50 #include &quot;gc/shared/oopStorageSet.hpp&quot;</span>
  51 #include &quot;interpreter/bytecodeStream.hpp&quot;
  52 #include &quot;interpreter/interpreter.hpp&quot;
  53 #include &quot;jfr/jfrEvents.hpp&quot;
  54 #include &quot;logging/log.hpp&quot;
  55 #include &quot;logging/logStream.hpp&quot;
  56 #include &quot;memory/filemap.hpp&quot;
  57 #include &quot;memory/heapShared.hpp&quot;
  58 #include &quot;memory/metaspaceClosure.hpp&quot;
  59 #include &quot;memory/oopFactory.hpp&quot;
  60 #include &quot;memory/resourceArea.hpp&quot;
  61 #include &quot;memory/universe.hpp&quot;
  62 #include &quot;oops/access.inline.hpp&quot;
  63 #include &quot;oops/fieldStreams.inline.hpp&quot;
  64 #include &quot;oops/instanceKlass.hpp&quot;
  65 #include &quot;oops/instanceRefKlass.hpp&quot;
  66 #include &quot;oops/klass.inline.hpp&quot;
  67 #include &quot;oops/method.inline.hpp&quot;
  68 #include &quot;oops/methodData.hpp&quot;
  69 #include &quot;oops/objArrayKlass.hpp&quot;
  70 #include &quot;oops/objArrayOop.inline.hpp&quot;
  71 #include &quot;oops/oop.inline.hpp&quot;

  72 #include &quot;oops/symbol.hpp&quot;
  73 #include &quot;oops/typeArrayKlass.hpp&quot;
  74 #include &quot;oops/valueKlass.hpp&quot;
  75 #include &quot;prims/jvmtiExport.hpp&quot;
  76 #include &quot;prims/methodHandles.hpp&quot;
  77 #include &quot;runtime/arguments.hpp&quot;
  78 #include &quot;runtime/biasedLocking.hpp&quot;
  79 #include &quot;runtime/handles.inline.hpp&quot;
  80 #include &quot;runtime/java.hpp&quot;
  81 #include &quot;runtime/javaCalls.hpp&quot;
  82 #include &quot;runtime/mutexLocker.hpp&quot;
  83 #include &quot;runtime/os.hpp&quot;
  84 #include &quot;runtime/sharedRuntime.hpp&quot;
  85 #include &quot;runtime/signature.hpp&quot;
  86 #include &quot;services/classLoadingService.hpp&quot;
  87 #include &quot;services/diagnosticCommand.hpp&quot;
  88 #include &quot;services/threadService.hpp&quot;
  89 #include &quot;utilities/macros.hpp&quot;
  90 #include &quot;utilities/utf8.hpp&quot;
  91 #if INCLUDE_CDS
  92 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  93 #endif
  94 #if INCLUDE_JFR
  95 #include &quot;jfr/jfr.hpp&quot;
  96 #endif
  97 
  98 PlaceholderTable*      SystemDictionary::_placeholders        = NULL;
  99 LoaderConstraintTable* SystemDictionary::_loader_constraints  = NULL;
 100 ResolutionErrorTable*  SystemDictionary::_resolution_errors   = NULL;
 101 SymbolPropertyTable*   SystemDictionary::_invoke_method_table = NULL;
 102 ProtectionDomainCacheTable*   SystemDictionary::_pd_cache_table = NULL;
 103 
<span class="line-removed"> 104 oop         SystemDictionary::_system_loader_lock_obj     =  NULL;</span>
<span class="line-removed"> 105 </span>
 106 InstanceKlass*      SystemDictionary::_well_known_klasses[SystemDictionary::WKID_LIMIT]
 107                                                           =  { NULL /*, NULL...*/ };
 108 
 109 InstanceKlass*      SystemDictionary::_box_klasses[T_VOID+1]      =  { NULL /*, NULL...*/ };
 110 
<span class="line-modified"> 111 oop         SystemDictionary::_java_system_loader         =  NULL;</span>
<span class="line-modified"> 112 oop         SystemDictionary::_java_platform_loader       =  NULL;</span>


 113 
 114 // Default ProtectionDomainCacheSize value
 115 
 116 const int defaultProtectionDomainCacheSize = 1009;
 117 
 118 ClassLoadInfo::ClassLoadInfo() {
 119   _protection_domain = Handle();
 120   _unsafe_anonymous_host = NULL;
 121   _cp_patches = NULL;
 122   _class_hidden_info._dynamic_nest_host = NULL;
 123   _class_hidden_info._class_data = Handle();
 124   _is_hidden = false;
 125   _is_strong_hidden = false;
 126   _can_access_vm_annotations = false;
 127 }
 128 
 129 ClassLoadInfo::ClassLoadInfo(Handle protection_domain) {
 130   _protection_domain = protection_domain;
 131   _unsafe_anonymous_host = NULL;
 132   _cp_patches = NULL;
</pre>
<hr />
<pre>
 141                              const InstanceKlass* unsafe_anonymous_host,
 142                              GrowableArray&lt;Handle&gt;* cp_patches,
 143                              InstanceKlass* dynamic_nest_host,
 144                              Handle class_data,
 145                              bool is_hidden,
 146                              bool is_strong_hidden,
 147                              bool can_access_vm_annotations) {
 148   _protection_domain = protection_domain;
 149   _unsafe_anonymous_host = unsafe_anonymous_host;
 150   _cp_patches = cp_patches;
 151   _class_hidden_info._dynamic_nest_host = dynamic_nest_host;
 152   _class_hidden_info._class_data = class_data;
 153   _is_hidden = is_hidden;
 154   _is_strong_hidden = is_strong_hidden;
 155   _can_access_vm_annotations = can_access_vm_annotations;
 156 }
 157 
 158 // ----------------------------------------------------------------------------
 159 // Java-level SystemLoader and PlatformLoader
 160 




 161 oop SystemDictionary::java_system_loader() {
<span class="line-modified"> 162   return _java_system_loader;</span>
 163 }
 164 
 165 oop SystemDictionary::java_platform_loader() {
<span class="line-modified"> 166   return _java_platform_loader;</span>
 167 }
 168 
 169 void SystemDictionary::compute_java_loaders(TRAPS) {
 170   JavaValue result(T_OBJECT);
 171   InstanceKlass* class_loader_klass = SystemDictionary::ClassLoader_klass();
 172   JavaCalls::call_static(&amp;result,
 173                          class_loader_klass,
 174                          vmSymbols::getSystemClassLoader_name(),
 175                          vmSymbols::void_classloader_signature(),
 176                          CHECK);
 177 
<span class="line-modified"> 178   _java_system_loader = (oop)result.get_jobject();</span>
 179 
 180   JavaCalls::call_static(&amp;result,
 181                          class_loader_klass,
 182                          vmSymbols::getPlatformClassLoader_name(),
 183                          vmSymbols::void_classloader_signature(),
 184                          CHECK);
 185 
<span class="line-modified"> 186   _java_platform_loader = (oop)result.get_jobject();</span>
 187 }
 188 
 189 ClassLoaderData* SystemDictionary::register_loader(Handle class_loader, bool create_mirror_cld) {
 190   if (create_mirror_cld) {
 191     // Add a new class loader data to the graph.
 192     return ClassLoaderDataGraph::add(class_loader, true);
 193   } else {
 194     return (class_loader() == NULL) ? ClassLoaderData::the_null_class_loader_data() :
 195                                       ClassLoaderDataGraph::find_or_create(class_loader);
 196   }
 197 }
 198 
 199 // ----------------------------------------------------------------------------
 200 // Parallel class loading check
 201 
 202 bool SystemDictionary::is_parallelCapable(Handle class_loader) {
 203   if (class_loader.is_null()) return true;
 204   if (AlwaysLockClassLoader) return false;
 205   return java_lang_ClassLoader::parallelCapable(class_loader());
 206 }
 207 // ----------------------------------------------------------------------------
 208 // ParallelDefineClass flag does not apply to bootclass loader
 209 bool SystemDictionary::is_parallelDefine(Handle class_loader) {
 210    if (class_loader.is_null()) return false;
 211    if (AllowParallelDefineClass &amp;&amp; java_lang_ClassLoader::parallelCapable(class_loader())) {
 212      return true;
 213    }
 214    return false;
 215 }
 216 
 217 // Returns true if the passed class loader is the builtin application class loader
 218 // or a custom system class loader. A customer system class loader can be
 219 // specified via -Djava.system.class.loader.
 220 bool SystemDictionary::is_system_class_loader(oop class_loader) {
 221   if (class_loader == NULL) {
 222     return false;
 223   }
 224   return (class_loader-&gt;klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_AppClassLoader_klass() ||
<span class="line-modified"> 225          class_loader == _java_system_loader);</span>
 226 }
 227 
 228 // Returns true if the passed class loader is the platform class loader.
 229 bool SystemDictionary::is_platform_class_loader(oop class_loader) {
 230   if (class_loader == NULL) {
 231     return false;
 232   }
 233   return (class_loader-&gt;klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_PlatformClassLoader_klass());
 234 }
 235 
 236 // ----------------------------------------------------------------------------
 237 // Resolving of classes
 238 
 239 Symbol* SystemDictionary::class_name_symbol(const char* name, Symbol* exception, TRAPS) {
 240   if (name == NULL) {
 241     THROW_MSG_0(exception, &quot;No class name given&quot;);
 242   }
 243   if ((int)strlen(name) &gt; Symbol::max_length()) {
 244     // It&#39;s impossible to create this class;  the name cannot fit
 245     // into the constant pool.
</pre>
<hr />
<pre>
 633 //     so another thread got here in parallel
 634 //
 635 // lockObject must be held.
 636 // Complicated dance due to lock ordering:
 637 // Must first release the classloader object lock to
 638 // allow initial definer to complete the class definition
 639 // and to avoid deadlock
 640 // Reclaim classloader lock object with same original recursion count
 641 // Must release SystemDictionary_lock after notify, since
 642 // class loader lock must be claimed before SystemDictionary_lock
 643 // to prevent deadlocks
 644 //
 645 // The notify allows applications that did an untimed wait() on
 646 // the classloader object lock to not hang.
 647 void SystemDictionary::double_lock_wait(Handle lockObject, TRAPS) {
 648   assert_lock_strong(SystemDictionary_lock);
 649 
 650   bool calledholdinglock
 651       = ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, lockObject);
 652   assert(calledholdinglock,&quot;must hold lock for notify&quot;);
<span class="line-modified"> 653   assert((lockObject() != _system_loader_lock_obj &amp;&amp; !is_parallelCapable(lockObject)), &quot;unexpected double_lock_wait&quot;);</span>

 654   ObjectSynchronizer::notifyall(lockObject, THREAD);
 655   intx recursions =  ObjectSynchronizer::complete_exit(lockObject, THREAD);
 656   SystemDictionary_lock-&gt;wait();
 657   SystemDictionary_lock-&gt;unlock();
 658   ObjectSynchronizer::reenter(lockObject, recursions, THREAD);
 659   SystemDictionary_lock-&gt;lock();
 660 }
 661 
 662 // If the class in is in the placeholder table, class loading is in progress
 663 // For cases where the application changes threads to load classes, it
 664 // is critical to ClassCircularity detection that we try loading
 665 // the superclass on the same thread internally, so we do parallel
 666 // super class loading here.
 667 // This also is critical in cases where the original thread gets stalled
 668 // even in non-circularity situations.
 669 // Note: must call resolve_super_or_fail even if null super -
 670 // to force placeholder entry creation for this class for circularity detection
 671 // Caller must check for pending exception
 672 // Returns non-null Klass* if other thread has completed load
 673 // and we are done,
</pre>
<hr />
<pre>
 729         // This logic has the current thread wait once it has done
 730         // all the superclass/superinterface loading it can, until
 731         // the original thread completes the class loading or fails
 732         // If it completes we will use the resulting InstanceKlass
 733         // which we will find below in the systemDictionary.
 734         // We also get here for parallel bootstrap classloader
 735         if (class_loader.is_null()) {
 736           SystemDictionary_lock-&gt;wait();
 737         } else {
 738           double_lock_wait(lockObject, THREAD);
 739         }
 740       } else {
 741         // If not in SD and not in PH, other thread&#39;s load must have failed
 742         super_load_in_progress = false;
 743       }
 744     }
 745   }
 746   return NULL;
 747 }
 748 
<span class="line-modified"> 749 static void post_class_load_event(EventClassLoad* event, const InstanceKlass* k, const ClassLoaderData* init_cld) {</span>
 750   assert(event != NULL, &quot;invariant&quot;);
 751   assert(k != NULL, &quot;invariant&quot;);
 752   assert(event-&gt;should_commit(), &quot;invariant&quot;);
 753   event-&gt;set_loadedClass(k);
 754   event-&gt;set_definingClassLoader(k-&gt;class_loader_data());
 755   event-&gt;set_initiatingClassLoader(init_cld);
 756   event-&gt;commit();
 757 }
 758 
 759 
 760 // Be careful when modifying this code: once you have run
 761 // placeholders()-&gt;find_and_add(PlaceholderTable::LOAD_INSTANCE),
 762 // you need to find_and_remove it before returning.
 763 // So be careful to not exit with a CHECK_ macro betweeen these calls.
 764 //
 765 // name must be in the form of &quot;java/lang/Object&quot; -- cannot be &quot;Ljava/lang/Object;&quot;
 766 InstanceKlass* SystemDictionary::resolve_instance_class_or_null(Symbol* name,
 767                                                                 Handle class_loader,
 768                                                                 Handle protection_domain,
 769                                                                 TRAPS) {
</pre>
<hr />
<pre>
1395   // If unexpected superclass or interfaces are found, we cannot
1396   // load &lt;ik&gt; from the shared archive.
1397 
1398   if (ik-&gt;super() != NULL &amp;&amp;
1399       !check_shared_class_super_type(ik, InstanceKlass::cast(ik-&gt;super()),
1400                                      class_loader, protection_domain, true, THREAD)) {
1401     return false;
1402   }
1403 
1404   Array&lt;InstanceKlass*&gt;* interfaces = ik-&gt;local_interfaces();
1405   int num_interfaces = interfaces-&gt;length();
1406   for (int index = 0; index &lt; num_interfaces; index++) {
1407     if (!check_shared_class_super_type(ik, interfaces-&gt;at(index), class_loader, protection_domain, false, THREAD)) {
1408       return false;
1409     }
1410   }
1411 
1412   return true;
1413 }
1414 































1415 InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,
1416                                                    Handle class_loader,
1417                                                    Handle protection_domain,
1418                                                    const ClassFileStream *cfs,
1419                                                    PackageEntry* pkg_entry,
1420                                                    TRAPS) {
1421   assert(ik != NULL, &quot;sanity&quot;);
1422   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);
1423   Symbol* class_name = ik-&gt;name();
1424 
1425   bool visible = is_shared_class_visible(
1426                           class_name, ik, pkg_entry, class_loader, CHECK_NULL);
1427   if (!visible) {
1428     return NULL;
1429   }
1430 
1431   if (!check_shared_class_super_types(ik, class_loader, protection_domain, THREAD)) {
1432     return NULL;
1433   }
1434 
<span class="line-modified">1435   InstanceKlass* new_ik = KlassFactory::check_shared_class_file_load_hook(</span>




1436       ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);

1437   if (new_ik != NULL) {
1438     // The class is changed by CFLH. Return the new class. The shared class is
1439     // not used.
1440     return new_ik;
1441   }
1442 
1443   // Adjust methods to recover missing data.  They need addresses for
1444   // interpreter entry points and their default native method address
1445   // must be reset.
1446 
1447   // Updating methods must be done under a lock so multiple
1448   // threads don&#39;t update these in parallel
1449   //
1450   // Shared classes are all currently loaded by either the bootstrap or
1451   // internal parallel class loaders, so this will never cause a deadlock
1452   // on a custom class loader lock.
1453 
1454   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
1455   {
1456     HandleMark hm(THREAD);
</pre>
<hr />
<pre>
1850       } else {
1851         probe-&gt;set_instance_klass(k);
1852       }
1853       probe-&gt;set_definer(NULL);
1854       placeholders()-&gt;find_and_remove(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);
1855       SystemDictionary_lock-&gt;notify_all();
1856     }
1857   }
1858 
1859   // Can&#39;t throw exception while holding lock due to rank ordering
1860   if (linkage_exception() != NULL) {
1861     THROW_OOP_(linkage_exception(), NULL); // throws exception and returns
1862   }
1863 
1864   return k;
1865 }
1866 
1867 Handle SystemDictionary::compute_loader_lock_object(Handle class_loader, TRAPS) {
1868   // If class_loader is NULL we synchronize on _system_loader_lock_obj
1869   if (class_loader.is_null()) {
<span class="line-modified">1870     return Handle(THREAD, _system_loader_lock_obj);</span>
1871   } else {
1872     return class_loader;
1873   }
1874 }
1875 
1876 // This method is added to check how often we have to wait to grab loader
1877 // lock. The results are being recorded in the performance counters defined in
1878 // ClassLoader::_sync_systemLoaderLockContentionRate and
1879 // ClassLoader::_sync_nonSystemLoaderLockConteionRate.
1880 void SystemDictionary::check_loader_lock_contention(Handle loader_lock, TRAPS) {
1881   if (!UsePerfData) {
1882     return;
1883   }
1884 
1885   assert(!loader_lock.is_null(), &quot;NULL lock object&quot;);
1886 
1887   if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader_lock)
1888       == ObjectSynchronizer::owner_other) {
1889     // contention will likely happen, so increment the corresponding
1890     // contention counter.
<span class="line-modified">1891     if (loader_lock() == _system_loader_lock_obj) {</span>
1892       ClassLoader::sync_systemLoaderLockContentionRate()-&gt;inc();
1893     } else {
1894       ClassLoader::sync_nonSystemLoaderLockContentionRate()-&gt;inc();
1895     }
1896   }
1897 }
1898 
1899 // ----------------------------------------------------------------------------
1900 // Lookup
1901 
1902 InstanceKlass* SystemDictionary::find_class(unsigned int hash,
1903                                             Symbol* class_name,
1904                                             Dictionary* dictionary) {
1905   assert_locked_or_safepoint(SystemDictionary_lock);
1906   int index = dictionary-&gt;hash_to_index(hash);
1907   return dictionary-&gt;find_class(index, hash, class_name);
1908 }
1909 
1910 
1911 // Basic find on classes in the midst of being loaded
</pre>
<hr />
<pre>
1988       resolution_errors()-&gt;purge_resolution_errors();
1989     }
1990   }
1991 
1992   GCTraceTime(Debug, gc, phases) t(&quot;Trigger cleanups&quot;, gc_timer);
1993 
1994   if (unloading_occurred) {
1995     SymbolTable::trigger_cleanup();
1996 
1997     // Oops referenced by the protection domain cache table may get unreachable independently
1998     // of the class loader (eg. cached protection domain oops). So we need to
1999     // explicitly unlink them here.
2000     // All protection domain oops are linked to the caller class, so if nothing
2001     // unloads, this is not needed.
2002     _pd_cache_table-&gt;trigger_cleanup();
2003   }
2004 
2005   return unloading_occurred;
2006 }
2007 
<span class="line-removed">2008 void SystemDictionary::oops_do(OopClosure* f, bool include_handles) {</span>
<span class="line-removed">2009   f-&gt;do_oop(&amp;_java_system_loader);</span>
<span class="line-removed">2010   f-&gt;do_oop(&amp;_java_platform_loader);</span>
<span class="line-removed">2011   f-&gt;do_oop(&amp;_system_loader_lock_obj);</span>
<span class="line-removed">2012   CDS_ONLY(SystemDictionaryShared::oops_do(f);)</span>
<span class="line-removed">2013 </span>
<span class="line-removed">2014   // Visit extra methods</span>
<span class="line-removed">2015   invoke_method_table()-&gt;oops_do(f);</span>
<span class="line-removed">2016 </span>
<span class="line-removed">2017   if (include_handles) {</span>
<span class="line-removed">2018     OopStorageSet::vm_global()-&gt;oops_do(f);</span>
<span class="line-removed">2019   }</span>
<span class="line-removed">2020 }</span>
<span class="line-removed">2021 </span>
2022 // CDS: scan and relocate all classes referenced by _well_known_klasses[].
2023 void SystemDictionary::well_known_klasses_do(MetaspaceClosure* it) {
2024   for (int id = FIRST_WKID; id &lt; WKID_LIMIT; id++) {
2025     it-&gt;push(well_known_klass_addr((WKID)id));
2026   }
2027 }
2028 
2029 void SystemDictionary::methods_do(void f(Method*)) {
2030   // Walk methods in loaded classes
2031   MutexLocker ml(ClassLoaderDataGraph_lock);
2032   ClassLoaderDataGraph::methods_do(f);
2033   // Walk method handle intrinsics
2034   invoke_method_table()-&gt;methods_do(f);
2035 }
2036 
2037 // ----------------------------------------------------------------------------
2038 // Initialization
2039 
2040 void SystemDictionary::initialize(TRAPS) {
2041   // Allocate arrays
2042   _placeholders        = new PlaceholderTable(_placeholder_table_size);
2043   _loader_constraints  = new LoaderConstraintTable(_loader_constraint_size);
2044   _resolution_errors   = new ResolutionErrorTable(_resolution_error_size);
2045   _invoke_method_table = new SymbolPropertyTable(_invoke_method_size);
2046   _pd_cache_table = new ProtectionDomainCacheTable(defaultProtectionDomainCacheSize);
2047 
2048   // Allocate private object used as system class loader lock
<span class="line-modified">2049   _system_loader_lock_obj = oopFactory::new_intArray(0, CHECK);</span>


2050   // Initialize basic classes
2051   resolve_well_known_classes(CHECK);
2052 }
2053 
2054 // Compact table of directions on the initialization of klasses:
2055 static const short wk_init_info[] = {
2056   #define WK_KLASS_INIT_INFO(name, symbol) \
2057     ((short)vmSymbols::VM_SYMBOL_ENUM_NAME(symbol)),
2058 
2059   WK_KLASSES_DO(WK_KLASS_INIT_INFO)
2060   #undef WK_KLASS_INIT_INFO
2061   0
2062 };
2063 
2064 #ifdef ASSERT
2065 bool SystemDictionary::is_well_known_klass(Symbol* class_name) {
2066   int sid;
2067   for (int i = 0; (sid = wk_init_info[i]) != 0; i++) {
2068     Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
2069     if (class_name == symbol) {
</pre>
</td>
<td>
<hr />
<pre>
  29 #include &quot;classfile/classFileStream.hpp&quot;
  30 #include &quot;classfile/classLoader.hpp&quot;
  31 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  32 #include &quot;classfile/classLoaderDataGraph.inline.hpp&quot;
  33 #include &quot;classfile/classLoaderExt.hpp&quot;
  34 #include &quot;classfile/dictionary.hpp&quot;
  35 #include &quot;classfile/javaClasses.inline.hpp&quot;
  36 #include &quot;classfile/klassFactory.hpp&quot;
  37 #include &quot;classfile/loaderConstraints.hpp&quot;
  38 #include &quot;classfile/packageEntry.hpp&quot;
  39 #include &quot;classfile/placeholders.hpp&quot;
  40 #include &quot;classfile/protectionDomainCache.hpp&quot;
  41 #include &quot;classfile/resolutionErrors.hpp&quot;
  42 #include &quot;classfile/stringTable.hpp&quot;
  43 #include &quot;classfile/symbolTable.hpp&quot;
  44 #include &quot;classfile/systemDictionary.hpp&quot;
  45 #include &quot;classfile/vmSymbols.hpp&quot;
  46 #include &quot;code/codeCache.hpp&quot;
  47 #include &quot;compiler/compileBroker.hpp&quot;
  48 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;


  49 #include &quot;interpreter/bytecodeStream.hpp&quot;
  50 #include &quot;interpreter/interpreter.hpp&quot;
  51 #include &quot;jfr/jfrEvents.hpp&quot;
  52 #include &quot;logging/log.hpp&quot;
  53 #include &quot;logging/logStream.hpp&quot;
  54 #include &quot;memory/filemap.hpp&quot;
  55 #include &quot;memory/heapShared.hpp&quot;
  56 #include &quot;memory/metaspaceClosure.hpp&quot;
  57 #include &quot;memory/oopFactory.hpp&quot;
  58 #include &quot;memory/resourceArea.hpp&quot;
  59 #include &quot;memory/universe.hpp&quot;
  60 #include &quot;oops/access.inline.hpp&quot;
  61 #include &quot;oops/fieldStreams.inline.hpp&quot;
  62 #include &quot;oops/instanceKlass.hpp&quot;
  63 #include &quot;oops/instanceRefKlass.hpp&quot;
  64 #include &quot;oops/klass.inline.hpp&quot;
  65 #include &quot;oops/method.inline.hpp&quot;
  66 #include &quot;oops/methodData.hpp&quot;
  67 #include &quot;oops/objArrayKlass.hpp&quot;
  68 #include &quot;oops/objArrayOop.inline.hpp&quot;
  69 #include &quot;oops/oop.inline.hpp&quot;
<span class="line-added">  70 #include &quot;oops/oopHandle.inline.hpp&quot;</span>
  71 #include &quot;oops/symbol.hpp&quot;
  72 #include &quot;oops/typeArrayKlass.hpp&quot;
  73 #include &quot;oops/valueKlass.hpp&quot;
  74 #include &quot;prims/jvmtiExport.hpp&quot;
  75 #include &quot;prims/methodHandles.hpp&quot;
  76 #include &quot;runtime/arguments.hpp&quot;
  77 #include &quot;runtime/biasedLocking.hpp&quot;
  78 #include &quot;runtime/handles.inline.hpp&quot;
  79 #include &quot;runtime/java.hpp&quot;
  80 #include &quot;runtime/javaCalls.hpp&quot;
  81 #include &quot;runtime/mutexLocker.hpp&quot;
  82 #include &quot;runtime/os.hpp&quot;
  83 #include &quot;runtime/sharedRuntime.hpp&quot;
  84 #include &quot;runtime/signature.hpp&quot;
  85 #include &quot;services/classLoadingService.hpp&quot;
  86 #include &quot;services/diagnosticCommand.hpp&quot;
  87 #include &quot;services/threadService.hpp&quot;
  88 #include &quot;utilities/macros.hpp&quot;
  89 #include &quot;utilities/utf8.hpp&quot;
  90 #if INCLUDE_CDS
  91 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  92 #endif
  93 #if INCLUDE_JFR
  94 #include &quot;jfr/jfr.hpp&quot;
  95 #endif
  96 
  97 PlaceholderTable*      SystemDictionary::_placeholders        = NULL;
  98 LoaderConstraintTable* SystemDictionary::_loader_constraints  = NULL;
  99 ResolutionErrorTable*  SystemDictionary::_resolution_errors   = NULL;
 100 SymbolPropertyTable*   SystemDictionary::_invoke_method_table = NULL;
 101 ProtectionDomainCacheTable*   SystemDictionary::_pd_cache_table = NULL;
 102 


 103 InstanceKlass*      SystemDictionary::_well_known_klasses[SystemDictionary::WKID_LIMIT]
 104                                                           =  { NULL /*, NULL...*/ };
 105 
 106 InstanceKlass*      SystemDictionary::_box_klasses[T_VOID+1]      =  { NULL /*, NULL...*/ };
 107 
<span class="line-modified"> 108 </span>
<span class="line-modified"> 109 OopHandle   SystemDictionary::_system_loader_lock_obj;</span>
<span class="line-added"> 110 OopHandle   SystemDictionary::_java_system_loader;</span>
<span class="line-added"> 111 OopHandle   SystemDictionary::_java_platform_loader;</span>
 112 
 113 // Default ProtectionDomainCacheSize value
 114 
 115 const int defaultProtectionDomainCacheSize = 1009;
 116 
 117 ClassLoadInfo::ClassLoadInfo() {
 118   _protection_domain = Handle();
 119   _unsafe_anonymous_host = NULL;
 120   _cp_patches = NULL;
 121   _class_hidden_info._dynamic_nest_host = NULL;
 122   _class_hidden_info._class_data = Handle();
 123   _is_hidden = false;
 124   _is_strong_hidden = false;
 125   _can_access_vm_annotations = false;
 126 }
 127 
 128 ClassLoadInfo::ClassLoadInfo(Handle protection_domain) {
 129   _protection_domain = protection_domain;
 130   _unsafe_anonymous_host = NULL;
 131   _cp_patches = NULL;
</pre>
<hr />
<pre>
 140                              const InstanceKlass* unsafe_anonymous_host,
 141                              GrowableArray&lt;Handle&gt;* cp_patches,
 142                              InstanceKlass* dynamic_nest_host,
 143                              Handle class_data,
 144                              bool is_hidden,
 145                              bool is_strong_hidden,
 146                              bool can_access_vm_annotations) {
 147   _protection_domain = protection_domain;
 148   _unsafe_anonymous_host = unsafe_anonymous_host;
 149   _cp_patches = cp_patches;
 150   _class_hidden_info._dynamic_nest_host = dynamic_nest_host;
 151   _class_hidden_info._class_data = class_data;
 152   _is_hidden = is_hidden;
 153   _is_strong_hidden = is_strong_hidden;
 154   _can_access_vm_annotations = can_access_vm_annotations;
 155 }
 156 
 157 // ----------------------------------------------------------------------------
 158 // Java-level SystemLoader and PlatformLoader
 159 
<span class="line-added"> 160 oop SystemDictionary::system_loader_lock() {</span>
<span class="line-added"> 161   return _system_loader_lock_obj.resolve();</span>
<span class="line-added"> 162 }</span>
<span class="line-added"> 163 </span>
 164 oop SystemDictionary::java_system_loader() {
<span class="line-modified"> 165   return _java_system_loader.resolve();</span>
 166 }
 167 
 168 oop SystemDictionary::java_platform_loader() {
<span class="line-modified"> 169   return _java_platform_loader.resolve();</span>
 170 }
 171 
 172 void SystemDictionary::compute_java_loaders(TRAPS) {
 173   JavaValue result(T_OBJECT);
 174   InstanceKlass* class_loader_klass = SystemDictionary::ClassLoader_klass();
 175   JavaCalls::call_static(&amp;result,
 176                          class_loader_klass,
 177                          vmSymbols::getSystemClassLoader_name(),
 178                          vmSymbols::void_classloader_signature(),
 179                          CHECK);
 180 
<span class="line-modified"> 181   _java_system_loader = OopHandle::create((oop)result.get_jobject());</span>
 182 
 183   JavaCalls::call_static(&amp;result,
 184                          class_loader_klass,
 185                          vmSymbols::getPlatformClassLoader_name(),
 186                          vmSymbols::void_classloader_signature(),
 187                          CHECK);
 188 
<span class="line-modified"> 189   _java_platform_loader = OopHandle::create((oop)result.get_jobject());</span>
 190 }
 191 
 192 ClassLoaderData* SystemDictionary::register_loader(Handle class_loader, bool create_mirror_cld) {
 193   if (create_mirror_cld) {
 194     // Add a new class loader data to the graph.
 195     return ClassLoaderDataGraph::add(class_loader, true);
 196   } else {
 197     return (class_loader() == NULL) ? ClassLoaderData::the_null_class_loader_data() :
 198                                       ClassLoaderDataGraph::find_or_create(class_loader);
 199   }
 200 }
 201 
 202 // ----------------------------------------------------------------------------
 203 // Parallel class loading check
 204 
 205 bool SystemDictionary::is_parallelCapable(Handle class_loader) {
 206   if (class_loader.is_null()) return true;
 207   if (AlwaysLockClassLoader) return false;
 208   return java_lang_ClassLoader::parallelCapable(class_loader());
 209 }
 210 // ----------------------------------------------------------------------------
 211 // ParallelDefineClass flag does not apply to bootclass loader
 212 bool SystemDictionary::is_parallelDefine(Handle class_loader) {
 213    if (class_loader.is_null()) return false;
 214    if (AllowParallelDefineClass &amp;&amp; java_lang_ClassLoader::parallelCapable(class_loader())) {
 215      return true;
 216    }
 217    return false;
 218 }
 219 
 220 // Returns true if the passed class loader is the builtin application class loader
 221 // or a custom system class loader. A customer system class loader can be
 222 // specified via -Djava.system.class.loader.
 223 bool SystemDictionary::is_system_class_loader(oop class_loader) {
 224   if (class_loader == NULL) {
 225     return false;
 226   }
 227   return (class_loader-&gt;klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_AppClassLoader_klass() ||
<span class="line-modified"> 228          class_loader == _java_system_loader.peek());</span>
 229 }
 230 
 231 // Returns true if the passed class loader is the platform class loader.
 232 bool SystemDictionary::is_platform_class_loader(oop class_loader) {
 233   if (class_loader == NULL) {
 234     return false;
 235   }
 236   return (class_loader-&gt;klass() == SystemDictionary::jdk_internal_loader_ClassLoaders_PlatformClassLoader_klass());
 237 }
 238 
 239 // ----------------------------------------------------------------------------
 240 // Resolving of classes
 241 
 242 Symbol* SystemDictionary::class_name_symbol(const char* name, Symbol* exception, TRAPS) {
 243   if (name == NULL) {
 244     THROW_MSG_0(exception, &quot;No class name given&quot;);
 245   }
 246   if ((int)strlen(name) &gt; Symbol::max_length()) {
 247     // It&#39;s impossible to create this class;  the name cannot fit
 248     // into the constant pool.
</pre>
<hr />
<pre>
 636 //     so another thread got here in parallel
 637 //
 638 // lockObject must be held.
 639 // Complicated dance due to lock ordering:
 640 // Must first release the classloader object lock to
 641 // allow initial definer to complete the class definition
 642 // and to avoid deadlock
 643 // Reclaim classloader lock object with same original recursion count
 644 // Must release SystemDictionary_lock after notify, since
 645 // class loader lock must be claimed before SystemDictionary_lock
 646 // to prevent deadlocks
 647 //
 648 // The notify allows applications that did an untimed wait() on
 649 // the classloader object lock to not hang.
 650 void SystemDictionary::double_lock_wait(Handle lockObject, TRAPS) {
 651   assert_lock_strong(SystemDictionary_lock);
 652 
 653   bool calledholdinglock
 654       = ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, lockObject);
 655   assert(calledholdinglock,&quot;must hold lock for notify&quot;);
<span class="line-modified"> 656   assert((lockObject() != _system_loader_lock_obj.resolve() &amp;&amp;</span>
<span class="line-added"> 657          !is_parallelCapable(lockObject)), &quot;unexpected double_lock_wait&quot;);</span>
 658   ObjectSynchronizer::notifyall(lockObject, THREAD);
 659   intx recursions =  ObjectSynchronizer::complete_exit(lockObject, THREAD);
 660   SystemDictionary_lock-&gt;wait();
 661   SystemDictionary_lock-&gt;unlock();
 662   ObjectSynchronizer::reenter(lockObject, recursions, THREAD);
 663   SystemDictionary_lock-&gt;lock();
 664 }
 665 
 666 // If the class in is in the placeholder table, class loading is in progress
 667 // For cases where the application changes threads to load classes, it
 668 // is critical to ClassCircularity detection that we try loading
 669 // the superclass on the same thread internally, so we do parallel
 670 // super class loading here.
 671 // This also is critical in cases where the original thread gets stalled
 672 // even in non-circularity situations.
 673 // Note: must call resolve_super_or_fail even if null super -
 674 // to force placeholder entry creation for this class for circularity detection
 675 // Caller must check for pending exception
 676 // Returns non-null Klass* if other thread has completed load
 677 // and we are done,
</pre>
<hr />
<pre>
 733         // This logic has the current thread wait once it has done
 734         // all the superclass/superinterface loading it can, until
 735         // the original thread completes the class loading or fails
 736         // If it completes we will use the resulting InstanceKlass
 737         // which we will find below in the systemDictionary.
 738         // We also get here for parallel bootstrap classloader
 739         if (class_loader.is_null()) {
 740           SystemDictionary_lock-&gt;wait();
 741         } else {
 742           double_lock_wait(lockObject, THREAD);
 743         }
 744       } else {
 745         // If not in SD and not in PH, other thread&#39;s load must have failed
 746         super_load_in_progress = false;
 747       }
 748     }
 749   }
 750   return NULL;
 751 }
 752 
<span class="line-modified"> 753 void SystemDictionary::post_class_load_event(EventClassLoad* event, const InstanceKlass* k, const ClassLoaderData* init_cld) {</span>
 754   assert(event != NULL, &quot;invariant&quot;);
 755   assert(k != NULL, &quot;invariant&quot;);
 756   assert(event-&gt;should_commit(), &quot;invariant&quot;);
 757   event-&gt;set_loadedClass(k);
 758   event-&gt;set_definingClassLoader(k-&gt;class_loader_data());
 759   event-&gt;set_initiatingClassLoader(init_cld);
 760   event-&gt;commit();
 761 }
 762 
 763 
 764 // Be careful when modifying this code: once you have run
 765 // placeholders()-&gt;find_and_add(PlaceholderTable::LOAD_INSTANCE),
 766 // you need to find_and_remove it before returning.
 767 // So be careful to not exit with a CHECK_ macro betweeen these calls.
 768 //
 769 // name must be in the form of &quot;java/lang/Object&quot; -- cannot be &quot;Ljava/lang/Object;&quot;
 770 InstanceKlass* SystemDictionary::resolve_instance_class_or_null(Symbol* name,
 771                                                                 Handle class_loader,
 772                                                                 Handle protection_domain,
 773                                                                 TRAPS) {
</pre>
<hr />
<pre>
1399   // If unexpected superclass or interfaces are found, we cannot
1400   // load &lt;ik&gt; from the shared archive.
1401 
1402   if (ik-&gt;super() != NULL &amp;&amp;
1403       !check_shared_class_super_type(ik, InstanceKlass::cast(ik-&gt;super()),
1404                                      class_loader, protection_domain, true, THREAD)) {
1405     return false;
1406   }
1407 
1408   Array&lt;InstanceKlass*&gt;* interfaces = ik-&gt;local_interfaces();
1409   int num_interfaces = interfaces-&gt;length();
1410   for (int index = 0; index &lt; num_interfaces; index++) {
1411     if (!check_shared_class_super_type(ik, interfaces-&gt;at(index), class_loader, protection_domain, false, THREAD)) {
1412       return false;
1413     }
1414   }
1415 
1416   return true;
1417 }
1418 
<span class="line-added">1419 InstanceKlass* SystemDictionary::load_shared_lambda_proxy_class(InstanceKlass* ik,</span>
<span class="line-added">1420                                                                 Handle class_loader,</span>
<span class="line-added">1421                                                                 Handle protection_domain,</span>
<span class="line-added">1422                                                                 PackageEntry* pkg_entry,</span>
<span class="line-added">1423                                                                 TRAPS) {</span>
<span class="line-added">1424   InstanceKlass* shared_nest_host = SystemDictionaryShared::get_shared_nest_host(ik);</span>
<span class="line-added">1425   assert(shared_nest_host-&gt;is_shared(), &quot;nest host must be in CDS archive&quot;);</span>
<span class="line-added">1426   Symbol* cn = shared_nest_host-&gt;name();</span>
<span class="line-added">1427   Klass *s = resolve_or_fail(cn, class_loader, protection_domain, true, CHECK_NULL);</span>
<span class="line-added">1428   if (s != shared_nest_host) {</span>
<span class="line-added">1429     // The dynamically resolved nest_host is not the same as the one we used during dump time,</span>
<span class="line-added">1430     // so we cannot use ik.</span>
<span class="line-added">1431     return NULL;</span>
<span class="line-added">1432   } else {</span>
<span class="line-added">1433     assert(s-&gt;is_shared(), &quot;must be&quot;);</span>
<span class="line-added">1434   }</span>
<span class="line-added">1435 </span>
<span class="line-added">1436   // The lambda proxy class and its nest host have the same class loader and class loader data,</span>
<span class="line-added">1437   // as verified in SystemDictionaryShared::add_lambda_proxy_class()</span>
<span class="line-added">1438   assert(shared_nest_host-&gt;class_loader() == class_loader(), &quot;mismatched class loader&quot;);</span>
<span class="line-added">1439   assert(shared_nest_host-&gt;class_loader_data() == ClassLoaderData::class_loader_data(class_loader()), &quot;mismatched class loader data&quot;);</span>
<span class="line-added">1440   ik-&gt;set_nest_host(shared_nest_host, THREAD);</span>
<span class="line-added">1441 </span>
<span class="line-added">1442   InstanceKlass* loaded_ik = load_shared_class(ik, class_loader, protection_domain, NULL, pkg_entry, CHECK_NULL);</span>
<span class="line-added">1443 </span>
<span class="line-added">1444   assert(shared_nest_host-&gt;is_same_class_package(ik),</span>
<span class="line-added">1445          &quot;lambda proxy class and its nest host must be in the same package&quot;);</span>
<span class="line-added">1446 </span>
<span class="line-added">1447   return loaded_ik;</span>
<span class="line-added">1448 }</span>
<span class="line-added">1449 </span>
1450 InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,
1451                                                    Handle class_loader,
1452                                                    Handle protection_domain,
1453                                                    const ClassFileStream *cfs,
1454                                                    PackageEntry* pkg_entry,
1455                                                    TRAPS) {
1456   assert(ik != NULL, &quot;sanity&quot;);
1457   assert(!ik-&gt;is_unshareable_info_restored(), &quot;shared class can be loaded only once&quot;);
1458   Symbol* class_name = ik-&gt;name();
1459 
1460   bool visible = is_shared_class_visible(
1461                           class_name, ik, pkg_entry, class_loader, CHECK_NULL);
1462   if (!visible) {
1463     return NULL;
1464   }
1465 
1466   if (!check_shared_class_super_types(ik, class_loader, protection_domain, THREAD)) {
1467     return NULL;
1468   }
1469 
<span class="line-modified">1470   InstanceKlass* new_ik = NULL;</span>
<span class="line-added">1471   // CFLH check is skipped for VM hidden or anonymous classes (see KlassFactory::create_from_stream).</span>
<span class="line-added">1472   // It will be skipped for shared VM hidden lambda proxy classes.</span>
<span class="line-added">1473   if (!SystemDictionaryShared::is_hidden_lambda_proxy(ik)) {</span>
<span class="line-added">1474     new_ik = KlassFactory::check_shared_class_file_load_hook(</span>
1475       ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);
<span class="line-added">1476   }</span>
1477   if (new_ik != NULL) {
1478     // The class is changed by CFLH. Return the new class. The shared class is
1479     // not used.
1480     return new_ik;
1481   }
1482 
1483   // Adjust methods to recover missing data.  They need addresses for
1484   // interpreter entry points and their default native method address
1485   // must be reset.
1486 
1487   // Updating methods must be done under a lock so multiple
1488   // threads don&#39;t update these in parallel
1489   //
1490   // Shared classes are all currently loaded by either the bootstrap or
1491   // internal parallel class loaders, so this will never cause a deadlock
1492   // on a custom class loader lock.
1493 
1494   ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());
1495   {
1496     HandleMark hm(THREAD);
</pre>
<hr />
<pre>
1890       } else {
1891         probe-&gt;set_instance_klass(k);
1892       }
1893       probe-&gt;set_definer(NULL);
1894       placeholders()-&gt;find_and_remove(p_index, p_hash, name_h, loader_data, PlaceholderTable::DEFINE_CLASS, THREAD);
1895       SystemDictionary_lock-&gt;notify_all();
1896     }
1897   }
1898 
1899   // Can&#39;t throw exception while holding lock due to rank ordering
1900   if (linkage_exception() != NULL) {
1901     THROW_OOP_(linkage_exception(), NULL); // throws exception and returns
1902   }
1903 
1904   return k;
1905 }
1906 
1907 Handle SystemDictionary::compute_loader_lock_object(Handle class_loader, TRAPS) {
1908   // If class_loader is NULL we synchronize on _system_loader_lock_obj
1909   if (class_loader.is_null()) {
<span class="line-modified">1910     return Handle(THREAD, _system_loader_lock_obj.resolve());</span>
1911   } else {
1912     return class_loader;
1913   }
1914 }
1915 
1916 // This method is added to check how often we have to wait to grab loader
1917 // lock. The results are being recorded in the performance counters defined in
1918 // ClassLoader::_sync_systemLoaderLockContentionRate and
1919 // ClassLoader::_sync_nonSystemLoaderLockConteionRate.
1920 void SystemDictionary::check_loader_lock_contention(Handle loader_lock, TRAPS) {
1921   if (!UsePerfData) {
1922     return;
1923   }
1924 
1925   assert(!loader_lock.is_null(), &quot;NULL lock object&quot;);
1926 
1927   if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader_lock)
1928       == ObjectSynchronizer::owner_other) {
1929     // contention will likely happen, so increment the corresponding
1930     // contention counter.
<span class="line-modified">1931     if (loader_lock() == _system_loader_lock_obj.resolve()) {</span>
1932       ClassLoader::sync_systemLoaderLockContentionRate()-&gt;inc();
1933     } else {
1934       ClassLoader::sync_nonSystemLoaderLockContentionRate()-&gt;inc();
1935     }
1936   }
1937 }
1938 
1939 // ----------------------------------------------------------------------------
1940 // Lookup
1941 
1942 InstanceKlass* SystemDictionary::find_class(unsigned int hash,
1943                                             Symbol* class_name,
1944                                             Dictionary* dictionary) {
1945   assert_locked_or_safepoint(SystemDictionary_lock);
1946   int index = dictionary-&gt;hash_to_index(hash);
1947   return dictionary-&gt;find_class(index, hash, class_name);
1948 }
1949 
1950 
1951 // Basic find on classes in the midst of being loaded
</pre>
<hr />
<pre>
2028       resolution_errors()-&gt;purge_resolution_errors();
2029     }
2030   }
2031 
2032   GCTraceTime(Debug, gc, phases) t(&quot;Trigger cleanups&quot;, gc_timer);
2033 
2034   if (unloading_occurred) {
2035     SymbolTable::trigger_cleanup();
2036 
2037     // Oops referenced by the protection domain cache table may get unreachable independently
2038     // of the class loader (eg. cached protection domain oops). So we need to
2039     // explicitly unlink them here.
2040     // All protection domain oops are linked to the caller class, so if nothing
2041     // unloads, this is not needed.
2042     _pd_cache_table-&gt;trigger_cleanup();
2043   }
2044 
2045   return unloading_occurred;
2046 }
2047 














2048 // CDS: scan and relocate all classes referenced by _well_known_klasses[].
2049 void SystemDictionary::well_known_klasses_do(MetaspaceClosure* it) {
2050   for (int id = FIRST_WKID; id &lt; WKID_LIMIT; id++) {
2051     it-&gt;push(well_known_klass_addr((WKID)id));
2052   }
2053 }
2054 
2055 void SystemDictionary::methods_do(void f(Method*)) {
2056   // Walk methods in loaded classes
2057   MutexLocker ml(ClassLoaderDataGraph_lock);
2058   ClassLoaderDataGraph::methods_do(f);
2059   // Walk method handle intrinsics
2060   invoke_method_table()-&gt;methods_do(f);
2061 }
2062 
2063 // ----------------------------------------------------------------------------
2064 // Initialization
2065 
2066 void SystemDictionary::initialize(TRAPS) {
2067   // Allocate arrays
2068   _placeholders        = new PlaceholderTable(_placeholder_table_size);
2069   _loader_constraints  = new LoaderConstraintTable(_loader_constraint_size);
2070   _resolution_errors   = new ResolutionErrorTable(_resolution_error_size);
2071   _invoke_method_table = new SymbolPropertyTable(_invoke_method_size);
2072   _pd_cache_table = new ProtectionDomainCacheTable(defaultProtectionDomainCacheSize);
2073 
2074   // Allocate private object used as system class loader lock
<span class="line-modified">2075   oop lock_obj = oopFactory::new_intArray(0, CHECK);</span>
<span class="line-added">2076   _system_loader_lock_obj = OopHandle::create(lock_obj);</span>
<span class="line-added">2077 </span>
2078   // Initialize basic classes
2079   resolve_well_known_classes(CHECK);
2080 }
2081 
2082 // Compact table of directions on the initialization of klasses:
2083 static const short wk_init_info[] = {
2084   #define WK_KLASS_INIT_INFO(name, symbol) \
2085     ((short)vmSymbols::VM_SYMBOL_ENUM_NAME(symbol)),
2086 
2087   WK_KLASSES_DO(WK_KLASS_INIT_INFO)
2088   #undef WK_KLASS_INIT_INFO
2089   0
2090 };
2091 
2092 #ifdef ASSERT
2093 bool SystemDictionary::is_well_known_klass(Symbol* class_name) {
2094   int sid;
2095   for (int i = 0; (sid = wk_init_info[i]) != 0; i++) {
2096     Symbol* symbol = vmSymbols::symbol_at((vmSymbols::SID)sid);
2097     if (class_name == symbol) {
</pre>
</td>
</tr>
</table>
<center><a href="javaClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="systemDictionary.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/thread.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="thread.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmOperations.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/thread.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2022 
2023  private:
2024   // Saved incoming arguments to popped frame.
2025   // Used only when popped interpreted frame returns to deoptimized frame.
2026   void*    _popframe_preserved_args;
2027   int      _popframe_preserved_args_size;
2028 
2029  public:
2030   void  popframe_preserve_args(ByteSize size_in_bytes, void* start);
2031   void* popframe_preserved_args();
2032   ByteSize popframe_preserved_args_size();
2033   WordSize popframe_preserved_args_size_in_words();
2034   void  popframe_free_preserved_args();
2035 
2036 
2037  private:
2038   JvmtiThreadState *_jvmti_thread_state;
2039 
2040   // Used by the interpreter in fullspeed mode for frame pop, method
2041   // entry, method exit and single stepping support. This field is
<span class="line-modified">2042   // only set to non-zero by the VM_EnterInterpOnlyMode VM operation.</span>
<span class="line-modified">2043   // It can be set to zero asynchronously (i.e., without a VM operation</span>
<span class="line-modified">2044   // or a lock) so we have to be very careful.</span>


2045   int               _interp_only_mode;
2046 
2047  public:
2048   // used by the interpreter for fullspeed debugging support (see above)
2049   static ByteSize interp_only_mode_offset() { return byte_offset_of(JavaThread, _interp_only_mode); }
2050   bool is_interp_only_mode()                { return (_interp_only_mode != 0); }
2051   int get_interp_only_mode()                { return _interp_only_mode; }
2052   void increment_interp_only_mode()         { ++_interp_only_mode; }
2053   void decrement_interp_only_mode()         { --_interp_only_mode; }
2054 
2055   // support for cached flag that indicates whether exceptions need to be posted for this thread
2056   // if this is false, we can avoid deoptimizing when events are thrown
2057   // this gets set to reflect whether jvmtiExport::post_exception_throw would actually do anything
2058  private:
2059   int    _should_post_on_exceptions_flag;
2060 
2061  public:
2062   int   should_post_on_exceptions_flag()  { return _should_post_on_exceptions_flag; }
2063   void  set_should_post_on_exceptions_flag(int val)  { _should_post_on_exceptions_flag = val; }
2064 
</pre>
</td>
<td>
<hr />
<pre>
2022 
2023  private:
2024   // Saved incoming arguments to popped frame.
2025   // Used only when popped interpreted frame returns to deoptimized frame.
2026   void*    _popframe_preserved_args;
2027   int      _popframe_preserved_args_size;
2028 
2029  public:
2030   void  popframe_preserve_args(ByteSize size_in_bytes, void* start);
2031   void* popframe_preserved_args();
2032   ByteSize popframe_preserved_args_size();
2033   WordSize popframe_preserved_args_size_in_words();
2034   void  popframe_free_preserved_args();
2035 
2036 
2037  private:
2038   JvmtiThreadState *_jvmti_thread_state;
2039 
2040   // Used by the interpreter in fullspeed mode for frame pop, method
2041   // entry, method exit and single stepping support. This field is
<span class="line-modified">2042   // only set to non-zero at a safepoint or using a direct handshake</span>
<span class="line-modified">2043   // (see EnterInterpOnlyModeClosure).</span>
<span class="line-modified">2044   // It can be set to zero asynchronously to this threads execution (i.e., without</span>
<span class="line-added">2045   // safepoint/handshake or a lock) so we have to be very careful.</span>
<span class="line-added">2046   // Accesses by other threads are synchronized using JvmtiThreadState_lock though.</span>
2047   int               _interp_only_mode;
2048 
2049  public:
2050   // used by the interpreter for fullspeed debugging support (see above)
2051   static ByteSize interp_only_mode_offset() { return byte_offset_of(JavaThread, _interp_only_mode); }
2052   bool is_interp_only_mode()                { return (_interp_only_mode != 0); }
2053   int get_interp_only_mode()                { return _interp_only_mode; }
2054   void increment_interp_only_mode()         { ++_interp_only_mode; }
2055   void decrement_interp_only_mode()         { --_interp_only_mode; }
2056 
2057   // support for cached flag that indicates whether exceptions need to be posted for this thread
2058   // if this is false, we can avoid deoptimizing when events are thrown
2059   // this gets set to reflect whether jvmtiExport::post_exception_throw would actually do anything
2060  private:
2061   int    _should_post_on_exceptions_flag;
2062 
2063  public:
2064   int   should_post_on_exceptions_flag()  { return _should_post_on_exceptions_flag; }
2065   void  set_should_post_on_exceptions_flag(int val)  { _should_post_on_exceptions_flag = val; }
2066 
</pre>
</td>
</tr>
</table>
<center><a href="thread.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="vmOperations.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/deoptimization.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../prims/jvmtiRedefineClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="fieldDescriptor.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/deoptimization.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 672   HandleMark hm;
 673 
 674   frame stub_frame = thread-&gt;last_frame();
 675 
 676   // Since the frame to unpack is the top frame of this thread, the vframe_array_head
 677   // must point to the vframeArray for the unpack frame.
 678   vframeArray* array = thread-&gt;vframe_array_head();
 679 
 680 #ifndef PRODUCT
 681   if (TraceDeoptimization) {
 682     ttyLocker ttyl;
 683     tty-&gt;print_cr(&quot;DEOPT UNPACKING thread &quot; INTPTR_FORMAT &quot; vframeArray &quot; INTPTR_FORMAT &quot; mode %d&quot;,
 684                   p2i(thread), p2i(array), exec_mode);
 685   }
 686 #endif
 687   Events::log_deopt_message(thread, &quot;DEOPT UNPACKING pc=&quot; INTPTR_FORMAT &quot; sp=&quot; INTPTR_FORMAT &quot; mode %d&quot;,
 688               p2i(stub_frame.pc()), p2i(stub_frame.sp()), exec_mode);
 689 
 690   UnrollBlock* info = array-&gt;unroll_block();
 691 






 692   // Unpack the interpreter frames and any adapter frame (c2 only) we might create.
 693   array-&gt;unpack_to_stack(stub_frame, exec_mode, info-&gt;caller_actual_parameters());
 694 


 695   BasicType bt = info-&gt;return_type();
 696 
 697   // If we have an exception pending, claim that the return type is an oop
 698   // so the deopt_blob does not overwrite the exception_oop.
 699 
 700   if (exec_mode == Unpack_exception)
 701     bt = T_OBJECT;
 702 
 703   // Cleanup thread deopt data
 704   cleanup_deopt_info(thread, array);
 705 
 706 #ifndef PRODUCT
 707   if (VerifyStack) {
 708     ResourceMark res_mark;
 709     // Clear pending exception to not break verification code (restored afterwards)
 710     PRESERVE_EXCEPTION_MARK;
 711 
 712     thread-&gt;validate_frame_layout();
 713 
 714     // Verify that the just-unpacked frames match the interpreter&#39;s
</pre>
<hr />
<pre>
 810           tty-&gt;print_cr(&quot;  cur_invoke_parameter_size = %d&quot;, cur_invoke_parameter_size);
 811           tty-&gt;print_cr(&quot;  Thread = &quot; INTPTR_FORMAT &quot;, thread ID = %d&quot;, p2i(thread), thread-&gt;osthread()-&gt;thread_id());
 812           tty-&gt;print_cr(&quot;  Interpreted frames:&quot;);
 813           for (int k = 0; k &lt; cur_array-&gt;frames(); k++) {
 814             vframeArrayElement* el = cur_array-&gt;element(k);
 815             tty-&gt;print_cr(&quot;    %s (bci %d)&quot;, el-&gt;method()-&gt;name_and_sig_as_C_string(), el-&gt;bci());
 816           }
 817           cur_array-&gt;print_on_2(tty);
 818         } // release tty lock before calling guarantee
 819         guarantee(false, &quot;wrong number of expression stack elements during deopt&quot;);
 820       }
 821       VerifyOopClosure verify;
 822       iframe-&gt;oops_interpreted_do(&amp;verify, &amp;rm, false);
 823       callee_size_of_parameters = mh-&gt;size_of_parameters();
 824       callee_max_locals = mh-&gt;max_locals();
 825       is_top_frame = false;
 826     }
 827   }
 828 #endif /* !PRODUCT */
 829 
<span class="line-removed"> 830 </span>
 831   return bt;
 832 JRT_END
 833 
 834 class DeoptimizeMarkedClosure : public HandshakeClosure {
 835  public:
 836   DeoptimizeMarkedClosure() : HandshakeClosure(&quot;Deoptimize&quot;) {}
 837   void do_thread(Thread* thread) {
 838     JavaThread* jt = (JavaThread*)thread;
 839     jt-&gt;deoptimize_marked_methods();
 840   }
 841 };
 842 
 843 void Deoptimization::deoptimize_all_marked(nmethod* nmethod_only) {
 844   ResourceMark rm;
 845   DeoptimizationMarker dm;
 846 
 847   // Make the dependent methods not entrant
 848   if (nmethod_only != NULL) {
 849     nmethod_only-&gt;mark_for_deoptimization();
 850     nmethod_only-&gt;make_not_entrant();
</pre>
</td>
<td>
<hr />
<pre>
 672   HandleMark hm;
 673 
 674   frame stub_frame = thread-&gt;last_frame();
 675 
 676   // Since the frame to unpack is the top frame of this thread, the vframe_array_head
 677   // must point to the vframeArray for the unpack frame.
 678   vframeArray* array = thread-&gt;vframe_array_head();
 679 
 680 #ifndef PRODUCT
 681   if (TraceDeoptimization) {
 682     ttyLocker ttyl;
 683     tty-&gt;print_cr(&quot;DEOPT UNPACKING thread &quot; INTPTR_FORMAT &quot; vframeArray &quot; INTPTR_FORMAT &quot; mode %d&quot;,
 684                   p2i(thread), p2i(array), exec_mode);
 685   }
 686 #endif
 687   Events::log_deopt_message(thread, &quot;DEOPT UNPACKING pc=&quot; INTPTR_FORMAT &quot; sp=&quot; INTPTR_FORMAT &quot; mode %d&quot;,
 688               p2i(stub_frame.pc()), p2i(stub_frame.sp()), exec_mode);
 689 
 690   UnrollBlock* info = array-&gt;unroll_block();
 691 
<span class="line-added"> 692   // We set the last_Java frame. But the stack isn&#39;t really parsable here. So we</span>
<span class="line-added"> 693   // clear it to make sure JFR understands not to try and walk stacks from events</span>
<span class="line-added"> 694   // in here.</span>
<span class="line-added"> 695   intptr_t* sp = thread-&gt;frame_anchor()-&gt;last_Java_sp();</span>
<span class="line-added"> 696   thread-&gt;frame_anchor()-&gt;set_last_Java_sp(NULL);</span>
<span class="line-added"> 697 </span>
 698   // Unpack the interpreter frames and any adapter frame (c2 only) we might create.
 699   array-&gt;unpack_to_stack(stub_frame, exec_mode, info-&gt;caller_actual_parameters());
 700 
<span class="line-added"> 701   thread-&gt;frame_anchor()-&gt;set_last_Java_sp(sp);</span>
<span class="line-added"> 702 </span>
 703   BasicType bt = info-&gt;return_type();
 704 
 705   // If we have an exception pending, claim that the return type is an oop
 706   // so the deopt_blob does not overwrite the exception_oop.
 707 
 708   if (exec_mode == Unpack_exception)
 709     bt = T_OBJECT;
 710 
 711   // Cleanup thread deopt data
 712   cleanup_deopt_info(thread, array);
 713 
 714 #ifndef PRODUCT
 715   if (VerifyStack) {
 716     ResourceMark res_mark;
 717     // Clear pending exception to not break verification code (restored afterwards)
 718     PRESERVE_EXCEPTION_MARK;
 719 
 720     thread-&gt;validate_frame_layout();
 721 
 722     // Verify that the just-unpacked frames match the interpreter&#39;s
</pre>
<hr />
<pre>
 818           tty-&gt;print_cr(&quot;  cur_invoke_parameter_size = %d&quot;, cur_invoke_parameter_size);
 819           tty-&gt;print_cr(&quot;  Thread = &quot; INTPTR_FORMAT &quot;, thread ID = %d&quot;, p2i(thread), thread-&gt;osthread()-&gt;thread_id());
 820           tty-&gt;print_cr(&quot;  Interpreted frames:&quot;);
 821           for (int k = 0; k &lt; cur_array-&gt;frames(); k++) {
 822             vframeArrayElement* el = cur_array-&gt;element(k);
 823             tty-&gt;print_cr(&quot;    %s (bci %d)&quot;, el-&gt;method()-&gt;name_and_sig_as_C_string(), el-&gt;bci());
 824           }
 825           cur_array-&gt;print_on_2(tty);
 826         } // release tty lock before calling guarantee
 827         guarantee(false, &quot;wrong number of expression stack elements during deopt&quot;);
 828       }
 829       VerifyOopClosure verify;
 830       iframe-&gt;oops_interpreted_do(&amp;verify, &amp;rm, false);
 831       callee_size_of_parameters = mh-&gt;size_of_parameters();
 832       callee_max_locals = mh-&gt;max_locals();
 833       is_top_frame = false;
 834     }
 835   }
 836 #endif /* !PRODUCT */
 837 

 838   return bt;
 839 JRT_END
 840 
 841 class DeoptimizeMarkedClosure : public HandshakeClosure {
 842  public:
 843   DeoptimizeMarkedClosure() : HandshakeClosure(&quot;Deoptimize&quot;) {}
 844   void do_thread(Thread* thread) {
 845     JavaThread* jt = (JavaThread*)thread;
 846     jt-&gt;deoptimize_marked_methods();
 847   }
 848 };
 849 
 850 void Deoptimization::deoptimize_all_marked(nmethod* nmethod_only) {
 851   ResourceMark rm;
 852   DeoptimizationMarker dm;
 853 
 854   // Make the dependent methods not entrant
 855   if (nmethod_only != NULL) {
 856     nmethod_only-&gt;mark_for_deoptimization();
 857     nmethod_only-&gt;make_not_entrant();
</pre>
</td>
</tr>
</table>
<center><a href="../prims/jvmtiRedefineClasses.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="fieldDescriptor.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
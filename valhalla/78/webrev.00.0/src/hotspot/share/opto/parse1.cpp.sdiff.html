<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/parse1.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="library_call.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../prims/jvm.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/parse1.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1350   assert(flow()-&gt;is_start() == (this == outer-&gt;start_block()), &quot;&quot;);
1351 }
1352 
1353 //-------------------------------init_graph------------------------------------
1354 void Parse::Block::init_graph(Parse* outer) {
1355   // Create the successor list for this parser block.
1356   GrowableArray&lt;ciTypeFlow::Block*&gt;* tfs = flow()-&gt;successors();
1357   GrowableArray&lt;ciTypeFlow::Block*&gt;* tfe = flow()-&gt;exceptions();
1358   int ns = tfs-&gt;length();
1359   int ne = tfe-&gt;length();
1360   _num_successors = ns;
1361   _all_successors = ns+ne;
1362   _successors = (ns+ne == 0) ? NULL : NEW_RESOURCE_ARRAY(Block*, ns+ne);
1363   int p = 0;
1364   for (int i = 0; i &lt; ns+ne; i++) {
1365     ciTypeFlow::Block* tf2 = (i &lt; ns) ? tfs-&gt;at(i) : tfe-&gt;at(i-ns);
1366     Block* block2 = outer-&gt;rpo_at(tf2-&gt;rpo());
1367     _successors[i] = block2;
1368 
1369     // Accumulate pred info for the other block, too.
<span class="line-modified">1370     if (i &lt; ns) {</span>
<span class="line-modified">1371       block2-&gt;_pred_count++;</span>
<span class="line-modified">1372     } else {</span>


1373       block2-&gt;_is_handler = true;
1374     }
1375 
1376     #ifdef ASSERT
1377     // A block&#39;s successors must be distinguishable by BCI.
1378     // That is, no bytecode is allowed to branch to two different
1379     // clones of the same code location.
1380     for (int j = 0; j &lt; i; j++) {
1381       Block* block1 = _successors[j];
1382       if (block1 == block2)  continue;  // duplicates are OK
1383       assert(block1-&gt;start() != block2-&gt;start(), &quot;successors have unique bcis&quot;);
1384     }
1385     #endif
1386   }
<span class="line-removed">1387 </span>
<span class="line-removed">1388   // Note: We never call next_path_num along exception paths, so they</span>
<span class="line-removed">1389   // never get processed as &quot;ready&quot;.  Also, the input phis of exception</span>
<span class="line-removed">1390   // handlers get specially processed, so that</span>
1391 }
1392 
1393 //---------------------------successor_for_bci---------------------------------
1394 Parse::Block* Parse::Block::successor_for_bci(int bci) {
1395   for (int i = 0; i &lt; all_successors(); i++) {
1396     Block* block2 = successor_at(i);
1397     if (block2-&gt;start() == bci)  return block2;
1398   }
1399   // We can actually reach here if ciTypeFlow traps out a block
1400   // due to an unloaded class, and concurrently with compilation the
1401   // class is then loaded, so that a later phase of the parser is
1402   // able to see more of the bytecode CFG.  Or, the flow pass and
1403   // the parser can have a minor difference of opinion about executability
1404   // of bytecodes.  For example, &quot;obj.field = null&quot; is executable even
1405   // if the field&#39;s type is an unloaded class; the flow pass used to
1406   // make a trap for such code.
1407   return NULL;
1408 }
1409 
1410 
</pre>
</td>
<td>
<hr />
<pre>
1350   assert(flow()-&gt;is_start() == (this == outer-&gt;start_block()), &quot;&quot;);
1351 }
1352 
1353 //-------------------------------init_graph------------------------------------
1354 void Parse::Block::init_graph(Parse* outer) {
1355   // Create the successor list for this parser block.
1356   GrowableArray&lt;ciTypeFlow::Block*&gt;* tfs = flow()-&gt;successors();
1357   GrowableArray&lt;ciTypeFlow::Block*&gt;* tfe = flow()-&gt;exceptions();
1358   int ns = tfs-&gt;length();
1359   int ne = tfe-&gt;length();
1360   _num_successors = ns;
1361   _all_successors = ns+ne;
1362   _successors = (ns+ne == 0) ? NULL : NEW_RESOURCE_ARRAY(Block*, ns+ne);
1363   int p = 0;
1364   for (int i = 0; i &lt; ns+ne; i++) {
1365     ciTypeFlow::Block* tf2 = (i &lt; ns) ? tfs-&gt;at(i) : tfe-&gt;at(i-ns);
1366     Block* block2 = outer-&gt;rpo_at(tf2-&gt;rpo());
1367     _successors[i] = block2;
1368 
1369     // Accumulate pred info for the other block, too.
<span class="line-modified">1370     // Note: We also need to set _pred_count for exception blocks since they could</span>
<span class="line-modified">1371     // also have normal predecessors (reached without athrow by an explicit jump).</span>
<span class="line-modified">1372     // This also means that next_path_num can be called along exception paths.</span>
<span class="line-added">1373     block2-&gt;_pred_count++;</span>
<span class="line-added">1374     if (i &gt;= ns) {</span>
1375       block2-&gt;_is_handler = true;
1376     }
1377 
1378     #ifdef ASSERT
1379     // A block&#39;s successors must be distinguishable by BCI.
1380     // That is, no bytecode is allowed to branch to two different
1381     // clones of the same code location.
1382     for (int j = 0; j &lt; i; j++) {
1383       Block* block1 = _successors[j];
1384       if (block1 == block2)  continue;  // duplicates are OK
1385       assert(block1-&gt;start() != block2-&gt;start(), &quot;successors have unique bcis&quot;);
1386     }
1387     #endif
1388   }




1389 }
1390 
1391 //---------------------------successor_for_bci---------------------------------
1392 Parse::Block* Parse::Block::successor_for_bci(int bci) {
1393   for (int i = 0; i &lt; all_successors(); i++) {
1394     Block* block2 = successor_at(i);
1395     if (block2-&gt;start() == bci)  return block2;
1396   }
1397   // We can actually reach here if ciTypeFlow traps out a block
1398   // due to an unloaded class, and concurrently with compilation the
1399   // class is then loaded, so that a later phase of the parser is
1400   // able to see more of the bytecode CFG.  Or, the flow pass and
1401   // the parser can have a minor difference of opinion about executability
1402   // of bytecodes.  For example, &quot;obj.field = null&quot; is executable even
1403   // if the field&#39;s type is an unloaded class; the flow pass used to
1404   // make a trap for such code.
1405   return NULL;
1406 }
1407 
1408 
</pre>
</td>
</tr>
</table>
<center><a href="library_call.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../prims/jvm.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/oops/klass.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="klass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/arraycopynode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/oops/klass.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
160 
161   JFR_ONLY(DEFINE_TRACE_ID_FIELD;)
162 
163   // Biased locking implementation and statistics
164   // (the 64-bit chunk goes first, to avoid some fragmentation)
165   jlong    _last_biased_lock_bulk_revocation_time;
166   markWord _prototype_header;   // Used when biased locking is both enabled and disabled for this type
167   jint     _biased_lock_revocation_count;
168 
169 private:
170   // This is an index into FileMapHeader::_shared_path_table[], to
171   // associate this class with the JAR file where it&#39;s loaded from during
172   // dump time. If a class is not loaded from the shared archive, this field is
173   // -1.
174   jshort _shared_class_path_index;
175 
176 #if INCLUDE_CDS
177   // Flags of the current shared class.
178   u2     _shared_class_flags;
179   enum {
<span class="line-modified">180     _has_raw_archived_mirror = 1</span>

181   };
182 #endif
183 
184   // The _archived_mirror is set at CDS dump time pointing to the cached mirror
185   // in the open archive heap region when archiving java object is supported.
186   CDS_JAVA_HEAP_ONLY(narrowOop _archived_mirror;)
187 
188 protected:
189 
190   // Constructor
191   Klass(KlassID id);
192   Klass() : _id(KlassID(-1)) { assert(DumpSharedSpaces || UseSharedSpaces, &quot;only for cds&quot;); }
193 
194   void* operator new(size_t size, ClassLoaderData* loader_data, size_t word_size, TRAPS) throw();
195 
196  public:
197   int id() { return _id; }
198 
199   enum DefaultsLookupMode { find_defaults, skip_defaults };
200   enum OverpassLookupMode { find_overpass, skip_overpass };
</pre>
<hr />
<pre>
277   // modifier flags
278   jint modifier_flags() const          { return _modifier_flags; }
279   void set_modifier_flags(jint flags)  { _modifier_flags = flags; }
280 
281   // size helper
282   int layout_helper() const            { return _layout_helper; }
283   void set_layout_helper(int lh)       { _layout_helper = lh; }
284 
285   // Note: for instances layout_helper() may include padding.
286   // Use InstanceKlass::contains_field_offset to classify field offsets.
287 
288   // sub/superklass links
289   Klass* subklass(bool log = false) const;
290   Klass* next_sibling(bool log = false) const;
291 
292   InstanceKlass* superklass() const;
293   void append_to_sibling_list();           // add newly created receiver to superklass&#39; subklass list
294 
295   void set_next_link(Klass* k) { _next_link = k; }
296   Klass* next_link() const { return _next_link; }   // The next klass defined by the class loader.

297 
298   // class loader data
299   ClassLoaderData* class_loader_data() const               { return _class_loader_data; }
300   void set_class_loader_data(ClassLoaderData* loader_data) {  _class_loader_data = loader_data; }
301 
302   int shared_classpath_index() const   {
303     return _shared_class_path_index;
304   };
305 
306   void set_shared_classpath_index(int index) {
307     _shared_class_path_index = index;
308   };
309 
310   void set_has_raw_archived_mirror() {
311     CDS_ONLY(_shared_class_flags |= _has_raw_archived_mirror;)
312   }
313   void clear_has_raw_archived_mirror() {
314     CDS_ONLY(_shared_class_flags &amp;= ~_has_raw_archived_mirror;)
315   }
316   bool has_raw_archived_mirror() const {
317     CDS_ONLY(return (_shared_class_flags &amp; _has_raw_archived_mirror) != 0;)
318     NOT_CDS(return false;)
319   }
320 











321   // Obtain the module or package for this class
322   virtual ModuleEntry* module() const = 0;
323   virtual PackageEntry* package() const = 0;
324 
325  protected:                                // internal accessors
326   void     set_subklass(Klass* s);
327   void     set_next_sibling(Klass* s);
328 
329  public:
330 
331   // Compiler support
332   static ByteSize super_offset()                 { return in_ByteSize(offset_of(Klass, _super)); }
333   static ByteSize super_check_offset_offset()    { return in_ByteSize(offset_of(Klass, _super_check_offset)); }
334   static ByteSize primary_supers_offset()        { return in_ByteSize(offset_of(Klass, _primary_supers)); }
335   static ByteSize secondary_super_cache_offset() { return in_ByteSize(offset_of(Klass, _secondary_super_cache)); }
336   static ByteSize secondary_supers_offset()      { return in_ByteSize(offset_of(Klass, _secondary_supers)); }
337   static ByteSize java_mirror_offset()           { return in_ByteSize(offset_of(Klass, _java_mirror)); }
338   static ByteSize class_loader_data_offset()     { return in_ByteSize(offset_of(Klass, _class_loader_data)); }
339   static ByteSize modifier_flags_offset()        { return in_ByteSize(offset_of(Klass, _modifier_flags)); }
340   static ByteSize layout_helper_offset()         { return in_ByteSize(offset_of(Klass, _layout_helper)); }
</pre>
</td>
<td>
<hr />
<pre>
160 
161   JFR_ONLY(DEFINE_TRACE_ID_FIELD;)
162 
163   // Biased locking implementation and statistics
164   // (the 64-bit chunk goes first, to avoid some fragmentation)
165   jlong    _last_biased_lock_bulk_revocation_time;
166   markWord _prototype_header;   // Used when biased locking is both enabled and disabled for this type
167   jint     _biased_lock_revocation_count;
168 
169 private:
170   // This is an index into FileMapHeader::_shared_path_table[], to
171   // associate this class with the JAR file where it&#39;s loaded from during
172   // dump time. If a class is not loaded from the shared archive, this field is
173   // -1.
174   jshort _shared_class_path_index;
175 
176 #if INCLUDE_CDS
177   // Flags of the current shared class.
178   u2     _shared_class_flags;
179   enum {
<span class="line-modified">180     _has_raw_archived_mirror = 1,</span>
<span class="line-added">181     _archived_lambda_proxy_is_available = 2</span>
182   };
183 #endif
184 
185   // The _archived_mirror is set at CDS dump time pointing to the cached mirror
186   // in the open archive heap region when archiving java object is supported.
187   CDS_JAVA_HEAP_ONLY(narrowOop _archived_mirror;)
188 
189 protected:
190 
191   // Constructor
192   Klass(KlassID id);
193   Klass() : _id(KlassID(-1)) { assert(DumpSharedSpaces || UseSharedSpaces, &quot;only for cds&quot;); }
194 
195   void* operator new(size_t size, ClassLoaderData* loader_data, size_t word_size, TRAPS) throw();
196 
197  public:
198   int id() { return _id; }
199 
200   enum DefaultsLookupMode { find_defaults, skip_defaults };
201   enum OverpassLookupMode { find_overpass, skip_overpass };
</pre>
<hr />
<pre>
278   // modifier flags
279   jint modifier_flags() const          { return _modifier_flags; }
280   void set_modifier_flags(jint flags)  { _modifier_flags = flags; }
281 
282   // size helper
283   int layout_helper() const            { return _layout_helper; }
284   void set_layout_helper(int lh)       { _layout_helper = lh; }
285 
286   // Note: for instances layout_helper() may include padding.
287   // Use InstanceKlass::contains_field_offset to classify field offsets.
288 
289   // sub/superklass links
290   Klass* subklass(bool log = false) const;
291   Klass* next_sibling(bool log = false) const;
292 
293   InstanceKlass* superklass() const;
294   void append_to_sibling_list();           // add newly created receiver to superklass&#39; subklass list
295 
296   void set_next_link(Klass* k) { _next_link = k; }
297   Klass* next_link() const { return _next_link; }   // The next klass defined by the class loader.
<span class="line-added">298   Klass** next_link_addr() { return &amp;_next_link; }</span>
299 
300   // class loader data
301   ClassLoaderData* class_loader_data() const               { return _class_loader_data; }
302   void set_class_loader_data(ClassLoaderData* loader_data) {  _class_loader_data = loader_data; }
303 
304   int shared_classpath_index() const   {
305     return _shared_class_path_index;
306   };
307 
308   void set_shared_classpath_index(int index) {
309     _shared_class_path_index = index;
310   };
311 
312   void set_has_raw_archived_mirror() {
313     CDS_ONLY(_shared_class_flags |= _has_raw_archived_mirror;)
314   }
315   void clear_has_raw_archived_mirror() {
316     CDS_ONLY(_shared_class_flags &amp;= ~_has_raw_archived_mirror;)
317   }
318   bool has_raw_archived_mirror() const {
319     CDS_ONLY(return (_shared_class_flags &amp; _has_raw_archived_mirror) != 0;)
320     NOT_CDS(return false;)
321   }
322 
<span class="line-added">323   void set_lambda_proxy_is_available() {</span>
<span class="line-added">324     CDS_ONLY(_shared_class_flags |= _archived_lambda_proxy_is_available;)</span>
<span class="line-added">325   }</span>
<span class="line-added">326   void clear_lambda_proxy_is_available() {</span>
<span class="line-added">327     CDS_ONLY(_shared_class_flags &amp;= ~_archived_lambda_proxy_is_available;)</span>
<span class="line-added">328   }</span>
<span class="line-added">329   bool lambda_proxy_is_available() const {</span>
<span class="line-added">330     CDS_ONLY(return (_shared_class_flags &amp; _archived_lambda_proxy_is_available) != 0;)</span>
<span class="line-added">331     NOT_CDS(return false;)</span>
<span class="line-added">332   }</span>
<span class="line-added">333 </span>
334   // Obtain the module or package for this class
335   virtual ModuleEntry* module() const = 0;
336   virtual PackageEntry* package() const = 0;
337 
338  protected:                                // internal accessors
339   void     set_subklass(Klass* s);
340   void     set_next_sibling(Klass* s);
341 
342  public:
343 
344   // Compiler support
345   static ByteSize super_offset()                 { return in_ByteSize(offset_of(Klass, _super)); }
346   static ByteSize super_check_offset_offset()    { return in_ByteSize(offset_of(Klass, _super_check_offset)); }
347   static ByteSize primary_supers_offset()        { return in_ByteSize(offset_of(Klass, _primary_supers)); }
348   static ByteSize secondary_super_cache_offset() { return in_ByteSize(offset_of(Klass, _secondary_super_cache)); }
349   static ByteSize secondary_supers_offset()      { return in_ByteSize(offset_of(Klass, _secondary_supers)); }
350   static ByteSize java_mirror_offset()           { return in_ByteSize(offset_of(Klass, _java_mirror)); }
351   static ByteSize class_loader_data_offset()     { return in_ByteSize(offset_of(Klass, _class_loader_data)); }
352   static ByteSize modifier_flags_offset()        { return in_ByteSize(offset_of(Klass, _modifier_flags)); }
353   static ByteSize layout_helper_offset()         { return in_ByteSize(offset_of(Klass, _layout_helper)); }
</pre>
</td>
</tr>
</table>
<center><a href="klass.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../opto/arraycopynode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/code/nmethod.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../classfile/systemDictionary.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../compiler/compileBroker.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/code/nmethod.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1123     }
1124   }
1125 }
1126 
1127 // This is a private interface with the sweeper.
1128 void nmethod::mark_as_seen_on_stack() {
1129   assert(is_alive(), &quot;Must be an alive method&quot;);
1130   // Set the traversal mark to ensure that the sweeper does 2
1131   // cleaning passes before moving to zombie.
1132   set_stack_traversal_mark(NMethodSweeper::traversal_count());
1133 }
1134 
1135 // Tell if a non-entrant method can be converted to a zombie (i.e.,
1136 // there are no activations on the stack, not in use by the VM,
1137 // and not in use by the ServiceThread)
1138 bool nmethod::can_convert_to_zombie() {
1139   // Note that this is called when the sweeper has observed the nmethod to be
1140   // not_entrant. However, with concurrent code cache unloading, the state
1141   // might have moved on to unloaded if it is_unloading(), due to racing
1142   // concurrent GC threads.
<span class="line-modified">1143   assert(is_not_entrant() || is_unloading(), &quot;must be a non-entrant method&quot;);</span>


1144 
1145   // Since the nmethod sweeper only does partial sweep the sweeper&#39;s traversal
1146   // count can be greater than the stack traversal count before it hits the
1147   // nmethod for the second time.
1148   // If an is_unloading() nmethod is still not_entrant, then it is not safe to
1149   // convert it to zombie due to GC unloading interactions. However, if it
1150   // has become unloaded, then it is okay to convert such nmethods to zombie.
1151   return stack_traversal_mark() + 1 &lt; NMethodSweeper::traversal_count() &amp;&amp;
1152          !is_locked_by_vm() &amp;&amp; (!is_unloading() || is_unloaded());
1153 }
1154 
1155 void nmethod::inc_decompile_count() {
1156   if (!is_compiled_by_c2() &amp;&amp; !is_compiled_by_jvmci()) return;
1157   // Could be gated by ProfileTraps, but do not bother...
1158   Method* m = method();
1159   if (m == NULL)  return;
1160   MethodData* mdo = m-&gt;method_data();
1161   if (mdo == NULL)  return;
1162   // There is a benign race here.  See comments in methodData.hpp.
1163   mdo-&gt;inc_decompile_count();
</pre>
</td>
<td>
<hr />
<pre>
1123     }
1124   }
1125 }
1126 
1127 // This is a private interface with the sweeper.
1128 void nmethod::mark_as_seen_on_stack() {
1129   assert(is_alive(), &quot;Must be an alive method&quot;);
1130   // Set the traversal mark to ensure that the sweeper does 2
1131   // cleaning passes before moving to zombie.
1132   set_stack_traversal_mark(NMethodSweeper::traversal_count());
1133 }
1134 
1135 // Tell if a non-entrant method can be converted to a zombie (i.e.,
1136 // there are no activations on the stack, not in use by the VM,
1137 // and not in use by the ServiceThread)
1138 bool nmethod::can_convert_to_zombie() {
1139   // Note that this is called when the sweeper has observed the nmethod to be
1140   // not_entrant. However, with concurrent code cache unloading, the state
1141   // might have moved on to unloaded if it is_unloading(), due to racing
1142   // concurrent GC threads.
<span class="line-modified">1143   assert(is_not_entrant() || is_unloading() ||</span>
<span class="line-added">1144          !Thread::current()-&gt;is_Code_cache_sweeper_thread(),</span>
<span class="line-added">1145          &quot;must be a non-entrant method if called from sweeper&quot;);</span>
1146 
1147   // Since the nmethod sweeper only does partial sweep the sweeper&#39;s traversal
1148   // count can be greater than the stack traversal count before it hits the
1149   // nmethod for the second time.
1150   // If an is_unloading() nmethod is still not_entrant, then it is not safe to
1151   // convert it to zombie due to GC unloading interactions. However, if it
1152   // has become unloaded, then it is okay to convert such nmethods to zombie.
1153   return stack_traversal_mark() + 1 &lt; NMethodSweeper::traversal_count() &amp;&amp;
1154          !is_locked_by_vm() &amp;&amp; (!is_unloading() || is_unloaded());
1155 }
1156 
1157 void nmethod::inc_decompile_count() {
1158   if (!is_compiled_by_c2() &amp;&amp; !is_compiled_by_jvmci()) return;
1159   // Could be gated by ProfileTraps, but do not bother...
1160   Method* m = method();
1161   if (m == NULL)  return;
1162   MethodData* mdo = m-&gt;method_data();
1163   if (mdo == NULL)  return;
1164   // There is a benign race here.  See comments in methodData.hpp.
1165   mdo-&gt;inc_decompile_count();
</pre>
</td>
</tr>
</table>
<center><a href="../classfile/systemDictionary.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../compiler/compileBroker.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
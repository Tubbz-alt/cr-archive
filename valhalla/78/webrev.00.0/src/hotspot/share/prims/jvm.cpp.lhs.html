<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/jvm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classFileStream.hpp&quot;
  28 #include &quot;classfile/classLoader.hpp&quot;
<a name="1" id="anc1"></a>
  29 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  30 #include &quot;classfile/javaAssertions.hpp&quot;
  31 #include &quot;classfile/javaClasses.inline.hpp&quot;
  32 #include &quot;classfile/moduleEntry.hpp&quot;
  33 #include &quot;classfile/modules.hpp&quot;
  34 #include &quot;classfile/packageEntry.hpp&quot;
  35 #include &quot;classfile/stringTable.hpp&quot;
  36 #include &quot;classfile/symbolTable.hpp&quot;
  37 #include &quot;classfile/systemDictionary.hpp&quot;
  38 #include &quot;classfile/vmSymbols.hpp&quot;
  39 #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  40 #include &quot;interpreter/bytecode.hpp&quot;
  41 #include &quot;interpreter/bytecodeUtils.hpp&quot;
  42 #include &quot;jfr/jfrEvents.hpp&quot;
  43 #include &quot;logging/log.hpp&quot;
<a name="2" id="anc2"></a>
  44 #include &quot;memory/heapShared.hpp&quot;
  45 #include &quot;memory/oopFactory.hpp&quot;
  46 #include &quot;memory/referenceType.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;oops/access.inline.hpp&quot;
  50 #include &quot;oops/constantPool.hpp&quot;
  51 #include &quot;oops/fieldStreams.inline.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/method.hpp&quot;
  54 #include &quot;oops/recordComponent.hpp&quot;
  55 #include &quot;oops/objArrayKlass.hpp&quot;
  56 #include &quot;oops/objArrayOop.inline.hpp&quot;
  57 #include &quot;oops/oop.inline.hpp&quot;
  58 #include &quot;oops/valueArrayKlass.hpp&quot;
  59 #include &quot;prims/jvm_misc.hpp&quot;
  60 #include &quot;prims/jvmtiExport.hpp&quot;
  61 #include &quot;prims/jvmtiThreadState.hpp&quot;
  62 #include &quot;prims/nativeLookup.hpp&quot;
  63 #include &quot;prims/stackwalk.hpp&quot;
  64 #include &quot;runtime/arguments.hpp&quot;
  65 #include &quot;runtime/atomic.hpp&quot;
  66 #include &quot;runtime/handles.inline.hpp&quot;
  67 #include &quot;runtime/init.hpp&quot;
  68 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  69 #include &quot;runtime/deoptimization.hpp&quot;
  70 #include &quot;runtime/handshake.hpp&quot;
  71 #include &quot;runtime/java.hpp&quot;
  72 #include &quot;runtime/javaCalls.hpp&quot;
  73 #include &quot;runtime/jfieldIDWorkaround.hpp&quot;
  74 #include &quot;runtime/jniHandles.inline.hpp&quot;
  75 #include &quot;runtime/os.inline.hpp&quot;
  76 #include &quot;runtime/perfData.hpp&quot;
  77 #include &quot;runtime/reflection.hpp&quot;
  78 #include &quot;runtime/synchronizer.hpp&quot;
  79 #include &quot;runtime/thread.inline.hpp&quot;
  80 #include &quot;runtime/threadSMR.hpp&quot;
  81 #include &quot;runtime/vframe.inline.hpp&quot;
  82 #include &quot;runtime/vmOperations.hpp&quot;
  83 #include &quot;runtime/vm_version.hpp&quot;
  84 #include &quot;services/attachListener.hpp&quot;
  85 #include &quot;services/management.hpp&quot;
  86 #include &quot;services/threadService.hpp&quot;
  87 #include &quot;utilities/copy.hpp&quot;
  88 #include &quot;utilities/defaultStream.hpp&quot;
  89 #include &quot;utilities/dtrace.hpp&quot;
  90 #include &quot;utilities/events.hpp&quot;
  91 #include &quot;utilities/histogram.hpp&quot;
  92 #include &quot;utilities/macros.hpp&quot;
  93 #include &quot;utilities/utf8.hpp&quot;
  94 #if INCLUDE_CDS
  95 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  96 #endif
  97 
  98 #include &lt;errno.h&gt;
  99 #include &lt;jfr/recorder/jfrRecorder.hpp&gt;
 100 
 101 /*
 102   NOTE about use of any ctor or function call that can trigger a safepoint/GC:
 103   such ctors and calls MUST NOT come between an oop declaration/init and its
 104   usage because if objects are move this may cause various memory stomps, bus
 105   errors and segfaults. Here is a cookbook for causing so called &quot;naked oop
 106   failures&quot;:
 107 
 108       JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields&lt;etc&gt; {
 109           JVMWrapper(&quot;JVM_GetClassDeclaredFields&quot;);
 110 
 111           // Object address to be held directly in mirror &amp; not visible to GC
 112           oop mirror = JNIHandles::resolve_non_null(ofClass);
 113 
 114           // If this ctor can hit a safepoint, moving objects around, then
 115           ComplexConstructor foo;
 116 
 117           // Boom! mirror may point to JUNK instead of the intended object
 118           (some dereference of mirror)
 119 
 120           // Here&#39;s another call that may block for GC, making mirror stale
 121           MutexLocker ml(some_lock);
 122 
 123           // And here&#39;s an initializer that can result in a stale oop
 124           // all in one step.
 125           oop o = call_that_can_throw_exception(TRAPS);
 126 
 127 
 128   The solution is to keep the oop declaration BELOW the ctor or function
 129   call that might cause a GC, do another resolve to reassign the oop, or
 130   consider use of a Handle instead of an oop so there is immunity from object
 131   motion. But note that the &quot;QUICK&quot; entries below do not have a handlemark
 132   and thus can only support use of handles passed in.
 133 */
 134 
 135 static void trace_class_resolution_impl(Klass* to_class, TRAPS) {
 136   ResourceMark rm;
 137   int line_number = -1;
 138   const char * source_file = NULL;
 139   const char * trace = &quot;explicit&quot;;
 140   InstanceKlass* caller = NULL;
 141   JavaThread* jthread = JavaThread::current();
 142   if (jthread-&gt;has_last_Java_frame()) {
 143     vframeStream vfst(jthread);
 144 
 145     // scan up the stack skipping ClassLoader, AccessController and PrivilegedAction frames
 146     TempNewSymbol access_controller = SymbolTable::new_symbol(&quot;java/security/AccessController&quot;);
 147     Klass* access_controller_klass = SystemDictionary::resolve_or_fail(access_controller, false, CHECK);
 148     TempNewSymbol privileged_action = SymbolTable::new_symbol(&quot;java/security/PrivilegedAction&quot;);
 149     Klass* privileged_action_klass = SystemDictionary::resolve_or_fail(privileged_action, false, CHECK);
 150 
 151     Method* last_caller = NULL;
 152 
 153     while (!vfst.at_end()) {
 154       Method* m = vfst.method();
 155       if (!vfst.method()-&gt;method_holder()-&gt;is_subclass_of(SystemDictionary::ClassLoader_klass())&amp;&amp;
 156           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(access_controller_klass) &amp;&amp;
 157           !vfst.method()-&gt;method_holder()-&gt;is_subclass_of(privileged_action_klass)) {
 158         break;
 159       }
 160       last_caller = m;
 161       vfst.next();
 162     }
 163     // if this is called from Class.forName0 and that is called from Class.forName,
 164     // then print the caller of Class.forName.  If this is Class.loadClass, then print
 165     // that caller, otherwise keep quiet since this should be picked up elsewhere.
 166     bool found_it = false;
 167     if (!vfst.at_end() &amp;&amp;
 168         vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp;
 169         vfst.method()-&gt;name() == vmSymbols::forName0_name()) {
 170       vfst.next();
 171       if (!vfst.at_end() &amp;&amp;
 172           vfst.method()-&gt;method_holder()-&gt;name() == vmSymbols::java_lang_Class() &amp;&amp;
 173           vfst.method()-&gt;name() == vmSymbols::forName_name()) {
 174         vfst.next();
 175         found_it = true;
 176       }
 177     } else if (last_caller != NULL &amp;&amp;
 178                last_caller-&gt;method_holder()-&gt;name() ==
 179                  vmSymbols::java_lang_ClassLoader() &amp;&amp;
 180                last_caller-&gt;name() == vmSymbols::loadClass_name()) {
 181       found_it = true;
 182     } else if (!vfst.at_end()) {
 183       if (vfst.method()-&gt;is_native()) {
 184         // JNI call
 185         found_it = true;
 186       }
 187     }
 188     if (found_it &amp;&amp; !vfst.at_end()) {
 189       // found the caller
 190       caller = vfst.method()-&gt;method_holder();
 191       line_number = vfst.method()-&gt;line_number_from_bci(vfst.bci());
 192       if (line_number == -1) {
 193         // show method name if it&#39;s a native method
 194         trace = vfst.method()-&gt;name_and_sig_as_C_string();
 195       }
 196       Symbol* s = caller-&gt;source_file_name();
 197       if (s != NULL) {
 198         source_file = s-&gt;as_C_string();
 199       }
 200     }
 201   }
 202   if (caller != NULL) {
 203     if (to_class != caller) {
 204       const char * from = caller-&gt;external_name();
 205       const char * to = to_class-&gt;external_name();
 206       // print in a single call to reduce interleaving between threads
 207       if (source_file != NULL) {
 208         log_debug(class, resolve)(&quot;%s %s %s:%d (%s)&quot;, from, to, source_file, line_number, trace);
 209       } else {
 210         log_debug(class, resolve)(&quot;%s %s (%s)&quot;, from, to, trace);
 211       }
 212     }
 213   }
 214 }
 215 
 216 void trace_class_resolution(Klass* to_class) {
 217   EXCEPTION_MARK;
 218   trace_class_resolution_impl(to_class, THREAD);
 219   if (HAS_PENDING_EXCEPTION) {
 220     CLEAR_PENDING_EXCEPTION;
 221   }
 222 }
 223 
 224 // Wrapper to trace JVM functions
 225 
 226 #ifdef ASSERT
 227   Histogram* JVMHistogram;
 228   volatile int JVMHistogram_lock = 0;
 229 
 230   class JVMHistogramElement : public HistogramElement {
 231     public:
 232      JVMHistogramElement(const char* name);
 233   };
 234 
 235   JVMHistogramElement::JVMHistogramElement(const char* elementName) {
 236     _name = elementName;
 237     uintx count = 0;
 238 
 239     while (Atomic::cmpxchg(&amp;JVMHistogram_lock, 0, 1) != 0) {
 240       while (Atomic::load_acquire(&amp;JVMHistogram_lock) != 0) {
 241         count +=1;
 242         if ( (WarnOnStalledSpinLock &gt; 0)
 243           &amp;&amp; (count % WarnOnStalledSpinLock == 0)) {
 244           warning(&quot;JVMHistogram_lock seems to be stalled&quot;);
 245         }
 246       }
 247      }
 248 
 249     if(JVMHistogram == NULL)
 250       JVMHistogram = new Histogram(&quot;JVM Call Counts&quot;,100);
 251 
 252     JVMHistogram-&gt;add_element(this);
 253     Atomic::dec(&amp;JVMHistogram_lock);
 254   }
 255 
 256   #define JVMCountWrapper(arg) \
 257       static JVMHistogramElement* e = new JVMHistogramElement(arg); \
 258       if (e != NULL) e-&gt;increment_count();  // Due to bug in VC++, we need a NULL check here eventhough it should never happen!
 259 
 260   #define JVMWrapper(arg) JVMCountWrapper(arg);
 261 #else
 262   #define JVMWrapper(arg)
 263 #endif
 264 
 265 
 266 // Interface version /////////////////////////////////////////////////////////////////////
 267 
 268 
 269 JVM_LEAF(jint, JVM_GetInterfaceVersion())
 270   return JVM_INTERFACE_VERSION;
 271 JVM_END
 272 
 273 
 274 // java.lang.System //////////////////////////////////////////////////////////////////////
 275 
 276 
 277 JVM_LEAF(jlong, JVM_CurrentTimeMillis(JNIEnv *env, jclass ignored))
 278   JVMWrapper(&quot;JVM_CurrentTimeMillis&quot;);
 279   return os::javaTimeMillis();
 280 JVM_END
 281 
 282 JVM_LEAF(jlong, JVM_NanoTime(JNIEnv *env, jclass ignored))
 283   JVMWrapper(&quot;JVM_NanoTime&quot;);
 284   return os::javaTimeNanos();
 285 JVM_END
 286 
 287 // The function below is actually exposed by jdk.internal.misc.VM and not
 288 // java.lang.System, but we choose to keep it here so that it stays next
 289 // to JVM_CurrentTimeMillis and JVM_NanoTime
 290 
 291 const jlong MAX_DIFF_SECS = CONST64(0x0100000000); //  2^32
 292 const jlong MIN_DIFF_SECS = -MAX_DIFF_SECS; // -2^32
 293 
 294 JVM_LEAF(jlong, JVM_GetNanoTimeAdjustment(JNIEnv *env, jclass ignored, jlong offset_secs))
 295   JVMWrapper(&quot;JVM_GetNanoTimeAdjustment&quot;);
 296   jlong seconds;
 297   jlong nanos;
 298 
 299   os::javaTimeSystemUTC(seconds, nanos);
 300 
 301   // We&#39;re going to verify that the result can fit in a long.
 302   // For that we need the difference in seconds between &#39;seconds&#39;
 303   // and &#39;offset_secs&#39; to be such that:
 304   //     |seconds - offset_secs| &lt; (2^63/10^9)
 305   // We&#39;re going to approximate 10^9 ~&lt; 2^30 (1000^3 ~&lt; 1024^3)
 306   // which makes |seconds - offset_secs| &lt; 2^33
 307   // and we will prefer +/- 2^32 as the maximum acceptable diff
 308   // as 2^32 has a more natural feel than 2^33...
 309   //
 310   // So if |seconds - offset_secs| &gt;= 2^32 - we return a special
 311   // sentinel value (-1) which the caller should take as an
 312   // exception value indicating that the offset given to us is
 313   // too far from range of the current time - leading to too big
 314   // a nano adjustment. The caller is expected to recover by
 315   // computing a more accurate offset and calling this method
 316   // again. (For the record 2^32 secs is ~136 years, so that
 317   // should rarely happen)
 318   //
 319   jlong diff = seconds - offset_secs;
 320   if (diff &gt;= MAX_DIFF_SECS || diff &lt;= MIN_DIFF_SECS) {
 321      return -1; // sentinel value: the offset is too far off the target
 322   }
 323 
 324   // return the adjustment. If you compute a time by adding
 325   // this number of nanoseconds along with the number of seconds
 326   // in the offset you should get the current UTC time.
 327   return (diff * (jlong)1000000000) + nanos;
 328 JVM_END
 329 
 330 JVM_ENTRY(void, JVM_ArrayCopy(JNIEnv *env, jclass ignored, jobject src, jint src_pos,
 331                                jobject dst, jint dst_pos, jint length))
 332   JVMWrapper(&quot;JVM_ArrayCopy&quot;);
 333   // Check if we have null pointers
 334   if (src == NULL || dst == NULL) {
 335     THROW(vmSymbols::java_lang_NullPointerException());
 336   }
 337   arrayOop s = arrayOop(JNIHandles::resolve_non_null(src));
 338   arrayOop d = arrayOop(JNIHandles::resolve_non_null(dst));
 339   assert(oopDesc::is_oop(s), &quot;JVM_ArrayCopy: src not an oop&quot;);
 340   assert(oopDesc::is_oop(d), &quot;JVM_ArrayCopy: dst not an oop&quot;);
 341   // Do copy
 342   s-&gt;klass()-&gt;copy_array(s, src_pos, d, dst_pos, length, thread);
 343 JVM_END
 344 
 345 
 346 static void set_property(Handle props, const char* key, const char* value, TRAPS) {
 347   JavaValue r(T_OBJECT);
 348   // public synchronized Object put(Object key, Object value);
 349   HandleMark hm(THREAD);
 350   Handle key_str    = java_lang_String::create_from_platform_dependent_str(key, CHECK);
 351   Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != NULL ? value : &quot;&quot;), CHECK);
 352   JavaCalls::call_virtual(&amp;r,
 353                           props,
 354                           SystemDictionary::Properties_klass(),
 355                           vmSymbols::put_name(),
 356                           vmSymbols::object_object_object_signature(),
 357                           key_str,
 358                           value_str,
 359                           THREAD);
 360 }
 361 
 362 
 363 #define PUTPROP(props, name, value) set_property((props), (name), (value), CHECK_(properties));
 364 
 365 /*
 366  * Return all of the system properties in a Java String array with alternating
 367  * names and values from the jvm SystemProperty.
 368  * Which includes some internal and all commandline -D defined properties.
 369  */
 370 JVM_ENTRY(jobjectArray, JVM_GetProperties(JNIEnv *env))
 371   JVMWrapper(&quot;JVM_GetProperties&quot;);
 372   ResourceMark rm(THREAD);
 373   HandleMark hm(THREAD);
 374   int ndx = 0;
 375   int fixedCount = 2;
 376 
 377   SystemProperty* p = Arguments::system_properties();
 378   int count = Arguments::PropertyList_count(p);
 379 
 380   // Allocate result String array
 381   InstanceKlass* ik = SystemDictionary::String_klass();
 382   objArrayOop r = oopFactory::new_objArray(ik, (count + fixedCount) * 2, CHECK_NULL);
 383   objArrayHandle result_h(THREAD, r);
 384 
 385   while (p != NULL) {
 386     const char * key = p-&gt;key();
 387     if (strcmp(key, &quot;sun.nio.MaxDirectMemorySize&quot;) != 0) {
 388         const char * value = p-&gt;value();
 389         Handle key_str    = java_lang_String::create_from_platform_dependent_str(key, CHECK_NULL);
 390         Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != NULL ? value : &quot;&quot;), CHECK_NULL);
 391         result_h-&gt;obj_at_put(ndx * 2,  key_str());
 392         result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 393         ndx++;
 394     }
 395     p = p-&gt;next();
 396   }
 397 
 398   // Convert the -XX:MaxDirectMemorySize= command line flag
 399   // to the sun.nio.MaxDirectMemorySize property.
 400   // Do this after setting user properties to prevent people
 401   // from setting the value with a -D option, as requested.
 402   // Leave empty if not supplied
 403   if (!FLAG_IS_DEFAULT(MaxDirectMemorySize)) {
 404     char as_chars[256];
 405     jio_snprintf(as_chars, sizeof(as_chars), JULONG_FORMAT, MaxDirectMemorySize);
 406     Handle key_str = java_lang_String::create_from_platform_dependent_str(&quot;sun.nio.MaxDirectMemorySize&quot;, CHECK_NULL);
 407     Handle value_str  = java_lang_String::create_from_platform_dependent_str(as_chars, CHECK_NULL);
 408     result_h-&gt;obj_at_put(ndx * 2,  key_str());
 409     result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 410     ndx++;
 411   }
 412 
 413   // JVM monitoring and management support
 414   // Add the sun.management.compiler property for the compiler&#39;s name
 415   {
 416 #undef CSIZE
 417 #if defined(_LP64) || defined(_WIN64)
 418   #define CSIZE &quot;64-Bit &quot;
 419 #else
 420   #define CSIZE
 421 #endif // 64bit
 422 
 423 #ifdef TIERED
 424     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Tiered Compilers&quot;;
 425 #else
 426 #if defined(COMPILER1)
 427     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Client Compiler&quot;;
 428 #elif defined(COMPILER2)
 429     const char* compiler_name = &quot;HotSpot &quot; CSIZE &quot;Server Compiler&quot;;
 430 #elif INCLUDE_JVMCI
 431     #error &quot;INCLUDE_JVMCI should imply TIERED&quot;
 432 #else
 433     const char* compiler_name = &quot;&quot;;
 434 #endif // compilers
 435 #endif // TIERED
 436 
 437     if (*compiler_name != &#39;\0&#39; &amp;&amp;
 438         (Arguments::mode() != Arguments::_int)) {
 439       Handle key_str = java_lang_String::create_from_platform_dependent_str(&quot;sun.management.compiler&quot;, CHECK_NULL);
 440       Handle value_str  = java_lang_String::create_from_platform_dependent_str(compiler_name, CHECK_NULL);
 441       result_h-&gt;obj_at_put(ndx * 2,  key_str());
 442       result_h-&gt;obj_at_put(ndx * 2 + 1, value_str());
 443       ndx++;
 444     }
 445   }
 446 
 447   return (jobjectArray) JNIHandles::make_local(env, result_h());
 448 JVM_END
 449 
 450 
 451 /*
 452  * Return the temporary directory that the VM uses for the attach
 453  * and perf data files.
 454  *
 455  * It is important that this directory is well-known and the
 456  * same for all VM instances. It cannot be affected by configuration
 457  * variables such as java.io.tmpdir.
 458  */
 459 JVM_ENTRY(jstring, JVM_GetTemporaryDirectory(JNIEnv *env))
 460   JVMWrapper(&quot;JVM_GetTemporaryDirectory&quot;);
 461   HandleMark hm(THREAD);
 462   const char* temp_dir = os::get_temp_directory();
 463   Handle h = java_lang_String::create_from_platform_dependent_str(temp_dir, CHECK_NULL);
 464   return (jstring) JNIHandles::make_local(env, h());
 465 JVM_END
 466 
 467 
 468 // java.lang.Runtime /////////////////////////////////////////////////////////////////////////
 469 
 470 extern volatile jint vm_created;
 471 
 472 JVM_ENTRY_NO_ENV(void, JVM_BeforeHalt())
 473   JVMWrapper(&quot;JVM_BeforeHalt&quot;);
 474   // Link all classes for dynamic CDS dumping before vm exit.
 475   if (DynamicDumpSharedSpaces) {
 476     MetaspaceShared::link_and_cleanup_shared_classes(THREAD);
 477   }
 478   EventShutdown event;
 479   if (event.should_commit()) {
 480     event.set_reason(&quot;Shutdown requested from Java&quot;);
 481     event.commit();
 482   }
 483 JVM_END
 484 
 485 
 486 JVM_ENTRY_NO_ENV(void, JVM_Halt(jint code))
 487   before_exit(thread);
 488   vm_exit(code);
 489 JVM_END
 490 
 491 
 492 JVM_ENTRY_NO_ENV(void, JVM_GC(void))
 493   JVMWrapper(&quot;JVM_GC&quot;);
 494   if (!DisableExplicitGC) {
 495     if (AsyncDeflateIdleMonitors) {
 496       // AsyncDeflateIdleMonitors needs to know when System.gc() is
 497       // called so any special deflation can be done at a safepoint.
 498       ObjectSynchronizer::set_is_special_deflation_requested(true);
 499     }
 500     Universe::heap()-&gt;collect(GCCause::_java_lang_system_gc);
 501   }
 502 JVM_END
 503 
 504 
 505 JVM_LEAF(jlong, JVM_MaxObjectInspectionAge(void))
 506   JVMWrapper(&quot;JVM_MaxObjectInspectionAge&quot;);
 507   return Universe::heap()-&gt;millis_since_last_gc();
 508 JVM_END
 509 
 510 
 511 static inline jlong convert_size_t_to_jlong(size_t val) {
 512   // In the 64-bit vm, a size_t can overflow a jlong (which is signed).
 513   NOT_LP64 (return (jlong)val;)
 514   LP64_ONLY(return (jlong)MIN2(val, (size_t)max_jlong);)
 515 }
 516 
 517 JVM_ENTRY_NO_ENV(jlong, JVM_TotalMemory(void))
 518   JVMWrapper(&quot;JVM_TotalMemory&quot;);
 519   size_t n = Universe::heap()-&gt;capacity();
 520   return convert_size_t_to_jlong(n);
 521 JVM_END
 522 
 523 
 524 JVM_ENTRY_NO_ENV(jlong, JVM_FreeMemory(void))
 525   JVMWrapper(&quot;JVM_FreeMemory&quot;);
 526   size_t n = Universe::heap()-&gt;unused();
 527   return convert_size_t_to_jlong(n);
 528 JVM_END
 529 
 530 
 531 JVM_ENTRY_NO_ENV(jlong, JVM_MaxMemory(void))
 532   JVMWrapper(&quot;JVM_MaxMemory&quot;);
 533   size_t n = Universe::heap()-&gt;max_capacity();
 534   return convert_size_t_to_jlong(n);
 535 JVM_END
 536 
 537 
 538 JVM_ENTRY_NO_ENV(jint, JVM_ActiveProcessorCount(void))
 539   JVMWrapper(&quot;JVM_ActiveProcessorCount&quot;);
 540   return os::active_processor_count();
 541 JVM_END
 542 
 543 
 544 
 545 // java.lang.Throwable //////////////////////////////////////////////////////
 546 
 547 JVM_ENTRY(void, JVM_FillInStackTrace(JNIEnv *env, jobject receiver))
 548   JVMWrapper(&quot;JVM_FillInStackTrace&quot;);
 549   Handle exception(thread, JNIHandles::resolve_non_null(receiver));
 550   java_lang_Throwable::fill_in_stack_trace(exception);
 551 JVM_END
 552 
 553 // java.lang.NullPointerException ///////////////////////////////////////////
 554 
 555 JVM_ENTRY(jstring, JVM_GetExtendedNPEMessage(JNIEnv *env, jthrowable throwable))
 556   if (!ShowCodeDetailsInExceptionMessages) return NULL;
 557 
 558   oop exc = JNIHandles::resolve_non_null(throwable);
 559 
 560   Method* method;
 561   int bci;
 562   if (!java_lang_Throwable::get_top_method_and_bci(exc, &amp;method, &amp;bci)) {
 563     return NULL;
 564   }
 565   if (method-&gt;is_native()) {
 566     return NULL;
 567   }
 568 
 569   stringStream ss;
 570   bool ok = BytecodeUtils::get_NPE_message_at(&amp;ss, method, bci);
 571   if (ok) {
 572     oop result = java_lang_String::create_oop_from_str(ss.base(), CHECK_NULL);
 573     return (jstring) JNIHandles::make_local(env, result);
 574   } else {
 575     return NULL;
 576   }
 577 JVM_END
 578 
 579 // java.lang.StackTraceElement //////////////////////////////////////////////
 580 
 581 
 582 JVM_ENTRY(void, JVM_InitStackTraceElementArray(JNIEnv *env, jobjectArray elements, jobject throwable))
 583   JVMWrapper(&quot;JVM_InitStackTraceElementArray&quot;);
 584   Handle exception(THREAD, JNIHandles::resolve(throwable));
 585   objArrayOop st = objArrayOop(JNIHandles::resolve(elements));
 586   objArrayHandle stack_trace(THREAD, st);
 587   // Fill in the allocated stack trace
 588   java_lang_Throwable::get_stack_trace_elements(exception, stack_trace, CHECK);
 589 JVM_END
 590 
 591 
 592 JVM_ENTRY(void, JVM_InitStackTraceElement(JNIEnv* env, jobject element, jobject stackFrameInfo))
 593   JVMWrapper(&quot;JVM_InitStackTraceElement&quot;);
 594   Handle stack_frame_info(THREAD, JNIHandles::resolve_non_null(stackFrameInfo));
 595   Handle stack_trace_element(THREAD, JNIHandles::resolve_non_null(element));
 596   java_lang_StackFrameInfo::to_stack_trace_element(stack_frame_info, stack_trace_element, THREAD);
 597 JVM_END
 598 
 599 
 600 // java.lang.StackWalker //////////////////////////////////////////////////////
 601 
 602 
 603 JVM_ENTRY(jobject, JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,
 604                                      jint skip_frames, jint frame_count, jint start_index,
 605                                      jobjectArray frames))
 606   JVMWrapper(&quot;JVM_CallStackWalk&quot;);
 607   JavaThread* jt = (JavaThread*) THREAD;
 608   if (!jt-&gt;is_Java_thread() || !jt-&gt;has_last_Java_frame()) {
 609     THROW_MSG_(vmSymbols::java_lang_InternalError(), &quot;doStackWalk: no stack trace&quot;, NULL);
 610   }
 611 
 612   Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 613 
 614   // frames array is a Class&lt;?&gt;[] array when only getting caller reference,
 615   // and a StackFrameInfo[] array (or derivative) otherwise. It should never
 616   // be null.
 617   objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 618   objArrayHandle frames_array_h(THREAD, fa);
 619 
 620   int limit = start_index + frame_count;
 621   if (frames_array_h-&gt;length() &lt; limit) {
 622     THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(), &quot;not enough space in buffers&quot;, NULL);
 623   }
 624 
 625   oop result = StackWalk::walk(stackStream_h, mode, skip_frames, frame_count,
 626                                start_index, frames_array_h, CHECK_NULL);
 627   return JNIHandles::make_local(env, result);
 628 JVM_END
 629 
 630 
 631 JVM_ENTRY(jint, JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,
 632                                   jint frame_count, jint start_index,
 633                                   jobjectArray frames))
 634   JVMWrapper(&quot;JVM_MoreStackWalk&quot;);
 635   JavaThread* jt = (JavaThread*) THREAD;
 636 
 637   // frames array is a Class&lt;?&gt;[] array when only getting caller reference,
 638   // and a StackFrameInfo[] array (or derivative) otherwise. It should never
 639   // be null.
 640   objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));
 641   objArrayHandle frames_array_h(THREAD, fa);
 642 
 643   int limit = start_index+frame_count;
 644   if (frames_array_h-&gt;length() &lt; limit) {
 645     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;not enough space in buffers&quot;);
 646   }
 647 
 648   Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));
 649   return StackWalk::fetchNextBatch(stackStream_h, mode, anchor, frame_count,
 650                                    start_index, frames_array_h, THREAD);
 651 JVM_END
 652 
 653 // java.lang.Object ///////////////////////////////////////////////
 654 
 655 
 656 JVM_ENTRY(jint, JVM_IHashCode(JNIEnv* env, jobject handle))
 657   JVMWrapper(&quot;JVM_IHashCode&quot;);
 658   // as implemented in the classic virtual machine; return 0 if object is NULL
 659   return handle == NULL ? 0 : ObjectSynchronizer::FastHashCode (THREAD, JNIHandles::resolve_non_null(handle)) ;
 660 JVM_END
 661 
 662 
 663 JVM_ENTRY(void, JVM_MonitorWait(JNIEnv* env, jobject handle, jlong ms))
 664   JVMWrapper(&quot;JVM_MonitorWait&quot;);
 665   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 666   JavaThreadInObjectWaitState jtiows(thread, ms != 0);
 667   if (JvmtiExport::should_post_monitor_wait()) {
 668     JvmtiExport::post_monitor_wait((JavaThread *)THREAD, (oop)obj(), ms);
 669 
 670     // The current thread already owns the monitor and it has not yet
 671     // been added to the wait queue so the current thread cannot be
 672     // made the successor. This means that the JVMTI_EVENT_MONITOR_WAIT
 673     // event handler cannot accidentally consume an unpark() meant for
 674     // the ParkEvent associated with this ObjectMonitor.
 675   }
 676   ObjectSynchronizer::wait(obj, ms, CHECK);
 677 JVM_END
 678 
 679 
 680 JVM_ENTRY(void, JVM_MonitorNotify(JNIEnv* env, jobject handle))
 681   JVMWrapper(&quot;JVM_MonitorNotify&quot;);
 682   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 683   ObjectSynchronizer::notify(obj, CHECK);
 684 JVM_END
 685 
 686 
 687 JVM_ENTRY(void, JVM_MonitorNotifyAll(JNIEnv* env, jobject handle))
 688   JVMWrapper(&quot;JVM_MonitorNotifyAll&quot;);
 689   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 690   ObjectSynchronizer::notifyall(obj, CHECK);
 691 JVM_END
 692 
 693 
 694 JVM_ENTRY(jobject, JVM_Clone(JNIEnv* env, jobject handle))
 695   JVMWrapper(&quot;JVM_Clone&quot;);
 696   Handle obj(THREAD, JNIHandles::resolve_non_null(handle));
 697   Klass* klass = obj-&gt;klass();
 698   JvmtiVMObjectAllocEventCollector oam;
 699 
 700 #ifdef ASSERT
 701   // Just checking that the cloneable flag is set correct
 702   if (obj-&gt;is_array()) {
 703     guarantee(klass-&gt;is_cloneable(), &quot;all arrays are cloneable&quot;);
 704   } else {
 705     guarantee(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 706     bool cloneable = klass-&gt;is_subtype_of(SystemDictionary::Cloneable_klass());
 707     guarantee(cloneable == klass-&gt;is_cloneable(), &quot;incorrect cloneable flag&quot;);
 708   }
 709 #endif
 710 
 711   // Check if class of obj supports the Cloneable interface.
 712   // All arrays are considered to be cloneable (See JLS 20.1.5).
 713   // All j.l.r.Reference classes are considered non-cloneable.
 714   if (!klass-&gt;is_cloneable() ||
 715        klass-&gt;is_value() ||
 716       (klass-&gt;is_instance_klass() &amp;&amp;
 717        InstanceKlass::cast(klass)-&gt;reference_type() != REF_NONE)) {
 718     ResourceMark rm(THREAD);
 719     THROW_MSG_0(vmSymbols::java_lang_CloneNotSupportedException(), klass-&gt;external_name());
 720   }
 721 
 722   // Make shallow object copy
 723   const int size = obj-&gt;size();
 724   oop new_obj_oop = NULL;
 725   if (obj-&gt;is_array()) {
 726     const int length = ((arrayOop)obj())-&gt;length();
 727     new_obj_oop = Universe::heap()-&gt;array_allocate(klass, size, length,
 728                                                    /* do_zero */ true, CHECK_NULL);
 729   } else {
 730     new_obj_oop = Universe::heap()-&gt;obj_allocate(klass, size, CHECK_NULL);
 731   }
 732 
 733   HeapAccess&lt;&gt;::clone(obj(), new_obj_oop, size);
 734 
 735   Handle new_obj(THREAD, new_obj_oop);
 736   // Caution: this involves a java upcall, so the clone should be
 737   // &quot;gc-robust&quot; by this stage.
 738   if (klass-&gt;has_finalizer()) {
 739     assert(obj-&gt;is_instance(), &quot;should be instanceOop&quot;);
 740     new_obj_oop = InstanceKlass::register_finalizer(instanceOop(new_obj()), CHECK_NULL);
 741     new_obj = Handle(THREAD, new_obj_oop);
 742   }
 743 
 744   return JNIHandles::make_local(env, new_obj());
 745 JVM_END
 746 
 747 // java.io.File ///////////////////////////////////////////////////////////////
 748 
 749 JVM_LEAF(char*, JVM_NativePath(char* path))
 750   JVMWrapper(&quot;JVM_NativePath&quot;);
 751   return os::native_path(path);
 752 JVM_END
 753 
 754 
 755 // Misc. class handling ///////////////////////////////////////////////////////////
 756 
 757 
 758 JVM_ENTRY(jclass, JVM_GetCallerClass(JNIEnv* env))
 759   JVMWrapper(&quot;JVM_GetCallerClass&quot;);
 760 
 761   // Getting the class of the caller frame.
 762   //
 763   // The call stack at this point looks something like this:
 764   //
 765   // [0] [ @CallerSensitive public sun.reflect.Reflection.getCallerClass ]
 766   // [1] [ @CallerSensitive API.method                                   ]
 767   // [.] [ (skipped intermediate frames)                                 ]
 768   // [n] [ caller                                                        ]
 769   vframeStream vfst(thread);
 770   // Cf. LibraryCallKit::inline_native_Reflection_getCallerClass
 771   for (int n = 0; !vfst.at_end(); vfst.security_next(), n++) {
 772     Method* m = vfst.method();
 773     assert(m != NULL, &quot;sanity&quot;);
 774     switch (n) {
 775     case 0:
 776       // This must only be called from Reflection.getCallerClass
 777       if (m-&gt;intrinsic_id() != vmIntrinsics::_getCallerClass) {
 778         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;JVM_GetCallerClass must only be called from Reflection.getCallerClass&quot;);
 779       }
 780       // fall-through
 781     case 1:
 782       // Frame 0 and 1 must be caller sensitive.
 783       if (!m-&gt;caller_sensitive()) {
 784         THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), err_msg(&quot;CallerSensitive annotation expected at frame %d&quot;, n));
 785       }
 786       break;
 787     default:
 788       if (!m-&gt;is_ignored_by_security_stack_walk()) {
 789         // We have reached the desired frame; return the holder class.
 790         return (jclass) JNIHandles::make_local(env, m-&gt;method_holder()-&gt;java_mirror());
 791       }
 792       break;
 793     }
 794   }
 795   return NULL;
 796 JVM_END
 797 
 798 
 799 JVM_ENTRY(jclass, JVM_FindPrimitiveClass(JNIEnv* env, const char* utf))
 800   JVMWrapper(&quot;JVM_FindPrimitiveClass&quot;);
 801   oop mirror = NULL;
 802   BasicType t = name2type(utf);
 803   if (t != T_ILLEGAL &amp;&amp; !is_reference_type(t)) {
 804     mirror = Universe::java_mirror(t);
 805   }
 806   if (mirror == NULL) {
 807     THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), (char*) utf);
 808   } else {
 809     return (jclass) JNIHandles::make_local(env, mirror);
 810   }
 811 JVM_END
 812 
 813 
 814 // Returns a class loaded by the bootstrap class loader; or null
 815 // if not found.  ClassNotFoundException is not thrown.
 816 // FindClassFromBootLoader is exported to the launcher for windows.
 817 JVM_ENTRY(jclass, JVM_FindClassFromBootLoader(JNIEnv* env,
 818                                               const char* name))
 819   JVMWrapper(&quot;JVM_FindClassFromBootLoader&quot;);
 820 
 821   // Java libraries should ensure that name is never null or illegal.
 822   if (name == NULL || (int)strlen(name) &gt; Symbol::max_length()) {
 823     // It&#39;s impossible to create this class;  the name cannot fit
 824     // into the constant pool.
 825     return NULL;
 826   }
 827   assert(UTF8::is_legal_utf8((const unsigned char*)name, (int)strlen(name), false), &quot;illegal UTF name&quot;);
 828 
 829   TempNewSymbol h_name = SymbolTable::new_symbol(name);
 830   Klass* k = SystemDictionary::resolve_or_null(h_name, CHECK_NULL);
 831   if (k == NULL) {
 832     return NULL;
 833   }
 834 
 835   if (log_is_enabled(Debug, class, resolve)) {
 836     trace_class_resolution(k);
 837   }
 838   return (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
 839 JVM_END
 840 
 841 // Find a class with this name in this loader, using the caller&#39;s protection domain.
 842 JVM_ENTRY(jclass, JVM_FindClassFromCaller(JNIEnv* env, const char* name,
 843                                           jboolean init, jobject loader,
 844                                           jclass caller))
 845   JVMWrapper(&quot;JVM_FindClassFromCaller throws ClassNotFoundException&quot;);
 846 
 847   TempNewSymbol h_name =
 848        SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_ClassNotFoundException(),
 849                                            CHECK_NULL);
 850 
 851   oop loader_oop = JNIHandles::resolve(loader);
 852   oop from_class = JNIHandles::resolve(caller);
 853   oop protection_domain = NULL;
 854   // If loader is null, shouldn&#39;t call ClassLoader.checkPackageAccess; otherwise get
 855   // NPE. Put it in another way, the bootstrap class loader has all permission and
 856   // thus no checkPackageAccess equivalence in the VM class loader.
 857   // The caller is also passed as NULL by the java code if there is no security
 858   // manager to avoid the performance cost of getting the calling class.
 859   if (from_class != NULL &amp;&amp; loader_oop != NULL) {
 860     protection_domain = java_lang_Class::as_Klass(from_class)-&gt;protection_domain();
 861   }
 862 
 863   Handle h_loader(THREAD, loader_oop);
 864   Handle h_prot(THREAD, protection_domain);
 865   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 866                                                h_prot, false, THREAD);
 867 
 868   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 869     trace_class_resolution(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(result)));
 870   }
 871   return result;
 872 JVM_END
 873 
 874 // Currently only called from the old verifier.
 875 JVM_ENTRY(jclass, JVM_FindClassFromClass(JNIEnv *env, const char *name,
 876                                          jboolean init, jclass from))
 877   JVMWrapper(&quot;JVM_FindClassFromClass&quot;);
 878   TempNewSymbol h_name =
 879        SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_ClassNotFoundException(),
 880                                            CHECK_NULL);
 881   oop from_class_oop = JNIHandles::resolve(from);
 882   Klass* from_class = (from_class_oop == NULL)
 883                            ? (Klass*)NULL
 884                            : java_lang_Class::as_Klass(from_class_oop);
 885   oop class_loader = NULL;
 886   oop protection_domain = NULL;
 887   if (from_class != NULL) {
 888     class_loader = from_class-&gt;class_loader();
 889     protection_domain = from_class-&gt;protection_domain();
 890   }
 891   Handle h_loader(THREAD, class_loader);
 892   Handle h_prot  (THREAD, protection_domain);
 893   jclass result = find_class_from_class_loader(env, h_name, init, h_loader,
 894                                                h_prot, true, thread);
 895 
 896   if (log_is_enabled(Debug, class, resolve) &amp;&amp; result != NULL) {
 897     // this function is generally only used for class loading during verification.
 898     ResourceMark rm;
 899     oop from_mirror = JNIHandles::resolve_non_null(from);
 900     Klass* from_class = java_lang_Class::as_Klass(from_mirror);
 901     const char * from_name = from_class-&gt;external_name();
 902 
 903     oop mirror = JNIHandles::resolve_non_null(result);
 904     Klass* to_class = java_lang_Class::as_Klass(mirror);
 905     const char * to = to_class-&gt;external_name();
 906     log_debug(class, resolve)(&quot;%s %s (verification)&quot;, from_name, to);
 907   }
 908 
 909   return result;
 910 JVM_END
 911 
 912 static void is_lock_held_by_thread(Handle loader, PerfCounter* counter, TRAPS) {
 913   if (loader.is_null()) {
 914     return;
 915   }
 916 
 917   // check whether the current caller thread holds the lock or not.
 918   // If not, increment the corresponding counter
 919   if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader) !=
 920       ObjectSynchronizer::owner_self) {
 921     counter-&gt;inc();
 922   }
 923 }
 924 
 925 // common code for JVM_DefineClass() and JVM_DefineClassWithSource()
 926 static jclass jvm_define_class_common(JNIEnv *env, const char *name,
 927                                       jobject loader, const jbyte *buf,
 928                                       jsize len, jobject pd, const char *source,
 929                                       TRAPS) {
 930   if (source == NULL)  source = &quot;__JVM_DefineClass__&quot;;
 931 
 932   assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
 933   JavaThread* jt = (JavaThread*) THREAD;
 934 
 935   PerfClassTraceTime vmtimer(ClassLoader::perf_define_appclass_time(),
 936                              ClassLoader::perf_define_appclass_selftime(),
 937                              ClassLoader::perf_define_appclasses(),
 938                              jt-&gt;get_thread_stat()-&gt;perf_recursion_counts_addr(),
 939                              jt-&gt;get_thread_stat()-&gt;perf_timers_addr(),
 940                              PerfClassTraceTime::DEFINE_CLASS);
 941 
 942   if (UsePerfData) {
 943     ClassLoader::perf_app_classfile_bytes_read()-&gt;inc(len);
 944   }
 945 
 946   // Class resolution will get the class name from the .class stream if the name is null.
 947   TempNewSymbol class_name = name == NULL ? NULL :
 948        SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_NoClassDefFoundError(),
 949                                            CHECK_NULL);
 950 
 951   ResourceMark rm(THREAD);
 952   ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);
 953   Handle class_loader (THREAD, JNIHandles::resolve(loader));
 954   if (UsePerfData) {
 955     is_lock_held_by_thread(class_loader,
 956                            ClassLoader::sync_JVMDefineClassLockFreeCounter(),
 957                            THREAD);
 958   }
 959   Handle protection_domain (THREAD, JNIHandles::resolve(pd));
 960   Klass* k = SystemDictionary::resolve_from_stream(class_name,
 961                                                    class_loader,
 962                                                    protection_domain,
 963                                                    &amp;st,
 964                                                    CHECK_NULL);
 965 
 966   if (log_is_enabled(Debug, class, resolve) &amp;&amp; k != NULL) {
 967     trace_class_resolution(k);
 968   }
 969 
 970   return (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
 971 }
 972 
 973 enum {
 974   NESTMATE              = java_lang_invoke_MemberName::MN_NESTMATE_CLASS,
 975   HIDDEN_CLASS          = java_lang_invoke_MemberName::MN_HIDDEN_CLASS,
 976   STRONG_LOADER_LINK    = java_lang_invoke_MemberName::MN_STRONG_LOADER_LINK,
 977   ACCESS_VM_ANNOTATIONS = java_lang_invoke_MemberName::MN_ACCESS_VM_ANNOTATIONS
 978 };
 979 
 980 /*
 981  * Define a class with the specified flags that indicates if it&#39;s a nestmate,
 982  * hidden, or strongly referenced from class loader.
 983  */
 984 static jclass jvm_lookup_define_class(JNIEnv *env, jclass lookup, const char *name,
 985                                       const jbyte *buf, jsize len, jobject pd,
 986                                       jboolean init, int flags, jobject classData, TRAPS) {
 987   assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
 988   JavaThread* jt = (JavaThread*) THREAD;
 989   ResourceMark rm(THREAD);
 990 
 991   Klass* lookup_k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(lookup));
 992   // Lookup class must be a non-null instance
 993   if (lookup_k == NULL) {
 994     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Lookup class is null&quot;);
 995   }
 996   assert(lookup_k-&gt;is_instance_klass(), &quot;Lookup class must be an instance klass&quot;);
 997 
 998   Handle class_loader (THREAD, lookup_k-&gt;class_loader());
 999 
1000   bool is_nestmate = (flags &amp; NESTMATE) == NESTMATE;
1001   bool is_hidden = (flags &amp; HIDDEN_CLASS) == HIDDEN_CLASS;
1002   bool is_strong = (flags &amp; STRONG_LOADER_LINK) == STRONG_LOADER_LINK;
1003   bool vm_annotations = (flags &amp; ACCESS_VM_ANNOTATIONS) == ACCESS_VM_ANNOTATIONS;
1004 
1005   InstanceKlass* host_class = NULL;
1006   if (is_nestmate) {
1007     host_class = InstanceKlass::cast(lookup_k)-&gt;nest_host(CHECK_NULL);
1008   }
1009 
1010   log_info(class, nestmates)(&quot;LookupDefineClass: %s - %s%s, %s, %s, %s&quot;,
1011                              name,
1012                              is_nestmate ? &quot;with dynamic nest-host &quot; : &quot;non-nestmate&quot;,
1013                              is_nestmate ? host_class-&gt;external_name() : &quot;&quot;,
1014                              is_hidden ? &quot;hidden&quot; : &quot;not hidden&quot;,
1015                              is_strong ? &quot;strong&quot; : &quot;weak&quot;,
1016                              vm_annotations ? &quot;with vm annotations&quot; : &quot;without vm annotation&quot;);
1017 
1018   if (!is_hidden) {
1019     // classData is only applicable for hidden classes
1020     if (classData != NULL) {
1021       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;classData is only applicable for hidden classes&quot;);
1022     }
1023     if (is_nestmate) {
1024       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;dynamic nestmate is only applicable for hidden classes&quot;);
1025     }
1026     if (!is_strong) {
1027       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;an ordinary class must be strongly referenced by its defining loader&quot;);
1028     }
1029     if (vm_annotations) {
1030       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;vm annotations only allowed for hidden classes&quot;);
1031     }
1032     if (flags != STRONG_LOADER_LINK) {
1033       THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1034                   err_msg(&quot;invalid flag 0x%x&quot;, flags));
1035     }
1036   }
1037 
1038   // Class resolution will get the class name from the .class stream if the name is null.
1039   TempNewSymbol class_name = name == NULL ? NULL :
1040        SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_NoClassDefFoundError(),
1041                                            CHECK_NULL);
1042 
1043   Handle protection_domain (THREAD, JNIHandles::resolve(pd));
1044   const char* source = is_nestmate ? host_class-&gt;external_name() : &quot;__JVM_LookupDefineClass__&quot;;
1045   ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);
1046 
1047   Klass* defined_k;
1048   InstanceKlass* ik = NULL;
1049   if (!is_hidden) {
1050     defined_k = SystemDictionary::resolve_from_stream(class_name,
1051                                                       class_loader,
1052                                                       protection_domain,
1053                                                       &amp;st,
1054                                                       CHECK_NULL);
1055 
1056     if (log_is_enabled(Debug, class, resolve) &amp;&amp; defined_k != NULL) {
1057       trace_class_resolution(defined_k);
1058     }
1059     ik = InstanceKlass::cast(defined_k);
1060   } else { // hidden
1061     Handle classData_h(THREAD, JNIHandles::resolve(classData));
1062     ClassLoadInfo cl_info(protection_domain,
1063                           NULL, // unsafe_anonymous_host
1064                           NULL, // cp_patches
1065                           host_class,
1066                           classData_h,
1067                           is_hidden,
1068                           is_strong,
1069                           vm_annotations);
1070     defined_k = SystemDictionary::parse_stream(class_name,
1071                                                class_loader,
1072                                                &amp;st,
1073                                                cl_info,
1074                                                CHECK_NULL);
1075     if (defined_k == NULL) {
1076       THROW_MSG_0(vmSymbols::java_lang_Error(), &quot;Failure to define a hidden class&quot;);
1077     }
1078 
1079     ik = InstanceKlass::cast(defined_k);
1080 
1081     // The hidden class loader data has been artificially been kept alive to
1082     // this point. The mirror and any instances of this class have to keep
1083     // it alive afterwards.
1084     ik-&gt;class_loader_data()-&gt;dec_keep_alive();
1085 
1086     if (is_nestmate &amp;&amp; log_is_enabled(Debug, class, nestmates)) {
1087       ModuleEntry* module = ik-&gt;module();
1088       const char * module_name = module-&gt;is_named() ? module-&gt;name()-&gt;as_C_string() : UNNAMED_MODULE;
1089       log_debug(class, nestmates)(&quot;Dynamic nestmate: %s/%s, nest_host %s, %s&quot;,
1090                                   module_name,
1091                                   ik-&gt;external_name(),
1092                                   host_class-&gt;external_name(),
1093                                   ik-&gt;is_hidden() ? &quot;is hidden&quot; : &quot;is not hidden&quot;);
1094     }
1095   }
1096   assert(Reflection::is_same_class_package(lookup_k, defined_k),
1097          &quot;lookup class and defined class are in different packages&quot;);
1098 
1099   if (init) {
1100     ik-&gt;initialize(CHECK_NULL);
1101   } else {
1102     ik-&gt;link_class(CHECK_NULL);
1103   }
1104 
1105   return (jclass) JNIHandles::make_local(env, defined_k-&gt;java_mirror());
1106 }
1107 
1108 JVM_ENTRY(jclass, JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd))
1109   JVMWrapper(&quot;JVM_DefineClass&quot;);
1110 
1111   return jvm_define_class_common(env, name, loader, buf, len, pd, NULL, THREAD);
1112 JVM_END
1113 
1114 /*
1115  * Define a class with the specified lookup class.
1116  *  lookup:  Lookup class
1117  *  name:    the name of the class
1118  *  buf:     class bytes
1119  *  len:     length of class bytes
1120  *  pd:      protection domain
1121  *  init:    initialize the class
1122  *  flags:   properties of the class
1123  *  classData: private static pre-initialized field
1124  */
1125 JVM_ENTRY(jclass, JVM_LookupDefineClass(JNIEnv *env, jclass lookup, const char *name, const jbyte *buf,
1126           jsize len, jobject pd, jboolean initialize, int flags, jobject classData))
1127   JVMWrapper(&quot;JVM_LookupDefineClass&quot;);
1128 
1129   if (lookup == NULL) {
1130     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Lookup class is null&quot;);
1131   }
1132 
1133   assert(buf != NULL, &quot;buf must not be NULL&quot;);
1134 
1135   return jvm_lookup_define_class(env, lookup, name, buf, len, pd, initialize, flags, classData, THREAD);
1136 JVM_END
1137 
1138 JVM_ENTRY(jclass, JVM_DefineClassWithSource(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd, const char *source))
1139   JVMWrapper(&quot;JVM_DefineClassWithSource&quot;);
1140 
1141   return jvm_define_class_common(env, name, loader, buf, len, pd, source, THREAD);
1142 JVM_END
1143 
1144 JVM_ENTRY(jclass, JVM_FindLoadedClass(JNIEnv *env, jobject loader, jstring name))
1145   JVMWrapper(&quot;JVM_FindLoadedClass&quot;);
1146   ResourceMark rm(THREAD);
1147 
1148   Handle h_name (THREAD, JNIHandles::resolve_non_null(name));
1149   char* str = java_lang_String::as_utf8_string(h_name());
1150 
1151   // Sanity check, don&#39;t expect null
1152   if (str == NULL) return NULL;
1153 
1154   // Internalize the string, converting &#39;.&#39; to &#39;/&#39; in string.
1155   char* p = (char*)str;
1156   while (*p != &#39;\0&#39;) {
1157       if (*p == &#39;.&#39;) {
1158           *p = &#39;/&#39;;
1159       }
1160       p++;
1161   }
1162 
1163   const int str_len = (int)(p - str);
1164   if (str_len &gt; Symbol::max_length()) {
1165     // It&#39;s impossible to create this class;  the name cannot fit
1166     // into the constant pool.
1167     return NULL;
1168   }
1169   TempNewSymbol klass_name = SymbolTable::new_symbol(str, str_len);
1170 
1171   // Security Note:
1172   //   The Java level wrapper will perform the necessary security check allowing
1173   //   us to pass the NULL as the initiating class loader.
1174   Handle h_loader(THREAD, JNIHandles::resolve(loader));
1175   if (UsePerfData) {
1176     is_lock_held_by_thread(h_loader,
1177                            ClassLoader::sync_JVMFindLoadedClassLockFreeCounter(),
1178                            THREAD);
1179   }
1180 
1181   Klass* k = SystemDictionary::find_instance_or_array_klass(klass_name,
1182                                                               h_loader,
1183                                                               Handle(),
1184                                                               CHECK_NULL);
1185 #if INCLUDE_CDS
1186   if (k == NULL) {
1187     // If the class is not already loaded, try to see if it&#39;s in the shared
1188     // archive for the current classloader (h_loader).
1189     k = SystemDictionaryShared::find_or_load_shared_class(klass_name, h_loader, CHECK_NULL);
1190   }
1191 #endif
1192   return (k == NULL) ? NULL :
1193             (jclass) JNIHandles::make_local(env, k-&gt;java_mirror());
1194 JVM_END
1195 
1196 // Module support //////////////////////////////////////////////////////////////////////////////
1197 
1198 JVM_ENTRY(void, JVM_DefineModule(JNIEnv *env, jobject module, jboolean is_open, jstring version,
1199                                  jstring location, jobjectArray packages))
1200   JVMWrapper(&quot;JVM_DefineModule&quot;);
1201   Modules::define_module(module, is_open, version, location, packages, CHECK);
1202 JVM_END
1203 
1204 JVM_ENTRY(void, JVM_SetBootLoaderUnnamedModule(JNIEnv *env, jobject module))
1205   JVMWrapper(&quot;JVM_SetBootLoaderUnnamedModule&quot;);
1206   Modules::set_bootloader_unnamed_module(module, CHECK);
1207 JVM_END
1208 
1209 JVM_ENTRY(void, JVM_AddModuleExports(JNIEnv *env, jobject from_module, jstring package, jobject to_module))
1210   JVMWrapper(&quot;JVM_AddModuleExports&quot;);
1211   Modules::add_module_exports_qualified(from_module, package, to_module, CHECK);
1212 JVM_END
1213 
1214 JVM_ENTRY(void, JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, jstring package))
1215   JVMWrapper(&quot;JVM_AddModuleExportsToAllUnnamed&quot;);
1216   Modules::add_module_exports_to_all_unnamed(from_module, package, CHECK);
1217 JVM_END
1218 
1219 JVM_ENTRY(void, JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, jstring package))
1220   JVMWrapper(&quot;JVM_AddModuleExportsToAll&quot;);
1221   Modules::add_module_exports(from_module, package, NULL, CHECK);
1222 JVM_END
1223 
1224 JVM_ENTRY (void, JVM_AddReadsModule(JNIEnv *env, jobject from_module, jobject source_module))
1225   JVMWrapper(&quot;JVM_AddReadsModule&quot;);
1226   Modules::add_reads_module(from_module, source_module, CHECK);
1227 JVM_END
1228 
1229 // Reflection support //////////////////////////////////////////////////////////////////////////////
1230 
1231 JVM_ENTRY(jstring, JVM_InitClassName(JNIEnv *env, jclass cls))
1232   assert (cls != NULL, &quot;illegal class&quot;);
1233   JVMWrapper(&quot;JVM_InitClassName&quot;);
1234   JvmtiVMObjectAllocEventCollector oam;
1235   ResourceMark rm(THREAD);
1236   HandleMark hm(THREAD);
1237   Handle java_class(THREAD, JNIHandles::resolve(cls));
1238   oop result = java_lang_Class::name(java_class, CHECK_NULL);
1239   return (jstring) JNIHandles::make_local(env, result);
1240 JVM_END
1241 
1242 
1243 JVM_ENTRY(jobjectArray, JVM_GetClassInterfaces(JNIEnv *env, jclass cls))
1244   JVMWrapper(&quot;JVM_GetClassInterfaces&quot;);
1245   JvmtiVMObjectAllocEventCollector oam;
1246   oop mirror = JNIHandles::resolve_non_null(cls);
1247 
1248   // Special handling for primitive objects
1249   if (java_lang_Class::is_primitive(mirror)) {
1250     // Primitive objects does not have any interfaces
1251     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1252     return (jobjectArray) JNIHandles::make_local(env, r);
1253   }
1254 
1255   Klass* klass = java_lang_Class::as_Klass(mirror);
1256   // Figure size of result array
1257   int size;
1258   if (klass-&gt;is_instance_klass()) {
1259     InstanceKlass* ik = InstanceKlass::cast(klass);
1260     size = ik-&gt;local_interfaces()-&gt;length();
1261     if (ik-&gt;has_injected_identityObject()) {
1262       size--;
1263     }
1264   } else {
1265     assert(klass-&gt;is_objArray_klass() || klass-&gt;is_typeArray_klass(), &quot;Illegal mirror klass&quot;);
1266     size = 3;
1267   }
1268 
1269   // Allocate result array
1270   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);
1271   objArrayHandle result (THREAD, r);
1272   // Fill in result
1273   if (klass-&gt;is_instance_klass()) {
1274     // Regular instance klass, fill in all local interfaces
1275     int cursor = 0;
1276     for (int index = 0; index &lt; size; index++) {
1277       InstanceKlass* ik = InstanceKlass::cast(klass);
1278       Klass* k = ik-&gt;local_interfaces()-&gt;at(index);
1279       if (!ik-&gt;has_injected_identityObject() || k != SystemDictionary::IdentityObject_klass()) {
1280         result-&gt;obj_at_put(cursor++, k-&gt;java_mirror());
1281       }
1282     }
1283   } else {
1284     // All arrays implement java.lang.Cloneable, java.io.Serializable and java.lang.IdentityObject
1285     result-&gt;obj_at_put(0, SystemDictionary::Cloneable_klass()-&gt;java_mirror());
1286     result-&gt;obj_at_put(1, SystemDictionary::Serializable_klass()-&gt;java_mirror());
1287     result-&gt;obj_at_put(2, SystemDictionary::IdentityObject_klass()-&gt;java_mirror());
1288   }
1289   return (jobjectArray) JNIHandles::make_local(env, result());
1290 JVM_END
1291 
1292 
1293 JVM_ENTRY(jboolean, JVM_IsInterface(JNIEnv *env, jclass cls))
1294   JVMWrapper(&quot;JVM_IsInterface&quot;);
1295   oop mirror = JNIHandles::resolve_non_null(cls);
1296   if (java_lang_Class::is_primitive(mirror)) {
1297     return JNI_FALSE;
1298   }
1299   Klass* k = java_lang_Class::as_Klass(mirror);
1300   jboolean result = k-&gt;is_interface();
1301   assert(!result || k-&gt;is_instance_klass(),
1302          &quot;all interfaces are instance types&quot;);
1303   // The compiler intrinsic for isInterface tests the
1304   // Klass::_access_flags bits in the same way.
1305   return result;
1306 JVM_END
1307 
1308 JVM_ENTRY(jboolean, JVM_IsHiddenClass(JNIEnv *env, jclass cls))
1309   JVMWrapper(&quot;JVM_IsHiddenClass&quot;);
1310   oop mirror = JNIHandles::resolve_non_null(cls);
1311   if (java_lang_Class::is_primitive(mirror)) {
1312     return JNI_FALSE;
1313   }
1314   Klass* k = java_lang_Class::as_Klass(mirror);
1315   return k-&gt;is_hidden();
1316 JVM_END
1317 
1318 JVM_ENTRY(jobjectArray, JVM_GetClassSigners(JNIEnv *env, jclass cls))
1319   JVMWrapper(&quot;JVM_GetClassSigners&quot;);
1320   JvmtiVMObjectAllocEventCollector oam;
1321   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1322     // There are no signers for primitive types
1323     return NULL;
1324   }
1325 
1326   objArrayHandle signers(THREAD, java_lang_Class::signers(JNIHandles::resolve_non_null(cls)));
1327 
1328   // If there are no signers set in the class, or if the class
1329   // is an array, return NULL.
1330   if (signers == NULL) return NULL;
1331 
1332   // copy of the signers array
1333   Klass* element = ObjArrayKlass::cast(signers-&gt;klass())-&gt;element_klass();
1334   objArrayOop signers_copy = oopFactory::new_objArray(element, signers-&gt;length(), CHECK_NULL);
1335   for (int index = 0; index &lt; signers-&gt;length(); index++) {
1336     signers_copy-&gt;obj_at_put(index, signers-&gt;obj_at(index));
1337   }
1338 
1339   // return the copy
1340   return (jobjectArray) JNIHandles::make_local(env, signers_copy);
1341 JVM_END
1342 
1343 
1344 JVM_ENTRY(void, JVM_SetClassSigners(JNIEnv *env, jclass cls, jobjectArray signers))
1345   JVMWrapper(&quot;JVM_SetClassSigners&quot;);
1346   if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1347     // This call is ignored for primitive types and arrays.
1348     // Signers are only set once, ClassLoader.java, and thus shouldn&#39;t
1349     // be called with an array.  Only the bootstrap loader creates arrays.
1350     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1351     if (k-&gt;is_instance_klass()) {
1352       java_lang_Class::set_signers(k-&gt;java_mirror(), objArrayOop(JNIHandles::resolve(signers)));
1353     }
1354   }
1355 JVM_END
1356 
1357 
1358 JVM_ENTRY(jobject, JVM_GetProtectionDomain(JNIEnv *env, jclass cls))
1359   JVMWrapper(&quot;JVM_GetProtectionDomain&quot;);
1360   if (JNIHandles::resolve(cls) == NULL) {
1361     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);
1362   }
1363 
1364   if (java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1365     // Primitive types does not have a protection domain.
1366     return NULL;
1367   }
1368 
1369   oop pd = java_lang_Class::protection_domain(JNIHandles::resolve(cls));
1370   return (jobject) JNIHandles::make_local(env, pd);
1371 JVM_END
1372 
1373 
1374 // Returns the inherited_access_control_context field of the running thread.
1375 JVM_ENTRY(jobject, JVM_GetInheritedAccessControlContext(JNIEnv *env, jclass cls))
1376   JVMWrapper(&quot;JVM_GetInheritedAccessControlContext&quot;);
1377   oop result = java_lang_Thread::inherited_access_control_context(thread-&gt;threadObj());
1378   return JNIHandles::make_local(env, result);
1379 JVM_END
1380 
1381 class RegisterArrayForGC {
1382  private:
1383   JavaThread *_thread;
1384  public:
1385   RegisterArrayForGC(JavaThread *thread, GrowableArray&lt;oop&gt;* array)  {
1386     _thread = thread;
1387     _thread-&gt;register_array_for_gc(array);
1388   }
1389 
1390   ~RegisterArrayForGC() {
1391     _thread-&gt;register_array_for_gc(NULL);
1392   }
1393 };
1394 
1395 
1396 JVM_ENTRY(jobject, JVM_GetStackAccessControlContext(JNIEnv *env, jclass cls))
1397   JVMWrapper(&quot;JVM_GetStackAccessControlContext&quot;);
1398   if (!UsePrivilegedStack) return NULL;
1399 
1400   ResourceMark rm(THREAD);
1401   GrowableArray&lt;oop&gt;* local_array = new GrowableArray&lt;oop&gt;(12);
1402   JvmtiVMObjectAllocEventCollector oam;
1403 
1404   // count the protection domains on the execution stack. We collapse
1405   // duplicate consecutive protection domains into a single one, as
1406   // well as stopping when we hit a privileged frame.
1407 
1408   oop previous_protection_domain = NULL;
1409   Handle privileged_context(thread, NULL);
1410   bool is_privileged = false;
1411   oop protection_domain = NULL;
1412 
1413   // Iterate through Java frames
1414   vframeStream vfst(thread);
1415   for(; !vfst.at_end(); vfst.next()) {
1416     // get method of frame
1417     Method* method = vfst.method();
1418 
1419     // stop at the first privileged frame
1420     if (method-&gt;method_holder() == SystemDictionary::AccessController_klass() &amp;&amp;
1421       method-&gt;name() == vmSymbols::executePrivileged_name())
1422     {
1423       // this frame is privileged
1424       is_privileged = true;
1425 
1426       javaVFrame *priv = vfst.asJavaVFrame();       // executePrivileged
1427 
1428       StackValueCollection* locals = priv-&gt;locals();
1429       StackValue* ctx_sv = locals-&gt;at(1); // AccessControlContext context
1430       StackValue* clr_sv = locals-&gt;at(2); // Class&lt;?&gt; caller
1431       assert(!ctx_sv-&gt;obj_is_scalar_replaced(), &quot;found scalar-replaced object&quot;);
1432       assert(!clr_sv-&gt;obj_is_scalar_replaced(), &quot;found scalar-replaced object&quot;);
1433       privileged_context    = ctx_sv-&gt;get_obj();
1434       Handle caller         = clr_sv-&gt;get_obj();
1435 
1436       Klass *caller_klass = java_lang_Class::as_Klass(caller());
1437       protection_domain  = caller_klass-&gt;protection_domain();
1438     } else {
1439       protection_domain = method-&gt;method_holder()-&gt;protection_domain();
1440     }
1441 
1442     if ((previous_protection_domain != protection_domain) &amp;&amp; (protection_domain != NULL)) {
1443       local_array-&gt;push(protection_domain);
1444       previous_protection_domain = protection_domain;
1445     }
1446 
1447     if (is_privileged) break;
1448   }
1449 
1450 
1451   // either all the domains on the stack were system domains, or
1452   // we had a privileged system domain
1453   if (local_array-&gt;is_empty()) {
1454     if (is_privileged &amp;&amp; privileged_context.is_null()) return NULL;
1455 
1456     oop result = java_security_AccessControlContext::create(objArrayHandle(), is_privileged, privileged_context, CHECK_NULL);
1457     return JNIHandles::make_local(env, result);
1458   }
1459 
1460   // the resource area must be registered in case of a gc
1461   RegisterArrayForGC ragc(thread, local_array);
1462   objArrayOop context = oopFactory::new_objArray(SystemDictionary::ProtectionDomain_klass(),
1463                                                  local_array-&gt;length(), CHECK_NULL);
1464   objArrayHandle h_context(thread, context);
1465   for (int index = 0; index &lt; local_array-&gt;length(); index++) {
1466     h_context-&gt;obj_at_put(index, local_array-&gt;at(index));
1467   }
1468 
1469   oop result = java_security_AccessControlContext::create(h_context, is_privileged, privileged_context, CHECK_NULL);
1470 
1471   return JNIHandles::make_local(env, result);
1472 JVM_END
1473 
1474 
1475 JVM_ENTRY(jboolean, JVM_IsArrayClass(JNIEnv *env, jclass cls))
1476   JVMWrapper(&quot;JVM_IsArrayClass&quot;);
1477   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1478   return (k != NULL) &amp;&amp; k-&gt;is_array_klass() ? true : false;
1479 JVM_END
1480 
1481 
1482 JVM_ENTRY(jboolean, JVM_IsPrimitiveClass(JNIEnv *env, jclass cls))
1483   JVMWrapper(&quot;JVM_IsPrimitiveClass&quot;);
1484   oop mirror = JNIHandles::resolve_non_null(cls);
1485   return (jboolean) java_lang_Class::is_primitive(mirror);
1486 JVM_END
1487 
1488 
1489 JVM_ENTRY(jint, JVM_GetClassModifiers(JNIEnv *env, jclass cls))
1490   JVMWrapper(&quot;JVM_GetClassModifiers&quot;);
1491   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
1492     // Primitive type
1493     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
1494   }
1495 
1496   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1497   debug_only(int computed_modifiers = k-&gt;compute_modifier_flags(CHECK_0));
1498   assert(k-&gt;modifier_flags() == computed_modifiers, &quot;modifiers cache is OK&quot;);
1499   return k-&gt;modifier_flags();
1500 JVM_END
1501 
1502 
1503 // Inner class reflection ///////////////////////////////////////////////////////////////////////////////
1504 
1505 JVM_ENTRY(jobjectArray, JVM_GetDeclaredClasses(JNIEnv *env, jclass ofClass))
1506   JvmtiVMObjectAllocEventCollector oam;
1507   // ofClass is a reference to a java_lang_Class object. The mirror object
1508   // of an InstanceKlass
1509 
1510   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1511       ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_instance_klass()) {
1512     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1513     return (jobjectArray)JNIHandles::make_local(env, result);
1514   }
1515 
1516   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1517   InnerClassesIterator iter(k);
1518 
1519   if (iter.length() == 0) {
1520     // Neither an inner nor outer class
1521     oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);
1522     return (jobjectArray)JNIHandles::make_local(env, result);
1523   }
1524 
1525   // find inner class info
1526   constantPoolHandle cp(thread, k-&gt;constants());
1527   int length = iter.length();
1528 
1529   // Allocate temp. result array
1530   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), length/4, CHECK_NULL);
1531   objArrayHandle result (THREAD, r);
1532   int members = 0;
1533 
1534   for (; !iter.done(); iter.next()) {
1535     int ioff = iter.inner_class_info_index();
1536     int ooff = iter.outer_class_info_index();
1537 
1538     if (ioff != 0 &amp;&amp; ooff != 0) {
1539       // Check to see if the name matches the class we&#39;re looking for
1540       // before attempting to find the class.
1541       if (cp-&gt;klass_name_at_matches(k, ooff)) {
1542         Klass* outer_klass = cp-&gt;klass_at(ooff, CHECK_NULL);
1543         if (outer_klass == k) {
1544            Klass* ik = cp-&gt;klass_at(ioff, CHECK_NULL);
1545            InstanceKlass* inner_klass = InstanceKlass::cast(ik);
1546 
1547            // Throws an exception if outer klass has not declared k as
1548            // an inner klass
1549            Reflection::check_for_inner_class(k, inner_klass, true, CHECK_NULL);
1550 
1551            result-&gt;obj_at_put(members, inner_klass-&gt;java_mirror());
1552            members++;
1553         }
1554       }
1555     }
1556   }
1557 
1558   if (members != length) {
1559     // Return array of right length
1560     objArrayOop res = oopFactory::new_objArray(SystemDictionary::Class_klass(), members, CHECK_NULL);
1561     for(int i = 0; i &lt; members; i++) {
1562       res-&gt;obj_at_put(i, result-&gt;obj_at(i));
1563     }
1564     return (jobjectArray)JNIHandles::make_local(env, res);
1565   }
1566 
1567   return (jobjectArray)JNIHandles::make_local(env, result());
1568 JVM_END
1569 
1570 
1571 JVM_ENTRY(jclass, JVM_GetDeclaringClass(JNIEnv *env, jclass ofClass))
1572 {
1573   // ofClass is a reference to a java_lang_Class object.
1574   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1575       ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_instance_klass()) {
1576     return NULL;
1577   }
1578 
1579   bool inner_is_member = false;
1580   Klass* outer_klass
1581     = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))
1582                           )-&gt;compute_enclosing_class(&amp;inner_is_member, CHECK_NULL);
1583   if (outer_klass == NULL)  return NULL;  // already a top-level class
1584   if (!inner_is_member)  return NULL;     // a hidden or unsafe anonymous class (inside a method)
1585   return (jclass) JNIHandles::make_local(env, outer_klass-&gt;java_mirror());
1586 }
1587 JVM_END
1588 
1589 JVM_ENTRY(jstring, JVM_GetSimpleBinaryName(JNIEnv *env, jclass cls))
1590 {
1591   oop mirror = JNIHandles::resolve_non_null(cls);
1592   if (java_lang_Class::is_primitive(mirror) ||
1593       !java_lang_Class::as_Klass(mirror)-&gt;is_instance_klass()) {
1594     return NULL;
1595   }
1596   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));
1597   int ooff = 0, noff = 0;
1598   if (k-&gt;find_inner_classes_attr(&amp;ooff, &amp;noff, THREAD)) {
1599     if (noff != 0) {
1600       constantPoolHandle i_cp(thread, k-&gt;constants());
1601       Symbol* name = i_cp-&gt;symbol_at(noff);
1602       Handle str = java_lang_String::create_from_symbol(name, CHECK_NULL);
1603       return (jstring) JNIHandles::make_local(env, str());
1604     }
1605   }
1606   return NULL;
1607 }
1608 JVM_END
1609 
1610 JVM_ENTRY(jstring, JVM_GetClassSignature(JNIEnv *env, jclass cls))
1611   assert (cls != NULL, &quot;illegal class&quot;);
1612   JVMWrapper(&quot;JVM_GetClassSignature&quot;);
1613   JvmtiVMObjectAllocEventCollector oam;
1614   ResourceMark rm(THREAD);
1615   // Return null for arrays and primatives
1616   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1617     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1618     if (k-&gt;is_instance_klass()) {
1619       Symbol* sym = InstanceKlass::cast(k)-&gt;generic_signature();
1620       if (sym == NULL) return NULL;
1621       Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
1622       return (jstring) JNIHandles::make_local(env, str());
1623     }
1624   }
1625   return NULL;
1626 JVM_END
1627 
1628 
1629 JVM_ENTRY(jbyteArray, JVM_GetClassAnnotations(JNIEnv *env, jclass cls))
1630   assert (cls != NULL, &quot;illegal class&quot;);
1631   JVMWrapper(&quot;JVM_GetClassAnnotations&quot;);
1632 
1633   // Return null for arrays and primitives
1634   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1635     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1636     if (k-&gt;is_instance_klass()) {
1637       typeArrayOop a = Annotations::make_java_array(InstanceKlass::cast(k)-&gt;class_annotations(), CHECK_NULL);
1638       return (jbyteArray) JNIHandles::make_local(env, a);
1639     }
1640   }
1641   return NULL;
1642 JVM_END
1643 
1644 
1645 static bool jvm_get_field_common(jobject field, fieldDescriptor&amp; fd, TRAPS) {
1646   // some of this code was adapted from from jni_FromReflectedField
1647 
1648   oop reflected = JNIHandles::resolve_non_null(field);
1649   oop mirror    = java_lang_reflect_Field::clazz(reflected);
1650   Klass* k    = java_lang_Class::as_Klass(mirror);
1651   int slot      = java_lang_reflect_Field::slot(reflected);
1652   int modifiers = java_lang_reflect_Field::modifiers(reflected);
1653 
1654   InstanceKlass* ik = InstanceKlass::cast(k);
1655   intptr_t offset = ik-&gt;field_offset(slot);
1656 
1657   if (modifiers &amp; JVM_ACC_STATIC) {
1658     // for static fields we only look in the current class
1659     if (!ik-&gt;find_local_field_from_offset(offset, true, &amp;fd)) {
1660       assert(false, &quot;cannot find static field&quot;);
1661       return false;
1662     }
1663   } else {
1664     // for instance fields we start with the current class and work
1665     // our way up through the superclass chain
1666     if (!ik-&gt;find_field_from_offset(offset, false, &amp;fd)) {
1667       assert(false, &quot;cannot find instance field&quot;);
1668       return false;
1669     }
1670   }
1671   return true;
1672 }
1673 
1674 static Method* jvm_get_method_common(jobject method) {
1675   // some of this code was adapted from from jni_FromReflectedMethod
1676 
1677   oop reflected = JNIHandles::resolve_non_null(method);
1678   oop mirror    = NULL;
1679   int slot      = 0;
1680 
1681   if (reflected-&gt;klass() == SystemDictionary::reflect_Constructor_klass()) {
1682     mirror = java_lang_reflect_Constructor::clazz(reflected);
1683     slot   = java_lang_reflect_Constructor::slot(reflected);
1684   } else {
1685     assert(reflected-&gt;klass() == SystemDictionary::reflect_Method_klass(),
1686            &quot;wrong type&quot;);
1687     mirror = java_lang_reflect_Method::clazz(reflected);
1688     slot   = java_lang_reflect_Method::slot(reflected);
1689   }
1690   Klass* k = java_lang_Class::as_Klass(mirror);
1691 
1692   Method* m = InstanceKlass::cast(k)-&gt;method_with_idnum(slot);
1693   assert(m != NULL, &quot;cannot find method&quot;);
1694   return m;  // caller has to deal with NULL in product mode
1695 }
1696 
1697 /* Type use annotations support (JDK 1.8) */
1698 
1699 JVM_ENTRY(jbyteArray, JVM_GetClassTypeAnnotations(JNIEnv *env, jclass cls))
1700   assert (cls != NULL, &quot;illegal class&quot;);
1701   JVMWrapper(&quot;JVM_GetClassTypeAnnotations&quot;);
1702   ResourceMark rm(THREAD);
1703   // Return null for arrays and primitives
1704   if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {
1705     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
1706     if (k-&gt;is_instance_klass()) {
1707       AnnotationArray* type_annotations = InstanceKlass::cast(k)-&gt;class_type_annotations();
1708       if (type_annotations != NULL) {
1709         typeArrayOop a = Annotations::make_java_array(type_annotations, CHECK_NULL);
1710         return (jbyteArray) JNIHandles::make_local(env, a);
1711       }
1712     }
1713   }
1714   return NULL;
1715 JVM_END
1716 
1717 JVM_ENTRY(jbyteArray, JVM_GetMethodTypeAnnotations(JNIEnv *env, jobject method))
1718   assert (method != NULL, &quot;illegal method&quot;);
1719   JVMWrapper(&quot;JVM_GetMethodTypeAnnotations&quot;);
1720 
1721   // method is a handle to a java.lang.reflect.Method object
1722   Method* m = jvm_get_method_common(method);
1723   if (m == NULL) {
1724     return NULL;
1725   }
1726 
1727   AnnotationArray* type_annotations = m-&gt;type_annotations();
1728   if (type_annotations != NULL) {
1729     typeArrayOop a = Annotations::make_java_array(type_annotations, CHECK_NULL);
1730     return (jbyteArray) JNIHandles::make_local(env, a);
1731   }
1732 
1733   return NULL;
1734 JVM_END
1735 
1736 JVM_ENTRY(jbyteArray, JVM_GetFieldTypeAnnotations(JNIEnv *env, jobject field))
1737   assert (field != NULL, &quot;illegal field&quot;);
1738   JVMWrapper(&quot;JVM_GetFieldTypeAnnotations&quot;);
1739 
1740   fieldDescriptor fd;
1741   bool gotFd = jvm_get_field_common(field, fd, CHECK_NULL);
1742   if (!gotFd) {
1743     return NULL;
1744   }
1745 
1746   return (jbyteArray) JNIHandles::make_local(env, Annotations::make_java_array(fd.type_annotations(), THREAD));
1747 JVM_END
1748 
1749 static void bounds_check(const constantPoolHandle&amp; cp, jint index, TRAPS) {
1750   if (!cp-&gt;is_within_bounds(index)) {
1751     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;Constant pool index out of bounds&quot;);
1752   }
1753 }
1754 
1755 JVM_ENTRY(jobjectArray, JVM_GetMethodParameters(JNIEnv *env, jobject method))
1756 {
1757   JVMWrapper(&quot;JVM_GetMethodParameters&quot;);
1758   // method is a handle to a java.lang.reflect.Method object
1759   Method* method_ptr = jvm_get_method_common(method);
1760   methodHandle mh (THREAD, method_ptr);
1761   Handle reflected_method (THREAD, JNIHandles::resolve_non_null(method));
1762   const int num_params = mh-&gt;method_parameters_length();
1763 
1764   if (num_params &lt; 0) {
1765     // A -1 return value from method_parameters_length means there is no
1766     // parameter data.  Return null to indicate this to the reflection
1767     // API.
1768     assert(num_params == -1, &quot;num_params should be -1 if it is less than zero&quot;);
1769     return (jobjectArray)NULL;
1770   } else {
1771     // Otherwise, we return something up to reflection, even if it is
1772     // a zero-length array.  Why?  Because in some cases this can
1773     // trigger a MalformedParametersException.
1774 
1775     // make sure all the symbols are properly formatted
1776     for (int i = 0; i &lt; num_params; i++) {
1777       MethodParametersElement* params = mh-&gt;method_parameters_start();
1778       int index = params[i].name_cp_index;
1779       constantPoolHandle cp(THREAD, mh-&gt;constants());
1780       bounds_check(cp, index, CHECK_NULL);
1781 
1782       if (0 != index &amp;&amp; !mh-&gt;constants()-&gt;tag_at(index).is_utf8()) {
1783         THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1784                     &quot;Wrong type at constant pool index&quot;);
1785       }
1786 
1787     }
1788 
1789     objArrayOop result_oop = oopFactory::new_objArray(SystemDictionary::reflect_Parameter_klass(), num_params, CHECK_NULL);
1790     objArrayHandle result (THREAD, result_oop);
1791 
1792     for (int i = 0; i &lt; num_params; i++) {
1793       MethodParametersElement* params = mh-&gt;method_parameters_start();
1794       // For a 0 index, give a NULL symbol
1795       Symbol* sym = 0 != params[i].name_cp_index ?
1796         mh-&gt;constants()-&gt;symbol_at(params[i].name_cp_index) : NULL;
1797       int flags = params[i].flags;
1798       oop param = Reflection::new_parameter(reflected_method, i, sym,
1799                                             flags, CHECK_NULL);
1800       result-&gt;obj_at_put(i, param);
1801     }
1802     return (jobjectArray)JNIHandles::make_local(env, result());
1803   }
1804 }
1805 JVM_END
1806 
1807 // New (JDK 1.4) reflection implementation /////////////////////////////////////
1808 
1809 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredFields(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1810 {
1811   JVMWrapper(&quot;JVM_GetClassDeclaredFields&quot;);
1812   JvmtiVMObjectAllocEventCollector oam;
1813 
1814   // Exclude primitive types and array types
1815   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||
1816       java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1817     // Return empty array
1818     oop res = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), 0, CHECK_NULL);
1819     return (jobjectArray) JNIHandles::make_local(env, res);
1820   }
1821 
1822   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1823   constantPoolHandle cp(THREAD, k-&gt;constants());
1824 
1825   // Ensure class is linked
1826   k-&gt;link_class(CHECK_NULL);
1827 
1828   // Allocate result
1829   int num_fields;
1830 
1831   if (publicOnly) {
1832     num_fields = 0;
1833     for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1834       if (fs.access_flags().is_public()) ++num_fields;
1835     }
1836   } else {
1837     num_fields = k-&gt;java_fields_count();
1838   }
1839 
1840   objArrayOop r = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), num_fields, CHECK_NULL);
1841   objArrayHandle result (THREAD, r);
1842 
1843   int out_idx = 0;
1844   fieldDescriptor fd;
1845   for (JavaFieldStream fs(k); !fs.done(); fs.next()) {
1846     if (!publicOnly || fs.access_flags().is_public()) {
1847       fd.reinitialize(k, fs.index());
1848       oop field = Reflection::new_field(&amp;fd, CHECK_NULL);
1849       result-&gt;obj_at_put(out_idx, field);
1850       ++out_idx;
1851     }
1852   }
1853   assert(out_idx == num_fields, &quot;just checking&quot;);
1854   return (jobjectArray) JNIHandles::make_local(env, result());
1855 }
1856 JVM_END
1857 
1858 JVM_ENTRY(jboolean, JVM_IsRecord(JNIEnv *env, jclass cls))
1859 {
1860   JVMWrapper(&quot;JVM_IsRecord&quot;);
1861   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
1862   if (k != NULL &amp;&amp; k-&gt;is_instance_klass()) {
1863     InstanceKlass* ik = InstanceKlass::cast(k);
1864     return ik-&gt;is_record();
1865   } else {
1866     return false;
1867   }
1868 }
1869 JVM_END
1870 
1871 JVM_ENTRY(jobjectArray, JVM_GetRecordComponents(JNIEnv* env, jclass ofClass))
1872 {
1873   JVMWrapper(&quot;JVM_GetRecordComponents&quot;);
1874   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass));
1875   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
1876   InstanceKlass* ik = InstanceKlass::cast(c);
1877 
1878   if (ik-&gt;is_record()) {
1879     Array&lt;RecordComponent*&gt;* components = ik-&gt;record_components();
1880     assert(components != NULL, &quot;components should not be NULL&quot;);
1881     {
1882       JvmtiVMObjectAllocEventCollector oam;
1883       constantPoolHandle cp(THREAD, ik-&gt;constants());
1884       int length = components-&gt;length();
1885       assert(length &gt;= 0, &quot;unexpected record_components length&quot;);
1886       objArrayOop record_components =
1887         oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);
1888       objArrayHandle components_h (THREAD, record_components);
1889 
1890       for (int x = 0; x &lt; length; x++) {
1891         RecordComponent* component = components-&gt;at(x);
1892         assert(component != NULL, &quot;unexpected NULL record component&quot;);
1893         oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);
1894         components_h-&gt;obj_at_put(x, component_oop);
1895       }
1896       return (jobjectArray)JNIHandles::make_local(components_h());
1897     }
1898   }
1899 
1900   // Return empty array if ofClass is not a record.
1901   objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);
1902   return (jobjectArray)JNIHandles::make_local(env, result);
1903 }
1904 JVM_END
1905 
1906 static bool select_method(const methodHandle&amp; method, bool want_constructor) {
1907   bool is_ctor = (method-&gt;is_object_constructor() ||
1908                   method-&gt;is_static_init_factory());
1909   if (want_constructor) {
1910     return is_ctor;
1911   } else {
1912     return (!is_ctor &amp;&amp;
1913             !method-&gt;is_class_initializer() &amp;&amp;
1914             !method-&gt;is_overpass());
1915   }
1916 }
1917 
1918 static jobjectArray get_class_declared_methods_helper(
1919                                   JNIEnv *env,
1920                                   jclass ofClass, jboolean publicOnly,
1921                                   bool want_constructor,
1922                                   Klass* klass, TRAPS) {
1923 
1924   JvmtiVMObjectAllocEventCollector oam;
1925 
1926   // Exclude primitive types and array types
1927   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))
1928       || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))-&gt;is_array_klass()) {
1929     // Return empty array
1930     oop res = oopFactory::new_objArray(klass, 0, CHECK_NULL);
1931     return (jobjectArray) JNIHandles::make_local(env, res);
1932   }
1933 
1934   InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));
1935 
1936   // Ensure class is linked
1937   k-&gt;link_class(CHECK_NULL);
1938 
1939   Array&lt;Method*&gt;* methods = k-&gt;methods();
1940   int methods_length = methods-&gt;length();
1941 
1942   // Save original method_idnum in case of redefinition, which can change
1943   // the idnum of obsolete methods.  The new method will have the same idnum
1944   // but if we refresh the methods array, the counts will be wrong.
1945   ResourceMark rm(THREAD);
1946   GrowableArray&lt;int&gt;* idnums = new GrowableArray&lt;int&gt;(methods_length);
1947   int num_methods = 0;
1948 
1949   for (int i = 0; i &lt; methods_length; i++) {
1950     methodHandle method(THREAD, methods-&gt;at(i));
1951     if (select_method(method, want_constructor)) {
1952       if (!publicOnly || method-&gt;is_public()) {
1953         idnums-&gt;push(method-&gt;method_idnum());
1954         ++num_methods;
1955       }
1956     }
1957   }
1958 
1959   // Allocate result
1960   objArrayOop r = oopFactory::new_objArray(klass, num_methods, CHECK_NULL);
1961   objArrayHandle result (THREAD, r);
1962 
1963   // Now just put the methods that we selected above, but go by their idnum
1964   // in case of redefinition.  The methods can be redefined at any safepoint,
1965   // so above when allocating the oop array and below when creating reflect
1966   // objects.
1967   for (int i = 0; i &lt; num_methods; i++) {
1968     methodHandle method(THREAD, k-&gt;method_with_idnum(idnums-&gt;at(i)));
1969     if (method.is_null()) {
1970       // Method may have been deleted and seems this API can handle null
1971       // Otherwise should probably put a method that throws NSME
1972       result-&gt;obj_at_put(i, NULL);
1973     } else {
1974       oop m;
1975       if (want_constructor) {
1976         assert(method-&gt;is_object_constructor() ||
1977                method-&gt;is_static_init_factory(), &quot;must be&quot;);
1978         m = Reflection::new_constructor(method, CHECK_NULL);
1979       } else {
1980         m = Reflection::new_method(method, false, CHECK_NULL);
1981       }
1982       result-&gt;obj_at_put(i, m);
1983     }
1984   }
1985 
1986   return (jobjectArray) JNIHandles::make_local(env, result());
1987 }
1988 
1989 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredMethods(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1990 {
1991   JVMWrapper(&quot;JVM_GetClassDeclaredMethods&quot;);
1992   return get_class_declared_methods_helper(env, ofClass, publicOnly,
1993                                            /*want_constructor*/ false,
1994                                            SystemDictionary::reflect_Method_klass(), THREAD);
1995 }
1996 JVM_END
1997 
1998 JVM_ENTRY(jobjectArray, JVM_GetClassDeclaredConstructors(JNIEnv *env, jclass ofClass, jboolean publicOnly))
1999 {
2000   JVMWrapper(&quot;JVM_GetClassDeclaredConstructors&quot;);
2001   return get_class_declared_methods_helper(env, ofClass, publicOnly,
2002                                            /*want_constructor*/ true,
2003                                            SystemDictionary::reflect_Constructor_klass(), THREAD);
2004 }
2005 JVM_END
2006 
2007 JVM_ENTRY(jint, JVM_GetClassAccessFlags(JNIEnv *env, jclass cls))
2008 {
2009   JVMWrapper(&quot;JVM_GetClassAccessFlags&quot;);
2010   if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
2011     // Primitive type
2012     return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;
2013   }
2014 
2015   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2016   return k-&gt;access_flags().as_int() &amp; JVM_ACC_WRITTEN_FLAGS;
2017 }
2018 JVM_END
2019 
2020 JVM_ENTRY(jboolean, JVM_AreNestMates(JNIEnv *env, jclass current, jclass member))
2021 {
2022   JVMWrapper(&quot;JVM_AreNestMates&quot;);
2023   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
2024   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2025   InstanceKlass* ck = InstanceKlass::cast(c);
2026   Klass* m = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(member));
2027   assert(m-&gt;is_instance_klass(), &quot;must be&quot;);
2028   InstanceKlass* mk = InstanceKlass::cast(m);
2029   return ck-&gt;has_nestmate_access_to(mk, THREAD);
2030 }
2031 JVM_END
2032 
2033 JVM_ENTRY(jclass, JVM_GetNestHost(JNIEnv* env, jclass current))
2034 {
2035   // current is not a primitive or array class
2036   JVMWrapper(&quot;JVM_GetNestHost&quot;);
2037   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
2038   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2039   InstanceKlass* ck = InstanceKlass::cast(c);
2040   InstanceKlass* host = ck-&gt;nest_host(THREAD);
2041   return (jclass) (host == NULL ? NULL :
2042                    JNIHandles::make_local(THREAD, host-&gt;java_mirror()));
2043 }
2044 JVM_END
2045 
2046 JVM_ENTRY(jobjectArray, JVM_GetNestMembers(JNIEnv* env, jclass current))
2047 {
2048   // current is not a primitive or array class
2049   JVMWrapper(&quot;JVM_GetNestMembers&quot;);
2050   ResourceMark rm(THREAD);
2051   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
2052   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2053   InstanceKlass* ck = InstanceKlass::cast(c);
2054   InstanceKlass* host = ck-&gt;nest_host(THREAD);
2055 
2056   log_trace(class, nestmates)(&quot;Calling GetNestMembers for type %s with nest-host %s&quot;,
2057                               ck-&gt;external_name(), host-&gt;external_name());
2058   {
2059     JvmtiVMObjectAllocEventCollector oam;
2060     Array&lt;u2&gt;* members = host-&gt;nest_members();
2061     int length = members == NULL ? 0 : members-&gt;length();
2062 
2063     log_trace(class, nestmates)(&quot; - host has %d listed nest members&quot;, length);
2064 
2065     // nest host is first in the array so make it one bigger
2066     objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(),
2067                                              length + 1, CHECK_NULL);
2068     objArrayHandle result(THREAD, r);
2069     result-&gt;obj_at_put(0, host-&gt;java_mirror());
2070     if (length != 0) {
2071       int count = 0;
2072       for (int i = 0; i &lt; length; i++) {
2073         int cp_index = members-&gt;at(i);
2074         Klass* k = host-&gt;constants()-&gt;klass_at(cp_index, THREAD);
2075         if (HAS_PENDING_EXCEPTION) {
2076           if (PENDING_EXCEPTION-&gt;is_a(SystemDictionary::VirtualMachineError_klass())) {
2077             return NULL; // propagate VMEs
2078           }
2079           if (log_is_enabled(Trace, class, nestmates)) {
2080             stringStream ss;
2081             char* target_member_class = host-&gt;constants()-&gt;klass_name_at(cp_index)-&gt;as_C_string();
2082             ss.print(&quot; - resolution of nest member %s failed: &quot;, target_member_class);
2083             java_lang_Throwable::print(PENDING_EXCEPTION, &amp;ss);
2084             log_trace(class, nestmates)(&quot;%s&quot;, ss.as_string());
2085           }
2086           CLEAR_PENDING_EXCEPTION;
2087           continue;
2088         }
2089         if (k-&gt;is_instance_klass()) {
2090           InstanceKlass* ik = InstanceKlass::cast(k);
2091           InstanceKlass* nest_host_k = ik-&gt;nest_host(CHECK_NULL);
2092           if (nest_host_k == host) {
2093             result-&gt;obj_at_put(count+1, k-&gt;java_mirror());
2094             count++;
2095             log_trace(class, nestmates)(&quot; - [%d] = %s&quot;, count, ik-&gt;external_name());
2096           } else {
2097             log_trace(class, nestmates)(&quot; - skipping member %s with different host %s&quot;,
2098                                         ik-&gt;external_name(), nest_host_k-&gt;external_name());
2099           }
2100         } else {
2101           log_trace(class, nestmates)(&quot; - skipping member %s that is not an instance class&quot;,
2102                                       k-&gt;external_name());
2103         }
2104       }
2105       if (count &lt; length) {
2106         // we had invalid entries so we need to compact the array
2107         log_trace(class, nestmates)(&quot; - compacting array from length %d to %d&quot;,
2108                                     length + 1, count + 1);
2109 
2110         objArrayOop r2 = oopFactory::new_objArray(SystemDictionary::Class_klass(),
2111                                                   count + 1, CHECK_NULL);
2112         objArrayHandle result2(THREAD, r2);
2113         for (int i = 0; i &lt; count + 1; i++) {
2114           result2-&gt;obj_at_put(i, result-&gt;obj_at(i));
2115         }
2116         return (jobjectArray)JNIHandles::make_local(THREAD, result2());
2117       }
2118     }
2119     else {
2120       assert(host == ck || ck-&gt;is_hidden(), &quot;must be singleton nest or dynamic nestmate&quot;);
2121     }
2122     return (jobjectArray)JNIHandles::make_local(THREAD, result());
2123   }
2124 }
2125 JVM_END
2126 
2127 JVM_ENTRY(jobjectArray, JVM_GetPermittedSubclasses(JNIEnv* env, jclass current))
2128 {
2129   JVMWrapper(&quot;JVM_GetPermittedSubclasses&quot;);
2130   assert(!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(current)), &quot;should not be&quot;);
2131   Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));
2132   assert(c-&gt;is_instance_klass(), &quot;must be&quot;);
2133   InstanceKlass* ik = InstanceKlass::cast(c);
2134   {
2135     JvmtiVMObjectAllocEventCollector oam;
2136     Array&lt;u2&gt;* subclasses = ik-&gt;permitted_subclasses();
2137     int length = subclasses == NULL ? 0 : subclasses-&gt;length();
2138     objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),
2139                                              length, CHECK_NULL);
2140     objArrayHandle result(THREAD, r);
2141     for (int i = 0; i &lt; length; i++) {
2142       int cp_index = subclasses-&gt;at(i);
2143       // This returns &lt;package-name&gt;/&lt;class-name&gt;.
2144       Symbol* klass_name = ik-&gt;constants()-&gt;klass_name_at(cp_index);
2145       assert(klass_name != NULL, &quot;Unexpected null klass_name&quot;);
2146       Handle perm_subtype_h = java_lang_String::create_from_symbol(klass_name, CHECK_NULL);
2147       result-&gt;obj_at_put(i, perm_subtype_h());
2148     }
2149     return (jobjectArray)JNIHandles::make_local(THREAD, result());
2150   }
2151 }
2152 JVM_END
2153 
2154 // Constant pool access //////////////////////////////////////////////////////////
2155 
2156 JVM_ENTRY(jobject, JVM_GetClassConstantPool(JNIEnv *env, jclass cls))
2157 {
2158   JVMWrapper(&quot;JVM_GetClassConstantPool&quot;);
2159   JvmtiVMObjectAllocEventCollector oam;
2160 
2161   // Return null for primitives and arrays
2162   if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {
2163     Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2164     if (k-&gt;is_instance_klass()) {
2165       InstanceKlass* k_h = InstanceKlass::cast(k);
2166       Handle jcp = reflect_ConstantPool::create(CHECK_NULL);
2167       reflect_ConstantPool::set_cp(jcp(), k_h-&gt;constants());
2168       return JNIHandles::make_local(jcp());
2169     }
2170   }
2171   return NULL;
2172 }
2173 JVM_END
2174 
2175 
2176 JVM_ENTRY(jint, JVM_ConstantPoolGetSize(JNIEnv *env, jobject obj, jobject unused))
2177 {
2178   JVMWrapper(&quot;JVM_ConstantPoolGetSize&quot;);
2179   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2180   return cp-&gt;length();
2181 }
2182 JVM_END
2183 
2184 
2185 JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2186 {
2187   JVMWrapper(&quot;JVM_ConstantPoolGetClassAt&quot;);
2188   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2189   bounds_check(cp, index, CHECK_NULL);
2190   constantTag tag = cp-&gt;tag_at(index);
2191   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
2192     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2193   }
2194   Klass* k = cp-&gt;klass_at(index, CHECK_NULL);
2195   return (jclass) JNIHandles::make_local(k-&gt;java_mirror());
2196 }
2197 JVM_END
2198 
2199 JVM_ENTRY(jclass, JVM_ConstantPoolGetClassAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2200 {
2201   JVMWrapper(&quot;JVM_ConstantPoolGetClassAtIfLoaded&quot;);
2202   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2203   bounds_check(cp, index, CHECK_NULL);
2204   constantTag tag = cp-&gt;tag_at(index);
2205   if (!tag.is_klass() &amp;&amp; !tag.is_unresolved_klass()) {
2206     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2207   }
2208   Klass* k = ConstantPool::klass_at_if_loaded(cp, index);
2209   if (k == NULL) return NULL;
2210   return (jclass) JNIHandles::make_local(k-&gt;java_mirror());
2211 }
2212 JVM_END
2213 
2214 static jobject get_method_at_helper(const constantPoolHandle&amp; cp, jint index, bool force_resolution, TRAPS) {
2215   constantTag tag = cp-&gt;tag_at(index);
2216   if (!tag.is_method() &amp;&amp; !tag.is_interface_method()) {
2217     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2218   }
2219   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2220   Klass* k_o;
2221   if (force_resolution) {
2222     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2223   } else {
2224     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2225     if (k_o == NULL) return NULL;
2226   }
2227   InstanceKlass* k = InstanceKlass::cast(k_o);
2228   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2229   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2230   methodHandle m (THREAD, k-&gt;find_method(name, sig));
2231   if (m.is_null()) {
2232     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up method in target class&quot;);
2233   }
2234   oop method;
2235   if (m-&gt;is_object_constructor()) {
2236     method = Reflection::new_constructor(m, CHECK_NULL);
2237   } else {
2238     method = Reflection::new_method(m, true, CHECK_NULL);
2239   }
2240   return JNIHandles::make_local(method);
2241 }
2242 
2243 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2244 {
2245   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAt&quot;);
2246   JvmtiVMObjectAllocEventCollector oam;
2247   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2248   bounds_check(cp, index, CHECK_NULL);
2249   jobject res = get_method_at_helper(cp, index, true, CHECK_NULL);
2250   return res;
2251 }
2252 JVM_END
2253 
2254 JVM_ENTRY(jobject, JVM_ConstantPoolGetMethodAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2255 {
2256   JVMWrapper(&quot;JVM_ConstantPoolGetMethodAtIfLoaded&quot;);
2257   JvmtiVMObjectAllocEventCollector oam;
2258   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2259   bounds_check(cp, index, CHECK_NULL);
2260   jobject res = get_method_at_helper(cp, index, false, CHECK_NULL);
2261   return res;
2262 }
2263 JVM_END
2264 
2265 static jobject get_field_at_helper(constantPoolHandle cp, jint index, bool force_resolution, TRAPS) {
2266   constantTag tag = cp-&gt;tag_at(index);
2267   if (!tag.is_field()) {
2268     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2269   }
2270   int klass_ref  = cp-&gt;uncached_klass_ref_index_at(index);
2271   Klass* k_o;
2272   if (force_resolution) {
2273     k_o = cp-&gt;klass_at(klass_ref, CHECK_NULL);
2274   } else {
2275     k_o = ConstantPool::klass_at_if_loaded(cp, klass_ref);
2276     if (k_o == NULL) return NULL;
2277   }
2278   InstanceKlass* k = InstanceKlass::cast(k_o);
2279   Symbol* name = cp-&gt;uncached_name_ref_at(index);
2280   Symbol* sig  = cp-&gt;uncached_signature_ref_at(index);
2281   fieldDescriptor fd;
2282   Klass* target_klass = k-&gt;find_field(name, sig, &amp;fd);
2283   if (target_klass == NULL) {
2284     THROW_MSG_0(vmSymbols::java_lang_RuntimeException(), &quot;Unable to look up field in target class&quot;);
2285   }
2286   oop field = Reflection::new_field(&amp;fd, CHECK_NULL);
2287   return JNIHandles::make_local(field);
2288 }
2289 
2290 JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAt(JNIEnv *env, jobject obj, jobject unusedl, jint index))
2291 {
2292   JVMWrapper(&quot;JVM_ConstantPoolGetFieldAt&quot;);
2293   JvmtiVMObjectAllocEventCollector oam;
2294   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2295   bounds_check(cp, index, CHECK_NULL);
2296   jobject res = get_field_at_helper(cp, index, true, CHECK_NULL);
2297   return res;
2298 }
2299 JVM_END
2300 
2301 JVM_ENTRY(jobject, JVM_ConstantPoolGetFieldAtIfLoaded(JNIEnv *env, jobject obj, jobject unused, jint index))
2302 {
2303   JVMWrapper(&quot;JVM_ConstantPoolGetFieldAtIfLoaded&quot;);
2304   JvmtiVMObjectAllocEventCollector oam;
2305   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2306   bounds_check(cp, index, CHECK_NULL);
2307   jobject res = get_field_at_helper(cp, index, false, CHECK_NULL);
2308   return res;
2309 }
2310 JVM_END
2311 
2312 JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetMemberRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2313 {
2314   JVMWrapper(&quot;JVM_ConstantPoolGetMemberRefInfoAt&quot;);
2315   JvmtiVMObjectAllocEventCollector oam;
2316   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2317   bounds_check(cp, index, CHECK_NULL);
2318   constantTag tag = cp-&gt;tag_at(index);
2319   if (!tag.is_field_or_method()) {
2320     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2321   }
2322   int klass_ref = cp-&gt;uncached_klass_ref_index_at(index);
2323   Symbol*  klass_name  = cp-&gt;klass_name_at(klass_ref);
2324   Symbol*  member_name = cp-&gt;uncached_name_ref_at(index);
2325   Symbol*  member_sig  = cp-&gt;uncached_signature_ref_at(index);
2326   objArrayOop  dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 3, CHECK_NULL);
2327   objArrayHandle dest(THREAD, dest_o);
2328   Handle str = java_lang_String::create_from_symbol(klass_name, CHECK_NULL);
2329   dest-&gt;obj_at_put(0, str());
2330   str = java_lang_String::create_from_symbol(member_name, CHECK_NULL);
2331   dest-&gt;obj_at_put(1, str());
2332   str = java_lang_String::create_from_symbol(member_sig, CHECK_NULL);
2333   dest-&gt;obj_at_put(2, str());
2334   return (jobjectArray) JNIHandles::make_local(dest());
2335 }
2336 JVM_END
2337 
2338 JVM_ENTRY(jint, JVM_ConstantPoolGetClassRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2339 {
2340   JVMWrapper(&quot;JVM_ConstantPoolGetClassRefIndexAt&quot;);
2341   JvmtiVMObjectAllocEventCollector oam;
2342   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2343   bounds_check(cp, index, CHECK_0);
2344   constantTag tag = cp-&gt;tag_at(index);
2345   if (!tag.is_field_or_method()) {
2346     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2347   }
2348   return (jint) cp-&gt;uncached_klass_ref_index_at(index);
2349 }
2350 JVM_END
2351 
2352 JVM_ENTRY(jint, JVM_ConstantPoolGetNameAndTypeRefIndexAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2353 {
2354   JVMWrapper(&quot;JVM_ConstantPoolGetNameAndTypeRefIndexAt&quot;);
2355   JvmtiVMObjectAllocEventCollector oam;
2356   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2357   bounds_check(cp, index, CHECK_0);
2358   constantTag tag = cp-&gt;tag_at(index);
2359   if (!tag.is_invoke_dynamic() &amp;&amp; !tag.is_field_or_method()) {
2360     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2361   }
2362   return (jint) cp-&gt;uncached_name_and_type_ref_index_at(index);
2363 }
2364 JVM_END
2365 
2366 JVM_ENTRY(jobjectArray, JVM_ConstantPoolGetNameAndTypeRefInfoAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2367 {
2368   JVMWrapper(&quot;JVM_ConstantPoolGetNameAndTypeRefInfoAt&quot;);
2369   JvmtiVMObjectAllocEventCollector oam;
2370   constantPoolHandle cp(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2371   bounds_check(cp, index, CHECK_NULL);
2372   constantTag tag = cp-&gt;tag_at(index);
2373   if (!tag.is_name_and_type()) {
2374     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2375   }
2376   Symbol* member_name = cp-&gt;symbol_at(cp-&gt;name_ref_index_at(index));
2377   Symbol* member_sig = cp-&gt;symbol_at(cp-&gt;signature_ref_index_at(index));
2378   objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 2, CHECK_NULL);
2379   objArrayHandle dest(THREAD, dest_o);
2380   Handle str = java_lang_String::create_from_symbol(member_name, CHECK_NULL);
2381   dest-&gt;obj_at_put(0, str());
2382   str = java_lang_String::create_from_symbol(member_sig, CHECK_NULL);
2383   dest-&gt;obj_at_put(1, str());
2384   return (jobjectArray) JNIHandles::make_local(dest());
2385 }
2386 JVM_END
2387 
2388 JVM_ENTRY(jint, JVM_ConstantPoolGetIntAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2389 {
2390   JVMWrapper(&quot;JVM_ConstantPoolGetIntAt&quot;);
2391   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2392   bounds_check(cp, index, CHECK_0);
2393   constantTag tag = cp-&gt;tag_at(index);
2394   if (!tag.is_int()) {
2395     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2396   }
2397   return cp-&gt;int_at(index);
2398 }
2399 JVM_END
2400 
2401 JVM_ENTRY(jlong, JVM_ConstantPoolGetLongAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2402 {
2403   JVMWrapper(&quot;JVM_ConstantPoolGetLongAt&quot;);
2404   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2405   bounds_check(cp, index, CHECK_(0L));
2406   constantTag tag = cp-&gt;tag_at(index);
2407   if (!tag.is_long()) {
2408     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2409   }
2410   return cp-&gt;long_at(index);
2411 }
2412 JVM_END
2413 
2414 JVM_ENTRY(jfloat, JVM_ConstantPoolGetFloatAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2415 {
2416   JVMWrapper(&quot;JVM_ConstantPoolGetFloatAt&quot;);
2417   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2418   bounds_check(cp, index, CHECK_(0.0f));
2419   constantTag tag = cp-&gt;tag_at(index);
2420   if (!tag.is_float()) {
2421     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2422   }
2423   return cp-&gt;float_at(index);
2424 }
2425 JVM_END
2426 
2427 JVM_ENTRY(jdouble, JVM_ConstantPoolGetDoubleAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2428 {
2429   JVMWrapper(&quot;JVM_ConstantPoolGetDoubleAt&quot;);
2430   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2431   bounds_check(cp, index, CHECK_(0.0));
2432   constantTag tag = cp-&gt;tag_at(index);
2433   if (!tag.is_double()) {
2434     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2435   }
2436   return cp-&gt;double_at(index);
2437 }
2438 JVM_END
2439 
2440 JVM_ENTRY(jstring, JVM_ConstantPoolGetStringAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2441 {
2442   JVMWrapper(&quot;JVM_ConstantPoolGetStringAt&quot;);
2443   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2444   bounds_check(cp, index, CHECK_NULL);
2445   constantTag tag = cp-&gt;tag_at(index);
2446   if (!tag.is_string()) {
2447     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2448   }
2449   oop str = cp-&gt;string_at(index, CHECK_NULL);
2450   return (jstring) JNIHandles::make_local(str);
2451 }
2452 JVM_END
2453 
2454 JVM_ENTRY(jstring, JVM_ConstantPoolGetUTF8At(JNIEnv *env, jobject obj, jobject unused, jint index))
2455 {
2456   JVMWrapper(&quot;JVM_ConstantPoolGetUTF8At&quot;);
2457   JvmtiVMObjectAllocEventCollector oam;
2458   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2459   bounds_check(cp, index, CHECK_NULL);
2460   constantTag tag = cp-&gt;tag_at(index);
2461   if (!tag.is_symbol()) {
2462     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Wrong type at constant pool index&quot;);
2463   }
2464   Symbol* sym = cp-&gt;symbol_at(index);
2465   Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
2466   return (jstring) JNIHandles::make_local(str());
2467 }
2468 JVM_END
2469 
2470 JVM_ENTRY(jbyte, JVM_ConstantPoolGetTagAt(JNIEnv *env, jobject obj, jobject unused, jint index))
2471 {
2472   JVMWrapper(&quot;JVM_ConstantPoolGetTagAt&quot;);
2473   constantPoolHandle cp = constantPoolHandle(THREAD, reflect_ConstantPool::get_cp(JNIHandles::resolve_non_null(obj)));
2474   bounds_check(cp, index, CHECK_0);
2475   constantTag tag = cp-&gt;tag_at(index);
2476   jbyte result = tag.value();
2477   // If returned tag values are not from the JVM spec, e.g. tags from 100 to 105,
2478   // they are changed to the corresponding tags from the JVM spec, so that java code in
2479   // sun.reflect.ConstantPool will return only tags from the JVM spec, not internal ones.
2480   if (tag.is_klass_or_reference()) {
2481       result = JVM_CONSTANT_Class;
2482   } else if (tag.is_string_index()) {
2483       result = JVM_CONSTANT_String;
2484   } else if (tag.is_method_type_in_error()) {
2485       result = JVM_CONSTANT_MethodType;
2486   } else if (tag.is_method_handle_in_error()) {
2487       result = JVM_CONSTANT_MethodHandle;
2488   } else if (tag.is_dynamic_constant_in_error()) {
2489       result = JVM_CONSTANT_Dynamic;
2490   }
2491   return result;
2492 }
2493 JVM_END
2494 
2495 // Assertion support. //////////////////////////////////////////////////////////
2496 
2497 JVM_ENTRY(jboolean, JVM_DesiredAssertionStatus(JNIEnv *env, jclass unused, jclass cls))
2498   JVMWrapper(&quot;JVM_DesiredAssertionStatus&quot;);
2499   assert(cls != NULL, &quot;bad class&quot;);
2500 
2501   oop r = JNIHandles::resolve(cls);
2502   assert(! java_lang_Class::is_primitive(r), &quot;primitive classes not allowed&quot;);
2503   if (java_lang_Class::is_primitive(r)) return false;
2504 
2505   Klass* k = java_lang_Class::as_Klass(r);
2506   assert(k-&gt;is_instance_klass(), &quot;must be an instance klass&quot;);
2507   if (!k-&gt;is_instance_klass()) return false;
2508 
2509   ResourceMark rm(THREAD);
2510   const char* name = k-&gt;name()-&gt;as_C_string();
2511   bool system_class = k-&gt;class_loader() == NULL;
2512   return JavaAssertions::enabled(name, system_class);
2513 
2514 JVM_END
2515 
2516 
2517 // Return a new AssertionStatusDirectives object with the fields filled in with
2518 // command-line assertion arguments (i.e., -ea, -da).
2519 JVM_ENTRY(jobject, JVM_AssertionStatusDirectives(JNIEnv *env, jclass unused))
2520   JVMWrapper(&quot;JVM_AssertionStatusDirectives&quot;);
2521   JvmtiVMObjectAllocEventCollector oam;
2522   oop asd = JavaAssertions::createAssertionStatusDirectives(CHECK_NULL);
2523   return JNIHandles::make_local(env, asd);
2524 JVM_END
2525 
2526 // Arrays support /////////////////////////////////////////////////////////////
2527 
2528 JVM_ENTRY(jboolean, JVM_ArrayIsAccessAtomic(JNIEnv *env, jclass unused, jobject array))
2529   JVMWrapper(&quot;JVM_ArrayIsAccessAtomic&quot;);
2530   oop o = JNIHandles::resolve(array);
2531   Klass* k = o-&gt;klass();
2532   if ((o == NULL) || (!k-&gt;is_array_klass())) {
2533     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
2534   }
2535   return ArrayKlass::cast(k)-&gt;element_access_is_atomic();
2536 JVM_END
2537 
2538 JVM_ENTRY(jobject, JVM_ArrayEnsureAccessAtomic(JNIEnv *env, jclass unused, jobject array))
2539   JVMWrapper(&quot;JVM_ArrayEnsureAccessAtomic&quot;);
2540   oop o = JNIHandles::resolve(array);
2541   Klass* k = o-&gt;klass();
2542   if ((o == NULL) || (!k-&gt;is_array_klass())) {
2543     THROW_0(vmSymbols::java_lang_IllegalArgumentException());
2544   }
2545   if (k-&gt;is_valueArray_klass()) {
2546     ValueArrayKlass* vk = ValueArrayKlass::cast(k);
2547     if (!vk-&gt;element_access_is_atomic()) {
2548       /**
2549        * Need to decide how to implement:
2550        *
2551        * 1) Change to objArrayOop layout, therefore oop-&gt;klass() differs so
2552        * then &quot;&lt;atomic&gt;[Qfoo;&quot; klass needs to subclass &quot;[Qfoo;&quot; to pass through
2553        * &quot;checkcast&quot; &amp; &quot;instanceof&quot;
2554        *
2555        * 2) Use extra header in the valueArrayOop to flag atomicity required and
2556        * possibly per instance lock structure. Said info, could be placed in
2557        * &quot;trailer&quot; rather than disturb the current arrayOop
2558        */
2559       Unimplemented();
2560     }
2561   }
2562   return array;
2563 JVM_END
2564 
2565 // Verification ////////////////////////////////////////////////////////////////////////////////
2566 
2567 // Reflection for the verifier /////////////////////////////////////////////////////////////////
2568 
2569 // RedefineClasses support: bug 6214132 caused verification to fail.
2570 // All functions from this section should call the jvmtiThreadSate function:
2571 //   Klass* class_to_verify_considering_redefinition(Klass* klass).
2572 // The function returns a Klass* of the _scratch_class if the verifier
2573 // was invoked in the middle of the class redefinition.
2574 // Otherwise it returns its argument value which is the _the_class Klass*.
2575 // Please, refer to the description in the jvmtiThreadSate.hpp.
2576 
2577 JVM_ENTRY(const char*, JVM_GetClassNameUTF(JNIEnv *env, jclass cls))
2578   JVMWrapper(&quot;JVM_GetClassNameUTF&quot;);
2579   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2580   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2581   return k-&gt;name()-&gt;as_utf8();
2582 JVM_END
2583 
2584 
2585 JVM_ENTRY(void, JVM_GetClassCPTypes(JNIEnv *env, jclass cls, unsigned char *types))
2586   JVMWrapper(&quot;JVM_GetClassCPTypes&quot;);
2587   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2588   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2589   // types will have length zero if this is not an InstanceKlass
2590   // (length is determined by call to JVM_GetClassCPEntriesCount)
2591   if (k-&gt;is_instance_klass()) {
2592     ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2593     for (int index = cp-&gt;length() - 1; index &gt;= 0; index--) {
2594       constantTag tag = cp-&gt;tag_at(index);
2595       types[index] = (tag.is_unresolved_klass()) ? (unsigned char) JVM_CONSTANT_Class : tag.value();
2596     }
2597   }
2598 JVM_END
2599 
2600 
2601 JVM_ENTRY(jint, JVM_GetClassCPEntriesCount(JNIEnv *env, jclass cls))
2602   JVMWrapper(&quot;JVM_GetClassCPEntriesCount&quot;);
2603   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2604   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2605   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;constants()-&gt;length();
2606 JVM_END
2607 
2608 
2609 JVM_ENTRY(jint, JVM_GetClassFieldsCount(JNIEnv *env, jclass cls))
2610   JVMWrapper(&quot;JVM_GetClassFieldsCount&quot;);
2611   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2612   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2613   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;java_fields_count();
2614 JVM_END
2615 
2616 
2617 JVM_ENTRY(jint, JVM_GetClassMethodsCount(JNIEnv *env, jclass cls))
2618   JVMWrapper(&quot;JVM_GetClassMethodsCount&quot;);
2619   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2620   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2621   return (!k-&gt;is_instance_klass()) ? 0 : InstanceKlass::cast(k)-&gt;methods()-&gt;length();
2622 JVM_END
2623 
2624 
2625 // The following methods, used for the verifier, are never called with
2626 // array klasses, so a direct cast to InstanceKlass is safe.
2627 // Typically, these methods are called in a loop with bounds determined
2628 // by the results of JVM_GetClass{Fields,Methods}Count, which return
2629 // zero for arrays.
2630 JVM_ENTRY(void, JVM_GetMethodIxExceptionIndexes(JNIEnv *env, jclass cls, jint method_index, unsigned short *exceptions))
2631   JVMWrapper(&quot;JVM_GetMethodIxExceptionIndexes&quot;);
2632   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2633   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2634   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2635   int length = method-&gt;checked_exceptions_length();
2636   if (length &gt; 0) {
2637     CheckedExceptionElement* table= method-&gt;checked_exceptions_start();
2638     for (int i = 0; i &lt; length; i++) {
2639       exceptions[i] = table[i].class_cp_index;
2640     }
2641   }
2642 JVM_END
2643 
2644 
2645 JVM_ENTRY(jint, JVM_GetMethodIxExceptionsCount(JNIEnv *env, jclass cls, jint method_index))
2646   JVMWrapper(&quot;JVM_GetMethodIxExceptionsCount&quot;);
2647   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2648   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2649   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2650   return method-&gt;checked_exceptions_length();
2651 JVM_END
2652 
2653 
2654 JVM_ENTRY(void, JVM_GetMethodIxByteCode(JNIEnv *env, jclass cls, jint method_index, unsigned char *code))
2655   JVMWrapper(&quot;JVM_GetMethodIxByteCode&quot;);
2656   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2657   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2658   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2659   memcpy(code, method-&gt;code_base(), method-&gt;code_size());
2660 JVM_END
2661 
2662 
2663 JVM_ENTRY(jint, JVM_GetMethodIxByteCodeLength(JNIEnv *env, jclass cls, jint method_index))
2664   JVMWrapper(&quot;JVM_GetMethodIxByteCodeLength&quot;);
2665   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2666   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2667   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2668   return method-&gt;code_size();
2669 JVM_END
2670 
2671 
2672 JVM_ENTRY(void, JVM_GetMethodIxExceptionTableEntry(JNIEnv *env, jclass cls, jint method_index, jint entry_index, JVM_ExceptionTableEntryType *entry))
2673   JVMWrapper(&quot;JVM_GetMethodIxExceptionTableEntry&quot;);
2674   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2675   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2676   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2677   ExceptionTable extable(method);
2678   entry-&gt;start_pc   = extable.start_pc(entry_index);
2679   entry-&gt;end_pc     = extable.end_pc(entry_index);
2680   entry-&gt;handler_pc = extable.handler_pc(entry_index);
2681   entry-&gt;catchType  = extable.catch_type_index(entry_index);
2682 JVM_END
2683 
2684 
2685 JVM_ENTRY(jint, JVM_GetMethodIxExceptionTableLength(JNIEnv *env, jclass cls, int method_index))
2686   JVMWrapper(&quot;JVM_GetMethodIxExceptionTableLength&quot;);
2687   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2688   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2689   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2690   return method-&gt;exception_table_length();
2691 JVM_END
2692 
2693 
2694 JVM_ENTRY(jint, JVM_GetMethodIxModifiers(JNIEnv *env, jclass cls, int method_index))
2695   JVMWrapper(&quot;JVM_GetMethodIxModifiers&quot;);
2696   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2697   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2698   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2699   return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2700 JVM_END
2701 
2702 
2703 JVM_ENTRY(jint, JVM_GetFieldIxModifiers(JNIEnv *env, jclass cls, int field_index))
2704   JVMWrapper(&quot;JVM_GetFieldIxModifiers&quot;);
2705   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2706   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2707   return InstanceKlass::cast(k)-&gt;field_access_flags(field_index) &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2708 JVM_END
2709 
2710 
2711 JVM_ENTRY(jint, JVM_GetMethodIxLocalsCount(JNIEnv *env, jclass cls, int method_index))
2712   JVMWrapper(&quot;JVM_GetMethodIxLocalsCount&quot;);
2713   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2714   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2715   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2716   return method-&gt;max_locals();
2717 JVM_END
2718 
2719 
2720 JVM_ENTRY(jint, JVM_GetMethodIxArgsSize(JNIEnv *env, jclass cls, int method_index))
2721   JVMWrapper(&quot;JVM_GetMethodIxArgsSize&quot;);
2722   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2723   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2724   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2725   return method-&gt;size_of_parameters();
2726 JVM_END
2727 
2728 
2729 JVM_ENTRY(jint, JVM_GetMethodIxMaxStack(JNIEnv *env, jclass cls, int method_index))
2730   JVMWrapper(&quot;JVM_GetMethodIxMaxStack&quot;);
2731   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2732   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2733   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2734   return method-&gt;verifier_max_stack();
2735 JVM_END
2736 
2737 
2738 JVM_ENTRY(jboolean, JVM_IsConstructorIx(JNIEnv *env, jclass cls, int method_index))
2739   JVMWrapper(&quot;JVM_IsConstructorIx&quot;);
2740   ResourceMark rm(THREAD);
2741   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2742   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2743   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2744   return method-&gt;is_object_constructor();
2745 JVM_END
2746 
2747 
2748 JVM_ENTRY(jboolean, JVM_IsVMGeneratedMethodIx(JNIEnv *env, jclass cls, int method_index))
2749   JVMWrapper(&quot;JVM_IsVMGeneratedMethodIx&quot;);
2750   ResourceMark rm(THREAD);
2751   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2752   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2753   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2754   return method-&gt;is_overpass();
2755 JVM_END
2756 
2757 JVM_ENTRY(const char*, JVM_GetMethodIxNameUTF(JNIEnv *env, jclass cls, jint method_index))
2758   JVMWrapper(&quot;JVM_GetMethodIxIxUTF&quot;);
2759   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2760   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2761   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2762   return method-&gt;name()-&gt;as_utf8();
2763 JVM_END
2764 
2765 
2766 JVM_ENTRY(const char*, JVM_GetMethodIxSignatureUTF(JNIEnv *env, jclass cls, jint method_index))
2767   JVMWrapper(&quot;JVM_GetMethodIxSignatureUTF&quot;);
2768   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2769   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2770   Method* method = InstanceKlass::cast(k)-&gt;methods()-&gt;at(method_index);
2771   return method-&gt;signature()-&gt;as_utf8();
2772 JVM_END
2773 
2774 /**
2775  * All of these JVM_GetCP-xxx methods are used by the old verifier to
2776  * read entries in the constant pool.  Since the old verifier always
2777  * works on a copy of the code, it will not see any rewriting that
2778  * may possibly occur in the middle of verification.  So it is important
2779  * that nothing it calls tries to use the cpCache instead of the raw
2780  * constant pool, so we must use cp-&gt;uncached_x methods when appropriate.
2781  */
2782 JVM_ENTRY(const char*, JVM_GetCPFieldNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2783   JVMWrapper(&quot;JVM_GetCPFieldNameUTF&quot;);
2784   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2785   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2786   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2787   switch (cp-&gt;tag_at(cp_index).value()) {
2788     case JVM_CONSTANT_Fieldref:
2789       return cp-&gt;uncached_name_ref_at(cp_index)-&gt;as_utf8();
2790     default:
2791       fatal(&quot;JVM_GetCPFieldNameUTF: illegal constant&quot;);
2792   }
2793   ShouldNotReachHere();
2794   return NULL;
2795 JVM_END
2796 
2797 
2798 JVM_ENTRY(const char*, JVM_GetCPMethodNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2799   JVMWrapper(&quot;JVM_GetCPMethodNameUTF&quot;);
2800   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2801   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2802   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2803   switch (cp-&gt;tag_at(cp_index).value()) {
2804     case JVM_CONSTANT_InterfaceMethodref:
2805     case JVM_CONSTANT_Methodref:
2806       return cp-&gt;uncached_name_ref_at(cp_index)-&gt;as_utf8();
2807     default:
2808       fatal(&quot;JVM_GetCPMethodNameUTF: illegal constant&quot;);
2809   }
2810   ShouldNotReachHere();
2811   return NULL;
2812 JVM_END
2813 
2814 
2815 JVM_ENTRY(const char*, JVM_GetCPMethodSignatureUTF(JNIEnv *env, jclass cls, jint cp_index))
2816   JVMWrapper(&quot;JVM_GetCPMethodSignatureUTF&quot;);
2817   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2818   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2819   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2820   switch (cp-&gt;tag_at(cp_index).value()) {
2821     case JVM_CONSTANT_InterfaceMethodref:
2822     case JVM_CONSTANT_Methodref:
2823       return cp-&gt;uncached_signature_ref_at(cp_index)-&gt;as_utf8();
2824     default:
2825       fatal(&quot;JVM_GetCPMethodSignatureUTF: illegal constant&quot;);
2826   }
2827   ShouldNotReachHere();
2828   return NULL;
2829 JVM_END
2830 
2831 
2832 JVM_ENTRY(const char*, JVM_GetCPFieldSignatureUTF(JNIEnv *env, jclass cls, jint cp_index))
2833   JVMWrapper(&quot;JVM_GetCPFieldSignatureUTF&quot;);
2834   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2835   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2836   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2837   switch (cp-&gt;tag_at(cp_index).value()) {
2838     case JVM_CONSTANT_Fieldref:
2839       return cp-&gt;uncached_signature_ref_at(cp_index)-&gt;as_utf8();
2840     default:
2841       fatal(&quot;JVM_GetCPFieldSignatureUTF: illegal constant&quot;);
2842   }
2843   ShouldNotReachHere();
2844   return NULL;
2845 JVM_END
2846 
2847 
2848 JVM_ENTRY(const char*, JVM_GetCPClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2849   JVMWrapper(&quot;JVM_GetCPClassNameUTF&quot;);
2850   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2851   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2852   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2853   Symbol* classname = cp-&gt;klass_name_at(cp_index);
2854   return classname-&gt;as_utf8();
2855 JVM_END
2856 
2857 
2858 JVM_ENTRY(const char*, JVM_GetCPFieldClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2859   JVMWrapper(&quot;JVM_GetCPFieldClassNameUTF&quot;);
2860   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2861   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2862   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2863   switch (cp-&gt;tag_at(cp_index).value()) {
2864     case JVM_CONSTANT_Fieldref: {
2865       int class_index = cp-&gt;uncached_klass_ref_index_at(cp_index);
2866       Symbol* classname = cp-&gt;klass_name_at(class_index);
2867       return classname-&gt;as_utf8();
2868     }
2869     default:
2870       fatal(&quot;JVM_GetCPFieldClassNameUTF: illegal constant&quot;);
2871   }
2872   ShouldNotReachHere();
2873   return NULL;
2874 JVM_END
2875 
2876 
2877 JVM_ENTRY(const char*, JVM_GetCPMethodClassNameUTF(JNIEnv *env, jclass cls, jint cp_index))
2878   JVMWrapper(&quot;JVM_GetCPMethodClassNameUTF&quot;);
2879   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2880   k = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2881   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2882   switch (cp-&gt;tag_at(cp_index).value()) {
2883     case JVM_CONSTANT_Methodref:
2884     case JVM_CONSTANT_InterfaceMethodref: {
2885       int class_index = cp-&gt;uncached_klass_ref_index_at(cp_index);
2886       Symbol* classname = cp-&gt;klass_name_at(class_index);
2887       return classname-&gt;as_utf8();
2888     }
2889     default:
2890       fatal(&quot;JVM_GetCPMethodClassNameUTF: illegal constant&quot;);
2891   }
2892   ShouldNotReachHere();
2893   return NULL;
2894 JVM_END
2895 
2896 
2897 JVM_ENTRY(jint, JVM_GetCPFieldModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))
2898   JVMWrapper(&quot;JVM_GetCPFieldModifiers&quot;);
2899   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2900   Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
2901   k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2902   k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
2903   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2904   ConstantPool* cp_called = InstanceKlass::cast(k_called)-&gt;constants();
2905   switch (cp-&gt;tag_at(cp_index).value()) {
2906     case JVM_CONSTANT_Fieldref: {
2907       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2908       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2909       InstanceKlass* ik = InstanceKlass::cast(k_called);
2910       for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {
2911         if (fs.name() == name &amp;&amp; fs.signature() == signature) {
2912           return fs.access_flags().as_short() &amp; JVM_RECOGNIZED_FIELD_MODIFIERS;
2913         }
2914       }
2915       return -1;
2916     }
2917     default:
2918       fatal(&quot;JVM_GetCPFieldModifiers: illegal constant&quot;);
2919   }
2920   ShouldNotReachHere();
2921   return 0;
2922 JVM_END
2923 
2924 
2925 JVM_ENTRY(jint, JVM_GetCPMethodModifiers(JNIEnv *env, jclass cls, int cp_index, jclass called_cls))
2926   JVMWrapper(&quot;JVM_GetCPMethodModifiers&quot;);
2927   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));
2928   Klass* k_called = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(called_cls));
2929   k        = JvmtiThreadState::class_to_verify_considering_redefinition(k, thread);
2930   k_called = JvmtiThreadState::class_to_verify_considering_redefinition(k_called, thread);
2931   ConstantPool* cp = InstanceKlass::cast(k)-&gt;constants();
2932   switch (cp-&gt;tag_at(cp_index).value()) {
2933     case JVM_CONSTANT_Methodref:
2934     case JVM_CONSTANT_InterfaceMethodref: {
2935       Symbol* name      = cp-&gt;uncached_name_ref_at(cp_index);
2936       Symbol* signature = cp-&gt;uncached_signature_ref_at(cp_index);
2937       Array&lt;Method*&gt;* methods = InstanceKlass::cast(k_called)-&gt;methods();
2938       int methods_count = methods-&gt;length();
2939       for (int i = 0; i &lt; methods_count; i++) {
2940         Method* method = methods-&gt;at(i);
2941         if (method-&gt;name() == name &amp;&amp; method-&gt;signature() == signature) {
2942             return method-&gt;access_flags().as_int() &amp; JVM_RECOGNIZED_METHOD_MODIFIERS;
2943         }
2944       }
2945       return -1;
2946     }
2947     default:
2948       fatal(&quot;JVM_GetCPMethodModifiers: illegal constant&quot;);
2949   }
2950   ShouldNotReachHere();
2951   return 0;
2952 JVM_END
2953 
2954 
2955 // Misc //////////////////////////////////////////////////////////////////////////////////////////////
2956 
2957 JVM_LEAF(void, JVM_ReleaseUTF(const char *utf))
2958   // So long as UTF8::convert_to_utf8 returns resource strings, we don&#39;t have to do anything
2959 JVM_END
2960 
2961 
2962 JVM_ENTRY(jboolean, JVM_IsSameClassPackage(JNIEnv *env, jclass class1, jclass class2))
2963   JVMWrapper(&quot;JVM_IsSameClassPackage&quot;);
2964   oop class1_mirror = JNIHandles::resolve_non_null(class1);
2965   oop class2_mirror = JNIHandles::resolve_non_null(class2);
2966   Klass* klass1 = java_lang_Class::as_Klass(class1_mirror);
2967   Klass* klass2 = java_lang_Class::as_Klass(class2_mirror);
2968   return (jboolean) Reflection::is_same_class_package(klass1, klass2);
2969 JVM_END
2970 
2971 // Printing support //////////////////////////////////////////////////
2972 extern &quot;C&quot; {
2973 
2974 ATTRIBUTE_PRINTF(3, 0)
2975 int jio_vsnprintf(char *str, size_t count, const char *fmt, va_list args) {
2976   // Reject count values that are negative signed values converted to
2977   // unsigned; see bug 4399518, 4417214
2978   if ((intptr_t)count &lt;= 0) return -1;
2979 
2980   int result = os::vsnprintf(str, count, fmt, args);
2981   if (result &gt; 0 &amp;&amp; (size_t)result &gt;= count) {
2982     result = -1;
2983   }
2984 
2985   return result;
2986 }
2987 
2988 ATTRIBUTE_PRINTF(3, 4)
2989 int jio_snprintf(char *str, size_t count, const char *fmt, ...) {
2990   va_list args;
2991   int len;
2992   va_start(args, fmt);
2993   len = jio_vsnprintf(str, count, fmt, args);
2994   va_end(args);
2995   return len;
2996 }
2997 
2998 ATTRIBUTE_PRINTF(2, 3)
2999 int jio_fprintf(FILE* f, const char *fmt, ...) {
3000   int len;
3001   va_list args;
3002   va_start(args, fmt);
3003   len = jio_vfprintf(f, fmt, args);
3004   va_end(args);
3005   return len;
3006 }
3007 
3008 ATTRIBUTE_PRINTF(2, 0)
3009 int jio_vfprintf(FILE* f, const char *fmt, va_list args) {
3010   if (Arguments::vfprintf_hook() != NULL) {
3011      return Arguments::vfprintf_hook()(f, fmt, args);
3012   } else {
3013     return vfprintf(f, fmt, args);
3014   }
3015 }
3016 
3017 ATTRIBUTE_PRINTF(1, 2)
3018 JNIEXPORT int jio_printf(const char *fmt, ...) {
3019   int len;
3020   va_list args;
3021   va_start(args, fmt);
3022   len = jio_vfprintf(defaultStream::output_stream(), fmt, args);
3023   va_end(args);
3024   return len;
3025 }
3026 
3027 // HotSpot specific jio method
3028 void jio_print(const char* s, size_t len) {
3029   // Try to make this function as atomic as possible.
3030   if (Arguments::vfprintf_hook() != NULL) {
3031     jio_fprintf(defaultStream::output_stream(), &quot;%.*s&quot;, (int)len, s);
3032   } else {
3033     // Make an unused local variable to avoid warning from gcc compiler.
3034     size_t count = ::write(defaultStream::output_fd(), s, (int)len);
3035   }
3036 }
3037 
3038 } // Extern C
3039 
3040 // java.lang.Thread //////////////////////////////////////////////////////////////////////////////
3041 
3042 // In most of the JVM thread support functions we need to access the
3043 // thread through a ThreadsListHandle to prevent it from exiting and
3044 // being reclaimed while we try to operate on it. The exceptions to this
3045 // rule are when operating on the current thread, or if the monitor of
3046 // the target java.lang.Thread is locked at the Java level - in both
3047 // cases the target cannot exit.
3048 
3049 static void thread_entry(JavaThread* thread, TRAPS) {
3050   HandleMark hm(THREAD);
3051   Handle obj(THREAD, thread-&gt;threadObj());
3052   JavaValue result(T_VOID);
3053   JavaCalls::call_virtual(&amp;result,
3054                           obj,
3055                           SystemDictionary::Thread_klass(),
3056                           vmSymbols::run_method_name(),
3057                           vmSymbols::void_method_signature(),
3058                           THREAD);
3059 }
3060 
3061 
3062 JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))
3063   JVMWrapper(&quot;JVM_StartThread&quot;);
3064   JavaThread *native_thread = NULL;
3065 
3066   // We cannot hold the Threads_lock when we throw an exception,
3067   // due to rank ordering issues. Example:  we might need to grab the
3068   // Heap_lock while we construct the exception.
3069   bool throw_illegal_thread_state = false;
3070 
3071   // We must release the Threads_lock before we can post a jvmti event
3072   // in Thread::start.
3073   {
3074     // Ensure that the C++ Thread and OSThread structures aren&#39;t freed before
3075     // we operate.
3076     MutexLocker mu(Threads_lock);
3077 
3078     // Since JDK 5 the java.lang.Thread threadStatus is used to prevent
3079     // re-starting an already started thread, so we should usually find
3080     // that the JavaThread is null. However for a JNI attached thread
3081     // there is a small window between the Thread object being created
3082     // (with its JavaThread set) and the update to its threadStatus, so we
3083     // have to check for this
3084     if (java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread)) != NULL) {
3085       throw_illegal_thread_state = true;
3086     } else {
3087       // We could also check the stillborn flag to see if this thread was already stopped, but
3088       // for historical reasons we let the thread detect that itself when it starts running
3089 
3090       jlong size =
3091              java_lang_Thread::stackSize(JNIHandles::resolve_non_null(jthread));
3092       // Allocate the C++ Thread structure and create the native thread.  The
3093       // stack size retrieved from java is 64-bit signed, but the constructor takes
3094       // size_t (an unsigned type), which may be 32 or 64-bit depending on the platform.
3095       //  - Avoid truncating on 32-bit platforms if size is greater than UINT_MAX.
3096       //  - Avoid passing negative values which would result in really large stacks.
3097       NOT_LP64(if (size &gt; SIZE_MAX) size = SIZE_MAX;)
3098       size_t sz = size &gt; 0 ? (size_t) size : 0;
3099       native_thread = new JavaThread(&amp;thread_entry, sz);
3100 
3101       // At this point it may be possible that no osthread was created for the
3102       // JavaThread due to lack of memory. Check for this situation and throw
3103       // an exception if necessary. Eventually we may want to change this so
3104       // that we only grab the lock if the thread was created successfully -
3105       // then we can also do this check and throw the exception in the
3106       // JavaThread constructor.
3107       if (native_thread-&gt;osthread() != NULL) {
3108         // Note: the current thread is not being used within &quot;prepare&quot;.
3109         native_thread-&gt;prepare(jthread);
3110       }
3111     }
3112   }
3113 
3114   if (throw_illegal_thread_state) {
3115     THROW(vmSymbols::java_lang_IllegalThreadStateException());
3116   }
3117 
3118   assert(native_thread != NULL, &quot;Starting null thread?&quot;);
3119 
3120   if (native_thread-&gt;osthread() == NULL) {
3121     // No one should hold a reference to the &#39;native_thread&#39;.
3122     native_thread-&gt;smr_delete();
3123     if (JvmtiExport::should_post_resource_exhausted()) {
3124       JvmtiExport::post_resource_exhausted(
3125         JVMTI_RESOURCE_EXHAUSTED_OOM_ERROR | JVMTI_RESOURCE_EXHAUSTED_THREADS,
3126         os::native_thread_creation_failed_msg());
3127     }
3128     THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),
3129               os::native_thread_creation_failed_msg());
3130   }
3131 
3132 #if INCLUDE_JFR
3133   if (JfrRecorder::is_recording() &amp;&amp; EventThreadStart::is_enabled() &amp;&amp;
3134       EventThreadStart::is_stacktrace_enabled()) {
3135     JfrThreadLocal* tl = native_thread-&gt;jfr_thread_local();
3136     // skip Thread.start() and Thread.start0()
3137     tl-&gt;set_cached_stack_trace_id(JfrStackTraceRepository::record(thread, 2));
3138   }
3139 #endif
3140 
3141   Thread::start(native_thread);
3142 
3143 JVM_END
3144 
3145 
3146 // JVM_Stop is implemented using a VM_Operation, so threads are forced to safepoints
3147 // before the quasi-asynchronous exception is delivered.  This is a little obtrusive,
3148 // but is thought to be reliable and simple. In the case, where the receiver is the
3149 // same thread as the sender, no VM_Operation is needed.
3150 JVM_ENTRY(void, JVM_StopThread(JNIEnv* env, jobject jthread, jobject throwable))
3151   JVMWrapper(&quot;JVM_StopThread&quot;);
3152 
3153   // A nested ThreadsListHandle will grab the Threads_lock so create
3154   // tlh before we resolve throwable.
3155   ThreadsListHandle tlh(thread);
3156   oop java_throwable = JNIHandles::resolve(throwable);
3157   if (java_throwable == NULL) {
3158     THROW(vmSymbols::java_lang_NullPointerException());
3159   }
3160   oop java_thread = NULL;
3161   JavaThread* receiver = NULL;
3162   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, &amp;java_thread);
3163   Events::log_exception(thread,
3164                         &quot;JVM_StopThread thread JavaThread &quot; INTPTR_FORMAT &quot; as oop &quot; INTPTR_FORMAT &quot; [exception &quot; INTPTR_FORMAT &quot;]&quot;,
3165                         p2i(receiver), p2i(java_thread), p2i(throwable));
3166 
3167   if (is_alive) {
3168     // jthread refers to a live JavaThread.
3169     if (thread == receiver) {
3170       // Exception is getting thrown at self so no VM_Operation needed.
3171       THROW_OOP(java_throwable);
3172     } else {
3173       // Use a VM_Operation to throw the exception.
3174       Thread::send_async_exception(java_thread, java_throwable);
3175     }
3176   } else {
3177     // Either:
3178     // - target thread has not been started before being stopped, or
3179     // - target thread already terminated
3180     // We could read the threadStatus to determine which case it is
3181     // but that is overkill as it doesn&#39;t matter. We must set the
3182     // stillborn flag for the first case, and if the thread has already
3183     // exited setting this flag has no effect.
3184     java_lang_Thread::set_stillborn(java_thread);
3185   }
3186 JVM_END
3187 
3188 
3189 JVM_ENTRY(jboolean, JVM_IsThreadAlive(JNIEnv* env, jobject jthread))
3190   JVMWrapper(&quot;JVM_IsThreadAlive&quot;);
3191 
3192   oop thread_oop = JNIHandles::resolve_non_null(jthread);
3193   return java_lang_Thread::is_alive(thread_oop);
3194 JVM_END
3195 
3196 
3197 JVM_ENTRY(void, JVM_SuspendThread(JNIEnv* env, jobject jthread))
3198   JVMWrapper(&quot;JVM_SuspendThread&quot;);
3199 
3200   ThreadsListHandle tlh(thread);
3201   JavaThread* receiver = NULL;
3202   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3203   if (is_alive) {
3204     // jthread refers to a live JavaThread.
3205     {
3206       MutexLocker ml(receiver-&gt;SR_lock(), Mutex::_no_safepoint_check_flag);
3207       if (receiver-&gt;is_external_suspend()) {
3208         // Don&#39;t allow nested external suspend requests. We can&#39;t return
3209         // an error from this interface so just ignore the problem.
3210         return;
3211       }
3212       if (receiver-&gt;is_exiting()) { // thread is in the process of exiting
3213         return;
3214       }
3215       receiver-&gt;set_external_suspend();
3216     }
3217 
3218     // java_suspend() will catch threads in the process of exiting
3219     // and will ignore them.
3220     receiver-&gt;java_suspend();
3221 
3222     // It would be nice to have the following assertion in all the
3223     // time, but it is possible for a racing resume request to have
3224     // resumed this thread right after we suspended it. Temporarily
3225     // enable this assertion if you are chasing a different kind of
3226     // bug.
3227     //
3228     // assert(java_lang_Thread::thread(receiver-&gt;threadObj()) == NULL ||
3229     //   receiver-&gt;is_being_ext_suspended(), &quot;thread is not suspended&quot;);
3230   }
3231 JVM_END
3232 
3233 
3234 JVM_ENTRY(void, JVM_ResumeThread(JNIEnv* env, jobject jthread))
3235   JVMWrapper(&quot;JVM_ResumeThread&quot;);
3236 
3237   ThreadsListHandle tlh(thread);
3238   JavaThread* receiver = NULL;
3239   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3240   if (is_alive) {
3241     // jthread refers to a live JavaThread.
3242 
3243     // This is the original comment for this Threads_lock grab:
3244     //   We need to *always* get the threads lock here, since this operation cannot be allowed during
3245     //   a safepoint. The safepoint code relies on suspending a thread to examine its state. If other
3246     //   threads randomly resumes threads, then a thread might not be suspended when the safepoint code
3247     //   looks at it.
3248     //
3249     // The above comment dates back to when we had both internal and
3250     // external suspend APIs that shared a common underlying mechanism.
3251     // External suspend is now entirely cooperative and doesn&#39;t share
3252     // anything with internal suspend. That said, there are some
3253     // assumptions in the VM that an external resume grabs the
3254     // Threads_lock. We can&#39;t drop the Threads_lock grab here until we
3255     // resolve the assumptions that exist elsewhere.
3256     //
3257     MutexLocker ml(Threads_lock);
3258     receiver-&gt;java_resume();
3259   }
3260 JVM_END
3261 
3262 
3263 JVM_ENTRY(void, JVM_SetThreadPriority(JNIEnv* env, jobject jthread, jint prio))
3264   JVMWrapper(&quot;JVM_SetThreadPriority&quot;);
3265 
3266   ThreadsListHandle tlh(thread);
3267   oop java_thread = NULL;
3268   JavaThread* receiver = NULL;
3269   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, &amp;java_thread);
3270   java_lang_Thread::set_priority(java_thread, (ThreadPriority)prio);
3271 
3272   if (is_alive) {
3273     // jthread refers to a live JavaThread.
3274     Thread::set_priority(receiver, (ThreadPriority)prio);
3275   }
3276   // Implied else: If the JavaThread hasn&#39;t started yet, then the
3277   // priority set in the java.lang.Thread object above will be pushed
3278   // down when it does start.
3279 JVM_END
3280 
3281 
3282 JVM_ENTRY(void, JVM_Yield(JNIEnv *env, jclass threadClass))
3283   JVMWrapper(&quot;JVM_Yield&quot;);
3284   if (os::dont_yield()) return;
3285   HOTSPOT_THREAD_YIELD();
3286   os::naked_yield();
3287 JVM_END
3288 
3289 static void post_thread_sleep_event(EventThreadSleep* event, jlong millis) {
3290   assert(event != NULL, &quot;invariant&quot;);
3291   assert(event-&gt;should_commit(), &quot;invariant&quot;);
3292   event-&gt;set_time(millis);
3293   event-&gt;commit();
3294 }
3295 
3296 JVM_ENTRY(void, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong millis))
3297   JVMWrapper(&quot;JVM_Sleep&quot;);
3298 
3299   if (millis &lt; 0) {
3300     THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &quot;timeout value is negative&quot;);
3301   }
3302 
3303   if (thread-&gt;is_interrupted(true) &amp;&amp; !HAS_PENDING_EXCEPTION) {
3304     THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
3305   }
3306 
3307   // Save current thread state and restore it at the end of this block.
3308   // And set new thread state to SLEEPING.
3309   JavaThreadSleepState jtss(thread);
3310 
3311   HOTSPOT_THREAD_SLEEP_BEGIN(millis);
3312   EventThreadSleep event;
3313 
3314   if (millis == 0) {
3315     os::naked_yield();
3316   } else {
3317     ThreadState old_state = thread-&gt;osthread()-&gt;get_state();
3318     thread-&gt;osthread()-&gt;set_state(SLEEPING);
3319     if (!thread-&gt;sleep(millis)) { // interrupted
3320       // An asynchronous exception (e.g., ThreadDeathException) could have been thrown on
3321       // us while we were sleeping. We do not overwrite those.
3322       if (!HAS_PENDING_EXCEPTION) {
3323         if (event.should_commit()) {
3324           post_thread_sleep_event(&amp;event, millis);
3325         }
3326         HOTSPOT_THREAD_SLEEP_END(1);
3327 
3328         // TODO-FIXME: THROW_MSG returns which means we will not call set_state()
3329         // to properly restore the thread state.  That&#39;s likely wrong.
3330         THROW_MSG(vmSymbols::java_lang_InterruptedException(), &quot;sleep interrupted&quot;);
3331       }
3332     }
3333     thread-&gt;osthread()-&gt;set_state(old_state);
3334   }
3335   if (event.should_commit()) {
3336     post_thread_sleep_event(&amp;event, millis);
3337   }
3338   HOTSPOT_THREAD_SLEEP_END(0);
3339 JVM_END
3340 
3341 JVM_ENTRY(jobject, JVM_CurrentThread(JNIEnv* env, jclass threadClass))
3342   JVMWrapper(&quot;JVM_CurrentThread&quot;);
3343   oop jthread = thread-&gt;threadObj();
3344   assert (thread != NULL, &quot;no current thread!&quot;);
3345   return JNIHandles::make_local(env, jthread);
3346 JVM_END
3347 
3348 JVM_ENTRY(void, JVM_Interrupt(JNIEnv* env, jobject jthread))
3349   JVMWrapper(&quot;JVM_Interrupt&quot;);
3350 
3351   ThreadsListHandle tlh(thread);
3352   JavaThread* receiver = NULL;
3353   bool is_alive = tlh.cv_internal_thread_to_JavaThread(jthread, &amp;receiver, NULL);
3354   if (is_alive) {
3355     // jthread refers to a live JavaThread.
3356     receiver-&gt;interrupt();
3357   }
3358 JVM_END
3359 
3360 
3361 // Return true iff the current thread has locked the object passed in
3362 
3363 JVM_ENTRY(jboolean, JVM_HoldsLock(JNIEnv* env, jclass threadClass, jobject obj))
3364   JVMWrapper(&quot;JVM_HoldsLock&quot;);
3365   assert(THREAD-&gt;is_Java_thread(), &quot;sanity check&quot;);
3366   if (obj == NULL) {
3367     THROW_(vmSymbols::java_lang_NullPointerException(), JNI_FALSE);
3368   }
3369   Handle h_obj(THREAD, JNIHandles::resolve(obj));
3370   return ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, h_obj);
3371 JVM_END
3372 
3373 
3374 JVM_ENTRY(void, JVM_DumpAllStacks(JNIEnv* env, jclass))
3375   JVMWrapper(&quot;JVM_DumpAllStacks&quot;);
3376   VM_PrintThreads op;
3377   VMThread::execute(&amp;op);
3378   if (JvmtiExport::should_post_data_dump()) {
3379     JvmtiExport::post_data_dump();
3380   }
3381 JVM_END
3382 
3383 JVM_ENTRY(void, JVM_SetNativeThreadName(JNIEnv* env, jobject jthread, jstring name))
3384   JVMWrapper(&quot;JVM_SetNativeThreadName&quot;);
3385 
3386   // We don&#39;t use a ThreadsListHandle here because the current thread
3387   // must be alive.
3388   oop java_thread = JNIHandles::resolve_non_null(jthread);
3389   JavaThread* thr = java_lang_Thread::thread(java_thread);
3390   if (thread == thr &amp;&amp; !thr-&gt;has_attached_via_jni()) {
3391     // Thread naming is only supported for the current thread and
3392     // we don&#39;t set the name of an attached thread to avoid stepping
3393     // on other programs.
3394     ResourceMark rm(thread);
3395     const char *thread_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
3396     os::set_native_thread_name(thread_name);
3397   }
3398 JVM_END
3399 
3400 // java.lang.SecurityManager ///////////////////////////////////////////////////////////////////////
3401 
3402 JVM_ENTRY(jobjectArray, JVM_GetClassContext(JNIEnv *env))
3403   JVMWrapper(&quot;JVM_GetClassContext&quot;);
3404   ResourceMark rm(THREAD);
3405   JvmtiVMObjectAllocEventCollector oam;
3406   vframeStream vfst(thread);
3407 
3408   if (SystemDictionary::reflect_CallerSensitive_klass() != NULL) {
3409     // This must only be called from SecurityManager.getClassContext
3410     Method* m = vfst.method();
3411     if (!(m-&gt;method_holder() == SystemDictionary::SecurityManager_klass() &amp;&amp;
3412           m-&gt;name()          == vmSymbols::getClassContext_name() &amp;&amp;
3413           m-&gt;signature()     == vmSymbols::void_class_array_signature())) {
3414       THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), &quot;JVM_GetClassContext must only be called from SecurityManager.getClassContext&quot;);
3415     }
3416   }
3417 
3418   // Collect method holders
3419   GrowableArray&lt;Klass*&gt;* klass_array = new GrowableArray&lt;Klass*&gt;();
3420   for (; !vfst.at_end(); vfst.security_next()) {
3421     Method* m = vfst.method();
3422     // Native frames are not returned
3423     if (!m-&gt;is_ignored_by_security_stack_walk() &amp;&amp; !m-&gt;is_native()) {
3424       Klass* holder = m-&gt;method_holder();
3425       assert(holder-&gt;is_klass(), &quot;just checking&quot;);
3426       klass_array-&gt;append(holder);
3427     }
3428   }
3429 
3430   // Create result array of type [Ljava/lang/Class;
3431   objArrayOop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), klass_array-&gt;length(), CHECK_NULL);
3432   // Fill in mirrors corresponding to method holders
3433   for (int i = 0; i &lt; klass_array-&gt;length(); i++) {
3434     result-&gt;obj_at_put(i, klass_array-&gt;at(i)-&gt;java_mirror());
3435   }
3436 
3437   return (jobjectArray) JNIHandles::make_local(env, result);
3438 JVM_END
3439 
3440 
3441 // java.lang.Package ////////////////////////////////////////////////////////////////
3442 
3443 
3444 JVM_ENTRY(jstring, JVM_GetSystemPackage(JNIEnv *env, jstring name))
3445   JVMWrapper(&quot;JVM_GetSystemPackage&quot;);
3446   ResourceMark rm(THREAD);
3447   JvmtiVMObjectAllocEventCollector oam;
3448   char* str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
3449   oop result = ClassLoader::get_system_package(str, CHECK_NULL);
3450   return (jstring) JNIHandles::make_local(result);
3451 JVM_END
3452 
3453 
3454 JVM_ENTRY(jobjectArray, JVM_GetSystemPackages(JNIEnv *env))
3455   JVMWrapper(&quot;JVM_GetSystemPackages&quot;);
3456   JvmtiVMObjectAllocEventCollector oam;
3457   objArrayOop result = ClassLoader::get_system_packages(CHECK_NULL);
3458   return (jobjectArray) JNIHandles::make_local(result);
3459 JVM_END
3460 
3461 
3462 // java.lang.ref.Reference ///////////////////////////////////////////////////////////////
3463 
3464 
3465 JVM_ENTRY(jobject, JVM_GetAndClearReferencePendingList(JNIEnv* env))
3466   JVMWrapper(&quot;JVM_GetAndClearReferencePendingList&quot;);
3467 
3468   MonitorLocker ml(Heap_lock);
3469   oop ref = Universe::reference_pending_list();
3470   if (ref != NULL) {
3471     Universe::set_reference_pending_list(NULL);
3472   }
3473   return JNIHandles::make_local(env, ref);
3474 JVM_END
3475 
3476 JVM_ENTRY(jboolean, JVM_HasReferencePendingList(JNIEnv* env))
3477   JVMWrapper(&quot;JVM_HasReferencePendingList&quot;);
3478   MonitorLocker ml(Heap_lock);
3479   return Universe::has_reference_pending_list();
3480 JVM_END
3481 
3482 JVM_ENTRY(void, JVM_WaitForReferencePendingList(JNIEnv* env))
3483   JVMWrapper(&quot;JVM_WaitForReferencePendingList&quot;);
3484   MonitorLocker ml(Heap_lock);
3485   while (!Universe::has_reference_pending_list()) {
3486     ml.wait();
3487   }
3488 JVM_END
3489 
3490 
3491 // ObjectInputStream ///////////////////////////////////////////////////////////////
3492 
3493 // Return the first user-defined class loader up the execution stack, or null
3494 // if only code from the bootstrap or platform class loader is on the stack.
3495 
3496 JVM_ENTRY(jobject, JVM_LatestUserDefinedLoader(JNIEnv *env))
3497   for (vframeStream vfst(thread); !vfst.at_end(); vfst.next()) {
3498     vfst.skip_reflection_related_frames(); // Only needed for 1.4 reflection
3499     oop loader = vfst.method()-&gt;method_holder()-&gt;class_loader();
3500     if (loader != NULL &amp;&amp; !SystemDictionary::is_platform_class_loader(loader)) {
3501       return JNIHandles::make_local(env, loader);
3502     }
3503   }
3504   return NULL;
3505 JVM_END
3506 
3507 
3508 // Array ///////////////////////////////////////////////////////////////////////////////////////////
3509 
3510 
3511 // resolve array handle and check arguments
3512 static inline arrayOop check_array(JNIEnv *env, jobject arr, bool type_array_only, TRAPS) {
3513   if (arr == NULL) {
3514     THROW_0(vmSymbols::java_lang_NullPointerException());
3515   }
3516   oop a = JNIHandles::resolve_non_null(arr);
3517   if (!a-&gt;is_array()) {
3518     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Argument is not an array&quot;);
3519   } else if (type_array_only &amp;&amp; !a-&gt;is_typeArray()) {
3520     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Argument is not an array of primitive type&quot;);
3521   }
3522   return arrayOop(a);
3523 }
3524 
3525 
3526 JVM_ENTRY(jint, JVM_GetArrayLength(JNIEnv *env, jobject arr))
3527   JVMWrapper(&quot;JVM_GetArrayLength&quot;);
3528   arrayOop a = check_array(env, arr, false, CHECK_0);
3529   return a-&gt;length();
3530 JVM_END
3531 
3532 
3533 JVM_ENTRY(jobject, JVM_GetArrayElement(JNIEnv *env, jobject arr, jint index))
3534   JVMWrapper(&quot;JVM_Array_Get&quot;);
3535   JvmtiVMObjectAllocEventCollector oam;
3536   arrayOop a = check_array(env, arr, false, CHECK_NULL);
3537   jvalue value;
3538   BasicType type = Reflection::array_get(&amp;value, a, index, CHECK_NULL);
3539   oop box = Reflection::box(&amp;value, type, CHECK_NULL);
3540   return JNIHandles::make_local(env, box);
3541 JVM_END
3542 
3543 
3544 JVM_ENTRY(jvalue, JVM_GetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jint wCode))
3545   JVMWrapper(&quot;JVM_GetPrimitiveArrayElement&quot;);
3546   jvalue value;
3547   value.i = 0; // to initialize value before getting used in CHECK
3548   arrayOop a = check_array(env, arr, true, CHECK_(value));
3549   assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
3550   BasicType type = Reflection::array_get(&amp;value, a, index, CHECK_(value));
3551   BasicType wide_type = (BasicType) wCode;
3552   if (type != wide_type) {
3553     Reflection::widen(&amp;value, type, wide_type, CHECK_(value));
3554   }
3555   return value;
3556 JVM_END
3557 
3558 
3559 JVM_ENTRY(void, JVM_SetArrayElement(JNIEnv *env, jobject arr, jint index, jobject val))
3560   JVMWrapper(&quot;JVM_SetArrayElement&quot;);
3561   arrayOop a = check_array(env, arr, false, CHECK);
3562   oop box = JNIHandles::resolve(val);
3563   jvalue value;
3564   value.i = 0; // to initialize value before getting used in CHECK
3565   BasicType value_type;
3566   if (a-&gt;is_objArray()) {
3567     // Make sure we do no unbox e.g. java/lang/Integer instances when storing into an object array
3568     value_type = Reflection::unbox_for_regular_object(box, &amp;value);
3569   } else {
3570     value_type = Reflection::unbox_for_primitive(box, &amp;value, CHECK);
3571   }
3572   Reflection::array_set(&amp;value, a, index, value_type, CHECK);
3573 JVM_END
3574 
3575 
3576 JVM_ENTRY(void, JVM_SetPrimitiveArrayElement(JNIEnv *env, jobject arr, jint index, jvalue v, unsigned char vCode))
3577   JVMWrapper(&quot;JVM_SetPrimitiveArrayElement&quot;);
3578   arrayOop a = check_array(env, arr, true, CHECK);
3579   assert(a-&gt;is_typeArray(), &quot;just checking&quot;);
3580   BasicType value_type = (BasicType) vCode;
3581   Reflection::array_set(&amp;v, a, index, value_type, CHECK);
3582 JVM_END
3583 
3584 
3585 JVM_ENTRY(jobject, JVM_NewArray(JNIEnv *env, jclass eltClass, jint length))
3586   JVMWrapper(&quot;JVM_NewArray&quot;);
3587   JvmtiVMObjectAllocEventCollector oam;
3588   oop element_mirror = JNIHandles::resolve(eltClass);
3589   oop result = Reflection::reflect_new_array(element_mirror, length, CHECK_NULL);
3590   return JNIHandles::make_local(env, result);
3591 JVM_END
3592 
3593 
3594 JVM_ENTRY(jobject, JVM_NewMultiArray(JNIEnv *env, jclass eltClass, jintArray dim))
3595   JVMWrapper(&quot;JVM_NewMultiArray&quot;);
3596   JvmtiVMObjectAllocEventCollector oam;
3597   arrayOop dim_array = check_array(env, dim, true, CHECK_NULL);
3598   oop element_mirror = JNIHandles::resolve(eltClass);
3599   assert(dim_array-&gt;is_typeArray(), &quot;just checking&quot;);
3600   oop result = Reflection::reflect_new_multi_array(element_mirror, typeArrayOop(dim_array), CHECK_NULL);
3601   return JNIHandles::make_local(env, result);
3602 JVM_END
3603 
3604 
3605 // Library support ///////////////////////////////////////////////////////////////////////////
3606 
3607 JVM_ENTRY_NO_ENV(void*, JVM_LoadLibrary(const char* name))
3608   //%note jvm_ct
3609   JVMWrapper(&quot;JVM_LoadLibrary&quot;);
3610   char ebuf[1024];
3611   void *load_result;
3612   {
3613     ThreadToNativeFromVM ttnfvm(thread);
3614     load_result = os::dll_load(name, ebuf, sizeof ebuf);
3615   }
3616   if (load_result == NULL) {
3617     char msg[1024];
3618     jio_snprintf(msg, sizeof msg, &quot;%s: %s&quot;, name, ebuf);
3619     // Since &#39;ebuf&#39; may contain a string encoded using
3620     // platform encoding scheme, we need to pass
3621     // Exceptions::unsafe_to_utf8 to the new_exception method
3622     // as the last argument. See bug 6367357.
3623     Handle h_exception =
3624       Exceptions::new_exception(thread,
3625                                 vmSymbols::java_lang_UnsatisfiedLinkError(),
3626                                 msg, Exceptions::unsafe_to_utf8);
3627 
3628     THROW_HANDLE_0(h_exception);
3629   }
3630   log_info(library)(&quot;Loaded library %s, handle &quot; INTPTR_FORMAT, name, p2i(load_result));
3631   return load_result;
3632 JVM_END
3633 
3634 
3635 JVM_LEAF(void, JVM_UnloadLibrary(void* handle))
3636   JVMWrapper(&quot;JVM_UnloadLibrary&quot;);
3637   os::dll_unload(handle);
3638   log_info(library)(&quot;Unloaded library with handle &quot; INTPTR_FORMAT, p2i(handle));
3639 JVM_END
3640 
3641 
3642 JVM_LEAF(void*, JVM_FindLibraryEntry(void* handle, const char* name))
3643   JVMWrapper(&quot;JVM_FindLibraryEntry&quot;);
3644   void* find_result = os::dll_lookup(handle, name);
3645   log_info(library)(&quot;%s %s in library with handle &quot; INTPTR_FORMAT,
3646                     find_result != NULL ? &quot;Found&quot; : &quot;Failed to find&quot;,
3647                     name, p2i(handle));
3648   return find_result;
3649 JVM_END
3650 
3651 
3652 // JNI version ///////////////////////////////////////////////////////////////////////////////
3653 
3654 JVM_LEAF(jboolean, JVM_IsSupportedJNIVersion(jint version))
3655   JVMWrapper(&quot;JVM_IsSupportedJNIVersion&quot;);
3656   return Threads::is_supported_jni_version_including_1_1(version);
3657 JVM_END
3658 
3659 
3660 // String support ///////////////////////////////////////////////////////////////////////////
3661 
3662 JVM_ENTRY(jstring, JVM_InternString(JNIEnv *env, jstring str))
3663   JVMWrapper(&quot;JVM_InternString&quot;);
3664   JvmtiVMObjectAllocEventCollector oam;
3665   if (str == NULL) return NULL;
3666   oop string = JNIHandles::resolve_non_null(str);
3667   oop result = StringTable::intern(string, CHECK_NULL);
3668   return (jstring) JNIHandles::make_local(env, result);
3669 JVM_END
3670 
3671 
3672 // VM Raw monitor support //////////////////////////////////////////////////////////////////////
3673 
3674 // VM Raw monitors (not to be confused with JvmtiRawMonitors) are a simple mutual exclusion
3675 // lock (not actually monitors: no wait/notify) that is exported by the VM for use by JDK
3676 // library code. They may be used by JavaThreads and non-JavaThreads and do not participate
3677 // in the safepoint protocol, thread suspension, thread interruption, or anything of that
3678 // nature. JavaThreads will be &quot;in native&quot; when using this API from JDK code.
3679 
3680 
3681 JNIEXPORT void* JNICALL JVM_RawMonitorCreate(void) {
3682   VM_Exit::block_if_vm_exited();
3683   JVMWrapper(&quot;JVM_RawMonitorCreate&quot;);
3684   return new os::PlatformMutex();
3685 }
3686 
3687 
3688 JNIEXPORT void JNICALL  JVM_RawMonitorDestroy(void *mon) {
3689   VM_Exit::block_if_vm_exited();
3690   JVMWrapper(&quot;JVM_RawMonitorDestroy&quot;);
3691   delete ((os::PlatformMutex*) mon);
3692 }
3693 
3694 
3695 JNIEXPORT jint JNICALL JVM_RawMonitorEnter(void *mon) {
3696   VM_Exit::block_if_vm_exited();
3697   JVMWrapper(&quot;JVM_RawMonitorEnter&quot;);
3698   ((os::PlatformMutex*) mon)-&gt;lock();
3699   return 0;
3700 }
3701 
3702 
3703 JNIEXPORT void JNICALL JVM_RawMonitorExit(void *mon) {
3704   VM_Exit::block_if_vm_exited();
3705   JVMWrapper(&quot;JVM_RawMonitorExit&quot;);
3706   ((os::PlatformMutex*) mon)-&gt;unlock();
3707 }
3708 
3709 
3710 // Shared JNI/JVM entry points //////////////////////////////////////////////////////////////
3711 
3712 jclass find_class_from_class_loader(JNIEnv* env, Symbol* name, jboolean init,
3713                                     Handle loader, Handle protection_domain,
3714                                     jboolean throwError, TRAPS) {
3715   // Security Note:
3716   //   The Java level wrapper will perform the necessary security check allowing
3717   //   us to pass the NULL as the initiating class loader.  The VM is responsible for
3718   //   the checkPackageAccess relative to the initiating class loader via the
3719   //   protection_domain. The protection_domain is passed as NULL by the java code
3720   //   if there is no security manager in 3-arg Class.forName().
3721   Klass* klass = SystemDictionary::resolve_or_fail(name, loader, protection_domain, throwError != 0, CHECK_NULL);
3722 
3723   // Check if we should initialize the class
3724   if (init &amp;&amp; klass-&gt;is_instance_klass()) {
3725     klass-&gt;initialize(CHECK_NULL);
3726   }
3727   return (jclass) JNIHandles::make_local(env, klass-&gt;java_mirror());
3728 }
3729 
3730 
3731 // Method ///////////////////////////////////////////////////////////////////////////////////////////
3732 
3733 JVM_ENTRY(jobject, JVM_InvokeMethod(JNIEnv *env, jobject method, jobject obj, jobjectArray args0))
3734   JVMWrapper(&quot;JVM_InvokeMethod&quot;);
3735   Handle method_handle;
3736   if (thread-&gt;stack_available((address) &amp;method_handle) &gt;= JVMInvokeMethodSlack) {
3737     method_handle = Handle(THREAD, JNIHandles::resolve(method));
3738     Handle receiver(THREAD, JNIHandles::resolve(obj));
3739     objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);
3740     oop result = Reflection::invoke_method(method_handle(), receiver, args, CHECK_NULL);
3741     jobject res = JNIHandles::make_local(env, result);
3742     if (JvmtiExport::should_post_vm_object_alloc()) {
3743       oop ret_type = java_lang_reflect_Method::return_type(method_handle());
3744       assert(ret_type != NULL, &quot;sanity check: ret_type oop must not be NULL!&quot;);
3745       if (java_lang_Class::is_primitive(ret_type)) {
3746         // Only for primitive type vm allocates memory for java object.
3747         // See box() method.
3748         JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3749       }
3750     }
3751     return res;
3752   } else {
3753     THROW_0(vmSymbols::java_lang_StackOverflowError());
3754   }
3755 JVM_END
3756 
3757 
3758 JVM_ENTRY(jobject, JVM_NewInstanceFromConstructor(JNIEnv *env, jobject c, jobjectArray args0))
3759   JVMWrapper(&quot;JVM_NewInstanceFromConstructor&quot;);
3760   objArrayHandle args = oopFactory::ensure_objArray(JNIHandles::resolve(args0), CHECK_NULL);
3761   oop constructor_mirror = JNIHandles::resolve(c);
3762   oop result = Reflection::invoke_constructor(constructor_mirror, args, CHECK_NULL);
3763   jobject res = JNIHandles::make_local(env, result);
3764   if (JvmtiExport::should_post_vm_object_alloc()) {
3765     JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);
3766   }
3767   return res;
3768 JVM_END
3769 
3770 // Atomic ///////////////////////////////////////////////////////////////////////////////////////////
3771 
3772 JVM_LEAF(jboolean, JVM_SupportsCX8())
3773   JVMWrapper(&quot;JVM_SupportsCX8&quot;);
3774   return VM_Version::supports_cx8();
3775 JVM_END
3776 
3777 JVM_ENTRY(void, JVM_InitializeFromArchive(JNIEnv* env, jclass cls))
3778   JVMWrapper(&quot;JVM_InitializeFromArchive&quot;);
3779   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
3780   assert(k-&gt;is_klass(), &quot;just checking&quot;);
3781   HeapShared::initialize_from_archived_subgraph(k);
3782 JVM_END
3783 
<a name="3" id="anc3"></a>










































































































3784 JVM_ENTRY_NO_ENV(jlong, JVM_GetRandomSeedForCDSDump())
3785   JVMWrapper(&quot;JVM_GetRandomSeedForCDSDump&quot;);
3786   if (DumpSharedSpaces) {
3787     const char* release = Abstract_VM_Version::vm_release();
3788     const char* dbg_level = Abstract_VM_Version::jdk_debug_level();
3789     const char* version = VM_Version::internal_vm_info_string();
3790     jlong seed = (jlong)(java_lang_String::hash_code((const jbyte*)release, (int)strlen(release)) ^
3791                          java_lang_String::hash_code((const jbyte*)dbg_level, (int)strlen(dbg_level)) ^
3792                          java_lang_String::hash_code((const jbyte*)version, (int)strlen(version)));
3793     seed += (jlong)Abstract_VM_Version::vm_major_version();
3794     seed += (jlong)Abstract_VM_Version::vm_minor_version();
3795     seed += (jlong)Abstract_VM_Version::vm_security_version();
3796     seed += (jlong)Abstract_VM_Version::vm_patch_version();
3797     if (seed == 0) { // don&#39;t let this ever be zero.
3798       seed = 0x87654321;
3799     }
3800     log_debug(cds)(&quot;JVM_GetRandomSeedForCDSDump() = &quot; JLONG_FORMAT, seed);
3801     return seed;
3802   } else {
3803     return 0;
3804   }
3805 JVM_END
3806 
3807 // Returns an array of all live Thread objects (VM internal JavaThreads,
3808 // jvmti agent threads, and JNI attaching threads  are skipped)
3809 // See CR 6404306 regarding JNI attaching threads
3810 JVM_ENTRY(jobjectArray, JVM_GetAllThreads(JNIEnv *env, jclass dummy))
3811   ResourceMark rm(THREAD);
3812   ThreadsListEnumerator tle(THREAD, false, false);
3813   JvmtiVMObjectAllocEventCollector oam;
3814 
3815   int num_threads = tle.num_threads();
3816   objArrayOop r = oopFactory::new_objArray(SystemDictionary::Thread_klass(), num_threads, CHECK_NULL);
3817   objArrayHandle threads_ah(THREAD, r);
3818 
3819   for (int i = 0; i &lt; num_threads; i++) {
3820     Handle h = tle.get_threadObj(i);
3821     threads_ah-&gt;obj_at_put(i, h());
3822   }
3823 
3824   return (jobjectArray) JNIHandles::make_local(env, threads_ah());
3825 JVM_END
3826 
3827 
3828 // Support for java.lang.Thread.getStackTrace() and getAllStackTraces() methods
3829 // Return StackTraceElement[][], each element is the stack trace of a thread in
3830 // the corresponding entry in the given threads array
3831 JVM_ENTRY(jobjectArray, JVM_DumpThreads(JNIEnv *env, jclass threadClass, jobjectArray threads))
3832   JVMWrapper(&quot;JVM_DumpThreads&quot;);
3833   JvmtiVMObjectAllocEventCollector oam;
3834 
3835   // Check if threads is null
3836   if (threads == NULL) {
3837     THROW_(vmSymbols::java_lang_NullPointerException(), 0);
3838   }
3839 
3840   objArrayOop a = objArrayOop(JNIHandles::resolve_non_null(threads));
3841   objArrayHandle ah(THREAD, a);
3842   int num_threads = ah-&gt;length();
3843   // check if threads is non-empty array
3844   if (num_threads == 0) {
3845     THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);
3846   }
3847 
3848   // check if threads is not an array of objects of Thread class
3849   Klass* k = ObjArrayKlass::cast(ah-&gt;klass())-&gt;element_klass();
3850   if (k != SystemDictionary::Thread_klass()) {
3851     THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);
3852   }
3853 
3854   ResourceMark rm(THREAD);
3855 
3856   GrowableArray&lt;instanceHandle&gt;* thread_handle_array = new GrowableArray&lt;instanceHandle&gt;(num_threads);
3857   for (int i = 0; i &lt; num_threads; i++) {
3858     oop thread_obj = ah-&gt;obj_at(i);
3859     instanceHandle h(THREAD, (instanceOop) thread_obj);
3860     thread_handle_array-&gt;append(h);
3861   }
3862 
3863   // The JavaThread references in thread_handle_array are validated
3864   // in VM_ThreadDump::doit().
3865   Handle stacktraces = ThreadService::dump_stack_traces(thread_handle_array, num_threads, CHECK_NULL);
3866   return (jobjectArray)JNIHandles::make_local(env, stacktraces());
3867 
3868 JVM_END
3869 
3870 // JVM monitoring and management support
3871 JVM_ENTRY_NO_ENV(void*, JVM_GetManagement(jint version))
3872   return Management::get_jmm_interface(version);
3873 JVM_END
3874 
3875 // com.sun.tools.attach.VirtualMachine agent properties support
3876 //
3877 // Initialize the agent properties with the properties maintained in the VM
3878 JVM_ENTRY(jobject, JVM_InitAgentProperties(JNIEnv *env, jobject properties))
3879   JVMWrapper(&quot;JVM_InitAgentProperties&quot;);
3880   ResourceMark rm;
3881 
3882   Handle props(THREAD, JNIHandles::resolve_non_null(properties));
3883 
3884   PUTPROP(props, &quot;sun.java.command&quot;, Arguments::java_command());
3885   PUTPROP(props, &quot;sun.jvm.flags&quot;, Arguments::jvm_flags());
3886   PUTPROP(props, &quot;sun.jvm.args&quot;, Arguments::jvm_args());
3887   return properties;
3888 JVM_END
3889 
3890 JVM_ENTRY(jobjectArray, JVM_GetEnclosingMethodInfo(JNIEnv *env, jclass ofClass))
3891 {
3892   JVMWrapper(&quot;JVM_GetEnclosingMethodInfo&quot;);
3893   JvmtiVMObjectAllocEventCollector oam;
3894 
3895   if (ofClass == NULL) {
3896     return NULL;
3897   }
3898   Handle mirror(THREAD, JNIHandles::resolve_non_null(ofClass));
3899   // Special handling for primitive objects
3900   if (java_lang_Class::is_primitive(mirror())) {
3901     return NULL;
3902   }
3903   Klass* k = java_lang_Class::as_Klass(mirror());
3904   if (!k-&gt;is_instance_klass()) {
3905     return NULL;
3906   }
3907   InstanceKlass* ik = InstanceKlass::cast(k);
3908   int encl_method_class_idx = ik-&gt;enclosing_method_class_index();
3909   if (encl_method_class_idx == 0) {
3910     return NULL;
3911   }
3912   objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::Object_klass(), 3, CHECK_NULL);
3913   objArrayHandle dest(THREAD, dest_o);
3914   Klass* enc_k = ik-&gt;constants()-&gt;klass_at(encl_method_class_idx, CHECK_NULL);
3915   dest-&gt;obj_at_put(0, enc_k-&gt;java_mirror());
3916   int encl_method_method_idx = ik-&gt;enclosing_method_method_index();
3917   if (encl_method_method_idx != 0) {
3918     Symbol* sym = ik-&gt;constants()-&gt;symbol_at(
3919                         extract_low_short_from_int(
3920                           ik-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
3921     Handle str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
3922     dest-&gt;obj_at_put(1, str());
3923     sym = ik-&gt;constants()-&gt;symbol_at(
3924               extract_high_short_from_int(
3925                 ik-&gt;constants()-&gt;name_and_type_at(encl_method_method_idx)));
3926     str = java_lang_String::create_from_symbol(sym, CHECK_NULL);
3927     dest-&gt;obj_at_put(2, str());
3928   }
3929   return (jobjectArray) JNIHandles::make_local(dest());
3930 }
3931 JVM_END
3932 
3933 // Returns an array of java.lang.String objects containing the input arguments to the VM.
3934 JVM_ENTRY(jobjectArray, JVM_GetVmArguments(JNIEnv *env))
3935   ResourceMark rm(THREAD);
3936 
3937   if (Arguments::num_jvm_args() == 0 &amp;&amp; Arguments::num_jvm_flags() == 0) {
3938     return NULL;
3939   }
3940 
3941   char** vm_flags = Arguments::jvm_flags_array();
3942   char** vm_args = Arguments::jvm_args_array();
3943   int num_flags = Arguments::num_jvm_flags();
3944   int num_args = Arguments::num_jvm_args();
3945 
3946   InstanceKlass* ik = SystemDictionary::String_klass();
3947   objArrayOop r = oopFactory::new_objArray(ik, num_args + num_flags, CHECK_NULL);
3948   objArrayHandle result_h(THREAD, r);
3949 
3950   int index = 0;
3951   for (int j = 0; j &lt; num_flags; j++, index++) {
3952     Handle h = java_lang_String::create_from_platform_dependent_str(vm_flags[j], CHECK_NULL);
3953     result_h-&gt;obj_at_put(index, h());
3954   }
3955   for (int i = 0; i &lt; num_args; i++, index++) {
3956     Handle h = java_lang_String::create_from_platform_dependent_str(vm_args[i], CHECK_NULL);
3957     result_h-&gt;obj_at_put(index, h());
3958   }
3959   return (jobjectArray) JNIHandles::make_local(env, result_h());
3960 JVM_END
3961 
3962 JVM_ENTRY_NO_ENV(jint, JVM_FindSignal(const char *name))
3963   return os::get_signal_number(name);
3964 JVM_END
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
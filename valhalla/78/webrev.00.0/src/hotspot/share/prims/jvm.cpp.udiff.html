<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/prims/jvm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../opto/parse1.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiRedefineClasses.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/prims/jvm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -24,10 +24,11 @@</span>
  
  #include &quot;precompiled.hpp&quot;
  #include &quot;jvm.h&quot;
  #include &quot;classfile/classFileStream.hpp&quot;
  #include &quot;classfile/classLoader.hpp&quot;
<span class="udiff-line-added">+ #include &quot;classfile/classLoaderData.hpp&quot;</span>
  #include &quot;classfile/classLoaderData.inline.hpp&quot;
  #include &quot;classfile/javaAssertions.hpp&quot;
  #include &quot;classfile/javaClasses.inline.hpp&quot;
  #include &quot;classfile/moduleEntry.hpp&quot;
  #include &quot;classfile/modules.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -39,10 +40,11 @@</span>
  #include &quot;gc/shared/collectedHeap.inline.hpp&quot;
  #include &quot;interpreter/bytecode.hpp&quot;
  #include &quot;interpreter/bytecodeUtils.hpp&quot;
  #include &quot;jfr/jfrEvents.hpp&quot;
  #include &quot;logging/log.hpp&quot;
<span class="udiff-line-added">+ #include &quot;memory/dynamicArchive.hpp&quot;</span>
  #include &quot;memory/heapShared.hpp&quot;
  #include &quot;memory/oopFactory.hpp&quot;
  #include &quot;memory/referenceType.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3779,10 +3781,117 @@</span>
    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));
    assert(k-&gt;is_klass(), &quot;just checking&quot;);
    HeapShared::initialize_from_archived_subgraph(k);
  JVM_END
  
<span class="udiff-line-added">+ JVM_ENTRY(void, JVM_RegisterLambdaProxyClassForArchiving(JNIEnv* env,</span>
<span class="udiff-line-added">+                                               jclass caller,</span>
<span class="udiff-line-added">+                                               jstring invokedName,</span>
<span class="udiff-line-added">+                                               jobject invokedType,</span>
<span class="udiff-line-added">+                                               jobject methodType,</span>
<span class="udiff-line-added">+                                               jobject implMethodMember,</span>
<span class="udiff-line-added">+                                               jobject instantiatedMethodType,</span>
<span class="udiff-line-added">+                                               jclass lambdaProxyClass))</span>
<span class="udiff-line-added">+   JVMWrapper(&quot;JVM_RegisterLambdaProxyClassForArchiving&quot;);</span>
<span class="udiff-line-added">+   if (!DynamicDumpSharedSpaces) {</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Klass* caller_k = java_lang_Class::as_Klass(JNIHandles::resolve(caller));</span>
<span class="udiff-line-added">+   InstanceKlass* caller_ik = InstanceKlass::cast(caller_k);</span>
<span class="udiff-line-added">+   if (caller_ik-&gt;is_hidden() || caller_ik-&gt;is_unsafe_anonymous()) {</span>
<span class="udiff-line-added">+     // VM anonymous classes and hidden classes not of type lambda proxy classes are currently not being archived.</span>
<span class="udiff-line-added">+     // If the caller_ik is of one of the above types, the corresponding lambda proxy class won&#39;t be</span>
<span class="udiff-line-added">+     // registered for archiving.</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   Klass* lambda_k = java_lang_Class::as_Klass(JNIHandles::resolve(lambdaProxyClass));</span>
<span class="udiff-line-added">+   InstanceKlass* lambda_ik = InstanceKlass::cast(lambda_k);</span>
<span class="udiff-line-added">+   assert(lambda_ik-&gt;is_hidden(), &quot;must be a hidden class&quot;);</span>
<span class="udiff-line-added">+   assert(!lambda_ik-&gt;is_non_strong_hidden(), &quot;expected a strong hidden class&quot;);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Symbol* invoked_name = NULL;</span>
<span class="udiff-line-added">+   if (invokedName != NULL) {</span>
<span class="udiff-line-added">+     invoked_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(invokedName));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   Handle invoked_type_oop(THREAD, JNIHandles::resolve_non_null(invokedType));</span>
<span class="udiff-line-added">+   Symbol* invoked_type = java_lang_invoke_MethodType::as_signature(invoked_type_oop(), true);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Handle method_type_oop(THREAD, JNIHandles::resolve_non_null(methodType));</span>
<span class="udiff-line-added">+   Symbol* method_type = java_lang_invoke_MethodType::as_signature(method_type_oop(), true);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Handle impl_method_member_oop(THREAD, JNIHandles::resolve_non_null(implMethodMember));</span>
<span class="udiff-line-added">+   assert(java_lang_invoke_MemberName::is_method(impl_method_member_oop()), &quot;must be&quot;);</span>
<span class="udiff-line-added">+   Method* m = java_lang_invoke_MemberName::vmtarget(impl_method_member_oop());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Handle instantiated_method_type_oop(THREAD, JNIHandles::resolve_non_null(instantiatedMethodType));</span>
<span class="udiff-line-added">+   Symbol* instantiated_method_type = java_lang_invoke_MethodType::as_signature(instantiated_method_type_oop(), true);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   SystemDictionaryShared::add_lambda_proxy_class(caller_ik, lambda_ik, invoked_name, invoked_type,</span>
<span class="udiff-line-added">+                                                  method_type, m, instantiated_method_type);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ JVM_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ JVM_ENTRY(jclass, JVM_LookupLambdaProxyClassFromArchive(JNIEnv* env,</span>
<span class="udiff-line-added">+                                                         jclass caller,</span>
<span class="udiff-line-added">+                                                         jstring invokedName,</span>
<span class="udiff-line-added">+                                                         jobject invokedType,</span>
<span class="udiff-line-added">+                                                         jobject methodType,</span>
<span class="udiff-line-added">+                                                         jobject implMethodMember,</span>
<span class="udiff-line-added">+                                                         jobject instantiatedMethodType,</span>
<span class="udiff-line-added">+                                                         jboolean initialize))</span>
<span class="udiff-line-added">+   JVMWrapper(&quot;JVM_LookupLambdaProxyClassFromArchive&quot;);</span>
<span class="udiff-line-added">+   if (!DynamicArchive::is_mapped()) {</span>
<span class="udiff-line-added">+     return NULL;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (invokedName == NULL || invokedType == NULL || methodType == NULL ||</span>
<span class="udiff-line-added">+       implMethodMember == NULL || instantiatedMethodType == NULL) {</span>
<span class="udiff-line-added">+     THROW_(vmSymbols::java_lang_NullPointerException(), NULL);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Klass* caller_k = java_lang_Class::as_Klass(JNIHandles::resolve(caller));</span>
<span class="udiff-line-added">+   InstanceKlass* caller_ik = InstanceKlass::cast(caller_k);</span>
<span class="udiff-line-added">+   if (!caller_ik-&gt;is_shared()) {</span>
<span class="udiff-line-added">+     // there won&#39;t be a shared lambda class if the caller_ik is not in the shared archive.</span>
<span class="udiff-line-added">+     return NULL;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Symbol* invoked_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(invokedName));</span>
<span class="udiff-line-added">+   Handle invoked_type_oop(THREAD, JNIHandles::resolve_non_null(invokedType));</span>
<span class="udiff-line-added">+   Symbol* invoked_type = java_lang_invoke_MethodType::as_signature(invoked_type_oop(), true);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Handle method_type_oop(THREAD, JNIHandles::resolve_non_null(methodType));</span>
<span class="udiff-line-added">+   Symbol* method_type = java_lang_invoke_MethodType::as_signature(method_type_oop(), true);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Handle impl_method_member_oop(THREAD, JNIHandles::resolve_non_null(implMethodMember));</span>
<span class="udiff-line-added">+   assert(java_lang_invoke_MemberName::is_method(impl_method_member_oop()), &quot;must be&quot;);</span>
<span class="udiff-line-added">+   Method* m = java_lang_invoke_MemberName::vmtarget(impl_method_member_oop());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   Handle instantiated_method_type_oop(THREAD, JNIHandles::resolve_non_null(instantiatedMethodType));</span>
<span class="udiff-line-added">+   Symbol* instantiated_method_type = java_lang_invoke_MethodType::as_signature(instantiated_method_type_oop(), true);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   InstanceKlass* lambda_ik = SystemDictionaryShared::get_shared_lambda_proxy_class(caller_ik, invoked_name, invoked_type,</span>
<span class="udiff-line-added">+                                                                                    method_type, m, instantiated_method_type);</span>
<span class="udiff-line-added">+   jclass jcls = NULL;</span>
<span class="udiff-line-added">+   if (lambda_ik != NULL) {</span>
<span class="udiff-line-added">+     InstanceKlass* loaded_lambda = SystemDictionaryShared::prepare_shared_lambda_proxy_class(lambda_ik, caller_ik, initialize, THREAD);</span>
<span class="udiff-line-added">+     jcls = loaded_lambda == NULL ? NULL : (jclass) JNIHandles::make_local(env, loaded_lambda-&gt;java_mirror());</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   return jcls;</span>
<span class="udiff-line-added">+ JVM_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ JVM_ENTRY(jboolean, JVM_IsCDSDumpingEnabled(JNIEnv* env))</span>
<span class="udiff-line-added">+     JVMWrapper(&quot;JVM_IsCDSDumpingEnable&quot;);</span>
<span class="udiff-line-added">+     return DynamicDumpSharedSpaces;</span>
<span class="udiff-line-added">+ JVM_END</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ JVM_ENTRY(jboolean, JVM_IsCDSSharingEnabled(JNIEnv* env))</span>
<span class="udiff-line-added">+     JVMWrapper(&quot;JVM_IsCDSSharingEnable&quot;);</span>
<span class="udiff-line-added">+     return UseSharedSpaces;</span>
<span class="udiff-line-added">+ JVM_END</span>
<span class="udiff-line-added">+ </span>
  JVM_ENTRY_NO_ENV(jlong, JVM_GetRandomSeedForCDSDump())
    JVMWrapper(&quot;JVM_GetRandomSeedForCDSDump&quot;);
    if (DumpSharedSpaces) {
      const char* release = Abstract_VM_Version::vm_release();
      const char* dbg_level = Abstract_VM_Version::jdk_debug_level();
</pre>
<center><a href="../opto/parse1.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="jvmtiRedefineClasses.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/share/services/heapDumper.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="diagnosticCommand.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/share/classes/java/lang/invoke/InnerClassLambdaMetafactory.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/services/heapDumper.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -30,10 +30,11 @@</span>
  #include &quot;classfile/symbolTable.hpp&quot;
  #include &quot;classfile/systemDictionary.hpp&quot;
  #include &quot;classfile/vmSymbols.hpp&quot;
  #include &quot;gc/shared/gcLocker.hpp&quot;
  #include &quot;gc/shared/gcVMOperations.hpp&quot;
<span class="udiff-line-added">+ #include &quot;gc/shared/workgroup.hpp&quot;</span>
  #include &quot;jfr/jfrEvents.hpp&quot;
  #include &quot;memory/allocation.inline.hpp&quot;
  #include &quot;memory/resourceArea.hpp&quot;
  #include &quot;memory/universe.hpp&quot;
  #include &quot;oops/objArrayKlass.hpp&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -50,10 +51,11 @@</span>
  #include &quot;runtime/threadSMR.hpp&quot;
  #include &quot;runtime/vframe.hpp&quot;
  #include &quot;runtime/vmThread.hpp&quot;
  #include &quot;runtime/vmOperations.hpp&quot;
  #include &quot;services/heapDumper.hpp&quot;
<span class="udiff-line-added">+ #include &quot;services/heapDumperCompression.hpp&quot;</span>
  #include &quot;services/threadService.hpp&quot;
  #include &quot;utilities/macros.hpp&quot;
  #include &quot;utilities/ostream.hpp&quot;
  
  /*
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -375,64 +377,58 @@</span>
  enum {
    STACK_TRACE_ID = 1,
    INITIAL_CLASS_COUNT = 200
  };
  
<span class="udiff-line-modified-removed">- // Supports I/O operations on a dump file</span>
<span class="udiff-line-modified-added">+ // Supports I/O operations for a dump</span>
  
  class DumpWriter : public StackObj {
   private:
    enum {
<span class="udiff-line-modified-removed">-     io_buffer_max_size = 8*M,</span>
<span class="udiff-line-modified-removed">-     io_buffer_min_size = 64*K,</span>
<span class="udiff-line-modified-added">+     io_buffer_max_size = 1*M,</span>
<span class="udiff-line-modified-added">+     io_buffer_max_waste = 10*K,</span>
      dump_segment_header_size = 9
    };
  
<span class="udiff-line-removed">-   int _fd;              // file descriptor (-1 if dump file not open)</span>
<span class="udiff-line-removed">-   julong _bytes_written; // number of byte written to dump file</span>
<span class="udiff-line-removed">- </span>
    char* _buffer;    // internal buffer
    size_t _size;
    size_t _pos;
  
    bool _in_dump_segment; // Are we currently in a dump segment?
    bool _is_huge_sub_record; // Are we writing a sub-record larger than the buffer size?
    DEBUG_ONLY(size_t _sub_record_left;) // The bytes not written for the current sub-record.
    DEBUG_ONLY(bool _sub_record_ended;) // True if we have called the end_sub_record().
  
<span class="udiff-line-modified-removed">-   char* _error;   // error message when I/O fails</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   void set_file_descriptor(int fd)              { _fd = fd; }</span>
<span class="udiff-line-removed">-   int file_descriptor() const                   { return _fd; }</span>
<span class="udiff-line-modified-added">+   CompressionBackend _backend; // Does the actual writing.</span>
  
<span class="udiff-line-removed">-   bool is_open() const                          { return file_descriptor() &gt;= 0; }</span>
    void flush();
  
    char* buffer() const                          { return _buffer; }
    size_t buffer_size() const                    { return _size; }
    size_t position() const                       { return _pos; }
    void set_position(size_t pos)                 { _pos = pos; }
  
<span class="udiff-line-modified-removed">-   void set_error(const char* error)             { _error = (char*)os::strdup(error); }</span>
<span class="udiff-line-modified-added">+   // Can be called if we have enough room in the buffer.</span>
<span class="udiff-line-added">+   void write_fast(void* s, size_t len);</span>
  
<span class="udiff-line-modified-removed">-   // all I/O go through this function</span>
<span class="udiff-line-modified-removed">-   void write_internal(void* s, size_t len);</span>
<span class="udiff-line-modified-added">+   // Returns true if we have enough room in the buffer for &#39;len&#39; bytes.</span>
<span class="udiff-line-modified-added">+   bool can_write_fast(size_t len);</span>
  
   public:
<span class="udiff-line-modified-removed">-   DumpWriter(const char* path);</span>
<span class="udiff-line-modified-removed">-   ~DumpWriter();</span>
<span class="udiff-line-modified-added">+   // Takes ownership of the writer and compressor.</span>
<span class="udiff-line-modified-added">+   DumpWriter(AbstractWriter* writer, AbstractCompressor* compressor);</span>
  
<span class="udiff-line-modified-removed">-   void close();</span>
<span class="udiff-line-modified-added">+   ~DumpWriter();</span>
  
    // total number of bytes written to the disk
<span class="udiff-line-modified-removed">-   julong bytes_written() const          { return _bytes_written; }</span>
<span class="udiff-line-modified-added">+   julong bytes_written() const          { return (julong) _backend.get_written(); }</span>
  
<span class="udiff-line-modified-removed">-   char* error() const                   { return _error; }</span>
<span class="udiff-line-modified-added">+   char const* error() const             { return _backend.error(); }</span>
  
    // writer functions
    void write_raw(void* s, size_t len);
<span class="udiff-line-modified-removed">-   void write_u1(u1 x)                   { write_raw((void*)&amp;x, 1); }</span>
<span class="udiff-line-modified-added">+   void write_u1(u1 x);</span>
    void write_u2(u2 x);
    void write_u4(u4 x);
    void write_u8(u8 x);
    void write_objectID(oop o);
    void write_symbolID(Symbol* o);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -443,120 +439,95 @@</span>
    void start_sub_record(u1 tag, u4 len);
    // Ends the current sub-record.
    void end_sub_record();
    // Finishes the current dump segment if not already finished.
    void finish_dump_segment();
<span class="udiff-line-modified-removed">- };</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- DumpWriter::DumpWriter(const char* path) : _fd(-1), _bytes_written(0), _pos(0),</span>
<span class="udiff-line-modified-removed">-                                            _in_dump_segment(false), _error(NULL) {</span>
<span class="udiff-line-modified-removed">-   // try to allocate an I/O buffer of io_buffer_size. If there isn&#39;t</span>
<span class="udiff-line-removed">-   // sufficient memory then reduce size until we can allocate something.</span>
<span class="udiff-line-removed">-   _size = io_buffer_max_size;</span>
<span class="udiff-line-removed">-   do {</span>
<span class="udiff-line-removed">-     _buffer = (char*)os::malloc(_size, mtInternal);</span>
<span class="udiff-line-removed">-     if (_buffer == NULL) {</span>
<span class="udiff-line-removed">-       _size = _size &gt;&gt; 1;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   } while (_buffer == NULL &amp;&amp; _size &gt;= io_buffer_min_size);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   if (_buffer == NULL) {</span>
<span class="udiff-line-removed">-     set_error(&quot;Could not allocate buffer memory for heap dump&quot;);</span>
<span class="udiff-line-removed">-   } else {</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   // Called by threads used for parallel writing.</span>
<span class="udiff-line-modified-added">+   void writer_loop()                    { _backend.thread_loop(false); }</span>
<span class="udiff-line-modified-added">+   // Called when finished to release the threads.</span>
<span class="udiff-line-modified-added">+   void deactivate()                     { flush(); _backend.deactivate(); }</span>
  };
  
<span class="udiff-line-modified-removed">-     // if the open failed we record the error</span>
<span class="udiff-line-modified-removed">-     if (_fd &lt; 0) {</span>
<span class="udiff-line-modified-removed">-       set_error(os::strerror(errno));</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-added">+ // Check for error after constructing the object and destroy it in case of an error.</span>
<span class="udiff-line-modified-added">+ DumpWriter::DumpWriter(AbstractWriter* writer, AbstractCompressor* compressor) :</span>
<span class="udiff-line-modified-added">+   _buffer(NULL),</span>
<span class="udiff-line-modified-added">+   _size(0),</span>
<span class="udiff-line-modified-added">+   _pos(0),</span>
<span class="udiff-line-added">+   _in_dump_segment(false),</span>
<span class="udiff-line-added">+   _backend(writer, compressor, io_buffer_max_size, io_buffer_max_waste) {</span>
<span class="udiff-line-added">+   flush();</span>
  }
  
  DumpWriter::~DumpWriter() {
<span class="udiff-line-modified-removed">-   close();</span>
<span class="udiff-line-removed">-   os::free(_buffer);</span>
<span class="udiff-line-removed">-   os::free(_error);</span>
<span class="udiff-line-modified-added">+   flush();</span>
  }
  
<span class="udiff-line-modified-removed">- // closes dump file (if open)</span>
<span class="udiff-line-modified-removed">- void DumpWriter::close() {</span>
<span class="udiff-line-modified-removed">-   // flush and close dump file</span>
<span class="udiff-line-modified-removed">-   if (is_open()) {</span>
<span class="udiff-line-removed">-     flush();</span>
<span class="udiff-line-removed">-     os::close(file_descriptor());</span>
<span class="udiff-line-removed">-     set_file_descriptor(-1);</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-modified-added">+ void DumpWriter::write_fast(void* s, size_t len) {</span>
<span class="udiff-line-modified-added">+   assert(!_in_dump_segment || (_sub_record_left &gt;= len), &quot;sub-record too large&quot;);</span>
<span class="udiff-line-modified-added">+   assert(buffer_size() - position() &gt;= len, &quot;Must fit&quot;);</span>
<span class="udiff-line-modified-added">+   debug_only(_sub_record_left -= len);</span>
  
<span class="udiff-line-modified-removed">- // write directly to the file</span>
<span class="udiff-line-modified-removed">- void DumpWriter::write_internal(void* s, size_t len) {</span>
<span class="udiff-line-modified-removed">-   if (is_open()) {</span>
<span class="udiff-line-removed">-     const char* pos = (char*)s;</span>
<span class="udiff-line-removed">-     ssize_t n = 0;</span>
<span class="udiff-line-removed">-     while (len &gt; 0) {</span>
<span class="udiff-line-removed">-       uint tmp = (uint)MIN2(len, (size_t)INT_MAX);</span>
<span class="udiff-line-removed">-       n = os::write(file_descriptor(), pos, tmp);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       if (n &lt; 0) {</span>
<span class="udiff-line-removed">-         // EINTR cannot happen here, os::write will take care of that</span>
<span class="udiff-line-removed">-         set_error(os::strerror(errno));</span>
<span class="udiff-line-removed">-         os::close(file_descriptor());</span>
<span class="udiff-line-removed">-         set_file_descriptor(-1);</span>
<span class="udiff-line-removed">-         return;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-modified-added">+   memcpy(buffer() + position(), s, len);</span>
<span class="udiff-line-modified-added">+   set_position(position() + len);</span>
<span class="udiff-line-modified-added">+ }</span>
  
<span class="udiff-line-modified-removed">-       _bytes_written += n;</span>
<span class="udiff-line-modified-removed">-       pos += n;</span>
<span class="udiff-line-removed">-       len -= n;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+ bool DumpWriter::can_write_fast(size_t len) {</span>
<span class="udiff-line-modified-added">+   return buffer_size() - position() &gt;= len;</span>
  }
  
  // write raw bytes
  void DumpWriter::write_raw(void* s, size_t len) {
    assert(!_in_dump_segment || (_sub_record_left &gt;= len), &quot;sub-record too large&quot;);
    debug_only(_sub_record_left -= len);
  
<span class="udiff-line-modified-removed">-   // flush buffer to make room</span>
<span class="udiff-line-modified-removed">-   if (len &gt; buffer_size() - position()) {</span>
<span class="udiff-line-modified-removed">-     assert(!_in_dump_segment || _is_huge_sub_record, &quot;Cannot overflow in non-huge sub-record.&quot;);</span>
<span class="udiff-line-modified-removed">-     flush();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // If larger than the buffer, just write it directly.</span>
<span class="udiff-line-removed">-     if (len &gt; buffer_size()) {</span>
<span class="udiff-line-removed">-       write_internal(s, len);</span>
<span class="udiff-line-modified-added">+   // flush buffer to make room.</span>
<span class="udiff-line-modified-added">+   while (len &gt; buffer_size() - position()) {</span>
<span class="udiff-line-modified-added">+     assert(!_in_dump_segment || _is_huge_sub_record,</span>
<span class="udiff-line-modified-added">+            &quot;Cannot overflow in non-huge sub-record.&quot;);</span>
  
<span class="udiff-line-modified-removed">-       return;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     size_t to_write = buffer_size() - position();</span>
<span class="udiff-line-modified-added">+     memcpy(buffer() + position(), s, to_write);</span>
<span class="udiff-line-added">+     s = (void*) ((char*) s + to_write);</span>
<span class="udiff-line-added">+     len -= to_write;</span>
<span class="udiff-line-added">+     set_position(position() + to_write);</span>
<span class="udiff-line-added">+     flush();</span>
    }
  
    memcpy(buffer() + position(), s, len);
    set_position(position() + len);
  }
  
  // flush any buffered bytes to the file
  void DumpWriter::flush() {
<span class="udiff-line-modified-removed">-   write_internal(buffer(), position());</span>
<span class="udiff-line-modified-removed">-   set_position(0);</span>
<span class="udiff-line-modified-added">+   _backend.get_new_buffer(&amp;_buffer, &amp;_pos, &amp;_size);</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ // Makes sure we inline the fast write into the write_u* functions. This is a big speedup.</span>
<span class="udiff-line-added">+ #define WRITE_KNOWN_TYPE(p, len) do { if (can_write_fast((len))) write_fast((p), (len)); \</span>
<span class="udiff-line-added">+                                       else write_raw((p), (len)); } while (0)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void DumpWriter::write_u1(u1 x) {</span>
<span class="udiff-line-added">+   WRITE_KNOWN_TYPE((void*) &amp;x, 1);</span>
  }
  
  void DumpWriter::write_u2(u2 x) {
    u2 v;
    Bytes::put_Java_u2((address)&amp;v, x);
<span class="udiff-line-modified-removed">-   write_raw((void*)&amp;v, 2);</span>
<span class="udiff-line-modified-added">+   WRITE_KNOWN_TYPE((void*)&amp;v, 2);</span>
  }
  
  void DumpWriter::write_u4(u4 x) {
    u4 v;
    Bytes::put_Java_u4((address)&amp;v, x);
<span class="udiff-line-modified-removed">-   write_raw((void*)&amp;v, 4);</span>
<span class="udiff-line-modified-added">+   WRITE_KNOWN_TYPE((void*)&amp;v, 4);</span>
  }
  
  void DumpWriter::write_u8(u8 x) {
    u8 v;
    Bytes::put_Java_u8((address)&amp;v, x);
<span class="udiff-line-modified-removed">-   write_raw((void*)&amp;v, 8);</span>
<span class="udiff-line-modified-added">+   WRITE_KNOWN_TYPE((void*)&amp;v, 8);</span>
  }
  
  void DumpWriter::write_objectID(oop o) {
    address a = cast_from_oop&lt;address&gt;(o);
  #ifdef _LP64
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -595,11 +566,12 @@</span>
  
      // Fix up the dump segment length if we haven&#39;t written a huge sub-record last
      // (in which case the segment length was already set to the correct value initially).
      if (!_is_huge_sub_record) {
        assert(position() &gt; dump_segment_header_size, &quot;Dump segment should have some content&quot;);
<span class="udiff-line-modified-removed">-       Bytes::put_Java_u4((address) (buffer() + 5), (u4) (position() - dump_segment_header_size));</span>
<span class="udiff-line-modified-added">+       Bytes::put_Java_u4((address) (buffer() + 5),</span>
<span class="udiff-line-added">+                          (u4) (position() - dump_segment_header_size));</span>
      }
  
      flush();
      _in_dump_segment = false;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -607,13 +579,14 @@</span>
  
  void DumpWriter::start_sub_record(u1 tag, u4 len) {
    if (!_in_dump_segment) {
      if (position() &gt; 0) {
        flush();
<span class="udiff-line-removed">-       assert(position() == 0, &quot;Must be at the start&quot;);</span>
      }
  
<span class="udiff-line-added">+     assert(position() == 0, &quot;Must be at the start&quot;);</span>
<span class="udiff-line-added">+ </span>
      write_u1(HPROF_HEAP_DUMP_SEGMENT);
      write_u4(0); // timestamp
      // Will be fixed up later if we add more sub-records.  If this is a huge sub-record,
      // this is already the correct length, since we don&#39;t add more sub-records.
      write_u4(len);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1501,11 +1474,11 @@</span>
      DumperSupport::dump_prim_array(writer(), typeArrayOop(o));
    }
  }
  
  // The VM operation that performs the heap dump
<span class="udiff-line-modified-removed">- class VM_HeapDumper : public VM_GC_Operation {</span>
<span class="udiff-line-modified-added">+ class VM_HeapDumper : public VM_GC_Operation, public AbstractGangTask {</span>
   private:
    static VM_HeapDumper* _global_dumper;
    static DumpWriter*    _global_writer;
    DumpWriter*           _local_writer;
    JavaThread*           _oome_thread;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1557,11 +1530,12 @@</span>
   public:
    VM_HeapDumper(DumpWriter* writer, bool gc_before_heap_dump, bool oome) :
      VM_GC_Operation(0 /* total collections,      dummy, ignored */,
                      GCCause::_heap_dump /* GC Cause */,
                      0 /* total full collections, dummy, ignored */,
<span class="udiff-line-modified-removed">-                     gc_before_heap_dump) {</span>
<span class="udiff-line-modified-added">+                     gc_before_heap_dump),</span>
<span class="udiff-line-added">+     AbstractGangTask(&quot;dump heap&quot;) {</span>
      _local_writer = writer;
      _gc_before_heap_dump = gc_before_heap_dump;
      _klass_map = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;Klass*&gt;(INITIAL_CLASS_COUNT, true);
      _stack_traces = NULL;
      _num_threads = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1588,12 +1562,14 @@</span>
      delete _klass_map;
    }
  
    VMOp_Type type() const { return VMOp_HeapDumper; }
    void doit();
<span class="udiff-line-added">+   void work(uint worker_id);</span>
  };
  
<span class="udiff-line-added">+ </span>
  VM_HeapDumper* VM_HeapDumper::_global_dumper = NULL;
  DumpWriter*    VM_HeapDumper::_global_writer = NULL;
  
  bool VM_HeapDumper::skip_operation() const {
    return false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1818,12 +1794,30 @@</span>
    // At this point we should be the only dumper active, so
    // the following should be safe.
    set_global_dumper();
    set_global_writer();
  
<span class="udiff-line-added">+   WorkGang* gang = ch-&gt;get_safepoint_workers();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (gang == NULL) {</span>
<span class="udiff-line-added">+     work(0);</span>
<span class="udiff-line-added">+   } else {</span>
<span class="udiff-line-added">+     gang-&gt;run_task(this, gang-&gt;active_workers(), true);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   // Now we clear the global variables, so that a future dumper can run.</span>
<span class="udiff-line-added">+   clear_global_dumper();</span>
<span class="udiff-line-added">+   clear_global_writer();</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void VM_HeapDumper::work(uint worker_id) {</span>
<span class="udiff-line-added">+   if (!Thread::current()-&gt;is_VM_thread()) {</span>
<span class="udiff-line-added">+     writer()-&gt;writer_loop();</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    // Write the file header - we always use 1.0.2
<span class="udiff-line-removed">-   size_t used = ch-&gt;used();</span>
    const char* header = &quot;JAVA PROFILE 1.0.2&quot;;
  
    // header is few bytes long - no chance to overflow int
    writer()-&gt;write_raw((void*)header, (int)strlen(header));
    writer()-&gt;write_u1(0); // terminator
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1882,13 +1876,12 @@</span>
    ClassLoaderData::the_null_class_loader_data()-&gt;classes_do(&amp;class_dumper);
  
    // Writes the HPROF_HEAP_DUMP_END record.
    DumperSupport::end_of_dump(writer());
  
<span class="udiff-line-modified-removed">-   // Now we clear the global variables, so that a future dumper might run.</span>
<span class="udiff-line-modified-removed">-   clear_global_dumper();</span>
<span class="udiff-line-removed">-   clear_global_writer();</span>
<span class="udiff-line-modified-added">+   // We are done with writing. Release the worker threads.</span>
<span class="udiff-line-modified-added">+   writer()-&gt;deactivate();</span>
  }
  
  void VM_HeapDumper::dump_stack_traces() {
    // write a HPROF_TRACE record without any frames to be referenced as object alloc sites
    DumperSupport::write_header(writer(), HPROF_TRACE, 3*sizeof(u4));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1900,10 +1893,11 @@</span>
    int frame_serial_num = 0;
    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {
      oop threadObj = thread-&gt;threadObj();
      if (threadObj != NULL &amp;&amp; !thread-&gt;is_exiting() &amp;&amp; !thread-&gt;is_hidden_from_external_view()) {
        // dump thread stack trace
<span class="udiff-line-added">+       ResourceMark rm;</span>
        ThreadStackTrace* stack_trace = new ThreadStackTrace(thread, false);
        stack_trace-&gt;dump_stack_at_safepoint(-1);
        _stack_traces[_num_threads++] = stack_trace;
  
        // write HPROF_FRAME records for this thread&#39;s stack trace
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1942,11 +1936,11 @@</span>
      }
    }
  }
  
  // dump the heap to given path.
<span class="udiff-line-modified-removed">- int HeapDumper::dump(const char* path, outputStream* out) {</span>
<span class="udiff-line-modified-added">+ int HeapDumper::dump(const char* path, outputStream* out, int compression) {</span>
    assert(path != NULL &amp;&amp; strlen(path) &gt; 0, &quot;path missing&quot;);
  
    // print message in interactive case
    if (out != NULL) {
      out-&gt;print_cr(&quot;Dumping heap to %s ...&quot;, path);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1954,12 +1948,23 @@</span>
    }
  
    // create JFR event
    EventHeapDump event;
  
<span class="udiff-line-modified-removed">-   // create the dump writer. If the file can be opened then bail</span>
<span class="udiff-line-modified-removed">-   DumpWriter writer(path);</span>
<span class="udiff-line-modified-added">+   AbstractCompressor* compressor = NULL;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   if (compression &gt; 0) {</span>
<span class="udiff-line-added">+     compressor = new (std::nothrow) GZipCompressor(compression);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (compressor == NULL) {</span>
<span class="udiff-line-added">+       set_error(&quot;Could not allocate gzip compressor&quot;);</span>
<span class="udiff-line-added">+       return -1;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   DumpWriter writer(new (std::nothrow) FileWriter(path), compressor);</span>
<span class="udiff-line-added">+ </span>
    if (writer.error() != NULL) {
      set_error(writer.error());
      if (out != NULL) {
        out-&gt;print_cr(&quot;Unable to create %s: %s&quot;, path,
          (error() != NULL) ? error() : &quot;reason unknown&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1974,12 +1979,11 @@</span>
      dumper.doit();
    } else {
      VMThread::execute(&amp;dumper);
    }
  
<span class="udiff-line-modified-removed">-   // close dump file and record any error that the writer may have encountered</span>
<span class="udiff-line-removed">-   writer.close();</span>
<span class="udiff-line-modified-added">+   // record any error that the writer may have encountered</span>
    set_error(writer.error());
  
    // emit JFR event
    if (error() == NULL) {
      event.set_destination(path);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2022,11 +2026,11 @@</span>
      return NULL;
    }
  }
  
  // set the error string
<span class="udiff-line-modified-removed">- void HeapDumper::set_error(char* error) {</span>
<span class="udiff-line-modified-added">+ void HeapDumper::set_error(char const* error) {</span>
    if (_error != NULL) {
      os::free(_error);
    }
    if (error == NULL) {
      _error = NULL;
</pre>
<center><a href="diagnosticCommand.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/share/classes/java/lang/invoke/InnerClassLambdaMetafactory.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/share/services/diagnosticCommand.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderHierarchyDCmd.hpp&quot;
  28 #include &quot;classfile/classLoaderStats.hpp&quot;
  29 #include &quot;compiler/compileBroker.hpp&quot;
  30 #include &quot;compiler/directivesParser.hpp&quot;
  31 #include &quot;gc/shared/gcVMOperations.hpp&quot;
  32 #include &quot;memory/metaspace/metaspaceDCmd.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;memory/universe.hpp&quot;
  35 #include &quot;oops/objArrayOop.inline.hpp&quot;
  36 #include &quot;oops/oop.inline.hpp&quot;
  37 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  38 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  39 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  40 #include &quot;runtime/handles.inline.hpp&quot;
  41 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  42 #include &quot;runtime/javaCalls.hpp&quot;
  43 #include &quot;runtime/os.hpp&quot;
  44 #include &quot;services/diagnosticArgument.hpp&quot;
  45 #include &quot;services/diagnosticCommand.hpp&quot;
  46 #include &quot;services/diagnosticFramework.hpp&quot;
  47 #include &quot;services/heapDumper.hpp&quot;
  48 #include &quot;services/management.hpp&quot;
  49 #include &quot;services/writeableFlags.hpp&quot;
  50 #include &quot;utilities/debug.hpp&quot;
  51 #include &quot;utilities/events.hpp&quot;
  52 #include &quot;utilities/formatBuffer.hpp&quot;
  53 #include &quot;utilities/macros.hpp&quot;
  54 
  55 
  56 static void loadAgentModule(TRAPS) {
  57   ResourceMark rm(THREAD);
  58   HandleMark hm(THREAD);
  59 
  60   JavaValue result(T_OBJECT);
  61   Handle h_module_name = java_lang_String::create_from_str(&quot;jdk.management.agent&quot;, CHECK);
  62   JavaCalls::call_static(&amp;result,
  63                          SystemDictionary::module_Modules_klass(),
  64                          vmSymbols::loadModule_name(),
  65                          vmSymbols::loadModule_signature(),
  66                          h_module_name,
  67                          THREAD);
  68 }
  69 
  70 void DCmdRegistrant::register_dcmds(){
  71   // Registration of the diagnostic commands
  72   // First argument specifies which interfaces will export the command
  73   // Second argument specifies if the command is enabled
  74   // Third  argument specifies if the command is hidden
  75   uint32_t full_export = DCmd_Source_Internal | DCmd_Source_AttachAPI
  76                          | DCmd_Source_MBean;
  77   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;HelpDCmd&gt;(full_export, true, false));
  78   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;VersionDCmd&gt;(full_export, true, false));
  79   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CommandLineDCmd&gt;(full_export, true, false));
  80   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;PrintSystemPropertiesDCmd&gt;(full_export, true, false));
  81   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;PrintVMFlagsDCmd&gt;(full_export, true, false));
  82   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;SetVMFlagDCmd&gt;(full_export, true, false));
  83   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;VMDynamicLibrariesDCmd&gt;(full_export, true, false));
  84   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;VMUptimeDCmd&gt;(full_export, true, false));
  85   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;VMInfoDCmd&gt;(full_export, true, false));
  86   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;SystemGCDCmd&gt;(full_export, true, false));
  87   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;RunFinalizationDCmd&gt;(full_export, true, false));
  88   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;HeapInfoDCmd&gt;(full_export, true, false));
  89   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;FinalizerInfoDCmd&gt;(full_export, true, false));
  90 #if INCLUDE_SERVICES
  91   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;HeapDumpDCmd&gt;(DCmd_Source_Internal | DCmd_Source_AttachAPI, true, false));
  92   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassHistogramDCmd&gt;(full_export, true, false));
  93   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;SystemDictionaryDCmd&gt;(full_export, true, false));
  94   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassHierarchyDCmd&gt;(full_export, true, false));
  95   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;SymboltableDCmd&gt;(full_export, true, false));
  96   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;StringtableDCmd&gt;(full_export, true, false));
  97   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;metaspace::MetaspaceDCmd&gt;(full_export, true, false));
  98   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;PrintClassLayoutDCmd&gt;(full_export, true, false));
  99   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;EventLogDCmd&gt;(full_export, true, false));
 100 #if INCLUDE_JVMTI // Both JVMTI and SERVICES have to be enabled to have this dcmd
 101   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JVMTIAgentLoadDCmd&gt;(full_export, true, false));
 102 #endif // INCLUDE_JVMTI
 103 #endif // INCLUDE_SERVICES
 104 #if INCLUDE_JVMTI
 105   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JVMTIDataDumpDCmd&gt;(full_export, true, false));
 106 #endif // INCLUDE_JVMTI
 107   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ThreadDumpDCmd&gt;(full_export, true, false));
 108   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassLoaderStatsDCmd&gt;(full_export, true, false));
 109   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;ClassLoaderHierarchyDCmd&gt;(full_export, true, false));
 110   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompileQueueDCmd&gt;(full_export, true, false));
 111   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CodeListDCmd&gt;(full_export, true, false));
 112   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CodeCacheDCmd&gt;(full_export, true, false));
 113   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;TouchedMethodsDCmd&gt;(full_export, true, false));
 114   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CodeHeapAnalyticsDCmd&gt;(full_export, true, false));
 115 
 116   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompilerDirectivesPrintDCmd&gt;(full_export, true, false));
 117   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompilerDirectivesAddDCmd&gt;(full_export, true, false));
 118   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompilerDirectivesRemoveDCmd&gt;(full_export, true, false));
 119   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;CompilerDirectivesClearDCmd&gt;(full_export, true, false));
 120 
 121   // Enhanced JMX Agent Support
 122   // These commands won&#39;t be exported via the DiagnosticCommandMBean until an
 123   // appropriate permission is created for them
 124   uint32_t jmx_agent_export_flags = DCmd_Source_Internal | DCmd_Source_AttachAPI;
 125   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JMXStartRemoteDCmd&gt;(jmx_agent_export_flags, true,false));
 126   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JMXStartLocalDCmd&gt;(jmx_agent_export_flags, true,false));
 127   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JMXStopRemoteDCmd&gt;(jmx_agent_export_flags, true,false));
 128   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;JMXStatusDCmd&gt;(jmx_agent_export_flags, true,false));
 129   // Debug on cmd (only makes sense with JVMTI since the agentlib needs it).
 130 #if INCLUDE_JVMTI
 131   DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl&lt;DebugOnCmdStartDCmd&gt;(full_export, true, true));
 132 #endif // INCLUDE_JVMTI
 133 
 134 }
 135 
 136 #ifndef HAVE_EXTRA_DCMD
 137 void DCmdRegistrant::register_dcmds_ext(){
 138    // Do nothing here
 139 }
 140 #endif
 141 
 142 
 143 HelpDCmd::HelpDCmd(outputStream* output, bool heap) : DCmdWithParser(output, heap),
 144   _all(&quot;-all&quot;, &quot;Show help for all commands&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;),
 145   _cmd(&quot;command name&quot;, &quot;The name of the command for which we want help&quot;,
 146         &quot;STRING&quot;, false) {
 147   _dcmdparser.add_dcmd_option(&amp;_all);
 148   _dcmdparser.add_dcmd_argument(&amp;_cmd);
 149 };
 150 
 151 
 152 static int compare_strings(const char** s1, const char** s2) {
 153   return ::strcmp(*s1, *s2);
 154 }
 155 
 156 void HelpDCmd::execute(DCmdSource source, TRAPS) {
 157   if (_all.value()) {
 158     GrowableArray&lt;const char*&gt;* cmd_list = DCmdFactory::DCmd_list(source);
 159     cmd_list-&gt;sort(compare_strings);
 160     for (int i = 0; i &lt; cmd_list-&gt;length(); i++) {
 161       DCmdFactory* factory = DCmdFactory::factory(source, cmd_list-&gt;at(i),
 162                                                   strlen(cmd_list-&gt;at(i)));
 163       output()-&gt;print_cr(&quot;%s%s&quot;, factory-&gt;name(),
 164                          factory-&gt;is_enabled() ? &quot;&quot; : &quot; [disabled]&quot;);
 165       output()-&gt;print_cr(&quot;\t%s&quot;, factory-&gt;description());
 166       output()-&gt;cr();
 167       factory = factory-&gt;next();
 168     }
 169   } else if (_cmd.has_value()) {
 170     DCmd* cmd = NULL;
 171     DCmdFactory* factory = DCmdFactory::factory(source, _cmd.value(),
 172                                                 strlen(_cmd.value()));
 173     if (factory != NULL) {
 174       output()-&gt;print_cr(&quot;%s%s&quot;, factory-&gt;name(),
 175                          factory-&gt;is_enabled() ? &quot;&quot; : &quot; [disabled]&quot;);
 176       output()-&gt;print_cr(&quot;%s&quot;, factory-&gt;description());
 177       output()-&gt;print_cr(&quot;\nImpact: %s&quot;, factory-&gt;impact());
 178       JavaPermission p = factory-&gt;permission();
 179       if(p._class != NULL) {
 180         if(p._action != NULL) {
 181           output()-&gt;print_cr(&quot;\nPermission: %s(%s, %s)&quot;,
 182                   p._class, p._name == NULL ? &quot;null&quot; : p._name, p._action);
 183         } else {
 184           output()-&gt;print_cr(&quot;\nPermission: %s(%s)&quot;,
 185                   p._class, p._name == NULL ? &quot;null&quot; : p._name);
 186         }
 187       }
 188       output()-&gt;cr();
 189       cmd = factory-&gt;create_resource_instance(output());
 190       if (cmd != NULL) {
 191         DCmdMark mark(cmd);
 192         cmd-&gt;print_help(factory-&gt;name());
 193       }
 194     } else {
 195       output()-&gt;print_cr(&quot;Help unavailable : &#39;%s&#39; : No such command&quot;, _cmd.value());
 196     }
 197   } else {
 198     output()-&gt;print_cr(&quot;The following commands are available:&quot;);
 199     GrowableArray&lt;const char *&gt;* cmd_list = DCmdFactory::DCmd_list(source);
 200     cmd_list-&gt;sort(compare_strings);
 201     for (int i = 0; i &lt; cmd_list-&gt;length(); i++) {
 202       DCmdFactory* factory = DCmdFactory::factory(source, cmd_list-&gt;at(i),
 203                                                   strlen(cmd_list-&gt;at(i)));
 204       output()-&gt;print_cr(&quot;%s%s&quot;, factory-&gt;name(),
 205                          factory-&gt;is_enabled() ? &quot;&quot; : &quot; [disabled]&quot;);
 206       factory = factory-&gt;_next;
 207     }
 208     output()-&gt;print_cr(&quot;\nFor more information about a specific command use &#39;help &lt;command&gt;&#39;.&quot;);
 209   }
 210 }
 211 
 212 int HelpDCmd::num_arguments() {
 213   ResourceMark rm;
 214   HelpDCmd* dcmd = new HelpDCmd(NULL, false);
 215   if (dcmd != NULL) {
 216     DCmdMark mark(dcmd);
 217     return dcmd-&gt;_dcmdparser.num_arguments();
 218   } else {
 219     return 0;
 220   }
 221 }
 222 
 223 void VersionDCmd::execute(DCmdSource source, TRAPS) {
 224   output()-&gt;print_cr(&quot;%s version %s&quot;, VM_Version::vm_name(),
 225           VM_Version::vm_release());
 226   JDK_Version jdk_version = JDK_Version::current();
 227   if (jdk_version.patch_version() &gt; 0) {
 228     output()-&gt;print_cr(&quot;JDK %d.%d.%d.%d&quot;, jdk_version.major_version(),
 229             jdk_version.minor_version(), jdk_version.security_version(),
 230             jdk_version.patch_version());
 231   } else {
 232     output()-&gt;print_cr(&quot;JDK %d.%d.%d&quot;, jdk_version.major_version(),
 233             jdk_version.minor_version(), jdk_version.security_version());
 234   }
 235 }
 236 
 237 PrintVMFlagsDCmd::PrintVMFlagsDCmd(outputStream* output, bool heap) :
 238                                    DCmdWithParser(output, heap),
 239   _all(&quot;-all&quot;, &quot;Print all flags supported by the VM&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 240   _dcmdparser.add_dcmd_option(&amp;_all);
 241 }
 242 
 243 void PrintVMFlagsDCmd::execute(DCmdSource source, TRAPS) {
 244   if (_all.value()) {
 245     JVMFlag::printFlags(output(), true);
 246   } else {
 247     JVMFlag::printSetFlags(output());
 248   }
 249 }
 250 
 251 int PrintVMFlagsDCmd::num_arguments() {
 252     ResourceMark rm;
 253     PrintVMFlagsDCmd* dcmd = new PrintVMFlagsDCmd(NULL, false);
 254     if (dcmd != NULL) {
 255       DCmdMark mark(dcmd);
 256       return dcmd-&gt;_dcmdparser.num_arguments();
 257     } else {
 258       return 0;
 259     }
 260 }
 261 
 262 SetVMFlagDCmd::SetVMFlagDCmd(outputStream* output, bool heap) :
 263                                    DCmdWithParser(output, heap),
 264   _flag(&quot;flag name&quot;, &quot;The name of the flag we want to set&quot;,
 265         &quot;STRING&quot;, true),
 266   _value(&quot;string value&quot;, &quot;The value we want to set&quot;, &quot;STRING&quot;, false) {
 267   _dcmdparser.add_dcmd_argument(&amp;_flag);
 268   _dcmdparser.add_dcmd_argument(&amp;_value);
 269 }
 270 
 271 void SetVMFlagDCmd::execute(DCmdSource source, TRAPS) {
 272   const char* val = NULL;
 273   if (_value.value() != NULL) {
 274     val = _value.value();
 275   }
 276 
 277   FormatBuffer&lt;80&gt; err_msg(&quot;%s&quot;, &quot;&quot;);
 278   int ret = WriteableFlags::set_flag(_flag.value(), val, JVMFlag::MANAGEMENT, err_msg);
 279 
 280   if (ret != JVMFlag::SUCCESS) {
 281     output()-&gt;print_cr(&quot;%s&quot;, err_msg.buffer());
 282   }
 283 }
 284 
 285 int SetVMFlagDCmd::num_arguments() {
 286   ResourceMark rm;
 287   SetVMFlagDCmd* dcmd = new SetVMFlagDCmd(NULL, false);
 288   if (dcmd != NULL) {
 289     DCmdMark mark(dcmd);
 290     return dcmd-&gt;_dcmdparser.num_arguments();
 291   } else {
 292     return 0;
 293   }
 294 }
 295 
 296 void JVMTIDataDumpDCmd::execute(DCmdSource source, TRAPS) {
 297   if (JvmtiExport::should_post_data_dump()) {
 298     JvmtiExport::post_data_dump();
 299   }
 300 }
 301 
 302 #if INCLUDE_SERVICES
 303 JVMTIAgentLoadDCmd::JVMTIAgentLoadDCmd(outputStream* output, bool heap) :
 304                                        DCmdWithParser(output, heap),
 305   _libpath(&quot;library path&quot;, &quot;Absolute path of the JVMTI agent to load.&quot;,
 306            &quot;STRING&quot;, true),
 307   _option(&quot;agent option&quot;, &quot;Option string to pass the agent.&quot;, &quot;STRING&quot;, false) {
 308   _dcmdparser.add_dcmd_argument(&amp;_libpath);
 309   _dcmdparser.add_dcmd_argument(&amp;_option);
 310 }
 311 
 312 void JVMTIAgentLoadDCmd::execute(DCmdSource source, TRAPS) {
 313 
 314   if (_libpath.value() == NULL) {
 315     output()-&gt;print_cr(&quot;JVMTI.agent_load dcmd needs library path.&quot;);
 316     return;
 317   }
 318 
 319   char *suffix = strrchr(_libpath.value(), &#39;.&#39;);
 320   bool is_java_agent = (suffix != NULL) &amp;&amp; (strncmp(&quot;.jar&quot;, suffix, 4) == 0);
 321 
 322   if (is_java_agent) {
 323     if (_option.value() == NULL) {
 324       JvmtiExport::load_agent_library(&quot;instrument&quot;, &quot;false&quot;,
 325                                       _libpath.value(), output());
 326     } else {
 327       size_t opt_len = strlen(_libpath.value()) + strlen(_option.value()) + 2;
 328       if (opt_len &gt; 4096) {
 329         output()-&gt;print_cr(&quot;JVMTI agent attach failed: Options is too long.&quot;);
 330         return;
 331       }
 332 
 333       char *opt = (char *)os::malloc(opt_len, mtInternal);
 334       if (opt == NULL) {
 335         output()-&gt;print_cr(&quot;JVMTI agent attach failed: &quot;
 336                            &quot;Could not allocate &quot; SIZE_FORMAT &quot; bytes for argument.&quot;,
 337                            opt_len);
 338         return;
 339       }
 340 
 341       jio_snprintf(opt, opt_len, &quot;%s=%s&quot;, _libpath.value(), _option.value());
 342       JvmtiExport::load_agent_library(&quot;instrument&quot;, &quot;false&quot;, opt, output());
 343 
 344       os::free(opt);
 345     }
 346   } else {
 347     JvmtiExport::load_agent_library(_libpath.value(), &quot;true&quot;,
 348                                     _option.value(), output());
 349   }
 350 }
 351 
 352 int JVMTIAgentLoadDCmd::num_arguments() {
 353   ResourceMark rm;
 354   JVMTIAgentLoadDCmd* dcmd = new JVMTIAgentLoadDCmd(NULL, false);
 355   if (dcmd != NULL) {
 356     DCmdMark mark(dcmd);
 357     return dcmd-&gt;_dcmdparser.num_arguments();
 358   } else {
 359     return 0;
 360   }
 361 }
 362 #endif // INCLUDE_SERVICES
 363 
 364 void PrintSystemPropertiesDCmd::execute(DCmdSource source, TRAPS) {
 365   // load VMSupport
 366   Symbol* klass = vmSymbols::jdk_internal_vm_VMSupport();
 367   Klass* k = SystemDictionary::resolve_or_fail(klass, true, CHECK);
 368   InstanceKlass* ik = InstanceKlass::cast(k);
 369   if (ik-&gt;should_be_initialized()) {
 370     ik-&gt;initialize(THREAD);
 371   }
 372   if (HAS_PENDING_EXCEPTION) {
 373     java_lang_Throwable::print(PENDING_EXCEPTION, output());
 374     output()-&gt;cr();
 375     CLEAR_PENDING_EXCEPTION;
 376     return;
 377   }
 378 
 379   // invoke the serializePropertiesToByteArray method
 380   JavaValue result(T_OBJECT);
 381   JavaCallArguments args;
 382 
 383   Symbol* signature = vmSymbols::serializePropertiesToByteArray_signature();
 384   JavaCalls::call_static(&amp;result,
 385                          ik,
 386                          vmSymbols::serializePropertiesToByteArray_name(),
 387                          signature,
 388                          &amp;args,
 389                          THREAD);
 390   if (HAS_PENDING_EXCEPTION) {
 391     java_lang_Throwable::print(PENDING_EXCEPTION, output());
 392     output()-&gt;cr();
 393     CLEAR_PENDING_EXCEPTION;
 394     return;
 395   }
 396 
 397   // The result should be a [B
 398   oop res = (oop)result.get_jobject();
 399   assert(res-&gt;is_typeArray(), &quot;just checking&quot;);
 400   assert(TypeArrayKlass::cast(res-&gt;klass())-&gt;element_type() == T_BYTE, &quot;just checking&quot;);
 401 
 402   // copy the bytes to the output stream
 403   typeArrayOop ba = typeArrayOop(res);
 404   jbyte* addr = typeArrayOop(res)-&gt;byte_at_addr(0);
 405   output()-&gt;print_raw((const char*)addr, ba-&gt;length());
 406 }
 407 
 408 VMUptimeDCmd::VMUptimeDCmd(outputStream* output, bool heap) :
 409                            DCmdWithParser(output, heap),
 410   _date(&quot;-date&quot;, &quot;Add a prefix with current date&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 411   _dcmdparser.add_dcmd_option(&amp;_date);
 412 }
 413 
 414 void VMUptimeDCmd::execute(DCmdSource source, TRAPS) {
 415   if (_date.value()) {
 416     output()-&gt;date_stamp(true, &quot;&quot;, &quot;: &quot;);
 417   }
 418   output()-&gt;time_stamp().update_to(tty-&gt;time_stamp().ticks());
 419   output()-&gt;stamp();
 420   output()-&gt;print_cr(&quot; s&quot;);
 421 }
 422 
 423 int VMUptimeDCmd::num_arguments() {
 424   ResourceMark rm;
 425   VMUptimeDCmd* dcmd = new VMUptimeDCmd(NULL, false);
 426   if (dcmd != NULL) {
 427     DCmdMark mark(dcmd);
 428     return dcmd-&gt;_dcmdparser.num_arguments();
 429   } else {
 430     return 0;
 431   }
 432 }
 433 
 434 void VMInfoDCmd::execute(DCmdSource source, TRAPS) {
 435   VMError::print_vm_info(_output);
 436 }
 437 
 438 void SystemGCDCmd::execute(DCmdSource source, TRAPS) {
 439   Universe::heap()-&gt;collect(GCCause::_dcmd_gc_run);
 440 }
 441 
 442 void RunFinalizationDCmd::execute(DCmdSource source, TRAPS) {
 443   Klass* k = SystemDictionary::System_klass();
 444   JavaValue result(T_VOID);
 445   JavaCalls::call_static(&amp;result, k,
 446                          vmSymbols::run_finalization_name(),
 447                          vmSymbols::void_method_signature(), CHECK);
 448 }
 449 
 450 void HeapInfoDCmd::execute(DCmdSource source, TRAPS) {
 451   MutexLocker hl(THREAD, Heap_lock);
 452   Universe::heap()-&gt;print_on(output());
 453 }
 454 
 455 void FinalizerInfoDCmd::execute(DCmdSource source, TRAPS) {
 456   ResourceMark rm(THREAD);
 457 
 458   Klass* k = SystemDictionary::resolve_or_fail(
 459     vmSymbols::finalizer_histogram_klass(), true, CHECK);
 460 
 461   JavaValue result(T_ARRAY);
 462 
 463   // We are calling lang.ref.FinalizerHistogram.getFinalizerHistogram() method
 464   // and expect it to return array of FinalizerHistogramEntry as Object[]
 465 
 466   JavaCalls::call_static(&amp;result, k,
 467                          vmSymbols::get_finalizer_histogram_name(),
 468                          vmSymbols::void_finalizer_histogram_entry_array_signature(), CHECK);
 469 
 470   objArrayOop result_oop = (objArrayOop) result.get_jobject();
 471   if (result_oop-&gt;length() == 0) {
 472     output()-&gt;print_cr(&quot;No instances waiting for finalization found&quot;);
 473     return;
 474   }
 475 
 476   oop foop = result_oop-&gt;obj_at(0);
 477   InstanceKlass* ik = InstanceKlass::cast(foop-&gt;klass());
 478 
 479   fieldDescriptor count_fd, name_fd;
 480 
 481   Klass* count_res = ik-&gt;find_field(
 482     vmSymbols::finalizer_histogram_entry_count_field(), vmSymbols::int_signature(), &amp;count_fd);
 483 
 484   Klass* name_res = ik-&gt;find_field(
 485     vmSymbols::finalizer_histogram_entry_name_field(), vmSymbols::string_signature(), &amp;name_fd);
 486 
 487   assert(count_res != NULL &amp;&amp; name_res != NULL, &quot;Unexpected layout of FinalizerHistogramEntry&quot;);
 488 
 489   output()-&gt;print_cr(&quot;Unreachable instances waiting for finalization&quot;);
 490   output()-&gt;print_cr(&quot;#instances  class name&quot;);
 491   output()-&gt;print_cr(&quot;-----------------------&quot;);
 492 
 493   for (int i = 0; i &lt; result_oop-&gt;length(); ++i) {
 494     oop element_oop = result_oop-&gt;obj_at(i);
 495     oop str_oop = element_oop-&gt;obj_field(name_fd.offset());
 496     char *name = java_lang_String::as_utf8_string(str_oop);
 497     int count = element_oop-&gt;int_field(count_fd.offset());
 498     output()-&gt;print_cr(&quot;%10d  %s&quot;, count, name);
 499   }
 500 }
 501 
 502 #if INCLUDE_SERVICES // Heap dumping/inspection supported
 503 HeapDumpDCmd::HeapDumpDCmd(outputStream* output, bool heap) :
 504                            DCmdWithParser(output, heap),
 505   _filename(&quot;filename&quot;,&quot;Name of the dump file&quot;, &quot;STRING&quot;,true),
 506   _all(&quot;-all&quot;, &quot;Dump all objects, including unreachable objects&quot;,
 507        &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 508   _dcmdparser.add_dcmd_option(&amp;_all);
 509   _dcmdparser.add_dcmd_argument(&amp;_filename);
 510 }
 511 
 512 void HeapDumpDCmd::execute(DCmdSource source, TRAPS) {
 513   // Request a full GC before heap dump if _all is false
 514   // This helps reduces the amount of unreachable objects in the dump
 515   // and makes it easier to browse.
 516   HeapDumper dumper(!_all.value() /* request GC if _all is false*/);
 517   dumper.dump(_filename.value(), output());
 518 }
 519 
 520 int HeapDumpDCmd::num_arguments() {
 521   ResourceMark rm;
 522   HeapDumpDCmd* dcmd = new HeapDumpDCmd(NULL, false);
 523   if (dcmd != NULL) {
 524     DCmdMark mark(dcmd);
 525     return dcmd-&gt;_dcmdparser.num_arguments();
 526   } else {
 527     return 0;
 528   }
 529 }
 530 
 531 ClassHistogramDCmd::ClassHistogramDCmd(outputStream* output, bool heap) :
 532                                        DCmdWithParser(output, heap),
 533   _all(&quot;-all&quot;, &quot;Inspect all objects, including unreachable objects&quot;,
 534        &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 535   _dcmdparser.add_dcmd_option(&amp;_all);
 536 }
 537 
 538 void ClassHistogramDCmd::execute(DCmdSource source, TRAPS) {
 539   VM_GC_HeapInspection heapop(output(),
 540                               !_all.value() /* request full gc if false */);
 541   VMThread::execute(&amp;heapop);
 542 }
 543 
 544 int ClassHistogramDCmd::num_arguments() {
 545   ResourceMark rm;
 546   ClassHistogramDCmd* dcmd = new ClassHistogramDCmd(NULL, false);
 547   if (dcmd != NULL) {
 548     DCmdMark mark(dcmd);
 549     return dcmd-&gt;_dcmdparser.num_arguments();
 550   } else {
 551     return 0;
 552   }
 553 }
 554 
 555 #endif // INCLUDE_SERVICES
 556 
 557 ThreadDumpDCmd::ThreadDumpDCmd(outputStream* output, bool heap) :
 558                                DCmdWithParser(output, heap),
 559   _locks(&quot;-l&quot;, &quot;print java.util.concurrent locks&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;),
 560   _extended(&quot;-e&quot;, &quot;print extended thread information&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 561   _dcmdparser.add_dcmd_option(&amp;_locks);
 562   _dcmdparser.add_dcmd_option(&amp;_extended);
 563 }
 564 
 565 void ThreadDumpDCmd::execute(DCmdSource source, TRAPS) {
 566   // thread stacks
 567   VM_PrintThreads op1(output(), _locks.value(), _extended.value());
 568   VMThread::execute(&amp;op1);
 569 
 570   // JNI global handles
 571   VM_PrintJNI op2(output());
 572   VMThread::execute(&amp;op2);
 573 
 574   // Deadlock detection
 575   VM_FindDeadlocks op3(output());
 576   VMThread::execute(&amp;op3);
 577 }
 578 
 579 int ThreadDumpDCmd::num_arguments() {
 580   ResourceMark rm;
 581   ThreadDumpDCmd* dcmd = new ThreadDumpDCmd(NULL, false);
 582   if (dcmd != NULL) {
 583     DCmdMark mark(dcmd);
 584     return dcmd-&gt;_dcmdparser.num_arguments();
 585   } else {
 586     return 0;
 587   }
 588 }
 589 
 590 // Enhanced JMX Agent support
 591 
 592 JMXStartRemoteDCmd::JMXStartRemoteDCmd(outputStream *output, bool heap_allocated) :
 593 
 594   DCmdWithParser(output, heap_allocated),
 595 
 596   _config_file
 597   (&quot;config.file&quot;,
 598    &quot;set com.sun.management.config.file&quot;, &quot;STRING&quot;, false),
 599 
 600   _jmxremote_host
 601   (&quot;jmxremote.host&quot;,
 602    &quot;set com.sun.management.jmxremote.host&quot;, &quot;STRING&quot;, false),
 603 
 604   _jmxremote_port
 605   (&quot;jmxremote.port&quot;,
 606    &quot;set com.sun.management.jmxremote.port&quot;, &quot;STRING&quot;, false),
 607 
 608   _jmxremote_rmi_port
 609   (&quot;jmxremote.rmi.port&quot;,
 610    &quot;set com.sun.management.jmxremote.rmi.port&quot;, &quot;STRING&quot;, false),
 611 
 612   _jmxremote_ssl
 613   (&quot;jmxremote.ssl&quot;,
 614    &quot;set com.sun.management.jmxremote.ssl&quot;, &quot;STRING&quot;, false),
 615 
 616   _jmxremote_registry_ssl
 617   (&quot;jmxremote.registry.ssl&quot;,
 618    &quot;set com.sun.management.jmxremote.registry.ssl&quot;, &quot;STRING&quot;, false),
 619 
 620   _jmxremote_authenticate
 621   (&quot;jmxremote.authenticate&quot;,
 622    &quot;set com.sun.management.jmxremote.authenticate&quot;, &quot;STRING&quot;, false),
 623 
 624   _jmxremote_password_file
 625   (&quot;jmxremote.password.file&quot;,
 626    &quot;set com.sun.management.jmxremote.password.file&quot;, &quot;STRING&quot;, false),
 627 
 628   _jmxremote_access_file
 629   (&quot;jmxremote.access.file&quot;,
 630    &quot;set com.sun.management.jmxremote.access.file&quot;, &quot;STRING&quot;, false),
 631 
 632   _jmxremote_login_config
 633   (&quot;jmxremote.login.config&quot;,
 634    &quot;set com.sun.management.jmxremote.login.config&quot;, &quot;STRING&quot;, false),
 635 
 636   _jmxremote_ssl_enabled_cipher_suites
 637   (&quot;jmxremote.ssl.enabled.cipher.suites&quot;,
 638    &quot;set com.sun.management.jmxremote.ssl.enabled.cipher.suite&quot;, &quot;STRING&quot;, false),
 639 
 640   _jmxremote_ssl_enabled_protocols
 641   (&quot;jmxremote.ssl.enabled.protocols&quot;,
 642    &quot;set com.sun.management.jmxremote.ssl.enabled.protocols&quot;, &quot;STRING&quot;, false),
 643 
 644   _jmxremote_ssl_need_client_auth
 645   (&quot;jmxremote.ssl.need.client.auth&quot;,
 646    &quot;set com.sun.management.jmxremote.need.client.auth&quot;, &quot;STRING&quot;, false),
 647 
 648   _jmxremote_ssl_config_file
 649   (&quot;jmxremote.ssl.config.file&quot;,
 650    &quot;set com.sun.management.jmxremote.ssl.config.file&quot;, &quot;STRING&quot;, false),
 651 
 652 // JDP Protocol support
 653   _jmxremote_autodiscovery
 654   (&quot;jmxremote.autodiscovery&quot;,
 655    &quot;set com.sun.management.jmxremote.autodiscovery&quot;, &quot;STRING&quot;, false),
 656 
 657    _jdp_port
 658   (&quot;jdp.port&quot;,
 659    &quot;set com.sun.management.jdp.port&quot;, &quot;INT&quot;, false),
 660 
 661    _jdp_address
 662   (&quot;jdp.address&quot;,
 663    &quot;set com.sun.management.jdp.address&quot;, &quot;STRING&quot;, false),
 664 
 665    _jdp_source_addr
 666   (&quot;jdp.source_addr&quot;,
 667    &quot;set com.sun.management.jdp.source_addr&quot;, &quot;STRING&quot;, false),
 668 
 669    _jdp_ttl
 670   (&quot;jdp.ttl&quot;,
 671    &quot;set com.sun.management.jdp.ttl&quot;, &quot;INT&quot;, false),
 672 
 673    _jdp_pause
 674   (&quot;jdp.pause&quot;,
 675    &quot;set com.sun.management.jdp.pause&quot;, &quot;INT&quot;, false),
 676 
 677    _jdp_name
 678   (&quot;jdp.name&quot;,
 679    &quot;set com.sun.management.jdp.name&quot;, &quot;STRING&quot;, false)
 680 
 681   {
 682     _dcmdparser.add_dcmd_option(&amp;_config_file);
 683     _dcmdparser.add_dcmd_option(&amp;_jmxremote_host);
 684     _dcmdparser.add_dcmd_option(&amp;_jmxremote_port);
 685     _dcmdparser.add_dcmd_option(&amp;_jmxremote_rmi_port);
 686     _dcmdparser.add_dcmd_option(&amp;_jmxremote_ssl);
 687     _dcmdparser.add_dcmd_option(&amp;_jmxremote_registry_ssl);
 688     _dcmdparser.add_dcmd_option(&amp;_jmxremote_authenticate);
 689     _dcmdparser.add_dcmd_option(&amp;_jmxremote_password_file);
 690     _dcmdparser.add_dcmd_option(&amp;_jmxremote_access_file);
 691     _dcmdparser.add_dcmd_option(&amp;_jmxremote_login_config);
 692     _dcmdparser.add_dcmd_option(&amp;_jmxremote_ssl_enabled_cipher_suites);
 693     _dcmdparser.add_dcmd_option(&amp;_jmxremote_ssl_enabled_protocols);
 694     _dcmdparser.add_dcmd_option(&amp;_jmxremote_ssl_need_client_auth);
 695     _dcmdparser.add_dcmd_option(&amp;_jmxremote_ssl_config_file);
 696     _dcmdparser.add_dcmd_option(&amp;_jmxremote_autodiscovery);
 697     _dcmdparser.add_dcmd_option(&amp;_jdp_port);
 698     _dcmdparser.add_dcmd_option(&amp;_jdp_address);
 699     _dcmdparser.add_dcmd_option(&amp;_jdp_source_addr);
 700     _dcmdparser.add_dcmd_option(&amp;_jdp_ttl);
 701     _dcmdparser.add_dcmd_option(&amp;_jdp_pause);
 702     _dcmdparser.add_dcmd_option(&amp;_jdp_name);
 703 }
 704 
 705 
 706 int JMXStartRemoteDCmd::num_arguments() {
 707   ResourceMark rm;
 708   JMXStartRemoteDCmd* dcmd = new JMXStartRemoteDCmd(NULL, false);
 709   if (dcmd != NULL) {
 710     DCmdMark mark(dcmd);
 711     return dcmd-&gt;_dcmdparser.num_arguments();
 712   } else {
 713     return 0;
 714   }
 715 }
 716 
 717 
 718 void JMXStartRemoteDCmd::execute(DCmdSource source, TRAPS) {
 719     ResourceMark rm(THREAD);
 720     HandleMark hm(THREAD);
 721 
 722     // Load and initialize the jdk.internal.agent.Agent class
 723     // invoke startRemoteManagementAgent(string) method to start
 724     // the remote management server.
 725     // throw java.lang.NoSuchMethodError if the method doesn&#39;t exist
 726 
 727     loadAgentModule(CHECK);
 728     Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
 729     Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, Handle(), true, CHECK);
 730 
 731     JavaValue result(T_VOID);
 732 
 733     // Pass all command line arguments to java as key=value,...
 734     // All checks are done on java side
 735 
 736     int len = 0;
 737     stringStream options;
 738     char comma[2] = {0,0};
 739 
 740     // Leave default values on Agent.class side and pass only
 741     // agruments explicitly set by user. All arguments passed
 742     // to jcmd override properties with the same name set by
 743     // command line with -D or by managmenent.properties
 744     // file.
 745 #define PUT_OPTION(a) \
 746     do { \
 747         if ( (a).is_set() ){ \
 748             if ( *((a).type()) == &#39;I&#39; ) { \
 749                 options.print(&quot;%scom.sun.management.%s=&quot; JLONG_FORMAT, comma, (a).name(), (jlong)((a).value())); \
 750             } else { \
 751                 options.print(&quot;%scom.sun.management.%s=%s&quot;, comma, (a).name(), (char*)((a).value())); \
 752             } \
 753             comma[0] = &#39;,&#39;; \
 754         }\
 755     } while(0);
 756 
 757 
 758     PUT_OPTION(_config_file);
 759     PUT_OPTION(_jmxremote_host);
 760     PUT_OPTION(_jmxremote_port);
 761     PUT_OPTION(_jmxremote_rmi_port);
 762     PUT_OPTION(_jmxremote_ssl);
 763     PUT_OPTION(_jmxremote_registry_ssl);
 764     PUT_OPTION(_jmxremote_authenticate);
 765     PUT_OPTION(_jmxremote_password_file);
 766     PUT_OPTION(_jmxremote_access_file);
 767     PUT_OPTION(_jmxremote_login_config);
 768     PUT_OPTION(_jmxremote_ssl_enabled_cipher_suites);
 769     PUT_OPTION(_jmxremote_ssl_enabled_protocols);
 770     PUT_OPTION(_jmxremote_ssl_need_client_auth);
 771     PUT_OPTION(_jmxremote_ssl_config_file);
 772     PUT_OPTION(_jmxremote_autodiscovery);
 773     PUT_OPTION(_jdp_port);
 774     PUT_OPTION(_jdp_address);
 775     PUT_OPTION(_jdp_source_addr);
 776     PUT_OPTION(_jdp_ttl);
 777     PUT_OPTION(_jdp_pause);
 778     PUT_OPTION(_jdp_name);
 779 
 780 #undef PUT_OPTION
 781 
 782     Handle str = java_lang_String::create_from_str(options.as_string(), CHECK);
 783     JavaCalls::call_static(&amp;result, k, vmSymbols::startRemoteAgent_name(), vmSymbols::string_void_signature(), str, CHECK);
 784 }
 785 
 786 JMXStartLocalDCmd::JMXStartLocalDCmd(outputStream *output, bool heap_allocated) :
 787   DCmd(output, heap_allocated) {
 788   // do nothing
 789 }
 790 
 791 void JMXStartLocalDCmd::execute(DCmdSource source, TRAPS) {
 792     ResourceMark rm(THREAD);
 793     HandleMark hm(THREAD);
 794 
 795     // Load and initialize the jdk.internal.agent.Agent class
 796     // invoke startLocalManagementAgent(void) method to start
 797     // the local management server
 798     // throw java.lang.NoSuchMethodError if method doesn&#39;t exist
 799 
 800     loadAgentModule(CHECK);
 801     Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
 802     Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, Handle(), true, CHECK);
 803 
 804     JavaValue result(T_VOID);
 805     JavaCalls::call_static(&amp;result, k, vmSymbols::startLocalAgent_name(), vmSymbols::void_method_signature(), CHECK);
 806 }
 807 
 808 void JMXStopRemoteDCmd::execute(DCmdSource source, TRAPS) {
 809     ResourceMark rm(THREAD);
 810     HandleMark hm(THREAD);
 811 
 812     // Load and initialize the jdk.internal.agent.Agent class
 813     // invoke stopRemoteManagementAgent method to stop the
 814     // management server
 815     // throw java.lang.NoSuchMethodError if method doesn&#39;t exist
 816 
 817     loadAgentModule(CHECK);
 818     Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
 819     Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, Handle(), true, CHECK);
 820 
 821     JavaValue result(T_VOID);
 822     JavaCalls::call_static(&amp;result, k, vmSymbols::stopRemoteAgent_name(), vmSymbols::void_method_signature(), CHECK);
 823 }
 824 
 825 JMXStatusDCmd::JMXStatusDCmd(outputStream *output, bool heap_allocated) :
 826   DCmd(output, heap_allocated) {
 827   // do nothing
 828 }
 829 
 830 void JMXStatusDCmd::execute(DCmdSource source, TRAPS) {
 831   ResourceMark rm(THREAD);
 832   HandleMark hm(THREAD);
 833 
 834   // Load and initialize the jdk.internal.agent.Agent class
 835   // invoke getManagementAgentStatus() method to generate the status info
 836   // throw java.lang.NoSuchMethodError if method doesn&#39;t exist
 837 
 838   loadAgentModule(CHECK);
 839   Handle loader = Handle(THREAD, SystemDictionary::java_system_loader());
 840   Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_agent_Agent(), loader, Handle(), true, CHECK);
 841 
 842   JavaValue result(T_OBJECT);
 843   JavaCalls::call_static(&amp;result, k, vmSymbols::getAgentStatus_name(), vmSymbols::void_string_signature(), CHECK);
 844 
 845   jvalue* jv = (jvalue*) result.get_value_addr();
 846   oop str = (oop) jv-&gt;l;
 847   if (str != NULL) {
 848       char* out = java_lang_String::as_utf8_string(str);
 849       if (out) {
 850           output()-&gt;print_cr(&quot;%s&quot;, out);
 851           return;
 852       }
 853   }
 854   output()-&gt;print_cr(&quot;Error obtaining management agent status&quot;);
 855 }
 856 
 857 VMDynamicLibrariesDCmd::VMDynamicLibrariesDCmd(outputStream *output, bool heap_allocated) :
 858   DCmd(output, heap_allocated) {
 859   // do nothing
 860 }
 861 
 862 void VMDynamicLibrariesDCmd::execute(DCmdSource source, TRAPS) {
 863   os::print_dll_info(output());
 864   output()-&gt;cr();
 865 }
 866 
 867 void CompileQueueDCmd::execute(DCmdSource source, TRAPS) {
 868   VM_PrintCompileQueue printCompileQueueOp(output());
 869   VMThread::execute(&amp;printCompileQueueOp);
 870 }
 871 
 872 void CodeListDCmd::execute(DCmdSource source, TRAPS) {
 873   CodeCache::print_codelist(output());
 874 }
 875 
 876 void CodeCacheDCmd::execute(DCmdSource source, TRAPS) {
 877   CodeCache::print_layout(output());
 878 }
 879 
 880 //---&lt;  BEGIN  &gt;--- CodeHeap State Analytics.
 881 CodeHeapAnalyticsDCmd::CodeHeapAnalyticsDCmd(outputStream* output, bool heap) :
 882                                              DCmdWithParser(output, heap),
 883   _function(&quot;function&quot;, &quot;Function to be performed (aggregate, UsedSpace, FreeSpace, MethodCount, MethodSpace, MethodAge, MethodNames, discard&quot;, &quot;STRING&quot;, false, &quot;all&quot;),
 884   _granularity(&quot;granularity&quot;, &quot;Detail level - smaller value -&gt; more detail&quot;, &quot;INT&quot;, false, &quot;4096&quot;) {
 885   _dcmdparser.add_dcmd_argument(&amp;_function);
 886   _dcmdparser.add_dcmd_argument(&amp;_granularity);
 887 }
 888 
 889 void CodeHeapAnalyticsDCmd::execute(DCmdSource source, TRAPS) {
 890   jlong granularity = _granularity.value();
 891   if (granularity &lt; 1) {
 892     Exceptions::fthrow(THREAD_AND_LOCATION, vmSymbols::java_lang_IllegalArgumentException(),
 893                        &quot;Invalid granularity value &quot; JLONG_FORMAT  &quot;. Should be positive.\n&quot;, granularity);
 894     return;
 895   }
 896 
 897   CompileBroker::print_heapinfo(output(), _function.value(), granularity);
 898 }
 899 
 900 int CodeHeapAnalyticsDCmd::num_arguments() {
 901   ResourceMark rm;
 902   CodeHeapAnalyticsDCmd* dcmd = new CodeHeapAnalyticsDCmd(NULL, false);
 903   if (dcmd != NULL) {
 904     DCmdMark mark(dcmd);
 905     return dcmd-&gt;_dcmdparser.num_arguments();
 906   } else {
 907     return 0;
 908   }
 909 }
 910 //---&lt;  END  &gt;--- CodeHeap State Analytics.
 911 
 912 EventLogDCmd::EventLogDCmd(outputStream* output, bool heap) :
 913   DCmdWithParser(output, heap),
 914   _log(&quot;log&quot;, &quot;Name of log to be printed. If omitted, all logs are printed.&quot;, &quot;STRING&quot;, false, NULL),
 915   _max(&quot;max&quot;, &quot;Maximum number of events to be printed (newest first). If omitted, all events are printed.&quot;, &quot;STRING&quot;, false, NULL)
 916 {
 917   _dcmdparser.add_dcmd_option(&amp;_log);
 918   _dcmdparser.add_dcmd_option(&amp;_max);
 919 }
 920 
 921 void EventLogDCmd::execute(DCmdSource source, TRAPS) {
 922   const char* max_value = _max.value();
 923   long max = -1;
 924   if (max_value != NULL) {
 925     char* endptr = NULL;
 926     max = ::strtol(max_value, &amp;endptr, 10);
 927     if (max == 0 &amp;&amp; max_value == endptr) {
 928       output()-&gt;print_cr(&quot;Invalid max option: \&quot;%s\&quot;.&quot;, max_value);
 929       return;
 930     }
 931   }
 932   const char* log_name = _log.value();
 933   if (log_name != NULL) {
 934     Events::print_one(output(), log_name, max);
 935   } else {
 936     Events::print_all(output(), max);
 937   }
 938 }
 939 
 940 int EventLogDCmd::num_arguments() {
 941   ResourceMark rm;
 942   EventLogDCmd* dcmd = new EventLogDCmd(NULL, false);
 943   if (dcmd != NULL) {
 944     DCmdMark mark(dcmd);
 945     return dcmd-&gt;_dcmdparser.num_arguments();
 946   } else {
 947     return 0;
 948   }
 949 }
 950 
 951 void CompilerDirectivesPrintDCmd::execute(DCmdSource source, TRAPS) {
 952   DirectivesStack::print(output());
 953 }
 954 
 955 CompilerDirectivesAddDCmd::CompilerDirectivesAddDCmd(outputStream* output, bool heap) :
 956                            DCmdWithParser(output, heap),
 957   _filename(&quot;filename&quot;,&quot;Name of the directives file&quot;, &quot;STRING&quot;,true) {
 958   _dcmdparser.add_dcmd_argument(&amp;_filename);
 959 }
 960 
 961 void CompilerDirectivesAddDCmd::execute(DCmdSource source, TRAPS) {
 962   DirectivesParser::parse_from_file(_filename.value(), output());
 963 }
 964 
 965 int CompilerDirectivesAddDCmd::num_arguments() {
 966   ResourceMark rm;
 967   CompilerDirectivesAddDCmd* dcmd = new CompilerDirectivesAddDCmd(NULL, false);
 968   if (dcmd != NULL) {
 969     DCmdMark mark(dcmd);
 970     return dcmd-&gt;_dcmdparser.num_arguments();
 971   } else {
 972     return 0;
 973   }
 974 }
 975 
 976 void CompilerDirectivesRemoveDCmd::execute(DCmdSource source, TRAPS) {
 977   DirectivesStack::pop(1);
 978 }
 979 
 980 void CompilerDirectivesClearDCmd::execute(DCmdSource source, TRAPS) {
 981   DirectivesStack::clear();
 982 }
 983 #if INCLUDE_SERVICES
 984 ClassHierarchyDCmd::ClassHierarchyDCmd(outputStream* output, bool heap) :
 985                                        DCmdWithParser(output, heap),
 986   _print_interfaces(&quot;-i&quot;, &quot;Inherited interfaces should be printed.&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;),
 987   _print_subclasses(&quot;-s&quot;, &quot;If a classname is specified, print its subclasses. &quot;
 988                     &quot;Otherwise only its superclasses are printed.&quot;, &quot;BOOLEAN&quot;, false, &quot;false&quot;),
 989   _classname(&quot;classname&quot;, &quot;Name of class whose hierarchy should be printed. &quot;
 990              &quot;If not specified, all class hierarchies are printed.&quot;,
 991              &quot;STRING&quot;, false) {
 992   _dcmdparser.add_dcmd_option(&amp;_print_interfaces);
 993   _dcmdparser.add_dcmd_option(&amp;_print_subclasses);
 994   _dcmdparser.add_dcmd_argument(&amp;_classname);
 995 }
 996 
 997 void ClassHierarchyDCmd::execute(DCmdSource source, TRAPS) {
 998   VM_PrintClassHierarchy printClassHierarchyOp(output(), _print_interfaces.value(),
 999                                                _print_subclasses.value(), _classname.value());
1000   VMThread::execute(&amp;printClassHierarchyOp);
1001 }
1002 
1003 int ClassHierarchyDCmd::num_arguments() {
1004   ResourceMark rm;
1005   ClassHierarchyDCmd* dcmd = new ClassHierarchyDCmd(NULL, false);
1006   if (dcmd != NULL) {
1007     DCmdMark mark(dcmd);
1008     return dcmd-&gt;_dcmdparser.num_arguments();
1009   } else {
1010     return 0;
1011   }
1012 }
1013 
1014 #endif
1015 
1016 PrintClassLayoutDCmd::PrintClassLayoutDCmd(outputStream* output, bool heap) :
1017                                        DCmdWithParser(output, heap),
1018   _classname(&quot;classname&quot;, &quot;Name of class whose layout should be printed. &quot;,
1019              &quot;STRING&quot;, true) {
1020   _dcmdparser.add_dcmd_argument(&amp;_classname);
1021 }
1022 
1023 void PrintClassLayoutDCmd::execute(DCmdSource source, TRAPS) {
1024   VM_PrintClassLayout printClassLayoutOp(output(), _classname.value());
1025   VMThread::execute(&amp;printClassLayoutOp);
1026 }
1027 
1028 int PrintClassLayoutDCmd::num_arguments() {
1029   ResourceMark rm;
1030   PrintClassLayoutDCmd* dcmd = new PrintClassLayoutDCmd(NULL, false);
1031   if (dcmd != NULL) {
1032     DCmdMark mark(dcmd);
1033     return dcmd-&gt;_dcmdparser.num_arguments();
1034   } else {
1035     return 0;
1036   }
1037 }
1038 
1039 class VM_DumpTouchedMethods : public VM_Operation {
1040 private:
1041   outputStream* _out;
1042 public:
1043   VM_DumpTouchedMethods(outputStream* out) {
1044     _out = out;
1045   }
1046 
1047   virtual VMOp_Type type() const { return VMOp_DumpTouchedMethods; }
1048 
1049   virtual void doit() {
1050     Method::print_touched_methods(_out);
1051   }
1052 };
1053 
1054 TouchedMethodsDCmd::TouchedMethodsDCmd(outputStream* output, bool heap) :
1055                                        DCmdWithParser(output, heap)
1056 {}
1057 
1058 void TouchedMethodsDCmd::execute(DCmdSource source, TRAPS) {
1059   if (!LogTouchedMethods) {
1060     output()-&gt;print_cr(&quot;VM.print_touched_methods command requires -XX:+LogTouchedMethods&quot;);
1061     return;
1062   }
1063   VM_DumpTouchedMethods dumper(output());
1064   VMThread::execute(&amp;dumper);
1065 }
1066 
1067 int TouchedMethodsDCmd::num_arguments() {
1068   return 0;
1069 }
1070 
1071 #if INCLUDE_JVMTI
1072 extern &quot;C&quot; typedef char const* (JNICALL *debugInit_startDebuggingViaCommandPtr)(JNIEnv* env, jthread thread, char const** transport_name,
1073                                                                                 char const** address, jboolean* first_start);
1074 static debugInit_startDebuggingViaCommandPtr dvc_start_ptr = NULL;
1075 
1076 DebugOnCmdStartDCmd::DebugOnCmdStartDCmd(outputStream* output, bool heap) : DCmdWithParser(output, heap) {
1077 }
1078 
1079 void DebugOnCmdStartDCmd::execute(DCmdSource source, TRAPS) {
1080   char const* transport = NULL;
1081   char const* addr = NULL;
1082   jboolean is_first_start = JNI_FALSE;
1083   JavaThread* thread = (JavaThread*) THREAD;
1084   jthread jt = JNIHandles::make_local(thread-&gt;threadObj());
1085   ThreadToNativeFromVM ttn(thread);
1086   const char *error = &quot;Could not find jdwp agent.&quot;;
1087 
1088   if (!dvc_start_ptr) {
1089     for (AgentLibrary* agent = Arguments::agents(); agent != NULL; agent = agent-&gt;next()) {
1090       if ((strcmp(&quot;jdwp&quot;, agent-&gt;name()) == 0) &amp;&amp; (dvc_start_ptr == NULL)) {
1091         char const* func = &quot;debugInit_startDebuggingViaCommand&quot;;
1092         dvc_start_ptr = (debugInit_startDebuggingViaCommandPtr) os::find_agent_function(agent, false, &amp;func, 1);
1093       }
1094     }
1095   }
1096 
1097   if (dvc_start_ptr) {
1098     error = dvc_start_ptr(thread-&gt;jni_environment(), jt, &amp;transport, &amp;addr, &amp;is_first_start);
1099   }
1100 
1101   if (error != NULL) {
1102     output()-&gt;print_cr(&quot;Debugging has not been started: %s&quot;, error);
1103   } else {
1104     output()-&gt;print_cr(is_first_start ? &quot;Debugging has been started.&quot; : &quot;Debugging is already active.&quot;);
1105     output()-&gt;print_cr(&quot;Transport : %s&quot;, transport ? transport : &quot;#unknown&quot;);
1106     output()-&gt;print_cr(&quot;Address : %s&quot;, addr ? addr : &quot;#unknown&quot;);
1107   }
1108 }
1109 #endif // INCLUDE_JVMTI
    </pre>
  </body>
</html>
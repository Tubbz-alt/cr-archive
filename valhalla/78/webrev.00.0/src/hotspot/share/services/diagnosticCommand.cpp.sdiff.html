<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/services/diagnosticCommand.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../runtime/vmStructs.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="diagnosticCommand.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/services/diagnosticCommand.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 487   assert(count_res != NULL &amp;&amp; name_res != NULL, &quot;Unexpected layout of FinalizerHistogramEntry&quot;);
 488 
 489   output()-&gt;print_cr(&quot;Unreachable instances waiting for finalization&quot;);
 490   output()-&gt;print_cr(&quot;#instances  class name&quot;);
 491   output()-&gt;print_cr(&quot;-----------------------&quot;);
 492 
 493   for (int i = 0; i &lt; result_oop-&gt;length(); ++i) {
 494     oop element_oop = result_oop-&gt;obj_at(i);
 495     oop str_oop = element_oop-&gt;obj_field(name_fd.offset());
 496     char *name = java_lang_String::as_utf8_string(str_oop);
 497     int count = element_oop-&gt;int_field(count_fd.offset());
 498     output()-&gt;print_cr(&quot;%10d  %s&quot;, count, name);
 499   }
 500 }
 501 
 502 #if INCLUDE_SERVICES // Heap dumping/inspection supported
 503 HeapDumpDCmd::HeapDumpDCmd(outputStream* output, bool heap) :
 504                            DCmdWithParser(output, heap),
 505   _filename(&quot;filename&quot;,&quot;Name of the dump file&quot;, &quot;STRING&quot;,true),
 506   _all(&quot;-all&quot;, &quot;Dump all objects, including unreachable objects&quot;,
<span class="line-modified"> 507        &quot;BOOLEAN&quot;, false, &quot;false&quot;) {</span>



 508   _dcmdparser.add_dcmd_option(&amp;_all);
 509   _dcmdparser.add_dcmd_argument(&amp;_filename);

 510 }
 511 
 512 void HeapDumpDCmd::execute(DCmdSource source, TRAPS) {











 513   // Request a full GC before heap dump if _all is false
 514   // This helps reduces the amount of unreachable objects in the dump
 515   // and makes it easier to browse.
 516   HeapDumper dumper(!_all.value() /* request GC if _all is false*/);
<span class="line-modified"> 517   dumper.dump(_filename.value(), output());</span>
 518 }
 519 
 520 int HeapDumpDCmd::num_arguments() {
 521   ResourceMark rm;
 522   HeapDumpDCmd* dcmd = new HeapDumpDCmd(NULL, false);
 523   if (dcmd != NULL) {
 524     DCmdMark mark(dcmd);
 525     return dcmd-&gt;_dcmdparser.num_arguments();
 526   } else {
 527     return 0;
 528   }
 529 }
 530 
 531 ClassHistogramDCmd::ClassHistogramDCmd(outputStream* output, bool heap) :
 532                                        DCmdWithParser(output, heap),
 533   _all(&quot;-all&quot;, &quot;Inspect all objects, including unreachable objects&quot;,
 534        &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 535   _dcmdparser.add_dcmd_option(&amp;_all);
 536 }
 537 
</pre>
</td>
<td>
<hr />
<pre>
 487   assert(count_res != NULL &amp;&amp; name_res != NULL, &quot;Unexpected layout of FinalizerHistogramEntry&quot;);
 488 
 489   output()-&gt;print_cr(&quot;Unreachable instances waiting for finalization&quot;);
 490   output()-&gt;print_cr(&quot;#instances  class name&quot;);
 491   output()-&gt;print_cr(&quot;-----------------------&quot;);
 492 
 493   for (int i = 0; i &lt; result_oop-&gt;length(); ++i) {
 494     oop element_oop = result_oop-&gt;obj_at(i);
 495     oop str_oop = element_oop-&gt;obj_field(name_fd.offset());
 496     char *name = java_lang_String::as_utf8_string(str_oop);
 497     int count = element_oop-&gt;int_field(count_fd.offset());
 498     output()-&gt;print_cr(&quot;%10d  %s&quot;, count, name);
 499   }
 500 }
 501 
 502 #if INCLUDE_SERVICES // Heap dumping/inspection supported
 503 HeapDumpDCmd::HeapDumpDCmd(outputStream* output, bool heap) :
 504                            DCmdWithParser(output, heap),
 505   _filename(&quot;filename&quot;,&quot;Name of the dump file&quot;, &quot;STRING&quot;,true),
 506   _all(&quot;-all&quot;, &quot;Dump all objects, including unreachable objects&quot;,
<span class="line-modified"> 507        &quot;BOOLEAN&quot;, false, &quot;false&quot;),</span>
<span class="line-added"> 508   _gzip(&quot;-gz&quot;, &quot;If specified, the heap dump is written in gzipped format &quot;</span>
<span class="line-added"> 509                &quot;using the given compression level. 1 (recommended) is the fastest, &quot;</span>
<span class="line-added"> 510                &quot;9 the strongest compression.&quot;, &quot;INT&quot;, false, &quot;1&quot;) {</span>
 511   _dcmdparser.add_dcmd_option(&amp;_all);
 512   _dcmdparser.add_dcmd_argument(&amp;_filename);
<span class="line-added"> 513   _dcmdparser.add_dcmd_option(&amp;_gzip);</span>
 514 }
 515 
 516 void HeapDumpDCmd::execute(DCmdSource source, TRAPS) {
<span class="line-added"> 517   jlong level = -1; // -1 means no compression.</span>
<span class="line-added"> 518 </span>
<span class="line-added"> 519   if (_gzip.is_set()) {</span>
<span class="line-added"> 520     level = _gzip.value();</span>
<span class="line-added"> 521 </span>
<span class="line-added"> 522     if (level &lt; 1 || level &gt; 9) {</span>
<span class="line-added"> 523       output()-&gt;print_cr(&quot;Compression level out of range (1-9): &quot; JLONG_FORMAT, level);</span>
<span class="line-added"> 524       return;</span>
<span class="line-added"> 525     }</span>
<span class="line-added"> 526   }</span>
<span class="line-added"> 527 </span>
 528   // Request a full GC before heap dump if _all is false
 529   // This helps reduces the amount of unreachable objects in the dump
 530   // and makes it easier to browse.
 531   HeapDumper dumper(!_all.value() /* request GC if _all is false*/);
<span class="line-modified"> 532   dumper.dump(_filename.value(), output(), (int) level);</span>
 533 }
 534 
 535 int HeapDumpDCmd::num_arguments() {
 536   ResourceMark rm;
 537   HeapDumpDCmd* dcmd = new HeapDumpDCmd(NULL, false);
 538   if (dcmd != NULL) {
 539     DCmdMark mark(dcmd);
 540     return dcmd-&gt;_dcmdparser.num_arguments();
 541   } else {
 542     return 0;
 543   }
 544 }
 545 
 546 ClassHistogramDCmd::ClassHistogramDCmd(outputStream* output, bool heap) :
 547                                        DCmdWithParser(output, heap),
 548   _all(&quot;-all&quot;, &quot;Inspect all objects, including unreachable objects&quot;,
 549        &quot;BOOLEAN&quot;, false, &quot;false&quot;) {
 550   _dcmdparser.add_dcmd_option(&amp;_all);
 551 }
 552 
</pre>
</td>
</tr>
</table>
<center><a href="../runtime/vmStructs.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="diagnosticCommand.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
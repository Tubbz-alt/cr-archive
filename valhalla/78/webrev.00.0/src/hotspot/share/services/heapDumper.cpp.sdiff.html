<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/services/heapDumper.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="diagnosticCommand.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/share/classes/java/lang/invoke/InnerClassLambdaMetafactory.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/services/heapDumper.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  29 #include &quot;classfile/javaClasses.inline.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;gc/shared/gcLocker.hpp&quot;
  34 #include &quot;gc/shared/gcVMOperations.hpp&quot;

  35 #include &quot;jfr/jfrEvents.hpp&quot;
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;memory/universe.hpp&quot;
  39 #include &quot;oops/objArrayKlass.hpp&quot;
  40 #include &quot;oops/objArrayOop.inline.hpp&quot;
  41 #include &quot;oops/oop.inline.hpp&quot;
  42 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  43 #include &quot;runtime/frame.inline.hpp&quot;
  44 #include &quot;runtime/handles.inline.hpp&quot;
  45 #include &quot;runtime/javaCalls.hpp&quot;
  46 #include &quot;runtime/jniHandles.hpp&quot;
  47 #include &quot;runtime/os.inline.hpp&quot;
  48 #include &quot;runtime/reflectionUtils.hpp&quot;
  49 #include &quot;runtime/thread.inline.hpp&quot;
  50 #include &quot;runtime/threadSMR.hpp&quot;
  51 #include &quot;runtime/vframe.hpp&quot;
  52 #include &quot;runtime/vmThread.hpp&quot;
  53 #include &quot;runtime/vmOperations.hpp&quot;
  54 #include &quot;services/heapDumper.hpp&quot;

  55 #include &quot;services/threadService.hpp&quot;
  56 #include &quot;utilities/macros.hpp&quot;
  57 #include &quot;utilities/ostream.hpp&quot;
  58 
  59 /*
  60  * HPROF binary format - description copied from:
  61  *   src/share/demo/jvmti/hprof/hprof_io.c
  62  *
  63  *
  64  *  header    &quot;JAVA PROFILE 1.0.2&quot; (0-terminated)
  65  *
  66  *  u4        size of identifiers. Identifiers are used to represent
  67  *            UTF8 strings, objects, stack traces, etc. They usually
  68  *            have the same size as host pointers. For example, on
  69  *            Solaris and Win32, the size is 4.
  70  * u4         high word
  71  * u4         low word    number of milliseconds since 0:00 GMT, 1/1/70
  72  * [record]*  a sequence of records.
  73  *
  74  *
</pre>
<hr />
<pre>
 360   HPROF_GC_ROOT_JNI_GLOBAL      = 0x01,
 361   HPROF_GC_ROOT_JNI_LOCAL       = 0x02,
 362   HPROF_GC_ROOT_JAVA_FRAME      = 0x03,
 363   HPROF_GC_ROOT_NATIVE_STACK    = 0x04,
 364   HPROF_GC_ROOT_STICKY_CLASS    = 0x05,
 365   HPROF_GC_ROOT_THREAD_BLOCK    = 0x06,
 366   HPROF_GC_ROOT_MONITOR_USED    = 0x07,
 367   HPROF_GC_ROOT_THREAD_OBJ      = 0x08,
 368   HPROF_GC_CLASS_DUMP           = 0x20,
 369   HPROF_GC_INSTANCE_DUMP        = 0x21,
 370   HPROF_GC_OBJ_ARRAY_DUMP       = 0x22,
 371   HPROF_GC_PRIM_ARRAY_DUMP      = 0x23
 372 } hprofTag;
 373 
 374 // Default stack trace ID (used for dummy HPROF_TRACE record)
 375 enum {
 376   STACK_TRACE_ID = 1,
 377   INITIAL_CLASS_COUNT = 200
 378 };
 379 
<span class="line-modified"> 380 // Supports I/O operations on a dump file</span>
 381 
 382 class DumpWriter : public StackObj {
 383  private:
 384   enum {
<span class="line-modified"> 385     io_buffer_max_size = 8*M,</span>
<span class="line-modified"> 386     io_buffer_min_size = 64*K,</span>
 387     dump_segment_header_size = 9
 388   };
 389 
<span class="line-removed"> 390   int _fd;              // file descriptor (-1 if dump file not open)</span>
<span class="line-removed"> 391   julong _bytes_written; // number of byte written to dump file</span>
<span class="line-removed"> 392 </span>
 393   char* _buffer;    // internal buffer
 394   size_t _size;
 395   size_t _pos;
 396 
 397   bool _in_dump_segment; // Are we currently in a dump segment?
 398   bool _is_huge_sub_record; // Are we writing a sub-record larger than the buffer size?
 399   DEBUG_ONLY(size_t _sub_record_left;) // The bytes not written for the current sub-record.
 400   DEBUG_ONLY(bool _sub_record_ended;) // True if we have called the end_sub_record().
 401 
<span class="line-modified"> 402   char* _error;   // error message when I/O fails</span>
<span class="line-removed"> 403 </span>
<span class="line-removed"> 404   void set_file_descriptor(int fd)              { _fd = fd; }</span>
<span class="line-removed"> 405   int file_descriptor() const                   { return _fd; }</span>
 406 
<span class="line-removed"> 407   bool is_open() const                          { return file_descriptor() &gt;= 0; }</span>
 408   void flush();
 409 
 410   char* buffer() const                          { return _buffer; }
 411   size_t buffer_size() const                    { return _size; }
 412   size_t position() const                       { return _pos; }
 413   void set_position(size_t pos)                 { _pos = pos; }
 414 
<span class="line-modified"> 415   void set_error(const char* error)             { _error = (char*)os::strdup(error); }</span>

 416 
<span class="line-modified"> 417   // all I/O go through this function</span>
<span class="line-modified"> 418   void write_internal(void* s, size_t len);</span>
 419 
 420  public:
<span class="line-modified"> 421   DumpWriter(const char* path);</span>
<span class="line-modified"> 422   ~DumpWriter();</span>
 423 
<span class="line-modified"> 424   void close();</span>
 425 
 426   // total number of bytes written to the disk
<span class="line-modified"> 427   julong bytes_written() const          { return _bytes_written; }</span>
 428 
<span class="line-modified"> 429   char* error() const                   { return _error; }</span>
 430 
 431   // writer functions
 432   void write_raw(void* s, size_t len);
<span class="line-modified"> 433   void write_u1(u1 x)                   { write_raw((void*)&amp;x, 1); }</span>
 434   void write_u2(u2 x);
 435   void write_u4(u4 x);
 436   void write_u8(u8 x);
 437   void write_objectID(oop o);
 438   void write_symbolID(Symbol* o);
 439   void write_classID(Klass* k);
 440   void write_id(u4 x);
 441 
 442   // Start a new sub-record. Starts a new heap dump segment if needed.
 443   void start_sub_record(u1 tag, u4 len);
 444   // Ends the current sub-record.
 445   void end_sub_record();
 446   // Finishes the current dump segment if not already finished.
 447   void finish_dump_segment();
<span class="line-modified"> 448 };</span>
<span class="line-modified"> 449 </span>
<span class="line-modified"> 450 DumpWriter::DumpWriter(const char* path) : _fd(-1), _bytes_written(0), _pos(0),</span>
<span class="line-modified"> 451                                            _in_dump_segment(false), _error(NULL) {</span>
<span class="line-modified"> 452   // try to allocate an I/O buffer of io_buffer_size. If there isn&#39;t</span>
<span class="line-removed"> 453   // sufficient memory then reduce size until we can allocate something.</span>
<span class="line-removed"> 454   _size = io_buffer_max_size;</span>
<span class="line-removed"> 455   do {</span>
<span class="line-removed"> 456     _buffer = (char*)os::malloc(_size, mtInternal);</span>
<span class="line-removed"> 457     if (_buffer == NULL) {</span>
<span class="line-removed"> 458       _size = _size &gt;&gt; 1;</span>
<span class="line-removed"> 459     }</span>
<span class="line-removed"> 460   } while (_buffer == NULL &amp;&amp; _size &gt;= io_buffer_min_size);</span>
<span class="line-removed"> 461 </span>
<span class="line-removed"> 462   if (_buffer == NULL) {</span>
<span class="line-removed"> 463     set_error(&quot;Could not allocate buffer memory for heap dump&quot;);</span>
<span class="line-removed"> 464   } else {</span>
 465     _fd = os::create_binary_file(path, false);    // don&#39;t replace existing file
 466 
<span class="line-modified"> 467     // if the open failed we record the error</span>
<span class="line-modified"> 468     if (_fd &lt; 0) {</span>
<span class="line-modified"> 469       set_error(os::strerror(errno));</span>
<span class="line-modified"> 470     }</span>
<span class="line-modified"> 471   }</span>



 472 }
 473 
 474 DumpWriter::~DumpWriter() {
<span class="line-modified"> 475   close();</span>
<span class="line-removed"> 476   os::free(_buffer);</span>
<span class="line-removed"> 477   os::free(_error);</span>
 478 }
 479 
<span class="line-modified"> 480 // closes dump file (if open)</span>
<span class="line-modified"> 481 void DumpWriter::close() {</span>
<span class="line-modified"> 482   // flush and close dump file</span>
<span class="line-modified"> 483   if (is_open()) {</span>
<span class="line-removed"> 484     flush();</span>
<span class="line-removed"> 485     os::close(file_descriptor());</span>
<span class="line-removed"> 486     set_file_descriptor(-1);</span>
<span class="line-removed"> 487   }</span>
<span class="line-removed"> 488 }</span>
 489 
<span class="line-modified"> 490 // write directly to the file</span>
<span class="line-modified"> 491 void DumpWriter::write_internal(void* s, size_t len) {</span>
<span class="line-modified"> 492   if (is_open()) {</span>
<span class="line-removed"> 493     const char* pos = (char*)s;</span>
<span class="line-removed"> 494     ssize_t n = 0;</span>
<span class="line-removed"> 495     while (len &gt; 0) {</span>
<span class="line-removed"> 496       uint tmp = (uint)MIN2(len, (size_t)INT_MAX);</span>
<span class="line-removed"> 497       n = os::write(file_descriptor(), pos, tmp);</span>
<span class="line-removed"> 498 </span>
<span class="line-removed"> 499       if (n &lt; 0) {</span>
<span class="line-removed"> 500         // EINTR cannot happen here, os::write will take care of that</span>
<span class="line-removed"> 501         set_error(os::strerror(errno));</span>
<span class="line-removed"> 502         os::close(file_descriptor());</span>
<span class="line-removed"> 503         set_file_descriptor(-1);</span>
<span class="line-removed"> 504         return;</span>
<span class="line-removed"> 505       }</span>
 506 
<span class="line-modified"> 507       _bytes_written += n;</span>
<span class="line-modified"> 508       pos += n;</span>
<span class="line-removed"> 509       len -= n;</span>
<span class="line-removed"> 510     }</span>
<span class="line-removed"> 511   }</span>
 512 }
 513 
 514 // write raw bytes
 515 void DumpWriter::write_raw(void* s, size_t len) {
 516   assert(!_in_dump_segment || (_sub_record_left &gt;= len), &quot;sub-record too large&quot;);
 517   debug_only(_sub_record_left -= len);
 518 
<span class="line-modified"> 519   // flush buffer to make room</span>
<span class="line-modified"> 520   if (len &gt; buffer_size() - position()) {</span>
<span class="line-modified"> 521     assert(!_in_dump_segment || _is_huge_sub_record, &quot;Cannot overflow in non-huge sub-record.&quot;);</span>
<span class="line-modified"> 522     flush();</span>
<span class="line-removed"> 523 </span>
<span class="line-removed"> 524     // If larger than the buffer, just write it directly.</span>
<span class="line-removed"> 525     if (len &gt; buffer_size()) {</span>
<span class="line-removed"> 526       write_internal(s, len);</span>
 527 
<span class="line-modified"> 528       return;</span>
<span class="line-modified"> 529     }</span>




 530   }
 531 
 532   memcpy(buffer() + position(), s, len);
 533   set_position(position() + len);
 534 }
 535 
 536 // flush any buffered bytes to the file
 537 void DumpWriter::flush() {
<span class="line-modified"> 538   write_internal(buffer(), position());</span>
<span class="line-modified"> 539   set_position(0);</span>







 540 }
 541 
 542 void DumpWriter::write_u2(u2 x) {
 543   u2 v;
 544   Bytes::put_Java_u2((address)&amp;v, x);
<span class="line-modified"> 545   write_raw((void*)&amp;v, 2);</span>
 546 }
 547 
 548 void DumpWriter::write_u4(u4 x) {
 549   u4 v;
 550   Bytes::put_Java_u4((address)&amp;v, x);
<span class="line-modified"> 551   write_raw((void*)&amp;v, 4);</span>
 552 }
 553 
 554 void DumpWriter::write_u8(u8 x) {
 555   u8 v;
 556   Bytes::put_Java_u8((address)&amp;v, x);
<span class="line-modified"> 557   write_raw((void*)&amp;v, 8);</span>
 558 }
 559 
 560 void DumpWriter::write_objectID(oop o) {
 561   address a = cast_from_oop&lt;address&gt;(o);
 562 #ifdef _LP64
 563   write_u8((u8)a);
 564 #else
 565   write_u4((u4)a);
 566 #endif
 567 }
 568 
 569 void DumpWriter::write_symbolID(Symbol* s) {
 570   address a = (address)((uintptr_t)s);
 571 #ifdef _LP64
 572   write_u8((u8)a);
 573 #else
 574   write_u4((u4)a);
 575 #endif
 576 }
 577 
</pre>
<hr />
<pre>
 580   write_u8((u8) x);
 581 #else
 582   write_u4(x);
 583 #endif
 584 }
 585 
 586 // We use java mirror as the class ID
 587 void DumpWriter::write_classID(Klass* k) {
 588   write_objectID(k-&gt;java_mirror());
 589 }
 590 
 591 void DumpWriter::finish_dump_segment() {
 592   if (_in_dump_segment) {
 593     assert(_sub_record_left == 0, &quot;Last sub-record not written completely&quot;);
 594     assert(_sub_record_ended, &quot;sub-record must have ended&quot;);
 595 
 596     // Fix up the dump segment length if we haven&#39;t written a huge sub-record last
 597     // (in which case the segment length was already set to the correct value initially).
 598     if (!_is_huge_sub_record) {
 599       assert(position() &gt; dump_segment_header_size, &quot;Dump segment should have some content&quot;);
<span class="line-modified"> 600       Bytes::put_Java_u4((address) (buffer() + 5), (u4) (position() - dump_segment_header_size));</span>

 601     }
 602 
 603     flush();
 604     _in_dump_segment = false;
 605   }
 606 }
 607 
 608 void DumpWriter::start_sub_record(u1 tag, u4 len) {
 609   if (!_in_dump_segment) {
 610     if (position() &gt; 0) {
 611       flush();
<span class="line-removed"> 612       assert(position() == 0, &quot;Must be at the start&quot;);</span>
 613     }
 614 


 615     write_u1(HPROF_HEAP_DUMP_SEGMENT);
 616     write_u4(0); // timestamp
 617     // Will be fixed up later if we add more sub-records.  If this is a huge sub-record,
 618     // this is already the correct length, since we don&#39;t add more sub-records.
 619     write_u4(len);
 620     _in_dump_segment = true;
 621     _is_huge_sub_record = len &gt; buffer_size() - dump_segment_header_size;
 622   } else if (_is_huge_sub_record || (len &gt; buffer_size() - position())) {
 623     // This object will not fit in completely or the last sub-record was huge.
 624     // Finish the current segement and try again.
 625     finish_dump_segment();
 626     start_sub_record(tag, len);
 627 
 628     return;
 629   }
 630 
 631   debug_only(_sub_record_left = len);
 632   debug_only(_sub_record_ended = false);
 633 
 634   write_u1(tag);
</pre>
<hr />
<pre>
1486   }
1487 
1488   if (DumperSupport::mask_dormant_archived_object(o) == NULL) {
1489     log_debug(cds, heap)(&quot;skipped dormant archived object &quot; INTPTR_FORMAT &quot; (%s)&quot;, p2i(o), o-&gt;klass()-&gt;external_name());
1490     return;
1491   }
1492 
1493   if (o-&gt;is_instance()) {
1494     // create a HPROF_GC_INSTANCE record for each object
1495     DumperSupport::dump_instance(writer(), o);
1496   } else if (o-&gt;is_objArray()) {
1497     // create a HPROF_GC_OBJ_ARRAY_DUMP record for each object array
1498     DumperSupport::dump_object_array(writer(), objArrayOop(o));
1499   } else if (o-&gt;is_typeArray()) {
1500     // create a HPROF_GC_PRIM_ARRAY_DUMP record for each type array
1501     DumperSupport::dump_prim_array(writer(), typeArrayOop(o));
1502   }
1503 }
1504 
1505 // The VM operation that performs the heap dump
<span class="line-modified">1506 class VM_HeapDumper : public VM_GC_Operation {</span>
1507  private:
1508   static VM_HeapDumper* _global_dumper;
1509   static DumpWriter*    _global_writer;
1510   DumpWriter*           _local_writer;
1511   JavaThread*           _oome_thread;
1512   Method*               _oome_constructor;
1513   bool _gc_before_heap_dump;
1514   GrowableArray&lt;Klass*&gt;* _klass_map;
1515   ThreadStackTrace** _stack_traces;
1516   int _num_threads;
1517 
1518   // accessors and setters
1519   static VM_HeapDumper* dumper()         {  assert(_global_dumper != NULL, &quot;Error&quot;); return _global_dumper; }
1520   static DumpWriter* writer()            {  assert(_global_writer != NULL, &quot;Error&quot;); return _global_writer; }
1521   void set_global_dumper() {
1522     assert(_global_dumper == NULL, &quot;Error&quot;);
1523     _global_dumper = this;
1524   }
1525   void set_global_writer() {
1526     assert(_global_writer == NULL, &quot;Error&quot;);
</pre>
<hr />
<pre>
1542   // writes a HPROF_GC_CLASS_DUMP records for a given basic type
1543   // array (and each multi-dimensional array too)
1544   static void do_basic_type_array_class_dump(Klass* k);
1545 
1546   // HPROF_GC_ROOT_THREAD_OBJ records
1547   int do_thread(JavaThread* thread, u4 thread_serial_num);
1548   void do_threads();
1549 
1550   void add_class_serial_number(Klass* k, int serial_num) {
1551     _klass_map-&gt;at_put_grow(serial_num, k);
1552   }
1553 
1554   // HPROF_TRACE and HPROF_FRAME records
1555   void dump_stack_traces();
1556 
1557  public:
1558   VM_HeapDumper(DumpWriter* writer, bool gc_before_heap_dump, bool oome) :
1559     VM_GC_Operation(0 /* total collections,      dummy, ignored */,
1560                     GCCause::_heap_dump /* GC Cause */,
1561                     0 /* total full collections, dummy, ignored */,
<span class="line-modified">1562                     gc_before_heap_dump) {</span>

1563     _local_writer = writer;
1564     _gc_before_heap_dump = gc_before_heap_dump;
1565     _klass_map = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;Klass*&gt;(INITIAL_CLASS_COUNT, true);
1566     _stack_traces = NULL;
1567     _num_threads = 0;
1568     if (oome) {
1569       assert(!Thread::current()-&gt;is_VM_thread(), &quot;Dump from OutOfMemoryError cannot be called by the VMThread&quot;);
1570       // get OutOfMemoryError zero-parameter constructor
1571       InstanceKlass* oome_ik = SystemDictionary::OutOfMemoryError_klass();
1572       _oome_constructor = oome_ik-&gt;find_method(vmSymbols::object_initializer_name(),
1573                                                           vmSymbols::void_method_signature());
1574       // get thread throwing OOME when generating the heap dump at OOME
1575       _oome_thread = JavaThread::current();
1576     } else {
1577       _oome_thread = NULL;
1578       _oome_constructor = NULL;
1579     }
1580   }
1581   ~VM_HeapDumper() {
1582     if (_stack_traces != NULL) {
1583       for (int i=0; i &lt; _num_threads; i++) {
1584         delete _stack_traces[i];
1585       }
1586       FREE_C_HEAP_ARRAY(ThreadStackTrace*, _stack_traces);
1587     }
1588     delete _klass_map;
1589   }
1590 
1591   VMOp_Type type() const { return VMOp_HeapDumper; }
1592   void doit();

1593 };
1594 

1595 VM_HeapDumper* VM_HeapDumper::_global_dumper = NULL;
1596 DumpWriter*    VM_HeapDumper::_global_writer = NULL;
1597 
1598 bool VM_HeapDumper::skip_operation() const {
1599   return false;
1600 }
1601 
1602 // fixes up the current dump record and writes HPROF_HEAP_DUMP_END record
1603 void DumperSupport::end_of_dump(DumpWriter* writer) {
1604   writer-&gt;finish_dump_segment();
1605 
1606   writer-&gt;write_u1(HPROF_HEAP_DUMP_END);
1607   writer-&gt;write_u4(0);
1608   writer-&gt;write_u4(0);
1609 }
1610 
1611 // writes a HPROF_LOAD_CLASS record for the class (and each of its
1612 // array classes)
1613 void VM_HeapDumper::do_load_class(Klass* k) {
1614   static u4 class_serial_num = 0;
</pre>
<hr />
<pre>
1803 
1804   HandleMark hm;
1805   CollectedHeap* ch = Universe::heap();
1806 
1807   ch-&gt;ensure_parsability(false); // must happen, even if collection does
1808                                  // not happen (e.g. due to GCLocker)
1809 
1810   if (_gc_before_heap_dump) {
1811     if (GCLocker::is_active()) {
1812       warning(&quot;GC locker is held; pre-heapdump GC was skipped&quot;);
1813     } else {
1814       ch-&gt;collect_as_vm_thread(GCCause::_heap_dump);
1815     }
1816   }
1817 
1818   // At this point we should be the only dumper active, so
1819   // the following should be safe.
1820   set_global_dumper();
1821   set_global_writer();
1822 



















1823   // Write the file header - we always use 1.0.2
<span class="line-removed">1824   size_t used = ch-&gt;used();</span>
1825   const char* header = &quot;JAVA PROFILE 1.0.2&quot;;
1826 
1827   // header is few bytes long - no chance to overflow int
1828   writer()-&gt;write_raw((void*)header, (int)strlen(header));
1829   writer()-&gt;write_u1(0); // terminator
1830   writer()-&gt;write_u4(oopSize);
1831   // timestamp is current time in ms
1832   writer()-&gt;write_u8(os::javaTimeMillis());
1833 
1834   // HPROF_UTF8 records
1835   SymbolTableDumper sym_dumper(writer());
1836   SymbolTable::symbols_do(&amp;sym_dumper);
1837 
1838   // write HPROF_LOAD_CLASS records
1839   {
1840     LockedClassesDo locked_load_classes(&amp;do_load_class);
1841     ClassLoaderDataGraph::classes_do(&amp;locked_load_classes);
1842   }
1843   Universe::basic_type_classes_do(&amp;do_load_class);
1844 
</pre>
<hr />
<pre>
1867 
1868   // HPROF_GC_ROOT_MONITOR_USED
1869   MonitorUsedDumper mon_dumper(writer());
1870   ObjectSynchronizer::oops_do(&amp;mon_dumper);
1871 
1872   // HPROF_GC_ROOT_JNI_GLOBAL
1873   JNIGlobalsDumper jni_dumper(writer());
1874   JNIHandles::oops_do(&amp;jni_dumper);
1875   Universe::oops_do(&amp;jni_dumper);  // technically not jni roots, but global roots
1876                                    // for things like preallocated throwable backtraces
1877 
1878   // HPROF_GC_ROOT_STICKY_CLASS
1879   // These should be classes in the NULL class loader data, and not all classes
1880   // if !ClassUnloading
1881   StickyClassDumper class_dumper(writer());
1882   ClassLoaderData::the_null_class_loader_data()-&gt;classes_do(&amp;class_dumper);
1883 
1884   // Writes the HPROF_HEAP_DUMP_END record.
1885   DumperSupport::end_of_dump(writer());
1886 
<span class="line-modified">1887   // Now we clear the global variables, so that a future dumper might run.</span>
<span class="line-modified">1888   clear_global_dumper();</span>
<span class="line-removed">1889   clear_global_writer();</span>
1890 }
1891 
1892 void VM_HeapDumper::dump_stack_traces() {
1893   // write a HPROF_TRACE record without any frames to be referenced as object alloc sites
1894   DumperSupport::write_header(writer(), HPROF_TRACE, 3*sizeof(u4));
1895   writer()-&gt;write_u4((u4) STACK_TRACE_ID);
1896   writer()-&gt;write_u4(0);                    // thread number
1897   writer()-&gt;write_u4(0);                    // frame count
1898 
1899   _stack_traces = NEW_C_HEAP_ARRAY(ThreadStackTrace*, Threads::number_of_threads(), mtInternal);
1900   int frame_serial_num = 0;
1901   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {
1902     oop threadObj = thread-&gt;threadObj();
1903     if (threadObj != NULL &amp;&amp; !thread-&gt;is_exiting() &amp;&amp; !thread-&gt;is_hidden_from_external_view()) {
1904       // dump thread stack trace

1905       ThreadStackTrace* stack_trace = new ThreadStackTrace(thread, false);
1906       stack_trace-&gt;dump_stack_at_safepoint(-1);
1907       _stack_traces[_num_threads++] = stack_trace;
1908 
1909       // write HPROF_FRAME records for this thread&#39;s stack trace
1910       int depth = stack_trace-&gt;get_stack_depth();
1911       int thread_frame_start = frame_serial_num;
1912       int extra_frames = 0;
1913       // write fake frame that makes it look like the thread, which caused OOME,
1914       // is in the OutOfMemoryError zero-parameter constructor
1915       if (thread == _oome_thread &amp;&amp; _oome_constructor != NULL) {
1916         int oome_serial_num = _klass_map-&gt;find(_oome_constructor-&gt;method_holder());
1917         // the class serial number starts from 1
1918         assert(oome_serial_num &gt; 0, &quot;OutOfMemoryError class not found&quot;);
1919         DumperSupport::dump_stack_frame(writer(), ++frame_serial_num, oome_serial_num,
1920                                         _oome_constructor, 0);
1921         extra_frames++;
1922       }
1923       for (int j=0; j &lt; depth; j++) {
1924         StackFrameInfo* frame = stack_trace-&gt;stack_frame_at(j);
</pre>
<hr />
<pre>
1927         // the class serial number starts from 1
1928         assert(class_serial_num &gt; 0, &quot;class not found&quot;);
1929         DumperSupport::dump_stack_frame(writer(), ++frame_serial_num, class_serial_num, m, frame-&gt;bci());
1930       }
1931       depth += extra_frames;
1932 
1933       // write HPROF_TRACE record for one thread
1934       DumperSupport::write_header(writer(), HPROF_TRACE, 3*sizeof(u4) + depth*oopSize);
1935       int stack_serial_num = _num_threads + STACK_TRACE_ID;
1936       writer()-&gt;write_u4(stack_serial_num);      // stack trace serial number
1937       writer()-&gt;write_u4((u4) _num_threads);     // thread serial number
1938       writer()-&gt;write_u4(depth);                 // frame count
1939       for (int j=1; j &lt;= depth; j++) {
1940         writer()-&gt;write_id(thread_frame_start + j);
1941       }
1942     }
1943   }
1944 }
1945 
1946 // dump the heap to given path.
<span class="line-modified">1947 int HeapDumper::dump(const char* path, outputStream* out) {</span>
1948   assert(path != NULL &amp;&amp; strlen(path) &gt; 0, &quot;path missing&quot;);
1949 
1950   // print message in interactive case
1951   if (out != NULL) {
1952     out-&gt;print_cr(&quot;Dumping heap to %s ...&quot;, path);
1953     timer()-&gt;start();
1954   }
1955 
1956   // create JFR event
1957   EventHeapDump event;
1958 
<span class="line-modified">1959   // create the dump writer. If the file can be opened then bail</span>
<span class="line-modified">1960   DumpWriter writer(path);</span>











1961   if (writer.error() != NULL) {
1962     set_error(writer.error());
1963     if (out != NULL) {
1964       out-&gt;print_cr(&quot;Unable to create %s: %s&quot;, path,
1965         (error() != NULL) ? error() : &quot;reason unknown&quot;);
1966     }
1967     return -1;
1968   }
1969 
1970   // generate the dump
1971   VM_HeapDumper dumper(&amp;writer, _gc_before_heap_dump, _oome);
1972   if (Thread::current()-&gt;is_VM_thread()) {
1973     assert(SafepointSynchronize::is_at_safepoint(), &quot;Expected to be called at a safepoint&quot;);
1974     dumper.doit();
1975   } else {
1976     VMThread::execute(&amp;dumper);
1977   }
1978 
<span class="line-modified">1979   // close dump file and record any error that the writer may have encountered</span>
<span class="line-removed">1980   writer.close();</span>
1981   set_error(writer.error());
1982 
1983   // emit JFR event
1984   if (error() == NULL) {
1985     event.set_destination(path);
1986     event.set_gcBeforeDump(_gc_before_heap_dump);
1987     event.set_size(writer.bytes_written());
1988     event.set_onOutOfMemoryError(_oome);
1989     event.commit();
1990   }
1991 
1992   // print message in interactive case
1993   if (out != NULL) {
1994     timer()-&gt;stop();
1995     if (error() == NULL) {
1996       out-&gt;print_cr(&quot;Heap dump file created [&quot; JULONG_FORMAT &quot; bytes in %3.3f secs]&quot;,
1997                     writer.bytes_written(), timer()-&gt;seconds());
1998     } else {
1999       out-&gt;print_cr(&quot;Dump file is incomplete: %s&quot;, writer.error());
2000     }
</pre>
<hr />
<pre>
2007 HeapDumper::~HeapDumper() {
2008   if (timer()-&gt;is_active()) {
2009     timer()-&gt;stop();
2010   }
2011   set_error(NULL);
2012 }
2013 
2014 
2015 // returns the error string (resource allocated), or NULL
2016 char* HeapDumper::error_as_C_string() const {
2017   if (error() != NULL) {
2018     char* str = NEW_RESOURCE_ARRAY(char, strlen(error())+1);
2019     strcpy(str, error());
2020     return str;
2021   } else {
2022     return NULL;
2023   }
2024 }
2025 
2026 // set the error string
<span class="line-modified">2027 void HeapDumper::set_error(char* error) {</span>
2028   if (_error != NULL) {
2029     os::free(_error);
2030   }
2031   if (error == NULL) {
2032     _error = NULL;
2033   } else {
2034     _error = os::strdup(error);
2035     assert(_error != NULL, &quot;allocation failure&quot;);
2036   }
2037 }
2038 
2039 // Called by out-of-memory error reporting by a single Java thread
2040 // outside of a JVM safepoint
2041 void HeapDumper::dump_heap_from_oome() {
2042   HeapDumper::dump_heap(true);
2043 }
2044 
2045 // Called by error reporting by a single Java thread outside of a JVM safepoint,
2046 // or by heap dumping by the VM thread during a (GC) safepoint. Thus, these various
2047 // callers are strictly serialized and guaranteed not to interfere below. For more
</pre>
</td>
<td>
<hr />
<pre>
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  28 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  29 #include &quot;classfile/javaClasses.inline.hpp&quot;
  30 #include &quot;classfile/symbolTable.hpp&quot;
  31 #include &quot;classfile/systemDictionary.hpp&quot;
  32 #include &quot;classfile/vmSymbols.hpp&quot;
  33 #include &quot;gc/shared/gcLocker.hpp&quot;
  34 #include &quot;gc/shared/gcVMOperations.hpp&quot;
<span class="line-added">  35 #include &quot;gc/shared/workgroup.hpp&quot;</span>
  36 #include &quot;jfr/jfrEvents.hpp&quot;
  37 #include &quot;memory/allocation.inline.hpp&quot;
  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;memory/universe.hpp&quot;
  40 #include &quot;oops/objArrayKlass.hpp&quot;
  41 #include &quot;oops/objArrayOop.inline.hpp&quot;
  42 #include &quot;oops/oop.inline.hpp&quot;
  43 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  44 #include &quot;runtime/frame.inline.hpp&quot;
  45 #include &quot;runtime/handles.inline.hpp&quot;
  46 #include &quot;runtime/javaCalls.hpp&quot;
  47 #include &quot;runtime/jniHandles.hpp&quot;
  48 #include &quot;runtime/os.inline.hpp&quot;
  49 #include &quot;runtime/reflectionUtils.hpp&quot;
  50 #include &quot;runtime/thread.inline.hpp&quot;
  51 #include &quot;runtime/threadSMR.hpp&quot;
  52 #include &quot;runtime/vframe.hpp&quot;
  53 #include &quot;runtime/vmThread.hpp&quot;
  54 #include &quot;runtime/vmOperations.hpp&quot;
  55 #include &quot;services/heapDumper.hpp&quot;
<span class="line-added">  56 #include &quot;services/heapDumperCompression.hpp&quot;</span>
  57 #include &quot;services/threadService.hpp&quot;
  58 #include &quot;utilities/macros.hpp&quot;
  59 #include &quot;utilities/ostream.hpp&quot;
  60 
  61 /*
  62  * HPROF binary format - description copied from:
  63  *   src/share/demo/jvmti/hprof/hprof_io.c
  64  *
  65  *
  66  *  header    &quot;JAVA PROFILE 1.0.2&quot; (0-terminated)
  67  *
  68  *  u4        size of identifiers. Identifiers are used to represent
  69  *            UTF8 strings, objects, stack traces, etc. They usually
  70  *            have the same size as host pointers. For example, on
  71  *            Solaris and Win32, the size is 4.
  72  * u4         high word
  73  * u4         low word    number of milliseconds since 0:00 GMT, 1/1/70
  74  * [record]*  a sequence of records.
  75  *
  76  *
</pre>
<hr />
<pre>
 362   HPROF_GC_ROOT_JNI_GLOBAL      = 0x01,
 363   HPROF_GC_ROOT_JNI_LOCAL       = 0x02,
 364   HPROF_GC_ROOT_JAVA_FRAME      = 0x03,
 365   HPROF_GC_ROOT_NATIVE_STACK    = 0x04,
 366   HPROF_GC_ROOT_STICKY_CLASS    = 0x05,
 367   HPROF_GC_ROOT_THREAD_BLOCK    = 0x06,
 368   HPROF_GC_ROOT_MONITOR_USED    = 0x07,
 369   HPROF_GC_ROOT_THREAD_OBJ      = 0x08,
 370   HPROF_GC_CLASS_DUMP           = 0x20,
 371   HPROF_GC_INSTANCE_DUMP        = 0x21,
 372   HPROF_GC_OBJ_ARRAY_DUMP       = 0x22,
 373   HPROF_GC_PRIM_ARRAY_DUMP      = 0x23
 374 } hprofTag;
 375 
 376 // Default stack trace ID (used for dummy HPROF_TRACE record)
 377 enum {
 378   STACK_TRACE_ID = 1,
 379   INITIAL_CLASS_COUNT = 200
 380 };
 381 
<span class="line-modified"> 382 // Supports I/O operations for a dump</span>
 383 
 384 class DumpWriter : public StackObj {
 385  private:
 386   enum {
<span class="line-modified"> 387     io_buffer_max_size = 1*M,</span>
<span class="line-modified"> 388     io_buffer_max_waste = 10*K,</span>
 389     dump_segment_header_size = 9
 390   };
 391 



 392   char* _buffer;    // internal buffer
 393   size_t _size;
 394   size_t _pos;
 395 
 396   bool _in_dump_segment; // Are we currently in a dump segment?
 397   bool _is_huge_sub_record; // Are we writing a sub-record larger than the buffer size?
 398   DEBUG_ONLY(size_t _sub_record_left;) // The bytes not written for the current sub-record.
 399   DEBUG_ONLY(bool _sub_record_ended;) // True if we have called the end_sub_record().
 400 
<span class="line-modified"> 401   CompressionBackend _backend; // Does the actual writing.</span>



 402 

 403   void flush();
 404 
 405   char* buffer() const                          { return _buffer; }
 406   size_t buffer_size() const                    { return _size; }
 407   size_t position() const                       { return _pos; }
 408   void set_position(size_t pos)                 { _pos = pos; }
 409 
<span class="line-modified"> 410   // Can be called if we have enough room in the buffer.</span>
<span class="line-added"> 411   void write_fast(void* s, size_t len);</span>
 412 
<span class="line-modified"> 413   // Returns true if we have enough room in the buffer for &#39;len&#39; bytes.</span>
<span class="line-modified"> 414   bool can_write_fast(size_t len);</span>
 415 
 416  public:
<span class="line-modified"> 417   // Takes ownership of the writer and compressor.</span>
<span class="line-modified"> 418   DumpWriter(AbstractWriter* writer, AbstractCompressor* compressor);</span>
 419 
<span class="line-modified"> 420   ~DumpWriter();</span>
 421 
 422   // total number of bytes written to the disk
<span class="line-modified"> 423   julong bytes_written() const          { return (julong) _backend.get_written(); }</span>
 424 
<span class="line-modified"> 425   char const* error() const             { return _backend.error(); }</span>
 426 
 427   // writer functions
 428   void write_raw(void* s, size_t len);
<span class="line-modified"> 429   void write_u1(u1 x);</span>
 430   void write_u2(u2 x);
 431   void write_u4(u4 x);
 432   void write_u8(u8 x);
 433   void write_objectID(oop o);
 434   void write_symbolID(Symbol* o);
 435   void write_classID(Klass* k);
 436   void write_id(u4 x);
 437 
 438   // Start a new sub-record. Starts a new heap dump segment if needed.
 439   void start_sub_record(u1 tag, u4 len);
 440   // Ends the current sub-record.
 441   void end_sub_record();
 442   // Finishes the current dump segment if not already finished.
 443   void finish_dump_segment();
<span class="line-modified"> 444 </span>
<span class="line-modified"> 445   // Called by threads used for parallel writing.</span>
<span class="line-modified"> 446   void writer_loop()                    { _backend.thread_loop(false); }</span>
<span class="line-modified"> 447   // Called when finished to release the threads.</span>
<span class="line-modified"> 448   void deactivate()                     { flush(); _backend.deactivate(); }</span>












 449 };
 450 
<span class="line-modified"> 451 // Check for error after constructing the object and destroy it in case of an error.</span>
<span class="line-modified"> 452 DumpWriter::DumpWriter(AbstractWriter* writer, AbstractCompressor* compressor) :</span>
<span class="line-modified"> 453   _buffer(NULL),</span>
<span class="line-modified"> 454   _size(0),</span>
<span class="line-modified"> 455   _pos(0),</span>
<span class="line-added"> 456   _in_dump_segment(false),</span>
<span class="line-added"> 457   _backend(writer, compressor, io_buffer_max_size, io_buffer_max_waste) {</span>
<span class="line-added"> 458   flush();</span>
 459 }
 460 
 461 DumpWriter::~DumpWriter() {
<span class="line-modified"> 462   flush();</span>


 463 }
 464 
<span class="line-modified"> 465 void DumpWriter::write_fast(void* s, size_t len) {</span>
<span class="line-modified"> 466   assert(!_in_dump_segment || (_sub_record_left &gt;= len), &quot;sub-record too large&quot;);</span>
<span class="line-modified"> 467   assert(buffer_size() - position() &gt;= len, &quot;Must fit&quot;);</span>
<span class="line-modified"> 468   debug_only(_sub_record_left -= len);</span>





 469 
<span class="line-modified"> 470   memcpy(buffer() + position(), s, len);</span>
<span class="line-modified"> 471   set_position(position() + len);</span>
<span class="line-modified"> 472 }</span>













 473 
<span class="line-modified"> 474 bool DumpWriter::can_write_fast(size_t len) {</span>
<span class="line-modified"> 475   return buffer_size() - position() &gt;= len;</span>



 476 }
 477 
 478 // write raw bytes
 479 void DumpWriter::write_raw(void* s, size_t len) {
 480   assert(!_in_dump_segment || (_sub_record_left &gt;= len), &quot;sub-record too large&quot;);
 481   debug_only(_sub_record_left -= len);
 482 
<span class="line-modified"> 483   // flush buffer to make room.</span>
<span class="line-modified"> 484   while (len &gt; buffer_size() - position()) {</span>
<span class="line-modified"> 485     assert(!_in_dump_segment || _is_huge_sub_record,</span>
<span class="line-modified"> 486            &quot;Cannot overflow in non-huge sub-record.&quot;);</span>




 487 
<span class="line-modified"> 488     size_t to_write = buffer_size() - position();</span>
<span class="line-modified"> 489     memcpy(buffer() + position(), s, to_write);</span>
<span class="line-added"> 490     s = (void*) ((char*) s + to_write);</span>
<span class="line-added"> 491     len -= to_write;</span>
<span class="line-added"> 492     set_position(position() + to_write);</span>
<span class="line-added"> 493     flush();</span>
 494   }
 495 
 496   memcpy(buffer() + position(), s, len);
 497   set_position(position() + len);
 498 }
 499 
 500 // flush any buffered bytes to the file
 501 void DumpWriter::flush() {
<span class="line-modified"> 502   _backend.get_new_buffer(&amp;_buffer, &amp;_pos, &amp;_size);</span>
<span class="line-modified"> 503 }</span>
<span class="line-added"> 504 </span>
<span class="line-added"> 505 // Makes sure we inline the fast write into the write_u* functions. This is a big speedup.</span>
<span class="line-added"> 506 #define WRITE_KNOWN_TYPE(p, len) do { if (can_write_fast((len))) write_fast((p), (len)); \</span>
<span class="line-added"> 507                                       else write_raw((p), (len)); } while (0)</span>
<span class="line-added"> 508 </span>
<span class="line-added"> 509 void DumpWriter::write_u1(u1 x) {</span>
<span class="line-added"> 510   WRITE_KNOWN_TYPE((void*) &amp;x, 1);</span>
 511 }
 512 
 513 void DumpWriter::write_u2(u2 x) {
 514   u2 v;
 515   Bytes::put_Java_u2((address)&amp;v, x);
<span class="line-modified"> 516   WRITE_KNOWN_TYPE((void*)&amp;v, 2);</span>
 517 }
 518 
 519 void DumpWriter::write_u4(u4 x) {
 520   u4 v;
 521   Bytes::put_Java_u4((address)&amp;v, x);
<span class="line-modified"> 522   WRITE_KNOWN_TYPE((void*)&amp;v, 4);</span>
 523 }
 524 
 525 void DumpWriter::write_u8(u8 x) {
 526   u8 v;
 527   Bytes::put_Java_u8((address)&amp;v, x);
<span class="line-modified"> 528   WRITE_KNOWN_TYPE((void*)&amp;v, 8);</span>
 529 }
 530 
 531 void DumpWriter::write_objectID(oop o) {
 532   address a = cast_from_oop&lt;address&gt;(o);
 533 #ifdef _LP64
 534   write_u8((u8)a);
 535 #else
 536   write_u4((u4)a);
 537 #endif
 538 }
 539 
 540 void DumpWriter::write_symbolID(Symbol* s) {
 541   address a = (address)((uintptr_t)s);
 542 #ifdef _LP64
 543   write_u8((u8)a);
 544 #else
 545   write_u4((u4)a);
 546 #endif
 547 }
 548 
</pre>
<hr />
<pre>
 551   write_u8((u8) x);
 552 #else
 553   write_u4(x);
 554 #endif
 555 }
 556 
 557 // We use java mirror as the class ID
 558 void DumpWriter::write_classID(Klass* k) {
 559   write_objectID(k-&gt;java_mirror());
 560 }
 561 
 562 void DumpWriter::finish_dump_segment() {
 563   if (_in_dump_segment) {
 564     assert(_sub_record_left == 0, &quot;Last sub-record not written completely&quot;);
 565     assert(_sub_record_ended, &quot;sub-record must have ended&quot;);
 566 
 567     // Fix up the dump segment length if we haven&#39;t written a huge sub-record last
 568     // (in which case the segment length was already set to the correct value initially).
 569     if (!_is_huge_sub_record) {
 570       assert(position() &gt; dump_segment_header_size, &quot;Dump segment should have some content&quot;);
<span class="line-modified"> 571       Bytes::put_Java_u4((address) (buffer() + 5),</span>
<span class="line-added"> 572                          (u4) (position() - dump_segment_header_size));</span>
 573     }
 574 
 575     flush();
 576     _in_dump_segment = false;
 577   }
 578 }
 579 
 580 void DumpWriter::start_sub_record(u1 tag, u4 len) {
 581   if (!_in_dump_segment) {
 582     if (position() &gt; 0) {
 583       flush();

 584     }
 585 
<span class="line-added"> 586     assert(position() == 0, &quot;Must be at the start&quot;);</span>
<span class="line-added"> 587 </span>
 588     write_u1(HPROF_HEAP_DUMP_SEGMENT);
 589     write_u4(0); // timestamp
 590     // Will be fixed up later if we add more sub-records.  If this is a huge sub-record,
 591     // this is already the correct length, since we don&#39;t add more sub-records.
 592     write_u4(len);
 593     _in_dump_segment = true;
 594     _is_huge_sub_record = len &gt; buffer_size() - dump_segment_header_size;
 595   } else if (_is_huge_sub_record || (len &gt; buffer_size() - position())) {
 596     // This object will not fit in completely or the last sub-record was huge.
 597     // Finish the current segement and try again.
 598     finish_dump_segment();
 599     start_sub_record(tag, len);
 600 
 601     return;
 602   }
 603 
 604   debug_only(_sub_record_left = len);
 605   debug_only(_sub_record_ended = false);
 606 
 607   write_u1(tag);
</pre>
<hr />
<pre>
1459   }
1460 
1461   if (DumperSupport::mask_dormant_archived_object(o) == NULL) {
1462     log_debug(cds, heap)(&quot;skipped dormant archived object &quot; INTPTR_FORMAT &quot; (%s)&quot;, p2i(o), o-&gt;klass()-&gt;external_name());
1463     return;
1464   }
1465 
1466   if (o-&gt;is_instance()) {
1467     // create a HPROF_GC_INSTANCE record for each object
1468     DumperSupport::dump_instance(writer(), o);
1469   } else if (o-&gt;is_objArray()) {
1470     // create a HPROF_GC_OBJ_ARRAY_DUMP record for each object array
1471     DumperSupport::dump_object_array(writer(), objArrayOop(o));
1472   } else if (o-&gt;is_typeArray()) {
1473     // create a HPROF_GC_PRIM_ARRAY_DUMP record for each type array
1474     DumperSupport::dump_prim_array(writer(), typeArrayOop(o));
1475   }
1476 }
1477 
1478 // The VM operation that performs the heap dump
<span class="line-modified">1479 class VM_HeapDumper : public VM_GC_Operation, public AbstractGangTask {</span>
1480  private:
1481   static VM_HeapDumper* _global_dumper;
1482   static DumpWriter*    _global_writer;
1483   DumpWriter*           _local_writer;
1484   JavaThread*           _oome_thread;
1485   Method*               _oome_constructor;
1486   bool _gc_before_heap_dump;
1487   GrowableArray&lt;Klass*&gt;* _klass_map;
1488   ThreadStackTrace** _stack_traces;
1489   int _num_threads;
1490 
1491   // accessors and setters
1492   static VM_HeapDumper* dumper()         {  assert(_global_dumper != NULL, &quot;Error&quot;); return _global_dumper; }
1493   static DumpWriter* writer()            {  assert(_global_writer != NULL, &quot;Error&quot;); return _global_writer; }
1494   void set_global_dumper() {
1495     assert(_global_dumper == NULL, &quot;Error&quot;);
1496     _global_dumper = this;
1497   }
1498   void set_global_writer() {
1499     assert(_global_writer == NULL, &quot;Error&quot;);
</pre>
<hr />
<pre>
1515   // writes a HPROF_GC_CLASS_DUMP records for a given basic type
1516   // array (and each multi-dimensional array too)
1517   static void do_basic_type_array_class_dump(Klass* k);
1518 
1519   // HPROF_GC_ROOT_THREAD_OBJ records
1520   int do_thread(JavaThread* thread, u4 thread_serial_num);
1521   void do_threads();
1522 
1523   void add_class_serial_number(Klass* k, int serial_num) {
1524     _klass_map-&gt;at_put_grow(serial_num, k);
1525   }
1526 
1527   // HPROF_TRACE and HPROF_FRAME records
1528   void dump_stack_traces();
1529 
1530  public:
1531   VM_HeapDumper(DumpWriter* writer, bool gc_before_heap_dump, bool oome) :
1532     VM_GC_Operation(0 /* total collections,      dummy, ignored */,
1533                     GCCause::_heap_dump /* GC Cause */,
1534                     0 /* total full collections, dummy, ignored */,
<span class="line-modified">1535                     gc_before_heap_dump),</span>
<span class="line-added">1536     AbstractGangTask(&quot;dump heap&quot;) {</span>
1537     _local_writer = writer;
1538     _gc_before_heap_dump = gc_before_heap_dump;
1539     _klass_map = new (ResourceObj::C_HEAP, mtInternal) GrowableArray&lt;Klass*&gt;(INITIAL_CLASS_COUNT, true);
1540     _stack_traces = NULL;
1541     _num_threads = 0;
1542     if (oome) {
1543       assert(!Thread::current()-&gt;is_VM_thread(), &quot;Dump from OutOfMemoryError cannot be called by the VMThread&quot;);
1544       // get OutOfMemoryError zero-parameter constructor
1545       InstanceKlass* oome_ik = SystemDictionary::OutOfMemoryError_klass();
1546       _oome_constructor = oome_ik-&gt;find_method(vmSymbols::object_initializer_name(),
1547                                                           vmSymbols::void_method_signature());
1548       // get thread throwing OOME when generating the heap dump at OOME
1549       _oome_thread = JavaThread::current();
1550     } else {
1551       _oome_thread = NULL;
1552       _oome_constructor = NULL;
1553     }
1554   }
1555   ~VM_HeapDumper() {
1556     if (_stack_traces != NULL) {
1557       for (int i=0; i &lt; _num_threads; i++) {
1558         delete _stack_traces[i];
1559       }
1560       FREE_C_HEAP_ARRAY(ThreadStackTrace*, _stack_traces);
1561     }
1562     delete _klass_map;
1563   }
1564 
1565   VMOp_Type type() const { return VMOp_HeapDumper; }
1566   void doit();
<span class="line-added">1567   void work(uint worker_id);</span>
1568 };
1569 
<span class="line-added">1570 </span>
1571 VM_HeapDumper* VM_HeapDumper::_global_dumper = NULL;
1572 DumpWriter*    VM_HeapDumper::_global_writer = NULL;
1573 
1574 bool VM_HeapDumper::skip_operation() const {
1575   return false;
1576 }
1577 
1578 // fixes up the current dump record and writes HPROF_HEAP_DUMP_END record
1579 void DumperSupport::end_of_dump(DumpWriter* writer) {
1580   writer-&gt;finish_dump_segment();
1581 
1582   writer-&gt;write_u1(HPROF_HEAP_DUMP_END);
1583   writer-&gt;write_u4(0);
1584   writer-&gt;write_u4(0);
1585 }
1586 
1587 // writes a HPROF_LOAD_CLASS record for the class (and each of its
1588 // array classes)
1589 void VM_HeapDumper::do_load_class(Klass* k) {
1590   static u4 class_serial_num = 0;
</pre>
<hr />
<pre>
1779 
1780   HandleMark hm;
1781   CollectedHeap* ch = Universe::heap();
1782 
1783   ch-&gt;ensure_parsability(false); // must happen, even if collection does
1784                                  // not happen (e.g. due to GCLocker)
1785 
1786   if (_gc_before_heap_dump) {
1787     if (GCLocker::is_active()) {
1788       warning(&quot;GC locker is held; pre-heapdump GC was skipped&quot;);
1789     } else {
1790       ch-&gt;collect_as_vm_thread(GCCause::_heap_dump);
1791     }
1792   }
1793 
1794   // At this point we should be the only dumper active, so
1795   // the following should be safe.
1796   set_global_dumper();
1797   set_global_writer();
1798 
<span class="line-added">1799   WorkGang* gang = ch-&gt;get_safepoint_workers();</span>
<span class="line-added">1800 </span>
<span class="line-added">1801   if (gang == NULL) {</span>
<span class="line-added">1802     work(0);</span>
<span class="line-added">1803   } else {</span>
<span class="line-added">1804     gang-&gt;run_task(this, gang-&gt;active_workers(), true);</span>
<span class="line-added">1805   }</span>
<span class="line-added">1806 </span>
<span class="line-added">1807   // Now we clear the global variables, so that a future dumper can run.</span>
<span class="line-added">1808   clear_global_dumper();</span>
<span class="line-added">1809   clear_global_writer();</span>
<span class="line-added">1810 }</span>
<span class="line-added">1811 </span>
<span class="line-added">1812 void VM_HeapDumper::work(uint worker_id) {</span>
<span class="line-added">1813   if (!Thread::current()-&gt;is_VM_thread()) {</span>
<span class="line-added">1814     writer()-&gt;writer_loop();</span>
<span class="line-added">1815     return;</span>
<span class="line-added">1816   }</span>
<span class="line-added">1817 </span>
1818   // Write the file header - we always use 1.0.2

1819   const char* header = &quot;JAVA PROFILE 1.0.2&quot;;
1820 
1821   // header is few bytes long - no chance to overflow int
1822   writer()-&gt;write_raw((void*)header, (int)strlen(header));
1823   writer()-&gt;write_u1(0); // terminator
1824   writer()-&gt;write_u4(oopSize);
1825   // timestamp is current time in ms
1826   writer()-&gt;write_u8(os::javaTimeMillis());
1827 
1828   // HPROF_UTF8 records
1829   SymbolTableDumper sym_dumper(writer());
1830   SymbolTable::symbols_do(&amp;sym_dumper);
1831 
1832   // write HPROF_LOAD_CLASS records
1833   {
1834     LockedClassesDo locked_load_classes(&amp;do_load_class);
1835     ClassLoaderDataGraph::classes_do(&amp;locked_load_classes);
1836   }
1837   Universe::basic_type_classes_do(&amp;do_load_class);
1838 
</pre>
<hr />
<pre>
1861 
1862   // HPROF_GC_ROOT_MONITOR_USED
1863   MonitorUsedDumper mon_dumper(writer());
1864   ObjectSynchronizer::oops_do(&amp;mon_dumper);
1865 
1866   // HPROF_GC_ROOT_JNI_GLOBAL
1867   JNIGlobalsDumper jni_dumper(writer());
1868   JNIHandles::oops_do(&amp;jni_dumper);
1869   Universe::oops_do(&amp;jni_dumper);  // technically not jni roots, but global roots
1870                                    // for things like preallocated throwable backtraces
1871 
1872   // HPROF_GC_ROOT_STICKY_CLASS
1873   // These should be classes in the NULL class loader data, and not all classes
1874   // if !ClassUnloading
1875   StickyClassDumper class_dumper(writer());
1876   ClassLoaderData::the_null_class_loader_data()-&gt;classes_do(&amp;class_dumper);
1877 
1878   // Writes the HPROF_HEAP_DUMP_END record.
1879   DumperSupport::end_of_dump(writer());
1880 
<span class="line-modified">1881   // We are done with writing. Release the worker threads.</span>
<span class="line-modified">1882   writer()-&gt;deactivate();</span>

1883 }
1884 
1885 void VM_HeapDumper::dump_stack_traces() {
1886   // write a HPROF_TRACE record without any frames to be referenced as object alloc sites
1887   DumperSupport::write_header(writer(), HPROF_TRACE, 3*sizeof(u4));
1888   writer()-&gt;write_u4((u4) STACK_TRACE_ID);
1889   writer()-&gt;write_u4(0);                    // thread number
1890   writer()-&gt;write_u4(0);                    // frame count
1891 
1892   _stack_traces = NEW_C_HEAP_ARRAY(ThreadStackTrace*, Threads::number_of_threads(), mtInternal);
1893   int frame_serial_num = 0;
1894   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) {
1895     oop threadObj = thread-&gt;threadObj();
1896     if (threadObj != NULL &amp;&amp; !thread-&gt;is_exiting() &amp;&amp; !thread-&gt;is_hidden_from_external_view()) {
1897       // dump thread stack trace
<span class="line-added">1898       ResourceMark rm;</span>
1899       ThreadStackTrace* stack_trace = new ThreadStackTrace(thread, false);
1900       stack_trace-&gt;dump_stack_at_safepoint(-1);
1901       _stack_traces[_num_threads++] = stack_trace;
1902 
1903       // write HPROF_FRAME records for this thread&#39;s stack trace
1904       int depth = stack_trace-&gt;get_stack_depth();
1905       int thread_frame_start = frame_serial_num;
1906       int extra_frames = 0;
1907       // write fake frame that makes it look like the thread, which caused OOME,
1908       // is in the OutOfMemoryError zero-parameter constructor
1909       if (thread == _oome_thread &amp;&amp; _oome_constructor != NULL) {
1910         int oome_serial_num = _klass_map-&gt;find(_oome_constructor-&gt;method_holder());
1911         // the class serial number starts from 1
1912         assert(oome_serial_num &gt; 0, &quot;OutOfMemoryError class not found&quot;);
1913         DumperSupport::dump_stack_frame(writer(), ++frame_serial_num, oome_serial_num,
1914                                         _oome_constructor, 0);
1915         extra_frames++;
1916       }
1917       for (int j=0; j &lt; depth; j++) {
1918         StackFrameInfo* frame = stack_trace-&gt;stack_frame_at(j);
</pre>
<hr />
<pre>
1921         // the class serial number starts from 1
1922         assert(class_serial_num &gt; 0, &quot;class not found&quot;);
1923         DumperSupport::dump_stack_frame(writer(), ++frame_serial_num, class_serial_num, m, frame-&gt;bci());
1924       }
1925       depth += extra_frames;
1926 
1927       // write HPROF_TRACE record for one thread
1928       DumperSupport::write_header(writer(), HPROF_TRACE, 3*sizeof(u4) + depth*oopSize);
1929       int stack_serial_num = _num_threads + STACK_TRACE_ID;
1930       writer()-&gt;write_u4(stack_serial_num);      // stack trace serial number
1931       writer()-&gt;write_u4((u4) _num_threads);     // thread serial number
1932       writer()-&gt;write_u4(depth);                 // frame count
1933       for (int j=1; j &lt;= depth; j++) {
1934         writer()-&gt;write_id(thread_frame_start + j);
1935       }
1936     }
1937   }
1938 }
1939 
1940 // dump the heap to given path.
<span class="line-modified">1941 int HeapDumper::dump(const char* path, outputStream* out, int compression) {</span>
1942   assert(path != NULL &amp;&amp; strlen(path) &gt; 0, &quot;path missing&quot;);
1943 
1944   // print message in interactive case
1945   if (out != NULL) {
1946     out-&gt;print_cr(&quot;Dumping heap to %s ...&quot;, path);
1947     timer()-&gt;start();
1948   }
1949 
1950   // create JFR event
1951   EventHeapDump event;
1952 
<span class="line-modified">1953   AbstractCompressor* compressor = NULL;</span>
<span class="line-modified">1954 </span>
<span class="line-added">1955   if (compression &gt; 0) {</span>
<span class="line-added">1956     compressor = new (std::nothrow) GZipCompressor(compression);</span>
<span class="line-added">1957 </span>
<span class="line-added">1958     if (compressor == NULL) {</span>
<span class="line-added">1959       set_error(&quot;Could not allocate gzip compressor&quot;);</span>
<span class="line-added">1960       return -1;</span>
<span class="line-added">1961     }</span>
<span class="line-added">1962   }</span>
<span class="line-added">1963 </span>
<span class="line-added">1964   DumpWriter writer(new (std::nothrow) FileWriter(path), compressor);</span>
<span class="line-added">1965 </span>
1966   if (writer.error() != NULL) {
1967     set_error(writer.error());
1968     if (out != NULL) {
1969       out-&gt;print_cr(&quot;Unable to create %s: %s&quot;, path,
1970         (error() != NULL) ? error() : &quot;reason unknown&quot;);
1971     }
1972     return -1;
1973   }
1974 
1975   // generate the dump
1976   VM_HeapDumper dumper(&amp;writer, _gc_before_heap_dump, _oome);
1977   if (Thread::current()-&gt;is_VM_thread()) {
1978     assert(SafepointSynchronize::is_at_safepoint(), &quot;Expected to be called at a safepoint&quot;);
1979     dumper.doit();
1980   } else {
1981     VMThread::execute(&amp;dumper);
1982   }
1983 
<span class="line-modified">1984   // record any error that the writer may have encountered</span>

1985   set_error(writer.error());
1986 
1987   // emit JFR event
1988   if (error() == NULL) {
1989     event.set_destination(path);
1990     event.set_gcBeforeDump(_gc_before_heap_dump);
1991     event.set_size(writer.bytes_written());
1992     event.set_onOutOfMemoryError(_oome);
1993     event.commit();
1994   }
1995 
1996   // print message in interactive case
1997   if (out != NULL) {
1998     timer()-&gt;stop();
1999     if (error() == NULL) {
2000       out-&gt;print_cr(&quot;Heap dump file created [&quot; JULONG_FORMAT &quot; bytes in %3.3f secs]&quot;,
2001                     writer.bytes_written(), timer()-&gt;seconds());
2002     } else {
2003       out-&gt;print_cr(&quot;Dump file is incomplete: %s&quot;, writer.error());
2004     }
</pre>
<hr />
<pre>
2011 HeapDumper::~HeapDumper() {
2012   if (timer()-&gt;is_active()) {
2013     timer()-&gt;stop();
2014   }
2015   set_error(NULL);
2016 }
2017 
2018 
2019 // returns the error string (resource allocated), or NULL
2020 char* HeapDumper::error_as_C_string() const {
2021   if (error() != NULL) {
2022     char* str = NEW_RESOURCE_ARRAY(char, strlen(error())+1);
2023     strcpy(str, error());
2024     return str;
2025   } else {
2026     return NULL;
2027   }
2028 }
2029 
2030 // set the error string
<span class="line-modified">2031 void HeapDumper::set_error(char const* error) {</span>
2032   if (_error != NULL) {
2033     os::free(_error);
2034   }
2035   if (error == NULL) {
2036     _error = NULL;
2037   } else {
2038     _error = os::strdup(error);
2039     assert(_error != NULL, &quot;allocation failure&quot;);
2040   }
2041 }
2042 
2043 // Called by out-of-memory error reporting by a single Java thread
2044 // outside of a JVM safepoint
2045 void HeapDumper::dump_heap_from_oome() {
2046   HeapDumper::dump_heap(true);
2047 }
2048 
2049 // Called by error reporting by a single Java thread outside of a JVM safepoint,
2050 // or by heap dumping by the VM thread during a (GC) safepoint. Thus, these various
2051 // callers are strictly serialized and guaranteed not to interfere below. For more
</pre>
</td>
</tr>
</table>
<center><a href="diagnosticCommand.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../../../java.base/share/classes/java/lang/invoke/InnerClassLambdaMetafactory.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
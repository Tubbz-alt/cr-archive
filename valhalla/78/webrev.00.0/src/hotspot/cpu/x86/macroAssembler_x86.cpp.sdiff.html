<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/macroAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../aarch64/aarch64.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/macroAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
7161 
7162 /**
7163  * Emits code to update CRC-32 with a byte value according to constants in table
7164  *
7165  * @param [in,out]crc   Register containing the crc.
7166  * @param [in]val       Register containing the byte to fold into the CRC.
7167  * @param [in]table     Register containing the table of crc constants.
7168  *
7169  * uint32_t crc;
7170  * val = crc_table[(val ^ crc) &amp; 0xFF];
7171  * crc = val ^ (crc &gt;&gt; 8);
7172  *
7173  */
7174 void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {
7175   xorl(val, crc);
7176   andl(val, 0xFF);
7177   shrl(crc, 8); // unsigned shift
7178   xorl(crc, Address(table, val, Address::times_4, 0));
7179 }
7180 
<span class="line-removed">7181 /**</span>
<span class="line-removed">7182 * Fold four 128-bit data chunks</span>
<span class="line-removed">7183 */</span>
<span class="line-removed">7184 void MacroAssembler::fold_128bit_crc32_avx512(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset) {</span>
<span class="line-removed">7185   evpclmulhdq(xtmp, xK, xcrc, Assembler::AVX_512bit); // [123:64]</span>
<span class="line-removed">7186   evpclmulldq(xcrc, xK, xcrc, Assembler::AVX_512bit); // [63:0]</span>
<span class="line-removed">7187   evpxorq(xcrc, xcrc, Address(buf, offset), Assembler::AVX_512bit /* vector_len */);</span>
<span class="line-removed">7188   evpxorq(xcrc, xcrc, xtmp, Assembler::AVX_512bit /* vector_len */);</span>
<span class="line-removed">7189 }</span>
<span class="line-removed">7190 </span>
7191 /**
7192  * Fold 128-bit data chunk
7193  */
7194 void MacroAssembler::fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset) {
7195   if (UseAVX &gt; 0) {
7196     vpclmulhdq(xtmp, xK, xcrc); // [123:64]
7197     vpclmulldq(xcrc, xK, xcrc); // [63:0]
7198     vpxor(xcrc, xcrc, Address(buf, offset), 0 /* vector_len */);
7199     pxor(xcrc, xtmp);
7200   } else {
7201     movdqa(xtmp, xcrc);
7202     pclmulhdq(xtmp, xK);   // [123:64]
7203     pclmulldq(xcrc, xK);   // [63:0]
7204     pxor(xcrc, xtmp);
7205     movdqu(xtmp, Address(buf, offset));
7206     pxor(xcrc, xtmp);
7207   }
7208 }
7209 
7210 void MacroAssembler::fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, XMMRegister xbuf) {
</pre>
<hr />
<pre>
7374   BIND(L_tail_restore);
7375   movl(len, tmp); // restore
7376   BIND(L_tail);
7377   andl(len, 0xf);
7378   jccb(Assembler::zero, L_exit);
7379 
7380   // Fold the rest of bytes
7381   align(4);
7382   BIND(L_tail_loop);
7383   movsbl(rax, Address(buf, 0)); // load byte with sign extension
7384   update_byte_crc32(crc, rax, table);
7385   increment(buf);
7386   decrementl(len);
7387   jccb(Assembler::greater, L_tail_loop);
7388 
7389   BIND(L_exit);
7390   notl(crc); // ~c
7391 }
7392 
7393 #ifdef _LP64














































































































































































































































































































































































7394 // S. Gueron / Information Processing Letters 112 (2012) 184
7395 // Algorithm 4: Computing carry-less multiplication using a precomputed lookup table.
7396 // Input: A 32 bit value B = [byte3, byte2, byte1, byte0].
7397 // Output: the 64-bit carry-less product of B * CONST
7398 void MacroAssembler::crc32c_ipl_alg4(Register in, uint32_t n,
7399                                      Register tmp1, Register tmp2, Register tmp3) {
7400   lea(tmp3, ExternalAddress(StubRoutines::crc32c_table_addr()));
7401   if (n &gt; 0) {
7402     addq(tmp3, n * 256 * 8);
7403   }
7404   //    Q1 = TABLEExt[n][B &amp; 0xFF];
7405   movl(tmp1, in);
7406   andl(tmp1, 0x000000FF);
7407   shll(tmp1, 3);
7408   addq(tmp1, tmp3);
7409   movq(tmp1, Address(tmp1, 0));
7410 
7411   //    Q2 = TABLEExt[n][B &gt;&gt; 8 &amp; 0xFF];
7412   movl(tmp2, in);
7413   shrl(tmp2, 8);
</pre>
</td>
<td>
<hr />
<pre>
7161 
7162 /**
7163  * Emits code to update CRC-32 with a byte value according to constants in table
7164  *
7165  * @param [in,out]crc   Register containing the crc.
7166  * @param [in]val       Register containing the byte to fold into the CRC.
7167  * @param [in]table     Register containing the table of crc constants.
7168  *
7169  * uint32_t crc;
7170  * val = crc_table[(val ^ crc) &amp; 0xFF];
7171  * crc = val ^ (crc &gt;&gt; 8);
7172  *
7173  */
7174 void MacroAssembler::update_byte_crc32(Register crc, Register val, Register table) {
7175   xorl(val, crc);
7176   andl(val, 0xFF);
7177   shrl(crc, 8); // unsigned shift
7178   xorl(crc, Address(table, val, Address::times_4, 0));
7179 }
7180 










7181 /**
7182  * Fold 128-bit data chunk
7183  */
7184 void MacroAssembler::fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf, int offset) {
7185   if (UseAVX &gt; 0) {
7186     vpclmulhdq(xtmp, xK, xcrc); // [123:64]
7187     vpclmulldq(xcrc, xK, xcrc); // [63:0]
7188     vpxor(xcrc, xcrc, Address(buf, offset), 0 /* vector_len */);
7189     pxor(xcrc, xtmp);
7190   } else {
7191     movdqa(xtmp, xcrc);
7192     pclmulhdq(xtmp, xK);   // [123:64]
7193     pclmulldq(xcrc, xK);   // [63:0]
7194     pxor(xcrc, xtmp);
7195     movdqu(xtmp, Address(buf, offset));
7196     pxor(xcrc, xtmp);
7197   }
7198 }
7199 
7200 void MacroAssembler::fold_128bit_crc32(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, XMMRegister xbuf) {
</pre>
<hr />
<pre>
7364   BIND(L_tail_restore);
7365   movl(len, tmp); // restore
7366   BIND(L_tail);
7367   andl(len, 0xf);
7368   jccb(Assembler::zero, L_exit);
7369 
7370   // Fold the rest of bytes
7371   align(4);
7372   BIND(L_tail_loop);
7373   movsbl(rax, Address(buf, 0)); // load byte with sign extension
7374   update_byte_crc32(crc, rax, table);
7375   increment(buf);
7376   decrementl(len);
7377   jccb(Assembler::greater, L_tail_loop);
7378 
7379   BIND(L_exit);
7380   notl(crc); // ~c
7381 }
7382 
7383 #ifdef _LP64
<span class="line-added">7384 // Helper function for AVX 512 CRC32</span>
<span class="line-added">7385 // Fold 512-bit data chunks</span>
<span class="line-added">7386 void MacroAssembler::fold512bit_crc32_avx512(XMMRegister xcrc, XMMRegister xK, XMMRegister xtmp, Register buf,</span>
<span class="line-added">7387                                              Register pos, int offset) {</span>
<span class="line-added">7388   evmovdquq(xmm3, Address(buf, pos, Address::times_1, offset), Assembler::AVX_512bit);</span>
<span class="line-added">7389   evpclmulqdq(xtmp, xcrc, xK, 0x10, Assembler::AVX_512bit); // [123:64]</span>
<span class="line-added">7390   evpclmulqdq(xmm2, xcrc, xK, 0x01, Assembler::AVX_512bit); // [63:0]</span>
<span class="line-added">7391   evpxorq(xcrc, xtmp, xmm2, Assembler::AVX_512bit /* vector_len */);</span>
<span class="line-added">7392   evpxorq(xcrc, xcrc, xmm3, Assembler::AVX_512bit /* vector_len */);</span>
<span class="line-added">7393 }</span>
<span class="line-added">7394 </span>
<span class="line-added">7395 // Helper function for AVX 512 CRC32</span>
<span class="line-added">7396 // Compute CRC32 for &lt; 256B buffers</span>
<span class="line-added">7397 void MacroAssembler::kernel_crc32_avx512_256B(Register crc, Register buf, Register len, Register key, Register pos,</span>
<span class="line-added">7398                                               Register tmp1, Register tmp2, Label&amp; L_barrett, Label&amp; L_16B_reduction_loop,</span>
<span class="line-added">7399                                               Label&amp; L_get_last_two_xmms, Label&amp; L_128_done, Label&amp; L_cleanup) {</span>
<span class="line-added">7400 </span>
<span class="line-added">7401   Label L_less_than_32, L_exact_16_left, L_less_than_16_left;</span>
<span class="line-added">7402   Label L_less_than_8_left, L_less_than_4_left, L_less_than_2_left, L_zero_left;</span>
<span class="line-added">7403   Label L_only_less_than_4, L_only_less_than_3, L_only_less_than_2;</span>
<span class="line-added">7404 </span>
<span class="line-added">7405   // check if there is enough buffer to be able to fold 16B at a time</span>
<span class="line-added">7406   cmpl(len, 32);</span>
<span class="line-added">7407   jcc(Assembler::less, L_less_than_32);</span>
<span class="line-added">7408 </span>
<span class="line-added">7409   // if there is, load the constants</span>
<span class="line-added">7410   movdqu(xmm10, Address(key, 1 * 16));    //rk1 and rk2 in xmm10</span>
<span class="line-added">7411   movdl(xmm0, crc);                        // get the initial crc value</span>
<span class="line-added">7412   movdqu(xmm7, Address(buf, pos, Address::times_1, 0 * 16)); //load the plaintext</span>
<span class="line-added">7413   pxor(xmm7, xmm0);</span>
<span class="line-added">7414 </span>
<span class="line-added">7415   // update the buffer pointer</span>
<span class="line-added">7416   addl(pos, 16);</span>
<span class="line-added">7417   //update the counter.subtract 32 instead of 16 to save one instruction from the loop</span>
<span class="line-added">7418   subl(len, 32);</span>
<span class="line-added">7419   jmp(L_16B_reduction_loop);</span>
<span class="line-added">7420 </span>
<span class="line-added">7421   bind(L_less_than_32);</span>
<span class="line-added">7422   //mov initial crc to the return value. this is necessary for zero - length buffers.</span>
<span class="line-added">7423   movl(rax, crc);</span>
<span class="line-added">7424   testl(len, len);</span>
<span class="line-added">7425   jcc(Assembler::equal, L_cleanup);</span>
<span class="line-added">7426 </span>
<span class="line-added">7427   movdl(xmm0, crc);                        //get the initial crc value</span>
<span class="line-added">7428 </span>
<span class="line-added">7429   cmpl(len, 16);</span>
<span class="line-added">7430   jcc(Assembler::equal, L_exact_16_left);</span>
<span class="line-added">7431   jcc(Assembler::less, L_less_than_16_left);</span>
<span class="line-added">7432 </span>
<span class="line-added">7433   movdqu(xmm7, Address(buf, pos, Address::times_1, 0 * 16)); //load the plaintext</span>
<span class="line-added">7434   pxor(xmm7, xmm0);                       //xor the initial crc value</span>
<span class="line-added">7435   addl(pos, 16);</span>
<span class="line-added">7436   subl(len, 16);</span>
<span class="line-added">7437   movdqu(xmm10, Address(key, 1 * 16));    // rk1 and rk2 in xmm10</span>
<span class="line-added">7438   jmp(L_get_last_two_xmms);</span>
<span class="line-added">7439 </span>
<span class="line-added">7440   bind(L_less_than_16_left);</span>
<span class="line-added">7441   //use stack space to load data less than 16 bytes, zero - out the 16B in memory first.</span>
<span class="line-added">7442   pxor(xmm1, xmm1);</span>
<span class="line-added">7443   movptr(tmp1, rsp);</span>
<span class="line-added">7444   movdqu(Address(tmp1, 0 * 16), xmm1);</span>
<span class="line-added">7445 </span>
<span class="line-added">7446   cmpl(len, 4);</span>
<span class="line-added">7447   jcc(Assembler::less, L_only_less_than_4);</span>
<span class="line-added">7448 </span>
<span class="line-added">7449   //backup the counter value</span>
<span class="line-added">7450   movl(tmp2, len);</span>
<span class="line-added">7451   cmpl(len, 8);</span>
<span class="line-added">7452   jcc(Assembler::less, L_less_than_8_left);</span>
<span class="line-added">7453 </span>
<span class="line-added">7454   //load 8 Bytes</span>
<span class="line-added">7455   movq(rax, Address(buf, pos, Address::times_1, 0 * 16));</span>
<span class="line-added">7456   movq(Address(tmp1, 0 * 16), rax);</span>
<span class="line-added">7457   addptr(tmp1, 8);</span>
<span class="line-added">7458   subl(len, 8);</span>
<span class="line-added">7459   addl(pos, 8);</span>
<span class="line-added">7460 </span>
<span class="line-added">7461   bind(L_less_than_8_left);</span>
<span class="line-added">7462   cmpl(len, 4);</span>
<span class="line-added">7463   jcc(Assembler::less, L_less_than_4_left);</span>
<span class="line-added">7464 </span>
<span class="line-added">7465   //load 4 Bytes</span>
<span class="line-added">7466   movl(rax, Address(buf, pos, Address::times_1, 0));</span>
<span class="line-added">7467   movl(Address(tmp1, 0 * 16), rax);</span>
<span class="line-added">7468   addptr(tmp1, 4);</span>
<span class="line-added">7469   subl(len, 4);</span>
<span class="line-added">7470   addl(pos, 4);</span>
<span class="line-added">7471 </span>
<span class="line-added">7472   bind(L_less_than_4_left);</span>
<span class="line-added">7473   cmpl(len, 2);</span>
<span class="line-added">7474   jcc(Assembler::less, L_less_than_2_left);</span>
<span class="line-added">7475 </span>
<span class="line-added">7476   // load 2 Bytes</span>
<span class="line-added">7477   movw(rax, Address(buf, pos, Address::times_1, 0));</span>
<span class="line-added">7478   movl(Address(tmp1, 0 * 16), rax);</span>
<span class="line-added">7479   addptr(tmp1, 2);</span>
<span class="line-added">7480   subl(len, 2);</span>
<span class="line-added">7481   addl(pos, 2);</span>
<span class="line-added">7482 </span>
<span class="line-added">7483   bind(L_less_than_2_left);</span>
<span class="line-added">7484   cmpl(len, 1);</span>
<span class="line-added">7485   jcc(Assembler::less, L_zero_left);</span>
<span class="line-added">7486 </span>
<span class="line-added">7487   // load 1 Byte</span>
<span class="line-added">7488   movb(rax, Address(buf, pos, Address::times_1, 0));</span>
<span class="line-added">7489   movb(Address(tmp1, 0 * 16), rax);</span>
<span class="line-added">7490 </span>
<span class="line-added">7491   bind(L_zero_left);</span>
<span class="line-added">7492   movdqu(xmm7, Address(rsp, 0));</span>
<span class="line-added">7493   pxor(xmm7, xmm0);                       //xor the initial crc value</span>
<span class="line-added">7494 </span>
<span class="line-added">7495   lea(rax, ExternalAddress(StubRoutines::x86::shuf_table_crc32_avx512_addr()));</span>
<span class="line-added">7496   movdqu(xmm0, Address(rax, tmp2));</span>
<span class="line-added">7497   pshufb(xmm7, xmm0);</span>
<span class="line-added">7498   jmp(L_128_done);</span>
<span class="line-added">7499 </span>
<span class="line-added">7500   bind(L_exact_16_left);</span>
<span class="line-added">7501   movdqu(xmm7, Address(buf, pos, Address::times_1, 0));</span>
<span class="line-added">7502   pxor(xmm7, xmm0);                       //xor the initial crc value</span>
<span class="line-added">7503   jmp(L_128_done);</span>
<span class="line-added">7504 </span>
<span class="line-added">7505   bind(L_only_less_than_4);</span>
<span class="line-added">7506   cmpl(len, 3);</span>
<span class="line-added">7507   jcc(Assembler::less, L_only_less_than_3);</span>
<span class="line-added">7508 </span>
<span class="line-added">7509   // load 3 Bytes</span>
<span class="line-added">7510   movb(rax, Address(buf, pos, Address::times_1, 0));</span>
<span class="line-added">7511   movb(Address(tmp1, 0), rax);</span>
<span class="line-added">7512 </span>
<span class="line-added">7513   movb(rax, Address(buf, pos, Address::times_1, 1));</span>
<span class="line-added">7514   movb(Address(tmp1, 1), rax);</span>
<span class="line-added">7515 </span>
<span class="line-added">7516   movb(rax, Address(buf, pos, Address::times_1, 2));</span>
<span class="line-added">7517   movb(Address(tmp1, 2), rax);</span>
<span class="line-added">7518 </span>
<span class="line-added">7519   movdqu(xmm7, Address(rsp, 0));</span>
<span class="line-added">7520   pxor(xmm7, xmm0);                     //xor the initial crc value</span>
<span class="line-added">7521 </span>
<span class="line-added">7522   pslldq(xmm7, 0x5);</span>
<span class="line-added">7523   jmp(L_barrett);</span>
<span class="line-added">7524   bind(L_only_less_than_3);</span>
<span class="line-added">7525   cmpl(len, 2);</span>
<span class="line-added">7526   jcc(Assembler::less, L_only_less_than_2);</span>
<span class="line-added">7527 </span>
<span class="line-added">7528   // load 2 Bytes</span>
<span class="line-added">7529   movb(rax, Address(buf, pos, Address::times_1, 0));</span>
<span class="line-added">7530   movb(Address(tmp1, 0), rax);</span>
<span class="line-added">7531 </span>
<span class="line-added">7532   movb(rax, Address(buf, pos, Address::times_1, 1));</span>
<span class="line-added">7533   movb(Address(tmp1, 1), rax);</span>
<span class="line-added">7534 </span>
<span class="line-added">7535   movdqu(xmm7, Address(rsp, 0));</span>
<span class="line-added">7536   pxor(xmm7, xmm0);                     //xor the initial crc value</span>
<span class="line-added">7537 </span>
<span class="line-added">7538   pslldq(xmm7, 0x6);</span>
<span class="line-added">7539   jmp(L_barrett);</span>
<span class="line-added">7540 </span>
<span class="line-added">7541   bind(L_only_less_than_2);</span>
<span class="line-added">7542   //load 1 Byte</span>
<span class="line-added">7543   movb(rax, Address(buf, pos, Address::times_1, 0));</span>
<span class="line-added">7544   movb(Address(tmp1, 0), rax);</span>
<span class="line-added">7545 </span>
<span class="line-added">7546   movdqu(xmm7, Address(rsp, 0));</span>
<span class="line-added">7547   pxor(xmm7, xmm0);                     //xor the initial crc value</span>
<span class="line-added">7548 </span>
<span class="line-added">7549   pslldq(xmm7, 0x7);</span>
<span class="line-added">7550 }</span>
<span class="line-added">7551 </span>
<span class="line-added">7552 /**</span>
<span class="line-added">7553 * Compute CRC32 using AVX512 instructions</span>
<span class="line-added">7554 * param crc   register containing existing CRC (32-bit)</span>
<span class="line-added">7555 * param buf   register pointing to input byte buffer (byte*)</span>
<span class="line-added">7556 * param len   register containing number of bytes</span>
<span class="line-added">7557 * param tmp1  scratch register</span>
<span class="line-added">7558 * param tmp2  scratch register</span>
<span class="line-added">7559 * return rax  result register</span>
<span class="line-added">7560 */</span>
<span class="line-added">7561 void MacroAssembler::kernel_crc32_avx512(Register crc, Register buf, Register len, Register key, Register tmp1, Register tmp2) {</span>
<span class="line-added">7562   assert_different_registers(crc, buf, len, key, tmp1, tmp2, rax);</span>
<span class="line-added">7563 </span>
<span class="line-added">7564   Label L_tail, L_tail_restore, L_tail_loop, L_exit, L_align_loop, L_aligned;</span>
<span class="line-added">7565   Label L_fold_tail, L_fold_128b, L_fold_512b, L_fold_512b_loop, L_fold_tail_loop;</span>
<span class="line-added">7566   Label L_less_than_256, L_fold_128_B_loop, L_fold_256_B_loop;</span>
<span class="line-added">7567   Label L_fold_128_B_register, L_final_reduction_for_128, L_16B_reduction_loop;</span>
<span class="line-added">7568   Label L_128_done, L_get_last_two_xmms, L_barrett, L_cleanup;</span>
<span class="line-added">7569 </span>
<span class="line-added">7570   const Register pos = r12;</span>
<span class="line-added">7571   push(r12);</span>
<span class="line-added">7572   subptr(rsp, 16 * 2 + 8);</span>
<span class="line-added">7573 </span>
<span class="line-added">7574   // For EVEX with VL and BW, provide a standard mask, VL = 128 will guide the merge</span>
<span class="line-added">7575   // context for the registers used, where all instructions below are using 128-bit mode</span>
<span class="line-added">7576   // On EVEX without VL and BW, these instructions will all be AVX.</span>
<span class="line-added">7577   lea(key, ExternalAddress(StubRoutines::x86::crc_table_avx512_addr()));</span>
<span class="line-added">7578   notl(crc);</span>
<span class="line-added">7579   movl(pos, 0);</span>
<span class="line-added">7580 </span>
<span class="line-added">7581   // check if smaller than 256B</span>
<span class="line-added">7582   cmpl(len, 256);</span>
<span class="line-added">7583   jcc(Assembler::less, L_less_than_256);</span>
<span class="line-added">7584 </span>
<span class="line-added">7585   // load the initial crc value</span>
<span class="line-added">7586   movdl(xmm10, crc);</span>
<span class="line-added">7587 </span>
<span class="line-added">7588   // receive the initial 64B data, xor the initial crc value</span>
<span class="line-added">7589   evmovdquq(xmm0, Address(buf, pos, Address::times_1, 0 * 64), Assembler::AVX_512bit);</span>
<span class="line-added">7590   evmovdquq(xmm4, Address(buf, pos, Address::times_1, 1 * 64), Assembler::AVX_512bit);</span>
<span class="line-added">7591   evpxorq(xmm0, xmm0, xmm10, Assembler::AVX_512bit);</span>
<span class="line-added">7592   evbroadcasti32x4(xmm10, Address(key, 2 * 16), Assembler::AVX_512bit); //zmm10 has rk3 and rk4</span>
<span class="line-added">7593 </span>
<span class="line-added">7594   subl(len, 256);</span>
<span class="line-added">7595   cmpl(len, 256);</span>
<span class="line-added">7596   jcc(Assembler::less, L_fold_128_B_loop);</span>
<span class="line-added">7597 </span>
<span class="line-added">7598   evmovdquq(xmm7, Address(buf, pos, Address::times_1, 2 * 64), Assembler::AVX_512bit);</span>
<span class="line-added">7599   evmovdquq(xmm8, Address(buf, pos, Address::times_1, 3 * 64), Assembler::AVX_512bit);</span>
<span class="line-added">7600   evbroadcasti32x4(xmm16, Address(key, 0 * 16), Assembler::AVX_512bit); //zmm16 has rk-1 and rk-2</span>
<span class="line-added">7601   subl(len, 256);</span>
<span class="line-added">7602 </span>
<span class="line-added">7603   bind(L_fold_256_B_loop);</span>
<span class="line-added">7604   addl(pos, 256);</span>
<span class="line-added">7605   fold512bit_crc32_avx512(xmm0, xmm16, xmm1, buf, pos, 0 * 64);</span>
<span class="line-added">7606   fold512bit_crc32_avx512(xmm4, xmm16, xmm1, buf, pos, 1 * 64);</span>
<span class="line-added">7607   fold512bit_crc32_avx512(xmm7, xmm16, xmm1, buf, pos, 2 * 64);</span>
<span class="line-added">7608   fold512bit_crc32_avx512(xmm8, xmm16, xmm1, buf, pos, 3 * 64);</span>
<span class="line-added">7609 </span>
<span class="line-added">7610   subl(len, 256);</span>
<span class="line-added">7611   jcc(Assembler::greaterEqual, L_fold_256_B_loop);</span>
<span class="line-added">7612 </span>
<span class="line-added">7613   // Fold 256 into 128</span>
<span class="line-added">7614   addl(pos, 256);</span>
<span class="line-added">7615   evpclmulqdq(xmm1, xmm0, xmm10, 0x01, Assembler::AVX_512bit);</span>
<span class="line-added">7616   evpclmulqdq(xmm2, xmm0, xmm10, 0x10, Assembler::AVX_512bit);</span>
<span class="line-added">7617   vpternlogq(xmm7, 0x96, xmm1, xmm2, Assembler::AVX_512bit); // xor ABC</span>
<span class="line-added">7618 </span>
<span class="line-added">7619   evpclmulqdq(xmm5, xmm4, xmm10, 0x01, Assembler::AVX_512bit);</span>
<span class="line-added">7620   evpclmulqdq(xmm6, xmm4, xmm10, 0x10, Assembler::AVX_512bit);</span>
<span class="line-added">7621   vpternlogq(xmm8, 0x96, xmm5, xmm6, Assembler::AVX_512bit); // xor ABC</span>
<span class="line-added">7622 </span>
<span class="line-added">7623   evmovdquq(xmm0, xmm7, Assembler::AVX_512bit);</span>
<span class="line-added">7624   evmovdquq(xmm4, xmm8, Assembler::AVX_512bit);</span>
<span class="line-added">7625 </span>
<span class="line-added">7626   addl(len, 128);</span>
<span class="line-added">7627   jmp(L_fold_128_B_register);</span>
<span class="line-added">7628 </span>
<span class="line-added">7629   // at this section of the code, there is 128 * x + y(0 &lt;= y&lt;128) bytes of buffer.The fold_128_B_loop</span>
<span class="line-added">7630   // loop will fold 128B at a time until we have 128 + y Bytes of buffer</span>
<span class="line-added">7631 </span>
<span class="line-added">7632   // fold 128B at a time.This section of the code folds 8 xmm registers in parallel</span>
<span class="line-added">7633   bind(L_fold_128_B_loop);</span>
<span class="line-added">7634   addl(pos, 128);</span>
<span class="line-added">7635   fold512bit_crc32_avx512(xmm0, xmm10, xmm1, buf, pos, 0 * 64);</span>
<span class="line-added">7636   fold512bit_crc32_avx512(xmm4, xmm10, xmm1, buf, pos, 1 * 64);</span>
<span class="line-added">7637 </span>
<span class="line-added">7638   subl(len, 128);</span>
<span class="line-added">7639   jcc(Assembler::greaterEqual, L_fold_128_B_loop);</span>
<span class="line-added">7640 </span>
<span class="line-added">7641   addl(pos, 128);</span>
<span class="line-added">7642 </span>
<span class="line-added">7643   // at this point, the buffer pointer is pointing at the last y Bytes of the buffer, where 0 &lt;= y &lt; 128</span>
<span class="line-added">7644   // the 128B of folded data is in 8 of the xmm registers : xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7</span>
<span class="line-added">7645   bind(L_fold_128_B_register);</span>
<span class="line-added">7646   evmovdquq(xmm16, Address(key, 5 * 16), Assembler::AVX_512bit); // multiply by rk9-rk16</span>
<span class="line-added">7647   evmovdquq(xmm11, Address(key, 9 * 16), Assembler::AVX_512bit); // multiply by rk17-rk20, rk1,rk2, 0,0</span>
<span class="line-added">7648   evpclmulqdq(xmm1, xmm0, xmm16, 0x01, Assembler::AVX_512bit);</span>
<span class="line-added">7649   evpclmulqdq(xmm2, xmm0, xmm16, 0x10, Assembler::AVX_512bit);</span>
<span class="line-added">7650   // save last that has no multiplicand</span>
<span class="line-added">7651   vextracti64x2(xmm7, xmm4, 3);</span>
<span class="line-added">7652 </span>
<span class="line-added">7653   evpclmulqdq(xmm5, xmm4, xmm11, 0x01, Assembler::AVX_512bit);</span>
<span class="line-added">7654   evpclmulqdq(xmm6, xmm4, xmm11, 0x10, Assembler::AVX_512bit);</span>
<span class="line-added">7655   // Needed later in reduction loop</span>
<span class="line-added">7656   movdqu(xmm10, Address(key, 1 * 16));</span>
<span class="line-added">7657   vpternlogq(xmm1, 0x96, xmm2, xmm5, Assembler::AVX_512bit); // xor ABC</span>
<span class="line-added">7658   vpternlogq(xmm1, 0x96, xmm6, xmm7, Assembler::AVX_512bit); // xor ABC</span>
<span class="line-added">7659 </span>
<span class="line-added">7660   // Swap 1,0,3,2 - 01 00 11 10</span>
<span class="line-added">7661   evshufi64x2(xmm8, xmm1, xmm1, 0x4e, Assembler::AVX_512bit);</span>
<span class="line-added">7662   evpxorq(xmm8, xmm8, xmm1, Assembler::AVX_256bit);</span>
<span class="line-added">7663   vextracti128(xmm5, xmm8, 1);</span>
<span class="line-added">7664   evpxorq(xmm7, xmm5, xmm8, Assembler::AVX_128bit);</span>
<span class="line-added">7665 </span>
<span class="line-added">7666   // instead of 128, we add 128 - 16 to the loop counter to save 1 instruction from the loop</span>
<span class="line-added">7667   // instead of a cmp instruction, we use the negative flag with the jl instruction</span>
<span class="line-added">7668   addl(len, 128 - 16);</span>
<span class="line-added">7669   jcc(Assembler::less, L_final_reduction_for_128);</span>
<span class="line-added">7670 </span>
<span class="line-added">7671   bind(L_16B_reduction_loop);</span>
<span class="line-added">7672   vpclmulqdq(xmm8, xmm7, xmm10, 0x1);</span>
<span class="line-added">7673   vpclmulqdq(xmm7, xmm7, xmm10, 0x10);</span>
<span class="line-added">7674   vpxor(xmm7, xmm7, xmm8, Assembler::AVX_128bit);</span>
<span class="line-added">7675   movdqu(xmm0, Address(buf, pos, Address::times_1, 0 * 16));</span>
<span class="line-added">7676   vpxor(xmm7, xmm7, xmm0, Assembler::AVX_128bit);</span>
<span class="line-added">7677   addl(pos, 16);</span>
<span class="line-added">7678   subl(len, 16);</span>
<span class="line-added">7679   jcc(Assembler::greaterEqual, L_16B_reduction_loop);</span>
<span class="line-added">7680 </span>
<span class="line-added">7681   bind(L_final_reduction_for_128);</span>
<span class="line-added">7682   addl(len, 16);</span>
<span class="line-added">7683   jcc(Assembler::equal, L_128_done);</span>
<span class="line-added">7684 </span>
<span class="line-added">7685   bind(L_get_last_two_xmms);</span>
<span class="line-added">7686   movdqu(xmm2, xmm7);</span>
<span class="line-added">7687   addl(pos, len);</span>
<span class="line-added">7688   movdqu(xmm1, Address(buf, pos, Address::times_1, -16));</span>
<span class="line-added">7689   subl(pos, len);</span>
<span class="line-added">7690 </span>
<span class="line-added">7691   // get rid of the extra data that was loaded before</span>
<span class="line-added">7692   // load the shift constant</span>
<span class="line-added">7693   lea(rax, ExternalAddress(StubRoutines::x86::shuf_table_crc32_avx512_addr()));</span>
<span class="line-added">7694   movdqu(xmm0, Address(rax, len));</span>
<span class="line-added">7695   addl(rax, len);</span>
<span class="line-added">7696 </span>
<span class="line-added">7697   vpshufb(xmm7, xmm7, xmm0, Assembler::AVX_128bit);</span>
<span class="line-added">7698   //Change mask to 512</span>
<span class="line-added">7699   vpxor(xmm0, xmm0, ExternalAddress(StubRoutines::x86::crc_by128_masks_avx512_addr() + 2 * 16), Assembler::AVX_128bit, tmp2);</span>
<span class="line-added">7700   vpshufb(xmm2, xmm2, xmm0, Assembler::AVX_128bit);</span>
<span class="line-added">7701 </span>
<span class="line-added">7702   blendvpb(xmm2, xmm2, xmm1, xmm0, Assembler::AVX_128bit);</span>
<span class="line-added">7703   vpclmulqdq(xmm8, xmm7, xmm10, 0x1);</span>
<span class="line-added">7704   vpclmulqdq(xmm7, xmm7, xmm10, 0x10);</span>
<span class="line-added">7705   vpxor(xmm7, xmm7, xmm8, Assembler::AVX_128bit);</span>
<span class="line-added">7706   vpxor(xmm7, xmm7, xmm2, Assembler::AVX_128bit);</span>
<span class="line-added">7707 </span>
<span class="line-added">7708   bind(L_128_done);</span>
<span class="line-added">7709   // compute crc of a 128-bit value</span>
<span class="line-added">7710   movdqu(xmm10, Address(key, 3 * 16));</span>
<span class="line-added">7711   movdqu(xmm0, xmm7);</span>
<span class="line-added">7712 </span>
<span class="line-added">7713   // 64b fold</span>
<span class="line-added">7714   vpclmulqdq(xmm7, xmm7, xmm10, 0x0);</span>
<span class="line-added">7715   vpsrldq(xmm0, xmm0, 0x8, Assembler::AVX_128bit);</span>
<span class="line-added">7716   vpxor(xmm7, xmm7, xmm0, Assembler::AVX_128bit);</span>
<span class="line-added">7717 </span>
<span class="line-added">7718   // 32b fold</span>
<span class="line-added">7719   movdqu(xmm0, xmm7);</span>
<span class="line-added">7720   vpslldq(xmm7, xmm7, 0x4, Assembler::AVX_128bit);</span>
<span class="line-added">7721   vpclmulqdq(xmm7, xmm7, xmm10, 0x10);</span>
<span class="line-added">7722   vpxor(xmm7, xmm7, xmm0, Assembler::AVX_128bit);</span>
<span class="line-added">7723   jmp(L_barrett);</span>
<span class="line-added">7724 </span>
<span class="line-added">7725   bind(L_less_than_256);</span>
<span class="line-added">7726   kernel_crc32_avx512_256B(crc, buf, len, key, pos, tmp1, tmp2, L_barrett, L_16B_reduction_loop, L_get_last_two_xmms, L_128_done, L_cleanup);</span>
<span class="line-added">7727 </span>
<span class="line-added">7728   //barrett reduction</span>
<span class="line-added">7729   bind(L_barrett);</span>
<span class="line-added">7730   vpand(xmm7, xmm7, ExternalAddress(StubRoutines::x86::crc_by128_masks_avx512_addr() + 1 * 16), Assembler::AVX_128bit, tmp2);</span>
<span class="line-added">7731   movdqu(xmm1, xmm7);</span>
<span class="line-added">7732   movdqu(xmm2, xmm7);</span>
<span class="line-added">7733   movdqu(xmm10, Address(key, 4 * 16));</span>
<span class="line-added">7734 </span>
<span class="line-added">7735   pclmulqdq(xmm7, xmm10, 0x0);</span>
<span class="line-added">7736   pxor(xmm7, xmm2);</span>
<span class="line-added">7737   vpand(xmm7, xmm7, ExternalAddress(StubRoutines::x86::crc_by128_masks_avx512_addr()), Assembler::AVX_128bit, tmp2);</span>
<span class="line-added">7738   movdqu(xmm2, xmm7);</span>
<span class="line-added">7739   pclmulqdq(xmm7, xmm10, 0x10);</span>
<span class="line-added">7740   pxor(xmm7, xmm2);</span>
<span class="line-added">7741   pxor(xmm7, xmm1);</span>
<span class="line-added">7742   pextrd(crc, xmm7, 2);</span>
<span class="line-added">7743 </span>
<span class="line-added">7744   bind(L_cleanup);</span>
<span class="line-added">7745   notl(crc); // ~c</span>
<span class="line-added">7746   addptr(rsp, 16 * 2 + 8);</span>
<span class="line-added">7747   pop(r12);</span>
<span class="line-added">7748 }</span>
<span class="line-added">7749 </span>
7750 // S. Gueron / Information Processing Letters 112 (2012) 184
7751 // Algorithm 4: Computing carry-less multiplication using a precomputed lookup table.
7752 // Input: A 32 bit value B = [byte3, byte2, byte1, byte0].
7753 // Output: the 64-bit carry-less product of B * CONST
7754 void MacroAssembler::crc32c_ipl_alg4(Register in, uint32_t n,
7755                                      Register tmp1, Register tmp2, Register tmp3) {
7756   lea(tmp3, ExternalAddress(StubRoutines::crc32c_table_addr()));
7757   if (n &gt; 0) {
7758     addq(tmp3, n * 256 * 8);
7759   }
7760   //    Q1 = TABLEExt[n][B &amp; 0xFF];
7761   movl(tmp1, in);
7762   andl(tmp1, 0x000000FF);
7763   shll(tmp1, 3);
7764   addq(tmp1, tmp3);
7765   movq(tmp1, Address(tmp1, 0));
7766 
7767   //    Q2 = TABLEExt[n][B &gt;&gt; 8 &amp; 0xFF];
7768   movl(tmp2, in);
7769   shrl(tmp2, 8);
</pre>
</td>
</tr>
</table>
<center><a href="../aarch64/aarch64.ad.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
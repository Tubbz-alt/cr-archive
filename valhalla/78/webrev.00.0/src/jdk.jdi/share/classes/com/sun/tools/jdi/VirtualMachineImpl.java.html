<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jdi/share/classes/com/sun/tools/jdi/VirtualMachineImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.jdi;
  27 
  28 import java.lang.ref.Reference;
  29 import java.lang.ref.ReferenceQueue;
  30 import java.lang.ref.SoftReference;
  31 import java.text.MessageFormat;
  32 import java.util.ArrayList;
  33 import java.util.Arrays;
  34 import java.util.Collections;
  35 import java.util.HashMap;
  36 import java.util.HashSet;
  37 import java.util.Iterator;
  38 import java.util.List;
  39 import java.util.Map;
  40 import java.util.Set;
  41 import java.util.function.Consumer;
  42 
  43 import com.sun.jdi.BooleanType;
  44 import com.sun.jdi.BooleanValue;
  45 import com.sun.jdi.ByteType;
  46 import com.sun.jdi.ByteValue;
  47 import com.sun.jdi.CharType;
  48 import com.sun.jdi.CharValue;
  49 import com.sun.jdi.ClassLoaderReference;
  50 import com.sun.jdi.ClassNotLoadedException;
  51 import com.sun.jdi.DoubleType;
  52 import com.sun.jdi.DoubleValue;
  53 import com.sun.jdi.FloatType;
  54 import com.sun.jdi.FloatValue;
  55 import com.sun.jdi.IntegerType;
  56 import com.sun.jdi.IntegerValue;
  57 import com.sun.jdi.InternalException;
  58 import com.sun.jdi.LongType;
  59 import com.sun.jdi.LongValue;
  60 import com.sun.jdi.ModuleReference;
  61 import com.sun.jdi.ObjectCollectedException;
  62 import com.sun.jdi.PathSearchingVirtualMachine;
  63 import com.sun.jdi.PrimitiveType;
  64 import com.sun.jdi.ReferenceType;
  65 import com.sun.jdi.ShortType;
  66 import com.sun.jdi.ShortValue;
  67 import com.sun.jdi.StringReference;
  68 import com.sun.jdi.ThreadGroupReference;
  69 import com.sun.jdi.ThreadReference;
  70 import com.sun.jdi.Type;
  71 import com.sun.jdi.VMDisconnectedException;
  72 import com.sun.jdi.VirtualMachine;
  73 import com.sun.jdi.VirtualMachineManager;
  74 import com.sun.jdi.VoidType;
  75 import com.sun.jdi.VoidValue;
  76 import com.sun.jdi.connect.spi.Connection;
  77 import com.sun.jdi.event.EventQueue;
  78 import com.sun.jdi.request.BreakpointRequest;
  79 import com.sun.jdi.request.EventRequest;
  80 import com.sun.jdi.request.EventRequestManager;
  81 
  82 class VirtualMachineImpl extends MirrorImpl
  83              implements PathSearchingVirtualMachine, ThreadListener {
  84     // VM Level exported variables, these
  85     // are unique to a given vm
  86     public final int sizeofFieldRef;
  87     public final int sizeofMethodRef;
  88     public final int sizeofObjectRef;
  89     public final int sizeofClassRef;
  90     public final int sizeofFrameRef;
  91     public final int sizeofModuleRef;
  92 
  93     final int sequenceNumber;
  94 
  95     private final TargetVM target;
  96     private final EventQueueImpl eventQueue;
  97     private final EventRequestManagerImpl internalEventRequestManager;
  98     private final EventRequestManagerImpl eventRequestManager;
  99     final VirtualMachineManagerImpl vmManager;
 100     private final ThreadGroup threadGroupForJDI;
 101 
 102     // Allow direct access to this field so that that tracing code slows down
 103     // JDI as little as possible when not enabled.
 104     int traceFlags = TRACE_NONE;
 105 
 106     static int TRACE_RAW_SENDS     = 0x01000000;
 107     static int TRACE_RAW_RECEIVES  = 0x02000000;
 108 
 109     boolean traceReceives = false;   // pre-compute because of frequency
 110 
 111     // ReferenceType access - updated with class prepare and unload events
 112     // Protected by &quot;synchronized(this)&quot;. &quot;retrievedAllTypes&quot; may be
 113     // tested unsynchronized (since once true, it stays true), but must
 114     // be set synchronously
 115     private Map&lt;Long, ReferenceType&gt; typesByID;
 116     private Set&lt;ReferenceType&gt; typesBySignature;
 117     private boolean retrievedAllTypes = false;
 118 
 119     private Map&lt;Long, ModuleReference&gt; modulesByID;
 120 
 121     // For other languages support
 122     private String defaultStratum = null;
 123 
 124     // ObjectReference cache
 125     // &quot;objectsByID&quot; protected by &quot;synchronized(this)&quot;.
 126     private final Map&lt;Long, SoftObjectReference&gt; objectsByID = new HashMap&lt;&gt;();
 127     private final ReferenceQueue&lt;ObjectReferenceImpl&gt; referenceQueue = new ReferenceQueue&lt;&gt;();
 128     static private final int DISPOSE_THRESHOLD = 50;
 129     private final List&lt;SoftObjectReference&gt; batchedDisposeRequests =
 130             Collections.synchronizedList(new ArrayList&lt;&gt;(DISPOSE_THRESHOLD + 10));
 131 
 132     // These are cached once for the life of the VM
 133     private JDWP.VirtualMachine.Version versionInfo;
 134     private JDWP.VirtualMachine.ClassPaths pathInfo;
 135     private JDWP.VirtualMachine.Capabilities capabilities = null;
 136     private JDWP.VirtualMachine.CapabilitiesNew capabilitiesNew = null;
 137 
 138     // Per-vm singletons for primitive types and for void.
 139     // singleton-ness protected by &quot;synchronized(this)&quot;.
 140     private BooleanType theBooleanType;
 141     private ByteType    theByteType;
 142     private CharType    theCharType;
 143     private ShortType   theShortType;
 144     private IntegerType theIntegerType;
 145     private LongType    theLongType;
 146     private FloatType   theFloatType;
 147     private DoubleType  theDoubleType;
 148 
 149     private VoidType    theVoidType;
 150 
 151     private VoidValue voidVal;
 152 
 153     // Launched debuggee process
 154     private Process process;
 155 
 156     // coordinates state changes and corresponding listener notifications
 157     private VMState state = new VMState(this);
 158 
 159     private Object initMonitor = new Object();
 160     private boolean initComplete = false;
 161     private boolean shutdown = false;
 162 
 163     private void notifyInitCompletion() {
 164         synchronized(initMonitor) {
 165             initComplete = true;
 166             initMonitor.notifyAll();
 167         }
 168     }
 169 
 170     void waitInitCompletion() {
 171         synchronized(initMonitor) {
 172             while (!initComplete) {
 173                 try {
 174                     initMonitor.wait();
 175                 } catch (InterruptedException e) {
 176                     // ignore
 177                 }
 178             }
 179         }
 180     }
 181 
 182     VMState state() {
 183         return state;
 184     }
 185 
 186     /*
 187      * ThreadListener implementation
 188      */
 189     public boolean threadResumable(ThreadAction action) {
 190         /*
 191          * If any thread is resumed, the VM is considered not suspended.
 192          * Just one thread is being resumed so pass it to thaw.
 193          */
 194         state.thaw(action.thread());
 195         return true;
 196     }
 197 
 198     VirtualMachineImpl(VirtualMachineManager manager,
 199                        Connection connection, Process process,
 200                        int sequenceNumber) {
 201         super(null);  // Can&#39;t use super(this)
 202         vm = this;
 203 
 204         this.vmManager = (VirtualMachineManagerImpl)manager;
 205         this.process = process;
 206         this.sequenceNumber = sequenceNumber;
 207 
 208         /* Create ThreadGroup to be used by all threads servicing
 209          * this VM.
 210          */
 211         threadGroupForJDI = new ThreadGroup(vmManager.mainGroupForJDI(),
 212                                             &quot;JDI [&quot; +
 213                                             this.hashCode() + &quot;]&quot;);
 214 
 215         /*
 216          * Set up a thread to communicate with the target VM over
 217          * the specified transport.
 218          */
 219         target = new TargetVM(this, connection);
 220 
 221         /*
 222          * Set up a thread to handle events processed internally
 223          * the JDI implementation.
 224          */
 225         EventQueueImpl internalEventQueue = new EventQueueImpl(this, target);
 226         new InternalEventHandler(this, internalEventQueue);
 227         /*
 228          * Initialize client access to event setting and handling
 229          */
 230         eventQueue = new EventQueueImpl(this, target);
 231         eventRequestManager = new EventRequestManagerImpl(this);
 232 
 233         target.start();
 234 
 235         /*
 236          * Many ids are variably sized, depending on target VM.
 237          * Find out the sizes right away.
 238          */
 239         JDWP.VirtualMachine.IDSizes idSizes;
 240         try {
 241             idSizes = JDWP.VirtualMachine.IDSizes.process(vm);
 242         } catch (JDWPException exc) {
 243             throw exc.toJDIException();
 244         }
 245         sizeofFieldRef  = idSizes.fieldIDSize;
 246         sizeofMethodRef = idSizes.methodIDSize;
 247         sizeofObjectRef = idSizes.objectIDSize;
 248         sizeofClassRef = idSizes.referenceTypeIDSize;
 249         sizeofFrameRef  = idSizes.frameIDSize;
 250         sizeofModuleRef = idSizes.objectIDSize;
 251 
 252         /**
 253          * Set up requests needed by internal event handler.
 254          * Make sure they are distinguished by creating them with
 255          * an internal event request manager.
 256          *
 257          * Warning: create events only with SUSPEND_NONE policy.
 258          * In the current implementation other policies will not
 259          * be handled correctly when the event comes in. (notfiySuspend()
 260          * will not be properly called, and if the event is combined
 261          * with external events in the same set, suspend policy is not
 262          * correctly determined for the internal vs. external event sets)
 263          */
 264         internalEventRequestManager = new EventRequestManagerImpl(this);
 265         EventRequest er = internalEventRequestManager.createClassPrepareRequest();
 266         er.setSuspendPolicy(EventRequest.SUSPEND_NONE);
 267         er.enable();
 268         er = internalEventRequestManager.createClassUnloadRequest();
 269         er.setSuspendPolicy(EventRequest.SUSPEND_NONE);
 270         er.enable();
 271 
 272         /*
 273          * Tell other threads, notably TargetVM, that initialization
 274          * is complete.
 275          */
 276         notifyInitCompletion();
 277     }
 278 
 279     EventRequestManagerImpl getInternalEventRequestManager() {
 280         return internalEventRequestManager;
 281     }
 282 
 283     void validateVM() {
 284         /*
 285          * We no longer need to do this.  The spec now says
 286          * that a VMDisconnected _may_ be thrown in these
 287          * cases, not that it _will_ be thrown.
 288          * So, to simplify things we will just let the
 289          * caller&#39;s of this method proceed with their business.
 290          * If the debuggee is disconnected, either because it
 291          * crashed or finished or something, or because the
 292          * debugger called exit() or dispose(), then if
 293          * we end up trying to communicate with the debuggee,
 294          * code in TargetVM will throw a VMDisconnectedException.
 295          * This means that if we can satisfy a request without
 296          * talking to the debuggee, (eg, with cached data) then
 297          * VMDisconnectedException will _not_ be thrown.
 298          * if (shutdown) {
 299          *    throw new VMDisconnectedException();
 300          * }
 301          */
 302     }
 303 
 304     public boolean equals(Object obj) {
 305         return this == obj;
 306     }
 307 
 308     public int hashCode() {
 309         return System.identityHashCode(this);
 310     }
 311 
 312     public List&lt;ModuleReference&gt; allModules() {
 313         validateVM();
 314         List&lt;ModuleReference&gt; modules = retrieveAllModules();
 315         return Collections.unmodifiableList(modules);
 316     }
 317 
 318     private static boolean isReferenceArray(String signature) {
 319         int i = signature.lastIndexOf(&#39;[&#39;);
 320         if (i &gt; -1 &amp;&amp; signature.charAt(i+1) == &#39;L&#39;) {
 321             return true;
 322         }
 323         return false;
 324     }
 325 
 326     public List&lt;ReferenceType&gt; classesByName(String className) {
 327         validateVM();
 328         return classesBySignature(JNITypeParser.typeNameToSignature(className));
 329     }
 330 
 331     List&lt;ReferenceType&gt; classesBySignature(String signature) {
 332         validateVM();
 333         List&lt;ReferenceType&gt; list;
 334         if (retrievedAllTypes) {
 335             list = findReferenceTypes(signature);
 336         } else {
 337             list = retrieveClassesBySignature(signature);
 338         }
 339         // HACK: add second request to cover the case where className
 340         // is the name of an inline type. This is done only if the
 341         // first signature is either a reference type or an array
 342         // of a reference type.
 343         if (signature.length() &gt; 1 &amp;&amp;
 344                 (signature.charAt(0) == &#39;L&#39; || isReferenceArray((signature)))) {
 345             List&lt;ReferenceType&gt; listInlineTypes;
 346             signature = signature.replaceFirst(&quot;L&quot;, &quot;Q&quot;);
 347             if (retrievedAllTypes) {
 348                 listInlineTypes = findReferenceTypes(signature);
 349             } else {
 350                 listInlineTypes = retrieveClassesBySignature(signature);
 351             }
 352             if (!listInlineTypes.isEmpty()) {
 353                 list.addAll(listInlineTypes);
 354             }
 355         }
 356 
 357         return Collections.unmodifiableList(list);
 358     }
 359 
 360     public List&lt;ReferenceType&gt; allClasses() {
 361         validateVM();
 362 
 363         if (!retrievedAllTypes) {
 364             retrieveAllClasses();
 365         }
 366         ArrayList&lt;ReferenceType&gt; a;
 367         synchronized (this) {
 368             a = new ArrayList&lt;&gt;(typesBySignature);
 369         }
 370         return Collections.unmodifiableList(a);
 371     }
 372 
 373     /**
 374      * Performs an action for each loaded type.
 375      */
 376     public void forEachClass(Consumer&lt;ReferenceType&gt; action) {
 377         for (ReferenceType type : allClasses()) {
 378             try {
 379                 action.accept(type);
 380             } catch (ObjectCollectedException ex) {
 381                 // Some classes might be unloaded and garbage collected since
 382                 // we retrieved the copy of all loaded classes and started
 383                 // iterating over them. In this case calling methods on such types
 384                 // might result in com.sun.jdi.ObjectCollectedException
 385                 // being thrown. We ignore such classes and keep iterating.
 386                 if ((vm.traceFlags &amp; VirtualMachine.TRACE_OBJREFS) != 0) {
 387                     vm.printTrace(&quot;ObjectCollectedException was thrown while &quot; +
 388                             &quot;accessing unloaded class &quot; + type.name());
 389                 }
 390             }
 391         }
 392     }
 393 
 394     public void
 395         redefineClasses(Map&lt;? extends ReferenceType, byte[]&gt; classToBytes)
 396     {
 397         int cnt = classToBytes.size();
 398         JDWP.VirtualMachine.RedefineClasses.ClassDef[] defs =
 399             new JDWP.VirtualMachine.RedefineClasses.ClassDef[cnt];
 400         validateVM();
 401         if (!canRedefineClasses()) {
 402             throw new UnsupportedOperationException();
 403         }
 404         Iterator&lt;?&gt; it = classToBytes.entrySet().iterator();
 405         for (int i = 0; it.hasNext(); i++) {
 406             @SuppressWarnings(&quot;rawtypes&quot;)
 407             Map.Entry&lt;?, ?&gt; entry = (Map.Entry)it.next();
 408             ReferenceTypeImpl refType = (ReferenceTypeImpl)entry.getKey();
 409             validateMirror(refType);
 410             defs[i] = new JDWP.VirtualMachine.RedefineClasses
 411                        .ClassDef(refType, (byte[])entry.getValue());
 412         }
 413 
 414         // flush caches and disable caching until the next suspend
 415         vm.state().thaw();
 416 
 417         try {
 418             JDWP.VirtualMachine.RedefineClasses.
 419                 process(vm, defs);
 420         } catch (JDWPException exc) {
 421             switch (exc.errorCode()) {
 422             case JDWP.Error.INVALID_CLASS_FORMAT :
 423                 throw new ClassFormatError(
 424                     &quot;class not in class file format&quot;);
 425             case JDWP.Error.CIRCULAR_CLASS_DEFINITION :
 426                 throw new ClassCircularityError(
 427                     &quot;circularity has been detected while initializing a class&quot;);
 428             case JDWP.Error.FAILS_VERIFICATION :
 429                 throw new VerifyError(
 430                     &quot;verifier detected internal inconsistency or security problem&quot;);
 431             case JDWP.Error.UNSUPPORTED_VERSION :
 432                 throw new UnsupportedClassVersionError(
 433                     &quot;version numbers of class are not supported&quot;);
 434             case JDWP.Error.ADD_METHOD_NOT_IMPLEMENTED:
 435                 throw new UnsupportedOperationException(
 436                     &quot;add method not implemented&quot;);
 437             case JDWP.Error.SCHEMA_CHANGE_NOT_IMPLEMENTED :
 438                 throw new UnsupportedOperationException(
 439                     &quot;schema change not implemented&quot;);
 440             case JDWP.Error.HIERARCHY_CHANGE_NOT_IMPLEMENTED:
 441                 throw new UnsupportedOperationException(
 442                     &quot;hierarchy change not implemented&quot;);
 443             case JDWP.Error.DELETE_METHOD_NOT_IMPLEMENTED :
 444                 throw new UnsupportedOperationException(
 445                     &quot;delete method not implemented&quot;);
 446             case JDWP.Error.CLASS_MODIFIERS_CHANGE_NOT_IMPLEMENTED:
 447                 throw new UnsupportedOperationException(
 448                     &quot;changes to class modifiers not implemented&quot;);
 449             case JDWP.Error.METHOD_MODIFIERS_CHANGE_NOT_IMPLEMENTED :
 450                 throw new UnsupportedOperationException(
 451                     &quot;changes to method modifiers not implemented&quot;);
 452             case JDWP.Error.CLASS_ATTRIBUTE_CHANGE_NOT_IMPLEMENTED :
 453                 throw new UnsupportedOperationException(
 454                     &quot;changes to class attribute not implemented&quot;);
 455             case JDWP.Error.NAMES_DONT_MATCH :
 456                 throw new NoClassDefFoundError(
 457                     &quot;class names do not match&quot;);
 458             default:
 459                 throw exc.toJDIException();
 460             }
 461         }
 462 
 463         // Delete any record of the breakpoints
 464         List&lt;BreakpointRequest&gt; toDelete = new ArrayList&lt;&gt;();
 465         EventRequestManager erm = eventRequestManager();
 466         it = erm.breakpointRequests().iterator();
 467         while (it.hasNext()) {
 468             BreakpointRequest req = (BreakpointRequest)it.next();
 469             if (classToBytes.containsKey(req.location().declaringType())) {
 470                 toDelete.add(req);
 471             }
 472         }
 473         erm.deleteEventRequests(toDelete);
 474 
 475         // Invalidate any information cached for the classes just redefined.
 476         it = classToBytes.keySet().iterator();
 477         while (it.hasNext()) {
 478             ReferenceTypeImpl rti = (ReferenceTypeImpl)it.next();
 479             rti.noticeRedefineClass();
 480         }
 481     }
 482 
 483     public List&lt;ThreadReference&gt; allThreads() {
 484         validateVM();
 485         return state.allThreads();
 486     }
 487 
 488     public List&lt;ThreadGroupReference&gt; topLevelThreadGroups() {
 489         validateVM();
 490         return state.topLevelThreadGroups();
 491     }
 492 
 493     /*
 494      * Sends a command to the back end which is defined to do an
 495      * implicit vm-wide resume. The VM can no longer be considered
 496      * suspended, so certain cached data must be invalidated.
 497      */
 498     PacketStream sendResumingCommand(CommandSender sender) {
 499         return state.thawCommand(sender);
 500     }
 501 
 502     /*
 503      * The VM has been suspended. Additional caching can be done
 504      * as long as there are no pending resumes.
 505      */
 506     void notifySuspend() {
 507         state.freeze();
 508     }
 509 
 510     public void suspend() {
 511         validateVM();
 512         try {
 513             JDWP.VirtualMachine.Suspend.process(vm);
 514         } catch (JDWPException exc) {
 515             throw exc.toJDIException();
 516         }
 517         notifySuspend();
 518     }
 519 
 520     public void resume() {
 521         validateVM();
 522         CommandSender sender =
 523             new CommandSender() {
 524                 public PacketStream send() {
 525                     return JDWP.VirtualMachine.Resume.enqueueCommand(vm);
 526                 }
 527         };
 528         try {
 529             PacketStream stream = state.thawCommand(sender);
 530             JDWP.VirtualMachine.Resume.waitForReply(vm, stream);
 531         } catch (VMDisconnectedException exc) {
 532             /*
 533              * If the debugger makes a VMDeathRequest with SUSPEND_ALL,
 534              * then when it does an EventSet.resume after getting the
 535              * VMDeathEvent, the normal flow of events is that the
 536              * BE shuts down, but the waitForReply comes back ok.  In this
 537              * case, the run loop in TargetVM that is waiting for a packet
 538              * gets an EOF because the socket closes. It generates a
 539              * VMDisconnectedEvent and everyone is happy.
 540              * However, sometimes, the BE gets shutdown before this
 541              * waitForReply completes.  In this case, TargetVM.waitForReply
 542              * gets awakened with no reply and so gens a VMDisconnectedException
 543              * which is not what we want.  It might be possible to fix this
 544              * in the BE, but it is ok to just ignore the VMDisconnectedException
 545              * here.  This will allow the VMDisconnectedEvent to be generated
 546              * correctly.  And, if the debugger should happen to make another
 547              * request, it will get a VMDisconnectedException at that time.
 548              */
 549         } catch (JDWPException exc) {
 550             switch (exc.errorCode()) {
 551                 case JDWP.Error.VM_DEAD:
 552                     return;
 553                 default:
 554                     throw exc.toJDIException();
 555             }
 556         }
 557     }
 558 
 559     public EventQueue eventQueue() {
 560         /*
 561          * No VM validation here. We allow access to the event queue
 562          * after disconnection, so that there is access to the terminating
 563          * events.
 564          */
 565         return eventQueue;
 566     }
 567 
 568     public EventRequestManager eventRequestManager() {
 569         validateVM();
 570         return eventRequestManager;
 571     }
 572 
 573     EventRequestManagerImpl eventRequestManagerImpl() {
 574         return eventRequestManager;
 575     }
 576 
 577     public BooleanValue mirrorOf(boolean value) {
 578         validateVM();
 579         return new BooleanValueImpl(this,value);
 580     }
 581 
 582     public ByteValue mirrorOf(byte value) {
 583         validateVM();
 584         return new ByteValueImpl(this,value);
 585     }
 586 
 587     public CharValue mirrorOf(char value) {
 588         validateVM();
 589         return new CharValueImpl(this,value);
 590     }
 591 
 592     public ShortValue mirrorOf(short value) {
 593         validateVM();
 594         return new ShortValueImpl(this,value);
 595     }
 596 
 597     public IntegerValue mirrorOf(int value) {
 598         validateVM();
 599         return new IntegerValueImpl(this,value);
 600     }
 601 
 602     public LongValue mirrorOf(long value) {
 603         validateVM();
 604         return new LongValueImpl(this,value);
 605     }
 606 
 607     public FloatValue mirrorOf(float value) {
 608         validateVM();
 609         return new FloatValueImpl(this,value);
 610     }
 611 
 612     public DoubleValue mirrorOf(double value) {
 613         validateVM();
 614         return new DoubleValueImpl(this,value);
 615     }
 616 
 617     public StringReference mirrorOf(String value) {
 618         validateVM();
 619         try {
 620             return JDWP.VirtualMachine.CreateString.
 621                 process(vm, value).stringObject;
 622         } catch (JDWPException exc) {
 623             throw exc.toJDIException();
 624         }
 625     }
 626 
 627     public VoidValue mirrorOfVoid() {
 628         if (voidVal == null) {
 629             voidVal = new VoidValueImpl(this);
 630         }
 631         return voidVal;
 632     }
 633 
 634     public long[] instanceCounts(List&lt;? extends ReferenceType&gt; classes) {
 635         if (!canGetInstanceInfo()) {
 636             throw new UnsupportedOperationException(
 637                 &quot;target does not support getting instances&quot;);
 638         }
 639         long[] retValue ;
 640         ReferenceTypeImpl[] rtArray = new ReferenceTypeImpl[classes.size()];
 641         int ii = 0;
 642         for (ReferenceType rti: classes) {
 643             validateMirror(rti);
 644             rtArray[ii++] = (ReferenceTypeImpl)rti;
 645         }
 646         try {
 647             retValue = JDWP.VirtualMachine.InstanceCounts.
 648                                 process(vm, rtArray).counts;
 649         } catch (JDWPException exc) {
 650             throw exc.toJDIException();
 651         }
 652 
 653         return retValue;
 654     }
 655 
 656     public void dispose() {
 657         validateVM();
 658         shutdown = true;
 659         try {
 660             JDWP.VirtualMachine.Dispose.process(vm);
 661         } catch (JDWPException exc) {
 662             throw exc.toJDIException();
 663         }
 664         target.stopListening();
 665     }
 666 
 667     public void exit(int exitCode) {
 668         validateVM();
 669         shutdown = true;
 670         try {
 671             JDWP.VirtualMachine.Exit.process(vm, exitCode);
 672         } catch (JDWPException exc) {
 673             throw exc.toJDIException();
 674         }
 675         target.stopListening();
 676     }
 677 
 678     public Process process() {
 679         validateVM();
 680         return process;
 681     }
 682 
 683     private JDWP.VirtualMachine.Version versionInfo() {
 684        try {
 685            if (versionInfo == null) {
 686                // Need not be synchronized since it is static information
 687                versionInfo = JDWP.VirtualMachine.Version.process(vm);
 688            }
 689            return versionInfo;
 690        } catch (JDWPException exc) {
 691            throw exc.toJDIException();
 692        }
 693     }
 694 
 695     public String description() {
 696         validateVM();
 697 
 698         return MessageFormat.format(vmManager.getString(&quot;version_format&quot;),
 699                                     &quot;&quot; + vmManager.majorInterfaceVersion(),
 700                                     &quot;&quot; + vmManager.minorInterfaceVersion(),
 701                                      versionInfo().description);
 702     }
 703 
 704     public String version() {
 705         validateVM();
 706         return versionInfo().vmVersion;
 707     }
 708 
 709     public String name() {
 710         validateVM();
 711         return versionInfo().vmName;
 712     }
 713 
 714     public boolean canWatchFieldModification() {
 715         validateVM();
 716         return capabilities().canWatchFieldModification;
 717     }
 718 
 719     public boolean canWatchFieldAccess() {
 720         validateVM();
 721         return capabilities().canWatchFieldAccess;
 722     }
 723 
 724     public boolean canGetBytecodes() {
 725         validateVM();
 726         return capabilities().canGetBytecodes;
 727     }
 728 
 729     public boolean canGetSyntheticAttribute() {
 730         validateVM();
 731         return capabilities().canGetSyntheticAttribute;
 732     }
 733 
 734     public boolean canGetOwnedMonitorInfo() {
 735         validateVM();
 736         return capabilities().canGetOwnedMonitorInfo;
 737     }
 738 
 739     public boolean canGetCurrentContendedMonitor() {
 740         validateVM();
 741         return capabilities().canGetCurrentContendedMonitor;
 742     }
 743 
 744     public boolean canGetMonitorInfo() {
 745         validateVM();
 746         return capabilities().canGetMonitorInfo;
 747     }
 748 
 749     private boolean hasNewCapabilities() {
 750         return versionInfo().jdwpMajor &gt; 1 ||
 751             versionInfo().jdwpMinor &gt;= 4;
 752     }
 753 
 754     boolean canGet1_5LanguageFeatures() {
 755         return versionInfo().jdwpMajor &gt; 1 ||
 756             versionInfo().jdwpMinor &gt;= 5;
 757     }
 758 
 759     public boolean canUseInstanceFilters() {
 760         validateVM();
 761         return hasNewCapabilities() &amp;&amp;
 762             capabilitiesNew().canUseInstanceFilters;
 763     }
 764 
 765     public boolean canRedefineClasses() {
 766         validateVM();
 767         return hasNewCapabilities() &amp;&amp;
 768             capabilitiesNew().canRedefineClasses;
 769     }
 770 
 771     @Deprecated(since=&quot;15&quot;)
 772     public boolean canAddMethod() {
 773         validateVM();
 774         return hasNewCapabilities() &amp;&amp;
 775             capabilitiesNew().canAddMethod;
 776     }
 777 
 778     @Deprecated(since=&quot;15&quot;)
 779     public boolean canUnrestrictedlyRedefineClasses() {
 780         validateVM();
 781         return hasNewCapabilities() &amp;&amp;
 782             capabilitiesNew().canUnrestrictedlyRedefineClasses;
 783     }
 784 
 785     public boolean canPopFrames() {
 786         validateVM();
 787         return hasNewCapabilities() &amp;&amp;
 788             capabilitiesNew().canPopFrames;
 789     }
 790 
 791     public boolean canGetMethodReturnValues() {
 792         return versionInfo().jdwpMajor &gt; 1 ||
 793             versionInfo().jdwpMinor &gt;= 6;
 794     }
 795 
 796     public boolean canGetInstanceInfo() {
 797         if (versionInfo().jdwpMajor &gt; 1 ||
 798             versionInfo().jdwpMinor &gt;= 6) {
 799             validateVM();
 800             return hasNewCapabilities() &amp;&amp;
 801                 capabilitiesNew().canGetInstanceInfo;
 802         } else {
 803             return false;
 804         }
 805     }
 806 
 807     public boolean canUseSourceNameFilters() {
 808         return versionInfo().jdwpMajor &gt; 1 ||
 809             versionInfo().jdwpMinor &gt;= 6;
 810     }
 811 
 812     public boolean canForceEarlyReturn() {
 813         validateVM();
 814         return hasNewCapabilities() &amp;&amp;
 815             capabilitiesNew().canForceEarlyReturn;
 816     }
 817 
 818     public boolean canBeModified() {
 819         return true;
 820     }
 821 
 822     public boolean canGetSourceDebugExtension() {
 823         validateVM();
 824         return hasNewCapabilities() &amp;&amp;
 825             capabilitiesNew().canGetSourceDebugExtension;
 826     }
 827 
 828     public boolean canGetClassFileVersion() {
 829         return versionInfo().jdwpMajor &gt; 1 ||
 830             versionInfo().jdwpMinor &gt;= 6;
 831     }
 832 
 833     public boolean canGetConstantPool() {
 834         validateVM();
 835         return hasNewCapabilities() &amp;&amp;
 836             capabilitiesNew().canGetConstantPool;
 837     }
 838 
 839     public boolean canRequestVMDeathEvent() {
 840         validateVM();
 841         return hasNewCapabilities() &amp;&amp;
 842             capabilitiesNew().canRequestVMDeathEvent;
 843     }
 844 
 845     public boolean canRequestMonitorEvents() {
 846         validateVM();
 847         return hasNewCapabilities() &amp;&amp;
 848             capabilitiesNew().canRequestMonitorEvents;
 849     }
 850 
 851     public boolean canGetMonitorFrameInfo() {
 852         validateVM();
 853         return hasNewCapabilities() &amp;&amp;
 854             capabilitiesNew().canGetMonitorFrameInfo;
 855     }
 856 
 857     public boolean canGetModuleInfo() {
 858         validateVM();
 859         return versionInfo().jdwpMajor &gt;= 9;
 860     }
 861 
 862     public void setDebugTraceMode(int traceFlags) {
 863         validateVM();
 864         this.traceFlags = traceFlags;
 865         this.traceReceives = (traceFlags &amp; TRACE_RECEIVES) != 0;
 866     }
 867 
 868     void printTrace(String string) {
 869         System.err.println(&quot;[JDI: &quot; + string + &quot;]&quot;);
 870     }
 871 
 872     void printReceiveTrace(int depth, String string) {
 873         StringBuilder sb = new StringBuilder(&quot;Receiving:&quot;);
 874         for (int i = depth; i &gt; 0; --i) {
 875             sb.append(&quot;    &quot;);
 876         }
 877         sb.append(string);
 878         printTrace(sb.toString());
 879     }
 880 
 881     private synchronized ReferenceTypeImpl addReferenceType(long id,
 882                                                             int tag,
 883                                                             String signature) {
 884         if (typesByID == null) {
 885             initReferenceTypes();
 886         }
 887         ReferenceTypeImpl type = null;
 888         switch(tag) {
 889             case JDWP.TypeTag.CLASS:
 890                 type = new ClassTypeImpl(vm, id);
 891                 break;
 892             case JDWP.TypeTag.INTERFACE:
 893                 type = new InterfaceTypeImpl(vm, id);
 894                 break;
 895             case JDWP.TypeTag.ARRAY:
 896                 type = new ArrayTypeImpl(vm, id);
 897                 break;
 898             default:
 899                 throw new InternalException(&quot;Invalid reference type tag&quot;);
 900         }
 901 
 902         if (signature == null &amp;&amp; retrievedAllTypes) {
 903             // do not cache if signature is not provided
 904             return type;
 905         }
 906 
 907         typesByID.put(id, type);
 908         typesBySignature.add(type);
 909 
 910         if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
 911            vm.printTrace(&quot;Caching new ReferenceType, sig=&quot; + signature +
 912                          &quot;, id=&quot; + id);
 913         }
 914 
 915         return type;
 916     }
 917 
 918     synchronized void removeReferenceType(String signature) {
 919         if (typesByID == null) {
 920             return;
 921         }
 922         /*
 923          * There can be multiple classes with the same name. Since
 924          * we can&#39;t differentiate here, we first remove all
 925          * matching classes from our cache...
 926          */
 927         Iterator&lt;ReferenceType&gt; iter = typesBySignature.iterator();
 928         int matches = 0;
 929         while (iter.hasNext()) {
 930             ReferenceTypeImpl type = (ReferenceTypeImpl)iter.next();
 931             int comp = signature.compareTo(type.signature());
 932             if (comp == 0) {
 933                 matches++;
 934                 iter.remove();
 935                 typesByID.remove(type.ref());
 936                 if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
 937                    vm.printTrace(&quot;Uncaching ReferenceType, sig=&quot; + signature +
 938                                  &quot;, id=&quot; + type.ref());
 939                 }
 940                 // fix for 4359077, don&#39;t break out. list is no longer sorted
 941                 // in the order we think
 942             }
 943         }
 944 
 945         /*
 946          * ...and if there was more than one, re-retrieve the classes
 947          * with that name
 948          */
 949         if (matches &gt; 1) {
 950             retrieveClassesBySignature(signature);
 951         }
 952     }
 953 
 954     private synchronized List&lt;ReferenceType&gt; findReferenceTypes(String signature) {
 955         if (typesByID == null) {
 956             return new ArrayList&lt;&gt;(0);
 957         }
 958         Iterator&lt;ReferenceType&gt; iter = typesBySignature.iterator();
 959         List&lt;ReferenceType&gt; list = new ArrayList&lt;&gt;();
 960         while (iter.hasNext()) {
 961             ReferenceTypeImpl type = (ReferenceTypeImpl)iter.next();
 962             int comp = signature.compareTo(type.signature());
 963             if (comp == 0) {
 964                 list.add(type);
 965                 // fix for 4359077, don&#39;t break out. list is no longer sorted
 966                 // in the order we think
 967             }
 968         }
 969         return list;
 970     }
 971 
 972     private void initReferenceTypes() {
 973         typesByID = new HashMap&lt;&gt;(300);
 974         typesBySignature = new HashSet&lt;&gt;();
 975     }
 976 
 977     ReferenceTypeImpl referenceType(long ref, byte tag) {
 978         return referenceType(ref, tag, null);
 979     }
 980 
 981     ClassTypeImpl classType(long ref) {
 982         return (ClassTypeImpl)referenceType(ref, JDWP.TypeTag.CLASS, null);
 983     }
 984 
 985     InterfaceTypeImpl interfaceType(long ref) {
 986         return (InterfaceTypeImpl)referenceType(ref, JDWP.TypeTag.INTERFACE, null);
 987     }
 988 
 989     ArrayTypeImpl arrayType(long ref) {
 990         return (ArrayTypeImpl)referenceType(ref, JDWP.TypeTag.ARRAY, null);
 991     }
 992 
 993     ReferenceTypeImpl referenceType(long id, int tag, String signature) {
 994         if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
 995             StringBuilder sb = new StringBuilder();
 996             sb.append(&quot;Looking up &quot;);
 997             if (tag == JDWP.TypeTag.CLASS) {
 998                 sb.append(&quot;Class&quot;);
 999             } else if (tag == JDWP.TypeTag.INTERFACE) {
1000                 sb.append(&quot;Interface&quot;);
1001             } else if (tag == JDWP.TypeTag.ARRAY) {
1002                 sb.append(&quot;ArrayType&quot;);
1003             } else {
1004                 sb.append(&quot;UNKNOWN TAG: &quot;).append(tag);
1005             }
1006             if (signature != null) {
1007                 sb.append(&quot;, signature=&#39;&quot;).append(signature).append(&#39;\&#39;&#39;);
1008             }
1009             sb.append(&quot;, id=&quot;).append(id);
1010             vm.printTrace(sb.toString());
1011         }
1012         if (id == 0) {
1013             return null;
1014         } else {
1015             ReferenceTypeImpl retType = null;
1016             synchronized (this) {
1017                 if (typesByID != null) {
1018                     retType = (ReferenceTypeImpl)typesByID.get(id);
1019                 }
1020                 if (retType == null) {
1021                     retType = addReferenceType(id, tag, signature);
1022                 }
1023                 if (signature != null) {
1024                     retType.setSignature(signature);
1025                 }
1026             }
1027             return retType;
1028         }
1029     }
1030 
1031     private JDWP.VirtualMachine.Capabilities capabilities() {
1032         if (capabilities == null) {
1033             try {
1034                 capabilities = JDWP.VirtualMachine
1035                                  .Capabilities.process(vm);
1036             } catch (JDWPException exc) {
1037                 throw exc.toJDIException();
1038             }
1039         }
1040         return capabilities;
1041     }
1042 
1043     private JDWP.VirtualMachine.CapabilitiesNew capabilitiesNew() {
1044         if (capabilitiesNew == null) {
1045             try {
1046                 capabilitiesNew = JDWP.VirtualMachine
1047                                  .CapabilitiesNew.process(vm);
1048             } catch (JDWPException exc) {
1049                 throw exc.toJDIException();
1050             }
1051         }
1052         return capabilitiesNew;
1053     }
1054 
1055     private synchronized ModuleReference addModule(long id) {
1056         if (modulesByID == null) {
1057             modulesByID = new HashMap&lt;&gt;(77);
1058         }
1059         ModuleReference module = new ModuleReferenceImpl(vm, id);
1060         modulesByID.put(id, module);
1061         return module;
1062     }
1063 
1064     ModuleReference getModule(long id) {
1065         if (id == 0) {
1066             return null;
1067         } else {
1068             ModuleReference module = null;
1069             synchronized (this) {
1070                 if (modulesByID != null) {
1071                     module = modulesByID.get(id);
1072                 }
1073                 if (module == null) {
1074                     module = addModule(id);
1075                 }
1076             }
1077             return module;
1078         }
1079     }
1080 
1081     private synchronized List&lt;ModuleReference&gt; retrieveAllModules() {
1082         ModuleReferenceImpl[] reqModules;
1083         try {
1084             reqModules = JDWP.VirtualMachine.AllModules.process(vm).modules;
1085         } catch (JDWPException exc) {
1086             throw exc.toJDIException();
1087         }
1088         ArrayList&lt;ModuleReference&gt; modules = new ArrayList&lt;&gt;();
1089         for (int i = 0; i &lt; reqModules.length; i++) {
1090             long moduleRef = reqModules[i].ref();
1091             ModuleReference module = getModule(moduleRef);
1092             modules.add(module);
1093         }
1094         return modules;
1095     }
1096 
1097     private List&lt;ReferenceType&gt; retrieveClassesBySignature(String signature) {
1098         if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
1099             vm.printTrace(&quot;Retrieving matching ReferenceTypes, sig=&quot; + signature);
1100         }
1101         JDWP.VirtualMachine.ClassesBySignature.ClassInfo[] cinfos;
1102         try {
1103             cinfos = JDWP.VirtualMachine.ClassesBySignature.
1104                                       process(vm, signature).classes;
1105         } catch (JDWPException exc) {
1106             throw exc.toJDIException();
1107         }
1108 
1109         int count = cinfos.length;
1110         List&lt;ReferenceType&gt; list = new ArrayList&lt;&gt;(count);
1111 
1112         // Hold lock during processing to improve performance
1113         synchronized (this) {
1114             for (int i = 0; i &lt; count; i++) {
1115                 JDWP.VirtualMachine.ClassesBySignature.ClassInfo ci =
1116                                                                cinfos[i];
1117                 ReferenceTypeImpl type = referenceType(ci.typeID,
1118                                                        ci.refTypeTag,
1119                                                        signature);
1120                 type.setStatus(ci.status);
1121                 list.add(type);
1122             }
1123         }
1124         return list;
1125     }
1126 
1127     private void retrieveAllClasses1_4() {
1128         JDWP.VirtualMachine.AllClasses.ClassInfo[] cinfos;
1129         try {
1130             cinfos = JDWP.VirtualMachine.AllClasses.process(vm).classes;
1131         } catch (JDWPException exc) {
1132             throw exc.toJDIException();
1133         }
1134 
1135         // Hold lock during processing to improve performance
1136         // and to have safe check/set of retrievedAllTypes
1137         synchronized (this) {
1138             if (!retrievedAllTypes) {
1139                 // Number of classes
1140                 int count = cinfos.length;
1141                 for (int i = 0; i &lt; count; i++) {
1142                     JDWP.VirtualMachine.AllClasses.ClassInfo ci = cinfos[i];
1143                     ReferenceTypeImpl type = referenceType(ci.typeID,
1144                                                            ci.refTypeTag,
1145                                                            ci.signature);
1146                     type.setStatus(ci.status);
1147                 }
1148                 retrievedAllTypes = true;
1149             }
1150         }
1151     }
1152 
1153     private void retrieveAllClasses() {
1154         if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
1155             vm.printTrace(&quot;Retrieving all ReferenceTypes&quot;);
1156         }
1157 
1158         if (!vm.canGet1_5LanguageFeatures()) {
1159             retrieveAllClasses1_4();
1160             return;
1161         }
1162 
1163         /*
1164          * To save time (assuming the caller will be
1165          * using then) we will get the generic sigs too.
1166          */
1167         JDWP.VirtualMachine.AllClassesWithGeneric.ClassInfo[] cinfos;
1168         try {
1169             cinfos = JDWP.VirtualMachine.AllClassesWithGeneric.process(vm).classes;
1170         } catch (JDWPException exc) {
1171             throw exc.toJDIException();
1172         }
1173 
1174         // Hold lock during processing to improve performance
1175         // and to have safe check/set of retrievedAllTypes
1176         synchronized (this) {
1177             if (!retrievedAllTypes) {
1178                 // Number of classes
1179                 int count = cinfos.length;
1180                 for (int i = 0; i &lt; count; i++) {
1181                     JDWP.VirtualMachine.AllClassesWithGeneric.ClassInfo ci =
1182                                                                cinfos[i];
1183                     ReferenceTypeImpl type = referenceType(ci.typeID,
1184                                                            ci.refTypeTag,
1185                                                            ci.signature);
1186                     type.setGenericSignature(ci.genericSignature);
1187                     type.setStatus(ci.status);
1188                 }
1189                 retrievedAllTypes = true;
1190             }
1191         }
1192     }
1193 
1194     void sendToTarget(Packet packet) {
1195         target.send(packet);
1196     }
1197 
1198     void waitForTargetReply(Packet packet) {
1199         target.waitForReply(packet);
1200         /*
1201          * If any object disposes have been batched up, send them now.
1202          */
1203         processBatchedDisposes();
1204     }
1205 
1206     Type findBootType(String signature) throws ClassNotLoadedException {
1207         List&lt;ReferenceType&gt; types = retrieveClassesBySignature(signature);
1208         Iterator&lt;ReferenceType&gt; iter = types.iterator();
1209         while (iter.hasNext()) {
1210             ReferenceType type = iter.next();
1211             if (type.classLoader() == null) {
1212                 return type;
1213             }
1214         }
1215         JNITypeParser parser = new JNITypeParser(signature);
1216         throw new ClassNotLoadedException(parser.typeName(),
1217                                          &quot;Type &quot; + parser.typeName() + &quot; not loaded&quot;);
1218     }
1219 
1220     BooleanType theBooleanType() {
1221         if (theBooleanType == null) {
1222             synchronized(this) {
1223                 if (theBooleanType == null) {
1224                     theBooleanType = new BooleanTypeImpl(this);
1225                 }
1226             }
1227         }
1228         return theBooleanType;
1229     }
1230 
1231     ByteType theByteType() {
1232         if (theByteType == null) {
1233             synchronized(this) {
1234                 if (theByteType == null) {
1235                     theByteType = new ByteTypeImpl(this);
1236                 }
1237             }
1238         }
1239         return theByteType;
1240     }
1241 
1242     CharType theCharType() {
1243         if (theCharType == null) {
1244             synchronized(this) {
1245                 if (theCharType == null) {
1246                     theCharType = new CharTypeImpl(this);
1247                 }
1248             }
1249         }
1250         return theCharType;
1251     }
1252 
1253     ShortType theShortType() {
1254         if (theShortType == null) {
1255             synchronized(this) {
1256                 if (theShortType == null) {
1257                     theShortType = new ShortTypeImpl(this);
1258                 }
1259             }
1260         }
1261         return theShortType;
1262     }
1263 
1264     IntegerType theIntegerType() {
1265         if (theIntegerType == null) {
1266             synchronized(this) {
1267                 if (theIntegerType == null) {
1268                     theIntegerType = new IntegerTypeImpl(this);
1269                 }
1270             }
1271         }
1272         return theIntegerType;
1273     }
1274 
1275     LongType theLongType() {
1276         if (theLongType == null) {
1277             synchronized(this) {
1278                 if (theLongType == null) {
1279                     theLongType = new LongTypeImpl(this);
1280                 }
1281             }
1282         }
1283         return theLongType;
1284     }
1285 
1286     FloatType theFloatType() {
1287         if (theFloatType == null) {
1288             synchronized(this) {
1289                 if (theFloatType == null) {
1290                     theFloatType = new FloatTypeImpl(this);
1291                 }
1292             }
1293         }
1294         return theFloatType;
1295     }
1296 
1297     DoubleType theDoubleType() {
1298         if (theDoubleType == null) {
1299             synchronized(this) {
1300                 if (theDoubleType == null) {
1301                     theDoubleType = new DoubleTypeImpl(this);
1302                 }
1303             }
1304         }
1305         return theDoubleType;
1306     }
1307 
1308     VoidType theVoidType() {
1309         if (theVoidType == null) {
1310             synchronized(this) {
1311                 if (theVoidType == null) {
1312                     theVoidType = new VoidTypeImpl(this);
1313                 }
1314             }
1315         }
1316         return theVoidType;
1317     }
1318 
1319     PrimitiveType primitiveTypeMirror(byte tag) {
1320         switch (tag) {
1321             case JDWP.Tag.BOOLEAN:
1322                 return theBooleanType();
1323             case JDWP.Tag.BYTE:
1324                 return theByteType();
1325             case JDWP.Tag.CHAR:
1326                 return theCharType();
1327             case JDWP.Tag.SHORT:
1328                 return theShortType();
1329             case JDWP.Tag.INT:
1330                 return theIntegerType();
1331             case JDWP.Tag.LONG:
1332                 return theLongType();
1333             case JDWP.Tag.FLOAT:
1334                 return theFloatType();
1335             case JDWP.Tag.DOUBLE:
1336                 return theDoubleType();
1337             default:
1338                 throw new IllegalArgumentException(&quot;Unrecognized primitive tag &quot; + tag);
1339         }
1340     }
1341 
1342     private void processBatchedDisposes() {
1343         if (shutdown) {
1344             return;
1345         }
1346 
1347         JDWP.VirtualMachine.DisposeObjects.Request[] requests = null;
1348         synchronized(batchedDisposeRequests) {
1349             int size = batchedDisposeRequests.size();
1350             if (size &gt;= DISPOSE_THRESHOLD) {
1351                 if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1352                     printTrace(&quot;Dispose threashold reached. Will dispose &quot;
1353                                + size + &quot; object references...&quot;);
1354                 }
1355                 requests = new JDWP.VirtualMachine.DisposeObjects.Request[size];
1356                 for (int i = 0; i &lt; requests.length; i++) {
1357                     SoftObjectReference ref = batchedDisposeRequests.get(i);
1358                     if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1359                         printTrace(&quot;Disposing object &quot; + ref.key().longValue() +
1360                                    &quot; (ref count = &quot; + ref.count() + &quot;)&quot;);
1361                     }
1362 
1363                     // This is kludgy. We temporarily re-create an object
1364                     // reference so that we can correctly pass its id to the
1365                     // JDWP command.
1366                     requests[i] =
1367                         new JDWP.VirtualMachine.DisposeObjects.Request(
1368                             new ObjectReferenceImpl(this, ref.key().longValue()),
1369                             ref.count());
1370                 }
1371                 batchedDisposeRequests.clear();
1372             }
1373         }
1374         if (requests != null) {
1375             try {
1376                 JDWP.VirtualMachine.DisposeObjects.process(vm, requests);
1377             } catch (JDWPException exc) {
1378                 throw exc.toJDIException();
1379             }
1380         }
1381     }
1382 
1383     private void batchForDispose(SoftObjectReference ref) {
1384         if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1385             printTrace(&quot;Batching object &quot; + ref.key().longValue() +
1386                        &quot; for dispose (ref count = &quot; + ref.count() + &quot;)&quot;);
1387         }
1388         batchedDisposeRequests.add(ref);
1389     }
1390 
1391     private void processQueue() {
1392         Reference&lt;?&gt; ref;
1393         //if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1394         //    printTrace(&quot;Checking for softly reachable objects&quot;);
1395         //}
1396         while ((ref = referenceQueue.poll()) != null) {
1397             SoftObjectReference softRef = (SoftObjectReference)ref;
1398             removeObjectMirror(softRef);
1399             batchForDispose(softRef);
1400         }
1401     }
1402 
1403     synchronized ObjectReferenceImpl objectMirror(long id, int tag) {
1404 
1405         // Handle any queue elements that are not strongly reachable
1406         processQueue();
1407 
1408         if (id == 0) {
1409             return null;
1410         }
1411         ObjectReferenceImpl object = null;
1412         Long key = id;
1413 
1414         /*
1415          * Attempt to retrieve an existing object reference
1416          */
1417         SoftObjectReference ref = objectsByID.get(key);
1418         if (ref != null) {
1419             object = ref.object();
1420         }
1421 
1422         /*
1423          * If the object wasn&#39;t in the table, or it&#39;s soft reference was
1424          * cleared, create a new instance.
1425          */
1426         if (object == null) {
1427             switch (tag) {
1428                 case JDWP.Tag.OBJECT:
1429                 case JDWP.Tag.INLINE_OBJECT:
1430                     object = new ObjectReferenceImpl(vm, id);
1431                     break;
1432                 case JDWP.Tag.STRING:
1433                     object = new StringReferenceImpl(vm, id);
1434                     break;
1435                 case JDWP.Tag.ARRAY:
1436                     object = new ArrayReferenceImpl(vm, id);
1437                     break;
1438                 case JDWP.Tag.THREAD:
1439                     ThreadReferenceImpl thread =
1440                         new ThreadReferenceImpl(vm, id);
1441                     thread.addListener(this);
1442                     object = thread;
1443                     break;
1444                 case JDWP.Tag.THREAD_GROUP:
1445                     object = new ThreadGroupReferenceImpl(vm, id);
1446                     break;
1447                 case JDWP.Tag.CLASS_LOADER:
1448                     object = new ClassLoaderReferenceImpl(vm, id);
1449                     break;
1450                 case JDWP.Tag.CLASS_OBJECT:
1451                     object = new ClassObjectReferenceImpl(vm, id);
1452                     break;
1453                 default:
1454                     throw new IllegalArgumentException(&quot;Invalid object tag: &quot; + tag);
1455             }
1456             ref = new SoftObjectReference(key, object, referenceQueue);
1457 
1458             /*
1459              * If there was no previous entry in the table, we add one here
1460              * If the previous entry was cleared, we replace it here.
1461              */
1462             objectsByID.put(key, ref);
1463             if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1464                 printTrace(&quot;Creating new &quot; +
1465                            object.getClass().getName() + &quot; (id = &quot; + id + &quot;)&quot;);
1466             }
1467         } else {
1468             ref.incrementCount();
1469         }
1470 
1471         return object;
1472     }
1473 
1474     synchronized void removeObjectMirror(ObjectReferenceImpl object) {
1475         // Handle any queue elements that are not strongly reachable
1476         processQueue();
1477 
1478         SoftObjectReference ref = objectsByID.remove(object.ref());
1479         if (ref != null) {
1480             batchForDispose(ref);
1481         } else {
1482             /*
1483              * If there&#39;s a live ObjectReference about, it better be part
1484              * of the cache.
1485              */
1486             throw new InternalException(&quot;ObjectReference &quot; + object.ref() +
1487                                         &quot; not found in object cache&quot;);
1488         }
1489     }
1490 
1491     synchronized void removeObjectMirror(SoftObjectReference ref) {
1492         /*
1493          * This will remove the soft reference if it has not been
1494          * replaced in the cache.
1495          */
1496         objectsByID.remove(ref.key());
1497     }
1498 
1499     ObjectReferenceImpl objectMirror(long id) {
1500         return objectMirror(id, JDWP.Tag.OBJECT);
1501     }
1502 
1503     StringReferenceImpl stringMirror(long id) {
1504         return (StringReferenceImpl)objectMirror(id, JDWP.Tag.STRING);
1505     }
1506 
1507     ArrayReferenceImpl arrayMirror(long id) {
1508        return (ArrayReferenceImpl)objectMirror(id, JDWP.Tag.ARRAY);
1509     }
1510 
1511     ThreadReferenceImpl threadMirror(long id) {
1512         return (ThreadReferenceImpl)objectMirror(id, JDWP.Tag.THREAD);
1513     }
1514 
1515     ThreadGroupReferenceImpl threadGroupMirror(long id) {
1516         return (ThreadGroupReferenceImpl)objectMirror(id,
1517                                                       JDWP.Tag.THREAD_GROUP);
1518     }
1519 
1520     ClassLoaderReferenceImpl classLoaderMirror(long id) {
1521         return (ClassLoaderReferenceImpl)objectMirror(id,
1522                                                       JDWP.Tag.CLASS_LOADER);
1523     }
1524 
1525     ClassObjectReferenceImpl classObjectMirror(long id) {
1526         return (ClassObjectReferenceImpl)objectMirror(id,
1527                                                       JDWP.Tag.CLASS_OBJECT);
1528     }
1529 
1530     ModuleReferenceImpl moduleMirror(long id) {
1531         return (ModuleReferenceImpl)getModule(id);
1532     }
1533 
1534     /*
1535      * Implementation of PathSearchingVirtualMachine
1536      */
1537     private JDWP.VirtualMachine.ClassPaths getClasspath() {
1538         if (pathInfo == null) {
1539             try {
1540                 pathInfo = JDWP.VirtualMachine.ClassPaths.process(vm);
1541             } catch (JDWPException exc) {
1542                 throw exc.toJDIException();
1543             }
1544         }
1545         return pathInfo;
1546     }
1547 
1548    public List&lt;String&gt; classPath() {
1549        return Arrays.asList(getClasspath().classpaths);
1550    }
1551 
1552    public List&lt;String&gt; bootClassPath() {
1553        return Collections.emptyList();
1554    }
1555 
1556    public String baseDirectory() {
1557        return getClasspath().baseDir;
1558    }
1559 
1560     public void setDefaultStratum(String stratum) {
1561         defaultStratum = stratum;
1562         if (stratum == null) {
1563             stratum = &quot;&quot;;
1564         }
1565         try {
1566             JDWP.VirtualMachine.SetDefaultStratum.process(vm,
1567                                                           stratum);
1568         } catch (JDWPException exc) {
1569             throw exc.toJDIException();
1570         }
1571     }
1572 
1573     public String getDefaultStratum() {
1574         return defaultStratum;
1575     }
1576 
1577     ThreadGroup threadGroupForJDI() {
1578         return threadGroupForJDI;
1579     }
1580 
1581    static private class SoftObjectReference extends SoftReference&lt;ObjectReferenceImpl&gt; {
1582        int count;
1583        Long key;
1584 
1585        SoftObjectReference(Long key, ObjectReferenceImpl mirror,
1586                            ReferenceQueue&lt;ObjectReferenceImpl&gt; queue) {
1587            super(mirror, queue);
1588            this.count = 1;
1589            this.key = key;
1590        }
1591 
1592        int count() {
1593            return count;
1594        }
1595 
1596        void incrementCount() {
1597            count++;
1598        }
1599 
1600        Long key() {
1601            return key;
1602        }
1603 
1604        ObjectReferenceImpl object() {
1605            return get();
1606        }
1607    }
1608 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.jdi/share/classes/com/sun/tools/jdi/VirtualMachineImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.jdi;
  27 
  28 import java.lang.ref.Reference;
  29 import java.lang.ref.ReferenceQueue;
  30 import java.lang.ref.SoftReference;
  31 import java.text.MessageFormat;
  32 import java.util.ArrayList;
  33 import java.util.Arrays;
  34 import java.util.Collections;
  35 import java.util.HashMap;
  36 import java.util.HashSet;
  37 import java.util.Iterator;
  38 import java.util.List;
  39 import java.util.Map;
  40 import java.util.Set;
  41 import java.util.function.Consumer;
  42 
  43 import com.sun.jdi.BooleanType;
  44 import com.sun.jdi.BooleanValue;
  45 import com.sun.jdi.ByteType;
  46 import com.sun.jdi.ByteValue;
  47 import com.sun.jdi.CharType;
  48 import com.sun.jdi.CharValue;
  49 import com.sun.jdi.ClassLoaderReference;
  50 import com.sun.jdi.ClassNotLoadedException;
  51 import com.sun.jdi.DoubleType;
  52 import com.sun.jdi.DoubleValue;
  53 import com.sun.jdi.FloatType;
  54 import com.sun.jdi.FloatValue;
  55 import com.sun.jdi.IntegerType;
  56 import com.sun.jdi.IntegerValue;
  57 import com.sun.jdi.InternalException;
  58 import com.sun.jdi.LongType;
  59 import com.sun.jdi.LongValue;
  60 import com.sun.jdi.ModuleReference;
  61 import com.sun.jdi.ObjectCollectedException;
  62 import com.sun.jdi.PathSearchingVirtualMachine;
  63 import com.sun.jdi.PrimitiveType;
  64 import com.sun.jdi.ReferenceType;
  65 import com.sun.jdi.ShortType;
  66 import com.sun.jdi.ShortValue;
  67 import com.sun.jdi.StringReference;
  68 import com.sun.jdi.ThreadGroupReference;
  69 import com.sun.jdi.ThreadReference;
  70 import com.sun.jdi.Type;
  71 import com.sun.jdi.VMDisconnectedException;
  72 import com.sun.jdi.VirtualMachine;
  73 import com.sun.jdi.VirtualMachineManager;
  74 import com.sun.jdi.VoidType;
  75 import com.sun.jdi.VoidValue;
  76 import com.sun.jdi.connect.spi.Connection;
  77 import com.sun.jdi.event.EventQueue;
  78 import com.sun.jdi.request.BreakpointRequest;
  79 import com.sun.jdi.request.EventRequest;
  80 import com.sun.jdi.request.EventRequestManager;
  81 
  82 class VirtualMachineImpl extends MirrorImpl
  83              implements PathSearchingVirtualMachine, ThreadListener {
  84     // VM Level exported variables, these
  85     // are unique to a given vm
  86     public final int sizeofFieldRef;
  87     public final int sizeofMethodRef;
  88     public final int sizeofObjectRef;
  89     public final int sizeofClassRef;
  90     public final int sizeofFrameRef;
  91     public final int sizeofModuleRef;
  92 
  93     final int sequenceNumber;
  94 
  95     private final TargetVM target;
  96     private final EventQueueImpl eventQueue;
  97     private final EventRequestManagerImpl internalEventRequestManager;
  98     private final EventRequestManagerImpl eventRequestManager;
  99     final VirtualMachineManagerImpl vmManager;
 100     private final ThreadGroup threadGroupForJDI;
 101 
 102     // Allow direct access to this field so that that tracing code slows down
 103     // JDI as little as possible when not enabled.
 104     int traceFlags = TRACE_NONE;
 105 
 106     static int TRACE_RAW_SENDS     = 0x01000000;
 107     static int TRACE_RAW_RECEIVES  = 0x02000000;
 108 
 109     boolean traceReceives = false;   // pre-compute because of frequency
 110 
 111     // ReferenceType access - updated with class prepare and unload events
 112     // Protected by &quot;synchronized(this)&quot;. &quot;retrievedAllTypes&quot; may be
 113     // tested unsynchronized (since once true, it stays true), but must
 114     // be set synchronously
 115     private Map&lt;Long, ReferenceType&gt; typesByID;
 116     private Set&lt;ReferenceType&gt; typesBySignature;
 117     private boolean retrievedAllTypes = false;
 118 
 119     private Map&lt;Long, ModuleReference&gt; modulesByID;
 120 
 121     // For other languages support
 122     private String defaultStratum = null;
 123 
 124     // ObjectReference cache
 125     // &quot;objectsByID&quot; protected by &quot;synchronized(this)&quot;.
 126     private final Map&lt;Long, SoftObjectReference&gt; objectsByID = new HashMap&lt;&gt;();
 127     private final ReferenceQueue&lt;ObjectReferenceImpl&gt; referenceQueue = new ReferenceQueue&lt;&gt;();
 128     static private final int DISPOSE_THRESHOLD = 50;
 129     private final List&lt;SoftObjectReference&gt; batchedDisposeRequests =
 130             Collections.synchronizedList(new ArrayList&lt;&gt;(DISPOSE_THRESHOLD + 10));
 131 
 132     // These are cached once for the life of the VM
 133     private JDWP.VirtualMachine.Version versionInfo;
 134     private JDWP.VirtualMachine.ClassPaths pathInfo;
 135     private JDWP.VirtualMachine.Capabilities capabilities = null;
 136     private JDWP.VirtualMachine.CapabilitiesNew capabilitiesNew = null;
 137 
 138     // Per-vm singletons for primitive types and for void.
 139     // singleton-ness protected by &quot;synchronized(this)&quot;.
 140     private BooleanType theBooleanType;
 141     private ByteType    theByteType;
 142     private CharType    theCharType;
 143     private ShortType   theShortType;
 144     private IntegerType theIntegerType;
 145     private LongType    theLongType;
 146     private FloatType   theFloatType;
 147     private DoubleType  theDoubleType;
 148 
 149     private VoidType    theVoidType;
 150 
 151     private VoidValue voidVal;
 152 
 153     // Launched debuggee process
 154     private Process process;
 155 
 156     // coordinates state changes and corresponding listener notifications
 157     private VMState state = new VMState(this);
 158 
 159     private Object initMonitor = new Object();
 160     private boolean initComplete = false;
 161     private boolean shutdown = false;
 162 
 163     private void notifyInitCompletion() {
 164         synchronized(initMonitor) {
 165             initComplete = true;
 166             initMonitor.notifyAll();
 167         }
 168     }
 169 
 170     void waitInitCompletion() {
 171         synchronized(initMonitor) {
 172             while (!initComplete) {
 173                 try {
 174                     initMonitor.wait();
 175                 } catch (InterruptedException e) {
 176                     // ignore
 177                 }
 178             }
 179         }
 180     }
 181 
 182     VMState state() {
 183         return state;
 184     }
 185 
 186     /*
 187      * ThreadListener implementation
 188      */
 189     public boolean threadResumable(ThreadAction action) {
 190         /*
 191          * If any thread is resumed, the VM is considered not suspended.
 192          * Just one thread is being resumed so pass it to thaw.
 193          */
 194         state.thaw(action.thread());
 195         return true;
 196     }
 197 
 198     VirtualMachineImpl(VirtualMachineManager manager,
 199                        Connection connection, Process process,
 200                        int sequenceNumber) {
 201         super(null);  // Can&#39;t use super(this)
 202         vm = this;
 203 
 204         this.vmManager = (VirtualMachineManagerImpl)manager;
 205         this.process = process;
 206         this.sequenceNumber = sequenceNumber;
 207 
 208         /* Create ThreadGroup to be used by all threads servicing
 209          * this VM.
 210          */
 211         threadGroupForJDI = new ThreadGroup(vmManager.mainGroupForJDI(),
 212                                             &quot;JDI [&quot; +
 213                                             this.hashCode() + &quot;]&quot;);
 214 
 215         /*
 216          * Set up a thread to communicate with the target VM over
 217          * the specified transport.
 218          */
 219         target = new TargetVM(this, connection);
 220 
 221         /*
 222          * Set up a thread to handle events processed internally
 223          * the JDI implementation.
 224          */
 225         EventQueueImpl internalEventQueue = new EventQueueImpl(this, target);
 226         new InternalEventHandler(this, internalEventQueue);
 227         /*
 228          * Initialize client access to event setting and handling
 229          */
 230         eventQueue = new EventQueueImpl(this, target);
 231         eventRequestManager = new EventRequestManagerImpl(this);
 232 
 233         target.start();
 234 
 235         /*
 236          * Many ids are variably sized, depending on target VM.
 237          * Find out the sizes right away.
 238          */
 239         JDWP.VirtualMachine.IDSizes idSizes;
 240         try {
 241             idSizes = JDWP.VirtualMachine.IDSizes.process(vm);
 242         } catch (JDWPException exc) {
 243             throw exc.toJDIException();
 244         }
 245         sizeofFieldRef  = idSizes.fieldIDSize;
 246         sizeofMethodRef = idSizes.methodIDSize;
 247         sizeofObjectRef = idSizes.objectIDSize;
 248         sizeofClassRef = idSizes.referenceTypeIDSize;
 249         sizeofFrameRef  = idSizes.frameIDSize;
 250         sizeofModuleRef = idSizes.objectIDSize;
 251 
 252         /**
 253          * Set up requests needed by internal event handler.
 254          * Make sure they are distinguished by creating them with
 255          * an internal event request manager.
 256          *
 257          * Warning: create events only with SUSPEND_NONE policy.
 258          * In the current implementation other policies will not
 259          * be handled correctly when the event comes in. (notfiySuspend()
 260          * will not be properly called, and if the event is combined
 261          * with external events in the same set, suspend policy is not
 262          * correctly determined for the internal vs. external event sets)
 263          */
 264         internalEventRequestManager = new EventRequestManagerImpl(this);
 265         EventRequest er = internalEventRequestManager.createClassPrepareRequest();
 266         er.setSuspendPolicy(EventRequest.SUSPEND_NONE);
 267         er.enable();
 268         er = internalEventRequestManager.createClassUnloadRequest();
 269         er.setSuspendPolicy(EventRequest.SUSPEND_NONE);
 270         er.enable();
 271 
 272         /*
 273          * Tell other threads, notably TargetVM, that initialization
 274          * is complete.
 275          */
 276         notifyInitCompletion();
 277     }
 278 
 279     EventRequestManagerImpl getInternalEventRequestManager() {
 280         return internalEventRequestManager;
 281     }
 282 
 283     void validateVM() {
 284         /*
 285          * We no longer need to do this.  The spec now says
 286          * that a VMDisconnected _may_ be thrown in these
 287          * cases, not that it _will_ be thrown.
 288          * So, to simplify things we will just let the
 289          * caller&#39;s of this method proceed with their business.
 290          * If the debuggee is disconnected, either because it
 291          * crashed or finished or something, or because the
 292          * debugger called exit() or dispose(), then if
 293          * we end up trying to communicate with the debuggee,
 294          * code in TargetVM will throw a VMDisconnectedException.
 295          * This means that if we can satisfy a request without
 296          * talking to the debuggee, (eg, with cached data) then
 297          * VMDisconnectedException will _not_ be thrown.
 298          * if (shutdown) {
 299          *    throw new VMDisconnectedException();
 300          * }
 301          */
 302     }
 303 
 304     public boolean equals(Object obj) {
 305         return this == obj;
 306     }
 307 
 308     public int hashCode() {
 309         return System.identityHashCode(this);
 310     }
 311 
 312     public List&lt;ModuleReference&gt; allModules() {
 313         validateVM();
 314         List&lt;ModuleReference&gt; modules = retrieveAllModules();
 315         return Collections.unmodifiableList(modules);
 316     }
 317 
 318     private static boolean isReferenceArray(String signature) {
 319         int i = signature.lastIndexOf(&#39;[&#39;);
 320         if (i &gt; -1 &amp;&amp; signature.charAt(i+1) == &#39;L&#39;) {
 321             return true;
 322         }
 323         return false;
 324     }
 325 
 326     public List&lt;ReferenceType&gt; classesByName(String className) {
 327         validateVM();
 328         return classesBySignature(JNITypeParser.typeNameToSignature(className));
 329     }
 330 
 331     List&lt;ReferenceType&gt; classesBySignature(String signature) {
 332         validateVM();
 333         List&lt;ReferenceType&gt; list;
 334         if (retrievedAllTypes) {
 335             list = findReferenceTypes(signature);
 336         } else {
 337             list = retrieveClassesBySignature(signature);
 338         }
 339         // HACK: add second request to cover the case where className
 340         // is the name of an inline type. This is done only if the
 341         // first signature is either a reference type or an array
 342         // of a reference type.
 343         if (signature.length() &gt; 1 &amp;&amp;
 344                 (signature.charAt(0) == &#39;L&#39; || isReferenceArray((signature)))) {
 345             List&lt;ReferenceType&gt; listInlineTypes;
 346             signature = signature.replaceFirst(&quot;L&quot;, &quot;Q&quot;);
 347             if (retrievedAllTypes) {
 348                 listInlineTypes = findReferenceTypes(signature);
 349             } else {
 350                 listInlineTypes = retrieveClassesBySignature(signature);
 351             }
 352             if (!listInlineTypes.isEmpty()) {
 353                 list.addAll(listInlineTypes);
 354             }
 355         }
 356 
 357         return Collections.unmodifiableList(list);
 358     }
 359 
 360     public List&lt;ReferenceType&gt; allClasses() {
 361         validateVM();
 362 
 363         if (!retrievedAllTypes) {
 364             retrieveAllClasses();
 365         }
 366         ArrayList&lt;ReferenceType&gt; a;
 367         synchronized (this) {
 368             a = new ArrayList&lt;&gt;(typesBySignature);
 369         }
 370         return Collections.unmodifiableList(a);
 371     }
 372 
 373     /**
 374      * Performs an action for each loaded type.
 375      */
 376     public void forEachClass(Consumer&lt;ReferenceType&gt; action) {
 377         for (ReferenceType type : allClasses()) {
 378             try {
 379                 action.accept(type);
 380             } catch (ObjectCollectedException ex) {
 381                 // Some classes might be unloaded and garbage collected since
 382                 // we retrieved the copy of all loaded classes and started
 383                 // iterating over them. In this case calling methods on such types
 384                 // might result in com.sun.jdi.ObjectCollectedException
 385                 // being thrown. We ignore such classes and keep iterating.
 386                 if ((vm.traceFlags &amp; VirtualMachine.TRACE_OBJREFS) != 0) {
 387                     vm.printTrace(&quot;ObjectCollectedException was thrown while &quot; +
 388                             &quot;accessing unloaded class &quot; + type.name());
 389                 }
 390             }
 391         }
 392     }
 393 
 394     public void
 395         redefineClasses(Map&lt;? extends ReferenceType, byte[]&gt; classToBytes)
 396     {
 397         int cnt = classToBytes.size();
 398         JDWP.VirtualMachine.RedefineClasses.ClassDef[] defs =
 399             new JDWP.VirtualMachine.RedefineClasses.ClassDef[cnt];
 400         validateVM();
 401         if (!canRedefineClasses()) {
 402             throw new UnsupportedOperationException();
 403         }
 404         Iterator&lt;?&gt; it = classToBytes.entrySet().iterator();
 405         for (int i = 0; it.hasNext(); i++) {
 406             @SuppressWarnings(&quot;rawtypes&quot;)
 407             Map.Entry&lt;?, ?&gt; entry = (Map.Entry)it.next();
 408             ReferenceTypeImpl refType = (ReferenceTypeImpl)entry.getKey();
 409             validateMirror(refType);
 410             defs[i] = new JDWP.VirtualMachine.RedefineClasses
 411                        .ClassDef(refType, (byte[])entry.getValue());
 412         }
 413 
 414         // flush caches and disable caching until the next suspend
 415         vm.state().thaw();
 416 
 417         try {
 418             JDWP.VirtualMachine.RedefineClasses.
 419                 process(vm, defs);
 420         } catch (JDWPException exc) {
 421             switch (exc.errorCode()) {
 422             case JDWP.Error.INVALID_CLASS_FORMAT :
 423                 throw new ClassFormatError(
 424                     &quot;class not in class file format&quot;);
 425             case JDWP.Error.CIRCULAR_CLASS_DEFINITION :
 426                 throw new ClassCircularityError(
 427                     &quot;circularity has been detected while initializing a class&quot;);
 428             case JDWP.Error.FAILS_VERIFICATION :
 429                 throw new VerifyError(
 430                     &quot;verifier detected internal inconsistency or security problem&quot;);
 431             case JDWP.Error.UNSUPPORTED_VERSION :
 432                 throw new UnsupportedClassVersionError(
 433                     &quot;version numbers of class are not supported&quot;);
 434             case JDWP.Error.ADD_METHOD_NOT_IMPLEMENTED:
 435                 throw new UnsupportedOperationException(
 436                     &quot;add method not implemented&quot;);
 437             case JDWP.Error.SCHEMA_CHANGE_NOT_IMPLEMENTED :
 438                 throw new UnsupportedOperationException(
 439                     &quot;schema change not implemented&quot;);
 440             case JDWP.Error.HIERARCHY_CHANGE_NOT_IMPLEMENTED:
 441                 throw new UnsupportedOperationException(
 442                     &quot;hierarchy change not implemented&quot;);
 443             case JDWP.Error.DELETE_METHOD_NOT_IMPLEMENTED :
 444                 throw new UnsupportedOperationException(
 445                     &quot;delete method not implemented&quot;);
 446             case JDWP.Error.CLASS_MODIFIERS_CHANGE_NOT_IMPLEMENTED:
 447                 throw new UnsupportedOperationException(
 448                     &quot;changes to class modifiers not implemented&quot;);
 449             case JDWP.Error.METHOD_MODIFIERS_CHANGE_NOT_IMPLEMENTED :
 450                 throw new UnsupportedOperationException(
 451                     &quot;changes to method modifiers not implemented&quot;);
 452             case JDWP.Error.CLASS_ATTRIBUTE_CHANGE_NOT_IMPLEMENTED :
 453                 throw new UnsupportedOperationException(
 454                     &quot;changes to class attribute not implemented&quot;);
 455             case JDWP.Error.NAMES_DONT_MATCH :
 456                 throw new NoClassDefFoundError(
 457                     &quot;class names do not match&quot;);
 458             default:
 459                 throw exc.toJDIException();
 460             }
 461         }
 462 
 463         // Delete any record of the breakpoints
 464         List&lt;BreakpointRequest&gt; toDelete = new ArrayList&lt;&gt;();
 465         EventRequestManager erm = eventRequestManager();
 466         it = erm.breakpointRequests().iterator();
 467         while (it.hasNext()) {
 468             BreakpointRequest req = (BreakpointRequest)it.next();
 469             if (classToBytes.containsKey(req.location().declaringType())) {
 470                 toDelete.add(req);
 471             }
 472         }
 473         erm.deleteEventRequests(toDelete);
 474 
 475         // Invalidate any information cached for the classes just redefined.
 476         it = classToBytes.keySet().iterator();
 477         while (it.hasNext()) {
 478             ReferenceTypeImpl rti = (ReferenceTypeImpl)it.next();
 479             rti.noticeRedefineClass();
 480         }
 481     }
 482 
 483     public List&lt;ThreadReference&gt; allThreads() {
 484         validateVM();
 485         return state.allThreads();
 486     }
 487 
 488     public List&lt;ThreadGroupReference&gt; topLevelThreadGroups() {
 489         validateVM();
 490         return state.topLevelThreadGroups();
 491     }
 492 
 493     /*
 494      * Sends a command to the back end which is defined to do an
 495      * implicit vm-wide resume. The VM can no longer be considered
 496      * suspended, so certain cached data must be invalidated.
 497      */
 498     PacketStream sendResumingCommand(CommandSender sender) {
 499         return state.thawCommand(sender);
 500     }
 501 
 502     /*
 503      * The VM has been suspended. Additional caching can be done
 504      * as long as there are no pending resumes.
 505      */
 506     void notifySuspend() {
 507         state.freeze();
 508     }
 509 
 510     public void suspend() {
 511         validateVM();
 512         try {
 513             JDWP.VirtualMachine.Suspend.process(vm);
 514         } catch (JDWPException exc) {
 515             throw exc.toJDIException();
 516         }
 517         notifySuspend();
 518     }
 519 
 520     public void resume() {
 521         validateVM();
 522         CommandSender sender =
 523             new CommandSender() {
 524                 public PacketStream send() {
 525                     return JDWP.VirtualMachine.Resume.enqueueCommand(vm);
 526                 }
 527         };
 528         try {
 529             PacketStream stream = state.thawCommand(sender);
 530             JDWP.VirtualMachine.Resume.waitForReply(vm, stream);
 531         } catch (VMDisconnectedException exc) {
 532             /*
 533              * If the debugger makes a VMDeathRequest with SUSPEND_ALL,
 534              * then when it does an EventSet.resume after getting the
 535              * VMDeathEvent, the normal flow of events is that the
 536              * BE shuts down, but the waitForReply comes back ok.  In this
 537              * case, the run loop in TargetVM that is waiting for a packet
 538              * gets an EOF because the socket closes. It generates a
 539              * VMDisconnectedEvent and everyone is happy.
 540              * However, sometimes, the BE gets shutdown before this
 541              * waitForReply completes.  In this case, TargetVM.waitForReply
 542              * gets awakened with no reply and so gens a VMDisconnectedException
 543              * which is not what we want.  It might be possible to fix this
 544              * in the BE, but it is ok to just ignore the VMDisconnectedException
 545              * here.  This will allow the VMDisconnectedEvent to be generated
 546              * correctly.  And, if the debugger should happen to make another
 547              * request, it will get a VMDisconnectedException at that time.
 548              */
 549         } catch (JDWPException exc) {
 550             switch (exc.errorCode()) {
 551                 case JDWP.Error.VM_DEAD:
 552                     return;
 553                 default:
 554                     throw exc.toJDIException();
 555             }
 556         }
 557     }
 558 
 559     public EventQueue eventQueue() {
 560         /*
 561          * No VM validation here. We allow access to the event queue
 562          * after disconnection, so that there is access to the terminating
 563          * events.
 564          */
 565         return eventQueue;
 566     }
 567 
 568     public EventRequestManager eventRequestManager() {
 569         validateVM();
 570         return eventRequestManager;
 571     }
 572 
 573     EventRequestManagerImpl eventRequestManagerImpl() {
 574         return eventRequestManager;
 575     }
 576 
 577     public BooleanValue mirrorOf(boolean value) {
 578         validateVM();
 579         return new BooleanValueImpl(this,value);
 580     }
 581 
 582     public ByteValue mirrorOf(byte value) {
 583         validateVM();
 584         return new ByteValueImpl(this,value);
 585     }
 586 
 587     public CharValue mirrorOf(char value) {
 588         validateVM();
 589         return new CharValueImpl(this,value);
 590     }
 591 
 592     public ShortValue mirrorOf(short value) {
 593         validateVM();
 594         return new ShortValueImpl(this,value);
 595     }
 596 
 597     public IntegerValue mirrorOf(int value) {
 598         validateVM();
 599         return new IntegerValueImpl(this,value);
 600     }
 601 
 602     public LongValue mirrorOf(long value) {
 603         validateVM();
 604         return new LongValueImpl(this,value);
 605     }
 606 
 607     public FloatValue mirrorOf(float value) {
 608         validateVM();
 609         return new FloatValueImpl(this,value);
 610     }
 611 
 612     public DoubleValue mirrorOf(double value) {
 613         validateVM();
 614         return new DoubleValueImpl(this,value);
 615     }
 616 
 617     public StringReference mirrorOf(String value) {
 618         validateVM();
 619         try {
 620             return JDWP.VirtualMachine.CreateString.
 621                 process(vm, value).stringObject;
 622         } catch (JDWPException exc) {
 623             throw exc.toJDIException();
 624         }
 625     }
 626 
 627     public VoidValue mirrorOfVoid() {
 628         if (voidVal == null) {
 629             voidVal = new VoidValueImpl(this);
 630         }
 631         return voidVal;
 632     }
 633 
 634     public long[] instanceCounts(List&lt;? extends ReferenceType&gt; classes) {
 635         if (!canGetInstanceInfo()) {
 636             throw new UnsupportedOperationException(
 637                 &quot;target does not support getting instances&quot;);
 638         }
 639         long[] retValue ;
 640         ReferenceTypeImpl[] rtArray = new ReferenceTypeImpl[classes.size()];
 641         int ii = 0;
 642         for (ReferenceType rti: classes) {
 643             validateMirror(rti);
 644             rtArray[ii++] = (ReferenceTypeImpl)rti;
 645         }
 646         try {
 647             retValue = JDWP.VirtualMachine.InstanceCounts.
 648                                 process(vm, rtArray).counts;
 649         } catch (JDWPException exc) {
 650             throw exc.toJDIException();
 651         }
 652 
 653         return retValue;
 654     }
 655 
 656     public void dispose() {
 657         validateVM();
 658         shutdown = true;
 659         try {
 660             JDWP.VirtualMachine.Dispose.process(vm);
 661         } catch (JDWPException exc) {
 662             throw exc.toJDIException();
 663         }
 664         target.stopListening();
 665     }
 666 
 667     public void exit(int exitCode) {
 668         validateVM();
 669         shutdown = true;
 670         try {
 671             JDWP.VirtualMachine.Exit.process(vm, exitCode);
 672         } catch (JDWPException exc) {
 673             throw exc.toJDIException();
 674         }
 675         target.stopListening();
 676     }
 677 
 678     public Process process() {
 679         validateVM();
 680         return process;
 681     }
 682 
 683     private JDWP.VirtualMachine.Version versionInfo() {
 684        try {
 685            if (versionInfo == null) {
 686                // Need not be synchronized since it is static information
 687                versionInfo = JDWP.VirtualMachine.Version.process(vm);
 688            }
 689            return versionInfo;
 690        } catch (JDWPException exc) {
 691            throw exc.toJDIException();
 692        }
 693     }
 694 
 695     public String description() {
 696         validateVM();
 697 
 698         return MessageFormat.format(vmManager.getString(&quot;version_format&quot;),
 699                                     &quot;&quot; + vmManager.majorInterfaceVersion(),
 700                                     &quot;&quot; + vmManager.minorInterfaceVersion(),
 701                                      versionInfo().description);
 702     }
 703 
 704     public String version() {
 705         validateVM();
 706         return versionInfo().vmVersion;
 707     }
 708 
 709     public String name() {
 710         validateVM();
 711         return versionInfo().vmName;
 712     }
 713 
 714     public boolean canWatchFieldModification() {
 715         validateVM();
 716         return capabilities().canWatchFieldModification;
 717     }
 718 
 719     public boolean canWatchFieldAccess() {
 720         validateVM();
 721         return capabilities().canWatchFieldAccess;
 722     }
 723 
 724     public boolean canGetBytecodes() {
 725         validateVM();
 726         return capabilities().canGetBytecodes;
 727     }
 728 
 729     public boolean canGetSyntheticAttribute() {
 730         validateVM();
 731         return capabilities().canGetSyntheticAttribute;
 732     }
 733 
 734     public boolean canGetOwnedMonitorInfo() {
 735         validateVM();
 736         return capabilities().canGetOwnedMonitorInfo;
 737     }
 738 
 739     public boolean canGetCurrentContendedMonitor() {
 740         validateVM();
 741         return capabilities().canGetCurrentContendedMonitor;
 742     }
 743 
 744     public boolean canGetMonitorInfo() {
 745         validateVM();
 746         return capabilities().canGetMonitorInfo;
 747     }
 748 
 749     private boolean hasNewCapabilities() {
 750         return versionInfo().jdwpMajor &gt; 1 ||
 751             versionInfo().jdwpMinor &gt;= 4;
 752     }
 753 
 754     boolean canGet1_5LanguageFeatures() {
 755         return versionInfo().jdwpMajor &gt; 1 ||
 756             versionInfo().jdwpMinor &gt;= 5;
 757     }
 758 
 759     public boolean canUseInstanceFilters() {
 760         validateVM();
 761         return hasNewCapabilities() &amp;&amp;
 762             capabilitiesNew().canUseInstanceFilters;
 763     }
 764 
 765     public boolean canRedefineClasses() {
 766         validateVM();
 767         return hasNewCapabilities() &amp;&amp;
 768             capabilitiesNew().canRedefineClasses;
 769     }
 770 
 771     public boolean canAddMethod() {
 772         validateVM();
 773         return hasNewCapabilities() &amp;&amp;
 774             capabilitiesNew().canAddMethod;
 775     }
 776 
 777     public boolean canUnrestrictedlyRedefineClasses() {
 778         validateVM();
 779         return hasNewCapabilities() &amp;&amp;
 780             capabilitiesNew().canUnrestrictedlyRedefineClasses;
 781     }
 782 
 783     public boolean canPopFrames() {
 784         validateVM();
 785         return hasNewCapabilities() &amp;&amp;
 786             capabilitiesNew().canPopFrames;
 787     }
 788 
 789     public boolean canGetMethodReturnValues() {
 790         return versionInfo().jdwpMajor &gt; 1 ||
 791             versionInfo().jdwpMinor &gt;= 6;
 792     }
 793 
 794     public boolean canGetInstanceInfo() {
 795         if (versionInfo().jdwpMajor &gt; 1 ||
 796             versionInfo().jdwpMinor &gt;= 6) {
 797             validateVM();
 798             return hasNewCapabilities() &amp;&amp;
 799                 capabilitiesNew().canGetInstanceInfo;
 800         } else {
 801             return false;
 802         }
 803     }
 804 
 805     public boolean canUseSourceNameFilters() {
 806         return versionInfo().jdwpMajor &gt; 1 ||
 807             versionInfo().jdwpMinor &gt;= 6;
 808     }
 809 
 810     public boolean canForceEarlyReturn() {
 811         validateVM();
 812         return hasNewCapabilities() &amp;&amp;
 813             capabilitiesNew().canForceEarlyReturn;
 814     }
 815 
 816     public boolean canBeModified() {
 817         return true;
 818     }
 819 
 820     public boolean canGetSourceDebugExtension() {
 821         validateVM();
 822         return hasNewCapabilities() &amp;&amp;
 823             capabilitiesNew().canGetSourceDebugExtension;
 824     }
 825 
 826     public boolean canGetClassFileVersion() {
 827         return versionInfo().jdwpMajor &gt; 1 ||
 828             versionInfo().jdwpMinor &gt;= 6;
 829     }
 830 
 831     public boolean canGetConstantPool() {
 832         validateVM();
 833         return hasNewCapabilities() &amp;&amp;
 834             capabilitiesNew().canGetConstantPool;
 835     }
 836 
 837     public boolean canRequestVMDeathEvent() {
 838         validateVM();
 839         return hasNewCapabilities() &amp;&amp;
 840             capabilitiesNew().canRequestVMDeathEvent;
 841     }
 842 
 843     public boolean canRequestMonitorEvents() {
 844         validateVM();
 845         return hasNewCapabilities() &amp;&amp;
 846             capabilitiesNew().canRequestMonitorEvents;
 847     }
 848 
 849     public boolean canGetMonitorFrameInfo() {
 850         validateVM();
 851         return hasNewCapabilities() &amp;&amp;
 852             capabilitiesNew().canGetMonitorFrameInfo;
 853     }
 854 
 855     public boolean canGetModuleInfo() {
 856         validateVM();
 857         return versionInfo().jdwpMajor &gt;= 9;
 858     }
 859 
 860     public void setDebugTraceMode(int traceFlags) {
 861         validateVM();
 862         this.traceFlags = traceFlags;
 863         this.traceReceives = (traceFlags &amp; TRACE_RECEIVES) != 0;
 864     }
 865 
 866     void printTrace(String string) {
 867         System.err.println(&quot;[JDI: &quot; + string + &quot;]&quot;);
 868     }
 869 
 870     void printReceiveTrace(int depth, String string) {
 871         StringBuilder sb = new StringBuilder(&quot;Receiving:&quot;);
 872         for (int i = depth; i &gt; 0; --i) {
 873             sb.append(&quot;    &quot;);
 874         }
 875         sb.append(string);
 876         printTrace(sb.toString());
 877     }
 878 
 879     private synchronized ReferenceTypeImpl addReferenceType(long id,
 880                                                             int tag,
 881                                                             String signature) {
 882         if (typesByID == null) {
 883             initReferenceTypes();
 884         }
 885         ReferenceTypeImpl type = null;
 886         switch(tag) {
 887             case JDWP.TypeTag.CLASS:
 888                 type = new ClassTypeImpl(vm, id);
 889                 break;
 890             case JDWP.TypeTag.INTERFACE:
 891                 type = new InterfaceTypeImpl(vm, id);
 892                 break;
 893             case JDWP.TypeTag.ARRAY:
 894                 type = new ArrayTypeImpl(vm, id);
 895                 break;
 896             default:
 897                 throw new InternalException(&quot;Invalid reference type tag&quot;);
 898         }
 899 
 900         if (signature == null &amp;&amp; retrievedAllTypes) {
 901             // do not cache if signature is not provided
 902             return type;
 903         }
 904 
 905         typesByID.put(id, type);
 906         typesBySignature.add(type);
 907 
 908         if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
 909            vm.printTrace(&quot;Caching new ReferenceType, sig=&quot; + signature +
 910                          &quot;, id=&quot; + id);
 911         }
 912 
 913         return type;
 914     }
 915 
 916     synchronized void removeReferenceType(String signature) {
 917         if (typesByID == null) {
 918             return;
 919         }
 920         /*
 921          * There can be multiple classes with the same name. Since
 922          * we can&#39;t differentiate here, we first remove all
 923          * matching classes from our cache...
 924          */
 925         Iterator&lt;ReferenceType&gt; iter = typesBySignature.iterator();
 926         int matches = 0;
 927         while (iter.hasNext()) {
 928             ReferenceTypeImpl type = (ReferenceTypeImpl)iter.next();
 929             int comp = signature.compareTo(type.signature());
 930             if (comp == 0) {
 931                 matches++;
 932                 iter.remove();
 933                 typesByID.remove(type.ref());
 934                 if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
 935                    vm.printTrace(&quot;Uncaching ReferenceType, sig=&quot; + signature +
 936                                  &quot;, id=&quot; + type.ref());
 937                 }
 938                 // fix for 4359077, don&#39;t break out. list is no longer sorted
 939                 // in the order we think
 940             }
 941         }
 942 
 943         /*
 944          * ...and if there was more than one, re-retrieve the classes
 945          * with that name
 946          */
 947         if (matches &gt; 1) {
 948             retrieveClassesBySignature(signature);
 949         }
 950     }
 951 
 952     private synchronized List&lt;ReferenceType&gt; findReferenceTypes(String signature) {
 953         if (typesByID == null) {
 954             return new ArrayList&lt;&gt;(0);
 955         }
 956         Iterator&lt;ReferenceType&gt; iter = typesBySignature.iterator();
 957         List&lt;ReferenceType&gt; list = new ArrayList&lt;&gt;();
 958         while (iter.hasNext()) {
 959             ReferenceTypeImpl type = (ReferenceTypeImpl)iter.next();
 960             int comp = signature.compareTo(type.signature());
 961             if (comp == 0) {
 962                 list.add(type);
 963                 // fix for 4359077, don&#39;t break out. list is no longer sorted
 964                 // in the order we think
 965             }
 966         }
 967         return list;
 968     }
 969 
 970     private void initReferenceTypes() {
 971         typesByID = new HashMap&lt;&gt;(300);
 972         typesBySignature = new HashSet&lt;&gt;();
 973     }
 974 
 975     ReferenceTypeImpl referenceType(long ref, byte tag) {
 976         return referenceType(ref, tag, null);
 977     }
 978 
 979     ClassTypeImpl classType(long ref) {
 980         return (ClassTypeImpl)referenceType(ref, JDWP.TypeTag.CLASS, null);
 981     }
 982 
 983     InterfaceTypeImpl interfaceType(long ref) {
 984         return (InterfaceTypeImpl)referenceType(ref, JDWP.TypeTag.INTERFACE, null);
 985     }
 986 
 987     ArrayTypeImpl arrayType(long ref) {
 988         return (ArrayTypeImpl)referenceType(ref, JDWP.TypeTag.ARRAY, null);
 989     }
 990 
 991     ReferenceTypeImpl referenceType(long id, int tag, String signature) {
 992         if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
 993             StringBuilder sb = new StringBuilder();
 994             sb.append(&quot;Looking up &quot;);
 995             if (tag == JDWP.TypeTag.CLASS) {
 996                 sb.append(&quot;Class&quot;);
 997             } else if (tag == JDWP.TypeTag.INTERFACE) {
 998                 sb.append(&quot;Interface&quot;);
 999             } else if (tag == JDWP.TypeTag.ARRAY) {
1000                 sb.append(&quot;ArrayType&quot;);
1001             } else {
1002                 sb.append(&quot;UNKNOWN TAG: &quot;).append(tag);
1003             }
1004             if (signature != null) {
1005                 sb.append(&quot;, signature=&#39;&quot;).append(signature).append(&#39;\&#39;&#39;);
1006             }
1007             sb.append(&quot;, id=&quot;).append(id);
1008             vm.printTrace(sb.toString());
1009         }
1010         if (id == 0) {
1011             return null;
1012         } else {
1013             ReferenceTypeImpl retType = null;
1014             synchronized (this) {
1015                 if (typesByID != null) {
1016                     retType = (ReferenceTypeImpl)typesByID.get(id);
1017                 }
1018                 if (retType == null) {
1019                     retType = addReferenceType(id, tag, signature);
1020                 }
1021                 if (signature != null) {
1022                     retType.setSignature(signature);
1023                 }
1024             }
1025             return retType;
1026         }
1027     }
1028 
1029     private JDWP.VirtualMachine.Capabilities capabilities() {
1030         if (capabilities == null) {
1031             try {
1032                 capabilities = JDWP.VirtualMachine
1033                                  .Capabilities.process(vm);
1034             } catch (JDWPException exc) {
1035                 throw exc.toJDIException();
1036             }
1037         }
1038         return capabilities;
1039     }
1040 
1041     private JDWP.VirtualMachine.CapabilitiesNew capabilitiesNew() {
1042         if (capabilitiesNew == null) {
1043             try {
1044                 capabilitiesNew = JDWP.VirtualMachine
1045                                  .CapabilitiesNew.process(vm);
1046             } catch (JDWPException exc) {
1047                 throw exc.toJDIException();
1048             }
1049         }
1050         return capabilitiesNew;
1051     }
1052 
1053     private synchronized ModuleReference addModule(long id) {
1054         if (modulesByID == null) {
1055             modulesByID = new HashMap&lt;&gt;(77);
1056         }
1057         ModuleReference module = new ModuleReferenceImpl(vm, id);
1058         modulesByID.put(id, module);
1059         return module;
1060     }
1061 
1062     ModuleReference getModule(long id) {
1063         if (id == 0) {
1064             return null;
1065         } else {
1066             ModuleReference module = null;
1067             synchronized (this) {
1068                 if (modulesByID != null) {
1069                     module = modulesByID.get(id);
1070                 }
1071                 if (module == null) {
1072                     module = addModule(id);
1073                 }
1074             }
1075             return module;
1076         }
1077     }
1078 
1079     private synchronized List&lt;ModuleReference&gt; retrieveAllModules() {
1080         ModuleReferenceImpl[] reqModules;
1081         try {
1082             reqModules = JDWP.VirtualMachine.AllModules.process(vm).modules;
1083         } catch (JDWPException exc) {
1084             throw exc.toJDIException();
1085         }
1086         ArrayList&lt;ModuleReference&gt; modules = new ArrayList&lt;&gt;();
1087         for (int i = 0; i &lt; reqModules.length; i++) {
1088             long moduleRef = reqModules[i].ref();
1089             ModuleReference module = getModule(moduleRef);
1090             modules.add(module);
1091         }
1092         return modules;
1093     }
1094 
1095     private List&lt;ReferenceType&gt; retrieveClassesBySignature(String signature) {
1096         if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
1097             vm.printTrace(&quot;Retrieving matching ReferenceTypes, sig=&quot; + signature);
1098         }
1099         JDWP.VirtualMachine.ClassesBySignature.ClassInfo[] cinfos;
1100         try {
1101             cinfos = JDWP.VirtualMachine.ClassesBySignature.
1102                                       process(vm, signature).classes;
1103         } catch (JDWPException exc) {
1104             throw exc.toJDIException();
1105         }
1106 
1107         int count = cinfos.length;
1108         List&lt;ReferenceType&gt; list = new ArrayList&lt;&gt;(count);
1109 
1110         // Hold lock during processing to improve performance
1111         synchronized (this) {
1112             for (int i = 0; i &lt; count; i++) {
1113                 JDWP.VirtualMachine.ClassesBySignature.ClassInfo ci =
1114                                                                cinfos[i];
1115                 ReferenceTypeImpl type = referenceType(ci.typeID,
1116                                                        ci.refTypeTag,
1117                                                        signature);
1118                 type.setStatus(ci.status);
1119                 list.add(type);
1120             }
1121         }
1122         return list;
1123     }
1124 
1125     private void retrieveAllClasses1_4() {
1126         JDWP.VirtualMachine.AllClasses.ClassInfo[] cinfos;
1127         try {
1128             cinfos = JDWP.VirtualMachine.AllClasses.process(vm).classes;
1129         } catch (JDWPException exc) {
1130             throw exc.toJDIException();
1131         }
1132 
1133         // Hold lock during processing to improve performance
1134         // and to have safe check/set of retrievedAllTypes
1135         synchronized (this) {
1136             if (!retrievedAllTypes) {
1137                 // Number of classes
1138                 int count = cinfos.length;
1139                 for (int i = 0; i &lt; count; i++) {
1140                     JDWP.VirtualMachine.AllClasses.ClassInfo ci = cinfos[i];
1141                     ReferenceTypeImpl type = referenceType(ci.typeID,
1142                                                            ci.refTypeTag,
1143                                                            ci.signature);
1144                     type.setStatus(ci.status);
1145                 }
1146                 retrievedAllTypes = true;
1147             }
1148         }
1149     }
1150 
1151     private void retrieveAllClasses() {
1152         if ((vm.traceFlags &amp; VirtualMachine.TRACE_REFTYPES) != 0) {
1153             vm.printTrace(&quot;Retrieving all ReferenceTypes&quot;);
1154         }
1155 
1156         if (!vm.canGet1_5LanguageFeatures()) {
1157             retrieveAllClasses1_4();
1158             return;
1159         }
1160 
1161         /*
1162          * To save time (assuming the caller will be
1163          * using then) we will get the generic sigs too.
1164          */
1165         JDWP.VirtualMachine.AllClassesWithGeneric.ClassInfo[] cinfos;
1166         try {
1167             cinfos = JDWP.VirtualMachine.AllClassesWithGeneric.process(vm).classes;
1168         } catch (JDWPException exc) {
1169             throw exc.toJDIException();
1170         }
1171 
1172         // Hold lock during processing to improve performance
1173         // and to have safe check/set of retrievedAllTypes
1174         synchronized (this) {
1175             if (!retrievedAllTypes) {
1176                 // Number of classes
1177                 int count = cinfos.length;
1178                 for (int i = 0; i &lt; count; i++) {
1179                     JDWP.VirtualMachine.AllClassesWithGeneric.ClassInfo ci =
1180                                                                cinfos[i];
1181                     ReferenceTypeImpl type = referenceType(ci.typeID,
1182                                                            ci.refTypeTag,
1183                                                            ci.signature);
1184                     type.setGenericSignature(ci.genericSignature);
1185                     type.setStatus(ci.status);
1186                 }
1187                 retrievedAllTypes = true;
1188             }
1189         }
1190     }
1191 
1192     void sendToTarget(Packet packet) {
1193         target.send(packet);
1194     }
1195 
1196     void waitForTargetReply(Packet packet) {
1197         target.waitForReply(packet);
1198         /*
1199          * If any object disposes have been batched up, send them now.
1200          */
1201         processBatchedDisposes();
1202     }
1203 
1204     Type findBootType(String signature) throws ClassNotLoadedException {
1205         List&lt;ReferenceType&gt; types = retrieveClassesBySignature(signature);
1206         Iterator&lt;ReferenceType&gt; iter = types.iterator();
1207         while (iter.hasNext()) {
1208             ReferenceType type = iter.next();
1209             if (type.classLoader() == null) {
1210                 return type;
1211             }
1212         }
1213         JNITypeParser parser = new JNITypeParser(signature);
1214         throw new ClassNotLoadedException(parser.typeName(),
1215                                          &quot;Type &quot; + parser.typeName() + &quot; not loaded&quot;);
1216     }
1217 
1218     BooleanType theBooleanType() {
1219         if (theBooleanType == null) {
1220             synchronized(this) {
1221                 if (theBooleanType == null) {
1222                     theBooleanType = new BooleanTypeImpl(this);
1223                 }
1224             }
1225         }
1226         return theBooleanType;
1227     }
1228 
1229     ByteType theByteType() {
1230         if (theByteType == null) {
1231             synchronized(this) {
1232                 if (theByteType == null) {
1233                     theByteType = new ByteTypeImpl(this);
1234                 }
1235             }
1236         }
1237         return theByteType;
1238     }
1239 
1240     CharType theCharType() {
1241         if (theCharType == null) {
1242             synchronized(this) {
1243                 if (theCharType == null) {
1244                     theCharType = new CharTypeImpl(this);
1245                 }
1246             }
1247         }
1248         return theCharType;
1249     }
1250 
1251     ShortType theShortType() {
1252         if (theShortType == null) {
1253             synchronized(this) {
1254                 if (theShortType == null) {
1255                     theShortType = new ShortTypeImpl(this);
1256                 }
1257             }
1258         }
1259         return theShortType;
1260     }
1261 
1262     IntegerType theIntegerType() {
1263         if (theIntegerType == null) {
1264             synchronized(this) {
1265                 if (theIntegerType == null) {
1266                     theIntegerType = new IntegerTypeImpl(this);
1267                 }
1268             }
1269         }
1270         return theIntegerType;
1271     }
1272 
1273     LongType theLongType() {
1274         if (theLongType == null) {
1275             synchronized(this) {
1276                 if (theLongType == null) {
1277                     theLongType = new LongTypeImpl(this);
1278                 }
1279             }
1280         }
1281         return theLongType;
1282     }
1283 
1284     FloatType theFloatType() {
1285         if (theFloatType == null) {
1286             synchronized(this) {
1287                 if (theFloatType == null) {
1288                     theFloatType = new FloatTypeImpl(this);
1289                 }
1290             }
1291         }
1292         return theFloatType;
1293     }
1294 
1295     DoubleType theDoubleType() {
1296         if (theDoubleType == null) {
1297             synchronized(this) {
1298                 if (theDoubleType == null) {
1299                     theDoubleType = new DoubleTypeImpl(this);
1300                 }
1301             }
1302         }
1303         return theDoubleType;
1304     }
1305 
1306     VoidType theVoidType() {
1307         if (theVoidType == null) {
1308             synchronized(this) {
1309                 if (theVoidType == null) {
1310                     theVoidType = new VoidTypeImpl(this);
1311                 }
1312             }
1313         }
1314         return theVoidType;
1315     }
1316 
1317     PrimitiveType primitiveTypeMirror(byte tag) {
1318         switch (tag) {
1319             case JDWP.Tag.BOOLEAN:
1320                 return theBooleanType();
1321             case JDWP.Tag.BYTE:
1322                 return theByteType();
1323             case JDWP.Tag.CHAR:
1324                 return theCharType();
1325             case JDWP.Tag.SHORT:
1326                 return theShortType();
1327             case JDWP.Tag.INT:
1328                 return theIntegerType();
1329             case JDWP.Tag.LONG:
1330                 return theLongType();
1331             case JDWP.Tag.FLOAT:
1332                 return theFloatType();
1333             case JDWP.Tag.DOUBLE:
1334                 return theDoubleType();
1335             default:
1336                 throw new IllegalArgumentException(&quot;Unrecognized primitive tag &quot; + tag);
1337         }
1338     }
1339 
1340     private void processBatchedDisposes() {
1341         if (shutdown) {
1342             return;
1343         }
1344 
1345         JDWP.VirtualMachine.DisposeObjects.Request[] requests = null;
1346         synchronized(batchedDisposeRequests) {
1347             int size = batchedDisposeRequests.size();
1348             if (size &gt;= DISPOSE_THRESHOLD) {
1349                 if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1350                     printTrace(&quot;Dispose threashold reached. Will dispose &quot;
1351                                + size + &quot; object references...&quot;);
1352                 }
1353                 requests = new JDWP.VirtualMachine.DisposeObjects.Request[size];
1354                 for (int i = 0; i &lt; requests.length; i++) {
1355                     SoftObjectReference ref = batchedDisposeRequests.get(i);
1356                     if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1357                         printTrace(&quot;Disposing object &quot; + ref.key().longValue() +
1358                                    &quot; (ref count = &quot; + ref.count() + &quot;)&quot;);
1359                     }
1360 
1361                     // This is kludgy. We temporarily re-create an object
1362                     // reference so that we can correctly pass its id to the
1363                     // JDWP command.
1364                     requests[i] =
1365                         new JDWP.VirtualMachine.DisposeObjects.Request(
1366                             new ObjectReferenceImpl(this, ref.key().longValue()),
1367                             ref.count());
1368                 }
1369                 batchedDisposeRequests.clear();
1370             }
1371         }
1372         if (requests != null) {
1373             try {
1374                 JDWP.VirtualMachine.DisposeObjects.process(vm, requests);
1375             } catch (JDWPException exc) {
1376                 throw exc.toJDIException();
1377             }
1378         }
1379     }
1380 
1381     private void batchForDispose(SoftObjectReference ref) {
1382         if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1383             printTrace(&quot;Batching object &quot; + ref.key().longValue() +
1384                        &quot; for dispose (ref count = &quot; + ref.count() + &quot;)&quot;);
1385         }
1386         batchedDisposeRequests.add(ref);
1387     }
1388 
1389     private void processQueue() {
1390         Reference&lt;?&gt; ref;
1391         //if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1392         //    printTrace(&quot;Checking for softly reachable objects&quot;);
1393         //}
1394         while ((ref = referenceQueue.poll()) != null) {
1395             SoftObjectReference softRef = (SoftObjectReference)ref;
1396             removeObjectMirror(softRef);
1397             batchForDispose(softRef);
1398         }
1399     }
1400 
1401     synchronized ObjectReferenceImpl objectMirror(long id, int tag) {
1402 
1403         // Handle any queue elements that are not strongly reachable
1404         processQueue();
1405 
1406         if (id == 0) {
1407             return null;
1408         }
1409         ObjectReferenceImpl object = null;
1410         Long key = id;
1411 
1412         /*
1413          * Attempt to retrieve an existing object reference
1414          */
1415         SoftObjectReference ref = objectsByID.get(key);
1416         if (ref != null) {
1417             object = ref.object();
1418         }
1419 
1420         /*
1421          * If the object wasn&#39;t in the table, or it&#39;s soft reference was
1422          * cleared, create a new instance.
1423          */
1424         if (object == null) {
1425             switch (tag) {
1426                 case JDWP.Tag.OBJECT:
1427                 case JDWP.Tag.INLINE_OBJECT:
1428                     object = new ObjectReferenceImpl(vm, id);
1429                     break;
1430                 case JDWP.Tag.STRING:
1431                     object = new StringReferenceImpl(vm, id);
1432                     break;
1433                 case JDWP.Tag.ARRAY:
1434                     object = new ArrayReferenceImpl(vm, id);
1435                     break;
1436                 case JDWP.Tag.THREAD:
1437                     ThreadReferenceImpl thread =
1438                         new ThreadReferenceImpl(vm, id);
1439                     thread.addListener(this);
1440                     object = thread;
1441                     break;
1442                 case JDWP.Tag.THREAD_GROUP:
1443                     object = new ThreadGroupReferenceImpl(vm, id);
1444                     break;
1445                 case JDWP.Tag.CLASS_LOADER:
1446                     object = new ClassLoaderReferenceImpl(vm, id);
1447                     break;
1448                 case JDWP.Tag.CLASS_OBJECT:
1449                     object = new ClassObjectReferenceImpl(vm, id);
1450                     break;
1451                 default:
1452                     throw new IllegalArgumentException(&quot;Invalid object tag: &quot; + tag);
1453             }
1454             ref = new SoftObjectReference(key, object, referenceQueue);
1455 
1456             /*
1457              * If there was no previous entry in the table, we add one here
1458              * If the previous entry was cleared, we replace it here.
1459              */
1460             objectsByID.put(key, ref);
1461             if ((traceFlags &amp; TRACE_OBJREFS) != 0) {
1462                 printTrace(&quot;Creating new &quot; +
1463                            object.getClass().getName() + &quot; (id = &quot; + id + &quot;)&quot;);
1464             }
1465         } else {
1466             ref.incrementCount();
1467         }
1468 
1469         return object;
1470     }
1471 
1472     synchronized void removeObjectMirror(ObjectReferenceImpl object) {
1473         // Handle any queue elements that are not strongly reachable
1474         processQueue();
1475 
1476         SoftObjectReference ref = objectsByID.remove(object.ref());
1477         if (ref != null) {
1478             batchForDispose(ref);
1479         } else {
1480             /*
1481              * If there&#39;s a live ObjectReference about, it better be part
1482              * of the cache.
1483              */
1484             throw new InternalException(&quot;ObjectReference &quot; + object.ref() +
1485                                         &quot; not found in object cache&quot;);
1486         }
1487     }
1488 
1489     synchronized void removeObjectMirror(SoftObjectReference ref) {
1490         /*
1491          * This will remove the soft reference if it has not been
1492          * replaced in the cache.
1493          */
1494         objectsByID.remove(ref.key());
1495     }
1496 
1497     ObjectReferenceImpl objectMirror(long id) {
1498         return objectMirror(id, JDWP.Tag.OBJECT);
1499     }
1500 
1501     StringReferenceImpl stringMirror(long id) {
1502         return (StringReferenceImpl)objectMirror(id, JDWP.Tag.STRING);
1503     }
1504 
1505     ArrayReferenceImpl arrayMirror(long id) {
1506        return (ArrayReferenceImpl)objectMirror(id, JDWP.Tag.ARRAY);
1507     }
1508 
1509     ThreadReferenceImpl threadMirror(long id) {
1510         return (ThreadReferenceImpl)objectMirror(id, JDWP.Tag.THREAD);
1511     }
1512 
1513     ThreadGroupReferenceImpl threadGroupMirror(long id) {
1514         return (ThreadGroupReferenceImpl)objectMirror(id,
1515                                                       JDWP.Tag.THREAD_GROUP);
1516     }
1517 
1518     ClassLoaderReferenceImpl classLoaderMirror(long id) {
1519         return (ClassLoaderReferenceImpl)objectMirror(id,
1520                                                       JDWP.Tag.CLASS_LOADER);
1521     }
1522 
1523     ClassObjectReferenceImpl classObjectMirror(long id) {
1524         return (ClassObjectReferenceImpl)objectMirror(id,
1525                                                       JDWP.Tag.CLASS_OBJECT);
1526     }
1527 
1528     ModuleReferenceImpl moduleMirror(long id) {
1529         return (ModuleReferenceImpl)getModule(id);
1530     }
1531 
1532     /*
1533      * Implementation of PathSearchingVirtualMachine
1534      */
1535     private JDWP.VirtualMachine.ClassPaths getClasspath() {
1536         if (pathInfo == null) {
1537             try {
1538                 pathInfo = JDWP.VirtualMachine.ClassPaths.process(vm);
1539             } catch (JDWPException exc) {
1540                 throw exc.toJDIException();
1541             }
1542         }
1543         return pathInfo;
1544     }
1545 
1546    public List&lt;String&gt; classPath() {
1547        return Arrays.asList(getClasspath().classpaths);
1548    }
1549 
1550    public List&lt;String&gt; bootClassPath() {
1551        return Collections.emptyList();
1552    }
1553 
1554    public String baseDirectory() {
1555        return getClasspath().baseDir;
1556    }
1557 
1558     public void setDefaultStratum(String stratum) {
1559         defaultStratum = stratum;
1560         if (stratum == null) {
1561             stratum = &quot;&quot;;
1562         }
1563         try {
1564             JDWP.VirtualMachine.SetDefaultStratum.process(vm,
1565                                                           stratum);
1566         } catch (JDWPException exc) {
1567             throw exc.toJDIException();
1568         }
1569     }
1570 
1571     public String getDefaultStratum() {
1572         return defaultStratum;
1573     }
1574 
1575     ThreadGroup threadGroupForJDI() {
1576         return threadGroupForJDI;
1577     }
1578 
1579    static private class SoftObjectReference extends SoftReference&lt;ObjectReferenceImpl&gt; {
1580        int count;
1581        Long key;
1582 
1583        SoftObjectReference(Long key, ObjectReferenceImpl mirror,
1584                            ReferenceQueue&lt;ObjectReferenceImpl&gt; queue) {
1585            super(mirror, queue);
1586            this.count = 1;
1587            this.key = key;
1588        }
1589 
1590        int count() {
1591            return count;
1592        }
1593 
1594        void incrementCount() {
1595            count++;
1596        }
1597 
1598        Long key() {
1599            return key;
1600        }
1601 
1602        ObjectReferenceImpl object() {
1603            return get();
1604        }
1605    }
1606 }
    </pre>
  </body>
</html>
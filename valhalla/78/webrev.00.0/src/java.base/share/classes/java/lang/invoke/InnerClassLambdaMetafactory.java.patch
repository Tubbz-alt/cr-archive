diff a/src/java.base/share/classes/java/lang/invoke/InnerClassLambdaMetafactory.java b/src/java.base/share/classes/java/lang/invoke/InnerClassLambdaMetafactory.java
--- a/src/java.base/share/classes/java/lang/invoke/InnerClassLambdaMetafactory.java
+++ b/src/java.base/share/classes/java/lang/invoke/InnerClassLambdaMetafactory.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -244,10 +244,51 @@
                 throw new LambdaConversionException("Exception finding constructor", e);
             }
         }
     }
 
+    /**
+     * Spins the lambda proxy class.
+     *
+     * This first checks if a lambda proxy class can be loaded from CDS archive.
+     * Otherwise, generate the lambda proxy class. If CDS dumping is enabled, it
+     * registers the lambda proxy class for including into the CDS archive.
+     */
+    private Class<?> spinInnerClass() throws LambdaConversionException {
+        // include lambda proxy class in CDS archive at dump time
+        if (LambdaProxyClassArchive.isDumpArchive()) {
+            Class<?> innerClass = generateInnerClass();
+            LambdaProxyClassArchive.register(targetClass,
+                                             samMethodName,
+                                             invokedType,
+                                             samMethodType,
+                                             implMethod,
+                                             instantiatedMethodType,
+                                             isSerializable,
+                                             markerInterfaces,
+                                             additionalBridges,
+                                             innerClass);
+            return innerClass;
+        }
+
+        // load from CDS archive if present
+        Class<?> innerClass = LambdaProxyClassArchive.find(targetClass,
+                                                           samMethodName,
+                                                           invokedType,
+                                                           samMethodType,
+                                                           implMethod,
+                                                           instantiatedMethodType,
+                                                           isSerializable,
+                                                           markerInterfaces,
+                                                           additionalBridges,
+                                                           !disableEagerInitialization);
+        if (innerClass == null) {
+            innerClass = generateInnerClass();
+        }
+        return innerClass;
+    }
+
     /**
      * Generate a class file which implements the functional
      * interface, define and return the class.
      *
      * @implNote The class that is generated does not include signature
@@ -259,11 +300,11 @@
      *
      * @return a Class which implements the functional interface
      * @throws LambdaConversionException If properly formed functional interface
      * is not found
      */
-    private Class<?> spinInnerClass() throws LambdaConversionException {
+    private Class<?> generateInnerClass() throws LambdaConversionException {
         String[] interfaces;
         String samIntf = samBase.getName().replace('.', '/');
         boolean accidentallySerializable = !isSerializable && Serializable.class.isAssignableFrom(samBase);
         if (markerInterfaces.length == 0) {
             interfaces = new String[]{samIntf};

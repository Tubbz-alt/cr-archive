<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/invoke/MethodHandles.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MethodHandleNatives.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../jdk.compiler/share/classes/com/sun/tools/doclint/Checker.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/invoke/MethodHandles.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.access.JavaLangAccess;
  29 import jdk.internal.access.SharedSecrets;

  30 import jdk.internal.misc.VM;
  31 import jdk.internal.module.IllegalAccessLogger;
  32 import jdk.internal.org.objectweb.asm.ClassReader;
  33 import jdk.internal.org.objectweb.asm.Opcodes;
  34 import jdk.internal.org.objectweb.asm.Type;
  35 import jdk.internal.reflect.CallerSensitive;
  36 import jdk.internal.reflect.Reflection;
  37 import jdk.internal.vm.annotation.ForceInline;
  38 import sun.invoke.util.ValueConversions;
  39 import sun.invoke.util.VerifyAccess;
  40 import sun.invoke.util.Wrapper;
  41 import sun.reflect.misc.ReflectUtil;
  42 import sun.security.util.SecurityConstants;
  43 
  44 import java.lang.invoke.LambdaForm.BasicType;
  45 import java.lang.reflect.Constructor;
  46 import java.lang.reflect.Field;
  47 import java.lang.reflect.Member;
  48 import java.lang.reflect.Method;
  49 import java.lang.reflect.Modifier;
</pre>
<hr />
<pre>
2226 
2227             Lookup defineClassAsLookup(boolean initialize) {
2228                 Class&lt;?&gt; c = defineClass(initialize, null);
2229                 return new Lookup(c, null, FULL_POWER_MODES);
2230             }
2231 
2232             /**
2233              * Defines the class of the given bytes and the given classData.
2234              * If {@code initialize} parameter is true, then the class will be initialized.
2235              *
2236              * @param initialize true if the class to be initialized
2237              * @param classData classData or null
2238              * @return the class
2239              *
2240              * @throws LinkageError linkage error
2241              */
2242             Class&lt;?&gt; defineClass(boolean initialize, Object classData) {
2243                 Class&lt;?&gt; lookupClass = lookup.lookupClass();
2244                 ClassLoader loader = lookupClass.getClassLoader();
2245                 ProtectionDomain pd = (loader != null) ? lookup.lookupClassProtectionDomain() : null;
<span class="line-modified">2246                 Class&lt;?&gt; c = JLA.defineClass(loader, lookupClass, name, bytes, pd, initialize, classFlags, classData);</span>

2247                 assert !isNestmate() || c.getNestHost() == lookupClass.getNestHost();
2248                 return c;
2249             }
2250 
2251             Lookup defineClassAsLookup(boolean initialize, Object classData) {
2252                 // initialize must be true if classData is non-null
2253                 assert classData == null || initialize == true;
2254                 Class&lt;?&gt; c = defineClass(initialize, classData);
2255                 return new Lookup(c, null, FULL_POWER_MODES);
2256             }
2257 
2258             private boolean isNestmate() {
2259                 return (classFlags &amp; NESTMATE_CLASS) != 0;
2260             }
2261         }
2262 
2263         private ProtectionDomain lookupClassProtectionDomain() {
2264             ProtectionDomain pd = cachedProtectionDomain;
2265             if (pd == null) {
<span class="line-modified">2266                 cachedProtectionDomain = pd = JLA.protectionDomain(lookupClass);</span>
2267             }
2268             return pd;
2269         }
2270 
2271         // cached protection domain
2272         private volatile ProtectionDomain cachedProtectionDomain;
2273 
2274         // Make sure outer class is initialized first.
2275         static { IMPL_NAMES.getClass(); }
2276 
2277         /** Package-private version of lookup which is trusted. */
2278         static final Lookup IMPL_LOOKUP = new Lookup(Object.class, null, TRUSTED);
2279 
2280         /** Version of lookup which is trusted minimally.
2281          *  It can only be used to create method handles to publicly accessible
2282          *  members in packages that are exported unconditionally.
2283          */
2284         static final Lookup PUBLIC_LOOKUP = new Lookup(Object.class, null, UNCONDITIONAL);
2285 
<span class="line-removed">2286         static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();</span>
<span class="line-removed">2287 </span>
2288         private static void checkUnprivilegedlookupClass(Class&lt;?&gt; lookupClass) {
2289             String name = lookupClass.getName();
2290             if (name.startsWith(&quot;java.lang.invoke.&quot;))
2291                 throw newIllegalArgumentException(&quot;illegal lookupClass: &quot;+lookupClass);
2292         }
2293 
2294         /**
2295          * Displays the name of the class from which lookups are to be made,
2296          * followed by &quot;/&quot; and the name of the {@linkplain #previousLookupClass()
2297          * previous lookup class} if present.
2298          * (The name is the one reported by {@link java.lang.Class#getName() Class.getName}.)
2299          * If there are restrictions on the access permitted to this lookup,
2300          * this is indicated by adding a suffix to the class name, consisting
2301          * of a slash and a keyword.  The keyword represents the strongest
2302          * allowed access, and is chosen as follows:
2303          * &lt;ul&gt;
2304          * &lt;li&gt;If no access is allowed, the suffix is &quot;/noaccess&quot;.
2305          * &lt;li&gt;If only unconditional access is allowed, the suffix is &quot;/publicLookup&quot;.
2306          * &lt;li&gt;If only public access to types in exported packages is allowed, the suffix is &quot;/public&quot;.
2307          * &lt;li&gt;If only public and module access are allowed, the suffix is &quot;/module&quot;.
</pre>
<hr />
<pre>
2585          * &lt;p&gt;
2586          * The lookup context here is determined by the {@linkplain #lookupClass() lookup class},
2587          * its class loader, and the {@linkplain #lookupModes() lookup modes}.
2588          *
2589          * @param targetName the fully qualified name of the class to be looked up.
2590          * @return the requested class.
2591          * @throws SecurityException if a security manager is present and it
2592          *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2593          * @throws LinkageError if the linkage fails
2594          * @throws ClassNotFoundException if the class cannot be loaded by the lookup class&#39; loader.
2595          * @throws IllegalAccessException if the class is not accessible, using the allowed access
2596          * modes.
2597          * @since 9
2598          * @jvms 5.4.3.1 Class and Interface Resolution
2599          */
2600         public Class&lt;?&gt; findClass(String targetName) throws ClassNotFoundException, IllegalAccessException {
2601             Class&lt;?&gt; targetClass = Class.forName(targetName, false, lookupClass.getClassLoader());
2602             return accessClass(targetClass);
2603         }
2604 





































2605         /**
2606          * Determines if a class can be accessed from the lookup context defined by
2607          * this {@code Lookup} object. The static initializer of the class is not run.
2608          * &lt;p&gt;
2609          * If the {@code targetClass} is in the same module as the lookup class,
2610          * the lookup class is {@code LC} in module {@code M1} and
2611          * the previous lookup class is in module {@code M0} or
2612          * {@code null} if not present,
2613          * {@code targetClass} is accessible if and only if one of the following is true:
2614          * &lt;ul&gt;
2615          * &lt;li&gt;If this lookup has {@link #PRIVATE} access, {@code targetClass} is
2616          *     {@code LC} or other class in the same nest of {@code LC}.&lt;/li&gt;
2617          * &lt;li&gt;If this lookup has {@link #PACKAGE} access, {@code targetClass} is
2618          *     in the same runtime package of {@code LC}.&lt;/li&gt;
2619          * &lt;li&gt;If this lookup has {@link #MODULE} access, {@code targetClass} is
2620          *     a public type in {@code M1}.&lt;/li&gt;
2621          * &lt;li&gt;If this lookup has {@link #PUBLIC} access, {@code targetClass} is
2622          *     a public type in a package exported by {@code M1} to at least  {@code M0}
2623          *     if the previous lookup class is present; otherwise, {@code targetClass}
2624          *     is a public type in a package exported by {@code M1} unconditionally.&lt;/li&gt;
</pre>
</td>
<td>
<hr />
<pre>
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang.invoke;
  27 
  28 import jdk.internal.access.JavaLangAccess;
  29 import jdk.internal.access.SharedSecrets;
<span class="line-added">  30 import jdk.internal.misc.Unsafe;</span>
  31 import jdk.internal.misc.VM;
  32 import jdk.internal.module.IllegalAccessLogger;
  33 import jdk.internal.org.objectweb.asm.ClassReader;
  34 import jdk.internal.org.objectweb.asm.Opcodes;
  35 import jdk.internal.org.objectweb.asm.Type;
  36 import jdk.internal.reflect.CallerSensitive;
  37 import jdk.internal.reflect.Reflection;
  38 import jdk.internal.vm.annotation.ForceInline;
  39 import sun.invoke.util.ValueConversions;
  40 import sun.invoke.util.VerifyAccess;
  41 import sun.invoke.util.Wrapper;
  42 import sun.reflect.misc.ReflectUtil;
  43 import sun.security.util.SecurityConstants;
  44 
  45 import java.lang.invoke.LambdaForm.BasicType;
  46 import java.lang.reflect.Constructor;
  47 import java.lang.reflect.Field;
  48 import java.lang.reflect.Member;
  49 import java.lang.reflect.Method;
  50 import java.lang.reflect.Modifier;
</pre>
<hr />
<pre>
2227 
2228             Lookup defineClassAsLookup(boolean initialize) {
2229                 Class&lt;?&gt; c = defineClass(initialize, null);
2230                 return new Lookup(c, null, FULL_POWER_MODES);
2231             }
2232 
2233             /**
2234              * Defines the class of the given bytes and the given classData.
2235              * If {@code initialize} parameter is true, then the class will be initialized.
2236              *
2237              * @param initialize true if the class to be initialized
2238              * @param classData classData or null
2239              * @return the class
2240              *
2241              * @throws LinkageError linkage error
2242              */
2243             Class&lt;?&gt; defineClass(boolean initialize, Object classData) {
2244                 Class&lt;?&gt; lookupClass = lookup.lookupClass();
2245                 ClassLoader loader = lookupClass.getClassLoader();
2246                 ProtectionDomain pd = (loader != null) ? lookup.lookupClassProtectionDomain() : null;
<span class="line-modified">2247                 Class&lt;?&gt; c = SharedSecrets.getJavaLangAccess()</span>
<span class="line-added">2248                         .defineClass(loader, lookupClass, name, bytes, pd, initialize, classFlags, classData);</span>
2249                 assert !isNestmate() || c.getNestHost() == lookupClass.getNestHost();
2250                 return c;
2251             }
2252 
2253             Lookup defineClassAsLookup(boolean initialize, Object classData) {
2254                 // initialize must be true if classData is non-null
2255                 assert classData == null || initialize == true;
2256                 Class&lt;?&gt; c = defineClass(initialize, classData);
2257                 return new Lookup(c, null, FULL_POWER_MODES);
2258             }
2259 
2260             private boolean isNestmate() {
2261                 return (classFlags &amp; NESTMATE_CLASS) != 0;
2262             }
2263         }
2264 
2265         private ProtectionDomain lookupClassProtectionDomain() {
2266             ProtectionDomain pd = cachedProtectionDomain;
2267             if (pd == null) {
<span class="line-modified">2268                 cachedProtectionDomain = pd = SharedSecrets.getJavaLangAccess().protectionDomain(lookupClass);</span>
2269             }
2270             return pd;
2271         }
2272 
2273         // cached protection domain
2274         private volatile ProtectionDomain cachedProtectionDomain;
2275 
2276         // Make sure outer class is initialized first.
2277         static { IMPL_NAMES.getClass(); }
2278 
2279         /** Package-private version of lookup which is trusted. */
2280         static final Lookup IMPL_LOOKUP = new Lookup(Object.class, null, TRUSTED);
2281 
2282         /** Version of lookup which is trusted minimally.
2283          *  It can only be used to create method handles to publicly accessible
2284          *  members in packages that are exported unconditionally.
2285          */
2286         static final Lookup PUBLIC_LOOKUP = new Lookup(Object.class, null, UNCONDITIONAL);
2287 


2288         private static void checkUnprivilegedlookupClass(Class&lt;?&gt; lookupClass) {
2289             String name = lookupClass.getName();
2290             if (name.startsWith(&quot;java.lang.invoke.&quot;))
2291                 throw newIllegalArgumentException(&quot;illegal lookupClass: &quot;+lookupClass);
2292         }
2293 
2294         /**
2295          * Displays the name of the class from which lookups are to be made,
2296          * followed by &quot;/&quot; and the name of the {@linkplain #previousLookupClass()
2297          * previous lookup class} if present.
2298          * (The name is the one reported by {@link java.lang.Class#getName() Class.getName}.)
2299          * If there are restrictions on the access permitted to this lookup,
2300          * this is indicated by adding a suffix to the class name, consisting
2301          * of a slash and a keyword.  The keyword represents the strongest
2302          * allowed access, and is chosen as follows:
2303          * &lt;ul&gt;
2304          * &lt;li&gt;If no access is allowed, the suffix is &quot;/noaccess&quot;.
2305          * &lt;li&gt;If only unconditional access is allowed, the suffix is &quot;/publicLookup&quot;.
2306          * &lt;li&gt;If only public access to types in exported packages is allowed, the suffix is &quot;/public&quot;.
2307          * &lt;li&gt;If only public and module access are allowed, the suffix is &quot;/module&quot;.
</pre>
<hr />
<pre>
2585          * &lt;p&gt;
2586          * The lookup context here is determined by the {@linkplain #lookupClass() lookup class},
2587          * its class loader, and the {@linkplain #lookupModes() lookup modes}.
2588          *
2589          * @param targetName the fully qualified name of the class to be looked up.
2590          * @return the requested class.
2591          * @throws SecurityException if a security manager is present and it
2592          *                           &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;
2593          * @throws LinkageError if the linkage fails
2594          * @throws ClassNotFoundException if the class cannot be loaded by the lookup class&#39; loader.
2595          * @throws IllegalAccessException if the class is not accessible, using the allowed access
2596          * modes.
2597          * @since 9
2598          * @jvms 5.4.3.1 Class and Interface Resolution
2599          */
2600         public Class&lt;?&gt; findClass(String targetName) throws ClassNotFoundException, IllegalAccessException {
2601             Class&lt;?&gt; targetClass = Class.forName(targetName, false, lookupClass.getClassLoader());
2602             return accessClass(targetClass);
2603         }
2604 
<span class="line-added">2605         /**</span>
<span class="line-added">2606          * Ensures that {@code targetClass} has been initialized. The class</span>
<span class="line-added">2607          * to be initialized must be {@linkplain #accessClass accessible}</span>
<span class="line-added">2608          * to this {@code Lookup} object.  This method causes {@code targetClass}</span>
<span class="line-added">2609          * to be initialized if it has not been already initialized,</span>
<span class="line-added">2610          * as specified in JVMS {@jvms 5.5}.</span>
<span class="line-added">2611          *</span>
<span class="line-added">2612          * @param targetClass the class to be initialized</span>
<span class="line-added">2613          * @return {@code targetClass} that has been initialized</span>
<span class="line-added">2614          *</span>
<span class="line-added">2615          * @throws  IllegalArgumentException if {@code targetClass} is a primitive type or {@code void}</span>
<span class="line-added">2616          *          or array class</span>
<span class="line-added">2617          * @throws  IllegalAccessException if {@code targetClass} is not</span>
<span class="line-added">2618          *          {@linkplain #accessClass accessible} to this lookup</span>
<span class="line-added">2619          * @throws  ExceptionInInitializerError if the class initialization provoked</span>
<span class="line-added">2620          *          by this method fails</span>
<span class="line-added">2621          * @throws  SecurityException if a security manager is present and it</span>
<span class="line-added">2622          *          &lt;a href=&quot;MethodHandles.Lookup.html#secmgr&quot;&gt;refuses access&lt;/a&gt;</span>
<span class="line-added">2623          * @since 15</span>
<span class="line-added">2624          * @jvms 5.5 Initialization</span>
<span class="line-added">2625          */</span>
<span class="line-added">2626         public Class&lt;?&gt; ensureInitialized(Class&lt;?&gt; targetClass) throws IllegalAccessException {</span>
<span class="line-added">2627             if (targetClass.isPrimitive())</span>
<span class="line-added">2628                 throw new IllegalArgumentException(targetClass + &quot; is a primitive class&quot;);</span>
<span class="line-added">2629             if (targetClass.isArray())</span>
<span class="line-added">2630                 throw new IllegalArgumentException(targetClass + &quot; is an array class&quot;);</span>
<span class="line-added">2631 </span>
<span class="line-added">2632             if (!VerifyAccess.isClassAccessible(targetClass, lookupClass, prevLookupClass, allowedModes)) {</span>
<span class="line-added">2633                 throw new MemberName(targetClass).makeAccessException(&quot;access violation&quot;, this);</span>
<span class="line-added">2634             }</span>
<span class="line-added">2635             checkSecurityManager(targetClass, null);</span>
<span class="line-added">2636 </span>
<span class="line-added">2637             // ensure class initialization</span>
<span class="line-added">2638             Unsafe.getUnsafe().ensureClassInitialized(targetClass);</span>
<span class="line-added">2639             return targetClass;</span>
<span class="line-added">2640         }</span>
<span class="line-added">2641 </span>
2642         /**
2643          * Determines if a class can be accessed from the lookup context defined by
2644          * this {@code Lookup} object. The static initializer of the class is not run.
2645          * &lt;p&gt;
2646          * If the {@code targetClass} is in the same module as the lookup class,
2647          * the lookup class is {@code LC} in module {@code M1} and
2648          * the previous lookup class is in module {@code M0} or
2649          * {@code null} if not present,
2650          * {@code targetClass} is accessible if and only if one of the following is true:
2651          * &lt;ul&gt;
2652          * &lt;li&gt;If this lookup has {@link #PRIVATE} access, {@code targetClass} is
2653          *     {@code LC} or other class in the same nest of {@code LC}.&lt;/li&gt;
2654          * &lt;li&gt;If this lookup has {@link #PACKAGE} access, {@code targetClass} is
2655          *     in the same runtime package of {@code LC}.&lt;/li&gt;
2656          * &lt;li&gt;If this lookup has {@link #MODULE} access, {@code targetClass} is
2657          *     a public type in {@code M1}.&lt;/li&gt;
2658          * &lt;li&gt;If this lookup has {@link #PUBLIC} access, {@code targetClass} is
2659          *     a public type in a package exported by {@code M1} to at least  {@code M0}
2660          *     if the previous lookup class is present; otherwise, {@code targetClass}
2661          *     is a public type in a package exported by {@code M1} unconditionally.&lt;/li&gt;
</pre>
</td>
</tr>
</table>
<center><a href="MethodHandleNatives.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../jdk.compiler/share/classes/com/sun/tools/doclint/Checker.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
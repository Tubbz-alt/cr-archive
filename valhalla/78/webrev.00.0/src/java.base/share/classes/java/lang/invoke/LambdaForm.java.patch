diff a/src/java.base/share/classes/java/lang/invoke/LambdaForm.java b/src/java.base/share/classes/java/lang/invoke/LambdaForm.java
--- a/src/java.base/share/classes/java/lang/invoke/LambdaForm.java
+++ b/src/java.base/share/classes/java/lang/invoke/LambdaForm.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -803,11 +803,11 @@
      * not differ in their optimized form.  Repeated versions
      * of machine would have the undesirable overheads of
      * (a) redundant compilation work and (b) extra I$ pressure.
      * To control repeated versions, we need to be ready to
      * erase details from LFs and move them into MH data,
-     * whevener those details are not relevant to significant
+     * whenever those details are not relevant to significant
      * optimization.  "Significant" means optimization of
      * code that is actually hot.
      *
      * Achieving this may require dynamic splitting of MHs, by replacing
      * a generic LF with a more specialized one, on the same MH,
@@ -897,11 +897,11 @@
     // The next few routines are called only from assert expressions
     // They verify that the built-in invokers process the correct raw data types.
     private static boolean argumentTypesMatch(String sig, Object[] av) {
         int arity = signatureArity(sig);
         assert(av.length == arity) : "av.length == arity: av.length=" + av.length + ", arity=" + arity;
-        assert(av[0] instanceof MethodHandle) : "av[0] not instace of MethodHandle: " + av[0];
+        assert(av[0] instanceof MethodHandle) : "av[0] not instance of MethodHandle: " + av[0];
         MethodHandle mh = (MethodHandle) av[0];
         MethodType mt = mh.type();
         assert(mt.parameterCount() == arity-1);
         for (int i = 0; i < av.length; i++) {
             Class<?> pt = (i == 0 ? MethodHandle.class : mt.parameterType(i-1));

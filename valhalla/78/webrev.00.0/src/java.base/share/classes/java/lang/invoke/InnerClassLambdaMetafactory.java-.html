<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/lang/invoke/InnerClassLambdaMetafactory.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2012, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package java.lang.invoke;
 27 
 28 import jdk.internal.access.JavaLangAccess;
 29 import jdk.internal.access.SharedSecrets;
 30 import jdk.internal.org.objectweb.asm.*;
 31 import sun.invoke.util.BytecodeDescriptor;
 32 import sun.security.action.GetPropertyAction;
 33 import sun.security.action.GetBooleanAction;
 34 
 35 import java.io.FilePermission;
 36 import java.io.Serializable;
 37 import java.lang.invoke.MethodHandles.Lookup;
 38 import java.lang.reflect.Constructor;
 39 import java.lang.reflect.Modifier;
 40 import java.security.AccessController;
 41 import java.security.PrivilegedAction;
 42 import java.util.LinkedHashSet;
 43 import java.util.concurrent.atomic.AtomicInteger;
 44 import java.util.PropertyPermission;
 45 import java.util.Set;
 46 
 47 import static java.lang.invoke.MethodHandles.Lookup.ClassOption.NESTMATE;
 48 import static java.lang.invoke.MethodHandles.Lookup.ClassOption.STRONG;
 49 import static jdk.internal.org.objectweb.asm.Opcodes.*;
 50 
 51 /**
 52  * Lambda metafactory implementation which dynamically creates an
 53  * inner-class-like class per lambda callsite.
 54  *
 55  * @see LambdaMetafactory
 56  */
 57 /* package */ final class InnerClassLambdaMetafactory extends AbstractValidatingLambdaMetafactory {
 58     private static final int CLASSFILE_VERSION = 52;
 59     private static final String METHOD_DESCRIPTOR_VOID = Type.getMethodDescriptor(Type.VOID_TYPE);
 60     private static final String JAVA_LANG_OBJECT = &quot;java/lang/Object&quot;;
 61     private static final String NAME_CTOR = &quot;&lt;init&gt;&quot;;
 62 
 63     //Serialization support
 64     private static final String NAME_SERIALIZED_LAMBDA = &quot;java/lang/invoke/SerializedLambda&quot;;
 65     private static final String NAME_NOT_SERIALIZABLE_EXCEPTION = &quot;java/io/NotSerializableException&quot;;
 66     private static final String DESCR_METHOD_WRITE_REPLACE = &quot;()Ljava/lang/Object;&quot;;
 67     private static final String DESCR_METHOD_WRITE_OBJECT = &quot;(Ljava/io/ObjectOutputStream;)V&quot;;
 68     private static final String DESCR_METHOD_READ_OBJECT = &quot;(Ljava/io/ObjectInputStream;)V&quot;;
 69     private static final String DESCR_SET_IMPL_METHOD = &quot;(Ljava/lang/invoke/MethodHandle;)V&quot;;
 70 
 71     private static final String NAME_METHOD_WRITE_REPLACE = &quot;writeReplace&quot;;
 72     private static final String NAME_METHOD_READ_OBJECT = &quot;readObject&quot;;
 73     private static final String NAME_METHOD_WRITE_OBJECT = &quot;writeObject&quot;;
 74     private static final String NAME_FIELD_IMPL_METHOD = &quot;protectedImplMethod&quot;;
 75 
 76     private static final String DESCR_CLASS = &quot;Ljava/lang/Class;&quot;;
 77     private static final String DESCR_STRING = &quot;Ljava/lang/String;&quot;;
 78     private static final String DESCR_OBJECT = &quot;Ljava/lang/Object;&quot;;
 79     private static final String DESCR_METHOD_HANDLE = &quot;Ljava/lang/invoke/MethodHandle;&quot;;
 80     private static final String DESCR_CTOR_SERIALIZED_LAMBDA
 81             = &quot;(&quot; + DESCR_CLASS + DESCR_STRING + DESCR_STRING + DESCR_STRING + &quot;I&quot;
 82             + DESCR_STRING + DESCR_STRING + DESCR_STRING + DESCR_STRING + &quot;[&quot; + DESCR_OBJECT + &quot;)V&quot;;
 83 
 84     private static final String DESCR_CTOR_NOT_SERIALIZABLE_EXCEPTION = &quot;(Ljava/lang/String;)V&quot;;
 85     private static final String[] SER_HOSTILE_EXCEPTIONS = new String[] {NAME_NOT_SERIALIZABLE_EXCEPTION};
 86 
 87     private static final String[] EMPTY_STRING_ARRAY = new String[0];
 88 
 89     // Used to ensure that each spun class name is unique
 90     private static final AtomicInteger counter = new AtomicInteger(0);
 91 
 92     // For dumping generated classes to disk, for debugging purposes
 93     private static final ProxyClassesDumper dumper;
 94 
 95     private static final boolean disableEagerInitialization;
 96 
 97     static {
 98         final String dumpProxyClassesKey = &quot;jdk.internal.lambda.dumpProxyClasses&quot;;
 99         String dumpPath = GetPropertyAction.privilegedGetProperty(dumpProxyClassesKey);
100         dumper = (null == dumpPath) ? null : ProxyClassesDumper.getInstance(dumpPath);
101 
102         final String disableEagerInitializationKey = &quot;jdk.internal.lambda.disableEagerInitialization&quot;;
103         disableEagerInitialization = GetBooleanAction.privilegedGetProperty(disableEagerInitializationKey);
104     }
105 
106     // See context values in AbstractValidatingLambdaMetafactory
107     private final String implMethodClassName;        // Name of type containing implementation &quot;CC&quot;
108     private final String implMethodName;             // Name of implementation method &quot;impl&quot;
109     private final String implMethodDesc;             // Type descriptor for implementation methods &quot;(I)Ljava/lang/String;&quot;
110     private final MethodType constructorType;        // Generated class constructor type &quot;(CC)void&quot;
111     private final ClassWriter cw;                    // ASM class writer
112     private final String[] argNames;                 // Generated names for the constructor arguments
113     private final String[] argDescs;                 // Type descriptors for the constructor arguments
114     private final String lambdaClassName;            // Generated name for the generated class &quot;X$$Lambda$1&quot;
115     private final boolean useImplMethodHandle;       // use MethodHandle invocation instead of symbolic bytecode invocation
116 
117     /**
118      * General meta-factory constructor, supporting both standard cases and
119      * allowing for uncommon options such as serialization or bridging.
120      *
121      * @param caller Stacked automatically by VM; represents a lookup context
122      *               with the accessibility privileges of the caller.
123      * @param invokedType Stacked automatically by VM; the signature of the
124      *                    invoked method, which includes the expected static
125      *                    type of the returned lambda object, and the static
126      *                    types of the captured arguments for the lambda.  In
127      *                    the event that the implementation method is an
128      *                    instance method, the first argument in the invocation
129      *                    signature will correspond to the receiver.
130      * @param samMethodName Name of the method in the functional interface to
131      *                      which the lambda or method reference is being
132      *                      converted, represented as a String.
133      * @param samMethodType Type of the method in the functional interface to
134      *                      which the lambda or method reference is being
135      *                      converted, represented as a MethodType.
136      * @param implMethod The implementation method which should be called (with
137      *                   suitable adaptation of argument types, return types,
138      *                   and adjustment for captured arguments) when methods of
139      *                   the resulting functional interface instance are invoked.
140      * @param instantiatedMethodType The signature of the primary functional
141      *                               interface method after type variables are
142      *                               substituted with their instantiation from
143      *                               the capture site
144      * @param isSerializable Should the lambda be made serializable?  If set,
145      *                       either the target type or one of the additional SAM
146      *                       types must extend {@code Serializable}.
147      * @param markerInterfaces Additional interfaces which the lambda object
148      *                       should implement.
149      * @param additionalBridges Method types for additional signatures to be
150      *                          bridged to the implementation method
151      * @throws LambdaConversionException If any of the meta-factory protocol
152      * invariants are violated
153      */
154     public InnerClassLambdaMetafactory(MethodHandles.Lookup caller,
155                                        MethodType invokedType,
156                                        String samMethodName,
157                                        MethodType samMethodType,
158                                        MethodHandle implMethod,
159                                        MethodType instantiatedMethodType,
160                                        boolean isSerializable,
161                                        Class&lt;?&gt;[] markerInterfaces,
162                                        MethodType[] additionalBridges)
163             throws LambdaConversionException {
164         super(caller, invokedType, samMethodName, samMethodType,
165               implMethod, instantiatedMethodType,
166               isSerializable, markerInterfaces, additionalBridges);
167         implMethodClassName = implClass.getName().replace(&#39;.&#39;, &#39;/&#39;);
168         implMethodName = implInfo.getName();
169         implMethodDesc = implInfo.getMethodType().toMethodDescriptorString();
170         constructorType = invokedType.changeReturnType(Void.TYPE);
171         lambdaClassName = lambdaClassName(targetClass);
172         useImplMethodHandle = !implClass.getPackageName().equals(implInfo.getDeclaringClass().getPackageName())
173                                 &amp;&amp; !Modifier.isPublic(implInfo.getModifiers());
174         cw = new ClassWriter(ClassWriter.COMPUTE_MAXS);
175         int parameterCount = invokedType.parameterCount();
176         if (parameterCount &gt; 0) {
177             argNames = new String[parameterCount];
178             argDescs = new String[parameterCount];
179             for (int i = 0; i &lt; parameterCount; i++) {
180                 argNames[i] = &quot;arg$&quot; + (i + 1);
181                 argDescs[i] = BytecodeDescriptor.unparse(invokedType.parameterType(i));
182             }
183         } else {
184             argNames = argDescs = EMPTY_STRING_ARRAY;
185         }
186     }
187 
188     private static String lambdaClassName(Class&lt;?&gt; targetClass) {
189         String name = targetClass.getName();
190         if (targetClass.isHidden()) {
191             // use the original class name
192             name = name.replace(&#39;/&#39;, &#39;_&#39;);
193         }
194         return name.replace(&#39;.&#39;, &#39;/&#39;) + &quot;$$Lambda$&quot; + counter.incrementAndGet();
195     }
196 
197     /**
198      * Build the CallSite. Generate a class file which implements the functional
199      * interface, define the class, if there are no parameters create an instance
200      * of the class which the CallSite will return, otherwise, generate handles
201      * which will call the class&#39; constructor.
202      *
203      * @return a CallSite, which, when invoked, will return an instance of the
204      * functional interface
205      * @throws ReflectiveOperationException
206      * @throws LambdaConversionException If properly formed functional interface
207      * is not found
208      */
209     @Override
210     CallSite buildCallSite() throws LambdaConversionException {
211         final Class&lt;?&gt; innerClass = spinInnerClass();
212         if (invokedType.parameterCount() == 0 &amp;&amp; !disableEagerInitialization) {
213             // In the case of a non-capturing lambda, we optimize linkage by pre-computing a single instance,
214             // unless we&#39;ve suppressed eager initialization
215             final Constructor&lt;?&gt;[] ctrs = AccessController.doPrivileged(
216                     new PrivilegedAction&lt;&gt;() {
217                 @Override
218                 public Constructor&lt;?&gt;[] run() {
219                     Constructor&lt;?&gt;[] ctrs = innerClass.getDeclaredConstructors();
220                     if (ctrs.length == 1) {
221                         // The lambda implementing inner class constructor is private, set
222                         // it accessible (by us) before creating the constant sole instance
223                         ctrs[0].setAccessible(true);
224                     }
225                     return ctrs;
226                 }
227                     });
228             if (ctrs.length != 1) {
229                 throw new LambdaConversionException(&quot;Expected one lambda constructor for &quot;
230                         + innerClass.getCanonicalName() + &quot;, got &quot; + ctrs.length);
231             }
232 
233             try {
234                 Object inst = ctrs[0].newInstance();
235                 return new ConstantCallSite(MethodHandles.constant(samBase, inst));
236             } catch (ReflectiveOperationException e) {
237                 throw new LambdaConversionException(&quot;Exception instantiating lambda object&quot;, e);
238             }
239         } else {
240             try {
241                 MethodHandle mh = caller.findConstructor(innerClass, invokedType.changeReturnType(void.class));
242                 return new ConstantCallSite(mh.asType(invokedType));
243             } catch (ReflectiveOperationException e) {
244                 throw new LambdaConversionException(&quot;Exception finding constructor&quot;, e);
245             }
246         }
247     }
248 
249     /**
250      * Generate a class file which implements the functional
251      * interface, define and return the class.
252      *
253      * @implNote The class that is generated does not include signature
254      * information for exceptions that may be present on the SAM method.
255      * This is to reduce classfile size, and is harmless as checked exceptions
256      * are erased anyway, no one will ever compile against this classfile,
257      * and we make no guarantees about the reflective properties of lambda
258      * objects.
259      *
260      * @return a Class which implements the functional interface
261      * @throws LambdaConversionException If properly formed functional interface
262      * is not found
263      */
264     private Class&lt;?&gt; spinInnerClass() throws LambdaConversionException {
265         String[] interfaces;
266         String samIntf = samBase.getName().replace(&#39;.&#39;, &#39;/&#39;);
267         boolean accidentallySerializable = !isSerializable &amp;&amp; Serializable.class.isAssignableFrom(samBase);
268         if (markerInterfaces.length == 0) {
269             interfaces = new String[]{samIntf};
270         } else {
271             // Assure no duplicate interfaces (ClassFormatError)
272             Set&lt;String&gt; itfs = new LinkedHashSet&lt;&gt;(markerInterfaces.length + 1);
273             itfs.add(samIntf);
274             for (Class&lt;?&gt; markerInterface : markerInterfaces) {
275                 itfs.add(markerInterface.getName().replace(&#39;.&#39;, &#39;/&#39;));
276                 accidentallySerializable |= !isSerializable &amp;&amp; Serializable.class.isAssignableFrom(markerInterface);
277             }
278             interfaces = itfs.toArray(new String[itfs.size()]);
279         }
280 
281         cw.visit(CLASSFILE_VERSION, ACC_SUPER + ACC_FINAL + ACC_SYNTHETIC,
282                  lambdaClassName, null,
283                  JAVA_LANG_OBJECT, interfaces);
284 
285         // Generate final fields to be filled in by constructor
286         for (int i = 0; i &lt; argDescs.length; i++) {
287             FieldVisitor fv = cw.visitField(ACC_PRIVATE + ACC_FINAL,
288                                             argNames[i],
289                                             argDescs[i],
290                                             null, null);
291             fv.visitEnd();
292         }
293 
294         generateConstructor();
295 
296         // Forward the SAM method
297         MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, samMethodName,
298                                           samMethodType.toMethodDescriptorString(), null, null);
299         new ForwardingMethodGenerator(mv).generate(samMethodType);
300 
301         // Forward the bridges
302         if (additionalBridges != null) {
303             for (MethodType mt : additionalBridges) {
304                 mv = cw.visitMethod(ACC_PUBLIC|ACC_BRIDGE, samMethodName,
305                                     mt.toMethodDescriptorString(), null, null);
306                 new ForwardingMethodGenerator(mv).generate(mt);
307             }
308         }
309 
310         if (useImplMethodHandle) {
311             FieldVisitor fv = cw.visitField(ACC_PRIVATE + ACC_STATIC,
312                                             NAME_FIELD_IMPL_METHOD,
313                                             DESCR_METHOD_HANDLE,
314                                             null, null);
315             fv.visitEnd();
316         }
317 
318         if (isSerializable)
319             generateSerializationFriendlyMethods();
320         else if (accidentallySerializable)
321             generateSerializationHostileMethods();
322 
323         cw.visitEnd();
324 
325         // Define the generated class in this VM.
326 
327         final byte[] classBytes = cw.toByteArray();
328         // If requested, dump out to a file for debugging purposes
329         if (dumper != null) {
330             AccessController.doPrivileged(new PrivilegedAction&lt;&gt;() {
331                 @Override
332                 public Void run() {
333                     dumper.dumpClass(lambdaClassName, classBytes);
334                     return null;
335                 }
336             }, null,
337             new FilePermission(&quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read, write&quot;),
338             // createDirectories may need it
339             new PropertyPermission(&quot;user.dir&quot;, &quot;read&quot;));
340         }
341         try {
342             // this class is linked at the indy callsite; so define a hidden nestmate
343             Lookup lookup = caller.defineHiddenClass(classBytes, !disableEagerInitialization, NESTMATE, STRONG);
344             if (useImplMethodHandle) {
345                 // If the target class invokes a method reference this::m which is
346                 // resolved to a protected method inherited from a superclass in a different
347                 // package, the target class does not have a bridge and this method reference
348                 // has been changed from public to protected after the target class was compiled.
349                 // This lambda proxy class has no access to the resolved method.
350                 // So this workaround by passing the live implMethod method handle
351                 // to the proxy class to invoke directly.
352                 MethodHandle mh = lookup.findStaticSetter(lookup.lookupClass(), NAME_FIELD_IMPL_METHOD, MethodHandle.class);
353                 mh.invokeExact(implMethod);
354             }
355             return lookup.lookupClass();
356         } catch (IllegalAccessException e) {
357             throw new LambdaConversionException(&quot;Exception defining lambda proxy class&quot;, e);
358         } catch (Throwable t) {
359             throw new InternalError(t);
360         }
361     }
362 
363     /**
364      * Generate the constructor for the class
365      */
366     private void generateConstructor() {
367         // Generate constructor
368         MethodVisitor ctor = cw.visitMethod(ACC_PRIVATE, NAME_CTOR,
369                                             constructorType.toMethodDescriptorString(), null, null);
370         ctor.visitCode();
371         ctor.visitVarInsn(ALOAD, 0);
372         ctor.visitMethodInsn(INVOKESPECIAL, JAVA_LANG_OBJECT, NAME_CTOR,
373                              METHOD_DESCRIPTOR_VOID, false);
374         int parameterCount = invokedType.parameterCount();
375         for (int i = 0, lvIndex = 0; i &lt; parameterCount; i++) {
376             ctor.visitVarInsn(ALOAD, 0);
377             Class&lt;?&gt; argType = invokedType.parameterType(i);
378             ctor.visitVarInsn(getLoadOpcode(argType), lvIndex + 1);
379             lvIndex += getParameterSize(argType);
380             ctor.visitFieldInsn(PUTFIELD, lambdaClassName, argNames[i], argDescs[i]);
381         }
382         ctor.visitInsn(RETURN);
383         // Maxs computed by ClassWriter.COMPUTE_MAXS, these arguments ignored
384         ctor.visitMaxs(-1, -1);
385         ctor.visitEnd();
386     }
387 
388     /**
389      * Generate a writeReplace method that supports serialization
390      */
391     private void generateSerializationFriendlyMethods() {
392         TypeConvertingMethodAdapter mv
393                 = new TypeConvertingMethodAdapter(
394                     cw.visitMethod(ACC_PRIVATE + ACC_FINAL,
395                     NAME_METHOD_WRITE_REPLACE, DESCR_METHOD_WRITE_REPLACE,
396                     null, null));
397 
398         mv.visitCode();
399         mv.visitTypeInsn(NEW, NAME_SERIALIZED_LAMBDA);
400         mv.visitInsn(DUP);
401         mv.visitLdcInsn(Type.getType(targetClass));
402         mv.visitLdcInsn(invokedType.returnType().getName().replace(&#39;.&#39;, &#39;/&#39;));
403         mv.visitLdcInsn(samMethodName);
404         mv.visitLdcInsn(samMethodType.toMethodDescriptorString());
405         mv.visitLdcInsn(implInfo.getReferenceKind());
406         mv.visitLdcInsn(implInfo.getDeclaringClass().getName().replace(&#39;.&#39;, &#39;/&#39;));
407         mv.visitLdcInsn(implInfo.getName());
408         mv.visitLdcInsn(implInfo.getMethodType().toMethodDescriptorString());
409         mv.visitLdcInsn(instantiatedMethodType.toMethodDescriptorString());
410         mv.iconst(argDescs.length);
411         mv.visitTypeInsn(ANEWARRAY, JAVA_LANG_OBJECT);
412         for (int i = 0; i &lt; argDescs.length; i++) {
413             mv.visitInsn(DUP);
414             mv.iconst(i);
415             mv.visitVarInsn(ALOAD, 0);
416             mv.visitFieldInsn(GETFIELD, lambdaClassName, argNames[i], argDescs[i]);
417             mv.boxIfTypePrimitive(Type.getType(argDescs[i]));
418             mv.visitInsn(AASTORE);
419         }
420         mv.visitMethodInsn(INVOKESPECIAL, NAME_SERIALIZED_LAMBDA, NAME_CTOR,
421                 DESCR_CTOR_SERIALIZED_LAMBDA, false);
422         mv.visitInsn(ARETURN);
423         // Maxs computed by ClassWriter.COMPUTE_MAXS, these arguments ignored
424         mv.visitMaxs(-1, -1);
425         mv.visitEnd();
426     }
427 
428     /**
429      * Generate a readObject/writeObject method that is hostile to serialization
430      */
431     private void generateSerializationHostileMethods() {
432         MethodVisitor mv = cw.visitMethod(ACC_PRIVATE + ACC_FINAL,
433                                           NAME_METHOD_WRITE_OBJECT, DESCR_METHOD_WRITE_OBJECT,
434                                           null, SER_HOSTILE_EXCEPTIONS);
435         mv.visitCode();
436         mv.visitTypeInsn(NEW, NAME_NOT_SERIALIZABLE_EXCEPTION);
437         mv.visitInsn(DUP);
438         mv.visitLdcInsn(&quot;Non-serializable lambda&quot;);
439         mv.visitMethodInsn(INVOKESPECIAL, NAME_NOT_SERIALIZABLE_EXCEPTION, NAME_CTOR,
440                            DESCR_CTOR_NOT_SERIALIZABLE_EXCEPTION, false);
441         mv.visitInsn(ATHROW);
442         mv.visitMaxs(-1, -1);
443         mv.visitEnd();
444 
445         mv = cw.visitMethod(ACC_PRIVATE + ACC_FINAL,
446                             NAME_METHOD_READ_OBJECT, DESCR_METHOD_READ_OBJECT,
447                             null, SER_HOSTILE_EXCEPTIONS);
448         mv.visitCode();
449         mv.visitTypeInsn(NEW, NAME_NOT_SERIALIZABLE_EXCEPTION);
450         mv.visitInsn(DUP);
451         mv.visitLdcInsn(&quot;Non-serializable lambda&quot;);
452         mv.visitMethodInsn(INVOKESPECIAL, NAME_NOT_SERIALIZABLE_EXCEPTION, NAME_CTOR,
453                            DESCR_CTOR_NOT_SERIALIZABLE_EXCEPTION, false);
454         mv.visitInsn(ATHROW);
455         mv.visitMaxs(-1, -1);
456         mv.visitEnd();
457     }
458 
459     /**
460      * This class generates a method body which calls the lambda implementation
461      * method, converting arguments, as needed.
462      */
463     private class ForwardingMethodGenerator extends TypeConvertingMethodAdapter {
464 
465         ForwardingMethodGenerator(MethodVisitor mv) {
466             super(mv);
467         }
468 
469         void generate(MethodType methodType) {
470             visitCode();
471 
472             if (implKind == MethodHandleInfo.REF_newInvokeSpecial) {
473                 visitTypeInsn(NEW, implMethodClassName);
474                 visitInsn(DUP);
475             }
476             if (useImplMethodHandle) {
477                 visitVarInsn(ALOAD, 0);
478                 visitFieldInsn(GETSTATIC, lambdaClassName, NAME_FIELD_IMPL_METHOD, DESCR_METHOD_HANDLE);
479             }
480             for (int i = 0; i &lt; argNames.length; i++) {
481                 visitVarInsn(ALOAD, 0);
482                 visitFieldInsn(GETFIELD, lambdaClassName, argNames[i], argDescs[i]);
483             }
484 
485             convertArgumentTypes(methodType);
486 
487             if (useImplMethodHandle) {
488                 MethodType mtype = implInfo.getMethodType().insertParameterTypes(0, implClass);
489                 visitMethodInsn(INVOKEVIRTUAL, &quot;java/lang/invoke/MethodHandle&quot;,
490                                 &quot;invokeExact&quot;, mtype.descriptorString(), false);
491             } else {
492                 // Invoke the method we want to forward to
493                 visitMethodInsn(invocationOpcode(), implMethodClassName,
494                                 implMethodName, implMethodDesc,
495                                 implClass.isInterface());
496             }
497             // Convert the return value (if any) and return it
498             // Note: if adapting from non-void to void, the &#39;return&#39;
499             // instruction will pop the unneeded result
500             Class&lt;?&gt; implReturnClass = implMethodType.returnType();
501             Class&lt;?&gt; samReturnClass = methodType.returnType();
502             convertType(implReturnClass, samReturnClass, samReturnClass);
503             visitInsn(getReturnOpcode(samReturnClass));
504             // Maxs computed by ClassWriter.COMPUTE_MAXS,these arguments ignored
505             visitMaxs(-1, -1);
506             visitEnd();
507         }
508 
509         private void convertArgumentTypes(MethodType samType) {
510             int lvIndex = 0;
511             int samParametersLength = samType.parameterCount();
512             int captureArity = invokedType.parameterCount();
513             for (int i = 0; i &lt; samParametersLength; i++) {
514                 Class&lt;?&gt; argType = samType.parameterType(i);
515                 visitVarInsn(getLoadOpcode(argType), lvIndex + 1);
516                 lvIndex += getParameterSize(argType);
517                 convertType(argType, implMethodType.parameterType(captureArity + i), instantiatedMethodType.parameterType(i));
518             }
519         }
520 
521         private int invocationOpcode() throws InternalError {
522             switch (implKind) {
523                 case MethodHandleInfo.REF_invokeStatic:
524                     return INVOKESTATIC;
525                 case MethodHandleInfo.REF_newInvokeSpecial:
526                     return INVOKESPECIAL;
527                  case MethodHandleInfo.REF_invokeVirtual:
528                     return INVOKEVIRTUAL;
529                 case MethodHandleInfo.REF_invokeInterface:
530                     return INVOKEINTERFACE;
531                 case MethodHandleInfo.REF_invokeSpecial:
532                     return INVOKESPECIAL;
533                 default:
534                     throw new InternalError(&quot;Unexpected invocation kind: &quot; + implKind);
535             }
536         }
537     }
538 
539     static int getParameterSize(Class&lt;?&gt; c) {
540         if (c == Void.TYPE) {
541             return 0;
542         } else if (c == Long.TYPE || c == Double.TYPE) {
543             return 2;
544         }
545         return 1;
546     }
547 
548     static int getLoadOpcode(Class&lt;?&gt; c) {
549         if(c == Void.TYPE) {
550             throw new InternalError(&quot;Unexpected void type of load opcode&quot;);
551         }
552         return ILOAD + getOpcodeOffset(c);
553     }
554 
555     static int getReturnOpcode(Class&lt;?&gt; c) {
556         if(c == Void.TYPE) {
557             return RETURN;
558         }
559         return IRETURN + getOpcodeOffset(c);
560     }
561 
562     private static int getOpcodeOffset(Class&lt;?&gt; c) {
563         if (c.isPrimitive()) {
564             if (c == Long.TYPE) {
565                 return 1;
566             } else if (c == Float.TYPE) {
567                 return 2;
568             } else if (c == Double.TYPE) {
569                 return 3;
570             }
571             return 0;
572         } else {
573             return 4;
574         }
575     }
576 
577 }
    </pre>
  </body>
</html>
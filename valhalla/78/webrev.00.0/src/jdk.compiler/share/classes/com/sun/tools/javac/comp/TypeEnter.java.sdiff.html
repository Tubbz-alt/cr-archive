<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Attr.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../parser/JavacParser.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TypeEnter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 702             ListBuffer&lt;Type&gt; interfaces = new ListBuffer&lt;&gt;();
 703             ListBuffer&lt;Type&gt; all_interfaces = null; // lazy init
 704             List&lt;JCExpression&gt; interfaceTrees = tree.implementing;
 705             for (JCExpression iface : interfaceTrees) {
 706                 iface = clearTypeParams(iface);
 707                 Type it = attr.attribBase(iface, baseEnv, false, true, true);
 708                 if (it.hasTag(CLASS)) {
 709                     interfaces.append(it);
 710                     if (all_interfaces != null) all_interfaces.append(it);
 711                 } else {
 712                     if (all_interfaces == null)
 713                         all_interfaces = new ListBuffer&lt;Type&gt;().appendList(interfaces);
 714                     all_interfaces.append(modelMissingTypes(baseEnv, it, iface, true));
 715                 }
 716             }
 717 
 718             // Determine permits.
 719             ListBuffer&lt;Symbol&gt; permittedSubtypeSymbols = new ListBuffer&lt;&gt;();
 720             List&lt;JCExpression&gt; permittedTrees = tree.permitting;
 721             for (JCExpression permitted : permittedTrees) {
<span class="line-removed"> 722                 permitted = clearTypeParams(permitted);</span>
 723                 Type pt = attr.attribBase(permitted, baseEnv, false, false, false);
 724                 permittedSubtypeSymbols.append(pt.tsym);
 725             }
 726 
 727             if ((sym.flags_field &amp; ANNOTATION) != 0) {
 728                 ct.interfaces_field = List.of(syms.annotationType);
 729                 ct.all_interfaces_field = ct.interfaces_field;
 730             }  else {
 731                 ct.interfaces_field = interfaces.toList();
 732                 ct.all_interfaces_field = (all_interfaces == null)
 733                         ? ct.interfaces_field : all_interfaces.toList();
 734             }
 735             if (ct.isValue()) {
 736                 ClassSymbol cSym = (ClassSymbol) ct.tsym;
 737                 if (cSym.projection != null) {
 738                     ClassType projectedType = (ClassType) cSym.projection.type;
 739                     projectedType.supertype_field = ct.supertype_field;
 740                     projectedType.interfaces_field = ct.interfaces_field;
 741                     projectedType.all_interfaces_field = ct.all_interfaces_field;
 742                 }
 743             }
 744 
<span class="line-modified"> 745             sym.permitted = permittedSubtypeSymbols.toList();</span>






 746             sym.isPermittedExplicit = !permittedSubtypeSymbols.isEmpty();
 747         }
 748             //where:
 749             protected JCExpression clearTypeParams(JCExpression superType) {
 750                 return superType;
 751             }
 752     }
 753 
 754     private final class HierarchyPhase extends AbstractHeaderPhase implements Completer {
 755 
 756         public HierarchyPhase() {
 757             super(CompletionCause.HIERARCHY_PHASE, new PermitsPhase());
 758         }
 759 
 760         @Override
 761         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 762             //The ClassSymbols in the envs list may not be in the dependency order.
 763             //To get proper results, for every class or interface C, the supertypes of
 764             //C must be processed by the HierarchyPhase phase before C.
 765             //To achieve that, the HierarchyPhase is registered as the Completer for
</pre>
</td>
<td>
<hr />
<pre>
 702             ListBuffer&lt;Type&gt; interfaces = new ListBuffer&lt;&gt;();
 703             ListBuffer&lt;Type&gt; all_interfaces = null; // lazy init
 704             List&lt;JCExpression&gt; interfaceTrees = tree.implementing;
 705             for (JCExpression iface : interfaceTrees) {
 706                 iface = clearTypeParams(iface);
 707                 Type it = attr.attribBase(iface, baseEnv, false, true, true);
 708                 if (it.hasTag(CLASS)) {
 709                     interfaces.append(it);
 710                     if (all_interfaces != null) all_interfaces.append(it);
 711                 } else {
 712                     if (all_interfaces == null)
 713                         all_interfaces = new ListBuffer&lt;Type&gt;().appendList(interfaces);
 714                     all_interfaces.append(modelMissingTypes(baseEnv, it, iface, true));
 715                 }
 716             }
 717 
 718             // Determine permits.
 719             ListBuffer&lt;Symbol&gt; permittedSubtypeSymbols = new ListBuffer&lt;&gt;();
 720             List&lt;JCExpression&gt; permittedTrees = tree.permitting;
 721             for (JCExpression permitted : permittedTrees) {

 722                 Type pt = attr.attribBase(permitted, baseEnv, false, false, false);
 723                 permittedSubtypeSymbols.append(pt.tsym);
 724             }
 725 
 726             if ((sym.flags_field &amp; ANNOTATION) != 0) {
 727                 ct.interfaces_field = List.of(syms.annotationType);
 728                 ct.all_interfaces_field = ct.interfaces_field;
 729             }  else {
 730                 ct.interfaces_field = interfaces.toList();
 731                 ct.all_interfaces_field = (all_interfaces == null)
 732                         ? ct.interfaces_field : all_interfaces.toList();
 733             }
 734             if (ct.isValue()) {
 735                 ClassSymbol cSym = (ClassSymbol) ct.tsym;
 736                 if (cSym.projection != null) {
 737                     ClassType projectedType = (ClassType) cSym.projection.type;
 738                     projectedType.supertype_field = ct.supertype_field;
 739                     projectedType.interfaces_field = ct.interfaces_field;
 740                     projectedType.all_interfaces_field = ct.all_interfaces_field;
 741                 }
 742             }
 743 
<span class="line-modified"> 744             /* it could be that there are already some symbols in the permitted list, for the case</span>
<span class="line-added"> 745              * where there are subtypes in the same compilation unit but the permits list is empty</span>
<span class="line-added"> 746              * so don&#39;t overwrite the permitted list if it is not empty</span>
<span class="line-added"> 747              */</span>
<span class="line-added"> 748             if (!permittedSubtypeSymbols.isEmpty()) {</span>
<span class="line-added"> 749                 sym.permitted = permittedSubtypeSymbols.toList();</span>
<span class="line-added"> 750             }</span>
 751             sym.isPermittedExplicit = !permittedSubtypeSymbols.isEmpty();
 752         }
 753             //where:
 754             protected JCExpression clearTypeParams(JCExpression superType) {
 755                 return superType;
 756             }
 757     }
 758 
 759     private final class HierarchyPhase extends AbstractHeaderPhase implements Completer {
 760 
 761         public HierarchyPhase() {
 762             super(CompletionCause.HIERARCHY_PHASE, new PermitsPhase());
 763         }
 764 
 765         @Override
 766         protected void doCompleteEnvs(List&lt;Env&lt;AttrContext&gt;&gt; envs) {
 767             //The ClassSymbols in the envs list may not be in the dependency order.
 768             //To get proper results, for every class or interface C, the supertypes of
 769             //C must be processed by the HierarchyPhase phase before C.
 770             //To achieve that, the HierarchyPhase is registered as the Completer for
</pre>
</td>
</tr>
</table>
<center><a href="Attr.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../parser/JavacParser.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/code/Types.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.code;
  27 
  28 import java.lang.ref.SoftReference;
  29 import java.util.HashSet;
  30 import java.util.HashMap;
  31 import java.util.Locale;
  32 import java.util.Map;
  33 import java.util.Optional;
  34 import java.util.Set;
  35 import java.util.WeakHashMap;
  36 import java.util.function.BiPredicate;
  37 import java.util.function.Function;
  38 import java.util.stream.Collector;
  39 
  40 import javax.tools.JavaFileObject;
  41 
  42 import com.sun.tools.javac.code.Attribute.RetentionPolicy;
  43 import com.sun.tools.javac.code.Lint.LintCategory;
  44 import com.sun.tools.javac.code.Source.Feature;
  45 import com.sun.tools.javac.code.Type.UndetVar.InferenceBound;
  46 import com.sun.tools.javac.code.TypeMetadata.Entry.Kind;
  47 import com.sun.tools.javac.comp.AttrContext;
  48 import com.sun.tools.javac.comp.Check;
  49 import com.sun.tools.javac.comp.Enter;
  50 import com.sun.tools.javac.comp.Env;
  51 import com.sun.tools.javac.comp.LambdaToMethod;
  52 import com.sun.tools.javac.jvm.ClassFile;
  53 import com.sun.tools.javac.jvm.Target;
  54 import com.sun.tools.javac.util.*;
  55 
  56 import static com.sun.tools.javac.code.BoundKind.*;
  57 import static com.sun.tools.javac.code.Flags.*;
  58 import static com.sun.tools.javac.code.Kinds.Kind.*;
  59 import static com.sun.tools.javac.code.Scope.*;
  60 import static com.sun.tools.javac.code.Scope.LookupKind.NON_RECURSIVE;
  61 import static com.sun.tools.javac.code.Symbol.*;
  62 import static com.sun.tools.javac.code.Type.*;
  63 import static com.sun.tools.javac.code.TypeTag.*;
  64 import static com.sun.tools.javac.jvm.ClassFile.externalize;
  65 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  66 
  67 /**
  68  * Utility class containing various operations on types.
  69  *
  70  * &lt;p&gt;Unless other names are more illustrative, the following naming
  71  * conventions should be observed in this file:
  72  *
  73  * &lt;dl&gt;
  74  * &lt;dt&gt;t&lt;/dt&gt;
  75  * &lt;dd&gt;If the first argument to an operation is a type, it should be named t.&lt;/dd&gt;
  76  * &lt;dt&gt;s&lt;/dt&gt;
  77  * &lt;dd&gt;Similarly, if the second argument to an operation is a type, it should be named s.&lt;/dd&gt;
  78  * &lt;dt&gt;ts&lt;/dt&gt;
  79  * &lt;dd&gt;If an operations takes a list of types, the first should be named ts.&lt;/dd&gt;
  80  * &lt;dt&gt;ss&lt;/dt&gt;
  81  * &lt;dd&gt;A second list of types should be named ss.&lt;/dd&gt;
  82  * &lt;/dl&gt;
  83  *
  84  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  85  * If you write code that depends on this, you do so at your own risk.
  86  * This code and its internal interfaces are subject to change or
  87  * deletion without notice.&lt;/b&gt;
  88  */
  89 public class Types {
  90     protected static final Context.Key&lt;Types&gt; typesKey = new Context.Key&lt;&gt;();
  91 
  92     final Symtab syms;
  93     final JavacMessages messages;
  94     final Names names;
  95     final boolean allowDefaultMethods;
  96     final boolean mapCapturesToBounds;
  97     final boolean allowValueBasedClasses;
  98     final boolean injectTopInterfaceTypes;
  99     final Check chk;
 100     final Enter enter;
 101     JCDiagnostic.Factory diags;
 102     List&lt;Warner&gt; warnStack = List.nil();
 103     final Name capturedName;
 104 
 105     public final Warner noWarnings;
 106 
 107     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Instantiating&quot;&gt;
 108     public static Types instance(Context context) {
 109         Types instance = context.get(typesKey);
 110         if (instance == null)
 111             instance = new Types(context);
 112         return instance;
 113     }
 114 
 115     protected Types(Context context) {
 116         context.put(typesKey, this);
 117         syms = Symtab.instance(context);
 118         names = Names.instance(context);
 119         Source source = Source.instance(context);
 120         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 121         mapCapturesToBounds = Feature.MAP_CAPTURES_TO_BOUNDS.allowedInSource(source);
 122         chk = Check.instance(context);
 123         enter = Enter.instance(context);
 124         capturedName = names.fromString(&quot;&lt;captured wildcard&gt;&quot;);
 125         messages = JavacMessages.instance(context);
 126         diags = JCDiagnostic.Factory.instance(context);
 127         noWarnings = new Warner(null);
 128         Options options = Options.instance(context);
 129         allowValueBasedClasses = options.isSet(&quot;allowValueBasedClasses&quot;);
 130         injectTopInterfaceTypes = Options.instance(context).isUnset(&quot;noTopInterfaceInjection&quot;) &amp;&amp;
 131                 Feature.INLINE_TYPES.allowedInSource(source) &amp;&amp;
 132                 Target.instance(context).hasTopInterfaces();
 133     }
 134     // &lt;/editor-fold&gt;
 135 
 136     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;bounds&quot;&gt;
 137     /**
 138      * Get a wildcard&#39;s upper bound, returning non-wildcards unchanged.
 139      * @param t a type argument, either a wildcard or a type
 140      */
 141     public Type wildUpperBound(Type t) {
 142         if (t.hasTag(WILDCARD)) {
 143             WildcardType w = (WildcardType) t;
 144             if (w.isSuperBound())
 145                 return w.bound == null ? syms.objectType : w.bound.getUpperBound();
 146             else
 147                 return wildUpperBound(w.type);
 148         }
 149         else return t;
 150     }
 151 
 152     /**
 153      * Get a capture variable&#39;s upper bound, returning other types unchanged.
 154      * @param t a type
 155      */
 156     public Type cvarUpperBound(Type t) {
 157         if (t.hasTag(TYPEVAR)) {
 158             TypeVar v = (TypeVar) t;
 159             return v.isCaptured() ? cvarUpperBound(v.getUpperBound()) : v;
 160         }
 161         else return t;
 162     }
 163 
 164     /**
 165      * Get a wildcard&#39;s lower bound, returning non-wildcards unchanged.
 166      * @param t a type argument, either a wildcard or a type
 167      */
 168     public Type wildLowerBound(Type t) {
 169         if (t.hasTag(WILDCARD)) {
 170             WildcardType w = (WildcardType) t;
 171             return w.isExtendsBound() ? syms.botType : wildLowerBound(w.type);
 172         }
 173         else return t;
 174     }
 175 
 176     /**
 177      * Get a capture variable&#39;s lower bound, returning other types unchanged.
 178      * @param t a type
 179      */
 180     public Type cvarLowerBound(Type t) {
 181         if (t.hasTag(TYPEVAR) &amp;&amp; ((TypeVar) t).isCaptured()) {
 182             return cvarLowerBound(t.getLowerBound());
 183         }
 184         else return t;
 185     }
 186 
 187     /**
 188      * Recursively skip type-variables until a class/array type is found; capture conversion is then
 189      * (optionally) applied to the resulting type. This is useful for i.e. computing a site that is
 190      * suitable for a method lookup.
 191      */
 192     public Type skipTypeVars(Type site, boolean capture) {
 193         while (site.hasTag(TYPEVAR)) {
 194             site = site.getUpperBound();
 195         }
 196         return capture ? capture(site) : site;
 197     }
 198     // &lt;/editor-fold&gt;
 199 
 200     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;projections&quot;&gt;
 201 
 202     /**
 203      * A projection kind. See {@link TypeProjection}
 204      */
 205     enum ProjectionKind {
 206         UPWARDS() {
 207             @Override
 208             ProjectionKind complement() {
 209                 return DOWNWARDS;
 210             }
 211         },
 212         DOWNWARDS() {
 213             @Override
 214             ProjectionKind complement() {
 215                 return UPWARDS;
 216             }
 217         };
 218 
 219         abstract ProjectionKind complement();
 220     }
 221 
 222     /**
 223      * This visitor performs upwards and downwards projections on types.
 224      *
 225      * A projection is defined as a function that takes a type T, a set of type variables V and that
 226      * produces another type S.
 227      *
 228      * An upwards projection maps a type T into a type S such that (i) T has no variables in V,
 229      * and (ii) S is an upper bound of T.
 230      *
 231      * A downwards projection maps a type T into a type S such that (i) T has no variables in V,
 232      * and (ii) S is a lower bound of T.
 233      *
 234      * Note that projections are only allowed to touch variables in V. Therefore, it is possible for
 235      * a projection to leave its input type unchanged if it does not contain any variables in V.
 236      *
 237      * Moreover, note that while an upwards projection is always defined (every type as an upper bound),
 238      * a downwards projection is not always defined.
 239      *
 240      * Examples:
 241      *
 242      * {@code upwards(List&lt;#CAP1&gt;, [#CAP1]) = List&lt;? extends String&gt;, where #CAP1 &lt;: String }
 243      * {@code downwards(List&lt;#CAP2&gt;, [#CAP2]) = List&lt;? super String&gt;, where #CAP2 :&gt; String }
 244      * {@code upwards(List&lt;#CAP1&gt;, [#CAP2]) = List&lt;#CAP1&gt; }
 245      * {@code downwards(List&lt;#CAP1&gt;, [#CAP1]) = not defined }
 246      */
 247     class TypeProjection extends TypeMapping&lt;ProjectionKind&gt; {
 248 
 249         List&lt;Type&gt; vars;
 250         Set&lt;Type&gt; seen = new HashSet&lt;&gt;();
 251 
 252         public TypeProjection(List&lt;Type&gt; vars) {
 253             this.vars = vars;
 254         }
 255 
 256         @Override
 257         public Type visitClassType(ClassType t, ProjectionKind pkind) {
 258             if (t.isCompound()) {
 259                 List&lt;Type&gt; components = directSupertypes(t);
 260                 List&lt;Type&gt; components1 = components.map(c -&gt; c.map(this, pkind));
 261                 if (components == components1) return t;
 262                 else return makeIntersectionType(components1);
 263             } else {
 264                 Type outer = t.getEnclosingType();
 265                 Type outer1 = visit(outer, pkind);
 266                 List&lt;Type&gt; typarams = t.getTypeArguments();
 267                 List&lt;Type&gt; formals = t.tsym.type.getTypeArguments();
 268                 ListBuffer&lt;Type&gt; typarams1 = new ListBuffer&lt;&gt;();
 269                 boolean changed = false;
 270                 for (Type actual : typarams) {
 271                     Type t2 = mapTypeArgument(t, formals.head.getUpperBound(), actual, pkind);
 272                     if (t2.hasTag(BOT)) {
 273                         //not defined
 274                         return syms.botType;
 275                     }
 276                     typarams1.add(t2);
 277                     changed |= actual != t2;
 278                     formals = formals.tail;
 279                 }
 280                 if (outer1 == outer &amp;&amp; !changed) return t;
 281                 else return new ClassType(outer1, typarams1.toList(), t.tsym, t.getMetadata()) {
 282                     @Override
 283                     protected boolean needsStripping() {
 284                         return true;
 285                     }
 286                 };
 287             }
 288         }
 289 
 290         @Override
 291         public Type visitArrayType(ArrayType t, ProjectionKind s) {
 292             Type elemtype = t.elemtype;
 293             Type elemtype1 = visit(elemtype, s);
 294             if (elemtype1 == elemtype) {
 295                 return t;
 296             } else if (elemtype1.hasTag(BOT)) {
 297                 //undefined
 298                 return syms.botType;
 299             } else {
 300                 return new ArrayType(elemtype1, t.tsym, t.metadata) {
 301                     @Override
 302                     protected boolean needsStripping() {
 303                         return true;
 304                     }
 305                 };
 306             }
 307         }
 308 
 309         @Override
 310         public Type visitTypeVar(TypeVar t, ProjectionKind pkind) {
 311             if (vars.contains(t)) {
 312                 if (seen.add(t)) {
 313                     try {
 314                         final Type bound;
 315                         switch (pkind) {
 316                             case UPWARDS:
 317                                 bound = t.getUpperBound();
 318                                 break;
 319                             case DOWNWARDS:
 320                                 bound = (t.getLowerBound() == null) ?
 321                                         syms.botType :
 322                                         t.getLowerBound();
 323                                 break;
 324                             default:
 325                                 Assert.error();
 326                                 return null;
 327                         }
 328                         return bound.map(this, pkind);
 329                     } finally {
 330                         seen.remove(t);
 331                     }
 332                 } else {
 333                     //cycle
 334                     return pkind == ProjectionKind.UPWARDS ?
 335                             syms.objectType : syms.botType;
 336                 }
 337             } else {
 338                 return t;
 339             }
 340         }
 341 
 342         private Type mapTypeArgument(Type site, Type declaredBound, Type t, ProjectionKind pkind) {
 343             return t.containsAny(vars) ?
 344                     t.map(new TypeArgumentProjection(site, declaredBound), pkind) :
 345                     t;
 346         }
 347 
 348         class TypeArgumentProjection extends TypeMapping&lt;ProjectionKind&gt; {
 349 
 350             Type site;
 351             Type declaredBound;
 352 
 353             TypeArgumentProjection(Type site, Type declaredBound) {
 354                 this.site = site;
 355                 this.declaredBound = declaredBound;
 356             }
 357 
 358             @Override
 359             public Type visitType(Type t, ProjectionKind pkind) {
 360                 //type argument is some type containing restricted vars
 361                 if (pkind == ProjectionKind.DOWNWARDS) {
 362                     //not defined
 363                     return syms.botType;
 364                 }
 365                 Type upper = t.map(TypeProjection.this, ProjectionKind.UPWARDS);
 366                 Type lower = t.map(TypeProjection.this, ProjectionKind.DOWNWARDS);
 367                 List&lt;Type&gt; formals = site.tsym.type.getTypeArguments();
 368                 BoundKind bk;
 369                 Type bound;
 370                 if (!isSameType(upper, syms.objectType) &amp;&amp;
 371                         (declaredBound.containsAny(formals) ||
 372                          !isSubtype(declaredBound, upper))) {
 373                     bound = upper;
 374                     bk = EXTENDS;
 375                 } else if (!lower.hasTag(BOT)) {
 376                     bound = lower;
 377                     bk = SUPER;
 378                 } else {
 379                     bound = syms.objectType;
 380                     bk = UNBOUND;
 381                 }
 382                 return makeWildcard(bound, bk);
 383             }
 384 
 385             @Override
 386             public Type visitWildcardType(WildcardType wt, ProjectionKind pkind) {
 387                 //type argument is some wildcard whose bound contains restricted vars
 388                 Type bound = syms.botType;
 389                 BoundKind bk = wt.kind;
 390                 switch (wt.kind) {
 391                     case EXTENDS:
 392                         bound = wt.type.map(TypeProjection.this, pkind);
 393                         if (bound.hasTag(BOT)) {
 394                             return syms.botType;
 395                         }
 396                         break;
 397                     case SUPER:
 398                         bound = wt.type.map(TypeProjection.this, pkind.complement());
 399                         if (bound.hasTag(BOT)) {
 400                             bound = syms.objectType;
 401                             bk = UNBOUND;
 402                         }
 403                         break;
 404                 }
 405                 return makeWildcard(bound, bk);
 406             }
 407 
 408             private Type makeWildcard(Type bound, BoundKind bk) {
 409                 return new WildcardType(bound, bk, syms.boundClass) {
 410                     @Override
 411                     protected boolean needsStripping() {
 412                         return true;
 413                     }
 414                 };
 415             }
 416         }
 417     }
 418 
 419     /**
 420      * Computes an upward projection of given type, and vars. See {@link TypeProjection}.
 421      *
 422      * @param t the type to be projected
 423      * @param vars the set of type variables to be mapped
 424      * @return the type obtained as result of the projection
 425      */
 426     public Type upward(Type t, List&lt;Type&gt; vars) {
 427         return t.map(new TypeProjection(vars), ProjectionKind.UPWARDS);
 428     }
 429 
 430     /**
 431      * Computes the set of captured variables mentioned in a given type. See {@link CaptureScanner}.
 432      * This routine is typically used to computed the input set of variables to be used during
 433      * an upwards projection (see {@link Types#upward(Type, List)}).
 434      *
 435      * @param t the type where occurrences of captured variables have to be found
 436      * @return the set of captured variables found in t
 437      */
 438     public List&lt;Type&gt; captures(Type t) {
 439         CaptureScanner cs = new CaptureScanner();
 440         Set&lt;Type&gt; captures = new HashSet&lt;&gt;();
 441         cs.visit(t, captures);
 442         return List.from(captures);
 443     }
 444 
 445     /**
 446      * This visitor scans a type recursively looking for occurrences of captured type variables.
 447      */
 448     class CaptureScanner extends SimpleVisitor&lt;Void, Set&lt;Type&gt;&gt; {
 449 
 450         @Override
 451         public Void visitType(Type t, Set&lt;Type&gt; types) {
 452             return null;
 453         }
 454 
 455         @Override
 456         public Void visitClassType(ClassType t, Set&lt;Type&gt; seen) {
 457             if (t.isCompound()) {
 458                 directSupertypes(t).forEach(s -&gt; visit(s, seen));
 459             } else {
 460                 t.allparams().forEach(ta -&gt; visit(ta, seen));
 461             }
 462             return null;
 463         }
 464 
 465         @Override
 466         public Void visitArrayType(ArrayType t, Set&lt;Type&gt; seen) {
 467             return visit(t.elemtype, seen);
 468         }
 469 
 470         @Override
 471         public Void visitWildcardType(WildcardType t, Set&lt;Type&gt; seen) {
 472             visit(t.type, seen);
 473             return null;
 474         }
 475 
 476         @Override
 477         public Void visitTypeVar(TypeVar t, Set&lt;Type&gt; seen) {
 478             if ((t.tsym.flags() &amp; Flags.SYNTHETIC) != 0 &amp;&amp; seen.add(t)) {
 479                 visit(t.getUpperBound(), seen);
 480             }
 481             return null;
 482         }
 483 
 484         @Override
 485         public Void visitCapturedType(CapturedType t, Set&lt;Type&gt; seen) {
 486             if (seen.add(t)) {
 487                 visit(t.getUpperBound(), seen);
 488                 visit(t.getLowerBound(), seen);
 489             }
 490             return null;
 491         }
 492     }
 493 
 494     // &lt;/editor-fold&gt;
 495 
 496     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isUnbounded&quot;&gt;
 497     /**
 498      * Checks that all the arguments to a class are unbounded
 499      * wildcards or something else that doesn&#39;t make any restrictions
 500      * on the arguments. If a class isUnbounded, a raw super- or
 501      * subclass can be cast to it without a warning.
 502      * @param t a type
 503      * @return true iff the given type is unbounded or raw
 504      */
 505     public boolean isUnbounded(Type t) {
 506         return isUnbounded.visit(t);
 507     }
 508     // where
 509         private final UnaryVisitor&lt;Boolean&gt; isUnbounded = new UnaryVisitor&lt;Boolean&gt;() {
 510 
 511             public Boolean visitType(Type t, Void ignored) {
 512                 return true;
 513             }
 514 
 515             @Override
 516             public Boolean visitClassType(ClassType t, Void ignored) {
 517                 List&lt;Type&gt; parms = t.tsym.type.allparams();
 518                 List&lt;Type&gt; args = t.allparams();
 519                 while (parms.nonEmpty()) {
 520                     WildcardType unb = new WildcardType(syms.objectType,
 521                                                         BoundKind.UNBOUND,
 522                                                         syms.boundClass,
 523                                                         (TypeVar)parms.head);
 524                     if (!containsType(args.head, unb))
 525                         return false;
 526                     parms = parms.tail;
 527                     args = args.tail;
 528                 }
 529                 return true;
 530             }
 531         };
 532     // &lt;/editor-fold&gt;
 533 
 534     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;asSub&quot;&gt;
 535     /**
 536      * Return the least specific subtype of t that starts with symbol
 537      * sym.  If none exists, return null.  The least specific subtype
 538      * is determined as follows:
 539      *
 540      * &lt;p&gt;If there is exactly one parameterized instance of sym that is a
 541      * subtype of t, that parameterized instance is returned.&lt;br&gt;
 542      * Otherwise, if the plain type or raw type `sym&#39; is a subtype of
 543      * type t, the type `sym&#39; itself is returned.  Otherwise, null is
 544      * returned.
 545      */
 546     public Type asSub(Type t, Symbol sym) {
 547         return asSub.visit(t, sym);
 548     }
 549     // where
 550         private final SimpleVisitor&lt;Type,Symbol&gt; asSub = new SimpleVisitor&lt;Type,Symbol&gt;() {
 551 
 552             public Type visitType(Type t, Symbol sym) {
 553                 return null;
 554             }
 555 
 556             @Override
 557             public Type visitClassType(ClassType t, Symbol sym) {
 558                 if (t.tsym == sym)
 559                     return t;
 560                 Type base = asSuper(sym.type, t.tsym);
 561                 if (base == null)
 562                     return null;
 563                 ListBuffer&lt;Type&gt; from = new ListBuffer&lt;&gt;();
 564                 ListBuffer&lt;Type&gt; to = new ListBuffer&lt;&gt;();
 565                 try {
 566                     adapt(base, t, from, to);
 567                 } catch (AdaptFailure ex) {
 568                     return null;
 569                 }
 570                 Type res = subst(sym.type, from.toList(), to.toList());
 571                 if (!isSubtype(res, t))
 572                     return null;
 573                 ListBuffer&lt;Type&gt; openVars = new ListBuffer&lt;&gt;();
 574                 for (List&lt;Type&gt; l = sym.type.allparams();
 575                      l.nonEmpty(); l = l.tail)
 576                     if (res.contains(l.head) &amp;&amp; !t.contains(l.head))
 577                         openVars.append(l.head);
 578                 if (openVars.nonEmpty()) {
 579                     if (t.isRaw()) {
 580                         // The subtype of a raw type is raw
 581                         res = erasure(res);
 582                     } else {
 583                         // Unbound type arguments default to ?
 584                         List&lt;Type&gt; opens = openVars.toList();
 585                         ListBuffer&lt;Type&gt; qs = new ListBuffer&lt;&gt;();
 586                         for (List&lt;Type&gt; iter = opens; iter.nonEmpty(); iter = iter.tail) {
 587                             qs.append(new WildcardType(syms.objectType, BoundKind.UNBOUND,
 588                                                        syms.boundClass, (TypeVar) iter.head));
 589                         }
 590                         res = subst(res, opens, qs.toList());
 591                     }
 592                 }
 593                 return res;
 594             }
 595 
 596             @Override
 597             public Type visitErrorType(ErrorType t, Symbol sym) {
 598                 return t;
 599             }
 600         };
 601     // &lt;/editor-fold&gt;
 602 
 603     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isConvertible&quot;&gt;
 604     /**
 605      * Is t a subtype of or convertible via boxing/unboxing
 606      * conversion to s?
 607      */
 608     public boolean isConvertible(Type t, Type s, Warner warn) {
 609         if (t.hasTag(ERROR)) {
 610             return true;
 611         }
 612 
 613         boolean tValue = t.isValue();
 614         boolean sValue = s.isValue();
 615         if (tValue != sValue) {
 616             return tValue ?
 617                     isSubtype(t.referenceProjection(), s) :
 618                     (!t.hasTag(BOT) || isValueBased(s)) &amp;&amp; isSubtype(t, s.referenceProjection());
 619         }
 620 
 621         boolean tPrimitive = t.isPrimitive();
 622         boolean sPrimitive = s.isPrimitive();
 623         if (tPrimitive == sPrimitive) {
 624             return isSubtypeUnchecked(t, s, warn);
 625         }
 626         boolean tUndet = t.hasTag(UNDETVAR);
 627         boolean sUndet = s.hasTag(UNDETVAR);
 628 
 629         if (tUndet || sUndet) {
 630             return tUndet ?
 631                     isSubtype(t, boxedTypeOrType(s)) :
 632                     isSubtype(boxedTypeOrType(t), s);
 633         }
 634 
 635         return tPrimitive
 636             ? isSubtype(boxedClass(t).type, s)
 637             : isSubtype(unboxedType(t), s);
 638     }
 639 
 640     /**
 641      * Is t a subtype of or convertible via boxing/unboxing
 642      * conversions to s?
 643      */
 644     public boolean isConvertible(Type t, Type s) {
 645         return isConvertible(t, s, noWarnings);
 646     }
 647     // &lt;/editor-fold&gt;
 648 
 649     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;findSam&quot;&gt;
 650 
 651     /**
 652      * Exception used to report a function descriptor lookup failure. The exception
 653      * wraps a diagnostic that can be used to generate more details error
 654      * messages.
 655      */
 656     public static class FunctionDescriptorLookupError extends RuntimeException {
 657         private static final long serialVersionUID = 0;
 658 
 659         transient JCDiagnostic diagnostic;
 660 
 661         FunctionDescriptorLookupError() {
 662             this.diagnostic = null;
 663         }
 664 
 665         FunctionDescriptorLookupError setMessage(JCDiagnostic diag) {
 666             this.diagnostic = diag;
 667             return this;
 668         }
 669 
 670         public JCDiagnostic getDiagnostic() {
 671             return diagnostic;
 672         }
 673     }
 674 
 675     /**
 676      * A cache that keeps track of function descriptors associated with given
 677      * functional interfaces.
 678      */
 679     class DescriptorCache {
 680 
 681         private WeakHashMap&lt;TypeSymbol, Entry&gt; _map = new WeakHashMap&lt;&gt;();
 682 
 683         class FunctionDescriptor {
 684             Symbol descSym;
 685 
 686             FunctionDescriptor(Symbol descSym) {
 687                 this.descSym = descSym;
 688             }
 689 
 690             public Symbol getSymbol() {
 691                 return descSym;
 692             }
 693 
 694             public Type getType(Type site) {
 695                 site = removeWildcards(site);
 696                 if (site.isIntersection()) {
 697                     IntersectionClassType ict = (IntersectionClassType)site;
 698                     for (Type component : ict.getExplicitComponents()) {
 699                         if (!chk.checkValidGenericType(component)) {
 700                             //if the inferred functional interface type is not well-formed,
 701                             //or if it&#39;s not a subtype of the original target, issue an error
 702                             throw failure(diags.fragment(Fragments.NoSuitableFunctionalIntfInst(site)));
 703                         }
 704                     }
 705                 } else {
 706                     if (!chk.checkValidGenericType(site)) {
 707                         //if the inferred functional interface type is not well-formed,
 708                         //or if it&#39;s not a subtype of the original target, issue an error
 709                         throw failure(diags.fragment(Fragments.NoSuitableFunctionalIntfInst(site)));
 710                     }
 711                 }
 712                 return memberType(site, descSym);
 713             }
 714         }
 715 
 716         class Entry {
 717             final FunctionDescriptor cachedDescRes;
 718             final int prevMark;
 719 
 720             public Entry(FunctionDescriptor cachedDescRes,
 721                     int prevMark) {
 722                 this.cachedDescRes = cachedDescRes;
 723                 this.prevMark = prevMark;
 724             }
 725 
 726             boolean matches(int mark) {
 727                 return  this.prevMark == mark;
 728             }
 729         }
 730 
 731         FunctionDescriptor get(TypeSymbol origin) throws FunctionDescriptorLookupError {
 732             Entry e = _map.get(origin);
 733             CompoundScope members = membersClosure(origin.type, false);
 734             if (e == null ||
 735                     !e.matches(members.getMark())) {
 736                 FunctionDescriptor descRes = findDescriptorInternal(origin, members);
 737                 _map.put(origin, new Entry(descRes, members.getMark()));
 738                 return descRes;
 739             }
 740             else {
 741                 return e.cachedDescRes;
 742             }
 743         }
 744 
 745         /**
 746          * Compute the function descriptor associated with a given functional interface
 747          */
 748         public FunctionDescriptor findDescriptorInternal(TypeSymbol origin,
 749                 CompoundScope membersCache) throws FunctionDescriptorLookupError {
 750             if (!origin.isInterface() || (origin.flags() &amp; ANNOTATION) != 0) {
 751                 //t must be an interface
 752                 throw failure(&quot;not.a.functional.intf&quot;, origin);
 753             }
 754 
 755             final ListBuffer&lt;Symbol&gt; abstracts = new ListBuffer&lt;&gt;();
 756             for (Symbol sym : membersCache.getSymbols(new DescriptorFilter(origin))) {
 757                 Type mtype = memberType(origin.type, sym);
 758                 if (abstracts.isEmpty()) {
 759                     abstracts.append(sym);
 760                 } else if ((sym.name == abstracts.first().name &amp;&amp;
 761                         overrideEquivalent(mtype, memberType(origin.type, abstracts.first())))) {
 762                     if (!abstracts.stream().filter(msym -&gt; msym.owner.isSubClass(sym.enclClass(), Types.this))
 763                             .map(msym -&gt; memberType(origin.type, msym))
 764                             .anyMatch(abstractMType -&gt; isSubSignature(abstractMType, mtype))) {
 765                         abstracts.append(sym);
 766                     }
 767                 } else {
 768                     //the target method(s) should be the only abstract members of t
 769                     throw failure(&quot;not.a.functional.intf.1&quot;,  origin,
 770                             diags.fragment(Fragments.IncompatibleAbstracts(Kinds.kindName(origin), origin)));
 771                 }
 772             }
 773             if (abstracts.isEmpty()) {
 774                 //t must define a suitable non-generic method
 775                 throw failure(&quot;not.a.functional.intf.1&quot;, origin,
 776                             diags.fragment(Fragments.NoAbstracts(Kinds.kindName(origin), origin)));
 777             } else if (abstracts.size() == 1) {
 778                 return new FunctionDescriptor(abstracts.first());
 779             } else { // size &gt; 1
 780                 FunctionDescriptor descRes = mergeDescriptors(origin, abstracts.toList());
 781                 if (descRes == null) {
 782                     //we can get here if the functional interface is ill-formed
 783                     ListBuffer&lt;JCDiagnostic&gt; descriptors = new ListBuffer&lt;&gt;();
 784                     for (Symbol desc : abstracts) {
 785                         String key = desc.type.getThrownTypes().nonEmpty() ?
 786                                 &quot;descriptor.throws&quot; : &quot;descriptor&quot;;
 787                         descriptors.append(diags.fragment(key, desc.name,
 788                                 desc.type.getParameterTypes(),
 789                                 desc.type.getReturnType(),
 790                                 desc.type.getThrownTypes()));
 791                     }
 792                     JCDiagnostic msg =
 793                             diags.fragment(Fragments.IncompatibleDescsInFunctionalIntf(Kinds.kindName(origin),
 794                                                                                        origin));
 795                     JCDiagnostic.MultilineDiagnostic incompatibleDescriptors =
 796                             new JCDiagnostic.MultilineDiagnostic(msg, descriptors.toList());
 797                     throw failure(incompatibleDescriptors);
 798                 }
 799                 return descRes;
 800             }
 801         }
 802 
 803         /**
 804          * Compute a synthetic type for the target descriptor given a list
 805          * of override-equivalent methods in the functional interface type.
 806          * The resulting method type is a method type that is override-equivalent
 807          * and return-type substitutable with each method in the original list.
 808          */
 809         private FunctionDescriptor mergeDescriptors(TypeSymbol origin, List&lt;Symbol&gt; methodSyms) {
 810             return mergeAbstracts(methodSyms, origin.type, false)
 811                     .map(bestSoFar -&gt; new FunctionDescriptor(bestSoFar.baseSymbol()) {
 812                         @Override
 813                         public Type getType(Type origin) {
 814                             Type mt = memberType(origin, getSymbol());
 815                             return createMethodTypeWithThrown(mt, bestSoFar.type.getThrownTypes());
 816                         }
 817                     }).orElse(null);
 818         }
 819 
 820         FunctionDescriptorLookupError failure(String msg, Object... args) {
 821             return failure(diags.fragment(msg, args));
 822         }
 823 
 824         FunctionDescriptorLookupError failure(JCDiagnostic diag) {
 825             return new FunctionDescriptorLookupError().setMessage(diag);
 826         }
 827     }
 828 
 829     private DescriptorCache descCache = new DescriptorCache();
 830 
 831     /**
 832      * Find the method descriptor associated to this class symbol - if the
 833      * symbol &#39;origin&#39; is not a functional interface, an exception is thrown.
 834      */
 835     public Symbol findDescriptorSymbol(TypeSymbol origin) throws FunctionDescriptorLookupError {
 836         return descCache.get(origin).getSymbol();
 837     }
 838 
 839     /**
 840      * Find the type of the method descriptor associated to this class symbol -
 841      * if the symbol &#39;origin&#39; is not a functional interface, an exception is thrown.
 842      */
 843     public Type findDescriptorType(Type origin) throws FunctionDescriptorLookupError {
 844         return descCache.get(origin.tsym).getType(origin);
 845     }
 846 
 847     /**
 848      * Is given type a functional interface?
 849      */
 850     public boolean isFunctionalInterface(TypeSymbol tsym) {
 851         try {
 852             findDescriptorSymbol(tsym);
 853             return true;
 854         } catch (FunctionDescriptorLookupError ex) {
 855             return false;
 856         }
 857     }
 858 
 859     public boolean isFunctionalInterface(Type site) {
 860         try {
 861             findDescriptorType(site);
 862             return true;
 863         } catch (FunctionDescriptorLookupError ex) {
 864             return false;
 865         }
 866     }
 867 
 868     public Type removeWildcards(Type site) {
 869         if (site.getTypeArguments().stream().anyMatch(t -&gt; t.hasTag(WILDCARD))) {
 870             //compute non-wildcard parameterization - JLS 9.9
 871             List&lt;Type&gt; actuals = site.getTypeArguments();
 872             List&lt;Type&gt; formals = site.tsym.type.getTypeArguments();
 873             ListBuffer&lt;Type&gt; targs = new ListBuffer&lt;&gt;();
 874             for (Type formal : formals) {
 875                 Type actual = actuals.head;
 876                 Type bound = formal.getUpperBound();
 877                 if (actuals.head.hasTag(WILDCARD)) {
 878                     WildcardType wt = (WildcardType)actual;
 879                     //check that bound does not contain other formals
 880                     if (bound.containsAny(formals)) {
 881                         targs.add(wt.type);
 882                     } else {
 883                         //compute new type-argument based on declared bound and wildcard bound
 884                         switch (wt.kind) {
 885                             case UNBOUND:
 886                                 targs.add(bound);
 887                                 break;
 888                             case EXTENDS:
 889                                 targs.add(glb(bound, wt.type));
 890                                 break;
 891                             case SUPER:
 892                                 targs.add(wt.type);
 893                                 break;
 894                             default:
 895                                 Assert.error(&quot;Cannot get here!&quot;);
 896                         }
 897                     }
 898                 } else {
 899                     //not a wildcard - the new type argument remains unchanged
 900                     targs.add(actual);
 901                 }
 902                 actuals = actuals.tail;
 903             }
 904             return subst(site.tsym.type, formals, targs.toList());
 905         } else {
 906             return site;
 907         }
 908     }
 909 
 910     /**
 911      * Create a symbol for a class that implements a given functional interface
 912      * and overrides its functional descriptor. This routine is used for two
 913      * main purposes: (i) checking well-formedness of a functional interface;
 914      * (ii) perform functional interface bridge calculation.
 915      */
 916     public ClassSymbol makeFunctionalInterfaceClass(Env&lt;AttrContext&gt; env, Name name, Type target, long cflags) {
 917         if (target == null || target == syms.unknownType) {
 918             return null;
 919         }
 920         Symbol descSym = findDescriptorSymbol(target.tsym);
 921         Type descType = findDescriptorType(target);
 922         ClassSymbol csym = new ClassSymbol(cflags, name, env.enclClass.sym.outermostClass());
 923         csym.completer = Completer.NULL_COMPLETER;
 924         csym.members_field = WriteableScope.create(csym);
 925         MethodSymbol instDescSym = new MethodSymbol(descSym.flags(), descSym.name, descType, csym);
 926         csym.members_field.enter(instDescSym);
 927         Type.ClassType ctype = new Type.ClassType(Type.noType, List.nil(), csym);
 928         ctype.supertype_field = syms.objectType;
 929         ctype.interfaces_field = target.isIntersection() ?
 930                 directSupertypes(target) :
 931                 List.of(target);
 932         csym.type = ctype;
 933         csym.sourcefile = ((ClassSymbol)csym.owner).sourcefile;
 934         return csym;
 935     }
 936 
 937     /**
 938      * Find the minimal set of methods that are overridden by the functional
 939      * descriptor in &#39;origin&#39;. All returned methods are assumed to have different
 940      * erased signatures.
 941      */
 942     public List&lt;Symbol&gt; functionalInterfaceBridges(TypeSymbol origin) {
 943         Assert.check(isFunctionalInterface(origin));
 944         Symbol descSym = findDescriptorSymbol(origin);
 945         CompoundScope members = membersClosure(origin.type, false);
 946         ListBuffer&lt;Symbol&gt; overridden = new ListBuffer&lt;&gt;();
 947         outer: for (Symbol m2 : members.getSymbolsByName(descSym.name, bridgeFilter)) {
 948             if (m2 == descSym) continue;
 949             else if (descSym.overrides(m2, origin, Types.this, false)) {
 950                 for (Symbol m3 : overridden) {
 951                     if (isSameType(m3.erasure(Types.this), m2.erasure(Types.this)) ||
 952                             (m3.overrides(m2, origin, Types.this, false) &amp;&amp;
 953                             (pendingBridges((ClassSymbol)origin, m3.enclClass()) ||
 954                             (((MethodSymbol)m2).binaryImplementation((ClassSymbol)m3.owner, Types.this) != null)))) {
 955                         continue outer;
 956                     }
 957                 }
 958                 overridden.add(m2);
 959             }
 960         }
 961         return overridden.toList();
 962     }
 963     //where
 964         private Filter&lt;Symbol&gt; bridgeFilter = new Filter&lt;Symbol&gt;() {
 965             public boolean accepts(Symbol t) {
 966                 return t.kind == MTH &amp;&amp;
 967                         t.name != names.init &amp;&amp;
 968                         t.name != names.clinit &amp;&amp;
 969                         (t.flags() &amp; SYNTHETIC) == 0;
 970             }
 971         };
 972         private boolean pendingBridges(ClassSymbol origin, TypeSymbol s) {
 973             //a symbol will be completed from a classfile if (a) symbol has
 974             //an associated file object with CLASS kind and (b) the symbol has
 975             //not been entered
 976             if (origin.classfile != null &amp;&amp;
 977                     origin.classfile.getKind() == JavaFileObject.Kind.CLASS &amp;&amp;
 978                     enter.getEnv(origin) == null) {
 979                 return false;
 980             }
 981             if (origin == s) {
 982                 return true;
 983             }
 984             for (Type t : interfaces(origin.type)) {
 985                 if (pendingBridges((ClassSymbol)t.tsym, s)) {
 986                     return true;
 987                 }
 988             }
 989             return false;
 990         }
 991     // &lt;/editor-fold&gt;
 992 
 993    /**
 994     * Scope filter used to skip methods that should be ignored (such as methods
 995     * overridden by j.l.Object) during function interface conversion interface check
 996     */
 997     class DescriptorFilter implements Filter&lt;Symbol&gt; {
 998 
 999        TypeSymbol origin;
1000 
1001        DescriptorFilter(TypeSymbol origin) {
1002            this.origin = origin;
1003        }
1004 
1005        @Override
1006        public boolean accepts(Symbol sym) {
1007            return sym.kind == MTH &amp;&amp;
1008                    (sym.flags() &amp; (ABSTRACT | DEFAULT)) == ABSTRACT &amp;&amp;
1009                    !overridesObjectMethod(origin, sym) &amp;&amp;
1010                    (interfaceCandidates(origin.type, (MethodSymbol)sym).head.flags() &amp; DEFAULT) == 0;
1011        }
1012     }
1013 
1014     public boolean isValue(Type t) {
1015         return t != null &amp;&amp; t.tsym != null &amp;&amp; (t.tsym.flags_field &amp; Flags.VALUE) != 0;
1016     }
1017 
1018     public boolean isValueBased(Type t) {
1019         return allowValueBasedClasses &amp;&amp; t != null &amp;&amp; t.tsym != null &amp;&amp; (t.tsym.flags() &amp; Flags.VALUEBASED) != 0;
1020     }
1021 
1022     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isSubtype&quot;&gt;
1023     /**
1024      * Is t an unchecked subtype of s?
1025      */
1026     public boolean isSubtypeUnchecked(Type t, Type s) {
1027         return isSubtypeUnchecked(t, s, noWarnings);
1028     }
1029     /**
1030      * Is t an unchecked subtype of s?
1031      */
1032     public boolean isSubtypeUnchecked(Type t, Type s, Warner warn) {
1033         boolean result = isSubtypeUncheckedInternal(t, s, true, warn);
1034         if (result) {
1035             checkUnsafeVarargsConversion(t, s, warn);
1036         }
1037         return result;
1038     }
1039     //where
1040         private boolean isSubtypeUncheckedInternal(Type t, Type s, boolean capture, Warner warn) {
1041             if (t.hasTag(ARRAY) &amp;&amp; s.hasTag(ARRAY)) {
1042                 if (((ArrayType)t).elemtype.isPrimitive()) {
1043                     return isSameType(elemtype(t), elemtype(s));
1044                 } else {
1045                     // if T.ref &lt;: S, then T[] &lt;: S[]
1046                     Type es = elemtype(s);
1047                     Type et = elemtype(t);
1048                     if (isValue(et)) {
1049                         et = et.referenceProjection();
1050                         if (isValue(es))
1051                             es = es.referenceProjection();  // V &lt;: V, surely
1052                     }
1053                     if (!isSubtypeUncheckedInternal(et, es, false, warn))
1054                         return false;
1055                     return true;
1056                 }
1057             } else if (isSubtype(t, s, capture)) {
1058                 return true;
1059             } else if (t.hasTag(TYPEVAR)) {
1060                 return isSubtypeUncheckedInternal(t.getUpperBound(), s, false, warn);
1061             } else if (!s.isRaw()) {
1062                 Type t2 = asSuper(t, s.tsym);
1063                 if (t2 != null &amp;&amp; t2.isRaw()) {
1064                     if (isReifiable(s)) {
1065                         warn.silentWarn(LintCategory.UNCHECKED);
1066                     } else {
1067                         warn.warn(LintCategory.UNCHECKED);
1068                     }
1069                     return true;
1070                 }
1071             }
1072             return false;
1073         }
1074 
1075         private void checkUnsafeVarargsConversion(Type t, Type s, Warner warn) {
1076             if (!t.hasTag(ARRAY) || isReifiable(t)) {
1077                 return;
1078             }
1079             ArrayType from = (ArrayType)t;
1080             boolean shouldWarn = false;
1081             switch (s.getTag()) {
1082                 case ARRAY:
1083                     ArrayType to = (ArrayType)s;
1084                     shouldWarn = from.isVarargs() &amp;&amp;
1085                             !to.isVarargs() &amp;&amp;
1086                             !isReifiable(from);
1087                     break;
1088                 case CLASS:
1089                     shouldWarn = from.isVarargs();
1090                     break;
1091             }
1092             if (shouldWarn) {
1093                 warn.warn(LintCategory.VARARGS);
1094             }
1095         }
1096 
1097     /**
1098      * Is t a subtype of s?&lt;br&gt;
1099      * (not defined for Method and ForAll types)
1100      */
1101     final public boolean isSubtype(Type t, Type s) {
1102         return isSubtype(t, s, true);
1103     }
1104     final public boolean isSubtypeNoCapture(Type t, Type s) {
1105         return isSubtype(t, s, false);
1106     }
1107     public boolean isSubtype(Type t, Type s, boolean capture) {
1108         if (t.equalsIgnoreMetadata(s))
1109             return true;
1110         if (s.isPartial())
1111             return isSuperType(s, t);
1112 
1113         if (s.isCompound()) {
1114             for (Type s2 : interfaces(s).prepend(supertype(s))) {
1115                 if (!isSubtype(t, s2, capture))
1116                     return false;
1117             }
1118             return true;
1119         }
1120 
1121         // Generally, if &#39;s&#39; is a lower-bounded type variable, recur on lower bound; but
1122         // for inference variables and intersections, we need to keep &#39;s&#39;
1123         // (see JLS 4.10.2 for intersections and 18.2.3 for inference vars)
1124         if (!t.hasTag(UNDETVAR) &amp;&amp; !t.isCompound()) {
1125             // TODO: JDK-8039198, bounds checking sometimes passes in a wildcard as s
1126             Type lower = cvarLowerBound(wildLowerBound(s));
1127             if (s != lower &amp;&amp; !lower.hasTag(BOT))
1128                 return isSubtype(capture ? capture(t) : t, lower, false);
1129         }
1130 
1131         return isSubtype.visit(capture ? capture(t) : t, s);
1132     }
1133     // where
1134         private TypeRelation isSubtype = new TypeRelation()
1135         {
1136             @Override
1137             public Boolean visitType(Type t, Type s) {
1138                 switch (t.getTag()) {
1139                  case BYTE:
1140                      return (!s.hasTag(CHAR) &amp;&amp; t.getTag().isSubRangeOf(s.getTag()));
1141                  case CHAR:
1142                      return (!s.hasTag(SHORT) &amp;&amp; t.getTag().isSubRangeOf(s.getTag()));
1143                  case SHORT: case INT: case LONG:
1144                  case FLOAT: case DOUBLE:
1145                      return t.getTag().isSubRangeOf(s.getTag());
1146                  case BOOLEAN: case VOID:
1147                      return t.hasTag(s.getTag());
1148                  case TYPEVAR:
1149                      return isSubtypeNoCapture(t.getUpperBound(), s);
1150                  case BOT:
1151                      return
1152                          s.hasTag(BOT) || (s.hasTag(CLASS) &amp;&amp; (!isValue(s) || isValueBased(s))) ||
1153                          s.hasTag(ARRAY) || s.hasTag(TYPEVAR);
1154                  case WILDCARD: //we shouldn&#39;t be here - avoids crash (see 7034495)
1155                  case NONE:
1156                      return false;
1157                  default:
1158                      throw new AssertionError(&quot;isSubtype &quot; + t.getTag());
1159                  }
1160             }
1161 
1162             private Set&lt;TypePair&gt; cache = new HashSet&lt;&gt;();
1163 
1164             private boolean containsTypeRecursive(Type t, Type s) {
1165                 TypePair pair = new TypePair(t, s);
1166                 if (cache.add(pair)) {
1167                     try {
1168                         return containsType(t.getTypeArguments(),
1169                                             s.getTypeArguments());
1170                     } finally {
1171                         cache.remove(pair);
1172                     }
1173                 } else {
1174                     return containsType(t.getTypeArguments(),
1175                                         rewriteSupers(s).getTypeArguments());
1176                 }
1177             }
1178 
1179             private Type rewriteSupers(Type t) {
1180                 if (!t.isParameterized())
1181                     return t;
1182                 ListBuffer&lt;Type&gt; from = new ListBuffer&lt;&gt;();
1183                 ListBuffer&lt;Type&gt; to = new ListBuffer&lt;&gt;();
1184                 adaptSelf(t, from, to);
1185                 if (from.isEmpty())
1186                     return t;
1187                 ListBuffer&lt;Type&gt; rewrite = new ListBuffer&lt;&gt;();
1188                 boolean changed = false;
1189                 for (Type orig : to.toList()) {
1190                     Type s = rewriteSupers(orig);
1191                     if (s.isSuperBound() &amp;&amp; !s.isExtendsBound()) {
1192                         s = new WildcardType(syms.objectType,
1193                                              BoundKind.UNBOUND,
1194                                              syms.boundClass,
1195                                              s.getMetadata());
1196                         changed = true;
1197                     } else if (s != orig) {
1198                         s = new WildcardType(wildUpperBound(s),
1199                                              BoundKind.EXTENDS,
1200                                              syms.boundClass,
1201                                              s.getMetadata());
1202                         changed = true;
1203                     }
1204                     rewrite.append(s);
1205                 }
1206                 if (changed)
1207                     return subst(t.tsym.type, from.toList(), rewrite.toList());
1208                 else
1209                     return t;
1210             }
1211 
1212             @Override
1213             public Boolean visitClassType(ClassType t, Type s) {
1214                 Type sup = asSuper(t, s.tsym);
1215                 if (sup == null) return false;
1216                 // If t is an intersection, sup might not be a class type
1217                 if (!sup.hasTag(CLASS)) return isSubtypeNoCapture(sup, s);
1218                 return sup.tsym == s.tsym
1219                      // Check type variable containment
1220                     &amp;&amp; (!s.isParameterized() || containsTypeRecursive(s, sup))
1221                     &amp;&amp; isSubtypeNoCapture(sup.getEnclosingType(),
1222                                           s.getEnclosingType());
1223             }
1224 
1225             @Override
1226             public Boolean visitArrayType(ArrayType t, Type s) {
1227                 if (s.hasTag(ARRAY)) {
1228                     if (t.elemtype.isPrimitive())
1229                         return isSameType(t.elemtype, elemtype(s));
1230                     else {
1231                         // if T.ref &lt;: S, then T[] &lt;: S[]
1232                         Type es = elemtype(s);
1233                         Type et = elemtype(t);
1234                         if (isValue(et)) {
1235                             et = et.referenceProjection();
1236                             if (isValue(es))
1237                                 es = es.referenceProjection();  // V &lt;: V, surely
1238                         }
1239                         return isSubtypeNoCapture(et, es);
1240                     }
1241                 }
1242 
1243                 if (s.hasTag(CLASS)) {
1244                     Name sname = s.tsym.getQualifiedName();
1245                     return sname == names.java_lang_Object
1246                         || sname == names.java_lang_Cloneable
1247                         || sname == names.java_io_Serializable
1248                         || (injectTopInterfaceTypes &amp;&amp; sname == names.java_lang_IdentityObject);
1249                 }
1250 
1251                 return false;
1252             }
1253 
1254             @Override
1255             public Boolean visitUndetVar(UndetVar t, Type s) {
1256                 //todo: test against origin needed? or replace with substitution?
1257                 if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {
1258                     return true;
1259                 } else if (s.hasTag(BOT)) {
1260                     //if &#39;s&#39; is &#39;null&#39; there&#39;s no instantiated type U for which
1261                     //U &lt;: s (but &#39;null&#39; itself, which is not a valid type)
1262                     return false;
1263                 }
1264 
1265                 t.addBound(InferenceBound.UPPER, s, Types.this);
1266                 return true;
1267             }
1268 
1269             @Override
1270             public Boolean visitErrorType(ErrorType t, Type s) {
1271                 return true;
1272             }
1273         };
1274 
1275     /**
1276      * Is t a subtype of every type in given list `ts&#39;?&lt;br&gt;
1277      * (not defined for Method and ForAll types)&lt;br&gt;
1278      * Allows unchecked conversions.
1279      */
1280     public boolean isSubtypeUnchecked(Type t, List&lt;Type&gt; ts, Warner warn) {
1281         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
1282             if (!isSubtypeUnchecked(t, l.head, warn))
1283                 return false;
1284         return true;
1285     }
1286 
1287     /**
1288      * Are corresponding elements of ts subtypes of ss?  If lists are
1289      * of different length, return false.
1290      */
1291     public boolean isSubtypes(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1292         while (ts.tail != null &amp;&amp; ss.tail != null
1293                /*inlined: ts.nonEmpty() &amp;&amp; ss.nonEmpty()*/ &amp;&amp;
1294                isSubtype(ts.head, ss.head)) {
1295             ts = ts.tail;
1296             ss = ss.tail;
1297         }
1298         return ts.tail == null &amp;&amp; ss.tail == null;
1299         /*inlined: ts.isEmpty() &amp;&amp; ss.isEmpty();*/
1300     }
1301 
1302     /**
1303      * Are corresponding elements of ts subtypes of ss, allowing
1304      * unchecked conversions?  If lists are of different length,
1305      * return false.
1306      **/
1307     public boolean isSubtypesUnchecked(List&lt;Type&gt; ts, List&lt;Type&gt; ss, Warner warn) {
1308         while (ts.tail != null &amp;&amp; ss.tail != null
1309                /*inlined: ts.nonEmpty() &amp;&amp; ss.nonEmpty()*/ &amp;&amp;
1310                isSubtypeUnchecked(ts.head, ss.head, warn)) {
1311             ts = ts.tail;
1312             ss = ss.tail;
1313         }
1314         return ts.tail == null &amp;&amp; ss.tail == null;
1315         /*inlined: ts.isEmpty() &amp;&amp; ss.isEmpty();*/
1316     }
1317     // &lt;/editor-fold&gt;
1318 
1319     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isSuperType&quot;&gt;
1320     /**
1321      * Is t a supertype of s?
1322      */
1323     public boolean isSuperType(Type t, Type s) {
1324         switch (t.getTag()) {
1325         case ERROR:
1326             return true;
1327         case UNDETVAR: {
1328             UndetVar undet = (UndetVar)t;
1329             if (t == s ||
1330                 undet.qtype == s ||
1331                 s.hasTag(ERROR) ||
1332                 s.hasTag(BOT)) {
1333                 return true;
1334             }
1335             undet.addBound(InferenceBound.LOWER, s, this);
1336             return true;
1337         }
1338         default:
1339             return isSubtype(s, t);
1340         }
1341     }
1342     // &lt;/editor-fold&gt;
1343 
1344     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isSameType&quot;&gt;
1345     /**
1346      * Are corresponding elements of the lists the same type?  If
1347      * lists are of different length, return false.
1348      */
1349     public boolean isSameTypes(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1350         while (ts.tail != null &amp;&amp; ss.tail != null
1351                /*inlined: ts.nonEmpty() &amp;&amp; ss.nonEmpty()*/ &amp;&amp;
1352                isSameType(ts.head, ss.head)) {
1353             ts = ts.tail;
1354             ss = ss.tail;
1355         }
1356         return ts.tail == null &amp;&amp; ss.tail == null;
1357         /*inlined: ts.isEmpty() &amp;&amp; ss.isEmpty();*/
1358     }
1359 
1360     /**
1361      * A polymorphic signature method (JLS 15.12.3) is a method that
1362      *   (i) is declared in the java.lang.invoke.MethodHandle/VarHandle classes;
1363      *  (ii) takes a single variable arity parameter;
1364      * (iii) whose declared type is Object[];
1365      *  (iv) has any return type, Object signifying a polymorphic return type; and
1366      *   (v) is native.
1367     */
1368    public boolean isSignaturePolymorphic(MethodSymbol msym) {
1369        List&lt;Type&gt; argtypes = msym.type.getParameterTypes();
1370        return (msym.flags_field &amp; NATIVE) != 0 &amp;&amp;
1371               (msym.owner == syms.methodHandleType.tsym || msym.owner == syms.varHandleType.tsym) &amp;&amp;
1372                argtypes.length() == 1 &amp;&amp;
1373                argtypes.head.hasTag(TypeTag.ARRAY) &amp;&amp;
1374                ((ArrayType)argtypes.head).elemtype.tsym == syms.objectType.tsym;
1375    }
1376 
1377     /**
1378      * Is t the same type as s?
1379      */
1380     public boolean isSameType(Type t, Type s) {
1381         return isSameTypeVisitor.visit(t, s);
1382     }
1383     // where
1384 
1385         /**
1386          * Type-equality relation - type variables are considered
1387          * equals if they share the same object identity.
1388          */
1389         TypeRelation isSameTypeVisitor = new TypeRelation() {
1390 
1391             public Boolean visitType(Type t, Type s) {
1392                 if (t.equalsIgnoreMetadata(s))
1393                     return true;
1394 
1395                 if (s.isPartial())
1396                     return visit(s, t);
1397 
1398                 switch (t.getTag()) {
1399                 case BYTE: case CHAR: case SHORT: case INT: case LONG: case FLOAT:
1400                 case DOUBLE: case BOOLEAN: case VOID: case BOT: case NONE:
1401                     return t.hasTag(s.getTag());
1402                 case TYPEVAR: {
1403                     if (s.hasTag(TYPEVAR)) {
1404                         //type-substitution does not preserve type-var types
1405                         //check that type var symbols and bounds are indeed the same
1406                         return t == s;
1407                     }
1408                     else {
1409                         //special case for s == ? super X, where upper(s) = u
1410                         //check that u == t, where u has been set by Type.withTypeVar
1411                         return s.isSuperBound() &amp;&amp;
1412                                 !s.isExtendsBound() &amp;&amp;
1413                                 visit(t, wildUpperBound(s));
1414                     }
1415                 }
1416                 default:
1417                     throw new AssertionError(&quot;isSameType &quot; + t.getTag());
1418                 }
1419             }
1420 
1421             @Override
1422             public Boolean visitWildcardType(WildcardType t, Type s) {
1423                 if (!s.hasTag(WILDCARD)) {
1424                     return false;
1425                 } else {
1426                     WildcardType t2 = (WildcardType)s;
1427                     return (t.kind == t2.kind || (t.isExtendsBound() &amp;&amp; s.isExtendsBound())) &amp;&amp;
1428                             isSameType(t.type, t2.type);
1429                 }
1430             }
1431 
1432             @Override
1433             public Boolean visitClassType(ClassType t, Type s) {
1434                 if (t == s)
1435                     return true;
1436 
1437                 if (s.isPartial())
1438                     return visit(s, t);
1439 
1440                 if (s.isSuperBound() &amp;&amp; !s.isExtendsBound())
1441                     return visit(t, wildUpperBound(s)) &amp;&amp; visit(t, wildLowerBound(s));
1442 
1443                 if (t.isCompound() &amp;&amp; s.isCompound()) {
1444                     if (!visit(supertype(t), supertype(s)))
1445                         return false;
1446 
1447                     Map&lt;Symbol,Type&gt; tMap = new HashMap&lt;&gt;();
1448                     for (Type ti : interfaces(t)) {
1449                         if (tMap.containsKey(ti)) {
1450                             throw new AssertionError(&quot;Malformed intersection&quot;);
1451                         }
1452                         tMap.put(ti.tsym, ti);
1453                     }
1454                     for (Type si : interfaces(s)) {
1455                         if (!tMap.containsKey(si.tsym))
1456                             return false;
1457                         Type ti = tMap.remove(si.tsym);
1458                         if (!visit(ti, si))
1459                             return false;
1460                     }
1461                     return tMap.isEmpty();
1462                 }
1463                 return t.tsym == s.tsym
1464                     &amp;&amp; visit(t.getEnclosingType(), s.getEnclosingType())
1465                     &amp;&amp; containsTypeEquivalent(t.getTypeArguments(), s.getTypeArguments());
1466             }
1467 
1468             @Override
1469             public Boolean visitArrayType(ArrayType t, Type s) {
1470                 if (t == s)
1471                     return true;
1472 
1473                 if (s.isPartial())
1474                     return visit(s, t);
1475 
1476                 return s.hasTag(ARRAY)
1477                     &amp;&amp; containsTypeEquivalent(t.elemtype, elemtype(s));
1478             }
1479 
1480             @Override
1481             public Boolean visitMethodType(MethodType t, Type s) {
1482                 // isSameType for methods does not take thrown
1483                 // exceptions into account!
1484                 return hasSameArgs(t, s) &amp;&amp; visit(t.getReturnType(), s.getReturnType());
1485             }
1486 
1487             @Override
1488             public Boolean visitPackageType(PackageType t, Type s) {
1489                 return t == s;
1490             }
1491 
1492             @Override
1493             public Boolean visitForAll(ForAll t, Type s) {
1494                 if (!s.hasTag(FORALL)) {
1495                     return false;
1496                 }
1497 
1498                 ForAll forAll = (ForAll)s;
1499                 return hasSameBounds(t, forAll)
1500                     &amp;&amp; visit(t.qtype, subst(forAll.qtype, forAll.tvars, t.tvars));
1501             }
1502 
1503             @Override
1504             public Boolean visitUndetVar(UndetVar t, Type s) {
1505                 if (s.hasTag(WILDCARD)) {
1506                     // FIXME, this might be leftovers from before capture conversion
1507                     return false;
1508                 }
1509 
1510                 if (t == s || t.qtype == s || s.hasTag(ERROR) || s.hasTag(UNKNOWN)) {
1511                     return true;
1512                 }
1513 
1514                 t.addBound(InferenceBound.EQ, s, Types.this);
1515 
1516                 return true;
1517             }
1518 
1519             @Override
1520             public Boolean visitErrorType(ErrorType t, Type s) {
1521                 return true;
1522             }
1523         };
1524 
1525     // &lt;/editor-fold&gt;
1526 
1527     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Contains Type&quot;&gt;
1528     public boolean containedBy(Type t, Type s) {
1529         switch (t.getTag()) {
1530         case UNDETVAR:
1531             if (s.hasTag(WILDCARD)) {
1532                 UndetVar undetvar = (UndetVar)t;
1533                 WildcardType wt = (WildcardType)s;
1534                 switch(wt.kind) {
1535                     case UNBOUND:
1536                         break;
1537                     case EXTENDS: {
1538                         Type bound = wildUpperBound(s);
1539                         undetvar.addBound(InferenceBound.UPPER, bound, this);
1540                         break;
1541                     }
1542                     case SUPER: {
1543                         Type bound = wildLowerBound(s);
1544                         undetvar.addBound(InferenceBound.LOWER, bound, this);
1545                         break;
1546                     }
1547                 }
1548                 return true;
1549             } else {
1550                 return isSameType(t, s);
1551             }
1552         case ERROR:
1553             return true;
1554         default:
1555             return containsType(s, t);
1556         }
1557     }
1558 
1559     boolean containsType(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1560         while (ts.nonEmpty() &amp;&amp; ss.nonEmpty()
1561                &amp;&amp; containsType(ts.head, ss.head)) {
1562             ts = ts.tail;
1563             ss = ss.tail;
1564         }
1565         return ts.isEmpty() &amp;&amp; ss.isEmpty();
1566     }
1567 
1568     /**
1569      * Check if t contains s.
1570      *
1571      * &lt;p&gt;T contains S if:
1572      *
1573      * &lt;p&gt;{@code L(T) &lt;: L(S) &amp;&amp; U(S) &lt;: U(T)}
1574      *
1575      * &lt;p&gt;This relation is only used by ClassType.isSubtype(), that
1576      * is,
1577      *
1578      * &lt;p&gt;{@code C&lt;S&gt; &lt;: C&lt;T&gt; if T contains S.}
1579      *
1580      * &lt;p&gt;Because of F-bounds, this relation can lead to infinite
1581      * recursion.  Thus we must somehow break that recursion.  Notice
1582      * that containsType() is only called from ClassType.isSubtype().
1583      * Since the arguments have already been checked against their
1584      * bounds, we know:
1585      *
1586      * &lt;p&gt;{@code U(S) &lt;: U(T) if T is &quot;super&quot; bound (U(T) *is* the bound)}
1587      *
1588      * &lt;p&gt;{@code L(T) &lt;: L(S) if T is &quot;extends&quot; bound (L(T) is bottom)}
1589      *
1590      * @param t a type
1591      * @param s a type
1592      */
1593     public boolean containsType(Type t, Type s) {
1594         return containsType.visit(t, s);
1595     }
1596     // where
1597         private TypeRelation containsType = new TypeRelation() {
1598 
1599             public Boolean visitType(Type t, Type s) {
1600                 if (s.isPartial())
1601                     return containedBy(s, t);
1602                 else
1603                     return isSameType(t, s);
1604             }
1605 
1606 //            void debugContainsType(WildcardType t, Type s) {
1607 //                System.err.println();
1608 //                System.err.format(&quot; does %s contain %s?%n&quot;, t, s);
1609 //                System.err.format(&quot; %s U(%s) &lt;: U(%s) %s = %s%n&quot;,
1610 //                                  wildUpperBound(s), s, t, wildUpperBound(t),
1611 //                                  t.isSuperBound()
1612 //                                  || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t)));
1613 //                System.err.format(&quot; %s L(%s) &lt;: L(%s) %s = %s%n&quot;,
1614 //                                  wildLowerBound(t), t, s, wildLowerBound(s),
1615 //                                  t.isExtendsBound()
1616 //                                  || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s)));
1617 //                System.err.println();
1618 //            }
1619 
1620             @Override
1621             public Boolean visitWildcardType(WildcardType t, Type s) {
1622                 if (s.isPartial())
1623                     return containedBy(s, t);
1624                 else {
1625 //                    debugContainsType(t, s);
1626 
1627                     // -----------------------------------  Unspecified behavior ----------------
1628 
1629                     /* If a value class V implements an interface I, then does &quot;? extends I&quot; contain V?
1630                        It seems widening must be applied here to answer yes to compile some common code
1631                        patterns.
1632                     */
1633 
1634                     // ---------------------------------------------------------------------------
1635                     return isSameWildcard(t, s)
1636                         || isCaptureOf(s, t)
1637                         || ((t.isExtendsBound() || isSubtypeNoCapture(wildLowerBound(t), wildLowerBound(s))) &amp;&amp;
1638                             (t.isSuperBound() || isSubtypeNoCapture(wildUpperBound(s), wildUpperBound(t))));
1639                 }
1640             }
1641 
1642             @Override
1643             public Boolean visitUndetVar(UndetVar t, Type s) {
1644                 if (!s.hasTag(WILDCARD)) {
1645                     return isSameType(t, s);
1646                 } else {
1647                     return false;
1648                 }
1649             }
1650 
1651             @Override
1652             public Boolean visitErrorType(ErrorType t, Type s) {
1653                 return true;
1654             }
1655         };
1656 
1657     public boolean isCaptureOf(Type s, WildcardType t) {
1658         if (!s.hasTag(TYPEVAR) || !((TypeVar)s).isCaptured())
1659             return false;
1660         return isSameWildcard(t, ((CapturedType)s).wildcard);
1661     }
1662 
1663     public boolean isSameWildcard(WildcardType t, Type s) {
1664         if (!s.hasTag(WILDCARD))
1665             return false;
1666         WildcardType w = (WildcardType)s;
1667         return w.kind == t.kind &amp;&amp; w.type == t.type;
1668     }
1669 
1670     public boolean containsTypeEquivalent(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1671         while (ts.nonEmpty() &amp;&amp; ss.nonEmpty()
1672                &amp;&amp; containsTypeEquivalent(ts.head, ss.head)) {
1673             ts = ts.tail;
1674             ss = ss.tail;
1675         }
1676         return ts.isEmpty() &amp;&amp; ss.isEmpty();
1677     }
1678     // &lt;/editor-fold&gt;
1679 
1680     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isCastable&quot;&gt;
1681     public boolean isCastable(Type t, Type s) {
1682         return isCastable(t, s, noWarnings);
1683     }
1684 
1685     /**
1686      * Is t is castable to s?&lt;br&gt;
1687      * s is assumed to be an erased type.&lt;br&gt;
1688      * (not defined for Method and ForAll types).
1689      */
1690     public boolean isCastable(Type t, Type s, Warner warn) {
1691         if (t == s)
1692             return true;
1693         if (t.isPrimitive() != s.isPrimitive()) {
1694             t = skipTypeVars(t, false);
1695             return (isConvertible(t, s, warn)
1696                     || (s.isPrimitive() &amp;&amp;
1697                         isSubtype(boxedClass(s).type, t)));
1698         }
1699         if (warn != warnStack.head) {
1700             try {
1701                 warnStack = warnStack.prepend(warn);
1702                 checkUnsafeVarargsConversion(t, s, warn);
1703                 return isCastable.visit(t,s);
1704             } finally {
1705                 warnStack = warnStack.tail;
1706             }
1707         } else {
1708             return isCastable.visit(t,s);
1709         }
1710     }
1711     // where
1712         private TypeRelation isCastable = new TypeRelation() {
1713 
1714             public Boolean visitType(Type t, Type s) {
1715                 if (s.hasTag(ERROR) || t.hasTag(NONE))
1716                     return true;
1717 
1718                 switch (t.getTag()) {
1719                 case BYTE: case CHAR: case SHORT: case INT: case LONG: case FLOAT:
1720                 case DOUBLE:
1721                     return s.isNumeric();
1722                 case BOOLEAN:
1723                     return s.hasTag(BOOLEAN);
1724                 case VOID:
1725                     return false;
1726                 case BOT:
1727                     return isSubtype(t, s);
1728                 default:
1729                     throw new AssertionError();
1730                 }
1731             }
1732 
1733             @Override
1734             public Boolean visitWildcardType(WildcardType t, Type s) {
1735                 return isCastable(wildUpperBound(t), s, warnStack.head);
1736             }
1737 
1738             @Override
1739             public Boolean visitClassType(ClassType t, Type s) {
1740                 if (s.hasTag(ERROR) || (s.hasTag(BOT) &amp;&amp; !isValue(t)))
1741                     return true;
1742 
1743                 if (s.hasTag(TYPEVAR)) {
1744                     if (isCastable(t, s.getUpperBound(), noWarnings)) {
1745                         warnStack.head.warn(LintCategory.UNCHECKED);
1746                         return true;
1747                     } else {
1748                         return false;
1749                     }
1750                 }
1751 
1752                 if (t.isCompound() || s.isCompound()) {
1753                     return !t.isCompound() ?
1754                             visitCompoundType((ClassType)s, t, true) :
1755                             visitCompoundType(t, s, false);
1756                 }
1757 
1758                 if (s.hasTag(CLASS) || s.hasTag(ARRAY)) {
1759                     if (isValue(t)) {
1760                         // (s) Value ? == (s) Value.ref
1761                         t = t.referenceProjection();
1762                     }
1763                     if (isValue(s)) {
1764                         // (Value) t ? == (Value.ref) t
1765                         s = s.referenceProjection();
1766                     }
1767                     boolean upcast;
1768                     if ((upcast = isSubtype(erasure(t), erasure(s)))
1769                         || isSubtype(erasure(s), erasure(t))) {
1770                         if (!upcast &amp;&amp; s.hasTag(ARRAY)) {
1771                             if (!isReifiable(s))
1772                                 warnStack.head.warn(LintCategory.UNCHECKED);
1773                             return true;
1774                         } else if (s.isRaw()) {
1775                             return true;
1776                         } else if (t.isRaw()) {
1777                             if (!isUnbounded(s))
1778                                 warnStack.head.warn(LintCategory.UNCHECKED);
1779                             return true;
1780                         }
1781                         // Assume |a| &lt;: |b|
1782                         final Type a = upcast ? t : s;
1783                         final Type b = upcast ? s : t;
1784                         final boolean HIGH = true;
1785                         final boolean LOW = false;
1786                         final boolean DONT_REWRITE_TYPEVARS = false;
1787                         Type aHigh = rewriteQuantifiers(a, HIGH, DONT_REWRITE_TYPEVARS);
1788                         Type aLow  = rewriteQuantifiers(a, LOW,  DONT_REWRITE_TYPEVARS);
1789                         Type bHigh = rewriteQuantifiers(b, HIGH, DONT_REWRITE_TYPEVARS);
1790                         Type bLow  = rewriteQuantifiers(b, LOW,  DONT_REWRITE_TYPEVARS);
1791                         Type lowSub = asSub(bLow, aLow.tsym);
1792                         Type highSub = (lowSub == null) ? null : asSub(bHigh, aHigh.tsym);
1793                         if (highSub == null) {
1794                             final boolean REWRITE_TYPEVARS = true;
1795                             aHigh = rewriteQuantifiers(a, HIGH, REWRITE_TYPEVARS);
1796                             aLow  = rewriteQuantifiers(a, LOW,  REWRITE_TYPEVARS);
1797                             bHigh = rewriteQuantifiers(b, HIGH, REWRITE_TYPEVARS);
1798                             bLow  = rewriteQuantifiers(b, LOW,  REWRITE_TYPEVARS);
1799                             lowSub = asSub(bLow, aLow.tsym);
1800                             highSub = (lowSub == null) ? null : asSub(bHigh, aHigh.tsym);
1801                         }
1802                         if (highSub != null) {
1803                             if (!(a.tsym == highSub.tsym &amp;&amp; a.tsym == lowSub.tsym)) {
1804                                 Assert.error(a.tsym + &quot; != &quot; + highSub.tsym + &quot; != &quot; + lowSub.tsym);
1805                             }
1806                             if (!disjointTypes(aHigh.allparams(), highSub.allparams())
1807                                 &amp;&amp; !disjointTypes(aHigh.allparams(), lowSub.allparams())
1808                                 &amp;&amp; !disjointTypes(aLow.allparams(), highSub.allparams())
1809                                 &amp;&amp; !disjointTypes(aLow.allparams(), lowSub.allparams())) {
1810                                 if (upcast ? giveWarning(a, b) :
1811                                     giveWarning(b, a))
1812                                     warnStack.head.warn(LintCategory.UNCHECKED);
1813                                 return true;
1814                             }
1815                         }
1816                         if (isReifiable(s))
1817                             return isSubtypeUnchecked(a, b);
1818                         else
1819                             return isSubtypeUnchecked(a, b, warnStack.head);
1820                     }
1821 
1822                     // Sidecast
1823                     if (s.hasTag(CLASS)) {
1824                         if ((s.tsym.flags() &amp; INTERFACE) != 0) {
1825                             return ((t.tsym.flags() &amp; FINAL) == 0)
1826                                 ? sideCast(t, s, warnStack.head)
1827                                 : sideCastFinal(t, s, warnStack.head);
1828                         } else if ((t.tsym.flags() &amp; INTERFACE) != 0) {
1829                             return ((s.tsym.flags() &amp; FINAL) == 0)
1830                                 ? sideCast(t, s, warnStack.head)
1831                                 : sideCastFinal(t, s, warnStack.head);
1832                         } else {
1833                             // unrelated class types
1834                             return false;
1835                         }
1836                     }
1837                 }
1838                 return false;
1839             }
1840 
1841             boolean visitCompoundType(ClassType ct, Type s, boolean reverse) {
1842                 Warner warn = noWarnings;
1843                 for (Type c : directSupertypes(ct)) {
1844                     warn.clear();
1845                     if (reverse ? !isCastable(s, c, warn) : !isCastable(c, s, warn))
1846                         return false;
1847                 }
1848                 if (warn.hasLint(LintCategory.UNCHECKED))
1849                     warnStack.head.warn(LintCategory.UNCHECKED);
1850                 return true;
1851             }
1852 
1853             @Override
1854             public Boolean visitArrayType(ArrayType t, Type s) {
1855                 switch (s.getTag()) {
1856                 case ERROR:
1857                 case BOT:
1858                     return true;
1859                 case TYPEVAR:
1860                     if (isCastable(s, t, noWarnings)) {
1861                         warnStack.head.warn(LintCategory.UNCHECKED);
1862                         return true;
1863                     } else {
1864                         return false;
1865                     }
1866                 case CLASS:
1867                     return isSubtype(t, s);
1868                 case ARRAY:
1869                     if (elemtype(t).isPrimitive() || elemtype(s).isPrimitive()) {
1870                         return elemtype(t).hasTag(elemtype(s).getTag());
1871                     } else {
1872                         Type et = elemtype(t);
1873                         Type es = elemtype(s);
1874                         if (!visit(et, es))
1875                             return false;
1876                         return true;
1877                     }
1878                 default:
1879                     return false;
1880                 }
1881             }
1882 
1883             @Override
1884             public Boolean visitTypeVar(TypeVar t, Type s) {
1885                 switch (s.getTag()) {
1886                 case ERROR:
1887                 case BOT:
1888                     return true;
1889                 case TYPEVAR:
1890                     if (isSubtype(t, s)) {
1891                         return true;
1892                     } else if (isCastable(t.getUpperBound(), s, noWarnings)) {
1893                         warnStack.head.warn(LintCategory.UNCHECKED);
1894                         return true;
1895                     } else {
1896                         return false;
1897                     }
1898                 default:
1899                     return isCastable(t.getUpperBound(), s, warnStack.head);
1900                 }
1901             }
1902 
1903             @Override
1904             public Boolean visitErrorType(ErrorType t, Type s) {
1905                 return true;
1906             }
1907         };
1908     // &lt;/editor-fold&gt;
1909 
1910     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;disjointTypes&quot;&gt;
1911     public boolean disjointTypes(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
1912         while (ts.tail != null &amp;&amp; ss.tail != null) {
1913             if (disjointType(ts.head, ss.head)) return true;
1914             ts = ts.tail;
1915             ss = ss.tail;
1916         }
1917         return false;
1918     }
1919 
1920     /**
1921      * Two types or wildcards are considered disjoint if it can be
1922      * proven that no type can be contained in both. It is
1923      * conservative in that it is allowed to say that two types are
1924      * not disjoint, even though they actually are.
1925      *
1926      * The type {@code C&lt;X&gt;} is castable to {@code C&lt;Y&gt;} exactly if
1927      * {@code X} and {@code Y} are not disjoint.
1928      */
1929     public boolean disjointType(Type t, Type s) {
1930         return disjointType.visit(t, s);
1931     }
1932     // where
1933         private TypeRelation disjointType = new TypeRelation() {
1934 
1935             private Set&lt;TypePair&gt; cache = new HashSet&lt;&gt;();
1936 
1937             @Override
1938             public Boolean visitType(Type t, Type s) {
1939                 if (s.hasTag(WILDCARD))
1940                     return visit(s, t);
1941                 else
1942                     return notSoftSubtypeRecursive(t, s) || notSoftSubtypeRecursive(s, t);
1943             }
1944 
1945             private boolean isCastableRecursive(Type t, Type s) {
1946                 TypePair pair = new TypePair(t, s);
1947                 if (cache.add(pair)) {
1948                     try {
1949                         return Types.this.isCastable(t, s);
1950                     } finally {
1951                         cache.remove(pair);
1952                     }
1953                 } else {
1954                     return true;
1955                 }
1956             }
1957 
1958             private boolean notSoftSubtypeRecursive(Type t, Type s) {
1959                 TypePair pair = new TypePair(t, s);
1960                 if (cache.add(pair)) {
1961                     try {
1962                         return Types.this.notSoftSubtype(t, s);
1963                     } finally {
1964                         cache.remove(pair);
1965                     }
1966                 } else {
1967                     return false;
1968                 }
1969             }
1970 
1971             @Override
1972             public Boolean visitWildcardType(WildcardType t, Type s) {
1973                 if (t.isUnbound())
1974                     return false;
1975 
1976                 if (!s.hasTag(WILDCARD)) {
1977                     if (t.isExtendsBound())
1978                         return notSoftSubtypeRecursive(s, t.type);
1979                     else
1980                         return notSoftSubtypeRecursive(t.type, s);
1981                 }
1982 
1983                 if (s.isUnbound())
1984                     return false;
1985 
1986                 if (t.isExtendsBound()) {
1987                     if (s.isExtendsBound())
1988                         return !isCastableRecursive(t.type, wildUpperBound(s));
1989                     else if (s.isSuperBound())
1990                         return notSoftSubtypeRecursive(wildLowerBound(s), t.type);
1991                 } else if (t.isSuperBound()) {
1992                     if (s.isExtendsBound())
1993                         return notSoftSubtypeRecursive(t.type, wildUpperBound(s));
1994                 }
1995                 return false;
1996             }
1997         };
1998     // &lt;/editor-fold&gt;
1999 
2000     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;cvarLowerBounds&quot;&gt;
2001     public List&lt;Type&gt; cvarLowerBounds(List&lt;Type&gt; ts) {
2002         return ts.map(cvarLowerBoundMapping);
2003     }
2004         private final TypeMapping&lt;Void&gt; cvarLowerBoundMapping = new TypeMapping&lt;Void&gt;() {
2005             @Override
2006             public Type visitCapturedType(CapturedType t, Void _unused) {
2007                 return cvarLowerBound(t);
2008             }
2009         };
2010     // &lt;/editor-fold&gt;
2011 
2012     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;notSoftSubtype&quot;&gt;
2013     /**
2014      * This relation answers the question: is impossible that
2015      * something of type `t&#39; can be a subtype of `s&#39;? This is
2016      * different from the question &quot;is `t&#39; not a subtype of `s&#39;?&quot;
2017      * when type variables are involved: Integer is not a subtype of T
2018      * where {@code &lt;T extends Number&gt;} but it is not true that Integer cannot
2019      * possibly be a subtype of T.
2020      */
2021     public boolean notSoftSubtype(Type t, Type s) {
2022         if (t == s) return false;
2023         if (t.hasTag(TYPEVAR)) {
2024             TypeVar tv = (TypeVar) t;
2025             return !isCastable(tv.getUpperBound(),
2026                                relaxBound(s),
2027                                noWarnings);
2028         }
2029         if (!s.hasTag(WILDCARD))
2030             s = cvarUpperBound(s);
2031 
2032         return !isSubtype(t, relaxBound(s));
2033     }
2034 
2035     private Type relaxBound(Type t) {
2036         return (t.hasTag(TYPEVAR)) ?
2037                 rewriteQuantifiers(skipTypeVars(t, false), true, true) :
2038                 t;
2039     }
2040     // &lt;/editor-fold&gt;
2041 
2042     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isReifiable&quot;&gt;
2043     public boolean isReifiable(Type t) {
2044         return isReifiable.visit(t);
2045     }
2046     // where
2047         private UnaryVisitor&lt;Boolean&gt; isReifiable = new UnaryVisitor&lt;Boolean&gt;() {
2048 
2049             public Boolean visitType(Type t, Void ignored) {
2050                 return true;
2051             }
2052 
2053             @Override
2054             public Boolean visitClassType(ClassType t, Void ignored) {
2055                 if (t.isCompound())
2056                     return false;
2057                 else {
2058                     if (!t.isParameterized())
2059                         return true;
2060 
2061                     for (Type param : t.allparams()) {
2062                         if (!param.isUnbound())
2063                             return false;
2064                     }
2065                     return true;
2066                 }
2067             }
2068 
2069             @Override
2070             public Boolean visitArrayType(ArrayType t, Void ignored) {
2071                 return visit(t.elemtype);
2072             }
2073 
2074             @Override
2075             public Boolean visitTypeVar(TypeVar t, Void ignored) {
2076                 return false;
2077             }
2078         };
2079     // &lt;/editor-fold&gt;
2080 
2081     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Array Utils&quot;&gt;
2082     public boolean isArray(Type t) {
2083         while (t.hasTag(WILDCARD))
2084             t = wildUpperBound(t);
2085         return t.hasTag(ARRAY);
2086     }
2087 
2088     /**
2089      * The element type of an array.
2090      */
2091     public Type elemtype(Type t) {
2092         switch (t.getTag()) {
2093         case WILDCARD:
2094             return elemtype(wildUpperBound(t));
2095         case ARRAY:
2096             return ((ArrayType)t).elemtype;
2097         case FORALL:
2098             return elemtype(((ForAll)t).qtype);
2099         case ERROR:
2100             return t;
2101         default:
2102             return null;
2103         }
2104     }
2105 
2106     public Type elemtypeOrType(Type t) {
2107         Type elemtype = elemtype(t);
2108         return elemtype != null ?
2109             elemtype :
2110             t;
2111     }
2112 
2113     /**
2114      * Mapping to take element type of an arraytype
2115      */
2116     private TypeMapping&lt;Void&gt; elemTypeFun = new TypeMapping&lt;Void&gt;() {
2117         @Override
2118         public Type visitArrayType(ArrayType t, Void _unused) {
2119             return t.elemtype;
2120         }
2121 
2122         @Override
2123         public Type visitTypeVar(TypeVar t, Void _unused) {
2124             return visit(skipTypeVars(t, false));
2125         }
2126     };
2127 
2128     /**
2129      * The number of dimensions of an array type.
2130      */
2131     public int dimensions(Type t) {
2132         int result = 0;
2133         while (t.hasTag(ARRAY)) {
2134             result++;
2135             t = elemtype(t);
2136         }
2137         return result;
2138     }
2139 
2140     /**
2141      * Returns an ArrayType with the component type t
2142      *
2143      * @param t The component type of the ArrayType
2144      * @return the ArrayType for the given component
2145      */
2146     public ArrayType makeArrayType(Type t) {
2147         if (t.hasTag(VOID) || t.hasTag(PACKAGE)) {
2148             Assert.error(&quot;Type t must not be a VOID or PACKAGE type, &quot; + t.toString());
2149         }
2150         return new ArrayType(t, syms.arrayClass);
2151     }
2152     // &lt;/editor-fold&gt;
2153 
2154     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;asSuper&quot;&gt;
2155     /**
2156      * Return the (most specific) base type of t that starts with the
2157      * given symbol.  If none exists, return null.
2158      *
2159      * Caveat Emptor: Since javac represents the class of all arrays with a singleton
2160      * symbol Symtab.arrayClass, which by being a singleton cannot hold any discriminant,
2161      * this method could yield surprising answers when invoked on arrays. For example when
2162      * invoked with t being byte [] and sym being t.sym itself, asSuper would answer null.
2163      *
2164      * @param t a type
2165      * @param sym a symbol
2166      */
2167     public Type asSuper(Type t, Symbol sym) {
2168         return asSuper(t, sym, false);
2169     }
2170 
2171     /**
2172      * Return the (most specific) base type of t that starts with the
2173      * given symbol.  If none exists, return null.
2174      *
2175      * Caveat Emptor: Since javac represents the class of all arrays with a singleton
2176      * symbol Symtab.arrayClass, which by being a singleton cannot hold any discriminant,
2177      * this method could yield surprising answers when invoked on arrays. For example when
2178      * invoked with t being byte [] and sym being t.sym itself, asSuper would answer null.
2179      *
2180      * @param t a type
2181      * @param sym a symbol
2182      * @param checkReferenceProjection if true, first compute reference projection of t
2183      */
2184     public Type asSuper(Type t, Symbol sym, boolean checkReferenceProjection) {
2185         /* Some examples:
2186          *
2187          * (Enum&lt;E&gt;, Comparable) =&gt; Comparable&lt;E&gt;
2188          * (c.s.s.d.AttributeTree.ValueKind, Enum) =&gt; Enum&lt;c.s.s.d.AttributeTree.ValueKind&gt;
2189          * (c.s.s.t.ExpressionTree, c.s.s.t.Tree) =&gt; c.s.s.t.Tree
2190          * (j.u.List&lt;capture#160 of ? extends c.s.s.d.DocTree&gt;, Iterable) =&gt;
2191          *     Iterable&lt;capture#160 of ? extends c.s.s.d.DocTree&gt;
2192          */
2193 
2194         /* For a (value or identity) class V, whether it implements an interface I, boils down to whether
2195            V.ref is a subtype of I. OIOW, whether asSuper(V.ref, sym) != null. (Likewise for an abstract
2196            superclass)
2197         */
2198         if (checkReferenceProjection)
2199             t = t.isValue() ? t.referenceProjection() : t;
2200 
2201         if (sym.type == syms.objectType) { //optimization
2202             if (!isValue(t))
2203                 return syms.objectType;
2204         }
2205         return asSuper.visit(t, sym);
2206     }
2207     // where
2208         private SimpleVisitor&lt;Type,Symbol&gt; asSuper = new SimpleVisitor&lt;Type,Symbol&gt;() {
2209 
2210             public Type visitType(Type t, Symbol sym) {
2211                 return null;
2212             }
2213 
2214             @Override
2215             public Type visitClassType(ClassType t, Symbol sym) {
2216                 if (t.tsym == sym)
2217                     return t;
2218 
2219                 // No man may be an island, but the bell tolls for a value.
2220                 if (isValue(t))
2221                     return null;
2222 
2223                 Type st = supertype(t);
2224                 if (st.hasTag(CLASS) || st.hasTag(TYPEVAR)) {
2225                     Type x = asSuper(st, sym);
2226                     if (x != null)
2227                         return x;
2228                 }
2229                 if ((sym.flags() &amp; INTERFACE) != 0) {
2230                     for (List&lt;Type&gt; l = interfaces(t); l.nonEmpty(); l = l.tail) {
2231                         if (!l.head.hasTag(ERROR)) {
2232                             Type x = asSuper(l.head, sym);
2233                             if (x != null)
2234                                 return x;
2235                         }
2236                     }
2237                 }
2238                 return null;
2239             }
2240 
2241             @Override
2242             public Type visitArrayType(ArrayType t, Symbol sym) {
2243                 return isSubtype(t, sym.type) ? sym.type : null;
2244             }
2245 
2246             @Override
2247             public Type visitTypeVar(TypeVar t, Symbol sym) {
2248                 if (t.tsym == sym)
2249                     return t;
2250                 else
2251                     return asSuper(t.getUpperBound(), sym);
2252             }
2253 
2254             @Override
2255             public Type visitErrorType(ErrorType t, Symbol sym) {
2256                 return t;
2257             }
2258         };
2259 
2260     /**
2261      * Return the base type of t or any of its outer types that starts
2262      * with the given symbol.  If none exists, return null.
2263      *
2264      * @param t a type
2265      * @param sym a symbol
2266      */
2267     public Type asOuterSuper(Type t, Symbol sym) {
2268         switch (t.getTag()) {
2269         case CLASS:
2270             do {
2271                 Type s = asSuper(t, sym);
2272                 if (s != null) return s;
2273                 t = t.getEnclosingType();
2274             } while (t.hasTag(CLASS));
2275             return null;
2276         case ARRAY:
2277             return isSubtype(t, sym.type) ? sym.type : null;
2278         case TYPEVAR:
2279             return asSuper(t, sym);
2280         case ERROR:
2281             return t;
2282         default:
2283             return null;
2284         }
2285     }
2286 
2287     /**
2288      * Return the base type of t or any of its enclosing types that
2289      * starts with the given symbol.  If none exists, return null.
2290      *
2291      * @param t a type
2292      * @param sym a symbol
2293      */
2294     public Type asEnclosingSuper(Type t, Symbol sym) {
2295         switch (t.getTag()) {
2296         case CLASS:
2297             do {
2298                 Type s = asSuper(t, sym);
2299                 if (s != null) return s;
2300                 Type outer = t.getEnclosingType();
2301                 t = (outer.hasTag(CLASS)) ? outer :
2302                     (t.tsym.owner.enclClass() != null) ? t.tsym.owner.enclClass().type :
2303                     Type.noType;
2304             } while (t.hasTag(CLASS));
2305             return null;
2306         case ARRAY:
2307             return isSubtype(t, sym.type) ? sym.type : null;
2308         case TYPEVAR:
2309             return asSuper(t, sym);
2310         case ERROR:
2311             return t;
2312         default:
2313             return null;
2314         }
2315     }
2316     // &lt;/editor-fold&gt;
2317 
2318     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;memberType&quot;&gt;
2319     /**
2320      * The type of given symbol, seen as a member of t.
2321      *
2322      * @param t a type
2323      * @param sym a symbol
2324      */
2325     public Type memberType(Type t, Symbol sym) {
2326 
2327         if ((sym.flags() &amp; STATIC) != 0)
2328             return sym.type;
2329 
2330         /* If any inline types are involved, switch over to the reference universe,
2331            where the hierarchy is navigable. V and V.ref have identical membership
2332            with no bridging needs.
2333         */
2334         if (t.isValue())
2335             t = t.referenceProjection();
2336 
2337         if (sym.owner.isValue())
2338             sym = sym.referenceProjection();
2339 
2340         return memberType.visit(t, sym);
2341         }
2342     // where
2343         private SimpleVisitor&lt;Type,Symbol&gt; memberType = new SimpleVisitor&lt;Type,Symbol&gt;() {
2344 
2345             public Type visitType(Type t, Symbol sym) {
2346                 return sym.type;
2347             }
2348 
2349             @Override
2350             public Type visitWildcardType(WildcardType t, Symbol sym) {
2351                 return memberType(wildUpperBound(t), sym);
2352             }
2353 
2354             @Override
2355             public Type visitClassType(ClassType t, Symbol sym) {
2356                 Symbol owner = sym.owner;
2357                 long flags = sym.flags();
2358                 if (((flags &amp; STATIC) == 0) &amp;&amp; owner.type.isParameterized()) {
2359                     Type base = asOuterSuper(t, owner);
2360                     //if t is an intersection type T = CT &amp; I1 &amp; I2 ... &amp; In
2361                     //its supertypes CT, I1, ... In might contain wildcards
2362                     //so we need to go through capture conversion
2363                     base = t.isCompound() ? capture(base) : base;
2364                     if (base != null) {
2365                         List&lt;Type&gt; ownerParams = owner.type.allparams();
2366                         List&lt;Type&gt; baseParams = base.allparams();
2367                         if (ownerParams.nonEmpty()) {
2368                             if (baseParams.isEmpty()) {
2369                                 // then base is a raw type
2370                                 return erasure(sym.type);
2371                             } else {
2372                                 return subst(sym.type, ownerParams, baseParams);
2373                             }
2374                         }
2375                     }
2376                 }
2377                 return sym.type;
2378             }
2379 
2380             @Override
2381             public Type visitTypeVar(TypeVar t, Symbol sym) {
2382                 return memberType(t.getUpperBound(), sym);
2383             }
2384 
2385             @Override
2386             public Type visitErrorType(ErrorType t, Symbol sym) {
2387                 return t;
2388             }
2389         };
2390     // &lt;/editor-fold&gt;
2391 
2392     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isAssignable&quot;&gt;
2393     public boolean isAssignable(Type t, Type s) {
2394         return isAssignable(t, s, noWarnings);
2395     }
2396 
2397     /**
2398      * Is t assignable to s?&lt;br&gt;
2399      * Equivalent to subtype except for constant values and raw
2400      * types.&lt;br&gt;
2401      * (not defined for Method and ForAll types)
2402      */
2403     public boolean isAssignable(Type t, Type s, Warner warn) {
2404         if (t.hasTag(ERROR))
2405             return true;
2406         if (t.getTag().isSubRangeOf(INT) &amp;&amp; t.constValue() != null) {
2407             int value = ((Number)t.constValue()).intValue();
2408             switch (s.getTag()) {
2409             case BYTE:
2410             case CHAR:
2411             case SHORT:
2412             case INT:
2413                 if (s.getTag().checkRange(value))
2414                     return true;
2415                 break;
2416             case CLASS:
2417                 switch (unboxedType(s).getTag()) {
2418                 case BYTE:
2419                 case CHAR:
2420                 case SHORT:
2421                     return isAssignable(t, unboxedType(s), warn);
2422                 }
2423                 break;
2424             }
2425         }
2426         return isConvertible(t, s, warn);
2427     }
2428     // &lt;/editor-fold&gt;
2429 
2430     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;erasure&quot;&gt;
2431     /**
2432      * The erasure of t {@code |t|} -- the type that results when all
2433      * type parameters in t are deleted.
2434      */
2435     public Type erasure(Type t) {
2436         return eraseNotNeeded(t) ? t : erasure(t, false);
2437     }
2438     //where
2439     private boolean eraseNotNeeded(Type t) {
2440         // We don&#39;t want to erase primitive types and String type as that
2441         // operation is idempotent. Also, erasing these could result in loss
2442         // of information such as constant values attached to such types.
2443         return (t.isPrimitive()) || (syms.stringType.tsym == t.tsym);
2444     }
2445 
2446     private Type erasure(Type t, boolean recurse) {
2447         if (t.isPrimitive()) {
2448             return t; /* fast special case */
2449         } else {
2450             Type out = erasure.visit(t, recurse);
2451             return out;
2452         }
2453     }
2454     // where
2455         private TypeMapping&lt;Boolean&gt; erasure = new StructuralTypeMapping&lt;Boolean&gt;() {
2456             private Type combineMetadata(final Type s,
2457                                          final Type t) {
2458                 if (t.getMetadata() != TypeMetadata.EMPTY) {
2459                     switch (s.getKind()) {
2460                         case OTHER:
2461                         case UNION:
2462                         case INTERSECTION:
2463                         case PACKAGE:
2464                         case EXECUTABLE:
2465                         case NONE:
2466                         case VOID:
2467                         case ERROR:
2468                             return s;
2469                         default: return s.cloneWithMetadata(s.getMetadata().without(Kind.ANNOTATIONS));
2470                     }
2471                 } else {
2472                     return s;
2473                 }
2474             }
2475 
2476             public Type visitType(Type t, Boolean recurse) {
2477                 if (t.isPrimitive())
2478                     return t; /*fast special case*/
2479                 else {
2480                     //other cases already handled
2481                     return combineMetadata(t, t);
2482                 }
2483             }
2484 
2485             @Override
2486             public Type visitWildcardType(WildcardType t, Boolean recurse) {
2487                 Type erased = erasure(wildUpperBound(t), recurse);
2488                 return combineMetadata(erased, t);
2489             }
2490 
2491             @Override
2492             public Type visitClassType(ClassType t, Boolean recurse) {
2493                 Type erased = t.tsym.erasure(Types.this);
2494                 if (recurse) {
2495                     erased = new ErasedClassType(erased.getEnclosingType(),erased.tsym,
2496                             t.getMetadata().without(Kind.ANNOTATIONS));
2497                     return erased;
2498                 } else {
2499                     return combineMetadata(erased, t);
2500                 }
2501             }
2502 
2503             @Override
2504             public Type visitTypeVar(TypeVar t, Boolean recurse) {
2505                 Type erased = erasure(t.getUpperBound(), recurse);
2506                 return combineMetadata(erased, t);
2507             }
2508         };
2509 
2510     public List&lt;Type&gt; erasure(List&lt;Type&gt; ts) {
2511         return erasure.visit(ts, false);
2512     }
2513 
2514     public Type erasureRecursive(Type t) {
2515         return erasure(t, true);
2516     }
2517 
2518     public List&lt;Type&gt; erasureRecursive(List&lt;Type&gt; ts) {
2519         return erasure.visit(ts, true);
2520     }
2521     // &lt;/editor-fold&gt;
2522 
2523     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;makeIntersectionType&quot;&gt;
2524     /**
2525      * Make an intersection type from non-empty list of types.  The list should be ordered according to
2526      * {@link TypeSymbol#precedes(TypeSymbol, Types)}. Note that this might cause a symbol completion.
2527      * Hence, this version of makeIntersectionType may not be called during a classfile read.
2528      *
2529      * @param bounds    the types from which the intersection type is formed
2530      */
2531     public IntersectionClassType makeIntersectionType(List&lt;Type&gt; bounds) {
2532         return makeIntersectionType(bounds, bounds.head.tsym.isInterface());
2533     }
2534 
2535     /**
2536      * Make an intersection type from non-empty list of types.  The list should be ordered according to
2537      * {@link TypeSymbol#precedes(TypeSymbol, Types)}. This does not cause symbol completion as
2538      * an extra parameter indicates as to whether all bounds are interfaces - in which case the
2539      * supertype is implicitly assumed to be &#39;Object&#39;.
2540      *
2541      * @param bounds        the types from which the intersection type is formed
2542      * @param allInterfaces are all bounds interface types?
2543      */
2544     public IntersectionClassType makeIntersectionType(List&lt;Type&gt; bounds, boolean allInterfaces) {
2545         Assert.check(bounds.nonEmpty());
2546         Type firstExplicitBound = bounds.head;
2547         if (allInterfaces) {
2548             bounds = bounds.prepend(syms.objectType);
2549         }
2550         long flags = ABSTRACT | PUBLIC | SYNTHETIC | COMPOUND | ACYCLIC;
2551         if (isValue(bounds.head))
2552             flags |= VALUE;
2553         ClassSymbol bc =
2554             new ClassSymbol(flags,
2555                             Type.moreInfo
2556                                 ? names.fromString(bounds.toString())
2557                                 : names.empty,
2558                             null,
2559                             syms.noSymbol);
2560         IntersectionClassType intersectionType = new IntersectionClassType(bounds, bc, allInterfaces);
2561         bc.type = intersectionType;
2562         bc.erasure_field = (bounds.head.hasTag(TYPEVAR)) ?
2563                 syms.objectType : // error condition, recover
2564                 erasure(firstExplicitBound);
2565         bc.members_field = WriteableScope.create(bc);
2566         return intersectionType;
2567     }
2568     // &lt;/editor-fold&gt;
2569 
2570     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;supertype&quot;&gt;
2571     public Type supertype(Type t) {
2572         return supertype.visit(t);
2573     }
2574     // where
2575         private UnaryVisitor&lt;Type&gt; supertype = new UnaryVisitor&lt;Type&gt;() {
2576 
2577             public Type visitType(Type t, Void ignored) {
2578                 // A note on wildcards: there is no good way to
2579                 // determine a supertype for a super bounded wildcard.
2580                 return Type.noType;
2581             }
2582 
2583             @Override
2584             public Type visitClassType(ClassType t, Void ignored) {
2585                 if (t.supertype_field == null) {
2586                     Type supertype = ((ClassSymbol)t.tsym).getSuperclass();
2587                     // An interface has no superclass; its supertype is Object.
2588                     if (t.isInterface())
2589                         supertype = ((ClassType)t.tsym.type).supertype_field;
2590                     if (t.supertype_field == null) {
2591                         List&lt;Type&gt; actuals = classBound(t).allparams();
2592                         List&lt;Type&gt; formals = t.tsym.type.allparams();
2593                         if (t.hasErasedSupertypes()) {
2594                             t.supertype_field = erasureRecursive(supertype);
2595                         } else if (formals.nonEmpty()) {
2596                             t.supertype_field = subst(supertype, formals, actuals);
2597                         }
2598                         else {
2599                             t.supertype_field = supertype;
2600                         }
2601                     }
2602                 }
2603                 return t.supertype_field;
2604             }
2605 
2606             /**
2607              * The supertype is always a class type. If the type
2608              * variable&#39;s bounds start with a class type, this is also
2609              * the supertype.  Otherwise, the supertype is
2610              * java.lang.Object.
2611              */
2612             @Override
2613             public Type visitTypeVar(TypeVar t, Void ignored) {
2614                 if (t.getUpperBound().hasTag(TYPEVAR) ||
2615                     (!t.getUpperBound().isCompound() &amp;&amp; !t.getUpperBound().isInterface())) {
2616                     return t.getUpperBound();
2617                 } else {
2618                     return supertype(t.getUpperBound());
2619                 }
2620             }
2621 
2622             @Override
2623             public Type visitArrayType(ArrayType t, Void ignored) {
2624                 if (t.elemtype.isPrimitive() || isSameType(t.elemtype, syms.objectType))
2625                     return arraySuperType();
2626                 else
2627                     return new ArrayType(supertype(t.elemtype), t.tsym);
2628             }
2629 
2630             @Override
2631             public Type visitErrorType(ErrorType t, Void ignored) {
2632                 return Type.noType;
2633             }
2634         };
2635     // &lt;/editor-fold&gt;
2636 
2637     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;interfaces&quot;&gt;
2638     /**
2639      * Return the interfaces implemented by this class.
2640      */
2641     public List&lt;Type&gt; interfaces(Type t) {
2642         return interfaces.visit(t);
2643     }
2644     // where
2645         private UnaryVisitor&lt;List&lt;Type&gt;&gt; interfaces = new UnaryVisitor&lt;List&lt;Type&gt;&gt;() {
2646 
2647             public List&lt;Type&gt; visitType(Type t, Void ignored) {
2648                 return List.nil();
2649             }
2650 
2651             @Override
2652             public List&lt;Type&gt; visitClassType(ClassType t, Void ignored) {
2653                 if (t.interfaces_field == null) {
2654                     List&lt;Type&gt; interfaces = ((ClassSymbol)t.tsym).getInterfaces();
2655                     if (t.interfaces_field == null) {
2656                         // If t.interfaces_field is null, then t must
2657                         // be a parameterized type (not to be confused
2658                         // with a generic type declaration).
2659                         // Terminology:
2660                         //    Parameterized type: List&lt;String&gt;
2661                         //    Generic type declaration: class List&lt;E&gt; { ... }
2662                         // So t corresponds to List&lt;String&gt; and
2663                         // t.tsym.type corresponds to List&lt;E&gt;.
2664                         // The reason t must be parameterized type is
2665                         // that completion will happen as a side
2666                         // effect of calling
2667                         // ClassSymbol.getInterfaces.  Since
2668                         // t.interfaces_field is null after
2669                         // completion, we can assume that t is not the
2670                         // type of a class/interface declaration.
2671                         Assert.check(t != t.tsym.type, t);
2672                         List&lt;Type&gt; actuals = t.allparams();
2673                         List&lt;Type&gt; formals = t.tsym.type.allparams();
2674                         if (t.hasErasedSupertypes()) {
2675                             t.interfaces_field = erasureRecursive(interfaces);
2676                         } else if (formals.nonEmpty()) {
2677                             t.interfaces_field = subst(interfaces, formals, actuals);
2678                         }
2679                         else {
2680                             t.interfaces_field = interfaces;
2681                         }
2682                     }
2683                 }
2684                 return t.interfaces_field;
2685             }
2686 
2687             @Override
2688             public List&lt;Type&gt; visitTypeVar(TypeVar t, Void ignored) {
2689                 if (t.getUpperBound().isCompound())
2690                     return interfaces(t.getUpperBound());
2691 
2692                 if (t.getUpperBound().isInterface())
2693                     return List.of(t.getUpperBound());
2694 
2695                 return List.nil();
2696             }
2697         };
2698 
2699     public List&lt;Type&gt; directSupertypes(Type t) {
2700         return directSupertypes.visit(t);
2701     }
2702     // where
2703         private final UnaryVisitor&lt;List&lt;Type&gt;&gt; directSupertypes = new UnaryVisitor&lt;List&lt;Type&gt;&gt;() {
2704 
2705             public List&lt;Type&gt; visitType(final Type type, final Void ignored) {
2706                 if (!type.isIntersection()) {
2707                     final Type sup = supertype(type);
2708                     return (sup == Type.noType || sup == type || sup == null)
2709                         ? interfaces(type)
2710                         : interfaces(type).prepend(sup);
2711                 } else {
2712                     return ((IntersectionClassType)type).getExplicitComponents();
2713                 }
2714             }
2715         };
2716 
2717     public boolean isDirectSuperInterface(TypeSymbol isym, TypeSymbol origin) {
2718         for (Type i2 : interfaces(origin.type)) {
2719             if (isym == i2.tsym) return true;
2720         }
2721         return false;
2722     }
2723     // &lt;/editor-fold&gt;
2724 
2725     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;isDerivedRaw&quot;&gt;
2726     Map&lt;Type,Boolean&gt; isDerivedRawCache = new HashMap&lt;&gt;();
2727 
2728     public boolean isDerivedRaw(Type t) {
2729         Boolean result = isDerivedRawCache.get(t);
2730         if (result == null) {
2731             result = isDerivedRawInternal(t);
2732             isDerivedRawCache.put(t, result);
2733         }
2734         return result;
2735     }
2736 
2737     public boolean isDerivedRawInternal(Type t) {
2738         if (t.isErroneous())
2739             return false;
2740         return
2741             t.isRaw() ||
2742             supertype(t) != Type.noType &amp;&amp; isDerivedRaw(supertype(t)) ||
2743             isDerivedRaw(interfaces(t));
2744     }
2745 
2746     public boolean isDerivedRaw(List&lt;Type&gt; ts) {
2747         List&lt;Type&gt; l = ts;
2748         while (l.nonEmpty() &amp;&amp; !isDerivedRaw(l.head)) l = l.tail;
2749         return l.nonEmpty();
2750     }
2751     // &lt;/editor-fold&gt;
2752 
2753     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;setBounds&quot;&gt;
2754     /**
2755      * Same as {@link Types#setBounds(TypeVar, List, boolean)}, except that third parameter is computed directly,
2756      * as follows: if all all bounds are interface types, the computed supertype is Object,otherwise
2757      * the supertype is simply left null (in this case, the supertype is assumed to be the head of
2758      * the bound list passed as second argument). Note that this check might cause a symbol completion.
2759      * Hence, this version of setBounds may not be called during a classfile read.
2760      *
2761      * @param t         a type variable
2762      * @param bounds    the bounds, must be nonempty
2763      */
2764     public void setBounds(TypeVar t, List&lt;Type&gt; bounds) {
2765         setBounds(t, bounds, bounds.head.tsym.isInterface());
2766     }
2767 
2768     /**
2769      * Set the bounds field of the given type variable to reflect a (possibly multiple) list of bounds.
2770      * This does not cause symbol completion as an extra parameter indicates as to whether all bounds
2771      * are interfaces - in which case the supertype is implicitly assumed to be &#39;Object&#39;.
2772      *
2773      * @param t             a type variable
2774      * @param bounds        the bounds, must be nonempty
2775      * @param allInterfaces are all bounds interface types?
2776      */
2777     public void setBounds(TypeVar t, List&lt;Type&gt; bounds, boolean allInterfaces) {
2778         t.setUpperBound( bounds.tail.isEmpty() ?
2779                 bounds.head :
2780                 makeIntersectionType(bounds, allInterfaces) );
2781         t.rank_field = -1;
2782     }
2783     // &lt;/editor-fold&gt;
2784 
2785     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;getBounds&quot;&gt;
2786     /**
2787      * Return list of bounds of the given type variable.
2788      */
2789     public List&lt;Type&gt; getBounds(TypeVar t) {
2790         if (t.getUpperBound().hasTag(NONE))
2791             return List.nil();
2792         else if (t.getUpperBound().isErroneous() || !t.getUpperBound().isCompound())
2793             return List.of(t.getUpperBound());
2794         else if ((erasure(t).tsym.flags() &amp; INTERFACE) == 0)
2795             return interfaces(t).prepend(supertype(t));
2796         else
2797             // No superclass was given in bounds.
2798             // In this case, supertype is Object, erasure is first interface.
2799             return interfaces(t);
2800     }
2801     // &lt;/editor-fold&gt;
2802 
2803     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;classBound&quot;&gt;
2804     /**
2805      * If the given type is a (possibly selected) type variable,
2806      * return the bounding class of this type, otherwise return the
2807      * type itself.
2808      */
2809     public Type classBound(Type t) {
2810         return classBound.visit(t);
2811     }
2812     // where
2813         private UnaryVisitor&lt;Type&gt; classBound = new UnaryVisitor&lt;Type&gt;() {
2814 
2815             public Type visitType(Type t, Void ignored) {
2816                 return t;
2817             }
2818 
2819             @Override
2820             public Type visitClassType(ClassType t, Void ignored) {
2821                 Type outer1 = classBound(t.getEnclosingType());
2822                 if (outer1 != t.getEnclosingType())
2823                     return new ClassType(outer1, t.getTypeArguments(), t.tsym,
2824                                          t.getMetadata());
2825                 else
2826                     return t;
2827             }
2828 
2829             @Override
2830             public Type visitTypeVar(TypeVar t, Void ignored) {
2831                 return classBound(supertype(t));
2832             }
2833 
2834             @Override
2835             public Type visitErrorType(ErrorType t, Void ignored) {
2836                 return t;
2837             }
2838         };
2839     // &lt;/editor-fold&gt;
2840 
2841     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;sub signature / override equivalence&quot;&gt;
2842     /**
2843      * Returns true iff the first signature is a &lt;em&gt;sub
2844      * signature&lt;/em&gt; of the other.  This is &lt;b&gt;not&lt;/b&gt; an equivalence
2845      * relation.
2846      *
2847      * @jls 8.4.2 Method Signature
2848      * @see #overrideEquivalent(Type t, Type s)
2849      * @param t first signature (possibly raw).
2850      * @param s second signature (could be subjected to erasure).
2851      * @return true if t is a sub signature of s.
2852      */
2853     public boolean isSubSignature(Type t, Type s) {
2854         return isSubSignature(t, s, true);
2855     }
2856 
2857     public boolean isSubSignature(Type t, Type s, boolean strict) {
2858         return hasSameArgs(t, s, strict) || hasSameArgs(t, erasure(s), strict);
2859     }
2860 
2861     /**
2862      * Returns true iff these signatures are related by &lt;em&gt;override
2863      * equivalence&lt;/em&gt;.  This is the natural extension of
2864      * isSubSignature to an equivalence relation.
2865      *
2866      * @jls 8.4.2 Method Signature
2867      * @see #isSubSignature(Type t, Type s)
2868      * @param t a signature (possible raw, could be subjected to
2869      * erasure).
2870      * @param s a signature (possible raw, could be subjected to
2871      * erasure).
2872      * @return true if either argument is a sub signature of the other.
2873      */
2874     public boolean overrideEquivalent(Type t, Type s) {
2875         return hasSameArgs(t, s) ||
2876             hasSameArgs(t, erasure(s)) || hasSameArgs(erasure(t), s);
2877     }
2878 
2879     public boolean overridesObjectMethod(TypeSymbol origin, Symbol msym) {
2880         for (Symbol sym : syms.objectType.tsym.members().getSymbolsByName(msym.name)) {
2881             if (msym.overrides(sym, origin, Types.this, true)) {
2882                 return true;
2883             }
2884         }
2885         return false;
2886     }
2887 
2888     /**
2889      * This enum defines the strategy for implementing most specific return type check
2890      * during the most specific and functional interface checks.
2891      */
2892     public enum MostSpecificReturnCheck {
2893         /**
2894          * Return r1 is more specific than r2 if {@code r1 &lt;: r2}. Extra care required for (i) handling
2895          * method type variables (if either method is generic) and (ii) subtyping should be replaced
2896          * by type-equivalence for primitives. This is essentially an inlined version of
2897          * {@link Types#resultSubtype(Type, Type, Warner)}, where the assignability check has been
2898          * replaced with a strict subtyping check.
2899          */
2900         BASIC() {
2901             @Override
2902             public boolean test(Type mt1, Type mt2, Types types) {
2903                 List&lt;Type&gt; tvars = mt1.getTypeArguments();
2904                 List&lt;Type&gt; svars = mt2.getTypeArguments();
2905                 Type t = mt1.getReturnType();
2906                 Type s = types.subst(mt2.getReturnType(), svars, tvars);
2907                 return types.isSameType(t, s) ||
2908                     !t.isPrimitive() &amp;&amp;
2909                     !s.isPrimitive() &amp;&amp;
2910                     types.isSubtype(t, s);
2911             }
2912         },
2913         /**
2914          * Return r1 is more specific than r2 if r1 is return-type-substitutable for r2.
2915          */
2916         RTS() {
2917             @Override
2918             public boolean test(Type mt1, Type mt2, Types types) {
2919                 return types.returnTypeSubstitutable(mt1, mt2);
2920             }
2921         };
2922 
2923         public abstract boolean test(Type mt1, Type mt2, Types types);
2924     }
2925 
2926     /**
2927      * Merge multiple abstract methods. The preferred method is a method that is a subsignature
2928      * of all the other signatures and whose return type is more specific {@see MostSpecificReturnCheck}.
2929      * The resulting preferred method has a thrown clause that is the intersection of the merged
2930      * methods&#39; clauses.
2931      */
2932     public Optional&lt;Symbol&gt; mergeAbstracts(List&lt;Symbol&gt; ambiguousInOrder, Type site, boolean sigCheck) {
2933         //first check for preconditions
2934         boolean shouldErase = false;
2935         List&lt;Type&gt; erasedParams = ambiguousInOrder.head.erasure(this).getParameterTypes();
2936         for (Symbol s : ambiguousInOrder) {
2937             if ((s.flags() &amp; ABSTRACT) == 0 ||
2938                     (sigCheck &amp;&amp; !isSameTypes(erasedParams, s.erasure(this).getParameterTypes()))) {
2939                 return Optional.empty();
2940             } else if (s.type.hasTag(FORALL)) {
2941                 shouldErase = true;
2942             }
2943         }
2944         //then merge abstracts
2945         for (MostSpecificReturnCheck mostSpecificReturnCheck : MostSpecificReturnCheck.values()) {
2946             outer: for (Symbol s : ambiguousInOrder) {
2947                 Type mt = memberType(site, s);
2948                 List&lt;Type&gt; allThrown = mt.getThrownTypes();
2949                 for (Symbol s2 : ambiguousInOrder) {
2950                     if (s != s2) {
2951                         Type mt2 = memberType(site, s2);
2952                         if (!isSubSignature(mt, mt2) ||
2953                                 !mostSpecificReturnCheck.test(mt, mt2, this)) {
2954                             //ambiguity cannot be resolved
2955                             continue outer;
2956                         } else {
2957                             List&lt;Type&gt; thrownTypes2 = mt2.getThrownTypes();
2958                             if (!mt.hasTag(FORALL) &amp;&amp; shouldErase) {
2959                                 thrownTypes2 = erasure(thrownTypes2);
2960                             } else if (mt.hasTag(FORALL)) {
2961                                 //subsignature implies that if most specific is generic, then all other
2962                                 //methods are too
2963                                 Assert.check(mt2.hasTag(FORALL));
2964                                 // if both are generic methods, adjust thrown types ahead of intersection computation
2965                                 thrownTypes2 = subst(thrownTypes2, mt2.getTypeArguments(), mt.getTypeArguments());
2966                             }
2967                             allThrown = chk.intersect(allThrown, thrownTypes2);
2968                         }
2969                     }
2970                 }
2971                 return (allThrown == mt.getThrownTypes()) ?
2972                         Optional.of(s) :
2973                         Optional.of(new MethodSymbol(
2974                                 s.flags(),
2975                                 s.name,
2976                                 createMethodTypeWithThrown(s.type, allThrown),
2977                                 s.owner) {
2978                             @Override
2979                             public Symbol baseSymbol() {
2980                                 return s;
2981                             }
2982                         });
2983             }
2984         }
2985         return Optional.empty();
2986     }
2987 
2988     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Determining method implementation in given site&quot;&gt;
2989     class ImplementationCache {
2990 
2991         private WeakHashMap&lt;MethodSymbol, SoftReference&lt;Map&lt;TypeSymbol, Entry&gt;&gt;&gt; _map = new WeakHashMap&lt;&gt;();
2992 
2993         class Entry {
2994             final MethodSymbol cachedImpl;
2995             final Filter&lt;Symbol&gt; implFilter;
2996             final boolean checkResult;
2997             final int prevMark;
2998 
2999             public Entry(MethodSymbol cachedImpl,
3000                     Filter&lt;Symbol&gt; scopeFilter,
3001                     boolean checkResult,
3002                     int prevMark) {
3003                 this.cachedImpl = cachedImpl;
3004                 this.implFilter = scopeFilter;
3005                 this.checkResult = checkResult;
3006                 this.prevMark = prevMark;
3007             }
3008 
3009             boolean matches(Filter&lt;Symbol&gt; scopeFilter, boolean checkResult, int mark) {
3010                 return this.implFilter == scopeFilter &amp;&amp;
3011                         this.checkResult == checkResult &amp;&amp;
3012                         this.prevMark == mark;
3013             }
3014         }
3015 
3016         MethodSymbol get(MethodSymbol ms, TypeSymbol origin, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
3017             SoftReference&lt;Map&lt;TypeSymbol, Entry&gt;&gt; ref_cache = _map.get(ms);
3018             Map&lt;TypeSymbol, Entry&gt; cache = ref_cache != null ? ref_cache.get() : null;
3019             if (cache == null) {
3020                 cache = new HashMap&lt;&gt;();
3021                 _map.put(ms, new SoftReference&lt;&gt;(cache));
3022             }
3023             Entry e = cache.get(origin);
3024             CompoundScope members = membersClosure(origin.type, true);
3025             if (e == null ||
3026                     !e.matches(implFilter, checkResult, members.getMark())) {
3027                 MethodSymbol impl = implementationInternal(ms, origin, checkResult, implFilter);
3028                 cache.put(origin, new Entry(impl, implFilter, checkResult, members.getMark()));
3029                 return impl;
3030             }
3031             else {
3032                 return e.cachedImpl;
3033             }
3034         }
3035 
3036         private MethodSymbol implementationInternal(MethodSymbol ms, TypeSymbol origin, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
3037             for (Type t = origin.type; t.hasTag(CLASS) || t.hasTag(TYPEVAR); t = supertype(t)) {
3038                 t = skipTypeVars(t, false);
3039                 TypeSymbol c = t.tsym;
3040                 Symbol bestSoFar = null;
3041                 for (Symbol sym : c.members().getSymbolsByName(ms.name, implFilter)) {
3042                     if (sym != null &amp;&amp; sym.overrides(ms, origin, Types.this, checkResult)) {
3043                         bestSoFar = sym;
3044                         if ((sym.flags() &amp; ABSTRACT) == 0) {
3045                             //if concrete impl is found, exit immediately
3046                             break;
3047                         }
3048                     }
3049                 }
3050                 if (bestSoFar != null) {
3051                     //return either the (only) concrete implementation or the first abstract one
3052                     return (MethodSymbol)bestSoFar;
3053                 }
3054             }
3055             return null;
3056         }
3057     }
3058 
3059     private ImplementationCache implCache = new ImplementationCache();
3060 
3061     public MethodSymbol implementation(MethodSymbol ms, TypeSymbol origin, boolean checkResult, Filter&lt;Symbol&gt; implFilter) {
3062         return implCache.get(ms, origin, checkResult, implFilter);
3063     }
3064     // &lt;/editor-fold&gt;
3065 
3066     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;compute transitive closure of all members in given site&quot;&gt;
3067     class MembersClosureCache extends SimpleVisitor&lt;Scope.CompoundScope, Void&gt; {
3068 
3069         private Map&lt;TypeSymbol, CompoundScope&gt; _map = new HashMap&lt;&gt;();
3070 
3071         Set&lt;TypeSymbol&gt; seenTypes = new HashSet&lt;&gt;();
3072 
3073         class MembersScope extends CompoundScope {
3074 
3075             CompoundScope scope;
3076 
3077             public MembersScope(CompoundScope scope) {
3078                 super(scope.owner);
3079                 this.scope = scope;
3080             }
3081 
3082             Filter&lt;Symbol&gt; combine(Filter&lt;Symbol&gt; sf) {
3083                 return s -&gt; !s.owner.isInterface() &amp;&amp; (sf == null || sf.accepts(s));
3084             }
3085 
3086             @Override
3087             public Iterable&lt;Symbol&gt; getSymbols(Filter&lt;Symbol&gt; sf, LookupKind lookupKind) {
3088                 return scope.getSymbols(combine(sf), lookupKind);
3089             }
3090 
3091             @Override
3092             public Iterable&lt;Symbol&gt; getSymbolsByName(Name name, Filter&lt;Symbol&gt; sf, LookupKind lookupKind) {
3093                 return scope.getSymbolsByName(name, combine(sf), lookupKind);
3094             }
3095 
3096             @Override
3097             public int getMark() {
3098                 return scope.getMark();
3099             }
3100         }
3101 
3102         CompoundScope nilScope;
3103 
3104         /** members closure visitor methods **/
3105 
3106         public CompoundScope visitType(Type t, Void _unused) {
3107             if (nilScope == null) {
3108                 nilScope = new CompoundScope(syms.noSymbol);
3109             }
3110             return nilScope;
3111         }
3112 
3113         @Override
3114         public CompoundScope visitClassType(ClassType t, Void _unused) {
3115             if (!seenTypes.add(t.tsym)) {
3116                 //this is possible when an interface is implemented in multiple
3117                 //superclasses, or when a class hierarchy is circular - in such
3118                 //cases we don&#39;t need to recurse (empty scope is returned)
3119                 return new CompoundScope(t.tsym);
3120             }
3121             try {
3122                 seenTypes.add(t.tsym);
3123                 ClassSymbol csym = (ClassSymbol)t.tsym;
3124                 CompoundScope membersClosure = _map.get(csym);
3125                 if (membersClosure == null) {
3126                     membersClosure = new CompoundScope(csym);
3127                     for (Type i : interfaces(t)) {
3128                         membersClosure.prependSubScope(visit(i, null));
3129                     }
3130                     membersClosure.prependSubScope(visit(supertype(t), null));
3131                     membersClosure.prependSubScope(csym.members());
3132                     _map.put(csym, membersClosure);
3133                 }
3134                 return membersClosure;
3135             }
3136             finally {
3137                 seenTypes.remove(t.tsym);
3138             }
3139         }
3140 
3141         @Override
3142         public CompoundScope visitTypeVar(TypeVar t, Void _unused) {
3143             return visit(t.getUpperBound(), null);
3144         }
3145     }
3146 
3147     private MembersClosureCache membersCache = new MembersClosureCache();
3148 
3149     public CompoundScope membersClosure(Type site, boolean skipInterface) {
3150         CompoundScope cs = membersCache.visit(site, null);
3151         Assert.checkNonNull(cs, () -&gt; &quot;type &quot; + site);
3152         return skipInterface ? membersCache.new MembersScope(cs) : cs;
3153     }
3154     // &lt;/editor-fold&gt;
3155 
3156 
3157     /** Return first abstract member of class `sym&#39;.
3158      */
3159     public MethodSymbol firstUnimplementedAbstract(ClassSymbol sym) {
3160         try {
3161             return firstUnimplementedAbstractImpl(sym, sym);
3162         } catch (CompletionFailure ex) {
3163             chk.completionError(enter.getEnv(sym).tree.pos(), ex);
3164             return null;
3165         }
3166     }
3167         //where:
3168         private MethodSymbol firstUnimplementedAbstractImpl(ClassSymbol impl, ClassSymbol c) {
3169             MethodSymbol undef = null;
3170             // Do not bother to search in classes that are not abstract,
3171             // since they cannot have abstract members.
3172             if (c == impl || (c.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
3173                 Scope s = c.members();
3174                 for (Symbol sym : s.getSymbols(NON_RECURSIVE)) {
3175                     if (sym.kind == MTH &amp;&amp;
3176                         (sym.flags() &amp; (ABSTRACT|DEFAULT|PRIVATE)) == ABSTRACT) {
3177                         MethodSymbol absmeth = (MethodSymbol)sym;
3178                         MethodSymbol implmeth = absmeth.implementation(impl, this, true);
3179                         if (implmeth == null || implmeth == absmeth) {
3180                             //look for default implementations
3181                             if (allowDefaultMethods) {
3182                                 MethodSymbol prov = interfaceCandidates(impl.type, absmeth).head;
3183                                 if (prov != null &amp;&amp; prov.overrides(absmeth, impl, this, true)) {
3184                                     implmeth = prov;
3185                                 }
3186                             }
3187                         }
3188                         if (implmeth == null || implmeth == absmeth) {
3189                             undef = absmeth;
3190                             break;
3191                         }
3192                     }
3193                 }
3194                 if (undef == null) {
3195                     Type st = supertype(c.type);
3196                     if (st.hasTag(CLASS))
3197                         undef = firstUnimplementedAbstractImpl(impl, (ClassSymbol)st.tsym);
3198                 }
3199                 for (List&lt;Type&gt; l = interfaces(c.type);
3200                      undef == null &amp;&amp; l.nonEmpty();
3201                      l = l.tail) {
3202                     undef = firstUnimplementedAbstractImpl(impl, (ClassSymbol)l.head.tsym);
3203                 }
3204             }
3205             return undef;
3206         }
3207 
3208     public class CandidatesCache {
3209         public Map&lt;Entry, List&lt;MethodSymbol&gt;&gt; cache = new WeakHashMap&lt;&gt;();
3210 
3211         class Entry {
3212             Type site;
3213             MethodSymbol msym;
3214 
3215             Entry(Type site, MethodSymbol msym) {
3216                 this.site = site;
3217                 this.msym = msym;
3218             }
3219 
3220             @Override
3221             public boolean equals(Object obj) {
3222                 if (obj instanceof Entry) {
3223                     Entry e = (Entry)obj;
3224                     return e.msym == msym &amp;&amp; isSameType(site, e.site);
3225                 } else {
3226                     return false;
3227                 }
3228             }
3229 
3230             @Override
3231             public int hashCode() {
3232                 return Types.this.hashCode(site) &amp; ~msym.hashCode();
3233             }
3234         }
3235 
3236         public List&lt;MethodSymbol&gt; get(Entry e) {
3237             return cache.get(e);
3238         }
3239 
3240         public void put(Entry e, List&lt;MethodSymbol&gt; msymbols) {
3241             cache.put(e, msymbols);
3242         }
3243     }
3244 
3245     public CandidatesCache candidatesCache = new CandidatesCache();
3246 
3247     //where
3248     public List&lt;MethodSymbol&gt; interfaceCandidates(Type site, MethodSymbol ms) {
3249         CandidatesCache.Entry e = candidatesCache.new Entry(site, ms);
3250         List&lt;MethodSymbol&gt; candidates = candidatesCache.get(e);
3251         if (candidates == null) {
3252             Filter&lt;Symbol&gt; filter = new MethodFilter(ms, site);
3253             List&lt;MethodSymbol&gt; candidates2 = List.nil();
3254             for (Symbol s : membersClosure(site, false).getSymbols(filter)) {
3255                 if (!site.tsym.isInterface() &amp;&amp; !s.owner.isInterface()) {
3256                     return List.of((MethodSymbol)s);
3257                 } else if (!candidates2.contains(s)) {
3258                     candidates2 = candidates2.prepend((MethodSymbol)s);
3259                 }
3260             }
3261             candidates = prune(candidates2);
3262             candidatesCache.put(e, candidates);
3263         }
3264         return candidates;
3265     }
3266 
3267     public List&lt;MethodSymbol&gt; prune(List&lt;MethodSymbol&gt; methods) {
3268         ListBuffer&lt;MethodSymbol&gt; methodsMin = new ListBuffer&lt;&gt;();
3269         for (MethodSymbol m1 : methods) {
3270             boolean isMin_m1 = true;
3271             for (MethodSymbol m2 : methods) {
3272                 if (m1 == m2) continue;
3273                 if (m2.owner != m1.owner &amp;&amp;
3274                         asSuper(m2.owner.type, m1.owner) != null) {
3275                     isMin_m1 = false;
3276                     break;
3277                 }
3278             }
3279             if (isMin_m1)
3280                 methodsMin.append(m1);
3281         }
3282         return methodsMin.toList();
3283     }
3284     // where
3285             private class MethodFilter implements Filter&lt;Symbol&gt; {
3286 
3287                 Symbol msym;
3288                 Type site;
3289 
3290                 MethodFilter(Symbol msym, Type site) {
3291                     this.msym = msym;
3292                     this.site = site;
3293                 }
3294 
3295                 public boolean accepts(Symbol s) {
3296                     return s.kind == MTH &amp;&amp;
3297                             s.name == msym.name &amp;&amp;
3298                             (s.flags() &amp; SYNTHETIC) == 0 &amp;&amp;
3299                             s.isInheritedIn(site.tsym, Types.this) &amp;&amp;
3300                             overrideEquivalent(memberType(site, s), memberType(site, msym));
3301                 }
3302             }
3303     // &lt;/editor-fold&gt;
3304 
3305     /**
3306      * Does t have the same arguments as s?  It is assumed that both
3307      * types are (possibly polymorphic) method types.  Monomorphic
3308      * method types &quot;have the same arguments&quot;, if their argument lists
3309      * are equal.  Polymorphic method types &quot;have the same arguments&quot;,
3310      * if they have the same arguments after renaming all type
3311      * variables of one to corresponding type variables in the other,
3312      * where correspondence is by position in the type parameter list.
3313      */
3314     public boolean hasSameArgs(Type t, Type s) {
3315         return hasSameArgs(t, s, true);
3316     }
3317 
3318     public boolean hasSameArgs(Type t, Type s, boolean strict) {
3319         return hasSameArgs(t, s, strict ? hasSameArgs_strict : hasSameArgs_nonstrict);
3320     }
3321 
3322     private boolean hasSameArgs(Type t, Type s, TypeRelation hasSameArgs) {
3323         return hasSameArgs.visit(t, s);
3324     }
3325     // where
3326         private class HasSameArgs extends TypeRelation {
3327 
3328             boolean strict;
3329 
3330             public HasSameArgs(boolean strict) {
3331                 this.strict = strict;
3332             }
3333 
3334             public Boolean visitType(Type t, Type s) {
3335                 throw new AssertionError();
3336             }
3337 
3338             @Override
3339             public Boolean visitMethodType(MethodType t, Type s) {
3340                 return s.hasTag(METHOD)
3341                     &amp;&amp; containsTypeEquivalent(t.argtypes, s.getParameterTypes());
3342             }
3343 
3344             @Override
3345             public Boolean visitForAll(ForAll t, Type s) {
3346                 if (!s.hasTag(FORALL))
3347                     return strict ? false : visitMethodType(t.asMethodType(), s);
3348 
3349                 ForAll forAll = (ForAll)s;
3350                 return hasSameBounds(t, forAll)
3351                     &amp;&amp; visit(t.qtype, subst(forAll.qtype, forAll.tvars, t.tvars));
3352             }
3353 
3354             @Override
3355             public Boolean visitErrorType(ErrorType t, Type s) {
3356                 return false;
3357             }
3358         }
3359 
3360     TypeRelation hasSameArgs_strict = new HasSameArgs(true);
3361         TypeRelation hasSameArgs_nonstrict = new HasSameArgs(false);
3362 
3363     // &lt;/editor-fold&gt;
3364 
3365     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;subst&quot;&gt;
3366     public List&lt;Type&gt; subst(List&lt;Type&gt; ts,
3367                             List&lt;Type&gt; from,
3368                             List&lt;Type&gt; to) {
3369         return ts.map(new Subst(from, to));
3370     }
3371 
3372     /**
3373      * Substitute all occurrences of a type in `from&#39; with the
3374      * corresponding type in `to&#39; in &#39;t&#39;. Match lists `from&#39; and `to&#39;
3375      * from the right: If lists have different length, discard leading
3376      * elements of the longer list.
3377      */
3378     public Type subst(Type t, List&lt;Type&gt; from, List&lt;Type&gt; to) {
3379         return t.map(new Subst(from, to));
3380     }
3381 
3382     private class Subst extends StructuralTypeMapping&lt;Void&gt; {
3383         List&lt;Type&gt; from;
3384         List&lt;Type&gt; to;
3385 
3386         public Subst(List&lt;Type&gt; from, List&lt;Type&gt; to) {
3387             int fromLength = from.length();
3388             int toLength = to.length();
3389             while (fromLength &gt; toLength) {
3390                 fromLength--;
3391                 from = from.tail;
3392             }
3393             while (fromLength &lt; toLength) {
3394                 toLength--;
3395                 to = to.tail;
3396             }
3397             this.from = from;
3398             this.to = to;
3399         }
3400 
3401         @Override
3402         public Type visitTypeVar(TypeVar t, Void ignored) {
3403             for (List&lt;Type&gt; from = this.from, to = this.to;
3404                  from.nonEmpty();
3405                  from = from.tail, to = to.tail) {
3406                 if (t.equalsIgnoreMetadata(from.head)) {
3407                     return to.head.withTypeVar(t);
3408                 }
3409             }
3410             return t;
3411         }
3412 
3413         @Override
3414         public Type visitClassType(ClassType t, Void ignored) {
3415             if (!t.isCompound()) {
3416                 return super.visitClassType(t, ignored);
3417             } else {
3418                 Type st = visit(supertype(t));
3419                 List&lt;Type&gt; is = visit(interfaces(t), ignored);
3420                 if (st == supertype(t) &amp;&amp; is == interfaces(t))
3421                     return t;
3422                 else
3423                     return makeIntersectionType(is.prepend(st));
3424             }
3425         }
3426 
3427         @Override
3428         public Type visitWildcardType(WildcardType t, Void ignored) {
3429             WildcardType t2 = (WildcardType)super.visitWildcardType(t, ignored);
3430             if (t2 != t &amp;&amp; t.isExtendsBound() &amp;&amp; t2.type.isExtendsBound()) {
3431                 t2.type = wildUpperBound(t2.type);
3432             }
3433             return t2;
3434         }
3435 
3436         @Override
3437         public Type visitForAll(ForAll t, Void ignored) {
3438             if (Type.containsAny(to, t.tvars)) {
3439                 //perform alpha-renaming of free-variables in &#39;t&#39;
3440                 //if &#39;to&#39; types contain variables that are free in &#39;t&#39;
3441                 List&lt;Type&gt; freevars = newInstances(t.tvars);
3442                 t = new ForAll(freevars,
3443                                Types.this.subst(t.qtype, t.tvars, freevars));
3444             }
3445             List&lt;Type&gt; tvars1 = substBounds(t.tvars, from, to);
3446             Type qtype1 = visit(t.qtype);
3447             if (tvars1 == t.tvars &amp;&amp; qtype1 == t.qtype) {
3448                 return t;
3449             } else if (tvars1 == t.tvars) {
3450                 return new ForAll(tvars1, qtype1) {
3451                     @Override
3452                     public boolean needsStripping() {
3453                         return true;
3454                     }
3455                 };
3456             } else {
3457                 return new ForAll(tvars1, Types.this.subst(qtype1, t.tvars, tvars1)) {
3458                     @Override
3459                     public boolean needsStripping() {
3460                         return true;
3461                     }
3462                 };
3463             }
3464         }
3465     }
3466 
3467     public List&lt;Type&gt; substBounds(List&lt;Type&gt; tvars,
3468                                   List&lt;Type&gt; from,
3469                                   List&lt;Type&gt; to) {
3470         if (tvars.isEmpty())
3471             return tvars;
3472         ListBuffer&lt;Type&gt; newBoundsBuf = new ListBuffer&lt;&gt;();
3473         boolean changed = false;
3474         // calculate new bounds
3475         for (Type t : tvars) {
3476             TypeVar tv = (TypeVar) t;
3477             Type bound = subst(tv.getUpperBound(), from, to);
3478             if (bound != tv.getUpperBound())
3479                 changed = true;
3480             newBoundsBuf.append(bound);
3481         }
3482         if (!changed)
3483             return tvars;
3484         ListBuffer&lt;Type&gt; newTvars = new ListBuffer&lt;&gt;();
3485         // create new type variables without bounds
3486         for (Type t : tvars) {
3487             newTvars.append(new TypeVar(t.tsym, null, syms.botType,
3488                                         t.getMetadata()));
3489         }
3490         // the new bounds should use the new type variables in place
3491         // of the old
3492         List&lt;Type&gt; newBounds = newBoundsBuf.toList();
3493         from = tvars;
3494         to = newTvars.toList();
3495         for (; !newBounds.isEmpty(); newBounds = newBounds.tail) {
3496             newBounds.head = subst(newBounds.head, from, to);
3497         }
3498         newBounds = newBoundsBuf.toList();
3499         // set the bounds of new type variables to the new bounds
3500         for (Type t : newTvars.toList()) {
3501             TypeVar tv = (TypeVar) t;
3502             tv.setUpperBound( newBounds.head );
3503             newBounds = newBounds.tail;
3504         }
3505         return newTvars.toList();
3506     }
3507 
3508     public TypeVar substBound(TypeVar t, List&lt;Type&gt; from, List&lt;Type&gt; to) {
3509         Type bound1 = subst(t.getUpperBound(), from, to);
3510         if (bound1 == t.getUpperBound())
3511             return t;
3512         else {
3513             // create new type variable without bounds
3514             TypeVar tv = new TypeVar(t.tsym, null, syms.botType,
3515                                      t.getMetadata());
3516             // the new bound should use the new type variable in place
3517             // of the old
3518             tv.setUpperBound( subst(bound1, List.of(t), List.of(tv)) );
3519             return tv;
3520         }
3521     }
3522     // &lt;/editor-fold&gt;
3523 
3524     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;hasSameBounds&quot;&gt;
3525     /**
3526      * Does t have the same bounds for quantified variables as s?
3527      */
3528     public boolean hasSameBounds(ForAll t, ForAll s) {
3529         List&lt;Type&gt; l1 = t.tvars;
3530         List&lt;Type&gt; l2 = s.tvars;
3531         while (l1.nonEmpty() &amp;&amp; l2.nonEmpty() &amp;&amp;
3532                isSameType(l1.head.getUpperBound(),
3533                           subst(l2.head.getUpperBound(),
3534                                 s.tvars,
3535                                 t.tvars))) {
3536             l1 = l1.tail;
3537             l2 = l2.tail;
3538         }
3539         return l1.isEmpty() &amp;&amp; l2.isEmpty();
3540     }
3541     // &lt;/editor-fold&gt;
3542 
3543     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;newInstances&quot;&gt;
3544     /** Create new vector of type variables from list of variables
3545      *  changing all recursive bounds from old to new list.
3546      */
3547     public List&lt;Type&gt; newInstances(List&lt;Type&gt; tvars) {
3548         List&lt;Type&gt; tvars1 = tvars.map(newInstanceFun);
3549         for (List&lt;Type&gt; l = tvars1; l.nonEmpty(); l = l.tail) {
3550             TypeVar tv = (TypeVar) l.head;
3551             tv.setUpperBound( subst(tv.getUpperBound(), tvars, tvars1) );
3552         }
3553         return tvars1;
3554     }
3555         private static final TypeMapping&lt;Void&gt; newInstanceFun = new TypeMapping&lt;Void&gt;() {
3556             @Override
3557             public TypeVar visitTypeVar(TypeVar t, Void _unused) {
3558                 return new TypeVar(t.tsym, t.getUpperBound(), t.getLowerBound(), t.getMetadata());
3559             }
3560         };
3561     // &lt;/editor-fold&gt;
3562 
3563     public Type createMethodTypeWithParameters(Type original, List&lt;Type&gt; newParams) {
3564         return original.accept(methodWithParameters, newParams);
3565     }
3566     // where
3567         private final MapVisitor&lt;List&lt;Type&gt;&gt; methodWithParameters = new MapVisitor&lt;List&lt;Type&gt;&gt;() {
3568             public Type visitType(Type t, List&lt;Type&gt; newParams) {
3569                 throw new IllegalArgumentException(&quot;Not a method type: &quot; + t);
3570             }
3571             public Type visitMethodType(MethodType t, List&lt;Type&gt; newParams) {
3572                 return new MethodType(newParams, t.restype, t.thrown, t.tsym);
3573             }
3574             public Type visitForAll(ForAll t, List&lt;Type&gt; newParams) {
3575                 return new ForAll(t.tvars, t.qtype.accept(this, newParams));
3576             }
3577         };
3578 
3579     public Type createMethodTypeWithThrown(Type original, List&lt;Type&gt; newThrown) {
3580         return original.accept(methodWithThrown, newThrown);
3581     }
3582     // where
3583         private final MapVisitor&lt;List&lt;Type&gt;&gt; methodWithThrown = new MapVisitor&lt;List&lt;Type&gt;&gt;() {
3584             public Type visitType(Type t, List&lt;Type&gt; newThrown) {
3585                 throw new IllegalArgumentException(&quot;Not a method type: &quot; + t);
3586             }
3587             public Type visitMethodType(MethodType t, List&lt;Type&gt; newThrown) {
3588                 return new MethodType(t.argtypes, t.restype, newThrown, t.tsym);
3589             }
3590             public Type visitForAll(ForAll t, List&lt;Type&gt; newThrown) {
3591                 return new ForAll(t.tvars, t.qtype.accept(this, newThrown));
3592             }
3593         };
3594 
3595     public Type createMethodTypeWithReturn(Type original, Type newReturn) {
3596         return original.accept(methodWithReturn, newReturn);
3597     }
3598     // where
3599         private final MapVisitor&lt;Type&gt; methodWithReturn = new MapVisitor&lt;Type&gt;() {
3600             public Type visitType(Type t, Type newReturn) {
3601                 throw new IllegalArgumentException(&quot;Not a method type: &quot; + t);
3602             }
3603             public Type visitMethodType(MethodType t, Type newReturn) {
3604                 return new MethodType(t.argtypes, newReturn, t.thrown, t.tsym) {
3605                     @Override
3606                     public Type baseType() {
3607                         return t;
3608                     }
3609                 };
3610             }
3611             public Type visitForAll(ForAll t, Type newReturn) {
3612                 return new ForAll(t.tvars, t.qtype.accept(this, newReturn)) {
3613                     @Override
3614                     public Type baseType() {
3615                         return t;
3616                     }
3617                 };
3618             }
3619         };
3620 
3621     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;createErrorType&quot;&gt;
3622     public Type createErrorType(Type originalType) {
3623         return new ErrorType(originalType, syms.errSymbol);
3624     }
3625 
3626     public Type createErrorType(ClassSymbol c, Type originalType) {
3627         return new ErrorType(c, originalType);
3628     }
3629 
3630     public Type createErrorType(Name name, TypeSymbol container, Type originalType) {
3631         return new ErrorType(name, container, originalType);
3632     }
3633     // &lt;/editor-fold&gt;
3634 
3635     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;rank&quot;&gt;
3636     /**
3637      * The rank of a class is the length of the longest path between
3638      * the class and java.lang.Object in the class inheritance
3639      * graph. Undefined for all but reference types.
3640      */
3641     public int rank(Type t) {
3642         switch(t.getTag()) {
3643         case CLASS: {
3644             ClassType cls = (ClassType)t;
3645             if (cls.rank_field &lt; 0) {
3646                 Name fullname = cls.tsym.getQualifiedName();
3647                 if (fullname == names.java_lang_Object)
3648                     cls.rank_field = 0;
3649                 else {
3650                     int r = rank(supertype(cls));
3651                     for (List&lt;Type&gt; l = interfaces(cls);
3652                          l.nonEmpty();
3653                          l = l.tail) {
3654                         if (rank(l.head) &gt; r)
3655                             r = rank(l.head);
3656                     }
3657                     cls.rank_field = r + 1;
3658                 }
3659             }
3660             return cls.rank_field;
3661         }
3662         case TYPEVAR: {
3663             TypeVar tvar = (TypeVar)t;
3664             if (tvar.rank_field &lt; 0) {
3665                 int r = rank(supertype(tvar));
3666                 for (List&lt;Type&gt; l = interfaces(tvar);
3667                      l.nonEmpty();
3668                      l = l.tail) {
3669                     if (rank(l.head) &gt; r) r = rank(l.head);
3670                 }
3671                 tvar.rank_field = r + 1;
3672             }
3673             return tvar.rank_field;
3674         }
3675         case ERROR:
3676         case NONE:
3677             return 0;
3678         default:
3679             throw new AssertionError();
3680         }
3681     }
3682     // &lt;/editor-fold&gt;
3683 
3684     /**
3685      * Helper method for generating a string representation of a given type
3686      * accordingly to a given locale
3687      */
3688     public String toString(Type t, Locale locale) {
3689         return Printer.createStandardPrinter(messages).visit(t, locale);
3690     }
3691 
3692     /**
3693      * Helper method for generating a string representation of a given type
3694      * accordingly to a given locale
3695      */
3696     public String toString(Symbol t, Locale locale) {
3697         return Printer.createStandardPrinter(messages).visit(t, locale);
3698     }
3699 
3700     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;toString&quot;&gt;
3701     /**
3702      * This toString is slightly more descriptive than the one on Type.
3703      *
3704      * @deprecated Types.toString(Type t, Locale l) provides better support
3705      * for localization
3706      */
3707     @Deprecated
3708     public String toString(Type t) {
3709         if (t.hasTag(FORALL)) {
3710             ForAll forAll = (ForAll)t;
3711             return typaramsString(forAll.tvars) + forAll.qtype;
3712         }
3713         return &quot;&quot; + t;
3714     }
3715     // where
3716         private String typaramsString(List&lt;Type&gt; tvars) {
3717             StringBuilder s = new StringBuilder();
3718             s.append(&#39;&lt;&#39;);
3719             boolean first = true;
3720             for (Type t : tvars) {
3721                 if (!first) s.append(&quot;, &quot;);
3722                 first = false;
3723                 appendTyparamString(((TypeVar)t), s);
3724             }
3725             s.append(&#39;&gt;&#39;);
3726             return s.toString();
3727         }
3728         private void appendTyparamString(TypeVar t, StringBuilder buf) {
3729             buf.append(t);
3730             if (t.getUpperBound() == null ||
3731                 t.getUpperBound().tsym.getQualifiedName() == names.java_lang_Object)
3732                 return;
3733             buf.append(&quot; extends &quot;); // Java syntax; no need for i18n
3734             Type bound = t.getUpperBound();
3735             if (!bound.isCompound()) {
3736                 buf.append(bound);
3737             } else if ((erasure(t).tsym.flags() &amp; INTERFACE) == 0) {
3738                 buf.append(supertype(t));
3739                 for (Type intf : interfaces(t)) {
3740                     buf.append(&#39;&amp;&#39;);
3741                     buf.append(intf);
3742                 }
3743             } else {
3744                 // No superclass was given in bounds.
3745                 // In this case, supertype is Object, erasure is first interface.
3746                 boolean first = true;
3747                 for (Type intf : interfaces(t)) {
3748                     if (!first) buf.append(&#39;&amp;&#39;);
3749                     first = false;
3750                     buf.append(intf);
3751                 }
3752             }
3753         }
3754     // &lt;/editor-fold&gt;
3755 
3756     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Determining least upper bounds of types&quot;&gt;
3757     /**
3758      * A cache for closures.
3759      *
3760      * &lt;p&gt;A closure is a list of all the supertypes and interfaces of
3761      * a class or interface type, ordered by ClassSymbol.precedes
3762      * (that is, subclasses come first, arbitrary but fixed
3763      * otherwise).
3764      */
3765     private Map&lt;Type,List&lt;Type&gt;&gt; closureCache = new HashMap&lt;&gt;();
3766 
3767     /**
3768      * Returns the closure of a class or interface type.
3769      */
3770     public List&lt;Type&gt; closure(Type t) {
3771         List&lt;Type&gt; cl = closureCache.get(t);
3772         if (cl == null) {
3773             Type st = supertype(t);
3774             if (!t.isCompound()) {
3775                 if (st.hasTag(CLASS)) {
3776                     cl = insert(closure(st), t);
3777                 } else if (st.hasTag(TYPEVAR)) {
3778                     cl = closure(st).prepend(t);
3779                 } else {
3780                     cl = List.of(t);
3781                 }
3782             } else {
3783                 cl = closure(supertype(t));
3784             }
3785             for (List&lt;Type&gt; l = interfaces(t); l.nonEmpty(); l = l.tail)
3786                 cl = union(cl, closure(l.head));
3787             closureCache.put(t, cl);
3788         }
3789         return cl;
3790     }
3791 
3792     /**
3793      * Collect types into a new closure (using a @code{ClosureHolder})
3794      */
3795     public Collector&lt;Type, ClosureHolder, List&lt;Type&gt;&gt; closureCollector(boolean minClosure, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3796         return Collector.of(() -&gt; new ClosureHolder(minClosure, shouldSkip),
3797                 ClosureHolder::add,
3798                 ClosureHolder::merge,
3799                 ClosureHolder::closure);
3800     }
3801     //where
3802         class ClosureHolder {
3803             List&lt;Type&gt; closure;
3804             final boolean minClosure;
3805             final BiPredicate&lt;Type, Type&gt; shouldSkip;
3806 
3807             ClosureHolder(boolean minClosure, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3808                 this.closure = List.nil();
3809                 this.minClosure = minClosure;
3810                 this.shouldSkip = shouldSkip;
3811             }
3812 
3813             void add(Type type) {
3814                 closure = insert(closure, type, shouldSkip);
3815             }
3816 
3817             ClosureHolder merge(ClosureHolder other) {
3818                 closure = union(closure, other.closure, shouldSkip);
3819                 return this;
3820             }
3821 
3822             List&lt;Type&gt; closure() {
3823                 return minClosure ? closureMin(closure) : closure;
3824             }
3825         }
3826 
3827     BiPredicate&lt;Type, Type&gt; basicClosureSkip = (t1, t2) -&gt; t1.tsym == t2.tsym;
3828 
3829     /**
3830      * Insert a type in a closure
3831      */
3832     public List&lt;Type&gt; insert(List&lt;Type&gt; cl, Type t, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3833         if (cl.isEmpty()) {
3834             return cl.prepend(t);
3835         } else if (shouldSkip.test(t, cl.head)) {
3836             return cl;
3837         } else if (t.tsym.precedes(cl.head.tsym, this)) {
3838             return cl.prepend(t);
3839         } else {
3840             // t comes after head, or the two are unrelated
3841             return insert(cl.tail, t, shouldSkip).prepend(cl.head);
3842         }
3843     }
3844 
3845     public List&lt;Type&gt; insert(List&lt;Type&gt; cl, Type t) {
3846         return insert(cl, t, basicClosureSkip);
3847     }
3848 
3849     /**
3850      * Form the union of two closures
3851      */
3852     public List&lt;Type&gt; union(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2, BiPredicate&lt;Type, Type&gt; shouldSkip) {
3853         if (cl1.isEmpty()) {
3854             return cl2;
3855         } else if (cl2.isEmpty()) {
3856             return cl1;
3857         } else if (shouldSkip.test(cl1.head, cl2.head)) {
3858             return union(cl1.tail, cl2.tail, shouldSkip).prepend(cl1.head);
3859         } else if (cl2.head.tsym.precedes(cl1.head.tsym, this)) {
3860             return union(cl1, cl2.tail, shouldSkip).prepend(cl2.head);
3861         } else {
3862             return union(cl1.tail, cl2, shouldSkip).prepend(cl1.head);
3863         }
3864     }
3865 
3866     public List&lt;Type&gt; union(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2) {
3867         return union(cl1, cl2, basicClosureSkip);
3868     }
3869 
3870     /**
3871      * Intersect two closures
3872      */
3873     public List&lt;Type&gt; intersect(List&lt;Type&gt; cl1, List&lt;Type&gt; cl2) {
3874         if (cl1 == cl2)
3875             return cl1;
3876         if (cl1.isEmpty() || cl2.isEmpty())
3877             return List.nil();
3878         if (cl1.head.tsym.precedes(cl2.head.tsym, this))
3879             return intersect(cl1.tail, cl2);
3880         if (cl2.head.tsym.precedes(cl1.head.tsym, this))
3881             return intersect(cl1, cl2.tail);
3882         if (isSameType(cl1.head, cl2.head))
3883             return intersect(cl1.tail, cl2.tail).prepend(cl1.head);
3884         if (cl1.head.tsym == cl2.head.tsym &amp;&amp;
3885             cl1.head.hasTag(CLASS) &amp;&amp; cl2.head.hasTag(CLASS)) {
3886             if (cl1.head.isParameterized() &amp;&amp; cl2.head.isParameterized()) {
3887                 Type merge = merge(cl1.head,cl2.head);
3888                 return intersect(cl1.tail, cl2.tail).prepend(merge);
3889             }
3890             if (cl1.head.isRaw() || cl2.head.isRaw())
3891                 return intersect(cl1.tail, cl2.tail).prepend(erasure(cl1.head));
3892         }
3893         return intersect(cl1.tail, cl2.tail);
3894     }
3895     // where
3896         class TypePair {
3897             final Type t1;
3898             final Type t2;;
3899 
3900             TypePair(Type t1, Type t2) {
3901                 this.t1 = t1;
3902                 this.t2 = t2;
3903             }
3904             @Override
3905             public int hashCode() {
3906                 return 127 * Types.this.hashCode(t1) + Types.this.hashCode(t2);
3907             }
3908             @Override
3909             public boolean equals(Object obj) {
3910                 if (!(obj instanceof TypePair))
3911                     return false;
3912                 TypePair typePair = (TypePair)obj;
3913                 return isSameType(t1, typePair.t1)
3914                     &amp;&amp; isSameType(t2, typePair.t2);
3915             }
3916         }
3917         Set&lt;TypePair&gt; mergeCache = new HashSet&lt;&gt;();
3918         private Type merge(Type c1, Type c2) {
3919             ClassType class1 = (ClassType) c1;
3920             List&lt;Type&gt; act1 = class1.getTypeArguments();
3921             ClassType class2 = (ClassType) c2;
3922             List&lt;Type&gt; act2 = class2.getTypeArguments();
3923             ListBuffer&lt;Type&gt; merged = new ListBuffer&lt;&gt;();
3924             List&lt;Type&gt; typarams = class1.tsym.type.getTypeArguments();
3925 
3926             while (act1.nonEmpty() &amp;&amp; act2.nonEmpty() &amp;&amp; typarams.nonEmpty()) {
3927                 if (containsType(act1.head, act2.head)) {
3928                     merged.append(act1.head);
3929                 } else if (containsType(act2.head, act1.head)) {
3930                     merged.append(act2.head);
3931                 } else {
3932                     TypePair pair = new TypePair(c1, c2);
3933                     Type m;
3934                     if (mergeCache.add(pair)) {
3935                         m = new WildcardType(lub(wildUpperBound(act1.head),
3936                                                  wildUpperBound(act2.head)),
3937                                              BoundKind.EXTENDS,
3938                                              syms.boundClass);
3939                         mergeCache.remove(pair);
3940                     } else {
3941                         m = new WildcardType(syms.objectType,
3942                                              BoundKind.UNBOUND,
3943                                              syms.boundClass);
3944                     }
3945                     merged.append(m.withTypeVar(typarams.head));
3946                 }
3947                 act1 = act1.tail;
3948                 act2 = act2.tail;
3949                 typarams = typarams.tail;
3950             }
3951             Assert.check(act1.isEmpty() &amp;&amp; act2.isEmpty() &amp;&amp; typarams.isEmpty());
3952             // There is no spec detailing how type annotations are to
3953             // be inherited.  So set it to noAnnotations for now
3954             return new ClassType(class1.getEnclosingType(), merged.toList(),
3955                                  class1.tsym);
3956         }
3957 
3958     /**
3959      * Return the minimum type of a closure, a compound type if no
3960      * unique minimum exists.
3961      */
3962     private Type compoundMin(List&lt;Type&gt; cl) {
3963         if (cl.isEmpty()) return syms.objectType;
3964         List&lt;Type&gt; compound = closureMin(cl);
3965         if (compound.isEmpty())
3966             return null;
3967         else if (compound.tail.isEmpty())
3968             return compound.head;
3969         else
3970             return makeIntersectionType(compound);
3971     }
3972 
3973     /**
3974      * Return the minimum types of a closure, suitable for computing
3975      * compoundMin or glb.
3976      */
3977     private List&lt;Type&gt; closureMin(List&lt;Type&gt; cl) {
3978         ListBuffer&lt;Type&gt; classes = new ListBuffer&lt;&gt;();
3979         ListBuffer&lt;Type&gt; interfaces = new ListBuffer&lt;&gt;();
3980         Set&lt;Type&gt; toSkip = new HashSet&lt;&gt;();
3981         while (!cl.isEmpty()) {
3982             Type current = cl.head;
3983             boolean keep = !toSkip.contains(current);
3984             if (keep &amp;&amp; current.hasTag(TYPEVAR)) {
3985                 // skip lower-bounded variables with a subtype in cl.tail
3986                 for (Type t : cl.tail) {
3987                     if (isSubtypeNoCapture(t, current)) {
3988                         keep = false;
3989                         break;
3990                     }
3991                 }
3992             }
3993             if (keep) {
3994                 if (current.isInterface())
3995                     interfaces.append(current);
3996                 else
3997                     classes.append(current);
3998                 for (Type t : cl.tail) {
3999                     // skip supertypes of &#39;current&#39; in cl.tail
4000                     if (isSubtypeNoCapture(current, t))
4001                         toSkip.add(t);
4002                 }
4003             }
4004             cl = cl.tail;
4005         }
4006         return classes.appendList(interfaces).toList();
4007     }
4008 
4009     /**
4010      * Return the least upper bound of list of types.  if the lub does
4011      * not exist return null.
4012      */
4013     public Type lub(List&lt;Type&gt; ts) {
4014         return lub(ts.toArray(new Type[ts.length()]));
4015     }
4016 
4017     /**
4018      * Return the least upper bound (lub) of set of types.  If the lub
4019      * does not exist return the type of null (bottom).
4020      */
4021     public Type lub(Type... ts) {
4022         final int UNKNOWN_BOUND = 0;
4023         final int ARRAY_BOUND = 1;
4024         final int CLASS_BOUND = 2;
4025 
4026         int[] kinds = new int[ts.length];
4027 
4028         boolean haveValues = false;
4029         boolean haveRefs = false;
4030         for (int i = 0 ; i &lt; ts.length ; i++) {
4031             if (ts[i].isValue())
4032                 haveValues = true;
4033             else
4034                 haveRefs = true;
4035         }
4036         if (haveRefs &amp;&amp; haveValues) {
4037             System.arraycopy(ts, 0, ts = new Type[ts.length], 0, ts.length);
4038             for (int i = 0; i &lt; ts.length; i++) {
4039                 if (ts[i].isValue())
4040                     ts[i] = ts[i].referenceProjection();
4041             }
4042         }
4043 
4044         int boundkind = UNKNOWN_BOUND;
4045         for (int i = 0 ; i &lt; ts.length ; i++) {
4046             Type t = ts[i];
4047             switch (t.getTag()) {
4048             case CLASS:
4049                 boundkind |= kinds[i] = CLASS_BOUND;
4050                 break;
4051             case ARRAY:
4052                 boundkind |= kinds[i] = ARRAY_BOUND;
4053                 break;
4054             case  TYPEVAR:
4055                 do {
4056                     t = t.getUpperBound();
4057                 } while (t.hasTag(TYPEVAR));
4058                 if (t.hasTag(ARRAY)) {
4059                     boundkind |= kinds[i] = ARRAY_BOUND;
4060                 } else {
4061                     boundkind |= kinds[i] = CLASS_BOUND;
4062                 }
4063                 break;
4064             default:
4065                 kinds[i] = UNKNOWN_BOUND;
4066                 if (t.isPrimitive())
4067                     return syms.errType;
4068             }
4069         }
4070         switch (boundkind) {
4071         case 0:
4072             return syms.botType;
4073 
4074         case ARRAY_BOUND:
4075             // calculate lub(A[], B[])
4076             Type[] elements = new Type[ts.length];
4077             for (int i = 0 ; i &lt; ts.length ; i++) {
4078                 Type elem = elements[i] = elemTypeFun.apply(ts[i]);
4079                 if (elem.isPrimitive()) {
4080                     // if a primitive type is found, then return
4081                     // arraySuperType unless all the types are the
4082                     // same
4083                     Type first = ts[0];
4084                     for (int j = 1 ; j &lt; ts.length ; j++) {
4085                         if (!isSameType(first, ts[j])) {
4086                              // lub(int[], B[]) is Cloneable &amp; Serializable
4087                             return arraySuperType();
4088                         }
4089                     }
4090                     // all the array types are the same, return one
4091                     // lub(int[], int[]) is int[]
4092                     return first;
4093                 }
4094             }
4095             // lub(A[], B[]) is lub(A, B)[]
4096             return new ArrayType(lub(elements), syms.arrayClass);
4097 
4098         case CLASS_BOUND:
4099             // calculate lub(A, B)
4100             int startIdx = 0;
4101             for (int i = 0; i &lt; ts.length ; i++) {
4102                 Type t = ts[i];
4103                 if (t.hasTag(CLASS) || t.hasTag(TYPEVAR)) {
4104                     break;
4105                 } else {
4106                     startIdx++;
4107                 }
4108             }
4109             Assert.check(startIdx &lt; ts.length);
4110             //step 1 - compute erased candidate set (EC)
4111             List&lt;Type&gt; cl = erasedSupertypes(ts[startIdx]);
4112             for (int i = startIdx + 1 ; i &lt; ts.length ; i++) {
4113                 Type t = ts[i];
4114                 if (t.hasTag(CLASS) || t.hasTag(TYPEVAR))
4115                     cl = intersect(cl, erasedSupertypes(t));
4116             }
4117             //step 2 - compute minimal erased candidate set (MEC)
4118             List&lt;Type&gt; mec = closureMin(cl);
4119             //step 3 - for each element G in MEC, compute lci(Inv(G))
4120             List&lt;Type&gt; candidates = List.nil();
4121             for (Type erasedSupertype : mec) {
4122                 List&lt;Type&gt; lci = List.of(asSuper(ts[startIdx], erasedSupertype.tsym));
4123                 for (int i = startIdx + 1 ; i &lt; ts.length ; i++) {
4124                     Type superType = asSuper(ts[i], erasedSupertype.tsym);
4125                     lci = intersect(lci, superType != null ? List.of(superType) : List.nil());
4126                 }
4127                 candidates = candidates.appendList(lci);
4128             }
4129             //step 4 - let MEC be { G1, G2 ... Gn }, then we have that
4130             //lub = lci(Inv(G1)) &amp; lci(Inv(G2)) &amp; ... &amp; lci(Inv(Gn))
4131             return compoundMin(candidates);
4132 
4133         default:
4134             // calculate lub(A, B[])
4135             List&lt;Type&gt; classes = List.of(arraySuperType());
4136             for (int i = 0 ; i &lt; ts.length ; i++) {
4137                 if (kinds[i] != ARRAY_BOUND) // Filter out any arrays
4138                     classes = classes.prepend(ts[i]);
4139             }
4140             // lub(A, B[]) is lub(A, arraySuperType)
4141             return lub(classes);
4142         }
4143     }
4144     // where
4145         List&lt;Type&gt; erasedSupertypes(Type t) {
4146             ListBuffer&lt;Type&gt; buf = new ListBuffer&lt;&gt;();
4147             for (Type sup : closure(t)) {
4148                 if (sup.hasTag(TYPEVAR)) {
4149                     buf.append(sup);
4150                 } else {
4151                     buf.append(erasure(sup));
4152                 }
4153             }
4154             return buf.toList();
4155         }
4156 
4157         private Type arraySuperType = null;
4158         private Type arraySuperType() {
4159             // initialized lazily to avoid problems during compiler startup
4160             if (arraySuperType == null) {
4161                 synchronized (this) {
4162                     if (arraySuperType == null) {
4163                         // JLS 10.8: all arrays implement Cloneable and Serializable.
4164                         List&lt;Type&gt; ifaces = injectTopInterfaceTypes ?
4165                                 List.of(syms.serializableType, syms.cloneableType, syms.identityObjectType):
4166                                 List.of(syms.serializableType, syms.cloneableType);
4167                         arraySuperType = makeIntersectionType(ifaces, true);
4168                     }
4169                 }
4170             }
4171             return arraySuperType;
4172         }
4173     // &lt;/editor-fold&gt;
4174 
4175     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Greatest lower bound&quot;&gt;
4176     public Type glb(List&lt;Type&gt; ts) {
4177         Type t1 = ts.head;
4178         for (Type t2 : ts.tail) {
4179             if (t1.isErroneous())
4180                 return t1;
4181             t1 = glb(t1, t2);
4182         }
4183         return t1;
4184     }
4185     //where
4186     public Type glb(Type t, Type s) {
4187         if (s == null)
4188             return t;
4189         else if (t.isPrimitive() || s.isPrimitive())
4190             return syms.errType;
4191         else if (isSubtypeNoCapture(t, s))
4192             return t;
4193         else if (isSubtypeNoCapture(s, t))
4194             return s;
4195 
4196         List&lt;Type&gt; closure = union(closure(t), closure(s));
4197         return glbFlattened(closure, t);
4198     }
4199     //where
4200     /**
4201      * Perform glb for a list of non-primitive, non-error, non-compound types;
4202      * redundant elements are removed.  Bounds should be ordered according to
4203      * {@link Symbol#precedes(TypeSymbol,Types)}.
4204      *
4205      * @param flatBounds List of type to glb
4206      * @param errT Original type to use if the result is an error type
4207      */
4208     private Type glbFlattened(List&lt;Type&gt; flatBounds, Type errT) {
4209         List&lt;Type&gt; bounds = closureMin(flatBounds);
4210 
4211         if (bounds.isEmpty()) {             // length == 0
4212             return syms.objectType;
4213         } else if (bounds.tail.isEmpty()) { // length == 1
4214             return bounds.head;
4215         } else {                            // length &gt; 1
4216             int classCount = 0;
4217             List&lt;Type&gt; cvars = List.nil();
4218             List&lt;Type&gt; lowers = List.nil();
4219             for (Type bound : bounds) {
4220                 if (!bound.isInterface()) {
4221                     classCount++;
4222                     Type lower = cvarLowerBound(bound);
4223                     if (bound != lower &amp;&amp; !lower.hasTag(BOT)) {
4224                         cvars = cvars.append(bound);
4225                         lowers = lowers.append(lower);
4226                     }
4227                 }
4228             }
4229             if (classCount &gt; 1) {
4230                 if (lowers.isEmpty()) {
4231                     return createErrorType(errT);
4232                 } else {
4233                     // try again with lower bounds included instead of capture variables
4234                     List&lt;Type&gt; newBounds = bounds.diff(cvars).appendList(lowers);
4235                     return glb(newBounds);
4236                 }
4237             }
4238         }
4239         return makeIntersectionType(bounds);
4240     }
4241     // &lt;/editor-fold&gt;
4242 
4243     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;hashCode&quot;&gt;
4244     /**
4245      * Compute a hash code on a type.
4246      */
4247     public int hashCode(Type t) {
4248         return hashCode(t, false);
4249     }
4250 
4251     public int hashCode(Type t, boolean strict) {
4252         return strict ?
4253                 hashCodeStrictVisitor.visit(t) :
4254                 hashCodeVisitor.visit(t);
4255     }
4256     // where
4257         private static final HashCodeVisitor hashCodeVisitor = new HashCodeVisitor();
4258         private static final HashCodeVisitor hashCodeStrictVisitor = new HashCodeVisitor() {
4259             @Override
4260             public Integer visitTypeVar(TypeVar t, Void ignored) {
4261                 return System.identityHashCode(t);
4262             }
4263         };
4264 
4265         private static class HashCodeVisitor extends UnaryVisitor&lt;Integer&gt; {
4266             public Integer visitType(Type t, Void ignored) {
4267                 return t.getTag().ordinal();
4268             }
4269 
4270             @Override
4271             public Integer visitClassType(ClassType t, Void ignored) {
4272                 int result = visit(t.getEnclosingType());
4273                 result *= 127;
4274                 result += t.tsym.flatName().hashCode();
4275                 for (Type s : t.getTypeArguments()) {
4276                     result *= 127;
4277                     result += visit(s);
4278                 }
4279                 return result;
4280             }
4281 
4282             @Override
4283             public Integer visitMethodType(MethodType t, Void ignored) {
4284                 int h = METHOD.ordinal();
4285                 for (List&lt;Type&gt; thisargs = t.argtypes;
4286                      thisargs.tail != null;
4287                      thisargs = thisargs.tail)
4288                     h = (h &lt;&lt; 5) + visit(thisargs.head);
4289                 return (h &lt;&lt; 5) + visit(t.restype);
4290             }
4291 
4292             @Override
4293             public Integer visitWildcardType(WildcardType t, Void ignored) {
4294                 int result = t.kind.hashCode();
4295                 if (t.type != null) {
4296                     result *= 127;
4297                     result += visit(t.type);
4298                 }
4299                 return result;
4300             }
4301 
4302             @Override
4303             public Integer visitArrayType(ArrayType t, Void ignored) {
4304                 return visit(t.elemtype) + 12;
4305             }
4306 
4307             @Override
4308             public Integer visitTypeVar(TypeVar t, Void ignored) {
4309                 return System.identityHashCode(t);
4310             }
4311 
4312             @Override
4313             public Integer visitUndetVar(UndetVar t, Void ignored) {
4314                 return System.identityHashCode(t);
4315             }
4316 
4317             @Override
4318             public Integer visitErrorType(ErrorType t, Void ignored) {
4319                 return 0;
4320             }
4321         }
4322     // &lt;/editor-fold&gt;
4323 
4324     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Return-Type-Substitutable&quot;&gt;
4325     /**
4326      * Does t have a result that is a subtype of the result type of s,
4327      * suitable for covariant returns?  It is assumed that both types
4328      * are (possibly polymorphic) method types.  Monomorphic method
4329      * types are handled in the obvious way.  Polymorphic method types
4330      * require renaming all type variables of one to corresponding
4331      * type variables in the other, where correspondence is by
4332      * position in the type parameter list. */
4333     public boolean resultSubtype(Type t, Type s, Warner warner) {
4334         List&lt;Type&gt; tvars = t.getTypeArguments();
4335         List&lt;Type&gt; svars = s.getTypeArguments();
4336         Type tres = t.getReturnType();
4337         Type sres = subst(s.getReturnType(), svars, tvars);
4338         return covariantReturnType(tres, sres, warner);
4339     }
4340 
4341     /**
4342      * Return-Type-Substitutable.
4343      * @jls 8.4.5 Method Result
4344      */
4345     public boolean returnTypeSubstitutable(Type r1, Type r2) {
4346         if (hasSameArgs(r1, r2))
4347             return resultSubtype(r1, r2, noWarnings);
4348         else
4349             return covariantReturnType(r1.getReturnType(),
4350                                        erasure(r2.getReturnType()),
4351                                        noWarnings);
4352     }
4353 
4354     public boolean returnTypeSubstitutable(Type r1,
4355                                            Type r2, Type r2res,
4356                                            Warner warner) {
4357         if (isSameType(r1.getReturnType(), r2res))
4358             return true;
4359         if (r1.getReturnType().isPrimitive() || r2res.isPrimitive())
4360             return false;
4361 
4362         if (hasSameArgs(r1, r2))
4363             return covariantReturnType(r1.getReturnType(), r2res, warner);
4364         if (isSubtypeUnchecked(r1.getReturnType(), r2res, warner))
4365             return true;
4366         if (!isSubtype(r1.getReturnType(), erasure(r2res)))
4367             return false;
4368         warner.warn(LintCategory.UNCHECKED);
4369         return true;
4370     }
4371 
4372     /**
4373      * Is t an appropriate return type in an overrider for a
4374      * method that returns s?
4375      */
4376     public boolean covariantReturnType(Type t, Type s, Warner warner) {
4377         return
4378             isSameType(t, s) ||
4379             !t.isPrimitive() &amp;&amp;
4380             !s.isPrimitive() &amp;&amp;
4381             isAssignable(t, s, warner);
4382     }
4383     // &lt;/editor-fold&gt;
4384 
4385     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Box/unbox support&quot;&gt;
4386     /**
4387      * Return the class that boxes the given primitive.
4388      */
4389     public ClassSymbol boxedClass(Type t) {
4390         return syms.enterClass(syms.java_base, syms.boxedName[t.getTag().ordinal()]);
4391     }
4392 
4393     /**
4394      * Return the boxed type if &#39;t&#39; is primitive, otherwise return &#39;t&#39; itself.
4395      */
4396     public Type boxedTypeOrType(Type t) {
4397         return t.isPrimitive() ?
4398             boxedClass(t).type :
4399             t;
4400     }
4401 
4402     /**
4403      * Return the primitive type corresponding to a boxed type.
4404      */
4405     public Type unboxedType(Type t) {
4406         for (int i=0; i&lt;syms.boxedName.length; i++) {
4407             Name box = syms.boxedName[i];
4408             if (box != null &amp;&amp;
4409                 asSuper(t, syms.enterClass(syms.java_base, box)) != null)
4410                 return syms.typeOfTag[i];
4411         }
4412         return Type.noType;
4413     }
4414 
4415     /**
4416      * Return the unboxed type if &#39;t&#39; is a boxed class, otherwise return &#39;t&#39; itself.
4417      */
4418     public Type unboxedTypeOrType(Type t) {
4419         Type unboxedType = unboxedType(t);
4420         return unboxedType.hasTag(NONE) ? t : unboxedType;
4421     }
4422     // &lt;/editor-fold&gt;
4423 
4424     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Capture conversion&quot;&gt;
4425     /*
4426      * JLS 5.1.10 Capture Conversion:
4427      *
4428      * Let G name a generic type declaration with n formal type
4429      * parameters A1 ... An with corresponding bounds U1 ... Un. There
4430      * exists a capture conversion from G&lt;T1 ... Tn&gt; to G&lt;S1 ... Sn&gt;,
4431      * where, for 1 &lt;= i &lt;= n:
4432      *
4433      * + If Ti is a wildcard type argument (4.5.1) of the form ? then
4434      *   Si is a fresh type variable whose upper bound is
4435      *   Ui[A1 := S1, ..., An := Sn] and whose lower bound is the null
4436      *   type.
4437      *
4438      * + If Ti is a wildcard type argument of the form ? extends Bi,
4439      *   then Si is a fresh type variable whose upper bound is
4440      *   glb(Bi, Ui[A1 := S1, ..., An := Sn]) and whose lower bound is
4441      *   the null type, where glb(V1,... ,Vm) is V1 &amp; ... &amp; Vm. It is
4442      *   a compile-time error if for any two classes (not interfaces)
4443      *   Vi and Vj,Vi is not a subclass of Vj or vice versa.
4444      *
4445      * + If Ti is a wildcard type argument of the form ? super Bi,
4446      *   then Si is a fresh type variable whose upper bound is
4447      *   Ui[A1 := S1, ..., An := Sn] and whose lower bound is Bi.
4448      *
4449      * + Otherwise, Si = Ti.
4450      *
4451      * Capture conversion on any type other than a parameterized type
4452      * (4.5) acts as an identity conversion (5.1.1). Capture
4453      * conversions never require a special action at run time and
4454      * therefore never throw an exception at run time.
4455      *
4456      * Capture conversion is not applied recursively.
4457      */
4458     /**
4459      * Capture conversion as specified by the JLS.
4460      */
4461 
4462     public List&lt;Type&gt; capture(List&lt;Type&gt; ts) {
4463         List&lt;Type&gt; buf = List.nil();
4464         for (Type t : ts) {
4465             buf = buf.prepend(capture(t));
4466         }
4467         return buf.reverse();
4468     }
4469 
4470     public Type capture(Type t) {
4471         if (!t.hasTag(CLASS)) {
4472             return t;
4473         }
4474         if (t.getEnclosingType() != Type.noType) {
4475             Type capturedEncl = capture(t.getEnclosingType());
4476             if (capturedEncl != t.getEnclosingType()) {
4477                 Type type1 = memberType(capturedEncl, t.tsym);
4478                 t = subst(type1, t.tsym.type.getTypeArguments(), t.getTypeArguments());
4479             }
4480         }
4481         ClassType cls = (ClassType)t;
4482         if (cls.isRaw() || !cls.isParameterized())
4483             return cls;
4484 
4485         ClassType G = (ClassType)cls.asElement().asType();
4486         List&lt;Type&gt; A = G.getTypeArguments();
4487         List&lt;Type&gt; T = cls.getTypeArguments();
4488         List&lt;Type&gt; S = freshTypeVariables(T);
4489 
4490         List&lt;Type&gt; currentA = A;
4491         List&lt;Type&gt; currentT = T;
4492         List&lt;Type&gt; currentS = S;
4493         boolean captured = false;
4494         while (!currentA.isEmpty() &amp;&amp;
4495                !currentT.isEmpty() &amp;&amp;
4496                !currentS.isEmpty()) {
4497             if (currentS.head != currentT.head) {
4498                 captured = true;
4499                 WildcardType Ti = (WildcardType)currentT.head;
4500                 Type Ui = currentA.head.getUpperBound();
4501                 CapturedType Si = (CapturedType)currentS.head;
4502                 if (Ui == null)
4503                     Ui = syms.objectType;
4504                 switch (Ti.kind) {
4505                 case UNBOUND:
4506                     Si.setUpperBound( subst(Ui, A, S) );
4507                     Si.lower = syms.botType;
4508                     break;
4509                 case EXTENDS:
4510                     Si.setUpperBound( glb(Ti.getExtendsBound(), subst(Ui, A, S)) );
4511                     Si.lower = syms.botType;
4512                     break;
4513                 case SUPER:
4514                     Si.setUpperBound( subst(Ui, A, S) );
4515                     Si.lower = Ti.getSuperBound();
4516                     break;
4517                 }
4518                 Type tmpBound = Si.getUpperBound().hasTag(UNDETVAR) ? ((UndetVar)Si.getUpperBound()).qtype : Si.getUpperBound();
4519                 Type tmpLower = Si.lower.hasTag(UNDETVAR) ? ((UndetVar)Si.lower).qtype : Si.lower;
4520                 if (!Si.getUpperBound().hasTag(ERROR) &amp;&amp;
4521                     !Si.lower.hasTag(ERROR) &amp;&amp;
4522                     isSameType(tmpBound, tmpLower)) {
4523                     currentS.head = Si.getUpperBound();
4524                 }
4525             }
4526             currentA = currentA.tail;
4527             currentT = currentT.tail;
4528             currentS = currentS.tail;
4529         }
4530         if (!currentA.isEmpty() || !currentT.isEmpty() || !currentS.isEmpty())
4531             return erasure(t); // some &quot;rare&quot; type involved
4532 
4533         if (captured)
4534             return new ClassType(cls.getEnclosingType(), S, cls.tsym,
4535                                  cls.getMetadata());
4536         else
4537             return t;
4538     }
4539     // where
4540         public List&lt;Type&gt; freshTypeVariables(List&lt;Type&gt; types) {
4541             ListBuffer&lt;Type&gt; result = new ListBuffer&lt;&gt;();
4542             for (Type t : types) {
4543                 if (t.hasTag(WILDCARD)) {
4544                     Type bound = ((WildcardType)t).getExtendsBound();
4545                     if (bound == null)
4546                         bound = syms.objectType;
4547                     result.append(new CapturedType(capturedName,
4548                                                    syms.noSymbol,
4549                                                    bound,
4550                                                    syms.botType,
4551                                                    (WildcardType)t));
4552                 } else {
4553                     result.append(t);
4554                 }
4555             }
4556             return result.toList();
4557         }
4558     // &lt;/editor-fold&gt;
4559 
4560     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Internal utility methods&quot;&gt;
4561     private boolean sideCast(Type from, Type to, Warner warn) {
4562         // We are casting from type $from$ to type $to$, which are
4563         // non-final unrelated types.  This method
4564         // tries to reject a cast by transferring type parameters
4565         // from $to$ to $from$ by common superinterfaces.
4566         boolean reverse = false;
4567         Type target = to;
4568         if ((to.tsym.flags() &amp; INTERFACE) == 0) {
4569             Assert.check((from.tsym.flags() &amp; INTERFACE) != 0);
4570             reverse = true;
4571             to = from;
4572             from = target;
4573         }
4574         List&lt;Type&gt; commonSupers = superClosure(to, erasure(from));
4575         boolean giveWarning = commonSupers.isEmpty();
4576         // The arguments to the supers could be unified here to
4577         // get a more accurate analysis
4578         while (commonSupers.nonEmpty()) {
4579             Type t1 = asSuper(from, commonSupers.head.tsym);
4580             Type t2 = commonSupers.head; // same as asSuper(to, commonSupers.head.tsym);
4581             if (disjointTypes(t1.getTypeArguments(), t2.getTypeArguments()))
4582                 return false;
4583             giveWarning = giveWarning || (reverse ? giveWarning(t2, t1) : giveWarning(t1, t2));
4584             commonSupers = commonSupers.tail;
4585         }
4586         if (giveWarning &amp;&amp; !isReifiable(reverse ? from : to))
4587             warn.warn(LintCategory.UNCHECKED);
4588         return true;
4589     }
4590 
4591     private boolean sideCastFinal(Type from, Type to, Warner warn) {
4592         // We are casting from type $from$ to type $to$, which are
4593         // unrelated types one of which is final and the other of
4594         // which is an interface.  This method
4595         // tries to reject a cast by transferring type parameters
4596         // from the final class to the interface.
4597         boolean reverse = false;
4598         Type target = to;
4599         if ((to.tsym.flags() &amp; INTERFACE) == 0) {
4600             Assert.check((from.tsym.flags() &amp; INTERFACE) != 0);
4601             reverse = true;
4602             to = from;
4603             from = target;
4604         }
4605         Assert.check((from.tsym.flags() &amp; FINAL) != 0);
4606         Type t1 = asSuper(from, to.tsym);
4607         if (t1 == null) return false;
4608         Type t2 = to;
4609         if (disjointTypes(t1.getTypeArguments(), t2.getTypeArguments()))
4610             return false;
4611         if (!isReifiable(target) &amp;&amp;
4612             (reverse ? giveWarning(t2, t1) : giveWarning(t1, t2)))
4613             warn.warn(LintCategory.UNCHECKED);
4614         return true;
4615     }
4616 
4617     private boolean giveWarning(Type from, Type to) {
4618         List&lt;Type&gt; bounds = to.isCompound() ?
4619                 directSupertypes(to) : List.of(to);
4620         for (Type b : bounds) {
4621             Type subFrom = asSub(from, b.tsym);
4622             if (b.isParameterized() &amp;&amp;
4623                     (!(isUnbounded(b) ||
4624                     isSubtype(from, b) ||
4625                     ((subFrom != null) &amp;&amp; containsType(b.allparams(), subFrom.allparams()))))) {
4626                 return true;
4627             }
4628         }
4629         return false;
4630     }
4631 
4632     private List&lt;Type&gt; superClosure(Type t, Type s) {
4633         List&lt;Type&gt; cl = List.nil();
4634         for (List&lt;Type&gt; l = interfaces(t); l.nonEmpty(); l = l.tail) {
4635             if (isSubtype(s, erasure(l.head))) {
4636                 cl = insert(cl, l.head);
4637             } else {
4638                 cl = union(cl, superClosure(l.head, s));
4639             }
4640         }
4641         return cl;
4642     }
4643 
4644     private boolean containsTypeEquivalent(Type t, Type s) {
4645         return isSameType(t, s) || // shortcut
4646             containsType(t, s) &amp;&amp; containsType(s, t);
4647     }
4648 
4649     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;adapt&quot;&gt;
4650     /**
4651      * Adapt a type by computing a substitution which maps a source
4652      * type to a target type.
4653      *
4654      * @param source    the source type
4655      * @param target    the target type
4656      * @param from      the type variables of the computed substitution
4657      * @param to        the types of the computed substitution.
4658      */
4659     public void adapt(Type source,
4660                        Type target,
4661                        ListBuffer&lt;Type&gt; from,
4662                        ListBuffer&lt;Type&gt; to) throws AdaptFailure {
4663         new Adapter(from, to).adapt(source, target);
4664     }
4665 
4666     class Adapter extends SimpleVisitor&lt;Void, Type&gt; {
4667 
4668         ListBuffer&lt;Type&gt; from;
4669         ListBuffer&lt;Type&gt; to;
4670         Map&lt;Symbol,Type&gt; mapping;
4671 
4672         Adapter(ListBuffer&lt;Type&gt; from, ListBuffer&lt;Type&gt; to) {
4673             this.from = from;
4674             this.to = to;
4675             mapping = new HashMap&lt;&gt;();
4676         }
4677 
4678         public void adapt(Type source, Type target) throws AdaptFailure {
4679             visit(source, target);
4680             List&lt;Type&gt; fromList = from.toList();
4681             List&lt;Type&gt; toList = to.toList();
4682             while (!fromList.isEmpty()) {
4683                 Type val = mapping.get(fromList.head.tsym);
4684                 if (toList.head != val)
4685                     toList.head = val;
4686                 fromList = fromList.tail;
4687                 toList = toList.tail;
4688             }
4689         }
4690 
4691         @Override
4692         public Void visitClassType(ClassType source, Type target) throws AdaptFailure {
4693             if (target.hasTag(CLASS))
4694                 adaptRecursive(source.allparams(), target.allparams());
4695             return null;
4696         }
4697 
4698         @Override
4699         public Void visitArrayType(ArrayType source, Type target) throws AdaptFailure {
4700             if (target.hasTag(ARRAY))
4701                 adaptRecursive(elemtype(source), elemtype(target));
4702             return null;
4703         }
4704 
4705         @Override
4706         public Void visitWildcardType(WildcardType source, Type target) throws AdaptFailure {
4707             if (source.isExtendsBound())
4708                 adaptRecursive(wildUpperBound(source), wildUpperBound(target));
4709             else if (source.isSuperBound())
4710                 adaptRecursive(wildLowerBound(source), wildLowerBound(target));
4711             return null;
4712         }
4713 
4714         @Override
4715         public Void visitTypeVar(TypeVar source, Type target) throws AdaptFailure {
4716             // Check to see if there is
4717             // already a mapping for $source$, in which case
4718             // the old mapping will be merged with the new
4719             Type val = mapping.get(source.tsym);
4720             if (val != null) {
4721                 if (val.isSuperBound() &amp;&amp; target.isSuperBound()) {
4722                     val = isSubtype(wildLowerBound(val), wildLowerBound(target))
4723                         ? target : val;
4724                 } else if (val.isExtendsBound() &amp;&amp; target.isExtendsBound()) {
4725                     val = isSubtype(wildUpperBound(val), wildUpperBound(target))
4726                         ? val : target;
4727                 } else if (!isSameType(val, target)) {
4728                     throw new AdaptFailure();
4729                 }
4730             } else {
4731                 val = target;
4732                 from.append(source);
4733                 to.append(target);
4734             }
4735             mapping.put(source.tsym, val);
4736             return null;
4737         }
4738 
4739         @Override
4740         public Void visitType(Type source, Type target) {
4741             return null;
4742         }
4743 
4744         private Set&lt;TypePair&gt; cache = new HashSet&lt;&gt;();
4745 
4746         private void adaptRecursive(Type source, Type target) {
4747             TypePair pair = new TypePair(source, target);
4748             if (cache.add(pair)) {
4749                 try {
4750                     visit(source, target);
4751                 } finally {
4752                     cache.remove(pair);
4753                 }
4754             }
4755         }
4756 
4757         private void adaptRecursive(List&lt;Type&gt; source, List&lt;Type&gt; target) {
4758             if (source.length() == target.length()) {
4759                 while (source.nonEmpty()) {
4760                     adaptRecursive(source.head, target.head);
4761                     source = source.tail;
4762                     target = target.tail;
4763                 }
4764             }
4765         }
4766     }
4767 
4768     public static class AdaptFailure extends RuntimeException {
4769         static final long serialVersionUID = -7490231548272701566L;
4770     }
4771 
4772     private void adaptSelf(Type t,
4773                            ListBuffer&lt;Type&gt; from,
4774                            ListBuffer&lt;Type&gt; to) {
4775         try {
4776             //if (t.tsym.type != t)
4777                 adapt(t.tsym.type, t, from, to);
4778         } catch (AdaptFailure ex) {
4779             // Adapt should never fail calculating a mapping from
4780             // t.tsym.type to t as there can be no merge problem.
4781             throw new AssertionError(ex);
4782         }
4783     }
4784     // &lt;/editor-fold&gt;
4785 
4786     /**
4787      * Rewrite all type variables (universal quantifiers) in the given
4788      * type to wildcards (existential quantifiers).  This is used to
4789      * determine if a cast is allowed.  For example, if high is true
4790      * and {@code T &lt;: Number}, then {@code List&lt;T&gt;} is rewritten to
4791      * {@code List&lt;?  extends Number&gt;}.  Since {@code List&lt;Integer&gt; &lt;:
4792      * List&lt;? extends Number&gt;} a {@code List&lt;T&gt;} can be cast to {@code
4793      * List&lt;Integer&gt;} with a warning.
4794      * @param t a type
4795      * @param high if true return an upper bound; otherwise a lower
4796      * bound
4797      * @param rewriteTypeVars only rewrite captured wildcards if false;
4798      * otherwise rewrite all type variables
4799      * @return the type rewritten with wildcards (existential
4800      * quantifiers) only
4801      */
4802     private Type rewriteQuantifiers(Type t, boolean high, boolean rewriteTypeVars) {
4803         return new Rewriter(high, rewriteTypeVars).visit(t);
4804     }
4805 
4806     class Rewriter extends UnaryVisitor&lt;Type&gt; {
4807 
4808         boolean high;
4809         boolean rewriteTypeVars;
4810 
4811         Rewriter(boolean high, boolean rewriteTypeVars) {
4812             this.high = high;
4813             this.rewriteTypeVars = rewriteTypeVars;
4814         }
4815 
4816         @Override
4817         public Type visitClassType(ClassType t, Void s) {
4818             ListBuffer&lt;Type&gt; rewritten = new ListBuffer&lt;&gt;();
4819             boolean changed = false;
4820             for (Type arg : t.allparams()) {
4821                 Type bound = visit(arg);
4822                 if (arg != bound) {
4823                     changed = true;
4824                 }
4825                 rewritten.append(bound);
4826             }
4827             if (changed)
4828                 return subst(t.tsym.type,
4829                         t.tsym.type.allparams(),
4830                         rewritten.toList());
4831             else
4832                 return t;
4833         }
4834 
4835         public Type visitType(Type t, Void s) {
4836             return t;
4837         }
4838 
4839         @Override
4840         public Type visitCapturedType(CapturedType t, Void s) {
4841             Type w_bound = t.wildcard.type;
4842             Type bound = w_bound.contains(t) ?
4843                         erasure(w_bound) :
4844                         visit(w_bound);
4845             return rewriteAsWildcardType(visit(bound), t.wildcard.bound, t.wildcard.kind);
4846         }
4847 
4848         @Override
4849         public Type visitTypeVar(TypeVar t, Void s) {
4850             if (rewriteTypeVars) {
4851                 Type bound = t.getUpperBound().contains(t) ?
4852                         erasure(t.getUpperBound()) :
4853                         visit(t.getUpperBound());
4854                 return rewriteAsWildcardType(bound, t, EXTENDS);
4855             } else {
4856                 return t;
4857             }
4858         }
4859 
4860         @Override
4861         public Type visitWildcardType(WildcardType t, Void s) {
4862             Type bound2 = visit(t.type);
4863             return t.type == bound2 ? t : rewriteAsWildcardType(bound2, t.bound, t.kind);
4864         }
4865 
4866         private Type rewriteAsWildcardType(Type bound, TypeVar formal, BoundKind bk) {
4867             switch (bk) {
4868                case EXTENDS: return high ?
4869                        makeExtendsWildcard(B(bound), formal) :
4870                        makeExtendsWildcard(syms.objectType, formal);
4871                case SUPER: return high ?
4872                        makeSuperWildcard(syms.botType, formal) :
4873                        makeSuperWildcard(B(bound), formal);
4874                case UNBOUND: return makeExtendsWildcard(syms.objectType, formal);
4875                default:
4876                    Assert.error(&quot;Invalid bound kind &quot; + bk);
4877                    return null;
4878             }
4879         }
4880 
4881         Type B(Type t) {
4882             while (t.hasTag(WILDCARD)) {
4883                 WildcardType w = (WildcardType)t;
4884                 t = high ?
4885                     w.getExtendsBound() :
4886                     w.getSuperBound();
4887                 if (t == null) {
4888                     t = high ? syms.objectType : syms.botType;
4889                 }
4890             }
4891             return t;
4892         }
4893     }
4894 
4895 
4896     /**
4897      * Create a wildcard with the given upper (extends) bound; create
4898      * an unbounded wildcard if bound is Object.
4899      *
4900      * @param bound the upper bound
4901      * @param formal the formal type parameter that will be
4902      * substituted by the wildcard
4903      */
4904     private WildcardType makeExtendsWildcard(Type bound, TypeVar formal) {
4905         if (bound == syms.objectType) {
4906             return new WildcardType(syms.objectType,
4907                                     BoundKind.UNBOUND,
4908                                     syms.boundClass,
4909                                     formal);
4910         } else {
4911             return new WildcardType(bound,
4912                                     BoundKind.EXTENDS,
4913                                     syms.boundClass,
4914                                     formal);
4915         }
4916     }
4917 
4918     /**
4919      * Create a wildcard with the given lower (super) bound; create an
4920      * unbounded wildcard if bound is bottom (type of {@code null}).
4921      *
4922      * @param bound the lower bound
4923      * @param formal the formal type parameter that will be
4924      * substituted by the wildcard
4925      */
4926     private WildcardType makeSuperWildcard(Type bound, TypeVar formal) {
4927         if (bound.hasTag(BOT)) {
4928             return new WildcardType(syms.objectType,
4929                                     BoundKind.UNBOUND,
4930                                     syms.boundClass,
4931                                     formal);
4932         } else {
4933             return new WildcardType(bound,
4934                                     BoundKind.SUPER,
4935                                     syms.boundClass,
4936                                     formal);
4937         }
4938     }
4939 
4940     /**
4941      * A wrapper for a type that allows use in sets.
4942      */
4943     public static class UniqueType {
4944         public final Type type;
4945         final Types types;
4946         private boolean encodeTypeSig;
4947 
4948         public UniqueType(Type type, Types types, boolean encodeTypeSig) {
4949             this.type = type;
4950             this.types = types;
4951             this.encodeTypeSig = encodeTypeSig;
4952         }
4953 
4954         public UniqueType(Type type, Types types) {
4955             this(type, types, true);
4956         }
4957 
4958         public int hashCode() {
4959             return types.hashCode(type);
4960         }
4961 
4962         public boolean equals(Object obj) {
4963             return (obj instanceof UniqueType) &amp;&amp;
4964                 types.isSameType(type, ((UniqueType)obj).type);
4965         }
4966 
4967         public boolean encodeTypeSig() {
4968             return encodeTypeSig;
4969         }
4970 
4971         public String toString() {
4972             return type.toString();
4973         }
4974 
4975     }
4976     // &lt;/editor-fold&gt;
4977 
4978     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Visitors&quot;&gt;
4979     /**
4980      * A default visitor for types.  All visitor methods except
4981      * visitType are implemented by delegating to visitType.  Concrete
4982      * subclasses must provide an implementation of visitType and can
4983      * override other methods as needed.
4984      *
4985      * @param &lt;R&gt; the return type of the operation implemented by this
4986      * visitor; use Void if no return type is needed.
4987      * @param &lt;S&gt; the type of the second argument (the first being the
4988      * type itself) of the operation implemented by this visitor; use
4989      * Void if a second argument is not needed.
4990      */
4991     public static abstract class DefaultTypeVisitor&lt;R,S&gt; implements Type.Visitor&lt;R,S&gt; {
4992         final public R visit(Type t, S s)               { return t.accept(this, s); }
4993         public R visitClassType(ClassType t, S s)       { return visitType(t, s); }
4994         public R visitWildcardType(WildcardType t, S s) { return visitType(t, s); }
4995         public R visitArrayType(ArrayType t, S s)       { return visitType(t, s); }
4996         public R visitMethodType(MethodType t, S s)     { return visitType(t, s); }
4997         public R visitPackageType(PackageType t, S s)   { return visitType(t, s); }
4998         public R visitModuleType(ModuleType t, S s)     { return visitType(t, s); }
4999         public R visitTypeVar(TypeVar t, S s)           { return visitType(t, s); }
5000         public R visitCapturedType(CapturedType t, S s) { return visitType(t, s); }
5001         public R visitForAll(ForAll t, S s)             { return visitType(t, s); }
5002         public R visitUndetVar(UndetVar t, S s)         { return visitType(t, s); }
5003         public R visitErrorType(ErrorType t, S s)       { return visitType(t, s); }
5004     }
5005 
5006     /**
5007      * A default visitor for symbols.  All visitor methods except
5008      * visitSymbol are implemented by delegating to visitSymbol.  Concrete
5009      * subclasses must provide an implementation of visitSymbol and can
5010      * override other methods as needed.
5011      *
5012      * @param &lt;R&gt; the return type of the operation implemented by this
5013      * visitor; use Void if no return type is needed.
5014      * @param &lt;S&gt; the type of the second argument (the first being the
5015      * symbol itself) of the operation implemented by this visitor; use
5016      * Void if a second argument is not needed.
5017      */
5018     public static abstract class DefaultSymbolVisitor&lt;R,S&gt; implements Symbol.Visitor&lt;R,S&gt; {
5019         final public R visit(Symbol s, S arg)                   { return s.accept(this, arg); }
5020         public R visitClassSymbol(ClassSymbol s, S arg)         { return visitSymbol(s, arg); }
5021         public R visitMethodSymbol(MethodSymbol s, S arg)       { return visitSymbol(s, arg); }
5022         public R visitOperatorSymbol(OperatorSymbol s, S arg)   { return visitSymbol(s, arg); }
5023         public R visitPackageSymbol(PackageSymbol s, S arg)     { return visitSymbol(s, arg); }
5024         public R visitTypeSymbol(TypeSymbol s, S arg)           { return visitSymbol(s, arg); }
5025         public R visitVarSymbol(VarSymbol s, S arg)             { return visitSymbol(s, arg); }
5026     }
5027 
5028     /**
5029      * A &lt;em&gt;simple&lt;/em&gt; visitor for types.  This visitor is simple as
5030      * captured wildcards, for-all types (generic methods), and
5031      * undetermined type variables (part of inference) are hidden.
5032      * Captured wildcards are hidden by treating them as type
5033      * variables and the rest are hidden by visiting their qtypes.
5034      *
5035      * @param &lt;R&gt; the return type of the operation implemented by this
5036      * visitor; use Void if no return type is needed.
5037      * @param &lt;S&gt; the type of the second argument (the first being the
5038      * type itself) of the operation implemented by this visitor; use
5039      * Void if a second argument is not needed.
5040      */
5041     public static abstract class SimpleVisitor&lt;R,S&gt; extends DefaultTypeVisitor&lt;R,S&gt; {
5042         @Override
5043         public R visitCapturedType(CapturedType t, S s) {
5044             return visitTypeVar(t, s);
5045         }
5046         @Override
5047         public R visitForAll(ForAll t, S s) {
5048             return visit(t.qtype, s);
5049         }
5050         @Override
5051         public R visitUndetVar(UndetVar t, S s) {
5052             return visit(t.qtype, s);
5053         }
5054     }
5055 
5056     /**
5057      * A plain relation on types.  That is a 2-ary function on the
5058      * form Type&amp;nbsp;&amp;times;&amp;nbsp;Type&amp;nbsp;&amp;rarr;&amp;nbsp;Boolean.
5059      * &lt;!-- In plain text: Type x Type -&gt; Boolean --&gt;
5060      */
5061     public static abstract class TypeRelation extends SimpleVisitor&lt;Boolean,Type&gt; {}
5062 
5063     /**
5064      * A convenience visitor for implementing operations that only
5065      * require one argument (the type itself), that is, unary
5066      * operations.
5067      *
5068      * @param &lt;R&gt; the return type of the operation implemented by this
5069      * visitor; use Void if no return type is needed.
5070      */
5071     public static abstract class UnaryVisitor&lt;R&gt; extends SimpleVisitor&lt;R,Void&gt; {
5072         final public R visit(Type t) { return t.accept(this, null); }
5073     }
5074 
5075     /**
5076      * A visitor for implementing a mapping from types to types.  The
5077      * default behavior of this class is to implement the identity
5078      * mapping (mapping a type to itself).  This can be overridden in
5079      * subclasses.
5080      *
5081      * @param &lt;S&gt; the type of the second argument (the first being the
5082      * type itself) of this mapping; use Void if a second argument is
5083      * not needed.
5084      */
5085     public static class MapVisitor&lt;S&gt; extends DefaultTypeVisitor&lt;Type,S&gt; {
5086         final public Type visit(Type t) { return t.accept(this, null); }
5087         public Type visitType(Type t, S s) { return t; }
5088     }
5089 
5090     /**
5091      * An abstract class for mappings from types to types (see {@link Type#map(TypeMapping)}.
5092      * This class implements the functional interface {@code Function}, that allows it to be used
5093      * fluently in stream-like processing.
5094      */
5095     public static class TypeMapping&lt;S&gt; extends MapVisitor&lt;S&gt; implements Function&lt;Type, Type&gt; {
5096         @Override
5097         public Type apply(Type type) { return visit(type); }
5098 
5099         List&lt;Type&gt; visit(List&lt;Type&gt; ts, S s) {
5100             return ts.map(t -&gt; visit(t, s));
5101         }
5102 
5103         @Override
5104         public Type visitCapturedType(CapturedType t, S s) {
5105             return visitTypeVar(t, s);
5106         }
5107     }
5108     // &lt;/editor-fold&gt;
5109 
5110 
5111     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Annotation support&quot;&gt;
5112 
5113     public RetentionPolicy getRetention(Attribute.Compound a) {
5114         return getRetention(a.type.tsym);
5115     }
5116 
5117     public RetentionPolicy getRetention(TypeSymbol sym) {
5118         RetentionPolicy vis = RetentionPolicy.CLASS; // the default
5119         Attribute.Compound c = sym.attribute(syms.retentionType.tsym);
5120         if (c != null) {
5121             Attribute value = c.member(names.value);
5122             if (value != null &amp;&amp; value instanceof Attribute.Enum) {
5123                 Name levelName = ((Attribute.Enum)value).value.name;
5124                 if (levelName == names.SOURCE) vis = RetentionPolicy.SOURCE;
5125                 else if (levelName == names.CLASS) vis = RetentionPolicy.CLASS;
5126                 else if (levelName == names.RUNTIME) vis = RetentionPolicy.RUNTIME;
5127                 else ;// /* fail soft */ throw new AssertionError(levelName);
5128             }
5129         }
5130         return vis;
5131     }
5132     // &lt;/editor-fold&gt;
5133 
5134     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot;Signature Generation&quot;&gt;
5135 
5136     public static abstract class SignatureGenerator {
5137 
5138         public static class InvalidSignatureException extends RuntimeException {
5139             private static final long serialVersionUID = 0;
5140 
5141             private final transient Type type;
5142 
5143             InvalidSignatureException(Type type) {
5144                 this.type = type;
5145             }
5146 
5147             public Type type() {
5148                 return type;
5149             }
5150         }
5151 
5152         private final Types types;
5153 
5154         protected abstract void append(char ch);
5155         protected abstract void append(byte[] ba);
5156         protected abstract void append(Name name);
5157         protected void classReference(ClassSymbol c) { /* by default: no-op */ }
5158 
5159         protected SignatureGenerator(Types types) {
5160             this.types = types;
5161         }
5162 
5163         protected void reportIllegalSignature(Type t) {
5164             throw new InvalidSignatureException(t);
5165         }
5166 
5167         /**
5168          * Assemble signature of given type in string buffer.
5169          */
5170         public void assembleSig(Type type) {
5171             switch (type.getTag()) {
5172                 case BYTE:
5173                     append(&#39;B&#39;);
5174                     break;
5175                 case SHORT:
5176                     append(&#39;S&#39;);
5177                     break;
5178                 case CHAR:
5179                     append(&#39;C&#39;);
5180                     break;
5181                 case INT:
5182                     append(&#39;I&#39;);
5183                     break;
5184                 case LONG:
5185                     append(&#39;J&#39;);
5186                     break;
5187                 case FLOAT:
5188                     append(&#39;F&#39;);
5189                     break;
5190                 case DOUBLE:
5191                     append(&#39;D&#39;);
5192                     break;
5193                 case BOOLEAN:
5194                     append(&#39;Z&#39;);
5195                     break;
5196                 case VOID:
5197                     append(&#39;V&#39;);
5198                     break;
5199                 case CLASS:
5200                     if (type.isCompound()) {
5201                         reportIllegalSignature(type);
5202                     }
5203                     if (types.isValue(type))
5204                         append(&#39;Q&#39;);
5205                     else
5206                         append(&#39;L&#39;);
5207                     assembleClassSig(type);
5208                     append(&#39;;&#39;);
5209                     break;
5210                 case ARRAY:
5211                     ArrayType at = (ArrayType) type;
5212                     append(&#39;[&#39;);
5213                     assembleSig(at.elemtype);
5214                     break;
5215                 case METHOD:
5216                     MethodType mt = (MethodType) type;
5217                     append(&#39;(&#39;);
5218                     assembleSig(mt.argtypes);
5219                     append(&#39;)&#39;);
5220                     assembleSig(mt.restype);
5221                     if (hasTypeVar(mt.thrown)) {
5222                         for (List&lt;Type&gt; l = mt.thrown; l.nonEmpty(); l = l.tail) {
5223                             append(&#39;^&#39;);
5224                             assembleSig(l.head);
5225                         }
5226                     }
5227                     break;
5228                 case WILDCARD: {
5229                     Type.WildcardType ta = (Type.WildcardType) type;
5230                     switch (ta.kind) {
5231                         case SUPER:
5232                             append(&#39;-&#39;);
5233                             assembleSig(ta.type);
5234                             break;
5235                         case EXTENDS:
5236                             append(&#39;+&#39;);
5237                             assembleSig(ta.type);
5238                             break;
5239                         case UNBOUND:
5240                             append(&#39;*&#39;);
5241                             break;
5242                         default:
5243                             throw new AssertionError(ta.kind);
5244                     }
5245                     break;
5246                 }
5247                 case TYPEVAR:
5248                     if (((TypeVar)type).isCaptured()) {
5249                         reportIllegalSignature(type);
5250                     }
5251                     append(&#39;T&#39;);
5252                     append(type.tsym.name);
5253                     append(&#39;;&#39;);
5254                     break;
5255                 case FORALL:
5256                     Type.ForAll ft = (Type.ForAll) type;
5257                     assembleParamsSig(ft.tvars);
5258                     assembleSig(ft.qtype);
5259                     break;
5260                 default:
5261                     throw new AssertionError(&quot;typeSig &quot; + type.getTag());
5262             }
5263         }
5264 
5265         public boolean hasTypeVar(List&lt;Type&gt; l) {
5266             while (l.nonEmpty()) {
5267                 if (l.head.hasTag(TypeTag.TYPEVAR)) {
5268                     return true;
5269                 }
5270                 l = l.tail;
5271             }
5272             return false;
5273         }
5274 
5275         public void assembleClassSig(Type type) {
5276             ClassType ct = (ClassType) type;
5277             ClassSymbol c = (ClassSymbol) ct.tsym;
5278             classReference(c);
5279             Type outer = ct.getEnclosingType();
5280             if (outer.allparams().nonEmpty()) {
5281                 boolean rawOuter =
5282                         c.owner.kind == MTH || // either a local class
5283                         c.name == types.names.empty; // or anonymous
5284                 assembleClassSig(rawOuter
5285                         ? types.erasure(outer)
5286                         : outer);
5287                 append(rawOuter ? &#39;$&#39; : &#39;.&#39;);
5288                 Assert.check(c.flatname.startsWith(c.owner.enclClass().flatname));
5289                 append(rawOuter
5290                         ? c.flatname.subName(c.owner.enclClass().flatname.getByteLength() + 1, c.flatname.getByteLength())
5291                         : c.name);
5292             } else {
5293                 append(externalize(c.flatname));
5294             }
5295             if (ct.getTypeArguments().nonEmpty()) {
5296                 append(&#39;&lt;&#39;);
5297                 assembleSig(ct.getTypeArguments());
5298                 append(&#39;&gt;&#39;);
5299             }
5300         }
5301 
5302         public void assembleParamsSig(List&lt;Type&gt; typarams) {
5303             append(&#39;&lt;&#39;);
5304             for (List&lt;Type&gt; ts = typarams; ts.nonEmpty(); ts = ts.tail) {
5305                 Type.TypeVar tvar = (Type.TypeVar) ts.head;
5306                 append(tvar.tsym.name);
5307                 List&lt;Type&gt; bounds = types.getBounds(tvar);
5308                 if ((bounds.head.tsym.flags() &amp; INTERFACE) != 0) {
5309                     append(&#39;:&#39;);
5310                 }
5311                 for (List&lt;Type&gt; l = bounds; l.nonEmpty(); l = l.tail) {
5312                     append(&#39;:&#39;);
5313                     assembleSig(l.head);
5314                 }
5315             }
5316             append(&#39;&gt;&#39;);
5317         }
5318 
5319         public void assembleSig(List&lt;Type&gt; types) {
5320             for (List&lt;Type&gt; ts = types; ts.nonEmpty(); ts = ts.tail) {
5321                 assembleSig(ts.head);
5322             }
5323         }
5324     }
5325 
5326     public Type constantType(LoadableConstant c) {
5327         switch (c.poolTag()) {
5328             case ClassFile.CONSTANT_Class:
5329                 return syms.classType;
5330             case ClassFile.CONSTANT_String:
5331                 return syms.stringType;
5332             case ClassFile.CONSTANT_Integer:
5333                 return syms.intType;
5334             case ClassFile.CONSTANT_Float:
5335                 return syms.floatType;
5336             case ClassFile.CONSTANT_Long:
5337                 return syms.longType;
5338             case ClassFile.CONSTANT_Double:
5339                 return syms.doubleType;
5340             case ClassFile.CONSTANT_MethodHandle:
5341                 return syms.methodHandleType;
5342             case ClassFile.CONSTANT_MethodType:
5343                 return syms.methodTypeType;
5344             case ClassFile.CONSTANT_Dynamic:
5345                 return ((DynamicVarSymbol)c).type;
5346             default:
5347                 throw new AssertionError(&quot;Not a loadable constant: &quot; + c.poolTag());
5348         }
5349     }
5350     // &lt;/editor-fold&gt;
5351 
5352     public void newRound() {
5353         descCache._map.clear();
5354         isDerivedRawCache.clear();
5355         implCache._map.clear();
5356         membersCache._map.clear();
5357         closureCache.clear();
5358     }
5359 }
    </pre>
  </body>
</html>